00:05:21 <liangzan> sorry, i’ve hit a wall in haskell
00:05:24 <liangzan> http://lpaste.net/353765
00:05:40 <liangzan> i’m using mysql-simple. but i can’t get a query function to compile
00:05:58 <liangzan> any idea what i should do?
00:06:42 <jle`> liangzan: it looks like you need to specify what type you want
00:06:52 <jle`> there's really no way to infer, from the code you wrote
00:07:02 <liangzan> yup, but how?
00:07:04 <jle`> you can add a type annotatio somewhere, maybe
00:07:11 <jle`> what should the type of xs be?
00:07:22 <liangzan> it should be a list of tuples
00:07:26 <jle`> tuples of what
00:07:40 <liangzan> a 54 arg tuple
00:07:47 <liangzan> with strings, ints, etc
00:07:58 <jle`> do you know what the type of the thing you want is
00:08:06 <jle`> then you can provide an annotation
00:08:07 <liangzan> i just hope to match for empty lists
00:08:17 <jle`> case xs :: [(Int, Bool)] of ...
00:08:29 <liangzan> ah har
00:08:38 <liangzan> but i have a 54 arg tuple
00:08:47 <jle`> why in the world do you have a 54-tuple lol
00:08:56 <liangzan> well, its a select sql statement
00:09:08 <jle`> try selecting less things
00:09:21 <jle`> well, i'm not really sure how mysql-simple works exactly
00:09:21 <liangzan> alright, thanks jie`!
00:09:31 <pavonia> If you only want to check foe empty results, you can just select the ID
00:10:13 <liangzan> i don’t want to touch the sql if need be
00:10:37 <liste> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) -- 54 is almost pushing the limits anyway
00:10:39 <lambdabot> error:
00:10:39 <lambdabot>     A 96-tuple is too large for GHC
00:10:39 <lambdabot>       (max size is 62)
00:13:22 <xdfreak22> hey
00:14:15 <xdfreak22> anyone home
00:14:20 <jle`> liangzan: it looks like the library needs to know what types you want, because the types you expect determine how it parses the result
00:14:26 <xdfreak22> whats up
00:14:28 <jle`> liangzan: but, i wonder if you can just expect [()]
00:14:37 <xdfreak22> anyone use freebsd?
00:14:48 <liangzan> let me try
00:14:57 <jle`> xdfreak22: if your question is related to haskell, just ask it :)
00:15:20 <oz3n> this is my first time on an irc chat
00:15:31 <oz3n> well my first time on irc
00:15:40 <oz3n> I just wanted to try it out. 
00:15:43 <jle`> welcome :)
00:15:47 <oz3n> thanks
00:15:49 <jle`> if you have a question about haskell or want to discuss it you can ask here
00:15:59 <jle`> but if your question is about freebsd, you might want to ask in a more relevant channel
00:15:59 <oz3n> If anyone knows anything about freebsd
00:16:07 <oz3n> such as?
00:16:21 <jle`> like #freebsd
00:16:28 <oz3n> What do u typically discuss in haskell?
00:16:32 <oz3n> thanks
00:16:51 <jle`> um people ask questions about their haskell programs, or discuss things about haskell the programming language
00:16:59 <oz3n> oh okay
00:17:09 <jle`> like current events or connecting with other programms and fun stuff like that :)
00:17:28 <jle`> *programmers
00:17:49 <oz3n> In that case, your thoughts on Trump/
00:17:51 <oz3n> ?
00:18:08 <jle`> that would probably be a clear-cut off-topic
00:18:12 <oz3n> okay
00:18:12 <kylefang> hey guys, quick question. how can I make something like this point free? `\x -> x ++ ".md"`
00:18:17 <jle`> i meant current events about haskell, heh
00:18:21 <oz3n> ill try another channel
00:18:24 <oz3n> thanks
00:18:32 <jle`> kylefang: (++".md") would be the direct translation
00:18:38 <pacak> > (++".md") "foo"
00:18:40 <lambdabot>  "foo.md"
00:18:51 <jle`> but if you're working with a filepath then you can use (<.> "md") as well, from the filepath library
00:19:09 <kylefang> jle`: awesome,.. thanks
00:20:03 <jle`> no problem
00:20:12 <jle`> for the record there's @pl if you want to try it out in private chat with lambdabot
00:20:20 <jle`> @pl \x -> x ++ ".md"
00:20:20 <lambdabot> (++ ".md")
00:20:46 <kylefang> wow
00:21:00 <kylefang> that's amazing, thanks @jle`
00:21:14 <jle`> np!
00:22:20 <jle`> but yeah, if you're working with filepaths, it's nice to work with them abstractly instead of as strings, because of differences in posix/windows, normalization, etc.
00:22:39 <jle`> <.> has some extra logic to make sure that the result makes sense
00:23:10 <liangzan> @jie` xs :: [Char] works
00:23:10 <lambdabot> Unknown command, try @list
00:23:24 <jle`> liangzan: nice :)
00:23:32 <liangzan> but its not representing the actual type. but i only want to match empty lists, so...
00:23:39 <jle`> i'm not sure what sort of behavior mysql-simple defines for that
00:23:52 <jle`> you should probably check the result to make sure it does what you want
00:23:57 <liangzan> Char for 54-tuple for now
00:24:03 <liangzan> yup
00:24:10 <jle`> does it return a string representation of the 54-tuple?
00:24:40 <jle`> fun stuff
00:24:49 <JavaSucksMan> what was that @pl thing... it looked cool
00:25:09 <boxscape> JavaSucksMan: returns a version of the code you give it without variables
00:25:14 <jle`> it's called pointless; it tries its best to make functions point-free
00:25:29 <JavaSucksMan> cool... let me try
00:25:40 <jle`> @pl \xs -> foldr (+) 0 xs
00:25:40 <lambdabot> foldr (+) 0
00:25:56 <jle`> so you can rewrite the function without having to name any variables
00:25:58 <boxscape> @pl \x y z -> z y x
00:25:58 <lambdabot> flip (flip . flip id)
00:26:12 <jle`> it's called pointless because usually the results are unusable
00:26:40 <jle`> but in rare occasions the result might be more readable than the original
00:27:22 <kylefang> jle`: hahhah, but for it's really useful for learning the syntax.
00:27:26 <JavaSucksMan> @pl \stuff = foldr (&&) True $ zipWith (<) stuff (tail stuff)
00:27:26 <lambdabot> (line 1, column 8):
00:27:27 <lambdabot> unexpected "="
00:27:27 <lambdabot> expecting operator, pattern or "->"
00:27:28 <boxscape> there's also unpl
00:27:29 <boxscape> @unpl flip (flip . flip id)
00:27:29 <lambdabot> (\ x y y0 -> y0 y x)
00:27:41 <JavaSucksMan> @pl \stuff -> foldr (&&) True $ zipWith (<) stuff (tail stuff)
00:27:41 <lambdabot> foldr (&&) True . ap (zipWith (<)) tail
00:27:44 <jle`> for personal usage you can use it in a private query with lambdabot, using /msg lambdabot @pl blah
00:28:19 <boxscape> (I'd recommend /query instead of /msg)
00:28:45 <jle`> oh, i yes, i meant that, sorry
00:28:54 <kylefang> boxscape: how so?
00:29:32 <boxscape> kylefang: I prefer to have the conversation open in an extra tab, which query does with all irc clients I know, but msg doesn't (at least not with all clients)
00:30:43 <kylefang> boxscape: got it. :)
00:32:24 <JavaSucksMan> yeah.. the point-free version looks more like a puzzle unless it's trivial
00:33:32 <JavaSucksMan> @unpl foldr (&&) True . ap (zipWith (<)) tail
00:33:32 <lambdabot> (\ x -> foldr (&&) True ((zipWith (<) >>= \ x1 -> tail >>= \ x2 -> return (x1 x2)) x))
00:33:53 <JavaSucksMan> hmm round-trip with pl and unpl is even worse ;-)
00:34:07 <jle`> @. unpl pl \stuff -> foldr (&&) True $ zipWith (<) stuff (tail stuff)
00:34:08 <lambdabot> (\ x -> foldr (&&) True ((zipWith (<) >>= \ x1 -> tail >>= \ x2 -> return (x1 x2)) x))
00:34:56 <jle`> @. pl unpl foldr (+) 0 . map (*2)
00:34:56 <lambdabot> foldr (+) 0 . map (2 *)
00:35:31 <JavaSucksMan> yeah... that's trivial... try a function that uses it's parameter twice.
00:35:33 <jle`> usually (pl . unpl) is close to id, heh
00:35:53 <jle`> but in this case pl thought it was ok to rewrite (*2) as (2*)
00:36:35 <jle`> @. pl unpl foldr (&&) True . ap (zipWith (<)) tail
00:36:36 <lambdabot> foldr (&&) True . ((tail >>=) . (return .) =<< zipWith (<))
00:36:58 <jle`> welp so much for 'pl . unpl' being id
00:37:18 <JavaSucksMan> @pl \stuff -> foldr (&&) True $ zipWith (<) stuff (tail stuff) -- isSorted
00:37:18 <lambdabot> foldr (&&) True . ap (zipWith (<)) tail
00:38:01 <boxscape> isn't foldr (&&) True just and?
00:38:16 <jle`> yes pl isn't too intelligent, it mostly does text subsitutions
00:38:17 <JavaSucksMan> :t and
00:38:19 <lambdabot> Foldable t => t Bool -> Bool
00:38:30 <JavaSucksMan> yeah... I'm a Haskell noob
00:38:47 <boxscape> You pick those library functions up over time :)
00:39:38 <JavaSucksMan> I'm starting to put '--' comments into my bash scripts.... I hate switching languages
00:40:38 <boxscape> that's what commenting plugins in editors are for :P
00:43:16 <halogenandtoast> Let's say I wanted to test this function shuffleDeck :: RandomGen gen => gen -> State Deck ()
00:43:27 <halogenandtoast> What would be the best way to do that?
00:43:43 <jle`> you can write property tests with quickcheck
00:43:50 <jle`> or do you mean like test interactively
00:43:59 <halogenandtoast> with something like quickcheck
00:44:06 <halogenandtoast> I'm not sure what I'd be testing for though
00:44:12 <jle`> you'd have to think of properties
00:44:42 <jle`> like, the size of the starting deck is equal to the size of the ending deck
00:44:54 <jle`> quickcheck will generate random decks and gens to test it with
00:45:12 <jle`> it also might be easier to unroll 'State Deck ()' into 'Deck -> Deck'
00:45:31 <jle`> but that's just execState :: State Deck () -> (Deck -> Deck) anyway
00:47:03 <jle`> imo 'State s ()' isn't a very useful way to offer an (s -> s), but i guess it depends on context
00:48:10 <halogenandtoast> I do that because of this
00:48:10 <halogenandtoast>     ((hand1, hand2), deck) = flip runState initialDeck $ do
00:48:10 <halogenandtoast>       shuffleDeck gen
00:48:11 <halogenandtoast>       (,) <$> draw 7 <*> draw 7
00:48:31 <halogenandtoast> There might be a better way to do that.
00:48:32 <jle`> yeah, but you can convert a (Deck -> Deck) into a State Deck () pretty easily
00:48:38 <jle`> using modify :: (Deck -> Deck) -> State Deck ()
00:49:06 <halogenandtoast> Hmmm
00:49:10 <jle`> not a big deal though in the grand scheme of things
00:49:13 <halogenandtoast> I will try this out
00:49:30 <jle`> but haskell is pretty good at working with normal functions
00:49:41 <jle`> and it's easy to unwrap/wrap it into State if you need it
00:49:56 <jle`> if you're going to write a property test, you're going to be writing it on the unwrapped (Deck -> Deck) anyway
00:50:39 <jle`> (not a big deal, just a style thing.  if you use the wrapped version more than the unwrapped one then there isn't anything wrong with exposing the wrapped version normally)
00:50:48 <halogenandtoast> jle`: Ah yeah it works, that is awesome
00:50:52 <halogenandtoast> did not know about modify
00:51:02 <halogenandtoast> just now learning how to use the State monad
00:51:17 <jle`> yup, modify is the inverse of execState in that they wrap/unwrap (s -> s)'s from State
00:51:35 <halogenandtoast> I originally didn't want to put that function in the state monad but didn't know about modify
00:52:20 <jle`> my general style is to leave things as unwrapped normal functions by default and wrap them/lift them at the usage site
00:52:46 <halogenandtoast> would you have draw as unwrapped?
00:53:05 <jle`> it also depends on how often you'd use draw in the unwrapped form
00:53:14 <jle`> in this case it looks like it's more useful as State Deck Card
00:53:28 <jle`> because how often do you want to use an explicit Deck -> (Card, Deck)
00:53:30 <halogenandtoast> Yeah I don't think I'll ever use it unwrapped
00:54:31 <jle`> but, it's good to be familiar with the transformation, and recognizing that the two representations are the same
00:54:48 <halogenandtoast> Right
00:54:52 <jle`> modify (f . g) = modify g >> modify f
00:55:54 <jle`> which makes modify structure-preserving with respect to function composition
00:56:33 <halogenandtoast> thanks for the help jle` definitely added a new tool to my toolbox today
00:56:40 <jle`> no problem!
01:00:25 <halogenandtoast> I had a function I wanted to try to oneline, but I now wonder if maybe there is a better way? draw c = get >>= liftM2 (>>) (put . drop c) (return . take c)
01:00:51 <jle`> lol yes do not one-line that
01:01:24 <jle`> hm
01:01:29 <halogenandtoast> lol okay originally it was deck <- get; put $ drop c deck; return $ take c deck
01:01:35 <halogenandtoast> but on three lines
01:01:44 <jle`> draw c = state $ \d -> (take c d, drop c d)
01:01:44 <halogenandtoast> and the structure seemed so simple I thought I could one line it.
01:01:58 <jle`> you can think of 'state' as "modify + return"
01:02:17 <jle`> state lets you modify but also give a return value at the same time
01:03:06 <halogenandtoast> jle`: Awesome
01:03:21 <halogenandtoast> I don't like hlints suggestion for that though: Use &&& Found: \ d -> (take c d, drop c d) Why not: (take c Control.Arrow.&&& drop c)
01:03:25 <jle`> but the three line version is fine too
01:04:01 <jle`> yeah, i'm not too big of a fan with that
01:04:05 <ClaudiusMaximus> hlint should suggest splitAt instead!
01:04:45 <jle`> &&&/*** makes the most sense when you're doing tuple manipulation (if at all), which doesn't really describe what's going on here
01:05:00 <halogenandtoast> splitAt is definitely the right way to go
01:05:27 <halogenandtoast> ClaudiusMaximus: Thanks!
01:05:45 <halogenandtoast> Now it has become: draw c = state $ splitAt c
01:06:03 <jle`> cute :)
01:06:10 <halogenandtoast> or just draw = state . splitAt
01:06:21 <jle`> now just think about which one will be easier for you to understand when you look at the code again in a month
01:06:44 <halogenandtoast> jle`: Sure, but I think the  method name plus type signature give it away
01:06:56 <halogenandtoast> *function
01:07:29 <halogenandtoast> I consider that one of Haskell's super powers
01:07:31 <jle`> s/understand/understand enough to modify
01:08:05 <halogenandtoast> jle`: True, I'm hoping it's so simple now that I never have to modify it (in this situation)
01:08:28 <halogenandtoast> But ideally all of my functions would be so small and as to do only one thing (when possible) that they won't often change
01:08:57 <jle`> fair, but yeah, it's always a tradeoff
01:09:06 <halogenandtoast> right now `state . splitAt` is pretty easy for me to understand and I can read it almost instantly
01:09:22 <halogenandtoast> I'll let you know in two weeks
01:09:28 <halogenandtoast> err 1 month
01:09:49 <jle`> i'm rooting for you, of course :)
01:10:07 <jle`> i just always try to program to a future me who is a little less inteligent than i am
01:10:46 <halogenandtoast> ha ha ha thanks jle` I definitely won't inline everything because at some point you fail to express what is happening
01:11:24 <halogenandtoast> Usually if I need `ap` of `liftM2` and friends I consider it not worth it
01:11:29 <halogenandtoast> s/of/or/
01:11:51 <halogenandtoast> because those don't translate to anything for me.
01:14:26 <halogenandtoast> I'm also on the fence for things like this: handFor = (playerHand .) . getPlayer
01:15:00 <halogenandtoast> Not sure if double dots are worth it to be point free
01:15:29 <halogenandtoast> type signature for that: getPlayer :: PlayerNumber -> GameState -> Player
01:15:44 <halogenandtoast> err
01:15:49 <halogenandtoast> handFor :: PlayerNumber -> GameState -> Hand
01:15:56 <jle`> i don't think anyone finds that more readable than handFor p = playerHand . getPlayer p
01:16:13 <jle`> or handFor p s = playerHand (getPlayer p s) even
01:16:40 <halogenandtoast> why not handFor p s = playerHand $ getPlayer p s
01:16:44 <jle`> some people introduce an operator f .: g = \x y -> f (g x y), so you could write it as handFor = playerHand .: getPlayer
01:17:30 <jle`> i don't think it's really worth it myself, heh, but .: is ubiquitous enough i suppose
01:17:32 <halogenandtoast> jle`: and if I have 3 arguments? .:⋮
01:18:28 <halogenandtoast> I haven't seen or used .: yet
01:18:46 <JavaSucksMan> when I'm in a bottom-up mood, I define  ($$) = flip ($)
01:19:01 <jle`> JavaSucksMan: you're in luck, flip ($) is now in base
01:19:06 <jle`> as of ghc 7.10 or something
01:19:13 <JavaSucksMan> as what?
01:19:17 <jle`> (&)
01:19:34 <jle`> in Data.Function
01:19:51 <JavaSucksMan> great, now im going to get & and && confused (try reading that aloud)
01:20:26 <jle`> i wouldn't mind a flip fmap, like <&>, but i think there are some issues with picking the fixity, because a lot of libraries separately define <&> with mutually incompatible fixities
01:21:08 <JavaSucksMan> I think I saw the (&) in some code and wrote it off as one of those monad/arrow confusing operators im not yet ready for
01:21:11 <jle`> just mostly for the same reasin that 'for'/'forM' was useful
01:21:15 <halogenandtoast> JavaSucksMan: I've learned a long time ago to read "&&" as "boolean and"
01:22:47 <JavaSucksMan> my roommate has a weird one-sylable way of reading all of the ascii symbols... >>= is rang rang eek
01:24:01 <halogenandtoast> rang for right angle? so I assume < is lang?
01:25:05 <quchen> »>>« is pronounced »bi«, and »=« is pronounced »nd«.
01:25:10 <Unhammer> JavaSucksMan,  is it this guy https://www.youtube.com/watch?v=8SkdfdXWYaI ?
01:25:46 <JavaSucksMan> yup... im too tired to dig out his whole glossary, and he's in argentina now
01:26:29 <JavaSucksMan> No... but I LOVE that talk! seen (or heard) it many times
01:26:54 <liste> quchen: strangely enough, the symbol for "ND" (no derivatives) in CC licensing is =: https://creativecommons.org/licenses/by-nd/3.0/
01:27:10 <quchen> Hah!
01:27:22 <JavaSucksMan> It's the guy who did patch-tag.... a no longer existing darcsden competitor
01:27:46 <Unhammer> mm, made me want to try too (but my hands got better after starting to use a real desk + chair + external monitor and working at an office with people who have lunch away from the computer)
01:29:50 <JavaSucksMan> Yeah... your chair is the most important piece of computer equipment you'll ever buy.
01:30:44 <JavaSucksMan> I'm actually working on a gestural programming language loosely inspired by ASL, and vastly inspired by that talk
01:31:07 <JavaSucksMan> or maybe its the other way around ;-)
01:31:20 <Unhammer> uhm
01:32:12 <Unhammer> sign language is cool and all, but there's a difference between signing as much as you talk, and signing as much as you code
01:32:44 <Unhammer> https://eric.ed.gov/?id=EJ447185
01:33:28 <JavaSucksMan> Well I can't code as fast as I talk in either English or ASL, so I'm not sure if that's relevant
01:49:18 <dmj`> JavaSucksMan: nice nick
01:49:37 <halogenandtoast> Are these different in any way (aside from syntax): liftM2 (+) (Just 1) Nothing and (+) <$> Just 1 <*> Nothing
01:51:25 <dmj`> @src liftA
01:51:26 <lambdabot> liftA f a = pure f <*> a
01:51:33 <dmj`> @src liftA2
01:51:34 <lambdabot> liftA2 f a b = f <$> a <*> b
01:51:46 <halogenandtoast> so no
01:51:54 <dmj`> @src liftM2
01:51:54 <lambdabot> liftM2 f m1 m2 = do
01:51:54 <lambdabot>     x1 <- m1
01:51:54 <lambdabot>     x2 <- m2
01:51:54 <lambdabot>     return (f x1 x2)
01:52:26 <dmj`> they’re equivalent, and liftM2 can probably be abolished, but it would break a lot of things
01:53:15 <halogenandtoast> Hmm the source of liftM2 makes no sense to me
01:53:27 <halogenandtoast> I can't see how (+) <$> Just 1 <*> Nothing would work
01:53:31 <halogenandtoast> x2 <- Nothing ??
01:53:57 <Cale> Yeah...
01:54:06 <Cale> That will result in the entire do-block becoming Nothing
01:54:14 <Cale> Nothing >>= f = Nothing
01:54:19 <Cale> Just x >>= f = f x
01:54:19 <dmj`> halogenandtoast: think of what it would look like unsugared
01:54:22 <halogenandtoast> OH
01:54:24 <halogenandtoast> herp derp
01:55:03 <dmj`> > do { x <- Just 1; y <- Nothing; pure (x + y) }
01:55:06 <lambdabot>  Nothing
01:59:40 <dmj`> halogenandtoast: I do think Maybe and Either are monads that often get neglected when it comes to monadic syntax, easier to resort to pattern matching. 
02:00:38 <halogenandtoast> Yeah I could see that, I'll try to do my part to use them monadically.
02:01:15 <Cale> Well, using their Monad instance means throwing away information about what thing failed.
02:01:24 <Cale> Often you want to handle different failures differently.
02:01:37 <Cale> But when you don't care, it's rather nice.
02:03:32 <dmj`> Yea, that’s a very good point.
02:04:11 <dmj`> > do { r1 <- lookup “foo” []; r2 <- lookup “bar” []; pure (r1, r2); }
02:04:13 <lambdabot>  <hint>:1:19: error: lexical error at character '\8220'
02:04:33 <barrucadu> Those are some fancy quotes
02:05:46 <dmj`> heh, this IRC client is a little too fancy
02:05:52 <dmj`> > do { r1 <- lookup "foo" []; r2 <- lookup "bar" []; pure (r1, r2) }
02:05:55 <lambdabot>  Nothing
02:09:57 <halogenandtoast> If I wanted to make takeTurn :: PlayerNumber -> GameState -> IO GameState
02:10:05 <halogenandtoast> use the state monad what would the last type be
02:10:20 <halogenandtoast> Playerumber -> IO (State GameState ()) ?
02:10:27 <lpaste_> av pasted “type woes” at http://lpaste.net/353766
02:11:15 <dmj`> halogenandtoast: at that point it might be best to use StateT s m a
02:11:31 <dmj`> and if PlayerNumber never changes
02:11:54 <halogenandtoast> dmj`: PlayerNumber is PlayerOne | PlayerTwo and doesn't change
02:11:59 <Cale> If you're working in IO anyway, you might also just use an IORef
02:12:15 <dmj`> :t (undefined :: ReaderT Int (StateT String IO) ())
02:12:17 <lambdabot> ReaderT Int (StateT String IO) ()
02:12:51 <dmj`> halogenandtoast: does your game require multiple threads?
02:12:54 <av> Hi everyone, I need some help with this code: http://lpaste.net/353766
02:13:15 <mutsig> I read on hackage that "The foldM function is analogous to foldl". Is this an issuie if I pass a very large list to it? In the same way as foldl builds up a very large call stack.
02:13:16 <halogenandtoast> dmj`: Not yet...
02:13:41 <Cale> av: I'm confused about why you defined realToFrac'
02:13:55 <halogenandtoast> av: Is the phantom type b deliberate?
02:13:55 <av> The idea is to have a computation (here in calcT2) that can internally run with various types (think of a coprocessor such as OpenCL)
02:14:00 <Cale> Also, none of this is even doing any IO, why IO?
02:14:22 <halogenandtoast> Cale: takeTurn is in IO
02:14:30 <Cale> I'm referring to av's code
02:14:33 <halogenandtoast> oh
02:15:00 <av> now when I run "calcT2 (undefined :: Float)", I expect a different result from running "calcT2 (undefined :: Double)"
02:15:03 <av> why is that?
02:15:18 <Cale> huh?
02:15:26 <Cale> calcT2 doesn't even use its argument
02:15:53 <Cale> Why would you expect anything different?
02:16:35 <mbw> Could someone please explain to me how https://hackage.haskell.org/package/tagsoup-0.14.1/docs/Text-HTML-TagSoup.html#v:sections works? Unfortunately the example that introduces is it out of date, but you can still see it at work in https://github.com/ndmitchell/tagsoup/blob/master/TagSoup/Sample.hs#L91 . Should I be able to make sense of it from the haddock alone?
02:16:40 <halogenandtoast> dmj`: I'll look into StateT, Cale: I'll look into IORef and see which one wins out
02:16:43 <Cale> Changing the type b which goes unused elsewhere in its type signature also shouldn't cause any difference
02:16:47 <av> Cale: I use ScopedTypeVariables, so realToFrac' should take its type from the type of the unused argument, should it not?
02:17:02 <Cale> av: Oh, but you're not actually making use of the extension.
02:17:15 <Cale> You need to explicitly forall the type variables you want scoped
02:17:22 <av> Cale: ah
02:18:40 <cspollard> is there any way to strictly modify an element of a boxed Vector?
02:18:52 <Cale> halogenandtoast: I would advise against using monad transformers unless you have a very clear plan for a new monad you're going to construct with them.
02:19:37 <Cale> halogenandtoast: They're good for expediently defining new monads where you're probably going to restrict the use of the operations they add, or at least, think about the API you're providing enough that you come up with something better than 'get' and 'put'
02:20:32 <halogenandtoast> Cale: yeah I'm pretty sure I'm not ready to create my own Monads just yet.
02:20:49 <halogenandtoast> or construct
02:21:02 <halogenandtoast> I don't have the vision to see how it would be used yet.
02:21:22 <av> thanks guys, will try playing around a bit, must leave the desk for a while now
02:22:09 <Cale> av: There's a bunch of things you give up when you transform IO -- at the very least, you make forkIO and catching exceptions rather tricky.
02:23:23 <Cale> There are things you can do to recover a bit with MonadBaseControl and such.
02:24:05 <Cale> But also, the first monad transformer you put over IO is going to make you pay a bunch in syntactic noise by having to stick liftIO in a bunch of places.
02:24:37 <Cale> That might be fine, but vs. just passing around a parameter, it's not really much of an improvement.
02:28:55 <Cale> There is an argument that if you're using StateT, then you can give parts of your computation types like  (MonadState MyState m) => ... -> m (), where it's clear that those bits can't do IO, apart from what actions they may get as arguments. You can do that with an IORef as well though, by passing along actions for reading or writing your state to something polymorphic in a choice of monad.
02:29:28 <Cale> m MyState -> (MyState -> m ()) -> ... -> m ()
02:30:28 <Cale> Sorry, that'd probably want (Monad m) => ... on the front
02:31:08 <Cale> cspollard: I think you're just meant to ensure the thing you're writing is evaluated.
02:34:55 <halogenandtoast> Cale: thanks for your help, I think I'll just leave my code alone.
02:35:29 <lpaste_> halogenandtoast pasted “Game.hs” at http://lpaste.net/353767
02:35:35 <halogenandtoast> I would say ^^ isn't too bad
02:36:46 <halogenandtoast> What's kind of nice is my lib has no IO operations. Everything IO related is here in the main exe
02:37:32 <Cale> Yeah, personally I would just leave this until some problem with it needed solving
02:38:32 <halogenandtoast> Yeah I just keep feeling like I'm passing GameState around a lot
02:38:41 <halogenandtoast> and keep assuming it's a common pattern I should solve
02:41:38 <Cale> If you're worried that you'll accidentally use the wrong, old GameState, then something like State is one possible solution to that.
02:42:17 <Cale> But I do think it's a common mistake to jump to applying StateT to IO a little quickly
02:46:00 <dmj`> One annoyance with StateT, or any transformer is concurrency. When you forkIO or async, you escape into IO forever, forcing you to pass your state from the closure into the IO action of the newly forked thread
02:47:17 <dmj`> monad-control helps with that
02:49:57 <Cale> Also, that might not even make sense -- because updates to the state on the other thread obviously aren't going to apply
02:50:55 <Cale> monad-control "helps", but sometimes the thing it does for you isn't actually what you want.
02:52:13 <halogenandtoast> dmj` Cale I assume the solution is to have the state only in one thread and have the other threads send messages to that thread
02:52:21 <halogenandtoast> kind of like erlang mailboxes
02:53:37 <halogenandtoast> s/the solution/one solution/
02:54:18 <halogenandtoast> heading out to grab dinner thanks everyone
02:55:33 <dmj`> Cale: yea, it probably wouldn’t be as convenient for StateT as ReaderT, using lifted-base / lifted-async
03:06:42 <mbw> Say I have finally "figured it out" while in a ghci session, and now I want to write it into a source file. Is there a way to dump the current session history to a file or something like that?
03:10:15 <bartavelle> great, my haskell program gives random results now
03:10:24 <bartavelle> doesn't do any IO, all pure computation
03:10:46 <Cale> mbw: Not really, apart from going back through your history and copy/pasting things, which is why you should be writing definitions to a file from the outset, and only testing them in ghci
03:10:48 <cocreature> bartavelle: can you show us the code?
03:11:26 <bartavelle> cocreature, https://github.com/bartavelle/gamebooksolver
03:11:34 <mbw> This'll teach me :(
03:11:43 <bartavelle> I thought it was faulty cpu/ram, but it's the same on another computer
03:11:49 <bartavelle> I blame memoization + parallel
03:11:57 <bartavelle> which already caused me problems in the past
03:12:50 <cocreature> bartavelle: what do I need to do to reproduce the behavior?
03:13:10 <bartavelle> stack build && time .stack-work/install/x86_64-linux/lts-8.4/8.0.2/bin/gamebooksolver-solvebook02 +RTS -s -N8
03:13:21 <bartavelle> sometimes gives slightly different results (not always)
03:13:34 <bartavelle> it's pretty slow though :/
03:14:14 <cocreature> well executing an executable is IO, what’s the part that is pure and still produces different results?
03:14:42 <bartavelle> that's the executable https://github.com/bartavelle/gamebooksolver/blob/master/app/SolveBook02.hs
03:14:54 <bartavelle> it basically just computes "solution", and prints some data extracted from it
03:15:23 <bartavelle> all the IO is about printing
03:15:48 <cocreature> ah ok
03:17:06 <bartavelle> but yeah, I already witnessed <<loop>> when using "parallel" that would not happen without it, so I guess it's kind of hacky
03:17:22 <bartavelle> perhaps I should start using something that's more explicit
03:17:28 <Cale> That's... messed up
03:17:41 <Cale> par should never affect the result of your program
03:17:52 <liste> bartavelle: and no "unsafePerformIO" anywhere?
03:18:04 <bartavelle> liste: nope
03:18:11 <liste> or libraries that may use it (for eg FFI)
03:18:45 <bartavelle> liste: I don't think so? I don't think I even use bytestring
03:19:05 <cocreature> I would have suspected data-memocombinators but it looks fine
03:19:18 <Cale> data-memocombinators should be safe
03:19:58 <bartavelle> I fixed my <<loop>> issues by being a bit more strict at places, so I thought it was some sort of race with the thunks that are being evaluated at the same time
03:20:04 <bartavelle> didn't use memoization in that case
03:20:25 <Cale> Being more strict should never fix <<loop>>, it should only hasten it
03:20:36 <Cale> (or cause it)
03:20:53 <cocreature> I can reproduce the problem
03:20:56 <bartavelle> well, parMap shouldn't cause <<loop>> either :)
03:21:00 <bartavelle> wow cool!
03:21:28 <cocreature> but I’m not quite sure where to start looking for a bug.
03:22:10 <bartavelle> I'm running it with -N1 to see if this happens too
03:22:34 <Cale> Is it this 0.48460975500424647 which should be different?
03:22:50 <bartavelle> that, and it sometimes also gives the result list in a slightly different order
03:22:57 <cocreature> yeah I saw both
03:23:19 <bartavelle> sometimes it just messes the score, and returns the same list, but as it's rounded I am unsure it's the same
03:23:38 <bartavelle> you might want to remove the casts to Double, and keep the Rational
03:24:02 <bartavelle> also I found my parMap problem, if that is of interest, unfortunately I can't share this code  ...
03:25:06 <Cale> 0.516055644569007 hmm
03:25:28 <bartavelle> oh, nice error!
03:26:59 <jchia> How can I extract/obtain "{\"a\": {\"b\": 1, \"c\": 2}, \"e\": 4}" from "{\"a\": {\"b\": 1, \"c\": 2, \"d\": 3}, \"e\": 4}" using lens-aeson? Basically, drop all keys under "a" that are not in ["b", "c"].
03:27:55 <bartavelle> jchia, go
03:27:58 <bartavelle> jchia, gimme a sec
03:31:27 <bartavelle> jchia, I don't think I know how to do it just with lens, I have to add some HM in the mix :/
03:31:43 <jchia> bartavelle: HM? HashMap?
03:31:47 <bartavelle> yes
03:32:17 <Cale> bartavelle: I tried replacing HashMap with Map, and haven't been able to cause it yet.
03:32:46 <bartavelle> argh
03:32:48 <Cale> I think there might be a bug in HashMap
03:33:02 <bartavelle> that's pretty bad if true, as it's so much faster
03:33:04 <Cale> That was the first thing which came to mind when I saw your imports.
03:33:16 <bartavelle> that would be a good catch though
03:33:16 <Cale> HashMap does all kinds of insane crap
03:34:02 <Cale> HM.insert uses reallyUnsafePtrEquality#
03:34:12 <cocreature> who would have thought that this is unsafe
03:34:19 <bartavelle> :))))
03:34:34 <bartavelle> jchia, key "a" . _Object %~ HM.filterWithKey (\k _ -> k `elem` ["b","c"])  btw, if you did not have it already
03:35:04 <bartavelle> alright, I'll try to move to Data.map
03:35:06 <bartavelle> err
03:35:07 <bartavelle> Map
03:35:07 <cocreature> but I kind of hoped that by now HashMap would be sufficiently battletested
03:36:01 <bartavelle> I can't reproduce it with -N1, so it's almost certainly a race :(
03:36:08 <jchia> bartavelle: Thanks a lot. I'll try to find a way that is more lensy
03:36:09 <Cale> Possibly it only comes up in conjunction with par, or under heavy GC pressure
03:36:35 <jchia> i.e. try to continue from "Object %~" and do without HM
03:37:04 <Cale> reallyUnsafePtrEquality# can give false negatives when the GC moves things around -- I imagine it can also give false positives, though that would be extremely unlikely.
03:37:17 <bartavelle> jchia: yeah, but you'd have to do it at the right side of %~, and I don't think there's a toHashMapOf ?
03:37:24 <Cale> Maybe it really can't -- I remember hearing a reason why it shouldn't be able to
03:38:06 <Cale> (basically because if the GC moves something in the interim, it's going to be moving it to a memory location where nothing should have been just prior)
03:38:40 <cocreature> I wish ghc-prim had better docs for these operations
03:39:40 <bartavelle> anyway thanks Cale!
03:40:25 <bartavelle> I'll probably submit some sort of bug to unordered-containers, although I can't seem to reproduce it right now ...
03:41:55 <bartavelle> jchia, you'll have more luck on #haskell-lens, although it might take some time
03:42:06 <jchia> bartavelle: OK
03:44:12 <Cale> Actually, and if it's not the reallyUnsafePtrEquality, it might have something to do with the unsafe updates to these arrays.
03:44:58 <bartavelle> I just want to do "HM.toList . HM.fromListWith (+)" really fast though, I tried the "discrimination" package, but it was much slower
03:45:09 <bartavelle> I'll test the Map solution for a while today
03:46:19 <cocreature> bartavelle: you could try throwing everything in a vector, applying an inplace sort and then storing the results in a data structure of your choice
03:47:29 <bartavelle> humm
03:47:35 <bartavelle> yeah with Map program is twice as slow :(
03:47:43 <bartavelle> I'll go eating, perhaps I'll have an idea
03:48:41 <Cale> It didn't seem twice as slow for me...
03:49:20 <Cale> 20.8s elapsed vs. 19.1s
03:49:30 <Cale> What did you do? :)
03:49:55 <Cale> Map is usually only marginally slower than HashMap in my experience anyway
03:50:14 <merijn> But mutable vectors with in-place sort is always fast in my experience :p
03:50:19 <mmo> Hey :) If I write a GUI-Application for Ubuntu, would "gtk2hs" or "haskell-gi" be a better choice?
03:50:56 <Cale> mmo: The new version of gtk2hs is just called 'gtk' btw.
03:51:05 <Cale> mmo: What kind of GUI is it?
03:52:18 <Cale> Personally, I would strongly consider using reflex-dom and compiling with ghc to get a native webkit application, just because I've been enjoying that so much when it comes to web applications.
03:52:31 <mmo> I just want to write a little Sudoku program with a graphical interface.
03:52:46 <Rembane> mmo: Gloss might do what you want.
03:52:48 <merijn> You could use a terminal UI using brick :)
03:53:50 <Cale> That's actually a great idea, and if you don't do it with reflex-dom, I probably will. Would make a good example application.
03:54:15 <Cale> Plus, you compile it with ghcjs and you get a web page :)
03:54:28 <_sras_> How can I convert a LogStr (System.Log.FastLogger) to string....
03:55:02 <mmo> Ok. Thanks. I'll have a look at those things. On the github page of "gtk2hs" the refer to "haskell-gi" and say that it would be a better choice for new projects. However, there is not really a good documentation for "haskell-gi".
03:55:45 <Cale> _sras_: I don't see that it's possible -- that's kinda miserable
03:56:09 <Cale> oh
03:56:10 <Cale> fromLogStr :: LogStr -> ByteString
03:56:46 <_sras_> Cale: Where is that func?
03:56:58 <cocreature> _sras_: System.Log.FastLogger
03:57:05 <cocreature> https://hackage.haskell.org/package/fast-logger-2.4.10/docs/System-Log-FastLogger.html#v:fromLogStr
03:59:13 <_sras_> cocreature: Thanks. I was looking at an older version.
03:59:47 <_sras_> Cale: "I don't see that it's possible -- that's kinda miserable"...Why did you think so?
03:59:55 <Cale> Just didn't see that function
04:00:10 <Cale> I'm not sure why
04:00:16 <cocreature> we really need to add some big red warning if you are looking at the docs for an older version of a package
04:00:31 <Cale> Well, I also didn't expect it to be ByteString
04:01:16 <Cale> also, the constructor for LogStr isn't exported, so if the library didn't provide fromLogStr, you would be stuck
04:13:09 <bartavelle> cocreature, I have a chrome extension for that :/
04:22:31 <bartavelle> Cale, running time went from 37s to 57s
04:22:49 <Cale> bartavelle: weird
04:22:57 <Cale> bartavelle: I didn't see much difference here
04:23:11 <bartavelle> that's very consistent with my usual observations, only IntMap compares favorably to HashMap
04:23:24 <bartavelle> Cale, you did just derive the needed Ord instances to make the change?
04:23:31 <Cale> yeah
04:23:33 <bartavelle> oh weird it's faster now oO
04:23:44 <bartavelle> went to 38s
04:23:46 <Cale> Maybe something else was running on your machine the first time?
04:23:54 <bartavelle> most certainly
04:24:18 <bartavelle> also I run 2 cpus cores, with 6HT cores each, so perhaps locality has an effect
04:24:27 <bartavelle> as I run -N8
04:24:50 <Cale> I was running -N8 too as per your original command
04:25:06 <Cale> I should try -N16
04:25:12 <bartavelle> yeah now it's a pretty consistent 38s ... probably one of my VM was acting up
04:25:43 <bartavelle> I didn't observe better performance past -N8 though ... but anyway, I still have to make it a *lot* faster if I want to solve the whole book
04:26:41 <Cale> Yeah, seems like it's significantly worse for me
04:26:57 <bartavelle> I get peak performance between -N8 and -N12
04:27:31 <Cale> Heh, with -N7, it ran faster than the original HashMap one did at -N8
04:27:56 <Cale> Probably just less contention with other junk running on my system
04:28:25 <bartavelle> Oh, I thought I had it badd https://github.com/tibbe/unordered-containers/issues/68
04:29:10 <bartavelle> on the other hand, I'd rather have a clean crash than data corruption
04:29:10 <Cale> lol
04:29:37 <Cale> I've never really been a great fan of hashing
04:29:48 <Cale> anyway
04:30:02 <Cale> (not that it has anything to do with why unordered-containers seems to be flaking out)
04:38:14 <merijn> quchen: So, what needs to happen with your prettyprinter before it can be released/used?
04:59:15 <av> Cale: back at the keyboard now -- in case the IO stuff you wrote was directed my way: I use IO in this case because the real work I'm doing uses OpenCL, not for passing around a state.
05:02:35 <quchen> merijn: Politics! I want to take over maintainership of wl-pprint, and release my package as a major version bump (to 1.*). I’d then like to deprecate ansi-wl-pprint in favour of my wl-pprint-ansi, which builds ontop of wl-pprint (adding the ANSI dep). The modules are slightly breaking, but I’m providing drop-in compatibility layers for dead simple migration.
05:03:18 <quchen> wl-pprint seems to be used by older libraries, for the most part. I don’t expect many breakages there.
05:03:34 <quchen> And migrating away from the compatibility layers to the new library should be fairly easy as well.
05:04:00 <quchen> Well, not should, *is*. Transitioning the STGi to the new prettyprinter was a matter of a couple of minutes.
05:04:46 <mbw> Hello, I have another question. I've successfully slapped together some functions that recursively extract some links from a website. I use wreq to get the response bodies, and tagsoup to barbarically extract the links. However, this seems very inefficient to me. Wreq's get method is of type get :: String -> IO ByteString. I can process this ByteString with tagsoup to get another ByteString. But then I have 
05:04:52 <mbw> to call 'get' again, which expects a string, so I have to unpack. This methodology seems to be seriously flawed. How are you supposed to recursively follow links with wreq?
05:05:40 <Rembane> mbw: What makes it flawed?
05:06:15 <ph88> hi all
05:06:51 <phadej> quchen: http://packdeps.haskellers.com/reverse/ansi-wl-pprint vs 
05:06:58 <phadej> quchen: yours wl-pprint-ansi
05:07:20 <ph88> does anyone know how i can resolve the type ambiguity in the type signature on line 105 ? https://bpaste.net/show/b7495fd638b0  above there is the ghci infered type, but i can not use that because the generics-eot package does not expose those types
05:07:33 <phadej> quchen: and ansi-wl-pprint is maintained by edwardk, (though seems be a legacy of max bolingbroke)
05:07:54 <mbw> Rembane: All the convertions, and the memory allocations associated with each Char to get a String. The wreq tutorial shows a minimal example of a session, but the links they use are hardcoded Strings.
05:08:36 <cocreature> mbw: allocating space for a URL is really cheap compared to actually doing a web request, so I doubt you need to worry about this
05:08:42 <Rembane> mbw: I think the right approach is to code a whole application that does what you want it to do and then measure the memory allocation. GHC does quite a lot of interesting optimizations on the way.
05:08:47 <_sras_> Is there a typical usage example for System-Log-FastLogger?
05:08:52 <phadej> quchen: so please contact wl-pprint maintainer, and edward and try to figure out the friendly migration
05:08:53 <quchen> phadej: Yup, I talked to Edward and he seemed open to someone taking over maintainership
05:09:27 <quchen> phadej: Sure, I tried contacting him a couple of times already, first time in December, and again around Feb. Didn’t receive any response. :-(
05:09:51 <mbw> It might be true that the time associated with the convertions is negligible compared to the requests. It just felt like I was doing something wrong...
05:10:05 <phadej> quchen: there seems activity in ~two monts ago: https://github.com/sinelaw/wl-pprint
05:10:43 <phadej> quchen: an issue in issue tracker would be great, to be an evidence "when the process started"
05:10:47 <cocreature> mbw: the fact that you constantly have to convert between various flavors of String, Text and ByteString is one of the worst parts of haskell but sadly it’s there
05:11:09 <quchen> phadej: The intended process is a public mail to haskell-cafe, as far as I know.
05:11:29 <phadej> quchen: well, that's too; but to reach people the all communications channel are good
05:11:59 <mbw> If I was doing it right, I would have to convert the ByteStrings to Text before parsing them, probably :/
05:12:12 <quchen> phadej: In my happy place, I was hoping for Noam to tell me »yeah sure go ahead« ;-)
05:12:48 <quchen> phadej: I tried compiling a couple of revdeps against my package (or the compatibility layer) and they all worked fairly well, so I don’t even expect that much breakage
05:14:48 <phadej> quchen: but, anyhow, please proceed with https://wiki.haskell.org/Taking_over_a_package so cafe&libraries mail would be a good start
05:15:50 <quchen> phadej: Yes, I should really get started
05:16:15 <phadej> and IIRC the timetable was 6 months of author's inactivity, dunno when and why that page says 2-6 week period (which is imho is rather small)
05:16:33 <phadej> at least I won't proceed with breaking changes, as there's an year disclaimer
05:16:54 <phadej> about unconditional return of ownership
05:17:36 <quchen> Yes, I know about that.
05:17:56 <quchen> But public support for the new package would be a huge help, and for getting that I need to get started. :-)
05:18:43 <phadej> what's wrong with ansi-wl-pprint?
05:18:57 <phadej> quchen: there is also annotated-wl-pprint and wl-pprint-annotated
05:19:20 <phadej> so if you really want to make things nice, consider all those forks
05:19:35 <quchen> I know about many of them, yes.
05:19:54 <phadej> and obviously there are pretty; etc
05:20:54 <quchen> phadej: My version is merely a modernization of wl-pprint, addressing multiple things: 1. add extensive doc(test)s; 2. remove clashes with now-common operators such as <$>; 3. decouple the layout algorithm from the renderer (-> e.g. no ANSI dependency if you don’t use the colouring functions)
05:21:35 <quchen> And, as mentioned, it is mostly compatible, with the choice of a) a trivial compatibility drop-in, or b) a very simple migration.
05:21:38 <phadej> quchen: is it via annotations, like in annotated-wl-pprint?
05:22:08 <Clint> i would love for optparse-applicative to stop using ansi-wl-pprint
05:22:09 <quchen> No annotations, no. I don’t see their utility, and the number of reverse deps of ansi-wl-pprint seems to agree with me.
05:22:15 <quchen> Clint: Why?
05:22:29 <Clint> because it's incompatible with wl-pprint-terminfo
05:22:37 <quchen> What’s that
05:22:37 <phadej> :P
05:23:05 <quchen> Jesus, the number of prettyprinters is horrible. (Which is why I don’t want to release my own as yet another one, but would rather use it to clean up.)
05:23:13 <phadej> quchen: colors are annotations
05:23:44 <phadej> or is there something you cannot "colorize" with annotations?
05:24:00 <quchen> Everything can be colorized.
05:24:44 <quchen> Oh, and benefit #4: my package is extensible by other backends, for example I have an HTML prettyprinter backend.
05:24:52 <quchen> Try putting that onto ansi-wl-pprint.
05:25:07 <quchen> (This is what made me start the project in the first place, since I wanted to render STGi for the browser.)
05:25:11 <quchen> (And the terminal.)
05:25:53 <phadej> quchen: annotated-wl-pprint can do that too, cannot it?
05:26:11 <phadej> quchen: it's used for idris IIRC
05:26:16 <phadej> "ide"
05:27:29 <phadej> https://wiki.haskell.org/wikiupload/4/4c/Hiw-2015-david-christiansen.pdf
05:28:27 <phadej> quchen: don't get me wrong, I don't like current situation either; so it would be great to clean it up
05:29:37 <quchen> I don’t understand the annotations, really. What’s a non-() example annotation?
05:30:04 <quchen> »Contains colours«? Why can’t the backend simply ignore colour directives when it does not support it (e.g. for plain text)?
05:31:07 <phadej> quchen: you can write a backend which doesn't care about annotations (polymorphic one)
05:31:39 <phadej> but annotations can contain whatever semantic information; e.g. "type&kind of the expresion" represented by Doc
05:31:54 <phadej> so e.g. in HTML render you could put stuff into tooltips
05:32:00 <phadej> etc.
05:32:34 <quchen> Hm, okay. Might be worth thinking about.
05:33:02 <quchen> The upside of piggybacking ontop of (ansi-)wl-pprint is adoption speed.
05:33:25 <quchen> The downside is that a one-size-(really!-)fits-all solution would be even nicer.
05:34:08 <phadej> well, i'd like 'wl-pprint' and 'annotated-wl-pprint' merge (as pretty have both atm); and `ansi-wl-pprint` implemented on top of `annotated-wl-pprint`
05:34:47 <quchen> phadej: The result of that would be what I get when I add annotations to my module, I guess.
05:35:09 <quchen> But then we get new problems. For example, »red : Doc a -> Doc Colour«.
05:35:23 <quchen> But what if I want to add colour and type info to my Doc?
05:35:31 <quchen> So now we need type-level sets?
05:35:35 <quchen> <gh
05:35:44 <phadej> red :: HasColor a => Doc a -> Doc Colour
05:35:48 <phadej> red :: HasColor a => Doc a -> Doc a
05:36:03 <quchen> I see.
05:36:15 <_sras_> Is there an example of using System.Log.FastLogger somewhere? I cannot make sense of it from the Hackage docs alone.
05:36:38 <phadej> quchen: where HasColor could provide only setter, I guess
05:36:53 <quchen> phadej: The downside is that this makes the types more complicated again. Argh!
05:37:01 <quchen> But not by too much, at least.
05:37:21 <phadej> quchen: well, you can have ColouredDoc = Doc Colour
05:38:53 <phadej> an actually, wl-pprint-terminfo has: type TermDoc = Doc Effect
05:39:56 <phadej> quite impossible to think about useful stuff, which doesn't have Kmett's implementation too :P 
05:40:22 <quchen> Haha
05:41:47 <phadej> yet; I miss tabular layouts from pretty-printing libs
05:41:50 <quchen> Anyway, I’ll think about this some more, and try not to go too public before it’s figured out
05:42:03 <quchen> Yes, so do I. But the WL algorithm doesn’t allow those
05:42:33 <phadej> make a better algo; publish a paper; re-implement all the libs; ...; profit!
05:43:02 <quchen> Uhhh yeah
05:43:47 <phadej> I'd like a lib where sub-documents could be layoted using different algorithms; if global one isn't sufficient
05:50:17 <_sras_> In the documentation page for FastLogger, it says that "file rotation is done on demand". What does it mean?
06:07:50 <ADG> :)
06:30:38 <_sras_> Is there any way to make Servant log the handler that was used to service a Route?
06:39:38 <mutsig> I'm working with a datatype of "StateT s (Reader r) a". Does switching the monads to "ReaderT r (State s) a" anything, or is it just a matter of taste?
06:48:09 <c_wraith> mutsig: that particular pair of monads commute, so it's the same thing either way
06:48:34 <c_wraith> mutsig: But not all pairs of monads commute, so that's not a universal rule
06:48:55 <c_wraith> @unmtl StateT s (Reader r) a
06:48:55 <lambdabot> s -> r -> (a, s)
06:49:05 <c_wraith> @unmtl ReaderT r (State s) a
06:49:06 <lambdabot> r -> s -> (a, s)
06:49:34 <c_wraith> mutsig: as you can see, the only difference in the underlying data type caused by switching those around is what order the function arguments are in.
06:49:42 <c_wraith> mutsig: so there's no difference in that case.
06:49:56 <mutsig> c_wraith: I see. I suspected that, but didn't know for sure. Thanx for the explanation
07:18:40 <mbw> My very first web-crawler with space-leak still uses less memory than firefox. What a great success!
07:25:52 <benzrf> heh
07:25:57 <benzrf> its not hard to use less memory than firefox
07:26:05 <benzrf> in fact i'd be hard pressed to use more
07:27:20 * pi_____ kylefang
07:29:39 <quchen> I need a function to tick every N seconds. The simplest implementation is using threadDelay, but this depends on the scheduler’s mood. Is there a library with better timing guarantees?
07:30:02 <quchen> Example: »forever (threadDelay 1e6 >> putStrLn "tick")«.
07:31:04 <quchen> (By »tick«, I mean »execute some IO«)
07:34:36 <c_wraith> quchen, what timing constraint do you have? start time or interval time? 
07:34:38 <merijn> quchen: If threadDelay isn't going to cut it for you, you honestly are likely in much deeper shit than you think with scheduler delay :)
07:35:08 <merijn> quchen: hard realtime? soft realtime? do you care about jitter? do you care about drift?
07:35:55 <quchen> c_wraith merijn: Luckily, I don’t have any constraints. I just felt like my solution was a bit hacky. I guess for a simple game, you could say I have very soft real time requirements, but it’s just an example.
07:36:04 <quchen> Just wanted to make sure I wasn’t missing something obvious.
07:37:06 <merijn> quchen: Then your choice is probably 1) threadDelay or 2) go extremely hardcore
07:37:21 <c_wraith> just use threadDelay then. there's a lot of complexity for little gain if you don't have hard requirements 
07:37:35 <merijn> quchen: While, *in theory* you're at the scheduler's mood, in reality except for GC pauses there should be little getting in the way
07:37:56 <quchen> thanks c_wraith, but I think I’ll go with merijn’s »very hardcore« to implement my tutorialized pong clone.
07:38:03 <quchen> It seems like a good fit.
07:38:15 <quchen> Okay, no ;-)
07:38:16 <merijn> quchen: Also, to repeat my question from earlier: So what needs to be done before your prettyprinter before it can be distributed/used?
07:38:53 <quchen> merijn: I answered the question a couple of minutes later and talked with phadej a bit about it as well. Do you have the scrollback?
07:39:02 <quchen> Otherwise I’ll find it on ircbrowse for you
07:39:51 <c_wraith> the only way to get around the vagaries of GC stopping the world is by moving out of the haskell context entirely. 
07:39:55 <merijn> quchen: no, I had to leave for a talk and I'm still too lazy to setup a bouncer xD
07:40:32 <quchen> c_wraith: Yeah, like asking the OS to send a signal to Haskell every X seconds or something. ThreadDelay it is :-)
07:40:35 <quchen> merijn: Hold on.
07:41:26 <quchen> Ugh, IRCBrowse is broken!?
07:41:59 <merijn> quchen: Eh, sending a signal is how thread delay works :)
07:42:28 <merijn> quchen: Partly, the logging seems to work, but all the old things like user profiles, etc. seems broken
07:42:43 <quchen> Logging tells me no new entries since Feb
07:42:58 <quchen> merijn: PM’d you
07:43:25 <mbw> Is GHC's GC concurrent by now?
07:43:37 <merijn> mbw: Define what you mean by concurrent GC
07:43:44 <merijn> GHC has a parallel GC
07:44:39 <mbw> Then that's probably what I mean. I.e., the thing it was not, at the time Real World Haskell came out, so-to-say...
07:45:16 <quchen> RWH is 10 years old now :-/
07:46:00 <merijn> mbw: Ok, yeah, GHC still pauses all threads for GC, but it now does the GC in parallel using all threads
07:46:17 <quchen> Yes, it’s a stop-the-world GC.
07:47:05 <mbw> Is this as good as it gets, or are there better alternatives that might actually be implemented in the forseeable future?
07:47:27 <mbw> I'm not a GC expert, so it's an honest question
07:47:41 <cocreature> mbw: I don’t think anybody is working on a new GC so in the near future there probably won’t be one
07:47:42 <merijn> quchen: I support phadej's comments. I would really like all the different pretty printing packages a little more consolidated and not breaking fmap, etc. :)
07:47:54 <merijn> mbw: The problem is there is not "optimal GC"
07:48:08 <cocreature> mbw: the main problem (in some areas) with GHC’s GC is if you have low latency requirements
07:48:10 <merijn> mbw: GC is about trade-offs, and GHC's design is pretty solid for most workloads
07:48:22 <dolio> mbw: It's not as good as it gets, but I wouldn't anticipate GHC becoming as good as it gets in the near future.
07:48:56 <quchen> merijn: Mine 1) uses Text; 2) doesn’t break fmap; 3) has lots of docs; 4) decouples the abstract layout from the renderer. It does not support annotations right now, although this would be an easy addition I believe.
07:49:11 <merijn> mbw: Here's a good intro: https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e#.1htv6xpl7
07:49:23 <quchen> merijn: If I add annotations, I wonder whether there’s anything left that people might miss.
07:49:32 <mbw> Are the discussions about alternative GC implementations more of an academic nature, or are there better implementations out there, for instance for Java or something?
07:49:37 <cocreature> quchen: Text and not breaking fmap is already sufficient to win me over :)
07:49:40 <merijn> quchen: Right now I'm using ansi-wl-pprint, since that's already a dependency via trifecta
07:49:55 <quchen> cocreature: And an HTML renderer :-)
07:50:04 <mbw> merijn: Thanks for the reference.
07:50:15 <dolio> mbw: There are definitely 'better' GCs out there.
07:50:18 <cocreature> quchen: neat, I haven’t needed that but it seems nice to have
07:50:26 <merijn> mbw: As you will see, GC design is not about making it better, but "what am I willing to trade for what?"
07:50:40 <dolio> There's a company whose product is a JVM with extremely low latency GC, for real-time-ish stuff.
07:50:50 <quchen> cocreature: https://quchen.github.io/ansi-wl-pprint-docdump/wl-pprint-1/Data-Text-Prettyprint-Doc.html
07:51:10 <dolio> Although extremely low latency might not always be what you want.
07:51:15 <cocreature> quchen: good luck with taking over maintenance!
07:51:15 <merijn> mbw: GHC's GC is optimised for throughput, that is, over a long running program the time spent GCing should be the smallest percentage of the time spent doing useful stuff
07:51:54 <merijn> mbw: But, to do this it's traded off jitter (that is, sometimes it pauses all programs for a longer time to do GC), which means if you want consistent short pauses, that screws you over
07:52:03 <cocreature> merijn: that’s easy, just don’t gc at all :)
07:52:04 <merijn> But if you care about "wasting the least time doing GC" it's ok
07:52:21 <merijn> cocreature: If you crash due to OOM you're not productive either ;)
07:52:33 <cocreature> merijn: the program was very productive while it was running!
07:53:02 <dolio> Can't GHC do minor collections on a per-capability basis?
07:53:06 <merijn> mbw: Similarly, GHC's GC thrives if the set of non-garbage is relatively small. The more "non-garbage" the slower it becomes. But in general in Haskell most stuff actually turns into garbage quickly too
07:53:08 <dolio> And not stop everything?
07:53:10 <merijn> dolio: Yes
07:53:25 <merijn> Only major collections are stop the world
07:53:29 <dolio> Okay, right.
07:54:01 <merijn> mbw: On the upside, the design of GHC also makes allocating memory *super cheap*, like, I doubt you could *ever* be faster than GHC at allocating memory
07:54:16 <halogenandtoast> is there a function for lists to count matching elements. I don't see anything for (a -> Bool) -> [a] -> Int
07:54:17 <merijn> It's like 3-4 asm instructions or something
07:54:26 <cocreature> halogenandtoast: length . filter
07:54:27 <quchen> halogenandtoast: length . filter p
07:54:30 <merijn> halogenandtoast: combine length plus filter? :)
07:54:41 <Rembane> Hat-trick!
07:54:42 <halogenandtoast> I was hoping to do it in one pass...
07:54:43 <halogenandtoast> :(
07:54:51 <quchen> It *is* one pass :-)
07:54:52 <merijn> halogenandtoast: It does one pass!
07:54:52 <mbw> merijn: Does it boil down to alloca and a designated arena or something like that?
07:54:55 <merijn> halogenandtoast: Laziness!
07:54:58 <quchen> Fusion!
07:54:59 <cocreature> magic!
07:55:44 <halogenandtoast> whelp looks like I don't know Haskell very well
07:55:53 <merijn> halogenandtoast: The filter doesn't run until length starts traversing the list, so it's basically like JIT filtering the list for length :)
07:56:03 <quchen> halogenandtoast: The concept behind it is known as »list fusion«. It allows the compiler (based on internal library annotations) to rewrite multiple list traversals into a single one (or sometimes, even none at all).
07:56:17 <merijn> quchen: Even without fusion it would do a single traversal
07:56:32 <merijn> quchen: fusion just makes the traversal even cheaper
07:56:35 <quchen> merijn: Well, arguably. It would still dereference every cons cell twice without list fusion.
07:56:55 <merijn> quchen: Yes, but that's still much faster than traversing twice in a strict manner
07:57:07 <merijn> quchen: And a smaller working set of memory
07:57:11 <quchen> Because of locality?
07:57:15 <quchen> Hm, you’re right.
07:57:16 <merijn> quchen: Yeah
07:57:25 <quchen> Good point, actually! Never thought about it this way.
07:57:48 <merijn> I mean, *not* allocating is better, but compared to strict it's already pretty good without fusion
08:03:31 <merijn> quchen: Look on the bright side, you could become ultimate prettyprint Czar of Haskell if you reimplement everything on top of wl-pprint ;)
08:03:47 <mbw> That reminds me of something I wanted to ask. Why do some/most/all/? of the http-client libraries' "get" functions return lazy ByteStrings for efficiency reasons, even though the binary blob resides in memory? 
08:05:09 <quchen> merijn: I always wanted to be a Czar!
08:05:38 <halogenandtoast> Another fun question.. is there a good way to group list elements with something like groupBy, but have them in tuples with the value I used for equality? For example [(PlayerOne, [1,2]), (PlayerTwo, [3,4,5]), (PlayerOne, [6])] ?
08:05:38 <merijn> mbw: Why do you assume the binary blob resides in memory?
08:05:58 <Rembane> mbw: Chunked HTTP response I believe might be the culprit here.
08:06:01 <merijn> mbw: The way HTTP works you can start accessing the data before it's finished
08:06:33 <Aruro> is there good tutorila and docs for HaRe? wiki page is 2014 hmm.
08:06:53 <merijn> mbw: Consider downloading a GB file or something, you can start processing the lazy BS before the file has finished downloading (you'll block when you exhaust the part downloaded, obviously)
08:08:34 <danharaj> cstrahan: you should ANN your gochan lib on HN i want to see a language flame wa
08:09:08 <c_wraith> I still want to know how it compares to chp
08:09:38 <mbw> Ok that makes sense. I thought I read that the whole string resides in memory, in conjunction with wreq. But now I can't find it :/
08:10:04 <halogenandtoast> I guess I could maybe write my own func with `span` soehow
08:10:06 <halogenandtoast> *somehow
08:10:17 <danharaj> c_wraith: cool lib i'll have to read about it
08:11:37 <codedmart> Anyone know why if I use `default-extensions: OverloadedStrings` in my cabal file `ghc-mod` complains if I don't have the `OverloadedStrings` pragma in the file?
08:11:56 <cocreature> codedmart: maybe it ignores default-extensions?
08:12:22 <ph88> does anyone know how i can resolve the type ambiguity in the type signature on line 105 ? https://bpaste.net/show/b7495fd638b0  above there is the ghci infered type, but i can not use that because the generics-eot package does not expose those types
08:17:32 <codedmart> cocreature: Hmm... that seems really annoying.
08:21:10 <codedmart> cocreature: I see I can pass options to ghc-mod for ghc.
08:26:27 <cocreature> ph88: I think you have some kind of logic error in your code. if you pass http://sprunge.us/XdHT to GHC it will tell you that you need something of type c, but "toEot value" has type "Eot b"
08:27:25 <be5invis> In FTG we have: http://lpaste.net/353771 . but can we do this? http://lpaste.net/353773
08:29:32 <cocreature> ph88: if you think about it, your type signature is claiming that for any b and some mapper function on a you can produce a c. but there is nothing that relates a b and c
08:30:24 <be5invis> Pi and Sigma are both standard type-intro-elim triplets. They could be unified i think.
08:50:30 <dolio> be5invis: This is in your implementation? I've definitely factored the type former part into a 'binder' plus a lambda/pi/sigma tag before.
08:50:46 <dolio> I'm not sure intro and elim benefit from that sort of thing as much, though.
09:00:16 <aeroxam> yosh
09:00:38 <aeroxam> I  got Badwindow errors while using gloss. gloass-examples won't run either
09:01:05 <aeroxam> It happened after a reboot, I don't know what I changed exactly, but I tried changing drivers and it didn't fix it
09:01:23 <aeroxam> kinda bummed 
09:01:47 <Cale> Which platform?
09:01:50 <Cale> Linux?
09:02:05 <aeroxam> yes
09:02:06 <aeroxam> void linux
09:02:52 <Cale> does  glxinfo | head  tell you that you're using direct rendering with the driver that you expect?
09:03:24 <Aruro> anyone using hare here? there is video on youtube and it has much more features than current version
09:03:50 <Cale> The old haskell refactoring thing?
09:04:07 <Aruro> yes, video is 8 year old
09:04:11 <Cale> oh, wow, people are keeping it up to date now
09:04:20 <magthe> I'm looking for programming exercises for building a working knowledge of the various type classes, i.e. something like "Solve the following problem by constructing a Monoid: <problem description>." Is there something like that out there?
09:04:23 <Cale> Maybe it lost features along the way, I dunno
09:04:24 <Aruro> it has nice features like generalising, not simple import struggle
09:04:53 <Aruro> yeah, seems lots of stuff got lost. actually most important ones :D
09:04:59 <aeroxam> http://lpaste.net/353779
09:05:13 <aeroxam> I don't see a driver reference
09:05:51 <Cale> server glx vendor string: SGI
09:06:04 <Cale> server glx vendor string: NVIDIA Corporation -- what it says on my machine
09:06:12 <aeroxam> !
09:06:20 <Cale> I'm guessing you don't have an SGI video card ;)
09:06:30 <aeroxam> Nope x)
09:06:55 <c_wraith> software renderer, then? 
09:07:01 <Cale> probably
09:08:46 <aeroxam> so my nouveau drivers aren't installed properly, hm
09:10:05 <Cale> Look in your Xorg.0.log for lines containing (EE) (and the surrounding context)
09:11:50 <aeroxam> oh boy
09:11:53 <aeroxam> II) LoadModule: "nv"
09:11:53 <aeroxam> [    10.214] (WW) Warning, couldn't open module nv
09:11:53 <aeroxam> [    10.214] (II) UnloadModule: "nv"
09:11:53 <aeroxam> [    10.214] (II) Unloading nv
09:11:53 <aeroxam> [    10.214] (EE) Failed to load module "nv" (module does not exist, 0)
09:12:08 <Cale> Well, that's a pretty nice clue
09:12:20 <Cale> That should probably be either nvidia or nouveau
09:13:16 <tabaqui1> I want to build many similar executables
09:13:19 <Cale> If you look in /etc/X11/xorg.conf you should find the Driver line
09:13:31 <tabaqui1> but with one different string constant
09:13:52 <tabaqui1> I think, ghc could compile them as dynamically linked
09:13:56 <aeroxam> I don't have a xorg.conf
09:14:07 <tabaqui1> with constant imported from other module as symbol
09:14:50 <tabaqui1> create a swarm of tiny libraries exporting this constant
09:15:08 <tabaqui1> and then link with 'em static
09:15:19 <tabaqui1> maybe there is already some nice solution
09:15:39 <tabaqui1> without modifying binary data and messing with ld?
09:16:05 <tabaqui1> ah, and I have to do this with Windows too
09:16:09 <tabaqui1> later
09:16:14 <Cale> tabaqui1: Maybe use CPP?
09:16:32 <tabaqui1> Cale: CPP preprocessor?
09:16:35 <Cale> yeah
09:16:41 <tabaqui1> it works before compilation
09:16:49 <Cale> yes
09:16:51 <aeroxam> I'll try making one since obviously automatic conf doesn't work
09:16:59 <tabaqui1> but ghc compiles too long for me
09:17:03 <Cale> Have one module which has a big #ifdef
09:17:30 <Cale> Make sure it's a separate Haskell module, so that you can keep the .o and .hi files from compiling everything else
09:17:44 <Cale> So all that ghc has to rebuild is that one thing, and then relink
09:17:48 <tabaqui1> I can't wait, while ghc makes 100 unique compilations
09:17:53 <Cale> hm?
09:18:37 <tabaqui1> Cale: yeah, I thought like this before
09:18:42 <Cale> I mean, you compile everything else once, so you have .o and .hi files
09:18:47 <tabaqui1> but looks like "stack build" recompile smth
09:19:00 <Cale> and then you compile that one module with different CPP directives however many times
09:19:21 <tabaqui1> hmm
09:19:24 <Cale> and rebuild your main executable each time
09:20:12 <Cale> It's quite probable that stack won't just want to do this
09:20:22 <tabaqui1> *fix a string
09:20:24 <Cale> But I don't know stack all that well
09:20:26 <tabaqui1> > time stack build
09:20:29 <lambdabot>  error:
09:20:29 <lambdabot>      Variable not in scope: time :: t0 -> t1 -> terror: Variable not in scope...
09:20:29 <lambdabot>      • Variable not in scope: build
09:20:31 <tabaqui1> stack build  3.12s user 0.32s system 98% cpu 3.498 total
09:20:41 <tabaqui1> 3 seconds
09:20:57 <Cale> Is that your whole project?
09:21:03 <tabaqui1> yep
09:21:07 <Cale> That's not bad
09:21:15 <Cale> How many different builds do you need to do?
09:22:00 <tabaqui1> dunno, every incoming user should get different executable
09:22:10 <aeroxam> thanks for your help Cale, rebooting to see if the xorg.conf helps
09:22:22 <Cale> aeroxam: You just just be able to restart X
09:22:29 <Cale> aeroxam: but rebooting will work
09:22:41 <Cale> should just*
09:23:21 <Cale> tabaqui1: 100 builds * 3 seconds per build = 5 minutes
09:23:49 <Cale> This discussion is already longer than 5 minutes ;)
09:24:20 <tabaqui1> Cale: boss said that 3 seconds is fine result
09:24:25 <tabaqui1> thx anyway
09:29:41 <Phyx-> tabaqui1: for windows you could put the strings in a resource
09:29:50 <Phyx-> and emmbed the resource in the exe later
09:29:55 <Phyx-> so you don't have to ever recompile
09:30:02 <Phyx-> I don't know if linux has a similar thing
09:30:44 <merijn> Phyx-: Yes, it's trivial, even
09:31:49 <merijn> Lemme lookup how I did it...
09:33:58 <Phyx-> that should be a heck of a lot quicker than 3 seconds and less complicated
09:36:10 <merijn> ugh, I can't seem to find the repo that did this
09:36:32 <merijn> You can use ld to turn any file into a binary with a start, length, and end symbol
09:39:24 <Claudius1aximus> merijn: i think i tried doing something similar using the assembler with incbin or so, but it's been years since i touched it https://code.mathr.co.uk/binembed
09:41:28 <ph88> cocreature, maybe b is also suppose to be c
09:58:42 <shapr> Is there some way to print the kind of something from a Haskell program?
09:59:30 <Cale> shapr: hmm... maybe via the GHC API
09:59:31 <jle`> well, type erasure
09:59:41 <monochrom> No, I think kinds are really erased.
09:59:53 <jle`> but how often do you really work with dynamic kinds
09:59:58 <Cale> (well, surely you could look at what GHCi is doing)
10:00:56 <shapr> Ok is there a way I can fire up ghci with a command to execute?
10:01:28 <Cale> ghc -e ":k Maybe"
10:02:02 <shapr> Cale: ah, that does it, thanks!
10:02:31 <shapr> ghc -XDataKinds https://gist.github.com/cotrone/1a486f6eb3a1be98c6bb9f2672813a96 -e ":kind! (FizzBuzz 100)"
10:02:42 <shapr> tolt made a funny thing.
10:03:12 <monochrom> Wait, GHC now takes URLs too?!
10:03:34 <shapr> no, but that's the file to use
10:04:25 <monochrom> Every program attempts to expand until it can download from URLs. :)
10:06:23 <Taneb> shapr, wow
10:07:11 <shapr> hey, tolt wrote it.
10:07:29 <shapr> definitely super-cute 
10:07:48 <Taneb> tolt, wow
10:07:52 <nbro> hi
10:08:34 <nbro> I was reading this paper http://cheatsheet.codeslower.com/CheatSheet.pdf and at page 3 it’s defined the data type data Color = C { red, green, blue :: Int }
10:08:46 <nbro> then it’s said we can only match "green"
10:08:48 <nbro> why?
10:09:30 <davean> nbro: its showing you HOW to match only green
10:09:51 <nbro> davean:  "we can match on green only"
10:10:20 <davean> yes
10:10:21 <davean> we CAN
10:10:26 <davean> we don't HAVE to
10:10:26 <nbro> then that doesn’t seem to be a good description of what the author did
10:10:30 <davean> not we can ONLY
10:10:49 <davean> You're reading in things the text doesn't say
10:11:18 <shapr> I'd argue the text could be clearer.
10:11:28 <dolio> We can (match on green only).
10:11:44 <shapr> "We could write code that matches only on green, here's how."
10:11:44 <dolio> Not, we can (match on green) only.
10:12:03 <koala_man> submit a patch: https://github.com/m4dc4p/cheatsheet/blob/master/CheatSheet.lhs#L382
10:12:03 <nbro> shapr: I agree
10:13:02 <ph88> bbl
10:26:43 <TheVip799> Hiiii
10:30:50 * dmwit waves vaguely
10:32:36 <tsahyt> hello. is there some tool to better view profiling output? a vim folding plugin would work too I guess
10:33:12 <dmwit> threadscope?
10:33:13 <tsahyt> for reference, this file is some 15000 lines and navigating it becomes quite painful
10:33:14 <jle`> there's profiteur
10:33:20 <jle`> which i use mostly
10:33:30 <tsahyt> dmwit: I mean the .prof file you get when running with -p
10:33:49 <dmwit> ah
10:33:52 <MarcelineVQ> did you ask ghc? :> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#profiling
10:33:56 <tsahyt> jle`: that looks interesting. I'll give it a shot
10:34:28 <dmwit> MarcelineVQ: I guess he's asking about tools that help with step 3 there.
10:34:36 <tsahyt> yep
10:37:53 <MarcelineVQ> I mention it because the page suggests hp2any which is quite a compehensive suite,  I don't know if it's been kept up to date though
10:38:36 <tsahyt> MarcelineVQ: but that's for heap profiles I think
10:39:42 <dmwit> tsahyt: Let's see how many irrelevant profiling-related tools we, as a channel, can suggest for you. ;-)
10:39:45 <dmwit> We're up to two at least.
10:40:26 <tsahyt> actually profiteur is quite nice so far
10:40:53 <dmwit> two irrelevant tools, one good one =)
10:42:11 <aeroxam> hoy
10:42:12 <aeroxam> so
10:42:19 <aeroxam> it was stupid.
10:43:05 <dmwit> tell it to read a book!
10:44:12 <aeroxam> I just needed to add the user to the video group
10:44:16 <aeroxam> ...
10:44:50 <aeroxam> I still have the server glx vendor string : SGI and for some reason Xorg still tries to load nv...
10:44:53 <aeroxam> but it works now
10:45:11 <aeroxam> actually loads nouveau, so
10:45:24 <aeroxam> I don't understand why it became a necessity to become part of the group. probably a weird mesa upgrade
10:45:28 <MarcelineVQ> aeroxam: glad you figured it out
10:45:35 <aeroxam> thanks
10:45:42 <aeroxam> I love gloss so I was sad
10:49:45 <AndreasK> tsahyt: It might be a side effect of my Engineering background but I used Excel and it worked reasonably well.
10:50:37 <AndreasK> tsahyt: But probably breaks as well over a certain size
10:51:11 <tsahyt> AndreasK: the main thing I was looking for is folding, and profiteur does that well
10:51:33 <dmwit> :set foldmethod=indentation ;-)
10:51:58 <dmwit> Oops, just indent.
10:52:07 <AndreasK> tsahyt: The github page looks nice. I need to remember that one for next time
10:52:32 <tsahyt> dmwit: that also works
10:52:41 <tsahyt> but it doesn't give you such a nice visualization
10:52:50 <dmwit> yeah
10:58:05 <xkb> hi
10:58:44 <xkb> I have a beginner question. I have a function like so `countPerMap :: Map.Map T.Text [[T.Text]] -> Map.Map T.Text (IO [Int])`. How do I actually make those IO actions into Ints?
10:59:12 <xkb> I know about `sequence` but I'm not quite sure how to use i
10:59:15 <xkb> it*
10:59:53 <nitrix> xkb: Do you mean t :: IO [Int] -> [Int] ?
11:00:19 <monochrom> Cannot. What happened to countPerMap such that it ended up with "Map Text (IO [Int])" at the end?
11:00:24 <sbrg> xkb: It would probably be better to write your function so that it gives you something like: Map Text [[Text]] -> Map Text [Int] and then use IO on the result of that when needed
11:00:54 <xkb> the Int in this case comes from a call to an external system
11:00:55 <monochrom> Overall you probably need to read my http://www.vex.net/~trebla/haskell/IO.xhtml
11:02:36 <tsahyt> :t traverse
11:02:38 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
11:02:45 <tsahyt> umm no, that's not what I meant
11:02:47 <tsahyt> :t sequenceA
11:02:48 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
11:02:51 <nitrix> xkb: IS the goal to perform all the IO's at once?
11:03:01 <jle`> it does one of those xkb you can use sequenceA to turn a map of IO actions into an IO action returning a map
11:03:11 <nitrix> xkb: Or keeping them unevaluated in your data structure until needed?
11:03:13 <jle`> oh sorry i started typing with something already in the buffer
11:03:14 <hatboi> 125 ** (1/3)
11:03:16 <hatboi> 4.999999999999999 :: Floating a => a
11:03:23 <jle`> sequenceA :: Map k (IO a) -> IO (Map k a)
11:03:26 <hatboi> how can i have precise calculations?
11:03:30 <shapr> yay! I got approval to write Haskell at work as long as I'm willing to port the code to Python if it goes into production.
11:03:30 <tsahyt> :t sequence (undefined :: Map Text (IO [Int])))
11:03:32 <lambdabot> error: parse error on input ‘)’
11:03:34 <monochrom> Use Rational.
11:03:38 <tsahyt> :t sequence (undefined :: Map Text (IO [Int]))
11:03:40 <lambdabot> error:
11:03:40 <lambdabot>     Not in scope: type constructor or class ‘Map’
11:03:40 <lambdabot>     Perhaps you meant ‘M.Map’ (imported from Data.Map)
11:03:43 <tsahyt> hmpf
11:03:52 <monochrom> Ah but Rational doesn't do **
11:03:55 <shapr> Now I just need to write a libtshark binding
11:03:57 <jle`> xkb: sequenceA executes all of the IO actions, and then assembles the results into a new map
11:04:00 <xkb> Ill paste the code of that function.. sec
11:04:01 <monochrom> or cube roots
11:04:28 <tsahyt> :t sequenceA (M.empty :: M.Map Text (IO [Int]))
11:04:29 <lambdabot> error:
11:04:29 <lambdabot>     Not in scope: type constructor or class ‘Text’
11:04:35 <tsahyt> ok I give up with this now
11:04:36 <Cale> Is one part in a quadrillion not precise enough?
11:04:37 <jle`> where each key in the new map corresponds to the result of the IO action that the original key had
11:04:42 <lpaste_> xkb pasted “io actions” at http://lpaste.net/353784
11:04:48 <lpaste_> xkb pasted “io actions” at http://lpaste.net/353785
11:04:54 <hatboi> so cube roots?
11:04:55 <xkb> twice ??
11:04:58 <xkb> weird
11:05:01 <hatboi> but what if i have really weird exponentials
11:05:17 <hatboi> i also noticed i can't do 125 ** (1%3)
11:05:27 <jle`> you probably want traverseWithKey
11:05:37 <nitrix> xkb: Do you want to run all these IO or to keep them unevaluated in your data structure until needed?
11:05:41 <xkb> where `getDiffNr` does an external call to github
11:05:46 <Cale> hatboi: Yeah, because the result would be Rational
11:05:49 <magneticduck> :t (1 % 3, (**))
11:05:50 <lambdabot> (Floating a, Integral a1) => (Ratio a1, a -> a -> a)
11:05:55 <xkb> In the end i need to run them and write them to a file
11:05:59 <jle`> xkb: mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
11:06:01 <Tuplanolla> If you think Haskell being "mathematical" means that it can do algebraic manipulations, you're mistaken, hatboi.
11:06:03 <Cale> hatboi: and of course, in general, nth roots aren't going to be rational
11:06:13 <jle`> xkb: traverseWithKey :: (k -> a -> IO b) -> Map k a -> IO (Map k b)
11:06:20 <xkb> ah nice
11:06:34 <monochrom> hatboi: http://hackage.haskell.org/package/cyclotomic will help you to some extent.
11:06:41 <xkb> at least that gives a map
11:06:42 <jle`> the result is an IO action that produces each value by executing the function
11:06:49 <hatboi> haskell does not aid with maths?
11:07:01 <jle`> aid in what way?
11:07:03 <hatboi> i thought it was better to use a functional language for precise calculations
11:07:09 <Tuplanolla> Not like Mathematica, no, hatboi.
11:07:11 <monochrom> No, Haskell is not Mathematica.
11:07:22 <monochrom> Haskell is just a programming language.
11:07:26 <Tuplanolla> Unfortunately, I may add.
11:07:28 <jle`> hatboi: your result is precise enough for most engineering applications
11:07:28 <hatboi> damn
11:07:31 <hatboi> :(
11:07:32 <Cale> hatboi: Did you want like, a number theoretical cube root which would fail when given 124 for instance, because it's not a cube?
11:07:39 <monochrom> It pains me that people look at the math-like notation and think it actually has math semantics.
11:07:42 <hatboi> was planning on using it in my scientific work
11:07:46 <jle`> no bridges are going to collapse because 4.99999999999999999 was used instead of 5
11:07:56 <jle`> same for scientific work, too, for the most part
11:08:01 <Cale> If you just want to round the number differently, that's doable
11:08:09 <Cale> as part of the display
11:08:14 <jle`> * instead of 5.000000000000000, that is
11:08:21 <Tuplanolla> SymPy would've fit Haskell so much better...
11:08:32 <Cale> > showFFloat (Just 4) (125 ** (1/3))
11:08:34 <lambdabot>  <[Char] -> [Char]>
11:08:37 <Cale> > showFFloat (Just 4) (125 ** (1/3)) ""
11:08:39 <lambdabot>  "5.0000"
11:08:40 <jle`> as a scientist, i rarely run into a situation where 4.999999999999999 caused issues in calculations while 5.000000000000 did not
11:08:54 <shapr> Tuplanolla: yeah, I've heard people complain about sympy some lately.
11:09:00 <Cale> Note that this is actually less precise than the 4.999999999999999
11:09:17 <jle`> looks like a classic rage quit
11:09:37 <cocreature> floats are known to cause rage
11:09:52 <Tuplanolla> I can't blame him.
11:10:06 <MarcelineVQ> what will topple bridges and crash mars landers are unit converersions which a type system is swell for
11:10:31 <tsahyt> is there even something like sympy for haskell?
11:10:33 <monochrom> Not very scientifically minded if real world facts they don't like lead to quitting.
11:10:45 <tsahyt> on the surface it doesn't seem too hard to implement symbolic maths in Haskell
11:11:04 <tsahyt> but I may be underestimating the amount of work involved by several orders of magnitude, as usually
11:11:08 <Tuplanolla> It's complicated regardless of platform, tsahyt.
11:11:19 <tsahyt> Tuplanolla: but still haskell seems to be a good fit
11:11:35 <Tuplanolla> Reliable rule rewriting systems are really difficult to build and Risch integration is hell.
11:12:16 <monochrom> Haskell makes the parsing easier. That's probably about it.
11:12:29 <tsahyt> hmm. I should look into that a bit I guess
11:12:45 <tsahyt> so many potential projects, so little time
11:12:55 <jle`> overload numerical operators give you a nice little dsl, but it doesn't really help with the algorithms
11:13:06 <jle`> but i guess purity/algebraic data types would probably help
11:13:13 <tsahyt> yeah the overloading is what I was thinking of
11:13:13 <jle`> s/i guess/i am guessing
11:13:24 <tsahyt> you could nicely integrate it with the rest of the language
11:13:31 <tsahyt> no integration pun intended
11:13:32 <jle`> can you imagine implementing anything symbolic without algebraic data types
11:13:46 <jle`> what brave souls
11:13:49 <tsahyt> well I can imagine it. but I don't want to
11:14:06 <Tuplanolla> Risch integration in particular is my go-to suggestion for crushing the souls of beginners asking for project ideas.
11:16:39 <jle`> i wonder if there is any CAS in the works for haskell
11:17:23 <monochrom> There was a dream. It was even on sourceforge. I know because I was one of the 3 dreamers (I think it was 3).
11:17:46 <jle`> a dream in time gone by
11:17:51 <monochrom> And another dreamer was wli, if you remember her.
11:18:09 <monochrom> (I forgot her new nick.)
11:19:04 <tsahyt> what went wrong?
11:19:09 <monochrom> And yes it was back in the days when sourceforge was the cool site and github didn't even exist (nor git itself).
11:19:37 <monochrom> We all had our respective real lives.
11:20:06 <c_wraith> that nick sounds really familiar. 
11:20:17 <monochrom> And perhaps it didn't go wrong, it went right.
11:20:17 <c_wraith> I wonder where I knew her from. 
11:20:33 <Tuplanolla> On the topic of algebra systems, it really annoys me how existing algebra systems represent functions as expressions without bound variables.
11:21:00 <Tuplanolla> It makes everything needlessly complicated, because renaming becomes a burden for the user.
11:21:02 <meister_> Wanna free spins on Starburst without depositing anything? Try your luck for free money 20 Free Spins on signing up http://bit.ly/2n6f4iA
11:21:29 <monochrom> None of the 3 of us actually knew how to do CAS, so it went right that we went on to do what we respectively knew how to.
11:24:18 <jle`> your journeys will all somehow eventually lead you back to doing CAS again, but this time with the perfect skillset to achieve it
11:24:36 <jle`> it will be a nice movie
11:25:06 <MarcelineVQ> starring your favorite actor monochrom bemberbunch cabberette
11:25:14 <monochrom> "No. This is 3 movies."
11:25:54 <Tuplanolla> Which universities have programs for getting a doctorate in everything?
11:27:08 <jle`> do you mean like, a "Doctor of Everything", or every possible doctorate
11:28:17 <Tuplanolla> Whichever it is for honing a perfect skillset.
11:29:55 <sssilver> What's the point of Haskell in a world that already has Java?
11:30:45 <monochrom> No, Haskell came before Java.
11:30:53 <lassulus> ups
11:31:06 <sssilver> But now Java is a thing
11:31:13 <Taneb> sssilver, what's the point of gloves in a world that already has socks?
11:31:27 <Taneb> Java and Haskell are both programming languages, sure, but are very different in their design and purpose
11:31:55 <monochrom> Haskell has no points. :)
11:32:03 <tsahyt> judging by the developments in java 8, I'd say if nothing else Haskell at least serves as a blueprint for features to make java bearable
11:32:20 <sssilver> Taneb both have been around for long enough where we can nonambiguously establish which one is better
11:32:42 <tsahyt> sssilver: better for what
11:32:43 <sssilver> i.e. which one has won the hearts and minds of programmers around the world
11:32:51 <sssilver> tsahyt programming programs
11:32:57 <tsahyt> there is no single answer to that
11:32:59 <tsahyt> you need to be more specific
11:33:07 <monochrom> I don't like this debate. But Java won, you can stop now.
11:33:14 <Athas> Java achieved massive industrial support very early.  The tools are much better.  But maybe if Haskell had the same support, the tools would be *even* better.
11:33:35 <tsahyt> monochrom: Java only won the popularity contest.
11:33:47 <tsahyt> but I agree, this debate is not going to lead anywhere
11:33:58 <sssilver> fine
11:33:58 <monochrom> tsahyt, you understand that I said that just to stop wasting time.
11:34:37 <monochrom> "You are both pretty, can I go home now?"  (from Megamind)
11:35:39 <tsahyt> I thought so, but I also have a bad habit of getting way too deep into debates like this
11:36:53 <monochrom> http://www.vex.net/~trebla/haskell/cont.xhtml  New data added.
11:37:48 <tsahyt> unrelated, is there any performance data on extensible effects vs monad transformers?
11:38:37 <Athas> Is there a way to cut down on the profiling information produced by +RTS -p?  I'm not sure exactly what I want, but given that it has produced a 100MiB report, maybe slightly coarser cost centres or some aggregation?
11:38:43 <Athas> Any tools to help analyse this file, maybe?
11:39:16 <Tuplanolla> I think John A De Goes talked about the existence of such data, but I don't have it, tsahyt.
11:39:17 <tsahyt> heh, I just asked a similar question an hour or so ago
11:39:32 <Tuplanolla> Scour his blog maybe.
11:39:42 <tsahyt> Athas: profiteur is a decent tool to browse the output
11:39:43 <MarcelineVQ> monochrom: a version of exercise 5 came up in #haskell-beginners yesterday, you were guessing the typeclass from base instead of an animal
11:39:53 <tsahyt> Athas: of course you can always just use manual cost centers instead
11:39:57 <MarcelineVQ> oh you were there, gosh I have a bad memory
11:40:04 <monochrom> :)
11:40:19 <Athas> tsahyt: I'd rather not use manual cost centres... this program is too large for this.  I'll try profiteur.
11:41:22 <tsahyt> Athas: when you have a rough idea of what module you want to look at, you can have cost centers generated just for one module too
11:41:35 <cocreature> Athas: https://github.com/fpco/ghc-prof-flamegraph is also great
11:41:38 <tsahyt> it works somehow by disabling -fprof-auto in general and then enabling it for this particular module
11:41:45 <monochrom> The two were related. Before I saw the typeclass game, I was pondering on whether to include my animal exercise or not. After seeing the typeclass game, I decided "yes!".
11:42:16 <Athas> tsahyt: oh really?  Say I know which module is probably interesting.  How do I get only cost centres from there?
11:43:13 <tsahyt> it's been a while so my memory is a bit hazy about that. I remember putting {-# OPTIONS_GHC -fprof-auto #-} or something along those lines in the relevant module and disabling automatic cost centers via --ghc-options or something like that
11:43:34 <lilred> I have a noob question about deriving Show: http://stackoverflow.com/questions/42935549/haskell-deriving-show-for-fix-types
11:43:39 <tsahyt> but it definitely did revolve around setting -fprof-auto as desired
11:44:00 <tsahyt> Athas: this was also on 7.10.3 iirc. I think it should still work on GHC 8 though
11:44:56 <tsahyt> Athas: for finding out which module is probably interesting it might also pay to do a per module heap profile. -hm iirc. Allocs and time spent tend to correlate strongly in haskell programs
11:45:01 <lilred> How do I derive Show for types written with Fix?
11:45:52 <adelbertc> I often hear that Eff/extensible-effects/Free-r only works for "algebraic effects" - does anyone have a pointer to a book or paper that outlines what exactly constitutes an "algebraic effect?" I have an intuition for what it is but I'm looking for something written down/something to point to
11:49:03 <nitrix> adelbertc: As long as the inner Fix'ed type is Show'able, it should be doable.
11:49:13 <nitrix> lilred: ^ wrong person :D
11:49:19 <adelbertc> :-)
11:49:33 <lilred> nitrix: but see http://stackoverflow.com/questions/38958895/how-to-derive-instances-in-recursion-schemes
11:49:50 <lilred> nitrix: whoops wrong question: http://stackoverflow.com/questions/42935549/haskell-deriving-show-for-fix-types
11:50:13 <nitrix> lilred: Same answer as what I just said.
11:50:19 <tsahyt> does lambdabot have a .seen command or something like that?
11:50:37 <geekosaur> no
11:50:39 <nitrix> lilred: T2 will need a Show instance.
11:51:03 <geekosaur> if the person you're looking for is registered with nickserv, you can "/ns info" their nick
11:51:03 <nitrix> lilred: Which means T1, which means T1F.
11:51:23 <lilred> nitrix: nitrix: but T1F already derives Show
11:51:25 <geekosaur> (or longer form, for clients that don't speak the short one: /msg nickserv info thenickhere)
11:52:31 <nitrix> lilred: Oh it's gotta be Show1 according to the error.
11:53:20 <lilred> nitrix: interesting, I´ve never heard of Show1.
11:54:03 <nitrix> lilred: Me neither. It's to show type constructors I believe.
11:54:29 <nitrix> liftShowsPrec :: (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> f a -> ShowS
11:54:31 <nitrix> showsPrec function for an application of the type constructor based on showsPrec and showList functions for the argument type.
11:55:00 <nitrix> Looks painful.
11:55:20 <dolio> adelbertc: The informal idea would be that you can give a finitary, possibly first-order signature to the operations involved.
11:55:37 <dolio> Like, get : () => s ; put : s => ()
11:56:36 <lilred> nitrix: that´s a bit above my level to be honest
11:56:50 <nitrix> lilred: The stackoverflow guy helped you.
11:56:55 <nitrix> lilred: You can apparently use the package https://hackage.haskell.org/package/deriving-compat
11:57:25 <lilred> nitrix: yeah, I saw that. But that uses Template Haskell, which I´ve never used. I´ll try to make it work
11:58:04 <lilred> nitrix: I see `compat` in the name, would it be reasonable to assume that there is some language extension which does this?
11:59:14 <adelbertc> dolio: ah that's interesting
11:59:36 <nitrix> lilred: Normally it's a sign of people writing a compatibility layer to migrate the code to newer versions of GHC and not having code breakable on older versions.
11:59:39 <adelbertc> Seems like there's not a lot of written defiNitions of algebraic effects :/
11:59:52 <nitrix> lilred: Possibly deriving Show1 is something GHC supports now.
12:00:48 <dolio> Where the signatures are in terms of some set of sorts characterizing the algebra. And would definitely not allow you to specify higher-order operations _on the algebra_.
12:01:41 <monochrom> Is "forkIO :: IO a -> IO a" an example of non-algebraic effect?
12:02:09 <dolio> Probably.
12:02:42 <dolio> Although maybe there's some algebraic way of specifying concurrent behavior.
12:03:13 <dolio> Another example would be `censor :: (w -> w) -> Writer w a -> Writer w a`.
12:03:21 <nitrix> lilred: Let me see if I can implement it for fun.
12:03:41 <lilred> nitrix: <3
12:06:03 <dolio> mplus wouldn't fit my definition either, and I'm not 100% certain if that's correct.
12:06:44 <dolio> But you may have to break it down to be algebraic.
12:13:00 <nitrix> lilred: That's not trivial to implement.
12:13:13 <lilred> nitrix: yeah, that´s what I´m finding out.
12:13:37 <lilred> nitrix: I ditched F# for Haskell just for the recursion-schemes thing, but I might have to go back >_>
12:14:19 <nitrix> lilred: I'm gonna need a value to show as well to test it.
12:14:30 <nitrix> lilred: Do you have anything in mind of what the result should look like?
12:16:51 <lilred> nitrix: showing `Bar (Fix Foo)` should show something approximating `Bar Foo`, modulo maybe some line noise
12:17:06 <lilred> nitrix: whatever is simplest
12:18:38 <cocreature> is there some fundamental reason why ShortByteString provides basically no operations or has simply nobody taken the time to implement them?
12:19:10 <nitrix> lilred: Filling type holes slowly :P
12:19:28 <lilred> nitrix: that sounds involved :o
12:19:49 <nitrix> lilred: Fix has always been a mindfuck for me :P
12:20:10 <nitrix> Which is partly why I'm interested.
12:20:41 <lilred> Oi, I got it to work with the StackOverflow guy´s comment!!
12:20:46 <lilred> nitrix: check it
12:21:07 <lilred> https://gist.github.com/lilred/0ef087ff1e5d7e51c2df6796456ee8ed
12:21:13 <lilred> nitrix: ^
12:21:46 <nitrix> Mhm :P
12:21:52 <nitrix> I'm trying to implement it manually ahah
12:22:16 <nitrix> I'm guessing there's a reason why this other package exists and reifies types :P
12:22:36 <lilred> nitrix: it´s a blessing IMO
12:22:52 <lilred> nitrix: maybe there´s a way to get around having to derive 4-5 classes for every data type, using the content here: https://www.reddit.com/r/haskell/comments/1kmods/patternsynonyms_ghc_trac/cbqk5t2/
12:23:23 <splanch> has anyone played with https://www.schoolofhaskell.com/user/edwardk/phoas
12:24:07 <nitrix> lilred: Yeah I'm indeed getting stuck. I have to Turn `T1F a` into `a`, but the type constructor is unhelpful since it's a phantom type.
12:24:18 <nitrix> lilred: *value constructor
12:24:59 <splanch> i'm not sure what we get out of profunctorish church/yoneda-encoding, because the monad instance ends up replacing ALL bound variables
12:25:19 <_sras_> What is the best way to make a wrapper monad for IO so that one cannot use arbitrary IO functions in it, but is instead forced to use a set of functions that run in the wrapper monad?
12:25:50 <nitrix> _sras_: newtype MyMonad a = IO a ?
12:26:13 <nitrix> _sras_: newtype MyMonad a = MyMonad { unwrapMonad :: IO a }
12:26:30 <nitrix> _sras_: In its own module, you don't export unwrapMonad.
12:26:35 <cocreature> ezyang: if you need another example of where backpack might be useful: ShortByteString vs ByteString
12:27:19 <_sras_> nitrix: doesn't that require making monad instances for MyMonad?
12:27:44 <nitrix> _sras_: You can derive Monad for your newtype.
12:28:13 <lyxia> splanch: I would also like to know. You can decide at the substitution site how/whether to replace a given variable though.
12:28:26 <lpaste_> splanch pasted “phoas” at http://lpaste.net/353787
12:28:26 <nitrix> _sras_: You'll need NewtypeDeriving extension.
12:28:53 <nitrix> _sras_: Or you could re-implement it if you want, it's just less noisy to use GHC's extension.
12:29:00 <_sras_> nitrix: Yes.
12:30:29 <_sras_> nitrix: GeneralizedNewtypeDeriving this one, right?
12:30:47 <nitrix> Yush.
12:31:19 <nitrix> _sras_: As long as unwrapMyMonad is not exposed, and you don't provide a function `myMonadLiftIO :: IO () -> MyMonad ()`, people wont be able to lift arbitrary IO computation in the IO that your newtype is hiding.
12:31:33 <nitrix> _sras_: They'll have to use your helper functions that can themselves perform IO, but that's all.
12:31:52 <Tuplanolla> That's the wrong way around, nitrix.
12:31:58 <nitrix> Tuplanolla: Is it?
12:32:08 <Tuplanolla> The constructor must not be exposed, but the destructor may be.
12:32:23 <nitrix> o.o
12:32:27 <nitrix> Oh you're right.
12:33:12 <nitrix> Tuplanolla: https://github.com/nitrix/lspace/blob/master/src/Game.hs#L48
12:33:14 <nitrix> Tuplanolla: So this is flawed?
12:33:27 <splanch> lyxia: what do you mean decide at substitution site?
12:33:32 <splanch> @lyxia
12:33:32 <lambdabot> Unknown command, try @list
12:34:06 <nitrix> Tuplanolla: Flawed in the sense someone could create an evil arbitrary Game computations and >>= with existing ones?
12:34:14 <Tuplanolla> You're not exposing `MkGameState` there, nitrix.
12:34:28 <Tuplanolla> That would require `GameState (..)` in the export list.
12:34:43 <lyxia> splanch: I mean, you're using a function  variable -> term  to substitute, not just a simple term which gets replaced inconditionally for every variable.
12:35:37 <Tuplanolla> The same applies to `Game`.
12:36:01 <dfeuer> Ping edwardk
12:36:09 <nitrix> Tuplanolla: I'm exporting the Game type and not the Game constructor? Game vs. Game(Game) ?
12:36:22 <Tuplanolla> Yes, nitrix.
12:36:39 <Tuplanolla> That's fine.
12:36:42 <nitrix> So I got it right, yet I'm explaining it wrong. That's unfortunate.
12:38:53 <nitrix> _sras_: So don't export the MyMonad constructor then.
12:39:14 <_sras_> nitrix: Yes. 
12:43:24 <adelbertc> dolio: i did some digging around on Twitter, found https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/algeff-tr-2016-v2.pdf which in the first paragraph points to http://homepages.inf.ed.ac.uk/gdp/publications/alg_ops_gen_effects.pdf
12:45:32 <BassSultan> hi, maybe someone can help me - i am trying to overload predefined functions. i got an example here (including error msg from the compiler): http://pastebin.com/10RBaCMx , thanks for any help!
12:46:34 <lyxia> BassSultan: indent show.
12:47:33 <lyxia> BassSultan: what you wrote means an empty instance followed by a top-level definition of show, different from the type class show.
12:47:34 <BassSultan> oh god.. :D thats embarassing.
12:48:20 <lyxia> You're going to have other problems though...
12:48:30 <BassSultan> jeah, now i get another message: The first argument of a tuple should have kind ‘*’..
12:48:32 <lyxia> a Show instance is already defined for pairs
12:48:37 <lyxia> and Num Int is not a type
12:48:42 <lyxia> Num is a typeclass
12:49:05 <BassSultan> ok, obviously there is some stuff i dont get yet
12:51:34 <codedmart> Is there something in aeson or another package that I can get an array of all my data record fields as text?
12:52:55 <monochrom> I don't understand the question. But if the JSON already uses an array/list, then aeson already parses it into an array.
12:54:26 <codedmart> monochrom: That is what I want the `Text` out of the toJSON `HM.HashMap Text Value`, but I don't want to have to pass anything to it other the the data type itself. I just want to be able to say `someFn User` and get back `["firstName", "lastName", ...].
12:54:33 <codedmart> Does that explain what I am looking for more?
12:55:44 <lilred> is there some standardized way of composing type constructors?
12:56:01 <Tuplanolla> There's `Data.Functor.Compose`, lilred.
12:56:27 <Tuplanolla> I'm not sure if that's what you mean.
12:56:36 <lyxia> codedmart: By record do you mean a Haskell record,  data User = User { firstName :: ..., lastName :: ... }, and you want to get the field names?
12:56:37 <lilred> Tuplanolla: I think that´s it, thanks!
12:57:07 <lyxia> codedmart: that's something Generics can do , I don't know whether there's already a library for that
13:01:41 <lilred> Tuplanolla: is there a way to perform that composition without using a newtype wrapper?
13:02:42 <Tuplanolla> I guess you could just type them out, lilred.
13:03:54 <Tuplanolla> @let type ComposeLike f g a = f (g a)
13:03:56 <lambdabot>  Defined.
13:04:28 <Tuplanolla> > Just (Right 42) :: ComposeLike Maybe (Either ()) Int
13:04:30 <lambdabot>  Just (Right 42)
13:04:49 <lilred> amazing, thanks!
13:04:51 <Tuplanolla> Why though?
13:05:09 <lilred> Tuplanolla: recursion scheme shenanigans. I´m trying to fix over a composition of two type constructors.
13:06:23 <lilred> Tuplanolla: whoops, that doesn´t work - type synonyms don´t support partial application -_-
13:07:54 <Tuplanolla> If you're working with `cata` or `ana`, then `Compose` should do what you expect.
13:08:26 <Tuplanolla> There's an extension for making pattern matching on it nicer too.
13:09:02 <Tuplanolla> It was `ViewPatterns` or `PatternSynonyms`.
13:09:40 <lilred> Tuplanolla: yeah, I guess I´m gravitating towards pattern synonyms.
13:09:49 <Sornaensis> why pattern synonyms
13:10:55 <sbrg> lilred: but type syonyms can be partially applied types, if that helps
13:11:01 <lyxia> codedmart: http://lpaste.net/353789
13:17:45 <codedmart> lyxia: Awesome thanks!
13:17:54 <codedmart> Sorry was at lunch
13:18:18 <codedmart> I need to dig into Generics more.
13:19:50 <shapr> I want a logo like those generic products that are only black and white with text that says "Haskell Generics"
13:26:04 <cocreature> can I get a Ptr Word8 to a MutableByteArray so I can memcpy my way to glory?
13:26:52 <splanch> apologies; i'm still failing to find a way to usefully >>= Rec TermF a b while staying parametric
13:27:30 <lilred> Grmbl, I keep running into problems that require more and more sophisticated type machinery. Now I´m looking for type-level lists. I might just switch to Coq.
13:27:39 <splanch> if we're parametric we can't discriminate variables? and if we're not, we can create exotic terms etc
13:29:13 <cocreature> ah I think copyAddrToByteArray might actually do what I want
13:30:23 <balor> It looks like Haskell's facebook bindings are no-longer maintained (https://github.com/prowdsponsor/fb). Are there maintained bindings elsewhere?
13:31:06 <shapr> graphql?
13:32:59 <codedmart> lyxia: I haven't tried it yet, but lets say I have `data User = User {_id :: Text, _firstName :: Text}`, and I want it print it as `["id", "firstName"]`.  Would I just need to do something similar to how aeson does it with modifiers?
13:33:24 <lyxia> yeah
13:33:32 <codedmart> OK cool thanks again.
13:33:44 <lyxia> yw
13:40:11 <ezyang> cocreature: Haha, yes! But ShortByteString really doesn't suport many ops 
13:40:39 <cocreature> ezyang: yep, but it should!
13:40:52 <cocreature> and once you get the primitives down the rest is just duplicated code
13:42:11 <ezyang> I guess I'll add short ByteString to my CHART OF DOOM 
13:42:30 <MarcelineVQ> the chart
13:43:17 <Tuplanolla> Can the type system run Doom yet?
13:43:28 <shapr> Vorpal: hello! Have you started learning Haskell?
13:43:51 <Tuplanolla> That better be what the chart is for.
13:45:53 <lyxia> Tuplanolla: It doesn't handle floating point operations yet.
13:47:22 <cocreature> surprisingly my implementation of packCString for ShortByteString doesn’t seem to segfault
13:48:22 <shapr> Vorpal: I recommend haskellbook.com or brent yorgey's Haskell course
13:50:22 <lilred> What would be the best way to obtain a term-level integer from a type-level integer?
13:51:11 <monochrom> knownNat
13:51:29 <BassSultan> just a quick question before i continue wasting my time: is it possible to include a type defined with "type Interval = (Double,Double)" into an instance declaration?
13:51:31 <monochrom> let me double-check
13:51:55 <monochrom> natVal and natVal'
13:52:17 <monochrom> It's in GHC.TypeLits again and you probably knew
13:52:41 <lilred> monochrom: I probably knew? :p
13:52:57 <cocreature> BassSultan: you need TypeSynonymInstances iirc but then it should work
13:53:09 <lilred> monochrom: I´m a Haskell noob, wandering in from the everything-but-Haskell world (including a bit of Coq)
13:53:12 <BassSultan> ok, thanks - let me google that :)
13:53:29 <balor> The docs in Hackage suggests `checkStatus` is in http-conduit, but the function appears to have disappeared from the latest version (https://hackage.haskell.org/package/http-conduit-2.2.3.1/docs/Network-HTTP-Conduit.html).  Is this just a case that someone has forgotten to update the docs?
13:53:58 <monochrom> I recommend against starting Haskell from the dependent-type angle.
13:54:33 <monochrom> Or the proof angle (same difference, what Curry and Howard said).
13:55:07 <cocreature> balor: looks like it, it’s called checkResponse now
13:55:11 <lilred> monochrom: I´m approaching from the generic traversal angle - scrap your boilerplate, recursion-schemes, etc
13:55:30 <balor> cocreature, ah, I see that now.  Thanks.
13:56:19 <monochrom> There are type-level numbers in traversals?!
13:57:47 <lilred> monochrom: I´m trying to figure out if I can get mutually recursive datatypes out of recursion-schemes, the connection with type-level numbers is actually pretty tenuous
13:58:14 <codedmart> lyxia: got another question as I try and understand all this. How hard is it to add the ability to list nested fields? Say I have `data User = User {name::Text, address::Address}; data Address = Address {street::Text, state::Text}` and have it print `["name", "address.street", "address.state"]`
13:58:48 <codedmart> I don't fully understand what is going on in that code yet.
13:59:36 <lilred> monochrom: know anything about using recursion-schemes for mutually recursive datatypes?
13:59:47 <monochrom> If I am given value-level "fix" and try to get a pair of mutually recursive values, I would implement it by one tuple and use fix for self-reference.
14:00:33 <monochrom> And so if I wanted to do the type-level analogous thing, I would attempt "a type-level tuple" too. Except I don't know if it's actually doable in Haskell.
14:03:06 <lilred> monochrom: and the variadic approach would use a type-level list, but those are ¨downstream¨ from type-level nats. Hence my interest in type-level nats :o)
14:04:11 <lilred> monochrom: type-level tuples are definitely possible.
14:04:19 <lilred> @let newtype (:*:) f g  x y = Prod (f x y, g x y)
14:04:21 <lambdabot>  Defined.
14:04:37 <lilred> monochrom: and then you can fix on that
14:05:19 <lilred> monochrom: but then I´d like an ergonomic, variadic approach.
14:07:36 <dolio> That's not a type-level tuple. That's a product of two bifunctors.
14:08:56 <lilred> dolio: sorry :c
14:18:02 <shapr> Itkovian: you still writing Haskell?
14:18:12 <Itkovian> Seldomly
14:18:15 <Itkovian> Sadly
14:18:19 <shapr> ah, too bad
14:18:35 <shapr> I just got approval to write Haskell at this python shop, as long as I'm willing to port to Python if something goes into production.
14:18:39 <Itkovian> I mostly use it for small tools and solving programming contest questions
14:19:08 <Itkovian> sounds nice, but the porting might be ... difficult at times, no?
14:19:17 <shapr> could be, but I'll cross that bridge if I have to
14:19:28 <Itkovian> I guess the idea is that it runs so fabulously, they will want to keep the Haskell version?
14:19:30 <sbrg> just make sure the stuff you write is so good that it doesn't have to be ported ;)
14:19:35 <sbrg> exactly
14:19:43 <shapr> Yes, I am hoping for fabulous code.
14:19:59 <monochrom> Do write them the most continuation-passing, algebraic-typing Python that the world has ever seen!
14:20:18 <Itkovian> right now, I'm Pythoning and trying to add some go (since the tools we need have libs in go)
14:20:28 <shapr> yeah, we use Go here, it's okay
14:20:30 <Itkovian> wish I could have some Rust and Haskell as well
14:20:34 <sbrg> just tell them you ported it and set up an elaborate alias map that maps all commands from your python build tool to the appropriate stack commands
14:20:44 <monochrom> Err actually with continuation-passing you can probably scratch algebraic-typing.
14:22:56 <christiandiloren> I've got a yesod project I'm trying to get up and running but `stack test` seems to not see the module Settings. It gives me undefined symbols errors such as ..._Settings_appCopyright_closure since it is being referenced in one of the hamlet files. Any ideas?
14:23:37 <christiandiloren> I know that it is not getting that particular module since I removed references to a different function in Settings and then another one popped up immediately.
14:23:49 <geekosaur> you forgot to list the Settings module in the exported modules, probably
14:24:03 <geekosaur> or in other-modules if it's not supposed to be directly accessible
14:24:05 <christiandiloren> Well, it's actually already in there.
14:24:13 <christiandiloren> I wish that was the issue. :-)
14:24:35 <geekosaur> oh wait, test
14:24:42 <christiandiloren> Yes.
14:25:16 <geekosaur> make sure the package is listed as an explicit dependency of the test program?
14:25:21 <christiandiloren> I have the typical build-depends option listing the app properly.
14:25:41 <geekosaur> also, if that module is in an executable instead of the library, it needs to be moved to the library
14:26:09 <geekosaur> because modules that are part of executables are wired to that executable, not exposed for others, not even tests
14:26:46 <christiandiloren> Okay, I just tried adding it to the 'other-modules' key for the test target but it seems to not change anything.
14:26:57 <erisco> nothing kills my enthusiasm more than working with monads, ugh
14:26:58 <christiandiloren> BTW, how would I be able to tell if it is tied to an executable?
14:27:06 <shapr> erisco: poor guy, monads are fun!
14:27:29 <sbrg> christiandiloren: is it an executable target or a library target in your cabal file?
14:27:46 <christiandiloren> library
14:28:19 <christiandiloren> I can post a gist of my cabal file if that might be helpful.
14:28:22 <sbrg> sure
14:28:43 <christiandiloren> https://gist.github.com/rcdilorenzo/2241b43fc0cd687a8fdef5f58fb1a490
14:28:55 <christiandiloren> Thanks, btw, for the assistance.
14:30:01 <christiandiloren> The thing that's a bit odd is I have only modified the project slightly from its originally generated state.
14:31:01 <MarcelineVQ> which module contains Settings and/or appCopyright  from your error
14:31:49 <christiandiloren> Settings is the module name.
14:34:18 <christiandiloren> I shouldn't have to do anything if `{-# Language CPP #-}` is at the top of the module, right?
14:34:47 <christiandiloren> I assume that just indicates to GHC that it has preprocessor statements in it.
14:37:24 <Itkovian> shapr what tool/project are you going to hlorify?
14:38:13 <shapr> ha, hlorify?
14:38:37 <shapr> Itkovian: I want something like scapy, but I could be okay with an ffi wrapper around libwireshark
14:41:42 <Itkovian> TIL
14:46:46 <christiandiloren> I lost my connection but I resolved the issue.
14:46:59 <MarcelineVQ> what was the fix?
14:47:02 <christiandiloren> Apparently, rebooting sometimes solves issues.
14:47:22 <christiandiloren> Not that I intended to--I actually got a kernel panic from a different app. :-)
14:47:23 <monochrom> haha
14:47:48 <geekosaur> oh dear. that makes me wonder if you got memory corruption or something
14:47:50 <christiandiloren> A little bit creepy but I'm okay with that since it's fixed now. :-)
14:48:04 <monochrom> I say that they have the same hidden variable cause. Kernel file handling bug.
14:48:26 <christiandiloren> Thanks so much for the help, though. I've only come on the #haskell twice, and I've gotten excellent help both times.
14:48:47 <christiandiloren> Once I actually become more skilled with Haskell and Yesod, I'll be able to hopefully give back a little. :-)
14:49:31 <christiandiloren> monochrom: I'm actually sure which process it was. I write Objective-C for iOS and can read the stack traces on my Mac when it has problems. :-)
14:54:14 <erisco> I thought for MonadIO types you usually found a M a -> IO a function called "exec" or something
14:54:47 <Cale> runM
14:57:17 <erisco> hrm, looking at Data.SBV and I don't see such a function
14:57:48 <erisco> they have a function called "prove" which works for some things but not all
14:58:16 <erisco> they perhaps didn't design this part of the library so well, I don't know, it is strange
14:58:36 <erisco> they have Symbolic which is their MonadIO type, but then many functions which return IO
14:59:26 <erisco> whereas I'd expect everything to return Symbolic expect for a final runM or execute or whatever
14:59:32 <erisco> except
15:00:36 <erisco> it seems they want you to drop out of Symbolic early and work in IO
15:00:41 <erisco> but practically this is a headache
15:02:45 <erisco> because every time you have to start in Symbolic and funnel everything into one of the Symbolic A -> IO B functions
15:12:27 <centril> I'm in the process of writing my bachelors thesis - and I'd like some inspiration from you guys... If possible, could you send me yours ?
15:16:16 <maerwald> write a better compiler than GHC
15:18:24 <centril> maerwald: I already have a project - I need some inspiration for writing text ;)
15:18:42 <Tuplanolla> I have just what you need.
15:18:53 <maerwald> writing text?
15:19:31 <Tuplanolla> @google simon peyton jones to write a great paper
15:19:32 <lambdabot> Plugin `search' failed with: connect: does not exist (No route to host)
15:19:42 * erisco channels his energy towards centril
15:20:07 <Tuplanolla> @google simon peyton jones to write a great paper
15:20:08 <lambdabot> https://www.cis.upenn.edu/~sweirich/icfp-plmw15/slides/peyton-jones.pdf
15:20:34 <erisco> I haven't written much academically, but I started conversationally and then removed the conversational bits
15:20:45 <centril> Tuplanolla: oh, that's nice - SPJ is always a good source
15:20:48 <erisco> because I do not usually write in such a dry way
15:20:51 <centril> how neat, some comic sans...
15:20:54 <centril> :P
15:21:02 <Tuplanolla> There's a talk of it as well, if you prefer that, centril.
15:21:10 <Tuplanolla> @google simon peyton jones to write a great paper on youtube
15:21:11 <lambdabot> https://www.youtube.com/watch?v=g3dkRsTqdDA
15:21:23 <centril> Tuplanolla: <3
15:23:20 <maerwald> erisco: can you give us a sample? 
15:23:27 <maerwald> I have a hard time imagining it
15:23:45 <maerwald> (except I see two guys rapping a haskell paper)
15:23:59 <erisco> of the transition between the two? no I don't have anything readily available
15:24:21 <Tuplanolla> Write a big blog post and correct the things your supervisors or reviewers complain about, maerwald.
15:24:47 <maerwald> Tuplanolla: what do you mean?
15:24:52 <erisco> but if you look at academic writing there is little fluff, flavour text, story telling
15:25:04 <Tuplanolla> (Not entirely serious.)
15:25:17 <erisco> but other writing tends to have those things to be interesting
15:25:44 <erisco> so I began by telling it like it was a story, then just removed the superfluous parts after
15:25:57 <erisco> it is a more natural way for me to extract the ideas from my head
15:26:00 <maerwald> you mean you write more O'Reilly book style at first?
15:26:17 <erisco> yes, like I was writing it like a tutorial
15:27:12 <centril> erisco: so... did you write your content chronologically first ?
15:27:40 <erisco> I just told the story of my research, so yes, it was chronological
15:27:44 <centril> erisco: because a lot of the stuff going on in my brain is : "first I did this, then that, that was bad, so then I did this, and that was good, so I did more, etc."
15:27:55 <erisco> it happened to end up in the same order anyways but I suppose you could change it if necessary
15:28:23 <centril> erisco: right - so it is OK to write it like it is in my brain and not start with a non-chronological thing
15:28:25 <centril> thats good
15:28:30 <centril> now im happy again
15:32:16 <erisco> a rewrite you can do is "I tried this and found that" to "This resulted in that", and similar
15:33:35 <centril> erisco: ah, in editing ?
15:33:39 <erisco> if you really struggle removing the "I" then you can use "we"
15:34:14 <centril> "We" is fine - we decided that active is better than passive in our stuff
15:35:18 <maerwald> huh, I wasn't even allowed to use "We"
15:35:27 <erisco> when it is something pertaining to your subjectivity, I think it makes sense
15:35:45 <erisco> so if you arbitrated that active is better than passive it seems fine to say "we"
15:36:08 <Tuplanolla> These are the least important details.
15:36:08 <erisco> but otherwise you can just state the fact
15:36:42 <erisco> it is important when you're trying to figure out how to rewrite into an academic tone
15:37:36 <centril> erisco: right, so if we are talking about us specifically, then we use "we" - otherwise not
15:37:48 <centril> like: "we" is better than: "the group"
15:38:51 <centril> erisco: So I guess it's fine if I just write about what we/I did and then you fix stuff in editing ?
15:39:43 <erisco> the only thing that matters is what you end up with
15:40:15 <centril> :P
15:40:44 <erisco> that is how I started, and rewrote once I had my ideas down to come up with a final paper
15:41:43 <centril> erisco: you did it alone ? our group has 6 members
15:42:08 <erisco> yes
15:42:30 <erisco> I haven't done group writing so I don't have any advice to offer
15:42:59 <centril> ah, still - it was really good advice
15:43:16 <okeuday_bak> within the IO monad, using the fail function wraps the string in "user error ()", there isn't any functional difference other than this when compared to using error directly, right?
15:43:27 <Tuplanolla> Suffer as other write dodgy LaTeX and 1000-character lines.
15:43:33 <centril> erisco: i've had a mental block about writing text for the report thinking that I can't just write it chronologically like a story - now it is kinda gone
15:43:33 <Tuplanolla> That's group writing for you.
15:44:33 <centril> Tuplanolla: hah - I'm not letting crap into my report... maybe I'll accept badly written code in pull requests for the bachelors project, but not the report ^^
15:44:38 <erisco> if there is a better organisation it will become more apparent once you can see all the key points written down
15:45:05 <centril> Tuplanolla: for our "planning report" we did like a complete review of it 10 times before sending it in
15:45:23 <centril> erisco: =)
15:45:27 <lyxia> > ((fail "" :: IO ()) `seq` (), (error "" :: IO ()) `seq` ()) -- okeuday_bak 
15:45:29 <lambdabot>  ((),*Exception:
15:45:59 <erisco> but like SPJ says in his slides, the paper should be designed to convey knowledge to others
15:46:13 <erisco> so introducing concepts before they are used, with examples, is a good idea
15:46:33 <okeuday_bak> lyxia: thanks
15:46:51 <centril> erisco: right - we got some practice with that in our planning report
15:52:42 <centril> erisco: would you like to read it btw? maybe you can offer some advice?
16:00:57 <centril> Anyone else can ofc also read it if they so wish =)
16:02:12 <ew_> hello
16:02:39 <ew_> I'm having problems with quickchek
16:02:51 <ew_> quickcheck tells my property is failing and giving me the example
16:02:58 <ew_> but the example actually doesn't fail
16:03:46 <centril> ew_: if you can show us some relevant code we can more easily help you =)
16:04:03 <ew_> I'm preparing a pastie
16:04:05 <ew_> ;D
16:04:09 <ew_> thank you!
16:04:14 <centril> ew_: oh, right =)
16:06:40 <ew_> http://lpaste.net/9160497602586738688
16:07:28 <ew_> it is the first time I'm using QuickCheck in a project that is not very small
16:07:36 <ew_> So I may be doing something very silly
16:08:59 <codedmart> lyxia: Did you happen to see my previous question? 
16:09:18 <codedmart> I don't know enough about generics yet to know if it is possible.
16:09:26 <ew_> centril: done
16:10:01 <ew_> I kinda was making the pastie, but hey, I don't have to keep my code secret
16:10:04 <ew_> it is BSD3 =D
16:10:17 <ertes> ew_: have you verified that mkGraph does actually do what you think it does?
16:10:22 <lyxia> codedmart: sorry I didn't see it, but I just found it now that you mention it.
16:10:31 <codedmart> Say I have `data User = User {name::Text, address::Address}; data Address = Address {street::Text, state::Text}` and have it print `["name", "address.street", "address.state"]`
16:10:43 <codedmart> Repeated @lyxia 
16:10:47 <codedmart> Is that possible>
16:10:50 <codedmart> Is that possible?
16:11:01 <ew_> ertes: mkGraph is a pure function that creates the graph. And it is not my function. It is from Data.Graph.Inductive
16:11:07 <ertes> ew_: i.e. that (TG $ mkGraph [(0,"0"),(1,"}H\SOHB[\EOT{"),(7," \DLE\ETX\145"),(8,"Z\b")] [])) actually matches the test case that quickcheck reported
16:11:15 <codedmart> Basically to keep expanding nested data?
16:11:25 <lyxia> that looks feasible.
16:11:48 <codedmart> Where is the best place to read about all this or how I would go about it?
16:11:58 <codedmart> This is all new and out of my realm at the moment
16:13:45 <lyxia> You can start learning about generics on the GHC.Generics documentation, it shows an example
16:14:23 <ertes> ew_: also why aren't you using the test case verbatim?
16:14:45 <ew_> test case verbatim?
16:15:18 <ph88^> Because a parser combinator-based program is generally slower than a parser generator-based program, Parsec is normally used for small domain-specific languages, while Happy is used for compilers such as GHC.[7]  from  https://en.wikipedia.org/wiki/Parsec_(parser)    how come parser-combinator are slower? does this apply even to attoparsec ?
16:15:23 <ertes> ew_: the test case you gave to prop_self_equiv is not the same as the failing test case that quickcheck reported
16:15:48 <ertes> ph88^: they aren't slower…  i think that's a misconception
16:15:55 <ertes> ph88^: parsec is slower
16:16:22 <ph88^> ertes, maybe the wikipedia page should be edited ?
16:16:23 <ertes> attoparsec is pretty fast, but still far from the optimum
16:16:28 <ew_> Uhm, it may be a mistake
16:16:42 <ph88^> how would you even write the optimum in haskell
16:16:42 <ertes> ph88^: have fun =)
16:16:44 <ew_> but it happends ith the same tests
16:17:01 <ph88^> i was using lemon before which generate special tables for gcc
16:17:24 <ertes> ph88^: here is a parser monad that is very close to the optimum:  StateT ByteString Maybe
16:17:35 <lyxia> codedmart: I don't know where you can read about type-level literals, but perhaps you can make do with the bit I gave you.
16:17:45 <ertes> ph88^: here is another one (they're not the same):  MaybeT (State ByteString)
16:17:58 <codedmart> lyxia: OK I will see if I can figure anything out.
16:18:00 <centril> ph88^: well, if you want optimum performance you should drop a lexer pass altogether to begin with... but then you get a parser that is totally unmanageable
16:18:04 <ew_> ertes: http://lpaste.net/353790
16:18:18 <centril> it's OK to pay some perf penalties for something that is well written and manageable
16:18:28 <centril> but there is a limit i guess
16:18:55 <ertes> ph88^: you can get even closer by distinguising non-consuming fails from consuming fails and recovering parsec's user-controlled backtracking (try)
16:20:12 <ertes> ew_: again: verify that mkGraph actually agrees with its own result
16:20:13 <lyxia> codedmart: But I think here you need to: 1) modify the first instance (GFN (M1 S ... f)) to try and get the sub-fields recursively, if any. 2) write an instance for the K1 type. This will probably make more sense once you've gone through the GHC.Generics example.
16:20:29 <ertes> ew_: TG (mkGraph [(0,"eibl"),(1,"1"),(2,""),(8,"\250\SOH")] [(0,8,False)])
16:20:40 <ertes> *without* prop_self_equiv
16:24:20 <ew_> it does
16:24:27 <ew_> but the problem now is quickcheck
16:24:46 <ew_> when I run prop_self_equiv, it returns True
16:25:01 <ertes> ew_: it's unlikely to be quickcheck's fault though
16:25:01 <ew_> but QuickCheck fails for the same example
16:25:08 <ew_> Yes, I know
16:25:15 <ertes> ew_: for example sometimes Show instances aren't entirely honest…  they might give the same string for values that are subtly different – supposedly an internal difference that somehow leaks through the API anyway
16:25:21 <ew_> Probably also not mkGraph, because its from fgl
16:25:52 <ew_> or maybe I'm using Arbitrary wrong
16:26:19 <ertes> that would only affect the quality of your test cases, not the correctness of the test
16:26:20 <dougger> Hi. Is anyone familiar with using servant-client to delete resources from a remote resource? In particular, I seem to need a content type for the DELETE verb when the remote resource returns no content.
16:26:23 <dougger> Code and error: http://lpaste.net/353791
16:26:41 <lyxia> ew_: what type is prop_self_equiv
16:26:59 <lyxia> oh I didn't see the link
16:27:29 <ew_> ertes: show might be really a source of the problem
16:27:44 <ew_> ertes: but is there a way to get the example directly? without showing?
16:28:32 <ertes> ew_: yes, but it's awkward:  you can write a Show instance for TG that doesn't use G's Show instance, but unwraps the G (if fgl even allows that)
16:28:48 <ertes> so you see the internal representation instead of the nice mkGraph-based one
16:29:02 <ertes> but if that's the source of the problem, consider it an fgl bug
16:29:24 <ew_> uhm, this is probably my best bet now
16:29:29 <ew_> I'll try that
16:34:44 <ew_> ertes: nope, show instance for mkGraph is fine
16:35:13 <codedmart> lyxia: Thanks again, I am going to try and take a stab at it tomorrow.
16:38:34 <ew_> ertes: I kinda fixed the problem.
16:40:11 <Koterpillar> lyxia: if I'm getting into generics, should I look at GHC.Generics, SYB/Uniplate, or both?
16:40:42 <ew_> it was a problem of the fgl arbitrary package
16:41:00 <lyxia> Koterpillar: GHC.Generics.
16:41:51 <Koterpillar> lyxia: are there cases where SYB et al. are more useful?
16:45:32 <lyxia> SYB is a bit simpler because it doesn't involve type class acrobatics.
16:46:02 <ew_> ertes: sorry for being bitchy, thank you very, very much
16:46:10 <ew_> ertes: you saved me a few days of work
16:46:15 <ew_> ertes: gtg now
16:47:30 <lyxia> Koterpillar: I can't think of any good feature it has over Generics. SYB has a lot of unsafety, while being slower at the end.
16:47:34 <sleffy> Anyone know anything about trying to do monadic substitution, but with *two* distinct free variable types?
16:48:08 <Koterpillar> lyxia: thanks, that's helpful.
16:48:21 <sleffy> I've got basically a `Term a b` where `a` and `b` are two different types representing free variables and I'd like to be able to do substitution on each separately. Seems like I'd need some sort of bimonad to do so
16:52:54 <lyxia> Koterpillar: another bad thing is it doesn't work with types as soon as they contain functions, IO, anything that doesn't look like a "data" type.
16:53:56 <Koterpillar> well, what can you do about those for a generic function anyway?
16:54:46 <lyxia> I mean, if you define a type with "data" you can at least peek at its constructors
17:03:19 <lyxia> SYB only considers a datatype to be generic if all its fields are.
17:03:33 <lyxia> with special cases for primitive types like Int/Double
17:05:12 <Koterpillar> Wasn't there an escape hatch for "some other type"?
17:09:38 <lyxia> You can define a dummy Data instance that behaves like the unit type.
17:10:46 <lyxia> or any type you want actually
17:15:02 <lyxia> It feels quite wrong.
17:38:06 <lynnard> yes
17:42:55 <robkennedy> Is there any reason `Data.Map.size` is named size and not length?
17:43:45 <robkennedy> The question is as much design as it is practicality
17:45:19 <lyxia> "size" sounds natural when talking about a map.
17:45:20 <centril> robkennedy: well.. this is just speculation but: do you generally speak of length for non-sequential stuff? Do sets have length or do they have a size/cardinality ? Maps are more like sets than lists
17:46:19 <centril> robkennedy: size is imo also a more general term, length is kinda specific  length/height/depth... vs. size
17:46:57 <robkennedy> But length is what Data.Traversable exports?
17:47:34 <centril> robkennedy: and Monad has return , which it shouldn't, and head is a partial function, etc...
17:48:03 <centril> base is filled with things you could change for the better that would break backwards compatibility
17:48:32 <robkennedy> But the FTP was a bridge burning proposal?
17:48:38 <centril> robkennedy: also, Traversable has a notion of  left -> right
17:48:53 <ezyang> well, it didn't burn /that/ many bridges 
17:50:18 <centril> robkennedy: it even has a function called "sequence" - so it implies order of some sort
17:50:34 <centril> does a "Map" have order ?
17:51:45 <centril> again, this is rank speculation, but this is my intuition
17:51:53 <harwiltz> Hello all. I just attempted to implement a tree in haskell to learn about functors and stuff, anyone mind critiquing my code? http://lpaste.net/353794
17:51:59 <robkennedy> Sure, Map are not infinite and a finite subset of any ordered set is well ordered
17:52:55 <lyxia> harwiltz: there are a lot of unnecessary parentheses
17:52:57 <MarcelineVQ> harwiltz: take x (repeat y)  is also called replicate x y
17:53:16 <harwiltz> MarcelineVQ: oh man.... I knew I was missing something there
17:53:22 <harwiltz> lyxia: where?
17:53:33 <harwiltz> I always get confused with parentheses
17:53:34 <robkennedy> You can't blame me for believing that Maps are ordered when (Ord k) is a constraint ;)
17:53:37 <lyxia> harwiltz: lines 12 13 17
17:53:41 <ChaiTRex> harwiltz: Leaf should probably be Leaf a.
17:53:46 <Axman6> > replicate 3 True
17:53:46 <centril> harwiltz: also, a lot of  ++  - consider using concat instead =)
17:53:48 <lambdabot>  [True,True,True]
17:53:55 <lyxia> harwiltz: also 34-37
17:54:00 <harwiltz> ChaiTRex: I did that on purpose, in case I wanted to make Tree a Monoid somehow
17:54:01 <Axman6> ChaiTRex: not necessarilly
17:54:08 <lyxia> harwiltz: it's quite minor though
17:54:21 <harwiltz> centril: I've never used concat, I'll check it out
17:54:25 <centril> robkennedy: well, some maps are ordered, but not maps in general
17:54:35 <harwiltz> lyxia: Nah, I wanna clear up the parenthesis issue
17:54:41 <lyxia> harwiltz: (length $ dropWhile isDigit s) == 0   is   all isDigit s
17:54:43 <harwiltz> I'm always confused about that
17:54:45 <Axman6> harwiltz: you might find writing addtoBST ius a little prettier if you use compare and parttern match on the three cases
17:54:58 <harwiltz> lyxia: Oh, didn't know about all
17:54:59 <centril> > concat ["hello", "world", "what", "a", "nice", "day"]
17:55:01 <lambdabot>  "helloworldwhataniceday"
17:55:37 <harwiltz> Axman6: I've never heard of compare either, I'll check it out
17:55:41 <Axman6> harwiltz: case compare x a of LT -> ... GT -> ... EQ -> ...
17:55:42 <harwiltz> Thanks for the help everyone
17:55:45 <lyxia> harwiltz: remember function application has higher precedence than any operator. So    ... ++ (show a) ++ ...   is   ... ++ show a ++ ...
17:55:54 <robkennedy> centril: are you going to give a case where `x :: Map k v` is not ordered? Sounds like fake news, even for Map which is not from Data.Map
17:55:57 <harwiltz> Axman6: Oh right... now that you mention it, I think I've seen that before
17:56:00 <Axman6> > map (compare 2) [1,2,3]
17:56:02 <lambdabot>  [GT,EQ,LT]
17:56:12 <harwiltz> lyxia: Ah, that's what I was missing
17:56:21 <harwiltz> I love this lambdabot functionality
17:56:50 <centril> robkennedy: a hash map is not ordered. a tree map is
17:57:08 <harwiltz> Ok, just removed a bunch of parentheses, beautiful
17:58:03 <centril> harwiltz: also, avoid too much indentation - you should bias towards using more top level functions and instead using modules for exporting and controlling interfaces
17:58:15 <centril> harwiltz: top level functions are testable
17:58:45 <lyxia> harwiltz: the second argument of dispTree seems unnecessary
17:58:55 <lyxia> it's always ""
17:59:13 <centril> harwiltz: also, this is a personal preference, but use case instead of the way you are pattern matching since it is more DRY - and check out LambdaCase
17:59:28 <centril> <3 LambdaCase
17:59:30 <harwiltz> Hmm. Youre right lyxia, not sure what I was thinking there
17:59:39 <harwiltz> centril: LambdaCase?
17:59:53 <centril> harwiltz: http://dev.stephendiehl.com/hask/#lambdacase
18:00:02 <robkennedy> centril: ... 
18:00:23 <centril> robkennedy: ... ?
18:00:49 <robkennedy> Sorry bad send. 
18:01:22 <harwiltz> centril: Ah I see, that is nice
18:01:38 <centril> harwiltz: protip: if you already haven't, cabal install hlint , and integrate it into your editor - and let it do a lot of the work for you
18:01:58 <centril> harwiltz: very nice =)
18:02:18 <centril> my world would fall apart without LambdaCase - it satisfies all my eta reduction needs
18:02:30 <harwiltz> centril: I haven't gotten around to that yet, but I definitely should. I'm imagining I can do that with vim?
18:02:47 <centril> harwiltz: sure, tho i cant help you with vim since i dont like or use it
18:02:48 <harwiltz> centril: I'm surprised I've never seen LambdaCase in any books yet
18:02:54 <harwiltz> centril: psssshhh
18:02:58 <harwiltz> Lol
18:03:23 <centril> harwiltz:  What I Wish I Knew When Learning Haskell  is an invaluable source - you should read it, ALL OF IT
18:03:40 <harwiltz> centril: And I've never heard of that either, but it does sound intriguing
18:03:52 <centril> it is
18:04:06 <harwiltz> I will definitely look that up
18:04:06 <robkennedy> centril: is your contention that `size` makes less sense as a function of the `Traversable` class than `length`?
18:04:23 <harwiltz> I actually have another question though, however this one may be more philosophical
18:05:28 <marvin2> hi
18:05:48 <harwiltz> So this is my first time deriving an instance of Functor, and I'm trying to learn Monoids and Monads as well. From what I understand, the only use of Functors, Monads, and Monoids is purely to make code cleaner (and to make use of code easier when working in groups I guess). It's basically just like inheritance with types kinda, so you can define general functions rather than specific ones for each type.
18:05:50 <harwiltz> Correct?
18:06:07 <centril> robkennedy: no - my **conjecture** is that length is better for ordered and sequential stuff, which Traversable has some notion of... And maps in general are not ordered, even tho Data.Map is (sometimes)
18:06:27 <marvin2> trying to fetch my ip from icanhazip.com web page. what library would you recommend?
18:07:01 <harwiltz> Like theoretically I can make a function with the same signature as (>>=), and use it to sequence code like I would with a Monad, and I would get the same functionality. So Monads, for example, don't actually add any new functionality to the language, it's just convenience
18:07:48 <centril> harwiltz: so functions abstract what a structure preserving mapping is, so given a functor, any functor, you can do certain stuff - so it gives you the power to not care about the specifics and write abstract code
18:08:02 <centril> functors*
18:08:13 <centril> s/functions/functors 
18:09:09 <centril> harwiltz: right, you can always write a function:   [a] -> (a -> [b]) -> [b]
18:09:19 <harwiltz> Right, thats kinda what I meant. What I'm getting at is that the only benefit of using these classes is that you get to write more abstract general code. But theoretically I can always get away with not using them, just the code may be uglier
18:09:32 <centril> or: Maybe a -> (a -> Maybe b) -> Maybe b
18:09:48 <harwiltz> centril: Exactly, just of course that would be annoying and hideous
18:09:50 <centril> harwiltz: well, and you'd have to repeat yourself
18:09:56 <harwiltz> centril: Right
18:10:30 <centril> harwiltz: there is a lot of things you can say generally with monads that you'd have to rewrite for every single monad if you weren't able to speak generally about monads
18:10:50 <harwiltz> centril: Was that supposed to confuse me? ;)
18:11:46 <centril> harwiltz: and I put it to you: everything "above" 010101 and machine instructions is only for: 1) convenience, 2) correctness
18:11:54 <centril> harwiltz: no, apologies if you were confused
18:12:09 <centril> harwiltz: what specifically was confusing ?
18:12:09 <harwiltz> centril: Hmm, I see.  I get what you mean
18:12:18 <harwiltz> centril: Mostly a joke on my part
18:12:23 <centril> oh =)
18:12:45 <centril> convenience and easier correctness allows for increased productivity
18:12:49 <centril> which is important
18:13:07 <centril> harwiltz: so "only" becomes "NEAT!"
18:13:18 <harwiltz> centril: But what I'm trying to say is that Monads in haskell are kinda quasi-analagous to interfaces in java... sort of. 
18:14:08 <harwiltz> And by that I mean it makes code much more integratable and less repetitive, but doesn't actually add any features that you couldn't live without
18:14:13 <centril> harwiltz: well, not monads, but (type) classes are, if you squint a bit, analagous to java interfaces
18:14:21 <robkennedy> centril: okay, I'm ready to be put to bed - is there an example that comes to mind to instantiate your parenthetical "sometimes"?
18:14:24 <harwiltz> centril: Right, that makes more sense
18:14:54 <harwiltz> centril: Thanks for all this. I think I have finally (sort of) understood monads now
18:15:00 <harwiltz> (And functors and monoids)
18:15:12 <centril> robkennedy: well, if you don't have  (Ord k, Ord v), then =/=> Ord (Map k v)
18:16:10 <centril> robkennedy: but no - i dont have any instantiation atm since im only at the level of conjecture and not stating =) and for maps in general, i.e: all maps, including hash maps, the language of size is more apt than length
18:16:31 <centril> harwiltz: sec, I'll link you a lecture in advanced functional programming
18:16:59 <centril> harwiltz: http://www.cse.chalmers.se/edu/course/TDA342_Advanced_Functional_Programming/lecture4.html
18:17:29 <centril> harwiltz: but start with: http://www.cse.chalmers.se/edu/course/TDA342_Advanced_Functional_Programming/lecture3.html
18:17:55 <harwiltz> centril: Oooh thanks
18:18:39 <harwiltz> centril: Is this from your school or something?
18:18:43 <centril> harwiltz: Some important stuff: Java has subtyping (unfortunately), haskell does not have this - you can only talk about what common class of functions a set of data types have in common
18:18:58 <centril> harwiltz: yes, from Chalmers University of Technology
18:19:10 <harwiltz> Oh, nice. I wish I learned this at my school haha
18:19:32 <harwiltz> Also, these notes are wayy better than what my profs provide, it's quite impressive
18:19:33 <centril> harwiltz: this common class of functions is what we call a (type) class
18:19:50 <centril> harwiltz: They were made by Alejandro Russo, he's a great lecturer
18:20:07 <harwiltz> centril: So that's what I've come to understand about type classes today
18:20:19 <harwiltz> centril: are you a cs student?
18:20:26 <centril> harwiltz: Yes, writing my bachelors atm
18:20:50 <harwiltz> centril: Awesome. I'm a comp eng student, no haskell (or functional programming at all) for us
18:21:11 <centril> harwiltz: comp eng or software eng doesnt really matter that much for me
18:21:23 <centril> harwiltz: terms don't really translate over english/swedish
18:21:33 <centril> harwiltz: my programme is really called "Information Technology"
18:21:54 <centril> I guess the english name is: "Software engineering"
18:22:15 <harwiltz> centril: Oh, I see. That makes sense
18:22:19 <centril> But I'm gearing towards a master in: Computer Science, Algorithms, Logic & Languages
18:22:31 <harwiltz> centril: I'm thinking about doing that as well
18:22:37 <centril> it's nice
18:22:49 <centril> harwiltz: Have you heard of a type constructor before ?
18:23:11 <harwiltz> centril: Really nice. Just worried I'm not learning enough software in my program, it's a shame. And yes, I've heard of a type constructor, I think
18:23:31 <harwiltz> Isn't that how I defined Tree in my code? "data Tree a = Leaf|Node a...
18:24:34 <centril> harwiltz: right, so a refresher:  You have constructors at the level of expressions and values, ... so: makePerson :: Name -> Age -> Person
18:24:49 <tom7942> harwiltz: the tree on the left side of = is your type constructor
18:24:54 <harwiltz> Yup
18:25:03 <centril> harwiltz: but you can also have constructors, and functions  on the type level
18:25:22 <harwiltz> What do you mean by that?
18:25:44 <centril> harwiltz: what Maybe ? or [] ?
18:25:48 <centril> harwiltz: what's*
18:26:27 <harwiltz> centril: Well they're Monads, but you can define them by type contructors... not sure I'm on the right track here lol
18:26:30 <centril> harwiltz: so, you have a function/constructor  Maybe    and I give you a type  Int,   and you give me back:   Maybe Int
18:26:43 <harwiltz> Right
18:27:22 <centril> harwiltz: so you have a function  from one type, to another, and I give you a type, and you give me back a type
18:27:38 <harwiltz> Ok, makes sense
18:28:04 <centril> harwiltz: so, if we can talk about types of types (which are often called kinds), then   Maybe :: Type -> Type
18:28:10 <centril> :k Maybe
18:28:11 <lambdabot> * -> *
18:28:22 <centril> :k []
18:28:22 <harwiltz> centril: Yup, makes sense
18:28:24 <lambdabot> * -> *
18:28:28 <centril> :k Either
18:28:29 <lambdabot> * -> * -> *
18:28:41 <harwiltz> So lemme try to figure out the kind of my tree
18:29:03 <tom7942> :k (,,,)
18:29:04 <lambdabot> * -> * -> * -> * -> *
18:29:18 <harwiltz> Wait, the tree is recursive, how would I even go about that...
18:29:25 <tom7942> harwiltz:  easy enough… how many type arguments are there?
18:29:34 <harwiltz> One
18:29:43 <tom7942> :k Int
18:29:44 <lambdabot> *
18:29:51 <tom7942> :k Maybe
18:29:53 <lambdabot> * -> *
18:30:00 <tom7942> :k Maybe Int
18:30:01 <lambdabot> *
18:30:10 <centril> tom7942: haha, shoulda started with that
18:30:29 <tom7942> :info Maybe
18:30:35 <harwiltz> So I'd have Tree: *, Trew Int: * -> * for example?
18:30:44 <tom7942> close...
18:30:50 <harwiltz> Oops, flipped them
18:30:57 <harwiltz> Tree: * -> *, Tree Int: *
18:31:02 <centril> harwiltz: yes
18:31:05 <tom7942> right, so Tree is a type constructor, Tree Int is now concrete
18:31:22 <harwiltz> Ok, so the *'s represent only how many type arguments are needed to define the type basically
18:31:24 <centril> harwiltz: because you can't make any values of  Tree,  but you can make values of  Tree Int
18:31:30 <harwiltz> Yup, got it
18:31:44 <centril> harwiltz: yes, so you have a function on types, and arguments to the function
18:31:59 <centril> harwiltz: applying the arguments to the function gets you a result , a type in this case
18:32:05 <harwiltz> Right
18:32:51 <centril> harwiltz:  *  is just fancy notation for  Type
18:33:00 <tom7942> you could make your tree kind * -> * -> * by chaging the "data Tree a =" to "data Tree a b ="
18:33:03 <harwiltz> centril: fair enough]
18:33:19 <centril> :k Int
18:33:21 <lambdabot> *
18:33:22 <harwiltz> tom7942: Ok, I see
18:33:22 <centril> :k Either
18:33:24 <lambdabot> * -> * -> *
18:33:28 <centril> :k Either Int
18:33:30 <lambdabot> * -> *
18:33:34 <centril> :k Either Int String
18:33:35 <lambdabot> *
18:33:40 <harwiltz> I see
18:33:47 <tom7942> like maybe if you wanted some meta data attached to the tree nodes
18:33:59 <tom7942> :k (,,)
18:34:00 <lambdabot> * -> * -> * -> *
18:34:01 <tom7942> :k (,,)
18:34:03 <lambdabot> * -> * -> * -> *
18:34:09 <tom7942> :k (,)
18:34:10 <harwiltz> tom7942: Lol, I was gonna say I don't understand the application of the Tree a b but that makes sense
18:34:10 <lambdabot> * -> * -> *
18:34:37 <centril> harwiltz: Have you heard of higher-order functions (HoF:s) ?
18:34:57 <harwiltz> centril: By that do you mean functions that "take multiple arguments"?
18:35:17 <erisco> that's half of it
18:35:22 <AndoBado> Wait, Are those functions that return functions or take functions?
18:35:23 <harwiltz> Like currying stuff
18:35:45 <centril> harwiltz: no,  functions that either 1) take other functions as arguments, 2) return functions, 3) both of 1 & 2
18:35:56 <centril> :t map
18:35:58 <lambdabot> (a -> b) -> [a] -> [b]
18:36:01 <erisco> functions that have multiple arguments are functions that return functions
18:36:02 <harwiltz> centril: Oh. Ok hahaha. Well yeah I've heard of those
18:36:11 <harwiltz> erisco: Right, that's true
18:36:23 <harwiltz> centril: Well then >>= is a higher order function
18:36:46 <harwiltz> And so is fmap
18:36:49 <centril> erisco: right, but the fact that curried functions are functions returning functions is not the important note here
18:37:03 <AndoBado> and partially applied functions are higher order? Right?
18:37:30 <centril> harwiltz: right you are
18:38:02 <centril> harwiltz: so... if we can have higher-order functions on values,  what about higher-order functions on types ?
18:38:11 <harwiltz> centril: Jeez
18:38:23 <harwiltz> I guess so? Never thought about that
18:38:40 <centril> harwiltz: how would such a signature look like,  if you do the * -> * stuff
18:38:44 <centril> ?
18:38:45 <harwiltz> Trying to understand the implications of that
18:38:55 <harwiltz> centril: Well, something like * -> (* -> *) -> *
18:39:12 <harwiltz> Oh yeah, makes sent
18:39:14 <harwiltz> *sense
18:39:19 <centril> :k Functor
18:39:20 <lambdabot> (* -> *) -> Constraint
18:39:22 <Welkin> kinds
18:39:25 <harwiltz> Either Maybe Int
18:39:29 <centril> :k Monad
18:39:30 <lambdabot> (* -> *) -> Constraint
18:39:52 <harwiltz> What's Constraint?
18:39:59 <centril> harwiltz: Constraint here is a special kind used for classes that denote that some constraint has been fulfilled
18:40:01 <Welkin> Monad is a typeclass
18:40:07 <Welkin> :k Maybe
18:40:08 <erisco> I think it is more simple to say functions are values, and the rest falls from that
18:40:08 <lambdabot> * -> *
18:40:20 <erisco> because even id is a higher order function
18:40:37 <Welkin> :k Either
18:40:39 <lambdabot> * -> * -> *
18:40:39 <harwiltz> But why wouldn't Either (Maybe) Int have * -> (* -> *) -> * -> *?
18:40:41 <Welkin> :k Either String
18:40:42 <lambdabot> * -> *
18:40:57 <harwiltz> Oops, I think I added an extra -> * to that
18:41:09 <harwiltz> :k Either (Maybe) Int
18:41:09 <Welkin> :k Either Maybe
18:41:10 <lambdabot> error:
18:41:10 <lambdabot>     • Expecting one more argument to ‘Maybe’
18:41:10 <lambdabot>       Expected a type, but ‘Maybe’ has kind ‘* -> *’
18:41:11 <lambdabot> error:
18:41:11 <lambdabot>     • Expecting one more argument to ‘Maybe’
18:41:12 <lambdabot>       Expected a type, but ‘Maybe’ has kind ‘* -> *’
18:41:13 <Welkin> :P
18:41:14 <Koterpillar> Either Maybe is not well formed
18:41:17 <centril> :k StateT
18:41:17 <harwiltz> Oh, that's why
18:41:18 <lambdabot> * -> (* -> *) -> * -> *
18:41:19 <Welkin> because * is a type
18:41:20 <harwiltz> Lol
18:41:25 <Welkin> in Idris, it is called Type
18:41:31 <centril> :k ExceptT
18:41:33 <lambdabot> * -> (* -> *) -> * -> *
18:41:35 <centril> :k ReaderT
18:41:37 <lambdabot> * -> (k -> *) -> k -> *
18:41:37 <centril> :k WriterT
18:41:39 <lambdabot> * -> (* -> *) -> * -> *
18:41:47 <harwiltz> What's k?
18:41:52 <centril> harwiltz: any kind
18:41:53 <Welkin> type variable
18:41:57 <harwiltz> Oh, I see
18:42:02 <Welkin> kind variable in this case 
18:42:56 <centril> harwiltz:  Functor is a higher order type constructor, so is Applicative, and Monad
18:43:12 <harwiltz> centril: Ok, makes sense
18:43:51 <centril> harwiltz: they are a bit special due to Constraint, but as you saw with   :k StateT , you can have  * -> (* -> *) -> * -> *
18:44:00 <harwiltz> Right
18:44:13 <mmachenry> Anyone know what I'm doing wrong here trying to derive a MonadState instance? http://lpaste.net/353795
18:44:54 <centril> harwiltz: Java does not have the ability to speak about  T<Integer>  if T is a generic parameter
18:44:59 <centril> haskell does.
18:45:15 <centril> This is commonly referred to as "Higher Kinded Types" or (HKTs)
18:45:29 <erisco> Java has higher-kinded types
18:45:36 <centril> erisco: whatnow ?
18:45:38 <erisco> it does not have higher-kinded polymorphism
18:45:52 <harwiltz> centril: Oh, that's true
18:45:56 <erisco> neither does Rust
18:45:58 <Welkin> HKT would be type constructors, would it not?
18:46:32 <centril> erisco: how do you form  (* -> *) -> * -> *  in Java ?
18:46:34 <dolio> Java doesn't have higher-kinded types, because the "higher" part means they're parameterized by a function.
18:46:44 <dolio> Higher than first-order.
18:46:50 <centril> dolio: right
18:47:26 <centril> harwiltz: thus, you can't speak generally about Functors, Monads, and stuff like this in Java
18:47:36 <erisco> well, I relinquish the pedantry
18:47:41 <erisco> everyone keeps defining it differently
18:47:50 <centril> harwiltz: only specific instances of Functors
18:48:11 <centril> erisco: I've never heard of anyone saying that Java has HKTs - but Scala tho...
18:48:21 <lyxia> mmachenry: where is ListT from
18:48:47 <Welkin> so, MaybeT is a HKT, but Maybe is not?
18:48:50 <lyxia> mmachenry: I suspect it doesn't implement MonadState
18:48:51 <harwiltz> centril: Right, fair enough. That makes sense. So if I had a bunch of other Tree-like things in Java, my code would get very messy and tedious, whereas with Haskell I can just keep redefining fmap
18:48:58 <Welkin> :k Control.Monad.Trans.Maybe.MaybeT
18:48:59 <lambdabot> (* -> *) -> * -> *
18:49:02 <Welkin> :k Maybe
18:49:03 <lambdabot> * -> *
18:49:10 <erisco> centril, well I am glad it has been consistent for you ;)
18:49:14 <mmachenry> lyxia: list-t… https://hackage.haskell.org/package/list-t
18:49:19 <dolio> Welkin: Yes.
18:49:21 <centril> erisco: cheers ;)
18:49:29 <mmachenry> It could probably be easily swapped for Control.Monad.List for this example.
18:49:59 <centril> erisco: well, i revise my statement... Now I've heard of one person saying that Java has HKTs
18:50:06 <centril> erisco: revision is healthy
18:50:08 <erisco> centril, higher-kinded types and higher-order types have meant the same thing in some discussions
18:50:09 <centril> ^^
18:50:22 <mmachenry> lyxia: ListT definitely doesn't implement MonadState, I want my monad transformer to implement it though
18:50:51 <erisco> centril, and since I have never heard of someone talk about "higher-typed values" I don't have much of a basis to make either case
18:50:59 <harwiltz> centril: How would this idea apply to C++? Because in C++ you can do operator overloading, but I wouldnt think you can do higher-kinded types
18:51:14 <centril> erisco: well, I interpret HKTs enabled languages as those languages with the ability to have higher order type constructors
18:51:50 <erisco> centril, if you're tacitly saying that higher-order types and hkts are the same then I stand by what I said
18:51:55 <dolio> harwiltz: C++ can do template templates now, I think.
18:52:09 <harwiltz> dolio: Oh, really. That's interesting
18:52:14 <Welkin> C++ "overloading" is ad-hoc polymorphism
18:52:15 <lifter> There are a number of options available for auto-completion in Emacs, anyone know what is considered to be the best? ("company-mode", maybe?)
18:52:23 <erisco> centril, any type parameterised by a generic becomes a higher-order type
18:52:37 <erisco> centril, the question is if variables can range over such types
18:52:51 <centril> erisco: hmm well, can you form higher order type constructors in Java?
18:53:04 <erisco> centril, hence me saying it has HKT (same as higher-order types) but not HKP (because variables do not range over HKTs)
18:53:06 <dolio> No, first order is not "higher" order. :)
18:53:24 <tom7942> sorry, but who cares about java? 
18:53:37 <centril> tom7942: well, you have to have reasons to avoid it
18:53:43 <harwiltz> centril: lol
18:54:02 <centril> tom7942: at least if you want to tell people why they should use a better language
18:54:07 <lyxia> mmachenry: looks like you won't be deriving it then
18:54:14 <Welkin> philip wadler worked on the java type system, lol
18:54:44 <centril> Welkin: it's a freakin mess... but im sure it's not his fault
18:55:01 <Welkin> I think he added all the good features
18:55:16 <mmachenry> lyxia: I've done this before and it seemed to work… Made a monad transformer chain and it allowed me to just use the functions of the inner monads on my resultant monad.
18:55:17 <centril> Welkin: soooo many special cases, even for simple things such as conversions btw primitive types
18:55:26 <mmachenry> I'm confused about why this is different.
18:55:29 <centril> Welkin: right - im sure the language was pretty effed up when he came along
18:55:53 <centril> Welkin: a part of my bachelors thesis involved writing a type checker for Java - it was not fun...
18:55:56 <Welkin> centril: oh god... you just reminded me of another reason I hate using java... the distinction between primitive and user-defined types...
18:56:07 <lyxia> mmachenry: because more standard transformers implement the mtl type classes
18:56:32 <mmachenry> Ah.
18:56:33 <centril> Welkin: the language is not uniform in any way... the rules for conversions in assignment and function application are for example not the same
18:57:04 <centril> Welkin: read this chapter if you want yourself a good cry... https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html
18:57:09 <mmachenry> lyxia: So is it ListT that's blocking this from propagating out?
18:57:14 <centril> Welkin: or you know... don't. if you value your sanity.
18:57:15 <tom7942> does java do implicit type conversion?
18:57:17 <Welkin> oracle.com is banned from my computer
18:57:19 <lyxia> mmachenry: yes
18:57:30 <centril> tom7942: yes, in an inconsistent manner
18:57:35 <tom7942> well then it sucks 
18:57:46 <Welkin> "worse than javascript" :D
18:57:51 <tom7942> it doesn't even run on metal
18:57:53 <centril> Welkin: OK - not that bad...
18:57:56 <tom7942> waste of time :)
18:57:58 <mmachenry> Ah I see. Maybe ListT done wrong does this right. :)
18:58:03 <centril> Welkin: nothing is worse than Javascript
18:58:07 <Welkin> javascript is actually a better language than many others that people seem to *think* are good
18:58:42 <centril> Welkin: 1995 - Brendan Eich reads up on every mistake ever made in designing a programming language, invents a few more, and creates LiveScript. Later, in an effort to cash in on the popularity of Java the language is renamed JavaScript. Later still, in an effort to cash in on the popularity of skin diseases the language is renamed ECMAScript.
18:58:44 <Welkin> I'd choose javascript any day over java and friends
18:58:49 <Welkin> ES6
18:58:50 <tom7942> if it weren't for the whole "untyped" thing, javascript would be ok
18:59:43 <centril> Welkin: http://stackoverflow.com/questions/5447153/javascript-equality-transitivity-is-weird
18:59:58 <dolio> Okay, this is getting a bit in the woods.
19:00:06 <lyxia> mmachenry: http://hackage.haskell.org/package/pipes-4.3.2/docs/Pipes.html#t:ListT this ListT is done right
19:00:08 <tom7942> yeah the channel is #haskell :)
19:00:24 <centril> right, we seem to have hit a tangent
19:00:28 <Welkin> you can do something close to real functional programming in js
19:00:40 <Welkin> afaik you can't in languages like java
19:00:44 <centril> tom7942: I thought it was  #RustIsLiterallyHaskell
19:00:48 <Welkin> and there are nice haskell-like libraries for it
19:00:49 <harwiltz> I've never seen such hate for a programming language before lol
19:00:59 <centril> harwiltz: which one ?
19:01:06 <harwiltz> java
19:01:14 <centril> harwiltz: oh, if you think I loathe Java...
19:01:25 <harwiltz> centril: Well now I'm curious
19:02:27 <centril> harwiltz: If I say it like this: https://www.youtube.com/watch?v=uMY5VGYh2Go
19:03:06 <nshepperd> Welkin: primitive types like int, byte, etc are analogous to unlifted Int# etc in haskell. the difference is that java encourages you to use the unlifted types, instead of doing like haskell and having a good compiler that optimizes away boxes
19:03:10 <tom7942> perl is worse than java
19:03:25 <harwiltz> centril: I'm not sure I understand...
19:03:35 <centril> harwiltz: "Go Johnny Go"
19:03:54 <harwiltz> centril: Yeah, what does that have to do with languages that you hate? Or are you telling me to leave? haha
19:04:19 <centril> harwiltz: the name of the programming language is in there
19:04:21 <erisco> dolio, maybe I am confusing things in my head, but I think you'd be arguing that if f :: Int -> String that f is a first-order value
19:04:24 <harwiltz> Ohhhh
19:04:29 <nshepperd> if they had instead provided a nice way to use boxed Integers for everything, they'd be about on par with haskell there
19:04:31 <Welkin> tom7942: perl is really cool though, and has first-class functions o.o
19:04:37 <erisco> dolio, and if not then could you clarify what you mean by first-order type?
19:04:55 <Welkin> for me, first-class functions are required or the language automatically sucks (excepting C and asm)
19:05:13 <harwiltz> Alright all, I best be off to sleep. Thanks for all the help centril!
19:05:24 <centril> harwiltz: At the time Java & others was made, it was somewhat acceptable to not have a good type system, because type system research wasn't that well developed at the time, but now it is not acceptable
19:05:34 <centril> harwiltz: you're welcome =)
19:05:51 <Welkin> centril: unless the language is called "Go" and made by google :P
19:06:00 <centril> Welkin: right
19:06:02 <Welkin> then it can be as crappy as they want
19:06:03 <dolio> erisco: id : Int -> Int is a first-order function. It operates on non-function arguments.
19:06:05 <harwiltz> centril: Unfortunately, Java is the only language I learn at my uni (which is ridiculous, I don't even learn C). Thankfully I learn software stuff on my own time
19:06:19 <tom7942> go was made by the people that made plan 9 i think
19:06:22 <centril> harwiltz: Java is very common at all universities, even mine
19:06:33 <erisco> dolio, okay, that's fine, but HKT does not include the word "function"
19:06:35 <dolio> erisco: `f : (Int -> Int) -> Int` is second-order.
19:06:39 <Welkin> harwiltz: that is the unfortunate state of CS "education" it seems
19:06:46 <Welkin> CS people get screwed it seems
19:06:51 <harwiltz> centril: Yeah. But how do you explain not learning C? That's just insulting
19:06:52 <dolio> `g : ((Int -> Int) -> Int) -> Int` is third-order.
19:06:59 <Welkin> I studied computer engineering (with lots of real engineering courses) and we used C and asm
19:07:00 <erisco> if we were talking about "first order type functions" and "higher-order type functions" it'd be a different discussion
19:07:08 <dolio> Maybe : * -> * is first-order.
19:07:09 <erisco> but when we say "higher order type" or "higher-kinded type" that is something else
19:07:15 <harwiltz> Welkin: I'm not even in CS, I'm in comp eng. You'd think java would be more useless even for comp eng than CS
19:07:18 <dolio> Fix : (* -> *) -> * is second-order.
19:07:45 <erisco> a first-order what and a second-order what
19:07:46 <centril> harwiltz: C is important to learn, but it's not really a good language with todays research in mind
19:08:01 <harwiltz> Welkin: Right, I'm in computer engineering (with real engineering courses), but we never learn C and we half-learned asm
19:08:11 <centril> erisco: does it make sense to talk about higher order types even? functions are higher order...
19:08:19 <harwiltz> centril: I guess, but it's very useful for low level stuff like embedded systems
19:08:26 <harwiltz> And OS
19:08:29 <centril> harwiltz: Rust is better =)
19:08:30 <erisco> centril, yes, depending on how you set up the terminology
19:08:38 <Welkin> centril: rust is still immature
19:08:48 <erisco> centril, I am happy saying functions are higher-order values, and so higher-order types are type functions
19:08:54 <dolio> erisco: Higher-kind means that the kind is analogous to the type of a higher-order function.
19:09:02 <harwiltz> centril: Ah. Well I don't learn Rust either, and havent started learning that on my own yet. I should look into that though, I've been hearing a lot about it recently
19:09:16 <centril> Welkin: well, kinda, it is racing towards being an awesome language very fast
19:09:30 <erisco> if everyone means to include the word "function" but keeps forgetting it, well, that isn't my problem :P
19:09:31 <Welkin> but yes, I am interested in rust myself
19:09:49 <harwiltz> Alright guys, thanks again. Off to bed for real now!
19:09:50 <centril> Welkin: =)
19:09:52 <harwiltz> Good night
19:10:22 <centril> erisco: I think it is more clear to talk about higher order type constructors
19:10:33 <centril> less confusion
19:10:36 <nshepperd> hm. (* -> *) -> * is a second order type function
19:10:43 <erisco> sure
19:10:59 <dolio> nshepperd: Well, that specifically is a kind, but it's the kind of a second-order function.
19:11:16 <centril> erisco: besides, Hotc is almost Hots, which is kinda Hot.
19:11:16 <nshepperd> I guess that checks out with the intuitive understanding that 'higher kinded types' means that your variables can range over type functions
19:12:35 <centril> I was supposed to sleep a long time ago... damn...
19:12:46 <Welkin> centril: happens to me all the time
19:13:06 <nshepperd> for instance 'fmap :: Functor f => (a -> b) -> f a -> f b'
19:13:56 <nshepperd> I suppose that could be written out in dependent syntax as '(f :: * -> *) -> Functor f -> (a -> b) -> f a -> f b'
19:14:05 <Welkin> is there confucion over the definition of higer kinded types?
19:14:07 <Welkin> hgher*
19:14:08 <centril> nshepperd: and some foralls to :P
19:14:09 <Welkin> higher*
19:14:18 <centril> Welkin: much it seems ?
19:14:20 <MathUser> Can someone please verify my proof? http://mathb.in/134943 if it is good, I have a follow up question for it (I know it's math related but also know you guys like proofs. I am studying this for type theory)
19:14:32 <erisco> yes there is and I blame whoever came up with the term :P
19:14:36 <nshepperd> which is a second order type function and also contains an application of a second order type function
19:14:41 <Welkin> MathUser: ask in Category Theory if it is CT related
19:14:51 <Welkin> MathUser: ask in #category-theory if it is CT related
19:14:55 <centril> MathUser: try writing it in #agda
19:14:58 <Welkin> it might be ##category-theory
19:15:08 <erisco> as soon as we establish clearly what a higher-typed value is I'll buy whatever higher-kinded type is supposed to mean
19:15:19 <MathUser> Thanks!
19:15:23 <Welkin> lol erisco 
19:15:27 <centril> MathUser: if #agda says your proof is good, your proof is good, barring that agda has bugs
19:15:47 <MathUser> I need to learn Agda :)
19:15:54 <centril> MathUser: and #idris
19:16:53 <Welkin> never heard of a higher-typed value
19:17:04 <Welkin> doesn't make sense
19:17:16 <Welkin> unless you mean a function that takes a function as a parameter
19:17:20 <dolio> A higher-typed value would be a higher-order function.
19:17:23 <Welkin> like fmap
19:17:32 <centril> dolio: right, that makes sense
19:17:39 <centril> somewhat
19:17:52 <dolio> Or one that returns a function if you want to define your orders that way (but people usually don't).
19:17:56 <nshepperd> I've never heard of the term 'higher-typed' and would imagine it's not real
19:18:22 <centril> dolio: aren't you just taking higher-kinded type and extrapolating on values & types ?
19:18:29 <Welkin> to me, HKT only makes sense then if you have a kind that takes a type-function as a parameter
19:18:32 <centril> feels like somewhat an after-the-fact construction
19:18:34 <dolio> Yes, I've never seen someone use the term.
19:18:45 <Welkin> otherwise, it's not a higher-ikind; it's just a kind
19:18:49 <dolio> But there are lots of examples of "higher".
19:18:58 <erisco> take me higher
19:19:24 <Welkin> this was helpful actually :D
19:19:25 <dolio> And I'm not sure I've ever seen a situation where it included 1.
19:19:31 <erisco> to a place where blind men see
19:19:32 <centril> erisco: sorry, I'm Apping your Lam
19:19:32 <Welkin> I never really understood what HKT actually meant
19:20:09 <Welkin> for some reason I thought it was a type constructor, like * -> *
19:20:15 <Welkin> but that is obviously wrong
19:20:31 <nshepperd> that's what I thought too
19:20:37 <tswett_to_go> I've been craving to write some Haskell code...
19:20:42 <tswett_to_go> So I'm going to write a database query language. :D
19:20:54 <nshepperd> it's not that obviously wrong, to me
19:21:07 <Welkin> nshepperd: after the discussion that just happened, it is
19:21:20 <Welkin> but what is Higher-Kinded Polymorphism?
19:21:34 <centril> Welkin: classes over that ?
19:21:51 <nshepperd> I mean, the main problem with lots of languages that don't have HKTs is that they also don't have types of kind * -> *
19:21:54 <erisco> centril, and I counter by eta expansion
19:21:55 <Welkin> (* -> *) -> Constraint ?
19:22:20 <centril> Welkin: PolyKinds  ? 
19:22:22 <nshepperd> they might have macros that can expand into a type of kind * when passed a type, but those macros don't have a kind
19:22:25 <dolio> There aren't many of those anymore.
19:22:31 <erisco> centril, or I suppose beta would make more sense
19:23:19 <Welkin> oh, HKP would be ReaderT?
19:23:23 <Welkin> :k ReaderT
19:23:25 <lambdabot> * -> (k -> *) -> k -> *
19:23:31 <Welkin> because of the kind variable
19:23:37 <dolio> That would be polymorphic kinds.
19:23:48 <centril> nshepperd: is doing it by macro an important distinction ?
19:23:58 <Welkin> okay
19:24:01 <Welkin> so what is HKP?
19:24:10 <erisco> nshepperd, do they not? I don't see why they can not
19:24:24 <centril> erisco: yes, i dont see it too
19:24:49 <centril> Welkin: we need a glossary :/
19:24:55 <centril> clearly this is all levels of confusing
19:25:15 <centril> You all know what happens when you don't have shared facts...
19:25:26 <erisco> you probably cannot use this kind, but it'd be like saying Haskell doesn't have bottom because you can't use it
19:25:27 <centril> BAD STUFF.
19:25:28 <Welkin> but then, how is a kind variable useful?
19:25:49 <Welkin> does that just mean it could be * or * -> *?
19:26:26 <centril> erisco: WHNF is verboten
19:26:38 <erisco> Welkin, yes, that is what it means
19:26:57 <dolio> Welkin: I would guess people mean it to involve being able to quantify over the things that can be used as arguments in higher kinds.
19:27:08 <Welkin> Are there other kinds in haskell tht are actually useful besides *?
19:27:14 <dolio> So it would be pretty odd to have the kinds but not the polymorphism.
19:27:21 <erisco> yes, all the promoted ones you get with DataKinds
19:27:25 <centril> Welkin: there is #, Constraint
19:27:34 <centril> # <-- magic hash
19:27:37 <Welkin> * is a weird (and confusing) name
19:27:43 <Welkin> why not call it Type like in Idris?
19:27:44 <centril> Welkin: s/*/Type
19:27:55 <erisco> possibly because of Miranda, but I don't know
19:27:57 <monochrom> * -> * is useful. When I turn on DataKinds and define "data X = Y | Z", the kind X is useful.
19:28:09 <erisco> in Miranda your type variables were *, **, ***, and so on :P
19:28:37 * monochrom cringes, unary type variable notation?!
19:28:48 <dolio> Yep.
19:29:03 <monochrom> If I have 20 type variables, is it going to be "My God it's full of stars!!!!"
19:29:34 <erisco> pipes or lens in Miranda, oh boy
19:29:34 <monochrom> The number of stars grows quadratically to the number of type variables, did they notice that?
19:29:39 <tswett_to_go> I'm not totally sure what to name my modules. If I'm implementing a language, and I want to refer to it as "LaserDb", does that mean I should probably name the root module Language.LaserDb?
19:29:49 <centril> Welkin: https://www.reddit.com/r/haskell/comments/4180k3/what_is_typeintype/
19:30:02 <tswett_to_go> With 100 type variables, you get at least 5,050 stars. Hmm.
19:30:05 <centril> tswett_to_go: that is standard
19:30:10 <mniip> * :: *
19:30:19 <mniip> :: :: * -> *
19:30:20 <centril> :k *
19:30:21 <lambdabot> error:
19:30:21 <lambdabot>     Not in scope: type constructor or class ‘*’
19:30:21 <lambdabot> error: Operator applied to too few arguments: *
19:30:27 <centril> lambdabot: dude...
19:30:37 <dolio> It's a very odd choice, since ML had named variables, I'm sure.
19:30:37 <centril> :k Type
19:30:39 <lambdabot> error:
19:30:39 <lambdabot>     Not in scope: type constructor or class ‘Type’
19:30:41 <erisco> that is not how you refer to it actually
19:30:52 <centril> Ok, lambdabot needs some updating ?
19:30:53 <mniip> :k Data.Kind.*
19:30:55 <lambdabot> *
19:30:55 <tswett_to_go> centril: coo', thanks.
19:31:03 <centril> mniip: aah
19:31:06 <monochrom> tswett_to_go: Since it's for databases, you may also choose "DataBase.LaserDB".
19:31:21 <erisco> it is weird, and I don't know why, but DataKinds gives a special way to refer to it that mniip just showed
19:31:26 <monochrom> And since "LaserDB" is pretty unique, you may also just choose "LaserDB"
19:31:27 <Welkin> mniip: privet, comrade
19:31:35 <mniip> DataKinds?
19:31:38 <mniip> Data.Kind is a module
19:31:50 <erisco> yes, I am aware
19:31:59 <mniip> I think it was added in 7.12 for compatibility reasons?
19:32:09 <mniip> and defines type Kind along with type *
19:32:12 <tswett_to_go> I'd probably go with either Language.LaserDb or DataBase.Laser.
19:32:13 <mniip> er
19:32:15 <mniip> type Type
19:32:21 <centril> tswett_to_go: I'd also just go for LaserDB
19:32:28 <mniip> Welkin, well hello
19:32:29 <centril> tswett_to_go: short and sweet is nice
19:32:51 <tswett_to_go> *nod* Yeah, that works!
19:33:20 <centril> mniip: privet tavarich
19:33:21 <erisco> you guys have it all wrong
19:33:57 <erisco> Org.Tswett.LaserDB obv
19:34:10 <centril> erisco: =====> Java land :P
19:34:14 <lifter> Is there another place I should go to ask Spacemacs/Emacs related questions?
19:34:25 <tswett_to_go> You mean Net.Warrigal.LaserDB. :D
19:34:36 <tswett_to_go> I hope nobody's going to be offended if I go with LaserDb instead of LaserDB.
19:34:46 <mniip> centril, дратути
19:34:51 <erisco> ICANN already does the work of ensuring uniqueness
19:34:58 <centril> mniip: I can't read cyrillic tho
19:34:59 <Welkin> lol wtf?
19:35:24 <centril> tswett_to_go: noooo don't do it. LaserDB is way cooler.
19:35:31 <Welkin> centril: that reddit thread you linked has someone saying "HKT is a type that takes a type"
19:35:40 <Welkin> the confusion pervades
19:35:46 <centril> Welkin: wat?
19:35:48 <centril> ...
19:35:50 <erisco> I think you're missing the opportunity of DbLaser
19:35:56 <tswett_to_go> Mmmmmmmm. I just don't know if I can bring myself to call it LaserDB. :D
19:35:57 <boccato> hspec's before and around are making me mad, i just can't understand how to combine them
19:36:04 <tswett_to_go> erisco: I've thought about calling it that!
19:36:08 <tswett_to_go> "The Database Laser"
19:36:31 <boccato> This post finishes with "Simply combine the with app and around withRollback"... and I simply cannot do that!
19:36:35 <monochrom> The King Edward and the Database Laser.
19:36:54 <boccato> https://begriffs.com/posts/2014-10-19-warp-server-controller-test.html
19:37:14 <centril> tswett_to_go: LightAmplificationByStimulatedEmissionOfRadiationDb
19:37:18 <nshepperd> tswett_to_go: laser decibels?
19:37:32 <tswett_to_go> The official name of the language is just "Laser", though.
19:37:38 <tswett_to_go> Harry Potter and the Database Laser?
19:37:58 <centril> tswett_to_go: Fantastic Beasts and where to find a Laser for Databases.
19:38:04 <tswett_to_go> And "laserdb" is just a secondary disambiguative moniker.
19:38:09 <monochrom> The potter Harry and the database Laser.
19:38:25 <nshepperd> when you titlecase an initialism, a puppy cries
19:38:41 <centril> nshepperd: dafuq is titlecase?
19:38:50 <monochrom> "Db"
19:38:54 <nshepperd> Titlecase, UPPERCASE, lowercase
19:38:55 <mniip> Xml Http Request
19:38:58 <centril> oh
19:39:08 <erisco> snake_case
19:39:13 <Koterpillar> nshepperd: TitleCase?
19:39:17 <centril> CamelCase
19:39:20 <mniip> --kebab-case
19:39:20 <Welkin> LASER: Light Amplification by Stimulated Emission of Radiation
19:39:21 <Welkin> :D
19:39:25 <tswett_to_go> module laser'data'base where
19:39:41 <Welkin> centril: wrong!!
19:39:46 <Welkin> that is CapsCase D:<
19:39:54 <Koterpillar> camelCase
19:39:54 <Welkin> this is camelCase
19:40:02 <erisco> lowerCamelCase UpperCamelCase
19:40:04 <centril> Welkin: CapitalCamelCase
19:40:23 <erisco> CAPSCASE come on people
19:40:25 <Welkin> and then you have the-weird-lisp-stuff
19:40:47 <centril> Upper_Camel_Snake_Case
19:41:02 <centril> go nuts with (.) on naming conventions
19:41:04 <tswett_to_go> antIcameLcasE
19:41:18 <centril> LaTeX
19:41:34 <centril> MiDDleCaSe
19:41:50 <tswett_to_go> vOwElcAsE
19:42:08 <centril> KKKKoNSoNaNTCaSe
19:42:20 <nshepperd> those are just variations on l33tsN1perCasE
19:42:43 <erisco> I feel like real progress is occurring right now
19:42:56 <centril> erisco: right RIGHT
19:43:07 <tswett_to_go> aɪpiːˈeɪ keɪs
19:44:08 <centril>  \case
19:44:09 <nshepperd> never mind actual progress, a feeling of progress is what's important
19:44:18 <centril> LambdaCase .
19:44:22 <Welkin> what about china case? 大便
19:44:24 <tswett_to_go> module ˌleɪzɹ̩diːˈbiː where
19:44:34 <Welkin> we need unicode variable names!
19:45:13 <Koterpillar> Welkin: case isn't defined for CJK, AFAIR
19:45:22 <centril> Welkin: "By the way, I thought it was about time I built my own Agda library. With no fucking unicode. " - Conor McBride, https://mobile.twitter.com/pigworker/status/764410137884909568
19:45:23 <Welkin> I know :D
19:45:26 <Koterpillar> (also, language!)
19:45:28 <tswett_to_go> Hiragana vs katakana is sort of like case.
19:45:43 <centril> Koterpillar: not my language :P
19:45:44 <Koterpillar> tswett_to_go: but does Unicode standard agree?
19:45:57 <centril> blame Conor ^,-
19:46:13 <Koterpillar> centril: sorry, that was to Welkin
19:46:17 <centril> ^^
19:46:20 <tswett_to_go> I'm sure that the Unicode standard does not say anywhere, "The distinction between hiragana and katakana is *not* sort of like the distinction between lowercase and uppercase letters."
19:46:25 <monochrom> > case 5 of λ -> λ*λ
19:46:28 <lambdabot>  25
19:46:50 <centril> monochrom: wat ?
19:46:53 <centril> magic...
19:47:05 <Koterpillar> > isUpper "ひ"
19:47:07 <lambdabot>  error:
19:47:07 <lambdabot>      • Couldn't match expected type ‘Char’ with actual type ‘[Char]’
19:47:07 <lambdabot>      • In the first argument of ‘isUpper’, namely ‘"\12402"’
19:47:11 <Koterpillar> > isUpper 'ひ'
19:47:13 <lambdabot>  False
19:47:17 <Koterpillar> > isLower 'ひ'
19:47:20 <lambdabot>  False
19:47:29 <tswett_to_go> Well, I think I'm going to succumb to peer pressure and name this module "LaserDB".
19:47:32 <erisco> there is this nice little case/of feature for types with literals
19:47:35 <Welkin> those are only defined on the ascii range o.o
19:47:38 <erisco> where it uses the Eq instance
19:47:44 <Koterpillar> > let ひ = "hi" in ひ
19:47:44 <centril> also, -case (EmptyCase) is always useful
19:47:46 <lambdabot>  "hi"
19:47:52 <Welkin> tswett_to_go: that is the trend these days
19:47:55 <Koterpillar> @let data ひ = ひ
19:47:55 <lambdabot>  Parse failed: Illegal character ''\12402''
19:47:57 <centril> tswett_to_go: that's the spirit!
19:48:09 <Welkin> no namespacing, just top-level name squatting
19:48:23 <centril> Has anyone ever had an actual use for EmptyCase ?
19:48:29 <mniip> > generalCategory 'ひ'
19:48:30 <erisco> yes
19:48:31 <lambdabot>  OtherLetter
19:48:35 <monochrom> What is EmptyCase?
19:48:40 <Koterpillar> @let data ヒ = ヒ
19:48:41 <lambdabot>  Parse failed: Illegal character ''\12498''
19:48:51 <erisco> you need it to inhabit Void
19:48:56 <centril> monochrom: a case with no patterns
19:48:57 <Welkin> > generalCategory 💩
19:48:59 <lambdabot>  <hint>:1:18: error:
19:49:00 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
19:49:03 <Welkin> lol
19:49:04 <monochrom> Oh! That one.
19:49:12 <erisco> or want it, at least, and unfortunately Haskell doesn't check it correctly
19:49:14 <mniip> quotes
19:49:20 <centril> erisco: right, but can't you do ordinary pattern not-match ?
19:49:25 <tswett_to_go> > case 6 of {}
19:49:28 <lambdabot>  *Exception: <interactive>:3:1-4: Non-exhaustive patterns in case
19:49:29 <Welkin> > generalCategory '💩'
19:49:31 <lambdabot>  OtherSymbol
19:49:36 <erisco> I am not aware of a pattern not-match notation
19:49:42 <centril> erisco: :P
19:49:44 <Koterpillar> tswett_to_go: checked GHCi, it refuses to make ヒ a constructor
19:49:53 <erisco> well it exists in other languages
19:49:58 <Welkin> Koterpillar: that is because it's an animal! D:<
19:50:06 <centril> erisco: it is there <hand waving> I think ?
19:50:13 <centril> erisco: agda has it iirc
19:50:20 <mniip> > generalCategory 'ヒ'
19:50:22 <lambdabot>  OtherLetter
19:50:26 <mniip> it's not an UppercaseLetter
19:50:29 <Welkin> Koterpillar: I can't tell if that is the chinese character or the katakana
19:50:36 <centril> but Void is kinda more important in Agda
19:50:41 <Welkin> probably katakana
19:50:54 <lifter> That's katakana "hi"
19:50:59 <erisco> eh, well, that is somewhat just because of how Agda is used
19:51:08 <Koterpillar> Welkin: ヒト doesn't work either
19:51:27 <Welkin> a perosn is still an animal!
19:51:29 <Welkin> person*
19:52:36 <centril> erisco: right
19:53:02 <centril> erisco: well, using agda as a general purpose language is probably painful
19:53:10 <erisco> though in Haskell you also end up limited because DataKinds is limited in what it can promote
19:53:44 <centril> the only time I've actually dealt with Void is for Trees that Grow
19:53:54 <centril> https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/trees-that-grow.pdf
19:54:13 <erisco> and limited in what type level functions you can write
19:54:36 <mniip> :let data 𝓓𝓪𝓽𝓪 = 𝕯𝖆𝖙𝖆
19:54:43 <mniip> @let data 𝓓𝓪𝓽𝓪 = 𝕯𝖆𝖙𝖆
19:54:44 <lambdabot>  Defined.
19:55:01 <centril> does lambdabot have all extensions enabled, or what?
19:55:07 <mniip> no
19:55:35 <erisco> but Haskell has the wonderful traits of simplicity and better inference
19:55:38 <centril> but dont you need UnicodeSyntax for this ... ?
19:55:44 <mniip> yes you do
19:55:51 <mniip> er
19:55:52 <mniip> no
19:55:57 <mniip> not for this in particular
19:56:01 <centril> ah
19:56:06 <mniip> this is not unicode *syntax*, just identifier
19:56:12 <centril> right
19:56:30 <mniip> I wonder if :t was fixed
19:56:33 <mniip> :t 𝕯𝖆𝖙𝖆
19:56:35 <lambdabot> ????
19:56:38 <mniip> :(
19:56:59 <erisco> lambdabot is confused
19:57:08 <tswett_to_go> So I'd like to define a function or two for converting a String into my language's Identifier type.
19:57:12 <centril> btw, if you haven't read the trees that grow paper i highly recommend it
19:57:38 <tswett_to_go> I'd like to have toIdentifierMaybe :: String -> Maybe Identifier, and also toIdentifier :: String -> Identifier, which just does "error" for invalid identifiers.
19:57:52 <centril> tswett_to_go: that paper might be useful to you as well in language design if you need tree decoration
19:58:28 <centril> tswett_to_go: toIdentifier = fromJust . toIdentifierMaybe
19:58:51 <centril> tho I don't recommend it
19:59:13 <erisco> the more conventional names would be  parseIdentifier :: String -> Maybe Identifier  and  unsafeParseIdentifier :: String -> Identifier
19:59:21 <centril> erisco: +1
19:59:27 <centril> or just skip the unsafe part
19:59:46 <tswett_to_go> But I want to give a good error message in the case that it's not a valid identifier.
20:00:10 <centril> tswett_to_go: Either GoodErrorMessage Identifier
20:00:16 <tswett_to_go> I want to say "error: this string has length 53 but identifiers have a maximum length of 50" rather than "error: nope, sorry".
20:01:29 <tswett_to_go> erisco: unsafeParseIdentifier, really? I usually think of "unsafe" as meaning "violates the assumptions that are generaly made about Haskell code".
20:01:36 <centril> tswett_to_go: offering partial functions is also promoting their use, kinda...
20:01:42 <erisco> yeah, and totality is one of those assumptions
20:01:46 <centril> idd
20:02:04 <centril> tswett_to_go: don't promote the use of partial functions, please :P
20:02:05 <erisco> it is why people balk at head and tail
20:02:06 <tswett_to_go> "Unsafe" makes me think unsafePerformIO and unsafeCoerce, not error and undefined.
20:02:37 <centril> tswett_to_go: well, undefined is basically just an unsafePerformIO to something that always crashes
20:02:43 <okeuday_bak> what version of GHC attaches is the first to attach the stack trace to error function use?
20:02:47 <centril> or you could define it as such
20:02:57 <tswett_to_go> Anyway... how about...
20:03:11 <tswett_to_go> parseIdentifierEither :: String -> Either String Identifier; parseIdentifier :: String -> Maybe String
20:03:12 <nshepperd> + is just an unsafePerformIO to something that adds two numbers then does nothing :p
20:03:20 <tswett_to_go> Er, s/Maybe String/Maybe Identifier/
20:03:44 <Welkin> has anyone used sorts in haskell?
20:03:47 <tswett_to_go> And just forget about the String -> Identifier version
20:03:49 <erisco> parseIdentifierWithError perhaps
20:03:59 <centril> tswett_to_go: flip them around - Either is should be the default
20:04:19 <nshepperd> parseIdentifierOrDie
20:04:30 <tswett_to_go> parseIdentifier :: String -> Either String Identifier; parseIdentifierMaybe :: String -> Maybe Identifier?
20:04:43 <centril> parseIdentifier = either (const Nothing) pure . parseIdentifierEither
20:04:47 <erisco> I don't see parts of the type being included in the name that often
20:04:51 <erisco> it is already in the type, after all
20:04:58 <Welkin> :k ExceptT
20:05:00 <centril> erisco: right - no hungarian notation
20:05:00 <lambdabot> * -> (* -> *) -> * -> *
20:05:04 <Welkin> :k ReaderT
20:05:06 <lambdabot> * -> (k -> *) -> k -> *
20:05:06 <tswett_to_go> Yeah, but I can't call them both parseIdentifier.
20:05:11 <glguy> :t mapMaybe
20:05:12 <lambdabot> (a -> Maybe b) -> [a] -> [b]
20:05:15 <centril> tswett_to_go: parseIdentifier'
20:05:31 <centril> or parseIdentifierM
20:05:40 <erisco> yes there are lots of exceptions glguy :P
20:05:47 <tswett_to_go> I like parseIdentifierM.
20:05:59 <centril> tswett_to_go: you should really put all your parsers in a neat type class
20:06:02 <glguy> enough that it's not worth making a confusing name to avoid it
20:06:27 <tswett_to_go> I should keep in mind that for the time being, I don't care about making a stable public API...
20:06:47 <erisco> I didn't say it should be confusing
20:07:06 <centril> tswett_to_go:  class Parsable (t :: *) where  type Repr t = r | r -> t ;  parse :: String -> Either Err (Repr t) ;
20:07:10 <Welkin> didn't ghc8 add more sorts to haskell?
20:07:12 <erisco> if they called it mapAndFilter or something that wouldn't be confusing
20:07:21 <centril> tswett_to_go: wait... you don't need the Repr
20:07:46 <centril> just class Parsable (t :: *) where parse :: String -> Either Err t
20:07:54 <glguy> welkin: with TypeInType, the sky is the limit
20:08:24 <centril> glguy: you can even reach the bottom!
20:08:27 <erisco> it is type universes all the way down
20:08:28 <nshepperd> I would have parseIdentifier with the Either, and parseIdentifier' or parseIdentifierOrDie for the partial function
20:08:41 <tswett_to_go> I'm planning to use Parsec (or Megaparsec).
20:09:01 <nshepperd> only bother providing the partial function if people frequently need to convert identifiers that are known to be valid
20:09:02 <tswett_to_go> I could just give you a parser for identifiers instead of this parseIdentifier function.
20:09:04 <tswett_to_go> *shrug*
20:09:07 <centril> nshepperd: is that Or, or Xor ?
20:09:37 <nshepperd> if you're using a parser library, you could just provider a parser, yeah
20:09:46 <centril> yes, do that
20:09:50 <fede> hi
20:09:57 <centril> and then add a type class to provide parsers for all your types
20:10:02 <nshepperd> CharParsing m => m Identifier
20:10:07 <fede> i need some help with a little problem
20:11:10 <nshepperd> centril: parsing an identifier *and* dying is hardly distinguishable from dying on its own, so it doesn't matter :p
20:11:58 <barrucadu> fede: What is your problem? (also: don't ask to ask, just ask)
20:11:59 <centril> nshepperd: "And, as his last act, he parsed an identifier, and them promptly proceed to die."
20:12:02 <centril> Sad.
20:12:11 <centril> nshepperd: total failure.
20:12:24 <erisco> this is what we call a "don't care" and denote it with an underscore
20:13:20 <centril> clearly I'm not fit to write text at this hour...
20:13:32 <centril> Time to sleep... Goodnight y'all
20:18:00 <Welkin> yeah
20:18:09 <Welkin> I'm trying to program right now, and my whole screen is orange
20:18:11 <Welkin> because of flux
20:18:40 <Welkin> I turned it off for a moment and my eyes were assaulted by blue light
20:19:18 <centril> Dont do that
20:19:25 <Welkin> yeah
20:19:29 <centril> Protip
20:20:06 <Welkin> all of my terminals and emacs use a dark theme too :P
20:20:16 <centril> Except when watching movies 
20:20:18 <Welkin> the web browser is the only thing that really assaults me
20:20:43 <centril> Yeah I wish web pages were dark 
20:21:12 <centril> It's not the browser but the websites 
20:21:19 <Welkin> I always wanted a dark theme website for myself :D
20:21:35 <Welkin> but it goes against "common wisdom"
20:21:45 <centril> Firefox dev edition has a dark chrome 
20:21:54 <centril> It's nice 
20:22:01 <Welkin> dark theme?
20:22:07 <tswett_to_go> Is there a library function which will convert a Char to its Unicode number string thingy, such as "U+201A" or "U+1FE08"?
20:22:21 <Welkin> > ord 'c'
20:22:23 <lambdabot>  99
20:22:32 <centril> Right the chrome is dark
20:22:33 <Welkin> > ord '好'
20:22:35 <lambdabot>  22909
20:22:44 <Welkin> twomix: ^
20:22:45 <Welkin> er'
20:22:49 <Welkin> tswett_to_go: ^
20:23:10 <tswett_to_go> But I'm looking for "U+0063" in that case.
20:23:16 <centril> Those parts of the browser not displaying the web page itself
20:23:24 <tswett_to_go> Guess I can do ord, convert it to hex with padding out to 4 digits, and stick "U+" on the front.
20:23:41 <Koterpillar> tswett_to_go: 4 digits is not enough
20:23:52 <Welkin> Koterpillar: 4 digits is enough for anybody
20:24:21 <tswett_to_go> Koterpillar: yeah, that's why I said "pad out". Use 4 digits if 4 digits is enough, otherwise use 5 digits.
20:25:55 <centril> Representing years with 2 digits... What could go wrong? 
20:29:10 <tswett_to_go> It's not quite a library function, but looks like (Text.Printf.printf "U+%04X" :: Int -> String) does the trick.
20:38:24 <erisco> cool, I generated a puzzle
20:42:43 <trineroks> hey guys, why can't I continuously concat a list like this?
20:42:53 <trineroks> element : element1 : element2 : ...
20:43:00 <trineroks> it works for element : element1
20:43:04 <trineroks> but when I add : element2
20:43:08 <trineroks> it throws an error
20:43:11 <erisco> : is cons, not concat
20:43:19 <trineroks> sorry then, cons
20:43:19 <erisco> and for element : element1 to work element1 has to be a list
20:43:20 <jle`> > 1 : 2 : 3 : [4,5,6]
20:43:23 <lambdabot>  [1,2,3,4,5,6]
20:43:32 <erisco> indicated by the type of :
20:43:34 <tom7942> :t (:)
20:43:34 <erisco> :t (:)
20:43:35 <lambdabot> a -> [a] -> [a]
20:43:36 <lambdabot> a -> [a] -> [a]
20:43:42 <jle`> which is 1 : (2 : (3 : [4,5,6]))
20:44:14 <tom7942> :t snoc
20:44:16 <lambdabot> Snoc s s a a => s -> a -> s
20:45:16 <erisco> this is the most common misconception about lists, I think, and I had it to
20:45:22 <erisco> : does not put two elements together
20:45:25 <trineroks> oh
20:45:29 <erisco> : puts an element and a list geother
20:45:30 <trineroks> so it's element added to a list?
20:45:30 <trineroks> so
20:45:31 <trineroks> element : list
20:45:34 <erisco> together*
20:45:38 <jle`> > 3:[4,5,6]
20:45:40 <lambdabot>  [3,4,5,6]
20:45:44 <jle`> > 2 : (3:[4,5,6])
20:45:46 <lambdabot>  [2,3,4,5,6]
20:45:49 <trineroks> then how would you do element + list + list2?
20:45:52 <jle`> > 1 : (2 : (3 : [4,5,6]))
20:45:54 <lambdabot>  [1,2,3,4,5,6]
20:45:57 <trineroks> is that
20:45:59 <erisco> (x : xs) ++ ys
20:46:02 <jle`> trineroks: you can use (++), which concatenates two lists
20:46:03 <trineroks> element : (concat (list list2))?
20:46:13 <erisco> or  x : (xs ++ ys)
20:46:15 <jle`> element : list1 ++ list2
20:46:21 <trineroks> alright, thanks
20:46:21 <erisco> you can prove the equivalence if you like :)
20:58:14 <trineroks> okay, this approach is not working
20:58:25 <erisco> lol this library has some issues with killing children
20:58:38 <trineroks> how would I do a nested for loop in haskell while adding to a list?
20:59:49 <erisco> by approaching the problem quite differently, likely
21:00:46 <jle`> trineroks: we would need more details to be able to help
21:00:53 <tom7942> no loops, only recursion
21:00:54 <trineroks> yeah I'm writing up what I want this to do in pseudo
21:01:11 <jle`> learning haskell helps you see how much we rely on loops as a crtuch
21:01:14 <jle`> *crutch
21:01:45 <tom7942> trineroks: can you write something like length :: [a] -> Int  in haskell yet?
21:02:12 <trineroks> http://pastebin.com/AR44V4TY
21:02:17 <trineroks> yes I can
21:02:44 <trineroks> you'd just recursively go through each element in a list and add 1, and when the head is empty you return a 0
21:03:00 <tom7942> cool, so you know how to loop
21:04:00 <erisco> trineroks, there is more than one answer, but one is a list comprehension
21:04:03 <tswett_to_go> All right, here's a bit of code.
21:04:09 <erisco> trineroks, so  [(x,y) | x <- xs, y <- ys]
21:04:11 <tswett_to_go> I'm sort of an "old newbie" with Haskell.
21:04:27 <tswett_to_go> I first learned about it, like, 15 years ago or whatever, but I don't have any experience writing code for other people to read.
21:04:38 <lpaste_> tswett pasted “LaserDB.Identifier” at http://lpaste.net/353801
21:04:55 <tswett_to_go> ^^^ Something tells me I did a bunch of confusing, non-idiomatic stuff there. :D
21:05:03 <erisco> trineroks, another is the list Applicative, so  (,) <$> xs <*> ys
21:05:20 <trineroks> can you explain what [(x,y) | x <- xs, y <- ys] does?
21:05:26 <tswett_to_go> Oh, I forgot to write the export list...
21:06:22 <erisco> trineroks, it does xs >>= \x -> ys >>= \y -> return (x, y)
21:06:29 <jle`> tswett_to_go: it returns a list of all combinations of x and y from xs and ys
21:06:32 <jle`> * trineroks 
21:06:39 <jle`> that's how list comprehensions work
21:06:57 <erisco> or just for that specific example it is the Cartesian product of xs and ys
21:06:58 <tswett_to_go> If someone would like to take a look at my code and offer a comment or two, I'd really appreciate it!
21:07:01 <jle`> but, you can also write it from scratch
21:07:24 <jle`> trineroks: you can start the same way you started wit 'length'
21:07:35 <jle`> trineroks: allPairs [] [] = ...
21:07:40 <jle`> trineroks: allpairs (x:xs) [] = ...
21:07:49 <trineroks> yeah, that snippet isn't doing what I intend it to do
21:07:57 <erisco> you can also read it like set builder notation
21:07:59 <jle`> trineroks: allPairs [] (y:ys) = ...
21:08:04 <jle`> allPairs (x:xs) (y:ys) = ..
21:08:16 <erisco> *like*, as it isn't, but similar concept
21:08:39 <jle`> tswett_to_go: what's the issue?
21:08:48 <jle`> tswett_to_go: or are you just looking to clean it up
21:08:56 <erisco> trineroks, what snippet?
21:09:17 <tswett_to_go> jle`: I'm just looking for feedback about style.
21:09:30 <trineroks> [(x,y) | x <- xs, y <- ys]
21:09:31 <trineroks> this one
21:09:50 <erisco> > [(x,y) | x <- "abc", y <- [1..2]]
21:09:50 <tswett_to_go> Does all of this look idiomatic, or am I doing some unconventional stuff?
21:09:53 <lambdabot>  [('a',1),('a',2),('b',1),('b',2),('c',1),('c',2)]
21:10:20 <trineroks> I don't know why, but I'm getting this error "Couldn't match expected type [[Char]] -> t with actual type [Integer]"
21:10:31 <trineroks> I'm testing this using List A = [1,2]
21:10:38 <trineroks> List B = ["string", "string2"]
21:10:51 <jle`> hm, variable names can't have spaces in them
21:10:58 <jle`> and they also can't start with capital letters
21:11:28 <trineroks> oh wait
21:11:31 <trineroks> nevermind, I'm a dumbass
21:11:40 <trineroks> I forgot to preface it with my function name lol
21:11:49 <trineroks> ah there we go
21:12:23 <trineroks> but if I wanted to write this from scratch...
21:14:24 <trineroks> jle`, [] means an empty list right?
21:14:28 <tom7942> start with your base case, make it work for one more
21:14:33 <jle`> trineroks: yes
21:14:36 <tom7942> recurse
21:16:16 <erisco> tswett, your first clause of parseIdentifier looks suspicious
21:16:38 <erisco> tswett, unless I misunderstand guards, I think the first clause will always be used because all strings match str
21:17:08 <erisco> tswett, so it will either return Left reserved-word-error or crash
21:18:36 <tswett_to_go> erisco: thanks for taking a look. It seems to be working fine; when the guard expression comes out as False, it's falling through to the next equation.
21:18:55 <erisco> that is weird
21:19:55 <erisco> I didn't think guards fell through like that
21:21:58 <tom7942> yeah, you usually write: | otherwise = 
21:22:03 <tom7942> which is the same as | False = 
21:22:10 <tom7942> er True 
21:22:13 <Koterpillar> > otherwise
21:22:15 <lambdabot>  True
21:22:27 <erisco> even without that I didn't think it fell through
21:22:46 <erisco> because I was writing some complicated cases a few months ago and I remember that not happening
21:22:46 <MarcelineVQ> tswett_to_go: the name repetition is hard to read through, consider using a case statement for parseIdentifier, you can also combine the multiple different guards into one or two guard blocks
21:22:51 <erisco> suppose I remember incorrectly
21:25:29 <tswett_to_go> MarcelineVQ: that's a good idea, thanks.
21:25:58 <erisco> why the bang pattern in showsPrec?
21:26:07 <erisco> I thought a pattern match there was already strict
21:26:33 <trineroks> hey guys, "maximum" just returns the highest member of a list, right?
21:26:39 <tswett_to_go> What do y'all think of IdentifierInternal, Identifier, fromIdentifier and toIdentifier? Good idea or pointless overkill?
21:27:14 <tswett_to_go> erisco: nope, it's not strict in (Identifier str) without the bang.
21:27:17 <erisco> well I am not sure why the data constructor is not just called Identifier
21:27:20 <erisco> but it is fine to newtype String
21:27:35 <barryburd> I’ve defined a class as follows:
21:27:36 <barryburd> class Fancy a where
21:27:37 <barryburd>   fancy :: a -> String
21:27:40 <erisco> tswett_to_go, is this something to do with it being a newtype?
21:27:53 <barryburd> define Purchase as follows:
21:28:00 <barryburd> data Purchase = Purchase Item Amount
21:28:17 <barryburd> I let Int and Purchase be instances of Fancy
21:28:38 <tswett_to_go> erisco: the bang thing, you mean? The reason I want it to be strict in str is so that if there's an error, it gives you the error message right away instead of starting to print stuff out and then showing you the error.
21:29:01 <barryburd> When I try to do putStrLn $ Fancy 33    , I get an ambiguous type message. Why does Haskell think that 33 might be a Purchase?
21:29:51 <erisco> tswett_to_go, I don't know what that means. Pattern matches are strict, as far as I know, and so I don't see the bang being necessary
21:30:04 <erisco> tswett_to_go, but maybe the rules are different wrt newtypes, I wouldn't be so surprised
21:30:59 <tswett_to_go> As for why the data constructor isn't just called Identifier, the motivation is that I want users of this module to be able to pattern match on Identifier, but not to use it to create their own Identifier values.
21:31:05 <erisco> barryburd, did you mean  putStrLn $ fancy 33  ?
21:31:23 <barryburd> Yes, I meant putStrLn $ fancy 33
21:31:38 <tswett_to_go> erisco: I think pattern matches are only strict as far as the pattern goes... so to speak.
21:31:50 <Koterpillar> :t 33 -- barryburd
21:31:51 <tswett_to_go> > (\(Just x) -> "hello") (Just undefined)
21:31:51 <lambdabot> Num t => t
21:31:54 <lambdabot>  "hello"
21:32:09 <tswett_to_go> erisco: ^^^ it's strict in (Just x), but it's not strict in x.
21:32:16 <erisco> barryburd, please lpaste the whole error, but it is probably because 33 is polymorphic
21:32:38 <erisco> barryburd, I don't think it looks at available instances and then decides what the type is
21:32:49 <erisco> barryburd, rather it figures out the type and then finds an instance
21:33:05 <erisco> barryburd, so when the type is variable then so can be the instance, hence an ambiguity error
21:33:16 <tswett_to_go> erisco: now that I think about it again, I think newtypes must be special here after all.
21:33:48 <erisco> > (\!(Just x) -> "hello") (Just undefined)
21:33:50 <lambdabot>  <hint>:1:13: error: parse error on input ‘->’
21:34:06 <erisco> > let foo !(Just x) = "hello" in foo (Just undefined)
21:34:08 <lambdabot>  "hello"
21:34:14 <erisco> see, your example is incorrect
21:34:15 <tswett_to_go> I think pattern matching on the constructor of a newtype doesn't force anything at all.
21:34:41 <tswett_to_go> Let me see, can I...
21:34:42 <erisco> you placed undefined where x is, and of course it is not strict on x because we do not pattern match on x
21:34:53 <tswett_to_go> @newtype MyString = MyString String
21:34:53 <lambdabot> Unknown command, try @list
21:35:05 <barryburd> Ambiguous type variable arising from a use of ‘fancy’ … Potential instances exist: instance Fancy Purchase, instance Fancy Int…
21:35:30 <erisco> which you acknowledge, but then it just proves the redundancy of the bang in showsPrec
21:35:30 <barryburd> That’s much of the error message (not all of it)
21:35:39 <erisco> barring different rules for newtype
21:36:04 <erisco> barryburd, try (33 :: Int)
21:36:46 <barryburd> Yes, (33 :: Int) works. I’m just not sure why it’s suggesting Purchase as one of the possible types.
21:36:46 <tswett_to_go> And if that's the case, that means we've proved that there are in fact different rules for newtype.
21:36:52 <erisco> it is just listing instances
21:36:58 <erisco> it doesn't know Purchase is not a Num
21:37:10 <erisco> like I said, it does not consider "here are the only instances I have"
21:37:17 <erisco> it figures out the type and then finds an instance
21:37:42 <erisco> so if you chose the Purchase instance it would then be looking for Num Purchase
21:38:20 <barryburd> OK. I have some further investigating to do about Int and Num. Thank you.
21:39:06 <glguy> tswett_to_go: Yes, pattern matching on a newtype doesn't force anything. The newtype constructors don't exist at runtime
21:39:21 <tswett_to_go> I want to do a test, but I'm not aware of any newtypes in the standard libraries...
21:39:42 <glguy> tswett_to_go: There are a lot in Data.Monoid you can try
21:39:44 <erisco> the question is if the bang transfers to the unwrapped value
21:39:44 <MarcelineVQ> tswett_to_go: most things in Data.Monoid and Data.Semigroup
21:39:53 <erisco> but I don't think so, I think it is just redundant
21:40:25 <glguy> I think I missed the original question. Would you want to restate it?
21:40:30 <tswett_to_go> erisco: I've *tried* it; the bang changes the behavior of the program.
21:40:41 <erisco> that's alarming
21:40:43 <erisco> how could that be?
21:41:03 <tswett_to_go> glguy: we're talking about http://lpaste.net/353801, line 16.
21:41:10 <erisco> strictness should not be doing that, unless unsafe IO is involved
21:41:16 <erisco> or you are talking about time and memory
21:41:16 <tswett_to_go> "showsPrec p !(Identifier str) = ..."
21:41:24 <tswett_to_go> Identifier is a newtype around String.
21:41:32 <erisco> or you are talking about one case being bottom and the other not
21:42:14 <erisco> what is this change in behaviour?
21:42:19 <glguy> tswett_to_go: Where is the Identifier value constructor defined?
21:42:41 <glguy> Oh, I see the pattern synonym now
21:42:46 <tswett_to_go> Without the bang, showing an "undefined" Identifier value prints this out:
21:42:46 <glguy> not sure how I missed it
21:42:47 <tswett_to_go> toIdentifier "*** Exception: An identifier cannot be empty.
21:42:58 <tswett_to_go> With the bang, it's just:
21:42:59 <tswett_to_go> *** Exception: An identifier cannot be empty.
21:44:05 <glguy> What's the surprise?
21:44:14 <erisco> okay, that's fine, it is unsafe IO involved
21:44:34 <tswett_to_go> You consider the "error" function to be unsafe IO?
21:44:39 <erisco> yes
21:44:45 <erisco> that is how it is defined
21:45:30 <erisco> and when you change evaluation order with strictness you can see differences when unsafe IO is involved
21:45:43 <erisco> but also there is a view pattern involved and I am not familiar with how those work
21:45:50 <erisco> it isn't just about the newtype like I thought it was
21:45:54 <glguy> The view pattern doesn't matter
21:45:56 <MarcelineVQ> they're really quite interesting
21:46:21 <erisco> it has to matter wrt what the bang does
21:46:31 <erisco> I am guessing "Identifier" is a pattern, and the bang is applied to this
21:46:34 <glguy> The view pattern doesn't matter regarding the bang
21:46:55 <glguy> You get the same behavior inlining the newtype constructor rather than using the view pattern
21:47:41 <glguy> Given newtype N = MkN Int, forcing a value with type N forces the Int
21:47:48 <glguy> so: example !(N x) = ...
21:47:55 <glguy> is going to force the x
21:47:59 <glguy> err
21:48:05 <glguy> so: example !(MkN x) = ...
21:48:20 <glguy> The newtype constructors don't count as far as strictness and evaluation go
21:49:11 <erisco> okay, so if F is a newtype
21:49:18 <erisco> then !(F x) is strict on x
21:49:21 <glguy> yeah
21:49:31 <glguy> It might as well be !x
21:49:34 <erisco> okay, I didn't know if that was the case
21:49:36 <glguy> the F just changes the type
21:49:50 <erisco> the other option is it is just redundant i.e. ignored
21:50:18 <erisco> not sure how I feel about that
21:53:35 <MarcelineVQ> that's pretty interesting, I saw a bit of that here https://wiki.haskell.org/Newtype (4 Examples section) but didn't know how to piece together how ! would interact with that behavior
21:54:00 <mmachenry> I'm having a design problem and I'm wondering if anyone has any suggestions.
21:54:12 <MarcelineVQ> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#bang-patterns-and-strict-haskell has a lot of examples with let but I also wasn't sure how that translates to patterns ni a function defintion
21:54:13 <mmachenry> I'm writing a dynamic state space search.
21:54:58 <mmachenry> I have a game state in the state monad and nested within RandT and other transformers making up my primary type that I'm searching.
21:55:45 <mmachenry> At some point, I need to access bits of the game state. I sometimes do this by focusing on a particular piece in the game. I need to change that piece. 
21:56:24 <mmachenry> To do so, functionally, I'm finding the piece in the game state, and then making the manipulation I need, then removing the old version and inserting the new version.
21:57:12 <mmachenry> However, now, in order to maintain information about how the piece is changing while I also maintain information about how the game is changing, I kind of want to wrap my game monad in a (StateT Piece)
21:57:33 <mmachenry> But that is going to make it so that get,put, and modify refer to just the piece. 
21:57:42 <mmachenry> I'm sorry if this is hard to explain.
22:08:48 <erisco> is the issue that you have multiple StateT in your stack?
22:10:26 <Koterpillar> add a lens to the piece to the state
22:10:55 <Koterpillar> State Game -> State (Game, Maybe (Lens' Game Piece))
22:13:46 <mmachenry> erisco: That's an issue with one proposed solution. But really I think that solution might be wrong for many reasons.
22:14:29 <mmachenry> Koterpillar: I was reading about lenses. I was thinking they might be a good solution. 
22:14:30 <erisco> well it isn't a technical issue because it just depends on how you lift get/put/modify
22:15:02 <mmachenry> erisco: Yeah I suppose it's not hard to get around it, huh?
22:15:05 <erisco> but from a practical standpoint it isn't friendly to have a deep stack
22:16:10 <mmachenry> Basically I want to keep my GameEffect monad which is basically ListT (RandT (State GameState))
22:16:22 <Koterpillar> maybe you even want to pass the piece lens explicitly to functions that need it
22:16:28 <erisco> I like monads like I like the plague
22:16:48 <mmachenry> I then want to do something to a piece that's in that GameState. Imagine game state is a matrix of integers. Let's say I get one of them.
22:17:02 <Koterpillar> do you want access to the old state though?
22:17:38 <mmachenry> I want to hold on to that piece… add one to it, that should update the board but also update the piece I'm holding in a variable elsewhere so that when I delete it from the board, it's equal to the piece that's acually there.
22:17:39 <Koterpillar> because if not, use zoom to get from State GameState to State Piece
22:17:53 <mmachenry> Zoom?
22:18:21 <erisco> the way you worded that sounds impossible
22:18:29 <Koterpillar> zoom :: (a -> (b, b -> a)) -> State a r -> State b r
22:18:30 <erisco> because you've described mutability
22:18:57 <mmachenry> erisco: I've gotten it written with really inelegant functions and types.
22:19:15 <mmachenry> But a monad transformer really cleaned up the game state effects.
22:19:24 <mmachenry> I want to do the same thing for the pieces.
22:19:59 <Koterpillar> do you want to modify both the complete state and the piece in one function?
22:20:19 <mmachenry> Koterpillar: Yeah, more or less.
22:20:43 * erisco recalls talking about an indexed state monad a few days ago
22:20:43 <Koterpillar> let's say data GameState = Game { pieces :: [Piece] }
22:20:43 <mmachenry> I want Piece -> GameEffect
22:21:03 <mmachenry> Kotepillar: Sure
22:21:08 <Koterpillar> and the first thing your function does is put $ Game []
22:21:16 <Koterpillar> and then you're trying to modify the piece
22:21:18 <Koterpillar> what happens?
22:22:03 <erisco> can you just work with the state (GameState, Piece)?
22:22:16 <mmachenry> Let's say I have Piece -> GameEffect. and data Piece = Piece Bool Int
22:22:23 <mmachenry> Doesn't matter what the Bool and Int are.
22:22:28 <Koterpillar> that doesn't modify anything...
22:22:43 <erisco> you can zoom to this state
22:22:49 <erisco> extract the piece, put the piece back in
22:23:35 <erisco> maybe not the most elegant because there is a different piece in the GameState than what you've pulled out
22:23:41 <erisco> but then you can use a lens like Koterpillar says
22:23:55 <mmachenry> Now I want to write a function that's basically myFunc :: Piece -> GameEffect; myFunc piece = do {negateThePiece; moveThePieceBackSpace }
22:24:08 <erisco> or you can just program responsibly
22:24:21 <mmachenry> I want negateThePiece and moveThePieceBackSpace to be separate functions that I can compose.
22:24:26 <Koterpillar> mmachenry: so you have a notion of "current piece", right?
22:24:37 <mmachenry> Koterpillar: Yes in a way.
22:24:45 <mmachenry> It's not really current to the game state
22:24:55 <Koterpillar> State (Game, Maybe (Lens' Game State))
22:24:59 <mmachenry> It's just the piece I'm trying to move at this point in the search for a solution.
22:25:01 <Koterpillar> State (Game, Maybe (Lens' Game Piece))
22:25:02 <Koterpillar> sorry
22:25:21 <Koterpillar> or
22:25:25 <mmachenry> Koterpillar: Not sure that's going to help me all that much.
22:25:26 <Koterpillar> type PieceRef = Lens' Game Piece
22:25:40 <Koterpillar> negateThePiece :: PieceRef -> GameM ()
22:25:44 <erisco> you want the Piece in the state, don't you?
22:25:50 <Koterpillar> moveThePieceBack :: PieceRef -> GameM ()
22:25:57 <Koterpillar> i.e. pass the lens around explicitly
22:25:57 <mmachenry> Because I want, if possible, GameEffect to remain unchanged. Pieces are just one thing that could be the current focus of what I'm trying to manipulate the game state with
22:25:58 <erisco> I thought that was the essence of your inquiry
22:26:11 <mmachenry> And GameEffects are very solid and reusable. 
22:26:33 <mmachenry> erisco: Yeah… let me fininsh my example.
22:26:40 <erisco> you can focus on more than just Piece
22:26:48 <erisco> just substitute the type Piece with whatever you want
22:27:13 <erisco> and I don't know what GameEffect is but that doesn't have to change, I don't think anyways
22:27:21 <erisco> you use zoom like Koterpillar said
22:27:36 <erisco> so you reach a point where you want to focus on a part of the game state
22:27:41 <erisco> you use zoom to augment the state with this focus
22:27:47 <glguy> You can't have a Maybe (Lens' s a), specifically that Maybe can't be applied to a Lens' _ _
22:27:55 <erisco> now you have some functions which work on this focused state
22:28:12 <Koterpillar> glguy: why not?
22:28:17 <mmachenry> So I have negatePiece :: Piece -> GameEffect; negatePiece (Piece b i) = let newPiece = Piece False i in do { s <- get; put (insert newPiece (delete piece s)) }
22:28:23 <glguy> Because Lens' is a polymorphic type
22:28:32 <mmachenry> That game effect takes a piece and negatates it.
22:28:35 <erisco> then you move back to the unfocused state
22:28:47 <mmachenry> moveAPieceBack would do a similar manipulation.
22:28:53 <Koterpillar> mmachenry: are your pieces identifiable?
22:29:15 <Koterpillar> mmachenry: i.e. what would insert p $ insert p $ insert p s do?
22:29:18 <mmachenry> Koterpillar: I actually tried that. It was a nightmare. :(
22:29:22 <mmachenry> It's a good idea.
22:29:27 <mmachenry> But it was hard.
22:29:54 <suppi> glguy: you need ALens' or something like that, right?
22:29:58 <mmachenry> Koterpillar: multiple inserts would make a weird game state that shouldn't happen and duplicate the piece
22:30:12 <glguy> suppi: Yes, that or ReifiedLens
22:30:59 <erisco> :t insert
22:31:01 <lambdabot> Ord a => a -> [a] -> [a]
22:31:13 <Koterpillar> is this your insert?
22:31:34 <mmachenry> Ah no, sorry, I was being a little fast and loose there.
22:31:37 <suppi> i remember having problems with that and it kinda made me put aside the project i was working on 
22:31:41 <mmachenry> Let's imagine it's just (:)
22:32:07 <mmachenry> I remove the piece from the board, the not negated version, and cons on a negated version of the piece.
22:32:28 <mmachenry> Effectively just doing and in-place update to the state of the piece. But functionally. 
22:33:10 <mmachenry> Thing is I have to now now that the piece is negated so that when I go looking for it in the movePieceBackASpace function it'll be (==) to the piece I'm actually working with.
22:33:31 <mmachenry> So chaining together these updates that focus on one piece is the critical issue.
22:33:53 <mmachenry> You think zoom helps me solve that problem? Lens maybe? 
22:34:20 <erisco> or you can add a StateT to your stack
22:34:39 <mmachenry> erisco: Yeah I was just about to do that, felt weird about it, and came here. :)
22:35:02 <erisco> zoom lets you change the state, but you said you want to still use GameEffect
22:35:36 <mmachenry> So I have a monad transformer stack… I just call get and it uses the one and only StateT in the transformer stack. How would adding a StateT Piece change that?
22:36:05 <erisco> the lens lets you read and write a part of the game state, but isn't relevant to the monad issues
22:36:48 <mmachenry> Lens might work well if the updates can happen all in the original State GameState type
22:36:50 <erisco> so I am guessing you have StateT GameEffect (Lens' Game Piece) now, or something
22:37:26 <erisco> but I'm not a lens person so I don't know if that type works
22:37:41 <mmachenry> That puts the Piece on the inside of this stack of transformers though. 
22:38:20 <mmachenry> Which is a bit unsatisfying to me. Because it requires I put everything that will be the focus of my game state updates at some point in there along with it. Or a union type that knows about all of them.
22:38:35 <mmachenry> I will be adding focuses of things I'm updating. The game state is complicated.
22:38:59 <mmachenry> So I don't want to have to list them all ahead of time in the game effect monad
22:38:59 <erisco> I don't really understand
22:39:20 <mmachenry> Currently it's something like this:
22:39:38 <mmachenry> ListT (RandT StdGen (State GameState))
22:40:00 <mmachenry> type GameEffect = <that>
22:40:14 <mmachenry> But if I change it to this:
22:40:58 <mmachenry> type GameEffect = ListT (RandT StdGen (State (Lens' GameState Piece)))
22:41:10 <mmachenry> Then I've made Piece part of the GameEffect. 
22:41:24 <erisco> why would you change it like that?
22:41:39 <mmachenry> Because I thought you were suggesting that.
22:41:43 <erisco> no, reread
22:42:05 <mmachenry> "StateT GameEffect (Lens' Game Piece)"
22:42:11 <erisco> :t StateT
22:42:12 <lambdabot> (s -> m (a, s)) -> StateT s m a
22:42:20 <erisco> okay reverse the args
22:42:39 <mmachenry> Oh I think I see what you're saying.
22:42:56 <erisco> you're just going to add on a StateT to the stack
22:43:02 <mmachenry> Well.. if I put a "StateT Piece GameEffect" that kind of does away with the need for lens in a way.
22:43:16 <glguy> mmachenry: No, you can't use Lens' there
22:43:24 <erisco> I can't comment on the lens portion of it
22:43:32 <mmachenry> Yeah, like I said, I was about to do that, but didn't know how to reference the correct "get"
22:43:39 <erisco> I don't know how the lens would manage to read and write from the state
22:43:44 <mmachenry> How would I make sure I get the right get and put?
22:43:59 <erisco> it just depends on how you lift them
22:44:04 <mmachenry> I should really read up on lens even if it's not for this project.
22:44:10 <erisco> :t get
22:44:12 <lambdabot> MonadState s m => m s
22:44:23 <erisco> too many monad classes -.-
22:44:23 <mmachenry> I'm not lifting at all right now.
22:44:34 <erisco> well if you don't lift you'll get the outermost state
22:44:59 <mmachenry> And if I lift I'll get the inner get? Okay, that makes plenty of sense.
22:45:35 <mmachenry> I guess that's probably the most straight forward way to do this.
22:45:54 <erisco> when you change the piece it isn't going to update in the game state, mind you
22:46:05 <erisco> that is what the lens part was trying to achieve but I don't think it succeeds with this setup
22:47:08 <erisco> you'd be looking to write the updated piece back to the game state when you drop the outer StateT again
22:48:13 <erisco> just a side note, I don't find it a good idea to depend on the state as it is being computed
22:48:15 <mmachenry> Yeah that's exactly my plan
22:48:22 <erisco> this leads to weird, obnoxious, ordering issues
22:48:24 <mmachenry> Maybe not very elegant. 
22:48:39 <mmachenry> I think I can handle the ordering alright. 
22:48:41 <erisco> it is much better if you can compute the next state only from the previous state
22:48:50 <erisco> rather than the previous state plus an incomplete delta
22:49:11 <erisco> I see games written like that and they run into awful ordering problems
22:49:46 <mmachenry> I can compute the next state just from the current.
22:51:17 <erisco> it starts with the decision that there is just one mutable state object
22:51:33 <erisco> then you're immediately in the last state + incomplete delta paradigm
22:51:53 <erisco> but you can just as easily do this without mutability
22:56:25 <mmachenry> Sure.
22:56:35 <mmachenry> Thans for your help, bye the way.
22:56:46 <erisco> you're welome
23:06:16 <Sh4rPEYE> Hey. I reached the chapter about monoids and bedore I knew it, I was lost. Am I right when I think that monoid(s) is just a typeclass?
23:07:00 <erisco> Sh4rPEYE, Monoid is a type class, yes
23:07:38 <Sh4rPEYE> And as such it has some functions, which all its instances have to define?
23:08:03 <Sh4rPEYE> So, when Num has instance of monoid, it defines mappend, mempty etc?
23:08:28 <erisco> Num is a type class, so there is no such thing as a Num instance of Monoid
23:08:37 <erisco> instances are defined on types. Num is not a type.
23:08:54 <Sh4rPEYE> So... on Integer?
23:09:01 <erisco> then yes, correct
23:09:19 <geekosaur> except that there isn't one
23:09:24 <Sh4rPEYE> Ok... and what's that 'Sum' and 'Product' about?
23:09:32 <geekosaur> that's why there isn't one :)
23:09:48 <erisco> yes, so there can only be one instance of a type class per type
23:10:08 <geekosaur> rings ("numbers", unless you want to delve into number theory and learn the truth :)  have *two* monoids.
23:10:15 <erisco> there are more than one possible instances for Integer, and so instead of choosing one arbitrarily the library authors chose none
23:10:25 <geekosaur> ((+),0) and ((*),1)
23:10:37 <geekosaur> neither one can be considered primary, so we punt them both to newtypes
23:11:21 <erisco> mind you, this didn't stop people from making other non-unique instances
23:11:39 <Sh4rPEYE> Ok, great. Should've asked before - why do I need to define mappend for numbers? (Or rings, then)
23:12:08 <erisco> they have been defined for you
23:12:11 <Sh4rPEYE> Even if I end up with two... why do I need one in the firdt place? 
23:12:32 <erisco> because there are functions defined only assuming a type is a Monoid
23:12:32 <Sh4rPEYE> * I meant, why are they define
23:12:35 <erisco> :t foldMap
23:12:37 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
23:12:38 <erisco> such as that one
23:12:54 <erisco> so if you want to participate you need to define a Monoid instance for your type
23:13:32 <erisco> > getSum (foldMap Sum [1,2,3])
23:13:34 <lambdabot>  6
23:13:44 <erisco> > getProduct (foldMap Product [1,2,3])
23:13:47 <lambdabot>  6
23:13:54 <Sh4rPEYE> Oh, I see. 
23:14:17 <Sh4rPEYE> It needs to be monoid, becaude ut needs thide associativity and identity things :-D
23:14:25 <Sh4rPEYE> Those*
23:14:38 <erisco> it needs mempty and mappend, which are supposed to abide by those laws, yes
23:14:49 <erisco> in Haskell these laws are not checked
23:15:17 <Sh4rPEYE> Mappend is just some arbitrary general append, then?
23:15:32 <erisco> mappend is associative and has mempty as an identity
23:15:34 <Sh4rPEYE> And mempty just general... Nothing
23:15:45 <erisco> mempty is the identity of mappend
23:15:55 <Axman6> Sh4rPEYE: you cannot have two instances of a Class for a specific type. Numbers have two (or more) possible Monoid instances, one using Addition and one using Multiplication. so we have the Sum and Product newtypes which allow us to choose which one we want
23:16:31 <erisco> they are named "append" and "empty" just 'cause
23:16:55 <Sh4rPEYE> The "identity" means it's something that makes mappend return the secind argument it was passed?
23:17:17 <Axman6> mappend mempty x = x and mappend mempty x = x
23:17:26 <erisco> well it is both a left and right identity
23:17:30 <Axman6> uh, mappend x mempty
23:17:31 <Sh4rPEYE> So, yes
23:17:54 <erisco> but it doesn't have to return the argument given, it just has to give something equivalent
23:18:12 <Sh4rPEYE> Equivalent to what?
23:18:21 <erisco> to the argument
23:18:47 <mniip> oh man
23:18:52 <mniip> the technicalities of equality
23:19:03 <erisco> the way you worded it made it sound like object identities, which is not applicable here
23:19:13 <erisco> but also like mniip says it depends on what equality you are using
23:19:57 <erisco> in Haskell we're usually referring to ==
23:20:36 <mniip> except for ->
23:20:42 <mniip> then it's behavioral equality
23:21:13 <mniip> actually
23:21:20 <Sh4rPEYE> Oh, ok. Thanks
23:21:24 <mniip> are that many laws even realizable with ==
23:21:40 <Axman6> Sh4rPEYE: the reason people are being a bit particular about language here is that image you use lists to represent Sets, then [1,2,3] == [3,2,1]. to obey the monoid laws, we could happily have mappend [1,2,3] [] = [3,2,1]
23:22:06 <Sh4rPEYE> To wrap up: Monoid is simething that has a associative function and and identity for that function
23:22:40 <Sh4rPEYE> Yeah, I understand. My wording wasn't really precise
23:23:40 <Axman6> yep
23:24:01 <mniip> hmm, curious
23:24:22 <mniip> in presence of arbitrary transitive-reflexive relations for ==, functions turn into arbitrary relations
23:24:45 <erisco> mniip, what is behavioural equality?
23:24:55 <Axman6> it's worth understanind there a lots of different monoids (Sum, Product, list, Any and All), but also combinations of monoids are also often monoids (hence the instance for (Monoid a, Monoid b) => Monoid (a,b))
23:25:07 <mniip> erisco, how do you check the fmap laws for ((->) e)
23:25:53 <Sh4rPEYE> Thank you very much for help. 
23:25:55 <boxscape> Are there purely functional arrays (or similar data structures) that have runtime in O(m) to replace m elements, regardless of the length? I looked at diffarray, but that uses unsafePerformIO internally (a lot)
23:26:30 <jle`> boxscape: is the API purely functional?
23:26:34 <boxscape> yes
23:26:41 <erisco> fmap id f = id . f = \x -> id (f x) = \x -> f x = f
23:26:45 <jle`> are you asking for a theoretical answer, or are you looking for something you can use
23:26:46 <erisco> and whatever for the other law
23:26:55 <boxscape> jle`: theoretical answer
23:27:01 <erisco> mniip, so the equality I am using here is behavioural?
23:27:07 <Axman6> boxscape: what's wrong with that? the API is pure
23:27:10 <mniip> basically
23:27:11 <mniip> yes
23:27:17 <boxscape> It's not wrong, I just want to know whether it's possible :)
23:27:27 <mniip> boxscape, a quick thought suggests that no
23:27:42 <boxscape> ok
23:27:43 <mniip> the best you can do on a pointer machine is log(m log m)
23:27:52 <mniip> errrr
23:27:54 <mniip> m log m
23:27:59 <jle`> boxscape: also it depends on what you mean by array
23:28:00 <Axman6> boxscape: there's probably structures similar to HAMT's which could do it in O(m log k) or something
23:28:22 <trineroks> hey guys, is it possible to let list = list?
23:28:23 <trineroks> like
23:28:28 <trineroks> let list = (map f xs)
23:28:36 <boxscape> What's k in that case, Axman6 ? the depth?
23:28:39 <jle`> trineroks: what happens when you try?
23:28:43 <trineroks> would give me a list "list" that has all the members of xs with f applied?
23:29:01 <Axman6> boxscape: yeah, probably bit size of pointers on the machine
23:29:05 <boxscape> ah, ok
23:29:11 <boxscape> alright, thanks guys
23:29:19 <jle`> trineroks: if you defined 'list = map f xs', then list is a list of all the members of x with f applied to them, yes
23:29:29 <Axman6> trineroks: I'm not sure I understand the question, that's exactly what you get
23:29:40 <jle`> boxscape: if you consider type Array a = (Int -> a) to be a "purely functional" array
23:29:46 <jle`> then it has O(m) replacements
23:29:57 <boxscape> ah, yeah, that makes sense
23:30:17 <mniip> yeah but O(2^(ram size)) worst case
23:30:20 <mniip> yeah but O(2^(ram size)) worst case access
23:31:04 <Axman6> well, O(2^|Int|)
23:31:33 <jle`> yes, access is pretty bad :)
23:32:14 <mniip> Axman6, explain?
23:32:23 <jle`> boxscape: type Array a = [(Int, a)], same story
23:32:31 <Axman6> well, |Int| might be less than RAM size
23:32:37 <jle`> replace i x = ((i,x) :)
23:32:58 <mniip> if |Int| is larger, which it usually is, then yours is incorrect
23:33:06 <mniip> mine still is
23:33:17 <Axman6> on 32bit it can be smaller
23:33:30 <mniip> hardly
23:33:39 <boxscape> jle`: but... If you want to replace the last element in that list, wouldn't that still take O(length), because you have to go through the whole list?
23:33:44 <Axman6> ANYWAY,, this irrelevant :)
23:33:50 <jle`> boxscape: lookup would be finding the first match
23:33:56 <boxscape> oh, I see
23:34:31 <jle`> > find ((== 3) . fst) [(5,'a'), (3,'a'), (1, 'b'), (3,'c')]
23:34:34 <lambdabot>  Just (3,'a')
23:34:42 <boxscape> right, ok
23:34:52 <jle`> > find ((== 3) . fst) $ (3,'c') : [(5,'a'), (3,'a'), (1, 'b'), (3,'c')]
23:34:54 <lambdabot>  Just (3,'c')
23:35:03 <mniip> consider this
23:35:12 <mniip> with ADTs, all allocations are of bounded size
23:35:32 <mniip> a datum can reference a bounded amount of other data
23:35:32 <jle`> anyway this kind of blurs the line for what you'd call an array, of course
23:35:46 <mniip> so to store N elements you need log N constructors
23:35:49 <jle`> but it seemed like you were considering some sort of tree structure as an array, which is already breaking from the traditional definition
23:35:51 <mniip> at least
23:36:02 <boxscape> right, I mostly meant fast access by that, I suppose
23:36:30 <mniip> fast access would be using an impure library
23:36:40 <jle`> traditionally, an array data structure refers to data stored in contiguous chunks in memory
23:36:59 <mniip> jle`, what's "memory"
23:37:25 <jle`> from the context of the interpretation it's pretty clear
23:37:33 <jle`> s/pretty/usually
23:37:39 <mniip> from the context of haskell it's nonsensical
23:37:43 <jle`> but this is distinct from the idea of an array of an abstract data type
23:37:59 <jle`> yes, my point was that the idea of a traditional array in haskell is already kind of weird
23:38:11 <mniip> oxymoronic
23:38:30 <jle`> so if you ask for an array, you probably have to clarify what you mean
23:38:49 <jle`> just something that implements the abstract operations of replace + access ?
23:40:08 <jle`> if so then yeah, you open yourself up to a lot of things that have O(1) replacement :)
23:41:56 <nshepperd_> mniip: might as well call the haskell ffi oxymoronic with that attitude
23:42:13 <mniip> we're talking theoretical haskell
23:42:23 <mniip> LC with ADT
23:43:02 <erisco> I'm waiting for the super-exponential algorithm
23:43:47 <mniip> store the hash of the array
23:44:13 <jle`> beautiful
23:47:20 <mniip> no wait
23:47:36 <jle`> that one should have constant-time lookup on the length of the array
23:47:54 <mniip> jle`, not for a variable length hash
23:48:08 <jle`> constant time replacements
23:48:13 <mniip> I have a better algorithm in mind though
23:48:31 <mniip> jle`, again no?
23:48:41 <trineroks> hey guys, is there a haskell function that returns the maximum value of a list as well as its inex?
23:48:42 <trineroks> index
23:48:59 <jle`> mniip: oh wait, nvm, yeah
23:49:05 <jle`> trineroks: you can use maximumBy
23:49:14 <geekosaur> ?
23:49:17 <mniip> you could encode your array as a solution to a system of rational equations
23:49:21 <mniip> and then
23:49:28 <mniip> using Tarski-Seidenberg...
23:49:36 <jle`> > maximumBy (comparing snd) (zip [0..] "hello world")
23:49:39 <lambdabot>  (6,'w')
23:50:06 <geekosaur> hm, right. I should be trying to sleep...
23:50:09 <trineroks> comparing snd?
23:50:19 <geekosaur> :t comparing
23:50:21 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
23:50:33 <jle`> trineroks: it compares the second items in the tuples
23:50:41 <jle`> > comparing snd (1, 100) (3, 10)
23:50:43 <geekosaur> applies the function you specify to the parameter, then does the comparison
23:50:44 <lambdabot>  GT
23:50:49 <jle`> > comparing snd (1, 100) (3, 10000)
23:50:51 <lambdabot>  LT
23:51:06 <jle`> oh, and comparing returns LT/EQ/GT based on which one is bigger
23:51:11 <geekosaur> so, you're handing it tuples of values and their indices, then telling maximumBy to only look at the value part
23:51:41 <jle`> maximumBy takes a comparison function, an (a -> a -> Ordering)
23:51:50 <jle`> so you can tell it how to compare different items
23:52:10 <jle`> 'comparing snd' is a comparing function that compares tuples by their second item
23:52:35 <jle`> although, i suppose...
23:52:42 <jle`> > maximum (zip "hello world" [0..])
23:52:44 <lambdabot>  ('w',6)
23:52:51 <jle`> that works fine too
23:53:09 <jle`> but that's a little more magical to me
23:53:38 <jle`> hm, oh, also it gives the last index that the item occurred in, instead of the first
23:53:51 <jle`> > maximum (zip "hello world wow" [0..])
23:53:53 <lambdabot>  ('w',14)
23:53:59 <trineroks> what is "zip" btw?
23:54:12 <jle`> > zip [0..] "hello world"
23:54:14 <lambdabot>  [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(5,' '),(6,'w'),(7,'o'),(8,'r'),(9,...
23:54:20 <trineroks> ah
23:54:23 <jle`> it zips up two lists, pairing them element-by-element
23:54:30 <jle`> feel free to try it out on ghci too :)
23:54:36 <jle`> > zip "abc" [1,2,3]
23:54:39 <lambdabot>  [('a',1),('b',2),('c',3)]
23:55:00 <jle`> so zip [0..] "hello world" pairs up each letter in "hello world" with its index
23:55:15 <jle`> and `maximumBy snd` picks out the maximum in that list of tuples, based on the second item in the tuple (the letter)
23:55:19 <eatman> Hi! I was wondering what Vim plugins do you guys use for Haskell dev?
23:55:54 <jle`> mine have been sort of cobbled together over the years
23:56:01 <jle`> but this seems to be a good rundown on the state of the art http://www.stephendiehl.com/posts/vim_2016.html
23:56:09 <boxscape> > maximum (zip "hello world wow" [0,-1..]) -- I suppose works if you want the first 'w' in that case
23:56:11 <lambdabot>  ('w',-6)
23:57:17 <trineroks> what if I want to find the maximum of only one list?
23:57:22 <trineroks> so for example, I have two lists
23:57:46 <trineroks> [5, 6, 3] and then [25, 36, 9] (the original list mapped with a square function)
23:57:56 <trineroks> I want this to return (36, 6)
23:58:05 <eatman> Thx jle` 
23:58:08 <trineroks> it seems maximum over a zip doesn't exactly do this behavior?
23:58:23 <boxscape> in that case, maximumBy (comparing snd) is what you want
23:58:33 <cocreature> trineroks: isn’t that just (maximum [25,36,9], maximum [5,6,3])
23:58:38 <Axman6> > maximumBy (comparing fst) (zip [25,36,9] [5,6,3])
23:58:40 <lambdabot>  (36,6)
23:58:50 <trineroks> cocreature not exactly, since -6 squared would be 36
23:58:50 <Axman6> :t fst
23:58:52 <lambdabot> (a, b) -> a
23:58:52 <Axman6> :t comparing
23:58:53 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
23:58:58 <cocreature> oh I should read the backlog
23:59:01 <jle`> trineroks: suqaring is monotonic
23:59:08 <jle`> so you can just find the maximum of [5,6,3] and thens quare it
23:59:15 <jle`> well, for positive numbers
23:59:15 <trineroks> but what if there's a list like
23:59:21 <trineroks> [5, -6, 6, 3]?
23:59:25 <trineroks> because in this case I want it to return
23:59:28 <trineroks> (36, -6)
23:59:40 <Axman6> do you want the maximum swuared number of unsquared number?
23:59:44 <boxscape>  > maximumBy (comparing fst) (zip [25,36,36,9] [5,-6,6,3])
23:59:45 <cocreature> maximumBy abs
23:59:47 <Axman6> squared*
