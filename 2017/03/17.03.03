00:28:48 <ongy> symlinks it is for now :) also why have I never seen cabal exec before? I think that fixes a problem I had
00:29:52 <ezyang> :) 
00:43:14 <ongy> what's the best way to make a dev-only feature with cabal? I have something I would like for debugging but really makes no sense/would confuse people in practice. Make a flag and use CPP in the file?
00:43:40 <ezyang> manual flag 
00:44:01 <ongy> ok
00:45:19 <ongy> and that flag should define a define that I can check with CPP in source then?
00:45:39 <ezyang> yeah, that's one way to do it 
00:45:47 <ezyang> you could also use it to just define extra modules, whatever 
00:46:56 <ongy> that's not enough to enable/disable a feature, is it? I either include the module and get a compile erorr, or don't and it's not in
00:47:52 <ezyang> well, it depends on who is using he dev features 
00:47:57 <ezyang> but yes, CPP is normal 
00:49:25 <ezyang> Conditional jump or move depends on uninitialised value(s) ==12128==	at 0x421284: runInteractiveProcess  
00:49:28 <ezyang> HMMMM 
00:55:13 <alanz> ongy: you can have conditional hs-source-dirs, where you have a debug and non-debug version of the debug routines
00:56:09 <alanz> similar to https://github.com/alanz/ghc-exactprint/blob/ghc-8.2/ghc-exactprint.cabal#L92
00:59:43 <ongy> oh that's a nice way to do it. Not applicable for what I want to use, but I like it
00:59:55 <alanz> CPP is evil
01:05:06 <ongy> maybe what I want to do is stupid... But I want to disable a single packet (A constructor in a sum type) of my ipc that allows to bypass some checks. It's really useful for testing but a dumb idea otherwise
01:05:23 <jchia> Question about Data.Binary.Builder. How do I check whether a Builder is empty? I can't use (== mempty) because Builder has no Eq instance although it has a Monoid instance. Is there a better way than using (null . toLazyByteString)?
01:06:27 <ezyang> ongy: Sounds like you want Backpack :) 
01:07:36 <phadej> jchia: IIRC there isn't better way, and if I think right, that shouldn't be too bad
01:08:31 <ongy> ezyang: I do? isn't that similar to the aproach alanz linked? (from user perspective, I bet the way it works is quite different)
01:09:01 <ezyang> ongy: Yeah, except with Backpack you get to typecheck without committing to an implementation :) :) :) 
01:09:16 <ezyang> (Note: Not actually a good idea, unless you like GHC 8.2...) 
01:10:48 <alanz> ongy: cant you declare the small version in one file and the one with the debug constructor in another, and pull them in via source dirs?
01:10:57 <alanz> so same file name
01:10:58 <ongy> my current idea is to use the MonadFail instance from cereal with an error that says "this is a dev feature" which disables one line and enables one other line. Without keeping 2 versions of the parser for everything else
01:12:05 <ongy> removing one of the Constructors in a sum type would break every case match that handles it, so I don't think that's a good idea
01:13:18 <ongy> it's not a library, so the parser *should* be the only way to get something of that type
01:15:10 <ongy> ezyang: why 8.2? Is that required for backpack?
01:15:16 <ezyang> yeah 
01:16:19 <ongy> what's the eta on that release? I will probably want to use that for another part in the same project
01:16:31 <ongy> and for once I don't care much about compat to old ghc
01:16:33 <ezyang> well, we haven't cut the branch yet. So.... 
01:17:53 <yfwyfw> I was wondering if someone could explain me how "> (fmap . fmap) sum Just [1, 2, 3]" produce the same result as "> fmap sum $ Just [1,2,3]"
01:18:43 <ongy> > (fmap . fmap) sum Just [1, 2, 3]
01:18:47 <lambdabot>  Just 6
01:18:55 <yfwyfw> lifting sum twice should be like "Just [sum 1, sum 2, sum 3]"
01:19:19 <ezyang> it's a little confusing though cuz it's not (Just [1, 2, 3]) 
01:19:27 <jchia> phadej: OK
01:19:36 <ezyang> > map @Int (+2) [1,2] 
01:19:40 <lambdabot>  error:
01:19:40 <lambdabot>      Pattern syntax in expression context: map@Int
01:19:40 <lambdabot>      Did you mean to enable TypeApplications?
01:19:45 <ezyang> drat! No type applications 
01:21:11 <yfwyfw> lifting sum twice should be like "Just [sum 1, sum 2, sum 3]" instead of "Just (sum [1, 2, 3])"
01:21:53 <ezyang> that's not what it's doing 
01:22:06 <ezyang> @pl (fmap . fmap) sum Just [1, 2, 3] 
01:22:07 <lambdabot> fmap sum (Just [1, 2, 3])
01:22:30 <ongy> :t (fmap . fmap) sum
01:22:34 <lambdabot> (Foldable t, Num b, Functor f1, Functor f) => f (f1 (t b)) -> f (f1 b)
01:22:49 <ongy> ok that looks worse than I expected
01:23:04 <ezyang> so f is gonna be function 
01:23:09 <ezyang> cuz the next argument is Just 
01:23:32 <ezyang> > 2 :: _ 
01:23:34 <ongy> maybe we should mention that there's Monad/Applicative/Functor instances for ((->) a)
01:23:35 <lambdabot>  error:
01:23:36 <lambdabot>      • No instance for (Num t1)
01:23:36 <lambdabot>        Possible fix:
01:24:09 <yfwyfw> ah.
01:24:15 <yfwyfw> right
01:24:24 <yfwyfw> Now I know what you mean
01:24:43 <ongy> :t fmap fmap fmap -- This is the example that comes up from time to time and confuses people (sometimes including me)
01:24:45 <yfwyfw> Thank you very much :)
01:24:45 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
01:25:21 <yfwyfw> happy again
01:34:38 <cocreature> "fmap fmap fmap max max" is the maximum function on three numbers :)
01:39:13 <yfwyfw> that's now a proper type tetris.. I must play a lot
01:39:35 <cocreature> yfwyfw: be careful, it’s addictive
01:39:47 <yfwyfw> :)
02:13:06 <jle`> wrote my first literate haskell file today, wasn't all that bad
02:13:19 <bollu> jle`: I quite like TH
02:13:22 <jle`> maybe i'll do it more often
02:13:28 <jle`> i don't know why i avoided it for so long
02:13:55 <jle`> the file was mostly an executable demo...i was just writing block comments until i just gave up and flipped everything
02:26:23 <JuanDaugherty> which thing is this?
02:27:16 <JuanDaugherty> not CWeb i take it
02:28:08 <JuanDaugherty> template haskell has a literate programming aspect?
02:28:25 <Rodenbach> Are there many Lens libs for Haskell? Is there one which is kind of _the_ Lens lib? The one that nearly everyone is using?
02:28:50 <cocreature> Rodenbach: the lens lib is definitly https://hackage.haskell.org/package/lens
02:29:14 <cocreature> there are several other libs (e.g. microlens) but the main ideas are basically the same
02:30:17 <cocreature> at least to some degree they can also interoperate
02:41:52 <riddle_> exit
02:41:54 <riddle_> sorry
02:41:58 <riddle_> mistyped
02:44:24 <bennofs> Rodenbach: there's a few libraries other than 'lens', but those ('microlens', 'lens-family') are stripped-down versions of the 'lens' library with less dependencies and sometimes less general types. The types of both are compatible though, so you can use a lens defined using one of the libraries also with another
02:47:05 <liste> fclabels and data-lens are not compatible with 'lens' AFAIK
02:48:02 <bennofs> liste: yeah but those are not so popular neither, are they?
02:48:17 <liste> not anymore at leawt
02:48:20 <liste> least*
02:50:38 <liste> 40 hackage packages depend on fclabels, 34 on data-lens, 14 on lens-family and 704 on lens
02:51:20 <Rodenbach> bennofs: ah okay, so in some cases the alternative libs offer what is needed for my specific case, and their selling point is that they introduce fewer deps. Oki, makes sense, thx.
02:52:40 <John[Lisbeth]> I hate to interject but this is album is named after a haskell joke: https://www.youtube.com/watch?v=Iozs9yOztQA
02:52:58 <John[Lisbeth]> or maybe even not
02:53:55 <Taneb> John[Lisbeth], if it is I do not recognize it
02:54:42 <John[Lisbeth]> if https://www.youtube.com/watch?v=RqvCNb7fKsg
03:11:00 <nbro> Hi!
03:11:11 <ski> hello again nbro
03:11:41 <nbro> playing again with Haskell…
03:12:13 <mekeor> already? it's not even weekend yet... ;P
03:12:29 <zuck007> ?src
03:12:29 <lambdabot> src <id>. Display the implementation of a standard function
03:12:40 <zuck007> ?src (map)
03:12:41 <lambdabot> Source not found. Maybe you made a typo?
03:12:48 <mekeor> ?src map
03:12:49 <lambdabot> map _ []     = []
03:12:49 <lambdabot> map f (x:xs) = f x : map f xs
03:13:09 <zuck007> ?filter
03:13:10 <lambdabot> Unknown command, try @list
03:13:15 <zuck007> ?src filter
03:13:16 <lambdabot> filter _ []     = []
03:13:16 <lambdabot> filter p (x:xs)
03:13:16 <lambdabot>     | p x       = x : filter p xs
03:13:16 <lambdabot>     | otherwise = filter p xs
03:13:31 <zuck007> ?src $
03:13:32 <lambdabot> f $ x = f x
03:14:06 <nbro> I’ve an exercise where it’s required to bind specifically an Integer to a variable and then produce a square root of that Integer… I’m not 100% sure if functions can also be considered expressions, I guess, yes
03:14:47 <nbro> sorry, I didn’t express myself in the best wa
03:14:49 <nbro> *way
03:15:11 <nbro> it’s required to bind the Integer to a variable in an expression
03:15:22 <AndreasK> nbro: Probably wants you to define a lambda expression
03:15:56 <ski> or possibly even a named function
03:16:45 <AndreasK> Yeah it's not that well worded
03:17:02 <nbro> I thought to create a function by declaring explicitly also its type, e.g. f :: Integer -> Double; f x = sqrt(fromInteger(x))
03:17:28 <nbro> but, at this point, I would have a question: what isn’t an expression in Haskell?
03:17:51 <ski> `f x = sqrt(fromInteger(x))' isn't an expression (it's a defining equation)
03:18:03 <ski> `f :: Integer -> Double' isn't an expression (it's a type signature)
03:18:41 <ski> neither `f x', nor `f' nor `x' in `f x = sqrt(fromInteger(x))' are expressions either (they are patterns)
03:18:53 <nbro> here https://www.haskell.org/onlinereport/exps.html it’s written that type signature are expressions
03:19:38 <ski> (i.e. talking about the `x' on the left of `=', in the definiendum, the "thing to be defined"; as opposed to the right of `=', the "definiens", what it's being defined as)
03:19:49 <ski> that's type ascriptions
03:20:29 <ski> (unfortunately the report doesn't use separate terminology here)
03:20:47 <nbro> ok
03:22:16 <nbro> but, at this point, if a function definition isn’t an expression, then what could they actually mean by “An expression that binds a variable x to an Integer, then evaluates to the square of x.”?
03:22:18 <ski> .. anyway, one way of interpreting your exercise (given what you've said here) might be that you're to find the square root, without using the library `sqrt' operation (or say any other operation involving floating-point numbers)
03:23:06 <ski> nbro : interpreting that literally, what AndreasK said
03:23:46 <ski> .. have you seen function expressions/abstractions (aka "lambda expressions/abstractions") yet ?
03:25:57 <nbro> well, not in class, but I’ve already had a look at the syntax of lambda expressions, like (\x -> sqrt(x))?
03:26:24 <ski> ok, *nod*
03:27:10 <ski> nbro : another interpretation of "An expression that binds a variable x to an Integer, then evaluates to the square of x." would be a `let'-`in' expression ..
03:27:40 * ski realizes that sentence didn't say anything about "root"
03:28:18 <nbro> @ski the previous exercise was (I know this are stupid exercises): “An expression that binds a variable x to a number (using let), then evaluates to the square of x.“. So here they were specifically requiring us to use the let .. in .. with any number..
03:28:18 <lambdabot> Maybe you meant: wiki src ask
03:28:20 <tabaqui1> Just 1 <|> Just 2
03:28:23 <tabaqui1> >Just 1 <|> Just 2
03:28:25 <tabaqui1> > Just 1 <|> Just 2
03:28:28 <lambdabot>  Just 1
03:28:38 <tabaqui1> :t some $ Just 1
03:28:40 <lambdabot> Num a => Maybe [a]
03:28:46 <tabaqui1> head $ some $ Just 1
03:28:49 <tabaqui1> > head $ some $ Just 1
03:28:52 <lambdabot>  error:
03:28:52 <lambdabot>      • Couldn't match type ‘Maybe’ with ‘[]’
03:28:53 <lambdabot>        Expected type: [[a]]
03:28:59 <tabaqui1> > head <$> some $ Just 1
03:29:03 <lambdabot>  error:
03:29:03 <lambdabot>      • Couldn't match type ‘[a]’ with ‘Maybe Integer’
03:29:03 <lambdabot>        Expected type: Maybe Integer -> [a]
03:29:30 <ski> tabaqui1 : perhaps you could speak to lambdabot in private, at least until you're satisfied with a lambdabot query you'd like to show the channel ?
03:29:57 <tabaqui1> ski: I want to demonstrate it first
03:30:17 <ski> you want to demonstate typos and error messages ?
03:30:24 <tabaqui1> here
03:30:29 <tabaqui1> > head <$> some (Just 1)
03:30:36 <lambdabot>  mueval-core: Time limit exceeded
03:30:44 <tabaqui1> some (Just 1) returns Maybe [Int]
03:31:01 <tabaqui1> but it cannot be used even in lazy way
03:31:06 <ski> correct
03:31:15 <tabaqui1> what's the purpose of Alternative class?
03:31:32 <ski> it's often used with parsers
03:31:55 <tabaqui1> empty and <|> seem fine
03:32:01 <ski> > some Nothing
03:32:04 <lambdabot>  Nothing
03:32:14 <tabaqui1> but some and many cannot be evaluated at all
03:32:32 <tabaqui1> > some [] :: [[Int]]
03:32:35 <ski> `some' will retry until the action fails. `Just 1' never fails, so it's retry infinitely many times
03:32:36 <lambdabot>  []
03:33:09 <novakboskov> Is it possible to provide "bare" switches from https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#compiler-options-for-profiling to stack build command? It looks to me like stack build --executable-profiling --library-profiling somehow provides -fprof-cafs to ghc and I don't want it.
03:33:43 <ski> however, the type indicates that it *might* fail, so it can't return a `Just (...)' answer before it has found the first failing execution of the action -- which will never happen in this case
03:34:03 <tabaqui1> but it is still useless with pure types
03:34:18 <ski> i don't know what "pure types" mean
03:34:24 <tabaqui1> yeah, "some . print" do something
03:34:33 <ski> `IO' is just as pure as `Maybe'
03:34:50 <tabaqui1> ghc evaluate (return 1) each time
03:35:02 <tabaqui1> even if it gain us the same result
03:35:04 <ski> as is `StateT Foo Maybe'
03:35:46 <tabaqui1> there is no reason to check "some $ Just 1"
03:35:58 <ski> nbro : with any number, or with a specific number (possibly of your choosing) ?
03:36:02 <tabaqui1> if it doesn't fail once, it doesn't fail anytime
03:36:10 <ski> `some' can't know that
03:37:20 <ski> `some' is just a general function written in terms of `(<|>)'
03:37:21 <tabaqui1> still can't imagine code with "some $ Just smth
03:37:39 <ski> it doesn't seem very useful, no
03:38:13 <nbro> @ski : I’m not sure. Since function definitions are not expressions, then I interpreted ““An expression that binds a variable x to a number (using let), then evaluates to the square of x.” as something like “myexp = let x = 3 in sqrt(x)”, so I’m in reality binding x to a specific number (but not strictly an Integer)...
03:38:14 <lambdabot> Maybe you meant: wiki src ask
03:38:22 <ski> however, `(<|>)' is still useful on `Maybe'
03:38:48 <tabaqui1> yeah, these function can be applicable
03:38:57 <tabaqui1> except of some/many
03:39:54 <ski> nbro : fyi, it's not IRC custom to prefix the nickname of a person with `@', when addressing them. (also lambdabot gets confused, as you see). it's traditional to begin the message with the nickname in question, directly, followed e.g. by a colon or a comma, then the message
03:40:43 <ski> nbro : many IRC clients (by default) highlight/alert the user when someone addresses them in that way. not as many do that when the nickname is not eh very first thing in the message, though
03:41:30 <ski> nbro : again, since it says "square of x", not "square root of x", i doubt very much that you're to use `sqrt' at all
03:41:31 <tabaqui1> "/query nick" opens the new channel
03:41:33 <tabaqui1> btw
03:41:45 <nbro> ski: yes, sorry for that, I realized I was mentioning differently other people with respect to the other times… I may have got confused since in few certain other forums they usually use @
03:41:56 <tabaqui1> but channels don't handy in many clients
03:42:03 * ski nods
03:42:11 <ski> (IRC predates those forums)
03:42:18 * tabaqui1 foo
03:43:28 <nbro> ski: yes, you’re right, I should not be using sqrt but x*x
03:43:37 <ski> > 5^2
03:43:40 <lambdabot>  25
03:43:50 <ski> > x^2
03:43:53 <lambdabot>  x * x
03:43:54 <nbro> what
03:43:55 <nbro> lol
03:44:03 <nbro> ahah
03:44:08 <nbro> what’s happening to me
03:44:09 <nbro> ?
03:44:10 <nbro> ahah
03:44:17 <brynser_> > x ** 3
03:44:20 <lambdabot>  x**3
03:44:47 * ski believes it's called "laughter"
03:45:06 <ski> (perhaps aka "having fun", depending on circumstances)
03:46:15 <jle`> > x ^ 3
03:46:18 <lambdabot>  x * x * x
03:46:41 <jle`> > x ^ 5
03:46:45 <lambdabot>  x * x * (x * x) * x
03:46:52 <brynser_> huh
03:47:21 <ski> it's probably using the repeated squaring method for computing powers
03:47:30 <jle`> @src (^)
03:47:31 <lambdabot> x ^ 0            = 1
03:47:31 <lambdabot> x ^ n | n > 0    = f x (n-1) x
03:47:31 <lambdabot>   where
03:47:31 <lambdabot>     f _ 0 y = y
03:47:31 <lambdabot>     f x n y = g x n
03:47:33 <lambdabot> [3 @more lines]
03:48:14 <ski> @more
03:48:15 <lambdabot>         where g x n | even n    = g (x*x) (n `quot` 2)
03:48:15 <lambdabot>                     | otherwise = f x (n-1) (x*y)
03:48:15 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
03:48:51 * ski nods
03:49:30 <ij> Could you define a monad without type classes? Somehow capture the idea as much as possible.
03:49:31 <MarcelineVQ> novakboskov: stack build  accepts a --ghc-options  flag for passing specific things, e.g. stack build --ghc-options="-O1 -prof"  but it doesn't seem to accept -prof due to https://github.com/commercialhaskell/stack/issues/1015  :(
03:49:47 <ski> `f x n y = x ^ n * y' is the invariant there
03:50:02 <MarcelineVQ> novakboskov: appearantly it's inherited from https://github.com/haskell/cabal/issues/2827#issuecomment-141783201 since stack uses Cabal
03:50:33 <brynser_> :t concatMap
03:50:35 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
03:50:46 <ski> ij : yes, you could make a data type for the operations
03:51:21 <liste> ij: you could pass around the dictionaries yourself
03:51:49 <liste> so instead of Monad m => m Integer, you'd have Monad m -> m Integer
03:52:01 <liste> and Monad would be just a record of functions
03:52:31 <ski> ij : of course this requires higher-order types, to be able to abstract over arbitrary monads like this
03:52:37 <novakboskov> MarcelineVQ: I'm still investigate but something like `stack build --profile --ghc-options="-fno-prof-cafs"` acts like `ghc -prof -fprof-auto Module.hs`
03:54:45 <MarcelineVQ> are you sure that's not -fprof-auto-exported  or -fprof-auto-top  and not -fprof-auto?
03:55:21 <MarcelineVQ> I wonder if you can pass Cabal options somewhere, 1.23 provides http://cabal.readthedocs.io/en/latest/nix-local-build.html?highlight=--enable-profiling#cfg-flag---profiling-detail
03:58:19 <novakboskov> I guess... I really have no experience in this so I have to try... :)
03:59:13 * JuanDaugherty sees that as a weaver TH would have an implicit LP aspect
03:59:44 <ski> weaver ?
04:00:16 <JuanDaugherty> code weaver
04:00:36 <JuanDaugherty> LP weaves code and doc
04:00:37 <ski> does that mean the same as staged programming ?
04:00:52 <JuanDaugherty> no like in AOP
04:01:02 <ski> oh, Literate Programming. i was for some reason thinking Logic Programming
04:02:14 <JuanDaugherty> prolly cause you know me mostly from prolog
04:02:23 <ski> possibly
04:05:21 <MarcelineVQ> novakboskov: I can't seem to find anything particularily helpful beyond the mentioned links
04:05:50 <MarcelineVQ> especially I don't see any way to pass cabal options, possibly it's because such things are really cabal-install options which stack isn't.
04:06:15 <MarcelineVQ> though idk if that's the case, just my immediate thought
04:06:54 <mathkb> I am looking for the wiki page that speak about hiding the type constructor. How is this idiom called?
04:07:45 <MarcelineVQ> novakboskov: poossssibly if you specify your .cabal version to be >= 1.23  you could set these as options in your .cabal file, lemme see
04:09:32 <marekw2143> hello 
04:09:58 <ski> hello
04:11:27 <marekw2143> is there something wrong near here https://bitbucket.org/chessRepo/c7/src/08f9d9bd00825500ba10056bedbdbd410b1f9975/main.hs?at=master&fileviewer=file-view-default#main.hs-131 ? 
04:12:33 <marekw2143> compiler tells me : main.hs:131:20: parse error on input ‘=’
04:13:09 <novakboskov> Marceline
04:14:16 <ski> marekw2143 : `getNextMoves' has no body after `do'
04:14:34 <marekw2143> oh
04:14:41 <ski> you could put `undefined' there for the time being
04:14:50 <MarcelineVQ> novakboskov: stack doesn't seem to recognise cabal .project files so it may not be possible to specify these flags manually :(
04:15:54 <marekw2143> ski: ok, works
04:16:04 <marekw2143> undeifned is just a mock? 
04:16:07 <marekw2143> or a type in haskell 
04:16:07 <ski> yes
04:16:12 <ski> @src undefined
04:16:12 <lambdabot> undefined = error "Prelude.undefined"
04:16:25 <ski> it's not a type, it's an ordinary variable
04:16:29 <MarcelineVQ> novakboskov: this is a .project file, it's different than a .cabal file and appearantly where these options could be passed if not on the command line, but stack doesn't seem to check it: http://cabal.readthedocs.io/en/latest/nix-local-build.html#configuring-builds-with-cabal-project
04:16:43 <marekw2143> ski, but it can be assigned to everything ? 
04:16:55 <ski> it has every type, yes
04:16:58 <ski> @type undefined
04:17:02 <lambdabot> a
04:17:42 <marekw2143> ski, :)
04:18:08 <marekw2143> btw, are there lot of people using haskell in their daily job ? 
04:18:41 <novakboskov> MarcelineVQ: Nevermind, --ghc-options stack flag is OK for my current needs... It seems like this is the only way to pass these options all the way down to ghc. Thank you! :)
04:20:37 <MarcelineVQ> np, note that you should be able to turn off things with ghc options, so you could stack build --profile --ghc-options="-fno-prof-cafs"  or somesuch, dunno if that works as expected
04:21:38 <MarcelineVQ> ah you mentioned that earlier anyway hehe :>
04:22:12 <halogenandtoast> Is there a preferred safe library for HTTP requests?
04:22:24 <SepakoRayl> hello everyone
04:22:34 <brynser_> hi
04:23:23 <JuanDaugherty> halogenandtoast, last i knew there was only streit for the title
04:25:19 <brynser_> halogenandtoast: check http://haskelliseasy.readthedocs.io/en/latest/#http-clients
04:26:58 <brynser_> http-conduit also has a Simple module which is my current go-to, tutorial here: https://haskell-lang.org/library/http-client
04:27:51 <halogenandtoast> brynser_: I'll check it out.
04:29:42 <halogenandtoast> thanks
04:36:23 <brynser_> np :)
05:01:56 <ibKH> hello i m learning haskell and i'm having difficult time understanding monoid, functor, applicative functor and monads. Can anyone suggest me link to a tutorial or some easy way to understand them
05:04:00 <hpc> ibKH: take it one thing at a time, and learn them in that order
05:04:00 <oherrala> ibKH: have you already found this: http://dev.stephendiehl.com/hask/ ?
05:04:43 <oherrala> ibKH: and this one: https://wiki.haskell.org/Typeclassopedia
05:05:34 <ibKH> the first one i haven't checked i'll look now thanks
05:11:22 <dramforever> ibKH: Are you trying to know 'What exactly *is* a functor'?
05:11:28 <dramforever> Don't do that
05:11:31 <dramforever> Just keep going
05:11:40 <dramforever> Things will make much more sense later on
05:12:26 <Athas> Man, "functor" gotta be the most overloaded term in computer science.
05:12:54 <dramforever> *If* you understand typeclasses, you know enough about monoid, functor, applicative to get going
05:13:10 <dramforever> (unrelated note: you mentioned functor twice :P)
05:13:10 <hpc> especially Monoid, which you probably know already and just don't know it yet
05:13:17 <ibKH> @dranforever yes, i know that is a mappable over a structure but that's it
05:13:18 <lambdabot> Unknown command, try @list
05:13:31 <dramforever> *If* you get do-notation desugaring you know enough about Monoid
05:13:38 <dramforever> ibKH: That's it
05:13:41 <ski> @where on-functors
05:13:42 <lambdabot> "On Functors" (in C++,Standard ML,Haskell,Prolog) by Peteris Krumins in 2010-05-17 at <http://www.catonmat.net/blog/on-functors/>
05:14:25 <dramforever> If you don't find the meaning of functors, that's because there's no such meaning
05:14:52 <dramforever> ibKH: Do you know typeclasses?
05:14:58 <ibKH> yes
05:15:16 * ski doesn't see what `do'-notation desugaring has to do with `Monoid'
05:15:21 <dramforever> ibKH: And you've seen the typeclasses of those things?
05:15:33 <dramforever> Uh, sorry I meant monad
05:15:48 <ibKH> fmap and things like that ?
05:15:57 <dramforever> class Functor f where
05:16:05 <ski> or `(==)',`show',&c.
05:16:05 <dramforever>     fmap :: (a -> b) -> f a -> f b
05:16:06 <ibKH> aa yes
05:16:11 <dramforever> ibKH: Thank you
05:16:22 <dramforever> You have learned functor, applicative, monad, etc.
05:17:01 <ibKH> ok so i need practice to know how to use them i guess
05:17:19 <dramforever> ibKH: To practice, keep going forwards
05:17:41 <dramforever> Don't struggle to understand them -- there isn't anything to understand
05:18:18 <ibKH> ok i ll try to use them in practice thanks.
05:28:32 <SepakoRayl> When using Alex with the monad wrapper, is runAlex supposed to return a single match ?
05:29:43 <nbro> if I define a function like this: k = 1; h k = True; h _ = False; why, if I call f 1, or f 2, I’m not the first pattern?
05:30:41 <Ferdirand> nbro: because of shadowing
05:32:05 <nbro> Ferdirand: how does it work exactly here? If I calll f k, it still returns False...
05:33:08 <Ferdirand> wait that should not even compile
05:33:17 <Ferdirand> it would complain of overlapping patterns
05:34:48 <nbro> Ferdirand: you’re right, I was trying it on the interpreter...
05:35:08 <nbro> so f k = True should actually match anything
05:35:41 <Ferdirand> oh
05:35:42 <Ferdirand> then your second clause shadows the first as an entirely new function
05:38:28 <nbro> Ferdirand: yes
05:38:57 <nbro> btw, is it a good idea to say that a function returns a value?
05:39:22 <nbro> with respect to the word “returns”
05:39:45 <nbro> should I prefer for example “produces”?
05:40:02 <nbro> I know there’s also the keyword return in Haskell, even though I’ve still not had a look at it
05:41:39 <liste> nbro: it's a function, not a keyword
05:41:41 <liste> :t return
05:41:44 <lambdabot> Monad m => a -> m a
05:42:05 <nbro> ahah, this bot is funny
05:42:14 <nbro> liste: ok
05:42:55 <Ferdirand> maybe "evaluates to" is more accurate, I don't know, let's ask the elders for their opinion
05:42:59 <Logio> nbro: I would prefer 'return' to 'produce' myself
05:43:16 <dminuoso> nbro: The book Im reading uses the word reduction actually.
05:45:03 <ski> nbro : "returns" or "outputs" is fine, imho
05:45:11 <Logio> if you feel like avoiding 'return', it's probably best to go towards the abstract math version of mapping values to values, instead of the intuitive 'doing stuff' to values interpretation
05:45:17 <ski> "produces" might work as well
05:45:45 <Logio> but that depends on what you want the reader to think about
05:45:45 <ski> one could say the function call evaluates or reduces to a result
05:47:14 <nbro> ok, at least saying “returns” it does not seem to be a sin
05:47:53 <liste> yeah, the "return" function is badly named anywahy
05:48:06 <liste> these days you can use "pure" instead of "return"
05:48:26 <liste> > do { putStrLn "hi"; pure 4 }
05:48:30 <lambdabot>  <IO Integer>
05:50:37 <nbro> let me try to play also with this bot
05:50:51 <ski> @help run
05:50:51 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
05:50:56 <nbro> :t map
05:50:58 <lambdabot> (a -> b) -> [a] -> [b]
05:51:02 <ski> `> ...' short for `@run ...'
05:51:10 <ski> `:t ...' is short for `@type ...'
05:51:36 <Tuplanolla> You can send private messages to it as well, nbro.
05:52:31 <nbro> ahah, I saw the source code is hosted on Github, maybe I will have a look at it
05:53:48 <liste> > isGreat "liste" -- pm's with lambdabot rock
05:53:51 <lambdabot>  yeah!
06:02:19 <nbro> :t toDegress x = x * 180.0 / pi
06:02:21 <lambdabot> error:
06:02:21 <lambdabot>     parse error on input ‘=’
06:02:21 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
06:02:36 <Xnuk> :t \x -> x * 180.0 / pi
06:02:39 <lambdabot> Floating a => a -> a
06:03:05 <Xnuk> > isGreat "Haskell"
06:03:08 <lambdabot>  nah...
06:03:17 <nbro> ahah
06:03:42 <Tuplanolla> The documentation for `Control.Concurrent` says that "if you have a `ThreadId`, you essentially have a pointer to the thread itself".
06:03:44 <fDev2179> That's funny.
06:04:19 <Tuplanolla> Does this mean that if a thread dies and I start another one, it could get the now-unused `ThreadId` of the dead thread?
06:05:42 <Tuplanolla> This feels like the pid reaping problem all over again.
06:07:39 <mauke> Tuplanolla: what's the problem?
06:08:33 <Tuplanolla> You may accidentally kill the wrong thread, mauke.
06:09:19 <mauke> how so?
06:15:25 <Tuplanolla> Let's say I spawn threads #1, #2 and #3. Before #2 manages to start, #1 dies due to an exception. Now #3 may get the `ThreadId` of #1, so when I try to kill #1, which should do nothing, #3 dies instead.
06:17:25 <Tuplanolla> This is the stuff nightmares are made of.
06:22:20 <mauke> Tuplanolla: you can only kill #1 if you have its ThreadId
06:22:29 <mauke> if you have a ThreadId, you have a pointer to the thread
06:22:38 <mauke> if you have a pointer to it, it can't be garbage collected
06:22:49 <mauke> so it can't be reused
06:22:54 <Tuplanolla> Oh, of course!
06:34:13 <vaibhavsagar> I'm having insane memory usage on this program for the Coursera algorithms 1 course
06:34:24 <vaibhavsagar> is there a way to get around this?
06:34:36 <vaibhavsagar> http://lpaste.net/1337420848532815872
06:36:59 <robertkennedy> If I implement a class with a non transitive version of Eq, will my code work?
06:37:06 <vaibhavsagar> the input is roughly 1 million lines, and it all seems fine until I try to calculate the intersections
06:39:01 <robertkennedy> Ie will pattern matching literals use Eq? Probably not?
06:39:06 <lyxia> robertkennedy: maybe, if your code doesn't rely on transitivity.
06:39:25 <lyxia> pattern matching literals uses Eq
06:39:57 <robertkennedy> Oh tight
06:40:24 <lyxia> that sounds like a bad idea out of any context though
06:40:59 <robertkennedy> Well I'm thinking to represent computable numbers with equality on intervals 
06:42:23 <robertkennedy> So I could say "1.66666 == 1.67"
06:43:23 <robertkennedy> Not intervals, maybe, but I just wanted to ensure I wasn't dead out of the gate
06:43:41 <nbro> I’m creating an “unhex”  function that, given a character from ‘1’ to ‘f’ (i.e. the hexadecimal characters) it returns the decimal representation… I’m enumerating all possible pattern matchings in different lines, like “…unhex 'c' = Just 12; unhex 'd' = Just 13; …”. Is there a way to shorten this code?
06:44:37 <Tuplanolla> You can make use of `ord`, nbro.
06:44:42 <Tuplanolla> :t ord
06:44:44 <lambdabot> Char -> Int
06:44:45 <mauke> > digitToInt 'c'
06:44:49 <lambdabot>  12
06:45:09 <liste> > digitToInt 'g'
06:45:12 <lambdabot>  *Exception: Char.digitToInt: not a digit 'g'
06:45:59 <nbro> @Tuplanolla : I’m required to use pattern matching where appropriately required and this function should actually return a Maybe Int...
06:46:00 <lambdabot> Unknown command, try @list
06:46:06 <robertkennedy> > fromEnum 'c'
06:46:09 <lambdabot>  99
06:46:21 <Tuplanolla> All these options!
06:47:18 <robertkennedy> > fromEnum '😎'
06:47:20 <lambdabot>  128526
06:47:38 <mauke> > let unhex c | any (`inRange` c) [('0', '9'), ('A', 'F'), ('a', 'f')] = Just (digitToInt c) | otherwise = Nothing in unhex 'c'
06:47:41 <lambdabot>  Just 12
06:47:47 <mauke> > let unhex c | any (`inRange` c) [('0', '9'), ('A', 'F'), ('a', 'f')] = Just (digitToInt c) | otherwise = Nothing in unhex 'g'
06:47:50 <lambdabot>  Nothing
06:48:18 <mauke> nbro: you can shorten it but not with pattern matching
06:48:58 <Tuplanolla> Compress the code with gzip and then extract it at compile time with TH.
06:49:18 <liste> nbro: you can do "unhex x = case x in { '0' -> ... }"
06:49:31 <lyxia> vaibhavsagar: you have 1M lines, is the size of "values" going to be around that order of magnitude as well? then for each element you produce a set of size 20k.
06:51:34 <nbro> liste: case .. in ?
06:52:19 <liste> > case 5 in { 5 -> "five"; _ -> "not five; }
06:52:22 <lambdabot>  <hint>:1:8: error: parse error on input ‘in’
06:52:27 <liste> oh wait
06:52:29 <liste> brainfart
06:52:54 <liste> > case 5 of { 5 -> "five"; _ -> "not five"; }
06:52:57 <lambdabot>  "five"
06:54:22 <liste> > let unhex x = case x of { '0' -> Just 0; '1' -> Just 1; '2' -> Just 2; _ -> Nothing } in unhex '2'
06:54:27 <lambdabot>  Just 2
06:57:28 <nbro> liste: ok, that could actually work and I would not be using if-then-else (which I shouldn’t be using in this exercise)… but this would be as cumbersome as the pattern matching solution
06:58:16 <mauke> nbro: case/of *is* pattern matching
06:58:27 <nbro> mauke: what does the | (i.e. the pipe) actually means in Haskell, for example you used it here: “let unhex c | any (`inRange` c) [('0', '9'), ('A', 'F'), ('a', 'f')] = Just (digitToInt c) | otherwise = Nothing in unhex 'g'”...
06:58:36 <raylocal> hi i have a question . why does this work pure (++"foobar") <*> ("foo", "bar")
06:58:55 <raylocal> but not ->  pure (+2) <*> (2,3)
06:59:14 <Ferdirand> > pure (+2) <*> (2,3)
06:59:17 <lambdabot>  error:
06:59:18 <lambdabot>      • Ambiguous type variable ‘t0’ arising from a use of ‘show_M727212133103...
06:59:18 <lambdabot>        prevents the constraint ‘(Show t0)’ from being solved.
06:59:35 <mauke> nbro: in that case it introduces a "guard", i.e. a boolean condition in addition to the pattern match
06:59:41 <Ferdirand> > pure (+2) <*> (2,3) :: (Int,Int)
06:59:44 <lambdabot>  error:
06:59:44 <lambdabot>      • No instance for (Monoid Int) arising from a use of ‘<*>’
06:59:44 <lambdabot>      • In the expression: pure (+ 2) <*> (2, 3) :: (Int, Int)
07:00:06 <Tuplanolla> > pure (+ 2) <*> (2, 3)
07:00:11 <lambdabot>  (2,5)
07:00:34 <mauke> > mempty :: Integer
07:00:41 <lambdabot>  0
07:00:45 <mauke> that's cheating
07:00:47 <Tuplanolla> You need a `Monoid` instance for this to work.
07:01:15 <Ferdirand> :t (+ 2)
07:01:18 <lambdabot> Num a => a -> a
07:01:19 <Ferdirand> :t (+2)
07:01:21 <lambdabot> Num a => a -> a
07:01:32 <Ferdirand> huh
07:01:32 <Tuplanolla> Check the constraint of `Monoid ((,) a)`, raylocal.
07:01:53 <Tuplanolla> Actually `Monoid ((,) a b)`.
07:02:12 <raylocal> yeah i was thinking  that in  that case this should work pure (++"test") <*> (2, "test")   but it doesn't
07:02:22 <robertkennedy> ?src instance Monoid ((,) a b)
07:02:23 <lambdabot> Source not found. It can only be attributed to human error.
07:02:34 <nbro> mauke: I can use a boolean condition in the left side of the definition of a function?!!
07:02:57 <mauke> nbro: sure
07:03:56 <nbro> mauke: can I use only guards in the left side of the function def?
07:04:01 <mauke> there are language extensions for even crazier things, such as pattern guards and view patterns
07:04:07 <nbro> to introduce a condition?
07:04:30 <mauke> function definition syntax is just sugar for case/of
07:04:46 <mauke> and I think guards work in any context where a pattern is allowed
07:06:20 <mauke> > let foo | False = 42 in foo
07:06:23 <lyxia> > pure (++ "test") <*> (2, "test") :: (Product Integer, String)
07:06:23 <lambdabot>  *Exception: <interactive>:3:5-20: Non-exhaustive patterns in function foo
07:06:27 <glguy> not lambda s
07:06:28 <lambdabot>  (Product {getProduct = 2},"testtest")
07:06:42 <lyxia> raylocal: totally works ^
07:06:58 <mauke> > (\foo | False -> foo) 42
07:07:01 <lambdabot>  <hint>:1:7: error: parse error on input ‘|’
07:07:06 <glguy> or do notation <-
07:07:53 <Tuplanolla> Why though?
07:08:25 <vaibhavsagar> @lyxia I just found out that HashSet is implemented in terms of Data.HashMap.Lazy
07:08:25 <lambdabot> Unknown command, try @list
07:08:32 <vaibhavsagar> maybe that is why?
07:09:05 <glguy> the @ is for bot commands
07:09:59 <argent0> Hi, I itend to use sqlite in haskell, is HDBC the prefered way?
07:10:04 <nbro> can we import modules or functions from modules only if the current file is defined as a module?
07:10:20 <vaibhavsagar> thanks glguy :)
07:10:33 <mauke> nbro: all files are modules
07:11:02 <argent0> s/itend/want
07:11:03 <mauke> if you don't have an explicit module declaration, it's 'module Main where'
07:11:08 <nbro> well, I’ve read that modules must be explicitly defined with a name that starts with a capital letter…
07:11:29 <nbro> mauke: ok, so I’m currently on the Main module
07:11:49 <lyxia> vaibhavsagar: that doesn't matter though. The laziness of HashMap only affects values, i.e., (), not keys.
07:12:17 <mauke> https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1
07:12:33 <raylocal> thanks Tuplanolla  and lyxia . I understand that the monoid instance should be there for both the members of the tuple and not only the 2nd one as i has thought /imagined 
07:12:36 <lyxia> vaibhavsagar: but isn't your program representing 20 billion elements?
07:12:47 <liste> argent0: check out https://hackage.haskell.org/package/sqlite-simple
07:12:50 <raylocal> i understand NOW i mean :)
07:12:59 <lyxia> vaibhavsagar: how did you expect it to fit
07:13:34 <vaibhavsagar> lyxia: are you saying that that is where the memory usage is coming from?
07:13:43 <Tuplanolla> For `Monoid` you need both, but `Applicative` only requires the first, raylocal.
07:13:46 <vaibhavsagar> not the intersection that I'm doing?
07:14:21 <lyxia> well the intersections surely don't help
07:16:24 <vaibhavsagar> fair call, I changed it so that I'm computing intersections when I first build the hashmap
07:18:58 <argent0> liste: thanks for the info
07:26:43 <nbro> mauke: I was looking at your solution of unhex, and there’s one part that I actually didn’t fully understand
07:26:49 <nbro> and which is: any (`inRange` c) [('0', '9'), ('A', 'F'), ('a', 'f')]
07:26:55 <nbro> :t any
07:26:57 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
07:27:12 <nbro> any :: (a -> Bool) -> [a] -> Bool
07:27:34 <nbro> any requires a predicate
07:27:55 <nbro> in your example, apparently (`inRange` c) is the predicate
07:28:02 <nbro> :t inRange
07:28:04 <lambdabot> Ix a => (a, a) -> a -> Bool
07:28:07 <benjwadams> Where can I learn more about Haskell's build system?  I've only dabbled with haskell, but I'm getting irritated with python's model breaking everything.
07:28:19 <benjwadams> heard mixed things about cabal
07:30:19 <sm> http://haskell-lang.org/get-started
07:30:44 <vaibhavsagar> benjwadams: https://docs.haskellstack.org/en/stable/README/
07:31:27 <nbro> :info inRange
07:31:53 <mauke> @hoogle inRange
07:31:56 <lambdabot> Data.Ix inRange :: Ix a => (a, a) -> a -> Bool
07:31:56 <lambdabot> Data.Ix.Enum inRange :: Enum a => (a, a) -> a -> Bool
07:31:56 <lambdabot> Data.Ord.HT inRange :: Ord a => (a, a) -> a -> Bool
07:34:47 <nbro> mauke: in the first signature of inRange function we have: Data.Ix inRange :: Ix a => (a, a) -> a -> Bool, we have that it receives two arguments, a tuple (a, a) and a
07:35:21 <nbro> but in your usage: any (`inRange` c) [('0', '9'), ('A', 'F'), ('a', ‘f’)], you don’t seem to use the two arguments correctly
07:35:32 <nbro> maybe I’m just misinterpreting the signature
07:36:21 <mauke> nbro: do you know what ` ` does?
07:36:52 <mauke> also, you retyped the 'f' part. weird
07:36:59 <nbro> mauke: from my understanding it’s used to make the function be infix
07:37:14 <mauke> correct
07:37:33 <mauke> do you know about operator sections?
07:37:48 <mauke> > (/ 2) 3
07:37:52 <lambdabot>  1.5
07:38:15 <nbro> mm…I think I briefly saw something like that before
07:38:30 <mauke> > map (/ 2) [1 .. 10]
07:38:33 <lambdabot>  [0.5,1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0]
07:38:36 <nbro> you essentially can precede the operator
07:38:48 <nbro> with the second part
07:39:06 <mauke> :t (`inRange` ?c)
07:39:08 <lambdabot> (?c::a, Ix a) => (a, a) -> Bool
07:39:18 <mauke> :t (`inRange` (?c :: Char))
07:39:20 <lambdabot> (?c::Char) => (Char, Char) -> Bool
07:41:40 <lep-delete> :t (`inRange` _)
07:41:43 <lambdabot> error:
07:41:43 <lambdabot>     • Found hole: _ :: a
07:41:43 <lambdabot>       Where: ‘a’ is a rigid type variable bound by
07:41:47 <lep-delete> :D
07:42:31 <mauke> @undo (`inRange` c)
07:42:31 <lambdabot> (`inRange` c)
07:42:38 <mauke> @unpl (`inRange` c)
07:42:38 <lambdabot> (\ a0 -> inRange a0 c)
07:43:20 <tabaqui1> I have one config file for my application
07:43:59 <tabaqui1> in Python I would parse it and put in one global singleton
07:44:26 <tabaqui1> because I don't want to pass fields up to down, from main to actual function
07:44:35 <tabaqui1> which pattern do you use in haskell?
07:44:42 <tabaqui1> *what pattern
07:47:04 <tabaqui1> ah, haskell wiki recommends to wrap the whole code into configuration monad
07:47:24 <tabaqui1> I hope there is more elegant solution
07:47:31 <mauke> @where configurations
07:47:32 <lambdabot> http://okmij.org/ftp/Haskell/dependent-types.html#Prepose
07:47:43 <mauke> @where reflection
07:47:43 <lambdabot> I know nothing about reflection.
07:47:51 <Sornaensis> is anyone ever going to fix the syntax highlighting bugs in the haskell wiki
07:47:57 <liste> @hackage reflection
07:47:57 <mauke> @where+ reflection http://hackage.haskell.org/package/reflection
07:47:58 <lambdabot> http://hackage.haskell.org/package/reflection
07:47:58 <lambdabot> Good to know.
07:52:57 <nbro> I’m curious to know what Haskell programmers that have at least some experience with Scala think about this latter?
07:53:13 <maerwald> nothing
07:53:39 <maerwald> it's an incredibly unfocussed language and not really functional for a haskeller
07:53:47 <bollu> lens question: is there a way to simplify this? I have two (Data.Map x y), call them "m1" and "m2". I want to extract the key out of m1. if it does not exist, I want to take it out of m2. Best I could come up with way m1 ^. key <|> m2 ^. key
07:55:32 <nbro> maerwald: you mean that it supports different paradigms as opposed to Haskell
07:55:39 <nbro> ?!
07:55:39 <lambdabot> Maybe you meant: v @ ? .
07:55:40 <maerwald> no, it's unfocusses
07:56:01 <maerwald> e.g. try to write a proper ADT in Scala... there are 5-10 ways to do it and all are different and have oddities
07:56:04 <berndl> I think Haskellers will all prefer Haskell over Scala any day.
07:56:14 <maerwald> and ultimately, all of them are not what you want
07:56:28 <maerwald> the Scala developers keep adding stuff to the language without much thought
07:56:31 <maerwald> it's like C++
07:56:48 <Sornaensis> yea my problem with scala/c++ is how many divergent ways of doing things there are
07:56:58 <berndl> maerwald: yes, indeed.
07:57:13 <Sornaensis> makes understanding what's happening in a piece of code take longer than necessary
07:57:13 <nbro> oh, I see, I also like languages that are more focused, like Haskell or C
07:57:28 <berndl> How many ways can you define a int variable with a value of 27 in C++?
07:57:37 <nbro> lol
07:57:37 <mlev> Can someone please help me with this memoization within an instance declaration question?  http://stackoverflow.com/questions/42583263/memoization-of-intermediate-values-in-a-typeclass-instance
07:57:51 <berndl> There are 6 ways of doing it.
07:58:10 <nbro> but I think this problem comes from the fact that people in those programming languages come from different areas and require different things
07:58:12 <Sornaensis> berndl: only 6?
07:58:22 <berndl> Last I counted, yes.
07:58:24 <mauke> int i = 27; int i(27); int i = { 27 }; int i { 27 }; ?
07:58:39 <berndl> Don't forget the auto versions.
07:58:57 <mauke> signed int i = 27; int signed i = 27; int (i) = 27; int ((i)) = 27;
07:59:24 <nbro> well, guys, I must say one thing
08:00:37 <nbro> C++ is complex mostly because it strives to be back-compatible with C and because of a bad type system
08:01:02 <mauke> C++ doesn't strive to be compatible with C
08:01:17 <nbro> mauke: it was originally designed to be
08:01:20 <mauke> no
08:01:33 <nbro> mauke: yes
08:01:45 <mauke> it stopped when it added the 'class' keyword
08:02:02 <brynser_> "C with Classes"
08:02:47 <nbro> mauke: backward compatible means that any (or almost any) C program can be compiled by a C++ compiler
08:02:55 <mauke> not "almost"
08:03:35 <mauke> C++ made 'class' a keyword, which broke all C programs that did 'int class;' or similar
08:03:48 <nbro> mauke: you’re saying different things
08:03:54 <nitrix> The OOP mania doesn't help.
08:03:58 <nbro> C is not C++, of course!
08:04:01 <mauke> this wouldn't be such a big deal, but C++ also redefined 'struct' to create classes
08:04:07 <berndl> C++ is complex because it inherited most of the stuff from C and added even more stuff on top.
08:04:14 <nbro> but C++ is (almost always) C
08:04:15 <mauke> so 'class' is actually 100% redundant
08:04:15 <c_wraith> that was an early goal of C++, but it was abandoned long ago. even without that keyword collision, some C constructs have different semantics in C++ now
08:04:36 <mauke> nbro: nonsense
08:04:44 <nbro> mauke: class and struct are different in C++
08:04:58 <nbro> struct makes fields public by default, class makes them private
08:05:01 <mauke> nbro: yes, one defaults to public, the other to private
08:05:03 <mauke> big deal
08:05:22 <mauke> you could still use 'struct Foo { private: ...}' everywhere and never need 'class'
08:06:22 <nbro> look, I’m not saying C++ is the most elegant language in terms of design, but it beats almost all the others almost in all context in terms of performance, so it’s useful as a language
08:06:37 <Sornaensis> C++ is going to be entirely replaced by rust in a few years
08:06:42 <bollu> is there a way to simplify this? I have two (Data.Map x y), call them "m1" and "m2". I want to extract the key out of m1. if it does not exist, I want to take it out of m2. Best I could come up with way m1 ^. key <|> m2 ^. key
08:06:42 <mauke> performance is not a language property
08:07:04 <karroffel> Sornaensis: yeah, just like IPv6 replaced IPv4 5 years ago
08:07:09 <Sornaensis> bollu: is there a reason that's not simple enough for you?
08:07:10 <karroffel> I love Rust
08:07:12 <karroffel> don't get me wrong
08:07:13 <nbro> mauke: yes, I said it in that way to simplify things
08:07:15 <Sornaensis> karroffel: C++ is not as entrenched as C
08:07:16 <bollu> Sornaensis: curiosity, mostly
08:07:22 <bollu> Sornaensis: I want to see how much I can push lens
08:08:16 <karroffel> I see rust as a really really really capable competitor to C++, but I don't think C++ is going anywhere the next 10 years unfortunately
08:08:25 <nbro> Sornaensis: I’m also curious about rust, zero-cost abstractions, no gc, it really seems the most promosing language to replace C++ step by step
08:08:27 <bollu> karroffel: hm, why?
08:08:50 <karroffel> bollu: because the industry is slow when it comes to adapting new stuff
08:09:04 <glguy> the comparison of rust and c++ is off topic in #haskell
08:09:08 <karroffel> AAA games will still count on C++ as Rust is a bit too pure
08:09:22 <karroffel> Yeah true, sorry glguy :/
08:09:25 <Sornaensis> rust is heavily influenced by haskell tho
08:11:34 <bollu> Sornaensis: more ML
08:12:01 <shapr> Has anyone use HaNS for packet manipulation instead of purely as a TCP/IP stack?
08:12:31 <fendor> Short question, how can i get the binary representation of a number?
08:13:58 <glguy> > showIntAtBase 2 intToDigit 42 ""
08:14:01 <lambdabot>  "101010"
08:14:13 <fendor> thanks a lot 
08:14:38 <nbro> I really like Haskell, but there also a few minor things that I’ve already perceived in the language that could have been designed better, for example the fact that you need to wrap negative numbers with parenthesis when passing them to a function, that’s kind of unnecessary tedios for such a minor thing 
08:15:24 <coltfred> I agree that's a little annoying.
08:15:27 <shapr> nbro: what about keeping a list of the things that bug you, and then when you've learned Haskell, come back and fix them?
08:15:43 <shapr> or at least share the list after a month or two?
08:16:00 <shapr> nbro: Mind you, I'd want to see the other list as well, things that thrill you :-)
08:16:27 <fendor> the thing that thrills me most is when c++ programmers come at me and act like haskell is not a real language
08:16:36 <nbro> shapr: eheh 
08:16:47 <fendor> that thrills me in haskell develeopment :D 
08:16:53 <shapr> fendor: That's an odd way to start a discussion
08:17:05 <fendor> shapr, that was just a joke
08:17:06 <shapr> I like to show people useful everyday code I've written in Haskell.
08:17:07 <shapr> ha
08:17:16 <nbro> shapr: definitely not many things, I predict, compared to other lists ;)
08:17:29 <fendor> shapr, was not meant to be taken seriously, sorry
08:17:34 <shapr> nbro: well, keep track of the lists, I'm interested
08:17:40 <glguy> There's already an extension you can turn on to support negative literals
08:17:44 <shapr> nbro: Want to see some cool code I wrote as a weekend hack?
08:17:57 <blackdog> nbro: problem is that you'd have to make that a special case and make it more complicated to understand how operators work in general.
08:17:58 <nbro> shapr: yeah, why not?
08:18:42 <shapr> nbro: This displays info in my status bar from the JSON API of Atlanta's subway trains so I can get to work and other places on time: https://github.com/shapr/tmuxmarta/blob/master/src/Lib.hs
08:20:06 <shapr> nbro: I use byobu, and I put the resulting binary into ~/.byobu/bin/ as 60_marta so byobu will refresh the info every sixty seconds.
08:21:16 <shapr> output (at this instant) looks like: ["M:10","N:Arriving"] meaning a train going south from North Avenue is arriving, and a train going north from Midtown is ten minutes away.
08:22:32 <shapr> nbro: are you familiar with list comprehensions in Python?
08:24:55 <nbro> shapr: yes, I’m familiar with them
08:26:08 <shapr> nbro: Python's list comps were borrowed from Haskell, and TransformListComp gives even MOAR super list comp powers!
08:26:32 <nbro> shapr: yes, I noticed ;)
08:26:49 <shapr> nbro: Have you used LINQ in C#? The TransformListComp extensions remind me of LINQ: https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/list-and-comprehension-extensions
08:28:16 <nbro> shapr: I’ve used C# 2-3 years ago and I don’t think I’ve ever used LINQ…
08:28:46 <shapr> oh, I really enjoyed writing LINQ, you can make some amazingly powerful pipelines that mix sql results, anonymous objects, and everything else.
08:29:20 <shapr> nbro: What got you interested in Haskell?
08:30:18 <nbro> I would like to have the opportunity to go back to C#, but I’ve not programmed on Windows for a while, even though now it can also be used as a cross-platform language because of mono
08:31:03 <nbro> shapr: I got interested in Haskell already a few months ago, but I only started learning it like not even a week ago
08:31:22 <nbro> oh
08:31:27 <nbro> sorry, you asked “what"
08:31:32 <shapr> sure, that's fine too
08:32:16 <nbro> first because it’s a pure functional language
08:32:43 <nbro> it’s also probably the most used one
08:33:09 <shapr> Yeah, lots of commercial use of Haskell
08:34:02 <maerwald> lots?
08:34:06 <shapr> Here at work Haskell is mostly used for pandoc, xmonad, and shellcheck.
08:34:23 <shapr> Though we almost chose PFQ instead of DPDK, oh well
08:34:42 <maerwald> last I checked even Prolog was ahead on the Tiobe index. Then there was a survey about used programming languages where haskell scored as a "weekend language"
08:34:50 <shapr> maerwald: yeah, I think lots, have you seen the CUFP talks?
08:36:11 <shapr> nbro: Do you have a project you want to implement in Haskell?
08:36:19 <maerwald> do they provide numbers or talk about surveys in industry?
08:38:30 <nbro> shapr: I would like to exploit Haskell where, let’s say, it excels, for example in a multi-threading environment, but first I need to learn the language very well
08:39:32 <nbro> it excels in the sense that by default we do not have mutable things
08:40:07 <nbro> now I’m still not familiar with libraries and the actual support for multi-threading
08:40:21 <shapr> Yeah, the multicore support is especially nifty
08:40:59 <Sornaensis> haskell has the finest implementation of software transactional memory afaik
08:41:04 <Sornaensis> well, ghc
08:41:30 <maerwald> and ghc breaks errno thread safety :P
08:43:45 <ongy> I thought ghc saves errno into the haskell threads for that reason?
08:44:17 <meijiJAPAN> Is it possible to do web development with Haskell 
08:44:43 <meijiJAPAN> And if so, how it is different compared to Scala 
08:45:03 <liste> karroffel: yes, it's possible.
08:45:12 <liste> meijiJAPAN: ^
08:45:16 <liste> not karroffel, sorry
08:45:17 <maerwald> ongy: I don't know, that's what I got from discussions with more knowledable people here, I asked about it
08:45:44 <liste> meijiJAPAN: the libraries, programming techniques and ecosystem are different
08:45:48 <fendor> does someone know a good template haskell tutorial?
08:47:03 <nbro> joke: I think Haskell is not the mostly widely used programming language only because people are lazy enough to avoid the laziness of Haskell 
08:47:08 <nbro> well, not that funny
08:47:11 <nbro> :D
08:47:42 <nbro> lol
08:48:00 <Sornaensis> maerwald: you mean web frameworks? yesod is quite mature 
08:51:41 <maerwald> ongy: http://tunes.org/~nef/logs/haskell/17.01.09 check the logs for "errno"
08:51:49 <maerwald> ircbrowse is down, no idea why
08:53:57 <sm> thread-safe current working directory has been a problem, also
08:54:11 <maerwald> sm: heh... are you referring to darcs? :P
08:54:29 <sm> we've seen it in darcsden, yup
08:54:40 <maerwald> anyway, for that there is an "easy" solution: absolute paths :P
08:54:51 <sm> just adding that to the list while we're pointing out flaws in haskell's gem-like perfection
08:55:13 <Tuplanolla> Haskell's what?
08:55:54 <maerwald> sm: however, I'm not actually sure that working directory thing is a problem with GHC/the runtime... could just be the way darcs/darcsden or libraries (mis-)handle things?
08:56:08 <maerwald> could even be Snap
08:56:50 <sm> it is a piece of state that's not thread-safe, IIRC
08:57:49 <sm> perhaps we have some process lib that handles it better now 
08:59:00 <kuribas> Hi, I have a profiling graph of my library http://kuribas.hcoop.net/Overlap.html : http://kuribas.hcoop.net/graph.svg
08:59:30 <kuribas> Control.Monad.State.Class.modify seems to take a large chunck of the time, is there a way to optimize that?
08:59:53 <kuribas> Shouldn't ghc optimize it away?
09:00:24 <Tuplanolla> Is that state lazy, kuribas?
09:01:25 <kuribas> Tuplanolla: I think not...
09:02:46 <Tuplanolla> That would explain it.
09:03:10 <kuribas> Tuplanolla: why?
09:03:21 <kuribas> the algorithm is strict...
09:04:24 <Tuplanolla> Since `modify` does not evaluate its arguments.
09:04:40 <Tuplanolla> There's `modify'` for that.
09:05:58 <kuribas> right
09:07:27 <kuribas> what about modifying?
09:07:32 <kuribas> :t modifying
09:07:35 <lambdabot> MonadState s m => ASetter s s a b -> (a -> b) -> m ()
09:08:53 <kuribas> is there a strict version of modifying?
09:09:21 <Tuplanolla> @hoogle modifying'
09:09:22 <lambdabot> No results found
09:09:27 <Tuplanolla> Not reassuring.
09:09:44 <fProgrammer> quick question: I've a created a datatype using record syntax.  What is the most efficient way to convert it to a map, where the accessor functions are key and the values are Map Values. For ex: http://lpaste.net/353181
09:09:54 <Tuplanolla> There may be some lens magic to get around this.
09:10:44 <kuribas> modifying l f = State.modify' (over l f)
09:10:52 <kuribas> erm modifying'
09:16:26 <lyxia> fProgrammer: Text and Int are different types so you can't put both of them in a map
09:19:03 <kuribas> perhaps I should try lens instead of microlens...
09:22:42 <ongy> is there a reason strerror is not exposed in haskell? I wanted to reuse the errno definitions for sending errors over sockets
09:32:56 <hongminhee> I got this error which is new to me.  Do anyone know what does this mean?
09:32:56 <hongminhee>     • Couldn't match type ‘Constraint’ with ‘*’
09:32:57 <hongminhee>       Expected type: Proxy * (Target Nirum.Targets.Python.Python)
09:32:57 <hongminhee>         Actual type: Proxy Constraint (Target Nirum.Targets.Python.Python)
09:35:05 <lyxia> this means you used a Proxy with the wrong type.
09:35:16 <lyxia> hongminhee: can you paste the offending code
09:36:09 <hongminhee> I'm actually using some TemplateHaskell now...
09:38:13 <hongminhee> github gist seems not to support directories
09:38:16 <hongminhee> https://gist.github.com/dahlia/e0b726810b90806a3e1c7791d7499c6d#file-nirum-targets-hs-L48
09:38:41 <hongminhee> That line is where the error comes from
09:45:44 <lyxia> hongminhee: InstanceD _ _ t _  here t is not the type for which the instance is being defined.
09:46:14 <lyxia> When you write instance Monoid (), here t corresponds to the whole "Monoid ()"
09:46:21 <lyxia> rather than just "()"
09:46:55 <hongminhee> oh
09:47:45 <hongminhee> lyxia: really thanks for your advice!  :-)  it was my first TemplateHaskell coding, so I'd mistaken...
09:47:55 <hongminhee> 🙏
09:48:55 <lyxia> you're welcome
10:02:50 <Ch3ck> is there any GHC playground online?
10:03:00 <Ch3ck> Where I can run my haskell code on the browser
10:04:48 <danza> Ch3ck, a web search should bring you some, this was added lately https://repl.it/site/blog/haskell
10:07:56 <Tuplanolla> @let m = Data.Map.fromList [(1, 'a'), (2, 'b')] :: Map Int Char
10:07:58 <lambdabot>  .L.hs:164:47: error:
10:07:58 <lambdabot>      Not in scope: type constructor or class ‘Map’
10:07:58 <lambdabot>      Perhaps you meant ‘M.Map’ (imported from Data.Map)
10:08:08 <Tuplanolla> @let m = M.fromList [(1, 'a'), (2, 'b')] :: M.Map Int Char
10:08:11 <lambdabot>  Defined.
10:08:18 <Tuplanolla> > has (at 3) m -- Why?
10:08:21 <lambdabot>  error:
10:08:21 <lambdabot>      Ambiguous occurrence ‘m’
10:08:21 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.m’,
10:08:27 <Tuplanolla> > has (at 3) M.m -- Why?
10:08:31 <lambdabot>  error:
10:08:31 <lambdabot>      Not in scope: ‘M.m’
10:08:31 <lambdabot>      Perhaps you meant ‘L.m’ (line 164)
10:08:59 <Tuplanolla> > has (at 3) L.m -- Once more why? And lambdabot's imports are the worst.
10:09:03 <lambdabot>  True
10:11:25 <mauke> @undefine
10:11:25 <lambdabot> Undefined.
10:11:32 <mauke> just don't define single-letter variables
10:12:48 <Tuplanolla> Shouldn't import `SimpleReflect` or use single-letter module aliases.
10:33:28 <c_wraith> SimpleReflect is valuable for lambdabot's main purpose. 
10:34:18 <lyxia> Yeah, lambdabot is no ghci
10:40:30 <Tuplanolla> It's nice that you undefined my example and didn't answer my question. I don't need variables for it though.
10:40:36 <Tuplanolla> > has (at 3) (mempty :: Data.Map.Map Int Char)
10:40:40 <lambdabot>  True
10:40:44 <Tuplanolla> Why does this happen?
10:43:32 <lyxia> at is a lens, it always matches.
10:44:51 <Tuplanolla> Is there something I can compose it with to make it behave like `ix`? Perhaps `each`?
10:46:24 <c_wraith> why not just use ix? 
10:46:57 <Tuplanolla> The lens is an argument and it's used in more than one spot.
10:47:18 <lyxia> at 3 . _Just
10:47:58 <c_wraith> yeah, I was just hoping to check that.. since at points to a Maybe, the _Just works. 
10:48:35 <Tuplanolla> Great.
10:51:13 <michalrus> Hey, is there a “deterministic” code formatter in the sense that it will always output the same whitespace, irregardless of formatting it gets as its input?
10:52:15 <lyxia> Just parse the code and print it?
10:54:57 <mauke> "irregardless" :-(
10:56:25 <c_wraith> mauke, now accepted by dictionaries as a synonym of regardless! :) 
10:58:09 * michalrus grins
10:58:11 <mauke> but not by me!
10:58:16 <mauke> infidels
10:59:58 <michalrus> lyxia: but isn’t there some commonly used solution for that? I wanted to setup a CI (or update/post-receive hook) script to reject unformatted changes. Writing the formatter myself seems wrong. (:
11:00:53 <michalrus> I tried hindent once, but I think it behaved strangely…
11:01:35 <michalrus> (And arguing over formatting in CRs is time lost.)
11:12:40 <lyxia> michalrus: why is it important for it to be deterministic
11:13:14 <lyxia> I think the way you worded it implies every AST has a unique source code representation
11:13:34 <lyxia> but this is not really desirable because you may want to choose yourself how to break some lines
11:14:12 <lyxia> I bookmarked this some time ago but have never tried it https://github.com/lspitzner/brittany
11:14:13 <michalrus> AST might be too much, but every source… has one best whitespace arrangement?
11:14:24 <Tuplanolla> I reckon it would still be desirable to have a generalized isomorphism between source code and syntax trees.
11:15:08 <michalrus> I just wanted to limit formatting discussions to 0. I might be spoiled by this one(!) part of Scala ecosystem (scalafmt). =)
11:15:25 <michalrus> Thank you for the link!
11:15:52 <lyxia> I like the idempotence requirement
11:15:54 <cocreature> iirc brittany tries even harder to preserve the original formatting than hindent
11:15:58 <monochrom> For each person, there exists uniquely a canonocial source code format.
11:16:22 <monochrom> The problem is different people demand different, conflicting canonical formats.
11:16:29 <shapr> monochrom: but I don't like line noise
11:16:39 <Tuplanolla> That is, f . g . f = f and g . f . g = g instead of just f . g = id and g . f = id.
11:17:03 <dolio> Scala is spoiling you because there are 0 best arrangements for all source? :P
11:17:12 <michalrus> Haha.
11:17:38 <lyxia> Tuplanolla: Okay that one's much more reasonable
11:18:37 <Tuplanolla> Doesn't Go have this?
11:18:47 <monochrom> This lack-of-consensus problem is mitigated in the Scala community (similarly the Python community) by a strong leader and the rest being docile (even religious) followers.
11:19:06 <monochrom> But the Haskell community is very close to being a diverse democracy.
11:19:45 <michalrus> But time! Time is lost on these discussions. And they don’t necessarily contribute much… value? :)
11:20:00 <monochrom> (Just look at how many web frameworks to choose from!)
11:20:12 <shapr> michalrus: On the other hand, if you don't have multiple valid approaches, how do you advance?
11:20:26 <monochrom> You don't have to discuss. You can just go ahead implement your ideal.
11:20:33 <shapr> michalrus: Whatever programming will be in 100 years, I hope it's not just like it is now, I want to steal those things from the future and use them now!
11:21:23 <monochrom> For example the GHC people do implement first then let the community discuss. And it is a good idea because the discussion is based on actual usage experience not armchair what-ifs.
11:22:45 <monochrom> And the perk up is that if everyone else merely propose ideas, but you have a ready-to-use implementation of your idea, you gain de facto followers. This is what happened to lens.
11:23:12 <michalrus> shapr: that would be awesome and is one of my greatest sorrows, that we’re in the Middle Ages of programming… =( Maybe in the next incarnations⸮
11:23:14 <michalrus> Mhm. :)
11:24:33 <shapr> michalrus: we can rebuild it! We have the technology!
11:24:37 <EvanR> congratulations youre what conal called a "priestly caste"
11:25:03 <EvanR> people who can comprehend and officiate over the arcane processes of software
11:26:23 <EvanR> hopefully in the future the distilled essence of programming language becomes available to everybody
11:31:05 <monochrom> That is only half of the story. The other half is: Do people actually want it?
11:31:09 <shapr> EvanR: my girlfriend has been learning Python the past few months. When we started she had never heard of a terminal or command line.
11:31:39 <shapr> I realize that anyone who joins this channel is almost certainly part of that priestly caste.
11:31:54 <EvanR> yes when the sales girl remarked/jokes she wanted to learn "coding" i just sent her iterm2
11:31:57 <monochrom> The distilled essence of programming language is available today. It is a solved problem. Denotation semantics and stuff. But look at the programmers, they actually hate it.
11:31:58 <EvanR> technically all you need
11:32:01 <dolio> Do you folks call mechanics the, "priestly class of auto repair," too?
11:32:42 <monochrom> Everyone is a priestly caste member of something.
11:32:47 <EvanR> electricians and mechanics have well defined environments and ways to solve every problem
11:32:55 <EvanR> they have been doing X for 100 years
11:33:27 <EvanR> outside microsoft certified IT stuff, you can do anything, and we get in trouble for it on a regular basis
11:33:43 <EvanR> no ones right
11:33:49 <shapr> dolio: I've seen people break their cars because they didn't understanding anything about them, so maybe?
11:34:35 <EvanR> the complexity of car maintenance pales in comparison to "coding"
11:34:53 <shapr> Don't recent cars have many millions of lines of code in them?
11:34:55 <EvanR> even the computer parts which is just a thing you plug a thing into and press a button
11:35:28 <EvanR> the mechanic is readin or writing the code in the car
11:35:30 <EvanR> isn*
11:35:50 <monochrom> I doubt that electrician jobs have existed for 100 years. :)
11:36:24 <EvanR> the 19th century screwing-around with electricity and radio, yeah that seems like where we are 
11:36:43 <monochrom> True.
11:37:11 <monochrom> Car mechanics are still not touching the software.
11:37:26 <EvanR> now you plug in LCD shield, internet shield, accelerometer shield... even the potentiometer shield
11:38:29 <monochrom> Also, car manufacturers have been modularizing cars so much that car mechanics do not have to understand intra-module things. They just have to replace modules.
11:39:00 <monochrom> (Some car mechanics can choose to dig deeper. They personal preference. Not a majority.)
11:39:55 <EvanR> i go to work, hope that i can choose to not dig deeper and just use 2 gems together, it explodes in my face, i now need to understand the code of 2 terrible projects
11:39:59 <monochrom> So these days car mechanics are more at the level of Cisco Certified Network persons.
11:40:20 <monochrom> (who do not have to code up TCP/IP stacks, clearly)
11:40:29 <maerwald_mob> EvanR: xD
11:42:36 <monochrom> Consider "FPComplete Certified XMonad Engineer" :)
11:43:47 <monochrom> No no, re-order the words, "XMonad FPComplete Certified Engineer", XFCE.
11:44:02 <maerwald_mob> where can I apply for certified for complete jobs?!
11:44:32 <maerwald_mob> oh wait. this is not -offtopic
11:46:03 <SepakoRayl> Jgiyo
11:46:36 <SepakoRayl> that was VimFx :(
11:47:01 <monochrom> So you meant "yo", right?
11:48:12 <SepakoRayl> yup, what's everyone doing
11:48:35 <monochrom> We got off-topic a bit, then it died.
11:50:53 <shapr> greetings SepakoRayl, how's code? Tried opaleye yet?
11:52:22 <Athas> Is it generally considered a good or a bad thing that Prelude.union or Data.Map.union is left-biased in case of duplicates?
11:52:24 <SepakoRayl> nope! I'll check it out after I am done with my parser
11:52:53 <monochrom> Yes Athas.
11:53:12 <Athas> Is it generally considered a bad thing that Prelude.union or Data.Map.union is left-biased in case of duplicates?
11:53:14 <monochrom> At least for people who are used to left-to-right mother tongues.
11:53:41 <monochrom> I mean a good thing.
11:54:08 <Athas> Really?  I'd assume that left-to-right-readers would conclude the _last_ statement to be the true one.
11:54:45 <monochrom> Ah.
11:55:06 <Tuplanolla> I'm sure there's a connection to `foldr` here, Athas.
11:55:20 <monochrom> Dunno. But looks like people have settled for it.
11:55:22 <Athas> I suspect the reason is that if you implement an association table as a list, and 'lookup' picks the first match, then union is just concatenation.
11:56:22 <Athas> But it never made much sense to me.  I've memorised it for Data.Map.union, but I recently got tripped up by the fact that `mappend` for Data.Map.Map is also left-biased!  (Because it is synonymous with union.)
11:56:27 <nitrix> Wouldn't concatenating the two lists risk creating duplicates though?
11:56:36 <nitrix> This doesn't sound like union.
11:56:45 <Athas> Sure, but the lookup function picks the first one it sees.
11:57:44 <nitrix> Ah that's interesting.
11:58:09 <nitrix> "Note that the implementation is left-biased -- the elements of a first argument are always preferred to the second, for example in union or insert."
11:58:21 <Theophane> *left-padded
11:58:22 <Theophane> :P
11:58:38 <Athas> At least that behaviour is consistent among all Haskell libraries I've used.
11:58:44 <monochrom> You have to break ties and someone has to pick a convention and the rest of us have to suffer it. It can't be helped.
11:58:49 <Athas> But I was considering whether to adopt the same design for a non-Haskell language.
11:59:18 <Athas> Sure, I was just wondering whether it's (in hindsigt) considered a good idea, for a clean-slate environment.
11:59:19 <monochrom> Make a poll in the community :)
11:59:21 <mauke> perl effectively is right biased
11:59:29 <Athas> I'd never do a Haskell library that didn't follow this convention.
12:00:37 <Tuplanolla> > fold [Just "yes", Nothing, Just "no"] -- Would you consider this left-biased too, Athas?
12:00:41 <lambdabot>  Just "yesno"
12:01:28 <Athas> Well, I meant for functions called "union".
12:02:04 <Tuplanolla> Yes, but the question is whether the left-bias is somehow more universal or intrinsic to the language.
12:03:07 <nitrix> I'd prefer a unionWith.
12:03:29 <dolio> That exists.
12:03:42 <nitrix> I meant for his language design.
12:04:12 <Athas> That's not really an option here.  It's for record concatenation, and what happens in the case of duplicate field names.
12:05:04 <nitrix> Athas: That sound very dynamically typed.
12:05:25 <nitrix> If so, maybe you could merge the two fields by creating another object/record that contains the two values under the same key.
12:06:48 <nitrix> {a = 1, b = 2} `union` {b = 3, c = 4} == {a = 1, b = [2,3], c = 4}
12:07:42 <EvanR> i like "extensible records with scoped labels"
12:08:03 <EvanR> {a = 1, b = 2} union {b = 3, c = 4} ==> {a = 1, b = 2, b = 3, c = 4}
12:08:22 <nitrix> data Record = Record { a :: Element Int, b :: Element Int };  data Element a = Such a | Many [a]
12:08:26 <Athas> Ah, but an important use case is for record updates.  {a = 1, b = 2} `union` {b = 3} == {a = 1, b = 3}.
12:08:37 <Athas> This form of concatenation subsumes record updates, which I find elegant.
12:08:44 <dolio> Why do you think the right side is the update?
12:08:52 <EvanR> it also loses something
12:09:22 <mauke> dolio: because I read from left to right, so the left side happens earlier
12:09:26 <EvanR> theres a different abstraction for talking about updates
12:10:22 <Athas> mauke: that's a good point.  However, in most use cases, the left-hand side will be a record-typed variable: rv `union` {b = 3} == {a = 1, b = 3}.
12:10:35 <Athas> I find that this reads nicely, and is close to Haskell's own 'rv { b = 3 }' notation.
12:11:32 <EvanR> union seems to evoke something completely different from updating to me
12:11:44 <Tuplanolla> The lens order would be `set id new old`, Athas.
12:11:56 <EvanR> actually, replacement strategies seem totally off topic for union
12:12:35 <EvanR> were talking about record concatenation
12:12:42 <EvanR> so <>
12:12:47 <nitrix> Now that I think about it, merging them into a list has no benefits. It makes the language more comlicated and there's no practical use of "keeping both sides" as it's immutable and you can just write "b `union` a" rather than "a `union` b" if that's what you want.
12:12:53 * nitrix still thinkering.
12:13:13 <EvanR> nitrix: there is a benefit, as described in the paper
12:13:19 <EvanR> for extensible records and variants
12:13:25 <Mortenl> I'm trying to create a new Stack project using 'stack new my-project simple', but when I try to build it it fails with "Invalid package ID: "array-0.5.1.1 base-4.9.0.0 binary-0.8.3.0 bytestring-0.10.8.1". Using Ubuntu 16.04, any ideas what's wrong?
12:14:21 <dolio> EvanR: That's allowing duplicate fields, though. Not allowing duplicate fields but having the types of fields change if there are duplicates in a union is different (and probably unnecessarily complicated).
12:14:54 <EvanR> were changin the types of fields?
12:15:05 <dolio> In nitrix's example, yes.
12:15:13 <EvanR> agreed
12:15:34 <nitrix> Depends. I corrected myself with an `Element` type that allowed multiple values.
12:15:46 <nitrix> I'm not too sure where it's headed though.
12:16:20 <EvanR> rather than duplicate you could think of it as scoped, or temporal
12:16:20 <monochrom> You need quantum superposition.
12:16:28 <nitrix> Maybe the field values all have to be monoids :D !?
12:17:33 <EvanR> monoid hammer
12:18:09 <monochrom> quantum states form a monoid. mappend is vector addition.
12:19:48 <nitrix> data Record = forall a b. (Monoid a, Monoid b) => Record { a :: a, b :: b }
12:19:52 <nitrix> Fixed it !
12:20:18 <EvanR> semigroup?
12:20:49 <nitrix> Mhhh... oh yeah.
12:21:10 <nitrix> I have no clue how practical that'd be but it's fun to think about.
12:23:25 <byorgey> that looks... not very practical.
12:23:37 <byorgey> you can put things in and combine them, as long as you never want the values back out.
12:26:24 <nitrix> EvanR: With a Monoid you could have {} initialize your record, a problem haskell suffers with the record syntax setting all the fields to undefined.
12:27:22 <nitrix> I think I would've liked that answer until knowing Haskell where magical default values became a big no-no.
12:27:33 <nitrix> I'd rather have an ADT now.
12:39:02 <Ptival_> does anyone understand how to use NonEmpty in SmallCheck?
12:45:34 <zipper> Hey, does anyone here know about the text lib and how it handles or doesn't handle unicode when packing and unpacking?
12:45:37 <zipper> e.g
12:45:57 <zipper> Data.Text.unpack $ Data.Text.pack "уч"
12:46:01 <zipper> > Data.Text.unpack $ Data.Text.pack "уч"
12:46:05 <lambdabot>  error:
12:46:05 <lambdabot>      Not in scope: ‘Data.Text.unpack’
12:46:05 <lambdabot>      No module named ‘Data.Text’ is imported.error:
12:46:31 <zipper> Anywho that should be isomorphic but doesn't seem to be
12:47:47 <Tuplanolla> @let import qualified Data.Text as Text
12:47:49 <lambdabot>  Defined.
12:47:50 <Tuplanolla> > let x = "уч" in Text.unpack (Text.pack x) == x
12:47:53 <lambdabot>  True
12:47:56 <geekosaur> > T.unpack $ T.pack "уч"
12:47:59 <lambdabot>  error:
12:48:00 <lambdabot>      Not in scope: ‘T.unpack’
12:48:00 <lambdabot>      Perhaps you meant ‘BS.unpack’ (imported from Data.ByteString)
12:48:11 <geekosaur> of course we couldn't be sensible enough to do that :/
12:48:24 <zipper> > Text.unpack $ Text.pack "уч"
12:48:28 <lambdabot>  "\1091\1095"
12:48:32 <zipper> You see
12:48:36 <Tuplanolla> Nope.
12:48:38 <zipper> Not isomophic
12:48:48 <Tuplanolla> > "уч"
12:48:51 <lambdabot>  "\1091\1095"
12:48:53 <zipper> I just read http://stackoverflow.com/questions/24953125/how-to-convert-unicode-escape-sequence-to-unicode-string-in-haskell
12:49:18 <zipper> "If you putStrLn or write to any other handle, the result will display the proper unicode string"
12:49:21 <zipper> hmmmmm
12:49:43 <geekosaur> > text $ Text.unpack $ Text.pack "уч"
12:49:47 <lambdabot>  уч
12:49:58 <geekosaur> nothing to do with Data.Text; this is Show
12:50:04 <geekosaur> on String
12:50:27 <geekosaur> (pedantically, showList @Char)
12:50:56 <zipper> hmmmm I didn't know about text
12:50:58 <monochrom> zipper: It is a great lesson to learn that WYS is not WYG.
12:50:58 <zipper> :t text
12:51:00 <lambdabot> String -> Doc
12:51:17 <zipper> monochrom: WYS? WYG?
12:51:26 <monochrom> You heard of WYSIWYG?
12:51:29 <geekosaur> it's a hack, a orettyprinter combinator whose Show instance is literal (violating expectations for Show...)
12:51:37 <AbstractLion> What you see is not what you get
12:52:33 <geekosaur> basically Show is expected to produce sometyhing that would be valid Haskell source code from a maximally compatible character set, so pretty much everything above U+007E gets escaped
12:53:07 <zipper> Oh yeah
12:53:28 <geekosaur> (and below U+0020)
12:54:07 <monochrom> WYSIWYG is something we tell end-users, and we strive to code up things to live up to it, because we want to make things easy for end-users and help them get things done.
12:54:49 <monochrom> But we programmers deal with crossing abstraction boundaries and differing representations and differing renders and this and that. WYSIWYG is untrue for us.
12:55:22 <monochrom> If you see two different renderings, it doesn't mean that they have different backing data.
12:55:41 <monochrom> If you see two same renderings, it still doesn't mean that they have identical backing data.
12:55:58 <geekosaur> ..and unicode is especially evil there
12:56:06 <geekosaur> unless you enforce normalization
12:57:32 <monochrom> For the backing data, trust only a hex editor.
12:57:45 <zipper> Thinking about how this Doc type will typecheck
12:57:53 <monochrom> Even REPLs and editors can lie.
12:58:23 <geekosaur> you don;t need it most likely; we use it in lambdabot because you can't putStr / putStrLn
12:58:27 <geekosaur> it's a hack
12:58:42 <monochrom> Well, not lie, but they do various translations that may be convenient for one purpose but unfaithful for all others.
12:58:58 <zipper> I also don't want to putStrLn because it'll print
12:59:03 <geekosaur> the only thing you need to do in a program, usually, is avoid use of show on String or Text
12:59:12 <geekosaur> what areyou doing with the data?
12:59:28 <geekosaur> more precisely, what are you doing that might make use of show / showsPrec?
12:59:34 <zipper> I want to do something with the string
12:59:48 <geekosaur> that is a non-answer
12:59:58 <zipper> geSorry
13:00:02 <zipper> geekosaur: Sorry
13:00:09 <geekosaur> I think you still are not getting it, you still believe that eithger String or Text is causing this
13:00:16 <geekosaur> neither is. *Show* is causing it.
13:00:18 <zipper> I'm I'm fetching HTML page metadata
13:00:21 <geekosaur> make the Show go away.
13:00:32 <zipper> I'm not using show
13:00:42 <zipper> Oh
13:00:44 <geekosaur> then something you are doing is
13:01:09 <zipper> Yea the lib tagsoup probably is
13:01:19 <zipper> https://hackage.haskell.org/package/tagsoup-0.14.1/docs/Text-HTML-TagSoup.html
13:01:53 <zipper> `renderTagsOptions renderOptions{optEscape = id} $ parseTags "<title>&& Слу - YouTube</title>"`
13:02:06 <zipper> It is printing in the repl
13:02:18 <geekosaur> ghci is using Show behind your back
13:02:22 <geekosaur> do not trust its output
13:02:37 <monochrom> <monochrom> Even REPLs and editors can lie.
13:02:50 <zipper> hmmm in the end the program will end up printing this so it'll use show, right?
13:03:00 <geekosaur> (specifically, it does `print it` after evaluation --- and print = putStrLn . show
13:03:21 <geekosaur> only if you use `print` instead of `putStrLn` or whatever
13:03:24 <monochrom> In the end it's your program and you choose putStr vs print.
13:03:48 <zipper> monochrom: hmmm
13:03:54 <zipper> It's not a big program
13:03:56 <zipper> One sec
13:04:31 <monochrom> Use hPutStr and save it to a file and use a hex editor to examine it.
13:04:52 <zipper> It's an IRC bot https://github.com/nairobilug/nairobi-bot/blob/master/src/Bot/URL.hs
13:05:12 <zipper> Some dudes using cyrillic text got so pissed
13:05:27 <zipper> I'll find out what is using the show
13:05:46 <monochrom> And the real story gets more complicated that just hPutStr
13:06:02 <monochrom> Because there is the question of "is it UTF-8 or what?"
13:06:50 <monochrom> IIRC the text library has a function for "translate Text to UTF-8 bytestring". This is preferred. Send the bytestring to file or stdout.
13:07:37 <monochrom> Do not even bother with String because String's putStr/hPutStr is locale-dependent and that's a whole can of worm there.
13:07:37 <zipper> It is utf-8 because we get a unicode codepoint, no?
13:07:46 <monochrom> No.
13:08:08 <monochrom> Text is not already utf-8. Text does its own thing.
13:08:22 <monochrom> I can tell you what it is, but it is only going to harm you.
13:08:34 <zipper> monochrom: How so?
13:08:40 <monochrom> Better think of it as abstract and/or "may change arbitrarily tomorrow"
13:08:50 <zipper> lol ok
13:09:13 <monochrom> Because it is actually irrelevant to input and output formats.
13:09:49 <Clint> zipper: do not use Data.ByteString.Char8
13:10:00 <monochrom> Notice that every I/O function of text is explicitly documented with what format it uses.
13:10:24 <monochrom> And there is none that says "I use Text's internal storage format verbatim".
13:10:31 <monochrom> So you may as well not care.
13:11:25 <monochrom> String is the opposite. String tells you the internal storage format (32-bit int per Char) but the I/O format is practically unspecified.
13:11:43 <monochrom> (Well, "locale-dependent". Does that tell you anything?)
13:13:28 <zipper> Yes it does
13:13:43 <monochrom> OK, what does that tell you?
13:14:02 <zipper> If I had set a locale to something, maybe Russian
13:14:06 <zipper> It would have worked
13:14:13 <zipper> But mine is en_US
13:14:28 <monochrom> Which encoding for the Russian? KOI? UTF-8? UTF-16LE?
13:15:04 <Clint> it would not have worked, because you are using Data.ByteString.Char8 to convert to String
13:15:18 <zipper> I tried `Data.ByteString.Char8.unpack $  Data.Text.Encoding.encodeUtf8 $ Text.pack "уч"` nothing
13:15:27 <zipper> Although Clint did say not to use Char8
13:15:30 <Clint> zipper: do not use Data.ByteString.Char8
13:15:33 <monochrom> Yeah, cut the Char8.
13:15:34 <zipper> monochrom: idk what encoding it is
13:16:11 <monochrom> There you go. It doesn't tell you anything.
13:16:19 <zipper> monochrom: It doesn't help the result though 
13:16:24 <zipper> Dropping the Char8
13:16:37 <zipper> I think I should take a nap and look at this with fresh eyes
13:16:46 <monochrom> In fact why unpack at all?
13:16:48 <bitf> hey guys, i have a question from the book, Learn You a Haskell:
13:16:51 <zipper> I believe tagsoup is doing soemthing fishy
13:16:57 <bitf>     instance Monad Maybe where  
13:16:57 <bitf>         return x = Just x  
13:16:57 <bitf>         Nothing >>= f = Nothing  
13:16:57 <bitf>         Just x >>= f  = f x  
13:16:59 <bitf>         fail _ = Nothing  
13:17:13 <bitf> this is in the section on monads
13:17:28 <bitf> does the just x line make sense
13:17:33 <monochrom> Do you trust me? If so, screw bytestring unpack, just use Data.ByteString.hPutStr directly.
13:17:39 <zipper> monochrom: I assumed unpack is the only way it would stop being a bytestring and be a string
13:17:52 <zipper> monochrom: I sure do trust you
13:17:56 <bitf> shouldn't it be Just x >>= f = Just f x
13:17:56 <monochrom> No, screw String altogether, that's what I'm saying and you proved.
13:17:57 <Sornaensis> bitf: which one
13:18:08 <Sornaensis> :t (>>=)
13:18:10 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:18:22 <Sornaensis> bitf: notice the type of the second parameter
13:18:31 <bitf> ok
13:18:46 <zipper> :t Data.ByteString.hPutStr
13:18:49 <lambdabot> GHC.IO.Handle.Types.Handle -> BSC.ByteString -> IO ()
13:19:23 <bitf> so the Just is implicit in the f...?
13:19:29 <zipper> I really don't want something that returns a unit
13:19:32 <zipper> I need this string
13:19:34 <monochrom> Remember WYS is not WYG? If you go through String and System.IO, you are incurring more of that, not less. You are incurring more mutilating translations.
13:19:49 <Sornaensis> bitf: f is a function that will return a (Maybe b)
13:20:04 <Sornaensis> when you give it an a
13:20:32 * monochrom shakes head
13:20:52 <zipper> monochrom: :) let me take a small break
13:21:04 <zipper> I'm going to make sense of this scrollback
13:21:15 <monochrom> You already have the Text version and the ByteString version. If you pass them as parameters to Data.ByteString.hPutStr, it does not mean that you will lose the original Text or the original Bytestring. You understand that?
13:21:38 <zipper> Oh I see with Data.ByteString.hPutStr I write to the handle and read from it right after
13:21:48 <zipper> *write to the file
13:21:56 <zipper> Sounds like it would blow up at scale
13:22:04 <zipper> file descriptors and all
13:22:21 <zipper> monochrom: I do now
13:22:46 <monochrom> OK I give up. https://xkcd.com/763/
13:22:46 <bitf> ah yes i understand now. thanks for help  Sornaensis
13:24:49 <zipper> monochrom: LOL I'm kinda sleep deprived
13:24:57 <zipper> I'll look at it in a few
13:25:33 <lpaste_> f-a pasted “Could not match type `m` with `m1`” at http://lpaste.net/353191
13:26:25 <zipper> monochrom: I believe tagsoup forces me to go through String or at least something they call StringLike
13:26:50 <zipper> "A class to generalise TagSoup parsing over many types of string-like types. "
13:27:33 <mauke> f-a: that's a different type
13:27:48 <mauke> your signature creates a new type variable 'm'
13:27:55 <mauke> unrelated to the 'm' in run's type
13:28:32 <f-a> thanks mauke. Any way to tell ghc "hey they are the same"?
13:29:20 <f-a> I can of course omit to write them, but with them it is easier to read the code
13:29:35 <mauke> look into ScopedTypeVariables
13:29:41 <geekosaur> f-a, ScopedTypeVariables and use `forall m.` in the signature
13:30:04 <f-a> mhh I had {-# Language ScopedTypeVariables #-}
13:30:07 <f-a> not the forall though
13:30:22 <geekosaur> right, you need the forall to tell it *which* type variables to scope-extend
13:31:15 <f-a> forall m t i o. (MonadIO m, Integral t) did it
13:31:21 <f-a> thanks mauke & geekosaur 
13:34:30 <d0t> ohai. Does intero work with .hsc files?
13:39:48 <zipper> monochrom: Ok seems to me I could solve this simply by setting locale. However given that it already is set to UTF-8 it should just work. It is utf-8 in that "en_US.UTF-8"
13:40:22 <Clint> zipper: are you missing that Data.ByteString.Char8 breaks anything but ASCII?
13:40:52 <zipper> Ch3ck: I won't use a bytestring
13:41:02 <zipper> hmmm
13:41:18 <zipper> I read a bytestring over the network though
13:41:20 <zipper> FML
13:42:11 <Clint> you read a bytestring over the network. you write a bytestring over the network.
13:43:30 <zipper> Clint: I agree
13:46:19 <Tuplanolla> Can you give a rough estimate for how long `forkIO` takes?
13:48:32 <Tuplanolla> Three orders of magnitude is an acceptable uncertainty.
13:49:30 <mauke> I would imagine it to be super fast
13:49:50 <geekosaur> forkIO does virtually nothing itself except some accounting, so it should be fast
13:51:44 <Tuplanolla> There's a potential race condition when transferring the ownership of a `Handle` to a new thread, so I'd like to add a just-in-case wait to ensure the other thread can register it before unregistering it on the other side.
13:53:34 <geekosaur> you will likely want to use an MVar or similar, I think
13:54:08 <monochrom> Yeah, MVar will do the handshake nicely.
13:54:25 <monochrom> Err, no, not enough.
13:55:38 <geekosaur> forkIO does not actually create or schedule a thread, it creates a "spark" which the runtime will schedule on a thread. you cannot rely on the spark being scheduled on a thread in any timely fashion after forkIO returns; you must use synchronization
13:55:47 <monochrom> Actually, yes enough if you don't mind a time period of "the old owner no longer uses it, the new owner hasn't started using it"
13:57:00 <monochrom> The old owner does a putMVar, then don't use it anymore. The new owner does a takeMVar, then starts using it. putMVar finishes before takeMVar.
13:57:05 <geekosaur> there's also a question of whether having two registrations or zero registrations is considered the error condition (if the error condition is "both" then you need to rethink this)
13:58:05 <Tuplanolla> Then an `MVar` should do.
13:58:06 <geekosaur> uh, s/both/any state other than exactly one/
13:58:10 <monochrom> which is, admittedly, slightly different from the dual-pilot protocol, maybe? "I have control" happens before "you have control".
14:03:53 <Tuplanolla> Well, I just changed a leak to a double free.
14:05:14 <monochrom> haha
14:07:17 <monochrom> Don't just write free software. Write double-free software!
14:10:10 <Tuplanolla> I'll have to trust this "a Handle will be automatically closed when the garbage  collector detects that it has become unreferenced by the program" remark.
14:11:09 <monochrom> That sentence can be trusted. But the timing is less predictable.
14:11:26 <Tuplanolla> That's fine for a failsafe.
14:11:42 <monochrom> Also a human's skill of determining whether their code unreferences anything.
14:24:17 <voidhorse> Preferred way to write Haskell? IDE, vim, text editor, stone tablet?
14:25:21 <monochrom> May I lump vim with text editor?
14:26:42 <APic> Emacs.
14:26:46 <lyxia> generated from coq
14:26:54 <Tuplanolla> Correct answer, lyxia.
14:27:11 <voidhorse> Monochrom Yeah, I just wanted to distinguish from a text editor running in the terminal from one with a standalone ui
14:27:47 <monochrom> There are two schools.
14:28:28 <monochrom> One school goes with Leksah, an IDE. It takes some effort to install, and you may or may not like it at the end. If you do, great.
14:28:47 <monochrom> The other school goes with a text editor of a personal choice.
14:29:15 <fDev2179> Vim ftw
14:29:18 <voidhorse> Cool--I tried leksah back two or so years ago--I don't remember liking it too much
14:29:23 <monochrom> Both schools agree that stone tablets are great for thinking and planning. Or whiteboards.
14:30:21 <voidhorse> I guess leksah is probably the closest thing to something like an IntelliJ ide for Haskell --from the looks of it
14:30:48 <voidhorse> Ignoring idea Haskell plugins of course
14:30:59 <Rembane> emacs and the right plugins seems to be a nice experience for many.
14:31:48 <dgpratt> if I'm reading something that discusses a "top" type and a "bottom" type in the context of a type lattice, I suppose that "forall a. a" could be the top type and...Void could be the bottom type? my other thought was maybe "exists a. a"?
14:34:26 <lyxia> I imagine this is about subtyping and something like exists a. a would be at the top, forall a. a at the bottom (isomorphic to Void)
14:37:47 <monochrom> Yeah, forall is at the bottom, exist is at the top.
14:38:07 <dgpratt> ok, thanks
14:42:12 <dgpratt> I suppose that my misapprehension of "forall a. a" has at least something to do with the fact that I usually encounter it in negative position (he said knowing full well he was risking saying something stupid)
14:59:45 <nitrix> Does anyone with an intuition for genetic programming can look at the `moo` library (https://hackage.haskell.org/package/moo-1.0) and tell me how I'd have a fitness function that requires IO?
14:59:58 <nitrix> (Loading samples from network/disk to train the GA) ?
15:00:22 <nitrix> `ObjectiveFunction` seems to not have such thing.
15:01:46 <nitrix> Strangely, StepGA though lets you have a monad `m`.
15:01:58 <nitrix> I don't know how one would connect to twos.
15:02:39 <fDev2179> From what I know of optimization algorithms, there is no training.  
15:03:06 <nitrix> fDev2179: I'm using a GA to train a NN :P
15:03:15 <nitrix> Sorry for overlapping the terminology a bit.
15:03:23 <fDev2179> Fitness function requiring IO, yes.
15:03:45 <fDev2179> I've done design optimization studies where I used an external analysis code to evaluate the objective function.
15:04:10 <fDev2179> Then, I have a separate code which drives the optimization.
15:04:32 <nitrix> I'm thinking the fitness function could take a lazy list of inputs as argument and be partially applied and given to the library, but it solves half the problem :/
15:04:34 <fDev2179> The analysis code writes results to a file which must be read.
15:04:50 <nitrix> fDev2179: The issue is having IO with that library in the first place.
15:05:10 <nitrix> I'm well competent with GA, no worries :)
15:05:47 <fDev2179> The way I've handled the communication is using files.  For example, I write the inputs to a file which the analysis code reads.  I'm confused about the question then.
15:07:11 <nitrix> fDev2179: The fitness function that the framework seems to work with isn't monadic.
15:07:59 <nitrix> I guess it is from ((->) r) but that wont get me anything usuable. I'd love to have a minimum support for effects of some kind.
15:08:27 <fDev2179> Ohhhh, I see.
15:08:31 <nitrix> class ObjectiveFunction f a where evalObjective :: f -> [Genome a] -> Population a
15:08:43 <nitrix> And the instances leads to nothing.
15:08:48 <fDev2179> That makes things difficult.
15:08:57 <Cale> Well, just being in *some* monad doesn't mean much -- control over which monad it is, is what you want :)
15:09:16 <nitrix> StepGA has ehm... m (StepResult (Population a))
15:09:56 <Cale> Yeah, it only extends as far as population management
15:10:17 <nitrix> But I'm not sure how I can use this. I think I'd load the dataset in this stepping function between current and next generation and partially apply the fitness function?
15:11:17 <nitrix> This way it can run the Genome agaisn't some data set. That _should_ work?
15:13:22 <Cale> I wouldn't bother with that. Just grab the code and start changing it so that the fitness function is in the same monad m.
15:16:38 <Cale> So it becomes something like  class ObjectiveFunction m f a where evalObjective :: f -> [Genome a] -> m (Population a)
15:16:51 <nitrix> Mhm.
15:17:33 <the|auriscope> hi all. I've been fooling with haskell on and off for a few months, and wanted to say "hi"
15:17:46 <kloppadop> does anyone know of a nice, clean implementation of a parser for an indentation sensitive language like haskell?
15:17:57 <c_wraith> hello, the|auriscope
15:18:07 <kloppadop> the haskell lexer and parser are a complete mindfuck
15:18:17 <fDev2179> Hi, the|auriscope.
15:19:00 <nitrix> kloppadop: Languages do get fairly complicated when they grow beyond the pet toy project phase.
15:19:16 <nitrix> kloppadop: Haskell's parser and lexers are actually very clean and well documented.
15:19:28 <the|auriscope> does anyone have opinions on books for learning Haskell?
15:19:34 <kloppadop> nitrix: lol no they arent
15:19:43 <kloppadop> they are needlessly complex and brittle af
15:19:58 <kloppadop> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Parser
15:20:42 <max3> solution to all of my problems: liftIO all the things!
15:21:18 <kloppadop> ' if we encounter an error in parsing, we try exiting an indentation context and trying again'
15:21:20 <kloppadop> kek
15:21:50 <zennist> anyone knows how to hide the imported modules in the prompt inside ghci when inside a multiline block?
15:21:55 <zennist> this has been annoying...
15:22:12 <c_wraith> ghc's parser is complicated by all the extensions it supports that add syntax. 
15:22:28 <kloppadop> zennist: :set prompt "\ESC[34mλ> \ESC[m"
15:22:50 <zennist> kloppadop: yeah but that doesn't hide the list when inside a multiline block started with :{
15:22:50 <kloppadop> c_wraith: yeah I understand that theres a lot of complexity, thats why im looking for something more minimalistic
15:22:54 <kloppadop> but with a similar layout
15:23:46 <zennist> oh got it! :set prompt2 "..."
15:23:56 <zennist> can't believe no one mentioned it in any blog!
15:24:36 <kloppadop> purescript seems to have a much cleaner lexer/parser implementation
15:26:52 <Tuplanolla> It was added fairly recently, zennist.
15:27:34 <codedmart> I renamed a file, changed it everywhere in my project but now stack errors `Failed to load interface for 'Lib.Auth'`. I have removed my `.stack-work` dir and rebuild but this error still happens.
15:27:42 <codedmart> Any ideas what I am missing here. I have never had this happen which leads me to believe it is something stupid I am overlooking since I am tired.
15:29:05 <kloppadop> codedmart: do you export the module in your .cabal file?
15:29:15 <kloppadop> and does the module name match the path?
15:29:27 <geekosaur> that sounds like you misunderstood the question tbh
15:29:51 <geekosaur> I'd probably be looking for .hi files containing the old name
15:30:37 <codedmart> @geekosaur wouldn't deleting the .stack-work dir remove those?
15:30:38 <lambdabot> Unknown command, try @list
15:32:41 <geekosaur> sometimes? iirc it's a bit more complex than that
15:32:50 <kloppadop> https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060670.html
15:32:51 <geekosaur> but you probably want someone who knows more stack internals there
15:33:05 <kloppadop> 'the complete offside rule as found in Haskell is   almost impossible to get right.'
15:33:20 <geekosaur> kloppadop, that was fixed in haskell2010
15:33:35 <kloppadop> geekosaur: what do you mean?
15:33:42 <geekosaur> although I think I should save that thread pointer for next time the discussion comes up
15:33:46 <kloppadop> geekosaur: the off-side rules were changed?
15:33:50 <geekosaur> yes
15:34:01 <kloppadop> geekosaur: is there somewhere where they are 'formally' documented?
15:34:04 <geekosaur> someone actually found a case where hugs and ghc produced different valid parses
15:34:21 <geekosaur> (valid meaning satisfied the haskell98 report)
15:34:21 <kloppadop> oh hugs, I should look at that parser
15:35:24 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17800010.3
15:35:33 <kloppadop> great, thanks geekosaur 
15:35:37 <geekosaur> formal specification of the haskell2010 layout rule
15:37:57 <geekosaur> also note that ghc does not fully follow it by default, because it enables the NondecreasingIndentation extension by default. another extension affecting it is DoAndIfThenElse.
15:39:37 <geekosaur> ...wait, did NondecreasingIndentation go away in 8.x?
15:40:17 <kloppadop> I wonder if it would be noticeably simpler only indentation layout was supported, (without curly braces), and the layout rules were more strict
15:40:27 <kloppadop> if only*
15:40:59 <geekosaur> first you have to rewire SPJ's brain :p
15:41:00 <hpc> geekosaur: what was the case that produces different valid parses?
15:41:27 <geekosaur> I don;t recall,t hat's why I want to go through the thread pointed to earlier because I couldn't find it last time I looked and I'm hoping that thread has it
15:42:57 <geekosaur> it's also possible that it was nhc98 involved instead of hugs
15:43:21 <geekosaur> except that that late someone would have had a fair amount of work to do to get that working for people to reproduce it :)
15:46:16 <dolio> I don't think it's significantly harder to support both indentation and braces than it is to support just indentation.
15:46:36 <arkasis> hello, I'm new to haskell. How can I post a formated snippet?
15:46:52 <hpc> @lpaste
15:46:53 <lambdabot> Haskell pastebin: http://lpaste.net/
15:47:49 <arkasis> Here is my code;
15:47:52 <arkasis> data Bit = True | False  newtype Byte = (Bit, Bit)  main = putStrLn "hi!"
15:48:14 <monochrom> You will have name clash because of True and False.
15:48:52 <arkasis> http://lpaste.net/353195
15:49:07 <monochrom> newtype is wrongly used.
15:49:26 <arkasis> how is the correct way?
15:49:43 <monochrom> Need a data constructor.
15:49:56 <monochrom> Or else do not use newtype.
15:50:16 <monochrom> It is ambiguous whether you intend newtype or not.
15:51:00 <arkasis> I tried type instead and worked, thanks
15:51:03 <monochrom> But read up very seriously on "data", "newtype", and "type". Choose the one you really mean.
15:51:22 <monochrom> (Do not guess from "meaningful" names.)
16:03:48 <jle`> 1;0c/b 10
16:04:45 <jle`> i wonder why my terminal emulator or ssh client throws these random characters onto the screen
16:11:39 <baasvik> is there a way to just fetch dependencies with cabal and *not* build them?
16:12:09 <ezyang> it's either cabal get or cabal fetch 
16:12:18 <baasvik> cabal install (from inside a directory with a sandbox in it) and (cabal install --dry-run) seem to have different behavior
16:12:46 <baasvik> okay let me put a shell script in the pastebin and hopefully get some guidance on what I'm doing wrong
16:19:41 <manek> hello guys! :) Is it possible to tell stack to copy-bins of dependencies? I've got a package that needs graphmod which is shipped as executable only. I want to add it to stack config and copy its executable to bin folder. Unfortunetally `-copy-bins` copies only my lockal package bin
16:22:49 <mbw> Hello everyone. Can you interface with a C routine that expects a pointer to over-aligned memory? Say it is something computationally expensive that uses vector instructions. I don't have a concrete example in mind, I'm just curious. My google-fu didn't come up with anything, either.
16:24:11 <mbw> I presume I could just interface to aligned_alloc or something, and then call the C function?
16:24:31 <ezyang> mbw: Well, if you're passing Ptrs around, you can make them however you want 
16:26:28 <geekosaur> mbw, hsc2hs allows you to specify alignment in various ways. for a Ptr, iirc it's part of the Storable instance for the target type
16:45:32 <mbw> Ok, so how I understand it, the #alignment keyword is used for computing the alignment of a given C struct, taking padding into account. However according to the documentation, the #type keyword is restricted to C's POD types. On the other hand, in the FFI example for interfacing with Gsl on the HaskellWiki, they define their own Storable class, which mandates specifying an alignment. So I guess there are 
16:45:38 <mbw> these three ways: 1. Allocate normaly, assuming natural alignment. Then send an offset pointer to C. 2. Call a C allocation function. 3. <Insert something intelligent about Storable here>. The hsc2hs documentation isn't really conclusive for me.
16:46:48 <mbw> 1. is not entirely correct, since I would need to figure out the actuall address (which is probably possible).
16:47:55 <mbw> Since I don't have _that_ much with Haskell's FFI (and hsc2hs, inline-c and ...) yet, I guess I better post-pone this and just assume it's possible.
16:48:18 <mbw> Anyway, thanks ezyang and geekosaur.
16:48:32 <mbw> *that much experience
16:48:56 <baasvik> Here's what I'm trying to do http://lpaste.net/7137326431440207872
16:49:04 <baasvik> I'm trying to fetch Haskell stack sources
16:49:19 <baasvik> and the sources for dependencies inside a cabal sandbox without building anything
16:49:55 <geekosaur> short version is you use hsc2hs when building direct FFI bindings to functions, and Storable when the FFI interface exclusively uses pointers to arrays
16:50:38 <geekosaur> you *can* do arrays via hsc2hs, but you are limited to what Foreign.Marshal.Array can do... Storable is a later and more complete interface, and gives you access to things like Storable Vectors
16:52:06 <geekosaur> so unless you're doing something very simple, you may want to focus on Storable and ignore Foreign.Marshal.Array. note that Storable also replaces hsc2hs's struct support in this case
16:52:37 <mbw> So with storable, the focus is on *exclusively*, and a function like void do_stuff(double *a, size_t n); does *not* apply?
16:53:25 <dmwit> ongy: You have a question about new-exec/new-run?
16:54:14 <dmwit> ongy: Oh, just about the existence? https://github.com/dmwit/cabal/tree/feature/new-run
16:55:04 <dmwit> ongy: And yeah, new-exec can run things you've built, but will not build them if you haven't already. new-run does
16:57:28 <dmwit> (new-exec never builds, but will happily execute any command; new-run always builds and only works for executables in your dependency tree)
16:58:00 <monochrom> So there is a new-* series of commands, new-build, new-run, etc?
16:58:11 <dmwit> yep
16:58:18 <monochrom> <joke> Is there also a new-fangle? </joke>  <duck>
16:58:23 <dmwit> =D
16:59:04 <monochrom> Actually is there a reason they are all called new-*?
16:59:25 <dmwit> Yes. They're a big breaking change to the way you use cabal.
16:59:46 <dmwit> And they're not finished/well-tested yet, so it's premature to just drop them on people for sure.
17:00:42 <dmwit> (Disclaimer: This is my outsider understanding of the current state. IANACD)
17:03:18 <dramforever> I hope this isn't off-topic, but: {Where can I find|Are there any} implementations of 'Okasakian' persistent data structures in 'mainstream' languages?
17:03:56 <dramforever> mainstream, like for example C
17:04:42 <geekosaur> mbw, the question is about how you use it from Haskell, not from C. the Haksell side interface for hsc2hs is Foreign.Marshal. the Haskell side interface for Storable is the type's Storable instance
17:06:31 <geekosaur> and, if you use Storable you can take advantage of anything that supports a Storable instance. with Foreign.Marshal you basically get whatever you write in the hsc file, and would have to reinvent much of Storable if you wanted to use it
17:16:27 <EvanR> dramforever: they are rewritten from scratch each time
17:16:40 <EvanR> in C
17:19:08 <mbw> Realistically speaking, I think the use case is probably not realistic, anyway. To have a function set up in a way that certain alignment conditions stricter than natural alignment are fulfilled, makes sense if the function is called a lot of times and doesn't do much work. Otherwise, the usual autovectorized code that jumps around between vectorized/unvectorized parts is fine. The former case is probably 
17:19:14 <mbw> not realistic, since I wouldn't want to call into C from Haskell a large number of times and I *presume* their is no portable way to inline a foreign function.
17:19:14 <dramforever> EvanR: Okay, I don't think I'll be using one, but I would be happy to see one
17:27:56 <mbw> Anyway, thanks for your help.
17:31:35 <_sras_> How can I use postgresql's hstore type with Opaleye. What are the respective Opaleye types?
17:35:30 <NextHendrix> hi, the docs for lambdabot are severely lacking, are there any better ones hiding away
17:35:35 <NextHendrix> ie not the wiki or on github
17:54:55 <posco> it seems the `-i` option is ignored with `ghc --make` mode. Is there something I am doing wrong?
17:55:08 <posco> ghc -fforce-recomp  --make -iout-hi -v -c Bar.hs -odir out-obar -hidir out-hi-bar
17:55:22 <ezyang> -i controls source include path, not his 
17:55:58 <posco> this link suggests otherwise: https://downloads.haskell.org/~ghc/5.00/docs/set/separate-compilation.html#RECOMP
17:56:15 <posco> in finding interface files it says use `-i`
17:56:21 <ezyang> you do realize those docs are for GHC 5? 
17:56:47 <posco> yeah. :) but I hoped/assumed the options would be the same...
17:56:52 <posco> let me find the latest
17:56:55 <ezyang> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/separate_compilation.html#search-path 
17:59:12 <posco> I'm not immediately finding an option to include a directory in the interface search
18:00:37 <posco> it seems like `-i` might be right, it is just that make mode expects the full source to be there
18:00:45 <posco> without `--make` it seems to work
18:01:26 <ezyang> I think it's -hidir 
18:01:51 <posco> I thought that was for output
18:03:57 <posco> just to be clear what I'm really trying to do: write bazel rules for haskell.
18:05:56 <posco> if I don't use `--make` I need to pass the files in the correct dependency order.
18:06:19 <MarcelineVQ> posco: there is a difference with --make https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/separate_compilation.html#search-path
18:06:21 <posco> if I use `--make` I can't see the interface files from a different compilation.
18:06:54 <MarcelineVQ> I've never used the option so I've nothing more useful to add :X
18:07:07 <posco> so, it looks like --make just can't be used in this way.
18:07:22 <posco> MarcelineVQ: thanks for pointing that out, though
19:00:39 <clinton> Is there a way to partially apply type families that aren't constraints?
19:13:25 <geekosaur> clinton, I don't think you can do partial application at all at the type level
19:13:54 <geekosaur> you can defer checking, but there are no type lambdas and few and limited hacks to simulate them
19:40:25 <clinton> geekosaur: I've written it up on stackoverflow now http://stackoverflow.com/questions/42591536/partially-applied-type-families
19:40:47 <clinton> geekosaur: Basically I want to do with ordinary type families what I can do with constrained ones
19:55:55 <Xnuk> @hoogle (Monad m1, Monad m2) => m1 (m2 x) -> (x -> m1 (m2 y)) -> m1 (m2 y)
19:55:59 <lambdabot> Data.Functor.Syntax (<.*$>) :: Functor f0 => (c -> d) -> f0 (a -> b -> c) -> f0 (a -> b -> d)
19:55:59 <lambdabot> Data.Functor.Syntax (<*.$>) :: Functor f0 => (a -> c -> d) -> f0 (b -> c) -> f0 (a -> b -> d)
19:55:59 <lambdabot> Data.Functor.Syntax (<~~~$>) :: Functor f0 => (a -> b -> c -> d -> e) -> f0 d -> f0 (a -> b -> c -> e)
20:04:39 <arkasis> I have a question; I don't understand the error messages -> http://lpaste.net/353201
20:06:38 <dmj`> arkasis: usage of map here is suspect
20:06:41 <dmj`> map a (\c i ->
20:06:46 <dmj`> on line 20
20:07:43 <arkasis> the problem is the syntax? (or semantics?
20:09:53 <dmj`> :t map
20:09:55 <lambdabot> (a -> b) -> [a] -> [b]
20:10:21 <dmj`> the type of addition you have is :: [Bit] -> [Bit] -> [Bit]
20:10:49 <dmj`> which means the type of the a parameter is also [Bit], which is being passed to the first argument of map
20:11:09 <dmj`> map is expecting (a -> b) and you’re providing [Bit]
20:11:39 <dmj`> which is the first error
20:11:51 <doyougnu> roughly speaking, map expects a function and a list. The way you've written it "a" is the function you pass to map, so you get a type error when you try to pass the lambda function "(\c i -> ...)"
20:12:14 <arkasis> hm... I'm going to try again
20:12:17 <arkasis> thanks
20:12:21 <doyougnu> because that is not a list
20:13:02 <dmj`> arkasis is your assumption that a should be a list and the lambda the index and value?
20:13:50 <arkasis> yes, because I come from javascript
20:13:51 <dmj`> and once addition does type check, that map function will never be evaluated since it always returns [True]
20:14:36 <arkasis> ok, I'm have to check the type of map
20:14:40 <dmj`> arkasis: ok, well that’s fine. Haskell does have some functions that allow one to traverse over a structure with both value and index
20:16:12 <dmj`> I’ll let you experiment though
20:16:39 <doyougnu> ^^ best way to learn
20:16:50 <arkasis> I prefer to know the name of that function (?
20:19:01 <arkasis> nvm, I think I can make that function and learn haskell on the way
20:21:01 <dmj`> arkasis: since haskell is lazy, it’s often times nice to generate a parallel list that corresponds to the indexes, and then zip them together
20:21:53 <dmj`> :t \f xs -> map f $ zip xs [0..]
20:21:55 <lambdabot> (Num b1, Enum b1) => ((a, b1) -> b) -> [a] -> [b]
20:23:21 <arkasis> seems a bit complicated for me at the moment
20:24:39 <dmj`> arkasis: then we can uncurry f to get the function you were looking for
20:24:45 <dmj`> :t \f xs -> map (uncurry f) $ zip xs [0..]
20:24:47 <lambdabot> (Num b1, Enum b1) => (a -> b1 -> b) -> [a] -> [b]
20:25:32 <arkasis> @____@
20:25:32 <lambdabot> Unknown command, try @list
20:25:36 <dmj`> where b1 is the type of your index, ‘a’ is the value, and ‘b’ is the type of what you’re returning
20:25:58 <Sornaensis> @list
20:25:58 <lambdabot> What module?  Try @listmodules for some ideas.
20:26:26 <Welkin> !list
20:26:32 <Welkin> show me your fserves!
20:30:04 <Wizek> hi, Anyone knows of a function `:: (Char -> IO String) -> Handle -> IO Handle` that would allow to map over a readable stream?
20:33:47 <drostie> Wizek: you want to run a program on every character read from a handle?
20:34:01 <Wizek> I'm launching a child-process, and I'd like to redirect its stdout to the main process'es stdout in a way that distinguishes both streams, e.g. indent the children's output. I imagine maybe using it something like this: `f (\case '\n' -> return "  \n"; a -> return a) childHandle >>= dupTo stdout`
20:34:03 <drostie> Wizek: and then ignore the strings that those programs produce?
20:35:38 <pikajude> wouldn't it be "\n   "
20:35:49 <Wizek> pikajude, yes, good catch
20:35:54 <pikajude> i tried
20:37:40 <Wizek> drostie, I don't think I'd want to run a program on every character, no. In fact, in my particular usecase `(Char -> String) -> Handle -> IO Handle` may be sufficient too.
20:38:50 <Wizek> the reason I thought to have the function parameter monadic is to allow handling stateful decisions too, e.g. change all 'a' to 'b' only if it was preceeded by 'c'
20:39:27 <Wizek> But that's a more general usecase I don't directly care about right now.
20:42:29 <Wizek> Also, I thought to write this function myself, the thing that's keeping me is it doesn't seem to be easy to create a mock Handle to simulate for tests. But maybe I'll more along those lines
20:59:21 <drostie> Wizek: I can completely understand how to make some pipes and spawn a new thread which reads from the one pipe and writes some transformed text to the other pipe. Looking over the normal IO libs I am not sure I see anything better built-in to Haskell unfortunately...
21:27:58 <Wizek> drostie, How do you do that in Haskell?
22:03:36 <ongy> dmwit: ah thanks. So new-run is a thing sometime soon(?) and nice work :)
22:04:03 <ongy> the current state of crypo-libraries in haskell confuses me
22:27:41 <drostie_> Wizek: import the System.Posix.IO.ByteString module that you're looking at, and also Control.Concurrent, start off with `do { (in_R, in_W) <- createPipe; (out_R, out_W) <- createPipe; thread <- forkIO (runConnector in_R out_W); return (thread, (out_R, in_W)) }`, fill in `runConnector` with something that does a `threadWaitRead` on the in_R and a `threadWaitWrite` on the out_W combined with some read, some transform, and some write, and recursing back on 
22:27:41 <drostie_> the function to loop over it again.
22:28:12 <Squarism> Theres no alternative to Data.Time? It feels very clumsy / unintuitive. 
22:32:55 <dmj`> Squarism: this is a good article on time, https://two-wrongs.com/haskell-time-library-tutorial
22:34:19 <Squarism> ive read that
22:36:55 <Squarism> but if i compare it to java's joda time it feels a bit primitive. I would like to express things like (minusMonths 3 $ plusHours 2 d1) `isWithin` $ periodFrom d2 $ weeks 2
22:37:15 <Squarism> instead they do alot of millis/picoseconds
22:40:56 <Squarism> dmj`, thank you anyhow! =D
22:41:45 <dmj`> Squarism: np
22:41:48 <Wizek> Squarism, such an API may be nice, but I don't believe I've seen it implemented in any package
22:41:54 <Wizek> yet
22:43:11 <Wizek> Squarism, you may comb through all 28 packages tagged with Time on hackage to get a somewhat definitive answer to you question: http://hackage.haskell.org/packages/#cat:Time
22:44:24 <Squarism> Wizek, ok - ill look into that
22:50:05 <cheater> hi
22:50:28 <Wizek> drostie-m, Thanks, I might give that a try! (for now I've side-stepped the problem)
22:50:55 <drostie-m> Wizek: I am back for a sec after the last thing I said before...
22:51:13 <drostie-m> Cool.
22:52:06 <drostie-m> Also the Pipes library looked like it might make this stuff easier.
22:52:55 <Wizek> drostie-m, Also this one: https://hackage.haskell.org/package/io-streams
22:53:09 <Wizek> that I've found along my searches
