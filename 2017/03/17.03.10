00:03:46 <ongy> Axman6: I hope you don't mind if I rip off your website a bit, when I decide to blog something at any point. I like the design
02:17:01 <Athas> Has anyone studied the performance impact of using deepseq?
02:21:12 <srhb> Athas: What do you mean? Deepseqing what and when?
02:22:17 <Athas> srhb: deepseq'ing involves traversing an entire object graph, right?  I see it frequently used in (task-)parallel Haskell code, to ensure that the computation is actually done in worker threads before the result is passed back to a main thread.
02:22:38 <Athas> I'm curious whether the traversal in deepseq can have a significant negative performance impact.
02:22:47 <Athas> Looks to me like it can easily evict the entire cache.
02:29:30 <merijn> Athas: It can also do a bunch of unnecessary work, so the obvious answer is "yes" ;)
02:31:15 <Athas> merijn: okay, but has anyone studied it?  Things like monad-par seem to be quite happy about implicitly deepseq'ing anything you put in a future, which may have an impact in some cases.
02:31:25 <Athas> There's been a lot of work on Haskell parallelism and performance, after all.
02:31:47 <merijn> Honestly, if evicting caching is something you worry about, I don't think Haskell is an ideal language to begin with
02:31:54 <merijn> laziness is pretty crappy for your caches
02:34:07 <Athas> Well, you could use laziness for control flow.
02:34:29 <Athas> I'm mostly asking because I don't know the answer, but lots of smart people have been working on it for years.
02:34:41 <merijn> Athas: I don't think anyone knows, tbh
02:35:32 <Athas> "High-performance", "functional", or "programming", pick two?
02:35:36 <merijn> Athas: There's a guy at Twente working on designing a CPU for lazy languages, so I know he's thought about caches and stuff (mostly, he said he decided not to use caches in the traditional sense), but I'm not sure if he has a write up on that
02:35:55 <Athas> That sounds cool!  Lazy and pure, or impure?
02:36:18 <merijn> Athas: Purity is rather irrelevant at the chip level
02:36:36 <Athas> Right, but you could call the total absence of cache coherence "purity".
02:36:40 <merijn> At the CPU level you're thinking about thunk updating, indirection, etc.
02:40:10 <Boomerang> merijn: is that CPU for lazy languages being written in CLaSH?
02:40:33 <merijn> Boomerang: He's in the same group as the CLaSH people
02:41:17 <Boomerang> Alright! Is it possible to read about this CPU somewhere online?
02:41:22 <merijn> Boomerang: But since the project I was collaborating on ended a while back I only see them incidentally, so I'm a bit out of date
02:42:06 <Boomerang> It sounds very interesting, I would love to find out more about it
02:42:07 <merijn> Boomerang: It doesn't exist yet, even in design, afaik :p Now would only be like the 2nd year of his phd?
02:42:29 <Boomerang> Fair enough :)
02:48:49 <merijn> Boomerang: I expect I'll run into them later this month, so I'll ask them about it
03:02:24 <_sras_> Is there a type class in haskell that can be used to describe conversions between related types?
03:02:55 <Athas> _sras_: not a standard one, no.
03:06:25 <Boomerang> _sras_: You could look at how opaleye does it to convert between Haskell type and SQL specific types, the type class used it called Default. I don't understand it fully but it seems to be what you want.
03:07:15 <_sras_> Boomerang: 'Default Constant' instances describes conversion in one direction...
03:07:23 <Athas> And be prepared for ambiguity errors...
03:10:46 <Boomerang> _sras_: Ah yes, I am not aware of a standard way to do this, you could just create your own type class then
03:14:28 <Boomerang> _sras_: Again I don't really know this package but would the Bijection type class from invertible be useful? It's a bidirectional arrow. It seems appropriate to convert a type from and to another one
03:15:04 <_sras_> Boomerang: Will look into it. I am not familiar with it either.
03:20:03 <otulp> Yikes. Just saw the (=<<->>=) operator in Data.Invertible.Monad. Its description: "Crazy operator form of bind." :)
03:30:58 <cocreature> that definitely qualifies as crazy
03:32:46 <Boomerang> At least it reuses well known infix symbols, but yeah that's a crazy operator
03:38:31 <Athas> I wonder what's the largest operator name on Hackage.
03:39:22 <otulp> Surely there is something hideous somewhere in the Acme hierarchy.
03:45:39 <monadicDuck> dw
03:47:41 <Jenaf> good morning!
03:47:49 <Taneb> Athas, https://gist.github.com/ndmitchell/aa1e0944379a7429cedb#file-gistfile1-txt
03:48:01 <Jenaf> Yesterday I was told to better replace if then else constructs with case matchings
03:48:20 <Jenaf> also i have some unreachable code in a fromMaybe wich is guaranteed not to be nothing
03:48:29 <Jenaf> http://lpaste.net/353382
03:48:38 <Jenaf> any tipps how to write that more cleanly?
03:49:30 <Athas> Taneb: thanks; some good ones there!
03:49:46 <otulp> I see functor-infix is doing quite well, lengthwise.
03:50:38 <Jenaf> I would love to get rid of this : fromMaybe (error "unreachable")
03:51:14 <Taneb> Jenaf, is fromJust an option?
03:51:25 <Taneb> > fromJust (Just "hello")
03:51:28 <lambdabot>  "hello"
03:51:40 <Jenaf> > fromJust (Nothing)
03:51:44 <lambdabot>  *Exception: Maybe.fromJust: Nothing
03:51:44 <ongy> Jenaf: if it's not reachable why is the argument of type (Maybe Int) ?
03:52:00 <ongy> ohh, I see
03:52:03 <Athas> Jenaf: 'sequence mayList' will give you a 'Maybe [Int]' back.
03:52:10 <Athas> You can pattern-match on that, instead of the branch.
03:52:44 <Taneb> > [x | Just x <- [Just 1, Nothing, Just 2, Just 3, Nothing]
03:52:47 <lambdabot>  <hint>:1:58: error:
03:52:47 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
03:52:48 <Taneb> > [x | Just x <- [Just 1, Nothing, Just 2, Just 3, Nothing]]
03:52:50 <ongy> that and I think you can use the Monad and MonadFail instances of Maybe here
03:52:51 <lambdabot>  [1,2,3]
03:53:40 <Jenaf> ahh
03:54:03 <Athas> > sequence [Just 1, Just 2, Just 3]
03:54:07 <lambdabot>  Just [1,2,3]
03:54:08 <Athas> > sequence [Just 1, Just 2, Just 3, Nothing]
03:54:12 <lambdabot>  Nothing
03:54:15 <Jenaf> I stay with maybe because i get the values from a sequence findIndexL
03:54:43 <ongy> yea, I wasn't properly reading at first, I thought it's Maybe [Int] which was weird, but [Maybe Int] is a bit different
03:55:00 <Boomerang> > catMaybes [Just 1, Nothing, Just 2]
03:55:03 <lambdabot>  [1,2]
03:55:11 <Jenaf> in the bigger context Nothing means that my propblem is unsolvable, while values indicated that the program can go on solving
03:55:47 <Jenaf> so I will propably have a case X of Nothing -> Nothing //of Just something -> foo(something) cascade 
03:56:09 <Jenaf> (unsolvability is NOT an error, it is an expected case)
03:58:42 <lpaste_> ongy annotated “How to refactor” with “How to refactor (annotation)” at http://lpaste.net/353382#a353383
03:59:54 <ahri> i'm writing a bomberman clone and i'm thinking about how to best model the exploding of bombs and resulting possible flame, which can in turn destroy powerups and walls. i was going to fmap over my [Bomb] but then i need to remove some of [Wall] and [PowerUp] in some cases, so: Bomb -> [Wall] -> [PowerUp] -> (Bomb, [Wall], [PowerUp], [Flame]) ..... is this sensible? i'm learning Haskell and feel like that 
03:59:58 <ongy> Jenaf: ^ Use the monad instance. It's nice
04:00:00 <ahri> looks clunky, but have no idea how i might otherwise model it
04:00:41 <ahri> hm, actually i have to return Maybe Bomb, as it may or may not explode
04:02:02 <Rodenbach> I have a function, which works nicely to create one random Bar, with the signature:     foo :: (PrimMonad m) => Config -> Gen (PrimState m) -> m Bar
04:02:07 <Rodenbach> I create a rng via    rng <- createSystemRandom
04:02:10 <Jenaf> thats what you get when you forget your luggage at the airport: Maybe Bomb
04:02:13 <Rodenbach> How can I now create a list [Bar] with 10 random Bars?
04:02:21 <SexHendrix> Jenaf: lol
04:02:43 <Jenaf> inb4 Just Nothing
04:03:07 <SexHendrix> Bomb disposal teams were in JFK this morning after a suspicious package was discovered. The initial fear was Maybe Bomb but it was later confirmed to be Nothing
04:04:01 <ahri> hehe, although in my case if it's Nothing, it just blew up so is no longer a Bomb ;)
04:05:26 <SexHendrix> unsafeMaybe
04:05:49 <SexHendrix> @ghc
04:05:50 <lambdabot> Try -fglasgow-exts for GHC's newtype-deriving extension
04:08:08 <ahri> so am i to assume that my suggested solution seems reasonably idiomatic for Haskellers? that's all i'm after really
04:10:33 <Athas> ahri: I find something to be strange about your representation.  What does [Wall] and what does [PowerUp] code?
04:10:38 <Athas> Is a Wall a coordinate?
04:11:31 <ahri> yeah, they both have a coordinate. powerup might be various types of powerup (more flame, more bombs, ... maybe other stuff if i get that far)
04:12:07 <Boomerang> Rodenbach: Is that the random from sfmt? You could do something along the line of: traverse makeBar $ replicateM 10 createSystemRandom
04:12:25 <Athas> ahri: can there be a powerup and a wall in the same location simultaneously?
04:14:07 <ahri> Athas: no, when a wall is destroyed it has a random chance to leave a powerup in its place
04:15:06 <ahri> it concerns me that my current model allows both to exist since they just have coordinates attached
04:15:12 <Athas> ahri: in your representation, what happens if the [Wall] and [PowerUp] lists have conflicting entries?
04:15:15 <Athas> Yeah, exactly.
04:15:20 <Athas> That is a design smell.
04:15:37 <Athas> Instead, I'd recommend the game board as a 2D-array of Things, where a Thing is then a bomb, a powerup, or a wall.
04:15:46 <Athas> (Or some other encoding - the point is that it can only encode valid states.)
04:15:56 <Athas> The only tricky thing is the player, since there can only be one of those, right?
04:17:09 <Boomerang> Rodenbach: Actually you'll need to use bind with the code I gave you: traverse makeBar =<< replicateM 10 createSystemRandom
04:17:33 <ahri> Athas: there are a few wrinkles like that: multiple players can be in one place. a player cannot move onto a square with a bomb on it, however when a player drops a bomb it is on the same square as whatever players currently reside on there
04:17:40 <Boomerang> Where makeBar :: GenIO -> IO Bar
04:18:03 <Athas> ahri: right, so maybe players should not be part of the game world as such, but stored separately.
04:18:13 <Athas> But for everything else, the 2D array approach makes more sense.
04:18:41 <Athas> It's not always about a design that eliminates *all* errors, just as many as practical.
04:19:05 <ahri> Athas: ok, i guess flame should stay apart too, as it will cover a wall, and then when it's cleaned up i will decide whether or not to leave a powerup in its place
04:19:43 <Athas> You could have an WallWithFlame cell state.
04:20:15 <ahri> Athas: and a SpaceWithFlame?
04:20:43 <ahri> i'd end up needing a PowerupWithFlame, too, actually, as they can be destroyed
04:21:59 <Athas> ahri: maybe all cells should just have an onFire field.
04:22:26 <Athas> But generally, don't be afraid of having many constructors.  It just means you are being explicit about your states.
04:22:59 <merijn> Athas: Well, too many might ruin your compile time :p
04:23:21 <Athas> merijn: using Haskell might ruin your compile time.
04:23:29 <merijn> Athas: Not as much as C++!
04:23:31 <Athas> That battle's already lost!
04:23:59 <Athas> Perhaps!  Although 'make' seems to do a better job of parallelisation than GHC does.
04:24:39 <merijn> Athas: My magic bash alias for superfast compilation: alias make='make -j32' :p
04:33:33 <ongy> Athas: what? when I compile with ghc (well cabal) I have 100% usage on all cores
04:33:44 <ongy> I dont' think that much more parallelisation is possible
04:33:52 <merijn> ongy: How many cores do you have? :p
04:34:07 <ongy> on this? 4+TH
04:34:14 <ongy> but I have done it with 24 cores before
04:34:18 <merijn> ongy: Right, that's pretty easy to saturate
04:34:23 <ongy> HT not TH
04:34:27 <Athas> ongy: how much faster is it?
04:34:35 <ongy> Athas: then what? single core?
04:34:38 <Athas> Yeah.
04:35:03 <ongy> never tested, I'd asume roughly 6 to 7 times.
04:35:47 <ongy> merijn: aren't you working on a cluster? shouldn't that be something like -j8192? :)
04:35:51 <Athas> My experience is that it doesn't scale very well.
04:36:14 <merijn> ongy: Jobs don't magically run on more than one machine
04:36:25 <merijn> And I don't think make can handle multiple machines anyway
04:36:30 <ongy> if you have single *huge* files, it doesn't. But for many small-ish files it's fine
04:36:51 <ongy> well, that's what we can use distcc for. But I don't know hoe make -j# and distcc interact
04:37:35 <SexHendrix> can lambdabot do IO
04:37:48 <cocreature> SexHendrix: no
04:38:23 <ongy> > putStrLn "It has a show instance"
04:38:27 <lambdabot>  <IO ()>
04:40:42 <Reisen> Is there a recommended way of emulating anonymous union / sum types in Haskell?
04:40:54 <ongy> hm Athas you are right. I was under the impression it parallelises better. But installing lens in a sandbox (with cabal) it's 1-3 cores most of the time. does 'cabal build' do something different?
04:42:21 <Athas> ongy: yes, building multiple *packages* works quite well.
04:42:27 <Athas> I think it just launches several GHC processes.
04:42:39 <Athas> It's compiling a single multi-module package that doesn't scale much.
04:43:21 <ongy> Athas: cabal build in the lens package multithreads properly
04:43:32 <ski> @help run
04:43:32 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
04:43:33 <ongy> though it doesn't saturate all cores all of time either
04:44:24 <Athas> I think GHC has some sequential bottlenecks.
04:44:30 <Athas> Or shared critical regions.
04:44:33 <Athas> Maybe the FastString stuff.
04:44:43 <ongy> which is probably more of a problem with the dependencie graph of the modules in it. For my own, which has very few inter-dependencies it's all cores all the time
04:46:26 <Athas> It doesn't matter how much you can utilise your cores.  That's just heat.  Only the wall-clock time matters.
04:46:45 <Athas> You can get great utilisation by spinning on a lock.
04:47:16 <ongy> it's an indicator, provided things don't spin on locks
04:48:15 <Athas> Or the cores trash each others caches.
04:53:50 <Jenaf> Yay my Code works as intended so far ^.^
04:58:55 <michalrus> Hey, is there traverseM in Haskell? Like in https://git.io/vywEQ i.e. traverse+join.
05:00:02 <michalrus> Or rather https://git.io/vywuJ
05:01:26 <teto> how to disambuguate instances: I have "The type variable ‘a0’ is ambiguous" ; full error here http://paste.ubuntu.com/24151500/
05:02:26 <reactormonk> !hoogle (Monad f, Applicative g) => f a -> (a -> g f b) -> g f b
05:03:24 <reactormonk> michalrus, http://hayoo.fh-wedel.de/?query=%28Monad+f%2C+Applicative+g%29+%3D%3E+f+a+-%3E+%28a+-%3E+g+f+b%29+-%3E+g+f+b
05:04:23 <michalrus> So it’s useful in Scala but not in Haskell? (:
05:04:58 <reactormonk> Implement it, can't be too hard.
05:07:05 <ongy> :t traverse 
05:07:07 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
05:07:20 <lally> Hi, I've got a lens question
05:08:16 <ongy> :t join . traverse
05:08:20 <lambdabot> Traversable t => (a -> t a -> b) -> t a -> t b
05:09:31 <lally> I've got a list of a sum type, and want to get the last one that has a value for a given lens
05:09:51 <lally> Is there something smaller than last $ catMaybes $ map (preview myLens) list ?
05:10:21 <Gurkenglas_> lastOf (traverse . myLens)
05:11:17 <lally> Nice! Thanks
05:11:45 <Gurkenglas_> Though it's more of a traversal than a lens if it only matches sometimes
05:14:20 <Gurkenglas> Hmm maybe lambdabot should get a module that defines undefinedLens :: Lens s t a b, undefinedTraversal :: Traversal s t a b, undefinedLens' :: Lens' s a, and so on, just so :t demonstrations don't explode into high-end typeclassery
05:15:07 <ski> @let undefinedLens :: Lens s t a b; undefinedLens = undefined; undefinedTraversal :: Traversal s t a b, undefinedLens'  :: Lens' s a
05:15:07 <lambdabot>  Parse failed: Parse error: ,
05:15:38 <ski> @let undefinedLens :: Lens s t a b; undefinedLens = undefined; undefinedTraversal :: Traversal s t a b; undefinedTraversal = undefined; undefinedLens' :: Lens' s a; undefinedLens' = undefined
05:15:41 <lambdabot>  .L.hs:167:1: error:
05:15:41 <lambdabot>      Duplicate type signatures for ‘undefinedLens’
05:15:41 <lambdabot>      at .L.hs:158:1-13
05:15:54 <ski> well
05:16:34 <Gurkenglas> Ya but that's gonna disappear after every @undefine. Though I guess I can query those to lambdabot when I need them...
05:16:37 <Cale> :t undefinedLens
05:16:40 <lambdabot> error: Variable not in scope: undefinedLens
05:16:40 <ongy> :t undefinedLens
05:16:43 <lambdabot> error: Variable not in scope: undefinedLens
05:16:57 <Cale> What would the purpose of those be?
05:17:11 <Gurkenglas> case in point, just did @undefine right after he said that in query to test whether they're actually in L.hs
05:18:38 <Gurkenglas> :t lastOf (traverse . undefinedTraversal) -- So you can say this instead of:
05:18:40 <lambdabot> Traversable t => t s -> Maybe b
05:18:44 <Gurkenglas> :t lastOf (traverse . ?f)
05:18:46 <lambdabot> (?f::(a -> Const (Rightmost a) a) -> a1 -> Const (Rightmost a) a1, Traversable t) => t a1 -> Maybe a
05:19:45 <Cale> Then again, I'm not sure  "Traversable t => t s -> Maybe b"  is much more comprehensible
05:20:21 <Cale> (though I suppose it's perhaps fine if you know the type variables used in undefinedTraversal)
05:20:26 <Gurkenglas> Yeah, not sure why I expected something to produce a reference to the connection between s and a there
05:22:47 <Gurkenglas> What's a good way to say this, for example something that produces (?f::Traversal s t a b, Traversable t1) => t1 s -> Maybe b
05:24:50 <drdo> I want to print data similarly to the derived Show instances but with full indentation (in a sexp-like fashion). Is there something for this?
05:26:02 <Cale> drdo: perhaps http://hackage.haskell.org/package/groom
05:26:51 <Cale> http://hackage.haskell.org/package/groom-0.1.2/docs/src/Text-Groom.html#groom -- as you can see here, it's a really simple application of haskell-src-exts
05:27:08 <Cale> So you could also just use haskell-src-exts directly
05:27:09 <lally> Is there a better way to learn lenses than th FPComplete tutorial + a lot of mucking around in ghci?
05:27:57 <drdo> Cale: I guess I could try it, but from the very first example on the page, it doesn't look like it's what I want
05:28:41 <Cale> lally: Perhaps start with some lens library which isn't 'lens'. The main lens library is great, but it's got a lot of stuff that is simply irrelevant when you're trying to learn the most important bits.
05:28:52 <drdo> Maybe there's a prettyPrint with this option
05:28:59 <drdo> I guess I'll check haskell-src-exts
05:29:29 <lally> n.m. just saw the FAQ off the lens package.  I'll hunt through there first.
05:30:23 <bennofs> drdo: try pretty-show
05:30:28 <bennofs> @hackage pretty-show
05:30:29 <lambdabot> http://hackage.haskell.org/package/pretty-show
05:31:54 <Cale> hmm, I was thinking of lens-family, but it seems to have become oddly abstracted as well now too.
05:33:54 <Cale> lally: I guess the real answer is "be around back when lenses were being invented for the first time and everything was much simpler" ;)
05:34:27 <bennofs> Cale: lens-family-core?
05:35:15 <Cale> Well, even that has the weird FoldLike shenanigans in it
05:36:05 <Cale> Is there anything which *just* does van Laarhoven lenses, without abstracting over various sorts of getters and setters and traversals and whatnot?
05:37:27 <bennofs> Cale: microlens doesn't look too bad
05:38:42 <Cale> It still does the ASetter / Getting stuff, but yeah, it's closer to what I'd want in order to teach someone about lenses the first time.
05:40:10 <Cale> I'd also kill off the infix operator shenanigans, but that's just personal preference ;)
05:40:48 <drdo> Ah, screw it, I'll just roll my own printer
05:41:06 <drdo> These things want to do fancy choices and all I want is simple consistent indentation
05:49:04 <cris_> hi , i write a small module to supplement postgresql-simple , it is to let larger size tuple to use with postgresql-simple, https://github.com/szehk/Haskell-Carbonara-Library/blob/master/src/Database/Carbonara/PostgreSQL.hs  
05:50:13 <cris_> i myself need to upload to postgres database with tuple size large than 40 , so i need to write it myself , do you think this will be useful to other haskeller as well?
05:50:29 <hexagoxel> drdo: so you want something like the last example in the readme of http://hackage.haskell.org/package/GenericPretty
05:50:30 <teto> anyone could help me disambiguate " The type variable ‘a0’ is ambiguous" in https://github.com/teto/vim-config/blob/master/test.hs (just runhaskell test.hs), it's my first haskell program and I don't think setting the returned value might disambugate thing (please ^^)
05:51:14 <merijn> teto: What's the full error?
05:51:38 <teto> merijn: full error here http://paste.ubuntu.com/24151500/
05:52:33 <teto> (btw I tried cabal update to get cassava 0.4.5, but it stays with 0.4.4)
05:52:41 <merijn> teto: You never use part of the result, so GHC can't infer what type you're wanting
05:53:41 <teto> merijn: I see thanks got it
06:04:30 <niko> .14
06:18:23 <matchwood> Hi all, I've tried asking this haskell-stack but nobody seems around so thought I'd give it a go here...
06:18:23 <matchwood> The question is basically about configuring stack for ghcjs
06:18:23 <matchwood> http://stackoverflow.com/questions/42720347/how-to-configure-stack-for-most-recent-ghcjs-lts-build
06:18:29 <matchwood> Any thoughts greatly appreciated!
06:23:03 <shiona> Does anyone know of a haskell-diagrams (or similar) web repl? I'm sure I've used something like that in the past, but now I cannot find such a thing.
06:30:48 <Jenaf> anything wrong with those two lines?
06:30:49 <Jenaf> http://lpaste.net/353390
06:31:19 <Jenaf> (except my fetish for parans)
06:39:28 <Cale> Jenaf: Well, I would add an import Data.Sequence (Seq) to the top of the file so as to avoid needing to write Seq.Seq
06:39:37 <Cale> also you *really* don't need parens around single tokens
06:39:54 <Jenaf> um, I did import Data.Sequence as Seq
06:39:54 <Cale> (Bool) is always going to be the same thing as writing Bool
06:40:01 <Jenaf> I was beeing scared of namespace collisions
06:40:04 <Cale> You should do:
06:40:10 <Cale> import qualified Data.Sequence as Seq
06:40:15 <Cale> import Data.Sequence (Seq)
06:40:17 <Cale> like that
06:40:49 <Jenaf> also I found another error
06:40:59 <Cale> The import qualified will make sure you need to use an explicit "Seq." qualifier to refer to things from that module, and then the second import removes that restriction for the type itself.
06:41:35 <Jenaf> yeah
06:41:44 <Cale> Another thing you can do is to remove the lambda and pull that argument over to the other side of the = sign
06:41:57 <Cale> filterHelper numList bools = toList ...
06:42:58 <Jenaf> yeah
06:43:45 <Jenaf> but I think I have my main reduction step for sudoku solving done. ^.^
06:43:59 <Jenaf> 140 lines of haskell feel a bit much thou
06:44:12 <Cale> I'm also not certain that it's actually better to be using Seq.zip rather than doing the toLists sooner
06:44:21 <Cale> but that's pretty minor
06:44:34 <Jenaf> yeah thats really quite minor ^. 
06:53:32 <kuribas> You may get better fusion with lists.
06:54:18 <kuribas> Does that typecheck?
06:55:42 <kuribas> wouldn't it return [(Int, Bool)]?
07:01:58 <Denommus> hello
07:02:39 <kuribas> Jenaf: confirmed by ghci
07:02:57 <kuribas> hi
07:04:03 <Denommus> do you guys use any package for gherkin specifications?
07:04:32 <Denommus> it's essential to us to make specifications in a human-readable language
07:05:11 <Jenaf> kuribase: yeah that was the error i was talking about earlier
07:08:24 <unclechu> hey guys, i'm trying to get coverage info from Stack, i'm trying to build my app by command `stack build --coverage` but getting this error at the end: `No tix files found in /--myapppath--/.stack-work/install/x86_64-linux/lts-6.30/7.10.3/hpc/, so not generating a unified coverage report.`
07:08:36 <unclechu> what should i do?
07:32:49 <nitrix> unclechu: I think you're supposed to compile with -fhpc to get .tix files.
07:33:37 <unclechu> nitrix: how should i do it?
07:33:55 <nitrix> I think you compile your executable with -fhpc, then run the executable, the runtime should generate a .tix file, which you can then generate reports from.
07:35:36 <unclechu> nitrix: how i can compile my executable with `-fhpc` flag? 
07:36:16 <unclechu> `stack build --help` doesn't show any available fhpc flag
07:36:40 <nitrix> The ghc-options section of your cabal file is possibly the easiest way.
07:38:19 <nitrix> stack build --ghc-options=-fhpc ?
07:38:35 <nitrix> Does stack lets you do that?
07:43:26 <unclechu> nitrix: thanks, now it's working, but coverage value is defenetely not right
07:43:34 <unclechu> or i misunderstand something
07:44:56 <unclechu> here it is: http://pastebin.com/H49Lyyg2 but my tests cover very small percent of the `library`
07:46:39 <unclechu> i'm looking at report right now and it shows only modules i imported in tests
07:47:50 <unclechu> maybe it's correct, but i prefer to show there everything from `exposed-modules`
07:53:09 <Jinixt> a design question: a Game has Players which have Cards; a Card can have wildly different effects, so right now it has a function with the type "State Game" to perform these effects. it feels like i'm giving too much 'power' to the cards since they can do anything they want with the Game. is there a better idiomatic way?
07:53:53 <Jinixt> i've toyed with the idea of a simple DSL for describing the effects, but i'm looking for other alternatives as well
07:54:37 <lyxia> I was about to suggest enumerating the effects in an ADT but that's basically what you just said.
07:55:24 <merijn> Jinixt: Difficult trade-off
07:57:23 <Jinixt> agreed
07:58:22 <Jinixt> it feels like it would be nice to be able to enumerate what sort of "permissions" a Card is asking for, if you will
07:58:53 <Jinixt> "why is this card asking for delete permissions?"
07:58:54 <teto> is it possible to embed an if/else (or case) in a lambda ?
07:59:41 <cocreature> teto: sure, just use it like anywhere else
08:00:22 <merijn> Jinixt: The "State Game" approach gives you maximum flexibility, but it's harder to restrict things
08:00:36 <Boomerang> teto: for example (\x -> case x of Just a -> True; Nothing -> False), you can even use the LambdaCase extension to make it shorter to write
08:00:49 <merijn> Jinixt: Enumerating it eliminates that, but becomes more verbose/hassle-like if you wanna add new behaviour
08:02:08 <Jinixt> i can imagine there's only a relatively limited set of things you'd want to do anyways
08:02:12 <teto> thanks
08:02:57 <Jinixt> the only thing missing is that if you have branching you can't see -all- possible effects easily, but perhaps that's a pipe dream
08:03:06 <Jinixt> or would require manually stating that first, which is also a hassle
08:06:43 <padre_angolano> I want to start learning Yesod. The homepage http://www.yesodweb.com/ makes reference to the first edition of the O'Reilly book (2012), whereas the 2-nd edition (2015) is already available. Is there a specific reason why the yesod site recommends the outdated edition?
08:07:36 <padre_angolano> Or maybe the yesod website itself was not updated since 2012?..
08:08:10 <Clint> padre_angolano: probably nobody noticed the discrepancy
08:08:29 <Reisen> So, if I had Either (Either A B) C, and I want to serialize the value contained with aeson (Just the value, not the Right/Left's of the Either), I can write a simple pattern match and do that easily
08:08:35 <padre_angolano> Clint: hmm...
08:08:58 <Reisen> But if I want to do the reverse, and I have an aeson serialized A, B, or C, and I want to write something that looks like:   decode :: Text -> Either (A B) C
08:09:24 <Reisen> I feel like I'm stumped on how I'd know how many Left/Right's would be needed to construct the right result, or how to traverse the type
08:09:45 <Reisen> Can someone point me in the right direction on what I should read about, or if this is impossible?
08:11:13 <smaug_> Is Haskell impractical to learn?
08:11:16 <ongy> Reisen: unless you have some information in there about whether it's an A, B or C you can't (how would you decide what it is?)
08:11:51 <ongy> smaug_: it's different, so when you are coming from oop/imperative languages it may be a bit harder at first
08:11:53 <Taneb> smaug_, there's not as many resources to learn from as as a more popular language like Python, say
08:11:57 <Reisen> ongy, I don't mind tagging the resulting encoded value with the type that it is
08:12:07 <ongy> if you are coming from maths or using it as first language, it may even be easier
08:12:13 <Taneb> smaug_, but I think once you get the hang of it it ends up quite easy
08:12:27 <smaug_> Is Haskell best for AI?
08:12:31 <Boomerang> Reisen: In that case I believe Aeson already provides you with instances for FromJSON and ToJSON fro Either a b
08:12:43 <merijn> padre_angolano: I would suspect they forgot to update the site
08:12:49 <ongy> Reisen: then you know what it is by from the type. if  it's A it's (Left (Left val)) and so forth
08:13:02 <Taneb> smaug_, I don't know of much people writing AI code in Haskell
08:13:02 <Boomerang> And it "tags" the data with "Left" and "Right"
08:13:05 <Reisen> Boomerang that's the thing though, I don't want to encode the Either part, I.E, I want to store something that looks like
08:13:17 <Reisen> Just "{"type": "C", "C { ... }"}
08:13:26 <Reisen> And then at runtime, figure out the right amount of Left's/Right's needed
08:13:29 <Reisen> When pulling it out
08:13:39 <Reisen> Without having to hand write the instances, if that makes sense
08:14:01 <Reisen> Essentially I'm trying to write a ghetto emulation of anonymous sum types
08:14:42 <smaug_> Why should I learn Haskell? Give me some good reasons.
08:14:43 <Boomerang> Reisen: You would probably be better of having a sum type: data MyData = MyA A | MyB B | MyC C, or do you need it to be Either?
08:15:08 <Reisen> Boomerang, I need it to be either because, there are some 15 types that I have stored, and I want to be able to do something that looks roughly akin to:
08:15:13 <Reisen> type (:|) a b = Either a b
08:15:20 <Reisen> And right functions that can work on any pairing, I.E
08:15:33 <Reisen> x :: (A :| B :| Z :| G) -> ()
08:15:34 <Taneb> smaug_, because it is a productive language that can change how you think about and program in other languages for the better
08:15:42 <Reisen> y :: (A |: R |: N) -> ()
08:15:43 <Jinixt> sounds like a list, Reisen 
08:15:51 <ongy> smaug_: because you want to broaden your horizon. Also that question reaks of troll
08:15:53 <Reisen> It is like a list, except that I don't want a product I want a sum
08:16:16 <Reisen> I think, THINK this is the UnboxedSum extension that might get merged at some point
08:16:32 <dunx> smaug_: https://www.cs.utexas.edu/users/EWD/OtherDocs/To%20the%20Budget%20Council%20concerning%20Haskell.pdf
08:16:36 <Reisen> Where I'd be able to write, x :: (A | B | C) -> () and use case x of ( A ||); (| B |) and so on
08:16:39 <Reisen> but It's not implemented yet
08:16:49 <smaug_> ongy, I don't an answer from people like you. Go away.
08:17:10 <ski> Reisen : unboxed or anonymous/light-weight ?
08:17:13 <ongy> you accidently all the :)
08:17:37 <Reisen> ski, I'm not really looking for unboxed it just happens the (||X) syntax is part of the UnboxedSums extension from what I can tell
08:17:41 <Reisen> anonymous sum types is what I'm after
08:17:53 * ski nods
08:17:55 <Reisen> but they don't exist so I'm trying to get as close as possible
08:18:00 <ski> (OCaml has them, e.g.)
08:19:49 <ski> i'd perhaps call them "positional sum types", since the alternatives are determined by position (as for tuples), rather than by name (as for records, and for "ordinary" sum types with data constructors)
08:20:00 <Reisen> That is exactly what I'm after more or less
08:20:27 <Reisen> I'm thinking that maybe I could traverse an Either type with some sort of type level function in order to determine that position
08:20:40 <ski> (OCaml's "polymorphic variants" have alternatives determined by name. but you dont' have to declare the types beforehand, you can just use them, as with e.g. tuples)
08:21:41 <smaug_> Fucktional programming has ugly syntax
08:21:48 <dunx> go away then
08:21:54 <ski> it has different syntax
08:22:08 <dunx> i like the syntax
08:22:13 <dunx> mathematival
08:22:16 <ongy> Reisen: I think this may be a job for template-haskell.
08:22:20 * ski doesn't think there's any reason to be unfriendly
08:22:35 <Reisen> ongy, I think you may be right
08:22:36 * dunx concurs
08:22:57 <ski> (heh. that applies to both of you :)
08:23:03 <ongy> but then you need one instance for each version (arity?) of the sum you use. So probably not that practical either
08:23:21 <Taneb> smaug_, there are many different functional programming languages, and many different syntaxes!
08:23:25 <Reisen> I'm sure there's a way to write a type level traversal, something like monad-classes liftN
08:23:30 <Reisen> I'll give it some thought
08:23:36 <Tuplanolla> Syntices?
08:23:37 <dunx> ski: i didn't mean to be unfriendly :(
08:23:40 <ski> if you like brackets, you might try Scheme
08:23:41 <Taneb> Haskell looks very different to Lisp looks very different to Erlang looks very different to Scala
08:23:43 <Reisen> I was kind of hoping maybe the concept had been done before and I'd get a "you want X-package Reisen" style answer
08:23:50 <Reisen> but It's cool, it'll be fun to play with this idea
08:23:59 <ski> dunx : regardless, "go away" could easily be construed as such
08:24:02 <cocreature> is there any way to get the exact logbase2 of a Word64 using base < 4.8 (and no other packages)?
08:24:37 <MarcelineVQ> Reisen: if you were wanting to try unboxed sums you could build ghc head which has them
08:24:55 <Reisen> Yeah, I just don't want my project relying on GHC head
08:25:03 <Reisen> I want to stay on a stackage LTS release
08:25:18 <ongy> cocreature: exact logbase2? How would you store that?
08:25:49 <MarcelineVQ> You can use head with stack if that's your only sticking point :>
08:26:14 <cocreature> ongy: I don’t understand that question :)
08:26:31 <MarcelineVQ> anyway it was just to try it, if you're waiting for something more official 8.2 will have them
08:26:36 <Tuplanolla> Rounded up or down, cocreature?
08:26:43 <cocreature> ongy: 4.8 allows me to use countLeadingZeroes but that doesn’t exist
08:26:47 <cocreature> Tuplanolla: rounding down
08:26:49 <ongy> cocreature: is log_2 guaranteed to be representagle in finite memory?
08:26:53 <cocreature> ah sorry yeah exact was a bad term
08:27:03 <cocreature> I wanted to say integer and for some reason I said exact
08:27:31 <Taneb> Tuplanolla, syntaxes or syntaxies I think
08:27:50 <ski> smaug_ : most languages other than functional programming ones are weak on expressing sum types and pattern-matching. for that reason alone, i'd suggest learning a functional programming language (such as Haskell,Erlang,OCaml,SML,F#, e.g.)
08:28:14 <cocreature> by exact I was referring to the fact that I’d like to avoid floating point errors as caused by log x / log 2
08:29:00 <ski> smaug_ : note that one of the core concepts in object-orientation is "record/struct types", aka "product types". product types are "dual" (complementary) to sum types. in practice, you should know about both of them
08:29:12 <ongy> cocreature: how would countLeadingZeroes help you? do you know it's just a single bit?
08:29:37 <cocreature> ongy: logBase2 x = finiteBitSize x - 1 - countLeadingZeros x
08:30:00 <ongy> oh because we are rounding, right
08:30:07 <cocreature> yep
08:30:49 <ongy> copypaste the code of countLeadingZeroes?
08:30:56 <cocreature> it’s a primitive :)
08:31:06 <ski> smaug_ : another thing that functional programming is heavy on is treating functions as "just another kind of value", passing functions as arguments, computing them at run-time, returning them, storing them in data structures. passing functions as input and output yields higher-order functions, which are good to reduce more complicated patterns of boiler-plate code than ordinary (first-order) functions can reduce
08:31:15 <cocreature> but yeah I might just write a shitty implementation myself
08:31:26 <ongy> binary search for it :)
08:31:31 <cocreature> I was hoping something like that might already exist somewhere in base and I’m just unable to find it
08:31:52 <cocreature> ongy: I feel kind of bad for doing a binary search when my cpu can do this in a single instruction :)
08:31:58 <smaug_> ski, most languages are multiparadigm
08:32:27 <Taneb> smaug_, multiparadigm rarely means "good at all of them"
08:32:27 <ski> smaug_ : most functional languages discourage "side-effects", if not completely disallowing them. you might have an easier time getting started with one which allows them, but then you might not as easily learn alternative modes of expression. it's a trade-off
08:32:29 <ongy> cocreature: inline-c inline-assemble it? :P
08:32:45 <cocreature> ongy: heh :)
08:33:13 <ski> smaug_ : most languages have assignment and mutation all over the place (in standard libraries, e.g.) .. which is hardly conducive to doing functional programming
08:33:15 <ongy> also the single instruction may not be as good as it sounds. Way better than doing it yourself though
08:33:56 <smaug_> ski, what is the best language paradigm?
08:34:11 <Cale> smaug_: Another reason to learn Haskell is to find out what it's like to actually have a useful type system that helps you make large refactors to your codebase far more easily, and catches the vast majority of stupid bugs for you.
08:34:15 <Taneb> smaug_, that is not a question with an answer
08:34:26 <ski> smaug_ : i'd also like to mention "logic programming" (e.g. Prolog), which is based on expressing computation using *relations*, rather than functions. relatively often, it happens that one can run these relations both "forwards and backwards", getting "two (or more) for one", with a single implementation
08:34:46 <viuo> Hi everybody! Im trying to write a sort of expression evaluator. I have State Monad with an expression and an "environment" (the map + some other stuff). Unfortunately the algorithm I am implementing, treats the map as a global so if you set a var inside an expression it should be accessible from the outer ones too. The question is - do you know of any way I could propagate the state up the ladder so I can 
08:34:52 <viuo> read a variable from the surrounding expression too ?
08:34:54 <ski> smaug_ : imho, it's best to learn about all the major paradigms, and try to learn which one is the best tool for any given job
08:35:13 <ski> (which is why i was mentioning logic programming as well)
08:36:24 <ski> smaug_ : the point is to broaden your horizons, which will improve your programming skills also in Java or Python or whatever ..
08:36:37 <shapr> I see a lot of illogic programming at my day job.
08:37:09 <ongy> haha thank you ski 
08:37:13 * ski idly wonders which language(s) would be the best exponent(s) for the paradigm of illogical programming ..
08:37:21 <shapr> smaug_: want to see some cool code I wrote to get subway times for the nearby stops in Atlanta?
08:37:26 <Cale> On the other hand, once you know Haskell well enough, programming in Java or Python will be an absolutely terrible experience and you will hate it.
08:37:31 <djfo> viuo: you may want to try using the State monad
08:37:35 <smaug_> shapr, sure.
08:37:39 <djfo> viuo: do you have an example expression?
08:37:46 <ski> ongy ?
08:37:54 <Cale> (but you will be better at it than before)
08:38:15 <ongy> ski: for going full circle. I started with your last statement
08:38:19 <shapr> smaug_: right now the output in my tmux status bar: ["M:Arriving,4","N:3,10"] and the source is: https://github.com/shapr/tmuxmarta/blob/master/src/Lib.hs
08:38:26 <ski> ah :)
08:38:35 <shapr> smaug_: have you written Python before? Are you familiar with list comprehensions?
08:38:43 <ongy> shapr: you really love that piece of code
08:38:57 <smaug_> shapr, not much
08:39:14 <viuo> djfo: I am using a state monad but i cannot update the variable on the upper expression
08:39:26 * ski idly wonders whether someone should ask smaug_ about what language(s) they're comfortable with, so far
08:39:34 <shapr> ongy: it's a single file self contained example that does something useful, do you have others you'd suggest?
08:39:35 <Cale> shapr: wow, fancy list comprehension :)
08:39:54 <shapr> Cale: yeah! TransformListComp code by napping :-)
08:39:55 <viuo> djfo: let me think how to visualize it
08:40:05 <smaug_> ski, I am from low-level world ;)
08:40:11 <ongy> I didn't say that it's bad, or that I have something better
08:40:18 <shapr> smaug_: oh, you want embedded Haskell then?
08:40:25 <ongy> smaug_: so ada/assembly, or closer to C?
08:41:04 <shapr> ongy: I'd much prefer to have a long list of "working program in one file" examples.
08:41:28 <Denommus> so, it seems there isn't a usable gherkin parser in Haskell, right?
08:41:37 <smaug_> Cortex M 
08:41:37 <smaug_> Assembly
08:41:39 <ski> shapr : `let station = event ^. station' ?
08:41:47 <Denommus> I wonder how difficult it would be to create one with megaparsec
08:41:49 <shapr> Denommus: https://github.com/sakari/haskell-gherkin ?
08:42:01 <ski> smaug_ : that's nice :)
08:42:19 <shapr> smaug_: oh yeah, fun stuff. I got the risc-v arduino recently, it's really cool
08:42:25 <Cale> smaug_: Back around 2004 or so, I had the experience of writing a pipeline scheduler for PPC/Altivec in Haskell for a research project. We used it to optimise some vectorised code for computing sine/cosine pairs so that it operated at about 2.6 clocks/float (by extremely unfair comparison, GNU libm's cosine takes a couple hundred clock cycles)
08:42:45 <viuo> djfo: http://pastebin.com/DmcJPgMe here's my code
08:42:45 <Cale> Haskell can make a really good metalanguage for low-level work
08:43:03 <shapr> ski: yeah, that lens grabs the station field from this event
08:43:24 <ski> i meant, why not use `let' there ?
08:43:33 <viuo> djfo: it's a little messy, I just started with haskell, excuse if it hurts the eyes ;) could use a review
08:43:55 <Cale> Basically, my thing did a simulation of the units on a particular PPC/Altivec CPU and rearranged the instructions such that as many different functional units in the processor could be operating simultaneously.
08:43:59 <Taneb> ski, well, you couldn't use the name "station"
08:44:47 <Cale> (Modern processors are really non-obvious to optimise assembly code for by hand)
08:45:07 <viuo> djfo: in general, when evaluating MuExpr, the i want to be able to set a variable and then re-use it in the next iteration of fixpoint
08:45:15 <shapr> smaug_: if you decide you want to learn Haskell, I'm a big fan of haskellbook.com
08:45:37 <shapr> smaug_: although if you want free learning materials, byorgey's course is really nice
08:45:46 <ski> viuo : instead of `e <- get' and then later `symbols e', you could use `old <- gets symbols' and then later `old' ..
08:45:52 <shapr> @where cis194
08:45:52 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
08:48:39 <ski> viuo : oh, yeah, `getSymbols = gets symbols'
08:48:40 <viuo> ski: yeah it's a bit messy
08:48:40 <ski> viuo : i'd suggest looking into `modify', possibly defining `modifySymbols' and `modifyBinding', using it
08:48:40 <smaug_> shapr, yes the book sounds good.
08:48:40 <ski> viuo : in `assign', the last `return ()' is redundant, since the type of `setSymbols new' is already `Evaluator ()'. the return value of that will just be propagated
08:49:18 <viuo> ski: oh right, will fix
08:49:32 <cocreature> ongy: ah the class providing countLeadingZeros has a default implementation so I can be lazy after all and just copy it :)
08:50:22 <ongy> cocreature: are you doing this for compat reasons, or because you need 4.8?
08:50:38 <cocreature> ongy: I’m doing this because hackerrank doesn’t have base 4.8 :)
08:50:40 <viuo> ski: I am not sure I understand what modify does
08:51:01 <ongy> oh hakerrank
08:51:35 <ongy> that probably doesn't do FFI
08:51:39 <cocreature> yeah
08:52:09 <ski> viuo : `modify' takes a function, call it `f', gets the state, applies the function to it, and puts the result back
08:52:44 <Profpatsch> Does anyone know how I pattern match on structures using Data.Fix?
08:53:14 <Profpatsch> e.g. I have an NExpr from  https://hackage.haskell.org/package/hnix-0.3.4/docs/Nix-Expr.html#t:NExpr
08:53:25 <Profpatsch> It’s parsed in from a string.
08:53:35 <Profpatsch> Now I want to transform it in a certain way.
08:53:43 <ski> viuo : `modifySymbols f = modify (\(Environment ks old b el) -> Environment ks (f sym) b el)', e.g., could be used in `assign'
08:53:50 <Taneb> Profpatsch, you can match on Fix (NConstant c) for example
08:54:06 <viuo> ski: oh right I get it now
08:54:19 <dunx> users
08:54:49 <Profpatsch> Taneb: Interestingly, this is the Show instance of Fix: https://hackage.haskell.org/package/data-fix-0.0.3/docs/src/Data-Fix.html#line-68
08:55:00 <Profpatsch> So the printed value skips all the Fixes
08:55:20 <Profpatsch> I wonder if there is no nice pattern matching for that?
08:55:21 <ski> Profpatsch : bad instance ..
08:55:37 <ski> (doesn't even define `showsPrec')
08:55:39 <Taneb> Profpatsch, the Show instance doesn't affect the pattern matching one iota
08:55:53 <viuo> ski: I am concerned mostly about the evaluate. So for instance if I have a AndExpr where I have expressions A and B , I want all the assigns from A and B get propagated so in AndExpr I can read those assigns
08:56:14 <ertes> in what way is GHC's Any type different from, say, Void?
08:56:28 <Profpatsch> Taneb: Yes, of course.
08:56:42 <ski> viuo : should work with a state monad, iiuc
08:56:52 <viuo> ski: damn can't express myself properly... basically I want the SymTab in the State to be shared between all the expression
08:57:16 <ski> what does "shared between all the expression" mean ?
08:57:25 <viuo> so far what I get is I can read assigns going downwards but I want it to work both ways
08:57:26 <Profpatsch> Taneb: I should be able to use one of cata ana hylo for that, but I’m not entirely sure, how.
08:57:45 <nitrix> viuo: You'll have access to the state as long as your computations happen within the stateful monadic context.
08:57:56 <viuo> ski: in the original algorithm - SymTab is a global variable 
08:58:10 <Taneb> Profpatsch, it can be hard to get an intuition for those, I've found
08:58:20 <Taneb> I'd just use explicit recursion
08:58:22 <ertes> ah, nevermind
08:58:28 <ski> viuo : yes, go on ..
08:58:42 <viuo> ski: that is when you evaluate an expression where a child expression sets a variable to 1. This variable should return 1 in the parent expression too
08:58:53 <Profpatsch> Taneb: Probably.
08:59:08 <Profpatsch> I’m sure there is a nice way to do structure conversion.
08:59:08 <ski> viuo : yes, that should happen automatically, if you set up the evaluator right, using a state monad
08:59:28 <Profpatsch> Having all these Fixes everywhere is kind of suboptimal.
08:59:38 <ski> (which, at a quick glance, it looks like you're doing. perhaps i'm missing some detail ?)
08:59:59 <Profpatsch> Maybe with ViewPatterns
09:00:34 <ski> Profpatsch : `foo (Fix x) = case x of NConstant atom -> ...; ...' ?
09:00:53 <ski> (or with a helper function, if you prefer)
09:01:11 <ski> (`cata' or whatever could also be useful, yes)
09:01:58 <eacameron> What's the best way to provide lenses for my datatypes to downstream users (it's a library) without bringing in all of lens dependency?
09:02:12 <viuo> ski: unfortunately what I get is the state only get passed down
09:02:14 <Profpatsch> If I want to match deeper into the structure, it will be (Fix (Constr (Fix Constr2 (Fix …
09:02:43 <Gurkenglas> eacameron, https://github.com/ekmett/lens/wiki/How-can-I-write-lenses-without-depending-on-lens%3F
09:03:16 <viuo> what I would like to do is something in a sense of. I do new <- eval and later on i set the current state to what was calculated in "new"
09:03:50 <eacameron> Gurkenglas: Hah, wow. Just for me? ;)
09:04:28 <viuo> ski: I googled a module called Tardis which looks like something that would be relevant here
09:04:56 <Profpatsch> convertToNewstyle (Fix (NWith _ (Fix (NWith _ a)))) = a
09:05:02 <ski> Profpatsch, yes
09:05:04 <Profpatsch> Has to be nice somehow. :(
09:05:13 <ski> pattern synonyms could be helpful
09:05:23 <Profpatsch> Complaining on a very high level. :P
09:09:31 <ski> viuo : `MuExpr' and `NuExpr' always has `FixedPointExpr fp' in first component ?
09:09:43 <viuo> ski: yes, correct
09:10:15 <viuo> ski: FixedPoint is a variable that I set in SymTab
09:11:49 <ski> why not just have `MuExpr fp f' instead of `MuExpr (FixedPointExpr fp) f', and similarly for `NuExpr' ?
09:12:02 <Profpatsch> johnw: You wrote hnix, have you find 
09:12:05 * ski figures this is some kind of modal logic thing ..
09:12:14 <Profpatsch> *found a nice way to match on Fix Structures?
09:12:15 <Profpatsch> convertToNewstyle (Fix (NWith _ (Fix (NWith _ a)))) = a
09:12:20 <Profpatsch> That’s a bit verbose.
09:12:30 <viuo> ski: yeah Im trying to implement EmersonLei Model Checking
09:12:31 <Profpatsch> As in many Fix Constructors.
09:12:45 * ski 's never heard of "Emerson-Lei" befoer
09:12:52 <viuo> FixedExpr comes from the parser
09:13:01 <viuo> you can have a freestanding FixedExpr too
09:13:06 <ski> can you fix the AST ?
09:13:20 <ski> yes, but that seems to me to be a different thing
09:13:34 <ski> aiui, `MuExpr' and `NuExpr' represents binders in the object language
09:13:59 <ski> as such, it would make sense to not (typewise) allow any expression in the first component, but only an identifier
09:14:43 <viuo> that's correct
09:15:06 <viuo> should never come to this though
09:15:15 <ski> ?
09:15:56 <viuo> it does not change much since im ignoring it as an expression anyway
09:16:31 <ski> do you have a simple example of "what I get is the state only get passed down" ?
09:16:54 <viuo> okay let me write you an expression
09:19:12 <viuo> MuExpr (FixedPoint 'A') (MuExpr (FixedPointExpr 'B') (DiamondExpr 'action' (FixedPointExpr 'B')))
09:19:48 <ski> and are we talking about `eval' here ?
09:19:59 <viuo> yes - eval
09:20:15 <viuo> so eval of MuExpr will evaluate it as long as it doesn't return the same value twice
09:20:37 <viuo> no consider the inner MuExpr first
09:20:52 <viuo> we set the B to be the set of all states at first
09:21:13 <viuo> and then we evaluate the DiamondExpr as long as it returns different values
09:21:30 <viuo> when we get two same values we set B to the result
09:21:37 <viuo> now consider the outer MuExpr
09:21:56 <viuo> we start here before evaluating the inner one
09:22:30 <ski> using `newEnvironment' or `newEmersonLeiEnvironment' as initial state ?
09:22:40 <ski> (i'd s/new/init/ there, fwiw)
09:22:40 <viuo> newEmersonLeiEnvironment
09:23:02 <viuo> init is for assigning the initial values
09:23:48 <viuo> now when evaluating the outer MuExpr (For A) we will have to repeat the same operation eval MuExpr for the inner one (B)
09:24:07 <ski> (i meant renaming them to `initialEnvironment' and `initialEmersonLeiEnvironment', or somesuch)
09:24:23 <viuo> oh okay
09:26:02 <viuo> I want to skip re-evaluating B when doing a second iteration of A
09:26:14 <viuo> so the eval MuExpr B set the state for B 
09:27:05 <ski> (hm, `evalEmersonLei' is only defined in the `MuExpr' and `NuExpr' cases)
09:27:42 * ski 'd probably specialize that to `evalEmersonLeiMu' and `evalEmersonLeiNu'
09:28:04 <ski> (or unfold, though the two bodies here are a bit large, so perhaps you wanted to avoid that)
09:28:22 * ski is trying to get a feel for the structure
09:29:16 <viuo> yeah, emerson lei is an extension of a basic naive algorithm
09:29:17 <Jinixt> is it possible to build a list with do notation? adding one element at a time
09:29:31 <viuo> they are only different in the muexpr and nuexpr cases
09:29:36 <Jinixt> (preferably without eating the performance cost of appending at the end)
09:29:53 * ski 'd factor out the common parts of the `if' there
09:30:25 <viuo> oh right, cause it's in a do block anyway
09:30:32 <ski> Jinixt : "adding one element at a time" is not that often a good idea, when dealing with lists
09:30:48 <Jinixt> yeah i know
09:31:02 <ski> viuo : in this case, one could use `when'/`unless'
09:31:22 <Jinixt> which is why i was hoping for something that would be statically transformed to something more performant
09:32:15 <ski> > do y <- [4,9,16]; x <- [sqrt y,-sqrt y]; return (x,y)
09:32:19 <lambdabot>  [(2.0,4.0),(-2.0,4.0),(3.0,9.0),(-3.0,9.0),(4.0,16.0),(-4.0,16.0)]
09:32:31 <Jinixt> imagine foo :: Int -> [Int], where if the argument is 0, you add an extra element to the middle of the list
09:32:44 <Jinixt> which is otherwise constant
09:32:52 <ski> to the middle of *which* list ?
09:33:02 <Jinixt> a constant inside the function
09:33:25 * ski is still not getting the picture
09:33:40 <okeuday_bak> it appears that one hex format char in a string causes all chars to be interpreted as hex, is there a way to avoid that? e.g. "\x83d" become one character
09:33:58 <okeuday_bak> it is likely attempting to make everything into UTF8
09:34:30 <Jinixt> sec
09:34:42 <Jinixt> foo x = if x == 0 then [1, 2, 3] else [1, 3]
09:35:00 <Jinixt> but without having to duplicate the list there and having more complex control flow etc
09:35:03 <Jinixt> just a simple example
09:35:56 <ski> > let x = 0 in concat [[1],if x == 0 then [2] else [],[3]]
09:36:00 <lambdabot>  [1,2,3]
09:36:01 <ski> > let x = 1 in concat [[1],if x == 0 then [2] else [],[3]]
09:36:05 <lambdabot>  [1,3]
09:36:32 <Jinixt> hm
09:38:10 <Jinixt> while that works it's not exactly what i'm looking for; i intend to try moving code from State to a DSL, where the DSL is just a list of a sum type
09:38:16 <Jinixt> so there's more control flow going on
09:38:24 <ski> yeah, elaborate on that ?
09:38:33 <Jenaf> what was the function for (a->b->c)->(b->a->c) again?
09:38:38 <ski> @type flip
09:38:42 <lambdabot> (a -> b -> c) -> b -> a -> c
09:38:50 <ski> @hoogle (a->b->c)->(b->a->c)
09:38:53 <lambdabot> package base
09:38:53 <lambdabot> package bytestring
09:38:53 <lambdabot> package containers
09:39:03 <ski> @hoogle (a -> b -> c) -> (b -> a -> c)
09:39:04 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
09:39:04 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
09:39:04 <lambdabot> CorePrelude flip :: (a -> b -> c) -> b -> a -> c
09:39:09 <Jenaf> thy
09:39:10 * ski nods
09:39:24 * ski tries looking some more at viuo's code
09:39:42 <viuo> im trying to formulate my problem properly
09:40:30 * ski is trying to figure out why `evalEmersonLei' apparently is using some previously set value of `fp' in the state
09:41:16 <viuo> take a look at fixPoint
09:41:32 <viuo> it runs in a loop
09:41:56 <viuo> each loop it's going to grow the Set or Shrink it
09:41:57 <ski> yeah, but that's for handling one `MuExpr' (or `NuExpr')
09:42:23 <viuo> yes but they can be nested
09:42:36 <viuo> so e in fixpoint can be MuExpr also
09:42:45 <ski> i'm not seeing why `evalEmersonLei' is somehow expecting `fp' to already have an associated value, before starting to process a `MuExpr'/`NuExpr' with a particular `fp' identifier
09:43:26 <ski> surely something like  MuExpr (FixedPoint 'A') (MuExpr (FixedPointExpr 'A') ...)  isn't intendend -- or is it ?
09:43:28 <viuo> for one because we initialize it at the beginning with iniEmersonLei
09:43:38 <ski> hm
09:43:48 <viuo> well with different values it is
09:43:49 * ski hasn't seen `eval' calling `initEmersonLei'
09:44:06 <viuo> sorry we initialize it at start in my main file
09:44:29 <viuo> so MuExpr (FixedPoint 'A') (MuExpr (FixedPoint 'B') ... is completely legit
09:44:37 <ski> (and, afaiac, i'm just consider a call like `runState (eval ...) (newEmersonLeiEnvironment ks)')
09:45:07 <ski> yeah, but reusing the *same* identifier with two different (nested) `MuExpr' ?
09:45:07 <viuo> runState (initEmersonLei f >>=  eval ) (newEmersonLeiEnvironment kripke) 
09:45:08 <Jinixt> ski: essentially, i want to write imperative-like code because it makes sense when talking about state transformation, but i want the result to end up in a list as a sequence of commands (and not State because it lets you do "anything")
09:45:13 <Jinixt> i think that's the best way to explain it
09:45:27 <ski> viuo : ty
09:45:41 <viuo> same identifier is not legal but I do not check for it
09:45:58 <viuo> it's a university project after all
09:46:07 <ski> Jinixt : it's still too vague to be able to give anything but very vague advice, and shots in the dark
09:46:30 <ski> not checking for it is ok. i wanted to know whether it was allowed or not
09:46:40 <ski> (by your precondition, i.e.)
09:48:02 <viuo> ski: you can ignore what happens when b==Nu etc
09:48:23 * ski would probably `initEmersonLei :: Expr -> Evaluator ()' ..
09:48:24 <viuo> the core is in v <- lookUp fp and fixPoint fp l v
09:48:49 <Aruro> why lense library occupies name space _Control_.Lense ? isnt it more _Data_.Lens?
09:49:08 <viuo> every time we evaluate MuExpr we first check the value of the variable and feed it to fix point
09:49:17 <ski> (or even `initEmersonLei :: Expr -> SymTab')
09:49:21 <viuo> fixpoint will then run in a loop starting with this variable
09:49:34 <Jinixt> it comes back to my earlier question about design of a card game. each Card can have a sequence of Effects (from a finite set of possible effects) depending on the current state of the board. while it's of course possible to write these cards as [Remove 0, Add "SomeCard"] or whatever, it sometimes has more control flow (depending on the board state), which would make do-notation handy
09:49:34 <viuo> when it's done the variable should be set to the result 
09:49:36 <Jinixt> how about that
09:49:47 <ski> Aruro : i suppose it's "control structures for *accessing* data" ?
09:50:37 <ski> viuo : hmm
09:50:45 <Aruro> are setters and getters control structures?
09:51:08 <viuo> since we basically have a nested loop when we have MuExpr inside MuExpr
09:51:19 <ski> viuo : now i'm wondering if you really want to set the initial values in `initEmersonLei', and not rather just when you start processing `MuExpr' and `NuExpr'
09:51:20 <viuo> we do not want to recalculate that
09:51:43 <ski> viuo : since with nesting (and repeating of those constructs), you'll pick up the old value from the last outer iteration
09:51:52 <ski> i'm wondering whether this is what you intended or not
09:52:04 <viuo> exactly I don't want to do that
09:52:12 <ski> <viuo> since we basically have a nested loop when we have MuExpr inside MuExpr
09:52:14 <ski> exactly
09:52:28 <viuo> I want for inner loop to set the state of outer loop
09:52:45 <ski> so you want the next activation of the inner loop to pick up the last value of the previous activision of the inner loop, correct ?
09:52:46 <viuo> so in the second iteration of outer loop we do not start from 0 so to speak
09:52:52 <viuo> exactly
09:53:00 <ski> ok, good
09:53:13 <viuo> sorry Im still confused by the fp
09:53:42 <monochrom> Aruro: If you go through examples like Data.Set, Data.Map, Data.Vector, Data.Int... they are actual data or data structures, in which case lens is an odd man out.
09:55:01 <Aruro> perhaps, but is it native of Control. set? :)
09:56:16 <Aruro> somehow negating whole point of having meaningful module classes
09:56:24 <ski> it's an "abstract" set, not particular to any data structure
09:56:56 <monochrom> Bat.Lens. Also Bat.List.
10:00:18 <Aruro> from same series, Data.Profunctor is it actually a data structure?
10:00:41 <monochrom> No. You can also cite Data.Function and Data.Functor.
10:01:13 <ski> viuo : sorry, i'm still not seeing the problem
10:01:50 <Aruro> why not to bring then Function and Functors also to Control? :)
10:02:35 <Aruro> Control.Profuntor sounds ok.
10:02:48 <monochrom> Yes. Send a pull request.
10:03:10 * ski . o O ( #haskell-lens )
10:04:29 <Clint> Control.List
10:04:50 <ertes> Aruro: at least having both Control and Data allowed 'lens' to use Control.Lens without conflicting with the older data-lens, which uses Data.Lens =)
10:05:12 <viuo> ski: ok very simply in expression (X (Y)) i want to evaluate Y and set the current state of X to that of Y
10:05:14 <monochrom> Oh, Data.Lens is already taken!
10:05:57 <ertes> you think in lisp everything is data?  you haven't seen van laarhoven lenses yet!
10:07:17 <monochrom> lisp is too easy. car and cdr are the basic lenses (prisms?) and you just compose them for a complete suite.
10:07:32 <ski> viuo : surely you don't want to set the state associated with `A' to the one associated with `B' in
10:07:35 <ski>   MuExpr (FixedPoint 'A') (MuExpr (FixedPointExpr 'B') (DiamondExpr 'action' (FixedPointExpr 'B')))
10:07:39 <ski> ?
10:07:58 * ski . o O ( `caddaadr')
10:08:12 <viuo> I do
10:08:16 <ertes> you think in lisp everything is data?  you haven't seen van laarhoven optics yet!
10:08:41 <viuo> i want the assignment of B to be visible in A
10:08:50 * ski thought each of the variables associated with individual `MuExpr's were to be kept distinct
10:09:23 <ski> an  assign 'B' ...  won't affect a  lookUp 'A'
10:09:25 <viuo> the only reason why I want that is that evaluation runs in a loop
10:09:49 <viuo> so MuExpr A will run a loop 
10:10:05 <viuo> and if in a loop there is a MuExpr B, i do not want to re-evaluate it
10:10:11 * JuanDaugherty suspects  a CL lens lib has just been referred to
10:10:26 <viuo> in imperative it would be something like - have global map and set it 
10:10:48 <viuo> so if I have already iterated through B I can just read it 
10:10:48 <ski> that's what you're doing here as well, unless i'm missing something
10:11:35 <ski> you have a single `SymTab'. using `assign' on `B' will update one part of it, using `lookUp' on `A' will read another, independent, part of it
10:11:56 <viuo> yes but it's working only on the same level
10:11:57 <ski> i don't see how this is any different from in an imperative language
10:12:14 <monochrom> catmorphism :: (F r -> r) -> Meow F -> r
10:12:17 <viuo> so so if we treat MuExpr as a loop
10:12:38 <viuo> then A as an outer and B as inner
10:13:00 <viuo> we loop A times B 
10:13:16 <viuo> each iteration of A we set be to some value
10:13:26 <viuo> so we reset B each time we loop A
10:13:49 <viuo> what I want is that first time we loop B we set B and in second iteration of A we get this B and not reset it
10:14:25 <ski> i only see you calling `reset' when you switch from `Mu' to `Nu' and vice versa
10:14:35 <viuo> no no that's a different thing
10:15:05 * ski nods
10:15:12 <viuo> 1. iteration of A :: 1 iteration of B  -> B = {}
10:15:20 <viuo> 1. iteration of A :: 2 iteration of B  -> B = {1}
10:15:29 <viuo> 1. iteration of A :: 3 iteration of B  -> B = {1,2}
10:15:46 <viuo> 2. iteration of A :: 1 iteration of B  -> B = {}
10:15:58 <viuo> but I want it to be :
10:16:01 <viuo> 2. iteration of A :: 1 iteration of B  -> B = {1,2}
10:16:19 <ski> is that what you want, or what you observe ?
10:16:24 <ski> ah, ok
10:16:54 <viuo> so I do not want to clear ( ;) not reset sorry ) B when continuing with A
10:16:56 * ski is still thinking the problem must be elsewhere, not causing this code to run or something ..
10:17:46 <ski> hmm
10:17:55 <viuo> I thought it's because I do result <- eval and then use this as a result
10:18:03 <ski> actually, you don't set `fp' to the last value in `fixPoint'
10:18:09 <ski> you're stuck and the next-to-last
10:18:12 <ski> perhaps that's it ?
10:18:27 <ski> s/and/at/
10:18:54 * ski ought to have spotted this before
10:18:56 <viuo> what would the best is to have something like (result, env) <- eval  
10:19:11 <ski> hm, or perhaps this doesn't matter anyway
10:19:40 <viuo> that doesn't matter because it's the same
10:20:21 <ski> yea :/
10:20:33 <viuo> when evaluating I want to get both the result of evaluating the expression and the environment when it finishes
10:20:54 <viuo> so (result, environment) <- eval l 
10:20:57 <ski> @type runState
10:21:01 <lambdabot> State s a -> s -> (a, s)
10:21:16 <viuo> and then do something like updateEnvironment env
10:21:45 <ski> if you're still in `Evaluator', this shouldn't matter
10:22:28 <viuo> there is something like reverse state monad i think right ?
10:23:17 <ski> yes, but i can't imagine why you'd want it here
10:23:19 <Cale> There is, but it sounds more like you want the ordinary one.
10:23:40 <Cale> The one where the state travels backwards in time is weird and you almost never want it.
10:24:00 <ski> (iirc, one use was backward AD)
10:24:50 <viuo> how is a global state in an expression usually done ?
10:25:13 <viuo> imagine you have the old school "global" keyword
10:25:15 * ski would like to get a concrete value for `kripke' in `runState (initEmersonLei f >>=  eval ) (newEmersonLeiEnvironment kripke)', and expected vs. actual output
10:25:41 <viuo> i want to be able to set a global variable basically
10:25:53 <ski> the point isn't "global" state, it's just a matter of mutable state persisting far enough
10:26:25 <viuo> hmm the state persisting far enought is not my problem
10:26:27 <ski> (sufficiently nonlocal state, if you insist)
10:26:28 <viuo> it works 
10:26:39 <viuo> yeah something like this
10:27:26 <viuo> if i have a nested expression that assings X=1 and after evaluating i'd do something like X+2 I want the result to be 3
10:27:46 <ski> yeah, that's what `State' gives you, out-of-the-box
10:27:49 <viuo> even if I have set X=0 in the beginning
10:28:03 <ski> .. meaning that there must be something else here that we're missing
10:28:29 <ski> as long as you don't rerun that `X := 0' assignment, you should be fine
10:28:41 <ski> (but you only run `initEmersonLei' once, so shouldn't be a problem)
10:29:14 <viuo> damn
10:30:03 <viuo> so It has to be something else
10:30:22 <ski> that's my inference, yes
10:30:43 <viuo> or nothing is wrong at all just it's the overhead of all the stuff I do in EmersonLei that screws it up
10:31:02 <viuo> in theory emerson lei should waaay faster since it's not recalculating stuff
10:31:14 <viuo> in practice it's always way slower in this case
10:31:41 <viuo> since it returns correct result I just assumed it's resetting stuff
10:31:59 <ski> (at this point, i'd start to check whether you've saved the file, whether you're compiling/running the correct code, &c. -- except that you seem experienced enough to already have checked all such silly mistakes already)
10:32:21 <viuo> I did
10:32:55 * ski was under the impression that viuo was getting an incorrect result out of the computation, though
10:33:08 <viuo> can you think of an easy way to log how the State changes with time ?
10:33:16 <viuo> yeah sorry I did not specify that
10:33:43 <viuo> the result is correct, I did a version without using monads and just passing everything in the arguments before
10:34:09 <ski> use `State [Environment]', have the accessors, updaters, modifiers access the head element, make changes to the state actually push a new state on the list
10:34:13 <viuo> the reason I switched to State Monad because I was under the impression that it's the best way to handle the global thingy
10:34:50 <ski> it's a good way to avoid the boiler-plate (and bugproness) of explicitly threading the state around, yes
10:35:22 <viuo> damn I could have gone with c++
10:35:29 <viuo> :D
10:35:40 <viuo> well I did learn something though
10:37:00 <ski> how did emerson lei fare with the version threading state around explicitly ?
10:37:08 <ski> also slower in that case ?
10:37:18 <shapr> ongy: got any other small complete Haskell projects you'd suggest?
10:37:38 <viuo> yes
10:37:52 <viuo> but I that was exactly because I did not have a global variable
10:38:42 <viuo> so it was doing I thought what was happening here
10:39:14 <ski> all `State' does is hide the state-threading for you
10:39:21 <ski> it's still passing it around, under the covers
10:39:33 <ski> if you want to, you could try using `STRef s' or `IORef' instead
10:39:49 <ski> which are implemented by actual update-in-place
10:40:08 * ski isn't sure it would make much of a difference here
10:40:29 <viuo> I think Im just going to give up for now
10:40:33 <ski> @type newIORef
10:40:37 <ski> @type readIORef
10:40:38 <lambdabot> error:
10:40:39 <lambdabot>     • Variable not in scope: newIORef
10:40:39 <lambdabot>     • Perhaps you meant ‘newSTRef’ (imported from Data.STRef)
10:40:42 <lambdabot> error:
10:40:42 <ski> bah
10:40:42 <lambdabot>     • Variable not in scope: readIORef
10:40:42 <lambdabot>     • Perhaps you meant ‘readSTRef’ (imported from Data.STRef)
10:40:52 <ski>   newIORef :: a -> IO (IORef a)
10:41:00 <ski>   readIORef :: IORef a -> IO a
10:41:00 <viuo> have a report due midnight anyway, spent way too much time trying to fix that anyway
10:41:07 <ski>   writeIORef :: IORef a -> a -> IO ()
10:41:14 <ski> viuo : fair enough
10:41:47 <viuo> I'll check changing Environment to [Environment] first though
10:41:55 <ski> in C++ terms, these are more or less `p = new ...', `*p' and `*p = ...'
10:42:14 <viuo> Thanks a lot for your time
10:42:17 <ski> np
10:42:35 <viuo> how do I buy you a beer ;) ?
10:42:46 <ski> hehe, i don't drink beer :)
10:44:06 <viuo> well then In all cases thank you for clearing things out for me and for some remarks on my code. :)
10:45:05 <sdrodge> Speaking of stateful computations. I'm trying to rewrite my program that is currently (flip evalState Empty . mapM doQuery) :: [Int -> Int] where doQuery is (State Blah Int)
10:45:11 <ski> viuo : i could give more remarks on small things, but i was thinking it was more important to try to find the main problem you were having ..
10:45:19 <sdrodge> To use pipes instead.
10:45:24 <sdrodge> Anyone know how to do that easily?
10:46:07 <viuo> ski: next time maybe then, I think I'll be getting some more into haskell
10:47:27 <ski> viuo : apropos C++, Bartosz Milewski seem to have some YT videos about concepts in Haskell, in some cases applying them in C++
10:47:36 <sdrodge> *(Int -> Int)
10:47:41 <sdrodge> not a list of int functions, lol
10:47:56 * ski was wondering ..
10:50:04 <sdrodge> jesus, I mean [Int] -> [Int]
10:50:44 * ski also guesses sdrodge meant a different type for `doQuery', perhaps `Int -> State Blah Int'
10:50:47 <ongy> shapr: not really. Also I don't think it's a bad example. I have just seen it often lately :)
10:50:52 <sdrodge> ski: You're right again.
10:50:58 <ongy> my stuff is usually to much around FFI...
10:51:02 <sdrodge> Geez I should not try to type this from memory while very tired.
10:51:30 <viuo> ski: yeah I am familiar with him, there is a lot of awesome stuff he wrote, Im a bit tied up with some other things so I just went throught Learn you a haskell so far. Have to say that it's awesome to look at things from different perspective. Some things gave me a huge headache though. Type declaration of state monad being one of them :)
10:51:37 * ski doesn't, alas, know much about `pipes', though
10:51:47 <sdrodge> But basically, the program reads a list of ints in from a file, jams them through a state processor, and then writes the ints back out
10:51:56 <sdrodge> but I want to do the I/O portion in a streaming manner
10:52:08 <sdrodge> and I can't really figure out how to do it.
10:52:14 <sdrodge> Because I am a pipes noob.
10:52:22 <ski> viuo : some people think LYAH is like an hour-long trailer. iow doesn't give much depth (nor exercises)
10:52:25 <nitrix> sdrodge: Without learning any pipe or fancy libraries, you can just leverage lazy lists.
10:52:38 <sdrodge> nitrix: I don't think so, because of the mapM, right?
10:52:40 <ski> @where CIS194
10:52:41 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
10:53:42 <ski> viuo : *nod*. the main point is to get to know different approaches to things, to be able to have more choices when attacking a problem
10:53:50 <nitrix> sdrodge: Ah yeah that's a problem.
10:54:43 <nitrix> sdrodge: How about data Stream m a = Nil | Stream a (m (Stream m a)) ?
10:55:16 <nitrix> Where Stream represents a value of type `a` and a generator for the next values of type `Stream m a` again.
10:55:17 <ski> sdrodge : hm, with lazy `State', i think that could still be possible
10:55:31 <nitrix> Until you reach Nil.
10:55:34 <sdrodge> ski: mapM forces the whole list.
10:56:07 <nitrix> Because of `sequence`, yeah. I've hit that problem a few times :P
10:56:25 <sdrodge> nitrix: That's an interesting idea for sure.
10:56:29 <ski> > (`evalState` 0) (mapM (\n -> state (\s -> (n ^ s,s+1))) (repeat 2))  -- `mapM' on an infinite list
10:56:30 <sdrodge> I do want to try using pipes though.
10:56:32 <ski> sdrodge : no
10:56:33 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
10:56:48 <ski> not for `State s'
10:57:12 <nitrix> ski: I believe the problem arise when you have `m ~ IO`.
10:57:22 <ski> yes -- but i didn't suggest that
10:57:30 <nitrix> I think he said the lists comes from a file or something.
10:57:41 <ski> `hGetContents' ?
10:57:42 <monochrom> I think we all agree what happens to IO's mapM. Just be careful when you generalize. Just don't generalize. :)
10:59:10 <sdrodge> Interesting. TIL.
11:00:33 <sdrodge> It's the same program I was asking questions about in here yesterday, btw.
11:00:35 <sdrodge> https://hastebin.com/utamusoliq.hs
11:01:03 * ski . o O ( "SSL error: error:14077438:SSL routines:SSL23_GET_SERVER_HELLO:tlsv1 alert internal error" )
11:01:16 <sdrodge> Sounds like I drew unwarranted conclusions from the heap profile.
11:02:01 <sdrodge> Because it shows memory usage only by main until peak memory usage, then a transfer out of main into doQuery and descendents for the rest of the lifetime of the program.
11:02:19 <sdrodge> so I just assumed State's mapM was also forcing the list.
11:03:01 <sdrodge> perhaps the real story is that IO's replicateM forces the entire list?
11:03:02 <ski> well, it isn't
11:03:09 <ski> but for `Maybe' and `Either e', it is
11:03:29 <sdrodge> Yeah, thanks for correcting my misconception.
11:03:54 <ski> @src replicateM
11:03:54 <lambdabot> replicateM n x = sequence (replicate n x)
11:03:57 <monochrom> Yes, replicateM and mapM have similar behaviors in IO.
11:04:15 <ski> `sequence' in `IO' traverses the whole list before relinguishinig control
11:04:44 <sdrodge> So is there a simple change I could make to this program that would get me streaming I/O?
11:05:06 <monochrom> unsafeInterleaveIO
11:05:16 <sdrodge> okay, _other_ than that, lol
11:05:16 <ski> `hGetContents' possibly
11:05:39 <ongy> which is unsafeInterleaveIO
11:05:45 <ski> right :)
11:06:03 * ski thinks `unsafeInterleaveIO' should possibly be renamed, in order to not unnecessarily scare people away from it
11:06:19 <monochrom> I wouldn't say that. unsafeInterleaveIO is strictly much more general than hGetContent.
11:06:23 <ongy> it has unsafeties, especially around withFile
11:07:16 <ongy> s/is/uses/
11:07:59 <monochrom> http://lpaste.net/77374
11:08:45 * ski thinks calling `hClose' on a handle that's been passed to `hGetContents' ought to raise an exception
11:08:59 <ski> (and similarly with calling `hGetContents' inside `withFile')
11:10:30 <sdrodge> If I did want to rewrite this program using pipes, though, anyone know how I could go about it?
11:10:40 <emc2> so, I have a situation where I have a Maybe-like type (named Result a; it has Success a, Undefined, and a few other failure modes).  It has a straightforward Monad and MonadPlus instance
11:10:51 <emc2> this is returned inside a monad
11:11:15 <emc2> so functions like (MonadStuff m) => args -> m (Result a)
11:11:31 <dmwit_> emc2: Without even seeing the rest of your question: you probably want `ExceptT`.
11:11:33 <emc2> is there a pattern that can handle this nicely without having tons of case statements everywhere
11:11:55 <dmwit> ?unmtl ExceptT AllTheWaysItCanFail m a
11:11:56 <lambdabot> ExceptT AllTheWaysItCanFail m a
11:11:56 <Rembane> emc2: Check out the errors package, it is neat.
11:12:10 <dmwit> ?unmtl ErrorT AllTheWaysItCanFail m a
11:12:11 <lambdabot> m (Either AllTheWaysItCanFail a)
11:12:15 <emc2> obviously, if it was just Result, you can just use monad
11:12:20 <emc2> ok, ExceptT
11:13:06 <dmwit> (\bot doesn't know about `ExceptT`; `ErrorT` has the same representation but possibly less preferable instances.)
11:13:18 <ski> monochrom : great fun :)
11:15:22 <monochrom> :)
11:15:59 <ski> i especially like the Mordor one
11:16:15 <ski> (simple, but suggestive)
11:17:55 * ski idly wonders whether the `seq' there should use `pseq' or perhaps `evaluate' instead
11:20:51 <monochrom> Yeah, but if it ain't broken, don't fix it :)
11:21:50 <ski> the question is : is it broken ? :)
11:34:37 <ongy> monochrom: that better than mordor... do I want to figure out why things happen that way?
11:35:20 <monochrom> I don't know. Are you interested?
11:35:23 * ski . o O ( concurrency is hard, .. )
11:36:09 <hololeap> where is a good place to propose small changes to the containers package
11:36:36 <shapr> ongy: ok, I'm convinced I need to write more small self-contained examples. I have one that turns off my touchpad with xinput, but I want to port that to turtle
11:36:54 <ski> `chaosContent' is a bit similar to spawning two threads to `readTChan', collecting the results in whatever order they arrive
11:40:58 <ertes> hololeap: the libraries mailing list
11:41:07 <ertes> hololeap: also the issue tracker on github
11:41:26 <ertes> hololeap: alternatively fork and implement the change, then issue a PR
11:45:19 <MarcelineVQ> I believe containers has somewhat of a backlog atm so ymmv for response-time, the mailing list is probably the best spot for getting muliple eyes on your idea
11:46:50 <ertes> i wish IntMap would get on par with HashMap…  it was quite surprising to see that the latter is actually faster most of the time
11:48:33 <hololeap> ertes: does it have a git repo or something?
11:48:44 <MarcelineVQ> yes https://github.com/haskell/containers/issues
11:48:51 <hololeap> oh, cool
11:49:59 <ongy> shapr: that's a shell one-liner for me. maybe not that interesting
11:50:05 <ongy> or do you have a nicer trigger for it?
11:50:39 <hololeap> well, i might as well ask for input since it's a really small change. i thought that the drawTree and drawForest would be better to be implemented using Show instead of forcing the type to be Tree String
11:50:48 <hololeap> (or Forest String)
11:51:02 <hololeap> any reasons that wouldn't work?
11:58:43 <geekosaur> Show is not the best thing to use for prettyprinting, since (a) ideally show . read ~~ id (b) it's really intended for debugging, not prettyprinting, so should include details you need to debug an error in the tree
12:05:59 <MarcelineVQ> I see so one should map an   element-to-String  function over the tree to use drawTree rather than relying on Show to reasonably show the things you're interested in, since it likely won't. You lose the ability to decide what's displayed with  `Show a => a` compared to (a -> String)
12:09:35 <Denommus`> intero is good. I like it
12:33:32 <mniip> MarcelineVQ, well uh technically nah
12:34:51 <ezyang> Man, IntMap is so fast lol 
12:35:36 <mniip> data Shown a s = Shown a; instance Reifies s String => Shown a s where show = reflect
12:37:30 <Denommus> do we have a recommended regexp library already?
12:37:49 <ezyang> don't use regex-compat!! 
12:38:46 <Denommus> ok, but what to use? XD
12:39:30 <cdornan> regex?
12:40:30 <ezyang> don't use regex-posix either 
12:40:39 <ezyang> regex-tdfa is pretty common. regex is new kid on the block 
12:40:39 <cdornan> if you are set on PCRE then pcre-light or pcre-heavy are also possibilities
12:44:06 <cdornan> regex is shim on regex-tdfa and regex-pcre -- will support either backend in the same framework
12:46:13 <MarcelineVQ> mniip: I'm not sure what you're communicating to me :O
12:47:02 <cdornan> the problem with regex-compat/regex-posix is that they rely on platform libraries which are buggy 
12:47:59 <pikajude> but regex-pcre doesn't work with ghcjs
12:48:02 <Denommus> ok, why =~ needs [[String]] instead of [String]? I don't get it
12:48:34 <Denommus> pikajude: I don't need ghcjs :-)
12:48:41 <pikajude> oh, good
12:48:55 <maerwald> cdornan: which ones?
12:49:05 <cdornan> ok -- then you probably want regex-tdfa or regex
12:49:10 <cdornan> (for ghcjs)
12:49:52 <cdornan> why is regex using [re| ... |]?
12:50:52 <Denommus> cdornan: probably because it's easier to write regexes that have backlashes
12:50:55 <cdornan> so that we can check the REs are well formed at compile time
12:51:04 <cdornan> and that too!
12:51:30 <Denommus> cdornan: ah, that's cool
12:51:53 <Denommus> but, again, why does =~ need [[String]] to extract multiple matches?
12:51:56 <Denommus> why not [String]?
12:52:20 <mniip> MarcelineVQ, reflection
12:52:41 <geekosaur> Denommus, presumably because each match can have captures in it
12:53:00 <cdornan> String type for RE isn't great either -- too easily confused with the text you are matching
12:53:08 <geekosaur> so each match is a list of strings [whole match, capture 1, ...]
12:53:18 <cdornan> but you can comoile from String anyway if you need to
12:53:43 <maerwald> cdornan: which platform libraries are buggy?
12:53:43 <MarcelineVQ> mniip: mmm, but why
12:53:56 <geekosaur> aand you really don't want the result type to change based on whether the RE has captres or not
12:54:13 <cdornan> macOS, Linux and Windows I think -- let me get the refernce
12:54:26 <geekosaur> (in fact you can't since that's reliably determinable onlyat runtime)
12:57:37 <cdornan> problems with regex-posix documented here: https://wiki.haskell.org/Regex_Posix
13:00:21 <cdornan> no data on the Windows libraries there -- don't know about those
13:07:14 <johnw> Profpatsch: what was the question?
13:09:44 <ertes> captures are just a horrible hack anyway, because regexes don't support semantics
13:09:48 <ertes> just use an actual parser library
13:12:56 <ertes> regexes are in the same lines of "solutions" as SELinux:  there is not a single legitimate use case, yet people love it for some reason
13:13:15 <ertes> *line
13:14:29 <cdornan> well I haven't just been writing a regex library but have been making heavy use of them for the first time in my Haskell career -- I couldn't disagree more with the notion that captures are not useful (when properly supported) -- a big mistake IMHO
13:15:32 <ertes> cdornan: captures are useful *with regex*…  my claim is that regexes themselves are a bad idea
13:16:55 <ertes> i can see how regexes are useful in a language like perl or PHP, but in haskell?  we have a language that supports EDSLs properly
13:17:06 <cdornan> as I said that in my experience is a major mistake -- regex captures don't make much sense without regexes
13:17:47 <chilversc> I was looking at http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#Tree.hs:simpleTree and wondered if I could define a constructor Leaf a that is equivilent to Node a Empty Empty?
13:19:27 <nitrix> chilversc: data Tree a = Empty | Leaf a | Node a (Tree a) (Tree a) ?
13:19:35 <geekosaur> only if you rewrite everything to use it. unless you want to get into the (more recent than RWH by several years) pattern synonyms extension
13:20:33 <chilversc> nitrix: but wouldn't treat Node 5 Empty Empty as being different to Leaf 5?
13:20:57 <geekosaur> yes, it would
13:21:00 <nitrix> chilversc: For the purpose of pattern matching, yes. I just thought you could handle both cases.
13:21:22 <nitrix> pattern Lead a = Node a (Tree a) (Tree a)
13:21:26 <pikajude> pattern Leaf a = Node a Empty Empty
13:21:32 <nitrix> Oh sorry, Empty yeah
13:21:40 <geekosaur> ^ pattern synonyms extension
13:22:01 <geekosaur> these can be bidirectional, meaning they can lso behave as "virtual constructors"
13:22:23 <nitrix> @let data Tree a = Empty | Node a (Tree a) (Tree a)
13:22:26 <lambdabot>  .L.hs:162:23: error:
13:22:26 <lambdabot>      Ambiguous occurrence ‘Tree’
13:22:26 <lambdabot>      It could refer to either ‘Data.Tree.Tree’,
13:22:40 <nitrix> @let data MyTree a = Empty | Node a (MyTree a) (MyTree a)
13:22:42 <lambdabot>  Defined.
13:22:52 <nitrix> @let pattern Leaf a = Node a Empty Empty
13:22:55 <lambdabot>  .L.hs:165:9: error: Not in scope: data constructor ‘Leaf’
13:22:55 <lambdabot>  
13:22:55 <lambdabot>  .L.hs:165:18: error:
13:23:13 <geekosaur> no patsyns in lambdabot currently I think
13:23:59 <nitrix> geekosaur: https://github.com/lambdabot/lambdabot/blob/freenode/lambdabot/State/Pristine.hs.708
13:24:03 <nitrix> Looks like it :(
13:24:06 <nitrix> I wonder why.
13:24:21 <chilversc> geekosaur: interesting, but as standard the answer is no? though I guess I could just have leaf a = Node a Empty Empty
13:24:26 <geekosaur> nobody requested it yet? talk to int-e I think
13:25:03 <pikajude> since it's bidirectional you can also use `Leaf foo` as an expression
13:25:05 <geekosaur> chilversc, you cannot "define a constructor" that way except as part of the data type, in which case it is distinct (can't resolve to Node a Empty Empty)
13:25:30 <geekosaur> you can define a *function* that way but you then can't use it in a pattern
13:25:50 <pikajude> mechb
13:25:52 <pikajude> sorry
13:25:56 <noobsy> hey guys, if I have a String, how do I view this as a char array and see what the first letter of the word is?
13:25:57 <nitrix> I think there's PatternGuards too?
13:26:09 <pikajude> pattern guards came first right
13:26:10 <noobsy> could I just do (first String)?
13:26:16 <geekosaur> :t head
13:26:16 <nitrix> noobsy: type String = [Char], it already is a list of chars.
13:26:20 <lambdabot> [a] -> a
13:26:23 <nitrix> noobsy: head :: [a] -> a
13:26:44 <noobsy> so say I have a string b
13:26:49 <noobsy> I can do (head b) and that gives me the first character
13:26:50 <noobsy> correct?
13:26:54 <pikajude> yes
13:27:00 <noobsy> alright
13:27:00 <cocreature> assuming a first character exists :)
13:27:08 <geekosaur> yes, there's pattern guards and view patterns and various other things, but you can;t just pretend it's a constructor. that's why patsyns exist
13:27:20 <geekosaur> re Leaf
13:27:34 <noobsy> another thing is I want to check to see if this first character is a member of accepted characters
13:27:34 <noobsy> for example, vowels
13:27:44 <noobsy> is there any way I can do that without doing a whole bunch of ifs?
13:27:47 <pikajude> elem "aoeui"
13:27:49 <nitrix> noobsy: `elems` "aeiouy"
13:27:55 <pikajude> elems?
13:28:07 <pikajude> :t elems
13:28:10 <lambdabot> Array i e -> [e]
13:28:13 <pikajude> oh
13:28:15 <cocreature> > 1 `elem` [1,2,3]
13:28:18 <pikajude> that sounds wrong
13:28:19 <lambdabot>  True
13:28:28 <cocreature> > 4 `elem` [1,2,3]
13:28:32 <lambdabot>  False
13:28:34 <pikajude> @let isVowel = (`elem` "aeiou")
13:28:37 <lambdabot>  Defined.
13:28:44 <cocreature> ^ noobsy that’s probably what you’re looking for
13:28:46 <nitrix> Seems like `elems` is the version for Data.Map and similar. Don't mind the `s` then.
13:28:59 <noobsy> how would that look, if (head String 'elem' "aeiou") then ___ else  ___?
13:29:07 <pikajude> sure
13:29:18 <cocreature> noobsy: you need backticks not '
13:29:20 <nitrix> noobsy: Close, but you'd need backticks, not apostrophe.
13:29:39 <noobsy> alright, thanks
13:29:54 <cocreature> also in most cases, pattern matching is better than using head since you can handle the case where the string is empty
13:30:18 <pikajude> let foo (x:_) | isVowel x = myFunction; foo _ = error "doesn't start with vowel"
13:30:53 <noobsy> so like case?
13:31:03 <cocreature> yep
13:31:06 <pikajude> they both support patterns
13:31:08 <noobsy> case [] do nothing, case x:xs, evaluate on x?
13:31:16 <nitrix> case lets you pattern match too, yeah.
13:31:28 <noobsy> kk
13:31:42 <nitrix> noobsy: It matches the pattern x:xs if it can, otherwise fallthrough the other cases. Evaluation is something else entirely.
13:32:13 <noobsy> when I mean evaluate I meant evaluating if it's a vowel or not
13:32:13 <noobsy> but yeah
13:32:48 <cocreature> case "a" of [] -> "empty string"; (c:cs) -> "single character" ++ show c
13:32:52 <cocreature> > case "a" of [] -> "empty string"; (c:cs) -> "single character" ++ show c
13:32:56 <lambdabot>  "single character'a'"
13:33:04 <cocreature> > case "" of [] -> "empty string"; (c:cs) -> "single character" ++ show c
13:33:06 <nitrix> In this case, there is evaluation happening, it's not wrong, just that I think the word you intend to use is `verify`/`check` or even `predicate`.
13:33:07 <lambdabot>  "empty string"
13:34:38 <akr[m]> Hi there, so I'm supposed to get a cabal project building and it's got the whole dependency hell thing going on… There is some patched package optparse-applicative included whose version has been set to 10000.something, but there is also a dependency fay, forced at some specific version, which requires optparse-applicative under 0.5… I guess my question is, how could this have ever worked?
13:35:09 <merijn> akr[m]: My guess is "it didn't"
13:35:30 <qqwy> Hello, everyone!
13:35:32 <nitrix> noobsy: We try to keep the term evaluation for when we mean some of Haskell's operational semantics (typically in the context of lazy evaluation, which is something Haskell differs from other functional languages).
13:35:35 <merijn> akr[m]: Because that sounds like an incredibly shittily maintained package at first glance
13:36:02 <noobsy> alright
13:36:07 <eacameron> Is it possible to derive a QuickCheck Arbitrary instance for a Generic type?
13:36:07 <nitrix> :)
13:37:14 <akr[m]> merijn: well, someone managed to launch it into production - although that might have been before someone else came around and try to "fix" things
13:37:32 <merijn> akr[m]: Well, if it didn't have proper upper bounds it might have worked then
13:38:08 <merijn> akr[m]: But the lack of bounds might now result in cabal selecting some other set of versions that happen to not work out
13:38:15 <qqwy> If you have a list-of-lists with the following preconditions: 1) each sublist is in increasing order, 2) when taking the heads of all sublists, this is in increasing order
13:38:24 <qqwy> How can you then combine this to a single, flat, ordered list?
13:38:33 <nitrix> int-e: Can we get -XPatternSynonyms for lambdabot's freenode default Prestine? Should I open a pull request?
13:38:35 <augur> @where calcfp
13:38:35 <lambdabot> http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/acmmpc-calcfp.pdf
13:38:36 <qqwy> (as efficiently as possible)
13:39:09 <akr[m]> merijn: but the package that requires optparse-applicative < 0.5 is fey == something
13:39:32 <akr[m]> so I don't see how the bound could've changed
13:39:51 <qqwy> This algorithm works, but is probably relatively inefficient:
13:40:11 <qqwy>  
13:40:11 <qqwy> inOrder ::  Eq a => [[a]] -> [a]
13:40:11 <qqwy> inOrder [] = []
13:40:11 <qqwy> inOrder ([] : rest) = inOrder rest
13:40:14 <qqwy> inOrder ((x : fl_rest) : rest) = x : ((concat xes) ++ (inOrder xless_rest))
13:40:18 <qqwy>   where
13:40:21 <qqwy>     (xes, xless_rest) = unzip $ map (\list -> span (== x) list) (fl_rest : rest)
13:40:56 <qqwy> Is there a smarter way?
13:41:30 <merijn> akr[m]: Perhaps, it's hard to say like this
13:41:45 <merijn> akr[m]: I don't suppose tracking down the original maintainer and giving them a swift beating is an option?
13:42:25 <akr[m]> well, they do have their names in the commits
13:42:32 <ertes> cdornan: that's not what i meant…  a proper parsing abstraction allows you to abstract and to encode semantics within the parser:  Email <$> userName <*> char '@' *> domainName
13:43:16 <merijn> ertes: ಠ_ಠ What if my email has no @ ?!? 
13:43:25 <nitrix> qqwy: Would you be able to rewrite it without that ++ ?
13:43:26 <pikajude> it's not an email then
13:43:29 <lyxia> qqwy: what about the other elements than the heads? how do they compare to each other
13:43:34 <ertes> merijn: then it's not an email according to that particular parser =)
13:43:44 <merijn> ertes: That means your parser is wrong!
13:44:05 <pikajude> "what's your email?" "q"
13:44:06 <ertes> merijn: maybe, but that's not the point
13:44:22 <merijn> ertes: I know, but I'm tired and bored and thus contrarian :)
13:44:29 <geekosaur> ...that means local domain
13:44:31 <merijn> pikajude: No, but a bang path is still technically valid
13:44:55 <pikajude> really
13:45:00 <pikajude> i've never traveled a bang path
13:45:18 <merijn> Technically yes, I wouldn't be surprised if half the infrastructure no longer supports it, though
13:45:26 <geekosaur> (and things like bang paths, decnet ::, etc. will be resolved to local inet domain and then processed as mail to a locally reachable non-inet destination, provided the local mail handler supports that and/or can route to it)
13:45:28 <merijn> pikajude: Hell, did you know valid emails can contain newlines?
13:45:35 <ertes> merijn: i'd take the bait, but i have to go in a few minutes, sorry =)
13:45:49 <pikajude> merijn: to the best of my knowledge (up until 3 minutes ago) it's a valid email address if there's a @ in it
13:46:04 <pikajude> well, specifically one @
13:46:06 <akr[m]> merijn: so would there happen to be some tool which would attempt to find some assignment of versions such that everything is satisfied
13:46:11 <MarcelineVQ> qqwy: I'd probably just concat and sort
13:46:13 <geekosaur> even that is wrong
13:46:18 <pikajude> yes
13:46:21 <pikajude> that's why i said up until 3 minutes ago
13:46:23 <geekosaur> source routing, although for spam reasons that's usually disabled
13:46:31 <pikajude> a valid email is any string
13:46:35 <geekosaur> @foo,@bar:bax@quux.org
13:46:36 <lambdabot> Unknown command, try @list
13:46:44 <qqwy> lyxia: They are in ascending order
13:46:53 <cdornan> ertes: but a good regex library lets you do loads of stuff without having to set up abstractions -- just look at the tons and tons of applications of regex in regex-examples 
13:47:04 <qqwy>  
13:47:04 <qqwy> example_list = [
13:47:04 <qqwy>   [1,1,2,3,4,5,6],
13:47:04 <qqwy>   [1,1,1,3,5],
13:47:07 <merijn> akr[m]: Well, the problem is not "finding such an assignment", it's "finding one that does AND actually works (in the sense of compiles and with the right behaviour)
13:47:07 <qqwy>   [2,2,2,3,3,3,6],
13:47:11 <qqwy>   [2,3,7,7,7]
13:47:14 <qqwy>                ]
13:47:15 <geekosaur> qqwy, please use a paste site
13:47:18 <geekosaur> @paste
13:47:18 <lambdabot> Haskell pastebin: http://lpaste.net/
13:47:29 <nitrix> qqwy: Just to understand, [[1,3,7], [2,5,8], [4,6,9]] is valid?
13:47:43 <qqwy> nitrix: Yes, it is
13:48:06 <cdornan> if I want to just rip out the target from the output of a stack invocation then I don't want to have to set up a parsing abstraction, etc.
13:48:07 <lyxia> qqwy: what about [[1,3],[1,2]]
13:48:10 <merijn> akr[m]: My approach would be to basically strip all bounds, see if it finds a solution (probably it will) see where it fails to compile (it probably will) and figure out which version of the library it fails on changed the external API, then fix that bound to that version. Repeat until everything works
13:48:17 <merijn> akr[m]: It'll be a hassle, though
13:49:26 <qqwy> Hmm...
13:49:49 <akr[m]> merijn: yeah, doesn't sound like much fun… not even getting payed for this until I get it building
13:50:12 <merijn> akr[m]: Nope, dependency management is never fun
13:50:37 <qqwy> The example that nitrix gave is at least not correctly converted with the algorithm I posted
13:50:53 <nitrix> qqwy: I'm working on an implementation for fun.
13:51:14 <merijn> akr[m]: On the bright side, at least you'll GET compiler errors. If this was python/JS you wouldn't figure out if the dependency was changed incompatibly until runtime
13:51:14 <cdornan> regex-examples is for the most part real scripts used to build the library, manage versions, build the cabal file from templates, the website, a test suite from the tutorial -- REs are really, really, really useful for all of this -- makes no sense to use parsers
13:51:22 <MarcelineVQ> akr[m]: cabal has an option called  --allow-newer  that may be helpful to get going   http://cabal.readthedocs.io/en/latest/installing-packages.html?highlight=allow%20newer#cmdoption-setup-configure-allow-newer
13:51:56 <eacameron> Does anyone derive their Arbitrary instances with Generics? I have a simple record type which really just needs to stick "arbitrary" into every field.
13:52:02 <qqwy> The idea is that the list-of-lists is generated by taking a list of (x,y) coordinates, taking the 'tails' of that, and for each of this [coordinate, other_coordinates] sublist, calculate the slope.
13:52:11 <qqwy> Now you have a list-of-lists of slopes
13:52:21 <akr[m]> MarcelineVQ: will try, thank you
13:52:29 <qqwy> because of 'tails', this is ordered (the original list of coordinates was ordered)
13:52:46 <qqwy> and because the slopes are created from these ordered lists, these will also be ordered
13:53:02 <merijn> akr[m]: Well, --allow-newer basically just tells it to ignore upper bounds, so it's roughly what I recommend (a bit smarter, tbh, since it keeps the lower bounds intact)
13:53:46 <qqwy> so I think you then end up with a list-of-lists where all sublists are ordered and the earlier elements of lower lists are never higher than the elements of later lists at the same index
13:53:52 <qqwy> although I am not entirely sure
13:54:04 <qqwy> (Which is why I asked this question)
13:54:10 <qqwy> nitrix: Awesome! :D
13:56:17 <noobsy> hey guys, assuming in this example "probOfSents" is just a function for finding the probability of something occuring given a certain model, is this the correct way to represent (probability modelVowel)(weight) + (probability modelLength)(1.0-weight)?
13:56:17 <noobsy> http://pastebin.com/Juv5McFC
13:56:31 <akr[m]> hmm, I can't find any docs on what does the fpath do in 'cabal install -fpath', anyone has any idea?
13:56:32 <noobsy> or do I have to use fromIntegral?
13:57:10 <MarcelineVQ> akr[m]: it sets a flag called path that is relevant to one of your .cabal files
13:57:26 <MarcelineVQ> iow it'll be defined in one of them so you should be able to find it there
13:58:48 <Profpatsch> johnw: It’s pretty awesome to construct stuff with hnix
13:58:52 <akr[m]> there are flags there, but this is not one of them
13:58:52 <akr[m]> great…
13:59:18 <Profpatsch> But when matching against deep NExprs, there’s a lot of Fix going on.
13:59:19 <Profpatsch> Maybe.
13:59:32 <Profpatsch> Maybe I just don’t know what I’m doing and I can use ana/cata/hylo somehow.
13:59:56 <Profpatsch> Practical example:
13:59:57 <Profpatsch>     outerLayer (Fix (NWith _
13:59:59 <Profpatsch>                  (Fix (NWith _
14:00:01 <Profpatsch>                    (Fix (NRecSet attrs)))))) = mkNonRecSet attrs
14:00:15 <dmwit> akr[m]: Don't forget to look in the cabal files of packages in your dependency tree.
14:00:23 <jle`> noobsy: you don't need to write 1.0
14:00:38 <jle`> but other than that i am not sure what you're asking
14:01:36 <akr[m]> dmwit: ah good point, thank you
14:02:37 <akr[m]> nope, nowhere to be seen
14:03:06 <jle`> this library is hilarious https://hackage.haskell.org/package/acme-smuggler
14:04:16 <jle`> doesn't work if you pattern match on () though, which i guess fits into the metaphor/abstraction of the package (catching smugglers)
14:04:22 <jle`> but who pattern matches on () anyway
14:04:57 <dmwit> Apparently it's easy to catch a smuggler if you observe them a little bit.
14:05:33 <jle`> hiding things in plain sight and just hoping nobody looks too closely
14:06:01 <dmwit> unsafeCoerce (4 :: Integer) :: () -- = ()
14:06:15 <dmwit> unsafeCoerce (unsafeCoerce (4 :: Integer) :: ()) :: Integer -- = 4
14:06:33 <dmwit> I think we can make a v2 of this package which makes smugglers much harder to catch.
14:07:44 <jle`> does that work if you pattern match on () ?
14:07:56 <dmwit> Well, it printed out. So.
14:08:08 <jle`> oh
14:08:16 <jle`> yeah it does :o
14:08:45 <dmwit> However, this version is much unsafer. If you try to discover a non-smuggler, bad things happen.
14:09:00 <jle`> gotta keep our smuggling operations safe
14:10:33 <dmwit> smuggle :: Typeable a => a -> (); smuggle = unsafeCoerce . toDyn; discover :: Typeable a => () -> Maybe a; discover = fromDynamic . unsafeCoerce
14:10:50 <MarcelineVQ> nitrix: got it?
14:10:54 <dmwit> Then `smuggle 3` prints `()` and `discover it :: Maybe Integer` gives `Just 3`. =D
14:11:20 <nitrix> MarcelineVQ: Got distracted, one sec.
14:12:20 <dmwit> `discover () :: Maybe Integer` -> segfault =)
14:12:36 <johnw> Profpatsch: we can fix that with pattern synonyms
14:12:49 <johnw> Profpatsch: I just haven't done it yet
14:13:21 <johnw> Profpatsch: example of what I mean: https://github.com/jwiegley/notes/blob/master/haskell/Synonyms.hs
14:13:44 <Profpatsch> johnw: I have a comment like that:
14:13:46 <Profpatsch>     -- e.g. findBinding (StaticKey "a") [nix|inherit a b c;] -> [nix|inherit a;]
14:13:53 <Profpatsch> I’d relly love quasiquotes.
14:14:00 <johnw> yes, we should do that as well
14:14:04 <Profpatsch> I think that would make it even cooler.
14:14:10 <johnw> making a note...
14:14:42 <Profpatsch> johnw: What’s the advantage of using the Data.Fix style of recursion?
14:14:57 <Profpatsch> For hnix in particular?
14:15:34 <johnw> it just makes the evaluators easier to write, since they can now be non-recursive
14:15:37 <Profpatsch> The error messages are more confusing, I’m not sure if there are that many pros from closing the recursion in the first place.
14:15:38 <johnw> and gives us a few other tools
14:15:45 <Profpatsch> Hm, that’s interesting.
14:16:04 <johnw> I could probably be convinced to convert to a form that doesn't use Fix
14:16:09 <Profpatsch> I’m not entirely sure how (and for what) to use ana/cata/hylo.
14:16:15 <johnw> once we have the pattern synonyms in place, it will become a purely internal detail anyway
14:16:20 <johnw> so the switch will have zero impact on clients
14:16:25 <Profpatsch> Maybe there’s an awesome usage I haven’t seen yet.
14:16:47 <johnw> oh, and Fix let you create attribute grammars easily
14:17:00 <johnw> because you can plumb other details through the recursive structure
14:17:10 <Profpatsch> Hm, if the * -> * interface changed to * a lot of type signatures would break.
14:17:34 <Profpatsch> I’m sure the algebra approach is the right one, yes.
14:17:45 <Profpatsch> Just not there yet from an end-user perspective.
14:18:02 <Profpatsch> Ah, that’s what Ann does?
14:18:09 <johnw> Profpatsch: https://github.com/jwiegley/hnix/issues/52
14:18:12 <johnw> Profpatsch: exactly
14:18:29 <johnw> really the value of Fix is that the recursive structure becomes a detail you can play with outside of the core type
14:18:45 <johnw> once you bake the structure in, you do gain simplicity benefits, but at the cost of flexibility
14:19:20 <Profpatsch> The base toolbox should be as general as possible. As long as it’s possible to wrap it in a more user-friendly way.
14:19:34 <johnw> yeah, we should be able to eliminate Fix from user view
14:19:41 <johnw> although, I'm not entirely sure about the error messages...
14:19:46 <Profpatsch> Right now what’s missing the most is a tutorial I think.
14:19:52 <johnw> agreed
14:20:27 <Profpatsch> I’m working on finding out how to best use the library myself, but maybe I can write something once I’ve used it a bit.
14:20:30 <akr[m]> can I force cabal to install a specific revision of some version of some package?
14:21:08 <johnw> Profpatsch: the synonyms fix should be dead simple (in fact, I'm thinking about writing a TH library for auto-generated such synonyms for any F-algebra)
14:21:25 <Profpatsch> Something like that would be awesome, yes.
14:21:54 <Profpatsch> It’s interesting that the Show instance of Data.Fix just outputs the structure with no Fixes.
14:22:04 <nitrix> qqwy: MarcelineVQ: Lame. The scratch pad I was using expired :(
14:22:10 <Profpatsch> Wait, I wonder if it’s possible to Read it in again that way.
14:22:15 <nitrix> I'll give another shot tonight :P
14:23:06 <Profpatsch> But even using the mkX functions is already awesome to generate nix expressions.
14:23:07 <Profpatsch> https://twitter.com/Profpatsch/status/839315463221948416
14:23:31 <nitrix> qqwy: My idea was to get the head of each list, find the `minimum` of that, keep it, then process the remainder of the lists recursively, without the minimum value we found.
14:23:55 <nitrix> qqwy: Eventually some lists gets empty and can be discarded until we end up with no lists at all, in which case, we have everything sorted.
14:24:30 <nitrix> qqwy: But a quick check revealed this is flawed :)
14:25:07 <qqwy> :-)
14:25:07 <johnw> Profpatsch: yeah, quasi-quoting would be awesome :)
14:25:17 <qqwy> Thank you for your help, nitrix!
14:25:24 <nitrix> qqwy: The problem arises because you do not know if the maximum value of a given list falls into the range of another list.
14:25:46 <nitrix> qqwy: So you cannot restrict yourself to the first N elements to each list, you have to merge them all.
14:25:57 <AWizzArd> One nice aspect about purity is: when I generate tons of random data, I only need to store the commit hash of my repo, and the used seed as a resort of storing a „backup” of the data.
14:26:12 <nitrix> qqwy: (1) Concatenate everything. (2) Sort everything. That's my best bet :)
14:26:32 <qqwy> ^^' Yes, that is the easy way
14:26:43 <nitrix> It's also the only way without more invariants :/
14:27:10 <qqwy> I was hoping that the current invariants would be enough to allow for an algorithm that runs faster than n log n.
14:28:13 <qqwy> that is, n² * log(n²) when you consider `n` the amount of points whose slope-combinations you want to work with.
14:28:39 <qqwy> I had hoped that sorting the points first, before generating their slopes would allow for a faster algorithm
14:30:08 <Profpatsch> johnw: Oh, there was another screenshot from earlier https://twitter.com/Profpatsch/status/835646875822919684
14:30:31 <Profpatsch> Seeing if I could translate an expression directly.
14:31:14 <nitrix> qqwy: What I'm saying makes no sense.
14:31:52 <nitrix> qqwy: I keep vizualizing multiple stacks and I keep thinking you can pick the top element from the appropriate stack and come up with a sorted list.
14:33:33 <nitrix> qqwy: But that means given M lists of N elements, you perform N * M checks? Maybe not, if the lists are kept in a sorted fashion and the list you pick from is resorted.
14:34:58 <nitrix> (e.g. lists A, B and C, with the top elements 1, 4, 7, you pick 1 from the list A, the value below is 5, then you resort your lists 4, 5, 7.
14:35:30 <nitrix> And you keep doing that and picking from A, with a large amount of lists, it should give you a reasonable complexity... 
14:37:09 <nitrix> n * log(m) actually.
14:37:15 <nitrix> :(
14:39:16 <graygray> Sorry if this sounds stupid but how would I go about adding a value to a list then returning a String as I was getting errors trying to use do
14:39:42 <Profpatsch> graygray: val : list
14:40:05 <Profpatsch> graygray: Code?
14:40:36 <graygray> Profpatsch: I am using that to add to the list but then after that I was after a return string along the line of "Value added to List"
14:41:09 <Profpatsch> graygray: would need to see the code
14:41:12 <nitrix> graygray: do { modify (val:); return "added!"  } ?
14:41:23 <graygray> I can try that
14:41:54 <nitrix> graygray: I need more context. What does your "modifying" implies? Is it a state?
14:42:34 <qqwy> I am thinking about something like:
14:42:42 <qqwy> 1) take the first element from the first list
14:43:04 <qqwy> 2) take the next element from this first list as long as it is equal to the first
14:43:04 <nitrix> qqwy: 2) Reposition the list once you see the second element of the list you just taken an element from?
14:43:32 <nitrix> qqwy: Well you have to make sure it's still smaller than the top element of all the other lists everytime.
14:43:51 <qqwy> hmm...
14:43:54 <nitrix> qqwy: Keeping the lists sorted helps with that, but that means everytime you pick, you must resort at least the list you picked from.
14:44:04 <nitrix> qqwy: That's what I tought too, but I get m * log n
14:44:39 <nitrix> Where m is the amount of elements to pick and log n, the length of one list
14:44:53 <nitrix> sorry, n.
14:45:26 <graygray> nitrix: Profpatsch: http://collabedit.com/yh5f5 this is the context
14:46:50 <Profpatsch> graygray: fan : (fans film) has which type?
14:47:18 <graygray> data Film = Film {title :: String, director:: String, year:: Int, fans :: [String]} deriving (Read, Show, Eq)
14:47:30 <graygray> fan is just a String
14:47:45 <Profpatsch> graygray: So fan : fans is of type [String]
14:47:53 <Profpatsch> But: you are in a do-Block
14:48:20 <Profpatsch> What do you want to “do” in the do-Block? :)
14:48:24 <Profpatsch> Probably IO
14:48:31 <qqwy> But what if you wouldn't need to reposition, but iterate in order over the list-of-lists until it is empty: take from the first list until its head is > than the head of the next list. Then this first list is done for this iteration, and we go on to the next. When the last list is reached, we start again at the first one of the accumulated result (the list-of-lists without all elements we just removed). Rinse and repeat.
14:48:44 <graygray> Profpatsch: Yeah, I am kind of new I know do is for IO but I'm not sure how I would get around doing multiple functions in that guard without do
14:48:45 <qqwy> I am not sure if this will be possible, or if it needs more invariants
14:48:59 <Profpatsch> graygray: What do you want the function to return?
14:49:19 <graygray> Profpatsch: "Fan added to film's fanlist"
14:49:46 <Profpatsch> Wait, is that what you want it to print as side-effect, or do you want the function to actually return it?
14:50:07 <graygray> I want it to print as a side-effect
14:50:13 <Profpatsch> Ah!
14:52:02 <graygray> So, any ideas on how I would go about that
14:52:35 <Profpatsch> graygray: I edited the code a bit.
14:52:55 <Profpatsch> addFanReturnMessage is how you would do it if you wanted to return the message from the function.
14:53:00 <Profpatsch> You just use a Tuple.
14:53:21 <Profpatsch> But that’s not really sensible if you want to log to stdout what you are doing.
14:53:30 <nitrix> qqwy: I think there's a problem because you can't always be picking from the first list and comparing with the other lists.
14:53:39 <Profpatsch> So there’s the third function.
14:53:51 <nitrix> qqwy: The top element of the first list might be bigger than the top of that of the other lists.
14:55:02 <nitrix> qqwy: e.g. [[1,100], [2,5,7], [3,4]]
14:55:28 <nitrix> qqwy: Everytime you pick, gotta resort the lists :)
14:56:01 <nitrix> (The resorting is log m, and you'll be picking n times, n * log m).
14:59:11 <qqwy> nitrix: Let me try to write my new idea out in an algorithm...
14:59:58 <qqwy> Although, yes, you're right
15:00:05 <qqwy> for input cases such as the one you just posted, that would not work
15:00:08 <qqwy> Hmm
15:00:16 <qqwy> I wonder if I am missing something
15:00:29 <qqwy> There might be more invariants given from the input in my specific problem
15:01:26 <qqwy> Right now I am writing a program that should, given a list of (x, y) coordinate points, print ot how many parallel lines there are
15:02:50 <qqwy> That means that for all `n` points, a list containing every (`n * n-1`) _pair_ of points is made, and each pair is then converted into a (x1 - x2 / y1 - y2) rational number representing the slope.
15:03:15 <qqwy> (This rational number is ofc. simplified so we can compare e.g. 1/2 with 2/4 properly)
15:04:11 <qqwy> Now, to find out how many parallel lines there are is the same as finding out how many pairs have the same slope. You can however only find this out by sorting the list of slopes (and then counting adjacent equal elements), or alternatively building a hashmap-histogram from them.
15:04:18 <nitrix> That sounds like linear algebra. You just get the slope of them all and find duplicates :P ?
15:04:28 <qqwy> Yes :-)
15:04:49 <qqwy> It's an exercise for Algorithms and Datastructures at the university. Which we are allowed to solve using Haskell B-)
15:04:54 <qqwy> That is, the exercise itself I have solved
15:05:08 <qqwy> but my program runs in O(n² * log(n²))
15:05:16 <noobsy> can anyone help me with this? http://pastebin.com/WDti0xnM
15:05:20 <noobsy> my compiler gives me an error
15:05:21 <qqwy> as it first creates all slopes, and then sorts them
15:05:58 <nitrix> qqwy: I have another approach.
15:06:05 <noobsy> Couldn't match expected type (String, String) -> Double with actual type Double. Possible cause: (*) is applied to too many arguments, IN the first argument of probOfSents, namely (fromIntegral (bigramProbByLength modelLength) * weight) ...
15:06:12 <qqwy> but what I am wondering about, is if it is possible to sort them faster than `n² log(n²)` by sorting the points before creating point-pairs and turning those into slopes
15:06:14 <nitrix> qqwy: How about a `Map Slope Count` ?
15:06:27 <qqwy> nitrix: That has the same time complexity
15:06:48 <qqwy> Building a HashMap takes `log n` insertion time, which you do `n` times when converting a list to a HashMap.
15:07:34 <nitrix> qqwy: Bloomfilters!
15:07:47 <noobsy> my question is "weight" is a double, and the value returned by "bigramProbByLength" is a double, so why can I not just use arithmetic in there?
15:07:52 <qqwy> My current solution uses a `Map Slope Count`, but I also have tried the `countAdjacents $ sort slopes` method
15:07:59 <qqwy> Heh x)
15:08:04 <qqwy> Probabilistic data structures for the win
15:08:22 <qqwy> It's really too unfortunate that my input data is too large for an IntMap
15:08:49 <qqwy> it's so amazing that Patricia trees work in O(min(n, 64)) on 64-bit machines
15:09:07 <nitrix> qqwy: I think bloomfilters would help here, avoiding unecessary lookups in the map.
15:09:34 <nitrix> qqwy: Now that I think about it, you don't even need a map, a Set is enough.
15:09:56 <nitrix> qqwy: All you care is if the element has been seen before, because that means you now have a new pair.
15:10:17 <nitrix> qqwy: Or do you need to know which lines are paired together?
15:10:34 <qqwy> You're right
15:11:30 <qqwy> The actual program is slightly more involved and does need you to keep track of how many there are for each slope, as you want the amount of trapeziums you can make, i.e. the amount of combinations of _pairs_ of parallel lines.
15:11:41 <qqwy> but the exercise itself does not change because of that
15:11:45 <qqwy> it only is a single extra step at the end
15:11:57 <lyxia> noobsy: you gave bigramProbByLength only one argument
15:12:10 <qqwy> that converts `count` to 'count * (count-1) `div` 2'
15:12:11 <nitrix> qqwy: Gotcha. I'm out of options then. I think bloomfilters is the furthest you can get.
15:12:21 <qqwy> All right!
15:12:24 <qqwy> Thank you for your help :-)
15:12:26 <lyxia> noobsy: so it gives you (String, String) -> Double, not just a Double
15:13:50 <noobsy> so there is no way I can make this work then?
15:13:59 <noobsy> given if I cannot touch any of the other functions
15:14:00 <noobsy> besides trainTestInterpolated
15:14:40 <lyxia> "make this work" is pretty vague
15:14:51 <lyxia> I can see a way to make this compile
15:15:00 <lyxia> I have no idea what this code does though
15:15:33 <lyxia> noobsy: let prob = probOfSents (bigramProbByLength modelLength) test * weight
15:16:42 <dmwit> `test :: [String]`, not `(String, String)`, no?
15:17:02 <dmwit> Oh, I misread your proposal. Ignore  me.
15:26:14 <Profpatsch> johnw: I’ve got a small intermediate datatype where I want to keep a few nix strings.
15:26:56 <Profpatsch> data Foo r = Foo { s1 :: NString r, s2 :: NString r }
15:27:19 <Profpatsch> But I’m not sure how to use that.
15:27:47 <Profpatsch> I can’t do type FooString = Fix NString I think.
15:28:12 <Profpatsch> Because the Fix would exclude all other NExpr types then.
15:28:55 <Profpatsch> But now I get Couldn't match type NExprF r with Fix NExprF
15:29:29 <Profpatsch> Because the NString is not from the fixpoint while the NExpr is.
15:30:54 <Profpatsch> Or more accurately: Couldn't match type NString r with Fix NExprF
15:30:58 <Profpatsch>         "goPackagePath" $= pkgPath goPkg
15:34:26 <Profpatsch> No idea how to work around that apart from just making all fields in my Foo type of type NExpr
15:37:46 <ghostprince> Hey
15:38:09 <ghostprince> Any IT channels?
15:45:01 <monochrom> Oh God, Cabal is moving forward to version 2.x
15:45:51 <Tuplanolla> Are you saying they're breaking everything, monochrom?
15:46:01 <monochrom> I don't know. I haven't tried.
15:46:07 <ezyang> there are a number of breakages 
15:46:21 <monochrom> But I think I will like "Since version 2.0, the macro CURRENT_PACKAGE_VERSION expands to the string version number of the current package." :)
15:48:13 <monochrom> (Also, not on hackage, only on github.)
15:50:44 <johnw> Profpatsch: that's an intriguing question, do you have sample code I can play with?
15:53:04 <johnw> Profpatsch: I wonder if you need something like data Foo = Foo { s1 :: forall r. NString r, etc ..., so that when you produce a Foo, it can only happen in a general context, allow for any future interpretation
17:06:46 * bsima always feels refreshed when hacking on haskell code
17:06:47 <teto> how to escape quotes in a String plz ?
17:07:26 <hpc> > '"':[]
17:07:27 <geekosaur> > text "hi\"lo"
17:07:29 <lambdabot>  "\""
17:07:30 <lambdabot>  hi"lo
17:08:01 <geekosaur> note that hpc's applied Show to the result (ghci does this also) and is not what is actually in the String, but a source representation of it
17:08:33 <hpc> but it is syntactically how you would write a string containing only a double quote
17:08:57 <hpc> (well, technically they both are)
17:09:14 <teto>  filehubut with a function ? it's to save different strings in a csv
17:09:45 <geekosaur> you should be using a csv library
17:11:24 <teto> sry huge lags: is there any function to just do the escape String -> String ?
17:11:58 <geekosaur> show but this will not do the right thing
17:12:18 <geekosaur> well, it will for some cases. again use a csv library to do this right
17:13:08 <hpc> yeah, that's the right answer for this situation
17:13:14 <geekosaur> if you are utterly lazy and don't mind it exploding because it produces Haskell strings instead of what CSV consumers expect, you can cheat and use show. which I expect means you will do so and then wonder why it sometimes explodes
17:13:17 <hpc> CSV string quoting is different from haskell string quoting
17:13:31 <geekosaur> CSV is not actually trivial
17:13:55 <geekosaur> (it's better than it used to be but it's still something of a sewer)
17:14:36 <hpc> csv is worse than it used to be, if you consider that there's other formats out there that aren't garbage ;)
17:15:49 <teto> to be clearer, I read from a csv file (saved with cassava) and then write to a lua script, I just want to escape ", i.e. replace " with \" 
17:16:06 * geekosaur is remembering spending part of 1995 trying to convince (employee theCustomer) that no, just because program A produces "CSV" and program B can read "CSV" does not mean program B understands what program A produces
17:16:37 <geekosaur> then you need to be certain the strings are sufficiently valid Lua source that you can get away with just that replacement
17:18:09 <teto> I don't need it to be robust, I will edit the final lua script by hand. It's just a pretext to learn haskell :)
17:18:37 <geekosaur> as I said earlier, show is the cheaty solution
17:19:14 <geekosaur> > show $ "ab" ++ ['"'] ++ "cd"
17:19:17 <lambdabot>  "\"ab\\\"cd\""
17:19:29 <geekosaur> hm, roght, that show-d twice
17:19:33 <geekosaur> > text $ show $ "ab" ++ ['"'] ++ "cd"
17:19:37 <lambdabot>  "ab\"cd"
17:20:05 <geekosaur> ("text" is a lambdabot hack. if you are doing this in ghci, use putStrLn)
17:20:07 <teto> geekosaur indeed perfect, sry I had not understood I could get away with it ^^
17:42:48 <Profpatsch> johnw: Yes, maybe that.
17:43:50 <Profpatsch> Anyway, as you can see in the paste, I just went with NExpr and “type-cast” the constructors when I need more specific types.
17:44:44 <Profpatsch> I was surprised how helpful the non-exhaustive pattern match errors were, together with taceShowId.
17:46:14 <Profpatsch> Those are basically asserts if I think about it.
17:46:25 <Profpatsch> like isStr (Fix (NStr s)) = s
17:47:13 <Profpatsch> Now, maybe it’s possible to create a function that can create these kinds of structural asserts.
17:47:25 <Profpatsch> Probably with pattern aliases.
17:47:52 <Profpatsch> Or Template Haskell if needbe.
17:49:22 <Profpatsch> the manual way would be something like
17:49:34 <Profpatsch> isStr (Fix (NStr s)) = s
17:51:07 <Profpatsch> isStr sth = error $ showShortened sth <> " is not a NStr"
18:10:44 <ratzes> any conduits parser experts here? I'm trying to parse a super large sql file (insert lines) and output one vector of values, everything i've tried has blown through my memory
18:12:21 <lyxia> How large is the file, how large is the vector, how large is your memory?
18:13:18 <ratzes> i have a 5gb and a 48gb, 5gb file is going to be 13mil data types with an int and a smallish text. I have 16 gigs, but would like to keep it as flat as possible
18:16:02 <lyxia> ratzes: do you have some code to work on?
18:17:31 <ratzes> i have an attoparsec parser that works on each line of the file and im using conduits to split the file into lines
18:18:20 <ratzes> i tried to yield a list and concat it down into a vector, i've tried yielding vectors (also lists) and using conduits vectorbuilder
18:19:43 <ratzes> each method blows right past my memory limits, I got it parsing flat (22mb) when i only count entries
18:30:39 <allenj12> whats the best way to get a random subList of a list? [a] -> b -> Rvar [a]
18:30:54 <allenj12> where b is the size of the sublist
18:31:13 <lyxia> take b
18:31:53 <allenj12> shuffle then take?
18:32:25 <allenj12> i thought there might be an actualy function i would be missing
18:32:27 <lyxia> hmmm that's a good idea if your shuffle is lazy or if you are going to take many elements
18:32:43 <ratzes> contiguous sublist?
18:34:33 <allenj12> it dosnt have to be a a "chunk" of the original array. like calling choice alot and puting the results into a list
18:35:22 <allenj12> i saw the function sampleSeq but its for sequences, just wish there was on for lists without having to do a conversion
18:36:17 <allenj12> im really dumb, there is just a sample function....
18:37:20 <ratzes> lol and they use sampleSeq and fromList so its not O(n*b)
18:40:36 <allenj12> i noticed that too... i mean its fine from now, but why would they do that?
18:40:47 <allenj12> fine for now*
18:41:00 <ratzes> because you can put it into a structure to index in O(1) time
18:41:21 <ratzes> oh, wait seqs are finger trees
18:41:24 <ratzes> so O(log n)
18:42:00 <allenj12> oooo
18:42:10 <ratzes> thats why you get the O(m*log n) and the other +n is from loading it into the seq
19:21:48 <allenj12> if i need to "unpack" two different monad to do a compution, is it possible to do that in one function. i.e if i have rlist <- 
19:21:59 <allenj12> woops one sec
19:23:24 <allenj12> rlist <- genRandList :: IO [Int] then i wanna take a sample of that list which by itself would look like s <- sample rlist :: RVar a
19:24:42 <allenj12> how do i do this but obviously type correctly
19:24:56 <allenj12> someFunc = do
19:24:56 <allenj12>     rlist <- genRandList 7
19:24:56 <allenj12>     s <- sample 3 rlist
19:24:56 <allenj12>     putStrLn $ show $ rlist
19:25:25 <allenj12> and rlist at the last line would be s, my b
19:27:12 <allenj12> should i just create a new function?
19:28:58 <MarcelineVQ> what is sample from
19:29:24 <allenj12> https://hackage.haskell.org/package/random-extras-0.19/docs/Data-Random-Extras.html
19:29:33 <allenj12> random-extras
19:30:23 <allenj12> but the basics of the question is what is the best way when you need to extract from two differently typed monads to do a computation
19:36:21 <lpaste_> allenj12 pasted “Dealing with two monads” at http://lpaste.net/353409
19:36:29 <allenj12> i made an lpaste if it helps
19:36:50 <johnmendonca> allenj12: i think you want to just say let s = sample 3 rlist
19:37:50 <allenj12> but how would i print it? its still wrapped in Rvar?
19:37:51 <ski> allenj12 : i suppose you might need to use something like `runRVar' on the result of `sample'
19:38:31 <ski> allenj12 : .. in order to get an `IO'-action, i.e.
19:39:40 <allenj12> hmm dont know if that function exists
19:40:30 <ski> allenj12 : see <https://hackage.haskell.org/package/random-fu-0.2.3.0/docs/Data-Random-RVar.html>, apparently
19:41:05 <jle`> allenj12: working with "two monads" inside a do block usually winds up being finding a way to have them both work in some common denominator monad
19:41:11 <jle`> in this case IO works; converta ll your actions to IO
19:42:18 <allenj12> jle`: hmmm so write a wrapper function to turn the result of sample to Rvar? is there an example?
19:44:04 <ski> the result is already `RVar [a]'
19:44:40 <ski> the "wrapper function" `runRVar' could possibly turn it into `IO [a]', given also a random source argument
19:45:25 <allenj12> thats actually kinda confusing, since sample uses the default global source of randomness
19:48:27 <ski> i'd suspect "default global source of randomness" here means the source provided to it by `runRVar', or any similar operation
19:50:22 <MarcelineVQ> it's the source provided by the relevant MonadRandom iirc, a compatible line for your s in the IO monad might look like:   s <- runRVar (sample 3 rlist) StdRandom
19:51:44 <MarcelineVQ> random-fu is a little much to take in at once :X could do with more examples at the top for sure
19:53:13 <allenj12> so there runrvar will convert to IO? im assuming this is because of stdrandom specifically?
19:54:19 <MarcelineVQ> idk, the docs say this about it  https://hackage.haskell.org/package/random-fu-0.2.3.0/docs/Data-Random.html#t:RandomSource   and IO has a MonadRandom instance
19:54:41 <MarcelineVQ> er, MonadRandom has an IO instance :>
20:00:19 <allenj12> this is kinda confusing haha :D
20:00:50 <c_wraith> It's not the easiest starting point.
20:03:21 <johnmendonca> runRVar :: RandomSource m s => RVar a -> s -> m a
20:03:38 <johnmendonca> in this case m will become IO because it is in IO do block
20:03:48 <allenj12> ah gotcha
20:04:35 <allenj12> also what is this error message? • Data constructor not in scope: StdRandom
20:04:35 <allenj12>        • Perhaps you want to add ‘StdRandom’ to the import list
20:04:35 <allenj12>          in the import of ‘Data.Random’
20:04:53 <allenj12> i did the import Data.Random(StdRandom) and it gives me that.
20:05:43 <allenj12> i feel like its telling me to do something I already did
20:07:35 <tswett> Hey everyone. I haven't written much Haskell in, oh, about 15 years?
20:07:43 <tswett> No, that's a little too long. I was 9 then.
20:08:47 <tswett> Anyway, I've been playing around with Scala. One of the interesting things about Scala is that classes ("ordinary" classes, not typeclasses) can have types as members, so you might have, say, a class called Graph, such that if g is a Graph, then g.Node is a type.
20:09:13 <tswett> I read about GHC's extensions and that made me wonder if I can manipulate Haskell into doing something vaguely similar.
20:09:38 <tswett> So here comes my question.
20:09:51 <tswett> Here's some stuff I wrote: http://rextester.com/JJRFT92091
20:10:45 <tswett> A typeclass called Vector, and two types, VectorSpace1 and VectorSpace2. Instances of Vector are vector spaces, essentially. VectorSpace1 and VectorSpace2 are both supposed to represent arbitrary vector spaces, but they're implemented differently.
20:11:40 <tswett> Both of them use existential quantification. A VectorSpace1 simply contains functions with the same types as the members of Vector. A VectorSpace2 just contains a Proxy, but its type variable is constrained to be an instance of Vector.
20:12:06 <tswett> The question: can a VectorSpace1 be turned into a VectorSpace2?
20:17:50 <MarcelineVQ> allenj12: import Data.Random (runRVar, StdRandom(..))   the (..) says to import the data constructors of StdRandom
20:19:30 <ski> tswett : would require a `reflection'-like trick, i suspect
20:20:09 <allenj12> MarcelineVQ: ty
20:20:47 <tswett> ski: yeah, I looked at Data.Reflection. It definitely seems like the sort of thing that would do it, but I can't figure out how.
20:21:30 <ski> the implementation uses `unsafeCoerce'
20:22:47 <ski> tswett : the (or a) basic problem is that one can't put `instance' declarations in `let'/`where'
20:23:54 <ski> and even if one could, i think one'd have to have restrictions on when it's possible, and i'm not sure what you want here would fall within such restrictions
20:25:06 <ski> (making an `instance' declaration for a type that's also declared locally should be ok, i think. but in general not for ones that are visible to third parties. and presumably there could be problems with trying to add instances on existentially hidden types, which is what you'd want here)
20:25:41 <tswett> If you could do that, I think you'd want to say something like: convert1to2 space = let { instance Vector (the "v" inside of "space") where (...) } in VectorSpace2 (Proxy :: Proxy (that "v" again))
20:25:54 <ski> yep
20:26:04 <tswett> And you can't do that, of course.
20:26:11 <ski> `ScopedTypeVariables' should be needed here, as well
20:27:24 <tswett> So we'd need an actual instance declaration in order to convert to VectorSpace2.
20:27:36 <ski> (.. there could be problems with existentials, since with GADTs, sometimes you can recover the hidden type again -- and so conflicting instances could "clash")
20:28:25 <tswett> Let me try to remember hwo I was trying to define a type that could have an actual instance.
20:28:50 <ski> (hm, perhaps there could be problems even if it's not recovered. thinking about stuff like `Set v', where the structure invariant depends on the `Ord v' instance used)
20:29:54 <tswett> data VectorOf space = Reifies space VectorSpace1 => VectorOf (that pesky "v" again)
20:31:01 <tswett> Then if we ignore the issue of the "v", the instance declaration you'd need is just...
20:32:48 <tswett> instance Reifies space VectorSpace1 => Vector (VectorOf space) where { length = vsLength (reflect (Proxy :: Proxy space)); ... }
20:33:48 <tswett> "length _ =", rather, because you need to ignore an argument.
20:36:13 <ski> hm .. and the other two methods ?
20:38:29 <tswett> fromIndArrayMaybe = vsFromIndArrayMaybe (reflect (Proxy :: Proxy space)); toIndArray = vsToIndArray (reflect (Proxy :: Proxy space))
20:38:31 <tswett> Ummm.
20:39:21 <tswett> First off, can I use a "where" clause here to avoid writing (reflect (Proxy :: Proxy space)) three times?
20:39:37 <tswett> Second, I'm forgetting to deal with the wrapping that VectorOf provides.
20:40:41 <tswett> fromIndArrayMaybe = fmap VectorOf vsFromIndArrayMaybe (reflect ...); toIndArray (VectorOf x) = vsToIndArray (reflect ...) x
20:40:44 <tswett> That looks better.
20:40:46 <ski> unfortunately, i don't think you can
20:41:12 <tswett> This is fmap for Maybe.
20:41:14 <ski> for some reason, one can't write e.g. `instance Eq Foo where [(==),(/=)] = undefined'
20:41:27 * ski has no idea why
20:41:31 <cobreadmonster> How do I get command line arguments in Haskell?
20:41:37 <ski> @type getArgs
20:41:39 <lambdabot> error: Variable not in scope: getArgs
20:41:46 <ski> @hoogle getArgs
20:41:50 <lambdabot> System.Environment getArgs :: IO [String]
20:41:50 <lambdabot> System.Posix.Env.ByteString getArgs :: IO [ByteString]
20:41:50 <lambdabot> System.Environment.Compat getArgs :: IO [String]
20:42:03 <ski> @hoogle getProgName
20:42:03 <lambdabot> System.Environment getProgName :: IO String
20:42:04 <lambdabot> System.Environment.Compat getProgName :: IO String
20:42:36 <ski> @hoogle getFullArgs
20:42:37 <lambdabot> GHC.Environment getFullArgs :: IO [String]
20:43:00 <cobreadmonster> ski: Is there a way I can get the whole string? So that spaces become significant?
20:43:11 <geekosaur> only on Windows
20:43:22 <cobreadmonster> geekosaur: as in?
20:43:35 <geekosaur> unixes *do not pass* the command line as a single line. at all
20:44:09 <tswett> Under Linux, your program can't even see the spaces, so there's no way to access the spaces. Under Windows, there's definitely some API call which tells you about the spaces.
20:44:28 <geekosaur> I don't know what the win32 call would be, see if there's documentation in the win32 package
20:44:56 <geekosaur> on unixlikes, the shell parses the command line to a list of strings and passes that to the exec syscall
20:45:15 <tswett> Looks like the Windows API call would be GetCommandLine. https://msdn.microsoft.com/en-us/library/windows/desktop/ms683156(v=vs.85).aspx
20:46:57 <tswett> So I think I *almost* have a way to convert VectorSpace1 to VectorSpace 2. The only missing part is in that data declaration:
20:47:12 <tswett> data VectorOf space = Reifies space VectorSpace1 => VectorOf (the "v" from the VectorSpace1)
20:50:28 <ski> hm, i suppose you need some kind of dependent types
20:51:10 <tswett> GHC doesn't have those at all, does it?
20:51:15 <ski> something like `vsV (reflect (Proxy :: Proxy space))' would extract the type `v', if `vsV :: VectorSpace1 -> *'
20:51:23 <ski> it doesn't
20:52:23 <ski> imagining something like `data VectorSpace1 = VectorSpace1 { vsV :: *,vsLength :: Int,vsFromIndArrayMaybe :: IndArray -> Maybe vsV,vsToIndArray :: vsV -> IndArray }'
20:52:48 * ski supposes Scala is allowing something like that
20:52:55 <tswett> Sure does.
20:53:01 <tswett> Lemme see, that's something like...
20:53:57 <tswett> trait VectorSpace1 { type vsV; def vsLength: Int; def vsFromIndArrayMaybe(array: IndArray): Maybe[vsV]; def vsToIndArray(vector: vsV): IndArray }
20:54:19 <tswett> I'm ignoring several facts about Scala, here, like I'm pretty sure Maybe is called Option in Scala.
20:55:13 <tswett> Then if you have a value space: VectorSpace1, then space.vsV is a type.
20:55:20 <ski> right
20:55:32 <ski> so type expressions can depend on value expressions
20:56:02 <tswett> Yep. It's a very limited form of dependent typing.
20:56:04 <ski> (and not just that data types gets reflected as data kinds on the next level, as in GHC)
20:58:03 <tswett> I think you can cheat and say:
20:58:08 <tswett> data VectorOf space = Reifies space VectorSpace1 => VectorOf Any
20:58:30 <tswett> And don't expose the data constructor, and unsafeCoerce as necessary.
20:59:28 <tswett> And that raises a question: if VectorOf isn't exposed, how *do* you create a VectorOf?
21:03:46 <tswett> Here's something I might want to implement: indArrayToVectorOfMaybe :: forall space. Reifies space VectorSpace1 => Proxy space -> IndArray -> Maybe (VectorOf space)
21:04:30 <tswett> I'm starting to repeat myself a little. An implementation I might want to write would be:
21:05:30 <tswett> indArrayToVectorOfMaybe Proxy array = fmap VectorOf (vsFromIndArrayMaybe (reflect (Proxy :: Proxy space)) array)
21:06:49 <tswett> But that doesn't seem to work because VectorOf can't have a type that allows it to accept that.
21:17:23 <jle`> is there a nice way to get a list of all executables specified by a cabal file
21:17:25 <jle`> maybe using stack?
21:17:30 <tswett> Oooh. I just read this thing, and I think I understand the trick behind reflection now. https://www.schoolofhaskell.com/user/thoughtpolice/using-reflection
21:18:18 <tswett> A typeclass is essentially just a type that the compiler only lets you have one value of. At compile time, class constraints get turned into "real" parameters.
21:19:25 <tswett> Reflection uses unsafeCoerce to pass this parameter in explicitly instead of having it passed implicitly, like it normally is.
21:24:13 <MarcelineVQ> jle`: Cabal can tell you, how are you intending to get the list though? cli?  with Cabal you could do somethig like  map fst . condExecutables <$> readPackageDescription normal "foo.cabal"
21:24:47 <jle`> MarcelineVQ: was going to get it from the command line for usage in a shakefile/makefile
21:25:19 <jle`> i could load in Cabal because i'm using Shake
21:25:33 <jle`> but a CLI method might be nice as well
21:25:43 <jle`> thanks very much, that's probably what i'll be using if there's no cli way :)
21:26:25 <MarcelineVQ> nb that one line requires 3 seperate imports :X
21:26:41 <MarcelineVQ> Cabal is quite split up :>
21:43:29 <bo> hey guys quick question i'm a freshman cs student who's already solid in java and python. Should I add something functional like haskell or sure up my C/C++ thanks
21:44:37 <johnw> bo: is your main interest to find a job, or to better understand computer science principles?
21:45:25 <grayhatter> bo, as someone who knows C, Python, hates java, and tolerates php. -> stay far away from haskell
21:45:47 <bo> definitely CS principles. My ultimate ambition is to go to graduate school for machine learning
21:46:31 <bo> grayhatter: haha why is that is it the paradigm shift or is it something with haskell
21:46:43 <grayhatter> trying to learn haskell is the most painful thing I've ever started. not a single person can explain (in a mannor I can understand) how to make haskell do what I want it to (IO)
21:47:28 <jle`> bo: i think haskell is a good investment for a cs student :)
21:47:46 <grayhatter> jle`: I strongly disagree
21:47:56 <jle`> not only does it help you see things in new ways, but programming haskell is a delight
21:48:22 <jle`> and my haskell programs tend to be my most maintainable and correct ones
21:48:30 <grayhatter> haskell is great for a seasoned programmer with at the very least a little knowledge about more advanced concepts
21:48:42 <bo> grayhatter: aren't some problems easier to solve form a functional point of view as jle' is alluding to
21:48:43 <grayhatter> otherwise it's a hard language to learn, filled with plenty of fustration
21:48:56 <grayhatter> fustration isn't something you should suggest a CS student start with
21:49:22 <grayhatter> jle`: well sure, because if it's not 100% it won't even compile
21:49:51 <jle`> moving errors from runtime to compiletime improves my productivity a lot :)
21:50:02 <grayhatter> that's like saying, I tend to drive the most consistantly when I'm the conductor of a train
21:50:21 <grayhatter> well, no s#!+
21:50:25 <jle`> that's a good metaphor
21:50:31 <jle`> if i could have train tracks pre-built for all my programs
21:50:33 <jle`> i'd be happy
21:50:36 <grayhatter> lol
21:50:45 * grayhatter points at python
21:51:01 <MarcelineVQ> idk about that, it's more like saying my survival rate on the road increases with a car tested before leaving the factory
21:51:38 <jle`> python is the opposite of haskell in this sense, heh.  you can run almost any program, and the language does pretty much nothing to help you write correct programs
21:51:52 <zcourts> bo: as a former CS student I highly recommend Haskell. Not only is it good to learn on its own but even a basic understanding of some of the common idioms and principles helped me be better at other languages including Java and has been great for the shift I made to Scala a few year ago.
21:51:58 <jle`> if haskell is like conducting a train then python is like driving a monster truck
21:52:06 <jle`> except w/o the protection
21:52:22 <jle`> a monster truck that if you ever veer off slightly the whole truck explodes :)
21:52:23 <grayhatter> MarcelineVQ: sure, but when I just need it to roll down the street, I don't really need to have airbags the pass NHTSA specs
21:52:39 <MarcelineVQ> ymmv, I'd want that on my street.
21:52:48 <tswett> bo: learning Haskell probably involves learning a lot of concepts that you won't learn from Java and C++.
21:52:52 <MarcelineVQ> other drivers are crazy you see
21:52:52 <jle`> haskell definitely excels in situations where maintainability and scalability are important
21:53:04 <grayhatter> jle`: nah, you're thinking of java, that's the one that explodes randomly
21:53:19 <tswett> bo: if you want to learn the stuff Haskell will teach you, learn Haskell. If you don't want to learn that stuff, don't learn Haskell.
21:53:22 <bo> very interesting discussion guys. Thanks for the advice zcourts It seems that exposing myself to some Haskell will be good for me
21:53:38 <jle`> i learned haskell to expand my mind but i ended up staying because i like writing correct programs
21:53:42 <grayhatter> bo: I'm smarter for having started with haskell
21:53:45 <grayhatter> that said
21:53:46 <bo> I don't mind working through some frustration either ;)
21:53:48 <grayhatter> I HATE haskell
21:54:28 <tswett> grayhatter: let me know if you're willing to let me try to teach you. :)
21:54:32 <jle`> when i'm writing haskell, most of my code ends up writing itself, and i have to keep track of a lot less things in my head
21:54:36 <tswett> I like to think I'm good at explaining things.
21:54:36 <grayhatter> tswett: I'm all in
21:54:46 <jle`> i write haskell because i'm not smart or clever enough to write python, java, c++
21:54:58 <grayhatter> I've actually started to get better at working it out on my own
21:55:03 <zcourts> bo: one way to work your way up with it is to work through the 99 problems https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems
21:55:09 <tswett> grayhatter: well, how can I help?
21:55:31 <zcourts> or have a read of http://learnyouahaskell.com/chapters 
21:55:33 <grayhatter> but currently, I'm trying to figure out monads
21:56:08 <tswett> grayhatter: fwiw, I've always thought that understanding monads before understanding I/O is the wrong way around.
21:56:41 <grayhatter> everything I read makes me think they should be at least partially interchangeable, and other things I've read make me think monads are like python objects where one is just another with different/extra features
21:56:43 <grayhatter> https://github.com/GrayHatter/devbot/blob/master/devbot.hs#L78
21:57:19 <jle`> for me, trying to learn about monads didn't really help at all
21:57:23 <bo> zcourts: Thanks for the links. I'll definitly use them to help speed up my learning. How powerful is Haskell. Is it more suited for math like R or MATLAB, or should you build GUIs with it
21:57:25 <grayhatter> I'm trying to convert the ReaderT into a StatefulMonadThatICanChangeTheData
21:57:27 <jle`> i just used them
21:57:45 <grayhatter> so that data Bot will hold a list of channels that I can append to
21:58:24 <tswett> Sounds like StateT, then.
21:58:46 <grayhatter> tswett: yeah, I tried swapping that out, but never figured out how to solve the type errors
21:59:21 <grayhatter> no matter what I tried I got type IO ((), Bot) doesnt match IO ()
21:59:41 <buttons840> grayhatter: have you memorized the type of (>>=)?  i've gained many intuitions from thinking about it, although by itself it will not help you understand
21:59:55 <tswett> grayhatter: hmm, right.
22:00:07 <grayhatter> buttons840: no
22:00:42 <grayhatter> in my head `a >>= b` is `evaluate function a, and pipe the output into thing b`
22:01:06 <zcourts> bo: you can do any of the above with it, however as others may point out you'll find some tasks easier than others to achieve (I guess as with any language). I've found that the difficulties I have with Haskell are usually with bending it to fit the paradigm of another lang/framework that I'm familiar with but actually when I have to write a solution from scratch and its designed in and for Haskell I have a much easier time.
22:01:30 <buttons840> :t (>>=)
22:01:33 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:01:51 <tswett> grayhatter: for what it's worth, you can probably do this incrementally. Start by defining type StateNet = StateT Bot IO, and gradually replace occurrences of Net with StateNet elsewhere.
22:02:01 <grayhatter> buttons840: you have no idea how unhelful that is
22:03:15 <buttons840> grayhatter: i am a novice myself, and still don't know that i fully understand monads, so i might know :) -- i would agree it's not an adequet explanation of things by itself, but IMHO it will pay off to memorize it
22:03:43 <tswett> Define a function Net a -> StateNet a, too, to help with the transition.
22:04:25 <buttons840> grayhatter:do you know what a typeclass is?
22:05:09 <bo> zcourts: sweet thanks for the info
22:05:14 <grayhatter> pretend I don't
22:07:02 <buttons840> a Monad is a typeclass -- a typeclass is a group of functions that work only with specific type, a function that is part of a typeclass will only work on types which "implement" that typeclass
22:07:48 <buttons840> grayhatter: i wouldn't worry about knowing how to create your own typeclasses or instances right now
22:09:49 <tswett> grayhatter: for what it's worth, I think I can suggest a find-and-replace that will replace ReaderT with StateT in your entire program, with no type errors in the result.
22:10:18 <grayhatter> tswett: nah, I'd rather figure it out
22:10:36 <grayhatter> ctrl c/v is how I got stuck with ReaderT in the first place
22:11:01 <tswett> All right.
22:11:09 <buttons840> grayhatter: so a Monad is a typeclass, a Monad (in it's concrete haskell impelementation at least) is a collection of functions which only work on specific types -- when someone talks about the IO Monad what they really mean is that the IO type can be used with the Monad functions
22:11:21 <tswett> I already finished typing it out, but I hit ctrl-x instead of enter for you. :D
22:12:53 <grayhatter> buttons840: I don't mean to encourage you to stop
22:13:03 <grayhatter> but I've read hours about monads
22:13:10 <grayhatter> from dozens of sources
22:13:29 <grayhatter> I'm pretty sure I understand what you're saying
22:13:38 <grayhatter> but it's not at all helpful in my understanding
22:13:55 <grayhatter> I have a strong suspision that no one really understands monads
22:14:24 <grayhatter> tswett | Define a function Net a -> StateNet a, too, to help with the transition.
22:14:33 <grayhatter> you can tell me how to write that function though
22:15:04 <grayhatter> you can tell me how to write that function though
22:15:11 <grayhatter> (wrong window(
22:16:35 <buttons840> grayhatter: ok, I'm not a great teacher -- the point I was working up to was that (>>=) is essentially the only Monad function, if it makes sense to implement (>>=) for a type, that type is a Monad
22:17:09 <tswett> grayhatter: sure, lemme see.
22:18:19 <grayhatter> buttons840: can you explain this line to me https://github.com/GrayHatter/devbot/blob/master/devbot.hs#L93
22:18:51 <tswett> migrate :: Net a -> StateNet a; migrate (ReaderT reader) = StateT (\state -> do result <- reader state; return (result, state))
22:18:53 <tswett> That ought to do it.
22:21:11 <grayhatter> lol
22:21:59 <grayhatter> I have NO idea how any of that works
22:23:54 <tswett> Yeah, it's a little abstract...
22:25:56 <tswett> Here, let me give you the beginning of an explanation, and you can tell me whether or not it sounds helpful.
22:26:03 <tswett> We want to write this function:
22:26:19 <ahri> i'm learning haskell, and am trying to understand why my recursive function https://gist.github.com/ahri/95ebcf45d8bbc2c3321b8d338c2f92ea#file-game-hs-L9 ends up inverting my 2d list. i've highlighted one of the lines "at fault" -- i can easily "fix" the problem by changing my use of (:) to instead swap the params around and use ++, but this means wrapping inside another list, and... well i just can't see 
22:26:25 <ahri> how my function is wrong as-is, so i don't want to just fix it without that understanding. can anyone explain what i've done wrong?
22:26:28 <tswett> migrate :: ReaderT Bot IO a -> StateT Bot IO a
22:26:39 <tswett> migrate (ReaderT reader) = ???
22:27:17 <tswett> Now, the definition of ReaderT tells us that "reader" is going to have the type Bot -> IO a here.
22:27:43 <tswett> We have to construct something of type StateT Bot IO a. We can always do that using the StateT constructor, so:
22:27:55 <tswett> migrate (ReaderT reader) = StateT (???)
22:28:17 <tswett> grayhatter: does this sound like it'll be helpful?
22:37:51 <buttons840> grayhatter: to answer you: no, i cannot explain that line, i am not familiar enough with monad transformers
22:40:40 <grayhatter> tswett: sure
22:40:47 <grayhatter> (sorry had to step away)
22:44:29 <tswett> Lemme pause for a moment with my own question.
22:45:03 <tswett> I think I've almost successfully implemented that whole VectorSpace thing I had going on, but I'm confused by what's happening now.
22:45:04 <tswett> http://rextester.com/LHE56858
22:45:38 <tswett> They're all close variations on: "Could not deduce (Reifies s0 (VectorImpl v1)) arising from a use of ‘reflect’ from the context (Reifies space (VectorImpl v))"
22:46:30 <tswett> And they all say that s0 and v1 are ambiguous, so I assume the compiler would be able to deduce that stuff, if it knew that s0 and v1 were supposed to be space and v.
22:47:03 <geekosaur> sounds like you need either asTypeOf or ScopedTypeVariables
22:47:49 <tswett> geekosaur: ahh, ScopedTypeVariables is what I was looking for. Thanks!
22:48:06 <tswett> grayhatter: all right, lemme continue.
22:48:19 <geekosaur> remember that you must explicitly forall the type variables you want in scope in the definition (space and v, here)
22:48:51 <tswett> Here's where we're at:
22:48:52 <tswett> migrate :: ReaderT Bot IO a -> StateT Bot IO a
22:48:52 <tswett> migrate (ReaderT reader) = StateT (???)
22:48:57 <tswett> And we know that reader :: Bot -> IO a.
22:50:03 <grayhatter> what is a
22:50:17 <geekosaur> here it helps to remember that ReaderT and StateT are *functions*
22:50:21 <grayhatter> that's one of the things that gets me about haskell
22:50:27 <tswett> Okay, what does ??? need to be? We look at the definition of StateT, and it tells us that the type we need is Bot -> IO (a, Bot).
22:50:34 <grayhatter> I under stand A -> B 
22:50:41 <grayhatter> put in A, get out B
22:50:43 <tswett> grayhatter: "a" here is a type parameter. When we're using migrate, we can substitute any type in for "a".
22:51:22 <tswett> Inside of migrate, all we know is that "a" is some type.
22:51:27 <the|auriscope> this also means that you know that you won't be manipulating it directly, because you can't
22:51:39 <geekosaur> grayhatter, it's the result of a function, we don't care what it is here, we just need to know how to invoke the function
22:52:15 <tswett> grayhatter: does that answer your question?
22:52:42 <geekosaur> @unmtl ReaderT Bot IO a
22:52:43 <lambdabot> Bot -> IO a
22:53:24 <grayhatter> geekosaur: sure
22:53:42 <grayhatter> ahh
22:53:45 <grayhatter> okay
22:53:55 <geekosaur> tswett, the problem here is you want to transform Bot -> IO a into Bot -> IO (a, Bot)
22:54:09 <romanandreg> has anyone know if one can set cabal flags (for package in development) to an intero (or stack ghc) session?
22:54:20 <romanandreg> stack ghci
22:54:27 <grayhatter> ReaderT Bot IO a is a construct saying a "ReaderT, holding a Bot, Holding ID"
22:54:27 <geekosaur> this might be running the ReaderT and repackaging the result, or it could be impossible
22:54:30 <grayhatter> yes?
22:54:46 <geekosaur> did you see the @unmtl I did?
22:54:52 <geekosaur> ReaderT is a newtype for a function
22:54:57 <geekosaur> it doesn't contain anything
22:55:07 <geekosaur> you pass it a Bot, it produces an IO a
22:55:21 <tswett> geekosaur: that's what I said. :)
22:55:51 <grayhatter> okay
22:56:01 <grayhatter> but how does Pure -> IO
22:56:25 <grayhatter> how do I turn Bot -> IO a
22:56:53 <geekosaur> :t fmap (,?x)
22:56:55 <lambdabot> (?x::t1, Functor f) => f t -> f (t, t1)
22:57:57 <tswett> grayhatter: well, the smart-aleck answer to that question is: however you want.
22:58:05 <tswett> grayhatter: let me see if I can find an example of where you're already doing that.
22:59:01 <grayhatter> tswett: or,
22:59:35 <grayhatter> explain how I pass a String -> ... ->  Net () And get a Net () back out?
22:59:59 <grayhatter> eg. privMsg
23:00:03 <grayhatter> https://github.com/GrayHatter/devbot/blob/master/devbot.hs#L183
23:00:14 <grayhatter> give strings, get Net ()
23:00:35 <geekosaur> :t \(ReaderT r) -> StateT (\bot -> fmap (, bot) (r bot))
23:00:40 <lambdabot> Functor m => ReaderT t m a -> StateT t m a
23:01:11 <tswett> grayhatter: well, privMsg delegates the work of coming up with a "Net ()" to "write".
23:01:46 <grayhatter> tswett: sure
23:01:56 <grayhatter> explain `write` then
23:02:04 <geekosaur> note that this cannot change a ReaderT that reads the Bot into one that updates the Bot; you cannot deconstruct the function and change it to one that does updates, you can only copy the Bot through
23:02:07 <grayhatter> geekosaur: you're about as helpful as Hoogle
23:02:30 <grayhatter> and the worst part, is I know I'm supposed to understand what you're telling me, but I just cant -_-
23:02:37 <geekosaur> those last 2 things I sent were not for you, they were answering tswett's original question
23:03:05 <tswett> grayhatter: so, in "write", you might say that the core question is: how does it turn a "String" into an "IO ()"?
23:03:17 <grayhatter> yes please!
23:03:21 <geekosaur> but tbh I am not sure what you are asking, you have a function, it is not a container it is a function
23:03:42 <grayhatter> geekosaur: sure, then I'm thinking about it all wrong
23:03:48 <geekosaur> you *pass* it something, it does not *contain* something. you cannot know what the function does
23:03:58 <tswett> grayhatter: and the short answer is, it delegates *that* work to the hPrintf function.
23:04:01 <tswett> @type hPrintf
23:04:03 <lambdabot> HPrintfType r => GHC.IO.Handle.Types.Handle -> String -> r
23:04:13 <geekosaur> you just have the function, the only thing you can do is apply it or wrap it in something else
23:04:21 <tswett> Um, that's not the type signature I was expecting.
23:04:29 <geekosaur> heh
23:05:09 <geekosaur> I'm not sure what you were expecting, but I'd advise avoiding printf/hPrintf for examples
23:05:41 <geekosaur> it's a typeclass hack, it *will* confuse yoi
23:05:43 <geekosaur> *you
23:06:36 <tswett> grayhatter: so, the way hPrintf is being *used* is: hPrintf :: Handle -> String -> String -> String -> IO ()
23:07:30 <tswett> grayhatter: so you might be wondering, how does hPrintf turn all that stuff into an "IO ()"?
23:07:54 <grayhatter> I think I know. But I was very wrong about monads, so now I am
23:09:51 <tswett> grayhatter: want me to try to explain?
23:10:16 <grayhatter> tell me if I'm close
23:10:47 <neuromancer42> Has anyone met this? I tried the `rpar` program in the `parconc-examples` package, the resulting time ranges from 0.86s-0.88s to 1.40s-1.46s. Is this normal?
23:11:05 <grayhatter> hPrintf is and IO function in of it self, and because it was called from (in a convoluted way) main. It's able to acces the IO in main
23:11:30 <grayhatter> so it's just passing the original IO of the binary back to main
23:11:34 <grayhatter> am I close?
23:12:00 <tswett> grayhatter: hmm... I'd say that sounds pretty close, at least.
23:12:49 <grayhatter> so I know where IO comes from, now how do I get Bot
23:12:51 <tswett> I would describe hPrintf as being "an IO function in and of itself", yeah. And because it's being called, in a convoluted way, from main, it's able to actually perform I/O actions.
23:13:11 <geekosaur> you don't get Bot
23:13:24 <geekosaur> not directly
23:13:32 <grayhatter> I get Net (), which is Bot -> IO
23:13:46 <geekosaur> you are being passed (a newtype of) a function, you are producing (a newtype of) a function
23:13:58 <geekosaur> the trick is, your function *takes* a Bot
23:14:20 <geekosaur> so you wrap it in a function that takes a Bot, and now you can invoke the function you are passed with that Bot and also do other things with it
23:14:24 <grayhatter> even thought it's not explicitly stating that?
23:14:36 <grayhatter> OH
23:14:42 <geekosaur> *now* you can go look at those two lines, particularly the first one
23:15:42 <geekosaur> I unwrapped the ReaderT to get the function, then wrote my own function to wrap around it that receives a Bot, invokes the ReaderT-d function with it, and then fmap-s the Bot into the result so it conforms to a StateT function... and wrapped that function in StateT
23:16:49 <geekosaur> since the ReaderT-d function produces IO a, I need to use fmap to push the tuple constructor with the copy of Bot "inside" the IO
23:17:07 <geekosaur> (oh, btw, that code probably needs TupleSections extension, it can be rewritten without it though)
23:17:23 <tswett> grayhatter: had an epiphany?
23:17:50 <geekosaur> :t \(ReaderT r) -> StateT (\bot -> fmap (flip (,) bot) (r bot)) -- no longer needs TupleSections
23:17:52 <lambdabot> Functor m => ReaderT t m a -> StateT t m a
23:17:59 <grayhatter> tswett: yeah, it's like a python decorator
23:18:50 <grayhatter> (I hope)
23:18:59 <tswett> Hmm. I know about decorators in Python, but I'm not sure which connection you're seeing.
23:19:36 <grayhatter> the function isn't really getting called, it's being replaced with a monad, that dose "stuff" to the function, then returns what it wants
23:19:42 <grayhatter> in this case, Net ()
23:20:50 <geekosaur> no, the only way the monad is relevant is that we need fmap to get the copy of the Bot where it needs to be
23:20:59 <geekosaur> we're defining a wrapper function over the original one
23:22:18 <geekosaur> so we can intercept whatever Bot was being passed to the original one, and do something extra with it after passing it on  to the original function
23:23:01 <geekosaur> :t \(ReaderT ?r) -> StateT (\bot -> fmap (flip (,) bot) (r bot))
23:23:03 <lambdabot> error: Parse error in pattern: ?r
23:23:10 <geekosaur> whoops
23:24:14 <geekosaur> :t \(ReaderT (r :: _)) -> StateT (\bot -> fmap (flip (,) bot) (r bot))
23:24:16 <lambdabot> error:
23:24:16 <lambdabot>     • Found type wildcard ‘_’ standing for ‘t -> m a’
23:24:16 <lambdabot>       Where: ‘m’ is a rigid type variable bound by
23:24:24 <geekosaur> deliberate error here :p
23:24:39 <tswett> Then it wasn't really an error, was it? :)
23:24:53 <geekosaur> it's only an error instead of a warning because it's in a :t
23:26:17 <tswett> I'm just making a joke based on the fact that by the ordinary definition of "error", there's no such thing as a deliberate error.
23:26:25 <tswett> grayhatter: I need to go to bed. Hope I was able to help a little bit!
23:26:35 <grayhatter> you were
23:26:44 <grayhatter> I'm sitting here about to pass out myself
23:26:51 <grayhatter> I think I need to come back to this tomorrow
23:27:08 <grayhatter> tswett: geekosaur thanks for you help guys
23:27:16 <geekosaur> r :: Bot -> IO a
23:27:35 <johnw> is Will Fancher here?
23:27:41 <geekosaur> \bot -> fmap (flip (,) bot) (r bot) :: Bot -> IO (a, Bot)
23:28:24 <geekosaur> the (r bot) is where I invoke the original function r with the Bot that my function receives, which is what r is expecting
23:29:30 <geekosaur> this produces an (IO a), but I need (IO (a,Bot)), so I use fmap to add to the IO chain something that turns a into (a,Bot) --- namely, flip (,) bot
23:30:18 <geekosaur> (,) is the 2-tuple constructor; it takes two parameters. I need bot to be the second, so I use flip to invert the parameters (,) receives (bot and a)
23:31:18 <geekosaur> (flip (,) bot) could also be written: \a b -> (b,a)
23:32:18 <geekosaur> so now I have a wrapper for a ReaderT function that is suitable to be a StateT function, and I can wrap it in the StateT constructor
