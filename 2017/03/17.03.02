00:00:21 <effectfully_> I meant the warning, sorry, the one that I posted previously, then comes an error, but it just says that a library is not found essentially
00:00:35 <effectfully_> *the library
00:01:29 <ezyang> the specific error message is kind of important; but anyway, I think I know what's going on 
00:02:23 <effectfully_> ezyang: the error is "[1 of 1] Compiling Main             ( src/Main.hs, .stack-work/dist/x86_64-linux/Cabal-1.24.0.0/build/qtah-examples/qtah-examples-tmp/Main.o )          /home/roman/code/qtah/qtah-examples/src/Main.hs:33:1: error:         Failed to load interface for ‘Graphics.UI.Qtah.Widgets.QGraphicsView’"
00:02:29 <effectfully_> but I don't think it's important
00:02:40 <ezyang> that looks important... 
00:02:47 <effectfully_> sorry then
00:02:49 <Guest16373>  OverloadedLabels example code not work：  http://dev.stephendiehl.com/hask/#overloadedlabels
00:03:12 <ezyang> OK, now I am confused 
00:03:24 <ezyang> "Failed to load interface" error has nothing to do with dynamic library loading 
00:03:43 <Theophane> hey raichoo o/
00:03:50 <effectfully_> that interface is what I added to the library against which the executable meant to be built
00:04:22 <ezyang> did you forget to add the module to other-modules/exposed-modules? 
00:04:40 <effectfully_> ouch
00:04:46 <effectfully_> I might
00:04:54 <effectfully_> that would be really stupid
00:05:31 <ezyang> erm, it's not a stupid mistake 
00:05:57 <ezyang> just dumb tools :) (Cabal library problem) 
00:06:02 <ezyang> we even have a bug for it... 
00:08:47 <effectfully_> ezyang: OK, I forgot to add the module to .cabal, thank you very much, I'll fix that, but why does stack still gives me a warning about --enable-executable-dynamic?
00:09:28 <ezyang> well, probably because putting -dynamic in ghc-options is a hack 
00:09:37 <ezyang> and the build system really ought to be informed about this sort of thing 
00:09:42 <effectfully_> I see
00:09:52 <ezyang> like, what if it decided not to actually build the dynamic libraries 
00:12:44 <raichoo> Theophane: hey o/
00:15:12 <effectfully_> yeah, I added all forgotten entries to .cabal and everything builds alright now. Thanks, ezyang
00:18:12 <ezyang> great! 
00:18:25 <ezyang> and may this be a lesson to copy paste error messages :) 
00:18:41 <effectfully_> lesson learned
00:21:45 <ezyang> I guess the original error message is coming from a Setup script or something 
00:21:53 <ezyang> cuz that error string doesn't grep for anything in Cabal codebase 
01:47:30 <howdie> Hey everyone! I have a question: how do I declare a variable in brainfuck?
01:47:57 <howdie> I'm too lazy to read the docs, y'know
01:48:19 <lassulus> seems like the wrong channel to ask imho
01:48:20 <howdie> haskell and brainfuck are both essentially low-level languages, so...
01:48:26 <howdie> lassulus: you think?
01:48:47 <howdie> lassulus: would the python channel work?
01:50:02 <lassulus> ¯\_(ツ)_/¯ 
02:14:27 <sjakobi> Does anyone know what's up with hvr? He hasn't been active on GitHub for several weeks now. Is he on vacation or something?
02:15:34 <quchen> hvr: What’s up? :-)
02:15:46 <kakashiAL> I am programming with javascript and for some time I spend time with haskell
02:15:48 <kakashiAL> I learned a lot of great concepts that makes my code easy to read and reason about
02:15:50 <kakashiAL> I also learned a lot of concepts like identity functors, I implemented one in javascript, now my primitive manipulation are more readable and fun.
02:15:52 <kakashiAL> long story short: I spend now time with category theory. I learned some fancy vocabulary and new definitions, but what can I do with it now?
02:15:54 <kakashiAL> I see no usecase :(
02:16:39 <quchen> I too found the return on investment for category theory extremely low. :-|
02:16:55 <quchen> And in particular, not helpful for my everyday programming at all.
02:17:14 <sjakobi> kakashiAL: I foun this talk by ekmett pretty mindblowing: https://www.youtube.com/watch?v=cB8DapKQz-I
02:17:19 <Rembane> Maybe it will help you see patterns where there was just a mess before.
02:17:49 <sjakobi> He starts off with category theory and ends up with linear time sorting instead of O(n log n)
02:17:57 <michalrus> > match failures are only checked if you use what is inside
02:18:01 <lambdabot>  <hint>:1:33: error: parse error on input ‘if’
02:18:07 <michalrus> jle`: ah, that makes a lot of sense! Thank you!
02:18:12 <michalrus> lambdabot: sorry.
02:18:43 <kakashiAL> sjakobi: if it shows a simple category theroy example implemented in the real world with some benefits, I am happy
02:18:58 <jle`> michalrus: no problem!
02:19:31 <sjakobi> It's not simple for me, but the benefits appear to be real.
02:20:50 <kakashiAL> at the moment category theory makes my code easy to reason about :)
02:21:18 <kakashiAL> well, its more lambda-calc :)
02:50:29 <Onemorenickname_> Hello
02:50:31 <Onemorenickname_> Newbie question
02:51:24 <Onemorenickname_> When I write "data Earley t = Array Items t", I get "expecting type for Items". I know that I have to wrap "Items t" with parenthesis, but I was wondering if there was some infix operator allowing me to do that
02:51:28 <Onemorenickname_> akin to "@@" in ocaml
02:53:07 <Xnuk> What is @@ in OCaml?
02:53:17 <Xnuk> Could you give me some example?
02:55:04 <Onemorenickname_> Xnuk, for instance, if I want to write "pop Some 5", I have to wrap "Some 5" in parenthesis : "pop (Some 5)"
02:55:10 <Onemorenickname_> In ocaml, I can write "pop @@ Some 5"
02:55:38 <Xnuk> pop $ Some 5
02:56:11 <Onemorenickname_> can we do that at the type level ?
02:57:08 <Xnuk> Onemorenickname_: As far as I know, you can't.
02:57:27 <Onemorenickname_> ok, thanks for the value level syntax though, i did not know it :)
03:00:38 <merijn> Xnuk: Well, you can do it on the type level, just not by default :p
03:00:48 <merijn> @define type f $ a = f a
03:00:52 <lambdabot>  Defined.
03:01:17 <merijn> > Right True :: Either e $ Bool
03:01:21 <lambdabot>  Right True
03:02:32 <Xnuk> oh
03:03:47 <Onemorenickname_> merijn, thanks !
03:21:15 <t7> what do i call the difference between some value and the-target/my-desired value?
03:23:15 <Rodenbach> t7: maybe „Computation”?
03:24:28 <opqdonut> heh
03:24:31 <opqdonut> or "diff"
03:27:14 <merijn> delta?
03:27:46 <t7> isnt the delta the difference after update?
03:28:05 <t7> no
03:28:13 <t7> hmm
03:34:07 <merijn> No, just difference
03:34:35 <t7> delta it is then
03:37:46 <iainhallam> Where do I report bugs for the Haskell Platform installer?
03:41:07 <liste> iainhallam: https://github.com/haskell/haskell-platform/issues
03:41:34 <iainhallam> Thanks.
03:47:03 <hiro`> Hey all, just noticed that in my global config the resolver is set to 3.16. I guess that's kinda old now. Is it worth setting it to something more up to date? Does this need to be done manually or is there way to make stack just pick the most recent one?
03:49:48 <jle`> hiro`: i'd just edit it in ~/.stack/global-project/stack.yaml
03:49:49 <Theophane> hiro`: have you tried editing ~/.stack/config.yaml ?
03:50:03 <jle`> i'm not sure if there's a way to make it update automatically, but i'm also not sure if that'd be a good idea
03:50:16 <jle`> but updaitng it is pretty simple
03:50:30 <jle`> and stack keeps track of things so that you can re-use the same installed packages across different snapshots/resolvers
03:50:39 <jle`> so you don't have to re-install everything every time you update your resolver
03:50:57 <jle`> (unless the resolvers use a different version of ghc of course)
03:56:30 <hiro`> I haven't edited yet, just wondered if it was worth doing / not doing. Updating to 8.3 now ...
03:56:53 <iainhallam> So the platform installer can't work with a path other than /usr/local/ghc..., but I would like to install to /opt/haskell.
03:57:10 <iainhallam> Anyone know a way to get it into the right place, or am I going to be compiling from scratch?
03:57:38 <russellw> When installing Haskell on Windows based on the instructions here https://www.haskell.org/platform/ step three, it says paste three lines into Cabal config. The default config file already contains lines assigning at least some of those variables to different values. Is that still intentional? Should I paste the lines from step three at the end of the file or what?
03:58:48 <hiro`> Are there any other steps that need to be followed when updating the global config?
03:59:33 <hiro`> Eg, stack setup, init, etc?
04:07:59 <Onemorenickname_> i'm a newbie
04:08:01 <Onemorenickname_> please dont kill me
04:08:02 <Onemorenickname_> but
04:08:23 <brynser> hiro`: I think you'd need to run stack setup to download and install the appropriate GHC version
04:08:32 <Onemorenickname_> is there a way to tell "Data.Set" : "I don't really mind the Ord of my keys, so just use the pointer address" ?
04:09:27 <Tuplanolla> What address is this, Onemorenickname_?
04:09:49 <Onemorenickname_> Tuplanolla, I come from C
04:10:24 <Tuplanolla> You know the garbage collector moves things around, so even if you were to find the address of an object, it could suddenly stop working.
04:10:39 <Onemorenickname_> Tuplanolla, I was just thinking about that
04:10:46 <Onemorenickname_> I was typing "haskell garbage collection" in google :D
04:11:12 <Tuplanolla> We have mechanisms to pin objects, but those are only used with ffi.
04:11:46 <Onemorenickname_> in haskell, how would you compare (x = 1:x) and (y = 1:y) ?
04:12:01 <brynser> The unordered-containers package has HashSet which doesn't use Ord
04:12:05 <Onemorenickname_> (they were not made from the same expressions, just two results of functions calls happen to have these value)
04:12:26 <Tuplanolla> The comparison of infinite lists is semidecidable, so ideally you wouldn't compare them at all.
04:12:38 <Onemorenickname_> "Deprecated: HashSet is deprecated. Please use Set instead.
04:12:38 <Onemorenickname_> The HashSet is a type synonym for Set for backward compatibility. It is deprecated and will be removed in furture releases."
04:12:56 <brynser> Oh, I didn't know that, sorry
04:13:17 <Onemorenickname_> Tuplanolla, I don't think comparing recursive lists (different from infinite lists) is only semidecidable
04:13:28 <Onemorenickname_> you can do some graph thingy if you can compare reference
04:13:39 <Onemorenickname_> oh
04:13:43 <Onemorenickname_> is there physical equality in haskell ?
04:14:01 <Onemorenickname_> still, this won't give me an ord, even if it exists
04:14:05 <brynser> Onemorenickname_: I think that deprecation warning is for a different HashSet
04:14:17 <brynser> I don't see it here https://hackage.haskell.org/package/unordered-containers-0.2.7.2/docs/Data-HashSet.html
04:15:32 <Onemorenickname_> brynser, i just typed HashSet haskell in google and got https://hackage.haskell.org/package/hashmap-1.3.2/docs/Data-HashSet.html
04:15:43 <Onemorenickname_> so i will pick your package then :)
04:15:54 <brynser> :D
04:16:10 <Onemorenickname_> ddo you know if it can hash recursive lists ?
04:17:50 <Tuplanolla> Hashes or not, what you want is impossible.
04:19:06 <Onemorenickname_> Tuplanolla, I can not have a structure holding recursive lists without duplicates ?
04:19:29 <Onemorenickname_> it's a bit problematic for my program termination
04:20:54 <JuanDaugherty> working the FFI will assuage ur Cness
04:22:00 <Onemorenickname_> hm, there has to be an efficient way to do it
04:22:13 <brynser> russellw: I just installed Haskell Platform on Windows and didn't see the lines in step 3 in my cabal config
04:22:26 <Onemorenickname_> JuanDaugherty, the lists are built in haskell
04:22:28 <JuanDaugherty> interface with some hoary thing, the default xml tools like xerces usw maybe
04:23:40 <Tuplanolla> Hey, are you the Brick man, JuanDaugherty?
04:24:26 <JuanDaugherty> um, i don't think so
04:25:11 <Tuplanolla> There is another J. Daugherty then.
04:25:24 <Tuplanolla> What a coincidence.
04:25:27 <JuanDaugherty> there are indeed
04:25:36 <Rodenbach> Do lenses ship with ghc? Or are they an external lib?
04:25:41 <JuanDaugherty> even other Juan Daughertys
04:25:55 <cocreature> Rodenbach: external libs
04:25:58 <Rodenbach> k
04:27:10 <Tuplanolla> Are people with that name naturally drawn to Haskell or something?
04:27:39 <JuanDaugherty> Arthur Koestler, Roots of Coincidence
04:28:02 <JuanDaugherty> Jung on synchronicity
04:32:39 <absence> i'm using stack with lts-8.3 and get "GHC runtime linker: fatal error: I found a duplicate definition for symbol _js_decode_string" because it's defined in both aeson and json-stream, and then "ghc.EXE: panic! (the 'impossible' happened)". anyone seen this?
04:38:14 <ertes> Onemorenickname_: when programming haskell, you shouldn't think in terms of "stuff in memory"…  you should think in terms of haskell's semantics
04:38:34 <ertes> x = 1:x; y = 1:y  -- these are the same list
04:39:16 <Onemorenickname_> ertes : yep, but that makes some thing highly impractical
04:39:27 <Onemorenickname_> if i have to reason in terms of semantics :
04:39:28 <merijn> Well, sometimes you should think about stuff in memory, but only after you've learned how to do things without doing that :p
04:39:33 <ertes> Onemorenickname_: which things?
04:39:33 <Onemorenickname_> i have a big list
04:40:01 <Onemorenickname_> i have some function accessing multiple times items of the big list, and I want to make a small sublist from these access (without adding several time the same item)
04:40:13 <Onemorenickname_> one solution would be to have boolean marking on the big list for each function call
04:40:27 <ertes> Onemorenickname_: you want sharing?
04:40:27 <Onemorenickname_> and i don't see any other, as I can not check uniqueness
04:40:58 <Onemorenickname_> i don't know what is, so i will say no
04:41:26 <Onemorenickname_> (the big thing is an array, the small thing are lists)
04:41:39 <Onemorenickname_> (hence, I don't want something which require O(N) in space)
04:42:23 <Onemorenickname_> and if i can't compare recursive lists between them (semi-decidable) and can not use physical equality
04:42:24 <ertes> Onemorenickname_: for example if you have a Map or a Set, and you create a new one based on it, the new one will not be an actual memory-copy of the old one
04:42:36 <Onemorenickname_> ertes, ofc
04:42:39 <hiro`> brynser: Thanks. Actually stack ghci is still returning an error message, saying "Error parsing targets: The specified targets matched no packages."
04:42:41 <ertes> Onemorenickname_: the parts that didn't change will be shared, and that's fine in haskell, because values are immutable
04:42:43 <Onemorenickname_> (I expect that from functional languages)
04:42:56 <ertes> Onemorenickname_: that's what i mean by sharing
04:42:59 <Onemorenickname_> i see
04:43:05 <Onemorenickname_> that's not my problem then
04:43:44 <Onemorenickname_> I'm going to eat
04:43:48 <Onemorenickname_> And then make a minimal example
04:43:57 <Onemorenickname_> So it's easier to talk about it
04:44:31 <ertes> Onemorenickname_: yeah, that would be useful
04:51:28 <robertkennedy> Is there anyway in ghci to evaluate type functions?
04:51:47 <Xnuk> :t take
04:51:50 <lambdabot> Int -> [a] -> [a]
04:52:51 <robertkennedy> I meant more like `F Char = Int`
04:54:36 <ertes> robertkennedy: :t undefined :: F Char
04:55:19 <ertes> GHCi seems to evaluate at least closed type families and type synonyms
04:55:29 <robertkennedy> Thats the best I got too. Tight, thanks. 
04:56:42 <ertes> robertkennedy: you can also guess what it evaluates to and have GHC check whether your guess was correct:  () :: (F Char ~ Int) => ()
04:57:03 <ertes> if it was correct, it will just be quiet
04:57:40 <ertes> ah, it does actually print the ()
04:57:59 <ertes> pure () :: (Int ~ Int) => IO ()
05:00:41 <fendor> > foldl (/) 1 [5, 6, 10, 2] :: Expr 
05:00:48 <lambdabot>  mueval-core: Time limit exceeded
05:01:09 <Onemorenickname_> ertes, I'm back, I'm making the small example
05:07:48 <Onemorenickname_> ertes, i'm still making it, but the small example I made was too simple
05:11:06 <Onemorenickname_> well, the simplest example : a mutually recursive tree trasversal and looking at most one time each node
05:11:14 <Onemorenickname_> it basically amounts to that
05:12:52 <Onemorenickname_> a connex graph where a node is represented by its adjacency list
05:13:10 <Onemorenickname_> with no intermediate representation
05:14:47 <ertes> Onemorenickname_: since i rarely work with graphs, take this with a grain of salt: i would probably name the nodes and keep a set of already visited nodes
05:15:11 <ertes> Onemorenickname_: but a nicer approach might be to use a zipper
05:15:21 <Onemorenickname_> ertes, the problem is that traversal are not in sync with one an other
05:15:33 <Onemorenickname_> so i'd have to keep many set of visited nodes at the same time
05:15:39 <Onemorenickname_> i'm looking online what a zipper is
05:16:00 <ertes> if they are mutually recursive, you can just pass the set around, can't you?
05:16:21 <Onemorenickname_> the traversals are not in sync
05:16:31 <Onemorenickname_> but a zipper looks like exactly what i need
05:16:47 <Onemorenickname_> i'm doing what i'm doing because i don't like the named approach
05:16:57 <Onemorenickname_> i can have non-addressed names and so on
05:16:58 <ertes> what do you mean by "not in sync"?
05:17:11 <ertes> they handle different parts of the graph?
05:18:14 <Onemorenickname_> like, traversal A will begin, then stop, then traversal B will begin, then A will continue etc.
05:18:34 <Onemorenickname_> oh, it's just one more argument and one more output
05:18:41 <Onemorenickname_> fair enough
05:18:43 <ertes> exactly
05:18:59 <ertes> in fact only one more argument, if they just use each other
05:19:06 <Onemorenickname_> (they don't)
05:19:07 <Onemorenickname_> i still don't like the O(N*m) space
05:19:11 <Onemorenickname_> i'm checking the zipper
05:19:15 <Onemorenickname_> it sounds very promising
05:20:06 <ertes> Onemorenickname_: in any case you should (at least for the first year or so) drop the notion that values have a fixed memory address, or in fact a memory address at all
05:20:27 <ertes> values might live in your program only implicitly, either because of an optimisation or laziness
05:22:46 <ertes> however, if you *want to*, you can do it the C way…  we have explicit allocation and pointers, but they're mostly used for FFI stuff
05:24:18 <russellw> Given a tool like this https://hackage.haskell.org/package/hfmt that says you can install either with Cabal or Stack, which should I use?
05:24:18 <Onemorenickname_> ertes, i'm trying to find a better way
05:24:29 <russellw> I'm running on Windows, if that makes a difference
05:24:30 <Onemorenickname_> if i'm in #haskell, at least i can find a not-C way
05:34:11 <ertes> Onemorenickname_: another option could be to design your algorithm such that you can't walk the same path twice by removing the edges during your traversal
05:34:32 <ertes> but i don't know how efficient that would be…  you would need to handle dead-ends by backtracking
05:34:46 <ertes> but you're probably doing that anyway
05:34:51 <Onemorenickname_> actually, it's a parsing algorithm
05:34:59 <Onemorenickname_> so the graph is an algebraic grammar graph
05:35:18 <Onemorenickname_> and there /many/ traversals
05:35:23 <Onemorenickname_> not easy to remove edges :(
05:35:30 <ertes> ah, i see
05:35:41 <ertes> something that can't be done with parser combinators?
05:36:17 <Onemorenickname_> there are many things
05:36:30 <Onemorenickname_> i want to be able to plug hooks on partial parsings
05:36:41 <Onemorenickname_> it will be modified from outside
05:36:45 <Onemorenickname_> (by user input)
05:37:06 <Onemorenickname_> and, i want to plug hooks on "character consuption"
05:37:12 <ertes> so the grammer itself changes dynamically in response to concurrent user input?
05:37:16 <Onemorenickname_> yep
05:37:32 <Onemorenickname_> (the hooks on character consumption are so I can make optimization based on my knowledge)
05:37:41 <ertes> well, at least megaparsec has a transformer variant, but as far as i see it can't handle incremental input
05:37:52 <ertes> trifecta can handle incremental input, but doesn't have a transformer variant
05:37:56 <jnj> Any thoughts on how to avoid a seemingly "wrong" warning?: http://lpaste.net/353124
05:38:25 <Onemorenickname_> ertes : basically, i'm making a dynamic language, and I want to provide high level parsing primitives
05:38:26 <ertes> attoparsec is the only combinator library i know that can do both, but it's specialised to efficiently parsing machine-generated stuff
05:38:54 <Onemorenickname_> i'm willing to use any language to make, hence my presence here
05:39:15 <ertes> Onemorenickname_: i would probably create a combinator library
05:39:17 <merijn> ertes: attoparsec doesn't have a transformer variant either, does it?
05:39:28 <ertes> merijn: doesn't it?  wait
05:39:41 <merijn> ertes: It never has had that
05:39:53 <ertes> crap, you're right
05:40:13 <ertes> yeah, custom combinator library then
05:41:49 <Onemorenickname_> ha ha
05:42:21 <Onemorenickname_> 1500 on #haskell, niice
05:44:55 <mbw> Hello everybody, I have a question regarding desugaring list comprehensions. If you take a naive matmul implementation with: dotProd v w = sum (zipWith (*) v w); matmul a b = [ map (dotProd row) (Data.List.transpose b) | row <- a ], is it possible to express this using nested do notation?
05:46:10 <mbw> v, w :: Num a => [a]; a, b :: Num a => [[a]]
05:46:46 <cocreature> mbw: you can’t express zipWith using do notation (well using ApplicativeDo and ZipList you probably can but that’s another topic)
05:47:59 <mbw> The dotProd can stay. But I thought I should be able to express applying the partially applied (dotProd row) to each row of (transpose b).
05:50:10 <mbw> So I thought that it would somehow be possible to do row <- a in a do block, and in a nested do block have something like row' <- (transpose b); return $ dotProd row row'.
05:50:21 <ertes> > [ replicate n c | n <- [1..4] | c <- "abcd" ]
05:50:25 <lambdabot>  ["a","bb","ccc","dddd"]
05:50:38 <cocreature> mbw: sure, that should work exactly like you described
05:50:49 <mbw> I can't get it to parse :(
05:51:59 <mauke> better not tell us what the error is, otherwise we might be able to help you
05:52:32 <mbw> mauke: I am currently trying to phrase it in a manner suitable for discussion, sorry for the delay
05:52:39 <cocreature> mbw: http://lpaste.net/353125
05:52:46 <mauke> why not just post your code and the error message?
05:52:54 <cocreature> however, I don’t think replacing map by do notation is useful
05:53:20 <cocreature> eh you probably need a return around the last do block
05:53:29 <mauke> yeah, I was about to say
05:53:38 <cocreature> that’s what I get for not adding types
05:54:10 <russellw> Okay so I'm using Stack because Google search results seemed to say it was better. It's been updating package index for about ten minutes now, which I wasn't expecting. Is it supposed to be doing that?
05:54:10 <mauke> don't need types if you're a text rewriting system :-)
05:55:29 <mbw> Ah, the return $ do ... part does it.
05:56:01 <cocreature> the return is not necessary for it to parse. it’s “just” necessary  for it to do the right thing :)
05:58:27 <mbw> Now that I think of it, that wasn't really that hard.
06:00:13 <mbw> And regarding replacing map: That's not what I want to do, I just want to be able to do some transformation, playing around with it.
06:00:35 <mbw> Anyway, thanks for your help!
06:38:52 <iainhallam> Is anyone available to help me build Haskell from source on CentOS 7?
06:39:24 <iainhallam> The README in the platform source distribution appears to contradict itself several times and I haven't been able to get platform.sh to run.
06:40:01 <johnw> iainhallam: just wondering, but would it be at all possible to run your Haskell application from Docker?
06:40:08 <johnw> this is what I do, rather than figure out building on CentOS 7
06:40:26 <iainhallam> I'm a sysadmin, and I have to install it for use across 100 teaching machines.
06:40:32 <johnw> ahh
06:40:36 <merijn> iainhallam: Why are you trying to build from source?
06:40:44 <merijn> iainhallam: Why not just install the binary dist?
06:40:45 <johnw> are you going to prepare an .rpm?
06:41:27 <iainhallam> Because the installer doesn't want to put it anywhere other than /usr/local.
06:42:13 <iainhallam> Eventually going to package to RPM, yes.
06:42:24 <iainhallam> My target is /opt/haskell/8
06:43:47 <merijn> iainhallam: Wut?
06:43:53 <ertes> there are at least 20 CentOS machines in the world that have a /nix directory, because a certain ertes didn't want to bother figuring out haskell deployment on CentOS =)
06:44:19 <merijn> I'm using GHC on Scientific Linux, which I'm pretty sure is retarded old CentOS and it Just Works
06:44:21 <c_wraith> ertes: do you know where that ertes is?
06:44:48 <iainhallam> @merijn: Why "wut?"?
06:44:49 <lambdabot> Unknown command, try @list
06:45:01 <merijn> Download bindist, run "./configure --prefix=~/opt/", "make install" and it just works
06:45:24 <merijn> Replace --prefix with whatever you want
06:45:25 <ertes> c_wraith: err…
06:45:27 <iainhallam> Of the whole platform?
06:45:34 <merijn> oh, dunno about platform
06:45:44 <merijn> I just install GHC + cabal
06:45:48 <c_wraith> if you're doing your own setup, why care about the platform?
06:45:55 <c_wraith> Just install what's actually needed
06:46:56 <iainhallam> Because we have a bunch of lecturers who know that their teaching works with platform, and otherwise we'd have to maintain a separate list of requirements for teaching every course, which will cause a lot more work in testing each time.
06:47:33 <iainhallam> Given that I don't use Haskell myself, and they are hard pushed for time as it is, I'd prefer to avoid asking them all to maintain such a list of requirements
06:48:37 <c_wraith> the problem is that the number of people who care about the platform is very small in comparison to the number of people who use haskell.
06:48:56 <iainhallam> Ah, right.
06:49:07 <iainhallam> Am I approaching this wrong, then?
06:49:26 <iainhallam> What's the best way to get a modern GHC and a bunch of modules to each PC?
06:49:27 <merijn> Also, the number of people who care about both CentOS and platform is probably epsilon :p
06:50:07 <iainhallam> Platform seemed like a nice easy way forward, but then it turns into a quagmire of problems to get running in our setup.
06:50:23 <c_wraith> What problems do you actually encounter?
06:51:12 <iainhallam> For starters, the README in the distributions suggests that I need a working ghc, cabal and stack to do the install, but then says that if I check out the GitHub repo, I only need a bindist.
06:51:12 <ertes> doesn't CentOS provide packages for GHC and cabal-install by itself?
06:51:25 <iainhallam> CentOS provides GHC 7.6
06:51:29 <c_wraith> Ouch
06:51:29 <ertes> ouch
06:51:29 <iainhallam> Somewhat old.
06:52:25 <iainhallam> Then the README suggests that to install I should run platform.sh with arguments for a bindist tarball, path to cabal and path to stack, even when I have the repo version.
06:52:45 <iainhallam> It's a little confusing - I'm used to running configure/make to get stuff built.
06:52:46 <c_wraith> if you install a recent ghc bindist, does that work by itself?
06:53:10 <ertes> yeah, i'd go for binaries, too
06:53:43 <brynser> There's a generic linux download here https://www.haskell.org/platform/linux.html#linux-generic
06:54:30 <iainhallam> brynser: That's what I'd been hoping to use
06:54:52 <iainhallam> But if you try to tell it a new prefix, it fails silently, because the scripts redirect errors to /dev/null
06:55:09 <c_wraith> odd, I've used that installer with alternate prefixes all the time
06:55:09 <brynser> Oh :(
06:55:19 <iainhallam> It only supports /usr/local/ghc-n.n.n, which is off limits in our setup.
06:55:51 <iainhallam> c_wraith: where does it put the symlinks in that case?
06:56:12 <c_wraith> It doesn't..  I've always created them myself.
06:56:24 <iainhallam> https://github.com/haskell/haskell-platform/issues/234 is open for supporting non-/usr/local installs.
06:57:18 <iainhallam> And the scripts that would get linked into /usr/local/bin contain the hardcoded path to /usr/local as well.
06:57:46 <c_wraith> This is bizarre, because I build it with a prefix $HOME/ghc-n.n.n all the time
06:58:13 <iainhallam> What command line do you use?
06:58:33 <c_wraith> ./configure --prefix=$HOME/ghc-whateverversion ; make install
06:59:12 <iainhallam> Ah, I'm talking about the platform binary distribution.
06:59:28 <iainhallam> Which has install-haskell-platform.sh as its installer.
06:59:45 <c_wraith> Oh.  Yeah, I'm saying to skip that.  Just install ghc, cabal, and then do global installs on the packages included in the platform.
07:00:04 <c_wraith> It seems easier than fighting with the platform's installer
07:00:24 <iainhallam> This is going to be fun to automate!
07:00:45 <c_wraith> It's not actually that bad.
07:00:51 <iainhallam> :)
07:01:23 <c_wraith> you can pass cabal a list of simultaneous targets, so it's really just one command.  With a very long command line
07:01:54 <iainhallam> At least I can get a script to build that.
07:02:32 <c_wraith> You might be able to make a binary .rpm out of it so that you don't need to run the build on every machine, too
07:03:09 <iainhallam> I've done that with quite a few other packages using an automated packaging system we've written.
07:03:45 <c_wraith> There are some things to watch out for, though.  For this use case, you want to install packages into the global package directory, not your user-local one.
07:04:52 <iainhallam> So the configure shipped with GHC 8.0.2 seems to be using something linked to libgmp.so.3
07:05:04 <c_wraith> ah, there is the libgmp problem. :(
07:05:06 <iainhallam> On CentOS 7 I have only libgmp.so.10!
07:05:41 <iainhallam> You say that like it's a known thing :o)
07:06:17 <c_wraith> libgmp is a source of problems, yeah
07:07:26 <c_wraith> Interesting.  Are you not on Centos 6.7?
07:07:39 <iainhallam> No - CentOS 7.3
07:08:00 <iainhallam> D'oh!
07:08:07 <iainhallam> Just seen the filename I downloaded.
07:08:22 <c_wraith> Well then.  Stupid as it sounds, try the debian 7 version.
07:09:15 <dabd> I installed the haskell layer for spacemacs but I can't figure how to start ghci. Can someone please give me a help?
07:18:54 <iainhallam> Amazingly that Debian 7 version is configured!
07:19:25 <iainhallam> That seems like it needs documentation updates at the very least :o)
07:19:40 <c_wraith> I thought there was a good chance it would work.  Kind of dumb, but the main difference between the different versions is what libgmp and libc they are built against.
07:21:06 <c_wraith> iainhallam: I've got to run, but I expect lots of others will help out
07:21:23 <iainhallam> Thanks!
07:21:35 <iainhallam> If this works, I'm just figuring out the cabal commands to get a full install.
07:22:13 <c_wraith> oh, I was going to warn you - when doing a global install, don't sudo cabal.  It tends to make libraries unusable to non-root users
07:22:29 <kubunto> if i have a datatype of Digit a, how would i write an fmap function to transform it?
07:22:38 <c_wraith> Instead, tell cabal to use sudo as the root command when installing.  There's a command-line flag for that, which I don't recall offhand
07:22:54 <iainhallam> Good to know.
07:23:28 <Tuplanolla> Is there an easy solution to moving and renaming modules?
07:23:58 <merijn> Tuplanolla: Just move them and wait for compiler errors?
07:24:19 <Tuplanolla> Then I need to go through all the other files that depend on them.
07:24:52 <Tuplanolla> I fondly remember Eclipse doing this automatically for Java.
07:26:53 <Tuplanolla> I'll have to pitch this next time someone asks for a learning project idea.
07:35:16 <nitrix> kubunto: How is your data type declared?
07:35:46 <cocreature> Tuplanolla: I’ve done module renaming using sed :)
07:36:24 <Tuplanolla> I just did the equivalent, but shuffling the buffers in Vim is also annoying, cocreature.
07:36:27 <nitrix> kubunto: I have trouble imaginating a parametric `Digit a` type when its goal is to represent a digit. What would be the meaning of `Digit String` or `Digit Bool` ?
07:36:31 <Tuplanolla> I lose all marks etc.
07:36:45 <cocreature> Tuplanolla: yeah I wasn’t suggesting this is a good solution
07:37:57 <kubunto> nitrix: digit wraps int
07:38:16 <nitrix> kubunto: Maybe data Digit = D Int, would make more sense?
07:38:21 <Tuplanolla> Should just stop coming up with bad names in the first place.
07:38:27 <c_wraith> it's funny how the super-static nature of haskell makes it conceptually straight-forward to write all kinds of refactoring tools - and at the same time provides a relatively low incentive to do so because doing it wrong by hand usually results in compiler errors that tell you what to fix.
07:42:07 <nitrix> kubunto: If it isn't algebraic, you might as well use newtype. newtype Digit a = D Int. You could automatically let GHC derive the Functor instance for you with `deriving Functor`, but it wont make much sense since it's the type of that `a` that's varying. You have a phantom type.
07:42:40 <nitrix> kubunto: I do not recognise this as a useful functor, but I could be mistaken.
07:44:18 <c_wraith> nitrix: it comes up sometimes.
07:44:32 <nitrix> kubunto: fmap for `Digit Bool` would infer as fmap :: (Bool -> b) -> f Bool -> f b
07:44:37 <nitrix> kubunto: Is this what you're after?
07:44:37 <c_wraith> nitrix: it's isomorphic to Const Int a
07:44:53 <nitrix> c_wraith: Yeah.
07:45:02 <c_wraith> nitrix: and we know Const is useful in the lensoverse :)
07:45:23 <nitrix> c_wraith: Just a tingly feeling from the level of the question that this might not be what they want.
07:45:23 <kubunto> nitrix: what i want is a way to transform the number within the digit struct using fmap
07:45:36 <c_wraith> nitrix: hey, you're right!
07:45:44 <c_wraith> kubunto: fmap isn't a good choice for that
07:45:47 <johnw> kubunto: that isn't what Functor does; but lenses can do that
07:45:57 <c_wraith> kubunto: since fmap requires being able to change the type arbitrarily
07:46:02 <johnw> also, MonoFunctor could do that
07:46:28 <nitrix> kubunto: What you're describing isn't a Functor. The type of what is changing has to be parametric.
07:46:52 <kubunto> should mention the larger goal of this is to learn more about monads and functors
07:47:52 <kubunto> if a graph data structure doesnt play well with functors then i would love to know what would
07:48:01 <aweinstock> does unsafeDupablePerformIO have any proof obligations/invariants other than thread-safety/purity?
07:51:05 <johnw> kubunto: graphs over arbitrary node types play very well with functors
07:52:16 <nitrix> kubunto: I recommend you to implement the functor instance of the Maybe type.
07:52:35 <nitrix> kubunto: data MyMaybe a = Just a | Nothing
07:52:51 <nitrix> Oh I guess you'd need *MyJust *MyNothing
07:54:18 <nitrix> kubunto: Name it something different from the existing Maybe type and its constructors and see if you can come up with the functor implementation.
07:54:52 <kubunto> nitrix: where is pattern matching in relation to functors?
07:55:04 <nitrix> kubunto: It's probably easier to implement some of these first to build some intuition, then look into what is and isn't a functor.
07:56:44 <nitrix> kubunto: Well, for an algebraic data type to be useful, it's going to have a constructor. And working with that data type (like defining instances that manipulates it) will require you to unwrap/rewrap something at some point, to make it of the type MyMaybe.
07:57:11 <nitrix> kubunto: e.g. 42 :: Int, MyJust 42 :: MyMaybe Int.
07:57:52 <kubunto> nitrix: i played with that concept in tree form the other day
07:58:04 <nitrix> kubunto: You can see the difference in type here, which is caused by us constructing a value of type `MyMaybe Int` using the MyJust constructor.
07:58:04 <kubunto> using a pattern matcher to unwrap values
07:58:31 <nitrix> kubunto: Same thing happens in reverse when you're deconstructing (pattern matching) the data type to work on it.
07:59:02 <nitrix> kubunto: But to answer your question, it's not a requirement of *functors*, just an Haskell data type thing.
07:59:30 <nitrix> kubunto: Here's an easier one for you:  data Simple a = MkSimple a
08:00:22 <nitrix> kubunto: Can you figure out how to implement fmap for this :) ?
08:00:48 <kubunto> fmap would unwrap and re wrap?
08:01:54 <nitrix> Yeah, you'd have to unwrap that Simple type, apply the transformation, then rewrap it.
08:02:31 <nitrix> Effectively transforming what's "inside" of Simple.
08:03:01 <merijn> johnw: And here I am representing my graphs as just arrays of numbers :p
08:03:26 <kubunto> nitrix: i could figure a pattern matching function yes
08:04:03 <nitrix> kubunto: Try it :P Then we can try more complicated ones or see why some types can be functors and others cannot.
08:10:48 <nitrix> kubunto: You can compare you answer with mine (http://lpaste.net/353130)
08:10:55 <kubunto> nitrix: i made curried functor for simple
08:11:08 <nitrix> A curried functor?
08:11:38 <kubunto> the function was fsimple f a
08:12:12 <kubunto> used a pattern match to unwrap it and returned it in the same data structure
08:12:28 <nitrix> You can just paste your line.
08:13:00 <kubunto>  MkSimple a -> MkSimple $ f a
08:14:02 <nitrix> That doesn't seems quite right. Where's your function definition? Where does `f` comes from? If it's a lambda, the syntax isn't correct either.
08:15:02 <nitrix> fmap f (MkSimple x) = MkSimple (f a)
08:15:10 <kubunto> http://lpaste.net/353131
08:15:13 <nitrix> fmap f (MkSimple x) = MkSimple (f x)
08:15:34 <nitrix> kubunto: There you go :D
08:15:51 <kubunto> what is this instance thing?
08:16:40 <nitrix> kubunto: Two details here. (1) You didn't define the functor instance, you created a completely new function named fsimple, when you're supposed to be implementing the `fmap` function of the `Functor` type class, via in instance for your Simple type.
08:17:23 <nitrix> (2) That means getting rid of the extension DeriveFunctor and the `deriving` keyword, they aren't doing anything for you there and probably best to ignore until you're comfortable with functors.
08:18:51 <nitrix> kubunto: I did like the creative use of `case of` though for the pattern matching, but you can achieve the same by pattern matching the arguments of your function definition directly (left hand side of = ).
08:21:28 <nitrix> Your solution hints me you need a slightly better intuitions of type classes. Type classes are a regroupment of types that have a property in common. Usually we leverage that property by providing a common interface for such types (so, a polymorphic function that works for any of the types that defines an instance for that type class).
08:21:44 <nitrix> kubunto: Are you familiar with Java interfaces, possibly?
08:21:55 <kubunto> that comes from scala
08:22:28 <nitrix> What "comes" ?
08:22:48 <kubunto> nitrix: i know pattern matching because of familiarity with scala
08:22:53 <nitrix> Gotcha :P
08:24:16 <nitrix> kubunto: In other words, for the user to be able to use `fmap` on a value of type `Simple`, the author of `Simple` has to define the instance `Functor Simple`.
08:24:58 <ongy> I have a withFile and us hGetContents in it, iirc that's dangerous because of lazy-IO. I want to return an IO Int, what's the best way to force the evaluation of the Int so I know all IO has been done before withFile returns?
08:26:13 <glguy> ongy: You can use Control.Exception.evaluate on the resulting Int inside the withFile.
08:27:10 <merijn> ongy: Depends, which hGetContents?
08:27:34 <ongy> glguy: ah looks good to me. merijn Prelude.hGetContents (for now)
08:27:54 <merijn> ongy: hGetContents is only lazy IO for String and lazy Text/BS
08:28:08 <merijn> ongy: strict Text and BS use a strict hGetContents
08:28:16 <nitrix> kubunto: Maybe you want to give it another try? You seem like you're pretty close for it all to click :)
08:28:30 <ongy> merijn: oh, good to know
08:28:47 <ongy> and makes a lot of sense. But I will use String for now
08:29:28 <kubunto> http://lpaste.net/353132 nitrix 
08:30:01 <kubunto> is fmap supposed to loop over a collection as well?
08:30:10 <nitrix> kubunto: Assuming data Foo a = Baz | Bar a ?
08:30:16 <kubunto> nitrix: yup
08:30:27 <nitrix> kubunto: If that's what you want it to do, sure. The functor instance of [] does this.
08:30:34 <nitrix> > fmap (+1) [1,3,5]
08:30:38 <lambdabot>  [2,4,6]
08:31:28 <kubunto> nitrix: i tried fmap (^2) [Bar 4, Baz] with no luck
08:31:46 <nitrix> @let data Foo a = Baz | Bar a
08:31:48 <kubunto> would have expected [Bar 16, Baz] back
08:31:49 <lambdabot>  Defined.
08:32:12 <nitrix> > (fmap . fmap) (^2) [Bar 4, Baz]
08:32:15 <lambdabot>  error:
08:32:16 <lambdabot>      • Could not deduce (Functor Foo) arising from a use of ‘fmap’
08:32:16 <lambdabot>        from the context: Num b
08:32:24 <nitrix> Oh I forgot the functor instance.
08:32:46 <nitrix> kubunto: You need two fmaps. There are two functors. The [] functor and then the Foo functor.
08:32:50 <nitrix> They're nested.
08:33:12 <kubunto> ah
08:36:43 <kubunto> nitrix: i am not seeing how to get it recursive
08:36:52 <kubunto> like in a tree traversal
08:37:29 <nitrix> kubunto: It can only be recursive for its own type (itself), if that's what you mean. Which is what recursive is.
08:37:40 <nitrix> In the [] and Foo example, they aren't recursive, they're simply nested.
08:38:27 <nitrix> kubunto: Try a binary tree first, maybe?  data Tree a = End | Node (Tree a) a (Tree a) ? 
08:38:46 <kubunto> nitrix: i was doing data Tree a = Leaf a | Branch a (Maybe (Tree a)) (Maybe (Tree a))
08:38:52 <kubunto> without the maybes
08:39:09 <Onemorenickname> hi
08:39:15 <Onemorenickname> i guess i kinda managed my grammar problem
08:39:28 <nitrix> kubunto: So you had what I just wrote, minor your leaves have a value in your example. You don't really need it but it's up to you.
08:39:46 <Onemorenickname> for those interested, all my grammar have now a context, and such, different grammars in different contexts can have the same name
08:39:48 <Onemorenickname> yay
08:40:23 <Onemorenickname> i lose some static checking, still, i have my most desired property
08:40:27 <nitrix> kubunto: data Tree a = End | Node (Tree a) a (Tree a)
08:40:43 <nitrix> kubunto: fmap f End = End
08:41:05 <nitrix> kubunto: fmap f (Node leftTree value rightTree) = ...
08:41:22 <nitrix> kubunto: Does that helps?
08:42:18 <nitrix> You should be able to figure out how to transform the current value, as well as continue the transformation on the left side and right side of the tree as well.
08:43:56 <kubunto> nitrix: i am seeing if i can do it with 2 types
08:44:13 <kubunto> Tree a b
08:44:28 <nitrix> kubunto: You'll have a hard time.
08:44:42 <nitrix> kubunto: `Tree a b` has the wrong kind to be a functor.
08:45:07 <nitrix> kubunto: Given `Tree a b`, only (Tree a) can be a functor.
08:46:34 <kubunto> nitrix: why
08:46:39 <nitrix> Again it's probably best to build a minimal intuition of how to use and create functors... at least to be able to write simple programs, and then slowly learn what is and isn't a functor.
08:46:54 <nitrix> kubunto: The explanation will fly above your head but:
08:47:38 <nitrix> kubunto: The kind of `Tree a b` is `* -> * -> *`. It's a type constructor that expects two other concrete types and produces a concrete type.
08:47:55 <nitrix> kubunto: class Functor (f :: * -> *) where fmap :: (a -> b) -> f a -> f b
08:48:24 <kubunto> it isnt (a b -> c d)
08:48:27 <nitrix> kubunto: The `f` required for `Functor` needs to be a type constructor with kind `* -> *` (taking only a single type as argument, not two).
08:48:49 <nitrix> kubunto: Your notation isn't correct but I get what you're trying to describe.
08:48:52 <nitrix> That'd be a Bifunctor.
08:49:14 <kubunto> sounds like a headache
08:49:20 <nitrix> And they work differently. Their interface is much different too.
08:49:25 <nitrix> bimap f g v
08:49:39 <nitrix> For Bifunctors, there are two transformation functions, rather than one.
08:51:01 <nitrix> I can understand the reaction. Without proper understanding of Functor, it's probably hard to conceptualize why would someone even want Bifunctor, or some infinite functor.
08:51:23 <kubunto> nitrix: whats wrong with this: http://lpaste.net/353133
08:51:36 <nitrix> I'm afraid that reasoning is due to not understanding what functors are used for. You might be conflating records / product types, with functors, which promises something else entirely.
08:52:05 <nitrix> kubunto: But, we're slowly building an intuition now, so that's awesome :D
08:54:05 <nitrix> kubunto: Checking
08:54:28 <nitrix> That seems doable.
08:54:41 <nitrix> @let data Equation d = Digit d | Operator d (Equation d ) (Equation d)
08:54:44 <lambdabot>  Defined.
08:55:07 <nitrix> @let instance Functor Equation where fmap f (Digit d) = Digit (f d); fmap f (Operator a b c) = Operator a (fmap f b) (fmap f c)
08:55:10 <lambdabot>  .L.hs:174:47: error:
08:55:10 <lambdabot>      • Couldn't match type ‘b’ with ‘a’
08:55:10 <lambdabot>        ‘b’ is a rigid type variable bound by
08:55:22 <kubunto> yea thats what i got
08:55:56 <glguy> The f for functor doesn't even need to be a type constructor
08:56:14 <glguy> Something like 'Either ()' will do, too
08:56:46 <nitrix> glguy: That has kind `* -> *`, no? Isn't that a type constructor?
08:56:58 <glguy> No, Either and () are type constructors
08:57:10 <glguy> Type constructor is a category of names, nothing to do with kinds
08:57:15 <nitrix> glguy: Ah interesting point of view.
08:57:29 <glguy> It's just the definition, not really a point of view
08:57:43 <nitrix> glguy: Is there a useful name to describe `Either ()` ?
08:57:51 <nitrix> Partially applied type constructor :3 ?
08:57:53 <glguy> It's a type with kind * -> *
08:57:53 <Cale> It's a type of kind * -> *
08:57:57 <nitrix> Ah okay.
08:58:06 <kubunto> nitrix: i know the either thing
08:58:17 <kubunto> left a | right b
08:58:18 <Cale> You could call it a type function if you like
08:58:52 <nitrix> Cale: I had always associated type construtor with type function mentally, but I now see that a distinction is needed.
09:00:18 <glguy> It's analogous to the value level with constructors Just and True where types don't factor in
09:00:22 <nitrix> glguy: Does this has a correlation with FlexibleInstances?
09:00:59 <glguy> I suppose. Haskell says that instances should specify one type constructor applied to zero or more type variables
09:01:03 <nitrix> glguy: e.g. GHC whining that the pattern for the instance must have the form `T a1 ... am` ?
09:01:13 <glguy> Flexible instances loosens that to allow being applied to other type constructors
09:01:25 <kubunto> nitrix: still cant get the recursive part of the fmap to work
09:01:25 <glguy> or even other non-variable types
09:01:29 <glguy> like (f a)
09:01:33 <nitrix> So isn't it okay to call it a type constructor?
09:01:50 <glguy> To call what a type constructor?
09:02:21 <nitrix> Either applied on (), I doubt that it's less of a type constructor just because it's being applied an argument.
09:02:29 <glguy> No, it's still nothing to do with being a type constructor
09:02:40 <glguy> flexible instances looses the restrictions on making instances, not on what a type constructor is
09:03:02 <glguy> There are type constructors: Either Bool () (->), and there are type variables  a b c d e...
09:03:13 <glguy> from those you can form more interesting types via application
09:03:30 <nitrix> I see, what you're saying is the report would just say `T` as the pattern if `Either ()` was a type constructor and get away with just saying it has to be a type constructor.
09:04:21 <nitrix> Instead, it specifies `T a1 .. am` such that you need a type constructor AND one or more type variables.
09:04:30 <glguy> zero or more
09:04:40 <nitrix> Wait you said zero earlier. Why is the pattern `T a1 .. am` then?
09:04:54 <glguy> m can be 0
09:05:02 <glguy> Consider: Show Int
09:05:07 <nitrix> a1 .. a0 ?
09:05:09 <glguy> T is Int there
09:05:10 <nitrix> That's an odd range.
09:07:01 <nitrix> glguy: I'll try to remember.
09:08:41 <nitrix> glguy: Cale I appreciate the correction :)
09:09:56 <mwilly> ThisPasswordIsNotGood@All
09:10:07 <kubunto> hehe
09:10:25 <kubunto> nitrix: glguy still lost on the recursive fmap call
09:10:29 <dgpratt> not anymore it ain't
09:15:54 <absence> i'm using stack with lts-8.3 and get "GHC runtime linker: fatal error: I found a duplicate definition for symbol _js_decode_string" because it's defined in both aeson and json-stream, and then "ghc.EXE: panic! (the 'impossible' happened)". anyone seen this?
09:21:32 <kubunto> anyone know about recursive fmaping
09:22:09 <mnoonan> maybe?
09:22:21 <mnoonan> what are you trying to do?
09:22:46 <kubunto> i am trying to get this to work: http://lpaste.net/353133
09:23:21 <jle`> kubunto: we need to know the definition of Equation
09:23:32 <kubunto> jle`: see title
09:23:38 <kubunto> it is my bad but it is there
09:23:53 <jle`> ah i see.
09:24:00 <jle`> well, what is the error?
09:24:48 <kubunto> jle`: http://lpaste.net/353135
09:25:41 <glguy> kubunto: In the expression "Operator x (fmap f y) (fmap f z)", x has type 'a', but a value of type 'b' is needed
09:25:56 <jle`> yeah, i'd probably use different variable names
09:26:48 <glguy> so you need to think of a value with type 'b' to fit into "Operator _ (fmap f y) (fmap f z)"
09:27:32 <kubunto> got it
09:28:37 <kubunto> turned the x to (f x)
09:29:31 <ski> yes
09:30:08 <ski> (the error message indicated this position in the code -- "In the first argument of ‘Operator’, namely ‘x’")
09:30:22 <kubunto> so fmap transforms a monad to a monad right?
09:30:33 <jle`> fmap transforms a function into a function
09:30:46 <Sornaensis> fmap applies a function to the contents of a functor
09:30:48 <jle`> it turns an (a -> b) into an (f a -> f b), for any Functor f
09:31:57 <jle`> it doesn't transform any monads.  monads exist at the type level, not at the value level
09:32:08 <kubunto> where would a monad fit into a functor?
09:32:11 <jle`> monads are types, not values, so fmap can't really transform monads because it's a function that works on values
09:32:40 <jle`> monads are a subset of functors
09:33:00 <jle`> some functors are monads, like how some rectangles are squares
09:33:01 <ski> all monads are functors. some functors are monads, some aren't
09:34:36 <kubunto> so what is a monad?
09:35:03 <Sornaensis> @hoogle Monad
09:35:06 <lambdabot> Prelude class Applicative m => Monad m
09:35:06 <lambdabot> module Control.Monad
09:35:06 <lambdabot> Control.Monad class Applicative m => Monad m
09:35:23 <monochrom> "Maybe" is a monad. "IO" is a monad. etc etc.
09:35:41 <Sornaensis> kubunto: http://hackage.haskell.org/package/base-4.9.1.0/docs/Prelude.html#t:Monad
09:35:42 <kubunto> Either?
09:35:47 <Sornaensis> a Monad is a type that instances this class
09:35:53 <Sornaensis> see the 'minimal complete definition'
09:35:54 <mauke> a monad is a type constructor m
09:35:56 <mauke> with some functions
09:36:20 <Sornaensis> a Monad is an applicative and a functor with a definition for (>>=)
09:36:21 <ski> kubunto : `Either' is not a monad, but `Either e' is a monad, for any type `e'
09:36:23 <Sornaensis> :t (>>=)
09:36:24 <mauke> a monad takes a single type parameter, so Int can't be one (no parameter)
09:36:26 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:36:31 <c_wraith> kubunto, the Monad class abstracts over a particular pattern of composition. don't worry about the details - they actually aren't that important 
09:36:37 <glguy> It's not necessary to be a type constructor to be a monad, 'Either a' is a Monad
09:36:49 <mauke> Either can't be one because it takes two parameters. but 'Either a' (for every type a) is a monad
09:37:01 <mauke> hmm. maybe "type constructor" is the wrong word
09:37:08 * mauke redictionarizes
09:37:19 <ski> "type constructor" is used in two difference senses
09:37:23 * ski uses the other sense
09:37:49 <mauke> something of kind * -> * :-)
09:38:08 <ski> type function is a good term, i think :)
09:39:04 <ski> (`ReadS' is a monad, but is not an instance of `Monad')
09:39:36 <monochrom> In want of an oversimplified coarse dichotomy between kind * and other kinds. But oversimplified coarse dichotomies numb the mind.
09:40:18 <mauke> "parameterized type"
09:40:32 <kubunto> how would >>= be used on a maybe?
09:40:37 <monochrom> Just like the one between "values" and "functions" becomes confusing when higher-order functions appear.
09:41:07 <monochrom> Just 5 >>= (\x -> Just (x + x))
09:41:59 <mauke> > Nothing >>= \x -> return (show x)
09:42:02 <lambdabot>  Nothing
09:42:06 <mauke> > Just [1,2,3] >>= \x -> return (show x)
09:42:09 <lambdabot>  Just "[1,2,3]"
09:42:34 <ski> kubunto : one could say that a monad is a certain "pattern" that has been cropping up again and again, and once one recognizes the common pattern, one can write a couple of helper functions to avoid large swathes of repetitive boilerplate code (which would be easy to get a detail wrong here and there)
09:42:56 <ski> kubunto : perhaps "What the hell are Monads?" by Noel Winstanley in 1999 might interest you
09:43:31 <monochrom> There was an ancient small tribe whose number system was the coarse trichotomy "one, two, many".
09:43:48 <mauke> the thing about Monad is that the instances all seem wildly different. yet they all support the same basic interface
09:44:24 <Sornaensis> > let x = Just 1;y = Just 5;z = Just 10 in do { x' <- x; y' <- y; z' <- z; return $ z*y+x }
09:44:28 <lambdabot>  error:
09:44:28 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M467484464745...
09:44:28 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
09:44:43 <monochrom> Very "nice" for students, but very useless.
09:44:59 <Sornaensis> > let x = Just 1;y = Just 5;z = Just 10 in do { x' <- x; y' <- y; z' <- z; return $ z'*y'+x' }
09:45:01 <Sornaensis> derp
09:45:02 <lambdabot>  Just 51
09:45:24 <pikajude> use liftA3 (\ x y z -> z * y + x)
09:45:25 <kubunto> what is >> used for?
09:45:41 <pikajude> kubunto: it's like >>=, but the second operand ignores the result of the first one
09:46:09 <kubunto> ?
09:46:09 <ski> `(>>)' is a variant of `(>>=)' used when the second action one want to sequence after a first one doesn't need to depend on the computed result from the first
09:46:20 <ski> @src (>>)
09:46:20 <lambdabot> m >> k = m >>= \_ -> k
09:46:23 <pikajude> kubunto: x >> y === x >>= \ _ -> y
09:46:42 <pikajude> or that
09:46:55 <kubunto> so it doesnt modify whats inside the monad
09:47:16 <ski> a monad is not something which is passed around at run-time
09:47:28 <pikajude> a monad isn't necessarily a container
09:48:31 <ski> a monad is a type function, together with a couple of functions for operating on values (often called "actions") of a "monadic type", the functions are required to satisfy a few reasonable laws
09:49:00 <ski> as pikajude, the result of a monadic action isn't necessarily "inside" it
09:49:07 <ski> @type getLine
09:49:10 <lambdabot> IO String
09:49:25 <ski> is an I/O action. the string that is its result, when executed, is not contained inside it
09:49:32 <pikajude> @quote /bin/ls
09:49:33 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
09:49:46 <fresheyeball> I know this already has to exist out there
09:49:48 <fresheyeball> newtype F a x = F (a -> x)
09:49:51 <ski> `getLine' is just a "recipe" for how to obtain a string, by communicating with the operating system (possibly communicating with the external world)
09:50:00 <fresheyeball> is there a name for `F` that is out there already?
09:50:04 <ski> fresheyeball : `Reader' ?
09:50:08 <ski> @src Reader
09:50:08 <kubunto> so when i type "a <- getline" that would be using monads?
09:50:09 <lambdabot> type Reader r = ReaderT r Identity
09:50:09 <lambdabot> --OR
09:50:09 <lambdabot> data Reader r a = Reader { runReader :: r -> a }
09:50:27 <fresheyeball> sweet!
09:50:29 <dolio> fresheyeball: (->)
09:50:48 <ski> kubunto : the `<-' symbol is part of the `do'-notation syntax, which is implicitly translated to calls to `(>>=)' and `(>>)', so yes
09:50:55 <pikajude> "using monads" is a very vague phrase
09:51:02 <pikajude> but yes
09:51:09 <fresheyeball> is there a default implimentation for Reader outside of MTL?
09:52:42 <ski> @undo do {x <- Just 2; y <- Nothing; return (x + y)}
09:52:43 <lambdabot> Just 2 >>= \ x -> Nothing >>= \ y -> return (x + y)
09:53:13 <ski> kubunto : that shows how `do'-notation gets translated to calls to `(>>=)' (and `(>>)', though it doesn't occur in this example)
09:53:18 <ski> @src Maybe (>>=)
09:53:18 <lambdabot> (Just x) >>= k = k x
09:53:18 <lambdabot> Nothing  >>= _ = Nothing
09:53:28 <fresheyeball> ski: is Reader a Monoid?
09:53:48 <ski> `Reader rho' is a *monad* (not a monoid), for any type `rho'
09:54:26 <ski> .. it would also be possible to make `Reader rho a' a monoid, if `a' is a monoid, for any types `a' and `rho'
10:03:03 <c_wraith> the underlying type, without the Reader wrapper, already has that Monoid instance! 
10:30:06 <thatrandomguy> Do I have the right feeling that haskell just doesn't lend itself very well to numerical mathematics? I mean it starts right at n-dimensional fields, I have no way to do functions that work on general n-dimensional fields which I defined since I cannot have generic n-tuples. Then if I want to do stuff like numerical simulation or Control of Differential equations the whole problem is that you have some state and you simulate and see ho
10:30:06 <thatrandomguy> w the state evolves over time
10:30:29 <thatrandomguy> Am I just to new to haskell to understand how it is done or should I look out for a multi-paradigm language?
10:31:08 <kuribas> when debugging, what is the difference between evaluating an expression, and :forcing it?
10:31:45 <kuribas> thatrandomguy: numerical computation is normally don't on vectors.
10:32:03 <kuribas> thatrandomguy: or matrixes (which usually use vector underneat).
10:32:15 <kuribas> s/don't/done
10:32:49 <gmalecha> is it possible to import the name of a type family but not import its equations?
10:32:57 <ski> @hackage ad
10:32:58 <lambdabot> http://hackage.haskell.org/package/ad
10:33:10 <ski> "Forward-, reverse- and mixed- mode automatic differentiation combinators with a common API."
10:33:12 <Sornaensis> thatrandomguy: yea it sounds like you want vectors, not tuples
10:34:04 <thatrandomguy> yeah ok maybe I should look further into it first
10:34:28 <kuribas> thatrandomguy: you can use immutable state, or use the ST-monad.
10:34:43 <thatrandomguy> somehow I read the whole tutorial, did all tasks and it was really fun but as soon as I start to think about the stuff I want to do on my own I have a feeling that haskell is not sooo suitable for this as the tutorial tasks where
10:34:56 <thatrandomguy> they where nearly exclusively about parsing
10:35:10 <Cale> were?
10:35:30 <thatrandomguy> Cale, are you asking which tutorial?
10:35:45 <Cale> No, you probably meant "they were"
10:36:08 <thatrandomguy> yes, that is what I meant, thank you
10:36:20 <kuribas> thatrandomguy: haskell lacks support for numerical programs, compared to Python or Julia...
10:36:32 <thatrandomguy> ok thanks everyone I will try to do the stuff with the vector package now
10:36:34 <kuribas> thatrandomguy: but it's not a flaw of the language...
10:36:44 <thatrandomguy> yes pythons numpy is really just the dream of dreams
10:37:03 <kuribas> I'd say haskell is more suited than python.
10:37:12 <mnoonan> thatrandomguy: you may also be interested in Accelerate, at least down the road: https://hackage.haskell.org/package/accelerate-0.15.1.0/docs/Data-Array-Accelerate.html
10:38:28 <kuribas> My feeling about GPU in haskell is that it rarely is worth it.
10:38:29 <thatrandomguy> kuribas, I hope so
10:38:43 <thatrandomguy> I really like haskell and the abstraction it brings
10:39:04 <thatrandomguy> mnoonan, thanks I'll keep that in mind in case I need it
10:39:10 <thatrandomguy> thanks everyone for helping
10:39:35 <Cale> You might find hmatrix helpful
10:39:43 <fresheyeball> I just published a thing http://hackage.haskell.org/package/Empty-0.1.0.0/docs/Control-Empty.html
10:40:42 <Cale> fresheyeball: "annihilation"
10:41:35 <thatrandomguy> Cale, that does look like a good companion for vector
10:42:08 <Cale> thatrandomguy: http://hackage.haskell.org/package/hmatrix-0.18.0.0/docs/Numeric-LinearAlgebra.html
10:42:13 <fresheyeball> Cale: oops
10:45:32 <Rub_ixCube> hello
10:45:50 <Cale> hi
10:47:43 <fresheyeball> Cale: fixed!
10:51:46 <Hello_> Does Haskell have the observable pattern built in?
10:51:55 <Hello_> IE is there is no need for ReactiveX?
10:52:18 <fresheyeball> Hello_: Haskell has Reactive programming
10:52:39 <fresheyeball> but Reactive programming is distinct from the Observable pattern
10:53:29 <fresheyeball> Hello_: imho ReactiveX is kind of a broken idea
10:54:45 <SomeT> for a false beginner in haskell, whats the best genetic algorithm library?
10:55:13 <Hello_> How is it distinct? I'm new to functional programming and have trouble understanding. Doesn't Reactive programming essentially boil down to events being dispatched in an immutable stream and a listener responding to those events, and making changes based purely on the state?
10:56:30 <fresheyeball> Hello_: its distinct in a couple ways. So Rx Observable are writable at any time. Reactive streams are immutable, and so all the information needed to create the stream must be local to stream creation. IE no `onNext`.
10:57:20 <fresheyeball> Rx Observables are also samplable at any time. And most Reactive streams are not samplable, IE you can't just get the last value out at any time.
10:57:56 <fresheyeball> I think you have the core idea of Reactive, but its pretty different from what Rx gives you inpractice.
10:59:15 <kuribas> Hello_: there is reactive-banana
10:59:18 <soulisson> Hi, sorry to bother you. I'm trying to learn about functional programming. I'm not familiar with haskell but I would like to understand the concept of Monad. I read several blog posts and I understood a Monad as an object that contains a value and has some methods like bind.
10:59:19 <fresheyeball> Rx also has this idea of a hot and cold stream, this is mutation built into the core abstraction of an Observable. Haskell does not allow this.
10:59:42 <kuribas> soulisson: Monad is not an object, it's apattern.
11:00:07 <kuribas> soulisson: It's basicly a typeclass, with some laws (which aren't enforced).
11:00:20 <fresheyeball> soulisson: Monad is a type for which you can write two functions, that obey the Monad laws
11:01:08 <fresheyeball> Hello_: so reactive streams cannot be active or inactive, they just are.
11:01:32 <fresheyeball> soulisson: I would start by understanding Functor before learning about Monad
11:01:57 <soulisson> fresheyeball: ok
11:02:36 <kuribas> soulisson: for example, r -> a is a monad, but it doesn't "contain" an "a".
11:02:59 <Hello_> fresheyball: I see.
11:03:03 <kuribas> soulisson: it's purely a type level thing.
11:03:42 <kuribas> (well, except for the laws)
11:03:51 <fresheyeball> soulisson: yeah kuribas is right. Many people trip on this. Monads are not necissarily containers, though many containers are Monads.
11:04:12 <fresheyeball> soulisson: Monad is just more abstract then your intuition tells you at first.
11:04:27 <soulisson> fresheyeball: the notion of type is close to the notion of class in OOP?
11:05:28 <fresheyeball> soulisson: no
11:05:31 <kuribas> soulisson: no
11:06:22 <kuribas> soulisson: you shouldn't try to understand monads before you know what typeclasses are.
11:06:23 <fresheyeball> soulisson: there are Monads in OOP, but you would never know it, because the asbraction of Monad is impossible to express in OOP. You can think of Monad more like its an interface.
11:06:34 <kuribas> soulisson: it will just confuse you.
11:07:10 <fresheyeball> soulisson: type classes are like way more flexible interfaces in OOP
11:07:43 <soulisson> Ok, I'll try. seems a little complex for now. Thanks for your help
11:09:10 <fresheyeball> soulisson: keep on learning!
11:10:21 <shapr> soulisson: I like haskellbook.com, it builds up from functor to applicative to monad
11:10:58 <soulisson> I'll check it
11:15:12 <shapr> soulisson: have you written any Haskell code?
11:15:55 <soulisson> shapr: No, I'm learning FP without any specific language, just the theory for now
11:16:07 <shapr> soulisson: found anything especially interesting?
11:16:13 <fresheyeball> soulisson: I highly recommend learning Haskell to accomplish that
11:17:24 <soulisson> shapr: liked memoization, currying, higher order functions and clojures but Monads are challenging to understand for now
11:17:58 <shapr> soulisson: the best hand wavey explanation I've seen is "decorating function composition"
11:18:25 <Zemyla> Question. Is the specific type of garbage collector part of the RTS chosen, or is it baked deeper into GHC?
11:18:52 <shapr> I think generational garbage collection is baked into GHC, but you can tune the settings.
11:19:16 <soulisson> shapr: I kind of understand the bind function and its usefulness but other than that ...
11:19:53 <sternmull> i would say playing around in haskell with a few basic monads is very helpful to understand their nature. Most of the stuff i read about monads is harder to understand than when you see how it fits together in practice.
11:19:58 <pi___> Hello, When I try to compile Cabal I get this error:
11:19:59 <pi___> gcc: error: dist/build/Distribution/PackageDescription/Parse.dyn_o: No such file or directory
11:20:02 <pi___> `gcc' failed in phase `Linker'. (Exit code: 1)
11:20:25 <shapr> soulisson: how would you describe the usefulness of the bind function?
11:22:04 <soulisson> shapr: I seep it like a pipe between the output a function and the input of another function. I mainly saw it when it comes to handling errors
11:25:16 <pi___> Hello, When I try to compile Cabal I get this error:
11:25:20 <pi___> gcc: error: dist/build/Distribution/PackageDescription/Parse.dyn_o: No such file or directory
11:25:23 <pi___> `gcc' failed in phase `Linker'. (Exit code: 1)
11:27:16 * ski thinks "r -> a is a monad" is vague enough to probably not be that helpful, except to the cognoscenti
11:30:16 <pi___> hello
11:31:46 <SomeT> Why can't I install these? I really need to install these: https://hastebin.com/wopipabegi.txt 
11:33:37 <suppi> SomeT: which ghc version are you using?
11:34:42 <SomeT> the latest
11:34:48 <SomeT> but when I used the older versions
11:34:53 <SomeT> moo package failed to even pick up
11:34:56 <SomeT> can't win lol
11:35:08 <suppi> that package was last updated before Applicative became a superclass of Monad
11:35:34 <SomeT> do I need to edit anything in config file for cabal?
11:36:12 <monochrom> Modify monad-mersenne-random source code, or use an older GHC.
11:36:45 <SomeT> when I used an oldere ghc then it would not find moo
11:37:58 <suppi> what do you mean?
11:38:04 <kuribas> why does the ghci debugger, when I force an expression, still evaluates the subexpression?
11:38:23 <monochrom> Yeah, I don't understand "not find" either. What is the exact error message?
11:39:30 <kuribas> (after :step)
11:40:13 <SomeT> I think I will uninstall everything lol
11:40:18 <SomeT> I think I messed up my installation
11:40:54 <SomeT> http://support.hfm.io/1.3/HaskellCLI-7.10.3-5.18-2.html
11:40:56 <SomeT> I used them
11:41:02 <suppi> did you use cabal without sandboxes?
11:41:04 <SomeT> and now I can't figure out how to fully remove
11:41:08 <SomeT> yes without sandbox
11:41:52 <suppi> sorry i must go, i'll be back later
11:42:54 <SomeT> ok
11:43:14 <kuribas> how annoying...
11:43:36 <kuribas> Either ghci is retarded, or I am missing something...
11:45:45 <kuribas> I don't want it to descent into the expression...
11:46:47 <shapr> gutentag AALLEE, wie geht es?
11:47:29 <kuribas> please tell me, how do I keep ghci from descending into the expression?
11:48:08 <davean> kuribas: what are you talking about?
11:48:19 <kuribas> davean: the ghci debugger
11:48:46 <kuribas> davean: I force _result, but it keeps descending into the expression...
11:48:47 <davean> kuribas: you want to not have it show the evaluation?
11:48:52 <kuribas> davean: no
11:49:16 <davean> kuribas: tracing the evaluation is exactly the thing it does
11:49:38 <kuribas> davean: why would I care about the whole evaluation?
11:49:46 <kuribas> davean: I forced _result for a reason...
11:49:59 <davean> If you don't, why are you using the debugger?
11:50:20 <kuribas> davean: so it can show me the relevant parts...
11:50:28 <SomeT> ok I wiped haskell from my system
11:50:36 <kuribas> davean: it's the _result from a subexpression.
11:50:46 <kuribas> davean: which I don't particularly care about.
11:51:19 <SomeT> on a mac using the software 'haskell for mac' in terms of installing moo shall I install these:  http://support.hfm.io/1.3/HaskellCLI-7.10.3-5.18-2.html or shall I install haskell via brew or both?
11:52:12 <kuribas> davean: I just want to skip it.
11:54:49 <AWizzArd> Is it possible to force ghc to output a binary, even in the presence of type errors
11:56:03 <Sornaensis> yea you can use unsafeCoerce I guess
11:56:16 <ski> AWizzArd : `-fdefer-type-errors' ?
11:56:28 <AWizzArd> ski: thx
11:56:33 <Sornaensis> ski: how does that work
11:56:50 <Sornaensis> type errors at runtime?
11:56:54 <ski> yes
12:14:37 <thatguy> what do I need to install to use https://hackage.haskell.org/package/hmatrix-0.18.0.0/docs/Numeric-LinearAlgebra-Data.html ?
12:14:59 <thatguy> nvm
12:15:25 <suppi> SomeT: best idea i have is to install ghc and cabal binaries and learn how to use them and cabal sandboxes
12:15:38 <suppi> i'm not sure which version will work with the package you want
12:15:42 <suppi> maybe search by date
12:18:18 <suppi> a maybe better way to solve your problem is to modify the source of the package that gives you trouble
12:19:54 <suppi> this might help for cabal sandboxes: http://katychuang.com/cabal-guide/
12:22:32 <abhiroop> Can someone explain what the ⇓ symbol means in PL theory
12:23:42 <Cale> abhiroop: Perhaps "reduces to"? It's hard to say for certain without more context.
12:24:48 <abhiroop> As an example I can provide this ⟨BC, σ0⟩ ⇓ ⟨B · BC, σn⟩ but then I would have to explain all the other variables
12:25:07 <thatguy> if I don't want to lazily return x + s*x' but want the function to actually compute it, how do I do that?
12:25:16 <lyxia> abhiroop: that looks like a reduction relation
12:25:21 <abhiroop> I thought this has a uniform meaning eg : Γ means an environment in any context
12:25:39 <johnw> thatguy: return $! x + s*x
12:26:23 <dolio> What if Γ means the gamma function?
12:26:26 <thatguy> so fun x x' s = ! x + s*x' ? johnw 
12:26:49 <johnw> oh, you didn't mean do-notation return
12:26:53 <suppi> abhiroop: i think 'evaluates to' or 'reduce to' as cale said
12:27:20 <johnw> there's no way for your function to force its own evaluation, that's the caller's job; it can only force the arguments it must evaluate _when it is evaluated_
12:27:42 <thatguy> ah how would I force it as the caller?
12:28:18 <johnw> one way: let !x = myfun blah blah in use x...
12:28:50 <johnw> but still, this only happens when the result of *that* expression is needed
12:29:06 <thatguy> is that considered good practice or should I try to let the stuff evaluated when it is passed as argument?
12:29:20 <johnw> in general I'd say don't worry about strictness until you need to
12:29:33 <thatguy> I am calculating someting which will have the form of x + s*x' + s*x'' + s*x''' + .... and don't want to carry that around with me
12:29:36 <thatguy> in case it gets long
12:30:10 <thatguy> all the xs will also be vectors which scales the whole thing again in memory
12:31:28 <thatguy> johnw, ok thanks then maybe I'll try without strictness for now
12:31:35 <thatguy> but I have the feeling it would be appropriate here
12:31:38 <johnw> I'm not sure if this is the right answer for your situation, but if you want to write pure code that forces results everywhere possible, you might consider: https://hackage.haskell.org/package/strict-identity-0.1.0.0/docs/Control-Monad-StrictIdentity.html
12:33:55 <thatguy> johnw, I will have a look, thank you
12:34:10 <johnw> my spidey sense tells me this isn't the right answer, though
12:34:21 <johnw> so come back if the lazy approach fails
12:35:32 <thatguy> :D I'll trust in your spidey sense that 
12:35:39 <thatguy> *then
12:35:41 <ski> abhiroop : presumably a big-step operational semantics
12:37:11 <abhiroop> Thanks ski and others
12:37:25 <abhiroop> This actually is big step operational semantics
12:38:01 <abhiroop> Corresponding small step operational semantic would e1 --> e1' --> e2
12:38:20 <abhiroop> So I guess it translates to "reduces to"
12:39:59 <ski> "finally reduces to"
12:53:12 <codedmart> Did something change in aeson with parsing integers and floats? I upgrading and now I am seeing an error  `Floating number specified for Integer`
12:58:20 <umib0zu> Hey Haskell. I had a question about Least Fixed Point Semantics here if anyone is interested. https://www.reddit.com/r/AskComputerScience/comments/5x5mkb/why_is_least_fixed_point_semantics_for_recursion/
13:08:56 <thatguy> can anyone tell me why 3.0*vector [1,2] works but let a = 3 :: Double, a * vector [1,2] gives me "couldn't match types?"
13:09:45 <ski> presumably in the former case `3.0' is a vector ?
13:10:21 <thatguy> ski, can I somehow check which type it has in the former case?
13:11:21 <ski> doesn't "couldn't match types?" tell you the involved types ?
13:11:51 <ski> if it's the ordinary `(*)', then it should be the same type as the type of `3.0*vector [1,2]'
13:12:09 <thatguy> ski, it only tells me in the case it does not work
13:12:23 <thatguy> 3.0 * vector [1,2] does what I thought it would: [3.0, 6.0]
13:12:31 <thatguy> the other one gives me the type missmatch
13:12:39 <ski> between which two types ?
13:13:01 <thatguy>     Couldn't match expected type ‘Double’ with actual type ‘Vector ℝ’
13:13:09 <thatguy> where type R = Double
13:13:43 <thatguy> I'm actually pretty impressed that the library used this fancy R for the real numbers
13:14:44 <Tuplanolla> I'm annoyed by it, because it's actually `Double`.
13:15:02 <ski> ok, so the type of `3.0' there is `Vector Double'
13:16:00 <thatguy> so to do scalar multiplication I have to convert my Double to a vector Double and then multiply them?
13:16:16 <thatguy> is that the good practice way or would it be more haskelly to use the Vector.map function?
13:17:36 <thatguy> Tuplanolla, but still I have to admit no other console application spitted me out such fancy mathbb letters until now
13:18:11 <Tuplanolla> You need APL in your life.
13:19:04 <thatguy> Tuplanolla, what is that?
13:19:44 <shapr> A Programming Language
13:19:54 <Tuplanolla> @google apl, a programming language
13:19:55 <lambdabot> https://en.wikipedia.org/wiki/APL_(programming_language)
13:19:56 * ski smiles
13:20:00 <Rembane> J!
13:20:05 <shapr> https://en.wikipedia.org/wiki/APL_(programming_language)
13:20:09 <shapr> Tuplanolla: beat me to it
13:20:52 <shapr> I never did track down an IBM Selectric typewriter APL font golf ball.
13:21:08 <kuribas> The ghci debugger is broken...
13:23:22 <shapr> kuribas: fix it?
13:23:32 <kuribas> shapr: I am not a ghc expert...
13:23:34 <thatguy> :D "A Programming Language" that is a hint what to search for on the one hand and a complete solution on the other hand 
13:23:34 <thatguy> Tuplanolla, from wikipedias first sentence "It uses a large range of special graphic symbols[11] to represent most functions and operators" you are right, it seems I would enjoy it
13:23:35 <thatguy> short at least
13:23:55 <thatguy> so can anyone tell me if there is any difference between using the Vector.map function or converting the scalar to a Vector before multiplying?
13:25:32 <kuribas> thatguy: Vector.map is probably more efficient.
13:25:44 <kuribas> As you don't create another vector.
13:26:04 <Tuplanolla> I wonder if there's a rewrite rule for this.
13:26:28 <Tuplanolla> That would not be surprising.
13:26:36 <thatguy> hmm I just saw that I was confusing the libraries. Vector.map is from the Vector library, I am now using the hmatrix library
13:27:57 <thatguy> but then I'll use fmap
13:28:20 <thatguy> Thanks everyone for helping, I'm gone for today, have a nice evening/day
13:31:15 <Nolrai> Okay so is there a way to have the type wittness what exceptions are thrown by a pure function?
13:31:56 <Nolrai> Even if I am not planing on catching the exception?
13:32:02 <davean> Nolrai: no
13:32:06 <Nolrai> Okay.
13:32:10 <Nolrai> Thanks!
13:32:23 <davean> Nolrai: so, its not even generally theoretically possible
13:32:33 <davean> Nolrai: if you think about it, whats the set of exceptions that might be thrown?
13:32:40 <Nolrai> Right.
13:32:45 <Tuplanolla> @hackage directory
13:32:45 <lambdabot> http://hackage.haskell.org/package/directory
13:32:53 <Tuplanolla> Exceptions are usually documented like this.
13:32:55 <davean> Nolrai: for example bottoms
13:33:10 <davean> we get into a computability issue
13:33:28 <monochrom> I don't think we include bottom as an exception.
13:33:46 <davean> monochrom: some throw exceptions
13:35:42 <Nolrai> Stack overflows, and blackholes for example.
13:39:28 <Nolrai> Hmm. What I should probably really do is explicitly build a error hierarchy and use the Except monad. I wish the type checker could build the sum type for me. That is probably silly of me.
13:39:46 <davean> Nolrai: that already exists
13:39:53 <Nolrai> It does?
13:40:03 <davean> Nolrai: https://hackage.haskell.org/package/control-monad-exception
13:40:41 <monochrom> It is a simplifying and coarse denotational semantics to lump non-termination and head [] (for example) together as "the same" bottom. It makes the math more beautiful. It doesn't mean that we always have to limit ourselves that way. head [] takes very much finite running time to detect.
13:41:28 <davean> monochrom: I never said it was the same ones
13:41:50 <davean> I said you couldn't type all potential exceptions in Haskell's type system
13:42:08 <Tuplanolla> I can't imagine a better way to go insane.
13:42:27 <jacqueline[m]> So...what is "sane" anyway?
13:42:39 <jacqueline[m]> That's just a matter of semantics :D
13:42:55 <monochrom> But you used the wrong reason, or I misread your reason.
13:43:51 <davean> monochrom: I said there was a computability issue
13:44:03 <davean> I never said anything about partial functions in any way shape or form
13:44:06 <monochrom> Then I read correctly. That's the wrong reason.
13:44:16 <davean> monochrom: no?
13:44:31 <monochrom> Because running into head [] is not a computability issue.
13:44:38 <davean> monochrom: Haskell's type system is litterly insufficient to type the exceptions a pure function can throw
13:44:43 <davean> monochrom: I never said it was
13:44:52 <davean> monochrom: I said noything about "head []" in any way
13:45:01 <davean> monochrom: I didn't say there were no exceptions it couldn't type
13:45:07 <davean> I said there were ones it couldn't
13:45:15 <davean> My proof was an existance proof, not a completeness proof
13:46:06 <monochrom> OK, we don't usually include non-termination and similarly uncomputable conditions as exceptions. OK, let's just say I don't.
13:46:39 <davean> monochrom: it throws a Haskell exception in many cases
13:47:04 <Tuplanolla> @hoogle NonTermination
13:47:04 <monochrom> When I hear "exception" I only think of head [] and division by zero and a few more similar things, things that are finite-running-time detectable at the very least.
13:47:07 <lambdabot> Control.Exception data NonTermination
13:47:07 <lambdabot> Control.Exception NonTermination :: NonTermination
13:47:07 <lambdabot> Control.Exception.Base data NonTermination
13:47:41 <davean> monochrom: and yet, thats not Haskell's explicite notion of exception at all
13:48:14 <davean> monochrom: So, all I can say is your definition seems entirely irrelivent in a discussion about Haskell?
13:48:43 <davean> I mean we could have other definitions
13:53:40 <monochrom> OK. Haskell. Computability you said?
13:54:19 <monochrom> Does the so-called "NonTermination" exception, and blackholing and whiteholing and whatnot, fall under computability issue?
13:54:42 <davean> monochrom: in some cases
13:54:53 <davean> They can be generated by obvious means also
13:55:24 <davean> But the limit of when they can be thrown is too unconstrained by Haskell's type system to be generally determinable
13:55:40 <monochrom> Because of the "meaningful" name "NonTermination" which mislead you to think it is really about non-termination?
13:56:03 <davean> monochrom: What do you think I mena by computability?
13:56:10 <davean> monochrom: I specificly meant the halting problem
13:56:29 <davean> Though we could start talking rice's I suppose
14:21:40 <nbro> Hi
14:22:06 <ski>  Lo
14:22:33 <nbro> I’m quite new to Haskell, but let me tell you it seems already a very nice language
14:22:45 <nbro> anyway, I’ve a problem
14:22:47 <benzrf> nbro: :)
14:23:18 <nbro> I think I understood the idea behind the Maybe a type
14:23:29 <nbro> but maybe not enough
14:24:01 <nbro> because I’m asked to write an expression of type Maybe Bool… 
14:24:38 <nbro> but I’m not really sure what would that mean, so I think I didn’t understand what Maybe a…
14:24:50 <nbro> is
14:24:53 <benzrf> what resource are u using?
14:25:29 <nbro> I’m using different ones, including hoogle to search for the documentation (maybe I’m just tired)
14:25:32 <nbro> :D
14:25:32 <ski> for every type `a' (e.g. `Bool'), `Maybe a' is a type (`Maybe Bool' in that example)
14:25:55 <ski> for any type `a', `Nothing' has type `Maybe a'
14:26:06 <ski> for any type `a', if `x' has type `a', then `Just x' has type `Maybe a'
14:26:27 <ski> this is what
14:26:29 <ski> @src Maybe
14:26:30 <lambdabot> data Maybe a = Nothing | Just a
14:26:31 <ski> means
14:26:55 <ski> (which is what the definition of `Maybe' looks like)
14:28:24 <nbro> well, from what I understood Nothing and Just a are data constructors, right?
14:29:01 <ski> `Nothing' and `Just' are data constructors, yes
14:30:24 <nbro> so
14:30:37 <nbro> Just True would be of type Maybe Bool..
14:30:53 <Nolrai> Yes.
14:31:30 <ski> also `Just (not True)'
14:33:46 <ertes> nbro: data Maybe a = Nothing | Just a  -- alternatively you can say that every value of type (Maybe a) is either of the shape Nothing or of the shape (Just x), where 'x' is of type 'a'
14:34:59 <ertes> data Bool = False | True  -- just like every value of type Bool is either of the shape False or of the shape True
14:38:48 <nbro> but Nothing has type Maybe a only not to break the type system, let’s say, right?
14:39:48 <ertes> nbro: what do you mean?
14:40:32 <ertes> Nothing is a legal value of type (Maybe a) for any 'a'
14:41:54 <monochrom> (What is there to break?)
14:41:55 <mniip> you're saying "only not to break the type system" as if it were some kind of workaround
14:42:04 <mniip> however that's just how ADTs work
14:42:10 <nbro> well, this nothing can somehow be compared with the nils, nones, and nulls of other programming languages, but in those programming languages, for example in Python, None is of type NoneType, but in Haskell the trick to indicate that something could be or contain indeed nothing is by “wrapping” our types in this Maybe a
14:42:13 <mniip> it's a feature and whatnot
14:42:49 <mniip> nbro, python is irrelevant because types are properties of values there
14:43:23 <mniip> (like basically any other dynamically typed langauge)
14:43:25 <monochrom> I don't really understand that sentence. But Python has subtyping and Haskell doesn't. Therefore Python's none story can be different from Haskell's Nothing story.
14:43:49 <mniip> hmm, subtyping, that's a nice way too look at it
14:43:58 <monochrom> And neither approach is to prevent "breaking", whatever that means.
14:44:30 <nbro> I’m just comparing the conceptual way of representing nothing in different languages… 
14:44:35 <mniip> nbro, haskell, for example, has a truly empty type
14:44:41 <mniip> a type of which no value exists
14:44:43 <nbro> in order to understand better the one in Haskell
14:44:54 <mniip> any computation that has a result of that type must either error or not terminate
14:45:27 <monochrom> Or alternatively but equivalently, every language design is to prevent "breaking" something, so you could tautologically say that everything done in Haskell is to prevent breaking the Haskell way, everything done in Python is to prevent breaking the Python way, etc etc, which sounds really nice but is informationless.
14:45:40 <c_wraith> nbro, the thing about Haskell is that Nothing isn't a special value and Maybe isn't a special type. they're completely normal things defined in pure haskell in the standard library. 
14:46:14 <monochrom> To sum up, Python goes subtype polymorphism, Haskell goes parametric polymorphism. And there is a sense in which they are opposites.
14:46:28 <nbro> monochrom: if this Maybe a wouldn’t have been invited, how could you represent the absence of something in Haskell?
14:46:35 <ski> nbro : conceptually, `Maybe T' "adds a new value to `T'". this means that `Maybe (Maybe T)' will now how two values in addition to the ones of form `Just (Just x)', with `x' of type `T'. this is unlike the story with nulls
14:46:35 <nbro> *invented
14:46:44 <mniip> nbro, invent your own?
14:46:50 <monochrom> It can always be invented and reinvented.
14:46:59 <c_wraith> nbro, you'd create a type just like it. there's nothing special about it. no magic. 
14:47:00 <monochrom> In fact I know that the GHC API reinvented it once.
14:47:02 <nbro> @monochrom I mean, the concept
14:47:03 <lambdabot> Unknown command, try @list
14:47:08 <mniip> @let data Maybe' a = Nothing' | Just' a
14:47:11 <lambdabot>  Defined.
14:47:20 <monochrom> And some http library revinvented it too.
14:47:25 <nbro> suppose for a moment that nobody managed to invent such a thing
14:47:33 <monochrom> Yes, the concept. It can always be reinvented.
14:47:46 <mniip> > Just' 3
14:47:47 <c_wraith> nbro, it's basically impossible to not invent when you have algebraic data types. 
14:47:50 <lambdabot>  Just' 3
14:47:52 <mniip> > Nothing'
14:47:56 <lambdabot>  Nothing'
14:48:00 <monochrom> OK, suppose that. Then we can prove true = false too. Yes, it's a vacuous premise.
14:48:36 <monochrom> Alternatively, why don't you suppose python did not have class and/or objects?
14:49:10 <mniip> nbro, well, suppose we want to represent absence of something in haskell
14:49:29 <mniip> e.g we want a type that is either an int or nothing
14:49:39 <mniip> data FancyInt = AnInt Int | NoInt
14:49:52 <mniip> but wait we want it for more types than just Int
14:49:58 <mniip> why not make it parametric
14:50:05 <mniip> data FancyThing a = AThing a | NoThing
14:50:14 <mniip> oops invented maybe
14:50:52 <monochrom> In Python you can use "none" wherever a list is expected, or a set is expected, or a date is expected, etc etc. This is why I mentioned subtyping. "none" is of NoneType but the thing is NoneType is a subtype of essentially all other types.
14:51:06 <monochrom> But Haskell doesn't do that. Haskell does the opposite.
14:51:26 <mniip> monochrom, huh?
14:51:39 <monochrom> In Haskell you can't use "Nothing" wherever a list is expected, or a set is expected, or a date expected. You can only use it where a "Maybe XXX" is expected.
14:51:57 <nbro> @mniip maybe I shouldn’t have said “not to break the type system”, which seems like one’s blaspheming for a religious person
14:51:57 <lambdabot> Unknown command, try @list
14:52:07 <mniip> monochrom, fairly sure you can't use None everywhere in python
14:52:25 <mniip> however you might have a different idea of what 'types' really mean in python
14:52:35 <mniip> def foo(x): return x[1]
14:52:42 <mniip> does that function take None? I don't think so
14:52:55 <mbw> What are the modules Data.Array.IO.Safe and the other "Safe" ones for? I can't see any differences...
14:53:13 <mbw> Between those and the parent modules, that is
14:53:19 <monochrom> OK, I was wrong, but I think it can be saved. Can that function return None?
14:53:39 <mniip> sure
14:53:44 <mniip> it returns exists a. a
14:53:56 <monochrom> OK, so s/use/return/ and I think I'm good.
14:53:56 <Tuplanolla> It seems to have no problems taking `None` for me, mniip.
14:54:33 <mniip> but NoneType has no __getitem__
14:55:14 <Tuplanolla> For sure, but that happens after you have given the procedure your `None`.
14:55:37 <Ch3ck> What is a blackhole, as it relates to haskell or programming?
14:55:37 <mniip> nbro, not really, we are not closed-minded, it's just that your proposition is actually of little logical sense
14:55:38 <Tuplanolla> Perhaps I don't know what to expect here.
14:55:38 <nbro> and maybe Python wasn’t the best example to compare things with Haskell, lol
14:55:55 <mniip> Tuplanolla, then all functions are universal in python
14:55:57 <mniip> just some are partial
14:56:03 <Tuplanolla> ...yes?
14:56:05 <mniip> that's a useless representation
14:56:22 <mniip> monochrom hinted at subtyping as a useful representation of typing rules in python
14:56:41 <nbro> @mniip ok, no problem, give me one month and you will see another master in haskell :D lol
14:56:42 <lambdabot> Unknown command, try @list
14:56:54 <mniip> month huh
14:57:01 <mbw> Does anybody know what the "Safe" variants of the Data.Array headers are for? Does it have to do with safe haskell?
14:57:02 <lyxia> mbw: note the Safe Haskell field in the header.
14:57:13 <monochrom> I am not religious. This is why I questioned "what is there to break?"
14:57:14 <mniip> I've been here for 3 years and I wouldn't call myself "master" by any chance
14:57:53 <mbw> lyxia: Ok, that confirms my suspicion. But in what way do these modules differ? Is the API more stable?
14:58:12 <geppettodivacin> Ch3ck: Pretty sure that it usually refers to a function that can never return, but isn't detectable as a loop.
14:58:47 <mniip> no
14:58:51 <monochrom> isn't? is?
14:59:12 <mniip> Ch3ck, a blackhole is a thunk that is currently being evaluated by ghc
14:59:26 <mniip> it is distinctly highlighted for a number of reasons
14:59:30 <monochrom> Because if the computer bothers to print a "black hole" message, certainly something has been detected.
15:00:34 <mniip> if one thread wants to evaluate a thunk and it's a blackhole, it knows another thread is evaluating it, and it can subscribe to the blackhole to let the evaluating thread wake it up once the computation is done
15:00:43 <lyxia> mbw: I don't know, sorry.
15:00:50 <mniip> and if a thread evaluates a blackhole that it is itself evaluating, it'll know that it's stuck in a loop
15:01:01 <mniip> or something like that
15:01:22 <nbro> @mniip by master I mean to master the concepts behind the programming language, not all features or libraries, etc ;)
15:01:22 <lambdabot> Unknown command, try @list
15:01:23 <mniip> would you like to know more? read the ghc commentary and/or the stg paper
15:01:34 <mniip> nbro, you underestimate its power
15:02:19 <nbro> @mniip maybe yes :D
15:02:20 <lambdabot> Unknown command, try @list
15:02:28 <geppettodivacin> Ah, I too have learned something. Neat.
15:03:45 <mbw> lyxia: No sweat. At least I know what to look up next. I have time...
15:04:35 <ertes> nbro: don't think of Maybe or Nothing as something special
15:04:50 <ertes> Maybe does not have any special status…  in fact it's defined in a library
15:05:09 <ertes> however, haskell itself is special to a certain degree in that it does not have an observable "null"
15:05:37 <mniip> base is a special enough library so that's a poor argument :p
15:05:52 <ertes> base certainly is, but Maybe isn't =)
15:05:53 <Koterpillar> ertes: that is not special; null is special
15:06:24 <ertes> Koterpillar: in the sense that a lot of languages have that special value…  haskell is more natural, yes, but it's certainly the special one among most other languages
15:06:37 <ertes> in that those other languages are unnatural
15:06:41 <monochrom> "special relativity"
15:07:11 <nbro> ahah
15:07:13 * ski . o O ( "Null References: The Billion Dollar Mistake" by Tony Hoare in 2009-08-25 at <https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare> )
15:07:25 <nbro> nice conversations here
15:07:30 <mniip> terminologicaly SR is a special case of GR so all is well
15:07:47 <monochrom> yeah just punning
15:09:40 <mbw> Ok, I just read about safe haskell: https://wiki.haskell.org/Safe_Haskell. Quote: "For typical Haskell programmers, using {-# LANGUAGE Safe #-} will be like -Wall: something that is considered good practice from a hygiene point of view." Is there general consensus on this, or is it not widely used after all?
15:11:07 <mbw> Btw the billion dollar mistake was not a null pointer dereference, but something like a comma instead of a colon in a FORTRAN format string, if I remember correctly.
15:11:57 <ertes> in that sense the billion dollar mistake was FORTRAN
15:12:33 <mbw> That's probably the gist of Backus' Turing award speech :)
15:13:31 <ertes> i also liked peter sewell's examination: https://media.ccc.de/v/31c3_-_6574_-_en_-_saal_1_-_201412301245_-_why_are_computers_so_and_what_can_we_do_about_it_-_peter_sewell
15:15:26 <monochrom> Wait, so Backus invented functional programming for avoiding comma and colon typos?!
15:16:28 <mbw> Even if so, he didn't succeed. Fortran is still around.
15:16:46 <Nolrai> Ch3ck : It's a way for the compiler to catch some infinite loops, basically.
15:17:30 <geekosaur> comma instead of period is actually an urban legend, iirc. but mostly that one is just lexing; pre-fortran90 considered DO 10 I = 1. 10 (typo period for comma in a loop starter) and DO10I = 1.10 (assignment) the same...
15:18:29 <Ch3ck> Nolrai, this is the first time I'm hearing of the concept. It is unique to haskell?
15:18:51 <mbw> Good old "IMPLICIT DOUBLE PRECISION (A-H,O-Z)"
15:19:12 <nbro> thanks for your help! I will probably come back ;) 
15:20:30 <mbw> If you think about it, python has this...
15:22:07 <mniip> Nolrai, uhh
15:22:11 <mniip> that's somewhat misleading too
15:22:26 <mniip> its primary purpose is multithreading
15:22:46 <monochrom> detecting a special kind of nontermination is a side effect
15:23:57 <Nolrai> <mniip> : Ah, I did not know that.
15:24:15 <Nolrai> Hmm. I wonder what I read that led me astray.
15:26:18 <monochrom> It doesn't take a lot of reading. It is an easy guess from personal experience. The thing is that it is non-obvious why the runtime system even bothers.
15:33:29 <Ch3ck> So is it unique to haskell?
15:33:36 <Ch3ck> I'm a FP and Haskell newbie :-)
15:35:19 <monochrom> Oh yikes haha "The obsolete language options -XPolymorphicComponents and -XRank2Types are synonyms for -XRankNTypes"  (GHC 8.0.2 or maybe earlier)
15:35:57 <glguy> That happened before GHC 8, I don't remember when in the 7 series it was, though
15:38:16 <ertes> yeah, Rank2Types was obsoleted a long time ago
15:38:35 <monochrom> Ah OK.
15:39:02 <monochrom> I agree that if you use PolymorphicComponents then you're very likely to also use RankNTypes.
15:39:08 <ertes> IMO it was a pointless extension anyway, because you could always just use a rank-2 subset of RankNTypes
15:40:15 <monochrom> The lack of a significant second compiler that makes a difference.
15:40:20 <mniip> Ch3ck, it's unique to STG
15:40:52 <mniip> the graph reduction machine implementation as it appears in GHC
15:41:14 <mniip> once again, read up on ghc commentary and/or the stg paper
15:41:15 <Ch3ck> mniip, what's STG?
15:41:23 <Ch3ck> Ahh I see
15:41:26 <monochrom> Because IIRC there is still a theoretical difference between rank-2 and rank-all-in, and it could cause a difference in how-hard-to-implement too.
15:41:34 <geppettodivacin> So not only Haskell specific, but GHC specific.
15:42:04 <mniip> monochrom, there's a terminating rank2 checker
15:42:09 <vtomole> Any other "fleshed out" haskell implementations other than ghc?
15:42:12 <mniip> not a rank3 however
15:42:54 <ertes> Ch3ck: in fact it's specific to the GHC *compiler*
15:43:01 <ertes> > let x = x in x
15:43:07 <lambdabot>  mueval-core: Time limit exceeded
15:43:40 <ertes> a compiled program would have thrown an exception your way
15:43:46 * ski . o O ( the Glasgow Haskell Compiler compiler )
15:43:59 <Ptival> is there a good reason why Tasty Assertions can't be written agnostically w.r.t. what type of check is to be performed?
15:44:01 <davean> vtomole: there have been a few
15:44:17 <kuribas> If I force an expression in the ghci debugger, then after :step, it's again unevaluated, it's a bug right?
15:44:23 <davean> vtomole: GHC is the one that has the energy to be regularly maintained though, the others end up tending to be rather nitch in practice
15:44:29 <mniip> kuribas, it could be polymorphic
15:44:29 <glguy> kuribas: or it has a polymorphic type
15:44:42 <kuribas> not polymorphic...
15:44:49 <mniip> however RTTI is complicated enough that it's not out of consideration
15:44:50 <ertes> vtomole: haste is a non-GHC haskell compiler that targets JS
15:44:53 <ertes> it still works
15:45:06 <kuribas> mniip: glguy, a Double
15:45:18 <mniip> are you sure it's the same expression
15:45:47 <ertes> vtomole: other compilers like JHC or UHC technically still work, but they aren't that useful, because you can forget most of hackage (haste has the same problem and is becoming obsolete – GHCJS)
15:45:52 <kuribas> mniip: I force the expression, but after :step ghci still goes into it...
15:45:54 <glguy> It's not enough to force an arbitrary expression, you need to force a particular variable
15:45:55 <kuribas> mniip: very annoying
15:46:06 <kuribas> glguy: I force _result
15:46:59 <kuribas> since it's already evaluated, why does it "enter" the expression again?
15:47:24 <mniip> 1488498153 [02:42:33] <ertes> Ch3ck: in fact it's specific to the GHC *compiler*
15:47:29 <mniip> that still creates a black hole
15:47:35 <mniip> just that it doesn't error out
15:47:50 <mniip> the thread subscribes to its own blackhole and everything goes into sleep
15:48:42 <Ch3ck> mniip, ertes I see
15:48:59 <Ch3ck> I'm still learning functional programming. I decided to take on haskell since I hear it's the core
15:49:26 <Ch3ck> Alot of my friends have told me stories about "monads" and "contextual structures"
15:49:40 <Ch3ck> Just interesting to find out how "hard" they are to understand ;-)
15:50:17 <ertes> Ch3ck: depends on how well you can deal with symbolic/algebraic thinking =)
15:50:18 <mniip> depends on what level of understanding you're aiming for
15:50:49 <mniip> haskell (and abstract algebra) is one of those things where being able to reason about, and understanding, are two very different thing
15:50:49 <mniip> s
15:51:22 <kuribas> mniip, glguy: it isn't supposed to do that, is it?
15:52:11 <Ch3ck> mniip, I see
15:52:26 <ertes> Ch3ck: it helps to look at simpler structures first, like monoids, but try to accept that they are really just a set of mathematical axioms
15:52:29 <Ch3ck> I'm not at that point yet, just installed the GHC and sifting my way through
15:52:32 <glguy> kuribas: I don't know how _result is supposed to work, but if _result isn't a variable in your original program then it doesn't seem surprising that evaluating it might not affec your original program
15:52:43 <glguy> Maybe put the code and terminal session on lpaste?
15:53:01 <kuribas> ok
15:53:32 <kuribas> glguy: _result is the result of the expression that is under focus by ghci.
15:55:07 <kuribas> glguy: so after forcing it, it wouldn't need to descend into the expression, at least that's my understanding.
15:55:49 <kuribas> I'll paste something next time...
15:55:53 <glguy> or it's just a new name created with a copy of the expression that is under focus
15:56:14 <kuribas> glguy: if so, how do I make ghci skip that expression?
15:57:39 * kuribas guesses nobody else uses the ghci debugger...
15:57:46 <glguy> I don't know. GHCi's debugger isn't part of my workflow
15:58:40 <Ptival> what do I need to do to be able to import `test/Foo.hs` from `test/Bar.hs`?
15:59:55 <robkennedy> Ptival: if your cabal file says "hs-source-dir: test" it should work
16:00:04 <Ptival> robkennedy: thanks
16:26:33 <dmj`> Ptival: you might need to start ghc with -itest as well
16:30:00 <dmj`> ghci*
16:31:42 <robkennedy> Just checking this
16:32:09 <robkennedy> :t \x y -> x / y
16:32:11 <lambdabot> Fractional a => a -> a -> a
16:33:18 <Koterpillar> robkennedy: FYI, /msg lambdabot :t "This works too"
16:41:43 <metalbot> anyone know the authors of "Real World Haskell"?
16:41:59 <metalbot> there's a bizarre chapter of their book being sold on Amazon by a different author...
16:42:23 <Clint> is it one that's not completely out of date?
16:42:43 <metalbot> no - it's literally the text of their chapter on monads republished under a new name
16:43:32 <metalbot> https://www.amazon.com/Monads-Programming-World-Haskell-Ellis/dp/1542739640
16:43:58 <monochrom> They don't come to IRC often these days. (They used to.)
16:44:23 <monochrom> But I bet O'Reilly is eager to know too, and more influential in taking action.
16:44:36 <glguy> That's got a pretty sweet title going for it
16:44:52 <metalbot> oreilly isn't on IRC either, and i'm pretty damn lazy...
16:45:05 <glguy> Oh well, it was a good effort
16:45:38 <dolio> This wouldn't be the first time someone has put a Haskell book they haven't written on Amazon, I think.
16:47:03 <robkennedy> It's worth the effort, if you can afford to expend it - Haskell lives because of SPJ, and Simon Marlow, and Bryan O'Sullivan, giving humanity the man-hours
16:47:16 <robkennedy> (and many many many others
16:47:46 <mmaruseacph2> wow, plagiarism even here :(
16:48:28 <metalbot> ah - found "infringement@oreilly.com" address :)
16:48:49 <robkennedy> Not here. Plagiarism is not the fault of the producers. Don Stewart didn't wear anything to ask for it ;)
16:49:30 <robkennedy> metalbot: thanks
16:49:41 <dmj`> world haskell ?
16:50:00 <dolio> Easy publishing lowers the bar for profitability, I imagine.
16:50:27 <dolio> Like spam.
16:52:47 <mmaruseacph2> robkennedy: I know
16:53:01 <mmaruseacph2> metalbot: sent them an email, the more the merrier :)
16:53:28 <mmaruseacph2> *the easier will be for them to see that it is an issue they need to tackle
17:28:57 <clmg> How do I make a "reference" in Haskell such that when I change one field of a record it updates that same field of another record?
17:30:24 <clmg> In C terms: I want my object (record) to have a field whose value is a pointer to another object (record).
17:30:47 <pacak> MVar, IORef
17:31:12 <jle`> is there a common term for something like (a, b) -> Either c d -> Either (a, c) (b, d)
17:31:22 <pacak> STRef, TVar
17:31:33 <clmg> pacak: is there a more "haskell" way to accomplish this?
17:31:44 <clmg> pacak: rather than actually having references/pointers?
17:31:55 <jle`> mvars/iorefs are pretty 'haskell'
17:32:01 <jle`> but it's hard to tell if there's a better way without more context
17:32:05 <pacak> clmg: Referential transparency is a nice thing.
17:32:17 <jle`> you're just giving us a very narrow/thin slice and from this perspective, mvar/ioref is the naive answer
17:32:55 <dolio> :t uncurry $ \x y -> bimap (x,) (y,)
17:32:58 <lambdabot> Bifunctor p => (t, t2) -> p t1 t3 -> p (t, t1) (t2, t3)
17:33:15 <clmg> pacak: I have two data constructors: window and buffer. Windows need to have buffers, but a buffer can be shared between two windows. I want it so that when one window edits its buffer, the other windows which ahve that buffer get updated also.
17:33:36 <clmg> pacak: all I can think of is passing around the list of buffers and storing the buffer index in the window. But that's cumbersome.
17:33:41 <jle`> dolio: i can implement it, i just was wondering if there was some name
17:33:49 <Anthaas> ~ books
17:33:53 <Anthaas> ! books
17:33:57 <jle`> what i'm actually doing is "zipping" (?) an n-ary product with an n-ary sum
17:33:59 <Anthaas> bot?
17:34:30 <ski> clmg : you could have windows include buffer identifiers, and have a separate data structure mapping buffer identifiers to buffer contents
17:34:31 <jle`> so like Tuple '[a,b,c,d] -> Sum '[e,f,g,h] -> Sum '[(a,e), (b f), (c, g), (d, h)]
17:34:42 <Anthaas> Meh, Hi guys - I have literally 0 experience with FP outside of Java 8 - can anyone suggest the "canonical" books which can explain everything from the start?
17:34:58 <clmg> Anthaas: I found learn you a haskell helpful.
17:35:35 <ski> Anthaas : i learned the basics from "Haskell: The Craft of Functional Programming" by Simon Thompson
17:35:36 <Anthaas> Im sort of looking for language agnostic, but with examples in a popular language/practice questions, etc.
17:35:41 <clmg> ski: how do I avoid passing that separate data structure around the entire application? Basically everything my application does works on a (buffer, window) pair.
17:35:48 <robkennedy> Arthaas: Learn You A Haskell and Parallel and Concurrent Programming in Haskell
17:36:05 <jle`> there's also haskellbook that is popular these days
17:36:06 <psilo2> I've got got this in an example xmonad config and can't find any explanations of the =<< operator:  main = xmonad =<< statusBar myBar myPP toggleStrutsKey myConfig    Can anybody explain (or tell me what I should be googling for)?
17:36:10 <jle`> @where haskellbook
17:36:10 <lambdabot> http://haskellbook.com
17:37:14 <Nolrai> What is Typeable1 as compared to Typeable?
17:37:14 <ski> clmg : `State'/`StateT' .. or `ST' or `IO'
17:37:17 <psilo2> Similarly, I've seen <+> somewhere (can't find it now) and not finding that in haskell syntax documentation
17:37:41 <clmg> ski: https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Lazy.html
17:37:42 <robkennedy> Bah humbug @haskellfromfirstprincipals
17:37:43 <clmg> that?
17:37:43 <jle`> psilo2: it's not a part of syntax
17:37:48 <jle`> psilo2: it's probably a custom defined operator
17:38:01 <ski> Nolrai : `Typeable1' is for types of kind `* -> *'
17:38:08 <Nolrai> Ah.
17:38:17 <monochrom> psilo2: "y =<< x" = "x >>= y"
17:38:20 <ski> clmg : that's one possibility
17:38:35 <psilo2> jle`: AH! So the Xmonad core source/docs is where I need to be looking. thanks!
17:38:43 <jle`> no problem!
17:38:55 <jle`> custom operaters are always one of the "ugh really" moments when you are trying to read code heh
17:38:58 <jle`> in haskell at least
17:38:59 <Nolrai> Wait ...why is that exported from Contro.Monad.Exceptions, but Typeable or Typeable0 isn't?
17:39:18 <Nolrai> jle' : I dont agree.
17:39:30 <robkennedy> :t (undefined :: Show a => a ->
17:39:32 <lambdabot> error:
17:39:33 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
17:39:33 <Nolrai> They are just infix functions.
17:40:00 <Fairy> I'm feeling a bit stupid, but I'm trying to create a function  notFollowedBy :: Parser b a -> Parser b ()   and I can't for the life of me figure it out :S
17:40:12 <psilo2> monochrom: that makes sense, since you seem to be familiar with it already, is it correct that it comes from the xmonad libraries and not haskell?
17:40:26 <slaterr> @hoogle <+>
17:40:30 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
17:40:30 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
17:40:30 <lambdabot> Text.PrettyPrint (<+>) :: Doc -> Doc -> Doc
17:40:30 <jle`> Nolrai: yes, it's true that they are just infix functions
17:40:40 <jle`> but that doesn't magically make them readable
17:40:45 <monochrom> >>= is a commonly used operator in most Haskell code.
17:40:48 <Nolrai> I guess it depends on how useful you find names.
17:40:51 <psilo2> Might be time to finally learn a bit of Haskell after a couple years of stumbling through my xmonad configs.
17:40:55 <jle`> "infix functions are readable functions" is not a logical conclusion i'd make
17:41:04 <robkennedy> :t undefined :: Show a => a -> String
17:41:06 <lambdabot> Show a => a -> String
17:41:07 <monochrom> But <+> is more custom-made.
17:41:08 <jle`> functions don't become readable just because they're infix
17:41:14 <Nolrai> No..
17:41:20 <psilo2> monochrom: right I see that but what about =<<?
17:41:22 <Nolrai> I never said that.
17:41:40 <Nolrai> (=<<) = flip (>>=)
17:41:44 <jle`> "i don't agree that they are bad; they are infix functions"
17:41:50 <monochrom> =<< is less common but sometimes people want it for the other operand order.
17:41:56 <jle`> sorry, sort of implicitly injected a "because" in the middle there :)
17:42:07 <jle`> *i sort of
17:42:23 <Nolrai> jle': Yes I don't find worse then normal functions, nor do I find them better.
17:42:37 <monochrom> Put it this way. >>= has been in the standard library for a long time. =<< is a fairly recent addition, but still to the standard library. <+> is custom-made.
17:42:46 <psilo2> monochrom: Ah ok, I'm just looking at http://www.imada.sdu.dk/~rolf/Edu/DM22/F06/haskell-operatorer.pdf and I suppose they fairly considered it obvious what =<< is after defining >>=
17:42:51 <dolio> (=<<) is not recent.
17:43:18 <psilo2> Thanks for everyone's input. this stuff's kinda hard to google sometimes (for me apparently)
17:43:34 <Nolrai> A couple of your responces only made sense if I said I liked operators /better/ then normal functions.
17:43:50 <monochrom> It is hard to Google. But xmonad assumes a fair bit of Haskell knowledge.
17:44:05 <Nolrai> (Though googleability is a real issue with operators.)
17:44:12 <monochrom> "Our config file is just a Haskell code file!"
17:44:32 <monochrom> Imagine if Windows config were "just a cmd.exe script".
17:44:47 <monochrom> (Wait, that actually happened to Windows 95.)
17:45:07 <Clint> win95 had cmd.exe?
17:45:29 <monochrom> Oh tonight everyone is going to anal nitpick on everything I said, right?
17:45:34 <Clint> could be
17:45:41 <psilo2> That's fair, I did learnyouahaskell probably literally a decade ago and then dropped it. If I want to try haskell again, is that still a decent place to start?
17:46:08 <monochrom> If you have an erratum to my sentences, just say the erratum, don't bother questioning me, I won't answer.
17:46:13 <psilo2> monochrom: it's a day of the week on an IRC programming channel, isn't that traditional? ;)
17:46:25 <monochrom> Not traditional on #haskell.
17:46:55 <psilo2> Sounds lovely, maybe I'll hang around for once
17:48:22 <Fairy> I'm trying to implement "notFollowedBy" function, using "lookahead" @ http://lpaste.net/4639017352053129216 but I can't seem to figure out a way to do it, I would have thought that "lookahead p <|> return ()" would work, but it doesn't :S
17:52:41 <Fairy> am I being stupid? :S
17:53:21 <monochrom> No, but you're confusing. The code on the webpage is not the code you just said.
17:54:01 <monochrom> I don't see "lookahead p <|> return ()" in the paste. I only see another version.
17:55:03 <Fairy> oh, sorry, that was the only version of "notFollowedBy" that I could get to work properly :S
17:56:55 <monochrom> OK, first a fixable technicality. "lookahead p <|> return ()" is a type error. But can be fixed by "(lookahead p >> return ()) <|> return ()"
17:57:25 <monochrom> But the real, semantic problem is that this attempt always succeeds.
17:57:56 <monochrom> If "lookahead p" succeeds, then the whole thing succeeds. This is not what you want for notFollowedBy.
17:58:46 <Fairy> yeah :S notFollowedBy is basically supposed to be the opposite of lookahead :S
17:59:20 <Fairy> I've spent around 3hrs thinking about a solution, and I can't come up with one
17:59:59 * mniip picks some nits
18:00:06 <monochrom> Suppose I give you && and ||, and ask you to implement "not", and I ask you to only use && and || to do it, no lowering yourself into the actual True's and False's. You will not be able to do it.
18:00:57 <mniip> ooh ooh that's a consequence of the post theorem isn't it
18:01:04 <mniip> && and || are monotonic but 'not' isn't :p
18:01:05 <monochrom> notFollowedBy is a similar story. It is a negation. You can't combine a lot of positive things to implement negation.
18:04:16 <Fairy> so there's no way to do it?
18:09:08 <monochrom> You have to first implement (by going low level) one kind of negation operator or another. Because it cannot be derived from the positive ones.
18:09:33 <monochrom> And the first negation operator you implement may as well be notFollowedBy itself.
18:10:15 <monochrom> Just like when doing booleans, you have to have a "not" as a basic operator, or "nor", or "nand", or "xor".
18:10:29 <Fairy> interesting
18:12:08 <mniip> yeah
18:13:19 <mniip> you need a function that is non-monotonic, one that is nonlinear, one that is non-1-preserving, one that is non-0-preserving, and one that is non-selfconjugate
18:13:49 <mniip> nand is all of those things simultaneously and hence you can implement all of boolean algebra with just that
18:14:29 <Fairy> and here I was sitting confident that the <|> would be sufficient 
18:14:33 <monochrom> That is a cunning plan. We need a "nor" or "nand" parser combinator!
18:16:36 <ski> i'm very sorry, but your negation won't be involutive
18:29:21 <mniip> what languages even are closed under nand?
18:29:46 <mniip> regular and recursively enumerable only I think
18:45:51 <dolio> I don't think RE is.
18:46:09 <Welkin> lambdabot: @messages
18:46:09 <lambdabot> You don't have any messages
18:46:13 <Welkin> D:<
18:47:09 <ski> @tell Welkin You've got a message
18:47:09 <lambdabot> Consider it noted.
18:47:15 <dolio> Recursive is.
18:47:48 <Nolrai> So in 8.0.2 deriving Typable is unnessary?
18:48:04 <Nolrai> *ghc 8.0.2
18:50:28 <lyxia> it has been unnecessary for a while.
18:51:02 <Nolrai> Really?
18:51:09 <Nolrai> I am behind the times.
18:58:43 <mniip> dolio, wait
18:58:55 <mniip> which is the class for which a TM terminates and says yes/no
18:59:18 <monochrom> Recursive.
18:59:34 <mniip> aha
18:59:58 <monochrom> Recursively enumerable = semidecidable = If the answer should be yes, the TM terminates and says yes; else the TM could say no or go on forever
19:00:09 <mniip> RE are the ones for which a TM terminates or doesn't
19:00:10 <mniip> right
19:02:43 <Nolrai> And Regular = decided by a context-free grammar, right?
19:03:30 <mniip> cfgs are strictly weaker
19:03:31 <monochrom> regular expression, finite state automaton
19:03:41 <mniip> ah er
19:03:42 <mniip> regular
19:03:50 <monochrom> context-free is when nondeterministic pushdown automaton
19:03:52 <mniip> cfgs are strictly stronger than regulars
19:04:42 <mniip> and contextful grammars are linearly bounded terminating TMs iirc
19:04:53 <monochrom> (In the case of finite state automata, determinism and nondeterminism don't matter, apart from exponential blowup.)
19:05:10 <mniip> yep
19:05:18 <mniip> deterministic pushdown automata define DCFGs
19:05:28 <mniip> which is strictly weaker than CFGs
19:05:34 <monochrom> Strangely, by the time you hit TM, again det vs nondet don't matter.
19:06:00 <mniip> are you sure in the case of a linearly bounded TM?
19:06:38 <monochrom> No.
19:06:54 <monochrom> I just meant unrestricted TM.
19:06:57 <mniip> ok
19:07:09 <monochrom> Haven't studied the context-sensitive class.
19:07:36 <mniip> we have barely touched it in our language theory course
19:07:52 <monochrom> It does seem a less popular topic.
19:08:04 <Nolrai> Because you can simulate NDTM's fairly straightforwardly with a DTM.
19:09:27 <Nolrai> Are infinite Regular Expressions equivalent to CFGs?
19:09:40 <monochrom> What are those?! :S
19:11:24 <dolio> Any language can be given an "infinite regular expression".
19:11:43 <mniip> do you mean a countable state automaton?
19:11:55 <mniip> :p
19:11:59 <Nolrai> mniip: I think so?
19:12:00 <dolio> Just take the union of all the strings in the language.
19:12:05 <mniip> well
19:12:09 <mniip> that's an unrestricted language
19:12:32 <mniip> because it all depends on the final states set
19:12:38 <Nolrai> Right.
19:13:25 <mniip> if you however restrict to recursively enumerable or computable sets, you get RE and resp. recursive languages
19:13:30 <dolio> Or yeah. Define states for every possible string, and circle the ones in the language.
19:14:12 <Nolrai> I meant things like mp='('mp*')' .
19:16:46 <mniip> like an EBNF?
19:16:51 <mniip> that's just a fancy cfg
19:17:25 <monochrom> Yes it doesn't exceed CFG yet. It's just using syntax sugar.
19:17:40 <monochrom> (FSVO "yes" I guess)
19:48:49 <theelous3> can someone help me wrap my head around how this is evaluated? let rightTriangles = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b] ]
19:50:22 <lyxia> theelous3: are you familiar with nested for loops
19:50:27 <theelous3> I'd've presumed that, in order, we'd get say, [(1, 1, 1), (2, 2, 2) (etc.)], but we get [(1,1,1),(1,1,2) etc.]
19:50:33 <theelous3> ah
19:50:35 <theelous3> right
19:50:45 <lyxia> heh
19:50:46 <theelous3> so it evals the c's
19:51:08 <theelous3> gottcha I think
19:51:33 <theelous3> yeah makes sense
19:51:35 <theelous3> ty lyxia 
19:51:43 <lyxia> yw
19:57:49 <Nolrai> So I am rather confused by this ghc error: http://lpaste.net/353164
19:58:21 <Nolrai> I am using FlexibleContexts, so why isn't it accepting the type it inffers?
19:58:51 <mniip> LANUAGE
19:59:07 <Nolrai> Oh god. Of course!
19:59:37 <ertes> Nolrai: it should have complained about an unknown pragma, too
19:59:39 <cads> Hey guys, I'm parsing some unformatted string output from an automated manufacturing service - basically these strings specify how much of which file needs to be manufactured, what material and thickness to use, and what finish to provide
19:59:46 <cads> Here's a sample: https://gist.github.com/maxsu/a64a5ad97c7f36591627abc7be311f21
20:00:18 <lispy> hello
20:00:26 <cads> there's some variability in the format, and I suspect that the format will continue to change as they tweak their code
20:00:45 <Nolrai> ertes: hmm. I don't think I've seen it ever make that complaint. Is there like a flag to turn that warnning on?
20:01:09 <ertes> Nolrai: not sure if a warning is needed, but i always use -W
20:01:15 <cads> so I'm wondering what's the best way to write a parser that will turn these unstructured strings into more tame structured json
20:01:16 <lispy> What sorts of projects are people working on these days?
20:02:07 <lispy> cads: well that's a pretty verbose english-y format
20:02:08 <cads> in practice it'll have to be fault tolerant enough to notify the admin when it can't parse a string
20:02:36 <lispy> But, since everything tends to be on online, you'd get pretty far with a regex as much as it pains me to suggest that
20:02:44 <lispy> er, on one line*
20:03:05 <cads> lispy, I was thinking regexes won
20:03:13 <cads> won't be too bad of an idea *
20:04:39 <Nolrai> ertes: stack build doesn't seem to be using the ghc-options in my .cabal file.
20:05:17 <lispy> cads: Actually, I might throw sed at it to preprocess into json, sexpr, csv, etc and then try to read that in
20:05:18 <ezyang> Nolrai: How can you tell? 
20:05:33 <lispy> cads: Basically going with a design where I would decouple input massaging from the Haskell code
20:06:30 <Nolrai> From this? https://www.irccloud.com/pastebin/hOOo8mei/message_from_stack
20:07:53 <glguy> the ghc options wouldn't be passed to the setup executable
20:08:50 <Nolrai> Okay..so how do I tell then?
20:12:12 <Nolrai> Okay I think I solved this, I had a "ghc-options:" line for app and test, but not lib.
20:14:30 <cads> For a simple line like  "1. qty 10, Custom part from R3J8-M0X4-aluspacer.dxf, Aluminum 6061 0.5, Process: Waterjet Machining,"   I can use a sed expression like  's/^[0-9]+\. qty \([0-9]\), Customer part from \(\w*.dxf\), \([^,]*\) \([0-9.]+\).*$/{"qty": "\1", "material": "\3", "thickness": "\4", "file": "\2"}/'
20:14:43 <cads> lispy, oh god that is so terrible, lol
20:15:08 <Nolrai> Does -W include warnings -Wall doesn't?
20:15:11 <cads> lemme see if that even works
20:16:37 <MarcelineVQ> Nolrai: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#options-sanity
20:18:47 <lispy> cads: it is pretty bad, but making a parser is going to have similar issues like, what is a token in this language? split on whitespace and punctuation, but then what about things like '-', you probably don't want to split on that.
20:20:28 <Nolrai> Hmm. It says "-Wunrecognised-pragmas" is on by default, but I am prettysure it shouldn't recognize "LANUAGE".
20:21:21 <Nolrai> lispy: using char as the tokens can work pretty well with haskell parsers.
20:22:51 <cads> lispy, that's true
20:23:22 <Squarism> why doesnt this work in ghci
20:23:25 <Squarism> Prelude> :{
20:23:25 <Squarism> Prelude| g :: Int -> String
20:23:25 <Squarism> Prelude| g i = show i
20:23:25 <Squarism> Prelude| :}
20:23:36 <cads> I guess I'm going to try it the regex way, but I'll probably do it in node or something more portable
20:23:42 <Squarism> get
20:23:43 <Squarism>  <interactive>:54:5: parse error on input ‘=’
20:24:00 <cads> Kinda wish I could just train the parser
20:25:02 <lispy> cads: if you want something more magical that might just work, there is this: http://www.padsproj.org/
20:25:24 <monochrom> Squarism: I just tried. Works.
20:25:31 <Squarism> gah
20:26:18 <cads> lispy, a concern is that this will have to be fault tolerant - if the data producer changes its format and the parser can't make sense of the new format, it needs to tell the human operator "hey, the format has changed"
20:26:51 <cads> I'll have to see about making an agreement for the producer to not change the format without notice
20:27:00 <lispy> ah
20:27:13 <lispy> Yeah, that means regular expressions are a liability
20:27:52 <lispy> If you're open to trying new things (I assumed this needed to be in Haskell), then PADS is probably the best tool I can think of
20:28:00 <cads> already in the three months of data I'm working with I've seen the data format change a bit, and there are also entries which seem hand written
20:28:07 <cads> lispy, checking pads out right now
20:28:36 <lispy> looks like there is a Haskell backend
20:28:55 <cads> lol, I'm only asking in here because I know haskellites have been exposed to advanced parser generation techniques :)
20:29:14 <cads> but yeah, this is probably going to be written in node or python 
20:29:55 <lispy> cads: like this example is kind of cool: http://pads.cs.tufts.edu/examples.html
20:30:02 <lispy> they generate C code that can parse the example log format
20:30:08 <lispy> You could call C code from python
20:31:09 <cads> yeah, shouldn't be a problem
20:31:38 <lispy> http://pads.cs.tufts.edu/doc/tutorial.html#toc11
20:33:45 <Nolrai> what do ":{" and ":}" mean in ghci?
20:34:02 <lyxia> start and end a multiline section
20:34:13 <Nolrai> Ah.
20:43:32 <jle`> Squarism: what version of ghc are you using?
20:43:43 <jle`> Squarism: in versions before 8.0, you aren't allowed to define functions like that
20:43:45 <Squarism> jle`, 7.10
20:43:48 <jle`> ah yeah
20:43:57 <Squarism> i figured it out though
20:43:58 <jle`> prior to ghci 8.0 functions have to be defined using 'let'
20:44:09 <jle`> this has always caused a lot of confusion
20:44:29 <Squarism> had to do:
20:44:30 <Squarism> *JC.Facade.Console.Controller> :{
20:44:30 <Squarism> *JC.Facade.Console.Controller| let g :: Int -> String
20:44:30 <Squarism> *JC.Facade.Console.Controller|     g i = show i
20:44:30 <Squarism> *JC.Facade.Console.Controller| :}
20:44:40 <jle`> yeah, you have to 'let' function declarations
20:44:43 * jle` shrugs
20:44:50 <jle`> glad they finally got rid of that requirement
20:45:15 <Squarism> i really have no good reason beeing on 7.10 still as im using stack
20:45:26 <Squarism> but just havent gotten to it
20:46:19 <MarcelineVQ> alternatively:  let g :: Int -> String; g i = show i
20:46:38 <BANNED_IRL_BRO> Alright..im down bitch
20:47:11 <jle`> sed -i 's/resolver:.*/resolver: lts-8.3/' ~/.stack/global-project/stack.yaml i suppose
20:47:20 <jle`> disclaimer i didn't test that
20:47:25 <BANNED_IRL_BRO> hello?!?!
20:47:28 <jle`> i don't know how regexes are supposed to be escaped in sed anymore
20:47:29 <BANNED_IRL_BRO> can;t you see im dope
20:47:31 <BANNED_IRL_BRO> baby im dope
20:47:35 <BANNED_IRL_BRO> can';t even type inm sod ope
20:47:36 <lispy> @ops
20:47:36 <lambdabot> Maybe you meant: pl oeis docs
20:47:39 <BANNED_IRL_BRO> blah balhb ablah
20:47:42 <BANNED_IRL_BRO> dont' bee so gay
20:47:44 <BANNED_IRL_BRO> im cool baby
20:48:02 <jle`> oh hey it worked
20:48:23 <jle`> between vim's regexes and grep's and sed's i always mix up what needs to be escaped
20:48:31 <jle`> especially cause you can toggle the regex mode in vim
20:48:38 <Squarism> MarcelineVQ, oh ok
20:52:50 <pavonia> Any hints on how to write a Parsec parser for this? http://lpaste.net/353165
20:53:38 <pavonia> The problem is that I don't know in advance which entry starts a section and which one is a simple one
20:59:24 <maybefbi> I want :: [[a]] -> [Int] -> [([a], [Int])] such that [Int] is "eaten" by the lengths of each [a] to make each ([a], [Int])
20:59:45 <maybefbi> i cant decide if it is a zipWith or something else
21:05:13 <pavonia> maybefbi: Do you have a sample for this? I don't know what you're looking for
21:05:15 <Cale> It's not entirely straightforward
21:06:03 <S11001001> maybefbi: I think you can replace Int with b, right?
21:06:10 <S11001001> maybefbi: in your types
21:06:23 <maybefbi> yes
21:06:58 <S11001001> maybefbi: it's not a zipWith, but it's a mapAccumL
21:07:01 <Cale> pavonia: I believe maybefbi wants f ["abc","de","fghi"] [1..] = [[('a',1),('b',2),('c',3)],[('d',4),('e',5)], ...]
21:07:29 <pavonia> Ah, thanks
21:08:55 <maybefbi> pavonia, example [[(),(),()], [()], [(), ()]] [2,7,1,8,2,8] = [([(),(),()], [2,7,1]). ([()], [8]), ([(), ()], [2, 8])]
21:09:15 <Cale> ohh, yeah, I misread that
21:09:28 <Cale> I thought you wanted it to pair them up one level deeper
21:09:46 <maybefbi> im thinking of some combination of zip and scanr
21:09:55 <nshepperd> it's what Cale said except `map unzip`d
21:10:22 <maybefbi> i could be wrong about zip + scanr
21:10:32 <ertes> pavonia: do you expect the grammar to get more complicated later?
21:10:36 <maybefbi> but the example is what im trying to achieve
21:11:10 <ertes> pavonia: if not, i'd honestly not use parsec at all…  just split into lines and count leading spaces to determine nesting
21:12:06 <ertes> then you can use a one-line lookahead using e.g. a simple foldr
21:12:08 <nshepperd> f ass bs = zip ass (splitPlaces (map length ass) bs)
21:12:12 <Cale> > let next = do (x:xs) <- get; put xs; return x in evalState (mapM (mapM (\x -> fmap ((,) x) next)) ["abc","de","fghi"]) [1..]
21:12:16 <lambdabot>  [[('a',1),('b',2),('c',3)],[('d',4),('e',5)],[('f',6),('g',7),('h',8),('i',9)]]
21:12:18 <pavonia> ertes: The grammar for each entry is already more complex, that's why I'd like to use a parser comibator for it. But yeah, doing a two-phase process is probably the easier solution
21:12:40 <nshepperd> (splitPlaces is from @hackage split)
21:12:42 <ertes> pavonia: you can still parse individual components with parsec
21:12:46 <maybefbi> :t splitPlaces
21:12:49 <lambdabot> Integral a => [a] -> [e] -> [[e]]
21:12:59 <nshepperd> oh hey, lambdabot has it
21:13:07 <Cale> > let next = do (x:xs) <- get; put xs; return x in map unzip $ evalState (mapM (mapM (\x -> fmap ((,) x) next)) ["abc","de","fghi"]) [1..]
21:13:11 <nshepperd> :t let f ass bs = zip ass (splitPlaces (map length ass) bs) in f
21:13:12 <lambdabot>  [("abc",[1,2,3]),("de",[4,5]),("fghi",[6,7,8,9])]
21:13:14 <lambdabot> Foldable t => [t a] -> [e] -> [(t a, [e])]
21:13:24 <ertes> pavonia: i believe there is also a ready-made layout parser in trifecta…  that might make it easier, too
21:14:33 <nshepperd> using `length` is a bit of laziness on my part, but it's easy to understand..
21:14:59 <johnw_> nshepperd: was there a pun intended there?
21:15:29 <nshepperd> heh
21:15:45 <Cale> :t \us vs -> let next = do (x:xs) <- get; put xs; return x in evalState (mapM (mapM (\x -> fmap ((,) x) next)) us) vs
21:15:47 <lambdabot> (Traversable t1, Traversable t) => t (t1 a) -> [b] -> t (t1 (a, b))
21:16:24 <pavonia> ertes: This one? https://hackage.haskell.org/package/trifecta-0.52/docs/Text-Trifecta-Layout.html
21:16:24 <nshepperd> a bit of laziness, but not lazy enough
21:16:48 <ertes> pavonia: yeah, although i don't know how to use it
21:17:12 <ertes> pavonia: i suppose you transform Layout into Parser
21:17:22 <ertes> i.e. use the (Layout Parser) monad
21:17:37 <maybefbi> nshepperd, thanks
21:17:52 <nshepperd> @let choppy ass bs = zip ass (splitPlaces (map length ass) bs)
21:17:56 <lambdabot>  Defined.
21:18:10 <nshepperd> > choppy ["abc","de","fghi"]) [1..]
21:18:14 <lambdabot>  <hint>:1:27: error: parse error on input ‘)’
21:18:22 <ertes> pavonia: at least that's what the API suggests
21:18:24 <nshepperd> > choppy ["abc","de","fghi"] [1..]
21:18:30 <lambdabot>  [("abc",[1,2,3]),("de",[4,5]),("fghi",[6,7,8,9])]
21:18:36 <nshepperd> excellent
21:19:32 <maybefbi> :)
21:19:40 <nshepperd> actually I guess this would be sufficiently lazy if I used genericLength with lazy peano nats there
21:20:08 <pavonia> ertes: Hhm, I guess I'll just do the structure parsing separately and use Parsec for the entries
21:21:01 <ertes> pavonia: reasonable…  you can also easily use stream processing that way…  parsec insists on having the whole input in memory
21:26:29 <pushp0p_> hey i dont understand the function signature for: unfix :: Fix f -> f (Fix f)
21:26:33 <pushp0p_> unfix (Fix f) = f
21:26:40 <pushp0p_> it seems backwards to me
21:29:20 <S11001001> pushp0p_: what's the signature for Fix?
21:29:59 <pushp0p_> fix :: f (Fix f) -> Fix f
21:30:07 <pushp0p_> fix = Fix
21:30:14 <S11001001> pushp0p_: it's just the reverse of that
21:30:51 <pushp0p_> yeah i understand they are reverse of each other
21:31:12 <pushp0p_> its just weird that the signatures look like that to me
21:31:27 <pushp0p_> is it point free style or something?
21:31:32 <pacak> Fix is a bit weird as it is.
21:31:42 <pacak> But useful
21:32:51 <pushp0p_> yeah i understand what it does
21:32:58 <pushp0p_> i just dont get why the signatures are like that i guess
21:34:15 <pushp0p_> fix :: f (Fix f) -> Fix f   
21:34:23 <pushp0p_> ^this looks like its 'tearing down a level of recursion'
21:34:29 <pushp0p_> but its the opposite, right?
21:35:17 <pushp0p_> nvm i guess i see it now looking at the type constructor for Fix
21:35:49 <pushp0p_> https://jtobin.io/tour-of-some-recursive-types
21:38:03 <ertes> pushp0p_: let (x = Fix y) :: Fix F
21:38:09 <ertes> pushp0p_: what's the type of y?
21:41:00 <pushp0p_> Fix (y (Fix y))
21:41:27 <ertes> pushp0p_: nope (and don't confuse the value level with the type level)
21:41:32 <ertes> Fix y :: Fix F
21:41:34 <ertes> y :: ?
21:42:02 <pushp0p_> i honestly don't know haskell at all
21:42:09 <pushp0p_> i'm just reading this article to try to understand recursive types
21:42:23 <ertes> pushp0p_: look at the definition of Fix
21:42:35 <ertes> newtype Fix f = Fix { unFix :: f (Fix f) }
21:42:58 <ertes> the Fix data constructor takes one argument of type (f (Fix f))
21:43:37 <pushp0p_> yeah
21:43:44 <ertes> let (blah :: Blubb (Fix Blubb))
21:43:51 <ertes> then:  Fix blah :: Fix Blubb
21:43:55 <ertes> does that make sense?
21:44:46 <pushp0p_> yeah
21:46:24 <ertes> good
21:46:34 <ertes> now use the same logic in the other direction
21:46:36 <pushp0p_> yah it made sense when i started looking at the type constructor
21:46:40 <ertes> Fix y :: Fix F
21:46:42 <ertes> y :: ?
21:46:56 <pushp0p_> the way it looks is still strange but if i substitute the type constructor into unfix it makes sense
21:50:57 <Squarism> So a value cant have type "Eq *" ? 
22:02:48 <geekosaur> Eq is not a type. You could think of it as an interface
22:03:53 <geekosaur> A typeclass (interface) is not a type and cannot be used as one. (It's actually a hint to the compiler to include a pointer to a type's implementation of the typeclass. Thus you must have a type, otherwise there is no pointer.)
22:07:18 <Squarism> geekosaur, i suspected that. I need to get rid o my scala/java mind set and learn my "generic" options in haskell
22:42:12 <ongy> hm, cabal new-build confuses me. It looks like it chokes on atomic-primops
22:45:46 <ezyang> ongy: Post error? 
22:47:03 <lpaste_> ongy pasted “cabal new-build doing nothing” at http://lpaste.net/4545204614789595136
22:47:26 <ezyang> it hung? 
22:47:32 <ongy> not at all
22:47:45 <ongy> just ended itself, but no shell error
22:47:51 <ezyang> this is 1.24? 
22:48:03 <ezyang> If you pass -j0 I bet you'll get an error 
22:48:05 <ongy> 1.24.0.0
22:48:07 <ezyang> this is a dumb bug and we fixed it in HEAD 
22:48:29 <ongy> I get an error I don't really understand
22:48:36 <ezyang> paste it? 
22:49:11 <ongy> error, called at libraries/Cabal/Cabal/Distribution/ReadE.hs:44:24 in Cabal-1.24.0.0:Distribution.ReadE
22:49:23 <ongy> oh when it's in one line I see it's just 'error' called -.-
22:49:27 <ongy> still, not that helpful for a user
22:50:25 <ezyang> that's unusuuuual 
22:51:44 <ezyang> uhh, can you post -v3 logs 
22:51:49 <ezyang> with -j0 
22:53:34 <lpaste_> ongy pasted “cabal new-build -j0 -v3  >/tmp/log 2>&1” at http://lpaste.net/353167
22:53:51 <ongy> this looks useful. and I just checked, the redirections don't void anything
22:54:34 <ezyang> ok...... 
22:54:48 <ezyang> well, I think the easiest thing to try next is to grab a cabal-install HEAD and see if the problem arises there 
22:55:03 <ezyang> you want to use HEAD anyway. Ubuntu? You can get one off of hvr's PPA 
22:55:17 <ongy> arch
22:55:29 <ongy> but we probably have a cabal-install-git in aur, let me check
22:55:37 <ongy> also I'm not sure if I want to run HEAD :)
22:55:42 <ezyang> it's not too hard to build yourself either 
22:55:52 <ezyang> I know HEAD is bootstrapping off of 1.24 new-build :) 
22:56:12 <ongy> we don't -.- anything to worry about when building from HEAD? Also where is that
22:56:49 <ezyang> get it off of https://github.com/haskell/cabal 
22:56:56 <ezyang> just run cabal new-build cabal 
22:57:11 <ezyang> I don't believe there are any known problems 
22:58:59 <ongy> oh, I ran the bootstrap.sh in cabal-install inside there
22:59:06 <ongy> I should wait for answers when I ask something...
23:00:32 <ezyang> oh bootstrap.sh is ok too 
23:00:41 <ezyang> we test that too :) 
23:00:59 <ezyang> but it's mostly intended for when you don't have any working cabal at all 
23:01:33 <ongy> ohh, well I did it in an tmpfs, so it shouldn't litter
23:04:42 <ongy> oh we are having fun today
23:05:13 <lpaste_> ongy pasted “./bootstrap.sh” at http://lpaste.net/8695420333114523648
23:05:26 <ongy> should I just try the new-build?
23:05:39 <ezyang> bootstrap is supposed to work. Let's see 
23:06:10 <ezyang> TBC, you've got both Cabal and cabal-install dirs in tmpfs? 
23:06:49 <ezyang> but yes, maybe try new-build 
23:07:25 <ezyang> let me see if I can repro 
23:07:53 <ongy> ah maybe I ran it in the wrong directory? I cd'ed into cabal-install inside the repo
23:08:38 <ongy> I ran my git clone inside /tmp/ so /tmp/cabal is the root of the repo
23:08:45 <ezyang> no that's fine 
23:09:17 <ezyang> is your new-build humming? Do you want to help debug bootstrap? 
23:10:13 <ongy> new-build is running, but the bootstrap ran for a good while aswell
23:11:13 <ongy> sure I can help debug bootstrap
23:12:54 <ezyang> first, did you pass any arguments to bootstrap.sh? 
23:13:01 <ongy> no
23:13:21 <ezyang> ok, is there a ./Setup exec in cabal-install dir? 
23:13:40 <ezyang> if so, tell me what ./Setup --version says 
23:15:10 <ongy> I'll run this on a different machine, to not interrupt the new-build going on
23:15:22 <ongy> this one has a bit more power aswell, so it shouldn't take too long
23:16:07 <ezyang> oh, I was assuming you had kept the intermediate products around 
23:16:25 <ongy> I did the new-build in the same git checkout, not sure if that keeps things around
23:16:29 <ezyang> it will 
23:17:05 <ongy> ./Setup --version: Cabal library version 1.24.0.0
23:17:50 <ezyang> :O 
23:17:55 <ezyang> that's not supposed to happen haha 
23:18:17 <ongy> git log --oneline | head -n 1                                                                    :(
23:18:19 <ongy> cef856fc9 Merge pull request #4363 from ezyang/pr/hs-libraries-indefinite
23:19:52 <ezyang> well 
23:20:03 <ezyang> I see the bug, looking at bootstrap.sh 
23:20:08 <ezyang> thanks, we'll try and fix this. new-build should still work 
23:20:49 <ongy> still running, but I ran into oom on my laptop so it got interrupted
23:23:50 <ezyang> https://github.com/haskell/cabal/issues/4365 
23:23:54 <ongy> so what does new-build do with the binary? install them into ~/.cabal/bin ?
23:24:27 <ongy> feel free to highlight me when you mention me on github, I'm ongy there aswell
23:25:35 <ezyang> ongy: No, it gets put in dist-newstyle 
23:25:38 <ezyang> look for the "Linking" line 
23:25:45 <ezyang> I symlinked something to that path 
23:26:59 <ongy> this is in /tmp/ so I'd rather not :). Do I need to copy anything out but the cabal binary? hackage-security?
23:28:22 <ezyang> I think it's statically linked by default so the binary is good enough 
23:28:32 <ezyang> ldd it to be sure :o) 
23:29:06 <ongy> static against haskell libs, dynamic against external dependencies
23:29:10 <ongy> I really like that default
23:30:09 <ongy> now I'll see if I can get my first aur PKGBUILD done
23:30:46 <ezyang> haha, back to the original problem 
23:31:16 <ezyang> but, actually, I kind of wonder if the problem that caused bootstrap to not work is also the same problem that caused your package not to build originally 
23:33:33 <ongy> ah no, I want to have cabal-install-git or aur. I don't like to install things as user that I haven't written myself
23:33:42 <ezyang> :) 
23:34:47 <ongy> how long until cabal new-run? Or does it exist on HEAD?
23:35:31 <ezyang> ongy: https://github.com/haskell/cabal/pull/4304 
23:35:47 <ezyang> it's not green on CI so we haven't merged yet 
23:37:42 <ezyang> but you could give it a try if you were so inclined 
23:37:46 <ezyang> testing = good :) 
23:38:14 <ongy> that's not `cabal run` is it? looks more like it would be useful to run ghc-mod and such
23:38:42 <ongy> I'm not at home over the weekend, not sure how much time and internet I will have
23:39:56 <ezyang> I think cabal new-exec knows how to find executables you built 
23:40:01 <ezyang> I haven't used it so I'm not sure 
23:40:14 <ongy> dmwit should know :)
23:45:49 <ongy> but skimming the changes, it can run the build tools installed as dependencies, not sure about the built project
23:46:08 <ezyang> yeah, dunno. Code is the gospel 
23:47:34 <ongy> I got a 101 character long path from new-build to run the binary...
23:48:00 <ongy> that's equal parts hilarious and horrible
23:49:27 <ezyang> yeah, HEAD new-build puts it in a bit longer path 
23:49:35 <ezyang> Maybe we should drop the arch 
23:49:45 <ezyang> but I've found ghc version quite useful 
23:50:26 <ongy> if we get cabal new-run/ or something to get the newest paths from cabal (useful for automated install scripts) I don't mind it
23:50:37 <ongy> but parsing the output of new-build for the Linking line... not my favorite passtime
23:50:52 <ezyang> yeah... 
