00:08:08 <dminuoso> piyush-kurur: Can you fill me in on this?
00:08:10 <dminuoso> Im curious.
00:09:38 <piyush-kurur> dminuoso: Ford_Prefect is the right person, I guess he is around
00:09:52 <piyush-kurur> I will point you to some links that he sent me
00:10:29 <dminuoso> Fair enough. Was hoping you had those links ready for me. :)
00:10:45 <piyush-kurur> for example this is how system d uses "getrandom" https://github.com/systemd/systemd/blob/master/src/basic/missing_syscall.h#L72
00:11:16 <piyush-kurur> dminuoso: warning make sure you do not have a heart condition before looking at it
00:11:41 <dminuoso> piyush-kurur: And please elaborate which part of this is "confusing" or "bad" ?
00:11:54 <piyush-kurur> some staring at openssl code base would have given you the necessary imunity (if you are not dead yet that is)
00:12:15 <dminuoso> Honestly, I'm not seeing anything obvious wrong with this code. Please fill me in.
00:12:33 <piyush-kurur> dminuoso: the manpage on linux innocently says the existance of a getrandom fucntion except that it is not there
00:12:56 <dminuoso> piyush-kurur: What do you mean?
00:13:14 <piyush-kurur> https://bugzilla.kernel.org/show_bug.cgi?id=194797 
00:18:38 <piyush-kurur> dminuoso: and here is another https://lwn.net/Articles/711013/ saying getrandom has finally arrived in glibc although I do not know why it is a glibc thing when the particular syscall is a linux specific thing
00:23:30 <Ford_Prefect> piyush-kurur: glibc is what provides the headers and (potentially) function stubs that call syscall()
00:27:28 <zipper> ski: Isn't indenting like that too much work?
00:28:40 <Ford_Prefect> piyush-kurur: you'll notice there's also a proposal (not actually being implemented) to have a linux-specific-syscall library
00:34:34 <dickbarends> \leave
01:16:16 <piyush-kurur> Ford_Prefect: I do not understand why glibc is designed in such a way. I thought glibc is meant to be a portable library
01:16:56 <piyush-kurur> the link on lwn that you forwared shows the confusion that results in adding a system specific call to a generic library
01:17:05 <dminuoso> The glibc is not meant to be portable at all.
01:17:24 <dminuoso> The glibc is an ugly collection of non-portable hacks for legacy reasons.
01:17:53 <dminuoso> With so many Drepper codes that were written because he felt educating others on how to write code was a good thing to do.
01:18:47 <piyush-kurur> dminuoso: Much like how OpenSSL was written to learn writing multi-precision integer arithmetic I guess
01:19:43 <dyreshark> on the bright side, it has a strfry function
01:19:49 <dyreshark> so at least it can sautee strings pretty well
01:20:57 <piyush-kurur> dyreshark: Wow glibc is starting to look like openssl 
01:22:24 <dyreshark> ...in that it's written in c?
01:22:31 * dyreshark has never actually read any openssl source
01:22:52 <piyush-kurur> dyreshark: good that you did not try
01:22:59 <barrucadu> dyreshark: `man strfry` pointed me to `man memfrob`, which made me sad :(
01:24:19 <piyush-kurur> If programming was literature than openssl would be Vogon poetry
01:24:33 <dyreshark> yeah, i'm not actually sure why memfrob exists, except as a joke
01:25:05 <dyreshark> but i'm sure some application somewhere depends on it in order to function
01:27:31 <barrucadu> Something somewhere will break if the xor constant is changed from 42
01:28:13 <M-Magnap> I sure hope not! It'd be like https://xkcd.com/1172/ except in real life
01:45:55 <raylocal> Hi, am I doing something wrong here : i  get 6 as the random everytime for - randomR (1,6) (mkStdGen 3)  , randomR (1,6) (mkStdGen 5) and randomR (1,6) (mkStdGen 50) 
01:46:27 <raylocal> Hi, am I doing something wrong here : i  get 6 as the random everytime for - randomR (1,6) (mkStdGen 3)  , randomR (1,6) (mkStdGen 5) and randomR (1,6) (mkStdGen 50) 
01:48:26 <merijn> raylocal: THe default random generator is...not ideal :)
01:48:58 <merijn> There was a thread about this a while back, but I forget the link
01:50:45 <cocreature> if you bug carter often enough, he will release the new version of random with a better rng :)
01:50:57 <merijn> raylocal: Basically, seeds that are similar tend to result in similar random numbers
01:51:21 <merijn> raylocal: 3 and 50 being "similar" in the scheme of 0 through maxBound
01:51:31 <raylocal> oh o kay 
01:51:47 <merijn> There are several other decent random generators on hackage
01:52:32 <raylocal> thanks you are right. I managed to get a different one with mkStdGen 6747264 
01:52:42 <Xnuk> > map (fst . randomR (1,6) . mkStdGen) [0..]
01:52:50 <lambdabot>  [6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6...
01:53:28 <liste> > map (fst . randomR (1,6) . mkStdGen) [0,1000..]
01:53:33 <lambdabot>  [6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6...
01:53:50 <liste> > map (fst . randomR (1,6) . mkStdGen) [0,10000000..]
01:53:53 <lambdabot>  [6,6,6,6,5,5,5,4,4,4,3,3,3,2,2,2,1,1,1,6,6,6,5,5,5,4,4,4,3,3,3,2,2,2,1,1,1,6...
01:54:09 <Xnuk> > length . takeWhile (==6) $ map (fst . randomR (1,6) . mkStdGen) [0..]
01:54:13 <lambdabot>  53668
01:55:03 <merijn> tf-random and mwc-random provide better (but not cryptographic) randomness
01:55:42 <merijn> mwc-random is also superfast, iirc
01:56:16 <Xnuk> > map (fst . randomR (1,6) . mkStdGen) [0,53667..]
01:56:21 <lambdabot>  [6,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6,5,4,3,2,1,6...
01:56:26 <merijn> But if you don't care too much, simply using System.Random is fine
01:56:35 <raylocal> I am not looking for the strength . just trying out  the state monad chapter of the wikibook. Was just curious why it was giving me 6 all the time
01:56:49 <merijn> There's also newStdGen which does better initialisation
01:57:09 <raylocal> for real random we have hardware random number generators we can use ;)
01:57:18 <piyush-kurur> shameless self promotion. In case you want cryptographically secure randomness have a look at raaz. We have an interface that I hope is simple enough (do not use it in multiple threads  though)
01:58:00 <piyush-kurur> I am sure cryptonite might also have some prg in it
01:58:48 <piyush-kurur> raylocal: even with cryptographic prg be careful when you want to generate random numbers in a particular range
01:58:58 <piyush-kurur> do not just take modulo
02:02:11 <raylocal> I do not really need to generate a industrial strength random thankfully but we do run statistical tests on clients RNG (TRNG /PRNGs) but  that is just me clicking a button to run the script.
02:04:38 <Athas> I just use this one: http://stackoverflow.com/a/12996028
02:04:46 <Athas> They say it's cool to run your own crypto, after all.
02:06:22 <merijn> I just stole MurmurHash3 when I needed a fast hash
02:07:03 <Athas> Does it have a very small state?  (That was my main need, as I needed hundreds of thousands of threads, each with their own RNG state.)
02:07:13 <spatial> type ArrayAccess = ReaderT  (IOArray Int Int) IO Int  readvalue :: ArrayAccess  -> Int   readvalue arr   = do    a <- ask   b <- readArray a 1;       return b
02:07:26 <merijn> I think so? lemme check
02:07:44 <spatial> Does this allow array read ?
02:08:07 <Athas> spatial: it allows array writing, too.
02:09:02 <merijn> Athas: It boils down to this: https://github.com/merijn/GPU-benchmarks/blob/master/evolve.cpp#L67-L109 But this is a rather stripped down and specialised version of the open source one by Google
02:09:33 <Athas> merijn: a uint64_t as the seed/state?  That's fine.
02:09:45 <Athas> Maybe I'll switch to that one if I actually need *good* random numbers.
02:10:13 <spatial> Ã¤ <- ask   doesn't work.
02:10:39 <merijn> Athas: Well, it was written by google specifically to be very fast, so minimal amount of state is obviously required for that :)
02:11:33 <spatial> Couldn't match kind `*' with `* -> *'
02:11:56 <Athas> spatial: type ArrayAccess = ReaderT  (IOArray Int Int) IO
02:12:24 <Athas> readvalue :: ArrayAccess Int
02:13:05 <Athas> The array is stored in the monadic context of the ArrayAccess monad, so there's no argument to the readValue function.
02:15:39 <spatial> type ArrayAccess = ReaderT  (IOArray Int Int) IO  readvalue :: ArrayAccess Int   readvalue    = do    a <- ask   b <- readArray a 1;       return b
02:16:03 <Athas> spatial: yes, that should work (if you insert appropriate line breaks).
02:16:36 <spatial> No instance for (MArray                          IOArray Int (ReaderT (IOArray Int Int) IO))         arising from a use of `readArray'
02:17:53 <Athas> Ah, right.  You have to use 'liftIO (readArray a 1)'.
02:18:30 <Athas> Since readArray runs in the IO monad, but you are in a ReaderT on top of IO.  liftIO allows you to lift an IO action into the ArrayAccess monad.
02:19:08 <spatial> You mean monad transformet stack.
02:19:25 <spatial> one inside the other
02:21:34 <spatial> createarray :: IO ( IOArray Int Int) createarray =  do {                        arr <- newArray (512,512) 0;                        return arr                   }  I create the array like this.
02:22:17 <spatial> liftIO works. How is createarray used with readvalue ?
02:26:20 <Athas> spatial: well, createArray runs in IO, and readValue runs in ArrayAccess.
02:26:38 <Athas> You'd run createArray in the IO monad, and then you'd use runReaderT to run readValue in the IO monad.
02:27:03 <Athas> Something like: do { a <- createArray; liftIO (runReaderT readValue a) }
02:27:05 <Athas>  
02:27:29 <spatial> Athas: Really appreciate it.
02:29:14 <Athas> spatial: but be careful, because your ReadArray monad doesn't really provide just read-only access to the IOArray.
02:29:51 <spatial> I will write also.
02:30:49 <Athas> Alright, that's good, then.
02:32:54 <M-Magnap2> A monad transformer stack will still be a monad
02:40:37 <jophish> hi jchia_, sorry I was away this weekend, did you find a solution to your problem with vector-sized?>
02:42:12 <jophish> the easiest way at the moment would probably be to use withVectorUnsafe
02:42:33 <jophish> this allows you to change the underlying vector as long as you promise to not change the size.
02:46:53 <merijn> bleh, I wish there was a library that was the best of both worlds of Groundhog and Persistent >.>
02:53:19 <spatial> type ArrayAccess = ReaderT  (IOArray Int Int)  IO   readvalue ::  ArrayAccess Int          How can I pass additional Int argument to readvalue ?
02:53:42 <spatial> Should ArrayAccess change too ?
02:55:14 <liste> spatial: readvalue :: Int -> ArrayAccess Int ?
03:00:02 <spatial> readfromarray = do { a <- createarray; liftIO (runReaderT readvalue 1 a) }   That throws error is I pass '1'
03:00:29 <Athas> spatial: (runReaderT (readvalue 1) a)
03:01:05 <spatial> :-) An imperative programmer struggling with Haskell.
03:01:49 <dminuoso> spatial: The weird thing is, I just started with Haskell after having dived into React + Redux hardcore. Suddenly the whole concept of functional programming seemed quite intuitive right from the get-go.
03:02:08 <dminuoso> Though grokking redux reducers was a bit of a PITA.
03:02:09 <dminuoso> :-)
03:02:21 <spatial> OCaml was like that for me. Not Haskell
03:02:59 <spatial> I wasn't prepared for Monad.
03:05:54 <spatial> You mean Redux is written in Haskell ?
03:06:28 <spatial> That was JS
03:06:30 <dminuoso> spatial: No, but it uses a purely functional approach to describe how state is derived from actions.
03:06:35 <dminuoso> Rogjt/
03:06:36 <dminuoso> Right.
03:19:40 <V3> Hi everyone.
03:19:40 <V3> Over the past few months, I have written Blast, a distributed computing library, inspired by Apache Spark.
03:19:41 <V3> It is now open source and can be found on github: https://github.com/jcmincke/Blast
03:20:45 <kuribas> cool.
03:22:36 <Unhammer> V3, you should share on https://gitter.im/dataHaskell/Lobby :)
03:23:23 <Unhammer> (or I can if you don't want to make yet another account)
03:24:37 <spatial> readfromarray = do { a <- createarray; liftIO (runReaderT (readvalue 1) a) } writetoarray = do { a <- createarray; liftIO (runReaderT (writevalue 1 2) a) }
03:25:08 <spatial> In this 'a', the array is shared only if used within the same function ?
03:25:45 <spatial> No global ?
03:27:03 <V3> Unhammer, thanks, done.
03:27:54 <cads> Hey guys, I've got a bunch of JSON entries and I'd like to extract their schema, build some statistics about the fields, and build some validation/sanity checks into a data consumer
03:29:01 <Unhammer> :)
03:29:35 <cads> the data set consists of about 360 json objects, and I've been able to use Jq to extract their path structures and compare them across the data set
03:30:40 <cads> things are pretty homogenous at the json level, though there is a field that has a somewhat freeform string element which is important
03:35:29 <carter> cocreature: I actually need the new random lib for work. May use test some API stuff first though
03:35:35 <spatial> I mean in this http://pastebin.com/sUquHU0L. The array reads and writes can happen inside the same functions. Is it possible to share it globally ?
03:36:26 <_sras_> Using attoparsec-bytestring lib, how can I match a NULL value in a bytestring?
03:37:43 <cads> Example of the unstructured part of the input: https://gist.github.com/maxsu/a64a5ad97c7f36591627abc7be311f21 , as well as my best effort so far in parsing it: https://gist.github.com/maxsu/95a5c12b961cda389ce3b9b3840dba41
03:40:31 <Athas> spatial: in fairness, the type errors when working with monad transformers can be quite horrible.
03:40:38 <Athas> In general, Haskell isn't in the best place wrt. type errors...
03:41:05 <cads> This is my data extraction pipeline so far: https://gist.github.com/maxsu/8d47d6cd9e26c3af26d1ea5c35e19abf
03:41:26 <cads> kinda awful, no?
03:42:12 <Athas> cads: all those unescaped shell variables give me the jitters.
03:42:48 <cads> Athas, ach, you're right
03:43:12 <Athas> Also, put a 'set -e' there or you will have a bad time eventually.
03:47:10 <spatial> Athas: I never figured out anything from the error reports. Too difficult for me.
03:47:44 <spatial> Just that there was an error :-)
03:49:13 <kuribas> You learn to read the eventually.
03:49:28 <kuribas> The problem is that many libraries have convoluted types. Especially lens...
03:51:18 <cads> I kinda wish shell variables were self quoting
03:51:39 * cads has swiffered all the non-quoted variables away
03:52:20 <liste> @hackage shellcheck
03:52:21 <lambdabot> http://hackage.haskell.org/package/shellcheck
03:52:29 <liste> not on hackage :(
03:52:38 <liste> but it's awesome https://www.shellcheck.net/
03:54:45 <Unhammer> +1 on shellcheck, can no longer live without it
03:59:56 <merijn> Is anyone aware of a writeup off persistent's internals somewhere?
04:00:03 <cads> oh wow
04:00:11 * cads feels fuzzy inside
04:00:48 <danza> this seems to be the right link http://hackage.haskell.org/package/ShellCheck
04:01:04 <cads> grep -rl "#!/bin/bash" | xargs -I % shellcheck %
04:16:22 <oihdsg> 9 11 attacks, Did USA do it itself or it just let it happen?
04:23:57 <M-Magnap2> That's... Incredibly off topic
04:24:22 <M-Magnap2> If you want a flame war, asks about record syntax instead ;)
04:24:26 <M-Magnap2> *ask
04:25:27 <Athas> M-Magnap2: why?  There is only one notation worth fighting for anyway.
04:25:38 <Athas> Haskell records were an inside job.
04:31:19 <hpc> the iphone was an inside Jobs
04:34:13 <maerwald> that pun
04:44:28 <mbrock> is there a combinator or pattern for turning a "Lens' s a" and a "Lens' s b" into a "Lens' s (a, b)"?
04:45:15 <_sras_> Is it possible to do IO from within a parser monad in Attoparsec?
04:45:56 <osa1> mmm I just sent a PR to a lib that was last updated on 2013
04:46:06 <merijn> _sras_: No
04:46:29 <osa1> srbaker_: no
04:46:44 <mbrock> ah, I guess I'm looking for "alongside"
04:47:25 <_sras_> merijn: So what can I do to debug a parser?
04:48:22 <liste> _sras_: there's Debug.Trace.trace, if it's useful to you
04:53:05 <merijn> Anyone used OpalEye?
04:53:58 <_sras_> merijn: Yes
04:55:18 <_sras_> liste: Anything bundled with these parser combinators for debugging parsers?
04:55:28 <merijn> _sras_: Debug.Trace is in base
04:57:28 <mbrock> (oops, no, alongside isn't it...)
04:58:10 <Athas> _sras_: just consider yourself fortunate you're not using Happy!
04:58:12 <Athas> No debugging there.
04:58:43 <merijn> As far as I can tell my options (besides writing raw SQL) are: 1) persistent + esqueletto (Pros: supports streaming, joins, automatic migration. Cons: No flexibility with schema) 2) Groundhog (Pros: Very flexible schema. Cons: no streaming, no joins. Not sure about migration) 3) opaleye (Pros: Flexible schema management, joins. Cons: No migration, doesn't setup tables, no streaming)
04:59:16 <merijn> Oh, and I forgot the "lacking type safety" for esqueletto
05:01:18 <cocreature> writing raw sql is not that bad :)
05:01:54 <Athas> cocreature: the yak doesn't shave itself.
05:02:15 <merijn> cocreature: It's not that I dislike writing raw SQL, but then all my type safety goes out the window too
05:02:38 <cads> hey guys, anyone know where I could find cost/performance comparisons for computer hardware, driven by live data?
05:02:52 <cocreature> merijn: yeah thatâs a fair point.
05:03:12 <Athas> cads: how do you even measure performance in a comparable way?
05:03:26 <cads> I'd like to quantify the cost/performance benefit of various tiers of desktop and laptop hardware
05:04:04 <cocreature> cads: that doesnât seem to be a haskell question :)
05:04:08 <merijn> cocreature: It seems odds that besides persistent all the other database libraries only offer queries returning lists, rather than streaming...wanting to deal with huge queries shouldn't be such an odd thing?
05:04:09 <cads> Athas, I'd be happy with relatively simple metrics - coupling CPUMark results to a laptop's cost
05:04:19 <cads> cocreature, it's a cohaskell question ;()
05:04:23 <cads> ;)*
05:04:29 <merijn> cocreature: Similarly, the lack of joins in groundhog seems limiting too
05:04:46 <cocreature> merijn: well persistent on its own is also lacking joins
05:04:55 <merijn> cocreature: I know
05:05:06 <merijn> And esqueletto adds joins at the cost of type-safety
05:05:08 <cocreature> merijn: Iâve never really used any of the higher level libs so I donât know much about them
05:05:13 <merijn> It's inadequate compromise all around
05:05:36 <Athas> Make your own!
05:05:40 <cads> It /could/ be a haskell question, if the question is how to use haskell to pull CPU benchmark data, computer hardware data, and join the two
05:05:54 <merijn> cocreature: My basic tests with persistent itself is ok, but it's kinda annoying that you can't represent compound entities in their schema language
05:05:59 <merijn> Athas: I already have enough yaks
05:06:00 <cocreature> yesterday I got annoyed when I realized that _none_ of the haskell sql libs can properly work with arrays of composites in postgres
05:06:28 <robkennedy> On hardware: do I need an Nvidia GPU to use accelerate?
05:06:39 <Athas> robkennedy: you can also use a CPU.
05:06:48 <Athas> But NVIDIA GPUs are the only supported GPUs (or accelerator at all).
05:06:55 <cocreature> accelerate-llvm doesnât need a gpu iirc
05:07:01 <merijn> Athas: Adding conduit/pipes support to OpalEye seems the easiest way to get closer to where I wanna be
05:07:30 <Athas> merijn: already looking for your yak trimmer?
05:07:33 <merijn> In the sense that OpalEye has both schema flexibility and joins
05:07:58 <cocreature> merijn: it seems like opaleye already supports streaming queries in some form https://github.com/tomjaguarpaw/haskell-opaleye/pull/69
05:08:00 <merijn> Athas: Well, if I fix it once *now*, I won't ever have to do it again if I need to do things in the future!
05:09:30 <merijn> cocreature: That's only in opaleye, not opaleye-sqlite
05:09:40 <merijn> But I guess I could rip the same code off
05:09:43 <Athas> Accelerate used to support OpenCL, but it's long since bitrotted away: https://github.com/HIPERFIT/accelerate-opencl
05:10:00 <cocreature> oh, I wasnât even aware that opaleye supports something other than postgres
05:10:46 <merijn> https://hackage.haskell.org/package/opaleye-sqlite
05:11:03 <merijn> But not sure how much (if any?) it's lagging behind opaleye itself
05:11:23 <Athas> Why not do everything in pure Haskell?  Just load in the data as a bunch of arrays (or lists, if you have plenty of time) and go to town.
05:11:31 <merijn> bah
05:11:40 <merijn> Last updated in 2015 :\
05:12:08 <cocreature> reinventing relational databases in haskell is definitely a good use of your time
05:12:38 <merijn> Athas: Because SQLite has many great properties: 1) it's fast 2) it allows me to replace 50k result files with a single database 3) it's robust 4) it's portable to other languages 5) it handles data larger than my RAM
05:14:00 <Nuub> Hello everyone! I'm new to Haskell and I was wondering how do you write this without let bindings? let notNull x = not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]]
05:14:33 <cocreature> Nuub: replace filter notNull by filter (\x -> not (null x))
05:15:00 <merijn> Sadly it looks like opaleye's sqlite support is bitrotted, so that's out too
05:15:18 <Athas> Nuub: the nice thing about Haskell is that you can always just substitute the definition of a let-bound name where the name is used.  (As long as there are no name conflicts.)
05:17:53 <merijn> Yak's all around :\
05:19:06 <cocreature> Iâm accepting bets on when merijn gives up and just uses sqlite-simple
05:19:27 <merijn> cocreature: More likely: I give up and don't use anything
05:19:27 <Athas> merijn: don't worry, at least you still have C++ and GPU driver issues to keep you occupied.
05:20:32 <merijn> Naah, my C++ code is mostly solid right now and I don't have to maintain the driver
05:21:17 <Athas> I have spent a lot of time fighting drivers and rebooting crashed GPUs.
05:21:29 <Athas> I can't believe people use this stuff in production.
05:22:30 <merijn> Athas: Aren't you running code on a cluster maintained by a dedicated admin?
05:23:09 <Athas> merijn: no.  Our IT department installed RHEL on the machines and manage access rights, but I do most of the day-to-day maintenance (and kick them when they fall over).
05:23:14 <merijn> Didn't ircbrowse have this nice summary of activity in channels?
05:23:42 <Athas> And I am not a particularly competent systems administrator.
05:23:53 <merijn> Athas: Ah, we have a dedicated cluster shared by a few universities with a fulltime admin I can just yell at
05:24:36 <Athas> Must be nice!  Wish we had that.  Maybe even a proper job queuing system.  A man can dream...
05:24:42 <merijn> Nothing except the logs seem to work on ircbrowse :\
05:24:47 <Athas> At least I have root on our machines, so I can just kill everyone when I need to run benchmarks.
05:25:54 <cads> hey lispy, are you around?
05:26:27 <tabaqui1> can I call shell command in haskell template?
05:26:35 <tabaqui1> I want simple code, alike
05:26:50 <tabaqui1> version = $(exec "git log | head -n 1")
05:29:24 <quchen> tabaqui1: System.Process can execute commands, runIO runs IO during TH.
05:30:04 <sbrg> and there are probably git libraries to do what you want. if you have your proper version in the cabal file, you can also read the cabal file's version 
05:30:22 <tabaqui1> quchen: yeah, readProcess + runIO
05:30:24 <tabaqui1> thanks
05:30:27 <Athas> tabaqui1: https://hackage.haskell.org/package/shqq-0.1/docs/System-ShQQ.html
05:31:04 <Athas> Then you don't have to fiddle around with TH yourself.
05:31:37 <tabaqui1> last uploaded: 2011
05:31:49 <tabaqui1> I have to rebuild it manually then
05:32:03 <tabaqui1> but thx too, I could stole some code from it)
05:32:04 <chenyu`> quchen: just read about this part in a TH tutorial. "For example, the quotation [| 1 + $(f x) |] will execute (f x) â which must have type Q Exp, translate returned Exp value to literal Haskell code"
05:32:13 <chenyu`> quchen: http://web.archive.org/web/20100703060856/http://www.haskell.org/bz/thdoc.htm
05:35:25 <Nuub> cocreature, thanks. Can it be done without lambdas?
05:36:05 <merijn> I don't suppose anyone knows an old mirror of ircbrowse that still works?
05:38:10 <chenyu`> Nuub: filter (not . null) [......] maybe like this?
05:39:12 <Nuub> chenyu`, thanks :)
06:25:29 <spatial> Trying once more. Have the code http://pastebin.com/sUquHU0L How does a function that writes pass the updated array to another ? Not getting it.
06:26:39 <spatial> I have some lisp code and I convert that. Seems functions try to access shared array. (defvar value-table)
06:26:52 <Athas> spatial: you need to use just one monadic action: readandwritefromarray = do { a <- createarray; liftIO (runReaderT (do {writeValue 1 2; readvalue 1}) a) }
06:27:00 <Athas> (Although hopefully with more linebreaks.)
06:28:38 <spatial> Yes. But then http://pastebin.com/G3QAQemD lisp seems different.
06:29:04 <Athas> Yes, because in Lisp you can have implicit global mutable variables.
06:29:21 <Athas> That doesn't fly in Haskell.  You use monads to precisely describe the context in which the side-effects occur.
06:29:35 <spatial> Ok. Refactor ?
06:29:48 <Athas> Yes.
06:43:57 <lpaste_> bezirg pasted âScopedTypeVariables questionâ at http://lpaste.net/353269
06:44:34 <bezirg> can anybody explain me why http://lpaste.net/353269   that uses ScopedTypeVariables does typecheck?
06:46:06 <lyxia> bezirg: line 20; let o2' = o2
06:46:20 <lyxia> line 24; let o2' = o2'
06:47:27 <bezirg> lyxia: omg, thanks for spotting this, I thought something was wrong with ScopedTypeVariables :)
06:48:15 <lyxia> you're welcome
06:48:32 <nitrix> I thoughti t was intentional and trying to figure out the isomorphism here x]
06:58:58 <ij> Will one be able to write some types of code that depend on bytestring/string/text only once with backpack?
06:59:42 <lyxia> isn't that the point of it?
07:00:24 * ij is just making sure he got it right.
07:02:49 <lyxia> ij: Okay. That sounds right to me.
07:04:56 <lyxia> ij: We can already sort of do that with type classes but it's not very modular, see comments at the bottom http://blog.ezyang.com/2016/09/the-base-of-a-string-theory-for-haskell/
07:07:42 <spatial> Is there a return type to signify void ?
07:08:05 <sbrg> spatial: there is Void, a type with no inhabitants
07:08:09 <spatial> State is changed but the functions doesn't explicitly return
07:08:17 <sbrg> which means you can't return anything but undefined
07:08:28 <sbrg> return unit?
07:08:29 <sbrg> ()
07:08:40 <sbrg> that is the traditional way 
07:08:53 <spatial> return ()
07:09:38 <spatial> declaration is :: ()
07:16:13 <lyxia> yes, you return something which carries no information, which is the equivalent of not returning anything in imperative languages.
07:17:42 <Yttrill> hi, can anyone help me convert a small function to use unboxed ints? 
07:20:59 <cocreature> Yttrill: itâs hard to see answer that question without seeing the function :)
07:21:18 <Yttrill> import System.IO  n = 13 main = do   (print n)   (print (ack 3 n))  ack :: Int -> Int -> Int ack 0 n = n + 1 ack m 0 = ack (m - 1) 1 ack m n = ack (m - 1) (ack m (n - 1))
07:21:22 <Yttrill> hmm
07:21:28 <cocreature> @where lpaste
07:21:28 <lambdabot> http://lpaste.net/
07:21:42 <cocreature> use that for posting your code
07:21:52 <lyxia> why do you want to unbox this
07:22:02 <Yttrill> because its too slow
07:22:12 <cocreature> have you compiled with optimizations?
07:22:13 <Yttrill> 5 times slower than C
07:22:18 <Yttrill> yes
07:22:33 <Yttrill> ghc 7.10
07:22:52 <lyxia> First add strictness annotations
07:23:34 <Yttrill> http://lpaste.net/353271
07:24:27 <cocreature> yeah add a strictness annotation to the second argument
07:24:40 <Yttrill> how
07:24:47 <Yttrill> sorry i'm just learning Haskell
07:24:55 <shapr> I feel that way too
07:24:57 <Yttrill> this is in a performance comparison
07:25:41 <cocreature> you are probably not going to beat C if thatâs your goal
07:25:46 <shapr> I like comparing time to write code that solves a problem among languages.
07:26:06 <shapr> For me, Haskell almost always wins that performance comparison.
07:28:28 <Yttrill> i just want a fair comparison, C, Felix, Ocaml, Haskell
07:28:55 <Yttrill> without optimisations Haskell takes over 2 minutes 
07:29:16 <Yttrill> with -O2 15 seconds
07:29:31 <Yttrill> Ocaml does 4 seconds
07:29:43 <Yttrill> clang 3.8 
07:29:47 <Yttrill> and gcc 2.2
07:30:13 <Yttrill> the original code use Int#
07:30:33 <Yttrill> but it didn't work on 7.10 so i removed the unboxing
07:31:05 <shapr> Yttrill: Have you benchmarked hand written assembly?
07:31:16 <Yttrill> nope
07:31:34 <Tuplanolla> Read up on `BangPatterns`, Yttrill.
07:32:01 <Yttrill> yeah, i just looked at BangPatterns, is that in 7.10?
07:32:10 <Tuplanolla> Yes. It has been around forever.
07:32:25 <Yttrill> i could perhaps upgrade to 8 but i'm using OSX Sierra ..
07:32:36 <cocreature> looks like bang patterns donât help
07:32:54 <cocreature> unboxing wonât help either since ghc already unboxes this
07:33:13 <cocreature> one thing you could try is using the llvm backend but I donât have the right llvm version installed to do so
07:34:37 <StarsC> why cabal has docs disables by default? 
07:35:05 <dramforever> cocreature: *Exactly* what I did a few seconds ago
07:35:16 <dramforever> -fllvm, oh well it doesn't work
07:35:26 <Yttrill> so its already unboxed?
07:35:34 <cocreature> Yttrill: yep
07:35:43 <dramforever> Yttrill: yes, you can check by passing -ddump-simpl
07:35:50 <Yttrill> ouch
07:35:54 <dramforever> (-fforce-recomp also helps when playing)
07:36:07 <dramforever> So, conclusion: Haskell sucks at computing ack
07:36:11 <Yttrill> yep i found that
07:36:23 <cocreature> dramforever: I already have 3 different llvm builds installed. Iâm too lazy to have another one for ghc :)
07:36:25 <shapr> Is that a real world test?
07:36:38 <Yttrill> no its a stupid micro test
07:37:04 <cocreature> llvm would probably be worth the effort if you are really keen on getting this example fast
07:37:40 <Yttrill> you mean make ghc generate LLVM code?
07:37:46 <Yttrill> instead of C?
07:37:56 <cocreature> ghc does not generate C, it has itâs own code generator
07:37:57 <dramforever> It doesn't generate C really
07:38:04 <cocreature> but yeah make it use llvm instead
07:38:09 <cocreature> you can do so by passing -fllvm
07:38:10 <dramforever> cocreature: You handle this, goodbye :P
07:38:15 <Tuplanolla> It used to generate C.
07:38:33 <dramforever> That's like forever ago
07:38:42 <Tuplanolla> Indeed.
07:38:54 <Tuplanolla> Still, the documentation won't die.
07:39:16 <dramforever> -fvia-C is already dead
07:39:48 <Yttrill> ok it can't figure llvm version
07:40:00 <Yttrill> i wonder where it lives ..
07:42:02 <Yttrill> Apple LLVM version 8.0.0 (clang-800.0.42.1)
07:42:20 <Yttrill> how do i tell ghc where llvm is?
07:45:18 <StarsC> why people dont use https://gitter.im/haskell-chat/Lobby?  u can post code directly in chat
07:45:28 <StarsC> seems more advanced than irc
07:45:37 <quchen> Yttrill: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#replacing-phases
07:46:12 <shapr> StarsC: same reason windows is still popular, it's hard to unseat an incumbent with an active community.
07:47:08 <StarsC> i know that many people from here use gitter
07:47:23 <StarsC> but majority seems not
07:48:52 <luis3m> I like chatting in my Emacs editor, but as you say gitter is better to post code and stuff
07:50:28 <StarsC> also gitter seems to be more community oriented, you can go and look at people work by clicking on their picture
07:51:29 <Tuplanolla> Where's the source code to their server, StarsC?
07:51:39 <StarsC> gitter?
07:51:49 <cocreature> good luck trying to convince the 1538 people in here to move to gitter
07:51:57 <Tuplanolla> Yes, StarsC.
07:52:08 <StarsC> Tuplanolla: i did not know its not opensource
07:52:30 <StarsC> cocreature: i up if people will write haskell clone of irc with all good features
07:52:33 <luis3m> Cool, I'm gonna join there as well.
07:53:15 <StarsC> cocreature: just saying irc is outdated, there is irc, haskell-maillist , twitter, github
07:53:18 <StarsC> hard to follow
07:53:35 <cocreature> StarsC: sure irc is outdated. but it somehow works and people use it
07:53:45 <cocreature> twitter & github are completely different things
07:53:46 <StarsC> well lets make new one?
07:53:55 <Tuplanolla> All the improvements are either proprietary or garbage, so IRC lives on.
07:54:07 <shapr> There have been many new IRCs, I haven't seen any huge successes.
07:54:24 <srk> hehe, slack even has IRC gateway :D
07:54:29 <StarsC> Tuplanolla: whats wrong with posting code? or maintaining proper profiles of community users?
07:54:38 <shapr> I think IRC has the sweet spot of being extremely simple and using DCC for additional features.
07:55:01 <Tuplanolla> The lack of support for equations and a user interface that's not a 200 MB JavaScript abomination for example, StarsC.
07:55:13 <shapr> ooh, inline LaTeX would be awesome
07:55:30 <StarsC> Tuplanolla: good point, so why u still think irc is good?
07:55:30 <shapr> I also wish for messages longer than 512 chars
07:55:54 <Tuplanolla> I don't, but it's good enough to stay relevant, StarsC.
07:56:00 <amf> are there any good libraries for helping one generate random data? is this something quickcheck is suited for?
07:56:11 <cocreature> I doubt anybody argues that IRC doesnât have problems. they are just not big enough for people to move away from it
07:56:22 <shapr> amf: yes, there are haskell wiki articles on using quickcheck to generate random data for testing java, etc
07:57:08 <Yttrill> kak .. ok i have to compile LLVM to make haskell go fast :-(
07:57:30 <StarsC> Tuplanolla: i guess in this way of thinking email is more relevant than irc
07:57:42 <Tuplanolla> That's true.
07:57:46 <shapr> Yes, I agree with that.
07:58:31 <shapr> StarsC: I tried to make a multi-user pair programming web app in Haskell, for teaching on #haskell, but it didn't get popular in the Haskell community.
07:58:56 <StarsC> shapr: is it on hackage?
07:59:19 <shapr> StarsC: if you like the sort of features that gitter has for pasting code, fpcomplete's IDE did way more cool stuff, it was closer to a shared jupyter notebook for Haskell (with state and auth)
07:59:35 <shapr> StarsC: yes, but last updated 2012
07:59:35 <StarsC> nice
08:00:05 <StarsC> but fpcomplete closed its haskell school?
08:00:19 <StarsC> i mean online ide
08:00:51 <shapr> The previously created articles are still available, but I think creation of new articles has been disabled.
08:01:08 <shapr> I'd love to host that IDE on my own server.
08:01:11 <shapr> for my own use
08:02:31 <StarsC> are there any emacs multi user editing capabilities?
08:02:51 <shapr> StarsC: yes, but rarely used
08:03:54 <shapr> StarsC: I haven't tried those multi-user editing libraries lately, I couldn't find anyone who wanted to pair with me across the internet :-(
08:04:25 <Yttrill> how big is an Int in ghc? (on x86-64)?
08:05:24 <tsahyt> Hello. I want to implement a function that works for all types (contained in a particular functor) but if it happens to be one specific type, it should act slightly differently. How would I got about solving this? I suppose I can just provide two versions of the function but maybe there's some nifty typeclass hackery I can put to work here
08:06:27 <shapr> Yttrill: pretty sure it's 64bits
08:06:48 <shapr> tsahyt: sounds like a typeclass thing to me
08:07:27 <Yttrill> 64 bits would explain the performance issue
08:07:46 <tsahyt> shapr: but I would end up with overlapping instances I think
08:07:59 <tsahyt> although right now I'm not getting even a warning.. hmm
08:08:22 <tsahyt> ah, they appear on use
08:09:20 <tsahyt> I'd somehow have to express instance a !~ T => C a, with !~ meaning that it does *not* unify
08:09:23 <tsahyt> but afaik that's not possible
08:10:37 <Yttrill> ooo .. if i change C to use int64_t its 17 seconds .. ghc is faster now
08:11:15 <Yttrill> ah no i forgot -O2 ;(
08:11:27 <Yttrill> still 4 seconds for C
08:11:48 <Tuplanolla> You probably won't see GHC beat GCC in microbenchmarks such as this one, Yttrill.
08:12:02 <Yttrill> ackman is dependent entirely on how many words go on the machine stack
08:12:07 <Tuplanolla> The real benefits come in at larger scale via sharing and fusion.
08:12:58 <Yttrill> one can share stuff in C too
08:13:24 <Yttrill> fusion should be a big win tho
08:13:30 <Tuplanolla> You can do anything in C.
08:13:34 <Yttrill> neither Felix nor Ocaml can do that AFAIK
08:14:08 <iainhallam> Anyone know why GHC has precompiled binaries for CentOS 6.7 but not CentOS 7, which is now nearly three years old?
08:14:10 <Yttrill> well, in C you have problems with memory management
08:14:43 <Yttrill> actually i'm trying to see how fast my own language is :)
08:14:44 <iainhallam> Or, for that matter, what the difference between the Debian 7 version (which works on CentOS 7) and the Debian 8 version?
08:14:53 <tsahyt> hmm, okay with an overlaps pragma it works at least for a simple test
08:14:58 <iainhallam> They both say compiled against libgmp.so.10.
08:16:07 <unclechu> hey guys, i wan't to make my first library that i'm going to publish to hackage, any tutorials you could recommend me to read first? how do i test it for different ghc versions?
08:16:59 <unclechu> now i usually use stack and don't even specify packages versions in `*.cabal` file and let stack-lts provide it
08:17:13 <Guest88422> test
08:17:23 <tsahyt> oh, maybe this even works properly with overlapping instances
08:17:32 <unclechu> in case where i develop a public library i should specificy ranges of acceptable versions i guess
08:17:52 <cocreature> unclechu: https://github.com/hvr/multi-ghc-travis is great for testing against multiple ghc versions
08:18:19 <unclechu> cocreature: thanks
08:20:00 <tsahyt> I guess it does. so in my case I have a instance C a, and a single instance C T, which is always the most specific instance for T.
08:20:13 <tsahyt> nice, and the class constraint I have to introduce even serves some documentative purpose
08:21:53 <StarsC> unclechu: please write good docs and at least ONE example :)
08:22:24 <unclechu> StarsC: of course, i'll try my best :)
08:24:35 <EvanR> please write more than just one example, more than examples
08:24:55 <EvanR> like, write words
08:28:14 <cocreature> EvanR has the best words
08:30:19 <suica> I'm trying to understand `once` as it's defined here: http://neilmitchell.blogspot.com/2012/06/flavours-of-mvar_04.html -- recreated here http://lpaste.net/353272 using plain MVars. 
08:31:21 <suica> firstly, why can't the signature be `IO a -> IO a`? do you need the wrapper IO to create the enclosed MVar?
08:34:49 <cocreature> suica: if you use IO a -> IO a it would need to execute the action immediately. using IO (IO a) allows passing an action back to the caller and leaving it up to him if and when it is called
08:38:12 <ski> suica : the outer `IO' in `IO (IO a)' is required because of the `newVar'. the inner is required to modify it, to manipulate the `Barrier', and to execute the input action
08:38:27 <suica> cocreature: makes sense. is it not possible to write `once'` that lets you do `do { let g = once' f; x <- g; y <- g; ... }` with the behavior of `once`?
08:38:52 <suica> cool, that makes sense
08:39:22 <saylu> Hey folks!
08:39:26 <saylu> Iâve been searching for inspiring & interesting Haskell code, talks, and writing lately and I thought you all would have some favorites.
08:39:36 <saylu> Iâd love to hear about any Haskell stuff thatâs inspired you before!
08:40:30 <saylu> Hereâs good, and I also made a thread on /r/haskell that Iâll copy responses over to unless youâd like to just post there
08:40:31 <saylu> https://www.reddit.com/r/haskell/comments/5xtrq6/inspiring_code_talks_papers_and_writing_in_haskell/
08:40:52 <magnap> suica: If you'd accept `g <- once f` you could probably use some kind of forcing, if I'm understanding you correctly
08:41:05 <ski> suica : `let g = once' f' doesn't work since it needs to allocate a `Var', so there must be an outer action
08:41:43 <shapr> saylu: https://github.com/glguy/advent2016 solutions for http://adventofcode.com/2016/
08:42:16 <suica> thanks, makes sense. was going to ask why I couldn't manage to generalize `once` to `Monad m => m a -> IO (m a)` but I get it now
08:42:41 <saylu> thanks shapr!
08:48:38 <tsmish> Yttrill, looks like your program allocates lot of memory. It literally spends 90% time in GC. Can anyone explain this to me.
08:49:04 <suica> ski: what's the reason for the `return $ join $ modifyMVar` in `once` instead of just `modifyMVar` (which is the same type)? don't really understand his explanation. 
08:49:35 <le_frogballs> Is there a way to do package imports in Haskell as you would in Scala? I don't want to have to import everything I need manually in every file
08:50:27 <cocreature> le_frogballs: you can make modules that reexport other modules to accomplish something similar but there is nothing that no way to accomplish this directly.
08:51:05 <le_frogballs> cocreature: yea that was the hack I was planning on doing
08:51:28 <ski> suica : the `modifyVar var (...)' has type `IO (IO (...))', the outer `IO' represents modifying the mutable cell referenced by `var', the inner `IO' represents an inner I/O action (involving barriers and executing `act') which results from reading that mutable cell
08:51:57 <ski> suica : we want to perform both of these two "layers", one right after the other -- hence the `join'
08:52:44 <ski> suica : then the `return' means that the resulting I/O action isn't to be performed immediately, but only when the executer of `once' decides to subsequently execute this computed I/O action
08:53:05 <tsmish> Looks like I misunderstood output, sorry.
08:57:32 <suica> ski: thanks, makes sense. so if you removed the `return $ join $` it would still typecheck, but the resulting `IO (IO a)` when executed would fill the outer MVar and return an action which, when executed, fill the barrier and return `x` (the first time) and then block forever on subsequent executions?
08:58:35 <ski> suica : something like that, i suppose (i didn't keep track of the details of how `once' is supposed to do its job)
08:59:34 <ski> suica : with `IO (IO (...))' we "monadically" return a callback action (i.e. the caller will use it later to callback into code given by the callee)
09:00:22 <ski> (as opposed to "input callbacks", where the caller is providing some code that the callee (or someone it delegates responsiblity to) will call back into)
09:02:29 <suica> ski: thanks, it's a lot clearer to me now!
09:03:25 <ski> np
09:06:10 <koala_man> liste: shellcheck is on hackage with a case sensitive url: http://hackage.haskell.org/package/ShellCheck
09:18:04 <Geraldus> Hi folks!
09:18:26 <Geraldus> Does anyone knows how to configure Apache2 to redirect some requests to Keter?
09:19:59 <unclechu> StarsC: what do you think, is this readme good enough? https://github.com/unclechu/haskell-qm-interpolated-string did i missed something?
09:23:46 <suica> ski: so I modified `once` a bit to add a non-blocking lookup before the blocking `modifyMVar` -- would you mind taking a quick look? http://lpaste.net/353274 I purposefully kept the `Nothing` check inside the `modifyMVar`.
09:23:47 <sdrodge> Anyone willing to look at my code for this hackerrank problem: https://www.hackerrank.com/challenges/messy-medians and tell me how it could be done better? https://hastebin.com/ulewutuwey.hs
09:30:30 <chenyu`> Oh, this hackerrank is what I am looking for.
09:30:43 <chenyu`> A haskell leetcode
09:30:45 <chenyu`> cool
09:33:12 <chetshah_> Hello all, haskell beginner here, Just saw this definition of fix in haskell wikibook : fix f = let {x = f x} in x, was wondering if the curly braces have some meaning?
09:33:39 <kuribas> chetshah_: yes, they delimit the substatement.
09:34:24 <kuribas> chetshah_: well, substatements.  But alternatively, you can use the layout rule.
09:34:55 <kuribas> chetshah_: what the layout rule does, is just insert curly braces based on indentation.
09:35:18 <benzrf> chetshah_: they are not strictly necessary there; that particular case works without em
09:35:20 <chetshah_> kuribas you mean escape hatch for layout rules ?
09:36:11 <kuribas> benzrf: because of the layout rule.
09:36:31 <geekosaur> chetshah_, more practically, you need the braces there if you're combining stuff into a single line for ghci (or lambdabot) and the let is inside another layout-inducer like do
09:37:13 <geekosaur> because let can do more than one binding at a time and the language can't tell when the binding list for let ends and the do resumes
09:37:13 <kuribas> chetshah_: the braces are part of the "real" syntax, the layout rule is a convenience.
09:37:57 <monochrom> layout is escape hatch for the {;} rules.
09:39:03 <chetshah_> Ah.. that makes sense. Thanks all. Was hard to find this on googling though. Guess I would find more under indentation section.
09:52:58 <kuribas> What do you use for debugging?
09:53:02 <kuribas> Debug.Trace?
09:54:11 <bollu> is there a way to "create a pattern match" from a lens? something of the form, "if a.b.c.d == val, allow this lens to match"
09:54:36 <bollu> I have a deep structure, on which I want to perform an operation only if its shape looks like something I know
09:56:00 <mnoonan> bollu: you know about view patterns?
09:56:54 <bollu> mnoonan: oh, right, the syntax extension :)
09:56:57 <bollu> mnoonan: pretend I don't know
09:57:06 <bollu> mnoonan: could you tell me how they could be used here?
09:57:21 <mnoonan> well, I'm not entirely clear on what you want to do :)
09:57:52 <kuribas> bollu: why not use normal pattern matching?
09:58:12 <geekosaur> I think the point is that the only pattern they have is the lens
09:58:20 <geekosaur> which sounds like a view pattern using has to me
09:58:33 <bollu> kuribas: a little too unweildy
09:58:50 <geekosaur> ...or just a guard for that matter, unless they also want the deconstruction behavior
09:59:09 <kuribas> bollu: in that case view patterns or pattern synonyms are your friend.
10:00:12 <geekosaur> actually has is the guard, one of the ? variants for lens matches for view pattern so you get a Maybe
10:00:21 <geekosaur> bleh
10:00:50 <bollu> kuribas: it looks like this:
10:00:50 <bollu> case closure of
10:00:50 <bollu>             Closure {
10:00:50 <bollu>                 lf @ _lambdaForm = 
10:00:50 <bollu>                     LambdaForm{
10:00:50 <bollu>                         _lambdaShouldUpdate = False
10:00:50 <bollu>                     }
10:00:51 <bollu>             } -> stepEnterIntoNonUpdateableClosure lf
10:00:51 <bollu> I want to simplify the mess
10:00:53 <bollu> I don't think that will even compile :P
10:00:54 <bollu> I see
10:00:54 <bollu> but I hope the intent is clear
10:00:55 <bollu> if the internal structure looks like so, hand over the lambdaForm
10:00:55 <bollu> Gurkenglas_: hey
10:01:05 <kuribas> bollu: use a pastebin
10:01:18 <kuribas> like lpaste
10:02:54 <kuribas> bollu: that doesn't look like haskell...
10:03:22 <byorgey> kuribas: it is =)
10:03:45 <geekosaur> it is, just oddly laid out
10:03:59 <geekosaur> probably from the paste
10:04:10 <geekosaur> (again, reasons to use a paste site...)
10:04:20 <kuribas> what's the "=" doing there?
10:04:54 <geekosaur> it's a record-syntax pattern match, in a case
10:05:17 <geekosaur> Constructor {aspattern @ fieldname = bindname}
10:05:25 <kuribas> is that an extension?
10:05:29 <geekosaur> no?
10:05:52 <geekosaur> it's not the most common construct in the langaiuge but I use various pieces of it fairly regularly
10:06:10 <kuribas> strange, I haven't seen that before...
10:06:41 <Tuplanolla> I thought the name would come to the right of `=`.
10:07:03 <geekosaur> also I'm not sure what point the as-pattern has there, but.
10:07:55 <lpaste_> bollu pasted âungainly-pattern-match-can-lensify?â at http://lpaste.net/353275
10:08:10 <bollu> geekosaur, kuribas: ^
10:09:05 <geekosaur> myKeys XConfig {modMask = modm} = fromList [ ... keybinds using modm as the KeyMask ... ]    :p
10:09:19 <geekosaur> (granted there's a reaosn we strongly recommend additionalKeysP these days...)
10:11:06 <contiver_> I just realized there is no liftA4, so I ended up using liftM4. Any particular reason for that?
10:11:20 <bollu> kuribas, geekosaur: how would I use ViewPatterns for this?
10:11:30 <bollu> contiver_: why not do-notation at that point? or <$> <*> â¦ ?
10:11:33 <geekosaur> nobody thought it was needed? and liftA<n> is just a chain of <$> ... <*> ... <*>
10:12:57 <Tuplanolla> We should totally have a `liftAN` splice for completeness.
10:13:32 <bollu> mnoonan: how do I ViewPatterns this?
10:13:35 <kuribas> I would write something like this: myFun closure | lf <- _closureLambda closure, _lambdaShouldUpdate lf == False = stepEnter... lf | otherwise -> error ...
10:14:01 <contiver_> bollu: I could do that, but then I'd either have more lines, or it would go further to the right. In other words, just personal taste.
10:14:20 <bollu> contiver_: I think a ViewPattern would carry intent better?
10:14:24 <contiver_> I just expected there would be a liftA4, being there a liftM4 already.
10:14:27 <bollu> contiver_: like, "this is a non updatable closure"
10:14:30 <kuribas> bollu: I'd only use a pattern synonym when I have the same pattern many times.
10:14:35 <bollu> kuribas: oh, I see
10:14:37 <bollu> kuribas: hm
10:14:43 <bollu> kuribas: I don't know how often this comes up
10:14:49 <geekosaur> contiver_, things like liftM4 are historical... and not very widely used
10:14:50 <bollu> I am implementing STG for understanding 
10:15:00 <bollu> if quchen was around, he would know
10:15:53 <geekosaur> so there's a fair amount of "...do we really need this?", akin to how there's 15 tuple instances for any typeclass that can take a tuple and a;most nobody uses anything bigger than a 3-tuple or the occasional 4-tuple
10:17:18 <geekosaur> (historical = that was before someone figured out they could use liftM and `ap` instead of having to have umpteen different liftMn-s)
10:17:40 <geekosaur> (which was how we spelled <$> and <*> in the monad version, which predated Applicative by like a decade or so)
10:17:57 <contiver_> geekosaur, yes, I get what you mean, monads came before than applicative, and hence both APIs share much.
10:18:21 <geekosaur> but more than that, liftMn for n > 2 is itself predating the generalized version
10:18:35 <geekosaur> whereas Applicative always had the generalized one
10:19:13 <geekosaur> and tbh I;ve never needed more than liftM3 / liftA3
10:19:16 <bollu> geekosaur: do you know the "actual" main type before IO? I am told it was [Input] -> [Output], but is that true?
10:19:32 <geekosaur> [Response] -> [Request]
10:19:39 <kuribas> bollu: there is filtered from lens, but it may not give a legal lens...
10:19:40 <dmwit> http://hackage.haskell.org/package/data-aviary-0.2.3/docs/Data-Aviary-Birds.html is pretty funny =)
10:19:40 <geekosaur> the initial Response had argv in it
10:19:42 <kuribas> :t filtered
10:19:45 <lambdabot> (Choice p, Applicative f) => (a -> Bool) -> Optic' p f a a
10:19:53 <geekosaur> among other things
10:20:00 <bollu> geekosaur: um, response to requests?
10:20:07 <bollu> geekosaur: explain that a bit please?
10:20:22 <Tuplanolla> The runtime system has the other order, bollu.
10:20:31 <Tuplanolla> It's like a server--client relationship.
10:20:37 <geekosaur> yes, you receive a Response from the OS (again, the initial one was the command line parameters) and produce Request-s to the OS for I/O. both were lazy lists
10:20:44 <bollu> ah
10:20:46 <bollu> dang
10:20:48 <bollu> that is quite cool
10:20:57 <Tuplanolla> Yeah, until you actually use it.
10:20:59 <bollu> is there some way to "go back" to that style of programming?
10:21:00 <bollu> xD
10:21:05 <dmwit> bollu: `Request` was an ADT with things like `PutStrLn :: String -> Request`, `GetLine :: Request`. `Response` was an ADT with things like `GotALine :: String -> Response`.
10:21:07 <bollu> Tuplanolla: what were the pain points?
10:21:19 <Tuplanolla> I didn't use Haskell back then.
10:21:30 <geekosaur> it's "cool" in the "neat hack" sense. I'd rather beat my head against a brick wall than actually *write* to it...
10:21:44 <dmwit> Pain points: your response consumption must be kept in synch with your request generation, or else you start reading responses to a different request than the one you sent.
10:22:10 <sdrodge> It's all fun and games until you accidentally force the input list too hard and get a deadlock.
10:22:16 <dmwit> Responses are completely untyped; even though you know `GetLine` should always respond with `GotALine s`, you still have to write a case that covers all possible responses.
10:22:28 <bollu> dmwit: hmm
10:22:45 <kuribas> What's a good debugging strategy?  I find the ghci debugger rather painfull.
10:23:17 <bollu> dmwit: is there some way to emulate this in current haskell? short of writing a library
10:23:22 <dmwit> :t interact
10:23:25 <lambdabot> (String -> String) -> IO ()
10:23:29 <kuribas> Or use cpphs to conditionally produce debug output?
10:23:31 <bollu> interesting
10:23:40 <bollu> dmwit: that seems quite REPLy
10:24:13 <geekosaur> you could say it's an inside-out REPL
10:24:31 <geekosaur> unfortunately the inside-out-ness will confuse you very quickly in real programs
10:25:21 <geekosaur> you could also say it's the event loop from Hell
10:25:32 <bollu> oh wow, you are forced to be lazy and consume just the right amount
10:25:41 <bollu> people actually coded like this? o.O
10:25:41 <geekosaur> because you're working the wrong side of it; the "normal" event loop is the runtime processing it from the other side
10:25:50 <sdrodge> bollu: Very briefly, yes.
10:26:10 <bollu> sdrodge: so, like, between monads and this, there was no other way to go?
10:26:13 <bollu> geekosaur: yeah
10:26:40 <dmwit> "No other way to go"? This seems unlikely.
10:26:42 <sdrodge> bollu: Not sure. My only exposure to this is from SPJ paper/talks where he mentions it.
10:27:11 <geekosaur> iirc the decision came down to 3 things, but I can;t remember the third (the second was current monadic I/O)
10:27:23 <dmwit> But the current solution has a lot of attractive properties. The burden is on *you* to come up with an alternative with better properties. =P
10:27:25 <geekosaur> so at least one other alternative that was judged to be inferior
10:27:35 <dmwit> Not on us to prove that all other alternatives are "worse"!
10:27:36 <sdrodge> He refers to the [Response] -> [Request] lazy list model of I/O as the embarassing time before someone figured out monads would work.
10:28:03 <bollu> geekosaur: do you know where I can read about the 3rd choice?
10:28:10 <dmwit> http://r6.ca/blog/20110520T220201Z.html
10:28:10 <bollu> dmwit: yeah, I was just curious about the design soace
10:28:12 <bollu> space*
10:28:15 <geekosaur> not offhand but probably the hair shirt paper
10:28:21 <geekosaur> which is what I think sdrodge is referring to
10:28:32 <geekosaur> @google haskell hair shirt
10:28:34 <lambdabot> https://www.microsoft.com/en-us/research/publication/wearing-hair-shirt-retrospective-haskell-2003/
10:29:00 <dmwit> bollu: (That r6.ca blog post was an answer to your question to geekosaur, I think.)
10:29:37 <dmwit> bollu: (I think his third alternative is called `Dialogue2` there.)
10:29:43 <sdrodge> geekosaur: Yeah. I think that's the paper I'm recalling.
10:29:48 <geekosaur> also there is no guarantee that there weren;t other possibilities; there just werent any other proposals at the time
10:30:02 <bollu> wow, the dialogue this is similar to free monads in some sense
10:30:05 <bollu> thing*
10:30:19 <dmwit> Yes, that is not an accident. =)
10:30:36 <bollu> dmwit: :)
10:30:39 <geekosaur> it's a moderately common pattern, and not limited to haskell documentation. see for example the Kerberos Dialogue in 4 Parts
10:30:44 <bollu> dmwit: I assumed the free algebra stuff was discovered later
10:31:19 <sdrodge> For another possible I/O model, see: http://www.idris-lang.org/documentation/effects/
10:31:19 <bollu> geekosaur: what is it about? just saw it
10:31:54 <dmwit> geekosaur: https://web.mit.edu/kerberos/dialogue.html ?
10:31:54 <geekosaur> describing the reasoning behind the ((initial) implementation of the Kerberos authenticatin protocol
10:32:00 <geekosaur> dmwit, yes
10:33:53 <sdrodge> btw, still looking for comments on how to improve this code: https://hastebin.com/jicequciqu.hs
10:34:18 <sdrodge> My solution feels very janky and hacked together, and I would appreciate the eyes of a more experienced haskeller.
10:34:26 <geekosaur> og feh, should have actually read the furst url, I was tryoing to keep up with too much and thought Dialogue refered to the prose part
10:35:01 * geekosaur is also failing to syynchronize with local housekeeping...
10:37:13 <dmwit> sdrodge: http://hackage.haskell.org/package/multiset-0.3.3/docs/Data-IntMultiSet.html
10:37:32 <sdrodge> dmwit: Unfortunately, this is for a hackerrank problem, and that library is not part of their environment.
10:38:51 <dmwit> Also, a very minor suggestion: `queries <- replicateM numQueries readLn`.
10:39:06 <dmwit> You should not need either type ascription.
10:39:41 <sdrodge> true, good point
10:40:42 <dmwit> If raw speed matters, `even` and `odd` can be replaced with `Data.Bits` operations.
10:41:01 <dmwit> (And computed once per call to `updateTrackers` instead of potentially four times.
10:41:04 <dmwit> )
10:41:32 <dmwit> Possibly: `updateTrackers n ts = case (compare n median, odd s) of ...` would be more idiomatic.
10:41:33 <GreySunshine> Hello, does ghc have a risc V port?
10:42:29 <dmwit> However, I haven't understood the algorithm well enough to be able to give deep advice; all of this is admittedly very superficial.
10:42:32 <dmwit> Apologies for that.
10:42:44 <sdrodge> dmwit: No problem. Still interesting suggestions.
10:43:12 <thoughtpolice> GreySunshine: People have worked on it, with the LLVM fork it's possible if you know what you're doing (people have gotten it working in RISC-V/QEMU). It's certainly not "officially supported" in any real sense while all the toolchains, etc are still being merged upstream and ironed out, however.
10:43:50 <sdrodge> dmwit: The high level overview of what is going on is that you're fed a series of integers, if they are positive, you should add them to the current set and recompute the median of the set, if they are negative, you should roll back the state by the corresponding amount (where -1 means repeat the state that we were just at).
10:44:04 <f-a> I am reading ye olde yampa paper. There is a datatype (Identity list) which reads: data IL a = IL { ilNextKey :: Int, ilAssocs :: [(Int, a)] }. Does it have a name? (And most importantly, does it have a package? List doesn't seem the most efficient way to implement it)
10:44:38 <sdrodge> dmwit: So I'm just tracking the state after each query as an IntMedianTracker in a sequence.
10:45:08 <sdrodge> Which gives me O(log n) new state creation and O(log n) access to previous states.
10:45:18 <sdrodge> Which is good enough because you get at most 10^5 queries.
10:46:02 <sdrodge> I'm mostly looking for suggestions about a better way to structure the code, since the structure feels a little disgusting, and possibly ways to improve the asymptotics without using ST or IO.
10:47:05 <sdrodge> Maybe there's some unified data structure that didn't occur to me that does median tracking as well as persistence?
10:49:28 <kadoban> sdrodge: Yay hackerrank haskell people xD Not enough haskellers on there, heh.
10:50:20 <sdrodge> kadoban: xD
10:53:30 <dmwit> f-a: There is `IntMap`.
10:54:20 <kadoban> sdrodge: You can just use Data.Map.Map using either elemAt and size to check the median, or splitRoot in case elemAt isn't in the version they use, can't recall. The constants will be worse, but less code required.
10:54:54 <f-a> dmwit: thanks. are the ints in intmap invariant with the respect to the changes (add/remove) to the map?
10:55:00 <kadoban> IntMap would also work for the same idea, except `size` in O(n) in IntMap
10:55:14 <kadoban> is O(n)*
10:56:12 <sdrodge> Nice. Didn't know about that.
10:57:48 <dmwit> IntMap doesn't support elemAt. =(
10:58:38 <kadoban> Ya, IntMap isn't super useful for this. If you annotate it with the size, so you can check in O(1) time, then you can implement "elemAt" using splitRoot without too much trouble, but at that point I'm not sure it's worth it.
10:59:10 <kadoban> Also splitRoot doesn't really guarantee wtf it does I guess, it's more of an internal function it seems, but ... in practice it'd be fine anyway.
10:59:15 <dmwit> splitRoot won't give you annotated subtrees.
10:59:17 <sdrodge> Still certainly gonna be cleaner than the juggling between two maps that I'm doing.
10:59:28 <kadoban> dmwit: Hmm ... good point.
11:00:05 <dmwit> IntMap doesn't support elemAt for exactly the same reason size is O(n). You could fix both, at the cost of reduced efficiency and increased space usage for all other operations.
11:00:20 <dmwit> This was a conscious engineering decision made by the containers folks and unlikely to be reversed.
11:00:39 <sdrodge> kadoban: Wait, elemAt wouldn't work, would it?
11:00:51 <dmwit> Why not?
11:00:54 <sdrodge> Because it doesn't take into account the MultiSet structure.
11:01:13 <sdrodge> 1 1 1 5 10
11:01:30 <dmwit> Oops, even worse. =)
11:01:40 <kadoban> sdrodge: From Data.Map? Should. Oh did I miss part of it? Oh, to make it a multiset, just make every element unique. zip them with [0 ..] first?
11:03:15 <cris_> hello
11:03:47 <sdrodge> kadoban: That's starting to get just as ugly as the current solution, imo.
11:04:20 <kadoban> Ya, it's not terribly pretty. Anything to avoid having to create actual data structures though :)
11:04:43 <sdrodge> What's wrong with making data structures?
11:06:10 <kadoban> Requires a lot of effort. If I can just reuse one that already exists, and if it wont' get TLE or whatever, I usually do that.
11:06:28 <johnw> TLE?
11:07:04 <kadoban> time-limit-exceeded. They mentioned hackerrank.com earlier, it's a programming competition site.
11:08:18 <dmwit> sdrodge: Honestly, I think your current code is pretty nice.
11:09:23 <sdrodge> dmwit: Okay. Perhaps my feeling of disgust is unwarranted. Thanks for giving it a look!
11:09:29 <dmwit> I would change your guards to `case (n <= median, odd s) of ...` just because then it's very clear we're covering all the cases (to the point that even the compiler can see it -- or warn you), but it's really just fine I think.
11:09:54 <sdrodge> Yeah. I agree with you on that.
11:10:20 <sdrodge> Gonna have to use viewL to make it work, but that should be cleaner than what I did anyway.
11:10:36 <kadoban> dmwit: Nice, never though of doing that transformation of guards.
11:14:47 <dmwit> sdrodge: I'm not sure I see why any of the other code would have to change.
11:15:15 <dmwit> Where does `viewL` come in?
11:15:44 <sdrodge> dmwit: To pattern match on empty vs. non-empty sequences in that same function instead of just using an S.null guard.
11:16:13 <dmwit> Oh. I'm fine with that part of the guard if you are. =)
11:16:24 <dmwit> `| S.null ts = ... | otherwise = case ... of ...`
11:17:12 <dmwit> I think GHC even has something special in its pattern completeness checker for `otherwise`.
11:27:43 <cris_> hi dmwit, you helped me yesterday, u are very action in IRC
11:27:50 <cris_> active
11:28:20 <sdrodge> dmwit: How about this? https://hastebin.com/sidagedire.hs
11:32:06 <sdrodge> To be honest, I would be shocked if the compiler isn't smart enough to convert the guard version into the case version (with the exception of the S.null vs the pattern match).
11:45:39 <filipovsky> Hi everyone! I'm working on a podcast episode about UI APIs. Was hoping you could recommend approaches or people that are worth researching. UI is all about working around side-effects I figured Haskell community is good place to ask.
11:46:16 <filipovsky> A short version of the pitch:
11:46:17 <filipovsky> > DOM API, iOS UIViews, Android Views and Activities are ... well.. awful. I'm looking for ideas around how to write UI code that is composable, testable and flexible.
11:46:20 <lambdabot>  <hint>:1:8: error: parse error on input â,â
11:46:44 <filipovsky> The slightly longer version: https://discuss.codepodcast.com/t/idea-pitch-weird-ui/32
11:47:38 <filipovsky> Grapefruit looks interesting, but I could reach the author https://wiki.haskell.org/Grapefruit
11:47:45 <filipovsky> *could not
11:47:47 <ongy> we have reflex-dom (which I have no experience with) for browser-based things, brick for tui and no idea if anything for native gui
11:48:30 <mbeidler> react-flux is really nice for GHCJS
11:48:44 <f-a> does reflex work (well) with canvas?
11:48:50 <sternmull> there are bindings to wxWidgets and others. But i have no idea about their quality.
11:48:59 <mbeidler> You can use it with React Native and people have also built electron apps with it.
11:49:34 <mbeidler> https://hackage.haskell.org/package/react-flux
11:50:11 <filipovsky> is reflex/react-flux similar to react.js ideologically?
11:50:55 <filipovsky> seems so
11:52:01 <mbeidler> I'd say for react-flux yes. I haven't used reflex much, but I think it's more of a full-fledged FRP system.
11:53:39 <louispan> you might want to check out glazier-react that I'm currently working on
11:53:47 <jle`> filipovsky: it might be fruitful to ask in #reflex-frp, or also on the reddit :)  not everyone relevant might be online on irc at the moment
11:54:20 <louispan> I think it's a simpler version of FRP. It's Elm-inspired - but IMHO better because in haskell we can use typeclasses
11:55:01 <louispan> And widgets are actually composable (you can make bigger widgets out of smaller ones) without changing any code in the smaller widgets.
11:55:40 <filipovsky> <jle`>: got it, thanks 
11:56:06 <louispan> Does anyone know if it's possible to run multiple template haskell splices in one go?
11:56:26 * geekosaur is not sure what that even means
11:56:46 <louispan> makeClassyPrisms ''Action
11:56:47 <louispan> makeClassy ''Callbacks
11:56:48 <louispan> makeClassy ''Model
11:57:04 <louispan> Can I do o
11:57:32 <louispan> $(makeClassy ''Action, makeClassy ''Callbacks, makeClassy ''Model) instead
11:58:07 <louispan> I'm just wondering because generating TH using GHCJS takes a bit of time, and I'm wondering if generating three at once will save time.
11:59:02 <geekosaur> probably not, since ghcjs is using a backend process so the overhead should only apply to the first splice
11:59:56 <louispan> geekosaur: thanks for answering
12:00:33 <geekosaur> basically those kinds of splices *themselves* are expensive, and youre far from the only one to notice (whether using ghc or ghcjs)
12:01:00 <geekosaur> makeClassy is doing a lot of work behind the scenes
12:01:02 <cris_> hi all, i want to install "haste" into cabal sandbox , i first type $cabal sandbox init
12:01:12 <cris_> 1.0 create a folder , say ~/Downloads/sand 1.1 go to https://hackage.haskell.org/package/haste  1.2 download - haste-0.1.1.tar.gz to ~/Download 1.3 extracted to ~/Downloads/sand ;  1.4 go to ~/Downloads/sand/haste-0.1.1    2.0 $ cabal install --only-dependencies
12:02:07 <cris_> but after the last command: cabal install --only-dependencies, the following errors occur: 
12:04:01 <geekosaur> cris_, for starters I would 'cabal get haste', 'cd haste', 'cabal sandbox init'
12:04:25 <geekosaur> (or whatever dir haste ends up in, which will likely be versioned)
12:05:23 <cris_> curl-1.3.8 failed during th ecnofigure step
12:05:45 <cris_> configure step
12:07:29 <cris_> thanks geekosaur
12:07:55 <geekosaur> that probably won;t help with the curl error, but it's a bit simpler/shorter setup
12:08:08 <geekosaur> as for curl, there should be a build log somewhere. also, what platform are you on?
12:08:48 <geekosaur> (often you need to install devel libraries)
12:10:23 <zcourts> Can someone tell me what's wrong with this: GHC error `a1` is a rigid type variable bound by the type signature for >>>
12:10:28 <zcourts> class X c where
12:10:28 <zcourts>   (>>>) :: a -> b -> c
12:10:28 <zcourts> data Y a b = Y a b
12:10:30 <zcourts> instance X (Y a b) where
12:10:32 <zcourts>    (>>>) = Y
12:11:00 <ski> `a' and `b' in the type signature of `(>>>)' is unrelated to `a' and `b' in `X (Y a b)'
12:11:33 <ski> the type of the method `(>>>)', for `X c' is `forall a b. a -> b -> c'
12:12:04 <ski> (considered as "just another variable", its type is `forall a b c. X c => a -> b -> c')
12:12:04 <cris_> hi geek , i am using Debian 8.7.1 with haskell-platform (ghc 7.6.3 ; cabal 1.20)
12:13:12 <ski> this means that an implementation of `(>>>)' *must* be able to take two inputs of *any* types `a' and `b' whatsoever, completely unrelated to the type of `c' (which was `Y a0 b0' in your case, after renaming those `a' and `b' to `a0' and `b0' to avoid confusion)
12:14:03 <ski> this in turn means that since an implementation of `(>>>)' can have no idea what the two types `a' and `b' of its arguments are, there is (by parametricity) *no* way it can inspect those arguments
12:14:18 <cris_> > geeko , i often use nix , but now i plan to create my own package to upload to Hackage, but i could only find cabal guide , so i need to learn cabal from scratch , does anyone know any practical guide for nix user to upload to Hackage?
12:14:20 <lambdabot>  <hint>:1:7: error: parse error on input â,â
12:14:24 <ski> .. so you might as well have passed two arguments of type `()', or not having passed them at all
12:14:41 <ski> zcourts : so, at it stands, those two arguments of `(>>>)' are useless ..
12:15:24 <zcourts> ski: oh I see ;( - what's the approach to defining those two arguments so as to make them not useless
12:15:29 <ski> zcourts : .. now, perhaps if you could elaborate on what you're trying to do, we could suggest something more helpful of a positive kind (as opposed to the negative kind, knowing what doesn't work usefully, and why)
12:15:56 <ski> zcourts : hard to see what you're trying to do, or even why you're defining a new type class in the first place ..
12:16:26 <ski> zcourts : typically, one should only make a new type class in case one has at least two different instances of it in mind
12:16:47 <ski> (and even then one should consider whether one really needs a type class)
12:18:13 <ski> zcourts : perhaps you want functional dependencies, perhaps you want something completely different. please elaborate on what you want to do
12:18:20 <zcourts> I'm not implementing any real world code, I am reading about typeclasses again and writing quick snippets to refresh my memory, it's been a while since I;ve written any Haskell. My intention was just to define a type class that hadd 1 function for which I could create 2 instances that i'd then have do diff things and just print 
12:18:47 <ski> which two instances ?
12:21:12 <zcourts> Hadn't gotten as far as to implement a second one because the first didn't work, but I had something as simple as addition in mind, so data Y and data Z's constr were just going to have 2 ints put in. Complete waste for a typeclass since one would do the same thing but it'd get me two types to start playing with as I worked through the book
12:22:12 <ski> perhaps you could try playing around with `class X c where (>>>) :: Int -> Int -> c' or `class X c where (>>>) :: c -> c -> c' ?
12:24:28 <zcourts> Yeah, I'm totally jumping the gun, I'm sure the book gets to this. I'll start with what you've suggested, get it to work and finish the chapter before doing anything else.
12:26:19 <ski> one could also imagine `class X a b c where (>>>) :: a -> b -> c' (with or without FDs added), but that strikes me as being enough "amorphous" that probably it won't be very useful
12:30:58 <zcourts> perhaps - I'll do a mini project to have solid/concrete types to implement. That should get rid of the superflous/"amorphous" types I'm trying to create
12:48:55 <okeuday_bak> does haskell at any point read from global state that is a constant related to the platform used, to determine how logic should function, but does so as a pure function, or is that impossible?
12:50:03 <geekosaur> okeuday_bak, it's something of a sore point among some. see https://downloads.haskell.org/~ghc/8.0.2/docs/html/libraries/base-4.9.1.0/System-Info.html
12:50:28 <geekosaur> (the argument being that on some level they really shouldn't be pure)
12:51:02 <okeuday_bak> geekosaur: so doesn't that mean it isn't clear whether or not that is a pure function, or is it just a question of how you define purity?
12:51:13 <geekosaur> however most programs use Cabal build configurations conditionalized by platform in the cabal file
12:51:21 <xa0> xni
12:51:29 <xa0> xnull:
12:51:30 <geekosaur> the latter
12:51:31 <xa0> xnil:
12:51:36 <okeuday_bak> geekosaur: k, thanks
12:51:49 <geekosaur> there's folks who define it operationally, and those who want it to obey strict laws
12:51:55 <xa0> Xnuk: 
12:52:10 <okeuday_bak> geekosaur: strict laws being laws that are consistent on all platforms, right?
12:52:23 <xa0> Xnuk: are you xnil
12:52:38 <geekosaur> strict laws meaning it obeys a mathematical notion of purity instead of a practical one
12:52:48 <okeuday_bak> geekosaur: k, makes sense
12:53:18 <geekosaur> (wherein the platform you compiled on is not going to change regardless of how/where you run the result)
12:54:18 <geekosaur> but that is also a warning, those things are resolved at compile time and if you run a program built on x86 on an x86_64, System.Info will tell you about the x86 it was built on and not the x86_64 you ran it on
12:54:51 <okeuday_bak> geekosaur: k
13:10:35 <jessekempf> How does one go about excluding certain modules or functions from an HPC test coverage report when using `stack test âcoverage`?
13:11:19 <jessekempf> I've read https://github.com/commercialhaskell/stack/blob/master/doc/coverage.md and https://wiki.haskell.org/Haskell_program_coverage and it's not clear to me how to fit them together.
13:24:23 <autopawn> :q
13:53:07 <mzabani> hi everyone! Can someone explain me why my Monad Transformer's implementation fails to compile with "The coverage condition fails in class âMonadReaderâ for functional dependency: âm -> râ" when making it an instance of MonadReader such as: instance MonadReader r m => MonadReader r (TunnelT m) where?
13:54:10 <c_wraith> mzabani, because the first type argument doesn't start with a concrete type constructor. 
13:54:45 <c_wraith> mzabani, that error is basically useless with MPTCs and fundeps
13:54:55 <c_wraith> mzabani, just turn on UndecidableInstances 
13:55:13 <mzabani> but do I really have to turn on UndecidableInstances for this?
13:55:31 <mzabani> It feels kinda bad to do that
13:55:36 <c_wraith> why? 
13:55:58 <c_wraith> UndecidableInstances is specifically to allow what you want to do. 
13:56:00 <monochrom> mtl turns it on too. http://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control-Monad-Reader-Class.html
13:56:08 <mzabani> Isn't UndecidableInstances basically saying that I'll guarantee correctness of my instances?
13:56:14 <c_wraith> no. 
13:56:44 <monochrom> Where did you get that idea from?
13:56:44 <mzabani> hmm I didn't know mtl also used it..
13:56:51 <c_wraith> it just says "don't worry about monotonicity, instance resolution will terminate" 
13:56:59 <jle`> undecidable instances has nothing to do with correctness of instances heh
13:57:21 <mzabani> oh, sorry about that, I'm pretty new to all this :P
13:57:35 <jle`> i wonder where the idea comes from
13:57:40 <jle`> maybe the name sounds scary?
13:57:53 <mzabani> haha it does a little bit
13:58:00 <c_wraith> well, it's unclear what the Undecidable part refers to. 
13:58:05 <jle`> it's about as benign as TupleSections
13:58:19 <c_wraith> all it means is that instance resolution isn't guaranteed to terminate. 
13:58:23 <mzabani> oh that is good to know!
13:58:25 <Xnuk> xa0: no i'm not
13:58:29 <jle`> Sections kinda sounds scary if you have trauma with discussion sections in university
13:58:53 <ertes> "undecidable" â  "unsafe" =)
13:59:05 <jle`> TupleSections sounds like a bad lecture section about tuples, who would want to turn that on?
13:59:09 <ertes> "undecidable" = "(something) might not terminate"
13:59:10 <jle`> :)
13:59:29 <c_wraith> if something goes wrong with UndecidableInstances, the worst case is a compiler error. 
13:59:39 <Koterpillar> with Undecidable, what happens if I put in instances A a => A b and A b => A a?
13:59:44 <c_wraith> that's not too bad of a worst case. 
13:59:54 <Koterpillar> or just something loopy
14:00:02 <c_wraith> Koterpillar, they'll be rejected as overlapping. 
14:00:04 <mzabani> I was really under a very wrong impression on this. Thanks for clearing it out!
14:00:10 <monochrom> The compiler has a loop counter for this. "I give up after 5 iterations"
14:00:39 <jle`> psh wait until i submit my patch solving the halting problem
14:00:40 <monochrom> "and here is the flag you need if you want me to try 500 iterations"
14:00:56 <c_wraith> Koterpillar, allowing overlapping instances actually gets a little scary. 
14:01:01 <monochrom> The problem with "meaningful" names.
14:02:05 <Koterpillar> I thought I could give priorities to overlapping instances?
14:14:21 <Gurkenglas_> What's a better way to write fmap concat . sequenceA? (also y no more ircbrowse search)
14:15:01 <jle`> :t fmap concat . sequenceA
14:15:03 <lambdabot> (Traversable t, Applicative f) => t (f [a]) -> f [a]
14:16:40 <monochrom> If you change concat to join...
14:40:27 <centril> is there a lens, :t Lens' (Maybe a) a  ?
14:40:39 <johnw> that's a Prism'
14:41:03 <centril> johnw: thinking of _Just ?
14:41:13 <johnw> yeah
14:41:40 <robertkennedy> :t findZero
14:41:42 <lambdabot> error: Variable not in scope: findZero
14:41:59 <centril> johnw: so... I have a lens:  Lens' TcExpr (Maybe Type), and now I need a lens:  Lens' TcExpr Type
14:42:04 <centril> johnw: is that doable?
14:42:34 <johnw> not as a lens, no
14:42:43 <johnw> what happens if the slot has a Nothing?
14:43:06 <centril> johnw: just skip it, hmm...
14:43:24 <centril> johnw: the best I can get is: :: Applicative f => (Type -> f Type) -> TcExpr -> f TcExpr
14:43:25 <johnw> a Traversal, Fold or Prism can "just skip", but a Lens cannot
14:43:58 <centril> which I guess fits into all lens functions since it's a stronger guaranteed than  Functor f => ...
14:44:20 <centril> oh wait... no
14:44:30 <centril> the lens functions pick the functors, damn 
14:44:36 <ski> the other way around, yes
14:46:41 <centril> johnw, ski so... what does  :t Applicative f => (b -> f b) -> a -> f a  translate in the lens library if anything ?
14:46:46 <wizardwizard> so what work, if any, has been done on programming languages targeting heterogeneous computing platforms
14:46:47 <centril> translate to *
14:46:52 <johnw> Traversal
14:46:58 <wizardwizard> for example, i might have a computer with a single core CPU as a compilation target
14:47:10 <wizardwizard> while another machine might be a quad core CPU with an FPGA attached
14:47:15 <wizardwizard> and a third might be a dual core CPU with GPU
14:47:25 * ski . o O ( `forall f. Applicative f => (b -> f b) -> a -> f a' )
14:47:40 <wizardwizard> and i might want to compile my program for any of the three platforms and get the best performance
14:47:49 <johnw> Traversal' :)
14:47:59 <wizardwizard> i might also need to provide some kind of formal description of my target platform to inform the compiler,...
14:48:36 <centril> wizardwizard: is the platform specified at compile time?
14:48:50 <centril> i infer that it is
14:48:57 <wizardwizard> ideally my code would know nothing about what platform it is being compiled to
14:49:12 <wizardwizard> but i could have separate code which provides as much detail as you want about the platform
14:49:13 <centril> right, but the compiler does ?
14:49:17 <wizardwizard> cache sizes, etc
14:49:23 <peddie> wizardwizard: have you looked at OpenCL?  also, LLVM can generate code for different platforms (e.g. NVIDIA GPUs or intel CPUs) from a subset of its IR
14:49:25 <wizardwizard> the compiler would receive (1) my program and (2) the platform desciption
14:49:26 <centril> then I'd say LLVM
14:49:42 <centril> this is exactly what LLVM does...
14:50:01 <wizardwizard> LLVM opportunistically makes use of the GPU?
14:50:30 <centril> wizardwizard: well... that is a matter of adding optimization passes for that into LLVM, but in principle there should be nothing stopping it
14:50:40 <wizardwizard> i think openCL produces code for single targets
14:50:40 <centril> LLVM already does auto-vectorization, etc.
14:51:34 <centril> the problem with GPUs is that they are very free to change from one iteration to another, and the abstraction-layers are not really meant for general purpose computation, until recently at least
14:51:48 <wizardwizard> right
14:51:59 <wizardwizard> and i can't keep up with heterogeneous architectures
14:52:03 <wizardwizard> it's just not feasible
14:52:18 <wizardwizard> i want to throw my code at a compiler and have it actually figure out what to do
14:52:28 <centril> I guess LLVM could compile to openCL / CUDA, etc... ?
14:57:33 <dedgrant> wizardwizard, centril, reminds me of this PASC project: http://www.pasc-ch.org/projects/projects/heterogeneous-compiler-platform/ (but I have no other info)
14:57:44 <peddie> centril: http://llvm.org/docs/NVPTXUsage.html
14:58:03 <wizardwizard> given that intel is going to start shipping CPUs with integrated FPGAs
14:58:44 <wizardwizard> it would be nice if my code simply automatically made use of whatever compute resource was available
15:04:39 <centril> wizardwizard: yes, wouldn't it be nice if your code just magically ran on the GPU ;)
15:04:46 <wizardwizard> well yeah, that's the point
15:04:53 <centril> unfortunately, someone has to do the work ^^
15:05:07 <wizardwizard> it can't be that hard to pick out vector operations
15:05:38 <centril> well... doing vector opt in CPU is easier because the cost of moving data is less
15:05:55 <wizardwizard> right but in addition to a descrption of the system
15:05:56 <centril> but if you are moving stuff via PCI-E, then the compiler has to consider the cost of moving data to GPU first
15:06:04 <wizardwizard> the compiler could run various benchmarks testing latency, bandwidth, etc
15:06:12 <wizardwizard> and actually reason about the code
15:06:22 <wizardwizard> and even compile it, test perf, tweak, and so on
15:06:28 <centril> wizardwizard: yes, it is possible, but someone has to write that code that does it
15:06:35 <centril> Im guessing it will be done eventually
15:06:39 <wizardwizard> it seems like people think that compilers have to get it right on the first try
15:06:47 <wizardwizard> without any empiricism
15:06:51 <centril> once GPU general purpose languages and assembly stabilize
15:07:40 <centril> you cant write optimizations for a target that is moving too fast
15:08:39 <centril> wizardwizard: another thing on my wishlist: rewrite LLVM in Rust
15:08:47 <wizardwizard> heh why?
15:08:54 <wizardwizard> finding bugs?
15:09:10 <centril> Cause C++ be unsafe
15:09:27 <wizardwizard> because you think LLVM has defects?
15:09:45 <wizardwizard> a minisat rewrite in rust found at least one serious bug
15:09:59 <centril> anything sizeable written in C++ is bound to have defects somewhere
15:10:11 <centril> and I'd very much not like bugs in a compiler...
15:10:28 <centril> I'd say bug free compilers are even more important than bugfree kernels
15:10:50 * mniip . o O ( a compiler in coq )
15:11:12 <centril> mniip: why not Agda? or Idris?
15:11:22 <zv> wizardwizard: even large SAT solvers have huge bugs, SMT solvers doubly so.
15:11:49 <wizardwizard> haha
15:11:54 <wizardwizard> so why use them?
15:12:08 <wizardwizard> i guess,... run on two independent implementations...?
15:12:10 <mniip> they are crazy fust
15:12:12 <mniip> fast*
15:12:17 <zv> sortof
15:12:53 <zv> Crazy fast becomes crazy slow when you want to satisfy literals over a theory of, say, Integers.
15:12:55 <mniip> and by fast I mean in real world cases they provide fairly subexponential complexity on large inputs
15:13:01 <mniip> sure
15:13:38 * centril sprinkles some dependent types on the problem and, poof, all my troubles seem so far away...
15:13:44 <zv> To verify 32-bit integer addition, that's equivalent to literally thousands (maybe millions) of CNFs
15:13:48 <mniip> once we have efficient SAT over bit-encoded integers we'd have defeated modern cryptographic hash functions
15:13:57 <zv> Sorry, to verify a *SINGLE* 32-bit addition
15:14:23 <mniip> zv, don't SAT solvers take expression graphs?
15:14:37 <centril> zv: wth... using SAT for additions ?
15:14:45 <mniip> integer addition in a graph is fairly compact
15:14:51 <mniip> linear size in fact
15:14:51 <zv> mniip: SMT solvers encode higher order logics into a sequence of SAT problems
15:15:06 <zv> So, for example, for the "theory of" u8 addition
15:15:13 <mniip> right
15:15:19 <centril> oh, right
15:15:21 <peddie> wizardwizard: isn't the thing with SAT (well, NP) that you can verify efficiently, just not solve efficiently?  so you don't need two implementations of the solver :)
15:15:21 <mniip> do SAT solves benefit from CNF?
15:15:26 <zv> You might have (assert (= (+ 2 4) 6))
15:16:00 <wizardwizard> you can verify, but what does the verification?
15:16:00 <mniip> otherwise, is there a reason a SAT solver can't benefit from a graph encoding of the input as opposed to a CNF
15:16:05 <zv> That SMTLIB2 code is going to be converted into 700 variables and 1060 clauses
15:16:09 <solrize> mniip, compcert.inria.fr
15:16:14 <monochrom> There is no real loss if an SMT solver is wrong. No real loss compared to the days before there were SMT solvers.
15:16:16 <centril> https://en.wikipedia.org/wiki/Conjunctive_normal_form#Computational_complexity
15:16:30 <wizardwizard> computing is a steaming pile of dung
15:16:43 <wizardwizard> and is impossible to do correctly
15:16:45 <wizardwizard> i think that's the lesson
15:17:06 <monochrom> That is, before, you assumed (wrongly) that your program was perfect.
15:17:09 <centril> wizardwizard: that is a really sad lesson i hope not to draw
15:18:05 <centril> some languages allow computing to be made more correctly
15:18:32 <centril> (Idris/Agda/Haskell/Rust, ...)
15:18:45 <monochrom> With a buggy SMT solver, sometimes it correctly points out a bug, so you gain. Sometimes it incorrectly overlooks a bug, no loss compared to before. Sometimes it incorrectly claims you have a bug, but you will investigate, right? You will find that the bug is not with your program, no loss.
15:18:50 <mniip> centril, yeah but CNF is exponential of the input size
15:19:02 <mniip> so no wonder it's NP-hard timewise
15:20:12 <centril> monochrom: if your compiler claims that correct programs are incorrect then we have a problem...
15:20:54 <zv> mniip: it's possible to immediately eliminate many unprofitable avenues of exploration (in the universe of possible satisfactions of a set of variables), so not nessasarily
15:20:59 <centril> mniip: what about the k-SAT thingy ?
15:21:12 <zv> kSAT is even more complex
15:21:35 <centril> 2-SAT then
15:22:02 <zv> centril: which can be *even* harder to solve than 3sat
15:22:33 <centril> zv: wiki says "known to have solutions in polynomial time..."
15:22:34 <zv> Remember, every binary clause (2sat) is equivalent to two 3sat clauses
15:22:55 <centril> oh, right
15:23:13 <zv> centril: The art of computer programming Volume 4 Fascicle 6 discusses this problem
15:23:27 <zv> but yes, in general you are absolutely correct
15:23:52 <zv> anwyay, I hijack the conversation every time the topic of SAT solving comes up
15:24:18 <zv> It's such a fantastic vehicle of research for everything from automated bug hunting to program verification
15:24:25 <centril> zv: yes, ..., how did we go from Code => GPU to SAT?
15:25:23 <wizardwizard> (the original question btw wasn't code => gpu but code => gpu + cpu + fpga + anything else avail)
15:25:35 <centril> zv: speaking of program verification... I'm currently writing my bachelors thesis (with 5 others) about automated assessment of programming exercises, where the exercises are written in Java (sadly...)
15:25:47 <wizardwizard> maybe even code => networked devices
15:25:53 <wizardwizard> hehe
15:26:12 <centril> wizardwizard: I claim  Code => GPU is a subproblem of your problem
15:26:27 <wizardwizard> yeah :)
15:27:06 <koala_man> centril: neat. what does it handle that testing doesn't?
15:27:07 <centril> reading the JLS is not much fun... at every corner there is another special case
15:27:13 <zv> centril: it's definitely doable at this point
15:27:55 <zv> That is to say, "Making abstract claims about machine code", or perhaps even Java
15:28:12 <centril> koala_man: we use normalization + strategies to verify that 2 programs are the same structurally, instead of running the code
15:28:34 <centril> well... since normalization + strategies is undecidable, we fall back on property based testing
15:29:42 <centril> zv: replicating this in LLVM would be interesting
15:29:51 <dedgrant> wizardwizard: If you rephrase your problem as, "what if we had a solution to the Optimization Problem?" then we could say that SMT solvers have resulted in some powerful tools for exploring the problem.
15:29:57 <centril> then you can prove that 2 programs from 2 diff languages are the same
15:30:05 <zv> centril: have you heard of the tool Klee?
15:30:25 <koala_man> centril: so an exercise would be e.g. "quicksort a list" and not a broader "sort a list"?
15:30:43 <zv> It operates on LLVM IR, can 'symbolically execute' a program without every actually running it
15:30:52 <centril> koala_man: right, but more introductory programming exercises
15:31:02 <centril> zv: ooh, that is cool
15:31:10 <zv> So you could determine if it fulfills certain non-trivial criteria (inb4 rices theorem).
15:31:35 <zv> I've used it to find real-deal exploitable heap and buffer overflows in major language runtimes with a minimum of effort, I highly recommend it
15:32:17 <koala_man> centril: seems very useful if you can add a set of known good solutions and known bad solutions, and the system will classify ~95% of submissions automatically 
15:32:36 <centril> koala_man: yes, that is what we intend to do
15:32:56 <centril> we call them "student-" and "model-solutions"
15:35:40 <centril> koala_man: relevant reading: http://dspace.ou.nl/bitstream/1820/5388/1/INF_20140617_Keuning.pdf
15:35:48 <wizardwizard> bbl
15:41:19 <srk> looking for some feedback if anyone wants to play with lan p2p networking https://git.48.io/zre
15:42:00 <srk> want to push it to hackage soon
16:05:05 <okeuday_bak> isn't it possible to have something like: let x = do { .,... multiple lines .... } in x ? 
16:05:33 <Koterpillar> okeuday_bak: yes, separate "lines" with ;
16:05:42 <centril> okeuday_bak: seems awfully redundant tho
16:05:48 <ski> (s/lines/commands/)
16:06:16 <ski> if you use layout, then you don't need `;'s there
16:06:35 <okeuday_bak> ski: k
16:06:37 <ski> note that the body of the `do' must be indented more than `x' in that case
16:06:38 <glguy> I'm just wondering what that comma is going hiding amongst all those periods
16:06:43 <glguy> seems suspicious
16:06:46 <glguy> is doing*
16:06:56 <ski> illegal alien
16:06:58 <centril> glguy: haha, nice catch
16:06:58 <okeuday_bak> mistype
16:07:00 <geekosaur> just means tey type like i do >.>
16:07:24 <centril> ski: seems that function needs to build a wall.
16:07:33 * ski doesn't understand
16:07:52 <ski> (which function ?)
16:08:05 <centril> that the let binding is in
16:08:20 <centril> alternatively, GHC needs to build a wall
16:08:24 <ski> it need not be
16:08:27 <okeuday_bak> centril: yeah, attempting to return x as Right x, so it is wrapped in an Either
16:08:33 <okeuday_bak> it is somewhat wall-like
16:08:49 <centril> okeuday_bak: like a fence?
16:08:53 * ski . o O ( "warn all" )
16:09:14 <okeuday_bak> centril: I was hoping to avoid having exceptions escape
16:09:28 <centril> okeuday_bak: watcha doing ?
16:09:57 <okeuday_bak> centril: trying to use binary Put without exceptions and have it return a String error or even an Error type in an Either type
16:10:37 <okeuday_bak> centril: however, I get odd errors when attempting to use do syntax normally, since it expects Either in the do syntax usage, as if each line would have Right as a prefix
16:10:47 <centril> Put :: ?
16:11:05 <okeuday_bak> https://hackage.haskell.org/package/binary-0.8.4.1/docs/Data-Binary-Put.html
16:11:55 <glguy> okeuday_bak: If you've got some actual broken code you can share it via lpaste.net
16:12:01 <okeuday_bak> centril: binary Get isn't a problem, because it provides strings coming from fail usage, its just the Put usage which is an issue, since it doesn't provide a function that handles errors, since no errors would happen within the binary source code, just doing extra checking
16:13:20 <okeuday_bak> glguy: https://github.com/okeuday/erlang_hs/blob/master/src/Foreign/Erlang.hs#L454-L647 is the code I want to improve to avoid any exceptions being thrown
16:14:04 <okeuday_bak> currently, outputError is using fail, which causes an exception to be thrown
16:15:15 <centril> okeuday_bak: so if you want to capture errors you need to encode that in the type... So  Either Err Put... ?
16:15:28 <okeuday_bak> it doesn't seem clear to me whether this requires a monad transform to attach a String or Error type unto the Put monad, haven't really learned about transforms yet
16:15:47 <okeuday_bak> centril: yes, that is what I was attempting to do
16:16:44 <centril> okeuday_bak: OK, so the shape of your computation is similar to:   WriterT (Except Err) ()
16:17:37 <okeuday_bak> centril: I wasn't sure how the Writer monad really works, the PutM type takes something, but Put sets it as (), so just not sure how PutM a uses a
16:17:37 <centril> oh wait...
16:18:07 <okeuday_bak> centril: I had expected that to be a detail related to being a Writer monad that is just merging pairs of things
16:18:10 <centril> okeuday_bak: the result is in the "writer" part of the monoid
16:19:34 <centril> okeuday_bak: unfortunately, the PutM type has no corresponding transformer
16:20:03 <okeuday_bak> centril: yeah, I was expecting to have to use mtl to wrap an error, if Either couldn't be used here
16:20:10 <centril> so you have to build the  MonadError interface + the functions already made for PutM  over it
16:21:08 <okeuday_bak> and MonadError is https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Error-Class.html right?
16:21:33 <centril> okeuday_bak: Just say:   newtype EPutM e a = EPutM { _runEPutM :: Either e (PutM a) }
16:21:45 <centril> okeuday_bak: that's correct
16:22:25 <okeuday_bak> centril: Ok, thanks, I probably should read more before doing more though
16:22:26 <centril> then you need to build a bunch of functions that work with EPutM now instead
16:22:58 <okeuday_bak> centril: so I basically will need all my own put functions for all the different bits I may write, right?
16:23:50 <centril> okeuday_bak: it is pretty straight forward... you can make a higher order function that does :: (a -> Put) -> (a -> EPutM ())
16:24:03 <okeuday_bak> centril: k, cool
16:24:17 <okeuday_bak> centril: thanks for the insight
16:25:40 <centril> call it:  liftPut :: (a -> Put) -> (a -> EPutM ()) ; liftPut f = EPutM . pure . f ;
16:26:33 <centril> okeuday_bak: then just take every function  of the form  :: a -> Put , for some a... for example: putWord8
16:27:37 <okeuday_bak> centril: ok, thanks
16:27:42 <centril> yw =)
16:37:46 <lpaste_> mzabani pasted âCan't write a monad transformer that is an instance of MonadReaderâ at http://lpaste.net/353281
16:38:55 <Koterpillar> mzabani: if you have a ReaderT unconditionally, you don't need to have a constraint
16:39:20 <glguy> You'll have an  instance MonadReader Int (TunnelT m)   
16:39:33 <Koterpillar> mzabani: if you _do_ have a constraint, that means you are requiring two Readers in your stack
16:39:48 <mzabani> the title is a little wrong, guys, sorry: it is more like creating MonadReader instances automatically when the underlying monad is MonadReader
16:40:12 <glguy> or probably closer to: instance Monad m => MonadReader Int (TunnelT m)
16:40:15 <mzabani> the ReaderT in the implementation is just because TunnelT is just a special kind of ReaderT
16:40:45 <glguy> It's generally better not to write this instance, however
16:40:47 <Koterpillar> mzabani: OK, you still don't need that constraint
16:41:15 <glguy> You can have some definition:   getWhateverTheIntMeans :: TunnelT m Int
16:41:34 <glguy> if it's appropriate to expose that Int, or if it's not you can write the actual operation in terms of that
16:41:54 <mzabani> what I really want is not to expose the Int
16:42:01 <glguy> OK, then don't write the isntance
16:42:38 <mzabani> but how do I make sure that users of TunnelT keep their underlying MonadReaders accessible?
16:43:11 <glguy> Oh, that's a different question. you just need to 'lift' the ask operation or ask
16:43:18 <Koterpillar> write an instance of MonadTrans?
16:45:18 <mzabani> hmm haven't tried using lift yet..
16:45:54 <mzabani> I was scratching my head over and over with MonadReader's functions... but couldn't typecheck
16:46:43 <mzabani> so I have to make TunnelT an instance of MonadTrans first.. right?
16:48:55 <Koterpillar> yes, then you'll get 'lift ask' and such
16:49:02 <glguy> ask = TunnelT (lift ask); local f (TunnelT m) = TunnelT (mapReaderT (local f) m)
16:49:15 <glguy> You *can* write the MonadTrans instance
16:49:18 <glguy> and use that
16:49:23 <glguy> (probably a good idea)
16:51:34 <glguy> mapReaderT :: (m a -> n b) -> ReaderT r m a -> ReaderT r n b
16:52:28 <mzabani> that's a lot of help.. thank you once again
16:53:07 <mzabani> I'll go scratch my head on implementing lift now..
17:14:45 <mzabani> guys, sorry to bother you again with this... but how can I implement lift without knowing anything about the underlying Monad?
17:14:53 <ezyang> mzabani: No. 
17:15:08 <ezyang> Well, depends on what you mean 
17:17:14 <mzabani> while trying to make my monad transformer an instance of MonadTrans, how can I separate "m" from "a" in "m a" to build "t m a" in lift?
17:18:17 <glguy> lift :: m a -> ReaderT m a
17:18:43 <Rotaerk> why do you want to separate the m from the a?
17:18:43 <glguy> lift :: m a -> ReaderT r m a
17:18:49 <glguy> TunnelT :: ReaderT r m a -> TunnelT m a
17:21:52 <monochrom> You don't have an unknown "t". It is your own transformer. You know how to implement lift for it.
17:22:11 <monochrom> But look at how StateT and ReaderT do it for examples.
17:22:25 <mzabani> oh gosh.. glguy just showed me what I had to see
17:23:17 <mzabani> thank you once again, I still have a hard time remembering the functions that are there for me to use most of the time.. it's been kind of a steep learning curve here
17:24:18 <Rotaerk> the haskell mountain is steep everywhere
17:25:17 <mzabani> indeed it is
17:26:47 <Koterpillar> then it can't be finite
17:30:25 <Rotaerk> well, I guess I shouldn't call it a mountain; it's more like a rabbit hole
17:30:45 <Rotaerk> though when I said steep everywhere, I really meant from every angle, rather than at ever elevation
17:30:50 <Rotaerk> every *
17:30:55 <monochrom> There is a Schwarzchild radius.
17:47:27 <c_wraith> Haskell feels infinite. but that's because ghc keeps advancing. so much to keep learning. 
17:49:03 <c_wraith> I just learned that TypeInType allows higher-rank kinds. except they're not called kinds anymore. unless.. Do we still call them kinds? 
17:49:11 <c_wraith> type-types? 
17:50:22 <centril> c_wraith: kinds were always type of types
17:50:49 <centril> just as you can have types of types of types
17:51:03 <lyxia> kinds become sorts
17:51:20 <centril> (Universe sets in Agda)
17:51:41 <centril> c_wraith: interesting: https://en.wikipedia.org/wiki/Girard%27s_paradox
17:51:51 <c_wraith> my question was more.. if they no longer behave differently, do we still call them something else? 
17:53:23 <centril> c_wraith: well... TypeInType makes * :: * , which is an analog to Russel's Paradox... so you can prove bottom thus
17:53:59 <Tuplanolla> It's not `KindInType`, is it now?
17:54:40 <centril> Tuplanolla: call it what you want... but:  * :: *  is inconsistent as a logic
17:54:50 <centril> but haskell was already inconsistent as a logic, so that is fine
17:59:54 <lyxia> c_wraith: It can still be useful and improve clarity to have a richer vocabulary when talking about a type and its own type.
18:00:08 <centril> lyxia: +1
18:03:19 <c_wraith> centril, haskell was already an inconsistent logic, so it's not like it's worse. 
18:03:41 <centril> c_wraith: I already stated that ;)
18:14:20 <centril> hmm.. when using one signature for multiple functions like:   a, b, c :: MyType  ... can you specify haddok docs on the definitions of the functions ?
18:14:43 <lyxia> nope
18:14:49 <centril> damn
18:14:53 <centril> that sucks
18:17:49 <lyxia> If you try you'll just duplicate the text
18:45:06 <nshepperd> c_wraith: yeah I'm not really sure. I definitely still think about the 'kind of a type'. But not so sure if I should be distinguishing between 'Bool the type' and 'Bool the kind'
18:46:02 <nshepperd> is Bool inhabited by three values and two types? *head explodes*
18:47:59 <nshepperd> (or is that three types, if UndecidableInstances lets â¥ be a type as well?)
18:56:33 <Rotaerk> hmm I don't actually know what I'm talking about, but it seems like it would be ... cleaner... to say that the Bool type only has two values, but the type of every expression is actually the union of the type you specify and the set containing â¥
18:56:48 <Guest75574> anyone have any recommendations for config libraries?
18:59:23 <lyxia> Rotaerk: what about Maybe Bool :)
18:59:48 <Rotaerk> hmm true, I guess Just â¥ is a possibility...
19:00:09 <lyxia> le_frogballs: what do you mean by config library
19:01:17 <le_frogballs> to read .conf files preferably...for static parameters
19:02:51 <lyxia> le_frogballs: I'm not sure about ways to read files, but once you've got a concrete configuration there are a couple of ways of threading it throughout your program discussed here https://www.reddit.com/r/haskell/comments/5xqozf/implicit_parameters_vs_reflection/?utm_name=haskell
19:03:09 <lyxia> Basically Reader/reflection/ImplicitParams
19:37:51 <_sras_> Is there a library that can pretty print records without any additonal boilerplate?
19:43:08 <lyxia> _sras_: is Show not pretty enough
19:48:10 <_sras_> lyxia: It is hard to read the output of show in case of nested records
19:50:02 <Koterpillar> pretty-show?
19:51:34 <_sras_> Koterpillar: for pretty-show, one has to convert the records to a format that this library understands, right?
19:52:05 <Koterpillar> hmm, there's no Generic?
19:52:22 <Koterpillar> ppShowÂ ::Â ShowÂ a => a ->Â String
19:52:29 <Koterpillar> that seems good enough to me
19:53:09 <Koterpillar> hmm, reading further
19:53:44 <Koterpillar> I would have thought they require GHC.Generic, but they don't. YMMV.
19:57:21 <_sras_> Koterpillar: It's output is same as that of Show.
19:57:44 <Koterpillar> even for tuples and other instances of their PrettyVal?
20:46:50 <piyush-kurur> tommd: ping
20:52:06 <Wizek> Anyone knows what the following error means? Is my idea (as written in the issue) accurate? https://github.com/reflex-frp/reflex-platform/issues/103
20:52:26 <buttons840> any suggestions for HTML/CSS templating in haskell?
20:52:53 <buttons840> i've been looking at lucid, but don't know how to do CSS with it
21:52:54 <dmj`> buttons840: 
21:53:07 <dmj`> lucid is moreso for html
21:53:28 <dmj`> @package clay
21:53:28 <lambdabot> http://hackage.haskell.org/package/clay
21:55:17 <dmj`> ^ buttons840
22:08:10 <tommd> piyush-kurur: pong
22:08:19 <buttons840> dmj`: would you use clay with lucid then?
22:08:40 <buttons840> in other words? use both?
22:10:44 <liste> buttons840: yes
22:10:58 <liste> lucid for html, clay for css
22:12:14 <piyush-kurur> tommd: it was just regarding the issue for file specific cc-flags
22:12:34 <piyush-kurur> I just forked cabal repository and am putting up a small proposal
22:12:49 <dmj`> buttons840: you wonât be able to write css in javascript generated by haskell
22:13:25 <dmj`> buttons840: unless you made ffi bindings to create and manipulate styles with the dom
22:13:45 <buttons840> i am just making static pages
22:14:03 <dmj`> buttons840: you can write the css clay generates to disk to a static dir that the web server servers
22:15:56 <buttons840> dmj`: i don't want to write to disk, I need what would traditionally be called "templates" for a CRUD app
22:16:22 <dmj`> buttons840: you can render the Clay type to a Bytestring and embed that into the lucid template
22:16:43 <dmj`> I donât recommend inline styles
22:17:37 <buttons840> dmj`: oh, i got confused and thought you mean write the HTML to disk -- yeah, I agree I should write the CSS to disk
22:18:12 <buttons840> i'll probably just inline a hand written CSS file to begin with, i'm already taking on a lot of new ideas here
22:19:57 <osa1> what breaks if I define Eq and Ord instances so that `compre x y /= EQ` but `x == y` ?
22:21:00 <osa1> for some reason I always assumed Eq and Ord should be in agreement about when two values are equal but looking at the docs that doesn't seem to be the case
22:23:38 <piyush-kurur> tommd: I have just added a comment to the issue https://github.com/haskell/cabal/issues/4294
22:23:49 <piyush-kurur> just let me know how it looks
22:24:24 <Axman6> osa1: nothing happens, but code will break. I think that is probably a law for Ord, but there's nothing which (can) enforce it
22:24:35 <kadoban> osa1: Sounds quite confusing for any users of those instances, at least.
22:24:37 <buttons840> :i Ord
22:25:00 <osa1> no that's not a law, that's what I'm saying
22:25:49 <ezyang> piyush-kurur: I'm not a big fan of cc-options-for: filename flag flag 
22:25:53 <ezyang> it's weirdly asymmetric 
22:26:45 <ezyang> Other thing to watch out for: if you add a Cabal feature for this, you are committing your packages to requiring a sufficiently new version of Cabal to build correctly 
22:27:29 <ezyang> If you've got a support window, like many packages do, you'll need a BC story too 
22:29:03 <piyush-kurur> ezyang: what are the other options
22:29:17 <ezyang> piyush-kurur: I did say that I couldn't think of a good syntax ;) 
22:29:50 <ezyang> otoh, filename flag flag might not be so terrible 
22:30:06 <piyush-kurur> ezyang: you mean in the c-sources ?
22:30:26 <ezyang> cc-options-for 
22:31:33 <piyush-kurur> ezyang: sorry I am confused, you first said you do not like c-options-for
22:31:39 <ezyang> Yes I did 
22:31:56 <ezyang> but I also agree that there aren't very many good choices for syntax 
22:32:07 <tommd> I'll think on it some.
22:32:22 <ezyang> Setting that aside for now, what about the BC problem? 
22:32:56 <piyush-kurur> ezyang: that is simple for older cabals we do not give the user the best options ;-)
22:33:24 <ezyang> ok. That's a design constraint, because it means any option you add, needs to be ignored by old cabal 
22:33:25 <piyush-kurur> just whatever is currently supported 
22:33:53 <ezyang> I don't actually remember what happens when Cabal sees a field it doesn't undersatnd 
22:33:59 <piyush-kurur> ezyang: okey now I see what you meant
22:34:06 <piyush-kurur> sorry I was being dense
22:34:09 <tommd> piyush-kurur: How would this help the avx2 issue where you want portability on non-avx systems as well?
22:34:10 <ezyang> np 
22:34:33 <ezyang> tommd: Seems like this won't really help 
22:34:41 <ezyang> because Cabal doesn't know about avx 
22:34:52 <tommd> piyush-kurur: I suppose something like `cc-options-for: x.c -mavx -DWITH_AVX` newline `x.c // notice no avx`.
22:35:20 <piyush-kurur> tommd: yes something like that
22:35:21 <tommd> piyush-kurur: But cabal would need to know to produce and link to seperate object files from one (duplicately mentioned) C file.
22:35:38 <tommd> And that's some careful CPP to boot.
22:36:05 <tommd> Anyways, It's late by my standards so I'm signing off.  Thanks for putting this together piyush-kurur, I'll mull it over.
22:36:27 <piyush-kurur> tommd: if I link a file that contains some avx code  and do not call that function on a non-avx machine it should be fine I guess
22:36:38 <piyush-kurur> tommd: bye
22:38:06 <piyush-kurur> I will choose to call the function that contains the avx2 code from the haskell level. There is no harm in it residing in the .so file and not being called I guess (some what like a fat binary)
22:42:26 <piyush-kurur> ezyang: is it necessary that we need all the options in cabal file. It might make sense to have a helper file for tweaking cc-options
22:43:24 <ezyang> Helper file would be major architectural change 
22:43:32 <ezyang> Would be better to do a Custom setup in that case :/ 
22:46:05 <piyush-kurur> ezyang: that is what I meant, we provide hooks that users can include in their setup.lhs which does a c flags matching 
22:46:36 <Squarism> i have a parameterized type that takes 2 type arguments. Thing is its really a pair of type arguments. They cannot be varied separatly. So i wonder if theres some trick to make "MyType a b" into "MyType c"
22:46:56 <Athas> Squarism: type families.
22:47:00 <Athas> But it's a heavy hammer.
22:47:04 <Cale> You might be able to define a type family which determines one from the other
22:47:06 <Cale> yeah
22:47:29 <ezyang> piyush-kurur: Yes, that's doable 
22:47:37 <Cale> Or depending on the situation, a class with a functional dependency might also be useful
22:47:39 <Squarism> heavy hammer? I havent learned that expression 
22:48:00 <Cale> I wouldn't consider it all that heavy, unless you're concerned about using compilers which aren't GHC
22:49:41 <piyush-kurur> ezyang: just confirm one thing. It should be possible for me to have say a function bar in foo.c which is compiled with say -mavx2 and added in the .so file. 
22:50:03 <piyush-kurur> on platforms that do not have avx2 we will just not call it (decision done at the Haskell level)
22:51:05 <Squarism> From google search i found https://wiki.haskell.org/GHC/Type_families. All code examples squeezed inbetween explaination into unreadable. Could have been better! =D
22:51:34 <ezyang> Not easily 
22:51:45 <ezyang> We do know what arch you're building with 
22:51:53 <ezyang> but we don't have any feature tests for things like avx support 
22:52:11 <ezyang> that sort of thing is usually done with a Configure script 
22:52:30 <ezyang> The way this works is you run the Configure script, this generates a buildinfo which is then "added" to the Cabal package description, for flags and stuff 
22:52:40 <ezyang> Actually, now that I think of it, I'm not convinced that this wouldn't solve your problem! 
22:53:44 <piyush-kurur> ezyang: I would want the code to be compiled in any case because often the machine where the code is run will be different from the machine where it s executed
22:54:25 <ezyang> "If only gcc had {-# GCC_OPTIONS ... #-}" 
22:54:31 <ezyang> ;) 
22:54:39 <piyush-kurur> ezyang: that is not enough
22:55:16 <piyush-kurur> often you have the following situation. Debian package builder builds on say a machine without avx2
22:55:32 <piyush-kurur> but it is to be run on a machine with avx2
22:55:43 <piyush-kurur> one needs something like a fat binary
22:55:54 <ezyang> piyush-kurur: Put this in the ticket! 
22:56:35 <piyush-kurur> ezyang: it is there in the ticket that is referred to but yes I will add this point
22:58:37 <ongy> piyush-kurur: I don't know the exact details, but I do know that we do that somewhere in a C library. But I think there's some trick with compiler intrinsics 
22:58:50 <ongy> you can get an array of supported extensions form the CPU in *some* way
22:59:10 <piyush-kurur> ongy: cpuid ?
22:59:29 <ongy> possible, I have only read a bit of backlog, so if you got a reason not to use it, I probably missed it
23:00:22 <piyush-kurur> ongy: we were discussing the following ticket for cabal https://github.com/haskell/cabal/issues/4294
23:02:08 <ski> Squarism : there is an iso between `T * T' and `2 -> T' which could be used .. in your case, one could have `MyType :: (Tag -> *) -> *' -- but possibly it's too heavy-weight / inflexible for your use case
23:03:30 <ongy> ah, that explains the problem
23:05:04 <Squarism> ski, Thanks but thats greek to me. 
23:07:13 <piyush-kurur> ezyang: I have added a comment on the build machine being different from the target machine
23:07:41 <piyush-kurur> ongy: If you have better ideas please pitch in.
23:08:13 <ezyang> thanks 
23:09:22 <winny> https://en.wikipedia.org/wiki/Wilmington_insurrection_of_1898
23:09:28 <winny> oops wrong channel
23:09:41 <ongy> not really. http://stackoverflow.com/questions/12925989/gcc-enable-compiler-flags-only-on-specific-functions could work for some cases
23:10:53 <piyush-kurur> ongy: that looks like it should solve many of my use cases thanks
23:11:12 <ongy> but I think this should be done by the build system. Or have cabal invoke make for the more complex cases? Adding foreing build capabilities to cabal will only go so far
23:11:12 <piyush-kurur> ezyang: just have a look at the url that ongy pointed out
23:11:50 <ezyang> oh that's nice 
23:11:58 <ezyang> can you use that instead? 
23:12:23 <piyush-kurur> ezyang: I think a lot of problems will be handled by it I guess.
23:12:39 <piyush-kurur> I will add the link to the ticket
23:14:43 <piyush-kurur> ongy: your github id (for reference in the ticket)
23:14:54 * ongy is ongy on github :)
23:15:48 <ongy> ezyang: does cabal use the CC env var? or does it decide on the compiler in some other way?
23:15:50 <ski> Squarism : one way of making a "pair" of types `A' and `B' is to define `data Tag = IsA | IsB' and then the "pair type" is `data AB :: Tag -> * where FromA :: A -> AB IsA; From B :: B -> AB IsB'. to pass this "pair" of `A' and `B' to `MyType', use `MyType AB'. to access the two components of `ab' in `MyType ab', use `ab IsA' and `ab IsB'
23:16:33 <ezyang> --with-gcc and --gcc-options, I think 
23:19:44 <Squarism> ski, that was a concrete explaination. Thanks!
23:21:42 <ski> Squarism : as i said, this is pretty heavy-weight (in that you have to define a new type `AB' (and `Tag' needs to be defined)) / inflexible (hard to vary `A' and `B') .. but this encoding can sometimes be useful (e.g. when making several mutually recursive types (usually ASTs), where you want to untangle the recursion for `Fix'-trick purposes)
23:22:58 <Squarism> ski, so would you recommend that approach over type famillies?
23:26:26 <ski> i'm not quite sure how the type family thing is supposed to go here
23:26:54 <CIKIDING> hallo
23:27:03 <amy_> bored :(
23:27:14 <liste> hello CIKIDING
23:29:17 <amy_> hi @luigi
23:29:17 <amy_> pls talk to me?
23:29:17 <andrevdm> Hi all. Am I correctly understanding that a record defined with newtype means that all the records fields are all automatically strict? That seems to be what the docs say
23:29:17 <luigi> @okay
23:29:17 <lambdabot> Unknown command, try @list
23:29:17 <Guest21874> talk to me too
23:29:17 <jle`> andrevdm: should be, yes
23:29:17 <jle`> depending on what you are thinking about when you mean strict
23:29:17 <liste> @let newtype Foo = Foo { bar :: String, baz :: String } -- andrevdm 
23:29:17 <lambdabot>  Parse failed: newtype declaration constructor must have exactly one parameter.
23:29:21 <luigi>  haiiii  @amy
23:29:34 <jle`> newtype Identity a = Identity a
23:29:45 <jle`> newtype Identity a = Identity { runIdentity :: a }
23:29:52 <jle`> the two should have the same strictness semantics
23:29:57 <andrevdm> so more or less data A = A {a :: !Int}   ==  newtype A = A {a::Int}
23:29:59 <jle`> all the record gives you is an accessor and constructor
23:30:15 <jle`> well, the record-ness is a bit of a distraction here
23:30:17 <andrevdm> (ignoring the fact that newtype is removed at compile time)
23:30:22 <amy_> how do i do a private chat?
23:30:28 <jle`> data A = A { a :: !Int } has the same strictness as data A = A !a
23:30:32 <jle`> er, A !Int
23:30:40 <jle`> so the records don't have anything to do with it
23:30:48 <liste> amy_: type /msg <nick>
23:31:06 <jle`> are you asking if `data A = A !Int` is the same as `newtype A = A Int` ?
23:31:38 <luigi> kikuk2x test
23:31:58 <ski> andrevdm : well, with `data', `case _|_ of A _ -> ()' doesn't terminate; but with `newtype', it would
23:32:04 <andrevdm> hmm, we specifically I asking about records :) because I've got a bunch of records defined with data (all fields strict) and I'm thinking I should make them newtypes
23:32:21 <andrevdm> and I want to understand if that is chaning my strictness 
23:32:21 <amy_> help
23:32:41 <andrevdm> *chaning
23:32:41 <ski> amy_ : do you have a Haskell-related query ?
23:32:57 <liste> andrevdm: so you have records with multiple fields?
23:33:09 <andrevdm> @liste correct, yes multiple
23:33:09 <lambdabot> No module "correct, yes multiple" loaded
23:33:14 <luigi> @liste kikuk2x
23:33:14 <lambdabot> No module "kikuk2x" loaded
23:33:33 <liste> andrevdm: newtypes can only have one field
23:33:45 <CIKIDING> @luigi pak tito yg punya punya polisi banyak
23:33:45 <lambdabot> Unknown command, try @list
23:33:47 <andrevdm> but that one field can be a record?
23:33:50 -ChanServ(ChanServ@services.)- glguy quieted *!*@*/ip.202.164.220.226
23:33:51 --- mode: ChanServ set +q *!*@*/ip.202.164.220.226
23:34:13 <andrevdm> ah, no
23:34:26 <jle`> the single field of a newtype can be a record
23:34:28 <andrevdm> ok, I see where it all went wrong
23:34:37 <jle`> most of the newtypes in 'base' actually are records :o
23:34:51 <andrevdm> thanks, yes. Ok, that then makes a lot more sense
23:35:07 <jle`> but for the most parts records are just synactic conveniences
23:35:10 <andrevdm> I was misreading the hlint suggestion, I thought it was on a multi-record field
23:35:11 <jle`> they don't affect any strictness properties
23:35:12 <nshepperd> sometimes people talk of making a newtype wrapping a tuple, but that is redundant. if you have multiple things you want to wrap, you're better of with some kind of 'data'
23:35:40 <andrevdm> excellent, thanks.
23:35:49 <ski> nshepperd, usually
23:37:13 <ongy> I found some old code from when I was new-ish to haskell... one of the oddities I found in there was exactly that
23:37:59 <andrevdm> ski: I missed the comment about bottom. Thanks, I see that in the wiki, I'll read that again (a few times) to make sure I understand
23:57:33 <lolisa> Hi
23:58:32 <liste> hi
23:58:45 <lolisa> So I am reading the algebra of programming.
