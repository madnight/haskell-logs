00:07:12 <av> good morning everyone, here's my question of the day:
00:07:59 <av> I've defined my own data type, operations on which create and use file(s) on the hard drive
00:08:45 <av> now when an instance of that data type gets garbage collected, I can make sure that all memory related to it is freed, but how do I make sure the temporary files are also deleted?
00:08:55 <av> what's the best/cleanest way of doing this?
00:10:45 <KamaKama> Hi guys, just joined this channel. Learning Haskell. Hope to learn a lot from you guys.
00:12:17 <halogena1dtoast> Anyone use Yi, I've installed it, but I don't even know where to begin, I just have a window that says *console*
00:16:10 <cocreature> av: you might be able to hack something together using StablePtr and ForeignPtr but usually tying external resources (such as temporary files) to the lifetime of some haskell data is not a good idea since you want to guarantee that external resources are freed at some point
00:16:59 <halogena1dtoast> Answered my question, the default is similar to emacs.
00:18:38 <halogena1dtoast> KamaKama: Good luck!
00:19:19 <halogena1dtoast> av: I agree with cocreature, for the most part, you should probably ignore the fact the GC even exists.
00:19:47 <halogena1dtoast> s/, for the most part/. For the most part/
00:21:56 <ongy> av: something like 'withTempFile :: (TempFile -> IO a) -> IO a' is usually better, since you can be sure that things are freed somewhat soon (but it's also more restricted)
00:22:52 <av> cocreature: thanks for pointing out StablePtr, though I'm not sure how it's of any use in this case, but it might be useful in the future
00:23:05 <av> halogena1dtoast: thanks
00:23:47 <ongy> also, I doubt that all finalizers are run when the application ends, so you'd leave around some temporary files after execution aswell
00:24:04 <cocreature> av: foreignptr is the useful part, but you need something to point the foreignptr to and that could be a stableptr
00:24:05 <av> ongy: that's my other option, it makes the code a little more restricted, as you say, but that's probably just how it has to be, I'll probably go that route
00:24:44 <av> cocreature: yes, but I was alreay aware of ForeignPtr, but never heard of StablePtr :)
00:33:37 <ahri> i'm getting an error that confuses me: it says it's expecting Seq but getting ViewL on this line: "convertRow S.EmptyL _ = S.empty" -- have i misunderstood how the views work?
00:34:02 <jle`> ahri: can you put more context...?
00:34:49 <cocreature> you can’t just use ViewL in place of Seq, you need to call viewl first
00:34:55 <jle`> my guess is that convertRow's first argument should be a Seq but you're giving it S.EmptyL, which is a constructor for the ViewL type
00:35:07 <cocreature> you can use view pattern and to something like "convertRow (viewl -> S.EmptyL)"
00:35:50 <jle`> @let import qualified Data.Sequence as Seq
00:35:52 <lambdabot>  Defined.
00:35:55 <jle`> :t Seq.EmptyL
00:35:58 <lambdabot> Seq.ViewL a
00:36:13 <ahri> https://github.com/ahri/bombastic-hs/blob/master/src/Bombastic.hs#L160
00:36:38 <jle`> yes, you can use the 'viewl' function, like cocreature mentioned
00:36:44 <jle`> as a view pattern or using explicit pattern matching
00:36:57 <jle`> convertRow s coords = case viewl s of
00:37:06 <jle`>   S.EmptyL -> S.empty
00:37:18 <jle`>   c :< cs -> ...
00:37:36 <jle`> s/explicit pattern matching/explicit case statement
00:37:48 <ahri> https://gist.github.com/ahri/82bb0290487ac579efc2e8cb3395bb4e is the error, in case i was not clear. i'll try to tweak it as you say :) thanks!
00:38:08 <jle`> does view patterns optimize the case where the same view is used twice?
00:38:18 <cocreature> jle`: heh, I’ve just been wondering the same
00:38:19 <jle`> it'd be nice, but i am not sure if i trust the compiler to do that
00:38:33 <jle`> if it's an explicitly documented feature then that'd be nice
00:38:40 <jle`> i think i've read about it somewhere but i can't recall :|
00:39:56 <dmwit> "Efficiency: When the same view function is applied in multiple branches of a function definition or a case expression (e.g., in size above), GHC makes an attempt to collect these applications into a single nested case expression, so that the view function is only applied once."
00:40:00 <dmwit> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#view-patterns
00:40:06 <cocreature> nice!
00:40:21 <jle`> sweet
00:40:37 <cocreature> “makes an attempt” sounds like these might fail. under what conditions is GHC unable to do this?
00:40:48 <ahri> so... obviously i don't know what i'm doing, but i thought https://github.com/ahri/bombastic-hs/blob/master/src/Bombastic.hs#L1 meant that i could directly substitute for (x:xs) :\
00:40:52 <dmwit> cocreature: Read the rest of the paragraph. =)
00:41:12 <jle`> ahri: what about line 1 are you thinking about?
00:41:16 <ahri> i'm not familiar with language extensions at all though
00:41:22 <cocreature> dmwit: ah sry :)
00:41:43 <jle`> ahri: do you mean Pattern Synonyms?
00:41:55 <jle`> or View Patterns
00:42:01 <jle`> or {-# LANGUAGE ... #-} pragmas in general
00:42:13 <dmwit> ahri: You can read about the ViewPatterns extension at the link I posed above.
00:42:17 <dmwit> *posted
00:42:28 <jle`> or did you just highlight line 1 by accident
00:42:48 <ahri> erm, i hoped that the combination of those two extensions would allow a direct substitution based on something i read on stackoverflow. i'm clearly mistaken!
00:43:03 <cocreature> PatternSynonyms would work
00:43:13 <cocreature> but that would require EmptyL to be declared as a patern synonym
00:43:15 <jle`> pattern synonyms would let you if :</EmptyL were defined as pattern synonyms
00:43:19 <cocreature> it doesn’t magically substitute things
00:43:22 <jle`> which they werne't, unfortunately
00:43:39 <dmwit> To be fair, some extensions do magically substitute things.
00:43:39 <jle`> ahri: pattenr synonyms doesn't let you subistute types for other types
00:43:59 <jle`> but it lets you define custom abstract "constructor-like things" for types
00:44:16 <jle`> in another universe, Empty might have been defined as a pattern synonym for Seq
00:44:27 <jle`> and so you could directly match on Empty :: Seq a
00:44:33 <ahri> is https://github.com/ahri/bombastic-hs/blob/master/src/Bombastic.hs#L34-L36 what's required then? i pasted it in but didn't really understand what it's for, and the compiler complained so i got rid of it again
00:44:36 <jle`> but the key is that the type of Empty would be Seq
00:45:05 <jle`> oh, yeah, that should do it.
00:45:30 <jle`> it's not clear because of the missing type signatures, but Empty :: Seq a, and (:<) :: a -> Seq a -> Seq a
00:45:48 <jle`> so that's why you can use it to pattern match on a Seq
00:46:18 <jle`> but :< and EmptyL/EmptyR from Data.Sequence aren't defined as pattern synonyms; they are constructors for altogether different types, ViewL and ViewR
00:46:26 <halogena1dtoast> *sigh* I want to use language-c-inline but it looks like that project is kind of dead.
00:46:46 <jle`> ahri: i wouldn't use pattern synonyms in this case though
00:46:51 <liste> @inline-c -- halogena1dtoast ?
00:46:51 <lambdabot> Unknown command, try @list
00:46:57 <liste> @hackage inline-c -- halogena1dtoast 
00:46:58 <lambdabot> http://hackage.haskell.org/package/inline-c -- halogena1dtoast
00:47:02 <liste> is that good?
00:47:03 <jle`> just using viewl and pattern matching on S.EmptyL and S.:< should be nice enough
00:47:22 <halogena1dtoast> oh no I've been ghosted...
00:47:23 <ahri> jle`: oh, ok, yes, i think it's clear that i'm trying to run before i can walk here...
00:47:27 <jle`> the reason why i shy away from pattern synonyms for this situation is that we don't have support for coverage annotations yet in GHC
00:47:36 <jle`> and i -Wall
00:47:40 <halogena1dtoast> inline-c doesn't support objc I think.
00:48:05 <jle`> there's no way to let GHC know that matching on Empty and x :< xs is exhaustive, and GHC will complain about an inexhaustive pattern match
00:48:06 <jle`> :'(
00:48:34 <halogena1dtoast> I guess I should have said I wanted to inline objc and not c.
00:48:56 <Jello_Raptor> :/ the only type of bugs I've had in the past month that weren't caught by the type system were either me typing "f a b" when I meant "f b a" or "x" instead of "not x". 
00:48:58 <jle`> pattern synonyms are a minor convenience here but they don't clean up anything too much imo
00:49:02 <halogena1dtoast> I want access to stuff in AppKit on OSX.
00:49:24 <ahri> jle`: oh that sucks as i'm heavily leaning on -Wall to force myself to question things a bit more
00:49:32 <jle`> you should -Wall
00:50:22 <jle`> it's because of this that i consider unidirectional pattern synonyms an incomplete feature
00:51:04 <jle`> but yeah, if you're just learning, using a pattern synonym barely adds anything here heh
00:51:17 <jle`> using a view pattern like cocreature mentioned should already be plenty clean
00:51:30 <jle`> convertRow (viewl->S.empty) _ = S.empty
00:51:36 <halogena1dtoast> Another dead project seems to be HOC...
00:51:43 <jle`> convertRow (viewl -> c :< cs) coords = ...
00:52:10 <jle`> or just using explicit case statements and function application like i mentioned earlier requires no extensions and is also fairly readable
00:52:18 <jle`> s/fairly/just as
00:52:43 <Cale> halogena1dtoast: this looks relevant https://github.com/mchakravarty/language-c-inline/blob/master/tests/objc/app/AppDelegate.hs
00:52:46 <jle`> the undesirable aspect of explicit application of viewl/a case statement is that it requires you to make up a name for the seq parameter
00:52:59 <jle`> whereas the view patterns and pattern synonym approaches don't
00:53:19 <halogena1dtoast> Cale: it does, but I can't seem to add language-c-inline in a way that makes stack happy
00:53:33 <halogena1dtoast> `language-c-quote-0.11.7.1 must match >=0.8 && <0.9 (latest applicable is 0.8.0)`
00:54:21 <_sras_> How can I make ghci to stop printing errors as soon as it prints the first one?
00:54:30 <jle`> i have some habit ingrained in me to avoid unnecessarily naming parameters, mostly because i'm very bad at picking names for parameters
00:54:52 <jle`> too many x', x'', x''', inconsistent choices for x/y/z and parameter names between similar functions v.v
00:54:55 <halogena1dtoast> jle`: that seems to be a common problem in the world of mathematics.
00:55:14 <ahri> jle`: good point about the naming :\
00:55:30 <jle`> i have a bad habit of going out of my way to avoid ahving to name parameters to an extreme degree though
00:55:38 <jle`> so don't learn from my example :)
00:55:43 <jle`> i'm just discussing the tradeoffs
00:56:10 <ahri> i find it somewhat attractive to not use language extensions yet, though - as i'm early in my learning
00:56:33 <halogenandtoast> ahri: You'll break that habit really quickly.
00:56:37 <ahri> so i think i can live with having to name a variable
00:56:39 <jle`> it can help to sort of feature-freeze what you want to learn
00:56:43 <Cale> halogenandtoast: If you need it to work with a newer language-c-quote, you may have to edit its .cabal file and relax the version constraint (and then fix any resulting issues)
00:56:52 <jle`> learning normal haskell + extended haskell all at once can be daunting
00:57:06 <ahri> halogenandtoast: that's fine, i don't mind using them when i feel the pain :)
00:57:07 <jle`> s/can be/is undeniably
00:57:09 <Cale> Otherwise, the older one is still available from hackage
00:57:20 <halogenandtoast> jle`: True, but I've found that anytime I want to write something useful, I want language extensions.
00:57:33 <halogenandtoast> Cale: Do you mean editing language-c-inlines cabal file?
00:57:38 <Cale> yeah
00:57:54 <jle`> yes, not saying language extensions aren't useful and a part of everyday haskell
00:58:06 <jle`> but just as a pedagogical process
00:58:14 <halogenandtoast> jle`: Even in my simple command line tool I used NamedFieldPuns and DeriveGeneric
00:58:47 <jle`> if you're learning anything, you usually start with learning a simplified subset and gradually expanding it
00:58:50 <halogenandtoast> I'm hoping one day NamedFieldPuns will just be baked in.
00:59:12 <ahri> halogenandtoast: i imagine you're approximately a million times better at Haskell than i am though ;)
00:59:29 <jle`> language extensions aren't bad, but it's reasonable to start with a subset of useful haskell and start gradually expanding it when you're comfortable
00:59:33 <jle`> just as a learning process
00:59:57 <jle`> nobody intends to stick with training wheels forever
01:00:08 <halogenandtoast> ahri: That's questionable, but I'm just saying not to fight against them
01:00:15 <Cale> halogenandtoast: It encourages people to shadow names, so it's sort of in a grey area for me. It's better than RecordWildCards at least, in that you get to see what you're binding
01:00:26 <halogenandtoast> Sometimes you'll write code and the compiler will say, "You can't do this without X extension"
01:00:32 <halogenandtoast> and so I just use the extension
01:00:53 <halogenandtoast> Rather than try to work around it.
01:01:20 <halogenandtoast> Cale: that's fair.
01:02:28 <jle`> some extensions you can turn on because they're how you expected things to have worked in the first place
01:02:32 <jle`> like TupleSections
01:02:46 <Cale> I usually will just bind the record to a single variable and then apply the field extractors to that.
01:02:47 <jle`> FlexibleContexts, FlexibleInstances
01:02:51 <ahri> halogenandtoast: ah yes, if i hit those scenarios i'm willing to naturally ease into using the ones the compiler says i should
01:03:32 <jle`> like, those are extensions you just have to turn on you know that's how things are supposed to work, but haskell-the-language-spec is kinda bizarrely narrow
01:03:40 <jle`> > (,4) 10
01:03:42 <halogenandtoast> ahri: that's perfect then.
01:03:44 <lambdabot>  (10,4)
01:04:22 <Cale> good buddy
01:04:24 <jle`> i wouldn't say that TupleSections/FlexibleContexts/FlexibleInstances/etc. add language features as much as they let haskell match your expectations
01:04:28 <halogenandtoast> > flip (,) 10 4
01:04:30 <lambdabot>  (4,10)
01:04:45 <halogenandtoast> I just wanted to try out lambdabot, that has no significance
01:05:47 <jle`> InstanceSigs too maybe
01:05:49 <pacak> halogenandtoast: you can /query lambdabot  and try other stuff in  direct message
01:06:10 <halogenandtoast> pacak: Thanks, that sounds less fun though.
01:07:54 <jle`> those are the only ones i can think of at the moment
01:09:37 <halogenandtoast> I feel like I see `ExistentialQuantification` a lot as well
01:09:49 <halogenandtoast> Although I don't quite understand it and have never used it myself.
01:10:43 <jle`> my list is just of extensions that fix unexpected surprises in the literal haskell spec, that make things work as you would have expected haskell to work
01:11:29 <halogenandtoast> I don't know why but I would have expected `forall` to be one of those things.
01:11:59 <jle`> ExistentialQuantification has its use cases, but it's more often the wrong solution heh
01:12:37 <halogenandtoast> I take that as useful insight in case I ever reach for it.
01:12:40 <jle`> ScopedTypeVariables would probably count as making haskell work the way you would have expected it to work
01:13:32 <jle`> like if you have a type variable 'a' in a top-level type signature, you probably would expect that all "a"s in the type signatures of bindings inside would refer to the same 'a'
01:13:48 <jle`> instead of always shadowing it
01:29:36 <sphinxo> quit
01:30:05 <sphinxo> How do people feel about use of the maybe fn?
01:30:57 <halogenandtoast> sphinxo: it has its use cases
01:31:12 <Rembane> sphinxo: How come you ask?
01:31:21 <halogenandtoast> sphinxo: https://github.com/halogenandtoast/nhk-reader-haskell/blob/0ccc208436de326720355553d67495684d3a81ef/Model/Story.hs#L19
01:31:26 <Rembane> sphinxo: maybe is a oneliner, the case expression isn't. :)
01:32:08 <sphinxo> ahh nice
01:33:41 <halogenandtoast> I also like `either` for its use cases
01:33:42 <halogenandtoast> https://github.com/halogenandtoast/nhk-reader-haskell/blob/f7a70f3acf51c2b66e8f9d206dc4a430bcef5847/Util/Redis.hs#L11
01:33:49 <halogenandtoast> https://github.com/halogenandtoast/nhk-reader-haskell/blob/6e28be090db17f9308ae74e82c74aa9b7e5c5fef/Util/Nhk.hs#L80
01:34:02 <Cale> They're nice in cases where you feel that you'll never have to return to that code
01:34:31 <Cale> When I start editing code, often the first thing that happens if there's a maybe or either is that it gets replaced by a case expression.
01:35:15 <Rembane> When you don't care about Nothing fmap is quite nice too.
01:41:30 <ezyang> lol I'm so awful, I made use of Functor (,) e 
01:41:48 <Cale> Is that awful?
01:42:12 <ezyang> I think so! :) 
01:42:13 <Cale> I've used its Traversable instance quite profitably
01:42:53 <Cale> performRequestsAsync :: (Traversable f, MonadWidget t m) => Event t (f XhrRequest) -> m (Event t (f XhrResponse))
01:43:10 <Cale> Picking f = (,) SomeTag
01:43:29 <Cale> will have the responses be tagged with the same value as the request when they come back in the future
01:43:30 <ezyang> i feel like it usually means you should have made a data type 
01:43:53 <Cale> Which means that we don't need some special function for that case
01:44:18 <Cale> I dunno, I've just gotten used to thinking of pairs as containers with a label (the first part) and an element (the second part)
01:46:08 <Cale> Then again, sometimes you really do want a custom datatype with an instance of Functor for some reason anyway. I think if you start writing your own instances of other things, that's probably the right way to go.
01:46:29 <Cale> (rather than using some sketchy FlexibleInstances)
01:46:48 <Cale> I mean, instances with the first component fixed at something monomorphic
01:48:02 <Rembane> Keep it simple?
01:48:11 <Cale> Weird, Chrome's element inspector seems much much slower today than yesterday.
01:50:27 <cardboard64> anyone familiar with scotty here?
01:50:42 <Cale> How familiar do you need?
01:50:51 <Cale> (better yet, just ask a question)
01:50:55 <ph88_> how can i upgrade a global installed package with stack ?
01:51:17 <Cale> ph88_: I don't think stack does that?
01:51:39 <Cale> Could be wrong, I haven't really found any opportunity to use stack
01:52:25 <ph88_> when you install a package outside of a stack directory it's installed in the global project
01:52:26 <kadoban> ph88_: In what context are you using the package? You just change what you are depending on, usually in the stack.yaml file you'd specify it as an extra-dep, or change the extra-dep or whatever.
01:53:04 <kadoban> ph88_: That's more of an accident of implementation than anything, AFAIK. 'stack install' is supposed to be for installing the executables that a package contains.
01:53:04 <ph88_> maybe i need to update the resolver to update the packages ?
01:53:09 <Cale> ph88_: Does it have a command to remove the package?
01:53:47 <ph88_> Cale, there is no remove/uninstall command
01:54:09 <cardboard64> I'm trying to use sqlite-simple with scotty, but I have a type error I can't solve: https://zerobin.net/?353c9b8d4408c816#6m0bSkHLKB057Ll6KTKaILYWNrLChEqVGjZkaD21UV8=
01:54:12 <Cale> ph88_: right, when I tried that, it told me that it doesn't manage installations in global locations
01:55:25 <Cale> cardboard64: I don't need to be familiar with Scotty to tell you that you need liftIO
01:55:34 <Cale> liftIO $ createAuthor ...
01:56:15 <Cale> liftIO turns an IO action into an action in some other monad (which will necessarily be built in terms of IO somehow)
01:56:19 <Cale> :t liftIO
01:56:21 <lambdabot> MonadIO m => IO a -> m a
01:56:42 <Cale> In this case, you want an action of the monad  ActionT Text IO
01:57:14 <halogenandtoast> by "which will necessarily be built in terms of IO somehow" do you mean "which will necessarily be built in terms of MonadIO somehow"
01:57:35 <Cale> Well, any good instance of MonadIO will involve IO itself internally in some fashion
01:57:42 <halogenandtoast> I'm asking to clarify my understanding, not saying you're wrong.
01:58:30 <kadoban> ph88_: In what context are you trying to use the package in question?
01:58:30 <Cale> This is just because IO is an opaque data type -- there's no way to pick apart IO actions and interpret them yourself somehow.
01:58:51 <cardboard64> I've already tring using liftIO, but then I get another error: https://zerobin.net/?cad9419194158634#KUIunNvAU2zX9Q8n9QDrBAa6siIVBgcwHZY5rVwZPZI=
01:58:56 <Cale> (there could be in principle, but there isn't)
01:59:03 <ph88_> kadoban, oh sorry i was mistaken the package was not added to lts, i need to download it first https://github.com/jameysharp/corrode#alternate-instructions-stack
01:59:12 <halogenandtoast> Cale: I'd assume it would be up to the compiler
01:59:24 <Cale> cardboard64: It doesn't know what types name, pass, pic, and desc are supposed to have
01:59:39 <Cale> cardboard64: and so it doesn't know which parser to use for param
01:59:44 <cardboard64> they are supposed to be Text
01:59:56 <Cale> cardboard64: Using those variables in a way which makes it clear they're Text should fix that
02:00:19 <Cale> For instance, just adding an explicit type signature to createAuthor ought to fix it
02:00:21 <halogenandtoast> cardboard64: Cale is on point.
02:01:17 <Cale> Something like  createAuthor :: Text -> Text -> Text -> Text -> IO ()
02:02:28 <Cale> I would typically feel slightly embarrassed typing that because of all the indistinguishable Text parameters, and would probably want to define a new record data type as soon as convenient, so that it could be something like  createAuthor :: Author -> IO ()
02:03:52 <ph88_> kadoban, i follow the instructions, do you know why this happens ?  https://bpaste.net/show/54417bbab64c
02:05:11 <ph88_> corrode uses lts-6.6 which has the right version of language-c  https://www.stackage.org/lts-6.6/package/language-c-0.5.0
02:05:22 <ph88_> i don't know where the requirement of ==0.6.* comes from
02:05:23 <halogenandtoast> Cale: Would that be a higher-kinded type?
02:05:30 <halogenandtoast> Again checking my terminology here.
02:05:38 <Cale> no, just a plain record with 4 Text fields
02:05:49 <kadoban> ph88_: It looks like the maintainer of that package updated the requirements in the .cabal file and never fixed the stack.yaml.
02:05:54 <Cale> Nothing fancy at all, kind would be *
02:06:08 <halogenandtoast> Cale: True, fair enough.
02:06:18 <kadoban> ph88_: The reslover that's set in the stack.yaml file gives language-c = 0.5.0  The .cabal file requires language-c >= 0.6
02:06:30 <cardboard64> it works now, thanks!
02:06:32 <ph88_> ah yes i see it now, i will open an issue
02:06:34 <kadoban> ph88_: Or it was broken in the first place, I didn't check the history. But that's my guess.
02:06:39 <Cale> cardboard64: great!
02:10:35 <Cale> A really solid rule of thumb is that any time it's hard to tell what a parameter to a function ought to mean based on its type alone, it's strongly worth considering defining a new data type for the parameters to your function - obviously a bit of taste is required, but you could do worse than to apply that rule blindly.
02:12:03 <halogenandtoast> Cale: That's a good rule of thumb.
02:20:10 <stpl> hi, I was trying create my own type class, where on of the instance throws an error and forces to enable FlexibleInstances. I'm trying to achive the funcationality without using FlexibleInstances. Can someonw help. this is my code http://lpaste.net/353522
02:22:03 <ezyang> FlexibleInstances is pretty harmless 
02:22:14 <merijn> stpl: That example isn't going to work as-is, since the instance on line 22 overlaps with everything
02:22:18 <ezyang> oh but that's not going to help you 
02:23:45 <infinity0> typeclassopaedia says "Someone in the #haskell IRC channel used (***), and when I asked Lambdabot to tell me its type, it printed out scary gobbledygook that didn’t even fit on one line! Then someone used fmap fmap fmap and my brain exploded."
02:23:48 <infinity0> what's this in reference to
02:23:55 <infinity0> Prelude Control.Arrow> :t (***)
02:23:55 <infinity0> (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
02:23:58 <infinity0> that seems ok to me
02:24:22 <merijn> infinity0: Well, then clearly you've transcended and become a Haskell adept :)
02:24:53 <infinity0> well it fits on one line :) was wondering if there was some older thing with less clean constraints or something
02:25:02 <merijn> Naah
02:25:15 <merijn> It's mostly "oh god, the large number of type variables!"
02:25:34 <merijn> infinity0: Also, some people find it counter-intuitive/hard to see that 'a' can be '->'
02:25:59 <infinity0> ah ok
02:27:29 <infinity0> fmap fmap fmap is easier to understand rewritten as \f -> fmap (fmap f) and similar for the (.).(.) boob tricks
02:28:22 <merijn> infinity0: Honestly, like many things in Haskell those two things aren't fundamentally difficult
02:29:08 <infinity0> yeah, for me it just takes actively playing with the expressions and refactoring into stuff that "looks" more familiar but turns out was actually the same
02:29:17 <merijn> infinity0: It is, however, not uncommon for people to gloss over how the types work and getting a feeling for how to unify them in your head, to sort of see how things fit together. And obviously, if you skip that or some other fundamental steps things look very confusing
02:29:56 <merijn> infinity0: Right, if you make a habit of doing that, you will find out that, except for the latest bleeding-edge extensions most things are pretty predictable and simple
02:30:48 <merijn> infinity0: Lemme also take the time to recommend reading the actual Haskell Report. It's an incredibly readable language spec and once you get past the "beginner syntax" levels of haskell you can learn a lot from it
02:31:00 <infinity0> oh cool, thanks
02:31:06 <merijn> @where report
02:31:06 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
02:31:34 <merijn> infinity0: Especially if you've ever seen the insanity that is ISO C, you'll be surprised how readable a spec can be :p
02:33:01 <infinity0> yes i'm familiar enough with c/c++ to know that i don't want to be more familiar with them, and likewise unfortunately for some other languages :(
02:34:07 <merijn> Haskell Report and R6RS are up there as "shining beacons of what language specs should aspire to be" :p
02:41:26 <eugenez> Hello, friends! I often end up having to go over the list and apply some function on n and n+1 elements of the list consecutively, is there any simpler way to do that? I usually do map (\(x,y) -> ...) $ zip <*> tail xs
02:42:45 <Rembane> eugenez: zipWith, but the tail remains.
02:42:48 <kgadek> eugenez: zipWith
02:43:38 <eugenez> Thank you!
02:43:52 <merijn> See the usual neat fibonacci example ;)
02:44:07 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
02:44:10 <lambdabot>  error:
02:44:10 <lambdabot>      Ambiguous occurrence ‘zipWith’
02:44:10 <lambdabot>      It could refer to either ‘Data.List.zipWith’,
02:44:16 <merijn> wut
02:44:17 <kgadek> eugenez: btw, I think that's one of the things that hlint will happily suggest
02:44:25 <merijn> @undefine
02:44:25 <lambdabot> Undefined.
02:44:28 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
02:44:30 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
02:52:08 <eugenez> btw, is there some trick or version of scanl/fold for example where instead of acc you have n-1th element ?
02:57:31 <Cale> eugenez: zip xs (tail xs)?
02:58:05 <ph88_> in ghci how do find out the type of the exception ?
03:02:02 <Cale> ph88: Let me know if you find a really good way. You kind of just have to know it.
03:02:19 <Cale> Which exception is it?
03:03:19 <Cale> ph88: A lot of the basic things you'll run into will be of type IOException
03:03:45 <Cale> At least, the ones you're likely to want to catch
03:06:05 <farao> hi, I'm looking for a function that takes a Map and paritions it in n pieces, does anyone know if there is a library function that helps? I have only found "partition" but it takes a filter function instead of a number of partitions and produces only 2 partittions
03:08:32 <ongy> farao: then by what metric would you want the map to be devided? Same size chunks?
03:08:36 <ph88_> Cale, ok i will let you know if i find a way
03:09:20 <farao> ongy: equal size (more or less). I don't even really care which entries go into which partitions
03:09:38 <ph88_> in php i code put code like this https://bpaste.net/show/34e42f91ee45 i read here http://stackoverflow.com/a/6009807 that in haskell i can also check the type of the exception with tryJust, is it possible to get similar syntax as php where it tries a few types of exceptions and then goes to the default case ?
03:09:44 <ahri> i've got a problem with my cabal file, and the error stack gives me is confusing me: "containers-0.5.7.1 must match >=0.5.8 && <1 (latest applicable is 0.5.10.1)" -- i understand that i have 0.5.7.1 installed, but if it found a "latest applicable" version that fits my predicate, why doesn't it upgrade to that version?
03:11:06 <ahri> i assume i'm misunderstanding the error
03:11:47 <ph88_> ahri, which stack resolver are you using ?
03:12:42 <Cale> ph88: You can nest a bunch of uses of handle or catch
03:12:58 <ph88_> how can i nest them without the code getting ugly ?
03:13:08 <ph88_> i think php has nice syntax here
03:13:09 <zomg> ph88_: it would probably be easy to do if you can group your error into a data type, Err1 | Err2 | Err3, then you could pattern match on the errors you care about
03:13:22 <Cale> `catch` \(e :: Foo) -> ...
03:13:26 <Cale> `catch` \(e :: Bar) -> ...
03:13:29 <Cale> etc.
03:13:34 <ph88_> ok i will try it
03:14:11 <Cale> If you look for `catch` on https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Exception.html you'll find some like that
03:14:24 <Cale> oh, yeah, there's also catches
03:14:42 <Cale> which might be better (for reasons given on that page)
03:15:05 <ahri> ph88_: i'm not sure; how can i find out? (i'm a bit new to haskell)
03:15:16 <ph88_> ahri, look in stack.yaml file
03:15:16 <Cale> also note that if you have standard ways to handle the errors, you can make a definition of a new function that does that
03:15:31 <ph88_> Cale, i think you are refering to this piece https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Exception.html#v:catches
03:15:35 <Cale> yeah
03:15:43 <Athas> Is it usual to see parallel Haskell programs have very high CPU utilisation, even when there is no parallelism in the program?
03:15:46 <ahri> ph88_: ah! lts-7.5
03:16:10 <ph88_> ahri, look here https://www.stackage.org/lts-7.5/package/containers-0.5.7.1
03:16:10 <ahri> sorry, i went over the cabal file and couldn't find it. silly me :\
03:16:20 <Cale> Athas: Well, what makes it a parallel Haskell program if there's no parallelism?
03:16:23 <ph88_> ahri, you have to upgrade your lts version to get new version of containers
03:16:40 <Athas> Cale: running it with +RTS -N.
03:16:57 <Cale> and building with -threaded?
03:17:09 <Athas> Rather, there is *some* parallelism, early in the program, but the program keeps having very high multi-core utilisation even later on.
03:17:10 <Athas> Yes.
03:17:20 <Cale> Well, the garbage collections will be parallel at least
03:17:31 <Athas> Yeah, I guess that could be it.
03:17:39 <ahri> ph88_: oh no, looks like it's only available on hackage, not stackage. i guess i'll have to do my own bounds checking + "index", rather than using "lookup"
03:17:40 <Athas> I thought it didn't really pay off, though.
03:17:44 <ph88_> ahri, eh actually that's not true, because i check the latest lts for you  https://www.stackage.org/lts-8.5/package/containers-0.5.7.1 and here it's still on the same containers version, so you must manually override the version of the lts by specifying extra-deps in your stack.yaml file
03:17:55 <Cale> Athas: Well, GHC's garbage collector is parallel
03:18:07 <ph88_> ahri, you can get newest version from hackage with stack if you specify it in extra-deps
03:18:07 <Cale> (but it's also stop-the-world)
03:18:23 <ahri> ph88_: oh, cool. i'll give that a whirl!
03:18:51 <ph88_> ahri, can you do everyone a favor and open an issue here https://github.com/haskell/containers and ask if they can upgrade the containers package on stackage ?
03:18:52 <Cale> I wouldn't expect that to produce "very high" CPU usage for most programs
03:19:11 <Cale> Usually the amount of time spent in the GC is a pretty small fraction
03:19:44 <Cale> There's also the potential for foreign calls to execute at the same time as Haskell code is evaluating that way
03:19:51 <ahri> ph88_: absolutely. also, wow, that was way easier than i thought it might be :D
03:20:11 <Athas> There are no foreign calls in this program.  I guess it does generate a large amount of garbage, though, so that seems the likely explanation.
03:20:26 <Athas> But this mostly-sequential program is pegging three-to-four cores for most of its run.
03:20:31 <Athas> It must be spinning a lot.
03:20:46 <Cale> Athas: There's a tool called threadscope you might want to try
03:20:55 <merijn> Athas: Actually, high amount of garbage wouldn't take many GC cores
03:21:01 <Cale> https://wiki.haskell.org/ThreadScope
03:21:04 <merijn> Athas: It's lots of non-garbage that would use lots of cores
03:21:13 <merijn> Cale: I've never been able to reliably build that :\
03:21:28 <Athas> Well, it's not a big problem for me, yet.  I was just curious about whether I'm messing something up badly.
03:21:33 <ph88_> Cale, is there a default type for Exceptions? in PHP there is a type Exception from which ALL exceptions must inherit
03:21:36 <Athas> I'm not very experienced at parallel Haskell, really.
03:21:49 <merijn> ph88_: SomeException is a wrapper for all exceptions
03:21:56 <Cale> I've managed to successfully build it a couple times... but it's just enough trouble that it's not something I usually have handy
03:22:07 <ph88_> ok thank you merijn 
03:22:08 <Cale> ph88: SomeException
03:22:15 <Cale> ah, yeah, already answered :)
03:22:24 <merijn> Cale: Too slow ;)
03:22:37 <Cale> ph88: You might want to take a close look at the Exception type class
03:22:48 <ahri> ph88_: issue logged. thanks a bunch for your help :)
03:22:53 <ph88_> np
03:22:53 <Cale> It's actually pretty interesting how it works
03:23:27 <Athas> I can't decide whether the Haskell exception system is elegant or a hack.
03:23:29 <Cale> Basically, the important bit is  fromException :: (Exception e) => SomeException -> Maybe e
03:24:00 <Cale> It's elegant, but Haskell programmers are usually picky enough that they don't find a lot of uses for throwing exceptions.
03:24:05 <merijn> Athas: It's nice, the only problem is lack of checked exceptions
03:24:06 <ph88_> well for a novice it's a bit confusing with all the ways to handle errors http://blog.ezyang.com/2011/08/8-ways-to-report-errors-in-haskell-revisited/
03:24:17 <Cale> Well, we sort of do have checked exceptions
03:24:19 <ph88_> i was gonna try openFile and then catch exceptions
03:24:32 <merijn> Cale: Not in the "transparently propagated up" kind
03:25:10 <Cale> Well, there are various monads you can employ for that... depending on your definition of "transparently"
03:25:23 <merijn> Cale: I can't pass an expression of type Int that might throw division by zero to a function expecting Int and infer that this function might throw "division by zero"
03:25:32 <Cale> Well, okay
03:25:47 <Cale> and division by zero is of a sort of exception that you wouldn't ever want to catch in Haskell
03:26:01 <merijn> Cale: I've been sketching (with large breaks) a language where you could do that, but I'm not sure how well it could ever be retrofitted into haskell
03:26:04 <Cale> Exceptions thrown by expression evaluation aren't worth trying to catch
03:26:14 <merijn> Cale: Not in Haskell's current design, no
03:26:30 <merijn> Cale: Which IMO is a flaw in Haskell's design, not in throwing expressions
03:26:32 <ph88_> Cale, in that example of catches what do they mean with handleIO ex ? is that just a placeholder for a function that the user is suppose to write ?
03:26:44 <Cale> merijn: Well, there should almost be another word for them
03:27:08 <Cale> merijn: Those exceptions are sort of a different kind of thing altogether from exceptions thrown by execution of IO actions
03:27:21 <merijn> Cale: Are they, though?
03:27:25 <merijn> Cale: Why?
03:27:31 <ph88_> merijn, if you want to infer that the function might throw division by zero doesn't that go into the realm of dependent types ?
03:28:44 <ongy> exceptions from pure code with laziness are a bit different
03:28:50 <Cale> merijn: Well, personally, I think of exceptions thrown from evaluation as being like a fast way to run forever.
03:29:01 <Cale> We could have written fix id
03:29:31 <Cale> But instead we're doing something that gives you some indication the program is fundamentally broken.
03:30:20 <Cale> Catching such exceptions will violate the usual referentially transparent semantics of expression evaluation.
03:30:43 <ph88_> i put  import Control.Exception (catches, Handler)  and ghci still gives Data constructor not in scope Handler  Perhaps you want to add ‘Handler’ to the import list in the import of ‘Control.Exception’   i don't understand, i already put it in the import list
03:30:45 <Cale> and doing it reliably at all requires making some low-level assumptions about how evaluation and execution get interleaved
03:31:01 <Cale> (Control.Exception.evaluate helps a bit, but only if the thing wasn't already evaluated!)
03:31:07 <merijn> Cale: In waht way does it violate referential transparency?
03:31:32 <merijn> Cale: No, it just means you need to propagate the exception to everywhere the lazy value gets propagated
03:31:45 <Cale> merijn: Well, which exception gets thrown from an expression will depend on the evaluation order.
03:31:59 <merijn> Cale: i.e. "f :: Int -> Bool" needs to infer that if I pass in a throwing Int, 'f' returns a throwing Bool
03:32:39 <merijn> Cale: How is that different from the current bottom semantics?
03:32:40 <Cale> and the evaluation order may depend on the external context
03:33:10 <Cale> The one where we identify all the exceptions and infinite loops with _|_?
03:33:10 <merijn> Cale: If I pass in undefined the result also depends on evaluation order (if you distinguish bottoms) or just 'bottom' if you don't
03:33:33 <merijn> Cale: Right, but why is that semantics impossible with checked exceptions?
03:33:57 <Cale> You don't distinguish them, if you want a denotational semantics rather than just an operational one
03:34:28 <Cale> Because which exception you hit first lets you determine things about how your value was consumed
03:34:50 <merijn> Cale: How is this different from the current imprecise exception semantics we have?
03:36:56 <Cale> How is what different from it? I'm describing what happens when you let expression evaluation just throw exceptions from anywhere: if you want the semantics to capture information about which exception you'll obtain, it becomes operational
03:37:12 <Cale> (or I suppose you could have a nondeterministic semantics)
03:37:46 <merijn> Cale: How is what you're describing "I can tell what was evaluated first" different from the current semantics of imprecise exceptions?
03:37:52 <Cale> We usually don't want to tolerate thinking operationally about Haskell evaluation unless we *really* have to
03:38:17 <Cale> I'm not describing anything that doesn't already exist.
03:38:59 <merijn> Cale: Right, so if it exists, then what's the issue with making the compiler check it at compile time?
03:39:08 <Cale> To understand which exceptions you'll catch when they're thrown by evaluation of an expression, you need to understand the expression in an operational way.
03:39:33 <merijn> Cale: Why?
03:39:34 <Cale> Well, I wasn't really talking about an issue with checking
03:39:56 <Cale> I was talking about an issue with actually making use of catching exceptions from otherwise-pure expressions.
03:40:07 <merijn> Cale: Then I don't understand what you're arguing. You don't disagree with checking, you agree that we can already do this
03:40:57 <merijn> Cale: That's all fine and well in theoretical fairy land. But I'm sick and tired of having libraries throw exceptions in my face that I don't know can happen
03:41:04 <Cale> Well, the thing I was originally trying to argue for was that exceptions thrown by expression evaluation are a different sort of thing from exceptions thrown from IO execution
03:41:12 <merijn> Because no one bothers to document edge cases
03:41:58 <Cale> I would be *reasonably* content if there were no way at all to catch such exceptions, apart from the fact that it might bite me when using some poorly designed proprietary library
03:42:09 <merijn> Cale: I disagree, since from the perspective of pure code those expressions are just bottom
03:42:17 <Cale> (but already, I'd fork someone's project over catching an exception thrown from evaluation)
03:42:36 <merijn> Cale: So why does it matter if we can observe them in, e.g. IO?
03:43:01 <Cale> I'm not saying it hurts things all that much -- it's a pragmatic escape hatch to have
03:43:03 <merijn> Cale: It doesn't restrict evaluation order at all, it just means that at runtime we MIGHT observe a specific order of evaluation from IO
03:43:09 <Cale> But designing your programs that way is terrible
03:43:39 <Cale> Because you end up caring about the operational semantics of evaluation in ways that make the program fragile to changes in e.g. compiler optimisations
03:43:47 <merijn> Cale: I'm not advocating the use of throwing expressions. But either we don't have them (which is unrealistic unless you go to a total language) OR we have reasonable tooling for dealing with them
03:43:59 <merijn> Cale: I disagree
03:44:22 <Cale> Compiler optimisations can and do change the evaluation order
03:44:40 <Cale> and can change which exception will get thrown from the evaluation of an expression
03:44:47 <merijn> Cale: If I have an expressions that can throw any exception E from some set of exceptions, I don't get to care about order "oh, E1 will never happens since E2 gets thrown first"
03:44:57 <merijn> Cale: So?
03:45:02 <Cale> You might -- people do that kind of thing in ML
03:45:13 <Cale> and get away with it
03:45:33 <merijn> Cale: Like I said, you get to observe a specific evaluation order that happened at runtime. That doesn't mean your semantics have to depend on that ordering
03:45:35 <Cale> (because they think operationally about evaluation all the time)
03:46:18 <Cale> People use exceptions to indicate success :)
03:46:21 <merijn> Cale: Even if, at runtime, the evaluation order is a coin flip between exception E1 and E2, how does knowing that both E1 and E2 might get thrown 1) restrict the compiler 2) harm my reasoning about the program 3) restrict/hurt the semantics
03:46:49 <ph88_> this is my program so far with the data constructor Handler not in scope ?!  https://bpaste.net/show/18c27719bf26
03:46:54 <Cale> Well, depending on which exception gets caught, you will carry on with a different situation.
03:47:05 <Cale> and the rest of the program might behave differently
03:47:19 <Cale> So to understand what the program will do, you need to know which exception will be caught
03:47:26 <merijn> Cale: But if we have our handler in IO how is that different from what we have now?
03:47:45 <Cale> It's not different from what we have now. I'm describing something that's bad about what we have now
03:47:59 <Cale> But which culture discourages us from exploiting
03:48:04 <merijn> Cale: That's bogus. That's like saying I need to know what number input I get from stdin to predict what a program that reads a number and checks if it's even does
03:48:35 <ahihi> ph88_: you've imported the type, but not its data constructor. try e.g. Handler(..)
03:48:55 <ph88_> ah yes that helps :P
03:49:27 <Cale> Well, you know that whatever you read from stdin is going to be the number that was provided to the program as input. It's not just random chance or the whim of some low level detail of your compiler
03:50:04 <merijn> Anyway, I need to take a break from this and somehow beat this python code into working
03:50:39 <Cale> If you test a program which catches exceptions thrown from evaluation, you might find that it works. Then you upgrade your compiler, and some evaluation happens sooner by accident, before the handler happens, and now your program crashes.
03:50:54 <ph88_> what is handleIO supposed to be here ??  https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Exception.html#v:catches
03:51:04 <Cale> This isn't terribly likely, but it's possible.
03:51:08 <ph88_> i tried making my own function for it  handleIO ex = putStrLn "something here"  but that doesn't type match
03:51:11 <merijn> Cale: How could it happen before the handler happens without a compile error?
03:51:31 <merijn> Cale: And if the compiler isn't tracking that, then we still don't have what I'm arguing for
03:51:40 <Cale> merijn: Because the compiler arranged to evaluate something a bit sooner. Perhaps the strictness analyser was improved.
03:51:45 <merijn> Cale: That mistaken can only happen in the current setup, because the current setup is stupid
03:52:24 <Cale> ph88: Well, it's got to return something of the same type as the original action that it's catching an exception for
03:52:25 <merijn> Anyway, some other time :)
03:52:50 <Cale> catches :: IO a -> [Handler a] -> IO a
03:52:58 <Cale> ^^ the a's have to match
04:00:45 <ahri> holy crap. i just used a monadic bind to solve an actual problem and it actually solved my actual problem. time for a celebration drink. this haskell stuff isn't so crazy after all!
04:02:05 <zomg> ahri: I'm using a functor-inspired pattern to solve something different in JavaScript (and our codebase is far from FP style JS), so I wouldn't say Haskell stuff is crazy at all =)
04:04:57 <ahri> hehe, i'm kidding, it's just taken me a while to find my own problem to solve involving monads, so until now i've been a bit scared of them
04:05:25 <cspollard> hey does anyone know of a (nominal+variations) structure already available?
04:05:28 <ongy> ahri: one of my favorite moments was when I got my first (non-trivial) monad instance done and could clean up quite a bit of other code
04:05:59 <cspollard> i.e. data Tmp b a = Tmp a (Map b a)
04:07:21 <Cale> cspollard: There's a really old package http://hackage.haskell.org/package/total-map
04:07:27 <cspollard> where x <*> y "fills in" the default value if keys are missing in the two maps
04:07:27 <Cale> But it's probably still fine
04:07:46 <cspollard> thanks will have a look!
04:08:07 <Athas> Cale: that package is not even a year old!
04:08:11 <Athas> Does Haskell move that quickly nowadays?
04:08:29 <Cale> Oh, sorry, I read the wrong date :)
04:08:42 <Cale> The copyright wasn't updated
04:08:53 <Cale> 2012 would be quite old by now
04:09:21 <Cale> May 2016 isn't so old ;)
04:10:13 <cspollard> hm the applicative instance is not so easy to comprehend ;-)
04:10:39 * ongy really needs a commit-hook that autofixes copyright notices in source files...
04:13:21 <Cale> cspollard: Well, given some fs :: TMap k v, it helps to see that (!) fs :: k -> v  is the corresponding ordinary function
04:14:33 <Cale> cspollard: and tabulate, given a default value, a set of points to measure, and a function, produces a TMap which potentially varies from the default at the given points by having the given function's value there
04:15:02 <Cale> So it just uses tabulate with the default just being the default function applied to the default argument
04:16:00 <cspollard> got it
04:16:17 <Cale> and the set of keys to tabulate at being the union of the set of keys on which function might vary and the value might vary
04:16:42 <cspollard> I suppose this might predate Data.Map.mergeWithKey, which is what I have in my implementation
04:16:59 <cspollard> and if I'm not mistaken does the same thing
04:17:22 <cspollard> Cale: (sorry have not been tagging you)
04:17:44 <Cale> It might, but also there's a much newer bunch of stuff in containers which you might prefer to use instead of mergeWithKey
04:18:03 <Cale> http://hackage.haskell.org/package/containers-0.5.10.1/docs/Data-Map-Merge-Lazy.html
04:19:34 <cspollard> Cale: damn not available in my current stack snapshot
04:21:09 <cspollard> Cale: but thanks for the link I will keep this in mind in the future
04:22:28 <Cale> Yeah, it's quite new, I bugged dfeuer to implement something to solve the general problem of merging maps efficiently in various ways -- there are a lot of various Map operations which come up in our real world applications.
04:23:00 <Cale> It implements the operations by simultaneously walking down both tree structures, and uses the tactics you give it to decide what to do.
04:23:10 <Cale> So it'll be rather efficient generally :)
04:24:47 <eugenez> Friends! Is there a conditional iterate, that applies function until result "converges" so to speak and stops changing?
04:25:18 <Cale> Not in the Prelude at least
04:25:33 <Cale> You might just take the list you obtained from iterate
04:25:38 <Cale> and zip it with its own tail
04:26:15 <Cale> and then takeWhile (\(x,y) -> x /= y)
04:26:35 <eugenez> Cale: Yep, I was thinking of doing something like that, thank you very much!
04:26:45 <Cale> or some other condition which indicates convergence, like (\(x,y) -> abs (x - y) < epsilon)
04:28:29 <Unhammer> http://bildr.no/image/dHVDMkU2.jpeg 
04:29:01 <Unhammer>  – not confidence inspiring
04:29:30 <Cale> oh, that's odd
04:30:12 <Cale> I just get "Time limit exceeded" for that -- which is also very strange.
04:30:23 <Cale> > putStrLn "hi"
04:30:28 <lambdabot>  <IO ()>
04:30:36 <Cale> ^^ Would have expected something like that
04:30:43 <Unhammer> http://bildr.no/image/dkZ5K1lW.jpeg
04:30:45 <Unhammer> there we go
04:30:47 <Unhammer> even better
04:31:17 <Cale> I wonder what they have in scope in the sandbox
04:31:33 <Cale> IO actions aren't going to do much even if they fix this issue :)
04:31:57 <Cale> oh, apparently they *do* allow some IO
04:31:59 <Cale> that's curious
04:32:15 <Cale> ah, via this pure-io library which fakes things for you
04:32:19 <Cale> hmm
04:32:20 <Unhammer> they have "putStrLn line" as an example ;)
04:32:27 <Cale> ahh
04:32:56 <Cale> Interestingly, the example works
04:33:08 <Cale> Just not... literal strings?
04:36:03 <Unhammer> haha :(
04:36:35 <Cale> Definitely weird.
04:39:05 <Unhammer> https://github.com/haskell-infra/hl/issues/203
04:39:11 <Unhammer> reported 23 days ago
05:04:16 <ph88_> Cale, when i use catches what can i use for handleIO ?  https://bpaste.net/show/69faf915cb93
05:05:14 <Cale> ph88_: any... anything of the appropriate type?
05:05:43 <Cale> The type of the handler depends on the type of the action you're catching exceptions in
05:06:03 <Cale> It's going to take the exception, and it needs to produce a result of the same type the original action was going to produce
05:06:05 <ph88_> i use openFile do you mean that with action ?
05:06:34 <Cale> Yeah, so with openFile, it returns a Handle, so your handler needs to do so as well
05:06:48 <ph88_> but in case of exception i don't have a valid handle
05:06:54 <Cale> You might want to catch the exception in a larger block of code than that in that case
05:07:55 <ph88_> on a block that prints an io string ?
05:08:11 <ph88_> so then i can print the normal string in case all went fine or the exception string otherwise ?
05:08:14 <halogenandtoast> Do you suggest uses `catches` over something like `try` for example: https://github.com/halogenandtoast/nhk-reader-haskell/blob/6e28be090db17f9308ae74e82c74aa9b7e5c5fef/Util/Nhk.hs#L79
05:08:20 <halogenandtoast> s/uses/using/
05:08:35 <Cale> Something like that would work
05:08:55 <Cale> halogenandtoast: catches is primarily useful if you want to catch a variety of different exceptions
05:09:04 <halogenandtoast> Ah I see
05:09:56 <ph88_> Cale, maybe it's a good idea to create a type that can be handle or a string ?
05:13:21 <ph88_> something like   handle <- (Left <$> openFile path ReadMode) `catches` [Handler (\(ex :: IOException) -> Right <$> show ex)]
05:13:51 <merijn> ph88_: Isn't that just 'try'?
05:14:51 <ph88_> well try doesn't allow to match the type of exception
05:15:02 <merijn> It does
05:15:21 <ph88_> in catches you can put more handlers for each type of exception
05:16:17 <merijn> You can either catch a specific exception using try, or just catch 'SomeException' and use fromException to check what it is
05:18:09 <ph88_> handle <- (try $ openFile path ReadMode) :: SomeException    ?
05:19:08 <ph88_> oh no i found it should be this    handle <- (try $ openFile path ReadMode) :: IO (Either SomeException Handle)
05:19:34 <ph88_> quite large type signature, Handle could be infered, any way to put just SomeException ?
05:20:31 <merijn> ph88_: you can leave out the entire type signature, as long as you use handle later so it can infer the type
05:20:41 <ph88_> ah ok
05:21:30 <ph88_> why does fromException return Maybe e  and not e ?
05:21:46 <merijn> ph88_: Well, what if the exception is NOT 'e'?
05:22:07 <ph88_> e is just a placeholder, no ?
05:22:15 <merijn> i.e. what if you catch some custom exception, rather than IOException?
05:22:16 <ph88_> for the value of the exception
05:22:21 <merijn> ph88_: No
05:22:40 <ph88_> i can't do fromException on custom exceptions ?
05:23:11 <merijn> fromException :: Exception e => SomeException -> Maybe e
05:23:16 <ph88_> https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Exception.html#v:fromException
05:23:17 <ph88_> ye i saw it
05:23:19 <merijn> But that SomeException can be ANY exception
05:24:07 <merijn> ph88_: I can recommend reading Simon Marlow's paper, Haskell exceptions are a lot more flexible than many people think, but it's not necessarily obvious: https://pdfs.semanticscholar.org/85c6/306c27cbd7e241e3989f3fb72ce3d6bc02d7.pdf
05:24:42 <ph88_> ew what happened to the formatting :|
05:24:58 <merijn> You can actually introduce "classes of exceptions" like "MyLibrary" which has 10 different exceptions and then you can catch either a specific one or all 10 (but not others)
05:25:11 <merijn> ph88_: Here's a better one: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.78.205&rep=rep1&type=pdf
05:25:29 <merijn> ph88_: I just grab free URLs of Google Scholar, since not everyone has access to the paid copies
05:25:56 <ph88_> didn't know about Google Scholar
05:26:30 <merijn> Google Scholar is amazing
05:26:44 <merijn> For finding papers and for finding free copies of said paper
05:32:12 <liste> google scholar + sci-hub is a great combination
05:35:24 <merijn> bleh
05:35:42 <merijn> Travis tests are too verbose to see the actual error >.<
05:39:33 <ph88_> merijn, could you take a look? it's not really going well with the exceptions https://bpaste.net/show/a047fd81eafb
05:40:21 <cocreature> :t maybe
05:40:26 <lambdabot> b -> (a -> b) -> Maybe a -> b
05:40:41 <merijn> ph88_: Well, that's not working because you're basically asking GHC to *guess* what kinda exception it should try and convert 'e' too
05:40:44 <cocreature> ph88_: you are using "maybe a b" in a place where IO () is expected and you are passing a string literal as "a"
05:40:47 <merijn> eh, 'ex'
05:40:56 <merijn> Also that
05:41:00 <ph88_> oh ye i put this now:  putStrLn $ maybe "unknown type of exception" show (fromException ex)
05:41:48 <ph88_> merijn, yes i was thinking the type of the actual exception ! it's known at runtime
05:41:57 <lpaste_> merijn pasted “No title” at http://lpaste.net/353525
05:42:15 <merijn> That still breaks due to lack of conversion annotation
05:42:21 <merijn> But cleans up some noise
05:43:57 <ph88_> this totally defeats the purpose of using SomeException if i need to give the type of the specific exception i want to match on
05:44:19 <merijn> ph88_: Well, if you're only printing, why are you converting at all?
05:44:37 <merijn> ph88_: If you're not only printing, then GHC would be able to infer the type from whatever you're doing with it
05:47:52 <ph88_> when i do   show ex   i get   openFile: inappropriate type (is a directory)   how can i match on this ?
05:48:12 <ph88_> openFile: does not exist (No such file or directory)
05:48:20 <ph88_> everything is IOException here
05:51:05 <merijn> You want to use stuff like 'isIllegalOperationErrorType' from System.IO.Error
05:51:12 <ph88_> ok
05:52:29 <lpaste_> merijn revised “No title”: “No title” at http://lpaste.net/353525
05:52:34 <merijn> ph88_: Like that
05:53:00 <merijn> ph88_: And the use of isIllegalOperationErrorType will result in GHC inferring "IO (Either IOException Handle)" for try
05:54:08 <farao> hi, I want to write a haskell program, that reads data to the form of [(key, value)] and groups this by key so that it becomes [(key, Set value)] and puts it out in another file. I have a first solution that puts everything in a Data.Map (updating the map using "insertWith (Set.union)...") but it consumes gigabytes of memory on a 100M input file. So I thought about using Data.HashTable.IO but I'm struggling with finding a good pattern to f
05:54:10 <farao> old over a list putting (key,value) and (value,key) in the hashtable since this needs to be monadic. how do I do this?
05:56:38 <farao> clarification: putting (key, value) and (value, key) in the hashmap so that if there is no entry, the entry will be (key, Set(value)) otherwise (key, Set(value,previousvalues...))
06:01:12 <_sras_> What is the proper way to do logging of errors from a servant web application?
06:04:42 <lyxia> farao: were you using a lazy map
06:07:47 <farao> yes, I tried with Data.Map.Lazy and Data.Map.Strict with the same result. I don't know if I'm doing something wrong elsewhere, I'm reading the file, doing "lines" on it, using "concatMap" to produce [(key,value),(value,key)] from each line and putting those with a fold in a Data.Map.[Lazy|Strict]. Then I use toList on the map and produce outputlines to write to another file
06:08:03 <Cale> Are you using String?
06:08:23 <Cale> If so, then use Text instead
06:08:28 <farao> yes, readFile is giving me Strings
06:08:46 <Cale> String is a lazy linked list of 32 bit wide characters
06:08:55 <farao> ah
06:09:23 <farao> ok, I'll try that, thanks for the tip :-)
06:09:27 <farao> *advice
06:09:40 <ph88_> farao, what function will you be using to read from file and get Text ?
06:10:32 <farao> I just saw, that there is a readFile that gives me Text, I'll just change the type of my reader function I guess
06:11:09 <Cale> The Data.Text one will read the entire file into memory at once.
06:11:33 <farao> how can I prevent that?
06:11:42 <Cale> It might be worth trying Data.Text.Lazy there, if you're going to be parsing it.
06:12:04 <farao> ah ok, that makes sense
06:13:37 <Cale> Lazy I/O isn't always the nicest thing, but for one big file that you want to process in a streaming fashion, it's not too bad. The alternatives are using strict Text and reading smaller bits at a time, or using a fancy library such as pipes or conduit to manage streaming for you (but those are somewhat heavy tools)
06:14:27 <Cale> The downsides of lazy I/O are that you give up control over when the file handle is closed (which can matter if you're reading a lot of files), and that it's awkward if you want to handle exceptions.
06:14:41 <Cale> (that occur in the middle of reading the file)
06:15:19 <Cale> But the upside is that you write the program which gets the whole file at once and does a bunch of stuff with that, and it gets read only as needed.
06:16:45 <farao> yeah, that's what I want :-) I'll try with lazy Text instead of String and see if there's a difference
06:19:38 <ph88_> when using optparse-applicative how can i make it so that i don't need to specify a flag when using stdin https://github.com/pcapriotti/optparse-applicative#alternative  ?
06:21:26 <merijn> ph88_: You want to default to stdin and only use a flag to overwrite it?
06:22:12 <ph88_> i was thinking that if i don't give a filename that it would try to read from stdin automatically
06:22:39 <merijn> Just use "Maybe FilePath" and use stdin when Nothing?
06:23:17 <ph88_> ok i will try that
06:33:49 <Aruro> is it worth installing HaRe? it looks like it depends on ghc-mod, and ghc-mod is scary.
06:34:05 <merijn> What's scary about ghc-mod?
06:37:17 <farao> how can i cast a Data.Text.Lazy to an Int? there seems to be no "read :: Text -> Int"
06:37:37 <cocreature> read . Text.unpack
06:37:52 <merijn> Nah, there's a text specific one
06:38:09 <cocreature> oh? I only know of a bytestring one
06:38:09 <farao> where?^^
06:38:13 <merijn> https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Read.html
06:38:28 <merijn> farao: You need to puzzle a bit with the type to figure it out
06:38:40 <merijn> type Reader a = IReader Text a
06:38:47 <merijn> type IReader t a = t -> Either String (a, t)
06:38:52 <merijn> Simple enough to work with
06:39:24 <farao> ah ok. wow that's much more complicated than "read str :: Int" :D
06:39:31 <jhrcek> I'm reading "Haskell programming from first principles" it states that "Functor instances for a datatype are unique". Is that really so? How about following example:
06:39:41 <jhrcek> data Weird a = Weird a a
06:39:41 <jhrcek> is the following not valid instance of Functor? Do functor laws FORCE me to also apply f to x?
06:39:41 <jhrcek> instance Functor Weird where
06:39:41 <jhrcek> fmap f (Weird x y) = Weird x (f y)
06:39:52 <merijn> jhrcek: Won't type check
06:40:02 <cocreature> you don’t even need the laws for that :)
06:40:09 <merijn> jhrcek: Imagine if you had "Weird 1 2" and did "fmap even"
06:40:35 <merijn> jhrcek: Then you'd have "Weird 1 True" which is not ok since they should be the same type
06:40:39 <merijn> jhrcek: More relevantly what the text means is *lawful* Functors are unique
06:40:57 <merijn> jhrcek: So if there exists a lawful functor for a type, then it is the ONLY lawful functor for that type
06:40:58 <jhrcek> Ah, so I'm actually forced to apply to all occurences of a :)
06:41:14 <halogenandtoast> instance Functor (Weird a) where
06:41:18 <merijn> jhrcek: As opposed to, say, applicative, since types can have multiple different lawful applicatives
06:41:38 <cocreature> jhrcek: you can of course define data Weird b a and then it works out, that’s isomorphic to a tuple (a,b)
06:42:17 <jhrcek> merijn, cocreature: I get it. Thanks
06:42:20 <merijn> jhrcek: More realistically we *could* do "instance Functor [] where fmap f (x:xs) = [x]" <- this type checks, but it not a lawful functor
06:42:54 <cocreature> merijn: do you mean [f x]? otherwise this doesn’t typecheck
06:43:09 <merijn> jhrcek: GHC will happily let you write that, but it's also obvious that it doesn't obey the functor law of "fmap id == id" since "fmap id [1,2,3,4,5]" would end up as '[1]', rather than [1,2,3,4,5]
06:43:13 <merijn> cocreature: Eh, yes
06:43:15 <merijn> cocreature: Typing is hard
06:43:17 <ph88_> if i do   "cat myFile.txt" | myHaskellProgram   how can i read that stream of bytes into my haskell program ?
06:43:31 <merijn> ph88_: Pipes just write input to stdin
06:43:42 <ph88_> ya i search for stdin
06:43:45 <cocreature> :t getContents
06:43:46 <merijn> ph88_: Incidentally, that's a "Useless Use of Cat Award"
06:43:47 <lambdabot> IO String
06:43:48 <jhrcek> Right, that would break the identity law, because it "touches the structure" which functor instance shouldn't modify
06:44:11 <merijn> "myHaskellProgram <myFile.txt" :)
06:44:31 <ph88_> oh this one https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString-Lazy.html#v:getContents
06:45:16 <merijn> jhrcek: Fun trivia fact, despite there being 2 functor laws (as described almost everywhere), you only need to prove "fmap id == id" since the 2nd law is a free theorem (i.e. given Haskell's parameteric type system you get a free proof that it holds, iff you have a proof for the first law)
06:46:22 <jhrcek> merijn: nice. Where can I read more?
06:46:50 <jhrcek> Found ekmett's article: https://www.schoolofhaskell.com/user/edwardk/snippets/fmap
06:46:58 <merijn> jhrcek: Well there's Wadler's "Theorems for Free!" paper, but I'm not sure how readable that is
06:47:20 <halogenandtoast> Not that anyone said anything but my line `instance Functor (Weird a) where` was wrong since the type would have had to have been `Weird a b`
06:47:24 <halogenandtoast> as I've learned...
06:47:27 <ph88_> COOL !!    B.getContents >>= \str -> B.putStr (B.reverse str)
06:47:45 <merijn> jhrcek: In general, if you wanna read about proving things about programs, there's the excellent (free & including exercises!) Software Foundations book
06:47:48 <merijn> @where sf
06:47:49 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages",
06:47:49 <lambdabot> "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof assistant."
06:47:51 <halogenandtoast> If it's `Weird a a` then you'd have to have `instance Functor Weird where fmap f (Weird a b) = Weird (f a) (f b)`
06:48:57 <jhrcek> ph88_: try  B.interact B.reverse
06:48:59 <kylefang> halogenandtoast: what does `Weird a a` mean?
06:49:06 <Cale> merijn: Though ironically, you won't be able to use parametricity as a principle to prove anything with Coq/SF :)
06:49:32 <halogenandtoast> kylefang: I was just using the example type `data Weird a = Weird a a`
07:03:09 <ph88_> merijn, i want to show you my program so far https://bpaste.net/show/8b09440e2735
07:03:25 <ph88_> it's cool bcz it can handle input from stdin or from file
07:20:29 <ph88_> hey guys on line 55 i still have to put an implementation https://bpaste.net/show/8b13941dce02 so i can combine the implementations from line 43 and line 49 and duplicate some code, or is it possible to put that logic into a function somehow ?
07:22:02 <ph88_> hhmm i think i will try to make some functions there that yield IO actions
07:23:39 <lpaste_> allenj12 pasted “foldM error?” at http://lpaste.net/353528
07:27:01 <lyxia> allenj12: (rem + elem) mod 10,  did you mean   `mod`  instead of   mod   ?
07:27:50 <allenj12> yes i did actually
07:28:01 <ahri> ph88_: https://github.com/haskell/containers/issues/420 doesn't look like containers will get an update on Stackage
07:28:21 <ph88_> :(
07:34:14 <ph88_> that thing i was just asking i made an implementation now https://bpaste.net/show/aef70f7bf30b can anyone check if it can be done more cleanly, or is this as good as it gets ?
07:35:42 <ph88_> hahaha i created a bug by calling byteswap on both input and output function
07:38:41 <ph88_> should i remove byteswap from readFromFileToWrite or from writeToFile ?
07:40:12 <ph88_> hmm both seems to be the best :P
08:11:32 <ph88_> i have a bytestring and i want to "handle" 5 bytes at a time, i want to swap some characters and then to the same to the next 5 bytes,   should i work with the index function can keep track of a counter that points into the bytestring ? or is there a more functional way to do this ?
08:12:37 <ph88_> or maybe use splitAt ?
08:22:12 <ph88_> i tried with splitAt but i ran into a little problem with my byteswap function https://bpaste.net/show/3460cd2b9357  someone mind taking a look ?
08:22:43 <ph88_> this needs to be really fast as well, because it's the processing function that takes the most time
08:30:00 <shapr> ph88_: could you use one of the B.fold options?
08:30:35 <ph88_> shapr, i think the fold goes character by character, i need to by 5 characters at a time
08:48:06 <lpaste_> allenj12 pasted “very small style review?” at http://lpaste.net/353531
08:53:38 <eugenez> Friends, how to reduce this? filter (\x -> numOfFactors x == 2) [1..1000], my first thought was something like filter (numOfFactors <*> == 2) [1..1000] but that unfortunately does not work. May be it cannot be simplified?
08:54:52 <ph88_> eugenez, hows that even shorter
08:55:09 <glguy> eugenez: Your first version looks great
08:55:20 <ph88_> eugenez you can use list comprehensios too
08:55:33 <eugenez> Okay, thank you, friends!
08:56:22 <ph88_> glguy, perhaps you have any idea how i can work with that bytestring ?
08:57:22 <glguy> ph88_: If you want it to terminate you'll need to write it so that it has a reason to terminate
08:57:40 <glguy> and I'd use a Builder instead of repeated appends
08:57:47 <ph88_> a Builder ?
08:57:59 <glguy> http://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString-Builder.html
08:58:26 <ph88_> is there an opposite of a Builder, so that i can first take the bytestring that i have apart ?
08:58:55 <glguy> unpack :: ByteString -> [Word8]
08:59:09 <ph88_> wouldn't that create a linked list ?
08:59:30 <glguy> yeah, but it'd be short lived
08:59:39 <glguy> the whole list wouldn't need to exist at once
08:59:53 <glguy> You can just index the bytestring
09:00:07 <glguy> index :: ByteString -> Int -> Word8
09:00:16 <ph88_> would indexing the bytestring be faster than splitAt ?
09:00:24 <glguy> yeah
09:00:41 <ph88_>  Builders therefore take special care to ensure that the average chunk size is large enough. The precise meaning of large enough is application dependent. The current implementation is tuned for an average chunk size between 4kb and 32kb, which should suit most applications.
09:00:43 <glguy> or the same depending on how the optimizations work out (if the splitAt optimizes away)
09:00:52 <ph88_> i have just pieces of 5 bytes, maybe Builder is not the right choice for me ?
09:01:09 <glguy> No, the 5 byte number is irrelevant to that previous statement
09:01:25 <glguy> unless you're saying you literally only have 5 bytes in total
09:01:36 <ph88_> the total is many megabytes
09:01:41 <ph88_> but i need to process 5 bytes at a time
09:01:42 <glguy> yeah, then your 5 bytes don't matter
09:02:33 <glguy> Builder also allows you to specify the final size if you know it ahead of time, which you do
09:03:25 <ph88_> glguy, my program can also read from stdin with getContents, how do i know the final size of that ?
09:03:42 <glguy> Oh, in that case Builder will work out just fine in its default arrangement
09:04:22 <ph88_> glguy, what kind of check could i create to see if i need to do recursion or reached the end of the bytestring ?
09:05:13 <glguy> If you're not sure, then this is a good exercise that you shouldthink about
09:05:37 <ph88_> ya i feel like the ideas i have are stupid
09:05:43 <ph88_> like checking all 5 bytes if they are EOF
09:05:57 <glguy> There won't be any EOF bytes
09:06:32 <ph88_> also little mention about EOF on https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString-Lazy.html
09:06:56 <ph88_> should i check the length on each iteration ? it will be expensive
09:07:09 <c_wraith> there's... no such thing as an EOF byte. 
09:07:53 <c_wraith> all possible byte values are data, not signaling. 
09:08:29 <ph88_> so length checking then ?
09:10:44 <glguy> Why is checking the length expensive?
09:11:05 <ph88_> it says O(n/c) in the docs, and i have to do that on every 5 bytes
09:11:05 <glguy> If you're streaming from stdin you probably wouldn't want to check that, though
09:11:18 <ph88_> well either from stdin or from file
09:11:43 <glguy> You don't need to know how long it is anyway
09:11:58 <ph88_> why is that ?
09:12:18 <cocreature> just wait until an exception is thrown and check for isEOFError
09:12:38 <glguy> There wouldn't be an EOFError processing a ByteString
09:18:36 <cocreature> ph88_: btw if you are doing IO, you might just want to read small chunks of strict bytestrings at each step. length is O(1) on those
09:18:51 <glguy> or just check that there are at least 5 bytes available
09:19:10 <glguy> null . drop 5
09:20:01 <ph88_> i didn't run this yet, but just for the idea ... https://bpaste.net/show/53bd05b2556b
09:20:41 <ph88_> fixed types https://bpaste.net/show/359eb6d567dc
09:22:54 <m4lvin[m]> is there a well-known type class for types  that have only one value?
09:25:02 <cocreature> m4lvin[m]: afaik there isn’t
09:29:17 <ph88_> glguy, cocreature i implemented the suggestions you gave me https://bpaste.net/show/a4f439123caf it type checks, but when i run it  byteswap2 "1234 5678 "  i get an endless string  "3412 3412 3412 3412 3412 3412 3412 3412   i don't know why because i recurse on the part when already 5 are dropped
09:30:20 <cocreature> ph88_: you don’t recalculate rest in each iteration
09:33:08 <ph88_> ah yes ok now it works well
09:33:16 <ph88_> so this is the fastest thing i can make ?
09:34:04 <ph88_> version that seems to work https://bpaste.net/show/55bbe22e964e
09:35:20 <ph88_> hhmm there is still a problem with this version .. it can happen that i get as input "f120 f3" or something like that, it should then output "20f1 f3"  but now it throws an exception that the index is not valid
09:36:19 <m4lvin[m]> cocreature: ok, still thanks!
09:36:49 <cocreature> m4lvin[m]: what do you need that for? I can’t see any useful operations that you can implement in terms of that typeclass
09:42:11 <m4lvin[m]> Okay, I'll try to explain. I think I want something like a family of newtypes that are also Functors.
09:44:02 <cocreature> if your type has only a single inhabitant, then the Functor instance is going to be pretty boring
09:46:03 <m4lvin[m]> yes, it is trivial and basically the Identity functor.
09:46:13 <cocreature> no it’s Const
09:46:30 <Sornaensis> @info Const
09:46:30 <lambdabot> Const
09:46:51 <cocreature> hm I guess Identity () works too
09:47:06 <m4lvin[m]> ah, let me look at Const
09:47:20 <cocreature> and for Const you also need Const () if you only want a single inhabitant
09:47:26 <cocreature> so basically your type is isomorphic to ()
09:47:45 <cocreature> so I don’t really understand what you get out of knowing that
09:49:43 <m4lvin[m]> I used the different (but yes, isomorphic) types to label different newtypes. Maybe I did just reinvent "Const a b" here? http://lpaste.net/4108449596617785344
09:52:25 <freeside> m4lvin[m]: have are you familiar with http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/ ?
09:52:30 <freeside> s/have //
09:53:00 <cocreature> you never really use your Vocab typeclass. the only place where it’s used is in the applicative instance of "InVocab v" but you could get the value there just by pattern matching on one of the arguments if you assume it’s unique
09:53:55 <cocreature> it’s not Const however
09:55:09 <cocreature> it’s a special case of (a,b)
09:55:45 <cocreature> the monoid doesn’t really matter if you assume the value is unique so you can just use (First a, b) to get a monoid instance for any value
09:59:32 <m4lvin[m]> freeside: thanks, I know some of this but will read the series. already clarifies the role of ()
10:00:17 <m4lvin[m]> cocreature: so i am doing (a,b) where a is a type isomorphic to () ?
10:00:28 <cocreature> m4lvin[m]: I think so :)
10:01:12 <cocreature> m4lvin[m]: it looks like you don’t really care about the value and just want a type to differentiate things, so maybe "Tagged" is what you’re looking for
10:01:15 <cocreature> https://hackage.haskell.org/package/tagged-0.8.5/docs/Data-Tagged.html#t:Tagged
10:01:43 <m4lvin[m]> my motvation was having two things of type  b (BDDs) that should not be combined, so i want to label them with something on the type level.
10:01:53 <cocreature> yeah Tagged is exactly that
10:02:11 <m4lvin[m]> aha!
10:02:18 <m4lvin[m]> great :-)
10:02:43 <cocreature> it doesn’t even have a value for the first type parameter. it just adds an additional type paramater
10:04:14 <m4lvin[m]> yes, perfect. i can ignore the "experimental" though?
10:04:31 <cocreature> nobody cares about the stability field on hackage :)
10:04:37 <cocreature> Tagged has been there for quite some time :)
10:05:01 <freeside> m4lvin[m]: also, are you familiar with GF?
10:05:25 <cocreature> freeside: galois fields?
10:06:11 <freeside> http://www.grammaticalframework.org/
10:06:19 <m4lvin[m]> grammatical framework?
10:06:32 <cocreature> I’ve clearly been studying too much for my algebra exam :)
10:07:04 <m4lvin[m]> cocreature: good luck with that then :-) (my only galois theory lecture is too long ago)
10:07:13 <cocreature> thanks :)
10:08:03 <m4lvin[m]> freeside: not really (met some people working on GF at a summer school once and tried the android app...) why are you asking? is there a connection to my question?!
10:08:45 <freeside> dunno, it looks like you're doing linguistic type things?
10:10:31 <m4lvin[m]> ah, not really. I'm mainly in model checking modal logics.
10:10:49 <freeside> oh, ok, i misunderstood.
10:11:23 <freeside> have you found any haskell libraries that are useful for that sort of thing? Kripke structures, CTL/LTL, etc
10:12:40 <cocreature> m4lvin[m]: do you work on model checkers or do you apply model checkers to various problems?
10:13:50 <m4lvin[m]> i am writing a (symbolic) model checker, mainly for dynamic epistemic logic (DEL)
10:14:11 <m4lvin[m]> for temporal logics i do not know anything in haskell
10:15:10 <m4lvin[m]> (DEMO-S5 and SMCDEL are the epistemic model checkers made by us here, explicit and symbolic respectively)
10:15:57 <m4lvin[m]> </advertisement> ;-)
10:16:09 <freeside> thanks, i will go read your paper http://homepages.cwi.nl/~jve/papers/16/pdfs/2016-05-23-del-bdd-lori-journal.pdf
10:17:53 <freeside> i'm working on a project to formalize legal contracts, and it looks like DEL will be relevant to the aspects of contracts that have to do with giving notices, making public announcements, and responding to globally announced state changes, e.g. blockchain oracles.
10:26:35 <m4lvin[m]> oh, nice!
10:30:18 <freeside> yeah, are you guys seeing any interest from industry in commercial applications of your work?
10:32:35 <freeside> i wonder if the intersection between anonymity blockchains (e.g. zcash) and smart contract oracles (as in ethereum) offers an opportunity for your work to assess privacy preservation properties
10:33:35 <freeside> if i know that a smart contract performs some action based on information that is available to the smart contract but not to me, then when i observe that action, i deduce the original information.
10:33:46 <freeside> and then you can start bringing in ideas of differential privacy
10:43:52 <m4lvin[m]> i don't know of any industry interests for DEL ... model checking there is all temporal logics afaik. which makes sense if things like synchronizity matter. but if the focus is epistemic and a fixed sort of time (with perfect recall) is applicable, then DEL might actually be easier and more efficient.
10:46:02 <m4lvin[m]> what should i read to understand zcash / how it differs from bitcoin?
10:49:13 <jle`> m4lvin[m], cocreature: Const () is just `Proxy`
10:49:38 <cocreature> jle`: yeah good point
10:54:41 <hm02> greetings
10:55:27 <dylukes> Is anyone here familiar with configuring neco-ghc with deoplete? I'm running into an issue with completions of module contents.
10:56:05 <dylukes> import Control.Monad (<C-x><C-o>) ⇒ "Omni completion ^O^N^P Pattern not found"
10:56:12 <dylukes> import Control.Monad (<C-x><C-o> *
10:56:28 <dylukes> If I then add a space following the open parentheses, backspace, and complete, it works as expected.
10:56:51 <dylukes> If I exit insert mode, and then renter and complete, it also works.
10:57:01 <shapr> now I want to try neco-ghc
10:57:08 <dylukes> It looks to me like neco-ghc is lazily loading modules.
10:57:16 <dylukes> Also long time no see shapr. Hope life is finding you well.
10:57:24 <shapr> howdy dylukes! Yeah, life is good.
10:57:30 <shapr> How's code with you?
10:57:48 <dylukes> Pretty good! Currently working in a structural biology lab, as grad school applications haven't panned out.
10:58:00 <dylukes> Crystallographic analysis type stuff.
10:58:03 <shapr> Do you get to write Haskell for that?
10:58:24 <dylukes> Gold nanoparticles, Pol2 (RNA polymerase), and soon a network theory approach to hydrogen bond coordination.
10:58:33 <dylukes> Currently no, it's all Python. But that might change :).
10:58:52 <dylukes> There's certainly no restriction on using Haskell. It's just a matter of library support.
10:59:08 <shapr> hm, I thought I saw a bond graph library in Haskell
10:59:27 <shapr> not sure if that would help for hydrogen bond coordination
10:59:53 <dylukes> The goal is basically to model hydrogen-coordinations in proteins as a network.
10:59:57 <dylukes> Which they are,
11:00:11 <dylukes> in the sense that small permutations in one position can have *very* large effects at a distance.
11:00:37 <shapr> sounds interesting, but I am unfamiliar with that flavor of problem.
11:00:40 <dylukes> Think about the way a flower blooms. A very small exertion of force at the sepals and along the base of the petals results in an "unfurling" motion 
11:00:43 <dylukes> Me too!
11:00:46 <dylukes> That's why it's so exciting!
11:01:51 <shapr> does sound like fun
11:02:08 <dylukes> Well, I'm still puzzling out how it's going to work.
11:03:07 <dylukes> Anything graph/network related is almost always going to come down to very unsavory asymptotics :)
11:03:34 <dylukes> No reason I can't compile static haskell binaries against OpenMPI and deploy on the research cluster though.
11:03:41 <dylukes> 48h+ runs aren't unusual.
11:05:39 <dylukes> shapr: one of the most fascinating things is that while you'd think proteins are in general big squiggly messes, there are actually high level functional motifs that are still being found.
11:05:58 <dylukes> Which can be identified via loosely connected (but compact) sub graphs of the hydrogen bond graph.
11:07:13 <dylukes> Anyhow, anyone know if it's possible to have necoghc reload modules live? 
11:07:25 <dylukes> Having to exit insert mode isn't so bad, it's just a bit of a snag.
11:07:35 <shapr> dylukes: got any survey papers on that motif?
11:07:49 <dylukes> There's not really any one particular motif. 
11:07:56 <shapr> I really did think protein folding depended on all of the nearby state
11:08:10 <dylukes> It does. It's still an n-body problem in a sense.
11:11:34 <dylukes> shapr: this isn't about folding though, it's about allosteric effects.
11:12:04 <shapr> had to look that up, but neat!
11:12:31 <dylukes> For example, when ATP coordinates with Pol2 (RNA polymerase II), there's very substantial movement. If you imagine a flint-lock pistol, it's rather similar.
11:12:44 <dylukes> An entire "arm" (trigger loop) bends/rotates almost 180 to seal off a channel.
11:13:07 <zennist> I was just reading the new Retrofitting Linear Types paper (great read by the way); and wondering: does anyone have any idea how to actually implement: withQueue :: (PQ a -. IO a) -. IO a
11:13:08 <dylukes> So basically, you can observe these large-scale movements, but the question is, how do they happen? 
11:13:55 <shapr> interesting question
11:14:22 <dylukes> It's the same sort of problem as tracking neuronal activations, and trying to understand how they result in activity patterns. 
11:14:25 <dylukes> That is, a network.
11:14:42 <dylukes> Each individual coordination is relatively minor, but they can *leverage* each other, which seems to me key.
11:15:02 <Tuplanolla> I was expecting "that is, a mess".
11:15:05 <zennist> my motivation for the question: if you just allocate a normal object like what currently in haskell: e.g., PQ.fromList elements, that would be in the dynamic heap right? At which point can I put that into the linear heap instead?
11:15:20 <dylukes> Tuplanolla correct :p.
11:15:45 <dylukes> What I'd like to look at initially is where small movements magnify each other. 
11:16:13 <dylukes> For example if you had some rigid ball and stick thing A == B == C, where the == bend.
11:16:23 <pebblexe> how do I use a locally cloned github project (not on hackage) as a library in my cabal file?
11:16:31 <dylukes> Then a small movement of the A == B could leverage a B == C movement (changes the frame of reference).
11:16:56 <Tuplanolla> You can Cabal install it and simply refer to it by name after that, pebblexe.
11:17:05 <pebblexe> Tuplanolla: thanks!
11:17:18 <Tuplanolla> Point the installer to the Cabal file.
11:18:23 <dylukes> What's the long term direction with Cabal/Stack? 
11:19:32 <cocreature> dylukes: they’ll probably coexist for a long time :)
11:20:05 <bennofs> dylukes: don't write Cabal like that. There's two projects: Cabal (the library) and cabal-install (user interface to this library + the solver). Stack uses Cabal (the library)
11:20:12 <dylukes> That's what I mean.
11:20:24 <dylukes> I assume Stack is still using Cabal, and the Cabal format isn't going anywhere.
11:20:47 <dylukes> It's the cabal-install solver that I'd rather not have to use.
11:20:48 <cocreature> cabal-install is also not going anywhere for the foreseable future
11:20:49 <bennofs> dylukes: replacing Cabal would be a huge effort with what benefits?
11:21:03 <dylukes> I'm not suggesting replacing it?
11:21:07 <bennofs> dylukes: oh that's what you said, sorry
11:21:59 <bennofs> dylukes: well stack's solver command requires cabal-install, and I think quite a few people use it. And there's also users that just prefer cabal-install. So I don't think cabal-install will go away in the future
11:25:18 <bennofs> dylukes: I assume that long-term, both tools with coexist. I don't see why that would be bad thing
11:25:26 <dylukes> Good!
11:25:40 <dylukes> I was just wondering, not passing any judgement. I've been out of the toolchain loop.
11:26:44 <dylukes> Hm.
11:29:13 <pebblexe> does "Bad file descriptor during read" mean I have a disk problem?
11:29:34 <pebblexe> I got it as a slime error
11:29:56 <pebblexe> sorry wrong channel
11:59:20 <AWizzArd> Are there Foldable alternatives/variants, for data types with the kind  * ?
11:59:42 <lyxia> MonoFoldable
12:00:20 <AWizzArd> Ah good, will have a look, thx.
12:04:18 <AWizzArd> There is this trick, than when using a certain language extensions, one can simply derive Foldable.
12:04:51 <AWizzArd> Is there a way to make own type classes derivable? Or is this something that requires GHC support?
12:07:38 <geekosaur> currently requires support within ghc
12:08:08 <geekosaur> 8.2 will change this (or begin to change it; unsure if that part will be in 8.2) with deriving strategies
12:08:56 <lyxia> Generics go a long way though.
12:10:15 <jle`> AWizzArd: the way people usually do that is with Generics
12:10:40 <jle`> for example, the 'binary' library uses Generics to "derive" serialization instances and strategies
12:10:49 <jle`> the aeson library uses it to derive JSON representation for types
12:11:10 <jle`> you could use generics to derive Show/Ord/Eq/Foldable/Traversable too I believe
12:11:39 <jle`> generics can be considered a tool for deriving custom typeclasses
12:12:24 <AWizzArd> Is Quickcheck also using Generics, to be able to produce instances of any data type?
12:13:26 <lyxia> It can't produce an instance of any data type though
12:15:06 <shapr> hurrah! https://github.com/MichaelXavier/quickcheck-generic
12:15:28 <shapr> now I want to try that this evening after word
12:15:49 <shapr> oh, speaking of which ... I want to put a PR to add tau to the Prelude, since it's pi day.
12:16:19 <lyxia> I didn't see that one before I wrote my own generic-random
12:17:06 <shapr> lyxia: Is that the name on hackage? generic-random?
12:17:27 <Tuplanolla> Tau's a crap name though, shapr.
12:17:35 <shapr> Tuplanolla: what's a better name?
12:17:53 <lyxia> And for product types one-liner and product-profunctors provide a much more general pattern for generic stuff
12:17:54 <Tuplanolla> Anything that's not a letter that's all over math and physics.
12:18:01 <lyxia> shapr: yeah mine's on hackage
12:18:03 <Tuplanolla> Even `twopi`.
12:20:14 <nbro> hi
12:20:31 <nbro> can someone explain me what does this: "updateRec Rec {name = uname@"Bob", uid = idn@42} = …" actually mean?
12:21:13 <jle`> nbro: how familiar are you with record types
12:21:17 <jle`> or functions
12:21:26 <jle`> do you know how to declare functions in haskell?
12:21:29 <nbro> jle`: go ahead, and let’s see what I understand
12:21:33 <jle`> or how pattern matching works?
12:21:44 <jle`> Rec is probably a record type with the fields "name" and "uid"
12:21:51 <nbro> jle`: yes, I just don’t know what that syntax means
12:22:01 <nbro> the "@"…
12:22:05 <jle`> updateRec (Rec { name = "Bob", uid = 42 } = ...
12:22:13 <jle`> it matches a rec with name "Bob" and uid 42
12:22:22 <jle`> as patterns let you name the result of the pattern
12:22:27 <geekosaur> the term you are looking for is as-pattern
12:22:35 <jle`> > let f t@(x,y) = (t, (x, y))
12:22:38 <lambdabot>  <no location info>: error:
12:22:38 <lambdabot>      not an expression: ‘let f t@(x,y) = (t, (x, y))’
12:22:38 <jle`> > let f t@(x,y) = (t, (x, y)) in f (1,2)
12:22:43 <lambdabot>  ((1,2),(1,2))
12:22:59 <jle`> in the above pattern, the tuple is pattern matched on, and 'x' and 'y' are the named fields
12:23:04 <jle`> but the tuple itself can be bound to 't'
12:23:30 <jle`> > let f xs@(y:_) = y:xs  in   f [1,2,3]
12:23:33 <lambdabot>  [1,1,2,3]
12:23:43 <jle`> so there we match on the (y:_) pattern, the non-empty list
12:23:45 <jle`> and y is the head
12:23:51 <jle`> but we can also name the entire list xs
12:24:12 <nbro> so essentially we’re doing pattern matching and at the same time we have kind of a reference to the field
12:24:17 <jle`> yes
12:24:30 <jle`> it's kinda silly in the case you wrote, because 'uname' is always going to be "Bob"
12:24:41 <jle`> because the "Bob" pattern only matches on "Bob"
12:24:47 <jle`> literally
12:24:51 <geekosaur> makes sense if someone copied code that expects those names bound
12:24:57 <eacameron> How do I derive a client for a nested Servant API? I can't use servant-client's new generic module since I'm still on servant 0.9.1.1
12:25:05 <jle`> but if it was name = uname@('b':'o':'b':_)
12:25:11 <geekosaur> (workaround for where not scoping over multiple cases)
12:25:20 <jle`> then itn would match on any string that started with the letters bob
12:25:27 <jle`> and the entire string would be bound to 'uname'
12:26:00 <geekosaur> *my* problem with it is hardcoding usernames like that is questionable security :)
12:27:22 <freeside> just don't tell Alice and Carol
12:27:49 <Luefer> Reading about Lenses and Traversals at hackage I came across the following sentences: "A Lens' has a Functor constraint and Traversal' has an Applicative constraint. This means that any Lens' is automatically also a valid Traversal' (since Functor is a superclass of Applicative)." Shouldn't it be the other way around?
12:28:28 <lyxia> which way around
12:28:44 <Luefer> I mean since the Functor is the superclass all Travesals are Lenses.
12:28:52 <nbro> and can these as-patterns be used everywhere on the left side of the equals of functions?
12:29:07 <Luefer> But that does not imply that all Lenses are Traversals.
12:29:17 <geekosaur> nbro, they can be used anywhere a pattern is valid, so that and also case ... of
12:29:20 <lyxia> Luefer: a lens has to work for all Functors, and a Traversal for all Applicatives
12:29:34 <nbro> ok
12:29:52 <lyxia> Luefer: since a Lens works with all Functors, it also works for all Applicatives
12:30:04 <nbro> geekosaur: honestly I still need to see more examples of pattern macthing that aren’t on the left side of the equals
12:30:07 <geekosaur> there are some syntactic restrictions if you have TypeApplications enabled, because it also uses @ (iirc this means that while you could normally have spaces around the @, you must not have them with TypeApplications ebnabled)
12:30:22 <Luefer> lyxia: To me that feels like all Traversals are Lenses?
12:30:31 <geekosaur> nbro, case, let, and the left of a <- in do notation
12:31:01 <lyxia> Luefer: no because there are functors which a Traversal can not handle
12:32:28 <nbro> geekosaur: I’ve seen <- in the case and in list comprehensions, but not in the do notations
12:32:35 <nbro> but I’m also still not familiar with the do notations
12:32:40 <nbro> so far I’ve just written pure functions
12:33:05 <Luefer> lyxia: So I can have a Lens which is not a Traversal, no? I still don't get it.
12:33:38 <lyxia> Luefer: No, every Lens is a Traversal.
12:34:45 <lyxia> Luefer: A better way to understand this is that a lens is basically an accessor for a single field. a Traversal is an accessor for zero, one, or many fields.
12:35:28 <Luefer> lyxia: There is something fundamental that I don't get here. It makes sense that all Lenses are Traversals but when I read the definitions to me it feels that every Traversal is a Lens.
12:35:30 <nbro> guys, from a certain point of view, the fact that functions in haskell heavily use recursion may be a limitation, in the sense that if you do not have a good compiler or a computer with a good amount of resources, you can’t go everywhere you want
12:35:51 <byorgey> Luefer: I think maybe you are getting tripped up by the fact that the class constraint is like a function argument, so it is contravariant.  A Lens is something that can *accept* any Functor.  A Traversal can *accept* any Applicative.
12:36:01 <freeside> nbro, can you explain that point of view?
12:36:14 <byorgey> Luefer: something that can accept *any* functor can certainly accept Applicative ones.  So every Lens is a Traversal.
12:36:28 <byorgey> On the other hand something which *requires* an Applicative may not be happy with just any old Functor.
12:36:30 <geekosaur> nbro, the same is true of graph reduction in general tbh
12:36:36 <freeside> you are right that one would not want to run a Haskell program on, say, an Arduino
12:36:47 <geekosaur> (also "recursion" in the sense most people mean is not relevant in the context of graph reduction
12:36:52 <nbro> freeside: what if you have a recursive function which requires a lot of computation resources, i.e. the recurses for a long time
12:37:05 <nbro> *it recurses
12:37:46 <Luefer> byorgey: That makes sense. I kind of had a feeling it was something along those lines but I couldn't quite grasp it. I will make another attempt with this in mind.
12:37:51 <byorgey> nbro: what if you have an iterative function which requires a lot of computational resources, i.e. loops for a long time?
12:37:52 <freeside> mmm. you might enjoy reading https://wiki.haskell.org/Tail_recursion
12:38:22 <freeside> the problem you are thinking about is optimized away by any sensible language
12:38:46 <geekosaur> nb ro, the key here is graph reduction. if that means nothing to you, I suggest you learn about it; how Haskell works, and why tail recursion is an almost meaningless concept in Haskell, will make no sense to you until you understand graph reduction
12:39:05 <nbro> byorgey: yes, but in Haskell the recursion would occur on the stack, in a loop, you may do other things outside of the stack, moreover recursion requires more resources that iterative equivalent functions in order to keep track of variables, return values, etc
12:39:14 <rstefanic> I've crashed C programs nesting 8 loops inside of each other before. Resource management is a problem with any limited system.
12:39:22 <geekosaur> here eis exactly why you need ot learn about graph reduction
12:39:24 <geekosaur> there is no call stack
12:39:34 <geekosaur> there is a *pattern* stack
12:39:43 <geekosaur> it is not just the same idea renamed, it does something completely different
12:39:45 <nbro> rstefanic: 8 nested loops?
12:40:06 <nbro> nobody writes down 8 nested loops
12:40:11 <byorgey> nbro: right, that isn't true though.  See what others have said.
12:40:42 <freeside> about 8 years ago, byorgey wrote: https://mail.haskell.org/pipermail/haskell-cafe/2009-March/058607.html
12:41:17 <byorgey> woah
12:42:45 <c_wraith> foldr doesn't sound right there. did you mean something like map, or was that in reference to a specific use of foldr? 
12:48:44 <byorgey> c_wraith: you're right, foldr doesn't sound right.  I have no clue what I meant, it was 8 years ago!
12:48:57 <byorgey> Just for fun let's assume I meant "map".
12:51:19 <c_wraith> let's see.. 8 years ago.. I had at least started learning haskell. 
12:53:39 <geekosaur> well, the thread was about folds...
12:53:50 * geekosaur assumes braino
12:59:29 <freeside> http://stackoverflow.com/questions/4092864/tail-recursion-in-haskell and http://stackoverflow.com/questions/13042353/does-haskell-have-tail-recursive-optimization go on and on about this
13:09:13 <shapr> lyxia: would you recommend generic-random over quickcheck-generic?
13:13:48 <lyxia> shapr: it's the same for product types, but for sums you can specify custom distributions with generic-random
13:14:32 <shapr> ok, I'm convinced.
13:24:14 <techieAgnostic> Would anyone be able to help me with hdevtools and Vim? Can't get them to play nice
13:30:05 <kadoban> techieAgnostic: Personally I found it not worth the effort to maintain, if that's considered help.
13:30:31 <techieAgnostic> Fair, are there any you'd reccomend instead?
13:33:26 <kadoban> techieAgnostic: I just use ghci in a terminal, along with very minor haskell-specific stuff in vim, like a syntax checker and hlint really (using syntastic)
13:33:48 <kadoban> And my usual bunch of nonsense, like completion in non-language-specific mode.
13:34:15 <techieAgnostic> gotcha
13:35:43 <kadoban> To be fair, I do plan to figure out more integration some day, but I'm mostly waiting for someone to make something more mature and stable. Some of it was cool, it just ate up way too much time trying to keep it working and figure out why it wasn't working and etc.
13:40:34 <freeside> in most languages, documentation takes the form: "here is how you use the language and its libraries." in Haskell, documentation seems to prefer the form: "here is how you reimplement the language and its libraries."
13:40:39 <freeside> not a criticism, just an observation.
13:42:17 <schell> is it inherently wrong to implement Applicative in terms of Monad?
13:43:05 <schell> mf <*> mx = do{ f <- mf; x <- mx; return $ f x }
13:43:17 <lyxia> not at all
13:43:19 <kadoban> schell: Not really, no. 'ap' exists, by the way
13:43:23 <kadoban> :t ap
13:43:26 <lambdabot> Monad m => m (a -> b) -> m a -> m b
13:43:34 <kadoban> :t (<*>)
13:43:37 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:43:39 <schell> as in - does it violate the Applicative laws?
13:43:55 <schell> hmm that would make it a nice one liner
13:44:32 <kadoban> I don't think it even can violate the laws, if you use  (<*>) = ap  and pure = return from an already existing lawful Monad implementation, though I could be missing something.
13:44:46 <tdammers> https://wiki.haskell.org/Functor-Applicative-Monad_Proposal
13:45:30 <tdammers> basically, any lawful Monad is also a lawful Applicative, and ap == (<*>) and return == pure
13:52:37 <schell> kadoban, lyxia, tdammers: okay, thanks - here’s another argument - this implementation throws away the ability to parallelize
13:55:31 <lyxia> QuickCheck's (>>=) can be run in parallel.
13:59:00 <platz> 'parallelization in theory' seems to succumb to 'never in practice' in the current haskell libs
13:59:16 <platz> there are exceptions like haxl/fraxl etc..
14:00:35 <platz> haven't seen any other applicative instances do this though... Concurrently from Async is the only one i can think of
14:00:46 <ezyang> embarassing parallelism is still profitable 
14:01:17 <platz> and I'm not sure Concurrently really counts because it's hiding it under IO
14:01:26 <platz> hiding/implementing
14:03:00 <platz> yeah explicit parallelism is effective via accelerate/repa
14:03:43 <platz> but that is different from implicit parallisim under applicative instances
14:04:37 <platz> i guess Control.Parallel.Stratagies is the big one that does count in this regard
14:07:52 <michalrus> @hoogle m a -> m b -> m (a, b)
14:07:53 <lambdabot> Control.Concurrent.Async.Lifted concurrently :: MonadBaseControl IO m => m a -> m b -> m (a, b)
14:07:53 <lambdabot> Control.Concurrent.Async.Lifted.Safe concurrently :: (MonadBaseControl IO m, Forall (Pure m)) => m a -> m b -> m (a, b)
14:07:54 <lambdabot> Yesod.WebSockets concurrently :: MonadBaseControl IO m => m a -> m b -> m (a, b)
14:08:09 <michalrus> Where is “normal” zip? :P
14:08:29 <sveit> typically to fold down to a single value the strict foldl' is used to avoid allocating extra memory. that said, it seems natural to write "and = foldr (&&) True". is this memory efficient (i.e. as compared to explicit recursion)? More generally (assuming that (&&) is strict in its first argument) are functions that are strict in the first argument and lazy in the second folded efficiently by foldr?
14:14:44 <byorgey> michalrus: normal zip has a more specialized type, so it's farther down in the search results
14:14:54 <byorgey> @hoogle [a] -> [b] -> [(a,b)]
14:14:55 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
14:14:56 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
14:14:56 <lambdabot> GHC.OldList zip :: [a] -> [b] -> [(a, b)]
14:15:13 <michalrus> byorgey: yeah, but what is one for general `m` called?
14:15:42 <michalrus> Or do other preludes have it defined for `m`?
14:15:55 <byorgey> oh, I see, you are looking for mzip from the MonadZip class
14:16:02 <michalrus> Yes! Wonderful.
14:16:03 <michalrus> Thank you!
14:16:04 <byorgey> https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Monad-Zip.html
14:16:08 <shapr> byorgey: have you written generic-random part 2?
14:16:26 <byorgey> michalrus: you're welcome
14:16:36 <shapr> I'm going to use part 1 this evening, so I'm curious.
14:16:49 <byorgey> shapr: not yet.  It's on my list but I keep putting it off.
14:16:57 <shapr> also, thanks for all the great blog posts :-)
14:17:17 <byorgey> The problem is it's probably going to require some more research on my part and it might turn into multiple blog posts.  So I'm kind of intimidated by it.
14:17:33 <byorgey> shapr: sure =)
14:17:56 <shapr> you implied generic-random can produce examples for non-QC purposes
14:18:01 <shapr> that sounds exciting
14:18:13 <shapr> but then, so do the other implications for later part(s)
14:18:38 <lyxia> I ended up splitting boltzmann-samplers as its own package BTW
14:19:06 <lyxia> which is the part that is compatible with non-QC random stuff
14:19:25 <shapr> oh, interesting
14:20:09 <lyxia> and I would like to rewrite it with GHC.Generics instead of Data.Data
14:21:39 <byorgey> lyxia: oh, nice, I will have to take a look
14:21:52 <lyxia> The problem is it's so slow compared to testing-feat
14:22:36 <byorgey> interesting, any intuition as to why?
14:23:13 <byorgey> maybe it's only faster when n is very large?
14:23:57 <schell> lyxia, platz, ezyang: thanks guys
14:23:59 <byorgey> obviously they are using very different generation strategies.  In theory Boltzmann sampling is asymptotically faster than testing-feat, but...
14:24:16 <lyxia> I wrote about it here https://github.com/Lysxia/generic-random/issues/6
14:25:26 <lyxia> I suspect the constant factor is just too large
14:26:43 <Sornaensis> @info &&
14:26:43 <lambdabot> <unknown>.hs: 1: 1:Parse error: &&
14:26:47 <Sornaensis> @info (&&)
14:26:47 <lambdabot> (&&)
14:32:35 <byorgey> lyxia: hmm, that makes sense, but it's rather disappointing
14:33:21 <byorgey> lyxia: I wonder if we can perhaps identify a special class of problems where Boltzmann sampling actually pays off, i.e. some kind of worst case for testing-feat's approach
14:33:37 <byorgey> then at least we could say something intelligent about when you might want to pick which approach.
14:34:15 <sphinxo>  Have I got my usage of mapM wrong? http://lpaste.net/1618438411226447872
14:35:20 <sphinxo> I'm a bit confused by the error message
14:35:30 <lyxia> byorgey: That sounds good. Another possibility is to somehow "recycle" the randomness that is being discarded.
14:36:26 <byorgey> lyxia: ah, interesting idea.  So it wouldn't be faster to generate a *single* random thing but you might be able to get a nice "pipelined/streaming" algorith if you want to generate a sequence of random things?
14:37:34 <lyxia> I was imagining the recycling going into the single object you want to generate
14:37:57 <byorgey> oh, OK
14:38:13 <geekosaur> sphinxo, mapM used without the return would map the IO through. with the return, the monad it operates on is [] because the IO isn't available there
14:39:02 <sphinxo> geekosaur: so somethings wrong in my testFiles implementation
14:39:04 <sphinxo> ?
14:39:40 <geekosaur> why did you use a return in tests?
14:40:46 <sphinxo> geekosaur: I'm just returning the testCase?
14:40:58 <geekosaur> what do you think return does?
14:41:07 <geekosaur> (hint: it is not flow control)
14:41:10 <sphinxo> oh wait
14:41:35 <sphinxo> for some reason I thought takeBaseName required it, but that makes no sense
14:41:39 <freeside> what does "return" do? "return" causes every Haskell novice who has an imperative programming background to make mistakes that could have been avoided if "return" had been named something else. :)
14:42:36 <sphinxo> takeBaseName required IO, that is
14:43:36 <geekosaur> um
14:43:40 <geekosaur> you still do not understand
14:43:51 <freeside> :t mapM
14:43:54 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
14:44:09 <sphinxo> where tests = return ... bit right?
14:44:13 <geekosaur> return lifts a pure value into a monad. in the case of `tests` that monad is IO; therefore the thing you are returning is *not* in IO
14:44:44 <geekosaur> and the error iss telling you that mapM had to use [] because IO is *not there*
14:45:03 <geekosaur> because the `return` provided the IO
14:45:16 <sphinxo> ahh
14:46:40 <geekosaur> sin ce I don't know any of the types of the things in mkTest, I don't know if it actually needs IO; but it is not getting IO. ghc didn't get far enough to notice because mapM was already producing a type error
14:47:09 <sphinxo> well testFiles is the only thing that needs io
14:48:11 <geekosaur> then you (a) probably want to ditch the return in `tests` (b) and likewise in `mkTest` because you did the same thing again and there is no IO context for anything being `return`d
14:49:35 <sphinxo> how do I  map mkTest :: FilePath -> TestTree over testFiles ::  IO [FilePath]
14:50:18 <lyxia> (fmap . fmap) mkTest testFiles
14:50:43 <lyxia> or is there IO in TestTree?
14:51:01 <sphinxo> no
14:52:57 <lyxia> ok so what I said just before would make IO [TestTree]
14:53:43 <sphinxo> so I need to thread IO all down to here?
14:54:23 <sphinxo> or get testFiles at the top level, and pass it down
14:55:03 <freeside> fmap (mapM mkTest) testFiles
14:55:37 <freeside> wait, what are you doing again now?
14:56:02 <freeside> is mkTest returning an IO now or not
14:56:07 <lyxia> the type of mkTest seems to have changed in the meantime :)
14:56:13 <lyxia> not anymore
14:56:37 <sveit> sorry to repeat. typically to fold down to a single value the strict foldl' is used to avoid allocating extra memory. that said, it seems natural to write "and = foldr (&&) True". is this memory efficient (i.e. as compared to explicit recursion)? More generally (assuming that (&&) is strict in its first argument) are functions that are strict in the first argument and lazy in the second folded efficiently by foldr?
14:56:43 <sphinxo> if it did then that'd give me IO (IO [TestTree])
14:56:44 <freeside> oh, then fmap . fmap would be right
14:57:35 <freeside> fmap (fmap mkTest) testFiles ?
14:58:24 <lyxia> sveit: I think it is the same
14:59:00 <sveit> lyxia: what is the same? :) it's certainly not the same as using foldl' since it works on infinite lists
14:59:10 <freeside> see http://stackoverflow.com/questions/4092864/tail-recursion-in-haskell and http://stackoverflow.com/questions/13042353/does-haskell-have-tail-recursive-optimization
14:59:54 <lyxia> sveit: I mean, foldr (&&) True and a hand written recursive and
15:00:30 <freeside> http://stackoverflow.com/questions/3429634/foldl-is-tail-recursive-so-how-come-foldr-runs-faster-than-foldl
15:00:41 <sveit> lyxia: ah ok, that's what I hoped. is the general pattern that "&&" is strict in first argument and lazy in second?
15:02:37 <Enigmagic> @src and
15:02:37 <lambdabot> and = foldr (&&) True
15:03:17 <lyxia> sveit: yes
15:04:03 <lyxia> like in every programming language, except that in Haskell it's not built-in
15:04:26 <c_wraith> @src &&
15:04:26 <lambdabot> True  && x = x
15:04:26 <lambdabot> False && _ = False
15:04:31 <sveit> Enigmagic: interesting, clicking "source" on hackage gives a different definition (in terms of foldMap)
15:04:55 <c_wraith> lyxia, notice how the first argument is pattern matched, but the second isn't in either case? 
15:05:20 <c_wraith> lyxia, that's what determines how strict it is, and in which argument 
15:06:12 <sveit> so a related question, is a legitimate implementation of foldl': foldl' f = foldl f' where f' !a x = f a x?
15:07:06 <c_wraith> sveit, nope. 
15:07:17 <sveit> or foldl' f = foldl f' where f' a x = a `seq` f a x
15:07:35 <sveit> c_wraith: i figured not, but i can't see why. doesn't that only ever store at most one thunk?
15:07:39 <freeside> hm, following a strict interpretation of "strict", aren't you actually talking about the fact that pattern-matching forces evaluation of the first argument but not the second -- which is a different notion than "strict" forcing evaluation at time of construction?
15:07:39 <c_wraith> sveit, that is only strict when the result of f' is evaluated. 
15:07:54 <stephA> hello everyone. What is the most haskellish way t?o transform a [Maybe MyType] into |MyType] while ignoring Nothing ? for the moment I do something with filter and a predicate that does the pattern matching, but I wonder if there's not a more direct way 
15:08:13 <peddie> :t catMaybes
15:08:15 <lambdabot> [Maybe a] -> [a]
15:08:20 <stephA> perfect !
15:08:21 <lyxia> sveit: http://lpaste.net/353545 shows that both compile to the same Core
15:08:22 <c_wraith> sveit, foldl', on the other hand, puts the evaluation dependency on the recursive call to foldl'
15:08:57 <sveit> c_wraith: i'm confused because won't the next call to f' force the evaluation of the previous f completely (since 'a' becomes 'f a x', and 'a' gets evaluated)
15:09:19 <c_wraith> sveit, only if something forces f' to be evaluated. 
15:09:34 <c_wraith> sveit, and the whole problem with foldl is that it doesn't do that. 
15:11:41 <c_wraith> sveit, consider x `seq` x
15:11:53 <c_wraith> sveit, do you know why that doesn't do anything? 
15:12:05 <sveit> c_wraith: yes
15:12:22 <c_wraith> sveit, well, this is the same underlying idea. 
15:13:11 <Enigmagic> sveit: just need to go back a few versions, e.g. https://hackage.haskell.org/package/base-4.6.0.0/docs/src/GHC-List.html#and
15:13:27 <c_wraith> sveit, if nothing evaluates an expression, the internal evaluation dependencies of that expression don't matter. 
15:13:53 <sveit> c_wraith: i'm still a bit confused. can you explain where the following picture goes wrong (i'm sure it is)? call foldl'' f = foldl f where f' !a x = f a x (my "wrong" foldl'). then if i call foldl'' f x0 xs, i will get ONE unevaluated thunk. when i ask for that thunk everything gets evaluated strictly.
15:14:41 <c_wraith> the problem is that you don't get one evaluated thunk. 
15:15:28 <c_wraith> foldl builds up a whole chain of thunks. 
15:15:35 <c_wraith> that's just what it does. 
15:16:09 <c_wraith> > foldl f z [a, b, c] 
15:16:12 <lambdabot>  f (f (f z a) b) c
15:17:12 <c_wraith> so, first it creates (f z a). then it uses that as an argument to f (..) b, and so on. 
15:17:13 <sveit> but doesn't your second f force (f z a) if it's strict in the first argument?
15:17:28 <c_wraith> only if something causes it to be evaluated. 
15:18:19 <c_wraith> that's the thing. if nothing forces the expression to be evaluated, *nothing* will be evaluated. 
15:18:26 <sveit> ah i think i'm starting to understand. so function arguments only get evaluated, even if strict, when the value of the function is actually requested.
15:18:47 <c_wraith> more specifically, when the result of the function is evaluated. 
15:19:27 <sveit> so adding a bang pattern before an argument is redundant if the function uses the value of the argument?
15:19:35 <sphinxo> How to apply 2 functions to something and make a tuple of the results?
15:20:02 <sphinxo> ( usage: carrying a filename, with the files content )
15:20:02 <c_wraith> for a sufficiently precise definition of "uses", sure. :) 
15:20:21 <sveit> c_wraith: forces to be evaluated :)
15:20:36 <lyxia> sphinxo: Control.Arrow.(&&&)
15:20:46 <sveit> that seems like a strange convention though. of course if i add a bang pattern i want the argument to get evaluated as soon as possible. what is the reason for building it this way?
15:21:10 <sveit> i could evaluate arguments without evaluating the function
15:21:25 <c_wraith> sveit, it's the same thing as x `seq` x, in that sense. 
15:21:30 <lyxia> sphinxo: liftA2 (,)
15:22:20 <c_wraith> sveit, seq doesn't cause evaluation. it *links* the evaluation of two expressions. 
15:22:47 <c_wraith> sveit, bang patterns desugar to calls to seq within the function body. 
15:23:33 <sveit> makes a lot more sense! is there a way to cause evaluation?
15:24:00 <freeside> https://ghc.haskell.org/trac/ghc/wiki/StrictPragma
15:24:30 <sphinxo> thanks
15:24:39 <c_wraith> if you follow the chain all the way up.. the only thing that truly causes evaluation is IO. in every other case, evaluation is the result of demand from something else. 
15:34:57 <sphinxo> Any reason why my test suite ( which has my main library as a build-depends ) would not have a package that my main library has?
15:35:52 <c_wraith> things that are only transitive dependencies aren't exposed to be imported directly. 
15:35:54 <sveit> is there a reason that GHC doesn't use the function "foldl f x0 (x:xs) = foldl f (f x0 x) xs" to only build ONE thunk, then evaluate the chain when the value is requested? this would allow f being strict in one argument to have the same behavior as foldl'
15:37:05 <lyxia> sphinxo: you must relist dependencies separately for test suites/benchmarks/executables
15:37:52 <sphinxo> so how do I import my library from my test suite?
15:38:01 <sphinxo> as a package or something?
15:38:15 <lyxia> like any other package
15:43:21 <sveit> basically my question is if i have "foldl f x0 (x:xs) = foldl f (f x0 x) xs", why can't i not evaluate ANYTHING (including building thunks) until evaluation is forced?
15:44:10 <lyxia> GHC doesn't have a fine enough analysis to tell that f x0 x will be needed.
15:44:35 <c_wraith> it isn't always needed. 
15:44:41 <c_wraith> it depends on f
15:45:29 <sveit> hm, still a bit confused. another example: "let s = foldl (+) 0 [1..100000] in print s"; why is the language structured so that /all/ the thunks are built first, then we get a value for s?
15:45:50 <c_wraith> for instance, one of the few cases in which foldl is fine: reverse = foldl (flip (:)) [] 
15:46:01 <lyxia> it could make that analysis depend on f
15:47:49 <c_wraith> sveit, can you provide an alternate language semantics that would be better? I mean the details of it, not just "it gets this one situation right"? 
15:48:08 <sveit> c_wraith: are you saying the advantage there is that i can reverse a list without evaluating the elements? if that's the only feature you want to preserve my picture of not building up the thunks first, but only building one is compatible.
15:48:23 <sveit> c_wraith: at most one thunk is built up until a value is requested
15:48:29 <c_wraith> sveit, I mean, the real answer to your question is that no one else has provided better semantics, either. 
15:48:50 <c_wraith> sveit, that's not an operational semantics 
15:49:16 <sveit> c_wraith: let me try again :) tail recursive functions only recurse once until they are forced
15:49:44 <c_wraith> sveit, actually, my point with reverse is that the thunks being built up are the (:) constructors. 
15:49:46 <lyxia> let s = foldl (+) 0 [1 .. n] in ... already takes constant space until s is needed
15:50:35 <c_wraith> sveit, so.. how does graph reduction proceed when the result is demanded? 
15:51:31 <c_wraith> sveit, I mean, haskell is open-ended on reduction strategy, as long as the result is maximally defined. 
15:52:07 <lyxia> sveit: so I find what you're asking confusing. It's already just one thunk before being evaluated.
15:52:42 <sveit> now i'm confused too. let me try to be a bit more precise.
15:58:12 <sveit> let's focus on foldl'' f = foldl f' where f' a x = a `seq` f a x. currently, let s = foldl'' (+) 0 [1..n] in print s evaluates by (1) building the thunk (...((0 + 1) + 2)... + n), (2) evaluating it inside out. instead, since f' is strict in the first argument, and we know the value of the fold is being requested, it will always be consistent to evaluate the inner function application first instead of building the thunk, righ?
15:59:35 <c_wraith> sveit, out of curiosity, are you testing this with optimizations? ghc actually tries to do that rewrite when you tell it to optimize. 
16:00:12 <c_wraith> sveit, but as with most optimizations, it's heuristic-driven. 
16:07:48 <AWizzArd> I have my own data structure, a tree. Can a Lens be used to remove the nth element of the tree?
16:08:55 <c_wraith> if you have the right lens... maybe. 
16:09:21 <c_wraith> does your tree have values in the internal nodes? 
16:09:22 <glguy> There isn't a single "tree" type, so it will help to be more specific
16:10:26 <AWizzArd> Well, my tree is a Program, that my GP system wants to evolve.
16:10:46 <AWizzArd> I just want to ask in general, if this could be done. I don’t need something concrete right now.
16:10:53 <c_wraith> the big problem is with deleting elements from a tree in general. 
16:11:08 <AWizzArd> But for the mutation function it would be interesting to delete or insert elements, or to change/mutate them.
16:11:12 <glguy> There's no general answer. It's unlikely that "nth element of a tree" will support a lens
16:11:24 <AWizzArd> (obviously by mutation I mean genetic mutation, and not a side effect)
16:11:29 <c_wraith> that's not a defined operation unless you provide more details. 
16:11:56 <AWizzArd> Okay, I see. In that case I will simply implement it myself.
16:12:06 <c_wraith> for instance, if you have an expression tree for (2+(3*4)), what does it mean to delete the + node? 
16:12:34 <AWizzArd> It would result in (2 (3*4)) – in my case.
16:13:00 <c_wraith> so the tree becomes a forest? 
16:13:04 <AWizzArd> One can delete the 2, the + the  (3*4) subtree,  the 3,  the *  or the 4
16:13:22 <glguy> can I delete a left parenthesis?
16:13:28 <AWizzArd> glguy: nope
16:13:41 <AWizzArd> c_wraith: yes, probably that’s the name.
16:14:15 <c_wraith> AWizzArd, I mean, in some sense you're not even deleting that node - just changing it to a sequence operation. 
16:14:35 <glguy> so deleting the * from c_wraith's example leads to   (2+(3 4))?
16:14:35 <AWizzArd> It’s fine (and expected) that mutations of genes are typically not very beneficial.
16:14:44 <glguy> The subtree 3*4 is replaced by a "forest"?
16:14:45 <AWizzArd> glguy: exactly!
16:14:56 <glguy> Yeah, so you've got something that isn't a "tree"
16:14:59 <AWizzArd> My GP system can still make use of this.
16:15:20 <freeside> http://learnyouahaskell.com/zippers
16:15:23 <glguy> so you'll have to be much more specific about what you *do* have for questions like if it can have a lense
16:17:29 <AWizzArd> Oki, makes sense. I will delay the Lens thing then and simply implement it by hand, for now, and come back to this a bit later.
16:31:39 <jle`> AWizzArd: lens doesn't let you define new actions; it is a way of phrasing/encoding actions things in a composable way
16:31:55 <jle`> s/is a/can be used as a
16:32:26 <jle`> AWizzArd: so once you define your deletion function, you can make it more composable with other functions, and lens would probably help with that
16:40:41 <Habib> Hey, anyone know a version of <*> where the type signature is more like Functor f => f (a -> b) -> a -> f b? I know I can just use pure to wrap the value up before operating on it with <*>, but surely there's a function that will just take care of that for me?
16:41:05 <Tuplanolla> @hoogle Functor f => f (a -> b) -> a -> f b
16:41:06 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
16:41:06 <lambdabot> Prelude (<$>) :: Functor f => (a -> b) -> f a -> f b
16:41:06 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
16:41:17 <Tuplanolla> I'm sure I've seen it around.
16:41:39 <Habib> Yeah, I searched hoogle, but it didn't turn up anything useful.
16:41:46 <Tuplanolla> @hoogle (??)
16:41:46 <lambdabot> Control.Lens.Lens (??) :: Functor f => f (a -> b) -> a -> f b
16:41:47 <lambdabot> Control.Lens.Operators (??) :: Functor f => f (a -> b) -> a -> f b
16:41:47 <lambdabot> Control.Error.Util (??) :: Applicative m => Maybe a -> e -> ExceptT e m a
16:42:15 <Habib> Holy crap, the first one looks promising.
16:42:34 <Tuplanolla> This makes Hoogle look broken.
16:42:46 <Habib> Does that mean I'll have to start learning about Lens? I've been trying to avoid that until after this project.
16:42:53 <shapr> lens is wonderful
16:43:16 <Tuplanolla> You can just yoink that one function.
16:43:31 <Habib> I'm aware of its benefits, but I feel like I don't have a handle on understanding it, and so would prefer to avoid using it for now.
16:44:31 <glguy> The ?? operator just happens to be in Control.Lens. It's not "using lens" in any interesting way beyond the coincidence of using Functor
16:44:45 <Habib> But yes, if this function does what I want, it seems to be easily understandable.
16:47:55 <dmwit> :t let f ?? x = fmap ($x) f in (??)
16:47:57 <lambdabot> Functor f => f (a -> b) -> a -> f b
16:48:11 <Habib> Is it reasonable to pull in lens for just this one thing when I could just use pure to wrap the value? It's just annoying because I have to actually do pure . fromString on the value, because I want an IsString instance.
16:48:22 <glguy> No, it's not reasonable to pull lens in for this
16:48:27 <dmwit> It is not reasonable to pull in lens for this.
16:48:31 <Habib> lol
16:48:35 <Habib> ok, ok, i got it.
16:48:36 <dmwit> Just write the definition above in a file and be done.
16:48:52 <Habib> Ay, I didn't think of that.
16:49:17 <Tuplanolla> You can even name that module `Control.Lens`.
16:49:21 <jle`> learn the lessons of left-pad :)
16:49:31 <Habib> I think I'll name it Control.Functor
16:49:39 <Tuplanolla> You could play pretend without ten-hour compile times.
16:49:42 <Habib> What does the Control name actually stand for.
16:49:59 <jle`> nothing, really
16:50:00 <dmwit> Re: "ok, ok, i got it." -- not trying to swamp you with advice. It's just coincidence that we happened to have the same answer and type at about the same speed.
16:50:15 <Habib> Yeah, I know. I'm just trying to be funny :)
16:50:49 <dmwit> okay =)
16:51:49 <robkennedy> Which type I could wrap around functions whose output type depends on the input type? Ie listToMaybe, typeRep (constant relationship). 
16:52:08 <dmwit> You will need to be more specific.
16:52:28 <jle`> you mean functions of the form 'f a -> g a', that work for any 'a'?
16:52:31 <Habib> listToMaybe returned value depends on the input value, not the type.
16:52:52 <jle`> they're commonly called natural transformations
16:53:05 <jle`> type Nat f g = forall a. f a -> f g
16:53:12 <dmwit> :t typeRep
16:53:12 <jle`> er, type Nat f g = forall a. f a -> g a
16:53:14 <lambdabot> forall k (proxy :: k -> *) (a :: k). Typeable a => proxy a -> TypeRep
16:53:17 <jle`> but i'm not sure that's what you actually mean
16:53:23 <dmwit> The output type of `typeRep` does not appear to depend on the input type.
16:54:46 <robkennedy> I tried `newtype F fo = F (forall i. i -> fo i)`, where you could construct a type family `ListToMaybe` and write `H listToMaybe :: H ListToMaybe` 
16:55:12 <robkennedy> Sorry, I switched from F to H there
16:55:30 <freeside> the old switcferoo
16:55:49 <glguy> ListToMaybe is a type family with no parameters?
16:56:10 <robkennedy> Well there's the rub: it won't work that way
16:56:12 <dmwit> Presumably it is a family with `type instance ListToMaybe [a] = Maybe a`.
16:56:13 <glguy> That's just a type synonym
16:56:41 <Habib> @type listToMaybe
16:56:43 <robkennedy> dmwit intuited correctly thanks 
16:56:43 <lambdabot> [a] -> Maybe a
16:57:19 <glguy> robkennedy: You can't omit the parameters when you use a type family, so "H ListToMaybe" indicates that it has no parameters
16:58:48 <dmwit> Why do you want this?
16:58:56 <robkennedy> Right, I understand that. So `newtype H fo = H (forall i. i -> fo i)` doesn't seem like the right type wrapper
16:59:01 <dmwit> Perhaps there is a solution which avoids needing to create `F` (or `H` or whatever).
16:59:34 <robkennedy> Yeah, I'm looking to use functions on heterogeneous collections
17:00:39 <jle`> looks like a specific case of newtype NatTrans f g = NT (forall a. f a -> g a)
17:01:20 <moookle> whats a good hashmap library for haskell?
17:01:23 <robkennedy> Maybe... Does that allow `NT typeRep`?
17:01:29 <moookle> or is there a builtin hashmap structure?
17:01:45 <jle`> moookle: there's unordered-containrs if you want actual *hash* maps
17:01:57 <jle`> but Data.Map from containers is the typical map structure
17:02:08 <jle`> key-value dictionary
17:02:27 <jle`> robkennedy: how is typeRep similar to listToMaybe ?
17:02:27 <moookle> oh is Data.Map not a hash map?
17:02:39 <dmwit> Hash maps turn out to be surprisingly hard to make both ephemeral and efficient, which turn out to be key ingredients for idiomatic use.
17:02:54 <jle`> moookle: it's map that's not implemented using hashing
17:02:55 <dmwit> Data.Map is uses a balanced search tree.
17:02:58 <kadoban> No, it's a comparison-based ordered dictionary. (something like a BST-backed)
17:03:12 <moookle> oh I see
17:03:24 <moookle> dmwit: what do you mean 'ephemeral'?
17:03:28 <jle`> but i'm mentioning it because ruby uses the word "hashmap" to refer to key-value dicts in general
17:03:43 <jle`> so i suspect yuo might actually just want a map
17:03:45 <jle`> with a map API
17:03:47 <robkennedy> jle': how is it not? Rather than our ListToMaybe family, you'd have a `Const TypeRep` or similar
17:03:55 <kadoban> This is fairly typical, for example std::map in C++ is a BST-based ordered dictionary.
17:04:00 <moookle> jle`: yeah just a map
17:04:14 <jle`> typically you'd use Data.Map for this
17:04:17 <moookle> jle`: is containers like the standard haskell library for collections?
17:04:30 <jle`> yeah, it's actually used to ghc
17:04:34 <jle`> *used by ghc
17:04:39 <dmwit> moookle: "Ephemeral" means that you can roll back to any earlier version of the data structure for free.
17:04:39 <moookle> ok cool :)
17:04:43 <geekosaur> ordered collections. there's also unordered-containers which is standard hash-based collections
17:04:56 <jle`> moookle: and it's also where the most effort goes into optimization
17:05:07 <jle`> dmwit: do you mean ... persistent?
17:05:14 <dmwit> Perhaps I mean persistent.
17:05:23 <jle`> because ephemeral means the opposite of that
17:06:23 <jle`> robkennedy: what type family are you talking about?
17:06:33 <jle`> :t typeRep
17:06:36 <lambdabot> forall k (proxy :: k -> *) (a :: k). Typeable a => proxy a -> TypeRep
17:06:36 <jle`> :t listToMaybe
17:06:39 <lambdabot> [a] -> Maybe a
17:07:21 <jle`> hm yeah i suppose you could do NT (Const . typeRep) :: NatTrans p (Const TypeRep)
17:07:37 <dmwit> robkennedy: I suspect you'll be in for a lot less pain if you avoid heterogeneous collections, too. =)
17:07:39 <jle`> but actually, there has been some talk about a typerep type that is parameterized by the type
17:08:55 <robkennedy> dmwit: well my current research goal is to improve our situation on that front - I think it's within reach.
17:09:44 <jle`> oh wait, you can't do that beucas eit requires a constraint
17:10:21 <robkennedy> jle': yeah, the general point I think holds is that you can write a type function TF for any function f so that `f :: a -> TF a`
17:10:58 <robkennedy> Switch those predicates; for any function f you can write a TF
17:13:17 <jle`> how does that fit into typeRep?
17:13:40 <jle`> typeRep is `Typeable a => f a -> TypeRep`
17:13:42 <robkennedy> TF _ = TypeRep 
17:14:37 <jle`> you could naively just wrap up that function, but, i'm not sure if it'll help you any heh
17:15:13 <robkennedy> Okay you're right, you need a constraint for typeRep - I have a different solution for those solved, I was considering typeRep unconstrained
17:15:31 <jle`> and also 'TF _ = TypeRep' doesn't really let you do anything special for listToMaybe
17:15:55 <jle`> listToMaybe :: [a] -> Maybe a
17:16:01 <robkennedy> It's a different TF for each function, if that weren't clear. 
17:16:02 <juri_> http://implicitcad.org/ now working properly again. :)
17:16:27 <jle`> yeah, using NatTrans, you can parameterize it based on the type functions/constructors
17:16:37 <jle`> you can require a constraint too by parameterizing on the constraint
17:16:52 <pacak> Any ideas how to make some code that will load fine in ghci but will fail to compile?
17:16:53 <robkennedy> I'll hit that. 
17:16:57 <jle`> newtype NatTrans c f g = NT (forall a. c a => f a -> g a)
17:17:23 <jle`> this should still form a category I believe
17:18:02 <jle`> the original form would just have 'c' be the always-satisfied constraint
17:18:12 <jle`> type NoConstraint a = () :: Constraint
17:18:16 <robkennedy> Ummm does `NatTrans head` or `NatTrans (:[])` typecheck? 
17:18:37 <jle`> you'd need to explicitly go thorugh the identity functor
17:18:53 <robkennedy> Sorry, `NT head`
17:19:13 <robkennedy> Ah, okay. That's not too bad. 
17:19:18 <jle`> NT (I . head) :: NatTrans c [] I
17:19:32 <jle`> newtype I a = I { getI :: a }
17:19:52 <jle`> (which is also Identity from Data.Functor in base)
17:20:07 <jle`> NT ((:[]) . getI) :: NatTrans c I []
17:20:22 <dmwit> pacak: Sure, just don't put `main`. ;-)
17:20:48 <jle`> NT (Const . typeRep) :: NatTrans Typeable p (Const TypeRep)
17:21:01 <pacak> dmwit: There is no main, but a few things are exported.
17:21:56 <dmwit> pacak: I suddenly feel lost.
17:22:01 <robkennedy> Okay, that's pretty much the abstraction I was looking for. The wrap into Identity is not terrible. I appreciate it
17:22:21 <dmwit> pacak: Your first question was about how to write some new code. Your followup refers implicitly to some existing code. Can you help connect these two comments for me?
17:22:23 <jle`> instance Category (NatTrans c) where id = NT Prelude.id; NT f . NT g = NT (f Prelude.. g)
17:22:30 <pacak> dmwit: It's a module, it contains a bunch of stuff that's exported to be used in different modules
17:22:43 <hsk3> (/) :: Fractional a => a -> a -> a
17:22:44 <hsk3> 2 :: Num t => t
17:22:44 <hsk3> If 2 is only Num, why can I do "2 / 2"? 2 is not Fractional.
17:22:44 <hsk3> This seems like magic to me. If something implements Num, does it automagically also implement Fractional?
17:22:54 <jle`> hsk3: 2 is not only Num
17:23:10 <jle`> Num is not a type, anyway
17:23:12 <pacak> The goal is to avoid getting debugging-only code to compile
17:23:18 <jle`> hsk3: if 2/2 :: Double
17:23:23 <jle`> then 2 can be Double, which is an instance of Num
17:23:34 <jle`> if you :i Double in ghci, you will see that Double is an instance of the Num typeclass
17:23:44 <jle`> so (2 :: Double) is perfectly fine
17:23:45 <dmwit> pacak: Ah! You don't mean "write code which works in ghci, but causes a compile error", you mean "write code which does something in ghci but gets compiled to a no-op".
17:23:58 <jle`> Double is also an instance of Fractional, so you can use  '/' with it
17:24:13 <dmwit> pacak: CPP seems like a reasonable way to do this.
17:24:22 <pacak> dmwit: More like get's compiled into big nice "don't do that dumbass" ghc error
17:24:29 <dmwit> pacak: -D something special when compiling but not when loading with ghci (or vice versa).
17:24:31 <jle`> if __main__ == "__main__" ...
17:24:43 <pacak> And talking about CPP - that's the reason I'm worried
17:25:14 <pacak> Code uses unboxed tuples and other magic that is not very ghci friendly so there are two versions and it gets switched with ghci
17:25:17 <pacak> with CPP
17:25:43 <jle`> hsk3: not all things that implement Num implement Fractional
17:25:50 <jle`> hsk3: but all things that implement Fractional implement Num
17:26:25 <Xnuk> @src Fractional
17:26:25 <lambdabot> class (Num a) => Fractional a where
17:26:25 <lambdabot>     (/)          :: a -> a -> a
17:26:25 <lambdabot>     recip        :: a -> a
17:26:25 <lambdabot>     fromRational :: Rational -> a
17:26:27 <pacak> Are there any -D that ghc defines during normal compilation?
17:28:23 <lyxia> the compiler version probably
17:28:45 <lyxia> pacak: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html#standard-cpp-macros
17:29:14 <jle`> pacak: if you getProgName, then you can tell if something is loaded in ghc or not
17:29:19 <jle`> but this happens at runtime
17:30:19 <jle`> maybe you can use getProgName in a TH splice
17:30:53 <jle`> this is almost certainly a bad idea
17:31:06 <pacak> It is :(
17:32:42 <freeside> https://downloads.haskell.org/~ghc/master/users-guide/bugs.html#bugs-in-ghci-the-interactive-ghc
17:32:55 <geekosaur> hsk3, this is not OOP subtyping. Num specifies the *maximum* available interface; if all you have is a Num constraint, you cannot assume that anything else is available
17:33:39 <dmwit> geekosaur: I find this sentence deceptive and possibly untrue.
17:33:56 <geekosaur> could you expand on that?
17:34:32 <dmwit> If I give you a value of type `forall a. Num a => a`, you can assume much more than just `Num`. You can pick a specific `Num` instance and assume everything you know about that instance.
17:35:37 <geekosaur> actually I misread hsk3's comment and they were talking about the opposite situation. but yes, I was not talking about that situation
17:35:56 <geekosaur> I will be hyperpedantic to the point of incomprehensibility like a perl 5-er from now on.
17:36:16 <dmwit> I'm not encouraging that. But sloppy has its own pitfalls.
17:36:26 <geekosaur> ...or just not bother since comprehensibility is not one of the goals here apparently
17:36:28 <c_wraith> geekosaur, we just call that "precise" :) 
17:36:42 <hsk3> When a generic function is actually called, all the generic type parameters have to be concrete types, right?
17:36:54 <dmwit> What is a generic function?
17:36:58 <freeside> ${^PEDANTRY} = 65535;
17:37:01 <jle`> s/generic/polymorphic, but yeah
17:37:05 <jle`> generic is a Java term
17:37:17 <hsk3> Ok. Now.
17:37:17 <hsk3> When I do 2 / 2, what does 2 turn into? Double?
17:37:29 <jle`> it depends on what you want the result to be
17:37:30 <dmwit> That depends. In ghci, by default, yes.
17:37:55 <jle`> if there are no other clues the ghc will make a guess and assume you mean Double, but this is sort of an ad-hoc thing
17:37:56 <geekosaur> oh, so I described the oposite condition to yours (covariance vs. contravariance, roughly), and if I am permitted...
17:38:11 <jle`> > 2 / 2 :: Float
17:38:12 <freeside> when you do 2 / 2, it doesn't turn into Double. it turns into Half! ha, ha.
17:38:14 <lambdabot>  1.0
17:38:16 <dmwit> I'm not sure I'm on board with "when a polymorphic function is actually called, all the type variables have to be concrete types", by the way. But it might be a decent first approximation for now.
17:38:27 <robkennedy> hsk3: but if you define a different type which is Fractional and Num, it could be that. If you turn on Wall you will be told more about this
17:38:42 <hsk3> But if it's Double by default, why is the result a generic Fractional?
17:38:42 <hsk3> Prelude> let b = 2 / 2
17:38:42 <hsk3> Prelude> :t b
17:38:42 <hsk3> b :: Fractional a => a
17:38:51 <geekosaur> the case (2 :: Num a => a) means that the compiler knows how to generate that value at any Num instance type (by applying fromInteger; Num instances must provide this)
17:38:55 <jle`> hsk3: polymorphic
17:39:01 <jle`> but that's because there are no other clues
17:39:08 <jle`> so b can be *any* instance of Fractional you want
17:39:12 <geekosaur> (/) requires a Fractional instance, so that constrains what Num instances are permitted
17:39:20 <jle`> do you want it to be a Double? you got it!  if you want it to be Float, that's ok too!
17:39:22 <geekosaur> then defaulting leads ghc to pick Double as the type
17:39:30 <jle`> do you want it as a Rational? knock yourself out :)
17:39:38 <jle`> ghci keeps polymorphic bindings polymorphic
17:39:54 <jle`> b could be *any* instance of Fractional that you want
17:40:38 <jle`> defaulting doesn't happen in ghci by default, but it happens in haskell source code for performance reasons
17:40:39 <dmwit> hsk3: Now you see why I was not on board with "when a polymorphic function is actually called, all the type variables have to be concrete types".
17:40:47 <geekosaur> jle`, um
17:40:58 <geekosaur> defaulting does happen because it compute it it needs to know the type
17:41:04 <freeside> ghci: Keepin' It Classy[tm]
17:41:04 <dmwit> hsk3: In fact, when a rank-1 polymorphic function is called, all the type variables have to be made monomorphic. But they may not be concrete types.
17:41:05 <jle`> oh, yeah
17:41:14 <geekosaur> monomorphic bindings don't happen in ghci by default
17:41:18 <jle`> only when you eventually want it as a monomorphic type
17:41:26 <jle`> that is true
17:41:39 <jle`> defaulting happens like normal. monomorphization doesn't happen like normal
17:41:40 <dmwit> hsk3: And in this case, they are made monomorphic with *other type variables*; then those other type variables are re-generalized to make the whole computation polymorphic.
17:43:08 <geekosaur> this makes a bit more sense when you understand what is going on behind the scenes: a (Num a) constraint means that the compiler must provide a dictionary containing the Num instance methods for whatever type a is at the call site
17:43:16 <dmwit> This is made significantly more confusing by the fact that Haskell tries to hide the difference between `forall a. a` and `a` from the user.
17:43:20 <geekosaur> likewise (Fractional a)
17:44:53 <geekosaur> (except it's the methods for the Fractional instance, and that includes the dictionary for (Num a) as well)
17:45:09 <hsk3> The above confuses me. I don't fully understand it.
17:45:10 <hsk3> This is why I've the habit of always doing "default ()".
17:45:10 <hsk3> It allows me to ignore these complexities and just specify the type I want, e.g., (2 :: Integer).
17:45:22 <geekosaur> in standard Haskell it would also have dictionaries for Show and Eq but ghc doesnt so that any more
17:45:23 <hsk3> What is your opinion of doing this?
17:45:36 <dmwit> hsk3: The latter is fine and encouraged. The former is unusual.
17:46:09 <hsk3> dmwit what's the former?
17:46:38 <dmwit> hsk3: Adding type signatures to fix types is fine and encouraged. Removing the defaulting rules is unusual; but you might like -XNoMonomorphismRestriction, which is common and encouraged.
17:46:48 <geekosaur> actually turning off defaulting can get you in trouble, because you can't always specify what typeclass instance you want in a situation involving other typeclasses
17:47:05 <geekosaur> (unless you enable TypeApplication and use @ to specify)
17:48:42 <hsk3> An ordinary Haskell book for normal people won't suffice to get this.
17:48:42 <hsk3> I'm going to have to read the Haskell Report :S
17:48:45 <geekosaur> especially in ghci since it uses ExtendedDefaultRules; I think with normal defaulting you always have a way to specify in the case of the few typeclasses that defaulting works with
17:49:35 <geekosaur> somehow people manage to get it... as I said it makes more sense if you understand that a typeclass constraint is a dictionary passed around
17:50:33 <geekosaur> you have exactly what that dictionary says you have
17:51:22 <dmwit> hsk3: I'd be glad to explain further, but at the moment I believe I've lost track of your concrete questions.
17:51:47 <hsk3> I'm going to have digest all of the above and get back to you later. Thank you all!
17:51:50 <geekosaur> this also covers dmwit's case of a (forall a. Num a): it could be any Num instance, but all you can know about it is the Num instance. (also, yes this means it is actually a function, not a value! the compiler must pass it a typeclass dictionary to get a value)
17:51:55 <ricky_clarkson> If you're used to thinking in Java or similar, here's something I wrote explaining it: http://rickyclarkson.blogspot.com/2009/01/typeclass-pattern.html
17:52:35 <geekosaur> Haskell compilers try to hide this, but => looks a bit like -> for a reason; it really does represent an extra parameter, just not one you can supply or manipulate except by changing the signature
17:54:00 <geekosaur> (barring some evil which I believe dmwit has experience with :)
17:54:11 <dmwit> =)
17:54:35 <dmwit> Also worth mentioning that many of the comments here are GHC-specific. Other compilers implement typeclasses in other ways.
17:54:56 <dmwit> But dictionary-passing is a pretty good way to understand it, not least because GHC is absolutely the most-used compiler.
17:58:11 <geekosaur> also because (at least I'm under the impression that) the original Report specification of typeclasses was geared toward a simple dictionary-passing implementation, to make life easier for compiler writers
17:58:48 <geekosaur> (what ghc can do with typeclasses is much more than the Report specifies, but that just means not the simplest possible dictionary passing impl)
18:27:02 <jchia_> I'm trying to build a graph at compile-time and using it at run-time to traverse the nodes in a specific order (a node can be visited only if it has no unvisited predecessor). I specify a node with a unique string name and an arc by providing the names of the nodes. Currently, I'm building it at runtime, so if I misspell a node name when adding an arc, I get a run-time error. How can I build the graph at compile-time so that such errors
18:27:02 <jchia_>  are compile-time errors?
18:33:50 <Cale> jchia: Well, perhaps you could at least choose a different type from String for your vertices
18:41:28 <Sornaensis> HAPPY PI DAY
18:43:24 <hsk3> Sornaensis :)
18:47:01 <okeuday_bak> have you used your round function today?
18:57:58 <halogenandtoast> Morning all
19:22:37 <jalnanco> Hi :)
21:02:33 <nak> can someone explain EitherT to me quick ?
21:02:41 <nak> specifically, what is: runEitherT :: m (Either e a)
21:02:53 <nak> m is the monad type we're transforming, right? but what is e and a?
21:03:07 <Koterpillar> nak: that's not the full type
21:03:29 <Koterpillar> :t runEitherT
21:03:31 <lambdabot> error:
21:03:31 <lambdabot>     • Variable not in scope: runEitherT
21:03:31 <lambdabot>     • Perhaps you meant ‘runWriterT’ (imported from Control.Monad.Writer)
21:03:36 <Koterpillar> :t runWriterT
21:03:38 <lambdabot> WriterT w m a -> m (a, w)
21:03:43 <geekosaur> EitherT and MaybeT work a bit differently from the other transformers, iirc
21:03:57 <Xnuk> @hoogle runEitherT
21:03:58 <lambdabot> Control.Monad.Trans.Either runEitherT :: EitherT e m a -> m (Either e a)
21:04:14 <nak> ok so what is "e" and "a" there ?
21:04:20 <Koterpillar> e is the error type
21:04:23 <Koterpillar> a is the result
21:04:24 <geekosaur> but for Either it has two type parameters but a monad can have only one, so the "e" has to be fixed like the "s" in StateT s m a
21:04:40 <geekosaur> and as usual, "a" is the result type of a computation in the monad
21:05:49 <nak> ok so let's pretend we have a Just x or a Nothing
21:05:55 <nak> how would we use EitherT to transform it ?
21:06:09 <geekosaur> those are Maybe, not Either, so EitherT isn't the right mapping
21:06:19 <geekosaur> MaybeT also exists though
21:06:33 <nak> oh, so EitherT transforms Either TO something else
21:06:36 <nak> not something TO either
21:06:49 <nak> mmm that makes more sense
21:06:55 <geekosaur> depends on how you think of it
21:07:02 <nak> Ok so let's say we have a Left x or a Right y
21:07:23 <nak> can we go EitherT to Maybe?
21:07:23 <geekosaur> e is your x, a is your y
21:07:33 <geekosaur> EitherT goes to Either, not to Maybe
21:07:56 <nak> EitherT goes to Either...
21:08:00 <geekosaur> there is nothing that magically transforms a Maybe to an Either, because you'd have to specify what to map Nothing to
21:08:10 <pavonia> :t either (const Nothing) Just
21:08:13 <lambdabot> Either b a -> Maybe a
21:08:23 <geekosaur> likewise if you wanted to convert an Either (or EotherT) to a Maybe, you;d have to specify what to do about the e
21:08:29 <geekosaur> (which is to say, the value of a Left)
21:08:47 <nak> ok so EitherT goes TO an Either tho?
21:08:50 <nak> from some other type
21:09:02 <geekosaur> I phrased that badly, I guess
21:09:41 <geekosaur> EitherT gives you a way to work with an m (Either e a) without having to dig around inside the m all the time, basically
21:10:04 <geekosaur> in this sense it's "backwards" from other transformers which put something "on top of" the m
21:10:28 <nak> mm 
21:11:07 <pavonia> It's an 'm' enhanced by the opportunity to fail prematurely with an error result
21:11:27 <spatial> valueofnewstate <- readthevalue a (ReinforcementLearning.index newstate) How do I catch exception and print the values involved ?
21:11:54 <nak> ok so let's say we do have a Just(Left(x)) or a Just(Right(x))
21:12:02 <nak> would EitherT help here
21:12:13 <spatial> Any way to isolate printing in a separate function.
21:12:58 <nak> ie, iff we were to be okay with demoting the Left(x) down to a Nothing
21:14:10 <nak> geekosaur: i guess i'm most confused that e and a are specified when i only have one value at a time
21:14:36 <geekosaur> you may have only one value, but you have both *types*. one is phantom at any given time
21:14:50 <geekosaur> if you have a Right 5 :: Either String Int, you cannot use it as an Either Int Int
21:15:05 <geekosaur> it is still Either String Int
21:17:35 <spatial> Left and Right. How are they used in valueofnewstate <- readthevalue a (ReinforcementLearning.index newstate) ?
21:20:43 <geekosaur> spatial, the Left/Right discussion is not related to your question
21:21:01 <geekosaur> unless the types specify that it is... but I see no types here and have no way to answer as a result
21:21:37 <geekosaur> if there is an actual exception then there is Control.Exception.catch... but I'd want to check the API to see if there's a better way, because exceptions are a lousy way to handle that
21:26:34 <spatial>  valueofnewstate <- catch (readthevalue a (ReinforcementLearning.index newstate)(\(SomeException e) -> print $ e)      Is this right ?
21:27:16 <spatial> I am returning some values in a long function though. Just wanted to print at this time.
21:31:59 <geekosaur> in theory yes, in practice this may bite you unless you can ensure it gets evaluated
21:32:15 <geekosaur> I did not say "lousy way to handle that" because that's not the Haskell way
21:32:33 <geekosaur> I said it because *it does not work well with laziness" --- yet it seems like exceptions are the first thing some programmers reach for
21:33:06 <geekosaur> some strict language taught them that was the only correct way to think, so they do it in Haskell and then wonder why the exception gets thrown outside the catch
21:37:58 <spatial> http://lpaste.net/353552 Here attempted to add catch.
21:40:11 <spatial> Looks like I need to return something. But I am just debugging. IO Double and IO ()
21:42:34 <geekosaur> you must return something
21:42:43 <geekosaur> you are assigning (<-)
21:43:00 <geekosaur> you must return something that can be assigned
21:44:24 <spatial> But returning something makes by flow go wrong.Can I return the same value ?
21:45:00 <geekosaur> what same value?
21:45:07 <geekosaur> you didnt get a value, you got an exception
21:45:21 <halogenandtoast> geekosaur: I think this is where you explaination of errors really shines
21:45:55 <halogenandtoast> s/errors/exceptions/
21:46:05 <geekosaur> this still hasn't reached the real problem which is that the call that can raise the exception is still lazy and could happen when the result is used, which will be outside the catch so the exception gets thrown
21:46:29 <geekosaur> IO is not the strict subset of Haskell, it's still lazy
21:46:48 <geekosaur> and people get bitten by exceptions happening lazily all the time
21:47:53 <Cale> Er, it's hard to say that execution of IO actions is lazy or eager, because they're not really expressions in a usual way. They describe things which ought to occur in a particular order. If you throw exceptions from the execution of IO actions, they'll be reasonably easy and sensible to catch
21:47:55 <halogenandtoast> geekosaur: is the solution here to use valueofnewstate somewhere pending the exception returns something?
21:48:13 <geekosaur> usually, yes. or at least force it somehow
21:48:15 <Cale> It's just when you're throwing exceptions using throw or error or undefined, from the evaluation of expressions, that things get tricky.
21:48:45 <Cale> You generally should avoid throwing exceptions from expression evaluation if you have any intention that they be caught.
21:49:20 <Cale> If you're going to use exceptions, use throwIO
21:51:17 <Cale> The one *ahem* exception to that is perhaps if you're using a poorly designed library, you may want to catch exceptions that it throws from evaluation for some reason. However, I've forked libraries before rather than do that.
21:51:28 <Cale> It's less trouble.
21:52:51 <halogenandtoast> Cale: speaking of catching exceptions, do you have any insight on this line: https://github.com/halogenandtoast/nhk-reader-haskell/blob/master/Util/Nhk.hs#L79 is there something better I could be doing there?
22:09:07 <halogenandtoast> I guess that wasn't only directed at Cale, but they seemed to have strong opinions.
22:09:16 <Cale> halogenandtoast: Oh, sorry, meant to reply, but got distracted. That looks reasonably sensible to me.
22:09:41 <halogenandtoast> Cale: No worries, not like I'm paying you for your opinion. Thanks!
22:09:58 <halogenandtoast> I hate having to typecast it, but I don't use the error
22:10:06 <halogenandtoast> I guess I could have a function that "eats" the error
22:10:06 <Cale> You could replace the try with catch
22:10:16 <Cale> or handle
22:10:50 <Cale> handle (\(e :: HttpException) -> return Nothing) $ do ...
22:12:26 <Cale> (and then write the same do-block, only just assume the simpleHttp will work out)
22:12:37 <halogenandtoast> Does doing it that way provide any benefits (e.g. it's easier to change in the future, etc.)
22:12:47 <Cale> I dunno, it's about the same
22:12:52 <halogenandtoast> I haven't used `catch` or `handle` yet
22:13:12 <halogenandtoast> I didn't even want to use the `try` but simpleHTTP forced me to...
22:13:33 <halogenandtoast> Actually... annoyingly enough it didn't force me to
22:13:39 <halogenandtoast> my app failing at runtime forced me to
22:13:41 <halogenandtoast> boo hiss
22:13:57 <Cale> Well, yeah, I'm not really a fan of that.
22:14:52 <halogenandtoast> Rightfully so. I wish it just returned an Either to begin with.
22:14:55 <Cale> It's reasonably expected that you're going to actually get those exceptions and want to handle them pretty quickly. Just having the result be an Either to begin with would likely be nicer.
22:15:09 <halogenandtoast> Agreed! We can be friends!
22:16:13 <halogenandtoast> I feel like well written Haskell code forces me to handle all the cases.
22:17:05 <halogenandtoast> Being surprised with a runtime error is not my cup of tea.
22:18:20 <halogenandtoast> And of course for me that error was particularly annoying because it only happened on "production" because Akamai had flagged the IP I'm using preventing it from accessing images (using a droplet so I assume someone once used it for something bad).
22:21:47 <spatial> catch ( valueofnewstate <- readthevalue a (ReinforcementLearning.index newstate) )(\(SomeException e) -> print  e >> return Nothing)  Is this the pattern ?
22:22:49 <halogenandtoast> spatial: I assume it could be if readthevalue returns a Maybe
22:23:52 <halogenandtoast> actually... the catch needs to be to the right of the arrow no?
22:23:52 <spatial> IO Double. Don't know how I can return a dummy value. Isn't it wrong to do that ?
22:24:58 <halogenandtoast> spatial: I think you first have to answer the question, what should happen if readthevalue fails.
22:25:10 <spatial> I catch and rethrow the exception generally in Java.Or use wrapped exceptions.
22:25:25 <spatial> Fails.
22:26:38 <halogenandtoast> maybe this: valueofnewstate <- catch (readthevalue a (ReinforcementLearning.index newstate)) (\(SomeException e) -> print e >> fail e)
22:27:42 <spatial> halogenandtoast: Seems like it.
22:28:26 <halogenandtoast> you might want to use `failIO` there instead
22:28:38 <halogenandtoast> but I don't know
22:29:06 <halogenandtoast> For Monad IO fail s = failIO s
22:29:24 <halogenandtoast> So I suppose there is no difference here.
22:30:37 <spatial> fail e throws Couldn't match expected type `String' with actual type `e'
22:30:59 <Cale> Use throwIO
22:31:42 <halogenandtoast> that sounds better
22:34:16 <halogenandtoast> spatial: The issue with fail that I "failed" on was that it expects a string (which you could, but shouldn't in this case, get with show). It also doesn't do what you wanted since it will terminate the program there instead of "reraising" as you put it.
22:34:16 <Cale> (and pretend that fail doesn't exist)
22:34:40 <halogenandtoast> spatial: Cale is correct in that `throwIO e` should reraise and expects an Exception instead of a string.
22:36:04 <halogenandtoast> which is more in line with what you wanted. In my perfect world though readthevalue would just return a `IO (Maybe Double)`
22:36:11 <MarcelineVQ> as someone motly innocent about exceptions, what is being done here? why is catching being done if one isn't doing anything about the caught error? the exception would be printed if left to propogate yes?
22:36:32 <halogenandtoast> or an `IO (Either Exception Double)` if you really cared about the Exception.
22:36:50 <spatial> fail is used in unit test to fail and pass the exception test
22:37:44 <Cale> MarcelineVQ: Sometimes if something external is catching exceptions and keeping quiet about it, something like that would be necessary
22:38:00 <Cale> But I agree -- usually that shouldn't be needed if you're just going to rethrow
22:42:49 <MarcelineVQ> Cale: I see. there's always some potential for something that can get in the way I guess :>
22:42:58 <spatial> I am just trying to print details at the exception site.
22:45:29 <Cale> spatial: Don't you already get details though? Is something eating the exception?
22:46:26 <spatial> readthevalue a (ReinforcementLearning.index newstate) The detail newstate
22:46:56 <Cale> ah, so you're printing more than just the exception
22:47:02 <Cale> fair enough
22:51:30 <spatial> Used to stack trace. Does Haskell work like that ?
22:52:45 <geekosaur> not easily, graph reductions are not calls
22:53:43 <Cale> Well, there are some "CallStack" things now which can be used to give you some idea of where things are taking place. The stack used by GHC isn't a call stack though, so it usually wouldn't be quite as useful at working out what was going on (I think it would be nice to have support for visualising the *actual* stack when something goes wrong too though.)
22:55:06 <Cale> You'd have to display bits of case expressions or other pattern matches that were waiting.
23:32:09 <halogenandtoast> spatial: btw, that case on Bool, is there a reason you didn't use if?
23:33:28 <halogenandtoast> if result then ... else ...
23:35:32 <spatial> case seems to be more structured in this case because there are other if loops inside In fact if in this case should be replaced with 'when' and 'unless'
23:36:04 <spatial> Because I convert Lisp to Haskell. Lisp used 'when'
23:36:59 <cocreature> sorry for being pedantic but please don’t call if clauses if loops, there is nothing loopy about them :)
23:38:11 <halogenandtoast> spatial: Haskell has those.
23:38:21 <halogenandtoast> I believe in Control.Monad
23:38:22 <spatial> Yes
23:38:58 <halogenandtoast> I'm fine with nested if clauses though.
23:39:02 <halogenandtoast> but that's me.
23:39:29 <halogenandtoast> by fine with, what I really mean is that I would eventually extract the into another function
23:39:40 <halogenandtoast> small functions all day every day.
23:39:49 <cocreature> halogenandtoast++
