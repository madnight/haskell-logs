00:00:10 <_sras_> How can I make a stack package without a Main module?
00:00:33 <adarqui> ya you would specify that in your .cabal file
00:00:39 <adarqui> use Library instead of Executable
00:04:06 <_sras_> adarqui: There is no Executable section in my cabal file, only one Library section....
00:04:43 <adarqui> cool, so you don't need a main module in that case
00:04:48 <adarqui> you just specify your exposed-modules
00:05:13 <adarqui> anyone here using GHCJS on ghc 8.0.2??
00:06:04 <mniip> 4no
00:07:01 <_sras_> adarqui: But I get this error when calling stack build http://lpaste.net/353878
00:08:34 <adarqui> mniip: thanks. im going to use raw javascript.
00:09:13 <adarqui> _sras_: post your .cabal file
00:10:28 <mniip> good luck
00:10:51 <adarqui> im not a pro with colors, i just know bold. but yes, i imagine i'll have more luck using raw javascript
00:11:00 <adarqui> thnx
00:11:31 <_sras_> adarqui: http://lpaste.net/98610052524408832
00:12:27 <mniip> adarqui, did not mean to discourage you, just that I can hardly see colors being used in serious discussion
00:13:01 <adarqui> well i rarely get a response, in any haskell channel i'm in.. so in a last ditch effort, i bolded my question.
00:13:20 <adarqui> see it from my perspective: everything is always broken
00:13:32 <adarqui> and you hardly get any help
00:13:49 <adarqui> if i asked some noob question about the prelude, i'd get 1000 lines of discussion
00:13:54 <adarqui> all good though
00:16:10 <MarcelineVQ> _sras_: odd error, I've no ide why it would suggest that Main at the end, the error is clearly that you don't have a file called LICENSE
00:16:34 <sm> pretty nifty.. going to bold/underline my questions from now on
00:16:51 <MarcelineVQ> "Warning: The 'license-file' field refers to the file 'LICENSE' which does not exist."  "LICENSE: copyFile: does not exist (No such file or directory)"
00:17:07 <_sras_> MarcelineVQ: indeed!
00:17:09 <mniip> adarqui, the state of applied haskell needs a lot of work
00:18:34 <_sras_> MarcelineVQ:  It used to be a Warning usually!
00:20:08 <MarcelineVQ> it is a warning but it tried to copy the file while building which failed
00:22:55 <adarqui> mniip: ya
00:26:47 <MarcelineVQ> adarqui: my own adventures in having stack and ghcjs play nicely under manual setup haven't gone too well, so I tend to stick to the latest available here https://docs.haskellstack.org/en/stable/ghcjs/ when experimenting with stack+ghcjs    there's a repo here for making things yourself with whatever params you need https://github.com/tolysz/prepare-ghcjs
00:27:31 <adarqui> cool thanks MarcelineVQ .. ya i've tried both. i'm using ghc 8.0.2 and it just can't ghcjs boot, something always breaks
00:27:47 <cocreature> maybe ghcjs just doesn’t support 8.0.2 yet?
00:27:54 <adarqui> so was wondering if someone had any specific experience with 8.0.2 and lts 8.x
00:28:22 <adarqui> cocreature: dno, maybe
00:29:28 <adarqui> 8.0.1 is broken on my osx box so, 8.0.2 works. but i haven't developed my ghcjs app since 7.10.3 (which was building, but failing in the browser due to GHCJS bugs (most likely))
00:31:01 <MarcelineVQ> well now you've got me curious about this
00:32:31 <cocreature> https://github.com/tolysz/prepare-ghcjs/issues/6 seems relevant
00:34:49 <adarqui> ya thanks
00:42:44 <tsahyt> Hello. I've been looking at the Hoogle API and it seems that the 5.x versions are very incomplete. are they intended to be used already?
00:43:09 <tsahyt> I'm exploring the possibilities of writing a GUI haddock browser with type search enabled
00:54:07 <MarcelineVQ> tsahyt: it's quite nice to use http://hoogle.haskell.org/  I'm not quite sure what it means about the type-search not working though, something like  Monad m => m a -> (a -> m b) -> m b  returns exactly what you'd expect
00:54:35 <tsahyt> MarcelineVQ: that's a web frontend. I want to write a GTK frontend
00:55:00 <tsahyt> the problem is that the version >= 5 don't expose any functions to generate a database etc
01:00:25 <MarcelineVQ> hmm interesting, there's a couple options for that which come to mind, you could call up 'hoogle data' with System.Process  or  fork hoogle and expose the internals you need like src/Action/Generate.hs
01:01:24 <MarcelineVQ> I'd be more inclined to the latter if you're after tight integration
01:03:42 <tsahyt> I guess until I make a feature to browser documentation of non-published projects (e.g. for the current one), hoogle generate would be okay
01:04:28 <tsahyt> hoogle generate by default now indexes all of stackage as far as I can see
01:04:30 <cocreature> tsahyt: iirc stack hoogle does that do it might be possible already
01:04:31 <tsahyt> which covers almost anything I use
01:04:59 <tsahyt> cocreature: as long as I can get an URL out of it, it'd be usable for my purposes
01:05:54 <tsahyt> although the query completion feature in 4.2.x looks very interesting too
01:06:23 <cocreature> development of 4.x is dead so I wouldn’t start building software on top of it
01:09:54 <tsahyt> after playing around with a pre-generated database I think I can make this work for now
01:10:25 <tsahyt> I want a relatively simplistic gtk interface. a search bar, results in one column with possibly some brief description, full docs in a webkit view in the second column
01:10:55 <tsahyt> something that is easy enough to use on a touchscreen too, so I can prop up my laptop next to my workstation and flip through docs on a second screen.
01:11:59 <tsahyt> from there I could add the option to store offline copies of docs, and so on
01:17:19 <tsahyt> most importantly though, this all gives me a good excuse to finally make something with gi-gtk and FRP. I've been meaning to do that for a while.
01:46:49 <miniBill> is there a nicer/more readable way of writing "ect >>= \ct -> join <$> mapM next ct" ect is of type (Either String (t a)), next is of type (a -> Either String (t b)), and t is a Traversable and Monad
01:49:00 <ezyang> :t forM 
01:49:02 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
01:51:42 <miniBill> ezyang: forM is flip mapM, I fail to see how this helps me?
01:51:51 <riaqn> I give up on compiling GHC core to my virtual machine.
01:52:23 <riaqn> it seems CoreSyn is only for internal use, and not even have Show instance. which makes me analysising harder.
01:52:48 <riaqn> There was a project called "external Core", but was out-of-sync with GHC for 2 years and finally abandoned.
01:54:09 <ezyang> miniBill: I guess you kind of wnat the EitherT monad transformer 
01:54:31 <ezyang> then bind will do the right thing 
01:54:57 <ezyang> riaqn: The AST is pretty simple though! 
01:59:37 <riaqn> Ez
01:59:41 <miniBill> ezyang: uhm, but isn't EitherT String m a equivalent to m (Either String a) rather than Either String (m a) ?
02:00:50 <riaqn> ezyang: you must be kiding.. for the last hour I added dozens of dumb Show instance only to (show Expr).
02:01:00 <ezyang> oops, yes, I guess you want the other way 
02:01:19 <riaqn> What a backend's author wants is just untyped lambda calculus...
02:01:47 <ezyang> riaqn: Why don't you use STG then? 
02:01:59 <JuanDaugherty> or try #lisp
02:02:18 <riaqn> JuanDaugherty:  exactly! that's what I plan to turn to.
02:02:21 <miniBill> ezyang: so I should write and instance for Transforem for my t?
02:02:31 <riaqn> ezyang:  AFAIK, STG has explicit stack?
02:02:58 <ezyang> miniBill: Well, actually, I guess you can't necessarily do the composition the other way 
02:03:01 <riaqn> while my machine is really pure lambda reduction.
02:03:02 <ezyang> riaqn: Uh... no? 
02:03:11 <riaqn> ezyang:  OK let me check.
02:04:52 <riaqn> ezyang:  a short glimpse tells me that, STG is just Core lower-level, closer to machine.
02:05:36 <ezyang> and importantly untyped 
02:06:25 <riaqn> yes that's a good thing. I wish things unrelated to backends striped as much as possible.
02:07:03 <riaqn> but I worry that the STG data type is still too complex to handle, and more, many GHC's internal references.
02:07:27 <riaqn> that's uninteresting to me, and potentially hide something that might break my compiler.
02:08:21 <riaqn> as much as I hate dynamic typing, for now I guess I have to try..
02:09:25 <riaqn> ezyang: BTW, late congratulations on the PhD defense!
02:10:28 <ezyang> thanks! 
02:10:58 <ezyang> riaqn: So, what are you /really/ trying to do? 
02:11:11 <ezyang> i.e. is this just for fun/learning or do you actually need to get something done? 
02:11:21 <riaqn> ezyang: so I have a untyped lambda reduction machine, and hope to run haskell on it.
02:11:40 <riaqn> ahh, it's my undergraduate thesis, but it's also fun I think..
02:11:50 <riaqn> the machine is running on fpga.
02:12:19 <ezyang> what kind of primitive operations does it support 
02:13:34 <riaqn> communication to outside-world is based on 24bit(or so) integers. The IO is event based.
02:15:02 <riaqn> say there is a buttom on the FPGA, then the program can read the REQ port of that port to check if the bottom's status as changed, read the status of that bottom, and write 1 to ACK port to acknowledge the events.
02:15:22 <ezyang> I get the feeling that this isn't going to work. Surely your hardware is not implementing a lazy evaluation model, is it? 
02:16:17 <riaqn> ahh, something wrong? it's lazy. But yeah, I feel some stricty is needed to avoid some pitfall related to IO.
02:16:34 <riaqn> as the primitive operations is not pure.
02:17:46 <riaqn> The hardware implementation is not hard; the hard part is how to compile pure languages to it while preserving semantics.
02:18:19 <ezyang> riaqn: So, have you implemented the translator from a dog simple lambda calculus to this arch? 
02:18:29 <ezyang> i.e., the one you'd write in a lambda calculus tutorial 
02:19:35 <riaqn> ezyang: this arch IS lambda calculus.. I would say compile scheme to it requires very very little work.
02:20:14 <riaqn> the bytecode(or ISA if you will) IS lambda calculus..
02:20:17 <ezyang> ok, well, start with a lambda calculus (identity transform) and then start adding features to it 
02:20:48 <ezyang> can you add natural numbers? 
02:22:44 <riaqn> ezyang:  yeah that's also waht I'm thinking. start with untyped LC and add typing, polymorphism gradually.
02:23:50 <riaqn> ezyang: already has. there is church numbers(of course) and machine integer(24bit)
02:24:03 <riaqn> I haven't write the verilog code, but have a haskell prototype that runs like a machine(every tail recursion change the argument represetning the states, etc).
02:24:09 <ezyang> but for most languages typing is not interesting because you just erase the types and you have the same redution semantics 
02:24:22 <ezyang> ok, how about strings? 
02:24:35 <ezyang> and/or heap allocated literals 
02:26:35 <riaqn> I'm not sure what you means by "heap"... as the machine has no memory other than heap..
02:26:57 <ezyang> how are you going to represent a constructor 
02:27:17 <ezyang> simple example: tuple. Church encode? 
02:27:26 <riaqn> by now just church encoding..I'm not sure if there's any pitfalls.
02:28:00 <riaqn> say, weak-head normal form..
02:29:08 <ezyang> OK, well, if you still want to use Core, I suggest writing a translator that works with a very small subset of it, and then start adding features 
02:29:20 <ezyang> much in the same way you would start with a trivial lisp, and then start adding extra things 
02:31:07 <riaqn> ezyang: well I'm still fighting with trivial things in Core..many hacks, don't know if it worth the time.
02:32:00 <merijn> Is there any value to using Core? I've thought about this, but afaik it's difficult-to-impossible to feed Core into GHC anyway
02:32:00 <riaqn> I think I will start with racket or something..
02:32:28 <riaqn> merijn:  yeah, but I'm trying to grab Core out of GHC.
02:32:54 <merijn> Getting Core out is rather easier, although I don't think the output is very stable across versions?
02:33:00 <ezyang> the only benefit you get is getting to reuse the frontend 
02:33:23 <riaqn> merijn: that's the point.. Also I don't think it fully preserves the data.
02:33:52 <merijn> ezyang: Yeah, but the front-end is, to me, the least interesting bit ;)
02:33:56 <riaqn> ezyang:  which is a huge gain! consider the eco-system..
02:34:04 <merijn> ezyang: I care about not having to reinvent the optimisations :p
02:34:05 <ezyang> and if I were working with core, I'd use a core2core pass and the GHC API 
02:34:17 <ezyang> well, you'll get that too 
02:35:47 <int-e> riaqn: I actually had a prototype that translated core to lambda calculus... I made it a ghc plugin that just prints the result to stdout.
02:35:53 <merijn> ezyang: No, I mean in the sense of I'm going to work on a language, it's most likely not Haskell, so the GHC front-end doesn't help, but not having to reinvent an optimising back-end would be nice, but since it's not really possible to feed, e.g. Core into GHC that's not very helpful
02:36:14 <ezyang> ah 
02:36:51 <ezyang> well, if your source language is at all interesting you'll have to do some work to write a desugarer; gotta get the coercions 
02:37:11 <riaqn> merijn:  there was a project called "external Core", even this project only concerns "grab Core out of GHC", leaving out "feed core into GHC", because the authors said it's too damm hard.
02:37:30 <riaqn> int-e: can I have the link?
02:37:32 <merijn> ezyang: If I believed the kinda stuff I'm interested in doing would be some what easy to retrofit into GHC Haskell, I would just attempt to hack it into GHC directly.
02:37:54 <merijn> ezyang: But some of the semantics I'd want are sufficiently not-backwards compatible that I don't think that will happen
02:37:58 <riaqn> merijn:  here you go https://downloads.haskell.org/~ghc/6.12.3/docs/core.pdf
02:38:25 <merijn> riaqn: Right, but grabbing Core out of GHC is something I'm not interested in at all :)
02:38:41 <riaqn> yeah I understand that, just saying.
02:39:03 <ezyang> merijn: :^) 
02:39:08 <riaqn> merijn: hmm, but can't you just compile your cool language to haskell?
02:39:16 <riaqn> if you can..
02:39:25 <merijn> riaqn: Not in a straightforward way
02:39:32 <riaqn> OK, I can relate.
02:39:36 <merijn> So you'd just end up introducing overhead by mismatch between semantics
02:39:50 <merijn> Not to mention I care a lot about the language RTS interaction
02:39:59 <riaqn> yeah, seriously, there is not a FP backend framework. like LLVM for imperative languages.
02:40:04 <int-e> riaqn: yes, it's on github anyway: https://github.com/tromp/AIT/blob/master/BLC.hs ... I think it worked with ghc-7.10.2. And the code is quite ugly.
02:40:25 <merijn> ezyang: I think Haskell is basically the UNIX of programming languages. Good enough to undermine new efforts for a long while
02:40:46 <ezyang> ...is ML BSD then? 
02:40:58 <merijn> But having just enough obnoxious historical warts to be obnoxious
02:41:06 <riaqn> merijn:  terrific metaphor.
02:41:22 <riaqn> int-e: thanks.. no hacking is not ugly..
02:42:05 <riaqn> hmm, as I was saying, no backend framework for FP, like LLVM?
02:42:34 <merijn> There's a lot of tiny things in the RTS and language semantics that I find really annoying/ugly, but that can't be fixed without some significant breaks in backwards compatibility. And any new language will have a hard time competing with GHC's years of optimisation and ecosystem, so it will probably never take off
02:49:00 <int-e> oh how do I turn off the automatic typeable generation...
02:51:51 <merijn> int-e: I don't think you do?
02:52:04 <merijn> int-e: Why?
02:52:31 <ezyang> you can;t 
02:52:44 <ezyang> it goos up core output haha 
02:53:48 <int-e> merijn: Because my plugin gets confused by the generated code. I guess it needs to filter them out.
02:56:32 <int-e> merijn: It's of no practical consequence, I think. This hack assumes that all code is in a single module with no external references at all. But now there is a reference to a constructor called TyCon (perhaps others) and it gets confused.
03:04:15 <Phyx-> "feed, e.g. Core into GHC that's not  very helpful
03:04:17 <Phyx-> "
03:04:23 <Phyx-> can't you use the API for this?
03:08:32 <int-e> merijn: the new thing is that one gets external references even with NoImplicitPrelude and no explicit module imports.
03:10:35 <dmj`> Can anyone speak as to how cabal new-build and nix might interact with each other.
03:11:41 <int-e> riaqn: I added such a filter to my code now, perhaps that's also useful to you.
03:17:28 <tsahyt> has anyone here worked with gi-gtk and ListStore?
03:19:40 <mekeor> tsahyt: maybe just ask your question
03:20:42 <tsahyt> I'm looking for an example that actually works. the constructor takes a [GType] now for columns, and from the examples I can find it looks like this wasn't always the case. those examples just pass a list of some suitable datatype. but of course I get a type error when I try that
03:21:04 <tsahyt> and with some suitable datatype I mean a custom type for whatever record they want to hold there
03:21:17 <tsahyt> e.g. https://github.com/haskell-gi/gi-gtk-examples/blob/master/treelist/ListDemo.hs
03:22:11 <tsahyt> hmm no this examples actually doesn't seem to use gi-gtk to start with
03:22:55 <tsahyt> maybe it just hasn't been ported yet. anyway, the question remains. GType doesn't have any constructors exposed, so I'm at a loss here on how to construct a [GType] to describe my data columns
03:24:40 <tsahyt> hmm, gi-gtk-hs provides a nicer API for this. I think I can work from there
03:36:13 <_sras_> Is there a package that provides a safe version of Text.Printf? 
03:36:50 <merijn> A bunch, I think. But more crucially, do you need printf?
03:36:59 <merijn> _sras_: Or do you just want to format numbers?
03:37:37 <_sras_> merijn: No, not only numbers. Want to interpolate strings...
03:38:00 <merijn> I don't know what you mean by that?
03:38:38 <cocreature> _sras_: there are several libraries. "formatting" seems to be relatively popular. Cale’s category-printf is also cute but probably not used as much
03:38:55 <merijn> Numeric in base has a ton of stuff for formatting numbers
03:39:27 <cocreature> I think _sras_ is more looking for something like printf("%s…%s", a, b) rather than just formatting numbers
03:40:06 <_sras_> merijn: Have to do stuff like "Hello %s" name....
03:40:16 <_sras_> cocreature: Yes
03:40:22 <merijn> I tend to just "mconcat" a list of strings for that
03:40:43 <Cale> Yeah, I don't even use that library, even though it's actually kinda nice, it's a bit too cute for its own good.
03:40:43 <yushyin> some of the quasiquoters for text/strings maybe?
03:40:51 <merijn> mconcat ["Hello ", name, " ", "etc."]
03:41:16 <cocreature> usually I do that as well because I’m too lazy to figure out what the printf library du jour is
03:41:19 <merijn> Or if I want slightly more speed I use ShowS
03:41:23 <Cale> I also just concat stuff
03:41:43 <cocreature> but there is some advantage to being able to specify the format string separately. it often becomes easier to see how the final results look
03:41:52 <merijn> I've used ansi-wl-pprint for pretty coloured output, but that's basically just concat with a bunch of annotation
03:42:21 <merijn> Now I'm just repeatedly pinging quchen here until he finally releases his stuff ;)
03:45:09 <_sras_> I usually do Text.concat if I don't have to do it too often...
03:45:40 <_sras_> yushyin: Do you know a good one. I am looking at the formatting package right now....
03:46:18 <cocreature> iirc formatting uses some underlying C library which caused problem on windows. not sure if that’s still the case
03:46:44 <yushyin> yeah the formatting package looks nice but never tried it so far.
03:47:34 <merijn> You all should go show some support for my proposal for containers! https://mail.haskell.org/pipermail/libraries/2017-March/027827.html
03:47:44 <merijn> And/or bikeshed names
03:49:20 <mbw> Hello everyone, I have a question about mtl. Specifically regarding its documentation, or rather lack thereof. If you look for example at https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html , you have a short overview, and some examples further down. That's cool. There's a similar format for ContT, and ReaderT. Alright so far. Now if you look at the pages for WriterT, there is no 
03:49:26 <mbw> information at all, only a link to one of the seminal papers. Most importantly, there is no warning whatsoever about space leaks which might occur when using even the strict version of writer. Did I misunderstand how people are supposed to look up documentation on a fundamental level?
03:49:30 <Cale> merijn: In fact, practically all of our Maps in projects at Obsidian are newtyped in that way already.
03:49:48 <merijn> Cale: I know, I've never wanted the current Monoid
03:49:51 <cocreature> merijn: just make a PR and convince dfeuer to merge it and save yourself annoying discussions on mailing lists :) 
03:49:57 <merijn> Cale: But i think that ship has sailed
03:50:19 <Cale> merijn: We have a module Data.AppendMap that works exactly like Data.Map, and exports everything that Data.Map does, except has different instances.
03:50:55 <merijn> cocreature: I would rather have the current instances changed, but I don't think I'm going to win that fight against backwards compatability
03:51:18 <merijn> Fortunately coerce makes this kinda stuff a lot less cumbersome
03:51:23 <Cale> Yeah, it's a particularly difficult change, because stuff will still often compile
03:51:29 <Cale> and just work incorrectlyu
03:51:54 <merijn> But it seems like a rather uncontroversial change. I dunno why I (or anyone else) hasn't proposed it before
03:52:18 <cocreature> people are lazy
03:52:46 <_sras_> cocreature: Looking at formatting,  What is the point of writing `format ("Here comes a string: " % string % " and another " % string)` "Hello" "Hello again"? I could have used the "++" in the place of "%" and got the same result, right?
03:53:30 <cocreature> _sras_: no string is not a variable containing a string, it’s more like "%s"
03:53:33 <merijn> cocreature: Hence why I'm going through the effort of proposing it :p
03:53:38 <cocreature> _sras_: and it is then substituted by "Hello"
03:54:01 <Cale> Here's a modest proposal: new containers package, moves Data.Map to Map, has the right instances.
03:54:08 <merijn> Cale: I thought about proposing a new module like that, but in the end I figured simply using 'coerce' whenever I need the monoid is simpler
03:54:24 <merijn> Cale: Don't think that's going anywhere soon :p
03:54:52 <Cale> Yeah, the tough thing is that then you need to get everything *else* to support the new Map
03:55:04 <Cale> and probably bifurcate all other packages
03:55:06 <_sras_> cocreature: But the I still have to close and reopen quotes, which is what I am trying to avoid...
03:55:06 <Cale> lol
03:55:15 <Cale> That's assuming you even succeed
03:55:30 <cocreature> _sras_: then you need to use some library that relies on TH
03:55:41 <cocreature> or deal with the fact that it’s unsafe
03:55:55 <_sras_> cocreature: Yes. TH is fine. Do you have a suggestion?
03:57:04 <lpaste_> abel-abel pasted “Kinds and some type-foo” at http://lpaste.net/353883
03:57:59 <abel-abel> Hello. I am very confused by the instance definition. Why and How does it make Frank as an instance of Tofu?
03:58:20 <abel-abel> This example is from here: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#kinds-and-some-type-foo
03:58:24 <Boomerang> @package interpolatedstring-perl6 -- _sras_ this is pretty good when you have a lot of text
03:58:25 <lambdabot> http://hackage.haskell.org/package/interpolatedstring-perl6 -- _sras_ this is pretty good when you have a lot of text
03:59:01 <cocreature> _sras_: sry no. it hasn’t been sufficiently painful for me to look into TH-based solutions :)
03:59:09 <Cale> abel-abel: Well, what kind of argument does Tofu have?
03:59:37 <Cale> abel-abel: i.e. which kind does the type variable t have in that definition?
03:59:58 <Cale> We see the type signature: tofu :: j a -> t a j
04:00:00 <abel-abel> Cale: Tofu has a type parameter t. t's kind is * -> (* -> *) -> *
04:00:09 <Cale> right
04:00:28 <Cale> So, now what kind does Frank have?
04:00:28 <abel-abel> Cale: I can understand this.
04:00:45 <abel-abel> Cale: yeah, frank's kind is the same as t.
04:01:11 <brynedwardz> @package NeatInterpolation
04:01:11 <lambdabot> http://hackage.haskell.org/package/NeatInterpolation
04:01:12 <Cale> right, so at least the instance head is legal: we can write  instance Tofu Frank where
04:01:30 <brynedwardz> oh
04:01:36 <brynedwardz> @package neat-interpolation
04:01:36 <lambdabot> http://hackage.haskell.org/package/neat-interpolation
04:01:37 <Cale> and then we need to define a function  tofu :: j a -> Frank a j
04:01:58 <_sras_> cocreature: Why the hate for TH?
04:02:01 <Cale> Which as it happens, is exactly the type of Frank's data constructor
04:02:03 <brynedwardz> I like that one because it doesn't need haskell-src-exts
04:02:25 <Cale> (this is a pretty silly and contrived example... I don't know why the author went with it)
04:02:38 <geekosaur> _sras_, templating is a lot easier to deal with when it uses the same language (lisp, scheme, etc.) AST swizzling is a pain in the butt
04:03:26 <geekosaur> also TH splices are interpreted so it tends to slow the compile down a lot when used heavily
04:03:55 <cocreature> _sras_: I don’t hate it but it comes with it’s own set of problems most notably an increase in compile times and the fact that it doesn’t integrate very well with the tooling I use, e.g. hindent can’t indent some weird quasi quoted syntax
04:04:40 <abel-abel> Cale: you mean the type of Frank's data constructor is the same as the function's type?
04:04:54 <abel-abel> I mean the function tofu.
04:04:58 <Cale> abel-abel: Yeah
04:06:13 <abel-abel> I remember value constructor is a function. So here, we just assign Frank's value constructor to tofu function?
04:07:05 <Cale> Yeah, we define tofu to be Frank
04:11:31 <abel-abel> while, I didn't figure out the type of Frank's data constructor is the same as the function tofu's type. In fact, the `b` in Frank is like `j` in tofu; `Frank` is like `t` in tofu. Is that correct?
04:12:00 <Cale> right
04:12:11 <abel-abel> Cale: Thank you so much!!
04:12:52 <abel-abel> very helpful to me.
04:23:30 <kuribas> Is this considered bad style?  myFun x | isNothing y = 0 | otherwise = z+2 where y = myFun2 x; Just z = y
04:24:30 <ogrady> So I have an AST for a language which consists of Statements, Expressions and other custom structures Foo. The Expressions are nested inside the Statements or Foos. I'd now like to manipulate the expressions - but without ever handling any of the outer Statements or Foos. Is that hard to achieve?
04:24:41 <kuribas> I find it convenient not to have to nest many case expressions, however the irrefutable matches can crash at runtime.
04:25:46 <kuribas> In this function case would be cleaner, but I have sometimes many nested case expressions.
04:26:14 <kuribas> ogrady: use lenses?
04:26:39 <hpc> kuribas: case (a, b) of ...?
04:26:41 <ogrady> kuribas: never heard of them. Will look into, thanks!
04:27:04 <lyxia> | Just z <- myFun2 x = z + 2 | otherwise = 0
04:27:22 <kuribas> ogrady: https://hackage.haskell.org/package/lens-tutorial-1.0.2/docs/Control-Lens-Tutorial.html
04:27:59 <kuribas> lyxia: but suppose I have a long list of veriables depending on z in the where statement.
04:29:10 <cocreature> kuribas: use let instead of where?
04:29:24 <kuribas> like here http://lpaste.net/353885
04:30:18 <lyxia> ^.^ this code looks so happy
04:30:42 <kuribas> that's dot product :)
04:35:35 <lyxia> you can define an auxiliary function that takes q3', chop_min, chop_max as arguments and continue after pattern matching there.
04:36:53 <lyxia> do-notation + let works as well
04:38:49 <kuribas> here is the alternative: http://lpaste.net/353885#a353886
04:39:26 <kuribas> lyxia: hm, that may work
04:39:50 <merijn> kuribas: You can use guards without isNothing
04:40:26 <kuribas> merijn: how?
04:40:30 <lpaste_> merijn annotated “No title” with “No title (annotation)” at http://lpaste.net/353885#a353887
04:40:42 <merijn> Like always, everyone forgets about pattern guards
04:41:21 <merijn> kuribas: Simply change "| isNothing mbQ3 =" in your guard to "| Nothing <- mbQ3 ="
04:41:33 <kuribas> merijn: yeah, but I still have the irrefutable pattern...
04:41:48 <kuribas>  Just (chop_tmin, chop_tmax) = chop_interval
04:42:28 <merijn> kuribas: Where is that used?
04:42:53 <kuribas> merijn: line 65
04:43:15 <merijn> kuribas: You can combine pattern guards with the boolean guard
04:43:35 <merijn> ugh
04:43:39 <merijn> lpaste is slow
04:44:07 <merijn> Slow is apparently an understatement
04:44:22 <merijn> Any other pastebins that don't suck?
04:45:07 <geekosaur> depends on how you define "suck". I often use dpaste.de as a fallback
04:45:17 <brynedwardz> There bpaste.net
04:45:20 <brynedwardz> There's*
04:46:56 <merijn> kuribas: Write something like: http://dpaste.de/dBYc
04:47:11 <merijn> kuribas: Then you don't even need the "isNothing chop_interval"
04:48:55 <kuribas> merijn: I cannot access chop_tmin in the where block.
04:49:07 <kuribas> merijn: So I still get a nested expression.
04:49:56 <merijn> So move everything in that where block inside that case
04:50:53 <kuribas> merijn: how's that different from my annotation?
04:51:17 <merijn> Write a function in the where block that returns a tuple containing all the tmin, new_tmin, whatever based on chop_tmin/chop_tmax, call that function in the guard, use the values directly?
04:59:46 <kuribas> I could abuse the continuation monad for a local exit.
05:00:04 <kuribas> like in C
05:12:15 <kuribas> merijn: I found the maybe monad solved the problem...
05:15:44 <ogrady> kuribas: Lenses look very promising. But the tutorial only mentions record datatypes. Mine are plain data structures. Is there a way to make Lenses work with them? It compiles just fine but I have no idea what I should then put as argument for "over".
05:16:18 <kuribas> ogrady: it is easier with record datatypes, but you can construct your own lenses.
05:16:46 <kuribas> ogrady: Do you know what a traversal is?
05:17:04 <ogrady> kuribas: Not in detail yet. I've seen it being mentioned in the tutorial though.
05:17:42 <kuribas> ogrady: do you know traverse?
05:17:46 <kuribas> :t traverse
05:17:47 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
05:18:47 <kuribas> ogrady: traverse is the general version of mapM
05:18:49 <kuribas> :t mapM
05:18:51 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
05:19:37 <ogrady> kuribas: I have not until now but skimming through the text looks like it could fit my problem.
05:20:17 <kuribas> ogrady: traverse performs an action on a part, and returns the whole as an action.
05:21:17 <kuribas> ogrady: a lens does the same
05:21:27 <kuribas> ogrady: but specialized for your structure.
05:21:29 <ogrady> kuribas: Alright, 
05:21:34 <ogrady> will look into it, thanks.
05:22:42 <kuribas> ogrady: so to create a lens, you need to extract the subpart, perform the action over it, then merge it with the whole.
05:27:58 <exio4> someone is asking me for books about introduction to functional programming as a concept
05:28:44 <exio4> which books would you recommend?
05:33:34 <brynedwardz> exio4: I learned Haskell using haskellbook.com book. It teaches functional programming concepts quite well.
05:34:55 <brynedwardz> Here's a free one https://www.gitbook.com/book/drboolean/mostly-adequate-guide/details . I haven't read it and so can't really comment.
05:35:08 <exio4> brynedwardz: I would like something which aims to be at least a bit language-agnostic 
05:35:08 <brynedwardz> I'm sure there are some people here who'd have better suggestions
05:35:19 <cocreature> exio4: maybe sicp?
05:35:23 <fProgrammer> quick Question: I've a hashmap of the form { "textKey" : [ "value", "value2"] }   I have to perform operation which requires me to append the value of "textKey" . Simple way is to lookup with "textKey" append the value, and re-Insert. What is the most efficient way to do it? 
05:36:21 <Axman6> what do you mean by 'to append the value of "textKey"'?
05:36:22 <cocreature> fProgrammer: use "update"
05:36:28 <cocreature> or "adjust"
05:36:43 <cocreature> (assuming we are talking about HashMap from unordered-containers)
05:36:48 <lep-delete> or insertWith
05:36:57 <exio4> cocreature: yeah, I am adding it
05:37:00 <exio4> anything extra?
05:37:11 <fProgrammer> Axman6: append the list, the new value of "textKey" will be ["value", "value2", "vlaue3"] 
05:37:31 <Axman6> yeah, then what cocreature said
05:37:59 <fProgrammer> Axman6: cocreature: Thanks!
06:00:50 <quchen> merijn: ;-)
06:01:16 <quchen> merijn: You can already use it by the way. I include it via git+stack in all my projects. :-)
06:01:58 <merijn> quchen: Yeah...I'm so curmudgeony I haven't looked at stack at all yet
06:02:05 <merijn> So I don't think that'd work for me :p
06:05:41 <cocreature> merijn: cabal new-build makes it a lot less annoying to depend on local projects than the add-source stuff :)
06:07:19 <merijn> cocreature: I never had problems with add-source, tbh
06:07:28 <merijn> I haven't looked at new-build yet either >.>
06:07:47 <merijn> I'm stubbornly on 7.10 with some cabal from around that time >.>
06:07:59 <cocreature> heh fair enough
06:08:51 <merijn> If it works, don't fuck with it ;)
06:09:34 <cocreature> if it works break it so you don’t get bored
06:12:57 <merijn> cocreature: I generate enough yak shaving by finding already broken things :p
06:28:08 <fizbin> How do I get access to stack traces in the ghci that I get when I say "cabal repl" ?
06:29:47 <lyxia> what stack traces
06:30:08 <fizbin> These ones: https://simonmar.github.io/posts/2016-02-12-Stack-traces-in-GHCi.html
06:30:47 <lyxia> have you looked in GHC.Stack
06:31:07 <fizbin> No, why would I look at accessing the stack programmatically?
06:31:29 <lyxia> Okay I don't understand what you're looking for then
06:31:38 <lyxia> What do you mean by "get access"
06:31:42 <lyxia> if not programmatically
06:31:55 <fizbin> I have code that (unexpectedly) hangs. I'd like to type that into the thing I get with "cabal repl", interrupt it with a Ctrl-C , and get a stack trace.
06:33:06 <fizbin> If I could get the ghci command line cabal uses when it invokes "cabal repl", I'd follow that blog post and append "-fexternal-interpreter -prof" to the command.
06:33:29 <fizbin> Or if there were some option to cabal to say "also pass these flags to ghci when starting the repl"
06:34:12 <lyxia> --ghc-options
06:35:51 <cocreature> if you run cabal with -v it should also show the command line it uses, but --ghc-options is the right thing to use here
06:35:59 <fizbin> Hrm.
06:36:12 <fizbin> This does not seem to actually give me stack traces.
06:40:06 <eugenez> Hello, friends! I need to write a few recursive functions, figured i'd use memoization akin to that in Python, where you have a dict with results, and either return value by key or calculate, append and return said key. I have serious troubled trying to implement that in haskell, since I take it i'd need to make a monad, right? (appending Data.Map with value being a side-effect?) Is there a 
06:40:13 <eugenez> better/standart way? I tried to find one with memoization in map or anythin on https://wiki.haskell.org/The_Fibonacci_sequence but failed as well
06:42:08 <geekosaur> there are some memoization packages on hackage
06:43:24 <eugenez> it's just for a codewars challenge, I need something simple 
06:43:33 <kuribas> eugenez: There are many options.  You can use lazyness for it, or a fold with a map.
06:43:48 <kuribas> It depends on the problem./
06:44:33 <geekosaur> the Fibonacci one relies on the fact that it's recursively defined in a way that lets you use tying-the-knot to get memoization. you can sometimes define things with a lazy map similarly. but what kuribas said; it will depend on the problem
06:46:24 <eugenez> Thank you friends!
07:16:37 <adelbertc> is FlexibleInstances what I want if I need to define an instance for say, Const, partially applied to a *concrete* type? e.g. http://lpaste.net/2870650862408040448
07:17:00 <adelbertc> and if so are there any caveats with using FlexibleInstances?
07:17:00 * shapr bends a flexible instance
07:18:00 <adelbertc> hm yeah it could violate coherence
07:18:04 <merijn> adelbertc: No real caveats to FlexibleInstances
07:18:33 <merijn> adelbertc: Well, one potential caveats
07:19:00 <merijn> adelbertc: That instance overlaps with "FileIO (Const a)", but whether you care about that is up to you to decide
07:19:07 <merijn> adelbertc: It's generally fine, though
07:19:12 <adelbertc> right
07:19:19 <adelbertc> seems sketchy in that context
07:19:22 <adelbertc> is there a better way to achieve this?
07:19:27 <adelbertc> or is FlexibleInstances basically the answer
07:19:46 <merijn> What's FileIO even supposed to do? :)
07:20:11 <adelbertc> its an EDSL in tagless final style
07:20:13 <adelbertc> MTL-esque
07:20:32 <merijn> adelbertc: Incidentally, since FileIO requires applicative I don't think this will work
07:20:50 <merijn> Since "instance Monoid m => Applicative (Const m)" exits
07:21:17 <adelbertc> right.....
07:21:19 <adelbertc> hm
07:22:19 <merijn> oh, well, I guess it does work, but then why not write either: "Monoid m => FileIO (Const m)" or "Applicative (Const m) => FileIO (Const m)"?
07:22:51 <merijn> In general this just seems the wrong abstraction?
07:24:20 <adelbertc> merijn: its increasingly seeming like that
07:24:29 <adelbertc> this is exactly the kind of discussion i was looking for :-)
07:24:35 <adelbertc> alright i'm going to stare at this some more
07:24:40 <adelbertc> thank you for your help :-)
07:25:54 <merijn> adelbertc: What are you actually trying to do? :)
07:26:21 <merijn> i.e., what's the goal of this EDSL?
07:27:34 <adelbertc> merijn: i want an Applicative-y EDSL where i can interpret it into IO, but also run analysis (via a Monoid lifted into Applicative) on it
07:35:17 <adelbertc> ok yeah im using the wrong tools to solve this
07:40:18 <fizbin> Can someone tell me why this program hangs? I can't figure out why my relatively straightforward tree to hold statistics seems to be hanging. https://gist.github.com/fizbin/4987735a07a7f47be358c0be70e1f148
07:48:18 <Mihai_> What does the symbol >>= mean ? 
07:48:30 <Ferdirand> it's the bind operator
07:48:46 <Wizek> Anyone has experience with RecursiveDo/defining MonadFix instances? Do you think it would be possible/simple/easy to define such an instance for Yesod's `Handler` monad?
07:48:47 <kuribas> :t (>>=)
07:48:48 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:48:52 <Mihai_> oh, as in monads
07:48:52 <Mihai_> ok
07:55:16 <lyxia> Wizek: this one? http://hackage.haskell.org/package/yesod-core-1.4.32/docs/Yesod-Core-Types.html#t:HandlerT
07:56:29 <lyxia> It's probably the same instance as ReaderT  http://hackage.haskell.org/package/transformers-0.5.4.0/docs/src/Control.Monad.Trans.Reader.html#line-187
07:56:30 <Wizek> lyxia, yes
07:59:45 <lyxia> fizbin: print the tree only up to some depth and see whether it looks correct
08:02:28 <robkennedy> How would you work with PDFs? Doesn't seem like our ecosystem supports it ATM 
08:03:12 <Cale> What work specifically? There are a lot of external tools you can use.
08:03:40 <robkennedy> Yeah, it's just text analysis. I could use this to learn ffi 
08:04:26 <robkennedy> Is there a higher ffi barrier to entry if I don't know C? 
08:04:51 <robkennedy> *high, not higher
08:04:59 <Cale> Well, you shouldn't need to know very much about C
08:05:21 <Cale> But some familiarity with concepts that C programmers would be familiar with, like pointers and memory management would be helpful
08:07:43 <Wizek> lyxia, Hmm. I tried if it is indeed so trivial: `mfix f = HandlerT $ \ r -> mfix $ \ a -> unHandlerT (f a) r` and even though it typechecked I seem to get a a hangup when I try to run some code with out-of-order bindings in an `mdo`.
08:08:04 <Wizek> in-order bindings work
08:09:07 <merijn> robkennedy: Depends on how much C you don't know ;)
08:09:11 <Wizek> lyxia, Does that look like 'the correct' definition to you? Is the hangup to be expected?
08:09:54 <Wizek> (I don't have much experience with `mdo`. I've heard of it and thought now could be a great opportunity for me to give it a try in a Yesod app)
08:12:36 <lyxia> the definition looks fine
08:15:08 <lyxia> What does your mdo code look like
08:15:48 <rodrigo> s
08:19:29 <mofasa> Is there any way to pass a specific file to `stack test course:doctests` ??
08:19:57 <mofasa> Like this, but through stack: doctest -isrc src/Course/Monad.hs
08:21:53 <brynedwardz> mofasa: Maybe `stack exec -- doctest -isrc src/Course/Monad.hs`
08:22:02 <lyxia> mofasa: --test-argiments="-isrc ..."
08:22:04 <Wizek> lyxia, Here is a small example https://gist.github.com/Wizek/5958e9c1cb2ccc6c500dd45aff641f04
08:22:10 <lyxia> mofasa: --test-arguments
08:22:33 <brynedwardz> lyxia's way seems more proper
08:24:24 <lyxia> Wizek: runDB $ findOne ...   is probably strict in adderEmail
08:25:36 <lyxia> Wizek: basically mfix/mdo is just a convenient way of constructing data with values that you don't quite have access to yet, but you are not allowed to make the control flow depend on that data, if that makes any sense.
08:27:30 <mofasa> lyxia: that still runs all the tests
08:29:07 <Wizek> lyxia, makes sense, while a bit disappointing
08:30:04 <Wizek> lyxia, I hoped I could just throw bindings in as a soup and the compiler would decide which order is the best to take :)
08:30:31 <lyxia> mofasa: I guess that does nothing if your main is simply main = doctest [...]  with a fixed list of arguments.
08:31:22 <lyxia> Wizek: I think that wouldn't need mfix, if it were possible.
08:45:39 <phz_> hi; I’m trying to run tests with stack but it seems it just builds them
08:51:43 <gargawel> (Probably) stupid question: what is the functor instance used by fmap in, e.g., fmap id read ? 
08:51:54 <gargawel> (Granted, that's not something you'd like to do, just wondering)
08:52:01 <brynedwardz> :t read
08:52:02 <merijn> :t read
08:52:03 <lambdabot> Read a => String -> a
08:52:04 <lambdabot> Read a => String -> a
08:52:21 <merijn> gargawel: 'Functor ((->) String)' :)
08:52:34 <merijn> Or, more specifically "Functor ((->) a)"
08:52:34 <mauke> (e ->)
08:52:34 <gargawel> merijn: Oh, right. Thanks :)
08:52:54 <merijn> :t fmap even
08:52:55 <lambdabot> (Integral a, Functor f) => f a -> f Bool
08:53:06 <merijn> :t fmap even `asAppliedTo` read
08:53:08 <lambdabot> (Read a, Integral a) => (String -> a) -> String -> Bool
08:54:23 <gargawel> Don't know why I was confused
08:55:19 <brynedwardz> phz_: Are you using the default stack template?
08:55:34 <phz_> brynedwardz: no
08:56:02 <Sornaensis> :t asAppliedTo
08:56:03 <lambdabot> (a -> b) -> a -> a -> b
08:59:10 <QRealm> http://lpaste.net/353893 Hey guys, is there anyway to write the last line of this snippet without parens? I've been trying a bunch of combinations of (.) and ($) but nothing's worked out lol
09:00:24 <lyxia> QRealm: return $ words2sample . words <$> lines content
09:00:26 <glguy> words2Sample . words <$> lines <$> readFile s
09:00:38 <glguy> words2Sample . words . lines <$> readFile s
09:00:45 <glguy> err, almost
09:01:34 <QRealm> so the <$> replaces the map call yes?
09:03:14 <lyxia> one of them does
09:09:45 <fizbin> lyxia: That suggestion (to print the first several top levels of the tree) eventually helped me find my error. Thanks
09:12:29 <phz_> is there a known abstraction to have short-circuiting fold in a way that I get a tuple (b, [f]) as result?
09:12:32 <phz_> like
09:13:00 <phz_> oh I guess it’s some kind of unfold?
09:13:01 <mpickering> What techniques do people use to generate API bindings? Do you literally write a program which downloads the specification and uses HSE or something to print out the right source code?
09:14:23 <thoughtpolice> mpickering: IME you don't even need HSE depending on what you're doing. But yes, it's usually something like that - amazonka, gogol, and 'gl' all do something of this variety.
09:15:16 <tsahyt> has anyone here used the webkitgtk webview widget? I want to go to a certain anchor in a page directly. e.g. example.com/#anchor. instead it loads example.com. It works just fine for links.
09:15:20 <thoughtpolice> amazonka and gogol in particular are massive and almost entirely generated, from my understanding, with some by-hand tweaking. It seems to work pretty well.
09:16:38 <merijn> What's the flag to allow scientific notation for integers?
09:17:14 <glguy> NumDecimals extension
09:17:30 <merijn> thanks
09:18:49 <mpickering> thanks thoughtpolice
09:19:34 <thoughtpolice> mpickering: Is this for Phab?
09:19:39 <mpickering> yes
10:00:12 <tsahyt> is there a way to generate a hoogle (5) database directly against a stackage snapshot?
10:01:33 <hs428> tsahyt: I think `stack hoogle` is what you want (https://github.com/commercialhaskell/stack/issues/55)
10:02:21 <tsahyt> is that for hoogling in the current project? What I need is a hoogle database that contains URLs of exact versions of packages, rather than against the general hackage page
10:03:02 <tsahyt> e.g. "https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString.html#v:map" rather than "https://hackage.haskell.org/package/bytestring/docs/Data-ByteString.html#v:map"
10:03:08 <tsahyt> stackage snapshots are just one way to get that
10:14:40 <_sras_> Is there an easy way to run the application after a stack build command?
10:15:02 <thoughtpolice> stack exec -- name-of-exe <args>
10:15:17 <tsahyt> shouldn't the -- go after name-of-exe?
10:16:41 <_sras_> thoughtpolice: The problem is that often I don't know the name of exe!
10:17:28 <Tritlo> run (pure 1 2)
10:17:37 <Tritlo> lambdabot: run (pure 1 2)
10:19:15 <Sornaensis> is bottom a member of a void datatype
10:19:29 <JavaSucksMan_> I'm a haskell noob... is there any reason to use cabal, or should I just learn stack?
10:20:25 <isd> (I actually have the opposite question -- I'm still not clear on what problems stack is trying to solve)
10:21:49 <thoughtpolice> tsahyt: No, because 'stack exec' has to have its arguments separated from the executable's (.e.g 'stack exec foo --bar' is somewhat ambiguous as to whether it applies to 'stack', 'exec' or 'foo')
10:22:09 <tsahyt> thoughtpolice: but the name of the executable *is* an argument to stack
10:22:11 <thoughtpolice> _sras_: Uhhh, I don't know about that, then? Look in .stack-work and find the name? Why wouldn't you know it ahead of time?
10:22:19 <isd> JavaSucksMan_: I believe stack builds on top of cabal, so it's not an either/or thing.
10:22:28 <tsahyt> hence stack exec myexe -- <arguments to my exe>
10:22:36 <tsahyt> worked perfectly fine for me all this time
10:23:56 <thoughtpolice> tsahyt: The '--' means "Do not interpret any further --flags as going to stack", so it doesn't matter where you mention it, really. It's only to fix that ambiguity. But the -- separates it cleanly in any case.
10:24:46 <thoughtpolice> So you can use either. I suppose both cases are equivalent unless your executable started with a hypen or + or something ambiguous (which is legit in unix but probably extremely unlikely)
10:26:31 <significance> Hey all!
10:26:35 <mmachenry> Hey!
10:26:37 <_sras_> thoughtpolice: I often does not know what 'exactly' it is...unless I look it up in the .cabal file, right?
10:27:07 <_sras_> even then there is some suffix involved..
10:27:32 <thoughtpolice> _sras_: Yes, you'll need to look in the .cabal file for the name of the executable, specifically the 'executable <name>' stanza. (In theory you should just be able to grep for this over every .cabal file)
10:28:03 <thoughtpolice> something like, `find . -type f -iname '*.cabal' | xargs grep "$executable "` or something
10:28:30 <mmachenry> I want to make changes to a particular record in an imperative context. So I made a chain of monad transformers to model the effects I want. I now want to add nondeterminism, with ListT but I'm getting really confused. Anyone know what's going on? http://lpaste.net/353896
10:28:31 <significance> If I'm implementing, say, [] as a functor, is it possible to have different implementations based on the type of the contents? i.e. give [Int] and [Char] different fmaps?
10:28:55 <thoughtpolice> _sras_: In general you should just be able to use the name, but you may need to disambiguate if two packages have the exact same executable name. I'm actually not sure how to do that with stack.
10:29:07 <thoughtpolice> There shouldn't be any necessary suffixes; even on Windows you don't need to mention .exe
10:29:16 <S11001001> significance: no, it's not possible
10:29:19 <mmachenry> Basically I'm trying to take an input game state, and crawl through branching possibilities of outcomes for the next state in a random context with log output of what happened.
10:29:24 <significance> S11001001: thanks!
10:30:00 <_sras_> thoughtpolice: I was under the impression the executable's name came from the `name` key  in the cabal file + '-exe'...
10:31:01 <isd> Is there a concrete description of what the problems with cabal are that stack was intended to solve? All I've found is "people found cabal frustrating, so we made another thing!"
10:31:02 <Cale> significance: A consequence of that is that you only need to check that fmap id = id, and fmap (f . g) = fmap f . fmap g is then implied by parametricity.
10:31:23 <thoughtpolice> _sras_: No, the executable name is always determined by the 'executable' stanza. A single cabal package could have multiple executables, after all, so that would not work, unless you used the name in the stanza as part of the name of the .exe
10:31:49 <Phyx-> isd: stack still uses cabal afaik, I guess you mean cabal install
10:31:56 <significance> Cale: ahh, that's awesome! How is the latter term implied by parametricity though?
10:32:34 <hvr> isd: here's a description of problems: https://www.well-typed.com/blog/2015/01/how-we-might-abolish-cabal-hell-part-2/
10:32:43 <Solar123> Hi
10:33:44 <hvr> isd: the problem was rather that fpcomplete didn't want to contribute to cabal (for reasons they state on their blog), and rather invent their own thing
10:33:51 <Cale> There's a paper about it called "Theorems for free!" by Phil Wadler.
10:33:57 <shapr> but the paper costs money
10:34:02 <shapr> ok ok, I'm joking
10:34:05 <significance> hahahaha
10:34:09 <significance> Cale: thanks!!
10:34:10 <Cale> https://people.mpi-sws.org/~dreyer/tor/papers/wadler.pdf
10:34:11 <isd> hvr: thanks for the link.
10:34:24 <Cale> @free map
10:34:26 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
10:34:33 <shapr> Solar123: hi! enjoying the sunlight of Haskell?
10:35:15 <Solar123> Yeah... Thanks😊
10:35:28 <shapr> Solar123: written any cool code? have some questions?
10:36:01 <Solar123> Umm.. Are u know the other active channel?
10:36:25 <hvr> isd: for completeness, here's the blogpost going into the details why they didn't contribute to cabal: https://www.fpcomplete.com/blog/2015/06/why-is-stack-not-cabal -- however, given http://cabal.readthedocs.io/en/latest/nix-local-build-overview.html it's rationale doesn't hold up that well anymore
10:36:26 <shapr> I think this is the most active channel for Haskell programming.
10:36:28 <Cale> significance: It's possible to mechanically compute a free theorem for a polymorphic type, which the @free command in lambdabot does.
10:37:02 <significance> Cale: whoa. That's incredible -- I'll have to do some wikipedia digging
10:37:09 <Solar123> Oh.. I see
10:37:28 <Solar123> Im noob of irc. Lol
10:37:30 <Cale> significance: It all breaks down if you allow polymorphic functions to act differently at different types though.
10:38:11 <significance> Cale: that's so cool! Does Haskell provide any way to write polymorphic functions which act differently based on type?
10:38:24 <Cale> Well, that's basically what type classes give you
10:38:29 <thoughtpolice> Cale: Object.toString is the greatest method of all time.
10:39:06 <Cale> Only in the case of fmap...
10:39:08 <Cale> :t fmap
10:39:10 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:39:34 <Cale> Only the f type variable is constrained by a type class, so we still get parametricity for a and b
10:39:48 <significance> Cale: but we can't do it in the case of the parameter to a type constructor that implements functor, right?
10:39:50 <tsahyt> what would I need to delete to purge all the accumulated stack snapshots on my system?
10:39:57 <tsahyt> just ~/.stack?
10:40:16 <Solar123> Hi Cale
10:40:32 <Cale> significance: Well, you can't change how fmap works for different choices of the type 'a' or 'b' in the above.
10:41:03 <Cale> significance: however, if you have an additional type parameter which is effectively part of the 'f', then you might decide to write separate instances
10:41:32 <significance> Cale: ahh, gotcha -- and that would preserve parametricity within each instance, right?
10:41:37 <Cale> yeah
10:41:43 <significance> sweet! this is so cool!
10:42:00 <Cale> (That's still uncommon in practice though -- usually if there's going to be a Functor instance, it's nearly always unique)
10:42:50 <significance> Cale: awesome -- thanks so much! I'm pushing through LYAH rn, any suggested reads afterward?
10:43:36 <Cale> Depends on what sorts of programs you want to write, but Simon Marlow's book on concurrency and parallelism in Haskell is really good.
10:44:24 <Solar123> Hi ikke
10:44:26 <significance> Cale: awesome -- I'll give that a read. For practice, is there any good set of exercises online to get started?
10:45:19 <Cale> With respect to Haskell specifically, I'm not sure.
10:45:39 <Cale> It was quite a long time ago when I was first learning now :)
10:45:50 <significance> Haha -- well thank you for your time! That's a huge help :)
10:46:11 <Cale> Feel free to continue asking questions as they come up :)
10:46:13 <Sornaensis> Cale: does the void datatype contain bottom
10:46:16 <Sornaensis> does that even make sense
10:46:32 <Cale> Yes
10:46:48 <Cale> It's unavoidable in Haskell, since we have general recursion
10:47:03 <Cale> So you can still write  fix id :: Void
10:47:09 <Sornaensis> general recursion = a function can reference itself?
10:47:14 <Cale> yeah
10:47:14 <Sornaensis> :t absurd
10:47:16 <lambdabot> Void -> a
10:47:19 <Sornaensis> lol
10:47:21 <Cale> :t fix id
10:47:23 <lambdabot> a
10:47:35 <Sornaensis> cool
10:47:35 <Cale> :t error "Or there's this..."
10:47:37 <lambdabot> a
10:47:43 <Sornaensis> what is the purpose of Data.Void
10:47:45 <Sornaensis> other than being spooky
10:48:14 <Cale> Sometimes you want to indicate that you don't believe there ought to be something there.
10:48:39 <significance> What is the "natural map" $map?
10:50:12 <int-index> I need to put `forall m . MonadReader r (trans m)` into my instance context. What's the best workaround? Could pass a Dict, but it's boxed so imposes a performance penalty
10:51:15 <Cale> significance: Well, it's just map itself, though when @free reports the theorem, it's important to realise that it was treating map as an arbitrary function having type (a -> b) -> [a] -> [b], while when it says $map it *really* means the map function.
10:51:28 <Cale> Might be clearer if we asked it a bit differently:
10:51:35 <Cale> @free f :: (a -> b) -> [a] -> [b]
10:51:35 <lambdabot> h . k = p . g => $map h . f k = f p . $map g
10:51:59 <significance>  the => is implication, right?
10:51:59 <Cale> So, any function f having this type will have that property, with $map referring to the usual map function on lists.
10:52:01 <Cale> yeah
10:52:08 <significance> whoa -- awesome, thanks!
10:52:26 <Solar123> Hey Cale..
10:52:29 <significance> so @free gives you the free theorem for a type?
10:52:33 <Solar123> Can u answer me?
10:52:35 <Sornaensis> @free f :: a -> b
10:52:35 <lambdabot> h . f = f . g
10:52:44 <Sornaensis> @free f :: Just a -> a
10:52:44 <lambdabot> g . f = f . $map_Just g
10:52:44 <Cale> Solar123: Sorry...
10:53:05 <Cale> Solar123: Did you ask a question? I might've missed it
10:53:07 <Solar123> I have to ask some question
10:53:36 <significance> @free Int
10:53:36 <lambdabot> Try `free <ident>` or `free <ident> :: <type>`
10:53:43 <significance> @free f :: Int
10:53:43 <lambdabot> f = f
10:53:49 <Sornaensis> @free filter
10:53:50 <lambdabot> $map f . filter (g . f) = filter g . $map f
10:53:53 <Cale> significance: You probably meant Maybe a -> a there
10:54:11 <Sornaensis> @free f :: Maybe a -> a
10:54:11 <lambdabot> g . f = f . $map_Maybe g
10:54:32 <significance> Does @free give us any free theorem about <ident>?
10:54:48 <Cale> <ident>?
10:54:57 <Cale> @free id :: a -> a
10:54:57 <lambdabot> f . id = id . f
10:54:59 <significance> the parameter to @free?
10:55:02 <Cale> ah
10:55:15 <significance> @free id
10:55:16 <lambdabot> f . id = id . f
10:55:17 <Cale> If you just give it a name, it looks up the type of that thing, and then gets you the free theorem for that type
10:55:26 <Solar123> Hey. Are u know more active channel? Anyone?
10:55:26 <significance> Cale: is there always just one free theorem?
10:55:28 <Cale> yeah
10:55:41 <Cale> Solar123: What about?
10:55:45 <significance> Solar123: this seems pretty active to me :) how come?
10:55:45 <Sornaensis> @free f :: (b -> Maybe (a,b)) -> b -> [a]
10:55:46 <lambdabot> $map_Maybe ($map_Pair h g) . k = p . g => $map h . f k = f p . g
10:56:32 <Solar123> About anything
10:56:49 <significance> Solar123: #freenode is often pretty active
10:56:53 <significance> also, #programming
10:56:57 <Cale> Solar123: Most IRC clients have a way of listing channels and getting a count of members in them
10:57:49 <Solar123> I just want to know about tech channel
10:58:02 <Cale> Solar123: There are over 10000 IRC channels with at least 5 people in them.
10:58:25 <Cale> and 702 of them have 100 people or more
10:58:29 <Cale> On just this network
10:58:49 <Solar123> Yeah thanks, but can u tell me the one active channel?
10:58:56 <Cale> ...
10:59:07 <Cale> You'll have to pick a topic you'd like to talk about
10:59:17 <significance> Solar123: If you want general discussion, #freenode works
10:59:24 <Cale> Try #freenode given that you seem interested in talking about IRC itself
10:59:51 <Solar123> Yeah. That its 
10:59:55 <Solar123> Thank man
11:00:24 <lyxia> int-index: I think the Data.Constraint.Forall module is the best there is at the moment.
11:00:53 <Sornaensis> @free f :: a -> a
11:00:54 <lambdabot> g . f = f . g
11:01:12 <int-index> lyxia: it won't work, `m` isn't the last parameter here
11:01:22 <int-index> I'd need a sort of `Compose` but for constraints
11:01:27 <significance> Is it hard to derive g . f = f . g for a -> a as a free theorem?
11:01:44 <significance> Doesn't that mean that function application is commutative for a -> a?
11:01:58 <int-index> Then I could write `Forall (Compose (MonadWriter w) trans)`.
11:02:20 <significance> What if I have g x = 2 * x and f x = x + 1? Those (afaik) don't commute
11:02:32 <eschnett> int-index: you could create a new typeclass for the constraints, then use that typeclass
11:02:34 <lyxia> int-index: ForallF (MonadWriter w) trans ?
11:03:00 <int-index> lyxia: Thanks, ForallF seems to be what I want.
11:03:11 <significance> @free f :: [a] -> [a]
11:03:12 <lambdabot> $map g . f = f . $map g
11:05:00 <eschnett> significance: if your signature is a -> a, then you can’t multiply by 2, since the Num constraint is missing
11:05:23 <eschnett> significance: so the only function left is id :: a -> a, apart from undefined etc.
11:05:28 <significance> eschnett: ah, thank you
11:05:39 <significance> @free :: (Num a) => a -> a
11:05:39 <lambdabot> Try `free <ident>` or `free <ident> :: <type>`
11:06:37 <significance> Does Wadler's algorithm not work with type constraints?
11:07:58 <lyxia> @free f :: Num a => a -> a
11:07:58 <lambdabot> Extra stuff at end of line
11:08:10 <significance> huh
11:08:17 <lyxia> probably not
11:08:51 <lyxia> it becomes pretty tricky if you start assuming non-trivial structure about a.
11:09:20 <significance> lyxia: sweet! I'll probably have to dive through Wadler after LYAH :)
11:09:34 <lyxia> @free f :: a -> (a -> a -> a) -> a -> a
11:09:34 <lambdabot> (forall y. g . h y = k (g y) . g) => g . f x h = f (g x) k . g
11:10:06 <significance> when we write `instance Functor [] where...`, for instance, we're having a type constructor implement a typeclass, right?
11:10:47 <glguy> type constructors always implement type classes. Without special extensions instances are always for type constructors applied to zero or more type variables
11:11:20 <glguy> instance Show Int; instance Functor (Either e); etc.
11:11:34 <significance> glguy: ahh, so Int is a type constructor of zero variables
11:11:45 <glguy> being a type constructor doesn't have to do with kinds
11:11:50 <glguy> so basically yes
11:11:58 <significance> ahh, now I'm following -- thanks!
11:15:25 <nmdanny> Is it possible, with arrows, to pass the values inside a case expression pattern to other arrows?
11:17:04 <mmachenry> Anyone know how I should add lists to this monad transformer to model branching game states? I
11:17:15 <mmachenry> I'm having a lot of trouble figuring this out http://lpaste.net/353899
11:18:49 <mmachenry> Adding ListT to the outside of the transformer chain gives me type errors. Making it just a list [Effect ()] seems like an awkward thing to do since I want to be able to operate on a list of them naturally with the other operations.
11:20:07 <lyxia> nmdanny: with ArrowChoice you can do some pattern matching on values
11:20:31 <lyxia> it's much convenient than monads though
11:21:24 <nmdanny> Yes, but when pattern matching on a value, I can't refer to that body inside the match body
11:21:38 <shapr> I'm parsing tshark output and I can handle "call-id time_relative sip.method" but sometimes it gives me "call-id1,call-id2 time_relative sip.method1,sip.method2" Is there an easy way to restructure my megaparsec parser to handle that?
11:22:18 <geekosaur> depends. if you broke out the components into sub-parsers it's relatively easy to fix those subparsers
11:22:27 <geekosaur> if it's inline, probably not; you get to refactor
11:22:43 <lyxia> nmdanny: I don't understand.
11:22:57 <geekosaur> of course it's always nice when you know up front where you need to factor stuff out >.>
11:23:05 <significance> How are types and kinds different? Aren't kinds just types of type constructors?
11:23:23 <geekosaur> that's a complex question given ghc8's type system :)
11:23:24 <shapr> geekosaur: I guess I'd change my per-line parser to return a list of values...
11:23:25 <shapr> hmm
11:23:26 <int-index> significance: turn on -XTypeInType and your view of this issue fits
11:23:29 <geekosaur> (types and kinds got unified)
11:23:43 <significance> int-index, geekosaur - awesome -- thanks!
11:23:50 <shapr> Right now the parser is E <$> callid <* space <*> float <* space <*> method
11:24:27 <geekosaur> ok, so I'd change callid and method, which now return lists, and then let the compiler show me where types need to be updated elsewhere
11:24:56 <geekosaur> with foresight I might have made the result types ADTs so that part could be refactored once each
11:25:16 <geekosaur> (and now the compiler tells me where the actual uses need to be fixed to handle lists)
11:25:40 <shapr> ah, I see. Then I can just zip the list together with the single relative_time
11:25:52 <lpaste_> nmdanny pasted “what I'm trying to do with ArrowChoice” at http://lpaste.net/353900
11:26:01 <nmdanny> lyxia: this is what I'm trying to do ^
11:33:13 <lpaste_> lambdafan pasted “map lens problem” at http://lpaste.net/353901
11:34:42 <glguy> lambdafan: fmap snd
11:36:07 <lyxia> nmdanny: strange, but I'm not familiar enough with arrows to figure this one out :/
11:37:12 <nmdanny> I think the problem is that, values computed within an arrow may only be passed to the right of '-<'
11:38:16 <nmdanny> so basically I'd need the following arrow: (ArrowChoice a) => a (XmlTree,VehicleMeta) XmlTree,  then I could pass the value from the case expression into this arrow
11:39:27 <nmdanny> but then I have another issue: I can only pass 'VehicleMeta' to arrows that expect it.. and obviously HXT's arrows don't expect it
11:41:39 <lambdafan> glguy : the problem is an artifical one, the actual problem uses lenses, and '_2' is a stand-in for that.
11:42:02 <glguy> ok, fmap (view _2)
11:43:42 <lambdafan> glguy: thanks :)
11:43:46 <nmdanny> can the following function be defined:?
11:43:52 <nmdanny> Arrow a => a (input,extraData) output -> (extraData -> a input output)
11:46:19 <glguy> nmdanny a extraData = proc input -> a -< (input, extraData)
11:46:26 <glguy> nmdanny :: Arrow t2 => t2 (t1, t) t3 -> t -> t2 t1 t3
11:50:35 <nmdanny> and can the inverse function be defined?
11:50:37 <nmdanny> Arrow a => extra -> a input output -> a (input,extra) output
11:51:50 <glguy> ignoreExtra _ a = proc (input, _) -> a -< input
11:55:24 <nmdanny> sorry, I meant this function
11:55:26 <nmdanny>  Arrow a => (extra -> a input output) -> a (input,extra) output
11:55:49 <glguy> nope
12:08:33 <nmdanny> hurray I found out what I need, ArrowApply
12:09:29 <zcourts_> Using the GHC API, can a target be loaded from a String? i.e. I saw the Target constructor in the docs, constructed a target but when I try it, it fails with "module ‘Test.hs’ is a package module"
12:10:32 <geekosaur> I think that means "yes but..."
12:12:12 * geekosaur has seen that "is a package module" but doesn't recall what it denotes, aside from it's looking for the wrong droid :) 
12:12:13 <geekosaur> https://parenz.wordpress.com/2013/08/17/ghc-api-interpreted-compiled-and-package-modules/
12:13:34 <zcourts_> thanks, I'll give that a read and see if I can suss what's going on
12:13:45 <geekosaur> in short, it doesn't load anything, just sets an already loaded thing as the current target
12:13:59 <geekosaur> that page does say how to do the actual load
12:14:50 <zcourts_> ahh, name's a bit misleading but I get it
12:15:52 <geekosaur> it;s not misleading in its intended context (this is working at the level of a "make" program, not a compiler)
12:16:17 <fProgrammer> Quick question: I've my own data type "Node" with a generic implementation of ToJSON . I want to serialize  a hashmap  of type (Map Node (Set Node))  Whenever I try to do that I get a compile error:  No instance for (aeson-1.0.2.1:Data.Aeson.Types.ToJSON.ToJSONKey Node) arising from a use of ‘json'   Ideas?
12:16:38 <geekosaur> btu you do have to keep those levels straight when ghc conflates them (arguably this got worse when --make became the default mode)
12:18:15 <fProgrammer> anyone?
12:19:45 <djanatyn> (++) <$> (Yell "good afternoon ") <*> (Yell "fellow haskellers")
12:19:47 <djanatyn> >>> "GOOD AFTERNOON FELLOW HASKELLERS"
12:24:00 <zcourts_> geekosaur: you're right in that it isn't in that ctx. Read the post/code from the link - that's very helpful, thanks.
13:01:29 <adelbertc> is it possible to derive Monoid ? my google-fu does not seem to be able to turn anything up
13:01:41 <adelbertc> i currently have `data Foo = Foo { x :: Int, y :: Int }`
13:02:20 <adelbertc> i could do newtype deriving if i re-formulate it to `newtype Foo = Foo (Int, Int)` but wondering if there is a way to do it with the formulation i have above
13:06:54 <geekosaur> there is the question of what it would mean for such a type
13:07:29 <adelbertc> i would assume the behavior to be equivalent to tuple-ifying it and using the newtype equivalent
13:07:30 <geekosaur> the naïve approach would apply it to the first element, then the second --- but you would never actually reach the second because of how Int works
13:08:05 <adelbertc> ah ok
13:08:09 <adelbertc> i am convinced now
13:08:12 <geekosaur> newtype deriving just exposes the underlying thing, it doesn't get you a meaningful tuple instance
13:08:25 <geekosaur> and I don't know offhand if there's a tuple instance
13:08:30 <adelbertc> there is
13:08:35 <adelbertc> (Monoid a, Monoid b) => Monoid (a, b)
13:09:09 <bengt_> pls
13:09:19 <bengt_> mt
13:14:10 <ertes> adelbertc: you can use the generic-deriving library to derive product monoids
13:14:24 <ertes> adelbertc: but it requires that all factors are monoids by themselves
13:14:30 <adelbertc> ertes: is that a common thing to do in Haskell, or do people generally just write it by hand
13:14:32 <ertes> so you need something like Sum Int rather than just Int
13:14:33 <cocreature> is there any Monad for which traverse_ is more efficient than mapM_?
13:14:54 <ertes> adelbertc: i use generic-deriving for that purpose a lot…  can't speak for other people though
13:14:56 <cocreature> I feel slightly bad for using mapM_ but I’m also too lazy to type traverse_
13:15:13 <bennofs> cocreature: Writer (First a) perhaps?
13:15:42 <monochrom> I write by hand a  lot.
13:16:23 <cocreature> bennofs: how so? or do I need to work through the instances myself :)
13:17:20 <bennofs> cocreature: idk, i thought that perhaps the Writer can take advantage of the fact that First can short-circuit
13:17:28 <ertes> cocreature: traverse_ should really be in Prelude =)
13:17:28 <bennofs> (the Applicative one)
13:17:33 <ertes> along with for_
13:18:03 <cocreature> ertes: it would still be longer than mapM_ :)
13:18:17 <cocreature> bennofs: hm, interesting. I’ll take a look
13:18:31 <adelbertc> how sketchy is FlexibleInstances
13:18:39 <adelbertc> seems pretty sketchy in that it breaks type class coherence
13:18:41 <adelbertc> or has the potential to
13:21:01 <geekosaur> you still get warnings (errors if you don't specify overlap/incoherence) if you do that
13:21:35 <adelbertc> seems sketch
13:21:49 <cocreature> how so?
13:21:50 <fresheyeball> athan: why did you leave nixos for your workstation?
13:22:27 <geekosaur> also the Haskell2010 spec is much tighter than it needs to be for coherence, which is why the FlexibleInstances extension exists
13:23:06 <geekosaur> but this does not disable checking for incoherence, it just lets you build stuff in what would otherwise be in the gray area between what the standard permits and what is actually incoherent
13:24:12 <geekosaur> you would still need the IncoherentInstances extension to be actually incoherent, or use the OVERLAP / OVERLAPPABLE pragmas to specify when overlapping instances are permitted
13:24:59 <adelbertc> ah
13:24:59 <adelbertc> that makes me feel a bit better
13:26:29 <trxeste_> hello
13:26:38 <cocreature> hey trxeste_ 
13:26:49 <trxeste_> can somebody help me?
13:27:04 <cocreature> trxeste_: if you tell us what your problem is we might be able to :)
13:27:04 <geekosaur> depends; what's the question?
13:27:26 <trxeste_> i cant install cabal-install-1.24.0.2 under gentoo calculate-linux
13:27:35 <trxeste_> here is my log
13:27:37 <trxeste_> http://pastebin.com/ZRxMQB9K
13:28:15 <cocreature> trxeste_: that log does not even mention cabal
13:29:13 <trxeste_> it's a dependency of cabal-install
13:29:30 <trxeste_> i could'nt solve it
13:29:47 <cocreature> maybe I don’t know enough about gentoo but I don’t see any error in your log
13:29:54 <cocreature> what is failing?
13:32:28 <geekosaur> that's not actually a log, just a summary of the build environment. I'd suspect you need to talk to the maintainer of the gentoo port though
13:35:20 <trxeste_> simply can't solve this dependency
14:09:51 <erisco> hm
14:10:40 <erisco> I want to accumulate over each factor of [[a]] but short-circuit
14:11:13 <erisco> so, for example, [[1,2],[3,4]] the factors are [[1,3],[1,4],[2,3],[2,4]]
14:11:14 <monochrom> What is a factor?
14:11:26 <erisco> the n-ary Cartesian product
14:11:33 <c_wraith> err. sequence? 
14:11:58 <benzrf> what do you mean about short circuiting
14:12:01 <monochrom> Under what condition should short-ciruit happen?
14:12:12 <c_wraith> or do you want to skip pieces but resume later? 
14:12:37 <monochrom> > sequence [[1,2], [3,4]]
14:12:39 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
14:12:52 <erisco> right, so for example I will see the number 1 and I may decide I do not want to see any factors that include 1
14:13:09 <Sornaensis> :t sequence
14:13:10 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
14:13:17 <erisco> so I short circuit and do not further look through [1,3] and [1,4]
14:13:38 <erisco> in an n-ary product this can save a lot of redundant work
14:13:49 <c_wraith> erisco, have you looked at a bunch of posts from a couple years back about the SEND MORE MONEY problem? 
14:14:01 <erisco> I am aware of sequence, thanks :)
14:14:25 <erisco> c_wraith, no
14:14:29 <Cale> erisco: In that case, you don't *quite* want sequence, but you want something whose implementation looks a lot like it, except that it implements your condition as a guard.
14:14:31 <monochrom> Is it OK to pre-filter? I mean this: sequence (map (filter (/= 1)) [[1,2], [3,4]])
14:14:41 <erisco> I know I don't want sequence, that is why I am not using it ^.^
14:14:41 <c_wraith> erisco, https://www.schoolofhaskell.com/user/chowells79/even-more-money
14:14:54 <monochrom> > sequence (map (filter (/= 1)) [[1,2], [3,4]])
14:14:56 <lambdabot>  [[2,3],[2,4]]
14:15:01 <c_wraith> erisco, it links to a bunch of other posts on the topic. 
14:15:13 <Cale> > do x <- [1,2]; guard (even x); y <- [3,4]; return (x,y)
14:15:15 <lambdabot>  [(2,3),(2,4)]
14:15:20 <ertes> > [ (x, y) | x <- [1..5], even x, y <- [3,4] ]
14:15:22 <lambdabot>  [(2,3),(2,4),(4,3),(4,4)]
14:15:29 <erisco> monochrom, no, because I need an arbitrary prefix of the factor to determine if I want to keep going with it
14:15:36 <ertes> erisco: the list monad short-circuits
14:15:38 <ertes> by itself
14:15:53 <monochrom> Ah, then what they said.
14:16:17 <ertes> erisco: you just need to make sure that you place your guard as early as possible, i.e. the following would not short-circuit:
14:16:24 <ertes> > [ (x, y) | x <- [1..5], y <- [3,4], even x ]
14:16:26 <lambdabot>  [(2,3),(2,4),(4,3),(4,4)]
14:16:40 <Cale> Ah, but perhaps he wants cut
14:16:40 <ertes> same result, but needs to scan every possible pair
14:17:14 <Cale> i.e. he wants to go through some of the y's and arbitrarily decide at some point to skip the remainder of them
14:17:44 <ertes> ah
14:18:00 <erisco> I am accumulating over each factor, and at some point I may decide no factors with this prefix are interesting
14:18:19 <erisco> so short-circuit by not iterating through any more factors of that prefix
14:18:24 <ertes> > [ (x, y) | x <- [1..5], even x, y <- takeWhile even [2,4,6,7,8,9], mod (x + y) 3 /= 2 ]
14:18:26 <lambdabot>  [(2,2),(2,4),(4,2),(4,6)]
14:18:30 <ertes> something like that?
14:18:35 <Cale> There is probably a rather nice solution involving ContT
14:18:44 <erisco> I'll have to read over these suggestions carefully
14:19:04 <Cale> Well, perhaps you can get by with takeWhile, try that first :)
14:19:37 <ertes> of course takeWhile's predicate can refer to 'x' as well =)
14:20:19 <erisco> thanks for the suggestions, I'll get back to you
14:21:34 <merijn> Right, so we're now up to at least 7 reimplementations of my Monoid suggestion for Map. I wonder whoever came up with the current Monoid, as it's clearly not as popular as the sensible one
14:22:20 <merijn> I wish Haskell had a better story for fixing historical mistakes wrt typeclass implementations >.>
14:22:28 <ertes> merijn: instance (Monoid a, Ord k) => Monoid (Map k a)  -- i would kill for that instance
14:22:35 <merijn> ertes: Right, I know
14:22:51 <merijn> ertes: Everyone seems to be reimplementing it, but it's not in containers
14:22:59 <ertes> yes
14:23:03 <merijn> I don't think I've ever actually seen the current Monoid in use
14:23:20 <merijn> ertes: Well, hop on to libraries@ and help me beat some sense in to people :p
14:23:43 <ertes> merijn: does anyone actually disagree?
14:23:43 <merijn> Or I should somehow talk dfeuer into sneaking it in behind people's backs
14:24:02 <ertes> merijn: containers 0.6 is long overdue anyway =)
14:24:17 <merijn> ertes: Well, some people don't want to add a newtype for it (I've preemptively given up changing the current instance(
14:24:45 <merijn> Because that backwards compatibility thing is never happening given people's complaints about not breaking things that might never be used
14:25:01 <merijn> I wonder if there's a way to survey hackage and find all uses of the Map monoid...
14:25:06 <ertes> that's what we have the PVP for
14:25:13 <ertes> fix it, make it 0.6
14:25:20 <merijn> ertes: You try and convincing people of that
14:26:15 <ertes> personally i think just providing a pull request might be a better strategy than arguing on libraries@ =)
14:26:17 <merijn> I've tried that sorta thing a few times, some people are stubbornly against fixing anything that might, conceivably break code
14:26:25 <merijn> ertes: In hindsight, maybe
14:26:46 <ertes> in fact i'm not even subscribed there
14:26:54 <monochrom> Devil's advocate: The reason PVP does not solve this is that by version 0.7 you have both this semantic change and unrelated performance improvements. People who want just the unrelated performance improvements have nothing to fall back on.
14:27:25 <merijn> monochrom: We change the monoid instance and add a newtype for the current nonsense instance, problem solved!
14:27:30 <monochrom> This shows that PVP, by nature of being sequential, does not address the real contention at all. You need a branching versioning scheme, even a DAG.
14:27:37 <ertes> monochrom: the thesis is that nobody actually uses the current Monoid instance
14:27:42 <bollu> what's PVP?
14:27:47 <merijn> I've never seen it used, at least
14:27:57 <merijn> But I don't know how to survey hackage to be sure
14:28:16 <merijn> If someone is bored/has more time to waste then me, I would love numbers to back me up :p
14:28:21 <monochrom> Yes, I agree, this is why I put up that point as "devil's advocate". But do understand that the same kind of issues will genuinely arise for other libraries.
14:28:25 <bollu> there is a monoid instance for Map?
14:28:34 <merijn> bollu: Yes, left-biased union
14:28:38 <bollu> what is it, replace things that already exist and put stuff that doesn't?
14:28:39 <cocreature> bollu: https://pvp.haskell.org/
14:28:41 <bollu> wait, left biased?
14:28:43 <bollu> wtf
14:28:45 <ertes> monochrom: more seriously, if we do something like AMP and FTP, we can fix the Monoid instance of Map, too =)
14:28:46 <bollu> why not right?
14:28:59 <bollu> oh wait
14:29:02 <bollu> left may make sense
14:29:05 <bollu> hm, I'm not sure
14:29:06 <ertes> *if we can do
14:29:10 <bollu> a <> b <> c == a?
14:29:18 <merijn> yes
14:29:36 <monochrom> Haha yes, we already opened Pandora's box, may as well ramming speed.
14:29:44 <merijn> you could use dual to make it right biased :p
14:30:10 <ertes> merijn: i'm in favour of breaking changes, and i'll happily accept the maintenance cost of having to fix my code
14:30:20 <Cale> ertes: This change is worse though
14:30:31 <merijn> let's never make changes that make writing future code easier if it risks breaking already bitrotted code!
14:30:49 <Cale> In the regard that code written with the old Monoid instance will often still work after the change, but it will do different stuff
14:30:59 <Cale> So absolutely everything will need to be audited.
14:30:59 <ertes> true
14:31:22 <monochrom> You know what, s/Pandora's box/Paradise/
14:31:45 <monochrom> Heaven has come, why not fully embrace it!
14:32:16 <merijn> I wonder if I can get a student to audit hackage for uses of the Map monoids and patch all of them...
14:32:23 <merijn> maybe then people would accept it...
14:32:34 <ertes> well, here is a way to do it: add a DEPRECATED warning to the current Monoid instance and wait a year
14:32:44 <monochrom> (Looking at some of my old code, I think AMP is Heaven. I don't have a strong feeling about FTP yet.)
14:33:09 <ertes> monochrom: both are heaven for me
14:33:14 <ertes> > null Nothing
14:33:16 <lambdabot>  True
14:33:45 <merijn> I like FTP, but I don't like everything that was generalised into FTP
14:34:22 <merijn> i.e., I think length was a mistakes
14:34:31 <merijn> Although I've used it a few times
14:34:38 <monochrom> I know right? FTP is hardwired with Monoid, and you will dislike it iff you run into a Monoid instance you dislike... :)
14:34:55 <ertes> well, it's fine to generalise it, as long as you're aware that it might not be the best implementation for your particular type
14:41:04 <merijn> Actually, maybe I should make that my main goal of going into education...suckering students into fixing the stuff I can't be arsed too in the Haskell ecosystem, pretend it's educational and shit or something :p
14:41:20 <JavaSucksMan_> FTP?
14:41:44 <monochrom> the Foldable-Traversable Proposal.
14:42:00 <geekosaur> "foldable/traversable proposal" or why Data.List module now reexports Data.Foldable instead of being about lists
14:42:04 <monochrom> We need to drop the P because it is no longer a proposal, it is a reality.
14:42:11 <geekosaur> ^
14:42:17 <mauke> foldable-traversable problem
14:42:42 <monochrom> Foldable-Traversal Prosperity :)
14:42:57 <Theophane> \o/
14:43:18 <monochrom> But anyway the same thing happens to RFC.
14:43:53 <ertes> instance (Monoid a, Ord k) => Monoid (Map k a) where mappend xs ys = trace "mappend: BTW, I'm no longer the bullshit instance I used to be, so you may need to acknowledge my brilliance by fixing your code" (M.unionWith (<>) xs ys); …
14:43:54 <monochrom> And in Star Trek, NCC.
14:44:11 * Jello_Raptor facepalms
14:44:58 <Jello_Raptor> turns out replacing my O(N^3) placeholder algorithm with an O(n) algorithm means I use an order of magnitude less time and space. I just forgot about the placeholder after I had checked the other stuff for correctness. 
14:45:47 <Jello_Raptor> is there an idiom for this? like using WARNING or DEPRACATED pragmas as reminders of these things?
14:46:38 <srhb> Jello_Raptor: badGorithm = ...
14:47:16 <geekosaur> heh
14:48:01 * geekosaur is reminded of using a placeholder bubblesort in a tool he'd developed, intending to replace it later, and having it (a) be productized (b) still with the placeholder
14:48:12 <ertes> "badGorithm" sounds like: "bad practice borrowed from go"
14:48:12 <mauke> foo x = trace "FIXME" $ badImpl x
14:48:56 <geekosaur> (having run into what was later shown to be a bug in standard unix qsort())
14:49:22 <Jello_Raptor> yeah, this was basically the same thing, instead of keeping a reverse lookup table, I was just looking at every value in the table for things that fit a pattern and modifying them
14:50:31 <Jello_Raptor> mauke: this function is called an immense amount of times in each run. Adding a trace there would mean the syscalls to print dominate the runtime. (I had a trace in there for other reasons at one point) 
14:50:41 <ertes> protoduction at its best
14:51:13 <Jello_Raptor> ertes: best part is that it's still *correct* just slow as balls 
14:51:21 <mauke> Jello_Raptor: is that a problem?
14:52:14 <Jello_Raptor> mauke: when the memory use of the program make a server with 120gb of RAM thrash, yes. yes it is. 
14:52:29 <ertes> "AWS, what can i do for you?" – "i'd like to book more cloud resources, specifically CPU and RAM" – "sure, how much?" – "the rest"
14:52:39 <Jello_Raptor> hah
14:52:49 <jle`> Jello_Raptor, mauke: ghc already gives you a way to emit a compiler warning when you compile code using a certain function
14:52:59 <jle`> *code that uses a certain function / value
14:53:11 <jle`> best of both worlds i suppose
14:53:12 <monochrom> ertes: Somehow that sounds like what Dogbert might do. :)
14:53:42 <ertes> monochrom: sorry for ruining the joke, but who's that? =)
14:54:04 <merijn> ertes: Dilbert character
14:54:05 <monochrom> Dilbert's pet. But the pet dominates, and is evil.
14:54:12 <Jello_Raptor> jle`: mm? I was just asking if there's a standard otherwise I was just going to make a habit of using WARNING pragmas as particularly important TODOs that are hard to forget
14:54:22 <ertes> dilbert doesn't ring a bell either
14:54:27 <monochrom> or maybe just s/evil/likes to pull pranks on humanity/
14:54:35 <monochrom> OK, dilbert.com :)
14:54:50 <geekosaur> it's a comic inspired by the author's time at pacific bell
14:54:53 <ertes> ah =)
14:55:09 <geekosaur> pretty much every management dysfunction you can imagine
14:55:12 <geekosaur> and a few more on top
14:55:17 <Jello_Raptor> ertes: old "engineers in an office" comic, a classic, but I'd not rate it worth people's free time anymore v0v
14:56:05 <jle`> Jello_Raptor: oh i didn't notice your original question
14:56:22 <merijn> There are more original/funny comics, yes :p
14:56:27 <Jello_Raptor> jle`: no worries :) nobody answered it after all :P 
14:56:38 <jle`> WARNING/DEPRECATED seems like a good way to go
14:56:45 <jle`> but
14:56:49 <geekosaur> the early dilbert was original and funny. it degenerated later, plus all the clones...
14:56:57 <jle`> it doesn't emit the warning if you use it within the defining module
14:57:00 <geekosaur> (plus that we all know about it now)
14:57:28 <Jello_Raptor> jle`: ooh :/ that invalidates a lot of how i tend to organize things. 
14:57:31 <geekosaur> Jello_Raptor, to be honest, for this you probably want the gnu linker annotation stuff
14:57:41 <Jello_Raptor> geekosaur: mmm? 
14:57:43 <jle`> Jello_Raptor: maybe you can use CPP and have the function only be available if you pass a --dev flag
14:57:46 <geekosaur> (although that may not help on non-linux)
14:57:57 <jle`> and if there's no --def cpp flag then the function isn't defined and it doesn't compile
14:58:01 <jle`> (or just emits an error)
14:58:05 <geekosaur> you can annotate a function so that, if the linker finds it being referenced, it spits out a warning
14:58:07 <jle`> this is not standard so don't listen to me
14:58:38 <geekosaur> if you try to compile on linux a program that calls the old gets() stdio API, you'll see it in action warning you about buffer overflows and such inherent in it
14:58:49 <monochrom> If the function is inlined, you will not get a linker warning :)
14:59:20 <ertes> Jello_Raptor: yeah, i looked at a few…  they weren't funny =)
14:59:36 <geekosaur> well, for this you'd need (a) a C stub to which you can attach said annotation (b) an analog of trace (which is to say, unsafePerformIO) to attach it to the Haskell code
14:59:49 <ertes> i have no idea how xkcd manages to still be funny after so many years
15:00:30 <geekosaur> a big part of the problem with dilbert is scott adams just started using stuff readers sent him, without a lot of critical thought
15:01:06 <merijn> ertes: I think XKCD is much less funny these days then, say, SMBC which is both funnier and more consistently so
15:01:25 <jle`> every once in a while i forget it exists and then check up again and see that it's still consistent quality. (re: xkcd).  i'm sure its readership has gone down in the past few years, and the author has had various other large projects besides xkcd since them too, but it doesn't stop randall from his commitment to quality
15:01:37 <jle`> also i hear that randall hangs out here from time to time so hi
15:01:38 * jle` waves
15:02:06 <ertes> you know, we could come up with lambdacats that are actually funny
15:02:13 <geekosaur> that'd be nice
15:02:22 <jle`> smbc has only gotten better over the years yes
15:02:44 <ertes> the cartesian closed comic is quite good, too, but there aren't too many issues
15:03:16 <hpc> jle`: i know the site admin says things here sometimes
15:03:16 <ertes> one of my favourites: https://ro-che.info/ccc/23
15:03:18 <ertes> =)
15:03:25 <hpc> (the xkcd admin)
15:03:25 <jle`> yeah, being able to nail some inspired jokes is different from having the ability to consistently churn them out
15:03:37 <jle`> i think it's a completely different skillset/talent altogether
15:04:19 <jle`> hpc: yes i've heard that he has asked questions about implementing some haskell code for an xkcd comic, heh
15:05:21 <ertes> also i'm kinda fascinated that this one actually did become irrelevant: https://ro-che.info/ccc/21
15:05:41 <c_wraith> the backend for the comic where there were thousands of punchlines depending on a bunch of factors was done in Haskell. 
15:05:42 <Ferdirand> https://xkcd.com/1312/ :(
15:06:26 <ertes> Ferdirand: yeah, there are so many ways to make fun of haskell, but that's not one of them
15:10:10 <abel-abel> hello. Is there anyway in Emacs to goto definition for functions in standard library?
15:11:00 <ertes> abel-abel: as far as i'm aware haskell-mode can't cross package boundaries, although i believe there is a way to integrate hoogle
15:13:21 <abel-abel> ertes: thank you. I am looking for a plugin to do this.
15:16:16 <praduca> Hi, i'm getting some trouble with haskell on nixos
15:18:06 <praduca> someone have some tutorial or other resource on using correctly the haskellng on nixos? after doing what it says on A Journey into the Haskell NG infrastructure, i started to get some errors...
15:19:57 <ertes> praduca: what errors do you get?
15:20:33 <praduca> not in haskell, on installing packages on nixos, so i can't have for sure that what i did is correct
15:20:59 <praduca> it should interfere on system? i started to get messages of name collision error when installing things
15:23:04 <praduca> I asked this on nixos but nobody answered (yet)
15:26:40 <ertes> praduca: is this about installing haskell packages into your user environment?
15:26:49 <ertes> or about using nix to build your haskell projects
15:28:44 <praduca> Hm, I think it is, because that haskellng "stuff" is about that, but i get problems only using stack with nix usage enabled
15:30:34 <praduca> and this "side effect" of clash of names too, that i really can't understand. I think this is more on NIXOS than haskell itself, but i cant find documentation for neither (about that)
15:31:45 <Cale> praduca: In my experience, nix people usually use nix to build their Haskell packages. It ought to be possible to use stack, but it seems a bit odd, when your entire environment is set up to do what stack does, only better.
15:32:54 <Cale> (I don't use nixos myself, but we do use the nix package manager where I work to build things)
15:33:08 <praduca> hm, thats interesting. The thing is i'm getting a course on yesod, and this thing is heavily dependent (the documentation) on the stack commands
15:33:13 <Cale> ah
15:33:26 <ertes> praduca: yeah, if you have nix, there is little reason to use stack
15:34:03 <ertes> praduca: however the way to install packages into your environment is a bit different from the way you build your packages for development
15:34:36 <ertes> praduca: that's why it would be useful to know what it is you're trying to do
15:35:44 <praduca> At the moment I'm just trying to setup the environment for the part of the course that use stack (will start one month from now)
15:36:14 <praduca> i was on ubuntu until some weeks, then discovered nixos
15:36:40 <praduca> everithing on it is marvelous, until you need to understand something more profoundly :) 
15:36:58 <sea_wulf> praduca: do you like nixos? How would you compare it to something like arch?
15:37:01 <moonarch[m]> +1 for nixos
15:37:46 <ertes> praduca: the best way to use stack on NixOS is to ignore the fact that you're on NixOS =)
15:38:00 <ertes> at least i think…  i don't really have stack experience
15:38:21 <praduca> it's crazy good, it's what you expect if someone ask you to make a linux "on rails"
15:38:45 <ertes> sea_wulf: i think #nixos is a better place for that particular question =)
15:39:31 <sea_wulf> ertes: true facts. I was just wondering how it fared in terms of hs development
15:41:17 <MP2E> generally speaking, haskell development on nixos involves using 'cabal2nix --shell ~/projectdir > shell.nix', then run nix-shell on the generated expression.
15:41:27 <praduca> just to be clear, when you Cale: say that you use nix to build things, and the stack similarity, you mean nix-shell?
15:41:31 <MP2E> also note that haskellng is now just haskell, the old infrastructure was deprecated and removed long ago
15:41:44 <MP2E> the docs relevant to haskellng should work if you just rename the parts that say haskellng to haskell, though.
15:42:24 <ertes> praduca: nix-shell for the development part, nix-build/nix-env for testing/deployment
15:42:45 <ertes> at least that's my workflow…  you can be a bit creative in how you do it
15:42:46 <praduca> OH GOD THANKS MP2E: this is the kind of info i was trying to get.
15:43:14 <Cale> (and nix-copy-closure for deployment :D)
15:43:31 <MP2E> no problem :)
15:43:53 <praduca> thanks to all, will try all that and maybe put in some blog :)
15:43:56 <MP2E> nixos is a great os but we really suffer from lack of documentation
15:44:01 <MP2E> that would be appreciated !
15:44:33 <ertes> praduca: if you like to use haskellPackages, i can show you my setup, if you prefer to make your own package set, you can see how reflex-platform works
15:44:56 <praduca> ertes: i will like that
15:45:15 <ertes> the former is just plain hackage, while the latter is more like somthing like stackage LTS
15:45:31 <ertes> plain hackage has worked for me so far
15:47:57 <praduca> ertes: but you need to declare something to access those (.nixpkgs folder i mean), or this is default 
15:48:15 <ertes> praduca: i'm using a few overrides: <https://github.com/esoeylemez/config/blob/master/files/.nixpkgs/config.nix>
15:48:58 <ertes> praduca: to launch a GHCi on a haskell project i've written this: <https://github.com/esoeylemez/config/blob/master/bin/nix-ghci>
15:49:03 <ertes> it's a bit hacky, but it works
15:49:14 <MP2E> neat, I like asGit. looks convenient :)
15:49:22 <MP2E> i have a similar setup https://github.com/MP2E/nix-projects/blob/master/nixpkgs-config/config.nix#L44
15:49:56 <ertes> reason being that haskell-interactive-mode doesn't have support for nix, so i'm using its GHCi process-type, but use my nix-ghci wrapper script
15:50:28 <praduca> tks people, will study all this and see what fits best. Really appreciated the help!
15:50:40 <ertes> MP2E: i'm not overly fond of asGit myself…  the real solution is to get default.nix out of the project directory =)
15:51:07 <ertes> it was a quick-n-dirty way to have both with a single default.nix
15:51:13 <MP2E> ah :p
15:52:10 * dmj` wishes ghc-musl was on nixpkgs
15:56:42 <ertes> MP2E: (asGit is fine…  it's just the way i use it that isn't) =)
15:57:02 <ertes> so feel free to copy it =)
15:58:56 <MP2E> thanks :)
16:03:44 <scope> monochrom you here?
16:07:15 <scope> Maybe someone else can help me. I swear these functions were working yesterday, but now I just get "Exception: prelude.read: no parse"
16:07:18 <scope> here's the code http://lpaste.net/6430151029542617088
16:07:38 <scope> I'm passing a string that looks like "5.0 3.0 4.0 7.0"
16:08:18 <jle`> scope: that isn't really oging to parse as a (Float, Float)
16:08:32 <scope> jle` I'm pretty sure it was working fine yesterday
16:09:20 <jle`> i'm skeptical :o
16:09:39 <jle`> might work with "(5,3) (4,7)"
16:09:45 <scope> let me try again
16:10:26 <jle`> but it's very fragile
16:10:42 <cjhoward> hey all
16:11:05 <scope> jle` that was the issue
16:11:08 <scope> lol
16:11:14 <scope> whoops
16:11:38 <lpaste_> lambdafan pasted “Tricky Traversal” at http://lpaste.net/353910
16:12:12 * lambdafan yawps
16:12:38 <Nolrai> Is there a beter way to write "g <$> f x <*> pure y"? 
16:13:16 <glguy> (`g` y) <$> f x;   or     flip g y <$> f x
16:13:34 <jle`> cjhoward: hi cjhoward 
16:13:36 <glguy> f x <&> \z -> g z y
16:14:27 <Nolrai> I like the second (partly because my g is almost commutative).
16:14:27 <lambdafan> glyguy: I came across some lens examples you wrote on github.
16:15:01 <scope> jle`, at the moment I've hardcoded values, but say I wanted the toPoints function under main to read the points from a file passed through the command line
16:15:02 <scope> http://lpaste.net/6430151029542617088
16:15:10 <scope> how would I go about doing so?
16:15:30 <scope> I tried passing it stdin
16:15:40 <jle`> you can get a string from command line arguments using getArgs
16:15:49 <jle`> and you can read a string from a file using readFile
16:15:53 <lambdafan> scope, have you read LYAH?
16:15:56 <glguy> lambdafan: It'd be something like: itoListOf (game_data_gs . players_gd . p_map . ifolded <. score)
16:16:02 <scope> lambdafan for the most part
16:16:10 <lambdafan> glyguy: oh cool, I will play around with that
16:16:11 <cjhoward> does anyone have experience with Servant or Snap or any other web framework?
16:16:25 <lambdafan> cjhoward, I do with scotty and yesod
16:16:47 <cjhoward> lambdafan how are they? Have things been smooth?
16:17:11 <lambdafan> cjhoward, sure have. I started with Yesod not knowing much about either web dev or haskell.
16:18:06 <lambdafan> cjhoward: yesod is big, but that also means it does alot for you. I would recommend using Yesod, and then Scotty for when you have your head wrapped around the more challenging aspects of Haskell.
16:18:11 <cjhoward> lambdafan awesome! I'm pretty familiar with web dev, and still relatively new with Haskell. I'm thinking of doing my next project with a Haskell server side
16:18:31 <cjhoward> lambdafan what would you say is more challenging about Scotty?
16:18:38 <cjhoward> I will look at yesod
16:19:15 <lambdafan> well with scotty you will have to figure out the details of how you want to integrate the database, for example.
16:20:31 <cjhoward> Yes, I still haven't done any DB stuff with Haskell yet so I assume there will be some challenge there
16:20:42 <cjhoward> it feels like there is always so much to learn
16:21:37 <lambdafan> cjhoward, if you feel like there isn't any more to learn, it means you have stopped growing. There's always more.
16:21:43 <scope> ah jle` getContents was what I was looking for
16:22:07 <lambdafan> Yesod makes DB interfacing easy, if a bit crippled.
16:22:22 <cjhoward> lambdafan, what do you mean by crippled
16:22:37 <cjhoward> lacking some features?
16:23:09 <lambdafan> well, it wants you to use (like I said, opinionated) a library called persistent, which has limitations that have been overcome by newer libraries.
16:23:21 <lambdafan> yeah persistent lacks some features.
16:23:48 <lambdafan> I think the up and comer is called OpalEye?
16:24:01 <cjhoward> hmm alright
16:24:13 <lambdafan> https://hackage.haskell.org/package/opaleye
16:24:17 <lambdafan> yeah that's the one
16:24:29 <Sornaensis> is opaleye as generic as persist
16:24:49 <athan> fresheyeball: Because I didn't have an ethernet connection :)
16:24:57 <lambdafan> opaleye is better, but I am not sure how welel it is integrated with Yesod. It is of course possible to use with Yesod. it's a question of how much work would be required.
16:25:06 <athan> fresheyeball: Gentoo's dilema
16:25:23 <lambdafan> Sornaensis : good question.
16:25:36 <jle`> is there any nice library that lets me derive Num instances from simple product types using generics
16:25:39 <jle`> 5c
16:25:39 <cjhoward> lambdafan well i have some work to do haha
16:26:46 <lambdafan> Yesod has a nice tutorial, The primary author spends much effort on documenting. From an engineer's point of view, as opposed to an academic's.
16:27:08 <lambdafan> so, more examples, fewer proofs.
16:27:23 <cjhoward> yeah I like examples
16:27:30 <lambdafan> As do I. 
16:27:30 <cjhoward> no need for proofs, many a times
16:27:59 <lambdafan> well, I'd want proofs when it comes to testing time. But not as documentation.
16:28:51 <cjhoward> sure, sure
16:29:34 <lambdafan> glguy: thanks that was exactly right.
16:31:16 <cjhoward> lambdafan I'm going to take off for now. Thanks for the help
16:45:40 <scope> if I have a list of tuples of type float, is there a simple way to find the max value of the list of tuples? for instance if I have (5,3) (2,7) (5,15) I want to get the value 15
16:46:35 <geekosaur> > maximumBy (comparing snd) [(5,3),(2,7),(5,15)]
16:46:36 <lambdabot>  (5,15)
16:46:49 <scope> thank you geekosaur
16:47:35 <ChaiTRex> > maximum . curry max $ [(5,3),(2,7),(5,15)]
16:47:37 <lambdabot>  error:
16:47:37 <lambdabot>      • No instance for (Typeable t0)
16:47:37 <lambdabot>          arising from a use of ‘show_M57767628145977763733546’
16:47:47 <ChaiTRex> > maximum . uncurry max $ [(5,3),(2,7),(5,15)]
16:47:49 <lambdabot>  error:
16:47:49 <lambdabot>      • Couldn't match expected type ‘(t0 c, t0 c)’
16:47:49 <lambdabot>                    with actual type ‘[(Integer, Integer)]’
16:48:36 <ChaiTRex> > maximum . map (uncurry max) $ [(5,3),(2,7),(5,15)]
16:48:38 <lambdabot>  15
16:48:49 <ChaiTRex> There
16:49:16 <geekosaur> > maximum . map snd $ [(5,3),(2,7),(5,15)]
16:49:18 <lambdabot>  15
16:49:59 <jle`> scope: note that those will only get the max value of the second item of the tuples
16:50:22 <jle`> well, some of those
16:50:32 <ChaiTRex> Mine gets the max of all of the items in the tuples.
16:51:01 <scope> jle` that's honestly what I'm trying to do, here's an example
16:51:15 <scope> formatting is wrong, but toPoints is a list of tuples
16:51:16 <scope> http://lpaste.net/4514503561492561920
16:51:30 <scope> I'm trying to get the minimum x value, max x value, min y value and max y value
16:52:22 <scope> do I need to import something to use maximumBy and minimumBy?
16:52:31 <jle`> @hoogle maximumBy
16:52:32 <lambdabot> Data.List maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
16:52:32 <lambdabot> Data.Foldable maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
16:52:32 <lambdabot> GHC.OldList maximumBy :: (a -> a -> Ordering) -> [a] -> a
16:52:37 <jle`> they're in Data.List and Data.Foldable
16:53:42 <scope> right
17:02:44 <scope> geekosaur when I try to run "maximumBy (comparing snd) [(5,3),(2,7),(5,15)]" in prelude I get "variable not in scope"
17:03:00 <geekosaur> @index comparing
17:03:01 <lambdabot> Data.Ord, Distribution.Simple.Utils
17:03:09 <geekosaur> you want the first of those
17:03:18 <scope> ty
17:03:25 <ezyang> how would you implement https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/src/Data-ByteString.html#splitWith on String? 
17:03:36 <ezyang> I did a simple implementation with break but it doesn't handle the empty list case correctly 
17:03:37 * geekosaur keeps a browser tab open with hayoo.fh-wedel.de to look stuff like that up
17:03:38 <scope> geekosaur same error
17:03:48 <ezyang> so I'm wondering if there is a clear spec of the function 
17:03:51 <geekosaur> then show the actual full error
17:04:14 <geekosaur> also I hope you imported maximumBy from either Data.List or Data.Foldable like mentioned earlier
17:04:38 <scope> yes I did
17:04:42 <Welkin> geekosaur: why keep a browser tab open?
17:04:49 <ezyang> besides special casing the empty input 
17:04:51 <Welkin> just use the duckduckgo bangs
17:04:51 <geekosaur> because I use it that often?
17:04:57 <Welkin> !hayoo <search term>
17:05:11 <scope> think I've figured it out
17:05:25 <geekosaur> and it's silly to go through another site
17:06:21 <Welkin> geekosaur: you type it into your address bar in your browser, as long as you have ddg set as your default search engine
17:06:31 <defanor> what would be the least painful way to open a file for reading and writing in text mode, read it, and then write it? hGetContents semi-closes the handle, makes it unusable for reading
17:06:37 <defanor> for writing*
17:06:51 <lolisa> Hello, typeclass question. So I have a typeclass, and I want to provide default method impl. However those impl rely on extra typeclass dependency. How can I make it so, only if those extra typeclass can be inferred, the default will be used?
17:07:11 <Welkin> defanor: readFile and writeFile?
17:07:48 <defanor> Welkin: those would open a file twice, allowing it to be changed between the calls
17:08:11 <ezyang> lolisa: You want "default method signatures" 
17:08:54 <ezyang> https://downloads.haskell.org/~ghc/7.2.1/docs/html/users_guide/type-class-extensions.html "default signatures" 
17:09:03 <geekosaur> defanor, you have to use non-lazy I/O for that
17:09:27 <ezyang> urk, apparently I still can't implement splitWhen correctly 
17:09:30 <lolisa> ezyang,  thx, exactly what I need.
17:10:34 <geekosaur> openFile, hGetLine, hSeek
17:10:36 <defanor> geekosaur: and non-lazy functions are just the binary ones?
17:10:53 <geekosaur> possibly the Buf ones if you want to use chunks that aren't lines
17:10:54 <defanor> geekosaur: oh, those. will try it then, thanks
17:11:04 <defanor> lines would be fine in this case
17:11:25 <Welkin> seeking a file is the worst 
17:11:36 <Welkin> it feels too low-level
17:11:49 <ezyang> when a QC fails, I often want some extra debug output 
17:11:55 <Welkin> I only do it when dealing with binary or something similar
17:11:57 <ezyang> what combinator do I want here? 
17:12:13 <ezyang> oh counterexample I guess 
17:12:13 <erisco> Cale, monochrom, ertes, et al, this is what I came up with http://lpaste.net/
17:12:15 <c_wraith> seeking in a file full of fixed-size records is fine. seeking in a text file is weird. 
17:12:36 <erisco> that's right, the whole website
17:12:39 <erisco> okay here it is http://lpaste.net/353911
17:13:12 <erisco> you can see in the example it very quickly finds only the diagonal
17:13:30 <geekosaur> if you are shortening the file, this will suckl a bit, and I don't see a binding to truncate offhand
17:13:33 <geekosaur> ftruncate
17:13:50 <geekosaur> note that the seek here is to offset 0
17:13:54 <geekosaur> read file, rewrite it
17:14:06 <geekosaur> that should always be valid on a disk file
17:14:06 <erisco> which dodges the vast majority of the 10 billion factors
17:14:06 <defanor> there's hSetFileSize
17:14:36 <erisco> there is the foo version and the bar version
17:15:07 <defanor> hrm, though hSetFileSize requires file size as an integer, and need to find how to get it from the current position
17:15:20 <erisco> I am still working out how this relates to other patterns, and the bar version may be a better candidate for that
17:15:46 <geekosaur> defanor, after the seek back to the start, you set the size to 0 and then rewrite the file which will re-extend it
17:16:07 <geekosaur> alternately, you use hTell after the write to find out where you are and hSetFileSize to that to drop anything left from the old version
17:16:19 <defanor> oh, there's hTell
17:16:32 <defanor> geekosaur: ah, indeed, could use that too
17:18:02 <geekosaur> also remember to open the file for read+write initially of course
17:18:50 <defanor> this program where i'm just modifying an xml file turns out surprisingly awkward. used the `xml` package for xml modification, and that also turned out to be more verbose than i've expected
17:19:04 <geekosaur> ...and this will not be a transaction as far as the filesystem is concerned, so another process may be able to observe an intermediate state. if this matters, write to a new temporary file, close and unlink original, rename temp to name of original
17:19:29 <geekosaur> (most filesystems don't do transactions...)
17:20:47 <defanor> geekosaur: that shouldn't be an issue, actually even opening for read-write is a bit of extra care, but yup, it might actually be a better idea to do that with a temp file
17:20:57 <defanor> and would probably be less verbose, even
17:22:32 <scope> geekosaur I'm trying to use your maximumBy example, this is what I have so far but I'm unsure of where to throw parentheses. The three "5.0"s are the other 3 arguments, placeholders until I can figure out the format for minimumBy http://lpaste.net/4514503561492561920
17:22:57 <scope> svgHeader takes 4 arguments
17:23:16 <scope> whoops let me update, toPoints is missing
17:23:39 <scope> http://lpaste.net/4514503561492561920
17:23:39 <geekosaur> maximumBy takes and returns lists. you can;t automagically unroll that list into parameters for svgHeader
17:23:56 <scope> I thought maximumBy returned the maximum number?
17:24:07 <geekosaur> wait,.. yeh
17:24:19 <geekosaur> I am confused by your syntax, I can;t tell what you are tryig to do
17:24:23 <scope> wait fuck
17:24:26 <scope> it returns a tuple
17:24:26 <geekosaur> oh
17:24:37 <scope> I only want the first value in that tuple
17:24:42 <scope> that might be what's tripping me up
17:24:55 <geekosaur> first off, I think you want the second version that I did but with snd replaced with fst
17:25:06 <geekosaur> [24 23:48:54] <geekosaur> > maximum . map snd $ [(5,3),(2,7),(5,15)]
17:25:25 <scope> yep you're right
17:25:25 <geekosaur> mo more tuple, and you're also not wasting time skipping over the part you don't careabout
17:25:27 <scope> dammit
17:25:36 <geekosaur> after that you need to parenthesize
17:25:44 <scope> right
17:25:46 <scope> thank you
17:26:28 <geekosaur> putStrLn (svgHeader (minimum . map fst $  toPoints points) 5.0 5.0 5.0) -- I think
17:26:35 <scope> geekosaur this look about right?
17:26:36 <scope>      putStrLn (svgHeader (minimum . map fst $ (toPoints points)) 5.0 5.0 5.0)
17:26:40 <scope> yep exactly
17:26:43 <scope> well close
17:26:56 <scope> I guess I don't need the last pair around toPoints points
17:27:26 <ChaiTRex> scope: One of the nice features of ($) is its parentheses reduction.
17:27:49 <scope> chaitrex yeah that's actually really cool
17:27:54 <scope> what does $ mean in english?
17:28:02 <scope> roughly speaking
17:28:06 <Welkin> "apply"
17:28:10 <Welkin> it is functions application
17:28:13 <Welkin> function*
17:28:17 <Welkin> :t ($)
17:28:17 <scope> ah alright
17:28:18 <lambdabot> (a -> b) -> a -> b
17:28:41 <Welkin> :t const flip const id
17:28:43 <lambdabot> b -> (b -> c) -> c
17:28:49 <Welkin> :t flip (const flip const id)
17:28:51 <lambdabot> (b -> c) -> b -> c
17:28:51 <Welkin> :D
17:29:07 <geekosaur> it's function application, but instead of highest precedence it's lowest
17:29:08 <Welkin> I discovered that last night
17:29:30 <geekosaur> (normal being highest precedence is why your extra parentheses weren't needed)
17:30:01 <scope> gotcha
17:30:08 <scope> managed to get it working
17:30:12 <geekosaur> it's just id with a specialized type :p
17:30:31 <Welkin> lol geekosaur, that's right
17:33:18 <erisco> I worked on generalising it and came up with   qux f z = foldl (\a x -> x >>= \x' -> a >>= \a' -> f a' x') (return z)
17:33:25 <erisco> which is not pretty, yet
17:33:39 <c_wraith> :t flip (flip id) 
17:33:41 <lambdabot> (b -> c) -> b -> c
17:33:49 <c_wraith> same thing but less silly. :) 
17:34:06 <c_wraith> ie, I evaluated the const. 
17:34:24 <erisco> qux :: (Monad m, Foldable t) => (b -> a -> m b) -> b -> t (m a) -> m b
17:34:36 <erisco> the type is pretty, though
17:35:20 <erisco> :t foldM
17:35:21 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
17:35:39 <erisco> can probably rewrite it with foldM
17:42:39 <erisco> so the whole thing comes down to  foldlM . ((=<<) .)
17:43:15 <erisco> that's my algorithm to accumulate over the factors of n-ary Cartesian product with short circuiting
17:43:25 <erisco> sometimes Haskell amazes me
17:45:20 <erisco> and to boot it is more general than that
17:50:02 <ezyang> heh, Text and ByteString disagree about what the split of an empty string should be 
17:57:14 <scope> I'm trying to do something like this using the $ format if someone can help me out
17:57:18 <scope> "     putStrLn (map edgeToSVG (convexHullEdges (toPoints points)))"
17:59:08 <sophiag> this seems like an obvious question, but i can't seem to find the answer to it... since parsec is jjust a state transformer monad, is it possible to use parsers like state monads? i want to cons nested lists and am thinking that might be a more sensible structure than storing them in IORefs
18:00:32 <erisco> pretty sure whatever it is that IORefs is unlikely the answer
18:01:05 <dmj`> sophiag: you can transform parsec w/ a state monad, ParsecT
18:01:29 <sophiag> erisco: that's how Write Yourself a Scheme structures the repl
18:01:57 <scope> nevermind figured it out
18:01:57 <dmj`> there’s even a convenient MonadState instace for ParsecT
18:02:16 <erisco> that's okay, they're licensed for that
18:02:19 <sophiag> dmj`: cool, thanks. i'll look into that
18:09:27 <sophiag> dmj`: with MonadState would i use modifyState instead of execState as in the regular state monad?
18:10:45 <dmj`> sophiag: when inside of a Monad that has a MonadState constraint, you can use modify (\f -> get >>= \x -> put (f x)). When evaluating / unwrapping a state, you’d use execState
18:11:32 <Welkin> dmj`: hi
18:11:49 <sophiag> oh, ok. i only asked that because i didn't see execState listed as a method
18:11:56 <dmj`> sophiag: both the regular State monad and the StateT monad are instances of MonadState, so it will be inferred by the context
18:12:11 <sophiag> that makes sense
18:12:18 <dmj`> sophiag: ah yea, I think only get, put, modify are methods
18:13:52 <sophiag> i guess my confusion was over methods of the MonadState class versus the State monad inside it?
18:15:36 <sophiag> i'm also curious about Parsec.Perm since i'm writing a nondeterministic parser. it seems the list monad has everything i need, but i just saw Perm today and am wondering about that vs. permutation and filter or guard
18:18:46 <sophiag> the idea is simply to build up one list of nested lists and another of booleans corresponding to them and then return all the permutations with the constraints filtered out. so like a dsl for what you can achieve with one liner in the list monad
18:22:37 <twiddly> /names
18:26:40 <nshepperd> B.split 0 (B.pack []) = [] -- nooo
18:37:34 <tobiasBora> Hello,
18:39:11 <nshepperd> ezyang: the text one has the convenient property that `split b (foo <> singleton b <> bar) = split b foo ++ split b bar`
18:40:57 <erisco> tobiasBora, hello
18:41:37 <tobiasBora> I'd like to do an efficient program that download html pages as fast as possible. For now, using parallisation on 4 cores, and using the httpLbs function, that uses one manager for all the threads, I can achieve to have 680 download per mn. However, when I look at the processor, I see that most of the time, the CPU is not used, the internet connection is not used "amazingly", and the RAM used is negligable,
18:41:39 <tobiasBora> so I think that my program spend most of the time by doing IDLE because he waits for the server answer... Do you have any idea on how to avoid that? I'm thinking to use pools, but... I don't know what I should put in a pool ^^'
18:41:47 <dmj`> sophiag: that’s a valid concern, multiple MonadState instances will be ambiguous, you might need to perform explicit lifting.
18:42:28 <tobiasBora> (or maybe someone has a better way to proceed)
18:43:48 <pacak> tobiasBora: Most likely it will be network bound and waiting for a server reply. 
18:44:01 <ChaiTRex> tobiasBora: I don't know the best method, but it may be that the server isn't that fast.
18:44:16 <pacak> tobiasBora: Plus if you are going to hammer the same server with a ton of request - they will most likely block you.
18:44:42 <erisco> as long as you always have a request in flight then you are already at max speed, as far as I know
18:45:13 <tobiasBora> ChaiTRex: The server should be fast, really. Or maybe he tried to avoid to send me info too quickly, but since I can use several proxy, I don't mind
18:45:45 <erisco> I mean as long as you are actively sending out a request, not waiting for a response
18:46:04 <erisco> but then responses are going to tie up time as well so I am not sure what the balance is
18:46:18 <tobiasBora> erisco: During the sending yes. But I think that their is time between sending and receiving, because my network use is quite low
18:48:26 <erisco> it sounds like you already have parallelisation set up, so if you've increased the number of parallel requests and there is no improvement I don't know what else to offer
18:49:59 <erisco> if you're hitting one host with lots of requests then it doesn't matter how fast you get them in
18:50:03 <erisco> you're still bottled by them
18:50:53 <scope> how the hell do I parenthesize this? "1" and "toPoints points" are the two arguments being passed to "pointToSVG"
18:50:54 <scope>      printList (map pointToSVG 1 toPoints points)
18:51:12 <Welkin> :t map
18:51:13 <lambdabot> (a -> b) -> [a] -> [b]
18:51:20 <Welkin> it takes 2 parameters
18:51:38 <capn_freako> Would anyone care to share their favorite method for writing/processing literate Haskell w/ markdown?
18:51:57 <Welkin> printList $ (map pointToSCG) 1 (toPoints points)
18:52:00 <Welkin> there is one way
18:52:12 <Welkin> er
18:52:13 <scope> that's the only way to do it?
18:52:26 <erisco> printList (map (pointToSVG 1 (toPoints points)) by your description but this probably is not correct
18:52:56 <scope> yeah erisco that didn't quite work
18:53:01 <scope> I must be forgetting something
18:53:11 <erisco> I think there are 15 ways to parenthesize them
18:53:21 <Welkin> wait...
18:53:22 <erisco> so better to just know what it is you're doing than to be guessing
18:53:29 <Welkin> what is the type of toPoints?
18:53:43 <scope> toPoints :: String -> [(Float,Float)]
18:53:54 <Welkin> printList $ map (pointToSCG 1) (toPoints points)
18:54:01 <Welkin> try that
18:54:10 <erisco> what is the type of printList and pointToSVG ?
18:54:18 <Welkin> pointToSVG is partially applied over 1
18:54:27 <scope> printList :: [String] -> IO ()
18:54:35 <scope> pointToSVG :: Float -> Point Float -> String
18:54:54 <erisco> is the type of points String?
18:55:13 <Welkin> and I assume `type Point = [(Float, Float)]`
18:55:13 <scope> yeah
18:55:24 <Welkin> e
18:55:25 <Welkin> er
18:55:29 <Welkin> and I assume `type Point = (Float, Float)`
18:55:31 <erisco> okay, so toPoints points :: [(Float,Float)]
18:55:33 <scope> toPoints converts the string of points to a list of (float, float)
18:55:48 <Welkin> scope: try my suggestion
18:55:58 <scope> didn't work welkin
18:55:58 <erisco> \f -> map f (toPoints points) :: ((Float,Float) -> b) -> [(Float,Float)] -> [b]
18:56:07 <scope> oh fuck
18:56:11 <scope> you had a typo lol
18:56:12 <scope> one sec
18:56:31 <scope> that worked, is there another way to write that without using the $?
18:56:36 <erisco> so I think you have a problem with the function you are mapping with
18:56:38 <scope>      printList $ map (pointToSVG 1) (toPoints points)
18:56:42 <scope> that works
18:56:49 <scope> but I want to know how to write it without the $
18:57:04 <Welkin> printList . map . pointToSCG 1 . toPoints $ points
18:57:05 <Welkin> :P
18:57:10 <Welkin> (printList . map . pointToSCG 1 . toPoints) points
18:57:17 <Welkin> er
18:57:23 <erisco> or I think you told me the wrong type for pointToSVG
18:57:26 <Welkin> (printList . map (pointToSCG 1) toPoints) points
18:57:38 <Welkin> (printList . map (pointToSCG 1) . toPoints) points
18:57:39 <scope> the . is necessary?
18:57:41 <Welkin> o.o damn
18:57:45 <erisco> maybe  type Point a = (a, a)
18:57:48 <scope> it's confusing the hell out of me
18:57:54 <Welkin> scope: it is function composition
18:57:55 <erisco> then we're making sense
18:58:14 <scope> here I'll just paste the necessary functions for what I"m trying to do
18:58:25 <Welkin> scope: use lpaste
18:58:28 <Welkin> @lpaste
18:58:28 <lambdabot> Haskell pastebin: http://lpaste.net/
18:59:23 <erisco> it is just  printList (map (pointToSVG 1) (toPoints points))
18:59:29 <scope> http://lpaste.net/4514503561492561920
18:59:57 <scope> erisco that's exactly what I was looking for
19:00:00 <scope> that works
19:00:18 <Welkin> o.o
19:00:23 <Welkin> that's what I wrote
19:00:29 <scope> wait what???
19:00:41 <Welkin> just with a $ in place of the extra parentheses
19:00:42 <scope> wait I lied
19:00:42 <sophiag> dmj`: sorry, just saw your response. i'm actually still debating how to structure it. i'm not sure it makes sense to use a MonadState instance to specify constraints
19:00:45 <erisco> Welkin, good artists copy, great artists steal
19:00:46 <scope> those points are all wrong
19:00:52 <scope> on the html graph
19:01:34 <scope> wait nevermind no they aren't
19:01:38 <scope> yep that works
19:01:45 <scope> welkin I just wanted to see it without the $ :)
19:02:12 <scope> I'm a total haskell noob
19:02:42 <sophiag> dmj`: essentially after i've parsed everything i want an eval function that applies permutations to the nested lists i've built up and then filters them based on the constraints. but i'd like the option for both to apply tags or not so i can either filter all the permutations based functions that return bools or filter just the ones where the tags match
19:02:43 <scope> it's just the way multiple arguments are passed that was confusing me a bit
19:03:18 <Welkin> scope: there are not multiple arguments
19:03:32 <Welkin> the maping function is partially applied over the value of 1
19:03:33 <scope> multiple arguments to pointsToSVG
19:03:33 <erisco> if you want the real answer it is that there is no such thing as multiple arguments
19:03:34 <scope> welkin
19:03:58 <erisco> all functions take exactly one argument
19:04:08 <scope> I'm used to being able to just to "pointsToSVG(1, (toPoints points))"
19:04:22 <erisco> since you've been confused by this before maybe it is time to learn how it really works
19:04:40 <scope> erisco at the moment I need to finish this up, I'll take you up on that later though
19:04:55 <scope> only need to get file I/O working
19:05:00 <Welkin> scope: if you haven't learned about curried functions and partial application, it's an important basic concept
19:05:20 <Welkin> I'm sure it is coverdd in Learn You A Haskell and any other haskell resource
19:05:29 <scope> I have an exceptionally basic idea of curried functions
19:05:43 <Welkin> scope: do you know javascript?
19:05:48 <erisco> "exceptionally basic"
19:05:50 <scope> I don't
19:05:56 <Welkin> okay, so no es6 example
19:06:07 <scope> I know java, c, c++ and some ruby
19:06:39 <erisco> out of those I think only Ruby is suitable to demonstrate in
19:06:42 <Welkin> function (a) { return function (b) { return a + b } }
19:06:55 <Welkin> there is a "curried" version of an `add` function
19:07:18 <erisco> or I suppose the new Java has papered over their inline class thing
19:07:19 <scope> ruby is the one I know the least :/
19:08:15 <erisco> lambdas in Java 8
19:08:32 <erisco> and maybe C++ has something by now... they're always adding pieces on
19:09:12 <scope> erisco haven't done C++ in a while either, I know C much better
19:09:41 <scope> welkin so curried functions are just "nested" I guess?
19:09:48 <Welkin> well, since none of those have first-class functions
19:09:53 <Welkin> it's not easy to demonstrate using them
19:10:05 <erisco> yeah I don't think C really has what is needed
19:10:08 <Welkin> which is why javascript is a good language for examples that are not haskell
19:10:19 <Welkin> (or lua!)
19:10:36 <erisco> it isn't that you cannot achieve the same effect, it is that the essence is obscured
19:10:57 <erisco> Lua is an abomination but JavaScript would work alright
19:11:02 <Welkin> erisco: o.o
19:11:10 <Welkin> lua is even *better* than javascript
19:11:15 <Welkin> not sure why you don't like it
19:11:18 <mniip> 1490407766 [05:09:26] <Welkin> well, since none of those have first-class functions
19:11:25 <mniip> java.util.function.Function<A, B> ??
19:11:36 <mniip> perhaps, as a suitable approximation
19:11:49 <erisco> yeah with lambdas in Java 8 you can demonstrate it, I presume
19:12:13 <scope> well thank you all for your help once again, I appreciate everything you all have done for me over the last couple of weeks
19:12:20 <erisco> without the syntax support it is obscure
19:12:23 <scope> but I need to head out for the night
19:13:08 <mniip> new Function<Integer, Function<Integer, Integer>> { Function<Integer, Integer> apply(Integer a) { return new Function<Integer, Integer> { Integer apply(Integer b) { return a + b; } } } } 
19:13:49 <erisco> you should be able to write  (Integer a) -> (Integer b) -> a + b
19:13:50 <mniip> that.apply(3).apply(5) = 8
19:14:03 <tobiasBora> erisco: Before adding threads didn't improve the result, but I tried another thing, and now I have my optimal rate at around 45 process... But I'm thinking that maybe create 45 process is not really good, so maybe I should try to create light threads instead...
19:14:31 <Welkin> mniip: o.o
19:14:36 <erisco> heh, well 45 processes isn't going to do you any good
19:14:40 <Welkin> mniip: wtf...
19:14:54 <erisco> the OS will schedule processes on your cores
19:15:01 <erisco> it cannot schedule more processes than cores
19:15:10 * mniip has learned a bit of java over the weekedn
19:15:17 <erisco> also, your NIC can only handle so much at once
19:15:21 <Welkin> mniip: my condolences
19:15:23 <erisco> I have no idea what the limits are, but they exist
19:15:49 <Welkin> in es6: a => b => a + b
19:15:54 <Welkin> almost looks like haskell o.o
19:16:01 <erisco> the only reason for 45 processes would be to persuade the OS to give you more time by drowning out other processes
19:16:20 <erisco> but there should be a more direct way to give priority to your process(es)
19:50:02 <tobiasBora> I've a question about parsec
19:50:50 <tobiasBora> How would you check that you are at the end of the line?
19:51:42 <tobiasBora> I tried this (endOfLine), but it does not work on strings: http://paste.debian.net/924255
19:52:00 <tobiasBora> I think it's because strings do not end with \n
19:52:02 <sophiag> tobiasBora: you can do something like "eol = char '\n'"
19:52:32 <tobiasBora> sophiag: Well, if my string do not contains '\n'?
19:52:41 <parsnip> try? 
19:53:15 <tobiasBora> unexpected end of input
19:53:17 <tobiasBora> expecting digit or "\n"
19:53:56 <parsnip> there's `newline`
19:54:03 <tobiasBora> how
19:54:08 <tobiasBora> eof do the job
19:54:10 <sophiag> sorry, didn't look at your snippet first
19:54:52 <sophiag> you're saying you have multiple lines in a file and newLine isn't matching, but eof is?
19:54:52 <parsnip> https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:try
19:55:38 <parsnip> https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Char.html#v:newline
19:56:26 <sophiag> oh, i think it's because when you fail on ';' it then doesn't match for newline? hence using try?
19:56:58 <parsnip> maybe use manyTill for the ;
19:57:16 <tobiasBora> sophiag: Well I'd like a parser then match : newline, and end of input (string or file)
19:57:30 <tobiasBora> eof seems to work for string also,
19:57:33 <sophiag> i would split those into two functions
19:57:39 <tobiasBora>  endOfLine should work for \n,
19:57:55 <tobiasBora> so I just need to find a way to say eof OR endOfLine
19:58:04 <sophiag> and then you could call many on the one that matches newline until it reaches eof
19:58:26 <sophiag> if you look at the csv example in Real World Haskell it basically does what you want
19:58:35 <sophiag> http://book.realworldhaskell.org/read/using-parsec.html
19:58:55 <parsnip> don't most filetypes end with a newline? 
19:59:24 <parsnip> eof <|> endOfLine works? 
19:59:25 <sophiag> although for some reason the RWH example doesn't use the newLine function
19:59:48 <sophiag> errr *endOfLine meant to say
20:00:15 <sophiag> but also what parsnip is suggesting should work
20:00:19 <parsnip> i guess the expect to not be used on windows
20:00:23 <parsnip> *they
20:00:42 <tobiasBora> eof <|> endOfLine do not compile...
20:00:54 <parsnip> endOfLine is if someone used Notepad or Outlook to edit your file ;)
20:00:55 <sophiag> you need a line break
20:01:42 <tobiasBora> parsnip: Well noone force you to put a line break at the end of a file, and I don't want to relly on such thing.
20:01:53 <parsnip> maybe `try endOfLine; eof`
20:02:23 <sophiag> parsnip: oh, yeah. endOfLine matches for the tab character... no wonder
20:03:31 <tobiasBora> parsnip: no: "unexpected end of input"
20:03:32 <sophiag> oh, no wait i mismatched comments
20:04:23 <parsnip> tobiasBora: maybe remove eof, just use `try endOfLine`
20:05:20 <tobiasBora> Well if I don't use eof it's strange... You mean 'try endOfLine', and on the next line 'eof' ?
20:07:05 <parsnip> i don't understand eof. if it gets to end of file, why would it say, "unexpected end of input". that seems to be the message associated with eof
20:07:22 <parsnip> https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Combinator.html#v:eof
20:07:38 <parsnip> eof  = notFollowedBy anyToken <?> "end of input"
20:07:38 <tobiasBora> I found a solution:
20:07:40 <tobiasBora>         ((try (endOfLine >> return ())) <|> eof)
20:08:13 <tobiasBora> but it's quite verbose. If you have a way to shortcut the >> return () I'd be happy to hear about it!
20:09:33 <sophiag> well, if you know what kind of file you're parsing you can just use either newline or crlf
20:09:58 <tobiasBora> sophiag: The thing is that I want to be as general as possible.
20:10:21 <sophiag> right, so you want both *and* eof. i get it now. sorry, exhausted so not sure i was helpful :p
20:10:23 <tobiasBora> When a program bug because it do not end with newline, it's crazy to debug
20:12:10 <parsnip> tobiasBora: how about (try endOfLine) >> eof
20:12:47 <parsnip> oh, somethings not sufficient about try maybe
20:13:15 <tobiasBora> no, it does not work
20:14:35 <parsnip> https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:sepEndBy
20:15:42 <sophiag> oh, here's an idea: "notFollowedBy endOfLine"
20:16:21 <tobiasBora> I've a little bit shorter version "eof <|> (endOfLine >> return ())"
20:16:30 <tobiasBora> sophiag: Well it would match 'a' for example ^^
20:17:13 <sophiag> lol, i'm saying as a way to combine endOfLine and eof
20:17:26 <sophiag> not sure if that will actually match endOfLine, though
20:22:22 <parsnip> tobiasBora: where is Parser defined? 
20:23:08 <parsnip> tobiasBora: nm, i had to use your imports
20:23:24 <tobiasBora> parsnip: I think it's a shortcut for the long "Parse....". 
20:23:38 <tobiasBora> ParsecT s u m Char = Parser Char I think
20:23:59 <parsnip> nice, i should probably take advantage of that in my code
20:24:13 <parsnip> i _just_ started using Parsec a few days ago
20:28:34 <parsnip> what breaks if you remove eof? 
20:33:39 <parsnip> @hoogle m a -> m ()
20:33:40 <lambdabot> Control.Monad.Extra unit :: m () -> m ()
20:33:40 <lambdabot> Extra unit :: m () -> m ()
20:33:40 <lambdabot> Development.Shake unit :: m () -> m ()
20:33:48 <dmwit_> :t (()<$)
20:33:49 <lambdabot> Functor f => f b -> f ()
20:34:46 <parsnip> tobiasBora: optional endOfLine <|> eof
20:35:00 <parsnip> tobiasBora: i just hoogled for type of (>> return ())
20:35:10 <dmwit> parsnip: eof doesn't say "unexpected end of input" if it gets to the end of file. It says it was "expecting end of input" if it does *not* get to the end of file.
20:35:31 <parsnip> ...
20:35:46 <parsnip> dmwit: ;_;
20:36:10 <dmwit> I don't know that emoticon.
20:36:19 <parsnip> cry
20:36:28 <dmwit> why cry?
20:36:51 <MarcelineVQ> :<
20:36:55 <tobiasBora> dmwit: Is ()<$ supposed to be a shortcut for my >> return ()?
20:37:02 <dmwit> tobiasBora: yes
20:38:06 <tobiasBora> so it would give something like: eof <|> (()<$ endOfLine) ?
20:38:16 <dmwit> yes
20:38:17 <tobiasBora> (it looks strange this parents
20:38:26 <tobiasBora> ok thank you!
20:38:38 <jle`> also ($> ()) if you like to keep the () on the right side
20:38:38 <parsnip> dmwit: oh, nm, had to read that a few times, that makes sense, so i suspected, `try` has issues when it tries at end of file? 
20:39:01 <dmwit> I haven't been following along, so I don't have a ton of context.
20:39:09 <dmwit> What's going bonkers again?
20:39:39 <tobiasBora> ok nice thank you!
20:39:40 <parsnip> but `optional` is in the same library! 
20:39:49 <Omel> So i'm a completely new to haskell i have a function that overloads the operator ## and takes two lists, i have it returning an integer (not a maybe integer) and uses guards, why does it not allow me to use fmap(+1)?
20:39:53 <Omel> error is Couldn't match expected type `f0 Integer' with actual type `Int'
20:40:04 <jle`> Omel: can you paste some code?
20:40:18 <jle`> it's...pretty impossible to answer without code, heh :)
20:40:32 <dmwit> `optional p` and `() <$ p` do not mean the same thing. Which one you mean I leave up to you.
20:40:40 <Omel> https://thepasteb.in/p/DRhjq00vYMLfy
20:41:18 <jle`> Omel: fmap :: (a -> b) -> [a] -> [b], here
20:41:22 <jle`> Omel: so it returns a list
20:41:37 <jle`> er i mean, it takes a list
20:41:44 <jle`> but xs ## ys is not a list...it's an Int
20:41:55 <adarqui> anyone know if ghc 8.x got "slower" .. seems my old code base takes forever to compile now
20:42:08 <dmwit> Omel: Why do you believe it should allow you to use `fmap (+1)`? What type do you expect `fmap` to have in that expression?
20:42:30 <Omel> isn't fmap a functor i'm incrementing the final function call by +1 until it hits 0?
20:42:46 <jle`> fmap isn't a functor
20:43:07 <jle`> do you just wnat (xs ## ys) + 1  ...?
20:43:16 <Omel> what is it then?
20:43:25 <jle`> it's a function
20:43:44 <jle`> it's a higher-order function that lifts a function over a functor
20:43:51 <jle`> > fmap (+1) [1,2,3]
20:43:53 <lambdabot>  [2,3,4]
20:43:53 <Omel> no so xs ## ys would be two lists, xs would be a list and ys would be a list and it would return a count of how many elemnts it has in common
20:44:03 <jle`> (xs ## ys) is an Int
20:44:08 <jle`> xs is a list, and ys is a list
20:44:12 <jle`> but (xs ## ys) is an int
20:44:28 <tobiasBora> I've a question: I've a list of elements, but I'd like to be able to access to any of the elements in constant time. I tought to convert it in array by using something like "listArray (0:len(myList)-1) myList". Is it the good solution?
20:44:31 <jle`> (xs ## ys) isn't two lists; the type of (##) says that it should return an Int, not two lists
20:45:21 <dmwit> tobiasBora: Seems fine. What worries you?
20:45:35 <jle`> Omel: it is true that xs and ys are both lists.  xs and ys are two lists.  but (xs ## ys) is an Int
20:45:36 <Omel> I think i get what you're saying let me take a crack at it again and get back to you
20:45:50 <dmwit> I still can't parse "isn't fmap a functor i'm incrementing the final function call by +1 until it hits 0".
20:45:52 <tobiasBora> dmwit: Don't know, maybe some structure could be more efficient in haskell, I don't know ^^'
20:46:12 <jle`> dmwit: maybe they are thinking about the definition of 'functor' from Java/C++ ?
20:46:20 <parsnip> Omel: can you point to your definition of functor? 
20:47:12 <Omel> maybe i was misreading?
20:47:12 <Omel> http://learnyouahaskell.com/functors-applicative-functors-and-monoids
20:47:22 <Omel> In Haskell, they're described by the typeclass Functor, which has only one typeclass method, namely fmap, which has a type of
20:47:29 <Omel> ...
20:47:34 <jle`> ah yes, but fmap is not the Functor there
20:47:43 <jle`> [] is a Functor; Maybe is a Functor, IO is a Functor
20:47:46 <jle`> but fmap is not a Functor
20:48:00 <fred-fri> would much appreciate any feedback of how to make this solution to "the staircase problem" shorter, clearer and more elegant: https://gist.github.com/androidfred/51116c056d790c354554f253f87d33a6
20:48:05 <Omel> ok
20:49:01 <dmwit> Actually, `fmap` is much more the functor than the type-level mapping is. The term-level mapping induces the type-level mapping (in all categories, even), but not the other way around.
20:49:31 <jle`> ah, yeah.  i guess fmap is a part of the functor.
20:49:48 <jle`> i was mixing it up with the capital-F Functor
20:49:49 <parsnip> i'd say there's maths functor, and haskell's functor
20:50:01 <parsnip> math's functor, F takes objects and arrows about
20:50:03 <jle`> but fmap is not quite a functor either; it's just one part of the functor
20:50:22 <dmwit> I don't see that substituting Functor for functor in my sentence actually makes it wrong.
20:50:30 <parsnip> where math's F takes objects to objects, haskell's m takes types to types
20:50:43 <dmwit> parsnip: Haskell types are objects in the category Hask.
20:50:59 <ertes> > (\n -> take n . map (\i -> replicate (n - i) ' ' ++ replicate i '#') $ [1..]) 6
20:51:01 <lambdabot>  ["     #","    ##","   ###","  ####"," #####","######"]
20:51:02 <parsnip> where math's F takes arrows to arrows, haskell's fmap takes, um, ... types to types? 
20:51:07 <dmwit> (...of Haskell types as objects with Haskell functions as arrows.)
20:51:07 <ertes> fred-fri: ^
20:51:16 <jle`> well, in haskell, Functor specifically refers to the head of the typeclass instance
20:51:20 <dmwit> parsnip: No, Haskell's fmap takes functions to functions -- that is, arrows to arrows.
20:51:45 <parsnip> right, but only up in the type description, not at the function definition level, no? 
20:52:01 <Omel> so the error was arising with fmap because fmap was returning a list when i wanted an integer?
20:52:11 <tobiasBora> dmwit: There is no way to deal with empty arrays?
20:52:21 <jle`> Omel: 'fmap f' for lists takes a list and returns a list
20:52:21 <dmwit> parsnip: No, right at the function definition level. If you have an arrow `f :: a -> b` then you can hand it to `fmap` to get an arrow `F a -> F b` for some Functor `F`.
20:52:22 <fred-fri> ertes, big thanks!
20:52:29 <dmwit> tobiasBora: Why not?
20:52:40 <Omel> ok thank you i got it working now
20:52:42 <jle`> Omel: so the problem was that it takes a list, but you gave it an integer
20:52:44 <ertes> actually
20:52:54 <ertes> > (\n -> map (\i -> replicate (n - i) ' ' ++ replicate i '#') $ [1..n]) 6
20:52:55 <lambdabot>  ["     #","    ##","   ###","  ####"," #####","######"]
20:52:58 <parsnip> dmwit: right, not sure the terminology, i guess, yes, at definition of type of function, but nothing to do with the body of the function
20:52:58 <ertes> > (\n -> map (\i -> replicate (n - i) ' ' ++ replicate i '#') [1..n]) 6
20:53:00 <lambdabot>  ["     #","    ##","   ###","  ####"," #####","######"]
20:53:05 <ertes> fred-fri: ^ better
20:53:17 <tobiasBora> dmwit: Oh sorry, I did a wrong thing. It works now!
20:53:18 <Omel> So would one way to fix it be doing a Maybe Int instead of a Int?
20:53:23 <dmwit> parsnip: I don't understand this last sentence of yours. Can you say again what your objection is?
20:53:52 <parsnip> dmwit: what is the terminology that separates `f :: Int -> Int` from `f x = 2 * x`? 
20:54:15 <dmwit> I don't know. Let's say: The former is a type declaration. The latter is a definition.
20:54:15 <parsnip> type declaration? and body? 
20:54:23 <ertes> > (\n -> take n . tails $ replicate (n - 1) ' ' ++ repeat '#') 6
20:54:26 <lambdabot>  ["     #####################################################################...
20:54:46 <dmwit> ertes: cute =)
20:54:53 <ertes> > (\n -> take n . map (take n) . tails $ replicate (n - 1) ' ' ++ repeat '#') 6
20:54:55 <lambdabot>  ["     #","    ##","   ###","  ####"," #####","######"]
20:55:11 <ertes> fred-fri: ^ to get a bit more experimental =)
20:55:24 <parsnip> right, so at one point, i had come to the conclusion (from online?) that the type declaration for fmap is where the analogy occurs for math's functor applied to arrows. whereas, not so for the function definition (body?)
20:55:46 <dmwit> No, the function definition is definitely still part of the analogy.
20:55:47 <jle`> Omel: well, you can use an Int
20:55:55 <jle`> Omel: you can just do (xs ## ys) + 1
20:55:59 <jle`> no need to involve fmap
20:56:02 <dmwit> The definition of `fmap` gives the computation that you should perform to map arrows to arrows.
20:56:12 <dmwit> parsnip: Perhaps we should start from the top?
20:56:51 <Omel> which is what i did i just was curious for the sake of knowledge
20:57:10 <dmwit> (I mean, when you define a functor, you have to say what the arrow mapping does, you can't just say there is one!)
20:57:35 <parsnip> not until you instantiate the typeclass i thought
20:57:37 <dmwit> Omel: Sure, or Identity Int would be even closer to the same code.
20:57:56 <parsnip> haskell's typeclasses, such as functor, exist with instances
20:58:14 <parsnip> (i'm bound to screw up the terminology/concepts, sorry)
20:58:23 <parsnip> *exist without instances
20:58:41 <dmwit> ...all the definitions of fmap occur in instances, yes. So?
20:59:15 <dmwit> Don't confuse the *definition* of functor with the claim that "such-and-such *is* a functor" -- just like you shouldn't mix up the Functor class with particular Functor instances.
21:00:34 <sophiag> parsnip: it's the same definition of functor from category theory. not the same as in c++ and such, but i doubt many people think of that. unless i'm missing something here the only thing people find counterintuitive are that types are objects in hask whereas functions are morphisms
21:01:52 <parsnip> two functions can be the same morphism
21:01:56 <sophiag> so then it makes sense that fmap maps between functors since they're the only things with mappable structure, right? you can't just map between types. unless i'm confusing what this discussion is about since i stepped away
21:02:09 <parsnip> category theory doesn't distinguish the function bodies
21:02:21 <parsnip> https://wiki.haskell.org/Hask
21:02:42 <parsnip> it only sees the type declarations
21:02:45 <sophiag> sure. i didn't say anything to the contrary
21:02:59 <dmwit> what? no
21:03:15 <dmwit> A category can have many distinguishable arrows between a given pair of objects.
21:03:17 <sophiag> dmwit: if two functions have the same type signature?
21:03:49 <dmwit> sophiag: Can you complete that question? "If X" ... then what?
21:04:02 <parsnip> if two fmaps have the same type declaration, category theory says they are the same morphism. 
21:04:09 <dmwit> noooo
21:04:10 <sophiag> no, not quite
21:04:30 <sophiag> they're isomorphic, which doesn't mean they're equal "on the nose" as category theory types say
21:04:34 <dmwit> no
21:04:35 <dmwit> no no
21:04:46 <dmwit> "same type" does not mean equal in any way, isomorphic or any other
21:04:50 <parsnip> oh, nm, reading more carefully now
21:05:05 <glguy> dmwit: What if I wanted it to ?
21:05:21 <sophiag> dmwit: you can't say that morphisms between the same objects are isomorphic?
21:05:27 <dmwit> glguy: I've got a lovely discrete category over here for your enjoyment, just 2c a pound.
21:05:37 <dmwit> sophiag: no!
21:05:50 <dmwit> sophiag: It's not even grammatical. Objects are isomorphic to each other, not arrows.
21:05:59 <parsnip> look, give me some credit, at least i read the bit where the types are the objects. 
21:06:15 <sophiag> dmwit: what about in a 2-category?
21:06:16 <dmwit> I mean, you *can* say it. But you have to be talking about a 2-category or something where your arrows are objects themselves in some other category.
21:06:22 <sophiag> jinx
21:07:04 <sophiag> i mean, we very often are talking about a 2-category in hask right? given the use of monads?
21:07:43 <dmwit> elaborate?
21:08:52 <sophiag> well, to the extent we're talking about the "monad hierarchy" we're talking about a 2-category where monads are monoids between functions
21:09:50 <dmwit> You'll have to unpack that a bit for me. If you don't care to I understand.
21:09:59 <sophiag> i'm sorry, i think i made what you were explaining origincally unnecessarily complicated
21:11:20 <nshepperd> what does objects being isomorphic to each other mean?
21:12:23 <dmwit> A and B being isomorphic means there is an arrow `f :: A -> B` and an arrow `g :: B -> A` for which `f . g = id` and `g . f = id`.
21:12:25 <sophiag> i wasn't the one who brought that up. i said morphisms are isomorphic to another in 2-categories and monads can be an example of that
21:12:58 <tobiasBora> Is there any way to "open" a module only inside a function? Because it's very annoying to put Mylibrary.(+++) everywhere inside a givent function, and if I use "import Mylibrary" without the qualified, the +++ will clash with others libraries...
21:13:08 <sophiag> but i'm sort of testing my understanding when i get to that... if memory serves me join is the binary operator?
21:13:19 <dmwit> tobiasBora: No, but you can give it a short name. `import qualified MyLibrary as M`.
21:13:57 <ChaiTRex> tobiasBora: You can also say whatsit = MyLibrary.(+++) and not export whatsit.
21:14:01 <dmwit> tobiasBora: Actually, you kind of can do it. `foo = ... where (+++) = (MyLibrary.+++)`
21:14:05 <tobiasBora> dmwit: Yes, but for symboles it's quite annoying to prefix everything with a letter (and at the end I have lot's of letters ^^)
21:14:05 <dmwit> oh yeah
21:14:16 <dmwit> tied with ChaiTRex =)
21:14:46 <tobiasBora> dmwit: ChaiTRex : Hum, it's a good idea...
21:14:48 <tobiasBora> Thank you
21:15:02 <ChaiTRex> You're welcome.
21:15:04 <tobiasBora> (By the way, is there any reason not to allow this kind of local opening?)
21:15:14 <dmwit> No, no reason. I've wished for it often, as well.
21:16:05 <dmwit> Well. Unless you count implementation simplicity (and simplicity for users, too) as a reason. =)
21:16:14 <dmwit> There is something to be said for stupid and simple.
21:17:25 <ertes> > (\(!)n->[(n-i)!' '<>i!'#'|i<-[1..n]])replicate 6
21:17:27 <lambdabot>  ["     #","    ##","   ###","  ####"," #####","######"]
21:18:05 <dmwit> Does <> have different fixity than ++ or something?
21:18:23 <isd> tobiasBora: Nothing wrong with the notion. Haskell's module system is pretty bare-bones in generally.
21:18:38 <glguy> dmwit: looks like <> is 6 and ++ is 5
21:19:20 <tobiasBora> dmwit: I'm not sure that's it's more friendly for the user to use "hiding" everywhere in the import section so avoid clash...
21:19:31 <ertes> dmwit: that's historical…  i had a different solution earlier, where i was using this instance:  instance (Monoid b) => Monoid (a -> b)
21:19:38 <dmwit> ah
21:19:53 <ertes> but the list comprehension turned out to be shorter =)
21:20:42 <dmwit> tobiasBora: I think `as` is pretty handy for avoiding clashes. I use it often, and I think many other Haskellers do, too.
21:21:05 <dmwit> If you write `BS.putStrLn` or `LBS.putStrLn` everybody in this channel is going to know exactly which module/package you meant. =)
21:21:35 <ertes> :t as
21:21:36 <lambdabot> error:
21:21:36 <lambdabot>     • Variable not in scope: as
21:21:36 <lambdabot>     • Perhaps you meant one of these:
21:21:38 <dmwit> T for Data.Text, M for Data.Map, S for Data.Set... there's a few other strong conventions but they don't come to mind immediately.
21:21:48 <dmwit> ertes: `import Foo as F`
21:21:57 <ertes> ah, that one
21:21:58 <dmwit> ertes: (usually also `qualified`)
21:22:07 <tobiasBora> dmwit: Yes, but the problems arrived if you want to be able to use some functions without adding letters before: for example it's horrible to write parsing with P. before each variable :P
21:22:13 <tobiasBora> *function
21:22:27 <dmwit> tobiasBora: That is an opinion that I no longer share.
21:22:38 <tobiasBora> really?
21:22:39 <dmwit> However I can understand that aesthetic.
21:22:51 <ertes> tobiasBora: you get used to it
21:22:53 <ertes> necessary evil
21:23:03 <ertes> i still maintain that haskell should just support ad hoc polymorphism
21:23:48 <tobiasBora> And why can't haskell "know" which function it refers to? Most of the time it's clear because of the concept...
21:24:49 <Sornaensis> can I install a package with stack using a .cabal file??
21:24:51 <dmwit> Do you have a proposal for how to know? Like, an algorithm?
21:25:09 <ertes> tobiasBora: haskell doesn't support ad hoc polymorphism…  it will stop as soon as it sees a name clash, instead of trying to resolve it via types
21:25:18 <kadoban> Sornaensis: You typically don't install packages with stack, unless you mean executable. You can certainly depend on a cabal package
21:25:37 <tobiasBora> ertes: oh, that's what you call ad hoc polymorphism
21:27:01 <ertes> tobiasBora: as soon as GHC implements -XAdHocPolymorphism, you can expect me to turn it on in pretty much every module =)
21:27:17 <ertes> but i don't think it will have that any time soon, so get used to those prefixes
21:27:27 <dmwit> Such an announcement could  be a good April Fool's post. =)
21:27:55 <ertes> i honestly would like to have that
21:28:14 <ertes> it would also solve the "record problem" we're apparently having
21:28:38 <dmwit> Do you have a proposal for how it would work that does not cause 99 other problems?
21:29:36 <tobiasBora> Ok
21:29:49 <ertes> my proposal is: use types to resolve name ambiguity and accept, if there is only one with a fitting type, and regarding those 99 problems: deal with it =)
21:31:10 <tobiasBora> By the way, do you have a way to convert a string into ByteString? The pack function is only for lazy ByteString, so the workaround I see would be to do String --> Lazy Bytestring --> Bytestring, but it's not very efficient, nor nice to read
21:31:37 <glguy> tobiasBora: There are two packs. One is for strict bytestrings
21:31:37 <kadoban> tobiasBora: The pack from the other module should do, there should be a lazy and a strict one.
21:31:38 <ertes> tobiasBora: what ByteString do you expect to get for "ä"`
21:31:39 <ertes> ?
21:31:58 <kadoban> Oh, ya that's a good question, disregard my answer.
21:32:33 <ertes> tobiasBora: remember that a String is a list of *characters*, not bytes
21:32:44 <tobiasBora> ertes: I don't mind, it's plain ascii I want to convert, so it could read it as utf8, I don't mind :P
21:33:05 <tobiasBora> Yes I know, but some functions are waiting for bytestring, so I can't do anything else...
21:33:12 <trudyjane> is there a ray tracing package out there that allows the scene to be described in haskell?
21:33:19 <ertes> tobiasBora: why ByteString though?  why not Text?
21:33:36 <ertes> ah
21:33:51 <tobiasBora> ertes: Don't know. It's for the proxy in conduit package.
21:34:16 <Sornaensis> kadoban: I had to reconfigure a package I got from hackage to get it to work
21:34:25 <Sornaensis> but I do not know how to install it with stack
21:34:27 <Sornaensis> so I can use it
21:34:29 <Sornaensis> :(
21:34:34 <kadoban> Sornaensis: Use it in what context?
21:34:38 <ertes> tobiasBora: even "it's all ASCII" has hidden assumptions, but it's usually safe to ignore that…  if it's really ASCII, you can use 'pack' from Data.ByteString.Char8
21:35:16 <ertes> tobiasBora: a good default choice (which subsumes ASCII) would be to use the utf8-string library
21:35:18 <kadoban> In a stack project? You specify it in your stack.yaml file usually, you can depend on local packages or ones in git repos (on github or etc.), there's a few options, depending on what makes sense.
21:35:21 <Sornaensis> kadoban: install it like I might do $ stack install blorps
21:35:33 <Sornaensis> but with the local source
21:35:54 <kadoban> Sornaensis: 'stack install' is really only for executables. But if you have local source, you can go into the directory, do 'stack init' and then 'stack install' if you like.
21:36:23 <ertes> trudyjane: there are a few on hackage, but i think most of them have bitrotted…  search for "raytrac" here: https://hackage.haskell.org/packages/
21:36:43 <dmwit> trudyjane: https://github.com/jtdaugherty/tracy/blob/master/src/Tracy/Types.hs#L203
21:37:03 <Sornaensis> kadoban: I see
21:37:07 <dmwit> ertes: Huh, I see just the one.
21:37:10 <ertes> trudyjane: and "ray trac"
21:37:20 <dmwit> ah
21:37:27 <trudyjane> ertes: Thanks : )
21:37:48 <Sornaensis> kadoban: is there a way to build with cabal and then install the result..?
21:38:06 <trudyjane> dmwit: OK, thanks : )
21:38:13 <Sornaensis> I'm trying to hack this together so I can see if it this package even works how I want
21:38:13 <kadoban> Sornaensis: Is this a library? You really should just depend on it in the relevant stack.yaml file.
21:38:22 <tobiasBora> ertes: Ok thank you. But the thing is that when I use "readFile", it's in string, so after I need to change everything... The lack of concensus on strings is quite annoying, each package seems to use a different version...
21:38:31 <kadoban> Sornaensis: 'stack init' and 'stack build' then?
21:38:40 <Sornaensis> kadoban: yes but the problem is the library is not configured correctly
21:38:48 <dmwit> Sornaensis: Just `cabal install` from within the directory that has the .cabal file.
21:38:49 <ertes> tobiasBora: you could use readFile from Data.ByteString
21:39:05 <ertes> tobiasBora: or indeed the file readers from conduit
21:39:05 <dmwit> Sornaensis: Wait, ignore me, I suspect I am dangerously missing context.
21:39:28 <kadoban> Well, not much. They asked about stack specifically, but I'm unsure why your solution wouldn't be fine for them checking if the thing builds anyway.
21:39:48 <kadoban> A bit unsure the actual goal.
21:40:50 <dmwit> I mean, `cabal install` will not make a package visible to stack probably.
21:41:05 <dmwit> So if continued usage of stack is part of the goal I'd be giving potentially wrong advice.
21:41:10 <glguy> Sornaensis: You can add this package's source directory to the packages: section of your stack.yaml
21:43:20 <trudyjane> Wow, the tracy ray tracer looks good. Yep, old stuff on hackage.
21:43:58 <tobiasBora> ertes: ok thank you
21:44:24 <tobiasBora> Is there any nice way to do something like "if exists <- doesFileExist pr" ? (I'm tired of using two lines for that...)
21:44:55 <ertes> tobiasBora: why are you doing it in the first place?
21:45:24 <tobiasBora> sorry, I mean "if doesFileExist pr", with doesFileExists IO()
21:45:39 <tobiasBora> ertes: Well I just want to check that a file exists...
21:45:54 <ertes> tobiasBora: and if it does, …?
21:46:09 <tobiasBora> when I go in the condition
21:46:15 <tobiasBora> I mean:
21:46:22 <tobiasBora> For now I write:
21:46:29 <tobiasBora> exists <- doesFileExist pr
21:46:34 <tobiasBora> if exists then ... else ...
21:46:49 <ertes> tobiasBora: i'm not asking about syntax, but about what your program actually does with that info
21:47:49 <tobiasBora> ertes: Well he can do plenty of things: send a message error if the file do not exists, are attribute a default value to the object build from this file...
21:48:34 <ertes> tobiasBora: the point is: if you're actually doing *any* other I/O with that file, you should just do that I/O in the first place and catch exceptions
21:48:53 <ertes> reason: there is a gap between doesFileExist and the actual I/O operation
21:49:23 <ertes> in other words: you need to handle exceptions anyway
21:49:29 <tobiasBora> Hum...
21:49:34 <tobiasBora> That's a good point
21:50:12 <tobiasBora> but for general culture, let's say that I've in place of doesFileExist a the function RandomRIO
21:50:28 <tobiasBora> and I want to check the the number is above a given n
21:50:42 <tobiasBora> Can I avoid the two lines structure?
21:50:54 <ertes> not if you use do/if
21:51:18 <tobiasBora> ok thank you
22:09:26 <lolisa> Hi, due to ambiguous type, I need to specialize an global function to a typeclass instance definition. Can I do that? (I can also use proxy to explicitly give type but I need a lot of Proxy then)
22:17:02 <ertes> lolisa: paste your code, please
22:17:30 <lolisa> ertes, got it, just a few second, hacking it right now
22:17:45 <lolisa> a few minute probably :)
22:26:49 <Sornaensis> gah I'm still confused. I just want to build and use this library but it still won't load after I've run the build process with stack
22:28:43 <lolisa> ertes, got it, see line 633. https://github.com/ThoughtWorksInc/DeepDarkFantasy/blob/master/src/DBI.hs
22:36:45 <ertes> lolisa: well, here is an immediate but minor improvement:  f :: proxy (a, b, c) -> …
22:37:04 <ertes> f (Proxy :: Proxy (A, B, C)) …
22:37:59 <ertes> but of course it would be best to help the type system figure it out for itself through unification, (injective) type families, functional dependencies, etc.
22:39:08 <lolisa> Yes, that's what I'm trying todo. Also it wont work since sub, sup are * -> Constraint...
22:39:22 <lolisa> (* -> * -> *) -> Constraint
22:41:38 <abed> Hi i'm having problems with my IO functionality on Haskell it cant properly store my output array and i don't know why
22:41:39 <ertes> for example Reify…  is this class really a general relation?  the type system will have no way to infer anything, unless it can unify
22:41:46 <abed> https://thepasteb.in/p/BghPjBoZOl2hY
22:42:00 <abed> if you can take a look the error occurs at test<-mednums []
22:42:22 <lolisa> dont worry about reify for now... It is gonna get refactored, wrong abstraction.
22:43:26 <ertes> abed: nitpick, but an important one: there are no arrays involved here…  you're using lists
22:44:12 <ertes> abed: and i'm assuming that you get a "no instance" error?
22:44:25 <ertes> no
22:44:29 <ertes> an ambiguity error
22:45:42 <abed> the error i got was Ambiguous type variable `a0' arising from a use of `mednums'
22:45:44 <abed> so yes
22:46:24 <ertes> lolisa: if you can't get inference to do that for you, you may find the TypeApplications extension useful
22:46:44 <ertes> abed: do you see why you get that error, and which particular function causes it?
22:47:20 <abed> i believe the reason its caused is cause im not properly inferring type from when i call test<-mednums[] i need to specify its an IO[integer] i think?
22:47:44 <lolisa> looking at it. right now the most painful thing is, I had to explictly use where, forall to scope the type r, can I do such implicitly?
22:47:45 <ertes> abed: nope (and you don't cast in haskell)
22:47:57 <ertes> > read "123" :: Integer
22:47:59 <lambdabot>  123
22:48:00 <ertes> > read "123" :: Rational
22:48:02 <lambdabot>  *Exception: Prelude.read: no parse
22:48:13 <ertes> > read "Just (5, 7)" :: Maybe (Integer, Double)
22:48:15 <lambdabot>  Just (5,7.0)
22:48:21 <ertes> abed: do you see the problem now?
22:50:56 <abed> i need to read the IO action of mednums[] something like read mednums[] and have it recognize its a list of integers so test <- read mednums[]::[Integer]
22:51:35 <ertes> abed: your reasoning is correct, although that piece of code is wrong
22:51:49 <ertes> abed: let n = read line :: Integer
22:52:33 <ertes> abed: but it would be better, if you got used to writing type signatures for top-level definitions:  mednums :: [Integer] -> IO [Integer]
23:06:47 <joneshf-laptop> What do people use for monitoring and error tracking? I only see the one New Relic library and it's years old now.
23:07:08 <ertes> joneshf-laptop: stderr
23:07:10 <joneshf-laptop> Some combination of ekg and log munging?
23:07:36 <joneshf-laptop> ertes, am I thinking about this idea incorrectly?
23:08:16 <ertes> joneshf-laptop: depends on your philosophy…  mine is that logs/diagnostics should always go to stderr
23:09:03 <ertes> practically speaking it also helps process supervisors like s6 actually bind your logs to something useful
23:10:25 <ertes> that way you can establish a real logging tree with proper log handling (think of log rotation, for example, which is often done incorrectly through something like logrotate)
23:13:22 <joneshf-laptop> Hmm.
23:21:18 <joneshf-laptop> Is that common?
23:21:40 <lolisa> Wait, can I made a member :: * -> [*] -> * typeclass?
23:21:52 <lolisa> * -> [*] -> Constraint
23:26:44 <glguy> lolisa: something like this? https://github.com/glguy/operations/blob/master/src/Object.hs#L70
23:28:08 <lolisa> glguy, just what I need.
23:29:22 <abed> So i need to calculate the median after receving user input atm i am sitting on top of a proper IO[Integer] should i sort and interact with that data type or is there a known way to convert from IO[Integer] to [Integer]?
23:30:14 <glguy> You can use your action that returns a list of Integer to make a new action that returns a single Integer, the median
23:30:26 <glguy> do xs <- getUserInput; return (median xs)
23:31:21 <ertes> joneshf-laptop: most people think that syslog is a good idea
23:31:47 <abed> so are you suggesting passing the IO[integer] into a different function that parses it and generates the median?
