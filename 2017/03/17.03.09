00:00:07 <`Guest03> the notion "any functions N -> N" is meaningless before we define the set of constructors for N
00:00:40 <`Guest03> it's a weird question
00:00:47 <quchen> `Guest03: Oh, good point! Maybe I don’t know what a function is either then ;-)
00:00:56 <dmwit> choose some fresh symbols, i'll call them zero and succ for absolutelp no reason ;-)
00:01:15 <quchen> dmwit: Resemblence to existing natural numbers is purely coincidential
00:02:14 <dmwit> define nat(s) = { zero } U { succ(n) | n \in s }
00:02:45 <dmwit> so for any set, we can ex.and the set by one this way
00:02:56 <dmwit> *expand
00:03:25 <`Guest03> why does 0 denote the number zero?
00:03:33 <dmwit> now i ask, are there any sets for which nat(s)=s?
00:04:41 <dmwit> turns out there are lots. but a few are special
00:04:44 <quchen> »ex.«?
00:04:55 <quchen> Oh.
00:04:57 <quchen> Nevermind.
00:05:13 <quchen> I see where this is going, but please carry on :-)
00:05:31 <dmwit> in particular there is a smallest such set
00:06:01 <dmwit> in the sense that it is a subset of any other set that has this property
00:06:34 <dmwit> that set looks suspiciously like the natural numbers
00:06:50 <quchen> What are other sets that satisfy nat(s)=s?
00:08:27 <dmwit> ones that have elements consistitg of infinitely-deeply-applied succ, e.g.
00:08:38 <SexHendrix> `Guest03: finished that problem finally
00:08:46 <SexHendrix> http://lpaste.net/353335
00:08:51 <SexHendrix> still seems like a right mess
00:09:16 <dmwit> rather than just infinitely many elemenns, each of which have only finitely deeply applied succs
00:09:37 <quchen> I see.
00:10:13 <`Guest03> omg
00:10:22 <`Guest03> why do you need [([Int], [Int])] ?
00:10:28 <dmwit> so one can and sometimes does take this as a def. of the nats
00:10:47 <SexHendrix> `Guest03: i got bored of constantly transforming the input
00:10:55 <SexHendrix> and like that it just about worked
00:11:02 <quchen> dmwit: But now we have another problem: you used »succ« in your definition. Where does that come from?
00:11:06 <`Guest03> also, "(fmap . fmap) read $ words" looks convoluted. do you understand the meaning of the first fmap?
00:11:24 <quchen> dmwit: zero I can see being just some arbitrary object. But succ has the same uniqueness problem I mentioned initially it seems.
00:11:28 <`Guest03> the first fmap is function composition
00:11:35 <dmwit> quchen: i told you: pick a fresh value
00:11:40 <quchen> dmwit: succ acts as a sort of tag, right?
00:11:43 <SexHendrix> i know fmap (fmap function) = fmap . fmap function
00:11:43 <`Guest03> which composes (fmap read) and words
00:12:07 <SexHendrix> i was trying to dig in twice
00:12:14 <dmwit> quchen: yep, sure
00:12:20 <quchen> dmwit: I guess I don’t understand what a fresh value is for a function
00:13:06 <dmwit> quchen: in fact it's not even im.artant that it be fresh, only that it be injective and distinguishable from zero
00:13:39 <quchen> It seems like it’s a function without a definition, that is, it has no ways to react on inputs.
00:13:49 <quchen> (Hence me seeing it as a tagging device)
00:14:25 <`Guest03> oh well
00:14:54 <`Guest03> i guess my metric of convolutedness was meaningless
00:14:58 <dmwit> quchen: e.g. succ(x) = (1, x); zero = (0, 0) is a fine choice if you are happy that we can def. 0, 1, and pairing
00:15:30 <quchen> dmwit: I see. (I’m happy with pairing and having some 0 and 1)
00:15:44 <`Guest03> aha.
00:15:55 <`Guest03> you use ([Int], [Int]) for pairs of points...
00:16:19 <`Guest03> you should use ((Int, Int), (Int, Int))
00:16:22 <`Guest03> but whatever
00:18:13 <dmwit> quchen: but often we don't care to make everything depend on set theory
00:18:15 <SexHendrix> noted
00:18:43 <dmwit> so we start from the inductive def. and go from there
00:18:49 <SexHendrix> i did have another magic' function that put it in [(Int, Int)]
00:19:00 <SexHendrix> but by then i already wanted to pull my eyeballs out
00:19:15 <dmwit> that is: zero is a nat, and if n is a nat, then succ(n) is a nat
00:19:50 <quchen> Sure, but that holds even if succ(n) ≡ 0.
00:20:01 <dmwit> this is simultaneously a def. of nat, succ, and zero
00:20:24 <dmwit> no, succ isn't just any old function
00:20:45 <quchen> Ah right, the (n,1) tuple example you gave.
00:21:18 <dmwit> implicit in my sentenge i guess is that succ is injective and not the identity
00:21:28 <quchen> dmwit: Hm. I guess »a type« is not simply the type, but the tuple (formation, constructors, elimination), and not merely the »ℕ«. So »the natural numbers« is (ℕ, {0, succ}, recurse) rather than just »the thing made with 0 and succ«
00:21:56 <dmwit> a similar implicit applies to other inductive def.s of course
00:22:25 <dmwit> quchen: absolutely agree
00:22:57 <quchen> so Tuple = (a -> b -> Set, a -> b -> Tuple a b, \f (Tuple a b) -> f a b)
00:23:23 <quchen> In the tuple case this makes much more sense, since we would never talk about »the tuple« the way we would talk about »the nats«
00:23:57 <quchen> So it’s harder to mistake »(,)« for »tuple«, compared to mistaking »0, succ« for »ℕ«
00:24:51 <`Guest03> i want to make a cool game in haskell.
00:24:59 <`Guest03> but i don't have ideas.
00:25:27 <SexHendrix> `Guest03: mastermind
00:25:37 <quchen> dmwit: So coming back to my original problem, which is explaining how succ+zero make ℕ to a very smart, but type-unfamiliar mathematician, I guess the postulate is »let zero be something and succ be an *injective* non-identity function from N to N« etc.
00:25:51 <SexHendrix> this one https://upload.wikimedia.org/wikipedia/commons/2/2d/Mastermind.jpg
00:26:05 <quchen> dmwit: I’m still not sure how to conclude that this forms exactly the natural numbers, but the injective part brings me a huge step further :-)
00:26:57 <dmwit> observe that the nats are a fixed point
00:27:20 <dmwit> then observe they must be a subset of any fixed point
00:28:24 <dmwit> (up to isomorphism everywhere)
00:29:18 <dmwit> or: what is your def. of "the nats"?
00:29:36 <osa1> is there a shorthand of `if this prism matches run this monad action otherwise return ()` in lens?
00:29:43 <ski> implicit in dmwit's sentence is that `nat' is defined in the least restrictive way, in order to support `zero' and `succ'. since `succ(n) = zero' doesn't need to hold if `zero' is an element and `succ' and endo-function, that means it doesn't hold, with `nat' being inductively defined like this
00:29:53 <ski> quchen : injectiveness follows from this
00:29:58 <osa1> similar to `case x of C1 (C2 (C3 x y z))) -> f x y z; _ -> return ()`
00:29:59 <dmwit> osa1: traverse does that
00:30:13 <dmwit> :t traverse_
00:30:15 <lambdabot> (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
00:31:08 <quchen> ski: »least restrictive« seems rather informal though
00:31:20 <jle`> osa1: if you have to use a prism then i think `traverseOf_ p` would work
00:31:22 <osa1> so for the `t a` part I need the lens expression that returns `Maybe (x, y, z)` ?
00:31:32 <dmwit> :t traverse_ :: Applicative f => (a -> f b) -> Maybe a -> f ()
00:31:34 <lambdabot> Applicative f => (a -> f b) -> Maybe a -> f ()
00:31:44 <osa1> OK
00:32:33 <osa1> thanks dmwit jle`
00:32:46 <ski> quchen : you can formalize it as the initial object in a specific category
00:33:02 <jle`> :t traverseOf_ _Just
00:33:05 <lambdabot> Applicative f => (b -> f r) -> Maybe b -> f ()
00:33:15 <jle`> :t traverseOf_ hex
00:33:17 <lambdabot> (Applicative f, Integral a) => (a -> f r) -> String -> f ()
00:34:18 <dmwit> i'm going to hand off to ski and get some sleep. enjoy
00:34:55 <quchen> dmwit: Thanks a lot for your explanations!
00:35:01 <ski> quchen : in this case, the objects of the category are triples `(X,z,s)', with `X' being a set, `z : 1 >---> X' and `s : X >---> X'. and a morphism `m : (X_0,z_0,s_0) >---> (X_1,z_1,s_1)' is a function `m : X_0 >---> X_1' such that `m . z_0 = z_1' and `m . s_0 = s_1 . m'
00:35:22 <quchen> dmwit: The obvious »constructors are injective« is invaluable for my understanding
00:35:39 <quchen> Not that I didn’t know that, but I didn’t *know* it ;-)
00:35:52 <ski> .. if you prefer, you could take `X' as being an object in an arbitrary "base" category `C', and then `m : X_0 >---> X_1' is a morphism in that category `C'
00:37:02 <ski> in the former case, the initial object in this new category is `(|N,zero,succ)', the natural numbers. the initiality of this object gives you fold (catamorphism)
00:37:17 <quchen> Categories unfortunately make things much less clear for me, usually. :-(
00:37:19 <ski> in the latter case, you call it "a natural numbers object in `C'"
00:39:43 <ski> quchen : anyway, apart from "constructors are injective", you also get "constructors are disjoint", and also that if you build a function `\x -> ..x..', `..x..' being an expression built by using `x' and the constructors, then this function is the identity only if the expression is `x' itself
00:40:18 <ski> the latter means there is no `n' with `n = succ(n)', e.g.
00:40:36 <quchen> I see, so you get a lot of mileage out of that definition then.
00:42:00 <quchen> But leaving away the higher math, one could say that constructors are injective, not the identity, and disjoint.
00:42:23 <quchen> The »has no fixed point« property is a speciality of the ℕ successor.
00:42:49 <ski> in a more general setting, one'd have both constructors/generators, and given *equations*/relations/laws between them (cf. generating e.g. a group from a set of generators, and a set of "relations" between them)
00:44:15 <ski> e.g. one could specify a category where objects are `(X,z,s,p)', with `X' a set, `z : 1 >---> X', `s : X >---> X' and `p : X >---> X', subject to `s . p = id' and `id = p . s'
00:44:27 <ski> the initial object here would be the integers
00:44:55 <ski> (so in this case the "constructors" are not disjoint, due to the presence of the laws)
00:45:40 <quchen> Not disjoint in the sense that 0 is possibly both a »s« and a »p«?
00:46:43 <ski> yes
00:46:59 <`Guest03> how to define infinite graphs?
00:47:34 <jle`> it depends on your graph type
00:48:00 <`Guest03> uh
00:48:03 <`Guest03> just graph?
00:48:07 <`Guest03> undirected
00:48:13 <ski> quchen : this latter would be an example of an archic algebra (iow having, or being subject to, laws). the former (the peano natural numbers) being an anarchic algebra (no laws)
00:49:14 <ski> any object of the category in question would be an algebra. the initial object is the "initial algebra", the naturals in one case, the integers in the other
00:49:23 <jle`> `Guest03: usually the type will provide some way in its API
00:49:30 <jle`> i mean, the data type that implements your graphs
00:49:41 <jle`> or are you talking about it mathematically?
00:49:56 <quchen> ski: The »initial« gives you what dmwit called the »smallest« then?
00:50:02 <`Guest03> yes, mathematically
00:50:04 <ski> yes
00:50:32 <jle`> `Guest03: an infinite graph is defined as a graph that is not finite
00:50:56 <ski> if you want to specify monoids, then objects are `(X,n,m)' with `X' a set, `n : 1 >---> X' and `m : X * X >---> X', subject to `forall y. m(n(),y) = y', `forall x. x = m(x,n())', and `forall x,y,z. m(m(x,y),z) = m(x,m(y,z))'
00:51:14 <`Guest03> how to define graph*s*
00:51:36 <Cale> `Guest03: Perhaps by an adjacency function?
00:51:46 <jle`> do you mean how to describe a specific graph?
00:51:56 <Cale> If you want to be able to define graphs on infinite sets, that might be the way to do it.
00:52:03 <Cale> It really depends on what operations you need on graphs
00:52:10 <ski> the initial monoid is here also the natural numbers, with `n() = 0', and `forall x,y. m(x,y) = x + y'
00:52:34 <Cale> Or wait, you just want a mathematical definition of graphs, not a Haskell one?
00:53:49 <ski> to specify "monoids generated from a set `S'", you have objects `(X,n,m,i)', with `(X,n,m)' as above and `i : S >---> X'. `i' acts as an "inclusion" function from your set of generators `S' into `X'
00:53:50 <Cale> A (simple, undirected) graph consists of a set V of vertices, and a set E of unordered pairs of distinct elements of V, called edges.
00:54:02 <`Guest03> sorry i don't inderstand your question Cale
00:54:18 <`Guest03> but i probably need a haskell definition
00:54:29 <`Guest03> judging by this name..
00:54:38 <`Guest03> i need to be able to
00:54:41 <`Guest03> walk them
00:54:55 <`Guest03> and store / load info in current vertex
00:55:02 <ski> the initial object in this case is the type `[S]' of finite lists of inhabitants of `S'. `i' is here the singleton function : `forall s. i(s) = [s]', and obviously `n() = []' and `forall xs,ys. m(xs,ys) = xs ++ ys'
00:55:18 <Cale> Ah, well, as soon as you want to start writing algorithms, you care a lot more about exactly how the thing is given. Usually I find that something along the lines of Map Vertex (Set Vertex) is a good representation.
00:55:33 <ski> quchen : does this make any vague sense at all ?
00:55:34 <Cale> With variations on that to be able to label the vertices and edges.
00:56:13 <Cale> You can independently store a labelling on vertices as a separate Map Vertex Label
00:56:56 <Cale> Sometimes if you're labelling the edges as well, it's better to use something like Map Vertex (Map Vertex Label)
00:57:18 <`Guest03> jle`: yes
00:57:24 <`Guest03> but not a specific graph
00:57:36 <`Guest03> just what are some ways
00:57:50 <Cale> Note that you'll need to be somewhat cautious if your graph is meant to be undirected here -- you can always encode an undirected graph as a directed one where every edge consists of two arcs going in opposite directions
00:58:16 <Cale> Another way is to encode it via a function which describes whether vertices are adjacent.
00:58:18 <quchen> ski: Yes, vaguely. :-)
00:58:26 <quchen> ski: I recognize most words :-þ
00:58:29 <Cale> i.e. Vertex -> Vertex -> Bool
00:58:55 <Cale> Or a function which tells you the set of neighbours of a given vertex
00:58:59 <Cale> Vertex -> Set Vertex
00:59:04 <quchen> ski: I just have difficulties working with initial objects and terminal ones because I’m not very used to them. But taking initial as smallest works well enough
01:00:06 <Cale> When I wrote http://hackage.haskell.org/package/astar, I went with that... it looks like Johannes went and changed it to use HashSet instead for some reason, I'm not sure how happy I am about that one :)
01:00:26 <Cale> http://hackage.haskell.org/package/astar-0.3.0.0/docs/Data-Graph-AStar.html
01:00:26 <ski> quchen : anyway, if we go back to the case of "natural number algebras", being objects `(X,z,s)', `X' a set, `z : 1 >---> X', `s : X >---> X', and with the stated requirement on morhphisms to "preserve" this "structure". then an example such object in this category is `(Bool,True,not)'. makes sense ?
01:00:43 <ski> well, `(Bool,\() -> True,not)' i really should say
01:02:04 <quchen> ski: Sooo the natural numbers are: 1. the type ℕ formed out of thin air; 2. the two injective, disjoint, non-identity functions Z : ℕ and S : ℕ → ℕ, and the elimination »elim : ∀ C. C -> (ℕ -> C -> C) -> ℕ -> C« with elim z f 0 = z; elim z f (S x) = f x (elim z f x)
01:02:52 <quchen> Showing the injection from this into the natural numbers as we know it seems easy enough, I wonder how to do the reverse.
01:02:53 <ski> quchen : the eliminator is given by the initiality
01:04:04 <quchen> ski: That is, »yes, but part of what you said was redundant«?
01:04:13 <ski> the eliminator is the initial object morphism `elim z f : (ℕ,0,S) >---> (C,z,f)'
01:04:21 <mbrock> with lenses foo and bar, when I do "let x = foo . bar" that seems to overspecify x's type in a way that prevents me from doing both "x . baz" and "x . qux" when baz and qux have different target types...
01:04:55 <ski> quchen : .. rather, an alternate way to understand it, in terms of initial algebras
01:05:04 <mbrock> it's always confusing to me when introducing a let binding for a common expression messes with type inference
01:05:09 <`Guest03> i don't know whether my question is related to graph's underlying data structure
01:05:45 <`Guest03> or to a "way of defining" for a particlar graph
01:05:52 <ski> mbrock : DMR ?
01:06:25 <mbrock> I do actually have the NoMonomorphismRestriction language feature on
01:06:55 <`Guest03> initially it is about latter, but those two layers seem to be interwoven
01:12:56 <quchen> Does anyone have an example of a non-type-inferrable definition without type classes? I vaguely remember a small example by Richard Eisenberg that looked similar to »f (x:xs) = x : zipWith f xs xs«.
01:13:13 <quchen> The crux was that polymorphic recursion is a problem.
01:15:07 <ski> quchen : yeah, i was just thinking polymorphic recursion would probably be involved, then i saw you said that :)
01:15:40 <quchen> It also involved zip(With). :-)
01:15:55 <quchen> The polymorphic recursion was a ---> [a]
01:16:01 <quchen> That’s all I remember :-(
01:16:06 <quchen> And it was a short definition.
01:16:24 <ski> > let length [] = 0; length (_:xs) = 1 + length (map (:[]) xs) in length "abc"  -- how about this one ?
01:16:29 <lambdabot>  error:
01:16:29 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ [a]
01:16:29 <lambdabot>        Expected type: [[a]] -> t1
01:16:37 <ski> > let length :: [a] -> Int; length [] = 0; length (_:xs) = 1 + length (map (:[]) xs) in length "abc"
01:16:41 <lambdabot>  3
01:16:52 <ski> works with a type signature
01:16:57 <quchen> Good one!
01:23:20 <Unhammer> Can I put the path to my system ghc in stack.yaml somewhere? (so I can e.g. install both 7.8.4 and 7.10.3 from ppa's instead of compiling for each computer …)
01:25:49 <SexHendrix> hm, how come the lambdabot in here supports multiline stuff with semicolons but mine doesn't
01:27:28 <Unhammer> mine = your bot or your ghci?
01:28:05 <SexHendrix> nvm missed the `in`
01:32:05 <`Guest03> ski: why can't a compiler infer the type?
01:35:21 <ski> `Guest03 : the type of the recursive use of `length' isn't the same as the type of the current call to `length'
03:09:46 <nshepperd_> Huh. I suppose translating polymorphic recursion to an application of fix doesn't work there, because it would be impredicative?
03:10:22 <nshepperd_> Like you need a specialised rank 2 fix
04:17:26 <muzzle> is it possible to use the GHC-tokenizer as a library?
04:17:44 <muzzle> I want to tokenize haskell code at runtime in my program
04:17:57 <muzzle> and I would really like to use a given haskell tokenizer
04:18:04 <muzzle> and possibly other parsing steps
04:21:59 <lyxia> muzzle: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc-8.0.1/Lexer.html ?
04:24:46 <tfc> hey there, i am currently implementing a parseJson function using aeson library to parse from json to my own types. i have type "Foo A String String", and my parser looks like parseJson (Object o) = Foo <$> o .: "key1" <*> o .: "key2", which works great. Now i switched from Foo String String to Foo A String. For type A, i have a Parsec parser function of type Parser A. but i can't fiddle out how to combine THAT now. can anyone help me
04:24:46 <tfc> ?
04:25:12 <tfc> sorry first type was "Foo String String", then the upgrade is "Foo A String"
04:26:25 <Rembane> tfc: What's the type signature of your parser?
04:26:40 <tfc> parse_func :: Parser A
04:26:48 <muzzle> lyxia thx, I failed at google...
04:27:21 <tfc> Rembane i can already write "parse parse_func "" "some input string which can be parsed to an A instance"
04:27:45 <tfc> in my json the object at "key1" is a string which i need to parse into an A 
04:28:31 <Rembane> tfc: What happens if you replace this `o .: "key1"` with: `(o .: "key1" >>= parse_func)`
04:28:38 <tfc> one moment
04:30:20 <tfc> couldnt match "Text.Parsec.Prin.ParsecT String () Data.Functor.Identity.Identity A" with "a0 -> Parser a"
04:30:57 <tfc> so aeson wants a "a -> Parser A" and i only have "Parser A" (but a parsec parser)
04:31:08 <novakboskov> Somewhere I've read a good point which been said like "Haskell basically have two languages, one _____ which is before :: sing and type language which is after :: sign...". Is there name for that first language, that one which remains when type language is separated?
04:31:55 <hpc> the right word for what you're thinking of is "levels"
04:31:58 <hpc> the type level and the value level
04:32:11 <hpc> above the type level is the kind level
04:33:42 <hpc> the TypeInType language extension makes it so kinds are the top level
04:33:48 <hpc> values :: types, types :: kinds
04:33:52 <hpc> and with TypeInType, * :: *
04:34:30 <hpc> otherwise there is a simple "sort" system above kinds that never shows up in code
04:36:59 <tfc> Rembane maybe you have an idea how i can use "String -> Either ErrStr A" in aeson to get an A or fail?
04:37:42 <Rembane> tfc: Supply a string to that function and pattern match on the result?
04:38:24 <tfc> yes but if i do a "case foo of Left _ -> fail "blabla" Right aInstance -> return aInstance" it's still a type error
04:38:58 <Rembane> tfc: What types does it want?
04:40:13 <tfc> Rembane sheesh... i somehow got it working now. not sure what i made different from before. let me test it... will report back
04:40:27 <Rembane> tfc: More brackets? :D
04:40:29 <Rembane> tfc: Good luck!
04:41:43 <tfc> ok, it actually works... so i have Foo <$> o .: "key1" <*> o .: "key2" again, and then instance FromJSON A where parseJson (String s) = case parse aParser "" (unpack s) of Left _ -> fail "blabla" Right m -> return m
04:41:57 <tfc> and that does the job. although it looks pretty clunky to me with the unpack etc.
04:42:44 <Rembane> It is indeed, it's the curse of having a gazillion string types.
04:44:11 <tfc> Rembane: too bad. all the string types are really a curse. it's all in all less a curse than programming in other languages.
04:45:35 <tfc> Rembane: thx for your help!
04:45:38 <Rembane> tfc: Indeed.
04:45:41 <Rembane> tfc: No worries! :D
04:46:05 <tfc> Rembane alone for the parsing i love haskell. :D
04:46:30 <Rembane> tfc: It's really nice! So powerful, so succinct.
04:54:39 <Wizek> if I'd like to specify a local package as a dependency for a cabalized project, in theory all I need to do is `cabal sandbox add-source /local/path/to/package/`, right?
04:56:43 <erisco> "string" is vague and that is why you see various implementations of it
04:59:18 <dminuoso> erisco: Mind my asking since I was curious about this, what is vague about it?
04:59:44 <erisco> tell me what it is
05:06:06 <maybefbi> will anyone share their haskell development salary with me? you can /msg me if you dont want it to be public
05:06:25 <erisco> mine is $0
05:06:32 <maybefbi> mine too
05:07:34 <erisco> I am looking for fix succ dollars
05:08:29 <robertkennedy> I work in data analytics and use Haskell to get my work done, bit I'm not a dev. Making 60k in Boise Idaho USA
05:09:55 <nilof> Out of curiosity, is it common practice to not include the prelude and use a different standard library?
05:11:19 <dminuoso> erisco: I would say it's just a list
05:11:30 <erisco> I don't think so, but it can be selectively imported when it is in the way, such as if you want (.) from Control.Category instead
05:12:19 <erisco> dminuoso, a list of characters? what is a character? and then does Text and ByteString not qualify because they are not lists?
05:36:22 <novakboskov> Is there any counterpart of fields reuse (through class inheritance in OOP) here in haskell?
05:37:26 <liste> novakboskov: https://github.com/adamgundry/ghc-proposals/blob/overloaded-record-fields/proposals/0000-overloaded-record-fields.rst
05:38:22 <liste> novakboskov: also https://downloads.haskell.org/~ghc/master/users-guide/glasgow_exts.html#duplicate-record-fields
05:41:10 <Cale> novakboskov: Ignoring the language extensions (which are somewhat questionable, imo), usually we just factor things to pull out common substructures into their own type.
05:41:57 <Cale> novakboskov: If you have a bunch of types which are related by having similar fields, it's quite probable that you really want a type for the fields that they have in common instead.
05:42:55 <novakboskov> liste: Thanks for directions.
05:43:41 <novakboskov> Cale: It makes sense too ... :D
05:45:06 <Cale> If you know about lenses, it's also possible to define a type class which defines one or more lenses for accessing common fields, and there's some template haskell machinery for doing that included with the lens package if you want to go that way.
05:45:54 <Cale> I've not often found it necessary to go quite that far
05:47:00 <Cale> But some kind of type class might be in order -- you might not just have it give you a lens, but instead, operations that are more specific to your application.
06:20:59 <Athas> What's the simplest way to do a parallel map?
06:21:08 <Athas> (Over a list.)
06:21:52 <c_wraith> parallel or concurrent?
06:22:08 <Athas> Parallel.  Pure code.
06:22:26 <c_wraith> list isn't a great structure for that, but sometimes it works
06:22:41 <Athas> Something from Control.Parallel.Strategies, maybe...
06:22:42 <arun_t> please let me know how haskell embrace immutability?
06:22:51 <c_wraith> yeah, it has combinators for lists
06:22:52 <Athas> These lists will typically be quite short, so it should be OK.
06:23:29 <c_wraith> there's parList and parListChunk
06:23:40 <quchen> arun_t: All variables are constant.
06:23:45 <c_wraith> or parMap
06:23:52 <c_wraith> err, *and* parMap
06:24:06 <arun_t> quchen: what about data structures?
06:24:37 <quchen> Variables whose values are data structures are just as constant.
06:25:18 <quchen> You can do things that do mutable updates in memory if that’s what you’re getting at. But it’s rarely necessary.
06:25:18 <Athas> c_wraith: so 'evalList rpar' would be a good strategy to apply to my list?
06:25:18 <arun_t> so mutation is not even possible
06:25:56 <Athas> Or... 'parList rseq'?  What's the difference?
06:26:00 <quchen> The compiler mutates lots of things, but that’s not visible on in the code :-)
06:26:05 <quchen> s/on//
06:26:11 <tabaqui1> can I combine function in one infix function?
06:26:13 <tabaqui1> alike
06:26:13 <c_wraith> Athas: maybe just parMap rseq
06:26:23 <tabaqui1> a `pure (&&)` b
06:26:32 <Athas> c_wraith: yes, that looks the simplest.
06:26:46 <c_wraith> Athas: there are a lot of equivalent options.  It's just a matter of what conceptual building blocks you want to use. :)
06:26:49 <bodisiw> quchen, are those impure operations, or ffi kinda things?
06:27:25 <tabaqui1> *a <*> `pure (&&)` <*> b
06:27:31 <tabaqui1> argh
06:27:33 <tabaqui1> dunno
06:27:41 <tabaqui1> wrong too
06:28:04 <arun_t> quchen : what do you mean by this line variables whose values are data structures are just as constant Please explain?
06:28:12 <tabaqui1> nevermind
06:28:18 <Athas> c_wraith: yes, I see.  Are these things frequently used in practice?
06:28:29 <quchen> arun_t: x = [1,2,3] -- A list is a data structure, and x is immutable.
06:28:34 <ongy> c_wraith: what's better suited for parallel evaluation than lists?
06:28:44 <quchen> We can’t change the 1 there. We can make a new list that has a different first element though.
06:28:55 <Wizek> Has anyone of you encountered an error like this before? /usr/bin/ar: .stack-work/dist/x86_64-linux/Cabal-1.24.0.0/build/Spec.o: No such file or directory
06:29:01 <merijn> ongy: arrays and vectors :p
06:29:05 <quchen> bodisiw: The compiler can mutate whatever it wants, as long as this preserves the semantics of Haskell :-)
06:29:27 <quchen> bodisiw: Most importantly, when you evaluate a thunk, its result is often written over the memory location of the former thunk
06:29:48 <bodisiw> right, i meant if you explicitly want to peek/poke (or whatever), that would have to be through IO monad?
06:29:54 <quchen> That’s a real mutable update in your RAM (or cache or whatever)
06:29:55 <merijn> bodisiw: There is a crucial distinction between "what the compiler/compiled code *does*" and "what we can observe it to do" :)
06:29:57 <bodisiw> i might be way off base... i am still real new
06:30:08 <c_wraith> Athas: occasionally, but the wins often are small, so they're usually very limited in scope
06:30:13 <arun_t> quchen: so how we can solve problems in haskell which needs mutable states in program
06:30:32 <merijn> arun_t: Haskell supports mutable state in a bunch of different ways
06:30:43 <quchen> arun_t: Many problems don’t need mutable state :-) And for when you *really* need mutable state, you can go back to using IO or ST.
06:30:48 <Athas> c_wraith: do you know of any "production" Haskell programs (or libraries) that do?
06:30:54 <quchen> Preferrable ST.
06:30:57 <merijn> arun_t: IO based operations, STM, the ST monad, etc.
06:31:00 <c_wraith> ongy: lists are a completely serial data structure - evaluating them in parallel only makes sense if most of the calculation goes into figuring out the element at each location, and there aren't dependencies between the elements.
06:31:08 <Athas> I had trouble finding real users of things like Repa or Accelerate, but this looks more accessible, maybe.
06:32:15 <merijn> Yeah, accelerate is like most high-level GPU tools in that people who want GPU performance don't use it
06:32:22 <c_wraith> Athas: monad-par might be used more - it's a bit simpler conceptually than Strategies, though it requires bigger code changes to use
06:32:31 <merijn> And people who don't need GPU performance don't have a use for using accelerate that much :p
06:32:41 <arun_t> merijn: why i need IO based operation to handle the mutable state in simple program, & i don't anything about monads? 
06:32:57 <Athas> merijn: not a lot of HPC people using Haskell; agreed!
06:33:21 <merijn> I would've loved using Haskell bindings for CUDA, but the existing ones aren't what I'd like
06:33:45 <Athas> What would you like?
06:33:50 <arun_t> merijn: quchen: I'm confuse about choosing b/w a lisp or haskell? to learn
06:34:10 <merijn> Athas: Higher level control flow descriptions and data marshalling
06:34:33 <Athas> arun_t: pick Haskell.  I used to be a (Common) Lisp programmer for many years.  It's a great language.  I switched to Haskell because Lisp is at the top of its power curve.  You can't really add anything without first taking something away.  On the other hand, Haskell still grows.
06:34:42 <merijn> arun_t: I'd say pick Haskell, because it's more different. I daresay that looking at lisp after haskell will be very easy
06:34:45 <c_wraith> ongy: most lists in Haskell end up being either super-simple so that the overhead of parallel evaluation isn't worth it, or there are evaluation dependencies between consecutive elements so they can't usefully be evaluated in parallel
06:34:47 <Athas> merijn: do you get that in C++ CUDA?
06:34:51 <merijn> arun_t: So if you've skipped list you're not losing much
06:35:13 <merijn> Athas: No, but then I don't have to worry about bindings and potential overhead in the FFI fucking up my benchmarks
06:35:19 <quchen> arun_t: Haskell is the better functional language (with its focus on purity, encapsulating effects, equational reasoning). Lisp’s strength is its macro system and that code and data share the same domain, allowing pretty interesting solutions to problems.
06:35:35 <bodisiw> hopefully this is an easy beginner question... i've got an Either String DynamicImage in ghci... what's needed in between to pass it to a (DynamicImage -> Image PixelRGBA8) ?
06:35:51 <merijn> arun_t: IO prevents the mutability leaking into other operations. As for the monad part, it's not really relevant here, since IO would work the same if monads had never been discovered :)
06:36:09 <merijn> bodisiw: You probably want fmap?
06:36:22 <bodisiw> ahh, thanks
06:36:32 <merijn> bodisiw: What do you expect to happen if you get a String instead of an image? That's presumably an error
06:37:30 <bodisiw> merijn, i believe that's correct... since i'm working on ghci, i'd like to ignore it.  but really i'm just trying to understand... in a program, i _must_ handle both sides
06:37:42 <ongy> c_wraith: I don't see how the datatype would influence most of that. Provided the spine of the list is easy to compute and the content is the complex stuff
06:37:51 <bodisiw> to satisfy the semantics? like, that's the whole point of it being defined that way?
06:38:22 <merijn> bodisiw: Yes
06:38:33 <sshine> I've got a datatype Foo = Alice | Bob, and I'd like for Show Foo to only show the first letter, so deriving Show does too much. is there any neat way to derive a Show that's based off the default derive?
06:39:01 <Cale> sshine: I wouldn't use show for that...
06:39:02 <merijn> bodisiw: But you can just pattern match "case myResult of Left _ -> putStrLn "Error!"; Right img -> processImage img"
06:39:18 <merijn> bodisiw: I mean, 'fmap' is basically doing the same
06:39:29 <sshine> Cale, I have actually got a little PP type class for it, but can I still derive?
06:39:32 <Cale> sshine: It's usually most convenient for show to produce valid source code for reconstructing values, whenever possible
06:39:38 <sshine> Cale, right!
06:39:50 <sshine> Cale, it's just that while I'm testing, I'm chaining my PP to Show :)
06:39:51 <arun_t> quchen: what is equational reasoning in haskell? merijn: can you explain more about IO use case and monad use case for mutable state?
06:39:54 <bodisiw> nice -- i think i need to understand the sugar and unsugar way... finding it kind of tough to learn both at once
06:40:12 <Cale> Well, you can derive show, and then write your pretty printing function to use the first letter that show gave.
06:40:20 <sshine> hmm, I'll stick with that.
06:40:25 <merijn> bodisiw: What do you mean by sugar? fmap isn't sugar, it's just a function
06:40:42 <bodisiw> 'case...of' ?
06:41:06 <c_wraith> ongy: well, compare that to a binary tree.  Even if the children are hard to compute and the elements are easy, it parallelizes easily.  It's just far more difficult to get data dependencies that mess up parallel evaluation.  (spark floods are a different and more likely issue, though, which require some care in a different way)
06:41:16 <merijn> bodisiw: case of is just pattern matching, it's the exact opposite of syntactic sugar :)
06:41:33 <bodisiw> dang!  one day i will get this all straight :-)
06:41:40 <merijn> bodisiw: Like, if there's anything in Haskell that is not sugar, but direct mechanical behaviour it's case-of :p
06:42:01 <c_wraith> in Haskell, if/then/else is syntactic suger. :)
06:42:09 <merijn> bodisiw: You're familiar with pattern matching while writing functions, right?
06:42:30 <merijn> bodisiw: The compiler just translates those into case-of expressions
06:42:54 <bodisiw> i've read about guards and such, but cant write them intuitively yet
06:42:56 <Cale> Yeah, one can imagine that at some level, the only reason that anything is ever evaluated is because it is the scrutinee of a case expression which needs to know which constructor matches.
06:43:39 <Cale> (and everything else that does pattern matching or causes evaluation is syntax sugar for case expressions)
06:44:23 <bodisiw> i love this aspect of haskell
06:44:32 <bodisiw> though obviously still struggling with it
06:44:48 <Cale> There is in reality at least one exception to that, because when you have something like seq f y where f is of function type, then you can't cause the function to similarly be evaluated using case
06:45:31 <Athas> A lot of people were upset in the 90s because of that!
06:45:45 <Cale> (seq is primitive and ensures that its first argument is evaluated before resulting in its second argument)
06:46:10 <bodisiw> Athas, i admit i usually code for the 'happy path'... because i am lazy
06:46:21 <Cale> Yeah, it screws up the denotational semantics a bunch
06:46:22 <bodisiw> but haskell and i can't both be lazy ;-)
06:46:48 <Athas> bodisiw: well, that's fine.  I think good language (and program) design requires compromises for practical reasons.
06:47:07 <Athas> Haskell only compromises in a very few places.  Look at OCaml for a language that perhaps compromises a bit too much.
06:48:46 <quchen> arun_t: Equational reasoning is what you do in math a lot: insert definitions to simplify things. For example, if you know that f(x)=2*x, then f(4) can be shown to be equal to 2*4. It’s a trivial example, but equational reasoning goes a *long* way. For example, »map id list = list« allows you to drop a loop from your program.
06:49:15 <quchen> Equational reasoning allows us to do pretty complex program transformation in our heads, and the compiler catches most errors humans make :-)
06:49:46 <quchen> Aaaand he’s gone
07:01:53 <dredozubov> does -O2 work for libraries nowadays?
07:02:20 <dredozubov> I always thought it doesn't, but i saw some conflicting opinions on the internet. :)
07:02:53 <Cale> dredozubov: I'm unaware of any point in time at which it didn't.
07:04:02 <shapr> Is there a collection of documents about structuring libraries/programs?
07:04:15 <c_wraith> cabal/hackage warn against -O2, but it's always worked.
07:04:37 <c_wraith> They just are suggesting that for most libraries, -O2 doesn't help much but significantly increases install time
07:05:04 <c_wraith> Of course, the cases where it does help the most are the same ones it increases install time the most...
07:05:22 <c_wraith> *cough* vector-algorithms *cough*
07:07:06 <dredozubov> basically i have a multi-package repo that i usually build with stack/nix
07:07:31 <dredozubov> nix have an override to build with -O2 for production builds
07:07:50 <dredozubov> but i'm wondering if i should set it in ghc-options in .cabal files
07:08:13 <bennofs> dredozubov: i don't think you should set it in .cabal files
07:09:00 <dredozubov> any explicit pro/cons?
07:09:37 <dredozubov> defaulting .cabal to -O0 sounds reasonable for all kinds of development feedback loops
07:10:05 <bennofs> dredozubov: it's might be hard to override if it's set in ghc-options 
07:10:41 <dredozubov> how is that different from omitting it? It defaults to -O afaik.
07:11:14 <merijn> dredozubov: You can do even better for development feedback loops
07:11:35 <merijn> You can incidentally locally override what cabal does
07:11:49 <merijn> If you change your .cabal/config you can have it build everything with -O2
07:14:11 <dredozubov> that doesn't sounds particularly good for development :)
07:14:31 <merijn> dredozubov: No, the one that speeds up development is '-fno-code'
07:14:40 <merijn> That just does typechecking, no code generation
07:14:46 <merijn> It's superfast combined with -O0
07:15:30 <dredozubov> i need to try that
07:15:43 <dredozubov> i'm not super happy with intero
07:16:05 <dredozubov> so i'm looking for a way to make typecheck-report faster in some other way
07:16:26 <merijn> dredozubov: I have ghc-mod setup to always use '-O0 -fno-code' for that reason
07:16:28 <dredozubov> launching stack on every check is not really fast
07:16:47 <dredozubov> i was wondering if i should hook flycheck to 'stack build --file-watch'
07:17:03 <dredozubov> but it requires writing some cringe-worthy elisp
07:17:28 <dredozubov> merijn: good tip!
07:21:01 <ertes> dredozubov: why do you even compile?  i just use GHCi during development (or rather my emacs + haskell-interactive-mode does)
07:22:33 <dredozubov> haskell-interactive-mode doesn't work with multi-package repos
07:22:42 <dredozubov> so it's out of the question for me
07:22:58 <ertes> dredozubov: "work"?
07:23:03 <dredozubov> intero doesn't seem too stable with my setup either
07:23:18 <ertes> dredozubov: or rather: what is a "multi-package repo"?
07:23:52 <dredozubov> and i use compilation-mode to find the next error that usually occurs in some arbitrary module
07:24:15 <dredozubov> ertes: a lot of cabal-packages depending on each other
07:24:19 <ertes> h-i-m does the same without compilation…  it even reuses next-error
07:24:25 <dredozubov>  > "work"?
07:24:38 <dredozubov> it's a work project if that's what you're asking
07:24:45 <ertes> dredozubov: that's a weird thing to say, considering that i do have those locally
07:25:17 <ertes> but i don't know much about stack…  in my setup nix handles those dependencies quite transparently
07:28:26 <dredozubov> i have ~20 packages in one repo
07:28:47 <dredozubov> i remember doing cabal yadda-yadda add-source
07:28:53 <dredozubov> and it felt like pure madness
07:29:01 <dredozubov> so i switched to stack and never looked back
07:30:33 <ertes> dredozubov: the workflow is: C-c C-l, then h-i-m will first check whether the cabal file has changed and restart my nix-ghci wrapper script if necessary (it just wraps GHCi in nix-shell), then reloads the module…  after that i use next-error to cycle errors
07:31:08 <ertes> dredozubov: i don't have any of that…  i just have a nix expression that specifies my local packages globally
07:31:26 <ertes> it's in ~/.nixpkgs/config.nix
07:31:52 <dredozubov> can you share a gist of it?
07:32:05 <dredozubov> i'm interested how that works
07:35:31 <ertes> dredozubov: here is the config.nix: https://github.com/esoeylemez/config/blob/master/files/.nixpkgs/config.nix
07:36:39 <ertes> this one specifies local overrides for packages…  in your case you would have to do without asGit, because it assumes that each git repo is a package
07:37:26 <ertes> this is my wrapper script (h-i-m fires up this one instead of "ghci"): https://github.com/esoeylemez/config/blob/master/bin/nix-ghci
07:38:12 <dredozubov> i have to run now, but i'll definitely look at it later, thanks!
07:38:13 <ertes> hopefully h-i-m will get first-class support for nix some day, so it will no longer be needed
07:54:22 <kubunto> i am trying to fix my code that is supposed to replace a char in a string
07:54:24 <kubunto> http://lpaste.net/353344
07:54:30 <kubunto> not sure why it isnt working
07:55:07 <merijn> kubunto: What does "ghc -> nothing" mean?
07:55:09 <kubunto> expected output is what i see in the ghci readout
07:55:21 <kubunto> merijn: litterally gives no string
07:55:33 <merijn> kubunto: What does the file you give to ghc look like?
07:56:04 <c_wraith> kubunto, that foldr is just concat
07:56:22 <kubunto> c_wraith: it is a string replacement function
07:56:56 <c_wraith> kubunto, the fmap is supposed to be. the foldr is just a concat
07:57:14 <kubunto> ok, function was not invoked
07:57:34 <ocharles> Ok, I am having a serious wtf experience with GHC atm - can any one shed any light on this? https://gist.github.com/ocharles/c028fa7c3f7c8242904a2beb33420eba
07:58:04 <merijn> ocharles: What part of "this" needs light?
07:58:31 <ocharles> See lines 22 , 30 and 31
07:59:06 <ocharles> I don't understand why abstracting `expressions (traverse f)` into `foo` causes a <<loop>> 
07:59:34 <ocharles> Though the abstracting is fine if I introduce one more class (line 22)
07:59:41 <c_wraith> ocharles, usually that means you're accidentally shadowing something 
07:59:42 <ocharles> there are some weird type class contexts, so I've tried to provide as much of those classes as I can
07:59:48 <ocharles> usually, but I'm not here
07:59:52 <Athas> c_wraith: parMap is working like a charm for me.  It's rare that I get good Haskell parallelism experiences, but this is looking like one.
07:59:59 <ocharles> at least, as much as I can tell
08:00:39 <kubunto> ok, seems like i have scoping issue
08:01:38 <ocharles> I mean I have expressions = baseTableExprs, and baseTableExprs just calls gexpressions, and gexpressions just calls itself (or terminates). Using GHCI with -fbreak-on-exception and :trace doesn't really shed any light
08:02:07 <kubunto> so why would c not be passed into the case function in this fragment: http://lpaste.net/353345
08:02:43 <ocharles> If I hit Ctrl-c and use :list, I'm apparently stuck at https://gist.github.com/ocharles/c028fa7c3f7c8242904a2beb33420eba#file-wat-hs-L100
08:02:58 <c_wraith> kubunto, you're not matching on the string "c" 
08:02:59 <merijn> kubunto: Case only matches on patterns
08:03:14 <merijn> kubunto: You're just introducing a new variable 'c' and not using it
08:03:27 <ocharles> I've commented with :history on that gist now too
08:03:36 <ocharles> I'll try and get something standalone reproducible
08:03:40 <kubunto> how would i do what i want then
08:03:59 <c_wraith> use ==
08:03:59 <kubunto> namely pass in char c to the case match
08:04:01 <merijn> kubunto: Use "x == c"
08:04:42 <c_wraith> ocharles, well.. have you tried putting an exact type annotation on foo? 
08:05:33 <kubunto> c_wraith: merijn getting parse errors
08:05:36 <ocharles> Yep, it doesn't help. I put on   foo :: (Table expr haskell, Applicative f) => (Some Expr -> f (Some Expr)) -> expr -> f expr   which is the most general type I want
08:06:27 <c_wraith> ocharles, how about without type variables? I'm trying to control the instance selection exactly. 
08:07:05 <ocharles> c_wraith: if I use foo :: (Some Expr -> IO (Some Expr)) -> Small Expr -> IO (Small Expr)  then it does work
08:07:41 <ocharles> Likewise foo :: Applicative f => (Some Expr -> f (Some Expr)) -> Small Expr -> f (Small Expr)
08:07:46 <c_wraith> ocharles, then it's definitely related to instance selection somehow. I bet there are incoherent  instances involved. 
08:08:01 <ocharles> I'll paste the extensions I'm using in the module that defines those clasess
08:08:16 <c_wraith> well, hmm. overlapping would suffice 
08:08:30 <ocharles> https://gist.github.com/ocharles/f1c707302f85cf386727849a1f60d4b1
08:08:37 <ocharles> and yea, there's the {-# OVERLAPPING #-} instance
08:09:17 <c_wraith> overlapping instances don't really play nicely with inference 
08:09:43 <kubunto> c_wraith: merijn how do i add in ==
08:10:04 <c_wraith> kubunto, replace the case with an if
08:10:07 <ocharles> that overlapping instance gets selected with polymorphic types - if I put `expressions = undefined`, then it crashes in both cases
08:11:25 <c_wraith> kubunto, like... if c == [x] then " " else [x] 
08:11:59 <c_wraith> kubunto, or something like that, but actually what you're trying to do 
08:13:54 <c_wraith> ocharles, I can't really suggest much. this is just the downside of overlapping instances. instance resolution becomes really hard to understand. 
08:13:58 <ocharles> ok, I think I've found the problem...
08:14:08 <ocharles> {-# OVERLAPS #-} might the pragma I really wanted
08:14:11 <kubunto> c_wraith: tyvm
08:14:13 <ocharles> rather than {-# OVERLAPPABLE #-}
08:14:26 <c_wraith> Oh. yes, those are very different 
08:14:30 <ocharles> ah, no
08:14:39 <ocharles> I had another line commented out still. Still loops with OVERLAPS
08:14:50 <ocharles> (and OVERLAPPING)
08:14:51 <ocharles> Urgh
08:14:59 <ocharles> Maybe I'll just kill this stupid instance and make people write two instances
08:15:12 <ocharles> all the methods are generic anyway
08:15:34 <c_wraith> if you can avoid overlapping, it's worth it. 
08:15:41 <ocharles> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=overlapping#ghc-flag--XOverlappingInstances I guess the WARNING here is what I'm hitting
08:16:49 <tfc> hey there. i have a function a -> IO Bool 
08:17:04 <tfc> and i basically want to filterM (not . f) list
08:17:09 <tfc> while f is a -> IO Bool
08:17:31 <tfc> of course not . f does not work in that context. but i am currently puzzled finding out how it can be done
08:17:42 <tfc> <$> and <*> won't work
08:17:52 <MarcelineVQ> :t fmap not
08:17:55 <lambdabot> Functor f => f Bool -> f Bool
08:18:23 <tfc> (fmap not f) then?
08:18:46 <MarcelineVQ> not quite, that's   not <$> f
08:19:04 <tfc> ok, i see...
08:19:06 <MarcelineVQ> you want the composition to happen still
08:19:09 <c_wraith> fmap not . f
08:19:09 <tfc> yes
08:19:35 <tfc> wow that works, thank you!
08:21:05 <kubunto> is char a legal variable name?
08:21:25 <kubunto> nvm
08:23:49 <tfc> MarcelineVQ: ok, i have working what i need. but i do not understand the syntax of "fmap not . testMachine". i do not find a pair of braces i can put there to understand how this works.
08:26:20 <tfc> MarcelineVQ: if :t fmap is Functor f => (a -> b) -> f a -> f b, then i do not see how the "not . f" fits in. while "not" alone can be the first parameter alone , which makes it all a f a -> f b function, i don't understand the next composition step. can you help me here?
08:26:47 <Tuplanolla> Expand the definition of `.`, tfc.
08:26:50 <MarcelineVQ> the definition for  (.)  is    f . g = \x -> f (g x)      so to plug in the values for your case it's something like     \x -> fmap not (f x)
08:27:32 <tfc> oh, i see. the lambda version is more comprehensive to me. thank you.
08:27:44 <SexHendrix> @src (.)
08:27:44 <lambdabot> (f . g) x = f (g x)
08:27:56 <tfc> i know the definition of ".'
08:28:47 <tfc> the problem is that i know what fmap does, and i know what "a . b" does, but while "not . (f :: a -> IO Bool)" does not work, and "fmap not f" also does not work, it's kind of complicated why "fmap not . f" works.
08:30:01 <MarcelineVQ> did the above clear that up for you now?
08:31:40 <kubunto> how would i do a recursive list comp?
08:32:26 <tfc> MarcelineVQ: the \x -> fmap not (f x) looks clear to me. but i fail to see how that is identical to "fmap not . f"
08:32:27 <MarcelineVQ> it's worth mentioning the f's are different, I should have written:  j . k = \x -> j (k x)      ...      \x -> fmap not (f x)
08:33:01 <MarcelineVQ> fmap not  is  j  and   f is k
08:33:34 <shapr> kubunto: [x | xs <- ["foo","bar"], x <- xs] ?
08:33:34 <tfc> aaah now i get it. (fmap not) . testMachine
08:33:38 <tfc> :)
08:33:45 <tfc> thank yo very much MarcelineVQ!
08:34:23 <MarcelineVQ> np, I should have been more clear
08:34:37 <kubunto> shapr: i want to be able to loop thru a list of punctuation marks and use them as arguments to a function i wrote
08:34:59 <tfc> i am still quickly confused by missing parentheses
08:35:21 <shapr> kubunto: do you want to pass each mark to different functions? or what?
08:35:26 <c_wraith> tfc, function calls always bind more tightly than operators 
08:35:54 <kubunto> shapr: one sec
08:35:59 <c_wraith> I suppose I should say "function application" 
08:36:03 <tfc> c_wraith: yes, while i know this, i am used yet to always read it like that. hling keeps kicking me for adding too many parentheses
08:36:41 <SexHendrix> kubunto: functionYouMade <$> listOfPunctuation
08:37:00 <shapr> yeah, fmap is the easy way
08:37:28 <kubunto> SexHendrix: i have better idea
08:37:45 <kubunto> make my if a little more useful in the replacement function i wrote
08:38:21 <SexHendrix> @get-shapr
08:38:22 <lambdabot> shapr!!
08:38:32 <shapr> you screamt?
08:38:35 <SexHendrix> i knew id seen that name somewhere
08:39:01 <shapr> SexHendrix: that command hasn't seen much use the past five or so years
08:39:30 <SexHendrix> recently set up my own lambdabot, saw it was installed by default
08:39:39 <SexHendrix> no idea what it was till i saw your name just now
08:39:52 <SexHendrix> :)
08:39:58 <shapr> I used to host lambdabot and I started #haskell, so I was the single point of failure for a pile of years.
08:40:15 <shapr> thankfully that's no longer the case
08:40:46 <SexHendrix> its a nice bot
08:40:49 <shapr> SexHendrix: any thoughts on lambdabot ?
08:41:02 <shapr> There's a bug in the Quote module that's nearing fifteen years old, I really need to fix that.
08:41:32 <SexHendrix> yeah i haven't looked much into hacking it yet but feels more premium than supybot
08:41:47 <shapr> amusingly, supybot's @command syntax came from lambdabot 
08:42:03 <Tuplanolla> I feel lambdabot's ux could do with a lot of work.
08:42:13 <shapr> I wasn't the original author of lambdabot, that would be Andrew Bromage, but I did write the plugin system and most of the early plugins.
08:42:53 <int-e> @quote bug
08:42:53 <lambdabot> Knuth says: The conventional wisdom shared by many of today's software engineers call for ignoring efficiency in the small; but I believe this is simply an overreaction to the abuses they see being
08:42:53 <lambdabot> practiced by pennywise-and-pound-foolish programmers, who can't debug or maintain their "optimized" programs.
08:42:56 <SexHendrix> still feels a lot more like a tool than a gen purpose bot
08:43:14 <SexHendrix> might write a duckhunt plugin
08:43:16 <Tuplanolla> If you define `x` for example, it should say "defined `Lambdabot.x`; already in scope: `SimpleReflect.x`, `Some.Other.x`".
08:43:23 <shapr> Yeah, people started plugging lambdabot into ghci at some point
08:43:35 <shapr> but most of those tools are now available in various plugins
08:43:42 <SexHendrix> deleting single definitions wouuld be nice
08:43:46 <shapr> though I'd still like to be able to do M-x pl-region
08:43:55 <SexHendrix> typos keep screwing me over
08:43:58 <shapr> Tuplanolla: fix it?
08:44:11 <SexHendrix> letlpaste is great though
08:44:15 <Tuplanolla> The `@let import` syntax is also impossible to figure out without seeing it in action first.
08:44:17 <SexHendrix> best feature
08:44:24 <shapr> One reason lambdabot got popular was that you got ops on lambdabot when you wrote a plugin :-)
08:44:43 <Tuplanolla> Whoa, extra responsibilities for free.
08:44:52 <Rembane> Sneaky! :D
08:45:18 <SexHendrix> people will do insane things for a slight increase in internet power
08:45:28 <shapr> yeah, imaginary internet points are coveted
08:46:31 <SexHendrix> in it for the 1337 hostmasks
08:48:26 <felko> Is there anyway of using a type-level Nat as a value in a computation ? I can't find anything online
08:49:04 <ertes> felko: on the type level or value level?
08:49:37 <cocreature> KnownNat allows you to get the value corresponding to a type-level nat
08:49:38 <glguy> felko: You can use the KnownNat class
08:49:58 <felko> ok i'll check it out thanks
08:50:13 <ertes> felko: for type-level computation you can use the type families like (+) from the GHC.TypeLits module
08:50:43 <felko> ertes: i meant using a type-level Nat in a value-level computation
08:51:20 <felko> Ok KnownNat seems to correspond to what I want, thanks a lot
08:52:26 <kubunto> ok i cant figure this out
08:52:36 <kubunto> i have a string of punctuation that i want to remove
08:53:28 <kubunto> function is http://lpaste.net/353349
08:54:35 <shapr> > filter (not . flip elem "'!") "I don't want punctuation!"
08:54:38 <lambdabot>  "I dont want punctuation"
08:54:45 <glguy> kubunto: Do you know that this "\[x] -> ..."
08:54:49 <glguy> is matching single element lists?
08:55:16 <kubunto> glguy: no but it matches what i have observed
08:55:32 <cocreature> maybe start by adding a type signature :)
08:55:39 <ertes> kubunto: you should really write a type signature for both 'replace' and 'replacef'
08:56:00 <glguy> In this context [x] is a pattern for a single element list where the single element is named x
08:56:41 <glguy> like the list: [1] or [True]. It's different from the type level where you have [Int] which means "a list of Ints"
08:59:37 <`Guest03> tfc: (not <$>) . f
09:00:43 <tfc> `Guest03: nice, this works too. thx!
09:00:47 <shapr> tfc: lambdabot's @pl command is fun too
09:01:01 <shapr> @pl \x -> fmap not (f x)
09:01:01 <lambdabot> fmap not . f
09:01:06 <glguy> If we're obfuscating:    (not <$>) <$> f
09:01:08 <SexHendrix> my favourite is
09:01:12 <SexHendrix> @protontorpedo
09:01:13 <lambdabot> so how do you use haskell tools to build large programs?
09:01:36 <SexHendrix> or maybe
09:01:38 <SexHendrix> @ghc
09:01:39 <lambdabot> Info table already?
09:01:41 <shapr> SexHendrix: yeah, that user had a surprising amount of surreality
09:01:51 <ertes> to (<$>) or not to (<$>): (<$>) (not (<$>)) f
09:02:18 <SexHendrix> im in a channel where some other lads are running a markov plugin on the entire log history
09:02:35 <dolio> protontorpedo is kind of boring. keal is better.
09:02:54 <merijn> @keal
09:02:55 <SexHendrix> so i like to spam @ghc in there to poison all output with sassy ghc quips
09:02:55 <lambdabot> b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b])
09:03:21 <ongy> :t b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b])
09:03:24 <lambdabot> error:
09:03:24 <lambdabot>     • Data constructor not in scope: Floor :: [Expr] -> Expr
09:03:24 <lambdabot>     • Perhaps you meant variable ‘floor’ (imported from Prelude)
09:03:36 <ertes> :t \f -> (id <*> not) (<$>) f
09:03:39 <lambdabot> error:
09:03:39 <lambdabot>     • Couldn't match type ‘Bool’ with ‘a -> b’
09:03:39 <lambdabot>       Expected type: ((a -> b) -> f a -> f b) -> f a -> f b
09:04:13 <kubunto> brb
09:05:15 <`Guest03> :t x
09:05:18 <lambdabot> Expr
09:05:25 <`Guest03> > x + x
09:05:31 <lambdabot>  x + x
09:05:35 <ertes> :t (id <*> not :: (forall f. (Functor f) => (a -> b) -> f a -> f b) -> [Bool] -> [Bool]) (<$>)
09:05:37 <lambdabot> error:
09:05:37 <lambdabot>     • Couldn't match type ‘Bool -> [Bool] -> [Bool]’
09:05:37 <lambdabot>                      with ‘forall (f :: * -> *). Functor f => (a -> b) -> f a -> f b’
09:07:40 <ertes> @src (<$$>)
09:07:40 <lambdabot> Source not found.
09:08:35 <ongy> :t (<$$>(
09:08:37 <ongy> :t (<$$>)
09:08:38 <lambdabot> error:
09:08:38 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
09:08:39 <lambdabot> error:
09:08:40 <lambdabot>     • Variable not in scope: <$$>
09:08:40 <lambdabot>     • Perhaps you meant one of these:
09:08:50 <ertes> lambdabot is not in tsunderebot mode today?
09:08:52 <SexHendrix> :t <$$$>
09:08:54 <lambdabot> error: parse error on input ‘<$$$>’
09:09:26 <ongy> you have to put operators in parens for things like this. so <$> becomes (<$>) and so forth
09:10:16 <ertes> where did i see (<$$>) = flip fmap?  would be quite useful to have in Prelude
09:10:21 <ongy> same for import lists, so 'import Control.Applicative ((<$>))' is rather common for me
09:10:23 <ertes> :t (<**>)  -- like this
09:10:27 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
09:22:12 <MarcelineVQ> ertes: often I see it as <&> if that's useful
09:25:29 <`Guest03> (<&>) can also be of type  f (a -> b) -> a -> f b
09:26:20 <nitrix> :t (<&>) -- from lens
09:26:20 <lambdabot> Functor f => f a -> (a -> b) -> f b
09:26:47 <kubunto> i am still lost on trying to get punctuation to be replaced with spaces
09:27:44 <ongy> kubunto: have you seen the version with filter that removes punctuation glguy posted earlier?
09:27:56 <kubunto> ongy: i dont want them removed
09:27:59 <kubunto> i want them replaced
09:28:06 <glguy> I don't think I posted one
09:28:42 <ongy> oh I thought it was you.
09:29:04 <ongy> kubunto: you can easily modify that filter ot something that replaces:
09:29:12 <nitrix> map (\c -> if isPunctuation c then ' ' else c)
09:29:50 <ongy> > let fun x =  x `notElem` "'!" in map (\c -> if fun c then ' ' else c) "I don't want punctuation!"
09:29:53 <lambdabot>  "     '                  !"
09:30:14 <ongy> whoops wrong way around. But I will let this be your homework
09:30:50 <`Guest03> hmm
09:30:58 <nitrix> Data.Char.isPunctuation already provides you with the detection, you can spare writing you own version.
09:32:34 <nitrix> In which case, it simply becomes:
09:32:49 <`Guest03> (\c -> fromEither $ guard (isPunctuation c) *> return c <|> return ' ')
09:33:13 <nitrix> > filter (not . isPunctuation) "Hello, World!"
09:33:16 <lambdabot>  "Hello World"
09:33:42 <nitrix> Oh I'm doing the same mistake.
09:33:59 <teto> any advice to a beginner for parsing CSV ?
09:34:16 <`Guest03> > concatMap (\c -> if (isPunctuation c) then "  " else [c]) "1, 2, 3..."
09:34:19 <lambdabot>  "1   2   3      "
09:35:01 <sm> teto: use one of the CSV libs on hackage ?
09:35:03 <kuribas> teto: cassava?
09:35:45 <teto> I hesitate between cassava and parsec ? any reason to choose one over the other ?
09:36:05 <sm> parsec doesn't come with a csv parser, you'd be writing it yourself
09:36:40 <sm> and that already exists (http://hackage.haskell.org/package/csv)
09:38:04 <sm> which is old, but very simple
09:39:39 <teto> thanks
09:40:04 <JonReed> Hi, is there a way to provide default value to a lens. E.g., this `aList ^? ix 0` returns maybe and I want it to return simply `a`. I know I can `fromMaybe 42 $ aList ^? ix 0 `, but what is the lens way of doing it?
09:40:37 <Tuplanolla> Yes, `non`, JonReed.
09:41:34 <JonReed> Tuplanolla: Can you provide an example, please? I tried non before and I used it somehow in a wrong way
09:41:50 <Tuplanolla> See Microlens' documentation for several examples, JonReed.
09:41:55 <Tuplanolla> @hackage microlens
09:41:56 <lambdabot> http://hackage.haskell.org/package/microlens
09:42:12 <kubunto> can i put type definitions inside a function?
09:42:18 <Tuplanolla> Yes, anywhere, kubunto.
09:42:31 * sm thinks not
09:42:34 <Tuplanolla> Wait, declarations or definitions?
09:42:52 <kubunto> for instance repl :: Char -> Char
09:43:11 <Tuplanolla> Then yes, anywhere.
09:44:43 <nitrix> JonReed: You want Iso.
09:44:46 <nitrix> JonReed: non :: Eq a => a -> Iso a (Maybe a)
09:45:11 <nitrix> aList ^? ix 0 . non 42
09:45:26 <nitrix> (If I remember the fixity right)
09:48:08 <kubunto> damn
09:48:17 <kubunto> i have no idea what types my functions are
09:50:43 <ongy> you can compile with warnings enabled and ghc will tell you
09:53:50 <glguy> No, you can't mix ix and non like that
09:54:35 <glguy> (or you can, but it doesn't do what the question wants)
09:56:56 <glguy> fromMaybe is the lens way
09:57:57 <nitrix> Ah. Well you can keep using Ix then.
09:58:04 <nitrix> > Nothing ^. at () . non 69
09:58:08 <lambdabot>  69
09:58:25 <nitrix> > Just 42 ^. at () . non 69
09:58:30 <lambdabot>  42
09:58:40 <glguy> Right, non pairs better with at, and lists aren't an instance of At
10:00:15 <glguy> (> [0..3] ^?! (ix 10 <> like 42),  [0..3] ^?! failing (ix 10) (like 42))
10:00:22 <glguy> > ([0..3] ^?! (ix 10 <> like 42),  [0..3] ^?! failing (ix 10) (like 42))
10:00:29 <lambdabot>  mueval-core: Time limit exceeded
10:00:32 <glguy> (42,42)
10:01:24 <nitrix> JonReed: aList ^. at 0 . non 69 -- So basically change `ix` for `at` and you'll be able to use `non` nicely.
10:01:39 <glguy> and change aList to something that isn't a list
10:02:51 <kubunto> ongy: i had issues declaring types of lambda functions
10:03:14 <nitrix> glguy: Once you go lens, you never come back :P
10:03:25 <nitrix> glguy: (As in rabbit hole)
10:04:04 <glguy> There's a phase to go through to learn that lens isn't a framework that all your computation needs to be embedded in, but that requires figuring out what's actually in lens
10:05:04 <MarcelineVQ> I'm still in the phase of "what the hell am I looking at"
10:05:30 <ongy> wait, lens is more than "fancy extensions to records"?
10:06:29 <Tuplanolla> Lens is a lifestyle.
10:06:31 <kuribas> ongy: only that and the kitchen sink
10:07:11 <glguy> very little of lens is about fancy extensions to records
10:07:48 <ongy> then I am at the point where I have no idea what lens is :)
10:08:37 <kuribas> lens is a traverse generalized to any structure and part.
10:09:13 <kuribas> traverse on steroids
10:09:16 <tommd> It's a way to peg your CPU for longer during compilation.   It's also about structure traversal or even monadic actions that are structure-specific (ex: state).
10:10:46 <bennofs> tommd: i think the CPU pegging part is called "template haskell" :)
10:38:02 <sdrodge> I still struggle a lot with knowing when to use lazy variants of various data structures/monads, and when its a good idea to add strictness annotations. Does anyone know of a good write up on this topic?
10:38:08 <sdrodge> (better than the wiki, that is)
10:38:44 <sdrodge> Or is the approach in "real" Haskell programs to actually just write everything using one default or the other and then do profiling to fix it?
10:39:08 <sdrodge> Perhaps I'm overestimating the extent to which practitioners know the answer to this question.
10:39:54 <sdrodge> Or perhaps I'm overestimating how often this impacts performance significantly.
10:42:54 <sdrodge> To make this more concrete: would any strictness annotations in this programming be an obviously good idea? https://hastebin.com/oweyizopax.hs
10:46:15 <sdrodge> *thi program
10:46:18 <sdrodge> *this program
10:52:22 <Cale> sdrodge: I suspect using IM.insertWith' may improve things.
10:53:06 * Sonolin shrugs
10:53:16 <Cale> sdrodge: When you use IM.insertWith (+) there, it won't actually calculate the sum, it just sticks the unevaluated expression into the map
10:53:21 <Sonolin> I always just use lazy, and when I come into problems or issues then look at strict variants
10:53:31 <Sonolin> profiling with ghc is a breeze IMO
10:53:53 <sdrodge> Is that the general practice, then?
10:54:00 <sdrodge> Write lazy and then profile it and fix it?
10:54:24 <merijn> sdrodge: Well, if you get better at understanding the implications of laziness you can predict them without profiling
10:54:27 <Cale> So if you don't observe the values in the map, you'll end up with large expressions of the form (...((1 + 1) + 1) + ...) + 1) + 1
10:54:34 <sdrodge> No real guidelines to follow for inserting strictness annotations that are "obviously" right the first time you write it?
10:55:01 <merijn> sdrodge: Well, there are heuristics and guidelines, but they are rather tricky to articulate
10:55:08 <sdrodge> Cale: Is that a real cost given that I'm storing all the past versions of the map anyway?
10:55:15 <merijn> At least, I realise I have them, but don't know how to articulate them
10:55:23 <sdrodge> merijn: Know of any good write ups?
10:55:29 <Cale> Yes, an expression like that requires much more memory than an Int would otherwise take
10:55:43 <monochrom> The real guideline is to learn laziness and decide, very consciously, whether you want it or not.
10:55:47 <Cale> and if you wait too long before eventually evaluating it, you'll end up with a stack overflow
10:56:04 <Cale> because (+) is strict in both its arguments
10:56:07 <merijn> sdrodge: Starting point for understanding laziness would be: https://hackhands.com/guide-lazy-evaluation-haskell/
10:56:14 <Cale> So you'll start out with (...) + 1
10:56:39 <merijn> sdrodge: A more in-depth follow up (assumes you know a little bit about C/asm) would be the STG paper: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.3729&rep=rep1&type=pdf
10:56:47 <Cale> and the outermost (+) will say, "Oh, I need to match on my first argument", and that pattern match will wait on the stack while the first argument is evaluated
10:56:54 <Cale> and it too will be of the form (...) + 1
10:57:10 <Cale> and if you have like a million of those, you'll blow up your stack
10:57:52 <sdrodge> merijn: My problem is that I already know how Haskell does laziness, but I find it hard to convert that knowledge into good strictness annotations while writing code.
10:58:56 <Cale> My usual rule of thumb is to break things down by whether operations are taking or producing things with many or few separately evaluatable parts
10:59:11 <sdrodge> Cale: I see why that would be true if I were only keeping the current map around, but aren't I paying that memory penalty anyway by keeping all the maps around?
10:59:26 <Cale> It's the cases where something is taking many separate parts, and condensing them down into something with few parts that you want strictness.
10:59:30 <monochrom> That's probably just because your own strictness annotation is not enough. Libraries you use have a say too. It's why Data.Map.Strict exists. Not something you can do outside the library.
10:59:41 <merijn> sdrodge: Why do you think you're keeping all the maps around?
10:59:58 <Cale> sdrodge: No, this is a separate penalty
11:00:16 <sdrodge> merijn: Because I'm keeping all the old maps in a sequences as state.
11:00:21 <sdrodge> *in a sequence
11:00:21 <Cale> This isn't the *Map*, this is the *Int* inside.
11:00:56 <monochrom> Yes, you have "one single Int" that takes up 100MB because it's still in a "1+1+1+..." form.
11:00:59 <Cale> You're storing a big complicated expression for that Int which, once you evaluate it, will be replaced by a machine word or two.
11:01:46 <aesthetik> Click on the link and get $110!
11:01:46 <aesthetik> https://richmondberks.com/?ref=rbd118972
11:01:46 <aesthetik> - Make 1,5% Daily profit !
11:01:46 <aesthetik> - Invite a friend and get 1$ as a gift !
11:01:46 <aesthetik> - Comissions of 10% !
11:01:53 --- mode: ChanServ set +o monochrom
11:01:56 --- mode: monochrom set +b *!*@adsl196-149-133-217-196.adsl196-13.iam.net.ma
11:01:57 --- kick: aesthetik was kicked by monochrom (aesthetik)
11:02:12 --- mode: monochrom set -o monochrom
11:02:14 <sdrodge> Okay, yes, good point.
11:02:51 <Cale> sdrodge: Doing that sooner rather than later also makes the garbage collector's life easier, and you'll save a bunch of time on allocations.
11:03:08 <sdrodge> So is the generalization here that I should use insertWith' unless I specifically need the value inserted to be calculated lazily?
11:03:28 <SLi> I've been pondering way too long about how to best implement this (as always seems to happen when I program in Haskell :(). Essentially, I'm writing a tool that works on expressions (and-inverter-graphs, i.e  each node is a binary AND operator, and the two inputs to each gate may independently either be inverted or not) and applies local rewrites. But there's a wrinkle: Expressed as trees, the expressions are huge and share a lot of subexpressions, so the 
11:03:29 <SLi> input is provided as a DAG, and should be kept as a DAG. So need sharing. Lots of times I would like to essentially rewrite the DAG node, i.e. the expression everywhere in the tree, but other times I might want to essentially unshare it and rewrite it in only parts of the tree.
11:03:42 <monochrom> Why are you in such a hurry for generalizations and no-brainer rules of thumb? But yes.
11:03:46 <Cale> Usually... it depends of course, but yeah.
11:04:10 <SLi> So, I guess I could implement this as described, but I wonder there's some abstraction that could help me, like abstracting the "sharing container with ability to unshare" idea somehow.
11:04:54 <Cale> Sometimes it'll be profitable to store a lazy expression for something in the Map -- if computing the outcome will be expensive and you might not need the result, or if you expect the space for the result to be larger than the space for the expression.
11:04:59 <sdrodge> monochrom: Because it's really helpful to have guidelines/rules to follow when programming as to not overload working memory.
11:05:23 <monochrom> (Fortunately this is still not a no-brainer because "do I need laziness" still requires conscious rational reasoning.)
11:05:28 <sdrodge> If I have to spend time thinking carefully about whether I want the strict or the lazy version every single time I write a line of code, that's not good.
11:05:44 <Cale> Well, you kind of do.
11:05:55 <sdrodge> Sure, but it's a matter of how hard I need to think.
11:06:00 <Cale> It's just that 95% of the time, the answer is "it doesn't matter"
11:06:10 <monochrom> It has been pretty easy for me.
11:06:11 <Cale> and then the other 5% of the time, it's one way or the other and very important
11:06:27 <sdrodge> Oh, I see.
11:06:46 <sdrodge> So it's more that the cost of computing this is low enough that strictness is obviously right.
11:06:51 <sdrodge> Even though the value may not be needed.
11:06:52 <SLi> I've also looked at graph rewriting packages in hoogle. Of those, I think this looks most promising at least for testing, but I think it lacks the sharing part. https://hackage.haskell.org/package/graph-rewriting
11:07:24 <Cale> sdrodge: yeah, in this case, you're not saving anything by deferring that addition until later
11:07:30 <monochrom> (Fortunately it is still not a no-brainer because for every line you still have to consciously rationally reason whether that line is in the 95% or in the 5%. Resistance is futile.)
11:07:43 <sdrodge> I'm really not looking for a no-brainer.
11:07:44 <Cale> monochrom: Yeah
11:07:56 <sdrodge> I'm just looking for a better feel about how to frame the question so that I can figure it out faster in the future.
11:07:57 <Cale> (though I'm not sure it's actually fortunate)
11:08:08 <SLi> I agree I've also had problems with laziness everywhere causing hard-to-debug memory issues. Trying strict-by-default Haskell is on my list of things to do.
11:08:08 <monochrom> That is called experience.
11:08:14 <sdrodge> Instead of the situation I currently have where I write a program and then wonder, huh, did I miss any obvious strictness annotations?
11:08:39 <sdrodge> Okay, but it's even better if you can learn from others' experience instead of your own.
11:08:54 <SLi> Actually, almost every time I write a Haskell program that takes a moderately large input and outputs something simple I have a problem that the memory usage grows to gigabytes. I've been told religiously avoiding lazy IO helps.
11:09:01 <monochrom> Yes. You have a USB port in your head? I could download mine to you.
11:09:19 <sdrodge> So one very useful tip I seem to have learned today is that in general for inexpensive operations on small data (like addition on ints), you want to demand strictness.
11:09:21 <merijn> SLi: Well, lazy IO is rather rarer than people seem to think it is
11:09:31 <merijn> Like, there's only 5 or so lazy IO operations in base
11:09:39 <monochrom> Or you can send me 100 bitcoins to commission me to write a whole book on this.
11:09:39 <SLi> merijn: Hmm, ok.
11:09:46 <merijn> sdrodge: Right, that's a reasonable heuristic
11:09:54 <sdrodge> monochrom: You could see if there's a way to gel your experience into a great article with worked examples!
11:10:07 <merijn> sdrodge: He already has that for most topics :p
11:10:11 <monochrom> Yes. You can send me 100 bitcoins to commission me to write it.
11:10:11 <SexHendrix> just written what could be the worlds slowest numerical integrator
11:10:16 <SexHendrix> http://lpaste.net/353356
11:10:35 <SexHendrix> looking for some obvious areas for speeding it up
11:10:49 <sdrodge> monochrom: Look, I just asked if there was such a write-up somewhere. You're the one attacking me for asking the question and suggesting this knowledge is impossible to transfer anywhere other than hard-won experience.
11:10:55 <sdrodge> Cool your jets.
11:11:07 <monochrom> I just asked for money.
11:11:11 <sdrodge> :P
11:11:14 <monochrom> You need to take a walk.
11:11:52 <monochrom> And I need a haircut.
11:12:00 <SLi> I need both.
11:12:33 <monochrom> But what merijn said. http://www.vex.net/~trebla/haskell/lazy.xhtml
11:12:56 <monochrom> The foldr and foldl examples are not too different from the insertWith situation.
11:13:28 <sdrodge> Yeah. I mean, I understand the foldr and foldl examples. I just find it difficult to apply that knowledge when writing larger programs.
11:14:03 <sdrodge> When you guys write Haskell, do you actually stop and think about whether strictness or laziness is correct for each expression that you write?
11:14:14 <monochrom> Yes I do.
11:14:24 <monochrom> And no, not taxing.
11:14:36 <Cale> sdrodge: The general rule of thumb that I use is that whenever you're taking many separately evaluatable things, and combining them together into a single indivisible value (which can't be partially evaluated), that almost always describes the places where you want the strictness annotations.
11:15:00 <sdrodge> Cale: Interesting.
11:15:02 <sdrodge> Thanks!
11:15:25 <merijn> sdrodge: Well, I just kinda have a feel for things, like Cale describes, and that sets of my warning "I need to pause and think" reflex
11:15:36 <kuribas> sdrodge: for small numerical functions, lazyness can be a high cost.  I had a 10X performance increase by forcing a tuple, because keeping the closure and garbage collecting it was much more expensive.
11:15:47 <sdrodge> I guess maybe the misconception that I have is that it doesn't always seem possible to reason about stricness locally.
11:15:49 <mniip> sdrodge, depends on what mode I'm programming in
11:15:54 <sdrodge> But maybe I'm missing something.
11:15:56 <merijn> kuribas: Well, forcing it might also help the strictness analyser
11:16:02 <Cale> sdrodge: Well, it's not.
11:16:07 <mniip> sometimes I'm writing code so that it runs well, sometimes I only need a qualitative result
11:16:33 <Cale> That's not a misconception -- how expressions are evaluated are something that can require insight into what the whole program is doing in general.
11:16:46 <kuribas> merijn: it wasn't strict, because both values depended on the same computations.
11:16:50 <sdrodge> That's the part that bothers me.
11:17:13 <sdrodge> Because whole program reasoning doesn't scale.
11:17:31 <merijn> kuribas: No, I meant that adding the strictness might lead the strictness analyser to kick in and unbox things
11:17:43 <merijn> sdrodge: That's a downside yes, but there's also an upside!
11:17:43 <kuribas> merijn: right
11:17:53 <sdrodge> Don't worry, I'm not upset about laziness.
11:17:55 <sdrodge> I love it.
11:18:01 <merijn> sdrodge: If you have code that is "too strict", making it lazier requires changing ALL the code
11:18:04 <SLi> So, I wonder if it would be possible to write some... thing that takes any type (Hashable a, Eq a, Functor f) => f a and produces an isomorphic type with observable sharing of a. Though that still wouldn't work for sharing subtrees in trees. Hmh.
11:18:08 <sdrodge> I just want to learn how to manage the lazy/strict choice better.
11:18:28 <merijn> sdrodge: Whereas, making something that's "too lazy" stricter is a local code change (see foldl vs foldl')
11:18:55 <merijn> sdrodge: So the upside is that code that's too lazy can be fixed/worked around without needing to change any original code, which cannot be said for too strict
11:19:02 <merijn> But it's time to log off!
11:19:03 <sdrodge> Cale, merijn: Out of curiosity, do you tend to default to Data.Map.Strict or Data.Map.Lazy?
11:19:14 <monochrom> "whole-program" is the pathological worst case. It rarely happens. For most programs, especially well-structured ones, very few parts actually has access to the data in question, even though those few parts don't sit together.
11:19:17 <sdrodge> merijn: Thanks for the help!
11:19:32 <Cale> sdrodge: Data.Map.Lazy
11:19:37 <monochrom> So instead, it is "everyone has access to everything" that doesn't scale.
11:19:40 <kuribas> sdrodge: the morale is I think don't keep thunks that are cheap to evaluate, or will be evaluated anyway.
11:19:41 <Cale> There are only a few operations which need strictness.
11:20:07 <sdrodge> monochrom: Fair enough.
11:20:22 <Cale> sdrodge: But note that it's not mutually exclusive
11:20:34 <Cale> The actual type is the same, only the functions are different.
11:21:00 <Cale> Data.Map.Strict just has functions that force evaluation of the elements of the Map that they interact with.
11:21:10 <sdrodge> Oh, didn't realize that.
11:21:24 <sdrodge> How about other cases where it is mutually exclusive?
11:21:36 <sdrodge> Like Control.Monad.State.{Lazy, Strict}
11:21:56 <sdrodge> Do you tend to default to Lazy or Strict?
11:22:03 <sdrodge> Is the answer the same or different for ST?
11:22:04 <Cale> For Control.Monad.State I just import Control.Monad.State
11:22:13 <sdrodge> So that's the Lazy one.
11:22:17 <Cale> which I believe gets me the Lazy one, yeah
11:22:59 <Cale> That doesn't matter too much in practice -- it's referring to whether the pairs are being forced in the definition of bind
11:23:49 <Cale> i.e. whether it's  x >>= f = State (\s -> let (v,s') = runState x s in runState (f v) s')
11:24:13 <Cale> or  x >>= f = State (\s -> case runState x s of (v,s') -> runState (f v) s')
11:24:43 <monochrom> Actually they use "(v, s')" vs "~(v, s')" now.
11:24:55 <Cale> fair enough (should be the same thing)
11:25:11 <Cale> Note that even with Control.Monad.State.Strict, you can still have the state itself be an unevaluated expression
11:25:36 <monochrom> (and an implicit case. Why implicit? Because they obtained the "case" from do-notation. Why do-notation? Because it's StateT, even if it's StateT Identity)
11:25:50 <Cale> ah, right, that makes sense :)
11:26:20 <sdrodge> So it seems I am missing something here. What is the significance of forcing the tuple directly in the bind vs. not?
11:26:35 <monochrom> Yes this one is very sutble.
11:27:00 <monochrom> My http://lpaste.net/41790/ shows what could happen.
11:29:03 <monochrom> In this case I do have a rule of thumb. But it is only because of statistics on how people use Control.Monad.State empirically.
11:29:35 <monochrom> When people use Control.Monad.State, 100% of the time they imagine that they're writing C or Pascal or Algol or something.
11:30:11 <monochrom> The Strict version is the one closer to their fantasy. This is why it is the safe default.
11:30:36 <sdrodge> Does that mean you think State was the wrong choice for that example program I shared?
11:30:39 <monochrom> The Lazy version corresponds to an imperative language that no one has thought of. (Except in my thesis.)
11:30:44 <dolio> What if they imagine they're writing Algol 68?
11:31:18 <monochrom> Well this is where the empirical statistics comes in. 0% of the people actually do that.
11:32:06 <Cale> In my experience, people usually don't care and import Control.Monad.State, which makes that the sensible default regardless of its semantics
11:32:40 <monochrom> Ah but they have a high chance of consuming more memory than they need.
11:33:19 <dolio> Strict used to avoid some stack overflows from really big computations. But I guess that's gone now.
11:33:38 <monochrom> There is a conspiracy in the correlation between "I am lazy, I just type 'Control.Monad.State'" and "it gets me Control.Monad.State.Lazy".
11:35:03 <Cale> Of course, that only matters if you expose things which involve explicitly the State/StateT you imported, which you probably shouldn't do anyway :P
11:35:09 <dolio> The maintainers are also too lazy to bother changing the semantics from when the lazy version was the only one that was offered.
11:35:15 <sdrodge> I guess when it comes to performance, all abstractions are leaky.
11:37:00 <Cale> sdrodge: Right -- depending on the amount of pain you want to take in making your programs time and space efficient, you might need to break through any abstraction barrier. Eventually you reach a point where it's no longer worth the trouble.
11:37:59 <kuribas> for performance, you should look at bottlenecks first.
11:38:39 <sdrodge> Sure. I mean, I understand that premature optimization is bad, and that you should look where the actual bottlenecks are before optimizing.
11:39:01 <sdrodge> But at the same time, there are usually rule of thumb sane defaults to get reasonable performance that you should follow when writing.
11:39:18 <kuribas> sdrodge: premature optimization is ok when you know what you are doing :)
11:39:31 <sdrodge> I'm trying to figure out what those rules are w.r.t. strictness in Haskell, though.
11:40:52 <kuribas> sdrodge: in general, or with a particular library?
11:41:03 <sdrodge> Either, honestly.
11:41:30 <sdrodge> Like, if there's good rules of thumb with particular commonly used libraries or data structures, I'd love to hear it.
11:41:56 <kuribas> sdrodge: I made my datatypes in my numerical library strict, since it doesn't make sense to make them lazy.
11:42:26 <sdrodge> I tend to make all my data structures strict unless I have a specific reason not to.
11:42:37 <sdrodge> But that's the only strictness optimization that I tend to do.
11:43:21 <kuribas> there's also lazy Bytestring and strict Bytestring.
11:43:33 <kuribas> lazy Bytestring for streaming, strict for random access...
11:43:36 <sdrodge> For some reason, I find that one much easier to reason about.
11:43:42 <johnw> although, lazy ByteString is somewhat of an interface on top of strict ByteString
11:43:55 <johnw> Lazy.ByteString = [Strict.ByteString]
11:44:06 <kuribas> lazy bytestring is great
11:44:07 <sdrodge> except it's head strict, right?
11:44:51 <kuribas> sdrodge: I wouldn't worry about it, unless profiling or benchmarking shows lazyness is a problem.
11:45:25 <SexHendrix> muh stack overflows
12:03:56 <stelleg1> is there a way to load the extensions listed in a file along with the definitions?
12:04:15 <stelleg1> gets tedious setting them all with :set -XBlah
12:04:26 <stelleg1> *in ghci
12:06:33 <AndreasK> stelleg1: You can use a .ghci file
12:06:46 <JonReed> stelleg1: I don't think so. But there is .ghci file thaht can be used to load them automatically
12:06:59 <JonReed> stelleg1: https://downloads.haskell.org/~ghc/7.2.2/docs/html/users_guide/ghci-dot-files.html
12:07:00 <stelleg1> thanks
12:11:17 <JonReed> Can anybody provide me a working example of providing defaults in a lens way. How to make this  `[42] ^? ix 0` to return not `Maybe Int` but `Int`. I know how to do this with Maps `Map.empty ^.at "key" . non 0`, but my brain can't process how to do it with lists
12:14:54 <tapirus> I'm trying to sort two lists in a way that's slightly different from lexicographic order. As an example, 'compare [LT,GT] [LT,GT,LT,...]' 'compare [LT,GT] [LT,GT,EQ,...]' and 'compare [LT,GT] [LT,GT,GT,...]' all return LT. I'd like them to return LT, EQ, and GT respectively. Is there any simple way of doing this?
12:15:25 <johnw> JonReed: Use ^?!
12:16:53 <JonReed> johnw: But how to provide default? This will error out instead
12:17:21 <JonReed> johnw: I want it to return default value if Nothing is encountered
12:17:53 <JonReed> I know how to do it non-lens way with fromMaybe 42 $ .. lens stuff here
12:18:08 <JonReed> but the lens way escapes me
12:18:34 <Profpatsch> Concerning the regex package (which was announced a bit ago)
12:18:55 <Profpatsch> Of course everybody wants to say she build the One True Solution
12:19:00 <supki> > [] ^?! (ix 0 `failing` like 42)
12:19:04 <lambdabot>  42
12:19:10 <Profpatsch> But isn’t it a bit presumptuous to just call the package `regex`
12:19:26 <Profpatsch> When all that came before used some suffix.
12:19:51 <muesli4> tapirus: So you only want to compare the minimal length? E.g. wrap it in a newtype whose Ord instance brings them to the same length and then compares them.
12:20:12 <Profpatsch> Originally wanted to reply that to the announcement mail, but that ML is probably not for discussions.
12:20:16 <JonReed> supki: Thanks!
12:22:16 <muesli4> tapirus: Something like: compare (Shortedned xs) (Shortened ys) = (let { zs = zip xs ys ; xs' = fst <$> zs ; ys' = snd <$> ys } in compare xs' ys'
12:22:45 <SexHendrix> is there a way to do solids of revolution numerically
12:23:27 <SexHendrix> ive written a program that does integrals numerically given function and limits
12:23:42 <SexHendrix> can it do revolutions the same way?
12:23:54 <tapirus> muesli4: cheers, looking at this
12:25:00 <johnw> Profpatsch: time to grab the "haskell" name, I guess
12:25:14 <Profpatsch> johnw: Go for it.
12:26:35 <Profpatsch> johnw: http://profpatsch.de/lulz/the_lulz.jpg
12:31:08 <lpaste_> Noobie22 pasted “Easy question” at http://lpaste.net/353360
12:31:25 <lpaste_> Noobie22 revised “Easy question”: “Easy question” at http://lpaste.net/353360
12:32:51 <jle`> noobie22: did you have a question? :)
12:35:12 <Profpatsch> “remains the best example of developing regular expressions at scale”
12:35:16 <Profpatsch> I’m scared now.
12:35:38 <Profpatsch> But it could be pretty handy for shell contexts.
12:36:49 <AWizzArd> How would one typically represent a configuration in Haskell?   data Config = { key1::Int, key2::[Float], …, keyN::SomeType }   ?
12:36:58 <Tuplanolla> @hackage dry-run
12:36:58 <lambdabot> http://hackage.haskell.org/package/dry-run
12:37:11 <Tuplanolla> This would also be a great package name.
12:37:32 <maerwald> AWizzArd: how's that question answerable. There's no such thing as a typical way of something like that
12:38:22 <AWizzArd> maerwald: well, I am thinking of Hashmap vs own data type, with a certain number of key/value pairs.
12:38:59 <AWizzArd> Is access to fields of a data type with 84 fields efficient?
12:39:17 <maerwald> I think darcs does it
12:39:28 <Tuplanolla> You can split it up into smaller parts that tend to change together, AWizzArd.
12:40:30 <SexHendrix> > let lucky n | mod n 7 == 0 = "LUCKY" | otherwise = "out of luck"; lucky' n = lucky <$> [0..n] in lucky' 10
12:40:35 <lambdabot>  ["LUCKY","out of luck","out of luck","out of luck","out of luck","out of luc...
12:47:10 <cdornan> Profpatsch: the idea with reflex is that it should become the goto API for regex-base, the defacto regex framework for these last 10 years, so it is logical at least
12:48:11 <ezyang> "reflex" haha 
12:49:26 <cdornan> How about turning that around -- could be good that there is a serious effort to produce a definitive regex package
12:50:24 <Cale> cdornan: Wait, someone is naming a regex-related package "reflex"?
12:50:34 <Cale> ~trademark issues~
12:50:39 <cdornan> ezyang: I have cut down deps on library and added escape functions
12:51:00 <blackdog> that's gonna be kinda confusing
12:51:21 <cdornan> Noooo -- that was my autocorrector
12:51:32 <Cale> ah, good
12:52:00 <cdornan> Package is called "regex"
12:52:15 <geekosaur> someone fatfingered "refex" at a guess. they must be borrowing my fingers :p
12:52:52 <cdornan> Fat autocorrector!
12:52:59 <dolio> You need really fat fingers to hit l when trying to hit f.
12:53:00 <Cale> Well, the main reason that regex-base hadn't seen any love is because Haskell programmers mostly don't use regexes for anything
12:53:17 <maerwald> they should
12:53:19 <johnw> although, they probably would, if they were asy to use
12:53:20 <Cale> (apart from via other tools, like text editors and sed)
12:53:21 <geekosaur> neh, they typoed regex as refex and autoincorrect added the l to get a word
12:53:41 <johnw> spending 30 mins trying to figure out regexps in Haskell usually leads people to Parsec as a simpler alternative
12:53:51 <cdornan> I agree -- a mistake , as I say in my blog post
12:53:53 <Cale> I can imagine some use cases where you'd want *actual* regular expressions, for performance reasons
12:53:59 <geekosaur> althogh re regex, see recent -cafe message
12:54:01 <Cale> (due to the ability to compile to DFAs)
12:54:04 <maerwald> Cale: no, for complexity reasons
12:54:12 <Cale> Yes
12:54:15 <maerwald> don't make your recognizer more complex than your input language
12:54:22 <maerwald> that's a security principle, not a performance thing
12:54:27 <geekosaur> I have snarked here about the Text.Regex interface being intended to push people as far away from regexes as possible
12:54:45 <Cale> Well, parser combinator based parsers aren't necessarily of higher complexity anyway
12:54:50 <johnw> I remember as a young Haskeller reaching for regexs, only to pull back a bloody stump
12:54:52 <maerwald> computationally yes
12:55:16 <johnw> and the problem is, even when you've figured out the interface, they don't really get any easier to use
12:55:49 <Cale> Yeah, regex-base is terrible, and if someone really needs regular expressions, they should probably build something else.
12:55:50 <muesli4> tapirus: My solution was actually wrong, am I correct that you want something like this? http://codepad.org/xVRPCH2t
12:56:03 <ezyang> I don't understand why we don't just have regular expression combinators 
12:56:19 <geekosaur> regex-applicative?
12:56:21 <ezyang> people complain all the time about regexes being unreadable 
12:56:23 <ezyang> sure :) 
12:56:37 <johnw> I like regex-applicative for building up complex regex expressions
12:56:45 <geekosaur> also, the counternark to Text.Regex is how often we get someone who first asks how to use it, then asks what regex they want...
12:56:45 <cdornan> Was just going to say regex-applicative
12:57:02 <johnw> so says ^e(dward)z\.?yang$
12:57:02 <geekosaur> which *ought* to be a hint that maybe reaching for regex is not the right answer
12:57:19 <maerwald> the demonization of regular expressions in the haskell community is a consequence of the fact that parser combinators are more elegant to do in haskell
12:57:26 <muesli4> tapirus: Basically, when the suffix stays below a reference value it is seen as lower (above -> higher, on the reference value -> equal).
12:58:00 <johnw> maerwald: regexs *should* be a strict subset of those combinators, that restricts what you can say in a way that results in even clearer error messages about what you might have done wrong
12:58:42 <johnw> while the "foo" type regex strings are just an alternate syntax, so who cares about that anyway
12:58:53 <Cale> Everyone knows that the only acceptable place to use regular expressions is as part of sed expressions in your .nix build scripts to hack the export lists on people's modules when they didn't export shit that you need. ;)
12:59:15 <cdornan> All true but not having conventional high quality regex API is not good in my experience
12:59:18 <hexagoxel> no, the usual notation to express regular expression does not leave room to write comments. this is in contrast with haskell's philosophy of writing extensive documentation for all code.
12:59:19 <johnw> Cale: and in the Perl scripts I use to patch the results of Coq's unverified extractor, thus resulting in complete confidence
12:59:25 <Cale> lol
12:59:49 <Cale> hexagoxel: lol
13:00:10 <Aruro> are there many commercial standalone haskell apps  ? beside hledger and haskell studio for mac ?
13:00:12 <maerwald> johnw: I don't understand. error messages in parser combinators are rarely clear
13:00:27 <Cale> Aruro: Do they also have to be open source?
13:00:28 <maerwald> ofc, depends on the library
13:00:30 <johnw> maerwald: that exactly my point; they are less clear the more general the combinators
13:00:36 <Aruro> Cale: no, just haskell
13:01:04 <Aruro> only requirement it has to be an "app" not "We are doing consulting"
13:01:15 <ezyang> to me, the bigger problem with string regexes is lack of compositionality 
13:01:16 <Cale> Aruro: Well, we build web applications for various clients entirely in Haskell.
13:01:36 <Cale> (and, more recently, mobile versions of those)
13:01:47 <maerwald> johnw: well, my point is rather the computational complexity of the recognizer. Choose the minimal complexity, not just for the input language, but also for the recognizer (if it can properly _detect_ it). Mitigating SQL injection with regexes is plain wrong
13:02:10 <Aruro> so apart from hledger and mac studio there are no haskell made apps? excluding industry internals.
13:02:10 <cdornan> ezyang: agreed -- one reason for adding macros and testbench to regex
13:02:11 <johnw> or how about writing RFC822 e-mail parsers
13:02:11 <Cale> Aruro: There are a bunch of industrial users of Haskell who have closed source apps.
13:02:17 <dolio> There are a bunch of problems with string regexes.
13:02:42 <Cale> Aruro: Well, there are a bunch of other open source things, but those I thought were more obvious.
13:02:53 <Cale> Pandoc, XMonad
13:03:01 <Aruro> Cale: so haskell economics is all about internal interbuiseness solutions?
13:03:07 <Aruro> why not making apps?
13:03:24 <Cale> Like, what kind of apps?
13:03:26 <Aruro> which people can buy. like paragon for example
13:03:34 <Cale> Most money is in web development these days
13:03:38 <blackdog> do you mean SaaS stuff?
13:03:41 <johnw> the best feature of regexs is how much they can liven up any IRC channel
13:04:04 <johnw> Cale: you'd think the Web would have been fully developed by now
13:04:11 <Cale> haha
13:04:18 <blackdog> johnw: think growth as in cancer
13:04:19 <Cale> Well, we're working on it
13:04:34 <Aruro> like even commercial modeling software, or even SaaS buiseness applications
13:04:36 <Cale> Hopefully we can get things to a place where it's not such a big effort
13:04:48 <blackdog> Aruro: sure. betterteam.com is in haskell.
13:04:55 <blackdog> the point is, you wouldn't know unless somebody told you.
13:05:32 <Aruro> i mean what stops developers to use haskell for end user programs?
13:05:44 <Aruro> excluding - cloud,services and such
13:05:48 <Xe> Aruro: managers
13:05:50 <Cale> Aruro: Almost nobody sells those at all?
13:06:07 <Aruro> why? i bout ntfs driver for mac from paragon, seems ok.
13:06:13 <Aruro> bought*
13:06:46 <Cale> I guess on Mac, there are some things which inexplicably cost money but which would ordinarily be part of your OS
13:06:51 <Aruro> i mean i would support good haskell developer of something nice
13:07:16 <blackdog> Aruro: nothing, really. i guess there isn't a clear winner in terms of writing graphical interfaces?
13:07:21 <geekosaur> r/o ntfs driver is built in, later releases have a hidden partial r/w support option
13:07:39 <blackdog> it's just way easier to make money by putting your code on a server, rather than dealing with licensing etc.
13:08:08 <Aruro> so licensing is one of the issues?
13:08:25 <dolio> It's an issue with writing software.
13:08:25 <geekosaur> this isn;t so inexplicable because r/w ntfs info used to require microsoft nda. linux emulated it via an ugly hack (which basically meant do stuff and let ntfs journaling sort it out on the next windows boot. yes, this worked about as well as you could expect)
13:10:05 <kuribas> blackdog: GUI's support isn't the best in haskell.
13:10:30 <ongy> I'd say the haskell ecosystem makes it annoying to distribute licensed software, since dependencies have licenses all over the place and nobody cares
13:11:07 <Aruro> take alphasheets, their task is perfect for an app, but it will be webservice ? they do have some haskell coding there
13:11:13 <kuribas> ongy: most haskell libraries are BSD.
13:11:17 <ongy> I have seen a package (some library bindings) that has a conflicting license to the library. Which the author explicitly states
13:11:24 <maerwald> unfortunately
13:11:28 <ongy> kuribas: except for the (l)gpl ones
13:11:29 <Cale> ongy: Which package?
13:11:41 <ongy> I don't remember which one. I don't think I ended up using it
13:11:58 <Cale> Note that you can distribute BSD bindings to a GPL library, so long as you don't distribute the GPLed library with it.
13:11:58 <dolio> The majority of programmers don't care about licenses, regardless of which language they use.
13:12:00 <maerwald> people just seem to use what random thing "cabal init" suggests (which is BSD-3 afair)
13:12:09 <maerwald> and that's a pity
13:12:42 <Theophane> `stack legal` could be very useful ;)
13:12:44 <ongy> Cale: it was something like this. But it's a bit more annoying if someone intended to distribute it the usual windows way with libraries included
13:12:47 <Cale> Whatever you're making bindings to might as well be proprietary from your perspective if you're not distributing the code.
13:12:48 <Theophane> (or `cabal legal`)
13:12:54 <Cale> ongy: That's true.
13:13:00 <kuribas> ongy: how is that different from any other language?
13:13:42 <Xe> kuribas: unlike php you don't need to dencrypt your source code at runtime
13:13:54 <Xe> (such monsters do exist in this world)
13:13:59 <ongy> kuribas: I have seen *less* of that in the C(++) ecosystem. But maybe I just cared less
13:14:26 <ongy> it's not language specific, but I feel like nobody cares. because for the main usecase (user downloads from hackage/stackage and builds/links themself) it doesn't matter
13:14:28 <jle`> huh didn't realize that hackagebot has been gone for over three months now
13:14:37 <jle`> i'll miss that little bot
13:14:44 <jle`> rest in peace hackagebot
13:14:54 <ongy> but if someone wanted to use it commercially and distribute binaries with *batteries included* (or for windows) things get hairy
13:15:16 <maerwald> why?
13:15:24 <Aruro> even for support scheme? like donate and spport me?
13:15:41 <maerwald> ongy: why would that be a problem?
13:16:17 <Cale> Well, ongy has a point -- the fact that you can't figure out from the license on the Haskell binding what to do about the library it's a binding to might be a bit annoying if you have a ton of dependencies to go through.
13:16:39 <Cale> But I dunno, packaging stuff for Windows already seems like a pain.
13:16:52 <Aruro> linux users have money too
13:16:54 <Aruro> :)
13:17:11 <Aruro> question is where is haskell monetization ecosystem? even in form of donations
13:17:46 <Cale> It comes from various startups and other companies who pay us to build reliable software
13:17:48 <blackdog> kuribas: yeah, that's what i meant - we haven't concentrated behind a single framework or approach, so no single codebase gets the work.
13:18:26 <blackdog> (which isn't a criticism, it's just not obvious what the best way forward is, and bluntly without a large base of people writing gui software nobody's that interested)
13:18:43 <kuribas> blackdog: I think it's more of a lack of interest in GUI code in general.
13:18:44 <ongy> maerwald: I have no example, but if there was a package that depended on another one  and they have incompatible licenses, distributing binaries wouldn't be possible to my understanding 
13:18:58 <blackdog> Aruro: i tend to think the easiest path is just writing fast, safe web apps.
13:19:05 <maerwald> ongy: probably, I just didn't understand what "commercially" has to do with that
13:19:39 <ongy> maerwald: most others don't give a damn, or just put it on hackage aswell and don't distribute binaries
13:20:00 <kuribas> blackdog: maybe because people think pure functional isn't a good much for the imperative nature of GUIs?
13:20:11 <ongy> blackdog: I think you can drop both fast and safe there....
13:20:34 <ongy> Aruro: I don't think there's any monetization options on hackage (or anywhere) maybe some people have donation buttons on their project websites
13:20:59 <Aruro> yeah, hledger has, would be interesting to hear his feedback
13:21:05 <ongy> if I ever get a userbase that's bigger than the people I know, I may put something up aswell
13:21:59 <blackdog> ongy: why?
13:22:19 <blackdog> i mean, just by default you're going to have faster safer code than your average rubyist.
13:22:30 <blackdog> (i know this because i am a very average rubyist)
13:22:31 <ongy> have you seen the web? I doesn't look like safe and fast are a requirement these days. It's good to have, but...
13:23:06 <ystael> ongy: distinguish "requirement for running a business" from "requirement for making something you would actually want to work on" :)
13:23:15 <ongy> oh and I'm mixing safe and secure again. But still applies even for safe
13:23:31 <ongy> ystael: The starting question was about the money :)
13:23:57 <ystael> oh, yes, I see
13:24:09 <Aruro> about economy of haskell codebase
13:24:20 <Aruro> money support/motivation
13:24:47 <Aruro> hledger is not distributed on windows, so windows pain seems real.
13:25:45 <maerwald> it's ok to not support windows
13:26:03 <maerwald> it's an unethical operating system, taking away pretty much all user freedoms
13:26:06 <ongy> for GHC there's a few people that are payed by companies. Microsoft research for example
13:26:21 <ystael> Is it OK to advertise jobs in here?
13:27:35 <ongy> people do from time to time. But IRC may not be the best platform to do so (volatile, and with a fast-ish channel like this not many people will see it)
13:28:48 <ezyang> cdornan: You mispelled regex as reflex on Reddit too :P 
13:30:23 <cdornan> ezyang: Corrected -- thanks! 
13:32:05 <tapirus> muesli4: thanks yeah, this looks like what I was looking for :) thanks!
13:41:25 <tapirus> why does compare [EQ] (repeat EQ) return LT?
13:41:45 <jle`> > "hi" < "hill"
13:41:49 <lambdabot>  True
13:41:49 <jle`> it's dictionary ordering
13:41:58 <jle`> would "hi" or "hill" come first in a dictionary?
13:42:02 <blackdog> i guess that's the same question as compare [] (repeat EQ), really.
13:42:07 <tapirus> hmm
13:42:21 <blackdog> wait, jle` 's explanation is better, ignore me
13:42:22 <tapirus> I guess intuitvely I expected it to behave as zipWith (compare) [EQ] (repeat EQ)
13:42:49 <glguy> jle`: How heavy do you suppose this dictionary containing infinitely long words would be?
13:42:49 <jle`> so it should return an [Ordering] ?
13:42:51 <tapirus> but yeah, I get jle`s's explanation
13:43:04 <jle`> :t compare
13:43:06 <lambdabot> Ord a => a -> a -> Ordering
13:43:07 <monochrom> Intuition is fantasy.
13:43:14 <jle`> compare returns an Ordering, not an 'a'
13:44:45 <jle`> tapirus: what would you have expected the answer to be?
13:46:00 <nitrix> Can someone with a reasonable understanding of decision trees (used as classifiers) kind of breif me on the minimal operations (decisions) the tree needs to support to perform its classification work?
13:47:10 <nitrix> The inputs are doubles in the range [0, 1]. I'm guessing X > Y and X * Y > Z ?
13:47:19 <nitrix> Is this the most minimal?
13:49:00 <nitrix> Actually X * Y > Z makes no sense, unless I don't have a tree with a single root, but a directed graph instead.
13:49:17 <jle`> what are you calling X, Y, and Z here?
13:49:18 <tapirus> jle`: yeah sorry, I just wrote that zipWith statement but that's not what I really meant...I get the right answer now, but for a moment, I was expecting that if I took some arbitrary array, say x, and compared it with (repeat n), then the result would be the same as (compare x (replicate (length x) y)
13:49:45 <nitrix> This is starting to look like a neural network. Let me think a little and ask a better question.
13:50:02 <jle`> tapirus: ah
13:50:07 <jle`> tapirus: how would you even implement that?
13:50:30 <jle`> you can't test if a list was created with 'repeat' or not
14:23:14 * monochrom is tempted to reply in haskell-cafe "No, this is an abuse of programs. Programs are not wrong, humans are."
14:25:34 <kuribas> > let (+) = (-) in 1 + 1
14:25:38 <lambdabot>  0
14:27:08 <glguy> monochrom: Which thread?
14:27:23 <monochrom> To [] or not to []
14:27:54 <Ariakenom> > let (+) = (*) in 2+2
14:27:58 <lambdabot>  4
14:28:27 <monochrom> So the original poster wrote statement of the form "if you use list for <a purpose that list is bad at>, your program is wrong"
14:28:52 <monochrom> And I think "your program is wrong" is a hyperbole and we should take it as such, rather than arguing semantics.
14:29:13 <maerwald> you're deliberately misinterpreting what he said I think
14:29:29 <monochrom> But Richard O'Keefe did decide to argue semantics. "This is an abuse of the word 'wrong'"
14:30:16 <maerwald> but I realize this sort of nitpicking is very characteristic to the haskell community
14:30:28 <maerwald> and ofc can be fun at times
14:30:39 <monochrom> maerwald, I did not nitpick, O'Keefe did.
14:31:13 <monochrom> Or rather, since O'Keefe felt like nitpicking, I would nitpick the nitpicker.
14:31:17 <maerwald> xD
14:33:10 <jmcarthur> Is this metanitpicking?
14:33:15 <maerwald> haha
14:33:53 <monochrom> No, this is reductio ad absurdum
14:40:01 <kuribas> we call it fucking ants
14:40:31 <kuribas> mierenneuken
14:45:23 * kuribas wishes haskell had better debuggers
14:49:47 <frontendloader> kuribas: "The compiler is your debugger" - #haskell
14:50:07 <kuribas> it sucks
14:50:40 <ezyang> invest in your logging infra 
14:51:07 <kuribas> I have a long list of data representing bezier curves, it's giving me a headache...
14:51:08 <monochrom> frontendloader, I have seen in the past few days that kuribas's debugging need exceeds what type-checking can do.
14:51:48 <frontendloader> I agree with him, being able to step through/inspect code is how I learn/progress primarily
14:52:28 <benzrf> i debug using the repl
14:52:28 <kuribas> monochrom: yeah, it's numerical code.
14:53:23 <kuribas> monochrom: on the other hand I am abusing Data.Set, so it may be my fault...
14:53:53 <monochrom> I can't imagine how Data.Set could possibly be abused...
14:54:15 <kuribas> monochrom: I have an ordering of curves, which implies they don't touch.
14:54:34 <kuribas> monochrom: so I am using Data.Set as a binary tree
14:55:36 <kuribas> maybe debugging numerical code is just hard in general...
14:56:16 <monochrom> Ah, maybe you don't really have a total order. Yeah that could be abuse, but still not always.
14:56:36 <kuribas> monochrom: it's total as long as the invariant holds.
14:57:23 <monochrom> Hmm. Debug the invariant? :)
14:57:36 <kuribas> yeah, I have many assertions now
14:59:10 <`Guest03> how to poke an array efficiently?
14:59:24 <`Guest03> array comes from a list
14:59:29 <`Guest03> so, poke a list
14:59:41 <`Guest03> into adjacent locations as array
14:59:53 <monochrom> There is no efficient way for lists. Use a real array.
15:00:12 <`Guest03> oh, a question i wanted to ask
15:00:36 <`Guest03> if i write: arr = ByteString.pack [0, 1, 2, 3, 4]
15:00:36 <monochrom> Most array libraries have a "fromList" function or such for dumping a list into an array.
15:00:44 <`Guest03> as top-level definition
15:01:04 <`Guest03> what will it do at compile time and runtime?
15:01:32 <monochrom> Compile time will preserve that expression. Run time will do the conversion at most once, then memoize.
15:02:18 <`Guest03> monochrom: can i get it to convert it at compile time without TemplateHaskell?
15:02:34 <monochrom> No.
15:02:53 <`Guest03> i want that
15:02:55 <monochrom> Yes. Write a GHC plugin.
15:03:14 <kuribas> doesn't ghc unroll short expressions?
15:03:15 <monochrom> 5 hours of template haskell can be saved by 5 months of GHC plugin.
15:03:29 <monochrom> FSVO "short"
15:03:46 <monochrom> Pretty sure "x :: Int; x = 1+1" is compile-time simplified.
15:03:55 <`Guest03> can we have it in future
15:04:01 <AWizzArd> System.Random.MWC – is it possible to use this to select a random item out of a list?
15:04:24 <kuribas> monochrom: because it's an arithmetic primitive...
15:04:44 <monochrom> I don't know the future.
15:05:02 <maerwald> I do, but only if you pay me...
15:05:34 <glguy> and when we don't the future is a blur to you?
15:05:44 <maerwald> exactly
15:07:23 <`Guest03> monochrom: i want to have a Ptr to an array of hardcoded data
15:07:32 <`Guest03> what is best way?
15:08:02 <monochrom> I don't know. GHC.Prim may or may not help.
15:09:00 <glguy> Data.ByteString.Char8.pack "the bytestring" 
15:09:24 <monochrom> Is the rest of your program so highly optimized that the only thing left to do is optimizing initialization?
15:10:44 <`Guest03> monochrom: i don't care, i consider deferring conversion to runtime ugly
15:10:56 <`Guest03> i want to not have ugly things in my program
15:11:32 <monochrom> I think we talked about this before.
15:11:39 <glguy> You can put the data in a .c file and import that via the FFI
15:12:31 <leafgreen> I have a question about the syntax of module. Why is it that the whole .hs file doesn't have to be indented with respect to the "module" lines at the beginning?
15:12:41 <glguy> I'd be a waste
15:12:45 <glguy> (but you can do it)
15:12:48 <glguy> it'd*
15:12:50 <glguy> I might be, too
15:12:53 <leafgreen> Is it just a special case in the parsing rule?
15:13:09 <leafgreen> since it is still using a "where" typically
15:13:29 <monochrom> This is not a special case.
15:13:32 <glguy> the parsing rules for module aren't really a special case, just a case
15:13:53 <monochrom> There is, actually, no rule saying "after 'where' you must indent"
15:14:20 <mbw> Hello everybody. I had to write a property test for my program, using hspec/QuickCheck. Luckily, I seem to have found the error immediately. I have a property prop_inequal :: SomeType -> Bool, which internally creates all the values that the argument should NOT compare equal to. So this test indeed failed. However, only the argument that triggered the failure is printed, and I do not know which other value 
15:14:26 <mbw> it unexpectedly compared equal to. I presume my property should either be of a different type, or there should be some fancy verbose flag. Does anybody know about this?
15:14:47 <Tuplanolla> Use `===`, mbw.
15:15:04 <mbw> I'll try that.
15:15:11 <monochrom> The real rule is only of relative indentation. If you are comparing two scopes, then the inner scope needs to be more indented than the outer scope.
15:15:14 <dmj`> :t verboseCheck
15:15:17 <lambdabot> Test.QuickCheck.Property.Testable prop => prop -> IO ()
15:15:28 <monochrom> But the top level has no even-more-outer thing to compare to.
15:15:55 <leafgreen> I see, monochrom
15:16:21 <monochrom> In fact, "     module F where" "x = True" works just fine.
15:16:33 <`Guest03> hmm
15:16:46 <`Guest03> one function withArray solves my problem perfectly.
15:17:18 <mbw> Tuplanolla: It has to work on lists, i.e. it should replace prop g = all (== g) valids, and prop' g = g `notElem` invalids, respectively.
15:17:54 <`Guest03> except
15:17:55 <`Guest03> length
15:17:58 <`Guest03> withArrayLen
15:19:06 <`Guest03> except the length is in elements, not bytes...
15:20:40 <mbw> I'm sure I'll find the other fancy operators once I'm done accidentally building the haddock documentation...
15:22:27 <ezyang> Suppose that you can either define a helper function in a where clause, or top level. Which do you prefer? how do you decide? 
15:24:37 <`Guest03> ezyang: where clause
15:24:49 <`Guest03> except if it would be used by more than one function
15:24:51 <glguy> Inside is nice if I want to be able to use a few other where-claused defined things all of which share common values and/or access to the arguments of the parent
15:25:09 <glguy> outside the where clause otherwise so I can test it out independently from GHCi
15:25:13 <monochrom> Top level for the first few months (for easier testing and debugging). Then inner.
15:26:26 <ezyang> Quite a variation of responses! :O 
15:26:41 <glguy> visibility can be managed by export lists, if the module gets too big I can make a new module
15:26:41 <monochrom> Then outer again because I am explaining it to someone else and I want to demo it. Then inner again.
15:27:00 <monochrom> This flipflopping continues indefinitely.
15:27:09 <ezyang> Sometimes I feel like if you put it in a where clause, you often have free variables that you shouldn't 
15:27:43 <glguy> having those free variables is why you'd put it in a where clause in the first place :) that seems like a contradiction
15:27:45 <monochrom> That kind of thinking will get you into the trouble of combinatory logic.
15:28:06 <ezyang> well, maybe it's just one or two new parameters 
15:28:12 <ezyang> and the top level brings, like 10 names into scope 
15:33:00 <mbw> Ok I found out that I can do something like prop g = conjoin $ (=== g) <$> valids. However, I don't see an analogous inequality operator. How would I express that?
15:33:57 <`Guest03> i'm pleasantly surprised with highlevelness of some binding libraries 
15:34:05 <michalrus> Hey! Quick (silly?) question: I have a list of functions, say, [a -> Maybe b], but I would also want each of them to have access to its own state — each state being of different type, unknown/transparent to the call site using this list. What would be the best way to approach this?
15:34:38 <glguy> What's state?
15:34:39 <`Guest03> you could think it would have ugly low-level types which need conversion every time, but no
15:34:48 <monochrom> There is no "state".
15:35:13 <`Guest03> not all types are high-level, but most are
15:35:21 <jle`> michalrus: well, each function can have its own closure
15:35:40 <`Guest03> shaderSource :: Shader -> StateVar [String] -- how cool, native strings.
15:35:41 <jle`> but by state, do you mean some sort of environment?
15:36:05 <michalrus> Yes, yes, I’m aware of that. :) Let’s say the signature is [s -> a -> (s, Maybe b)], and state is s.
15:36:12 <jle`> for addN n = (\x -> x + n), n is a part of the colsure/'state' of 'addN 10'
15:36:15 <michalrus> How can I have different s for each function?
15:36:40 <jle`> michalrus: what are you planning on doing with this list?
15:36:45 <`Guest03> michalrus: existential quantification
15:36:56 <glguy> michalrus: You can have:  data T a b = MkT (a -> (Maybe b, a -> T a b))
15:37:21 <jle`> michalrus: how would you even interact with each type?
15:37:25 <jle`> er, with each function
15:37:49 <jle`> if the state type is opaque, how would you get a state to give each function?
15:37:51 <glguy> or rather: data T a b = MkT (a -> (b, a -> T a b)) -- If you want b to be Maybe Something, that's fine
15:37:51 <michalrus> jle`: I want to run each function until one matches and returns a Just b, and return this (potentially) matched Maybe b.
15:38:17 <jle`> michalrus: but how can you run the function without giving an 's'
15:38:20 <michalrus> Nice, thank you for all the replies, I know what to google/hoogle now! (:
15:38:40 <jle`> if the functions are (s -> a -> (s, Maybe b)), and you want to 'run' it while only having an 'a', where do you get the 's' from?
15:38:41 <michalrus> jle`: the state would have to be somehow kept in the call site, yes…
15:38:57 <jle`> if the state is opaque to the call-site, then the state cannot be kept at the call site
15:39:02 <michalrus> :(
15:39:20 <jle`> what you can do is "store" an initial state with every function
15:39:20 <glguy> michalrus: No need to Google, I already wrote the type that does that
15:39:35 <jle`> but that's basically the same thing as my 'addN' example up there
15:40:11 <michalrus> glguy: I’ll read about MkT, thank you. 🙇
15:40:18 <jle`> useBoolState b = (\x -> if b then x else negate x)
15:40:24 <jle`> useIntState n = (\x -> x + n)
15:40:26 <glguy> michalrus: No, there's nothing to read. MkT is being defined on that line
15:40:35 <michalrus> Ah!
15:40:42 <kuribas> michalrus: each function in the list updates the state?
15:40:49 <jle`> you can now store `useBoolState True` and `useIntState 10` inside the same list
15:40:49 <michalrus> kuribas: yes.
15:41:28 <glguy> michalrus: Do all the functions share the same 's' value? does the output of one become the input of another?
15:41:41 <michalrus> No, they’re completely separate.
15:41:47 <jle`> :t let useBoolState b = (\x -> if b then x else negate x); useIntState n = (\x -> x + n) in [useBoolState True, useIntState 10]
15:41:49 <lambdabot> Num a => [a -> a]
15:42:03 <jle`> i've stored functions with different types in their closures in the same list, there
15:42:29 <jle`> (it's also not clear what you want to do with the 's' in the result of each function)
15:43:00 <jle`> what's the bigger problem you want to solve here?
15:43:13 <michalrus> jle`: store it somehow, for future calls of that particular function. (:
15:43:15 <jle`> this sounds like it might be a clear XY problem kind of situation
15:43:49 <michalrus> Haha, OK. I’ll explain it more widely.
15:44:50 <jle`> there's something you might be able to do with the 'auto' library that might let you do exactly what you described, but i'm not sure if you really want what you're asking for
15:45:34 <jle`> but the `Auto' a b` type represents an `(s -> a -> (b, s))` function paired with an initial state 's'
15:45:38 <jle`> that's opaque to the caller
15:46:02 <jle`> and you can "run" it to get the resulting 'b', and also a new Auto with an updated state
15:46:22 <jle`> (it's also Mealy from the machines library)
15:47:38 <jle`> so your type might be runAllAutos :: a -> [Auto' a b] -> ([b], [Auto' a b])     -- the Auto's in the resulting list have the updated states
15:48:50 <ezyang> Flipping between [] and Maybe is surprisingly annoying 
15:50:32 <michalrus> jle`: Bigger picture: I’ve got some `source :: IO Text` of, say, commands. Now, I want to have different handlers for these commands defined as `Text -> IO (Maybe SomeResult)`. If a handler returns Nothing, it means that the next handler should be used. If Just, just return that result. But I’d also want each handler to have access to its state that it can read and modify between calls. Now, since it’s
15:50:32 <michalrus> all happening in IO, I could probably store the state somewhere in IO, but there should be a better way…
15:51:03 <jle`> michalrus: if ti's all happening in IO then it's probably simplest to just have an IORef in the closure of the function
15:51:27 <michalrus> Call site has source, list of handlers and is supposed to return IO (Maybe SomeResult).
15:51:33 <michalrus> Yeah, but what if it wasn’t? (:
15:52:13 <jle`> if you're stuck with the idea of "state", then each call has to return a new list of functions
15:52:19 <glguy> ezyang: That reminds me that you can switch between Maybe and [] nicely in list comprehensions (with enough extensions), e.g. [ x | x <- [1..10], odd x, then listToMaybe, x > 3]
15:52:27 <jle`> and you would run the query on that new list every time
15:52:45 <jle`> the new list of functions would have the updated states in their closures
15:53:21 <jle`> libraries like 'auto'/'machines' make it a little more easy to implement state-updating closures like this, but there's no way getting around returning a new list every time you run it
15:53:58 <jle`> (if you're sticking with "pure" queries/handlers)
15:54:02 <glguy> also, libraries like auto and machines are not the place to start when getting stuck on questions like this
15:54:15 <ezyang> glguy: Hmm 
15:54:40 <jle`> if you're already in IO then you can just have the IORef in the closure to the function, and you have an easy solution
15:54:42 <michalrus> Mhm. :) OK, thank you, all. I’ll read carefully through the log once more.
15:54:45 <ezyang> I don't really want to bust out comprehensions though, because the code is pointless 
15:54:51 <Zemyla> You know, I think I have figured out the contravariant equivalent of Monad.join.
15:55:04 <jle`> but yeah, if you're not in IO, you have to be able to create closure-updating functions and return new functions every time you run them
15:55:26 <jle`> you can create them from scratch using lambda abstractions (they're not that hard), but there are libraries that make it simpler, yes.
15:55:28 <lyxia> Zemyla: what is it
15:56:53 <jle`> data MyHiddenState a b = forall s. MkHS s (s -> a -> (b, s))
15:57:13 <Zemyla> lyxia: contrajoin :: f (f (f a)) -> f a
15:57:25 <jle`> runMyHiddenState x (MkHS s0 f) = let (y, s') = f s0 x in (y, MkHS s' f)
15:57:55 <jle`> runMyHiddenState :: a -> MyHiddenState a b -> (b, MyHiddenState a b)
15:58:37 <jle`> the type of the state isn't in the type of MyHiddenState, so you can store MyHiddenState's of different internal state types in the same list
15:59:43 <Zemyla> It's basically triple negation elimination.
16:01:41 <Zemyla> Or maybe it's the other way around. f a -> f (f (f a)).
16:02:40 <Zemyla> Because I know contrareturn would be a -> f (f a).
16:05:07 <Ptival> is there a known trick to deal with a state monad where certain parts of the code should only have read-only access to certain parts of the state?
16:05:20 <Ptival> seems lens-y
16:05:32 <jle`> Ptival: there's a common readOnly pattern
16:05:38 <michalrus> jle`: so that’s what glguy suggested, also. (: I’ll look into that, looks much more interesting than IoRef. Thank you, to both of you!
16:05:39 <jle`> readOnly :: Reader s a -> State s a
16:06:10 <jle`> and you can use 'zoom' on the result
16:06:55 <jle`> zoom :: Lens s t -> State t a -> State s a
16:07:10 <Ptival> ah yeah that could help
16:07:13 <jle`> i'm not sure if there's a pre-written way that combines them, though
16:07:30 <jle`> i've only seen readOnly as an idiom but I haven't seen it defined anywhere
16:08:01 <Ptival> the idea is my state has a global component, and a local component, and some functions should have read-only access to the global part and read-write to local, while the toplevel code is allowed to modify the global
16:08:03 <jle`> so `zoom _1 . readOnly $ do ....`, the do block would be a Reader with access to the first item in a tuple state
16:08:15 <Ptival> I could also make the local parts just run in a different state monad I guess
16:08:25 <Ptival> maybe it would be simpler
16:08:38 <jle`> yeah, the typical way is to write the local parts in a State monad that has only small portion of the global state as its state
16:08:40 <Ptival> to put (Reader GlobalState, State LocalState) or something
16:08:51 <Ptival> makes sense :)
16:08:54 <jle`> and then use 'zoom' to use it as a part of a bigger fatty state type
16:08:56 <Ptival> thanks for the brainstorming
16:09:19 <jle`> no problem :)
16:09:41 <Zemyla> Yeah, because contrabind would be f a -> (b -> f (f a)) -> f b.
16:09:54 <jle`> \me . o ( zoom _1 . readOnly :: Reader r a -> State (r, s) a )
16:10:00 <robkennedy> Is DPH still active? I can't find a repo that compiles with ghc 8, but it seems perfect for my usecase
16:11:04 <robkennedy> In particular, is there an implementation for the syntax SPJ mentions: `[: 1,2,3 :]`
16:15:46 <robkennedy> @pl \a -> \f g -> (,) <$> f a <*> g a 
16:15:47 <lambdabot> ((((,) <$>) .) .) . ap (flip . (((.) . (<*>)) .) . flip id) (flip id)
16:16:06 <Ptival> oh, but if I have (MonadReader T m, MonadState T m), how do I make sure from the caller point of view that it's not the State monad filling in the Reader task?
16:17:57 <glguy> Ptival: By using those constraints you're saying you don't care
16:18:02 <robkennedy> @pl \a -> let f x = if null x then Nothing else Just (length x) in (,) <$> listToMaybe a <*> f a
16:18:03 <lambdabot> flip (((,) <$>) .) (ap (flip if' Nothing . null) (Just . length)) . ap ((.) . (<*>) . listToMaybe) (flip id)
16:18:12 <dunx> nnpppp/buffer 45
16:18:19 <robkennedy> Damn lambdabot too clever
16:18:19 <Ptival> glguy: so I'd need a newtype to be able to discriminate?
16:18:40 <glguy> Ptival: Just pick an 'm' that has the behavior you want
16:20:50 <robkennedy> @djinn (x -> Maybe a) -> (x -> Maybe b) -> x -> Maybe (a,b)
16:20:50 <lambdabot> f a b c =
16:20:50 <lambdabot>     case b c of
16:20:50 <lambdabot>     Nothing -> Nothing
16:20:50 <lambdabot>     Just d -> case a c of
16:20:50 <lambdabot>               Nothing -> Nothing
16:20:52 <lambdabot>               Just e -> Just (e, d)
16:21:05 <glguy> robkennedy: You can play with lambdabot in /msg
16:22:04 <robkennedy> Sorry. Apart from the distraction: do you know the status of DPH?
16:30:25 <`Guest03> @pl \name loc -> attributeLocation prog name $= loc
16:30:25 <lambdabot> ($=) . attributeLocation prog
16:30:37 <`Guest03> dang
16:32:50 <nilof> What alternative preludes are the most used?
16:33:15 <Welkin> I think most people don't bother with any prelude
16:33:33 <Welkin> I've used classy-prelude in the past, but it is overly complex
16:34:03 <Welkin> all the prelude does it re-export other modules
16:34:08 <Welkin> is*
16:34:38 <Jenaf> Hi there! I'm beeing stupid right now
16:34:57 <Jenaf> whats the equivalent to "map" for Data.Sequence
16:34:58 <Welkin> is that a bee joke?
16:35:04 <Welkin> Jenaf: fmap
16:35:08 <Welkin> fmap is the generic map
16:35:10 <Welkin> :t fmap
16:35:13 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:35:31 <Jenaf> okay, do i need to import it from traversable or so?
16:36:57 <Koterpillar> it is in Prelude
16:37:18 <`Guest03> omg
16:37:53 <`Guest03> why don't modules export specialized functions with standard names?
16:37:59 <`Guest03> like map in this case
16:38:07 <Welkin> ?
16:38:17 <Welkin> fmap is the standard...
16:38:21 <`Guest03> map is too
16:38:24 <Welkin> map is the weird one that is specialized to List
16:38:43 <`Guest03> Data.Sequence.map would be specialized to Seq
16:38:47 <inferno-cop> Welkin: Does map only exist for historical reasons?
16:38:52 <Welkin> yes
16:39:03 <Welkin> fmap is what you want
16:39:04 <`Guest03> maybe i like to use specialized functions
16:39:14 <`Guest03> for extra type robustness
16:39:17 <`Guest03> or whatever
16:39:26 <`Guest03> is it so hard?
16:39:40 <Welkin> I assume that the 'f' stands for "Functor", as in, "functor map"
16:39:44 <pacak> `Guest03: Specialized functions are actually worse
16:40:02 <pacak> For example
16:40:03 <pacak> :t id
16:40:06 <lambdabot> a -> a
16:40:18 <pacak> There's only one implementation (ignoring bottoms)
16:40:23 <pacak> But for
16:40:31 <pacak> :t id (Int -> Int)
16:40:33 <Welkin> I have felt the pain of using specialized functions for everything when using Elm
16:40:34 <lambdabot> error:
16:40:34 <lambdabot>     Pattern syntax in expression context: Int -> Int
16:40:34 <lambdabot>     Did you mean to enable TypeApplications?
16:40:36 <Welkin> it sucks
16:40:43 <pacak> there are a whole bunch of versions
16:40:45 <Welkin> you have to explictly import and qualify *everything*
16:40:50 <`Guest03> oh well
16:41:03 <pacak> :t map
16:41:05 <pacak> :t fmap
16:41:06 <lambdabot> (a -> b) -> [a] -> [b]
16:41:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:41:18 <Koterpillar> `Guest03: Elm does that, and it's a pain
16:41:26 <`Guest03> anyway map not only carries that, but also promise that it won't reorder and duplicate elements
16:41:31 <pacak> function with map's type signature can change the shape, fmap - does not.
16:41:44 <pacak> Not in the type signature
16:42:01 <Welkin> @src map
16:42:01 <lambdabot> map _ []     = []
16:42:01 <lambdabot> map f (x:xs) = f x : map f xs
16:42:05 <Welkin> wrong one
16:42:07 <inferno-cop> I think it's bad enough that there aren't general versions of collection functions like (!), insert etc
16:42:10 <Welkin> map is actually defined using fmap
16:42:16 <Welkin> so, it gives you no benefits whatsoever
16:42:56 <Welkin> ! is only used for Vector, !! for List
16:43:04 <Welkin> !! is almost never used for any reason
16:43:06 <`Guest03> Welkin: what should i use: singleton or return?
16:43:14 <Welkin> because List indexing is slow
16:43:17 <Koterpillar> `Guest03: there's another choice, pure
16:43:22 <Welkin> use pure o.o
16:43:27 <`Guest03> or pure
16:43:31 <`Guest03> are you sure?
16:43:38 <Welkin> unless you want to be explicit and use Map.singleton
16:43:41 <`Guest03> what if we are deep down in layers of Applicative?
16:43:41 <inferno-cop> But I mean, you have Data.Map.! and Data.Array.! for example
16:43:43 <Welkin> that's fine
16:44:01 <inferno-cop> And you have to qualify them if you've got both in scope (I think?)
16:44:20 <Welkin> you have to qualify Vector, Array, etc almost every time anyway
16:44:28 <Welkin> because they share similar apis with List
16:44:32 <Welkin> at least Vector does
16:44:39 <`Guest03> Welkin: that would be V., A., ...
16:44:45 <Welkin> yes
16:44:52 <Welkin> I am not sure what your point is
16:44:58 <inferno-cop> Yeah, why can't we just have a Indexable typeclass or something, so we don't have to qualify
16:45:08 <`Guest03> i want to be explicit when i want
16:45:23 <Welkin> fmap comes from the Functor typeclass
16:45:23 <`Guest03> specialized = explicit
16:45:30 <`Guest03> abot the type
16:45:33 <Welkin> ! does not have a typeclass
16:45:54 <`Guest03> by the way
16:46:08 <`Guest03> why the names ! and !! were chosen?
16:46:14 <inferno-cop> It doesn't, but I am saying the world may be a better place if it had a typeclass
16:46:32 <Welkin> inferno-cop: that has been taken to its logical extreme with classy-prelude
16:46:39 <Welkin> and it's a monster
16:46:50 <Welkin> too many typeclasses makes the code impossible to understand
16:46:57 <glguy> gaudy-prelude?
16:47:06 <inferno-cop> Oh, I hadn't heard about that, but I can definitely imagine it...
16:47:18 <Welkin> I think the name 'classy' refers to typeclasses :P
16:47:25 <`Guest03> inferno-cop: in that case, either that typeclass had to provide algorithm complexity restrictions or hadn't
16:47:50 <`Guest03> in first case, there are less !'s which could make it into the typeclass
16:48:16 <`Guest03> in the second case, you can write less code or be less sure about its complexity
16:48:25 <`Guest03> have to *
16:48:32 <Welkin> `Guest03: not having generic functions like `fmap` means you can never write generic functions yourself
16:48:32 <inferno-cop> Fair point.
16:48:35 <Welkin> that is horrible
16:48:51 <Welkin> you have a function you want to operate on Lists, and on Array, and on Map, and on etc.
16:48:58 <Welkin> have to copy/paste it several times
16:49:00 <Welkin> it's just stupid
16:49:07 <`Guest03> Welkin: i never said that we don't need generic functions
16:49:15 <Welkin> that is why Elm sucks
16:49:18 <Welkin> at least one reaosn
16:49:20 <`Guest03> i said that i need names for specialized versions too
16:49:31 <`Guest03> defined in modules.
16:50:28 <Welkin> `fmap :: (a -> b) -> [a] -> [b]` -- `Guest03 , done
16:50:30 <inferno-cop> But at the same time, lists, arrays, maps, sets etc are all different in important ways, so writing generic implementations of algorithms for them would seldom be a good idea (if you care about performance)
16:50:35 <Welkin> there is your specialized fmap for List
16:50:39 <`Guest03> Welkin: too verbose
16:50:45 <`Guest03> could just use L.map
16:51:04 <Jenaf> I still have the feeling that I'm producing ugly code:
16:51:05 <Jenaf> ieldReducer rows (a:(b:list))= (fmap (bfRowSetZeroPastN b) (Seq.take (b-a) rows))><(fieldReducer (Seq.drop (b-a) rows) (b:list))
16:51:19 <Welkin> Jenaf: this ain't lisp
16:51:20 <Welkin> !
16:51:29 <pacak> Jenaf: You are.
16:51:41 <Welkin> Jenaf: paste it on lpaste and we can show you how to clean it up
16:51:42 <Jenaf> I know but $ keeps throwing compilation errors
16:51:43 <Welkin> @lpaste
16:51:43 <lambdabot> Haskell pastebin: http://lpaste.net/
16:51:52 <Welkin> also, don't try to construct one big expression
16:52:03 <inferno-cop> At least their should be a space on both sides of the equals sign :P
16:52:03 <Welkin> break it up into smaller functions and use let/where clauses where they can help
16:52:40 <Jenaf> in this case i think breaking it up into where would make it less readable
16:53:05 <Jenaf> I've already broken down the main thingy into many subfunctions ^.^
16:53:29 <`Guest03> blah @lpaste
16:53:39 <`Guest03> hm
16:54:19 <Jenaf> http://lpaste.net/353365
16:54:22 <`Guest03> could parse that, then user could mention lpaste and invoke command simultaneously
16:54:44 <Jenaf> I'm quite sure I don't have the perfect representation of the Problem I want to tackle.
16:54:58 <MarcelineVQ> `Guest03: it's bad form for a bot to guess what you intend, it tends to produce noise
16:55:19 <`Guest03> that's bad if noise is very bad
16:55:28 <MarcelineVQ> noise is very bad
16:55:41 <`Guest03> it's not very bad for me...
16:55:43 <Welkin> Jenaf: something more like this http://lpaste.net/353366
16:55:49 <Welkin> but add type signatures to your functions
16:55:57 <`Guest03> okay
16:56:25 <Jenaf> I think i always have signatures
16:56:35 <Jenaf> thats what i start with when writin a function
16:56:57 <Welkin> Jenaf: I see you are using list comprehensions in your code as well
16:57:07 <Welkin> try to avoid those, especially for your use case
16:57:12 <Welkin> just use a simple `filter` instead
16:57:22 <Jenaf> can you tell me an example line?
16:57:29 <Jenaf> (jsut line number)
16:57:37 <Jenaf> also: I don't get <$>
16:57:43 <Welkin> http://lpaste.net/353365#line121
16:57:51 <Welkin> `<$>` is infix `fmap`
16:58:09 <Welkin> you could also write it as `fmap` (literally with backticks)
16:58:20 <Welkin> wrapping any function in backticks makes it infix
16:58:32 <Welkin> <$> is specifically already defined as infix though
16:59:09 <Jenaf> okay, so it's syntactical sugar
17:00:50 <Jenaf> btw: those lists/sequences are only 9 elements long
17:01:05 <ReinH> `` is syntax, <$> is a normal operator.
17:01:24 <Jenaf> see line 70 for evil magic number code
17:01:53 <inferno-cop> @src (<$>)
17:01:53 <lambdabot> f <$> a = fmap f a
17:02:11 <Welkin> Jenaf: I see a lot of unnecessary parentheses, but you'll get used to precedence rules with time
17:02:19 <Jenaf> yeah
17:02:30 <Jenaf> I tend to try and be better safe then sorry.
17:02:52 <Jenaf> and soemtimes $ messes up at compliation/ loading in ghci
17:02:58 <Welkin> the great thing about haskell is that you can afford to take risks
17:03:03 <Welkin> if you mess up, the compiler will tell you
17:03:07 <Jenaf> so I feel unsure about using $, but I know what parans do
17:03:09 <Welkin> unlike other languages that fail at runtime
17:03:36 <Welkin> $ is function application, but it has the lowest precendence
17:03:37 <inferno-cop> I actually think $ often looks uglier than parentheses
17:03:45 <Jenaf> like when you use gcc to compile C code with null pointers
17:03:56 <Welkin> so it's like wrapping everything to the right-hand side of the $ in parens
17:04:59 <Jenaf> what I don't really like is stuff like  
17:05:00 <Jenaf> if isNothing squares
17:05:02 <Jenaf>         then Nothing
17:05:03 <Jenaf>     else Just $ foo (fromMaybe (error "unreachable") squares)
17:05:21 <Koterpillar> Jenaf: this is fmap foo
17:05:22 <inferno-cop> that can be rewritten!
17:05:33 <Welkin> try to avoid using if-then-else
17:05:43 <Welkin> it is not idiomatic and there are almost always better ways to write it
17:05:44 <Koterpillar> > let foo = (* 2) in fmap foo (Just 3)
17:05:49 <lambdabot>  Just 6
17:05:53 <Koterpillar> > let foo = (* 2) in fmap foo Nothing
17:05:56 <lambdabot>  Nothing
17:05:56 <Welkin> use pattern matching as much as possible
17:06:03 <Welkin> and higher-order functions
17:06:10 <Jenaf> yeah 
17:06:21 <drostie> What I like about $ is that a $ b $ c $ d is equal to a . b . c $ d.
17:06:27 <Welkin> and yes, the Myabe Monad instance 
17:06:36 <Koterpillar> functor
17:06:37 <Welkin> Maybe*
17:06:40 <inferno-cop> yup, your entire example can be rewritten: fmap foo squares
17:06:43 <Welkin> er, Functor yes
17:06:50 <Welkin> the Monad instance is very useful too though :P
17:07:04 <Jenaf> lul
17:07:07 <Koterpillar> Jenaf: but if you want to go step by step, it's this:
17:07:23 <Koterpillar> case squares of Nothing -> Nothing; Just value -> Just $ foo value
17:08:00 <Jenaf> that should be äquivalent to the compiler?
17:08:13 <Jenaf> (interpreted is a different story ofc)
17:08:25 <Koterpillar> all three are equivalent
17:09:02 <Jenaf> but that part with "fromMaybe (error "unreachable") foo" is really ugly
17:09:32 <inferno-cop> Yeah, since you know that error "unreachable" is impossible to reach
17:09:48 <Jenaf> so let mayList::Maybe[a]
17:09:54 <inferno-cop> That's where you should use pattern matching
17:10:16 <Jenaf> then I can fmap (foo:: a->b) mayList
17:10:18 <Jenaf> ?
17:10:35 <Koterpillar> :t fmap
17:10:38 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:10:43 <Koterpillar> replace f with Maybe
17:10:56 <mbw> Ok the other day I asked for some advice about refactoring some data structures. It boiled down to introducing some more "helper types" in order to reduce overlap in constructor arguments. One of those subtypes was something like Helper a = None | A a | B b. I thought "None could be represented by Maybe" and made another type like Helper' a = A' a | B' b, and used it like Maybe (Helper' a). However, in 
17:11:02 <mbw> another function of type a -> Maybe a I introduced a very subtle bug because of this, when going from do notation to "clever Applicative style". So, and this is probably pretty opinionated, is there a lesson to learn from this? Should I try not to be overly clever with types, or stick to do notation? I often find myself "going back to a temporary do representation" when doing changes in functions using 
17:11:08 <mbw> applicative style, after all. Or is Maybe inside data structures generally a little dangerous because of cases like this?
17:11:35 <inferno-cop> Jenaf: No, if you have mayList :: Maybe a, then you can do fmap (f :: a -> b) mayList :: Maybe b
17:12:00 <Jenaf> okay i think i got that
17:13:03 <inferno-cop> Jenaf: and that's the same as: case mayList of { Nothing -> Nothing; Just x -> Just (f x) }.
17:13:26 <Jenaf> Memo to self: you always learn things and meet helpfull people at #haskell
17:13:32 <Jenaf> thanks a lot ^.^
17:14:30 <inferno-cop> So I heard! This is actually my first time ever using IRC :)
17:18:57 <stevenxl> Hi folks. I'm reading Real World Haskell and I have to run ghc -c to compile a source file to object code. 
17:19:03 <stevenxl> Those directions seem to be out of date
17:19:11 <stevenxl> What should I replace them with?
17:19:20 <ezyang> what's the full snippet? ghc -c still works 
17:19:23 <dunx> stevenxl: man ghc
17:19:35 <dunx> iirc -c works tho
17:19:45 <dunx> did for me last time i was writing progs in haskell
17:19:56 <mbw> stevenxl: Generally, the comments you can find on the online version of the books are very helpful.
17:20:03 <mbw> *book
17:20:28 <inferno-cop> ghc -c works for me, just tested it
17:20:39 <mbw> Most of the issues which arise from RWH being dated are adressed there.
17:20:55 <stevenxl> mbw: online version you say?
17:20:59 <Jenaf> I'm going to bed
17:21:07 <Jenaf> see you later space cowboys
17:21:13 <stevenxl> inferno-cop: weird. I am using stack so running `stack ghc -c Source.hs`
17:21:18 <mbw> http://book.realworldhaskell.org/read/
17:21:36 <inferno-cop> stevenxl: Ah, stack. I didn't try that
17:22:09 <stevenxl> mbw: thank you!
17:22:18 <stevenxl> inferno-cop: do I have the wrong program installed?
17:22:53 <stevenxl> I see the -c option in `man ghc`. Stop after generating object file.
17:22:55 <mbw> What are you using the object files for? I don't remember this from reading the book.
17:23:32 <stevenxl> http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html
17:23:51 <stevenxl> mbw: the module is not set up to correctly generate an executable. missing the main function, etc.
17:23:59 <stevenxl> i think i'm just going to brew install ghc and take it from there
17:24:47 <stevenxl> mbw: See section Compiling Haskell Source if you're interested in the area I'm on.
17:24:58 <mbw> Yeah I saw it.
17:25:39 <inferno-cop> stack is good though, but I guess 'stack build' is meant to take care of build details...
17:27:48 <Welkin> using homebrew to install ghc?
17:27:51 <Welkin> sounds like a terrible idea
17:27:59 <Welkin> just use stack or install from the bindist
17:28:07 <Welkin> or use nix
17:29:12 <mbw> stevenxl: Did you try stack exec -- ghc -c Source.hs? From my tab completion I don't see any -c command which could be passed to stack ghc.
17:30:15 <stevenxl> mbw: I just tried that, and it work. Thank you!
17:33:02 <kit_> Hey everyone, I'm running into a haskell problem that I can't figure out how to solve. Effectivley I'm trying to spawn a ghci process using createProcess, and then read and write to it but it keeps freezing or closing after about a minute
17:33:13 <sshine> when I can do [ x | x <- [1..], x < 5 ], is that predicate strictly a list comprehension thing? I can't seem to write 'do { x <- [1..]; x < 5; return x }'
17:33:20 <kit_> I think maybe the input and output handles are being closed but I have no idea how to avoid that, does anyone have any suggestions?
17:33:58 <teto> what would be the best way to look for a string into a string plz ?
17:34:57 <mbw> sshine: I think you need guard from Control.Monad.
17:35:49 <sshine> teto, did you find http://stackoverflow.com/questions/8748660/is-there-a-better-way-to-write-a-string-contains-x-method ?
17:36:11 <sshine> mbw, cool, thanks.
17:36:32 <teto> sshine: I had found others but this one looks better thanks !
17:37:28 <Welkin> sshine: use filter instead of list comprehensions
17:37:47 <Welkin> > filter (< 5) [1..10]
17:37:49 <lambdabot>  [1,2,3,4]
17:38:27 <mbw> teto: I don't think the question is really clear. Do you want to check if it exists? Or find it's position? Or... ?
17:39:01 <teto> mbw existence is enough so I am good ty
17:40:53 <Welkin> 5 `isElem` [1..10]
17:40:56 <Welkin> > 5 `isElem` [1..10]
17:40:57 <Welkin> o.o
17:40:59 <lambdabot>  error:
17:41:00 <lambdabot>      Variable not in scope: isElem :: Integer -> [Integer] -> t
17:41:15 <sshine> just `elem`, no?
17:41:19 <Welkin> > 5 `elem` [1..10]
17:41:20 <Welkin> yeah
17:41:22 <lambdabot>  True
17:41:28 <sshine> True dat.
17:41:28 * Welkin shakes fist at Elm
17:41:36 <Welkin> still recovering
17:42:26 <sshine> hehe.
17:44:13 <mbw> I have some expression like fun (Contructor a b c) = do { b' <- m b; return (Constructor a b' c) }. Is it possible to write this in Applicative style?
17:45:12 <Welkin> ?
17:45:17 <Welkin> that code doesn't make sense
17:46:03 <Welkin> @undo { b <- mb; return b }
17:46:04 <lambdabot> <unknown>.hs: 1: 1:Parse error: {
17:46:16 <Welkin> @undo do b <- mb; return b 
17:46:17 <lambdabot> mb >>= \ b -> return b
17:46:33 <Welkin> well, that is literally just fmap
17:46:47 <mbw> hmm
17:46:51 <Welkin> you could define fmap for your constructor
17:47:14 <Welkin> er
17:47:18 <Welkin> for your mb
17:47:24 <Welkin> whatever that is
17:47:42 <mbw> I think I better paste an example.
17:49:39 <lyxia> looks like a lens
17:50:37 <Koterpillar> mbw: Constructor a <$> m b <*> pure c
17:53:30 <Zemyla> What does it say about an Applicative type when a <* b = a and a *> b = b?
17:56:43 <ReinH> that it's ()?
17:59:09 <mbw> Koterpillar: That's the correct solution, thank you! Still, I pasted a minimal example of what my problem was about: http://lpaste.net/353369
18:02:41 <Koterpillar> checkType (T s n m) = T s <$> check n <*> fmap check m 
18:03:06 <mbw> Koterpillar: Doesn't this correspond to checkTypeWrong?
18:03:13 <mbw> This actually does not do the same thing.
18:03:28 <Koterpillar> checkTypeWrong - no
18:03:39 <Koterpillar> checkTypeWrong always has m as a Just something
18:03:56 <Koterpillar> it is possible to have m = Nothing in my version
18:05:43 <mbw> I do want it to treat the third argument like in the version using do notation, i.e. with pattern matching. From the program logic, if a Nothing is encountered, the other two values should still be able to "make it through".
18:06:05 <mbw> If I try your version with Type "" 6 Nothing, it fails, but it shouldn't.
18:06:43 <mbw> This kind of thing lead to a pretty subtle bug for me.
18:07:36 <Koterpillar> > let check (x :: Int) = if even x then Just (x `div` 2) else Nothing in let checkType (x, y, z) = (,,) x <$> check y <*> pure (fmap check z) in checkType (1, 2, Nothing)
18:07:38 <lambdabot>  Just (1,1,Nothing)
18:08:05 <Koterpillar> Back in your terms, checkType (T s n m) = T s <$> check n <*> pure (fmap check m)
18:09:39 <`Guest03> what does "Segmentation fault/access violation in generated code" mean?
18:09:52 <mbw> This doesn't typecheck for me, the last term expands to Maybe (Maybe (Maybe Int)).
18:11:12 <augur> lambdabot: ?faq can haskell make memes?
18:11:12 <lambdabot> https://wiki.haskell.org/FAQ
18:11:17 <augur> lambdabot: ?ask can haskell make memes?
18:11:18 <lambdabot> Consider it noted.
18:11:21 <augur> :|
18:13:29 <Koterpillar> mbw: suggest changing check to Either, then the type errors will be obvious
18:13:38 <Koterpillar> or anything other than Maybe, really
18:14:22 <`Guest03> oh welllll....
18:15:04 <`Guest03> shaderSource (from the OpenGL binding) segfaults my program if the source text is empty...
18:16:58 <mbw> Koterpillar: I'm using Maybe in the context of symbolic manipulations on algebraic expressions, which can become zero under certain circumstances, so it was an alright fit in this case.
18:17:40 <mbw> I think I will just stick with the version using do notation, for readability.
18:20:28 <mbw> Anyhow, thanks for your help!
18:24:38 <echosystm> what sorts of applications is haskell most suited to, given its performance, libraries, etc?
18:24:50 <markasoftware> echosystm: it's a g8eneral purpose language
18:24:55 <echosystm> i understand that
18:25:10 <echosystm> but in the real world, what is it most useful for compared to other languages?
18:25:52 <markasoftware> depends if you like it or not
18:26:13 <markasoftware> i'd say it's easier to define what it's not so great at: guis
18:26:45 <echosystm> ok let me put it another way
18:26:51 <echosystm> what is haskell most used for?
18:27:03 <markasoftware> what is python most used for?
18:27:17 <echosystm> cultivating neckbeards
18:27:37 <markasoftware> it's not "most used" for any one thing
18:27:42 <markasoftware> or any group of things
18:27:53 <echosystm> swift - ios, ruby - web apps, java - enterprise stuff, etc.
18:28:05 <echosystm> every language has some main purpose that has come about over time
18:28:09 <markasoftware> that's definitely not correct right there
18:28:10 <c_wraith> Haskell is easily most used for writing software
18:28:19 <markasoftware> apart from swift - ios
18:28:22 <c_wraith> it has some other minor uses. 
18:28:25 <markasoftware> ruby existing long before ruby on rails
18:28:32 <c_wraith> but it's definitely for building software 
18:28:35 <echosystm> yeah but almost all ruby devs use rails lol
18:28:43 <ertes> echosystm: haskell is not suitable for targetting small/embedded systems directly
18:28:43 <pikajude> haskell is good for frightening people
18:28:44 <markasoftware> well that's what it's turned into after a while
18:29:01 <markasoftware> but haskell wasn't designed for any one purpose like Javascript was
18:29:14 <echosystm> neither was ruby, but ruby == rails now
18:29:15 <markasoftware> or php
18:29:28 <c_wraith> if you want to get really narrow, Haskell's best niche is software that's maintained. 
18:29:36 <ertes> echosystm: other than that i can't think of anything i wouldn't pick haskell for
18:29:44 <echosystm> so, as an fp newbie, i just want to know what box i can put haskell into
18:30:11 <ertes> echosystm: if you ask 10 people, you will get 10 different answers…  you should just try it
18:30:22 <c_wraith> @quote used.for
18:30:22 <lambdabot> fasta says: Haskell is like an efficient version of Python and is used for the same things.
18:30:40 <c_wraith> hmm, that's not the one I was looking for 
18:30:41 <ertes> @quote HashMap
18:30:41 <lambdabot> ertes says: python can be summarised as HashMap String Dynamic
18:30:54 <markasoftware> echosystm: you can't put C, python, java, or totns of other languages into a "box"
18:31:00 <markasoftware> haskell either
18:31:07 <markasoftware> they're very general purpose lanugages
18:31:11 <markasoftware> php was designed with a purpose -- servers
18:31:18 <markasoftware> js was for front end web scripting
18:31:29 <markasoftware> sql for querying databases
18:31:37 <markasoftware> haskell -- no
18:31:54 <ertes> echosystm: one thing haskell is particularly strong at is concurrency, especially for networked stuff like servers and clients…  it's also strong at processing lots of data (but you need to learn how to do it properly)
18:32:41 <ertes> it's strong at embedded domain-specific languages, if that means anything to you
18:33:09 <c_wraith> Haskell is quite successfully used for live-coding music performances 
18:34:43 <c_wraith> Haskell is also excellent for studying the application of mathematical structures to programming. 
18:34:48 <echosystm> i disagree markasoftware 
18:34:54 <c_wraith> but mostly, it's used for writing software. 
18:34:59 <echosystm> i think C, python and java do have fairly clear uses
18:35:06 <echosystm> but anyway
18:35:11 <ertes> or live-coding in general…  i've used a small lens-based library for live-coding at a crypto workshop several times (often quite literally with a few jaw-drops)
18:35:15 <markasoftware> what exactly is C's single use case?
18:35:30 <echosystm> it sounds like systems programming would be a pretty common use for haskell
18:35:42 <echosystm> probably comparable to the sorts of projects i'm using go for currently
18:36:07 <markasoftware> or java or python for that matter
18:36:19 <markasoftware> all three of those have been used for all sorts of major projects that are very different
18:36:39 <markasoftware> java has been used for mobile apps, desktop games, giant databases (cassandra), servers, etc etc
18:37:13 <ertes> echosystm: i've observed a lot of haskell programmers trying to bring everything into haskell-land, often rewriting haskell versions of libraries from scratch to do it (myself included)
18:37:55 <ertes> so it's really difficult to decide what you will be using haskell for, until you have actually learned it to some extent
18:39:19 <c_wraith> ertes, lens makes a lot of live-coding jaw-dropping. like, lens-aeson makes live json manipulation astounding. and I had a demo of using lenses to examine a full game tree for tic-tac-toe in a live setting. 
18:39:57 <ertes> c_wraith: my use case was stuff like:  textFiltered isAlpha . blocks 3 . ix 0 . letter +~ 13
18:40:13 <ertes> i.e. rotate every third *letter* by 13 places
18:40:31 <ertes> the jaw-drop effect kicks in as soon as you use traversals =)
18:40:33 <peddie> c_wraith: is there a screencast of any of these available?
18:41:12 <ertes> or non-field lenses like textFiltered (lens into a filtered portion of the text)
18:41:15 <c_wraith> peddie, no. best I can do is find the code that created the game tree and lenses for working with it. 
18:41:24 <peddie> no worries
18:41:42 <MarcelineVQ> what do you two mean by live coding?
18:42:05 <Gurkenglas_> Try to do screen recordings the next time, or stream it on a website like livecoding.tv
18:42:13 <ertes> MarcelineVQ: in my case: sitting in front of an audience with a beamer and hacking stuff into emacs/GHCi
18:42:35 <c_wraith> MarcelineVQ, setting up some tools and then use them interactively to try things based on the result of previous exploration. 
18:42:43 <c_wraith> MarcelineVQ, usually in a REPL
18:43:59 <hololeap> when you use record syntax with one argument of a constructor, do you have to use it for all arguments of the constructor?
18:44:23 <ertes> hololeap: only when using the constructor rather than an existing value in scope
18:45:11 <MarcelineVQ> ertes, c_wraith: thank you
18:45:55 <ertes> @let data Person = Person { _numFingers :: Integer, _numTeeth :: Rational } deriving (Eq, Ord, Show)
18:45:58 <lambdabot>  Defined.
18:46:22 <hololeap> for instance `data Iterator a = a {nextLevel :: Iterator a}` gives me "Record syntax is illegal here", but `data Iterator a = {iterItem :: a, nextLevel :: Iterator a}` is ok
18:46:44 <Axman6> that doesn't look ok
18:46:49 <geekosaur> hololeap, yes it's all or nothing and it must have a constructor
18:46:51 <ertes> @let dentist x = x { _numTeeth = 32 }
18:46:52 <geekosaur> a is not a constructor
18:46:54 <lambdabot>  Defined.
18:47:07 <ertes> > dentist (Person 10 17.4)
18:47:11 <lambdabot>  Person {_numFingers = 10, _numTeeth = 32 % 1}
18:47:42 <hololeap> sorry, i mistyped that: `data Iterator a = Iterator {iterItem :: a, nextLevel :: Iterator a}`
18:48:12 <geekosaur> and even wth the constructor, you must use either the positional or the record syntax, you can't switch in the middle
18:48:22 <hololeap> hmm, ok
18:48:54 <geekosaur> although you can do something like data Foo a = Foo1 a | Foo2 {aa :: a; ab :: Int}
18:49:16 <geekosaur> (but don't do that, partial record destructors will throw exceptions if used against the wrong constructor)
18:49:39 <izacht13> Hi, can someone point me in the right direction. I'm looking for a monad lesson that goes over the concept, not the syntax. I'm trying to learn Ur/Web, which also has monads.
18:49:49 <geekosaur> tht is, if you apply aa or ab to a Foo1 then it will throw
18:50:05 <geekosaur> @go you could have invented monads
18:50:06 <lambdabot> Maybe you meant: google googleit do
18:50:10 <geekosaur> @google you could have invented monads
18:50:12 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
18:50:12 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Al...
18:50:18 <ertes> izacht13: if there is no ur/web-related version, you will most likely see haskell syntax anyway
18:50:32 <izacht13> Mhm, well thanks.
18:50:36 <izacht13> Ill take a look at it.
18:50:41 <geekosaur> it'll still have syntax, but it's mostly bout the concept
18:50:48 <ertes> or at least the haskell-based ones are probably the most trustworthy
18:51:00 <geekosaur> several examples of evolving the monad "pattern" from various use cases
18:51:57 <leshow> man lambdabot is pretty sweet, i had no idea you could search google with it
19:02:46 <ertes> lambdabot has far more impressive feats than that
19:03:51 <ertes> @djinn ((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r
19:03:52 <lambdabot> f a b c = a (\ d -> b d c)
19:06:46 <faberbrain> can anyone give me some ideas about how to accomplish something along these lines: http://lpaste.net/5129458430632787968
19:07:48 <faberbrain> specifically, for a given j, queueName should basically be a constant
19:08:19 <ertes> faberbrain: you need to mention 'j' in the type…  a common method is to use a proxy argument
19:08:28 <ertes> queueName :: proxy j -> ByteString
19:08:33 <faberbrain> ok yea, i started going down that path
19:08:45 <faberbrain> but wasn't sure if there was some simpler kind of way to do that
19:08:54 <pikajude> not much simpler than that
19:09:27 <ertes> faberbrain: import Data.Proxy, queueName (Proxy :: Proxy MyJobType)
19:10:00 <faberbrain> guess that is pretty simple
19:10:11 <ertes> faberbrain: also take a look at the aeson library, which already covers the first two functions
19:10:40 <ertes> class (FromJSON j, ToJSON j) => Resque j where queueName :: proxy j -> ByteString
19:10:43 <faberbrain> yea, i'm using aeson and may just add a FromJSON/ToJSON constraint
19:11:09 <faberbrain> but the particular JSON required by Resque (the ruby queueing library) is so weird that i may want it to e an alternative json represnetation
19:11:38 <ertes> faberbrain: you can make the JSON look like anything you want
19:12:34 <faberbrain> yea, i was more thinking along the lines of what if i don't want the Resque-json to be _the_ json representation for the data type.. but thinking on it more thats kinda dumb maybe
19:12:40 <faberbrain> since thats the only point of that data tyep in the first place
19:13:11 <ertes> faberbrain: same kind of question: is Integer the (+) or the (*) monoid?  answer: use a newtype wrapper to select different semantics
19:13:27 <ertes> > Sum 5 <> Sum 7
19:13:33 <lambdabot>  Sum {getSum = 12}
19:13:35 <ertes> > Product 5 <> Product 7
19:13:38 <lambdabot>  Product {getProduct = 35}
19:13:56 <faberbrain> ok yea, makes sense
19:14:15 <pikajude> > mempty @(Product Int)
19:14:18 <lambdabot>  error:
19:14:19 <lambdabot>      Pattern syntax in expression context: mempty@(Product Int)
19:14:19 <lambdabot>      Did you mean to enable TypeApplications?
19:14:21 <pikajude> doh
19:14:21 <faberbrain> so its more conventional to newtype wrap something then come up w/ some arbitrary new alternative thing (like an alternative to/from json)
19:15:09 <ertes> faberbrain: yes, because you're not looking for a different abstraction, just different semantics with an existing abstraction
19:15:29 <ertes> (+) and (*) *are* both monoids
19:16:01 <ertes> so it would be crazy to make (+) the default and invent a new monoid class to handle (*)
19:16:22 <ertes> along with all the functions that abstract over Monoid, like foldMap
19:16:35 <faberbrain> yea, i see.. thats a good way to think about it
19:17:03 <faberbrain> (probably _the_ way to think about it, i just hadn't reached that myself yet!)
19:18:04 <faberbrain> thanks!
19:18:58 <ertes> faberbrain: of course nothing wrong with making a particular semantics the default and selecting different ones via newtype
19:19:31 <ertes> like: clean JSON as default, insane JSON via newtype
19:20:06 <faberbrain> yea and in this case there honestly is really only one meaning, there isn't ever a need for a clean JSON rep (yet i guess)
19:20:24 <faberbrain> so probably makes sense to do the insane json as the default, since its the common use case
19:21:07 <ertes> insane JSON is quite common…  perhaps aeson should provide a wrapper by default
19:21:16 <athan> is @ just... ::?
19:21:36 <athan> I don't really see how they differ semantically :s
19:21:45 <pikajude> kind of, not really
19:21:58 <pikajude> if you have foo :: a -> b -> c you can use @T to fill in the variables
19:22:09 <Koterpillar> :t fmap@Maybe
19:22:10 <pikajude> Proxy :: Proxy Int --> Proxy @Int
19:22:12 <lambdabot> error:
19:22:12 <lambdabot>     Pattern syntax in expression context: fmap@Maybe
19:22:12 <lambdabot>     Did you mean to enable TypeApplications?
19:22:12 <pikajude> bit shorter
19:22:18 <pikajude> lambdabot doesn't have them enabled
19:22:22 <ertes> athan: if you look at the fully quantified type signature @ will apply type variables as introduced by 'forall'
19:22:32 <ertes> id :: forall a. a -> a
19:22:34 <pikajude> it's helpful to turn on ExplicitForall in GHC btw
19:22:38 <pikajude> or rather GHCi
19:22:43 <ertes> (id @ Bool) :: Bool -> Bool
19:22:55 <pikajude> or wait, sorry, i'm completely wrong
19:22:58 <pikajude> it's -fprint-explicit-foralls
19:23:08 <ertes> athan: so @ is literally application and therefore not the same as "::", which is more like a judgement
19:24:03 <ertes> athan: think about it this way: if haskell were dependently typed, "@" would literally be function application
19:26:45 <AndChat61364> !/
19:34:08 <athan> ertes, pikajude: Ahh wow okay that makes sense, so @ treats `forall` as a proper lambda?
19:34:43 <athan> man that makes a lot of sense, thank you
19:35:03 <athan> :: as a judgement, and how Curry works, that would also make a lot of sense too (ziiiing)
19:45:47 <whatinthefoo> Hi, I'm reading the happy parser docs and I came across this code: http://lpaste.net/353374
19:46:11 <whatinthefoo> lexer is defined as accepting one argument... but the pattern matches 2 arguments ??
19:46:48 <whatinthefoo> When I try similar code in haskell locally I get an error... is this an issue with the happy docs or am I missing something?
19:47:29 <Koterpillar> whatinthefoo: what's P?
19:47:55 <whatinthefoo> Koterpillar: P is 'type P a = String -> ParseResult a'
19:48:16 <geekosaur> that's your answer
19:48:22 <geekosaur> P a represents a function
19:48:22 <whatinthefoo> huh?
19:48:29 <whatinthefoo> okay
19:48:41 <whatinthefoo> I know that part
19:48:57 <geekosaur> so cont is a function that produces a function
19:49:03 <geekosaur> the "result type" P a is also a function
19:49:13 <whatinthefoo> 'lexer :: (Token -> P a) -> P a; lexer cont s = '
19:49:19 <geekosaur> so you can apply it, and the "s" parameter is applied to it
19:49:25 <whatinthefoo> how can you do 'lexer cont s =' though?
19:49:43 <geekosaur> let's try this: expand the P a in the type of lexer
19:49:53 <geekosaur> then remember that you can remove parens grouping rightward
19:50:15 <geekosaur> (Token -> P a) -> (String -> ParseResult a)
19:50:22 <geekosaur> we can remove the last parentheses
19:50:37 <geekosaur> (Token -> P a) -> String -> ParseResult a
19:50:44 <geekosaur> there's your cont and your s
19:51:03 <whatinthefoo> ohhh
19:51:20 <geekosaur> it's one of the trickier things to get used to in Haskell
19:51:50 <whatinthefoo> wow
19:52:27 <whatinthefoo> that makes sense
19:52:46 <whatinthefoo> i kept thinking that the P a in (Token -> P a) was being pattern matched somehow
19:54:29 <geekosaur> :t map
19:54:31 <lambdabot> (a -> b) -> [a] -> [b]
19:54:40 <geekosaur> we do the same thing in reverse here, fairly often
19:54:49 <geekosaur> (a -> b) -> ([a] -> [b])
19:55:05 <geekosaur> turning a function on a into a function on lists of a
19:55:58 <xmonader> is there a special meaning to colon in the beginning of line comments in haskell "--:" ?
19:56:17 <whatinthefoo> thanks geekosaur 
19:56:35 <xmonader> because i get "parse error on input ‘--:’"
19:56:39 <geekosaur> xmonader, it's not a comment
19:56:47 <geekosaur> --: is a valid operator name
19:57:06 <geekosaur> -- is only a comment leader when followed by something that is not a symbol character
19:57:25 <geekosaur> so --<space> or --a would be a comment but --: is an operator
19:58:12 <xmonader> uha I see. Thanks a lot geekosaur 
19:58:13 <geekosaur> likewise you'll see --> as an operator in some libraries
19:59:45 <cc> may i get a haskell cloak ?
20:09:38 <suica> anyone have a nice way of doing something like, given a string like `"(()())()"`, breaking it into `["(()())", "()"]` by counting matching parens (or any similar operation where you unfold into a list by keeping a running count and breaking off a piece right after the count reaches zero)?
20:10:06 <suica> could do it with zip, map, fst, snd, etc. but was wondering if anyone had a more concise way
20:18:04 <ludat> suica, what should happen with corner cases not matching parens?
20:21:27 <suica> i was going to ignore them
20:22:56 <suica> i just had a feeling there are some combinators or something I could use instead of doing a bunch of stuff like  `break (f . snd) (zip (map nestLevels xs) xs)`
20:23:24 <suica> i'll try lambdabot
20:28:05 <lyxia> > let s = "(()())()" in (fmap . fmap) snd $ groupBy (const ((/= 0) . fst)) $ zip (scanl (+) 0 (f s)) s
20:28:08 <lambdabot>  error:
20:28:08 <lambdabot>      • Ambiguous type variable ‘a0’ arising from an operator section
20:28:08 <lambdabot>        prevents the constraint ‘(Eq a0)’ from being solved.
20:28:25 <lyxia> come on
20:29:11 <lyxia> Oh I forgot to paste in f.
20:30:24 <lyxia> > let s = "(()())()" in (fmap . fmap) snd $ groupBy (const ((/= (0 :: Int)) . fst)) $ zip (scanl (+) (0 :: Int) (fmap (\x -> case x of '(' -> 1 ; _ -> -1) s)) s
20:30:27 <lambdabot>  ["(()())","()"]
20:30:52 <lyxia> that's not simpler than just recursing
20:31:15 <suica> yeah, fair enough
20:32:45 <suica> i've just been reading a lot of the "recursion is the goto of functional programming" stuff recently and wanted to try out some fancy things
21:12:20 <skeuomorf> Is the overloadedstrings language pragma documented anywhere?
21:14:42 <jle`> skeuomorf: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overloaded-string-literals
21:14:45 <jle`> in the ghc manual
21:14:53 <markasoftware> skeuomorf: there's some stuff about it in the introduction chapter of the yesod book
21:14:58 <markasoftware> which was enough for me to (mostly) understand it
21:15:45 <skeuomorf> jle`: Thanks
21:22:52 <lolisa> Hi, I am having some problem with my haskell code, I suspect it might be a bug: is it possible that splitting a file in two cause a term to inference different typeclass constraint?
21:23:53 <ertes> lolisa: one way this can happen is if you forget to turn on the same extensions in both files
21:24:15 <ertes> another way: different imports, different things in scope
21:24:51 <ertes> for example, if you import Control.Monad.Trans.State in one and Control.Monad.State in the other
21:26:43 <lolisa> Hmm, I indeed have different lang extension.
21:27:38 <lolisa> OMG now it work
21:28:10 <lolisa> ertes, Thx, bugging me for three hour... Where can I read more on such stuff?
21:28:27 <ertes> lolisa: the GHC manual explains what each extension does
21:28:44 <ertes> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/index.html
21:29:19 <ertes> they are a bit scattered around, so ctrl+f is your friend
21:29:32 <ertes> (or / or C-s or …)
21:30:00 <lolisa> :) happy!
21:32:11 <Suren> Hello
21:32:28 <lolisa> hello
21:33:06 <Suren> What's up lolisa, are you a Haskell developer just having a chat or are you new to the language?
21:37:33 <lolisa> Suren, I dont know, but shouldnt we like, talk more about haskell stuff instead of individual?
21:38:32 <peddie> lolisa: there is also a guide to some common GHC extensions at https://ocharles.org.uk/blog/pages/2014-12-01-24-days-of-ghc-extensions.html
21:40:50 <KiChjang> Suren, i happen to be new at the language
21:40:54 <KiChjang> i know zilch
21:41:09 <Suren> I was just asking you that question to see if you are the right person to ask my real question to, which is; as a web developer why would I choose haskell for a project over let's say C# .NET MVC 
21:41:23 <KiChjang> Suren, i think the answer here is you would not
21:41:25 <Suren> @lolisa
21:41:26 <lambdabot> Unknown command, try @list
21:41:43 <KiChjang> haskell isn't the right tool for that job i believe
21:41:53 <Suren> Why do you say that?
21:42:08 <lolisa> I'm here. Dont know about web, sorry.
21:42:20 <KiChjang> if you're using C# .NET MVC, then you're most likely making a web application
21:42:26 <Suren> yep
21:42:27 <Suren> lol
21:42:34 <Koterpillar> My .Net knowledge is rusty, but I would choose Haskell anyway
21:42:52 <Suren> What applications is haskell good for?
21:42:55 <KiChjang> literally "rusty" or "rust-y"?
21:42:55 <Suren> if not web
21:42:58 <ertes> hackage has more web frameworks than TYPO3 has global variables
21:42:58 <Koterpillar> because why would I give away referential transparency?
21:43:04 <ertes> so it's a weird thing to say
21:43:13 <KiChjang> Suren, i would consider it more of an academic language
21:43:14 <Koterpillar> Suren: applications where you want correctness
21:43:26 <pacak> Suren: parsing, ast manipulation
21:43:40 <KiChjang> there was a blog post before that talks extensively about how a company used haskell in production
21:43:42 <pacak> We are using it for automated trading.
21:43:48 <KiChjang> lemme try and fish that up
21:45:15 <Suren> Pacak: Automated trading has always interested me, how did you get into the field? What was your background before that job?
21:45:51 <pacak> Suren: Submitted my application. Had relatively basic haskell experience, no finance background.
21:46:55 <Suren> Pacak: How many years into your software engineering career were you? Did you have a CS or Stem degree? Was it from a top university?
21:47:21 <KiChjang> Suren, btw, this happened a while ago in #haskell but may also be relevant https://gist.github.com/quchen/5280339
21:47:33 <Suren> KiChjang: thanks
21:47:45 <KiChjang> (probably not but eh, good for laughs)
21:48:15 <pacak> Suren: I've been developing various stuff for quite a while back then. No CS, no fancy university either.
21:50:05 <Suren> Pacak: Nice man, really glad to hear! I'm a self-taught developer without a degree, about a year into my career now. I always hoped for a career in finance software engineering but didn't think it was possible without a CS degree. 
21:53:04 <buttons840> I am seeing "Type as Type" in an error -- what exention is this?
21:53:18 <buttons840> extension*
21:53:24 <jle`> can you give the context?
21:53:34 <jle`> is Type as Type the error message?
21:54:26 <buttons840> "Couldn't match expected type Text with actual type HVec as Text" -- something like this
21:55:26 <jle`> i think 'as' is a type variable there
21:55:58 <jle`> you are giving a value of type 'HVec bs Text', but the function expects a Text
21:56:02 <buttons840> jle`: you are right, it's actually "as0"
21:57:03 <buttons840> so, in spocks renderRoute (https://hackage.haskell.org/package/Spock-0.12.0.0/docs/Web-Spock.html#v:renderRoute) the "as" is a type variable?
21:57:21 <jle`> yup
21:57:37 <buttons840> it's not colored like a type variable, guess it's just a css issue?
21:57:59 <jle`> it's colored as a type variable on my browser
21:58:29 <jle`> it's just plain black text
21:58:55 <jle`> looking at the HTML, type variables don't have any specific styles
21:59:50 <buttons840> ah, your right, it's rendered the same as all other type varibles -- i guess it's just that it was sitting between two links that threw me off
22:17:13 <lolisa> Hi, so I do cabal install hscolour, but I still cant run the command (or use it from cabal). I am using windows, what should I do?
22:17:45 <Axman6> you probably need to add the install location to your path, but I have no idea how to do that on windows
22:19:42 <Axman6> lolisa: this looks like it nas what you need: http://stackoverflow.com/questions/15461085/how-to-configure-cabal-in-windows-7
22:29:57 <lolisa> Axman6, thx
22:36:27 <halogenandtoast> If I'm considering making a static website is Hakyll a good way to go?
22:36:52 <Axman6> it's not a bad way to go, I use it for my website
22:37:40 <halogenandtoast> https://axman6.com/blog/ ?
22:37:46 <Axman6> that's the one
22:37:53 <halogenandtoast> That page isn't selling me :p
22:37:55 <Axman6> uh, actually without /blog IIRC
22:38:09 <halogenandtoast> Ah much better
22:38:15 <Axman6> not even sure how that page is being served...
22:38:20 <Axman6> it shouldn't even be there :|
22:38:23 <halogenandtoast> Your github links there
22:38:32 <halogenandtoast> Which is why I ended up there
22:38:43 <Axman6> I'll fix that
22:39:51 <Axman6> all done
22:40:10 <halogenandtoast> Ha nice, are there any particular tools you suggest?
22:40:25 <Axman6> for what?
22:40:39 <Axman6> btw I believe that the code for my site is also on github
22:40:51 <Axman6> https://github.com/axman6/axman6.com
22:41:00 <halogenandtoast> Ah sorry I meant things you found useful to use with Hakyll
22:41:09 <Axman6> the important bits are in site.hs
22:41:29 <halogenandtoast> Cool thanks, I'll check it out.
22:41:55 <pikajude> blog posts need a bit more contrast
22:41:59 <pikajude> i can barely read it
22:42:11 <Axman6> submit a PR =)
22:42:34 <lolisa> Hi... the problem is still there, so basically if you move Poly into DBI, it will compile, but right now it wont. Can anyone look at it? I am working on a minimal example.
22:42:37 <lolisa> https://github.com/ThoughtWorksInc/DeepDarkFantasy/tree/master/src
22:43:50 <pikajude> oh, no, i don't want to contribute to your blog
22:43:54 <pikajude> this is just my opinion as a reader
22:44:34 <halogenandtoast> pikajude: My life rule has always been to never complain about something I won't try to fix myself :p
22:44:40 <halogenandtoast> Not judging you, just saying
22:44:52 <pikajude> my life rule has been not to try to interfere with other people's possessions
22:45:48 <halogenandtoast> Must make it hard to get a house or car loan.
22:46:06 <pikajude> i have neither
22:46:14 <halogenandtoast> Story checks out.
23:00:33 <lolisa> I got the minimal example out. So as you can see, https://github.com/ThoughtWorksInc/DeepDarkFantasy/blob/master/src/PolyT.hs contain a definition that is included in https://github.com/ThoughtWorksInc/DeepDarkFantasy/blob/master/src/DBIT.hs (but under different name), but wont type check
23:01:09 <lolisa> No library is used, and they have same language extension
23:08:25 <qmm> 12:30 < c_wraith> Experiments with per-process GC for GHC have shown it to not be especially compatible with laziness.
23:09:04 <qmm> c_wraith: do you have links, paper titles, email subjects, or any keywords to share whatsoever about this? 
23:09:27 <qmm> i am still interested in this subject
23:09:32 <c_wraith> there was a paper by at least one of the simons about adding per-HEC heaps
23:09:38 <c_wraith> I don't recall the name of it
23:14:55 <qmm> c_wraith: ah okay. i'm aware
23:15:35 <qmm> it added something like 15% performance increase and according to #ghc it wasn't easy to implement so it was never merged
23:16:06 <qmm> i read per-HEC has per core heaps
23:16:11 <qmm> what is HEC? :)
23:16:32 <qmm> haskell execution context, i see
23:17:07 <qmm> s/has/as
23:17:33 <qmm> c_wraith: thank you
23:17:37 <c_wraith> oh hey.  the paper was by both simons. :)
23:18:22 <qmm> :)
23:18:22 <qmm> http://community.haskell.org/~simonmar/local-gc.pdf
23:19:11 <qmm> haskell doesn't sound like it's desirable for distributed programming type projects
23:19:31 <qmm> <-- noob in distributed computing
23:23:13 <c_wraith> I don't think it's inherently unsuitable, just that there's a lot of engineering work that hasn't been done
23:24:19 <qmm> the lightweight scheduler work would be a nice first step
23:26:38 <Rotaerk> isn't that what cloud haskell is for?
23:27:34 <qmm> cloud haskell mimics erlang's style concurrency without changing the haskell runtime
23:27:49 <qmm> erlang style concurrency
23:28:08 <qmm> it's a library, in other words
23:29:57 <ongy> Axman6: I've read your blog article about linear typing, do you know how much that would change if ghc got some support for it?
23:31:26 <qmm> ongy: thanks for mentioning that Axman6 has a blog (and a post about linear types!)
