00:35:03 <spatial> http://pastebin.com/LxzCpQgE Thought a global array in a State Monad is like this. Seems to be wrong.
00:35:50 <spatial> Some type problems
00:45:23 <mniip> spatial, you can't have global variables without unsafe hacks
00:45:55 <mniip> and State is something else,
00:46:00 <mniip> it's for having variables without IO
00:47:35 <spatial> The same patter works for fun :: Map.Map String Int fun = Map.empty
00:47:51 <begriffs> Is there a Haskell library to read audio data from the microphone input of the soundcard?
01:10:49 <Squarism> begriffs, https://wiki.haskell.org/Applications_and_libraries/Music_and_sound
01:14:50 <begriffs> Squarism: hm, none of those seems right.
01:15:06 <begriffs> So far this looks closest https://hackage.haskell.org/package/conduit-audio
01:15:28 <begriffs> But not sure how you connect it to the soundcard
01:16:08 <Squarism> http://hackage.haskell.org/packages/#cat:Sound
01:17:17 <Squarism> Not an expert on this, but doesnt the OS have a notion of "default line in/microphone in"
01:18:24 <Rembane> You can set it with ALSA
01:20:42 <begriffs> I'll look into that, thanks.
01:39:01 <halogenandtoast> If I have a haskell program I've written, but it's dependent on some OS specific binary, is there any way to "bundle" them together?
01:39:46 <halogenandtoast> I do have the source code to the other binary, so I supposed I could convert it into Haskell, but I don't really want to
01:44:49 <zomg> halogenandtoast: at least with libraries you can link them statically
01:45:08 <zomg> but not sure if that'll make it work on OS's the library wasn't designed to work on, same issue most likely with any binaries
01:56:33 <bollu> is there a way to "get" a value inside a state monad lensily?I was to "get" SomeField out of ComplexObject. (^. SomeField) <$> get seems too verbose
02:46:16 <halogenandtoast> zomg: sorry I had disconnected.
02:46:41 <halogenandtoast> Maybe I can make it a library somehow, it's just an Objective-C program
02:47:04 <halogenandtoast> I don't care if it app works on different OSs
03:21:08 <ph88> hi all
03:24:17 <Squarism> i have an MVar where i store : Map String (TChan SomeType) - i feel i got a need to change its type to myMVar :: (SomeClass a) => Map String (TChan a) ... but i cannot se how i could store differnt instances of SomeClass on it?
03:24:24 <Squarism> Or could that be possible?
03:27:01 <Squarism> gah, im in desperate need of some typeclass expert. Cause im clearly out on deep water here
03:33:02 <ph88> helps already when you show some code that works and changes you want to make to it that dont work .. like a small test case
03:34:13 <Squarism> ph88, i guess. Its just that im hesitant of spending lots of time on an idea that doesnt fly
03:37:09 <Squarism> i think my only question is - how can i store values of different type in the same MVar wo using Union types. I would need a down/up cast mechanism for that and i understand there is no such thing in haskell
03:40:36 <ph88> Squarism, well i'm too nooby to know what you're talking about, so i guess sit around till someone else understands it
03:43:24 <ph88> ocharles, are you around ?
03:47:45 <hexagoxel> Squarism: Dynamic/existential type/unsafeCoerce are your options
03:49:34 <Squarism> hexagoxel, Ok thank you. Im not sure if you describe 1/2/4 concepts?
03:49:59 <hexagoxel> Squarism: Dynamic/(existential type)/unsafeCoerce
03:50:22 <hexagoxel> what is SomeClass?
03:50:40 <hexagoxel> if the existential makes sense depends on that.
03:51:22 <hexagoxel> (you'd have data SomeInstance = forall a . SomeClass a => SomeInstance a   and TChan SomeInstance)
03:54:27 <Squarism> hexagoxel, SomeClass would be just be a collection of "traits" for a certain type of message
03:55:21 <Squarism> Really it should be a type parameter
03:55:41 <Squarism> (rambling)
03:56:28 <Squarism> Really it should be a Java style type parameter. But i dont know how to express such
03:57:02 <hexagoxel> i am not convinced that what you have in mind would not be a (inefficient/bad) emulation of a union type.
03:58:52 <hexagoxel> i think example code would help.
04:03:47 <Squarism> hexagoxel, http://lpaste.net/353204
04:03:55 <Squarism> thats my sketch so far. 
04:05:08 <Squarism> its basicall about launching games (that have their own messageing model) depending on a "GameType" parameter found in the database - for a gameid parameter given by a connecting client. I have htis all working for one game. 
04:05:33 <Squarism> but i want to make it generic so i can have the same gameloop/messaging code for all games
04:07:07 <Squarism> launch game would creat a gameAdapter and just invoke gameLoop. The hard part constructing these typed channels and storing them in one MVar
04:14:10 <hexagoxel> Squarism: i think you can use an existential without any constraint/any additional type class. Something in the direction of GameServerInstance = forall m1 m2 . GameServerInstance (GameAdapter m1 m2) (TChan m1) (TChan m2)
04:15:06 <hexagoxel> that way you can have a monomorphic list of instances, yet when matching on a specific, you know that the types match up.
04:18:10 <Squarism> hexagoxel, so you mean my MVar should be typed with GameServerInstance?
04:20:00 <Squarism> (ive never used existential types in haskell) 
04:22:01 <hexagoxel> Squarism: yes, probably. the code does not show yet how you use the MVar.
04:22:27 <hexagoxel> Squarism: maybe consider the two examples at 3.2 on https://wiki.haskell.org/Existential_type
04:22:59 <hexagoxel> (hmm are there no better explained examples of existential without constraints around?)
04:23:49 <Squarism> ill take a deep look into the hint you've given me
04:24:16 <Squarism> hexagoxel, thanks alot
04:25:07 <Squarism> ...ill prolly need to read up on how they are used to persue this
04:32:30 <Mortenl> Is there any work going on to bring scoped threads back into the standard library? They're pretty nice
04:33:12 <nmattia> hi guys, I'm looking for some advice. I have a cabal project that builds an executable. the test-suite contains integrations tests that use the produced executable. with stack everything is fine, since it'll build the executable first and then put it on the path. however I'm struggling with nix, because I can't really pass the result of the derivat
04:33:12 <nmattia> ion as a build input to the derivation itself
04:34:09 <nmattia> one solution would be to skip the checkPhase, though it's a bit hacky
04:35:41 <hexagoxel> Squarism: https://hackage.haskell.org/package/foldl-1.2.3/docs/Control-Foldl.html#t:Fold seems like a nice real-life example of a non-typeclass existential.
04:36:00 <hexagoxel> note that there is an implicit "forall x ."
04:36:48 <hexagoxel> and with some creative imagination, a game is just a Fold over some game state :)
04:49:11 <Michael-jx> Hello , this is your videogame for pc windows  ? https://sourceforge.net/projects/black-fps/?source=directory
05:48:52 <ph88> anyone here familiar with GHC.Generics? it seems to me that product (fields) are encoded like this  data (:*:) a b p = a p :*: b p  and sum (data constructors) are encoded like this  data (:+:) a b p = L1 (a p) | R1 (b p)  Is there any other way to do deal with the data constructors ?
05:50:35 <ph88> if i have a type like  data Foo = Foo1 | Bar | Foo2  and i want to find the last data constructor that starts with "Foo"  i can't really do it right now, because i need lookahead. With product it's not a problem
05:55:24 <ph88> if it was encoded as a list consisting out of tuples of 2 elements like  (elem1, (elem2, () )) then i could pattern match to get the head and the tail like (head, tail) where tail would be (elem2, ()) .. but since the head is L1 and tail is L2 i can not inspect both at the same time ..
06:00:18 <jchia_> I'm trying to use Data.Vector.Sized with MonoTraversable, using "instance MonoFoldable (VS.Vector n a)" and thus getting a warning about orphan instances. If I use a newtype to wrap the VS.Vector, I can't easily use the functions that take a VS.Vector. Is there a better way to avoid the orphaned instance?
06:04:00 <lyxia> ph88: use overlapping instances.
06:04:41 <ph88> lyxia, what does that give me ?
06:05:55 <lyxia> ph88: actually, what exactly are you trying to do?
06:06:26 <ph88> i'm trying to traverse the structure and find the last occurance of a type
06:06:56 <ph88> structure like  Foo (Wrap T) (Bar (Wrap T)) (Wrap (Qux T))   find the last T
06:07:07 <ph88> but actually looking at this .. i only have 1 data constructor ..
06:07:25 <ph88> so looks like i'm trying to solve a problem that i don't have o_O
06:07:32 <lyxia> By overlapping instances I mean that   instance C (a :+: (b :+: c))   would be the instance for the non-last part of sum, and   instance C (a :+: b)   can then assume that b is not a sum, and thus is the last constructor.
06:07:53 <lyxia> you can actually avoid overlapping instances there because you know that b is actually a C1.
06:08:15 <ph88> aah very smart !
06:08:43 <lyxia> now you know!
06:08:48 <ph88> so instead of b i put  C1 ?
06:10:24 <ph88> lyxia, actually i think i will use those overlapping instances to throw an error if my type contains multiple data constructors .. then you are not suppose to call that function on it .. do you think that is a good idea ?
06:10:27 <Athas> What is the meaning of semicolons at the top-level in Happy?
06:11:35 <lyxia> ph88: sure
06:16:20 <ph88> lyxia, eh actually that last thing i said is not even true .. what i need to do is inspect the value to see which data constructor was chosen i guess ..  i mean ultimately i am trying to change a value to i don't need to do anything on data constructors which were not chosen. Do you know how i can find out which data constructor the value has?
06:22:06 <ph88> i think it will do that automatically, no? because when you convert a value to a generic representation then the data constructors which are not in the value will not be in the representation, or am i wrong ?
06:22:15 <lyxia> it's in the parameter of C1:   C1 ('MetaCons something something)
06:22:47 <ph88> the name ?
06:22:49 <lyxia> Uh, I didn't understand your last question
06:23:01 <lyxia> yeah what I wrote is how you find the name of the constructor.
06:24:26 <ph88> i mean when i have a structure like  data Foo = Foo1 | Bar | Foo2  but a value like  value = Foo2  and i write a generics function for it, do i need to worry about covering other non-chosen data constructors? I think the others (Foo1, Bar) are not even in the representation ?
06:25:01 <ph88> in my case i don't even think that i need the name of the constructor since the operation will be the same on all the constructors ^^
06:25:53 <ph88> if i have like   data = Foo1 (Wrap T) (Bar (Wrap T)) (Wrap (Qux T)) | Foo2 (Wrap T) (Bar (Wrap T))   no matter if it's Foo1 or Foo2 i need to change the value of the last T  (they both have a last T)
06:29:24 <lyxia> you don't write a generic function for a particular value
06:30:21 <lyxia> The generic representation of Foo, Rep Foo is a sum
06:30:42 <lyxia> and from value will just map your constructor to one of the variants in that sum
06:31:22 <lyxia> but if you're writing a generic function   Rep a -> X, it will need to handle all variants in one way or another
06:33:40 <ph88> how does that work "from value will just map your constructor to one of the variants in that sum"  ?? this automatic mapping
06:35:59 <lyxia> from Foo1 = M1 (L1 (L1 (M1 U1))) :: (D1 _ (((C1 _ U1) :+: _) :+: _)) p
06:36:18 <lyxia> something like that is generated by GHC when you derive Generic.
06:36:29 <lyxia> (from has two other cases for Bar and Foo2 of course)
06:37:15 <lyxia> ph88: from is basically one direction of the isomorphism between Foo and (Either (Either () ()) ())
06:38:35 <ph88> aah i see .. so it only takes a part of the full representation (the other caes) ?
06:38:59 <lyxia> what part
06:41:05 <lyxia> Do you mean that Foo1 is mapped to the "branch" A in (A :+: B :+: C) and doesn't really care what's in the other two B and C? That sounds about right.
06:44:07 <ph88> ya
06:50:12 <vctrh> hey
06:55:21 <martinga> I've written a library for accessing patent data from the EPO, and a client using it to download PDFs.  I think it is worth putting out there on Hackage for others, but it is my first significant bit of code.  What's the best way to ask the community for a quick review / sanity check?  Library is at https://github.com/fros1y/patent-api and the tool is at https://github.com/fros1y/epo-download
06:57:06 <lyxia> You could try the Haskell-café ML, or reddit.
06:58:46 <hpc> ML? in #haskell?
07:00:12 <hodapp> it's a big conspiracy, don't worry about it
07:00:58 <lyxia> Machine Learning is the future.
07:01:23 <martinga> It's Sneaky ML.  You know, SML.
07:06:41 <vctrh> there are a few of us are doing machine learning in haskell
07:13:05 <hodapp> there's DataHaskell on Gitter
07:13:17 <hodapp> ML libraries in Haskell seem to be rough though
07:13:54 <hodapp> I haven't attempted to use HLearn yet but looked through some examples, and there are a couple convnet things too that I'd like to look at
07:14:52 <hodapp> but every time I use R, I think about how this could be made SO MUCH CLEANER by using actual types instead of a lot of monkey-patching and duct-tape
07:15:41 <hodapp> I suppose HaskellR is still a thing.
07:17:39 <vctrh> hodapp yeah it could be so much better than R
07:17:57 <vctrh> hlearn is not very active
07:18:17 <hodapp> it just seems to be the most active :|
07:18:43 <vctrh> https://github.com/mikeizbicki/HLearn/graphs/contributors
07:18:49 <vctrh> kind of stalled for the last year+
07:19:13 <vctrh> i think datahaskell kind of has to build things up anew
07:19:31 <hodapp> yeah. I'd like to help with some of that but just haven't had time as of late
07:19:47 <hodapp> someone had a dataframe-like API (not Frames) that looked promising
07:19:54 <vctrh> as a lot of the one-man attempts at this stuff have mostly fizzled
07:20:22 <vctrh> was this from the other day? i haven't seen anything too promising in that arena yet
07:20:34 <hodapp> it was from some months ago
07:20:40 <hodapp> http://hackage.haskell.org/package/analyze
07:21:15 <hodapp> if we had something that could handle most of the data-juggling stuff from the Hadleyverse that would go amazingly far
07:21:25 <hodapp> e.g. reshape2, dplyr and friends
07:21:36 <vctrh> trying to find a tutorial or example of this...
07:21:57 <vctrh> actually i had an idea in the dataframe space i'm experimenting with
07:22:16 <hodapp> yeah?
07:22:23 <vctrh> may share soon but have to convince myself its not a dead end first
07:23:52 <hodapp> are you in the dataHaskell gitter? may get the most interest there
07:24:02 <hodapp> dataframes are a thing I'd have a hard time living without in some fashion
07:24:08 <vctrh> yeah i'm over there 
07:24:23 <vctrh> well even though i'm working on this data frame experiment
07:24:31 <vctrh> i'm not convinced it's the way to go
07:24:37 <jchia_> jophish: I'm trying to increment an element in a Data.Vector.Sized.Vector 20 Int. What's the simplest way to do it? With regular vector, I just use Data.Vector.modify with Data.Vector.Mutable.modify. The context is I'm using Data.Vector.Size.Vector as a histogram and I need to increment a bucket for each sample I encounter.
07:24:39 <vctrh> maybe haskell needs its own abstraction
07:25:09 <hodapp> it's not a rigidly-defined abstraction either. R does it one way, Python another with Pandas, and Scala another still in Spark
07:25:10 <vctrh> rather than transplanting R/Pandas verbatim. i keep thinking there's maybe a lens-y substitute for dataframe
07:25:28 <hodapp> doesn't Frames do something along these lines?
07:25:32 <vctrh> i'm not sure what that would look like but maybe someone does
07:25:52 <vctrh> I don't think Frames is it :/
07:26:02 <vctrh> it was a good try but the ergonomics of working with it are too problematic
07:26:11 <hodapp> I haven't worked much with it yet
07:26:23 <vctrh> doesn't scale to unwieldy CSVs (which are eveyrwhere in data science)
07:26:44 <vctrh> or rather, doesn't handle unwieldy data gracefully
07:27:10 <hodapp> but whatever it is, I'd love if certain things that are sort of a royal pain in R - like doing transformations that turn a row into multiple rows but maybe variable numbers of them - were much more direct
07:27:13 <vctrh> for example if you have a few hundred columns or more, compile times get not so good
07:27:23 <hodapp> hmmm
07:27:31 <vctrh> also try loading in 2 or 3 CSVs and you'll inevitably have a namespace clash
07:27:38 <vctrh> with the accessors being derived by column names
07:28:07 <vctrh> it was a good try, but i think the template haskell route is *too* static an approach
07:28:30 <Rembane> What about going the Data.Map approach? It's not as Haskelly, but it could work.
07:28:46 <Rembane> You might need some prefixes for the keys though.
07:28:48 <vctrh> Rembane it kind of works. I've rolled my own data analyses around map and vector
07:29:05 <vctrh> the problem is you can write your own joins and stuff
07:29:10 <vctrh> but it gets to be slow
07:29:15 <hodapp> whatever it was, if it's going to be usable the way dataframes are in many languages, would have to be something where it's trivial to add new columns based on existing columns to do quick computations and such
07:29:31 <hodapp> and where things like melt/cast aren't monstrosities
07:29:36 <Rembane> vctrh: It is indeed. Hm...
07:29:37 <vctrh> medium size-ish data sets that you'd left_join and filter like nothing in R
07:29:56 <vctrh> start to become substantial obstacles with Map representations
07:32:00 <vctrh> Rembane i'm experimenting with a pretty different approach to the problem now
07:32:59 <Rembane> vctrh: What's your current approach?
07:33:05 <Rembane> vctrh: Or rather, the different approach?
07:34:30 <vctrh> well might be premature to say because it could also be a dead end ... but the experiment i'm trying is to wrap a dplyr-like DSL around an in-memory sqlite database
07:35:02 <bollu> I'm reading lens over tea, I don't understand this sentence: "Now let's consider 2 cases – the first is when we use it to turn s into a, the second is when we use the iso to turn b into t. The definition we already have works well enough for the former case, but in the latter case sdoesn't even exist" Link: https://artyom.me/lens-over-tea-4. Could someone please tell me what it is trying to say?
07:35:27 <vctrh> give relational operations to the relational gods. then couple that with some bridges to standard haskell data structures like Map and IO operations (like CSVs)
07:36:22 <vctrh> kind of flips the dplyr sql database backend model on its head
07:37:03 <Rembane> That does indeed sound interesting, I'm afraid I don't have any intuition on if it is a sound design. 
07:38:18 <bollu> OMG lens is ungoogleable
07:38:48 <vctrh> neither do i. i think a question is how cleanly one can write an interpreter to sqlite. i would've tried building it on opaleye but i'm not sure if it's actively maintained
07:39:07 <rdococ> asdf
07:39:17 <bollu> how do you keep a message for someone? I forgot
07:39:19 <bollu> using lambdabot
07:39:34 <vctrh> so i'm trying to do it from scratch. no obvious reason why it wouldn't work but it's still an experiment at this stage.
07:40:41 <vctrh> alternatively, one could always use the many sql DSLs but i think they tend to be just slightly too low level for data analysis/data munging stuff.
07:40:57 <bollu> @msg ekmett "thanks for 'use' :) how would I have discovered it if it wasn't for your help?"
07:40:58 <lambdabot> Not enough privileges
07:40:59 <bollu> hm
07:41:04 <Rembane> vctrh: You could build your EDSL on top of a SQL EDSL.
07:41:08 <bollu> I had the same problem sometime back
07:41:18 <bollu> @tell ekmett "thanks for 'use' :) how would I have discovered it if it wasn't for your help?"
07:41:18 <lambdabot> Consider it noted.
07:41:48 <vctrh> Rembane like i said I'd use opaleye if I was confident their sqlite dsl wasn't trending towards abandonment
07:41:55 <vctrh> for now i'm building it on sqlite-simple
07:41:58 <Rembane> vctrh: Ah, good point.
07:52:03 <bollu> I fail to understand how the Iso instance of lens is encoded using PRofunctots
07:52:06 <bollu> Profunctors
07:52:20 <bollu> I'm reading lens over tea, but I'm confused as to how the method makes sense
07:52:27 <bollu> could someone walk me through this?
07:52:56 <johnw> hi bollu
07:53:09 <johnw> consider this function: iso :: (s -> a) -> (b -> t) -> Iso s t a b
07:54:38 <bollu> johnw: yes
07:54:46 <bollu> johnw: what repr. of Iso are you using? :)
07:55:02 <johnw> type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)
07:55:46 <bollu> johnw: I want to know where that came from
07:55:51 <bollu> johnw: but do go on
07:55:52 <johnw> Control.Lens.Iso
07:56:00 <johnw> note that if we use (->) as our profunctor, it becomes the type of Lens
07:57:00 <bollu> johnw: yep
07:57:01 <johnw> by another choice, we get the type of Prism
07:57:21 <bollu> John[Lisbeth]: I meant, like, "how did we arrive at that representation, and how does it represent isomorphisms" ?
07:57:27 <bollu> johnw: what is the other choice?
07:57:29 <bollu> johnw: ^
07:57:40 <bollu> John[Lisbeth]: sorry for the ping!
07:58:04 <johnw> this: Iso s t a b ~ (s -> a, b -> t)
07:58:11 <johnw> as you saw in the over tea article
07:58:46 <bollu> johnw: yes, that's the part I'm iffy about. I don't understand the "enum "example
07:59:07 <bollu> johnw: I am able to create a function called "enum_rev" like so: https://github.com/neongreen/artyom.me/issues/18
07:59:15 <bollu> but according to the article, I should not be able to do so?
07:59:33 <bollu> johnw: https://artyom.me/lens-over-tea-4
07:59:56 <berkobra> hello everyone
07:59:59 <bollu> berkobra: hey
08:00:21 <berkobra> i am a newbie trying to tackle project euler problems
08:00:33 <berkobra> but I got a parse error in my code
08:00:35 <berkobra> http://lpaste.net/353208
08:00:40 <berkobra> can you have alook :)
08:01:00 <bollu> johnw: could you please take a look? :)
08:01:09 <johnw> bollu: actually, this article really lays it out quite well, so maybe #haskell-lens is a better place to ask for the deeper theory.  I don't know how they came up with the exact definition we have for Iso.
08:02:28 <bollu> johnw: did you read my issue? 
08:02:37 <bollu> johnw: it's like, I'm stuck on a par
08:02:46 <bollu> johnw: I did ask on #haskell-lens, but it seems dead :(
08:02:46 <johnw> I did, but I'm afraid I don't have the time to dig into this deeply right now
08:02:53 <bollu> johnw: I see. thanks anyway :)
08:03:00 <bollu> johnw: much appreciated
08:03:53 <johnw> in your enum_rev example, btw
08:04:06 <johnw> what happens if I .~ an integer that toEnum fails to convert?
08:04:29 <johnw> myEnum & id .~ 99999
08:05:14 <bollu> hm
08:05:18 <bollu> it errors out
08:05:22 <bollu> I think
08:05:31 <johnw> that's not a lawful lens, then
08:05:35 <johnw> it should at the very least be a prism
08:05:43 <lpaste_> bollu pasted “euler-#4-fixed-syntax” at http://lpaste.net/353209
08:05:56 <bollu> berkobra: that is the fixed syntax, but you still have _semantic_ type errors :)
08:06:08 <bollu> berkobra: particularly, what is the type of isPalindrome?
08:06:53 <bollu> I see
08:06:56 <bollu> hm
08:06:58 <bollu> johnw: thanks
08:11:40 <berkobra> oh, do I need explicit type declaration for problem_4 ?
08:17:49 <bollu> it will warn you about conflicting choices of "which number type"
08:19:33 <berkobra> bollu what do you mean by fixed syntax
08:20:51 <Squarism> im trying to compile this but get 2 compile errors http://lpaste.net/353212
08:21:05 <bollu> berkobra: you don't need the "-"
08:21:07 <Squarism> ...on line 96
08:21:08 <bollu> "="*
08:21:20 <bollu> berkobra: and you also need to push the "|" pattern guards a little ahead
08:21:45 <berkobra> do I have to double indent after 'where'?
08:21:49 <berkobra> or is it about the guards
08:22:17 <berkobra> I can't really wrap my head around the indentation rules of Haskell
08:22:43 <sbrg> berkobra: for the most part, things just need to be at the same indentation level to be a part of the same 'block'
08:23:13 <sbrg> I prefer to have 'where' on a line of its own, indented two spaces. definitions in the 'where' clause are indented 4 spaces
08:23:51 <berkobra> thanks sbrg
08:23:57 <berkobra> and bollu too
08:24:17 <berkobra> Now I can move on to the actual logic errors of the code :)
08:26:29 <bollu> every lens is Iso?
08:26:35 <bollu> sbrg: no worries :)
08:26:43 <bollu> johnw: every Lens is an Iso right?
08:26:56 <bollu> oh no
08:26:59 <bollu> every Iso is a Lens
08:27:00 <bollu> hmm
08:28:17 <Squarism> better paste with error : http://lpaste.net/353213
08:38:26 <lyxia> Squarism: createGameServerInstance must be polymorphic
08:38:43 <lyxia> but gameLauncher1 uses a monomorphic value
08:39:10 <lyxia> Squarism: did you mean to use an existential type?
08:39:24 <Squarism> lyxia, yep.. i want to use existential type
08:39:34 <Squarism> (never tried in haskell before)
08:40:08 <lyxia> Squarism: data GameLauncher = forall m1 m2 . GameLauncher { ... }
08:40:15 <Squarism> ah
08:40:45 <Squarism> that did the trick
08:40:49 <Squarism> thanks lyxia 
08:40:54 <lyxia> yw
08:41:02 <Nikola> ... so I want to write an application in haskell - the target platform is ghc on linux : After writing some data to disk, I would would sometimes like to call sync(2). How can I do that?
08:43:04 <cocreature> Nikola: it looks like the unix package provides fsync https://hackage.haskell.org/package/unix-2.7.2.1/docs/System-Posix-Unistd.html#v:fileSynchronise but not sync. so your only option is probably the C ffi
08:44:40 <tsahyt> what's the fastest pure haskell FFT implementation?
08:45:04 <tsahyt> probably equivalent to the fastest that does not bind to fftw
08:45:14 <Nikola> Aahhh ... thanks cocreature: How come a function like that is not in the standard library? Any OS would provide some way to synchronize buffers to disk, wouldn't if ?
08:45:45 <cocreature> Nikola: I think it’s just rarely used. personally I never needed that function
08:49:25 <Nikola> cocreature: So you always use a database or other service to store data ?
08:49:32 <cocreature> Nikola: I would suspect that a PR to the unix package adding this would be accepted
08:49:45 <cocreature> Nikola: no I just don’t care enough about when files are written to call "sync(2)"
08:50:30 <Nikola> cocreature: And how _do_ you store the data ? :-)
08:50:47 <cocreature> Nikola: I just write to a file and let the os decide when it syncs :)
08:56:14 <geekosaur> Nikola, I would question using sync(), it is a very blunt hammer that impacts the entire system
08:56:53 <geekosaur> unless the entire system is guaranteed to be dedicated to your application, rethink that
08:56:57 <oPn7> hello guys, where am i doing wrong here about indentations ? https://paste.kde.org/psn0eczll can anybody help ?
08:57:21 <geekosaur> because it WILL trash performance systemwide
08:57:49 <Nikola> Sure - fsync is fine - thanks - But I mean more high-level: "How do you store data" ... say you have a web application receiving lots of messages ... I am looking into append-only event store solutions, like e.g. "java-dirty" (dead-simple object serialization
08:58:41 <geekosaur> oPn7, first thing I see is "-h"::String is both redundant and illegal without ScopedTypeVariables
08:58:51 <geekosaur> (also, you should include full error messages with this kind of paste)
08:59:23 <monochrom> Yeah, I don't think I see indentation errors either.
08:59:58 <Nikola> but that in haskell ... and I guess I'd somehow like to make sure the store is consistent and persisted to disk at some point
08:59:59 <geekosaur> I think it also needs parentheses, and when they are missing could well confuse the parser in ways that makes it suggest bad indentation just as a "I have no clue, maybe this?"
08:59:59 <Nikola> https://github.com/mrwilson/java-dirty/blob/master/java-dirty/src/main/java/uk/co/probablyfine/dirty/Store.java
09:00:20 <oPn7> i added those String things because it shows that they are not String
09:00:23 <geekosaur> Nikola, that is what fsync is for
09:00:48 <geekosaur> you want to sync that store, not every single dirty buffer on the system
09:01:10 <Nikola> geekosaur: yep, but fsync is not in the standard library either (neither is sync())
09:01:16 <geekosaur> depending on other activity, your data may actually end up being delayed
09:01:20 <oPn7> geekosaur: excat error message is "parse error (possibly incorrect indentation or mismatched brackets)"
09:01:39 <geekosaur> cocreature pointed you to https://hackage.haskell.org/package/unix-2.7.2.1/docs/System-Posix-Unistd.html#v:fileSynchronise
09:01:40 <oPn7> line 11,9
09:01:41 <geekosaur> that is fsync
09:02:17 <monochrom> Oh interesting, there is a parse error.
09:02:21 <geekosaur> oPn7, yes, that's the "I'm completely lost" error
09:02:28 <oPn7> :D
09:02:40 <oPn7> what that means ?
09:02:53 <geekosaur> what I said and you apparently only saw the last part of
09:02:56 <Nikola> oh ok - so unix-2.7.2.1 is there in any standard installation ?
09:03:14 <cocreature> Nikola: yep
09:03:22 <kmelva_> is there something "beyond" algebraic data types as in Haskell? analoguus to what dependent types are to Haskell?
09:03:33 <geekosaur> Nikola, on a unixlike system, yes
09:03:40 <geekosaur> should be obvious it wont be on windows
09:03:40 <Nikola> how do I know what is standard and what not ?
09:04:17 <monochrom> OK, it is parentheses. (h::String)
09:04:27 <geekosaur> Nikola, https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/frames.html
09:04:33 <geekosaur> libraries that come with ghc
09:04:34 <cocreature> Nikola: in general I would say that the what is part of the standard library and the packages bundled with ghc is not particularly important. every project is going to depend on a bunch of external libraries
09:04:45 <geekosaur> (I should point to 8.0.2 buut someone forgot to upload it yet again :/ )
09:05:27 <geekosaur> also you should understand that ghc ships with *as little as possible* because ghc's haskell code has some nasty dependency gotchas in the name of performance
09:05:44 <geekosaur> so pretty much everything requires external libraries and trying to avoid them is a fool's errand
09:06:09 <geekosaur> (anything that ships with ghc is not uphgradeable, basically, except by replacing ghc)
09:06:30 <MarcelineVQ> geekosaur: 8.0.2 is there it just didn't replace /latest/
09:06:57 <geekosaur> I swapped 8.0.2 for 8.0.1 and got a 404
09:07:22 <geekosaur> oh, they dropped the frames interface :(
09:07:33 <geekosaur> or renamed it maybe
09:07:51 * geekosaur considers a usability bug report
09:15:39 <thatguy> If I am writing a game in haskell and I want to save the positions of all of my agents and they change all the time, is it really a good idea to have immutable data structures then?
09:16:09 <oPn7> geekosaur: can you look at this ? https://paste.kde.org/pwyj0nze5
09:16:15 <Theophane> thatguy: you could use the State monad
09:17:13 <geekosaur> oPn7, for starters, once you lose the unnecessary type annotations, you don;t need the parentheses either
09:18:04 <geekosaur> second: getArgs is IO [[Char]], but you are using its result as if it were IO [Char]
09:19:33 <geekosaur> it is getArgs not getArg. it returns a *list* of arguments, not a single argument or a string containing multiple arguments
09:23:49 <geekosaur> oPn7, for your use case, the patterns you want are probably ("-h":[]), ("-d":[]), and _
09:24:16 <geekosaur> although you could also write the first two as ["-h"] and ["-b"]
09:24:25 <geekosaur> er -b not -d in that first one, sorry
09:25:23 <oPn7> okey 
09:26:31 <oPn7> there, that says, i expect [Char] but you gave me Char ? Couldn't match type ‘Char’ with ‘[Char]’
09:28:26 <geekosaur> please pastebin current code and full error again
09:28:44 * geekosaur ... is still fuzzy, sigh
09:31:20 <oPn7> http://pastebin.com/Mh21YuQ0
09:31:29 <oPn7> sorry :D pastebin is blocked here 
09:31:46 <oPn7> used proxy for that
09:33:36 <geekosaur> "pastebin" does not mean exactly pastebin.com and in fact many of us prefer you not use that. did paste.kde.org die?
09:35:03 <geekosaur> never mind, I will try to remember to precisely identify the nopaste host from now on
09:35:31 <oPn7> okey :D 
09:36:39 <geekosaur> so you said that gave you a mismatch on Char vs [Char] but the error talks about IO () and SP.CreateProcess...
09:37:00 <geekosaur> the problem here is that "shell" does not do what you think
09:37:06 <oPn7> yeah after your suggestions [] that part is okey
09:37:22 <oPn7> yeah i realized that. i used createProcess $ ...
09:37:27 <oPn7> but another error
09:37:30 <geekosaur> it specifies whether to use a shell or direct exec in a process creation specifier
09:37:42 <geekosaur> you probably want to use system
09:37:54 <geekosaur> @index system
09:37:55 <lambdabot> System.Process, System.Cmd
09:38:31 <geekosaur> unless you are actually intending to capture output or something
09:39:06 <oPn7> i should use System.Cmd 
09:39:43 <geekosaur> you already have System.Process imported...
09:40:58 <oPn7> geekosaur: https://paste.kde.org/pzmpxe3bm
09:41:51 <geekosaur> oPn7, yes, this is why I suggested system instead of CreateProcess
09:42:00 <geekosaur> you have to handle the result of CreateProcess
09:42:44 <geekosaur> it is giving you a tuple of possible filehandles and a result status, but you are using it in a place that expects "nothing" ( (), the degenerate tuple aka "unit")
09:46:20 <lpaste_> geekosaur pasted “No title” at http://lpaste.net/353214
09:48:23 <oPn7> geekosaur: yeah i did that and • Couldn't match type ‘SX.ExitCode’ with ‘()’
09:48:51 <geekosaur> :t system
09:48:53 <lambdabot> error: Variable not in scope: system
09:49:01 <geekosaur> :t System.Process.system
09:49:05 <lambdabot> String -> IO GHC.IO.Exception.ExitCode
09:49:16 <geekosaur> mrr. right, same problem with a simpler type
09:49:39 <geekosaur> so add ">> return ()" to the end of that if you don't care whether it succeeds or not, otherwise handle the ExitCode
09:50:43 <geekosaur> if you're not doing anything else after that, I would actually suggest:  SP.system "..." >>= exitWith
09:50:57 <geekosaur> so the Haskell program relays the result of the build to whatever invoked it
09:51:31 <geekosaur> er, probaby need to qualify that
09:51:40 <geekosaur> SP.system ... >>= SX.exitWith
09:53:01 <oPn7> the "..." part the thing i need to know actually :D if it works will message "Built is successfull etc.."
09:58:52 <MarcelineVQ> but little did the townsfolk know that the superhero known only as ertesx was actually ertes all along
09:59:47 <geekosaur> oPn7, the ... part is the nix-whatever you had there
10:00:04 <geekosaur> do I also have to copy-paste what you have already written as well?
10:00:04 <ertes> great…  thanks a lot for blowing my cover…
10:00:29 <geekosaur> I feel like we are not speaking the same language somehow, you are oddly precise in the palces you should not be and imprecise where you need to be
10:01:04 <oPn7> yeah yeah gotcha
10:01:48 <oPn7> it cant know whether nix-build .. is done its job or not. i am idiot sorry :D
10:03:29 <oPn7> geekosaur: what this means ">>=" or ">>" ? 
10:03:57 <geekosaur> the short version is that's what "do" notation turns into
10:04:34 <Myrl-saki> Is there a Parsec where failing is local?
10:04:43 <geekosaur> when you have something like IO ExitCode, you can;t use it directly because it is something that must be executed by the runtime to at some point produce an ExitCode
10:04:56 <Myrl-saki> Something like attoparsec, except not on Bytestrings and Text.
10:05:02 <geekosaur> >>= is how you add something to be done whenever the ExitCode becomes available
10:05:31 <geekosaur> >> is the version that ignores the result, and is used when the result is IO () because there;s nothing useful to do with a received ()
10:05:49 <geekosaur> but you can use it to "ignore" any IO result
10:06:20 <Myrl-saki> By that, I mean I don't have to use `try`.
10:06:33 <Myrl-saki> (That, or convince me why `try`.)
10:07:14 <oPn7> geekosaur: okey thank you, i got it
10:07:20 <tommd> In liquid Haskell I've reflected a function {-@ reflect func @-} which is a case/pattern match on a user data type.  Now liquid is complaining about Unbound Symbols `is_{constructor}`.
10:07:28 <tommd> Any liquid guru's here who have seen this?
10:09:51 <geekosaur> Myrl-saki, the point of try is not fail. the point of try is that backtracking is *expensive*
10:10:18 <geekosaur> so it does not backtrack, if a parser parses something and then fails the part it parsed is still consumed. you use try to tell it explicitly when to backtrack
10:10:37 <geekosaur> and where to backtrack to
10:11:07 <geekosaur> to limit the cost of backtracking
10:11:37 <thatguy> if I am writing some kind of simulation which mostly is: iterate stepSimulation initialstate, should I then just chunk together the whole "world" state into one data structure which stepSimulation then works on?
10:12:07 <Myrl-saki> geekosaur: Right.
10:12:15 <tsahyt> Myrl-saki: attoparsec just has implicit try
10:12:23 <Myrl-saki> tsahyt: I know, and I like that.
10:12:35 <Myrl-saki> But I don't want to work with only ByteStrings and Lists.
10:12:37 <Myrl-saki> Err
10:12:37 <tsahyt> it can and will backtrack arbitrarily, and if you're not careful this can lead to some major performance problems
10:12:39 <Myrl-saki> Text*
10:13:05 <Myrl-saki> geekosaur: Isn't there a better way such as identifying common token prefixes?
10:13:29 <geekosaur> how should it do that without pre-parsing your Haskell code?
10:13:36 <Myrl-saki> geekosaur: Right.
10:13:52 <Myrl-saki> geekosaur: That's the programmer's job.
10:13:56 <geekosaur> perhaps you want to use happy instead of parser combinators
10:14:07 <rly> thatguy: how high performance does this simulation have to be?
10:14:35 <geekosaur> but yes, in parser combinators that is the programmer's job, but few want to do that much work
10:14:56 <geekosaur> but you can;t write simple combinator code and expect runtime to have inspected all possible code paths and built prefix tables
10:15:10 <Myrl-saki> geekosaur: I guess it's a difference in perspective. I find identifying which part to add `try` more tiring and ugly.
10:15:30 <tsahyt> Just having try added implicitly everywhere is hardly more satisfying imo
10:15:45 <Myrl-saki> tsahyt: It's less ugly though. :P
10:15:56 <geekosaur> I don;t find adding try where needed a problem; it's usually fairly obvious where it si needed
10:15:56 <thatguy> rly: its just a hobby project so it doesn't have to compare with C code but I'd like to learn how to do it right in the long run
10:16:01 <tsahyt> a <||> b = try a <|> b
10:16:10 <tsahyt> now you don't have try littered everywhere
10:16:15 <tsahyt> at least not obviously
10:16:17 <Myrl-saki> tsahyt: True. xD
10:16:37 <Myrl-saki> geekosaur: I guess I have to rephrase my question to something the docs don't show.
10:16:53 <Myrl-saki> geekosaur: Where (in real code) does not adding try benefit the programmer?
10:16:59 <geekosaur> ...although I admit I figured out parsers (including writing my own parser generators) some time back so I don;t have to think much about it :)
10:17:23 <geekosaur> performance, reduced memory requirements
10:17:33 <thatguy> rly: so I don't need to get the last bit of optimization out of the code but I'd like to think about performance nevertheless
10:17:53 <Myrl-saki> WHoops, I still horribly phrased that.
10:17:55 <geekosaur> granted not too much of either unless your parser is really lopsided, but.
10:18:03 <Myrl-saki> geekosaur: Where is backtracking not required?
10:18:41 <rly> thatguy: GHC will never get you *very* good performance, regardless of what microbenchmarks show.  
10:18:43 <Myrl-saki> I find myself requiring backtracking for almost anything.
10:18:44 <geekosaur> anywhere there's only one valid parse, anywhere you are parsing only a single token as pass/fail
10:18:53 <monochrom> When you have an unambiguous grammar. Or an ambiguous grammar but you have a secret tie-breaker.
10:19:04 <Myrl-saki> geekosaur: Ohhh
10:19:14 <geekosaur> (although you must bve careful witht he latter because usually the token type is Char)
10:19:37 <thatguy> rly: is that because it is functional or because of the langauge design?
10:19:47 <Myrl-saki> geekosaur: I forgot the performance implications of `try` on a single token. Thanks.
10:20:04 <geekosaur> you can simplify this with a 2-level parser, one level is Char tokens an produces lexemes, the second level handles lexeme parsing and can avoid backtracking
10:20:06 <rly> thatguy: for real programs, you need to understand the specific run-time system and how it interacts with your program. 
10:20:41 <thatguy> rly: yes I was thinking about if some multi-paradigm language like Ocaml may be better suited for me
10:20:43 <rly> thatguy: the language itself induces some slowness.
10:20:48 <Myrl-saki> geekosaur: Right. Not really a fan of that though.
10:20:49 <geekosaur> (the lexeme generator can often avoid try because it has simpler pass/fail conditions, the actual parser can avoid it because it is more often handling single lexeme tokens)
10:21:02 <rly> thatguy: the value of Haskell is that the semantics are quite clear for concurrency/parallelism primitives.
10:21:41 <rly> thatguy: but in GHC there are also some exceptions to this, which exist because of "performance".
10:22:26 <rly> thatguy: Haskell is supposed to be a Sufficiently Smart Compiler language.
10:22:39 <rly> thatguy: OCaml's design is to have a really stupid compiler.
10:22:46 <thatguy> rly: so if I want a general purpose language and am mostly interested in numerical simulations where I do think about performance, would you say that some multi-paradigm language like ocaml may be better suited?
10:23:05 <rly> thatguy: I think you can use Haskell, but you should just use it as a compiler then.
10:23:25 <thatguy> rly: do you recommend any other functional language which maybe is not sooo strict about state and is a bit clearer about what which code does?
10:23:27 <hpc> you could do something silly like use haskell to generate fortran ;)
10:23:28 <rly> thatguy: this is a bit what the domain specific language hype was about a few years ago.
10:23:42 <rly> hpc: why would that be silly?
10:24:32 <rly> thatguy: I think you want to have a slow implementation in Haskell, and then another backend which compiles for example to Fortran (or C++, or..).
10:24:59 <rly> thatguy: FFTW works like this.
10:25:09 <monochrom> Ironically, generating Fortran is less silly than generating C.
10:25:20 <Sornaensis> that's how scipy works
10:25:30 <rly> thatguy: it exploits OCaml to do various smart things, but it never actually uses the OCaml run-time system.
10:25:32 <monochrom> Did you know that mature Fortran compilers are more optimizing than mature C compilers?
10:25:33 <Sornaensis> you write python and it emits C++
10:26:07 <monochrom> Age of Fortran notwithstanding, there is also C's own issue of too many semantic gotchas forcing optimizers to be really paranoid.
10:26:08 <thatguy> Sornaensis: I was using numpy/scipy for my stuff before learning haskell indeed
10:26:09 <rly> thatguy: having said that, Haskell is fine for the first version of your simulation, or whatever.
10:26:47 <rly> thatguy: if at some point it turns out that you want to do *huge* things and you are running a few hundred node cluster, then you might want to look in these things.
10:28:11 <Sornaensis> what's wrong with cloud haskell
10:28:23 <rly> Sornaensis: nobody uses it?
10:28:34 <rly> Sornaensis: by "nobody", I mean "almost nobody".
10:28:49 <rly> Sornaensis: it was just written as a "look, we can do Erlang too".
10:29:11 <Sornaensis> that didn't really answer my question
10:29:22 <geekosaur> your question isn;t really answerable
10:29:59 <thatguy> rly: ok thanks for the insight
10:30:18 <rly> Sornaensis: the latest "news" was over a year ago.
10:30:38 <thatguy> that helped a lot but now I am thinking if haskell is the right language to dig further into
10:30:44 <rly> Sornaensis: this might mean it's already God's personal best code and nothing can be improved, or nobody cares about it.
10:30:50 <geekosaur> that said, cloud haskell depends on a feature of ghc that is still evolving (stable names)
10:31:05 <rly> That was quick.
10:31:14 <geekosaur> so a pause in development can mean they're waiting on changes upstream
10:31:23 <rly> A business wouldn't like to be dependent on a single implementation of a language.
10:31:36 <monochrom> I think both can happen. Usually, nobody cares about God's personal best code.
10:31:55 <thatguy> yeah well I did the whole tutorial cis 194 and loved it but as soon as I want to apply it to my problems (mostly numerical stuff) I get the feeling that I would like to have some state at least
10:32:14 <geekosaur> rly, where's the second impl of perl5? python? (ok, there's a few but they're all worse) php?
10:32:23 <rly> thatguy: there are IORefs in Haskell.
10:32:46 <rly> thatguy: all the features are there, but imperative algorithms often look more ugly in Haskell.
10:32:57 <rly> (which is to be expected)
10:33:18 <thatguy> but am I just to new to haskell or is numerical (mathematics) mostly very imperative?
10:33:46 <thatguy> its nearly always that you have some state which changes or some solution which you imperatively make better etc
10:34:09 <rly> thatguy: for the part where it matters (FPU behaviour), Haskell is also not pure. 
10:35:17 <rly> I wonder whether anyone ever has demonstrated superior Haskell performance for a real numerical simulation (i.e., something used in climate models, for example).
10:35:39 <rly> I'd expect to have heard about it, if that had happened.
10:35:40 <monochrom> To a large extent, the "multitude" of Python implementations is no better than Haskell's situation of "we do have jhc, ajhc, nhc, and hugs".
10:35:49 <rly> monochrom: I disagree on that point.
10:36:04 <rly> monochrom: Python2.X has viable implementations.
10:36:25 <rly> monochrom: in Haskell, there is Haskell 98 in what can best be described as toy implementations.
10:36:58 <thatguy> monochrom: I don't understand what you mean by that
10:37:16 <thatguy> rly: do you use haskell for climate numerics?
10:37:27 <rly> thatguy: there are some full program optimization compilers for Haskell. 
10:37:44 <rly> thatguy: they are even more niche (of course) than using Haskell in the first place.
10:37:48 <rly> thatguy: no
10:38:14 <rly> thatguy: I have used Haskell for non-trivial things, which completely destroyed GHC.
10:38:22 <rly> thatguy: not the same domain as yours.
10:38:33 <thatguy> so you are not actively using haskell anymore?
10:38:54 <rly> thatguy: no, I sometimes write some scripts in it, but no "real work".
10:39:06 <thatguy> so what do you use now if I may ask?
10:39:23 <rly> thatguy: I don't want to endorse other things I also don't like :)
10:39:42 <rly> thatguy: IMHO, the world is a complete mess.
10:40:09 <rly> thatguy: we don't even have production file systems which have been verified to be free of bugs.
10:40:14 <thatguy> :D
10:40:43 <cocreature> well, formal verification is a _lot_ of work
10:40:43 <rly> We do have academic file systems with that property, though, but that happened in the past 5 years or so.
10:41:08 <rly> cocreature: I think it's less work than having a "bug tracking system" and "debugging random clients".
10:41:15 <thatguy> ok I think I'll just try to implement my simulation in haskell for now
10:41:20 <rly> cocreature: take for example "ZFS".
10:41:33 <rly> cocreature: it was designed a *long* time ago, and it still doesn't work.
10:41:36 <cocreature> rly: as someone working on formal verification, I disagree :)
10:41:48 <thatguy> but did I get it right that if you want to be performant on such bigger projects you cannot stick to functional languages but will have to return to C/C++ or something else lowlevel imperative?
10:41:57 <rly> cocreature: what do you do? Coq/Agda?
10:42:09 <cocreature> even if you formally verify your file system, you are probably making incorrect assumptions in your formal model and your file system is still buggy
10:42:24 <rly> cocreature: wrong assumptions can be fixed.
10:42:30 <ertes> Myrl-saki: http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
10:42:30 <rly> cocreature: at least it would get better over time.
10:42:48 <rly> cocreature: with our current development method, there is no way to know whether progress is being made.
10:43:00 <cocreature> well good luck writing your formally verified file system
10:43:32 <rly> cocreature: you don't want to say specifically what tooling you use?
10:43:49 <rly> cocreature: do you work on it commercially? Intel?
10:43:56 <cocreature> rly: we prove the equivalence of C code using smt solvers
10:44:04 <cocreature> not commercially, academia
10:44:12 <ertes> Myrl-saki: auto-backtracking is needlessly expensive and in parsers for human languages makes error reporting almost useless
10:44:21 <rly> cocreature: right, and that approach was already dead when I was in university.
10:44:29 <cocreature> lol
10:44:37 <cocreature> sry I have no interest in continuing that conversation
10:44:54 <rly> cocreature: unfortunate.
10:45:41 <monochrom> The wrong-specification problem is solved by not assigning blames unilaterally. You only assert "implementation mismatches specification". You don't assert the assymetric "implementation is wrong". The value of verification is that you now get two perspectives (the implementation and the specification) not just one (the implementation), this is supposed to be more informative.
10:46:18 <ertes> also changing assumptions can be quite expensive
10:46:32 <ertes> up to completely having to redo all proofs
10:47:21 <rly> ertes: if you write a program without a proof, you still need to do that work, except you don't write it out and you hope for the best.
10:48:03 <ertes> rly: you don't need to, and generally it's not done
10:48:18 <rly> ertes: sure, and that's why all bug trackers are filled.
10:48:42 <cocreature> so let’s just stop using computers because writing correct software is impossible
10:48:48 <ertes> try to look for formal proofs in the linux kernel…  not machine-checked proofs, just formal ones that would actually count as real proofs, i.e. instances of "you still need to do that work"
10:48:54 <johnw> cocreature: it's not impossible, just hard
10:49:04 <ertes> rly: it's easy to say: "it needs to be done"
10:49:08 <ertes> actually doing it is a different story
10:49:08 <cocreature> johnw: I was being sarcastic :)
10:49:16 <monochrom> I do stop exercising because it is hard. :)
10:50:05 <monochrom> Also, I stopped demanding proofs of correctness because getting people to write proofs is hard.
10:50:27 <monochrom> Writing proofs is not hard for me. But getting other people to do it is hard.
10:50:37 <ertes> one factor is that our tools aren't adequate for formalising a whole system
10:50:40 <rly> I think the problem is that there are only a few people on the planet who can write proofs and not all of those teach.
10:50:53 <ertes> and i believe before they get adequate, AI will take over writing them
10:51:00 <rly> I.e., write proofs of "production quality".
10:51:28 <ertes> rly: that's *a* problem…  a more relevant problem is that it's *hard*, even for people who can do it
10:51:29 <MarcelineVQ> monochrom: where do you learn to write proofs?
10:51:55 <rly> ertes: part of the reason is that proving theorems is in EXP.
10:52:01 <rly> ertes: so, of course it is hard.
10:52:03 <MarcelineVQ> monochrom: would sicp teach me?
10:52:25 <monochrom> And it doesn't have to be proofs. You need to wipe-clean your keyboard? Guess what, doing it yourself is so much easier than convincing someone else to do it.
10:52:37 <rly> monochrom: haha
10:52:37 <cocreature> MarcelineVQ: software foundations is pretty good if you are interested in formalizing and proving things about software
10:52:56 <ertes> rly: now combine that with the problem of practical/commercial feasibility…  sure, software is never *finished*, but at some point you want to produce something people can actually use =)
10:53:27 <rly> ertes: lots of software I have written happily hums away in data centers/clouds.
10:53:39 <cocreature> in a lot of cases the cost of bugs is simply cheaper than the cost of verifying that there are no bugs
10:53:40 <ertes> rly: and those are formally verified?
10:53:47 <rly> ertes: I wrote them, so they are perfect ;)
10:53:52 <ertes> so no
10:54:34 <rly> ertes: the only reason I am interested in formal tools, is because I don't like the quality of the software the rest of the planet is producing.
10:55:05 <rly> ertes: the current software development process doesn't scale for > SMALL_CONSTANT number of people.
10:55:26 <rly> The Linux kernel solved it by using trust.
10:55:26 <MarcelineVQ> I'm quite interetsed in learning about this stuff. even the idea of a proof is a little bit of black magic to me, if something works for x+1 and x+2 how can you then know it works for x+n
10:55:43 <cocreature> MarcelineVQ: https://www.cis.upenn.edu/~bcpierce/sf/current/index.html that’s the book I was mentioning
10:55:45 <ertes> MarcelineVQ: induction
10:55:47 <monochrom> MarcelineVQ: Bird's textbooks are one kind of books that teach proofs.
10:55:57 <monochrom> I haven't read SICP.
10:56:15 <ertes> MarcelineVQ: you prove that 1. it works for 0, 2. if it works for x, it also works for x + 1, for all x
10:56:21 <cocreature> I’ve read the first half or so of sicp. I don’t think it helps with teaching proofs
10:56:40 <ertes> MarcelineVQ: then in a certain sense magically it works for all natural numbers =)
10:57:03 <cocreature> induction on natural numbers made a lot more sense to me once I saw general structural induction and understood that natural numbers are just a special case of that
10:57:12 <ertes> (induction is not universally accepted as a valid principle, but i think most mathematicians accept it)
10:57:25 <monochrom> Induction is explained poorly because most explainers do not make explicit the "forall" quantifiers.
10:57:52 <rly> Induction is something you learn in high school.
10:58:20 <monochrom> You rightfully observe that "(forall x. works for x) => (forall x. works for x+1)" is circular logic. But induction does not say that.
10:58:48 <monochrom> Induction says "(forall x. (works for x => works for x+1))". Very different.
10:59:46 <monochrom> Once upon a time, there was a kid who saw a wounded bird. The kid was kind-hearted and able, he saved the bird and healed it.
11:00:07 <monochrom> The bird turns out to be a fairy. The fairy says, "I will grant you two wishes".
11:00:21 <ertes> MarcelineVQ: exercise: prove that the sum of two even natural numbers is an even natural number…  you may use the usual arithmetic properties (associativity, distributivity, etc.) of addition and multiplication
11:00:21 <Fairy> I said no such thing!
11:00:24 <monochrom> (Why two, why no three? Because I'm teaching induction!)
11:00:37 <monochrom> Haha OK sorry Fairy. Different fairy.
11:00:42 <Fairy> <_<
11:01:07 <monochrom> The kid was a math geek. (I guess the fairy was, too.) So he said: first wish, today I receive one gold coin.
11:01:57 <monochrom> Second wish: For each day, if I received a gold coin on that day, then I will also receive a gold coin on the next day.
11:02:28 <monochrom> If you now see that the kid will receive everyday a gold coin thereafter, you have understood induction.
11:03:41 <ertes> then the fairy says: "sorry, i'm propositional, but i'm happy to serve your first wish"
11:05:34 <buttons840> while were on this topic -- i was wondering if dependant types can be used to prove anything which is true? i know there are certain types of logic that cannot be expressed with dependant types, but are there alternative proofs for the same things?
11:06:10 <MarcelineVQ> ertes: I don't know what it means to prove something ^^; uhm,  2 + 2 = 4  this is true regardless of which two is in which spot, why is this true, well, uhm, 1 + 1 is 2, 2 + 1 + 1 is 4    1 + 1 + 2 = 4    and even 1 + 1 + 1 + 1 = 4
11:06:59 <ertes> MarcelineVQ: first define what it means for a natural number to be even
11:07:14 <ertes> MarcelineVQ: use the phrase "there exists" in your definition
11:08:08 <buttons840> MarcelineVQ: i am reading a book called "How To Prove It", which is focused on mathematical proofs and not on any computer program, but it might be a good resource for you to learn about proofs
11:09:05 <doyougnu> You may want to checkout Proofs in Idris then. 2 + 2 = 4 in Idris looks like this: 
11:09:05 <doyougnu> two_plus_two : n = 2 -> m = 2 -> m + n = 4
11:09:05 <doyougnu> two_plus_two p q = rewrite p in rewrite q in Refl
11:11:32 <MarcelineVQ> there exists a set of natural numbers which consists only of multiples of 2, they are called even numbers
11:12:10 <ertes> MarcelineVQ: definition: for all natural numbers n the statement "n is even" is equivalent to the statement: there exists …
11:12:16 <ertes> finish the sentence
11:14:17 <osa1> what's wrong with this pattern synonym: `pattern Some x <- Left x where Some x = Left x` ?
11:15:08 <ertes> MarcelineVQ: if you can't figure it out:  why is 10 even?  what makes it even?
11:15:22 <cocreature> osa1: compiles for me, what makes you think it is incorrect?
11:15:41 <osa1> cocreature: I get an error
11:15:49 <osa1> ghc 8.0.1
11:16:27 <cocreature> osa1: hm works with 8.0.2 and 8.0.1 for me
11:16:32 <osa1> huh, 8.0.2 doesn't give an error
11:16:32 <MarcelineVQ> there exists a factor of 2?
11:16:46 <ertes> MarcelineVQ: yeah…  10 is even, because it's a multiple of 2
11:17:04 <ertes> and "multiple of 2" means: "there exists a natural number k such that 10 = 2*k"
11:18:02 <ertes> MarcelineVQ: now generalise this:  definition: for all naturals n, "n is even" is the same statement as: there exists …
11:18:11 <osa1> cocreature: http://lpaste.net/353216
11:19:00 <geekosaur> osa1, iirc 8.0.1 does have some bugs in patsyns
11:19:09 <geekosaur> you may want to stick to 8.0.2
11:19:15 <cocreature> osa1: that’s different to the one you pasted here. it uses Right and not Left in the constructor
11:19:56 <xubunto> jw what does lift do?
11:20:09 <xubunto> (i assume haskell has this function)
11:20:12 <osa1> cocreature: ahh! so can't I use Right in the pattern part and Left in the expression part?
11:20:35 <cocreature> osa1: it definitely feels wrong but I’m still thinking about why that’s not allowed :)
11:20:42 <ertes> xubunto: it's most likely 'lift' from MonadTrans…  do you have a working understanding of monads?
11:20:51 <osa1> yeah it's weird but it should be possible
11:20:58 <xubunto> ertes: yes
11:21:33 <ertes> xubunto: let T be a monad transformer, then 'lift' embeds an action of the target monad m in (T m)
11:21:37 <ertes> lift :: m a -> T m a
11:21:45 <MarcelineVQ> it feels a bit like parroting, but: there exists a natural number k such that n = 2*k
11:22:27 <ertes> MarcelineVQ: that's correct, and it may feel like it, but having a precise definition in terms of logical primitives (in this case: explicit quantification) is important
11:22:51 <xubunto> MarcelineVQ: is that lifting too?
11:23:16 <cocreature> osa1: ah! it works with an explicit type signature. so it’s just ghc’s inference that is not smart enough to figure out that the left and right side have to have the same type
11:23:20 <ertes> MarcelineVQ: now try to prove that the sum of two even naturals is always an even natural…  first formulate an actual logical statement, a precise version of this statement
11:23:26 <xubunto> oh
11:23:30 <ertes> MarcelineVQ: you will need the phrase "for all"
11:23:40 <osa1> cocreature: how do you add a type sig to a pat syn?
11:23:51 <ertes> MarcelineVQ: (you may reuse your definition of "even" now, because now it's exact)
11:24:04 <ertes> ((taking the definition of naturals for granted))
11:24:16 <cocreature> osa1: http://lpaste.net/353217 
11:24:17 <xubunto> ertes: so say i lift just 5
11:24:26 <tsahyt> Is there such a thing as an applicative transformer?
11:24:29 <ertes> xubunto: lift (Just 5)
11:24:41 <xubunto> what would that do
11:24:44 <ertes> tsahyt: sure, every monad transformer is an applicative transformer
11:24:53 <tsahyt> ertes: but what about transformers for things that are applicatives but not monads?
11:24:54 <osa1> cocreature: awesome! thanks
11:24:55 <ertes> tsahyt: but there are easier methods to combine applicative functors
11:25:14 <ertes> xubunto: lift :: Maybe a -> T (Maybe a)
11:25:24 <ertes> xubunto: choose T, then it may be clearer what it means
11:25:41 <ertes> whoops
11:25:44 <ertes> xubunto: lift :: Maybe a -> T Maybe a
11:26:17 <xubunto> ertes: either *2 or String
11:26:29 <ertes> xubunto: do you know what MaybeT is?
11:26:36 <newbie64> hi, what is the difference between polytypic programming and generic programming?
11:26:37 <tsahyt> ertes: what I'm dealing with here is that I have values that are calculated recursively with an ArrowLoop interface (which does make more sense here than for FRP) and a 1 sample delay on each recursive step. But this of course can lead to infinite recursion quite quickly. So I was thinking about providing a type that provides limited recursion somehow, since that's how you generally handle these things in
11:26:39 <tsahyt> DSP
11:26:55 <xubunto> ertes: no
11:27:22 <ertes> xubunto: newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
11:27:36 <ertes> for all monads m, (MaybeT m) is a monad
11:27:46 <ertes> in other words:  instance (Monad m) => Monad (MaybeT m)
11:28:11 <ertes> xubunto: you may want to take it as an exercise to implement Functor, Applicative and Monad instances for this by yourself
11:28:36 <kuribas> Strange how adding code makes it faster... I added an iteration limit, and my code is 25% faster!
11:28:44 <ertes> xubunto: once you've done that, implement the following instance:  instance MonadTrans MaybeT
11:28:58 <xubunto> i went through the stuff for functors
11:28:59 <ertes> this will require you to implement 'lift' for MaybeT
11:28:59 <kuribas> Probably has something to do with cache prediction...
11:30:17 <glguy> lolisa: Assuming polytypic means definitions using polymorphic types, the definitions are implemented with no knowledge of the type variables, and specific knowledge of the non-type variables. so 'map :: (a -> b) -> [a] -> [b]' is going to work uniformly in choices of 'a' and 'b', using only the knowledge of lists and functions
11:30:50 <glguy> lolisa: Typically "generic" programming is where the structure of the function definition gets access to the structure of the types its operating on without being tied to a specific type
11:31:09 <glguy> This happens using Template Haskell, GHC.Generics, or SYB/Data.Data
11:31:39 <glguy> where the structure of types is made available either in a common type representation or a common value representation
11:32:07 <lolisa> Sorry... I should provide some context
11:32:29 <lolisa> http://www.cs.ox.ac.uk/ralf.hinze/talks/Nijmegen.pdf
11:32:54 <glguy> Did you have a more complete question then?
11:34:10 <lolisa> Yes. Polytypic programming also 'look into constructor' so it seems very similar to generic programming. I dont know if they are the same thing, or have some subtle difference.
11:34:40 <glguy> Into a specific constructor
11:35:11 <glguy> Like for map, only the constructors (:) and [] are available, not those of types 'a' or 'b'
11:36:53 <MarcelineVQ> ertes: for all even natural numbers n and for all even natural numbers k, n+k is even
11:37:24 <lolisa> I think polytypic is not the same thing as polymorphic...
11:38:08 <xubunto> ertes: ill look into applicative functors
11:38:59 <glguy> lolisa: Yeah, this talk appears to use polytypic to mean what I described as generic
11:39:00 <ertes> MarcelineVQ: yeah…  can you prove it?  show why it must be true
11:39:13 <glguy> paper->slides
11:39:53 <lolisa> thx anyway :)
11:40:19 <lolisa> ertes, yes. induction on the definition of eveness.
11:40:33 <glguy> lolisa: This looks like the precursor to GHC.Generics
11:40:56 <lolisa> Yes it sure does. Very interested into such thing.
11:41:10 <lolisa> to be more formal, induction on the proof that n is a even number.
11:41:31 <lolisa> base case: n = 0 is a even number, n + k = 0 + k = k, use the other hypothesis
11:41:56 <ertes> lolisa: please don't spoil it…  it's an exercise!
11:42:17 <jle`> i have my types defined in a seperate 'types' file, but in order to write instances for it, i would be using some utility functions that aren't defined in the types file
11:42:18 <lolisa> Oh, very sorry, does not see context
11:42:30 <jle`> if i move them all to the types file then the file becomes a bit bloaded and it sort of defeats the purpose
11:42:40 <glguy> Related to GHC.Generics, I did an implementation of a unified lens/traversal generator supporting type-changes this week http://lpaste.net/353157
11:42:41 <jle`> is there any common strategy to handle this nicely?
11:42:52 <ertes> (also you don't need induction here…  i explicitly allowed MarcelineVQ to use arithmetic properties of addition and multiplication)
11:43:08 <cocreature> jle`: I sometimes have a Types.Util module
11:43:25 <glguy> Don't merge all the types into a Types file?
11:43:51 <xubunto> ertes: can you give me a direction on applicative functors? (i have a sense on normal functors)
11:44:02 <jle`> glguy: but if i don't do that then i end up with cyclic imports eventually usually
11:44:13 <jle`> cocreature: does types.util have the typeclass instances too?
11:44:41 <cocreature> jle`: depends, I don’t have strict rules here
11:44:48 <glguy> jle`: That's OK, you can make hs-boot files so that you can maintain the complicated types in separate modules and still have them import each other where needed
11:45:39 <ertes> xubunto: where functors allow you to map over the (let's call it) point type of a single value, applicative functors let you combine two values into a single one while mapping over their point types
11:45:55 <jle`> gotta look into hs-boot files then
11:46:20 <ertes> fmap  ::   (a -> b) -> f a -> f b
11:46:20 <ertes> (<*>) :: f (a -> b) -> f a -> f b
11:46:24 <ertes> xubunto: ^
11:46:42 <xubunto> yea that f is confusing
11:46:55 <ertes> xubunto: look at a particular instance: Maybe
11:48:33 <ertes> xubunto: look also at [] and IO
11:48:48 <ertes> there is not only a list of values, but also a list of mapping functions
11:49:03 <ertes> [] does something along the lines of cartesian product
11:49:23 <ertes> IO: there is not only a program for the value, but also a program for the mapping function for the value
11:50:46 <xubunto> ertes: i found lyah article on it so reading through it
11:58:34 <dbohdan> Hey, everyone!
11:58:50 <dbohdan> I've run into an issue with a socket Handle that only manifests on Windows.
11:59:35 <dbohdan> When I do hReady on a socket Handle my program terminates with the message:
11:59:38 <dbohdan> >fdReady: fd is too big
11:59:44 <dbohdan> >This application has requested the Runtime to terminate it in an unusual way.
11:59:49 <dbohdan> >Please contact the application's support team for more information.
12:01:22 <dbohdan> The code to reproduce the issue + log: http://lpaste.net/917655724551569408
12:01:51 <dbohdan> Does anyone here know what this is?
12:02:23 <dbohdan> The example (and the larger socket program from which it derives) works normally on Linux and FreeBSD.
12:02:55 <geekosaur> dbohdan, that means the ghc runtime is using select() with a (virtual, for Windows) file descriptor number that exceeds FD_SETSIZE
12:03:38 <dbohdan> I would the underlying C code that prints the message, but I'm not sure what it means.
12:03:48 <geekosaur> (well, slightly more complex than that)
12:03:57 <dbohdan> *found
12:04:09 <dbohdan> Should I be using hReady differently?
12:04:23 <dbohdan> (on Windows)
12:04:49 <geekosaur> I don't think so. but I also didn't think the ghc runtime used select(), precisely because of issues like this... but winsock is seriously weird and select() might be the only API available
12:05:16 <geekosaur> and in that case you may need to rethink things, because the error translates to "winsock can;t cope with the number of sockets you have open"
12:05:48 <geekosaur> oh, hm. you probably don;t want hReady there anyway
12:06:04 <geekosaur> it doesn't do what you think
12:06:20 <geekosaur> why did you use it?
12:07:16 <geekosaur> (and given how winsock works, I would not want to bet on things actually being set up fully enough for it to work there)
12:07:34 <dbohdan> Originally I was writing a function that pipes data from one handle to another.
12:07:49 <dbohdan> I'll paste it.
12:09:05 <dbohdan> It's for a little program that I like to write in every new language I learn.
12:09:09 <dbohdan> http://lpaste.net/2334901538167717888
12:11:00 <geekosaur> mm. at this point you probably need to talk to someone who knows what the network library is doing on Windows
12:11:23 <dbohdan> I use `forkIO $ relay a b` and `forkIO $ relay b a`. The hReady check is to handle the other green thread closing the socket underneath you.
12:11:34 <geekosaur> last time I looked at the details, it still required you to wrap stuff in withSocketsDo (this is unneessary in current versions)
12:13:03 <geekosaur> yes, the problem is that something may be deferring actually creating the full socket <-> fd hack that winsock uses (socketToHandle doesn't do that part, Handle-s for sockets on Windows are not fd based)
12:14:33 <dbohdan> Could I force the socket creation?
12:15:22 <geekosaur> ... that's kinda the wrong question. the socket exists
12:15:31 <geekosaur> Windows sockets *are not file descriptors*
12:16:25 <geekosaur> what doesn;t necessarily exist yet is an evil hack somewhere in the depths of winsock that creates a fake fd so you can use normal I/O functions and Windows CRT will detect it and use the appropriate winsock functions instead
12:16:40 <geekosaur> and I don;t know the guts of the network library on Windows well enough to know what controls that part
12:17:54 <dbohdan> I guess it's time to learn Winsock properly.
12:18:01 <geekosaur> it's weird and ghc's runtime for some reason tries to avoid conflating sockets and their fake file descriptors as much as possible even though most socket APIs require you to use the fd interface :/
12:18:05 * dbohdan shudders
12:18:36 <geekosaur> (so, some of this may be on ghc's runtime. Handle is moderately evil when it comes to winsock)
12:19:51 <dbohdan> Is there a list of known Windows gotchas? The docs for Network.Socket have some notes on Windows but not about this.
12:20:05 <geekosaur> not that I know of
12:20:55 <geekosaur> ghc generally treats windows as a second class citizen :( (despite having been funded by microsoft research!)
12:22:18 <Tuplanolla> If the funds aren't working, you aren't using enough.
12:22:34 <thoughtpolice> Well, this particular problem is tricky because the way Windows async I/O works is really, fundamentally different from Linux/BSD (honestly, I like Windows' approach more, tbh). There have been attempts to fix the feature parity problems, and it fixed certain issues like asynchronous interrupts and FD limits. Making it all scalable is still even more
12:22:34 <thoughtpolice> difficult.
12:22:34 <geekosaur> also I'm not 100% on that explanation of what's going wrong here. I can see it happening that way but I cn also see other things (that would imply ghc's runtime is just broken for some reason. what ghc version?)
12:22:52 <geekosaur> yes, windows async I/O is much saner
12:23:09 <geekosaur> but this particular problem *is* an fd limit
12:23:15 <thoughtpolice> (IIRC, it probably requires scheduler integration to actually be fast, otherwise you die from the context switching).
12:23:48 <thoughtpolice> Right, I'm just saying the reason it uses select() (and thus why the limit exists at all) is partially a design thing, to be figured out
12:24:18 <thoughtpolice> Well, mostly the performance part. I think Joey's port of the I/O manager to Windows actually did fix a lot of the egregious feature-parity problems, but it wasn't very fast. That's probably OK.
12:24:33 <thoughtpolice> e.g. things like socket functions not being interruptible on Windows via async exceptions
12:24:48 <thoughtpolice> Which means things like 'timeout' on a forkIO'd thread waiting on a foreign call can work, etc.
12:25:31 <thoughtpolice> The scheduler thing is kind of shitty if you want to get the performance back, though. It's conceptually nice having the I/O manager almost entirely separated from the runtime, and written in Haskell, I think. It's a challenge for sure.
12:26:15 <geekosaur> btw if anyone knows a Windows programmer with a fair amount of internals knowlege who is willing to learn hacking on a haskell compiler, ghc needs them badly
12:26:26 <geekosaur> there's *one* person who actually groks windows
12:27:24 <geekosaur> (that person would not be me. I know a little but get lost quickly when it starts getting into details)
12:28:03 <dbohdan> geekosaur: Maybe not making Haskell's Windows support better is part of Microsoft's F# strategy? (j/k, F# fans tell me MS doesn't have one.) Still, it seems like Haskell on Windows works way better than it used to even 5-7 years ago, if you go by the blog posts.
12:28:46 <dbohdan> stack is very consistent across different platforms.
12:29:22 <thoughtpolice> GHC-on-Windows improvement in the past few years, IMO, is largely attributable to Tamar more than anyone.
12:30:09 <thoughtpolice> It's not just obvious things like async I/O parity... hundreds of bugs, toolchain issues, minor wrinkles. Many of those are collectively, together, far more than the sum of their parts, so to speak.
12:30:39 <geekosaur> dbohdan, they were funding it for OS hardening / security research. they've moved that project on to other things at this point though
12:31:11 <geekosaur> and yes, Tamar's done a lot of good work to fix up what used to be a much more terrible Windows story
12:31:26 <dbohdan> Would you say that Haskell is or isn't production ready on Windows?
12:31:36 <dbohdan> (For network-y applications.)
12:31:48 <dbohdan> Command line tools seem to works great.
12:31:59 <geekosaur> there are people who use it. most of them have figured out the pain points, but I don;t know of any writeups
12:32:27 <thoughtpolice> Depends. Are you writing a server that gets called twice a day to do reporting? That's easy. Do you want 500,000 concurrent connections? That's... not going to be easy I'm afraid.
12:32:44 <geekosaur> but, I'm mostly a unix person, so.
12:32:57 <dbohdan> geekosaur: Me too...
12:33:38 <dbohdan> thoughtpolice: Closer to the former than the latter, I guess.
12:36:23 <xubunto> ertes: fun thing those applicative functors
12:37:34 <dbohdan> All right, you've given me some tips (thanks!) and I'll try to investigate the problem some more, maybe with a debugger. I'll get back to you if I find anything interesting.
12:38:24 <Tuplanolla> Threads seem to install their own exception handlers that print out the exceptions when they arrive and exit. Is there a way to completely replace this mechanism?
12:39:58 <Zemyla> Bit janitoring is just as annoying with Haskell as it is with any other language, it seems.
12:40:09 <xubunto> so what is the symbol <* for?
12:40:40 <Tuplanolla> It's `<*>`, but ignores the result on the right, xubunto.
12:40:41 <Rembane> xubunto: It's like >> but in the other direction and or applicative functors.
12:40:49 <Rembane> +f
12:40:50 <Zemyla> xubunto: a <* b = const <$> a <*> b.
12:41:04 <Zemyla> Except potentially more optimized.
12:41:49 <Tuplanolla> It comes up often with parsers etc.
12:42:10 <Theophane> hi folks!
12:42:16 <geekosaur> Tuplanolla, fafik it's just a catch (\(e :: SomeException) -> ...) wrapped around the whole thing. what are you trying to do?
12:42:28 <Tuplanolla> Just exploring, geekosaur.
12:43:10 <Theophane> I'm trying to create a shell application (a REPL, basically), and I would need to hold the network socket as a global state, and I have a few questions about it:
12:43:24 <Theophane> Is it the good way to do it?
12:43:48 <Theophane> and should I investigate about the State monad?
12:44:05 <geekosaur> hm, actually that cant be right. I think they actually don;t trap excedptions at all, and they propagate up to top level and abort the program
12:44:06 <Zemyla> Theophane: You can probably get away with the ReaderT monad.
12:44:24 <Theophane> okay cool, thanks Zemyla :)
12:44:41 <geekosaur> and you will need to understand how exceptions work if you want to change this, although the wrapper I suggested is a good start
12:44:42 <Zemyla> If you need to change the socket, use the ReaderT monad holding an MVar with the socket in it, so you always have the most updated state of the socket.
12:44:52 <geekosaur> *** but remember that Haskell is lazy ***
12:45:29 <geekosaur> threads can and will produce unevaluated thunks that get evaluated sometime afterward and throw then, and no exception handler in the thread will help you
12:45:42 <Theophane> Zemyla: okay cool :) thanks for the tip!
12:48:15 <Tuplanolla> Hmm, indeed.
12:49:54 <Zemyla> I'm having to save 2 or 3 21-bit Unicode Chars to a single Word64.
12:57:42 <mekeor> what do symbols in lispy languages do? – explained for haskellers? what do correlate to in haskell?
12:58:11 <Rembane> I want to count the number of constructors in a data type programmatically, how do I do that?
12:58:38 <lyxia> Rembane: generics or template haskell
12:59:04 <mekeor> lyxia: you cound use the Bound type class i think?
12:59:08 <glguy> :t length . dataTypeConstrs . dataTypeOf
12:59:11 <lambdabot> Data a => a -> Int
12:59:12 <mekeor> @src Bound
12:59:13 <lambdabot> Source not found. Wrong!  You cheating scum!
13:00:11 <Rembane> lyxia, mekeor, glguy: Thank you!
13:00:57 <mekeor> @src Bounded -- that's what it's called
13:00:57 <lambdabot> Source not found. Are you typing with your feet?
13:01:17 <xubunto> i like this lambda bot
13:01:37 <mekeor> yes, but i'm too stupid to use it
13:02:05 <xubunto> it is a sassy bot
13:02:06 <xubunto> :D
13:02:45 <lyxia> mekeor: doesn't bounded only allow you to count values?
13:06:03 <Cale> mekeor: They're roughly like nullary data constructors
13:07:15 <Cale> mekeor: They're just values which can cheaply be compared for equality (though not necessarily ordering)
13:17:02 <okeuday_bak> After base-4.3, using fail "string" :: Either String a causes an error exception, is there an alternative that doesn't create an exception?
13:18:23 <byorgey> okeuday_bak: Left "string" ?
13:19:05 <okeuday_bak> byorgey: yeah, problem #4 at http://blog.ezyang.com/2011/08/8-ways-to-report-errors-in-haskell-revisited/
13:21:26 <byorgey> okeuday_bak: that blog post is from 5 1/2 years ago.  I don't think anyone at all advocates the use of 'fail' these days.
13:21:43 <okeuday_bak> byorgey: k, good to know
13:23:07 <okeuday_bak> byorgey: it seems best to avoid, is there something better than "Either CustomEnumerableType" for code that wants to avoid IO/exceptions, or is that best?
13:30:32 <Zemyla> byorgey: Lots of people use it implicitly in list comprehensions.
13:31:47 <byorgey> Zemyla: that's true
13:36:03 <deech> Hi all, this is a dumb question but how do I write a newline character to a file? I'm trying to write "hello\nworld" but having no success with 'writeFile blah "hello\\nworld", "hello\\\nworld" or "hello\\\\nworld".
13:36:27 <geekosaur> you wanted the one you didn't try. \n
13:37:03 <AWizzArd> In main (i.e. inside an IO do block) I would like to call a pure function, which returns a Bool.  What I did was   x <- return (myFn data)     and in the next line I had to putStrLn x, so that it would actually get evaluated.
13:37:03 <deech> That saves it as "hello <actual-newline> world"
13:37:18 <deech> I want "hello\nworld".
13:37:27 <geekosaur> \\n
13:37:33 <AWizzArd> Can I call myFn in a way that it *does* get evaluated, but the result will be thrown away?
13:37:47 <deech> That gets me "hello\ <actual-newline> world".
13:37:56 <geekosaur> that sounds very wrong
13:38:02 <AWizzArd> (I just want to time it via getCPUTime)
13:38:08 <mekeor> ddeech: try "
13:38:08 <mekeor> "
13:38:14 <geekosaur> > "hello\\nworld"
13:38:17 <lambdabot>  "hello\\nworld"
13:38:28 <geekosaur> > text "hello\\nworld"
13:38:31 <lambdabot>  hello\nworld
13:38:55 <mekeor> > show "hello\\nworld"
13:38:58 <lambdabot>  "\"hello\\\\nworld\""
13:39:00 <geekosaur> AWizzArd, what you wrote was the same as "let x = myFn data" and neither one forces evaluation
13:39:14 <geekosaur> "let !x = myFn data" will force at least partial evaluation
13:39:28 <AWizzArd> geekosaur: okay, I will give this a try, thx
13:39:47 <geekosaur> you may need an extension (BangPatterns)
13:42:23 <geekosaur> AWizzArd, also, timing stuff in Haskell is really hairy because of laziness.You want to look at the criterion package.
13:42:36 <geekosaur> it deals with most of the hairy edge cases
13:43:04 <AWizzArd> geekosaur: yes of course, true benchmarking is what is really the right way to go here. But in this case my goal is to simply play around with basic newbie Haskell stuff
13:43:33 <geekosaur> right, but the edge cases caused by laziness are bad enough that criterion is really needed even for basic/quick timings
13:43:46 <geekosaur> that was originally why it was written
13:44:04 <geekosaur> not benchmarking, just handling all the edge cases
13:44:47 <AWizzArd> Makes sense. In my case here it’s okay though, because I am not really very interested in the timings and don’t need accuracy.
13:44:55 <AWizzArd> Just trying to get ideas to compile.
13:47:07 <geekosaur> (it was like 2 weeks of discussion and tinkering on -cafe to get a "quick timing" to work, followed by someone collecting the result and making a package out of it. laziness is not the friend of timing)
13:47:44 <AWizzArd> (-:
13:48:00 <AWizzArd> https://tech.channable.com/posts/2017-02-24-how-we-secretly-introduced-haskell-and-got-away-with-it.html
13:57:26 <contiver> I´ve seen unsafePerformIO mentioned many times, but never had to deal with it till now.
13:57:55 <contiver> In the compress function here (at the bottom) https://github.com/ananthakumaran/hopfli/blob/master/src/Codec/Compression/Hopfli/Raw.hsc , would it be better to return IO Bytestring?
13:58:58 <contiver> I didn't write the code, but since I'm maintaining it, I thought I'd ask.
13:59:19 <okeuday_bak> is there a helper function in haskell somewhere that takes a single argument and doesn't do anything with it?
14:00:12 <exio4> okeuday_bak: const ()
14:00:17 <exio4> okeuday_bak: id?
14:00:24 <exio4> okeuday_bak: tell us the type signature you want :)
14:01:05 <okeuday_bak> exio4: yeah, good point, thanks
14:02:37 <hpc> contiver_: it's common for things that operate close to foreign imports to use unsafePerformIO
14:02:48 <hpc> contiver_: think of it as building a pure interface around impure code
14:03:03 <Cale> contiver: It's debateable. You'd sort of expect that compress is a pure function, so probably unsafePerformIO is okay there.
14:03:12 <hpc> there's a high bar to meet as far as ensuring that it is actually pure
14:03:14 <okeuday_bak> exio4: let f = (\x -> x) would be all I would want, just wondering if there is some standard definition somewhere, that should accept any type, right?
14:03:19 <hpc> but it might be worth the effort for something like this
14:03:23 <jle`> okeuday_bak: f is 'id'
14:03:28 <jle`> @src id
14:03:28 <lambdabot> id x = x
14:03:29 <hpc> people like being able to compress data at will ;)
14:03:35 <okeuday_bak> jle`: k, thanks
14:03:48 <Cale> Yeah, it's hard to know that the external libraries you're relying on really do produce a deterministic result.
14:04:12 <Cale> But if you can ensure that, it's nice to be able to let this be a function ByteString -> ByteString
14:04:48 <geekosaur> pedantry alert, you likely want unsafeLocalState (which skips some unnecessary cross-thread locking relative to unsafePerformIO)
14:05:32 <contiver> Cale, hpc: thanks for the answers, I think I'll leave it like that then.
14:05:59 <contiver> geekosaur, hadn't heard of that function, I'll keep it in mind :)
14:06:19 <geekosaur> the FFI spec defines it
14:06:23 <hpc> "It is expected that this operation will be replaced in a future revision of Haskell"
14:06:48 <hpc> unsafeLocalState = unsafeDupablePerformIO
14:07:04 <hpc> (in ghc)
14:08:06 <contiver> hpc: yeah, just read that. I guess it's deprecated (or will be)?
14:08:55 <hpc> deprecation warnings are red
14:09:06 <hpc> this seems more like a volatile api or something
14:09:22 <Cale> I'm not sure I'd use unsafeDupablePerformIO for that
14:09:50 <Cale> While it's probably safe if the IO gets duplicated, you're duplicating a potentially rather expensive operation.
14:10:22 <ertes> monochrom: BTW, i didn't have a satisfying experience with any of the proof systems i tried so far =/
14:10:49 <ertes> i saw one project to implement such a system in haskell, but it seemed abandoned
14:11:13 <contiver> If I may ask, what's the difference between the two? (unsafePerformIO and unsafeDupablePerformIO)
14:11:38 <geekosaur> unsafePerformIO adds locking to ensure two threads don;t run it at the same time
14:12:05 <geekosaur> which is necessary if you are working with the I/O manager, but not for most FFI calls
14:12:08 <Cale> With unsafeDupablePerformIO, there's a few cycles during which if more than one thread starts evaluating the same thunk, both may perform the entire evaluation.
14:12:45 <Cale> I would recommend just sticking with unsafePerformIO almost always.
14:13:17 <geekosaur> for pure code, if two threads hit an unevaluated thunk at the same time, we  let both evaluate it even though they will duplicate work; the cost of locking to prevent it is almost always higher than just letting it hapen
14:13:30 <Cale> It really depends
14:13:41 <geekosaur> (that was tested in one ghc release and removed after it caused major slowdowns)
14:14:16 <Cale> If the IO action is doing something nontrivial, then the locking might be quite inexpensive.
14:14:17 <geekosaur> sometime in 6.6 or 6.8 series iirc
14:14:35 <hpc> yeah, compressing data is a big operation
14:14:35 <geekosaur> but for IO locking is done because the I/O manager isn;t 100% reentrant
14:14:48 <hpc> especially (as one often does) when compressing gigs of data
14:15:15 <contiver> so if I were to use unsafeDupablePerformIO, it would on average be faster, but from time to time the bytestring might be compressed by two threads?
14:15:19 <Cale> yeah
14:15:45 <geekosaur> and unsafePerformIO allows entry to the I/O manager without the normal checks. so it does extra locking, and unsafeDupablePerformIO avoids that when you don;t need to care about that (non)reentrancy
14:16:36 <geekosaur> contiver, I said with pure code. for calling into C to do compression, that's different and you do need to think about how long it will run and whether it's worth doing the extra locking or not
14:16:58 <geekosaur> but you asked what the difference between the two was
14:19:03 <contiver> geekosaur, and I appreciate your answer :) I guess I'll stick to unsafePerformIO, if you are using Zopfli to compress you probably don't care about a couple more seconds.
14:19:14 <geekosaur> it will rarely be that much
14:19:25 <geekosaur> maybe if you call it a million times it;d add up to that
14:46:29 <okeuday_bak> when using https://hackage.haskell.org/package/binary-0.8.4.1/docs/Data-Binary-Get.html the usage of function runGetOrFail will somehow return the string fed to the fail function in the Left data, right?
14:47:15 <geekosaur> that sounds like the wrong way of thinking about it
14:47:23 <geekosaur> Either is what the name says
14:47:27 <okeuday_bak> or does the exception not get caught at that level?
14:47:31 <geekosaur> it is Either the Left or the Right, it is never both
14:48:37 <geekosaur> the error message from `fail` should be the String element of the tuple
14:48:47 <okeuday_bak> k
14:48:57 <geekosaur> (3rd element)
14:52:30 <MarcelineVQ> ertes: http://lpaste.net/353218
14:56:59 <ertes> MarcelineVQ: this may sound like nitpicking, but you really need to be precise here: "for all naturals n, there exists some natural number k such that n = k*2"
14:57:06 <ertes> counterexample: 1
14:57:52 <ertes> instead you need to define what it means when you say "n is even", which is a definition: "n is even" is the same statement as "…"
14:58:09 <geekosaur> ...and this is why most people don't include proofs...
14:59:30 <ertes> MarcelineVQ: however, without nitpicking too much on your syntax, your actual proof is fine, so congratulations =)
15:00:11 <ertes> if you're more rigorous about your syntax, a proof assistant would accept your proof (assuming that you have already proved distributivity)
15:07:22 <MarcelineVQ> that's good, thank you. that rule was more precise before, I flubbbed it when combining lines it looks like. actually I had another issue where I couldnt decide whether to be specific enough to say, "for every even natural n there exists exactly one natural k such that n = k*2" or whether I could ignore that since it'd be a consequence of them being natural numbers, sort of like how having to define distributivity would need its 
15:07:22 <MarcelineVQ> own proof that I'm not sure how to tackle
15:08:58 <MarcelineVQ> I can certainly see why, if you need to show every part, proofs would get prety big. Also this shows to me that a proof is only as good as the assumptions you're making, we start this of by saying what even means to us, but who knows, maybe at n = 1000000000 suddenlty even stops being true.
15:10:58 <ertes> MarcelineVQ: in mathematics you generally don't prove every detail…  instead you refer to theorems, i.e. things that have already been proven
15:11:05 <ertes> sort of like you use libraries in programming
15:11:19 <ertes> when using a proof assistant those things literally become libraries =)
15:12:06 <ertes> distributivity is surprisingly complex to prove from scratch (not difficult, just very tedious)
15:29:22 <hrumph> it'hi
15:29:23 <hrumph> hi
15:29:34 <hrumph> what do i have to include to have MonadTrans available?
15:34:13 <johnw> Hoogle will tell you
15:34:41 <hrumph> i tried control.monad.trans but it's not available
15:34:55 <hrumph> should i install haskell-platform or something?
15:35:35 <johnw> https://www.haskell.org/hoogle/?hoogle=MonadTrans
15:38:53 <ertes> does the lens library provide a generalisation of splitAt to arbitrary sequence types?
15:39:58 <glguy> no
15:40:08 <ertes> ok, thanks
15:50:47 <Squarism> what am i doing wrong here : http://lpaste.net/353220
15:51:31 <glguy> You're using createGameServerInstance as a record selector
15:55:19 <glguy> Squarism: To understand why that's an issue, consider what type createGameServerInstance would need to have to exist
15:58:40 <Squarism> glguy, well atm they could be anything
15:59:06 <glguy> I mean actually try to write the type
15:59:23 <glguy> like createGameServerInstance :: GameLauncher -> ?
16:02:02 <Hafydd_> class GameServerInstanceCreatorFactory where
16:03:40 <Squarism> createGameServerInstance :: forall m1 m2 . IO (GameServerInstance m1 m2) ?
16:04:48 <Squarism> i know im on thin ice here, but im trying to learn
16:17:19 <byorgey> Squarism: the problem is that GameLauncher existentially hides the types m1 and m2.  Once you put an  IO (GameServerInstance m1 m2)  inside a GameLauncher, you can never get it back out, because you don't know what the types m1 and m2 are anymore
16:17:50 <glguy> Squarism: That's a close guess, but it would mean that the user createGameServerInstance got to pick m1 and m2
16:18:56 <glguy> similar to how the user of 'id :: a -> a' get to pick a
16:19:07 <glguy> id :: forall a. a -> a
16:19:20 <glguy> the forall is implicit in Haskell type signatures
16:20:29 <Squarism> glguy, ok. i get that idea. 
16:20:47 <Squarism> byorgey, hmm.. trying to digest what you said
16:23:45 <Squarism> glguy, yes. Well i dont want the user of that function to decide that no.
16:27:37 <Squarism> woho. I got it to compile
16:28:01 <abhiroop> When working with Haskell STM, I know it initializes a thread local transaction log
16:28:03 <Squarism> pattern matching gl
16:28:20 <abhiroop> Can anybody tell me what data structure is this transaction log?
16:28:37 <abhiroop> I was trying to look for the code here : http://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Conc.Sync.html#atomically
16:28:47 <abhiroop> but couldn't find much
16:29:14 <glguy> Squarism: GOod work!
16:32:12 <monochrom> abhiroop: It may be in the source code of the runtime system instead.
16:32:48 <fryguybob> abhiroop: I can fill you in on details about STM if you want.
16:34:36 * hexagoxel tries to tie a knot using a continuation, but creates a knot in his brain instead.
16:35:40 <hexagoxel> is a double-continuation ever a solution? :S
16:36:45 <monochrom> It may comfort you to know that Cont cannot be a MonadFix instance.
16:40:05 <Guest55569> anyone know why I'd be getting "YAML parse exception at line 0, column 0: control characters not allowed" in stack.yaml?
16:40:24 <Zemyla> You know, I think I've figured out how to turn unstableSort in Data.Sequence into a stable sort.
16:40:47 <monochrom> You have control characters at line 0, column 0. The beginning. Use a hex editor to examine. Editors lie.
16:40:52 <Guest55569> e.g. using the example configuration of GHCJS + stack
16:40:55 <Guest55569> ok, thanks
16:40:57 <monochrom> Trust only hex editors.
16:48:20 <Guest55569> @monochrom dunno, looks like there's nothing there
16:48:20 <lambdabot> Unknown command, try @list
16:49:13 <Guest55569> monochrom dunno, looks like there's nothing there
16:50:08 <monochrom> Then I don't know.
17:08:04 <geekosaur> Guest55569, windows? text editors often hide byte order marks, which some editors (including some versions of notepad) stick on the front to differentiate utf8 from iso8859 or other single-byte code page content
17:08:32 <geekosaur> notepad++ is usable and a fairly big improvement if you've been using notepad.exe
17:11:17 <Guest55569> geekosaur, I am running stack from a linux VM on windows
17:13:39 <Guest55569> notepad++ doesn't see anything weird, just LFs
17:15:49 <Guest55569> geekosaur ended up just saving it another file and it works, must be some kind of encoding issue.  thanks.
17:18:02 <sanjoyd> Is there a way I can introduce a "scoped" type alias in Haskell?  I.e. "type Name = String" but only limited to a specific function?
17:18:07 <sanjoyd> s/function/lexical scope/
17:18:16 <ezyang> sanjoyd: No, sorry :( 
17:18:36 <sanjoyd> ezyang: thanks!
17:26:33 <Squarism> The final part of the puzzle im onto. How to put one existential type into a existentially typed Map?  http://lpaste.net/353224
17:27:24 <Squarism> ...it would involve aligning 2 unknown types and i just dont feel i have a wild guess on how
17:37:46 <glguy> Squarism: You don't
17:38:20 <Squarism> Hm ok. So this approach wont work?
17:49:48 <Squarism> What i. Have per-game type parameterized "GameServerInstance m1 m2". The hard part is storing these values (of different type arguments) together in an MVar
17:50:06 <Squarism> gah
17:50:35 <Squarism> correction 
17:50:36 <Squarism> What I want to accomplish is having per-game typ parame....
18:02:58 <ertes> Squarism: without going through all of your code: the dependent-map library might be interesting
18:03:19 <ertes> it allows value types to be given by the key
18:04:33 <Squarism> oh ok
18:09:06 <okeuday_bak> If you use runPutM from https://hackage.haskell.org/package/binary-0.8.4.1/docs/Data-Binary-Put.html how is the result of type a provided?
18:24:12 <Squarism> Just a hint - in 25 lines of java code what i want to accomplish in haskell : http://lpaste.net/353225
18:24:14 <Zemyla> Okay, so this typechecks, but what the heck does it represent?
18:24:19 <Zemyla> :t ContT mfix
18:24:21 <lambdabot> MonadFix m => ContT a m a
18:26:23 <ertes> Squarism: too much noise…  what does that code do that appears difficult to do in haskell?
18:27:55 <Squarism> ertes, the hard part is having an MVar that accepts map elements of a type with different type arguments
18:28:10 <ertes> Squarism: explain the problem, not the solution
18:29:24 <ertes> in other words: explain what you're trying to do without using the words "MVar", "Map" or "type"
18:31:05 <Squarism> the problem is storing a map of GameServerInstance m1 m2 - where m1,m2 can be different for different keys + retrieving values from the same map with their original type arguments
18:31:17 <ertes> you're still explaining the solution
18:33:15 <Squarism> problem - i want to be able to store and retrieve  parameterized type values - where type parameters can be different.
18:33:47 <Squarism> cannot put it any shorter than that
18:34:34 <ertes> no, that's still part of the solution…  you seem to be trying to translate a java solution to a problem into haskell, which is a recipe for sadness…  what *problem* does it solve?  just pretend that i'm not a programmer, then explain what you're trying to achieve
18:35:04 <ertes> you want your program to do *something*…  what?
18:37:49 <Squarism> remember my game. It mutated to become driven by messages. In and out messages. I have working thread / network code for it and all. Now i want to generify that code to accept games of different messaging models. Each game has its own in and out message types.
18:38:52 <ertes> do the games communicate with each other, or are you just trying to run multiple servers in a single application?
18:39:18 <Squarism> The server kept a store of games (in an MVar) that relied on these messages - thats dependency needs to go imho.
18:39:46 <Squarism> no the games do not communicate
18:39:57 <ertes> what's the map for?
18:40:45 <Squarism> keeping track of : gameid <-> (channels involved in a game)
18:40:56 <Squarism> ...that is used for lookup when clients connect
18:41:13 <Squarism> ...so the right channels are given to them'
18:41:22 <ertes> a client connects…  how does the server know which game to associate it with?
18:41:44 <Squarism> client connects with a gameId. 
18:42:34 <ertes> so in principle all your map needs to contain is a mapping from game ids to whatever mechanism is necessary for the game server to communicate with the client
18:42:51 <ertes> in particular it doesn't need to know the precise message type…  all it needs to know is how to encode/decode
18:42:52 <Squarism> yep
18:43:04 <Squarism> well
18:43:25 <ertes> so the map is really a map to encoders and decoders, not to a "game instance"
18:43:35 <Squarism> yes
18:43:49 <Squarism> encoders/decoders that is
18:44:07 <ertes> insisting on a concrete manifestation of "game instance" is an OO concept…  you may want to get rid of that habit =)
18:44:32 <Squarism> ill think of that =D
18:47:17 <ertes> try to think less in "objects" or "instances"…  think in terms of behaviours…  and don't insist on uniform representations…  for example a "player" doesn't have to be (and perhaps shouldn't be) an value of type Player; it may manifest differently depending on context
18:47:56 <ertes> in a map of all currently active game objects, it may manifest simply as something with a position and a rendering function
18:49:41 <Squarism> What i refered to as GameServerInstance is really 2 types of channels. 1 to game, N to players.
18:50:24 <Squarism> both type parameterized depending on game implementation
18:56:03 <ertes> why do you need a message type to begin with?
19:01:54 <Squarism> It felt natural when i had just one game. Played well with AEson to/from json. Plus both in and out messages could be of "control" messages that needed to be inspected in networking/game loop.  
19:02:42 <Squarism> But i understand what you mean. I could delegate decoding / encoding to games themselves
19:03:04 <Squarism> and have one generic message type for all games
19:03:11 <Squarism> doable
19:03:14 <Squarism> maybe
19:03:48 <srk> yeah. I'm trying similar thing
19:04:31 <srk> I have plain text messaging implemented that I want to combine wih serialization 
19:04:57 <srk> so nodes can use any protocol over that
19:11:54 <Squarism> ertes, thanks for taking your time. As i have no better ideas ill persue that
19:48:19 <NeverDie> Hey if anyone's interested, there's an FP Discord server up as well: https://discord.gg/FvT2Y5N
19:49:37 <glguy> We're good, thanks though
19:51:05 <pacak> NeverDie: What's wrong with irc?
19:51:16 <NeverDie> Nothing, I use both at the same time.
19:51:21 <pacak> NeverDie: Are there any discord clients that use less than 1Mb memory?
19:51:32 <NeverDie> Not sure why everyone assumes one must be given up to use the other when both can be used together just fine.
20:07:12 <ertes> license says "unfree"…  closed
20:07:57 <ertes> if you're trying to fragment the community even more, at least promote free solutions
20:32:44 <monochrom> When will someone advertise a Facebook group? :)
20:53:45 <lambdafan> can we have dependently typed pairs in haskell?
20:54:16 <ertes> lambdafan: see the dependent-sum library
20:55:00 <lambdafan> nice, thanks :)
20:57:18 <lambdafan> perfect!
21:37:46 <eklavya> what is ~() here   "~(f, s') <- mf s" ?
21:39:51 <eklavya> if this is not something in the syntax
21:39:56 <eklavya> context: 
21:40:00 <eklavya> StateT mf <*> StateT mx = StateT $ \ s -> do
21:40:00 <eklavya>         ~(f, s') <- mf s
21:40:01 <eklavya>         ~(x, s'') <- mx s'
21:40:02 <eklavya>         return (f x, s'')
21:43:23 <S11001001> eklavya: it means, don't force the tuple as part of pattern matching; instead, that f x gets turned into (fst theFirstTuple) (fst theSecondTuple)
21:43:57 <eklavya> S11001001: sorry, not getting you
21:44:01 <S11001001> eklavya: https://en.wikibooks.org/wiki/Haskell/Laziness#Lazy_pattern_matching
21:44:18 <eklavya> S11001001: thanks :) let me read that
21:51:52 <geekosaur> pattern matching normally forces immediate evaluation in order to see if the value matches. a lazy pattern match instead defers that evaluation like any other lazy evaluation
21:52:12 <geekosaur> (evaluation only to the extent needed to see if the pattern matches)
22:19:31 <Wizek> Hey! Anyone here who has experience with setting up reflex(-dom) with stack (and hopefully without involving nix)?
22:20:00 <Wizek> I've tried with lts-6.30 and I got a compile-time type error related to the cairo package
22:20:16 <Wizek> completely fresh start with `stack new`
22:20:59 <dymatic> No experience with the stack, sorry Wizek. What kind of type error is it?
22:21:37 <Wizek> sec, pasting it somewhere
22:23:37 <Wizek> dymatic, https://gist.github.com/Wizek/b2af32bd9d4aa1486dac5a93f5d0c2e6
22:26:29 <dymatic> Damn that doesn't seem right
22:27:02 <dymatic> If this is going through cabal and still giving you that error, someone's package file somewhere is goofed
22:27:13 <dymatic> Or some version of something (maybe cabal) is out of whack
22:28:17 <Wizek> dymatic, Yes, afaik stack uses cabal-install underneath
22:28:40 <Wizek> I have a hunch that I might need to specify to use GHCJS instead of GHC somewhere.
22:28:49 <geekosaur> not quite but it does use the Cabal library underneath
22:29:02 <geekosaur> this looks like there is a mismatch of Cabal versions somewhere
22:29:39 <dymatic> Maybe even try a "cabal install cabal"
22:39:56 <lispy> I think you mean Cabal
23:04:33 <mbw> Hello, I have another question about the FFI. According to https://ghc.readthedocs.io/en/8.0.1/ffi-chap.html#memory-allocation, among the functions in Foreign.Marshall.Alloc, alloca should be used when possible. However, the documentation on this (and similar functions like allocaArray) is not really exhaustive. Does alloca have anything to do with alloca from <alloca.h>? If so, can I assume it is not 
23:04:39 <mbw> portable and I an blow out the stack?
23:05:00 <mbw> *can
23:31:56 <cocreature> mbw: afaik it has nothing to do with alloca.h. it allocates on the heap and is portable
23:32:18 <cocreature> but I might be wrong here
23:33:13 <mbw> I tried it with 5000 doubles, which should've given some indication if it really was using alloca.
23:34:13 <mbw> oh wait
23:35:26 <mbw> That's only 39kb. Still, it should be easily checkable if I go over 8192kb.
23:36:04 <mbw> At least that's the stack size limit on my machine
23:36:25 <mbw> But probably, if this function was in any way dangerous, there would probably be a warning.
23:38:18 <glguy> alloca from C is different from GHC
23:42:35 <recur22> why every haskell library has to be special and has its own unique DSL?
23:43:46 <recur22> unnecessary monadic
23:48:15 <recur22> i'm looking haskage trying to find good library for teaching but all i can find is either bindings or unnecessarily verbose package
23:53:41 <mbw> Is it a convention that Haskell array code is done using indices starting at 1? I get the impression from the tutorials I've been looking at.
