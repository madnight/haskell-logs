00:11:01 <spatial> randommove ::  BoardState -> IO Int How do I print inside If the signature is this ?
00:12:19 <srhb> spatial: I'm thinking you're working in a do block. Just be aware that it cannot be the final action (because its type is IO (), not IO Int) - but other than that, you can just putStrLn "whatever"
00:13:00 <spatial>  let possibles = possiblemoves state in     case possibles of       p ->    fmap (p !! ) $ randomRIO(0, length p - 1)   
00:13:08 <srhb> spatial: That is, this is perfectly valid: randommove bs = do { putStrLn "foo"; return 42 }
00:16:08 <mac10688> I'm looking at reactive-banana examples
00:16:10 <mac10688> https://github.com/HeinrichApfelmus/reactive-banana/blob/master/reactive-banana/doc/examples/SlotMachine.hs
00:16:31 <mac10688> on line 107-109 there are functions or variables referenced
00:16:33 <mac10688> I'm not sure which
00:16:50 <mac10688> addCredit, removeCredit, addWin that I can't find in scope
00:17:03 <mac10688> they are defined in a let clause later in the function
00:17:22 <mac10688> is that the ones I'm seeing because that looks like it's out of scope
00:17:41 <MarcelineVQ> the key is that the first line is mdo
00:18:02 <MarcelineVQ> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#the-recursive-do-notation
00:18:02 <mac10688> yeah i just saw that for the first time. it's a recursive loop or something?
00:18:15 <MarcelineVQ> it's something quite interesting I've not learned about yet beyond recognising it
00:18:58 <mac10688> thanks MarcelineVQ 
00:19:09 <mac10688> that's good enough. It's bed time. I'll sleep on that
00:21:38 <spatial> I mean in this  p -> fmap (p !! ) $ randomRIO(0, length p - 1)
00:26:12 <halogenandtoast> spatial: what do you want to print?
00:28:54 <spatial> Result of fmap (p !! )
00:30:10 <halogenandtoast> maybe something like: p -> do; res <- fmap (p !!) $ randomRIO(0, length p - 1); print res; res
00:30:19 <halogenandtoast> last thing should be return res
00:34:31 <spatial> p -> debug $ fmap (p !! ) $ randomRIO(0, length p - 1)     I had to do this
00:35:16 <spatial> Something like Aspect Programming for Haskell to weave code instead of that ?
00:52:49 <halogenandtoast> Where does debug come from?
00:53:24 <spatial> Simple function to print and return
00:53:49 <halogenandtoast> ah so you wrote it.
01:14:40 <merijn> ls
01:19:34 <u-ou> ls
01:22:29 <dyreshark> sudo -s
01:39:54 <_sras_> Is there any issues with using WriterT for logging for a web application?
01:46:10 <jle`> WriterT isn't really meant for streaming logging
01:47:03 <jle`> you should probably use a proper logging type instead
01:47:34 <jle`> streaming logging is just not something that WriterT's purpose is even remotely related to
02:10:44 <dmj`> _sras_: I wouldn’t keep a WriterT around throughout the life of the web application. On each request a thread is forked that evaluates your monad stack completely. The monoid you accumulate from WriterT could be used to write to some kind of logging framework, either to disk or external api
02:18:42 <spatial> nextstate :: Player -> BoardState -> Int -> BoardState      IO and non-IO are still confusing. Is there a way to print in that function ?
02:20:27 <spatial> Otherwise I have to debug wherever that function is called.
02:21:16 <Mehdi2277> If I wanted to go about creating an iOS application with swift as the front end and haskell for the logic how should it be done? I've been trying to set up ghc-ios, but have been having trouble.
02:21:56 <_sras_> jle`: I am using Servant web framework. In the example in the Servants manual, the logger only logs the current request. How can I log a custom message from a route handler?
02:23:17 <bartavelle> _sras_, you can use one of the logging libraries, or just 'putStrLn' stuff
02:24:42 <_sras_> bartavelle: Logging libraries for servant? 
02:25:08 <bartavelle> you don't have to use something that's servant related, you are if i'm not mistaken in "ExceptT ServantErr IO"
02:25:16 <bartavelle> so you can liftIO anything that's IO
02:25:22 <bartavelle> gimme a sec
02:26:10 <bartavelle> that was for an old servant version : http://hbtvl.banquise.net/posts/2015-06-28-servantintegration.html
02:26:28 <bartavelle> but you can see that I can run "SqlPersistT (LoggingT (EitherT ServantErr IO)) a" in the handlers
02:26:59 <bartavelle> for this instance, you can just wrap your logic into the LoggingT transformer and you're done
02:28:20 <dmj`> _sras_: there are functions to help you log from Writers, that was the intention of the logWriterT*Nat family of functions
02:28:28 <dmj`> w/ servant, in servant-server
02:28:30 <dmj`> logWriterTLNat :: MonadIO m => (w -> IO ()) -> (:~>) * (WriterT w m) m
02:29:01 <bartavelle> oh wow
02:29:09 <dmj`> so you can keep a WriterT in your stack, and inside the natural transformation, unwrap it to Handler a, but log while doing so
02:29:18 <dmj`> bartavelle: yea, the lesser known parts of servant :)
02:30:23 <_sras_> dmj`: I am using a custom monad and use the"Nat" stuff to work with the servants Monad. Is this what you are trying to say?
02:30:53 <bartavelle> apparently with any monad
02:31:02 <bartavelle> that's MonadIO
02:32:48 <dmj`> _sras_: yea, if you add WriterT to your stack (might also want to derive MonadWriter YourMonoidGoesHere) then in the Nat function, you’d use logWriterTLNat when you hit the WriterT of wrapping, and supply some (w -> IO ())
02:33:44 <dredozubov> is it possible to supply a heap volume threshold to RTS after which the GC sweep comes in?
02:34:18 <dredozubov> i have to use -H to do that, but it seems like it can lead to heap bloating in some cases
02:43:44 <_sras_> dmj`: http://lpaste.net/7590969248134987776  this is my current setup. I just throw away the writer's log.
03:02:56 <ph88^> how can i make this little piece of code more clean? https://bpaste.net/show/1a35034bc254
03:06:43 <ongy> ph88^: I think 2 matches would look a bit cleaner, so first match on the input then get the output action (or the other way around)
03:07:08 <ph88^> ongy, not sure what you mean with 2 matches
03:11:57 <lpaste_> ongy pasted “for ph88” at http://lpaste.net/353554
03:12:04 <ongy> something like that
03:12:17 <ongy> not sure if I did it all correctly, but I think it shows what I mean
03:13:20 <ph88^> ooh right
03:13:31 <ph88^> thanks ongy 
03:13:54 <ph88^> another question, i was searching for a function with signature  Char -> Word8  but i couldn't find it on hoogle, anyone knows ?
03:14:53 <Rembane> ph88^: Are you working with Bytestrings?
03:14:53 <liste> ph88^: what should it do with chars over 255 ?
03:15:11 <ph88^> yes i work with bytestrings
03:15:35 <ph88^> only chars that can be represented in a single byte are valid
03:15:53 <ph88^> actually this gives me an idea .. i am using optparse-applicative .. so maybe i should just specify Word8 in the first place
03:16:20 <Rembane> ph88^: Use the variant of the ByteString library that works best for you.
03:16:50 <Rembane> ph88^: This one for instance: https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString-Char8.html
03:17:53 <ph88^> Rembane, there is no Char -> Word8 function there
03:18:16 <ph88^> i have this piece of code   padding = lazyByteString $ B.take (size - B.length rest) $ B.repeat padByte
03:18:26 <ph88^> padByte type is wrong at the moment
03:18:40 <ph88^> i'm trying to make a bytestring builder
03:19:56 <Rembane> ph88^: You don't need the Char -> Word8 function if you use Data.ByteString.Char8 instead of Data.ByteString.
03:20:33 <ph88^> is that compatible with the builder ?
03:20:52 <Rembane> ph88^: Your builder?
03:21:29 <ph88^> Module ‘Data.ByteString.Char8’ does not export ‘repeat’
03:21:48 <ph88^> :/
03:23:04 <Rembane> ph88^: Which Bytestring module exports repeat? I can't find it.
03:23:13 <ph88^> Rembane, i mean with the builder   lazyByteString :: ByteString -> Builder
03:23:27 <ph88^> Rembane, https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString-Lazy.html#v:repeat
03:23:51 <Rembane> ph88^: https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString-Lazy-Char8.html#v:repeat
03:24:13 <Rembane> ph88^: The lazy bytestring equivalent of what I said. :)
03:25:47 <ph88^> it type check now, thaks Rembane 
03:27:11 <Rembane> ph88^: No worries. The ByteString modules are a jungle. :)
03:29:22 <ph88^> ongy, from your idea i made this https://bpaste.net/show/8488bd735c4a
04:14:15 <spatial> Trying to print and it isn't possible . http://lpaste.net/353557
04:14:32 <spatial> IO doesn't mix
04:14:49 <spatial> What is the usual way ?
04:21:25 <ongy> spatial: that looks like a type error to me
04:21:46 <spatial> No
04:21:52 <ongy> 'mapM_ (putStr . show) xloc' shouldn't expect another argument
04:22:14 <spatial> Just added mapM to check.
04:22:36 <ongy> does that exact thing you pasted compile? if so, what would you expect it to do, and what does it do?
04:23:53 <spatial> mapM doesn't mix with the function. Removed.
04:25:11 <spatial> nextstate  player (BoardState xloc oloc index) move=   BoardState newx newo newindex where
04:25:30 <spatial> Introduce trace here. How ?
04:26:28 <ongy> there's Debug.Trace which exports trace (or if you have a show instance, probably nicer to use traceShowId)
04:30:03 <spatial> How does that function change ? Not a Haskell expert yet
04:30:38 <ongy> nextstate  player (BoardState xloc oloc index) move= traceShowId $ BoardState newx newo newindex where -- It should work like this
04:30:55 <ongy> also don't expect it to work exactly as you think, this is sill subject to lazyness
04:31:25 <spatial> trace "log" $  BoardState newx newo newindex where
04:32:44 <spatial> ongy:It worked with show
05:12:23 <doubling_> hello. Are any haskell maintainers here
06:01:42 <_sras_> is there a function similar to intercalate that uses monoid instances?
06:05:17 <merijn> :t intercalate
06:05:19 <lambdabot> [a] -> [[a]] -> [a]
06:05:31 <merijn> _sras_: Well, what would that do?
06:05:41 <liste> :t intersperse
06:05:43 <lambdabot> a -> [a] -> [a]
06:06:09 <merijn> I'm not sure how "monoid instances" would related to what intercalate does?
06:06:21 <Taneb> I presume Monoid m => m -> [m] -> m
06:06:25 <liste> @hoogle Monoid m => m -> [m] -> m
06:06:26 <lambdabot> BasicPrelude intercalate :: Monoid w => w -> [w] -> w
06:06:26 <lambdabot> Clay.Property intersperse :: Monoid a => a -> [a] -> a
06:06:26 <lambdabot> Language.PureScript.Docs.Utils.MonoidExtras mintersperse :: (Monoid m) => m -> [m] -> m
06:06:43 <lyxia> intercalate x [a,b,c] = mconcat [a, x, b, x, c]
06:06:47 <merijn> Well, isn't that just "mconcat . intersperse"?
06:07:08 <_sras_> merijn: Got it. intercalate in https://hackage.haskell.org/package/string-combinators-0.6.0.5/docs/Data-String-Combinators.html
06:07:59 <merijn> huh
06:08:05 <merijn> That's a super confusing type
06:11:06 <tabaqui1> there are some api functions in signals library
06:11:12 <tabaqui1> f.e
06:11:19 <tabaqui1> sigint :: CIint
06:11:28 <tabaqui1> siging = 2 -- I guess
06:11:40 <tabaqui1> and I cannot use this symbols in pattern matching
06:11:47 <merijn> That's not a function
06:11:51 <merijn> That's just a variable
06:12:04 <tabaqui1> hm, ok
06:12:08 <merijn> And no, you can't pattern match identifiers
06:12:34 <tabaqui1> only with basic data constructors?
06:12:42 <tabaqui1> no aliases?
06:13:10 <merijn> There's no notion of aliases in the language
06:13:42 <tabaqui1> but ghc can extract actual value, stored in sigint
06:14:30 <tabaqui1> or I cannot see possible issues
06:14:43 <tabaqui1> or there is no issues
06:14:46 <merijn> tabaqui1: Well, sigint could be an arbitrary expression, so how would it do that?
06:15:22 <tabaqui1> merijn: ghc could evaluate pure expression
06:15:54 <merijn> tabaqui1: That can take arbitrarily long, people already think GHC compilation takes too long
06:16:14 <tabaqui1> in runtime I mean
06:16:34 <Tuplanolla> You know guards do that, tabaqui1.
06:16:43 <merijn> tabaqui1: THen you could just use a guard using ==
06:17:02 <tabaqui1> yeah, I could but prefer case notation
06:17:37 <tabaqui1> I mean ghc *can* do such things
06:17:43 <lyxia> pattern SigInt = 2    case signal of SigInt -> ...
06:17:44 <tabaqui1> and there will be no collisions
06:17:58 <riaqn> Hello, is graph reduction in haskell optimal? (in levy's sense)
06:18:03 <merijn> lyxia: That requires modifying the library and isn't compatible with old versions
06:18:16 <lyxia> :(
06:18:34 <tabaqui1> ah, ok
06:18:36 <tabaqui1> I get it
06:19:22 <riaqn> say, f x y = (8 + x) * y, and g = f 9, and (g 10) and (g 11) will involve two computations of (8 + 9) I guess?
06:19:23 <tabaqui1> ghc doesn't know, must he compare it with existing variable, or bind it as a local var
06:19:48 <tabaqui1> *it compare
06:20:55 <lyxia> riaqn: that depends on the implementation
06:31:02 <riaqn> lyxia:sure it does. But what about ghc?
06:33:13 <riaqn> I can imagine that compiler can transform the program to f = \x -> (\s y ->  s * y) (8 + x), so this won't be a problem anymore.
06:33:16 <erisco> I don't know the answer, but I would be concerned if it always did this
06:33:42 <erisco> addition is cheap, whereas having separate functions for every g x would be pricey
06:33:49 <riaqn> but I think that couldn't achive the same level of sharing as "optimal reduction"
06:34:13 <Tuplanolla> The catch is that maximal sharing isn't optimal in practice, riaqn.
06:34:14 <erisco> if there is no substantial reduction I would not want it to do this
06:34:57 <riaqn> Tuplanolla: Yeah I read that a lot on internet.
06:35:10 <Tuplanolla> Here's evidence.
06:35:22 <Tuplanolla> :t Data.Vector.force
06:35:25 <lambdabot> Data.Vector.Vector a -> Data.Vector.Vector a
06:35:34 <riaqn> Tuplanolla: some even says that, optimal reduction on fibonacci achieve something similar to memorization.
06:35:48 <riaqn> which is expensive, and certainly not expected by programmers.
06:36:20 <Tuplanolla> That function is `id`, but breaks sharing internally.
06:37:33 <riaqn> OK. so I guess the sharing level of "call by need" is the balance point.
06:37:49 <riaqn> together with weak head normal form.
06:38:07 <Tuplanolla> As long as we have finite memory...
06:38:25 <erisco> and finite bandwidth
06:38:31 <riaqn> Tuplanolla: so it's common for optimal reduction to use much more memory?
06:38:44 <riaqn> wow wasn't expecting that.
06:38:45 <Tuplanolla> I don't know about common, but that's what happens here.
06:40:43 <riaqn> Tuplanolla: OK, thanks!
06:51:55 <robertkennedy> How can I get ghci to actually store big variables? Ie `let s = takeWhile (< 100000) $ dropWhile (< 90000) primes`
06:52:12 <robertkennedy> Then if I run length s twice it takes a long time
06:54:12 <erisco> the second as long as the first?
06:55:56 <erisco> it does have to count the list twice, and it will have something like 4000 elements, so it will take some time ("long time" isn't a number so I don't know what we're referencing)
06:56:41 <robertkennedy> Oh no it's clearly regenerating s both times
06:57:30 <robertkennedy> I checked via length [1..10000], which is quick enough. 
06:58:29 <erisco> maybe it is a REPL thing? I don't know
07:01:18 <tdammers> let s = primes `seq` takeWhile (< 100000) (dropWhile (< 90000) primes) -- maybe this helps?
07:01:45 <tdammers> or rather, you probably want to even force `s` in the context where you're taking the length twice
07:01:53 <tdammers> not sure though
07:01:56 <tdammers> might wanna profile?
07:03:19 <erisco> if the REPL works by re-evaluating from the top then this makes sense (and assuming you are using the REPL)
07:03:46 <merijn> The general rule is: Don't rely on ghci for ANYTHING relating to optimisations and performance
07:03:50 <erisco> what if you try (length s, length s) ?
07:04:39 <erisco> there are libs that run like crap in the REPL too, so watch out
07:11:20 <lyxia> robertkennedy: what type do you get for s
07:15:06 <merijn> lyxia: Oooh! You might be on to something, lack of MMR in ghci
07:15:46 <erisco> match-making rating?
07:15:55 <cocreature> monomorphism restriction
07:15:57 <merijn> erisco: monomorphism restriction
07:16:36 <merijn> Last time we talked about it people were saying "that never happens and if it did you wouldn't notice it!", but if that's the case here, this might be exhibit A for keeping the MMR always on :)
07:16:55 <merijn> robertkennedy: How did you define primes?
07:17:44 <erisco> is that suggesting s has a polymorphic type and that is why it evaluates twice?
07:17:55 <cocreature> yep
07:17:58 <merijn> erisco: If primes does too, then yes
07:18:11 <erisco> gotta stick in the specialize pragma I suppose
07:18:27 <cocreature> or just specialize manually
07:18:33 <merijn> erisco: Or just use ghc (which would yell at you due to MMR) or add a type signature
07:19:30 <erisco> that's just funny
07:19:47 <merijn> erisco: Well, this is the exact reason why the MMR exists in ghc :p
07:19:52 <erisco> so does (length s, length s) evaluate twice but let t = s in (length t, length t) not?
07:20:05 <merijn> It's not in ghci since it's usually annoying for interactivity
07:20:11 <merijn> erisco: The answer is: unspecified
07:20:37 <merijn> erisco: GHC has CSE (common subexpression elimination), but whether it fires is...not 100% reliable
07:20:41 <Welkin> you mean does s evaluate twice? or does `length s` evaluate twice?
07:20:47 <erisco> s
07:20:52 <erisco> or t, in the second example
07:20:59 <merijn> erisco: So, honestly there's no way to know wheter it evaluates 's' twice or even 'ength s' twice
07:21:17 <merijn> Welkin: Well, GHC is in no way required to evaluate 's' OR 'length s' twice in that example
07:21:39 <Welkin> I would assume that s is evaluated once
07:21:55 <Welkin> because it refers to the same expression/value
07:22:00 <merijn> Welkin: Most people would, which is why we have the MMR :)
07:22:15 <erisco> but it is polymorphic Welkin
07:22:27 <merijn> Although Haskell doesn't require anything, of course
07:22:29 <erisco> so it is different things depending on the chosen type
07:22:55 <Welkin> you mean like is you have (String, Text)?
07:23:09 <merijn> Welkin: No, if 's :: Num a => [a]'
07:23:28 <merijn> Welkin: You can't simply store the evaluation of 's', since it depends on the selected Num instance
07:23:55 <erisco> you can use the specialise pragma, or manually specialise
07:24:09 <erisco> or it could specialise based on found uses
07:24:16 <erisco> or it could even memoise at runtime
07:24:18 <erisco> who knows
07:24:33 <merijn> erisco: Haskell spec doesn't ban using magic to determine the result ;)
07:24:39 <shapr> Type Driven Development! w00!
07:25:14 <tdammers> Compiler Error Driven Development!
07:25:24 <cocreature> stackoverflow driven development!
07:25:25 <erisco> you mean development
07:26:29 <freeside> https://www.jwz.org/images/supercoder-2000-nur-1-und-0-und-done.jpg
07:27:18 <Unhammer> why does it have that "done" key, seems superfluous
07:27:21 <nbro> hi
07:27:35 <erisco> I should show this to people who think programming must be all 0's and 1's
07:27:41 <erisco> yes, this is what I type on every day, you're right
07:27:49 <nbro> I’m trying to understand how to fake "loops" in haskell by using an "auxiliary" function
07:28:06 <merijn> nbro: Usually depends on the kinda loop you're wanting to do
07:28:22 <nbro> I’m just trying to understand the syntax
07:28:25 <tdammers> it's not really fake, there's just two layers of abstractions in between
07:28:33 <freeside> https://hackage.haskell.org/package/loops-0.2.0.2/docs/Control-Monad-Loop.html
07:28:40 <nbro> here you have an example of such a thing for the factorial: https://en.wikibooks.org/wiki/Haskell/Recursion
07:28:51 <nbro> factorial'' n = go n 1
07:28:52 <nbro>     where
07:28:53 <nbro>         go a res
07:28:54 <nbro>             | a > 1     = go (a - 1) (res * a)
07:28:55 <nbro>             | otherwise = res
07:29:01 <cocreature> @where lpaste
07:29:01 <lambdabot> http://lpaste.net/
07:29:12 <cocreature> please paste your code there and send the link here
07:29:44 <freeside> http://dl.acm.org/citation.cfm?id=968579
07:29:50 <nbro> http://lpaste.net/353563
07:30:16 <erisco> understand that that is an exaggerated example. You'd not write factorial like that
07:30:20 <tdammers> nbro: haskell is a pure language, so loops like we can write them in an imperative language with mutable state updates aren't possible
07:30:30 <nbro> erisco: I’m just trying to understand the syntax
07:30:40 <nbro> it doesn’t matter if that’s the best way or not
07:30:44 <tdammers> nbro: the syntax has nothing to do with loops or recursion
07:30:58 <tdammers> nbro: basically all you need to produce a loop is a function that calls itself
07:31:01 <merijn> tdammers: Well, maybe his question is not about loops or recursion :)
07:31:01 <nbro> that’s the way authors are describing it
07:31:03 <erisco> what parts of the syntax do you not understand?
07:31:16 <freeside> thou base coder, for coding in that style, thou shalt be cursed and cursed again
07:31:26 <nbro> tdammers: please, I know how to write recursive functions, I’m just trying to understand the syntax above
07:31:26 <Cale> haha
07:31:38 <merijn> nbro: What syntax part confuses you?
07:31:49 <tdammers> nbro: do you mean the | part?
07:31:49 <erisco> yeah, puh-leez tdammers
07:32:08 <nbro> merijn: exactly how the control flow would happen
07:32:26 <tdammers> nbro: there is no control flow, just functions defined in terms of one another
07:32:30 <Cale> nbro: So a and res start at n and 1 respectively, and then so long as a > 1, we subtract 1 from a, and multiply res by a
07:32:51 <tdammers> nbro: evaluation order and control flow arise from the call graph
07:32:54 <Cale> nbro: and then once a is no longer greater than 1, we produce res as the result
07:33:27 <tdammers> nbro: you can trace the "control flow" by evaluating the function by hand - it's mostly just pattern matching and substitution
07:33:56 <freeside> res ipsa loquitur, really
07:34:00 <erisco> I don't think we talk about "control flow", we talk about "evaluation order"
07:34:06 <tdammers> e.g., if you want to evaluate `factorial'' 2`, the first line says you can susbtitue `go 2 1`
07:34:08 <sasinello> ciaoo
07:34:18 <sasinello> !list
07:34:33 <Cale> Yeah, we can do it algebraically:  factorial'' 4 = go 4 1 = go 3 (4*1) = go 2 (3*4*1) = go 1 (2*3*4*1) = 2*3*4*1
07:34:40 <nbro> Cale: exactly what I wanted to hear...
07:34:59 <nbro> essentially we call another function inside the function factorial''
07:35:07 <tdammers> yes
07:35:09 <nbro> by passing to it the initial parameters
07:35:10 <nbro> ok
07:35:32 <Cale> Yeah, it's a little weird to think of this as "calling" since it's outermost-first evaluation and there's no call stack
07:35:33 <tdammers> you could also just write go as a top-level function in this example
07:35:59 <Cale> but yes
07:36:12 <nbro> I’m still not really familiar with wheres and dos
07:36:26 <nbro> and I still need to understand when can I use them
07:36:58 <Cale> Well, do is for gluing together a bunch of actions in some monad to form a larger action.
07:36:58 <erisco> well, if you want to use foreign jargon, then stuff after "where" is like hoisted local variables
07:37:16 <tdammers> `where` is pretty simple, think of it as introducing a local scope for the definition that it follows
07:37:21 <Cale> 'where' is for making definitions which scope over the rest of your declaration
07:37:48 <nbro> Cale: the problem is that I still need to learn about monads… I know IO() is a monad and monads are used apparently when side effects could happen?
07:37:55 <nbro> honestly I still need to read bout those things
07:37:58 <tdammers> `do` is syntax sugar for monadic code; best way to "understand" it is to learn the desugaring rules and apply them to a bunch of examples
07:38:08 <Cale> IO is a monad, and IO is used to describe effects
07:38:15 <freeside> for completeness please contrast "where" with "let/in"
07:38:40 <Cale> But other monads might have different qualities to them -- what they share is basically a particularly-shaped API which seems to come up often.
07:38:50 <erisco> IO is a monad, not IO (), and monads provide an interface to cope with side-effects but that is not the only use of them
07:39:20 <Cale> For example, the list type constructor is also a monad, and so we can write things like:
07:39:30 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
07:39:31 <tdammers> s/side-effects/effects/
07:39:32 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
07:39:47 <nbro> I know that let … in … is somehow equivalent to … where ...
07:39:57 <Cale> Yes
07:39:59 <tdammers> also, it's not that you need monads to model effects
07:40:02 <nbro> not sure if they are really interchangable everywhere
07:40:05 <ph88> hi guys, i use stack build on one system and then move the executable to another system (with same OS) and it doesn't work because it says: can not find shared library libgmp.so.10  .. how can i make sure that the binary always works ?
07:40:18 <Cale> The difference being that 'where' is part of the declaration syntax rather than expression syntax
07:40:24 <Cale> and will scope over multiple guards
07:40:36 <Cale> But otherwise, they are equivalent
07:40:46 <tdammers> just that the "shape" of code that models effects usually forms a monad, and Haskell just decided to make this explicit in the form of the Monad typeclass
07:41:34 <nbro> why is the list type constructor a monad?
07:41:48 <Cale> Well, a monad consists of three things:
07:41:55 <Cale> 1) A type constructor M
07:42:11 <Cale> 2) A function  return :: a -> M a
07:42:22 <Cale> 3) A function  (>>=) :: M a -> (a -> M b) -> M b
07:42:41 <Cale> (and return and (>>=) have to satisfy some conditions I'll gloss over for now)
07:42:48 <Cale> For lists, we have
07:42:51 <Cale> return :: a -> [a]
07:42:52 <Cale> and
07:42:59 <Cale> (>>=) :: [a] -> (a -> [b]) -> [b]
07:43:07 <Cale> Can you come up with functions of those types?
07:43:17 <Cale> Chances are, the first thing you come up with will be the right ones :)
07:44:26 <erisco> oh I don't know about that, there are lots of ways to get it wrong too :P
07:44:43 <Cale> There are ways to get it wrong for sure
07:45:04 <Cale> But the right thing is perhaps the most intuitive thing to do
07:45:23 <nbro> Cale: mm.. honestly I need to read a full article about these topics, I’ve just read a little bit here and there
07:45:32 <tdammers> return = repeat; (>>=) = const [] -- >:-> ignore me
07:45:41 <Cale> nbro: The best way to proceed is probably just to look at examples of monads one by one
07:45:58 <nbro> Cale: ok, thanks again!
07:46:03 <freeside> to put it all together, a text like haskellbook.com might also be useful
07:46:13 <nbro> @lpaste
07:46:13 <lambdabot> Haskell pastebin: http://lpaste.net/
07:46:15 <nbro> lol
07:46:26 <eacameron> I'd like to use https://github.com/hvr/multi-ghc-travis or something like it for travis builds, but I have multiple cabal projects in my repo. Does anyone have an example of how to do that?
07:46:26 <tdammers> nbro: seriously; I recommend ignoring do notation until you understand plain monadic code (using >>= and return)
07:46:39 <merijn> Yes
07:46:45 <Cale> tdammers: That'll fail the law that x >>= return = x
07:47:01 <merijn> I would always recommend beginners to avoid do-notation until you're comfortable with >>=
07:47:08 <erisco> well you glossed over that Cale :P
07:47:08 <Cale> tdammers: also return v >>= f = f v ;)
07:47:17 <Cale> erisco: That's fair :)
07:47:34 <merijn> I like >>= for implementation, but I dislike it for laws
07:47:40 <merijn> >=> is so much more elegant
07:48:29 <erisco> and others like join
07:48:40 <merijn> Can you specify the laws with join?
07:48:45 <Cale> merijn: What, you don't like (x >>= f) >>= g = x >>= (\v -> f x >>= g)  ;)
07:48:47 <erisco> I think join is the better for implementation :P
07:48:57 <merijn> "return >=> f = f = f >=> return"
07:49:08 <Cale> Actually, the associativity law is kind of neat to look at do-notation
07:49:17 <Cale> in*
07:49:26 <erisco> well sure, because you can get >>= from fmap and join, and so then you just substitute into the >>= laws
07:49:27 <merijn> Cale: Both associativity and identity of return are nice with >=>
07:49:29 <shapr> Is there comonad notation similar to do notation?
07:49:35 <Cale> merijn: I know :)
07:49:43 <merijn> erisco: Yes, but that doesn't make the laws nicer to read/easier to understand
07:49:47 <freeside> nbro: http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
07:49:49 <shapr> :t (>=>)
07:49:51 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
07:49:58 <erisco> I said I like join for the implementation
07:50:11 <erisco> sits in my head better to think about m (m a) -> m a rather than bind
07:50:18 <merijn> erisco: >=> gives "return >=> f = f = f >=> return" and "(f >=> g) >=> h = f >=> (g >=> h)"
07:50:19 <Cale> Basically, it's telling us that we can chop pieces of a do-block out of the middle and make them into their own definition without affecting the result
07:51:05 <Cale> So it's what lets us refactor our code into smaller parts
07:51:50 <freeside> equational reasoning at the granularity of multiple expressions
07:51:52 <erisco> merijn, yes, that is nice because it has some mathematical familiarity
07:52:14 <merijn> It also avoids a lot of noise that makes things hard to understand
07:53:17 <Cale> nbro: Here's my little take on it: https://wiki.haskell.org/Monads_as_computation
07:54:04 <nbro> ok, guys, I will see have time to read about your suggestions
07:54:06 <nbro> ;)
07:54:28 <freeside> yeah. see you in a year or so :)
07:54:52 <nbro> lol
07:55:30 <freeside> have you ever wanted to watch a movie, and then and gone and read the reviews for that movie, and then found yourself wanting to watch all the movies that were mentioned in those reviews first? yeah.
07:56:06 <Cale> and then and gone and read those movies' reviews first, and then the same thing happened?
07:56:35 <Cale> and eventually you realised that you just like reading movie reviews
07:56:44 <freeside> haha
07:57:37 <Rembane> You will save so much time!
07:57:54 <freeside> and then you find yourself hanging out on IRC talking about movie reviews with other movie reviewers
07:58:07 <nbro> lol
07:58:08 <freeside> meanwhile there are people out there *actually making movies*
07:58:18 <Tuplanolla> That never happens.
07:58:43 <merijn> freeside: Some of are just here to slack while we wait for our programs to finish running :p
07:58:52 <mbrock> I asked a question on reddit for which some of you may have input: https://www.reddit.com/r/haskell/comments/5zjpbu/asking_the_type_system_questions/
07:59:10 <Tuplanolla> There's no point in reading positive reviews and insightful negative reviews are really hard to come by.
07:59:25 <shapr> I don't watch TV, and rarely do I watch movies.
07:59:27 <ggVGc> I never run my programs
07:59:35 <ggVGc> if they compile, they're done, aren't they?
07:59:40 <Tuplanolla> That they are.
07:59:47 <shapr> BUT! I would still like to be able to do a join across IMDB and netflix available movies.
07:59:50 <ggVGc> I thought we were all just running our programs in the type checker
07:59:54 <ggVGc> isn't that the main part
08:00:14 <mbrock> no, the main part is rendering them to LaTeX and admiring the beautiful PDF
08:00:22 <Tuplanolla> The point of dependent types is to finally allow the likes of us to actually run something.
08:00:31 <merijn> mbrock: So, there are people who've had this kinda idea before, but I'm not aware of any really advanced tooling for haskell to do this
08:00:56 <ggVGc> Tuplanolla: imagine what the next thing will be that you find out you need in order to make your dependent types programs actually do something
08:01:02 <ggVGc> looking forward to what that might be
08:01:05 <mbrock> merijn: okay. I'm kind of considering hacking something together without any formal rigor, basically a shell script that calls :t on everything and uses grep, or whatever
08:01:22 <Tuplanolla> Whats happens in the type system stays in the type system.
08:02:31 <freeside> well, in the Haskell tradition, some people write screenplays, then they go to conferences and give talks about those screenplays, and other people read those screenplays and write movie reviews about the movies that would have been made from those screenplays
08:03:09 <freeside> sometimes people write frameworks and libraries to make it easier for people to make a specific movie within the genre of movies implied by the screenplay
08:03:20 <mbrock> "I've noticed that your play is simply an instance of a more general play discovered by a narrative theorist in 1932"
08:03:41 <freeside> however, this means that anyone who wants to actually make a movie, like nbro, first needs to read a dozen screenplays and a hundred movie reviews
08:04:38 <freeside> the screenplays give vague directions about scene composition, and the reviews talk knowledgeably about cinematography, but none of them actually answer the question "how does this camera work?"
08:04:47 <nbro> what? actually I’ve already taken part in a few short moviews :D 
08:05:25 <erisco> merijn, careful on your first law there
08:06:43 <merijn> mbrock: Most notably Conor McBride's work on Epigram is working on getting things to be like a "dialogue" between compiler and programmer
08:07:01 <merijn> mbrock: You might also want to have a look at Peaker's work on Lamdu
08:07:17 <merijn> mbrock: http://www.lamdu.org/
08:07:24 <merijn> WHich is doing work along similar lines
08:08:46 <nbro> hey guys, here’s my length function for lists using the syntax I asked you about before: http://lpaste.net/353564
08:08:48 <nbro> :D
08:09:46 <ggVGc> freeside: and then it turns out, no one actually has a cinema that can play haskell screenplays
08:09:47 <mbrock> merijn: ok, looks cool! to contextualize a bit, I'm not so focused on the interactivity part, it's more that I want a reason to claim "only these functions can alter this part of the state" because then I can more easily justify the program's correctness. It's entirely possible that I should just rewrite the program in Agda/Idris
08:09:54 <ggVGc> so the movie you made isn't useful anyway
08:10:27 <freeside> :)
08:10:48 <erisco> nbro, well done :)
08:11:05 <merijn> mbrock: Ah, that's harder
08:11:39 <merijn> mbrock: This is the sorta stuff people at the cutting/bleeding edge of programming languages like to try doing :)
08:11:45 <erisco> nbro, there is a simpler definition if you want to keep trying
08:12:57 <freeside> a good learning exercise now would be to express the same concept in half a dozen ways
08:13:12 <freeside> like, "do this without `not`"
08:13:19 <erisco> id x, id id x, id id id x, ... ;)
08:13:22 <freeside> "do this without `where`"
08:13:35 <freeside> "do this without `null`"
08:14:17 <freeside> "move the `+ 1` to operate on the result of calling aux"
08:14:31 <freeside> "give up and use `length` lolol"
08:15:54 <nak> looking at this monad law: (m >>= f) >>= g == m >>= (\x -> f x >>= g) specifically the (\x -> f x >>= g) part. what happens first? (f x) or (x >>= g) ?
08:16:08 <freeside>  "do this without a `where`"
08:16:17 <freeside> "do this without | guards"
08:16:18 <merijn> nak: Function application has higher precedence than infix operators
08:16:18 <ggVGc> `where` is the best
08:16:24 <nak> i suspect (f x) >>= g is the order it happens in
08:16:29 <nak> ok thank you merijn ^_^
08:16:54 <nak> merijn: is that true in all cases? are there infix operators with higher precedence?
08:16:54 <merijn> nak: Infix operators/functions (if you use `) have a precence of 0-9 (higher binds tighter)
08:17:07 <merijn> nak: Function application has precedence 10, record syntax has precedence 11
08:17:08 <ski> nak : yes, application binds tigher than any (other) infix operator
08:17:30 <erisco> turn it up to 11
08:17:33 <nak> lol
08:17:41 <tdammers> record syntax is the marshall guitar amp among haskell syntax constructs
08:17:42 <ski> (apart from a few special syntactic constructions, but those aren't user-defined operators)
08:17:46 <nak> how can we check the precedence of any particular operator?
08:17:50 <nak> eg $
08:18:03 <merijn> nak: In ghci you can write ":info ($)" and it'll tell you
08:18:04 <ski> in the interactor `:info ($)'
08:18:46 <merijn> The default precedence for operators is 'infixl 9'
08:18:46 <nak> infix 0
08:19:06 <nak> merijn: infixl meaning left associativity ?
08:19:09 <merijn> nak: That's essentially the entire trick behind $, lowest possible precedence :)
08:19:12 <merijn> nak: Yes
08:19:40 <nak> and user-defined operators cannot be outside of infix 0-9 ?
08:19:48 <merijn> nak: Defining precedence of your own operators is as simple as putting 'infixl 6 *' (or whatever your operator is) in there
08:19:51 <merijn> nak: Right
08:20:02 <nak> sweet
08:20:23 * nak smiles and continues reading
08:21:15 <merijn> nak: Although, to be specific, *no* operators can be outside infix 0-9, not just the user defined ones ;)
08:21:47 <nak> merijn: ah ok thank you for the distinction 
08:22:15 <freeside> "space" is function application -- how do i :i that?
08:22:17 <nak> merijn: (f x) has precedence of 10 but that's not an operator
08:22:26 <merijn> freeside: Space is not an operator, tbh
08:22:33 <nak> freeside: well space is not always function application
08:22:33 <freeside> i meant what nak just said
08:22:48 <erisco> you have it wrong
08:22:52 <freeside> i have it wrong
08:22:58 * nak chortles
08:22:58 <erisco> it isn't the space, it is just the juxtaposition of two terms
08:23:17 <erisco> otherwise what is f  x  and  f   x  and so on
08:23:25 <merijn> nak: There's no real encoding of precedence of application/record syntax, but it's specified so that it behaves the same as if it did have precedence
08:23:27 <nak> f apply apply apply x !
08:28:35 <nak> how can i develop an intuition about >> vs >>= (re monads)
08:28:51 <nak> i understand Just 5 >> Just 4 will give Just 4
08:28:59 <nak> but when would such an operator be useful
08:29:07 <nak> it reminds me of const
08:29:47 <nak> :t (>>)
08:29:49 <lambdabot> Monad m => m a -> m b -> m b
08:29:50 <nak> :t const
08:29:53 <lambdabot> a -> b -> a
08:29:59 <nak> yeah this is like monad const
08:30:07 <nak> wait
08:30:11 <nak> no it's not
08:30:21 <nak> it's a -> b -> b, not a -> b -> a
08:30:34 <nak> ok now i'm dumbfounded. can someone provide useful example of >>
08:30:55 <erisco> putStrLn "hello" >> putStrLn "sailor!"
08:31:09 <nak> :t putStrLn
08:31:12 <lambdabot> String -> IO ()
08:31:21 <nak> my brain
08:31:58 <merijn> nak: Well, usually for sorta short-circuiting
08:32:00 <nak> erisco: can we use an example with no side effect ?
08:32:38 <brynedwa1ds> :t (*>)
08:32:40 <lambdabot> Applicative f => f a -> f b -> f b
08:32:43 <merijn> nak: Consider you compute "authorised :: Maybe ()" "authorised >> result" which results in result if it's Just, or Nothing otherwise
08:33:07 <nak> oh that's interesting
08:33:07 <erisco> x <- get; put (x + 1) >> return (x * 2)
08:33:18 <erisco> I don't know, it just comes up now and then
08:33:37 <nak> erisco: is that ... state monad ?
08:33:44 <erisco> yes
08:34:19 <erisco> there are lots of things that return m () and usually that follows with >> (or nothing)
08:34:44 <merijn> nak: Also in parsers
08:34:44 <nak> ok thanks ^^
08:34:55 <merijn> nak: "parsePrefix >> parsePartICareAbout"
08:35:08 <merijn> nak: You still wanna parse the prefix, but don't care about dropping it
08:35:30 <erisco> it is the monad version of *>
08:35:44 <nak> erisco: yeah i see that brynedwa1ds mentioned that
08:35:44 <merijn> nak: >> basically keeps the monadic context/effects/whatever you wanna call it, but drops the result on the floor
08:36:07 <nak> merijn: cool. i'm sure i'll gather an intuition when i see it more in reading other code
08:36:19 <nak> i'll use that as my base understanding for now 
08:36:38 <erisco> :t ($>)
08:36:41 <lambdabot> error:
08:36:41 <lambdabot>     • Variable not in scope: $>
08:36:41 <lambdabot>     • Perhaps you meant one of these:
08:36:45 <freeside> isn't it more like monad seq?
08:36:54 <erisco> really? well that is around too
08:37:01 <erisco> :t fmap . const
08:37:04 <lambdabot> Functor f => b -> f b1 -> f b
08:37:25 <merijn> :t (<$)
08:37:27 <lambdabot> Functor f => a -> f b -> f a
08:37:32 <merijn> Got the version wrong ;)
08:38:03 <merijn> > 'c' <$ Nothing
08:38:07 <lambdabot>  Nothing
08:38:10 <merijn> > 'c' <$ Just True
08:38:13 <lambdabot>  Just 'c'
09:00:43 <mofasa_> for suppressing 'Defined but not used' for methods... Is it '-fno-warn-missing-methods' or '-fno-warn-missing-binds' ??
09:04:14 <lyxia> mofasa_: when does such a warning occur?
09:05:03 <mofasa_> lyxia: ghc-mod reports for top level functions that are not used 
09:05:27 <lyxia> "Defined but not used" sounds more like a -Wunused-binds warning than a missing-something
09:06:22 <lyxia> mofasa_: Okay thats -Wno-unused-top-binds (and implied by -Wno-unused-binds)
09:06:48 <mofasa_> lyxia: alright. The info I could find online was all very old, i think the flags have changed in the past 5 years?
09:07:04 <lyxia> mofasa_: "method" usually refers to functions that are part of a type class.
09:07:12 <lyxia> which is why I was confused.
09:07:20 <lyxia> mofasa_: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html these docs are up to date
09:09:01 <mofasa_> Aah so implementations in 'instance xx where ..' are called methods, the rest functions? I got confused as well 
09:10:05 <lyxia> that's how I use these words
09:11:54 <mofasa_> that makes sense to me. no-warn-missing-methods are probably for incomplete type class instances
09:20:30 <Rodenbach> One of the examples at https://hackage.haskell.org/package/lens-tutorial-1.0.2/docs/Control-Lens-Tutorial.html is this:   shiftMoleculeX = over (atoms . traverse . point . x) (+ 1)       -- where does traverse come from? Is this a function from the Control.Lens module?
09:20:42 <lyxia> Data.Traversable
09:21:50 <Rodenbach> lyxia: thx
09:21:59 <lassulus> Is v
09:22:02 <lassulus> ups
09:22:05 <Tuplanolla> Note that `traversed` is elsewhere, Rodenbach.
09:25:15 <mohsen_> Hi. Can I use the tutorial prompt at haskell.org to practice lyah examples?
09:26:43 <Cale> mohsen_: You probably shouldn't -- it was acting up the other day, and it's pretty limited even when it's working properly. Just grab GHC.
09:27:35 <mohsen_> Cale: There is no other ghci online?
09:28:49 <Rodenbach> Tuplanolla: okay, traverse is different from traversed.
09:30:43 <Cale> mohsen_: Well, there are various other things which will run programs in a sandboxed environment, but I don't see why you'd want to bother with them when it's easy enough to install ghci and have it run fast on your own machine without time limits and sandboxes
09:32:51 <mohsen_> Cale: Hmm you're right, off to install ghci, thanks.
09:33:37 <Rodenbach> That Lens tutorial says: „[…] we can do a lot more with lenses than just get and set values […]”. Can you give some examples of what „a lot more” means?
09:34:42 <Tuplanolla> > over (iso ord chr) (+ 13) 'A'
09:34:45 <lambdabot>  'N'
09:36:01 <Rodenbach> Tuplanolla: okay, that’s an interesting example.
09:45:54 <chenyu``> > :t over
09:45:57 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
09:46:06 <chenyu``> :t over
09:46:09 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
09:48:00 <glguy> Rodenbach: The power comes from being able to generalize operations e.g. mapAccumLOf, lengthOf, holesOf, elemOf, forOf
09:51:20 <ParkeT> Hi, guys. 
09:52:53 <ParkeT> Is `ma >> mb` the same as `second <$> fa <*> fb ` where `second _ b = b`
09:53:02 <benzrf> ParkeT: yes
09:53:24 <benzrf> ParkeT: exercise: deduce this from the monad and applicative laws :)
09:53:42 <benzrf> (and the fact that the Applicative implementation needs to be equivalent to a certain one in terms of Monad)
09:54:08 <ParkeT> Nice idea. I will. Thx
09:54:19 <benzrf> good luck
09:54:25 <ParkeT> Bye ;)
09:54:36 <benzrf> ParkeT: oh, fyi
09:54:38 <benzrf> @src (>>)
09:54:38 <lambdabot> m >> k = m >>= \_ -> k
09:54:40 <benzrf> this should be useful
09:55:37 <ParkeT> Lambdabot. hmmm. Nice :) Let me try
09:55:47 <ParkeT> @src a >>= b
09:55:47 <lambdabot> Source not found. I've seen penguins that can type better than that.
09:55:56 <ParkeT> oups
09:56:00 <ParkeT> @src (>>=)
09:56:00 <lambdabot> Source not found. Wrong!  You cheating scum!
09:56:07 <benzrf> ParkeT: that's per-instance, of course
09:56:29 <benzrf> (also, @src uses a static pre-written database, so it's very limited)
09:56:35 <ParkeT> Oh. Ok
09:57:28 <chenyu``> benzrf: how do you know that? is there an article introduce lambdabot?
09:57:50 <benzrf> chenyu``: i've just learned it from other people saying so after hanging out for long enough in the channels :)
09:58:17 <brynedwards> stupid lens question: how do I do this without the map? map (view _2) [(1, 2), (3, 4)]
09:58:30 <brynedwards> I'm using amazonka which uses lenses for everything
09:58:46 <glguy> You wouldn't do that without a map
09:59:02 <Tuplanolla> There's `each`, but why?
09:59:05 <glguy> You can hack it in like:   toListOf (folded . _2)
09:59:12 <Rembane> brynedwards: fmap or list comprehension?
09:59:13 <benzrf> brynedwards: traverse
09:59:29 <benzrf> > toListOf (traverse . _2) [(1, 2), (3, 4)]
09:59:32 <lambdabot>  [2,4]
09:59:43 <Rembane> brynedwards: foldr if you really hate maps
09:59:58 <benzrf> ah, glguy just said that... oops :)
10:00:39 <brynedwards> Well what I have is 'let logKeys = map (view oKey) (lrs ^. lrsContents)'
10:01:29 <benzrf> oh jeez
10:01:30 <brynedwards> And oKey is a lens, and (lrs ^. lrsContents) is [Object]
10:01:35 <benzrf> (^.) is the same as view
10:01:41 <benzrf> you're nesting views there! just compose the lenses
10:01:43 <brynedwards> From here https://hackage.haskell.org/package/amazonka-s3-1.4.5/docs/Network-AWS-S3-ListObjectsV.html#v:lrsContents
10:01:50 <brynedwards> I know it's really dumb :'(
10:02:01 <benzrf> well... why not just compose the lenses, if you know?
10:04:54 <neophytes> Can anyone explain steps 5 and 6 here: http://i.imgur.com/1grOkPu.png --  λz(λn.z)((λp.p)z))  to λz.z -- book says bind n to ((λp.p)z)), but that confuses me since there is no other n in the expression other than λn which is at the head 
10:08:43 <benzrf> neophytes: hmm, this does look to me like it should become (\n.z)
10:10:30 <neophytes> benzrf: yeah thats what i thought -- since λz and z match up in λz(λn.z) so set z=((λp.p)z)=z  and it becomes λn.z
10:11:06 <lyxia> neophytes: (λn. z) (...) -> z    in one step
10:12:06 <lyxia> It's not (λz. (λn. z)) ((λp. p) z)  but  λz. ((λn. z) ((λp. p) z))
10:12:45 <neophytes> oh ok
10:13:48 <benzrf> aha
10:14:05 <neophytes> i'm confused because the book writes it as  λz. (λn. z) ((λp. p) z) in step 5
10:15:29 <lyxia> Right that's how it's usually written with minimal parentheses
10:15:49 <lyxia> lambdas group as far to the right as possible
10:16:01 <neophytes> so Az "quantifies" over the entire expression?
10:16:48 <nshepperd> it's the same as λz. x y
10:16:57 <neophytes> λz. ((λn. z) ((λp. p) z)) -- how do i proceed from there? 
10:17:08 <nshepperd> except that x is (λn. z) and y is ((λp. p) z)
10:17:47 <neophytes> there doesn't look like anything else i can do to λz. ((λn. z) ((λp. p) z)) 
10:18:45 <neophytes> unless you say p:=z and then λz. ((λn. z)z)) -> (λn. z) ?
10:18:48 <nshepperd> beta reduce it
10:19:09 <nshepperd> apply (λn. z) to ((λp. p) z)
10:19:28 <benzrf> ahaha 'nshepperd' and 'neophytes' are the same length and same color in my client and both start with n, i didnt even notice at first it wasnt one person talking to themself
10:19:46 <nshepperd> muahaha
10:19:50 <neophytes> nshepperd: is that not just  say p:=z and then λz. ((λn. z)z)) -> (λn. z) ?
10:20:20 <Tuplanolla> They're orange and red for me too, benzrf.
10:20:41 <benzrf> Tuplanolla: no, the're both purple for me
10:21:47 <neophytes> λz. ((λn. z) ((λp. p) z))   -> p:=z   -> λz. ((λn. z) (z)) -> λn. z  -- is that right?
10:22:13 <nshepperd> not quite
10:22:30 <nshepperd> what do you get when you beta reduce (λn. z) z?
10:22:30 <neophytes> i dont understand what to do then. 
10:22:51 <neophytes> you cant reduce (λn. z) z as you wrote it
10:22:55 <neophytes> since z is a free variable
10:23:05 <nshepperd> sure you can
10:23:08 <johnw> blue and fuschia here :)
10:23:22 <nshepperd> substitute z in for n
10:23:22 <neophytes> (λn. z) z as written contains z as a free variable
10:23:54 <Adluc> == (\n -> z) x
10:23:58 <neophytes> which z are you subsituting? (λn. z1) z2
10:23:59 <Adluc> == z
10:24:03 <neophytes> in my expression
10:24:04 <nshepperd> neophytes: they're the same z
10:25:13 <neophytes> im not followig 
10:25:31 <neophytes> steps 5 to 6 make no sense to me
10:25:51 <neophytes> based on what the book wrote (which isnt much to that point) I do not know the rules to proceed from step 5 to 6
10:26:03 <nshepperd> neophytes: (λn. z) is a constant function. it returns z no matter what you apply it to
10:26:13 <neophytes> ok
10:26:42 <nshepperd> so now apply (λn. z) to z
10:27:05 <neophytes> the book says if there is a free variable you cannot do a replacement
10:27:08 <neophytes> z is a free variable
10:27:15 <neophytes> lambda only quantifies n
10:27:39 <neophytes> im not seeing how youre moving from  𝜆𝑧((𝜆𝑛.𝑧)((𝜆𝑝.𝑝)𝑧)) step
10:27:52 <nshepperd> :/
10:28:04 <nshepperd> I don't understand why the book would say that
10:28:12 <neophytes> so what are the actual rules
10:28:16 <nshepperd> beta reduction works fine with free variables
10:28:22 <neophytes> o i c
10:28:46 <neophytes> e.g. book writes: Note that alpha equivalence does not apply to free variables. That is, 𝜆𝑥.𝑥𝑧 and 𝜆𝑥.𝑥𝑦 are not equivalent because 𝑧 and 𝑦 might be dif- ferent things. However, 𝜆𝑥𝑦.𝑦𝑥 and 𝜆𝑎𝑏.𝑏𝑎 are equivalent due to alpha equivalence, as are 𝜆𝑥.𝑥𝑧 and 𝜆𝑦.𝑦𝑧 because the free variable is le  alone.
10:29:10 <lyxia> It's talking about something else
10:29:18 <johnw> is everything Typeable by default since GHC 7.8, or is it just possible to auto-derive Typeable since then?
10:29:28 <lyxia> johnw: everything is Typeable
10:29:45 <neophytes> ok
10:30:12 <brynedwards> I still don't understand...with a lens, what's the "correct" way to apply a getter to a list I guess...?
10:30:29 <neophytes> so what are the steps for reducing:  𝜆𝑧((𝜆𝑛.𝑧)((𝜆𝑝.𝑝)𝑧))
10:30:38 <neophytes> this is one of the very first problems im looking at
10:30:55 <nshepperd> neophytes: right, it's saying there that you can't rename free variables. you can't decide that z is now called w. but you can still beta reduce
10:30:57 <johnw> brynedwards: you mean, apply a getter to every element of a list?
10:31:16 <johnw> > [(1,2),(3,4)] ^.. traverse._1
10:31:19 <lambdabot>  [1,3]
10:31:28 <neophytes> nshepperd: ok, so step-by-step how do you reduce  𝜆𝑧((𝜆𝑛.𝑧)((𝜆𝑝.𝑝)𝑧)) then
10:31:32 <chenyu``> :i toListOf
10:31:42 <chenyu``> :t toListOf
10:31:42 <nshepperd> neophytes: apply (λn.z) to ((\p. p) z)
10:31:44 <lambdabot> Getting (Endo [a]) s a -> s -> [a]
10:31:57 <nshepperd> neophytes: you get z[n := ((\p. p) z)]
10:31:57 <chenyu``> @src toListOf
10:31:57 <lambdabot> Source not found. Just what do you think you're doing Dave?
10:32:14 <nshepperd> that is "z" with n replaced by "((\p. p) z)"
10:32:33 <nshepperd> neophytes: however "z" doesn't contain "n" anywhere, so that's simply "z"
10:33:17 <nshepperd> so now you have λz. z
10:33:28 <brynedwards> johnw: I have two lenses (from amazonka-s3) 'lrsContents :: Lens' ListObjectsVResponse [Object]' and 'oKey :: Lens' Object ObjectKey'
10:34:07 <neophytes> i dont follow your notation. im trying to parse it  𝜆𝑧((𝜆𝑛.𝑧)((𝜆𝑝.𝑝)𝑧)) -> apply (λn.z) to ((\p. p) z) traslates to: (𝜆𝑛.𝑧)((𝜆𝑝.𝑝)𝑧)) -> z[n := ((\p. p) z)] dont know what this means
10:34:15 <brynedwards> and I want to get to [ObjectKey] from ListObjectsVResponse
10:34:38 <nshepperd> z[n :=
10:34:50 <Rodenbach> About the molecule example from the Lens tutorial again: https://hackage.haskell.org/package/lens-tutorial-1.0.2/docs/Control-Lens-Tutorial.html
10:34:52 <Rodenbach> What if we had 200 Atoms stored in a molecule, and we wanted to update the nth? How would one do that?
10:34:55 <Cale> neophytes: it just means that you're meant to substitute n for ((\p . p) z) in what came before
10:35:10 <Cale> neophytes: However, since there are no occurrences of n, there's nothing to do
10:35:36 <neophytes> ok
10:36:48 <neophytes> 𝜆𝑧((𝜆𝑛.𝑧)((𝜆𝑝.𝑝)𝑧)) -> n:=((𝜆𝑝.𝑝)𝑧)) -> there are no n's to apply this sub to -> then the next step?
10:36:48 <brynedwards> I tried "(lrs :: ListObjectsVResponse) ^.. lrsContents . oKey" but that doesn't seem to work
10:37:07 <brynedwards> I mean "(lrs :: ListObjectsVResponse) ^.. lrsContents . traverse oKey"
10:37:12 <nshepperd> neophytes: so, (λn.z)((λp.p)z) -> z
10:38:09 <brynedwards> I'm assuming this involves a getter...
10:38:22 <neophytes> z:= (λn.z)((λp.p)z)  and replace all occurnaces of z with (λn.z)((λp.p)z)  in 𝜆𝑧((𝜆𝑛.𝑧)((𝜆𝑝.𝑝)𝑧)) or do you mean  𝜆𝑧((𝜆𝑛.𝑧)((𝜆𝑝.𝑝)𝑧)) reduces to z
10:38:42 <nshepperd> neophytes: I mean that (λn.z)((λp.p)z) reduces to z
10:39:08 <nshepperd> neophytes: as we just established by beta reduction
10:39:27 <nshepperd> neophytes: which means that λz. (λn.z)((λp.p)z) reduces to λz.z
10:41:01 <neophytes> ((𝜆𝑝.𝑝)𝑧)), p: = z -> z  -- is that wrong?
10:41:23 <neophytes> i am not filling in the piece from 𝜆𝑧((𝜆𝑛.𝑧)((𝜆𝑝.𝑝)𝑧)) -> z
10:41:38 <nshepperd> ((λp.p)z) also reduces to z, yes, but you don't need to know that
10:41:42 <dmwit> brynedwards: `lrsContents . traverse . oKey`?
10:41:56 <nak> ok so i'm trying to understand runIdentity in the Identity monad. first of all, i don't even know how to construct a value compatible with Identity. ideas there?
10:42:06 <dmwit> Rodenbach: `at n`?
10:42:21 <dmwit> Disclaimer: I have only used lens for a few hours total.
10:42:46 <dmwit> nak: `Identity` is the constructor for the `Identity` type.
10:42:51 <neophytes> I understand: 𝜆𝑧((𝜆𝑛.𝑧)((𝜆𝑝.𝑝)𝑧)) and saying n:= ((𝜆𝑝.𝑝)𝑧)) , and not being able tp do that since n doesn't appear anywhere, so then im stuck back at 𝜆𝑧((𝜆𝑛.𝑧)((𝜆𝑝.𝑝)𝑧)) 
10:42:52 <nak> i'm trying to interact with Identity in my terminal. things like :t Identity and :t runIdentity say data constructor not in scope
10:42:52 <dmwit> > Identity 3 :: Identity Int
10:42:57 <lambdabot>  Identity 3
10:43:03 <neophytes> youre saying set z: = (𝜆𝑛.𝑧)((𝜆𝑝.𝑝)𝑧)
10:43:09 <neophytes> in 𝜆𝑧((𝜆𝑛.𝑧)((𝜆𝑝.𝑝)𝑧))
10:43:13 <lyxia> nak: you must import the module Data.Functor.Identity first
10:43:15 <dmwit> nak: import Control.Monad.Identity
10:43:16 <nak> ah
10:43:22 <nak> ok so newbie question
10:43:35 <nak> how would i know i need to do that?
10:43:37 <nak> well
10:43:39 <dmwit> Hoogle it.
10:43:42 <nshepperd> neophytes: let's take a simpler example. what is ((λn. z) w)?
10:43:43 <nak> how would i know that specific module
10:43:49 <dmwit> https://www.haskell.org/hoogle/
10:43:53 <dmwit> ?hoogle Identity
10:43:57 <lambdabot> module Data.Functor.Identity
10:43:57 <lambdabot> Data.Functor.Identity newtype Identity a
10:43:57 <lambdabot> Data.Functor.Identity Identity :: a -> Identity a
10:44:00 <neophytes>  ((λn. z) w)
10:44:08 <neophytes> nshepperd: ((λn. z) w) is ((λn. z) w)
10:44:19 <nshepperd> neophytes: no, you can beta reduce it
10:44:22 <nak> dmwit: and how do i know which of those is correct for me ?
10:44:25 <neophytes> how?
10:44:32 <dmwit> nak: They are all correct. =)
10:44:33 <nshepperd> neophytes: set n := w
10:44:41 <nak> I see Control.Monad.Identity and Data.Functor.Identity
10:44:49 <nak> do i need to import both if i want to use Identity as Functor and as Monad ?
10:44:49 <neophytes> okay so i set n:=w but there are no n's to sub it in 
10:45:05 <neophytes> ((λn. z) w) -- the only n is at the head
10:45:09 <neophytes> there are no n's in the body
10:45:15 <nshepperd> neophytes: yep
10:45:20 <dmwit> nak: Both will work. You can see from `Control.Monad.Identity`'s source that it is just re-exporting `Data.Functor.Identity`'s newtype.
10:45:22 <neophytes> so i cannot sub n anywhere 
10:45:26 <nshepperd> neophytes: so the result is just the body, unaffected, right?
10:45:29 <neophytes> yes
10:45:34 <neophytes> so ((λn. z) w) is ((λn. z) w) no?
10:45:36 <nak> dmwit: ok
10:45:37 <nshepperd> neophytes: the result is z
10:45:45 <neophytes> oh i see
10:45:47 <dmwit> nak: http://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control.Monad.Identity.html
10:46:07 <dmwit> nak: Which I reached by Hoogling; then clicking `Control.Monad.Identity`; then clicking "source" in the top right.
10:46:29 <neophytes> i did not know it worked this way
10:47:54 <nshepperd> neophytes: so ((λn. z) w) reduces to z
10:48:11 <nak> in prelude: import Control.Monad.Identity    Error: Could not find module ‘Control.Monad.Identity’
10:48:13 <nak> :(
10:48:41 <dmwit> From the documentation, you can see this is in the `mtl` package. If you don't have this installed, you can install it with `cabal install mtl`.
10:48:47 <nshepperd> neophytes: then what is ((λn. z) ((λp.p)z))?
10:48:58 <dmwit> That will install it locally to your user, which is the recommended way.
10:49:16 <neophytes> n:= ((λp.p)z), but there is no n to replace it with. so it becomes z?
10:49:27 <nshepperd> neophytes: yep :)
10:50:02 <neophytes> ahhh i see
10:50:13 <neophytes> 𝜆𝑧(𝜆𝑛.𝑧)((𝜆𝑝.𝑝)𝑧) -> 𝜆𝑧.z is correct then
10:51:42 <nshepperd> just so
10:52:01 <nak> dmwit: the All About Monads (https://wiki.haskell.org/All_About_Monads) mentions that some monads are available in Prelude
10:52:17 <neophytes> ok thank you very much for your patience and taking the time to explain this to me so well
10:52:18 <nak> so Identity just isn't in Prelude then?
10:52:21 <neophytes> i highly apperciate it
10:53:04 <dmwit> nak: Correct.
10:55:18 <dmwit> nak: A comment I made to somebody else the other day might be helpful to you, too: a module (like `Prelude`, `Control.Monad`, or `Data.Functor.Identity`) is a collection of code snippets. A package (like `base`, `mtl`, or `parsec`) is a collection of modules. Cabal and stack also have a notion of a project, which is a collection of packages.
10:55:49 <dmwit> nak: `mtl` is a package with several modules that each define new monads, and so is quite a popular dependency.
10:56:47 <nak> dmwit: so is there a list of modules that ships with Haskell? or is it only Prelude?
10:57:08 <dmwit> Actually, there is a list of packages that ship with GHC. =)
10:57:23 <dmwit> So no, it is not only Prelude.
10:57:32 <nak> and sorry if this is starting to sprawl into too many questions: if i cabal install mtl, does that happen at the project level, or does it install "globally", ie available to any project?
10:57:42 <dmwit> If you run `ghc-pkg list --global`, you will see the packages that shipped with your version of GHC.
10:58:16 <dmwit> `cabal install mtl` will install into your user package database. Other cabal projects that list `mtl` in their dependencies will be able to use it without further effort.
10:58:37 <ryantrinkle> does anyone have an idea of the performance impact of using ContT over IO (compared with straight IO)?
10:59:15 <dmwit> However, there are some gotchas that have led people to prefer cabal sandboxes, which let you install packages local to a particular directory.
10:59:29 <dmwit> I wonder if there is a wiki page about the devops side of things.
10:59:46 <nak> dmwit: yeah i do a lot of node dev and packages are almost alwyas locally installed to a project
10:59:57 <nak> helps resolve version conflicts across various projects
11:00:17 <nak> i'm okay doing whatever is most common amongst haskell community for now tho
11:00:56 <dmwit> That is indeed the issue that sandboxes address.
11:01:08 <orion> What are proof assistants like Coq and Adga used for, and if I'm not a mathematician, do these tools have a use case?
11:01:19 <dmwit> So the pattern for a new project is to make a directory and run `cabal sandbox init`. Then `cabal install mtl` will install `mtl` to that sandbox only.
11:01:30 <suppi> nak: have read much but warm suggestion to use stack :)
11:01:38 <suppi> haven't
11:01:56 <Cale> orion: Well, observing aspects of what might be the future of programming languages?
11:02:22 <Cale> orion: Also, you *can* write software with them, and prove theorems about it
11:02:41 <Cale> orion: There is, amazingly, a pretty complete end-to-end C compiler in Coq
11:03:17 <orion> Cale: Why is it amazing?
11:03:18 <suppi> nak: this guide is pretty thorough i think http://howistart.org/posts/haskell/1/
11:03:42 <Cale> orion: Because Coq is really not geared toward practical application development
11:04:05 <nak> suppi: thank you. i put it on my list to "learn stack", gonna stick to my "problem" at hand for now
11:04:07 <dmwit> orion: Some of my coworkers have used Coq to help develop a model of vote tabulation and formally verify that an implementation adheres to the protocol.
11:04:17 <nak> suppi: so many things to learn!
11:04:30 <orion> Cale: I see. Isn't Haskell the future of programming languages? What does Adga have that Haskell won't (eventually) have?
11:04:34 <dmwit> orion: So it does see some use. But it is also a very expensive development model, because proved-correct code is much more difficult to write.
11:04:51 <Cale> orion: Actual dependent types. I would say Haskell is the present of programming languages.
11:04:51 <suppi> nak: is your problem "i don't have the package i want installed"?
11:05:05 <suppi> i may have misunderstood, sorry
11:05:13 <nak> suppi: no that is definitely my problem lol
11:05:14 <orion> Cale: Why can't Haskell have dependent types? Does System F now allow for it?
11:05:23 <nak> suppi: i ran "cabal install mtl"
11:05:32 <Cale> orion: Well, System F isn't dependently typed
11:05:36 <dmwit> orion: System F indeed does not support dependent types.
11:05:39 <orion> :(
11:05:40 <geekosaur> orion, dependent types break things that people tend to rely on.. .like type inference
11:05:42 <suppi> nak: then the simplest solution is to learn stack from the guide i linked :)
11:05:49 <nak> suppi: ok ok
11:06:00 <dmwit> nak: You should already have it if you ran `cabal install mtl`.
11:06:03 <Cale> geekosaur: Yeah, well, there's probably stuff you can do in practice to help that along.
11:06:09 <dmwit> nak: Of course feel free to learn `stack` if you like.
11:06:27 <dmwit> nak: `stack` vs `cabal` tends to evoke strong opinions from people.
11:06:32 <Cale> geekosaur: and it's also worth noting that dependent types also *enable* term inference to a large extent
11:06:41 <nak> i figured it might have such an effect
11:06:46 <nak> like bower vs npm vs yarn
11:06:51 <nak> people love their package managers
11:06:53 <orion> dmwit: How exactly does this development model work? In other words, someone hires me to build a "thing", and I want to use Adga or Coq to prove that my deliverable (written in, say, Haskell) is correct.
11:07:18 <suppi> i don't love stack nor hate cabal btw, i use both :)
11:07:27 <dmwit> orion: I think a common way is to implement it in Coq and extract that code to Haskell or ML.
11:07:33 * geekosaur would be less annoyed at stack if he didn;t keep hitting blogs that very carefully make sure to only mention fpco-run sites/web pages
11:07:40 <Cale> orion: But also, Haskell's syntax would have to change a bunch to make dependent types not be shitty, I feel
11:07:47 <Cale> in ways that would break lots of libraries
11:08:01 <Cale> Like, currently types and terms in Haskell live in entirely separate namespaces
11:08:10 <orion> I see.
11:08:10 <brynedwards> dmwit: Thank you =)
11:08:12 <Cale> and we reuse identifiers at both levels all the time
11:09:21 <Cale> GHC is sort of edging toward dependent types, but what's there is kinda awkward to use relative to something that was designed for it from the start
11:10:01 <geekosaur> ...and fpco didn;t go out of their way to make said pages look exactly like the official ones except they only mention fpco which is clearly and obviously presented as the maintainer of everything worthwhile involving haskell
11:10:08 <geekosaur> it feels like a hostile takeover attempt
11:10:12 <nak> fwiw i have ghc-8.0.2 cabal-install-1.24.0.2 and stack-1.3.2 (hpack 0.15.0), are these versions current enough? (all were installed through homebrew on osx)
11:10:43 <MarcelineVQ> nak: looks pretty recent to me
11:11:31 <nak> MarcelineVQ: thx ^^
11:11:45 <dmwit> nak: Those were all released in the last four months.
11:11:55 <dmwit> So quite recent.
11:12:14 <Cale> orion: But yeah, Coq in particular has been around a fairly long time actually -- some bits of it feel older than Haskell (its term syntax especially is clearly influenced by older MLs)
11:12:37 <Cale> orion: But yeah, dependent types let you say a whole lot more than you can say with Haskell's types
11:12:41 <orion> dmwit: Could you contrive an example of a project that, if just done in Haskell could lead to unintended consequences, but if I had only done it in Coq first I would be fine?
11:13:02 <dmwit> orion: You can write bugs in any project.
11:13:37 <orion> Right. Therefore, I am not convinced of the value proof assistants bring to the table.
11:13:47 <Cale> Note that you can still write bugs in Coq or Agda, it's just you have more tools for saying what you mean and having the computer check things.
11:14:02 <Cale> For example, you might want to express that a sort function actually sorts a list.
11:14:09 <JuanDaugherty> Coq is general purpose now?
11:14:31 <Cale> JuanDaugherty: Well, it is with sufficient heroism :)
11:14:46 <Cale> It's certainly not aimed at being general purpose for the most part
11:14:48 <JuanDaugherty> (as distinct from ocaml)
11:14:53 <dmwit> orion: Bugs are much, much less common in proved-correct Coq projects, because usually you don't create the exact same bug in both the spec and the implementation; and because the machine checks the correspondence between the spec and the program.
11:15:37 <dmwit> orion: For example, famously fuzzers tried out all the major C implementations and found hundreds of bugs in gcc and clang, but only two in compcert -- and they were in the unverified part of compcert.
11:16:01 <JuanDaugherty> thinking that all computing needs to be proofs is ... .
11:16:15 <JuanDaugherty> (cast as you will)
11:16:24 <Cale> orion: Once you can have types which are parameterised by values, one of the first things you can do is to define a type which, given a type, and two values of that type, expresses the fact that those values are equal
11:16:40 <dmwit> If correctness is at a premium, I think the data very much support using Coq or the like.
11:17:13 * JuanDaugherty searches mind for a negative form of "mathesis"
11:17:28 <Cale> You do that by only giving the type a single constructor:  Refl :: Id A x x
11:17:34 <dmwit> JuanDaugherty: yo' thesis
11:17:47 <JuanDaugherty> dmwit, lol
11:19:28 <Cale> orion: and that lets you describe equations between things, and if you can somehow (perhaps using a recursive definition) define something of type Id A x y, then you know that x and y must be equal
11:19:53 <orion> I'm completely unfamiliar with proof assistants. Let's say I am creating some Pokemon-style card game. Given all the rules and all the defined cards, could a proof assistant inform me of any loopholes in the rules?
11:20:16 <jle`> you'd have to define what loophole means
11:20:18 <Cale> If you can say what a loophole is, you could prove that there are no loopholes
11:20:46 <orion> Interesting.
11:20:56 <Cale> It probably won't be able to just *inform* you -- it'll still require work.
11:21:16 <Cale> But how much work will depend on the definition of loophole :)
11:21:25 <erisco> finding the right questions to ask and figuring out the model are the hard parts
11:21:49 <Cale> orion: You can basically do all of mathematics in Coq's type system
11:22:09 <Cale> So anything you can reasonably imagine writing a mathematical proof about is probably going to be fair game
11:22:18 <erisco> you can come write Idris code with me :3
11:22:34 <monochrom> Yeah, Idris is a much more gentle introduction.
11:22:38 <Cale> Yeah, Idris is another one we ought to be mentioning
11:22:39 <orion> Cale: Right, but I am not necessarily a mathematician. Business people give me money to solve their problems, and I want to provide a proven solution.
11:23:43 <erisco> well it doesn't come for free. There is substantial cost to having more elaborate types
11:25:03 <erisco> when you consider the practical effect of bugs it may not be worth it
11:25:36 <erisco> if it is safety, finance, security, and things of this nature then it is well deserved
11:25:51 <erisco> but if you're tasked with adding a popup box when the user clicks a button on the web page...
11:26:08 <JuanDaugherty> yeah bebugging used to be an engineering technique back when software engineering was a thing
11:26:09 <orion> erisco: I am in the financial payment industry.
11:27:27 <bodisiw> i always want to formalize business rules and SAT check them
11:27:33 <bodisiw> but it has never worked out :-)
11:27:38 <orion> bodisiw: Why?
11:28:19 <bodisiw> because i want business rules to be consistent?
11:28:51 <orion> Just force your customers to be 100% consistent. That's a strategy for success.
11:29:15 <reactormonk> How can I you get the primitive type out of a newtype?
11:30:41 <domenkozar> is it possible to install older stack version on windows?
11:31:14 <StoneToad> reactormonk: you mean like unFoo (Foo x) to get x?
11:32:05 <reactormonk> StoneToad, newtype Foo = Foo Text -- get Text from Foo. Yeah.
11:32:08 <cocreature> reactormonk: get the type or get the value of that type?
11:32:14 <reactormonk> cocreature, value.
11:32:25 <cocreature> reactormonk: you can define newtype Foo = Foo { unfoo :: Text }
11:32:50 <StoneToad> you could also define the same function manual as unFoo (Foo x) = x
11:33:12 <orion> dmwit / Cale: Do you know of any case studies of proof assistants in business? I.e. "Our business had to do a /thing/ and Coq helped us do the /thing/!"
11:33:58 <StoneToad> manually*
11:34:51 <jlouis> shapr: w.r.t. parsing binary data in Haskell: Use an applicative instance to define how to decompose the stream. This is what I did back in the day, but I've been out of the loop for too log
11:35:04 <erisco> I'd be interested to hear as well
11:35:14 <erisco> I don't think there is much uptake, otherwise I'd expect to see more activity
11:35:17 <monochrom> reactormonk: Also pattern matching. You do have the data constructor "Foo" (the second one) to match against.
11:36:04 <shapr> jlouis: ok, thanks
11:36:10 <jlouis> shapr: the key takeaway from Erlang is that binary matching is very good as a way to handle complex binary protocols. And it is fast enough in practice to work out
11:36:12 <reactormonk> monochrom, yeah, that would be the manual definition StoneToad mentioned.
11:36:42 <erisco> you need a team of highly educated people to use the tools
11:36:56 <monochrom> But I had "case ... of Foo t -> ..." in mind.
11:36:58 <jlouis> shapr: also, look up something like Meredith Patterson's work on "Hammer". Parsing should be left to combinator libraries
11:37:08 <jlouis> shapr: for security reasons
11:37:08 <erisco> and if you're not one of those people then how are you going to be convinced to seek out those hires
11:37:31 <erisco> versus looking at what everyone else is doing
11:37:54 <orion> erisco: Speaking to me?
11:37:56 <jlouis> erisco: from lots of real-world Erlang QuickCheck experience: the load factor is 3-5 times the development time on QC models. But upshot is that you have almost no maintenance afterwards on the code
11:38:05 <erisco> yes
11:38:46 <orion> erisco: Define "highly educated".
11:39:03 <jlouis> IMO something like Coq has a larger load factor than that. You need something where the cost/benefit analysis pans out to an advantage
11:39:23 * monochrom grins. Adding numbers used to be exclusive to the highly educated too. :)
11:39:29 <erisco> if you were to learn everything just from school then you need graduate education
11:40:34 <jlouis> In short: measure a project as a whole, not just to the point where the system is deployed, and formal methods tend to win in the long run. Especially for things which are 1) Used by lots of people. 2) Correctness sensitive.
11:40:40 <erisco> jlouis, that is interesting. so if it is 3-5x cost to get something out the door that's a tough sell
11:41:05 <jlouis> erisco: yes, unless you happen to work in part of the system where this is a benefit
11:41:07 <cocreature> erlang quickcheck is still testing not verification, no?
11:41:17 <monochrom> It is very much short-term very long-term. (Under an assumption.)
11:41:17 <jlouis> It is just testing, indeed
11:41:29 <cocreature> the cost of proving things is a lot higher
11:41:43 <jlouis> yes. A load factor of 10-30 is not unheard of
11:41:44 <monochrom> (The assumption: The pro-short-term people intend good rather than intend scam.)
11:42:02 <jlouis> It can be improved if you can redesign the system as you go along with the proof
11:42:11 <jlouis> same for QC
11:42:41 <erisco> you want to sell early so you have income
11:42:44 <jlouis> I did the Erlang QC model for the "maps" feature (HAMTs) in Erlang. We found around 10-15 bugs, about 5 of them serious
11:42:51 <erisco> not so early that everyone hates you, but not so late that you go bust
11:43:13 <jlouis> And they would have had impact on a lot of people since this is part of the stdlib
11:43:48 <jlouis> Attack something with Money, or something where Nuclear fallout happens on error
11:44:01 <jlouis> Or planes falling from the sky
11:44:12 <jlouis> Or Mars Reentry happening at light speed
11:44:42 <cocreature> maybe we’ll figure out automating formal verification too a larger degree than we can atm at some point in the future :)
11:44:50 <jlouis> Distribution protocols are also notoriously hard to get right
11:44:57 <jlouis> TLA+ the hell out of those, etc
11:46:13 <jlouis> Another point is that there is no liability in software, so the sky doesn't fall when you mess up. If we had more liability, we would probably standardize on components where it is more likely to test them
11:46:55 <jlouis> The current world of ${STARTUP} and move fast and break things isn't particularly amenable to formal methods, except for a few places, IMO.
11:47:22 <jlouis> </rant> :)
11:48:37 <cocreature> tbh I don’t blame them. in a lot of cases the cost of formal verification is probably higher than the costs of bugs prevented by formal verification
11:49:20 <monochrom> Things did and do get very complicated, subtle, and messy because of that. (Most software developers having not much liability.)
11:50:09 <monochrom> For example it is obvious to you that wrong firmware on a plane can cause plane crashes, and that when this actually happens whom to blame.
11:50:19 <jlouis> cocreature: yeah. QuickCheck is often easier. And it tend to find many of the same bugs. And it paves the way for a formal proof later as it is helping define the spec
11:51:00 <monochrom> Not so obvious is CAD software used during the design of the plane can cause this too. And when this happen it is going to be a huge controversy.
11:51:39 <orion> monochrom: People getting killed in self-driving cars is another example.
11:51:53 <cocreature> often it is also simply unclear what you are even trying to verify. if you have some kind of isolated component where it is clear what it should do all is good, but good luck defining what your random webapp is supposed to do
11:52:58 <jlouis> cocreature: this is what we tend to do with QuickCheck. We write a naive spec as a model and then we check if the system has this model. Tune the model. Repeat. 
11:53:16 <jlouis> Suddenly it starts finding stuff the system shouldn't be doing
11:53:27 <jlouis> it isn't a proof, but the goal of QC is to find bugs
11:53:42 <jlouis> this finds bugs. Subtle bugs.
11:54:38 <cocreature> jlouis: what kind of systems are we talking about here? it’s relatively clear how to write a specification a data structure like HAMTs (it’s still a lot of work) but for some random webapp it’s less clear what it is even supposed to do
11:54:41 <jlouis> And it starts the road of having a spec in the first place
11:54:59 <cocreature> and sometimes the behavior changes too fast to justify the cost of having to adapt a spec at each step
11:55:09 <jlouis> HAMTs are easy actually. Your model is just [{K, V}] for key/value types
11:55:11 <monochrom> This is why I don't draw a line between testing and verification. Tests are proofs, too.
11:55:36 <jlouis> Add to this that K's should be generated such that you have lots of HAMT collisions, and you have almost 100% code coverage
11:56:15 <jlouis> monochrom: indeed! like types are. 
11:56:28 <cocreature> don’t get me wrong, I work on formal verification myself. but I think there are legitimate reasons to not verify your code or even develop a spec
11:57:33 <jlouis> cocreature: https://github.com/jlouis/fuse https://github.com/jlouis/safetyvalve and https://github.com/jlouis/dht are three projects with QC models (all Erlang.. I ate an apple 10 years ago)
11:58:53 <jlouis> And yes, there is a lot of code that shouldn't be tested
11:59:18 <cocreature> a friend of mine formally verified the correctness of Java’s dual-pivot quicksort implementation. it took him a full year and even then he had to rewrite the code in some places to make it more amenable to the tool he used
11:59:21 <jlouis> CompCert has this nice example where register allocation is written in (unverified) OCaml, but you can always verify the coloring when it comes back
11:59:59 <jlouis> And there is lots of code which shouldn't be formally verified since it isn't worth doing so
12:01:58 <erisco> cocreature, I imagine he had to first model how Java works, and that would have been a chore
12:02:44 <cocreature> erisco: nah, there are already tools that include formal models of subsets of Java and if you’re lucky your code only uses these subsets
12:03:26 <geekosaur> parts of xmonad are formally verified (...thereby proving that you can't formally verify a sane UX)
12:03:35 <nomeata> Hi. I could need a little help playing around with dependent type ideas in Haskell. I have a 'data Tag = A | B', a 
12:03:41 <erisco> I read a while ago that there was a bug found in Tim sort (Python's sort) when it was verified
12:03:47 <cocreature> yep
12:03:52 <cocreature> they used the same tool https://www.key-project.org/
12:04:05 <cocreature> they verified Tim sort in java
12:04:22 <cocreature> tim sort is used for objects and double pivot quicksort  is used for primitive types iirc
12:04:35 <monochrom> I haven't learned dual-pivot quicksort, but it sounds like the kind of subtle algorithm that if you taught it to most undergrads, they would be lost.
12:05:08 <monochrom> In other words a very subtle algorithm, if it's correct afterall, requires a non-obvious proof of course.
12:05:09 <erisco> does it partition on <, =, and > ?
12:05:25 <cocreature> I don’t remember :)
12:05:58 <erisco> I get why it exists, but it is funny to have this for Java
12:06:10 <erisco> retrofitting to the extreme
12:06:32 <cocreature> monochrom: it’s even worse when you’re talking about parallel quick sort. one of the parallel versions uses one pivot per processor
12:06:43 <nomeata> Hi. I could need a little help playing around with dependent type ideas in Haskell. I have a “type level state machine” consisting of 'data Tag = A | B',  'data Family Action :: Tag -> *' and 'type family Next :: Action t -> Tag'. Now I have a 'data familiy State :: Tag -> *', and I want to implement a function 'transition :: Event -> State s -> (a :: Action, State (Next a))', but such dependent products do not exist in Haskell yet. How owuld I encode that?
12:07:58 <monochrom> Did you know: Spec# is "from the makers of ESC/Java", and the transition is really the transition from "working at Digital/Compaq" to "working at Microsoft"? :) (Also, it was ESC/Modula before ESC/Java.)
12:08:36 <erisco> nomeata, can you briefly describe what roles Action, Next, and State play?
12:09:43 <monochrom> ESC/Java is now unmaintained therefore. But another Java model, more recent and alive, is in ACL2.
12:09:54 <cocreature> monochrom: spec# is also dead 
12:10:02 <erisco> if your state machine were a graph, what is each of these? I presume State is a labeled vertex
12:10:11 <monochrom> Darn. It was so good while it lasted.
12:13:02 <nomeata> erisco: `data instance Action A = StayInA | GoToB`, for example, with `type instance Next GoToB = B`
12:13:33 <nomeata> erisco: and `State` would capture the actual state of a state machine (e.g. state of the UI elements)
12:13:39 <erisco> okay, so, Action are edge labels
12:13:50 <reactormonk> How would you flip type arguments?
12:13:57 <lpaste_> allenj12 pasted “haskell error messages?” at http://lpaste.net/353570
12:14:01 <nomeata> Via another channel I learned that I will probably not get around defining singletons for the `Action` constructors.
12:14:07 <erisco> type Flip f a b = f b a
12:14:07 <reactormonk> similar to the value-level flip.
12:14:43 <erisco> but if you want to partially apply you need  newtype Flip f a b = Flip (f b a)
12:14:46 <geekosaur> allenj12, it means you are trying to add or subtract from something whose type is (Int, Int) and there is no standard Num instance for that type
12:15:15 <tfc> hey there, i am currently running a "forever-running" shell command in my haskell app with createProcess. then read some output with hGetLine for some lines until i stop being interested in its output and then use terminateProcess to get rid of it again. i realize that terminateProcess is maybe not the right thing becasue i would normally kill it with STRG+C as a normal shell user. any alternative?
12:15:27 <geekosaur> (Haskell's numeric hierarchy is extensible, and there are actual uses for that type in some situations; but not commonly enough that the standard libs support it)
12:16:01 <geekosaur> tfc, terminateProcess is actually the correct thing for noninteractive use like that
12:16:11 <geekosaur> (n particular, on Windows)
12:17:04 <tfc> geekosaur: even if it is a network application? i am worrying that it might be dangerous
12:17:26 <erisco> nomeata, how about a type family S' :: State s -> Action a -> State s  ?
12:17:32 <monochrom> Normal shell user uses SIGINT because users are lazy and the shell makes SIGINT easy but SIGTERM difficult.
12:17:50 <geekosaur> tfc, *something* is running locally. and if it's not handling SIGTERM properly then you're probably screwed anyway
12:18:14 <geekosaur> like someone ctrl-alt-del at the wrong time could corrupt the remote --- this is BAD
12:18:36 <erisco> or something like that
12:18:37 <geekosaur> (among other things that will send all processes SIGTERM, wait a bit, then SIGKILL anything that didn't go away by itself)
12:18:39 <tfc> i see. so if that app i am executing is handling terminateProcess correctly, then i do not have to worry?
12:18:43 <erisco> it is tough for me to get a picture of what you're trying to do
12:18:44 <geekosaur> yes
12:18:54 <Tuplanolla> You probably want to use both `Control.Exception` and `System.Posix.Signals`, tfc.
12:19:03 <tfc> ok, thank you
12:19:17 <geekosaur> Tuplanolla, only if they control the program being run; they;re bnot helpful in the one doing the running
12:20:06 <monochrom> Yeah we're talking about the parent process.
12:20:08 <allenj12> geekosour: interesting, im looking at it more but I cant find any instance, I only found an error in the Then statement. how come it dosnt list a specific location?
12:21:29 <nomeata> erisco: Yes, I guess I should get myself clearer what I am trying to do :-)
12:21:34 <Tuplanolla> Oh, well, there's not much the parent can do.
12:21:47 <geekosaur> allenj12, it "did", it told you exactly what is triggering it
12:21:58 <geekosaur> not by line/column but by the text of the expression
12:22:01 <erisco> nomeata, there are many ways to have a state machine, is the problem
12:22:07 <rbnnn> Hello. I have recently become interested in functional programming. Can anyone give me a resource that tells me why copying thins all the time isn't super slow? It defies how I think about things so I guess I'll learn something
12:22:25 <geekosaur> (go 0 []) is producing something that is being used as a Num instance ("a number") --- but its actual type is (Int,Int)
12:22:59 <geekosaur> this is not automatically illegal because there are cases when you *wnt* that to have a Num instance. this just isn't one of them
12:23:18 <barrucadu> rbnnn: Copying things all the time is super slow! However, when all data is immutable, the compiler can often avoid copying.
12:23:28 <erisco> nomeata, generally speaking you can use singletons to emulate the dependent pair
12:23:32 <barrucadu> For example, prepending an item to a list doesn't necessitate copying the tail.
12:23:58 <nomeata> erisco: thanks, I will dig deepter in that direction.
12:24:12 <rbnnn> barrucadu: I sorta get it... Compiler can defer reading/copying because the source object does not change.. Do you have any reading?
12:24:14 <erisco> nomeata, so this will look like  (Sing (Action a), State (Next a))
12:24:40 <barrucadu> rbnnn: Not really, and unfortunately I have to go out now. But perhaps someone else will.
12:24:56 <rbnnn> alright, have a good day/night wherever you are
12:25:07 <monochrom> allenj12: What does l++[0] mean? where l = [(1,1), (2,3), (3,1)] for example. So, what does [(1,1), (2,3), (3,1)] ++ [0] mean?
12:25:17 <geekosaur> allenj12, specifically when the recursion bottoms out you are producing a tuple (line 26 in your paste).
12:25:17 <erisco> nomeata, or something like that, not sure how all your pieces work
12:25:30 <allenj12> monochrom: I messed up in a couple spots that didnt change the error let me update it
12:25:54 <lpaste_> allenj12 revised “haskell error messages?”: “haskell error messages?” at http://lpaste.net/353570
12:26:21 <monochrom> OK, then this should have an error.
12:26:30 <monochrom> err, this shouldn't have an error.
12:27:51 <allenj12> monochrom: still is :(
12:27:56 <geekosaur> result is a list of tuples, it gets produced when recursion bottoms out, the expected type should be [Int] per the signature of mul, not [(Int,Int)]
12:28:10 <monochrom> No, I just tried on my ghci. No error.
12:28:12 <geekosaur> but I don't see how this triggers a Num instance issue instead of a simple type mismatch
12:28:31 <geekosaur> oh wait, I'm conflating two `result`s, whoops
12:28:36 <allenj12> im using a ghci instance in emacs, let me restart it
12:28:48 <allenj12> geekosaur: my naming is horrible, my fault
12:28:50 <allenj12> :D
12:29:19 <monochrom> Yeah I abstracted away from the detailed code of step.
12:29:40 <Cale> allenj12: In any case, that error generally means that you used an (Int, Int) pair as if it were a number.
12:29:49 <allenj12> monochrom: it works now, looks like i just needed to restart my instance
12:29:52 <Philipp> Hey guys. Just started to learn haskell after many years on imperative languages and I think it is awesome :D
12:30:00 <Cale> also, it's customary to line up the 'then' and 'else'
12:30:21 <allenj12> Cale: yea which was right, was just really hard to pin down for me. I will get use to it with time. Also thanks for the style tip
12:30:29 <Cale> Philipp: Nice! Feel free to ask any questions you might have.
12:30:46 <Philipp> Yeah, I think, I will. Thanks!
12:31:11 <monochrom> In this case it was using 0 as if it were a tuple.
12:31:30 <Philipp> But i'm still searching where I can apply haskell 
12:31:40 <Rembane> EVERYWHERE!
12:31:55 <Cale> Philipp: I use it for almost everything
12:32:28 <Cale> Philipp: At the place where I work, we build web applications for various clients, and write both the frontend and backend in Haskell
12:32:29 <Philipp> I love Lua and ++ too, I think, they will be offended at me
12:32:45 <Rembane> Cale: Do you use ghcjs to turn Haskell into Javascript?
12:32:48 <Cale> yep
12:33:00 <Rembane> Cool.
12:33:00 <Cale> and we use Reflex-DOM
12:33:09 <Cale> which is amazing :)
12:33:11 <Rembane> :D
12:33:16 <Philipp> So, am I right, that Haskell can do almost everything?
12:33:34 <Rembane> Philipp: it isn't very good at embedded programming, but not much is
12:33:37 <monochrom> You can use Haskell wherever you are proficient enough with Haskell. Which means almost nowhere for now but almost everywhere in the future when you get good.
12:33:58 <monochrom> But that's tautological because it's true of every language.
12:34:17 <Philipp> Is there any games on haskell? 
12:34:23 <Cale> There are a few.
12:34:31 <monochrom> Even when you heard "C is widely used in system programming", you could still not do it yourself when you were a beginner.
12:34:43 <Philipp> Yeah, I understand this
12:35:04 <grayhatter> monochrom: I disagree
12:35:09 <kadoban> Not many games, a couple? It's maybe not the best choice if your goal is like FPS games, just because not many have gone before you.
12:35:20 <Philipp> Right now I am on the first chapters of learnyouahaskell, so I can't fully understand whole power 
12:35:21 <grayhatter> I could write a game much faster in java, than in haskell
12:35:33 <grayhatter> I would say EVEN faster in python, but I already know much more python
12:35:39 <Cale> I actually believe that Haskell will eventually be an amazing language in which to write games
12:35:53 <Cale> It's just that the pieces have not all come together quite yet.
12:35:59 <grayhatter> like any tool, it's the job of the person holding it to use it correctly
12:36:01 <bodisiw> Philipp, i have been at it a few months, and i just looked back over the cheat sheet i tried to use as a shortcut initially... and now i understood most of it!
12:36:10 <grayhatter> I could build a house with just a machette
12:36:25 <grayhatter> but it'd be faster to use a table saw+hammer
12:36:44 <MarcelineVQ> Cale: compact regions being a major piece in that direction, if I understand them anyway
12:36:55 <Philipp> No, I'm not going to make games on haskell. But I'm really interested in some random-generation with it 
12:37:02 <Philipp> Mazes/dungeons/etc
12:37:09 <Philipp> I think it should be very good at it
12:37:13 <grayhatter> Philipp: lol, haskell doesn't do random
12:37:28 <grayhatter> err
12:37:31 <Philipp> Ok, then I will find some new purposes :D
12:37:33 <Cale> MarcelineVQ: I dunno -- I don't see GC as a huge obstacle actually.
12:37:36 <grayhatter> rather: haskell doesn't do IO
12:37:59 <Cale> MarcelineVQ: Of course, it depends on how much allocation pressure your game is going to have!
12:38:24 <monochrom> No, I use Haskell for both random and IO all the time. https://github.com/treblacy/random-read
12:38:39 <Cale> grayhatter: Haskell does IO
12:38:40 <Philipp> monochrom: Who should I believe?
12:39:02 <monochrom> I have actual code right there. Do not believe people. Believe actual code.
12:39:19 <grayhatter> if I write a haskell libaray, and then use that libarary in C or python or [other], won't it's lazyness lose it's benifit?
12:39:38 <Tuplanolla> I don't see Haskell ever making it into hpc, but anything else should be within its reach.
12:39:49 <Cale> Philipp: I'm paid to write web applications entirely in Haskell. If Haskell didn't manage I/O well, my job would be pretty silly.
12:40:03 <kadoban> grayhatter: "haskell doesn't do IO" ... what?
12:40:04 <grayhatter> can haskell even return ([1..]::Int) 
12:40:18 <Philipp> By the way, is haskell could be used with some other languages? Or it is only standalone?
12:40:22 <bodisiw> could there be a distributed thunk haskell Tuplanolla?
12:40:47 <kadoban> Philipp: It has FFI to C and with GHCJS to JavaScript. Other languages can be reached through C, most languages have a C FFI.
12:41:03 <Philipp> Probably, I don't need anything except C
12:41:16 <shapr> grayhatter: are you learning Haskell?
12:41:17 <grayhatter> kadoban: Cale monochrom I was making a subtle joke that Haskell was written with other goals in mind. Haskell can do IO just fine, but saying haskell does IO is like saying python does speed
12:41:38 <Cale> grayhatter: GHC's IO manager is excellent
12:41:49 <shapr> grayhatter: Would high throughput Haskell apps be a good counter-example?
12:41:54 <Cale> It has an n:m thread scheduler which is very fast
12:41:57 <grayhatter> Cale: GHC != Haskell
12:42:03 <grayhatter> *arguably
12:42:04 <kadoban> grayhatter: It's both not and "python does speed" isn't nonsensical either. Haskell is a perfectly fine imperative language, including doing IO operations.
12:42:08 <Cale> GHC is what everyone programming in Haskell seriously uses.
12:42:16 <Cale> GHC and GHCJS
12:43:05 <Cale> grayhatter: http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf -- check this out
12:43:11 <Philipp> Oh, by the way, is "learnyouahaskell" good enough? 
12:43:17 <Philipp> Or can you advice something better?
12:43:23 <grayhatter> Cale: sure, but my assertion wasn't that GHC makes haskell, more like; because the compiler compiles something nicely, doesn't mean it's best use
12:43:30 <kadoban> grayhatter: Haskell isn't cool because IO/imperative is hard, it's cool because the type system can understand the difference between imperative code and pure code.
12:43:32 <shapr> Philipp: I like haskellbook.com best right now
12:43:50 <shapr> Philipp: it does cost $60, but it also comprehensive with many excellent homework exercises
12:43:59 <shapr> Philipp: if you want free, there's cis194
12:44:02 <shapr> @where cis194
12:44:02 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
12:44:03 <kadoban> Philipp: LYAH is pretty not good on its own. I'd do haskellbook.com (not free), or cis194 spring '13 along with LYAH. The former greatly preferred.
12:44:52 <grayhatter> kadoban: sure, but until you learn a style that NO other language uses haskell is a broken style
12:45:18 <shapr> grayhatter: wait what?
12:45:20 <Cale> grayhatter: Well, if you're talking about how good Haskell is at expressing I/O, I'll still disagree with you -- Haskell is my favourite imperative language by far, and there are also non-imperative ways to handle I/O as well. In fact, I spend a lot of my time at work using Reflex-DOM, which is a library built atop Reflex, a functional reactive programming library.
12:45:26 <kadoban> Not really following what you're saying there, grayhatter
12:45:30 <grayhatter> learn how to drive an automatic car, and then learn a stick. while both have advantages, one seems broken until you learn how to use it
12:45:55 <Philipp> I mean, is it good enough to just feel the language? 
12:45:56 <shapr> oh, I see ... you're saying that the Haskell style is unique and thus appears nonsensical from the outside?
12:45:58 <Cale> It lets me declaratively express what the DOM ought to be and the interactions between the things which affect it.
12:46:09 <shapr> grayhatter: that sounds like support for Paul Graham's blub paradox
12:46:13 <grayhatter> shapr: that's much closer to what I meant
12:46:14 <Cale> and takes care of all the I/O involved in that
12:46:39 <kadoban> Philipp: LYAH? It's good enough to maybe kinda sorta give you a taste. Just don't expect to come out the other end actually able to write much/any haskell code, unless you do much more beyond LYAH than just read it.
12:46:54 <grayhatter> shapr: the problem with haskell (other than no one really understands monads) is people who use it are all too smart
12:46:57 <Philipp> Yeah, I understand
12:47:01 <shapr> grayhatter: I agree, my coworkers find it difficult to understand why a Functor instance for everything is so powerful.
12:47:17 <Philipp> My problem is that haskell is my first functional language
12:47:26 <Cale> So, we build web applications and our default is to have everything live updating, because the FRP library makes that easy -- you almost have to go slightly out of your way to freeze things :)
12:47:29 <grayhatter> #haskell is a GREAT example of this
12:47:32 <shapr> grayhatter: I got a job writing Haskell before I'd ever taken a college course in math or CS
12:47:40 <shapr> grayhatter: so I have anecdata that disagrees.
12:47:53 * geekosaur has zero degrees
12:47:55 <kadoban> grayhatter: Monad is way overblown.
12:47:57 <shapr> grayhatter: in my opinion, people believe that Haskell is scary, and that's the real problem
12:48:02 <davean> shapr: can we use you as an exemplar of anything never?
12:48:03 <Cale> grayhatter: I understand monads. There's really not a whole lot which needs understanding about them to use Haskell (and I understand a fair amount more than that)
12:48:04 <grayhatter> I'll ask a question and get a GREAT technical example that makes NO sense
12:48:12 <shapr> grayhatter: I just got a degree three years ago! after fifteen years of a career
12:48:12 <grayhatter> until I understand everything about it
12:48:15 <shapr> davean: that's a fair point
12:48:34 <grayhatter> shapr: no
12:48:36 <geekosaur> also tryinbg to approach Monad from the math view is entirely incorrect. Haskell Monad *is not* the CT construct; it's merely inspired by it, and for almost all purposes you don't care
12:48:36 <Cale> grayhatter: I mean, you can't expect to understand everything all at once of course :)
12:48:37 <grayhatter> here
12:48:43 <shapr> grayhatter: no what?
12:48:47 <grayhatter> let me find the page that made me NOT hate haskell
12:48:48 <Cale> geekosaur: Well, that's a little unfair
12:48:52 <monochrom> "the right tool for the right job" taken to an exclusive extreme (like languages are mutually disjoint) is also another real problem.
12:49:00 <Cale> geekosaur: It really is the CT construct -- it's an example of it anyway
12:49:13 <bodisiw> Philipp, if you like video, i really found the 'Modeling Data in Haskell for Beginners' talk on youtube helpful... by the same guy as wrote haskellbook.com
12:49:25 <Cale> geekosaur: But you don't need to understand that in full generality just to use it in Haskell
12:49:32 <Philipp> Is it a bad that I found haskellbook for free?
12:49:45 <Cale> heh, ask bitemyapp 
12:49:45 <monochrom> My random-read program could be written in C, Perl, or Haskell equally fine.
12:50:03 <shapr> Philipp: I met one of the authors recently, she's writing another book. In my opinion, if you get benefit from the book, buy a copy!
12:50:29 <grayhatter> https://wiki.haskell.org/Haskell_IO_for_Imperative_Programmers
12:50:45 <grayhatter> I've been "writing" haskell for weeks before I read this 
12:50:48 <Philipp> Yeah, I agree with that. But I still not sure, if I will get any benifit from that book
12:50:53 <grayhatter> and I hated every bit of it
12:51:02 <kadoban> Philipp: The author(s) might think so. It probably depends on your morality construct I guess (don't even mean that in a judgemental way). If you have the money though and get something out of it, maybe try to buy a copy if feasible. The authors are pretty cool and helpful and put a lot of work into that book.
12:51:04 <shapr> grayhatter: but now you're in love with Haskell?
12:51:24 <grayhatter> The problem is imperative-think... the virtues of laziness. 
12:51:26 <grayhatter> no
12:51:28 <grayhatter> I still hate it
12:51:32 <grayhatter> but at least I like working with it now
12:51:34 <shapr> ah, so why participate here?
12:51:47 <Cale> grayhatter: It took me a couple of months to feel like I could do anything useful with Haskell and about a year to be "comfortable" for some definition of the word
12:51:48 <grayhatter> shapr: because it's hard
12:51:49 <Philipp> kadoban: I would be happy to buy copy, but I don't have any money for now
12:51:53 <grayhatter> and I don't understand it
12:51:55 <shapr> hate is hard? I'm confused.
12:52:14 <shapr> oh, Haskell is hard?
12:52:22 <grayhatter> right
12:52:24 <monochrom> I recommend not thinking in terms of "love", "hate", "broken".
12:52:25 <Cale> grayhatter: and I started out knowing at least a dozen programming languages fairly well (though a shortage of functional ones among them)
12:52:30 <shapr> grayhatter: You have a surprising amount of global state in your sentences :-P
12:52:47 <grayhatter> lol, sorry
12:52:59 <monochrom> For example I wouldn't say "C is broken" even though I align with Haskell's way.
12:53:08 <grayhatter> I'm also home sick, so I'm likely a lot less sensical than I think I am
12:53:12 <Cale> Now I've probably used more than twice that number a fair amount, and a wider variety among them, and Haskell is still what I reach for in most practical tasks.
12:53:21 <Philipp> Anyway, thanks for help
12:53:28 <davean> monochrom: being broken suggests something is defined enough to be wrong!
12:53:30 <shapr> Philipp: come on down and ask more questions next time!
12:53:32 <grayhatter> monochrom: you're right, nothing is really broken. 
12:53:38 <Philipp> Yeah, I will! 
12:53:40 <Cale> davean: :D
12:53:40 <kadoban> Philipp: Good luck in your learning, definitely come back when you run into trouble, or regardless :)
12:53:44 <Philipp> Good night everybody
12:53:49 <grayhatter> I meant more a position as opinion, not as backed up by reason
12:53:50 <Cale> Good night!
12:54:00 <davean> monochrom: I think C is a wonderful assembly tempalte language
12:54:27 <Cale> grayhatter: But I highly encourage you to sit around here and absorb things by osmosis and ask questions whenever you hit something that you're struggling with
12:54:38 <shapr> grayhatter: I concur
12:54:41 <grayhatter> Cale: I often do
12:54:53 <Cale> It doesn't stay frustrating forever :)
12:55:05 <grayhatter> no, it's not too fustrating anymore
12:55:13 <shapr> On the downside, all the other languages suddenly get frustrating :-(
12:55:17 <grayhatter> no more than any other language at this point
12:55:58 <grayhatter> once I finally understand haskells assoiative syntax, I'll stop hating it
12:56:12 <shapr> that sounds like a positive change
12:56:49 <grayhatter> and/or someone fixes the syntax highlighter in sublime text
12:57:38 <reactormonk> grayhatter, emacs works nicely >:)
12:57:48 <kadoban> sublime's haskell hilighter is crap? That's unfortunate
12:57:48 <shapr> grayhatter: is it something you could improve?
12:57:55 <grayhatter> reactormonk: I'm sure it does
12:57:56 <shapr> I don't use sublime, sadly.
12:58:09 <grayhatter> I don't have the spare time to learn and setup a new editor
12:58:37 <reactormonk> grayhatter, ... the >:) is an evil smile, the closest thing I can do to a trollface.
12:58:37 <grayhatter> shapr: I probaly could, but I wouldn't even try... I don't know enough haskell yet
12:59:08 <Cale> Our team is insanely productive. We took an app that we'd been working on for one client for about a year, and just one other team member and I sat down and made it multi-tenant in about 3 days -- i.e. we converted the backend such that it effectively served multiple copies of the web application, each with their own database schema. This is something which often would require weeks, or starting from scratch, but the type system is 
12:59:08 <Cale> just really really good at helping refactor stuff. We changed out the type of our authentication tokens, and a type which represented a pool of database connections, and the resulting type errors basically took us through all the changes which needed to be made throughout our backend.
12:59:14 <grayhatter> reactormonk: yeah, I got the intent before, the dry response was intentional so I wouldn't meme respond
12:59:52 <reactormonk> grayhatter, but then there was the second one, which had a bit more juice. :-P
12:59:52 <grayhatter> I'd already started typing out an argument for vim, but decided not to start that discussion this time
13:00:21 <shapr> I'm beginning to feel like I should push for a Haskell-specific editor, like IDLE is for Python
13:00:21 <Cale> The app is a chat service somewhat like Slack, but with additional features like email integration with the chat, surveys, and a bunch of other organisational features.
13:00:30 <grayhatter> shapr: yes pls
13:00:42 <reactormonk> shapr, or atom for JS?
13:00:42 <shapr> As in, start a kickstarter or something... send money to one of the Haskell consultancies.
13:00:52 <shapr> reactormonk: yup, that kind of thing.
13:00:56 <grayhatter> shapr: you have NO idea how much that would help me in trying to fix segments of errors
13:01:01 <bodisiw> Cale, does the type system help with things like schema changes in the database?
13:01:32 <grayhatter> shapr: model the spec after something like learnyouahaskell
13:01:44 <shapr> the editor spec?
13:01:48 <shapr> je suis confuse
13:01:50 <kadoban> shapr: I can only imagine that money would be better spent improving integration in existing editors, something like that hie thing that got started and didn't seem to go too far maybe.
13:01:53 <grayhatter> shapr: right
13:02:04 <Tuplanolla> User manual driven programming, shapr.
13:02:12 <kadoban> Not that I'm the decider of where anyone's money goes of course.
13:02:26 <grayhatter> a haskell IDLE should be able to have a history that you can reference
13:02:38 <shapr> Tuplanolla: en ymmaerrae
13:02:46 <joeyh> is there any way to hide instances from default display in haddock?
13:02:50 <grayhatter> ghci as an editor
13:03:08 <Tuplanolla> You write the user manual first and use that experience to guide your design, shapr.
13:03:19 <Cale> bodisiw: Well, we sort of coerced it to. I took the function which runs a database transaction given a pool of connections, and generalised it so that instead of just a plain pool of connections, it could take what amounted to a pair of the schema to use and that pool instead (and we defined a WithSchema functor which paired on the schema name)
13:03:28 <Tuplanolla> Defects come up before you have a single line of code.
13:03:29 <shapr> Tuplanolla: I can't tell if you're being sarcastic or not, but I hope yes?
13:03:40 <shapr> Tuplanolla: have you done something like that?
13:03:44 <joeyh> hmm, I suppose I could move the instances to a newtype or something
13:03:48 <Tuplanolla> Yes, twice already, shapr.
13:03:50 <Cale> bodisiw: This WithSchema functor also wrapped the unencrypted contents of our auth tokens
13:03:59 <grayhatter> shapr: iphy did something like that for hstoxcore
13:04:20 <grayhatter> the spec is inline, so when you start writing code, how everything works is already there
13:04:31 <Cale> bodisiw: and having made those changes, the compiler started complaining at us a bunch about all the things we needed to consider.
13:04:31 <grayhatter> If I understand correctly
13:05:00 <shapr> Tuplanolla: is that written up / described somewhere? And hopefully in something other than Finnish?
13:05:00 <davean> shapr: I've never actually seen IDLE used
13:05:05 <shapr> My finnish is pitiful
13:05:28 <shapr> davean: I used to use it a bunch to teach Python, but pycharm is better now.
13:05:36 <Tuplanolla> No, shapr. It's just a guiding principle. If you can't explain your idea clearly, it's a bad idea or you don't understand it. Either way it's better to give up early.
13:07:01 <Cale> bodisiw: and basically by the time we were done, we had a working multi-tenant app -- of course with a few details here and there where it wasn't totally straightforward, like dealing with separate subdomains and such in various places -- but the compiler was amazingly helpful at keeping the pair of us on track and busy and not having to stumble around and wonder about what stuff would be broken and need fixing
13:07:39 <shapr> Tuplanolla: that's an interesting idea
13:08:27 <bodisiw> Cale, i'll take all the help i can get :-) i imagine service boundaries are inescapable, but what you described still sounds awesome
13:11:41 <ZelteHonor> Am I the only one who's hype by linear type?
13:11:53 <fProgrammer> quick question: I'm fairly new to developing webservices using Scotty framework, I can't find any documentation on how to deploy scotty app. Currently I deploy it by "stack exec projectName", How do we deploy it using Apache/Nginx anyone?
13:12:23 <Cale> fProgrammer: I don't know why you would use Apache...
13:12:39 <Cale> When you write a web app using Scotty, your app *is* the webserver
13:13:13 <Cale> You may still want to put a load balancer in front of it
13:13:27 <bodisiw> ZelteHonor, i am... but i need to learn linear logic better, so its premature for me... also its dismaying if i have to type unicode characters
13:13:43 <bodisiw> i hope to use -o
13:14:00 <Cale> I wasn't the one to do that setup for our apps, so I couldn't tell you too much about how to configure nginx
13:14:06 <ZelteHonor> I don't think learning linear logic is a prerequisite.
13:14:20 <fProgrammer> Cale: Got it! Am I deploying it correctly though? stack exec project-name? 
13:14:33 <geekosaur> ?
13:14:45 <geekosaur> stack exec does not deploy, it runs something that may or may not be deployed
13:14:57 <ZelteHonor> -o
13:15:16 <Guest____> Anyone here familiar with ghc-mod and neco-ghc's internals? 
13:15:20 <ZelteHonor> I am curious how it will interact with the existing ecosystem.
13:15:25 <bodisiw> okay then... i still need to learn haskell :-)
13:15:32 <ZelteHonor> I've read the blog post, but not the paper.
13:15:40 <fProgrammer> geekosaur: okay understood.
13:16:41 <dylukes> fProgrammer my suggestion is that you build your scotty app, and then put it behind nginx as a reverse-proxy/load-balancer.
13:16:42 <bodisiw> paper reads pretty easy, from what i started... mostly about where the memory gets allocated, seems like
13:16:51 <Cale> fProgrammer: I don't think stack does too much when it comes to actually setting up a remote machine environment the way you want. It'll build your project for you, but deployment is still largely up to you.
13:17:55 <Cale> fProgrammer: We use nix where I work, and it's a lot more comprehensive in that regard (though I personally dread working on nix configuration, it's nice when you have someone who knows it well to set things up)
13:18:30 <dylukes> fProgrammer you can either use Scotty as the webserver and use server entries in an upstream block, or you can use wai-handler-fastcgi (has that been superceded?)
13:18:51 <Cale> dylukes: Oh, I forgot about that
13:18:54 <dylukes> In general, it's been my experience that putting nginx in front of anything web facing is a good idea. 
13:19:08 <dylukes> Using built in webservers is often more convenient in the short term but less convenient in the long term.
13:19:19 <Cale> But yeah, you shouldn't need it just to use nginx
13:19:43 <dylukes> http { upstream myapp { server foo.bar.whatever; } 
13:19:54 <dylukes> server { listen 80; location / { proxy_pass http://myapp } }
13:20:08 <fProgrammer> dylukes: Usually built-in webservers are for development, which prompted me to enquire more about scotty
13:20:10 <dylukes> If you add multiple servers to the upstream, nginx will load balance.
13:20:24 <fProgrammer> dylukes: yes!
13:20:32 <dylukes> Scotty uses Warp, which is WAI.
13:20:35 <dylukes> nginx, Apache, etc use CGI.
13:20:56 <dylukes> There should be separation of concerns though.
13:21:11 <dylukes> Generally I handle load balancing, proxying, TLS, etc in nginx and keep that out of the application itself. 
13:21:36 <dylukes> http://nginx.org/en/docs/http/load_balancing.html
13:22:16 <dylukes> Also, if you're deploying in a containerized environment, you can write a quick script to pull the endpoints from each container and generate the nginx config. 
13:22:35 <dylukes> Pretty much all of my personal projects as well as contracts are nginx + containers. 
13:23:14 <dylukes> You can use this: https://github.com/jwilder/docker-gen
13:23:50 <dylukes> (or higher level: https://github.com/jwilder/nginx-proxy)
13:25:24 <dylukes> Cale: also hey Cale!
13:25:29 <dylukes> It's been a while :).
13:25:32 <fProgrammer> dylukes: So help me understand this, I've a scotty web app hosted on github/bitbucket, I pull the changes on remote machine/container, build it and execute the binary? Sorry I come from "war" lineage where we build a war file which is copied from a CI etc
13:25:36 <mauke> I thought nginx didn't support CGI
13:25:40 <Cale> hey :D
13:26:00 <dylukes> mauke It supports fastcgi.
13:26:13 <mauke> ok, that's a bit different :-)
13:26:43 <Cale> fProgrammer: yeah, assuming that the application is reasonably self-contained, that sounds about right. You might want to script that process.
13:27:07 <fProgrammer> Cale: got it! Thanks for the help!
13:27:11 <dylukes> I don't know if there's a stack buildpack, but,
13:27:21 <dylukes> I rather like dokku for small deployments.
13:27:23 <dylukes> It's very handy. 
13:27:37 <dylukes> But it's worth doing it manually first to learn how the ecosystem works.
13:28:05 <dylukes> fProgrammer WAR/EARs work because they're self contained and target a virtual machine (JVM).  
13:28:13 <Cale> fProgrammer: Where I work, we have a script which does a nix-build of a complete system configuration for an AWS machine, and then uses nix-copy-closure to send it, and then ssh'es in and switches to the new configuration
13:28:16 <dylukes> the idea with containers is similar, but you're packing an entire system, not just filesystem. 
13:28:21 <shiona> I have a python program that uses subprocess.Popen to run a program, pipes stdout and stdin into its own use and expects one line in input (from the subprocess) after which it would send a crapton of stuff to the subprocess. I'm giving it a haskell program and 'putStrLn "test"' terminates, but 'putStrLn "test" >> getLine' does not.
13:28:27 <dylukes> Cale that's very... yo.
13:28:28 <dylukes> you*
13:28:47 <shiona> I assume I'm either too drunk to code, or there's something I don't understand about how lazyness works in this case
13:28:51 <dylukes> I need to learn Nix.
13:28:55 <fProgrammer> dylukes: Makes sense, thanks!
13:29:02 <glguy> shiona: Nothing to do with laziness, probably something to do with buffering
13:29:05 <dylukes> fProgrammer just remember that docker is a finicky piece of crap.
13:29:18 <dylukes> It generally works great as long as you don't poke it too hard or need to mess with cgroups or anything.
13:29:20 <shiona> ah
13:29:24 <dylukes> At that point... may god have mercy on your soul.
13:29:29 <Cale> dylukes: So do I actually -- I've just been living well by being surrounded by people who know how to use it better than I do
13:29:30 <glguy> shiona: You can either set the buffering mode in your Haskell program to NoBuffering or LineBuffering, or you can explicitly hFlush stdout
13:29:44 <shiona> thanks. Forgot that stuff
13:29:45 <dylukes> Cale I'm jealous :(.
13:29:52 <dylukes> I'm in academia writing python scripts all day currently.
13:30:08 <mauke> avoid NoBuffering like the plague
13:30:31 <mauke> unless you like seeing write(..., 1) calls everywhere in your strace output
13:30:37 <shiona> in this case LineBuffering works fine
13:30:47 <dylukes> strace is another program I need to learn. 
13:30:56 <dylukes> Or, dtruss on OS X.
13:31:20 <mauke> the basics are easy. 'strace yourprogram --options' :-)
13:33:27 <grayhatter> is there anything overtly wrong with this https://gist.github.com/36c4c48f4a2977a1568722a1b215afed
13:33:29 <Habib_> Does anyone know a function that can generalise IsString values to the typeclass?
13:34:18 <dylukes> Hrm. Still can't get man pages opening in vim nicely.
13:34:21 <dylukes> So many ^Hs...
13:34:27 <Habib_> For example, say I have a function f, which calls another function g with the type ByteString -> ByteString
13:35:05 <Habib_> I can turn f into a generalised g with the type IsString stringy => ByteString -> stringy
13:35:28 <Habib_> But I can't turn it into a function with the type IsString stringy => stringy -> stringy
13:35:31 <Habib_> Can I?
13:35:51 <Habib_> grayhatter, I would use the maybe function
13:36:07 <Habib_> Sorry, the fromMaybe function
13:36:34 <mauke> grayhatter: it looks like it's repeating a lot of work
13:36:35 <Habib_> Actually, maybe looks good for this instance
13:37:03 <mauke> :t partition
13:37:05 <Habib_> No, wait.
13:37:05 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
13:37:15 <glguy> Habib_: If you look at the definition of the IsString class you'll see that it only provides for fromString :: IsString a => String -> a
13:37:51 <glguy> So that class isn't going to help you to write toString :: IsString a => a -> String
13:38:20 <Habib_> glguy, yeah, I was hoping that was because Haskell gives you toString for free from fromString or something like that.
13:38:58 <grayhatter> Habib_: I can't
13:39:15 <Habib_> Well, it's probably more like toString :: IsString a => a -> a, because I want to be able to pass any IsString instance and use it as an arbitrary IsString instance.
13:39:16 <grayhatter> there's no promise that channel will exist
13:39:25 <grayhatter> wait
13:39:52 <mauke> :t \search -> first listToMaybe . partition (\x -> ?chname x == search)
13:39:54 <lambdabot> (?chname::t -> a, Eq a) => a -> [t] -> (Maybe t, [t])
13:40:44 <grayhatter> huh
13:41:24 <Habib_> grayhatter, maybe (Nothing, cs) (flip (,) other) found?
13:41:43 <Habib_> maybe (Nothing, cs) (flip (,) $ other) found
13:42:00 <mauke> Habib_: that can be simplified to (found, other)
13:42:38 <Habib_> The maybe there is a function call.
13:42:49 <Habib_> But it doesn't typecheck.
13:43:04 <Habib_> Because the left tuple is a (Maybe a, b)
13:43:10 <Habib_> and the right is an (a, b)
13:43:14 <jle`> case partition (\x -> search == cname x) cs of
13:43:28 <jle`>   (x:xs, ys) -> (Just x, xs ++ ys)
13:43:34 <jle`>   ([], ys) -> (Nothing, ys)
13:43:54 <mauke> jle`: that's semantically different
13:43:59 <mauke> the original code doesn't return xs
13:44:15 <jle`> oh i see
13:44:37 <Habib_> if isJust found, isn't cs == other?
13:44:46 <jle`> then (x:xs, ys) -> (Just x, ys)
13:45:00 <Habib_> In that case, why not just say (found, other)
13:45:06 <mauke> jle`: that's equivalent to my version :-)
13:45:10 <Habib_> Just read the whole thing properly.
13:45:16 <Habib_> I think.
13:45:20 <jle`> my intent was to be identical to your version, just more pointful :3
13:45:21 <Habib_> Well, just read the whole thing.
13:45:27 <jle`> Habib_: (found, other) wouldn't work
13:45:35 <mauke> @unpl \search -> first listToMaybe . partition (\x -> chname x == search)
13:45:35 <lambdabot> \ search x -> first listToMaybe (partition (\ x0 -> chname x0 == search) x)
13:45:47 <mauke> jle`: why not?
13:46:00 <jle`> oh wait, yeah, it would
13:46:06 <jle`> heh
13:46:16 <jle`> was overthinking it :)
13:46:38 <Habib_> If found is Nothing, that means other is equal to cs, because none of the cs are equivalent to what you're trying to find, so the filter returns all the cs.
13:46:51 <Habib_> So, (found, cs)
13:47:36 <Habib_> or (found, other), sorry
13:48:05 <Habib_> grayhatter, the where clause should remain, but the whole isJust block can be collapsed to (found, other)
13:48:21 <mauke> I think the where clause should be removed and replaced by partition
13:48:40 <Habib_> Let me look up partition.
13:49:26 <mauke> :t partition
13:49:28 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
13:49:34 <Habib_> Ah, yeah, that might be good, and then the listToMaybe you thought is probably good too
13:49:50 <mauke> it takes a predicate and a list, and returns two lists: the elements that pass the predicate, and the elements that don't
13:50:04 <Habib_> Yeah, just looked it up on hoogle
13:50:55 <Habib_> Yeah, I think mauke's version might be best, although I don't like the listToMaybe function.
13:51:10 <mauke> why not?
13:52:37 <Habib_> I don't know, it seems like the intent is to be used when you know that only one result can ever be returned, but then in that case, I'd say just use a function which returns Just that first result or Nothing. It feels like coercion to me and if you end up finding more than one result, you'd never know.
13:53:01 <Habib_> With find, it's more intention revealing, its whole purpose is to only find the first result.
13:53:10 <mauke> no, it's used when you only care about one result and want to throw away the rest
13:54:21 <Habib_> Yeah, that's a fair point, but its intent is not as clear as find, IMO, but I agree with you that it's perfect to be used for this scenario. The version with find is just much longer.
13:55:17 <jle`> hm i've only ever used listToMaybe to take the first result and throw away the rest
13:55:37 <jle`> i've never used it in the case where i know i only have one result
13:55:42 <mauke> a.k.a. safeHead :-)
13:55:48 <Habib_> Tht's fair, but I could conceivably see it being used in that situation by someone.
13:56:11 <jle`> yes, that would be a useful application :)
13:56:17 <jle`> but one of many :o
13:56:26 <Habib_> I use Protolude to make Prelude safer.
13:56:58 <Habib_> I thought the whole point of Haskell was its safety, then I find out you can have partial functions.
13:57:08 <dylukes> Partial functions can be handy though. 
13:57:18 <dylukes> In Scala they're really useful for exception handling for example.
13:57:22 <Habib_> Not only that, but that the default imported functions are often partial.
13:57:26 <dylukes> Or registering event handlers.
13:57:34 <jle`> yes i am disturbed that so many partial functions are in Prelude
13:57:42 <Habib_> dylukes, really? I can't imagine how.
13:58:00 <jle`> even if they are used that way in scala, they aren't used that way in haskell, so it doesn't really make sense to put them in Prelude
13:58:10 <dylukes> jle`I agree there.
13:58:22 <Habib_> I don't understand the `error` function either. It seems like an IO action, but it has the type String -> a.
13:58:30 <jle`> error is not an IO action
13:58:53 <Habib_> Well, GHC says that, too, but it seems to behave like one to me.
13:59:03 <jle`> in what way?
13:59:03 <kadoban> I don't really mind the partial functions in Prelude. It's annoying that some of them don't have a safe alternative though.
13:59:32 <dylukes> jle`that's not really true though.
13:59:41 <Habib_> Well, it seems to stop further execution, behaving like an exception.
13:59:42 <dylukes> error ues CallStack, and currentCallStack is an IO action.
13:59:44 <dylukes> uses*
13:59:57 <dylukes> It just hides it because it terminates the program so any further unsafety probably doesn't matter.
14:00:05 <dylukes> Getting the current call stack state is absolutely IO though.
14:00:12 <Habib_> Ah, so that's why it has that a return value.
14:00:20 <Habib_> String -> a
14:00:26 <jle`> dylukes: that's an implementation detail, though
14:00:30 <jle`> it doesn't have the semantics of an IO action
14:00:55 <jle`> a lot of things in haskell are implemented using IO underneath...
14:00:57 <Habib_> It does, though. That's why I 'felt' like it was an IO action without being told.
14:00:59 <jle`> are you going to call (+) an IO action?
14:01:14 <Habib_> No, why would I?
14:01:29 <jle`> (addressing dylukes) because (+) for Int is implemented using IO underneath
14:01:35 <jle`> but that doesn't make 2 + 4 an IO action
14:01:55 <dylukes> I don't think that's a fair comparison.
14:02:01 <dylukes> (+) doesn't change control flow.
14:02:05 <dylukes> error very clearly does (it ends it).
14:02:23 <jle`> that's a better argument than your previous one
14:02:25 <Habib_> I mean, technically the type signature for error doesn't say it's *not* an IO action.
14:02:34 <Habib_> It just says the return value could be anything.
14:02:44 <jle`> semantically in haskell, error "string" is bottom
14:02:47 <jle`> it's a pure value
14:03:13 <jle`> in haskell semantics, 'error "msg"' is indistinguishable from a nonterminating computation
14:03:15 <Habib_> But then if it did return an IO action, it wouldn't be executed straight away.
14:03:20 <dylukes> jle`That makes sense.
14:03:30 <dylukes> Except error terminates the program immediately ;p. (I know, semantics)
14:03:38 <jle`> so, `error "msg"` can be thought of in Haskell as a way of creating a more useful bottom
14:03:45 <jle`> because you can hide bottom anywhere in your code already
14:03:57 <jle`> head [] = let x = x in x
14:04:00 <dylukes> Reminds me of ML exceptions.
14:04:12 <jle`> `let x = x in x` and `error "msg"` are semantically identical
14:04:21 <Habib_> That's true. I never use error, but I do use undefined when I know what the types are going to be, but not the definitions yet.
14:04:30 <jle`> but GHC, the compiler, can take advantage of the fact that the bottom was defined using 'error'
14:04:31 <Habib_> And I want to test part of the program without having to fully flesh things out.
14:05:36 <dylukes> jle`is there a canonical monograph/single reference on Haskell's denotational semantics?
14:06:01 <dylukes> I reimplemented STG in high school (for shits-and-gigs and so I wouldn't have to do a less interesting senior project) on LLVM, which was fun.
14:06:06 <jle`> dylukes: there's the Haskell report
14:06:09 <dylukes> But, I've neglected the denotational side.
14:06:29 <jle`> "is there a canonical X about haskell?" => the answer is usually the Haskell report
14:07:11 <dylukes> All I saw in the HR was discussion of informal semantics. 
14:07:30 <jle`> there isn't anything other than the report about haskell the language :/
14:07:33 <jle`> it's basically the only canon
14:07:50 <jle`> anything else is fanfiction
14:07:57 <dylukes> I was about to say "and our warmly held hopes and dreams".
14:07:59 <jle`> or "legends" i suppose
14:08:42 <dylukes> "The Legend of Haskell: Link's unsafeAwakening"?
14:08:42 <mauke> legend: that which ought to be read
14:09:31 <dylukes> In the distant future archeologists will discover troves of flash media filled with literate haskell, relics of a long forgotten civilization. 
14:10:16 <jle`> Habib_: IO actions describe programs, but error "msg" doesn't describe any program.  it's semantically identical to `let x = x in x`, except GHC can be smarter when trying to evaluate it
14:10:38 <dylukes> The end came too soon for this influential and advanced society. It had seemed wise to allow arbitrary unicode codepoints as names... but their folly was their demie, as increasingly new haskellers refused to use anything other than emoji.
14:10:45 <dylukes> New weekend project: reimplement Prelude using only emoji.
14:10:55 <shapr> dylukes: I'll send money
14:11:05 <jle`> https://twitter.com/EmojiHaskell
14:11:16 <dylukes> Jesus christ.
14:11:21 <dylukes> Why am I not surprised this exists.
14:11:21 <jle`> although some of their tweets aren't valid haskell which sort of defeats the purpose to me
14:11:39 <dylukes> But those are variable names....
14:11:53 <dylukes> I'm more interested in say, defining the list operations with emoji that actually make sense.
14:12:08 <mauke> where's the hieroglyph one?
14:12:16 <jle`> there are some data types there that have names that are emojis
14:12:29 <jle`> data ?????? ?????? where
14:12:32 <jle`>    ??????  :: ?????? ???
14:12:34 <jle`>    ?????? :: ?????? -> ?????? ?????? -> ?????? a
14:12:38 <jle`> huh something got mangled up during the pasting
14:12:51 <mauke> dylukes: https://twitter.com/t3xtm0de/status/600711130324008961
14:13:01 <mauke> the fun part is those identifiers actually make sense
14:13:08 <dylukes> Oh that's perfect.
14:13:09 <MarcelineVQ> yeah, some of the ? symbols became dots and arrows
14:13:30 <dylukes> mauke am I reading the type correctly:
14:13:50 <dylukes> "Given a function that rips a leg off a bird, and a list of birds, yield a list of legs."
14:14:05 <dylukes> a slug tha rips bird's legs off*
14:14:12 <dylukes> a slug that rips birds' legs off*
14:14:31 <dylukes> mauke also, the cliche... "are you sure that isn't perl?"
14:15:02 <mauke> ... have you seen haskell code before? haskell uses at least as much punctuation as perl
14:15:18 <maerwald> mauke: nah, we use `fmap` :P
14:15:25 <mauke> <$>
14:15:28 <dylukes> (.)
14:15:54 <dylukes> The fmap/map thing is still a huge wart to me.
14:16:03 <dylukes> Is there any reason beyond legacy for that still being split?
14:16:37 <maerwald> you mean you want: map with the type signature of fmap?
14:16:43 <mauke> IIRC those hieroglyphics are transliterations of the usual english variables
14:16:55 <geekosaur> fear of existing programs breaking because of unexpected polymorphism, I think
14:16:59 <mauke> the function name was something like "m-p"
14:17:04 <dylukes> Yeah, that's what I thought geekosaur.
14:17:14 <jle`> well ... map actually used to be fmap.  the split happened late into haskell development
14:17:25 <geekosaur> same reason everyone wants ScopedTypeVariables by default but it never happens
14:17:33 <dylukes> jle` everything changed when the fmap kingdom attacked.
14:17:38 <jle`> so the split actually broke some legacy code
14:17:45 <jle`> at the time
14:18:20 <jle`> for a long time map was generalized to use all functors but then enough people were unhappy that they split off the two
14:18:30 <dylukes> Why were they unhappy?
14:18:37 <jle`> error messages for newbies i think
14:18:53 <monochrom> History is a dialectic struggle between map=fmap and map≠fmap. :)
14:19:04 <jle`> but it is clear these days that "error messages for newbies" is no longer a priority, ever since the FTP side won
14:19:19 <jle`> maybe the argument should be that making map = fmap will actually fix legacy code
14:19:24 <jle`> code written from before the split will now work
14:19:27 <jle`> :)
14:19:37 <monochrom> I support it! :)
14:19:49 <monochrom> More thorny is whether (.) = fmap :)
14:19:56 <jle`> make legacy code work again, by generalizing map!
14:20:13 <monochrom> Make legacy code great again :)
14:20:14 <dylukes> (.).(.) = fmap fmap fmap which is onomatopoetically pleasing.
14:20:50 <monochrom> (+) . [1,2,3] <*> [4,5,6]
14:21:05 <jle`> we can just use <$> everywhere instead
14:21:11 <jle`> <$> is associative, remember, just like .!
14:21:21 <jle`> f <$> (g <$> h) = (f <$> g) <$> h
14:21:44 <jle`> the only problem is the fixity
14:21:46 <monochrom> "Hi I'm a beginner. What's the difference between 'sin <$> cos $ 4" and "sin $ cos $ 4"? :)
14:22:21 <Habib_> sin <$> cos $ 4 doens't work
14:22:30 <dylukes> Yes it does?
14:22:32 <jle`> > sin <$> cos $ 4
14:22:36 <lambdabot>  -0.6080830096407656
14:22:39 <Habib_> huh
14:22:40 <jle`> > sin $ cos $ 4
14:22:43 <lambdabot>  -0.6080830096407656
14:22:45 <jle`> surprise ~
14:22:53 <monochrom> :)
14:23:01 <Habib_> okay, sin <$> cos $ 4 fmaps the sin function over cos before applying it to 4
14:23:02 <dylukes> <$> = map = function composition
14:23:12 <dylukes> It's (f . g) 4 vs f (g 4)
14:23:14 <Habib_> Forgot for a second that (-> r) is a Functor
14:23:22 <jle`> > succ <$> (negate <$> Just 3)
14:23:25 <lambdabot>  Just (-2)
14:23:28 <jle`> > (succ <$> negate) <$> Just 3
14:23:31 <lambdabot>  Just (-2)
14:24:19 <jle`> Habib_: (-> r) is not a Functor
14:24:26 <jle`> you might be thinking about (r ->)
14:24:30 <Habib_> I'll just stay quiet now.
14:25:05 <glguy> Habib_: It's confusing because (r ->) and (-> r) are made-up syntax, neither works in Haskell.  (->) r   is a Functor, however
14:25:20 <dylukes> My current weekend project: a haskell engine for working with Pymol. 
14:25:49 <Habib_> Yes, I must have been thinking of (->) r
14:25:59 <Habib_> Which could be translated to (r ->)
14:26:13 <jle`> dylukes: where do you live that it is currently the weekend
14:26:16 <jle`> ;_;
14:26:21 <dylukes2> It's not haha. 
14:26:26 <dylukes2> That's just a weekend project. 
14:28:09 <dylukes2> So out of curiosity 
14:28:15 <dylukes2> What's the state of Haskell IDE support?
14:28:40 <dylukes2> Emacs support is good but I mostly use Vim these days and Intellisense/IntelliJ completion is addictive haha. 
14:29:38 <shapr> dylukes2: emacs support is good, I don't know about vim, and there isn't a Haskell-specific IDE that I've seen.
14:29:45 <oisdk_> dylukes2 I like haskellformac
14:31:11 <maerwald> there are haskell-specific IDEs
14:31:29 <dylukes2> I'd rather use Vim haha. 
14:31:45 <dylukes2> shapr: neco-ghc works pretty well, with some limitations. 
14:32:03 <dylukes2> emacs gets all of the love in the FP world much to my chagrin. 
14:32:27 <maerwald> why do you ask for haskell IDEs when you'd rather use vim then -.-
14:32:45 <dylukes> Because I'd rather use vim than the "for haskell" IDEs,
14:32:47 <maerwald> anyway: http://www.leksah.org/
14:32:53 <dylukes> which aren't it seems all that well supported or maintained.
14:32:56 <dylukes> When I tried to use them anyhow.
14:33:02 <dylukes> I could never get Leksah actually running on OS X properly.
14:33:19 <maerwald> well, I can't get anything running on OS X properly, so you're probably right
14:33:26 <shapr> maerwald: be nice
14:33:31 <maerwald> ?
14:33:46 <shapr> maerwald: that comes across as sniping at OSX
14:33:58 <maerwald> I've used OS X for development and that was my experience
14:34:01 <dylukes> herewegojoker.gif
14:34:28 <maerwald> and I said "_I_ can't get anything running on OS X"
14:34:33 <maerwald> that's not sniping 
14:34:42 <brynedwards> haskell-vim-now and this post are probably good for vim http://www.stephendiehl.com/posts/vim_2016.html
14:34:46 <maerwald> leksah works fine on linux though
14:34:51 <maerwald> I just dislike the internal editor
14:34:52 <dylukes> brynedwards that's the basis of my config. 
14:35:03 <dylukes> The problem is that neco-ghc is relatively limited and has some minor warts.
14:35:04 <maerwald> the yi interface is kinda broken/unmaintained unfortunately, which is the closes you would get to vim
14:35:16 <dylukes> I would rather have full ghc-mod integration with IntelliJ .
14:35:36 <dylukes> I'm learning vimscript currently though, so,
14:35:42 <dylukes> hopefully I can help remedy that situation.
14:35:47 <shapr> dylukes: hurrah!
14:36:20 <brynedwards> Haven't tried intellij but there's this http://rikvdkleij.github.io/intellij-haskell/
14:36:36 <dylukes> shapr I'd like to get declaration scanning implemented at the least.
14:36:44 <brynedwards> I used to use vim, now use emacs + evi
14:36:46 <brynedwards> evil*
14:38:41 <dylukes> There's this shapr: https://github.com/eagletmt/ghcmod-vim
14:44:45 <nak> ok so how the heck do i go about debugging in haskell
14:45:03 <nak> i have a variable and i just want to print it out 
14:45:15 <nak> or how do i get visibility on what's inside the var?
14:45:35 <erisco> nak, load up your program in ghci and poke it
14:45:35 <brynedwards> nak: There's trace from Debug.Trace
14:46:11 <nak> erisco: yeah but that's a total pain. my variable is the left hand side of a monad binding
14:46:35 <nak> csvData <- BL.readFile "batting.csv"
14:46:38 <nak>   let v = decode NoHeader csvData :: Either String (V.Vector BaseballStats)
14:46:42 <nak> how to get at "v" and see what's in there ?
14:47:08 <brynedwards> in GHCi: v <- decode NoHeader <$> BL.readFile "batting.csv"
14:47:12 <erisco> decode NoHeader =<< BL.readFile "batting.csv"
14:47:20 <nak> cmon tho
14:47:20 <brynedwards> or that
14:47:25 <nak> that
14:47:34 <erisco> or fmap rather
14:47:50 <nak> that's so much extra typing. and i can't even copy paste that from my own program
14:48:04 <nak> i'd have to know all of those extra ways to bend stuff around just to get at it ?
14:48:06 <brynedwards> you can copy paste both lines and it should be fine
14:48:07 <erisco> that's how I do it, but there could be other ways, I don't know
14:48:23 <erisco> there is an interactive debugger but I wasn't so keen on it
14:48:27 <brynedwards> doing the original two lines one after the other in GHCi would be fine
14:48:36 <nak> wait are you joking? i can use <- without starting a "do" ??
14:48:38 <oisdk_> nak how about https://hackage.haskell.org/package/base-4.9.1.0/docs/Debug-Trace.html#v:traceShowId
14:48:42 <brynedwards> in GHCi, yes
14:48:48 * nak sighs
14:48:51 <brynedwards> you can do 's <- getLine'
14:48:52 <brynedwards> :D
14:48:54 <kuribas> nak: :break in ghci
14:50:02 <nak> oisdk_: i have no idea how to use that
14:50:18 <heath> https://wiki.haskell.org/BayHac2017
14:50:23 <nak> Prelude is so different than compiling/running your script
14:50:43 <nak> that's kind of annoying <- beginner's perspective
14:51:05 <nak> sorry, not Prelude
14:51:06 <nak> ghci*
14:51:13 <geekosaur> perhaps you want runghc?
14:51:24 <erisco> runhaskell ?
14:51:33 <nak> lol i have no idea what either of those are
14:51:47 <erisco> they just compile your program, run it, and clean up
14:51:53 <oisdk_> when you wrap it around a value it prints the value whenever it's used
14:51:56 <geekosaur> they do not compile
14:52:03 <geekosaur> they use the same bytecode backend ghci uses
14:52:04 <erisco> okay, I thought they did
14:52:17 <nak> if people debug programs in ghci, then that's what i'll use... but i'm just expressing how it feels very overwhelming that there's a bunch of extra stuff to learn about it
14:52:22 <nak> and that knowledge is only valuable in ghci
14:52:24 <geekosaur> but they don't have the ghci ui
14:52:50 <erisco> there is not a bunch of extra stuff, it is mostly the same
14:53:24 <erisco> yes, you are implicitly in a do block already, so you can omit another do
14:53:40 <erisco> but if you use an extra one it doesn't matter
14:53:45 <erisco> so I don't see how that's so confounding
14:54:12 <nak> oisdk_: i don't even know how to import this module
14:54:18 <nak> import Debug isn't doing it for me
14:54:33 <nak> so i'm not "far" enough to know how to use this
14:54:46 <monochrom> You can choose to never use ghci. Then there is no ghci to learn. Apparently, that's what C programmer chose to do.
14:55:01 <oisdk_> nak it's Debug.Trace
14:55:02 <nak> mhm 
14:55:07 <erisco> you can't be too worried about typing a few characters into ghci
14:55:14 <monochrom> Did you know: Casio made a handheld calculator that interpreted C.
14:55:25 <koala_man> wat
14:55:33 <erisco> as soon as there is something unexpected you're going to be happy to be able to rapidly experiment
14:55:38 <monochrom> Wish I had the money to buy one back then, so I can show it to you now.
14:55:45 <brynedwards> I think temple OS has a C interpreter
14:55:59 <erisco> it works like your terminal so that you can use the up arrow to re-enter previous lines
14:56:00 <brynedwards> among other things...
14:56:02 <koala_man> that would have been so much better than the weird Basic variant mine had
14:56:05 <nak> erisco: it does "worry" me when the expression to type is completely different than the program i've written
14:56:13 <monochrom> I agree!
14:56:14 <nak> erisco: but yes, in this case i learned that i can just paste the lines verbatim
14:56:18 <erisco> but it isn't completely different...
14:56:32 <erisco> and you can write it exactly the same, including the line returns, if you want
14:57:10 <erisco> I just made a conversion from do-notation so it was more easily entered as a single line
14:57:11 <koala_man> Basic didn't even let you abstract over vectors. you had to choose a one-letter name and hope no one else used the same one while there was data in it
14:57:18 <erisco> but if you're not comfortable with that you don't have to
14:58:00 <nak> erisco: ok so how about writing a function in ghci
14:58:03 <nak> f :: Int -> Int -> Int
14:58:05 <nak> f x y = x + y
14:58:14 <nak> if i linebreak that in ghci, it freaks out
14:58:25 <erisco> you can enter multi-line mode, or you can use a semicolon
14:58:42 <nak> how to multiline mode ?
14:58:42 <erisco> or you can omit the type
14:58:57 <erisco> :{
14:59:08 <nak> is that a sad face ^_^
14:59:09 <monochrom> Begin with :{ , end with :}
14:59:53 <monochrom> Did you know: (: This is a comment in XPath :)
15:00:10 <erisco> if you omit the type a different one will be inferred, but usually you'd be alright with leaving it out
15:00:10 <nak> ok cool re: multiline mode
15:00:34 <nak> i wouldn't use the semicolon because that would mean i can't copy/paste from my program into ghci
15:01:14 <monochrom> Why copy? :load exists.
15:01:16 <erisco> well I am not usually doing that either, I just have my program loaded in ghci
15:02:19 <erisco> you can :load or you can list your files as arguments to the ghci program
15:02:20 <monochrom> To be fair, I acknowledge that there is 1% of the time when pasting is better.
15:02:50 <brynedwards> Must remember to use :break more often...
15:03:07 <erisco> the typical workflow is evaluate, edit, :r, repeat
15:04:08 <nak> where can i use break brynedwards ?
15:04:37 <nak> ok so type of my v is v :: Either String (V.Vector BaseballStats)
15:04:51 <nak> if it try to display the entire value, it's way too f big
15:04:57 <nak> so how can i poke around it ?
15:05:10 <nak> it's an Either, so it's a Right or a Left value
15:05:16 <Koterpillar> :t isLeft
15:05:19 <lambdabot> Either a b -> Bool
15:05:25 <nak> maybe fmap fst v to get the first value of the vector ?
15:05:36 <brynedwards> I would do let (Right csvData) = v
15:05:46 <brynedwards> Or something
15:06:24 <nak> but that's uninteresting to me. i need to know what v is after csvData was decoded
15:06:29 <brynedwards> fst is for tuples
15:07:25 <brynedwards> Perhaps csvData was a bad choice there, since you used it earlier
15:07:44 <brynedwards> I meant a new variable, that would unwrap the Either
15:07:47 <nak> i know its type, but like, that's still confusing to me. i would like to make an association in my mind of waht the data *values* look like compared to the *type*
15:08:16 <brynedwards> let (Right myVar) = v
15:08:26 <brynedwards> myVar :: V.Vector BaseballStats
15:09:25 <brynedwards> Then you could do `V.head myVar` to see the first BaseballStats
15:09:48 <nak> !
15:09:54 <nak> ok sweet
15:10:09 <nak> so (Right myVar) is a pattern match on v
15:10:26 <nak> if v were a Left, myVar would not have been assigned, correct ?
15:11:58 <geekosaur> nak, it should throw an exception about a pattern not being matched
15:12:14 <brynedwards> @let x = Left 3
15:12:17 <lambdabot>  Defined.
15:12:20 <brynedwards> @let (Right y) = x
15:12:23 <lambdabot>  .L.hs:180:13: error:
15:12:23 <lambdabot>      Ambiguous occurrence ‘x’
15:12:23 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.x’,
15:12:26 <monochrom> if v is a Left, and enough evaluation happens to find it out, then there will be what geekosaur said.
15:12:39 <brynedwards> @let somethingElseThen = Left 3
15:12:42 <lambdabot>  Defined.
15:12:51 <monochrom> However, "enough evaluation" does not always happen.
15:12:54 <geekosaur> ^
15:13:01 <brynedwards> @let (Right notSafe) = somethingElseTHen
15:13:03 <lambdabot>  .L.hs:183:19: error:
15:13:03 <lambdabot>      • Variable not in scope: somethingElseTHen :: Either t0 t
15:13:03 <lambdabot>      • Perhaps you meant ‘somethingElseThen’ (line 182)
15:13:05 <brynedwards> @let (Right notSafe) = somethingElseThen
15:13:13 <lambdabot>  Defined.
15:13:22 <brynedwards> > notSafe
15:13:25 <geekosaur> let bindings are lazy, you need to use something bound by the pattern to find out
15:13:31 <lambdabot>  *Exception: /tmp/mueval89369871982275856.hs:183:1-35: Irrefutable pattern fa...
15:13:45 <nak> ok well i'm happy i found at least some way to look at the data
15:13:50 <nak> well, i didn't find it
15:13:53 <nak> you all helped ^_^
15:14:16 <monochrom> Also, it turns out that the meaning of "enough evaluation" is rather subtle, even for those who understand lazy evaluation.
15:14:39 <geekosaur> https://twitter.com/deech/status/842110948378828802 not *quite* offtopic...
15:14:54 <monochrom> http://lpaste.net/100588 shows a subtle and surprising example
15:15:27 <nak> ok i have to get running. i'll be back a little later. thanks everyone
15:15:37 <monochrom> Basically "let y@(x:xs) = [] in but but but I am not evaluating x or xs, I am just evaluating y!"
15:17:02 * geekosaur assumes pattern evaluation is all or nothing, so that behavior makes sense
15:17:51 <geekosaur> (or put otherwise for this example, the as-pattern binding "doesn't exist" until (x:xs) has been matched)
15:21:53 <dmwit> > let Right x = Left 3 in x :: String
15:21:55 <lambdabot>  "*Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Ri...
15:22:09 <dmwit> No need for long `somethingElseThen` names. ;-)
15:23:04 <erisco> I don't follow lines 11-14
15:23:11 <erisco> not a clue what they're doing there
15:23:31 <monochrom> lines 11-14 of my calculation?
15:23:39 <erisco> whoever wrote the pastebin
15:23:44 <brynedwards> Yeah I realised that a minute after my typos
15:23:48 <monochrom> Yes that's me.
15:24:27 <monochrom> It applies Haskell 2010 Report section 3.17.3 rule (d).
15:24:44 <monochrom> You will probably need to read that rule to see.
15:25:57 <monochrom> But it is the main rule characterizing ~
15:26:04 <erisco> oh I completely misread the parens
15:26:12 <monochrom> Oh heh OK!
15:26:44 <monochrom> Yeah passing 3 parameters to a function, but each parameter is pretty long.
15:27:08 <monochrom> And the function ends up ignore 2 of them.
15:29:13 <erisco> so it is really that rule specifically that kills it
15:29:32 <jle`> wouldn't it be nice if there was (Num a, Num b) => Num (a, b)
15:29:38 <jle`> can you imagine tho
15:29:57 <jle`> (i could)
15:30:51 <erisco> well then also the meaning of the let binding
15:30:55 <erisco> how does it work for functions then, hm
15:34:06 <erisco> meh I can't be bothered to find it
15:35:45 <erisco> I'd expect the same thing though, I assume you get the same case expression
15:36:15 <geekosaur> jle`, I've seen it used in production code at least once. otherwise it's a generalization of Data.Complex :p
15:36:47 <geekosaur> (well, that's one way to interpret it at least)
15:38:28 <Darwin226> So I'm doing `stack install cabal-helper-0.7.3.0` and it's giving me a dependency error say that "cabal-helper-0.7.2.0" depends on some specific version of directory. But I'm not installing that version of cabal-helper. Is this a bug?
15:41:02 <conal> jle`: https://hackage.haskell.org/package/NumInstances has Num instances for tuples and functions.
15:42:45 <jle`> wouldn't dare use it for a library though
15:42:47 <monochrom> I have a cunning plan! Num (a,b) uses complex number multiplication, Num (a,b,c) uses vector cross-product multiplication, and Num (a,b,c,d) uses quaternion multiplication.
15:43:28 <lyxia> Definitely a good idea.
15:44:09 <freeside> haha
15:44:18 * jle` wonders if the dimensions actually line up properly
15:45:03 <twanvl> You'd need to multiply a's with b's, though
15:45:04 <jle`> i don't think they do unfortunately
15:45:07 <jle`> yeah
15:45:19 <jle`> but a+ for creativity
15:45:24 <freeside> Num ((Num a, Num b), (Num c, Num d))
15:45:26 <monochrom> The problem with cunning plans. :)
15:45:29 <freeside> what could possibly go wrong
15:46:04 <freeside> or did i mean Num (Num (a, b), Num (c, d))
15:46:21 <pikajude> yeah, when can we put constraints in nested tuples
15:46:24 <jle`> you meant neither
15:46:33 <oisdk> Is there a package out there for church-list kinds of things? Like a left-fold church list? Basically https://hackage.haskell.org/package/foldl-1.2.3/docs/Control-Foldl.html#t:Fold without the b parameter
15:46:37 <monochrom> You mean Num ((a,b), (c,d)) (with unsaid contraints)
15:47:24 <rbnnn> I'll try again: Does anyone have resources on how a functional language differs on a low level from for example java? What optimizations can the compiler make when everything is pure? The question I asked earlier makes me realize I have no idea what's going on and my assumptions are wrong, I thought a functional language copies stuff all the time.
15:48:19 <Koterpillar> rbnnn: http://joeduffyblog.com/2015/11/03/blogging-about-midori/
15:48:38 <mauke> being pure means you never have to copy anything because nothing is ever modified
15:48:41 <mauke> (this is a bit of a lie)
15:48:43 <geekosaur> most of what a pure functional language copies is pointers
15:48:49 <monochrom> rbnnn: https://github.com/takenobu-hs/haskell-ghc-illustrated may help
15:49:19 <geekosaur> and it does so more often than actual data because purity means it knows when some piece of data is immutable and just copying the pointer is safe
15:53:41 <rbnnn> Koterpillar: that looks very interesting, touches on all the right buzzwords I want to know about :D, moonchrom: I am too much of a novice for something that technical
15:54:30 <Koterpillar> rbnnn: if something isn't written to, you can pass it by reference
15:54:51 <Koterpillar> and if you can compute it beforehand, you can inline more
15:56:28 <rbnnn> Koterpillar awesome, if I understand correctly "not written to" is equivalent to a chained function in js, like .map(someFunc).map(someOtherFunc)?
15:57:26 <Koterpillar> var x = 1; x = 2; /* x is written to */
15:57:37 <Koterpillar> const x = 1; x = 2; /* error! */
15:57:53 <rbnnn> but..
15:58:09 <rbnnn> so written to means immutable?
15:58:28 <Koterpillar> immutable means the value cannot be changed
15:59:19 <rbnnn> hmm.. I don't see what you're saying.
15:59:28 <Koterpillar> const x = 1;
15:59:36 <rbnnn> yes.. sure
15:59:42 <Koterpillar> now the compiler is free to replace "x" with "1" everywhere
15:59:42 <rbnnn> cannot be changed
15:59:47 <rbnnn> yep
15:59:52 <Koterpillar> instead of making a memory access to x
16:00:02 <rbnnn> yes
16:00:08 <Koterpillar> also
16:00:16 <Koterpillar> var x = 1; f(); print(x);
16:00:29 <Koterpillar> even though x is mutable, f has no access to it because it's pure
16:00:46 <rbnnn> yeo
16:00:49 <rbnnn> *yep
16:00:50 <Koterpillar> therefore, you can go ahead and replace print(x) with print(1)
16:02:17 <rbnnn> uhh.. does your program have both const f and var f? i don't get the last step
16:02:33 <jle`> i wonder if data families are even relevant anymore now that we have injective type families
16:02:36 <Koterpillar> there's no const f or var f
16:03:09 <rbnnn> oh
16:03:16 <rbnnn> const x and var x
16:03:19 <rbnnn> my bad
16:03:26 <erisco> jle`, yes, for singletons at least
16:03:35 <Koterpillar> ignore all code samples but the last one
16:03:39 <jle`> does singletons even need data families anymore now that we have injective type families
16:03:48 <rbnnn> ohhh
16:03:49 <jle`> i thought singleton being a data family was a hack because of lack of injectivity
16:03:51 <rbnnn> I get it
16:03:54 <erisco> I don't know how they're related actually jle`, can you explain?
16:04:09 <rbnnn> f can't modify x, so it can "jump ahead" no worries
16:04:23 <jle`> erisco: the reason why Sing is a data family instead of a type family is because we didn't have injective type families
16:04:26 <erisco> well it'd be a big problem if Sing wasn't open
16:04:45 <erisco> I don't understand that reasoning
16:05:02 <Koterpillar> rbnnn: correct!
16:05:13 <rbnnn> but I still don't get this: >if something isn't written to, you can pass it by reference
16:05:29 <Koterpillar> OK, let's prepare an example of that
16:05:32 <jle`> erisco: for what reason do you believe that Sing is a data family instead of a type family?
16:06:22 <Koterpillar> rbnnn: which languages are you familiar with?
16:06:40 <rbnnn> js mostly, some java, smallc/pawn a long time ago
16:07:01 <rbnnn> Is it customary to always mention username? I am new to irc
16:07:14 <erisco> aesthetics, and injectivity sounds like a help like you mention
16:07:34 <erisco> but to have an injective type family it must be closed, afaik, and that won't work for Sing
16:07:54 <freeside> rbnnn: it might be helpful to read https://en.wikipedia.org/wiki/Copy-on-write to put you in the right frame of mind
16:08:05 <Koterpillar> rbnnn: when there's a few conversations going on, so you know it's for you and not anyone else
16:08:20 <rbnnn> freeside: will do
16:08:49 <jle`> erisco: open type families can be injective
16:09:02 <erisco> I wasn't aware
16:09:35 <jle`> no worries, i had to pause and open up ghci to check too heh
16:09:45 <erisco> then you still have the aesthetics of not needing another name for your singleton type
16:10:25 <jle`> yeah; so then it's not necessary for implementation, just a stylistic choice at this point
16:10:31 <jle`> but fwiw singletons does name every singleton type it exports
16:10:40 <jle`> the singleton type for bool sings is SBool
16:10:53 <erisco> you can also have data in classes, and that is directly supported by data families
16:10:54 <rbnnn> freeside: that's amazing! like a lazy copy operation..
16:10:56 <jle`> but it does this out of choice and not necessity, which makes me think that avoiding naming is not a priority
16:11:30 <jle`> oh, can associated tpyes not be injective?
16:12:01 <jle`> it looks like associated types can be injective
16:12:10 <erisco> what is an associated type?
16:12:22 <jle`> type families associated with type classes
16:12:27 <jle`> (that's what i thought you were talking about, at least)
16:12:35 <nshepperd> you can make a data family an instance of a type class
16:12:42 <jle`> oh, i see
16:13:06 <erisco> you can have types in classes as well which correspond to type families
16:13:09 <erisco> I was talking about data
16:13:27 <erisco> which corresponds to data families
16:14:04 <erisco> it is just a little syntax shuffling but you appreciate it when you need it
16:14:29 <freeside> rbnnn: so, in the haskell world where variables are immutable, the way you update state is by creating a new thing that is slightly different from the old thing; but behind the scenes, the compiler knows how to think about the deltas as a copy-on-write kind of problem.
16:15:04 <freeside> so you don't really have to worry about efficiency most of the time.
16:16:19 <freeside> http://stackoverflow.com/questions/4265660/updating-a-big-state-fast-in-haskell
16:17:36 <rbnnn> freeside: fantastic! I'm a novice programmer but I was thinking the other day about creating chains of parallel/unordered but not concurrent/orderer and not concurrent operations, or more advanced ordering rules of execution, is this the problem that functional programming languages solve also? I kind of feel like it when I'm reading but not sure
16:18:35 <freeside> in the real world, the love of money is the root of all evil.
16:19:04 <freeside> in software, premature optimization is the root of all evil.
16:19:25 <freeside> the advice is to first get it right, then make it fast.
16:19:37 <Rembane> So, what happens if you square it?
16:19:54 <freeside> you empower evil.
16:20:43 <nshepperd> hm, I wonder why Sing from singletons chose to write it as 'data family Sing (a :: k)' instead of 'Sing (k :: *) (a :: k)'
16:21:10 <freeside> besides, the smart people working on the layers of the tech stack below your software have already thought much more deeply about code optimization than you ever will; getting it right will match their expectations, and allow you to enjoy their optimizations.
16:21:15 <nshepperd> I find the explicitly kind indexed version a bit less confusing
16:21:50 <nshepperd> 'Sing Nat 5' instead of 'Sing (5 :: Nat)'
16:22:06 <freeside> once you become aware that your computer contains such devilry as https://en.wikipedia.org/wiki/Branch_predictor you will be satisfied to leave the nonobvious optimization to professionals.
16:22:48 <rbnnn> hmm, so I should assume the compiler knows best, in a wide sense?
16:23:06 <rbnnn> like not ever worry about number of function calls
16:23:33 <mauke> profile-guided worrying
16:24:08 <freeside> well, you should learn about strict, and you should learn how to instrument your code using things like Criterion.
16:24:22 <freeside> but before you learn about Criterion, which will help you make it fast, you should learn about Quickcheck, which will help you make it right.
16:24:47 <rbnnn> oh I haven't started with haskell yet at all
16:25:05 <orion> In industry/the professional world, how does one come up with QuickCheck properties that should hold in your application? It seems like an art.
16:25:18 <rbnnn> I'm just interested in the functional thing because I studied some math before I started programming and it makes sense
16:25:39 <rbnnn> or at least it's similar
16:25:54 <erisco> orion, well, what do you expect your program to do? test for that
16:26:14 <Koterpillar> orion: or, what do you expect your program to never do?
16:26:46 <mauke> never fail, never surrender
16:27:11 <monochrom> never terminate. :)
16:27:36 <orion> But that seems like unit testing rather than property testing.
16:27:39 <erisco> friend wrote something called the immortality protocol which handles interrupts by restoring the state, setting the pointer to the next instruction, and keep going
16:28:02 <erisco> solved some minor crashes on old games
16:28:19 <freeside> rbnnn: you could look at the reviews of https://www.amazon.com/Parallel-Concurrent-Programming-Haskell-Multithreaded/dp/1449335942
16:29:15 <mauke> ON ERROR RESUME NEXT
16:29:36 <freeside> think of writing Quickcheck tests as a giant Wason Card Problem
16:30:12 <freeside> testing for things your program should never do is as important as testing for things your program should do
16:30:29 <erisco> orion, they're related. In unit tests you test the individual cases
16:30:41 <erisco> and quickcheck does just that, afaik, it just figures out good cases to try
16:31:19 <erisco> in my opinion you should be writing unit tests in that manner anyways
16:31:41 <erisco> I know there is a rudimentary thing of a list of inputs and a list of expected outputs but this is a weak way of reasoning about the program
16:33:00 <erisco> once you decide what your program is supposed to do, it is then quite easy to run through thousands of cases
16:33:30 <erisco> if your program takes two ints it is trivial to take the product of all the ints in a range and run your program on it
16:34:00 <erisco> afaik what quickcheck adds is inspection on your program to more intelligently choose cases
16:34:12 <freeside> if you find yourself falling in love with test-driven development, you may be a natural candidate for test-ONLY development: https://community.embarcadero.com/blogs/entry/testonly-development-with-the-z3-theorem-prover-38818
16:34:21 <erisco> running a hundred-thousand cases is not practical when you have thousands of tests in the suite
16:35:04 <ggVGc> tests?
16:35:06 <ggVGc> type system!
16:35:15 <mauke> embarcadero? are they the ones who are currently running delphi into the ground?
16:37:05 <orion> erisco: Finding a generalization from individual test cases isn't easy.
16:39:59 <erisco> that isn't how you start
16:40:02 <erisco> or at least it isn't how I start
16:42:13 <erisco> for example, if you want to write a sorting algorithm, don't begin with sort [] = [], sort [2,1] = [1,2], sort [1,2,1] = [1,1,2]  and so on
16:42:31 <erisco> begin with how sort xs relates to xs
16:43:11 <MarcelineVQ> hmm, that's quite often what I see reccomended here, starting from the back case and iterating out until a pattern emerges you can abstract
16:43:19 <MarcelineVQ> *base case
16:43:22 <erisco> we can do this together orion so you can become wise in the art ;)
16:43:59 <mauke> MarcelineVQ: for testing or for implementing?
16:44:23 <erisco> the base case may be relevant, sure, and it isn't wrong to think about different cases
16:44:29 <MarcelineVQ> implementing, hmm I did that thing again where I don't read the scrollback didn't I :X sorry
16:44:58 <erisco> I am saying you don't want to write a program that satisfies the few cases you've figured out and then try and retrofit some general statement about it
16:45:11 <erisco> you haven't really understood the objective before you've gone and implemented it
16:45:12 <orion> erisco: You would check that each subsequent item is greater than the previous.
16:45:50 <erisco> orion, good start, so then lets think about the implications of this
16:46:00 <mauke> I think that's half the spec of sort: the result must be non-descending
16:46:06 <erisco> what you stated is more fancily called "monotonically increasing"
16:46:11 <orion> Sure.
16:46:33 <erisco> lets think about what will satisfy this spec
16:46:44 <erisco> what if I write sort = const []
16:47:13 <orion> Ok, and that length . sort $ xs == length xs
16:47:34 <mauke> that's actually a type error but I know what you mean :-)
16:48:09 <erisco> sort (x:_) = replicate (length xs) x; sort [] = []
16:48:28 <mauke> sort xs = [ head xs | _ <- xs ]
16:48:29 <erisco> lets assume replicate and length are defined on Integer... there is genericLength but not a genericReplicate
16:49:13 <orion> And that every element in (sort xs) exists in xs
16:49:27 <Koterpillar> the other way around
16:49:52 <mauke> more generally, you want sort xs to be a permutation of xs
16:49:53 <jle`> orion: not enough; you also need the correct multiplicities of each item
16:50:18 <erisco> I won't write out the definition, but we can nub the list (removes duplicates) and pad out the length (using whatever element we want)
16:51:01 <Koterpillar> you'll have to sort the result, though
16:51:17 <mauke> sort xs = take (length xs) (cycle (nub xs))
16:52:00 <Koterpillar> mauke: not monotonic
16:52:02 <mauke> > take 0 (cycle [])
16:52:05 <lambdabot>  []
16:52:10 <erisco> we began with "a sort program" and gave a stab at defining what we mean by "sort" by saying sort xs must be monotonically increasing
16:52:12 <mauke> yeah, put a real sort around that
16:52:33 <erisco> and then we attack this proposed meaning by trying to think of ways it doesn't agree with our intent
16:52:46 <erisco> this is the phase where you want all your mistakes to happen
16:52:51 <erisco> and we made a few
16:53:10 <erisco> you may not have thought of all these problems right away but that is part of the practice
16:53:58 <erisco> I like to say it in two parts. 1) sort xs must be monotonically increasing, 2) sort xs must be a permutation of xs
16:54:10 <orion> Sure, I follow.
16:54:56 <erisco> once we feel that we've really captured what we wanted to mean we go ahead and write the program
16:55:22 <erisco> and if the type system allows it you can have this spec as part of the type
16:55:28 <Koterpillar> A subset of this approach is: write an inefficient version and check that the optimized one produces the same results
16:55:49 <orion> This is a very nice self-contained example, but it's not the world I live in.
16:56:15 <erisco> sure, the world is dirty, and I don't know what it means to show a popup box
16:56:21 <orion> In my day to day life I have RESTful APIs written in scotty that consult PostgreSQL databases and send messages to RabbitMQ.
16:56:36 <erisco> so here is how I tackle the practical
16:57:10 <erisco> as you develop software you will have some libraries/modules/namespaces/APIs/layers/whatever that become deeper, as in more and more depends on them
16:57:24 <erisco> as this happens you increase the extent to which you test them
16:57:57 <erisco> this allows brand new things which have no dependencies to be done quickly and ensures important things are tested
16:58:35 <erisco> the things that sink to the bottom tend to have simpler parts to them, it isn't just the glue code
16:58:45 <erisco> and are more ideal to test rigorously
17:02:55 <orion> All of this makes sense.
17:06:24 <erisco> a practical problem is that when you write something new and you experience an error the first assumption is that it is with what you just wrote
17:06:38 <erisco> and errors in what you just wrote are the easier to fix
17:07:03 <erisco> whereas if the error is deep down in some other library it can take a while to even identify that is the case
17:07:15 <erisco> and further you may have little or no knowledge about the code that is failing
17:08:47 <erisco> and then depending on the tools, getting a patch out can be a delay
17:09:31 <erisco> and on your team's practices
17:10:39 <orion> Right.
19:28:38 <khouli> hello, can anyone give me pointers on how to implement plugins with recent GHC?
19:29:03 <khouli> I didn't have any luck with System.Plugins.Load
19:29:44 <khouli> I did have luck with GHCi.ObjLink
19:30:54 <khouli> if there's some 'preferred' way to do this, maybe something less GHC specific, I'd like to know about it
19:33:06 <monochrom> The preferred way doesn't exist yet, but it consists of someone updating System.Plugins to today's GHC API. The library "hint" is pretty close though.
19:34:34 <monochrom> In fact if you relax from "must load *.o" to "I'm fine with loading *.hs and interpreting", then hint does it.
19:34:41 <khouli> thanks, I'm checking out hint, sounds interpreter oriented though, is it appropriate for plugins that can be compiled?
19:35:12 <monochrom> Also mueval, which is what lambdabot uses.
19:35:26 <monochrom> No unfortunately.
19:38:45 <khouli> interpretting isn't a dealbreaker, but let me give some details for what I want to do: there is an early opportunity for compilation and loading, then a long runtime that will use the plugin code
19:38:54 <khouli> thoughts on the best approach in that case?
19:41:00 <monochrom> An up-todate library for that doesn't exist. It will take a lot of work to make it (a lot of learning of the GHC API).
19:42:05 <khouli> darn, out of curiosity, why is it that System.Plugins is broken?
19:42:31 <monochrom> GHC API changed a lot. Also, System.Plugins was a long time ago.
19:43:01 <monochrom> it works fine if you go back to a GHC version of those days, but will you want to?...
19:44:52 <khouli> indeed I don't, so then the GHC API itself is my only option if I want to use recent GHC and get the behavior I described, right?
19:45:52 <monochrom> Yes.
19:48:21 <khouli> how difficult do you think it would be for a non-expert like myself to bring System.Plugins up to date?
19:52:52 <khouli> I guess what I mean is: would that be something only someone already experienced with the GHC source should approach?
19:54:26 <monochrom> No need for GHC source code. Just the GHC API docs. But I think it will still take a while.
20:00:55 <khouli> suggested GHC API tutorial reading? (google does give me several relevant hits but if there are specific suggestions, I'd like to know)
20:03:21 <khouli> so far what I'm reading is on the API for GHC 7.x, how huge of an API break was GHC 8?
20:05:21 <monochrom> I don't know of a tutorial.
20:10:07 <khouli> what about docs in general? for example, the GHCi.ObjLink docs at https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/ghci-8.0.1/GHCi-ObjLink.html are very sparse; I just want to check if that's all there is (if that's the case, then ok, I just need to deal with it) or if there's another source for docs I don't know about
20:12:15 <monochrom> No, start with https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/ghc-8.0.1/GHC.html
20:17:02 <khouli> thanks, I hadn't found that page, looks like it'll be a bit of a slog before I grok enough, any other docs/info I should be looking at?
20:17:42 <monochrom> Other modules in the same neighbourhood. (Click "Contents" in the top right.)
20:18:09 <monochrom> But that's a lot of modules and disorienting. Use the "GHC" module as the centre.
20:19:19 <khouli> also, what was (or how can I found out) the last GHC version for which System.Plugins worked?
20:19:36 <monochrom> I forgot.
20:19:45 <monochrom> Maybe 6.something
20:20:48 <khouli> wow, so quite some time ago? alright, so I guess I'd have to walk backwards through the GHC git repo if I want to know?
21:27:18 <Zemyla> I found an error on the GHC Trac. https://ghc.haskell.org/trac/ghc/query?status=closed&col=id&col=summary&col=owner&col=type&col=priority&col=milestone&col=component&col=changetime&desc=1&order=changetime
21:27:26 <jle`> this gets asked every once in a while but i don't think i've ever caught the answer ... does anyone know if there's a way to have ghc only show the first error
21:27:39 <jle`> i'm doing a big refactor and scrolling back up is pretty annoying v.v
21:28:39 <Zemyla> I tried sorting by modified, but it seems the last couple of pages have some sort of error that prevents me from doing so.
21:30:47 <Zemyla> It seems to occur when I have the Modified column open and a ticket without a Modified date is in it.
21:40:18 <_deepfire> how do I convert a c2hs-generated function wrapper value into a raw C pointer?
21:41:08 <_deepfire> ..or, at least, into a FunPtr
21:42:01 <_deepfire> it /seems/ as if unsafeCoerce gives something else (at least it leads to a segmentation fault..)
21:46:29 <alexbrown> clear
21:46:34 <alexbrown> Hi all.
21:50:00 <_deepfire> sadly, so far it appears the easiest way to obtain the function's pointer is to re-declare the c2hs-generated function using a manual "foreign" declaration : -)
21:50:28 <alexbrown> I have this code https://dpaste.de/nzUw but when i run call `average (inc 3) (inc 5)` got errors `No instance for (Fractional Int) arising from a use of ‘average’`. I am new with Haskell, Please tell me why, and how can i fix it. Many thanks.
21:52:02 <peddie> alexbrown: doesn't `average` have type `Fractional a => a -> a -> a`?
21:52:23 <Koterpillar> alexbrown: you are using Num, so you promise that 'average' will work on Int, but (/) doesn't
21:53:53 <alexbrown> peddie: Koterpillar So, Should I change type signature of `average` from `Num` to `Fractional`?
21:55:00 <Koterpillar> :t (/)
21:55:03 <lambdabot> Fractional a => a -> a -> a
21:55:10 <Koterpillar> :t \x y -> (x + y) / 2.0
21:55:13 <lambdabot> Fractional a => a -> a -> a
21:55:27 <Koterpillar> alexbrown: see, that's the inferred type
21:57:15 <peddie> I'm actually a bit puzzled how alexbrown was able to write this type signature using `Num` and the compiler accepted it
21:57:50 <Koterpillar> :t (\x y -> (x + y) / 2.0) :: (Num a => a -> a -> a)
21:57:52 <lambdabot> error:
21:57:52 <lambdabot>     • Could not deduce (Fractional a1) arising from a use of ‘/’
21:57:53 <lambdabot>       from the context: Num a
21:58:00 <Koterpillar> I guess it didn't
21:58:07 <peddie> my guess too :)
22:15:48 <halogenandtoast> Howdy all!
22:17:30 <pacak> o/
22:19:21 <centril> is  (Any, a)  a valid dual of  Maybe a  ?
22:19:39 <centril> (is calling it a dual valid?)
22:20:06 <Koterpillar> :k Any
22:20:07 <lambdabot> *
22:20:51 <centril> Koterpillar: Any is Bool with (||) as monoid instance
22:23:10 <centril> (Any, a) as a monad always has an a , but also yields if there was a change anywhere
22:26:52 <halogenandtoast> As someone who only a a topical understanding of Monads and Monoids (nevermind duals) I find this question interesting, but I'm unable to answer
22:27:26 <centril> halogenandtoast: you and me both =)
22:29:03 <Koterpillar> would it need to be a comonad?
22:31:11 <centril> Koterpillar: well, (,) e   is a comonad without requiring that e be a Monoid, Any is a monoid tho
22:31:20 <centril> http://hackage.haskell.org/package/comonad-5/docs/Control-Comonad.html
22:31:44 <centril> but i dont know if it has to be a comonad to be a dual of Maybe
22:32:25 <Koterpillar> what is a dual?
22:33:37 <alexbrown> Many thanks all.
22:33:56 <centril> Koterpillar: http://math.stackexchange.com/questions/1518509/what-does-dual-mean-exactly-in-mathematics
22:35:26 <centril> I'm thinking that since  Maybe has the semantics as  All, and since you maybe don't have a result at the end while (Any, a) always has an a  , and that All is the dual of Any  - then they should be dual, no?
22:38:14 <Koterpillar> so what's this operator on the type system?
22:38:50 <centril> Koterpillar: dont understand the question...
22:39:13 <Koterpillar> your link says there's a negation operator that turns operations into their duals
22:39:50 <Koterpillar> my best guess for what it is for the type system is turning the arrows backwards (Control.Category.Dual?)
22:40:09 <MarcelineVQ> sometimes
22:40:45 <centril> right, there isnt  a function  Maybe a -> (Any, a)  since there might be Nothing
22:40:55 <centril> is that required?
22:41:12 <Koterpillar> well, I'm happy to take some type-level transformation
22:41:45 <Koterpillar> from a to Maybe a it's (a + 1)
22:42:31 <Koterpillar> from a to (Any, a) it's (a * 2)
22:45:43 <centril> Koterpillar: what does this tell us?
22:46:03 <Koterpillar> I don't know yet. Do you have any other examples of duals?
22:46:52 <centril> Koterpillar: Last is the dual of First
22:47:20 <Koterpillar> shouldn't Any be dual of All then?
22:47:29 <centril> Koterpillar: it is
22:47:41 <centril> Koterpillar: because (&&) is the dual of (||)
22:48:32 <Koterpillar> so, what does the fact that they are dual of each other give you?
22:49:06 <centril> Koterpillar: nothing - it was just an academic intrest
22:49:48 <Koterpillar> I'm just trying to figure out what a dual actually is
22:50:00 <centril> it's a bit unclear to me as well
22:50:49 <Koterpillar> and if you can't derive useful properties out of it, is there a point talking about it?
22:51:04 <MarcelineVQ> it's lots of things https://en.wikipedia.org/wiki/Duality_(mathematics)
22:51:37 <MarcelineVQ> there's a Dual monoid for example that swaps the order of arguments for mappend, what's interesting about it is that is can only create 'duals' for non-commutative Monoids
22:52:40 <MarcelineVQ> Last and First for example, yet not Any and All iiuc
22:52:49 <Koterpillar> here's my lousy definition: A :: (* -> *) is dual to B :: (* -> *) if B (A x) is isomorphic to x
22:53:11 <centril> MarcelineVQ: how can Any and All not be the dual of each-other ?
22:54:00 <centril> Koterpillar: can  A :: *  not be the dual of  B :: * ?
22:54:02 <MarcelineVQ> I've no idea about how to classify that, I was just noting that the Dual monoid wouldn't have an appreciable effect on them because they're commutative
22:54:44 <Koterpillar> I still don't know what do you get out of any of these definitions
22:54:44 <centril> MarcelineVQ: iirc A can be the dual of A
22:55:13 <Koterpillar> i.e. if I prove something for A, can I get something for B?
22:55:40 <Koterpillar> because if not, then such definition isn't useful
22:56:22 <centril> Koterpillar: we need to consult a mathematician ;)
22:56:32 <centril> they think it is useful
23:01:30 <MarcelineVQ> ah, an ezyang special http://blog.ezyang.com/2012/10/duality-for-haskellers/
23:02:11 <Koterpillar> close
23:02:12 <centril> thanks, ill add that to my reading list
23:02:13 <MarcelineVQ> probably just for one meaning of dual but hopefully relevant
23:02:36 <Koterpillar> so, we have Just :: a -> Maybe a
23:02:54 <Koterpillar> and Nothing :: () -> Maybe a
23:04:33 <Koterpillar> then (Bool, a) indeed has duals snd :: (Bool, a) -> a and fst :: (Bool, a) -> ...oops
23:05:21 <Koterpillar> doesn't look right anymore
