00:12:40 <Jello_Raptor> Is there a good way to find all the places where I call `show` on a type that won't force me to go through and temporarily nix the show instances of a gigantic pile of other types? 
00:12:52 <Jello_Raptor> like marking it deprecated or something. 
00:15:29 <joneshf-laptop> Jello_Raptor, what are you trying to accomplish?
00:16:04 <joneshf-laptop> Forgive me for assuming, but your question sounds like a means to an end.
00:16:08 <Jello_Raptor> I'm making a change to a core type that means I have to lookup a description string from a table, rather than just pull it out of the type.
00:16:35 <Jello_Raptor> I want to find all the places where I use "show" on that type so I can replace it with a lookup that's actually useful.
00:17:47 <cocreature> you can’t mark instances or instance methods as deprecated so that doesn’t work
00:19:11 <cocreature> Jello_Raptor: but if you want to replace all places why can’t you temporarely delete the Show instance?
00:20:50 <Jello_Raptor> cocreature: It would mean deleting the show instances of a huge pile of other types which isn't necessary and would be a huge pain
00:21:09 <cocreature> Jello_Raptor: ah right I forgot about that
00:21:41 <joneshf-laptop> Jello_Raptor, to make something concrete here, are you using the `Show` instance of your data type for pretty printing or formatting?
00:21:54 <dmwit> Why would it mean that? Don't those other `Show` instances also qualify as uses of `show` at this type?
00:22:07 <dmwit> (Hence should be replaced with a "useful lookup"?)
00:22:12 <joneshf-laptop> ^
00:24:30 <Jello_Raptor> joneshf-laptop: debug output generally
00:24:49 <joneshf-laptop> Jello_Raptor, What I mean to say is that, if you're using the `Show` instance for pretty printing/formatting, you probably want a different function altogether. However, this new function doesn't need to conflict with the `Show` instance. I.e., use `show` when you need a `read`able string, and use this new function when you need pretty print/format.
00:26:04 <Jello_Raptor> dmwit: not really, the way I've structured my system the 
00:26:24 <Jello_Raptor> dmwit: not really, the way I've structured my system the output will be reasonable regardless. 
00:26:25 <joneshf-laptop> Jello_Raptor, Alternatively, could you hand-write a show instance that did what you wanted? Again, that's against the use case of `Show`, but if it's temporary, it's probably not a big deal.
00:26:59 <Jello_Raptor> joneshf-laptop: nope, what I need is a monadic operation
00:27:38 <ggVGc> don't we all
00:28:33 <joneshf-laptop> Jello_Raptor, nope to what? You can't have both `show` and another function? Or, you can't handwrite the `Show` instance?
00:29:54 <Jello_Raptor> I can't handwrite the show instance without some unsafe IO :/ 
00:30:04 <joneshf-laptop> Jello_Raptor, gotcha
00:30:17 <Jello_Raptor> since the nice names (rather than the tiny integer references) are stored in a state
00:30:30 <Jello_Raptor> and getting them back out is a monadic operation
00:30:33 <joneshf-laptop> Jello_Raptor, so, you don't know where you use `show`?
00:30:49 <joneshf-laptop> Jello_Raptor, Sorry, having a bit of trouble internalizing the problem.
00:30:58 <Jello_Raptor> joneshf-laptop: I'm looking for an easier to find all the uses for this one type, yes
00:31:05 <Jello_Raptor> easier way* 
00:31:38 <joneshf-laptop> Jello_Raptor, also, what about nixing the instance and using `-fdefer-type-errors`? Wouldn't that give you a whole slew of warnings instead of failing at the first errors?
00:32:08 <Jello_Raptor> oh, that might work
00:32:19 <joneshf-laptop> Or would you still only get the same number of warnings as you would've gotten errors originally?
00:33:09 <joneshf-laptop> Meaning, just the data types complaining about missing `Show` rather than at the `show` uses.
00:33:28 <nshepperd_> Remove the instance, mock out all the dependent instances with undefined, then all remaining errors will be lines you need to change
00:35:48 <joneshf-laptop> nshepperd, I think the mocking part is what Jello_Raptor doesn't want to do.
00:36:10 <Jello_Raptor> nshepperd: reasonable enough, cool. 
00:36:17 <Jello_Raptor> yeah, I'd rather not
00:36:24 <Jello_Raptor> but eh, I can deal vov
00:36:40 <MarcelineVQ> mock out?
00:36:46 <nshepperd_> Yeah. At least you don't have to delete them recursively, i guess
00:36:47 <joneshf-laptop> Wouldn't you still have a problem though?
00:37:22 <joneshf-laptop> If it's `data Foo = Foo ... deriving Show; data Bar = Bar Foo deriving Show` and you delete the `Show` for `Foo`, how do you mock that?
00:37:48 <MarcelineVQ> Jello_Raptor: idk exactly what you're doing but are you aware of https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#custom-compile-time-errors ?
00:38:13 <nshepperd_> It might be worth trying with -fdefer-type-errors though in case that works
00:39:25 <Jello_Raptor> MarcelineVQ: that looks like it's almost exactly what I want, just mock out the show instance with that and get the errors i need. 
00:39:48 <nshepperd_> joneshf-laptop: instance Show Bar where
00:41:32 <Jello_Raptor> damn, it triggers errors in the derived show instances too
00:43:50 <joneshf-laptop> How many dependent data types are we talking here?
00:44:00 <joneshf-laptop> Might be quicker to just bite the bullet.
00:44:13 <Jello_Raptor> yeah, I'm in the middle of it now
00:44:22 <Jello_Raptor> probably ~ 50 or so 
00:45:04 <Jello_Raptor> but at least they're mostly defined using `standalone deriving` so it's straightforward to comment them out.
01:01:00 <Vibor> Hi how can I use '.' or '$' to truncate a line like this : DM.appendDB fileName (makeUPTuple (argv !! 1)  (argv !! 2 ++   "\n"))
01:01:33 <Vibor> I meant truncate parenthesis
01:01:43 <dmwit> appendDB file . makeUPTuple (argv !! 1) $ argv !! 2 ++ "\n"
01:02:33 <Vibor> dmwit: and is there a way to deal with parenthesis enclosing argv !! 1 ?
01:02:46 <dmwit> Not with the standard library.
01:04:59 <Vibor> So maybe this question looks stupid, but does it mean it's not always a bad haskell coding style if you have parenthsis around statements cuz cometimes they are just unavoidable?
01:05:07 <Vibor> dmwit: 
01:05:34 <dmwit> Explicit parentheses are often the most readable style.
01:05:37 <MarcelineVQ> tons of people prefer parens over $
01:06:44 <Vibor> MarcelineVQ: really? I saw lots of references recommending getting rid of them for readability
01:09:50 <ertes> Vibor: ($) makes code flat, so you lose a lot of visual structure…  unless you restore it by a consistent style or layout, it's preferable to use parentheses
01:09:55 <MarcelineVQ> ultimately it's up to what you find most readable, anecdotally what I've noticed is that people starting out seem to use $ a lot, possibly due to reccomendations like you've encountered, but use it less as they gain experience.
01:10:15 <ertes> Vibor: there is one notable exception: associative functions
01:10:36 <ertes> 1 + 2 + 3 + 4
01:10:39 <ertes> f . g . h . i
01:11:01 <MarcelineVQ> I don't have any particular explanation for why this seems to happen, other than as you reason about function application more and also understand precedence $ is often redundant
01:11:41 <ertes> also "$" is pretty ugly, but that may be my PHP trauma talking =)
01:12:58 <Vibor> Indeed, not just $ chaining up parameters, I saw others prefer . to compose functions as well, maybe it makes their codes more "functional" 
01:13:57 <dmwit> I prefer (.) to ($) for chaining.
01:14:19 <ertes> i find myself writing "(f . g . h) x" a lot, just to have a visual cue that somewhere down the line there is an argument following
01:14:52 <dmwit> In `foo . bar . baz $ quux`, I can extract `foo . bar . baz` as a function (or subterms of this). In `foo $ bar $ baz $ quux`, I cannot extract `foo $ bar $ baz` as a function because it means something significantly different.
01:15:20 <Vibor> dmwit: indeed 
01:15:34 <ertes> Vibor: i think the important part is that (.) is associative, while ($) is not, so parentheses wouldn't even make a difference
01:15:43 <ertes> (f . g) . h = f . (g . h)
01:16:40 <Vibor> Another math lesson lol
01:17:24 <ertes> welcome to #haskell =)
01:17:46 <Vibor> I love it a lot so far :D
02:02:07 <parsnip> the . are easier to visually scan for than the $, i find
02:02:56 <parsnip> and the possibility to chop off the tail of f . g . h $ x is nice too
02:33:20 <venkat24> Is there an ideas page for Summer of Haskell yet? Will there be one?
03:55:32 <reactormonk> I'm experimenting with the code in the eff paper, however, it doesn't compile - http://lpaste.net/1875206206314774528
03:58:14 <int-e> reactormonk: that >>> should be >>= I guess?
03:59:00 <cocreature> isn’t it >=>?
03:59:37 <int-e> Right.
04:00:48 <reactormonk> Ah, they call >>> kleisli composition, for whatever reason.
04:00:50 <Destol>  /bye
04:01:22 <reactormonk> I guess defining an applicative instance is an exercise left to the reader.
04:01:24 <cocreature> I hate it when papers use relatively common symbols but assign a different meaning to them
04:01:37 <cocreature> reactormonk: that’s easy "pure = return", <*> = ap
04:03:00 <reactormonk> cocreature, aaand the functor, but I should manage that one on my own, thanks for your help.
04:03:47 <cocreature> reactormonk: using do notation, implementing fmap is trivial
04:04:09 <cocreature> or just use liftM
04:04:25 <reactormonk> Hmm, that sounds interesting.
04:04:43 <reactormonk> I would have taken the bruteforce approach
04:04:58 <cocreature> what’s that?
04:05:06 <cocreature> play type tetris until it compiles?
04:05:45 <reactormonk> >>= return basically
04:06:00 <reactormonk> Yeah, if you know the pieces it's easier :-)
04:06:17 <cocreature> that’s exactly what liftM and do notation will desugar to :)
04:07:48 <reactormonk> ahh, nice.
04:08:30 <cocreature> "do x' <- x; return f x" desugares to "x >>= return . f"
04:08:45 <cocreature> eh I’m missing parenthesis
04:32:17 <rmrfroot> i have a haskell program that doesn't output everything on stdout when running it using systemd, i have a vague memory about buffering in haskell that could be the issue, anyone know what i'm talking about?
04:33:42 <reactormonk> rmrfroot, default unix buffer flushing is per newline.
04:34:03 <kuribas> rmrfroot: output with which functions?
04:35:48 <rmrfroot> kuribas: i'm using Text.putStrLn :) 
04:36:40 <rmrfroot> reactormonk: alright, so it *should* output everything since I'm using putStrLn
04:37:55 <rmrfroot> kuribas: where `Text` is: `import qualified Data.Text.Lazy.IO as Text`
04:38:23 <kuribas> rmrfroot: isn't the output redirected somewhere?
04:42:34 <rmrfroot> kuribas: i'm not using any redirection when calling the program, and inside the program I only use that putStrLn function, which says "Write a string to stdout, followed by a newline.". 
04:43:41 <kuribas> rmrfroot: sorry, I don't know then...
04:46:49 <rmrfroot> kuribas: no worries, maybe it's something with systemd, because if if I redirect stdout to a file everything is in that file
04:47:26 <kuribas> rmrfroot: yeah, that could be it.  Maybe line length?
04:48:06 <Vibor> Hi, I'm having problem with this little piece of code : https://ptpb.pw/Txwi  I figured I had to add fromIntegral in order to solve the problem, but why?
04:49:46 <QRealm> I think that's because of the definition of (^) :: (Num a, Integral b) => a -> b -> a
04:52:32 <Vibor> QRealm: so it was (fact oddTerm) did not return the proper type? what did it return without fromIntegral?
04:55:27 <QRealm> right, fact returns a simple Integer whereas you need a Fractional Integer to do the division
04:55:55 <QRealm> so it's because of the division op instead of the ^, sorry
04:58:05 <reactormonk> Uhm, how do you do basic string interpolation in haskell? for Show instances.
04:58:13 <reactormonk> Just with ++?
05:00:35 <rmrfroot> kuribas: seems like the problem is related to systemd/journald: "It's a kernel race... if you program exits, the last messages are lost. This is because before journald can read them, your program is already dead and we cannot figure out which cgroup it belonged to", source: https://github.com/coreos/bugs/issues/373#issuecomment-113631450
05:02:01 <kuribas> reactormonk: ++, printf, formatting, TH (there are libraries on hackage for that).
05:02:35 <kuribas> reactormonk: for example https://hackage.haskell.org/package/interpolate
05:04:06 <Vibor> QRealm: But if I change x^oddTerm simply into x, it would not give me an error message
05:04:15 <kuribas> reactormonk: I like to use printf, but it's not type safe.
05:04:51 <ADG> im trying to do https://projecteuler.net/problem=1
05:05:17 <ADG> for(int i=1;i<=1000;i++)if(i%3==0||i%5==0)sum+=i;
05:05:19 <kuribas> reactormonk: this one seems more recent: https://hackage.haskell.org/package/marvin-interpolate-1.1/docs/Marvin-Interpolate.html
05:05:29 <kuribas> reactormonk: beware that TH may increase compile times.
05:06:37 <int-e> ADG: "below"
05:06:47 <int-e> but what does this have to do with Haskell?
05:07:10 <ADG> i meant to say that im begining haskell , so i thought proj.eu. wud be a gud place
05:07:30 <ADG> what do i write something like this for haskell?
05:08:05 <ADG> sum (x | x<-[1...999] , x%3==0 & x%5==0)
05:08:09 <ADG> how about this?
05:08:34 <int-e> > ([1..10],[x | x <- [1..10], x `mod` 3 == 0 || x `mod` 5 == 0])
05:08:36 <lambdabot>  ([1,2,3,4,5,6,7,8,9,10],[3,5,6,9,10])
05:08:41 <kuribas> ADG: list comprehension you square brackets
05:09:09 <ADG> how to do `cout`?
05:09:26 <Vibor> https://ptpb.pw/Txwi It may seem silly but I still don't quite understand why I have to add fromIntegral before (fact oddTerm) in this code, without it it would give me an Ambiguous type variable error
05:09:32 <kuribas> > sum [x | x<-[1...999] , x `rem` 3==0 && x `rem` 5==0]
05:09:34 <lambdabot>  error:
05:09:34 <lambdabot>      • Could not deduce (Num (Over p f c0 c0 a b))
05:09:34 <lambdabot>          (maybe you haven't applied a function to enough arguments?)
05:09:58 <int-e> ADG: print, or just evaluate the thing in ghci
05:11:41 <int-e> kuribas: oh wow. all because you had one extra '.'
05:11:55 <kuribas> > sum [x | x <- [1..999] , x `rem` 3==0 && x `rem` 5==0]
05:11:57 <lambdabot>  33165
05:11:58 <kuribas> :t (...)
05:11:59 <lambdabot> (Plated c, Applicative f) => LensLike f s t c c -> Over p f c c a b -> Over p f s t a b
05:12:06 <kuribas> int-e: ... is a lens thing?
05:12:34 <int-e> apparrently.
05:12:51 <kuribas> ADG: best thing for you would be to get familiar with the prelude.
05:14:48 <kuribas> ADG: also #haskell-beginners
05:15:04 <ADG> i did make a 1.hs with ans = sum [x | x<-[1..999],x `mod` 3==0 || x `mod` 5==0]
05:15:12 <ADG> then ghci, :l 1.hs then ans
05:15:15 <ADG> it worked
05:25:07 <spatial> Is there hprintf ?
05:25:37 <spatial> Equivalent to printf that writes to file
05:26:24 <feuerbach> yes, hPrintf
05:30:18 <Adrian_____> hey guys i've just started haskell today and im unsure about two simply exercises. could one of you possibly help me out and send an .hs file with the solution id really appreciate it! http://imgur.com/a/cUIps
05:32:58 <Axman6> Adrian_____: You know you're supposed to do these exercises yourself right?
05:33:02 <feuerbach> Adrian_____: I doubt that having an .hs file with the solution will help you learn Haskell
05:33:21 <feuerbach> Adrian_____: is there something in particular you're struggling with?
05:33:30 <Axman6> Adrian_____: how did you start COMP1100 just today by the way?
05:33:42 <spatial> log  message = withFile "C:/Haskell/rl/game.log" AppendMode (\ fd -> hPutStr fd message ) I am trying to pass this to functions to write logs.
05:34:11 <Levex> Adrian_____, have a look at pattern matching and the operator (:) 
05:34:31 <spatial> The ''message'' is dynamic. How ?
05:35:00 <Adrian_____> ok im gonna try it out
05:35:32 <feuerbach> spatial: not sure what you're asking
05:36:06 <Axman6> Adrian_____: where did you get those exercises anyway? They're clerly from ANU's COMP1100 course, but an old version of them
05:36:23 <spatial> I mean the call site is this. log $ printf "%d" 1
05:37:03 <Adrian_____> wait really?
05:37:24 <Adrian_____> im in year 10 high school in sydney
05:37:25 <Axman6> yes
05:37:37 <spatial> So 'message' is dynamic parameter
05:37:57 <Axman6> Adrian_____: that's interesting, how are you connecting from a machine at ANU then?
05:38:04 <Adrian_____> oh actually
05:38:13 <Adrian_____> i totally missed that is says anu at the top of the pdf
05:38:34 <Adrian_____> ok lolmeme
05:38:51 <Jinxit> lmao
05:38:53 <feuerbach> wtf was that
05:39:10 <Axman6> I'm one of the tutors on that course...
05:39:19 <feuerbach> spatial: the result of printf "%d" 1 is String (at least it can be specialized to String)
05:39:24 <feuerbach> so I don't see a problem there
05:39:25 <Jinxit> oh that makes it even better
05:39:54 <feuerbach> and your log function accepts a String
05:52:54 <Axman6> @tell chrisdone Hey, it looks like http://ircbrowse.net/browse/haskell is having issues (A web handler threw an exception. Details: libpq: failed (another command is already in progress))
05:52:54 <lambdabot> Consider it noted.
06:02:03 <zcourts> I'm trying to extract a list of DataCon from GHC module summaries, I wrote http://pastebin.com/C4Mn9jGa - I'm getting "No instance for (GhcMonad Maybe) arising from a use of ‘infoOpt’". I get the gist of what's wrong but I can't figure out how to do infoOpt in the Ghc monad (I thought it was until I got the error)
06:03:46 <zcourts> full error http://pastebin.com/Q6hQubnL
06:09:14 <Athas> Does accelerate-cuda use 64-bit arithmetic for its index calculations?
06:15:31 <spatial>  log $ printf "Value %f\n " value This should write if file is opened in append mode ?
06:17:23 <spatial> logs  message = withFile "C:/Haskell/rl/game.log" AppendMode (\ fd -> hPutStr fd message )
06:21:06 <ADG> to get the k'th element why is this wrong elementAt (x:xs) k   | k==1 = x   | otherwise = elementAt xs k-1
06:22:14 <cocreature> ADG: you are missing parenthesis "elementAt xs (k-1)"
06:30:42 <laserpants> shouldn't it be k==0 = x ?
06:32:09 <cocreature> laserpants: depends on whether you want 0 or 1-based indices :)
06:33:51 <laserpants> cocreature: yes, that's true. But you're right.. k-1 should be (k-1)
06:34:54 <laserpants> otherwise it is interpreted as (elementAt xs k) - 1
06:36:13 <the_2nd> within do notation I'd like to enfore e.g. that length x == length y  and return early if that's not the case. Is there an elegant function  / way to do that?
06:38:00 <cocreature> :t guard
06:38:02 <lambdabot> Alternative f => Bool -> f ()
06:38:09 <cocreature> the_2nd: depending on the Monad that might work
06:39:42 <a3f> What do I need to run test files with .T extension that have entries like: test('T4452', normal, compile_and_run, ['-package Win32']) ?
06:40:34 <the_2nd> cocreature, awesome, thanks
06:41:45 <cocreature> the_2nd: just make sure that the Alternative instance does what you expect it to.
07:03:59 <rightfold> Hi, is there a function `Fold a b -> Fold a c -> Fold a (b, c)` (with Fold from lens)?
07:08:11 <spatial> logs  message = withFile "C:/Haskell/rl/game.log" AppendMode (\ fd -> hPutStr fd message )  Is there a way to make hPutStr function passed ? I need to print various things.
07:09:01 <spatial> In the same function I print lists, strings etc.
07:10:12 <c_wraith> rightfold: Do you want it to act like zip, in that it discards extras if there is more of one than the other?
07:10:41 <rightfold> c_wraith: Yes. I have at most one, if either is zero then the result should be zero
07:13:19 <c_wraith> rightfold: I don't see anything for it offhand.
07:13:34 <rightfold> I guessed (&&&) but it broke horribly :')
07:14:04 <c_wraith> Yeah, it's not quite right.
07:14:27 <rightfold> Maybe this is helpful: https://www.reddit.com/r/haskell/comments/3scjbn/zipzipwith_as_functions_on_traversables/
07:26:32 <spatial> log $ printf "Move is [%d] " move   log $ putStrLn (show player)   log $ print list    I use various print statements.
07:27:05 <spatial> Now when there is a single log function that writes to a file it fails.
07:29:22 <geekosaur> define "fails"
07:34:16 <spatial>  Couldn't match type `a1 -> IO ()' with `[Char]'
07:35:07 <geekosaur> feel like showing code?
07:35:09 <geekosaur> @pase
07:35:09 <lambdabot> Haskell pastebin: http://lpaste.net/
07:35:40 <geekosaur> although it looks like you're the sort who always pastes in one lump into the channel because somehow it's more convenient that it be unreadable
07:35:43 <spatial> logs  message = withFile "C:/Haskell/rl/game.log" AppendMode (\ fd -> hPutStr fd message )
07:37:12 <geekosaur> and omitting full code + full error message + pasting always into the channel = making it as hard as possible for others to help you
07:37:16 <Xnuk> Downloading stack's nightly snapshot is too slow; it still says "Updating package index Hackage (mirrored at https://s3.amazonaws.com/hackage.fpcomplete.com/) ..."
07:37:17 <geekosaur> that's always a win
07:37:23 <Xnuk> Is there anyone like me?
07:38:20 <spatial> http://lpaste.net/353944
07:38:20 <Xnuk> Downloading nightly-2017-03-24
07:39:13 <geekosaur> I don't use stack but would suspect it's a local problem
07:39:40 <Xnuk> hm
07:40:17 <geekosaur> spatial, so your code defines "logs" but uses "log". no full error message. you're still making it harder for people to try to help you
07:42:29 <c_wraith> :t \x y f s -> folded f (zip (toListOf x s) (toListOf y s))  -- rightfold this is the best I can come up with.
07:42:31 <lambdabot> (Applicative f, Contravariant f, Indexable Int p) => Getting (Endo [a]) s a -> Getting (Endo [b]) s b -> p (a, b) (f (a, b)) -> s -> f [(a, b)]
07:42:55 <spatial> http://lpaste.net/353945 Full code. I pass the 'logs' function to gameplan
07:43:39 <spatial> I mean nextvalue 
07:44:27 <c_wraith> rightfold: it's obviously not quite right.  Probably could be fixed with the right Rank-2 type signature
07:46:38 <bennofs> :t \a b -> runFold ((,) <$> Fold a <*> Fold b)
07:46:39 <lambdabot> error:
07:46:40 <lambdabot>     • Couldn't match expected type ‘(a1 -> f1 a1) -> s -> f1 s’
07:46:40 <lambdabot>                   with actual type ‘t1’
07:50:44 <bennofs> :t \a b -> runFold (liftA2 (,) a b)
07:50:46 <lambdabot> (Applicative f, Contravariant f) => ReifiedFold s a -> ReifiedFold s b -> ((a, b) -> f (a, b)) -> s -> f s
08:09:36 <hhhhhlllllloooo> Is it possible to define an infix operator in Haskell that takes more than 2 parameters?
08:09:55 <Jinxit> but why
08:10:00 <Jinxit> text is one-dimensional
08:10:18 <c_wraith> :t (.)
08:10:20 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:10:25 <c_wraith> infix operator, takes 3 parameters
08:10:46 <hhhhhlllllloooo> But I think it is defined as taking 2 arguments and returning a function
08:10:52 <c_wraith> they're the same thing
08:11:22 <hhhhhlllllloooo> But can you define an infix with pattern matching on 3 params?
08:11:30 <hhhhhlllllloooo> or 4
08:11:31 <c_wraith> @src (.)
08:11:31 <lambdabot> (f . g) x = f (g x)
08:11:35 <geekosaur> if it knows one is a function, yes
08:11:54 <hhhhhlllllloooo> x1 y1 ## x2 y2
08:11:58 <geekosaur> this confuses people all the time when an "extra" parameter pops up in some API
08:12:00 <hhhhhlllllloooo> something like that
08:12:16 <geekosaur> but otherwise, no, you have syntactic issues or you must give up partial application
08:12:17 <c_wraith> haskell's syntax doesn't work that way
08:12:31 <Jinxit> (x1 y1) ## (x2 y2)
08:12:42 <geekosaur> not the same
08:12:43 <hhhhhlllllloooo> that wouldnt work Jinxit 
08:12:45 <c_wraith> that's seen as a pattern match on two arguments
08:12:52 <Jinxit> i know it's not the same
08:12:57 <Jinxit> just proposing an alternative
08:13:07 <geekosaur> again, you lose something else useful
08:13:18 <hhhhhlllllloooo> Are there any languages that support this kind of thing?
08:13:22 <hhhhhlllllloooo> ML or something?
08:13:33 <geekosaur> since currently that means evaluate the function x1 with parameter y1,and likewise x1 and y2
08:13:33 <pavonia> How are these two different?
08:13:35 <c_wraith> possibly Agda - it has
08:13:47 <c_wraith> err, it has support for arbitrary mixfix syntax
08:14:07 <Jinxit> sorry, meant (x1, y1) ## (x2, y2)
08:14:09 <Jinxit> brainfart
08:14:39 <riaqn> so nobody told me that [2..0] is [], which wasted me half an hour.
08:14:40 <hhhhhlllllloooo> Ah, yeah agda mixfix looks promising :)
08:15:31 <hhhhhlllllloooo> > [2..0]
08:15:33 <michi7x7> Jinxit: this is just ## :: a -> b -> c
08:15:33 <lambdabot>  []
08:15:44 <geekosaur> riaqn, the haskell language report is surprisingly readable
08:15:50 <Jinxit> i am well aware
08:15:58 <michi7x7> > [3,2..0]
08:16:00 <lambdabot>  [3,2,1,0]
08:16:03 <laserpants> If I have  a data type `data X = A | B X X`, algebraically it can be seen as X = 1 + X × X? Then, the data type is the least solution to this equation. In what sense is it the "least" here?
08:16:27 <laserpants> or I mean, why is it the least solution
08:19:21 <geekosaur> laserpants, consider that Maybe () is isomorphic to Bool. (that is, ignoring bottoms, you can take Nothing as False and Just () as True and there are no other values occupying it)
08:19:28 <geekosaur> ...I thinkt hat's what that means...
08:19:35 * geekosaur not exactly type theory wonk
08:21:27 <laserpants> geekosaur: Ok... I have to meditate on that a while. (Sorry if the question was slightly off-topic btw.)
08:21:37 <geekosaur> it's fine for #haskell
08:21:48 <geekosaur> I'm just not the best person to answer it, but nobody else was
08:22:31 <geekosaur> anyway the point there, if I understand correctly, is there are more complex ways to implement a type that reduce to the same thing in the end
08:22:51 <geekosaur> but the algebraic representation will be more complex
08:23:00 <ezyang> least fp is clearer if we talk about sets 
08:23:04 <Welkin> geekosaur: like Free to implement a List?
08:23:10 <ezyang> Say you have a function f from one set to another 
08:23:19 <ezyang> a fixpoint is any set X such that f(X) = X 
08:23:42 <ezyang> what is a least fix point? It is a fixpoint such that for any Y, if f(Y) = Y , X <= Y 
08:24:04 <ezyang> but it's worth noting Haskell doesn't actually define least fixpoints 
08:24:26 <laserpants> ezyang: is there an order on types?
08:24:29 <Welkin> I don't get it
08:24:46 <Welkin> if f Y = Y, then X is less than or equal to Y?
08:25:09 <hpc> http://blog.ezyang.com/2010/12/getting-a-fix-on-fixpoints/
08:26:08 <hpc> Welkin: basically the least fixed point is the fixed point that's less than or equal to all other fixed points
08:27:29 <ezyang> you want to start with this post: http://blog.ezyang.com/2010/12/hussling-haskell-types-into-hasse-diagrams/ 
08:27:59 <laserpants> thanks, I was just going to ask that.. 
08:28:09 <hpc> ezyang: can you actually edit those to add links between each in the series?
08:28:13 <ezyang> yeah I'll do that 
08:28:20 <hpc> they're not even all consecutive in the archives ;)
08:40:25 <eatman> Hi 0/
08:40:53 <eatman> Does anyone here use the gitlab pages service to host Hakyll generated pages?
08:50:18 <vektorweg1> are there some Maybe to Either (and back) conversion functions in base or have i to define them?
08:53:05 <boxscape> vektorweg1: quick search on hoogle suggests that they don't exist
08:53:33 <Athas> How come concatMap hasn't been generalised to Monoid m => (a -> m b) -> [a] -> b?
08:53:38 <Athas> Huh, I guess that's actually just mapM.
08:53:51 <Athas> If 'm' is a Monad, at least.
08:55:03 <geekosaur> concatMap's generalization is spelled (=<<)     :p
08:57:02 <geekosaur> more to the point, concatMap pretty much exists to be the implementation of (>>=) for the list monad
08:58:18 <hpc> also to make it excruciatingly obvious how to implement (>>=) in terms of fmap and join
08:58:24 <geekosaur> ^
08:58:52 <geekosaur> thought about saying that and also pointing out the relationship between join and concat
08:58:55 <MarcelineVQ> :t foldMap
08:58:56 <vektorweg1> i guess thats why flatMap is their synonym for bind. 
08:58:57 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
08:58:58 <hpc> and for beginners to learn to code with monomorphic error messages
08:59:52 <Welkin> ew, "flatMap"
09:00:06 <Welkin> that's how you know when someone is a refugee form scala
09:00:51 <Athas> Yeah, I've always been confused at that name.
09:00:56 <Athas> What's flat about it?  concatMap is better.
09:01:07 <geekosaur> vektorweg1, I think it's considered that there are enough use cases that you don't gain anything (you have to specify what to put in the Left, or decide what to do when mapping a Left _ to a Nothing) 
09:01:07 <ezyang> ftp mumble mumble 
09:01:33 <geekosaur> flattening, concatenating, joining
09:01:56 <rightfold> c_wraith: Thanks for the help, I think I'll use a different approach than lenses for parsing JSON. I found one that includes error messages for missing fields automatically, which is nice.
09:02:16 * geekosaur pretty sure he saw "flat" being used in that sense in ancient computer languages
09:02:34 <muesli4> Hi, can someone explain me what GHC is trying to tell me with this? (http://codepad.org/Sh9XEKpy) I used these as qualified imports.
09:02:36 <kuribas> LISP?
09:02:47 <geekosaur> predating lisp I think?
09:03:09 <MarcelineVQ> muesli4: looks like it's saying you shouldn't have capitalized Level
09:03:27 <muesli4> MarcelineVQ: wow, thanks! Shame!
09:04:30 <muesli4> MarcelineVQ: I guess this is one of the downsides of camel case and human perception.
09:04:48 <kuribas> camel case is pretty bad
09:04:50 <MarcelineVQ> muesli4: yes it's petty common
09:05:15 <Welkin> it's not camel case, it's people using it wrong
09:05:35 <Welkin> "top" and "level" are two distinct words, so L should be capital
09:05:48 <kuribas> I always avoided it, but in haskell it's not possible.
09:06:07 <Welkin> also, don;t use long names
09:06:10 <Welkin> this isn't java
09:06:18 <boxscape> use single letter n
09:06:20 <boxscape> oops
09:06:23 <boxscape> I was gonna say
09:06:23 <boxscape> names
09:06:30 <geekosaur> "toplevel" is a single conceptual entity in a gui
09:06:47 <kuribas> Welkin: I suppose WindowTypeToplevel is a Gtk thing
09:06:48 <vektorweg1> "use single letter n" is perfect :D
09:06:59 <boxscape> it kind of is, yeah...
09:09:17 <boxscape> I really hate typing underscores, so I'm quite happy with any naming scheme that prevents me from having to use them
09:09:19 <geekosaur> (I was thinking that was some kind of auto conversion, but the web tells me the C version is GTK_WINDOW_TOPLEVEL)
09:09:44 <geekosaur> although that does make the point about "toplevel" being a conceptual entity in this context
10:05:38 <freth_> Is there some rule of thumb on when to use Data.Set?  Like, a lot of the time my lists *do* represent something like sets, i.e. i don't care about ordering or duplicates, just about membership, but using Data.Set all the time turned out to be quite cumbersome, e.g. doing list comprehension becomes difficult, checking if the list / set is empty takes longer because the set type isn't lazy, etc.
10:05:44 <cocreature> can I link to a package in haddock?
10:06:02 <ezyang> I generally use Data.Set if I actually need set ops 
10:06:15 <ezyang> usually this is obvious 
10:06:21 <freth_> i see
10:15:14 <mojjo> hi! is someonw up for a little code review? It's about a function that generates the intermediate computation steps of the imperative InsertSort algorithm. Just a few lines.. ;-) Well, here's the gist: https://gist.github.com/thought2/e9a58bb6392ab271484c832936c81a3d
10:16:46 <statusbot> Maintenance update: everything operational again! -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/58d7ead6b13e15472000002c
10:40:10 <myname_> Hello
10:43:18 <myname_> +i
10:43:47 <Nolrai> So ..I think it's impossible to give "Gen" an associative  (<|>), am I right?
10:44:04 <Nolrai> Hi myname_.
10:48:47 <myname_> Can anyone explain me pattern matching syntax? I understand the principles but i really get stucked at shit like this: someThing :: (Integral a) => a -> b ?
10:50:00 <Athas> Is there a parser for GHC .prof files?
10:50:10 <myname_> I thought I understood everything when i wrote code but it didn't work 
10:50:21 <cocreature> myname_: that has nothing to do with pattern matching. that’s a type signatu
10:51:24 <cocreature> myname_: what is means is that someThing is a function that takes something of type a as an argument and returns something of type b
10:51:28 <myname_> oh thx (it's name of the LYHGG chapter) sry
10:51:37 <cocreature> myname_: in addition to that a has to be Integral
10:51:44 <mojjo> myname_: you might confuse the arrow -> with the one that occurs in a case statement. In the latter you have pattern matching..
10:54:18 <myname_> What if function takes two arguments? should I write like that: smth :: (Integral a, Show a) => a -> a -> a   ?
10:55:45 <boxscape> myname_: if both arguments have the same type, yes
10:56:05 <myname_> what if they doesn't?
10:56:36 <boxscape> Well, something like "fun :: Int -> String -> Char" would be a function that takes two arguments of different types
10:56:36 <mojjo> myname_: Should the two args and the result be of the same type plus have the same typeclass constraints? then, yes.
10:57:05 <Myrl-saki> myname_: You could also do `smth :: (Integral a, Show a) => a -> b -> a` but that doesn't really make sense for the most part.
10:57:09 <geekosaur> do you understand the differnce between types and typeclasses?
10:57:41 <myname_> Yes. Types ate the sets of values while typeclases are the sets of types
11:00:13 <mauke> omnomnom
11:00:21 <sophiag> can different records really not have the same field names? seems so, but i find that rather odd
11:01:13 <mojjo> sophiag: without language extensions, unfortunately not. they are just reagular functions defined at the toplevel
11:02:38 <sophiag> mojjo: ah ok, so the fields are similar to defining new types that exist globally?
11:03:18 <boxscape> new functions, not new types
11:03:53 <dxtr> sophiag: Create field X in a record - now you have a function called X that you use to access field X
11:04:01 <michi7x7> sophiag: "field names" are just convinience functions like field (Data _ _ _ x _ _ ) = x
11:04:43 <sophiag> ah, right. they only become types with the DataKinds extension, yes?
11:05:28 <sophiag> also, what's the extension i can use if i want to have multiple ones with the same fields?
11:05:29 <dxtr> But I thought it was possible, without language extensions, to tell it to not create these convenience functions. Or do I not remember correctly?
11:05:35 <mojjo> sophiag: `data Person = Person {name :: String}`  equals  `data Person = Person String; name (Person n) = n` 
11:06:09 <sophiag> mojjo: yeah i get that now. the syntax was confusing me to think it was like using DataKinds
11:07:22 <boxscape> sophiag: OverloadedRecordFields. But it looks like OverloadedRecordFields is not yet part of ghc?
11:08:04 <sophiag> oh yeah, it looks like it's still a proposal
11:08:13 <sophiag> anyway, i can do without it
11:08:16 <diwank> hey guys, haskell newbie here. Needed some help with a side project that uses minimax
11:08:37 <diwank> Anyone care to take a quick look?
11:09:15 <sophiag> my second question about records was going to be whether there's a way to specify fields as optional. i suppose i could just create an adt to do that, but wondering if there's a simpler way
11:10:31 <Nolrai> @sophiag Use Maybe.
11:10:31 <lambdabot> Unknown command, try @list
11:10:33 <unclechu> can i check if my app is compiling on gnu/linux or freebsd using CPP extension using GHC?
11:10:37 <Nolrai> sophiag: Use Maybe.
11:10:49 <sophiag> Nolrai: ah, yeah of course. thanks
11:11:11 <mojjo> sophiag: fields cannot be optional, they are positional arguments (the order defined in the record syntax) to the data constructor.
11:11:19 <davean> unclechu: using cabal
11:11:58 <mrjake> Has anyone used the Diagrams library?  Their examples aren't type checking for me.  I'm getting illegal equational constraint and  non type variable argument errors in their mandelbrot set example: http://projects.haskell.org/diagrams/gallery/Mandelbrot.html
11:12:09 <geekosaur> unclechu, this is usually done with cabal if os(whatever)
11:12:24 <geekosaur> I don't know if os defies get passed through; they tend to cause problems
11:12:38 * geekosaur reminded of the pain of "#define sun 1" back in the day :p
11:12:55 <Nolrai> sophiag: You can additionally define convienence constructors say "mkDefault non_optional = MyCons Nothin non_optional Nothing.
11:14:12 <sophiag> Nolrai: yeah i figured i'd have two constructors, one with the field and one without, but didn't think far enough that i could just use maybe and pass Nothing for the latter
11:14:59 <Nolrai> Your first idea can work, but if your use record syntax it creates partial functions. :/
11:15:48 <sophiag> i'm not sure i understand the difference in what you're suggesting
11:15:55 <sophiag> i'll try to paste a gist in a moment
11:16:19 <unclechu> geekosaur: how actually i can do it using cabal?
11:16:32 <diwank> [REPOST] hey guys, haskell newbie here. Needed some help with a side project that uses minimax Anyone care to take a quick look? (Much appreciated; been banging my head for hours)
11:18:27 <michi7x7> diwank: just ask right away or post a link, nobody cares to ask you what your problem is
11:19:12 <diwank> michi7x7: Ah, thanks
11:19:52 <diwank> Wrote a tiny minimax implementation for tic-tac-toe but it seems to have a logical bug
11:19:52 <mojjo`> sophiag: You could also have a default instance of your type. ` defaultPerson = Person "Max" 20;` And then you'd use record update syntax to enhance only the fields you like. e.g: `me = defaultPersion{name="Me"}` This gives you a complete person of age 20, Many libraries use this approach...
11:19:54 <diwank> https://github.com/creatorrr/tic-tac-toe/blob/master/src/AI.hs
11:20:30 <diwank> Can't figure out what I got wrong..
11:21:06 <michi7x7> diwank: Debug.Trace is a great way to find these errors
11:21:25 <sophiag> mojjo`: this is how i'm structuring it now: http://lpaste.net/353948
11:21:48 <diwank> michi7x7: Thanks! Let me give that a shot
11:22:14 <sophiag> basically i'm going to have parsers of these types and cons the records into lists i can ultimately evaluate in a list monad
11:23:24 <sophiag> so the ones that are tagged will match constraints to particular values rather than constraints for every record
11:25:53 <sophiag> although i'm wondering if having constraints of type Bool will actually work considering what i really want are expressions that return type Bool...which to parse i may have to use HaskellDef or something like that (same for passing lists, although I could also probably due that in a hacky way using a regular parser)
11:28:32 <geekosaur> unclechu, something like http://hackage.haskell.org/package/network-2.6.3.1/network.cabal except you likely want os(freebsd)
11:30:45 <unclechu> geekosaur: interesting, thanks, it might work too, but i also found exact answer here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html#options-affecting-the-c-pre-processor
11:31:00 <unclechu> os_HOST_OS=1
11:31:07 * geekosaur very strongly recommends against relying directly on cpp
11:31:11 <geekosaur> since you are not writing C
11:31:37 <geekosaur> (that we use it at all is a wart, and freebsd is exactly where it will bite you because clang's cpp knows that it is intended for c/c++ not haskell)
11:34:30 <Boomerang> mojjo`: are you mojjo? If so here's your code from earlier with a couple of suggestions: https://gist.github.com/basile-henry/f7f68b744f5d924104cc86adaa4edf30 I am not sure trying to translate imperative code to haskell like this is the best way, you could refactor to remove most mentions of indices.
11:39:10 <sophiag> is anyone familiar with Text.ParserCombinators.Parsec.Language? i'm wondering if i can use it to create lexers for haskell lists and boolean expressions relatively painlessly. the only examples i've seen using it are from the old Parsec docs, but they're much lower level than that...like tables of infix operators and such :/
11:44:16 <geekosaur> sophiag, it concentrates on tose because operator parsers are the hard part of parsing. lists are fairly easy
11:45:05 <geekosaur> (once you throw associativity and precedence into the mix, operators are non-trivial)
11:45:40 <sophiag> geekosaur: but is there something in HaskellDef that just reads lists?
11:45:50 <ph88> hello, ghc reports that a type variable is ambiguous https://bpaste.net/show/188d02e77be6, i just don't understand what value it's talking about, could someone take a look?
11:45:50 <geekosaur> ...and while you can write them by hand, they perform poorly
11:45:57 <sophiag> or you're saying because it's so easy to do sepBy "," and cons them?
11:45:58 <geekosaur> sophiag, no
11:46:07 <geekosaur> right, it's easy to make your own parser for that
11:46:35 <geekosaur> so Language handles things like tracking lexical analysis for you (e.g. what's a valid identifier?) and operators (hard to get right, harder to get fast)
11:47:22 <sophiag> right...which it seems like i'll need for the only actually hard part: i want to essentially parse lambdas. or at least something similar
11:48:48 <sophiag> hmm...i wonder if i could use System.Eval.Haskell for that?
11:51:59 <cocreature> ph88: that’s the "a" in the type signature of changeLastValue2. neither "id" nor "\_ -> True" provide GHC with enough information to figure out what this should be
11:53:12 <ph88> cocreature, do you have any idea what it could be? i have hard time to "infer" this myself tbh
11:53:20 <alx741> hello everyone, I'm trying to use Hakyll and have a 'preview' of each post on index.html, but when i use $body$ in 'templates/post-list.html' it includes the post like it's rendered in the full page (including the navbar). How could I get onlye the body of the post itself?
11:53:57 <ph88> cocreature, by the way, that type signature you suggested worked very well !
11:54:04 <cocreature> ph88: there is no way to infer this. you just have to chose something by adding a type annotation. anything should work I think
11:54:25 <ph88> cocreature, i mean to say i don't know what to choose
11:54:57 <cocreature> ph88: I’m not so sure about this. I was just looking for something that compiles but I’m not sure the type signature of "changeLastValue2" makes sense. there is still no relation enforced between "a" and "b"
11:55:31 <cocreature> and I’m too lazy to look up all those lenses to figure out what you are actually trying to do :)
11:57:25 <ph88> cocreature, i made some helper functions and it seems to type check now .. still i'm a bit confused why this could not be infered, let me show you in a new paste
11:57:54 <cocreature> ph88: I think you first need to give me a quick summary of what you expect changeLastValue2 to do
11:57:58 <ph88> cocreature, https://bpaste.net/show/f51f15f6d767
11:59:01 <rotaerk> that sure is a lot of code for a hello world program
11:59:18 <geekosaur> heh
11:59:38 <glguy> ph88: nothing specifies the type a in your previous paste, but that a needs to have a Generic instance
11:59:46 <puregreen> Could someone explain why heterogeneous type equality is not needed in this example with GADTs, but needed with a typeclass? http://lpaste.net/353950
12:01:08 <ph88> cocreature, i think b is the "normal" value and a is the generic representation of the value. Not sure what you mean by "there is still no relation enforced between a and b"
12:01:31 <glguy> puregreen: the kinds aren't different in your first constructor
12:01:47 <cocreature> ph88: ah so EotTerminal is supposed to give you a Traversal for an _arbitrary_ "a"
12:01:59 <cocreature> that seems kind of weird
12:02:21 <ph88> cocreature, changeLastValue2 is suppose to go over all the elements of the generic representation backwards (so starting at the last one) then if the predicate is true you can change the value of that one element and return the entire structure with the last element changed. I can show an example of this with a  integers
12:03:14 <ph88> cocreature, it gives a traversal of all types that have derived Generic .. why does that seem kind of weird? I think it's pretty powerful to be able to traverse over the generic structure
12:03:21 <glguy> puregreen: It's like if you'd written: FooSame :: Foo a a
12:03:35 <cocreature> ph88: that’s not really what you’re getting here. at best you are going over all elements of type "a" but you’re missing all other fields. and that "a" might not even exist in "b" which is why I was saying that there is no relation enforced between a and b
12:04:36 <int-index> glguy, but "Foo :: (a :: k) -> (b :: k')" -> Type, so we have to assume k~k' as well.
12:05:03 <ph88> cocreature, to illustrate here is how changeLastValue2 works on a much simpler structure (tuples of ints) https://bpaste.net/show/4ff93ace47c7
12:05:17 <puregreen> glguy: if I don't include “a ~ b”, kinds *could* be different (e.g. I could add a constructor “FooNotSame :: Foo a b” without equality and then use “FooNotSame Int Maybe”), so I still don't understand why a ~ b works in the first example but not the second one
12:05:46 <puregreen> unless GHC has some special rules which make it treat “(a ~ b) => Foo a b” as “Foo a a”
12:05:51 <glguy> puregreen: because you included the a ~ b you implicitly added an additional constraint that hte kinds will be the same
12:06:24 <cocreature> ph88: right but here HasTokens only requires a "Traversal' a Int". "EotTerminal" requires that you find a traversal sufficiently general that it works for any "a" that is an instance of Generic
12:06:36 <glguy> puregreen: The k and k' in your data declaration don't mean that all of the data constructors will support all kinds
12:06:53 <int-index> glguy, are you saying that `(a :: k) ~~ (b :: k')` is exactly the same as `(k ~ k', a ~ b)`?
12:07:18 <cocreature> ph88: and I’m not quite sure you can actually make useful instances of that. however, this might just be due to my lack of familiarity with generics
12:07:36 <ezyang> puregreen:  “(a ~ b) => Foo a b” as “Foo a a” are not the same, as far as mathcing is concerned 
12:07:58 <glguy> ezyang: You mean in the context of type class instance resolution , right?
12:08:05 <ezyang> yeah 
12:08:07 <ph88> cocreature, what "other fields" are you talking about ?   I think when you have a type like   data Foo = Foo1 | Foo2   and you have a value  val = Foo1   then val is of type  b  and  a is not going to cover the entire space of possible generic representations of Foo, but only the generic representation of Foo1   ... at least so far the theory and so far as i understand it !
12:08:22 <ezyang> doesn't look like what you guys are talking about though lol 
12:08:51 <glguy> I'm saying that when GADT syntax is translated to explicit equality constraints you'll get a kind equality constraint from that definition
12:09:21 <cocreature> ph88: "data Foo = Foo Int Bool Int Bool". which value should me modified? you can either chose the last Int or the last Bool but not the last field regardless of the type because you need to provide type information upfront
12:09:53 <puregreen> glguy: so something like “instance (a ~ b, k ~ k') => GetFoo (a :: k) (b :: k') where { getFoo = FooSame }” should work?
12:09:54 <glguy> and that it's not just kind equalties that can be implicitly generated
12:10:17 <puregreen> hm
12:10:34 <puregreen> is there any place I could read about those implicit equality constraints that get added?
12:11:15 <cocreature> ph88: try making an instance of "EotTerminal" for "data Foo = Foo Int"
12:12:05 <Hi-Angel> What was called the extension to omit the first argument to record accessor-functions? So for "data Foo = Foo{bar :: Int}" I'd write in a function not "bar myFoo", but just "bar"?
12:12:26 <puregreen> Hi-Angel: RecordWildCards, maybe?
12:12:34 <puregreen> (and then you have to write Foo{..})
12:12:52 <Hi-Angel> puregreen: oh, thank you!
12:12:54 <ph88> cocreature, "that you find a traversal sufficiently general that it works for any "a"  ... yes but that a is provided by the generics-eot library which transforms the more complicated structure of GHC.Generics into a much simpler representation of nested tuples (see tutorial of generics-eot) .. but i think that the "dive into the nested structure" has been handled by the instances of EotTerminal and the generics-eot glues this together. So basically this 
12:12:54 <ph88> gives you the ability to go through all the elements (that is all the generic representations in the structure) .. and then the Lens part allows you to compose this "go-over" function (that is provided by generics-eot and my self written instances) with some other cool traversing functions like backwards (provided by lens)
12:13:01 <glguy> puregreen: Avoid GADTs if you want less magic and more understanding
12:13:13 <glguy> puregreen: For example: data HEq (a :: k') (b :: k'') = (a ~~ b) => Refl
12:13:25 <glguy> while you can't use  (a ~ b)
12:13:30 <ph88> cocreature, please understand that this stuff is already mind boggling to me. So maybe i sound like i understand it all, but i surely don't this is just what i'm barely grasping by studying this stuff for months now
12:14:14 <heath> who has statusbot setup in here?
12:14:23 <cocreature> ph88: I’d still like to see if you can write an instance of EotTerminal that actually modifies values :) your current instances are sort of boring in the sense that they don’t do anything
12:17:02 <ph88> cocreature, in case of your example   "data Foo = Foo Int Bool Int Bool"   i think this is handled by the instance i wrote on line 79 of this paste  https://bpaste.net/show/f51f15f6d767  this is where the fields of the constructor are represented as nested tuples .. so let's say R stands for the generic representation then you would get  (R Int, (R Bool, (R Int, R Bool))) .. then i traverse them in the order of left to right (unless i use special Lens 
12:17:02 <ph88> function backwards) .. which one should be modified depends now on the lens functions that take the predicate i provide
12:17:26 <ph88> cocreature, yes for sure my next goal is to actually make it change values !!! this is the whole point haha .. but i'm just at the point that it type checks AND i'm getting the same value back ... so now  le moment supreme :P
12:17:30 <int-index> glguy, why does this work? 
12:17:30 <int-index> data HEq (a :: k') (b :: k'') = (a ~~ b) => Refl
12:17:39 <int-index> (sorry, not this)
12:17:52 <int-index> this modified version
12:17:53 <int-index> data HEq (a :: k') (b :: k'') where { Refl :: (a ~ b) => HEq a b }
12:17:58 <int-index> it appears to use homogeneous equality
12:18:08 <cocreature> ph88: my point is that I’m not sure that it is actually possible to write instances that change values. I might be wrong here (and I’d love to know how you can do that!) but it’s also possible that you’re on the wrong track here
12:18:19 <glguy> int-index: Because GADTs add extra constraints automatically
12:18:30 <int-index> glguy, does this GADT add a heterogeneous equality constraint?
12:18:34 <ph88> cocreature, certainly !  i will try it with  this type   data Foo = Foo Int Bool   ok ?
12:18:51 <cocreature> ph88: sure, looking forward to see what you come up with!
12:19:00 <glguy> int-index: It translates that to: Refl :: forall k'' (b :: k''). HEq b b
12:19:32 <glguy> Refl :: forall k'' (b :: k''). HEq k'' k'' b b
12:24:14 <int-index> glguy, say I take Foo (a :: k1) (b :: k2) as input to a function. If I match on FooSame, shouldn't it bring a~~b into scope?
12:24:15 <glguy> There's a difference
12:24:16 <glguy> case (undefined :: HEq Maybe Bool) of Refl -> ()
12:24:20 <glguy> You can't do this^
12:24:23 <int-index> there must be heterogeneous equality stored inside
12:24:25 <glguy> because Refl doesn't have the right kinds
12:24:33 <glguy> You don't learn that the kinds of equal
12:24:38 <glguy> Refly just isn't valid
12:29:04 <glguy> (so there's an important distinction between how GADT syntax adds type and kind constraints)
12:30:33 <glguy> Oh, nevermind, you get the same inaccessible problem with    undefined :: HEq Int Bool
12:31:34 <int-index> glguy, yep, but depending on the definition of Refl (with GADT or without) you get different errors with HEq Maybe Bool
12:31:43 <int-index> kind error in one case, type error in another
12:32:52 <int-index> although I wouldn't expect GHC to accept/insert homogeneous equality there in the first place.
12:38:03 <ph88> cocreature, ok confusion has set in https://bpaste.net/show/248384e4d3a8
12:38:33 <cocreature> ph88: right, that’s what I expected :)
12:40:32 <ph88> cocreature, do you also think i'm traversing over the values and not the generic representation ?  If so .. do you have any idea how i can traverse over the generic representation ?
12:42:26 <geekosaur> does the generic representation even exist at runtime?
12:42:37 <Theophane> folks.
12:42:52 <glguy> geekosaur: It does if you're not careful
12:43:12 <Theophane> I came up with the |~> operator so I could pipe a variable as the 2nd argument of a function…
12:43:29 <Theophane> I think I caught the "custom operator" virus they warned me about :(
12:43:38 <cocreature> ph88: I think you might be better of using some Biplate like stuff (lens has it’s own copy of that) instead of Generics. but that might be related to me not really knowing generics :)
12:43:45 <Jinxit> are duplicate record names a thing yet?
12:43:49 <Jinxit> or is that still a problem?
12:44:31 <geekosaur> I thouthgt Biplate was where ph88 started a month or so ago
12:44:48 <cocreature> oh I’ve missed the start of this then
12:45:01 <geekosaur> Jinxit, still a problem unless you mean lens/whatever creating typeclasses for you
12:45:09 <Jinxit> alright
12:45:16 <ph88> cocreature, yeah i guess i'm forced to go the easier route now (the already proven stuff) .. i thought it would be viable to whip something up myself with some creativity .. but i'm close to giving up. Although i saw ndmitchell talking about wanting to reimplementing biplate in ghc.generics sometime but he never got around to it (which made be believe it was possible in the first place)
12:45:36 <geekosaur> part of the standard support is in 8.0.x, more coming in 8.2.x but OverloadedRecordFields is still future
12:45:37 <cocreature> Jinxit: GHC 8 has DuplicateRecordFields
12:46:07 <ph88> geekosaur, i was at biplate a few months ago (for another purpose in my code), then i dropped it to go with ghc generics (which worked for that part of the code). Now i need generics again to do some other stuff (change that last value) .. but for this use case it's seems much more difficult
12:46:42 <ph88> geekosaur, very likely for this specific use case it will be wise to consider biplate again .. in all honestly the project is not really progressing in the way i'm trying
12:47:04 <geekosaur> I'm not at all clear that the tooling to do what you want exists, tbh
12:47:14 <geekosaur> but I don't fully understand what you're up to
12:47:37 <ph88> me neither, it was a hard but interesting thing to discover .. seems not to work out .. 
12:47:56 <ph88> basically lens biplate but on top of GHC.Generics instead of Data
12:48:04 <ph88> i was still using Typeable though
12:48:13 <ph88> i need to go (train arrives), be back later
12:49:29 <ph88> thanks guys
12:49:30 <ph88> bye
12:53:50 <nshepperd> heh, * has a Typeable instance with TypeInType
13:00:48 <lpaste_> nshepperd pasted “kind equality” at http://lpaste.net/353953
13:01:19 <nshepperd> int-index, glguy: this seems to work?
13:02:59 <glguy> nshepperd: Yeah, foo seems to show that the GADT translation adds an implicit kind equality to the Refl constructor that becomes available upon pattern matching
13:03:21 <nshepperd> yeah
13:03:58 <nshepperd> If I cause a type error inside that context, the error message says the context is (k1 ~ k2, (a :: k1) ~~ (b :: k2), ...)
13:13:41 <cocreature> well now I wrote a generic traversal for ph88 using generics-sop
13:13:45 <cocreature> but I still need Typeable
13:13:49 <cocreature> but at least not Data
13:14:48 <glguy> cocreature: Like this one? http://hackage.haskell.org/package/lens-4.14/docs/Generics-Deriving-Lens.html#v:tinplate
13:14:59 <cocreature> glguy: yeah
13:15:16 <cocreature> glguy: I mostly wanted an excuse to finally play around with generics-sop
13:24:15 <CuriousErnestBro> how is haskell for optimization algorithms/dynamic programs?
13:25:27 <Owatch> Hey. 
13:25:36 <Owatch> Can anyone help me with installing Packages? 
13:26:04 <Owatch> I've been trying to get Data.Heap. I thought it was included with the Haskell Platform but it seems not. I also couldn't figure out a way to get it using Cabel. 
13:26:05 <geekosaur> maybe? ask your question
13:26:35 <geekosaur> hayoo tells me it' from the "heap" package
13:27:43 <Owatch> Ah
13:27:50 * geekosaur still thinks cabal should index exposed modules in a package, so it can do that translation for you
13:28:04 <Owatch> I see, I was trying: cable install Data.heap
13:28:08 <Owatch> Not just heap. 
13:28:15 <Owatch> Okay, it seems to be working now. 
13:28:18 <geekosaur> but it doesn't (nor does stack) so you end up having to ask something like hayoo to find the package a module comes from
13:28:57 <Owatch> Alright, it works now. 
13:29:02 <Owatch> I can import it in Prlude. 
13:29:08 <Owatch> Prelude*. Thank you! 
13:46:38 <orion> cocreature: It's OverloadedRecordFields.
13:48:52 <orion> Or wait, maybe not.
14:00:26 <Cale> CuriousErnestBro: No worse than anything else. For dynamic programming, you can use lazy arrays of various sorts quite effectively.
14:01:28 <Cale> CuriousErnestBro: Of course, if you're looking for implementations of algorithms, you might not find everything you'd find for Matlab or whatever.
14:04:06 <Owatch> Is there a way to mute the messages about user connections / disconnections ? 
14:06:12 <benzrf> Owatch: it depends on your client
14:07:16 <orion> Will lens ever land in base?
14:07:22 <benzrf> haha'
14:07:45 <Owatch> @benzrf using the web chat 
14:07:46 <lambdabot> Unknown command, try @list
14:07:57 <benzrf> Owatch: not sure, then
14:08:13 <Owatch> Oh well. 
14:14:58 <michi7x7> Owatch: I think you can, using the freenode-webchat, that is
14:15:33 <michi7x7> Owatch: yeah, options-menu and "Hide JOINS/PARTS/QUITS:"
14:28:15 <Owatch> Are there any priority queues that come with the Haskell platform I can use? 
14:28:29 <Owatch> Besides implementing my own, which would be a sort of 'insertion sort'. 
14:31:02 <hpc> does it have to be part of the platform? https://hackage.haskell.org/package/priority-queue
14:35:55 <Owatch> Well if it's short and I can implement it myself then I guess it'll work too. 
14:44:12 <sophiag> can anyone explain these errors I'm getting from Parsec? everything i'm trying to do is pretty simple so i'm a bit confused as to what's going wrong: http://lpaste.net/353955
14:46:22 <geekosaur> for the first one, sepBy wants the separator first but you are passing the list first
14:47:33 <geekosaur> sepBy parser thing         or       parser `sepBy` thing        (sepBy is not really infix-friendly, at least by its naming)
14:49:18 <sophiag> ah, ok. thanks
14:49:25 <geekosaur> the second one, an HList is not a Haskell list and can't be used with []
14:50:07 <sophiag> oh, the reason i used infix sepBy in that order was because that's how the docs have it
14:51:01 <sophiag> HList is an adt i defined at the top. i don't believe i ever use it with [] here...
14:51:42 <geekosaur> oh. that's confusing. HList is kinda a standard thing heterogeneous list type)
14:51:43 <sophiag> geekosaur: why do the docs use this example for sepBy? "commaSep p  = p `sepBy` (symbol ",")"
14:51:59 <kylepotts> thoughts on http://haskellbook.com/ and if its worth the $60?
14:52:38 <sophiag> yeah, i named it that beacuse what i wanted *is* a heterogenous list, but perhaps i should choose a more unique name that doesn't overlap with a common package
14:53:25 * geekosaur is getting confused trying to decipher this (not your fault, just took heavy duty sinus meds for it but they haven't kicked in yet)
14:54:43 <geekosaur> hm, your parseList seems wrong
14:55:35 <geekosaur> but I don't think that's a compile time issue, the parser will diverge at runtime because there's nothing to stop the recursion
14:55:48 <orion> Let'
14:55:52 <sophiag> how so? i fixed all the calls to sepBy to be opposite order from the docs and that cleared up parsing for the second data type
14:56:14 <sophiag> oh i see
14:56:28 <geekosaur> it parses '[' and reinvokes itself, requiring another '[' after which it reinvokes...
14:56:34 <geekosaur> never parses an *item*
14:56:57 <geekosaur> I think you have the same issue with parseRequireTagged
14:57:02 <sophiag> hmm?
14:57:20 <sophiag> it doesn't parse '[' tho. it calls between
14:58:36 <orion> Let's say I need an embedded DSL. I choose to represent the AST as a Free Monad and I'm off to the races. But later on I discover that I need to apply "transformations" to programs, which are defined like, "If the embedded program contains OperationA followed by OperationB, reverse the two operations". How do I continue?
15:00:54 <orion> It seems kind of inelegant to represent the entire program as a List (e.g. [OperationA, OperationB, OperationC, ...]).
15:01:11 <the_wit> > take 5 [1..] ==> [1,2,3,4,5]
15:01:13 <lambdabot>  error:
15:01:13 <lambdabot>      • Couldn't match expected type ‘Bool’ with actual type ‘[Integer]’
15:01:13 <lambdabot>      • In the first argument of ‘(==>)’, namely ‘take 5 [1 .. ]’
15:01:14 <sophiag> geekosaur: ghci is asking me if i want to add an OverloadedStrings pragma. do you think that has to do with it? i couldn't make sense of what you were saying before. it seemed to confuse the bodies of several functions
15:01:56 <geekosaur> re between, the first thing it does is call your opener parser which is (char '[
15:02:00 <the_wit> @sophiag, what are you trying to do and what ghc extensions are you using?
15:02:00 <lambdabot> Unknown command, try @list
15:02:01 <geekosaur> (char '[')
15:02:46 <sophiag> right, in a call to between
15:02:57 <sophiag> so it reads everything between that and (char ']')
15:03:04 <geekosaur> yes
15:03:13 <geekosaur> but it always looks for that open '['
15:03:20 <geekosaur> so it parses [[[[[[[[[...
15:03:34 <geekosaur> because there is no code path that does not immediately call (char '[')
15:03:53 <sophiag> really? i don't have a recursive call there
15:04:10 <geekosaur> parseList = do
15:04:10 <geekosaur>               list  <- between parseList (char '[') (char ']')
15:04:17 <geekosaur> looks recursive to me
15:04:28 <geekosaur> you might update your paste, including the full new error
15:04:32 <sophiag> oh i see what you're saying
15:04:37 <sophiag> that wsa the full error...
15:04:41 <the_wit> \clear
15:04:51 <geekosaur> the OverloadedStrings thing? that was not the full error
15:05:31 <sophiag> that was after i fixed the sepBy calls (which i'm still confused as to why the docs lists an opposite argument order)
15:05:38 <geekosaur> (it may suggest OverloadedStrings if you have mistakenly used a literal String where some other type is wanted)
15:06:08 <geekosaur> parsec has a number of bugs including some documentation bugs that havebn't been fixed
15:06:23 <geekosaur> megaparsec is currently recommended because it has fixes for that stuff
15:06:38 <geekosaur> also, Text.ParserCombinators.Parsec is the old parsec 2 interface
15:06:53 <geekosaur> but I usppose whatever docs you're using are for parsec 2
15:07:37 <sophiag> well i was looking at Text.Parsec, but still wondering why examples are incorrect
15:15:45 <zcourts_> How do I add a constraint to isConLike in http://pastebin.com/C4Mn9jGa to prevent http://pastebin.com/Q6hQubnL i.e. "No instance for (GhcMonad Maybe) arising from a use of ‘infoOpt’"?
15:17:46 <sophiag> geekosaur: i can't even figure out the type signature for Parsec 3. as in what to use for stream and state types? every Parsec tutorial uses Parsec 2 and the haddocks docs are not so helpful. i'm still wondering why they list the argument order to sepBy incorrectly, for example. unless they flip when it becomes infix?
15:19:06 <mauke> sophiag: what exactly is incorrect where?
15:21:29 <sophiag> mauke: what i mentioned above. sepBy
15:21:37 <mauke> ...
15:21:41 <sophiag> commaSep p  = p `sepBy` (symbol ",")
15:22:38 <mauke> where is that from?
15:22:40 <geekosaur> I may have misread hat you were doing, I'm still dizzy (and trying to back away from kbd...)
15:23:29 <sophiag> ok, i'll just state my question in whole again
15:24:28 <sophiag> i'm still why the Parsec 3 docs the argument order to sepBy incorrectly. unless they flip when it becomes infix?
15:24:39 <mauke> sophiag: what exactly is incorrect where?
15:26:21 <sophiag> mauke: <geekosaur> for the first one, sepBy wants the separator first but you are
15:26:21 <sophiag> 	    passing the list first  [17:46]
15:27:05 <mauke> so geekosaur = the parsec 3 docs?
15:27:36 <geekosaur> yes, "I'm still dizzy (and trying to back away from kbd...)" absolutely means I am all in on any discussion
15:28:18 <sophiag> ok, how about this... give me a minute to change my code back to what it was an hour ago and then i'll start fresh
15:28:45 <mauke> it sounds like you don't want to help me
15:28:59 <mauke> this is a bit annoying
15:29:40 <sophiag> mauke: no, it's fine. it's just i apparently got a bunch of false advice so if you'd like to look at my code i need to change it back to before i changed everything incorrectly
15:30:10 <sophiag> i'm relatively new to haskell so i assume when someone says something authoratatively on here they're correct. that's all
15:30:54 <MarcelineVQ> no one can be right every time :>
15:31:08 <mauke> I don't want to look at your code
15:31:15 <sophiag> ok, fine
15:31:18 <mauke> I want to look at the documentation you said was wrong
15:31:21 <MarcelineVQ> you can confirm quickly yourself how a parser works if its behavior is confusing you, load up your project in ghci (don't worry if it fails to load) and   import Text.Parsec  you now have access to the normal parsers of Parsec
15:31:31 <mauke> but you're not telling me where you found it
15:31:39 <sophiag> mauke: the documentation isn't wrong. someone made a mistake in telling me that
15:31:53 <sophiag> also i said several times where it was
15:32:17 <MarcelineVQ> or whichever way you import the parser lib in your own project
15:32:43 <sophiag> MarcelineVQ: i'm really confused by what you're saying
15:33:21 <sophiag> someone told me an hour ago that my project wasn't compiling because i needed to do something differently from in the docs, i kept changing things, then they just said "oops i'm sick and was wrong"
15:33:24 <sophiag> that's all that's going on here
15:33:38 <MarcelineVQ> I'm saying if something's confusing you can play with it directly, e.g.   import Text.ParserCombinators.Parsec   in ghci  and use parseTest
15:33:52 <sophiag> i'm also wondering if i have a connection problem because i seem to type a lot of things that no one sees
15:34:09 <sophiag> MarcelineVQ: the question was about compiler errors
15:34:37 <mauke> if by "where" you mean "the Parsec 3 docs", that's a bit vague. I thought you might have a direct link handy
15:35:43 <sophiag> i didn't think that was vague. there's only one place it's officially documented
15:36:05 <hexagoxel> sophiag: how about "list <- between (char '[') (char ']') (yourElemParser `sepBy` char ',')"
15:37:11 <mauke> there's at least two
15:38:26 <sophiag> hexagoxel: thanks! i'm just getting an error on the return type now
15:39:19 <hexagoxel> sophiag: sure, because the return types of »sepBy« and your function differ.
15:40:25 <sophiag> i'm also curious why it throws an error when i split it into two lines
15:40:36 <sophiag> even if i remove many, which apparently was unnecessary
15:41:41 <hexagoxel> because f (g x) is not the same as f >>= g.
15:42:44 <hexagoxel> sepBy takes, as first argument, a _parser_ for elements. you can't give it the _output of a parser_.
15:43:02 <sophiag> ah, ok. got it
15:43:26 <hexagoxel> apart from that the order of elements for between is messed up in the lpaste, but that is out of date anyways probably.
15:45:30 <sophiag> yeah, i realize that. i would use Parsec 3, but i couldn't figure out the type signatures considering literally every tutorial uses Parsec 2
15:45:42 <sophiag> what should be the stream and state types?
15:49:25 <mauke> in the simplest case? stream = String, state = ()
15:50:29 <sophiag> i was asking generally and figured hexagoxel could help since they were looking at my paste
15:51:07 <hexagoxel> your paste is not relevant if the question was about the general case oO
15:51:27 <sophiag> ok, well i think i get what stream should be
15:51:37 <hexagoxel> stream can be String/Text/ByteString
15:51:43 <sophiag> right, i get that part
15:52:19 <mauke> I'm pretty sure parsec2 already had a user state
15:52:47 <sophiag> i think the sugared type signatures in parsec 2 just ommitted the stream type, but could be wrong
15:53:06 <sophiag> if you just say Parser String, for example
15:53:16 <hexagoxel> sophiag: to make this clear: that kind of reply to mauke, who was clearly trying to answer your question, is not nice in my opinion.
15:53:34 <tobiasBora> Hello,
15:53:44 <tobiasBora> I'd like to know, I'm using the library https://hackage.haskell.org/package/parallel-io-0.3.3/docs/Control-Concurrent-ParallelIO-Local.html
15:53:46 <sophiag> hexagoxel: my intention was to spare them time since they stated earlier "i don't want to look at your paste"
15:53:49 <sophiag> that's all
15:53:59 <sophiag> and i didn't state it rudely
15:54:55 <tobiasBora> Do you agree that the function parallelE_ gives the result in the same order as the list input? 
15:55:12 <sophiag> my questions at this point are likely to be invovled so if someone says they don't have the time or interest then why waste their time? that would seem rude to me
15:55:16 <hexagoxel> a nice response would look like "ok, thanks; what about the general case?"
15:55:38 <tobiasBora> (I'm using this property to zip the errors with the input list in order to try them later, so I'd like to be sure that it is indeed corresponding)
15:55:51 <hexagoxel> sophiag: the first response you got on your question was unfortunate, without any parting having bad intentions.
15:56:04 <hexagoxel> it probably confused you more than it helped, and i am sorry for that.
15:56:24 <sophiag> you mean geekosaur? that's fine. he's sick and made a mistake
15:56:37 <mauke> my earlier comments were in the context of *me* asking *you* a question
15:57:03 <sophiag> mauke: have we cleared up the doc confusion tho?
15:57:13 <sophiag> why i even asked that and why it's not an issue?
15:57:22 <lyxia> tobiasBora: That sounds quite likely.
15:57:50 <tobiasBora> lyxia: Ok thank you, I wasn't sure to understand the doc correctly.
15:58:31 * hexagoxel needs to learn to switch to pm for certain kind of feedback.
15:58:32 <mauke> sophiag: probably not because I didn't realize you were asking anything
15:59:08 <sophiag> mauke: right when you came into the discussion geekosaur clarified he made a mistake and so that issue is mute
15:59:25 <sophiag> *moot
15:59:28 <sophiag> anyway
15:59:49 <sophiag> anyway, what i was asking after that was about the type signatures
15:59:50 <hexagoxel> sophiag: argh the parsec2 docs are confusing. GenParser does not even have docs? meh.
16:00:31 <sophiag> no, i mean as in examples. the hackage page refers you to real world haskell, write yourself a scheme, and parsec 2 docs from the wayback machine
16:01:30 <sophiag> so like i can't find any examples anywhere using parsec 3 just to figure out type signatures
16:06:02 <sophiag> well, if any one can help me with parsec 3 type signatures as compared to parsec 2 that would be appreciated. i can't find examples anywhere :/
16:08:40 <davean> sophiag: Are you trying to update ancient code?
16:09:03 <sophiag> every tutorial on parsec uses parsec 2
16:09:38 <davean> Why don't you just go off the haddocks?
16:09:39 <sophiag> i'm trying to switch from the only way possible to learn it to the current version
16:10:03 <davean> https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html
16:10:15 <sophiag> haddock is not very helpful if you've never used something before
16:10:24 <davean> Oh, its how I learn just about everything
16:10:39 <sophiag> you learned haskell by reading type signatures with no examples?
16:10:43 <davean> Do you ahve any particular things that aren't clear? I might be able to help with that?
16:10:47 <davean> Yes?
16:10:52 <sophiag> wow ok
16:11:07 <sophiag> i actually had to learn what types were and such before i could read haddock
16:11:13 <sophiag> that's impressive
16:11:30 <davean> I think its pretty normal
16:11:40 <davean> With some experience I expect you'll find it easy and intuative
16:11:53 <davean> But, here, if you ahve a specific question, maybe I can answer it?
16:12:00 <davean> I haven't used Parsec in years, but I've got hte docs open
16:12:07 <sophiag> sure. but i'm saying as a beginner
16:12:10 <hexagoxel> in rust i am annoyed that the docs default to showing docs+examples, instead of just giving an overview of types first :p
16:12:20 <davean> hexagoxel: I know, itsn't it annoying?
16:12:48 <sophiag> davean: i'm just wondering what a type signature should look like in parsec 3
16:12:51 <hexagoxel> (in haskell i'd just search by type, so how the docs are displayed is no issue)
16:12:54 <davean> sophiag: for?
16:13:05 <davean> sophiag: you'll have to be more specific about what you want it to DO
16:13:08 <davean> a type depends on function
16:13:12 <sophiag> well if you're parsing a string in parsec 2 you can just use "Parser String" and that's it
16:13:39 <davean> Right, so we've got "type Parsec s u = ParsecT s u Identity" then
16:13:43 <davean> we want a String out
16:13:57 <davean> sophiag: so, what are we parsing it out of?
16:14:02 <sophiag> in 3 i need the stream type (which i understand), the state, and then two more types
16:14:12 <davean> We know it'll be "Parsec s String"
16:14:17 <davean> but we need to fill in s
16:14:25 <sophiag> the stream is a string
16:14:34 <davean> (since you're getting out a string, thats u)
16:14:40 <davean> Ok, so you're parsing a string otu of a string?
16:14:58 <sophiag> but that's not sufficient. the compiler says in need something like "Parsec String String -> * -> *
16:15:07 <sophiag> in one example i am
16:15:29 <davean> are you using ParsecT or Parsec?
16:15:35 <sophiag> Parsec
16:15:39 <hexagoxel> (u is not the output.. or do i misunderstand?)
16:15:48 <mauke> no, u is the state
16:15:57 <davean> hexagoxel: sorry, I did say that wrong
16:15:59 <sophiag> u is the state
16:16:06 <mauke> if your parser doesn't use it, you can leave it a variable
16:16:13 <sophiag> the stream in this case is String
16:16:30 <sophiag> ah ok. i may actually use it, but not yet
16:16:45 <davean> Parsec String u String
16:16:46 <davean> let me check that
16:17:41 <sophiag> oh damn, that looks right
16:17:42 <davean> runParser (undefined :: Parsec String () String)  ()  "test"  "Test"
16:17:44 <davean> types
16:17:50 <mauke> in parsec 2 we had: type Parser a = GenParser Char () a
16:17:56 <mauke> i.e. the user state was hardcoded to ()
16:18:15 <sophiag> right, that confused me
16:18:20 <davean> Yah, I dropped in () because we're ignoring it here
16:18:33 <sophiag> although i think the newer way is more straightforward if you're actually using it as a state monad
16:18:38 <davean> sophiag: here, let me take you through how I did that?
16:18:43 <sophiag> which i may. i'm just trying to get it to work for now
16:18:50 <davean> first I went to "runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a"
16:18:56 <davean> I know what we want to get out must be 'a'
16:19:11 <davean> so I just filled that in for "runParser :: Stream s Identity t => Parsec s u String -> u -> SourceName -> s -> Either ParseError String"
16:19:48 <sophiag> oh i see. you're saying when i need to figure out type signatures for the first time that's how to approach it
16:20:17 <davean> Yah, just start filling stuff in and see where you get
16:20:28 <sophiag> right, and the errors should get more descriptive
16:20:29 <davean> now, I can tell s must be what we're parsing out of because of the class constraint
16:20:49 <davean> so, we can have a little question about its form, but to resolve that we can jump to the class definition
16:21:01 <davean> instead I just threw in String because I was pretty sure that would be a valid stream for it
16:21:15 <davean> then I had to look at the actual comments for u
16:21:25 <davean> decided we didn't care about it, and threw in ()
16:21:35 <davean> Does that help?
16:21:37 <mauke> looking at run* functions is generally a good idea because it tells you what the inputs and outputs are
16:21:45 <davean> mauke: right
16:22:03 <mauke> e.g. you can see 's' and 'u' going on and 'a' coming out
16:22:07 <sophiag> yeah, i didn't think about that
16:22:14 <mauke> *goin in
16:22:17 <mauke> blargh
16:22:22 <davean> sophiag: does that make it clearer how to teach yourself given the haddocks? You should be able to not need a tutorial with a little practice
16:22:46 <davean> generally I was just doing "unification" by hand
16:23:07 <sophiag> for the type signatures at least. i'd still need a tutorial to understand much of how things work
16:23:32 <davean> sophiag: well, a lot of things can only work one way if their types are general enough
16:23:35 <davean> see Theorems for Free
16:24:09 <sophiag> i mean basic syntax usually
16:24:13 <davean> oh
16:24:22 <davean> yah, syntax is a different issue, thats general haskell knowlege
16:24:30 <davean> I won't suggest you don't want a tutorial for learning the *language*
16:24:39 <sophiag> that seemed to be the case. lol
16:24:47 <sophiag> but thanks, this was helpful
16:24:47 <davean> Just that a well-typed library quickly removes the interest in having a tutorial
16:24:55 <davean> one finds a tutorial is just in the way if they types are done well
16:25:07 <davean> sophiag: glad I could be of service!
16:26:04 <sophiag> well, i'm still where i was 2.5 hrs ago except i've switched to parsec 3. lol
16:26:20 <davean> sophiag: if you ahve any more questions, ask. Specific questions get the best answers though.
16:26:32 <davean> "How do I use Parsec 3" will likely get silence
16:26:50 <davean> "How do I do $X with Parsec 3" is far more likely to get a useful response
16:27:06 <sophiag> no, it was originally a whole paste then i got some wrong answers then some people got mad when i repeated them, etc.
16:27:15 <sophiag> that's been my last two hours
16:27:19 <davean> lol
16:27:21 <davean> sorry
16:27:44 <sophiag> eh, it goes with irc
16:27:59 <sophiag> a lot is learning who has trouble communicating slash a bad temper
16:29:15 <sophiag> here's my code updated to use Parsec 3: http://lpaste.net/353955
16:29:40 <sophiag> on line 19 i'm not sure how to deal with the return type
16:30:02 <sophiag> i want it to be able to return lists of either strings, chars, or nums. hence that adt
16:30:21 <davean> well
16:30:27 <davean> you need to tell it WHAT to return
16:30:34 <davean> so maybe take a parser for what you want to parse?
16:30:49 <davean> parseList :: Parser String u a -> Parser String u [a]
16:31:07 <sophiag> oh i see. rather than specifying the type
16:31:38 <sophiag> that signature doesn't work
16:31:42 <davean> TECHNICALLY what I did specifies the type, but the first argument, but doesn't specify VIA the type
16:32:00 <davean> well, it makes your function take an argument
16:32:11 <davean> which is a parser for the type your list is made of
16:32:26 <sophiag> no, that's not what it does
16:32:31 <kylepotts> Has anyone used this book to learn Haskell what do you think about it? http://haskellbook.com/
16:32:46 <sophiag> it is a parser that returns a list of type HList (defined on line 3)
16:32:52 <orion> kylepotts: 10/10 would read again
16:32:56 <sophiag> it parses streams of strings
16:33:05 <davean> sophiag: You really want the HList there?
16:33:53 <sophiag> yes, because i made this just to use in parsers that return a record that requires it
16:34:05 <davean> I dobut you actually do, but ok
16:34:21 <davean> ok, so, first off, your HList definition is ... well, its screwy
16:34:48 <sophiag> lol ok
16:34:53 <davean> data HList = List String | Char | Num deriving (Show)
16:34:58 <davean> So you have 3 constructors
16:34:59 <slack1256> how to use cabal's data-files: and cabal build? (data files are only placed on cabal copy, not cabal build)
16:35:03 <davean> List, which holds a String
16:35:14 <davean> Char, which holds nothing, and Num which holds notihng
16:35:46 <davean> Do you want anything like that at all?
16:35:58 <sophiag> i think i want something like this: data HList = HList [String] | HList [Char] | HList [Num] deriving (Show)
16:36:04 <sophiag> right?
16:36:23 <davean> Ok, you want it to contain a list, which can be all of Char, or all of Num, or all of String?
16:36:27 <davean> (mind you Num isn't valid)
16:36:33 <davean> and yes, that makes more sense
16:36:43 <sophiag> yes. oh Num can only be a constraint?
16:36:51 <davean> yes, its a class, it isn't a type
16:37:03 <sophiag> is there a general numerical type?
16:37:23 <davean> No, what would happen if you added a Float to a Quaternion?
16:37:24 <sophiag> realistically i could use Integer for now i suppose
16:37:35 <davean> What operation is that?
16:37:49 <davean> it certainly isn't Float or Quaternion addition!
16:38:20 <sophiag> aren't floats part of the Num instance?
16:38:27 <sophiag> so they use the same addition?
16:38:37 <davean> No, each type uses DIFFERENT addition
16:38:47 <davean> a Quaternion also could (probably?) be Num
16:38:53 <davean> (I'm pretty sure but I'd have to double check)
16:38:54 <Koterpillar> there's no "Num instance", there are different instances
16:39:07 <Koterpillar> sophiag: Int and Bool are both instances of Eq, but you can't compare them
16:40:22 <sophiag> oh, i'm thinking of an example that used the Num instance and had "default (Integer, Rational, Double)"
16:40:51 <Koterpillar> sophiag: typically we say "Int instance for Num", not "Num instance"
16:40:56 <Koterpillar> so I'm not sure what you meant
16:41:18 <sophiag> "instance (Num a, Eq a) => Num [a] where"
16:41:44 <Koterpillar> that's an instance of Num for [a]
16:42:15 <davean> Based on the instance of Num for a
16:42:22 <davean> Theres only 2 Num instances used there
16:42:25 <davean> the one being writen
16:42:31 <sophiag> right. and you said typically we don't use the Num instance
16:42:32 <davean> and the one for the *single* type the list contains
16:42:51 <davean> All we're doing there is saying there *is* a num instance
16:43:44 <sophiag> ok, so in the interest of debugging my actual code...do you think it even makes sense to have that adt for different lists?
16:43:55 <davean> sophiag: no, not really, thats what I was getting at
16:44:05 <sophiag> yeah, seems like it
16:44:09 <davean> I'd do something like:
16:44:27 <davean> parseList :: Parser String u a -> Parser String u [a]
16:44:29 <davean> and then
16:45:11 <sophiag> except, i already mentioned that doesn't compile
16:45:14 <davean> parseList parseNum <|> parseList parseString <|> parseList parseChar :: HList
16:45:18 <davean> if I WAS going to use HList
16:45:35 <davean> No, that function CAN exist, it just isn't what you've writen
16:45:39 <davean> I'm proposing a change to the function
16:45:54 <davean> I'm proposing defining your parser based on another parser
16:46:06 <davean> now, why don't you know what you'll be parsing out ahead of time?
16:46:08 <davean> lets go there
16:46:14 <davean> why does HList exist at all?
16:46:27 <sophiag> because i know I WILL be parsing all three of those types
16:46:39 <sophiag> at least Ints, maybe other numerical types
16:46:43 <davean> Sure
16:46:45 <davean> when
16:46:49 <dmwit> davean: Because people keep thinking they want it. I mean, they keep being wrong, mostly, but... the heart is inscrutable.
16:47:07 <davean> dmwit: this isn't THAT HList
16:47:12 <dmwit> oh =P
16:47:26 <davean> I know why people think they want the ACTUAL HList
16:48:29 <OGLoli> Hello, I'm new to Haskell and new to programming in general. I was wondering if anyone could point me to any resources so that I can learn for myself on how to solve this problem. http://lpaste.net/353961
16:48:52 <sophiag> davean: so keeping in mind what i'm actually doing rather than changing this to do something else?
16:49:08 <davean> sophiag: But since it doesn't work I can't tell what you're doing
16:49:16 <davean> If I could tell, it would compile :-p
16:49:24 <davean> Ok
16:49:28 <dmwit> OGLoli: That's an admirable question!
16:49:31 <davean> so lets work with minimal change
16:49:32 <sophiag> ok, i have this record: data Amb = Amb { tag :: Maybe String, value :: [a] } deriving (Show)
16:49:42 <sophiag> i want the value field to be lists of several types
16:49:45 <dmwit> OGLoli: You might like Hoogle. It is a Haskell search engine where you give it a type and it proposes a function.
16:49:48 <dmwit> ?where hoogle
16:49:48 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
16:50:07 <davean> sophiag: so, Amb is a tagged value, and 'a' depends on the contents of the String?
16:50:09 <OGLoli> Thank you, dmwit. I will give it a try.
16:50:12 <davean> sophiag: what does Nothing lead to?
16:50:33 <sophiag> Nothing means there's nothing in that field
16:50:44 <dmwit> OGLoli: In this case, you want to give it the function (-) and get back a function that does (-) on two lists. So:
16:50:49 <sophiag> a does not depend on the contents of the String
16:50:52 <sophiag> it's wholly distinct
16:50:54 <davean> Ok, so first off, note theres nothing specify 'a'
16:50:55 <dmwit> ?hoogle (Double -> Double -> Double) -> [Double] -> [Double] -> [Double]
16:50:56 <lambdabot> Data.KMeans kmeansGen :: (a -> [Double]) -> Int -> [a] -> [[a]]
16:50:56 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
16:50:56 <lambdabot> Data.List unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
16:50:57 <sophiag> that's why it's a separate field
16:51:00 <davean> so you can't ever actually put anything there
16:51:06 <dmwit> ?hoogle+
16:51:07 <lambdabot> Data.List intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
16:51:07 <lambdabot> GHC.OldList deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
16:51:07 <lambdabot> GHC.OldList unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
16:51:11 <sophiag> well you saw what it said before and suggested i change it
16:51:23 <davean> so, are you sure that the list will contain all the same type?
16:51:24 <dmwit> OGLoli: Those results aren't too great. But the website one seems to do better. =P
16:51:29 <sophiag> yes
16:51:32 <davean> ok
16:51:58 <OGLoli> I'll use the website. Thank you, dmwit.
16:52:01 <davean> then data HList = SList [String] | CList [Char] | IList [Integer]
16:52:02 <sophiag> and then parseList is a helper function that just creates a list from a string that contains a list in standard haskell form
16:52:07 <davean> then parseList :: Parser String u HList
16:52:21 <davean> but then your problem is two fold
16:52:29 <davean> first off "(parseList `sepBy` char ',')" is recursive and won't ever parse anything
16:52:33 <dmwit> OGLoli: If you spend five or ten minutes without making progress, I encourage you to come back here. We're happy to help, and it will only take us a few seconds to put you on the right track.
16:52:33 <davean> second, you need choice
16:52:36 <davean> so
16:52:42 <davean> parseList :: Parser String u HList
16:52:58 <davean> parseList = do
16:53:00 <sophiag> davean: again, not something i had orginally. i was told to change it to that by someone on here
16:53:09 <davean>   
16:53:13 <davean> er, lets start over
16:53:20 <davean> parseList :: Parser String u HList
16:53:26 <sophiag> yeah
16:54:06 <sophiag> i feel like i need to remember everyone who forcefully yells at me about something and then turns out to be wrong. lol
16:54:14 <sophiag> i could save hours of time :p
16:54:15 <davean> parseList = (IList <$> parseSub parseI) <|> (SList <$> parseSub parseS) <|> (CList <$> parseSub parseC)
16:54:17 <davean> where
16:54:41 <davean>   parseSub p = (between (char '[') (char ']') (p `sepBy` char ',')
16:54:43 <davean> there
16:54:45 <davean> see how that works?
16:54:56 <sophiag> yup. thanks :)
16:55:05 <davean> we're parsing 'p's that are seperate by ','s
16:55:15 <davean> The order of the options matters
16:55:21 <sophiag> i just figured once i had HList i could use it to generically parse all of those types
16:55:23 <davean> Numbers probably parse as Strings
16:55:29 <davean> and chars probably parse as Strings
16:55:48 <sophiag> oh, that's good. i wouldn't have thought of that
16:56:01 <davean> We still have a problem
16:56:10 <davean> single digit numbers might parse as chars
16:56:23 <davean> or chars that are only numbers might parse as nums
16:56:26 <sophiag> yeah there seem to be lots of possibilites for error there
16:56:29 <davean> sadly your format is ambiguous
16:56:47 <davean> your format doesn't have enough specificity to actually be parsed "correctly"
16:56:59 <davean> which is why I don't think you actually want HList
16:57:26 <davean> but I think my order makes the best guess possible for most needs
16:58:15 <sophiag> i probably need something more complicated than this
16:58:59 <sophiag> i didn't want to have to use all the structure in Write Yourself a Scheme, especially since it uses Parsec2 and stores everything in IORefs. a lot of choices i wouldn't make
16:59:01 <davean> Yah, which is why I was giving you pushback all the way up top
16:59:19 <sophiag> well, it's different saying "make your program do a different thing"
16:59:46 <davean> No, I was saying "Doing that isn't really well defined"
17:00:23 <davean> And showing you similar, more well defined things
17:00:52 <sophiag> yeah i get it
17:01:21 <sophiag> i would really like to just get something working with the simplest input, frankly
17:01:33 <sophiag> then build up from there
17:02:50 <sophiag> davean: i'll either use that function with choice like you suggested or cut it down to one type for starters
17:04:03 <davean> mmm
17:04:35 <davean> I mean, this is why chars have single quotes around them in most languages while strings have double, and numbers none
17:04:42 <davean> it allows disambiguation
17:07:33 <sophiag> i'm confused how you suggested i write this function with all these other functions in it? parseI, parseS, etc.?
17:07:49 <davean> oh
17:07:54 <davean> sorry I failed to define those
17:08:30 <davean> parseC = char
17:08:33 <davean> er
17:08:35 <davean> no
17:08:38 <davean> parseC = anyChar
17:08:54 <sophiag> why don't i just put that inline?
17:09:06 <davean> Oh, because I wasn't looking up the functions
17:09:10 <davean> I was jsut suggesting what goes in there
17:09:12 <sophiag> oh ok
17:09:20 <davean> "some char parser"
17:09:29 <davean> because how your chars, nums, and string are formated are specific to you
17:09:36 <davean> I don't know how you represent an Integer
17:09:44 <davean> I can assume, I just wasn't
17:10:33 <sophiag> digit
17:10:46 <davean> probably many1 digit actually?
17:10:55 <davean> but yah, I just wasn't assuming
17:11:19 <davean> fill those in as makes sense for your specific case
17:11:42 <sophiag> using parseList :: String -> HList still doesn't compile tho
17:12:02 <davean> thats not a type I ever gave you
17:12:17 <davean> 19:52:58 davean parseList :: Parser String u HList
17:12:33 <davean> parseC :: Parser String u Char
17:12:41 <davean> parsecS :: Parser String u String
17:12:48 <davean> parsecI :: Parser String u Integer
17:12:56 <sophiag> ok, i tried String -> HList because the one you gave didn't compile either
17:13:46 <davean> what was the error?
17:14:04 <sophiag> " parse error (possibly incorrect indentation or mismatched brackets)"
17:14:37 <davean> paste the program?
17:14:43 <davean> sounds like a transcription error
17:15:21 <sophiag> http://lpaste.net/353955
17:15:39 <davean> (CList <$> parseSub (many1 string))?
17:15:47 <sophiag> yeah you suggested i look it up
17:16:02 <davean> and yah, it would have to be anyChar for example
17:16:25 <sophiag> that's not in the docs
17:16:26 <davean> char parses ONE specific char
17:16:31 <davean> sure it is
17:16:33 <davean> https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Char.html
17:16:36 <davean> anyChar :: Stream s m Char => ParsecT s u m Char
17:16:48 <davean> string parses the SPECIFIED string
17:16:58 <davean> so the string you want is many1 anyChar
17:17:07 <davean> but note theres nothing that will ever terminate that!
17:17:22 <sophiag> the ending bracket should
17:17:59 <davean> so maybe you want "endBy1 anyChar "char ',' <|> char ']')"
17:18:01 <davean> as your string
17:18:15 <davean> but then your strings can't have , or ] in them
17:18:32 <davean> this is why C strings use \ escaping
17:18:36 <davean> and ""s
17:19:11 <sophiag> i'm just still trying to get it compile
17:19:17 <sophiag> the type signature is still not correct
17:19:24 <davean> also, "many1 digit" will return a string of only digits
17:19:42 <davean> you can convert that to a num like "read <$> many1 digit"
17:19:57 <davean> those changes should do it
17:20:03 <sleffy> Has anyone here tried to use the bound library for a term type which may contain two distinct variable types, and which allows substitution on either one independently?
17:20:15 <sophiag> still type signature is wrong
17:20:18 <sophiag> same error
17:20:35 <davean> paste the error?
17:20:37 <davean> the full one
17:20:46 <sophiag> "Amb.hs:24:1: error: …
17:20:46 <sophiag>     parse error (possibly incorrect indentation or mismatched brackets)
17:20:46 <sophiag> Compilation failed."
17:20:46 <davean> At least what line?
17:20:52 <davean> its a syntax error
17:20:58 <sophiag> the type signature for parseList
17:21:06 <sophiag> "parseList :: Parser String u HList "
17:21:06 <davean> No, thats NOT a type error
17:21:23 <sophiag> that's the line the error is on
17:21:26 <sophiag> you asked
17:21:30 <davean> yes
17:21:38 <davean> "20:19:53 sophiag still type signature is wrong"
17:21:44 <davean> thats not saying the type signature is wrong
17:21:52 <davean> parseSub
17:21:59 <davean> its got one more ( then )
17:22:08 <davean> parseSub p = (between (char '[') (char ']') (p `sepBy` char ',')
17:22:14 <davean> you could change it to:
17:22:18 <davean> parseSub p = between (char '[') (char ']') (p `sepBy` char ',')
17:22:23 <davean> or add a ) to the end
17:22:29 <sophiag> oh you know what
17:22:35 <sophiag> Parsec
17:22:38 <davean> ?
17:22:38 <sophiag> not Parser
17:22:45 <sophiag> that was v2
17:23:01 <davean> still, the error you ahve there is pre-type checking
17:23:06 <davean> Haskell can't actually read the file
17:23:15 <davean> thats the earliest sort of error you can get
17:23:32 <davean> back in the 60s we did a lot of work on error handling parsers
17:23:35 <davean> then we never used it
17:26:23 <Welkin> davean: you personally did the research?
17:26:34 <davean> Welkin: no?
17:26:54 <Welkin> who is "we"?
17:27:01 <davean> the computer science community
17:31:15 <davean> sophiag: working?
17:39:25 * geekosaur remembers watfiv again...
17:43:05 <davean> I'm not actually sure how interesting error recovering parsers are in the modern age
17:43:29 <davean> maybe for interactive editing?
18:20:16 <Welkin> ezyang: what do you use for the hand-drawn graphs on your blog? Do you input them using a tablet/touchscreen, or scan them in from paper?
18:20:37 <Welkin> I've tried scanning from paper before and it's hard to get it to look clean
18:22:25 <ezyang> Welkin: it's a tablet laptop 
18:22:27 <ezyang> X61 :) 
18:28:15 <ezyang> I am braining. Can someone tell me what is wrong with this code: http://lpaste.net/353964 
18:30:33 <lyxia> is there supposed to be something wrong
18:30:56 <ezyang> when I feed it '9' and "aa9a9\154" I get [2] 
18:31:31 <ezyang> I guess I'll debug trace it to death 
18:32:55 <ezyang> maybe this is a bug in Foundation 
18:33:34 <glguy> ezyang: I'd guess breakElem isn't working like you want it to 
18:33:51 <glguy> or that your string literal somehow isn't working for whatever Str is
18:36:25 <ezyang> ok yep this is a foundation bug 
18:38:45 <ezyang> if you breakElem on a string from a breakElem (or perhaps it's uncons) it totally chokes 
18:39:58 <ezyang> https://github.com/haskell-foundation/foundation/issues/218 
18:55:25 <greymalkin> Whats the `[....| .... <- ...]` syntax about? I can't find a reference for it
18:55:35 <jle`> list comprehension
18:56:29 <jle`> @google haskell list comprehension
18:56:31 <lambdabot> https://wiki.haskell.org/List_comprehension
18:57:16 <glguy> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11
18:58:22 <greymalkin> Hmm. that still isn't shedding any light on how to use it in `readsPrec` for me -- thank you jle` 
18:58:39 <jle`> greymalkin: did you have a specific question?
19:01:15 <greymalkin> Not really, I'm just trying to make a `Read` instance which is slightly different from the default -- yesod's persistent doesn't seem to export the necessities to manually `derivePersistField` which I need for an enumerated type on which I want to do database comparisons.
19:01:47 <jle`> it is unlikely that list comprehensions would help you with that in a meaningful way; they're mostly just syntactic sugar
19:02:30 <greymalkin> They're used in the primary examples of implementing readPrec, though (a Tree type); which is why I was banging my head against it.
19:03:27 <jle`> hm.  well if you're trying to mimic other instances, then you can maybe ask about some unclear things in those instances.  but you can always just write them out in normal haskell, too
19:03:38 <jle`> without list comprehensions
19:03:49 <greymalkin> specifically https://www.haskell.org/tutorial/stdclasses.html#sect8.3
19:03:50 <jle`> instead of writing [ f x | x <- xs ], you can just write 'map f xs'
19:05:16 <jle`> when you bind multiple variables, it acts as a nested loop
19:06:05 <jle`> so [ (x, y) | x <- xs, y <- ys ]
19:06:13 <jle`> would return (x,y) for all x in xs, and all y in ys
19:06:31 <jle`> > [ (x,y) | x <- [1,2], y <- ['a','b'] ]
19:06:33 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
19:06:47 <jle`> it returns every possible combination of bindings
19:07:12 <boxscape_> [ x | x <- [1..10], odd x ]
19:07:15 <boxscape_> > [ x | x <- [1..10], odd x ]
19:07:17 <lambdabot>  [1,3,5,7,9]
19:07:39 <boxscape_> you can add boolean predicates
19:07:53 <jle`> and one feature that they're using in that example is pattern matching
19:08:23 <jle`> > [ x | ('c', x) <- [('c', 1), ('c', 2), ('d', 3), ('c', 9)] ]
19:08:25 <lambdabot>  [1,2,9]
19:08:51 <jle`> this only binds x's for tuples that match the ('c', x) pattern
19:08:59 <jle`> (if you're familiar with pattern matching)
19:09:41 <sshine_> > do { ('c', x) <- [('c', 1), ('c', 2), ('d', 3), ('c', 9)]; return x }
19:09:43 <lambdabot>  [1,2,9]
19:09:46 <sshine_> wow.
19:10:01 <manek> Hello guys! :) Is it possible to disable automatic datatype promotion in GHC? I just want to get error when I forgot to use ' in front of promoted constructor
19:10:59 <jle`> i'm guessing you are looking for an answer that doesn't involve {-# NoDataKinds #-}
19:11:03 <erisco> Prelude.foldr1 is throwing but it isn't my code... why does getting a stack trace look insanely complicated?
19:11:17 <jle`> manek: can you show an example
19:11:23 <jle`> of a problematic situation
19:11:34 <jle`> erisco: maybe try turning off optimizations?
19:11:46 <greymalkin> jle`: I found my major misunderstanding.  The default example uses a constructor which is not textually represented in the string
19:12:03 <erisco> jle`,  you never get a trace in ghci when error executes
19:13:18 <erisco> jle`, nor when you compile
19:13:28 <erisco> you just get the error message
19:13:32 <manek> jle`: of course. `type family Foo (a :: k) :: *; data A = B; type instance Foo B = Int` I want it to return error
19:13:43 <erisco> Prelude.foldr1: empty list
19:13:53 <jle`> heh, yeah, that's not a stack trace
19:14:08 <erisco> to get a stack trace it seems you have to rebuild all your cabal packages with the -p flag
19:14:19 <erisco> which is insane
19:14:24 <manek> jle`: however, I want to be able to tell `Foo 'B = Int` 
19:15:02 <MarcelineVQ> manek: you can put   -Wunticked-promoted-constructors  -Werror   but it'll error on any warning not just that one
19:15:16 <manek> MarcelineVQ: Ugh :(
19:15:35 <manek> MarcelineVQ: I've heard that GHC will have some day selectiwe -Werror flags
19:15:57 <manek> then it will be perfect for me, for now I cannot do it ? :(
19:16:08 <MarcelineVQ> I'm not sure, I really only use -Wall :>
19:16:33 <manek> I'm sure that Werror converts all warnings into errors.
19:16:38 <manek> currently
19:17:32 <jle`> manek: not sure i follow, are you trying to allow 'type instance Foo B = Int' ?
19:17:50 <manek> I just spend 30 minuts looking for a bug because GHC ticked automatically a consturctor
19:18:11 <manek> jle`: no, I want to allow `type instance Foo 'B = Int` but not `type instance Foo B = Int`
19:23:02 <jle`> they're the same thing, right?
19:23:15 <jle`> you just want to be required to use ' explicitly?
19:48:06 <manek> jle`: sorry I got disconnected and didnt notice it. Yeah they are currently the same, however it is very error prone sometimes
19:48:18 <manek> jle`: and yeah, I want to enforce using ' explicitly
20:02:04 <sophiag> are there haskell libraries that support string literals? as in allowing an IO string to be evaluated as an expression at runtime?
20:03:50 <geekosaur> that sounds confused, at least twice :)
20:03:53 <Koterpillar> sophiag: hmm. GHC itself?
20:04:06 <geekosaur> hint, which isa wrapper for ghc-api, if you actually mean Haskell expressions
20:04:31 <sophiag> wat?
20:04:49 <geekosaur> @hackage hint
20:04:49 <lambdabot> http://hackage.haskell.org/package/hint
20:04:50 <Koterpillar> well, you want to execute Haskell
20:04:59 <sophiag> well yeah of course it goes through ghc
20:05:01 <Koterpillar> so you need a Haskell compiler/interpreter library
20:05:16 <geekosaur> there's also mueval if you want some safety in what can be done (lambdabot uses mueval, for example)
20:05:49 <geekosaur> however, note that this does not allow introspection into your own program, it creates a separate interpreter instance
20:05:49 <sophiag> they're usually called "string literals" or "template literals" in other languages and i would imagine there's support for them in haskell, but they're just rarely used due to the obvious downsides
20:06:19 <geekosaur> there is no eval like there is in python/perl/ruby/javascript that can self-introspect
20:06:29 <sophiag> e.g. security, lack of full typechecking, etc.
20:06:38 <geekosaur> because providing that for compilation to native code is difficult and slows everything down
20:06:42 <Koterpillar> ah, do you mean "Hello, ${username}"?
20:06:58 <geekosaur> (and, in Haskell, would let you trivially violate referential transparency)
20:07:09 <sophiag> not quite? if i understand that correctly
20:07:16 <Koterpillar> what do you want then?
20:07:26 <sophiag> i found System.Eval.Haskell, but that doesn't take a string specifically
20:07:29 <Koterpillar> maybe paste an example of what will you do with this library?
20:07:30 <glguy> sophiag: A string literal is the syntax of including strings directly into the source language, so   "example" is a string literal
20:07:45 <glguy> That's not Haskell specific
20:07:51 <Koterpillar> assuming it exists as doit :: String -> IO ()
20:08:16 <glguy> 10    is an integer literal
20:08:19 <sophiag> glguy: well when they were added to javascript, for example, i think they were officially called "template literals"
20:08:48 <Koterpillar> sophiag: can you statically compile them in?
20:08:50 <sophiag> i've used them there to import glsl rather than embedding it in a script tag
20:09:11 <sophiag> Koterpillar: yes, but not fully since it would be at runtime
20:09:40 <sophiag> i think actually System.Eval.Haskell looks like it does what i'm referring to
20:09:41 <Koterpillar> i.e. someone else will give you "Hello ${name}" and you've got to turn it into "Hello Sophiag"?
20:09:49 <sophiag> no
20:10:01 <Koterpillar> that's what template literals do in Javascript, though
20:10:22 <sophiag> like you read a string that says, "map toUpper "sophiag" and you get "SOPHIAG"
20:10:26 <geekosaur> again, System.Eval.Haskell won't access data in *your* program
20:10:36 <sophiag> that's only one thing you can use them for in javascript
20:10:46 <Koterpillar> sophiag: OK, that's an interpreter, but it has nothing to do with template literals
20:10:49 * geekosaur just looked up tempate literals; this could be done with a quasiquoter but don't know if anyone has done so
20:10:50 <Koterpillar> http://exploringjs.com/es6/ch_template-literals.html
20:11:05 <geekosaur> in fact I'm tempted to say they mean quasiquotes
20:11:17 <sophiag> ok, lemme reboot this question :)
20:11:23 <sophiag> i'm looking at System.Eval.Haskell rn. have any of you used that?
20:11:23 <geekosaur> but that doesn;t mean someone has written  quasiquoter that does exactly what you want
20:11:37 <Koterpillar> geekosaur: template literals are totally quasiquotes, but I think they don't want them
20:12:15 <glguy> sophiag: Maybe you're asking for a 'string interpolation' library in Haskell then? "In computer programming, string interpolation (or variable interpolation, variable substitution, or variable expansion) is the process of evaluating a string literal containing one or more placeholders, yielding a result in which the placeholders are replaced with their corresponding values."
20:12:37 <geekosaur> sophiag, I could repeat what I've already said twice but I suspect a third time won't help. what do you believe System.Eval.Haskell will help with?
20:12:47 <geekosaur> also that functionality was superseded by hint and mueval
20:12:52 <sophiag> sorry
20:12:53 <Koterpillar> geekosaur:  (14:10:00) sophiag: like you read a string that says, "map toUpper "sophiag" and you get "SOPHIAG"
20:13:33 <sophiag> geekosaur: i'm considering it in place of parsing a full grammar now that i'm realizing the complexity of what i want and the limited applications
20:13:56 <geekosaur> yes, the question is whether the constraint I've mentioned matters to you
20:14:02 <sophiag> so i understand the downsides of evaling strings at runtime, but that might make sense in this case
20:14:09 <geekosaur> you *cannot* use it to access or modify your own program
20:14:20 <sophiag> that's goo
20:14:24 <sophiag> *good
20:14:32 <sophiag> otherwise it would be a horrible security flaw
20:14:45 <sophiag> i mean, many people would say it already is
20:14:54 <geekosaur> that's why mueval :)
20:15:04 <geekosaur> > putStrLn "hi"
20:15:06 <lambdabot>  <IO ()>
20:15:24 <sophiag> oh they do make a big deal about safety
20:15:39 <sophiag> oh, it's lambdabot! lol
20:16:20 <geekosaur> lb uses mueval to allow safe evals
20:16:25 <sophiag> geekosaur: i mean, you saw my code earlier...i just realized i don't really want to write 300 lines of parsers for 50 lines of actual logic
20:16:50 <geekosaur> you can do IO with hint or the plugins wrapper for hint; mueval blocks IO and restricts various other things
20:17:04 <sophiag> the application is really just so i can build up training it expression by expression and store them in libraries and such
20:17:28 <sophiag> i think mueval is probably a good thing. but i should look at both
20:17:59 <geekosaur> also if the idea here is to just use a haskell parser, you might want haskell-src-exts
20:18:37 <geekosaur> rather than linking ghc into your application
20:18:53 <sophiag> hmm
20:19:10 <sophiag> well, i'm talking about a very limited set of expressions
20:20:22 <sophiag> but i realized just parsing lists of different types was a bit more heavyweight than i thought and hadn't even gotten on to essentially lambdas
20:20:25 <Myrl-saki> Liquid Haskell. {-@ predicate Bounded N = 0 < N + maxInt && N < maxInt @-}
20:20:25 <geekosaur> yes,, that's why pulling all of ghc into your application just for that is a bit weird
20:20:33 <Myrl-saki> Why  0 < N + maxInt
20:20:34 <geekosaur> haskell-src-exts you should be able to use one of its subparsers
20:20:48 <Myrl-saki> Over, say. minInt < 0
20:20:55 <Myrl-saki> Assuming minInt exists, or something.
20:21:07 <sophiag> geekosaur: you're saying you think that makes more sense than mueval?
20:21:13 <geekosaur> yes
20:21:16 <Myrl-saki> Okay. There's minBound.
20:21:18 <sophiag> mueval seems more designed for this sort of stuff though
20:21:30 <geekosaur> no
20:21:36 <sophiag> oh wait, yeah now that i'm looking at it
20:21:38 <geekosaur> I wouldn;t say so, you are used to eval being cheap
20:21:54 <geekosaur> but using hint or mueval means pulling *all of ghc* into your program
20:21:57 <sophiag> no, i'm used to this being a kind of stupid thing to do tbh :)
20:21:59 <Myrl-saki> Or even easier, why `0 < N + maxInt` over `-maxInt < N`?
20:22:30 <geekosaur> haskell-src-exts gives you a parser, and just the parser, not code generators etc. --- and you should be able to pick which parts of the parser to use
20:22:37 <sophiag> but i see what you mean now because with haskell-src-exts i can just use specific bits of the lexer and such
20:22:57 <sophiag> right, like i don't need a full evaluator. that would be ridiculous overhead for this
20:23:03 <sophiag> and even more unsafe
20:23:50 <Conjecture> How extensive is the runtime garbage collector that ghc uses?
20:24:33 <geekosaur> ?
20:25:47 <sophiag> Conjecture: http://simonmar.github.io/bib/parallel-gc-08_abstract.html
20:26:26 <peddie> Conjecture: it collects all the garbage generated by your program, so quite extensive
20:27:19 <Conjecture> I should've said
20:27:22 <Conjecture> In the compiled binary
20:27:25 <glguy> Conjecture: "extensive" seems like a strange property to ask about of a GC
20:27:37 <geekosaur> yes, I'm rater confused about what you are asking
20:29:11 <Conjecture> geekosaur, When I compiler a binary, there is a garbage collector
20:29:18 <Conjecture> I compile*
20:29:24 <Conjecture> At least according to what I've read
20:29:41 <geekosaur> yes, and?
20:29:43 <Conjecture> The marketing says that it's very fast
20:29:51 <Conjecture> Fast is subjective
20:30:20 <Conjecture> I asked how extensive it was because I'm genuinely curious to know how it affects runtime performance
20:30:50 <glguy> What are possible levels of "extensive" that you might expect to get in response?
20:31:23 <Conjecture> Python to the C level
20:31:36 <glguy> Are you thinking of the word "expensive"?
20:31:49 <Conjecture> oops, I didn't mean to write extensive
20:31:52 <glguy> efficient?
20:32:02 <Conjecture> expensive
20:32:17 <Conjecture> I was a letter off
20:32:52 <geekosaur> a very confusing letter off, because if it's not extensive then it's leaking memory for no reason :)
20:33:47 <Conjecture> I put C in my Python to C thing because one could consider the tracking of Stack as garbage collecting
20:35:55 <turnage> Conjecture: I'm not sure that's a helpful analogy
20:36:14 <Conjecture> Ok, how does it affect performance
20:37:12 <turnage> See the introduction to: https://www.microsoft.com/en-us/research/wp-content/uploads/2017/03/haskell-linear-submitted.pdf
20:37:23 <turnage> it covers the effects of the cost of the gc briefly
20:37:55 <turnage> really it's not so useful to evaluate cost without also considering what you have to "spend"
20:38:39 <Conjecture> turnage, I'm probably conceptualizing this whole thing wrong anyways
20:39:15 <turnage> Conjecture: why are you curious about the cost of the gc?
20:40:58 <Conjecture> turnage, To get perspective into how Haskell will perform compared to others
20:42:16 <geekosaur> I think if you are worried about performance, the gc may be the least of your issues
20:42:32 <geekosaur> lazy evaluation means you have to optimize differently
20:43:31 <geekosaur> like, pretty much the first thing everyone asks is whether tail calls are optimized, and the answer is either "trivially yes" or "not relevant". evaluation is *graph reduction*, not call/jump-here-do-this
20:44:37 <dolio> Well, things would be much worse if tail calls weren't optimized.
20:45:36 <sophiag> it's not just tail calls tho. technically nothing in haskell is in "proper" tail position because it's all wrapped in thunks
20:45:59 <dolio> No, that is not true.
20:46:41 <sophiag> if you have a lazy function, then even if you're recursive call is at the end it's still not technically in what many would consider tail position
20:46:50 <sophiag> *your, ugh late
20:48:04 <sophiag> anyway, this is only something i think about because of using clojure which can't do that (at least without a cps transform) because it runs on a fucking stack machine
20:49:35 <dolio> Well, doing a CPS transform just makes things worse if you don't have proper tail calls. I guess you could CPS and trampoline yourself, though.
20:50:29 <sophiag> you can use CPS to optimize tail calls. that's essentially what's going on in most functional compilers
20:54:18 <Conjecture> Thanks, I think I understand now
21:06:23 <Sornaensis> how dramatically would haskell change if general recursion was removed
21:06:52 <sophiag> general?
21:07:03 <Sornaensis> oh I guess it would break
21:07:08 <sophiag> haha
21:07:20 <Sornaensis> yea like y f = f y f
21:07:25 <Sornaensis> y refers to itself
21:07:34 <Sornaensis> f (y f) sry
21:07:52 <geekosaur> you already can't do that except via a newtype; the typechecker rejects infinite types
21:08:15 <Sornaensis> >
21:08:17 <Sornaensis> ?
21:08:37 <jle`> `y f = f y f` is already not allowed
21:09:03 <sophiag> oh yeah, this is an interesting point: http://stackoverflow.com/questions/4273413/y-combinator-in-haskell
21:09:05 <Sornaensis> > let y f = f (y f) in y (\f n -> if n == 0 then 1 else n * (f (n-1))) 5
21:09:07 <lambdabot>  120
21:09:11 <Sornaensis> ...
21:09:56 <geekosaur> if you mean ordinary value recursion, that is certainly permitted and removing it would give you a rather less useful language
21:09:57 <Sornaensis> you can't write the fixed point combinator like you would in untyped lambda calculus, because haskell is typed
21:09:58 <sophiag> well you already have fix so that's not really special
21:10:13 <Sornaensis> but you would have to if general recursion was removed
21:10:19 <Sornaensis> but you can get around it with newtype
21:10:21 <Sornaensis> so hm
21:10:59 <geekosaur> well, I'm wndering which general recursion you mean now
21:11:14 <geekosaur> there is value recursion, where you need to provide a base case or it will recurse forever
21:11:27 <geekosaur> there is type recursion (data List a = Nil | Cons a (List a))
21:11:38 <Sornaensis> a function being able to refer to itself
21:11:57 <geekosaur> and there is Mu (one way to encode a fixpoint combinator via a newtype)
21:12:36 <geekosaur> (or Fix, or various other ways of slipping the Y combinator into the language by having something that "interrupts" the recursion)
21:13:16 <geekosaur> ok, ordinary value recursion. you lose lists, trees, etc. because you can't use recursive data types without general recursion
21:13:31 <geekosaur> you probably lose most functional programming because it's heavily based on inductive recursion
21:14:04 <sophiag> i suppose actually in haskell you could implement more higher order functions without recursion than in many functional languages
21:16:06 <jle`> hi all
21:16:11 <jle`> why is Product/:*: in base twice
21:16:38 <jle`> oh wait, wrong Product, nvm
21:17:07 <jle`> oh wait, id o mean it
21:17:09 <jle`> http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Functor-Product.html#t:Product
21:17:52 <jle`> type Product = (:*:)    ...?
21:18:05 <geekosaur> I eel like someone asked that the other day and the answer is nobody's gone through the trouble of merging them yet?
21:18:23 <geekosaur> s/through/to/
21:18:24 <glguy> They serve two different purposes
21:18:38 <glguy> even if they have the same definition
21:18:50 <glguy> it's like how even though we have Bool, people make other two constructor data types
21:19:08 <jle`> i feel like their purposes are the same
21:19:42 <glguy> One is specifically tied to a compiler generated generics representation of data types
21:20:25 <jle`> i feel like that could just be one specific usage of (:*:)
21:20:36 <jle`> there isn't any reason why it has to be tied to generics rep
21:20:49 <jle`> besides i enjoy typing (f :*: g) better than Product f g
23:02:43 <Disavowed> Hey all. Just starting out and looking for a repl with autocompletion whilst I get acquainted. Does such a thing exist? gchi doesn't appear to do this out-of-the-box. 
23:04:04 <Freundlich> It doesn't? What exactly are you looking for?
23:04:28 <Freundlich> You can tab-complete names in ghci at least.
23:09:03 <Disavowed> Freundlich: Sorry if I'm being a bit dense - I'm used to tab completion on methods of objects a la ipython but perhaps Haskell doesn't work that way at all. Either way, assigning a list to a variable and then tabbing on that list after a full stop isn't offering me the methods I would expect. Does this sound correct to you? 
23:10:34 <Freundlich> Haskell isn't object-oriented, so there are no "methods".
23:10:36 <kadoban> Disavowed: Haskell is quite different from python and most other languages. Haskell lists don't have methods of that sort
23:11:56 <Disavowed> kadoban: That would explain completely where I am going wrong
23:11:59 <Disavowed> Thank you
23:12:41 <Disavowed> Tab completion now working as expected. Thank you both
23:12:47 <kadoban> Cool, anytime
23:21:27 <runeks> Is there a bug somewhere if running with -N1 produces different behaviour from running with -N4? When running with -N4 my program stops gracefully (closes peer connections) (although the process itself never exits), and with -N1 the process exits abruptly, without gracefully closing the peer connections (in a `finally` clause). What gives?
23:24:31 <cocreature> runeks: well multithreading can result in all kinds of bugs. it’s hard to say without seeing some code. one thing to consider is that if your main threads dies, finalizers in other threads are not run
23:24:42 <cocreature> unless you explicitely wait for them
23:26:26 <runeks> cocreature: I'm waiting for the other threads with a waitAnyCancel: https://github.com/runeksvendsen/haskoin/blob/master/haskoin-wallet/Network/Haskoin/Wallet/Server.hs#L159
23:26:40 <runeks> When running with -N1, the main thread dies, but with -N4 the main thread never dies
23:26:45 <cocreature> runeks: which version of async are you using?
23:27:14 <runeks> I'm trying to rebuild now using lts-8.5, I believe I was using lts-6.14 before (GHC 7.10.3, I believe)
23:27:34 <cocreature> the behavior changed in 2.1.1 iirc. before that "cancel" will throw the exception but not wait for the thread to exit
23:27:49 <cocreature> and waitAnyCancel inherits that behavior
23:29:07 <cocreature> lts 6.14 is still on async 2.1.0 so upgrading that might be worth a try
23:29:33 <runeks> with lts-8.5 I get the same behaviour for -N1 and -N4. 
23:29:40 <runeks> now I just need to figure out why it doesn't exit... :)
23:33:59 <cocreature> well at least now you only have one problem to figure out :)
23:40:22 <vlatkoB> In ghc7 I had
23:40:22 <vlatkoB>   type DB a = MonadResourceBase m => SqlPersistT m a
23:40:22 <vlatkoB> but ghc8 complains with
23:40:22 <vlatkoB>   Not in scope: type variable ‘m’
23:41:01 <cocreature> vlatkoB: try type DB a = forall m. MonadResourceBase m => SqlPersistT m a
23:41:06 <cocreature> and enable RankNTypes
23:43:03 <vlatkoB> @cocreature Illegal polymorphic type: forall (m :: * -> *). MonadIO m
23:43:03 <vlatkoB>       A constraint must be a monotype
23:43:03 <lambdabot> Unknown command, try @list
23:43:48 <cocreature> vlatkoB: are you sure that error is caused by this code? it doesn’t mention MonadIO
23:44:25 <cocreature> ah MonadResourceBase is a type synonym
23:46:53 <arun_t> if any one has ebook of haskell programming from first principles Please send one to me I can't afford to purchase
23:47:22 <cocreature> vlatkoB: http://lpaste.net/353966 compiles just fine for me
23:47:45 <pacak> arun_t: learnyouahaskell.com/chapters
23:47:55 <cocreature> arun_t: send the authors an email. they openly said that they gift the book to people that can’t afford it or at least give you a discount
23:49:14 <arun_t> I'm sending one now 
23:50:03 <vlatkoB> cocreature:  yes, it compiles now. Thanks. Was looking at the wrong line. Thanks a lot. :-)
23:52:35 <Autolycus> if you can't really pay for it it's not difficult to find copies on the web
23:57:54 <CMCDragonkai> Hi, in regex, you can write something like /\d{1,5}/, what is the best way to achieve this using just Text.ParserCombinators.ReadP?
