00:08:02 <zuck007__> DROP zuck007
00:08:36 <zuck007__> wtf is this
00:09:03 <zuck007__> how do i logout from annonyms login session and regain my username
00:10:30 <mauke> you can log into your account from any nick
00:10:56 <zuck007__> ok
00:11:00 <mauke> /msg nickserv identify zuck007 yourpasswordhere
00:11:22 <zuck007__> i haven't set a password yet
00:11:48 <mauke> wait, do you even have an account?
00:11:56 <zuck007__> nope 
00:12:27 <zuck007__> i just login from website and chose a username thatsit
00:12:48 <mauke> then you'll have to wait until the other connection goes away by itself
00:13:02 <zuck007__> ok i need to read some docs on irc
00:13:07 <zuck007__> its my first time :)
00:13:47 <mauke> traditional IRC doesn't have accounts/passwords at all :-)
00:14:06 <mauke> here's something on freenode: http://freenode.net/kb/answer/registration
00:14:47 <zuck007__> thanks @mauke
00:15:38 <mauke> another thing. on IRC we generally don't use the @ thing to refer to names
00:16:02 <mauke> clients normally just highlight any line that contains your nick, especially at the beginning of a line
00:16:10 <mauke> zuck007__: like this
00:16:19 <tsahyt> @hoogle (f a -> f b) -> m (f (m a) -> f (m b))
00:16:19 <lambdabot> Data.List.Split.Internals build :: ((a -> [a] -> [a]) -> [a] -> [a]) -> [a]
00:16:20 <lambdabot> Data.Tuple.HT mapPair :: (a -> c, b -> d) -> (a, b) -> (c, d)
00:16:20 <lambdabot> Data.Tuple.Lazy mapPair :: (a -> c, b -> d) -> (a, b) -> (c, d)
00:16:32 <tsahyt> that's not helpful either then
00:16:40 <mauke> ^ and that's the problem with @nick: lambdabot interprets every line starting with @ as a command
00:17:09 <tsahyt> @does it fail silently?
00:17:10 <lambdabot> it fail silently? not available
00:17:22 <tsahyt> or was I just unlucky there
00:17:39 <mauke> @ajsdkflaskdjfks
00:17:39 <lambdabot> Unknown command, try @list
00:18:19 <mauke> bonus feature: lambdabot tries to autocorrect typos in command names
00:18:49 <tsahyt> @hgoole (a -> b) -> f a -> f b
00:18:49 <lambdabot> Maybe you meant: hoogle google
00:18:54 <tsahyt> nice
00:19:23 <mauke> @quate
00:19:24 <lambdabot> Ezla says: Why does Haskell need so many thunks?
00:22:23 <tsahyt> under what circumstances can I get f a -> f b -> f (a -> b)?
00:22:35 <tsahyt> umm with parens
00:22:43 <tsahyt> (f a -> f b) -> f (a -> b)
00:22:45 <tsahyt> there
00:23:37 <tsahyt> no that's not useful either. welp, seems like I'm stuck
00:32:10 <phadej> tsahyt: IIRC (a -> m b) -> m (a -> b) is stronger requirement than "Monad"
00:32:55 <tsahyt> phadej: it seems so. at least in my case it requires "time travel" in both directions
00:33:34 <tsahyt> but I figured out that I can limit the scope of those time travelling things cleverly and produce functions of the required type anyhow
00:34:35 <tsahyt> and limiting the scope of computation is something that's going on in DSP all the time anyhow, so I already have those functions around to lift computations on buffers to my waves types
00:39:50 <phadej> strong monad is the one you an do (a, m b) -> m (a, b); but I have no idea what's the term for exponentiation: (,) is product, (->) is exponent
00:41:13 <phadej> at least if you belive http://comonad.com/reader/2008/deriving-strength-from-laziness/ has terminology right
00:46:22 <tsahyt> phadej: thanks, I'll add this to my reading list
01:07:03 <tsahyt> are there any kind of accepted naming conventions for specializing f a -> f b to f ~= Identity?
01:08:02 <tsahyt> e.g. I have some function returning f a -> f b, and for convenience I think it'd be nice to have a specialized version that just returns a -> b. the types are of course determined by the other parameters, so it's not fully polymorphic
01:18:06 <Cale> :t ala Identity
01:18:09 <lambdabot> Functor f => ((b -> Identity b) -> f (Identity b1)) -> f b1
01:19:21 <tsahyt> where is ala from?
01:19:25 <Cale> Newtype
01:19:30 <Cale> https://hackage.haskell.org/package/newtype-0.2/docs/Control-Newtype.html
01:19:47 <Cale> :t under Identity
01:19:49 <lambdabot> error:
01:19:50 <lambdabot>     • Couldn't match type ‘Identity
01:19:50 <lambdabot>                              (Control.Lens.Internal.Iso.Exchange a b a (Identity b))’
01:20:05 <Cale> hm
01:20:53 <Cale> Though I would say just make the specialised function
01:20:56 <Gurkenglas> tsahyt, see evalState vs evalStateT etc
01:22:19 <Cale> ohh
01:22:21 <Cale> :t ala
01:22:24 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
01:22:30 <Cale> Right, it's lens' ala
01:22:36 <Cale> :t under
01:22:38 <lambdabot> AnIso s t a b -> (t -> s) -> b -> a
01:22:42 <Cale> :)
01:22:54 <Gurkenglas> Though it's kinda sad that the shorter type gets the shorter name, because here it feels like evalStateT would pop out first if you derived Haskell platonically optimally
01:27:20 <zuck007> can anybody recommend some cool projects idea for haskell beginner 
01:36:50 <suppi> maybe something here at the bottom? http://gilmi.xyz/post/2015/02/25/after-lyah
01:37:40 <suppi> oh, left.
03:12:21 <Hudini> Is Haskell difficult?
03:12:38 <merijn> Hudini: "It Depends" (TM)
03:12:40 <Hudini> Many programmers complain that Haskell is like an ocean and is difficult
03:12:42 <mauke> is a string long?
03:13:00 <Hudini> mauke, string can be long and short
03:13:32 <merijn> Hudini: So, my honest assessment is: 1) Haskell is VERY different from what most programmers are used to. 2) Haskell has a rather elaborate and advanced ecosystem
03:14:02 <merijn> Hudini: and 3) a lot of this ecosystem is designed for "easing advanced usage", rather than "make starting easy"
03:14:39 <merijn> Hudini: This means, that Haskell, for many people, feels like starting from scratch. You think "writing a program that does X should be easy!", but it feels very hard, because you need to learn a lot of basics
03:15:46 <merijn> Hudini: Secondly, since a lot of libraries in the ecosystem are more concerned with being "correct/complete" than "easy" to use.
03:16:11 <merijn> Hudini: Now, does this mean Haskell is hard? Maybe. It took me a long time to get "real world" productive with Haskell
03:16:57 <mohsen_> merijn: What do you mea by a library that is correct?
03:17:26 <Hudini> merijn, why should I learn it? What is normally haskell used for
03:18:17 <merijn> Hudini: On the upside: I now feel almost every task is easier for me to do in Haskell than without Haskell. Problems that I wouldn't dare tackle without Haskell seem easy now
03:18:59 <Hudini> merijn, what is Haskell used for? Scientific computing?
03:19:09 <brynser_> I started learning Haskell ~15 months ago and can do "real world" stuff but I'd consider myself late beginner. I use it for general programming tasks, like one might use Python or Java.
03:20:15 <mauke> Hudini: IRC bots, websites/web apps, compilers, version control, scripting boring tasks
03:20:16 <merijn> mohsen_: I mean that most popular libraries are rather pedantic about enforcing correctness/errors, which often means "getting a first prototype" is often a lot more hassle, than say, in python
03:20:59 <merijn> mohsen_: You know how in python you can get the first 80% of what you want in almost no time? And then you want to make things robust and then the last 20% requires like 20 times more work than the first 80% did?
03:21:18 <merijn> (Or replace python with: ruby, JS, whatever)
03:22:38 <Rembane> One interesting aspect of Haskell is that it is a research language, and research has a tendency to trickle down into popular libraries which makes things interesting.
03:22:51 <Hudini> merijn. Okay. I actually would like to learn it, what book is suited for people who are beginner in programmer? 
03:22:56 <suppi> Hudini: may I ask what interested you into coming here and ask about Haskell?
03:23:36 <suppi> it might help us understand how to describe Haskell to you better :)
03:23:44 <mauke> as a beginning programmer you have a bit of an advantage because you don't have to unlearn habits from other languages
03:24:02 <suppi> also www.haskellbook.com for your question :)
03:26:00 <brynser_> I learned it using the haskellbook.com book. Although it says "Early access", it's pretty much finished, just no initial release yet.
03:26:16 <brynser_> official* not initial
03:26:36 <mohsen_> I started with lyah, and not finished yet
03:30:10 <Hudini> Isn't function just something like this: func (x) { print x }
03:30:20 <dramforever> Hudini: Surprisingly, no
03:31:21 <Rembane> Hudini: f x = print x
03:31:28 <Rembane> Hudini: Haskell is superterse. :)
03:31:29 <dramforever> In Haskell, a function doesn't 'do' something like 'print'.
03:31:36 <dramforever> (pun not intended)
03:32:00 <dramforever> It's more like a mathematical function that specify a relationship between the result and the arguments
03:32:20 <dramforever> 'f x y = a + b' means 'the result is the sum of the two arguments'
03:34:14 <bollu> what is the "wildest" example of profunctor
03:34:39 <mauke> that would be either f x y = x + y or f a b = a + b
03:34:43 <mauke> or f = (+)
03:34:45 <bollu> the weirdest functor when you start out is (->), right? till it's normalised. Similarly, what's something that stretches profunctor to the extreme?
03:35:02 <bollu> I'm trying to build up a good intuition for them
03:35:03 <dramforever> Oh damn
03:35:06 <dramforever> I can't variable
03:35:12 <dramforever> mauke: Thank you
03:35:28 <mauke> you're not very able :-D
03:36:17 <dramforever> :(
03:40:18 <fendoer> > foldr (*) 0 [1..5] :: Expr 
03:40:21 <lambdabot>  1 * (2 * (3 * (4 * (5 * 0))))
03:48:18 <lep_> :i Expr
03:51:54 <fendoer>  lep_, he doesn't unterstand :i
03:52:21 <lep_> @src Expr
03:52:22 <lambdabot> Source not found. Take a stress pill and think things over.
03:53:22 <lep_> i was mostly interested if Expr was defined in some base package
03:54:07 <MarcelineVQ> it's from http://hackage.haskell.org/package/simple-reflect iirc
03:54:51 <lep_> ic
03:57:14 <_sras_> I am trying to use hdevtools. For a project that builds successfully, I get a missing instance error when I try to check one of the source files using `hdevtools --check` command
03:57:16 <_sras_> http://lpaste.net/353094
03:57:42 <_sras_> The missing instances are supposed to be generated by template haskell.
03:59:31 <_sras_> Also, if you see the error. The error message says that the available instances match the missing instance.
05:10:02 <nate_> Is there a convenient way to encode symmetric data types, whose constructors are coupled to each other?
05:10:08 <nate_> E.g., data Inner = Inner1 A | Inner2 B | ... | Inner100 Z; data Outer = Outer1 Inner1 Foo | Outer2 Inner2 Bar | ... | Outer100 Inner100 Quux
05:11:36 <nate_> duplicating the definitions of Inner in Outer seems fragile, just using Inner is fragile, since OuterN requires InnerN in perfect correspondance.
05:12:37 <nate_> Breaking Inner into 100 individual datatypes Inner1 through Inner100 and then having a sum type Inner over them all is tedious boilerplate.
05:12:49 <nate_> Is there an obvious solution to this that I'm not seeing?
05:17:49 <merijn> nate_: Why exactly do you have a 100 different constructors to begin with?
05:17:59 <merijn> That seems highly suspicious
05:18:32 <nate_> I don't, it's just arbitrarily large.
05:18:53 <nate_> I have 10 or maybe 20, but maybe it will change, I dunno.
05:19:12 <merijn> 10 or 20 already sounds like a lot. Can you tell us what you're doing?
05:19:25 <nate_> Abstract Syntax Tree :^/
05:19:52 <merijn> ok, then 10 sounds more reasonable. Why exactly do you have two separate types depending on each other, though?
05:20:00 <merijn> i.e. what are Inner and Outer representing
05:20:59 <nate_> Two different syntactic forms of the AST
05:21:52 <merijn> ?
05:22:10 <nate_> One of the forms has extra information, but the extra info is unique to each AST node type
05:22:43 <merijn> nate_: Why not have a single form and have "Maybe Annotation" on every constructor?
05:23:49 <nate_> Ah, good question!  Because the annotated form can only occur in certain places, and I want to be able to forbid it where it cannot occur.
05:24:05 <merijn> nate_: Extra parameter to your AST?
05:24:36 <nate_> Otherwise, everything that consumes it will either have to be a partial function or throw an error or something gross
05:24:46 <nate_> So, like data AST a = ...?
05:25:20 <merijn> "data AST f a = MyNode Foo Bar (f Annotation)" and then use "AST Identity" for parts where you *can* have an annotation and "data Forget a = Forget" and "AST Forget" where you can't have annotations?
05:26:23 <nate_> I do that elsewhere where it's a bit more uniform, I guess I hadn't considered that for this case.  It's an interesting suggestion.
05:28:04 <nate_> That's a bit of a Maybe at the type level, no?  A little cleaner, but it would hypothetically let you parameterize it over some arbitrary f that could make no sense.
05:28:39 <merijn> nate_: Yes, but you can stop that by simply not exporting the "AST" type directly
05:29:05 <merijn> nate_: "type AnnotatedAST = AST Identity; type UnannotatedAST = AST Forget" and then only export those two
05:29:22 <nate_> Granted.
05:29:48 <nate_> Alright, you've convinced me!  That's a good idea, at least until I'm convinced there's a better one :^)
05:31:32 <merijn> nate_: I'm not sure it's the most elegant solution, but it's the first thing that I can think of that avoids painful duplication :)
05:32:05 <nate_> merijn: By the way, I come to this channel once every few weeks with a question, and this is probably the 5th or 6th time you've helped me; if it is not too personal to ask, do you program Haskell for a living?
05:33:00 <merijn> I use Haskell a lot and at work, but mostly for quick scripts not the main code
05:33:15 <MarcelineVQ> merijn doesn't program at all, he's from the future and his cover is that of a working programmer
05:34:01 <nate_> Escaping to the past from the dystopic nightmare of a post P=NP world?
05:34:24 <merijn> Mostly because my main code is GPU code written in C++, so Haskell is not really suitable for that. And lots of Python plotting scripts that, as a lot of people can attest due to my complaining, I regret not writing in Haskell :p
05:34:45 <merijn> Honestly, rewriting most of my python to Haskell is currently a high priority task :p
05:35:01 <MarcelineVQ> "nanobots grey-goo'd far-future earf, the only escape was the past, her format guardian, to mend and defend..."
05:35:33 <nate_> That's a riot, as I just rewrote a matlab visualization tool into matplotlib...
05:36:08 <merijn> nate_: I used matplotlib, because "chart (haskell library) doesn't quite have all I want yet, this'll save time!" <- should've just fixed Chart
05:36:44 <merijn> Then I used scikit-learn (machine learning library), because "I'm already using python and writing something from scratch and reinventing the wheel is inefficient" <- should've just reinvented the wheel
05:36:56 <merijn> Everyone else's wheel are shitty >.>
05:37:26 <nate_> Well, their languages are dirty. so :^P
05:40:23 <merijn> Honestly, my day to day coding is a polyglot mess :p
05:42:06 <nate_> Eh, could be worse.  My philosophy is the more languages you know, the better you can think about problems in any language.  Until you get to pure math, then everything else feels like it's for peasants.  Which makes it hard to go back to C++.  But then you remember you like food, and not dying.
05:44:21 <dramforever> merijn: That moment when you realize that 'saving time in the short run' does not make sense :(
05:44:37 <merijn> dramforever: I was hoping to save time in the long run
05:44:55 <merijn> dramforever: Because "these libraries are widely used, that must mean people are making them not suck"
05:45:28 <dramforever> Oh noooooo waaaaaay
05:45:32 <dramforever> That sucks even more
05:45:53 <nate_> Try being someone thinking of the long run and working in consumer products.  Everyone has the memory of a mayfly.  The long run is fiction.
06:06:20 <Boomerang> In Data.Map there are functions like lookupLT, how should I go about making a more general one where I can supply a custom compare function: lookupBy :: k -> (k -> k -> Ordering) -> Map k v -> Maybe (k, v)
06:08:28 <merijn> Boomerang: You can't, really. Map always use the compare supplied by Ord
06:08:32 <mauke> that seems a bit pointless
06:09:08 <merijn> Boomerang: Since Map has to use the same comparison while constructing as it does while doing lookups
06:09:15 <Boomerang> Well I have a map with keys of type (Int, Int) and I want to easy compare on fst or snd depending on the situation
06:09:25 <Boomerang> *Map
06:09:33 <Boomerang> *easily
06:09:40 <merijn> Boomerang: There's no efficient way to do that using a single Map
06:10:12 <merijn> Because there's no efficient way that lookup could be implemented
06:12:08 <Boomerang> That makes sense, maybe a Map isn't an adequate data stucture for my purposes. Thanks for your inputs!
06:13:33 <kubunto> I am trying to remove extra spaces in my program but I cant seem to figure it out
06:13:49 <kubunto> source: http://lpaste.net/353096
06:14:02 <kubunto> output: ("time" ("party" 43 35 67 ) 72 )
06:14:31 <kubunto> i dont want space between 67 and the ) as well as between 72 and )
06:16:35 <Detrumi> kubunto: That's because the pattern match a:b also matches if b is the empty list
06:17:50 <kubunto> Detrumi: just thought of that
06:18:07 <kubunto> i made a case a:[] before a:b to cover
06:19:09 <kubunto> Detrumi: is there a guard i can put in beyond just a better match for this case?
06:19:30 <kubunto> so i could order it however i want to
06:21:45 <hexagoxel> kubunto: a:b@(_:_)
06:22:18 <kubunto> hexagoxel: that would check if the tail list has at least one element?
06:24:21 <kubunto> hexagoxel: so I would read that as a:b such that b has at least one element
06:25:12 <hexagoxel> kubunto: yes
06:26:01 <kubunto> what else could the @ have in it
06:26:24 <hexagoxel> without underscores and better names, it is like first:tail@(second:tailtail)
06:26:27 <Detrumi> The @ just gives a name to a pattern
06:27:03 <kubunto> could i do i@(<5)?
06:27:40 <Detrumi> I'd just go for 3 pattern matches: [a], a:b and [], it's simple to keep them in order
06:28:06 <mauke> kubunto: the syntax is IDENTIFIER '@' PATTERN
06:28:12 <mauke> (<5) is not a valid pattern
06:37:24 <zipper> I'm having trouble converting a bytes into MB/KB because it returns some scientific notation thing :(
06:37:30 <zipper> I mean result
06:37:58 <zipper> > 67824/1024^3
06:38:02 <lambdabot>  6.316602230072021e-5
06:38:16 <zipper> Yeah so how can I get an actual Double?
06:38:18 <kubunto> Detrumi: hexagoxel is my match exaughstive?
06:39:02 <Detrumi> kubunto: You mean the first:tail@(second:tailtail) match?
06:39:30 <kubunto> Detrumi: meaning the empty list case
06:39:45 <dramforever> > printf "%f" (67824/1024^3)
06:39:49 <lambdabot>  error:
06:39:50 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M855349794792...
06:39:50 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
06:39:54 <dramforever> > printf "%f" (67824/1024^3 :: Double)
06:39:59 <lambdabot>  error:
06:39:59 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M395477717473...
06:39:59 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
06:40:14 <dramforever> Screw you printf
06:40:41 <mauke> > printf "%f" (67824/1024^3) :: String
06:40:45 <lambdabot>  "0.00006316602230072021"
06:40:55 <dramforever> Yes that
06:41:14 <dramforever> I admit that I didn't really read the error message...
06:41:26 <zipper> mauke: Thanks
06:41:40 <MarcelineVQ> if you're working from bytes consider using integrals, in which case you'd use div instead of /
06:41:42 <dramforever> zipper: You likely want like 2 decimal places or something
06:41:49 <dramforever> > printf "%.2f" (67824/1024^3) :: String
06:41:58 <lambdabot>  mueval-core: Time limit exceeded
06:41:58 <lambdabot>  mueval: ExitFailure 1
06:42:00 <mauke> :t showFFloat
06:42:04 <lambdabot> RealFloat a => Maybe Int -> a -> ShowS
06:42:06 <Detrumi> kubunto: I'm not sure what you're asking
06:42:07 <dramforever> That's not how it works, lambdabot
06:42:07 <zipper> dramforever: That's exactly what I wanted thank you :)
06:42:10 <dramforever> > printf "%.2f" (67824/1024^3) :: String
06:42:15 <lambdabot>  "0.00"
06:42:21 <mauke> > showFFloat Nothing (67824/1024^3) ""
06:42:24 <lambdabot>  "0.00006316602230072021"
06:42:28 <dramforever> Docs is your friend :)
06:42:33 <mauke> > showFFloat (Just 4) (67824/1024^3) ""
06:42:35 <lambdabot>  "0.0001"
06:42:44 <dramforever> Even better, never knew that
06:42:56 <kubunto> Detrumi: i think it wouldnt work if i gave sentence a node of Node "h" []
06:43:05 <dramforever> I'm thinking, #haskell is a bit like bittorrent
06:43:07 <robertkennedy> :i showFFloat 
06:43:28 <mauke> there is no :i in lambdabot
06:43:42 <robertkennedy> Darn. What module is that in?
06:43:44 <zipper> hmmm `showFFloat` seems great
06:43:49 <MarcelineVQ> Numeric
06:43:50 <mauke> @hoogle showFFloat
06:43:53 <Detrumi> kubunto: Yeah, you'll need at least 3 cases if you do it this way
06:43:53 <lambdabot> Numeric showFFloat :: (RealFloat a) => Maybe Int -> a -> ShowS
06:43:54 <lambdabot> Numeric showFFloatAlt :: (RealFloat a) => Maybe Int -> a -> ShowS
06:43:54 <lambdabot> Numeric.Compat showFFloatAlt :: RealFloat a => Maybe Int -> a -> ShowS
06:45:03 <dramforever> :t intersperse
06:45:06 <lambdabot> a -> [a] -> [a]
06:45:12 <mauke> :t intercalate
06:45:16 <lambdabot> [a] -> [[a]] -> [a]
06:45:30 <dramforever> damn
06:45:53 <dramforever> I'm losing my Haskell skills faster than I can imagine
06:46:16 <MarcelineVQ> there's an option more straight-forward than intercalate as well
06:46:59 <MarcelineVQ> assuming you're working on kubunto's problem :>
06:47:02 <dramforever> Yeah I guess
06:47:07 <kubunto> Detrumi: i am getting a new error now from compilation
06:47:16 <robertkennedy> :t typeRep
06:47:19 <lambdabot> forall k (proxy :: k -> *) (a :: k). Typeable a => proxy a -> TypeRep
06:47:26 <dramforever> no space after 'show a', space before every 'subnode'
06:48:05 <robertkennedy> > typeRep (Just showFFloat)
06:48:08 <lambdabot>  Maybe Int -> Double -> [Char] -> [Char]
06:48:31 <kubunto> doesnt like dealing with g as an argument to a sentence: http://lpaste.net/353097
06:54:17 <robertkennedy> Is 'Left the same as `data HLeft` at the type level (with DataKinds)
06:54:53 <robertkennedy> I mean in the case where I have defined and used HLeft, can I refactor to use 'Left?
07:07:23 <kubunto> quite wierd
07:09:46 <kubunto> can anyone explain why i am getting an ambiguous type error in one case but when i run it standalone in ghci it works just fine?
07:10:21 <Tuplanolla> The monomorphism restriction is probably at it again, kubunto.
07:10:42 <kubunto> Tuplanolla: the whositwhatnow?
07:10:48 <mauke> @where dmr
07:10:48 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
07:10:53 <Tuplanolla> Start your file with `{-# LANGUAGE NoMonomorphismRestriction #-}` and see if it helps, kubunto.
07:11:05 <Tuplanolla> If it does, read more about it there.
07:11:05 <merijn> No, don't do that >.<
07:11:22 <merijn> Disabling monomorphismrestriction is a dumb "default" reaction
07:11:40 <merijn> But reading that wiki page is a good idea
07:11:45 <Tuplanolla> Why? I always turn it off.
07:12:07 <merijn> Tuplanolla: What do you prefer? Compile time warnings or hard to debug silent performance degradation?
07:12:23 <Tuplanolla> I've never seen such a problem.
07:12:32 <merijn> Tuplanolla: Because if your answer is "the former", then disabling monomorphism restriction is changing your default to the latter
07:13:22 <Tuplanolla> All of the counterexamples I've seen have been silly.
07:14:10 * hexagoxel has seen silent performance degradation in one non-silly case. but i'd have to dig really much to find the code..
07:14:26 <merijn> It's always silly counterexamples, until one day it isn't
07:14:57 <Tuplanolla> I'll worry about the extension when it happens then.
07:15:16 <merijn> And then you waste two hours or more debugging an issue that wouldn't have happened if you didn't disable it. Especially since there's a trivial way to get rid of monomorphism issues without disabling it
07:15:23 <Tuplanolla> It's more common that there's a missing `!` somewhere.
07:15:29 <danielsmw> Is there a clear theoretical reason why you might expect performance degredation? I don't know much about what the monomorphism restriction is really giving you.
07:16:36 <merijn> danielsmw: Right, so let's say we have "foo = map expensiveComputation [0..]"
07:16:58 <merijn> danielsmw: Normally if you have an expensive top level computation you'd only expect it to be computed once, right?
07:17:08 <danielsmw> Sure.
07:17:28 <kubunto> merijn: if i understand it correctly, the moment i make a data structure of type graph string int, that the next time i create a new graph of string ? it will be annoyed
07:17:57 <merijn> Since you're just lazily building the result. But if we have a typeclass polymorphic result, like "foo :: Num a => [a]" we have a bit of a problem
07:18:27 <kubunto> merijn: graph is defined as Graph o p
07:18:42 <merijn> danielsmw: Now, what happens if I first use "foo" as "[Double]" and later as "[Int]", both are legal, based on "Num a => [a]", yes?
07:18:58 <danielsmw> merijn: those are both legal, yes
07:19:06 <Tuplanolla> I don't see this as a problem, merijn. If you request two results with different types, you can expect two different computations.
07:19:11 <merijn> danielsmw: Now, clearly I have to compute it once in each case
07:19:17 <merijn> Tuplanolla: It's worse than that!
07:19:18 <danielsmw> merijn: sure
07:19:49 <lyxia> Tuplanolla: but if you require it twice with the same type it's not clear that it will be run only once.
07:19:50 <dramforever> Tuplanolla: Even if I request twice with the same type, it's going to recompute
07:19:53 <merijn> In other words, GHC can't really memoise the result, since it doesn't know which different types you are going to use
07:20:02 <Tuplanolla> I see.
07:20:09 <merijn> So even if you use it as [Int] 10 times, you recompute it all of those times
07:20:44 <merijn> The only other solution is to store one copy of foo per type, but if you only use it once for 10 different types that ends up wasting a ton of memory for no reason
07:20:49 <Tuplanolla> That's a bit annoying, but I'm not bothered.
07:21:05 <danielsmw> merijn: does the specialize pragma relieve this issue for particular types?
07:21:11 <merijn> For functions that's usually not an issue, but for values it's kinda annoying
07:21:18 <danielsmw> ah
07:21:37 <merijn> The logic being, if it's a non-function you're probably expecting it to be memoized
07:21:37 <dramforever> I used to do NoMonomorphismRestriction. But then I learned to write all top-level signatures, and I've never found myself needing that again
07:21:59 <kubunto> dramforever: toplevel sigs?
07:22:11 <merijn> danielsmw: So the solution chosen in the report is to say that any top-level polymorphic non-function gets monomorphised
07:22:14 <Rembane> I used to be a NoMonomorphismRestriction like you, but then I took a top-level signature to the knee.
07:22:22 <Tuplanolla> If it ever does become a problem, I'll just turn the extension off when the module is finished.
07:23:05 <merijn> danielsmw: So if I have "foo :: Num a => [a]" and GHC sees you use it as '[Int]' GHC simply goes 'welp...I'm just gonna assume this is *always* Int so I can have the memoised behaviour you expect of things that are not typeclass polymorphic"
07:23:47 <dramforever> kubunto: I don't think this will solve your problem in that code
07:23:55 <merijn> danielsmw: The result is: If you have a top level non-function that you only use with 1 type it "Just Works" (efficiently!). If you use it with 2 different types you get a compile error (easy to detect!)
07:24:14 <kubunto> dramforever: i know why the problem is there
07:24:24 <kubunto> cant figure out the second generic type
07:24:30 <merijn> danielsmw: The other solution would be, to assume it's polymorphic and always recompute. But if you're not thinking of that you get expensive recomputation at runtime (tricky to detect!)
07:24:59 <merijn> danielsmw: And when writing the standard "loud compile errors" were deemed preferable to silent bad performance
07:25:03 * dramforever is confused
07:25:44 <merijn> danielsmw: Of course, it's trivial to get rid of the error if you DO want it to be polymorphic, which is: write an explicit type signature. GHC only monomorphises top-level, non-function values without a type
07:25:54 <hexagoxel> Tuplanolla: i'll paraphrase my case: In some part of a synthesizer i needed silence as a default case. So i had a local let zeroVec = SV.sample 96000 (const 0.0). Due to NMMR, this had some non-monomorphic type (Fractional t => SV.Vector t), and it created a new vector for each use of that binding, even though it only ever needed Vector Floats.
07:26:00 <merijn> danielsmw: But that way you're at least forced to conciously decide "this should be recomputed all the time"
07:26:30 <kubunto> dramforever: my initial issue was because the compiler couldnt figure out what hte second type was for Graph op when all it had to go on was Node String
07:26:46 <kubunto> graph o p*
07:27:00 <dramforever> Oh there's a second issue?
07:27:23 <kubunto> dramforever: nah, that is just what started this
07:29:00 <danielsmw> merijn: I see. 
07:29:37 <danielsmw> merijn: So actually, I've /always/ written top level sigs, and the only time GHC has suggested NMRestriction to me is when I've used certain external libraries.
07:29:50 <dramforever> Wait a sec
07:29:54 <danielsmw> But you're saying that when I have top level polymorphic functions, they're not going to be memoized?
07:29:59 <dramforever> That's not because of MonomorphismRestriction right?
07:30:05 <dramforever> That's ExtendedDefaultRules
07:30:44 <Tuplanolla> It helps to mentally treat `=>` like `->` when reasoning about performance.
07:30:52 <dramforever> If you start ghci with -Wall it tells you it defaulted the type of g to Graph String ()
07:31:09 <merijn> danielsmw: memoised isn't really the right term, but anyway. For functions it's not really relevant, since everytime you pass in a new argument you have to compute the result from scratch anyway
07:31:47 <merijn> danielsmw: If you always write top level sigs the ambiguity where NMR kicks in is never there, because you're always explicitly telling GHC what you're expecting
07:31:58 <dramforever> wait a sec...
07:32:20 <danielsmw> merijn: Ah, okay, sure. So it really only does matter if I have constant valued top level computations, which I want to be polymorphic. Which does sort of seem edge-casey, but I can imagine it happening.
07:32:29 <danielsmw> (in practice)
07:32:37 <dramforever> Enabling NoMonomorphismRestriction *does not* solve kubunto's problem
07:32:44 <dramforever> ExtendedDefaultRules *does*
07:33:15 <merijn> danielsmw: Well, if you generate, e.g., a top-level vector of 10,000 entries, you'd probably want it to only be computed once :)
07:33:29 <danielsmw> merijn: Indeed :) thanks!
07:33:54 <merijn> danielsmw: And it doesn't happen a lot, sure. It's just that *when* it does it probably results in hair pulling debugging if you let it happen silently :p
07:34:55 <Cale> If apparent constants are *type class* polymorphic, then they won't be memoised, because they're secretly functions (of the type class dictionary), and the results of functions are never retained on their own (to do so automatically would basically mean giving up on garbage collecting anything ever)
07:34:56 <kubunto> merijn: this extended defaults thing looks right
07:35:16 <kubunto> dramforever: is that ignored in standard ghci?
07:37:03 <dramforever> It's turned on by default in GHCi
07:37:14 <dramforever> You can :set -XNoExtendedDefaultRules
07:37:30 <dramforever> Quick check: 'print []' changes from 'works' to 'doesn't work'
07:38:13 <kubunto> how would i specify a type for the generics in my definition?
07:38:32 <kubunto> data Num d => Graph d o = Leaf d | Node o [Graph d o] deriving (Show)
07:38:46 <kubunto> ignoring the num d part
07:39:05 <dramforever> kubunto: You don't
07:39:12 <dramforever> because you don't need to
07:39:36 <delYsid> How do I write a parser combinator that works like many, but only counts occurances?
07:39:59 <Tuplanolla> You `fmap length`, delYsid?
07:40:04 <delYsid> the efficient version of length <$> many p
07:40:26 <dramforever> kubunto: You want to use -Wall
07:40:42 <delYsid> Tuplanolla: Yeah, thats the obvious version, but I'd like to avoid the consing.
07:40:49 <kubunto> dramforever: as long as ther is a leaf in the graph, it is good
07:40:54 <lyxia> delYsid: take the definition of many and inline length <$> into it
07:41:13 <kubunto> no leaf -> no compilation
07:41:20 <dramforever> As you can see GHC defaults your types beyond what you would like
07:41:45 <dramforever> This is a hint: add more signatures
07:42:17 <lyxia> delYsid: aren't you optimizing prematurely
07:42:40 <delYsid> lyxia: no :-)
07:42:41 <kubunto> dramforever: how would i specify in place of the generics in my definition
07:42:48 <dramforever> specify what?
07:42:55 <kubunto> int and char
07:43:02 <kubunto> int and char
07:43:04 <kubunto> or rather [char]
07:43:28 <dramforever> That's not 'generics' any more
07:43:48 <fbergmann>  q
07:43:56 <jnj> Is something like this possible: class X a where { someThing :: a -> b } (so a type class with a single function someThing returns an unknown type 'b')
07:43:57 <kubunto> dramforever: i know
07:44:11 <kubunto> i want to know how to make it non generic
07:44:28 <dramforever> You want to specify the types of a through g?
07:44:50 <dramforever> a :: Graph Int String
07:45:13 <Cale> jnj: That would mean that someThing would produce a value of any result you wanted it to, which pretty much means that it has to fail.
07:45:54 <Cale> (by throwing an exception or running forever, as that's the only kind of thing which could be of an arbitrary type)
07:46:19 <lpaste_> dramforever pasted “kubunto please see this” at http://lpaste.net/353103
07:46:20 <Cale> any result type* you wanted it to
07:47:31 <dramforever> jnj: That's how 'unknown type' works
07:47:34 <lyxia> delYsid: count p = fmap (+1) (p *> count p) <|> return 0
07:47:36 <dramforever> Crap
07:47:43 <Cale> jnj: If you wanted it to mean "There exists some type b for which someThing produces a result of type b, but you can't know which", that's even less useful, because you could never ever use such a result (since you don't know what type it is, you'll never be able to inspect it)
07:47:45 <dramforever> That's *not* how 'unknown type' works
07:48:05 <jnj> Cale: I guess the error is confusing me a little: http://lpaste.net/353102 but i'll try and wrap my head around it
07:48:10 <Cale> You could do that with an existential type, but not a useful existential type.
07:48:11 <jnj> I don't see why that paste does not typecheck
07:48:29 <Cale> jnj: Because that function clearly produces a String
07:48:37 <Cale> Not a value of type b
07:48:50 <Cale> What if I want it to produce an Integer for me?
07:49:13 <Cale> I'm allowed to specify that b is Integer when I use the something function.
07:49:34 <jnj> I was expecting Haskell to infer that b == string I suppose, but I can see the problem in that
07:49:56 * kubunto is curious about these types im seing in ghci
07:50:13 <jnj> Can I have "something" return a type class? 
07:50:33 <kubunto> what does this mean:  Graph [Char] [Char] compared to (Num d, Num o) => Graph d o
07:51:10 <Cale> Well, functions at the value level have to produce values. Type classes are type-level things, and are only around at compile time.
07:51:30 <Cale> What are you trying to do?
07:51:33 <dramforever> jnj: The *caller* gets to choose what 'b' is
07:52:01 <Cale> Yeah, this would be clearer if all type variables were explicitly quantified
07:52:02 <dramforever> It means that I can call 'something', and *choose* b
07:52:22 <dramforever> kinda like an argument
07:52:43 <Cale> You'd have  class X a where something :: forall b. a -> b
07:53:08 <Cale> Maybe what you're looking for is a class associated type
07:53:12 <jnj> That's producing the same error, I tried it but am not strong in forall.
07:53:15 <Cale> class X a where
07:53:19 <Cale>   type XResult a
07:53:27 <Cale>   something :: a -> XResult a
07:53:35 <Cale> instance X Int where
07:53:41 <Cale>   type XResult Int = String
07:53:51 <Cale>   something = const "hello world!"
07:54:04 <dramforever> jnj: It's *very* unclear about what you're trying to achieve
07:54:18 <dramforever> Can you like explain further?
07:54:20 <Cale> jnj: That's because it's equivalent to what you wrote
07:54:39 <glguy> jnj: you don't get to pick what b is when you're defining your function. the users of your function get to pick it, so you have to be ready for any choice the user makes, you can't guess string
07:54:41 <Cale> jnj: It's just (hopefully) clearer that the type of something says that it should work for all types b
07:55:29 <Cale> jnj: Haskell automatically sticks foralls in at the top level of type signatures to bind the type variables which occur free in them.
07:55:52 <Cale> e.g. when we write   map :: (a -> b) -> [a] -> [b]
07:56:02 <dramforever> We're getting to far away from jnj I think
07:56:03 <Cale> it really means  map :: forall a b. (a -> b) -> [a] -> [b]
07:56:24 <Cale> i.e. whatever map does, it must work for all choices of types a and b
07:57:39 <Cale> The way it accomplishes that is by not inspecting any values of type a or b, so that it's just passing the (pointers to) values around.
07:58:39 <jnj> this is what i wrote down, don't know if that makes sense
07:58:40 <jnj> http://lpaste.net/353105
07:58:52 <jnj> (which does not compile)
07:59:27 <Cale> Well, the type of getCell is highly suspicious
08:00:24 <Cale> You probably want either a multiparameter type class with a functional dependency, or you want an associated type
08:00:39 <Cale> (or you don't want a type class at all)
08:01:16 <Cale> Also, the Monad constraint is weird
08:01:39 <delYsid> lyxia: ahh, nice, thanks!
08:01:46 <Cale> There's very little you could do to create an action in an arbitrary monad apart from applying return, so it doesn't make much sense to bother with that
08:02:05 <Cale> class Row e a | a -> e where getCell :: a -> Int -> Maybe e
08:02:09 <Cale> makes more sense
08:02:32 <Cale> instance Row a (SimpleRow a) where ...
08:03:15 <jnj> I was thinking that some instances of Row might require getCell to run in for example the IO monad
08:03:27 <Cale> Yeah, but you haven't said that
08:03:28 <jnj> anyways, I'll rethink the entire thing anyways, as it's not the right way
08:03:32 <Cale> You said it works in *any* monad
08:03:43 <jnj> Oh
08:03:59 <Cale> So you're not required to use it in IO at all, you could use it in the list monad, or Maybe.
08:04:09 <dramforever> jnj: You got the type variable thing completely wrong
08:04:27 <kubunto> dramforever: i got how to escape the issue with an empty list
08:04:36 <Cale> We could also parameterise the class by a choice of monad
08:04:41 <kubunto> let k = Node "fitness" [] :: Num a => Graph a [Char]
08:04:44 <dramforever> When I have an expression e, and it is of type 'forall a. something something'
08:04:45 <Cale> and have that depend on the row type as well
08:05:00 <Cale> class Row m e a | a -> m e where
08:05:09 <dramforever> Then when I use 'e', *I* get to choose what 'a' is
08:05:12 <Cale>   getCell :: a -> Int -> m (Maybe e)
08:05:35 <Cale> The "| a -> m e" means that the choice of a uniquely determines m and e
08:05:42 <dramforever> You know C++ templates or Java generics? It's a tiny bit like those
08:05:57 <Cale> The compiler will prevent you from writing more than one instance for any given type a
08:06:09 <Cale> but in exchange, it will infer m and e whenever it knows a
08:06:17 <Cale> (by looking for which instance applies)
08:06:35 <Cale> You can do some pretty fancy type level computation with this.
08:06:41 <jnj> I'll look into your suggestions, for now I need to read.. Thanks for your help
08:07:18 <Cale> Equivalently, using the newer TypeFamilies extension you could write:
08:07:31 <Cale> class Row a where
08:07:47 <Cale>   type RowM a :: * -> *
08:07:57 <Cale>   type RowElement a
08:08:14 <Cale>   getCell :: a -> Int -> RowM (Maybe (RowElement a))
08:09:12 <Cale> and then when you write the instance, you get to specify what those type synonyms expand to, when applied to the particular type a
08:09:24 <jnj> that might work, thanks
08:10:19 <merijn> Any persistent users who can tell me whether I can have "compound" fields in my entities? i.e. I have a datatype "data Foo = Foo Int Int Int" and another thing that has "data Bar = Bar Foo Foo Foo", can I somehow represent that in persistent easily? i.e. I just want a flat row with 9 Int in my resulting database, but on the haskell side have 9 direct Int fields is annoying compared to nesting like that
08:10:59 <Cale> merijn: I know it's possible with groundhog, so I would be surprised if persistent didn't also do it
08:11:32 <merijn> Cale: I would expect something like that to be possible, but I haven't found a way yet
08:12:35 <Cale> Wow, persistent's documentation actually manages to suck more than groundhog's
08:12:44 <merijn> Cale: Word :p
08:13:37 <merijn> Honestly, the Yesod way with lots of MPTC mtl constraints leads me to understand the complaint about unscrutable Haskell documentation >.>
08:14:46 <merijn> Cale: I hadn't heard of groundhog before. Would you recommend it?
08:15:19 <Cale> Well, it's terrible, but we're using it, so that's something.
08:15:27 <merijn> Cale: ah...
08:15:41 <Cale> It's less terrible than many of the alternatives
08:15:47 <merijn> That doesn't sound like a ringing endorsement for being better than persistent
08:16:21 <Cale> But looking at these entity definitions from persistent, it seems groundhog does a way better job of letting you specify how things are mapped to the DB
08:16:57 <Cale> even if you have to write a weird yaml syntax and it silently ignores anything it doesn't understand
08:17:28 <merijn> Cale: yeah, but on the other hand I already figured out persistent now and I'm not tied to a schema anyway
08:18:07 <merijn> So investing similar time into something else which is, at best, only marginally better seems a waste
08:18:22 <Cale> https://hackage.haskell.org/package/groundhog-th-0.8/docs/Database-Groundhog-TH.html
08:18:28 <Cale> -- documentation by example
08:20:00 <Cale> The main reason we use groundhog at this point is to get some automatic migrations (it's not bad at doing all the really easy ones), and to get a little extra type safety for the very simplest queries we need to do
08:20:23 <Cale> We end up using postgresql-simple to do a lot of queries, because groundhog (like persistent) doesn't support joins
08:21:05 <Cale> (they're compatible)
08:22:01 <Cale> If you've used persistent, using groundhog is usually the same -- it was actually forked from persistent somewhere along the way
08:22:16 <Cale> But the template haskell shenanigans seems to be quite different
08:23:41 <merijn> Cale: Basically, what I mostly need is SQLite and preferably a conduit/pipes interface to query results
08:23:42 <Cale> https://github.com/lykahb/groundhog/blob/master/examples/basic.hs
08:24:16 <kuribas> Does using mutable state improve performance?  (using STRefs for example)
08:24:26 <merijn> kuribas: "it depends"
08:25:05 <merijn> Cale: honestly, I don't think I really need joins atm
08:25:52 <merijn> Cale: Also, doesn't esqueleto provide joins for persistent?
08:26:08 <kuribas> I am amazed how much writing haskell code in a low level way can improve performance.
08:26:24 <kuribas> haskell is not very cache friendly.
08:26:30 <brynser_> I think persistent would end up storing your Bar value as a single varchar, the contents being 'show <Bar>'. At least that's what happened when I tried storing a product data type
08:26:33 <merijn> kuribas: That's the same in any language, knowing what you're doing is crucial for performance
08:26:45 <merijn> brynser_: That's for sum datatypes, yes
08:26:56 <kuribas> merijn: sure
08:27:04 <Cale> merijn: Yeah -- I have no idea how complete it is, but it claims to do so.
08:27:09 <merijn> brynser_: But I just have a simple product datatype, and storing as varchar is utterly unacceptable for my usecase
08:27:17 <MersenneInteger> Should Haskell be my first foray into functional programming or should I learn Scheme first and work my way up to Haskell?
08:27:31 <merijn> Cale: I remember a presentation at Dutch FP day on esqueleto, it seemed reasonably complete
08:27:42 <Cale> MersenneInteger: I'd say go for Haskell directly.
08:27:47 <merijn> MersenneInteger: tbh, I don't think learning Scheme first will really help much
08:27:49 <kuribas> merijn: I don't think it matters, except for inner loops...
08:28:06 <kuribas> MersenneInteger: scheme is great, but it is rather different from haskell.
08:28:21 <brynser_> merijn: Oh right, not sure then, I've only done e.g. "data Foo = Bar Int | Baz Text | ..."
08:29:24 <Cale> If you were going to go for any lisp, I would say some scheme variation is probably the best to try to do functional programming in. Common lisp is quite annoying -- I've tried to program in a functional style in it, and you're basically swimming upstream.
08:29:30 <kuribas> MersenneInteger: scheme is strict, dynamic typed, and uses Lispy syntax.
08:30:02 <Cale> But no pattern matching is sort of... barely functional programming.
08:30:44 <MersenneInteger> Thanks for the answers, Ive never programmed in a functional language before so I didnt know where I should start. I considered reading SICP because I wasnt sure where to start. Where is a good (book) place to start with Haskell? Sorry for the noob questions.
08:30:58 <Cale> SICP is really good, yes
08:31:25 <merijn> Cale: oh, maybe I can get it to work by writing a PersistEntity class by hand
08:31:50 <Tuplanolla> Scheme is certainly less daunting to start with, MersenneInteger.
08:32:03 <Cale> We don't really have anything nearly as good as that specifically for Haskell, but Graham Hutton's "Programming in Haskell" is good.
08:32:17 <Cale> If you're looking for something freely available to start off with...
08:32:29 <Cale> http://www.cis.upenn.edu/~cis194/spring13/
08:32:34 <kuribas> MersenneInteger: SICP is great, but it isn't really about scheme, it's more about programming paradigms.
08:32:46 <Cale> contains a bunch of lecture notes and exercises which many people have found useful
08:33:19 <Cale> Yeah, reading SICP / watching the SICP lectures is a lot of fun once you know a bit of Haskell too
08:33:56 <Cale> Because you get to see how many of the things they talked about there have been formalised into Haskell.
08:34:36 <Cale> (Things which were merely conventions have gotten language support)
08:34:57 <frostbit> Hey
08:35:02 <Cale> hello!
08:35:15 <frostbit> can you tell me what <+> does?
08:35:21 <merijn> Cale: hmm, maybe not, apparently the recommend solution "hand write a conversion from persistent entiy to your own datatype" :\
08:35:33 <Cale> frostbit: Probably if you can tell me which library it comes from
08:35:41 <frostbit> I saw it in xmonad
08:35:52 <frostbit> I thought it was part of standard package
08:36:00 <frostbit> And I hadn't read it
08:36:09 <frostbit> so that's why tho confusion
08:36:26 <Cale> ah, it's infix mappend
08:36:30 <suppi> MersenneInteger: www.haskellbook.com is quite good from what i read. i also like this course to get familiar with fp:  https://www.coursera.org/learn/programming-languages 
08:36:49 <Cale> But specifically, in xmonad, it's used to compose together ManageHooks
08:37:20 <suppi> it's standard ml but the ideas you learn there transfer to other languages like haskell, ocaml, elm, etc
08:37:38 <frostbit> Oh right
08:37:50 <frostbit> I feel like a knobhead now
08:38:25 <merijn> bleh, this is annoying. So I can either get decent mapping of datatype to database with groundhog, or keep the ability to add/switch to esqueleto if I need joins with persistent, but not both :\ 
08:38:44 <merijn> And groundhog apparently can't stream results either
08:39:03 <Cale> The result of a ManageHook is an Endo WindowSet, which is just a wrapper around a function WindowSet -> WindowSet, and it basically composes those functions together.
08:39:19 <Cale> merijn: Everything is terrible
08:39:54 <frostbit> Got it thanks
08:39:55 <Cale> merijn: It's one of the biggest scary things to tackle on our horizon
08:39:56 <frostbit> \part
08:40:19 <merijn> Cale: honestly, since I probably don't need joins I'd be fine switching to groundhog, but the lack of streaming results kinda kills me :(
08:40:53 <merijn> Cale: I don't wanna get lists for queries with hundreds of thousands or more results
08:41:56 <Cale> Yeah, we just stick LIMIT on most things
08:42:57 <merijn> Cale: That doesn't work very well if you actually plan to use all those results ;)
08:42:59 <Cale> (If we ever have to deal with more than a handful of results at a time, something is wrong with our architecture anyway, due to the nature of our applications.)
08:43:43 <merijn> Right now I have all my data in...plain text files, that I munge in memory before feeding it to my code, which is killing my performance now that I've 10x increased my dataset :p
08:43:57 <merijn> So it's one of the main reasons to wanna dump everything in an SQLite database
08:44:33 <merijn> Right, so persistent + ugly manual data conversion it is, for now
08:45:39 <clmg> How do I use Control.Lens.Plated?
08:46:39 <Cale> merijn: I don't know whether you're looking to scale up to using a full database server at some point, but given that description I'd be tempted just to switch to using something like binary or attoparsec (and pipes?)
08:47:02 <c_wraith> clmg, are you asking about making a type compatible with it, or using its combinators to achieve a particular goal? 
08:47:31 <merijn> Cale: No, these are just benchmark results I'm analysing/plotting
08:47:48 <clmg> c_wraith: I'm asking about what to write in the `instance Plated Foo where`
08:47:51 <merijn> Cale: It's just that my dataset has grown to the point where trivial scripts start to become to slow
08:48:06 <clmg> I need some `plate =` but I can't find any examples of how to implement Plated
08:48:28 <merijn> Cale: But that's not a workload that really demands a dedicated server. Especially since having all benchmark results in an SQLite file is nicely portable
08:49:01 <clmg> c_wraith: the structure is `Split = Split { left :: Maybe Split, right :: maybe Split }`
08:49:20 <clmg> I need to traverse these splits without simply deriving data.
08:49:42 <merijn> Cale: 'cause right now I have 50k text files of results, which would be a lot nicer as a single SQLite db :p And I do want to do some filtering/preprocessing in what datapoints I consider, so a straight up attoparsec+pipes thing seems a bit inconvenient
08:49:47 <Cale> clmg: Well, one option is just to add deriving (Data), and then write  "instance Plated Split"
08:50:09 <clmg> Cale: but I'll want to add more fields to split soon. like a filepath
08:50:17 <clmg> Cale: can I have filepath derive data also?
08:50:23 <c_wraith> clmg, deriving Data is the easiest, but it's not too bad manually. you just write a traversal that returns its direct children. 
08:50:34 <Cale> Does it not already?
08:50:40 <clmg> Cale nope
08:50:45 <Cale> ah, fair enough
08:50:51 <Cale> well, you can just write the traversal directly
08:51:11 <clmg> Cale: any examples other than the cryptic one on hackage?
08:51:31 <Cale> https://hackage.haskell.org/package/lens-4.15.1/docs/src/Control.Lens.Plated.html#Plated
08:52:03 <Cale> not as many good examples as I'd have hoped
08:52:10 <Cale> But the one for lists sort of gives the idea
08:52:24 <c_wraith> clmg, it's just a Traversal. if you work from the type, it's pretty obvious what it has to do. 
08:53:29 <clmg> c_wraith: okay so it's traversing a list. (x:xs) is obvious. [] is obvious. What is f?
08:53:53 <Cale> type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t
08:54:10 <Cale> and here, s, t, a, b are all your type
08:54:30 <c_wraith> f is whatever function is passed in. it's opaque. don't worry about what it *is*, just use it. 
08:54:45 <Cale> So you want to write something of type  Applicative f => (Split -> f Split) -> Split -> f Split
08:55:24 <clmg> I think I'm in over my head a bit
08:55:31 <clmg> thanks guys
08:55:39 <leshow> i thought traverse's type was (a -> f b) -> t a -> f (t b)
08:56:17 <c_wraith> clmg, as an alternative, if Split has lenses for left and right, you can build the traversal out of combinators. 
08:56:27 <lyxia> leshow: the idea is that Split is isomorphic to t Split for some t.
08:56:42 <c_wraith> leshow, Traversal is a generalization of that
08:57:45 <c_wraith> clmg, plate = leftLens . _Just <> rightness . _Just
08:58:50 <c_wraith> clmg, though in all honesty, that's more complicated than just writing it by hand. 
08:58:52 <Cale> plate f (Split l r) = Split <$> traverse f l <*> traverse f r
08:58:58 <Cale> ^^ easier
08:59:13 <clmg> Cale: awesome this is really really helpful
09:00:27 <c_wraith> as I said, writing it directly is a lot easier. :) 
09:01:58 <clmg> what if I want to add more fields to that record. where do that factor into the plate?
09:02:38 <ertes> :t \f (x, y) = (,) <$> f x <*> f y
09:02:40 <lambdabot> error:
09:02:40 <lambdabot>     parse error on input ‘=’
09:02:40 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
09:02:44 <ertes> :t \f (x, y) -> (,) <$> f x <*> f y
09:02:47 <lambdabot> Applicative f => (t -> f a) -> (t, t) -> f (a, a)
09:02:59 <c_wraith> clmg, just add them to the pattern match. unless they are also recursive, they don't need to be used in the body of plate 
09:03:09 <ertes> clmg: ^ a traversal for both components of a tuple
09:03:24 <ertes> @let myBoth f (x, y) = (,) <$> f x <*> f y
09:03:27 <lambdabot>  Defined.
09:03:42 <ertes> > (myBoth +~ 2) & (4, 7)
09:03:48 <lambdabot>  error:
09:03:48 <lambdabot>      • Couldn't match expected type ‘((Integer, Integer)
09:03:48 <lambdabot>                                       -> (Integer, Integer))
09:03:49 <Cale> you might end up replacing the use of the constructor on the left of the <$> with a lambda that replaces the unchanging fields
09:04:01 <c_wraith> clmg, wait, that's not true. they do need to be used to construct the result Spkit
09:04:05 <c_wraith> .. Split
09:04:15 <ertes> > (myBoth +~ 2) (4, 7)
09:04:19 <lambdabot>  (6,9)
09:04:30 <Cale> e.g.  plate f (Split l x r) = (\l' r' -> Split l' x r') <$> traverse f l <*> traverse f r
09:04:34 <c_wraith> clmg, basically, it's the only change you can make that still compiles 
09:04:43 <ertes> > ("hello ", "world") ^. myBoth
09:04:46 <lambdabot>  "hello world"
09:06:41 <clmg> c_wraith: that compiles
09:06:59 <clmg> c_wraith: great :)
09:07:13 <c_wraith> clmg, the compiler is your friend. it tells you what you need to do. it just speaks an odd dialect that takes a while to get used to :) 
09:07:14 <Cale> Yeah, looking at the traversal for both elements of a pair that ertes showed ought to be instructive
09:08:17 <raynold> ahh it's a wonderful day
09:08:20 <clmg> thanks chan
09:09:18 <Cale> You can think of a traversal as separating a data structure into the part outside the elements being traversed, which gets encoded as a function of those elements, sort of like it's the original data structure with holes blown in it, and then each of the elements you're traversing, which have the arbitrary function applied to them and then everything gets combined together with the Applicative combinators
09:10:23 <Cale> (at least, this always works for the cases where there's only finitely many things you're traversing over)
09:11:09 <ertes> another interpretation: a traversal takes apart a structure, applies an effectful function to it, and then reassembles it into the same structure, but with the results
09:12:01 <ertes> myBoth f (x, y) {- here we take apart the tuple -} = (,) {- here we reassemble it -} <$> f x <*> f y  -- after applying the effectful function to each component
09:12:35 <dolio> Cale: Works all the time. You just can't pretend it's a list for infinite cases.
09:13:16 <dolio> (Except infinite lists.)
09:13:24 <Cale> dolio: Well, you can't... have a function with infinitely many parameters
09:13:29 <Cale> But yeah
09:14:05 <ertes> with do-notation (e.g. -XApplicativeDo) it might be a bit clearer:  myBoth f {- take apart: -} (x', y') = do {- apply effect for each component: -} x <- f x'; y <- f y'; {- reassemble: -} pure (x, y)
09:16:12 <joe9> any rainbox users, please? Did you install it with stack? https://hackage.haskell.org/package/rainbox
09:34:46 <ski> Cale : hmm, reminds me of something i've been thinking about ..
09:57:01 <Tuplanolla> Does `ResourceT` release in the reverse allocation order or some random order?
09:57:34 <Tuplanolla> It's not mentioned in the documentation.
09:57:36 <johnw> Tuplanolla: given that they could be inter-dependent, reverse is the only thing that makes sense to me
09:58:57 <Arguggi> I read https://tech.channable.com/posts/2017-02-24-how-we-secretly-introduced-haskell-and-got-away-with-it.html and I don't understand why "we cannot run runWorkerLoop and runFetchLoop with forkIO, because we don’t have the right transformer stack.". Why won't liftIO work?
09:59:30 <Forkk> Is it possible to run valgrind on C code called from Haskell?
09:59:32 <johnw> forkIO *wants* an IO action
09:59:41 <johnw> they could do it with monad-control
09:59:43 <Forkk> It seems to fail setting up function redirection
10:00:14 <johnw> which one can do easily by using lifted-async
10:00:14 <Unhammer> https://www.haskell.org/hoogle/?hoogle=forkliftio
10:00:18 <Unhammer> missed opportunity there
10:00:51 <sternmull> is there a trick to see the precedence inside expressions? When i look at complex expressions i often struggle to see what ends up in which operator/function. It would be helpful to visualize the syntax tree in some way.
10:01:44 <Arguggi> johnw, aaaaaah I think I understand now
10:02:27 <ertes> sternmull: you can ask GHCi about the precedence of individual operators via :i
10:02:34 <ertes> like:  :i (+)
10:03:23 <sternmull> ertes: Yes i know... but sometimes it would be nice if it could insert brackets into an expression or something like that.
10:03:23 <monochrom> Arguggi: You may be thinking "liftIO (forkIO xxx)" but the issue is "forkIO runWorkerLoop"
10:03:51 <Cale> sternmull: The most important thing to remember about precedence (and which isn't strictly speaking a precedence rule) is that function application always binds more tightly than any infix operator
10:04:46 <Cale> So, regardless of the precedence of *,  f x y * g z  will always be (f x y) * (g z)
10:05:21 <sternmull> at the moment i am looking at something like "(a b . c d) e" and wonder what to think of it.
10:05:39 <mauke> ((a b) . (c d)) e
10:05:53 <Cale> That's the same as  a b (c d e)
10:06:48 <sternmull> ok, thanks. But at that point i wondered what i will do when i encounter more exotic operators. After all they can be all get their custom precedence...
10:06:50 <Cale> So a b and c d are functions, they're being composed and then the composite is being applied to e
10:06:55 <Arguggi>  monochrom yes I didn't think of that for some reason. You can "run" the action returning it to IO a and then fork that action right? (which seems to be what was suggesting in the comments unlift :: m r -> m (IO r) )
10:07:32 <Cale> sternmull: Somehow I practically never find myself needing to care about the actual precedence level of operators in Haskell
10:07:53 <davean> I only care when reading edwardk's code
10:08:12 <Cale> Yeah, it's possible to go overboard
10:08:13 <monochrom> Yes, but this means the new thread has nothing to do with the parent thread in terms of what the transformer stack wants to carry, usually.
10:08:25 <flxw> Hi all. Applicative on a tupple lets me do (x,f) <*> (y,a) ==> (x <> y, f a), in case x,y are from the same Monoid. I'm for awhile trying to get <*> working with Semigroup Last on the first component of the pair. Is that not possible? I mean, memtpy should not be needed for this, no?
10:08:39 <sternmull> Cale: Ok. This is more like a diffuse fear. I haven't written/read enough haskell to know if this is a problem in practice.
10:08:40 <Cale> But for the most part, things will be obvious from the types, in cases where the precedence matters at all
10:09:24 <sternmull> yes, type checks will probably catch many accidents.
10:10:18 <monochrom> Basic example: If you use StateT Int IO, you can pretend you have a mutable variable. But once you start doing liftIO (forkIO (runStateT ...)), the new thread's "mutable variable" is now divorced from the parent thread's.
10:10:46 <mauke> they're not even on speaking terms
10:10:47 <monochrom> And even monad-control will not change this.
10:10:52 <ystael> Cale: honestly I think it would be a perfectly reasonable design to say "application has precedence +inf, $ has precedence -inf, everything else *must* be parenthesized" :)
10:10:58 <Arguggi> monochrom, ok thanks that clears everything up
10:11:33 <mauke> record update has precedence inf + 1
10:11:38 <kuribas> > (a b . c d) e
10:11:41 <lambdabot>  error:
10:11:41 <lambdabot>      • Couldn't match expected type ‘Expr -> b0 -> c’
10:11:41 <lambdabot>                    with actual type ‘Expr’
10:12:28 <mauke> > let [a,b,c,d] = map fun ["a","b","c","d"] in (a b . c d) e
10:12:33 <lambdabot>  error:
10:12:33 <lambdabot>      • Could not deduce (Show b0) arising from a use of ‘a’
10:12:33 <lambdabot>        from the context: FromExpr c
10:13:33 <mauke> oh, I'm dumb
10:14:58 <byorgey> flxw: mempty is not needed for <*>, but it is needed for pure.
10:15:02 <mauke> > let [a,c :: Expr->Expr->Expr] = map fun ["a","c"] in (a b . c d) e
10:15:07 <lambdabot>  a b (c d e)
10:15:30 <catern> hey #haskell, I've constructed a type (say, a Passenger) which only makes sense/is meaningful in the context of another type (say, a Vehicle). how should I express this in types? should I add a list of passengers to vehicle, add a reference to vehicle into passengers, or do something else entirely??
10:15:59 <kuribas> > (f x . g y) z :: Expr
10:15:59 <byorgey> flxw: you may be interested in http://hackage.haskell.org/package/semigroupoids-5.1/docs/Data-Functor-Apply.html
10:16:04 <lambdabot>  error:
10:16:04 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘f’
10:16:04 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
10:16:04 <Cale> catern: One of the above?
10:16:17 <catern> Cale: but which one :(
10:16:37 <flxw> byorgey: Oh, thank you. Yes, pure needs mempty, because it must produce a value of type a out of thin air.
10:16:45 <byorgey> flxw: right
10:17:03 <Cale> catern: That really depends on what your program does
10:17:30 <catern> but I want easy answers :(
10:18:32 <mauke> ask easy questions
10:18:42 <Cale> catern: Depending on the circumstances, you might also have some sort of identifiers or references to passengers or vehicles, and you'd be using those in the fields instead.
10:19:08 <catern> Cale: right! that's yet another alternative!
10:19:35 <kuribas> > (f x . (g y :: Expr -> Expr)) (z::Expr) :: Expr
10:19:38 <Cale> Also, instead of a list of passengers, it's quite possible that a Set is more appropriate
10:19:39 <lambdabot>  f x (g y z)
10:20:00 <Cale> Or you might have a Map Vehicle (Set Passenger)
10:20:03 <catern> Cale: sure sure yeah that's not directly related though
10:20:18 <catern> (set vs list I mean)
10:20:42 <Cale> Well, it makes a difference, but maybe not the difference you're concerned about :)
10:20:54 <catern> indeed :)
10:21:06 <Cale> Or a  Map Passenger Vehicle
10:21:18 <Cale> Or a  Map Passenger VehicleId
10:21:21 <Cale> heheh
10:21:40 <catern> I think VehicleId would be strictly worse
10:21:50 <catern> at least from an abstract programming language point of view
10:22:08 <catern> a VehicleId is only meaningful given a Map VehicleId Vehicle
10:22:08 <Cale> Well, think about the case that Vehicle simply describes the characteristics of the vehicle, but doesn't identify it uniquely
10:22:45 <Cale> In that case, having a Map Passenger Vehicle doesn't allow you to determine that two people are in the same car
10:22:51 <Cale> Just that they're in the same sort of car
10:23:03 <Sonolin> well Vehicle could have an "id" field in that case, right?
10:23:09 <Cale> It could
10:23:11 <catern> oh, sure, sure, but I think it's definitely better to have an id field in Vehicle
10:23:16 <Cale> (probably you wouldn't call it id)
10:23:22 <Cale> ;)
10:23:23 <Sonolin> lol, yea
10:23:33 <Sonolin> silly non-haskell brain
10:23:33 <mbrock> naming types after real world object types is often confusing, in functional programming as well as object oriented programming...
10:24:00 <mbrock> there are no vehicles inside your computer!
10:24:20 <catern> a good point
10:24:29 <byorgey> on the other hand, naming everything VehicleInformationEncoding is kind of confusing too =P
10:24:31 <Cale> It's best to have some idea what you're going to be doing with the data as you plan out the structures you're going to store it in
10:24:32 <catern> but, I'm not actually talking about vehicles and passengers, but rather something that exists only in my computer :)
10:25:01 <catern> (Vehicles and Passengers in a game, say)
10:26:49 <catern> Cale: I mean, I find myself frequently encountering the situation where I have a type (like Passenger or VehicleLookupKey) where the values are only meaningful when considered in a context which contains a value of another type (like Vehicle or Map VehicleLookupKey Vehicle)
10:27:16 <catern> so I would like it to be true that there was some general purpose way to think about these cases :)
10:27:27 <catern> some type theory construct?
10:28:41 <dminuoso> Do you folks handwrite your actions creators and reducers for REST interaction? A single endpoint produced so much ugly boilerplate...
10:28:49 <dminuoso> Oh boy. Wrong channel. :|
10:29:46 <Younder> For what it's worth there is no toxonometry that works for every case. This was proved by Wittgenstein. The best you can do is use a user case, a universe of discource, to model the data.
10:31:54 <ertes> catern: i find myself using an approach like this from time to time, depending on the application:  data Vehicle passenger = Vehicle { …, _passenders :: [passenger], … }
10:32:44 <ertes> when it's fresh out of the database, i have a (Vehicle (Key Passenger)), which i can 'traverse' into a (Vehicle Passenger) if necessary
10:35:34 <NemesisD> hi all. i remember there being an extension or feature in recent GHC that lifted constructors to the type level (canonical example of Nat). is there a similar thing for sum types, i.e. data X = A | B, lifting A and B into the type system as distinct types?
10:36:23 <NemesisD> i've got something like data ClearanceLevel = TopSecret | MailRoom and am trying to create a type-level annotation like MinimumClearance TopSecret
10:36:29 <catern> ertes: interesting notion, I kind of like that
10:36:47 <NemesisD> so i'd want to reflect the constructor on the type level to the constructor in the value level
10:37:37 <catern> ertes: I guess you would reverse this to have data Passenger vehicle, and (Passenger (Key Vehicle)) (Passenger Vehicle)
10:38:02 <catern> would/could
10:38:15 <catern> and then passenger would be meaningful on its own...
10:38:25 <NemesisD> i guess i'm looking for DataKinds
10:38:58 <ertes> NemesisD: you might also be interested in the latest goodie: -XTypeInType
10:39:28 <ertes> it completely collapses all levels above values into a single type level
10:41:15 <ertes> however, communication between value and type level is still manual and ad-hoc
10:41:35 <catern> it's okay, I suppose, to always pass Passengers around with also Vehicles. the thing that I want to prevent, I guess, is partnering a Passenger with the wrong Vehicle... I suppose I could just make a PassengerVehicle type
10:41:53 <ertes> there are two major approaches: reflection (a.k.a. implicit configurations) and singletons
10:42:08 <ertes> you probably need the latter, because the former does not support type-level functions
10:42:20 <flxw> byorgey: thank you for the semigroupoids url. After pondering about the types for a while, I learnt that <.> does the trick. :)
10:46:42 <NemesisD> ertes: so i've got data Clearance = TopSecret | None, data MinClearance (clearance :: Clearance) ,  is it actually possible to write reflectMinClearance :: MinClearance clearance -> Clearance ?
10:48:02 <kmelva> is ZuriHac free to attend?
10:48:13 <kmelva> looking at the site there's no mention of admission price...
10:49:10 <johnw> kmelva: I'm pretty sure it's a hackathon, open to all, rather than an admissions-based conference
10:49:20 <flxw> when a functor description says "lax monoidal functor", the lax is concerned with the monoid part, and saying that the monoid laws are not valid upto equality, but just upto natural isomorphisms. Do I get this right?
10:49:22 <johnw> (for example, Compose)
10:50:04 <kmelva> johnw: ah cool, I just figured it was a regular conference where you have to pay for admission... never thought about going because I figured it would be too expensive :/
10:50:16 <johnw> flxw: https://en.wikipedia.org/wiki/Monoidal_functor
10:50:24 <dolio> flxw: Sort of. But there's no "monoid" exactly.
10:50:41 <flxw> because it is a tensor product?
10:50:59 <dolio> It's about 'preservation' of monoidal category structure being directional.
10:51:08 <dolio> And not up to equality.
10:51:38 <dolio> And not even up to isomorphism, actually.
10:51:38 <flxw> okay, I'll read the hinted at url.
10:51:47 <flxw> I see. :)
10:53:44 <dolio> In general, I think 'lax' is used when you replace isomorphisms with transformations in one direction.
10:54:07 <dolio> And there's also 'oplax' sometimes for things that replace isomorphisms with transformations in the opposite direction.
10:59:36 <Younder> an isomorpism is by nature in both directions
11:00:08 <Younder> You might also call it a bijective transform
11:00:45 <Younder> or on to one and onto. The three are equivalent
11:02:49 <Younder> simulary you have a monmorphic transform which could also be called a projection
11:04:42 <Younder> Perhaps 'Introduction to Lattices and Order' by Davey and Priestley can help
11:05:52 <Tuplanolla> Help whom, Younder?
11:08:17 <Younder> Well when I was first introduced to Haskell I was overwhelmed by number of mathematical terms. So I found that my education lacked a few pointers. That book helped me understand the terminology and the frame of mind of a Haskeller better
11:21:08 <ertes> NemesisD: what should that function do?
11:21:53 <NemesisD> ertes: i found a workable solution, i wanted reflect from the reflection package and i just need to write reifies instances for the constructors i care about
11:28:56 <ertes> NemesisD: if you need to write Reifies instances by hand, you probably should just use singletons in the first place
11:29:31 <NemesisD> ertes: yeah its a matter of boilerplate vs transparency imo
11:29:51 <NemesisD> i reckon if i've only got a few constructors to deal with its fine for me to hand write the reifies instances
11:39:11 <ertes> NemesisD: the idea is that you shouldn't write Reifies instances except in certain cases, which are basically use cases of singletons
11:40:04 <NemesisD> ertes: what is the problem i'm creating here and avoiding with singletons TH? that i could screw up one of my 3 instances of Reifies or is it something else?
11:49:02 <johnw> NemesisD: you could also reify a Prism
11:49:44 <Younder> Tuplanolla, For the record what i said about monomorpism is completely wrong its is a transorm from a space A onto A. Not a projection.
11:51:09 <Younder> Tuplanolla, Unfortunately it is now on record forever.
11:51:25 <NemesisD> johnw: interesting, i'm not sure if you could contain this in a prism though since MinClearance TopSecret and MinClearance None are different types
12:04:00 <mnoonan> has anybody used the LibClang package before? when I try to use it in a project, I'm getting a ton of link errors of the form "undefined reference to `__c2hs_wrapped__clang_XXX`" and I'm not quite sure how to debug further.
12:05:21 <flxw> dolio: Hmm, a question on terminology. I've grepped four texts on category theory for "lax" (Awodey, Wells, Pierce, Riehl) now, and had not a single hit. Is it, because lax monoidal categories are a more advanced concept, or that different groups call it differently?
12:07:11 <mnoonan> flwx: it's a notion from higher category theory, so I wouldn't be shocked if it was omitted from intro texts
12:09:21 <flxw> mnoonan: aha, I see. okay, then it's not for me for the time being ...
12:10:33 <flxw> (just for completeness sake: yes, the searched books are all on basic category theory)
12:15:02 <dmwit> flxw: You might like to look it up in ncatlab.
12:15:53 <dmwit> https://www.google.com/search?q=lax%20site%3Ancatlab.org has a few hits that look relevant
12:17:01 <dmwit> (Though beware that ncatlab does not try very hard to cater to beginners.)
12:19:18 <Tuplanolla> I can't figure out how to write the `bracket2` analogue (http://lpaste.net/352987) of `allocate` (https://hackage.haskell.org/package/resourcet/docs/Control-Monad-Trans-Resource.html).
12:19:49 <Tuplanolla> It seems that `Control.Monad.Trans.Resource.Internal` doesn't expose all the internal things.
12:20:26 <flxw> dmwit: thanks alot for the pointers. beginner friendly: yeah, I am seeing this just now. :)
12:26:20 <Tuplanolla> Maybe I don't need to...
12:35:11 <flxw> fmap acts on the second component of a pair. Is there a instance of fmap for (,) which acts on the first one? (Right now I'm doing swap twice)
12:36:00 <Tuplanolla> Well, `bimap f id`, but...
12:36:12 <opqdonut> flxw: it can't, because functor is parameterized on the last type variable
12:36:27 <robkennedy> There are things called Bifunctors which have that property. Overloading instances are not generally good
12:36:47 <kuribas> is it possible to break in ghci when a condition is met?
12:37:07 <opqdonut> I'd use a lens, or Control.Arrow.first
12:37:16 <Forkk> Maybe I'm being stupid here, because I feel like this should be obvious, but I can't figure out how to get a Ptr from a ForeignPtr
12:37:22 <Forkk> is there some function to do that or something?
12:37:26 <MarcelineVQ> kuribas: yus https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#the-ghci-debugger
12:37:38 <EvanR> Forkk: right
12:37:38 <ski> @hoogle withForeignPtr
12:37:38 <lambdabot> Foreign.ForeignPtr withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
12:37:39 <lambdabot> Foreign.ForeignPtr.Safe withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
12:37:39 <lambdabot> Foreign.ForeignPtr.Safe.Compat withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
12:37:50 <EvanR> the dox
12:38:06 <Forkk> that's why I said maybe I'm being stupid :P
12:38:10 <Forkk> because it turns out I was lol
12:38:28 <ski> @type ContT . Foreign.ForeignPtr.withForeignPtr
12:38:31 <lambdabot> GHC.ForeignPtr.ForeignPtr a -> ContT r IO (GHC.Ptr.Ptr a)
12:38:46 <kuribas> MarcelineVQ: sorry, but I don't see how to break on a condition...
12:39:02 <Forkk> I have no idea how I didn't see that function in the docs
12:39:22 <flxw> opqdonut: oh, because the type is partially applied, and the type variables are in order a b, so a is fix in (a,b), yes?  
12:39:58 <mauke> flxw: yes
12:40:20 <flxw> cool, again what learnt.
12:40:44 <ski> `(,) a' is an instance of `Functor'
12:40:52 <chreekat> I'm using +RTS -xc to look at some traces, and some of the entries end with a backslash, for instance "Stack.Build.build.\" . What does that mean?
12:40:59 <kuribas> MarcelineVQ: only at a particular line or function.
12:41:10 <mauke> I see your English is one wall free
12:41:15 <ski> one can't write `\a -> (a,b)' as a type to be an instance of `Functor'
12:41:53 <chreekat> Oh, I can answer my own question. It's a lambda.
12:44:39 <Zemyla> Why is Proxy not a MonadFix?
12:45:28 <Zemyla> instance MonadFix Proxy where mfix _ = Proxy
12:45:39 <Zemyla> Seems like the simplest thing in the world.
12:45:54 <MarcelineVQ> kuribas: Ah hmm, you'll need to make the conditon a branch of the code you're examining I guess. I suppose there isn't global state to ask about so conditions only make sense in context
12:46:10 <c_wraith> Zemyla, submit it to the libraries list. (some people will argue about strictness properties, probably) 
12:46:48 <kuribas> MarcelineVQ: well, something like "myVar > 20" or so...
12:47:51 <kuribas> MarcelineVQ: I could of course trigger an exception when the condition occurs, then break on the exception...
12:51:38 <ski> > undefined >>= return :: Proxy ()
12:51:42 <lambdabot>  Proxy
13:14:51 <danilo2_> Hi! :) I've got not a very popular use case here, however, I'm wondering if is it possible to re-export in a module constructors but not their types? I've got data Foo = A | B and I want a module to re-export A and B but not Foo
13:15:19 <EvanR> how would people write type signatures...
13:15:35 <danilo2_> EvanR: By importing the original module
13:16:40 <danilo2_> EvanR: the datatype is in module M1 and I want M2 to re-export only constructors if its possible.
13:18:52 <ski> did you try only listing the data constructors ?
13:21:28 <danilo2_> ski: Right, I was somehow mid-closed to reexporting things like module ... (module X) where import M1 (Foo(...)) as X, but right, listening constructors explicitly would do the trick. by the way, im not using it in any prodution code, I was just wondering if ist possible not seeing a simple solution
13:21:35 <danilo2_> *mind-closed
13:25:46 <EvanR> I don't think parsec can't let you resume in the middle with more input. But can it at least give you the remaining input after a successful parse?
13:40:01 <srhb> EvanR: getInput is a parser that just consumes everything,
13:40:48 <srhb> EvanR: (You could use setInput to continue with something else)
13:41:25 <EvanR> interesting
13:41:48 <EvanR> though would be nicer to have that in the external interface than in the DSL
13:44:46 <user1872> Hey! I've been using haskell for a while, but I've only just heard people throw "strict haskell" around. The only thing I can find on the topic is the strict pragma, but I feel like they're talking about something more than just the pragma
13:45:25 <user1872> do you all know of any good tutorials or descriptions of strict haskell and how to structure your code so that it's not lazy?
13:46:12 <monochrom> It is just the pragmas (there are two) and reading the GHC user's guide.
13:47:50 <user1872> Great! I wasn't sure if I was missing something. thanks
14:08:04 <EvanR> is a thread doing a ByteString copy interruptible
14:10:20 <dolio> Doubt it.
14:11:34 <dmwit> EvanR: If it exists in the DSL, you can implement the out-of-DSL function on top. But not vice versa.
14:11:55 <dmwit> EvanR: (re: the question about getting the rest of input after a successful parse)
14:13:02 <dolio> Yeah, bytestring imports memcpy as an unsafe ccall, and uses that for copying things.
14:13:16 <dolio> So I think it can't be interrupted.
14:40:30 <mtjmullen> Does a Free Monad have a valid Semigroup instance?
14:40:48 <mtjmullen> The free package doesn't have an instance for it
14:42:24 <fresheyeball> I have a simple task, take two lists and make a list of tuples with a book for matches
14:42:41 <fresheyeball> something like this
14:42:58 <fresheyeball> tagMatches :: [a] -> [a] -> [(a, Bool)]
14:43:05 <fresheyeball> such that
14:43:22 <glguy> mtjmullen: Free has an Alternative instance, so you can wrap it with Data.Monoid.Alt and get a Semigroup instance of that
14:43:41 <fresheyeball> tagMatches [1,2,3] [2,4] = [(1,False),(2,True),(3,False)]
14:43:53 <glguy> or if we had the Data.Monoid.App (Applicative instead of Alternative) you could use that
14:44:12 <fresheyeball> what I want to avoid is inefficient code
14:45:26 <Cale> mtjmullen: An arbitrary monad applied to a semigroup can be given a semigroup instance with (<>) = liftM2 (<>)
14:45:29 <mtjmullen> glguy: I should be more specific: I would like to lift a semigroup instance to Free
14:45:46 <glguy> mtjmullen: I don't know what that means
14:45:57 <Cale> (but the way type classes work, you have to do this for each monad)
14:46:06 <mtjmullen> So if I have a (Free f a), and a forms a semigroup, can I have (Free f a) be a semigroup by deferring to the semigroup on a
14:46:33 <glguy> mtjmullen: That's the hypothetical Data.Monoid.App case I mentioned above
14:46:34 <Cale> instance Semigroup a => Semigroup (Free f a) where (<>) = liftM2 (<>)
14:46:45 <glguy> You don't need a Monad for that, an Applicative will do
14:46:51 <Cale> Sure
14:47:04 <mtjmullen> That's what I thought, I was surprised the free package didn't have it
14:47:51 <mtjmullen> I guess they want you to use the Alt instance
14:48:29 <mtjmullen> sorry, Data.Monoid.App instance
15:07:51 <markholmes> is there a way to stop an infinite list from printing
15:07:58 <markholmes> in ghci
15:08:01 <markholmes> ... :)
15:08:05 <dmwit> fresheyeball: Make a `Set` and use `Data.Set.member` or `Data.Set.elem` or whatever it's called.
15:08:12 <markholmes> ctrl + c and ctrl + z do not work
15:08:30 <dmwit> markholmes: Hm. They work here.
15:08:44 <dmwit> markholmes: Perhaps you will like to become acquainted with `kill`. =)
15:09:13 <markholmes> i'm assuming it's an issue with git bash on windows
15:09:16 <markholmes> :/
15:09:39 <markholmes> thanks
15:10:25 <dmwit> fresheyeball: What have you tried so far?
15:13:29 <dmwit> markholmes: You could also try ctrl+q
15:13:47 <dmwit> Whoops, ctrl+q is resume. I meant ctrl+s
15:14:06 <mauke> on windows?
15:14:11 <glguy> When I have a run-away GHCi, I use Ctrl+Z and then kill -9 %1
15:14:15 <dmwit> Well, if he's in bash...
15:14:28 <dmwit> Presumably he has some kind of terminal emulation.
15:14:30 <mauke> ^S/^Q is a terminal thing, not shell
15:14:37 <dmwit> I am aware.
15:14:42 <mauke> ah
15:14:42 <markholmes> yeah, it's git bash
15:15:33 <markholmes> ctrl + s pauses it
15:15:51 <dmwit> Right. That should give you enough time to use some other tool to do something to ghci.
15:16:03 <markholmes> and then ctrl + z exits ghci
15:16:09 <markholmes> cool, thanks
15:17:52 <markholmes> oops, they were still running in the background. each one (i did it twice) was taking up 30% of my cpu
15:18:01 <markholmes> according to task manager
15:18:06 <dmwit> Yes, you can't forget the second half of glguy's workflow. =)
15:24:43 <geekosaur> on windows I'd expect c-z to exit, on unix it means suspend and will still be running
15:25:21 <Koterpillar> On Windows, Ctrl-Z is EOF
15:27:13 <marvin2> my windows ghci must be special.. it exists on C-d
15:27:21 <marvin2> exits
15:27:55 <AndreasK> In what shell
15:28:06 <marvin2> just tried in both cmd.exe and powershell
15:28:34 <AndreasK> actually it does for me as well
15:29:51 <geekosaur> that doesn't surprise me, haskeline likely supports both on windows
15:30:05 <geekosaur> what I would *not* expect is c-z on windows somehow suspending the ghci
15:30:49 <geekosaur> the way glguy described for unix
15:33:34 <ezyang> Haskell, I am braining right now. If A <: B, and A <: C, and it's the "best" choice, is that a greatest upper bound or a lowest upper bound 
15:33:49 <ezyang> erm, greatest lower bound, I mean 
15:34:13 <lyxia> looks like a glb
15:34:22 <lyxia> A is "lower" than B and C
15:34:27 <ezyang> ok thanks 
15:50:21 <Squarism> Ive isolated an "interface" from my threading code that isolates all interaction with the actual game. It looks as if i could make this interface "generic" as of 2 type parameters. Its just that i dont really know what is the best/easiest approach? Using generics? Using type classes? In this ( http://lpaste.net/353114 ) ive marked the 2 types that i want to parameterize with "a" and "b" and. Basically "a" == To game message, "b" == to client message. 
15:50:43 <ezyang> generics are definitely not what you want 
15:50:58 <ezyang> type classes could work, assuming that it is always obvious what the type parameter is 
15:50:58 <Squarism> oh ok?
15:51:16 <ezyang> you might also consider using an associated type, to reduce the number of type parameters you need 
15:51:36 <ezyang> if it is always the case that to game message uniquely determines to client message 
15:51:49 <Squarism> ezyang, well its completely deterimined by the createGameSetupAdapter call
15:52:26 <ezyang> this produces some adapter type? 
15:52:35 <Squarism> yep
15:52:42 <Squarism> that is parameterized by the type
15:52:50 <Squarism> (for that particular game)
15:53:04 <ezyang> so you could, say, define a separate adapter type per game 
15:53:15 <ezyang> and then have associated types declaring the game and client message types 
15:54:20 <Squarism> would that work even if above code would be "3rd" party? 
15:54:30 <Squarism> in a lib of its own
15:54:31 <ezyang> yes 
15:54:39 <ezyang> the third party defines the adapter type, and then writes an instance for it 
15:54:57 <ezyang> btw, the biggest problem you might run into with this scheme is convincing GHC to specialize the dictionaries away 
15:55:02 <ezyang> if it can't manage it, you might pay perf tax 
15:56:48 <Squarism> ezyang, im not very experianced in haskell. Im not sure i really understand what you mean by "define a separate adapter type per game , and then have associated types declaring the game and client message types"
15:57:05 <Squarism> is its something you could just sketch in lpaste?
15:57:43 <Squarism> ive written 1 type class
15:59:37 <ezyang> maybe https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/type-families-and-pokemon will help 
15:59:42 <ezyang> (haven't read) 
16:00:56 <markh> update to my windows infinite list issue: i switch over to my linux VM. much better
16:08:58 <Zemyla> There should be a type class for values e for which ((->) e) is Traversable.
16:12:48 <mpickering> Did manual documentation upload to hackage change at some point?
16:12:55 <mpickering> the script I used to use no longer works
16:15:25 <mpickering> oh I seem to be able to use cabal upload --documentation now
16:15:30 <mpickering> what an innovation
16:26:12 <lambdafan> I'm trying to do this : (Monad m) => a -> m b -> m (a -> b)
16:26:39 <Koterpillar> lambdafan: did you forget some brackets somewhere?
16:29:29 <c_wraith> it's not implementable with the missing parens. it is implementable like that. 
16:29:40 <c_wraith> though only trivially. 
16:30:57 <Koterpillar> oh, right
16:31:04 <Koterpillar> but doesn't look interesting either way
16:32:49 <lambdafan> (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c 
16:33:00 <lambdafan> I'm using this operator
16:33:07 <lambdafan> I have two monadic actions
16:33:12 <lambdafan> and I end up with 
16:33:37 <lambdafan> Monad m => a -> m c
16:34:01 <lambdafan> but I'd like a m (a -> c)
16:34:06 <c_wraith> that's what the type requires 
16:34:13 <c_wraith> that's impossible 
16:34:21 <marvin2> is it?
16:34:47 <c_wraith> except for specific trivial monads like identity, yes
16:35:14 <Koterpillar> lambdafan: consider this value: \v -> if v then putStrLn("Was true!") else return ()
16:35:51 <Koterpillar> lambdafan: that's Bool -> IO (). If you get an IO (Bool -> ()) out of it, what would that do?
16:36:10 <lambdafan> ah that makes no sense
16:36:13 <c_wraith> marvin2, if it wasn't impossible, Applicative and Monad would be the same thing
16:37:11 <monochrom> Nice example, Koterpillar.
16:38:39 <c_wraith> Koterpillar, yes, that really is an excellent illustration. 
16:39:13 <Koterpillar> well, I was confused in the first place <_<
16:39:30 <c_wraith> you recovered well. :) 
17:06:02 <michalrus> > let 1 = 2 in 3
17:06:07 <lambdabot>  3
17:06:24 <michalrus> Could anyone point me to some resources on why the above compiles? (:
17:06:39 <Koterpillar> > let 1 = 2 in 1
17:06:43 <lambdabot>  1
17:06:46 <michalrus> Noes. :p
17:06:52 <michalrus> There’s something weird going on.
17:06:54 <michalrus> Also:
17:06:59 <michalrus> > let 1 = "blah" in 2
17:07:03 <lambdabot>  error:
17:07:04 <lambdabot>      • Could not deduce (Num [Char]) arising from the literal ‘1’
17:07:04 <lambdabot>        from the context: Num t
17:07:36 <Koterpillar> > 2 where 1 = 3
17:07:39 <lambdabot>  <hint>:1:3: error: parse error on input ‘where’
17:08:02 <Koterpillar> > let f = 2 where 1 = 3 in f
17:08:05 <lambdabot>  2
17:13:00 <Squarism> is there some way to have ghc tell me about pointless imports?
17:13:09 <Squarism> ...stuff that isnt used that is
17:13:42 <Forkk> so haskell seems to be freeing all my foreign pointers when they're still in scope
17:13:53 <Forkk> I don't understand how this is possible
17:14:02 <RasmusWL> has the synopsis overview from hoogle been removed?
17:15:32 <Forkk> well I found the problem. had the line `fptr <- newForeignPtr code_free cptr` twice :|
17:15:49 <Forkk> oops
17:46:23 <jle`> michalrus: are you familiar with how pattern matching works?
17:46:57 <jle`> michalrus: you can match on numeric literals
17:47:13 <Forkk> yeah but shouldn't let 1 = 2 in 1 cause a match failure
17:47:19 <Forkk> since 1 isn't 2
17:47:32 <pikajude> no
17:47:34 <pikajude> because 1 matches 1
17:47:40 <jle`> > let Nothing = Just 10 in "hello"
17:47:43 <lambdabot>  "hello"
17:47:46 <Forkk> what
17:47:50 <Forkk> why does that happen
17:47:51 <jle`> match failures are only checked if you use what is inside
17:47:58 <jle`> > let Just x = Nothing in "hello"
17:48:01 <lambdabot>  "hello"
17:48:08 <jle`> > let Just x = Nothing in x
17:48:10 <lambdabot>  *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Just x
17:48:12 <jle`> ^ Forkk, michalrus 
17:48:15 <Forkk> interesting
17:48:20 <jle`> pattern matching is lazy
17:48:29 <jle`> the match is only resolved if any bindings inside are needed
17:48:46 <jle`> so let Just x = Nothing in "hello" doesn't actually do the pattern matching unless x is needed
17:49:16 <jle`> in let 1 = 2 in 3, there are no bindings generated in the pattern match '1 = 2', so nothing really can happen
17:49:34 <jle`> if '1 = 2' created a binding like 'Just x = Nothing' does, then if you evaluated it, you'd get problems
17:49:44 <jle`> but no bindings, no way to really cause any problems
17:50:09 <nshepperd_> let bindings are lazy. Pattern matching in a case is strict
17:50:29 <jle`> 1 = 2 is a bit of a silly pattern match but there's no reason to explicitly disallow it, since it's consistent with haskell pattern matching/let binding syntax
17:50:33 <Forkk> > case Just 1 of Nothing -> 0
17:50:36 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
17:50:44 <jle`> yes, sorry, should have clarified
17:52:19 <sveit> is there an "idiomatic" (i have a solution using explicit recursion) way to produce the list [0 (a0 times), 1, 0 (a1 - a0 - 1 times), 1, 0 (a2 - a1 - 1 times),...] given the list [a0, a1, a2, ...] of ascending integers? Preferably something that fuses well
17:52:58 <jle`> can you give example inputs/outputs?
17:53:09 <sveit> so for example the list [1,3,4] should produce [0,1,0,1,1]
17:53:28 <angerman> can someone recommend some th heavy library? I'd like to try some th compilation.
17:53:41 <angerman> E.g. some library that uses a lot of th.
17:54:04 <hpc> uses, or would just providing definitions work?
17:54:42 <sveit> what i really want to do is, for some N, take N (repeat 0) and for each index in some input list (i.e. [1,3,4]) replace 0 with 1
17:55:37 <sveit> this seems like a "fusable" operation, so i'd like something that is likely to fuse if possible (i.e. efficient)
17:59:00 <kadoban> sveit: What are you using it for after that? That seems like a fairly questionable operation on its own, adding a lot of ... stuff around not much data
18:01:23 <angerman> hpc: uses, or e.g. makes ghc have to compile th. 
18:01:23 <sveit> kadoban: this is actually a minimal example. in my particular application the objects are more complicated than integers and the list gets folded at the end. i can give a less trivial example if that would somehow help. the conceptual idea is to, without explicit recursion, emulate a sequence of while loops
18:08:53 <kadoban> sveit: Hmm, I'm not sure I'm following you. I just know that when I notice myself doing that type of thing, I'm often better off just ... not doing that transformation unless I'm really forced to by subsequent needs.
18:10:22 <kadoban> Possibly not a helpful comment, since it sounds like you have a solid goal in mind that I don't quite understand.
18:12:46 <sveit> kadoban: here is a less minimal example. suppose i want to create a path on a square lattice by moving up and right (so a list of data Steps = Up | Right) to process later. This is a list like [Up, Right, Up, Up, ...]. A compact way to represent such a path is by a list of ascending integers, where each integer tells you where to take a "Right" step. So [1,3,4] represents the path [Up, Right, Up, Right, Right, Up, ...]. I want to run a
18:12:46 <sveit> fold over the latter list. The question is how to efficiently convert [1,3,4] to the list of steps.
18:15:34 <Squarism> it seems my hunit test suite cannot access parts of my lib that isnt in "exposed-modules" in my cabal file. Is that how its supposed to work?
18:15:50 <Squarism> (i hoped test suite had special priviliges)
18:26:45 <kadoban> sveit: concat . concatMap ((\x -> [x, [Right]]) . (flip replicate Up) . max 0 . pred) $ zipWith (-) xs (0:xs) -- or explicitly recursive is the best I can come up with, but neither looks particularly great
18:30:30 <sveit> hmm. thanks. do you think i should just prefer explicit recursion to a stack of functions like that?
18:32:29 <sveit> i mean specifically for efficiency. it looks like lots of concatenations on lists will be happening
18:35:42 <kadoban> Not sure, the explicit recursive one is probably a bit faster when it matters. But if the lists are going to be long enough for it to matter, maybe there's a better way to do this than explicitly building the list?
18:52:04 <sveit> generating the list explicitly isn't so bad. i'm actually a bit surprised there isn't a lens that lets me get/set multiple list elements at once
18:52:33 <jchia> There are different schemes to compress data and they can be combined in different ways. e.g. I may apply difference encoding, followed by RLE, followed by huffman encoding. Given an input stream with known fixed-record structure, I may also choose split out different parts of the records and compress them differently. Is there a library the provides compression and decompression algorithms as combinators that I can easily connect together?
18:53:21 <kadoban> sveit: It's quite possible that there is and I just don't know it.
18:53:31 <peddie> jchia: I don't know of one, but if you find one, please tell me -- I've wanted this too
18:54:03 <jchia> peddie: If I have time, I'll try to make one, but I think it won't be anytime soon.
18:54:20 <peddie> jchia: that's what I concluded too :)  good luck
18:56:40 <jchia> peddie: I wonder if binary can be used for this. You can wrap a ByteStream in a newtype that determines the kind of encoding you apply when you compress. Splitting up the input stream is another matter, though.
18:56:50 <jchia> peddie: I man ByteString
18:56:53 <jchia> mean
18:57:42 <peddie> jchia: I don't see any reason that wouldn't work
19:06:52 <_sras_> Weird "stack build" behavior. says "File name does not match module name. Saw B. Expected A.B", and when I change it to A.B it says "Saw A.B. Expected A". Why does this happen?
19:07:28 <Koterpillar> what is the file name, relative to the cabal file?
19:08:14 <_sras_> the file is in a folder "src/Config/AbcConfig.hs"
19:08:40 <_sras_> Koterpillar: Sorry. The filename is "src/Config/AbcConfig.hs"
19:09:15 <_sras_> Koterpillar: I have added the "src/Config" to the list of source directories.
19:09:30 <pikajude> do you import it from other places
19:09:55 <geekosaur> that may be the problem; if you call the module Config.AbcConfig then you want the source directory to be src not src/Config
19:10:22 <_sras_> pikajude: Yes. From a module in src folder.
19:10:48 <pikajude> if you have src and a subfolder of src both listed as source directories it will confuse GHC
19:11:13 <_sras_> pikajude: Ok. So how should it be. Just the "src" folder?
19:11:18 <pikajude> yeah
19:11:35 <pikajude> what happens is that both Config.Foo and Foo become valid names for the module but which one the compiler actually expects depends on how it's imported from other modules
19:11:42 <pikajude> so best just to use src
19:13:45 <_sras_> pikajude: But now it says "failed to load interface for module"...
19:14:01 <pikajude> whenever i see those errors i usually run a clean and try again
19:20:18 <Squarism> can one see haddock docs in ghci?
19:20:30 <monochrom> No.
19:21:28 <pikajude> ghci would need to be a fully fledged browser then
19:21:34 <pikajude> or at least a pdf viewer
19:22:17 <peddie> it would be cool to be able to get docstrings of some kind in ghci
19:22:33 <pikajude> well they'd have to be added to the object files
19:22:53 <peddie> yes
19:25:26 <_sras_> pikajude: It worked. Thanks.
19:40:35 <Costar> what mean "type Example a" inside a class using TypeFamilies?
20:01:32 <c_wraith> Costar, it defines a type family named example that's associated with the class. 
20:01:52 <c_wraith> Costar, also called an associated type 
20:02:11 <c_wraith> Costar, if you're familiar with rust, they took that feature wholesale 
20:02:30 <Costar> c_wraith: it is like a "function of types"?
20:02:47 <c_wraith> Costar, type families in general are fun cti
20:02:53 <c_wraith> .. functions on types 
20:03:01 <Costar> yeah
20:03:04 <c_wraith> associated types  
20:03:16 <c_wraith> ... I'm having operator issues. :) 
20:03:51 <c_wraith> associated types are just defined as part of a class and it's instances, but are exactly as powerful 
20:04:21 <Costar> c_wraith: they are used just to enhace type safety?
20:04:44 <c_wraith> Costar, no. they're used to expand the capability of of type classes. 
20:05:31 <c_wraith> multiparameter type classes with functional dependencies give you similar power, but feel much more like prolog than writing functions. 
20:06:09 <jle`> Costar: when you write a typeclass instance, you get to implement its methods
20:06:22 <Costar> c_wraith: I havent dig this part of Haskell deeply
20:06:23 <jle`> Costar: if the typeclass has an associated type, you also give the associated type
20:06:29 <jle`> it's just another "part" of the typeclass
20:07:40 <jle`> typeclasses let you define functions/values/types for each instance
20:07:41 <mniip> prolog is much more powerful than mptcs anyway
20:07:45 <c_wraith> Costar, https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/typefun.pdf gives a bunch of good examples 
20:08:01 <Costar> c_wraith jle` thank you guys
20:08:12 <c_wraith> Costar, and it's very easy to read, even though it's an academic paper. :) 
20:09:32 <Costar> c_wraith: I was reading about HLearn, and the guy defined a "type Ring a" inside a class
20:09:40 <Costar> c_wraith: now its clear
20:10:35 <Costar> jle`: i know the basics of typeclasses, but i fail in typefamilies.
20:11:18 <jle`> you don't really have to know about type families in general to use associated types, i think
20:11:22 <jle`> class Foo a where
20:11:32 <jle`>     type Bar a
20:11:43 <jle`>     bar :: a -> Int
20:11:59 <jle`> so if you write an instance of 'Foo', you provide an implementation of 'bar' (the function) and also of 'Bar' (the associated type
20:12:10 <jle`> instance Foo String where
20:12:14 <jle`>     type Bar String = Bool
20:12:16 <jle`>     bar = id
20:12:18 <jle`> ta dah
20:12:21 <jle`> that's it :)
20:12:33 <jle`> s/id/length
20:13:12 <Costar> jle`: nice example, thanks.
20:41:47 <jle`> no problem!
21:02:20 <threshold> num <- newEmptyMVar ; forkIO (putMVar num 3) -- No instance for (Num GHC.Prim.Any) arising from the literal ‘3’ In the second argument of ‘putMVar’, namely ‘3’
21:03:09 <c_wraith> is that from an old version of ghci? 
21:03:52 <threshold> 8.0.1
21:04:07 <c_wraith> ah, but it is ghci? 
21:04:13 <threshold> c_wraith: yeah
21:04:26 <c_wraith> ghci doesn't get global inference. 
21:04:27 <mniip> I could see where that's coming from
21:04:33 <mniip> ah right
21:04:42 <mniip> "num <- newEmptyMVar"
21:04:45 <c_wraith> yep. 
21:04:51 <mniip> by that poiny num :: MVar Any
21:04:54 <mniip> point*
21:05:34 <threshold> I started guessing ways around this, but I wish that didn't occur. forkIO (putMVar num 3 :: Int)
21:05:42 <threshold> That didn't work
21:05:44 <glguy> does it help to add a do to the beginning?
21:06:21 <mniip> threshold, no like, if the two are different statements, the 'num' is bound with a wrong type already
21:06:41 <c_wraith> threshold, newEmptyMVar :: IO (MVar Int) 
21:07:11 <mniip> if ghci could go back and reinfer 'num' as MVar Integer when you typed the second line...
21:07:16 <mniip> well nothing would make sense then
21:07:29 <c_wraith> threshold, the problem is that ghci wasn't implemented to read from the future to infer types. 
21:07:34 <threshold> c_wraith: that did the trick
21:07:40 <mniip> although
21:07:48 <mniip> it could go with 'forall a. MVar a'
21:07:52 <mniip> but that's unsafeCoerce right there
21:08:31 <c_wraith> if ghci could just tell the future when type checking... so much easier. 
21:08:53 <mniip> this issue could be avoided with representing mvars as actual sources/sinks
21:08:59 <mniip> but yeah, future reading
21:09:04 <mniip> I hear that's planned for 8.3
21:09:52 <monochrom> "The future is always brighter"
21:10:28 <c_wraith> I think glguy's suggestion should work, though. 
21:10:32 <mniip> a monotonic function huh
21:10:56 <c_wraith> since it makes the two statements a single expression, so they're all type-checked together. 
21:11:23 <monochrom> Then you need your own "return num" so you don't lose it.
21:11:37 <c_wraith> that's true. 
21:11:47 <monochrom> In fact the whole "num <- do { num <- ... ...  return num }"
21:12:14 <mniip> monochrom, but wait, it is brighter in whose frame of reference? What if we have a ghci moving relative to another ghci at 0.5c?
21:12:43 <threshold> let terrible = do num <- newEmptyMVar :: IO (MVar Int) ; forkIO (putMVar num 3) ; forkIO (putMVar num 4) ; v <- takeMVar num ; return v in iterate (print . terrible) 50000
21:12:53 <threshold> > let terrible = do num <- newEmptyMVar :: IO (MVar Int) ; forkIO (putMVar num 3) ; forkIO (putMVar num 4) ; v <- takeMVar num ; return v in iterate (print . terrible) 50000
21:12:56 <lambdabot>  error:
21:12:56 <lambdabot>      Not in scope: type constructor or class ‘MVar’
21:13:12 <mniip> you can't do that
21:13:32 <threshold> mniip: The compiler agrees
21:13:42 <mniip> iterate is not the function you're looking for
21:13:51 <mniip> :t replicateM_
21:13:53 <lambdabot> Applicative m => Int -> m a -> m ()
21:14:00 <mniip> that's what you're looking fo
21:14:08 <mniip> also <$> not .
21:14:32 <monochrom> No, . won't do either
21:14:40 <mniip> that's what I said!
21:14:54 <monochrom> Ah. No, <$> won't do either.
21:15:37 <mniip> terrible :: IO Int
21:15:39 <mniip> lgtm?
21:15:51 <monochrom> @type print
21:15:53 <lambdabot> Show a => a -> IO ()
21:16:01 <monochrom> @type print . (undefined :: IO Int)
21:16:07 <lambdabot> error:
21:16:07 <lambdabot>     • Couldn't match expected type ‘a -> ()’ with actual type ‘IO Int’
21:16:07 <lambdabot>     • In the second argument of ‘(.)’, namely ‘(undefined :: IO Int)’
21:16:15 <monochrom> Sigh, I keep saying the wrong guy.
21:16:19 <monochrom> @type print <$> (undefined :: IO Int)
21:16:25 <lambdabot> IO (IO ())
21:16:46 <monochrom> Is that what you want? In fact...
21:16:54 <monochrom> @type replicateM_ 10 (print <$> (undefined :: IO Int))
21:16:56 <lambdabot> IO ()
21:17:50 <monochrom> OK, I guess that isn't informative.
21:17:56 <threshold> getNum = do num <- newEmptyMVar :: IO (MVar Int) ; forkIO (putMVar num 3) ; forkIO (putMVar num 4) ; v <- takeMVar num ; return v ; main = do nums <- replicateM 50000 getNum ; mapM_ print nums
21:17:56 <monochrom> This is the job of =<<
21:19:49 <threshold> Is there a common function similar to print which prints without attaching a new line?
21:19:55 <threshold> e.g. putStr
21:20:11 <monochrom> No, but you can combine "show" and "putStr"
21:20:47 <threshold> Thanks monochrom 
21:20:50 <threshold> That worked
21:24:27 <mniip> oh
21:24:35 <mniip> oops
21:24:37 <mniip> right
21:24:39 <mniip> >>=
21:24:43 <mniip> Ls
21:24:45 <mniip> :s *
21:28:44 <jle`> hi
21:28:51 <jle`> will Profunctor ever be in base?
21:29:24 <jle`> i'm reading https://www.reddit.com/r/haskell/comments/3kbj9r/edward_kmett_the_unreasonable_effectiveness_of/cuwucle/ but i don't really see the real issue
21:31:46 <mniip> jle`, well you can see why being able to rewrite 'fmap coerce' into 'coerce' is a good idea?
21:32:11 <jle`> i do
21:32:29 <mniip> and how that is fairly tricky to do without adding unsafety
21:33:30 <jle`> how does profunctor cause complications in that?
21:34:05 <mniip> I think ed deems profunctor useless without #./.#
21:34:11 <mniip> and he wants a more uniform interface?
21:34:41 <c_wraith> not useless
21:34:52 <threshold> Is this the package I need to install in order to use LVars?
21:34:54 <c_wraith> just a massive performance regression
21:35:04 <threshold> Ivar
21:35:25 <mniip> well
21:35:25 <mniip> sure
21:35:36 <mniip> #. can be implemented in terms of rmap
21:35:41 <mniip> but that's "useless"
21:36:42 <jle`> why not have #./.# in base?
21:36:50 <jle`> i mean, in a hypthetical base Profunctor
21:37:30 <mniip> 1488432829 [08:33:49] <mniip> and he wants a more uniform interface?
21:37:34 <c_wraith> because they're not good enough for general use
21:37:45 <c_wraith> They're good enough for lens, but not things that use profunctors in other ways
21:37:54 <mniip> basiscally you'd want a similar function in Functor
21:37:57 <mniip> and Contravariant
21:38:01 <mniip> but
21:38:04 <mniip> more "general"
21:39:01 <jle`> just having them there doesn't detract from their utility, does it?
21:39:05 <MarcelineVQ> threshold: is what the package?
21:39:06 <jle`> it might be ugly
21:40:02 <mniip> yeah but it means more changes later
21:40:13 <MarcelineVQ> threshold: IVar's are from monad-par afaik  http://hackage.haskell.org/package/monad-par  http://chimera.labs.oreilly.com/books/1230000000929/ch04.html
21:40:14 <mniip> you'd want something like this resolved before adding profunctor
22:02:55 <hrumph> what is the simplest possible monad
22:03:08 <barrucadu> Identity?
22:03:32 <hrumph> there's no null monad or anything like that?
22:04:55 <hrumph> https://gist.github.com/mikehadlow/795905
22:05:07 <hrumph> according to this web page the identity monad is the simplest
22:05:07 <hrumph> is that true?
22:06:16 <barrucadu> Well, it depends what you mean by "simple". Certainly I can't think of a monad I'd call simpler than Identity.
22:07:18 <barrucadu> There's also Proxy, that's pretty simple
22:07:34 <slack1256> I have problem understanding the traversable laws. If they are mean to be distributive functors over applicatives, how can I guarrante than a value won't be execute (applicative effects) twice?
22:08:05 <slack1256> Or should I stay with the intuition "distribution over applicative"?
22:09:43 <mniip> hrumph, what is the simplest monoid?
22:09:56 <hrumph> mniip don't know yet
22:10:08 <hrumph> wonderinf if tehre was something even simpler than identity like a "null monad"
22:10:12 <hrumph> not sure
22:10:26 <mniip> well, if you answer "the one with just one element", then by that token, Proxy is what you're looking for
22:11:26 <mniip> because that's the "null" object in the endofunctor category
22:13:17 <hrumph> mniip do you have a url for that?
22:14:15 <mniip> uhh
22:14:19 <mniip> afraid not
22:14:57 <mniip> I could link the Monad Proxy definition
22:15:10 <mniip> https://hackage.haskell.org/package/base-4.9.1.0/docs/src/Data.Proxy.html#line-98
22:16:17 <hrumph> ok
22:16:23 <hrumph> it's basically exactly what i thought
22:16:29 <hrumph> so that's the simplest monad
22:18:24 <Squarism> Im curious if you people working with haskell, studying it or play with it for fun?
22:21:33 <atian> Squarism i smoke it
22:23:39 <Squarism> fmap'ing the Bong-monad
22:24:04 <monochrom> I use Haskell and study it and play with it.
22:24:17 <monochrom> I don't think there is a need to choose one.
22:24:18 <atian> haskell strain
22:24:32 <atian> very good if you ask me
22:25:00 <Squarism> monochrom, ok 
22:25:07 <Squarism> im mostly curious if people use it for work I guess
22:25:28 <Squarism> The type you get paid for
22:26:28 <atian> Squarism have you considered doing stand up comedy
22:26:39 <monochrom> Haskell jobs are fewer. But people can still use it personally.
22:28:34 <monochrom> My job is teaching. And it is not teaching Haskell. But I used Haskell to write utilities and check answers. Haskell did help me earn my money efficiently.
22:29:51 <Squarism> Okey. Glad you found a way.
22:47:53 <effectfully_> Hi. `stack build` says "Warning: <blah> needs to be a dynamically linked executable; please     pass --enable-executable-dynamic to 'cabal install'.". What should I do?
23:25:28 <msko> account list
23:48:17 <effectfully_> Anybody?..
23:48:42 <markh> ?
23:48:50 <ezyang> try http://stackoverflow.com/questions/38863005/how-do-i-get-stack-to-use-dynamic-linking maybe 
23:50:00 <effectfully_> markh: `stack build` says "Warning: <blah> needs to be a dynamically linked executable; please     pass --enable-executable-dynamic to 'cabal install'.". What should I do?
23:50:11 <effectfully_> ezyang: I tried, but it doesn't seem to work
23:50:21 <effectfully_> I'm getting the same warning
23:50:28 <markh> have you tried cabal install --enable-executable-dynamic
23:51:15 <effectfully_> markh: I use Stack and this is Stack that tells me to do something with Cabal, which I have no idea what means
23:51:19 <ezyang> don't do that, he's using stack 
23:51:35 <ezyang> effectfully_: Which ghc-options did you add it to 
23:52:18 <effectfully_> ghc-options: -W <some_other_options> -dynamic
23:52:48 <ezyang> yes but which cabal file did ou add it to 
23:52:52 <ezyang> did you add it to the executable 
23:53:05 <effectfully_> yes
23:53:24 <ezyang> does the executable work or not 
23:54:00 <effectfully_> it worked when I manually copied the library it needs
23:54:35 <ezyang> see, with cabal-install, I know --enable-executable-dynamic will do the right thing 
23:54:46 <effectfully_> but the library is generated dynamically
23:54:52 <ezyang> maybe you are using https://github.com/commercialhaskell/stack/issues/1691 
23:54:55 <ezyang> *hitting 
23:55:12 <ezyang> Are you saying that stack is not setting an rpath 
23:56:07 <effectfully_> yes, I know that cabal is able to do what I want, but I have other problems with cabal
23:56:38 <ezyang> effectfully_: Have you tried using new-build? 
23:56:46 <ezyang> What do you mean by copy the library? 
23:57:01 <effectfully_> "is not setting an rpath" -- sorry, I don't understand
23:57:25 <effectfully_> no, I haven't tried, thanks for linking the issue
23:57:41 <ezyang> "What do you mean by copy the library?" 
23:57:56 <effectfully_> there are several packages, one of them generates a library, the other requires that library
23:58:19 <effectfully_> I see the error, manually copy the generated library to be on $PATH
23:58:22 <effectfully_> and things work
23:58:53 <ezyang> ...PATH or LD_LIBRARY_PATH 
23:58:55 <ezyang> are you on Windows? 
23:59:06 <effectfully_> no, Ubuntu
23:59:17 <ezyang> and what is "the error" 
23:59:24 <effectfully_> just $PATH, I think
