00:01:02 <sphinxo> Are there any tools to analyse the time complexity of (my) functions?
00:02:01 <sphinxo> oh looks like I can do something with criterion
00:03:55 <geekosaur> that's timing. "time complexity" sounds more like source analysis (but, good luck with that in a graph reduction language)
00:06:37 <nshepperd> you can estimate 'asymptotic' complexity by running your function on different inputs and fitting a function to it
00:18:06 <sphinxo> Does this function exist in the standard library? 
00:18:09 <sphinxo> substr s i j = [s !! x | x <- [i..j]]
00:24:24 <dmwit> sphinxo: No, but you can make it much more efficient: `substr s i j = take (j-i) . drop i $ s`.
00:26:15 <sphinxo> Thanks, that's cool
00:43:58 <NdaX404> Hi Everyone
00:53:19 <lehof> hello, I'm new to functional programming and I'm kind of stuck: http://rextester.com/SNOAR45047
00:53:41 <lehof> how would I print something inside the isprime function?
00:54:01 <lehof> I'm talking about line 10
00:54:42 <dmwit> lehof: You wouldn't.
00:54:47 <lehof> I would like to print n there and continue with executing check
00:55:03 <dmwit> If you want to print, you have to have an IO type.
00:55:12 <dmwit> No way* around it, I'm afraid.
00:55:23 <lehof> in imperative programming I would know how to get this done, but in Haskell I'm a bit confused
00:55:58 <lehof> but if isprime becomes an IO type, wouldn't that break the algorithm?
00:56:06 <lehof> check wants it to be a Bool
00:56:37 <dmwit> Something like this would do: `isprime :: Int -> IO Bool; isprime n = do print n; check n (n-1)`, then change `gameloop t = if t < 40 then do ip <- isprime t; if ip then do {- ... -} else {- ... -} else {- ... -}`.
00:56:42 <lehof> i mean gameloop
00:57:07 <dmwit> oops, I mean `isprime n = do print n; return (check n (n-1))`, of course.
00:59:30 <lehof> Am I correct in assuming that I don't understand this situation, because I don't have a clear understanding of monads?
00:59:51 <lehof> or is this about a different subject?
01:00:04 <dmwit> I don't think understanding monads is necessary. But you may like to stick to `(>>=)` and `return` instead of `do`-notation for a little while.
01:00:19 <dmwit> Use these specialized to `IO`.
01:00:35 <dmwit> `(>>=) :: IO a -> (a -> IO b) -> IO b` and `return :: a -> IO a`.
01:02:03 <dmwit> You might like sigfpe's "IO Monad for People Who Simply Don't Care"; or, if you are excited about monads anyway (certainly encouraged!), then I really liked sigfpe's "You Could Have Invented Monads (and Maybe You Already Have)".
01:02:36 <lehof> thanks :)
01:04:27 <shiona> A while ago I wrote a piece of code "main = let x = some_somewhat_complicated_calculation; forever do_stuff_with x" and after finding out that x was computed for each round of do_stuff_with, fixed it with a bang.  However I do feel like I would never catch any of these without the use of a profiler. Is there anything I could read so I could learn to avoid such traps?
01:10:03 <mfukar> shiona , start here: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
01:10:12 <lehof> what is the <- thing called in haskell?
01:10:33 <lehof> your suggestion seems to work :)
01:11:48 <liste> lehof: it's do notation, it's a shorthand for using >>=
01:12:18 <mfukar> lehof : "bind"?
01:12:57 <liste> lehof: do { a <- foo; b; return a; } is equivalent to foo >>= \a -> b >> return a
01:13:05 <liste> @undo do { a <- foo; b; return a; }
01:13:06 <lambdabot> foo >>= \ a -> b >> return a
01:14:27 <lehof> ok thanks :)
01:15:15 <lehof> I have only scratched the surface, but I feel like Haskell/FP is incredibly powerful :D
01:15:42 <NdaX404> Nice
01:17:58 <MarcelineVQ> shiona: Why did a bang help?
01:20:48 <vala> hi
01:23:09 <wing22> hi everyone, what are good places to hire haskellers for small projects,can I ask here?  
01:24:25 <quchen> wing22: Sure, just don’t spam it every couple of minutes (or hours). Reddit is also a popular option.
01:29:42 <lehof> I'm having a lot of trouble with Invariant Programming :(
01:30:51 <lehof> I've learned that Invariant Programming works the same in Functional Programming and Imperative Programming, but for some reason I can't wrap my head around it while using FP :(
01:31:16 <quchen> I’ve never heard of »invariant programming« :-/
01:31:48 <vala> i'm starting with Haskell
01:32:29 <lehof> the course I'm following describes it as adding arguments to a function such that a recursion function gets transformed to a tail recursive function
01:33:06 <quchen> lehof: Ah, that’s more commonly known as the »worker-wrapper transformation«.
01:33:53 <quchen> reverse = reverse' []; reverse' xs [] = xs; reverse' xs (y:ys) = reverse' (y:xs) ys
01:33:55 <lehof> quchen: ah ok... is there a reason it seems incredibly hard to do in FP?
01:33:55 <quchen> That sort of thing
01:33:59 <wing22> quchen, i'll  post it in reddit thx 
01:34:26 <quchen> lehof: Not really, no :-x
01:34:42 <sphinxo> is there a name for this pattern? http://lpaste.net/8703440454395363328 ( apart from recursion/ tail call )
01:35:05 <lehof> hmmm
01:35:12 <quchen> sphinxo: Worker/wrapper transformation ;-D
01:35:17 <quchen> sphinxo: Or at least akin to it
01:35:40 <sphinxo> thanks
01:36:19 <quchen> lehof: I think »length« is the canonical example, actually.
01:36:35 <quchen> Straightforward: length [] = 0; length (_:xs) = 1 + length xs
01:36:42 <sphinxo> How could you rewrite that with any?
01:37:17 <quchen> Worker/wrapper: length = go 0; go n [] = n; go n (_:xs) = go (n+1) xs
01:40:13 <sphinxo> ( when I say rewrite with any I mean the example I gave, not with length )
01:54:14 <mfukar> sphinxo : `any somefn [0..len]`
01:57:27 <sphinxo> What's the time complexity of this? http://lpaste.net/8480091744002637824 O(n^2) ?
01:59:36 <_sras_> Is there a package that can display/format monetary values in a local aware way...?
01:59:52 <_sras_> local/locale
02:04:07 <mbw> The documentation of the Network.Sockets API https://hackage.haskell.org/package/network-2.6.3.1/docs/Network.html more or less recommends Network as a high-level interface. However, the Network documentation again recommends Network.Sockets... Is this stuff all deprecated?
02:05:12 <Rembane> mbw: I use both depending on if I need the low-level stuff or not. Go for high level for as long as it does what you want.
02:07:27 <mbw> Rembane: It _does_ say "Network _was_ intended as a "higher-level" interface[...]", which kind of sounds like it was abandoned. But if you say you still use it, I guess it's okay to do so. It's for pedagogical reasons only, anyway.
02:09:24 <mbw> Rembane: What's the recommended way to make things exception-safe, do you bracket things or... ?
02:11:09 <Rembane> mbw: bracket is nice, but I don't know if it properly works with exceptions.
02:12:11 <Rembane> mbw: Go for it and see if it breaks! :D
02:12:51 <mbw> Rest assured, it will...
02:13:26 <Rembane> mbw: Then come back here and tell us how it broke and you can blame me for giving you stupid advice if somebody asks. :)
02:15:50 <mbw> Rembane: More importantly, what is the canonical way of testing things? I keep coming across a lot of deprecated information in this regard (telnet etc.), a lot of which doesn't work with localhost for security reasons. I saw there are some nice sites like httpbin. However, is there still a way of trying out the basics locally without making myself vulnerable?
02:16:30 <mbw> I really am a beginner in this regard :(
02:16:44 <Rembane> mbw: Bind to localhost and a port, and nobody but somebody who has access to the machine will be able to access the socket.
02:17:12 <Rembane> mbw: Being a beginner is cool. :)
02:17:15 <merijn> I missed the start, testing what?
02:17:37 <Rembane> mbw: Telnet actually isn't deprecated in this regard. You don't need encryption when nobody can snoop.
02:18:06 <mbw> merijn: The very basics of the information super-highway. HTTP, sockets, ...
02:18:17 <opqdonut> well telnet is deprecated in the sense that netcat is better
02:18:41 <opqdonut> and for http there's curl, wget, httpie, ...
02:18:43 <mbw> Well I did figure out that the verbose option of curl is very helpful.
02:18:47 <opqdonut> it is
02:18:59 <merijn> telnet is bad because telnet is a protocol, not just a dumb pipe for bytes
02:19:06 <antoine2> salut
02:19:07 <Rembane> You got me there. :D
02:19:08 <merijn> netcat *is* a dumb pipe for bytes
02:19:12 <opqdonut> merijn: yeah
02:20:34 <mbw> So I tried out binding a sockets the way the do it here: https://hackage.haskell.org/package/network-2.6.3.1/docs/Network-Socket.html (socket example), but then I quickly got stuck. How can I read/write without failing and see what happens?
02:20:37 <merijn> mbw: I learned socket the old school C way, i.e. beej's guide
02:20:43 <antoine2> beginer here. May someone explain in a nutshell why `not . null x` and `not (null x)` don’t return the same results ?
02:20:45 <merijn> https://beej.us/guide/bgnet/
02:21:13 <merijn> antoine2: because "not . null x" == "\y -> not ((null x) y)"
02:21:39 <antoine2> then just not . null ?
02:21:43 <merijn> antoine2: Yes
02:21:55 <antoine2> ok
02:22:03 <mbw> merijn: I think I came across this before. I think there is also this classical unix networking book that deals with this, but the author has been dead for a while and the material seems deprecated to some extent.
02:22:13 <merijn> mbw: I'm not sure how well beej's guide has aged
02:22:15 <antoine2> gotit
02:22:43 <merijn> mbw: There's also "Advanced Programming in the UNIX Environment", which covers basically *everything* you ever wanted to know and more about everything on *nix
02:22:52 <merijn> mbw: So I'd be surprised if it didn't cover networking
02:23:37 <antoine2> merijn, well, in my case, don’t work: [tail x | x<-xs, not . null]
02:23:46 <merijn> mbw: Note that the network package is really just a rather low level wrapping around C's socket functions, so if you find a better tutorial in another language you should be able to transplant that knowledge to haskell rather directly
02:23:56 <antoine2>     • Couldn't match expected type ‘Bool’
02:23:58 <antoine2>                   with actual type ‘t0 a0 -> Bool’
02:24:00 <antoine2>     • Probable cause: ‘(.)’ is applied to too few arguments
02:24:00 <merijn> antoine2: That's because guards must be booleans, not functions producing Bool
02:24:12 <mbw> It's kind of a shame that there is no "Learning Networking with Haskell" kind of material. All the tutorials/documentation of the libraries I checked out seem to assume some formal background
02:24:35 <merijn> antoine2: You need one of the following: "not (null x)", "(not . null) x", "not . null $ x"
02:24:50 <antoine2> so filter attemps function, but not guards, ok
02:25:12 <merijn> mbw: There's honestly not really a formal background, but most of it basically assumes you've used sockets in another language
02:25:40 <antoine2> and what’s the difference between `.` and `$` couldn’t we just replace all dots by dollar ?
02:26:14 <mbw> Well I just meant that you're either a professional, have some prior experience in another language, or you studied CS or something similar.
02:26:16 <merijn> antoine2: No, "($) :: (a -> b) -> a -> b" that is, it takes a function and an 'a' to produce a 'b'
02:26:58 <antoine2> a function that transforms a into b ?
02:27:12 <merijn> mbw: For example, if you look at the type of 'Network.Socket.socket' and compare it to the first line of 'man socket' you'll see it's basically the same (hence why I mentioned beej's guide)
02:29:28 <seequ_> antoine2: `(f . g) x = f (g x)` and `f $ x = f x`
02:29:45 <mbw> merijn: For me, a first milestone would be something like being able to automatically extract some links from a webpage and download them, or something like that. While I can "slap something" together with wreq or something, I still wouldn't really understand what I'm doing. That includes http requests and headers, which I have already been reading up about. But it also builds on TCP/IP of course. From a 
02:29:51 <mbw> pedagogical perspective, would you recommend a certain order of learning things? How did you learn all of this stuff?
02:30:11 <Rembane> mbw: Do it with netcat first.
02:30:54 <seequ_> antoine2: `f . g $ x` is equal to `f $ g $ x`, but  f . g` is not equal to `f $ g`
02:31:07 <mbw> This all sounds like there is not this one book that takes you by the hand...
02:31:49 <seequ_> The former is usually preferred because it's slightly neater.
02:32:04 <mbw> Rembane: So with netcat I can also throw out GET requests etc.?
02:32:09 <Rembane> mbw: Bingo
02:32:12 <Rembane> mbw: You need to know HTTP to retrieve a homepage.
02:32:19 <Rembane> mbw: Well, a small part of it at least.
02:32:49 <mbw> Is using HTTP/1.1 still ok?
02:32:53 <antoine2> ’cause of the automatical argument thing?
02:33:37 <Rembane> mbw: Anything that the server responds to is okay. :D
02:34:10 <merijn> mbw: Honestly, I had my first "computer networking" class 12 years ago, so I don't remember how I learned this stuff
02:35:36 <merijn> mbw: The only recommendation I have is: We used Tanenbaum's "Computer Networks" book and I remember all 3 Tanenbaum books I used at university as being excellent, so. But I don't remember how much that book focuses on theory vs practical
02:36:28 <antoine2> seequ_ it is ’cause the automatical argument thing?
02:37:00 <mbw> Ok but at least you did have a class... So now I have several options the way I see it. Using something like curl/netcat/whathaveyou, do it in C and use beej's guide or a book. I see this is all pretty involved and I have to go about this systematically to not get lost.
02:37:24 <merijn> mbw: Well, like I said, you could try simply using beej's guide and use Haskell
02:37:38 <merijn> mbw: Most of the API is identical, just the syntax isn't
02:37:53 <quchen> mbw: I generally read stuff, skipping things I don’t like or understand, until I hit the »all of this makes no sense to me« wall. I then revisit the first spot I skipped. Repeat!
02:38:04 <mbw> mbw: And this covers http as well, or only sockets?
02:38:05 <merijn> (and in Haskell you don't use select since it's built into the runtime)
02:38:16 <merijn> beej only covers sockets
02:38:17 <quchen> I like to call it »hammering the nail« learning tactic. It works fairly well for me. :-)
02:39:59 <mbw> quchen: Still, you have to start somewhere. In my case this now boils down to whether to start with sockets or http.
02:40:19 <DarkLeggend> !list
02:40:21 <mbw> And of course there's all this html/xml/json stuff also :(
02:41:54 <merijn> mbw: The one true way of learning is "Start somewhere (doesn't really matter where), keep going until you hit something you don't understand, then look for a way to learn that first and continue"
02:43:32 <quchen> Ignoring the induction basis makes keeping going much easier.
02:43:45 <quchen> It also makes it much easier to prove things, such as that every odd number is even ;-)
02:46:57 <mbw> I think I should start with the high-level presentation-layer stuff, to get practical results and keep me motivated, then. I have one more question about that. The way I understood it, if I GET a resource I can either get an html page, a media type or something like xml/json. In the latter case I think I can also request one of both, if the server supports it. But in practice, it might not. Now if I take 
02:47:03 <mbw> something like wreq for example, which works with json, I have to know beforehand that the server is able to throw json at me. Is that correct, or is there a more universal way to look at this?
02:47:37 <merijn> You always have to know beforehand what the server will talk to you
02:47:57 <merijn> Unless the server sends you stuff without you requesting it first, in which case you can try to guess based on what it sends you
02:48:15 <merijn> This is why we have protocols and assigned ports
02:50:41 <mbw> Aren't those two seperate things, protocol/port and resource presentation format? For instance, both xml/json can be used to present some kind of record type I might be interested in. The way I understood it, the format is encoded in the response header in some way. But it still can both be sent via tcp on port 80... Or am I totally mixing things up now...
02:51:48 <merijn> No, before the idiocy of web2.0 and "everything is http"
02:51:54 <merijn> Actually, still
02:51:59 <merijn> XML and JSON are not protocols
02:52:04 <merijn> They are file formats
02:52:31 <merijn> HTTP is a protocol which was made to send arbitrary blobs of data, so it doesn't care whether those blobs are images, HTML, XML, or JSON
02:53:01 <merijn> The IANA (Internet Assigned Numbers Authority) allocates port numbers to protocols
02:53:16 <mbw> k, that's the stuff in /etc/services.
02:53:38 <merijn> See: https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml
02:54:13 <merijn> So, you generally expect port 80 to talk HTTP to you, port 25 to talk SMTP, port 21 to talk FTP, etc.
02:54:33 <merijn> If you don't know what a server on port X talks, there's no reasonable way to interact with it
02:57:28 <mbw> ok, but then in what way do http and tcp differ fundamentally? The way I understood it, you use tcp for data that needs to arrive losslessly, and udp for something like online games or skype or whatever. Now if you say http is for arbitrary blobs of data, that _again_ sounds like the kind of unstructured information tcp/udp are talking about. Man...
02:58:03 <merijn> mbw: There's levels (see OSI layers) and generally each level is handled differently
02:58:26 <merijn> At the physical level (wifi or ethernet) your network cards hardware talks to another cards hardware
02:58:43 <merijn> These are usually just frame blobs with some boundaries
02:59:31 <merijn> ip is a higher level protocol that implement (unreliable, unordered) datagrams, this is implemented in your kernel and talks with your network card driver to convert it to whatever your card speaks
02:59:52 <merijn> TCP and UDP are implemented (again in your kernel) on top of IP
03:00:27 <merijn> HTTP is a layer 7 (i.e. application layer) protocol, implemented on top of TCP. Your kernel doesn't know HTTP, it just sees a TCP connection that contains bytes
03:00:36 <merijn> Your application has to turn those bytes into something sensible
03:01:01 <merijn> mbw: HTTP does a bunch of stuff beyond TCP
03:01:27 <merijn> HTTP supports resuming, compressing, it tells you (sometimes) the size of the binary data in advance, etc.
03:02:48 <mbw> ok, this is helpful
03:06:59 <mbw> merijn: Could you also expand on your remark on the idiocy of web2.0? You seem to refer to some specific problems with "how things are done nowadays"...
03:08:14 <merijn> mbw: The web2.0 crowd is reinventing literally every protocol by tunneling it over HTTP
03:09:29 <mbw> What would be a concrete example of that?
03:11:37 <merijn> mbw: Things like all "smart" devices talking HTTP to everything
03:12:15 <merijn> HTTP doesn't add anything there, since the actual requests in the HTTP tend to be opaque blobs anyway, so just writing a proper protocol would be easier and neater
03:15:00 <mbw> So, all this IoT stuff uses http?
03:17:12 <merijn> Lots of it
03:17:23 <merijn> Probably JSON too, because people like making me sad
03:18:38 <mbw> Is this the reason for why the majority of IoT communication is insecure, resulting in botnets ?
03:19:01 <sbrg> yes and no. the reason for the bad security is basically bad programmers, bad companies, bad ethics, bad pay
03:19:02 <sbrg> etc
03:19:07 <AndreasK> Going by the code quality of many embedded systems we should probably be thankful that they use existing http/json libraries instead of inventing new stuff. Although I bet some do write their own http stack too which has the worst of both worlds ...
03:19:17 <merijn> No, the reason is "companies with little software experience writing software in C"
03:19:17 <sbrg> they don't care, they don't have any gov. institutions demanding they do stuff properly, etc
03:21:34 <mbw> So what would be "doing things properly"? Your did mention "writing a proper protocol would be easier and neater", however that kind of sounds like it would make things worse since there is more that can be done wrong...
03:27:00 <merijn> Honestly, protocols are not that hard
03:27:11 <merijn> It's not rocket science, it's like defining a file format
03:27:38 <merijn> There's only 2 rules that are actually important: 1) have a unique header token 2) have a version number
03:27:43 <merijn> Especially rule two
03:29:43 <mbw> Ok, so the problem you mentioned with web2.0 isn't really about "reinventing things", but the abuse of http?
03:30:07 <merijn> mbw: My problem is "reinventing things *poorly*"
03:30:39 <mbw> I see.
03:30:48 <merijn> Adding HTTP below protocol X almost never makes X better, and often DOES make X worse
03:31:58 <mbw> This is probably something that I can only reasonably understand/judge after I have more knowledge and experience.
03:33:23 <merijn> Honestly, pick some goal that seems unrealistic and keep plugging away until you get somewhere. Most "hard" things (in terms of programming, not theory :p) I've encountered in CS were, in hindsight, not nearly as hard as they seemed
03:33:38 <merijn> (I'm talking filesystems, TCP implementations, compilers, etc.)
03:35:44 <tdammers> writing "a" compiler for "a" language isn't hard
03:36:08 <tdammers> the hard part is making it really really good
03:36:16 <merijn> :)
03:36:17 <Cale> merijn: There's a significant challenge in doing rule two well.
03:36:26 <mbw> (But there's only so much time...) But you're right, and I think I now have some good ideas on where to take things from here. I'd like to thank you for your patience with my naive questions, especially considering they were only _somewhat_ Haskell related :)
03:36:31 <merijn> tdammers: Not if you believe the Ur/Web guy :)
03:36:57 <merijn> Cale: Doing rule 2 at all is already a pretty big leap away from eternal regret
03:36:58 <tdammers> merijn: the problem with compiler and programming language design is that it usually happens by accident
03:37:17 <merijn> tdammers: That's because no one is willing to pay me for doing it on purpose :(
03:37:44 <tdammers> merijn: I had this HTML template engine that started out as a one-liner involving a regex and a dictionary lookup. By now it has turned into a turing-complete dynamically-typed programming language.
03:37:46 <centril> Given a  Traversal' s a ,  how do I get  s -> [a]  ?
03:37:55 <centril> i.e: get all elements that this traversal applies to
03:38:00 <merijn> tdammers: Poor you :)
03:39:11 <mbw> This sounds suspiciously like Perl.
03:39:40 <tdammers> first incarnation was PHP
03:39:52 <tdammers> a.k.a. Perl's retarded little brother
03:39:54 <mbw> D:
03:40:06 <tdammers> I was young and needed the money
03:40:23 <Cale> merijn: Well, minimally, you get to check that the versions match, and if not, present the user with an error. That's good, but then the next thing is implementing a server which can talk to old versions of the client, or a client that can talk to old versions of the server, and that's when stuff seems to get hard (I'm trying to figure out how we're going to arrange this for one of our applications right now -- just putting in a 
03:40:23 <Cale> version number is not the hard part :)
03:41:28 <merijn> Cale: Sure, that's not easy, but I've had to do that (for a file format, not protocol) when my very first and 2nd version...didn't HAVE a version number
03:41:32 <merijn> Cale: And then your bollocksed
03:41:40 <Cale> haha, yeah
03:41:43 <merijn> On a completely unrelated note
03:43:30 <merijn> Is anyone aware of a good intro on how to implement typechecking for (complex) pattern matches in something System F like. TaPL's coverage of sums/variants and polymorphism is rather disjoint, the Henk paper by SPJ and Erik Meijer also seems to gloss over some important details
03:45:13 <Cale> The problem is that we have this interface which consists of... jeez, something like 160 data types? I'm not sure exactly how many of those actually go over the wire, but it's a significant fraction of them, and we need to work out some sort of answer to how we're going to cope with mismatched versions between backend and frontend, simply because Apple takes an unpredictable amount of time to check new releases of things on the App 
03:45:13 <Cale> Store.
03:45:57 <Cale> (and you're not allowed to deliver new code)
03:47:48 <sbrg> merijn: [..] pick some goal that seems unrealistic [..] -- it's funny you should say that, but that is exactly the thing that I like to say is the most important thing I learned studying at uni. I don't know how many times I've stared at something that started out as more or less completely incomprehensible, and then had a good understanding of the subject a couple of weeks later, just because I kept banging my head against the
03:47:48 <sbrg> proverbial wall. 
03:47:55 <sbrg> people really do underestimate persistence
03:48:50 <merijn> sbrg: Not the students we're currently making suffer through compiler constructions ;)
03:50:28 <Cale> We'll probably just end up with N rolling copies of the libraries which define all our application data types and TH-generated Aeson instances, and then just painfully write annoying migrations.
03:50:56 <Cale> TH could automate a significant fraction of it
03:51:12 <Cale> But still, it's going to be really irritating
03:53:57 <sbrg> "migrations"
03:54:02 <sbrg> that word gives me the creeps
03:54:27 <merijn> So no recommendations on pattern matching explanations?
03:55:31 <mbw> Among the many options Haskell seems to give you when it comes to generic programming, are there that are "clearly to be preferred" and others "to be avoided", or do you at some point have to know them all?
03:55:51 <merijn> mbw: I don't think I know any of them? :p
03:55:52 <mbw> *are there some
03:56:02 <merijn> Unless you include TH as "generic programming", I suppose
03:56:10 <mbw> I thought the cool kids were using them.
03:56:22 <Cale> mbw: They only come up somewhat rarely, depending on what kind of programming you tend to do, none of them are absolutely terrible
03:56:58 <Cale> You can certainly write a heck of a lot without learning about any of them
03:57:59 <mbw> To be fair, I haven't really encountered a situation yet where I missed these kind of features. Also, the term "generic" seems to be somewhat differently in Haskell than for instance in C++, where you call making use of parametric polymorphism "generic programming"...
03:58:40 <Cale> Yeah, our "generic" is a whole other kind of thing, where you're building programs which act at many types based upon the structure of the type itself
03:59:02 <Cale> Rather than just generic in the sense that you have a things which works at many types because it doesn't care about the structure of the type.
03:59:09 <Cale> a thing*
04:00:03 <mbw> Is there some kind of context in which Haskell generic programming constructs are used most often?
04:00:21 <Cale> Serialisation and deserialisation
04:00:29 <Cale> Of various kinda
04:00:32 <Cale> kinds*
04:00:36 <Cale> I can't type :)
04:01:42 <mbw> Always? There have to be situations in which you can just "dump binary", right? For instance plain arrays. Don't know about lists.
04:02:36 <Cale> For example, Aeson uses generics to get you standard instances of ToJSON and FromJSON -- you can write  "instance FromJSON MyType" and not fill the instance in if your type is an instance of Generic.
04:02:52 <Cale> (and GHC can derive Generic)
04:03:28 <mbw> But Generic is GHC specific, right? (I know that GHC kind of "won", but still...)
04:03:40 <Rodenbach> Is there a way to implement Show on functions, so that they will output their module+name when shown?
04:03:56 <Cale> Well, somewhat. It doesn't need to be GHC specific
04:04:12 <Cale> But most of the generics solutions people actually use are.
04:04:23 <mbw> Rodenbach: I guess the simplest approach would be newtype wrappers.
04:04:56 <Cale> Well, it's almost hard to measure whether these things are specific to GHC, because there just isn't really much of a competitor
04:05:04 <Cale> at least at the moment
04:05:05 <mbw> And what is the difference between Generic and Typeable? Is the latter only used for reflection kind of things?
04:05:19 <Rodenbach> mbw: okay, thanks for this suggestion!
04:05:27 <Cale> Typeable only gives you runtime type level information.
04:05:43 <Cale> It doesn't give you information about which constructors some data type has, for example
04:06:30 <mbw> Cale: This kind of scares me, tbh. In conventional languages, it was always fruitful to have some healthy compiler competition, like clang for instance which resulted in a lot of improvements for gcc also. It feels like if I don't use other Haskell compilers out of pity or something, they will at some point all be gone...
04:06:54 <Cale> mbw: Well, the community for Haskell is only so large at the moment
04:07:19 <tdammers> then again, Haskell isn't the only single-implementation language out there
04:07:36 <Cale> and having two compiler implementation projects on the scale of GHC would be kind of a waste of scarce resources compared to the benefit it would provide
04:08:00 <Cale> There are only so many people capable of working on GHC, and then only so many of those people actually have time to do it
04:08:24 <tdammers> also, the "other" compilers aren't so much pity cases; most of them are research vehicles, and quite a bit of that research eventually ends up in GHC and its ecosystem
04:08:34 <Cale> Though, there is now GHC and GHCJS
04:08:48 <Cale> but those two share a lot :)
04:08:48 <mbw> But GHC doesn't belong to anyone, right? I mean I saw that a lot of stuff is done in the context of projects of Microsoft Research..
04:08:59 <MEIRL> NO
04:09:02 <Cale> Right
04:09:05 <MEIRL> HELLO
04:09:10 <MEIRL> HI AIDAN
04:09:14 --- mode: ChanServ set +o Cale
04:09:22 <MEIRL> HELLO
04:09:24 <MEIRL> Not ME
04:09:27 <mbw> (??)
04:09:28 <Cale> Please be considerate and try not to shout.
04:09:33 <MEIRL> okOk
04:10:31 --- mode: Cale set -o Cale
04:16:00 <mbw> Cale: If Typeable is about rtti only, what is it commonly used for? I thought rtti was basically what the implicit use of dictionary arguments are used for, since because of polymorphic recursion not everything can be resolved at compile-time...
04:16:22 <mbw> Excuse my grammar.
04:18:45 <Cale> mbw: Well, there are various ways to forget the type of something. Existential types and GADTs can lose information about what type something had. Typeable provides a way to recover that, conditionally.
04:18:48 <Cale> :t cast
04:18:49 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
04:19:46 <Cale> For example, if I define a (fairly silly) type like  data Showable where S :: (Show a) => a -> Showable
04:20:07 <Cale> Then having constructed something like  S (5 :: Integer) :: Showable
04:20:54 <Cale> The only thing I will know about the argument to S when I pattern match is that it's some instance of Show, and so the only thing I can do with it, pretty much, is to apply the show function (or shows/showsPrec)
04:21:30 <Cale> If I need to be able to recover the fact that it's an Integer whenever it happens to be one, then Typeable gives me that abilit
04:21:30 <Cale> y
04:22:11 <Cale> If we added Typeable a to the constraint on S
04:23:10 <Cale> Then we could do something like   foo (S x) = case cast x of Just n -> ... use n as an Integer here ...; Nothing -> ....
04:23:52 <Cale> Typeable is also central to the way that exceptions work
04:24:17 <mbw> I was just going to ask about typical use cases, but this seems like a pretty important one.
04:24:45 <mbw> So you probably won't find it in willy-nilly run-of-the-mill code?
04:25:53 <Cale> Probably not.
04:27:36 <Cale> Another example is Dynamic
04:27:54 <Cale> But people don't tend to use Dynamic so much in Haskell, they just use existentials, and possibly Typeable.
04:29:03 <Cale> But yeah, anything of a Typeable type, you can turn it into a Dynamic, and then turn it back.
04:29:13 <Cale> (conditionally, as a Maybe again)
04:29:26 <Cale> The simple implementation being
04:30:09 <Cale> data Dynamic where MkDynamic :: Typeable a => a -> Dynamic
04:30:33 <Cale> Or to use the other notation, that would be  data Dynamic = forall a. Typeable a => MkDynamic a
04:31:34 <Cale> and then you have  fromDynamic :: Typeable a => Dynamic -> Maybe a;  fromDynamic (MkDynamic x) = cast x
04:32:36 <mbw> Is data X where Y the notation for GADTs?
04:33:05 <Cale> Yeah, you list the types of the constructors under the where
04:33:47 <Cale> and the key point is that you get some extra flexibility with regard to the resulting type
04:34:00 <lep-delete> you can also only use -XGADTSyntax :D
04:34:42 <mbw> This is all so much more stuff to learn...
04:34:46 <Cale> Yeah, GADTSyntax turns on the syntax, but not the extra capacity to define types with constructors that restrict their type parameter
04:35:00 <Cale> For example, you can do the following as a GADT
04:35:07 <Cale> data Expr t where
04:35:16 <Cale>   Lit :: Integer -> Expr Integer
04:35:26 <Cale>   IsZero :: Expr Integer -> Expr Bool
04:35:43 <Cale>   IfThenElse :: Expr Bool -> Expr a -> Expr a -> Expr a
04:36:05 <Cale> and now, you could define:
04:36:09 <Cale> eval :: Expr t -> t
04:36:16 <Cale> eval (Lit n) = n
04:36:54 <Cale>  -- note that, having pattern matched on (Lit n), we discover that t is Integer, and so n is a valid result on the right hand side here
04:37:15 <Cale> eval (IsZero e) = eval e == 0
04:37:40 <Cale> eval (IfThenElse b t e) = if eval b then eval t else eval e
04:38:49 <mbw> How does eval (IsZero e) work?
04:38:59 <mbw> specifically, eval e...
04:39:06 <Cale> Well, in that case, we know that IsZero e :: Expr Bool
04:39:11 <Cale> and so we know that t = Bool
04:39:24 <Cale> and so the right hand side needs to be a Bool
04:39:33 <Cale> and of course, the argument to IsZero has type Expr Integer
04:39:44 <Cale> that is, e :: Expr Integer
04:39:48 <Cale> and so  eval e :: Integer
04:39:55 <Cale> and so  eval e == 0 :: Bool
04:39:57 <Cale> as desired
04:40:59 <mbw> I have to type this into a file...
04:41:07 <Cale> The key thing about GADTs which makes them GADTs is that you can recover information about their type parameter by pattern matching on their constructors
04:41:14 <mauke> see /topic for a link to channel logs
04:41:38 <Cale> So even though you only started out knowing that you had some Expr t, after pattern matching, you might know more
04:41:47 <mbw> Do I need GADTs or GADTSyntax?
04:41:51 <Cale> GADTs
04:42:15 <Cale> GADTSyntax should complain that this is a real honest GADT.
04:42:36 <Cale> and not just an ordinary algebraic data type with the generalised syntax
04:44:15 <mauke> :t field_1
04:44:16 <lambdabot> error: Variable not in scope: field_1
04:44:27 <AndreasK> merijn: What do you consider complex pattern matching in contrast to simple pattern matching?
04:44:52 <Cale> AndreasK: I'm guessing nested patterns
04:45:30 <mauke> map _ [] = []; map f ((f -> y) : (map f -> ys)) = y : ys
04:46:19 <mbw> Ah I think I get it.
04:46:55 <opqdonut> mauke: nice
04:47:33 <mbw> No I don't.
04:47:43 <AndreasK> merijn:I think "The Implementation of Functional Programming Languages" covers typechecking including patterns.  But in something SystemF like wouldn't you translate all pattern matching to case expressions first and then typecheck the result of that?
04:47:45 <Cale> mbw: Anything I can clear up?
04:47:58 <mbw> In IfThenElse, eval b should go into IfThenElse again, I think. Will this terminate?
04:48:07 <Cale> hm?
04:48:12 <narff> how can I 'map' on every other element? i.e. map' negate [1..10] output: [-1,2,-3,4,-5,6,-7,8,-9,10]
04:48:14 <mbw> My thinking was.
04:48:15 <Cale> why would it?
04:48:22 <mbw> In IsZero e
04:48:42 <mbw> eval e goes into the "Lit n" pattern match and returns an integer.
04:48:46 <Cale> Consider something like  IfThenElse (IsZero 5) (Lit 3) (Lit 6)
04:48:59 <mbw> Ah.
04:49:01 <mbw> Ok.
04:49:02 <mauke> > zipWith id (cycle [negate, id]) [1..10]
04:49:04 <lambdabot>  [-1,2,-3,4,-5,6,-7,8,-9,10]
04:49:29 <mbw> But it really is just pattern matching on types, right?
04:49:39 <merijn> AndreasK: I mean nested/compound patterns
04:49:43 <Cale> There's no runtime matching on types
04:49:46 <Cale> Only on constructors
04:50:05 <merijn> AndreasK: TaPL seems to only cover Sum/Variant types separately from polymorphic types and I'm having a hard time making things work that way
04:50:24 <Cale> It's just we know something more about what the types of things are, because we're able to set up this contract for eval
04:50:38 <Cale> eval :: Expr t -> t
04:51:05 <merijn> AndreasK: I wrote an implementation of Henk (see "Henk: a typed intermediate language" by SPJ/Erik Meijer), which seems like you should be able to do typechecking without needing unification, but I seem to get stuck with the typechecking of 'case'
04:51:16 <Cale> and so we know that the program will be safe
04:51:26 <Cale> even once we forget what all the types were
04:51:34 <mauke> I'd like to see an implementation of Cowboy Henk
04:51:51 <mbw> Is this related to polymorphic recursion?
04:52:09 <mbw> Since the t's can be different.
04:52:16 <Cale> I suppose our eval is polymorphically recursive.
04:52:42 <Cale> But consider, for example, if we tried something like this:
04:53:10 <merijn> AndreasK: Basically, the Henk paper suggest storing constructors as just their signature. I currently don't do type erasure, so all types are passed explicitly, including to constructors, but that means if you have "Foo a b c" (when constructing) some (or all) of 'a', 'b', and 'c' could be types
04:53:12 <Cale> data Expr t = Lit Integer | IsZero (Expr Integer) | IfThenElse (Expr Bool) (Expr a) (Expr a)
04:53:24 <Cale> and then tried to write
04:53:29 <Cale> eval :: Expr t -> t
04:53:46 <Cale> eval (Lit n) = n -- nope! Won't typecheck already.
04:53:48 <merijn> AndreasK: But I'm unsure how to deal with that in a pattern. Naively you could include a pattern variable for the types too, but that seems like it doesn't work out to well
04:53:55 <shiona> MarcelineVQ: I assume "let x = func >> forever print x" creates a thunk for x, and for each round in forever, the evaluation notices the requirement for x, evaluates it, uses it and then frees it, as there is no further need for the value. But there is, it's just too implicit for the runtime to understand it. That's my guess. "let (!x) = func >> forever print x" then forces x to some level outside the
04:53:56 <Cale> n :: Integer, but we want something of type t
04:53:57 <shiona> forever part, so within it x cannot be (completely) freed
04:54:13 <merijn> AndreasK: In the actual paper they just "sort of" annotate case with the types, but don't explain how you can figure out which positions *are* types and where they come from
04:54:54 <Cale> and, we know that  Lit n :: Expr t
04:54:57 <merijn> So I'm wondering whether I have to go all the way and do unification to make things work, or whether I'm missing something here
04:55:02 <Cale> But we don't learn from that that t = Integer
04:55:03 <AndreasK> merijn: It's sadly not really knowledgable about typechecking myself, I just remember a chapter being dedicated to it in that book. But I just looked it up and it doesn't really seem to go into detail and doesn't mention patterns explicitly at all :(
04:55:07 <Cale> and so it doesn't typecheck
04:55:28 <Cale> t could very well be String
04:55:34 <Cale> for all we know
04:55:43 <merijn> AndreasK: Yeah, this goes for most papers/books I know. TaPL goes into details, but only for the separate individual pieces and leaves putting them together as "exercise for the reader" apparently
04:55:57 <mauke> this is like Nothing :: Maybe whatever
04:56:07 <mauke> and we can't write Maybe a -> a
04:56:28 <Cale> Well, it's a little different...
04:56:42 <AndreasK> merijn: As far as I know GHC's core (more or less SystemF) doesn't have nested patterns though as they are desugared away.
04:56:43 <Cale> But kinda
04:56:53 <Cale> We actually have a value of type Integer, and we'd really like for t to be Integer here.
04:57:14 <Cale> But there's nothing which is constraining it to actually be that, so that we can use the Integer that we have.
04:57:47 <AndreasK> merijn: Sorry I couldn't be more helpful, I want to look into typechecking at some point but not there yet.
04:57:52 <merijn> AndreasK: Even without nested patterns you have the same issue about whether you treat types as bindable in patterns
04:58:00 <Cale> mbw: Does that make sense?
04:58:35 <narff> mauke: cool
04:58:38 <mbw> Kind of. It's only surprising that such a simple looking problem hasn't ocurred to me yet...
04:58:58 <merijn> Cale: You don't happen to have any pointers for me? :)
04:59:11 <Cale> merijn: References on how to typecheck nested patterns?
04:59:13 <mbw> Although I'm pretty sure I've probably encountered it without noticing.
04:59:25 <Cale> merijn: I wonder if there's something in SPJ's book
04:59:34 <merijn> Cale: Not necessarily nested, although a sort of "comprehensive" approach would be welcome
04:59:35 <Cale> merijn: I know there's stuff on compiling nested patterns
05:00:00 <merijn> My real issue is more how to typecheck polymorphic patterns, I think
05:00:07 <Cale> mbw: Seems to show up kinda rarely in actual practice.
05:00:07 <AndreasK> merijn: If you figure it out you should write a blog post about it sparing me the pain when I get there :D
05:00:30 <merijn> As in
05:00:35 <merijn> Suppose we have
05:00:38 <Cale> mbw: But when you're writing interpreters, it lets you hijack Haskell's type system for your own interpreter's use (as you might've guessed from this mini-example)
05:00:45 <merijn> data ProxyT : * -> * where
05:00:45 <merijn>     Proxy : forall a . a -> a -> ProxyT a
05:01:34 <merijn> Naively a pattern for ProxyT would look like "case p of Proxy t r r", since Proxy takes 3 arguments
05:01:34 <Cale> mbw: and since the main overarching design pattern of functional programming is to invent a language in which your problem is easy to solve and then write an interpreter or compiler for that language, it can come up :)
05:02:05 <merijn> However, that doesn't seem right, since 't' is a type variable that's already determined by the type of 'p', but I'm unsure how to handle that
05:02:34 <merijn> Simply eliding the types means 1) figuring out "what are types" and 2) having a different arity in patterns than you do in applications
05:03:15 <merijn> The Henk paper does seem to elide the types from patterns, but provides no explanation or justification for how they do this
05:03:55 <mbw> Cale: On the other hand, we write mini-interpreters all the time I think. Like expressing invariants in terms of types, and then work with those. From this perspective (which might be wrong of course), I still don't have this "Aha! Now I need GADTs!" decision making tool at hand...
05:05:18 <merijn> mbw: You notice rather quickly when you need GADTs, since when you try to write (fairly simple/obvious) code, it will fail to work
05:05:21 <mbw> But I have this problem with most GHC extensions still
05:05:54 <merijn> mbw: GADTs, like RankNTypes are something that usually don't make a lot of sense until you're trying to write some code that needs them, then you go "oh..."
05:06:18 <merijn> Especially GADTs and RankN, since what they're doing is actually rather simple. It's the implementation that's hard and requires lots of theory
05:06:58 <Cale> merijn: I guess one thing is that since you don't have a GADT ;) the type argument occurs in the type of p, and you could steal it from there
05:07:01 <merijn> Incidentally, the Henk paper is here: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.50.7152&rep=rep1&type=pdf and section 5.4 is the explanation of pattern matching, which you'll, hopefully, agree is rather light
05:07:14 <merijn> Cale: Yes, but I don't know *how*
05:07:31 <Cale> merijn: Well, is p going to be in your context?
05:07:39 <Cale> It had better be, I think
05:07:47 <merijn> Cale: Because that means somehow identifying which part of the computed type of 'p' correspond to which part of the pattern
05:07:53 <Cale> Or else that variable lookup is going to fail
05:08:35 <Cale> The types that the data constructors are applied to are the same as the types that the type constructor is applied to
05:08:40 <Cale> hmm
05:08:46 <Cale> I think
05:08:52 <merijn> Do I simply just keep a list of types and every time I see a Pi type in the type of Proxy pick the first element of said list?
05:08:57 <Cale> yeah, that should be right
05:09:05 <Cale> uh
05:09:10 <mbw> Are existentials, Rank2/NTypes, explicit forall etc. all expressing the same concept? A lot of extentions seem to use "forall", for instance ScopedTypeVariables which I use often in conjunction with typed holes, as well..
05:09:44 <merijn> mbw: ScopedTypeVariables merely uses the forall to introduce scoping, but they are the same forall in sense of the underlying theory
05:09:53 <Cale> merijn: I mean, when you're typechecking a case, you look up the type of the scrutinee in your context (after typechecking it)
05:10:02 <merijn> mbw: Haskell, implicitly has a forall everywhere, but it's never printed (hence, implicit)
05:10:10 <Cale> merijn: and then you pick it apart, and whatever types its constructor was applied to
05:10:19 <Cale> those are your implicit type arguments
05:10:42 <merijn> Cale: Currently I don't really have an "pick apart" implementation for types, but I suppose I will need to construct one?
05:10:54 <merijn> Cale: This is the kinda detail I was hoping got covered somewhere
05:11:05 <Cale> uhh, not implementation
05:11:20 <Cale> I just mean you need to extract the arguments to the type constructor
05:11:30 <Cale> It's going to have a list of type arguments
05:11:58 <Cale> those are the things you would have otherwise obtained from the data constructor's type arguments
05:12:07 <mbw> If I take something like Lens' s a = forall f. Functor f => (a -> f a) -> s -> f s. What would happen if I didn't use forall?
05:12:22 <merijn> Cale: Let's stick with the ProxyT example. The point is, I need to match the 'a' in 'ProxyT a' to the relevant fields in Proxy, but it's not obvious how I can compute that
05:12:31 <praduca> Hi everibody
05:13:02 <merijn> Cale: In case of proxy I need to somehow figure out that the first ProxyT argument corresponds to the type of both 'x' and 'y' in 'case p of Proxy x y'
05:13:12 <merijn> mbw: It wouldn't compile
05:13:48 <merijn> mbw: I wrote a minimal example show casing RankN here: https://gist.github.com/merijn/77e3fa9757658e59b01d
05:13:53 <praduca> can someone tell me a good way to start using haskell and stack on nixos? 
05:14:41 <merijn> Cale: And I need to figure out which arguments to 'Proxy' are type and can be elided from the match, which is also not obvious to me
05:15:30 <Cale> https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf
05:15:39 <merijn> mbw: RankN deals with 'who gets to pick the type of a type variable'\
05:15:42 <Cale> I think Fig. 2 actually probably gets you there :)
05:16:07 <Cale> So, read from below the line to above the line for typechecking
05:16:12 <merijn> mbw: Normally, the *caller* of a polymorphic function gets to pick, but that doesn't always work, like in that gist. Since the caller can't know what 'a' will end up being
05:17:00 <merijn> Cale: That's just using constraint based unification, no?
05:17:24 <merijn> I was hoping to get away with not implementing unification, since I don't think it's necessary if you don't do inference (I don't)
05:17:31 <Cale> yeah, though look carefully at what's going on with the list of types \bar{tau}
05:17:55 <Cale> Oh, I mean, probably something simpler works too, the constraint part is unimportant, I think
05:18:34 <merijn> Cale: I'm a bit unfamiliar with some of the syntax there, is it explained elsewhere?
05:18:56 <Cale> Are you generally familiar with this style of syntax for typing rules?
05:19:30 <Cale> There's a lot here which I'm not interested in, right now, maybe I could just write down the part which I think is relevant if you want :)
05:19:42 <merijn> Yeah, it's the forall double arrow and bar'ed substitution in VarCon I don't get it
05:19:54 <Cale> Ignore everything except the rule for Case
05:20:02 <Cale> and then ignore most of that
05:20:13 <merijn> Cale: I'm "got to chapter ~22 of TaPL" familiar with typing rules syntax ;)
05:20:28 <Cale> just notice that we're typechecking an expression of the form  case e of blah blah blah pattern matches
05:20:37 <mbw> It's amazing how all these "minimally not working examples" are so simple.
05:20:49 <Cale> and the first thing on the top of the line is Gamma |- e : T \bar{\tau}
05:21:03 <Cale> i.e. we typecheck e first
05:21:41 <merijn> Cale: \bar{\tau} is just "an unspecified indexed number of tau's", right?
05:21:45 <Cale> yeah
05:22:01 <Cale> so, the list of type arguments to the type constructor
05:22:10 <merijn> mbw: Like I said, what RankN actually does is not particularly hard. But most uses of it are confusing since there's usually multiple things going on at once :)
05:22:17 <Cale> and then we go to typecheck each of the branches of the case
05:23:49 <merijn> Cale: hmmm, this seems to actually be what I initially implemented, I think? But that messed up. But maybe that's because I did have types in the pattern math and tried to use them in the result
05:23:58 <Cale> and there's this  K_i: forall a. v_i -> T a (where I'm eliding the bars, but eh, just the same with lists of things)
05:24:09 <tobiasBora> Hello,
05:24:39 <Cale> and then we substitute the types tau that we unified while typechecking e
05:24:50 <Cale> for the type arguments to the data constructor
05:25:13 <merijn> Cale: Let's say I try to swap the two variables inside ProxyT, initially I'd write that as 'case p of Proxy t x y -> Proxy t y x', but that doesn't seem to work out nicely.
05:25:15 <tobiasBora> I've a question that may sounds stupid, but what are the main differencies between stack and haskell-platform? Is one way more popular that another? Are the projects written for one are simply usable by the other one?
05:25:44 <Cale> merijn: Er, but would you have the explicit type argument?
05:25:52 <merijn> Cale: I don't know?
05:25:54 <Cale> Or are you just making that explicit
05:26:03 <Cale> Wait, why doesn't it work out?
05:26:34 <merijn> Cale: I don't know, things got really messy and I never figured out how to fix it nicely. But that might also be me screwing up the implementation...
05:27:28 <merijn> Cale: I'm not even sure whether making the type an explicit matchable thing is even sensible, tbh
05:27:30 <Cale> The type of both x and y should be the type a that gets unified with the type obtained by typechecking the scrutinee of the case
05:28:05 <mbw> tobiasBora: The way I see it, people seem to recommend stack these days, though these things are of course always subjective. Some people actually argue actively against haskell-platform: https://github.com/bitemyapp/learnhaskell#also-do-not-install-haskell-platform
05:28:16 <Cale> merijn: At the term level?
05:28:42 <merijn> Cale: Yes
05:28:43 <Cale> merijn: I think it should be sensible, but it will throw away parametricity.
05:29:12 <merijn> Cale: Does it? How?
05:29:20 <Cale> If you do *that* then it makes sense to keep the types around as explicit arguments to your data constructors, because that's where they'll have to live at runtime
05:29:30 <merijn> Cale: I don't support a polymorphic case anyway
05:29:40 <Cale> I assume you mean you can type-case?
05:29:40 <merijn> So at best it can let you write more errors
05:29:45 <Cale> Or...
05:30:15 <merijn> Cale: I don't know what I'm doing tbh, because TaPL doesn't cover putting the pieces together like this and I haven't found any other resource
05:30:25 <merijn> So I honestly don't know if what I'm doing makes any sense at all
05:30:38 <merijn> Henk doesn't seem to include an explicitly matchable type argument.
05:30:42 <Cale> merijn: Your typechecker will of course make the type constructors matchable things, because that's what it does is to make sure that types match :)
05:31:00 <merijn> But including it won't change the actualy behaviour since that won't allow
05:31:09 <Cale> But you don't necessarily expose this ability to branch on type arguments to your users
05:31:19 <merijn> Cale: No, I mean I don't see how explicitly including a type argument in the pattern breaks parametricity
05:31:25 <Cale> ohh
05:31:34 <tobiasBora> mbw: Thank you!
05:31:44 <merijn> Cale: Because doing that doesn't seem like it will allow you to do typecase? Which I assume you meant is what breaks parametricity
05:31:46 <Cale> Well, it doesn't. It only breaks it if you allow, say, a non-variable type pattern there
05:32:01 <merijn> Cale: Even then it doesn't, since I require all patterns to have the same type
05:32:09 <Cale> ahh
05:32:12 <Cale> Then sure
05:32:14 <merijn> So that'd be a type error
05:32:28 <Cale> right, it would be a type error then to attempt to type case :)
05:32:34 <merijn> Or rather, I require all patterns to match the type of the scrutinee
05:33:31 <Cale> But then, if the type argument never varies, and it can be determined from the type of the scrutinee, why bother writing it in the syntax?
05:33:47 <Cale> Just because we like it? :)
05:33:58 <merijn> Cale: Because I didn't know how else to make it make sense
05:34:07 <Cale> I guess you could write a variety of type variables there and have them unified by the type checker
05:35:39 <Cale> merijn: You have to look up the type of the constructor in the context already, right?
05:35:45 <merijn> Yeah
05:36:13 <Cale> merijn: and then you unify its type variables with the type arguments you got while typechecking the scrutinee, right?
05:36:56 <Cale> Well, the rule in the paper is more to the point
05:37:05 <Cale> it says you extend the context
05:37:14 <merijn> Cale: Well, I first need to check the pattern before I can unify with the scrutinee
05:37:16 <hsk3> main :: IO ()
05:37:16 <hsk3> main = do
05:37:16 <hsk3>     assert False True `seq` return ()
05:37:16 <hsk3>     putStrLn "asdf"
05:37:22 <hsk3> Why doesn't that assert get executed?
05:37:49 <merijn> Cale: Since the type of the constructor is something like 'Proxy : ∀a . a -> a -> ProxyT a' whereas the scrutinee is 'ProxyT x' for some 'x'
05:37:56 <Cale> right...
05:38:25 <Cale> and you might have a pattern like Proxy u v
05:38:27 <hsk3> ah one sec
05:38:35 <opqdonut> hsk3: are you compiling with -O? that turns off asserts
05:39:35 <Cale> and so you typecheck that, and find that u : a and v : a
05:39:45 <hsk3> opqdonut yeah. is there another assert that never turns off?
05:40:03 <Cale> and then you substitute the a in those types with the tau that you got from typechecking e, according to the paper's rule
05:41:16 <opqdonut> hsk3: I guess you can just use throw
05:41:21 <opqdonut> hsk3: or call error
05:41:28 <hsk3> right yeah. thanks
05:42:00 <Cale> and add the types of those variables to the context, while checking that the right hand side of the match has type tau_r
05:42:33 <Cale> (the variables bound by pattern matching)
05:43:22 <Cale> I guess mixing this in with nested patterns gets a little interesting
05:43:50 <Cale> But it shouldn't really be that much more interesting -- you just need to keep track of all the stuff that you'll be adding to the context while checking the pattern recursively
05:44:06 <Cale> hmm
05:47:33 <Cale> merijn: Oh, maybe while checking the pattern, you can already make the substitution of the type parameters for the type arguments obtained while checking e
05:48:02 <Cale> and that might make it simpler to deal with nested patterns rather than doing that later
05:48:11 <Cale> (and having to do unification-y stuff)
05:52:40 <merijn> Cale: What I was doing before, was basically "compute type from pattern, inserting wildcards for the type variables", then unify that with type of the scrutinee and then re-check the pattern know that I know the actual types for the parts of the pattern, but somehow I kept bollocksing that up
05:52:53 <merijn> I think I just need to sit down and stare at this for several hours again
05:54:52 <Cale> merijn: I suppose you can't just replace the types of the constructors in your context, because they need to remain polymorphic in case they're used multiple times at different types in the same pattersn
05:54:55 <Cale> pattern*
05:56:35 <merijn> Ok, the end conclusion is: My approach was probably sound, I just suck at implementing it
05:57:45 <Cale> Cool. Someday I will have to try actually doing this as well. I've only ever thought a bunch about parts of typecheckers, and watched other people implement them.
05:59:58 <merijn> I'm not actually maintaining a context, though. I was using bound to deal with variable capture/substitution. Instead of maintaining a context I'm simply substituting variables with types
06:00:12 <Cale> ahhh
06:00:36 <merijn> Which in some sense is really nice, but in some other sense is horrifically confusing
06:00:59 <merijn> Since my types might have variables to, so you end up with a confusing recursive type for your types
06:16:28 <tobiasBora> When I install stack, I get haskell 7.*, how could I get Haskell 8.* using stack?
06:16:49 <merijn> tobiasBora: Do you have any specific reason for wanting 8.0?
06:17:10 <cocreature> tobiasBora: LTS 7.* is not the same as GHC 7.*
06:17:44 <tobiasBora> merijn: If I remember, 8.0 had better functionnalities for debugging, and since I juste hate how debugging works in haskell, I hoped that upgrading to 8.0 would solve some of my problems
06:18:08 <tobiasBora> cocreature: Well I think that when I installed stack I saw "downloading GHC 7.10"
06:18:20 <cocreature> tobiasBora: it depends on the snapshot you’re working in
06:18:28 <cocreature> at least lts >= 7 should use ghc 8.0 iirc
06:18:36 <geekosaur> at a guess, you have a global stack.yaml from your first install pointing to an old resolver
06:18:58 <geekosaur> you can either remove it and let it be regenerated, or edit it to point to a newer resolver
06:19:29 <tobiasBora> cocreature: Hum... What I did is to install the debin sid haskel-stack, and then run as explained in the documentation "stack upgrade --install-ghc" (or something like this)
06:20:00 <tobiasBora> geekosaur: Hum, maybe I've one that got installed by cabal before, is it supposed to be the same configuration files?
06:20:11 <geekosaur> cabal does not use stack.yaml
06:20:25 <cocreature> tobiasBora: if you don’t care what happens outside of a project, you can just create a new project with a sufficiently new stackage snapshot and run "stack setup" in that directory
06:20:35 <geekosaur> but, with your described commands, the sid haskell-stack might have written out a stack.yaml before upgrading itself
06:20:52 <cocreature> if you do care about what happens outside a project you need to edit the snapshot in ~/.stack/global/stack.yaml
06:20:52 <tobiasBora> geekosaur: hum... where could I find it?
06:21:10 <tobiasBora> cocreature: Yes I care about the "global libraries"
06:22:16 <geekosaur> otherwise it might be new project templates; I don't know offhand how you update those or if they do point to fixed snapshots
06:22:25 <tobiasBora> ok, I removed my .stack file, I'll see what is happening now
06:23:42 <tobiasBora> grrr... I have "Downloaded lts-6.25 build plan.    
06:24:04 <cocreature> just edit ~/.stack/global/stack.yaml
06:24:16 <tumbihe> Hey all:-)
06:24:27 <geekosaur> around now I'd probably be recursively grepping local stack dirs for the string "6.25".... not that I recommend this as a solution
06:24:50 <geekosaur> (rather, "lts-6\.25")
06:26:16 <tobiasBora> geekosaur: I don't have any lts-6* in the files in the .stack folder, nor ~/.stack/global/stack.yaml. Shall I create one?
06:26:47 <cocreature> huh, I thought stack created that automatically
06:27:00 <cocreature> but you can just create it yourself and add a line "resolver: lts-8.3"
06:27:07 <geekosaur> I... don't know. I would actually be hitting the stack docs now to try to figure out where it gets defaults from
06:27:56 <tobiasBora> cocreature: Ok thank you. Would it be possible to specify a general resolver like "pick the latest lts" ? It's very annoying to manually update the files when I want to upgrade
06:28:56 <tobiasBora> grr, I put resolver: lts-8.3 in the file, do stack upgrade, and got: "ghc-7.10.3:    6.51 MiB / 85.53 MiB (  7.61%) downloaded...
06:28:57 <Cale> tobiasBora: You'd be updating much more than your stack.yaml if you did that
06:29:21 <cocreature> tobiasBora: no, the reason why we have snapshots is that they’re supposed to represent a fixed set of packages and thereby guarantee reproducability. allowing something like “pick the latest lts” would defeat that
06:29:44 <Cale> Being randomly hit with a bunch of new version incompatibilities in every package when a new lts came out would be pretty difficult.
06:29:51 <tobiasBora> cocreature: Well, how is it different than manually edit the file?
06:29:58 <cocreature> tobiasBora: maybe stack upgrade does some weird things. what does "stack ghc -- --version" tell you
06:30:39 <cocreature> tobiasBora: oh you want to run a command to update it once. I thought you want stack to always chose the newest stack resolver automatically without doing anything
06:30:54 <cocreature> you can do "stack init --resolver lts" on a new project but I’m not sure about the global project
06:30:58 <Cale> That's what I thought as well
06:31:24 <tobiasBora> cocreature: when I do that it stats downloading the ghc 8.*
06:31:37 <tobiasBora> I'm sorry I need to leave, but I'll be back soon
06:31:44 <tobiasBora> Thank you for your help though
06:31:59 <cocreature> tobiasBora: then everything should be fine. just run "stack upgrade" without --install-ghc and everything should be fine :)
06:38:22 <lpaste_> halogenandtoast pasted “ShouldIUseReader.hs” at http://lpaste.net/353739
06:38:31 <halogenandtoast> Is this something where the Reader monad could be used effectively ^^
06:39:09 <halogenandtoast> I feel like I'm passing the GameState an awful lot
06:40:37 <merijn> halogenandtoast: Looks more like State(T)
06:40:52 <cocreature> I don’t think it does. the game state is never updated
06:41:23 <merijn> cocreature: Not here, but if he plans to loop takeTurn
06:41:40 <cocreature> merijn: oh right
06:44:42 <halogenandtoast> hmm
06:45:21 <halogenandtoast> alright thanks for the info merijn 
06:48:58 <piyush-kurur> anyone tried ATS
06:49:00 <piyush-kurur> ?
06:49:59 <piyush-kurur> the type theory seems very interesting. Might be a better low level language than Rust may be
07:07:19 <jbuurlage> am trying to understand the derivation of Data.Fix (https://hackage.haskell.org/package/data-fix-0.0.3/docs/Data-Fix.html), is it easy to see why the initial algebra has to have this shape? I can see that the usual definition of `cata` gives an arrow to any other F-algebra (which only gives me weak initiality), but is there a constructive proof for
07:07:19 <jbuurlage>  Fix?
07:13:55 <sphinxo> How with quickcheck can I generate a list of strings, and a string not in that list of strings?
07:16:26 <c_wraith> there are a bunch of options.  Do you care if the string's content makes sense?
07:18:48 <sphinxo> c_wraith: nope
07:20:24 <makalu> I can use cabal sandbox add-source to depend on a library that is not on hackage. But what if I want to have a local version of a library that IS on hackage? If I add it with add-source, cabal attempts to build the library twice (I guess because cabal finds it on hackage)
07:21:14 <c_wraith> makalu: at the moment, the best option for that is changing the version in the local copy to something that isn't on hackage, then depending on exactly that version
07:21:33 <makalu> ok that seems reasonable,  thanks
07:21:53 <merijn> c_wraith: I don't think you need even that, since I think add-source has priority over hackage
07:22:07 <lyxia> sphinxo: the probability of two random strings being equal is pretty small, so you can just generate and check.
07:22:08 <merijn> So afaik you only have to pin the version to the one in your local directory
07:22:21 <merijn> The problem is if cabal picks a version that you don't have, but is on hackage
07:22:24 <kylefang> hey guys, quick question, is there any way to split up large files into multiple small files? Do I have to declare module for each file?
07:22:24 <c_wraith> merijn: maybe that was fixed since I complained about it a while back, but it certainly wasn't the case then. :)
07:22:34 <merijn> c_wraith: I'm not 100% sure
07:22:54 <merijn> c_wraith: But I've worked with sandbox without changing the version number and it worked for me unless my memory is wrong
07:23:21 <lyxia> kylefang: one module per file, but you can have one that simply reexports many modules.
07:23:54 <lyxia> that way you need only one import for all of them
07:24:10 <kylefang> lyxia: thanks for you reply, :) Also, I'd have to declare all these files in .cabal file right?
07:24:25 <lyxia> yeah
07:24:27 <kylefang> lyxia: seems like a lot of trouble~
07:25:02 <nitrix> ph88^: Added to whitelist. You can try PMing me again :)
07:25:28 <lyxia> kylefang: not really
07:26:49 <kylefang> lyxia: gotcha, thank you. :)
07:28:21 <sphinxo> ok, something more difficult to generate with quickcheck: a string, and a list of strings where the single string is a arbitrary combination of strings in the list of strings?
07:29:17 <shapr> oneof ?
07:29:47 <shapr> sphinxo: https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck.html#g:6
07:30:09 <sphinxo> Thanks, that looks handy
07:34:17 <blueonyx> hi, whats the "-" function to use in this case: map ((-3).length) foo
07:34:38 <c_wraith> subtract
07:34:49 <Raddamu> Take away
07:35:08 <blueonyx> kthx
07:35:12 <Raddamu> How does map work
07:35:12 <c_wraith> That's the worst wart in Haskell's syntax, but I don't have a better solution.
07:35:19 <c_wraith> @src map
07:35:19 <lambdabot> map _ []     = []
07:35:19 <lambdabot> map f (x:xs) = f x : map f xs
07:35:20 <Raddamu> I am noob
07:37:04 <c_wraith> map creates a new list by applying a function to every element of a list
07:37:30 <Raddamu> Ty
07:37:53 <_sras_> does using a writerT leak memory for long running processes? How can it be prevented?
07:38:30 <c_wraith> _sras_: WriterT cannot be made strict in the values being accumulated.  This can in some cases result in a leak.
07:39:04 <c_wraith> _sras_: the workaround is to use StateT with a restricted interface, which can be made strict in the values being accumulated.
07:39:16 <Raddamu> Wat about lambda expressions
07:40:06 <Raddamu> Its a function with no name
07:40:25 <c_wraith> lambda expressions are a way to define a function without naming it.  It's mostly useful if you're about to pass that function to something else.
07:41:21 <c_wraith> for instance, map's first argument is a function.  It's common to pass a lambda as the first argument to map, if it needs something a bit more complicated.
07:41:35 <c_wraith> > map (\x -> x * 2 + 3) [1..10]
07:41:37 <lambdabot>  [5,7,9,11,13,15,17,19,21,23]
07:44:00 <c_wraith> _sras_: you'd do something like replacing "tell foo" with "modify' (\x -> mappend x foo)", if you need the value to be accumulated more strictly
07:45:06 <_sras_> c_wraith: Yes. I guess there is no issue if I evaluate the log periodically, right?
07:45:34 <c_wraith> _sras_: that would also work.  It depends on your needs, of course. :)
07:57:41 <Aruro> is it possible to define several modules in one file? if not why
07:59:50 <geekosaur> not currently, and because (a) the Report doesn't specify it (b) there's no well defined way to go from a module specifier to an actual module (if you have "import Foo.Bar" it is not going to look for a definition of module Bar in Foo.hi, it will look for Foo/Bar.hi (ghc also tries Foo.Bar.hi for some reason)
07:59:50 <merijn> Aruro: No and "because things weren't defined to work that way"
08:00:09 <merijn> I Don't actually think having multiple modules per file as actually against the report, but no compiler implements that
08:00:29 <merijn> geekosaur: Well, why *wouldn't* it try "Foo.Bar.hi"?
08:00:41 <shapr> if you want to be pedantic, template haskell splices can do it, but ...
08:00:52 <geekosaur> and "fi not why" sounds like "this should be basic functionality" which pretends that nobody (as opposed to, uh, pretty much *everybody*) has ever had a problem with mapping semantic modules to filesystem objects
08:01:06 <Aruro> i mean maybe question is more broad, why directory structure is imposed on the project?
08:01:14 <merijn> geekosaur: Well, the main problem is that the Report refuses to specify this mapping
08:01:28 <geekosaur> some languages have registries that try to deal with that... which means now you get to deal with registries, especially when they break
08:01:55 <Aruro> additionally is is possible to include cabal file in the same multi module file?
08:02:03 <geekosaur> because you'd like to be able to actually find things without having to read the entire project and build maps for it up front?
08:02:05 <merijn> geekosaur: What we have now is a "pseudo" spec of this mapping, where all tools *assume* GHC's mapping
08:02:41 <merijn> I'd much rather have the spec specify the behaviour so tools are portable
08:02:57 <Aruro> is there conceptual problem of working with one potentially big file?
08:03:40 <Aruro> like a latex book, cabal is intro and modules are chapters
08:04:04 <geekosaur> only experience of decades that that rapidly becomes unmaintainable, especially in a shared context
08:04:23 <shapr> Aruro: You could use the LaTeX literate Haskell, but I still don't think that gets you separate modules in the same file.
08:04:25 <miskomali12> Hello there. I dont know if im in the correct channel, if not please let me know or tell which one would be better. I'm looking for danish people that has english knowledge, im looking to export WINEs from my country to denmark. Need recommendation or bussiness agents or so. Anybody knows something i pay in advance paypal or skrill. thanks
08:04:43 --- mode: ChanServ set +o shapr
08:04:47 --- kick: miskomali12 was kicked by shapr (Kicked by shapr)
08:04:51 <merijn> Latex isn't normally written in a single file either
08:04:57 <geekosaur> (likewise I know of few large ... that)
08:05:00 --- mode: shapr set -o shapr
08:05:17 <geekosaur> every latex doc of ore than a few pages I've seen uses subdocuments
08:05:19 <Aruro> well simple file has its advantages, easier to distribute?
08:05:35 <merijn> Aruro: Why would you distribute source anyway?
08:05:44 <merijn> Just distribute binaries
08:05:50 <merijn> "just"
08:05:52 <merijn> :p
08:06:05 <quchen> merijn: Like a tarball including a compiler and everything!
08:06:43 <Aruro> is compiler plugin for ghc up the tast to make multimodule single file support?
08:07:02 <shapr> Aruro: you could probably do it, but I don't know if anyone would use it.
08:07:18 <merijn> Aruro: Why would you go through the huge effort?
08:07:48 <geekosaur> this feels like shaving huge yak to save a tiny amount of exra work
08:08:29 <merijn> geekosaur: Possibly negative amount of extra work, since the single file itself might introduce added work with regards to merging changes, etc.
08:08:48 <geekosaur> that one seems to have already been discounted/ignored
08:09:28 <shapr> Aruro: have you tried writing Haskell with the existing module per file structure? If yes, what were the downsides?
08:10:16 <Aruro> what is community agreement on reasonable module size (number of lines) ?
08:10:52 <merijn> ha!
08:10:59 <merijn> Community agreement in Haskell
08:11:06 <Aruro> shapr: i did, i dont like fragmentation, hard to keep track of whole project structure
08:11:20 <quchen> Try to stay below 1000.
08:11:27 <Aruro> then all the hussle with jumping between different files
08:11:31 <c_wraith> I don't even try to keep functions below 1000. :P
08:11:39 <shapr> Aruro: Have you tried intero and using that to jump to definition?
08:11:57 <Aruro> shapr: yes, haskell-mode can do it too
08:12:04 <Aruro> but it needs ghci to load project
08:12:17 <quchen> c_wraith: Hah, you must be using newlines
08:12:32 <c_wraith> quchen: my greatest weakness
08:13:22 <quchen> c_wraith: I learned from the best, and defined my own trigraphs. My files have two lines, a GHC preprocessor directive and then the source.
08:13:39 <quchen> If you see ???????????? in my code, that’s a newline. I insert them occasionally for readability.
08:14:21 <shapr> Aruro: so, still frustrating when you can jump to the definition and get the type signature?
08:15:03 <merijn> Anyone know if there's an intero for vim yet?
08:15:09 <c_wraith> Aruro: the best approach is to put things together that belong together, and separate things that don't.  Unfortunately, you need to be experienced with Haskell before that starts making sense.
08:16:23 <Aruro> shapr: certainly jumping to def helps a lot
08:16:34 <merijn> c_wraith: Isn't it "put all types and classes in one file and weep", rather than grouping things belonging together together
08:17:11 <c_wraith> merijn: after banging your head on that wall long enough, you believe they all belong together.
08:17:39 <merijn> One of the few aspects where I wish GHC was more Report conformant >.<
08:17:58 <c_wraith> Yeah, actually supporting mutually recursive modules would be nice
08:18:44 <shapr> Aruro: are you using M-. and M-* to jump to def and jump back?
08:18:52 <Aruro> yes
08:19:29 <fendor> Hello everyone! has someone an idea when GHC will support LVM version 3.9?
08:19:47 <Aruro> one thing i would like it orgstruct like functionality
08:19:59 <Aruro> where u can bring any two pieces of code into visual range
08:20:02 <Aruro> on single page
08:20:16 <shapr> fendor: looks like HEAD supports LLVM 3.9: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Backends/LLVM/Installing#LLVMSupport
08:20:42 <merijn> fendor: There's ongoing work for GHC to switch to LLVM microcode, which would make it portable across LLVM versions, but I don't know how far that is
08:20:46 <shapr> Aruro: maybe a larger monitor that can show more text at the same time?
08:21:17 <c_wraith> shapr: next you'll be recommending portrait mode. >_>
08:21:55 <shapr> I've seen edwardk use that to great profit
08:22:14 <shapr> Mind you, he had multiple massive monitors in use at the same time, but that's what got me using 4k screens.
08:22:16 <Aruro> shapr: i do have large monitor :) code should not be linear thats my point
08:22:23 <fendor> shapr, weird, when i try to compile it with -fllvm it still complains about the version
08:22:46 <fendor> merijn, cool! but i think, this does not help me at the moment?
08:23:13 <fendor> merijn, i can just wait for the project to finish?
08:23:47 <shapr> fendor: or put up PRs to speed the project along?
08:23:48 <merijn> fendor: That work is going on in HEAD, so presumably it's going into 8.2 or 8.4, so no it doesn't help you right now
08:24:06 <fendor> shapr, what are PRs?
08:24:09 <merijn> fendor: So you basically have two options: 1) wait, 2) contribute/help test :)
08:24:17 <fendor> merijn, what a pity :/ 
08:24:17 <merijn> fendor: Pull Requests, i.e., patches
08:24:24 <shapr> fendor: pull request, that is... put in your own improvements :-)
08:24:41 <fendor> merijn, i would love to help... but i dont believe in myself enough to do something valuable
08:24:42 <Aruro> shapr: basically orgstruct is something like advanced narrow in emacs you can make visible any parts of code u want
08:24:52 <merijn> fendor: I think investing effort in making it work with 3.9 is wasted effort, given the overall "more flexibility" that's being worked on
08:25:07 <merijn> fendor: depends, are you experienced with the LLVM part of things?
08:25:17 <fendor> merijn, no i'm not^^
08:25:43 <fendor> merijn, i'm merely a software developer for java and haskell
08:25:44 <merijn> ah, then it might be trickier, you could still help test :)
08:26:40 <shapr> fendor: what's the big gain with llvm 3.9?
08:27:07 <fendor> shapr, it's just the version of the OS i'm using and rebuilding everything from scratch seems to be hard
08:27:12 <merijn> shapr: Presumably the big gain is "not needing to have multiple LLVM installs around" :)
08:27:16 <shapr> ah, I see
08:27:52 <merijn> And that installing LLVM can be a pain :)
08:28:39 <fendor> well, yeah... so either wait or do not use it?
08:29:31 <merijn> fendor: Pretty much
08:29:40 <merijn> fendor: Any specific reason you want to use llvm?
08:30:03 <merijn> Because, with the exception of heavy numeric code, the native codegen of GHC is generally better performing
08:32:03 <fendor> merijn, i'm writing my bachelor thesis in performance comparison between c and haskell, and it is requested that i use SIMD instructions and also testing the llvm backend
08:32:14 <boxscape> I'm trying to install sdl2, but there appears to be a problem with the current version where you have to put "cpp-options: [...]" into the .cabal file. Instead of downloading it and changing the .cabal file, could I run "stack install sdl2" with some kind of command line option to do that instead?
08:32:21 <shapr> fendor: oooh, sounds like fun.
08:32:30 <merijn> Ah, yes, then you're boned unless you install the LLVM GHC wants :)
08:32:33 <fendor> also there will be heavy numeric code, so it might make sense ^^^
08:32:40 <fendor> merijn, yeah, sounds like fun :) 
08:32:57 <fendor> any other suggestions to help me with my thesis? for example something i should lokk into? 
08:33:07 <fendor> i will come here often now to ask loads of questions :D 
08:33:22 <fendor> so, prepare yorselves
08:33:50 <merijn> fendor: You might wanna join #numerical-haskell if you're gone do SIMD stuff
08:33:55 <lyxia> boxscape: perhaps you can add a --ghc-options
08:34:04 <merijn> fendor: carter is generally much more aware of that kinda stuff than many others :)
08:34:21 <Tuplanolla> I've worked with AVX for Haskell in the past, fendor.
08:35:13 <fendor> Tuplanolla, how was your experience?
08:35:29 <fendor> merijn, ok i will join the numerical haskell channel, thanks for that suggestion!
08:35:40 <Tuplanolla> Unpleasant but interesting, fendor.
08:35:44 <boxscape> lyxia: that could potentially work, I'll try it, thanks
08:36:07 <Tuplanolla> I have some sparse lecture notes about it here (see `Step10.hs`): https://github.com/Tuplanolla/ties341-profiling
08:37:25 <fendor> Tuplanolla,  thanks! ill read it 
08:39:38 <carter> fendor: are you the new possible simd ghc hacker?  Also yes join my channel :)
08:40:08 <carter> fendor: are you the new possible simd ghc hacker?  Also yes join my channel :)
08:41:32 <fendor> carter, maybe? :D ill join ^^
08:43:33 <carter> Tuplanolla: the lack of real rather than LLvm flavor ops ishe real issue.  I'm pretty convinced that the LLvm generic stuf exists mostly so that auto vectorization optimization is platform independent
08:59:56 <boxscape> ok, so now I did end up downloading sdl2 and installing it from that, but if I use stack build on my project, that requires sdl2, it still wants to install it new. Can I tell stack to use the version I already installed instead?
09:00:22 <boxscape> or rather, it wants to install it again
09:01:09 <mrrec> hi, i have a question about the hatex lib, anyone any experience with it?
09:01:45 <glguy> mrrec: It's better to just ask your actual question.
09:01:48 <lyxia> boxscape: you must add your local version in the extra-deps
09:03:42 <boxscape> lyxia: so just sdl2-<version>? because if I have write sdl2-2.2.0, which should be the one I installed, it still tries to install it
09:03:49 <mrrec> ok, yeah, i want to create a table with fixed width columns, i think i need to use ParColumnBot LaTeX	
09:03:58 <nitrix> metafoobar: I do have an idea in mind that I was to implement in haskell and could be open-source (very little risks there as most people wouldn't understand what it's about anyway).
09:04:41 <nitrix> metafoobar: The only one I keep closed source atm is my trading neural net :)
09:05:10 <mrrec> but im confused by the signature, shouldnt it take an Measure instead of an LaTex type?
09:05:51 <lyxia> boxscape: sorry, add the path to it inpackages
09:08:56 <boxscape> lyxia: works, thanks!
09:11:45 <lyxia> boxscape: packages: [{location: path/sdl2, extra-dep: true}] would be more correct, see https://docs.haskellstack.org/en/stable/yaml_configuration/
09:12:02 <boxscape> ok, thanks
09:32:10 <boxscape> I need a SDL2.dll file at runtime in the directory of the executable; is there any canonical way to do something like that with stack, or should I just copy it into the directory where stack puts the executable?
09:35:43 <boxscape> actually, putting it into that directory doesn't even work
09:36:15 <boxscape> (at least not if I try to run stack exec <exe> from the project dir)
09:36:44 <Boomerang> boxscape: if you use stack exec maybe place it at the top of the project dir
09:39:10 <boxscape> hm, actually, I'm not sure if it works with stack exec at the moment. If I run it manually, it works (i.e. no error message), but it closes itself immediately, so I may actually have a mistake in my source code
09:41:45 <boxscape> Boomerang: ok, you were right, placing it in the project dir works
09:44:50 <Boomerang> boxscape: you should be able to install SDL2 system wide if you need to. Otherwise just keep it there while developing
09:44:57 <Gurkenglas> Does some tool automatically find common patterns and extract them?
09:45:12 <boxscape> Boomerang: Ah, I'll look into that
09:51:13 <Aruro> is there any haskell "ide" which can easily transpose haskell expressions? like transpose elements of list, transpose applicative arguments , etc
10:02:13 <Aruro> is haskell-src-exts a good way to parse haskell file? are there lenses for it?
10:06:35 <shapr> What's the state of using GPUs in Haskell? I just got internet at home and now I'm thinking of setting up a multi-GPU server to run Haskell code, if that's possible.
10:09:22 <shapr> Is Data.Array.Accelerate with accelerate-cuda the best option?
10:09:40 <shapr> Aruro: have you looked at HaRe? the haskell refactorer?
10:10:16 <alanz> Aruro: you might look at ghc-exactprint too
10:10:26 <Aruro> i wanted to install it but then got discouraged because of their use of ghc-mod
10:11:18 <fendor> something bad about ghc-mod?
10:12:27 <Aruro> its huge and scary, takes lots of memory
10:12:47 <shapr> I actually have enough memory at the moment.
10:12:48 <Aruro> i was fun of it untill i realized its very slow and big
10:13:09 <Aruro> now the refactorer which has ghc-mod deps , that can not be fast
10:13:19 <shapr> I don't know of a laptop that supports 128GB of ram, but probably I'll upgrade when I find one.
10:13:33 <Aruro> i have 2gb ram
10:13:41 <shapr> oh, I have 64GB ram
10:14:08 <monochrom> Haha, Richard Eisenberg wrote in haskell-cafe "apologies for a newbie question"...
10:15:35 <MarcelineVQ> from what I've seen ghc-mod only gets heavy when you used it with stack
10:15:36 <shapr> Oh, the bryn mawr prof?
10:15:54 <esennesh> So I've got a pattern functor for a little AST sort of thing, and I want to make a Set of AST values.  How do I define the Eq1 instance I apparently need?
10:16:09 <differentpho> http://imgcash.co/oon4hVr
10:16:35 <lyxia> esennesh: the package generic-deriving can derive it
10:17:01 <shapr> lyxia: aha, one you didn't write!
10:17:15 <shapr> Also, it turns out I don't need generic-random for this project :-(
10:19:09 <lyxia> hmmm I thought it derived it... but I can't find it
10:19:20 <_sras_> What is the standard way to do logging in latest version of the Servant web framework?
10:23:12 <lyxia> esennesh: sorry I was mistaken, you'll probably have to write it by hand
10:25:55 <esennesh> So I tried to write "instance (Eq a) => Eq1 MyTree where"
10:26:12 <esennesh> And got, "Type synonym ‘MyTree’ should have 1 argument, but has been given none"
10:26:30 <esennesh> When I include the "a", I just get the complaint that "MyTree a" has kind * instead of *->*.
10:26:31 <esennesh> Beh
10:27:06 <lyxia> esennesh: http://hackage.haskell.org/package/deriving-compat-0.3.5/docs/Data-Eq-Deriving.html
10:27:33 <lyxia> esennesh: don't use a type synonym
10:27:53 <esennesh> I was getting the same problem with "Fix (MyTreeF a)" though.
10:28:24 <lyxia> I think you should implement Eq1 MyTreeF
10:29:45 <lyxia> Or Eq1 (MyTreeF a), I don't know what kind MyTreeF has
10:30:05 <esennesh> "Expecting one more argument to MyTreeF".
10:30:22 <esennesh> Ok, that finally got the error message to move a line down, thanks.
10:31:06 <lyxia> So the first rule is not to implement instances for type synonyms
10:31:34 <lyxia> Then, Eq1 expects a type of kind (* -> *)
10:32:08 <kyclark> Given this code, how do I extract the “fastaSeq” from each of the FASTA records? http://lpaste.net/353750
10:32:21 <lyxia> esennesh: I'm guessing you defined data MyTreeF a b = ..., so MyTreeF :: * -> * -> * needs to be applied to one argument for that to match the expected kind of Eq1
10:32:59 <esennesh> Yeah, got the compiler to stop complaining.  Thanks for your help!
10:33:01 <lyxia> esennesh: the deriving-compat package I just linked derives the instance in template haskell
10:33:13 <lyxia> yw
10:34:04 <lyxia> kyclark: map fastaSeq (parseFasta fa)
10:38:02 <Aruro> are there lenses for haskell-src-exts package?
10:38:08 <Aruro> how do people work with ast?
10:38:40 <edwardk> Aruro: i don't have any. you can use uniplate/biplate from Data.Data.Lens for some of it
10:38:53 <_sras_> How can I rotate logs when using Network-Wai-Logger with servant?
10:38:58 <cocreature> there is https://hackage.haskell.org/package/haskell-src-exts-prisms
10:39:21 <edwardk> oh neat
10:39:51 <cocreature> it looks like it’s slightly out of date but it’s not that bad
10:41:29 <kyclark> lyxia: I tried that, but I get “Variable not in scope: fastaSeq”
10:41:58 <kyclark> I update the lpaste to show the Data.Fasta.String.Parse module I’m using
10:42:14 <Aruro> edwardk: cocreature: ty, that package has LOTS of prisms :)
10:42:20 <kyclark> I’m struggling just to understand how to use the module when there is no documentation showing basic usage.
10:42:31 <Aruro> cocreature: seems abandoned?
10:42:48 <cocreature> Aruro: yeah looks like it. but bringing it up2date shouldn’t be too bad
10:44:08 <tobiasBora> Hum...
10:44:17 <tobiasBora> Is it possible to install stack for the whole system?
10:44:50 <geekosaur> no
10:45:23 <geekosaur> it would likely need a complete overhaul to be able to manage a global package cache securely across multiple users (or need to be run always as root)
10:45:57 <_sras_> How can I rotate logs when using Network-Wai-Logger with servant?
10:46:50 <theelous3> so, I have a program that bugged out, and won't close with mod+shift+c. I haven't had to deal with this. How kill?
10:47:14 <theelous3> (two instances of thunar)
10:47:38 <Aruro> cocreature: hm, source code has like 95 lines of code :)
10:47:56 <shapr> theelous3: kill -9 on the pid?
10:48:02 <lyxia> kyclark: you need to import a module exporting fastaSeq, like Data.Fasta.String.Types
10:48:24 <lyxia> kyclark: or simply Data.Fasta.String
10:48:26 <shapr> theelous3: or perhaps "killall thunar" ?
10:48:44 <tobiasBora> geekosaur: ok too bad. So If I want to have ghc available for the whole system, I need to install it manually?
10:48:49 <geekosaur> yes
10:48:58 <theelous3> shapr: thanks
10:49:05 <tobiasBora> ok thank you
10:51:00 <kyclark> lyxia: Oh!  Got it, thanks.
10:51:17 <tobiasBora> and so there is no way to have ghc, with given libraries, installed for the whole system
10:51:43 <Aruro> tobiasBora: which system?
10:51:50 <tobiasBora> Aruro: debian sid
10:52:03 <Aruro> why no way? simple cabal+ghc?
10:52:53 * tobiasBora just discovered all the debian libghc-* available!
10:53:26 <ggVGc> "Stack for the whole system" is basically nix isn't it?
10:53:29 <ggVGc> or at least nixpkg
10:53:31 <Aruro> cabal can also install globally for given user
10:54:06 <tobiasBora> Aruro: I'm a bit lost... cabal is not for a given user?
10:54:14 <Aruro> it is
10:54:24 <Aruro> u have ghc and cabal in path
10:54:29 <geekosaur> cabal can even be used for true global installs; it's just a relaly bad idea since you are then dependent on ghc not getting its knickers in a twist over multiple installed versions
10:54:42 <Aruro> then install packages with cabal install MYgratePackage
10:54:54 <Aruro> library(*)
10:55:01 <tobiasBora> Aruro: Well me I mean for all users. For example If I want to share some haskell scripts between several users, I don't want that my 50 users each have their own haskell installation
10:55:20 <geekosaur> tobiasBora, cabal can be used in global, user, or sandbox mode. (new-build etc. are always sandboxed, nix-style, which in practice likely means package caching per user like stack.)
10:55:35 <geekosaur> but cabal won't install ghc for you
10:56:25 <Aruro> tobiasBora: its possible, there are labs with thousands of users and ghc in path
10:56:37 <kyclark> I’d like to use the “hstats” package (https://hackage.haskell.org/package/hstats-0.3/docs/Math-Statistics.html), but when I add “hstats-0.3.0.1” to my “extra-deps” in “stack.yaml,” stack complains “base-4.9.1.0 must match >=3.0 && <4.9 (latest applicable is 4.8.2.0)”.  Does “base” here refer to the Prelude?  Should upgrade/downgrade?  How do I fix this?
10:58:55 <tobiasBora> ggVGc: nix is not dead? It does not receive any update since 2010
10:59:08 <Aruro> kyclark: base is not just prelude, a lot of other modules
10:59:27 <Aruro> tobiasBora: who told u nix is dead?:)
10:59:29 <ggVGc> I didn't know that
10:59:36 <ggVGc> I thought it was growing in popularity
11:00:09 <shapr> I've heard great things about nixOS recently.
11:00:42 <tobiasBora> geekosaur: Hum... Ok. And how do you make the difference between user mode and system mode when you install a package?
11:01:28 <tobiasBora> Aruro: ggVGc : Oh maybe, I think I read "The following old releases of Nixpkgs are available:", and I didn't read the "old", so maybe that's why I saw only 2010 version
11:01:31 <tobiasBora> my bad
11:01:48 <Aruro> yes, its very active
11:02:12 <geekosaur> tobiasBora, --global (and you will need sudo)
11:02:53 <geekosaur> kyclark, a dependency on base is, de facto, a dependency on a specific ghc version (or range thereof)]
11:03:26 <geekosaur> in other words, hstats does not claim to be able to work with your ghc, which is newer than it has been tested with
11:03:44 <geekosaur> you could try --allow-newer=base but no promises
11:04:25 <Aruro> anybody tried guix? they say its inspired by nix
11:04:54 <Aruro> https://www.gnu.org/software/guix/
11:05:25 <tobiasBora> geekosaur: great thant you!
11:08:18 <tobiasBora> Question not related at all: is it possible to install nix on a debian for example, as a non root user?
11:13:02 <carlosdagos> tobiasBora: curl https://nixos.org/nix/install | sh
11:13:44 <carlosdagos> if I'm not mistaken, the nix package manager is "nothing but" a set of bash/perl scripts
11:13:46 <tobiasBora> carlosdagos: according to this site, it creates a /nix/ folder, so I think it's using sudo: https://www.domenkozar.com/2014/01/02/getting-started-with-nix-package-manager/
11:13:49 <carlosdagos> so yes, I'd believe so
11:13:57 <tobiasBora> but I found another website:
11:14:02 <tobiasBora> https://nixos.org/wiki/How_to_install_nix_in_home_%28on_another_distribution%29
11:14:58 <carlosdagos> if you try it it'd be cool to know the result tobiasBora :)
11:15:37 <tobiasBora> carlosdagos: I will try... Hope I won't died soon!
11:18:07 <tobiasBora> "directory /nix does not exist; creating it by running ‘mkdir -m 0755 /nix && chown leo /nix’ using sudo
11:18:09 <tobiasBora> [sudo] Mot de passe de leo : 
11:18:11 <tobiasBora> "
11:19:41 <tobiasBora> "(We cannot use one of the pre-built binaries available on the Nix website because the Nix store path is hard-coded to /nix/store.)"
11:21:52 <tobiasBora> so or I need to compile it, or I rely on pchroot. But anyway, it's a bit offtopic, thank you for your help
11:23:31 <ADG> Hi
11:24:00 <shapr> hello ADG
11:24:34 <ADG> I just started learning haskell and this place was recommended.. I just came in to say hi
11:25:27 <shapr> ADG: this is often a nice place, do you have any questions about Haskell?
11:25:44 <ADG> Not yet i just started thanks btw
11:26:44 <shapr> ADG: are you using stack? Are you learning from haskellbook.com ?
11:27:08 <ADG> http://learnyouahaskell.com/syntax-in-functions
11:27:19 <ADG> Ghci on linux/ubuntu
11:28:37 <shapr> ADG: are you writing something fun/interesting?
11:30:51 <BernhardPosselt> is a promise a monad?
11:32:58 <lyxia> it is
11:33:36 <BernhardPosselt> i suppose the js implementation doesnt match the interface then
11:33:47 <niez> hi, are there any alternatives to reflex-dom or react-flux? what else can be used (is usable) with ghcjs?
11:34:18 <lyxia> BernhardPosselt: how does it not match the interface?
11:34:43 <cocreature> BernhardPosselt: iirc it’s pretty close. "then" is >>= and you can do something like pure
11:34:57 <davean> niez: I'm not the person to ask, but you'll likely get better answers if you say how you'd like them to differ.
11:35:03 <monochrom> What is promise?
11:35:10 <BernhardPosselt> https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise
11:35:19 <BernhardPosselt> is the constructor the pure function?
11:36:00 <davean> BernhardPosselt: not *all* consutructors must be the pure function
11:36:09 <davean> BernhardPosselt: such a pure function must be able to exist
11:36:17 <BernhardPosselt> right i meant pure in the sense of return
11:36:23 <davean> yes
11:36:27 <cocreature> BernhardPosselt: pure creates a promise that resolves immediately
11:36:28 <BernhardPosselt> the thing to put stuff into monads :D
11:36:43 <davean> BernhardPosselt: what cocreature said is also what I was saying if that helps
11:36:46 <davean> I can write a pure for it
11:36:50 <BernhardPosselt> i see
11:37:04 <davean> Not *all* ways of getting data into a monad are "pure/return"
11:37:19 <niez> davean, I just want a list of frontend libs used with ghcjs, so I can evaluate them, I know only about react-flux and reflex-dom, are there any others?
11:37:47 <davean> BernhardPosselt: monad is a minimum required level of structure, not a limit
11:39:47 <davean> BernhardPosselt: Did this help?
11:40:11 <BernhardPosselt> yep
11:40:16 <BernhardPosselt> just couldnt think of the pure function :D
11:41:49 <monochrom> pure x = new Promise( (resolve, reject) => { resolve(x); } )
11:42:10 <monochrom> See also my http://www.vex.net/~trebla/haskell/cont.xhtml
11:43:52 <monochrom> Also praise the person who introduced the (param)=>{body} syntax.
12:02:29 <Aruro> does haskell wiki support book making? like wikibooks?
12:03:01 <Tuplanolla> Probably not. It doesn't even support correct syntax highlighting.
12:04:57 <Aruro> does it sound like good community project for zurihac?
12:05:18 <Aruro> to migrate it to something uSeful
12:17:17 <ph88> can anyone help to figure out the type of this function (line 62) which i can put in my source file? https://bpaste.net/show/1e7cbe17bdf2
12:19:34 <Tuplanolla> Start by stripping the package qualifications, ph88.
12:20:13 <ph88> Tuplanolla, i think i need to use  HasEot
12:20:45 <ph88> also some of the things there are internal to the generics-eot package so i can not use them directly
12:21:34 <Tuplanolla> I'd simplify the type until it matches a known type internal to the package.
12:26:27 <ph88> Tuplanolla, don't know what to do with that comment
12:26:33 <Tuplanolla> Let's see.
12:26:37 <lyxia> your traversal isn't doing anything
12:27:03 <lyxia> and I don't understand why you would want to compose it with toEot
12:27:39 <lyxia> toEot does not output a function.
12:28:01 <ph88> ah ok, maybe the eot should go as second argument to eotTerminal
12:28:26 <Tuplanolla> In general you'd wrangle it into the form `(Constructors g ~ (a -> f a), Rep a ~ M1 D c g) => (Applicative f, HasConstructorsG g, EotTerminal eot, GenericConstructors g, Generic a, Generic b, Datatype c) => a -> eot -> f eot` and try to figure out where the constraints come from.
12:29:01 <lyxia> terminalEot . toEot is nonsense
12:29:19 <Tuplanolla> It's not a substitute to understanding however.
12:32:27 <lyxia> ph88: HasEot defines an isomorphism between a and Eot a, which you can then compose with the traversal.
12:34:02 <ClaudiusMaximus> i have   toDouble :: (Rounding r, Precision p) => Rounded r p -> Double   and i want to have a RULES pragma to use  toDouble  instead of  realToFrac  whenever the types match - is this possible? can't figure out how to put toDouble's constraints into the RULES.. http://lpaste.net/6173391635410321408 
12:45:21 <c_wraith> ClaudiusMaximus: iirc, RULES automatically are type-restricted.  They are applied only when the type after is the same as before.
12:48:00 <ClaudiusMaximus> c_wraith: right, but i get an error (see paste)
12:48:10 <ph88> lyxia, i wanted to use my eotTerminal function instead of the ints function here  https://bpaste.net/show/3d8b69878563
12:48:45 <ph88> lyxia, now i think should apply toEot on value first
12:51:25 <zereraz> hi, here `instance (MonadState m, StateType m ~ EventF) => ` what is the StateType m ~ EventF mean? I have not come across `~`
12:51:54 <lyxia> It means that EventF is the type of states in m
12:53:22 <zereraz> is ~ an operator ?
12:54:14 <zereraz> what do you mean "in m"
12:54:22 <lyxia> Something like that, it is type equality
12:54:52 <zereraz> what is StateType ?
12:55:05 <lyxia> MonadState m means that it is a monad with operations to access a "state". StateType m is the type of that state.
12:55:44 <jle`> zereraz: ~ is type equality, you can use it anywhere
12:56:03 <jle`> @let addTwo :: (a ~ Int) => a -> a; addTwo x = x + 2
12:56:05 <lambdabot>  Defined.
12:56:07 <zereraz> So for any MonadState we have to give a StateType?
12:56:24 <jle`> it depends on how it's implemented
12:56:32 <jle`> > addTwo 3 :: Int
12:56:35 <lambdabot>  5
12:56:38 <zereraz> jle`: got it, why use it? to help the compiler infer?
12:57:02 <jle`> in this case it looks like it's just used as a constraint
12:57:17 <jle`> so you have instance (some constraints) => MyClass Blah
12:57:31 <jle`> it cmeans that Blah is an instance of MyClass, provided that those constraints are satisfied
12:57:37 <zereraz> ok
12:57:47 <zereraz> thanks
12:58:10 <jle`> for example, 'instance Show a => Show (Maybe a)'
12:58:13 <zereraz> and for MonadState we have to give the StateType ?
12:58:22 <jle`> means that 'Maybe a' has a Show instance, as long as a is an instance of Show
12:58:34 <jle`> or alternatively, that having an instance of Show for 'a' implies an instance of Show for (Maybe a)
12:58:39 <jle`> zereraz: that depends on how MonadState is implemented
12:58:40 <zereraz> can we give primitive type constraint without '~' ? 
12:59:05 <jle`> usually, what a typeclass requires is a part of its definition
12:59:13 <jle`> without knowing more about the typeclass, i can't say what it requires
12:59:35 <jle`> like, if you gave me a typeclass 'MyClass' and asked if it required a function 'foo', i wouldn't be able to tell you
12:59:45 <zereraz> ok got it
12:59:46 <jle`> that depends on the methods and contents of the typeclass
12:59:52 <zereraz> I came across it here https://www.schoolofhaskell.com/user/agocorona/a-monad-for-reactive-programming-part-1
13:00:53 <AWizzArd> shapr: My update about pros/cons: I think that there is less need to debugging in Haskell, less need to trace. Things work regularily, when they compile.
13:02:04 <jle`> zereraz: that's interesting that they don't give any context
13:02:13 <jle`> but that MonadState probably comes from the mtl-tf library
13:02:15 <nshepperd> ClaudiusMaximus: it sounds like that can't be done http://stackoverflow.com/questions/19745038/ghc-rewrite-rule-specialising-a-function-for-a-type-class
13:02:16 <jle`> https://hackage.haskell.org/package/mtl-tf-0.1/docs/Control-Monad-State-Class.html
13:02:52 <zereraz> if I want to learn to make my own state monad should I read that source code?
13:03:13 <nshepperd> ClaudiusMaximus: you can specialise to concrete types, but not 'any type with those constraints'
13:03:50 <jle`> zereraz: if you want to learn how to make an instance of that specific typeclass, then you would read the documentation
13:03:58 <jle`> but mtl-tf isn't the normal state monad people use
13:04:10 <zereraz> no just as a concept
13:04:13 <jle`> also, that package doesn't implement any state monads
13:04:21 <jle`> it only provides a unified interface over many different types of state monads
13:04:36 <jle`> so no, it won't help you make a state monad
13:04:59 <jle`> it's like asking "if i want to learn how to implement Integers, should i read the source of the Show typeclass?"
13:05:10 <monochrom> Yes!
13:05:27 <mauke> which is approximately: class Show a where { show :: a -> String }
13:05:32 <mauke> except with more showsPrec
13:05:46 <monochrom> Or rather, the code for "instance Show Integer". It helps you reverse-engineer Integer.
13:05:58 <zereraz> ok thanks
13:07:07 <jle`> zereraz: regarding StateType in specific, it's a type family, which lets you associate a type with each 'm' input.  the purpose is to let you work polymorphically with different monads 'm' that are all 'state monads' in a way
13:07:39 <jle`> so the StateType type family lets you say "ok so for a given monad m, the type of its state is StateType m"
13:07:53 <jle`> it's basically a lot of hoops to go around to let you work polymorphically over many different 'state monads'
13:09:03 <ClaudiusMaximus> nshepperd: thanks, a comment there led me to syntax that compiles:  {-# RULES "realToFrac/toDouble" forall (x :: (Rounding r, Precision p) => Rounded r p) . realToFrac x = toDouble x #-}   still need to check that it is effective...
13:10:34 * ski would be surprised if that syntax worked
13:10:47 <zereraz> jle`: I didn't understand `let you work polymorphically over many different 'state monads'`
13:12:46 <ski> (presumably, the intended type of `x' there would be `Rounded r p', where `(Rounding r,Precision p)' .. which is not at all the same as saying that the type of `x' is `(Rounding r,Precision p) => Rounded r p')
13:16:51 <ClaudiusMaximus> ski: it seems to work, despite the syntax (compiles without error, and the rule fires in one simple test)
13:18:00 <ClaudiusMaximus> ski: now i have the same issue with return value polymorphism in fromDouble, so i can't use that syntax to solve it...
13:21:03 <ph88> lyxia, i try to correct my mistake of the nonsense eotTerminal . toEot function, could you have a look a my new attempt? i put the function on line 103 in the way i think it should be used https://bpaste.net/show/03cf716ce4f0
13:31:33 <ClaudiusMaximus> here's the current error message i am facing with RULES http://lpaste.net/6173391635410321408#a5772563383014391808
13:32:00 <EvanR> project euler eat your heart out... lets say i have 8 24" wide panels with 8 different lengths. the total length somewhat less than 16 feet. but the sheets only come in 8 feet, so we need two. how to allocate the panels to each sheet so we dont need even more than 2
13:32:27 <EvanR> should be a haskell one liner
13:40:23 <nitrix> Curiously, which area could Haskell executables (or more accurately GHC compiled programs), see the most performance improvement?
13:41:37 <ph88> could as in theoretically possible ?
13:41:45 <nitrix> As fancy as the garbage collector is, I've heard a lot of good things about Go's GC.
13:41:49 <EvanR> SIMD support?
13:41:53 <nshepperd> ClaudiusMaximus: yeah, I saw that too, but I couldn't get it to actually fire...
13:41:59 <nitrix> ph88: As in what you'd like to see happen.
13:42:40 <ph88> no gc ofcourse
13:45:39 <yushyin> nitrix: did you also heard the bad parts about Go’s GC?
13:45:49 <ClaudiusMaximus> nshepperd: it fires here in a simple test, as reported by  -ddump-rule-firings
13:45:58 <mbw> In the wreq tutorial http://www.serpentine.com/wreq/tutorial.html under "Uploading data via POST", they give an example using (:=), which is the only constructor for the "FormParam" data type https://hackage.haskell.org/package/wreq-0.5.0.0/docs/Network-Wreq.html#t:FormParam . While the example works in ghci, in a source file I have to add type signatures, otherwise it gives me an error about ambiguous types 
13:46:04 <mbw> preventing the constraint FormValue from being resolved. Is there a way around having to write this: r <- post (sampleURL ++ "post") [("num" :: B.ByteString) := (3 :: Integer), ("str" :: B.ByteString) := ("wat" :: B.ByteString)] ?
13:46:09 <nitrix> yushyin: I'd love to.
13:46:32 <nitrix> Can Haskell even work without a GC?
13:46:39 <ph88> no
13:46:45 <nitrix> Everything would turn into reference counting?
13:47:27 <yushyin> nitrix: maybe this for starters https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e#.vdkcqhuw8
13:47:29 <EvanR> haskell can easily work without a gc
13:47:33 <EvanR> if you have infinite memory
13:47:44 <ph88> easily
13:47:46 <lyxia> mbw: you only need to specify the second one
13:47:59 <EvanR> or if the program has a very short runtime
13:49:05 <lyxia> mbw: and I can't think of a way not to specify it
13:49:56 <Guest33694> What do you guys think about commercial stalking?
13:50:40 <glguy> Guest33694: Did you have a question about Haskell programming?
13:51:42 <nitrix> EvanR: What makes it need a GC so much? The thunks?
13:51:51 <nitrix> EvanR: And lambda capturing environments?
13:52:49 <mbw> lyxia: I have tried all the combinations though, and it will only shut up after having specified _all_ the types...
13:53:18 <lyxia> mbw: What error do you get on "num" := (3 :: Integer)
13:54:58 <mbw> lyxia: None iff it is the only list element
13:55:44 <lyxia> uh... what if you put another one?
13:57:41 <mbw> Then I have to specify the other rhs's of (:=) as well. Otherwise: Ambiguous type variable ‘v0’ arising from a use of ‘:=’ prevents the constraint ‘(FormValue v0)’ from being solved [...] .
13:59:20 <mbw> This is kinda surprising with Integer, since I don't have NoMonomorphismRestriction enabled...
13:59:24 <lyxia> You must annotate the second argument, because there's no other way to tell its type for overloaded literals
13:59:40 <lyxia> this has nothing to do with the monomorphism restriction
13:59:49 <mbw> I thought it'd just default to Integer.
13:59:51 <lyxia> but you don't need to annotate the first one at least
14:00:12 <lyxia> ["num" := (3 :: Integer), "str" := ("wat :: B.ByteString)]
14:00:28 <monochrom> Both defaulting and the monomorphism restriction come with fragile preconditions too.
14:00:49 <monochrom> i.e., there are ways you can introduce class contraints to kill even defaulting.
14:02:59 <mbw> I guess I will just have to live with it :/
14:03:47 <lyxia> you could define synonyms of (:=) with specialized types
14:04:23 <lyxia> it's just going to be another way of specifying the type you want
14:05:20 <mbw> That's not a bad idea at all.
14:06:18 <merijn> I just opened some code I haven't touched in a year...I'm completely lost wrt what the hell I was doing >.>
14:06:44 <Rembane> Does it work?
14:07:11 <mbw> Sounds pointless.
14:07:14 <merijn> Rembane: Well no, it was broken then and I don't remember which parts I ripped up trying to fix it xD
14:07:57 <Rembane> merijn: Ah one of those codebases, between states. They are fascinating. :)
14:08:49 <dat_toy> can someone tell me what the order of `id` is?
14:09:05 <dat_toy> can't find it anywhere.. I guess it's about \infty
14:09:25 <lyxia> what's an order
14:09:40 <merijn> Relatedly, I could use some tips, I have an AST type which stores annotations (specifically: source location, variable names) but for some operations (e.g. equality) it'd be better to not have those, but I'm unsure how to cleanly accomodate that
14:10:43 <dat_toy> well, a constant has order 0, a function taking Int's or such as arguments has order 1, a function taking a function as argument has order 2 (eg. map) etc.
14:10:47 <ski> the order of an element in a group is the least number of times you have to multiply it with itself, in order to get the neutral element
14:11:32 <dat_toy> as in higher order function, or first-order logic
14:11:32 <ski> in this case, `id :: a -> a' is itself the neutral element of the group of bijections over `a', so the order would be one, then ..
14:11:48 <lyxia> well looks like it's not about group theory.
14:12:09 <dat_toy> no it's not about group theory
14:12:38 <ski> oh. then the order is `n', for any positive integer `n'
14:13:10 <dat_toy> okay ^^
14:13:20 <dat_toy> so you mean it depends on the context
14:13:21 <ski> the order of `id :: Bool -> Bool' is one. the order of `id :: (Integer -> Bool) -> (Integer -> Bool)' is two, &c.
14:13:50 <mathk> Hi all, would it make sense to implement actor model in haskell?
14:13:52 <dat_toy> that  would be an answer that makes sense, I guess
14:14:00 <lyxia> "order" has lots of different meanings indeed.
14:15:05 <seequ_> Well, I guess you could argue it's first order function as it just returns the value untouched without caring what it is. It could be a function, but doesn't need to be.
14:15:25 <dat_toy> yeah, I know. sry for being unclear
14:17:03 <ski> yeah, one could argue that `id :: forall a. a -> a' has order one
14:17:09 <ski> `id :: a -> a', otoh ..
14:19:08 <dat_toy> but if I `let a = id`, clearly it takes a first order function as argument and it is thus 2nd order, no?
14:19:18 <dat_toy> otoh?
14:19:29 <merijn> dat_toy: that doesn't have any arguments
14:20:34 <dat_toy> true, also I think one cannot apply functions to itself :S
14:21:00 <dat_toy> so if we `let a = (\ x -> x+1)` then
14:21:09 <merijn> :t id id
14:21:11 <lambdabot> a -> a
14:21:17 <merijn> Sure you can
14:21:55 <monochrom> That gets us into "what is itself?"
14:22:12 <seequ_> :t fix id
14:22:14 <lambdabot> a
14:31:04 <ertes> mathk: it's pretty much in the base library
14:32:04 <ertes> mathk: threads can send each other messages via MVar or TChan
14:32:30 <mathk> in which module  ?
14:38:00 <ertes> mathk: Control.Concurrent gives you threads ("actors") and MVars (communication channels)
14:38:16 <ertes> mathk: in fact most of the time i suggest using the async library instead
14:38:31 <ertes> it gives you easier control over thread termination
14:40:06 <ertes> MVar is like a channel bounded to one message, so if the reader can't keep up, writers will block…  if you want non-blocking message sends in exchange for overall performance, you can use STM:  Control.Concurrent.STM.TChan
14:41:37 <ertes> actually Chan is good enough
14:41:44 <ertes> Control.Concurrent.Chan
14:42:56 <mathk> were is the async lib? in base library ?
14:43:14 <ertes> https://hackage.haskell.org/package/async
14:44:02 <mathk> But actor can be distributed can you have that with MVar / TChan ?
14:45:28 <ertes> nope, it's all single-process…  there are efforts to make this distributed like the distributed-process library (a.k.a. "cloud haskell")
14:46:07 <ertes> or manually: of course a thread can serialise messages and send them through a socket to some other process
14:46:24 <ertes> but it's not built into the concurrency framework
14:47:21 <ertes> https://haskell-distributed.github.io/
14:47:59 <mathk> yes and you would need to have away to queue message.
14:49:32 <ertes> you will have that in both cases…  for example in the manual case you have an MVar that communicates with the "local correspondent" thread that sends your message through a socket to another process, which on its end has a correspondent thread that unserialises the message and puts it into an MVar
14:49:59 <ertes> cloud haskell streamlines this…  remote listeners appear much like local MVars
14:50:55 <ertes> and it also provides an RPC-like framework, so you can actually call functions in remote processes directly
14:51:47 <kyclark> Given a string like “0123” I’d like to create a list of integers [0,1,2,3] — how?  I would have thought “map read "0123" :: [Int]” or “map (\x -> read x :: Int) "0123”” would have worked, but they don’t (“Couldn't match type ‘Char’ with ‘[Char]’”).  “map show "0123”” does what I would expect.  Why doesn’t “read"?
14:51:59 <mathk> interesting. Does it have also some back pressure implementation ?
14:52:23 <merijn> :t map read
14:52:25 <lambdabot> Read b => [String] -> [b]
14:52:29 <merijn> kyclark: ^^
14:52:41 <ertes> kyclark: you can first map each character to a string, and *then* use read
14:52:45 <merijn> kyclark: "map read" expects [String], but you're giving it String
14:52:53 <ertes> mathk: could you summarise what that is?
14:52:58 <merijn> And since String == [Char]
14:53:04 <merijn> You're trying to apply 'read' to a Char
14:53:06 <merijn> :t read
14:53:07 <lambdabot> Read a => String -> a
14:53:11 <merijn> Which is a type error
14:53:23 <ertes> merijn: hi!  i wanted to ask you, if you have any experience with vulkan compute and how it compares to CUDA in terms of performance
14:53:43 <merijn> ertes: back pressure == slow down senders if rate of sending exceeds rate of handling
14:53:57 <merijn> ertes: Usually implemented via, e.g. a fixed size buffer and blocking sends
14:54:08 <merijn> I haven't used vulkan, no
14:54:31 <ertes> mathk: ah, i don't know…  you can certainly implement back pressure yourself on top of TBQueue
14:54:34 <ertes> which is a bounded queue
14:54:49 <Tuplanolla> Back pressure is a silly term, because it's often on the opposite side in fluid mechanics.
14:54:50 <merijn> ertes: As for vulkan, I don't think it's comparable to CUDA?
14:54:57 <mathk> merijn: blocking sends imply that you have a way to signal to the sender from the receiver.
14:54:59 <merijn> ertes: AFAIK Vulkan is mostly aimed at doing graphics
14:55:29 <ertes> merijn: it seems to have a full compute API…  you can choose not to use any of the graphics chains
14:55:55 <ertes> so it's not graphics-only
14:56:49 <ertes> this might be a way to have fast compute across many GPUs, i.e. what OpenCL wanted and failed to be
14:57:33 <merijn> ertes: Honestly, I haven't really looked into it, since the non-NVidia GPUs aren't really worth getting anyway :)
14:58:40 <merijn> ertes: Most sources seem to say "The point of Vulkan's compute pipeline is to provide compute facilities for rendering operations. Despite the ridiculous tagline, Vulkan is not trying to compete with OpenCL. "
14:59:37 <merijn> OpenCL 2.x would be ok, but I'm *still* not aware of anyone actually implementing anything other than OpenCL 1.2
14:59:42 <ertes> merijn: well, the point of this is to have fast compute everywhere, not necessarily for special applications
15:00:14 <ertes> for example applications could use compute on the laptop to save power, not necessarily to be done faster
15:01:35 <merijn> ertes: Anyway, consensus seems to be still OpenCL for compute if you want portability
15:01:39 <Tuplanolla> I have no doubt both 3d graphics and hpc will remain extremely messy.
15:02:09 <ertes> merijn: even CL 1.2 over vulkan?
15:02:52 <Tuplanolla> This keeps happening: https://softwareengineering.stackexchange.com/a/88055
15:03:24 <merijn> oh, there seems to be some CL2.0 support now
15:04:58 <merijn> Tuplanolla: Well, it's more an issue of: OpenCL 2.0 is catching up with features CUDA had like 5 years ago, and since OpenCL is ugly as sin and painful to use and the performance of non-NVidia cards is trash anyway no one cares about OpenCL
15:07:13 <ertes> CL is a mess though
15:07:22 <merijn> There's basically 3 vendors "supporting" OpenCL in the PC/server market: Intel (they don't care, only support it to be compatible, use OpenMP/Intel TBB if you want performance/programmability), NVidia (they don't care, only support it for compatability, if you want performance/programmability, use CUDA) and AMD (they care, since it's the only thing they have). But since the other 2 have no real incentive 
15:07:28 <merijn> to improve OpenCL we have the ugly mess that it is now
15:07:47 <ertes> what a lot of people don't know is that vulkan is not GPU-only either…  if a device provides only compute, it can only offer the compute chain
15:07:55 <ertes> so in principle it could work for FPGAs as well
15:08:08 <merijn> I'll believe that when I see it
15:08:17 <merijn> If you wanted to do FPGA stuff, get Clash ;)
15:08:42 <ertes> FPGAs are too expensive…  and i don't really have a use case for them =)
15:09:00 <merijn> ertes: But with Clash you can program them in Haskell!
15:09:20 <davean> ertes: uh, does an FPGA really support vulcan's compute model?
15:09:36 <merijn> davean: That's another good question
15:09:45 <merijn> I don't see compute that maps well to GPU mapping well to FPGA
15:10:24 <ertes> i'm not sure…  all i know is that it's not GPU-exclusive
15:10:28 <thoughtpolice> You can get an FPGA with a fully open source toolchain for $50 with like, 30 GPIO pins and ~8k LUTs. More than enough for some surprisingly useful designs, without having to use horrid EDA tools or break the bank.
15:10:53 <thoughtpolice> Hell, $20 if you're willing to go to PMOD and can get away with 1k LUTs. That's enough for an entire low-speed logic analyzer.
15:10:59 <davean> thoughtpolice: yes, but do they run Haskell?
15:11:14 <merijn> davean: They don't need to run Haskell, you just compile haskell to VHDL :)
15:11:17 <thoughtpolice> Yes. Clash works fine on them. I only write my circuits in Clash, in fact. (And I'd argue Clash is indeed Haskell)
15:11:29 <davean> merijn: Yes, but my current Haskell is GHC
15:11:52 <davean> merijn: can I use and FPGA to compile Haskell faster?
15:12:14 <merijn> thoughtpolice: If you have any feedback for them, I'm pretty confident I'm seeing the Clash guys tomorrow :p
15:12:41 <merijn> davean: Honestly, I don't think FPGA are any help for compilation type work
15:12:48 <davean> merijn: I don't either!
15:12:49 <thoughtpolice> I've talked to Christiaan quite a bit already (in #clash-lang actually, there's a whole 1 dozen of us in there!)
15:13:14 <davean> merijn: actually, I *would* be interested in SHA1-on-FPGA probably
15:13:32 <davean> merijn: but why be practical?
15:13:42 <mckeankylej> What is the failure constraint in constraint kinds? I want to have: `type family Elem (x :: a) (xs :: [a]) :: Constraint` but I dont know what to put when the value is not found in the list
15:14:04 <merijn> mckeankylej: There isn't one, sadly
15:14:07 <merijn> mckeankylej: But!
15:14:14 <mckeankylej> lol Int ~ Bool
15:14:25 <mckeankylej> failure constraint xD
15:14:25 <merijn> mckeankylej: https://gist.github.com/merijn/6130082
15:14:41 <merijn> That, yes, but using Symbol it can be slightly more helpful
15:14:45 <mckeankylej> merijn: I love that idea
15:14:51 <mckeankylej> thanks!
15:15:13 <ertes> davean: FPGAs aren't *faster*, they are just *more parallel* with the unique feature: the smaller your algorithm, the more parallelism you get
15:15:27 <ertes> so there is an incentive to run *small* algorithms on FPGAs
15:15:33 <davean> ertes: yes, but I want to do an embarasing number of them
15:15:38 <davean> SHA1 looks small to me :-p
15:15:46 <merijn> ertes: Not necessarily more parallel
15:15:57 <merijn> ertes: FPGA work well with pipelined computation
15:16:08 <merijn> Especially with little state flowing between sections
15:16:27 <davean> I want to run billions of related SHA1 computations
15:16:51 <merijn> ertes: Duplicating the same pipeline a lot for parallelism is, arguably, one of the least efficient ways to use FPGAs
15:17:10 <merijn> ertes: It's far more efficient to have a single huge computation on there, if you can pipeline it nicely
15:17:34 <ertes> davean: bitcoin mining isn't really that profitable anymore ;)
15:17:37 <merijn> Because we already have GPU being awesome at duplicated computation
15:18:22 <davean> ertes: bitcoin?
15:19:56 <ertes> well, you seemed interested in SHA-1, and i'm not aware of any altcoins that use it =)
15:20:10 <davean> I have no idea why you're on coins
15:20:12 <hsk3> Is it possible to put "data Foo = ..." into a function scope?
15:20:17 <hsk3> for use only in the func
15:20:26 <ertes> davean: i'm kidding
15:20:32 <davean> ertes: I'm just confused
15:20:47 <ertes> hsk3: nope
15:21:10 <ertes> hsk3: only module-local types are possible
15:21:18 <hsk3> ok thanks
15:25:51 <newbie21> Hi, so I am trying to do some neural network example in Haskell.
15:27:31 <lolisa> So I need to generate some weight. For type safety reason they are stored in an existential type (but is actually tuple of tuple of ... of Double).
15:28:41 <lolisa> Now I need to generate some random value as initial weight. However I do not want to include dependency Test.QuickCheck merely for Test.QuickCheck.Gen. Is there a smaller equivalent?
15:28:55 <ertes> lolisa: mwc-random
15:29:21 <ertes> it's a super-fast generator, and if you use the 'vector' API instead of tuples, it will also generate a whole vector of randoms for you
15:30:47 <Tuplanolla> The speed must be Haskell-specific, because when I tested its C implementation against GSL's MT, they were equally fast.
15:31:33 <ph88> i have here an infered type signature from ghci that is using a package internal types which i can not use directly, how can i find out what types to put in my own source code?  https://bpaste.net/show/03cf716ce4f0
15:31:45 <ph88> Tuplanolla, i didn't understand your suggested method last time
15:32:32 <Tuplanolla> Then you're better off not using it, no?
15:32:36 <ertes> Tuplanolla: i don't know how it compares to GSL's MT, but it's faster than the mersenne-random library
15:32:59 <ph88> Tuplanolla, are you talking to me ?
15:33:03 <lolisa> eretes, I am planning to do vector, but I do not wanna drop type safety, so it'd be a bit hard.
15:33:10 <Tuplanolla> Yes, ph88.
15:33:16 <lolisa> But thx, (Variate a, Variate b) => Variate (a, b) is exactly what I need
15:33:33 <ertes> lolisa: type safety in which sense?
15:33:39 <ph88> Tuplanolla, i'm trying to get this code to work and i don't have a good alternative
15:35:18 <lolisa> ertes, access to weight are safe (there will always be enough weights). It can be done by dependent type vector, but now I'm building a prototype.
15:35:53 <ertes> lolisa: i'd just consider vectors to be sparse…  just assume that they denote infinite-dimensional vectors
15:36:08 <Tuplanolla> The gist of my suggestion was to convert the type into some sort of normal form (common ordering and naming conventions) and then try to pattern match it to existing constraints and type synonyms, ph88.
15:36:53 <lolisa> ertes, that's a good idea, thx :)
15:37:16 <ertes> lolisa: then dot products are simply:  V.foldl' (+) b (V.zipWith (*) xs ys)  -- where b is bias
15:37:33 <ph88> Tuplanolla, what do you mean "common ordering and naming conventions" ?
15:37:48 <ertes> lolisa: you will need to write a custom function for vector sums, but i have a ready-made one…  if you want, i can paste it
15:38:38 <lolisa> Nah, I can do that. But how do I take second derivative though
15:38:56 <Tuplanolla> If you had, say, `(Coercible (p (First a) c) (p (Maybe a) c), Bifunctor p, MonadReader r m) => ((Maybe a1 -> (First a1, Maybe a2)) -> r -> p (First a) c) -> m (p (Maybe a) c)`, which I recently encountered...
15:39:20 <Tuplanolla> ...you could rename `a1` to `a`, move `MonadReader` before `Bifunctor` and so on and recognize that it's actually an expanded and overgeneralized form of `LensLike ((,) (First a)) r t (Maybe a) (Maybe b) -> m (Maybe a, t)`.
15:39:59 <ertes> lolisa: in fact i have a whole class for that in my machine learning framework (which is currently not public)
15:40:02 <Tuplanolla> It's difficult and tedious, but might eventually get you the type you really want.
15:40:03 <ertes> lolisa: https://gist.github.com/esoeylemez/9fd04bed62f5876f5c08b6075f997ac6
15:40:10 <ph88> how can you rename a1 to a when a is already used ?
15:40:28 <ertes> lolisa: it's an implementation of this sparse vector idea for a lot of types, including IntMap, HashMap, etc.
15:40:51 <Tuplanolla> It was unnecessarily general in the first place, ph88.
15:41:07 <ertes> lolisa: (currently it doesn't use the new .Merge API of containers, but i will fix that soon)
15:41:14 <Tuplanolla> I had to make some assumptions.
15:43:59 <hsk3> Is it valid to do seq (z1, z2) ...
15:44:06 <hsk3> to make sure both z1 and z2 are computed
15:44:17 <ertes> hsk3: it's valid, but doesn't achieve what you want
15:44:24 <ertes> it only makes sure the *tuple* is evaluated
15:44:31 <hsk3> ah
15:44:36 <ertes> hsk3: z1 `seq` z2 `seq` …
15:44:42 <hsk3> ah i see, thank you
15:45:39 <lolisa> ertes, I see, but can one do jacobian matrix with infinite stream of Double?
15:47:16 <ertes> lolisa: depends on the function
15:47:37 <ertes> lolisa: in general no
15:49:14 <lolisa> I dont quite get it. can you give an example?
15:54:40 <ertes> lolisa: let f xs = map (^2) xs…  then jac f i j = ∂ (xs !! i)^2 / ∂ (xs !! j) | i == j = 2*(xs !! i) | otherwise = 0
15:55:12 <ertes> lolisa: you can certainly not compute an actual in-memory matrix, but you can represent this matrix as a function and that should work for most functions
15:55:54 <lolisa> Yes, what about the 'in general no' part?
16:05:15 <tobiasBora> Hello,
16:06:36 <tobiasBora> I don't like the [0..n-1] syntax because it does not follow the basic idea of "you count from 0", I really prefer the python syntax range(n) to denote [0..n-1]. Is there any haskell equivalent, or reason not to use it?
16:06:43 <kamyar> hello everyone!
16:07:32 <kamyar> I wanna start an open source project for Haskell language server.
16:07:37 <isd> tobiasBora: not sure if there's a handy function in the standard library, but you could always define it: range n = [0..n-1]
16:07:44 <hpc> tobiasBora: it's veeeeeeeeeeery rare that a loop of that style is the most natural way to write an algorithm in haskell
16:08:16 <kamyar> Any volunteers to help me?
16:08:26 <isd> That said, I'd discourage pulling notation from other languages because the agreed-upon style is not to your taste. In general, best to just live with the style.
16:08:45 <hpc> i did it a fair bit while learning haskell, but eventually it just gets pushed out of your brain by other methods
16:08:48 <isd> kamyar: not sure what you mean?
16:09:35 <hpc> tobiasBora: my advice would be that it's annoying for a good reason (that reason being it's not useful enough to make not annoying)
16:09:41 <kamyar> isd: just search for lang server
16:10:13 <hpc> tobiasBora: and if you're anything like me, it'll annoy you enough that you look for alternatives
16:10:19 <hpc> tobiasBora: and find they are much better :D
16:10:27 <isd> Ah, I see
16:10:30 <isd> neat.
16:10:30 <kamyar> We lack language server up to now
16:10:42 <isd> kamyar: I have far too many projects in my queue, but I wish you luck.
16:11:56 <kamyar> isd: Ok so you can keep in touch to help me since I am not so pro in haskell
16:11:59 <ertes> lolisa: actually i might be wrong, but if the function is some kind of convolution…
16:12:21 <Koterpillar> kamyar: isn't intero one?
16:12:36 <isd> kamyar: I consider myself an advanced beginner/early intermediate, but I'll hang out here, and I'm sure many others will be happy to field questions as you hit them.
16:12:44 <ertes> lolisa: so far i only needed gradients, and that's definitely possible
16:13:16 <ertes> tobiasBora: take n [0..]
16:13:37 <tobiasBora> hpc: So what is your want to compute the 100 first squares, included 0, if you don't do a map/list comprehension on [1..n] ?
16:14:06 <tobiasBora> ertes: take n [0..] is efficient?
16:14:13 <ertes> tobiasBora: i suppose your main issue is with the "n - 1", because it's based on end-point rather than count
16:14:15 <ertes> yes
16:14:20 <kamyar> Koterpillar: nope it is not lang server
16:14:45 <Koterpillar> kamyar: it's close
16:15:00 <ertes> tobiasBora: remember that it's most likely evaluated lazily
16:15:12 <tobiasBora> ertes: And there are no strange compilation optimisation on [0..n] that do not apply on [0..] ?
16:15:23 <maerwald> Koterpillar: no
16:15:29 <kamyar> Koterpillar: the lang server protocol is a language agnostic standard protocol not an IDE
16:15:32 <maerwald> there is a protocol for language servers
16:15:37 <maerwald> exactly
16:15:51 <ertes> tobiasBora: it's counterintuitive:  (take n [0..]) is more likely to behave properly than [0..n - 1]
16:16:16 <ertes> tobiasBora: especially if you delay the 'take' until you really need it:  take n (map f [0..])
16:16:33 <tobiasBora> ertes: well yes it makes sens
16:16:44 <kamyar> I am trying to collect a small team of haskell developers to create one implementation for haskell
16:16:58 <tobiasBora> ertes: Thank you!
16:16:59 <maerwald> kamyar: how much do you pay?
16:17:01 <maerwald> :P
16:17:06 <Koterpillar> maerwald: kamyar: I thought I'm using intero in Emacs as a language server
16:17:28 <ertes> kamyar: what's a "language server"?
16:17:38 <maerwald> ertes: https://github.com/Microsoft/language-server-protocol
16:17:47 <kamyar> maerwald: Zero! It is a voluntary open source project
16:17:53 <ertes> ah
16:17:57 <peddie> Koterpillar: I think they mean Language Server™, a special protocol, rather than a "language server", the generic concept
16:17:59 <ertes> kamyar: anything wrong with GHCi?
16:18:08 <Koterpillar> so I said, "it's close"
16:18:19 <Koterpillar> ertes: doesn't do "Jump to definition"
16:18:25 <ertes> it's used by a bunch of tools, including ghc-mod, haskell-mode (emacs), intero (emacs), leksah (a haskell IDE), etc.
16:18:27 <maerwald> yes and editors like vim support that language server protocol
16:18:29 <ertes> Koterpillar: haskell-mode does
16:18:29 <Koterpillar> while intero does: https://github.com/commercialhaskell/intero/blob/28609611c9f7c7d63370ce66e8ebb97676a8374e/src/test/Main.hs#L143
16:18:38 <Koterpillar> right
16:18:45 <ertes> Koterpillar: via GHCi
16:18:54 <Koterpillar> implementation detail :)
16:19:22 <maerwald> the editor doesn't have to know anything about the specific language server implementation, so you can use any language server implementation that follows the protocol with a generic editor plugin for the language server protocol
16:19:25 <maerwald> intero is not that
16:19:35 <ertes> kamyar: in other words: all you need is an editor that supports interactive haskell ;)
16:19:59 <ertes> well, i don't think i see value in such a generic framework
16:20:09 <maerwald> that just... your opinion man!
16:20:10 <Koterpillar> editor writers do
16:20:20 <ertes> how is it supposed to map language-specific things like GHC's holes?
16:20:38 <Koterpillar> the protocol can be extensible
16:20:46 <ertes> right
16:21:00 <ertes> well, go ahead =)
16:21:18 <kamyar> ertes: not really just read the protocol spec
16:21:24 * maerwald makes a not about ertes not liking protocols (haha)
16:21:36 <maerwald> *note
16:21:59 <ertes> i wouldn't mind such a protocol, it's just that i don't see enough value to contribute to it =)
16:22:19 <maerwald> the protocol is already done
16:22:29 <ertes> s/protocol/server/
16:22:47 <maerwald> well, less emacs-focused tools
16:23:09 <maerwald> or <whatever-editor>-focused tools
16:23:13 <maerwald> so the value is huge
16:23:41 <kamyar> ertes: the problem is that we still lack excellent IDEs like jerbrain ones
16:23:45 <ertes> yes, it is…  it just doesn't benefit *me*, because i'm not coding haskell in visual studio any time soon =)
16:24:01 <maerwald> ertes: vim has language server protocol support too.
16:24:06 <tobiasBora> And is there better way to define reverse [10..1] ?
16:24:09 <maerwald> so no idea how you come up with visual studio
16:24:18 <ertes> tobiasBora: [1..10]
16:24:51 <tobiasBora> ertes: sorry I mean "reverse [1..10]" ^^
16:24:59 <ertes> tobiasBora: [10,9..1]
16:25:17 <kamyar> in fact they are trying to eliminate programming language discriminations
16:25:27 <tobiasBora> ertes: Hum cleaver ^^ And both are equivalent in speed?
16:25:36 <maerwald> kamyar: xD
16:25:47 <Tuplanolla> > [10 .. 1] == [10, 11 .. 1] -- This is why it's that way, tobiasBora.
16:25:49 <lambdabot>  True
16:25:49 <maerwald> that gives a new meaning to "pure" languages, haha
16:26:43 <kamyar> All programming languages must be able to use robust tools
16:27:11 <tobiasBora> > [10 .. 1] == [10,9 .. 1]
16:27:13 <lambdabot>  False
16:27:40 <kamyar> For example google has convinced (paid?) jetbrains for making an IDE for go language 
16:28:02 <kamyar> but Rust language lacks it!
16:28:07 <maerwald> wat?
16:28:16 <maerwald> https://github.com/rust-lang-nursery/rls
16:28:36 <aeroxam_> what's your favorite IDE for haskell 
16:28:38 <aeroxam_> ?
16:28:45 <Rembane> nvim!
16:28:50 <Koterpillar> spacemacs
16:29:00 <maerwald> still no IDEs there
16:29:00 <aeroxam_> I use geany for everything, and I wonder if I should change my habits..
16:29:03 <ertes> aeroxam_: mine is emacs (yes, with haskell-mode i consider it a haskell IDE)
16:29:45 <kamyar> maerwald: I mean there is no Jetbrains special IDE for rust or haskell
16:29:59 <Rembane> maerwald: I need more Visual Haskell.
16:30:07 <ertes> vim users probably have a similar experience with ghc-mod (although many of them choose not to integrate the interpreter, and most of those people use tmux)
16:30:09 <Rembane> maerwald: But until then, I use vim.
16:30:25 <kamyar> While there is one for golang and this is a bad discrimination 
16:30:35 <maerwald> terminal vim is horrible, even more so in tmux
16:30:52 <ertes> kamyar: that's not discrimination, it's just lack of tools
16:30:54 <maerwald> you have 4+ layers of hotkeys
16:31:06 <maerwald> so when you press something, it might do random stuff
16:31:50 <kamyar> ertes: this lack if tools has taken place for lack of sth like langserver
16:32:59 <kamyar_> ok friends I have to go now
16:33:09 <ertes> kamyar_: in any case, if you really want this, you should probably just start coding
16:33:47 <maerwald> asking people first sounds like a better idea
16:34:10 <kamyar_> thanks anyway 
16:34:16 <kamyar_> bye for now 
16:34:20 <maerwald> e.g. someone might be already working on something, but just hasn't published something
16:34:45 <ertes> well, they did ask =)
16:34:56 <ertes> so that part is done ;)
16:35:01 <maerwald> on IRC only
16:47:15 <tobiasBora> Is there a more efficient way to write a list of string into a file that "writeFile filepath $ lines ["Ma", "Fonction"]"
16:50:45 <Welkin> more efficient?
16:51:06 <Welkin> writing a list of bytestring :P
16:51:07 <Koterpillar> tobiasBora: conduit?
16:51:27 <Welkin> that is kind of weird though
16:51:32 <Welkin> why would you have a list of strings?
16:51:36 <jle`> tobiasBora: do you mean like, write in the source code
16:51:38 <jle`> or write to a file?
16:51:54 <tobiasBora> Welkin: Well, is the writing done is a lazy way, is it written by bunch of text or char by char...
16:51:55 <jle`> oh sorry, there was some glare on my screen that covered part of the setnence v.v
16:52:09 <Welkin> I see
16:52:49 <Welkin> I actually don't know how it works by default
16:52:56 <Welkin> lazy IO perhaps
16:53:28 <Welkin> if you have huge datasets, you can use pipes or conduit to stream them
16:54:43 <dmwit> tobiasBora: You can choose the buffering on a per-handle basis. I think `writeFile` uses block buffering. Let's check the source!
16:55:46 <Welkin> oh yeah
16:55:48 <Welkin> it does
16:56:14 <ertes> tobiasBora: that looks pretty efficient to me
16:56:48 <ertes> tobiasBora: String is not inherently inefficient, it's just inefficient when you *store* strings
16:56:52 <tobiasBora> ok nice, thank you! So it's equivalent to play with IOHandle... ?
16:56:55 <dmwit> tobiasBora: Yes, the default is block buffering with a system-dependent size.
16:57:13 <tobiasBora> ok thank you
16:57:22 <ertes> tobiasBora: in other words: if you were reading those lines from another file and then writing them, String would be inefficient, and you should use ByteString or Text
16:57:31 <tobiasBora> ertes: Efficiency when I store strings is done using arrays?
16:57:39 <Welkin> tobiasBora: lol, no
16:57:46 <Welkin> use Text instead of String
16:57:47 <dmwit> tobiasBora: Usually `Text` from the `text` package.
16:57:56 <ertes> tobiasBora: a String, if it happens to actually manifest in memory through evaluation, is a linked list of Char
16:58:06 <tobiasBora> oh
16:58:11 <tobiasBora> yes
16:58:20 <Welkin> in haskell, we have String, Text, and ByteString
16:58:23 <Welkin> all for different uses
16:58:29 <dmwit> Or, for binary data, `ByteString`. Don't use `ByteString` for text.
16:58:33 <tobiasBora> But here I want to write a list of list of int into a file
16:58:42 <tobiasBora> (and do pretty nice align of the data)
16:58:54 <Welkin> tobiasBora: pretty print your data using Text
16:59:05 <tobiasBora> Welkin: ok thank you
16:59:07 <dmwit> tobiasBora: You might like the `boxes` package for constructing your file contents.
16:59:32 <tobiasBora> dmwit: it's alignment so not sure that boxes would do that
16:59:35 <dmwit> ...depending on what you want the contents to be, I guess.
16:59:50 <dmwit> tobiasBora: Hm. Okay. What is alignment?
17:00:01 <tobiasBora>  1  2
17:00:03 <tobiasBora> 10 42
17:00:19 <dmwit> Why do you think the boxes package will not do that?
17:00:42 <ertes> note that rendering numbers to String and writing them to a file should be pretty fast
17:01:29 <Enzyme> Is it possible to return a tuple where one of the members is a function?
17:01:41 <lyxia> :t (id, id)
17:01:43 <lambdabot> (a1 -> a1, a -> a)
17:02:01 <Koterpillar> :t (1, id)
17:02:03 <lambdabot> Num t => (t, a -> a)
17:02:35 <Enzyme> Hm?
17:02:53 <monochrom> The answer is yes.
17:03:25 <tobiasBora> dmwit: Well I though that this package would align paragraphs
17:03:35 <tobiasBora> like nested paragraph, or inside boxes...
17:04:10 <Koterpillar> > let (a, b) = (("y" ++), "es") in a b
17:04:12 <lambdabot>  "yes"
17:04:42 <Welkin> lambdabot: will you marry me?
17:04:43 <Welkin> > "yes"
17:04:46 <lambdabot>  "yes"
17:04:47 <Welkin> :D
17:04:54 <jle`> Enzyme: functions are just normal values in haskell
17:05:07 <jle`> so they can be used anywhere you expect any value
17:05:47 <jle`> you can have lists of functions, io actions that return functions, etc.
17:05:57 <Enzyme> jle`: yea, I thought it would be that easy, can't figure out how to write a type signature to say I'm returning a tuple with a function in it.
17:06:07 <Welkin> jle`: you got your functions in my functions!
17:06:30 <jle`> Enzyme: `(String, Int -> Bool)` is a tuple whose first item is a string, and whose second item is an Int -> Bool function
17:06:30 <Welkin> (a -> b, b)
17:06:57 <Enzyme> So, no generic way to say "a function"?
17:07:10 <dmwit> tobiasBora: In the future, if somebody suggests a package to you, I suggest you at a minimum read a bit of the documentation before discarding their suggestion.
17:07:11 <jle`> what do you mean, as a type?
17:07:27 <monochrom> How generic do you need?
17:07:51 <jle`> Enzyme: any X -> Y, where X and Y are types, is the type of a function
17:07:56 <Welkin> Enzyme: a
17:08:15 <Welkin> you have no idea what `a` is though
17:08:19 <monochrom> Welkin, unlikely that more type variables will help.
17:08:41 <Enzyme> Generic in the sense of "could be 1-3 args" but all return String.
17:09:05 <Enzyme> And yea, it's really all just taking 1 function, and I get currying.
17:09:09 <Enzyme> 1 arg*
17:09:17 <tobiasBora> dmwit: Yes sure. In my head I though I have already meet it, but in fact I was thinking to another package meet in Ocaml world
17:09:21 <Koterpillar> Enzyme: maaaaybe a typeclass
17:09:26 <dmwit> There is not a convenient type for functions that "take 1-3 args".
17:09:27 <Koterpillar> Enzyme: but what are you using it for?
17:09:30 <jle`> Enzyme: from that perspective you're thinking about functions that can take things of different types
17:09:42 <jle`> but
17:09:45 <dmwit> I suggest you rethink your needs, given the expertise level you are projecting, and ignore people who suggest solutions.
17:09:58 <tobiasBora> dmwit: so yes, this Box package is indeed interesting, thank you
17:10:21 <ertes> Enzyme: functions don't really have much of a special role in haskell
17:10:24 <jle`> you have to sort of think more about what you really want before you can start thinking about a type for it
17:10:29 <dmwit> tobiasBora: Ah, yeah, I've gotten confused across languages before, too. Easily done. =)
17:10:36 <ertes> Enzyme: if something can be "a type", it can also be a function type
17:10:52 <Enzyme> Trying to implement a way of taking an input command like "r file" or "i 3" "l 15 5" and returning a tuple with a function and a list of args.
17:11:13 <jle`> why not take a list of commands instaed
17:11:31 <jle`> ["r file"] or ["i 3", "l 15 5"]
17:11:44 <jle`> but also why are your commands strings, heh
17:11:48 <monochrom> Eliminating the tuple. Apply the function to the arguments right away.
17:11:49 <dmwit> Why are you returning a function and a list of args? Is that more useful than just applying the function, for some reason? If so, why?
17:12:11 <Enzyme> I also need to get my head around the state monad.
17:12:29 <Enzyme> I'm trying to implement a cryptanalysis tool.
17:12:51 <Welkin> State monad is just a nicer way of dealing with manually passing around a state object
17:12:51 <Enzyme> Take a ciphertext and apply functions on the text based on input.
17:13:08 <jle`> sounds like function composition?
17:13:42 <monochrom> Do you have partially complete current code to show us?
17:13:59 <Enzyme> Well, like "s R s" to replace 'R' with 's', and then being able to see the result after that.
17:14:35 <Enzyme> monochrom: I do, might just check into a gist.
17:15:22 <Enzyme> Or into github
17:18:07 <Enzyme> https://github.com/ramblingenzyme/krypto
17:19:48 <Enzyme> In Main.hs
17:21:20 <ertes> Enzyme: i'm using lenses for cryptanalysis live-coding
17:21:24 <ertes> Enzyme: but they are an advanced topic
17:22:31 <Enzyme> Neat, I'll give them a look.
17:24:02 <Welkin> ertes: where is your stream?
17:27:08 <ertes> Welkin: there is none…  you have to come to stuttgart ;)
17:38:07 <tobiasBora> I'd like to know, let's imagine I have a class X that allow me to implement another class Y, how can I say "for all instances of X, the way that Y is implemented is ..."
17:39:30 <ertes> > (listFiltered isAlpha . blocks 3 . ix 0 . letter +~ 13) "Hello World!"
17:39:32 <lambdabot>  "Uelyo Wbrlq!"
17:39:41 <dmwit> Enzyme: Even if you could do what you say, you can't (practically) print functions. So `putStrLn action` certainly ain't gonna work. What are you *actually* planning to do with `action`?
17:39:57 <ertes> Enzyme: ^ rotate every first letter in every 3-block of letters by 13
17:40:26 <ertes> > (blocks 3 %~ reverse) "Hello World!"
17:40:29 <lambdabot>  "leH olroW!dl"
17:40:36 <ertes> reverse every 3-block of characters
17:40:54 <ertes> > (listFiltered isAlpha . blocks 3 %~ reverse) "Hello World!"  -- reverse every 3-block of *letters*
17:40:57 <lambdabot>  "leHWo llrod!"
17:41:04 <ertes> stuff like that is super-easy with lenses
17:41:10 <ertes> but they have a learning curve
17:41:22 <Koterpillar> tobiasBora: default implementations?
17:41:23 <pacak> tobiasBora: That is probably not a very good idea.
17:41:41 <pacak> ertes: More like a learning cliff.
17:42:39 <pacak> tobiasBora: Once you do that - there's no way of writing instances of class Y manually
17:43:05 <ertes> in my live-coding i basically use a state monad with an initial text and apply more and more transformations to it
17:43:30 <tobiasBora> Koterpillar: Well, kind of, I'd like for example to express that all animals can be convertir as a string using their name and their age...
17:43:39 <dmwit> tobiasBora: http://stackoverflow.com/q/31600470/791604 possibly
17:45:11 <tobiasBora> dmwit: Does it also work when Subclass already exists (like "Show" for example)?
17:46:01 <ertes> > flip execState "This is a secret message." $ do zoom (blocks 3) (do ix 0 . letter += 5; ix 1 . letter += 8; ix 2 . letter += 17); blocks 4 %= reverse
17:46:03 <lambdabot>  "xzpY xz va ryvzhajd vofj."
17:46:06 <dmwit> Which direction does subclass go again? Doesn't "already exist" preclude "subclass of my class"?
17:46:36 <ertes> Enzyme: ^ first apply vigenere with key [5, 8, 17], then reverse each 4-block
17:46:37 <dmwit> At any rate, no, you cannot retroactively define a default implementation for `show`.
17:47:15 <dmwit> You can, of course, define `showForAnimals :: Animal a => a -> String` and use that in the `Show` instance for any animals you cook up.
17:47:24 <ertes> (it's quite readable, if you have that on multiple lines and with proper layout)
17:47:28 <dmwit> (And for which it's appropriate, of course.)
17:53:00 <nirvagold> wristle
18:07:50 <tobiasBora> dmwit: yes that's exactly what I want, I'd like to automatiquely use the showForAnimals function in the show instance, but I don't know how to do that
18:08:37 <robkennedy> Is there a quickish way to define a function for parsing in scope functions? Ie `f :: String -> Maybe (String ->Int)` so that `f "\x -> length (show x)" <$> "foo" == Just 3`
18:10:22 <dmwit> robkennedy: Take a look at the GHC API, and its spinoffs mueval and hint.
18:10:32 <robkennedy> Ty
18:26:47 <robkennedy> How do you interact with Text/String values which are enumerable, but do not follow Haskell casing? Right now I use Read/Show for Haskell and handspun classes like ToJSON, FromXmlAttributeValue. Is that the best we've got ATM?
18:31:05 <Welkin> ...what?
18:35:52 <jle`> what is haskell casing?
18:35:59 <jle`> and enumerable in what way?
18:36:41 <geekosaur> I'm guessing either escaping, or they want text-icu for different collations?
18:36:42 <ezyang> you mean, you want a constructor that is lower case? 
18:36:45 <geekosaur> or possibly both
18:37:00 <Koterpillar> my guess: you want to use Read and Show for outside interaction, don't do that
18:53:32 <robertkennedy> You're correct: I'm embedding an XML schema, and there's a single lower case option. Is knownSymbol just the best way to play this?
18:54:54 <robertkennedy> I'm all for using knownSymbol if that's normal. 
18:55:23 <robertkennedy> Enumerable like I'm reading an XML spec from NASDAQ
18:55:38 <lyxia> knownSymbol? Do you mean KnownSymbol as in type-level strings?
18:57:42 <robertkennedy> Yes
18:58:28 <robertkennedy> From GHC.TypeLits
18:59:14 <lyxia> I can't imagine this being useful here.
19:02:37 <robertkennedy> I'm trying to reduce memory footprints for medium datasets. I want to write functions where values which are currently `type Foo = Text` to `data Foo = Bar | Baz | somethingElse` and have ~ 2 bits in memory per item 
19:03:37 <monochrom> "data Foo = Bar | Baz" takes 32 bits or 64 bits. Just to surprise you more.
19:03:56 <robertkennedy> Don't crush my dreams :-0
19:04:11 <monochrom> My idea of learning is dream-crushing.
19:04:40 <monochrom> At any rate, Symbol is not normal.
19:04:53 <suzu> it takes 32 or 64?
19:04:59 <suzu> what decides what?
19:04:59 <Welkin> lol
19:05:01 <suzu> is this documented somewhere?
19:05:03 <Welkin> they are boxed values
19:05:04 <monochrom> Normal means you stick to Haskell 2010.
19:05:21 <lyxia> We sold too much of the idea that types are eraseable.
19:06:11 <robertkennedy> But seriously you have to be fake news'ing me. Are you saying `data Bool = True | False`, or that `data Foo = Bar | Baz` is not the same as Bool?
19:06:16 <monochrom> suzu: https://github.com/takenobu-hs/haskell-ghc-illustrated is a good start.
19:06:40 <monochrom> Bool is the same story. 32 or 64 bits.
19:07:03 <monochrom> My "or" is because I don't know whether you're using 32-bit GHC or 64-bit GHC.
19:07:30 <Welkin> monochrom: great link!
19:07:35 <monochrom> I could and should just say "pointer size" or "machine word".
19:07:59 <Welkin> robertkennedy: you can use unboxed values, but only for primitive types
19:08:17 <Welkin> `bool` in c++ is still 32/64-bits
19:09:25 <monochrom> Still, one machine word is better than "Foo", which is 6 machine words if String, 4 machine words if Text.
19:11:44 <robertkennedy> monochrom: are you saying `data BoolU = !True | !False` doesn't optimize such that `type Int' = (!BoolU, ... , !BoolU)` is not the same as `!Int` (with the right tuple size)?
19:12:11 <monochrom> "data BoolU = !True | !False" is a syntax error.
19:12:27 <monochrom> (I guess it gets optimized to 0 bits therefore?)
19:13:28 <monochrom> After a while, the right question to ask is "where did you get all these great ideas you currently have?!"
19:13:49 <monochrom> I mean, if you wrote your own compiler, sure, I trust you that you would totally do what you said.
19:14:06 <monochrom> But you didn't write GHC. So, where did you hear all your great ideas from?
19:15:17 <robertkennedy> Sorry, I didn't mean to impugn GHC. 
19:15:42 <MarcelineVQ> oh you're allowed to do that, I don't think that was his point :>
19:16:05 <monochrom> Yeah, my point is: Are you scientifically minded? Do you check evidence, or do you just presume?
19:17:06 <robertkennedy> > map GHC.Generics.to ([minBound..maxBound] :: [Bool])
19:17:08 <lambdabot>  error:
19:17:08 <lambdabot>      Not in scope: ‘GHC.Generics.to’
19:17:08 <lambdabot>      No module named ‘GHC.Generics’ is imported.
19:22:06 <robertkennedy> > map from ([minBound..maxBound] :: [Bool])
19:22:08 <lambdabot>  error:
19:22:08 <lambdabot>      • Couldn't match type ‘Bool’
19:22:08 <lambdabot>                       with ‘Control.Lens.Internal.Iso.Exchange a b a (Identit...
19:22:31 <robertkennedy> Well, the moral is that I got my idea from GHV
19:22:46 <robertkennedy> GHC
19:23:48 <lyxia> data Foo = Bar | Baz     parse "bar" = Bar ; parse "baz" = Baz    done.
19:25:58 <monochrom> Presumably there is a longer input to parse. Still, any parser suffices to get you to the data constructors you want.
19:30:28 <robertkennedy> Would be nice if I could do `type Foo = "baz" | "bar"`, but it's close. Ty. 
19:31:25 <nshepperd> robertkennedy: if you want to store a large list of items in a memory efficient way, you probably want unboxed vectors
19:32:08 <nshepperd> Data.Vector.Storable supports any data type with a Storable definition, which lets you choose your own representation
19:32:31 <nshepperd> I think it's still minimum 1 byte per element though
19:32:48 <nshepperd> unless you want to do the bit packing manually
19:34:13 <monochrom> It probably really has the byte-wise assumption. Because size :: a -> Int is not happy with fractions.
19:34:50 <suzu> 32 bits for a bool hhhwhtf
19:36:19 <robertkennedy> nshepperd: what is the next step up? 1 byte/element is (as monochrom noted) still OOM improvements. Do you ever break that abstraction?
19:37:08 <robertkennedy> But seriously 64 bits for Bool sounds like fake news 
19:37:14 <lyxia> You're free to compress it when storing it but a CPU is going to be faster by handling everything uniformly.
19:38:49 <pacak> robertkennedy: That's how it is. ghc uses lower bits of pointer to tag stuff.
19:39:14 <pacak> evaluated/thunk and 1st or 2nd constructor
19:39:40 <nshepperd> (could you not use 'fake news' as a blanket term for anything that annoys you?)
19:41:00 <lyxia> feel free to use "paradoxical" instead
19:42:01 <nshepperd> you can make your own vector type wrapping a plain array of bytes, and indexing manually into it with bit packing
19:42:58 <nshepperd> if you just need a bitvector, you could use one of the existing implementations of that
19:43:02 <nshepperd> eg. the bit-vector package
19:43:17 <robertkennedy> nshepperd: Meant to be read as exactly vacuously as POTUS uses it ;-)
19:44:44 <robertkennedy> Ty for bit-vector. Will look. But, that seems like quick the complexity to implement an efficient `inToBits`, ie
19:45:00 <robertkennedy> *quite
19:46:38 <robertkennedy> *intToBits
19:48:14 <alam> http://rextester.com/GVWK23668 How come f2 is considered wrong by the compiler? :S
19:48:19 <nshepperd> well, maybe you don't actually want intToBits
19:48:22 <nshepperd> whatever that is
19:49:29 <Koterpillar> alam: only the part to the left of '=' is considered when pattern matching
19:49:46 <alam> I think f2 makes it much clearer than f1 that f2 returns a function, but for some reason it is considered wrong
19:50:15 <alam> is there a way to use f2's syntax such that it stays clear that it returns a function?
19:50:44 <Koterpillar> alam: f3 0 = \y -> y; f3 x = \y -> x
19:50:46 <pacak> > toListOf bits (5 :: Word16)
19:50:48 <lambdabot>  [True,False,True,False,False,False,False,False,False,False,False,False,False...
19:51:05 <Koterpillar> > length it
19:51:05 <pacak> robertkennedy: You might not need intToBits
19:51:07 <lambdabot>  error:
19:51:07 <lambdabot>      • Variable not in scope: it :: [a0]
19:51:07 <lambdabot>      • Perhaps you meant one of these:
19:51:17 <lyxia> alam: you're pattern matching on 0 so use "case".
19:51:27 <alam> ah right... should've known that :P thanks! :)
19:51:47 <robertkennedy> nshepperd: I'm sure you could imagine `intToBits`. But I'm also willing to admit I don't know when a byte vs a bit bytes ( ;-} ) me. Do you have literature/a problem set to develop that intuition?
19:52:15 <lyxia> alam: what you wrote defines f2 twice, rather than a function with two clauses.
19:53:17 <lyxia> as for f1 being less clear that you are defining a function... we get used to it.
19:54:49 <lyxia> After writing lambdas for a while you figure that sometimes they're just noise.
19:54:52 <robertkennedy> pacak: True in the case I initially described. However, I have needed intToBits before (project Euler). Of course, generally you only would call `intToBits` once in those cases. You're right that this particular function doesn't suffer too much. 
19:55:18 <alam> I guess if I would want to be consistent, I would also have to call f3 like: (f3 5) 6... agree?
19:56:23 <lyxia> (f3 5) 6 is the same as f3 5 6
19:56:57 <alam> yeah I know, but I mean to make it extra clear that it's a function that returns a function
19:57:11 <alam> maybe even (f3 5) (6) :P
19:57:23 <robertkennedy> Is encoding small enumerable data types minimally​ not a general problem? 
19:57:26 <alam> but's that would be overdoing it i guess :P
19:59:15 <lyxia> Be consistently minimal.
20:03:22 <nshepperd> robertkennedy: normally the output 'encoding' of something like 'toListOf bits :: Int32 -> [Bool]' shouldn't matter
20:04:02 <nshepperd> you're just going to immediate consume the list anyway, and probably your whole expression will fuse together and the list will optimize away
20:05:46 <nshepperd> if you only have one Int, storing its bits in a bitvector is _definitely_ pointless, because an Int already is such a bitvector
20:06:51 <alam> what would the pattern matching syntax of f4::(Int->Int)->Int->Int look like?
20:07:46 <Koterpillar> alam: f4 a b c = ...
20:08:13 <Koterpillar> oh, sorry, miscounted
20:08:30 <Koterpillar> alam: f4 a b = ...  -- possible implementation: f4 a b = a b
20:08:42 <alam> and with lambda's?
20:09:06 <Koterpillar> there's nothing special about that argument type
20:09:35 <Koterpillar> if you already know how to pattern match in g: Int -> Int -> Int, it's the same for g': (Int -> Int) -> Int -> Int
20:11:30 <alam> I'm afraid I don't fully understand how to pattern match g as well
20:12:07 <alam> ah never mind I figured it out :D
20:14:23 <okeuday_bak> control.exception try use isn't entirely clear, if I want to handle two separate types of exceptions using try, don't I need to use two try wrappers?
20:14:39 <robertkennedy> nshepperd: I do see what you're saying ... but you could maybe see why something like `isPower2 = isSingleton . filter id . intToBits` seems nice in toy problems. Do you trust GHC to optimize this? I'll attempt the recommended optimizations tomorrow, I'd definitely believe they are enough. 
20:16:00 <lyxia> okeuday_bak: yes
20:16:15 <okeuday_bak> lyxia: k, thanks
20:19:47 <nshepperd> robertkennedy: simply due to laziness, that won't build the whole list of bits at any point. it amounts to a loop (and might even have all allocations optimized out, if these functions are good producers/consumers)
20:20:02 <nshepperd> robertkennedy: there's no reason to worry about memory usage here
20:23:28 <nshepperd> robertkennedy: although, of course, it would be faster if you used popCount from Data.Bits, or one of those bit wizardry expressions for testing power-of-2-ness
20:24:20 <nshepperd> 'x .&. (x - 1) == 0' iirc
20:36:16 <JavaSucksMan> How can I search for instance of a class either in packages installed on my system, or in Hackage
20:36:50 <JavaSucksMan> errr, instance
20:37:05 <JavaSucksMan> damn... bad typing day... instances
20:37:16 <Koterpillar> hoogle?
20:37:33 <JavaSucksMan> I tried, but couldnt guess how
20:37:53 <robertkennedy> nshepperd: amazing. I thought this had the `get` and `put` API, which I've not yet understood. That memory may have been my fault. Thanks. 
20:40:22 <JavaSucksMan> > "Lambdabot.... are you here?"
20:40:24 <lambdabot>  "Lambdabot.... are you here?"
20:40:38 <JavaSucksMan> @hoogle Show
20:40:38 <lambdabot> Prelude class Show a
20:40:38 <lambdabot> module Text.Show
20:40:38 <lambdabot> Text.Show class Show a
20:40:53 <JavaSucksMan> @hoogle Show instance
20:40:54 <lambdabot> Agda.Interaction.BasicOps UseShowInstance :: ComputeMode
20:40:54 <lambdabot> Database.Groundhog.TH.CodeGen mkKeyEqShowInstances :: THEntityDef -> Q [Dec]
20:40:54 <lambdabot> package text-show-instances
20:41:16 <JavaSucksMan> Wow... Agda... Cool
20:43:14 <Welkin> Agda O.o
20:43:36 <Welkin> is Agda written in haskell?
20:44:05 <Welkin> yeah, it is
20:44:10 <Welkin> just like Idris
20:44:45 <JavaSucksMan> apparently so is hoogle (or lambdabot)
20:45:10 <Welkin> yes, but thise are not languages
20:45:13 <Welkin> those*
20:45:16 <JavaSucksMan> err, rather hoogle uses Agda... mind mind is not so good today... I has the dumb
20:45:25 <Welkin> elm is written in haskell too, but unfortunately it sucks
20:45:41 <Welkin> too many languages are written in haskell :D
20:46:06 <Koterpillar> too few languages are written in haskell
20:46:06 <JavaSucksMan> Well, lambdabot coughed up some Agda when I tried to use it to search for instances of a class, which I still dont know how to do.
20:46:20 <Welkin> just search in your browser
20:46:34 <Koterpillar> JavaSucksMan: you searched for "show instance" and it found a matching function in an Agda *interop* library
20:46:35 <JavaSucksMan> I'm working on a Smalltalk written in Haskell
20:46:52 <Koterpillar> which class are you looking for instances of?
20:47:00 <lispy> JavaSucksMan: How's it going?
20:47:14 <Welkin> @hoogle instance Show Bool
20:47:14 <lambdabot> No results found
20:47:29 <lispy> JavaSucksMan: have you seen smallworld? https://github.com/russellallen/SmallWorld
20:47:30 <Koterpillar> @hoogle trace show id
20:47:30 <lambdabot> Debug.Trace traceShowId :: (Show a) => a -> a
20:47:31 <lambdabot> Debug.Trace.Compat traceShowId :: Show a => a -> a
20:47:31 <lambdabot> BasePrelude traceShowId :: Show a => a -> a
20:47:32 <JavaSucksMan> Well, I was trying to find instances of Show... for example
20:47:53 <lispy> It uses some clever java stuff, but given how small it is, it might make a nice reference
20:48:02 <Koterpillar> JavaSucksMan: that's... most of every library
20:49:31 <JavaSucksMan> Fine... then how about instances of Monad... it doesn;t matter which class... I want to know how to search
20:50:11 <Welkin> lol
20:50:23 <Koterpillar> JavaSucksMan: http://stackoverflow.com/a/32975529/288201
20:51:16 <JavaSucksMan> lispy: I know about Timothy Budd's Little Smalltalk... but I hadn't seen SmallWorld... 
20:51:28 <geekosaur> not sure hoogle is up to this. I think hayoo is, or would be if it were giving me results (I seem to get a lot of missing doc pages. Not updated for newer haddock, I suspect.)
20:51:36 <JavaSucksMan> maybe I did. but the unfortunate musical association blocked it from my brain
20:51:38 <suzu> Westworld is a better show
20:51:40 <suzu> ;)
20:53:27 <JavaSucksMan> lispy: I have his book... but it's in a storage locker  :-(
20:57:08 <JavaSucksMan> suzu: Unfortunately you can't do "Hello, World" in Westworld... only "Goodbye. World"?
20:57:36 <lispy> JavaSucksMan: smallworld was originally by Budd, but the github version is maintained by someone else
20:58:10 <JavaSucksMan> yeah... I know about it, but haven't seen Little Smalltalk since before git existed
20:58:35 <JavaSucksMan> Got's to get my CS books out of storage
21:01:36 <robertkennedy> Does `:i Show` in ghci not give what you want?
21:02:58 <Koterpillar> if the right modules are loaded, I suppose
21:04:29 <geekosaur> @help instances-importing
21:04:29 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
21:04:50 <geekosaur> the problem being that few of the modules you'd want to check are likely to be accessible to lambdabot
21:06:08 <JavaSucksMan> lispy: in Smallworld only [0..9] are unboxed... now THAT'S small
21:08:39 <JavaSucksMan> yeah, after I find the module, I can verify something is an instance of a class with :i... but how do I search for what to load?
21:09:26 <lispy> JavaSucksMan: you might have mildly better luck with hoogle: https://www.haskell.org/hoogle/
21:09:36 <lispy> IIRC, it indexes a bit more than lambdabot 
21:10:00 <Koterpillar> JavaSucksMan: did you see that SO answer?
21:10:01 <JavaSucksMan> I tried... don't know the syntax to do what I want
21:10:13 <JavaSucksMan> yeah.... I did... bummer
21:10:39 <JavaSucksMan> I guess there is always grep ;-)
21:11:13 <JavaSucksMan> @hoogle Monad
21:11:13 <lambdabot> Prelude class Applicative m => Monad m
21:11:13 <lambdabot> module Control.Monad
21:11:13 <lambdabot> Control.Monad class Applicative m => Monad m
21:11:48 <JavaSucksMan> yeah... thanks lambdabot... already knew that part.
21:13:16 <JavaSucksMan> afk
21:15:45 <_sras_> How can I add a logger monad to Servant that write to a file. Basically I want a tell function that write to a file instead of accumilating in memory.
21:29:26 <jle`> _sras_: the monad-logger package is nice for that
21:32:00 <geekosaur> lambdabot's hoogle is not very useful. use the website (either of them; hoogle.haskell.org is newer but that version of hoogle is still a bit broken)
21:32:34 <jle`> i wonder if neil is still working on hoogle
21:32:54 <jle`> not that i'm complaining
21:34:39 <geekosaur> I'm not sure if it's that, or nobody updsting hoogle.haskell.org's version, or both
21:35:15 <geekosaur> but as I'm not paying for either of them and they're both overloaded, also not pushing any buttons over it
21:35:28 <geekosaur> (devs that is)
21:40:41 <jle`> the new hoogle is just fine for me more or less
21:44:50 <Rotaerk> what's "the new hoogle"?
21:47:39 <geekosaur> http://hoogle.haskell.org (as opposed to http://www.haskell.org/hoogle)
21:48:25 <geekosaur> and, iirc hoogle 5 vs. 4?
21:48:48 <geekosaur> (yes)
21:49:19 <geekosaur> also ndm released 5.0.9 in January, so clearly still working on it
21:50:54 <halogenandtoast> Hello friends
21:52:46 <dfeuer> @tell bitemyapp If you have any questions or concerns about GHC proposals #41 or #42, please get in touch.
21:52:46 <lambdabot> Consider it noted.
22:02:55 <okeuday_bak> is there anything you can't derive Typeable for? (ignoring undefined)
22:04:10 <cocreature> okeuday_bak: I don’t think so
22:04:25 <okeuday_bak> cocreature: k, good
22:04:32 <cocreature> okeuday_bak: also you derive things for types not avalues, so undefined is not relevant here
22:05:01 <okeuday_bak> cocreature: k, since undefined has no type? 
22:05:23 <cocreature> okeuday_bak: exactly the opposite "undefined" has the most polymorphic type possible
22:05:26 <cocreature> :t undefined
22:05:28 <lambdabot> a
22:05:43 <cocreature> it’s typeable instance depends on the type you give it
22:06:17 <dfeuer> @tell mpickering In your blog post about inlining and specialization, you caution users not to put INLINE pragmas on loop breakers. This doesn't seem to be very practical advice, because users don't generally know which bindings are loop breakers.
22:06:17 <lambdabot> Consider it noted.
22:06:31 <okeuday_bak> cocreature: k, thanks
22:09:38 <qmm> what can haskell do that typical languages can't or can't do it as easily?
22:17:42 <qmm> maybe this is what i am looking for: https://wiki.haskell.org/Why_Haskell_matters
22:19:02 <qmm> i like this: "You could argue that Haskell has a much better form of duck typing. If a value walks and talks like a duck, then it will be considered a duck through type inference, but unlike Python the compiler will also catch errors if later on it tries to bray like a donkey!"
22:21:21 <halogenandtoast> cocreature: my favorite revalation about `undefined` having the type a is that a could be (b -> c) or (b -> c -> d) etc.
22:22:08 <cocreature> halogenandtoast: the power of polymorphism :)
22:22:14 <halogenandtoast> qmm: One thing Haskell can do that many others can't is tell you when a function has side effects just by looking at the type signature
22:22:19 <halogenandtoast> this is unbelievable useful
22:22:37 <halogenandtoast> *unbelievably
22:23:03 <qmm> halogenandtoast: that's a great point!
22:23:59 <halogenandtoast> qmm: I work in ruby mostly and it's a huge pain when someone writes a function name that seems obvious, but then does something in the database.
22:24:11 <qmm> this is a nice answer with regards to why haskell might be ideally suited for writing compilers: https://www.quora.com/What-does-Haskell-do-better-than-other-functional-programming-multi-paradigm-languages
22:24:15 <halogenandtoast> Which happens way more often than it should.
22:30:57 <Sh4rPEYE> Hello. I found a great question and answer on SO about the Haskell progression path... According to the comments, it is probably outdated though. And the thread is locked, so the only way to update it is to edit. Would somebody here be able to do it? It contains some great info and it would be awesome if it could be used as a reliable recource...
22:31:06 <Sh4rPEYE> The thread in question: http://stackoverflow.com/questions/1012573/getting-started-with-haskell
22:31:39 <halogenandtoast> This is me being a little condescending, but I really don't think SO is a good resource for anything anymore.
22:32:05 <cocreature> given that I wouldn’t be able to get anything done without SO I disagree :)
22:32:33 <halogenandtoast> cocreature: I see some hyperbole there.
22:32:37 <halogenandtoast> :p
22:32:38 <Sh4rPEYE> Well, what resource would you reccomend?
22:33:01 <Sh4rPEYE> I'm just a beginner nevertheless, so SO might be just sufficient enough :D
22:33:09 <cocreature> halogenandtoast: sure, but it definitely saves me an awful lot of time
22:33:21 <halogenandtoast> Sh4rPEYE: To be honest, when I was first learning, the best resource was making friends with people who already knew Haskell.
22:33:46 <Axman6> well, you guys havce already found one of the best haskell resources, IRC
22:33:53 <cocreature> Sh4rPEYE: https://github.com/bitemyapp/learnhaskell/ is pretty good as a meta-resource
22:34:04 <halogenandtoast> Sh4rPEYE: But SO is an "alright" resource, it sometimes influences people to cargo cult too much, but that's more a problem with people and not SO itself per say.
22:35:03 <halogenandtoast> And I agree with Axman6, the irc channel is the best resource.
22:35:27 <halogenandtoast> The other day we spent 2 hours trying to explain function composition to someone the other day.
22:41:04 <Sh4rPEYE> The problem with me is that I usually can't think of anything I want to ask... I'd rather passively read whatever I can about the topic and retrospectively find what wasn't clear to me... If that makes sense
22:42:52 <halogenandtoast> Sh4rPEYE: Differnet things work for different people. I of course believe you should just find a small problem, try to solve it, and ask questions along the way.
22:43:26 <halogenandtoast> Solving problems this way helps with information recall
22:45:31 <halogenandtoast> I find that just reading how the lowest effecting memory recall rate, unless you read it in bizarre fonts or with bizarre foreground/background colors.
22:45:42 <halogenandtoast> s/lowest effecting/lowest effective/
22:48:02 <Sh4rPEYE> Sure. I have a book about Haskell and I keep doing the excercises. So far I don't have problems, but I haven't yet reached monads or any other advanced topic... I'm really looking forward to that 😃 If I'll have questions then, I'll come here.
22:48:18 <halogenandtoast> I've forgotten the terms now, but basically the brain has two modes for dealing with information, one basically uses pattern recognition (which we use during reading) and it doesn't create a lot of new connections
22:48:37 <halogenandtoast> the second is when we can't use pattern recognition and it creates more connections.
22:49:34 <g1h3s> shit
22:49:41 <Sh4rPEYE> One last question before I leave to school: What IRC client shuld I use on MacOS/iOS?
22:49:58 <halogenandtoast> Sh4rPEYE: I just use irssi in my terminal
22:50:01 <g1h3s> heyy 
22:50:31 <halogenandtoast> I used to use Colloquy, but maybe no one else uses that anymore.
22:51:07 <systemfault> Textual is my favorite
22:51:15 <Sh4rPEYE> I'm not a terminal guy... Maybe it's time to change
22:52:02 <halogenandtoast> Sh4rPEYE: it's good for some people. I try to do as much as I can in the terminal
22:52:09 <halogenandtoast> but I know it's not the path for everyone
22:52:50 <_sras_> What is the best way to make sure the logs upto that point are not lost (if I am using something like Monad logger), when a thread crash (Due to a incomplete pattern or something like that)?
22:57:21 <cocreature> _sras_: what kind of logs are we talking about here? are you just writing to a file?
22:58:30 <_sras_> cocreature: Web application. Need to log reqeusts, route handler execution times, query execution times, and any unexpected situtations that the code comes across...
22:58:43 <jle`> LoggerT does streaming logging i believe, if that's what you're using
22:59:05 <cocreature> if you just write out your logs directly, then crashing at a later point shouldn’t cause problems.
22:59:25 <cocreature> if you care about data loss if your computer crashes, you need "fsync" or something like that
22:59:32 <_sras_> jle`: But the thing is, I want to group logs by request. So I want some thing to collect logs until the end of the request OR the thread crashes..
23:00:01 <jle`> do you want to not write the log until the request is finished ...?
23:00:25 <cocreature> you can always throw in a `finally` that dumps the logs
23:00:27 <_sras_> jle`: yes. Because I want to group logs for a single request.
23:00:39 <jle`> by group, do you mean batch their writes?
23:00:50 <jle`> or like, group them on the filesystem
23:01:26 <_sras_> jle`: I want logs for a certain request as a single block, and not interleaved with logs from other requests....
23:01:57 <jle`> ah so one big log stream, but for all of the log outputs from a single request to come all at once instead of being interleaved
23:02:43 <_sras_> jle`: Yes
23:08:38 <halogenandtoast> Why not just interleave them and write a program to parse them later on?
23:09:35 <_sras_> halogenandtoast: That would require some kind of id to link all those logs, right?
23:10:34 <_sras_> halogenandtoast: and would certainly be a pain, if you want to grep through the logs...
23:11:26 <jle`> hm, it looks like monad-logger comes built-in with a logger that writes to a different thread
23:11:38 <jle`> so you could have a thread that processes incoming requests and batches their writes
23:12:45 <jle`> oh actually it lets you be pretty flexible with your logging
23:13:07 <jle`> all you have to do is provide a callback on what to do with each log item emitted
23:13:52 <jle`> monad-logger's LoggerT doesn't do any accumulation of logs, so it doesn't really "lose" logs in the sense that you mentioned earlier
23:13:52 <_sras_> jle`: Sounds great.
23:14:34 <_sras_> jle`: this one right? https://hackage.haskell.org/package/monad-logger-0.3.21/docs/Control-Monad-Logger.html
23:14:39 <jle`> yes
23:15:01 <jle`> if you want, you can spawn a thread that waits on a Chan, and accumulates the input until it gets some signal that it's ready to write
23:15:19 <jle`> and have your logging callback write to that Chan
23:15:57 <jle`> and maybe use 'finally' or osmething to trigger a dump if the request thread crashes
23:16:34 <jle`> not sure how easy it is to integrate into your web framework though
23:19:54 <_sras_> jle`: What all kind of erros can be caught at run time. Can a fromJust Nothing or a Non exhaustive pattern match be caught?
23:22:32 <jle`> if you use 'bracket', then you can have something be run no matter if the thread crashed or completed succesfully
23:23:01 <jle`> but yes you can catch those exceptions in IO
23:23:29 <jle`> i recommend reading simon marlow's chapter about exceptions in haskell, in the free online book Parallell and Concurrent Programming in Haskell
23:23:39 <jle`> there is http://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Exception.html if you want a quick API reference too
23:24:47 <jle`> 'bracket' might be useful; the resource acquisition would be spawning the new thread and Chan, the resource releasing would be flushing the thread's accumulated logs, and the bracked action would be whatever you want to execute w/ logging
23:25:06 <jle`> but this workflow would require a separate 'runLoggerT' on every request
23:25:24 <jle`> so logging wouldn't be "global", it'd be something that was spun up from scratch on every request
23:26:00 <jle`> it feels a bit weird to me but it might be the simplest way to batch logs like you want
23:26:34 <jle`> i feel like having the logs all interleaved, with unique id's, isn't too bad, but
23:27:37 <_sras_> jle`: Yes.
23:28:16 <_sras_> jle`: But how will you grep through an interleaved logs, how will you see the context for a certain log item?
23:28:33 <jle`> it depends on what you're looking for
23:28:42 <jle`> but you can grep by id
23:29:18 <_sras_> jle`: Yes..it is possible.
23:30:02 <jle`> what would be the work flow if you had them batched...?
23:30:06 <jle`> just scroll up and down?
23:30:40 <jle`> grep -n20, instead of grep {id} ?
23:31:33 <_sras_> jle`: yes. 
23:33:32 <cocreature> you can always write your logs to a database instead of to a file and then you can nicely query by id :)
23:35:27 <_sras_> cocreature: Yes. that is another option. But appending to a file might be a lot faster, right?
23:35:51 <davean> _sras_: or a lot slower
23:35:56 <cocreature> depends
23:36:06 <cocreature> but is logging performance really the bottleneck in your application?
23:37:28 <_sras_> cocreature: no. Because there is no application yet. In the process of building it. I am just trying to make sensible choices....
23:38:02 <cocreature> _sras_: I would expect that a database is more than fast enough (and as davean mentioned can even be faster) for almost all logging usecases
23:38:40 <jle`> what's that quote again?  premature optimization is the root of all something something
23:38:57 <cocreature> evil :)
23:38:59 <ezyang> a pinch of prevention is worth a pound of cure 
23:39:38 <cocreature> I’m not a big fan of that quote however. people tend to use it as an excuse to write slow code :)
23:40:02 <_sras_> jle`: Yes. But don't want to be too reckless..there is also a quote about having everything in moderation...
23:40:14 <ezyang> the moral of premature optimization is not that early optimization is bad (it's really the only way to get things fast) but that usually you don't actually need it fast 
23:41:28 <cocreature> in the end it’s a tradeoff: do the benefits of having fast code outweigh the costs of making it fast?
23:41:32 <jle`> yeah; you end up optimizing something that is like 0.001% of your actual execution time, down to 0.0009%
23:42:39 <davean> or you make your program slower by optimizing one piece, moving complexity to places that can less afford it <-- seen that one a fair bit
23:42:46 <pacak> jle`: That's what I'm doing right now btw. Maybe a bit more than 0.001% and to make it slightly more faster. In some situations it makes perfect sense to do that.
23:42:55 <jle`> or you can make your program slower by taking two months to write it instead of two weeks
23:43:19 <jle`> a program you can run is faster than an incomplete program
23:43:21 <ezyang> as with all life matters, Wisdom and Courage 
23:43:47 <davean> jle`: I don't know about that, I have some VERY fast incomplete programs. Not doing the calculations does amazing things for execution time.
23:44:19 <ezyang> "http://groups.csail.mit.edu/cag/codeperf/" 
23:44:33 <jle`> ezyang: touche
23:45:59 <jle`> in this specific case, writing an entire multi-threaded abstraction system for logging is probably not worth any plausible difference in execution time over using a database
23:46:29 <davean> jle`: well, then clearly its the thing to do.
23:46:38 <davean> jle`: its always the most fun to work on the things that matter the least
23:47:42 <jle`> i cannot think of a reasonable argument against that
23:48:49 <ezyang> TBF, it's pretty easy to setup a logging thread 
