00:11:27 <for{}> hi, guys. does anyone here use vscode?
00:14:50 <nathyong> Cale: ah, that's enlightening. Thanks for your help
00:15:12 <for{}> what editor/ide do you use to code in haskell?
00:15:19 <nathyong> vim mostly
00:15:29 <nathyong> IntelliJ with the "HaskForce" plugin is all right too
00:15:41 <for{}> did you try vscode?
00:15:53 <nathyong> I've used it for python and C++, never for Haskell though
00:16:06 <nathyong> Is there something about the Haskell language plugin that you wanted to know?
00:16:18 <for{}> nathyong, whats the best haskell extension for vscode?
00:17:03 <for{}> in your opinion, of course
00:17:18 <nathyong> for{}: the ghc-mod plugin probably does what you want (syntax checking, autocompletion if you're lucky)
00:17:26 <nathyong> Don't know about that "Haskelly" plugin though
00:17:48 <nathyong> Ah, it runs Intero, which should be a good experience too
00:17:48 <for{}> nathyong, other extensions youd recommend?
00:18:26 <nathyong> for{}: but yeah, basically anything that builds on top of ghc-mod or intero should provide the IDE-ish features that you might be looking for, and anything else is just pretty colours really
00:18:50 <for{}> nathyong, thanks
01:09:34 <eatman> Hi. I tried to hask it on #hakyll but there are only few, idle, people there. Any clue on this problem : https://www.reddit.com/r/haskell/comments/62clhs/hakyll_and_pdf_generation/ ? Thanks a lot in advance!
01:22:32 <brynedwards> eatman: The example here is using "-" as an argument to pipe stdin. Does rubber need to do the same? 
01:22:35 <brynedwards> https://jaspervdj.be/hakyll/reference/Hakyll-Core-UnixFilter.html
01:22:53 <brynedwards> or read from stdin, whatever
01:23:22 <brynedwards> http://manpages.ubuntu.com/manpages/precise/man1/rubber.1.html
01:23:33 <brynedwards> this manpage says rubber-pipe reads from stdin, maybe try that?
01:24:03 <dmj`> is there type level (&&) somewhere convenient
01:25:26 <jle`> dmj`: && in what way
01:25:32 <jle`> Bool -> Bool -> Bool ?
01:26:38 <jle`> singletons has one, :&&
01:33:44 <eatman> brynedwards: http://ix.io/ppV/hs using rubber-pipe gives me non-empty but broken pdf.
01:35:20 <brynedwards> But `cat file.tex | rubber-pipe -d` is fine?
01:37:14 <merijn> brynedwards: Congratulations on your Useless Use of Cat award :)
01:37:27 <brynedwards> :(
01:38:17 <Athas> Beautiful use of cat.
01:38:22 <Athas> Processes are cheap!
01:40:01 <eatman> Athas && merijn : what would you guys do?
01:40:15 <brynedwards> I assume `rubber-pipe -d < file.tex`
01:40:19 <Athas> I would use cat.
01:40:29 <Athas> I find that it reads nicer.
01:40:46 <Athas> It also makes it easier to modify and, to me, conceptually simpler.
01:40:53 <eatman> Yeah but can't realy do it in a Hakyll process...
01:41:05 <brynedwards> I don't do shell much, I'm trying to help debug his thing
01:41:12 <merijn> eatman: If rubber-pipe supports just passing filenames, like most commands "rubber-pipe -d file.tex", otherwise you do "rubber-pipe -d <file.text" in the shell ;)
01:41:41 <merijn> Actually, you *can* do that with Hakyll, well last I remembered anyway
01:41:44 <eatman> Thing is, it works fine in a shell, not during the Hakyll compilation.
01:41:49 <Athas> eatman: what about using 'sh -c' and then an arbitrary shell pipeline?
01:42:07 <merijn> Where does unixFilter come from?
01:42:24 <brynedwards> merijn: https://jaspervdj.be/hakyll/reference/Hakyll-Core-UnixFilter.html
01:42:25 <Athas> I use Hakyll with a Unix pipeline for my own website.   See the bottommost code section here: http://sigkill.dk/programs/sigkill.html
01:43:09 <merijn> And what is rubber-pipe?
01:43:12 <brynedwards> eatman: Does your `latexExampleRaw` change the output in any way? like `curl -o file2.text <URL>` is the same as file.tex?
01:43:23 <brynedwards> http://manpages.ubuntu.com/manpages/precise/man1/rubber.1.html
01:43:35 <merijn> Like, does rubber-pipe output result to stdout?
01:43:58 <eatman> merijn: Yes.
01:44:08 <eatman> And I then have to > it to a pdf file.
01:44:38 <merijn> eatman: And your PDF is broken, right? Not empty
01:44:57 <eatman> From shell it works, not from the Hakyll compile process.
01:45:06 <eatman> brynedwards: no change.
01:45:15 <merijn> eatman: Yeah, but you get broken data in Hakyll, yes? Not no data
01:45:22 <eatman> Broken.
01:45:40 <eatman> I mean, no data using rubber and broken with rubber-pipe.
01:45:47 <Athas> Hm, maybe unixFilter cannot handle zero bytes?
01:45:52 <merijn> I bet $20 on "locale is fucked" with a side-remark off "don't use String"
01:45:54 <Athas> PDFs can contain NUL bytes, rights?
01:46:03 <merijn> unixFilter is converting String based on locale
01:46:13 <merijn> PDF is binary data, so of course it's all fucked
01:46:20 <merijn> You need unixFilterLBS
01:46:23 <brynedwards> You used unixFilterLBS in your first example, can you use it again?
01:46:47 <merijn> Also, what does your machine print when you run "locale" in your shell?
01:46:53 <eatman> http://ix.io/ppR/hs I went back to it.
01:47:25 <eatman> Locale : http://ix.io/ppX
01:48:16 <merijn> Probably want to set LC_ALL to the same value in your .profile
01:48:50 <merijn> So what happens with unixFilterLBS?
01:50:25 <eatman> merijn: done for the .profile; With uniFilterLBS I've the empty file.
01:50:49 <brynedwards> unixFilterLBS and rubber-pipe gives you an empty file?
01:51:02 <eatman> Line 56 to 62 on http://ix.io/ppR/hs
01:51:16 <eatman> Ho, both... didn't try that yet.
01:51:24 <eatman> Give me a second.
01:51:45 <brynedwards> the rubber-pipe command is taking input from stdin, I'm not sure what rubber is doing, maybe just printing to stderr
01:51:53 <brynedwards> Because it's missing a file argument
01:51:59 <merijn> Unrelated: I need naming tips: I have a type Foo which does one action (potentially returning an error), and one that does multiple Foo actions (potentially returning multiple errors). Suggestions on naming?
01:54:01 <merijn> Foo and FooMany? Seems awkward, but I don't have anything better atm...
01:55:07 <eatman> http://ix.io/pq0/hs Appears to work perfectly fine. I'll try with some more complex documents but sounds good to me right now.
01:59:43 <eatman> Well, it works fine for modernCV docs.
01:59:50 <eatman> Thanks a lot!
02:02:48 <Jimmy_> @type map
02:02:50 <lambdabot> (a -> b) -> [a] -> [b]
02:02:51 <Athas> merijn: Foo and [Foo].
02:03:34 <Jimmy_> @list
02:03:35 <lambdabot> What module?  Try @listmodules for some ideas.
02:03:42 <Jimmy_> @listmodules
02:03:42 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
02:03:43 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
02:03:57 <Jimmy_> @source (fmap)
02:03:57 <lambdabot> Unknown command, try @list
02:04:04 <Jimmy_> @list
02:04:04 <lambdabot> What module?  Try @listmodules for some ideas.
02:04:11 <Jimmy_> @help
02:04:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:04:17 <Jimmy_> list
02:04:26 <Jimmy_> @list
02:04:26 <lambdabot> What module?  Try @listmodules for some ideas.
02:04:30 <Jimmy_> @listmodules
02:04:30 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
02:04:30 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
02:04:39 <Jimmy_> @help type
02:04:40 <lambdabot> type <expr>. Return the type of a value
02:04:41 <merijn> Athas: No, it's a transformer stack
02:04:46 <merijn> Athas: With a slightly different base
02:05:18 <Jimmy_> @help src
02:05:18 <lambdabot> src <id>. Display the implementation of a standard function
02:05:34 <Jimmy_> @src ($)
02:05:34 <lambdabot> f $ x = f x
02:05:50 <Jimmy_> @src (<$>)
02:05:51 <lambdabot> f <$> a = fmap f a
02:05:56 <jle`> Jimmy_: btw, you can also use lambdabot in private chat :)
02:06:10 <jle`> using `/q lambdabot ...'
02:06:19 <brynedwards> >:|
02:10:07 <Booba> ertes: Hi again! Mind if I ask a couple more questions about http://community.haskell.org/~ertes/hangman/ ?
02:10:41 <Booba> ertes: you were saying that upsides of the approach that it is compositional and composable.
02:11:20 <Booba> ertes: I can see that. But also I noticed that `move` function is a Kleisli function (of type a -> m a)
02:12:05 <Booba> ertes: and Kleisli function, Kleisle arrow (<=<) and `return` form a category
02:12:22 <Booba> ertes: And category is THE thing that describes compositionality
02:12:51 <Booba> ertes: I am trying to say that monadic interface seems like a good option for the api to me
02:13:09 <Booba> ertes: inspired by http://www.haskellforall.com/2012/08/the-category-design-pattern.html
02:20:57 <Jimmy_> ?q
02:20:57 <lambdabot> Maybe you meant: queue-topic quit quote v @ ? .
02:28:34 <ph88> can anyone recommend a hash function and library? I want a fingerprint of a file, i was thinking of sha256, but maybe others are better
02:29:53 <merijn> ph88: What's the purpose of the fingerprint?
02:30:19 <ertes> Booba: there are no monads involved there
02:30:30 <ertes> Booba: and a monoid is a category
02:30:40 <ph88> merijn, not sure yet, i thought it would come in handy, maybe to check if the file is already in the database
02:30:40 <Booba> ertes: oh, it is, you're right
02:31:15 <merijn> ph88: The intended use is kinda crucial for the choice between a cryptographic hash or a non-crypto one :)
02:32:55 <Booba> ertes: ok, is there a way (a rule of thumb) to pick a category to describe my solution for an exact problem in?
02:33:08 <ph88> merijn, no intent yet .. just thought it would be useful information to store in the database might need it later
02:33:38 <merijn> ph88: MurmurHash3 is a nice fast non-crypto one, else you're probably looking at sha256 or sha3 or whatever
02:33:40 <tdammers> ph88: YAGNI
02:33:45 <ph88> merijn, besides that (on another topic) i also need to generate UUID, i was thinking to generate it off the file content + size, do you think this is a good idea ?
02:34:27 <ph88> https://hackage.haskell.org/package/uuid-1.3.13/docs/Data-UUID-V5.html#v:generateNamed
02:34:38 <ertes> Booba: you need to work with many algebraic patterns, and at some point you develop a sense for it…  but i generally start by generalising my problem
02:34:41 <ph88> i put file + size there as object to make uuid ?
02:35:06 <cocreature> ph88: adding the size seems kind of redundant
02:35:26 <ertes> Booba: i have a problem, i write a DSL for it, then i generalise the DSL as much as possible such that it's still expressive enough for my problem…  very often it turns out to be an algebraic structure that i know
02:35:31 <ph88> i don't think i like this V5 it uses sha1 only 128 bits
02:35:50 <tdammers> also, if you use the content to generate an ID, then it is basically a hash, and you're building a content-addressable system
02:35:54 <tdammers> if that's what you want, go for it
02:36:07 <tdammers> otherwise, using random IDs is easier, faster, and probably good enough
02:36:18 <ph88> what's that a content-addressable system ?
02:36:30 <ertes> Booba: the Hangman type in the repo is not the way i would have written it…  i would have abstracted over what is currently hard-coded as [] to be any Alternative
02:36:49 <ocharles> The documentation for `allocaBytes` states: "The memory is freed when f terminates (either normally or via an exception), so the pointer passed to f must not be used after this.". Yet reading the source of `allocaBytes`, I don't actually see a call to `free` anywhere - so is this strictly true? It seems more that the memory is freed when f terminates *and*
02:36:49 <ocharles> the garbage collector has ran
02:36:52 <ertes> Booba: and perhaps even to any Plus (from the semigroupoids package), such that it can even be Map
02:37:12 <tdammers> ph88: addresses of content items are derived from the content itself (and nothing else)
02:37:29 <Booba> ertes: I see. Thanks! I guess this is what I was looking for in course of these couple of days: a general guide on how to desin solutions to problems haskell way (algebraic way, as you call it)
02:37:32 <ocharles> In particular, I'm building a ForeignPtr on a Ptr built with allocaBytes, and surprised that reading from it outside `allocaBytes` works just as I'd expect... though what I'd really expect is for that memory to be free'd and a seg fault!
02:37:52 <ph88> tdammers, that might be a good thing if someone wants to add a document to the database and generate a uuid it's an easy way to check if the document was already in the database, no ?
02:38:15 <tdammers> ph88: yes. git, for example, is essentially a content-addressable database (and then some)
02:38:17 <Booba> ertes: I could say that it is similar to imperative or object oriented way: I design an exactl solution and generalize it in next iterations.
02:38:28 <Booba> ertes: its just the way to generalize is different
02:38:34 <tdammers> ph88: git uses commit hashes to determine whether two given commits are the same
02:39:18 <ertes> Booba: yeah, i generalise right away mainly for two reasons: to see structures more clearly, and to make implementation easier, because parametricity guides me to the correct solution
02:39:31 <ertes> Booba: example:  f :: Integer -> Integer
02:39:37 <ertes> infinitely many functions
02:39:46 <ertes> but as soon as i generalise, there is only one function left:
02:39:48 <ertes> id :: a -> a
02:39:55 <merijn> ocharles: alloca generally allocates on the stack in C, so I have to look up exactly what GHC is doing
02:40:01 <cocreature> ocharles: I don’t think you’re guaranteed to get a segfault even if the memory was freed. but you seem to be right that allocaBytes doesn’t explictely free
02:40:04 <merijn> ocharles: Also, why would you ever expect a segfault?
02:40:14 <ocharles> merijn: I thought reading from free'd memory would seg fault
02:40:18 <merijn> ocharles: segfaults happen when reading from/writing to unmapped memory
02:40:20 <cocreature> merijn: we’ve had this discussion before but GHC calls things "alloca" that have nothing to do with Cs alloca
02:40:22 <merijn> ocharles: Hah, I wish
02:40:25 <ocharles> oh :)
02:40:36 <muzzle> hi, I have a question about software licensing. Is this off topic here?
02:40:38 <ocharles> yea, GHC alloca is about pinned bytearrays, more
02:40:54 <cocreature> muzzle: yep, this channel is about the Haskell programming language
02:40:55 <ph88> is a uuid only ever 128 bits ?
02:41:04 <ocharles> ok. So I just need to be more careful when I write this code. It "just happening to work in the repl" is not sufficient
02:41:05 <ertes> Booba: note that this isn't quite the same kind of generalisation: you're generalising *solutions*, i'm generalising the *language*
02:41:08 <merijn> ocharles: If the memory is still in the processes memory space (likely, since I don't think GHC ever returns address space) you will happily read garbage data with no way to tell
02:41:19 <muzzle> when I publish a haskell package under LGPL, no non-LGPL/GPL haskell package can use it, right?
02:41:22 <merijn> ocharles: And writing to it will happily corrupt all the rest of your program
02:41:37 <merijn> muzzle: That's not true
02:41:43 <merijn> muzzle: They just can't statically link it
02:41:57 <ocharles> Next question... if I have one Ptr and create two ForeignPtrs, both with finalizeFree... that could lead to a double free. Right?
02:42:03 <merijn> ocharles: Yes
02:42:04 <ocharles> one Ptr created with mallocBytes, that is
02:42:07 <ocharles> ok
02:42:13 <muzzle> merijn, but isn't static linking what stack/cabal do by default?
02:42:14 <ertes> muzzle: don't ask legal questions on IRC…  the FSF has extensive documentation and a comprehensive FAQ
02:42:35 <merijn> muzzle: Yes, but that doesn't stop anyone from performing dynamic linking
02:42:36 <cocreature> ocharles: welcome to the mess that is manual memory management :)
02:42:38 <ocharles> I'm having fun trying to write a Quake 3 BSP parser that does as much mapping of the file buffer directly to Haskell memory without copying. Because why not :)
02:42:42 <ocharles> cocreature: haha, indeed
02:43:03 <merijn> cocreature: This is why I manage all my memory via stack and mmap in C++ ;)
02:43:44 <cocreature> merijn: I just throw unique_ptr and shared_ptr on everything and hope that I never need to worry about performance problems of shared_ptr
02:44:01 <merijn> shared_ptr all the things ;)
02:44:04 <ocharles> I wonder why bytestring doesn't export any functions to build bytestrings from foreignptrs
02:44:04 <merijn> hmmm
02:44:14 <merijn> I seem to be really good at panicing GHC...
02:44:16 <ocharles> or am I just blind?
02:44:24 <ocharles> merijn: I have been making GHC panic a lot more recently :(
02:44:25 <merijn> ocharles: You're just blind :)
02:44:47 <cocreature> ocharles: the internal module exports the constructor iirc
02:44:54 <merijn> ocharles: Data.ByteString.Unsafe
02:45:00 <ocharles> cocreature: right, but that seems really really really unsafe. I don't get why it's not in Unsafe
02:45:03 <ocharles> merijn: that is Ptr not ForeignPtr
02:45:21 <ertes> muzzle: https://www.gnu.org/licenses/gpl-faq.html#LGPLStaticVsDynamic
02:45:36 <merijn> ocharles: Oh, yes...but you can't sensibly build one from a ForeignPtr (since you have to convert ForeignPtr to Ptr before using)
02:45:49 <ocharles> I don't understand. ByteString *is* a wrapper over ForeignPtr
02:45:54 <ocharles> as cocreature said, that's literally the constructor
02:46:04 <merijn> Maybe the constructor is indeed exporte
02:46:09 <ocharles> it is, in Internal
02:46:13 <cocreature> ocharles: well exposing a function that constructs based on ForeignPtr would make it really hard to change the internals
02:46:15 <ph88> what does this first argument "UUID namespace" mean ?  https://hackage.haskell.org/package/uuid-1.3.13/docs/Data-UUID-V5.html#v:generateNamed
02:46:19 <int-e> ocharles: I think Internal implies Unsafe and potential volatility of the interface
02:46:21 <ocharles> cocreature: ah
02:46:24 <cocreature> so I don’t think it’s that unreasonable to require that you use the constructor
02:46:37 <ocharles> that's a fair point
02:46:46 <ph88> the namespaces below it do not match the purpose i had in mind
02:47:05 <cocreature> ocharles: also at this point it’s probably really unlikely that the internal representation of ByteString changes, so you should be relatively safe :)
02:47:10 <ocharles> :)
02:47:45 <cocreature> that reminds me, I still need to submit a bunch of PRs to bytestring to make ShortByteString actually usable
02:47:47 <ph88> hhmm i will read this http://stackoverflow.com/a/15395191
02:48:02 <merijn> ocharles: I'm making GHC panic at -O0 with no discernible reason >.>
02:48:29 <merijn> Well, it seems to be caused by enabling -fdefer-typed-holes, but I don't understand why :(
02:49:10 <ocharles> merijn: oh, I reported a panic just like that
02:50:48 <merijn> ocharles: Goddammit
02:50:57 <merijn> The regression I reported ages ago is still here :(
02:51:00 <merijn> That's the issue
02:51:00 <ocharles> bah, looks like I didn't report it, just commented on an existing report. But trac search is so bad
02:51:13 <merijn> It's now treating any identifier not in scope as a typed hole
02:51:21 <merijn> So I wasn't seeing the error with -fno-warn-typed-holes
02:53:51 <merijn> ocharles: Do you know if I can search trac based on what tickets I've commented on?
02:53:57 <ocharles> no, that's what I was trying to do
02:54:00 <ocharles> I couldn't find a way
02:54:40 <rabbi1> hi all, trying to learn haskell from MVC way, any suggestions ?
02:55:11 <srhb> rabbi1: "don't" ?
02:55:37 <rabbi1> srhb: ??
02:55:38 <merijn> @(&(%&(&% now I remember why I didn't update to 8 earlier
02:55:38 <lambdabot> Unknown command, try @list
02:55:46 <merijn> This is completely unacceptable >.<
02:56:17 <srhb> rabbi1: I personally don't think the traditional MVC pattern fits most Haskell programs very well, so I advise against it.
02:56:28 <srhb> But that's just my personal recommendation :-)
02:58:07 <merijn> ocharles: Even worse, I was right, my issue was fixed in 8.0.2, I just don't have that as the website only has a 8.0.1 binary for OSX >.<
02:58:12 <rabbi1> srhb: i am looking as haskell after pretty long time, too many frameworks already. adding to my confusion :(
02:58:21 <riaqn> Hi, I may have asked a similar question yesterday. But what's a more efficient version of (State (IArray i e) a)? the length of the array is fixed.
03:02:29 <jle`> riaqn: efficient with respect to what operations?
03:02:41 <riaqn> ahh, random write.
03:04:14 <dmj`> riaqn: MVector in ST or IO would be more efficient
03:06:46 <riaqn> dmj`: maybe I'm wrong. But from what I saw, ST allows create new Array?
03:07:03 <riaqn> while I want to make sure that it's just some modification to a single fixed-length array.
03:07:26 <stephAne> hi. It's the first time I use Data.Binary. I had a simple serialization mechanism based on show and read, and now I use Data.Binary encode and decode. When writing over the network I was using System.IO hPutStrLn which awaits a [Char]. Now that my code has change the compiler complains that Lazy.Interal.ByteString is not a [Char].  My problem is that I don't find a System.IO function that takes Lazy.Internal.ByteString as input. W
03:07:34 <riaqn> something like [(Int, a)], a list of keys to update.
03:08:06 <dmj`> riaqn: it allows for mutability
03:08:09 <stephAne> I mean, the most common way to write Lazy.Internal.ByteString to a hand ?
03:08:14 <stephAne> handle
03:08:56 <dmj`> stephAne: I’d watch out for hPutStrLn some use cases make a single system call per character, really inefficient on the kernel. 
03:09:16 <phadej> stephAne: there is hPutStr for bytestring
03:09:17 <phadej> s
03:09:22 <brynedwards> stephAne: https://www.stackage.org/haddock/lts-8.6/bytestring-0.10.8.1/Data-ByteString-Lazy.html#g:28
03:10:02 <dmj`> riaqn: a [] in haskell is a linked list, different rep. Most efficient use of a vector is probably and unboxed mutable one, but that requires your type to have an Unbox constraint
03:10:09 <rabbi1> srhb: any book suggestion
03:10:12 <phadej> but there aren't hPutStrLn as "new line charcter" is something which (could) depend on encoding
03:10:33 <stephAne> no pb, I will rely on hPutStr, seems really nice
03:11:01 <riaqn> dmj`: well I think box/unbox 's difference is negliable compared to mutable/immutable.
03:11:41 <riaqn> I honestly just want a faster (State (Array i e) a)..
03:11:53 <dmj`> riaqn: why use a State?
03:12:09 <dmj`> how is the state related to the Array I guess
03:12:18 <_sras_> Is there a way to insert an html string that I trust into a lucid template?
03:12:25 <riaqn> I'm just illustrating the idea.
03:12:30 <jle`> riaqn: you can do `ReaderT (STArray s i e) (ST s)` instead, maybe
03:13:04 <riaqn> jle`: yeah, but still no restriction on the ST monad.
03:13:13 <jle`> what restriction do you mean
03:13:18 <riaqn> user can still (lift $ newSTArray)
03:13:27 <jle`> sure, but that doesn't affect the state
03:13:31 <jle`> that just makes a new array
03:13:47 <jle`> it doesn't modify the (STArray s i e) that is your state
03:14:03 <riaqn> yeah you are right. let me think.
03:15:04 <ertes> riaqn: why do you use State at all there?
03:15:11 <ertes> (or rather StateT)
03:15:18 <riaqn> ertes: just illustrating the idea.
03:15:39 <riaqn> that, "this is what I want, now what's the real approach?
03:15:59 <ertes> riaqn: create an array in ST, the modify it
03:16:07 <ertes> *then
03:17:49 <riaqn> jle`: I think it's doable. Thanks
03:18:06 <ertes> ReaderT is just going to be an awkward version of the same thing
03:18:34 <stephAne> in Data.ByteString.Lazy, hGetContents :: Handle -> IO ByteString  will close the handle when the content has been read... unfortunately, I use Network.Socket sockets, and I was using the same handle for answering to the client. Do you think I am doing things wrong ? I'm keep on searching, but I'd just like your point of view.
03:18:56 <ertes> stephAne: yes, don't use lazy input
03:19:42 <ertes> stephAne: the proper low-level way to do this is to use regular blockwise reading and processing, the high-level way is to use a streaming abstraction like pipes
03:20:39 <stephAne> okay, I'm going to search about that. Pipes looks more entincing, judging by the name.
03:21:52 <ertes> stephAne: with pipes you would typically use these libraries:  https://hackage.haskell.org/package/pipes, https://hackage.haskell.org/package/pipes-bytestring, https://hackage.haskell.org/package/pipes-network
03:21:59 <bollu> cocreature: ping
03:22:05 <ertes> stephAne: the pipes package has a Pipes.Tutorial module that explains the basics
03:22:06 <bollu> cocreature: are the docs for llvm-hs built anywhere?
03:22:18 <riaqn> there are like what, maybe 50 pipes library in haskell?
03:22:19 <stephAne> ertes: great, many thanks
03:22:25 <riaqn> all incompatible to each other.
03:22:54 <stephAne> :-)
03:22:59 <ertes> riaqn: some of them are compatible…  for example pipes and conduit
03:29:11 <cocreature> bollu: the 4.0.0.0 docs are on hackage. I had to push a bugfix update earlier and didn’t get around to uploading the docs for that yet but the API is the same
03:29:52 <bollu> cocreature: I see. https://hackage.haskell.org/package/llvm-hs The docs are not linked for me on the webpage, are they for you?
03:30:14 <cocreature> bollu: you need to click on the 4.0.0.0 version https://hackage.haskell.org/package/llvm-hs-4.0.0.0
03:30:26 <bollu> cocreature: ah, thanks!
03:31:20 <bollu> what is the "mtl versus Free" debate? I understand how Free works and what mtl does, but I do not see how they can be related
03:31:31 <bollu> Free tries to build an AST and then evaluate it
03:31:35 <bollu> mtl allows you to layer effects
03:31:38 <bollu> where is the connection?
03:31:54 <jle`> Free also lets you compose effects as well
03:32:12 <bollu> jle`: quick example?
03:32:25 <bollu> jle`: and I do not understand why people say that Free is slower than MTL (?)
03:32:25 <tdammers> they are both abstractions that help you compose EDSLs
03:32:43 <jle`> `Free (f :*: g)` gives you the effects of both f and g
03:33:01 <bollu> jle`: what is (:*:) ?
03:33:06 <bollu> :t (:*:)
03:33:07 <lambdabot> error: Data constructor not in scope: :*:
03:33:17 <jle`> data (f :*: g) a = f a :*: g a
03:33:25 <jle`> functor product
03:33:52 <bollu> hm
03:33:58 <bollu> interesting
03:34:04 <jle`> @import GHC.Generics ((:*:)(..))
03:34:05 <lambdabot> Unknown command, try @list
03:34:13 <bollu> jle`: so, the debate is "which is better to compose effects"?
03:34:13 <jle`> @let import GHC.Generics ((:*:)(..))
03:34:14 <lambdabot>  Defined.
03:34:35 <jle`> :t (Left 'a') :*: "hello"
03:34:36 <lambdabot> (:*:) (Either Char) [] Char
03:34:48 <jle`> er
03:34:52 <jle`> :t (Left 'a') :*: [1,2,3]
03:34:54 <lambdabot> Num p => (:*:) (Either Char) [] p
03:35:01 <bollu> interesting
03:35:01 <jle`> (Either Char :*: []) Int
03:35:36 <jle`> and there's (:+:), which lets you use 'commands' from either functor
03:36:05 <jle`> so if you had Free (f :+: g), each 'layer' could be an action from the f Functor, or an action from the g Functor
03:36:17 <bollu> I see
03:36:28 <bollu> where is this from? :*: and :+:?
03:36:49 <jle`> so if f was AST1, and g was AST2, then Free (f :+: g) would have elemenents of both ast 1 and ast 2
03:37:03 <jle`> :*:/:+: are awkwardly from GHC.Generics
03:37:11 <jle`> but they have non-operator equivalents too, Product and Sum
03:37:15 <jle`> in Data.Functor.*
03:38:53 <bollu> OK
03:38:58 <jle`> this method is called the 'data types a la carte' style
03:39:15 <bollu> so, what about things like non-commutative effects and stuff? and repeated layers of the same effect?
03:39:23 <bollu> from what I understand, mtl has no solution to #2
03:40:03 <bollu> also, one other question: why is Free considered slower than mtl?
03:40:23 <jle`> well, mtl doesn't actually export any data types
03:40:33 <jle`> so i don't think it's a fair comparison
03:40:50 <jle`> er, i mean, it doesn't define any data types.
03:40:58 <jle`> mtl is just a bunch of typeclasses
03:41:08 <jle`> the instances you have for those typeclasses can be as efficient or inefficient as you wnat
03:41:27 <mniip> it does instantiate the typeclasses
03:41:31 <mniip> for types in transformers
03:42:06 <bollu> hm
03:42:17 <bollu> but, will Free be slower *by definition* or something?
03:42:20 <jle`> it does do that, but you aren't required to use those types as your instances
03:42:31 <bollu> when comparing  say the fastest Free implementation to the fastest mtl impementatin?
03:42:40 <jle`> most of the times i use mtl typeclasses is with types that aren't from transformers
03:43:09 <jle`> i don't know enough to give a meaningful answer to your actual question, sorry, so i'll duck out here :)
03:43:51 <bollu> OK :)
03:47:08 <maerwald> the only performance comparison I know of is in olegs paper
03:47:56 <maerwald> http://okmij.org/ftp/Haskell/extensible/more.pdf page 7
04:02:12 <ski> @type Data.Array.ST.runSTArray  -- riaqn, perhaps
04:02:13 <lambdabot> (forall s. ST s (GHC.Arr.STArray s i e)) -> Array i e
04:03:11 <riaqn> ski: I don't know... it's an imperative program that returns an array..
04:03:18 <riaqn> externally just a pure function returning an array..
04:03:49 <riaqn> anyway.. I will try all approaches and see if I can make my question more specific..
04:13:59 <ph88> how do i go from lazy bytestring to text?
04:14:32 <cocreature> ph88: Data.Text.Lazy.Encoding
04:14:43 <cocreature> obviously decoding functions are in the module called Encoding
04:14:54 <ph88> thx
04:15:51 <ski> (and then encoding functions are in `Decoding' ?)
04:16:07 <cocreature> ski: nah they are actually in the same module :)
04:17:04 * ski was fearing so
04:30:18 <tobiasBora> Hello,
04:31:18 <cocreature> hey tobiasBora 
04:31:55 <tobiasBora> I'm having a problem with a program that needs to open a big file (136M), and for each lines it perform some operations on it, and write the result in a given file. And my program uses multicore and multithreads (using Parallel.IO)
04:32:07 <tobiasBora> The thing is that my program runs out of memory
04:32:16 <tobiasBora> (it crashs my computer)
04:32:26 <cocreature> tobiasBora: how do you read the file?
04:33:06 <tobiasBora> cocreature: I'm using "parseInputFile" from Parsec.
04:33:32 <tobiasBora> I think that this is not lazy?
04:34:26 <cocreature> tobiasBora: for a file that large you might want to consider switching to "attoparsec"
04:34:27 <tobiasBora> And by the way, is it possible to use the parallel functions on a lazy list, or do I need to eval it before?
04:34:39 <tobiasBora> cocreature: Ok I'll try.
04:35:05 * tobiasBora must leave now, but comes back later, will read the answers, and annoy you again
04:35:56 <msl09> hello again
04:36:20 <msl09> I'm confused about this line of code "map print [1,2,3,4]"
04:36:30 <cocreature> msl09: confused how?
04:36:39 <msl09> when I input it to ghci I get an error
04:36:50 <msl09> No instance for (Show (IO ())) arising from a use of ‘print’
04:36:58 <cocreature> msl09: you probably want mapM_ print [1,2,3,4]
04:37:03 <cocreature> :t map print [1,2,3,4]
04:37:05 <lambdabot> [IO ()]
04:37:10 <cocreature> :t mapM_ print [1,2,3,4]
04:37:12 <lambdabot> IO ()
04:37:20 <msl09> right
04:38:04 <msl09> isn't the default behaviour of ghci to "put a print" at the end of every statement evaluated
04:38:13 <msl09> :t print
04:38:14 <lambdabot> Show a => a -> IO ()
04:38:23 <mniip> right
04:38:31 <cocreature> msl09: that’s exactly what’s happening here
04:38:36 <mniip> but [IO ()] is not Show
04:38:39 <cocreature> so it’s calling print (map print [1,2,3,4])
04:38:48 <cocreature> which requires a Show instance on [IO ()]
04:38:54 <cocreature> which requires a Show instance on IO ()
04:39:01 <cocreature> and that’s the error you’re seeing
04:39:41 <brynedwards> I guess leaving out the print would be "map id [1,2,3,4]"
04:39:46 <brynedwards> ...or just [1,2,3,4]
04:40:43 <msl09> ah I see now
04:40:58 <Axman6> :t  map print [1,2,3,4]
04:41:00 <lambdabot> [IO ()]
04:41:13 <msl09> now that I read it in that light the error was very clear
04:41:17 <Axman6> bleh, that was already said. late aagin to the party!
04:54:08 <ph88> if i want to parse all characters that are not double quote, should i use lookAhead ?
04:56:11 <ph88> i want to parse    "pdf:PDFVersion","1.4"
04:56:30 <riaqn> Hi is there some cooperative threading library? I hope it can be escaped (like ST). That is, inside there are many thread running, but I can escape it and the whole function behaves as pure.
04:56:52 <riaqn> This can be done by Cont monad, but I also need some signal between thread.
04:57:40 <ph88> oh i can use someTill
05:16:38 <cliodne> Hi, a beginner here. Can someone take a look at my thread, thank you. https://www.reddit.com/r/haskell/comments/62dkby/eli5_function_composition/
05:18:29 <ski> "follow the types"
05:18:37 <ph88> i try to use   https://hackage.haskell.org/package/megaparsec-5.2.0/docs/Text-Megaparsec-ByteString-Lazy.html   but i still have to input  String into the parse function .. i don't understand   https://hackage.haskell.org/package/megaparsec-5.2.0/docs/Text-Megaparsec.html#v:parse  
05:18:59 <ski> cliodne : you have
05:19:01 <ski>   act :: (a -> d -> c) -> (b -> a) -> ((a -> a) -> b -> d) -> b -> c
05:19:06 <ski>   act = ?
05:19:48 <ski> you can see immediately from the type signature that `act' will be a function that takes four arguments, one after another, so
05:20:01 <ski>   act f g h x = ?
05:20:04 <ski> where we know
05:20:10 <ski>   f :: a -> d -> c
05:20:15 <ski>   g :: b -> a
05:20:24 <ski>   h :: (a -> a) -> b -> d
05:20:27 <ski>   x :: b
05:20:33 <ski> and we want to construct the result
05:20:37 <ski>   ? :: c
05:20:46 <ski> cliodne : makes sense, so far ?
05:21:09 <cliodne> yes
05:21:37 <ski> now, the only way we can get a `c' here (which is an *unknown* type, from our point of view) is by calling `f' on two arguments
05:21:42 <ski> you see that ?
05:22:01 <cliodne> a and d?
05:22:08 <ski> yes, so now we have
05:22:15 <ski>   act f g h x = f ?0 ?1
05:22:28 <ski> where we now want to solve the goals / plug the holes :
05:22:31 <ski>   ?0 :: a
05:22:35 <ski>   ?1 :: d
05:23:20 <ski> if we decide to look at `?0', then we notice that the only way we can get hold of an `a' is by calling `g', so let's do that
05:23:38 <ski>   act f g h x = f (g ?2) ?1
05:23:40 <ski> where now
05:23:46 <ski>   ?2 :: b
05:23:50 <ski> cliodne, ok ?
05:24:11 <cliodne> ok
05:24:19 <ski> now, do you see where we could get a `b' from ?
05:24:26 <cliodne> x?
05:24:30 <ski> yes
05:24:43 <ski> in fact, that's the only way we can get a `b', even
05:24:44 <ski> so
05:24:49 <ski>   act f g h x = f (g x) ?1
05:24:59 <ski> and we're now left with satisfying the goal
05:25:03 <ski>   ?1 :: d
05:25:22 <ski> will you do the next step here ?
05:25:24 <cliodne> so h?
05:25:38 <ski> applied to how many new goals/holes ?
05:25:56 <cliodne> one?
05:26:05 <ski> sorry, nope
05:26:26 <ski> `h ?3' would have type `b -> d', not `d' (if `?3' has type `a -> a')
05:26:50 <ski> we want `?1' to have type `d', so we have to replace that hole with an expression of that type
05:27:32 <ski> try again ?
05:28:03 <cliodne> ok, give me a sec. I'll go through everything once more. (english is not my first language sorry)
05:28:11 <ski> no worry, take your time
05:30:16 <lyxia> ph88: Do you mean "Name of source file"?
05:31:20 <ph88> lyxia, i think i actually forgot to supply the parser function -____-
05:35:52 <tobiasBora> So I'm back
05:35:58 <cliodne> ski: so we have two new holes?
05:36:09 <ph88> lyxia, i supplied the parser function but the error remains
05:36:36 <ski> cliodne : yes, because we need to apply `h' to two arguments, in order to get a result of type `d' (which is what needs to fill the `?1' hole)
05:36:37 <tobiasBora> Let's imagine I use Attoparsec now, to parse a file containing on each list basically three elements separated by comas
05:36:41 <ski> cliodne : so
05:36:43 <ski>   act f g h x = f (g x) (h ?3 ?4)
05:36:50 <ski> where the goals now are
05:36:59 <ski>   ?3 :: a -> a
05:37:03 <ski>   ?4 :: b
05:37:33 <ski> cliodne : any idea how to satisfy the goal `?3' here ?
05:37:53 <tobiasBora> If Attoparsec gives me a list, first, would it be a lazy list ? So that when I then run parallelE from Parallel.IO, it never stores the whole file?
05:38:15 <lyxia> ph88: paste your code
05:38:16 <cliodne> not at first
05:38:36 <ph88> lyxia, i keep messing up arguments and stuff .. got it to compile now
05:38:38 <ski> cliodne : well, this situation is unlike what we had before (except at the very start, though you probably didn't notice that) ..
05:38:59 <ski> cliodne : .. `?3', the first argument to `h', should itself be a function. so we have to construct a function here
05:39:37 <bollu> what is the status of data parallel haskell?
05:39:49 <ski> cliodne : there could be many ways to construct a function, but the most direct way is to use a "lambda expression", aka a "function abstraction" or sometimes an "anonymous function" -- are you familiar with that ?
05:40:34 <cliodne> somewhat
05:40:35 <lyxia> tobiasBora: it won't be lazy
05:40:48 <lyxia> tobiasBora: it's going to parse the whole file before giving you a result
05:41:07 <stephAne> Just a reminder for me: I think I saw it once, but I don't remember the meaning of | m -> e in this : class (Monad m) => MonadError e m | m -> e where ... I try to interpret it as a guard but it doesnt sparkle anything in my mind.
05:41:29 <lyxia> stephAne: It's called functional dependencies
05:41:46 <ski> cliodne : an expression `\t -> t^2' is a value, a *function* value, describing "the function that, given an input, call it `t', returns `t^2'"
05:42:10 <ski> cliodne : in our case, we can invent a function `\y -> ?5', like so :
05:42:11 <bollu> stephAne: It means that given an "m", an "e" can be determined uniquely
05:42:21 <bollu> stephAne: AFAIK, all FunDeps can be expressed as type families
05:42:22 <ski>   act f g h x = f (g x) (h (\y -> ?5) ?4)
05:42:27 <ski> where the goals now are
05:42:29 <tobiasBora> lyxia: Hum... So how could I proceed? By the way, can parallel.IO work with lazy lists?
05:42:35 <ski>   ?5 :: a
05:42:40 <ski>   ?4 :: b
05:42:49 <ski> and we now have a *new* assumption/resource :
05:42:51 <ski>   y :: a
05:43:07 <ski> that's available for possible use in `?5' (but not in `?4')
05:43:09 <ski> cliodne : ok ?
05:43:45 <cliodne> ?4 would be x?
05:43:45 <lambdabot> Maybe you meant: v @ ? .
05:43:48 <merijn> hmmm, can I somehow avoid the pattern match here? http://lpaste.net/354095
05:43:54 <merijn> I can't seem to think of how
05:44:15 <ski> cliodne : yes, you can plug `?4' with `x' already :)
05:44:22 <ski>   act f g h x = f (g x) (h (\y -> ?5) x)
05:44:26 <ski> leaving
05:44:32 <ski>   ?5 :: a
05:44:40 <ski> where the available resources now are
05:44:40 <cliodne> ok, thank you so much ski 
05:44:44 <ski>   f :: a -> d -> c
05:44:46 <ski>   g :: b -> a
05:44:50 <ski>   h :: (a -> a) -> b -> d
05:44:50 <lyxia> tobiasBora: AFAICT parallel-io is going to force the spine of the list first. Why are you using parallel-io?
05:44:52 <ski>   x :: b
05:44:55 <ski>   y :: a
05:45:12 <ski> cliodne : so there's one more hole to plug, `?5', of type `a'
05:45:21 <cliodne> I think I understand. going to c/p this conv to my notepad and go through it again
05:45:21 <ski> cliodne : can you see how to satisfy this goal ?
05:45:36 <lyxia> merijn: runReaderT ?
05:45:44 <ski> (cliodne : there's in fact more than one way to satisfy this goal ..)
05:46:02 <tobiasBora> lyxia: Because I'd like to share the computation (IO computation) between lot's of threads... What else could I use?
05:47:07 <ski> cliodne : i think it helps to think of it as a kind of game, with set rules for how to "move" in each of the currently "open" goal/hole positions. the task is to satisfy all the individual goals
05:47:56 <ski> in each position, there are some resources, that one can use to satisfy the demand/goal. in some positions, (such as `?5' here), there may be more, additional, resources available
05:48:17 <lyxia> tobiasBora: okay, somehow I was disturbed by the juxtaposition of attoparsec and parallel-io.
05:48:26 <ski> cliodne : i hope this helps to understand what i meant by "follow the types". i have to leave now. good luck
05:48:42 <cliodne> thank you!
05:49:45 <lyxia> merijn: mapReaderT
05:49:46 <ski> (do try to see if you can figure out all the possible ways to plug `?5', btw)
05:50:24 <merijn> lyxia: Ah! That's the magic I missed!
05:52:18 <tobiasBora> lyxia: Yes, it's attoparsec --> string list --> parallel-io. But if parallel-io forces me to evaluate the list, I will never be able to lazilly read my file... Is there a better program that parallel-io that do not force evaluation of the list?
05:57:40 <lyxia> tobiasBora: doesn't attoparsec have to read the whole contents before giving you a result?
05:58:50 <tobiasBora> lyxia: Well it's line by line that it can parse it
06:08:49 <lyxia> tobiasBora: I can't find anything, but there's still the option of setting up your own concurrency scheme with stm.
06:15:16 <ph88> how can i turn this  Digest a  into a normal scalar type?   https://hackage.haskell.org/package/cryptonite-0.22/docs/Crypto-Hash.html#v:hash
06:16:39 <tobiasBora> lyxia: I wanted to avoid that, but if it's the only solution... Just, even if I use `endBy` parser it won't be a lazy string that will be procuced?
06:17:35 <mutsig> ph88: doesn't `show` do what you want? I'm not familiar with that stuff tho...
06:17:38 <tobiasBora> Hum... it makes sens indeed because it returns Either...
06:17:56 <tobiasBora> so he first need to know if he can parse it.
06:17:59 <ph88> mutsig, i thought show was only supposed to be used for debugging
06:18:44 <mutsig> ph88: you might be confused with "traceShow"?
06:18:55 <Gurkenglas_> No, ph88's got that right
06:19:28 <Gurkenglas_> But some libraries ignore that and the closest thing we've got to a Show law that show should produce strings that can be pasted into code to recover values
06:19:33 <merijn> mutsig: show is also not really for "real" use either
06:20:06 <ph88> yeah that method exist    show :: SHA3_512 -> String     but should i use it ?
06:20:26 <mutsig> merijn: why is that? You meen show in general? or for crypto stuff=
06:20:32 <mutsig> ?*
06:20:32 <lambdabot> Maybe you meant: v @ ? .
06:20:33 <merijn> mutsig: show in general
06:20:50 <merijn> mutsig: Because it's supposed to print "valid Haskell" and thus not really suitable for user output
06:21:06 <merijn> Better of using some pretty printing library in most cases
06:21:55 <lpaste_> msl09 pasted “test stream” at http://lpaste.net/354096
06:22:08 <msl09> ok I have another question
06:22:10 <mutsig> merijn: ok, good to know. However, I haven't had a problem with it so far, and I use it...
06:22:19 <msl09> the code I just pasted
06:22:52 <msl09> as I understand takes a stream of characters and puts it to the stdout
06:22:55 <msl09> lazily
06:23:16 <merijn> mutsig: It's ok if you're writing quick throwaway programs and small prototypes, but not really good for "real world" code. Even things like "printing a number", you probably want some locale aware representation, rather than just
06:23:21 <merijn> > show 123456789
06:23:24 <lambdabot>  "123456789"
06:23:42 <merijn> Often you'd want to print it as, e.g. "123,456,789" instead
06:23:46 <ph88> anyone here used cryptonite with hash function ?
06:23:50 <merijn> Or dots as thousand separator
06:24:03 <msl09> my optmistic belief were that the characters would be spit out as they were being read
06:24:11 <msl09> but that's not what happened
06:24:14 <Boomerang> ms109: That looks right, but it is line buffered by default
06:24:42 <msl09> I know that becase I used a 200mb file
06:24:57 <msl09> and the code simply hang
06:25:02 <merijn> msl09: getContents is also pretty awful for a 200mb file :)
06:25:31 <merijn> msl09: You should probably use Data.Text.Lazy.getContents and their uppercase function :)
06:26:34 <ph88> i think i'm supposed to use the ByteArrayAccess instance of Digest
06:27:47 <msl09> how do I know that?
06:28:14 <merijn> msl09: How do you know what? :)
06:28:24 <msl09> get contents from prelude shows the following documentation:
06:28:26 <msl09> The getContents operation returns all user input as a single string, which is read lazily as it is needed (same as hGetContents stdin). 
06:28:46 <msl09> while text.lazy:
06:28:47 <msl09> Lazily read all user input on stdin as a single string. 
06:28:58 <msl09> am I missing something?
06:29:25 <merijn> msl09: Prelude returns String, Text.Lazy returns Text, which is much better for doing textual IO
06:29:38 <ph88> how do i go from something that has ByteArrayAccess to Text ?
06:38:39 <lyxia> ph88: http://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Foreign.html
06:39:19 <lyxia> hmm that does not do decoding
06:39:21 <ph88> oi FFI
06:39:26 <ph88> sha3 :: B.ByteString -> Text
06:39:27 <ph88> sha3 = decodeLatin1 $ Data.ByteArray.convert hash
06:39:29 <ph88> i try this at the moment
06:40:12 <lyxia> why are you turning a digest to text
06:40:56 <lyxia> if you're going to print it I guess a hex encoding would be better.
06:42:52 <ph88> lyxia, i will use the hash as primary key in my database
06:43:26 <ph88> lyxia, the DocId constructor takes Text   https://hackage.haskell.org/package/bloodhound-0.13.0.0/docs/Database-V5-Bloodhound-Types.html#t:DocId
06:43:46 <msl09> merijn: ok so Prelude.getContents returns lazily but putStr needs to consume the hole string, is that correct?
06:43:49 <ph88> should i use Text with hexidecimal representation ?
06:44:49 <leshow> :t mapM
06:44:51 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
06:44:58 <leshow> :t traverse
06:44:59 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
06:45:03 <brynedwards> Maybe base16-bytestring for hex
06:45:34 <leshow> can I still use do notation inside the function passed to traverse?
06:45:50 <leshow> when would i want to use mapM over traverse
06:46:20 <msl09> otherwise I don't understand why the program hangs without printing anything
06:46:29 <lyxia> leshow: traverse (\x -> do { stuff; stuff })
06:48:22 <lyxia> leshow: mapM might be more convenient in older versions of base, when Applicative was not a superclass of Monad.
06:48:38 <leshow> lyxia, right so applicative is a superclass of monad
06:48:48 <leshow> cool
06:56:04 <phz_> hey: hunit or quickcheck?
06:56:10 <phz_> I’m struggling to pick one
06:57:25 <fuzzy-id> phz_: what do you want to test?
06:57:33 <phz_> unit testing for now
06:57:38 <lyxia> they're not mutually exclusive...
06:57:38 <phz_> properties and monadic results
06:57:49 <phz_> lyxia: in which terms?
06:58:19 <lyxia> you can have some tests using one framework, and some more using the other
06:58:31 <phz_> why would I do that?
06:58:33 <phz_> I want unification
06:58:51 <fuzzy-id> because they test different aspects of your code
06:58:54 <phz_> which ones?
07:00:23 <fuzzy-id> you got me at this one :)
07:00:49 <lyxia> unit testing makes it easy to specify edge cases
07:01:40 <lyxia> and you can say exactly the expected result on some inputs
07:01:45 <oherrala> phz_: pick something like Tasty for testing framework. then you can combine multiple testing methods under same tool
07:01:52 <lyxia> this is not always possible to do with property based testing
07:03:17 <fuzzy-id> wrapping my head around property-testing/quickcheck was a really interesting experience
07:03:30 <fuzzy-id> reading about it I was able to grasp what it is about
07:03:42 <fuzzy-id> but understanding came with implementing a few properties
07:04:03 <fuzzy-id> phz_: try it and you will see that neither of them is a swiss army knife…
07:04:48 <fuzzy-id> use a meta-testing framework like tasty and see how far you get…
07:13:50 <James123> Can someone possibly explain what is the difference between '$' and '$!' operators?
07:14:29 <Welkin> :t ($!)
07:14:31 <lambdabot> (a -> b) -> a -> b
07:14:34 <Welkin> lol
07:15:13 <Welkin> I think it is strict in evaluation
07:15:25 <lyxia> it is
07:15:45 <brynedwards> https://wiki.haskell.org/Performance/Strictness#Evaluating_expressions_strictly
07:17:11 <tobiasBora> lyxia: Indeed, I tried to run parallel_ $ map (\n -> putStrLn $ show n) [1..], and it never starts to display anothing, so Parallel.IO is not Lazy... Does anyone knows if there is a version which is lazy?
07:20:59 <the_2nd> Can I define a where clause which is visible for all definitions of the function? When there's multiple implementations for the function depending on the passed types
07:21:23 <the_2nd> f (Foo x) = 
07:21:28 <the_2nd> f (Bar x) = 
07:21:39 <the_2nd> where both have access to the local definition
07:21:44 <Boomerang> the_2nd: you can use a case statement instead of pattern match
07:22:29 <Boomerang> the_2nd: But you can't access x in your where clause
07:23:46 <stephAne> I'm reading a paper introducing Monad Transformers, https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/monad-transformers-step-by-step.pdf, at page 7, I have extracted the little code I don't understand: http://lpaste.net/354098.   In short, how does the Maybe monad knows how to return inside the Eval2 monad of this example ?
07:24:29 <Boomerang> the_2nd: So it would be: f fooBar = case fooBar of Foo x -> ...; Bar x -> ...; where ...
07:24:30 <merijn> stephAne: What's the type of Map.lookup?
07:24:41 <merijn> stephAne: Or is it just the one from Data.Map?
07:25:00 <merijn> stephAne: Also, how is Eval2 defined?
07:25:37 <stephAne> ithe type of Map.lookup is Maybe a
07:25:39 <the_2nd> Boomerang, I guess I could define a local function within the where
07:25:43 <stephAne> return type 
07:25:46 <the_2nd> which is pattern matched
07:26:03 <merijn> stephAne: Honestly, depending on what Eval2 is, that looks like a typo/bug to me
07:26:12 <stephAne> type Eval2 α = ErrorT String Identity α
07:26:17 <Boomerang> the_2nd: Yeah exactly, and if you need you can have sub-where clause in each branch of the case statement
07:26:23 <stephAne> with the function: runEval2 :: Eval2 α → Either String α
07:26:33 <merijn> stephAne: Right, that simply looks like a bug to me :)
07:26:49 <stephAne> okay, there's no magic between Maybe and ErrorT ?
07:26:55 <merijn> stephAne: Nope
07:27:11 <the_2nd> Boomerang, I mean f xs foobar =      where f' (Bar b) =   f' (Foo x) = .... 
07:27:22 <stephAne> cool :-)
07:27:25 <merijn> stephAne: Are you familiar with the State monad?
07:27:40 <Boomerang> Oh yeah sure :)
07:27:52 <stephAne> I played with 3 or 4 times, but always back to the start when dealing with StateT
07:28:40 <merijn> stephAne: Right, my usual advice for understanding transformers is: Implement State from scratch, then generalise it to StateT by hand: https://gist.github.com/merijn/098106abd45c940dab09
07:28:57 <stephAne> going to dive in this right now, thanx
07:30:52 <shapr> This is a fun read: http://teh.id.au/posts/2017/03/29/these-align-crosswalk/index.html
07:30:52 <the_2nd> Boomerang, http://lpaste.net/354099
07:31:02 <the_2nd> Boomerang, this way I dont have to pass nps to all helpers
07:36:41 <lpaste_> Boomerang annotated “No title” with “the_2nd” at http://lpaste.net/354099#a354100
07:37:07 <Boomerang> the_2nd: Your version is completely fine :) Here's another way
07:38:16 <lpaste_> Boomerang revised “the_2nd”: “the_2nd” at http://lpaste.net/354100
07:44:03 <naldoco> @help
07:44:04 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:44:16 <naldoco> @help list
07:44:16 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
07:44:33 <naldoco> @list
07:44:33 <lambdabot> What module?  Try @listmodules for some ideas.
07:47:05 <Booba_> ertes: Sorry for still not letting you go, but I have another question about Hangman game. I was trying to extend the game and add an attempt counter and I have a feeling that this breaks the monoidal nature of the proposed solution.
07:49:38 <Booba_> ertes: I was thinking about adding the counter to games state as a tuple: Guess ([Maybe a], Int) (a -> Hangman a b) and so on
07:50:29 <Booba_> ertes: but this doesn't make sense to have a counter for individual singleton game. The counter belongs semantically to the "whole" game
07:51:47 <Welkin> Boomerang: create your own data type
07:52:11 <Boomerang> Welkin, Booba_ maybe? :)
07:52:28 <Welkin> Boomerang: yes, sorry
07:53:09 <Welkin> data GameState = GameState { attempts :: Int, state :: <whatever> }
07:54:10 <Welkin> data GameState = GameState { attempts :: Int, board :: [String], guesses :: [String] }
07:54:13 <Welkin> or something similar
07:55:31 <Booba_> Welkin: I'm trying to learn to design solutions in haskell mindset, so to speak. And ertes proposed his http://community.haskell.org/~ertes/hangman/ as an example of hpw one might design using algebraic approaches
07:56:52 <Booba_> While I can understand the solution to original problem, I was thinking about how do I reuse this in my attempts to add a feature to the game: add a possibility to lose after a number of failed attempts
07:56:57 <ph88> i start to read this tutorial https://www.spock.li/tutorial/ it says  The conn type parameter describes what are database connection looks like (() for no database)   i would like to work with 2 databases, is that possible ?
07:57:58 <brynedwards> ph88: Not with the database helper
07:58:11 <ph88> :/
07:58:21 <Booba_> and while designing the game state as a superposition of singleton games looks nice, I can't see it being flexible enough to easily add an attempt limit feature. Am I missing something?
07:58:34 <ph88> brynedwards, what should i do? try another framework ?
07:58:48 <brynedwards> You could store two or more connection pools in the AppState
07:58:58 <ertes> Booba_: the current type does not easily expose whether the last guess was a miss or not…  that's the missing piece
07:59:22 <ertes> Booba_: Guess [Maybe b] (a -> Maybe (Hangman a b))  -- only return a new game, if the guess was a hit
08:00:34 <brynedwards> I think that's what Spock does for the database helper, but it only stores one connection pool
08:00:53 <Booba_> ertes: so I modify singleton function to represent this, right?
08:01:09 <ertes> Booba_: and mappend and hangmanStdio
08:01:42 <ertes> Booba_: then the hit/miss counter is an extension:  data GuessLimit a b = LGuess Integer (Hangman a b) | Lost (Hangman a b)
08:01:49 <Booba_> ertes: naturally, yes. And what about attempt count? Isn't it a part of games state now?
08:02:17 <ertes> Booba_: no, it doesn't change the game logic, it only extends it
08:03:04 <ertes> Booba_: there is one caveat: when you lose the game, the phrase will not be exposed
08:03:17 <ertes> if you want that, then you need to change Hangman itself to count
08:03:57 <ertes> you can preserve the monoidal structure though
08:04:51 <Booba_> ertes: lets focus on one thiing at a time. If I do not expose the phrase if I lose, I don't have to mess with the Hangman type, correct?
08:05:03 <ertes> correct
08:05:49 <Booba_> ertes: I still can't see where the GuessLimit should reside? In what function? In hangmanStdio?
08:07:25 <Booba_> ertes: oh, or GuessLimit is the new extended game?
08:10:06 <ertes> yes
08:10:12 <Booba_> ertes: if it is so, it has its own stdio
08:10:25 <Booba_> ertes: that reuses hangmanStdio
08:10:27 <ertes> of course, because it's a different game
08:10:38 <ertes> it probably can't reuse hangmanStdio either
08:10:48 <ertes> because that one is a closed loop
08:10:58 <Booba_> ertes: oh, I see what extention via composition means now!
08:11:23 <ertes> but you can factor out parts of hangmanStdio and reuse those
08:11:35 <Booba_> ertes: like, limited hangman is a function of whatever hangman game you might want
08:12:39 <Booba_> ertes: thank you for your patience and insights, AGAIN!
08:14:54 <Booba_> ertes: theoretically, I can push it further, like, introduce a Game typeclass that has a move function. And have a LimitedGame typeclass that decrements a counter once a move has been called!
08:15:15 <ph88> i'm just wondering when i use functions like this  https://hackage.haskell.org/package/req-0.2.0/docs/Network-HTTP-Req.html#v:req  haskell doesn't force me to check the response, shouldn't it ?
08:15:55 <Geekingfrog> why would you be forced to check the response ?
08:16:34 <Cale> Booba_: You shouldn't need a type class, you just need a constructor which represents the games which have already been lost.
08:17:08 <Cale> Booba_: Well, and you may wish to let the player know how many moves are left in the Scenario
08:17:13 <Cale> (but that is separate)
08:18:47 <ph88> Geekingfrog, cuz it can be 200 OK, or 500 ERROR, which is significant
08:18:54 <Cale> Booba_: You can define a function  limit :: Int -> Hangman -> Hangman  which will cause the player to lose in any case where they haven't won after a given number of moves.
08:19:40 <Cale> (Or you could count the number of times that the scenario didn't improve)
08:19:52 <Geekingfrog> ph88: iirc this lib will throw an exception if the status code is >= 400
08:20:11 <ph88> oh
08:22:00 <Booba_> Cale: the idea of designing a new game as a function over the old one makes more sense to it. I see I could add features this way: every new feature makes a new game out of oexisting one.
08:22:15 <okra_> are there any clever ways of creating an N x N matrix of the numbers [1..N^2] using List's applicative or monad properties?
08:22:52 <Booba_> and in some time I imagine I return to this and, probably, refactor it to be a single game, if I see that this is better (more readable, easier to compose)
08:23:13 <dolio> How would Haskell force you to check the response if the library isn't designed that way, anyway?
08:29:30 <Geekingfrog> dolio: if the library isn't designed this way you'll have to make a wrapper more to your liking.
08:31:20 <Geekingfrog> btw ph88 I just double checked and yes, you'll get an exception if the status code is not 2xx (didn't try too many redirect though)
08:32:02 <ph88> alright ^^
08:32:58 <lyxia> okra_: [[k * n + i | i <- [1 .. n]] | k <- [0 .. n-1]] is this clever
08:35:07 <okra_> lyxia: if that's what a real haskeller would do then i'm satisfied :)
08:36:36 <okra_> relatedly, https://en.wikibooks.org/wiki/Haskell/Traversable gives an instance of Traversable for [] as `sequenceA [] = pure []', but in ghci `sequenceA []' gives [], where `pure [] :: [[a]]' gives `[[]]'
08:36:47 <Ferdirand> i think there is the idiomatic: group n = map (take n) . takeWhile (not.null) . iterate (drop n)
08:36:59 <Ferdirand> then you can have group n [1..n*n]
08:38:18 <okra_> yeah, I considered that too
08:38:38 <Geekingfrog> Data.List.Split.chunksOf 4 [1..n*n] if you don't mind reaching for libraries outside the prelude
08:38:47 <Geekingfrog> s/4/k
08:40:01 <lyxia> > sequenceA [] :: [[()]]
08:40:03 <lambdabot>  [[]]
08:40:29 <lyxia> okra_: in ghci it's defaulting to sequenceA [] :: IO [a]
08:41:28 <okra_> lyxia: got it, thanks!
09:46:59 <rejagr> are there any good tutorials on working with Trees in haskell? For example how to traverse them or which operations are supported on them
09:48:24 <rejagr> or the mathematical concepts you should know to understand them
09:49:25 <bollu> cocreature: ping
09:49:36 <cocreature> bollu: pong
09:49:38 <bollu> cocreature: The fields of Function in llvm-hs-general are not visible externally
09:49:39 <bollu> https://hackage.haskell.org/package/llvm-hs-pure-4.0.0.0/docs/LLVM-AST.html#t:Global
09:49:44 <bollu> that's weird
09:49:48 <bollu> am I misusing the API?
09:50:06 <cocreature> bollu: I don’t understand the question. what is not visible?
09:50:27 <bollu> cocreature: I'm not able to construct Function by referring to it's fields as a record
09:50:45 <cocreature> bollu: have you tried doing that? I think haddock is just being stupid here
09:50:55 <bollu> cocreature: yep, I did. It tells me the fields are not visible
09:51:18 <sm> rejagr: there's https://en.wikibooks.org/wiki/Haskell/Other_data_structures#Trees
09:51:21 <cocreature> bollu: which module did you import?
09:51:41 <rejagr> thanks
09:51:51 <cocreature> bollu: LLVM.AST.Global doesn’t even have an explicit export list so it can’t really hide the fields
09:51:55 <lpaste_> bollu pasted “freejit.hjs” at http://lpaste.net/354106
09:52:06 <bollu> cocreature: http://lpaste.net/354106#line83
09:52:21 <cocreature> bollu: import LLVM.AST.Global
09:52:34 <cocreature> you might need to import it qualified. there are some name collisions
09:52:38 <bollu> ah, I see
09:53:00 <cocreature> but it’s weird that haddock doesn’t show the record names
09:53:22 <cocreature> bollu: also you might want to use OrcJIT instead of the old one
09:54:18 <bollu> cocreature: will do :)
09:56:40 <Sornaensis> is pointfree coding in haskell helpful for generation more efficient machine code
09:56:48 <Sornaensis> or is it just for rep and glory
09:56:58 <lpaste_> bollu revised “freejit.hjs”: “freejit.hjs” at http://lpaste.net/354106
09:57:06 <glguy> Sornaensis: neither
09:57:15 <bollu> cocreature: still doesn't work
09:57:47 <bollu> cocreature: could you check the lpaste out for me?
10:00:47 <Sornaensis> glguy: pretty sure people brag about writing all their code in pointfree style
10:01:03 <glguy> It's a phase
10:01:05 <Sornaensis> just curious if it was helpful for optimization
10:02:09 <glguy> No, the compiler still adds all the variables back in
10:02:55 <augur> after doing stack build, how does one run the resulting executable?
10:06:20 <sm> stack exec -- EXE ...
10:06:57 <bollu> cocreature: it's giving me errors in terms of "14th argument" etc.
10:07:50 <lpaste_> bollu pasted “weird-errors-llvm-hs” at http://lpaste.net/354110
10:08:36 <bollu> @tell cocreature "I'm leaving now, but check out the lpaste link: http://lpaste.net/354110. Why is it not exposing the record fields? weird"
10:08:37 <lambdabot> Consider it noted.
10:17:31 <geekosaur> bollu, I don't think the error in that paste has anything to do with exposed record fields?
10:18:02 <ExpHP> :t Data.Map.Strict.lookupMin
10:18:03 <lambdabot> error:
10:18:04 <lambdabot>     Not in scope: ‘Data.Map.Strict.lookupMin’
10:18:04 <lambdabot>     No module named ‘Data.Map.Strict’ is imported.
10:18:18 <ExpHP> @index lookupMin
10:18:18 <lambdabot> bzzt
10:18:23 <geekosaur> the errors say (a) you are missing two arguments to the constructor (b) some String-s got changed to something more typesafe
10:18:27 <ExpHP> I swear this function exists
10:18:47 <ExpHP> but intero claims it doesnt >_>
10:19:24 <ExpHP> with 99% probability I am doing something very stupid...
10:20:24 <geekosaur> I don't see lookupMin. did you mean findMin?
10:21:02 <ExpHP> https://hackage.haskell.org/package/containers-0.5.10.1/docs/Data-Map-Strict.html#v:lookupMin
10:21:07 <geekosaur> also, do make sure that you are looking for documentation for the same version of containers that you are using, since things do sometimes change
10:21:24 <cocreature> looks like this was added in 0.5.9.1
10:21:25 <ExpHP> ohgeez
10:21:37 <ExpHP> okay so according to stack I'm using containers 0.5.7
10:21:46 <geekosaur> I just checkedc containers-0.5.7.1 which is what comes with ghc 8.0.2
10:22:23 <cocreature> ExpHP: you should be able to add a newer version to extra-deps
10:22:26 <ExpHP> wtf how is this function on the bleeding edge
10:22:50 <cocreature> probably because nobody added it before :)
10:23:23 <ExpHP> I guess it's like the minimumOnKey that will be added to Data.List in 2025
10:23:41 <cocreature> what is minimumOnKey supposed to do?
10:23:53 <cocreature> that sounds like minimumBy which already exists
10:23:57 <geekosaur> ExpHP, containers was maintenance-only for some rears but recently development restarted
10:24:04 <geekosaur> *years
10:24:08 <ExpHP> cocreature: (Ord b) => (a -> b) -> [a] -> a
10:24:39 <ExpHP> i.e. 90% of use cases of minimumBy, other than to implement maximumBy
10:25:04 <cocreature> ah yeah I’ve wanted this in the past
10:25:53 <ExpHP> I mean okay I guess there's (comparing `on` f) but iirc you need two imports for that
10:25:57 <ExpHP> and a third for Data.list
10:26:08 <ExpHP> that's whack
10:26:09 <shapr> oh neat, I really wanted this last month: https://hackage.haskell.org/package/ghc-prof-flamegraph
10:26:32 <shapr> but I thought it didn't exist...
10:29:24 <ExpHP> (erm ok actually you don't need `on` for that; I'm just spouting nonsense from a dodgy memory)
10:34:42 <infandum`> Is there an easy way to have Map.insertWith but have a default function when the key is not already in the map? So a Map.insertWithWith?
10:35:31 <infandum`> insertWith f g k v, where f is f newValue oldValue and g is g newValue
10:37:33 <infandum`> Nevermind, I see it required (a -> a -> a) anyway
10:38:48 <sophiag> i'm a bit confused about how constraints work with existential quantification. something like "data OpT = forall a. (Num a, Fractional a) => NumOp (a -> a -> a)" works fine (in fact it seems almost as if i don't even need the constaints?) whereas "data OpT = forall a. (Eq a) => EqOp (a -> a -> Bool)" throws an error "Ambiguous type variable ‘a0’ arising from a use of ‘EqOp’ prevents the constraint ‘(Eq a0)’ from being solved." can
10:38:49 <sophiag> anyone explain how this works? i've tried reading a bit on the wiki, but am still confused by the conflicting cases
10:39:41 <geekosaur> first off, the constraints tell you what you can do with the existential. once it's hidden behind a forall, the constraints are all that anything can know about it
10:40:10 <geekosaur> in particular, you can't find out that a is, say, Integer (unless you have Typeable as one of the constraints)
10:40:39 <sophiag> i understand that part
10:41:30 <sophiag> are you saying that explains why it can't resolve Eq? because ghc doesn't know the type of a as it's hidden inside the forall?
10:41:34 <geekosaur> not fully, it seems, because you're expecting that a to unify with another a somewhere else
10:41:35 <geekosaur> and it won't
10:41:44 <geekosaur> which is why it hauls in an a0
10:42:02 <geekosaur> exactly
10:42:17 <sophiag> how come Num and Fractional get past the type checker then?
10:43:08 <gibran> Hello, anyone knows of a Firebird SQL connectivity library like Sqlite-simple and PostgreSQL-simple?
10:43:15 <geekosaur> the constraints inside the forall mean, in effect, "include a record of functions that know how to access the hidden value via Num and Fractional". which adds those to the things it knows how to do
10:43:20 <geekosaur> but knowing Num a does not mean knowing a
10:43:39 <geekosaur> it means precisely that you can use methods of Num on the unknowable a
10:43:58 <sophiag> right...which is what i expected to occur with Eq as well
10:44:24 <geekosaur> no, you did something when using OpT that needed to know more than Eq a, it needed to know a
10:44:33 <cocreature> sophiag: could you show the code fragment that actually causes the error? simply defining this type works just fine for me
10:44:35 <geekosaur> it doesn't and can't know a, so it called the type a0 instead
10:45:17 <sophiag> hmm. perhaps it's the signature itself? a -> a -> Bool vs. a -> a -> a ?
10:45:22 <geekosaur> to indicate that the a can never unify with another type, because a can never be known
10:45:56 <cocreature> sophiag: it’s not about the type definition. it’s about how you use it
10:46:17 <sophiag> i'm using it in exactly the same way
10:46:26 <geekosaur> existentials are often considered an antipattern precisely because of this confusion
10:46:30 <cocreature> could you show us the code you’re using?
10:46:37 <sophiag> the only difference is in operators i'm matching
10:46:51 <sophiag> cocreature: yup i'll paste it now
10:49:16 <sophiag> cocreature and geekosaur: http://lpaste.net/354112
10:49:50 <cocreature> sophiag: which line is line 121 supposed to be in that example?
10:50:07 <sophiag> line 32 in the paste
10:55:20 <cocreature> sophiag: ah the reason why this works for Num is that GHC defaults Num instances to Integer
10:55:28 <cocreature> sophiag: it doesn’t default Eq instances
10:56:00 <sophiag> ah ok. that makes sense
10:56:12 <sophiag> and that's fine for my use case
10:56:27 <cocreature> sophiag: if you compile with -Wall you’ll get a warning even if you disable the EqOp stuff
10:58:20 <sophiag> is there a way to make ghc trust me to only use arguments of the same type with EqOp? possible with RankNTypes?
10:58:58 <erisco> is it possible to have arrays of arrays in SBV?
11:04:17 <erisco> the types don't work, but maybe there is another approach
11:04:23 <erisco> I am sunk if I can't make it work
11:07:39 <erisco> based on comments here an approach is to concatenate bit vectors http://stackoverflow.com/questions/13443259/support-for-multi-dimensional-arrays-in-qf-aufbv
11:07:46 <erisco> makes sense but is a tad painful
11:20:28 <infandum`> What is this function: (a, m b) -> m (a, b)
11:20:50 <johnw> infandum`: strength, I believe
11:21:10 <johnw> https://hackage.haskell.org/package/category-extras-0.53.5/docs/Control-Functor-Strong.html
11:21:19 <cocreature> infandum`: sequence
11:21:35 <cocreature> :t sequence :: Monad m => (a, m b) -> m (a, b)
11:21:37 <lambdabot> Monad m => (a, m b) -> m (a, b)
11:21:37 <johnw> and that too :)
11:21:42 <infandum`> great, thanks
11:21:55 <infandum`> oh, sequence works for that too? wow
11:22:02 <shapr> infandum`: do you have hoogle installed?
11:22:03 <infandum`> I thought it would be (m a, m b)
11:22:11 <cocreature> infandum`: that won’t work with sequence :)
11:22:14 <infandum`> shapr: It didn't return that
11:22:16 <johnw> it's sequence for (,) a
11:22:31 <infandum`> cocreature: Yeah I tried that first and noticed it only did the snd
11:22:41 <infandum`> so I assumed it wouldn't work overall for tuple
11:22:44 <shapr> infandum`: yeah I just tried hoogle and I see what you mean.
11:23:36 <infandum`> :t sequence
11:23:38 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
11:23:47 <infandum`> ok yeah, I see why it's fine
11:24:20 <infandum`> But what about (m a, b) -> m (a, b)
11:25:27 <cocreature> :t fmap swap . sequence . swap
11:25:29 <lambdabot> Monad f => (f b, a) -> f (b, a)
11:25:39 <infandum`> coy
11:25:56 <infandum`> What prelude is lambdabot using?
11:26:08 <infandum`> Data.Tuple normally isn't imported
11:26:28 <Sornaensis> he's using mueval 
11:26:36 <Sornaensis> with a bunch of imports
11:26:48 <Sornaensis> > L.nub [1,1,2,2,3,4,5]
11:26:50 <lambdabot>  error:
11:26:51 <lambdabot>      Not in scope: ‘L.nub’
11:26:51 <lambdabot>      No module named ‘L’ is imported.
11:26:52 <Sornaensis> > nub [1,1,2,2,3,4,5]
11:26:54 <lambdabot>  [1,2,3,4,5]
11:27:44 <geekosaur> @where L.hs
11:27:44 <lambdabot> what lambdabot has in scope is at http://silicon.int-e.eu/lambdabot/State/Pristine.hs
11:32:18 <tobiasBora> I try again, nobody knows a way to use something like parallel-io but with lazy string?
11:35:19 <tobiasBora> lazy list*
11:44:38 <MitchellSalad> is each version of GHC pinned to specific versions of all the boot packages?
11:51:15 <geekosaur> even more specifically to the packages that came with it, because compilation leaks internals into the interface file and then they can be inlined elsewhere
11:51:25 <geekosaur> (this is, I think, finally fixed in the upcoming 8.2.1)
11:51:59 <geekosaur> generated internal symbols, that is
11:55:41 <MitchellSalad> are you replying to me, geekosaur?
11:55:47 <geekosaur> yes
11:55:50 <MitchellSalad> ah
11:56:06 <MitchellSalad> I'm a little confused about something, then, maybe you can explain it...
11:56:40 <MitchellSalad> using stack, peeking at the global package database associated w/ ghc 8.0.2, i see it pinned to process-1.3.0.0
11:57:07 <MitchellSalad> sorry, directory-1.3.0.0
11:57:33 <MitchellSalad> however, when trying to build hackage-server with cabal, I was warned about a destructive reinstall, because it depends on directory < 1.3
11:57:49 <MitchellSalad> althoug its cabal file claims it was tested on ghc 8.0.2
11:58:27 <MitchellSalad> so, I'm confused how the "directory < 1.3" constraint made its way into hackage-server's cabal file, if indeed ghc-8.0.2 implies directory-1.3.0.0
11:59:45 <geekosaur> you can use different versions of boot libraries as long as you don't depend on anything that comes with ghc and is linked to that version. so, for example, containers comes with ghc but you can substitute a different version as long as you're not using ghc-api or template haskell, both of which require the same containers library ghc was built against
12:00:21 <geekosaur> directory is likely even looser in that regard; I suspect it only matters for ghc-api
12:01:22 <geekosaur> but "destructive reinstall" implies cabal wants to rebuild other dependencies that use the different version. here you want either a cabal sandbox or cabal new-build
12:01:39 <geekosaur> rather than letting it rebuild half of your user package database and break the other half
12:02:10 <MitchellSalad> oh, that makes sense... but I *was* using a cabal sandbox
12:02:58 <geekosaur> hm.
12:03:56 <MitchellSalad> my setup might be messing something up. I don't have any global GHC installed, so I'm simply prefacing everything with PATH=<path-to-ghc-8.0.2>:$PATH
12:04:37 <geekosaur> maybe it thinks it has to install an overriding version of a global package and then needs to reinstall other global packages (locally to the sandbox) with tht version, and it's being a bit overcautious because it doesn;t consider things in the sandbox can't break stuff outside that sandbox
12:04:59 <geekosaur> but then this is part of why new-build exists (suggest you use a very recent cabal in that case)
12:05:28 <geekosaur> dependencies are hard, especially when ghc cross-module inlining (and internal symbol leakage) gets involved :/
12:05:34 <MitchellSalad> here's the exact error: lpaste.net/6154004758626566144
12:05:43 <MitchellSalad> that's after a cabal sandbox init
12:07:02 * geekosaur wonders if one of those depends on ghc-api
12:07:15 <geekosaur> because that would lead to this message and be a problem in general
12:07:37 <MitchellSalad> edited to show the output of "ghc-pkg list" as well
12:07:44 <MitchellSalad> ah, gotcha... hrm
12:08:24 <MitchellSalad> well I'm annoyed =D
12:08:37 <MitchellSalad> so much for setting up a private hackage in an afternoon
12:09:03 <geekosaur> sigh, the rev deps list excludes the ghc package so I can't check that way :/
12:09:17 <MitchellSalad> well, one fix is to just bump the bound on directory and fix any incompatibility bugs
12:09:22 <geekosaur> you probably want to ask in #hackage, I have a vague recollection this is a known issue
12:09:32 <MitchellSalad> ok
12:10:06 <geekosaur> and yes --allow-newer=directory might well be the quick workaround
12:12:47 <MitchellSalad> cool, thanks!
12:17:27 <MitchellSalad> are alex/happy versions also tied to GHC?
12:18:19 <MitchellSalad> hackage-server depends on alex < 3.2, yet the version of alex stack has installed alongside ghc 8.0.1 is 3.2.1
12:19:36 <itachi> Hi I wanted to convert a list of int [1, 2, 3] to Data.Semigroup data type [Max 1, Max 2, Max 3] How do I do that?
12:20:22 <MitchellSalad> itachi: map Max
12:20:36 <MitchellSalad> or coerce!
12:21:57 <itachi> Thanks MitchellSalad
12:23:15 <shapr> Has anyone installed TidalCycles here?
12:23:38 <shapr> I guess I should ask how to install supercollider plugins on that IRC channel
12:24:29 <itachi> I am trying to find max in a list of ints using foldMap
12:24:49 <itachi> foldMap <> $  map Max [1,2,3]
12:24:56 <itachi> I tried foldMap <> $  map Max [1,2,3]
12:25:18 <MitchellSalad> itachi: \ints -> getMax (foldMap Max ints)
12:27:38 <itachi> so if list of ints is [1,3,4,2] I should use getMax (foldMap Max [1,3,4,2]) ?
12:31:43 <sdrodge> getMax . foldMap Max $ [1,3,4,2]
12:31:47 <sdrodge> would be just as good
12:31:49 <sdrodge> but yes
12:33:52 <johnw> orion: ping
12:34:15 <sdrodge> itachi: In case you don't know, there's a function in Prelude called maximum.
12:35:11 <sdrodge> It does roughly the same thing, with the exception that it explodes on empty list instead of returning minBound
12:35:12 <itachi> sdrodge I know that. I was solving some questions :)
12:35:44 <sdrodge> Makes sense.
12:37:14 <itachi> any Idea on how to solve the problem?
12:37:23 <sdrodge> Which problem?
12:37:55 <itachi> oh did not see your earlier reply sorry
12:40:23 <itachi> getMax . foldMap Max $ [1,3,4,2] gives me http://lpaste.net/354115
12:40:59 <sdrodge> The type inference needs a little help
12:41:02 <sdrodge> just append :: Int
12:41:19 <sdrodge> getMax . foldMap Max $ [1,3,4,2] :: Int
12:42:04 <itachi> It worked thank you very much sdrodge and MitchellSalad
12:44:47 <itachi> so here what does " foldMap Max $ [1,2,3,4]  "do ?
12:46:38 <sdrodge> Well, for the record the composition happens "first"
12:46:54 <sdrodge> Like, we're talking getMax composed with foldMap Max and applying it to that list.
12:47:02 <sdrodge> (that's what the dot operator does)
12:47:08 <sdrodge> (function composition)
12:48:05 <mizu_no_oto_work> itachi: are you confused about `.` and `$` ?
12:48:20 <mizu_no_oto_work> Or about foldMap, Max, and getMax?
12:48:26 <itachi> Ya a little bit 
12:48:56 <sdrodge> Which one?
12:48:58 <sdrodge> Or both?
12:49:09 <mizu_no_oto_work> > ala Max foldMap [1,2,3,4]
12:49:11 <itachi> I am trying to find out how getMax . foldMap Max $ worked
12:49:11 <lambdabot>  error:
12:49:12 <lambdabot>      • Data constructor not in scope: Max :: Unwrapped s -> s
12:49:12 <lambdabot>      • Perhaps you meant variable ‘max’ (imported from Data.Ord)
12:50:01 <mizu_no_oto_work> itachi: do you understand '$' and '.'?
12:50:03 <sdrodge> itachi: do you understand how getMax (foldMap Max [1,3,4,2]) works, or would you have the same question with that formulation?
12:50:41 <itachi> I will have the same question with that too :(
12:51:14 <itachi> I have just started reading on monoids
12:51:39 <sdrodge> okay, why don't you describe in your own words what a monoid is, so we can get a better idea of what you're struggling with?
12:53:36 <Limona> hi, can someone just quickly explain something
12:53:51 <ExpHP_> :t something
12:53:53 <Limona> if i have type => t a -> a
12:53:53 <lambdabot> error: Variable not in scope: something
12:54:08 <Limona> how come t a can be treated as [a]
12:54:15 <sdrodge> uh
12:54:15 <Limona> what's the difference between t a and [a]
12:54:19 <itachi> From what I understand monoids is typeclass which follows a set of rules
12:54:35 <sdrodge> Limona: Are you sure there wasn't a class constraint on t where you saw this come up?
12:54:41 <ExpHP_> Limona: Is it (Foldable t)=> t a -> a?
12:55:23 <ExpHP_> Limona: "(Foldable t)=>" generally means t is a type that can be turned into a list
12:55:50 <Limona> oh yeah it was foldable
12:56:00 <mizu_no_oto_work> Limona: "Foo t => t a" means that this works for any type 't' that implements the Foo typeclass
12:56:02 <Limona> so what does t a mean then
12:56:18 <Limona> i understand the Foo t => t
12:56:19 <Limona> part
12:56:25 <Limona> but what does t a -> a mean
12:56:35 <ExpHP_> Limona: Here's a hint:  the type "[a]" can also be written as "[] a"
12:56:47 <Limona> ahh
12:56:51 <sdrodge> Limona: It means that t is a type constructor which yields a concrete type when passes another type as a variable.
12:56:54 <sdrodge> e.g.
12:56:57 <sdrodge> Maybe Int
12:57:11 <sdrodge> or as ExpHP_ points out [Int]
12:57:41 <mizu_no_oto_work> Limona: also,  'r -> a' can be rewritten as '(->) r a'
12:58:45 <sdrodge> Limona: Foldable basically means that the values in the structure can be combined into one value.
12:59:03 <mizu_no_oto_work> and (a, b) can be rewritten as '(,) a b'
12:59:09 <sdrodge> lists have a Foldable instance, but so do most other containers.
12:59:35 <mizu_no_oto_work> Which is important when reading typeclass instances for  [], (->) or (,)
12:59:49 <ExpHP_> Or (,,,,,,,,)
13:00:25 <sdrodge> itachi: So far so good. What are those rules? Or put another way, what does being a Monoid mean a type can do?
13:00:31 <ExpHP_> instance Functor (無) a b c d where
13:01:32 <Limona> thanks
13:01:48 <itachi> So a monoid type has function mappend mconcat 
13:02:50 <mizu_no_oto_work> itachi: importantly, it also has mempty
13:04:21 <mizu_no_oto_work> itachi: <>, from Data.Semigroup, is a commonly used operator that's identical to mappend
13:04:27 <itachi> Yup that helps it to minBound in place of error like maximum in  getMax . foldMap Max $ [] :: Int ? 
13:04:57 <itachi> I mean defination of mempty help it **
13:05:03 <itachi> *deffinition
13:05:08 <sdrodge> itachi: yep
13:05:29 <mizu_no_oto_work> The important thing about Monoids is that forall a, b and c, (a <> b) <> c == a <> (b <> c), and a <> mempty == a == mempty <> a
13:06:07 <itachi> k
13:06:15 <mizu_no_oto_work> so it's "associative" (you can rewrite the parenthesis) and mempty works as an identity element
13:06:45 <sdrodge> so basically, what foldMap :: (Monoid m, Foldable t) => (a -> m) -> t a -> m does is takes a function that injects values into a monoid, and a container of those values, then it injects them all, and combines all the results using the monoid's binary operation.
13:07:19 <itachi> I lot you there what I get for 
13:07:20 <sdrodge> Hopefully nobody decides to get on my ass for saying that Foldable t implies t is a container.
13:07:37 <itachi> I lost you there what I get from foldMap :: Monoid m => (a -> m) -> Max a -> m is
13:07:51 <sdrodge> itachi: Ah, that's the wrong substitution
13:07:53 <johnw> sdrodge: explain then how t ~ Const a is a container :)
13:07:57 <c_wraith> hopefully, the mappend association is done in a way that's efficient for that specific Traversable 
13:08:01 <sdrodge> johnw: I refuse.
13:08:03 <mizu_no_oto_work> to explain that a bit more, "foldMap Max [1,3,4,2] == Max 1 <> Max 2 <> Max 3 <> Max 4"
13:08:28 <johnw> sdrodge: simpler: t ~ (->) a
13:08:57 <sdrodge> johnw: yes yes, I'm well aware. I think calling it a container when first teaching it helps give intuition, though.
13:09:14 <itachi> so why are we using $ [1,3,4,2] ?
13:09:33 <johnw> not if the person is used to thinking operationally, in terms of memory cells and things on the heap.  Then they lose the computational intuition.  Happened to me.
13:09:38 <sdrodge> itachi: So in this case, t is [] and m is Max Int
13:09:46 <mizu_no_oto_work> Well, "Max 1 <> Max 2 <> Max 3 <> Max 4 <> mempty'
13:10:33 <itachi> @ sdrodge what did you mean by that is a wrong substitution?
13:10:33 <sdrodge> itachi: so substituting that into foldMap we get foldMap :: (Int -> Max Int) -> [Int] -> Max Int
13:10:53 <sdrodge> Does that answer your question?
13:11:27 <mizu_no_oto_work> itachi: as another matter, do you know why we're messing around with the Max constructor?
13:11:53 <itachi> no
13:12:12 <sdrodge> It's to get the correct monoid behavior for what we're trying to do
13:12:12 <mizu_no_oto_work> Part of typeclasses is that there's only one implementation per type, right?
13:12:49 <mizu_no_oto_work> That means that you could only have one unique instance for Monoid Int, for example.
13:12:54 <itachi> @ sdrodge so it should have been foldMap :: Monoid m => (a -> m) -> t a -> m is ?
13:13:10 <itachi> Yup
13:13:12 <mizu_no_oto_work> That's good for some cases, where there's only one sensible implementation
13:13:29 <mizu_no_oto_work> For example, Lists form a monoid under concatenation, and I think that's the only one
13:13:58 <Sh4rPEYE> Hello. Could somebody please explain what does this funcion do? Or, better put, how does it do it? I get only the fmap part, but I'm lost when it comes to Applicative
13:13:58 <itachi> k
13:13:59 <Sh4rPEYE> combinations a b c = (,,) <$> a <*> b <*> c
13:14:15 <mizu_no_oto_work> But Int forms a monoid with + and 0, * and 1, max and minbound, min and maxbound, and probably a few others besides.
13:14:37 <itachi> hmm
13:14:44 <erisco> lol, well I have finally got my problem encoded for SMT but it is insanely slow
13:14:49 <ExpHP_> :t \a b c -> (,,) <$> a <*> b <*> c
13:14:50 <lambdabot> Applicative f => f a2 -> f a1 -> f a -> f (a2, a1, a)
13:14:55 <zv> did i just hear the word smt solver
13:15:00 <erisco> I can't seem to win on this
13:15:10 <ExpHP_> ^ Sh4rPEYE looking at the type might help
13:15:33 <zv> let me guess, you used the z3 api
13:15:40 <erisco> no, SBV
13:15:44 <zv> even worse
13:15:54 <erisco> has nothing to do with the speed
13:15:54 <mizu_no_oto_work> itachi: The standard hack around that restriction is to make 'newtype Foo = Foo TypeIWantMultipleTypeclassInstancesFor', then create 'instance Monoid Foo', then wrap the values in the right newtype constructor
13:16:04 <sdrodge> Sh4rPEYE: I think it would be unhelpful to explain what it does before you read up on Applicatives and understand it more completely.
13:16:05 <erisco> it just takes an eon to solve
13:16:08 <zv> erisco: wheather you encode it into SMTLIB2 or use an API?
13:16:27 <zv> I assure you, it has everything and more to do with speed. 2-3 orders of magnitude difference.
13:16:29 <erisco> SBV does write SMTLIB2 files
13:16:36 <mizu_no_oto_work> itachi: so instead of creating monoid instances for Int, Int isn't a monoid and we have the monoid instances on Sum, Product, Min and Max instead.
13:16:45 <zv> erisco: Datalog, either/or
13:16:48 <erisco> well, that's not the problem I have
13:16:51 <sdrodge> Sh4rPEYE: but the basic idea is that when you're applying a regular function of multiple arguments to multiple applicative-wrapped values, you use <$> followed by some <*>'s.
13:17:06 <zv> ok
13:17:06 <mizu_no_oto_work> So 1 <> 2 doesn't work, but Sum 1 <> Sum 2 works
13:17:27 <itachi> wa makes sense
13:17:31 <itachi> Ya*
13:17:32 <Sh4rPEYE> sdrodge: Actually, it came up when I was reading about them. 
13:17:41 <erisco> it seems when you combine arrays, bit vector concatenation, and universal quantification, times explode
13:18:13 <zv> erisco: what is you exact problem?
13:18:16 <itachi> so the what was the order in which " getMax . foldMap Max $ [1,3,4,1] :: Int " took place?
13:18:20 <sdrodge> Sh4rPEYE: Yeah. It's a nice motivating example, imo. To better understand it, consider the different between using (+1) on one Maybe Int vs using (+) ont two Maybe IntS.
13:18:35 <itachi> first getMap . foldMap ?
13:18:38 <sdrodge> Sh4rPEYE: Try as hard as you might, you can't do it with only Functor.
13:19:01 <zv> erisco:an SMT solver is already NxN boolean literal comparisons, even for addition.
13:19:02 <erisco> zv, would take some time to explain, but it doesn't matter, I'm just moaning about it
13:19:06 <mizu_no_oto_work> itachi: edwardk gave a good talk a couple years ago about why that restriction (of one instance per type) isn't really a bad thing - https://www.reddit.com/r/haskell/comments/2w4ctt/boston_haskell_edward_kmett_type_classes_vs_the/
13:19:06 <itachi> * getMax.foldMap
13:19:08 <zv> There are clever ways to reduce it
13:19:54 <itachi> k I will look at it
13:19:55 <zv> Conflict-driven literal satisfaction brings you down to log(N^2) comparisons.
13:20:02 <mizu_no_oto_work> itachi: g . f $ x == (g . f) x == g (f x)
13:20:28 <mizu_no_oto_work> . is the function composition operator
13:20:37 <zv> and, not to belabor the point here, but if you encode your problem into SMTLIB2 rather than Datalog/Dimacs or API generated SMTLIB
13:20:49 <zv> it can be hundreds of times faster
13:20:59 <mizu_no_oto_work> where (g . f) x == g (f x)
13:21:18 <erisco> hm, and cvc4 doesn't understand it, okay
13:21:19 <itachi> k I am getting it now
13:21:33 <itachi> Thanks guys you realy helped me alot
13:21:36 <zv> erisco: cvc4 absolutely does understand smtlib2
13:21:47 <zv> I wrote the interaction major-mode.
13:22:00 <erisco> as I told you, it already writes in that format
13:22:14 <zv> You misunderstand, it's not about what *format* it's in
13:22:16 <erisco> so I don't understand what difference you're describing
13:22:18 <zv> it's about the *structure* of the format
13:22:45 <erisco> so you're suggesting I can hand write it better?
13:22:48 <zv> yes
13:22:50 <zv> exactly
13:22:59 <erisco> that isn't applicable to my problem
13:23:05 <zv> fair enough
13:23:18 <erisco> automation is the point of it, otherwise I wouldn't have bothered with SBV frankly
13:24:18 <erisco> yes but I may be touching on features outside of the standard, I am not sure, haven't read it
13:24:32 <erisco> or there is just a bug in SBV's CVC4 driver
13:24:37 <Sh4rPEYE> sdrodge: I see I can't... But why? I use the fmap to partially apply (,,), so I get a function 'b -> c -> (a, b, c)
13:24:58 <Sh4rPEYE> sdrodge: Why can't I fmap this function again on b?
13:25:25 <sdrodge> Sh4rPEYE: let's consider (+) restricted to Int for a moment just to make it simpler.
13:25:40 <zv> erisco: the tricky thing is that you could spend years tracking down a SMT performance error, particularly in generated code.
13:25:42 <sdrodge> (+) :: Int -> Int -> Int
13:25:56 <sdrodge> fmap (+) :: f Int -> f (Int -> Int)
13:26:09 <sdrodge> How do we use a f (Int -> Int) in the general case?
13:26:18 <sdrodge> what if f doesn't provide an unwrapper?
13:26:19 <erisco> I think it just sucks how I needed to encode the problem
13:26:43 <erisco> I need an array of arrays which I am emulating with bit vector concatenation to form the indices
13:26:56 <erisco> but my problem is finding those indices
13:27:09 <geppettodivacin> sdrodge: Usually I see it used with Applicative.
13:27:13 <geppettodivacin> :t (<*>)
13:27:14 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:27:15 <erisco> so I am concatenating existentials and also existentials with universals
13:27:34 <sdrodge> geppettodivacin: Yep, that's exactly what I'm explaining/motivating right now :)
13:27:41 <erisco> and I can't imagine that is so friendly, but it could just be the universals alone causing the issue
13:27:46 <erisco> particularly when I ask for all models
13:27:47 <geppettodivacin> Oh, sorry. I jumped in mid-conversation. :P
13:27:57 <zv> erisco: yeah, that will do it
13:28:44 <dmiles> zv: when will what erisco is doing not be asking too much?
13:28:54 <Sh4rPEYE> sdrodge: Thanks. I somehow missed the function after fmaping is in the structure.
13:29:21 <zv> in principle things like DPLL and CDCL are great because you can simply not explore the vast space of possibilties. One half of that is unification/not exploring 'contradictions', the other is that you can simply abandon the search upon first satisfying literals :)
13:29:30 <erisco> the problem is, roughly explained, that I am searching for possible rules to add to a puzzle which reduce the number of solutions
13:29:52 <Sh4rPEYE> Can I thing of ap as just taking a function from the structure and fmaping it over something?
13:30:11 <zv> dmiles: who knows
13:30:49 <erisco> so the problem is "find a rule R which fits solution A but not solution B", and thus I can repeat this process to iteratively reduce the solutions of any solvable puzzle to one
13:30:50 <sdrodge> sh4rpeye: Not quite. But close.
13:30:58 <zv> The average SMT problem is "SAT^2", even for basic arithmetic. SAT *itself* is already hard.
13:31:48 <zv> The average SAT/SMT engine just encodes, say, uint32 arithmetic into 32^32 boolean clauses
13:31:51 <erisco> the solutions are known (this is easy to solve) and so the variables are just in R
13:31:51 <sdrodge> sh4rpeye: Keep in mind that f (a -> b) does not imply exactly one function "inside" f
13:32:15 <sdrodge> Might be zero functions, might be more than one function.
13:32:32 <sdrodge> [(+1), (+2)] <*> [3, 4]
13:32:41 <sdrodge> for example.
13:32:56 <zv> So basically, just like with computer programming languages, there are many, many strength reductions that can make an SMT problem zoom by, but you need to express that in a high-enough level form that the solver can grasp what you are looking for.
13:33:13 <Sh4rPEYE> sdrodge: In that situation it applies every argument to every function on the left. Right?
13:33:36 <sdrodge> sh4rpeye: yep, that's what the list applicative instance does.
13:34:04 <zv> so, as erisco has found, the solver is going on a roundabout path to solving something because there is not enough 'problem information'
13:34:33 <zv> so it could be years before erisco is not 'asking too much'
13:34:47 <erisco> I am not sure if the question I am asking is even avoidably complex
13:35:03 <zv> erisco: Yeah, I agree. It probably isn't
13:35:18 <dmiles> one neat property (if done right) the more data/information given to the solver the faster it will run :)
13:35:22 <Sh4rPEYE> sdrodge: Oh, of course, that's what I meant.
13:35:45 <erisco> I threw it at an SMT solver because it certainly wasn't obvious to me how to make it fast :P
13:35:47 <zv> but unfortunately the way that SMT-api generators work is terrible
13:35:58 <Sh4rPEYE> sdrodge: I'll read more abut it, but now I have a general idea at least. Thank you :-)
13:36:11 <bollu> cocreature: ping :)
13:36:11 <sdrodge> sh4rpeye: No problem!
13:36:42 <erisco> but I might come up with some clever ways to simplify the problem, because I do have wiggle room
13:36:48 <bollu> @tell cocreature "ah, thanks for spotting that. I was in a hurry!"
13:36:48 <lambdabot> Consider it noted.
13:36:49 <zv> but of course there's chicken-n-egg for things like erisco's problem: "Encode the problems 'true' tree/horn-logic/whatever structure <-> Find the structure by solving the problem"
13:38:25 <zv> also, add in the typical "graduate student deathmarch" that most SMT-solver's code is made of, and you've got *loads* of difficult SMT problems
13:38:37 <dmiles> I am developing a Conflict learning system that works for full FOL .. it works to produces conflict producing horn clauses(HC) heads (as well as normally what is derived from HCs) of cource if i tried to ground the Conflists it produce exponeticals so what i do is enure all conflicts can be found by backchaining at a depth of three 
13:39:05 <dmiles> ensure all conflicts can be reached*
13:39:26 <dmiles> the idea is to give a narrower window to what is allowed to be searched
13:40:22 <zv> that is cool
13:41:22 <zv> I tried writing a CDCL solver from scratch awhile ago and didn't get very far. There are a lot of tricky issues that present themselves in the core logic, especially if you aren't an experienced Prolog programmer for example.
13:41:33 <dmiles> if some rule causes crazy chaining that is it produces equal or more consequnets .. that rule is backward chained (otherwise forward chained)
13:42:46 <dmiles> i started out with a guys code who created CDCL in 1983
13:43:32 <dmiles> (Mark Stickels PTTP .. for every p(X,Y).. he produced not_p(_X,_Y).
13:43:37 <dmiles> )
13:43:45 <Sh4rPEYE> sdrodge: Actually, one more question, sorry. Where is the 'monoidal' bit in all of this? I've read Applicatives are Monoidal functors
13:43:56 <zv> yep, thats the strategy :)
13:44:02 <dmiles> not_p/2 is a solver that proves what is a conflict
13:44:16 <benzrf> Sh4rPEYE: it has to do with this function:
13:44:22 <zv> Donald Knuth actually just recently released his most recent fascicle of 'The Art of Computer Programming' and it's on SAT solvers
13:44:36 <benzrf> a ** b = (\a' b' -> (a', b')) <$> a <*> b
13:44:45 <zv> He's got the most comprehensive description of every strategy in SAT solving I know of.
13:44:47 <dmiles> so before searching into p/2 .. you when/2-ify the free vars of it to check not_p/2
13:44:53 <benzrf> Sh4rPEYE: which has the type (**) :: Applicative f => f a -> f b -> f (a, b)
13:45:15 <zv> 2-ify meaning convert to 2SAT?
13:45:20 <benzrf> essentially, this forms something analogous to a monoid if you swap out some parts of the definition of "monoid"
13:45:58 <dmiles> when/2-ify = when bound enough, call not_p  (that can be set up in prlog with when/2)
13:46:12 <Sh4rPEYE> benzrf: It looks like a weird version of tuple append
13:46:22 <benzrf> tuple append?
13:47:06 <dmiles> when/2 is the way a person sets up coroutines (that react  on variables changing states
13:47:11 <AndreasK> Is there a pretty print lib thats polymorphic over the string type?
13:47:21 <monochrom> Wait, Knuth does SAT solvers now?!
13:47:32 <Sh4rPEYE> Pardon my imprecise wording... Rather, well... Actually, tuples cannot be appended to. Sorry.
13:47:47 <zv> monochrom: Volume 4 Fasc. 6
13:47:49 <monochrom> Well I guess it is a computational combinatorics interest too.
13:48:04 <dmiles> which is what some most CSP(?) systems use.. it sets up a lazy "onBind" trigger)
13:48:26 <sdrodge> Sh4rPEYE: I'm not confident enough in my understanding of that aspect of it to explain adequately, sorry.
13:48:41 <Sh4rPEYE> Anyway, it doesn't really merge a and b together, it just makes tuple of them. 
13:49:04 <dmiles> The Art of Computer Programming, Volume 4, Fascicle 6: Satisfiability
13:49:43 <monochrom> I should maybe actually buy this fascicle.
13:50:02 <monochrom> (Normally I am not interested in combinatorics.)
13:50:11 <Sh4rPEYE> I've seen that apply for tuple works like this (<*>) (a, f) (b, c) = (a <> b, f c). Nowhere did I find why it should behave like this.
13:50:31 <Sh4rPEYE> It could shed some light on the 'monoidal' part of it, though.
13:50:55 <dmiles> zf: though i am doing nonmonotonic logic.. but i cheat by using tricks found in many SAT solvers
13:51:11 <monochrom> oh w00t it has Kindle edition too
13:51:49 <AndreasK> Is it a proper kindle version or just a scan?
13:51:54 <sdrodge> Sh4rPEYE: The Applicative instance for Const m also depends on m being monoidal.
13:52:41 <Sh4rPEYE> sdrodge: Yes. It just seems weird to me, though. I guess it'll come with time. I'll stick to the function lifting analogy for now.
13:53:32 <tobiasBora> Hello,
13:54:15 <dmiles> The Art of Computer Programming, Volume 4A: Combinatorial Algorithms, Part 1
13:54:27 <dmiles> to monochrom
13:54:40 <monochrom> Ah, Knuth says don't go for the Kindle edition, there is a better choice on his home page.
13:55:00 <tobiasBora> I tried to create lot's of threads, by using forkIO, but the problem is that the program quit very quickly, so I suppose that the main thread close, and so it closes also the threads in the thread list. How could I wait that all the threads in a given list are stoped?
13:57:11 <geekosaur> tobiasBora, you need to keep track of them somehow. often this is done with a list of MVar-s. or see if the async package has something prepackaged for it
13:57:19 <monochrom> Haha, Knuth plans to teach us parsing again by 2025.
13:57:29 <tobiasBora> geekosaur: Well I've a list
13:57:36 <tobiasBora> I do
13:57:37 <geekosaur> (it's normal that exiting the main thread kills all subthreads, most thread systems work that way)
13:57:38 <tobiasBora> forM [1..nbThreads] $ \_ -> do forkIO $ oneThread sharedData
13:57:58 <geekosaur> yes, but you don't save the ThreadId-s
13:58:14 <geekosaur> so you have no idea what happens after starting them
13:58:16 <tobiasBora> well I could save them
13:58:22 <tobiasBora> listId <- forM [1..nbThreads] $ \_ -> do forkIO $ oneThread sharedData
13:58:39 <tobiasBora> but then what can I do with this list?
13:58:53 <tobiasBora> (actually, I want to wait that all the threads finish just after this list)
13:58:56 <tobiasBora> *this line
13:59:22 <tobiasBora> So I think that I don't even need a mvar, since the number of threads is fix, and in this list
13:59:31 <geekosaur> anyway it's not really enough to do even that, you create an MVar for each thread, pass each thread its MVar, and then each thread does putMVar before exiting and your main thread does tryTakeMVar on all of them until it's succeeded
13:59:55 <tobiasBora> geekosaur: oh like this...
14:00:30 <geekosaur> but there's edge cases where a thread can be killed in various ways and will therefore never putMVar
14:00:56 <tobiasBora> I though there would be some nice function to handle that. And when I've lot's of threads, I do like an infinite loop that always check for the result?
14:01:15 <geekosaur> I pointed you at async for a reason
14:01:20 <geekosaur> @hackage async
14:01:20 <lambdabot> http://hackage.haskell.org/package/async
14:01:35 <geekosaur> the standard ghc thread api is very low level; async provides a higher level abstraction
14:02:01 <geekosaur> and there's some add-on packages to do fancier stuff
14:02:38 <Sornaensis> :t const
14:02:39 <lambdabot> a -> b -> a
14:02:45 <Sornaensis> :t flip const
14:02:46 <lambdabot> b -> c -> c
14:04:37 <geekosaur> oh, sorry, I had thoguht about ,entioning async bu then ended up respinding to somehting else you said instead :/
14:04:50 <geekosaur> anyway you want the async package, it;s a much saner way to deal with threads than messing with the low level API
14:04:53 <tobiasBora> geekosaur: Hum I miss your message where you talked about async, sorry. This one sounds great!
14:05:08 <tobiasBora> ahah ok
14:08:50 <tobiasBora> geekosaur: It's definitely what I need, thank you very much!
14:17:02 <hexagoxel> :t [flip const, const id]
14:17:04 <lambdabot> [b -> c -> c]
14:21:33 <lapinot> hello there
14:22:31 <lapinot> i'm trying to implement Show on a GADT but deriving doesn't work.. does anyone have a hint on how I should tackle this?
14:22:33 <lyxia> hello
14:22:49 <lyxia> I think you can sometimes do this with standalone deriving
14:23:01 <lapinot> i also tried that :(
14:23:51 <lyxia> @lpaste lapinot
14:23:52 <lambdabot> Haskell pastebin: http://lpaste.net/
14:24:16 <lyxia> What's your GADT?
14:24:57 <maerwald> lyxia: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#generalised-algebraic-data-types-gadts
14:27:58 <ExpHP_> hmm, how come transformers doesn't have more type classes like MonadIO for its other transformers?
14:28:23 <ExpHP_> Like, is "MonadState s" not possible or just *not there*?
14:29:07 <lyxia> transformers only exposes the transformers, the type classes are in mtl
14:29:07 <ExpHP_> erp, answered my own question already, there's one in mtl
14:29:30 <ExpHP_> wait
14:29:46 <ExpHP_> MonadState s m | m -> s
14:30:06 <ExpHP_> I don't see why it specifies functional depencies, that means you can only have one instance
14:31:27 <lyxia> If you don't, then you lose a lot of type inference.
14:32:27 <ExpHP_> lyxia: I'd rather newtype all the things than have to stick them all in the same StateT
14:34:09 <lyxia> I don't understand what that solves
14:34:11 <lapinot> lyxia: https://ptpb.pw/T2Zz
14:34:29 <lyxia> lapinot: you have a function in there
14:34:52 <lyxia> There is no Show for function, hence you can't derive Show.
14:35:07 <lapinot> oh that's sad
14:35:22 <ExpHP_> right now if I write any functions for my monad stack which are parameterized over the type class, then they'll break if I add another layer that happens to be another StateT
14:35:56 <ExpHP_> or happens to contain one, for that matter
14:36:12 <lyxia> Okay, so what does newtype bring you here?
14:37:30 <sm> hvr, all: did you find any good ways to avoid running out of memory when doing a big build on travis with nothing cached ?
14:37:32 <ExpHP_> They're just to make inference tractable for generic types
14:37:59 <Koterpillar> sm: build a base docker image
14:38:24 <lapinot> if i can't show a function is it possible to show a type? (i'm relatively new to haskell, coming from strong ocaml background, so this question may sound stupid)
14:38:33 <Koterpillar> sm: https://github.com/koterpillar/tianbar/blob/master/Dockerfile.base
14:38:39 <sm> Koterpillar: aha.. I do not speak docker, but that's interesting
14:38:58 <sm> thanks
14:39:30 <Koterpillar> sm: it's a hack, but it works
14:39:33 <lyxia> lapinot: in your case you can write a function by hand to convert an Expr to a String.
14:40:35 <lapinot> lyxia: mhh wouldn't i need some kind of pattern on functions (which doesn't have any sense)?
14:40:46 <lapinot> s/pattern/pattern matching/
14:41:36 <lyxia> lapinot: What do you mean exactly by "show a type"? For debugging purposes?
14:42:53 <lyxia> lapinot: Since you're doing HOAS you can just apply the functions to fresh variables to get a meaningful result that you can print
14:43:26 <lapinot> yeah, some kind of... this code is part of the interpretation of a small language so i would have liked to implement a REPL providing some kind of output (at least type, some representation of what it does would be awesome)
14:43:55 <lyxia> Ah, I read too fast, you're going to have trouble with values.
14:44:48 <lapinot> i would need to represent the type of an expression (should be doable somehow with another `Type` GADT) and then be able to generate a dummy value for an arbitrary type
14:44:52 <lyxia> But what I said applies to Expr.
14:46:01 <lyxia> lapinot: you might use the Typeable type class for this.
14:46:15 <lyxia> lapinot: I mean, to print the type of an expression/value
14:47:59 <lyxia> lapinot:  import Data.Typeable ;  showTypeOf :: Typeable a => Expr a -> String ;  showTypeOf = show . typeRep
14:51:48 <lapinot> lyxia: cool, i'm gonna try that (Typeable is an awesome feature btw... haskell does definitely have a lot of funny features compared to ocaml)
14:53:38 <lapinot> (the only downside is that haskell folks useWeirdCase instead_of_normal_ones :P)
14:56:17 <lyxia> (it is indeed quite ugly sometimes)
14:56:36 <jle`> camels for life
14:58:38 <kadoban> This_Looks_Pretty_Bad <-- so there's not a ton of choice, IMO. You have to be able to start with capital letters, and This_looks_just_weird as well.
15:00:56 <lapinot> kadoban: types in CamelCase and function in lower_case is just fine for me (i do like python's pep8 a lot actually).. but i'm also very maniac when it comes to following conventions so i'll stick to writing haskell likeThis
15:01:30 <kadoban> lapinot: That would bother me, but ya I guess that'd be the most acceptable other alternative, IMO.
15:01:50 <tobiasBora> I've a question: I'm using stack, and I enabled the library profiling in my cabal/stack project. However, when I disabled it, my program are much slower than before to run, so I wonder if it's possible that stack is still using the profiling version of the library
15:02:37 <jle`> it is possible
15:02:46 <jle`> i usually stack clean if i notice anything fishy
15:04:46 <sm> strange, stack is usually recompilation-happy
15:07:01 <bollu> cocreature: ping
15:07:31 <tobiasBora> jle`: stack clean do not change anything
15:07:35 <bollu> anyone here who has used the LLVM API? I'm using llvm-hs. I was wondering if there a way to "reinterpret" a JITed LLVM value back as a Haskell value
15:08:00 <bollu> @tell cocreate I was wondering if there a way to "reinterpret" a JITed LLVM value back as a Haskell value. If you could point me to the API if it exists, it would help a lot :)
15:08:00 <lambdabot> Consider it noted.
15:09:47 <curious_> hello guys
15:10:03 <curious_> can you help me with some functional js code
15:10:14 <curious_> https://pastebin.com/ZVri3jMP
15:10:21 <davean> his is a Haskell channel, not a JS channel I'm afraid
15:10:41 <curious_> I know but the question is functional about functional programming
15:10:47 <davean> Ok?
15:10:59 <bollu> curious_: #haskell-overflow maybe willing to help
15:11:08 <curious_> ok I'll ask there
15:11:10 <bollu> curious_: what is the question?
15:11:13 <curious_> the
15:11:17 <curious_> the most inner function
15:11:29 <curious_> is supposed to get string and match as parameters
15:11:38 <curious_> but it gets match and offset
15:11:39 <darkSeid_> Hi, does anyone here have a recommended intro to haskell? There's so many different resources so I thought people here might have some solid suggestions :) I've never touched any functional programming before so it would need to start from 0
15:11:58 <jle`> a lot of people recommend haskell from first principles these days ...
15:12:01 <hpc> @where learnhaskell
15:12:01 <lambdabot> https://github.com/bitemyapp/learnhaskell
15:12:01 <jle`> @where haskellbook
15:12:01 <lambdabot> http://haskellbook.com
15:12:02 <darkSeid_> and I have no idea why randomly every 'so; is highlighted
15:12:12 <jle`> darkSeid_: it's because there's a user named 'so' in this channel
15:12:20 <darkSeid_> oh damn, thats unfortunate
15:12:21 <curious_> the documentation for the function states that the callback function can be passed several arguments in which I'm not interested in, I'm interested only in those two
15:12:26 <jle`> and your client probably highlights usernames :)
15:12:29 <hpc> @where lyah -- if you don't need exercises
15:12:29 <lambdabot> http://www.learnyouahaskell.com/
15:12:34 <darkSeid_> aye, textual is awesome
15:12:34 <glguy> bollu, curious_: No, as mentioned, that is offtopic here
15:12:43 <hpc> @where rwh -- has a good second half that covers common libraries
15:12:43 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:12:47 <curious_> ok
15:12:51 <darkSeid_> awesome, ty for the links :)
15:12:59 <bollu> curious_: come over to #haskell-overflow
15:13:06 <jle`> i am a graduate of lyah for what it's worth; it was what taught me originally, but i understand that it's not for everyone
15:13:10 <curious_> going
15:13:46 <glguy> darkSeid_: Graham Hutton's "Programming in Haskell" was updated recently and is worth looking at
15:14:22 <darkSeid_> jle`, when you say first principles, you mean like category theory?
15:14:25 <lapinot> i'm sorry, i'm really beginning with haskell (and starting right with GADTs!) so i'm having trouble with Typeable... deriving Typeable Expr works but Typeable (Expr t) doesn't so i can't use showTypeOf
15:14:34 <jle`> darkSeid_: no, i mean literally the book "Haskell from First Principles"
15:14:39 <darkSeid_> oh haha
15:14:44 <darkSeid_> thank god
15:14:50 <jle`> and learning haskell doesn't involve category theory at all :)
15:14:57 <jle`> in fact, haskell itself has nothing to do with category theory
15:15:12 <jle`> it's just that a lot of haskell programmers are hobby category theorists so we talk about it a lot for some reason
15:15:22 <jle`> so i guess that's how the misconception got spread around
15:15:57 <jle`> but it's just that the haskell fandom and CT fandom have some awkward overlap in members.  like star trek and star wars, maybe.
15:15:59 <lyxia> lapinot: you're not supposed to derive Typeable, it's already derived
15:16:05 <darkSeid_> isn;t functional programming based on category theory at all?
15:16:09 <jle`> not really, heh
15:16:14 <jle`> by not really i mean 'not at all'
15:16:24 <jle`> there is no relationship between functional programming and category theory
15:16:46 <bollu> darkSeid_: on some level, I would recommend coming to IRC and asking stuff
15:16:49 <jle`> at least not in the sense that one can be said to be based on the other
15:16:57 <bollu> darkSeid_: stackoverflow + google + IRC got me this far :)
15:17:01 <darkSeid_> bollu, thats why im here :)
15:17:01 <bollu> darkSeid_: LYAH as well
15:17:03 <lapinot> lyxia: i started with that (suspecting that Typeable would indeed be magic) but then I get a "No instance for (Typeable b0) arising from a use of ‘showTypeOf’"
15:17:06 <jle`> there are some things they have in common, of course.  (1) they are both studied by human beings
15:17:13 <jle`> (2) their names are two words long
15:17:16 <jle`> etc.
15:17:33 <darkSeid_> hmm
15:17:52 <sdrodge> darkSeid_: Category theory turns out to be really useful as a mathematical description of the semantics of programming languages.
15:17:54 <Cale> jle`: Well, there's definitely *some* relationship
15:18:04 <Koterpillar> lapinot: you do need to add deriving (Typeable), compiler will do it for you but only if you specify it so
15:18:07 <jle`> there are shallow relationships
15:18:37 <bollu> jle`: I disagree
15:18:42 <darkSeid_> I'm quite glad that it's not so important to understand category theory, as I attemted some number theory in uni and couldn't do _any_ of it
15:18:43 <bollu> jle`: CCC ~= lambda calculus is not shallow
15:18:46 <Cale> There's the Curry-Howard-Lambek correspondence between lambda calculi, logics, and various sorts of categories
15:18:50 <sdrodge> darkSeid_: Its influence happens to be strongly felt in the design of Haskell libraries, but it's not any more inherent to Haskell than any other language.
15:19:22 <jle`> ok, i'll admit that there are interesting links :)
15:19:29 <sdrodge> You can definitely understand and deal with all the important typeclasses without learning a lick of category theory.
15:19:39 <lapinot> Koterpillar: i get the same error using that
15:19:40 <darkSeid_> so the sterotype of all haskell programmers being maths phd's is...  nonsense?
15:19:46 <bollu> sdrodge: It helps to understand "monad is monoid is endofunctors" though
15:19:52 <bollu> darkSeid_: sample size of 1: am not PhD :P
15:19:56 <jle`> darkSeid_: pretty much nonsense
15:20:00 <Cale> Yeah, the thing is, you can be a totally competent, even an excellent Haskell programmer, without knowing any category theory at all.
15:20:03 <jle`> darkSeid_: haskell's ideal audience is the un-smart
15:20:10 <darkSeid_> oh man
15:20:16 <jle`> haskell is for people who aren't smart enough to program in C++ or java
15:20:16 <darkSeid_> hellooooo haskell
15:20:18 <Cale> But to deny that there's a correspondence there would be a lie :)
15:20:37 <sdrodge> bollu: I agree that you obtain a deeper understanding by knowing the math, but our point is that it's not necessary.
15:21:00 <darkSeid_> I suppose you gain a deeper understanding of every programming language if you understand the math behind it
15:21:00 <lapinot> more generally, functional programing is much more widespread in academics
15:21:01 <jle`> i'm convinced that only geniuses can program effectively in C++, and even then, not even well
15:21:09 <Koterpillar> lapinot: you need to derive Typeable throughout all your types
15:21:10 <sdrodge> darkSeid_: Exactly.
15:21:17 <bollu> sdrodge: beyond a point, when you enter the space of "libraries motivated by category theory ideas" it starts becoming imporant
15:21:23 <Koterpillar> lapinot: show what you have, I must have missed it
15:21:27 <jle`> almost every day some memory exploit or state management error comes out
15:21:34 <Cale> The main reason to learn the category theory is to be able to apply it *not* to Haskell, but to other things -- Haskell and functional programming can be a good motivating jumping off point to getting into all sorts of other mathematics, or other applications of category theory to computer science.
15:21:34 <sdrodge> bollu: Agree to disagree.
15:21:45 <jle`> keeping track of memory and implicit state in C++/Java is extremely difficult
15:21:46 <lyxia> lapinot: your error comes from your usage of showTypeOf
15:21:52 <lapinot> Koterpillar: https://ptpb.pw/g9d2 :)
15:21:59 <lapinot> lyxia: yes
15:22:10 <jle`> in haskell, your programs pretty much write themselves, and you have to keep track of much less in your head
15:22:15 <sdrodge> jle`: Just declare everything const! \s
15:22:22 <darkSeid_> you really are making it sound awesome
15:22:35 <lyxia> lapinot: what version of GHC are you using
15:22:41 <bollu> sdrodge: sure :)
15:22:54 <lapinot> lyxia: 7.8.4
15:23:16 <bollu> > let powerset = filterM (const [True, False]) in powerset [1, 2, 3]
15:23:19 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
15:23:25 <sdrodge> He's overselling a little bit. Learning to think the Haskell way takes a lot of time, and there are other things that are harder to reason about in Haskell programs than programs written in other languages (like space complexity).
15:23:26 <bollu> darkSeid_:  ^ powerset as a one-liner :3
15:23:54 <sdrodge> But yes, it is pretty great, and I find a lot of things more natural and beautiful to express in Haskell.
15:23:56 <bollu> let fibs = 1:2:zipWith (+) fibs (tail fibs) in take 10 fibs
15:24:02 <bollu> > let fibs = 1:2:zipWith (+) fibs (tail fibs) in take 10 fibs
15:24:04 <lambdabot>  [1,2,3,5,8,13,21,34,55,89]
15:24:14 <bollu> darkSeid_: one liner fibonacci sequence in Haskell
15:24:19 <darkSeid_> well, i always found functions easier to use than objects, so that has to be a start
15:24:21 <Cale> sdrodge: On average in practice, I would say Haskell programs are much easier to reason about than things written in other languages, even once you account for the time spent worrying about space complexity though :)
15:24:40 <darkSeid_> bollu, thats awesome =)
15:24:43 <sdrodge> Cale: I would tend to agree.
15:25:13 <jle`> learning haskell is indeed a large up-front investment
15:25:14 <bollu> Cale: now explain tardis monad ;)
15:25:21 <bollu> Cale: (I'm half serious)
15:25:24 <jle`> but the power of haskell is definitely in the long-term
15:25:31 <jle`> i used to dread maintaining and refactoring old projects
15:25:32 <Cale> bollu: You mean the state monad with the state wired up in reverse?
15:25:34 <jle`> but in haskell, it's a joy :)
15:25:35 <bollu> Cale: yeah
15:25:45 <darkSeid_> you think it'll grow significantly in popularity?
15:25:45 <bollu> Cale: bidirectional actually
15:25:47 <jle`> i can refactor without fear ~
15:25:53 <bollu> darkSeid_: haskell's mission was to be unpopular
15:25:53 <Squarism> +1
15:25:55 <bollu> darkSeid_: it failed
15:26:11 <Cale> oh, well, start with just one way
15:26:13 <Sonolin> lol nice one
15:26:14 <jle`> i don't know if haskell will ever grow significantly in popularity, but i know that the concepts that are tried and tested in haskell eventually spill over into other languages
15:26:21 <Cale> If you can do each way, doing both is no harder
15:26:31 <Sonolin> I think its definitely relatively popular compared to other pure functional languages
15:26:45 <darkSeid_> yeah, lots of people are now practising functional JS
15:27:04 <Sonolin> well I haven't seen any *pure functional JS, although I'm sure its out there ;)
15:27:06 <sdrodge> Also some more basic everyday ideas have flowed over.
15:27:13 <jle`> honestly, to me (and i'm sure many others), the benefit of haskell isn't the fact that it's functional, but it's the type system
15:27:19 <sdrodge> Notice how everybody is adding and optional types to their languages these days?
15:27:34 <bollu> Cale: I see, interesting
15:27:37 <sdrodge> std::optional in C++17, and Option<T> in Rust.
15:27:38 <jle`> functional programming is cute but without an expressive type system it can get just as messy
15:27:42 <Sonolin> oh yea definitely, the type system in haskell is my favorite I wish more languages were as expressive
15:27:45 <jle`>  see: any large codebase in lisp or scheme
15:27:59 <Cale> bollu: Are you familiar with how State works ordinarily?
15:28:04 <bollu> Cale: yeah
15:28:11 <jle`> but hsakell's type system is indeed spilling over too
15:28:12 <bollu> Cale: I'd never considered wiring it backwards :P
15:28:15 <Cale> So recall that you perhaps have something like:
15:28:17 <lapinot> jle`: indeed, rust (<3 btw) has a lot of haskell influence (actually i think type-classes are the quintessence of object oriented programming (python style, not smalltalk style))
15:28:18 <jle`> there's swift, scala, flow-js, etc.
15:28:33 <bollu> lapinot: rust <3 high five
15:28:45 <jle`> the most overrated thing about haskell to me is the cute one-liners
15:28:48 <Cale> x >>= f = State (\s -> let (v,s') = runState x s; (w, s'') = runState (f v) s' in (w, s''))
15:28:54 <Cale> bollu: right?
15:29:03 <jle`> they're nice but they can't communicate the real benefits of haskell, in maintainability and safety
15:29:07 <bollu> Cale: yes
15:29:23 <Cale> bollu: Of course, there's nothing stopping us from just wiring the s parameters through in the opposite direction:
15:29:26 <Squarism> the other day i had this significant refactoring - had to generify all messaging (really make specific messages generic up until a certain handler). That was both database-, thread-channels-, remoting- messages. Took me 3 days to do it. Once it compiled, i had just 2 easy to fix / obvious bug.  
15:29:34 <jle`> :D
15:29:48 <darkSeid_> jle`, how does haskell help you in refactoring and maintaining old projects?
15:29:49 <Cale> x >>= f = State (\s -> let (v,s'') = runState x s'; (w, s') = runState (f v) s in (w, s''))
15:30:04 <darkSeid_> i mean, why is it much easier than in other languages
15:30:09 <jle`> darkSeid_: the type system is expressive enough that it can describe behavior as well as just structure
15:30:30 <jle`> so if you want to change behavior, you start with changing the types
15:30:32 <lapinot> Cale: the problem behind one-liners is that haskell devs can't help defining functions as symbols (and thus helping people writing in point free programming)
15:30:35 <jle`> and the compiler makes sure everything is still correct
15:30:42 <sdrodge> darkSeid_: The type system holds your hand the entire way, and it also demands a certain level of decoupling from the get-go so it's harder to write an unmaintainable mess in the first place.
15:30:49 <Cale> lapinot: hm?
15:30:53 <jle`> and, if you want to change something while keeping the behavior invariant, you can make changes to code and be confident that the behavior won't change, and there aren't any regressions
15:31:03 <lyxia> lapinot: okay it seems that Typeable is automatically derived for all types only since 8.0.1
15:31:12 <jle`> because the compiler ensures that the behavior matches the expectations that the types set out
15:31:27 <sdrodge> lapinot: There's nothing inherently evil about point-free.
15:31:34 <jle`> refactoring/maintaining in other languages requires you to keep the entire 'system' in your mind
15:31:47 <jle`> and knowledge of all of the intricate parts and state of all the objects and how they all fit together fragilly
15:31:50 <lyxia> lapinot: I don't see any error here though. You didn't show the part where you're using showTypeOf
15:32:07 <Cale> lapinot: Infix operators often work a bit against points-free programming actually
15:32:14 <jle`> in haskell, you often don't even have to understand the program's implementation as long as you understand the types
15:32:16 <bollu> Cale: fuck, i'd never considered that
15:32:19 <bollu> Cale: that is awesome :O
15:32:21 <darkSeid_> btw this channel is already > 99% of irc
15:32:43 <bollu> darkSeid_: naw, ##math sees heavy traffic too
15:32:52 <jle`> the compiler basically keeps track of the program's architecture for you so that you don't have to worry about breaking anything
15:32:54 <darkSeid_> i didn't get laughed out for asking a beginner question, which was a shock to the system
15:32:55 <Cale> bollu: So then any get will obtain the value set by the *following* put, which, if you're not careful, might depend on the value thus obtained
15:33:04 <bollu> Cale: right
15:33:06 <lapinot> lyxia: yeah, i was typing `showTypeOf identity` in ghci
15:33:14 <lapinot> lyxia: gonna update right now
15:33:18 <Cale> bollu: So you can write stuff like:  do xs <- get; put (1:xs); return xs
15:33:28 <Cale> bollu: and that'll compute an infinite list of 1's :)
15:33:35 <bollu> Cale: WTF :P
15:33:44 <bollu> Cale: as usual, I get mind-bent by haskell
15:33:49 <lyxia> lapinot: Typeable is only going to show non-parametric types.
15:33:56 <sdrodge> I was actually doing a hackerrank problem in python the other day that was absolutely perfect for the Tardis monad. You could use it for practice/understanding if you want, bollu: https://www.hackerrank.com/challenges/candies
15:34:21 <bollu> sdrodge: haskell doesn't TLE?
15:34:34 <bollu> sdrodge: I've never been able to get haskell to perform as well as I want it to
15:34:47 <sdrodge> bollu: You'll learn. Don't worry.
15:34:47 <lyxia> lapinot: in ghci you can do :t identity
15:34:48 <kadoban> Naw, I've done a bunch of hackerrank with haskell and it's fine.
15:35:09 <monochrom> bollu: If x and f are non-strict in the "state" parameter, they can accomplish something.
15:35:11 <sdrodge> bollu: Also, they give you a generous amount of time for Haskell on hackerrank.
15:35:19 <bollu> sdrodge: I've been trying for a year now, around. I could never get things to work on codeforces
15:35:37 <bollu> s/codeforces/codechef
15:35:38 <kadoban> 5s on hackerrank for haskell, yeah, compared to 2s for C++
15:35:44 <monochrom> For example maybe the state is a list, and x and f just prepend things to the list state.
15:35:52 <Cale> It takes some time to build up a sense of what's going to perform well.
15:35:59 <bollu> monochrom: right
15:35:59 <monochrom> Oh, Cale already showed that.
15:36:03 <kadoban> I've done codechef as well, it works okay. I can't recall if you get extra time there.
15:36:17 <bollu> Cale: I actually went to the effort of implementing a small functional interpreter to understand laziness
15:36:24 <bollu> Cale: I have a much better sense of it now
15:36:28 <bollu> Cale: WHNF 
15:36:33 <bollu> Cale: learning that helped a lot
15:36:34 <Cale> yeah
15:37:13 <sdrodge> bollu: If you're getting destroyed on time in these contests, using ByteString for I/O would likely fix it.
15:37:20 <monochrom> And also everytime you try to evaluate "expr1 expr2", work on expr1 first, afterward you may find that you don't even care about expr2.
15:37:46 <bollu> sdrodge: ah, I've never tried that
15:37:50 <bollu> sdrodge: will keep that in mind
15:37:52 <Cale> The thing which helped me a lot early on was watching programs reduce in this graphical functional language called HOPS http://www.cas.mcmaster.ca/~kahl/HOPS/ which sadly isn't available, but you can watch some animated gifs there anyway
15:38:00 <monochrom> which is why if-then-else can be a user-defined function in Haskell, but must be a built-in in eager languages.
15:38:07 <kadoban> Usually Text is enough, but for most problems it doesn't even matter. It starts to matter when you have huge inputs.
15:38:22 <sdrodge> Well, you don't get Text in a lot of these environments.
15:38:27 <Cale> Once you have that idea in your head, that evaluation at runtime is this process of editing an expression graph, and that space usage is at least roughly proportional to the size of that graph
15:38:37 <kadoban> Really? I think it's in all of hackerrank/codeforces/codechef at least
15:38:39 <sdrodge> The bytestring package comes with GHC, so it's always available.
15:38:40 <Cale> A lot of stuff gradually starts becoming more obvious
15:39:03 <sdrodge> kadoban: I couldn't swear by it, but I think it's not available on hackerrank.
15:39:09 <bollu> Cale: interesting
15:39:17 <bollu> Cale: I wrote some programs on this: http://github.com/bollu/timi
15:39:20 <lapinot> lyxia: oh, i hadn't this in mind...
15:39:25 <bollu> Cale: since I understood the whole system, it helped immensely
15:40:17 <kadoban> sdrodge: It's definitely in there, just tried.
15:41:08 <kadoban> Not that it really matters, I think *all* of these problems are ASCII only, so there's not a big problem using BS.Char8, fugly as it feels.
15:41:13 <Cale> bollu: yeah, definitely something like that helps
15:41:59 <sdrodge> kadoban: Good to know.
15:42:20 <Cale> bollu: Actually, to be honest, most of the time, I don't even think too hard about the graphs, and just think about expressions being rewritten (with the thought in the back of my head that some repeated bits of expressions can be the same stuff in memory if they came from binding the same variable)
15:43:56 <Sonolin> I haven't had much experience with reducing haskell memory usage
15:44:01 <Cale> Thunks are just the implementation of expressions at runtime :)
15:44:03 <Sonolin> but the GHC profiler is a godsend
15:44:36 <Sonolin> I reduced the speed of my game loop from a noticible ~1-2 second to some unnoticible millisecond amount in about 30 minutes 
15:45:04 <Cale> Yeah, usually you have a look at some space profile graphs, and you see "oh, there's a lot of things of such and such type", and you often pretty quickly have some idea of where they're coming from.
15:45:14 <sdrodge> milliseconds? That's an eternity to a computer :P
15:46:09 <bollu> Cale: I see
15:46:24 <Cale> Well, it depends on what kind of program you're writing
15:47:01 <bollu> Cale: what I find hard to predict is what the compiled code will look like. I have a feeling that close to every function call leads to a cache miss since thunk evaluation leads to an indirect jump?
15:47:02 <tobiasBora> Does anyone knows why my haskell programs uses 150 real memory, but 1.0T of virtual memory? (I don't really understand what is virtual memory)
15:47:46 <Cale> Oh, I've never actually worried about anything at that level
15:48:10 <bollu> Cale: xD
15:49:07 <geekosaur> tobiasBora, the virtual memory thing is some top programs understand it even less well than you do :)
15:49:35 <Cale> How does that happen? Memory mapped files?
15:50:29 <tobiasBora> geekosaur: Ahah ^^
15:50:34 <geekosaur> http://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/8.0.1-notes.html#runtime-system
15:50:40 <bollu> geekosaur: `top programs` as in CLI or `top program(ers)`? :P
15:50:47 <tobiasBora> Cale: I know, but I'm curious!
15:51:03 <bollu> geekosaur: was that for me?
15:51:03 <geekosaur> a program called "top" which shows the top processes consuming some resource (you usually cna select the resource to monitor)
15:51:18 <bollu> geekosaur: ah, OK
15:51:30 <monochrom> Don't look at VIRT. Look at RES.
15:51:32 <geekosaur> Cale, it preallocates page table entries but not actual pages
15:51:40 <Cale> ohh
15:51:48 <Cale> right
15:51:57 <geekosaur> so it looks like 1Tb reserved process memory, but very little of it is actually allocated
15:52:03 <geekosaur> 1TB
15:52:38 <Cale> Does it handle the case where your program needs >1TB of physical memory? :D
15:53:12 <Sonolin> sdrodge yea its a turned based game, so not exactly a deal breaker :)
15:53:18 <geekosaur> I have no idea. want to send me a system with 1TB memory to test with? :p
15:53:22 <Sonolin> I could probably improve it some more but its more of just an experiment
15:54:12 <geekosaur> (well, actually it;s virtual memory so you really just need >1TB swap and that the kernel lets user processes have address spaces >1TB...)
15:54:35 <Cale> I wonder how nicely it would work to allocate an entire 2TB SSD to swap :D
15:55:22 * geekosaur doesn't even know if a kernel swap map can get that big, for that matter...
15:55:35 <Cale> "Here you go programs, you're free now."
15:55:56 <koala_man> Cale: with xpoint/optane, that's basically what's happening
15:56:08 <monochrom> To be fair, I don't have a >=1TB disk partition yet.
15:57:08 <Squarism> Im curious on how people do logging? Dont write programs that need it? Are you using and happy with hslogger? Do you use some writer monad instead of having IO functions all over to accomodate logging? Havent found so much info on this on the webz
15:57:38 <jle`> i usually use monad-logger
15:57:53 <Cale> Squarism: I just pass a suitable logging function around. If my application already has some sort of configuration environment which is being passed around, I put it in there.
15:58:04 <sdrodge> Isn't the Writer monad a leaky mess?
15:58:10 <sdrodge> Or is that fixed somehow now?
15:58:51 <Cale> I don't bother with monad transformers for logging, it's silly.
15:59:19 <Squarism> jle`, Cale - thanks
15:59:35 <koala_man> geekosaur: I would be really surprised if you couldn't have 1PB swap. It's the https://xkcd.com/619/ kind of thing
15:59:44 <Cale> Especially if you don't already have a transformed IO monad throughout most of your application
15:59:53 <Cale> I wouldn't incur one just for logging
16:00:52 <koala_man> so many HPC and big data projects pushing all the limits
16:00:58 <Cale> Squarism: At the top level, if your application is concurrent, you'll want to fork a thread to read from a Chan of messages and write the actual log file
16:01:15 <Cale> Squarism: Just so that the messages don't get interleaved and stuff
16:01:31 <Cale> Squarism: and then your logging function that gets passed around just writes to the Chan
16:02:01 <Cale> If your app isn't concurrent yet, you don't have to do that, you can just open the log and pass around some thin wrapper for hPutStrLn
16:02:11 <Cale> (and maybe a flush just to be safe)
16:02:21 <Squarism> it would be for a concurrent app yes
16:03:11 <fadeway__> http://lpaste.net/8291769260707938304 seems to me like it´s crying about x being a list, but why would x be a list?
16:03:15 <Cale> This stuff is sort of easy enough to do, and slightly different enough each time I want to do it, that I've never really felt a great need to have a library for it.
16:03:55 <Cale> fadeway__: Because it's the second argument to Node
16:04:03 <Cale> fadeway__: Perhaps you meant Node t (x:xs)
16:04:04 <Squarism> Cale, well for me - doing everything "first time" in haskell im keen on not doing things ill regret
16:04:07 <Sonolin> "pass around some thin wrapper for hPutStrLn" how to do that if the function doesn't have access to IO, though?
16:04:16 <Squarism> ill DONT regret
16:04:24 <Cale> Sonolin: It will.
16:04:42 <Sonolin> ah, so you mean either use a  channel, or expose IO 
16:04:43 <fadeway_> oops, dc
16:04:58 <geekosaur> Squarism, you were right the first time actually :)
16:04:59 <Cale> Anything which is doing something worth logging is usually going to have access to IO at some level.
16:05:05 <jle`> monad-logger is nice just because of the formatting and TH that formats the output for you, but yeah, i suppose that functionality can be implemented without adding an extra monad transformer
16:05:12 <Squarism> geekosaur, ops.. =D
16:05:15 <fadeway_> <Cale> fadeway__: Because it's the second argument to Node
16:05:30 <geekosaur> although more common is '...I won't regret'
16:05:48 <Squarism> (thumbup)
16:05:57 <Cale> fadeway_: The most important rule of precedence in Haskell (which isn't actually a rule of precedence) is that function application (whitespace) binds more tightly than any infix operator
16:06:01 <fadeway_> yeah, but if I´m writing a list as head:tail, isn´t head an element?
16:06:11 <Cale> fadeway_: So when you write Node t x:xs, it means (Node t x):xs
16:06:22 <fadeway_> ahh 
16:06:24 <fadeway_> thanks
16:45:33 <monochrom> I would meta-regret that I didn't do some experiments and exploring that would cause regrets.
17:18:58 <Jello_Raptor> huh, is there a standard way to "MonadState s m => Lens s a -> (a -> (b,a)) -> m b" I mean it's just "overAnd l f = state $ l f" but I'm curious why there's no operator for it in Control.Lens since it's something that I keep on needing (I'm using `<&=` for the moment)
17:19:50 <Jello_Raptor> or is there a good reason to not define that operator? 
17:20:05 <c_wraith> it seems a little specialized.
17:22:59 <Jello_Raptor> fair enough
17:28:01 <jle`> Jello_Raptor: is %%= what you are looking for?
17:28:36 <jle`> (%%=) :: MonadState s m => Lens s s a b -> (a -> (r, b)) -> m r
17:41:26 <m_ryan> hi i have a question here: how do i insert a character in every char on strin?
17:41:54 <m_ryan> e.g HELLO -> %H%E%L%L%L%O%
17:43:21 <peddie> :t intersperse
17:43:23 <lambdabot> a -> [a] -> [a]
17:43:27 <Welkin> yes
17:43:30 <peddie> > intersperse '%' "HELLO"
17:43:32 <lambdabot>  "H%E%L%L%O"
17:43:42 <peddie> m_ryan: ^
17:43:45 <Welkin> you could write all of these functions yourself m_ryan 
17:43:56 <Welkin> or just search hoogle for `a -> [a] -> [a]`
17:44:35 <Koterpillar> @hoogle a -> [a] -> [a]
17:44:36 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
17:44:36 <lambdabot> GHC.OldList intersperse :: a -> [a] -> [a]
17:44:36 <lambdabot> Data.Text.Internal.Functions intersperse :: a -> [a] -> [a]
17:45:13 <m_ryan> thanks everyone :)
17:49:23 <Welkin> > (init . concat . zipWith (\a b -> [a, b])) "hello" (repeat '%')
17:49:26 <lambdabot>  error:
17:49:27 <lambdabot>      • Couldn't match expected type ‘[Char] -> t’
17:49:27 <lambdabot>                    with actual type ‘[[Char]]’
17:49:34 <Welkin> :t repeat
17:49:36 <lambdabot> a -> [a]
17:49:42 <Welkin> > repeat '%'
17:49:45 <lambdabot>  "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%...
17:50:19 <Koterpillar> Welkin: did you want concatMap there somewhere?
17:51:52 <Koterpillar> > concatMap (:"%") "hello" -- almost
17:51:54 <lambdabot>  "h%e%l%l%o%"
17:52:08 <Welkin> > init . concat $ zipWith (\a b -> [a, b]) "hello" (repeat '%')
17:52:10 <lambdabot>  "h%e%l%l%o"
17:52:22 <Welkin> lol, sure, that works too
17:52:35 <Welkin> one thing I love about haskell is that there is more than one way to do it
17:52:50 <Sonolin> you must love perl too, right?
17:52:55 <Welkin> haha
17:52:57 <Welkin> nope
17:53:13 <Welkin> it's an entertaining language though
17:53:14 <Sonolin> yea just joshing you ;)
17:53:21 <Koterpillar> Welkin: notice that all these solutions are doing different things
17:53:30 <robertkennedy> When Wadler talks about `fix :: (a -> a) -> a`, how separate is this function from `fix' :: (a->a)-> a -> a`, which takes a seed value? Newton's algorithm seems a member of fix' but not fix
17:53:31 <Welkin> Koterpillar: yes, but the result is the same
17:53:52 <Koterpillar> Welkin: no
17:54:07 <Welkin> Koterpillar: add an `init` to yours and it is
17:54:17 <Koterpillar> Welkin: notice the first and last '%' absent
17:55:14 <Koterpillar> ah, you're right, I thought the first one did "%h%e%l%l%o%"
17:55:34 <Welkin> concatMap is also just concat . map
17:56:13 <Welkin> and map (:"%") is the same as zipWith (\a b -> [a, b]) <string> (repeat '%')
17:56:55 <m_ryan> how do i run some code here?
17:56:56 <Koterpillar> so are you saying there's just one way to do it, just written differently?
17:57:10 <Welkin> m_ryan: prefix with > 
17:57:16 <Welkin> Koterpillar: lol, maybe
17:57:33 <tobiasBora> geekosaur: Thank you for your VIRT explaination!
17:57:36 <Koterpillar> m_ryan: prefix it with "> ". You can also message lambdabot with that
17:58:05 <m_ryan> >  init . concat $ zipWith (\a b -> [a, b]) "%hello%" (repeat '%')
17:58:08 <lambdabot>  "%%h%e%l%l%o%%"
17:58:16 <m_ryan> >  init . concat $ zipWith (\a b -> [a, b]) "hello" (repeat '%')
17:58:18 <lambdabot>  "h%e%l%l%o"
17:58:43 <m_ryan> what is the best way to append % from start and end of the text?
17:58:58 <Welkin> m_ryan: intersperse
17:59:03 <Welkin> it's already defined
17:59:10 <Koterpillar> m_ryan: just start and end, or in between too?
17:59:14 <Welkin> we were just having fun writing our own implementation
17:59:16 <m_ryan> > intersperse "%" "hello"
17:59:18 <lambdabot>  error:
17:59:19 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
17:59:19 <lambdabot>        Expected type: [[Char]]
17:59:26 <Welkin> it takes a Char not a String
17:59:37 <m_ryan> > intersperse '%' 'hello'
17:59:40 <lambdabot>  error:
17:59:40 <lambdabot>      • Syntax error on 'hello'
17:59:40 <lambdabot>        Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
17:59:42 <Welkin> > intersperse '%' "Dr Pete Loomis"
17:59:44 <lambdabot>  "D%r% %P%e%t%e% %L%o%o%m%i%s"
18:00:00 <Welkin> m_ryan: '' is for Char, "" is for String
18:00:10 <Welkin> I thought you knew this o.o
18:00:20 <m_ryan> intersperse '%' "HELLO"
18:00:32 <m_ryan> > intersperse '%' "HELLO"
18:00:34 <lambdabot>  "H%E%L%L%O"
18:00:56 <isd> Hey all. I'm getting my hands dirty with the ST monad & mutable vectors for the first time, and I'm  banging my head against a type error. Here's a simplified version of the code: http://lpaste.net/3328211105888600064
18:01:00 <m_ryan> Welkin: not very familiar :)
18:01:03 <Welkin> > intercalate "NaNaNaNaNaNaNaNa" "BATMAN"
18:01:05 <lambdabot>  error:
18:01:05 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
18:01:05 <lambdabot>        Expected type: [[Char]]
18:01:07 <isd> and the error: http://lpaste.net/1872846555577319424
18:01:27 <Welkin> > intercalate "NaNaNaNaNaNaNaNa" (replicate 5 "BATMAN")
18:01:30 <lambdabot>  "BATMANNaNaNaNaNaNaNaNaBATMANNaNaNaNaNaNaNaNaBATMANNaNaNaNaNaNaNaNaBATMANNaN...
18:02:00 <Koterpillar> m_ryan: just start and end, or in between too?
18:02:11 <m_ryan> both
18:02:29 <Welkin> just start and end is easy
18:02:34 <Welkin> just flip the parameters
18:02:38 <Welkin> and use intercalate
18:02:44 <m_ryan> flip?
18:02:57 <Welkin> > intercalate "Batman" (replicate 2 "%")
18:02:59 <lambdabot>  "%Batman%"
18:03:22 <Welkin> lol, yes you can use flip too
18:03:24 <isd> I feel like I half get what it's talking about, but am at enough of a loss that I'm having trouble articulating what I do understand. The vector package uses a handful of language extensions I haven't played with before.
18:03:29 <isd> Um. any insights?
18:03:39 <Welkin> > (flip intercalate) (replicate 2 "%") "Batman"
18:03:41 <lambdabot>  "%Batman%"
18:04:10 <m_ryan> > (flip intercalate) (replicate 2 "%") (interperse '%' "Batman")
18:04:11 <Welkin> isd: ask away and someone might answer
18:04:12 <lambdabot>  error:
18:04:12 <lambdabot>      • Variable not in scope: interperse :: Char -> [Char] -> [Char]
18:04:12 <lambdabot>      • Perhaps you meant one of these:
18:04:58 <Welkin> m_ryan: if you want them between and one both ends, just modiy the order of parameters to zipWith
18:05:16 <Welkin> actually
18:05:38 <Welkin> > '%' : concatMap (:'%') "Batman"
18:05:40 <lambdabot>  error:
18:05:40 <lambdabot>      • Couldn't match expected type ‘[Char]’ with actual type ‘Char’
18:05:40 <lambdabot>      • In the second argument of ‘(:)’, namely ‘'%'’
18:05:51 <Welkin> > '%' : (concatMap (:'%') "Batman")
18:05:54 <lambdabot>  error:
18:05:54 <lambdabot>      • Couldn't match expected type ‘[Char]’ with actual type ‘Char’
18:05:54 <lambdabot>      • In the second argument of ‘(:)’, namely ‘'%'’
18:06:04 <Welkin> > '%' : concatMap (:"%") "Batman"
18:06:05 <Welkin> oops
18:06:06 <lambdabot>  "%B%a%t%m%a%n%"
18:06:25 <Welkin> m_ryan: so many ways to do it; choose your favorite
18:06:27 <Welkin> or make your own
18:06:39 <m_ryan> this is the anser  '%' : concatMap (:"%") "Batman"
18:07:13 <m_ryan> q: your code will return a String right?
18:07:21 <Welkin> yes
18:07:29 <m_ryan> thanks :)
18:07:29 <isd> I think I need to understand type families better before I'll be able to piece it together.
18:07:37 * isd goes off to read
18:07:38 <Welkin> but as you can see, the first '%' is a Char, and the second "%" is a String
18:08:03 <Welkin> it depends on what data you are working with
18:08:27 <Welkin> if you want a reusable function that accepts a Char, then use something like this
18:08:31 <johnw> isd: type families are thankfully one of the easier ones, despite some of the documentation
18:08:47 <johnw> isd: in another language, you'd just think of them as functions...
18:09:33 <Welkin> > let f a = a : concatMap (:[a]) in f '%' "Batman"
18:09:35 <lambdabot>  error:
18:09:36 <lambdabot>      • Couldn't match expected type ‘[b]’ with actual type ‘[b] -> [b]’
18:09:36 <lambdabot>      • Probable cause: ‘concatMap’ is applied to too few arguments
18:10:07 <Welkin> > let f a b = a : concatMap (:[a]) b in f '%' "Batman"
18:10:09 <lambdabot>  "%B%a%t%m%a%n%"
18:10:10 <Welkin> fine lambdabot 
18:10:15 <isd> johnw: I mean, yeah. the error seems to suggest that -- and the ambiguity arises because the function isnt' necessarily injective.
18:10:24 <Welkin> why doesn't eta reducation work there?
18:10:28 <Welkin> reduction*
18:10:31 <MarcelineVQ> because it would be wrong
18:10:41 <MarcelineVQ> \x -> (a : concatMap (:[a])) x
18:10:47 <Welkin> oh, I see
18:11:03 <Welkin> point-free strikes again
18:11:33 <Welkin> @pl f a b = a : concatMap (:[a]) b
18:11:33 <lambdabot> f = liftM2 (.) (:) ((=<<) . flip (:) . return)
18:11:36 <Welkin> lol
18:12:58 <MarcelineVQ> meet halfway :> (a :) . concatMap (:[a])
18:21:48 <m_ryan> Welkin: let f a b = a : concatMap (:[a]) b in f '%' "Batman" is this the function?
18:22:17 <Welkin> m_ryan: with the Batman and all yes
18:22:39 <m_ryan> i want Batman to be string variable
18:22:54 <m_ryan> and the % is as is how would i do that?
18:29:55 <m_ryan> i already did thanks :)
18:30:01 <MarcelineVQ> m_ryan: gj!
18:31:03 <lpaste> ExpHP pasted “the compiler's incoherent choice regarding incoherent instances” at http://lpaste.net/354119
18:31:28 <isd> Is there a concrete advantage to type family synonyms over functional dependencies? The reading I have done suggests that if vector was using those instead, I wouldn't be having this problem.
18:31:47 <ExpHP> how dost I do incoherent instances halp
18:34:41 <ExpHP> (second instance is supposed to bootstrap the class, first instance propagates it)
18:35:13 <ExpHP> but the compiler loves the first instance so much that it never considers the second one
18:39:36 <glguy> ExpHP: No, you just don't get to do this
18:39:49 <glguy> ExpHP: The fact that the instance heads are different isn't relevant to instance selection
18:40:18 <glguy> Turning on incoherent instances is you promising that it doesn't matter which instance is picked, that both behave the same
18:42:53 <c_wraith> I wonder how much people would be upset with me if I started putting duplicate incoherent instances into my libraries 
18:48:21 <robertkennedy> Does dph exist in GHC 8?
18:50:36 <robertkennedy> Independently: what's a good way to index a single value set with multiple inputs? Like a Sudoku puzzle
18:51:06 <Welkin> ?
18:51:10 <Welkin> a graph?
18:54:06 <robertkennedy> Hmmm. That does sound nice. Is there a repa esteemed for graphs?
18:54:45 <robertkennedy> *repa esteemed package
19:08:49 <ExpHP> ah, er, oops, apparently I was scrolled up and didn't see the responses
19:09:01 <ExpHP> but uh, thanks to whoever said the thing, which I'm sure was nice
19:10:13 <Cale> ExpHP: There was a warning that you shouldn't turn on IncoherentInstances
19:10:39 <Cale> <glguy> ExpHP: No, you just don't get to do this
19:10:39 <Cale> <glguy> ExpHP: The fact that the instance heads are different isn't relevant to instance selection
19:10:39 <Cale> <glguy> Turning on incoherent instances is you promising that it doesn't matter which instance is picked, that both behave the same
19:11:00 <ExpHP> Hm
19:11:48 <Cale> ExpHP: Your two instance heads look identical to the instance resolver
19:12:04 <Cale> ExpHP: MonadReaders ns s (ReaderT nt m)  vs.  MonadReaders ns s (ReaderT ns m)
19:12:16 <Cale> There's no type constructor there to match on to distinguish them
19:13:05 <Cale> ExpHP: Something you should be aware of is that the class constraints on an instance *do not matter* when it comes to deciding which instance to use.
19:13:19 <ExpHP> Cale: :o
19:13:52 <Cale> They get applied only *after* committing to the instance
19:14:28 <Cale> The reason for that is that the compiler can never rely on the absence of an instance -- it might exist in some future module, yet to be compiled or written.
19:16:41 <ExpHP> you mention that it needs type constructors to match, I wonder if I could somehow encode the depth of each nested instance with a natural number-y encoding in the type system...
19:16:48 <Cale> If it did rely on it, then decisions about which instance to use could be affected by future modules, meaning that previous stuff either needs to be recompiled, or else confusing and arbitrary choices would get made.
19:17:35 <ExpHP> have instances for S Foo, S (S Bar), S (S (S Baz)))...
19:18:18 <Cale> You could do something like that, or just do what I do and never really use the MonadReader class, apart from some early setup.
19:18:32 <ExpHP> hehe
19:19:13 <Cale> If you want to actually make things usable, either define your own classes with more meaningful operations, or at least the monomorphic operations for the monad you'll actually be using.
19:19:21 <ExpHP> I was trying to write something like this for State, because I wanted to just be able to plunk a layer into my stack that had some state and have methods for it "just work"
19:20:02 <ExpHP> with only one MonadState instance I have to tangle it all together
19:20:22 <Cale> I hate the word "stack" in this context, because if you have to think of it like a stack, you could probably be designing things a lot better.
19:21:03 <Cale> You have a monad. It may or may not have been constructed from other monads using some monad transformers.
19:21:54 <Cale> If you have a few monads which have different capabilities by design, then express those through type class constraints, satisfied by the few different monads you use.
19:22:07 <Cale> (assuming you want the polymorphism)
19:22:32 <Cale> But try to make it so that outside of the small module in which you define your monad, nobody can tell you're using monad transformers.
19:22:50 <Welkin> lol
19:22:59 <Welkin> "monad transformer stack"
19:23:15 <Welkin> it's not a transformer stack if you use the mtl typleclasses
19:23:31 <ExpHP> Welkin: yeah about that (scroll up)
19:23:49 <Welkin> to where?
19:23:57 <ExpHP> to me complaining about MonadReader
19:23:58 <Welkin> I'm not going to read the whole log
19:24:08 <Cale> Well, the term stack comes from the idea that you're going to be lifting operations different numbers of times and needing to care about all the intermediate monads along the way
19:24:35 <Welkin> There is also extensible effects using Free(er)?
19:24:37 <Cale> If you have a situation like that, probably it's worth thinking about whether you can do something better.
19:25:04 <Cale> There are countless ways to defer the decision about how to implement operations, yes.
19:25:27 <Cale> (though most of them will harm performance by preventing inlining)
19:25:46 <Cale> (sometimes that's okay)
19:26:04 <ExpHP> cale: okay, thanks for the explanation
19:26:20 <Welkin> https://hackage.haskell.org/package/freer-effects
19:26:39 <Cale> I used to have a little article about this, but it was only on a webserver on a machine whose hard drive died.
19:26:46 <Cale> I should rewrite it
19:27:40 <leshow> is there a way to get ghc to give me it's function signature for an instance?
19:28:04 <Welkin> leshow: look up the typeclass definition
19:28:07 <leshow> like, I want to try implementing lift in MonadTrans for StateT, can I get ghc to spit out the signature for that
19:28:19 <Cale> :t lift
19:28:20 <leshow> I mean with StateT substituted in
19:28:21 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
19:28:32 <Cale> (Monad m) => m a -> StateT s m a
19:28:47 <Cale> hmm
19:29:18 <leshow> isn't it like StateT s m a -> t (StateT s m a)
19:29:24 <Cale> no
19:29:28 <Cale> It's what I said :)
19:29:50 <Cale> lift takes an action in your original monad, and turns it into an action in the transformed monad
19:30:22 <leshow> so we're transforming it into a StateT action? from some other action?
19:30:26 <Cale> yes
19:30:40 <Cale> From an m action to a (StateT s m) action
19:31:13 <leshow> ok
19:32:26 <leshow> why do people use liftM instead of fmap, they look like they do the same thing
19:32:35 <Welkin> leshow: they don't
19:32:40 <Welkin> :t fmap
19:32:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:32:41 <Welkin> oh
19:32:43 <Welkin> yeah
19:32:46 <Welkin> liftM, not lift
19:32:50 <Welkin> liftM is old
19:32:57 <Welkin> fmap replaced it and is more general
19:33:00 <leshow> like mapM and traverse?
19:33:03 <Welkin> kind of like return and pure
19:33:18 <leshow> you can use pure in a monad now? instead of return?
19:33:21 <Welkin> yes
19:33:36 <Welkin> return = pure
19:34:04 <leshow> cool, i think purescript does that
19:34:50 <Cale> Well, liftM still serves a useful purpose
19:34:50 <Welkin> :t liftM
19:34:50 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
19:34:51 <Welkin> Cale: it does?
19:34:51 <MarcelineVQ> liftM is possibly useful in that when you say liftM you really mean to be using a Monad and ghc will let you know if there isn't one
19:34:51 <Cale> liftM is defined in terms of return and >>=
19:34:51 <Cale> So if you have your Monad instance written and want a Functor instance
19:34:53 <Cale> you can write fmap = liftM
19:34:55 <Welkin> yeah
19:35:00 <Welkin> that makes sense
19:35:48 <leshow> is monadtransformers still the popular way to go about composing applications
19:36:09 <Cale> leshow: They're a popular way to compose... monads.
19:36:33 <Cale> Defining an application specific monad is sometimes a good plan, sometimes a bit frivolous
19:36:47 <leshow> most web frameworks seem to use them, is there another strategy that's popular?
19:37:02 <Cale> Well, yeah, it's a little bit unfortunate.
19:37:20 <Cale> Not always the worst thing -- some cases are better than others.
19:37:27 <Welkin> I mentioned freer
19:37:30 <Welkin> https://hackage.haskell.org/package/freer-effects
19:37:42 <Welkin> extensible effects is very interesting
19:37:45 <Cale> You can just... write your program and not worry about defining monads.
19:37:48 <Welkin> it's used in purescript
19:38:21 <Welkin> I'll generally define a newtype App that is ReaderT
19:38:37 <Welkin> to store global config information for an application
19:39:13 <Cale> Sometimes that's nice, but I'd usually avoid moving away from IO to some other monad just for ReaderT
19:39:38 <leshow> whats the performance like for freer? Is everything interpreted at run time?
19:39:38 <Cale> You pay in liftIO what you made up in parameter passing
19:40:21 <leshow> you're making a DSL basically right, that gets interpreted?
19:40:26 <Cale> and you make things like bracket, forkIO, withMVar, catch, etc. etc. annoying to use
19:42:54 <chipmadness> does anyone know why this is not working? I don't know why it is yelling at me because of "then"
19:42:56 <chipmadness> displayNevenRecursive n k = if(k <= n && k%2==0 then print(displayNevenRecursive n k++) else if k <= n then displayNevenRecursive n k++ else return) 
19:43:23 <chipmadness> basically, i am making a recursive function that counts to N but only shows even numbers to N
19:43:46 <Cale> What the...
19:43:53 <Cale> You're partially applying ++
19:43:54 <Cale> ?
19:43:54 <MarcelineVQ> that's not quite how haskell if's are written
19:44:02 <leshow> why are you return-ing
19:44:23 <chipmadness> returning because its done. if k is past N, then stop counting
19:44:31 <leshow> thats not what return does
19:44:45 <Cale> Yeah, and that return doesn't make sense -- return is a function, which makes an action that does nothing except to return the given value as its result
19:44:54 <chipmadness> oh, I didn't look that part up, I was thinking in C++ terms
19:45:00 <Cale> You might be able to put  return ()  there
19:45:19 <Cale> also, your parens are super weird
19:45:36 <Cale> if( <-- I think this paren is out of place
19:46:00 <ExpHP> Let's start with the easy fixes
19:46:07 <chipmadness> this example I read uses paran -> doubleSmallNumber' x = (if x > 100 then x else x*2) + 1  
19:46:21 <ExpHP> chipmadness: ++ in haskell is string concatenation.  You probably want (k+1)
19:46:32 <Cale> That's using parens to group the if expression
19:46:33 <ExpHP> er, list concatenation.  Same thing.
19:46:46 <Cale> and note that the ( is outside the if
19:47:09 <Welkin> lol cale
19:47:29 <chipmadness> LOL
19:47:37 <chipmadness> i am blind, now it hates my else
19:47:49 <Cale> (displayNevenRecursive n k++) would be the function which concatenates the list  displayNevenRecursive n k  with whatever list it's supplied
19:48:07 <Cale> > ([1,2,3] ++) [4,5]
19:48:10 <lambdabot>  [1,2,3,4,5]
19:48:23 <Cale> > map ([1,2,3] ++) [[4,5], [6,7]]
19:48:26 <lambdabot>  [[1,2,3,4,5],[1,2,3,6,7]]
19:48:36 <leshow> you probably want mod too, not %
19:48:42 <Cale> Yeah, or just even
19:48:46 <Cale> > even 5
19:48:48 <lambdabot>  False
19:48:51 <Welkin> use case and  guards instead of if then else
19:48:51 <Cale> > even 6
19:48:53 <lambdabot>  True
19:49:14 <chipmadness> oh true
19:49:18 <Welkin> if-then-else is messy and unidiomatic except for very simple predicates
19:49:20 <chipmadness> i forgot ++ is concat
19:49:25 <chipmadness> i want it to plus by 1
19:49:27 <chipmadness> += 1
19:49:37 <Cale> n + 1
19:49:38 <Cale> ?
19:49:57 <Cale> n is whatever number it is
19:50:15 <allenj12> how do you x^n where x is a Double and n is an integer?
19:50:25 <ExpHP> x**n
19:50:26 <Cale> allenj12: Just like that
19:50:36 <Cale> Well, if you want negative values of n, use ^^
19:50:38 <ExpHP> actually yeah what Cale said
19:50:39 <allenj12> Cale: getting a type error, hmmm
19:50:53 <Cale> > (pi :: Double)^(6 :: Integer)
19:50:55 <lambdabot>  961.3891935753043
19:51:02 <Cale> > (pi :: Double)^(-6 :: Integer)
19:51:04 <lambdabot>  *Exception: Negative exponent
19:51:08 <Cale> > (pi :: Double)^^(-6 :: Integer)
19:51:09 <allenj12> Cale: its probably something else thanks maybe i can post the function. its really confusing me
19:51:11 <lambdabot>  1.0401614732958525e-3
19:51:17 <Cale> lpaste.net :)
19:51:32 <Sornaensis> :t (^^)
19:51:34 <lambdabot> (Integral b, Fractional a) => a -> b -> a
19:51:40 <Sornaensis> :t (**)
19:51:41 <lambdabot> Floating a => a -> a -> a
19:51:51 <leshow> http://lpaste.net/354122
19:52:05 <leshow> that's similar to your first function
19:52:30 <leshow> probably still crappy, I'm new to haskell also
19:52:35 <Cale> I think he actually wanted to increment k
19:52:47 <allenj12> eToThe x = (1+) $ sum $ foldl (+) 0 (map (\n -> (x^n)/(fact n)) [1..11])    fact :: Int -> Int. I get expected type [Double] and got Double in first argument of ^
19:52:47 <leshow> he said count to k printing evens, I think
19:52:56 <Cale> ah
19:53:04 <chipmadness> yeah
19:53:07 <chipmadness> thank you leshow
19:53:29 <Cale> Well, I would just write mapM print (filter even [k..n])
19:53:50 <leshow> yeah, I just wanted to make it like his original function, so it might make more sense
19:53:54 <chipmadness> Cale: displayNevenComprehension n = print([x*2 | x <- [1..n], x*2 <= n])
19:53:56 <chipmadness> i did :)
19:54:07 <Cale> allenj12: You probably want to apply fromIntegral to the fact n
19:54:24 <Cale> allenj12: It needs to be a Double so that you can divide by it.
19:54:32 <Cale> :t (/)
19:54:34 <lambdabot> Fractional a => a -> a -> a
19:55:01 <Cale> also, you really don't need that 1 + out front
19:55:12 <Cale> well, and you're summing twice?
19:55:22 <leshow> Cale, mapM_ right?
19:55:27 <leshow> because we dont want a return value
19:55:31 <Cale> leshow: yes
19:55:48 <post-ironic> Stupid question: in my simple hailstone iteration count program, I want it to take in an integer and return an integer.  It will be recursive with a pattern for odd and even. But how do I increment the iteration counter with each iteration and pass it to the next call?
19:56:09 <Cale> post-ironic: n+1?
19:56:17 <Cale> and then just... pass that along?
19:56:21 <allenj12> Cale: that one was a typo.. anyway it works now... sort of
19:56:34 <Cale> allenj12: note that x^0 = 1
19:56:39 <Cale> (even when x = 0)
19:56:41 <Cale> > 0^0
19:56:44 <lambdabot>  1
19:56:47 <post-ironic> @cale Can I do that without making it take in two arguments?
19:56:47 <lambdabot> Sorry, look up one word at a time please.
19:57:16 <chipmadness> i see print is more like println, how do i make it so it doesn't do a new line?
19:57:19 <ExpHP> post-ironic: write an inner function
19:57:21 <Cale> post-ironic: I can't tell. Maybe not, if the result of the operation depends on both.
19:57:31 <Welkin> chipmadness: print is defined as `putStrLn . show`
19:57:41 <Welkin> you must want putStr
19:57:47 <leshow> putStr
19:57:52 <ExpHP> post-ironic:  outer n = inner k n where ...
19:57:57 <Cale> post-ironic: Functions have to produce their result based only upon the arguments you give them. There's nothing else their result can depend on.
19:58:26 <ExpHP> (I meant inner 0 n; the definition of outer is where you would initialize extra arguments)
19:58:32 <Cale> right
19:58:39 <post-ironic> Cale Yes but I'm sure there is a way to do this. I will look into an inner function, thank you
19:59:00 <Cale> Yeah, just define a second function to begin with. You can move it into a where clause after
19:59:49 <chipmadness> Welkin: doesn't putStr only work with char? I need it for Int
19:59:50 <allenj12> Cale: updated version eToThe x = sum $ map (\n -> (x^n)/(fromIntegral (fact n))) [0..11] , but getting NaN when passed  0 and infinity when passed 1 :(
20:00:08 <Cale> post-ironic, chipmadness, others: A general technique for translating imperative programs if you're lost is to turn each point of control in your imperative program into a function, and each mutable variable in scope there into a function parameter
20:00:13 <leshow> is there a traverse that throws away the result, like mapM_
20:00:28 <Cale> Then you have each function apply the next according to your program's control flow.
20:00:47 <Cale> This will generally result in a mess, but it will be a mess of *equations*
20:01:18 <Cale> and you can simplify that the same way you'd simplify expressions in highschool algebra by plugging one equation into another and eliminating them.
20:01:37 <Welkin> wedens: what...
20:01:41 <Welkin> chipmadness: what...
20:01:49 <post-ironic> Cale Not sure I understand how a function can replace a variable
20:01:53 <Welkin> :t putStr -- chipmadness 
20:01:54 <lambdabot> String -> IO ()
20:02:05 <Cale> post-ironic: A function replaces a point of control in your program
20:02:09 <Welkin> if you can something that is not a String, you can apply `show` over it
20:02:14 <Welkin> :t show -- chipmadness 
20:02:15 <lambdabot> Show a => a -> String
20:02:34 <Welkin> :t putStr . show -- chipmadness, like this
20:02:36 <lambdabot> Show a => a -> IO ()
20:02:36 <Cale> post-ironic: i.e. the function will compute the final result of your imperative program, starting from that point, with its arguments being the current values of the mutable variables
20:03:13 <Cale> post-ironic: So you'd start out with a function for almost every line
20:03:26 <Cale> and if you have a loop, it will turn into (mutual) recursion
20:04:02 <Cale> because the function for the line at the end of the loop will apply the function for the start of the loop (or the loop test or whatever)
20:04:47 <Cale> and ordinarily, each function will apply the next to whatever the new values for the variables are (often the same, unless you've updated them)
20:06:40 <post-ironic> Cale my brain.exe stopped working
20:07:06 <Cale> I'll see if I can make you a simple example
20:07:14 <Welkin> post-ironic: that's because it's running winows
20:07:18 <Welkin> windows
20:07:52 <post-ironic> it's running in wine on gentoo linux
20:09:57 <dmwit> chipmadness: `print = putStrLn . show`, so perhaps you would like `printNoLn = putStr . show`.
20:10:13 <chipmadness> I got it working, thanks dmwit
20:10:26 <dmwit> Oh, I missed Welkin's answer. Sorry about that.
20:14:23 <chipmadness> http://lpaste.net/4885411465386786816
20:14:36 <dmwit> allenj12: Did you get an answer?
20:14:36 <chipmadness> I am trying to use this example now, but instead put it to a list
20:14:52 <dmwit> allenj12: If not, you should show your `fact`. When I paste your code into a file and implement `fact` myself it works fine.
20:14:56 <chipmadness> in the end, I want it to print the list
20:15:07 <utdemir> Hey. I have a template haskell function that generates some data type (String -> DecsQ). Now I also want to generate lenses using Control.Lens.TH.makeLenses function. But when I do that, it gives me "MyData is not in scope at a reify". I can understand the problem that makeLenses wants to reify to get my data structure, but it isn't defined yet. But I don't know a way to solve this. Can somebody help me?
20:15:16 <Welkin> chipmadness: consider breaking your function into smaller parts
20:15:19 <chipmadness> xs ++ n should add n to the end of the list correct?
20:15:19 <post-ironic> Cale wait maybe you are supposed to define an inner function that increments a variable counting iterations and calls the function to do the next iteration?
20:15:23 <Welkin> a pure part, and an impure part
20:15:28 <leshow> chipmadness, why do all that, when you can just do filter even [0..k]
20:15:28 <allenj12> dmwit: sorry its working fine now (the numbers are wrong) but there close logic error now
20:15:32 <Welkin> keep your IO separate from your computations
20:15:45 <chipmadness> i am screwing with recursion leshow
20:17:18 <dmwit> chipmadness: A question to ponder: why do you feel you need to fill in the `n` and `k` arguments when recursing on `displayNevenRecursion`, but do not need to fill in the `xs` argument?
20:17:25 <leshow> http://lpaste.net/4885411465386786816
20:17:34 <lpaste> Cale pasted “Translating imperative to functional, the mechanical way, step 1” at http://lpaste.net/354124
20:17:40 <leshow> can get rid of that do probably
20:18:02 <chipmadness> crap, I pasted the wrong code: sorry dmwit
20:18:03 <leshow> (:) is the cons operator
20:18:06 <Cale> ^^ see that paste for an example of what you might get doing this very mechanically
20:18:19 <Cale> Now I'll start simplifying it...
20:18:47 <chipmadness> thank you leshow
20:19:37 <ExpHP> Cale: Have you heard of this thing called GOTO?
20:20:03 <ExpHP> crap I forgot the winky emoticon
20:20:28 <chipmadness> leshow, how come it is backwards?
20:20:39 <chipmadness> it counts down
20:20:49 <chipmadness> I tried switching the (:)
20:20:50 <leshow> I never ran it, I just wrote your code in a way that compiles
20:21:01 <leshow> try playing with it
20:21:06 <chipmadness> Haskell is just so picky
20:21:14 <chipmadness> or i am too leanent
20:21:19 <leshow> or you just don't know any of the functions lol
20:21:27 <chipmadness> ^^^^^^^^^^^^^
20:21:43 <dmwit> Cale: I think you lost the `k := k+1` line.
20:21:55 <dmwit> Cale: Or rather, you have it, but didn't "do" it, in `f5`.
20:22:02 <glguy> utdemir: did you get that working?
20:22:08 <leshow> you may want the (++) operator, to append to the end of a list. try some variations of that to get a feel for it
20:22:24 <leshow> function, not operator
20:22:26 <leshow> old habit lol
20:22:27 <chipmadness> oky
20:22:28 <chipmadness> okay
20:22:56 <Cale> dmwit: you're right, I'll edit it :)
20:23:28 <lpaste> Cale revised “Translating imperative to functional, the mechanical way, step 1”: “Translating imperative to functional, the mechanical way, step 1” at http://lpaste.net/354124
20:24:25 <glguy> utdemir: The order matters, make sure you're defining the datatype above where you're making lenses
20:26:13 <lpaste> Cale annotated “Translating imperative to functional, the mechanical way, step 1” with “Translating imperative to functional, the mechanical way, step 1 (annotation)” at http://lpaste.net/354124#a354127
20:26:31 <Cale> and there's an annotation with simplification steps
20:27:39 <Cale> post-ironic, chipmadness: http://lpaste.net/354124 -- hopefully this gives an impression of what I mean
20:27:53 <Cale> Of course, you usually wouldn't write all this out
20:28:17 <Cale> You might even go directly to the end result, after a bit of practice
20:28:38 <post-ironic> Cale Yes I see how you would have something with local variables by defining a new function now. thank you
20:28:53 <Cale> But I think it's good when you're starting out to have something you can kind of fall back on as a way to translate things
20:30:26 <Cale> I've actually done this to obfuscated C code before to try to understand what it was doing :)
20:32:42 <chipmadness> Wow thanks Cale
20:39:38 <lpaste> allenj12 pasted “whats the difference? Haskell math help!” at http://lpaste.net/4892280702936023040
20:39:38 <chipmadness> is there any way to build a one liner out of this? I feel it is too complicated for what it is: https://paste.ofcode.org/HFZfqsdQEwubp7UPVyyW5d
20:40:00 <Cale> > product [1..11]
20:40:00 <allenj12> Cale: if your still here I was wondering if you could check that post out
20:40:02 <lambdabot>  39916800
20:40:21 <allenj12> ugh theres a typo
20:40:26 <allenj12> its [0..10]
20:40:28 <allenj12> not to 11
20:40:28 <chipmadness> LOL i know that, but I want to make my own product
20:40:53 <lpaste> allenj12 revised “whats the difference? Haskell math help!”: “whats the difference? Haskell math help!” at http://lpaste.net/4892280702936023040
20:41:19 <Welkin> > foldl1' (*) [1..10]
20:41:20 <Cale> Yeah, well, that last term ought not to matter too much
20:41:21 <lambdabot>  3628800
20:41:28 <Welkin> > product [1..10]
20:41:30 <lambdabot>  3628800
20:43:58 <dmwit> allenj12: It's actually [0..9], isn't it?
20:44:04 <dmwit> > take 10 [0..]
20:44:06 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
20:44:18 <Cale> yeah, hah, beat me to it
20:44:37 <Cale> Actually, it matters quite a lot that you're truncating the series
20:44:40 <Cale> > exp 20
20:44:42 <lambdabot>  4.851651954097903e8
20:45:08 <allenj12> ugh, yea thats it :( lol
20:45:12 <dmwit> Yeah, the observation that made me scratch my head was that the final terms in the sum were contributing quite a lot to the actual value.
20:45:45 <dmwit> chipmadness: `product = foldl' (*) 1` is another way to spell it
20:45:48 <Cale> 20 is far enough away from 0 that the convergence isn't terribly fast
20:46:46 <dmwit> chipmadness: (Actually I guess what you wrote is `foldr (*) 1`. But `(*)` is associative and commutative, so...)
20:47:07 <chipmadness> thanks everyone
20:47:40 <Cale> We can actually extract the definition of foldr from that, by abstracting out the (*) and 1 into parameters :)
20:48:34 <Cale> You might also have written
20:48:48 <Cale> sum' [] = 0; sum' (x:xs) = x + sum' xs
20:49:30 <Cale> and noticing the similarity between this code and the code for product (and the code for concat, and a bunch of other stuff), you might try abstracting out the bits which are different
20:56:28 <spatial> Passing an array around nested functions http://lpaste.net/354128 Is arr updated ?
20:57:13 <spatial> The array 'arr' is being read and written.
20:58:10 <ExpHP> > let id = foldr (:) []
20:58:12 <lambdabot>  <no location info>: error:
20:58:12 <lambdabot>      not an expression: ‘let id = foldr (:) []’
20:58:25 <ExpHP> > let id = foldr (:) [] in id [3,6,1,7,3,6,7]
20:58:28 <lambdabot>  [3,6,1,7,3,6,7]
20:59:31 <pavonia> spatial: What do you mean by updated?
20:59:50 <spatial> It is an IOArray
21:00:34 <pavonia> You say it's written to it, so would that count as updating?
21:01:02 <spatial> writethevalue arr i (v+1) Yes
21:07:02 <spatial> Question is about the bindings that are reused
21:09:07 <pavonia> You should probably rephrase/elaborate your question, I have no idea what you're asking for
21:10:51 <spatial> pavonia: I have 'arr' which is an IOArray. Read and Write functions are tested separately. They use ReaderT and liftIO.
21:12:03 <spatial> pavonia:I have nested functions that pass the parameters around. Is 'arr' binding correctly used so that the same array is read and written to ?
21:13:51 <pavonia> Yes, there only in one array being passed around here
21:14:38 <pavonia> You don't even need that arr parameter in the loop function because the outermost arr is already in scope
21:15:26 <spatial> Ok
21:37:38 <event_null> lots of in and out traffic for such little conversation
22:18:52 <qmm> is there a way to search through hackage for all packages that derive an instance of a typeclass?
22:19:00 <qmm> a specific typeclass
22:19:56 <qmm> e.g. i am interested in finding all instances of a functor
22:21:23 <geekosaur> hayoo can do it but that's going to be a painfully large list
22:30:14 <lapinot> me again... my little code that does normalization by evaluation on HOAS has grown a bit by undergoing a CPS transformation but I fail to make things typecheck.. I have a result type O (the codomain of continuations) which is a GADT. I would be happy to add a constructor Final :: a -> O a so that i can effectively have some sink to get the final value. The problem is that if I can't find types so that O has
22:30:17 <lapinot> kind * -> * (effectively "storing" the type of the final result, thus typechecking when extracting from Final). When O "forget" the type (kind *) then everything typechecks
22:31:21 <lapinot> the code is here: https://ptpb.pw/mM4g, if anyone is insterested in this, please take a look, if you have any idea I would be happy :)
22:38:08 <lapinot> oh forget it :) adding a type annotation just solved it
22:43:01 <lapinot> or not... anyway, i'm getting forward!
23:26:32 <spatial> Can IOArray Int Double hold null for a particular value ? I use 0 to represent null.
23:28:02 <spatial> Lisp seems to use nil.
23:34:39 <liste> spatial: you can use Maybe Doublew
23:34:44 <liste> Maybe Double*
23:34:56 <liste> :t Just 4.0
23:34:58 <lambdabot> Fractional a => Maybe a
23:35:28 <liste> > ([Just 4.0, Nothing] :: [Maybe Double])
23:35:30 <lambdabot>  [Just 4.0,Nothing]
23:37:58 <spatial> arr <- newArray (0,bins) 0;          Default value is 0. How does this change ?
23:39:44 <cocreature> spatial: just replace 0 by whatever you want the default value to be?
23:46:10 <itachi> Hi guys is there anyplace or book where I can find questions on monad or monoids?
23:47:34 <cocreature> itachi: afaik http://haskellbook.com/ contains a lot of exercises
23:51:18 <itachi> cocreature does it also have solutions?
23:51:34 <cocreature> itachi: not sure
23:51:59 <itachi> k thanks
