00:18:09 <joneshf-laptop> I'm trying to hand write a `Distributive` instance, and I feel like I'm doing something wrong.
00:18:22 <joneshf-laptop> Someone tell me I'm doing something wrong, please.
00:19:18 <joneshf-laptop> I don't see any `Generic` tooling either :(
00:22:20 <joneshf-laptop> Wait, I was looking at an old version.
00:22:27 <joneshf-laptop> Life might be good again!
00:23:16 <jle`> :D
00:24:06 <jle`> you can always write a distributive instance by going through its representation
00:24:17 <jle`> even though it might not always be the most efficient way
00:24:37 <joneshf-laptop> what does taht mean?
00:26:49 <joneshf-laptop> Oh, this: https://www.stackage.org/haddock/lts-8.5/adjunctions-4.3/Data-Functor-Rep.html#v:distributeRep ?
00:27:51 <rmrfroot> i have a data type called `Resource` that has a member `resourceName :: Text`, i would like to have a list of `Resource`s with a uniqueness constraint on the `resourceName` member. can i express this on the type level?
00:28:52 <rmrfroot> currently using a newtype that enforces this constraint in construction
00:47:35 <joneshf-laptop> Nope, still hard.
00:49:33 <joneshf-laptop> Is there an ecosystem around adjunctions that doesn't involve `Representable` and `Distributive`?
00:50:35 <joneshf-laptop> I mostly want the adjunctions betweeen `Free`/`Cofree` and `(:+:)`/`(:*:)`.
00:50:54 <joneshf-laptop> But without having to write `Representable` instances.
00:52:03 <joneshf-laptop> All I really want is this function: https://www.stackage.org/haddock/lts-8.5/adjunctions-4.3/Data-Functor-Adjunction.html#v:zapWithAdjunction, but that requires a whole slew of instances.
01:15:11 <jle`> joneshf-laptop: what i mean is that for all distributive instances F, any 'F a' is isomorphic to a 'K -> a'
01:15:16 <jle`> for some type K
01:15:37 <jle`> so if you can write that function explicitly, you can do some basic manipulations to get 'distribute' from it
01:16:19 <jle`> oh yeah similar to what you linked to
01:23:42 <ezyang> Hey guys look at this: https://gist.github.com/ezyang/baf6b71e9032748d9c317cf2af3fe38b 
01:23:49 <ezyang> would you prefer the rows to be sorted, or as they are now? 
01:24:41 <athan> they aren't sorted, but that _might_ be nice :s
01:24:50 * athan isn't sure if there's a preorder of utility :D
01:24:56 <ezyang> the order they're in now is the order they appear in Haddock 
01:25:08 <athan> I like it this way imho
01:25:20 <athan> is this some kind of api comparison system you're building?
01:25:23 <ezyang> yep 
01:25:27 <athan> sweet :)
01:25:41 <ezyang> i wish I could get diagonal column headers but alas 
01:26:22 <ezyang> left aligned checkmarks, or center aligned? 
01:26:34 <athan> diagonal? Left aligned :)
01:26:50 <athan> in semantic ui you can have structured tables, but im not sure if that's up your alley
01:26:52 <ezyang> the thing where you can make the cells thinner if you angle the labels on top 
01:26:57 <athan> (i think html natively supports them)
01:27:03 <ezyang> i want to render it on GH, unfortunately :( 
01:27:31 <athan> hm, shoot I don't think asciidoc would be comprable either
01:27:58 <athan> maybe multiple tables?
01:28:04 <athan> One for each -- * section?
01:28:10 <athan> :S
01:28:19 <ezyang> then they won't line up 
01:28:33 <ezyang> Well, I guess they would 
01:28:40 <ezyang> if you pad out the first col enough 
01:29:26 <athan> heh, I think the utf8 space has a standard width
01:29:36 * athan LaTeX \quad to the rescue >.>
01:31:03 <joneshf-laptop> jle`, Gotcha! Thanks. My problem is figuring out what `K` is and then being motivated enough to actually implement the instance :).
01:46:12 <eugenez> Hello, friends! Is there a command like find, but one that finds and returns all values that satisfy the predicate?
01:46:27 <Rembane> eugenez: partition might do what you want
01:46:35 <Rembane> :i partition
01:46:41 <Rembane> Hm... 
01:46:46 <ezyang> filter 
01:46:49 <ezyang> :t filter 
01:46:52 <lambdabot> (a -> Bool) -> [a] -> [a]
01:47:03 <eugenez> Thank you, friends!
01:47:11 <Rembane> eugenez: https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-List.html#g:15
03:00:59 <spatial> http://lpaste.net/353451 if loops always have else. Right. In this I just want to return without doing anything in else.
03:01:35 <spatial> Just exit the function.
03:12:59 <cocreature> spatial: you might be looking for "when"
03:13:02 <cocreature> :t when
03:13:04 <lambdabot> Applicative f => Bool -> f () -> f ()
03:13:34 <cocreature> ah no, that requires that valueofnewstate has type () which it probably doesn’t
03:13:49 <cocreature> spatial: what do you want to return if result is False?
03:20:28 <spatial> cocreature: http://lpaste.net/353452 Trying to port this lisp
03:21:29 <cocreature> spatial: so does this return nil if the condition is false?
03:26:37 <spatial> It  just continues with the rest if when isn't true
03:31:52 <cocreature> spatial: but what’s the rest? there is nothing following the if clause
03:39:22 <spatial> cocreature: http://lpaste.net/353455 Lisp at the top and my Haskell at the bottom.
03:40:38 <cocreature> spatial: how about "if result then … else explore r epsilon"
03:40:41 <spatial> Incomplete because I am still figuring it out.
03:41:05 <cocreature> "return" does not return from a function if that’s what you’re expecting
03:46:53 <spatial> You mean in Lisp ?
03:47:55 <cocreature> no in Haskell
03:48:51 <cocreature> "return" is just an ordinary function of type "Monad f => a -> f a"
03:50:33 <qqwy> Hello, everyone! :-)
03:50:48 <cocreature> hello qqwy :)
03:50:48 <spatial> Could you explain ? 'return' does what ?
03:50:56 <cocreature> :t return
03:50:58 <lambdabot> Monad m => a -> m a
03:51:07 <jophish> ertes: I've not had cause to touch it for a while sadly
03:51:18 <cocreature> spatial: what it does depends on what "m" is
03:51:44 <jophish> I made it for a use case at work that didn't end up panning out. My hobby coding hasn't involved vulkan recently
03:51:49 <cocreature> spatial: in the case of m=IO, "return x" evaluates to an IO action that does nothing when executed and returns x
03:52:05 <jophish> I'd certainly like to keep the package going though
03:54:34 <qqwy> Yesterday I used the ST monad, and STUArrays for the first time. I wonder if there are ways to make this code more idiomatic (and maybe even faster?)
03:54:38 <qqwy> https://gist.github.com/Qqwy/75e5a1c4ff37f94df853e77446432cc2#file-matrixchain-hs-L49
03:55:30 <qqwy> For instance, on line 59..61 I read out multiple values from the array before using them in a calculation
03:55:41 <qqwy> maybe there is a way to do this better?
03:57:14 <spatial> cocreature: Any better Haskell way to do what Lisp does ?
03:57:39 <qqwy> Spatial: I only entered the discussion halfway through. What's the context?
03:57:52 <cocreature> spatial: as I said "if result then … else explore r epsilon" should probably work
03:58:01 <cocreature> just don’t recurse if you want to return from a function
03:58:05 <cocreature> qqwy: http://lpaste.net/353455
03:59:08 <spatial> qqyw: Was trying convert lisp to haskell http://lpaste.net/353455
03:59:41 <ski> @hoogle runSTUArray
03:59:42 <lambdabot> Data.Array.ST runSTUArray :: (forall s . ST s (STUArray s i e)) -> UArray i e
03:59:42 <lambdabot> Data.Array.ST.Safe runSTUArray :: (forall s . ST s (STUArray s i e)) -> UArray i e
04:00:56 <ski> @src print
04:00:56 <lambdabot> print x = putStrLn (show x)
04:02:14 <CoolerZ> why do i get a warning saying missing methods ? http://lpaste.net/353457
04:02:35 <erisco> CoolerZ, indent the fmap definition
04:02:41 <CoolerZ> No explicit implementation for `Prelude.fmap`
04:07:17 <CoolerZ> erisco is ask = Reader id?
04:07:23 <qqwy> ski: Would runSTUArray be better to use here?
04:07:29 <CoolerZ> it compiles
04:07:33 <ski> qqwy : more efficient
04:07:34 <erisco> :t ask
04:07:37 <lambdabot> MonadReader r m => m r
04:07:42 <qqwy> I couldn't get it to work; probably because I specified the types wrong
04:07:49 <erisco> CoolerZ, probably. I haven't used Reader
04:07:58 <qqwy> Where does the array from runSTUArray come from?
04:08:17 <ski> qqwy : it does `runST (unsafeFreeze =<< ...)', but this particular use of `unsafeFreeze' is safe
04:08:58 <ski> qqwy : `freeze' copies; `unsafeFreeze' doesn't, but requires that you feed it the last reference to the mutable array
04:09:35 <erisco> well, having it compile is a low bar. Does it actually satisfy your intent?
04:10:11 <qqwy> When I swap runST for runSTUArray, then line 54 does not type match anymore
04:10:17 <qqwy> (the second for_)
04:10:45 <ski> also replace `freeze' with `return'
04:11:12 <qqwy> Ah, that was it :-)
04:13:17 <qqwy> thank you, ski!
04:13:33 <ski> np
04:13:50 <qqwy> Are there was to make lines 59..64 more idiomatic?
04:19:03 <erisco> you can remove the redundant parens on 60 and 61
04:20:43 <ski> (and `55',`62')
04:21:13 <ski> (`42')
04:21:24 <erisco> can you turn the array into some sort of state monad? that's be interesting
04:21:48 <erisco> so that get/put are reading and writing, though you'd require indexing
04:22:49 <qqwy> Would that be faster than an unboxed mutable array?
04:23:15 <qqwy> The strange thing about this (by nature imperative) algorithm is that it uses a square matrix, but then only uses the upper triangle of it
04:23:33 <qqwy> (the main diagonal and the upper right section above it)
04:23:55 <erisco> no, it would just be an interface where you wouldn't have "writeArray memo (i,i) 0" and "readArray memo (i,j)" but instead "write (i,i) 0" and "read (i,j)"
04:24:23 * ski isn't sure it would be much gain
04:24:55 <qqwy> I have no experience with the State monad, but the indexing that it requires to find `(i,j)` in its data probably require another array.
04:25:33 <qqwy> Interestingly, the current version (when optimizing with -O3) is already twice as fast on large inputs as an C++-implementation.
04:25:57 <qqwy> But then again, when optimizing the C++-implementation using g++'s -O3, then that one is three times faster still
04:26:47 <erisco> mm, but maybe you could generalise to indexed state
04:27:23 <qqwy> What I've tried to optimize this algorithm further was to rewrite 58..64 to return a list of all possibilities and then take the minimum from that. But that was significantly slower for some reason.
04:28:54 <qqwy> Maybe there is another way to take the minimum that does not require to read the `curval' during each iteration.
04:29:10 <erisco> probably more useful with dependent typing so that you can project values of various types from the state
04:31:40 <erisco> so there is a function  project_t : I -> Type  and  project_v : (i : I) -> S -> project_t i
04:33:03 <erisco> so you might get somewhere with singletons but the practicality goes down
04:33:44 * qqwy nods
04:38:58 <ezyang> Look at this beautiful table!! https://github.com/haskell-backpack/backpack-str 
04:39:51 <erisco> it is nice, but it would be improved by repeating the header every nth row. otherwise you have to scroll back to the top to recall what the columns means
04:42:27 <Rembane> ezyang: It's a beauty!
04:44:49 <ezyang> erisco: Oh all right :) 
04:45:16 <ezyang> blah I wish haskell-src-exts knew how to parse comments. Or maybe it does? 
04:46:41 <ezyang> oh it does 
04:52:31 <Newb> Hi, i got custom Data 'class', how to define order by multiple keys ? http://lpaste.net/7429912621689602048 firstly i want it to be sorted by 'from', afterwards by 'symbol'
04:53:23 <erisco> :t thenCmo -- Newb
04:53:26 <lambdabot> error: Variable not in scope: thenCmo
04:53:28 <erisco> :t thenCmp -- Newb
04:53:30 <lambdabot> error: Variable not in scope: thenCmp
04:53:50 <erisco> mkay, well, there is a function like this around somewhere
04:53:57 <erisco> Ordering -> Ordering -> Ordering
04:54:24 <erisco> http://hackage.haskell.org/package/template-haskell-2.11.1.0/docs/src/Language.Haskell.TH.Syntax.html#thenCmp
04:57:09 <erisco> well hang on, your Eq also includes t1 == t2 Newb
04:57:27 <erisco> if x == y then it has to be that compare x y == Eq
04:57:37 <erisco> and vice versa
04:58:30 <Newb> i already got thenCmp, thanks, but i dont know what u mean with Eq
04:59:05 <erisco> == considers all three components, but compare is only considering two, this is incoherent
04:59:16 <erisco> because it means that the property I stated above does not hold
04:59:42 <Newb> so in fact my instance Eq is redundant
04:59:51 <erisco> no, it is wrong, or Ord is wrong
05:01:26 <MoronMan> @help
05:01:27 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:01:47 <Newb> i am confused now, i just want to be sorted it liek this [T(1,a,2), T(1,b,2), T(2,a,5), T(2,b,4)]
05:02:21 <Newb> State and Symbosl are only aliases type State = String type Symbol = Char
05:02:29 <erisco> this has to be true Newb, forall x :: Transition, y :: Transition, (x == y) == (compare x y == Eq)
05:02:51 <erisco> but with how you have written it there are some x y where compare x y == Eq but not x == y
05:03:38 <Newb> well so how to achieve it, instead of `==` i should use `compare` ?
05:03:53 <erisco> paste what you have now
05:04:31 <Newb> erisco http://lpaste.net/7429912621689602048
05:05:54 <erisco> okay, so lets say you have  r = Transition "a" 'x' "b"  and   s = Transition "a" 'x' "c"
05:06:00 <erisco> what is r == s?
05:06:23 <Newb> it should be False
05:06:36 <erisco> correct, and what is compare r s?
05:07:32 <Newb> idk, propably False when u are asking :D
05:07:39 <erisco> :t compare
05:07:42 <lambdabot> Ord a => a -> a -> Ordering
05:07:45 <erisco> :t False
05:07:48 <lambdabot> Bool
05:07:53 <Newb> ah
05:08:28 <erisco> so what is compare r s?
05:09:20 <Newb> LT ?
05:09:27 <erisco> explain
05:10:05 <Newb> from and symbol are same but 'to' is not the same, and 'b' is LT 'c'
05:10:23 <erisco> be more mechanical about it. What is the definition of compare?
05:12:04 <Newb> well it it just returns LT if 'r' is less than 's', EQ if they are equal etc .. no ? or what do u mean
05:12:20 <erisco> you just wrote it
05:12:31 <erisco> (Transition f1 s1 t1) `compare` (Transition f2 s2 t2) = (f1 `compare` f2) `thenCmp` (s1 `compare` s2 )
05:12:47 <erisco> so what is f1, s1, t1, f2, s2, t2
05:13:37 <Newb> so i should add thenCmp also on t1, t2 ?
05:14:26 <erisco> for it to work with your definition of ==, yes
05:15:35 <Newb> ok thank you
05:16:21 <eugenez> Friends, i'm using stack ghci, it fails to import Data.Set with the following Could not find module ‘Data.Set’ It is a member of the hidden package ‘containers-0.5.7.1@containers-0.5.7.1’. What do I do?
05:16:48 <erisco> if this was equality and hash codes it'd be fine, but this isn't that
05:17:53 <erisco> it is also valid to remove t1 == t2 from your == definition, but know what you're doing if you do this
05:18:44 <erisco> because then x == y no longer implies they are structurally identical
05:19:08 <erisco> and structural equality is the assumed default (it is what you get with deriving Eq)
05:19:52 <erisco> and so when you go on to implement other classes you have to be clear about what equality you're using
05:20:09 <erisco> otherwise the laws are meaningless
05:26:50 <lyxia> eugenez: add containers to the dependencies of your package
05:27:01 <bennofs> what rank does the type 'forall b c. ((forall a. a -> a) -> b) -> c' have?
05:27:27 <erisco> n ;)
05:28:23 <erisco> if once to the left of -> is rank 2 then I guess that is rank 3, but I don't know
05:30:21 <eugenez> Thank you very much, it worked! :)
05:37:56 <CoolerZ> whats pure here? http://lpaste.net/353458
05:38:45 <erisco> you have  x :: a  and need something of type  r -> a
05:39:42 <erisco> so, you need a function, that is known because the type is ->
05:39:47 <erisco> and you have to return something of type a
05:39:57 <erisco> well, we have x :: a, so we can return that
05:40:16 <erisco> so what function can take something of type r (i.e. anything) and return x?
05:40:30 <grayhatter> IO ((), Data) -> IO (), Data ??
05:40:54 <erisco> what oO
05:41:27 <grayhatter> cmdline.org/err.png
05:42:03 <erisco> :t void -- grayhatter
05:42:06 <lambdabot> Functor f => f a -> f ()
05:43:15 <erisco> or if you are in do-notation you may write return ()
05:43:32 <erisco> or $> () may be convenient
05:44:54 <grayhatter> https://gist.github.com/13824fd7054b532151b4d9b8a36c6485
05:45:36 <erisco> CoolerZ, solve it?
05:46:28 <CoolerZ> erisco: i was gone
05:46:29 <CoolerZ> back
05:47:57 <CoolerZ> erisco: const x?
05:48:04 <erisco> looks good
05:50:35 <erisco> you could write  pure = fmap Reader pure
05:52:41 <erisco> though  pure a = Reader (pure a)   I think is more sensible
05:53:38 <erisco> particularly with newtypes we often have an underlying Applicative when we implement our newtype Applicative
05:53:45 <erisco> (and similarly for Functor, Monad, and other classes)
05:54:12 <erisco> fmap f (Reader x) = Reader (fmap f x)
05:54:19 <erisco> pure a = Reader (pure a)
05:54:48 <erisco> (->) is a Functor, Applicative, Monad, and so we can directly use these definitions
05:55:43 <erisco> with GeneralizedNewtypeDeriving we can even have these written for us
05:57:17 <erisco> I should say (->)a are those things, before someone writes me a kind fine
05:57:47 <CoolerZ> erisco: wait what?
05:58:05 <CoolerZ> why is pure recursive?
05:59:25 <CoolerZ> erisco: pure x = Reader const x right?
06:00:01 <Taneb> CoolerZ, it's sneakily not quite recursive
06:00:18 <Taneb> pure for Reader is being defined in terms of pure for (->) e
06:01:12 <CoolerZ> oh
06:04:40 <Taneb> CoolerZ, your definition is equivalent and possibly less confusing (although has a slight mistake)
06:06:33 <CoolerZ> Taneb: what mistake?
06:10:41 <Taneb> CoolerZ, should be pure x = Reader (const x)
06:11:02 <CoolerZ> oh
06:13:35 <CounterPillow> if monads are so good how come they live in tents
06:25:45 <erisco> CoolerZ, remember that functions such as pure are overloaded, so one site of pure is not necessarily the same as another, it depends on the type
06:26:14 <CoolerZ> erisco: yeah i got that
06:27:45 <erisco> once that is understood there should not be anything confusing about it, because it is typical to use the existing implementation for the type we are newtyping
06:28:25 <SudhanshuJ> I was playing and trying to make my own version of tic tac toe game from Graham Hutton's Haskell book. 
06:28:27 <SudhanshuJ> I am however having trouble trying to implement a simpler version of printing the tic tac toe grid. I would like to implement it using a single function or using an easier to understand function. 
06:28:28 <SudhanshuJ> The relevant sections of the code is posted on http://lpaste.net/353460
06:29:53 <erisco> what is wrong with line 9? seems short to me
06:31:01 <CoolerZ> whats the use case for the applicative instance of functions?
06:31:07 <CoolerZ>     (Reader rab) <*> (Reader ra) = Reader $ \r -> (rab r) (ra r)
06:31:07 <erisco> if you do not understand function composition then the better path is to learn function composition, because it is ubiquitous
06:31:20 <CoolerZ> seems very arbitrary to me
06:31:38 <sm> SudhanshuJ: it looks pretty reasonable already. You can move the helpers into a where clause in putPaygrid if you want
06:32:01 <erisco> CoolerZ, well, in one sense that is just how it has to be because that is what Applicative requires
06:32:08 <sm> SudhanshuJ: the use of foldr1 seems a little surprising perhaps
06:32:26 <erisco> CoolerZ, but if you want to understand some uses for it, read about the SK combinators
06:32:53 <CoolerZ> SK?
06:33:06 <eugenez> Friends, I'm trying to work with Cartesian product of 3 lists and for some reason beautiful comprehension [(x,y,z) | x <- xs, y <- ys, z <- zs] is several orders slower than weird (,,) <$> xs <*> ys <*> zs , why is that, my friends?
06:33:49 <erisco> CoolerZ, from Lambda Calculus. S = pure = const, K = (<*>) = \f g x -> f x (g x)
06:34:15 <erisco> using S and K you can write any function (as far as Lambda Calculus defines functions)
06:35:09 <SudhanshuJ> <erisco>  i forgot to remove the extra space
06:35:28 <erisco> also, the Applicative idiom is  f <$> a <*> b <*> c ... which is like "programmable application" in the way monads are "programmable semicolons"
06:35:39 <erisco> so it is like  f a b c  but you get to say what $ is
06:35:55 <erisco> see http://stackoverflow.com/a/34536499/260584 for how you can use that idiom with (->)a
06:38:58 <eugenez> Thanks, i'm still working my way towards understanding monads, it just surprised me why comprehension would be so slow and this solution so fast
06:39:42 <sm> SudhanshuJ: a cheap alternative would be putPlaygrid = mapM_ print
06:40:00 <SudhanshuJ> sm: Can you explain why foldr1 was used ?
06:40:01 <Lempr> Hi, anyone who could help me with algorithm to make "equality split class", idk how to describe it, here is sample http://lpaste.net/4041273696768229376
06:40:02 <erisco> eugenez, how did you measure this?
06:40:41 <sm> nope
06:40:53 <eugenez> codewars mostly, but when i just outright print it in ghci, you can see the second solution prints combinations waaay faster
06:41:22 <sm> Sudanshu: or, cleaner output: putPlaygrid = mapM_ (putStrLn . intercalate " " . map show)
06:41:26 <lyxia> Lempr: groupBy only groups consecutive elements
06:42:03 <lyxia> Lempr: you will need to write your own function that groups related elements in the whole list
06:42:09 <Lempr> yeah thats the problem :/ is there any simple solution how to achieve to group 'all' elements ?
06:44:03 <lyxia> nubBy might do it.
06:44:28 <lyxia> If your input is assumed to represent an equivalence relation.
06:45:36 <Lempr> yeah is equivalence relation, but how do u mean it ?
06:46:42 <lyxia> nubBy (\x y -> (x, y) `elem` relation) states
06:47:39 <CoolerZ> erisco: what is maybeIf/
06:47:40 <CoolerZ> ?
06:48:11 <CoolerZ> maybeIf = liftA3 truth <*> pure Just <*> pure (pure Nothing)
06:48:32 <Lempr> lyzia it just returns ["1","2","3"] which, but now i dont that "1" is old ["1","6"] etc ..
06:48:42 <erisco> CoolerZ, that was part of the question
06:49:01 <CoolerZ> this is really confusing using lift with <*>
06:49:02 <erisco> you can see it as an example but what I really wanted to show was the "some intuitions" part
06:49:14 <CoolerZ> usually you don't need <*> when using lift
06:49:25 <erisco> well, it needn't be, look at what I write below :)
06:49:47 <lyxia> lambdabot: what?
06:49:52 <lyxia> Lempr: what?
06:50:28 <Lempr> well output is ["1","2","3"] i need [["1","6"],["3","4"],["5,"6"]]
06:51:18 <erisco> eugenez, I am not sure. As far as I know they should be the same
06:51:36 <lyxia> Lempr: Oh I see nubBy doesn't work because it just discards "equal" elements
06:52:05 <lyxia> Lempr: you'll have to write the function
06:53:10 <Lempr> ah okay, it's part of school project, some former schoolmate solved id by using groupBy and sortBy but i dont know how to sort it.. anyway thanks
06:53:26 <CoolerZ> doesn't lift f ma mb = f <$> ma <*> mb ?
06:53:47 <CoolerZ> so why are you using lift AND <$> and <*>
06:53:48 <CoolerZ> ?
06:54:03 <erisco> you mean liftA2?
06:54:07 <CoolerZ> yes
06:54:42 <erisco> that is correct, but look at the expression
06:54:58 <erisco> would that be a natural way to rewrite it?
06:55:14 <Lempr> lyxia: I found this http://stackoverflow.com/questions/8262179/group-list-by-equivalence-relation but i am not able to rewrite it for my purpose
06:55:15 <eugenez> erisco: thank you
06:55:53 <erisco> why would you want to write  \ma mb -> f <$> ma <*> mb  when you can just write  liftA2 f?
06:56:31 <erisco> maybe the precedence is confusing you
06:56:48 <erisco> liftA2 f <$> x <*> y  is   (liftA2 f) <$> x <*> y
06:57:20 <CoolerZ> ik
06:57:44 <erisco> well, are you suggesting I write  (\a b -> f <$> a <*> b) <$> x <*> y  instead?
06:57:47 <CoolerZ> why are you using fmap and apply/
06:57:55 <lyxia> Lempr: "If you can define a compatible ordering relation,"
06:57:58 <lyxia> Lempr: can you
06:58:40 <erisco> by "apply" do you mean <*> ?
06:58:44 <CoolerZ> yes
06:58:59 <Lempr> Me personally not :D
06:59:02 <CoolerZ> your lifting the function once with lifta2 and then again with <*>
06:59:06 <erisco> I don't really understand the nature of your question
06:59:28 <CoolerZ> why are you lifting twice?
07:00:02 <erisco> <*> is not the same as the liftAn functions
07:00:15 <erisco> you know this though, so I don't understand the question
07:00:21 <lyxia> Lempr: as far as I can see you only have an equivalence relation, and no ordering, so you can't use that
07:00:47 <erisco> if you proposed the way you'd want to see it maybe I'd understand
07:01:11 <CoolerZ> what is pure Just?
07:01:22 <erisco> :t pure Just
07:01:29 <lambdabot> Applicative f => f (a -> Maybe a)
07:01:29 <CoolerZ> which pure?
07:01:34 <erisco> any of them
07:01:55 <erisco> in this case it is const
07:02:34 <erisco> you can see the full derivation at the end
07:02:51 <CoolerZ> its the pure for functions?
07:03:00 <erisco> yes, pure for functions is const
07:04:06 <CoolerZ> = liftA3 truth <$> id <*> pure Just <*> pure (pure Nothing)
07:04:14 <CoolerZ> where did the <$> id come from?
07:06:26 <erisco> you are asking why is  liftA3 truth = liftA3 truth <$> id
07:06:28 <CoolerZ> is it just me or this really convoluted?
07:06:41 <CoolerZ> is*
07:07:13 <CoolerZ> yes where did the <$> id come from
07:07:26 <erisco> finding pointfree definitions can lead you down strange roads, and in this particular case it is not so practical, but that wasn't the question
07:08:00 <erisco> the reasoning behind the presented solution is simple. it is just two equations
07:08:25 <CoolerZ> i guess <$> is just (.) so     . id makes sense
07:08:42 <erisco> yes, there you are CoolerZ :)
07:08:54 <erisco> id is an identity of (.)
07:09:18 <erisco> this expansion was used so that it would match the idiom which is how I presented the equations
07:12:04 <erisco> a loose way to think about it is that each lift adds an argument
07:13:32 <erisco> we start with one argument inherent from the idiom, and then add a second with liftA3
07:13:50 <erisco> liftA3 liftA3 f  would be three arguments, and so on
07:14:27 <erisco> er, maybe that  liftA3 (liftA3 f)
07:14:30 <erisco> make that*
07:14:40 <CoolerZ> do you have a simpler use case?
07:14:51 <CoolerZ> for applicative instance of functions
07:15:22 <lyxia> eugenez: http://lpaste.net/353461 In this benchmark the applicative style is faster when interpreted, slower when compiled without optimizations, the same with optimizations.
07:15:49 <erisco> well you can rewrite many functions like this, so if you have a candidate I'll show you how
07:16:29 <erisco> but practically I do not use this. sometimes the f x (g x) pattern will come up and I'll stick <*> in there
07:17:12 <erisco> or the  f (g x) (h x)  pattern will come up and I'll stick in liftA2
07:17:16 <michalrus> Quick/newbie question: how can I have a separate function with the same name as a record field, both defined within the same scope? It seems that DuplicateRecordFields enable only… duplicate record fields. If that regular function was of different type than the record field, then it would still be unambiguous, right?
07:17:57 <erisco> but I am not going out of my way to write everything like this. It is just part of the bag of tricks to abbreviate definitions
07:18:31 <CoolerZ> so   \x -> f x (g x) = f <*> g ?
07:18:48 <erisco> yes
07:20:32 <erisco> sometimes it is just a bit of fun to find pointfree expressions
07:20:34 <eugenez> lyxia: I think I figured it out, I actually had it like this: [(x,y,z)| x <- someFunc, y <- someFunc, z <- someFunc], once I moved xs ys and zs out with where it started working way faster
07:20:56 <erisco> and if you have some tricks like this you can often come up with something more understandable than @pl
07:21:06 <lyxia> eugenez: that changes everything indeed
07:21:43 <erisco> @pl \p -> \a -> truth (p a) (Just a) Nothing
07:21:44 <lambdabot> flip flip Nothing . (`ap` Just) . (truth .)
07:22:09 <erisco> sure, it is equivalent, but what is the intuition
07:23:35 <lyxia> michalrus: yes you could disambiguate by types, that's what type classes are for.
07:24:49 <lyxia> eugenez: when talking about performance it is important to show your code and how you are measuring it.
07:26:18 <erisco> someFunc has to be a list, not a function, but I presume you meant it is an expression containing application
07:26:33 <michalrus> *nods* Yes, I know that. =) lyxia, what caused my question was working with some REST API that returns an `error` field… And also there’s `Prelude.error`… If DuplicateRecordFields also allowed regular function names to be duplicates with record field names, it could’ve been easier in this case. =)
07:27:25 <erisco> it is likely that ys was re-evaluated for every x and zs for every y
07:29:10 <erisco> it is an optimisation to abstract an invariant expression, and GHC does not always do this, though I do not know the specifics
07:29:55 <erisco> if you compiled with -O or -O2 you may have seen the performance difference vanish
07:30:07 <erisco> versus the REPL which, afaik, does no optimisation
07:36:34 * erisco looks up "preorder" and sees video games, ugh
07:39:05 <lyxia> michalrus: I see. Ad-hoc overloading of duplicate names might be yucky but useful.
07:50:10 * ski . o O ( <https://ncatlab.org/nlab/show/preorder> )
07:50:48 <xa0> hello
07:50:54 <xa0> does anyone here understand cofree
07:51:11 <xa0> i'd like to create an example of it's use, without using free and/or pairing
07:51:18 <xa0> is that possible
07:51:33 <spatial_> How do I use 'do' in a case statement ? http://lpaste.net/353465
07:52:04 <spatial_> To compare the unwrapped value with another.
07:52:10 <erisco> you mean in the guard?
07:52:18 <kuribas> spatial_: I see no case?
07:53:39 <lyxia> xa0: type Tree = Cofree []
07:53:48 <spatial_> Yes in the guard.
07:53:53 <lyxia> xa0: What do you mean by "pairing
07:53:56 <erisco> you cannot
07:54:21 <xa0> lyxia: every example i've seen of cofree eventually uses a "pairing" functor to pair it with a free monad
07:54:38 <xa0> i've constructed a cofree but i've no idea how to use it without that
07:54:57 <erisco> the guard is constructed from a Bool expression and pattern matches
07:55:14 <erisco> so you can have do notation in the expression, but the result must be a Bool
07:56:01 <spatial_> I have a comparison that returns a Bool.
07:57:39 <tomboy64> hmm. pretty newbie question. how would i go about constructing a cli-parser? e.g. a program that reads (a variable number of) lines, until it's completed its tasks?
07:58:42 <lyxia> xa0: what about my list example
07:58:56 <tomboy64> just using await/yield or getLine/putStrLn wouldn't work as the number of lines need to be variable and i might have to accumulate data from stdin.
07:59:08 <xa0> lyxia: okay you have the cofree, now what do you do with it
08:00:00 <xa0> this is where i get stuck, i can make the cofree happily, but what do you do to "run" it or use it somehow
08:01:26 <erisco> spatial_, readthevalue returns a Bool?
08:10:24 <lyxia> xa0: the unfold functions are convenient to generate trees, and then you can search/fold/traverse them using recursion-schemes.
08:10:58 <CoolerZ> erisco: why is it called Reader?
08:11:16 <xa0> lyxia: that sounds like just a Tree thing, not a Cofree thing, though
08:11:31 <erisco> there are three types: Reader, Writer, and State
08:11:42 <erisco> State = Reader + Writer
08:11:52 <xa0> lyxia: i'm reading this for example http://dlaing.org/cofun/posts/free_and_cofree.html
08:11:55 <erisco> Reader lets you read a state, Writer lets you write a state
08:12:02 <erisco> and so State lets you do both
08:13:23 <erisco> a lot of the time you will be using classes instead of Reader, but in the cases where a class is inappropriate or impossible (such as data that only arrives at runtime) then Reader is available
08:14:24 <erisco> the connection is that instead of a class you can pass around a dictionary of its methods
08:14:32 <erisco> and Reader facilities this
08:15:10 <erisco> a common use for Reader is configuration read from a file
08:17:50 <spatial_> erisco: It is supposed to be like this http://lpaste.net/353467
08:18:45 <erisco> I am not sure what that is supposed to be
08:19:03 <erisco> what is the type of thethevalue?
08:19:47 <erisco> readthevalue*
08:19:48 <spatial_> Int. Unwrapping in the guard.
08:20:00 <erisco> it is not Int
08:20:26 <erisco> it is A -> B -> Int maybe, and so what is A and B?
08:21:37 <spatial_> readthevalue works separately. It takes an IOArray etc.
08:21:52 <anieuwland> Hi everyone :) I have a question about how I detect connected hardware (phones, ereaders) to a Linux computer in Haskell
08:22:03 <erisco> well, let me know when you figure out the type
08:22:18 <spatial_> I have a problem with the unwrapping in 'do' in the guard
08:22:30 <anieuwland> I'm not sure how I would go about doing this. Is there a specific library for, or should I work with typical linux files likes /proc/mounts?
08:22:45 <anieuwland> I would appreciate any tips,thanks! 
08:23:39 <spatial_> Ok. It is a rough cut. But readthevalueis readthevalue :: ( IOArray Int Double) -> Int -> IO Double
08:25:08 <erisco> :t (<)
08:25:10 <lambdabot> Ord a => a -> a -> Bool
08:25:32 <erisco> so best-value has to have the type IO Double
08:25:44 <erisco> but < is not defined for IO Double
08:26:55 <erisco> what you want to start with is   do x <- readthevalue ...;
08:27:13 <erisco> now x :: Double, and it is the Double you have read from the array
08:27:21 <erisco> (I presume, I am guessing as to what readthevalue does here)
08:27:24 <spatial_> Yes. I need to unwrap it first.
08:27:36 <erisco> no, there is no such thing with IO
08:27:57 <erisco> i.e. there is no function with type IO a -> a
08:28:37 <spatial_> I am able to do this http://lpaste.net/353468
08:28:53 <erisco> what you use is bind, i.e. >>=, which in do-notation is <- loosely speaking
08:28:55 <geekosaur> you need to learn how IO works, not try to evade it
08:29:47 <erisco> yes, that's right, so if you follow similarly as you've done with terminalstatep you can solve this
08:30:18 <spatial_> Right. Let me change that and ask again.
08:30:29 <erisco> so you begin with   do x <- readthevalue ...;  and then you can do things with the x
08:30:45 <erisco> if best_value < x then ... else if best_value > x then ... else ...
08:31:22 <erisco> or, in a better fashion,  case compare best_value x of LT -> ...; GT -> ...; EQ -> ...;
08:31:53 <erisco> in the end you don't really need a guard
08:35:24 <spatial_> erisco: That is legal haskell. Exactly like you typed ?
08:36:34 <erisco> if you replace the ellipses with something, yes
08:36:42 <kuribas> Is it possible to have data allocated on the stack?
08:37:01 <hpc> kuribas: ghc uses the stack and heap in a wildly different way than C
08:37:11 <hpc> so that question doesn't really make much sense
08:37:40 <kuribas> does ghc still garbage collect data when it is consumed immediately?
08:38:08 <hpc> depends
08:38:37 <kuribas> I'd like to avoid the cost of GC for critical code...
08:39:25 <hpc> what i would do then is write the critical code, and then if it does not perform adequately profile it
08:41:20 <geekosaur> nursery gc is very fast, you probably care about gen1 gc more
08:42:05 <erisco> the imagery of calling it the nursery is unpleasant
08:42:25 <hpc> plus ghc can occasionally optimize repeated allocation into a single allocation and many mutations
08:43:25 <hpc> erisco: computer science already has the concept of slaves and killing children, the nursery is downright harmless ;)
08:43:39 * geekosaur has had the joy of changing the diaper of a baby with projectile diarrhea. "nursery" is reasonably apropos :p
08:44:39 <kuribas> I improved performance 8X by avoiding thunks...
08:45:05 <kuribas> it's still expensive for critical code
08:47:55 <erisco> hpc, I am harrowed
08:48:18 <kuribas> why doesn't ghc compile minimum[a, b, c] into min a (min b c)?
08:50:00 <erisco> because it is less computational work
08:50:05 <erisco> oh, why *doesn't* it
08:50:11 <erisco> well because that rewrite rule is not present :P
08:50:14 <kuribas> erisco: yeah :)
08:50:35 <erisco> minimum (x:xs) => min a (minimum xs)
08:50:38 <nshepperd_> Because that involves inlining a recursive function, i bet
08:50:42 <erisco> min x (minimum xs)
08:50:54 <kuribas> erisco: well foldl f [a, b, c] in general
08:51:14 <erisco> how is a three-item list general?
08:51:32 <kuribas> erisco: well, a small list
08:51:46 <erisco> what is f?
08:51:58 <kuribas> it could partially evaluate the expression.
08:52:18 <erisco> oh, you mean minimum is defined in terms of foldl
08:52:24 <erisco> well probably foldl' but sure
08:52:25 <kuribas> if the list is known at compile time.
08:53:56 <erisco> the compiler can unroll (if that is an appropriate word here) but that is a trade-off
08:54:22 <kuribas> Are there rules for when it does?
08:55:04 <erisco> trading jumps for more instructions is a balancing act, and I don't know about the runtime either
08:56:00 <erisco> I know I have read in another case a rewrite rule was omitted because it was too likely to produce large expressions which would probably be slower
08:57:10 <spatial_> http://lpaste.net/353469 I have this now.
08:58:10 <spatial_> http://lpaste.net/353469 I have this now. Just variable scope problems.
08:58:20 <erisco> you have to load instructions into memory too, remember
08:59:30 <erisco> > let x-x = 1 in x-x
08:59:34 <lambdabot>  error:
08:59:34 <lambdabot>      • Conflicting definitions for ‘x’
08:59:34 <lambdabot>        Bound at: <interactive>:1:5
08:59:47 <erisco> I don't think hyphens are valid in identifiers
09:01:35 <nshepperd_> That line is defining subtraction
09:01:50 <geekosaur> ...but violating the linear pattern rule
09:02:38 <nshepperd_> Heh, so it is
09:02:44 <erisco> well I am surprised spatial_'s code hasn't exploded in these errors and instead has scope errors
09:03:08 <kuribas> It hasn't deleted the internet yet?
09:03:45 <erisco> I just answer questions. What people's programs do is their business :P
09:03:57 <geekosaur> it probably does report those but they scrolled off and spatial_ only looked at the later errors where the names are indeed not in scope
09:04:37 <nshepperd_> The code has lots of type errors but ghc won't report those until all the undefined names are fixed
09:05:28 <kuribas> erisco: sure, but c compilers unroll loops also.
09:06:20 <erisco> I think if you looked at how the runtime works it'd be a substantially different circumstance, but that is my speculation
09:07:35 <kuribas> I think it's more about a lack of manpower behind haskell compilers.
09:07:56 <kuribas> not that the men lack power, but there aren't enough of them...
09:08:13 <nshepperd_> Ghc could unroll folds i think. Just has to inline the fold and cancel the inlining if the result is much bigger
09:08:44 <spatial_> Maybe my haskell layer is spacemacs isn't setup properly.
09:08:46 <kuribas> yeah
09:08:51 <Tuplanolla> I think it's a general lack of manpower in compiler development, kuribas.
09:09:11 <erisco> I'm sure they'd tell you kuribas: "pull requests welcomed!"
09:09:12 <Tuplanolla> We don't even have proper link-time optimization for C compilers yet.
09:09:17 <kuribas> Tuplanolla: C++ and java have plenty...
09:09:35 <nshepperd_> spatial_: anyway, you can't use - in variable names
09:09:42 <Tuplanolla> Considering their importance, not as much as they should.
09:10:16 <kuribas> But ghc is all volunteer work?
09:10:20 <erisco> spatial_, what language are you coming from? just curious
09:11:25 <geekosaur> yes, ghc is all volunteer and chronically in need of devs
09:11:49 <geekosaur> also care needs to be taken with things like loop unrolling if it can alter strictness
09:12:09 <exio4> erisco: minimum (x:xs) = min x (minimum xs) doesn't hold
09:12:23 <exio4> > minimum []
09:12:26 <lambdabot>  *Exception: Prelude.minimum: empty list
09:12:52 <erisco> oh, one of them partial functions, well don't blame me :P
09:12:52 <exio4> minimum [1] = minimum (1:[]) = min 1 (minimum []) = ⊥
09:12:58 <exio4> > minimum [1]
09:13:02 <lambdabot>  1
09:13:38 <erisco> minimum (a:b:cs) = min a (minimum (b:cs))  then, but I'd rather fix minimum than worry about this optimisation
09:14:01 <exio4> erisco: it should be minimum (x0:x1:xs) = min x0 (minimum (x1:xs)) ∧ minimum (x0:[]) = x0 
09:14:07 <exio4> erisco: fix? 
09:14:49 <erisco> yes, make it total
09:15:08 <exio4> erisco: replacing [] with NonEmptyList? 
09:15:21 <exio4> erisco: or adding a Bounded restriction to the type?
09:17:07 <erisco> well, I am not sure that minBound makes much sense
09:17:09 <kuribas> exio4: that's not problem for partial evaluation
09:17:32 <exio4> kuribas: what do you mean? 
09:17:47 <exio4> kuribas: oh, this is about evaluating an arbitrary function? not the specific rules?
09:18:16 <kuribas> exio4: about ghc unrolling functions on known lists.
09:19:14 <kuribas> exio4: for example minimum [a, b, c] => min a (min b c)
09:19:40 <Tuplanolla> There's a school of thought for evaluating everything that doesn't depend on run-time values at compile-time, kuribas.
09:20:02 <exio4> there has been a POC compiler for "supercompilation"
09:20:08 <erisco> that's a school of thought?
09:20:23 <exio4> it took quite a few minutes, IIRC :P
09:20:29 <erisco> piece of crap?
09:20:40 <exio4> proof of concept
09:22:44 <erisco> does it run to a fixed point exio4?
09:23:16 <exio4> erisco: I don't remember, I barely skimmed through it 
09:23:26 <erisco> without knowing much, it doesn't sound that interesting
09:23:29 <spatial_> let x = 0 in x followed by let y = 0 in y That has a parse error at 'let'
09:23:58 <erisco> if you have some optimisations then of course you can apply them iteratively
09:24:49 <exio4> erisco: IIRC the "biggest part" of the paper was about recursive functions, knowing when to stop, and how to handle partial application and high order functions
09:25:36 <kuribas> it's increases compile time, but that could be a command line option...
09:25:44 <rmrfroot> getting a very unhelpful "dist/build/Backuper_o_split: getDirectoryContents" when preprocessing a library using GHC 8.0.1, anyone that has had something similar happen to them?
09:26:53 <geekosaur> spatial_, if you are in a do block then you can use let that way, otherwise it is let <bindings> in <expr>
09:27:06 <geekosaur> and note that outside do blocks you do not have "statements"
09:27:26 <geekosaur> (technically you don't inside them either but you can pretend. you can't pretend elsewhere)
09:27:36 <geekosaur> @paste your actual code also
09:27:37 <lambdabot> Haskell pastebin: http://lpaste.net/
09:27:49 <erisco> maybe I am misremembering... there was a supposed technique where you run an optimising compiler on the output of an optimising compiler and so on
09:28:04 <erisco> so your target and source languages have to be the same if you want to do it iteratively, but that was an idea
09:28:16 <erisco> then another was to run an optimiser on the compiler itself
09:28:29 <erisco> the idea being that the optimised compiler can produce more optimal code (by some magic?)
09:28:52 <geekosaur> only if they have disjoint optimizations or you're assuming the peephole optimization technique is actually useful
09:28:53 <erisco> and if the compiler can compile itself, now you just keep going until you you're content with your level of optimisation
09:29:21 <geekosaur> or both compilers' authors were too lazy to optimize in multiple passes
09:29:33 <exio4> erisco: multiple passes are actually that, just inside a compiler
09:29:43 <exio4> erisco: the thing is, how many times do you run the optimizations?
09:29:54 <exio4> erisco: they're also one of the most expensive parts of most compilers nowadays
09:30:10 <exio4> erisco: and you want modular support too.. it's a tough problem :)
09:31:33 <erisco> yes well for the iterative approach you'd have to limit your depth or guarantee convergence
09:33:25 <erisco> I want to see more examples of evolved code
09:33:43 <erisco> like they designed that logic gate some years ago
09:35:09 <erisco> so when you ship your final version you have a super computer take a crack at it for a good while
09:35:29 <rmrfroot> disabling split-objs solved my problem. 
09:36:31 <erisco> I think you're chiefly worried about knowing whether a program fits the spec
09:36:41 <erisco> or how to measure how closely it fits
09:37:26 <erisco> has anyone given serious consideration to measuring how close an implementation fits a spec? we clearly do it when we program
09:37:48 <erisco> that's how we figure out to change this bit over here rather than that bit over there
09:44:42 <juri_> ouch. hlint is not installable. my machine cannot find the right version of 'happy'.
09:48:00 <rom1504> try 'sad'
09:51:05 <osa1> juri_: install happy in a sandbox. add sandbox's bin to $PATH. build hlint.
09:53:08 <juri_> weird.
09:53:42 <osa1> I'm assuming you don't want to just install it system-wide otherwise you'd just do it
09:53:49 <osa1> `cabal install happy`
09:53:56 <osa1> or `stack install happy`
09:54:41 <juri_> strange. installing happy first seems to have worked.
09:54:59 <osa1> why is it strange? what did you expect?
09:55:28 <juri_> i expected for it to download and build it, rather than just erroring out.
09:56:24 <osa1> not sure what's the error message is but I don't think hlint directly depends on happy. it's probably a problem with a dependency.
09:56:30 <osa1> there's a cabal field `build-tools` for that
09:56:49 <osa1> so you add preprocessors to that field and it's supposed to work
09:56:56 <osa1> haven't tried it myself though so not sure if there's a bug
09:58:26 <osa1> juri_: example https://github.com/haskell-suite/haskell-src-exts/blob/master/haskell-src-exts.cabal#L45
09:59:21 <geekosaur> some people do seem to assume that happy is always installed and they don't need to list the dependency as a build tool
10:03:39 <maerwald_> geekosaur: isn't that still broken wrt PATH? 
10:04:19 <geekosaur> depends
10:04:45 <geekosaur> with stack, or cabal-install to user (not sandbox) with ~/.cabal/bin already in $PATH, it should work
10:04:57 <geekosaur> isntall to sandbox and use elsewhere is problematic
10:05:27 <thadtheman> Is there a generic fp channel?
10:05:59 <maerwald_> .cabal/bin can't be expected to be in PATH so it's broken
10:07:12 <hodapp> thadtheman: on freenode, I'm not aware of one; there is, however, a functional programming Slack
10:08:12 <geekosaur> maerwald_, in the same way building a binding with only runtime libs installed and not automatically running your package manager to fix it is "broken"
10:08:20 <geekosaur> they're build tools, not nannies
10:09:00 <maerwald_> no. those are different problems
10:10:25 <thadtheman> Well I'll try here. Even though it has been a while.
10:10:31 <_sras_> If I have two records of types A and B and B have a (subset of fields from A + fields that are functions of fields from A). Is there any way to make the conversions between these types easy?
10:10:33 <maerwald_> system libs are not managed by cabal. build tools like happy are, yet it is unable to register them for internal cabal processes
10:10:50 <thadtheman> Given a monad, with return, and bind. How do I make join and fmap?
10:11:13 <maerwald_> that's simply broken. sandbox or not
10:11:59 <hpc> happy isn't a build tool
10:12:20 <maerwald_> nitpicking incomong
10:12:56 <hpc> i think you misunderstand what exactly a build tool is
10:13:10 <hpc> and what its responsibilities are
10:13:21 <srhb> We should have a shared calendar so we can cross off each day this discussion recurs. Perhaps there's a pattern. :-)
10:14:39 <c_wraith> :t (>>= id) -- thadtheman 
10:14:42 <lambdabot> Monad m => m (m b) -> m b
10:15:30 <c_wraith> :t \f x -> x >>= return . f -- thadtheman 
10:15:33 <lambdabot> Monad m => (a -> b) -> m a -> m b
10:15:57 * thadtheman says -- a build tool is software designed to distract the user from learning a language by forcing them to learn something else.
10:16:07 <thadtheman> Thank you cwraith.
10:16:38 <thadtheman> Thank you c_wraith.
10:16:55 <hpc> oh, "build tools" here means cabal's build-tools field
10:17:26 * hpc would have considered cabal to be a build tool, and happy to be a build dependency
10:18:21 <maerwald_> hpc: maybe read the whole discussion before nitpicking
10:19:32 <hpc> maybe don't jump on me the instant i say something?
10:20:00 <maerwald_> the point is... cabal _knows_ about the location of it's database and such, but when it comes to binaries it needs for building, it just uses PATH and pretends to know nothing
10:20:04 <maerwald_> that is broken
10:20:18 <maerwald_> especially wrt sandboxes, but also without
10:20:36 <geekosaur> fine, you fix ghc-pjkg to list binaries
10:20:53 <geekosaur> (stack had the same problem and hacked around it)
10:21:17 <geekosaur> (and *still* has it with custom build tools, see the ticket about building gtk with stack)
10:22:07 <roundhouse> Hi, if I have a type with a phantom type, e.g. "newtype A b = A { unA :: Int }", how can I instance a typeclass for (A Text)? 
10:22:51 <hpc> roundhouse: what error are you getting?
10:24:34 <roundhouse> hpc: Illegal instance declaration for `DBI.Binary (AssetID Text)'
10:24:34 <roundhouse>         (All instance types must be of the form (T a1 ... an)
10:25:01 <monochrom> I recommend instancing (A b) instead.
10:25:14 <hpc> is there any more to the error?
10:25:32 <roundhouse> yeah, it recommends enabling FlexibleInstances, is that what I need?
10:25:39 <hpc> possibly
10:25:46 <hpc> you might want to try monochrom's suggestion first though
10:26:10 <roundhouse> monochrom: thanks that fixes it. I don't understand why though :)
10:27:30 <geekosaur> the problem has nothing to do with your phantoom type, it's because you are expected to have type variables and not concrete types (here Text is the culprit)
10:27:50 <hpc> class instances are required to be in a particular form to keep instance resolution simple (according to the haskell spec)
10:28:01 <monochrom> It is a rule. The rule is stated in the error message.
10:28:03 <hpc> ghc comes with language extensions that relax and extend that behavior
10:28:05 <geekosaur> this is basically a limitation intended to make things easier for haskell compiler implementors, which is why overriding it involves a ghc extension
10:28:21 <geekosaur> and FlexibleInstances is one of the mostly-safe extensions
10:28:32 <roundhouse> I see, but (A Int) and (A Text) should be different types, right? So they should be able to have different instances of a type class
10:28:41 <roundhouse> ah ok
10:28:43 <roundhouse> I see
10:28:50 <geekosaur> (it can get you in trouble if you later define an instance on A a, since now you have an overlap and behavior is NOT guaranteed)
10:28:53 <hpc> the ghc documentation has some discussion of what the implications of FlexibleInstances are
10:29:19 <roundhouse> thanks, I'll look into that
10:29:21 <geekosaur> basically overlaps + separate compilation = can't guarantee instance selection
10:38:16 <robkennedy> At what point in a paper should I begin soliciting co-authors? How should I go about that?
10:39:12 <monochrom> When and only when you can't do the work alone.
10:39:21 <monochrom> or maybe don't want to.
11:17:59 <kuribas> I have algorithms in my bezier library that I haven't seen elsewhere.  Should I write a paper about them?
11:18:19 <Tuplanolla> Review existing literature first.
11:19:40 <kuribas> To much work...
11:19:53 <kuribas> I don't even have access to academic literature...
11:20:07 <Tuplanolla> That's what Sci-Hub is for.
11:21:08 <kuribas> I'll have to do an analysis, etc... I don't think it's worth the effort...
11:21:51 <jmcarthur> Too much work to research, but not too much work to write the paper?
11:22:27 <Tuplanolla> Some say one hour in the library is worth ten in the lab.
11:23:00 <monochrom> Write a blog.
11:23:16 * geekosaur would think research would be fairly important before writing a paper...
11:23:28 <geekosaur> (blog not so much, so agree w/monochrom)
11:23:38 <kuribas> right, I'll write a blog.
11:26:43 <geekosaur> you could even ask your readers to do the research for you, not in so many words ("if anyone happens to know ...")
11:26:44 <kuribas> jmcarthur: My research upto now is google...
11:26:51 <kuribas> geekosaur: good idea :)
11:27:07 <umoukun> can someone here explain to me why haskell doesnt work when i try to enumerate patterns with my USB dildo????
11:27:31 <umoukun> NEED HELP
11:28:26 <zomg_> you need to "plug it in" if you know what I mean
11:29:19 <Tuplanolla> I think Emacs has a mode for this.
11:29:56 <ertes> kuribas: "The first discovery I'd like to present here is an algorithm for lazy evaluation of research papers. Just write whatever you want and don't cite any previous work, and indignant readers will send you references to all the papers you should have cited. I discovered this algorithm after ``A Plan for Spam'' [1] was on Slashdot." -- paul graham
11:30:32 <kuribas> ertes: lol
11:31:06 <srk> how often do you self censor yourself when about to ask this channel something? :D
11:31:06 <ertes> honestly i don't think i'll ever write a paper in my life, because if you aren't already somewhat involved in the scientific community, it's almost impossible to penetrate
11:31:45 <ertes> "write a blog post and show it to smart people" generally works just as well, at least for software engineering stuff =)
11:32:05 <srk> it seems to work better than a rubber duck
11:32:47 <ertes> a good example in this particular community: van laarhoven lenses
11:37:28 <kuribas> ertes: you didn't go to university?
11:37:37 <ertes> kuribas: nope
11:37:53 <kuribas> so like me
11:39:38 <Tene> I like to say that I graduated early with a double major in sleeping a lot and dropping out
11:40:31 <johnw> ertes: I think it's a misperception to see it as a "closed group"
11:41:08 <ertes> johnw: i don't see it as a closed group, but it's still difficult to penetrate, unless you have an idea that is clearly original
11:41:35 <johnw> it can also just be an idea that advances things along
11:42:06 <ertes> johnw: note: this is particularly about writing papers, not about general community interaction
11:42:14 <johnw> yeah, I'm talking about writing papers
11:42:57 <johnw> I've been rejected a few times already, but then was accepted last year for an experience report, and I'm going to submit another one tomorrow.  I think you just have to do it, rather than assume it won't be accepted because you're not already a well-known academic.
11:45:05 <johnw> at the very least, you'll get some excellent feedback on your idea, and you go through the work of preparing it
11:45:26 <ertes> probably, but then the second problem is that it's a lot of work, far beyond the work of actually explaining your idea
11:45:28 <johnw> I received two pages of feedback from Conor McBridge on one rejection that was worth the whole process
11:45:34 <johnw> McBride*
11:45:38 <kuribas> ertes: exactly
11:45:40 <johnw> yeah, that's true
11:45:49 <johnw> *that's* why most people don't do it, I'd say :)
11:45:57 <ertes> yes, and that's a problem
11:45:58 <johnw> plus side, I'm getting a lot better with LaTeX
11:47:55 <ertes> you know…  i see direct parallels between that and writing a java program…  ultimately the semantics of your program is at most 20 lines of code, but you have to follow all this OOP nonsense for the average java hipster to even look at it
11:48:12 <johnw> lol
11:48:24 <ertes> in the end you have done lots of research into factories and facades and the size of your program has grown to 2000 lines
11:49:05 <kuribas> ertes: well, looking at existing literature and comparing different timings may still give interesting results.
11:49:24 <ertes> kuribas: yes, i agree about that
11:49:33 <ertes> and generally at that point i would have done that
11:50:38 <geekosaur> if I'm going for some reason to formally submit something to a journal, I'd expect to need to do some homework first (references to prior art, etc.)
11:50:53 <geekosaur> (not that I foresee any particular need to do so)
11:51:50 <geekosaur> but then most of my journal experience is (a) reading (b) the likes of _Science_ and _Nature_, not CS or math journals
11:54:36 <monochrom> Paper rejection rate is high for everyone, not just for outsiders, whatever that means.
11:55:08 <Adluc> johnw: can you send DOI of the accepted paper if was already published?
11:55:50 <ertes> you know what would be really helpful?  an "outsider guide"
11:56:06 <ertes> "this is what you need to do to write a paper, and these are the things you need to keep in mind"
11:56:55 <johnw> Adluc: the conference date exactly coincided with an anniversary trip, so I actually had to decline to present.  But I can give you a link to the paper: https://dl.dropboxusercontent.com/u/137615/linearscan.pdf
11:57:25 <johnw> haven't decided whether to resubmit or not
12:10:07 <kuribas> My algorithm is quite simple, I am surprised it doesn't exist already...  Basicly I am using the curvature of a parametric curve to find the closest distance of a point to the curve.
12:12:01 * kuribas 'd better write a paper or blog about it...
12:15:42 <ongy> qui
12:24:11 <ertes> i have an associated type Sample that is defined elsewhere…  how do i exported instances defined in this module properly?  Sample(..)?
12:30:02 <geekosaur> instances are always exported
12:30:09 <geekosaur> and always imported
12:30:26 <geekosaur> oh, type instances not typeclass instances
12:30:32 <geekosaur> um, there's an extension for control of that
12:30:59 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#explicit-namespaces-in-import-export
12:31:26 <geekosaur> I think it also describes the default behavior there?
12:37:59 <kuribas> I found a paper with the same algorithm: https://hal.archives-ouvertes.fr/hal-00920672/document
12:47:12 <Tuplanolla> That didn't take long, kuribas.
12:47:32 <kuribas> Tuplanolla: no, it didn't :-P
12:48:47 <Tuplanolla> I may have thought about this problem at some point as well.
12:48:54 <Tuplanolla> Not enough to take it anywhere, however.
12:50:39 <kuribas> Tuplanolla: apparently the problem is called "point projection".
12:51:05 <Habib> Does anyone know of a function like stripPrefix that just returns the second argument by default instead of Nothing if it fails?
12:51:07 <ertes> ah:  pattern LinearSample
12:51:44 <Habib> This is what I've got so far:
12:51:50 <ertes> geekosaur: i had tried that, but got a syntax error…  didn't realise that i also need -XPatternSynonyms
12:51:52 <Habib> (join $ stripPrefix "https://google.co.uk" <$> Just "/search?q=search+query") <|> Just "/search?q=search+query"
12:52:53 <Habib> Whoos, sorry more lilke (join $ stripPrefix hostUrl <$> possiblePathOrUrl) <|> possiblePathOrUrl
12:53:19 <Habib> But that's ugly as hell.
12:53:54 <sm> maybeStripPrefix p s | p `isPrefixOf` s = drop (length p) s
12:53:58 <sm>                      | otherwise        = s
12:55:00 <Habib> Ha, fair enough. I did think about just implementing it myself, but I thought I might be able to drastically shorten it by building upon the original.
12:55:14 <ertes> Habib: you should probably use an actual URL library
12:55:27 <Habib> Another good idea.
12:56:00 <ertes> Habib: https://hackage.haskell.org/package/network-uri
13:04:53 <zennist> is there a way for ghc to print the typeclass instance selection process?
13:05:05 <zennist> i'm having trouble understanding some of the errors it arrives with
13:10:12 <geekosaur> I think -ddump-tc-trace is the best you can do?
13:36:26 <michalrus> So I would need to define a… sort of Bifunctor for my type, but with the first function inverted: `(c -> a) -> (b -> d) -> f a b -> f c d`. Is there a name for that?
13:38:28 <phadej> Produnctor
13:38:37 <phadej> michalrus: Profunctor
13:38:50 <michalrus> Awesome, thank you! ♥
13:38:54 <phadej> np
13:46:49 <Zemyla> So if a term made by composition of S, K, and I hasa valid type in the simply typed lambda calculus, then it's guaranteed to terminate, correct?
13:53:44 <hpc> Zemyla: STLC is strongly normalizing, so yes
13:54:11 <jgt> hey folks
13:54:52 <jgt> I have a `HandlerT App IO ()` in my Yesod app, but I need to give it to something expecting a `ReaderT App m ()`
13:55:08 <jgt> am I able to transform one to the other?
13:57:52 <jgt> basically I want to call a handler from a `runJob`, as defined here: https://github.com/nakaji-dayo/yesod-job-queue/blob/master/Yesod/JobQueue.hs#L99
13:59:07 <jgt> but since `runJob` takes a ReaderT, I'm guessing it can't take a HandlerT, as a HandlerT can change some state, and ReaderT disallows that… maybe?
14:04:44 <Zemyla> hpc: Is it still strongly normalizing when augmented with C :: (((a -> b) -> a) -> a? I don't think so, since that implies the law of the excluded middle.
14:06:43 <lyxia> jgt: runJob doesn't take a ReaderT, it produces one
14:06:43 <Zemyla> Though it's still not inconsistent, so hmm.
14:07:07 <lyxia> jgt: and you can convert it to a HandlerT because a HandlerT site m a is an instance of MonadReader site
14:07:39 <hpc> @djinn f :: (((a -> b) -> a) -> a
14:07:39 <lambdabot> Cannot parse command
14:07:56 <jgt> lyxia: so is what I'm trying to do, actually doable?
14:08:02 <hpc> Zemyla: probably not, because i don't think that type has any normal form inhabitants
14:08:15 <mauke> ((())
14:08:44 <lyxia> jgt: I guess so. What are the exact types of the input you have, and the output you expect?
14:09:04 <jgt> lyxia: are you familiar with Yesod?
14:09:53 <bollu> :t callCC
14:09:57 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
14:10:19 <bollu> ^ someone explain that to me? I don't intuitively understand what's happening.
14:10:28 <lyxia> jgt: kind of
14:10:50 <monochrom> bollu: My http://www.vex.net/~trebla/haskell/cont-monad.xhtml
14:11:01 <bollu> monochrom: ooh thanks
14:11:42 <jgt> lyxia: basically when I write my `instance YesodJobQueue App where`, I have a line like this: `runJob app FetchNextCompany = appFetchNewCompaniesJob app`
14:12:39 <jgt> lyxia: and `appFetchNewCompaniesJob app` is a `HandlerT App IO ()`
14:12:43 <bollu> monochrom: what I do not understand is: the early exit handler returns "m b" but the final type of callCC returns an "m a"
14:13:00 <bollu> monochrom: so, like, how the hell do you implement it in your head? I've written the implementation with "follow the types"
14:13:02 <Eduard_Munteanu> jgt, 'm' can be a HandlerT App IO ()
14:13:04 <bollu> monochrom: but it makes no sense to me
14:13:07 <ezyang> the early exit handler doesn't have to "return" 
14:13:12 <ezyang> think about error: it takes any type 
14:13:16 <ezyang> that's because it shortcuts out 
14:13:21 <ezyang> same with the early exit 
14:14:02 <bollu> ezyang: I don't follow, I'm sorry
14:14:11 <ezyang> :t error  
14:14:14 <lambdabot> [Char] -> a
14:14:16 <monochrom> It is similar to 'error "hello"' has a polymorphic return type. It doesn't return. It can afford to claim a polymorphic return type and blend into any context you like.
14:14:20 <mauke> bollu: do you happen to know C?
14:15:10 <jgt> lyxia Eduard_Munteanu $100 to anyone who wants to pair with me on this for like 30 minutes (probably takes less time though)
14:15:24 <bollu> mauke: yes
14:15:59 <mauke> what type would longjmp have in Haskell?
14:16:17 <bollu> ((a -> m b) -> m a) -> m a <- if I use callCC $ \handler -> k "error" or something, it would actually get called?
14:16:51 <ezyang> you didn't call handler 
14:16:56 <monochrom> But I don't have to use callCC in that boring way.
14:17:21 <bollu> mauke: I haven't used longjmp, sorry :) 
14:17:27 <bollu> ezyang: what do you mean?
14:17:35 <bollu> monochrom: how else would you make use of callCC?
14:17:48 <ezyang> bollu: Did you mean s/k/handler/ 
14:18:21 <monochrom> callCC $ (\k -> do { x <- if 4>5 then k False else return 10; return (x > 20) })
14:19:33 <monochrom> Also the examples in my article.
14:19:35 <bollu> monochrom: change the "k False" to "k 'a'" or something? because in your example, b ~ a
14:20:02 <bollu> monochrom: oh wait that doesn't make sense
14:20:06 <monochrom> No, x>20 :: Bool, therefore I need k (something :: Bool).
14:20:13 <bollu> monochrom: yeah
14:20:27 <bollu> monochrom: so, well, what if k = return "monochrom"
14:20:36 <bollu> monochrom: what would the output of actually running this continuation be?
14:20:44 <monochrom> But k != return "monochrom".
14:20:53 <bollu> monochrom: how do you know that?
14:21:03 <bollu> monochrom: k _ = return "monochrom" I mean
14:21:12 <monochrom> Neither.
14:21:24 <bollu> monochrom: OK, so, what is "k"?
14:21:29 <jgt> Eduard_Munteanu: So I guess I'm reading it wrong? Perhaps I should read it like: “runJob takes a `JobType master` and produces a `ReaderT master (HandlerT App IO ()) ()`”?
14:21:44 <monochrom> Let's say I read the source code of Cont and callCC so I know k _ != return "monochrom", OK?
14:22:19 <bollu> sure :)
14:23:01 <Eduard_Munteanu> jgt, that could work, with master ~ App. Note HandlerT is already ReaderT-like
14:23:05 <hpc> k = everything that happens after that callCC
14:23:07 <monochrom> It is the job of callCC to create something sensible and hand it to you as your k, and it has the effect of early escape. It is going to be a beast.
14:23:21 <bollu> I see
14:23:25 <hpc> including things not currently in scope
14:23:42 * hpc lpastes
14:23:51 <bollu> https://github.com/bollu/haskell-koans/blob/master/cont.hs#L46
14:23:55 <bollu> I had implemented it before
14:23:59 <bollu> I do not understand it however
14:24:16 <jgt> Eduard_Munteanu: I don't suppose you fancy pairing on this with me?
14:24:36 <Eduard_Munteanu> jgt, not exactly, I can help here though
14:25:18 <bollu> monochrom: so, well, what would it look like / be?
14:25:19 <jgt> Eduard_Munteanu: are you familiar with Yesod?
14:25:28 <hpc> bollu: http://lpaste.net/3364016637622616064
14:25:34 <monochrom> callCC has access to the piece of program that appears after callCC. (Well, every program in the Cont monad does, but few actually exploit it.)
14:25:37 <bollu> monochrom: in general, what is the type of "b" that is chosen in the ((a -> m b) -> m a) -> m a
14:26:22 <monochrom> So callCC creates a k that says "let's jump forward to that future point".
14:26:28 <Eduard_Munteanu> jgt, if you want to use runJob in a handler, you just have to do something like   do { app <- getYesod; runReaderT (runJob app ...) app }   though I'm not sure it makes much sense
14:26:38 <hpc> bollu: in a very real way, saying anything about the value of k there is like writing "do x <- get; print x" and declaring that x = 5
14:26:39 <monochrom> In general, it is determined by the context.
14:26:40 <bollu> hpc: oh, oh
14:26:50 <Eduard_Munteanu> jgt, yes
14:26:50 <bollu> I see
14:27:01 <jgt> Eduard_Munteanu: other way around. I want to call a handler from `runJob`
14:27:09 <hpc> it depends on things outside your current knowledge
14:27:19 <bollu> hpc, monochrom: so is there an intuition to the _implementation_ of callCC?
14:27:21 <Eduard_Munteanu> jgt, oh, then just lift
14:27:27 <bollu> I've implemented it but I don't understand why it works :)
14:27:33 <monochrom> For example, I wrote "if 4>5 then k False else return 10" so the context wants Integer because "else return 10", so b = Integer by type inference.
14:27:54 <bollu> right
14:27:56 <monochrom> Yes, the intuition is what I said.
14:28:10 <monochrom> <monochrom> callCC has access to the piece of program that appears after callCC. (Well, every program in the Cont monad does, but few actually exploit it.)
14:28:14 <Eduard_Munteanu> jgt, you might need a MonadHandler constraint on m
14:28:16 <hpc> honestly, if i had to write callCC by hand right now i would probably start by running the djinn algorithm in my head
14:28:17 <monochrom> <monochrom> So callCC creates a k that says "let's jump forward to that future point".
14:29:06 <jgt> Eduard_Munteanu: I tried saying `data App = App {...appFetchNewCompaniesJob :: IO () }`, and then in `makeFoundation` I did `appFetchNewCompaniesJob <- return $ handler fetchNextCompany`
14:29:28 <bollu> monochrom: so you would implement it using that intuition?
14:29:37 <monochrom> Yes.
14:29:43 <jgt> Eduard_Munteanu: and this worked _somewhat_ but it sometimes failed after a while with “runFakeHandler issue: InternalError "<socket: 14>: hFlush: illegal operation (handle is closed)"”
14:29:48 <Eduard_Munteanu> Let me get some context on this package.
14:29:48 <monochrom> I think I actually did.
14:30:06 <bollu> monochrom: when?
14:30:16 <jgt> Eduard_Munteanu: and I suspect it's because I used the `handler` function, which is implemented with the `unsafeHandler` function
14:30:16 <monochrom> A long time ago when I was learning this stuff.
14:30:51 <monochrom> When maybe it's unfair to call it intuition.
14:31:06 <monochrom> I don't do intuition. I do realistic theories.
14:31:06 <Eduard_Munteanu> jgt, oh, I see. You're not supposed to run a handler, but an IO action that executes asynchronously, I think.
14:31:15 <jgt> Eduard_Munteanu: oh and to run it, I was doing `runJob app FetchNextCompany = liftIO (appFetchNewCompaniesJob app)`
14:32:04 <Eduard_Munteanu> jgt, but you could turn appFetchNewCompaniesJob into an IO action and a handler action using the IO action.
14:32:16 <monochrom> callCC lives in the Cont monad therefore it has access to "the rest of the program". (Everything that lives in Cont does, though you don't always have to care.)
14:32:52 <bollu> I see
14:32:57 <jgt> Eduard_Munteanu: I _may_ have been doing that…? I'm not quite sure
14:33:04 <bollu> hm, OK
14:33:06 <monochrom> So callCC just needs to package that "rest of the program" up in a form suitable for the user.
14:33:08 <hpc> if you've ever written assembly, it's like having access to the instruction pointer
14:33:21 <monochrom> I don't know whether this is intuition or not. But it is the reality.
14:33:21 <hpc> (which also in some way represents the complete remainder of the program)
14:33:51 <jgt> Eduard_Munteanu: I think `data App = App {...appFetchNewCompaniesJob :: IO ()...}` means that appFetchNewCompaniesJob is an IO action
14:34:05 <hpc> you should experiment with it in ghci, and especially with constructing ContT values with the data constructor
14:34:25 <hpc> see what happens when you ignore the continuation, or when you do other fancy things with it
14:34:26 <jgt> Eduard_Munteanu: (also, I'm using ellipses here to emit other irrelevant fields; not some record wildcard thing)
14:34:42 <hpc> and then try and work out why it did those things for yourself
14:34:42 <Eduard_Munteanu> jgt, without using 'handler' to turn HandlerT App IO () into IO (), but the other way around... make your HandlerT App IO () use the IO () action
14:36:32 <jgt> Eduard_Munteanu: so how should I initialize the appFetchNewCompaniesJob field? 
14:36:37 <nilof> I'm wondering how MonoFoldable relates for Foldable? Is every instance of Foldable a MonoFoldable? Or the other way around? Or neither?
14:36:43 <nilof> *relates to
14:37:46 <Eduard_Munteanu> jgt, point it to the IO action that does the IO work (possibly including database stuff).
14:38:13 <bollu> hpc: cool, thanks. Much appreciated
14:38:22 <bollu> hpc: I've been trying to construct interesting things with Cont, but it is hard
14:38:35 <freeside> nilof: http://stackoverflow.com/questions/39634504/is-there-anything-we-lose-with-monofoldable
14:39:09 <geekosaur> "The motivation is that some commonly used data types (i.e., ByteString and Text) do not allow for instances of typeclasses like Functor and Foldable, since they are monomorphic structures. This module allows both monomorphic and polymorphic data types to be instances of the same typeclasses."
14:39:38 <jgt> Eduard_Munteanu: I'm not able to do `appFetchNewCompaniesJob <- fetchNextCompany`, with `fetchNextCompany` being the name of my handler
14:40:28 <Rotaerk> geekosaur, what's that from
14:40:38 <jgt> Eduard_Munteanu: that, combined with `runJob app FetchNextCompany = appFetchNewCompaniesJob app`, fails with:
14:40:40 <jgt> Couldn't match expected type ‘ReaderT App m ()’
14:40:42 <jgt>                 with actual type ‘HandlerT App IO ()’
14:40:46 <freeside> https://hackage.haskell.org/package/mono-traversable-1.0.2/docs/Data-MonoTraversable.html
14:40:55 <Eduard_Munteanu> jgt, sure, it's not supposed to be a Handler.
14:40:57 <Rotaerk> ah
14:40:58 <geekosaur> haddock for Data.MonoTraversable (mono-traversable package)
14:41:16 <Eduard_Munteanu> jgt, what I mean is you have to rewrite fetchNextCompany to split it into handler stuff and IO stuff
14:41:32 <geekosaur> and, somewhere in there, the point is to make a bunch of things able to work with any of String/ByteString/Text
14:41:59 <Eduard_Munteanu> jgt, after that, initialize the field to point to the IO bits.
14:42:13 <monochrom> callCC is passe these days. We have found that shift and reset exposes the real usefulness of Cont and ContT.
14:42:33 <jgt> Eduard_Munteanu: It might not even need to be a handler. If I understand it correctly, a handler is for when you need information about a request. I'm only using a `Handler ()` so I can use Yesod's logging, i.e., `$(logInfo)`
14:42:46 <Eduard_Munteanu> jgt, yep
14:43:19 <jgt> Eduard_Munteanu: Can I do logging that way without being inside a handler? 
14:43:55 <Eduard_Munteanu> jgt, sure, you just need the monad to be a MonadLogger for instance
14:44:15 <Eduard_Munteanu> And make a runner function that takes care of passing the right logger around.
14:44:58 <jgt> Eduard_Munteanu: so I need to write something like `instance MonadLogger where; fetchNextJob = …`?
14:45:16 <jgt> s/Job/Company/
14:46:29 <jgt> actually, if this doesn't need to be a Handler then the whole thing becomes so much simpler
14:46:44 <bollu> monochrom: what's shift and reset?
14:47:00 <Eduard_Munteanu> jgt, no... you can have   fetchNextJob :: MonadLogger m => m ...   then you can have a runner function which takes care of calling it
14:47:00 <monochrom> reset m = runCont m id
14:47:09 <jgt> I then don't need this appFetchNewCompaniesJob field
14:47:13 <monochrom> shift I forgot, but it is not complicated.
14:47:19 <bollu> monochrom: what does it do?
14:48:11 <ezyang> Curses! Got bit by 'length has an instance for (,) a' 
14:48:27 <monochrom> Let me see if I can recall it off the top of my head. I only have it written down in a file I don't have now.
14:49:15 <ezyang> oops 
14:50:21 <freeside> jgt: are you using WAI?
14:50:31 <ezyang> that error only occurs on update right? 
14:51:04 <jgt> freeside: I think so? I mean, Yesod uses it, right?
14:51:07 <geekosaur> was that for #hackage, ezyang?
14:51:14 <ezyang> yes oops 
14:53:02 <freeside> jgt: i'm looking at http://www.yesodweb.com/book/web-application-interface and wondering if your app would benefit from that structure.
14:53:21 <jgt> Eduard_Munteanu: how should I be running it? Do I need a `runReaderT`? I'm doing `runJob app FetchNextCompany = fetchNextCompany` and it's failing with this: http://sprunge.us/bVLh
14:53:43 <freeside> bollu: re shift and reset, see https://en.wikipedia.org/wiki/Delimited_continuation#Examples
14:54:03 <bollu> freeside: thank you
14:54:12 <ezyang> the problem with optparse-applicative is I can never find where the combinators are defined 
14:55:45 <freeside> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.11.3425&rep=rep1&type=pdf
14:55:49 <jgt> freeside: I'm not sure what the relevant part is :-/
15:00:32 <freeside> yeah, sorry, I don't know Yesod well enough to be useful to you, i think
15:01:19 <jgt> freeside: no problem, thanks for trying :) 
15:02:04 <jgt> Eduard_Munteanu: I think I figured out that last error; I was doing `app <- getYesod` which was making it a MonadHandler
15:05:28 <centril> Say I have a: type N a = a -> Maybe a, which denotes a normalizer of some term a ... The normalizer yields Just if something was normalized, or Nothing on identity... I then want to traverse the tree applying this normalizer recursively... but if I use >>= , then failing to normalize a sub-tree will yield Nothing for the whole computation...
15:05:58 <Athas> Which IO exception should I catch if I want to catch all IO errors, except those signalled by 'exitWith'?
15:06:07 <centril> Which leads me to... Is there some dual to Maybe  where computations only yield Nothing if all parts yield Nothing... ?
15:06:16 <Athas> Specifically, I want a top-level catcher for my program that catches all otherwise-unhandled exceptions, in order to print a custom error message.
15:07:11 <centril> I thought of:  data N a = Normalized a | Id a ... but this won't work with Functor, Monad, etc.
15:07:41 <monochrom> Athas: Use the method in my http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml#subtyping
15:07:52 <jgt> Eduard_Munteanu: currently, my thinking is that in order to use logging like `$(logInfo)`, I need to change the type constraint of `runJob` from `(MonadBaseControl IO m, MonadIO m)` to `(MonadBaseControl IO m, MonadIO m, MonadLogger m)`. Is that right?
15:08:39 <freeside> centril: you seem to imply that returning the term unchanged is a failure to normalize; do i understand you correctly?
15:08:44 <Athas> monochrom: I see.  Thank you.
15:09:26 <freeside> it seems to me that if the normalizer returns the term unchanged, then it is already in normal form, and you should give back Just whatever, rather than Nothing.
15:09:46 <monochrom> Is exitWith's exception really an IOException?
15:09:51 <Athas> monochrom: however, how can I check whether an exception is an ExitCode?
15:09:55 <Athas> No, it is an ExitCode.
15:10:27 <monochrom> OK, then you catch/try for the ExitCode type instead.
15:10:39 <centril> freeside: Yes, but the top normalizer loop-applies all normalizers until none yield Just anymore
15:10:43 <Athas> Hm, there is Control.Exception.catches.
15:10:53 <monochrom> Scroll up to the "Typing" section.
15:10:56 <Squarism> can one use type designators "type UserId = Int" to actually check an argument is not just an Int but a UserId?
15:11:08 <centril> freeside: and if they keep yielding Just, then the normalizers will never terminate
15:11:17 <jgt> Eduard_Munteanu: but to override the type signature of `runJob`, I have to create my own class with a new `runJob`, called something else like `runJob'`
15:11:22 <jgt> I think?
15:11:55 <geekosaur> Squarism, no
15:12:20 <Squarism> geekosaur, thanks
15:12:36 <geekosaur> you also cannot escape using a constructor if you wnt UserId to be a distinct type; the constructor is how the compiler / language keeps track
15:12:38 <freeside> centril: er, your approach sounds kind of imperative, are you thinking functionally?
15:13:08 <centril> freeside: the logic is: run all normalizers until you can't normalize no more
15:13:44 <centril> freeside: how else should you do it... ? one normalization may unlock another... and they may be written independently
15:14:29 <centril> I could roll a bunch of functions: l2 :: (a -> b -> c) -> a -> b -> Maybe a -> Maybe b -> Maybe c
15:14:58 <centril> l3 :: (a -> b -> c -> d) -> a -> b -> c -> Maybe a -> Maybe b -> Maybe c -> Maybe d
15:15:12 <centril> but that is not very generalizable
15:17:08 <centril> I want to avoid a combinatorial explosion of manually writing code for checking if (Just a, Just b, Just c) -> ... (Just a, Just b, Nothing) -> ... (Just a, Nothing, Nothing) -> ... (Nothing, Just b, Nothing) -> ...
15:17:12 <freeside> what kind of normalization are you performing? are you validating input data or are you doing some kind of program refinement?
15:17:50 <centril> freeside: im normalizing ASTs of parsed java programs
15:18:18 <centril> freeside: https://github.com/DATX02-17-26/DATX02-17-26/blob/dev/libsrc/NormalizationStrategies.hs
15:19:24 <centril> there is zero validation, just semantic preserving normalizations of the AST
15:20:17 <freeside> ok, so you want to keep normalizing until you detect convergence.
15:21:15 <centril> freeside: convergence meaning what in this context?
15:21:27 <freeside> your thingy stops moving
15:22:03 <centril> yes, keep normalizing until all normalizations yield "no change"
15:22:12 <centril> We already do that...
15:22:57 <centril> but... writing a single normalizer :: AST -> Maybe AST may be tricky and verbose since ASTs are deep, and there might be a normalization that can be applied deep within the tree
15:24:13 <robkennedy> When compiler writers worry about exponential code gen, what is their concern? Compilation time, or performance?
15:24:58 <monochrom> I think neither. I think it's this:
15:25:08 <monochrom> * newhaskeller has joined #haskell
15:25:56 <monochrom> <newhaskeller> Why are GHC-generated executables so bloody huge? Mine is 100MB and it's just summing numbers. I want my money back.
15:26:07 <monochrom> * newhaskeller has quitted #haskell
15:26:15 <centril> freeside: for example, for expressions, data E = V String | E :+: E | E :*: E   we might want to rewrite x * (x + x) = x * 2 x, and given  normXX :: E -> Maybe E , we need to normalize deeply in  l :+: r
15:26:45 <centril> robkennedy: performance = runtime performance of compiled program ?
15:27:56 <freeside> okay. i have two comments. first, why aren't you relying on the Traversable nature of your AST? second, using a Maybe in lines 98--100 seems like the wrong way to go about detecting stability/convergence.
15:28:10 <centril> a compiler writer would want to have a code-gen pass that emits an as efficient as possible program, but takes as little compile time as possible... sadly, you can't have it all
15:28:35 <freeside> your reduction rules may converge, diverge, or loop; you need to detect all these cases, and shoehorning things into a Maybe doesn't feel like the right design approach.
15:29:19 <centril> converge, diverge, loop - define the terms =)
15:29:37 <centril> a reduction rule may never loop - it must terminate
15:29:51 <centril> otherwise normalization is stuck
15:30:44 <freeside> if you are confident that reduction always converges, why not just tag each node of your AST with a "stable" predicate?
15:33:38 <centril> freeside: by "stable" predicate I'm guessing you mean: "decorate the tree with, I can't be normalized further"... because that would change the structure of the AST itself - and I can't say atm when something is stable or not - because Java is complicated and I could add more complex reduction passes
15:34:30 <centril> freeside: I also don't get how I can make the AST Traversable...
15:34:40 <freeside> as for looping and divergence, i'm talking about a set of reduction rules that may, um, let me give an example: suppose you have a rule (a :: exp) "+" (b :: exp) ==> b "+" a
15:34:48 <Athas> robkennedy: exponential *anything* is bad.  You run the risk of sudden explosion, which is as bad as nontermination.
15:35:20 <freeside> so that rule, the first time you run it, flips a+b into b+a. then the second time you run it, it turns back into a+b. so there you have a loop.
15:35:31 <centril> Athas: hah, im my BsC project we're dealing with factoral complexities at places
15:35:34 <centril> factorial*
15:36:23 <centril> freeside: well that would not be a valid reduction rule, because it doesn't reduce
15:36:29 <jgt> I'm using this library code, but I want to change the type constraint of this line. How can I override it? https://github.com/nakaji-dayo/yesod-job-queue/blob/master/Yesod/JobQueue.hs#L99
15:36:47 <centril> freeside: unless you sort a & b lexiographically
15:38:12 <mofasa> Has any of you had any luck doing `stack install hsdev`? I'm getting dependency hell, stack can't figure things out on its own
15:38:13 <centril> Athas: iirc dependent types in Idris & Agda requires SMT solvers, which makes type checking exponential
15:38:55 <mofasa> http://pastebin.com/8qB3Gfcs
15:39:39 <AWizzArd> Does Haskell support Arrays that have no bounds checking at runtime?
15:40:19 <centril> AWizzArd: by Arrays, do you mean a sequential list ?
15:40:21 <ezyang> there exist libraries that offer unchecked indexing 
15:40:22 <geekosaur> you probably want Data.Vector
15:41:15 <AWizzArd> centril: I mean ordinary simple Arrays. Could be byte arrays. I think there is a string type like this. Was it ByteString maybe? But I meant in general, Arrays, like Float Arrays.
15:41:36 <AWizzArd> For maximum read speed, of indexed data.
15:42:05 <centril> AWizzArd: sounds like you'd want dependent types and type level Nat:s to ensure that the compiler verifies bounds instead of doing it at run-time
15:42:23 <centril> (as a general comment)
15:42:25 <AWizzArd> centril: no dependent types. I trust that I will only access an element within the bounds.
15:42:49 <geekosaur> :t unsafeAt
15:42:51 <lambdabot> error: Variable not in scope: unsafeAt
15:43:04 <AWizzArd> I have 20 million floats and want to access the nth element, and I am confident that my code never tries to access the element 20000001
15:43:48 <AWizzArd> Lists would work of course, but I want the fastest possible access time, as this sits in tight loops that run billions of times.
15:44:12 <centril> :t (Data.Array.!)
15:44:14 <lambdabot> Ix i => Array i e -> i -> e
15:45:14 <AWizzArd> The JVM for example always checks when I access the nth element, if n is <= the max element number. I can’t go around this check. While C# does allow reads without any runtime checks.
15:45:34 <freeside> as geekosaur said, maybe you want Data.Vector
15:45:39 <geekosaur> right, I was trying to remember what the no-bounds-check version of (!) was
15:45:50 <geekosaur> there was one in there, I thought
15:46:55 <Rotaerk> hmm I'm writing a script where you can give it the name and version of a hackage package, and it will download http://hackage.haskell.org/package/<name>-<version>.tar.gz and hash it
15:47:14 <centril> geekosaur: does (Data.Array.!) do bounds checking ?
15:47:18 <AWizzArd> freeside: the Unboxed version possibly?
15:47:29 <geekosaur> iirc it does
15:47:34 <Rotaerk> if I want to allow the user not to have to specify a version, is there some easy way (without having a locally up to date cabal) to get the latest version of that package?
15:48:02 <centril> geekosaur: then why isnt it yielding Maybe e ?
15:48:16 <geekosaur> same reason hed doesn't
15:48:22 <geekosaur> someone thought that was a good idea
15:48:28 <geekosaur> (Array is not used much...)
15:48:34 <centril> stupid partial functions in base make me sad...
15:49:05 <geekosaur> you're far from the only one
15:49:38 <robkennedy> Athas: exponential everything isn't necessarily bad. Solving P problems with NP compiler difficulty is an optimization sometimes. 
15:49:39 <centril> geekosaur: ye =)
15:49:47 <Rotaerk> well, apart from scraping the contents of http://hackage.haskell.org/package/<name>-<version>
15:50:28 <jgt> (asking again)
15:50:28 <centril> robkennedy: for small n ;)
15:50:30 <jgt> I'm using this library code, but I want to change the type constraint of this line. How can I override it? https://github.com/nakaji-dayo/yesod-job-queue/blob/master/Yesod/JobQueue.hs#L99
15:51:05 <robkennedy> centril: yes, I thought of exponential code gen as performance hit, where performance is dichotomously compiler or run-time
15:51:06 <Rotaerk> eh, maybe cabal is fine in this case..
15:51:12 <jgt> or do I need to write my own fork of that library?
15:51:16 <geekosaur> the latter
15:51:43 <jgt> geekosaur: was that addressed to me?
15:51:49 <geekosaur> you can't override something else's type (well, there is a way but unless you know exactly what you are doinbg and what ti means to the compiler, you are inviting a core dump)
15:52:17 <jgt> ah, I see. So the right thing to do here would be to fork the library and use my own version in my project, then send a patch upstream?
15:52:21 <robkennedy> monochrom: good reason. What is the base line and "poor" Haskell exe? That's a priming I've yet to bother with
15:53:22 <robkennedy> centril: but many types are bound by small n (ie Int)
15:53:30 <geekosaur> likely, although if they don't accept the patch for whatever reason you may be stuck maintaining yoiur own fork
15:53:52 <geekosaur> (in that case it is usually worth listening to why; you may learn how to make it work without modification)
15:53:56 <centril> robkennedy: 2^32 sounds like very large
15:54:32 <jgt> geekosaur: Thanks for the clarification! :)
15:55:03 <freeside> jgt: i said previously that I don't know Yesod well enough, and that's still true, but 20 years of software development experience suggests that there's a right way and a wrong way to get Yesod to do what you want, and forking the library to change a type constraint sounds like the right way is still waiting to be discovered :)
15:55:29 <ongy> jgt: before you put effort into that it may be worth creating an issue (if it's on github) or equivalent, so you get told if there's a better way
15:55:50 <kuribas> Yesod isn't some obscure forgotten package.
15:56:12 <freeside> back on #perl, purl used to talk about XY Problem
15:56:12 <robkennedy> centril: I was referring to the 32. You're right that Int has a large domain. The times SPJ has referenced exponential code gen, I've wondered on that bound for N. I'll look back on those cases. 
15:56:20 <jgt> freeside: well, in the example usage of that library, the author prints stuff to screen with `putStrLn`. I don't want to do that; I want to use Yesod's logger. And to do that, I believe I must add `MonadLogger m` to that type constraint
15:56:45 <centril> robkennedy: oh =)
15:57:39 <jgt> ongy: I intend to open an issue, but I also want to get this thing working now, and also I'm learning a whole bunch of stuff along the way
15:57:42 <Cale> jgt: Which is unfortunate, because you can already perform arbitrary IO actions -- not being able to log stuff at that point is a crime :)
15:58:08 <centril> robkennedy: im very happy that topological sorting of a DAG is P, or we would be in deep shit
15:58:26 <jgt> Cale: I'm not sure *exactly* what you mean; are you saying that my wish to log stuff is reasonable in this context?
15:58:33 <centril> dependency analysis would be super expensive if it werent
15:59:09 <Cale> jgt: It is reasonable to want to log stuff, but I'm not a fan of MonadLogger
15:59:37 <Squarism> i wonder what a good way to create an api is. Right now i have all my types in Types.hs. I want to describe an api. Should import certain types to Api.hs and document them there?
15:59:56 <Cale> jgt: It does appear that there's a class MonadLoggerIO which, supposing that it applies to whatever monad you're using, will get you a function that gives you a plain IO action at the end
16:00:00 <Squarism> (for the "type" part of the api)
16:00:17 <centril> Squarism: will you export Types.hs in exposed-modules ?
16:01:11 <centril> Squarism: I think having small files is nice - you can always re-export... and the haddock docs will just magically work
16:01:37 <jgt> Cale: I *think* I want to use MonadLogger for a couple of reasons: 1. Consistency, and some free stuff like timestamps and other data, and 2. I vaguely remember reading something (I think Snoyman wrote it?) about output buffering; if you just use `putStrLn`, then eventually the output will start getting mashed together and will be useless. This is at least what I was seeing when I tried using `putStrLn`.
16:02:01 <jgt> although “output buffering” may not have been the correct term
16:02:17 <Rembane> MonadLogger is using something more low-level that I like.
16:02:18 <Cale> Oh, in a multithreaded application, you definitely want to set up a logging thread if you're going to be logging stuff from multiple threads.
16:03:17 <Cale> But I would just do that myself usually, and stick the action for writing to the log into whatever record structure I'm passing around for my application's state (or just pass it around directly if I don't have one of those yet)
16:03:19 <jgt> Cale: well, I'm using this library for background jobs, and naturally those jobs run in some worker threads in the background (I think? Yes?)
16:03:30 <Cale> Yeah, that's fine
16:03:45 <jgt> Cale: So even more so since you say that, it's strange that the author uses putStrLn in the usage examples
16:04:24 <jgt> but then again, I feel I'm working to defend this point in an IRC room full of Haskellers much more experienced than me, so I feel I'm probably wrong about something still
16:04:48 <freeside> maybe the putStrLn usage examples were written before fast-logger, etc were put into yesod
16:04:57 <Cale> It's mostly a matter of taste, and people can disagree on it.
16:05:01 <Cale> (reasonably)
16:05:06 <Cale> anyway, try  askLoggerIO :: m (Loc -> LogSource -> LogLevel -> LogStr -> IO ())
16:05:24 <Cale> Assuming you're using Snoyman's monad-logger, which it sounds like you are :)
16:06:07 <jgt> freeside: that project is only a year old. Not sure when fast-logger went into Yesod
16:06:15 <freeside> oh ok
16:06:27 <jgt> freeside: it's this one: https://github.com/nakaji-dayo/yesod-job-queue
16:07:06 <jgt> Cale: I'm not sure where I'd put that function
16:09:08 <freeside> "a monad is not like a burrito, but if it were, a monad-logger would be like the trail of meat juices and sour cream that squirts out from the distal end onto your jeans"
16:09:18 <pikajude> which end is the distal end
16:09:23 <johnw> lol
16:09:28 <johnw> distal is the one facing away from your mouth
16:09:36 <pikajude> oh
16:09:48 <jgt> I had a burrito this evening and the juice ended up on my trackpad
16:09:57 <jgt> my macbook is basically an eating utensil
16:10:05 <freeside> well, clearly It's A Sign
16:10:15 <centril> freeside: depends on where you put your logger in the monad transformer stack
16:10:15 <Squarism> centril, well some of them. The API atleast
16:11:27 <centril> Squarism: I would design like this: let Type.hs be an exported-module and Api.hs as well, and then in Api.hs, reexport Type.hs - put documentation relevant to Type.hs in Type.hs
16:11:48 <centril> in Type.hs, only export API stuff
16:12:31 <centril> you can always have auxilary functions related to Type.hs in TypeAux.hs which is not exported, etc...
16:13:08 <centril> Squarism: documenting stuff about Type.hs in Type.hs is good because it makes maintenance easier
16:13:19 <Squarism> ok.. so Api will just export stuff, nothing defined there?
16:14:13 <centril> Squarism: well... you can still define extra stuff in Api.hs , but yes ... that is a thumbrule
16:14:21 <Squarism> ok
16:14:41 <centril> Squarism: take a look at: https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens.html
16:16:02 <neophytes> I am new to programming, the book I have (purple Haskell programming book) doesn't explain how to set up an IDE + Haskell on a Mac. What IDE should I use (that isn't vim/emacs + is free)?
16:16:23 <srk> ghcid
16:16:25 <neophytes> Also, is there any step-by-step tutorials on setting this up and writing a first 'hello world' program to see it works?
16:16:32 <neophytes> what is a ghcid IDE?
16:16:35 <srk> nah, just ghci ;)
16:17:04 <srk> ghcid is "IDE", it just compiles your code over and over and tells you that it compiles
16:17:24 <srk> which often is the only thing you need
16:17:38 <neophytes> So you type your complete program into ghci and it will have highlighting and so open like ecplise
16:17:40 <neophytes> ?
16:17:45 <srk> ghci is interpreter, you can prototype whole program in ghci
16:17:58 <Cale> You generally won't type much of your program into ghci
16:17:59 <srk> but mostly for testing/trying out stuff
16:18:04 <Cale> but ghci is not the same thing as ghcid
16:18:10 <Cale> you don't type anything into ghcid
16:18:36 <Cale> It just sits there and lets you know the status of your code -- any errors or warnings which presently exist in it
16:18:36 <neophytes> I want something that will be like ecplise / sublime / IntelliJ so I can see my code /edit it if errors etc
16:18:52 <Cale> and then you use whatever text editor you like best alongside that
16:18:56 <centril> neophytes: my setup is: sublime text 3 in one 1/2 of the window to the left, a terminal with ghci on 1/2 of the window to the right - then I use SublimeLinter-hlint to give me tips inside sublime text for improvements
16:19:02 <Cale> You can even use IntelliJ if you like
16:19:13 <centril> Yes, IntelliJ has a haskell plugin
16:19:16 <Cale> I use SublimeText myself
16:19:26 <Cale> I used vim for years before that
16:19:39 <centril> Cale: there's a vim mode for st3
16:19:46 <centril> im sure you use it
16:19:51 <neophytes> I am wanting to learn functional programming to learn its connections to category theory (math guy here), not much of a programmer so I don't know anything about setting up IDEs or anything as such
16:19:55 <Cale> Yeah, I mostly switched away from ST to get away from vim's keys though
16:20:03 <neophytes> I just need a dumb easy to set up DIE
16:20:07 <neophytes> IDE*
16:20:08 <mengwong> oh lol then for once the tables are turned
16:20:12 <neophytes> so I can start hacking right away
16:20:30 <Cale> Due to the Chinese water torture of hitting u when I meant to hit i all the time
16:20:47 <centril> neophytes: I recommend just going with a text editor with syntax highlighting and a plugin system + ghci like I described
16:20:52 <Cale> and then having to redo, and then find the place where I was going to edit again
16:21:06 <neophytes> okay centril -- does sublime cost?
16:21:19 <bollu> Cale: you don't like vim?
16:21:20 <centril> neophytes: sublime text 3 is good, but a bit pricey... there is Atom if you want a FOSS solution that is free
16:21:24 <freeside> "ghci is simply a CLI IDE installable as part of any haskell platform, so all you have to do is familiarize yourself with the standard packaging system used on your *nix variant and you should be all set, it's easy"
16:21:29 <Cale> bollu: I hate every text editor.
16:21:37 <bollu> Cale: :)
16:21:42 <freeside> revenge of the software people on the math people
16:21:46 <srk> nix* variant :D
16:21:50 <neophytes> okay centril  I'll look into atom and see if I can figure out how to set up Haskell with it
16:22:32 <Cale> bollu: The only reason I'm using Sublime right now is that I haven't been annoyed with its annoyances enough times to switch to yet another thing, but I'm sure they'll eventually get to me too
16:22:48 <freeside> neophytes: have you gone and downloaded https://www.haskell.org/platform/mac.html yet?
16:22:53 <neophytes> no
16:23:09 <neophytes> I need a step-by-step process of what to do.
16:23:14 <neophytes> I'll use atom
16:23:20 <centril> freeside: why not start with stack from the start?
16:23:28 <srk> +1 for stack
16:23:28 <bollu> Cale: I see
16:23:31 <bollu> Cale: what is your idea?
16:23:33 <bollu> ideal*
16:23:34 <neophytes> I don't know what a 'stack' is -- I literally am, new
16:23:45 <freeside> because he wants a one-click situation, and https://www.haskell.org/platform/mac.html includes stack now
16:23:54 <centril> freeside: oh, right
16:23:55 <srk> nice
16:24:00 <centril> that's nice
16:24:09 <freeside> neophytes: get that download going and we can figure out a text editor next
16:24:19 <neophytes> ok, downloading that now
16:24:21 <freeside> what do you normally use to write your LaTeX papers, etc?
16:24:28 <Monoide> neophytes: what area of maths are you from?
16:24:41 <Cale> bollu: I don't even know -- something which doesn't do unexpected bullshit that wastes my time (hard to characterise, but almost every text editor seems to do at least some of this), and makes it easy to flip between contexts where I've recently been working.
16:25:21 <centril> Cale: that is awfully nondescript and vague...
16:25:27 <freeside> it ain't just text editors ... the unexpected bullshit that wastes your time is part of all computing.
16:25:27 <Cale> centril: yes
16:25:38 <Cale> centril: If it were less vague, I'd write my own text editor
16:25:48 <freeside> https://projects.csail.mit.edu/gsb/old-archive/gsb-archive/gsb2000-02-11.html
16:25:50 <neophytes> do I do core or full download freeside ? Monoide, I'm a math newbie but logic.. i got interested in FP because I realized there is a connection between covariance and contravariance (types) and covariant and contra variant functors. 
16:26:11 <Cale> One thing I really like in ST is that it has keys you can press to move through your history of positions without editing anything, across many files
16:26:13 <freeside> go with the full download if you're on a decent connection.
16:26:15 <centril> Cale: I can't really fix code for "makes it easy to flip btw contexts where I've recently been working"
16:26:25 <neophytes> ok @freeside doing so now
16:26:27 <Monoide> just do haskell beaucause it's a good langage and a huge source of amusement
16:26:37 <Monoide> doing it for maths seems a bit ackward (I am a mathematician)
16:26:41 <freeside> yes, the functors you are talking about there are https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/profunctors
16:27:19 <neophytes> sweet freeside -- I want to learn Haskell so I can understand that code! I know the math, not the code there haha
16:27:21 <Monoide> if you like logic don't foret to do some CoQ
16:27:35 <Cale> centril: So Sublime does a nice job there -- I have f12 bound to looking up the definition of the thing under my cursor, and Shift-f12 bound to jumping back in the history of locations, so I can quickly get back to where I was working after looking something up.
16:27:37 <centril> neophytes: if you want proofs about math stuff, then haskell really isn't for you... it's a general purpose programming language
16:27:39 <Cale> That much is good.
16:27:49 <neophytes> but I wanna say I'm very new to this sort of math and programming so I'm learning everything
16:27:51 <centril> neophytes: I'd recommend taking a look at Agda
16:27:55 <neophytes> ok
16:27:59 <centril> if you want to do proofs
16:27:59 <freeside> also you will probably get excited about Coq https://www.cis.upenn.edu/~bcpierce/sf/current/index.html
16:28:17 <centril> freeside: AGDA Agda agda!
16:28:21 <Monoide> Coq coq coq \o
16:28:22 <centril> (and idris)
16:28:42 <freeside> idris, the new 007
16:28:42 <centril> Monoide: even the guy who made Coq uses Agda, i've heard
16:28:48 <Cale> Where ST fails for me right now is that its highlighting for Haskell really sucks (it often gets confused and things that entire blocks of code are type signatures, especially if you put a signature in a pattern or have a let bound definition with a signature on it)
16:28:56 <neophytes> freeside:  it says the installation was successful
16:29:26 <freeside> neophytes: what text editor do you normally use to write your LaTeX papers, etc?
16:29:29 <centril> Cale: OK, but that can be fixed by improving the highlighter for haskell...
16:29:34 <Cale> Yes, sure.
16:29:35 <freeside> (hoping the answer is not "Word")
16:29:41 <MarcelineVQ> Cale: I wonder if any editor survives syntax for promoted types
16:29:44 <centril> Cale: it's not really a big problem...
16:30:03 <neophytes> freeside: text edit but i am on another computer (that is brand new) with nothing on it
16:30:07 <Cale> centril: It's big enough that I want to turn syntax highlighting off or switch to something else sometimes.
16:30:12 <neophytes> (I think that is what its called)
16:30:22 <neophytes> I think I can use sublime 3 license thingy?
16:30:23 <centril> Cale: ST3 for haskell is fine enough for me...
16:30:27 <Cale> (and I'm not going to fix the highlighter -- have you seen the highlighter definition for Haskell? :)
16:30:58 <Cale> There are also some annoyances with how it deals with closing braces
16:31:15 <centril> Cale: haskell is not a big nough language that ST3 devs care that much, probably...
16:31:22 <freeside> you said you wanted $0, so you might prefer Atom to Sublime Text
16:31:26 <Cale> Like, sometimes I'll type } and it will unindent the line "helpfully" when I already had my cursor positioned where I wanted it.
16:31:32 <neophytes> ok freeside 
16:31:37 <neophytes> so how do I set it up with atom
16:31:42 <neophytes> I never used kit
16:31:52 <neophytes> only used ecplise for java (which I am comfortable with)
16:31:59 <neophytes> (both java + ecplise which I cannot spell)
16:32:00 <Cale> That's the kind of "stupid unexpected bullshit" I was talking about before.
16:32:13 <centril> Cale: so recent updates to GHC havent had recent updates in the highlighter for ST3
16:32:17 <centril> neophytes: https://github.com/simonmichael/haskell-atom-setup
16:32:19 <neophytes> I would like high lighting and so on 
16:32:21 <Cale> If I type a printable character, you're not allowed to move my cursor on me before inserting it.
16:32:28 <freeside> well, if you're already familiar with Eclipse, then you can use that as your text editor for haskell, it's not a big deal
16:32:39 <centril> Eclipse... 
16:32:43 <neophytes> ill use something different-- ill use atom
16:32:46 <freeside> if you want to try something different, try Atom: http://atom.io/
16:32:53 <neophytes> ok
16:32:58 <neophytes> so I download that now?
16:33:04 <centril> neophytes: atom is nice, it also VERY similar to sublime text 3
16:33:05 <freeside> yes
16:33:10 <neophytes> k
16:33:12 <centril> but it is open source and free
16:33:23 <neophytes> downloading atom
16:33:29 <Cale> centril: But don't get me wrong, all in all, ST3 *is* okay for me -- for now.
16:33:30 <freeside> there are haskell packages, but why don't we get you running hello world and fibonacci before we install those. https://atom.io/packages/search?q=haskell
16:33:49 <Cale> centril: It's just I'm sure that eventually these little annoyances will gradually piss me off enough to try yet another thing
16:33:56 <centril> Cale: what I most of all want in ST3 is language-server usage, so I can use ST3 more like an IDE for Rust
16:34:00 <Cale> which will have different problems that I'm less annoyed with ;)
16:34:08 <neophytes> ok @ freeside  atom is downloaded
16:34:11 <neophytes> what should I do next
16:34:18 <freeside> okay, well, go run the installers for both of those packages
16:34:24 <neophytes> ok'
16:34:33 <centril> neophytes: you probably want to setup hlint integration some time in the future
16:34:47 <neophytes> wait which packages specially? the one you gave a link to has a lot
16:34:53 <neophytes> https://atom.io/packages/search?q=haskell
16:34:53 <Monoide> just do something that works and you'll complete your future needs in time
16:34:58 <minn> It's been a while since I've used Haskell. Am I supposed to be using Stack to manage packages (among other things) instead of Cabal, or is that not standard?
16:35:07 <centril> what Monoide said
16:35:17 <Cale> centril: btw, do you know how to get ST3 to read a standard tags file (like that emitted by hasktags)?
16:35:18 <monochrom> Both cabal and stack are standards.
16:35:21 <ertes> i'll face the question of editors on wednesday when i give my annual haskell workshop, which will no doubt have a few windows and mac users, and i don't want to force anyone to use emacs =)
16:35:22 <centril> neophytes: start small... add plugins later
16:35:30 <neophytes> ok
16:35:31 <ertes> i'd actually like to give leksah a shot this time
16:35:41 <neophytes> Ii only downloaded atom, not sure what to download next
16:35:43 <centril> Cale: wtf is standard tags file and hasktags ?
16:36:02 <centril> neophytes: nothing... start a project, and open a terminal and write ghci in it
16:36:15 <MarcelineVQ> ertes: there's also yi, iirc leksah is using yi though
16:36:18 <neophytes> how do I start a project? got the terminal open and typed that on
16:36:26 <Monoide> $ghci in terminal
16:36:27 <centril> neophytes: then you edit a file, save it, and go to your terminal, load it, and when you make changes you do :r
16:36:29 <Cale> centril: Many editors support a particular file format for describing the locations of definitions of various names, so that the editor can easily jump you to the definition
16:36:37 <ertes> MarcelineVQ: i considered yi to be among the more advanced editors that require some dedication
16:36:38 <Monoide> then >print "Hey I'm doing some Haskell"
16:36:39 <minn> monochrom: Thanks.
16:36:41 <neophytes> Last login: Sun Mar 12 19:12:30 on ttys000 recursive-functions-MacBook-Pro:~ ternary$ gchi -bash: gchi: command not found recursive-functions-MacBook-Pro:~ ternary$ 
16:36:58 <MarcelineVQ> ertes: in the realm of opening and it and going "well now what do​ I do" I agree
16:37:00 <freeside> typo, yo
16:37:02 <Cale> Sublime is semi-okay at this, but it's really not all that good at it, and often wants to take me to the export declaration instead of the actual definition, for example.
16:37:22 <centril> Cale: ST3 is not an IDE... there are limits to how smart text editors can be
16:37:27 <Cale> right
16:37:30 <neophytes> GHCi, version 8.0.2: http://www.haskell.org/ghc/  :? for help Prelude> 
16:37:32 <ertes> MarcelineVQ: judging by the screenshots leksah has at least one major advantage:  users of the more established IDEs will feel at home instantly
16:37:48 <Monoide> neophytes: print "Hey GHCI, my name is neophytes"
16:38:02 <neophytes> Prelude> print "Hey GHCI, my name is neophytes" "Hey GHCI, my name is neophytes" Prelude> 
16:38:04 <Cale> centril: But you don't have to be all that smart to read a file which has a bunch of strings and file names together with source locations and use that to decide where to jump
16:38:09 <neophytes> ok cool
16:38:12 <centril> neophytes: Monoide: print "Hello World"
16:38:12 <neophytes> so this is the REPL?
16:38:16 <centril> neophytes: yes
16:38:18 <neophytes> ok
16:38:19 <Monoide> neophytes: congratulations, you just did your very first haskell line of code
16:38:19 <Cale> centril: and then leave it up to some other program to generate that file :)
16:38:24 <neophytes> sweet!
16:38:31 <freeside> Prelude> take 10 $ map (+10) [1..]
16:38:37 <neophytes> how do I use the compiler to write code and so on and see it produce a value
16:38:40 <centril> Cale: I think language-server is better
16:38:44 <freeside> now you need to boot up Atom
16:38:46 <Cale> This was originally used for C, but most editors support it, and there are programs to generate them for other languages
16:38:49 <neophytes> Prelude> take 10 $ map (+10) [1..] [11,12,13,14,15,16,17,18,19,20] Prelude> 
16:38:52 <neophytes> okay atom is up
16:38:59 <Monoide> neophytes: the compiler is named 'ghc', you can run it for command line: $ghc you_code.hs
16:39:04 <monochrom> emacs certainly has limits to how smart it can be. Not smart enough to solve the halting problem, something like that. :)
16:39:11 <Monoide> it procuces (if no errors) an executable file you_code
16:39:18 <Cale> ST3 does have a CTags plugin, but it seems to ignore my existing tags file
16:39:19 <centril> effing emacs & vim...
16:39:25 <centril> they should both be banned
16:39:32 <centril> nano rules!
16:39:46 <monochrom> nano doesn't have rules.
16:39:52 <Monoide> nano doesn't
16:39:56 <ertes> how am i supposed to connect to IRC without emacs?
16:40:08 <ertes> how am i supposed to read my mail?
16:40:09 <neophytes> okay so I have atom up what is the "Hello world" of Haskell?
16:40:13 <centril> monochrom: I know of one thing to do in vim:  :q!
16:40:15 <neophytes> I wanna try to compile it
16:40:22 <ertes> neophytes: main = putStrLn "Hello world!"
16:40:30 <neophytes> k
16:40:42 <Monoide> neophytes: to compile it you need to do a module, but then you also want to read a real documentation / tutorial / book
16:40:59 <Cale> ertes: I use HexChat for IRC, and usually a web browser for mail, though my phone often competes with that.
16:41:01 <ertes> neophytes: this line is enough as your main module
16:41:05 <neophytes> ok
16:41:08 <Monoide> (instead of asking IRC, which is fine, but maybe not really needed here)
16:41:12 <centril> neophytes: but you should always try to put types on functions, so   main :: IO () \n main = putStrLn "Hello World!"
16:41:13 <neophytes> I saved it as hello_world.hs
16:41:32 <neophytes> main = putStrLn "Hello world!"
16:41:35 <neophytes> is my source code
16:41:39 <neophytes> so I wanna compile it
16:41:43 <ertes> neophytes: here is the quick way to compile it:  ghc -O -o hello_world hello_world.hs
16:41:52 <ertes> put an ".exe" there, if you're on windows
16:41:55 <neophytes> ok
16:42:11 <centril> neophytes: for real world compilation of haskell, you should take a look at cabal & stack
16:42:24 <monochrom> You don't need "-o hello_world" for this. Unix or Windows.
16:42:29 <centril> noone uses ghc directly like that in real world scenarios
16:42:31 <neophytes> did I not download that already?
16:42:39 <Monoide> ghc hello_world.hs is enough
16:42:49 <freeside> did it compile? good. you now have enough equipment to be dangerous. your next step should be to choose between http://haskellbook.com/ and https://fldit-www.cs.uni-dortmund.de/~peter/PS07/HR.pdf
16:42:55 <centril> neophytes: yes =) but DLing and using is not the same ;)
16:43:11 <ertes> neophytes: which OS?
16:43:18 <centril> freeside: why not  http://learnyouahaskell.com/chapters  ?
16:43:39 <neophytes> recursive-functions-MacBook-Pro:Haskell ternary$ ghc hello_world.hs [1 of 1] Compiling Main             ( hello_world.hs, hello_world.o ) Linking hello_world ... recursive-functions-MacBook-Pro:Haskell ternary$ 
16:43:43 <neophytes> did that work?
16:43:52 <ertes> neophytes: looks good
16:43:56 <Monoide> neophytes: try it!
16:43:58 <neophytes> it didn't print hello world did it? 
16:44:03 <centril> neophytes:  ./hello_world.o
16:44:04 <ertes> neophytes: you should now have a file called "hello_world", which is executable
16:44:15 <ertes> that's your actual program
16:44:19 <neophytes> ecursive-functions-MacBook-Pro:Haskell ternary$ ./hello_world.o -bash: ./hello_world.o: Permission denied recursive-functions-MacBook-Pro:Haskell ternary$ 
16:44:20 <centril> neophytes: or: $ ./hello_world
16:44:34 <Monoide> not the .o
16:44:41 <centril> Monoide: depends on the OS, no ?
16:44:47 <Monoide> it's an object file
16:44:52 <centril> oh, right
16:44:53 <Monoide> it's not an executable
16:45:00 <monochrom> The OS only determines whether you say ./ or .\
16:45:05 <centril> but still, object files might be executable sometimes
16:45:18 <centril> or .o files i mean
16:45:21 <Monoide> well you need linkage
16:45:23 <freeside> why is it that on the radio, everybody spells out URLs saying "backslash" when they should say "slash"?
16:45:30 <ertes> whether you say "./" or ""…  windows has the horrible habit of including . in PATH
16:45:36 <neophytes> so what do I do to execute it
16:45:42 <centril> neophytes: ./hello_world
16:45:56 <Monoide> (you also want to read a few stuff about your Mac's terminal ;)
16:46:00 <ertes> neophytes: or: ./hell<tab>
16:46:03 <neophytes> sweet it worked
16:46:12 <freeside> it worked! now go buy the purple book
16:46:28 <centril> neophytes: you can always use  ls -lah  to see the files in your directory
16:46:29 <ertes> neophytes: try this command:  cabal --version
16:46:46 <ertes> neophytes: if you get a bunch of version numbers, you now have a minimal development environment
16:46:54 <neophytes> ownloading the latest package list from hackage.haskell.org
16:47:01 <freeside> http://haskellbook.com/assets/img/sample.pdf
16:47:03 <neophytes> Downloading the latest package list from hackage.haskell.org cabal-install version 1.24.0.2 compiled using version 1.24.2.0 of the Cabal library  recursive-functions-MacBook-Pro:Haskell ternary$ 
16:47:11 <monochrom> Neat.
16:47:21 <neophytes> freeside: thanks just bought the book
16:47:30 <neophytes> so Im good to go thru that now?
16:47:34 <freeside> yeah
16:47:34 <neophytes> (the book)
16:47:36 <Monoide> yup
16:47:37 <neophytes> ok sweet
16:47:39 <neophytes> sweet do
16:47:42 <neophytes> thanks guys for setting me up
16:47:50 <Monoide> now you need some brain, some hard work and a lot of coffee / tea
16:48:01 <centril> neophytes: now that you've setup haskell... forget all about it, and read:
16:48:01 <monochrom> No, you need sleep.
16:48:03 <centril> neophytes: http://www.cse.chalmers.se/edu/year/2016/course/DAT140/
16:48:07 <neophytes> I'm new to programming + math stuff but very open to lots of hard work + coffeee & tea
16:48:12 <Monoide> (and this channel to answer all your silly questions ;)
16:48:31 <ertes> neophytes: if you have any questions your learning resource doesn't cover, feel free to ask here
16:48:53 <neophytes> centril: just checked and they have a free pdf version of the book you linked with my university access -- will check this out too
16:48:56 <neophytes> ertes:  sweet thanks
16:48:57 <freeside> and being a mathematician you should probably also read some of the foundational papers, like, hm, http://publications.lib.chalmers.se/records/fulltext/local_135303.pdf
16:49:03 <ezyang> String, Text, ByteString, Foundation String; anything I've missed? 
16:49:24 <ertes> neophytes: if you happen to live in germany near stuttgart, you can also visit my workshop on wednesday =)
16:49:36 <neophytes> excellent thanks freeside  (I am an aspiring mathematician / newbie I should say ;-) ) but I have a deep interest in this!
16:49:42 <centril> neophytes: you probably want  Types and Programming Languages (Pierce)
16:49:48 <neophytes> shoot I live in US lol else I would!
16:50:12 <freeside> you can also pick up some videos at https://www.cs.uoregon.edu/research/summerschool/summer10/curriculum.html
16:50:20 <Monoide> you would love https://projecteuler.net/
16:50:27 <neophytes> wow they have videos
16:50:30 <neophytes> excellent
16:50:33 <Monoide> because it's a bunch of exercices to learn haskell, plus it's algorithmic / maths
16:50:39 <freeside> also https://www.cs.uoregon.edu/research/summerschool/summer16/curriculum.php
16:50:41 <neophytes> centril: which one should I read first 
16:50:56 <centril> neophytes: or, just move to Sweden, Gothenburg and start studying at Chalmers Technical University, the world capital of Haskell, Agda, and functional programming
16:51:01 <neophytes> also which universities have research groups in this?
16:51:12 <centril> Chalmers, Chalmers, Chalmers
16:51:18 <neophytes> k
16:51:22 <neophytes> this is my new favorite irc channel
16:51:38 <freeside> you are our new favourite haskell newbie
16:51:41 <ertes> i'm not sure haskellbook.com is suitable, if you're new to programming altogether
16:51:50 <monochrom> The enthusiasm of #haskell participants ensures that every student has enough reading material to learn Haskell for 7 lifetimes (and therefore never getting to use Haskell).
16:51:57 <neophytes> haha
16:51:59 <Monoide> monochrom: :D
16:52:00 <centril> neophytes: but... beware, Donald Trump said that stuff is going on in Sweden :P
16:52:01 <freeside> we're also up for a good editor war anytime
16:52:11 <neophytes> trump says a lot of things 
16:52:15 <neophytes> I'll be careful ;-)
16:52:19 <centril> monochrom: lol :D
16:52:36 <neophytes> k im gonna go read
16:52:41 <neophytes> thanks guys
16:52:44 <centril> ertes: I'd say for a newbie, start with learnyouahaskell
16:52:47 <Monoide> do https://projecteuler.net/  to practice
16:53:12 <minn> I learned to program from Thompson's "The Craft of Functional Programming" and supplementing with some papers by Wadler. Would recommend to anyone.
16:53:17 <Monoide> (it will get you in algorithmic / recursive problems)
16:53:27 <ertes> centril: honestly i don't recommend that one, regardless of whether one is a programmer or not
16:53:28 <Monoide> (so you can learn good usage without going too deep too quickly)
16:53:46 <freeside> i just worked through the purple book, i'm a big fan of it. imho the best and most comprehensive
16:54:05 <centril> neophytes: so: my recommendation:  learnyouahaskell -> your book -> write a compiler for a small imperative language + a small functional language -> (forget about haskell) -> http://www.cse.chalmers.se/edu/year/2016/course/DAT140/  -> Types and Programming Languages
16:54:13 <ertes> the resource i'd recommend without hesitation is this: https://www.seas.upenn.edu/~cis194/spring13/lectures.html
16:54:14 <freeside> i was disappointed by Learn You A Haskell -- it had the whimsy of Why's Poignant Guide to Ruby but not the rigour
16:54:19 <neophytes> centril: sounds good
16:54:24 <neophytes> copying your comment
16:54:27 <neophytes> pasting in my notepad
16:54:39 <centril> freeside: you dont want rigour for an intro course to FP...
16:54:44 <centril> you want: get shit done fast
16:55:12 <monochrom> freeside: Does "purple book" mean haskellbook.com?
16:55:17 <freeside> yes
16:55:21 <MarcelineVQ> ertes: idk about that, haskellbook.com is called haskell programming from first principles for a reason, I'm not sure there's a better place to start with haskell if you're entirely new to programming
16:55:22 <centril> and for that LYaH (LearnYouAHaskell) is nice
16:55:25 <ertes> CIS194 has, as far as i see, very good pacing *and* correctness
16:56:02 <monochrom> I don't think LYAH gets shit done fast either.
16:56:08 <ertes> MarcelineVQ: the name alone doesn't cut it though =)
16:56:14 <freeside> neophytes, you should get used to using Atom instead of TextEdit
16:56:24 <Monoide> neophytes: stop listening to us
16:56:25 <centril> neophytes: for the purposes of mathematical proofs, you want to learn haskell just to familiarize yourself with coding in FP, and then move on to Agda
16:56:30 <Monoide> just do what tf you want and have fun
16:56:37 <Monoide> fun is what you want, and should be your only goal
16:56:47 <centril> also ^
16:56:59 <freeside> also **
16:57:06 <Monoide> if you want ideas to have fun, I have a bunch just ask me :)
16:57:14 <neophytes> okay centril 
16:57:27 <neophytes> https://www.youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_ -- just found this guy 
16:57:49 <centril> neophytes: but if you want general purpose programming, then haskell is really nice
16:57:50 <ertes> centril: you know, you could just pay someone to beat the crap out of you…  doing proofs in agda achieves the same thing, but much much slower
16:58:01 <monochrom> Also, rigour or not depends on personality, not absolute mandate.
16:58:18 <freeside> looks good ... soon you too will be able to talk about FP in incomprehensible terms
16:58:20 <centril> ertes: say what ?
16:58:24 <neophytes> lol
16:58:27 <neophytes> im gonna go read
16:58:29 <neophytes> thanks guyys
16:58:34 * neophytes afk
16:58:40 <neophytes> guys*
16:58:42 <ertes> centril: the next time you pass six universe level variables around you will remember this conversation
16:58:43 * neophytes afk now
16:58:46 <centril> neophytes: now I have to thank you... gonna watch those
16:58:50 <monochrom> FWIW for example when I learned Haskell (or anything) I went for rigour. Maybe not absolute rigour, but rigour enough so that it was scientific not cargo-culting.
16:58:58 <centril> ertes: :D
16:59:19 <centril> ertes: at least it doesn't have  :t * :: *    ^^
16:59:25 <monochrom> But cargo-culting works fine for some people too, so I don't always inflict my degree of rigour to everyone.
16:59:46 <freeside> you don't want to build your tech stack on sand.
17:00:12 <freeside> known knowns are preferable to known unknowns and unknown knowns.
17:00:47 <centril> freeside: no... but you want to get started with programming in a way that lets you do something so you dont get bored
17:01:02 <freeside> in most cases, i would agree, but neophytes is a self-declared mathhead so
17:01:06 <centril> freeside: at least that is important to first year university students
17:01:23 <centril> freeside: but not programming-head tho ;)
17:01:40 <freeside> as for the unboring stuff, i think web interaction and graphics programming are my top candidates for getting quick wins
17:01:42 <centril> Math is nice, but it is not CS
17:01:59 <centril> freeside: some purescript love ?
17:02:06 <freeside> well, we'll see what happens when he/she comes back
17:02:40 <centril> Cale: http://langserver.org/
17:04:08 <centril> Cale: https://github.com/sourcegraph/sublime-lsp
17:05:05 <centril> god... every time I see code written in Go I get crazy mad & sad...
17:05:25 <freeside> langserver looks nice, like netpbm for languages
17:05:34 <centril> Go Induces Uncontrollable Rage (TM)
17:05:52 <centril> freeside: =)
17:18:11 <Cale> centril: How... how does that help me though?
17:18:32 <centril> Cale: not sure, but it makes text editors more like IDEs
17:18:54 <Cale> I don't actually want my text editor to be much like an IDE
17:19:02 <centril> so jumping to language definitions and stuff becomes better
17:19:07 <Cale> I just want it to read a file consisting of strings, filenames, and line numbers
17:19:18 <Cale> and be able to jump to the appropriate file when I press a button :)
17:19:44 <centril> Cale: for the purposes of jumping to a function def, right ?
17:19:46 <c_wraith> so..   you like tag files
17:19:52 <freeside> i use emacs, i don't know what you all are talking about because i can't tell the difference between a text editor, an IDE, an operating system, and a tetris arcade game
17:19:56 <monochrom> I don't think the point is IDE. I think the point is reducing from M languages x N editors to M + N.
17:20:03 <centril> freeside: LOL
17:20:34 <Monoide> freeside: «emacs is a cool OS, just lacks a good text editor» ;)
17:20:38 <Cale> c_wraith: Well, yeah, my current concern was how to get Sublime Text to read tags files -- there appears to be a package for it, but I've not been able to get it to actually do the thing it's supposed to do.
17:20:57 <ertes> "IDE" doesn't really mean anything…  if we take the abbreviation itself apart, my emacs acts pretty much like an IDE:  it has most haskell stuff *integrated*, and i'm *developing* with it
17:21:05 <monochrom> I don't like emacs as OS because it has poor concurrency.
17:21:15 <centril> monochrom: well... M + N, for behaviors that are common to IDEs
17:21:27 <monochrom> If not for that, I would be using emacs for everything since 20 years ago.
17:22:33 <centril> I loathe any editor that separates view and input mode
17:22:43 <monochrom> I even almost chose emacs as my main web browser.
17:23:03 <Cale> I would take something which had IDE-like behaviour, but the trouble is, all the Haskell projects I work on require custom nix shells, and have all sorts of dependencies that I don't have installed globally -- so it's fairly unlikely that any of the more advanced tools are going to work.
17:23:21 <freeside> oh, you just haven't done enough yak shaving in emacs
17:23:30 <ertes> Cale: i have nix integrated into my emacs, plus local packages (via nix)
17:23:39 <freeside> you are like twenty lines of ELISP away from getting exactly what you want
17:23:53 <ertes> Cale: my GHCi in haskell-interactive-mode is actually wrapped by nix-shell
17:24:20 <freeside> see? all it takes is yak shaving
17:24:30 <Cale> But then I have to put up with emacs
17:24:39 <Cale> I guess I could live with it somewhat
17:24:47 <ertes> that's up to you of course
17:24:48 <freeside> right, how else were you planning to procrastinate?
17:25:05 <monochrom> IRC is how I plan to procrastinate. :)
17:25:30 <monochrom> Pretty sure that speaks for everyone too :)
17:26:06 <Cale> ertes: I actually don't care at all about ghci integration. Mostly I just want jump to definition.
17:26:07 <centril> monochrom: no, I was actually here for real stuff, but then I changed to procrastination
17:26:16 <ertes> Cale: ultimately it's a question of whether you want to sacrifice your pinky to a life-long relationship with an editor
17:26:22 <Cale> (ghci integration is going to be much more complicated)
17:26:38 <ertes> Cale: well, most editors have TAGS support, but h-i-m actually does better: it asks GHCi
17:26:43 <ertes> so it's much more precise
17:26:53 <Cale> ah
17:27:09 <Cale> It's not using one of the other things built on top of the GHC API?
17:27:14 * monochrom hugs his pinky
17:27:27 <ertes> Cale: nope, it uses GHCi directly
17:27:38 <ertes> (which i appreciate…  i've heard horror stories about ghc-mod)
17:27:39 <jgt> I'm trying to add (MonadLogger m) to some of the type constraints in https://github.com/nakaji-dayo/yesod-job-queue. When I do that, I get this error: http://sprunge.us/MMKZ. I'm trying to fix it by writing `instance MonadLogger IO where monadLoggerLog _ _ _ = return ()`, but then I get this error: http://sprunge.us/MXgK
17:27:50 <jgt> anyone what how to fix this?
17:28:37 <monochrom> ghc-mod is version-brittle. You use a newer GHC, you have to rebuild ghc-mod all over again. (Everything that uses the GHC API is this way.)
17:29:10 <ertes> monochrom: also about its RAM hunger
17:29:18 <minn> Not that it's particularly hard to write, but: is there a monadic version of takeWhile hiding somewhere in the standard library?
17:29:27 <Cale> Well, I have 64GB of memory for a reason ;)
17:29:29 <freeside> somebody please help jgt, i don't know enough Yesod
17:29:29 <ertes> i have enough RAM, but i'd like to use it for my application =)
17:30:09 <freeside> minn: google suggests https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html
17:30:10 <jgt> freeside: thank you 😌
17:30:14 <ertes> minn: you should use a stream abstraction, because monadic takeWhile will perform badly
17:30:17 <Cale> jgt: You don't need to do that
17:30:18 <ertes> minn: for most monads at least
17:30:29 <jle`> jgt: without knowing too much, it sounds like you're missing a _
17:30:30 <Cale> jgt: Presumably your monad is an instance of MonadLoggerIO, no?
17:30:39 <ertes> minn: take a look at pipes for example
17:30:44 <ertes> @package pipes
17:30:44 <lambdabot> http://hackage.haskell.org/package/pipes
17:30:53 <Cale> jgt: You can just use the thing I mentioned before to get a plain IO action for logging and use it
17:30:56 <jle`> jgt: monadLoggerLog takes four arguments
17:31:29 <jgt> Cale: I don't think so; the compiler was asking me to add (MonadLogger m) to the type constraints for a few functions
17:31:32 <minn> freeside: I must have missed that - thanks.
17:31:37 <jle`> jgt: your error comes from the fact that 'return ()' is interpreted as '\_ -> ()'
17:31:44 <Cale> jgt: Yeah, well, you can't use monadLoggerLog directly
17:31:55 <Cale> jgt: But you can do something like
17:32:03 <Cale> log <- askLoggerIO
17:32:08 <Cale> and then use log instead
17:32:12 <ertes> minn: note that you will most likely sacrifice laziness…  again: use a stream abstraction
17:32:13 <Cale> (probably liftIO'ed)
17:32:13 <jgt> Cale: I could add another _ arg; I assumed one would be missing because `$(logInfo)` takes some thing to log
17:32:16 <minn> ertes: I will look into that. I'm translating some Python code that used generators to perform cycle detection on infinite graphs using iterators.
17:32:44 <Cale> jgt: Can you link me to the code which is trying to do logging?
17:32:52 <Cale> or stick it on lpaste.net?
17:33:05 <Cale> oops
17:33:06 <ertes> minn: yeah, pipes is pretty much python's generators, but on steroids
17:33:09 <Cale> he's gone
17:33:49 <minn> Ah, I see - there's a pipes library - neat. Thanks :)
17:34:10 <Cale> ertes: you know what, let's try this emacs shenanigans. What do?
17:34:26 <ertes> Cale: are you completely new to emacs?
17:34:44 <Cale> I used it for a 2 month period back in 2004
17:34:52 <freeside> but the coughing got so bad you had to stop
17:34:56 <Cale> So pretty much
17:35:10 <Cale> Oh, and I've used it for Agda a bit
17:35:18 <Cale> (but that hardly counts)
17:35:21 <freeside> agda is practically an emacs extension as i understand it
17:35:32 <jgt> jle`: actually just adding that fourth _ arg seems to have fixed it
17:35:37 <jgt> I'll check if logging is actually working
17:35:54 <freeside> dude do you even liftM
17:35:55 <ertes> Cale: in that case i suggest that you familiarise yourself with the basics first:  dealing with files, switching between buffers, handling windows, and very importantly: using the built-in help system
17:36:00 <jle`> jgt: oh, that fix shouldn't actually let you log anything
17:36:03 <freeside> lol
17:36:16 <Cale> ertes: I'm going to use the mouse to do all of those things, it'll be okay
17:36:17 <jle`> jgt: it was just to fix the compiler error heh
17:36:22 <ertes> Cale: after that you can set up haskell-mode, which you should still be able to manage on your own
17:36:28 <jgt> jle`: Oh, yeah, I thought so
17:36:35 <ertes> Cale: once you have that, i will help you with setting up haskell-interactive-mode and integrating nix
17:36:43 <freeside> i <3 nix
17:36:59 <Cale> ertes: Which version of emacs should I install?
17:37:04 <Cale> Does it matter?
17:37:04 <freeside> ALL OF THEM
17:37:09 <ertes> Cale: it also helps to understand the haskell override system in nixpkgs in order to add your local packages to the haskellPackages set
17:37:19 <ertes> Cale: the latest
17:37:26 <Cale> Oh, I've mostly relied on other people understanding that for me.
17:37:29 <jle`> jgt: some more context would be helpful :)
17:37:34 <freeside> i am happy with http://emacsforosx.com
17:37:51 <ertes> Cale: well, you can use reflex-platform (i assume this is what it's mostly about), or you can use my method via package overrides
17:38:13 <ertes> if you use the former, you should be all set
17:38:27 <mbw> Hello everyone. I have a question about adding type signatures to local expressions in where blocks. I know that there is -XScopedTypeVariables, which helps in this regard, i.e. lets you avoid these "could not match a with a0" errors. However, how would you type signatures here: http://lpaste.net/353472 ? This is taken from https://github.com/Gabriel439/slides/blob/master/munihac/foldmap.md .
17:38:40 <freeside> muahaha, the yak shaving begins
17:38:43 <Cale> ertes: Okay, I'll assume everything will be fine :)
17:38:52 <jle`> mbw: can you paste the error too?
17:38:59 <ertes> Cale: assuming you're using nix for package management, you can get everything from nixpkgs
17:39:09 <mbw> of course
17:39:16 <Cale> I'm only using nix for project package management, not for system packages.
17:39:19 <jle`> mbw: but i'm also not sure where the problem is
17:39:25 <ertes> Cale: nix-env -iA nixos.{emacs,emacsPackagesNg.haskell-mode}
17:39:27 <jle`> it looks like you typed the signatures in properly and then uncommented it
17:39:36 <jle`> 'where' should be one line up though
17:39:43 <ertes> Cale: ok
17:39:44 <jle`> is your question purely a syntax one?
17:39:50 <jle`> where tally :: i -> ...
17:40:06 <Cale> (I tried nixos for a couple days, it was too much work to get a desktop configuration that I liked)
17:41:05 <mbw> http://lpaste.net/353472
17:42:05 <mbw> I had the 'where' in the correct position. The types are the ones inferred from ghc.
17:42:29 <jle`> mbw: what happens when you uncomment out the type signatures?
17:42:30 <mbw> The problem is the Monoid constraint in 'Fold', which is hidden.
17:42:39 <mbw> It compiles then.
17:43:16 <mbw> Or do you mean all of them? I'll check...
17:43:39 <jle`> oh
17:43:53 <jle`> ah i didn't notice your existential data type
17:44:44 <mbw> Yeah, that's the problem. This is something Mr. Gonzalez came up with, actually, in order to hide the constraint from the user, if I understood correctly.
17:45:39 <mbw> It's not a big deal to drop the constraint, probably, but maybe there's some way to make it work.
17:45:56 <jle`> mbw: you can provide type annotations to the bindings
17:45:58 <lyxia> you can bind existential type variables by annotating the pattern
17:46:22 <jle`> combine (Fold (tallyL :: i -> m1) ...)
17:46:32 <jle`> and then you can use those in your type signatures
17:46:34 <jle`> yeah, that
17:46:35 <ertes> Cale: once you have haskell-mode up (if all else fails, just follow haskell-mode's official guide), ping me…  the indicator is that you can load a *.hs file with syntax highlighting
17:46:43 <mbw> ok I'll try it.
17:46:50 <jle`> you can also avoid scoped type variables altogether by passing in tallyL and tallyR as arguments to tally
17:46:56 <jle`> tally tL tR x = ...
17:47:08 <jle`> and then Fold (tally tallyL tallyR) ....
17:47:11 <jle`> that might be a little less noisy
17:47:19 <ertes> Cale: i'll guide you through the rest, but it'll most likely be tomorrow
17:48:17 <mbw> The ScopedTypeVariables thing stems from my frequent usage of typed holes.
17:48:48 <jle`> mbw: so you might even want to write a standalone function combineTallies :: (Monoid m1, Monoid m2) => (i -> m1) -> (i -> m2) -> i -> (m1, m2)
17:48:56 <mbw> So it's just some temporary representation.
17:48:57 <jle`> (which is just liftA2 (,))
17:48:58 <freeside> indeed, it appears to underscore your reliance on typed holes.
17:49:13 <jle`> and something similar for combineSummarize
17:49:36 <jle`> this wouild be the way that doesn't rely on scoped type variables, and also doesn't require you to add type annotations/bindings to your pattern matches
17:49:43 <jle`> which i always thought was kind of ugly, syntactically
17:49:44 <mbw> freeside: Is that a bad thing?
17:49:49 <freeside> _
17:50:12 <freeside> joke
17:52:59 <mbw> jle`: Would you have an educated guess at why the existential type is used in the definition of Fold? It seems to be more trouble than it's worth, right now. The constraint would follow from the functions working on Fold, anyway.
17:54:08 <mbw> I didn't even have these problems when implementing lens stuff.
17:54:25 <jle`> is there a blog post or article associated with this?
17:54:32 <jle`> tekmo usually explains these things pretty well
17:55:00 <jle`> one guess would be that it lets Fold have an Applicative instance i suppose
17:55:05 <jle`> but that's not a good guess
17:55:16 <ertes> mbw: you need it for the Functor instance
17:55:19 <jle`> oh wait it doesn't need it for an Applicative instance
17:55:29 <jle`> you need it for a Comonad instance
17:55:51 <mbw> This all comes from here: https://github.com/Gabriel439/slides/blob/master/munihac/foldmap.md, which are slides from a talk, given here: https://www.youtube.com/watch?v=6a5Ti0r8Q2s .
17:56:11 <edwardk> existential type in Fold?
17:56:18 <edwardk> oh
17:56:25 <edwardk> the Moore machine Fold
17:56:32 <ertes> it's basically the same idea as in Coyoneda
17:57:09 <edwardk> data Fold a b where Fold :: (r -> b) -> (r -> a -> r) -> r -> Fold a b -- that one?
17:57:29 <edwardk> without 'r' being held existentially, e.g. by using
17:57:37 <jle`> mbw: you need the Monoid constraint for 'foldMapOf'
17:57:46 <jle`> in the focus function
17:58:08 <edwardk> data Fold a r where Fold :: (r -> a -> r) -> r -> Fold a r  -- then we are invariant in 'r'. so you basically get no useful instances, except contravariant stuff if you flop the arg order
17:58:13 <mbw> data Fold i o = forall m. Monoid m => Fold (i -> m) (m -> o). I haven't worked through the whole thing yet, so I don't know yet whether these things are all related.
17:58:21 <edwardk> as it is, the Fold type above is isomorphic to the Moore machine tyupe
17:58:33 <edwardk> data Moore a b = Moore b (a -> Moore a b)
17:58:46 <edwardk> except, its more efficient to map over repeatedly
17:59:23 <edwardk> as if you fmap over the 'b' argument in Moore you have to pay for it for each 'a' you feed the result, but with Fold, you only pay once for the final 'b' you want out at the end
17:59:48 <edwardk> mbw: that one works too. its in my folds package
18:00:21 <mbw> I see. Thanks, I will definitely check that out as well.
18:00:23 <edwardk> http://hackage.haskell.org/package/folds-0.7.1/docs/Data-Fold-M.html
18:00:47 <edwardk> note there i explicitly 'unpack' the monoid, but you can do it the other way just as well by using reflection earlier
18:01:08 <edwardk> i use reflection to pass the locally defined monoid through foldMap
18:01:34 <edwardk> http://hackage.haskell.org/package/folds-0.7.1/docs/Data-Fold-L.html is the Moore style fold
18:02:11 <edwardk> jle`: anyways you need it for Functor, so you need it for both Comonad and Applicative ;)
18:03:01 <jle`> does `fmap k (Fold tally summarize) = Fold tally (k . summarize)` not work?
18:04:55 <mbw> In the meantime, thanks for these references!
18:05:27 <edwardk> jle`: Fold :: (r -> a -> r) -> r -> Fold a r  -- would have r occurring in positive and negative position
18:05:56 <edwardk> you can't 'fmap' out r then
18:06:22 <edwardk> the existential version hides r and only operates covariantly on b, a function of r.
18:06:30 <edwardk> so it is a functor
18:23:11 <centril> edwardk: Say I have:  type Normalizer a = a -> Maybe a ; Which yields Nothing on "no change", Just x on normalization of the term ;  And then, I have an AST where I want to apply a certain Normalizer myNorm deeply, and want to do this w/o doing case l :+: r -> case (myNorm l, myNorm r) of (Just l', Just r') -> Just $ l' :+: r' ; (Just l', Nothing) -> Just $ l' :+: r ; (Nothing, Just r') -> Just $ l :+: r';
18:23:14 <centril> (Nothing, Nothing) -> Nothing ; ... is there a way to do this sort of thing smoothly ?
18:23:56 <centril> s/case l :+: r ->/case e of l :+: r ->
18:25:55 <centril> doing the manual case matching becomes problematic due to combinatorial explosion when dealing with complex AST constructors...
18:27:41 <centril> I guess I could do like: l2 :: (a -> b -> c) -> a -> b -> Maybe a -> Maybe b -> Maybe c , and for (a -> b -> c -> d), but it is not exactly very composable and elegant...
18:32:17 <lyxia> case (myNorm l, myNorm r) of (Nothing, Nothing) -> Nothing ; (l', r') -> Just $ fromMaybe l l' :+: fromMaybe r r'
18:33:49 <centril> lyxia: right, how do you generalize this to N instead of 2, and preferably some way that works with lenses
18:33:51 <centril> :P
18:35:12 <Zemyla> Okay, so it seems that, if I'm storing a value of type c => r that it's always stored in thunk form.
18:41:49 <lyxia> centril: how is it supposed to work with lenseS?
18:43:14 <lyxia> centril: This looks like the (,) All monad.
18:43:54 <lyxia> or (,) Any, as in "did normalization happen Anywhere"
18:43:58 <oisdk> centril how about https://gist.github.com/oisdk/92b43b63ee6aba451d5daf55af528d04
18:44:29 <lyxia> there you go :D
18:45:26 <centril> lyxia: so I write an AST, data E = L Int | V String | E :+: E | E :*: E  (but with records...), derive lenses for E, then, in a normalizer, I then use a lens to apply a normalization for some lens, then do it for another, and so on and "sum" the results
18:45:40 <centril> that's a really vague and poor description I know
18:46:45 <centril> oisdk: I have some reading to do =) thanks!
18:49:42 <centril> lyxia: "Did normalization happen anywhere?" is exactly the right semantics
19:21:31 <jle`> Zemyla: yes, a value of c => a is basically a function
19:21:42 <jle`> Dict c -> a
20:06:01 <redmq> what's the best resource for learning how to use ekmett's linear package effectively?
20:13:34 <jle`> redmq: there's the ocharles tutorial from the 24 days of hackage series
20:13:47 <jle`> but mostly just looking at the typeclasses should help you get started
20:14:46 <redmq> yeah, poking at the typeclasses and things like liftU2 atm.. thanks for the ocharles reference!
20:15:48 <jle`> most of the package is sort of just "normal" haskell data types and typeclasses
20:16:41 <jle`> `data V3 a = V3 a a a` for instance
20:16:56 <jle`> and it has num instances, dot products, norms, etc.
20:17:06 <redmq> yeah, the implementations of *^ and ^* are nice
20:36:10 <juri_> ok, hlint is nice.
20:40:42 <_sras_> Can Lens libraries help with transformations between records?
21:09:06 <grayhatter> Varible not in scope https://gist.github.com/6f6ed719c05743bcb4f7a2002e67ba26
21:09:40 <grayhatter> is there some magic I'm missing to get first show to work?
21:11:46 <Clint> grayhatter: did you import Control.Arrow (first)?
21:12:11 <grayhatter> I did not
21:12:13 <grayhatter> hmmm
21:12:45 <grayhatter> Clint: that worked
21:12:52 <grayhatter> how would I know that otherwise?
21:13:04 <grayhatter> I found First Show here https://hackage.haskell.org/package/base-4.9.1.0/docs/Text-Show.html
21:13:12 <grayhatter> but it meantions nothing about Control Arrow
21:13:21 <grayhatter> unless I'm blind
21:13:41 <Cale> Where did you see that?
21:14:00 <Cale> I see instances of show for the type "First" there...
21:14:04 <Cale> but that's unrelated
21:14:14 <grayhatter> oh, then I really don't know what I'm doing
21:14:51 <grayhatter> I googled "first show" looking for help and got that page, and it seemed like what I was looking for
21:16:05 <Clint> it isn't
21:16:20 <grayhatter> yeah, makes sense now 
21:16:22 <Cale> But how did you get the idea to use the first function in the first place?
21:16:36 <grayhatter> https://wiki.haskell.org/Roll_your_own_IRC_bot
21:16:47 <grayhatter> which has Import Control.Arrow
21:16:56 <grayhatter> but I dropped it somehow, and it was never needed before
21:16:57 <Cale> ah, yes
21:17:06 <Cale> Well, it's hardly used, apart from that :)
21:17:08 <grayhatter> and there wasn't any issue before 
21:17:39 <grayhatter> I JUST tried adding the last part, and the last section finally added Control.Arrow
21:18:14 <Clint> so the answer to your question might be to use hoogle or hayoo to find out where "first" comes from then
21:18:15 <grayhatter> thanks Clint
21:18:35 <grayhatter> Clint: I tried using google (hoogle is generally worthless to me)
21:18:48 <grayhatter> I'll add hoogle as my 2nd stop from now on
21:19:26 <grayhatter> ahh, 3rd result on google too... I should'nt have given up so soon -_-
21:31:02 <qmm> can somsone give me an example how i can use overloadedstrings with text?
21:31:20 <qmm> via lpaste please
21:38:43 <barrucadu> qmm: It just lets you use "string literals" as text literals: http://lpaste.net/1857030866790776832
21:38:43 <redmq> ok, i've figured out most of what i wanted to with the `linear` package. starting to spin my wheels on something basic though: how do i extend a vector?
21:39:53 <redmq> the closest i've found to the answer seems to be "deconstruct it and then reconstruct it" as in https://hackage.haskell.org/package/linear-1.20.5/docs/src/Linear.Matrix.html#m33_to_m44
21:40:59 <redmq> for padding a matrix, this is rather verbose
21:42:20 <johnw> qmm: it means that ("Foo" :: Text) type checks
22:36:07 <jle`> @tell redmq yes, that's outside of the use case of the library, kinda
22:36:07 <lambdabot> Consider it noted.
22:37:03 <jle`> @tell redmq if you can express what you want as a linear algebra operation, though, then it'll work smoothly
22:37:03 <lambdabot> Consider it noted.
23:32:33 <hololeap> I can't figure out how to "build" something of the type :: StateT s (ExceptT e m) a
23:37:39 <hololeap> I figured out `ExceptT e (StateT s m) a`: i just use `ExceptT . StateT $ f` where f has the type :: s -> m (Either e a, s)
23:38:02 <pacak> > return () :: StateT Int (ExceptT e m) ()
23:38:05 <lambdabot>  error:
23:38:05 <lambdabot>      • No instance for (Monad m1) arising from a use of ‘return’
23:38:05 <lambdabot>        Possible fix:
23:38:15 <pacak> > return () :: StateT Int (ExceptT e Identity) ()
23:38:21 <lambdabot>  error:
23:38:21 <lambdabot>      • No instance for (Show (StateT Int (ExceptT e0 Identity) ()))
23:38:21 <lambdabot>          arising from a use of ‘show_M707421031500494450431539’
23:38:48 <Eduard_Munteanu> > runExceptT . runStateT $ do { get; return 0 }
23:38:51 <pacak> hololeap: What do you mean "build"?
23:38:55 <lambdabot>  error:
23:38:55 <lambdabot>      • Couldn't match type ‘a0 -> m0 (Integer, a0)’ with ‘ExceptT e m a’
23:38:55 <lambdabot>        Expected type: StateT a0 m0 Integer -> ExceptT e m a
23:39:19 <Eduard_Munteanu> > runExceptT . (`runStateT` 1) $ do { get; return 0 }
23:39:30 <lambdabot>  error:
23:39:31 <lambdabot>      • Ambiguous type variables ‘e0’, ‘m0’, ‘a0’, ‘a1’ arising from a use of ...
23:39:31 <lambdabot>        prevents the constraint ‘(Show
23:40:53 <Eduard_Munteanu> hololeap, just write it as above, you only need to unpack/run it explicitly
23:41:38 <Eduard_Munteanu> :t get
23:41:40 <lambdabot> MonadState s m => m s
23:42:03 <hololeap> pacak: I'm not sure how else to explain it... how do you go from something of the form `s -> m (Either e (s, a))` to `StateT s (ExceptT e m) a`
23:42:59 <Eduard_Munteanu> hololeap, do you actualy have a 's -> m (Either e (s, a))'?
23:47:49 <hololeap> Eduard_Munteanu: yes
23:48:34 <Eduard_Munteanu> Oh well, in that case just wrap it in ExceptT and StateT. But just note that you don't have to write your monadic functions that way.
23:50:25 <Eduard_Munteanu> e.g. you can simply write 'return ()' instead of 'StateT . ExceptT $ \s -> return (Right (s, ()))'
23:53:06 <hololeap> Eduard_Munteanu: could you show me with this example i wrote (using the `ExceptT e (StateT s m) a` form): https://gist.github.com/hololeap/d3ba45d0d6cd0c8c6d2b43ed858aaff0
23:54:42 <hololeap> am i being needlessly expressive?
