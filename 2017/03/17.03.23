00:14:13 <spatial> http://lpaste.net/353843 In this section unless (r1 < 0.01) $ do           d <- (update d state nv)           return () isn't in scope later
00:14:52 <spatial> Looks like (nv,d) <- nextvalue O (randomgreedy r1 rm gm) c newstate is the 'd' in scope.
00:15:39 <spatial> Is that right ? Will 'd' have the updates done within 'unless' ?
00:16:02 <kadoban> spatial: The "d" in that inner do block is indeed a new binding, that quickly goes out of scope.
00:16:04 <geekosaur> suggest you compile that with -Wall
00:17:35 <pacak> spatial: Lines over 100 characters are just ugh.
00:19:19 <spatial_> Had to leave. Couldn't refactor because unless needs return()
00:19:38 <spatial_> http://lpaste.net/353843 I mean this.
00:19:58 <pacak> spatial_: Lines over 100 characters are just ugh.
00:20:26 <spatial_> pacak: Not a haskell expert.
00:20:49 <pacak> I suspect they are bad style in any language. Except for maybe Java.
00:20:57 <spatial_> You mean the characters. I can reduce that.
00:21:52 <geekosaur> there's no particular reason you have to use unless there
00:21:58 <pacak> It looks like whatver on that long line is - can be placed in a separate function.
00:22:03 <pacak> Add more type signatures
00:22:20 <pacak> Try to look at formatting in base and other libraries with lots of users
00:22:40 <pacak> If you make your code more readable - it will be easier to develop and debug.
00:22:45 <geekosaur> d' <- if r1 < 0.01 then return d else update d state nv
00:22:58 <spatial_> Yes.
00:23:28 <spatial_> geekosaur: That condition is needed.
00:23:40 <geekosaur> (except I't write on multiple lines)
00:23:56 <osa1> I'm trying to add someone as a maintainer in a package. the request seems to be successful but I don't see his hackage name in the "maintainers for <package>" page. is that expected?
00:23:59 <geekosaur> that condition is also present
00:24:50 <geekosaur> unless is not magic, it's an if-then-else with `return ()` in the else (which is why the then leg has to also produce m ())
00:24:53 <spatial_> Any refactoring idea ?
00:25:21 <spatial_> You mean the function returns at return ()
00:25:31 <spatial_> I didn't intend that.
00:26:15 <geekosaur> what?
00:26:30 <geekosaur> no, I mean then and else types must match
00:26:42 <spatial_> unless that cond is satisfied continue. Otherwise updata and continue.
00:26:50 <geekosaur> yes
00:27:15 <geekosaur> and the if I wrote does the same thing, while letting you get at the value
00:28:24 <spatial_> if-then-else (r1 < 0.01)  d <- (update d state nv)
00:29:04 <geekosaur> what?
00:29:28 <spatial_> Is that what you mean ?
00:29:46 <geekosaur> [23 07:22:23] <geekosaur> d' <- if r1 < 0.01 then return d else update d state nv
00:30:50 <spatial_> Ok. I can use that. But code is peppered with such 'returns'. So decided to use when and unless.
00:30:53 <geekosaur> (I switched the result to d' because shadowing bindings just causes confusion. you've already demonstrated one such, by thinking that it's doing an update like in e.g. python)
00:32:59 <geekosaur> that might be a symptom of trying to program as if in a procedural language
00:33:28 <spatial_> Right
00:39:53 <joneshf-laptop> Is statically linking a binary really a thing you should do with GHC? I've been trying to figure it out for a bit now, and it doesn't seem like there are any instructions that really work.
00:42:15 <geekosaur> joneshf-laptop, the real problem with -static is not with ghc, but with glibc becoming fragile
00:42:33 <spatial_> game state newstate a  = do   gameplan a state newstate    'game' returns what 'gameplan' returns. Right ?
00:42:42 <cocreature> alpine has ghc built against musl which should avoid the glibc problems
00:45:34 <joneshf-laptop> geekosaur, I'm sorry, what does that mean?
00:46:43 <geekosaur> glibc dlopen() a bunch of shared objects (nss modules for nameservice lookups, locale modules, ...) at run time. the ABI changes often, such that you can't reliably use one glibc version's shared objects with a different one
00:47:26 <geekosaur> if you like statically and copy the binary elsewhere, you need to copy along the appropriate shared objects and make sure the program uses them instead of the ones on the target system, or you can get core dumps or weirdness
00:47:40 <geekosaur> (ld will warn you of this if it detects globc being linked statically)
00:47:44 <geekosaur> *glibc
00:48:19 <joneshf-laptop> interesting.
00:48:43 <joneshf-laptop> Do I not understand what static linking means?
00:48:57 <geekosaur> it means that you use .a files instead of .so files in the link
00:49:18 <geekosaur> which means the actual library code is linked instead of stubs that load the shared objects at runtime
00:50:18 <geekosaur> there is a difference between linking statically and building ghc static libraries; the problem is that you can't easily use ghc static libraries with a ghc built for dynamic libraries, and trying to use -static to overcome this will break glibc as I described
00:50:41 <joneshf-laptop> I think I sort of understand now.
00:50:43 <joneshf-laptop> Thanks.
00:51:10 <joneshf-laptop> So, is the solution to use a ghc built for static libs then?
00:51:14 <joneshf-laptop> Is that even a thing?
00:51:29 <cocreature> I think the musl ghc in alpine also works
00:53:43 <joneshf-laptop> cocreature, thanks, I 'll read up on that
01:05:08 <dmj`> geekosaur: ABI == application binary interface?
01:08:35 <dmj`> geekosaur: interesting, just statically linked ghc binaries yesterday and got that exact warning about dlopen()
01:17:48 <joneshf-laptop> So maybe I should stick with dynamic and figure out the environment instead?
01:18:05 <joneshf-laptop> Overall goal is figuring out deploy.
01:19:23 <xkb> hi there. I have a question on Aeson: Is it possible to map the accessor function of a field to a different field name in the JSON?
01:19:39 <xkb> I'm dealing with conflicting names over 2 structures that are in the same module
01:20:11 <dmj`> joneshf-laptop: here’s the warning I received from static linking, exactly as geekosaur described.
01:20:13 <dmj`> https://gist.github.com/dmjio/32b226cc892b3bd41112e3624c2e0344
01:20:33 <dmj`> hsnet_getaddrinfo is just a wrapper around getaddrinfo 
01:21:43 <tdammers> xkb: you can write JSON instances by hand instead of deriving them
01:22:00 <xkb> Hmm I was hoping to avoid that ;)
01:22:01 <joneshf-laptop> xkb, yes, there's an option thing you can pass for that.
01:22:10 <joneshf-laptop> xkb, or do as tdammers suggested
01:22:23 <tdammers> xkb: then I'd factor the data structures out into separate modules, and import them qualified into the one they're currently in
01:22:25 <xkb> I'm digging in the docs now to see if I c an find it
01:22:35 <joneshf-laptop> dmj`, I see. I can't even get to that stage.
01:22:56 <tdammers> xkb: depending on how exactly you name the fields, you could also pass a custom field name modifier to the deriveJSON options
01:23:13 <xkb> @tdammers 
01:23:13 <lambdabot> Unknown command, try @list
01:23:21 <joneshf-laptop> xkb, or you could use that language extension `DuplicateSomethingSomething`.
01:23:22 <xkb> @tdammers  that sounds like my best bet
01:23:22 <lambdabot> Unknown command, try @list
01:23:36 <xkb> tdammers: that sounds like my best bet
01:23:42 <tdammers> xkb: if it's just removing a prefix, then it's easy
01:24:17 <joneshf-laptop> dmj`, this is where i'm stuck: https://gist.github.com/joneshf/044cb9f7c2416e9f12f2233137dc6b3a
01:24:20 <dmj`> joneshf-laptop: unless you’re doing numeric heavy code, one way to get around some linker issues is to use the integer-simple ghc (avoid linking with -gmp). This also gets around some licensing issues w/ distributing gmp 
01:25:04 <tdammers> xkb: http://hackage.haskell.org/package/json-extra-0.2.0.0/src/Data/Aeson/DeriveUtils.hs has an example of how to do this
01:25:11 <joneshf-laptop> xkb, `DuplicateRecordFields`.
01:25:40 <xkb> `fieldLabelModifier = drop 1` <= nice
01:25:50 <dmj`> joneshf-laptop: in your default.nix, besides configureFlags = [ "--ghc-option=-optl=-static" "--ghc-option=-optl=-pthread" ]; and enableSharedExecutables = false;  , what else do you have
01:26:59 <joneshf-laptop> dmj`, I know very little about nix so forgive me if I say something silly, but I don't have a `default.nix`. I have a `shell.nix`.
01:27:30 <joneshf-laptop> dmj`, dunno if those can be used equivalently, but I don't have any `configureFlags` in `shell.nix`.
01:29:49 <joneshf-laptop> dmj`, is that my problem? That I should be using a `default.nix` in addition to this `shell.nix`?
01:30:15 <dmj`> joneshf-laptop: By default nix doesn’t use cabal-install to build programs, it uses the old school ghc Setup.hs && ./Setup —configure <flags> && ./Setup … etc. 
01:31:25 <dmj`> Using cabal-install in the nix-shell is basically removing the necessity of cabal resolving dependencies from hackage (calling ghc-pkg list in the nix-shell should show you what is present)
01:32:25 <dmj`> joneshf-laptop:  In your project, I’d call cabal2nix . > default.nix
01:32:40 <joneshf-laptop> from outside of nix?
01:33:24 <dmj`> either or, if you installed cabal2nix with `nix-env -iA cabal2nix -f ‘<nixpkgs>’` that will put a symlink from the store into your profile, making it accessible from anywhere
01:34:19 <dmj`> unless you are in a shell with —pure, since that should block the PATH
01:34:34 <joneshf-laptop> I have no idea :(
01:34:57 <dmj`> just install cabal2nix with nix-env -iA cabal2nix -f ‘<nixpkgs>'
01:35:03 <dmj`> it’s present at the top level attribute set of nixpkgs
01:35:21 <joneshf-laptop> L
01:35:23 <joneshf-laptop> K
01:37:15 <hvr> dmj`: does nix contain all versions of a package from hackage?
01:38:32 <dmj`> hvr: I don’t believe so, only the most current curated set of packages that are manually synchronized from stackage. It’s always possible to get at old packages by using older hashes of nixpkgs, or calling `fetchFromGitHub`. It does allow you to have multiple versions present though. And package versions will vary amongst ghc’s that you’re using.
01:38:55 <hvr> dmj`: but this sounds like nix doesn't offer you the full cartesian product of valid solutions
01:39:31 <hvr> but rather more like a time-indexed family of "planes" within the hackage solution space
01:39:55 <hvr> which is only a tiny fraction of the solution space
01:44:00 <dmj`> hvr: yes, basically the latter. I believe there is a yaml file with a list of packages that is used to generate this file: https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/haskell-modules/hackage-packages.nix.
01:44:26 <hvr> dmj`: or put differently, is nix basically just a nix-ified stackage?
01:45:02 <hvr> (with respect to the supported configurations)
01:47:29 <hvr> looking at the hackage-packages.nix file I notice that most packages only have one single version
01:48:02 <hvr> while some may have 2 or 3 major versions represented
01:48:17 <dmj`> Hydra and nix-serve will only keep so many packages pre-built in the cache before a GC run is called, and these packages live along standard ‘channels’, analgous to LTS snapshots (but inclusive of system deps). Stackage might be considered more stable, no one is going to tell you your packages are broken on nixpkgs. But nixpkgs will look at versions of
01:48:17 <dmj`> packages on stackage and put them into nixpkgs iirc.
01:48:30 <joneshf-laptop> dmj`, hmm, got `default.nix` but can't seem to run it. Complains about `mkDerivation`. But, I think i'm kind of getting side tracked here. I'm not commited to using nix to build, since I've heard it's not great on OSX anyway (work computer is OSX). Just using it here since I'm too lazy to install postgres.
01:49:33 <hvr> dmj`: tbh, this makes nix appear less attractive to me :-/
01:49:41 <dmj`> hvr: for more popular packages it’s common to see version suffixes appended to the end. 
01:50:34 <hvr> dmj`: i.e. it seems to force me into constrained package sets due to hydra's limitation that it can't build *everything*
01:51:24 <hvr> i.e. we have a constraint database on hackage so we can let a solver select valid solutions for us
01:51:29 <joneshf-laptop> That reminds me,I should repond to your issue hvr :)
01:51:57 <hvr> rather than have to precompute solutions for everyone
01:52:07 <hvr> +low-dimensional solutions
01:52:20 <hvr> joneshf-laptop: :-)
01:52:34 <hvr> joneshf-laptop: if you have questions... feel free to ask!
01:53:15 <dmj`> hvr: Well, you can override specific packages that you need, or fetch from your fork. But in general most packages on nixpkgs build no problem, tests and haddocks not always. But that can be fixed. 
01:53:53 <joneshf-laptop> hvr, will do. Thanks!
01:54:15 <hvr> dmj`: what if I want to just leave package resolution up to cabal's solver, and just reuse nix packages in case they happen to be cached?
01:55:09 <hvr> btw, is overriding specific packages  less cumbersome than stack's extra-packages mechanism?
01:55:20 <dmj`> hvr: In general for most projects I guess I’m not using multiple versions of the same package, if I were it wouldn’t be a problem adding it to a list of overrides and giving it a similar name . You can setup your own personal hydra, that will cache your deps. as long as you’d like, and give everyone on your team access to the cache (behind basic auth
01:55:20 <dmj`> or something). 
01:55:28 <hvr> (where you have to manually pinpoint versions rather than specifying a version range)
01:56:22 <hvr> ok, but how does hydra know which install-plans to build?
01:56:33 <hvr> (or cache)
01:56:57 <dmj`> hvr: hmm, I don’t think it would be possible to use cabal’s resolver, esp. if you lack a freeze file. Since the hashes could change. In general all dependencies are explicit.
01:57:27 <hvr> hrm... that's unfortunate... and I guess I'm going to have to reinvent hydra for what I have in mind :-/
01:58:06 <dmj`> hvr: there is a schedule that is followed based on channels, hydra will follow the channel. Actually, see #2. http://howoldis.herokuapp.com/
01:58:18 <hvr> that's the thing; I don't need channels
01:58:30 <hvr> in fact, they're in conflict with what I want
01:59:02 <hvr> I deliberately want a channel-agnostic hydra
01:59:58 <dmj`> hvr: hmmm, I see. So with what you have in mind, would you like all of hackage built and cached at any given time.
02:00:12 <hvr> I'd like a sparse cache of hackage
02:00:34 <hvr> where stuff gets cached based on demand
02:01:09 <hvr> I *need* the cabal solver to be in charge
02:01:58 <hvr> so that I can get the same solutions ppl would get when they run cabal install
02:03:09 <hvr> schemes like stackage kinda put the cart before the horse in my model
02:04:08 <joneshf-laptop> hvr, should I pay attention tot he info?: *INFO* Please consider using the experimental `cabal new-build`-powered generator `make_travis_yml_2.hs`
02:04:32 <joneshf-laptop> Or is it too experimental?
02:04:32 <hvr> joneshf-laptop: can you link me to the specific comment? :-)
02:05:14 <joneshf-laptop> I ran step 4 of the instructions here: https://github.com/hvr/multi-ghc-travis#quick-start-instructions and it gave me that into as output.
02:05:42 <joneshf-laptop> https://gist.github.com/joneshf/c798cec0409d5a6eac48e5454fb5440e
02:05:46 <hvr> ah right, yeah
02:06:00 <hvr> if you've got a simple package, the _2.hs script is fairly robust
02:06:35 <joneshf-laptop> K. I'll give it a shot
02:06:48 <hvr> joneshf-laptop: lemme know in case it doesn't work as expected
02:06:54 <hvr> joneshf-laptop: it *is* supposed to work
02:07:22 <dmj`> hvr: Ah, very interesting, it might just be better to cache every package w/ version on hackage, and then let the cabal resolver hit the cache, and insert the package into your local package db. Assuming packages never change after being uploaded, for reproduceability, and modulo any system deps required. 
02:07:26 <hvr> the only experimental part about it is that it currently uses an unreleased bleeding edge cabal version :)
02:08:57 <hvr> dmj`: you can't properly cache every package*version; as you'd have to cache the DOF of all sub-install-plans possible for say foo-1.2.3's deps
02:09:38 <hvr> dmj`: but you can reasonably cache those configurations that actually get "solver coverage"
02:10:09 <hvr> otherwise http://104.239.175.197:8080/ would be impossible
02:11:00 <hvr> it's still got a huge database, but it's quite realistic to cache popular configurations
02:11:36 <hvr> w/o having to dumb down configurations by resorting to workarounds like stackage
02:14:18 <bollu> if Sum = A  Int | B Bool, and I have sums :: [Sum], can I collect all the "Int"s that are inside "sums" by using lens?
02:14:39 <hvr> bollu: if you have a prism for Sum, yes
02:14:42 <bollu> yes, I do
02:14:48 <bollu> so, like, how do I put it together?
02:15:08 <bollu> I understand I need a Traversal to walk over [], and a Prism to pull out the "Int" from A
02:15:15 <bollu> but I don't know how to actually write the code for this :)
02:15:20 <merijn> It's also trivial using a list comprehension
02:15:29 <bollu> merijn: yeah, but this is a lens exercise :P
02:15:39 <bollu> merijn: I'm trying to learn how to think lensy
02:16:12 <bollu> hvr: what would the code using the lens look like?
02:16:17 <hvr> bollu: jfyi, there's also #haskell-lens where ppl often answer this kind of questions
02:16:35 <hvr> bollu: I'm just looking up how that traversal oeprator is named (I keep forgetting)
02:16:45 <bollu> hvr: I asked there as well
02:16:49 <bollu> but you answered first
02:16:50 <bollu> :)
02:16:52 <mojjo> hi! say I have two types: data Point a = Point a a; data Path a = Path [Point a];  I'm trying to write instances of Functor for them now. for Point it was trivial, however I'm stock with the one for Path... (http://lpaste.net/353852)
02:17:54 <bollu> mojjo: to get to an "a" in Path, you need to go through two layers: one [] layer, and one Point layer
02:18:04 <bollu> mojjo: so, if you think of "fmap" as being able to puncture a layer
02:18:12 <bollu> mojjo: what would you need for Path? :)
02:19:55 <bollu> :t fmap . fmap
02:19:57 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
02:19:59 <bollu> mojjo: ^
02:20:55 <dmj`> hvr: This is cool, definitely think nix could be used to cache common resolver configurations. It’s a very generic framework for building packages. The atomic unit in nix is the derivation, which is just a list of all the sources and inputs a package would need to be reified. It’s like a thunk, a build thunk. Nix takes the key value pairs in a derivation
02:20:55 <dmj`> and converts them into environment variables, and begins building packages w/ bash. It goes through a series of phases that can be hooked into or overriden.
02:21:51 <dmj`> hvr: since the derivation is the atomic unit, I don’t think object / archive files can be shared, like new-build will be able to do
02:22:04 <bollu> hvr: did you find the function?
02:22:07 <hvr> dmj`: ok, so I could in fact have cabal solver output such a nix derivation
02:24:21 <mojjo> bollu: aha, I see. so this works now:  instance Functor Path where  fmap f (Path pts) = Path (map (fmap f) pts) 
02:24:33 <bollu> mojjo: yep!
02:25:05 <bollu> mojjo: I would prefer to write it as Path ((fmap . fmap) f pts), but that's a stylistic choice
02:25:08 <dmj`> hvr: yes, it seems so, similar to the hackage-packages.nix file, would probably need to generate something similar which has multiple packages versions in it. 
02:25:23 <dmj`> multiple version of the same package*
02:26:15 <akts> greetings everyone
02:26:41 <dmj`> hvr: although, this work may be related, https://github.com/haskell/cabal/issues/3651
02:27:19 <paolino> hi, I have a  dumb question, how to write bytes (not Char) to an handle ?
02:27:42 <paolino> seems to be a hPutBuf but I need a Ptr a
02:28:00 <merijn> paolino: Use bytestring
02:28:31 <merijn> Data.ByteString.hPut
02:29:31 <dmj`> hPutBuf :: Handle -> Ptr a -> Int -> IO () ?
02:30:06 <joneshf-laptop> hvr, hmm, well the 7.10 and 8.0 builds failed, but I wasn't expecting that: https://travis-ci.org/joneshf/servant-ruby/builds/214166869
02:30:13 <merijn> hPutBuf is too low level for most people to need
02:30:26 <paolino> merijn, hPut h (pack [0..10]) ?
02:30:30 <joneshf-laptop> hvr, do you think that's from the experimental generator?
02:30:32 <hvr> bollu: sorry, [Right True, Left (), Right False] ^.. traversed._Right
02:30:54 <merijn> paolino: For example, depending on what you want to output
02:31:00 <bollu> hvr: oh, (^..) is a many access?
02:31:04 <akts> Is it possible to get the basics of haskell covered in a fort night ? total newbie here ...
02:31:22 <paolino> merijn, Word8
02:31:42 <merijn> akts: Depends on your background, but probably not
02:31:56 <hvr> joneshf-laptop: looking...
02:32:29 <hvr> joneshf-laptop: oh... you got doctests...
02:32:48 <merijn> akts: Unless you have experience with somewhat similar languages (OCaml, Swift, F#, SML) you'll find yourself needing to basically learn from scratch as Haskell is rather different from most mainstream languages
02:33:30 <akts> I jumped in and joined an online course on haskell... and suddenly got a bit far behind (for reasons of national security :P) ... 
02:33:58 <hvr> bollu: do you know http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html ? I like to point students to that to get a first taste of lenses
02:34:14 <akts> oh!! I have a bit of background in c and a lil bit of python
02:34:23 <hvr> (and it does mention (^..) )
02:34:36 <bollu> hvr: I read it, yes. I had forgotten about (^..) since I have not used it so far
02:34:48 <bollu> hvr: so far, I have mostly been using the Prism and the StateT family of lenses
02:34:55 <bollu> hvr: I'm implementing STG to understand it xD
02:36:03 <akts> one more thing... ahem!! are you guys really strong with math ?
02:36:04 <hvr> joneshf-laptop: are those doc-tests expected to work?
02:36:14 <joneshf-laptop> hvr, yep.
02:36:36 <bollu> hvr: thanks for the help
02:37:40 <joneshf-laptop> hvr, seems relevant: https://github.com/hvr/multi-ghc-travis/issues/54
02:37:59 <joneshf-laptop> hvr, Going to try the non-experimental generator
02:38:11 <akts> my math is a bit under the rain... that is why I asked ... should I be well versed in math to learn haskell ?
02:38:12 <merijn> akts: Not particularly, and I don't believe it'd help much
02:40:29 <akts> Thanks merijn, I guess I'll take a crack at my fresh copy of Real World Haskell.  
02:42:07 <merijn> To be honest, Real World Haskell is kinda dated nowadays
02:42:17 <mojjo> bollu: looks like a good idea to avoid the nesting of fmaps.... The composing you suggest I find bit hard to reason about at the moment.. would you have a hint how to imagine that (fmap . fmap) is getting the type (a -> b) -> [[a]] -> [[b]] 
02:42:23 <tdammers> someone should write a revised edition
02:42:28 <merijn> There's the CIS something course which I forget which someone will probably jump in and recommend :)
02:42:47 <merijn> mojjo: Well, let's have a look:
02:42:48 <merijn> :t fmap
02:42:50 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:43:46 <merijn> So, we have an 'a -> b' and make it 'f a -> f b', but what if fmap a function we already have 'f a -> f b' (let's rename it to 'm x -> m y' for clarity
02:44:39 * sm inserts standard suggestion of Haskell Tutorial And Cookbook
02:44:46 <merijn> So, what if we pass 'm x -> m y' to fmap? Well, we get 'a = m x' and b = 'm y', so since fmap does '(a -> b) -> f a -> f b', we get '(m x -> m y) -> f (m x) -> f (m y)'
02:45:08 <Baklazhan> akts: you might want to be able to derive some formulas (= functions) in a formal way, like the one merijn is doing right now
02:45:55 <merijn> mojjo: Now, since the only restriction is that 'f' and 'm' must be Functor, we can pick [] (a functor) and see the result can be '[[a]] -> [[b]]' (alternative notation: '[] ([] a) -> [] ([] b)' which looks like the 'f (m x) -> f (m y)' we had
02:46:22 <akts> What you guys are saying is literally greek for me 
02:46:43 <akts> http://www.seas.upenn.edu/~cis194/ <- is this the one ?
02:47:40 <merijn> Yeah, that one
02:49:24 <akts> Thanks merijn Baklazhan 
02:49:28 <hvr> joneshf-laptop: yeah, I know... doctest are still an open issue for new-build ... as they rely on undefined behaviour which isn't provided by new-build anymore currently
02:53:02 <joneshf-laptop> hvr, yikes! undefined behavior?
02:56:52 <joneshf-laptop> hvr, looks like the old generator still works. Thanks for the help!
02:56:55 <mojjo> merijn: bollu: yeah, starting to make sense to me now... It helps to remember that the fmap signature includes those parentheses implicitly: (a -> b) -> (f a -> f b) . in other words: just currying, and then it's literally just replacing the symbols after the first arg is passed. nice! 
02:58:01 <bollu> mojjo: yes
02:58:33 <joneshf-laptop> hvr, Also, I'm curious. Are you already using/interested in using `servant-ruby` or just noticed it somehow?
02:59:00 <merijn> mojjo: My usual advice is: do the substitution by hand on paper anytime you get confused until you get comfortable doing them in your head :)
03:08:43 <mojjo> bollu: Alright, very good. So one could finally write fmap like: fmap f (Path pts) = Path $ (fmap . fmap) f pts; and use it e.g. like  fmap succ $ Path [Point 1 1]; This is sort of the 'deep' solution. Isn't this getting problematic when types are more nested?  
03:09:22 <hvr> joneshf-laptop: I do use servant-ruby, but it got on my radar cause it was flagged on http://104.239.175.197:8080/package/servant-ruby
03:09:34 <hvr> joneshf-laptop: meant, I use servant-* stuff; but not yet -ruby
03:09:58 <mojjo> I mean, I'd rather have assumed on would intend a usage like: fmap (f :: Point -> Point) $ Path [Point 1 1]
03:11:05 <hvr> joneshf-laptop: undefined insofar, as the way 'doctest' works relies on being able to see the local package-db; something that was a side-effect of the old system, but doesn't necessarily exist in the same way in the redesigned new-build model
03:13:52 <quchen> hvr: Woooo you’re alive! :-D
03:14:21 <hvr> quchen: yes... I'm slowly resurface from the depth of mainframe programming w/ PL/I & COBOL
03:14:22 <joneshf-laptop> hvr, that matrix thing is amazing!
03:14:32 <quchen> hvr: Really? REALLY?
03:15:15 <hvr> quchen: long story... but partly the reason why there GHC 8.0.1 revived the IBM AIX port
03:16:02 <quchen> Google translate: what does »grundgütiger herrgotimhimmel warum« mean in English
03:16:06 <quchen> I’d like to use it on IRC
03:16:33 <hvr> joneshf-laptop: fun-fact: the 3rd-gen matrix builder is powered by servant :-)
03:16:35 <opqdonut> quchen: with my limited german it sounds a bit like "why god why?"
03:16:43 <quchen> :-)
03:17:26 <mojjo> quchen: sounds like bavarian to me...
03:17:58 <hvr> quchen: well... turns out there's quite a few legacy-systems vendor-locked into IBM hardware/software that wants to be freeed up a little bit
03:18:27 <qqwy> Good morning! :-)
03:19:11 <qqwy> Quick question that one of you veterans probably can answer right away: I want to repeat a function on some input until some condition is true for this input, and then count the amount of repetitions.
03:19:24 <mojjo> "ground-gracious god's heaven.. why?" So, "why god why?" sounds like a good free translation to me..
03:19:34 <qqwy> In this case, I want to count how often I can run a function on a Set that deletes some of the elements from the set.
03:19:46 <Ferdirand> by repeat a function, you mean iterate ?
03:21:05 <marvin2> qqwy do you count function recursively calling itself (assuming it is doing that)?
03:21:23 <Ferdirand> > take 10 (iterate (*2) 1)
03:21:24 <mojjo> qqwy: what about: length $ takeWhile predicate xs
03:21:26 <lambdabot>  [1,2,4,8,16,32,64,128,256,512]
03:22:43 <mojjo> > length $ takeWhile (<8) [1,2,4,8,16,32,64,128,256,512]
03:22:46 <lambdabot>  3
03:24:04 <qqwy> marvin2, Ferdirand: I am not iterating over a list, but rather have one set, and want to run a function `a -> a` on some `a` until some `a -> Bool` is true, in which case I want to return how many times the `a -> a` function was called to reach that point
03:24:39 <Ferdirand> well that sounds exactly like iterating over a list
03:24:56 <Ferdirand> thanks to laziness it won't actually exist as a list in memory
03:25:24 <Ferdirand> iterate will compute the a's as takeWhile consumes them
03:25:49 <Ferdirand> takeWhile itself driven by length, which will discard each element immediately
03:26:30 <mojjo> qqwy: what do you mean by 'set' exactly, could you give some sample data?
03:28:18 <qqwy> It does seem like a waste to build a list just to read out its length afterwards. Although because of the lazyness that might not be such a problem, items being consumed while they are being produced and such
03:28:21 <qqwy> mojjo: Data.IntSet
03:28:35 <qqwy> A set like `Data.IntSet.fromList [1,2,3]`
03:30:48 <Ferdirand> you'd have to inspect the core to be sure, but with optimizations turned on i've heard that fusion might kick in and even eliminate the list allocations completely
03:31:02 <Ferdirand> perhaps a real expert can confirm
03:31:32 <qqwy> Thanks!
03:32:01 <qqwy> `length $ takeWhile (not . IntSet.null) $ iterate myFun set` works :-)
03:32:17 <qqwy> First make it correct, then readable, then fast. In that order. So for now, this is more than good enough :-)
03:33:38 <cocreature> I would be very surprised if that creates a list
03:41:40 <qqwy> This is what I would write when doing it manually:
03:41:42 <qqwy> https://gist.github.com/Qqwy/419b0db0c1920a7ecfc16c9d3f13812b
03:42:20 <qqwy> I'll benchmark which approach is faster
03:42:35 <qqwy> Probably it will still be the list one, because GHC can do ridiculous things with lists ^^'.
03:43:22 <mojjo> qqwy: I'm just wondering if a 'break condition' on iterating over a set makes sense at all. Isn't it the nature of sets that you can't rely on the order - in contrast to lists?
03:44:28 <mojjo> Then you would have to go over the whole thing anyways, but correct me if I'm wrong here.
03:44:28 <qqwy> mojjo: In this case I am repeatedly deleting elements (stored elsewhere) from the set. This procedure, doing 'something else' and then deleting an element from the set is what I want to count how many it is repeated until the set is empty
03:44:54 <qqwy> The set basically stores 'possible starting points' of the procedure.
03:45:36 <ccapndave> Morning Haskellers.  Is there a special word for 'exiting' a monad?  e.g. Maybe a -> a
03:45:52 <mojjo> qqwy: ok, got you...
03:45:58 <qqwy> ccapndave: I believe that 'escaping' is usually the term that is use
03:46:00 <qqwy> used*
03:46:05 <ccapndave> Awesome, thanks :)
03:46:54 <qqwy> mojjo: To give some more context, I am solving an exercise for the university
03:47:21 <qqwy> in which we get an array of `n` numbers as input, where each of the numbers is a distinct number in the range (0..n)
03:48:09 <qqwy> This means that array index `i` points to another element in the array
03:48:24 <qqwy> So it is sort of a 'graph' representation
03:48:32 <qqwy> and the idea is to find out how many cycles there are in this array
03:49:31 <qqwy> For instance, [1,2,3,0] has one cycle, as every element points to the next (with the last one pointing to the first)
03:49:39 <qqwy> And [0,1,2,3] has four cycles, as every element points to itself
03:50:53 <qqwy> How I solve it, is by creating an array from this list, so we have O(1) element access, and also creating an IntSet filled with these numbers.
03:53:03 <qqwy> Then, I take any number `i` from the IntSet, which is the 'start' of the cycle to consider, and read the `i`-th index' value `v` from the array. The number `i` is then deleted from the IntSet. If that value is equal to the start, the cycle has been completed. If it has not, this procedure is called recursively (so `v` is the new `i`) until it does.
03:53:27 <qqwy> So this is to find one cycle. After this procedure is completed, the IntSet only contains all numbers that were not part of that cycle.
03:53:42 <qqwy> So that procedure, runCycle, as a whole, is repeated until the IntSet is empty.
03:54:54 <qqwy> :-)
03:55:01 <qqwy> So what are you working on right now, everyone? 
03:55:20 <maerwald> proprietary software
03:56:19 <brynedwards> Writing a script to load an analytics DB from S3 logs using amazonka-s3
03:56:35 <qqwy> brynewards: Fancy!
03:56:51 <qqwy> maerwald: The good or the bad kind of proprietary software? :')
03:56:54 <brynedwards> :D
03:57:07 <mfukar> Coincidentally, parsing systemd files to discover dependency cycles (among other things)
04:12:34 <sbrg> i'm slumming it with clojurescript
04:13:12 <sbrg> i've found that clojurescript is the frontend solution i like the most so far, even though it's all dynamic. 
04:13:29 <brynedwards> sbrg: What else have you tried?
04:14:14 <sbrg> I've tried Haste, Elm, JS, PureScript, and fiddled a tiny bit with ghcjs
04:15:34 <sbrg> workflow-wise, there is nothing that even comes close. leinigen + figwheel is just awesome.
04:16:43 <mojjo> sbrg: interesting, are you using some react wrapper was well? such as reagent?
04:16:49 <sbrg> exactly, reagent.
04:17:08 <sbrg> I started with om, but reagent is just so much lighter, and doesn't really seem to sacrifice any features that I need.
04:17:24 <sbrg> clojurescript is seriously like it's made for react.
04:17:36 <mojjo> sbrg: yeah, same for me..
04:18:36 <mojjo> sbrg: defonce is also super nice, do you know if they have sth. like this in elm/purescript?
04:19:57 <sbrg> I also think it might be rather simple to work with servant's existing JS generation to generate clojurescript functions to consume the APIs.
04:20:38 <sbrg> mojjo: well, I'm not sure how that would apply to f.x. purescript. 
04:20:39 <Axman6> sbrg: have you seen the hot reloading stuff for pux in purescript?
04:21:10 <Axman6> https://github.com/alexmingoia/pux-starter-app
04:21:31 <ccapndave> Axman6: Have you got much experience using Purescript?
04:22:10 <sbrg> Axman6: I'm not familiar with pux. But one of the reasons I moved from purescript to clojurescript was that I wasted hours trying to get some webpack solution working, and it was very frustrating. even then, the hot reloading wasn't even close to what figwheel is doing. I think one of PS' biggest issues is that they rely so heavily on existing JS tooling, because most of it is, well, utter shit to use IMO. 
04:22:13 * sbrg checks link
04:22:32 <Axman6> very little, I did the Yow! LambdaJam workshop last year and did some playing around wiht it, but that;s it. hasn't been relevant to my work
04:22:39 <ccapndave> Fair enough
04:22:47 <sbrg> okay, that looks pretty nice
04:23:04 <ccapndave> I've a got a very large app that I'm building in Elm which is lovely, but I feel like I'm starting to miss some more fancy type system stuff
04:23:15 <brynedwards> I've been looking at purescript tooling as well and came across this https://github.com/sectore/purescript-webpack-vanilla-hmr
04:23:24 <brynedwards> Worked OK I think
04:23:33 <Axman6> ccapndave: yeah IMO you hit the upper limit of Elm extremely quickly
04:24:10 <ccapndave> Since I was pretty new to FP at the start it was ideal, but now I pretty much understand it I crave more :)
04:24:18 <ccapndave> You can do everything in Elm still, but it gets a bit wordy
04:24:27 <Axman6> I feel Elm would be a great teaching tool, but wouldnt want to use it for anything even medium sized because there's very little room for abstraction
04:24:34 <ccapndave> Agreed
04:24:42 <ccapndave> On the other hand, its a billion times better than JS
04:24:47 <sbrg> There's a ton of features that clojurescript offers that I think are incredibly nice to have. For example, there are custom formatters that you can use for the console. You can start a clojurescript repl that is connected to the browser session, and look at and modify the application state directly in the repl and see the change have effect.
04:24:48 <Axman6> no type classes right?
04:25:05 <ccapndave> No type classes or higher typed kinds or module functors or anything like that
04:25:22 <ccapndave> No room for any advanced abstraction, basically
04:25:22 <Axman6> :'(
04:25:29 <sbrg> Axman6: that is precisely the reason I didn't stick with elm. I was trying to use it to write gimped haskell
04:25:50 <Axman6> map_list, map_tree, map_maybe, map_either ... no things :(
04:25:50 <ccapndave> Yeah, you have to approach with a mindset where you don't mind writing boilerplate
04:26:00 <Axman6> thanks*
04:26:12 <mojjo> sbrg: what do you mean by custom formatters?
04:26:18 <Axman6> ccapndave: i mind that a lot
04:26:40 <ccapndave> Is Purescript a practical alternative though?
04:26:53 <Axman6> yes
04:26:59 <ccapndave> Do people use it in production for proper apps?
04:27:16 <sbrg> mojjo: chrome supports custom formatters, and using them for your clojurescript project is just a matter of preloading some plugin in the leinigen config. then, when you log CLJS objects to the console, they are output in a rich format that you can interact with
04:27:20 <sbrg> navigate through objects, etc.
04:27:25 <Axman6> it's not as powerful as Haskell, but it's improving AFAIU
04:27:26 <ccapndave> I'd happily give it a go but I can't get down the line only to discover that PUX performance (or whatever) isn't good enough for a real app
04:27:53 <brynedwards> ccapndave: I think this the biggest purescript app out there ATM https://github.com/slamdata/slamdata
04:28:40 <Axman6> "PureScript has been adopted successfully and put into production at several companies now..." - https://survivejs.com/blog/purescript-interview/
04:28:49 <Axman6> but no details
04:28:59 <ccapndave> Hmm
04:29:06 <ccapndave> I might wait a bit and revisit it in a few months
04:29:19 <Axman6> https://www.reddit.com/r/purescript/comments/5e4alh/ready_for_production_yet/ from a few months ago
04:29:22 <brynedwards> It is nice but just not that mature ecosystem-wise
04:30:00 <sbrg> ccapndave: I was really looking hard for a Haskell-ish frontend language.. but I was surprised to find that while CLJS isn't typed, it kind of feels like it makes up for some of it because of its expressiveness.
04:30:13 <sbrg> the metaprogramming capabilities just work really well for this kind of stuff
04:30:15 <Axman6> we're talking about web apps, how mature do you need? JS land does fine with one week from announcement to maturity of new frameworks :P
04:30:25 <ccapndave> I must say this for Elm - its a great way to teach what monads are
04:30:44 <ccapndave> Cos it doesn't have them, are you are like "wouldn't it be nice if it had this" only to discover that you have invented a monad
04:31:12 <mojjo> sbrg: interesting, This might be better than solutions which inject some app state inspector into you webapp on development (forgetting the name of the cljs one now)... Have you checked out boot as replacement for leiningen...? For me this was a good thing to do.. It's tasks are more composable, but I don't know how lein has envolved recently 
04:31:15 <taktoa> best thing about Elm is the popularity of (|>)
04:31:32 <ccapndave> Elixir and F# have it too I think
04:31:36 <Axman6> ccapndave: I don't think Elm is capable of teaching what monads really are about (it's an abstraction which you can't express in Elm, and therefore can't write code which is generic over any Monad)
04:31:58 <sbrg> mojjo: nope, I hadn't yet. I've seen people refer to it, but I honestly just started writing cljs two or three days ago. 
04:32:05 <ccapndave> Axman6: Right - so, you find yourself wondering why you can't abstract various things into a common operation
04:32:29 <ccapndave> Axman6: The fact that you can't express it helps (at least helped me) to understand what it really was
04:32:38 <ccapndave> After lots of reading tutorials and not quite understanding what it was all about
04:33:03 <Axman6> yeah, I guess we use a simmilar idea in the Data61 course
04:33:28 <mojjo> sbrg: cljs lacks types but it has cljojure.spec, which you might want to check out as well. 
04:33:44 <Axman6> we get people to write fmap and ap and sequence over and over again, then show them you only have to write it once
04:33:51 <ccapndave> Exactly
04:34:21 <qqwy> Yes, Elixir has it as well, but I believe in Elm you pipe the last operand, and in Elixir the first 
04:34:30 <qqwy> (because Elixir does not have built-in partial function application)
04:34:34 <ccapndave> Yeah, Elm is the last
04:34:42 * qqwy just read back the last 50 lines
04:34:59 <qqwy> I am also struggling a lot with what kind of front-end tool to use now
04:35:20 <qqwy> I myself  feel that Elm is a wonderful tool for new programmers/programmers from an imperative background to get started with functional programming
04:35:32 <ccapndave> qqwy: I think it depends on what your are making
04:36:03 <ccapndave> Elm is easy and has fairly good tooling
04:36:04 <mojjo> sbrg: and spec can talk about types and values, which makes it quite expressive.
04:36:10 <qqwy> but when you're already used to something like e.g. Haskell, Clojure or maybe OCaml (although I don't know OCaml myself at all), it feels like you hit Elm's ceiling really quickly because of the difficulty to abstract things
04:36:13 <ccapndave> But no fancy abstractions
04:36:16 <qqwy> not having typeclasses, e.g.
04:36:22 <qqwy> i.e.*
04:36:27 <ccapndave> Right
04:36:33 <qqwy> I love the compiler and its nice error messages though :-)
04:37:34 <sbrg> mojjo: cheers! I will definitely
04:37:55 <ccapndave> qqwy: Its definitely very possible to make large apps wth Elm; I have one in production now and it works great
04:37:58 <sbrg> I also read about some haskeller mentioning clojure.match or some such for pattern matching. i need to check that out as well.
04:38:16 <sbrg> core.match, it seem
04:38:47 <mojjo> sbrg: yeah, it's like recursive regular expressions operating on trees. amazing
04:39:16 <mojjo> core.match does not make you happy when coming from haskell ...
04:40:03 <qqwy> The thing is: When you know so many different nice tools, you want to work with all their good parts everywhere. (or in other words: You stumble upon a lot of 'language warts' you would not have seen before.)
04:40:47 <ccapndave> True enough
04:41:07 <ccapndave> Why doesn't someone make a new language with all the good bits from every language
04:41:15 <ccapndave> Situation: now there are 16 competing standards
04:41:20 <qqwy> Which always makes me feel a little bad, too =/ (as I have the utmost respect for the hard choices and years of work that the language creators' have poured in their projects)
04:41:37 <qqwy> Heh, very Astute x)
04:43:15 <qqwy> ccapndave: Very nice! I think I mostly need to bite through the hard skin to get to the juicy stuff inside. It's probably mostly my own prejudices that hold me back to learn more of Elm at this time
04:43:41 <ccapndave> You will pick it up in no time at all - its super easy
04:44:21 <ccapndave> Its basically Haskell + a built in architecture everyone is forced to use + |> - any fancy type stuff
04:44:27 <qqwy> I tried building a ratonal number library for Elm to learn it, because I did the same to learn Elixir back in the day. But then it turned out that it would be impossible to use these as normal numbers, which made me discard the idea alltogether
04:44:37 <ccapndave> Wrong kind of app
04:44:49 <qqwy> Yes, probably :-)
04:44:50 <ccapndave> You should try and learn it by building some UI stuff
04:44:59 <ccapndave> That's what its focussed towards
04:45:41 <ccapndave> Build a little game out of SVG, or a GUI for some backend
04:45:42 <qqwy> When I get back to the image gallery I was building as hobby project, I think I'll try to use it there (-:
04:45:55 <ccapndave> Yeah, perfect
04:46:11 <ccapndave> Any kind of generic library is going to be annoying in Elm
04:47:00 <qqwy> The thing is, a few days after I stopped working on that, I stumbled across this article: http://reasonablypolymorphic.com/blog/elm-is-wrong
04:47:05 <qqwy> Which is probably quite opinionated
04:47:09 <qqwy> and possibly outdated
04:47:21 <qqwy> but that made me reconsider elm at that time
04:48:05 <ccapndave> If you come at it expecting Haskell you will be disappointed
04:49:05 <qqwy> Yes, that's what happened with me. But then again, I have not yet been able to get PureScript working because it has so much extra settings/boilerplate-ish things going on that I was unable to overcome at the time.
04:50:26 <qqwy> That, too, might have changed in the meantime. On the other hand: I might be able to teach my coworkers Elm in reasonable time, but by no means a Haskell.
04:54:59 <mojjo> May I ask a concrete hs question during this front end chat.. :-) ? I'm struggleing to write a Functor instance for a type `data T1 a = T1 (T2 a)` where fmap should map over values of type (T2 a). E.g: `fmap (\(T2 x) -> succ x) (T1 (T2 1))`  I just get to run a 'deep' fmap which would be used: `fmap succ (T1 (T 2))`
04:56:20 <opqdonut> mojjo: I'm not sure what your question is, but your first example should be `fmap (\(T2 x) -> succ (T2 x)) (T1 (T2 1))` to type
04:56:25 <opqdonut> aargh
04:56:42 <opqdonut> `fmap (\(T2 x) -> T2 (succ x) (T1 (T2 1))`
04:56:50 <opqdonut> and now I messed up the parens
04:57:16 <opqdonut> `fmap (\(T2 x) -> T2 (succ x)) (T1 (T2 1))` there
04:57:17 <mojjo> opqdonut: yeah, I forgot this!
04:57:53 <opqdonut> and even that's only well typed if you define T1 like "data T1 a = T1 a"
04:58:33 <opqdonut> for "data T1 a = T1 (T2 a)", fmap can't see the T2 because the class is "class Functor f where fmap :: (a -> b) -> f a -> f b"
05:01:33 <mojjo> oh, right
05:02:41 <mojjo> when sticking to my data type it would be: fmap (\(T2 x) -> T2 (succ x)) (T1 1)
05:03:06 <opqdonut> mojjo: no, it would be: fmap succ (T1 (T2 1))
05:04:10 <bollu> lens question: I want to filter on a sub-part of a structure, but I want to get the full structure. I'm currently doing: xs ^.. each . filtered (\x -> x ^. subLens > 2). Is there an alternate way?
05:04:44 <Jay-Lenovo> wasup
05:06:27 <KentaKofot> any fellow autist here?
05:07:19 <mojjo> opqdonut: the T2's are confusing... Real world question: data Point a = Point a a; data Path a = Path [Point a]; Now, I'm trying to do this: fmap f (Path [Point 1 2, Point 3 4]), whereas f is of type Point a -> Point a
05:07:23 <bollu> can I clean this up? I feel that there is some patern here that I am missing:
05:07:24 <codedmart> lyxia: Anyway I can bother for another thought/question? This is what I am using at the moment: https://gist.github.com/codedmart/eb5cbe831b0bf4336d43f2ca49039b68#file-fieldnames-hs, but I am wondering if it is possible to have it so when I use gFieldNames with the opts that I don't have to also `@Type` like here
05:07:24 <codedmart> https://gist.github.com/codedmart/eb5cbe831b0bf4336d43f2ca49039b68#file-artworkcontentplaceholder-hs-L7
05:07:32 <bollu> `xs ^.. each . filtered (\x -> x ^. subLens > 2)`
05:07:37 <opqdonut> mojjo: that's not valid
05:07:48 <codedmart> It feels redundant since I already an in an instance for that type.
05:07:48 <opqdonut> mojjo: f will have type a -> a
05:08:06 <codedmart> Not a huge deal just wondering if there is something I am missing.
05:08:11 <opqdonut> mojjo: you can of course write your own "mapPath :: (Point a -> Point a) -> Path a -> Path a
05:08:49 <opqdonut> (it would be valid if your type was "data Path a = Path [a]" of course)
05:09:29 <mojjo> yeah, f has a -> a, but then the more concrete `Point a -> Point a` should fit as well
05:10:18 <mojjo> but couldn't mapPath be implemented as functor?
05:11:09 <Logio> it's probably better to ask, whether Path is a functor
05:11:47 <mojjo> Logio: yes, let's assume this is given
05:11:55 <Logio> can I map a Path a to Path b?
05:12:06 <Jay-Lenovo> I think alll of us KentaKofot
05:12:54 <Logio> mojjo, I don't think it is given until the compiler agrees
05:13:55 <mojjo> Logio: I was about to say 'yes!', but maybe I'm wrong. here's the implementation I used:  instance Functor Path where fmap f (Path pts) = Path $ f pts
05:14:19 <cocreature> mojjo: that doesn’t typecheck
05:14:28 <mojjo> arr, sorry.. wait
05:14:32 <cocreature> mojjo: f has type (a -> b) but pts has type [Point a]
05:14:37 <cocreature> so you can’t apply it directly
05:14:56 <cocreature> mojjo: try writing a Functor instance for Point first (if you haven’t done so already)
05:15:27 <mojjo> Here's the one for Point: instance Functor Point where fmap f (Point x y) = Point (f x) (f y)
05:15:39 <cocreature> that looks good!
05:15:48 <cocreature> so now use that to write the instance for Path
05:16:20 <opqdonut> mojjo: ah right, so if "f :: Point a -> Point a", then "fmap f :: Path (Point a) -> Path (Point a)"
05:16:40 <opqdonut> mojjo: get it?
05:17:18 <opqdonut> values of "Path (Point a)" look like "Path [Point (Point 1 2) (Point 3 4)]"
05:17:59 <msl09> hello I want to start a new project in haskell and I would like to ask a few newbie questions
05:18:39 <cocreature> msl09: go ahead :)
05:19:08 <msl09> should I use cabal or stack for package installations?
05:19:35 <msl09> my haskell-fu is very rusty by the way
05:19:37 <cocreature> msl09: are you familiar with one of them already?
05:19:54 <msl09> cabal, but I have found it very painful to use at the time
05:19:55 <Magnap> Definitely stack
05:20:22 <cocreature> msl09: in that case give stack a shot. cabal is fine and I use both stack and cabal but I think atm it’s a bit easier to get started with stack
05:20:31 <msl09> oh nice
05:20:42 <hvr> unless when you hit problems w/ stack :-)
05:20:49 <msl09> lol
05:20:54 <cocreature> there is a reason I use both :)
05:21:31 <hvr> cocreature: speculative computation? you throw both cabal & stack at a problem, and you use whoever succeeds first? ;)
05:21:56 <cocreature> heh
05:22:32 <msl09> what would be the difficulty level of making a program that periodically queries a postgres database and reports changes to a table via a REST query
05:22:59 <msl09> the project I'm trying to make is a very dumb slack bot
05:23:00 <hvr> msl09: depends on you :)
05:23:11 <Rembane> msl09: pi
05:23:19 <Rembane> msl09: It's a good project.
05:23:21 <brynedwards> Does periodically have to be running all the time or is a cron job OK?
05:23:35 <cocreature> msl09: I don’t know a good measure for difficulty levels but if you know the basics of haskell but none of the postgres libraries & web libraries you can probably do it in an afternoon or so
05:23:56 <msl09> hmm, it could be implemented in either way brynedwards 
05:24:15 <brynedwards> Well I would use postgresql-simple and http-conduit's simple module for the DB and REST bits
05:24:45 <msl09> yeah that's my level of understanding cocreature 
05:24:48 <cocreature> http-conduit for a REST _backend_? that seems like a really weird choice and I’m not sure if that’s even possible
05:25:09 * hvr would have gone for servant
05:25:21 <cocreature> just use Spock or something like that if you’re new to haskell
05:25:27 <cocreature> or scotty
05:25:32 <cocreature> I always forget which of those is the new one
05:25:36 <brynedwards> Sorry I thought he meant sending a request, not a backend
05:25:42 <liste> ^ scotty is the most noob-friendly
05:25:54 <typelevel> in :k I see a kind like `(k -> *)` what kind of Type is accepted here? I'm trying to understand the `k` part
05:26:01 <liste> Spock (like most others) utilize advanced concepts
05:26:23 <brynedwards> I've done some simple examples of Spock usage here https://github.com/brynedwards/spock-examples/tree/master/examples
05:26:30 <typelevel> I tried 'True and '[]
05:26:32 <cocreature> alright, then spocky and postgresql-simple will get you to your goal relatively easily
05:26:47 <mojjo> cocreature: The only way I get Path being a functor is: `instance Functor Path where fmap f (Path pts) = Path $ fmap (fmap f) pts` But i think this is not the one I'm looking for
05:26:49 <brynedwards> I can answer questions on basic Spock usage if you have any
05:26:59 <cocreature> mojjo: I’m pretty sure it is
05:27:11 <cocreature> mojjo: there is no other instance that satisfies the Functor laws :)
05:27:21 <geekosaur> what's accepted will depend on where/how it's used. often you'll find that it's intended to be parameterized by a lifted data constructor for a request type, or similar
05:27:27 <mojjo> cocreature: ok, this is already quite helpful to know ;-) !
05:28:45 <cocreature> mojjo: in fact Functor instances are always unique in Haskell if they exist and you can even ask GHC to find them for you
05:29:00 <mojjo> my function f could be: f (Point x y) = Point 1 1, with the above I could not just do: fmap f myPath
05:30:08 <cocreature> mojjo: right but that’s because Functor requires that you modify the thing that your type is parametrized over. and your type is not parametrized over Point
05:30:22 <cocreature> mojjo: in this specific case you could do fmap (\x -> 1) myPath
05:30:29 <cocreature> but that will fail if you want different values for x and y
05:30:42 <msl09> brynedwards: oh I just want to make posts and gets from haskell to a remote server, not the other way around
05:30:49 <Akii> might as well try my luck here. I've a problem which I fail to express in types well enough to be satisfied. Wrote a rather lengthy description here as well as the bad types I used. http://lpaste.net/353855 Anyone got a hint how to eliminate some of the invalid states?
05:31:02 <cocreature> mojjo: there is nothing wrong in making a "mapPoint :: (Point a -> Point b) -> Path a -> Path b" function. Functor only captures one specific pattern
05:31:08 <cocreature> if that doesn’t fit then don’t use it :)
05:32:08 <brynedwards> msl09: So you want a HTTP client? Then I'd look at http-conduit and Network.HTTP.Simple. There's a nice tutorial here https://haskell-lang.org/library/http-client
05:32:29 <mojjo> cocreature: Alright... ;-) But, could I also define Path parametrized over Point?
05:32:56 <cocreature> mojjo: you could define "data Path a = Path [a]"
05:33:05 <msl09> oh nice
05:33:09 <msl09> thanks brynedwards 
05:33:15 <cocreature> mojjo: and then if you have a "Path (Point a)" you can map points to something
05:33:16 <brynedwards> =)
05:34:00 <mojjo> cocreature: Yes, I see. I think this really solves my problem...
06:24:42 <spatial> http://lpaste.net/353843 This code updates and returns an array which is then use in subsequent lines. Any problem with the scope here ?
06:25:49 <spatial> Sorry. This code http://lpaste.net/353859
06:26:16 <spatial> Any possibility of an updated array going out of scope ?
06:26:34 <spatial> And not used by following statements.
06:27:11 <spatial> a,b.c.d and d' area arrays
06:33:51 <arpl> "If a tree falls in a forest and no one is around to hear it, does it make a sound?" A philosophical question ... and now a spatial observation.
06:38:43 <elfeck> Hi, can someone tell me how I can apply a function f :: (a -> b) -> c to g :: a -> b -> c so I can write g f
06:42:51 <geekosaur> that doesn't make any sense
06:43:03 <geekosaur> was the first one intended to be a tuple?
06:44:46 <raduom> elfeck: works for me. (f, g, g f) :: ((a1 -> b2) -> c2, a -> b -> c, b1 -> c1)
06:45:25 <elfeck> raduom: yeah, sorry I confused myself
06:45:30 <elfeck> raduom: I got it now
06:50:50 <laserpants> Trying to grok all this F-Algebra stuff; having a type data T = X | Y T T, and expressing this as data e.g. data U a = X | Y a a and then expressing the original type as a fixed point of U. That's the basic idea, or? 
06:51:09 <mnoonan> laserpants: yup
06:51:31 <laserpants> So what is the main advantage? From a more operational point-of-view.
06:52:37 <lyxia> you can compose U with other functors to insert stuff between nodes
06:52:41 <mnoonan> for me, I like it for making it nice to write various folds over your type
06:52:42 <byorgey> laserpants: (1) you can write things like folds and unfolds that are generic over any data type expressed as a fixpoint, instead of writing a fold and unfold for each new data types; (2) you can mix in things before taking a fixpoint, like having an annotation at each node
06:52:45 <mnoonan> e.g. in https://github.com/matt-noonan/FractalStream/blob/master/src/Lang/Expr.hs
06:53:30 <byorgey> laserpants: some more concrete examples can be found in http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.83.500
06:54:57 <laserpants> Thanks. I'll have a look at these links. I think I need to read some more code to see how this is used, but some libraries are a bit too advanced when you're just starting to grok these concepts.
07:19:30 <shapr> I think my coworkers think of my Haskell code the same way they think of APL code, 'so concise it's line noise'.
07:20:17 <c_wraith> Hmm.  I usually don't think that about haskell, but definitely still do about APL.
07:20:24 <c_wraith> Though I've written line-noise Haskell
07:20:32 <Sornaensis> you can make haskell look as obnoxious as APL
07:20:37 <c_wraith> Usually by using applicative operators to go pointfree
07:21:04 <c_wraith> pure is one letter shorter than const!
07:26:45 <shapr> On the other hand, some of them rewrite the compact bits in their own language of choice, it's a fun learning experience.
07:27:44 <shapr> I still don't understand clojure transducers, can someone explain them to me in terms of Haskell code?
07:29:17 <c_wraith> You know, the things that make Haskell seem concise to me aren't even the line noise operators.  They're useful library functions like traverse that other languages just don't have.
07:29:43 <c_wraith> I keep wanting to monkey-patch traverse (or at least traverse_) into Ruby projects I end up on.
07:29:56 <merijn> shapr: Basically a mix of Tekmo's fold package and pipes/conduit
07:32:30 <shapr> c_wraith: I haven't been able to convince my coworkers that having map and fold available for every datatype is worthwhile.
07:33:22 <shapr> c_wraith: have you written much APL?
07:33:39 <Sornaensis> c_wraith: yea after I learned haskell I noticed these patterns in other languages I use
07:35:08 <phz_> hey, I have a stack template file
07:35:21 <phz_> is there a place I should put it so that I can use it with stack new --template?
07:35:34 <phz_> put it in*
07:35:42 <merijn> shapr: So, 3 years ago at a PLDI workshop on array programming someone presented their APL dialect, the compiler for it was written in the language itself. So he decided to show us how elegant APL is by displaying one of the compiler passes
07:36:02 <brynedwards> phz_: stack templates are taken from https://github.com/commercialhaskell/stack-templates
07:36:09 <merijn> shapr: It was just an 80 column, ~34 lines dense blob of unicode characters and everyone in the audience was like "wut?"
07:36:30 <brynedwards> I think they're working on a way for people to include their own templates, but right now it doesn't look like an option
07:36:46 <phz_> I’m having a look at that
07:40:36 <spatial> http://lpaste.net/353862 I see a non-exhaustive pattern error in choosebestmove. Which is missing ?
07:41:00 <spatial> with EQ or without
07:42:53 <merijn> spatial: What's the error? My guess is that the problem is in choosebestmove, not your case
07:42:57 <mnoonan> spatial: isn't it the choosebestmove a [] b c case?
07:43:03 <merijn> spatial: Since choosebestmove doesn't handle empty list
07:44:06 <_sras_> Is there anyway to read a full request body from a request in a Wai middleware but not consume it, so that application that follow can read it?
07:44:32 <spatial>  Non-exhaustive patterns in case
07:48:40 <merijn> spatial: Impossible to say what's missing without full error and line numbers
07:48:51 <merijn> (Well, not impossible, but I can't be arsed :p)
07:49:44 <spatial> LInes correspond to case compare bestvalue1 xvalue of                       LT -> choosebestmove b xs xvalue x;                       GT -> return (bestmove1,b)  
07:50:14 <spatial> Non-exhaustive patterns in case is exact exception. At runtime.
07:50:53 <merijn> spatial: That's not a full error message
07:51:46 <spatial> *** Exception: file.hs:(220,21)-(222,48): Non-exhaustive patterns in case
07:55:27 <c_wraith> shapr: I've written no APL, which would be why it all looks like line noise to me.
07:55:40 <brynedwards> Maybe put the full exception in lpaste
07:58:00 <c_wraith> _sras_: sure, but with the obvious caveat that it means keeping the entire request body in memory, which might be gigabytes
07:59:05 <_sras_> c_wraith: Yes.
07:59:05 <merijn> c_wraith: Unless he basically wants "tee" but for conduit? :)
07:59:23 <c_wraith> merijn: wai doesn't actually use conduit in its interface! :)
07:59:38 <c_wraith> _sras_: here's a poorly-documented secret: https://hackage.haskell.org/package/wai-3.2.1.1/docs/Network-Wai.html#v:requestBody
07:59:58 <c_wraith> _sras_: that's a record accessor
08:00:17 <c_wraith> _sras_: you can use it to *set* the requestBody on the Request value passed to the next action
08:01:49 <c_wraith> _sras_: so if you have the full request body sitting around, you can set that to just "return body"
08:02:08 <c_wraith> _sras_: far more complex options are available - it's just an IO action
08:02:14 <_sras_> c_wraith: Yes. 
08:05:35 <c_wraith> err.  I guess it has to be slightly more complex than "return body"
08:06:02 <c_wraith> It has to handle subsequent calls with return empty
08:06:25 <_sras_> I see....
08:06:38 <_sras_> Where is it written?
08:06:40 <spatial> Is there a way to fit [] check in  LT -> choosebestmove b xs xvalue x;                       GT -> return (bestmove1,b) ?
08:07:21 <c_wraith> _sras_: where is what written?
08:07:39 <spatial> LT & []
08:07:39 <lyxia> spatial: What does that mean? Can you paste a more complete part of your code?
08:08:02 <_sras_> c_wraith: I mean, is there a spec or somethign that says it should be the behavior...
08:08:12 <spatial> http://lpaste.net/353862 Non-exhaustive patterns in case
08:08:23 <c_wraith> _sras_: just in the documentation that I linked to before
08:09:47 <lyxia> spatial: it's not clear from that snippet alone what the error could be
08:10:36 <_sras_> c_wraith: ok. So not doing this. Keeping the entire req body or reading it strictly seems quite dangerous...
08:11:00 <c_wraith> _sras_: well, in terms of being open to a DoS attack, yes.
08:11:04 <spatial> http://lpaste.net/353863 Function
08:11:33 <c_wraith> _sras_: but you can certainly implement the logic correctly if you trust all incoming requests (or verify that they're ok in some way before storing everything)
08:11:41 <lyxia> spatial: your exception message only spans 3 lines, did you make sure to save your code and recompile it?
08:11:47 <_sras_> c_wraith: Yes..
08:11:59 <lyxia> spatial: well in that snippet you're clearly missing a case at the end
08:12:19 <lyxia> spatial: whereas the snippet you first pasted had all three LT/GT/EQ
08:12:58 <spatial>      -- EQ -> choosebestmove b xs xvalue x;   Didn't see any change
08:13:51 <lyxia> If it's commented out it's not going to be compiled...
08:14:15 <spatial> Are there runtime exceptions in haskell ?
08:14:23 <lyxia> you just encountered one
08:15:06 <chenyu> spatial: Yes, I think. From IO operations.
08:15:41 <c_wraith> Not just IO operations.  you can get a runtime exception from anything
08:16:01 <c_wraith> It's just that if they don't indicate library user error, they should be counted as bugs.
08:16:19 <c_wraith> > case Just () of Nothing -> ()
08:16:22 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
08:16:31 <c_wraith> runtime exception from a pattern match. :)
08:16:55 <ventonegro> > head []
08:16:57 <lambdabot>  *Exception: Prelude.head: empty list
08:22:39 <timini> hi im trying to learn me a functionional proramming style
08:22:47 <timini> im actually using javascript 
08:23:04 <timini> but my question is more about functional programming than haskel
08:23:26 <funkshun> timini: alright
08:24:49 <spatial>            LT -> if (null xs) then return(0,a) else choosebestmove b xs xvalue x;             Tried this. No
08:25:36 <shapr> timini: what's your question?
08:26:47 <timini> so i have a function which retuns a list -  (...args) => [...args] - i want to curry that function so that i can append to the list by calling the curried function multiple times - 
08:27:39 <timini> curry((...args) => [...args])(3)([1,2]) = [1,2,3]
08:28:12 <c_wraith> that isn't really currying.
08:28:39 <c_wraith> It's just using a higher-order function that modifies arguments to another function
08:28:46 <funkshun> timini: you would be better off with a more typical append function
08:29:00 <funkshun> timini: as c_wraith said
08:29:12 <timini> cool - this is exactly why i asked you guys :)
08:29:25 <timini> i dont really know what currying is 
08:29:33 <funkshun> timini: come to haskell, then you can curry all you want :)
08:29:33 <timini> but i like saying it
08:29:58 <shapr> timini: it's spicy functions
08:30:08 <shapr> :t curry
08:30:10 <lambdabot> ((a, b) -> c) -> a -> b -> c
08:30:13 <marvin2> currying is taking a function that takes multiple arguments and returning a function that takes one argument and returns a function that takes the rest of the arguments
08:30:27 <shapr> :t uncurry
08:30:29 <lambdabot> (a -> b -> c) -> (a, b) -> c
08:30:36 <c_wraith> timini: your case *is* an example of using ideas from functional programming!  Just not currying. :)
08:31:21 <timini> funkshun, you mean array.append?
08:31:40 <brynedwards> There's an example of currying in JS here http://ramdajs.com/docs/#curry
08:31:42 <c_wraith> Unfortunately, this is a place where javascript is very non-functional
08:32:01 <c_wraith> Because you have two options on how to proceed - you either update the array, or create a new one.
08:32:04 <funkshun> timini: frankly, im not familiar with js, but the built in append method is likely heavily optimized
08:32:06 <c_wraith> Both are wrong in some cases
08:32:16 <funkshun> timini: it would be a good choice most likely
08:32:28 <timini> ok well i guess my question should be - something((...args) => [...args])(3)([1,2]) = [1,2,3] - is there a name for the function something in FP?
08:32:49 <c_wraith> In some cases, the caller will be shocked if the array they passed in was modified.  In other cases, the caller will be shocked if the array they passed in wasn't modified.
08:33:36 <c_wraith> This is the downside to default mutability.  You can't quickly tell if something is depending on it, or depending on the lack of it
08:33:58 <funkshun> hence, why we're here at #haskell :)
08:36:37 <spatial>  if (null xs )                       then case compare bestvalue1 xvalue of                              LT -> if (null xs) then return(0,a) else choosebestmove b xs xvalue x;                              GT -> return (bestmove1,b)                       else return(0,a)
08:36:51 <c_wraith> yeah, when the default is immutable and you see something mutable being used, you have a pretty good idea it's going to get mutated. :)
08:36:53 <spatial> This fixed the runtime exception. 
08:46:25 <rnaga> Any good online resource where I can find haskell code to read? Want to get a feel for the language
08:47:51 <merijn> rnaga: Without prior knowledge? Or did you already learn the syntax and want to see more "real world" usage?
08:48:56 <msl09> I'm running into some kind of problem installing postgresql-simple with stack
08:48:59 <msl09> http://lpaste.net/353864
08:49:29 <rnaga> I have an idea of the syntax, but I'm still quite new to haskell. Want to go through some "real world" code
08:50:12 <brynedwards> msl09: line 42 "Perhaps you need to add ‘postgresql-simple’ to the build-depends in your .cabal file."
08:50:23 <merijn> rnaga: Xmonad and pandoc?
08:50:38 <merijn> rnaga: XMonad is actually shockingly small :)
08:50:47 <merijn> Like <2.5k LOC iirc
08:51:15 <merijn> pandoc is pretty big, but pretty understandable, I think my first haskell contribution was patching the rST parser of pandoc :)
08:51:26 <shapr> rnaga: My coworkers most commonly use shellcheck, pandoc, and xmonad.
08:51:35 <merijn> Both should be fairly "basic" haskell, not too many extensions
08:51:40 <funkshun> rnaga: seconded for xmonad
08:51:52 * dram_phone is wasting one night on ghcjs
08:51:56 <infandum> What's a quick way to zip over a list of lists? i.e. someZip [1..] [[5,4,6],[1,234]] == [[(1,5), (2,4), (3,6)],[(4,1),(5,234)]]
08:52:07 <rnaga> Xmonad is awesome! Thanks!
08:52:10 <merijn> There's also several blogposts explaining xmonad's design :)
08:52:34 <rnaga> I'll definitely take a look at pandoc and shellcheck
08:52:53 <merijn> rnaga: https://xmonad.wordpress.com/2009/09/09/the-design-and-implementation-of-xmonad/
08:52:58 <shapr> infandum: I don't understand?
08:52:58 <lpaste_> msl09 pasted “haskellhal.cabal” at http://lpaste.net/4473648252025044992
08:53:08 <geekosaur> and a few people who mostly grok it as well :p
08:53:25 <msl09> ohhhh
08:53:39 <msl09> there is a build-depends for each source directory
08:53:46 <msl09> http://lpaste.net/4473648252025044992
08:53:48 <infandum> shapr: So zipping a list with another list, but that second list is a list of lists. I don't want the first level zipped, I want the inner level zipped
08:53:55 <dschoepe> infandum: Something like map (zip [1..]) [[5, 4, 6], [1, 2, 3]]?
08:54:12 <infandum> dschoepe: No, because it would start back at 1 for each sublist
08:54:13 <dschoepe> > map (zip [1..]) [[5, 4, 6], [1, 2, 3]]
08:54:16 <lambdabot>  [[(1,5),(2,4),(3,6)],[(1,1),(2,2),(3,3)]]
08:54:32 <merijn> :t \ls -> [ zip [1..] l | l <- ls ]
08:54:34 <lambdabot> (Enum a, Num a) => [[b]] -> [[(a, b)]]
08:54:36 <Vibor> Hi, I was trying to run an example about sql database, tried import Database.Sqlite in ghci, but it was not found. I tried cabal install Database.Sqlite, but no luck, so I'm stuck and how should I proceed ? thanks !
08:54:45 <merijn> oh, wait I see the problem
08:54:52 <merijn> Vibor: Which package is that from?
08:54:59 <geekosaur> cabal-install (nor stack for that matter) wants a package name not a module name
08:55:03 <merijn> Vibor: Cabal installs packages, not modules
08:55:08 <geekosaur> (it'd be nice if it dealt with that...)
08:55:09 <msl09> I have put the dependency to postgresql-simple on the src directory and I tried using it on the app directory
08:55:14 <Vibor> So what should I do?
08:55:30 <funkshun> Vibor: find the package name and install with cabal
08:55:34 * geekosaur generally looks up the module on hayoo to get the package
08:55:34 <infandum> [ zip [1..] [[1,2,3],[4,5]] | l <- [[1,2,3],[4,5]] ]
08:55:38 <geekosaur> ?where hayoo
08:55:38 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
08:55:42 <dram_phone> > [[5,4,6],[1,234]] & unsafePartsOf (each . each) %~ zip [1..]
08:55:42 <Vibor> The example is located here : https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/Simple%20examples#sqlite-database
08:55:44 <lambdabot>  [[(1,5),(2,4),(3,6)],[(4,1),(5,234)]]
08:56:00 <dram_phone> I saw partsOf here: https://redd.it/610sa1
08:56:04 <dram_phone> and it's unsafe because:
08:56:11 <infandum> yes!
08:56:16 <infandum> I knew it was probably in lens
08:56:17 <dram_phone> > > [[5,4,6],[1,234]] & unsafePartsOf (each . each) %~ zip [1..2]
08:56:19 <lambdabot>  <hint>:1:1: error: parse error on input ‘>’
08:56:25 <dram_phone> > [[5,4,6],[1,234]] & unsafePartsOf (each . each) %~ zip [1..2]
08:56:28 <lambdabot>  [[(1,5),(2,4),*Exception: unsafePartsOf': not enough elements were supplied
08:56:32 <dram_phone> *Not* the syntax error :(
08:56:44 <msl09> ok the build is advancing now sorry brynedwards 
08:56:48 <infandum> It was right the first time...
08:57:21 <Vibor> Got it thanks ! geekosaur merijn 
08:57:53 <dram_phone> infandum: I changed to [1..2] to illustrate why it's unsafe
08:58:08 <infandum> dram_phone: Ah. Thank you!
08:58:13 <dram_phone> it was because if you don't provide enough values back it's an error
08:58:24 <dram_phone> but [1..] is infinite so it must be enough :P
08:58:26 <infandum> dram_phone: Can you remind me of the word names for those functions rather than the symbols?
08:58:41 <dram_phone> :t (&)
08:58:42 <lambdabot> a -> (a -> b) -> b
08:58:45 <geekosaur> the annoying thing about this is that the exported modules of each package should be listed in the index db, so it *should* be able to resolve those itself
08:58:54 <infandum> :t %~
08:58:55 <geekosaur> (yes, I know, patches welcomed...)
08:58:56 <lambdabot> error: parse error on input ‘%~’
08:59:01 <infandum> :t (%~)
08:59:03 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
08:59:07 <dram_phone> :t over
08:59:09 <infandum> ah over
08:59:09 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
08:59:16 <infandum> awesome
08:59:28 <dram_phone> infandum: See, types are more useful here...
08:59:35 <dram_phone> Not everywhere in lens, though
09:01:12 <dram_phone> infandum: actually, see this
09:01:12 <brynedwards> np :)
09:01:18 <dram_phone> :t unsafePartsOf
09:01:19 <lambdabot> Functor f => Traversing (->) f s t a b -> LensLike f s t [a] [b]
09:01:20 <merijn> Anyone here that can tell me what the latex symbol for approximate values is, as in ~20% ?
09:01:36 <dram_phone> \approx maybe?
09:02:07 <merijn> dram_phone: That's the wavy =
09:02:24 <dram_phone> oops
09:02:39 <cocreature> merijn: \tilde?
09:03:03 <cocreature> hm no I think I’m remembering incorrectly
09:03:06 <dram_phone> http://detexify.kirelabs.org/classify.html says \sim
09:03:11 <merijn> ah
09:03:45 <merijn> \sim looks right
09:03:49 <infandum> \sim
09:04:27 <Magnap> Do note that \sim is a relation symbol
09:04:58 <dram_phone> did they, like, greatly improve the speed of compilation in GHC8?
09:05:05 <Magnap> So it might not behave the way you want it to
09:05:43 <merijn> Magnap: I'm using it in text anyway, as in "we get ~20% improvement"
09:05:45 <Magnap> In text mode you can use \textasciitilde
09:05:53 <Magnap> ^
09:06:39 <Magnap> See this TeX StackExchange answer: http://tex.stackexchange.com/a/55723/9350
09:09:29 <nrmn> Is there any way to find the function definition using ghci? I know :i shows where the function is defined
09:09:41 <glguy> That's the way
09:10:59 <nrmn> <glguy> Is there any way to open the file from within ghci?
09:11:34 <brynedwards> ghci doesn't really do that sort of thing, it'd be more of an IDE feature
09:11:54 <glguy> nrmn: No. In general there isn't any source code to edit for installed libraries
09:12:18 <glguy> You can use :edit to open your $EDITOR in the current module if that module is locally defined
09:12:52 <nrmn> Thanks!
09:12:54 <glguy> nrmn: The easiest way to get to source code is to click the Source links in haddock generated documentation
09:17:27 <harwiltz> Hello all. I'm trying to implement an identity monad (just a monad that does nothing), and I'm having some trouble using it in do notation (I've already successfully done operations with bind). Basically I have data Identity a = Identity a deriving (Show), and then I have some functions, times2 :: (Num a) => a -> Identity a and addIdentities :: (Num a) => Identity a -> Identity a -> Identity a. When I try
09:17:29 <harwiltz> let test = do {x <- times2 1; y <- times2 2; addIdentities x y;}, I get compiler errors
09:18:24 <glguy> harwiltz: x and y don't have Identity types
09:18:24 <harwiltz> First error is "No instance for (Num (Identity b0)) arising from the use of times2
09:18:26 <merijn> harwiltz: Well, it'd help to put the full error on lpaste :)
09:18:34 <harwiltz> glguy: they don't?
09:18:39 <glguy> harwiltz: so you can't apply addIdentities to x or y
09:18:48 <harwiltz> times2 outputs a Identity a though
09:19:03 <glguy> harwiltz: The point of do-notation is that given  "times2 1 :: Identity Int"
09:19:06 <glguy> then "x :: Int"
09:19:12 <merijn> harwiltz: Hint: rewrite this code using >>= instead of do notation :)
09:19:19 <harwiltz> glguy: so I should be able to replace that line with return (x+y)?
09:19:24 <glguy> harwiltz: sure
09:19:34 <harwiltz> merijn: I was thinking about something like that, but I don't want to use >>= in this implementation
09:19:43 <harwiltz> glguy: I think that gave me an error as well, Ill try again
09:20:03 <harwiltz> glguy: Oh, nvm, it compiled
09:20:05 <harwiltz> Haha
09:20:20 <merijn> harwiltz: My recommendation for beginners is *always* use >>= until you're comfortable doing that, then start using do notation. This helps understanding what the do notation actually does
09:20:37 <merijn> harwiltz: See also: https://en.wikibooks.org/wiki/Haskell/do_notation
09:20:42 <harwiltz> But then what happens, for example, if I was using Maybe instead of Identity, and x <- f returns Nothing? What would x store?
09:20:53 <harwiltz> merijn: Yeah, I got a little over-zealous ;)
09:21:01 <harwiltz> merijn: I'm gonna take that advice
09:21:05 <dram_phone> harwiltz: Write that in terms of >>= first
09:21:22 <harwiltz> dram_phone: I actually did, I guess I just got confused somewhere
09:21:26 <merijn> harwiltz: Well, rewrite that one to >>= too and you'll see what happens if it's Nothing :)
09:21:30 <harwiltz> dram_phone: Oh you mean the maybe one
09:21:35 <dram_phone> It's f >>= \x -> <the rest of the program>
09:21:38 <dram_phone> I did this for you
09:21:44 <dram_phone> And what if f is Nothing?
09:21:54 <harwiltz> dram_phone: Oh right... its just nothing
09:21:55 <dram_phone> Nothing >>= f = ...?
09:21:58 <dram_phone> bingo
09:22:06 <harwiltz> I see. Thanks
09:24:03 <dram_phone> Because Haskell functions inherently don't 'do' things
09:24:04 <dram_phone> harwiltz: it really helps to think about Haskell programs in terms of the result they calculate, and not what it 'does'.
09:24:08 <dram_phone> (That's a pun over there)
09:24:15 <harwiltz> Hahahaha, will do
09:24:27 <dram_phone> I know it's hard :P
09:24:38 <harwiltz> How can I go about making a Monoid instance of Identity? Is that even possible?
09:24:49 <harwiltz> Since there's no empty element I guess
09:24:58 <harwiltz> It must be impossible
09:25:24 <dram_phone> You said monoid, not monad, right?
09:25:29 <harwiltz> Yeah, monoid
09:25:43 <geekosaur> there's a Semigroup for that? :p
09:25:45 <harwiltz> I already made the monad :)
09:26:58 <merijn> harwiltz: You can do "instance Monoid a => Monoid (Identity a)"
09:27:16 <harwiltz> merijn: What does that mean?
09:27:23 <harwiltz> Ohhhh I see
09:27:41 <harwiltz> Could I also do "instance Monoid Int => Monoid (Identity Int)"?
09:28:00 <geekosaur> aside from ghc whining about the lack of type variables
09:28:03 <harwiltz> Or actually "instance Monoid Num => Monoid (Identity Num)"?
09:28:07 <geekosaur> no
09:28:13 <harwiltz> Aw, alright
09:28:13 <geekosaur> Num is a typeclass, not a type
09:28:24 <harwiltz> Thats what I was worried about
09:28:32 <geekosaur> but you can include Monoid and Num in the context for a tyvar
09:28:53 <geekosaur> (it'd be redundant here since Int is known to have a Monoid instance)
09:28:58 <harwiltz> But still, can I actually create a Monoid instance of Identity if it doesn't have a generic empty element?
09:29:14 <dram_phone> nope
09:29:17 <geekosaur> no.
09:29:20 <harwiltz> Ok, right]
09:29:27 <dram_phone> if you could you can just build something out of nothing
09:29:33 <harwiltz> Right
09:29:37 <geekosaur> but Semigroup is a monoid without the empty element
09:30:14 <harwiltz> Do you guys have any ideas of other simple monads I can implement? I'm thinking about making a monad that stores a 'state' of whether its parameter is even or odd
09:30:34 <harwiltz> like data Parity Int = Odd Int | Even Int
09:30:44 <harwiltz> Er
09:30:51 <harwiltz> data Parity = Odd Int | Even Int
09:30:59 <merijn> harwiltz: Well, simply implementing State and StateT is a good exercise and helps understand monad transformers
09:31:16 <harwiltz> merijn: Oh, that's true
09:31:34 <merijn> harwiltz: https://gist.github.com/merijn/098106abd45c940dab09
09:31:40 <harwiltz> I don't have a clue what a monad transformer is yet though ;)
09:31:58 <merijn> harwiltz: Honestly, just filling in the blanks here should answer that question :p
09:32:03 <Sornaensis> transformers, monads in disguise
09:32:37 <harwiltz> merijn: Thanks!
09:32:55 <harwiltz> I didn't know you could define (>>=) or (<*>) as undefined, that's nice
09:33:03 <merijn> harwiltz: the idea behind monad transformers that you use a transformer to, well, transform an existing monad, adding additional behaviour to >>=
09:33:13 <harwiltz> Oh wow
09:33:14 <merijn> harwiltz: You can actually do something much nicer and GHC these days
09:33:16 <dram_phone> > undefined -- That's what undefined do
09:33:18 <lambdabot>  *Exception: Prelude.undefined
09:33:24 <Sornaensis> :t undefined
09:33:26 <lambdabot> a
09:33:26 <harwiltz> Oh, haha
09:33:33 <merijn> harwiltz: You can use _ or other names starting with _
09:33:47 <merijn> And GHC will still typecheck your code, but produce an error at the end
09:33:57 <merijn> So unlike with undefined you can't forget to remove your _
09:34:08 <merijn> :t map _ [1..10]
09:34:09 <harwiltz> Oh... alright. So basically whenever I wanna make a monad I actually do have to make the applicative as well
09:34:10 <lambdabot> error:
09:34:10 <lambdabot>     • Found hole: _ :: Integer -> b
09:34:10 <lambdabot>       Where: ‘b’ is a rigid type variable bound by
09:34:23 <merijn> harwiltz: Well, in reality not really
09:34:33 <harwiltz> merijn: How can I avoid it?
09:34:40 <merijn> harwiltz: You can only write Monad and then do "pure = return; (<*>) = ap"
09:34:59 <harwiltz> Oh, makes sense actually, that's nice
09:35:03 <merijn> harwiltz: But it's easier to do all instances by hand in this example for educational purposes
09:35:24 <merijn> harwiltz: Are you familiar with "default implementations" ala only needing to define either == or /= ?
09:35:32 <harwiltz> No
09:35:48 <harwiltz> merijn: I actually just got to class, I gotta leave for now. Thanks for the help!
09:58:47 <heath> what is this iterateFB function? https://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.List.html#iterateFB
09:59:24 <heath> maybe if i knew what FB stood for, that would help
09:59:34 <geekosaur> fold/build
09:59:52 <ChaiTRex> heath: I think it's used behind the scenes for fusion.
09:59:59 <geekosaur> that, pretty much, yes
10:00:28 <heath> perfect, thanks you two
10:00:29 <geekosaur> if you rewrite stuff to fold/build form, it's easier for the compiler to detect opportunities to fuse stuff away
10:00:47 <ski> `iterateFB c f xs = foldr c undefined (iterate f xs)', i think
10:56:36 <lpaste_> lambdafan pasted “sum of two squares error” at http://lpaste.net/1472901292622872576
11:03:07 <ClaudiusMaximus> lambdabot: +/- 1, +/- 3 gives 4 possibilities total
11:03:24 <ClaudiusMaximus> oops, lambdafan 
11:05:34 <lambdabot> ClaudiusMaximus: no worries mate!
11:06:06 <ClaudiusMaximus> though the wiki page says that different orders should be counted too?  so that should give 8 as the answer...
11:20:12 <byorgey> lambdafan, ClaudiusMaximus: indeed, it should be 8.  The discrepancy is that you are not counting 1 as a divisor of anything.  line 24 should be  ... divisors' 1 k
11:28:50 <Iluvala> hello
11:29:22 <Iluvala> i've been looking for a question...
11:29:30 <Iluvala> can anybody help me?
11:30:05 <eugenez> Hello, friends! Say, how do I check whether Data.Map.lookup return Just x or Nothing and branch based on that? I wanted to use guards like that: func x; | Map.lookup x mymap == (Just _) = some_output, and so on but haskell complains of a new found hole...
11:31:18 <pavonia> eugenez: Usa a case expression: case lookup x mymap of { Just x -> ...; ... }
11:31:34 <pavonia> :t maybe
11:31:35 <lambdabot> b -> (a -> b) -> Maybe a -> b
11:31:42 <pavonia> ^ that's another option
11:31:49 <geekosaur> if you want to do it with guards, you can use a pattern guard
11:32:54 <eugenez> Thank you friends!
11:32:56 <eugenez>  1 ann n                                                                                       │Loaded GHCi configuration from /tmp/ghci10719/ghci-script
11:33:22 <eugenez> oops sorry :0
11:34:14 <geekosaur> | Just _ <- Map.lookup x mymap 
11:34:28 <geekosaur> myy require PatternGuards extension, I don't recall if that made haskell2010
11:34:40 <monochrom> Iluvala: what question are you looking for?
11:35:04 <monochrom> Pattern guards made it into Haskell 2010.
11:42:18 <Iluvala> so, i want to know how is the traduction of Haskell on every platform
11:42:43 <monochrom> What is traduction?
11:43:12 <Iluvala> if it's fast or slow 
11:43:31 <Iluvala> in compiling
11:44:33 <davean> is traduction a word from another language?
11:44:46 <davean> I can't even figure out what you might have meant to put there if its english
11:44:59 <davean> and fast-or-slow begs for a definition
11:45:02 <Iluvala> mmmm ok
11:45:05 <davean> and the answer is "it varies"?
11:45:14 <Iluvala> i can say "translation"
11:45:28 <davean> your optimization levels, the code complexity (on some sometimes unexpected axis), etc
11:45:43 <Iluvala> sorry, English it's not my native language ;|
11:46:55 <davean> In practice the answer is probably "slow" for many people, though you can choose "fast" with certain downsides, but "slow" is relative
11:47:20 <Iluvala> yeh
11:47:41 <geekosaur> English cognate "transduce", compare Italian "traducere"
11:48:00 <Iluvala> but how do you think is on compiling? speaking of mac, windows or linux
11:48:22 <davean> Iluvala: the platform is irrelivent?
11:48:37 <davean> Also, I'm having a REAL hard time guessing your meanings
11:48:44 <geekosaur> ^
11:49:11 <Iluvala> :(
11:49:13 <Iluvala> sorry
11:49:27 <davean> Its ok, I'm guess really guessing as to your question when I answer
11:49:40 <davean> *just really guessing
11:49:54 <shapr> Iluvala: yeah, how do you think *what* is on compiling? Do you want which platform compiles faster?
11:49:58 <Iluvala> it's a confused question that i can't do
11:50:02 <geekosaur> some people complain that ghc is slow (possibly compared to earlier versions) but to me it's pretty fast unless template haskell is involved
11:50:16 <geekosaur> ...much like c++ compilers are fast unless you have lots of templates
11:50:28 <geekosaur> (otoh the standard template library is full of ... templates)
11:51:04 <cocreature> geekosaur: who would have thought that the standard template library uses templates :)
11:51:14 <Iluvala> jaja
11:51:22 <Iluvala> thanks guys
11:51:58 <davean> Iluvala: "it probably won't take more then a minute"
11:52:16 <davean> (But you haven't given nearly enough information for a meaningful answer)
11:52:26 <davean> "It might take less then a second"
11:52:53 <davean> "In practice, Haskell code takes from milliseconds to hours to compile"
11:52:54 <Iluvala> no, i mean thanks for yours thoughts
11:53:20 <Iluvala> it's gonna be ok to answer my homework 
11:53:25 <davean> (I'm actually confused as to why you asked about the operating system portion) 
11:53:48 <davean> the only part that varies by operating system is the linking step and OS calling convention
11:53:54 <davean> which is really quite irrelivent
11:54:05 <davean> and that doesn't vary by Mac/Linux much
11:54:13 <davean> though the toolchain you refer to can
11:54:30 <davean> The compiler you use matters, but most people use GHC
11:54:37 <Iluvala> yeh
11:54:43 <davean> other compilers for Haskell have different performance characturistics
11:54:55 <davean> you'll vary more by CPU type, because then we're using a different backend (in GHC at least)
11:55:06 <Iluvala> 0:
11:55:10 <davean> OS isn't a highly correlated value here
11:55:26 <davean> Frankly, architecture isn't overly predictive either
11:55:37 <davean> what assembly we us just isn't that much of the compile time
11:56:02 <davean> the optimizations turned on and the code it's self are what matter most
11:56:19 <dolio> I suspect a lot of people don't optimize their workflow as much as they could with respect to compile times.
11:56:47 <dolio> -O0 during most development, and only -O or -O2 when you need to look at performance.
11:57:01 <davean> dolio: uh, well, frankly a lot of code just doesn't *work* with -O0
11:57:17 <davean> -O0 can lead to flat-out non-functional code in practice
11:57:34 <davean> so you can't run tests?
11:57:42 <dolio> Is -O0 going to stop your code from compiling?
11:57:48 <Iluvala> thanks guy, that will suffice
11:57:57 <davean> dolio: no, but it'll stop tests from passing
11:58:08 <dolio> If not, then you can at least use O0 when weeding out type errors.
11:58:20 <cocreature> dolio: then you can also use -fno-code :)
11:58:28 <dolio> That exists?
11:58:29 <davean> yah
11:58:33 <cocreature> yep
11:58:37 <dolio> Huh.
11:58:44 <Iluvala> blessings 
11:58:51 <davean> I don't know why you'd do a full compile with -O0
11:59:07 <davean> It makes sense to just do the front passes and not have optimizations come into it
11:59:16 <davean> once I *generate actual code* I want -O
11:59:19 <dolio> Well, I never compile with O0, either. But I don't complain about compile time.
11:59:22 <davean> otherwise why did I generat eit?
11:59:30 <cocreature> davean: well I never had my code break with O0 so I often compile with O0 and run it
11:59:39 <davean> cocreature: ah, I see it all the time
12:00:22 <cocreature> davean: you got me interested. do you have a specific example of code that breaks with O0?
12:01:01 <davean> cocreature: The general form is it generates extra intermediate data, etc and stack overflows
12:01:12 <davean> where it operates in O(1) with optimizations
12:01:25 <davean> Thats the most common case
12:01:36 <cocreature> ah yeah
12:01:41 <cocreature> that makes sense
12:01:48 <davean> and you COULD make it work with -O0
12:01:52 <davean> but then I might as well write C
12:01:57 <davean> because they'll look the same
12:02:08 <cocreature> that’s a bit harsh but you have a point :)
12:02:22 <davean> :)
12:02:33 <tobiasBora> Hello,
12:03:00 <cocreature> davean: I usually run with -K1K :)
12:03:05 <davean> cocreature: so, Alec actually has a "CMonad" that he pasted C code into and ran it
12:03:28 <davean> cocreature: Its based on RWS
12:04:28 <cocreature> RWS is one of those weird things that I’ve learned about pretty early on but I never used in actual code
12:04:49 <davean> cocreature: He never had untill he wanted to paste git code and have it behave the same in a Haskell program!
12:05:47 <davean> cocreature: It excited him for weeks
12:06:12 <geekosaur> there's a BASIC monad on hackage somewhere >.>
12:07:03 <davean> geekosaur: sadly theres not a C monad because people are bad at releasing things
12:08:11 <davean> (its not all of C, but it covers enough to allow a decent copy-pasta migration of some interesting bits) 
12:11:54 <benzrf> davean: hmm, what? copy paste?
12:12:00 <benzrf> was it using template haskell or something?
12:12:04 <davean> benzrf: no
12:12:20 <benzrf> so it was just a C interpreter basically?
12:12:52 <davean> No, it was just a monad with similar semantics, and a bunch of functions that allowed most C code to be ~= valid Haskell code
12:12:57 <dolio> If he's talking about the one Lennart made, it involved a bunch of overloading weird stuff, I think.
12:13:02 <benzrf> ohhhh
12:13:16 <benzrf> oh wow, that's pretty fucked up
12:13:17 <dolio> So that 'a[5]' was an array access.
12:13:27 <dolio> But also could be assigned to.
12:13:27 <davean> benzrf: you could paste function bodies from C and get Haskell functions
12:13:32 <davean> benzrf: it was statement level though
12:13:36 <benzrf> good god
12:13:45 <davean> benzrf: yep
12:14:02 <benzrf> how on earth do you get away with using = for assignment
12:14:07 <davean> OTOH, "What does that weird bit of C in git do?" becomes "Eh, deal with that later, paste it for now"
12:14:17 <geekosaur> heh
12:14:29 <benzrf> or prefix operators
12:14:59 <geekosaur> some questions may be best not asked. (or, perhaps, not answered especially if it involves looking at the implementation...)
12:15:15 <benzrf> i mean, did it support those things?
12:15:24 <benzrf> or did u have to tweak it replacing a few small pieces of syntax
12:15:33 <geekosaur> +1 int, -2 san :p
12:15:36 <benzrf> eg = to =:
12:28:26 <talzs> Does anyone know if haskell-mpi is still good? Are there any other distributed memory libraries that I should look at?
12:33:42 <dolio> benzrf: They also convinced everyone that 'variable' is about assignment.
12:34:30 <Athas> talzs: have you looked at Eden?  It's a modification of the GHC RTS that supports distributed memory.  It has a lot more buyin than a pure library, of course, but it is very smooth.
12:34:49 <Athas> You can transparently send closures and even IO actions across the network.
12:35:28 <talzs> Athas: I haven't yet, but that sounds nice. I'll take a look at it, as I don't really want to deal with mpi haha
12:35:49 <Athas> I don't think anyone _wants_ to deal with MPI.
12:40:58 <shapr> Yeah, MPI is frustrating
13:00:20 <scope> Hey guys, is this the correct way to create a module? Do I need a "where"? http://lpaste.net/3039850871400693760
13:01:41 <mmachenry> scope: Pretty sure you need to have a where at the end of that module line.
13:02:01 <scope> would that be all I need to add or am I missing something else?
13:02:09 <mmachenry> That's it.
13:02:15 <mmachenry> At least that's all I ever do.
13:02:22 <scope> awesome, thanks
13:02:32 <mmachenry> I often put the exports on a line each.
13:03:40 <scope> also, do you have any idea why my ghci takes so long to load?
13:03:46 <scope> it didn't used to be like this
13:07:52 <alx741> scope: it depends on what are you loading on it (if any?) or just ghci invocation without any paramters (no program to load)
13:10:39 <scope> literally just the ghci command
13:10:42 <scope> from CMD
13:10:49 <scope> takes around a minute to load and get into prelude
13:13:54 <alx741> when it's done loading take a look at what it spits out "Loaded GHCi configuration ... " and other stuff, that may point you to a potential problem
13:16:11 <monochrom> benzrf: Before C came around, Algol and Pascal used := just fine.
13:16:23 <AWizzArd> The new 8.2 Compact regions (non-gc region) – does it also support deletion of objects? Can I remove data from the compact region?
13:16:25 <geekosaur> "ghci -v" maybe to see what it's loading
13:16:32 <monochrom> My understanding is that C's rational for = is "saves typing"
13:16:41 <monochrom> err, rationale!
13:17:28 <dolio> Clearly bad thinking.
13:17:39 <dolio> They should have made it longer, so that fewer people would want to use assignment.
13:17:59 <geekosaur> better rationale than some things in C, like confusing pointers and arrays :)
13:18:17 <geekosaur> (and, thereby, programmers)
13:19:53 <seequ_> It's not like assignment is a bad thing in C. ;)
13:20:22 <dolio> Yes it is.
13:20:49 <kuribas> dolio: you would use tail recursion?
13:21:01 <kuribas> it blows up the stack quickly
13:22:28 <kuribas> without TCO assignment is the best option.
13:22:53 <dolio> Being the best doesn't make you good.
13:23:41 <mauke> who needs assignment when you have memcpy?
13:23:54 <dolio> Don't C compilers do good tail calls, to?
13:23:56 <seequ_> I think modern C has TCO, but the language still is unusable without liberal assignments.
13:24:57 <mizu_no_oto_work> Clearly, the right way to do assignment is to have assignment functions like rplaca and rplacd.
13:24:58 <mnoonan> afaik C doesn't *guarantee* TCO in the language, which is kind of limiting
13:27:02 <mauke> dolio: I've seen gcc turn 'unsigned fac(unsigned n) { if (n < 2) { return 1; } return n * fac(n - 1); }' into a loop
13:27:27 <dolio> That's pretty good.
13:29:24 <dolio> I'm not sure not having a language guarantee is a real limit.
13:29:32 <dolio> It could be an excuse.
13:29:52 <seequ_> C shouldn't be written with a functional style. That's taking a shotgun, strapping a few rocket boosters to it and using it for a surgery. :P
13:30:13 <nshepperd> rocket surgery, you say
13:30:13 <dolio> But people program to specific compiler features all the time.
13:31:36 <nshepperd> C has almost no language guarantees. in practice people program gcc x86 C
13:31:57 <seequ_> Programming C to specific features is counter-productive as that reduces portability greatly.
13:31:59 <nshepperd> (or clang or VC+)
13:32:49 <Jacoby6000_> seequ_: some problems lend themselves to very concise and understandable recursive solutions (like factorial)... I wouldn't say you should avoid recursion simply because a language isn't functional
13:32:56 <dolio> Programming C is often counter-productive, but people still do it.
13:33:06 <seequ_> C has a lot of guarantees of things that aren't defined. :p
13:33:31 <nshepperd> but if gcc or clang doesn't guarantee TCO, I wouldn't use recursion
13:33:51 <seequ_> Jacoby6000_: Well, if on some other pc it blows up the stack, you'll be sad.
13:34:20 <seequ_> dolio: Necessity usually is very productive.
13:36:06 <kuribas> Jacoby6000_: If the recursion depth isn't large it's ok.
13:36:53 <seequ_> You obviously have to be wary of embedded systems.
13:43:37 <tobiasBora> Is there a symbol equivalent of fmap?
13:43:47 <tobiasBora> something like >>=
13:43:53 <monochrom> Yes, <$>
13:44:42 <monochrom> In recent GHCs it's also in Prelude so you need not import anything extra. (But older GHCs would have you import Data.Functor or Control.Applicative, your choice.)
13:45:46 <tobiasBora> Hum...
13:45:56 <tobiasBora> Maybe it's not the good one, I tried :
13:45:57 <tobiasBora> lines <- (readFile "/tmp/test.txt") <$> unlines
13:46:02 <tobiasBora> and it does not work.
13:46:05 <monochrom> The other order!
13:46:12 <tobiasBora> sure
13:46:16 <tobiasBora> Thank you!
13:46:31 <tobiasBora> And in this order there is no symbol that do the job?
13:46:47 <monochrom> I don't know.
13:47:28 <tobiasBora> ok thank you
13:48:30 <dolio> There's <&> in lens.
13:49:30 <minn> I have 2.2GB of free disk and want to install Haskell using Stack, with room left over. Why would stack setup require all 2.2GB and fail when unpacking the compiler? Does it really require that much space?
13:50:23 <davean> no, but I'm sure stack installs extra stuff. But 2.2GBs of free space will give you serious issues actually using anything
13:50:26 <monochrom> GHC is about 1.7GB
13:50:50 <davean> monochrom: huh?
13:50:57 <davean> monochrom: not any version I've ever used
13:51:53 <minn> That's huge! Unfortunately that probably rules out using Haskell for this project. I never realized the compiler and libraries were so large.
13:51:57 <davean> that being said, even if GHC isn't that large, theres no real reason to fix things if you only have 2.2GBs of space, because irrespective of the size of GHC thats not a useful amount of space
13:51:58 <dolio> I thought it was more like 0.7GB.
13:52:05 <davean> dolio: yes
13:52:09 <davean> minn: well, don't use stack
13:52:47 <davean> but still, why are you compiling in a space limited enviroment?
13:55:58 <minn> I could compile GHC without Stack; but footprint is probably too large. I can request lots more space, but others would need to replicate the setup in a space limited environment (e.g., virtual machines with fixed disk space).
13:56:12 <davean> "compile GHC"? what are you doing?!
13:56:26 <davean> why wouldn't you use a compiled GHC?
13:56:47 <davean> theres so many things wrong about this
13:58:03 <Adluc> I am happily running stack with everything on beaglebone black, but have to enable swap with at least 2GB, therefore 3GB total with integrated ram
13:58:24 <Adluc> and mounted home on external flash drive, at least 8GB
13:58:28 <davean> Adluc: he said disk
13:58:31 <davean> we're not talking about RAM
13:59:01 <dolio> 2.2GB RAM would be pretty dicey, too.
13:59:12 <davean> 2.2GBs of RAM would be sensible to work on
13:59:31 <Adluc> I just have a flash drive for compiling, resulting binary runs without it
14:00:25 <davean> Adluc: right, and worse he said compiling GHC, not compiling WITH ghc
14:04:49 <minn> Okay, well I this problem was caused by me being an idiot. The binary packages seem to work fine.
14:05:00 <scope> hey guys, what's the fastest way to split a string into a list on whitespace characters?
14:05:05 <scope> easiest way, rather
14:05:08 <dolio> words
14:05:11 <scope> ty
14:05:53 <monochrom> When you want more generalized splitting, there is Data.List.Split.
14:07:45 <tobiasBora> Hum...
14:07:52 <tobiasBora> I've a but I can't understand:
14:07:56 <scope> monochrom, what if I need to split the string into a type such as [(float, float)]?
14:08:05 <tobiasBora> I've in the top of my file: type WriteMethod = WriteFile Handle
14:08:16 <tobiasBora> and latter:
14:08:17 <tobiasBora> writeUser :: WriteMethod -> Person -> IO ()
14:08:19 <tobiasBora> writeUser (WriteFile handle) person = do
14:08:35 <monochrom> You will have to split string to strings first, then convert to (float, float) individually.
14:08:38 <tobiasBora> And I have an error  Not in scope: data constructor ‘WriteFile’
14:08:46 <davean> minn: You'll will 2.2GBs quickly with any notable library stack though
14:08:54 <scope> using map?
14:08:57 <davean> minn: I currently have 6.7GBs of installed, compiled, libraries
14:09:01 <davean> for example
14:09:12 <monochrom> Yes, map is helpful.
14:09:26 <mauke> tobiasBora: what's WriteFile?
14:09:41 <davean> minn: You won't be able to function high up the stack with 2.2GBs of space
14:09:55 <davean> mauke: though you can avoid probiling and such to limit the size a bit
14:09:59 <davean> minn I mean
14:10:00 <tobiasBora> mauke: Well a personal Constructor: type WriteMethod = WriteFile Handle
14:10:15 <mauke> tobiasBora: that doesn't define WriteFile
14:10:35 <monochrom> tobiasBora: Do you have the definition of WriteFile anywhere? Where did it come from? Show actual code?
14:10:36 <tobiasBora> mauke: Really?
14:10:42 <ertes> tobiasBora: 'type' and 'data' are different things
14:10:49 <tobiasBora> ertes: Ahhhh
14:10:58 <monochrom> Oh, yeah you need "data".
14:11:06 <mauke> or newtype
14:11:32 <tobiasBora> I always exchange these two, what is the exact difference?
14:11:48 <monochrom> "type" is synonym. Consider it merely macro.
14:12:04 <ertes> tobiasBora: 'type' defines a type alias, so you're declaring that the type 'WriteMethod' should be the same as the type (!) 'WriteFile Handle', and then naturally it complains that it doesn't know what WriteFile is
14:12:31 <tobiasBora> hum ok then you !
14:12:31 <mauke> newtype is like type internally, but to code it looks like data
14:12:34 <monochrom> If you say "type X = Int" then X and Int are interchangeable, indistinguishable.
14:13:32 <tobiasBora> Thank you:D
14:14:15 <tobiasBora> And is there a shortcut for Person { username  = username, age = age} ?
14:14:25 <tobiasBora> I tried to remove the = username, and it complains
14:14:33 <minn> davean: That's really useful information - thank you for the help. I'm pretty sure that rules out using Haskell, which is unfortunate.
14:14:49 <monochrom> There are extensions, RecordPuns and RecordWildcards
14:15:01 <davean> minn: I don't know many things where compiling things using a lot of libraries is small
14:15:30 <scope> monochrom this is what I'm trying to do if this makes it more clear http://lpaste.net/6413022704261136384
14:15:32 <davean> minn: look at the size of C libraries+headers for any moderate sized project
14:15:45 <davean> how big is boost installed?
14:16:03 <miniBill> So I've got a monad t, and I want to write a function (Monad m) => t (m a) -> m (t a). Is there an intelligent way to write it without reimplementing the wheel?
14:16:13 <davean> minn: looks like boost can install to 10.9GBs?
14:16:21 <miniBill> The monad is a simple tree monad
14:16:29 <monochrom> scope: Yeah, it will go like: map parsePoint (words string). Now you have to implement parsePoint.
14:16:46 <scope> ah ok wasn't sure if I needed a helper
14:16:52 <davean> minn: it seems really weird to worry about toolchain size and not size of the resultant binary
14:16:56 <monochrom> Do you also need to worry about parse errors and invalid string inputs?
14:17:06 <dolio> miniBill: That looks like the type of sequence.
14:17:37 <ertes> miniBill: if it's an algebraic tree, you can pretty much let GHC write 'sequence' for you
14:17:38 <monochrom> Oh, helper is optional but separating it out is probably less insane.
14:17:42 <ertes> miniBill: -XDeriveTraversable
14:18:02 <scope> so monochrom, parsePoint would end up returning what, a list of (float,float) correct?
14:18:05 <miniBill> dolio: indeed! thanks!
14:18:13 <miniBill> ertes: I'll try DeriveTraversable, thanks
14:18:17 <monochrom> For all I know, if you wrote "map (\s -> ... long code for parsing here ...) (words string)" I would still understand it :)
14:18:35 <monochrom> No, it's individual, String -> (Float, Float)
14:18:39 <ertes> miniBill: you can also derive Foldable and Functor, on which Traversable depends
14:18:43 <scope> ah okay, thank you
14:19:01 <miniBill> ertes: thank you very much
14:20:22 <minn> davean: Right, I understand and am appreciating the point.
14:28:34 <scope> monochrom, the parsePoint function is going to be receiving strings that look like (5,8). I've been googling and unable to find a good way to convert that to a tuple of type (float,float). Do you have a suggestion? I'm very new to haskell
14:29:13 <monochrom> If the format is just that, "read" works out of the box. Example:
14:29:26 <monochrom> > read "(5,8)" :: (Float, Float)
14:29:28 <lambdabot>  (5.0,8.0)
14:29:31 <scope> oh wow
14:29:38 <scope> that's a lot simpler than I expected
14:30:00 <monochrom> Be sure to use types to get the right behaviour. But you already have the necessary type signatures.
14:30:14 <scope> that worked beautifully
14:30:24 <monochrom> Other formats will require more coding, yeah, we're lucky.
14:30:51 <scope> what's an example that would require more coding?
14:31:02 <scope> I guess, what wouldn't work like that
14:31:09 <freeside> "5 8 11 bogus 24.2"
14:31:17 <monochrom> Say, if they prefer semicolon to comma.
14:31:25 <scope> ah alright
14:32:19 <freeside> .oO (you could always pre-treat your input data in perl)
14:32:30 <scope> another quick question, when I try to load ghci in CMD it takes up to a minute to load
14:32:35 <scope> it used to be almost instant
14:32:59 <freeside> in the spirit of perl one-liners, here: fmap ((,) <$> head <*> last) <$> chunksOf 2 $ catMaybes $ (readMaybe :: String -> Maybe Float) <$> words "5 8 11 bogus 24.2"
14:33:07 <monochrom> If you quit ghci now and run it again, does it take a minute again?
14:33:16 <scope> yes, every time I try to run ghci
14:35:24 <scope> basically it sits on "GHCi, version xxxx -------------------" for about a minute before getting into prelude
14:44:40 <lyxia> scope: what's in your .ghci
14:44:56 <scope> where is that located?
14:45:54 <lyxia> Maybe in your home folder
14:46:09 <MarcelineVQ> most often ~/.ghc/ghci.conf
14:46:29 <scope> I'm on Windows
14:46:46 <scope> I found a ghci_history file under appdata
14:46:51 <scope> but there's nothing else
14:48:08 <lyxia> It might not be the cause anyway. I don't know where else the slowness could be coming from. :/
14:48:43 <monochrom> Yeah, this is a little bit weird.
14:48:49 <tobiasBora> monochrom: Ok thank you!
14:49:21 <scope> it's honestly not that big of a deal it's just an annoyance
14:49:31 <tobiasBora> By the way, I'd like to program a concurrent program, what is the difference between Control.Concurrent.ParallelIO and Control.Parallel.Strategies?
14:50:01 <freeside> how large is the ghci_history file?
14:50:09 <scope> 2kb
14:50:11 <scope> probably not the cause
14:50:17 <freeside> probably not
14:50:39 <Phyx-> scope: which version?
14:50:56 <monochrom> 2kb here too.
14:50:56 <scope> monochrom, that parsePoint function will load, but it fails on the last element of the list with the error Exception: Prelude.read: no parse
14:51:14 <monochrom> What does the string look like?
14:51:14 <scope> and phyx- it's version 8.0.2
14:51:34 <scope> "(5,5) (5,5) (5,5) (5,5)"
14:51:44 <scope> it fails before it prints the last one
14:52:00 <monochrom> > map read (words "(5,5) (5,5) (5,5) (5,5)") :: [(Float, Float)]
14:52:02 <lambdabot>  [(5.0,5.0),(5.0,5.0),(5.0,5.0),(5.0,5.0)]
14:52:05 <monochrom> should work
14:52:10 <Phyx-> scope: so is it only startup that is slow or also when you import a new module?
14:52:17 <scope> just the startup
14:52:51 <freeside> can you paste the entire ghci start sequence somewhere?
14:53:12 <Phyx-> hmm, then it's something else. I thought the loading of base would be taking a long time, but we relink and load everything when you import a module
14:53:14 <lyxia> tobiasBora: strategies offer parallelism for pure computations
14:53:19 <scope> not much to post, it's just the GHCi "versionnum" and the help message
14:53:23 <scope> then it goes into prelude
14:53:48 <scope> monochrom same error
14:54:10 <scope> I'll paste the code again
14:54:27 <tobiasBora> lyxia: Ok thank you!
14:54:32 <Phyx-> unfortunately, the only way to tell for sure what's going on is with a debug build of GHC...
14:54:44 <scope> monochrom http://lpaste.net/2651339077676171264
14:54:48 <lyxia> tobiasBora: Concurrence is not parallelism by the way.
14:54:50 <tobiasBora> There is not problem if the threads write in the same file?
14:55:51 <monochrom> scope, I will also need some string that exhibits the error.
14:56:11 <scope> "(5,5) (5,5) (5,5)"
14:56:18 <scope> anything I pass to it with that format monochrom
14:56:46 <scope> prints everything up to the last element and then fails with no parse
14:57:02 <lyxia> tobiasBora: you will need to synchronize your threads
14:57:22 <tobiasBora> lyxia: Hum... How do you do that?
14:57:33 <tobiasBora> I need to manually use semaphore...
14:57:41 <freeside> working hypothesis: a state-sponsored actor has hacked into your computer and is messing with your mind via ghci
14:59:08 <lyxia> tobiasBora: concurrent-extra has basic stuff
14:59:21 <scope> monochrom, interestingly it works with two elements
14:59:52 <lyxia> tobiasBora: stm has primitives for more custom concurrent abstractions
14:59:54 <scope> monochrom try different numbers, (5,5) (5,5) (5,5) actually works just fine
15:00:13 <scope> AHHHH I'm an idiot
15:00:22 <scope> I had a space in my string monochrom
15:00:29 <ski> > (`runStateT` "(5,5) (5,5) (5,5)") (replicateM 3 (StateT (reads :: ReadS (Float,Float))))
15:00:32 <lambdabot>  [([(5.0,5.0),(5.0,5.0),(5.0,5.0)],"")]
15:00:48 <freeside> when monocrom asks you for an actual string that exhibits the error, you need to give the actual string that exhibits the error.
15:00:53 <tobiasBora> lyxia: Hum, I'll try to give it a look...
15:01:05 <scope> freeside fair enough, I just absolutely missed the space
15:01:10 <scope> figured it was something else
15:02:22 <freeside> maybe you want Data.Text.strip
15:02:36 <scope> lol it was just user error
15:02:41 <freeside> :)
15:03:18 <lyxia> tobiasBora: also look at the Control.Concurrent* modules in base.
15:05:37 <monochrom> scope: If you want to be flexible about spacing, my http://www.vex.net/~trebla/haskell/reads.xhtml may give you some ideas. The gist is you now process the whole string, do not split-by-space first.
15:05:55 <scope> awesome, thanks for the link mono
15:08:20 <ski> scope : note that instead of `reads "..." :: [(X,String)]', one can say `(reads :: ReadS X) "..."'
15:08:39 <scope> ski awesome, was not aware of that
15:09:24 <scope> I'm a big fan of this channel, you guys are great. I'm learning haskell slowly but surely.
15:12:10 <ski> > let s0 = "  12 34  \t  " in [(x,y) | (x,s1) <- (reads :: ReadS Integer) s0,(y,s2) <- (reads :: ReadS Double) s1,("","") <- lex s2]  -- this use of `lex' ensures there's nothing but white space at the end
15:12:12 <lambdabot>  [(12,34.0)]
15:16:58 <ski> > let s0 = "(12;34)\n" in [(x,y) | ((x,y),s5) <- (readParen True `flip` s0) $ \s1 -> [((x,y),s4) | (x,s2) <- (reads :: ReadS Integer) s1,(";",s3) <- lex s2,(y,s4) <- (reads :: ReadS Double) s3],("","") <- lex s5] -- `lex' can also be used to scoop up tokens like `;' here. `readParen' can be used to handle the brackets
15:17:00 <lambdabot>  [(12,34.0)]
15:17:14 <ski> scope ^
15:27:31 <Unode> If I wanted to create a client-server, both written in Haskell and didn't want to care too much about the protocol between the two but just that I'm able to deliver full-duplex communication, what haskell libraries should I look into?
15:30:52 <monochrom> The Network module, comes with GHC.
15:31:27 <geekosaur> actually it doesn't
15:32:16 <geekosaur> (and ghc devs get grumpy if you suggest including it, since you'd presumably have some reason for ghc itself to use it... someone actually asked that the other day :)
15:32:35 <monochrom> Oh, oops, it doesn't come with GHC. The library package name is "network".
15:33:16 <Unode> monochrom: checking
15:33:18 <monochrom> Yes I have recently found a new reason for GHC to include it (and http and ssl).
15:33:21 <ezyang> we are all GRUMPBALLS 
15:33:37 <monochrom> It is to support "ghc -O http://www.vex.net/~trebla/whee.hs"
15:34:29 <Cale> Nice, and then whee.hs can include some IO-performing Template Haskell :)
15:35:41 <Unode> monochrom: uhm I was hoping for something a little bit higher level.
15:35:55 <monochrom> I think Network is already pretty high level.
15:36:15 <Unode> monochrom: not according to its description. Unless we are talking about different things.
15:36:27 <Unode> "Low-level networking interface"
15:37:34 <monochrom> I guess they encourage you to use Network.Socket, which is lower level.
15:38:07 <Cale> Unode: listenOn / accept / connectTo are a somewhat higher level interface
15:38:23 <okeuday_bak> programs are more perfect without I/O, a good reason to not include network
15:38:46 <geekosaur> yes, the higher level interface is a bit warty and needs redesign, so it's not currently recommended
15:38:49 <monochrom> I don't know a library that is higher level and "this is serious, this is not just for backward compatibility!"
15:38:52 <Unode> What I had in mind was something that I would initialize (create connection) and then could simply send messages (JSON or some other chunk-like block of info) back and forth.
15:38:59 <Cale> Well, wait, what's actually wrong with those three?
15:39:00 <geekosaur> but there's not a lot else unless you want to use conduit or pipes
15:39:17 <Unode> okeuday_bak: hehe funny remark.
15:39:24 <Cale> There's the sendTo/recvFrom functions which probably should go away
15:39:30 <monochrom> I mean, unless you also want to dabble with pipes or conduit.
15:39:49 <geekosaur> the funniest part os it has those, which are mainly useful with UDP... but Network doesn't support UDP
15:39:49 <Unode> conduit, checking...
15:40:06 <okeuday_bak> using sockets as handles works
15:40:10 <geekosaur> (Network.Socket does, just not the higher level interface)
15:40:12 <Cale> Unode: conduit isn't a network specific thing, it's a general I/O streaming abstraction
15:41:03 <okeuday_bak> but using sockets as handles still requires the network dependency to make the handles
15:41:05 <Unode> Cale: if that is in any way closer to what I just described, that works for me.
15:41:16 <Cale> I mean, the only thing you're going to need a lot of the time is just the first 4 functions there: withSocketsDo (just a silly Windows portability requirement), listenOn, accept, and sClose
15:41:26 <Cale> oh, and connectTo, so I guess that's 5
15:41:59 <geekosaur> it's not even needed on Windows any more, it's a backward compatibility shim for if you need to support older versions of ghc/network for some reason
15:42:02 <Cale> and then that'll get you a Handle and you can go use the stuff in Data.ByteString or Data.Text.IO or whatever
15:43:35 <Cale> and of course, you probably want Control.Concurrent, but that's a separate thing
15:43:44 <scope> ski thanks! I just saw your message. Sorry went to grab food
15:44:30 <Unode> Cale: trying to check that
15:45:53 <Unode> was hoping for a more consensual answer. At this point I just want to sort of get the network part working so I can focus on the other 'more fun' aspects.
15:46:08 <monochrom> Yikes, I keep mistyping Handle to Handel
15:46:46 <mauke> Händel!
15:47:05 <Cale> Unode: I don't know what other capabilities you might need, without a better description of the program you're trying to write, but that'll get you a server or client going pretty easily.
15:49:44 <Unode> Cale: the closest I can think of is a simple chat-like or bot-like interface with a dual client <-> server component.
15:50:40 <Unode> monochrom: You should see how Handel Handles Handles.
15:52:10 <Cale> Yeah, then those functions from Network should be just fine. You might also want some serialisation library.
15:52:44 <Cale> Something like Binary
15:53:00 <Cale> https://hackage.haskell.org/package/binary
15:53:13 <Unode> I was thinking JSON would be more than enough.
15:53:37 <Cale> Ah, then Aeson
15:56:54 <Unode> ok I go away now and play with this. Thanks for all the feedback.
15:58:09 <Cale> We've been using Aeson for serialising and deserialising JSON in both the frontend and backend of our web applications where I work. It's *okay* for that, but there are some gotchas which stem from the fact that it was originally designed for dealing with handcrafted JSON, rather than as a library where any format will do so long as you get back exactly what you put in.
15:58:53 <Cale> (the latter being representative of how we actually use it -- all our ToJSON and FromJSON instances are written automatically by a bunch of Template Haskell)
15:59:26 <tikhon> What are the preferred packages for logging?
16:01:20 <Cale> I've never actually tried using a package for that, but https://hackage.haskell.org/package/fast-logger came up the other day, and it looks mildly helpful
16:01:32 <tikhon> That's one of the ones I was wondering about.
16:01:46 <Cale> In particular, I don't believe very much in the various ones which give you a monad transformer.
16:02:04 <tikhon> You think it's better to just log from IO?
16:02:07 <Cale> yeah
16:02:40 <tikhon> I wasn't sure, but I'm happy to lean in that direction. Our codebase still has almost no monad transformers running around :).
16:03:09 <Cale> Or, well, usually in a larger application, you're going to have some record of configuration you're passing around already -- stick a function in there which gives you an action that writes to the log.
16:04:39 <tikhon> What do you think of monad transformers in general? I see a lot of people relying on them for organizing larger projects, but I've never felt the need myself.
16:05:17 <tikhon> Working with monad transformers seems a bit awkward in practice.
16:05:33 <Cale> They're all right if you have a solid vision for what kind of API you want to build. Leaving monad transformers exposed is ugly.
16:06:17 <Cale> and I don't care much for the MonadReader/MonadState type classes at all -- you always want something more particular than that, which will depend on your application
16:06:42 <Cale> I mean, you should define a type class in that vein yourself, but with operations more meaningful than 'get' and 'put'
16:06:52 <tikhon> yeah, that makes sense
16:07:15 <tikhon> and it helps with the issue of overlapping Reader/States
16:07:21 <Cale> MonadState over something like [] is rather cool
16:07:53 <Cale> You can implement a simple parsing library really quickly
16:08:01 <tikhon> I like the mtl style, but it seems easy to mess up type inference
16:08:13 <Cale> MonadReader constraints are really bad
16:08:49 <tikhon> yeah, I could see that
16:08:59 <tikhon> but Reader in general is another thing I almost never reach for
16:09:13 <Cale> They ruin your type errors
16:09:46 <tikhon> the project I'm working on now has a custom Random type that's isomorphic to a Reader monad of some sort
16:10:00 <tikhon> but having a distinct type for it seems much nicer in practice
16:10:35 <Cale> Yeah, it's just that sometimes the type you're defining will be a newtype of something which works out to a combination of some monad transformers, and it'll save you a bit of trouble writing instances.
16:11:10 <tikhon> yeah, that's definitely fair
16:11:25 <Cale> But you generally *should* newtype it
16:11:40 <Cale> and hide the fact that you're using monad transformers from outside the given module
16:11:47 <tikhon> and I guess having mtl-style constraints for it could help make code more polymorphic
16:12:29 <Cale> *Sometimes* that polymorphism actually turns out to be useful, and sometimes it just makes your type signatures annoying to write. :)
16:12:42 <tikhon> yeah
16:12:50 <tikhon> and, again, it's too easy to mess up type inference
16:13:05 <Wizek_> @djinn Monad m => [(m Bool, a)] -> m a
16:13:05 <lambdabot> Error: Undefined type []
16:13:06 <Cale> Well, MonadReader in particular screws it up, because (->) e is an instance
16:13:17 <tikhon> right
16:13:37 <Cale> and GHC deals with it rather poorly for some reason
16:13:57 <tikhon> Is (->) something of a special case for inference?
16:13:58 <Cale> An extra or missing argument in a large definition somewhere will turn into an error regarding the entire function definition
16:14:11 <tikhon> it's definitely a special case for error messages
16:14:18 <Cale> (it'll point you at the first line of the definition, rather than at the place where the error actually is)
16:14:40 <Cale> Well, it's not really special
16:14:51 <Cale> Apart from the fact that function application has special syntax
16:16:46 <Cale> But yeah, I had to go through one of our projects and remove all the MonadReader constraints for the application environment due to that, and I haven't regretted it at all. The constraints are easier to write, the type errors are no longer awful, and there are several methods for directly extracting bits of the configuration..
16:17:52 <tikhon> Luckily our codebase has escaped that so far, but some other bits have pretty hairy types.
16:18:18 <tikhon> Back to logging: has anyone here used hslogger recently? It looks like it was the most common logging library a few years ago, but it was last updated in 2016.
16:18:22 <Sonolin> to clarify Cale so to solve this, you just cahnged the MonadReader m => constraint to a specific type?
16:18:46 <Cale> yes, just built my own type class for the operations which ask for various bits of the environment
16:19:34 <Sonolin> cool, just wondering since I'm currently in the process of hiding 
16:19:53 <Sonolin> monad transformers in my app, and had begun to convert things to the polymorphic MonadReader constraint
16:20:01 <Sonolin> but useful error messages seem infinitely more important
16:20:35 <Cale> Also worth noting that I would basically never use ReaderT over IO on its own
16:21:34 <Cale> Unless I was in the process of constructing a monad that wasn't going to support all IO, or which at least had some decent *meaning*. It's not worth what you give up if you could just be passing a parameter around instead.
16:22:41 <Cale> But once you already have some monad which isn't IO, you have less to lose in the way of higher order primitives like forkIO and bracket and catch
16:25:25 <Cale> (nevermind that it's rarely actually a syntactic convenience relative to parameter passing, once you account for all the uses of liftIO)
16:25:38 <Sornaensis> :t liftIO
16:25:40 <lambdabot> MonadIO m => IO a -> m a
16:25:59 <Sornaensis> :t forkIO
16:26:01 <lambdabot> error: Variable not in scope: forkIO
16:26:10 <Cale> :t Control.Concurrent.forkIO
16:26:11 <lambdabot> IO () -> IO GHC.Conc.Sync.ThreadId
16:27:15 <Cale> ^^ things like this which take IO actions as parameters are annoying to use once you pass to working with some transformed monad
16:27:49 <tikhon> euh, do you end up having to run your whole stack to make it work?
16:29:01 <Cale> Well, you may be able to obtain all the pieces of state and whatnot that are required to re-run the same monad transformers on the action you're passing as an argument. But that might not even make sense.
16:29:51 <Cale> If it's MonadState for example, with forkIO, all the changes to state which happen on the second thread are going to be lost relative to the original thread. That might not be what you want.
16:29:58 <tikhon> right
16:30:16 <Cale> There are similar, but subtler problems with catching exceptions.
16:30:26 <tikhon> and, to be fair, that's the sort of thing you *should* consider explicitly—relying on default behavior for things like that leads to bugs pretty quickly
16:32:04 <Cale> There are some libraries like MonadBaseControl which can help with doing this in a standard way, but they're not magic, and won't help you if the thing you're asking for doesn't quite make sense, even if they force the types to line up.
16:34:04 <Conjecture> Does Haskell throw errors when you exceed what is representable by a fixed bit integer?
16:34:25 <Cale> Generally no.
16:34:35 <Conjecture> Is there a way to make it trigger?
16:34:46 <Cale> Int will be something of fixed size, but operations are modulo 2^n for some n
16:34:46 <pikajude> no
16:34:55 <Cale> Integer is arbitrary precision
16:35:02 <pikajude> you can't throw an error on overflow
16:35:12 <Cale> You could make your own type which did
16:35:13 <pikajude> unless you make a newtype wrapper and implement Num yourself
16:35:17 <Cale> yeah
16:35:20 <pikajude> which checks for overflow on every operation
16:35:21 <Conjecture> Thanks
16:35:25 <Cale> That may exist somewhere
16:35:25 <monochrom> I believe that exceeding Integer capacity will only manifest as out-of-memory. :)
16:36:03 <Cale> Usually it's not so bad just to use Integer if you're at all worried about overflow.
16:36:41 <Conjecture> Thanks
16:37:28 <Cale> (Or even if you're not, and you're just not terribly worried about finer performance details, or densely packing the things into unboxed arrays)
16:38:02 <Conjecture> Maybe I should use Google's coding practice on the subject
16:38:28 <Conjecture> Use signed when using fixed bit, that way rolls overs come out to very large negative numbers making any error obvious
16:39:00 <Conjecture> Thanks for the help on the subject
16:40:25 <dmwit> :t finiteBitSize
16:40:27 <lambdabot> FiniteBits b => b -> Int
16:40:53 <Conjecture> Thanks
16:41:20 <dmwit> ?let ensure p x = x <$ guard (p x)
16:41:22 <lambdabot>  Defined.
16:42:11 <dmwit> :t \op x y -> liftA2 op x y >>= ensure (\v -> v <= bit (finiteBitSize v `div` 2))
16:42:13 <lambdabot> (FiniteBits b, Ord b, Alternative m, Monad m) => (a -> b1 -> b) -> m a -> m b1 -> m b
16:42:57 <dmwit> ?let checkedOp op x y = liftA2 op x y >>= ensure (\v -> v <= bit (finiteBitSize v `div` 2))
16:42:58 <lambdabot>  Defined.
16:43:58 <nilof> Huh, apparently Haskell was twelve years old when Cobol got user-defined functions
16:43:59 <dmwit> Oh, I got that backwards, didn't I?
16:44:16 <dmwit> Ah well. Kind of a stupid hack anyway.
16:44:21 <dmwit> ?undefine
16:44:21 <lambdabot> Undefined.
17:08:36 <Engen> hey guys. I'm currently trying to understand a function given to me (yes it is hw) but I'm having difficulty in doing do, function found here: http://lpaste.net/353869
17:09:14 <Engen> the task is to check different properties of sorting functions using quickcheck and given properties of which the pasted code is one
17:10:04 <pacak> It checks that arbitrary element is still present in a given list after sorting
17:10:10 <c_wraith> Engen, that property checks that if an element is inserted between two list segments, and them the whole thing is sorted, that the element is still there. 
17:10:10 <Engen> so far my understanding is; sortProp2 takes a function, an Int, and two lists of Int and returns a Bool 
17:10:32 <pacak> Engen: Yep
17:11:50 <Engen> I understood that it was checking if x was still in the list but what is going on the rhs of the `elem` is what is confusing me 
17:12:06 <pacak> :t elem
17:12:07 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
17:12:22 <pacak> elem takes an element and a foldable, in this case - a list
17:12:27 <c_wraith> ah. backticks turn a prefix function into an operator. 
17:12:47 <pacak> > 10 `mod` 2
17:12:49 <lambdabot>  0
17:12:51 <pacak> > mod 10 2
17:12:52 <c_wraith> so elem x xs is the same as x `elem` xs
17:12:53 <lambdabot>  0
17:13:27 <pacak> You can go the other way as well
17:13:31 <pacak> > (+) 100 500
17:13:33 <lambdabot>  600
17:13:37 <pacak> > 100 + 500
17:13:39 <lambdabot>  600
17:13:41 <Engen> it concatenates xs to [x] to ys and sorts that data but whether the elem check or the sort happens first is not clear 
17:14:07 <c_wraith> infix operators are always lower priority than function application 
17:14:08 <pacak> sorts first
17:14:28 <Engen> sortProp2 sortFn x xs ys = x `elem` (sortFn (xs ++ [x] ++ ys))     is that... yeah ok gotcha 
17:16:06 <c_wraith> that's one of the primary reasons why people use functions as infix operators... it often lets them drop a set of parens. 
17:17:20 <Engen> I see 
17:17:53 <Rotaerk> it also sometimes reads more like english that way
17:17:58 <Rotaerk> "x is an element of ..."
17:19:53 <tikhon> I've found people are pretty consistent with it: if a function makes sense as infix (elem, mod... etc), they write it as infix most of the time
17:19:58 <c_wraith> I don't really like typing ` very much, and so I use backticks on essentially only 4 functions. elem, div, mod, and rem.
17:20:21 <tikhon> it is an annoying character on a lot of keyboard layouts
17:20:22 <c_wraith> (somehow, quot didn't make the list) 
17:20:43 <tikhon> and it's the default Emacs key for cycling through error >.<
17:20:55 <tikhon> I've typed C-x ` way too many times, but I'm too lazy to rebind it
17:21:45 <c_wraith> Oh, I do use it for divMod and quotRem in the cases I use those. so... maybe 7 functions. not many, really. :) 
17:22:49 <tikhon> I also use it to avoid using 'flip'
17:23:00 <tikhon> but I don't really know if that's a net gain or not :P
17:23:20 <Rotaerk> I don't like it most of the time because I tend to name my functions such that it grammatically makes sense in english to describe the first argument
17:23:36 * ski . o O (  foo `flip` bar  )
17:24:11 <tikhon> looking through our codebase at work, we use `min` and `max` a lot
17:24:15 <Rotaerk> isElement :: a -> [a] -> Bool   versus  isElementOf :: [a] -> a -> Bool
17:24:38 <Rotaerk> and if you used infix for the latter, it'd be ... myDict `isElementOf` 5
17:24:42 <Rotaerk> which looks wrong
17:25:30 * ski . o O (  `isElementOf :: a -> Bool <- [a]' )
17:25:31 <Rotaerk> s/myDict/myList/
17:26:22 <tikhon> my favorite example is a function I called "can" for determining whether a store has a particular capability
17:26:31 <tikhon> store `can` Fulfill
17:26:40 <tikhon> and then you can have a `can't` too :)
17:27:05 <tikhon> it actually reads really nicely in guards
17:28:52 <Rotaerk> I would prefer to make the capability the first argument of can, and if you want to make it englishy do:  store & can Fulfill
17:29:37 <Rotaerk> simply because I don't think functions should be designed *around* the infix notation, since they won't necessarily be used that way
17:29:51 <tikhon> hmm, not a bad idea
17:30:11 <tikhon> besides, looking through some of the examples in our code, we should have just defined operators for a few of them
17:30:20 <MarcelineVQ> > 2`subtract`8
17:30:23 <lambdabot>  6
17:30:30 <Rotaerk> infix notation, though, I think is fine for things where the order of arguments just doesn't matter
17:31:02 <Rotaerk> yea the order of args for subtract make sense to me
17:31:27 <MarcelineVQ> it does to me in prefix, subtract 2 from 8  infix is odd to me still
17:32:27 <Rotaerk> crap... drawing a blank ... a op b == b op a
17:32:29 <Rotaerk> that's called what?
17:32:31 <MarcelineVQ> and that it matters at all is just that I tend to use it infix becasue of the oddities of -
17:32:34 <tikhon> commutative
17:32:37 <Rotaerk> right
17:32:51 <Rotaerk> I think infix notation for functions is fine if they're commutative
17:33:05 <Rotaerk> otherwise you have to design the function *for* the notation, and then it looks wrong when you don't use it
17:33:16 <tikhon> I don't think that's always true
17:33:31 <tikhon> a lot of our code uses `zip` as infix, but it actually reads fine either way
17:33:56 <Rotaerk> hmm I guess commutative isn't the right property then...
17:34:16 <Rotaerk> though, zip is tricky in that case
17:34:27 <Rotaerk> a `zip` b  versus  zip a b
17:35:08 <Rotaerk> versus b & zip a
17:35:27 <Rotaerk> eh, I guess you're right
17:37:27 <monochrom> Infix is great for associative functions such as (+) and (*).
17:38:43 <monochrom> There are also non-associative cases where infix is still great for chaining up participants, such as 1:2:[] and f <$> getLine <*> hGetLine h
17:41:52 <monochrom> > False == True == False
17:41:54 <lambdabot>  error:
17:41:54 <lambdabot>      Precedence parsing error
17:41:54 <lambdabot>          cannot mix ‘==’ [infix 4] and ‘==’ [infix 4] in the same infix expre...
17:42:04 <monochrom> Oh heh. But it is associative too.
17:42:37 <ezyang> I'm QuickChecking a function that might raise an exception, but I want the case to pass in this case 
17:43:21 <ezyang> is there a way to do this? 
17:44:00 <ph88> ezyang, you can use monadicIO with qc
17:44:12 <ph88> and the Control Exception try
17:44:52 <monochrom> Ah! Yeah, "try" will convert exception to Either, now you have a cool value to check against.
17:45:26 <Jello_Raptor> is there a good viewer for .prof files? 
17:45:30 <ezyang> So, how do I say, "OK, skip this case" in that case? 
17:45:43 <ezyang> I guess I could do False ==> 
17:45:56 <ph88> ezyang, qc does not skip afaik, only pass or fail
17:46:18 <ph88> but maybe when you use MonadicIO you can do some logging on the side
17:46:42 <monochrom> I don't know QuickCheck, but your property is informally "try myaction should return Left MyException"
17:46:59 <ph88> but actually with other testing frameworks you can only decide to skip before you perform the test, when it's performing it can only pass or fail
17:47:28 <MarcelineVQ> Jello_Raptor: https://hackage.haskell.org/package/profiteur possibly, I've not used it
17:48:11 <ph88> ezyang, https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Monadic.html   https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Exception.html#v:try
17:48:18 <Jello_Raptor> MarcelineVQ: ahh, that's the one I'm installing now, we'll see how well it works :P
17:50:56 <tikhon> Is there an elegant way to write your own function in terms of printf?
17:51:23 <tikhon> I want to have something like "errorf", but it looks like I'd have to define my own class for it or something.
17:52:01 <MarcelineVQ> :t ioProperty
17:52:03 <lambdabot> Test.QuickCheck.Property.Testable prop => IO prop -> Test.QuickCheck.Property.Property
17:53:19 <lyxia> tikhon: you mean having   errorf fmt x y z = error (printf fmt x y z)  ?
17:54:26 <monochrom> You can reuse printf's classes.
17:54:27 <tikhon> yes, esactly
17:54:39 <tikhon> exactly**
17:54:49 <monochrom> In fact, s/reuse/use/, you can black-box-use them.
17:55:01 <tikhon> monochrom: I was hoping for that, but I couldn't immediately figure out how to do that.
17:55:46 <monochrom> OK, I need to pull of printf's doc. What's the package name again?
17:55:54 <monochrom> s/pull of/pull up/
17:56:01 <lyxia> base
17:56:06 <lyxia> https://hackage.haskell.org/package/base-4.9.1.0/docs/Text-Printf.html
17:59:38 <monochrom> Ah, I can't pull it off.
18:00:56 <erisco> almost quotable but I don't think enough people are British
18:16:21 <tikhon> I wonder what a printf could look like in the eventual dependent Haskell future
18:18:37 <lyxia> You can already do a type safe printf with GADTs + QuasiQuotes.
18:19:53 <tikhon> Hmm, I imagine that would still be awkward to work with.
18:20:05 <tikhon> If you want to do the errorf thing I mentioned, for example.
18:22:51 <lyxia> errorf [fmt|%d%s%f|] x y z   ?
18:23:11 <erisco> I have a fun problem
18:23:30 <lyxia> tikhon: do you consider that ^ awkward
18:24:18 <erisco> I have a set of sets S and a set of n-tuples T
18:25:08 <tikhon> lyxia: I meant defining errorf in terms of the underlying printf provided by the library would be awkward
18:25:32 <lyxia> ok nevermind me.
18:25:36 <Rotaerk> erisco, that DOES sound like a problem!
18:25:42 <tikhon> but otherwise it's fine
18:25:51 <erisco> I want to find the largest set S' = x1*x2*...xn where x1,..,xn ∈ S  such that S' ⊆ T
18:26:21 <tikhon> it is an improvement over the normal printf
18:26:27 <Jello_Raptor> huh, I wrote a program that is using 2000% of cpu power on our compute box (with many cores) :/ i'm sure I didn't actually tell it to parrelelize anything, where's all that multicore use coming from? 
18:26:59 <tikhon> I think we'd be able to have our cake and eat it to with dependent types—but maybe it would make the types involved to verbose to use.
18:27:06 <dolio> Jello_Raptor: Garbage collection?
18:27:44 <erisco> my core are spiking to! are you using a stop-the-world collector?
18:27:46 <Jello_Raptor> dolio: but that many cores? i thought it generally topped out at 2?
18:29:09 <dolio> I don't see why it would parallelize, but only use two cores.
18:29:20 <Jello_Raptor> the GC? 
18:29:23 <dolio> Unless you told it to.
18:29:27 <erisco> so I can think of a quadratic algorithm that finds all the n-tuples of sets from T
18:29:41 <erisco> then it selects just those where the sets are from S
18:29:45 <erisco> then it selects just the largest
18:30:05 <Jello_Raptor> ahh I'm used to GC from other languages that aren't as parallelized 
18:30:36 <erisco> it always runs in quadratic time
18:32:50 <erisco> the purpose of this problem is to find a small representation of as many of the elements of T as possible
18:33:21 <erisco> so it is a lossy simplification
18:33:42 <erisco> but in context, any element from T will do, I just want to represent as many as I can, so it isn't actually lossy
18:54:47 <_sras_> Is there anyway to make a forked thread run in a custom monad?
18:56:06 <Koterpillar> _sras_: not a general one - how would you handle, for example, StateT?
18:58:46 <_sras_> Koterpillar: Because that would let the thread modify state in the parent?
18:59:18 <pacak> :t forkIO
18:59:19 <lambdabot> error: Variable not in scope: forkIO
18:59:22 <pacak> Hmm...
18:59:52 <pacak> forkIO :: IO () -> IO ThreadId
19:00:20 <pacak> forkIO will spawn a separate thread - in IO monad it will be able to do stuff
19:00:27 <pacak> Side effects - launch rockets and so on.
19:00:44 <pacak> For state monad... Suppose it will modify some state. What's next?
19:01:50 <Koterpillar> _sras_: because the effects will need to be linearized somehow
19:02:20 <pacak> :t par
19:02:21 <lambdabot> error:
19:02:21 <lambdabot>     • Variable not in scope: par
19:02:21 <lambdabot>     • Perhaps you meant one of these:
19:02:37 <pacak> lambdabot:  Y U SO LAZY?
19:03:07 <_sras_> pacak: Access the changed state down the line...I guess..
19:03:31 <_sras_> Koterpillar: linearized mean? made in order?
19:03:37 <pacak> _sras_: How about Maybe monad?
19:05:17 <Koterpillar> _sras_: let's imagine you've somehow done forkIO $ modify (+ 1)
19:05:23 <_sras_> pacak: You cannot return the main thread until the forked thread is done...right?
19:05:31 <Koterpillar> _sras_: will the main thread ever see this effect?
19:06:00 <pacak> _sras_: Riiiiight. So why do we want to fork it in this case?
19:06:02 <_sras_> pacak: because it need to know if the forked maybe is a Just or Nothing...
19:06:35 <pacak> And if we are talking about arbitrary monads - they can do lots of strange stuff
19:06:37 <Koterpillar> if you can provide YourMonad () -> IO (), then do that
19:07:30 <_sras_> Koterpillar: But I do not want the main thread to see the effect. I want the state to be passed on to the new thread, and the new changes remain local....
19:08:06 <Koterpillar> then make the function above
19:08:13 <pacak> get state, forkIO, run state monad inside IO monad
19:08:17 <Koterpillar> ^
19:09:03 <pacak> Or look into parallel evaluation strategies
19:09:41 <Quarsi> How can I quote an associated data family for template haskell? I.E,   deriveJson ''(X Foo)     where I have   instance User Foo where; data X Foo = ...
19:10:44 <_sras_> pacak: Koterpillar Basically, What I want to do is this. I have a monad stack with a readerT and a loggingT. And I want to send emails from forked threads and want to catch exceptions and log using the LoggingT..
19:11:19 <Koterpillar> where does the logging go?
19:11:29 <_sras_> Koterpillar: to a file.
19:11:49 <pacak> _sras_: That's not arbitrary monad but something specific. You can pass config into forked monad. for loggingT - implement something similar.
19:12:08 <pacak> Btw, you might not want to write to a file from forked threads
19:12:22 <_sras_> Koterpillar: I can pass the FastLogger in the reader and make the thread use it to write to the log...
19:13:11 <_sras_> pacak: Yes. That can be done....
19:14:01 <_sras_> pacak: Koterpillar btw, I found this https://hackage.haskell.org/package/forkable-monad 
19:14:18 <_sras_> Not sure about using it though...
19:14:33 <pacak> uploaded 2010, downloads - 566
19:14:38 <erisco> I am thinking of a function (a -> [a] -> b) -> [a] -> [b] which maps each element together with every other element to a new list
19:14:51 <pacak> Userbase of 0, 1 download a month?
19:15:54 <_sras_> pacak: Koterpillar but it does require implementing a ForkableMonad instance...
19:22:04 <defanor> what are the recommended libraries to read and modify xml? i'm looking for something simple, maintained, lightweight; not necessarily usable for large files. there's plenty of libraries, hard to pick
19:23:00 <erisco> ah I think I am interested in list zippers
19:23:39 <erisco> ([a] -> a -> [a] -> b) -> [a] -> [b]
19:24:06 <erisco> or you could make that more like a fold than a map as well
19:24:33 <pacak> every element together with every other element?
19:24:40 <pacak> sounds comonadish
19:24:54 <erisco> it is the same as a zipper I realise
19:25:08 <erisco> it is the same as just mapping the zippers
19:25:19 <erisco> no experience with comonads
19:26:28 <pacak> :t extract
19:26:29 <lambdabot> error: Variable not in scope: extract
19:26:35 <pacak> lambdabot:  :-P
19:26:47 <erisco> so I can start with  [a] -> [([a], a, [a])]
19:26:52 <pacak> extract :: w a -> a
19:27:26 <pacak> list zipper is comonad
19:27:32 <erisco> that is not implementable for list, so how does a comonad apply here?
19:28:06 <pacak> http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
19:28:38 <edwardk> in that same vein there are these: https://www.schoolofhaskell.com/user/edwardk/cellular-automata
19:29:11 <erisco> thanks I'll bookmark those
19:29:21 <erisco> can just rattle off these functions for now though
19:29:52 <edwardk> Sadly the run button doesn't exist on the school of haskell any more =( it was nice when you could just click on the examples and get images
19:30:04 <pacak> erisco: I also have a huge list of bookmarks that I should  read at some point but never do for some reason.
19:30:39 <edwardk> erisco: re it not being implemented for lists you can think of the thing you have there as being take [] -> []   take (a:as) -> and start with a list zipper at that starting point, and run down the list.
19:31:01 <edwardk> so in the case where you actually _use_ the zipper you know you have a non-empty list... which is also a comonad.
19:31:36 <erisco> what is take?
19:32:17 <edwardk> i was using it a conversational term. the function takes that input and gives that output
19:32:54 <edwardk> so assuming you have a comonad   data Zipper a = Zipper [a] a [a]
19:33:01 <erisco> I don't follow but I'll read on comonads at some point
19:33:29 <erisco> Zipper might be a Comonad, sure, it at least gets past extract
19:33:43 <edwardk> blah _ [] = []; blah f (a:as) = case extend f (Zipper [] a as) of Zipper _ b bs -> b:bs
19:33:50 <erisco> :t extend
19:33:51 <lambdabot> error: Variable not in scope: extend
19:33:56 <edwardk> :t Control.Comonad.extend
19:33:58 <lambdabot> Control.Comonad.Comonad w => (w a -> b) -> w a -> w b
19:34:02 <pacak> If you are doing something comonadish using them cam save you some coding.
19:34:23 <edwardk> now all you have to do is write extend/extract for Zipper =)
19:34:36 <erisco> I need the laws too
19:34:41 <pacak> And understand comonads.
19:34:46 <edwardk> sure, but zipper is a known comonad, so its easy
19:34:59 <pacak> Like a burrito, but in reverse.
19:35:03 <erisco> if I copy and paste, sure :P
19:35:13 <erisco> extend looks weird to me
19:35:16 <edwardk> extract (Zipper _ a _) = a -- is obvious
19:35:19 <edwardk> extend is trickier
19:35:32 <pacak> :t Control.Comonad.duplicate
19:35:34 <lambdabot> Control.Comonad.Comonad w => w a -> w (w a)
19:35:34 <edwardk> might be easier to think in terms of duplicate
19:35:38 <pacak> this  one
19:35:39 <erisco> it has more than one implementation and so I need the laws to tell me which ones are valid
19:35:54 <pacak> comonad
19:36:10 <pacak> http://hackage.haskell.org/package/comonad
19:37:57 <edwardk> using http://hackage.haskell.org/package/comonad-extras-4.0/docs/Control-Comonad-Store-Zipper.html its easy to write the thing you want =)
19:38:22 <edwardk> well, i guess not, i don't expose enough guts
19:38:41 <edwardk> young me was an ass apparently =)
19:39:07 <pacak> edwardk: Then this library will be forked and maintained by somebody who will expose all the things...
19:39:26 <edwardk> pacak: go for it. it hasn't been maintained by the jerk who wrote it in 4 years
19:39:46 <Welkin> edwardk: you have over 200 packages to maintain
19:39:47 <Welkin> get to it
19:39:53 <edwardk> only about 130
19:39:53 <c_wraith> I can't manage to maintain 2
19:39:59 <edwardk> most of the rest are only on github
19:40:13 <edwardk> or are in other languages
19:40:33 <pacak> I have like 2 and they both are outdated compared to internally used versions.
19:43:24 <edwardk> my secret is for the longest time i always had to ship and update my dependencies to hackage before i'd let myself use the changes internally in another project
19:43:26 <erisco> nah I think I can do this more simply or differently with the combinations of length n
19:43:33 <erisco> there ought to be a package for these operations
19:43:36 <erisco> combinations and permutations
19:43:48 <edwardk> erisco: its easy enough to write a manual zip-through the list once operation
19:45:12 <pacak> edwardk: I'll try that.
19:45:36 <edwardk> :t let foo = go [] where go _ [] = []; go as (b:bs) = f as b bs  go (b:as) bs in foo
19:45:38 <lambdabot> (FromExpr [t], Typeable t, Typeable a, Show a) => [a] -> [t]
19:45:41 <edwardk> er
19:45:48 <erisco> subsequences, just what I was looking for
19:46:20 <edwardk> :t let foo f = go [] where go _ [] = []; go as (b:bs) = f as b bs :  go (b:as) bs in foo
19:46:22 <lambdabot> ([a] -> a -> [a] -> t) -> [a] -> [t]
19:46:25 <edwardk> better
19:49:34 <edwardk> > let foo f = go [] where go _ [] = []; go as (b:bs) = f as b bs :  go (b:as) bs in foo (\before during after -> sum before + sum after) [1,2,3,4,5]
19:49:36 <lambdabot>  [14,13,12,11,10]
20:31:55 <Welkin> :t flip (const flip const id)
20:31:57 <lambdabot> (b -> c) -> b -> c
20:32:01 <Welkin> write your programs with that :O
20:32:29 <Welkin> (+4) `flip (const flip const id)` 1
20:32:31 <Welkin> ? (+4) `flip (const flip const id)` 1
20:32:33 <Welkin> > (+4) `flip (const flip const id)` 1
20:32:35 <lambdabot>  <hint>:1:12: error: parse error on input ‘(’
20:32:52 <Welkin> > (flip (const flip const id)) (+4) 1
20:32:54 <lambdabot>  5
20:32:57 <Welkin> :D
20:44:44 <riaqn> Hello, in GHC core, what's Corecion? What's the difference between Cast?
20:49:01 <erisco> Gloss looks great for having a simple HTML5 canvas like drawing API
20:49:11 <erisco> if I wanted to then add shaders, how would I do so?
20:50:04 <erisco> or is there a more sophisticated drawing library? (other than just straight OpenGL bindings)
20:50:13 <Welkin> erisco: you would use love
20:50:43 <erisco> what is love?
20:51:01 <Welkin> https://love2d.org/wiki/love.graphics.setShader
20:51:02 <Welkin> :P
20:51:13 <Welkin> it's not-haskell
20:51:31 <Welkin> but if you want to make games, I recommend it
20:51:45 <erisco> I am not interested in non-Haskell libraries
20:52:17 <Welkin> haskell just doesn't have great support for games
20:52:31 <erisco> I am just looking to draw things
20:52:31 <Welkin> unless you like using raw opengl
20:53:46 <erisco> I am thinking Gloss is just too simplistic for me
20:54:50 <srk> just made this with concurrent-output and repline https://asciinema.org/a/108677
20:59:11 <davean> Welkin: I mean, your other option is raw Vulkan?
20:59:15 <trudyjane> Is there a Haskell implementaion of a complete SDL for an existing ray tracer? diagrams-povray?
20:59:17 <MarcelineVQ> riaqn: have a start here https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType
20:59:43 <riaqn> MarcelineVQ: thanks for the link. This link doesn't contain the Corecion constructor.
20:59:54 <riaqn> which is why I believe it's outdated.
21:00:03 <MarcelineVQ> "Cast is used for an FC cast expression. Coercion is a synonym for Type."
21:00:54 <riaqn> MarcelineVQ:  https://downloads.haskell.org/~ghc/7.6.3/docs/html/libraries/ghc/CoreSyn.html#t:Expr
21:01:07 <riaqn> I meant the last constructor, Corecion Corecion.
21:01:21 <riaqn> not Cast (Expr b) Coercion
21:04:09 <MarcelineVQ> I see, compared to that file the wiki page is out of date
21:04:46 <MarcelineVQ> idk much about Core unfortunately, CoreSyn seems like a good place to start though and possibly https://ghc.haskell.org/trac/ghc/browser/ghc/compiler/types/Coercion.hs
21:06:14 <riaqn> MarcelineVQ: thanks anyway.
21:06:32 <erisco> hm, I am checking out luminance
21:06:37 <MarcelineVQ> Is the haddock page you linked the ghc version you're using?
21:07:06 <MarcelineVQ> if not the newest stuff is at https://downloads.haskell.org/~ghc/8.0.2/docs/html/libraries/ghc-8.0.2/index.html
21:09:22 <MarcelineVQ> riaqn: maybe http://bgamari.github.io/posts/2015-01-19-understanding-ghc-core.html
21:09:25 <riaqn> MarcelineVQ: cool, thanks! Coercion is still in the latest version, though.
21:11:03 <riaqn> MarcelineVQ: no, this blog only explain the Corecion type, not the Corection constructor.
21:11:30 <riaqn> MarcelineVQ: maybe I will leave this constructor out until it occurs to me.
21:12:07 <riaqn> I 'm just compiling GHC core to my virtual machine.
21:12:41 <riaqn> So I can just leave this case out, and see where it comes from when it really appears.
21:12:44 <MarcelineVQ> riaqn: I'd go ahead and ask about this in #ghc   It's not the first place to ask questions but there's a good chance someone there could give you a straight answer to this question
21:15:23 <jle`> oh hey the foldl library has an EndoM
21:15:23 <geekosaur> riaqn, I'd agree this is a #ghc question
21:16:34 * geekosaur is trawling the Commentary to see if it says anything about this, but not having much luck
21:16:42 <buttons840> is anyone aware of an oauth2 package they would recommend?
21:18:11 <MarcelineVQ> it's probably covered in one of simon's implementing a compiler papers but idk ^^;
23:27:02 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
23:27:02 --- topic: set by glguy on [Fri Jan 13 08:41:11 2017]
23:27:02 --- names: list (clog splanch _sg oish dec0n halogenandtoast xplat govg meandi_3 igniting luckymerlin Swizec HalfEatenPie osa1_ ebzzry eazar001 slomo Vaelatern bjz Natch IRCFrEAK dopey_ hexagoxel dedgrant eklavya nepiktaz a3Dman brynedwardz fakenerd larsan1 surtn YellowOnion limlinlo felixsch__ castlelore pavonia shafox tomboy64 RageD wagle heurist plutoniix otto_s_ sleffy beerdrop aarvar sboosali cyborg-one pasukon Xanather tripped badlands Netwolf trudyjane aatxe kvazau)
23:27:02 --- names: list (CoconutCrab jrm exferenceBot xtreak justan0theruser Goplat hucksy {emptyset} bbcue uwap leat JavaSucksMan_ threshold luigy Sornaensis athan snowalpaca modori518 Stanley00 Scip vektorweg1 dan_f jshjsh StoneToad nighty- mda1 robertkennedy atomi_ juhp___ erisco theDon isd markus1189 markus1209 nomotif Unhammer ChaiTRex nakal revprez suls verement zar hydraz deepfire ludat hybrid YongJoon kefin Rotaerk lambda-11235 ddere louispan Edith MP2E runawayfive)
23:27:02 --- names: list (bananagram Atlantic777 Voldenet bryanlem_ cpup ph88 hiratara bencryption rbocquet _ashbreeze_ anderson ekr alphor augur Lord_of_Life zero_byte nyuszika7h featherlessbiped prophile _flow_ araujo taksuyu przembot rotcpy prkc buoto m1dnight_ adelbertc eschnett niteria Jesin bgamari electrostat connrs yinn lokydor alexbiehl dequbed ertes Bish shookees chrissl thunderrd gienah_ nahra schell genq iross urodna bweston92 chenyu Ranhir armyriad statusbot xanadu_)
23:27:02 --- names: list (guampa Fairy whaletechno carlomagno1 lep-delete sdrodge Phlogistique orion nopf MindlessDrone theelous3 djellemah CurryWurst msl09 shesek byte512 petermw jluttine glitch_hat seagreen_ coeus Philonous OnkelTem dsantiago magthe ClaudiusMaximus fiddlerwoaroof Deadhand mfukar prions Madars_ jrslepak kiltzman tessier petervaro MrWoohoo tmciver foobars niluje adraenwan dunx ChewieBeardy mrd seequ aidecoe Zialus j_king abh RouxTheDay da-x anoe sns benzrf eddsteel)
23:27:02 --- names: list (simony padre_angolano dmiles parmagreen xmonader jw358 oelewapperke kwantam Biohazard indiffernet_ oherrala rodlogic xa0 joehillen pharaun kolmodin __SiCC__ m0rphism1 Marqin_ kennyp_ kshannon_ Cathy Theodule chilversc_ wto_ carbolymer_ _cyril__ fxrs raatiniemi diskie IndigoTiger Vorpal piyush-k` geppettodivacin pikajude Benzi-Junior baetheus ploop parsnip nshepperd_ wjm Tertiary SAL9000 dmwit andyo capisce Faucelme h3nnn4n rafaelcgs10 kav NeverDie ccomb)
23:27:02 --- names: list (yrdz Disavowed jabbslad staafl kriztw dfranke mikeizbicki rdococ briansteffens danpalmer nshepperd1 IanKelling zennist Arguggi solarus ph88_ JDevlieghere acro SexHendrix sleblanc mdarse lattenwald reynir tctara_ SuprDewd MatrixTraveler[m edwtjo peschkaj AntiSpamMeta sz0 kgadek bcoppens megaTherion hamishmack lavalike LuckyRawApe Rodenbach MitchW_ mk-fg ubsan x1ddos besenwesen wtw_ jbalint Frans-Willem skeet70 descender baweaver joneshf-laptop ortmage)
23:27:02 --- names: list (QRealm riaqn freechips zaquest cpape Tesseraction_o ublubu Hafydd avn Nik05 danthemyth zcourts oaao Maxdamantus datajerk bshelden n1 earldouglas tristanp Magnap Sose ali_bush timrs2998 nshepperd chin-tastic samgd tomku tapirus_ stoopkid hiptobecubic dcoutts dcoutts_ kadoban angelos Younder mulk kosorith mounty Cale mw Khisanth jbuurlage meba jud bydo Brando753-o_O_o rotty_ Sgeo __main__ tomus laxask kolko_ tinkyholloway grumble mikeplus64 RayNbow`TU)
23:27:02 --- names: list (Bashmetim Tharbakim Fylwind leothrix tokik ljhms Lazersmoke Nicmavr s4kashya3 nikivi Enzyme mceier LeCamarade bitonic theorb deni Eagle_Erwin oleks gregoire overlard mxf ipuustin hanDerPeder qz luis ericsagnes SCHAAP137 wahrsagevogel Qfwfq NocnaShada boxofdeath vqrs lyxia pinupgeek flxw Willis mero 5EXAANIJ9 Monoide haasn wizonesolutions irclogger_com swalladge anry Shatnerz diamat feepo tdammers gnull lassulus greeny zgrepc esclear monomon[m]1 TabAtkins)
23:27:02 --- names: list (Guest34681 DDR sbrg Deewiant_ ftop_ yarou leah2 acowley_away Elsi_ wrengr \u psmolen_ palo_ bbielsa Solarion_ bsmt dh mmaruseacph2 mgaare_ benoliver999 ski Geekingfrog cjh`_ pikhq_ carc shennyg nekomune_ pingu__ Deaddy baamonde__ caw mrowe gridaphobe luite_ ajp_ esmiurium tjt arw DustyDin1o obiwahn lieven CodeKiwi juri_ `0660_ integral Guest22107 o`connor_ s4kashya5 jackhill Vivek__ Ralith__ Guest66940 phadej sshine_ coup_de_shitlord t00m0 delYsid`)
23:27:02 --- names: list (ess_sing NickSeagull ajmccluskey burp_ myfreeweb Stratege canta rdesfo[m] tctara Zowlyfon hongminhee ft xinming oberstein Myrl-saki huonw Bob131 solatis Xnuk Randy Sigyn cogrendel _kit_ Sonderblade obadz Qommand0r wedens eyck zenware fbergmann jchia Gredu rossberg zhulikas treehaqr arkeet norotartagen omilu ricardo82 tobiasBora atk maerwald marmalod1 baroncharlus adamCS ijp barrucadu dibblego caasih pita Cthalupa bxc Vzox01 numeo catsup MarcelineVQ Cxom)
23:27:02 --- names: list (pacak sqrt2 zxtx joachifm schjetne lambdabot dpepsilon metafoobar jdnavarro geekosaur unknownln TylerCecil[m] bobjason[m] cbHXBY1D[m] M-krsiehl Soif[m] closures999[m] wictory[m] hakan[m] FederalRick[m] bb010g roadrunner168[m] mmmrrr[m] alaradia[m] davidar_ TheWizardTower goodboy[m] jyp[m] jacqueline[m] iffsid[m] Naughtmare[m] davidar m4lvin[m] herzmeister[m] karroffel M-BostonEnginerd colton[m] foldu[m] elwan7[m] curry[m] unclechu seequ_ M-Quora)
23:27:02 --- names: list (miviotros[m] gentam[m] jmnoz[m] rakete sudoreboot[m] noraesae zaphar_ps[m] Guest91110[m] ProofTechnique[m chef_excellence[ M-berdario M-Illandan hendrik[m] M-schmittlauch aspiwack[m] M92854[m] tfc[m] Yves[m] NopeMarker[m] drasich[m] hiq[m] corintho[m] gkaplan[m] srenatus[m] Aidan[m] Robin_Jadoul jophish peterhil Dunearhp_ yrid Coldblackice fold4 chu Reisen cross micro_ louispvb zomg ziman sveit srhb beaky texasmynsted flebron Tourist rodarmor supki LnL mt)
23:27:02 --- names: list (cdidd fryguybob sujeet thi_ tv discrttm tippenein ysangkok SlashLife emily1 valdyn happy0 stvc1 byorgey zchn chindy Jinxit dolio kaeluka Ferdirand Wamanuz madsj FrankZappa Amadiro SolitaryCypher noteshui mimi_vx jchia_ malt3 jgertm- tabaqui1 whiteline bluepixel Kuros` makufiru Intensity RGamma ByronJohnson gornikm_ lenstr greenbagels relrod Majiir pmade Frankablu monochrom jle` mikecaruso grayhatter tlevine betawaffle logcat wavewave koala_man naudiz)
23:27:02 --- names: list (glowcoil aminb crosleyt dabukalam albel727 Ring0` d3lxa wting CuriousErnestBro Eliel eyen tumdedum ReinH afcondon_ centril Axman6 magicman jessicah amiri pdgwien- MasseR karce louisriesener blackdog idupree2 qmm bitemyapp Ninja3047 michaelw cheater brixen twomix Moyst SuperTux88 raid c0dehero ggVGc Jaak worch keemyb WizJin hive-mind niklasb LordDeath Baughn meck mak` c-rog [swift] Phyx- fkurkows1 ChongLi c0smo dschoepe acfoltzer Enigmagic spoonm)
23:27:02 --- names: list (clamchowder miklcct amoe_ mniip cic tjbp s4msung emmflo tg bno1 Raptor8m3 lopex nwf kini thewormkill Ov3rload flobberlet Morgawr Matajon dredozubov Dykam Speed __name__ Fuuzetsu lukke100 tnks winny wyvern Rembane ngWalrus marcel @ChanServ sdemos spicydonuts dwarders gargawel neonfuz dpn` ryoia raibutera JSharp geal kipras`away Freundlich monty gpampara cbaines ahf rootmos Tallenz posco vishesh MagBo irishsultan froztbyte folsen kaol gothos Ornedan Fubar^)
23:27:02 --- names: list (statusfailed rjeli hnrk odamn phz_ Reyu cheshircat mystfox defanor chelfi shiona fergusnoble Gothmog_ unsymbol Nikotiini suppi kjanosz lachenmayer Twey bd_ saurik emerson lpsmith eL_Bart0 absence Tehnix` bogdanteleaga qlkzy poga nerdystreetrat brent80_plow jrkp dqd kriton tomjaguarpawaway n__dles ncl28 AWizzArd vodkaInferno heath voidrays nilOps ReinH_ japesinator tych0 domenkozar pinkmuffinere Veltas kloeri pleiosaur Ford_Prefect wamaral jlouis s4kashya2)
23:27:02 --- names: list (abbe kmicu cnr vin-ivar lpaste_ scared zpconn__________ epta Ewout mkurkov_ Neo Ankhers abra0 PHO cynick TallerGh- agrif strixy- spacebug Profpatsch rstone Xorlev etrepum aristid strmpnk si14 andrew__n__ zmanian_ kipd milessabin kyagrd wenzowski jcp___ dgonyeo solidsnack micmus cmdv heyj bbee bengt_ ericbmerritt_ mpickering jotrk heinrich5991 cdornan ion davean jdt oj_the_juiceman raek Xandaros Xe jix SLi jaargon_ c9s_ ec\_ M2tias wayne madknight)
23:27:02 --- names: list (bob_twinkles mikedlr customminer xplat|work sclv ephemeron monad_cat ocharles bjs sa1 stig g4k brolin_empey cow-orker Rabbit__ TommyC carter-znc stefan- Taneb Logio srk trevorriles exio4 tekacs garphy numberten anonus _6a68 majjoha a3f erg icedev adimit ctag joeytwiddle grandy__ martingale Jello_Raptor bwe mattp anachrome vincenz CindyLinz Forkk intelux armlesshobo jtobin edejong hughrawlinson runeks Bengi tazjin OliPicard Scorchin andreypopp nkpart)
23:27:02 --- names: list (QuantumLogic angerman nbouscal {AS} rellen michalrus bgyss houli noplamodo_ daishan opios codebje Saimeidae qguv spion lstrano libscott tsani KaneTW CARAM__ edwardk tjpeden MejGun ircbrowse cjay dyreshark TheAuGingembre quuxman imalsogreg myme scopedTV siddhu Meanirelli mrlase henrytill pelegreno iphy liste hodapp Drezil reactormonk dunj3 gnusosa Belgarion0 petercommand newsham usr ycheng davl fabianvf peteretep arcetera ryanpcmcquen billstclair gsingh93)
23:27:02 --- names: list (stass stephe max-m TimWolla richi235 vimto pchiusano dxtr yushyin aegray flux dustinm tomaw int-e edran nesqi Clint thallada HappyEnte squisher dbecvarik mavihs asjo SoupEvil mbrcknl dpower seanparsons gleber_ w4and0er96 moop PatrickRobotham carter dgpratt ahihi mudfog implementation sm mauke angseus zenzike notdan JPohlmann xaimus wrmsr_ darktenaibre kofdog_ jstolarek hiredman tero- bjobjo timothyh stux|RC-only AppleJacks24_ sleepynate ernst suzu scav)
23:27:02 --- names: list (guios brisbin CosmicRay quaestor owickstrom Purlox wz1000 catern malthe MorTal1ty PotatoGim lancetw codedmart feltnerm ggherdov cstrahan jordanlewis shapr ogkloo dxld peddie ohsix adarqui Someguy123 rgrinberg pringlescan Guest36413 Adluc stasku avdi Heero minad georgew Jaxan nitrix chrzyki_ akermu RazorX seliopou aweinstock cartwright tharper darthvorik stevenxl chriswk ongy paroxp cansis lynn APic shutdown_-h_now rootnode reem x1n4u nemesit|znc fingerzam)
23:27:02 --- names: list (EvanR Ke dilinger robogoat greymalkin pyrtsa yaknyasn banjiewen prefork johtso bkonkle paf31 spinda incomprehensibly rjungemann Bigcheese isacloud jfokkan__ ecobos tarcwynne_ tgeeky fycth bbaren rotty thoughtpolice buckowski shans_ vikram__________ angular_mike_ masquerade sdx23 vikraman Nolrai sbauman enolan Nycatelos s4kashya Liskni_si tortal thoradam bartavelle Unode joeyh navilan- Blkt ixian pranz linduxed tolt niko drdo hpc yorick XMunkki_ andreass_)
23:27:02 --- names: list (Tspoon_ vili jameseb ezyang Quintasan cmn tek0 orzo watersoul osfameron AustinMatherne jgornick lispy cschneid Vbitz dtulig zymurgy anhduy aaron7 otulp Zemyla Squarism pushp0p_ GGMethos hyPiRion lwm inr Guest37271 dstockwell rann mbrock dsm Tritlo mankyKitty fuziontech jonrh jorendorff `DanZimm klugez brassel mathu Chousuke eagleflo Tazca_ Wojciech_K pent_ mudfog- Athas fugyk cpu1 rom1504 Cerise orcus g2 lukky513 cjwelborn asm89 Guest46632 SolarAquarion)
23:27:02 --- names: list (jml xacktm erikd dbohdan keri Klumben alem0lars fall_ Boreeas noctux jmct NemesisD lukexi S11001001 okeuday_bak sgript- Akii bigs_ Vq cmr nille bus000_ Jonno_FTW brennie lexi-lambda jorj zipper s4kashya1 cchalmers eikke biocage s4kashya_ rlr pfoetchen kml sjl_ sanjoyd frug72 jinblack josh5tone saylu Tristan-Speccy NickHu turnage kian xfix mendez frontendloader bdeferme Saizan urdh arand nocookies92 nurupo platz so darthdeus_ liyang Ulrar rejuvyesh Maerten)
23:27:02 --- names: list (spaceships glguy RevJohnnyHealey nikolah LeaChim avn_nb Adeon sovreign_ swhalen mnoonan mitchty bind1 karls Ieuan alpounet chirpsalot ramatevish p_q andjjj23 dan64 valkyr2e Igloo i-amd3 throughnothing l_zzie CGML Laney killtheliterate alanz ps-auxw vi0 c_wraith mjo B4tMaN u-ou staticfox kyren_ dmj` earthy vfs cgfbee jamiis pdxleif averell solution_ hsyl20 jtcs nek0 cgag loupgaroublond esph marens staffehn Kneiva hegge Ariadeno xnyhps tswett cods comboy_)
23:27:02 --- names: list (dogui mokus_ kosmikus opqdonut ambrosia_ Hijiri mantovani Raynes jzl Bane^ cocreature Sam___ SegFaultAX julmac tibbe amuck ynyounuo xxpor alibabzo prooftechnique codebam amatecha ninja_in_neopren scinawa Chobbes jokester divVerent hansihe AlainODea SaidinWoT zph metalrain yminsky trig-ger majoh)
23:50:25 <adarqui> anyone have a project using ghcjs/building with stack, on ghc 8.0.2 and lts-8.x ? if so, care to share your stack.yaml?
