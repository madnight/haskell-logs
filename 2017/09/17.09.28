00:16:28 <magthe> vaibhavsagar: isn't it automatically included when it's added to stackage?
00:17:08 <vaibhavsagar> magthe: gtk2hs-buildtools, pango, cairo, etc. have been updated very recently
00:17:17 <vaibhavsagar> but I don't see them in a nightly package set
00:17:51 <vaibhavsagar> I think haskell-packages in Nix are also based on this package set so it would be nice for them to be included soon
00:18:48 <magthe> aha, I mistunderstood you, I thought you wanted a new package into Stackage, not a bump of the version that's included
00:19:11 <magthe> vaibhavsagar: I believe there is a list of curators somewhere in the stackage git repo
00:23:35 <cocreature> vaibhavsagar: nix is based on LTS afaik and not on nightly
00:24:54 <vaibhavsagar> cocreature: what about the 8.2.1 package set?
00:25:01 <zyxoas> Peeps.
00:25:10 <vaibhavsagar> I assume that's based on nightly?
00:25:12 <zyxoas> Very quick question about type families:
00:25:37 <zyxoas> Can anyone show me an example of pattern matching on the individual characters of a symbol, in a type family?
00:26:17 <zyxoas> Something like: type instance TheThing ("a" ++ s) = Char
00:26:19 <zyxoas> ?
00:26:48 <zyxoas> Problem is that I can't have a type family application on the left hand side -- the instance head context.
00:27:08 <zyxoas> But I'm really not sure how to work around this massive limitation.
00:27:36 <zyxoas> Basically, it seems like you can't do pattern matching in type families, at least not in a straightforward way...
00:27:40 <zyxoas> Help?
00:59:37 <osa1> is there a way to limit upper bound of memory residency of a thread, like `GHC.Conc.setAllocationCounter` for allocations?
01:05:18 <Axman6> do you mean Haskell thread or OS thread?
01:05:36 <int-e> osa1: not on a thread level; heap objects have no owner once they come out of the thread-local nursery. Also, due to lazy evaluation, the allocating thread may just be evaluating a thunk that another thread created.
01:05:37 <Axman6> pretty sure Haskell threads don't have their own heaps, so doing so would be difficult
01:06:01 <Axman6> and what int-e said >_>
01:12:21 <pacak> osa1: You can set allocation limit per thread.
01:13:26 <pacak> setAllocationCounter and enableAllocationLimit
01:13:34 <osa1> allocation limit is useless in my case
01:13:46 <osa1> it's fine if it allocates 100Tb as long as residency is within the limits
01:14:33 <merijn> osa1: GHC8 is doing a great job of teaching people to stop paying attention to MEM and start paying attention to RES in top ;)
01:15:03 <osa1> heh, right.
01:22:00 <Axman6> yeah, gotta love all the 1TB MEM apps I write
01:23:54 <merijn> Axman6: Best when you're running on a shared server and top shows you running 12 of the things :p
01:24:37 <Axman6> yah
01:25:18 <merijn> So far no one's yelled at me, though, so :)
01:25:39 <Axman6> yer hoggin' all tha pages!
01:34:06 <`Guest00000> defining datatypes looks like adding constructors to *
01:36:26 <merijn> `Guest00000: If you think of kind * as the set of all existing types, then yes, defining a datatype adds a new element (potentially infinitely many!) to that set
01:37:16 <athan> merijn: Would * and Constraint be the only open kinds?
01:37:20 <merijn> `Guest00000: Since, for example "data List a = Cons a (List a) | Nil" actually adds one type to * for each type already in * (recursively including the new types it's adding to)
01:37:21 <athan> er Type*
01:37:50 <merijn> athan: No, because you can add new types to "* -> *" rather trivially too
01:38:10 <athan> Ahh right
01:38:11 <merijn> athan: e.g. Maybe, [], etc.
02:10:13 <saurabhnanda> does ghc-mod work well with stack?
02:14:35 <merijn> The person who added "instance Monoid a => Monoid (IO a)" is my hero
02:14:42 <MarcelineVQ> if you know the trick, which is to  stack build ghc-mod  for each project
02:17:34 <saurabhnanda> MarcelineVQ: thanks!
02:18:01 <saurabhnanda> and then `ghc-mod check myfile.hs` ?
02:18:09 <MarcelineVQ> stack exec -- ghc-mod
02:18:33 <MarcelineVQ> that way it picks the one you built for that project
02:19:42 <MarcelineVQ> if you're lucky your editor's ghc-mod plugin (if it has one) is stack aware but you still want to  stack build ghc-mod
02:19:48 <saurabhnanda> MarcelineVQ: how do I keep it running, and listening for file changes?
02:21:51 <MarcelineVQ> I'm not sure really, when I used it my editor took care of that.  if that's the speciic use you want it for I'd reccomend ghcid over ghc-mod
02:22:09 <MarcelineVQ> ghc-mod's only advantage over ghcid, for me, is mouse-over type checking
02:22:19 <merijn> MarcelineVQ: ghcid doesn't have a vim plugin, though :(
02:22:44 <saurabhnanda> this is exasperating!
02:23:14 <merijn> Can I linewrap the LHS of a function declaration? My patterns are getting too long for one line...
02:23:29 <merijn> saurabhnanda: Which editor are you using?
02:23:48 <saurabhnanda> merijn: spacemacs + intero. but it leaks memory like anything.
02:24:07 <MarcelineVQ> merijn: I'm able to in ghci, give it a try
02:24:35 <merijn> MarcelineVQ: This is a new achievement for me. I've been linewrapping types for ages, but patterns is a new one :p
02:25:13 <merijn> Seems to work, but wreaks havoc upon my code layout :\
02:25:56 <saurabhnanda> do I need to install ghcid separtely for each stack project?
02:27:09 <MarcelineVQ> I expect you only need it once per ghc version given how stack's resolvers are set up, but that is a simple way to make sure of that so I'd probably do so if I were you.
02:27:53 <MarcelineVQ> it's easy though luckily  stack build ghcid  if it doesn't need a different version it'll just copy a built one.
02:28:35 <saurabhnanda> how do I launch ghcid?
02:28:53 <MarcelineVQ> stack exec ghcid
02:29:32 <saurabhnanda> I'm trying this -- stack exec -- ghcid src/AppServer2.hs
02:29:50 <saurabhnanda> it's throwing a parse error on the first quasi-quote in that file./
02:30:25 <MarcelineVQ> How are you enabling quasiquoters?
02:30:44 <saurabhnanda> via cabal file
02:31:02 <saurabhnanda>   default-extensions: OverloadedStrings RecordWildCards DataKinds DeriveGeneric FlexibleInstances FlexibleContexts FunctionalDependencies GeneralizedNewtypeDeriving KindSignatures MultiParamTypeClasses TemplateHaskell TypeFamilies TypeSynonymInstances QuasiQuotes ScopedTypeVariables LambdaCase PolyKinds TypeApplications Arrows ConstraintKinds DuplicateRecordFields 
02:31:05 <MarcelineVQ> chances are it's not loading the cabal file since you're giving it a specific file. try loading the project by not suplying a file
02:31:38 <merijn> Also, files without explicit pragma's at the top of the file are evil
02:31:40 <saurabhnanda> but I don't want the entire project to be loaded -- not all top-level modules are in a compilable state due to a WIP refactor.
02:31:59 <MarcelineVQ> I agree with merijn very strongly
02:32:24 <saurabhnanda> I disagree. They're pragmatic and build tools *should* support them.
02:32:32 <bartavelle> so do I, what is the point of writing haskell if your source files are not 70% pragmas ?
02:32:41 <merijn> argh...who decided that `on` should have infixl 0, making it impossible to use it with $ :\
02:32:52 <MarcelineVQ> That's fine too. Anyway one of those options solves your current problem.
02:32:53 <merijn> saurabhnanda: It's not about build tools, it's about poor human programmers reading your file
02:33:12 <bartavelle> saurabhnanda: what merijn just said
02:33:32 <saurabhnanda> bartavelle: what about what he/she said?
02:33:35 <merijn> "Wait, is this file using RankNTypes? Or is this ScopedTypeVariables?
02:34:02 <saurabhnanda> merijn: it's using all the dozen type-system extensions that are required to write any real-life haskell program.
02:34:30 <saurabhnanda> you come into a project -- you read a doc about all the extensions that are enabled by default and be done with it. It's that simple.
02:34:36 <merijn> saurabhnanda: Funny, most of my real-life Haskell uses almost none of those, tbh
02:35:11 <boj> i put OverloadedStrings and NoImplicitPrelude in my cabal, but everything else as pragmas in each specific file. to not do so is madness
02:35:28 <saurabhnanda> merijn: then you and I are attacking different problem domainss. I'm not getting sucked into a "my code is purer than your code argument".
02:35:57 <boj> you seem to be avoiding a lot of arguments lately saurabhnanda :p
02:36:08 <MarcelineVQ> This is not a productive line of conversation for solving the issue. 
02:36:24 <bartavelle> this is a classic IRC case of "this doesn't work / but you are not doing the right thing"
02:37:22 <bartavelle> anyways, one workaround is to add stuff to the .ghcirc or to manually :set -X... in ghci
02:37:36 <saurabhnanda> boj: because I'm sick of people taking a "holier than thou" attitude. There's always some "best practice" that someone pulls-up, which doesn't really stand a broad application. I'm here to deliver working code, and would prefer my tools to enable me to do that with a good mix of safety and speed. I'm willing to forego some safety for development speed.
02:38:17 <bartavelle> I think these workarounds will not scale to that level of extensions though
02:38:28 <saurabhnanda> MarcelineVQ: thanks for your help MarcelineVQ. I don't think the issue can really be solved. It seems ghcid has that limitation. I'm not going to go over all 1,000+ files in my project adding pragmas at this point.
02:38:57 <MarcelineVQ> saurabhnanda: what do you get with  stack exec -- ghcid -c stack ghci yourfile.hs
02:39:08 <saurabhnanda> MarcelineVQ: parse error on the first QQ in that file.
02:39:13 <MarcelineVQ> odd.
02:39:26 <MarcelineVQ> does  stack ghci yourfile.hs  work?
02:39:53 <saurabhnanda> I can load the file in ghci via :l
02:40:06 <saurabhnanda> does stack ghci yourfile.hs have a different behaviour (which would be very surprising for me)
02:40:10 <saurabhnanda> let me validate this again
02:44:00 <saurabhnanda> :l works
02:44:16 <saurabhnanda> checking stack ghci src/AppServer2.hs
02:45:31 <saurabhnanda> both methods of loading the file in ghci work. GHCID doesn't work. MarcelineVQ does that point to anything?
02:47:09 <saurabhnanda> Gotta run for a meeting. I guess I'll just file this in my list of GHC tooling problems and move on with actually delivering some code. I've had enough of this constant fiddling with stack, ghci, cabal, ghcid, ghc-mod, intero, hie, and what not.
02:47:18 <MarcelineVQ> not sure at the moment, setting up something similar to see
02:47:41 <boj> saurabhnanda: maybe it's time to go back to ruby, your product could have been launched months ago
02:47:45 <Boomerang> Have you tried `ghcid -c "stack repl"`?
02:48:14 <MarcelineVQ> they don't want the load the whole project for some reason
02:48:46 <MarcelineVQ> when you write stack ghci yourfile.hs what does it say for Using configuration for [...]
02:49:26 <Boomerang> Alright fair enough (I should have read better)
02:57:02 <ventonegro> Funny how POV changes things. Having developed in Lua and Scheme for a long time, the haskell ecosystem seems so rich and polished to me
02:57:16 <ventonegro> I mean, the whole stackage thing is awesome...
02:59:06 <`Guest00000> need fractional fixities
02:59:15 <`Guest00000> infixl 0.4 `on`
03:00:07 <Maxdamantus> aiui, Perl 6 had a pretty decent way of dealing with that.
03:00:36 <Maxdamantus> You just say that one operator has higher, lower or equal precedence than another one.
03:01:51 <MarcelineVQ> something is in error about your project's setup saurabhnanda, I am able to set  default-extensions: QuasiQuotes  in my .cabal file and use a  stack exec -- ghcid -c stack ghci sourcefile.hs  that is aware of quasiquotation. Possibly it's choosing the wrong section of your cabal file to get settings from? It'll say what cabal file section configuration it's using then you write  stack ghci sourcefile.hs  by itself
03:01:54 <Maxdamantus> Preferably it would just be an error when you use operators that are both just specified as lower/higher precedence than another operator.
03:02:05 <Maxdamantus> Dunno if it actually does that.
03:03:22 <Maxdamantus> Hm, maybe Perl doesn't do that.
03:03:38 <MarcelineVQ> saurabhnanda: Is the sourcefile you're trying to load also a module listed in your cabal file? If not it'll say  Couldn't find a component for file target [sourcefile.hs]  which is a problem.
03:04:58 <ski> `Guest00000 : a partial order might be better ?
03:05:49 <ski> (including being able to declare operator groups, and declare an operator a member of a group, after the fact .. or something along those lines)
03:08:48 <fommil> how come there is no Monoid for Tuple7? I have two tuple7s (of strings) that I want to combine
03:09:03 <fommil> is there another way to do that?
03:09:10 <opqdonut> write out the tuple instance yourself?
03:09:20 <opqdonut> *monoid instance
03:09:27 <fommil> yeah I guess so, but since it doesn't exist I was wondering if there was a reason
03:09:36 <Maxdamantus> infixl on > (>>); infixl (>>) = (>>=)
03:09:39 <MarcelineVQ> why do you have 7tuples :X
03:09:46 <boj> probably because it is so rare :)
03:09:59 <opqdonut> usually people switch to records for >3 fields
03:10:07 <fommil> I'll do that. Also, is there a way to create a tuple7 out of a single element? Just repeated. And the same again, but by repeating a call to an algebra (e.g. calling random)
03:10:26 <ventonegro> tuples with 7 strings look more like lists...
03:10:41 <fommil> ventonegro: this really needs to be 7. It's for shakespeare input
03:11:48 <fommil> opqdonut: hmm, if I used a record could I derive Monoid?
03:11:59 <fommil> that might be nicer
03:12:13 <opqdonut> fommil: not directly, no. there might be a generics library for that though
03:12:41 <opqdonut> you could also consider something like https://hackage.haskell.org/package/sized-vector-1.4.3.1/docs/Data-Vector-Sized.html
03:12:46 <boj> fommil: you'd still have to write the instance out
03:13:17 <opqdonut> you could use zipWithSame and replicate from there to do the things you want
03:13:18 <fommil> ok. I would have expected that to work. I'd still have the problem that I'd need to generate a new `data TemplateInput` from either a single string or repeated calls to the random number generator.
03:15:02 <saurabhnanda> MarcelineVQ: I'm back, if you're still interested in helping debug this.
03:15:46 <saurabhnanda> MarcelineVQ: the way you're running ghcid is different from what I was doing. Is the missing -c the problem here?
03:16:36 <saurabhnanda> MarcelineVQ: I'm using hpack -- the cabal file is auto-generated. Confirmed that the module is listed  in other-modules.
03:17:50 <saurabhnanda> fommil: could you repeat your question? I *might* be able to help.
03:18:38 <MarcelineVQ> yes -c matters,  ghcid --help will tell you what it does. what were you trying earlier when asked?
03:18:39 <saurabhnanda> Boomerang: the whole project is 1,000+ files and we want to load only the in-active development modules.
03:18:59 <fommil> saurabhnanda: cool thanks. I want to create a Tuple7 two ways: 1) repeating a value 2) calling an algebraic method. Currently I'm doing it by hand and it's super boilerplate.
03:19:19 <fommil> 2) is calling a random number generator
03:19:27 <fommil> so basically a Tuple7 of randoms
03:19:49 <saurabhnanda> MarcelineVQ: here's what I'm trying. Are the stack warnings something that need to be investigated in this case? https://gist.github.com/saurabhnanda/10cc3760f2850c84ba3f4cbad6c75c0d
03:20:17 <MarcelineVQ> that's not what I'm writing
03:20:30 <fommil> saurabhnanda: also, in tandem to that, I was investigating something better than Tuple7 so I don't have to implement Monoid Tuple7 (which I've already done, but it feels hacky)
03:20:47 <saurabhnanda> MarcelineVQ: missing ghci ?
03:20:49 <MarcelineVQ> replace sourcefile.hs with the path to the file you're after      stack exec -- ghcid -c stack ghci sourcefile.hs
03:21:12 <fommil> e.g. a data type and derive the Monoid. Presumably I'd be able to create it from the Tuple7 I'd create from 1) and 2)
03:21:55 <fommil> oh, actually my own Monoid is horrid... orphan instance. ycuk
03:22:16 <saurabhnanda> fommil: you have two functions and want to compose them to create a tuple7 by calling them 7 times, except without having to type out the 7 invocations?
03:22:31 <MarcelineVQ> that rather unhelpful error you got is saying that it tried to run your file as a stack bang stript because that's what stack does when handed a source file without other args
03:23:18 <saurabhnanda> MarcelineVQ: it *seems* to be working now. Althought don't know what happened. There's two reference to stack in that command line and two references to ghci/ghcid
03:23:41 <saurabhnanda> MarcelineVQ: now, let's see if this also leaks memory... 
03:24:19 <fommil> saurabhnanda: not composed with each other. Just repeating something 7 times. I have a monadic version and a pure version, the code doesn't need to be shared.
03:24:21 <MarcelineVQ> you're running ghcid in the context of stack, because you built it with stack so that's just prudent, you're then telling ghcid to use stack's ghci to run your single file in the context of the project so it can take advantage of cabal file settings.it's a bit of a hassle but this isn't quite standard practice
03:24:49 <saurabhnanda> MarcelineVQ: okay. Got it. Thanks. Which part is non-standard?
03:26:03 <saurabhnanda> fommil: short answer. There is no easy/quick way to treat tuples like lists. You can't repeat a function call and get an n-tuple. You can't concat them. They LOOK like they're similar, but they're really different data-types. One could be RecA and the other could be RecB for all you care. I struggled with this a lot and this is my final epiphany.
03:26:49 <saurabhnanda> fommil: if you're hell-bend on doing this, then TH is probably the easiest answer for you, but it would be overkill. Swallow the bitter-pill of writing some boilerplate and move on. 
03:27:16 <saurabhnanda> fommil: if you need affirmation, please look at how lenses for _1.._20 are defined. Look at how p1...p32 of product profunctor are defined.
03:27:49 <fommil> saurabhnanda: ok, thanks
03:27:58 <MarcelineVQ> to me it's desiring to only be considering a single file while working in a whole project
03:28:07 <fommil> maybe I'll create a helper at least for the pure value case
03:28:40 <MarcelineVQ> That and extensions like quasiquotes over a whole project isn't something I see much of
03:29:20 <saurabhnanda> fommil: if you can go up one level and explain *why* you need a 7-tuple, probably there can be a better solution.
03:29:39 <tdammers> just ran into a weirdness with ghci where options you :set are applied to modules on :reload, which can compilation errors
03:29:44 <fommil> saurabhnanda: I have a shakespeare template that takes a 7 tuple of strings
03:29:55 <saurabhnanda> MarcelineVQ: we use the PerlQQ quasi quoter all over the place. By far the easiest way to interpolate strings/text/bytestrings/whatever.
03:30:09 <fommil> I have two ways I want to generate those inputs... one is a repeated value, another is random values.
03:30:25 <tdammers> e.g., importing a module, then :set -XOverloadedStrings, then :reload, may produce type errors because now the string literals are no longer monomorphic, and the type checker can't disambiguate
03:30:50 <saurabhnanda> fommil: are values in this 7-tuple of the same type? Not using a a list, because...
03:30:53 <MarcelineVQ> It's fine to use it all over it's already been mentioned before what's more common
03:31:36 <fommil> saurabhnanda: all the same type, arity is extremely important
03:32:05 <tdammers> saurabhnanda: one use case that comes to mind is database query result sets - say you want to enforce row count and row types, but you don't want to write a separate `data` type for each query. Tuples are a decent enough compromise.
03:32:11 <fommil> saurabhnanda: well I could use a List but then I lose compile time safety, so why would I want to lose that?
03:32:46 <fommil> oh man, the users with usernames so and e really mess up the emacs rendering of pretty much everything. This is driving me crazy, I'm going to have to work out how to not highlight short usernames.
03:32:57 <MarcelineVQ> saurabhnanda: In my case I just write stack exec ghcid and move along, I get to see all the errors and that's that. However if I wan't a module to not tell me things I might do something like {-# OPTIONS_GHC -fdefer-type-errors #-}  but it hasn't really come up
03:32:59 * ventonegro thinks of dependently-typed lists
03:33:38 <saurabhnanda> tdammers: agree. tuples are useful and irritating at the same time.
03:34:05 <saurabhnanda> fommil: to summarize, if you're convinced arity is important, then boilerplate is the short-term, get-it-done answer. 
03:34:25 <fommil> saurabhnanda: maybe I'll use a list and make this be Maybe. To hell with it.
03:34:49 <tdammers> saurabhnanda: the weird thing is, they're not technically *needed*, you could just define `data Tuple a b = Tuple a b`, and then nest them for n-ary tuples
03:34:54 <fommil> it that case I presume getting a 7 element List or M[List[_]] is quite easy?
03:35:01 <tdammers> it works, purescript does that, but it's positively awful to work with
03:35:13 <tdammers> although some things get more elegant
03:35:25 <saurabhnanda> fommil: please spend 2 minutes answering the question, what happens if this gets a shorter list or a longer list. Can your HTML handle the missing elements gracefully. IF it can, and this HTML is not mission critial, I'd go with a list and be done with it.
03:36:23 <fommil> saurabhnanda: nope, it needs to be exactly 7
03:36:34 <fommil> but this is test code, so I am happy to compromise
03:37:04 <tdammers> "needs to be" in the sense of "if you only have 6 of them, then there is absolutely no value at all in producing any output whatsoever"?
03:37:16 <fommil> saurabhnanda: I'm writing an http mock with this https://twitter.com/fommil/status/913135339874783241
03:37:24 <fommil> in an otherwise scala project
03:37:28 <saurabhnanda> you're overthinking for test code. You're not deploying the test to production. Do whatever you like in tests. As long as **running** the tests validates some properties of your main program, you're fine.
03:39:02 <fommil> saurabhnanda: still, this is my only opportunity to do Haskell, so I'm keen to learn how to do things properly. It seems that tuples are fiddly, is my lesson.
03:39:20 <saurabhnanda> tuples are anal. They're not fiddly.
03:39:26 <saurabhnanda> :)
03:40:16 <MarcelineVQ> saurabhnanda: oops I meant  {-# OPTIONS_GHC -fdefer-type-errors -w #-}
03:40:17 <saurabhnanda> MarcelineVQ: ghcid also leaks emory.
03:40:24 <michalrus> Hey, what’s the name of this extension where I can write @someValue and it’ll become its type?
03:40:32 <saurabhnanda> MarcelineVQ: every single GHC tool I've tried is leaking memory upon project reloads/recmopiles.
03:40:48 <saurabhnanda> michalrus: TypeApplication
03:40:51 <MarcelineVQ> michalrus: -XTypeApplications
03:40:51 <michalrus> ♥
03:40:53 <michalrus> Thanks!
03:42:25 <MarcelineVQ> saurabhnanda: I wouldn't know much about how that works. I have had that issue a lot with ghc-mod but not with ghcid and my projects are likely smaller than yours, or at least less ambitious.
03:44:21 <saurabhnanda> MarcelineVQ: if you have time, may I request you to please try this. fire up ghcid and edit the deepest file in your project (which should trigger a complete project recompile, essentially). Do that 5-10 times.  Check RAM usage for the ghc/ghcid process. I'm unable to ascertain if it's a general bug with the GHC tooling or some corner that is being hit with my project.
03:45:46 <Nikkis> q
03:48:07 <MarcelineVQ> sec, trying to find a project that impacts the meter
03:51:39 <MarcelineVQ> bleh, deleted my .stack too recently, everything's recompiling
03:52:19 <fommil> saurabhnanda: damnit, now the Monoid of the List isn't doing what I wanted... it's of course doing the right thing. I want to combine the elements of the list.
03:52:30 <fommil> I should have stuck with Tuple7 :crying:
03:52:36 <merijn> fommil: zipWith mappend?
03:52:41 <merijn> :t zipWith mappend
03:52:43 <lambdabot> Monoid c => [c] -> [c] -> [c]
03:53:06 <fommil> ah
03:53:09 <fommil> of course
03:53:13 <fommil> we even have that in scalaz
03:53:18 <merijn> fommil: You could newtype that and make it a Monoid instance too
03:53:41 <MarcelineVQ> ZipList already exists :>
03:53:55 <merijn> MarcelineVQ: That's for Applicative, don't think that has a zipping monoid
03:54:09 <MarcelineVQ> It doesn't? Pardon me then
03:54:20 <merijn> ZipList is not a Monoid according to the docs
03:54:55 <merijn> Although it's trivial to implement "liftA2 mappend" is zipWith mappend for ZipList
03:55:06 <dibblego> fommil: what operation exactly?
04:01:49 <fommil> dibblego: I'm being bad and using [String] instead of Tuple7 for template and I was wanting to combine them (hence zipWith mappend). Turns out Haskell doesn't come with a Monoid for Tuple7, and doesn't derive Monoid for data types. I guess scala can be better at some things :-P (scalaz-deriving will do this no problem...) 
04:02:20 <fommil> I didn't want to create an orphan Monoid for Tuple7
04:02:41 <fommil> I'm not sure what's worse... using a list instead of a data type / tuple, or using an orphan instance.
04:02:59 <MarcelineVQ> saurabhnanda: it seems to go up slowly every other file change on the project I'm trying, even given a fair bit of time between file changes. I don't expect it to go down but I would have expected it to at least not go up given time to finish things
04:03:06 <merijn> fommil: You can just newtype the datatype and write an instance for that, problem solved
04:03:22 <dibblego> use ((a, b, c), (d, e, f, g)) if you really must
04:03:26 <fommil> shakespeare is pretty damn good, btw. I'm generating 10k requests/sec in our http service mock, every query is a 7 parameter shakespeare template with random data.
04:03:47 <dibblego> use neither of those things, they are both bad
04:04:37 <fommil> merijn: I don't even need to newtype it, I can just create a data type and write the Monoid right there. But then I still have the problem of generating a tuple of size 7 from a value or monad. For [String] it's replicate or replicateM, as needed.
04:05:27 <fommil> and I figure this could easily be a huge rabbit hole or boilerplate
04:05:39 <fommil> I might come back and do it after, for funsies
04:06:14 <fommil> (I'm assuming that it's reasonably easy to create a data type from a tuple)
04:07:34 <MarcelineVQ> dibblego: how would you approach it?
04:07:47 <dibblego> I'd write my own data type and instance, and move on :)
04:07:58 <dibblego> I'd also set a timer, just to make it interesting
04:08:09 <dibblego> 9-finger typing challenge
04:08:59 <MarcelineVQ> oop good stuff but I meant to be asking what would you use instead of shakespear here
04:09:18 <fommil> dibblego: heh. Well I got that far and backed out. I think I should go back and just abstract out the replicate / replicateM into a kind of constructor method
04:09:41 <fommil> that was the bit that was annoying me. I guess I was trying to be too general
04:10:02 <fommil> I could just write the things out 7 times, damnit
04:10:24 <fommil> it feels like the Tuple package should probably provide something like replicate and replicateM
04:10:45 <dibblego> @type _7
04:10:47 <lambdabot> (Functor f, Field7 s t a b) => (a -> f b) -> s -> f t
04:11:00 <dibblego> that should be enough for anyone I reckon
04:11:16 <dibblego> you'll never ever see that type in scala :)
04:12:00 <fommil> where can I read more about that?
04:12:13 <dibblego> @hackage lens
04:12:13 <lambdabot> http://hackage.haskell.org/package/lens
04:13:51 <fommil> interesting
04:14:16 <fommil> Control.Lens.Tuple
04:14:38 <fommil> (I really need to get Emacs set up to do type search... hoogle is only good for signatures not the hackage docs)
04:16:11 <dibblego> > let m = _7 %~ (+1) in m ("abc", 2, 3, 4, 5, 6, 7)
04:16:14 <lambdabot>  ("abc",2,3,4,5,6,8)
04:18:41 <MarcelineVQ> hwhitchcraft
04:19:31 <dibblego> that would be a good package name
04:19:51 <merijn> Acme.Witchcraft and it just re-exports lens
04:21:04 <`Guest00000> %~
04:21:51 <fendor> @type (%~)
04:21:52 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
04:22:01 <John882> Hello, any website to solve haskell exercises and skill some haskell?
04:22:36 <ski> @where CIS194
04:22:36 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
04:22:37 <merijn> @where exercises
04:22:37 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems https://github.com/bitemyapp/learnhaskell http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
04:22:40 <MarcelineVQ> codingame is kind of fun and can be done in various languages
04:22:46 <ski> John882 : tried the CIS194 ?
04:27:43 <kakashiAL> how do they call the ":t" in haskell?
04:27:53 <kakashiAL> and is it a ghci thing only?
04:28:01 <merijn> kakashiAL: It's just a ghci command
04:28:39 <kakashiAL> merijn: are all :foo things ghci functions/operators ?
04:28:45 <ski> kakashiAL : it's short for `:type'
04:28:47 <merijn> kakashiAL: Yes
04:28:57 <kahlil29> If I have a timestamp with tz in the format of UTCTime, what's the easiest way to convert it into the format DD-MM-YYYY | HH : MM ? 
04:29:04 <kakashiAL> what is the haskell syntax for that?
04:29:06 <ski> it's an interactor command/directive
04:29:30 <merijn> kahlil29: The time library has a formatting/pretty printing module
04:29:42 <ski> kakashiAL : no syntax. it's not part of the language. it's part of the user interface of the interactor (GHCi)
04:29:47 <merijn> kahlil29: Data.Time.Format
04:34:12 <kakashiAL> ski: I mean is there a type function in haskell?:)
04:36:02 <ski> kakashiAL : what would it be useful for ? .. what would even be the type of it ?
04:36:44 <ski> (not rhetorical questions)
04:36:56 <kakashiAL> ski: to wrtie something like   foo x = if type x == "String" "its a string" else "its not a string" :D
04:39:18 <merijn> kakashiAL: That would be awful
04:39:26 <merijn> kakashiAL: That breaks all the nice properties we have
04:46:27 <exio4> merijn: well, we do have it...
04:46:48 <merijn> exio4: Not without incurring a Typeable constraint
04:47:04 <exio4> merijn: well, he didn't specify a type signature! 
04:47:27 <merijn> exio4: Also, I prefer not telling people that
04:48:00 <exio4> merijn: I know, I am just kidding, it's there but we pretty much agree it's only for ekmett-like code :)
04:49:11 * ski still wonders what type signature kakashiAL would like for that `type' function
04:49:45 <merijn> ugh...tasty's TestTree should be a monoid...
04:50:02 <merijn> Then I could use mappend/mconcat to combine all my test generating functions
04:53:29 <kahlil29> merijn, thanks :) 
04:55:03 <merijn> Generating a tree of tests seems to be a huge mess in general...
04:56:10 <angerman> has anyone ever tried to combine shelly and lucid to create static websites?
04:56:45 <saurabhnanda> MarcelineVQ: sorry, had to go for another meeting. Were you able to confirm the memory leak?
04:56:59 <merijn> I have a bunch of functions that take N parameters to generate a test and want to map those over lists of parameters to get a nicely labelled tree of tests and I keep inventing the same shitty recursion for it and haven't found a nice way to do it...
04:58:46 <saurabhnanda> MarcelineVQ: please direct-message me, if you've found something. I have to go again. Interviews at office today.
05:23:26 <merijn> How do people here deal with tiny, but useful snippets? I often find myself writing a generic function to solve an obnoxious problem that I feel might be useful to others, but publishing a separate package just for that seems...excessive?
05:24:06 <vogel> any admins here?
05:25:57 <MarcelineVQ> merijn: probably a blog post :>
05:26:22 <merijn> I should probably make a gist of it, like I do with all my other bits
05:37:45 <mrbackend> 1
05:38:28 <merijn> I wish we had mixfix...custom list types with more than two arguments are a pain in the neck to write out..
05:39:35 <mrbackend> @help
05:39:35 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:40:02 <mrbackend> >1
05:40:13 <maerwald> merijn: in javascript world they do publish libraries for a single function :o
05:40:18 <mrbackend> tell lambdabot help
05:40:32 <mrbackend> @tell lambdabot help
05:40:32 <lambdabot> Nice try ;)
05:40:48 <mrbackend> @tell hi
05:40:48 <lambdabot> What should I tell hi?
05:40:53 <mrbackend> @tell 1
05:40:53 <lambdabot> What should I tell 1?
05:40:58 <mrbackend> @run 1
05:41:00 <lambdabot>  1
05:41:10 <mrbackend> @help
05:41:10 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:41:19 <mrbackend> @list
05:41:19 <lambdabot> What module?  Try @listmodules for some ideas.
05:41:24 <mrbackend> @help list
05:41:24 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
05:41:24 <maerwald> mrbackend: for playing around please pm lambdabot
05:41:33 <mrbackend> lol sorry
05:41:35 <notshloub> > 1
05:41:38 <lambdabot>  1
05:41:51 <mrbackend> how?
05:43:14 <notshloub> How WhatsApp?
05:43:24 <notshloub> How what?*
05:44:09 <lyxia> mrbackend: //query lambdabot
05:44:22 <mrbackend> how to use lambdabot without having to type @run in front of everything
05:44:34 <lyxia> /query *
05:44:43 <notshloub> > and space
05:44:45 <lambdabot>  error:
05:44:46 <lambdabot>      • Couldn't match expected type ‘[Bool]’ with actual type ‘Doc’
05:44:46 <lambdabot>      • In the first argument of ‘and’, namely ‘space’
05:52:58 <mrbackend> It is not possible to use sequence on an infinite list, right? Just curious
05:54:01 <bxc> what's flavour du jour for command line parsing?
05:54:40 <ski> > (execWriter . sequence) [tell [n] | n <- [0 ..]]  -- mrbackend ?
05:54:42 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
05:55:24 <merijn> bxc: As in options/flags?
05:56:41 <merijn> Is there a convenient function to turn String into a ShowS?
05:58:06 <exio4> merijn: (++) ? 
05:58:12 <exio4> @type ShowS
05:58:13 <lambdabot> error: Data constructor not in scope: ShowS
05:58:20 <exio4> https://hackage.haskell.org/package/base-4.10.0.0/docs/Text-Show.html
05:58:24 <ski> @src ShowS
05:58:24 <lambdabot> type ShowS = String -> String
05:58:30 <merijn> exio4: That doesn't play nicely when I want to compose a few things but get a function as result
05:58:44 <exio4> merijn: what do you mean?
05:58:56 <exio4> @type ("dog"++) :: ShowS 
05:58:57 <lambdabot> ShowS
05:59:30 <merijn> oh, wait, I can just append the static bits and turn that in one go
05:59:32 <exio4> merijn: I often have a local s = (++) in local functions which use it heavily, but it's not that nice
05:59:56 <ski> @type showString
05:59:57 <lambdabot> String -> ShowS
06:00:27 <`Guest00000> how far can we decouple optimization from specification?
06:01:01 <merijn> ski: Yeah, I have "showString ({- several concats here -}) . show" now"
06:01:25 * ski thought optimization was by definition not part of specification
06:01:31 <ski> merijn : `Show' instances ?
06:01:44 <merijn> ski: ?
06:02:01 <ski> i mean, are you manually making such ?
06:02:02 <int-e> :t nub
06:02:03 <lambdabot> Eq a => [a] -> [a]
06:02:10 <ski> or just computing some custom strings ?
06:02:16 <merijn> ski: The latter
06:02:19 * ski nods
06:02:25 <exio4> merijn: for some reason, that doesn't compile properly in my ehad
06:02:30 <int-e> ski: sometimes, as in the case of nub, the specification may stand in the way of optimization.
06:02:34 <ski> @type showChar
06:02:35 <lambdabot> Char -> ShowS
06:02:54 <merijn> ski: I kept running into annoying code while trying to build trees of test/benchmarks for criterion/tasty
06:03:01 <int-e> (I'm referring to the Eq constraint)
06:03:06 <merijn> ski: So I decided to solve my problem once and for all
06:03:17 <`Guest00000> decouple optimization and specification in programming
06:03:19 <ski> int-e : please elaborate
06:03:20 <exio4> merijn: you're hiring someone? 
06:03:35 <merijn> exio4: Naah, I wrote a generic function that builds the tree for me
06:03:50 <int-e> ski: nub requires a quadratic number of comparisons in the worst case, where with Ord, n log n would suffice.
06:04:02 <mrbackend> ski, this is more what I was thinking: fmap (take 3) $ sequence [Just n | n <- [0 ..]]
06:04:11 <`Guest00000> do nothing except optimizing and specificating separately
06:04:49 <ski> oh, you mean adapting (restricting) the specification, in order to allow certain optimizations. ok
06:04:56 <merijn> exio4: Basically I tend to write functions that create a test/benchmark from N arguments and I usually want to supply multiple values for each argument
06:05:06 <`Guest00000> no
06:05:20 <merijn> exio4: So I wrote something where you just write up a list of labels + values and it generates a tree of tests from that + a function
06:05:56 <ski> mrbackend : won't work for `Maybe', no .. it can't know that every element is a `Just', it will search for the presence of a `Nothing', before daring to output a `Just' or `Nothing' result
06:06:14 <ski> mrbackend : so the answer is : it depends on the monad
06:07:51 <mrbackend> ski ah, thankls
06:08:02 <bxc> merijn: yeah what optparse-applicative/getopt do
06:08:12 <bxc> merijn: just wondering if there's new cool as I haven't looked for a bit
06:08:45 <ij> What's the opposite of -threaded?
06:09:12 <ski> mrbackend : .. in the case of `IO', there's a way to "cheat" a bit, using `unsafePerformIO' .. but any I/O exceptions thrown will be detached and possibly cause evaluation to error out later
06:10:29 <merijn> bxc: I think optparse-applicative is still the thing
06:25:00 <merijn> Any recommendations on how to linewrap types that are too long inside a GADT declaration?
06:25:09 <stevenxl> alright I'm in the monad transformers chapter. eventually I will write a web app in haskell!
06:25:20 <stevenxl> woops, wrong chan. 
06:25:27 <c_wraith> merijn: the same way you line-wrap any other wrong type signature?
06:25:58 <merijn> c_wraith: Normally I split every item onto a new line for functions, but that looks rather ugly in GADTSyntax
06:26:35 <c_wraith> it does?  huh.  I would have thought it would look basically the same
06:26:48 <merijn> c_wraith: My functions aren't already indented
06:27:00 <merijn> c_wraith: And are followed by a function body
06:28:03 <merijn> http://lpaste.net/358773 <- not aesthetically pleasing
06:30:44 <angerman> Feeling *really* adventurous? Maybe this is something for you http://hackage.mobilehaskell.org ... quite experimental though; as such, things might just not work.
06:38:09 <ventonegro> heh, https://www.mobilehaskell.org/ redirects to https://www.agrar-immo.de/Home/
06:38:54 <angerman> yea. don't try that :p
06:39:21 <angerman> ventonegro: good idea, I'll see if I can add a different redirect :)
06:40:59 <Psybur> Good morning raskells
06:41:24 <qwz> Morning Psybur
06:44:22 <angerman> ventonegro: betteR?
06:45:02 <ventonegro> angerman: Still the same
06:45:11 <angerman> ventonegro: probably caching...
06:45:22 <angerman> ventonegro: try a different browser? :-)
06:45:23 <Psybur> This function isn't tail recursive right: f [] = return (); f (x:xs) = do a <- b; f xs
06:45:28 <lunaris> Anyone here I can ask about writing a GHC typechecker/core plugin for discharging/satisfying custom type classes?
06:45:47 <angerman> ventonegro: thanks for reporting though.
06:46:00 <ventonegro> angerman: Yeah, now it's better :)
06:46:41 <Psybur> Since the a is going to be >>'d with f xs
06:46:47 <Psybur> Thats how that works?
06:48:38 <brynedwards> lunaris: Maybe try #ghc ? Or failing that one of the mailing lists
06:50:04 <lunaris> brynedwards: Ah of course; thanks.
06:50:51 <merijn> Psybur: Tail recursion is not as relevant in Haskell as many people think
06:51:12 <Psybur> merijn, it doesnt help keep the stack from growing?
06:51:23 <merijn> Psybur: (GHC) Haskell doesn't *have* a function stack
06:51:55 <Solidak> Hey guys. Sorry for the super noobish question, but what's a good source to start with Haskell?
06:55:57 <merijn> I don't suppose Tasty has a way to run my tests in parallel?
06:56:21 <brynedwards> Solidak: https://github.com/bitemyapp/learnhaskell
06:56:25 <merijn> Solidak: CIS194, Haskell Book, or RIchard Bird's book, probably
06:57:46 <Solidak> THANK!
06:57:48 <Solidak> THANKS!
06:58:26 <angerman> ventonegro: thanks again :-)
06:58:32 <ski> @where CIS194
06:58:32 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
06:58:42 <brynedwards> @where learnhaskell
06:58:42 <lambdabot> https://github.com/bitemyapp/learnhaskell
06:58:56 <ski> merijn : perhaps you could factor out the differing parts ?
06:59:04 <ski> Psybur : depends on the monad
06:59:05 <brynedwards> I never think of that
06:59:17 <Psybur> ski, rwst
06:59:43 <merijn> ski: hmm?
06:59:47 <merijn> ski: Of what?
07:02:57 <mbw> I have a question about "juggling modules" in a project. From what I have seen, there are proponents of sticking data type definitions in a .Types module, and exposing functions over that type (the algebra, if you will) in a dedicated module. On the other hand, some people like to define modules Foo (<-- api) and Internal.Foo (<-- e.g. for testing purposes). Furthermore, the Types module approach is claimed 
07:03:03 <mbw> to help avoid cyclic dependencies, whereas using Internal modules can help abstraction. So, are there any recommendations, however opinionated they may be?
07:03:54 <merijn> mbw: People don't use a .Types because they like it. They do so because they have a bunch of mutually recursive datatypes that can't be split into separate files since each file would have to import all the others
07:04:13 <ski> merijn : i was thinking `Params :: String -> Foo a -> Params l -> Params (a : l)' (deleting `DerivedParams') where `data Foo b where Plain :: Show b => [b] -> Foo b; Derived :: Show a => (a -> b) -> [a] -> Foo b'
07:04:14 <merijn> mbw: I end up throwing everything in a single .Types module and I freaking hate it
07:04:52 <merijn> ski: I ended up ditching it and keeping only the derive case
07:05:07 <merijn> ski: It's turned out to be quite elegant to use: https://gist.github.com/merijn/6a0126db702b3d109e508f442581eec9
07:05:14 <ski> merijn : perhaps that's not what you'd like to do. just mentioning it as an option
07:05:43 <mbw> merijn: Indeed, having this one .Types sin bin is making a mess of things. Is there a practical difference between having Types.Foo/Types.Bar or Foo.Types/Bar.Types?
07:06:38 <mbw> merijn: I would think that with the former, you can choose the "import granularity" more easily...
07:06:59 <saurabhnanda> mbw: after some experimentation I've settled with ModuleA.Types and standardized it across my project. It prevents cyclic references very easily.
07:07:04 <mbw> merijn: If you have .Types module that reexports the other ones.
07:07:35 <merijn> ski: Now I can just do "buildTree Test.Tasty.testGroup "tree name" testGenerator $ Param "foo" id [1..10] (Param "bar" (enumFromTo 0) [10,100,1000] (Param "xyzzy" id [True, Bar] None)))" (assuming "testGenerator :: Int -> [Int] -> Bool -> String -> TestTree" and get a nice labelled tree of tests
07:07:36 <ski> Psybur : well, then it also depends on the `m' you use in `RWST r w s m a' ..
07:07:44 <Psybur> IO
07:08:10 <ski> Psybur : then no
07:08:12 <merijn> ski: Should be able to simplify my criterion benchmark producers this way too :)
07:08:32 <mbw> saurabhnanda: Do you still maintain export lists?
07:08:45 <saurabhnanda> mbw: didn't understand that question.
07:08:56 <merijn> mbw: I use explicit export lists for all public modules, but I don't for internal ones.
07:08:57 <saurabhnanda> mbw: ModuleA import ModulaA.Types and re-exports it.
07:09:04 <ski> Psybur : `(>>=)' for `RWST' ends with a `return', not a continuation call. if this `return' is `IO', then the continuation isn't tail-called
07:09:47 <mbw> merijn: So you have internal modules as well as a type module? How do they play together?
07:09:59 <ski> Psybur : compare with how `sequence' for `IO' isn't tail-recursive
07:10:01 <merijn> mbw: It Depends
07:10:11 <mbw> saurabhnanda: Ah ok.
07:10:28 <merijn> mbw: I just do whatever seems most convenient/usable at the time
07:11:06 <ski> merijn : perhaps having `Param' be infix would look nicer
07:11:14 <merijn> ski: Thought about it
07:11:25 <merijn> ski: But it doesn't play nice with the fact that it takes multiple args
07:11:28 <mbw> merijn: Albeit you're most probably way ahead of me in terms of experience, so I can't trust myself making the intuitive approach work just yet :/
07:11:40 <ski> tuple, or otherwise pack ?
07:11:52 <merijn> ski: That makes the function application annoying again
07:12:04 <saurabhnanda> mbw: the ModuleA.Types module **generally** exports all its types and constructors. Trying to hide constructors in my experience, is more trouble than it is worth. I have realised that FP doesn't really have the concept of data-hiding and all proposed solutions are half-baked hacks around this. So, for **most** cases I don't worry about hiding constructors. It is possible in Haskell because refactoring is easy. Even if a data-type's 
07:12:04 <saurabhnanda> internals change, the corresponding refactor is tedious, by very easy to do.
07:12:12 <ski> merijn : it does ?
07:12:46 <ski> i wouldn't have thought that uncurrying `Param' would affect how `testGenerator' would have to be phrased, there
07:12:46 <merijn> ski: Actually Right now I'm using local definitions of the form "foo = Param "foo" id [1,2,3,4,5]", "bar = Param "bar (enumFromTo 0) [10,100,1000]" and doing "foo . bar $ None" when using it
07:13:01 <merijn> ski: I mean that buildTree becomes messier :p
07:13:06 <ski> mhm
07:13:19 <ski> slightly messier, i'd say :)
07:14:19 * hackagebot schematic 0.3.0.0 – JSON-biased spec and validation tool – https://hackage.haskell.org/package/schematic
07:15:10 <merijn> ski: At any rate, it's much better than the hacky shit I was doing before :P
07:15:40 * ski smiles
07:16:33 <merijn> ski: Just look at this in-place recursive approach I took before: https://github.com/merijn/broadcast-chan/blob/master/benchmarks/Channels.hs#L200-L224 ugh
07:16:39 <mbw> saurabhnanda: So if I get it correctly, you use the .Types module if only the types need to be visible (to avoid a cycle), and import ModuleA if you actually want to work with them? I'm asking since if you expose everything from both ModuleA and ModuleA.Types, there has to be a systematic approach to when to import which
07:17:02 <saurabhnanda> mbw:  just what you said.
07:17:26 <saurabhnanda> mbw: it's down to muscle memory now. import ModuleA => shit, cyclic imports => import ModuleA.Types
07:18:05 <ski> merijn : in any case, it smells `Coyoneda'ish
07:18:24 <shapr> GOOD MORNING!
07:18:30 <shapr> It's a great day to write Haskell code!
07:18:31 <ski> (`DerivedParams'/`Param', i.e.)
07:18:38 <c_wraith> shapr: are you sure there's such a thing as a good morning?
07:18:49 <c_wraith> shapr: it is a great day to write haskell code, though.
07:18:50 <ski> mod gorgon, herr shapr
07:18:55 <shapr> c_wraith: not unless it was preceded by at least eight hours of sleep
07:19:16 <shapr> ski: god morgon! dags att KODA!
07:19:42 <c_wraith> shapr: yesterday I triumphantly re-understood code I wrote years ago! It was amazing.
07:19:47 <saurabhnanda> mbw: if that still doesn't fix it, then it points to the **functions** in moduleA need **functions** in moduleB recursively, and that points to either: (a) tightly coupled stuff that ideally should be in the same module, or (b) some common utility function which may be required elsewhere and should be hived off to a third module.
07:19:53 <shapr> c_wraith: that's great!
07:20:11 <merijn> ski: Might be
07:20:30 <merijn> ski: But this is simple and understandable, so I'm not gonna category it up
07:20:35 * ski nods
07:20:39 <ski> just saying :)
07:20:56 <benen> hey, is there a way to add 'deriving Generic' to a libraries data types without forking and manually doing it? I can have standalone derive generics but that only works for datatypes with exported constructors?
07:21:17 <c_wraith> benen: there is not.
07:21:51 * ski was pondering a kind of two-dimensional associativity, the other day ..
07:22:11 <benen> c_wraith: ok thanks 
07:22:19 <c_wraith> benen: it is intended that you can't have a Generic implementation for types without exposed constructors, because using Generic is equivalent to introspecting the constructors and using them.
07:23:40 <mnoonan> ski: interchange? https://en.wikipedia.org/wiki/2-category
07:24:10 <mbw> saurabhnanda: How much do you stuff into one module anyways? I imagine that if you have ModuleA and ModuleA.Types instead of ModuleA and Types.ModuleA, you will have a lot of directories with only one file in them. Unless you don't, because ModuleA is large or the project is small.
07:24:27 <ski> mnoonan : not really. more of a geometric concept, perhaps one could say
07:26:03 <mnoonan> interchange is pretty geometric imo.. something like "no matter what order you apply this gluing pattern, you get the same result"
07:26:06 <saurabhnanda> mbw: I have a lot of directories with one file. Don't know if there is a downside to that. From a conceptual standpoint it makes sense to have ModuleA.Types , ModuleA.Internal, ModuleA.TH. Have you upon a real downside of this structure (please do share -- we're going to hit it pretty soon, if there is something!)
07:26:25 <ski> mnoonan : consider a binary tree. extend the leaves so that they all reach down to a base line, exhibiting the leaf ordering. now replace by ternary trees, each branch looking like a "tetrahedron angle" (think carbohydrates, like metane). extend leaves down to a base *plane*
07:26:29 <saurabhnanda> mbw: project is large, with a **lot** of modules.
07:27:11 <ski> mnoonan : this is too "wiggly", there's no stricture to the leaves, we can move them around each other (well, introducing braids might be somewhat better ?)
07:28:17 <ski> mnoonan : so, i also add *surfaces* inbetween the branch lines. those surfaces that connect branch lines going to leaves will also extend down to the base plane, as edges between the leaves
07:28:44 <mnoonan> ski: gotta run to a meeting, let's suspend this computation
07:28:54 <ski> mnoonan : of course, in general i don't just want "tetrahedron-ternary" branches ..
07:30:53 <AWizzArd> Is there a function that composes certain boolean functions into one and-ing all conditions?  Or is an explicit lambda  \x -> f x && g x   already the idiomatic way to do this?
07:31:15 <AWizzArd> I guess I am asking if the explicit use of x can go away.
07:31:21 <mbw> saurabhnanda: I can't really say, sorry. Especially since I didn't expect this kind of granularity after all. For instance, what is the reason of splitting of template haskell modules? Also, what goes inside the .Internals module? :/
07:32:01 <ertes-w> AWizzArd:
07:32:03 <ertes-w> :t liftA2 (&&)
07:32:05 <lambdabot> Applicative f => f Bool -> f Bool -> f Bool
07:32:22 <ertes-w> AWizzArd: now let (f = (->) a)
07:32:44 <ski> AWizzArd : `all' ?
07:32:55 <AWizzArd> ski: not really.
07:32:55 <ski> hm
07:33:19 <ertes-w> > let (<&&>) = liftA2 (&&) in (isAlpha <&&> isUpper) 'c'
07:33:21 <lambdabot>  False
07:33:24 <ertes-w> > let (<&&>) = liftA2 (&&) in (isAlpha <&&> isUpper) 'C'
07:33:26 <lambdabot>  True
07:34:01 <AWizzArd> ski: we can’t compose those guys, that is feed the output of g into f. Otherwise    all (f . g)   would look good, but is not doing the job.
07:34:15 <mbw> saurabhnanda: Of course, in the end a lot will boil down to personal taste. I remember reading an SO answer of Norman Ramsay which states that even with 100-200 modules he wouldn't make modules hierarchical...
07:34:23 <saurabhnanda> mbw: don't worry about it if you don't see the need for it. Just keeps Types separate for every module for now individually. Before the project gets larger figure out a common pattern and ensure that is enforced across the project and team. The last part is more important.
07:34:39 <ski> "feed the output of g into f" isn't what `\x -> f x && g x' suggested ?
07:34:52 <ski> (different `f' and `g' ?)
07:35:15 <merijn> AWizzArd: How many conditions have you got?
07:35:47 <AWizzArd> merijn: two
07:35:55 <mbw> saurabhnanda: Still, the difference between .Types and .Internal (assuming a top-level ModuleA, without a dot, exists) would interest me :)
07:36:25 <ski> then i think `liftA2' is probably the nicest
07:36:45 <ski> (in case you don't like the pointful)
07:36:46 <AWizzArd> Yeah.
07:36:58 <saurabhnanda> mbw: my opinion, keep that interest aside, and ship some code. I get a better kick out of shipping working code than anything else!
07:37:11 <AWizzArd> It’s not so much about like/dislike, I was just wondering if there is some nice alternative way to do this.
07:38:07 <ski> one can do it like `uncurry (&&) . (f &&& g)' .. but that's not that nice
07:39:05 <mbw> saurabhnanda: Alright then. Still, thanks for your input, much appreciated.
07:50:02 <mantasg> Hi guys. I have a list of Hashables. What is the best way to define Hashable instance for that list?
07:52:01 <mnoonan> mantasg: is this Data.Hashable? it seems to already have an Hashable a => Hashable [a] instance..
07:54:11 <mantasg> Darn! Of course.. silly me. Thanks  mnoonan!
07:55:40 * hackagebot testCom 0.2.0 – Write your tests in comments – https://hackage.haskell.org/package/testCom
08:27:38 <merijn> Is there a function that turns Int into a formatted string? i.e. "1e6" becomes "1,000,000" as opposed to "1000000"?\
08:29:36 <[exa]> merijn: I'd reach to something locale-relevant, but not sure
08:30:02 <merijn> [exa]: Don't really care about locale, etc.
08:30:08 <merijn> I just want something I can personally parse
08:31:41 <merijn> anyway, time to go home I'll sort it out later
08:33:43 <John882> Hello guys when i do define functions is the type foldable optional?
08:34:37 <ski> `Foldable' is a type class
08:34:47 <ski> define which functions ?
08:35:07 <John882> https://dpaste.de/aykh
08:35:26 <John882> I've written some code and pasted there
08:36:23 <John882> misstype btw : ghy = ghc   done with :type
08:39:16 <mnoonan> John882: the type you gave is not the most general possible type for the function you wrote. the version ghc inferred was more general, hence the Foldable constraint.
08:39:39 <Psybur> How would I construct a RWST with an env? Cant figure out how to set the reader env. So far I have let x = do put 1;lift $ return () :: RWST Int () Int IO ()
08:39:54 <ski> John882 : `foldr' and `foldl' work on lists. however, they're more general than that, and also work for other instances of `Foldable'
08:40:17 <Psybur> Trying to figure out how to turn my rwst creation function into a tail recursive function. Which means I have to construct an rwst each frame and pass it to the next, instead of binding all of them together
08:40:21 <ski> John882 : however, in your case you probably don't need to bother about this extra bit of generality
08:41:12 <ski> Psybur : use `ask' and `local' as usual ?
08:42:28 <John882> Thanks
08:42:33 <ski> Psybur : .. i suppose you could use `ContT' (or `Codensity') for tail calls ?
08:43:07 <mnoonan> Psybur: are you really sure you need to ensure tail calls? something smells a little off about this..
08:43:26 <ski> they're doing I/O
08:44:04 <Psybur> mnoonan, this is going to eat up a lot of memory with a large input right https://pastebin.com/CcdbwG0Y
08:46:25 <ski> Psybur : `ContT () (RWST Env (S.Seq String) ([Order],[Trade]) IO) ()' ?
08:47:22 <Psybur> ski, so theres no way to create an initial rwst with my reader env and initial state and then just make that function accept another rwst and >> them together?
08:47:23 <maerwald> mh, considering to write a pastebin service in haskell, rust or Go. Why should I pick haskell? Maybe to learn a proper http library instead of frameworks
08:48:26 <ski> @unmtl ContT o (RWST r w s m) a
08:48:26 <lambdabot> (a -> r -> s -> m (o, s, w)) -> r -> s -> m (o, s, w)
08:48:27 <ski> @unmtl RWST r w s (ContT o m) a
08:48:27 <lambdabot> r -> s -> (a -> s -> w -> m o) -> m o
08:48:39 <ski> hm, actually try the latter instead
08:50:14 <ski> Psybur : not sure what you mean by "create an initial rwst", nor by "make that function accept another rwst and >> them together"
08:51:16 <Psybur> ski, so in order to make that function tail recursive, I have to pass in an existing rwst and then combine it with the next computation. Problem is how do I get the initial rwst
08:53:42 <ski> Psybur : if by "pass in an existing rwst" you mean a continuation, try initializing using `return'
08:53:57 <ski> if you don't mean this, then clarify
09:06:11 <Psybur> ski, return () compiled. But now my app just says Killed a little while into execution heh
09:07:07 <Psybur> ski, see any problems? https://pastebin.com/Nfv5xx5V
09:10:12 <ski> that uses `(>>)' left-associatively (in the accumulator)
09:10:25 <ski> Psybur : did you try `RWST r w s (ContT o m) a' yet ?
09:10:57 <Psybur> ski, no. Not really wrapping my head around it D;
09:11:22 <ski> (just replace `IO' with `ContT () IO', at <https://pastebin.com/CcdbwG0Y>)
09:12:03 <Psybur> And thatll magically get rid of the chaining of >> ? Not really understanding how :D
09:12:07 <ski> then use `runCont' (after `runRWST'), passing `return' as argument, when you finally call this from `IO'
09:12:27 <ski> er, `runContT', rather than `runCont'
09:12:29 <hexagoxel> why do you care about tail-recursiveness?
09:12:55 <Psybur> hexagoxel, worried about the memory use
09:13:07 <Psybur> This is being run on a large file
09:13:58 <ski> @type \act r w -> runContT (runRWST act r s) return
09:13:59 <lambdabot> Monad m => RWST r w Expr (ContT (a, Expr, w) m) a -> r -> p -> m (a, Expr, w)
09:14:10 <hexagoxel> but tail recursiveness in haskell is orthogonal to memory usage, due to laziness.
09:14:24 <ski> `IO' is not lazy (unless `unsafeInterleaveIO')
09:15:26 <monochrom> Ah but this is RWST tail call not IO tail call.
09:16:11 <monochrom> And more refinedly, this is using the "local" method.
09:16:39 <monochrom> But anyway I smell a deep pile of XYZ problems so I don't want to go into it.
09:17:22 <hexagoxel> monochrom: sure feels that way :/
09:17:33 <Psybur> Hmm, maybe the new way I posted on pastebin will work. Im getting killed again with the old version (that used to work not sure what happened :D)
09:17:58 <hexagoxel> Psybur: the tail recursive version will walk through the whole input list before returning any action, will it not? is that not the opposite of what you want?
09:18:58 <Psybur> hexagoxel, you make a good point. No I dont want to collect everything and dump it at the end
09:19:23 <Psybur> I want to evaluate each window as its encountered
09:22:26 <hexagoxel> so you want exactly runFirst >>= recurse, regardless of "tail-recursive" property.
09:22:41 <ski> monochrom : well, i did suggest `ContT'
09:22:46 <ski> monochrom : `local' where ?
09:25:10 <ski> (note that in `runState (runFirst >>= recurse) s0 = let (a,s1) = runState runFirst s0 in runState (recurse a) s1', the `recurse' call is arguably a tail call)
09:26:29 <hexagoxel> (no?)
09:26:57 <hexagoxel> this step basically replaced `runFirst >>= recurse` with `recurse a`
09:28:17 <hexagoxel> perhaps i should stop arguing this at all until somebody gives me a sensible definition of tail-recursiveness in haskell, or points me to one.
09:28:59 <Psybur> Hmm I think the way I have it is better than the tail recursive version. Not getting killed now :D.
09:30:36 * ski would like Psybur to try `ContT' :/
09:30:58 <Psybur> Ok Ill give it a whirl
09:31:17 <ski> .. anyway, i have to leave presently
09:32:03 <bsima> why can't I do `data Whatever = (Int, Text)`? GHC says "illegal binding of built-in syntax: (,)"
09:32:59 <pavonia> You want "type Whatever = ...", data defines new data constructors
09:35:19 <bsima> ok `type` basically creates an alias?
09:35:22 <bsima> thanks pavonia 
09:35:46 <pavonia> Yes
09:39:21 <humanoyd> What is the most widely used matrix package for Haskell?
09:39:22 <hexagoxel> (when you move something into an accumulator to make stuff "tail-recursive", but don't force the accumulator, then the behaviour won't change at all, due to laziness in the accumulator. and this stands regardless of the type of the accumulator (e.g. if it happens to be an IO()) - the non-laziness of the _execution_ of the IO won't matter.)
09:49:03 <John882> j
09:54:11 <shapr> k
10:13:25 <kuribas> the binary library supposes that the data is streamed.  Is there a declarative binary parser that allows for offsets, lengths, sections, ...?
10:22:16 <ertes-w> humanoyd: depending on the use case hmatrix and 'linear' come to mind
10:23:46 <Psybur> hexagoxel, how do you 'force' the accumulator? Using seq?
10:24:27 <Psybur> Or is this $!
10:26:32 <humanoyd> ertes-w: use case is implementing simple machine learning algorithms ... right now I'm using the `Matrix` type from the `statistics` package
10:27:05 <johnw> @src $!
10:27:05 <lambdabot> f $! x = x `seq` f x
10:36:33 <ertes-w> humanoyd: like linear regression or something fancier?
10:40:50 <humanoyd> ertes-w: yeah, right now it's pretty much linear regression, transforming inputs etc ... nothing fancy
10:42:12 <ertes-w> humanoyd: in that case both hmatrix and statistics should have everything you need
10:44:37 <hexfive> i used to think haskell was pretty cool but a novelty. now im writing go at my day job and i find myself muttering a constant stream of 'ugh, this shouldn't be representible by the type system; why can't i just use a monad; i need my abstract data types; wtf why does the language let you shoot yourself like this; oh no, this is just 'how it is' in normal language land' :(
10:45:51 <sm> sorry hexfive
10:45:58 <hexfive> you've ruined me haskell
10:47:17 <mizu_no_oto> It's the one danger of learning new languages
10:47:25 <maerwald> hexfive: what language
10:47:29 <hexfive> Go
10:47:38 <humanoyd> ertes-w: Thanks!
10:47:40 <maerwald> well, that's not so bad
10:48:36 <mizu_no_oto> I'm not sure I've ever heard anything good about Go from anyone that does Haskell
10:49:02 <hexagoxel> Psybur: yes, there are multiple ways, including seq, ($!), force, ($!!), evaluate
10:49:27 <Psybur> Using $! (m >> m') still resulted in getting Killed
10:49:33 <maerwald> go routines are nice and integrate very well in the language, no huge framework or DSL needed. And the same goes for web dev. People don't use huge frameworks, but small libraries and "compose" them
10:49:59 <maerwald> but the language maintainers make a lot of weird decisions just to keep the compiler supposedly "simple"
10:50:22 <mizu_no_oto> Like having generics only for the standard library?
10:50:35 <maerwald> I think the lack of ADTs had a similar reason
10:50:44 <Psybur> Im thinking that the recursion as it is in the version of my code that does not get killed is not the problem. Things come to a crawl when the window size in the sliding window on these 50 mb files grows
10:51:47 <hexagoxel> Psybur: did you observe memory leakage in the non-tail-recursive version? (i have missed it if you mentioned it above)
10:52:11 <maerwald> mizu_no_oto: but it's a simple language, for the most part, no feature creep
10:52:15 <maerwald> which is a plus
10:53:37 <maerwald> simple, effective, mostly boring
10:53:46 <Psybur> hexagoxel, currently profiling using +RTS -hc -p
10:53:48 <Psybur> Lets see
10:56:29 <hexagoxel> Psybur: also, i just notice that you put "remainingOrders ++ newOrders" (in both versions)
10:57:36 <hexagoxel> which will likely make it O(n²)
10:58:33 <Psybur> hexagoxel, here's a bigger picture of whats going on https://github.com/jrciii/money-machine/blob/master/src/MoneyMachine/Backtest.hs
10:59:03 <Psybur> I think the most time gets spent in "lines"
11:02:23 <tabaqui> I stuck with lazy IO (I'm not sure what it is, but it issues IO and it is lazy)
11:02:32 <tabaqui> forever $ runExceptT $ function
11:02:59 <tabaqui> *forever $ runExceptT $ liftIO function
11:03:19 <tabaqui> **forever $ runExceptT $ ExceptT function
11:03:20 <tabaqui> damn
11:03:24 <tabaqui> okay, last is correct
11:03:35 <tabaqui> well, function returns Left SomeException
11:03:43 <tabaqui> and forever loop have to stop
11:04:16 <tabaqui> but it doesn't happen if I don't (ExceptT $ function >>= print)
11:04:41 <tabaqui> what can help me to force evaluation here?
11:05:46 <lyxia> _what_ doesn't happen if you don't _what_?
11:07:58 <tabaqui> I have func :: ExceptT SomeException IO ()
11:08:04 <tabaqui> and forever $ runExceptT $ func
11:08:12 <t7> whats this called again:   (A = B) -> (f A = f B)
11:08:36 <tabaqui> func reads from network socket, does some logic and returns Either
11:09:05 <tabaqui> when it returns Left, my forever loop should stop, but this doesn't happen
11:09:17 <tabaqui> if I don't force it by printing
11:10:53 <lyxia> tabaqui: can you paste some of your code
11:11:25 <tabaqui> one minute
11:12:42 <tabaqui> xmao, it depends on forever/runExceptT order
11:12:47 <tabaqui> I'll prepare the paste
11:13:24 <ertes-w> t7: not sure if it has a well-known name, but i call it the congruence law for equality, because it's called 'cong' in agda
11:13:59 <lyxia> tabaqui: yes order matters
11:15:03 <ertes-w> t7: in less general terms you could say that all functions respect equality
11:15:16 <johnw> tabaqui: you need runExceptT $ forever $ ..., not forever $ runExceptT $ ...
11:15:26 <johnw> otherwise, it will not stop when a Left value is encountered
11:15:55 <johnw> ah I see, you realized this
11:16:24 <ertes-w> s/less general/less specific/
11:16:38 <tabaqui> ah, yeah, because IO Left is not a reason to stop, but ExceptT Left is the one
11:16:56 <tabaqui> thanks to all
11:18:16 <ertes-w> t7: substitution law is also a fitting term
11:19:36 <hexagoxel> Psybur: you use (++) to append to large lists _everywhere_. it is possibly not the cause of memory leaks, but it likely will tank the performance anyway.
11:20:23 <Psybur> hexagoxel, so I should perhaps use seq?
11:20:25 <hexagoxel> Psybur: runBacktest looks like it is a sequence_
11:20:27 <Psybur> Sequence
11:21:35 <hexagoxel> checkOpenOrders seems to be `partitionEithers`, and should be a foldr not a foldl
11:22:31 <hexagoxel> and yes, you e.g. never force the `trades` values. and the other stuff only if the strategy forces it, i don't know if it does.
11:23:02 <hexagoxel> so you probably need to do some form of forcing.
11:23:13 <hexagoxel> note that WHNF on lists does not mean too much.
11:24:47 <Psybur> Ill try using sequences and see if that helps
11:25:37 <hexagoxel> (`sequence_` was a different topic; nothing to do with forcing)
11:25:39 <hexagoxel> :t sequence_
11:25:41 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
11:26:02 <kuribas> what's the standard way to use default parameters?
11:27:11 <kuribas> So far the best way seems to be the Endo Monoid...
11:27:48 <johnw> it's funny that we use the term leak, when none of the typical memory issues are leaks at all
11:28:21 <Psybur> hexagoxel, so when you said forcing the lists, you didnt mean Sequence. Ok, was thinking you mean that since Sequence is strict. But its strict in the sense that it only does WHNF?
11:28:41 <johnw> it's mainly just "GC too long delayed", because a thunk or a discriminee is still referencing data so it can't be freed yet
11:34:43 <Psybur> hexagoxel, and thanks for the tip on partitionEithers, thats a useful func
11:36:17 <Psybur> How long have you guys been programming in haskell?
11:36:53 <rom1504> there are 1634 persons here
11:37:25 <Psybur> The guys here that seem to know everything, how long have you been programming in haskell? :D
11:42:28 <parsnip> less than 27 years
11:42:34 <Psybur> o;
11:43:02 <hexagoxel> ~6 years
11:44:30 <geekosaur> ~10y
11:53:05 <k0001> Folks, is anybody here interested in a full-time DevOps job involving Nix in a functional programming team using a lot of Haskell? Ideally in San Francisco, but remote might be OK for the right person. Reach out to me if you are interested :)
11:58:08 <maerwald> 30 years
11:59:43 <shapr> k0001: ah that was your tweet
11:59:54 <shapr> k0001: have you asked on #nixos?
12:01:32 <k0001> shapr: yes, I just asked there as well :)
12:02:56 <shapr> In other news, after dealing with C# extension methods, Haskell typeclasses are SO WONDERFUL
12:08:22 <maerwald> hmm
12:08:53 <maerwald> I should try C# one day, but it seems boring
12:09:30 <Profpatsch> If I have (IO (Either Foo (SomeFunctor a))), is it okay to do (fmap.fmap.fmap) aToB thingy?
12:09:31 <shapr> best I can say is that it's not terrible, and that's only because of Erik Meijer's influence, LINQ is fun.
12:09:46 <Profpatsch> Or would you recommend something different?
12:09:52 <maerwald> when it's about free time, I'd probably try D instead
12:09:59 <Profpatsch> How would I solve that with (micro)lens?
12:10:01 <shapr> maerwald: rust?
12:10:06 <maerwald> I already know rust
12:10:14 <shapr> oh, how would you compare Haskell and Rust?
12:10:21 <maerwald> I wouldn't :P
12:10:25 <shapr> ok then
12:10:34 <maerwald> no idea how to start, because everything is different?
12:10:52 <shapr> huh ok
12:11:14 <maerwald> practically speaking, writing bindings is more tricky though
12:11:24 <shapr> inline-c ?
12:11:50 <maerwald> well, the problem is not calling C functions, but mapping that to the memory safety model of rust
12:12:00 <maerwald> either you just write a lot of unsafe functions
12:12:09 <maerwald> or you try to make it safe, apply lifetimes and so on
12:12:12 <maerwald> then it gets tricky
12:12:21 <maerwald> gtk is weird in rust
12:13:17 <maerwald> callback functions have static lifetime (as in: longer than main), instead of widget-lifetime, because the latter is somewhat harder to do
12:13:44 <maerwald> which forces you to use interior mutability
12:13:48 <maerwald> and then it gets all hairy
12:14:37 <Profpatsch> gtk is weird everywhere.
12:14:43 <maerwald> it's nice in python
12:15:48 <Profpatsch> Where you have the GIL interfering with the GTK thread …
12:15:52 <maerwald> also, lifetimes can change the semantics of a GTK program without it being a compile time error :D
12:16:03 <maerwald> as in: widgets disappear, because the deconstructor is called, oops
12:16:07 <maerwald> and that is all perfectly vali
12:16:08 <maerwald> d
12:16:35 <maerwald> that's also a nice "wat" effect in rust gtk programming
12:19:41 <shapr> sounds like I should tick to Haskell
12:19:52 <maerwald> shapr: error handling is superior imo
12:20:07 <shapr> maerwald: how so?
12:20:14 <maerwald> and dealing with multi-threaded problems too via Sync trait and so on
12:20:18 <maerwald> shapr: no exceptions
12:21:19 <maerwald> but you can't copy paste those concepts, you'd probably have to import more than that
12:21:34 <maerwald> e.g. signals not being exceptions
12:22:02 <gridaphobe> in template-haskell, can `reify` not see things that were defined in the current splice?
12:23:08 <maerwald> shapr: as long as you are dealing with native libraries, it's really nice imo. But that's kinda hard to do. E.g. there is no png library that can compare with the speed of libpng :>
12:23:29 <maerwald> those have decades of optimization behind them
12:26:02 <Profpatsch> What’s a nice way to deal with Functors nested multiple layers?
12:26:13 <Profpatsch> IO (Either (MyFunctor a))
12:26:26 <Profpatsch> fmap.fmap.fmap is a bit odd.
12:26:41 <Profpatsch> cadddr
12:26:43 <Profpatsch> :)
12:26:47 <maerwald> fmap `fmap` fmap `fmap` fmap
12:26:48 <maerwald> xD
12:26:55 <Profpatsch> Aaaaaah. :D
12:27:01 <maerwald> there you go
12:27:31 <Profpatsch> fffmap
12:27:46 <Profpatsch> pure purer purerer
12:28:27 <maerwald> https://hackage.haskell.org/package/definitive-base-2.3/docs/Algebra-Functor.html#v:map3 lol
12:28:51 <maerwald> the definition is funny too
12:29:27 <Profpatsch> Yeah, map = fmap
12:29:39 <maerwald> map3 = fmap fmap (fmap fmap fmap)
12:29:50 <Profpatsch> And then used like above, but no infix.
12:29:54 <maerwald> yeah
12:30:01 <maerwald> it's clearer that way
12:30:02 <maerwald> xD
12:30:05 <Profpatsch> right
12:31:40 <maerwald> there's probably a lens way, but is it worth it?
12:31:47 <Profpatsch> Hm, not really.
12:32:14 <maerwald> I find "fmap . fmap" actually quite idiomatic
12:32:27 <maerwald> I think most haskellers understand it, even if they see it for the first time
12:35:09 <Profpatsch> Well, once they :t it into ghci they do.
12:35:38 <maerwald> the lens alternative probably has Genkifunctors in the type signature
12:36:05 <maerwald> or doesn't load, because you are missing 30 GHC extensions
12:40:20 <crucify_me> > reverseTuple = uncurry (flip (,))
12:40:22 <lambdabot>  <hint>:1:14: error:
12:40:23 <lambdabot>      parse error on input ‘=’
12:40:23 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
12:40:38 <crucify_me> > let reverseTuple = uncurry (flip (,))
12:40:40 <lambdabot>  <no location info>: error:
12:40:40 <lambdabot>      not an expression: ‘let reverseTuple = uncurry (flip (,))’
12:41:04 <crucify_me> hi why does this function need uncurry ^
12:41:05 <maerwald> @define reverseTuple = uncurry (flip (,))
12:41:06 <lambdabot>  Defined.
12:41:10 <maerwald> :t reverseTuple
12:41:12 <lambdabot> (b, a) -> (a, b)
12:41:32 <maerwald> :t flip (,)
12:41:34 <lambdabot> b -> a -> (a, b)
12:41:40 <maerwald> because of that
12:41:52 <crucify_me> oh so its because of how flip is written. 
12:42:00 <cocreature> :t (,)
12:42:01 <lambdabot> a -> b -> (a, b)
12:42:04 <maerwald> it's needlessly tricky pointfree style
12:42:04 <cocreature> :t flip (,)
12:42:06 <lambdabot> b -> a -> (a, b)
12:42:11 <maerwald> write it without flip
12:42:47 <maerwald> flip is one of those functions I literally never use
12:42:57 <crucify_me> maerwald, thanks, its a book example against the equivalent reverseTuple' (a, b) = (b, a) 
12:43:03 <maerwald> ah
12:43:53 <crucify_me> maerwald, you never use it? I'm a beginner. there's a long section on const flip and id that I'm still studying
12:44:06 <maerwald> :t \(x, y) -> (y, x)
12:44:07 <lambdabot> (b, a) -> (a, b)
12:44:37 <maerwald> I read that function and I understand it within 0.3s
12:44:49 <maerwald> for the other version I probably need 10 times that time
12:44:55 <crucify_me> good call
12:44:56 <maerwald> unless I've seen it in the last 15 minutes
12:45:11 <maerwald> and it's just as short
12:45:42 <crucify_me> the point of the lesson is currying so that's why they have flip there I presume
12:45:57 <crucify_me> assume
12:46:08 <maerwald> yeah, I guess it's not to come up with real world examples
12:46:14 <crucify_me> thanks for the quick response
12:50:26 <mizu_no_oto> crucify_me: flip, const and id are all useful with higher order functions
12:51:06 <mizu_no_oto> crucify_me: e.g. foldr (flip foo) bar baz
12:51:22 <mizu_no_oto> if foo's arguments are the reverse of what you need
12:51:32 <maerwald> mizu_no_oto: why would you need flip there?
12:52:04 <maerwald> flip just forces you to visualize the type signature and the omitted arguments, which costs extra time
12:52:38 <mizu_no_oto> > foldl (flip (:)) [] [1,2,3,4,5]
12:52:40 <lambdabot>  [5,4,3,2,1]
12:52:57 <mizu_no_oto> > foldl (\x acc -> x : acc) [] [1,2,3,4,5]
12:52:59 <lambdabot>  error:
12:52:59 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ [a]
12:52:59 <lambdabot>        Expected type: [a]
12:53:14 <mizu_no_oto> > foldl (\acc x-> x : acc) [] [1,2,3,4,5]
12:53:16 <lambdabot>  [5,4,3,2,1]
12:54:08 <crucify_me> maerwald, mizu_no_oto hold on please could I get a little lesson re: foldr ?      re: this sum' xs = foldr (+) 0 xs or the pointfree summ = foldr (+) 0      ?
12:54:37 <crucify_me> when you have a fold, you need the zero as a counter?
12:54:47 <shloub> you need a start value
12:54:56 <maerwald> or end value :P
12:55:04 <crucify_me> that's what I meant thanks
12:55:12 <iqubic> Well, I'm taking the plunge head first. I'm installing NixOS cold turkey.
12:55:19 <maerwald> can lambdabot visualize foldr?
12:55:19 <mizu_no_oto> crucify_me: what's foldr (+) 0 [] going to return?
12:55:26 <shloub> i believe foldr1 takes the first (or last…) for this value
12:55:42 <crucify_me> zero?
12:55:53 <crucify_me> or []
12:56:02 <iqubic> :t foldr
12:56:04 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
12:56:26 <shloub> > foldr (+) 0 []
12:56:26 <crucify_me> iqubic, yeah frankly I cannot read that signature quite yet
12:56:29 <lambdabot>  0
12:56:47 <maerwald> I remember lamdabot being able to expan simple foldr commands, no?
12:57:00 <crucify_me> I never understood folds when I was doing scheme.
12:57:06 <crucify_me> *learning
12:57:10 <mizu_no_oto> you can simplify it to "(a -> b -> b) -> b -> [a] -> b"
12:57:14 <int-e> > foldr f a [b,c,d]
12:57:16 <lambdabot>  f b (f c (f d a))
12:57:24 <int-e> maerwald: like this?
12:57:33 <maerwald> exactly, you see 'a' being at the "end"
12:57:38 <int-e> :t f -- dirty trick
12:57:40 <lambdabot> FromExpr a => a
12:57:41 <maerwald> so it can be confusing to call it a start value
12:58:12 <crucify_me> I think of it as a "zeroed out" counter. is that wrong?
12:58:15 <int-e> > a^7
12:58:17 <lambdabot>  a * a * (a * a) * (a * a * a)
12:58:27 <maerwald> I just think of it as the bouncer
12:58:28 <maerwald> :P
12:58:30 <int-e> but fun to play with.
12:58:49 <crucify_me> sorry I'm losing this thread now
12:59:04 <maerwald> if there is no one getting into the party, the bouncer is the only person in the club, right?
12:59:09 <maerwald> err, forget that xD
12:59:42 <mizu_no_oto> crucify_me: basically, it takes a function (a -> b -> b), some initial value of type b, then a list of a's,s and applies that (a -> b -> b) in sequence to get back a single b at the end.
12:59:50 <monochrom> And if someone is getting into the party, the bouncer kicks them out, so the bouncer ends up stil being the only person.
13:00:14 <maerwald> well, I meant bouncer more in the sense that when it hits 'a' it "bounces back"
13:00:22 <mizu_no_oto> It doesn't have to be a 'zero' of some sort, but you often want it to be a 'zero'
13:00:37 <maerwald> but we are in the land of not-so-useful analogies now
13:02:12 <tdammers> useful analogies are like winnable wars
13:02:18 <maerwald> lol
13:03:02 <crucify_me> who let robert mcNamara into the party?
13:03:20 <monochrom> Me.
13:04:07 <mizu_no_oto> > foldr (:) [5,6,7] [1,2,3,4]
13:04:09 <lambdabot>  [1,2,3,4,5,6,7]
13:04:37 <crucify_me> excellent example I can probably figure it out now mizu_no_oto 
13:05:21 <mizu_no_oto> ^ that basically evaluates to 1 : 2 : 3 : 4 : [5,6,7]
13:05:21 <iqubic> > foldl (:) [5,6,7] [1,2,3,4]
13:05:23 <lambdabot>  error:
13:05:24 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ [a]
13:05:24 <lambdabot>        Expected type: [a] -> [a] -> [a]
13:05:41 <mizu_no_oto> > foldl (flip (:)) [5,6,7] [1,2,3,4]
13:05:44 <lambdabot>  [4,3,2,1,5,6,7]
13:06:17 <crucify_me> > foldl (:) [1,2,3,4] [5,6,7]
13:06:19 <lambdabot>  error:
13:06:19 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ [a]
13:06:19 <lambdabot>        Expected type: [a] -> [a] -> [a]
13:07:17 <crucify_me> ok thanks I'm going to look at this for a spell. THANKS ALL
13:08:14 <maerwald> is there an editor that can expand basic expressions like foldr and so on? I mean, not just the type signature
13:11:25 <fakenullie> Expand?
13:11:42 <maerwald> > foldr f a [b,c,d]
13:11:44 <lambdabot>  f b (f c (f d a))
13:15:59 <Psybur> So 30% of my app's time is spent parsing lines. Which is basically splitting a string on "," and then taking each element of the resulting array and putting it in a data constructor. Im guessing the successive !! calls to the array (a !! 0, a !! 1, a !! 2) means theres a lot of backtracking going on huh
13:16:51 <Psybur> https://github.com/jrciii/money-machine/blob/master/src/MoneyMachine/HistData.hs
13:17:54 <Psybur> Im guessing there has to be a better way of doing that
13:19:45 <Psybur> Hmm, probably by popping the resulting list
13:19:48 <shloub> [d, o, h, l, c] = s ?
13:19:55 <Psybur> shloub, even better.
13:20:06 <Psybur> Thanks
13:20:55 <iqubic> Anyone use NixOS and XMonad? I need some help getting the two to work together.
13:21:13 <maerwald> there is nixos channel
13:21:28 <callmecabman> I have a feeling that parser whatever = optional junk; useful1; optional junk; useful2; optional junk; useful3 ... can be encoded more nicely/
13:21:47 <iqubic> maerwald: I know, but they hate me for not using google.
13:21:53 <maerwald> lol
13:21:54 <callmecabman> iqubic: lol
13:22:38 <callmecabman> don't you know how to interleave a parser with another one? I want to get rid of this (optional junk).
13:23:22 <robertkennedy> lpaste.net/358780
13:24:21 <ertes-w> iqubic: slim + ~/.xsession works for me
13:24:28 <robertkennedy> I tried to recreate a python yield type nub using the state Monad, but I think I'm combining it incorrectly
13:25:14 <robertkennedy> The nub I use originally seems to slow down ~ 6x from python
13:39:30 <iqubic> Is Rotaerk around?
13:43:16 <kuribas> robertkennedy: you can just use Set.fromList
13:43:43 <kuribas> robertkennedy: nub is just Set.toList . Set.fromList
13:45:06 <robertkennedy> It is not
13:46:43 <kuribas> > (S.toList . S.fromList) [1, 2, 3, 2] -- robertkennedy
13:46:46 <lambdabot>  [1,2,3]
13:46:48 <hexagoxel> kuribas: stability
13:48:54 <hexagoxel> (or at least i hope that concept translates over from sorting algorithms..)
13:50:30 <fishythefish> > nub [3, 2, 1]
13:50:33 <lambdabot>  [3,2,1]
13:50:37 <fishythefish> > S.toList . Set.fromList $ [3, 2, 1]
13:50:40 <lambdabot>  error:
13:50:40 <lambdabot>      Not in scope: ‘Set.fromList’
13:50:40 <lambdabot>      Perhaps you meant one of these:
13:50:44 <fishythefish> > S.toList . S.fromList $ [3, 2, 1]
13:50:47 <lambdabot>  [1,2,3]
13:50:51 <fishythefish> no stability :)
13:53:31 <Psybur> :t Data.LinkedHashSet.empty
13:53:32 <lambdabot> error:
13:53:33 <lambdabot>     Not in scope: ‘Data.LinkedHashSet.empty’
13:53:33 <lambdabot>     No module named ‘Data.LinkedHashSet’ is imported.
13:53:42 <Psybur> > import Data.LinkedHashSet
13:53:45 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
13:53:47 <Psybur> :D
13:54:11 <kuribas> hexagoxel: nub isn't standard python either...
13:54:58 <Psybur> Can I get lambdabot to import?
13:55:10 <iqubic> sure.
13:55:27 <iqubic> @import Data.LinkedHashSet
13:55:27 <lambdabot> Unknown command, try @list
13:55:34 <iqubic> @let import Data.LinkedHashSet
13:55:34 <lambdabot>  .L.hs:101:1: error:
13:55:34 <lambdabot>      Could not find module ‘Data.LinkedHashSet’
13:55:34 <lambdabot>      Use -v to see a list of the files searched for.
13:55:36 <robertkennedy> I can add the nub implementation for python
13:55:49 <iqubic> Looks like that's not a valid package.
13:56:03 <iqubic> But It's @let import whatever.
13:56:54 <Psybur> https://hackage.haskell.org/package/linkedhashmap-0.4.0.0/docs/Data-LinkedHashSet.html
13:57:31 <iqubic> looks like that's not in lambdabot's package archive
13:57:42 <Psybur> Think that would let you do toList . fromList and keep the initial ordering
13:59:20 <robertkennedy> Added the python version. I'll look at the package. But generally, the `foldl (.) id` feels like the wrong combinator here
14:00:03 <monochrom> Would you like foldr (.) id instead?
14:01:24 <hexagoxel> robertkennedy: do you use State in an attempt to make `nub` faster?
14:01:51 <robertkennedy> Idk, is folding composition across a 10million element list good?
14:02:18 <robertkennedy> hexagoxel: yeah, and to learn it since it seems like a good usecase
14:04:56 <hexagoxel> robertkennedy: but state is no magic source of additional performance. if you are lucky, it will become as fast as `nub`.
14:06:37 <jle`> er, 'state' does absolutely nothing for performance
14:06:49 <jle`> it's just convenience combinators for writing cleaner code
14:07:28 <robertkennedy> Ah, okay. The original nub did feel correct and idiomatic. 
14:07:48 <jle`> foldr (.) id is probably the better thing for lists
14:07:52 <kuribas> > catMaybes $ flip evalState S.empty $  mapM (\e -> state (\s -> if S.member e s then (Nothing, s) else (Just e, S.insert e s))) [3, 2, 1, 3]  -- robertkennedy 
14:07:54 <lambdabot>  [3,2,1]
14:07:59 * hexagoxel also likes the original nub as it is there
14:08:41 <jle`> and yeah, you might be misunderstanding state; it doesn't actually give any different code than the one you'd write by hand
14:08:48 <jle`> it's just higher order functions and function composition in a clean way
14:09:08 <jle`> it's like using foldr vs. manual pattern matching
14:09:25 <jle`> foldr is implemented using pattern matching anyway, so it's just the same thing
14:09:28 <Psybur> Seems my app is spending a lot of time in: basicUnsafeWrite                  Data.Vector.Storable.Mutable
14:10:05 <Psybur> Is there a way to speed up vector usage or am I hosed
14:10:32 <jle`> unsure without seeing actual code
14:10:59 <hexagoxel> (foldr might have RULES stuff though..)
14:11:07 <Psybur> Its nasty. Youve been warned :D https://github.com/jrciii/money-machine/blob/master/src/MoneyMachine/ClusterStrategy.hs
14:12:08 <hexagoxel> (apart from that detail, jle` is of course correct.)
14:18:05 <royal_screwup21> how would you describe this type signature in words? (a -> b) -> [a] -> [b]  ?
14:18:52 <shapr> takes a function from a to b, and a list of a, returns a list of b
14:19:47 <iqubic> Looks like a standard map
14:19:50 <iqubic> :t map
14:19:51 <lambdabot> (a -> b) -> [a] -> [b]
14:20:45 <Profpatsch> I often miss NonEmpty.singleton
14:20:51 <royal_screwup21> suppose I do: map (3+) [1,2,3] -- how does each of the objects in this function "map" (ha) to the type signature?
14:21:02 <fishythefish> :t (3+)
14:21:03 <lambdabot> Num a => a -> a
14:21:04 <fishythefish> :t [1, 2, 3]
14:21:06 <lambdabot> Num a => [a]
14:21:12 <monochrom> [(3+) 1, (3+) 2, (3+) 3]
14:21:17 <Profpatsch> pure is just a bit non-descriptive for NonEmpty code.
14:21:24 <fishythefish> So here, it specializes to map :: Num a => (a -> a) -> [a] -> [a]
14:21:34 <jle`> it might be more interesting to look at a function that changes types
14:21:39 <jle`> like map even [1,2,3]
14:21:53 <jle`> or map ord "abc"
14:22:12 <jle`> > map ord "abc"
14:22:14 <lambdabot>  [97,98,99]
14:22:19 <monochrom> Oh! (3+) fills in the role of (a->b) and also sets b=a with Num a, so, what fishythefish said.
14:22:34 <monochrom> And so [1,2,3] has type [a] now.
14:23:17 <jle`> :t let map' = map in (map', map' ord "abc")
14:23:19 <lambdabot> ((a -> b) -> [a] -> [b], [Int])
14:23:24 <jle`> aw dang let polymorphism
14:23:30 <monochrom> And the answer [(3+) 1, (3+) 2, (3+) 3] has type [b], but b=a here, so [a] too.
14:23:42 <jle`> :t case map of map' -> (map', map' ord "abc")
14:23:43 <lambdabot> ((Char -> Int) -> [Char] -> [Int], [Int])
14:24:03 <jle`> the map in map ord "abc" is (Char -> Int) -> [Char] -> [Int]
14:24:13 <jle`> since ord :: Char -> Int
14:35:45 <robertkennedy> hexagoxel and jle`: I guess I was thinking it might mask the internal set for better memory management, since GC seems to take the Lions share of the program. But I'd believe it desugars to the same thing
14:36:18 <lyxia> Profpatsch: I also miss it
14:38:16 <jle`> robertkennedy: fwiw, state is not syntactic sugar, it's just normal higher-order functions
14:38:23 <jle`> like foldr, map, etc.
14:38:26 <jle`> @src foldr
14:38:26 <lambdabot> foldr f z []     = z
14:38:26 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:38:53 <jle`> it's all written within haskell, and is not any compiler or syntactic magic :)
14:39:34 <jle`> so it's not sugar any more than map f [x,y,z] is "sugar" for [f x, f y, f z]...it's just how all functions work in haskell
14:40:19 <Profpatsch> lyxia: (:|[]) :)
14:40:41 <jle`> map f (x:y:[]) = f x : map f (y:[]) = f x : f y : map f [] = f x : f y : []
14:40:46 <jle`> > map f [x,y,z]
14:40:49 <lambdabot>  error:
14:40:49 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘show_M110783466797...
14:40:49 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
14:40:55 <jle`> > map f [x,y,z] :: [Expr]
14:40:57 <lambdabot>  [f x,f y,f z]
14:41:42 <lyxia> Profpatsch: Very understandable :)
14:42:14 <jle`> it's the robot-monkey-with-mustache operator
14:42:33 <jle`> the cousin of everyone's favorite robot monkey operator
14:43:06 <jle`> @quote monkey
14:43:06 <lambdabot> byorgey says: now we have the pig operator <^(++)^> as well as the robot monkey operator (:[])
14:43:08 <Profpatsch> lyxia: Perl developers rejoice!
14:43:52 <Profpatsch> Too many operators kill the party.
14:43:59 <Profpatsch> ruin the soup
14:46:09 <lyxia> @quote elephant
14:46:10 <lambdabot> olsner says: < kmc> i think 250 milliolegs is enough to kill an elephant  < olsner> kmc: ... to kill an elephant - in the type system!
15:22:46 <mzabani> hi everyone, I'm having a hard time using Control.Exception.catch due to not knowing what exception type I should choose.. can anyone lend me a hand?
15:22:53 <dsal> Is there an easy way to have a persistent data structure in the IO monad?  Doing an exercism thing and it looks like it'd be fairly easy if I used a database or something.  All the functions are IO.
15:25:52 <koala_man> dsal: IORef? 
15:29:55 <jle`> dsal: IORef works as a mutable variable/reference in IO
15:30:02 <jle`> but also if you're nt doing any actual IO, conside rusing ST and STRef
15:31:48 <jle`> mzabani: you should just asky our question :)
15:32:40 <mzabani> jle`: All right! Can I catch all exception types with "catch" ?
15:32:47 <mzabani> Or some other function
15:32:59 <jle`> you can catch all exception types with catch
15:34:15 <mzabani> I'm trying to "bsMaybe <- catch (fmap Just $ Network.connectionGetChunk sock) (\e -> return Nothing)" but the compiler tells me to specify the type of the exception
15:34:47 <mzabani> Don't know what to do next
15:37:34 <jle`> mzabani: see the documentation for the 'catch' function
15:37:37 <kellytk> I currently write full-stack web 'apps' using TypeScript/Node.js although I'm awaiting a viable alternative.  Is Haskell web dev (back/frontend) continuing to gain traction?
15:37:50 <jle`> http://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Exception.html#v:catch <- mzabani 
15:39:07 <mzabani> oh gosh I missed the SomeException type.. sorry about that
15:39:19 <mzabani> should've read the docs more carefully..
15:39:21 <jle`> no problem :)
15:39:38 <jle`> also you usually don't want SomeException
15:40:18 <jle`> check out what kind of exceptions connnectionGetChunk might throw
15:40:45 <jle`> mzabani: also the pattern you wrote is very similar to try/tryJust
15:41:46 <mzabani> Indeed, tryJust seems really nice for what I need
15:42:06 <mzabani> but reading the docs more carefully I'm reminded that catching all exceptions is not really a good thing..
15:42:44 <jle`> yeah, it looks like you might want to jsut catch IOError's ?
15:43:13 <mzabani> in my context, I just need to clean up if something goes wrong and then exit.. 
15:43:33 <jle`> maybe bracket then?
15:44:16 <mzabani> The try and tryJust functions look fine to me, I'm just not sure if I will be doing the right thing ignoring asynchronous exceptions, for instance
15:44:35 <mzabani> I think I'm just a little scared of not knowing about exceptions in Haskell well enough
15:44:38 <dsal> koala_man, jle` thanks.  I'll do some reading.
15:45:42 <jle`> mzabani: if yuo're just going to clean up on the broken case, then bracket makes more sense; you don't have to deal with the awkward Just/Nothing's
15:45:57 <jle`> but yeah feel free to shop around the module, it's all pretty useful :)
15:46:28 <mzabani> jle`: hmmm all right! Thanks for all the help!!
15:47:10 <jle`> mzabani: the Marlow book also has a nice chapter on exceptions
15:47:14 <jle`> http://chimera.labs.oreilly.com/books/1230000000929/index.html
15:50:30 <mzabani> is that book hard to read?
15:50:58 <jle`> it's actually very accessible
15:51:05 <jle`> it's one of the books i recommend to all beginners :)
15:51:22 <jle`> it's like the second book haskell book i ever read when learning haskell, it's intended for people starting out on haskell
15:51:38 <jle`> after they are already familiar with syntax and the basics
15:51:57 <Tuplanolla> Three books and three Haskells in one sentence. I think that's enough for the night, jle`.
15:53:40 <jle`> > cycle "haskell "
15:53:42 <lambdabot>  "haskell haskell haskell haskell haskell haskell haskell haskell haskell has...
15:54:42 <mzabani> lol
15:54:49 <iqubic> > cycle "cycle haskell"
15:54:52 <lambdabot>  "cycle haskellcycle haskellcycle haskellcycle haskellcycle haskellcycle hask...
15:54:59 <iqubic> > cycle "cycle haskell "
15:55:01 <mzabani> I think I'll add it to my list, then!
15:55:01 <lambdabot>  "cycle haskell cycle haskell cycle haskell cycle haskell cycle haskell cycle...
15:55:13 <mzabani> my night read
15:55:30 <iqubic> My night read is the NixOS manual
15:56:13 <kellytk> The "WebGHC (a WebAssembly backend for GHC)" project (https://summer.haskell.org/news/2017-09-15-final-results.html) is very interesting
15:56:22 <jle`> :o
15:56:37 <monochrom> mzabani: My http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml#supertyping has some sample code for discovering which exact type is being throw.
16:03:05 <mzabani> monochrom: thanks for that. After reading what you wrote and looking at the definition of "try" there is something I don't understand. After specifying the exception's type, does the runtime check the exception's type to know whether it should rethrow the exception?
16:03:37 <jle`> yes
16:04:28 <mzabani> interesting.. is that something particular to the functions that deal with exceptions or does it happen in other places?
16:05:23 <mzabani> oh wait.. is this made possible because of Typeable?
16:05:59 <jle`> yes it's something that you can implement yourself using Typeable
16:06:21 <jle`> well, only-hand-certain-types thing
16:07:24 <jle`> basically cast :: (Typeable a, Typeable b) => a -> Maybe b is something you can use to implement similar functionality by hand
16:08:11 <mzabani> but once I write something like "e :: IOException", isn't my handler function specialized by the compiler during build time?
16:08:41 <jle`> yeah, consider cast :: (Typeable a) => a -> Maybe Int
16:09:01 <jle`> > cast True :: Maybe Int
16:09:04 <lambdabot>  Nothing
16:09:08 <jle`> > cast "hello" :: Maybe Int
16:09:10 <lambdabot>  Nothing
16:09:13 <jle`> > cast (5 :: Int) :: Maybe Int
16:09:16 <lambdabot>  Just 5
16:09:48 <mzabani> lol it looks like magic to me. Let me take a look at Typeable at the docs..
16:10:19 <jle`> yeah, typeable isn't actually inherently magic, it's something you can implement yourself (in a limited manner) using vanilla typeclasses
16:11:20 <jle`> consider something like class ShowType a where showType :: p a -> String, and instances like instance ShowType Int where showType _ = "Int", instance ShowType Bool where showType = "Bool"
16:12:19 <jle`> and so cast :: (ShowType a, ShowType b) => a -> Maybe b; cast x | showType (Just a) == showType (Nothing :: Maybe b) = Just (unsafeCoerce x) | otherwise = Nothing
16:17:12 <mzabani> jle`: hmm to make that safe we need to make sure that two types with the same value for showType have the same internal representations, right?
16:18:09 <AWizzArd> What is :>  in  type UserAPI = "users" :> QueryParam "sortby" SortBy :> Get '[JSON] [User]    ?
16:27:11 <boj> AWizzArd: it's a type level operator introduced by servant to build up api types like that
16:29:30 <jle`> mzabani: yes, that's why we always have GHC derive the Typeable instance for us
16:29:49 <jle`> we actuall used to be able to define our own Typeable instances but that got shut down a couple of ghc versions back
16:30:03 <jle`> AWizzArd: x :> y is equivalent to (:>) x y
16:30:12 <jle`> it's just normal operators but for types instead of values
16:30:35 <jle`> for example, an alternative definition of either:
16:30:43 <jle`> data a :+: b = Left a | Right b
16:30:53 <jle`> and you'd write `Int :+: Bool` instead of `Either Int Bool`
16:31:26 <jle`> @let type (:+:) = Either
16:31:28 <lambdabot>  Defined.
16:31:53 <jle`> > let f :: Int :+: Bool -> String; f (Left x) = show x; f (Right x) = show x in f (Left 10)
16:31:56 <lambdabot>  "10"
16:33:22 <erisco> after establishing a TCP connection from client to server, is the server supposed to establish a second connection from server to client?
16:33:30 <hpc> no
16:33:43 <erisco> I am confused by the Network.Transport library, because I cannot figure out how the server is to send messages to a client after the client has made a connection
16:34:00 <erisco> there is merely a ConnectionId and not a way to get a Connection object from that, which is necessary to send a message
16:34:13 <jle`> what is the Network.Transport library?
16:34:22 <hpc> https://hackage.haskell.org/package/network-transport-0.5.2/docs/Network-Transport.html?
16:34:31 <erisco> yes
16:34:38 <jle`> ah the network-transport library
16:35:43 <jle`> doesn't the server have a send action available to it?
16:35:47 <hpc> "Connections between EndPoints are unidirectional and lightweight"
16:35:49 <hpc> https://hackage.haskell.org/package/network-transport-0.5.2
16:35:59 <hpc> this is not a traditional network library
16:36:48 <erisco> yes, so am I supposed to create a second connection? that doesn't seem right for TCP
16:37:05 <erisco> maybe I want a different networking library, but I don't know of them
16:37:06 <hpc> i think so?
16:37:11 <jle`> i don't think it's quite a tcp library
16:37:16 <jle`> it looks like a library that is implemented on top of tcp
16:37:17 <hpc> this library is super weird
16:37:55 <jle`> it doesn't quite implement a tcp interface, it implements something else, and abstracts over concrete implementation details like tcp
16:38:13 <boj> erisco: if you want basic tcp networking i'd suggest looking at network-simple
16:38:20 <jle`> ah it looks like actually there are multiple backends available
16:38:30 <jle`> some of them not even tcp
16:39:34 <erisco> boj, thanks
16:46:29 <mzabani> jle`: thanks for all the explanations so far. If I may ask one last thing.. what happens to uncaught exceptions thrown in a thread created by forkIO ?
16:50:36 <monochrom> It will go quietly into the night, it will vanish without a fight.
16:50:58 <monochrom> (The thread, that is.)
16:51:15 <benzrf> it goes gentle into that good night
16:52:56 <mzabani> lol so if the thread failing is not a problem in my use case I don't have to worry about any other undesired side effects?
16:53:33 <Tuplanolla> It won't go quietly.
16:55:45 <Tuplanolla> It will print the exception to the standard error stream and clean up the dead thread.
16:56:22 <Tuplanolla> You can avoid doing those by using `fork#` from `GHC.Conc`.
16:57:04 <mzabani> hmm.. I'm afraid of the #-terminated functions.. is that ok to use?
16:57:10 <Tuplanolla> No.
16:57:23 <monochrom> I can't reproduce the "print the exception" part.  t <- forkIO (threadDelay 10000000); killThread t
16:58:00 <monochrom> So could you show a program that does what you said?
16:58:52 <mzabani> I've gotten some "ConnectionClosed" exceptions printed when some of my threads die
16:59:14 <Tuplanolla> > do {_ <- forkIO $ error "yes"; pure ()}
16:59:17 <lambdabot>  error:
16:59:17 <lambdabot>      Variable not in scope: forkIO :: t0 -> m a0
17:09:05 <Tuplanolla> > do {_ <- forkIO $ threadDelay 1000000 >> error "more obvious yes"; pure ()}
17:09:08 <lambdabot>  <IO ()>
17:09:44 <monochrom> Yeah lambdabot won't do it for you. Thanks.
17:10:27 <Tuplanolla> At least it let me import the module.
17:16:10 <AWizzArd> jle` and boj: thx guys
17:32:35 <jle`> np
17:33:07 <unclechu> hey guys, can i template some text for quasi-quote using haskell-templates?
17:34:36 <jle`> mzabani: see https://www.fpcomplete.com/blog/2017/08/exiting-haskell-process for an interesting meditation on this
17:35:09 <monochrom> unclechu: I don't understand the question. But maybe you mean https://hackage.haskell.org/package/string-qq
17:36:37 <grokkingStuff> Hi there!
17:36:52 <grokkingStuff> So i've been learning haskell on and off for a while and i'm stuck in that cycle
17:36:55 <grokkingStuff> any advice?
17:37:05 <jle`> grokkingStuff: build useful things with it :)
17:37:14 <monochrom> Get off the cycle. Do something else.
17:37:16 <unclechu> monochrom: i mean i have some quasi-quoter (in my case some sql-helper for requests to postgresql) and i have a model described as type-class, i want to serialize model fields automatically inside this quasi-quoter
17:37:39 <erisco> apply stick to spokes
17:37:43 <grokkingStuff> jle`: that's kinda the issue - doing real stuff involves libraries that usually need more stuff than i know
17:37:51 <grokkingStuff> erisco: ha
17:37:58 <jle`> usually it's within reach to learn those libraries
17:38:04 <jle`> and if it's useful to you, it's worth learning :)
17:38:27 <grokkingStuff> hmmm. any recommendations for db stuff?
17:38:35 <grokkingStuff> a simple one would be fine, really
17:38:47 <jle`> at least if you have a goal in mind, it's easier to focus on learning a specific library
17:38:57 <jle`> what kind of things do you want to do?
17:39:37 <grokkingStuff> jle`: a simple application that helps me keep track of my inventory
17:40:42 <jle`> sounds like it shouldn't be too bad, you can create a data structure that keeps track of your inventory
17:40:53 <jle`> and use the 'binary' library to automatically serialize it
17:40:58 <jle`> and deserialize it
17:41:20 <erisco> why not just take all your definitions and make them pointless, by hand, :)
17:41:22 <jle`> alternatively also the 'aeson' or 'yaml' library to serialize/deserialize as json or yaml if you want something portable 
17:41:54 <jle`> aeson/yaml library lets automatically generate json/yaml schemas for your data types
17:42:04 <grokkingStuff> jle`: i'd like to be able to use swift for the actual app
17:42:29 <jle`> hm what's the platform?
17:42:36 <grokkingStuff> is that a thing you'd recommend for a newb?
17:42:39 <grokkingStuff> jle`: iphone
17:42:41 <jle`> swift?
17:43:00 <grokkingStuff> jle`: yeah.
17:43:05 <erisco> the language is called "Haskell", after all
17:43:06 <jle`> a newb in what?
17:43:35 <jle`> i've never used swift so i can't say first-hand
17:43:38 <grokkingStuff> jle`: in haskell.
17:43:52 <grokkingStuff> i've used other languages but haskell's been eluding me for a while.
17:43:55 <jle`> is swift something i'd recommend for a newb in haskell?
17:44:05 <jle`> i think knowing some haskell concepts mimght help with learning swift
17:44:20 <jle`> but how swift goes for you probably depends on other factors than haskell knowledge more
17:44:36 <grokkingStuff> jle`: no, integrating haskell into swift
17:44:38 <jle`> sorry that was written weirdly
17:44:56 <jle`> ah
17:44:58 <grokkingStuff> jle`: np :D
17:45:03 <grokkingStuff> my bad.
17:45:23 <jle`> ;_;
17:46:15 <jle`> i didn't mean to scare them off i promise
17:50:49 <erisco> maybe some type inference exercises
17:53:36 <mzabani> jle`: the article is really interesting. In fact it shows that forkIO registers an exception handler that prints things to stderr
17:54:14 <jle`> indeed it reveals a lot of unexpected quirks in the standard library
17:54:52 <jle`> in other news regarding unexpected quirks, different implementations/engines for javascript implement .sort() differently for arrays, so your arrays are sortd differently depending on what engine your code is running on
18:00:28 <JScu> hello
18:02:39 <JScu> i dont understand Maybe
18:02:59 <JScu> whats the advantage of using Maybe?
18:03:24 <boj> JScu: rather than throw back a nil/null, you can capture whether an actual worked (Just a) or failed (Nothing) in a type safe manner
18:03:37 <boj> s/actual/action
18:03:49 <JScu> i thought there is no nil/null in haskell
18:03:53 <boj> right
18:04:24 <boj> sorry if that was confusing, i was using something common from other languages as an example of where you may consider using a Maybe
18:06:00 <JScu> http://lpaste.net/358786
18:06:06 <JScu> how do i call this function?
18:06:10 <JScu> getValue 5 does not work
18:06:44 <erisco> getValue (Just 5)  or  getValue Nothing
18:06:47 <boj> JScu: you would pass it  Just 5  or  Nothing
18:07:12 <JScu> and why?
18:07:48 <JScu> if i call the function with (Just 5) i already know that i am expecting a valid value
18:07:52 <boj> because there is a possibility that whatever is calling getValue might not be able to pass an Int, so you need some way to represent that
18:08:15 <monochrom> Who wrote this function?
18:08:25 <JScu> thats from some example
18:08:41 <JScu> but getValue (Just s) does not give me Nothing but rather an error
18:08:44 <monochrom> Could I see where this example came from?
18:08:48 <JScu> hm i am confused, whats the point
18:09:00 <JScu> https://thoughtbot.com/maybe_haskell-sample.pdf page 10
18:09:01 <erisco> 'tis a silly function
18:09:07 <monochrom> Oh this getValue function has no point. It's why I asked.
18:09:08 <boj> it's kind of a terrible example
18:09:25 <JScu> i altered it though
18:09:41 <JScu> i might make sense in its original form
18:09:58 <monochrom> There you go.
18:10:07 <monochrom> PEKBAC
18:10:20 <pikajude> Problem exists ketween beyboard and chair.
18:10:32 <erisco> the author continues on to explain the situation, so did you keep reading?
18:11:17 <JScu> i am not understanding the point
18:11:36 <monochrom> This book has a very good use case for Maybe. It makes sense to me.
18:12:11 <JScu> okay ill read again
18:12:18 <monochrom> I could explain it to you, but I would be repeating the book from cover to cover.
18:13:32 <erisco> there is a use on page 8, did you read that?
18:13:49 <monochrom> But tl;dr you can use "Maybe Int" for example to indicate "sometimes there is no legit answer". And of course for this purpose I assume the "Maybe Int" is the codomain, not the domain.
18:16:06 <erisco> the point of getValue is to demonstrate that having a  Maybe t  is not as strong as having a  t  i.e. there are some  Maybe t  values from which you cannot produce a  t  (i.e. from Nothing)
18:16:49 <erisco> then uses of Maybe itself appear throughout the book (it seems to be the whole theme of it)
18:36:25 <mzabani> guys, thanks for all the help
18:36:29 <mzabani> good night to everyone
18:49:58 <dmwit> I'm looking for a family of distributions.
18:50:36 <dmwit> I'd like it to cover the numbers 0-20 (either continuous or discrete is fine), and I'd like there to be a tunable parameter that lets me assign most of the probability mass to any of the integers in that range.
18:50:40 <dmwit> Are there any famous ones?
18:51:09 <dmwit> I thought of "flip a coin 20 times and count the heads", which has a parameter for the probability of it coming up heads, but I'd be interested in hearing about others.
18:51:50 <lyxia> Gaussian distribution centered on 10
18:52:27 <dmwit> I suppose that's also possible. But having the support extend beyond the range 0-20 makes me a little queasy.
18:56:32 <dmwit> A little context: I'm trying to construct a cost function for a tool that suggests a difficulty level for people to use when playing a game. I want it to take into account what difficulty levels they've played in previous games, but "smooth" it a bit so that e.g. if they always played at level 8 in the past, the tool would consider 7, 8, and 9 to all be reasonable suggestions.
18:57:17 <jle`> "flip a coin 20 times and count the heads" approximates the normal distribution
18:57:46 <jle`> so if that fits what you want, then the normal distribution is a reasonable implementation
18:57:51 <dmwit> jle`: Hm, really? With p /= 0.5, the distribution isn't even symmetric.
18:58:16 <jle`> the distribution isn't, but the sum of multiple samples approaches normal distribution
18:58:27 <dmwit> I don't plan to sum multiple samples.
18:58:30 <jle`> https://en.wikipedia.org/wiki/Central_limit_theorem
18:58:55 <jle`> as in, each coin flip is a sample, and the numbe rof heads is the sum of 20 samples
18:58:56 <dmwit> I plan to smooth an existing observed discrete distribution.
19:00:09 <dmwit> jle`: Yeah, but, like, 20 is not a large number. So appeals to the law of large numbers seem... wrong.
19:02:51 <jle`> dmwit: http://www.wolframalpha.com/widgets/view.jsp?id=78baf4f3a070cc5b9b226664d2ce80ec
19:02:55 <jle`> fwiw
19:03:42 <jle`> oh wait i think i did that wrong
19:07:09 <helpmeplz> Hello Everyone, I am writing this on behalf of a dear friend that has recently become a victim to a Secksual predator.  There is a runescape TWITCH streamer, who is streaming now, by the name of "RSGLORYANDGOLD" that has solicited her for favors of a secksual nature and has tried to get real life details from her. he now harrasses her and calls her vulgar and humilitating things daily. Please 
19:07:09 <helpmeplz> support by going to his channel and calling him out. there is video proof on youtube "rebecca black-rsgloryandgold"..thanks for your suppport
19:09:34 <dmwit> Okay. Anyway, normal and binomial distributions both seem usable. Thanks for the suggestions!
19:12:14 <jle`> no problem!  and just to elaborate on my previous link, flip-a-biased-coin-10-times-and-count-the-heads is exactly the binomial distribution, in case it wasn't clear
19:35:31 <obh332> If I want to build a web app, is it recommendable to compose a specific small library instead of a full-blown battery included one?
19:42:52 <c_wraith> obh332: both work.  You should go for what you feel comfortable with.
19:48:10 <guest_> hi
19:53:13 <vc> what are some good practices for resource allocation that's made within FFI, should it _always_ be within an IO monad, are there instances where unsafeperformIO is acceptable?
19:53:39 <vc> and in either case, how can one avoid resource leaks?
19:55:36 <eacameron> Can type application be partially applied?
19:57:49 <obh332> Is there any pointer on how it's done? Most of the articles I've read uses yesod
20:17:45 <glguy> eacameron: Types can be partially applied in general, but type synonyms and type synonym families can't be
20:19:06 <eacameron> glguy: I see, so just in the same way as Either Int is partially applied, swap @Int can also be.
20:19:34 <eacameron> > :t swap @Int
20:19:37 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
20:34:00 <dmj`> obh332: depends on your application. If it's simple, an all-in-one framework can make you more productive (yesod / snap approach). If your app is not simple, and will fall outside of what a framework can provide, you’re probably better off composing smaller pieces of what you need (wai / warp approach) into a solution.
20:39:20 <obh332> It's actually just a simple app, but 
20:39:34 <obh332> I want to compose it to exercise myself
20:40:33 <sm> either way, you'll get plenty of exercise :)
20:55:05 <Axman6> obh332: I'm a fan of using Servant for web apps, because you can get simple API stuff done really easily, but you can also splice in other frameworks really easily, like Snap or Yesod
20:56:50 <eacameron> vc: Avoiding resource leaks with FFI is always a challenge, just like it is in C already. You want to avoid allocating resources on one side of the fence and deallocating them on the other side. You can use StablePtr on the haskell side to pass values to C and prevent them from being GC'ed (you have to free them yourself, probably in a bracket'ed expression).
21:01:10 <Axman6> don't ForeignPtrs let you provide a cleanup callback for when things get GC'd? (which is good unless the C side holds references to it)
21:02:17 <c_wraith> ForeignPtr is basically Ptr + finalizers, yes
21:02:35 <eacameron> Axman6: Yep good point.
21:02:43 <c_wraith> But you need to be sure it never collects early, or things get... bad
21:02:59 <c_wraith> touchForeignPtr is important
21:03:35 <c_wraith> well.  withForeignPtr is better when it works.  Sometimes it doesn't, though
21:05:04 <eacameron> c_wraith: Yuck. That sounds like it's more trouble than it's worth almost.
21:06:15 <c_wraith> I mean..  You're trying to connect two different memory allocation systems.  It's not ever going to be pleasant.
21:07:31 <c_wraith> Like, even with different libraries in C it can be a mess.  If a particular library exposes any functions that heap-allocate some data structure, they should also expose a free function for that data structure, because different libraries can link to different heap allocation systems in the same program.
21:09:12 <nshepperd> you just need to make sure the Ptr doesn't escape out of withForeignPtr
21:09:40 <c_wraith> That works until you need it to. :)
21:11:46 <nshepperd> which means, define a bunch of 'basic operations' in IO that operate on the ForeignPtr, check that they don't let the Ptr escape, then only use those operations
21:25:34 <vc> thanks all
21:26:09 <vc> discovered a relevant RWH section, going to try this - http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html#id655309
21:26:15 <vc> are there other good tutorials on doing this well?
21:28:53 <dmj`> https://en.wikibooks.org/wiki/Haskell/FFI
21:40:04 <fred-fri> how can i print the outgoing requests from a servant client?
21:42:23 <Axman6> you could make a middlware that does that
21:44:12 <Axman6> but it may not be a good idea to print the body of the request
21:46:02 <fred-fri> Axman6: i'd like to print the whole request.. it's just for temporary debugging purposes
21:48:17 <Axman6> printResp :: Middleware; printResp app req resp = app req (\appResp -> print appResp >> respond appResp) -- roughly
21:48:47 <Axman6> but I don't know if Response has a Show instance
21:51:36 <fred-fri> Axman6: sorry i'm a complete noob just messing around with Servant https://gist.github.com/androidfred/a0edc0bc375eaa62886ba8ebde0167ab
21:51:47 <Axman6> you need to look at wai
21:51:57 <fred-fri> i know the server has a bad cert that you have to manually trust when browsing
21:52:02 <fred-fri> it could be that based on the output
21:52:14 <fred-fri> but i'd just like to confirm also it's making the request i want it to
21:52:18 <geekosaur> (there's a 'no wai' joke hidden in there somehwere)
21:53:04 <fred-fri> no wai *badabish*
21:53:54 <Axman6> oh you're not talking about the server side, my bad
21:55:30 <fred-fri> pls halp
21:56:12 <Axman6> does the default HTTP manager handle https?
21:56:41 <fred-fri> based on the output i intuit that it is making the request i want ie GET https://user-service.foo.com/v1/users/19647 but because of the shitty cert on the server it blows up
21:57:03 <Axman6> that port isn't the https port though
21:57:47 <Axman6> you've set things up for https://user-service.foo.com:8443/v1/users/19647 not https://user-service.foo.com:443/v1/users/19647 aka, https://user-service.foo.com/v1/users/19647
22:02:01 <fred-fri> Axman6: is there no way to just flat out not set the port?
22:02:36 <Axman6> doesn't look like it, the docs are the most likely place to tell you though
22:02:56 <Axman6> do you know for sure you want port 8443 and not 443?
22:03:09 <fred-fri> you're right about the port number though, i changed it from 8443 to 443
22:03:40 <fred-fri> manually opening in browser https://user-service.foo.com:8443/v1/users/19647 doesn't work but 443 does
22:07:09 <fred-fri> i'm pretty sure it's servant/wai not liking the bad cert on the server
22:08:25 <Axman6> you should probably be using https://hackage.haskell.org/package/http-client-tls-0.3.5.1/docs/Network-HTTP-Client-TLS.html
22:08:41 <Axman6> using newTlsManager
22:13:52 <Axman6> fred-fri: did that help?
22:16:40 <fred-fri> Axman6: you, sir, are a hero
22:16:50 <fred-fri> i also found this https://github.com/algas/haskell-servant-cookbook/blob/master/doc/Https.md
22:26:56 <kuribas> hi, I can define an optional arguments Monoid: Option a, which is basicly Endo a, and allows to compose optional arguments with <>.
22:27:07 <kuribas> Would it make  sense to create a package for it?
22:27:35 <kuribas> the advantage over Endo would be the name of the type.
22:27:56 <jle`> so it'd be exactly Endo, just named differently?
22:28:12 <kuribas> yeah
22:28:21 <kuribas> perhaps some TH to avoid boilerplate :)
22:28:21 <jle`> would there be any useful utility functions?
22:28:46 <kuribas> the only thing I can think of is TH
22:29:13 <jle`> if it's useful then it might be worth making a package
22:29:23 <kuribas> so you can mark default values.
22:30:21 <kuribas> say MyStruct_ {a :: A, b :: B, c :: C, d :: D}, where C and D or optional
22:30:42 <mbw> If I understand correctly, in times past there was something called ErrorT. It supposedly sucked, since it put a constraint on the Left value, hence it was deprecated in favor of... ExceptT inside transformers, or EitherT if you read any post by Tekmo. I always thought the "modern" thing was ExceptT, but is this correct in general?
22:30:57 <Axman6> sounds kind of like what configuration-tools does
22:30:59 <jle`> yes ExceptT is ErrorT-done-right
22:31:10 <jle`> EitherT existed in the gap
22:32:15 <mbw> Alright. Phew :)
22:32:56 <mbw> Btw will ListT and WriterT ever be fixed in transformers? :/
22:33:14 <jle`> ErrorT existed in transformers, EitherT was made in the eithers package to fix it, and then eventually transformers people allowed ExceptT to be made in transformers so we don't need EitherT anymore
22:33:57 <jle`> i don't think a proper ListT is in the scope of transformers at this point, it's probably a mistake that it ever existed
22:36:05 <jle`> i haven't heard any chatter about WriterT but it might be nice
22:36:56 <pacak> Are there any streaming library that allow you to combine several producers using some  kind of event ordering function?
22:37:17 <Axman6> I believe Machines gives you that
22:37:19 <mbw> I don't really get it though. At least with WriterT, people couldn't decide on a new name or how to embed a fixed version inside the existing module structure. But that is just what they did with ExceptT. So why not add a successor in the spirit of ListT called LogicT or whatever. They even added an embellished Writer version called Accum, which from what I have seen looking at the source has the same space 
22:37:25 <mbw> leak problem...
22:39:35 <kit__> toblerone!
22:40:08 <kit__> One of the best chocolate corrugated triangle prism treats!
22:40:52 <mbw> You better back that up with some triangle prism laws.
22:41:11 <jle`> mbw: implementing a working ListT isn't exactly straightforward i believe
22:41:48 <kit__> Law 1: It's easier to eat.
22:42:32 <kit__> Is identity a law? That's a safe bet, right? :(
22:44:19 <mbw> jle`: But there's like four versions on hackage, I believe. Of course, in the specific case of ListT, people don't regularly use it, so it might not be worth it. But with WriterT the working solution is simply StateT, and a lot of people would actually like to use it I presume, but don't.
22:45:21 <mbw> kit__: Don't forget: what goes in, comes out.
22:48:25 <kit__> So you're saying it's endomorphic???
22:48:41 <mbw> On the other hand, eating a toblerone twice is not the same as eating it once I think :/
22:48:58 <kit__> Something is lost in the process.
22:49:21 <Axman6> there's hidden state and other inputs
22:49:38 <Axman6> so eat and eat . eat don't make much sense
22:50:04 <kit__> I mean... then how do you explain human caterpillar?
22:50:10 <kit__> isn't that eat . eat . eat
22:50:26 <kit__> I've never seen it myself though.
22:51:25 <kit__> Sorry for the low-grade Haskell puns. I'm a newcomer and have found making bad jokes to be an effective mneumonic.
22:52:17 <srhb> kit__: Mnemonic, and agreed. :P
22:52:51 <kit__> Doh, and thank you :)
22:53:09 <Axman6> mfix eat
22:53:27 <liste> wouldn't that be just fix eat? if eat is pure
22:53:27 <kit__> :t joke
22:53:29 <lambdabot> error: Variable not in scope: joke
22:53:53 <seafood> Anyone got any experience using Haskell Program Coverage here?
22:54:29 <pierrot> I used it like a week ago
22:54:36 <liste> @let data Edible = Toblerone | Waste
22:54:37 <lambdabot>  Defined.
22:54:38 <Axman6> not for a long time. 
22:54:43 <liste> @let eat = const Waste
22:54:44 <lambdabot>  Defined.
22:54:51 <liste> > eat Toblerone
22:54:54 <lambdabot>  error:
22:54:54 <lambdabot>      • No instance for (Show Edible)
22:54:54 <lambdabot>          arising from a use of ‘show_M686867032319414317528248’
22:54:56 <seafood> Can you tell me how I could configure my build environment so I could compile a library with and without -fhpc enabled creating two sets of files (much like you get a .a and .p_a when you profile)
22:55:27 <Axman6> not sure you can
22:55:55 <Axman6> but I think that using something like stack build and stack build --coverage might at least let you swap between them
22:56:04 <kit__> liste: That's amazing. We're in ghci right now??? *___*
22:56:12 <seafood> Hmmm, that's annoying. So, basically I don't -fhpc enabled all the time since I imagine the instrumentation slows the code down when it executes.
22:56:30 <Axman6> yeah, quite a lot
22:57:03 * kit__
22:57:06 <Axman6> (the implementation is amazing, it's just a huge number of x++'s for many (_many_) variables in all your basic blocks
22:57:44 <seafood> Axman6: Well, that's all it really needs to do :-)
22:57:53 <seafood> But yeah, that would have slow things down a lot.
22:58:46 <Axman6> yeah but it's not one x++ per block, it can be like 20+
22:59:27 <seafood> Axman6: Hilarious
23:00:14 <Axman6> I thought I had some disassembled code for it, but can't find it
23:09:13 <liste> kit__: lambdabot can do a lot of stuff
23:11:52 <jle`> mbw: yes i would be ok with an abstract WriterT
23:12:12 <jle`> in fact now that pattern synonyms are a mainstream thing we could even treat WriterT as if it were what it is now
23:12:20 <jle`> but have it be implemented abstractly over StateT
23:12:37 <jle`> i just haven't heard much about any momentum to make that happen
23:33:44 <mbw> jle`: From what I have seen, the ether package implements (un-)tagged transformers that come without the histerical raisins, i.e. non-leaking writer based on a cps'ed StateT. Unfortunately, breaking API changes still happen, and I wasn't able to make it play nice with lens. And once you buy into lens, you don't need tagged transformers anyway :/
23:38:39 <nshepperd> 'class Monad m => MonadState tag s m | m tag -> s where { get :: m s; ... }' huh
23:38:54 <nshepperd> you're expect to use TypeApplications at every invocation?
23:43:11 <royal_screwup21> suppose I have a function, f, that takes one int and returns out an int. I want to apply this to every int in a list. So I tried map f [1,2,3] but I got this error: https://thepasteb.in/p/wjh035qLx18hv What am I doing wrong
23:45:39 <mbw> roayal_screwup21: Could you include the actual code with the error message as well? If you had f :: Int -> Int, this should work, after all.
23:47:35 <royal_screwup21> I've got f :: Num a => a, so yeah. I'm on the ghci interpreter and I did let f = f+1 then map f [1,2,3]
23:48:18 <nshepperd> 'f :: Num a => a' means that f is a number...
23:49:02 <royal_screwup21> oh shit
23:49:03 <jle`> royal_screwup21: `let f = f + 1`
23:49:10 <jle`> that's defining f as itself plus one
23:49:26 <royal_screwup21> yup, thanks folks!
23:49:27 <jle`> there actually isn't any 'Int' that satisfies that
23:53:30 <mbw> Of course there's NaN...
23:55:11 <Axman6> NaN is not an Int
23:59:56 <mbw> Haven't encountered it yet in Haskell, and in C++ it always came to be because of core garbage from some uninitialized variable. Does it behave fundamentally different in Haskell?
