00:00:36 <kadoban> If the outer list is infinite you have problems. But otherwise, the typical way to do that is with a heap, where the elements are the inner lists and the key is the first element in the list.
00:00:45 <kadoban> And then you just do a bunch of pops and the obvious
00:01:07 <kadoban> The inner lists can be infinite and it's fine, if that helps.
00:01:20 <c_wraith> if the outer list is infinite, the problems are severe.  Like...  how do you ever know you've found the first element? :)
00:01:40 <kadoban> In some types you could know, like if it's Bounded I guess. But ... probably not great.
00:01:56 <kadoban> Seems really problematic in general, heh.
00:02:11 <pacak> kadoban: s/the first element/all the minBound  elements/
00:02:13 <sqooq> andromeda-galazy: do you actually think you would be able to help me?
00:02:48 <kadoban> pacak: Yeah, you couldn't ever give anything except a certain number of minBound elements, which is kind of funny.
00:03:20 <kadoban> Or infinite number sometimes I suppose.
00:06:09 <andromeda-galaxy> sqooq: if you have specific Haskell related problems, I'd be happy to help, or even to try to look at api documentation with you to help you understand how to use a library.
00:06:26 <`Guest00000> the lists' elements are parse alternatives, and i need them all sorted by descending munch
00:06:33 <andromeda-galaxy> if you have a specific question, not just "I don't know how to hook up mouse clicks and charts"
00:06:43 <andromeda-galaxy> `Guest00000: are you sure that the outer list might be infinite?
00:06:43 <`Guest00000> so, what does a infinite list mean
00:06:45 <sqooq> andromeda-galaxy: do you already know gtk well?
00:07:01 <`Guest00000> hmmmmm
00:07:04 <`Guest00000> okay
00:07:06 <`Guest00000> it means
00:07:16 <andromeda-galaxy> sqooq: I used to do a bit of gtk programming in C, I haven't done much in Haskell for some time.
00:07:25 <sqooq> hmm
00:07:34 <kadoban> `Guest00000: It means that no matter how many elements you take off, you never reduce how many are left.
00:07:44 <`Guest00000> using integers for representing munch wont' work in all cases
00:07:48 <sqooq> If you have discord, add me on there so I can just paste code easier, if you're curious
00:07:56 <sqooq> my name is cypress
00:08:15 <sqooq> cypress#4017 actually
00:08:36 <andromeda-galaxy> sqooq: I don't have discord, can you uses lpaste?
00:08:40 <MarcelineVQ> it's a little odd to ask people to put extra effort into helping you. conventionally you'd be the one putting the effort in to get help :D  lpaste.net is good for sharing and editing code
00:08:42 <sqooq> sure ...
00:09:02 <sqooq> haskell should really get a discord server
00:09:10 <sqooq> there's an fp server that I sometimes go to
00:09:16 <MarcelineVQ> there is a general fp discord
00:09:19 <MarcelineVQ> ye
00:09:20 <sqooq> and it's just so much easier to share code back and forth and discuss
00:09:32 <kadoban> sqooq: We manage somehow.
00:09:37 <pacak> sqooq: What's wrong with irc?
00:09:42 <MarcelineVQ> idk, lpaste's annotation feature is pretty great
00:10:12 <sqooq> pacak: lpaste is annoying
00:10:21 <sqooq> http://lpaste.net/358257
00:10:37 <sqooq> andromeda-galaxy, that code generates a graph with a single point
00:10:45 <sqooq> wait 
00:11:04 <`Guest00000> a parser (let p = liftA2 (:) (oneChar 'x' *> cookie) p <|> pure []) on a string ['x','x'..] won't return an infinite list of cookies
00:11:46 <`Guest00000> because it will want to sort for maximal 'x's eaten, which is infinity
00:11:53 <`Guest00000> sort by *
00:12:36 <`Guest00000> welllll
00:12:43 <kadoban> In the heap thing I described, the inner lists can certainly be infinite and it doesn't hurt anything. As long as they are in order anyway. If that helps.
00:13:00 <`Guest00000> let's just hope that the programs fed to my compiler are finite..
00:13:22 <kadoban> Seems like a good assumption
00:15:14 <andromeda-galaxy> sqooq: no idea yet if this is the "right" way to solve this (need to read more graphics.ui.gtk) but: try putting the chart in an ioref, create the drawing area manually, set the expose event on the drawing area to update it with the result of dereferencing that ioref instead of using a fixed chart the way that createRendereableWindow does it, and make an event handler for onClick that adds a 
00:15:20 <andromeda-galaxy> point to the ioref
00:16:24 <`Guest00000> but in a hypothetical fancy infinite compiler, that is, a compiler that accepts an infinite Haskell program, what information can we get from a program?
00:18:10 <`Guest00000> for example, it seems like we can add new declarations, and we can resolve known variables, but we can't detect unknown variables
00:18:44 <pacak> How would you go about figuring out what creates threads (via forkIO or similar) in a big haskell program that uses a ton of libraries?
00:18:54 <kadoban> You could sometimes output an actually correct output in finite time (like if main = print 42 and the rest is just garbage). And sometimes you can error out because something doesn't make sense from what you already know, but usually probably not much?
00:19:20 <sqooq> andromeda-galaxy: that's probably on the right track
00:19:28 <sqooq> considering: https://archives.haskell.org/projects.haskell.org/diagrams/blog/2015-04-30-GTK-coordinates.html
00:19:34 <MarcelineVQ> pacak: an option that comes to mind, thought it's a bit baroque, is to unpack your deps and search for forkIO
00:20:12 <`Guest00000> but question is, can we actually run a function which depends on a chain of functions descending into infinity? ("f = ... g ... \n g = ... h ... \n h = ... (and so on)")
00:20:22 <ertes-w> pacak: perhaps threadscope?  disclaimer: i have never used it myself, and i don't know if it can actually find the forks
00:20:23 <MarcelineVQ> pacak: would the caller of forkIO show up in a full profile?
00:21:03 <pacak> MarcelineVQ: That's 286 libraries + ~600 modules
00:21:30 <kadoban> `Guest00000: I guess? As long as each is productive. Like if they're all of the form   f n = 1 : g n    g n = 2 : h n     etc.
00:21:48 <`Guest00000> kadoban: can you typecheck them first?
00:21:50 <ertes-w> pacak: now make a flat list of those 286 libraries, unpack all of them using 'cabal unpack', then grep through all *.hs files
00:21:58 <pacak> ertes-w: threadscope will show that there is a thread being created.
00:22:06 <andromeda-galaxy> sqooq: yeah, I think that that is what you want
00:22:13 <pacak> ertes-w: I already have them unpacked....
00:22:24 <sqooq> andromeda-galaxy: I mean I hardly understand IORef
00:22:25 <kadoban> `Guest00000: I have no godly idea. Probably not? I'd think you'd have to assume the parts you haven't looked at yet actually make sense at a minimum.
00:23:02 <andromeda-galaxy> sqooq: anything in particular with them giving you problems?
00:23:16 <sqooq> refresh the lpaste and tell me if I'm on the righttrack
00:23:19 <andromeda-galaxy> an IORef is a "mutable reference" to a value that you can use in the IO monad
00:23:23 <sqooq> how do I use newIORef
00:23:36 <pacak> ertes-w: Not as bad as I thought - only 335 uses of fork.
00:23:42 <ertes-w> pacak: what if you looped through all modules and replaced 'forkIO' by (\c -> putStrLn "Forked in …" >> forkIO c)?
00:23:55 <andromeda-galaxy> sqooq: so readIORef will always give you back the "current value" of the reference
00:23:58 <MarcelineVQ> ertes-w: gosh, that's almost evil
00:24:07 <andromeda-galaxy> so when you first create the reference, you need to give some value that is the initial current value
00:24:19 <sqooq> and writeIORef, puts a new value right?
00:24:31 <ertes-w> MarcelineVQ: i'm an FRP implementor…  evil is my second name =)
00:24:38 <andromeda-galaxy> yes, but I would suggest using atomicModifyIORef here, which is not nearly as scary as it looks
00:24:40 <sqooq> andromeda-galaxy, so make a default chart there?
00:24:50 <sqooq> with newIORef?
00:25:00 <pacak> ertes-w: Recompilation will take a few hours and I'm not 100% sure that this thread is not created by one of the more exotic variants - fork with mask or something.
00:25:06 <andromeda-galaxy> yes. in your case maybe an "empty" chart with no points?
00:25:28 <andromeda-galaxy> sqooq: actually I take it back, atomicModifyIORef is a good habit to get in, but here you only have 1 writer so either is fine
00:25:55 <MarcelineVQ> could edit the source for forkIO/etc instead
00:26:05 <pacak> MarcelineVQ: I'm not sure about doing full profile, but it won't show if it's forked by a library...
00:26:07 <MarcelineVQ> unless one of the libs is using the primops directly :(
00:26:26 <andromeda-galaxy> sqooq: also in your expose event handler, I think that you probably want to use updateCanvas
00:26:54 <sqooq> from https://hackage.haskell.org/package/Chart-gtk-1.8.2/docs/Graphics-Rendering-Chart-Gtk.html?
00:27:06 <andromeda-galaxy> yeah
00:27:16 <andromeda-galaxy> look at the source of createRenderableWindow for inspiration
00:27:17 <pacak> MarcelineVQ: Might work, but I'm on older ghc so stack trace is not a thing yet (debugging some perfomance regression which result in switching to 8.2)
00:27:48 <andromeda-galaxy> your expose event can be like `readIORef chartRef >>= flip updateCanvas drawArea`
00:28:03 <`Guest00000> compiler doesn't like type errors; it won't compile a program even if no names that main depends on have faulty types. so for an infinite program to execute we'll have to defer type errors
00:28:14 <pacak> *sigh*. Exciting.
00:28:15 <`Guest00000> because type errors can always happen later
00:28:18 <ertes-w> pacak: that's true…  i'm thinking of ways to exploit the debugging stuff that GHC generates by default, but i'm not very experienced with using debugging tools for haskell
00:28:29 <MarcelineVQ> hmm? traces aren't new to 8.2
00:28:39 <pacak> We are on 7.10
00:28:45 <MarcelineVQ> alrighty
00:29:34 <pacak> ertes-w: Neither am I in general because stuff usually just works.
00:29:35 <ertes-w> pacak: well, what's the actual problem?  i mean: why does it bother you that extra threads are created?
00:29:55 <kadoban> `Guest00000: Yeah, seems required to do anything.
00:30:52 <pacak> ertes-w: Extra latency.  Trying to ensure sub  100us reaction time, for that I want to push some stuff to a dedicated capability but ghc every once in a while spawns stuff that works for as long as 30-50us there.
00:31:14 <mbrock> I made a thread about a trick I found yesterday and thought was neat: https://www.reddit.com/r/haskell/comments/6ylqcg/viewpatterns_and_patternsynonyms_enable_easy/
00:31:20 <sqooq> andromeda-galaxy: o boy I don't understand all that "set window [containerChild..." stuff
00:31:23 <sqooq> but I just copied it
00:31:36 <sqooq> but where would this block occur? In the main block?
00:31:41 <mbrock> it's probably no big revelation if you already know about view patterns and type synonyms
00:31:47 <davean> pacak: ooh, ick, that sounds nasty
00:32:15 <andromeda-galaxy> sqooq: which block?
00:32:58 <andromeda-galaxy> sqooq: the set window containerchild thing is probably safe to copy as is. although `containerAdd` might do the same thing for you, I do not know for sure
00:33:14 <pacak> mbrock: Looks very javascriptish to me.
00:33:33 <sqooq> andromeda-galaxy: refresh the lpaste and see if i'm on the right track
00:35:24 <andromeda-galaxy> sqooq: you are on the right track here. I would guess that you only need one of containerAdd and the G.set thing, maybe try removing that and see if it still draws the default chart?  But there is one big problem with that code:
00:35:38 <ertes-w> mbrock: nice!
00:35:48 <`Guest00000> then, we have option of never stopping the program after main has started, if the set of dependent names typechecks, but something other does not; or we have the option of executing the program and typechecking further garbage in parallel...
00:35:54 <andromeda-galaxy> you use chart inside the call to updateCanvas, so every time that the drawing area is exposed, the same original chart will be drawn
00:36:29 <andromeda-galaxy> rather you want to dereference the chartRef reference and pass the result of that to updateCanvas
00:36:38 <andromeda-galaxy> like 'readIORef chartRef >>= flip updateCanvas drawArea'
00:37:54 <sqooq> what does flip do
00:37:57 <andromeda-galaxy> also I think that onExpose drawArea $ const, it is maybe better to do as drawArea `on` exposeEvent $ liftIO
00:38:04 <andromeda-galaxy> @t flip
00:38:04 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
00:38:09 <andromeda-galaxy> :t flip
00:38:11 <lambdabot> (a -> b -> c) -> b -> a -> c
00:38:29 <andromeda-galaxy> it takes a function that takes two arguments and returns some type c and flips the order
00:38:46 <andromeda-galaxy> so updateCanvas chart drawArea === flip updateCanvas drawArea chart
00:38:58 <`Guest00000> so that even if main loops forever, when there is a type error, program will abort...
00:39:29 <andromeda-galaxy> so in particular `flip updateCanvas drawArea :: Renderable a -> IO Bool`
00:39:43 <kadoban> `Guest00000: This is a pretty interesting idea. It feels like someone must have explored it before, but hard to search for.
00:39:51 <andromeda-galaxy> then you can use >>= to take the IO (Renderable a) that you get from `readIORef chartRef` and pass it into that
00:40:57 <sqooq> I thought updatecanvas already had that type
00:41:18 <andromeda-galaxy> updateCanvas :: Renderable a -> G.DrawingArea -> IO Bool
00:41:28 <andromeda-galaxy> but what we want is a function mystery :: Renderable a -> IO Bool
00:41:46 <andromeda-galaxy> flip updateCanvas :: G.DrawingArea -> Renderable a -> IO Bool
00:41:54 <andromeda-galaxy> so flip updateCanvas drawArea :: Renderable a -> IO Bool
00:42:04 <sqooq> i see
00:42:19 <sqooq> `*** Exception: user error (widgetGetDrawWindow: no DrawWindow available (the widget is probably not realized))`
00:42:49 <sqooq> check lpaste for what I used
00:44:04 <sqooq> wait
00:44:09 <sqooq> why am I even doing that in the first place
00:44:12 <andromeda-galaxy> sqooq: you are calling widgetGetDrawWindnow before showing the window. you probably want to do that inside an event handler
00:44:28 <sqooq> ok I removed that line
00:44:34 <sqooq> because I forgot why I put that 
00:44:43 <sqooq> and now it displays the default chart
00:44:56 <sqooq> now I need to get the point to follow mouse coordinates
00:49:09 <andromeda-galaxy> sqooq: right. you probably want to do drawArea `on` motionNotifyEvent $ do
00:49:26 <andromeda-galaxy> and then do (x, y) <- eventCoordinates
00:49:28 <sqooq> andromeda-galaxy: how in the world am I going to update the point data in chartRef. I know I can do readIORef, but then I have toRenderable chart, how do i 
00:49:39 <sqooq> andromeda-galaxy, yeah I got that far
00:50:42 <sqooq> Am I right in thinking I have to somehow unwrap the Renderable wrapper?
00:50:42 <andromeda-galaxy> hmm, so maybe you actually want to put the layout or the list from layout_plots in the ioref instaed of the 'chart'
00:50:58 <andromeda-galaxy> and then do the toRenderable, etc. inside the expose event handler
00:51:00 <`Guest00000> i want infinite program compilers for various languages, and infinite program generators for them
00:51:31 <`Guest00000> the haskell language would be more interesting, because of type system
00:51:36 <andromeda-galaxy> but maybe not? I don't know the charts package very well
00:51:42 <`Guest00000> dependently typed languages would be even more interesting
00:52:58 <`Guest00000> brainfuck you could easily interpret lazily, but what about interpreting brainfuck backwards?
00:53:02 <sqooq> ah it looks like there's a renderablemap thingy
00:53:19 <sqooq> maybe that can help?
00:53:19 <sqooq> https://hackage.haskell.org/package/Chart-1.8.2/docs/Graphics-Rendering-Chart-Renderable.html
00:53:36 <sqooq> You might be right though
00:53:38 <kadoban> `Guest00000: Was thinking of BF, seems kind of boring. Backwards should just be impossible usually, right?
00:53:43 <sqooq> I don't think chart was designed with interactivity in mind
00:53:58 <andromeda-galaxy> sqooq: which function on that page?
00:54:00 <sqooq> so it's probably like once you make the chart, it's there, meaning I have to repeatedly make a chart from fresh
00:54:02 <andromeda-galaxy> that's probably true
00:54:09 <sqooq> mapPickFn
00:54:31 <andromeda-galaxy> ah yeah, I don't think that you want to mess with that
00:54:47 <ertes-w> kadoban: if p is a valid brainfuck program, (reverse p) is also valid…  but of course those are very different programs
00:55:02 <sqooq> so I think I actually have to store point information
00:55:20 <sqooq> layout doesn't change
00:55:25 <andromeda-galaxy> that's probably the easiest way to do it
00:55:27 <sqooq> gimme a sec
00:55:32 <`Guest00000> you have infinite (or finite) [Char] representing reverse brainfuck program, and you have to find out as much information about final state and reverse/suffix output characters as you can
00:56:18 <`Guest00000> so that the more you progress back-to-front, the more final state you have, and at the end/beginning you have full final state / output info
00:58:10 <`Guest00000> the program "???[-]++++++++ ++++++++ ++++++++ ++++++++ + ." has final current cell 33 and printed char '!', regardless of what's in ???;
00:58:30 <`Guest00000> there's always a needed assumption that prefix program never loops forever
00:59:03 <`Guest00000> because it does have a final state
00:59:20 <andromeda-galaxy> `Guest00000: I like this notion of starting with the result and then moving backwards to get an iteratively better approximations of the actual result...
00:59:25 <`Guest00000> well, that was some things to think about
01:00:14 <sqooq>  andromeda
01:00:27 <sqooq> (x,y) <- eventCoordinates ; readIORef pointRef >>= \x -> plot_point_values .~ [(x,y)] 
01:00:28 <sqooq> help
01:00:42 <sqooq> I know I'm doing lens wrong
01:00:46 <sqooq> but I don't want to just readIO
01:00:51 <sqooq> I need to update it
01:00:51 <`Guest00000> it's interesting to think how would you actually solve this
01:01:27 <mniip> andromeda-galaxy, `Guest00000 that's kind of how State works
01:02:19 <`Guest00000> wow, could we actually solve this with just lazy State?
01:02:52 <mniip> > (`evalState` undefined) $ do { undefined; put 123; get }
01:02:55 <lambdabot>  123
01:03:06 <sqooq> also andromeda-galaxy, I know I doubled my x there. I changed it to `poin`
01:03:17 <andromeda-galaxy> sqooq: so I'm not super familiar with the types used in this thing. but does it work to do:
01:03:44 <andromeda-galaxy> modifyIORef' (plot_points_values .~ [(x, y)])
01:04:37 <huey> hey
01:04:54 <andromeda-galaxy> sqooq: the way the lens is used in point' makes it look like `plot_points_values .~ [(x, y)]` is some function that takes whatever type represents our point-value and returns another value of that type but with the values set to x and y, so it should be okay to use with modifyIORef
01:04:55 <sqooq> to do!!!! to do what !!!!!!! aghghghg
01:05:03 <andromeda-galaxy> huey: hey
01:05:05 <andromeda-galaxy> sqooq: what?
01:05:14 <sqooq> just expressing anticipation
01:06:05 <huey> how's it going, andro?
01:06:11 <sqooq> andromeda-galaxy, but how do I do it to the point in ref
01:06:27 <sqooq> like I'm using >>= to unwrap it but then where does it go in the function
01:07:01 <sqooq> this is latest attempt
01:07:02 <sqooq>     modifyIORef pointRef >>= \point -> plot_points_style . plot_point_values .~ [(x,y)] $ point
01:07:51 <andromeda-galaxy> sqooq: look at the type of modifyIORef
01:08:08 <andromeda-galaxy> modifyIOref takes two arguments: an IORef that points to some value of type 'a', and a function that transforms an 'a' into another 'a'
01:08:25 <andromeda-galaxy> my point is that 'plot_points_values .~ [(x,y)]' looks like that function
01:08:38 <sqooq> true
01:08:44 <andromeda-galaxy> so try `modifyIORef' pointRef (plot_points_values .~ [(x, y)])`
01:09:03 <sqooq> still no
01:09:17 <sqooq> wait
01:09:20 <sqooq> why '
01:09:40 <`Guest00000> i remember, some time ago i wanted to make a symbolic brainfuck IDE; it would abstractly bind input characters to variables and display values in cells as expressions of variables, to aid in debugging brainfuck code and proving correctness...
01:09:48 <sqooq> o derp
01:09:49 <andromeda-galaxy> just to avoid putting a thunk into the io ref.  modifyIORef' is the strict version of modifyIORef
01:10:01 <sqooq> i've been using plot_point_values, it's plot_points_values
01:10:25 <sqooq> I still get a type error though
01:11:50 <sqooq> that line isn't the same type as everything else
01:12:02 <`Guest00000> the expressions would change as you step forward / step back in code
01:12:19 <andromeda-galaxy> sqooq: post the error?
01:12:28 <sqooq> I updated lpaste
01:12:29 <sqooq> http://lpaste.net/358257
01:12:37 <sqooq> o error
01:12:38 <sqooq> hold up
01:13:09 <sqooq> http://lpaste.net/358265
01:13:24 <andromeda-galaxy> also: can you put type annotations on layout and point'?
01:13:32 <kadoban> `Guest00000: I did something like that for another language a while back (bitcoin's script language). It was pretty interesting to mess with, but ultimately fairly useless. (in my case anyway)
01:14:34 <andromeda-galaxy> sqooq: so that error is basically telling you that the monad that you are working on isn't IO
01:14:48 <sqooq> andromeda-galaxy: idk what the type would be tbh but ghc-mod says layout is `layout :: (PlotValue y0, PlotValue x0, ToPlot a) => a x0 y0 -> Graphics.Rendering.Chart.Layout x0 y0`
01:14:57 <andromeda-galaxy> okay never mind that then
01:15:12 <`Guest00000> kadoban: do you have source code online?
01:15:14 <andromeda-galaxy> anyway, probably this is where you want to use another one of those `liftIO`s:
01:15:45 <andromeda-galaxy> liftIO takes a value IO a and "lifts" it into some other monad that can evaluate IO thingers
01:15:57 <kadoban> `Guest00000: Hm, I'm not sure if I do or not. It got to be kind of a mess towards the end and I never quite completed it. *looks*
01:16:00 <sqooq> andromeda, it's still expecting a bool
01:16:01 <andromeda-galaxy> also: \x -> updateCanvas (chart x) drawArea is just flip updateCanvas drawArea . chart
01:16:32 <sqooq> lmao
01:16:34 <sqooq> ook
01:16:44 <andromeda-galaxy> sqooq: add a line to your event handler that returns one? probably True, I think
01:17:01 <sqooq> yeah I did that
01:17:03 <sqooq> it worked
01:17:04 <sqooq> but why
01:17:12 <sqooq> I still don't understand the point of lines like that
01:17:34 <andromeda-galaxy> well if you think about the desugaring of do notation
01:18:00 <andromeda-galaxy> the "output value" of the last action (= the last line in do notation) is going to be the "output value" of the whole thing that we're composing together with d
01:18:03 <andromeda-galaxy> *do
01:18:16 <kadoban> `Guest00000: Doesn't look like it's in the usual places I throw things. I probably meant to after I cleaned it up, heh.
01:18:27 <andromeda-galaxy> in this case the api that we are using asks us to give it an action that in its funny monad that is kind of IO but more (I'll just call it 'm' for now) eventually produces a value of type Bool
01:18:48 <andromeda-galaxy> but the modifyIORef didn't have any boolean to return, it just went off and did some side effects and didn't have any output value
01:19:05 <sqooq> doesn't `void` help with that too?
01:19:07 <sqooq> or wait
01:19:12 <andromeda-galaxy> void is the opposite of that
01:19:15 <sqooq> void would be if you had a 
01:19:17 <sqooq> yeah
01:19:18 <sqooq> ninjad
01:19:20 <andromeda-galaxy> void takes an action that computes some type 'a' and turns it into ()
01:19:27 <sqooq> btw
01:19:28 <andromeda-galaxy> right
01:19:33 <sqooq> default gets displayed
01:19:39 <sqooq> but nothing happens when I mouse over it :(
01:19:44 <andromeda-galaxy> oh, and you probably also want to insert a call to widgetQueueDraw in there
01:19:46 <andromeda-galaxy> here's a fun test:
01:20:01 <andromeda-galaxy> move the mouse, then cover up the window with another window, then move that window away
01:20:05 <andromeda-galaxy> does that make the display update?
01:20:23 <__monty__> I've heard good things about intero but I'm not an emacs user so I haven't actually used it. The haskell-mode post on r/haskell lead me to find out intero doesn't support nix. There's quite a few issues that are related to nix that were closed for being related to nix by chrisdone (https://github.com/commercialhaskell/intero/issues/407). However, I can't find a _why_ for not supporting nix.
01:20:43 <sqooq> wait
01:20:47 <sqooq> cover which window with what
01:20:52 <sqooq> then move which window
01:20:58 <andromeda-galaxy> so when you ran your program, it opened a window, right?
01:20:59 <`Guest00000> in that symbolic brainfuck debugger, i didn't figure out how would expressions for arbitrary brainfuck loops look like
01:21:02 <sqooq> yes
01:21:14 <andromeda-galaxy> take any other window that you have, cover your program's window with it, then uncover your program's window
01:21:32 <sqooq> nothing happened
01:21:38 <andromeda-galaxy> hmm, oh well
01:21:47 <andromeda-galaxy> so here are two more things to try:
01:21:48 <sqooq> also
01:21:53 <sqooq> isn't this thing using relative cordinates
01:21:59 <sqooq> or like a skewed coordinate system
01:22:02 <sqooq> from my mouse coords?
01:22:05 <kadoban> `Guest00000: Mine was easier in that sense because there were no loops or anything, the language is specifically designed to be easy to enforce that it finishes in a (very) finite time. That's an interesting question, loops and etc.
01:22:08 <andromeda-galaxy> maybe
01:22:16 <andromeda-galaxy> I don't know how this works yet
01:22:25 <sqooq> lol
01:22:31 <sqooq> actually I don't think that should matter
01:22:44 <sqooq> the whole layout updates accordingly
01:22:52 <andromeda-galaxy> so insert a call to 'widgetQueueDraw drawArea' into the motionNotifyEvent handler
01:22:54 <sqooq> if I put the point at 500,500, everything else would adjust
01:22:59 <andromeda-galaxy> oh, nice
01:23:28 <sqooq> However
01:23:35 <andromeda-galaxy> and then also insert a call to `liftIO $ putStrLn $ show (x, y)`
01:23:47 <sqooq> that would mean the circle would always be in the center, which isn't really what I'd want, but let's just test things first
01:24:23 <andromeda-galaxy> actually that auto recentering may be part of why you think that it doesn't update to follow the mouse?
01:25:20 <andromeda-galaxy> anyway if the logging shows that you're getting the (x, y) updates, then your initial problem is solved - you just need to figure out how to get chart to do what you want it to
01:25:28 <andromeda-galaxy> unfortunately I'm going to have to leave soon btw
01:25:38 <sqooq> again I have to lift it?
01:26:26 <sqooq> can I insert it into my liftIO block I already have there to update the ref
01:26:43 <ertes-w> __monty__: just use haskell-mode
01:27:16 <andromeda-galaxy> you can insert it into that block yes
01:27:20 <sqooq> and no andromeda-galaxy, I put it in that block and it still doesn't update
01:27:21 <ertes-w> __monty__: intero is unlikely to support nix
01:28:00 <sqooq> and also, the axis should change
01:28:03 <sqooq> they don't
01:28:17 <sqooq> that's how I know it's not getting mouse input correctly
01:28:28 <__monty__> ertes-w: It's really a non-issue for me as I'm not an emacs user. I'm just curious as to the why. Does fpcomplete really push stack to the detriment of cabal or cabal+nix?
01:29:01 <andromeda-galaxy> hmm, that is strange
01:30:01 <andromeda-galaxy> sqooq: going by that blog post you linked to earlier, maybe before the widgetShowAll window you should do drawArea `widgetAddEvents` [PointerMotionMask]?
01:30:19 <ertes-w> __monty__: yes, this is probably a political/economical issue, not a technical one…  there is no technical reason as to why intero would have to enforce stack, and in fact there exists at least one variant/fork of intero that liberates the user from this requirement
01:30:45 <andromeda-galaxy> ertes-w: is that dante, or something else?
01:30:49 <ertes-w> __monty__: i think it's called dante, but i'm not sure…  i use haskell-mode myself
01:31:00 <sqooq> That works!
01:31:04 <sqooq> I mean it doens't really work
01:31:05 <ertes-w> andromeda-galaxy: ^
01:31:06 <sqooq> but things change
01:31:24 <andromeda-galaxy> ertes-w: aha, ty!
01:32:23 <andromeda-galaxy> sqooq: great! I probably need to be going now, but it sounds like we've gotten past the initial issue that you were having of beign unsure how to hook up the pointer events to the charts library, at least
01:32:27 <sqooq> thanks andromeda-galaxy: now I have to figure out how to somehow keep things constant
01:32:37 <sqooq> ye
01:32:38 <sqooq> bye
01:32:40 <sqooq> <3
01:34:28 <__monty__> ertes-w: Ok, thanks for confirming my suspicion. Sad to see fpcomplete isn't as non-evil as I thought.
01:35:21 <ertes-w> __monty__: i wouldn't say they're evil, but they are a business, so of course they would want you to use their products
01:35:31 <ertes-w> however, their products are still open source and freely available
01:35:40 <__monty__> I didn't say evil either, just less non-evil than I thought.
01:36:32 <andromeda-galaxy> sqooq: glad to be of help, bye!
01:36:38 <nshepperd> more importantly, if everyone at fpcomplete uses intero and stack, that's probably the combination that will be worked on
01:37:37 <__monty__> I see no future in a version of intero that'll only support stack in perpetuity, it's open source so there will be an alternative that does support plain cabal or something like cabal+nix. It's a bad business decision. I understand not actively supporting it but that doesn't require actively avoiding PRs that improve the situation.
01:46:53 <kadoban> __monty__: In some sense that's true.. But, just speaking generally, even if someone does a PR that supports X fully, and the code is perfect and it's tested to hell and etc., you then have to maintain that forever. It's far from zero cost.
01:47:26 <kadoban> And if most/all of the devs you have don't even use whatever X is ... that's potentially a pretty big cost.
01:47:35 <__monty__> No you don't really. You can state clearly that you won't refrain from breaking the integration if it comes at a cost to stack integration.
01:48:52 <kadoban> __monty__: Ehh, that's pretty much impossible though. Then you have users depending on the thing, and code sitting around that has to be changed whenever you mess with stuff. You can't just seemlessly rip out the PR every time you make a change and then wait for someone to make a new fixing PR. That's just not realistic. Everyone will hate you, worse than if you just didn't accept the first PR.
01:49:42 <__monty__> Your thesis is that every change would break the integration though. I don't believe it would.
01:50:02 <kadoban> No, just that many would break it, or require examining it at least.
01:52:12 <maerwald> __monty__: you can see that sentiment in a lot of opensource projects
01:52:20 <__monty__> I still don't think it's unrealistic. I'm sure another shop that does use just cabal or nix would pop up and do the patching every time. The alternative would be to fork intero completely which'd incur more work.
01:52:42 <maerwald> basically ignoring active contributions for the sake of ignoring it, not for technical or maintenance reasons. They don't want to grow their team
01:52:55 <tdammers> just one thought
01:53:05 <tdammers> accepting a PR means accepting the maintenance burden that comes with it
01:53:09 <kadoban> __monty__: That's a possibility, but hard to guarantee.
01:53:12 <maerwald> not necessarily
01:53:36 <maerwald> let the guy who sent the PR join the team, require him to be active, otherwise remove the feature
01:53:46 <maerwald> dead simple
01:53:51 <__monty__> tdammers: I disagree. If you don't state clearly that you don't, sure. But it's not like accepting a PR is like signing a maintenance contract.
01:53:58 <tdammers> a more open-source-like approach would be to wait for them to fork your project
01:54:04 <maerwald> no
01:54:09 <tdammers> and then let free software dynamics battle it out
01:54:21 <maerwald> that's exactly not what opensource should be about
01:54:29 <maerwald> and healthy opensource projects don't go that route
01:54:29 <tdammers> __monty__: no, but if you accept the PR, the code is going to be in your codebase, and you will be dealing with it
01:54:54 <maerwald> code is modular, can be made optional
01:55:03 <maerwald> you don't have to deal with it unless you want to
01:55:12 <tdammers> my point is, rejecting the PR doesn't mean you reject the idea
01:55:20 <maerwald> depends on the reason
01:55:21 <tdammers> it just means that you don't want to take on any responsibility for it
01:55:28 <maerwald> then it's not a proper reason
01:55:34 <tdammers> why no
01:55:35 <ertes-w> maerwald: i feature probably can't be removed as easily a few months down the line
01:55:45 <maerwald> the reason is you don't want to grow your team and allow active collaborators
01:55:45 <tdammers> it's pretty simple
01:55:55 <kadoban> Even the "removing that feature" part is going to be non-trivial in any sane project. So you're setting up fun dilemas for future-you unless you trust this new team member immediately and fully, and don't care about bus factors.
01:56:14 <maerwald> look at leksah, it has a few features that are long broken, because they are optional at compile time
01:56:20 <maerwald> if you want them, fix them, maintain them
01:56:26 <ertes-w> in any case, that's their decision, and they are free to make it…  i can understand why they reject such PRs (if they really do), and i might make the same decision in their place
01:56:42 <ertes-w> again: it's still free and open source, so you can fork it
01:56:49 <tdammers> my philosophy is that if it's too complex for the actual team of maintainers to maintain properly, it needs to be made simpler
01:57:12 <ongy> there's also a big difference between decentralized open source projects, and a company that provides an internal tool to the public as open source project
01:57:19 <tdammers> and since making thing simpler is harder than keeping them simple in the first place, rejecting PRs that introduce complexity is, IMO, a valid response
01:57:31 <ertes-w> my perspective on stack is: i don't like its approach, so i don't use it, and that entails not using intero either…  it's simply a technical decision everybody is free to make
01:57:42 <tdammers> yes, and how much of a fuss the project's local culture makes about forks
01:57:52 <__monty__> tdammers: Most of the issues related to nix support aren't complex though. Things like, if intero's already in the path, don't reinstall it with stack.
01:58:00 <maerwald> all code introduces complexity, but it can still be an optional module at compile time you never have to even compile or deal with, unless you want to
01:58:35 <tdammers> maerwald: in that case, I would probably go through the trouble of making things modular at the project level, idk, provide some sort of plugin system
01:58:54 <tdammers> that's a one-time complexity investment, but once in place, it removes a number of N+1 problems
01:59:07 <tdammers> and it allows splitting up and containing the complexity of individual plugins
01:59:08 <maerwald> well, they are obviously not interested in a plugin system
01:59:12 <kadoban> __monty__: Judging based on how contributions to stack itself work, I doubt they'd reject PRs like that, that just fix things with little cost.
01:59:20 <tdammers> OTOH, the kernel project's approach is pretty damn good too
01:59:23 <ongy> at that point just tell people to run their own branch and rebase when they want to
01:59:35 <tdammers> everything in one codebase, but maximally decentralize development
01:59:42 <maerwald> ongy: that's a lot harder than you think
01:59:44 <__monty__> kadoban: They did close the issue though. Without even inviting a PR.
02:00:06 <ongy> maerwald: if you run a code base with intree branches that can be broken at any point, I really don't see the difference
02:00:10 <maerwald> I've done that with i3 for almost a year, you waste a lot of time rebasing and restructuring and fixing your patch
02:00:21 <tdammers> IMO the real problem here is a different one anyway
02:00:36 <tdammers> namely, that many open-source projects are driven by corporate-political agendas
02:00:47 <maerwald> tdammers: well, no
02:00:55 <maerwald> tdammers: depends on the corporation
02:01:03 <tdammers> of course it does
02:02:00 <tdammers> but when I look at the way fpcomplete acts in the community, it's pretty obvious that their main incentive is to support their own operation
02:02:03 <tdammers> which is fine, mind you
02:02:39 <maerwald> well, they can do whatever they want, but whether I find that "fine" in terms of opensource behavior is a different thing
02:02:41 <tdammers> but it sometimes borders on trying to nudge the community as a whole into a profitable direction for them
02:03:18 <tdammers> and it sometimes feels like their open-source projects are leverage for that
02:04:45 <kadoban> tdammers: Any particular example?
02:05:03 <tdammers> stack is a pretty good one
02:05:18 <tdammers> don't get me wrong, I use it all the time, it works very well
02:05:31 <tdammers> but it does incentivize a particular workflow
02:05:36 <kadoban> __monty__: This one I assume? https://github.com/commercialhaskell/intero/issues/371 ya, doesn't look like the best handled issue ever for sure.
02:06:03 <kadoban> tdammers: In what sense?
02:06:14 <cocreature> tdammers: it does but I don’t see how that workflow results in fpco making a profit
02:06:54 <tdammers> cocreature: indirectly. they had a workflow; they wrote a tool to support it
02:06:57 <tdammers> nothing wrong so far
02:07:28 <tdammers> but then they made use of the poor state of existing tools (cabal, particularly) to push their tool as *the* tool for haskell development
02:07:49 <tdammers> so now the entire community is more likely to adopt their workflow
02:08:11 <tdammers> which is good for them, because it means more and more stuff will work well with their workflow, at the expense of potential other workflows
02:08:19 <kadoban> I'm not really sure what we're referring to as a workflow here. Just using stack?
02:08:32 <ongy> and I feel like they overstate the troubles of cabal. Or maybe I'm too late to have witnessed them
02:08:33 <tdammers> using stack implies a project-centric workflow
02:08:58 <tdammers> and stack does that really well
02:09:09 <cocreature> I’m not sure that argument holds up. the work they put into developing stack and pushing it far outweighs the benefits they gain from that for their own projects.
02:09:32 <kadoban> ongy: It had some pretty glaring problems when I started haskell. Like having absolutely no even vaguely secure way of downloading packages (no HTTPS even). The sandboxes were funky and unreliable, etc.
02:09:54 <maerwald> ongy: that is correct
02:10:20 <tdammers> in all fairness, cabal has made some huge leaps since stack arrived on the scene
02:10:23 <kadoban> tdammers: What tooling *doesn't* imply a project-centric workflow? Stack does work outside of projects as well, for example the script-interpreter thing and runghc and etc.
02:10:47 <cocreature> stack was the best thing that happened to cabal development in quite some time :)
02:11:19 <ongy> kadoban: sandboxes still are a bit wonky. But I think they just got low priority since the new-* stuff is being worked on
02:11:23 <kadoban> And yeah I'm not really sure how that financially helps fpcomplete, having a project-centric workflow, even granting the premise? I seem to be missing something.
02:11:49 <ongy> I don't think cabal doesn't have issues, I just don't see them as glaring as I feel stack promoters do
02:11:58 <maerwald> people using and testing your tools does not help you? :>
02:12:10 <tdammers> kadoban: well, I would have preferred a system where dependency resolution works without having to use sandboxes and / or pinned versions, one where you could happily and fearlessly mix packages installed by the OS package manager, and globally or locally installed with a dedicated package manager
02:12:54 <cocreature> people using and testing your tools results in a lot of support work and I think it’s far from clear that the benefits outweigh this
02:13:01 <maerwald> uhm
02:13:01 <kadoban> maerwald: It does, but not as much as its cost.
02:13:07 <maerwald> definitely disagree
02:13:19 <tdammers> kadoban: look, for example, at Python. Project-centric tooling exists (virtualenv, requirements.txt, pip, etc), but a projectless workflow also works well
02:14:01 <kadoban> tdammers: I see. Yes, stack does not like to work that way indeed.
02:14:39 <cocreature> cabal new-build does also not work that way :)
02:14:42 <kadoban> But I'm not sure how that relates necessarily.
02:14:44 <tdammers> kadoban: in a way, you could say that stack succeeded *because* it broke the truce
02:14:55 <kadoban> What truce?
02:15:16 <tdammers> they basically said, OK, the problem we've been trying to solve is too hard, let's throw in some opinions and kill some people's workflow, if that means we can build something that actually works
02:15:39 <tdammers> the truct between "we want something that works in practice" and "we want something that does thing The Right Way"
02:16:00 <kadoban> Yes, that sounds correct. But isn't that the direction cabal-install is going too even, as cocreature might be saying (trying to avoid putting words in mouths just in case)
02:16:09 <__monty__> Maybe I'm just too inexperienced but I don't see how stack was a better solution than just hosting a stackage for cabal.
02:16:11 <michalrus> Hey, how can I translate an Exception caught by Control.Exception.catch into Servant’s throwError?
02:16:15 <kadoban> Not sure I agree with "the right way" part, but sure.
02:16:52 <tdammers> __monty__: stack is mostly that, or at least it was at first; stackage, plus a convenient command-line tool to automate dealing with it
02:16:59 <kadoban> __monty__: That's essentially how it started, if that helps. stackage was originally just cabal constraints
02:17:24 <kadoban> And some wrapper things for functionality that cabal-install lacked (like downloading securely) and etc.
02:17:29 <maerwald> stackage was a great idea
02:17:31 <tdammers> but now it also has project scaffolding, hackage uploading, package signing, compiler installation, test integration, etc. etc.
02:17:51 <cocreature> michalrus: depends™, throwError in servant requires that you produce an actual HTTP error. you’ll have to decide how you want to convert your exception into that
02:18:32 <cocreature> michalrus: a very simple conversion would be "\e -> throwError (err500 { errBody = show e })"
02:18:46 <tdammers> stackage was a bold, pragmatic thing to shake things up - people had been trying to get fluid dependencies working for years, and it wasn't really happening; stackage is the brute-force solution that says "forget fluid dependencies, let's just pin everything and be one with it"
02:19:05 <maerwald> tdammers: it's a little bit like systemd, both in technical and political terms :>
02:19:13 <tdammers> yes
02:19:26 <michalrus> cocreature: well, I have a function `convert :: SqlError -> ServantErr`, but… I can’t align the types. :c `liftIO $ E.catch action (e -> throwError $ convert e)`…
02:19:37 <tdammers> sacrifice a significant portion of the use case space in order to critically reduce the complexity of the problem
02:19:38 <michalrus> But I can’t use throwError in the handler, because it wants IO.
02:19:49 <tdammers> naturally those on the wrong side of the use case spectrum will be hurt
02:20:19 <maerwald> tdammers: well, the problem with fluid dependencies is... no one ever asked the people who have experience with it. There are rolling-release linux distros that have been doing this for years and have gathered valuable knowledge, tooling, methods etc.
02:20:37 <michalrus> cocreature: and throwError is ExceptT ServantErr IO, not just IO…
02:20:38 * michalrus lost
02:20:40 <kadoban> tdammers: Are there that many people on that side of the use case? What are they using? cabal-install was just awful for me before I started using sandboxes. And aren't sandboxes just a pretty small step away?
02:20:43 <cocreature> michalrus: use catch from Control.Monad.Catch and move the liftIO around action
02:20:45 <ongy> how old exactly is stack?
02:20:57 <michalrus> Woooo, just what I wanted! Thank you. ♥ ♥
02:20:57 <cocreature> michalrus: i.e. catch (liftIO action) (\e -> throwError (convert e))
02:21:03 <michalrus> Yes, awesome.
02:21:10 <michalrus> I didn’t know about Control.Monad.Catch, silly.
02:21:13 <michalrus> ^.^
02:21:33 <tdammers> kadoban: well yes, that's why stack succeeded - the people on the other side didn't really have a working toolchain either
02:22:34 <cocreature> at this point the main difference between "cabal new-build" and "stack" is package pinning vs dependency solving. they both support either of those approaches but are clearly geared towards one
02:23:51 <cocreature> and that’s a dispute that will probably never be settled so they will probably both continue to exist.
02:24:09 <cocreature> and tbh, if people would stop fighting that would be completely fine. a bit of competition is healthy
02:25:02 <tdammers> that's probably the biggest takeaway
02:25:17 <tdammers> back when cabal was the only solution, things were bad
02:25:30 <tdammers> now we have three approaches, and they're all pretty OK
02:25:33 <__monty__> Main thing I like about stack right now is the ease of using it as a script interpreter, makes the script more portable. Nix can be used similarly but was prohibitively slow for me.
02:26:39 <kadoban> I like the script interpreter thing quite a bit as well.
02:27:35 <kadoban> cocreature: I think I see more complaints about the fighting than I actually see the fighting. Just me?
02:28:27 <cocreature> kadoban: maybe I should spend less time on twitter and reading issue trackers ;)
02:28:34 <kadoban> __monty__: Heh, apparently this just got updated with a much better response: https://github.com/commercialhaskell/intero/issues/371
02:29:01 <kadoban> cocreature: Hah, maybe. Oh ya, some of the stack and cabal-install devs seem to hate each other quite a bit, I have noticed that.
02:29:14 <kadoban> (in the issue tracker(s))
02:29:30 <kadoban> I thought we were talking about fanboy stuff on here I guess, or that's what I was thinking of anyway.
02:29:49 <cocreature> kadoban: you’re definitely right that it’s a relatively small group of people that is actually fighting but sadly they are very vocal
02:30:17 <kadoban> True, as usual in most things I suppose :(
02:30:32 <cocreature> humanity sucks
02:30:57 <__monty__> I wasn't fanboying, I just noticed every nix issue was closed with the curt "nix is not supported." At least have a canonical issue to point to on why and what kind of PRs might still get accepted.
02:31:42 <kadoban> __monty__: Wasn't implying that you were (or anyone else was), if that wasn't clear.
02:32:18 <__monty__> Didn't take it that way, just clarifying since I did start the discussion.
02:33:01 <kadoban> Okay, just making sure.
02:34:38 <maerwald> well, I can understand they don't want to support nix
02:34:50 <maerwald> you shouldn't have to support a "distro"
02:36:00 <Cale> maerwald: nix is a build system and package manager though.
02:36:09 <Cale> maerwald: nixos is the distro
02:36:14 <maerwald> I know
02:36:18 <maerwald> which is why I said "distro"
02:37:52 <maerwald> nix does a lot of things different and breaks a lot of software that needed patching. I can understand that some projects say they don't care about that hackery
02:39:17 <__monty__> But intero supports stack which supports nix, albeit half-assedly.
02:39:29 <srhb> __monty__: More like quarter-assedly.
02:39:30 <srhb> At most.
02:40:36 <maerwald> the distro I contribute to also breaks things, because it has a non-standard file-system layout, which is then made FHS-compatible via default symlinks (but the PM itself cannot ever install to FHS-directories)... so you also need to patch a lot of build systems. Some projects say "get lost" and it's understandable
02:40:52 <maerwald> but it's not nearly as crazy as what nix does :>
02:41:20 <maerwald> basically debian does that too
02:41:49 <ongy> don't all build system allow --prefix= like arguments?
02:42:01 <maerwald> ongy: it gets more complicated if you want a proper cross environment
02:42:10 <maerwald> e.g. shared files must not go into arch-prefix and so on
02:42:22 <maerwald> so you need to control bindir, libdir, sharedir, whatnot all individually
02:42:42 <ongy> yea, cross environments are generally hacks
02:42:51 <ongy> sadly
02:43:01 <maerwald> nix pushes that even further ;)
02:50:32 <ertes-w> nix solves the issue of sharing files by what it incidentally calls "environments"
02:51:30 <ertes-w> they allow you to merge individual derivations, which is basically how things like user environments and build environments work
02:52:05 <maerwald> every solution depends on more implementation details and assumptions, that sometimes work, sometimes not
02:52:28 <ertes-w> in other words: even in nix build environments you still have only a small, semi-fixed set of, say, include paths for C or module paths for haskell
02:52:48 <maerwald> some distros even wrap headers in odd ways to make cross environment works... that worked for a long time, unless someone discovered that some packages manually parse headers instead of just including them... boom
02:54:49 <ertes-w> it's usually packages with hard-coded paths or hand-crafted build systems that need patching, and developers are actually fairly open to these kinds of abstractions…  the worse cases are usually: "sure, i'm happy to support the abstractions that nix needs, but you'll have to do the work of abstracting"
02:55:54 <maerwald> sure, but that's all non-standard hackery by then and it's reasonable to refuse to deal with such things, since those are basically distro-created problems, that could have been avoided if the distro didn't go the full-hack route
02:56:02 <maerwald> so I can understand if people just don't care
02:56:13 <ertes-w> non-standard in FHS terms, sure
02:56:29 <ertes-w> but the FHS is…  very 90's anyway =)
02:56:32 <maerwald> no
03:00:43 <ertes-w> whether you call these things hacks is a matter of perspective…  in my view they are abstractions, because nix support really only needs build systems to be more parametric and deterministic than traditional ones
03:01:50 <ertes-w> "hacks" are things that *break* abstractions, not things that *require* them
03:01:58 <cocreature> that’s the case for build systems but things like editor tooling need actual hacks to redirect all invocations via nix-shell and stuff like that
03:02:49 <maerwald> ertes-w: not, hacks don't break things, they just assume stuff that is not specified to be assumed anywhere 
03:03:01 <maerwald> so it may work, until it doesn't
03:05:51 <maerwald> e.g. spacefm broke on nix, because it doesn't invoke bash via PATH... for good reasons. So that was an assumption that worked most of the time
03:06:56 <ertes-w> maerwald: that's a case of missing abstraction: PATH makes executable paths parametric
03:07:29 <maerwald> ertes-w: there is an abstraction: FHS
03:07:39 <maerwald> relying on PATH has security implications
03:08:46 <maerwald> most init systems also use absolute paths to whatever binary they invoke
03:08:47 <ertes-w> FHS is not an abstraction; quite the contrary: it's a standard for hard-coded paths
03:09:01 <maerwald> ok, terminology nitpicking
03:11:47 <ertes-w> i'm not going to respond to that…  in fact the whole discussion isn't very interesting…  if you don't like nix' approach, don't use it
03:12:38 <maerwald> that wasn't the argument... if you break every standard there is and make a lot of assumptions about how packages work... the go to upstream developer and all tell them to support your corner case... you should expect that people say "no"
03:17:57 <ertes-w> they are free to do that, and it's a question of whether we find enough value in nix that we go through the trouble of coming up with suitable hacks to handle those cases
03:18:12 <maerwald> sure
03:18:20 <__monty__> maerwald: On nix spacefm's problem wouldn't exist in the first place. It's a better solution even.
03:18:39 <maerwald> __monty__: ofc, it was fixed by allowing an individual path to bash at compile-time
03:19:10 <__monty__> That's still more of a hardcoded solution than'd be necessary with nix though.
03:20:28 <__monty__> Btw, the r/haskell thread linked to what I'll consider as the canonical intero+nix issue: https://github.com/commercialhaskell/intero/pull/52#issuecomment-223744909
03:21:02 <__monty__> Would be nice if that was linked every time a nix issue is closed though. I couldn't find it by searching.
03:21:34 <__monty__> Or alternatively a small section in the README pointing to this.
03:22:32 <maerwald> "and every time a user has to enter a configuration option to get basic functionality, we've failed as a user experience" -- hilarious
03:22:38 <maerwald> but it explains their reasoning yeah
03:23:18 <maerwald> hint: you can have configuration options with defaults :>
03:24:28 <ertes-w> actually i sympathise with their strive for flawless UX…  if one uses stack, by all means, they should use intero
03:24:48 <maerwald> ertes-w: did you  mean that the other way around?
03:24:56 <ertes-w> no
03:25:06 <maerwald> I don't understand why I should use intero if I use stack :o
03:26:41 <boj> you don't have to
04:54:44 <JazzyEagle> Hey, all.  Hoping someone can help.  Using Persistent (and attempting to avoid esqueleto, if possible), I need to return the first record in a table.  selectFirst and get both seems like good candidates, but I can't figure out how to tell them which table I want them to pull from.  Any help would be appreciated.  Thanks in advance.
05:06:24 <cocreature> JazzyEagle: I’m not too familiar with persistent but afaik it automatically infers the corresponding table based on types
05:12:58 <JazzyEagle> cocreature: It does, and that's what drives me nuts about it.  Sometimes, it can't seem to figure out what to use and trying to use Type casting has caused different errors.
05:13:43 <cocreature> JazzyEagle: you’ll have to be a bit more precise. what errors are you seeing?
05:14:12 <cocreature> also type annotations are not casts. they don’t do any conversions.
05:16:15 <Psybur> dmwit, I made my own version of the algorithm we were discussing yesterday: https://ideone.com/9YESuA
05:16:17 <JazzyEagle> Sorry, poor choice of words.  It's early in the morning here.  :)
05:16:27 <Psybur> Allows dynamic intervals now
05:17:24 <JazzyEagle> cocreature: Now that I'm looking at it, I think the problem has more to do with Monads (my arch nemesis)...
05:18:07 <sm_> it sounds like you haven't got the type signature quite right
05:18:25 <sm_> and monads are your friend here (really :)
05:18:44 <JazzyEagle> I'm in a simple function "selectQueuedSong :: Maybe (Text, Text)", performing "mqueue <- selectFirst [] []" and getting issues because of ReaderT.  I don't know why I didn't see that earlier.
05:18:54 <Psybur> Does anything strike anybody as not "Haskelly" in this code? https://ideone.com/9YESuA
05:19:51 <JazzyEagle> sm: Using a straight Monad is fine now.  It's transformers and converting from one Monad to another that trips me up.
05:20:18 <JazzyEagle> The biggest thing that frustrates me is I just want the value inside the monad, but I always get returned the whole danged thing and struggle to figure out what to do with the thing.
05:20:38 <maerwald> heh
05:20:39 <JazzyEagle> ReaderT is not a Monad/Transformative Monad I'm used to working with directly.
05:21:08 <sm> I hear you.. I haven't used persistent recently enough to help much
05:21:28 <sm> maybe stare at a bunch of yesod example code ?
05:21:49 <JazzyEagle> I tried.  All of the persistent examples show some sort of filtering criteria...
05:22:16 <sm> when you figure it out, it's going to be annoyingly simple
05:22:20 <JazzyEagle> I suppose I could try something like selectFirst [ QueueId ==. 1 ] [], which seems overkill.
05:22:47 <JazzyEagle> But even once I figure that out, I need to extract the response out of the ReaderT so I can use it in a plain Maybe.
05:22:50 <cocreature> Psybur: using `seq` as a variable name is a bit weird since there is already a function in the Prelude by that name but apart from that it looks pretty good! 
05:22:55 <JazzyEagle> That's the part I have to figure out first.
05:23:03 <maerwald> Psybur: that looks like normal haskell code
05:23:43 <cocreature> JazzyEagle: I’m repeating myself but you really need to show us some code and the error message, if you’d like help :)
05:24:04 <JazzyEagle> cocreature: Sure.  Hold on.  I'll lpaste it...
05:25:17 <Psybur> cocreature, gotcha. thanks
05:25:43 <Psybur> maerwald, thanks for the input
05:30:34 <JazzyEagle> Code and errors:  http://lpaste.net/358271
05:31:07 <JazzyEagle> Again, I know my first problem is running selectFirst within a Maybe Monad, as that returns a ReaderT type.
05:31:49 <JazzyEagle> I don't know how to solve that, exactly.
05:32:57 <JazzyEagle> lift, I'm guessing?  Not sure if it will work, though...
05:33:31 <JazzyEagle> Nope.
05:33:50 <cocreature> you can’t do IO (and db queries definitely inolve IO) in Maybe
05:34:04 <cocreature> you’ll have to change the type signature of selectQueuedSong
05:35:28 <JazzyEagle> Ok.  Would a db call work in a straight IO Monad, or do I need a different Monad than that, even?
05:37:01 <cocreature> take a look at the type signature of selectFirst
05:37:01 <locallycompact> when will stack lts get ghc 8.2
05:37:14 <cocreature> it returns something of type "ReaderT backend m …"
05:37:42 <cocreature> and you have various constraints on "m" and "Backend"
05:37:55 <cocreature> choosing m=IO should work
05:38:06 <cocreature> or just leave it polymorphic
05:39:36 <JazzyEagle> Dang kids.  Sorry, I'll have to come back later.  I think what I need now is a class on Transformative Monads...  lol
05:39:42 <JazzyEagle> bbl
05:40:49 <maerwald> or switch to a library that is less insane :/
06:25:52 <sm> JazzyEagle: give it a little time, after a few attempts it will seem clearer
06:27:00 <sm> other web libraries will present similar monadic challenges, I think
06:29:32 <sm> sometimes it works to write the function you want (selectQueuedSong) without a type signature (since you don't know what yours should be yet) and see what type is inferred in GHCI
06:31:01 <sm> showing more of the program would allow us to give more help
06:31:14 <maerwald> sm: well, snap for example naturally exposes a lot more IO, so whether you do crazy monad transformers further down the line is absolutely up to you
06:31:21 <maerwald> it's not really a DSL in that sense
06:31:47 <sm> maerwald: is there not a special request handler monad in snap ?
06:32:05 <maerwald> there is the Snap monad, but it exposes IO
06:32:23 <sm> ok.. I haven't programmed either in quite a while
06:32:35 <maerwald> but darcsden uses snap :>
06:32:39 <sm> yep
06:32:52 <maerwald> have you been slacking?!
06:32:53 <sm> either way, JazzyEagle would be having trouble :)
06:33:20 <sm> by no means! hledger and client work are moving forward!
06:33:25 <maerwald> ah
06:33:36 <sm> I need more minions
06:33:39 <maerwald> heh
06:34:38 <sm> maerwald: once or twice a month I fantasise about investing more in darcs hub and adding a SAAS component
06:36:18 <sm> but I cant convince myself darcs is strong enough to make something much better than what we have
06:38:24 <platz> what would be better, marking a module full of records with StrictData, or applying strictness annotations to each primitive field?  
06:38:47 <platz> for example, how would StrictData affect a record that contains lists?
06:39:31 <cocreature> platz: personally I prefer manual strictness annotations because I find it confusing to keep track of whether StrictData or even worse Strict is turned on in a module
06:40:11 <platz> i could see that, sure
06:40:37 <cocreature> platz: if your record contains a list, then that list will be forced to whnf if you force the record to whnf
06:41:29 <platz> that is identical to Rec { field1 :: ![Int] } then?
06:41:35 <cocreature> yep
06:41:37 <platz> cool
06:41:59 <platz> or  Rec { field1 :: ![!Int] } rather
06:42:26 <cocreature> that’s not valid syntax
06:42:43 <platz> hmm, ok
06:42:45 <cocreature> bangs belong to fields not types.
06:43:16 <cocreature> it just happens that the syntax coincides with the type specification of that field
06:44:02 <platz> i'll go with the manual annotations, thanks
06:47:43 <JazzyEagle> Ok, I'm back.
06:48:56 <JazzyEagle> sm: maerwald:  FYI:  This is actually going to be a separate program from a web framework, called by Liquidsoap for a radio station I'm going to set up.  The db will be shared with either Snap or Yesod (haven't decided yet) for a conjoining website, but not at that point yet.
06:49:02 <JazzyEagle> I'm still just trying to get the backend set up.
06:49:45 <JazzyEagle> I just chose to use Persistent for two reasons:  1) It works with both Snap and Yesod, and I haven't 100% decided on either, and 2) It's used in the Yesod project I help with, Snowdrift.coop, so learning to work with it for my own project helps me learn how to do more for the project.
06:50:28 <JazzyEagle> Using it within Yesod is obviously a little bit easier, as Yesod and its types were designed to allow db calls to run within them.
06:50:53 <tdammers> at this point, I would avoid classic "web frameworks" probably
06:51:06 <JazzyEagle> tdammers: How do you mean?
06:51:17 <tdammers> build an API-only logic backend that interfaces with the DB
06:51:26 <tdammers> and then whatever frontend you need on top of that
06:51:48 <JazzyEagle> Oh, yeah.  Definitely.  The code I'm using is super minimal at this point, but it still relies on Persistent, which is what I'm trying to figure out how to use.
06:51:49 <tdammers> snap and yesod are great, but their main use case is building server-centric website-like apps
06:52:29 <tdammers> so they come with a lot of stuff that you don't really need for an API; something like Servant, or maybe even just Scotty, is going to be easier to work with
06:52:59 <tdammers> you can of course still use yesod or snap for the frontend if you want, but rather than having them talk to the database directly, they can just make API calls
06:53:01 <JazzyEagle> Liquidsoap will be calling this thing I'm working on as a standalone executable.  The piece I'm working on right now is going to do two things:  Check to see if any songs have already been queued (meaning a user requested a song, which will obviously come later) and, if not, grab a song at random based on a certain criteria.
06:53:12 <sm> I would seriously not recommend Servant at JazzyEagle's current level of type-fu
06:53:14 <JazzyEagle> That's it, nothing more.  No Snap or Yesod in the standalone program I'm making right now.
06:53:22 <tdammers> sm: good point. scotty then.
06:54:01 <JazzyEagle> I kind of want the challenge of the type-fu, actually.  As frustrating as it is to me, I would hope it'd help me with my type-fu.
06:54:15 <tdammers> anyway, I don't think the API is the hurdle here right now
06:54:22 <JazzyEagle> Though, tdammers knows me well enough to know I've struggled with type-fu since I started with Haskell, so maybe I *should* consider an easier web framework...;
06:54:46 <tdammers> the database side of things actually seems pretty straightforward if described in relational database terms
06:54:50 <JazzyEagle> At least, for the first pass.
06:54:53 <tdammers> you have a table of songs
06:55:18 <tdammers> and a table (song_id, requested_by, timestamp_requested) or something like that
06:55:25 <tdammers> forming the song queue
06:55:30 <JazzyEagle> Yep.
06:55:40 <JazzyEagle> tdammers: I pasted this earlier, not sure if you saw it:  http://lpaste.net/358271
06:55:47 <JazzyEagle> it has my config/models layout in there already.
06:55:52 <sm> JazzyEagle: your use of db-accessing functions inside a pure Maybe ... function is something you need to figure out first, that will not work with any db lib no matter how easy
06:56:12 <JazzyEagle> Yeah, I know, sm
06:56:29 <tdammers> personally, I'd find a library that allows me to write the SQL as SQL
06:56:41 <tdammers> plain hdbc, or (shameless plug) yeshql
06:56:54 <JazzyEagle> Ah, yes.  The lib you wrote that I didn't get a chance to read...
06:56:59 <tdammers> :)
06:57:20 <JazzyEagle> I should probably read it again.  hehe
06:57:27 * sm has not found any db lib that was not painful to get started with. Persistent at least is a fairly well trodden path
06:57:56 <phadej> tdammers: postgresql-simple + http://hackage.haskell.org/package/simple-sql-parser +  template-haskell, and you are good if you only write SELECTs :)
06:58:44 <phadej> I don't know what you are talking about though
06:59:18 <tdammers> phadej: yeshql does roughly that, but it also works fine with non-SELECT queries
06:59:38 <tdammers> phadej: also, mapping between SQL result sets and typed values, and type annotations in queries
06:59:44 <phadej> tdammers: cool!
07:00:21 <JazzyEagle> tdammers: Since I trust your opinions, how easy would it be to utilize yeshql within a web framework?
07:00:38 <phadej> i'd say, very easy
07:02:47 <sm> that does look cool, as a lower-level interface
07:03:13 <JazzyEagle> It does seem pretty straightforward and returns an IO Monad.  Those I can work with...
07:03:14 <tdammers> JazzyEagle: pretty easy, depending how opinionated the framework is
07:03:26 <JazzyEagle> Ok.  I'll give yeshql a try.
07:03:29 <tdammers> sm: yes, it's low-level on purpose
07:03:39 <JazzyEagle> That won't help with Snowdrift.coop, but maybe that's for the best...
07:04:04 <tdammers> JazzyEagle: well, snowdrift is fairly baroque if you ask me... lots of yesod magic going on there
07:04:26 <sm> tdammers: do you use this exclusively, or is there a higher-level lib you'll use for some things ?
07:04:43 <tdammers> sm: I use it when it's appropriate... which is rather often IMO
07:04:56 <tdammers> sm: I do usually build more domain-specific abstractions on top of it though
07:05:09 <tdammers> e.g., I'll usually write some TH code to generate boring CRUD operations
07:05:29 <tdammers> but these tend to rely on project-specific conventions, so I won't bake them into a general-purpose library
07:06:13 <sm> it seems like a good starting place for working with dbs in haskell
07:06:29 <tdammers> I've gone rather far with this on one project, where I even embedded foreign-key relationship information in the types, and then had the TH code derive getByXXXX queries from that and such
07:07:14 <tdammers> alternatively, you could also build an abstraction model where you have pairs of query type and result set type, and then you could almost directly relate them to API request/response types
07:07:32 <sm> persistent's schema definition and low boilerplate is nice too
07:07:45 <tdammers> yes, it is
07:08:23 <tdammers> the thing is, as soon as you want to do mildly advanced SQL stuff, like say aggregation, pagination, foreign-key stuff, etc., things tend to get hairy with highly abstractive interfaces
07:09:10 <tdammers> in the worst cases, I've seen people consciously avoid writing efficient SQL because it would have made the application code really hard to maintain
07:17:42 <sm> very cool
07:18:43 <sm> I didn't understand all the return type syntax on first read, but I'm sure it'd make sense soon
07:19:33 <reactormonk> Any conduit people around? I've got the issue where a foldC doesn't fuse properly, and the intermediate elements are being held in memory, which ooms my machine.
07:19:39 <sm> eg I wonder how would name:insertUser :: Integer differ from name:insertUser :: (Integer)
07:19:41 * sm bookmarks
07:27:15 <cement> Integer is a single arbitrary precision integer, (Integer) is a single arbitrary precision integer in a tuple
07:27:47 <cement> I'm not 100% on what that means in terms of memory allocation, but as far as types, they are distinct
07:28:04 <exio4> are they?
07:28:20 <cement> as far as type checking
07:29:53 <sm> cement: this is in the context of yeshql, which is different
07:30:04 <cement> ah, ok
07:30:14 * sm was reading http://hackage.haskell.org/package/yeshql-3.0.0.1/docs/Database-YeshQL.html -> Syntax
07:30:36 <cement> I was about to note the type error, lol
07:34:45 <tdammers> sm: ah yes, that is one peculiarity
07:35:29 <tdammers> cement: we're talking yeshql type annotation syntax, not actual haskell
07:36:17 <cement> yeah, I did figure that out
07:36:50 <tdammers> the difference is due to how yeshql can either marshal entire rows to values, or individual columns to values and then wrap those values in tuples
07:37:51 <tdammers> if you specify :: Integer, yeshql will assume that you want to marshal the entire result set row to one Integer; if you write (Integer), it will instead assume that you expect rows containing one column each, and that you want to marshal these to "one-tuples"
07:38:00 <tdammers> in both cases the return type will be Integer
07:38:19 <tdammers> it makes more sense with custom types, for which you can have both FromSql and FromSqlRow instances
07:38:50 <tdammers> :: (Foobar) uses instance FromSql Foobar; :: Foobar uses instance FromSqlRow Foobar
07:39:14 <tdammers> :: Integer doesn't usually make sense, but :: rowcount Integer does for things like INSERT or UPDATE queries
08:16:45 <dumptruckman> Is stack ghc different from regular ghc?
08:17:28 <dumptruckman> i can't seem to use -main-is
08:18:38 <cocreature> dumptruckman: try "stack ghc -- yourparametershere"
08:20:32 <dumptruckman> just figured that out, thanks
08:20:33 <dumptruckman> 🙃
08:52:50 <paolino> hi, I have a data instance which is just a wrapper around a Double. Is there a way to derive Num class instance for it ?
08:55:44 <michalrus> Can I somehow do `newtype T = MkT { action :: MonadIO m => m () }`?
08:56:01 <michalrus> It works with `:: IO ()`, but, hmmm.
08:59:36 <paolino> michalrus, it's hiding 'm', so it looks to me you will be able to call only liftIO on that
08:59:57 <michalrus> :’
09:03:43 <raynold> ahh it's a wonderful day
09:26:30 <__monty__> I've been reading up on best practices for haskell development with nix and I found two significantly different methods. 1) Working in a nix-shell based on a nix file specifying the project's dependencies 2) (from jwiegley) Specify an environment containing all the packages you ever use in projects. Method 2 sounds appealing but uncommon so I was wondering whether there were caveats I missed?
09:27:53 <michalrus> I’d go with 1), what if you want to collaborate on that project later? Also, have you read https://github.com/Gabriel439/haskell-nix ?
09:28:19 <Cale> It seems mildly unreasonable to me to expect that all your projects will never have conflicting sets of dependencies
09:28:20 <cocreature> you can probably also run into problems if different projects require different versions or configurations of the same package
09:28:24 <__monty__> Yes, started from this and read/watched everything. https://github.com/shajra/example-nix
09:29:02 <__monty__> You can have different envs that overlap though.
09:29:25 <Cale> It's probably worthwhile, if you're using nixos especially, to *have* a derivation for an environment which is reasonably complete, just for when you're experimenting and don't really have a coherent project yet.
09:29:32 <michalrus> (Since we’re talking about nix, how do I easily display dependency versions used by cabal?)
09:29:36 <cocreature> __monty__: I thought the point of 2 is that you only have a single env?
09:29:36 <__monty__> Main advantage is you can do all your development offline and you have more control over when you want to update your dependencies. Rather than updating every time you start a nix-shell.
09:30:00 <__monty__> cocreature: No, you can have as many as you want. It's just not a per project thing.
09:30:23 <michalrus> (Got it, `ls $NIX_GHC_LIBDIR`)
09:30:31 <cocreature> well if you have different envs for different projects because they’re incompatible you start moving towards a per project thing
09:30:55 <__monty__> michalrus: Collaboration would still work with the cabal file or you could run cabal2nix to generate an appropriate default.nix.
09:31:37 <__monty__> cocreature: I don't mind moving towards, I'd just rather not start with the least convenient method : )
09:31:38 <Cale> But I just  nix-shell -p "haskellPackages.ghcWithPackages (pkgs: with pkgs; [whatever, I, want, goes, here])"  when I just want to play around with some packages.
09:31:57 <michalrus> __monty__: sooo you want to specify versions explicitly in the Cabal file, despite defining them implicitly by pinning a particular Nixpkgs SHA1?
09:32:40 <__monty__> michalrus: Not necessarily, like I said you could generate a default.nix or write one.
09:34:05 <__monty__> Having better control over when all the packages update sounds especially nice. Wouldn't want to jump into development of something for the next hour and spend 10min waiting for nix-shell to update everything.
09:34:25 <cocreature> __monty__: that’s why you pin nixpkgs
09:36:21 <__monty__> That's an option but I don't see an advantage for working on personal projects. Once there's a team using nix for a project that's probably the way to go.
09:36:36 <cocreature> *shrug* use whatever workflow works for you :)
09:38:35 <__monty__> I figured someone might see serious shortcomings I missed. I'd considered most of what was mentioned so I'm just gonna try it out.
09:54:11 <trigone> hi! is edwardk around?
09:59:32 <Naughtmare[m]> Does anyone know where I can change the default maintainer email that cabal init suggests?
10:00:36 <sm> ~/.cabal/config ?
10:02:06 <monochrom> No, the email address is not stored there.
10:03:21 <monochrom> I have a hunch that it looks at your .gitconfig :D
10:04:03 <Naughtmare[m]> I have changed my git email, but it didn't change the cabal default email
10:04:12 <Limeth_> How do I add `codeworld-api-0.2.1.0` to `build-depends` in my .cabal? It's telling me that it was unable to parse the file.
10:04:24 <monochrom> It changes for me.
10:04:47 <Naughtmare[m]> monochrom: I will try again then
10:05:42 <monochrom> Aw I need to change it back before I forget.
10:05:57 <Naughtmare[m]> Limeth_: The version needs to be separated like this: `codeworld-api == 0.2.1.0` or `codeworld-api >= 0.2` or something like that.
10:08:05 <trigone-poor-con> not sure if my message was transmitted, but i'm looking for the best lens library tutorial. i want to learn how it works inside, not just how to use it. thanks!
10:08:56 <Limeth_> Naughtmare[m]: Hmm, now it's telling me this: https://hastebin.com/viwafosufa
10:09:55 <fvh> hey guys. I'm writing instance for postgresql-simple and my type and table structure have different number of fields, so I want to omit some of them when build ADT in toRow function. How can I achieve that?
10:10:24 <fvh> meaning skip some table fields while constructing ADT
10:11:40 <Limeth_> Naughtmare[m]: Nevermind, I am blind, got it working now, thanks.
10:11:48 <Naughtmare[m]> Limeth_: Do what it tells you: `stack solver`. The package codeworld-api is not in the stack snapshot you're using so you need to specify that you want it in your build-depends section of your stack.yaml. `stack solver` will try to do that automatically.
10:12:22 <Limeth_> `stack solver` wouldn't work for me, as for some reason I don't have `cabal` in my `PATH`.
10:12:41 <Limeth_> But I added the lib into stack.yaml manually and it seems to be working now
10:14:05 <Naughtmare[m]> monochrom: I managed to change my email, it was using my .darcs/author file
10:16:24 <monochrom> Oh!
10:17:34 <amx> fvh: really toRow? not fromRow?
10:19:15 <fvh> amx: my mistake, fromRow of course
10:20:14 <cocreature> fvh: can’t you just change your query such that it doesn’t include those fields?
10:21:13 <cocreature> fvh: if that doesn’t work for you, you can also just use "field" but ignore the result for the fields that you don’t care about
10:21:42 <fvh> I found a way to do  `fromRow = (\_ t1 t2 -> Unit t1 t2) <$> (field :: RowParser Int) <*> field <*>` .. but don't like usage of `(\_ ->)` to reconstruct ADT
10:21:47 <cocreature> so "do x <- field; _ <- field; y <- field; return (x,y)"
10:24:49 <amx> you can also use <* instead of <*>
10:26:02 <fvh> cocreature: that's it!
10:26:08 <fvh> thank you guys
10:40:17 <eikke> Anyone ever defined a MonadTransControl instance for a stack of >=3 transformers?
11:13:17 <Naughtmare[m]> cabal new-run (with cabal-install-2.0.0.0) doesn't do anything (just says "up to date", is it not yet implemented?
11:15:05 <dmwit> Naughtmare[m]: I think the bit that actually does something didn't make it into the 2.0 release.
11:16:22 <dmwit> ?tell trigone I greatly enjoyed "Lenses over Tea".
11:16:22 <lambdabot> Consider it noted.
11:17:17 <dmwit> Naughtmare[m]: (...so you should build and install the latest cabal-install from github if you want that feature.)
11:22:29 <cocreature> if you want to use cabal new-* building from master is a good idea in general :)
11:23:18 <alanz> cocreature: building cabal from master, I presume
11:24:21 <cocreature> right :)
11:59:42 <Psybur> Can anyone tell me what ".~" means in the second code block in https://github.com/timbod7/haskell-chart/wiki/example-2 ?
11:59:46 <Psybur> Is it something to do with lens?
12:00:02 <Psybur> Oh and what does ".=" do?
12:01:36 <mizu_no_oto> Psybur: https://hackage.haskell.org/package/lens
12:02:05 <Psybur> Damn looks like I finally have to learn lens. Been putting it off. Looks scary :D
12:02:18 <phadej> dejavu, someone asked exactly same question yesterday (or day before)
12:02:31 <monochrom> Or you can postpone learning Chart.
12:02:55 <mizu_no_oto> Simon P.J.'s lens talk is pretty good
12:02:57 <phadej> monochrom: could you be more supportive?
12:03:02 <monochrom> Why is everyone asking about it anyway?
12:03:03 <hexagoxel> or you can learn exactly these to operators and move on.
12:03:08 <Psybur> monochrom, do you mean just blindly try to copy the Chart examples or use a different library?
12:03:09 <monochrom> No.
12:03:09 <hexagoxel> *two
12:03:18 <monochrom> Use a different library.
12:03:28 <Psybur> monochrom, any recommendations?
12:03:32 <c_wraith> Psybur, those are both "set this value" operations. the latter implicitly works on the state in MonadState
12:03:34 <monochrom> I don't have one.
12:09:01 <monochrom> For the record: What phadej really means is: "could you be more supportive for going down a rabbit hole, aka depth-first search?"
12:09:29 <monochrom> The answer is no, because I believe that depth-first search is the cause of XY problems. I am supportive for breadth-first search.
12:10:51 <mizu_no_oto> Psybur: do you understand, at a basic level, what lenses are for?
12:11:51 <Psybur> mizu_no_oto, manipulating nested data structures I believe
12:12:05 <mizu_no_oto> More or less, yeah.
12:12:45 <mizu_no_oto> originally, lenses were composable getters and setters.
12:14:13 <mizu_no_oto> the 'lens' library is built off of the observation that you don't need separate getters and setters, but can use a modifier as a getter or setter.
12:22:44 <hexagoxel> Psybur: Chart also exports the record fields, so you can translate the example to be lens-free, too.
12:25:39 <drdo> Hmm, got an "Illegal instruction" when running something compiled in a different machine
12:26:16 <drdo> Same architecture but different cpus, is there some sort of compat mode I need to enable in ghc?
12:27:00 <hexagoxel> Psybur: roughly like this: http://lpaste.net/358274
12:28:19 <Psybur> hexagoxel, thanks
12:53:43 <Fendoer> hm, has someone experience on segmentations faults with the repa library?
12:54:09 <sm> I'm guessing you have :)
12:54:29 <Fendoer> well, it's my first now :D 
12:56:04 <Fendoer> my problem is, i am using the repa-convolution library and i get a segfaul when i have about 2GB of data. The problem occurs, when i apply the same kernel for more than 5 times one the same image 
12:57:19 <sphalerite> Is there a way to express a typeclass such that for any value of a type satisfying T a, there exists some function f :: a -> b and b is an instance of another typeclass? And if it is, is it even what I want or am I think about the problem in Java?
12:58:08 <tnks> shucks, I missed __monty__ who is evidently using my example-nix project for working with Haskell.
13:01:36 <Fendoer> sphalerite, maybe it would help if you explained what the purpose is exactly
13:04:40 <sphalerite> Fendoer: I'm just thinking that yes, I am approaching the problem wrong. I have an a, which I need IO to transform into a b which can then be further transformed into a C without IO. I should be able to get Cs from different (a, b)s. But given that what b is depends on what a is, it's not a sensible distinction to make.
13:05:17 <sphalerite> So what I really want is `class A a where transform :: a -> C`
13:05:30 <sphalerite> err
13:05:40 <sphalerite> `class A a where transform :: a -> IO C`
13:06:17 <Fendoer> you could use either multi param type classes or type families
13:07:02 <sphalerite> Taking out the intermediate typeclass seems like a better option
13:07:23 <epta> why there is no instance Bifunctor HashMap?
13:07:41 <Fenedor> sorry, disconnected
13:07:49 <Fenedor> sphalerite,  you could use either multi param type classes or type families
13:08:26 <sphalerite> I wrote: Taking out the intermediate typeclass seems like a better option
13:08:36 <sphalerite> Your message did still arrive :)
13:09:07 <Fenedor> yeah, that's true, so far no reason to use another type class
13:09:19 <Fenedor> and to my problem, i guess it's just a problem with not enough heap space
13:09:41 <dolio> epta: Because it isn't a Bifunctor.
13:13:16 <kadoban> epta: You'd need Hashable constraints on the b in the first :: (a -> b) -> f a c -> f b c  part, and you can't add constraints.
13:14:13 <deech> Hi all, how do I add a github dependency to my 'stack.yaml'? I added the 'git:', 'location:' and 'extra-dep:' field and the result is that it downloads and build the dependency and nothing else.
13:14:27 <drw77> working with Stack and Yesod, "stack build" is modifying my .cabal file--deleting "build-depends" lines that I've added thereby breaking my build.  The idea that "stack build" modifies source files is new to me.  Is there an option somewhere to prevent/restrict this behavior?
13:14:52 <kadoban> deech: You have to add it in your .cabal file as well
13:15:08 <deech> kadoban: It is in there.
13:15:12 <kadoban> drw77: It's probably hpack. Is there an uhm  project.yaml or something? I think that's the right file
13:15:40 <kadoban> deech: What is this "nothing else" that's supposed to be happening and isn't?
13:15:46 <kadoban> ie, what's the actual error?
13:17:06 <deech> kadoban: Here it is https://gist.github.com/deech/e85ae3688c7fe6cddf86e7bc67e74dce. It builds 'fltkhs' and stops, no error.
13:17:20 <drw77> kadoban: "package.yaml" exists, and looks like the ticket.  So, "hpack" is the thing I'm working with now...neat.  Thanks, man :)
13:17:31 <sm> drw77: stack regenerates the cabal file based on package.yaml if there is one
13:17:35 <kadoban> drw77: 'welcome
13:18:05 <kadoban> deech: It shouldn't also be in your extra-deps. And extra-dep: true should be indented less, the first 'e' should line up with the 'l' in location above it
13:19:04 <deech> kadoban: When I do that I get the error 'Error parsing targets: The project contains no local packages (packages not marked with 'extra-dep')'
13:19:47 <deech> kadoban: stack version: 'Version 1.5.1, Git revision 600c1f01435a10d127938709556c1682ecfd694e (4861 commits) x86_64 hpack-0.17.1'
13:20:52 <kadoban> deech: You should probably have something in packages that refers to the current directory. There should have been a line there: - '.'  or something like that
13:22:03 <deech> kadoban: Oh wow, that worked. Thanks!
13:22:06 <kadoban> 'welcome
13:27:26 <drw77> kadoban: I was able to solve this problem with the package.yaml.  I had a similar issue with a language pragma disappearing from ".hs" source files.  I looked for entries of "other-extensions:" but don't see any.  Is there something else, similar to hpack at play?
13:28:25 <kadoban> Shouldn't be, I don't know of any times when any of the build tools will mess with .hs files
13:29:16 <shapr> I've never heard of such a thing
13:29:28 <drw77> ok, thanks.  It must be something within 'yesod' then
13:29:31 <shapr> gremlins?
13:29:53 <drw77> I think I only observed that with 'stack exec yesod devel'
13:30:12 <drw77> which may as well be a prayer
13:32:11 <monochrom> stack exec yesod devel aeternam in nomine Domine
13:36:10 <sm> ghc might regenerate .hs files from .lhs or something ?
13:36:21 <geekosaur> ghc does not do that
13:36:49 <kadoban> Maybe .hsc files, do those generate .hs files? I think only transparently.
13:36:51 <geekosaur> (well, it does but into a temp directory, since it's an intermediate build artifact)
13:37:06 <geekosaur> hsc files do get generated persistently but it's a separate step (hsc2hs)
13:37:15 <geekosaur> er, .hs from .hsc
13:37:33 <geekosaur> so you should be able to see hsc2hs being run, hopefully
13:38:02 <kadoban> cabal-install and stack do it transparently though, right? I don't think I've had to do it manually at all or anything.
13:38:03 <sm> anyway, DO NOT QUESTION IT. Be grateful your source has been improved!
13:38:07 <geekosaur> hm, actually I guess cabal hides that under 'Preprocessing...'
13:38:25 <geekosaur> but both of those shoud put the generated file under dist/build
13:39:32 <kadoban> Ya, makes sense. It'd be weird if they didn't.
13:40:04 <drw77> the pragma deletions happen in the "real" source file--not down in the .stack-work directory somewhere.  I can watch it disappear if emacs is up.
13:40:40 <geekosaur> but, if it's "yesod devel", that's more or less "please build me a dev environment" and that would be expected to edit/create/replace files
13:40:49 <geekosaur> (dev env for yesod)
13:41:58 <kadoban> drw77: Weird
13:41:58 <geekosaur> oh, no, it got split, I recall that buildiung a new dev env
13:42:09 <sm> yea, yesod devel is "please watch files and auto-rebuild"
13:42:18 <geekosaur> hm, no, it still does that, but should only do so if it thinks this isn't one
13:42:30 <geekosaur> that could be a bug
13:42:46 <drw77> thats right--"watch files and rebuild on save" is how it behaves
13:43:02 <drw77> so I save in emacs, and it says "no--bad pragma!"
13:43:22 <drw77> so I go build without devel, and then restart the whole devel thing after it settles down
13:45:41 <hexagoxel> is there an automated way to list where a thing gets reexported (preferably across more than one package)?
13:45:55 <ezyang> not that I know of :( 
13:46:00 <drw77> to be clear, it doesn't say "no--bad pragma"...the line just disappears right in my editor after I ":w"
13:46:30 <sm> drw77: editor plugin cleaning up source on save ?
13:47:07 <kadoban> Wait, emacs has :w ?
13:47:15 <kadoban> Oh probably evil whatever.
13:47:23 <drw77> sm: I do have stylish-haskell installed, but it doesn't run on save--just on an explicit command (spacemacs: spc m F)
13:47:54 <biglambda> Is their a stack equivalent for the cabal parameter --with-c2hs
13:47:55 <drw77> kadoban: yeah--its like vim with plugins that work :)
13:48:25 <biglambda> I need to use a patched version of c2hs in order to compile OpenCL on my mac.
13:48:36 <kadoban> drw77: xD
13:48:48 <monochrom> hexagoxel: I think haddock generates a global index that has that information.
13:50:26 <biglambda> I have the patched version working but I need stack to use it.
13:53:05 <hexagoxel> monochrom: right, thanks. the normal index is per-package though, or do you mean something more "global" yet?
13:53:46 <monochrom> Yes, haddock also generates something more global.
13:55:10 <monochrom> Every time you "cabal install --user --enable-documentation", it regenerates a grand index that includes both the "--global" packages and the "--user" packages (provided those packages were built with docs enabled too). It is a coherent total.
13:55:34 <monochrom> ("coherent total" meaning for example "Int" links to base's Int!)
13:56:06 <monochrom> The location is somewhere like $HOME/.cabal/share/doc/x86_64-linux-ghc-8.2.1/index.html
13:56:42 <monochrom> well, that's the master list of all modules. For the index, change "index.html" to "doc-index.html"
13:57:02 <monochrom> And click your way through until you find the name you want.
14:02:47 <sqooq> konbanwa
14:03:00 <shapr> GOOD AFTERNOON #HASKELL!
14:03:23 <sqooq> andromeda-galaxy: you here?
14:03:24 <shapr> I foresee exciting Haskell code in my near future!
14:03:33 <shapr> that is, I'm going home to code in a few minutes
14:05:21 <Cale> shapr: :)
14:06:08 <monochrom> code to live? live to code? live code?
14:08:02 <shapr> monochrom: work so I can afford to have fun
14:08:15 <hexagoxel> (some combination of using new-build, not passing the enable-documentation or something else makes me not have an index in the location for the relevant compiler. i have looked at per-package stuff now and got my info.)
14:09:02 <monochrom> Oh, new-build refuses to build docs. No matter how many times I use command line flags and config flags to order it. I was disappointed too.
14:10:48 <monochrom> If you use sandboxing, then the master list and index (includes both --global and what's in the sandbox) are somewhere under .cabal-sandbox
14:11:02 <monochrom> But new-build is hopeless for now.
14:11:29 <hexagoxel> yeah, unless you overwrite in ~/.cabal/config :D
14:11:43 <hexagoxel> i had that all configured and working at some point :/
14:12:02 <monochrom> Hrm, actually I haven't tried that.
14:12:17 <hexagoxel> well, i am sure new-build will improve further soon.
14:17:01 <monochrom> Hrm, doesn't seem to build doc now.
14:17:17 <sqooq> anyone wanna try and help me with lens
14:17:53 <sqooq> http://lpaste.net/358276
14:18:41 <sqooq> this code works as expected, but when I try to fit `xlabels` in the `layout` definition, either xaxis is chosen, or xlabels is chosen, both don't seem to happen at the same time
14:18:48 <sqooq> i'm sure i'm just doing lens wrong
14:19:26 <Cale> I find it very hard to parse that
14:19:33 <Cale> What's with the repeated .~ ?
14:19:38 <sqooq> idk
14:19:42 <sqooq> that's what worked
14:19:46 <sm> heh
14:20:11 <hexagoxel> yeah, i don't even know precedence of (.~)
14:20:23 <hexagoxel> /associativity
14:20:25 <sqooq> I'm vaguely following this stuff https://github.com/timbod7/haskell-chart/wiki/example-8
14:20:54 <Cale> You'll notice that they don't nest .~'s there
14:20:54 <sqooq> layout type is https://hackage.haskell.org/package/Chart-1.8.2/docs/Graphics-Rendering-Chart-Layout.html#t:LayoutAxis
14:20:58 <monochrom> Yeah everyone is following that lately. I wonder why.
14:21:01 <sqooq> axis type is https://hackage.haskell.org/package/Chart-1.8.2/docs/Graphics-Rendering-Chart-Axis-Types.html#t:AxisT
14:21:45 <sqooq> Cale, yeah initially I didn't but they never go more than 1 layer deep in those examples. When I just did composition and then one final ~. I get type errors
14:21:47 <monochrom> Is there some Internet conspiracy of luring everyone to read those examples and it's a secret plan to get people to learn lens for a year?
14:21:59 <sqooq> monochrom: you sure it wasn't me?
14:22:01 <shapr> lens is really useful
14:22:10 <shapr> even basic lens knowledge has saved me hours of effort
14:22:10 <hexagoxel> fight fight fight!
14:22:13 <sqooq> My code works up until I try to fix the labels
14:22:20 <monochrom> Look for what Psybur said earlier today.
14:22:21 <sqooq> it tracks my mouse correctly, and the axis stays constant
14:22:32 <Cale> sqooq: So yeah, just don't do that
14:22:33 <sqooq> but the labels changes automatically because by default that's what it's set to do
14:22:34 <monochrom> And I think there was also another person yesterday.
14:22:38 <sqooq> so I'm trying to override it
14:22:53 <shapr> sounds like chart needs more detailed examples
14:22:54 <Cale> sqooq: If you want to compose lenses together to refer to fields inside fields, use .
14:22:55 <sphalerite> What's the nicest way of decoding a ByteString.Lazy ByteString as UTF-8 into a String?
14:23:02 <Psybur> I swear I didn't do it!
14:23:09 * shapr hugs Psybur
14:23:11 <sqooq> @shapr: I agree
14:23:12 <monochrom> Hell just go to any log of this channel and search for "timbod7". You will be afraid.
14:23:12 <lambdabot> Unknown command, try @list
14:23:12 <Psybur> Don't bone me, man!
14:23:26 <sqooq> Cale: and thne one final .~?
14:23:31 <sqooq> or does that come first?
14:23:47 <Cale> sqooq: Yeah, it's  lens .~ newValue
14:24:05 <sqooq> but I'm nested
14:24:05 <Cale> and (.) can combine lenses together to make new lenses
14:24:06 <monochrom> It's like everyone who weren't wearing tinfoil hats suddenly have the urge to read those examples very very specifically.
14:24:23 <sqooq> xaxis = layout_x_axis .~ laxis_override . axis_viewport . vmap (0.0::Double,500.0)
14:24:26 <sqooq> gives type errors
14:24:37 <Cale> Which of these things are lenses?
14:24:42 <sqooq> all
14:24:50 <sqooq> except vmap
14:25:27 <Cale> So, you probably want  layout_x_axis . laxis_override . axis_viewport .~ vmap (0::Double, 500)
14:25:34 <sqooq> that doesn't work
14:25:36 <sqooq> wither
14:25:39 <sqooq> either*
14:25:47 <Cale> Well, what's the type of the lenses then?
14:25:54 <Cale> Maybe you have them in reverse order?
14:26:16 <sqooq> http://lpaste.net/358277
14:26:20 <sqooq> that's error
14:26:33 <sqooq> it's higher layer -> lower layer, right?
14:26:46 <hexagoxel> Cale: the field is a function, so it makes sense
14:26:47 <hexagoxel> see axis_viewport
14:26:48 <sqooq> That's how I tried to follow it based on the types in the source code
14:26:53 <hexagoxel> eh, http://hackage.haskell.org/package/Chart-1.8.2/docs/Graphics-Rendering-Chart-Layout.html#v:laxis_override
14:26:59 <Cale> Yeah, the outermost lens goes on the left when you compose
14:27:35 <Cale> Okay, so laxis_override is a lens which goes from LayoutAxis to AxisData x -> AxisData x
14:27:43 <hexagoxel> xaxis = layout_x_axis . laxis_override .~ (axis_viewport .~ vmap (0.0::Double,500.0))
14:27:47 <RyanGlScott> I'm currently trying to spruce up Haddock's rendering of kind signatures.
14:27:53 <RyanGlScott> What are some examples of the hairiest poly-kinded Haddocks you can think of (as test cases)?
14:28:02 <sqooq> hexagoxel: that's how I had it originally lmao
14:28:03 <Cale> and yeah, it seems unlikely that you'd have a lens whose domain is a function type
14:28:13 <Cale> okay
14:28:20 <Cale> With the parens it makes sense.
14:28:30 <sqooq> ok so my actual probelm
14:28:39 <sqooq> is I then try to do xlabels which is roughly the same
14:28:45 <sqooq> but depending on which appears first
14:29:00 <sqooq> or rather, the one that appears first is the only one that gets activated
14:29:14 <Cale> Well, you're just replacing one function with another
14:29:19 <hexagoxel> sqooq: sure, you overwrite the `laxis_override` field
14:29:27 <Cale> So, probably you instead want to compose the functions which act on the AxisData
14:29:27 <hexagoxel> ironic, isnt it
14:29:38 <Psybur_> Should I learn about Template Haskell before I learn about lens?!
14:29:47 <Cale> Psybur_: Unnecessary
14:29:51 <sqooq> Cale: I'll try that
14:31:06 <sqooq> both have the appareance of lens .~ value
14:31:07 <sqooq> roght?
14:31:24 <sqooq> (lens1 .~ value) . (lens2 .~ value) ??
14:31:27 <Cale> yeah
14:31:28 <hexagoxel> yes
14:31:45 <Cale> and leave the parens in, or nobody will be able to figure out what's going on :)
14:31:46 <sqooq> o i forgot parenthesis
14:31:50 <sqooq> ok yup that works
14:32:05 <sqooq> Cale: it doesn't work without em
14:32:36 <sqooq> fuuu
14:32:43 <sqooq> the grid still auto adjusts
14:32:44 <Cale> Yeah, (.~) intentionally has lower precedence than (.)
14:32:50 <sqooq> but I'm guessing that's yet another field to change
14:35:02 <fendor> how can i trace a segmentation fault in ghc?
14:35:58 <sqooq> you know what
14:36:11 <sqooq> it looks like I could have just used makeAxis, if I wanted a fixed axis
14:36:24 <sqooq> but don't understand the labelling function thing
14:38:56 <Psybur> Do people actually remember all this? >.> https://github.com/ekmett/lens/wiki/Operators
14:47:48 <erisco> if you know what <, ~, = mean then I imagine it is not so difficult
14:48:08 <erisco> since the stuff in the middle is just the name of another operator, presumably related
14:50:34 <jle`> Psybur: they're not actually all "different" arbitrary operators
14:50:44 <jle`> the system is pretty consistent
14:51:25 <jle`> so if you know some, you can just "guess" the others and be right most of the time
14:52:00 <jle`> Psybur: for example, +~ adds along a lens
14:52:21 <jle`> can you guess what *~, -~, etc. do?
14:52:46 <jle`> and ^~, etc.
14:53:06 <jle`> ||~, &&~ ...
14:53:06 <Psybur> no i cant not yet :D
14:53:15 <jle`> well, if you know that "+~" adds along a lens
14:53:22 <jle`> then a good guess for "*~" would be that it multiplies along a lens
14:53:35 <jle`> and ||~ would be or-ing, or ||-ing... &&~ would be and-ing, or &&-ing ...
14:54:01 <RyanGlScott> Semigroup is now officially a superclass of Monoid: http://git.haskell.org/ghc.git/commit/8ae263ceb3566a7c82336400b09cb8f381217405
14:54:09 <jle`> most people don't memorize every individual operator, they just know like +~ for addition, and they can just guess <some other operator>~ for being that operator
14:54:12 <jle`> RyanGlScott: :O
14:54:14 <sqooq> how do I convert `chart p z = toRenderable (layout p z)` to dot
14:54:30 <jle`> RyanGlScott: what happened to the slow phasing in using warnings?
14:54:35 <ocharles> Errr. I have a cabal project. it's a library with 1 .hs file. I also have a test-suite (one .hs file) that uses TemplateHaskell. The only way to get the damn thing to build is with `--enable-shared`
14:54:37 <jle`> or has this already been happening and i didn't even know
14:54:39 <ocharles> that seems like a bug, right?
14:54:53 <RyanGlScott> jle: Indeed, this has been in the making for a while
14:54:57 <ocharles> If I don't, I get: `can't load .so/.DLL for: libHShsfmt-0.1.0.0-Fk7WGmarOCMAsQwQOEodcP.so (libHShsfmt-0.1.0.0-Fk7WGmarOCMAsQwQOEodcP.so: cannot open shared object file: No such file or directory)`
14:55:04 <RyanGlScott> But the warnings are under -Wcompat, not -Wall
14:55:10 <jle`> ah, i see
14:55:12 <ocharles> seems surprising that just `cabal test` doesn't actually work
14:55:12 <RyanGlScott> This is to keep in compliance with the 3-release policy
14:55:29 <RyanGlScott> So that you can have code that compiles without warnings on -Wall back three releases
14:56:08 <Psybur> Does anybody use the intellij haskell plugin? I cant really autocomplete anything unless its defined in the source file im in D:
14:56:14 <Psybur> Wondering if thats normal or not
14:56:19 <jle`> is there a canonical proposal somewhere we're following?
14:56:24 <hpc> -Wcompat isn't part of -Wall?
14:56:26 <jle`> wanted to look up what the fate of Option would be
14:56:48 <RyanGlScott> hpc: It's not, by virtue of that fact that doing so would violate the 3-release policy
14:57:09 <RyanGlScott> jle: It's roughly following this: https://prime.haskell.org/wiki/Libraries/Proposals/SemigroupMonoid
14:57:31 <RyanGlScott> Also being tracked at Trac here: https://ghc.haskell.org/trac/ghc/ticket/10365
14:57:44 <RyanGlScott> And here: https://ghc.haskell.org/trac/ghc/ticket/14191
14:57:48 <sqooq> why doesn't toRenderable . layout work
14:58:08 <RyanGlScott> I asked ekmett about Option, and he didn't have a solid idea what would happen to Option
14:59:11 <jle`> interesting dilemma
14:59:27 <RyanGlScott> I've often thought a -Wpedantic flag would be nice for this sort of thing
14:59:40 <RyanGlScott> As an umbrella warning for all the crazy junk we're too timid to put in -Wall
14:59:44 <jle`> well, i suppose it's not technically a dilemma, since there are an unknown number of potential resolutions
14:59:48 <jle`> none of them particularly appealing
15:00:48 <RyanGlScott> There's a number of other questionable warning flags not under -Wall as well, such as -Wunused-type-patterns
15:01:50 <fenedor> why is semigroup a superclass of monoid? it seems like it has more operations?
15:01:51 <jle`> whatever happened to that warning that popped up about redundant constraints?
15:02:06 <jle`> i remember being mildly annoyed by it, but then i never saw it again
15:02:09 <RyanGlScott> jle: It was yanked out of -Wall in 8.0.2 due to mob outcry
15:02:26 <jle`> fenedor: what operations are you thinking of?
15:02:34 <nshepperd_> Isn't that rather cheating, not putting things in -Wall so that code will compile without warnings? Warnings are supposed to make you update your code, not the other way around
15:02:45 <hpc> fenedor: the only real class member is (<>)
15:02:53 <hpc> fenedor: the others are nice-to-haves
15:02:54 <RyanGlScott> nshepperd_: It was removed because it would warn *too* much
15:03:09 <hpc> Monoid is Semigroup + mempty
15:03:22 <RyanGlScott> i.e., there was code that had "redundant constraint" warnings, but removing those redundant constraints meant it would no longer typecheck
15:03:58 <RyanGlScott> A less dire example is that sometimes people put "redundant" constraints on functions to enforce invariants
15:04:12 <fenedor> hpc, ah i see, then i understand why it is a superclass
15:04:14 <nshepperd_> I meant the semigroup thing
15:04:49 <RyanGlScott> nshepperd_: Indeed, the 3-release policy is a compromise
15:05:16 <RyanGlScott> A large number of people were quite upset about the fact that they couldn't write could which could compile warning-free between even two consecutive GHC releases
15:05:23 <nshepperd_> Warnings that are inaccurate have a good justification for being turned off by default
15:05:24 <RyanGlScott> Which I think is understandable
15:06:06 <RyanGlScott> -Wcompat, by its very nature, is incompatible with the 3-release policy since it can pop up with warnings without notice on a particular GHC release
15:17:48 <sqooq> hexagoxel, Cale: Can y'all help me again. axis_viewport takes a range and converts it to device coords, which i'm assuming is the coords of the window. I'm trying to access those device coords now, I tried `viewCoords = layout_x_axis . laxis_override ^. axis_viewport`, and a few other things with no luck. 
15:17:59 <sqooq> relevant : https://hackage.haskell.org/package/Chart-1.8.2/docs/Graphics-Rendering-Chart-Axis-Types.html#t:AxisData
15:45:45 <jchia_1> Can I get some comments on a code snippet that uses megaparsec 6? Namely, are the constraints for priceParser2 normal (can I simplify them)? I had to add 'IsString (Token s)' migrating from megaparsec 5 to megaparsec 6. http://lpaste.net/358278
15:45:48 <royal_screwup21> Suppose I write out the following code: let func x="foo"   and then  let func  1= "one". Now if I type in "let func 2", I get an exception. I'm not sure I understand why that happens. As I understand, if the patterns are checked from top to bottom, why wasn't "foo" returned?
15:47:26 <erisco> royal_screwup21,  let  introduces a declaration
15:47:31 <jchia_1> royal_screwup21: You didn't say what exception you got, but "let func 2" doesn't parse as proper Haskell.
15:47:45 <geekosaur> royal_screwup21, where are you typing these?
15:47:50 <royal_screwup21> on the command line
15:48:02 <geekosaur> ghci does not support multiline definitions without extra work
15:48:05 <royal_screwup21> the >Prelude thingy
15:48:10 <geekosaur> :{ :} or :set +m
15:48:26 <geekosaur> this is specific to ghci; in files, it works fine
15:49:07 <sqooq> royal_screwup21: yeah do it in a file. func :: Int -> String ; func 1 = "one" ; func 2 = "two" ; etc.
15:49:16 <sqooq> i don't see why you'd want to make that function like that though
15:49:17 <royal_screwup21> thanks guys!
15:49:24 <sqooq> you can use read
15:49:27 <sqooq> or sorry
15:49:28 <sqooq> show
15:49:47 <sqooq> no that won't work either
15:49:54 <sqooq> hmmm
15:50:04 <sqooq> I guess you will have to write it out nvm
15:50:17 <geekosaur> it's an example, who cares if it's the "best way"
15:50:24 <sqooq> tru
15:50:45 <erisco> it is the start of a conversion of numbers to English
15:50:53 <sqooq> ye
15:51:12 <sqooq> kek they're gonna fall down the parsing rabbit hole eventually if that's what they're interesting in
15:51:20 <sqooq> interested*
15:51:41 <erisco> now you learn that English does 10-19 strangely and also 20-90
15:51:58 <erisco> but it seems other languages have strangeness too
15:52:12 <hpc> french is pretty great iirc
15:52:24 <sqooq> no french is annoying
15:52:27 <erisco> French uses multiplies of 20 doesn't it? been a while since I took it
15:52:33 <sqooq> quatre-vingts
15:52:38 <monochrom> Babylonian!
15:52:40 <hpc> sqooq: the best kind of great ;)
15:52:58 <sqooq> 90 is quatre-vingts-dix
15:52:59 <monochrom> <<(<<((  hehe
15:53:01 <sqooq> screw that noise
15:53:14 <sqooq> 4 20 10
15:53:14 <sqooq> lmao
15:53:19 <erisco> yeah, 40 + 20 + 10
15:53:36 <sqooq> 70 is soixante-dix. 60+10
15:53:38 <sqooq> I think it's stupid
15:54:00 <sqooq> I prefer english, if teen didn't sound like ty, and if 11 and 12 were regular
15:54:24 <erisco> French does the teens better though
15:54:37 <sqooq> no it's irregular too
15:54:40 <erisco> well, 17 18 and 19... dix-sept, dix-huit, dix-neuf
15:54:48 <sqooq> ye
15:55:00 <sqooq> honestly we should just say numbers as binary
15:55:20 <sqooq> one, one zero, one one, one zero zero
15:55:38 <sqooq> except make zero only a syllable
15:55:58 <hpc> https://www.youtube.com/watch?v=CTjolEUj00g
15:56:11 <sqooq> one, one nil, one one, one nil nil
15:56:40 <MarcelineVQ> luckily there's even shorter words for those
15:56:47 <boj> that is quite unwieldy
15:56:57 <sqooq> MarcelineVQ: you can't get shorter than one syllable
15:57:15 <jchia_1> Is there such a thing as a constraint synonym where i can give a set of constraints a name so that i don't have to keep repeating myself when defining functions that have the same constraints?
15:57:35 <erisco> yes, there is
15:57:52 <jchia_1> erisco: What is it?
15:58:23 <erisco> type Equal a b = a ~ b  for example
15:58:52 <sqooq> is that a constraint though?
15:59:09 <erisco> yes
15:59:26 <sqooq> then sweet
16:00:12 <jchia_1> erisco: If I have 'a :: (MonadParsec e s m, Token s ~ Char, IsString (Tokens s)) => Side -> m Price' and 'b :: (MonadParsec e s m, Token s ~ Char, IsString (Tokens s)) => m Price', how can I factorize out the common constraint '(MonadParsec e s m, Token s ~ Char, IsString (Tokens s))' for the functions a & b so that I don't have to repeat myself?
16:01:16 <erisco> make it an alias as I have shown
16:02:15 <sqooq> can you do commas too
16:02:20 <erisco> note that parentheses in contexts are not structural
16:02:22 <geekosaur> it's a tuple
16:02:25 <erisco> and yes you can use commas
16:02:52 <sqooq> o 
16:03:09 <sqooq> idk why I asked that
16:03:10 <erisco> if A and B are constraints then (A, B) is a constraint
16:03:12 <jchia_1> erisco: Like this? 'type TextualParser e s m a = (MonadParsec e s m, Token s ~ Char, IsString (Tokens s))'
16:03:26 <geekosaur> you don'[t need the a there
16:03:32 <jchia_1> I get an error.  Illegal constraint synonym of kind: 'Constraint'
16:03:44 <geekosaur> you may need ConstraintKinds extension
16:03:44 <erisco> {-# LANGUAGE ConstraintKinds #-}
16:03:49 <geekosaur> the error should have told you that
16:04:12 <jchia_1> geekosaur: Just wanted to make sure
16:05:14 <erisco> actually, parentheses will become important to delineate variable scope
16:05:32 <erisco> if we see that feature added
16:06:01 <erisco> quantified constraints
16:06:36 <erisco> unless you are not allowed to quantify over a conjunction
16:07:17 <jchia_1> erisco, geekosaur: This way, I ended up with 'a:: TextualParser e s m => Side -> m Price' and 'b:: TextualParser e s m => m Price'. Can I do better so that I don't even have to mention the e & s in the 'TextualParser e s m'?
16:07:34 <geekosaur> no, because they would not be able to unify
16:07:59 <geekosaur> hm, actually in this specific case you could probably forall them
16:08:21 <geekosaur> but if you need to use more than one of those in a type signature then you would not be able to specify that all of them use the same e and s
16:11:24 <jchia_1> geekosaur: What do you mean by "forall them"?
16:11:37 <geekosaur> sigh
16:12:13 <geekosaur> here is your magic: type TextualParser m = forall e s. (MonadParsec e s m, Token s ~ Char, IsString (Tokens s))
16:12:18 <geekosaur> expect weird type errors
16:12:25 <jchia_1> i got errors
16:12:54 <hpc> wow, that type is a bad enough dude to save the president
16:12:57 <boj> TIL constraints are a tuple. so balatantly obvious is hindsight
16:13:35 <boj> do they actually get treated as a tuple? what about Show a => ?
16:13:47 <hpc> :k (Show a, Num a)
16:13:48 <lambdabot> error: Not in scope: type variable ‘a’
16:13:48 <lambdabot> error: Not in scope: type variable ‘a’
16:13:52 <jchia_1> geekosaur: Illegal polymorphic type: ... A constraint must be a monotype ...
16:13:54 <hpc> :k forall a. (Show a, Num a)
16:13:55 <lambdabot> Constraint
16:14:08 <boj> :k forall a. Show a
16:14:10 <lambdabot> Constraint
16:14:11 <hpc> boj: sort of
16:14:19 <boj> huh, interesting
16:14:20 <jle`> boj: they're not "actually" a tuple exactly
16:14:21 <geekosaur> jchia_1, in that case then you don't even get broken dangerous magic
16:14:26 <jle`> (,) is more like a monoid append
16:14:37 <hpc> in contexts at least
16:14:40 <hpc> :k (,)
16:14:40 <boj> gotcha
16:14:41 <lambdabot> * -> * -> *
16:14:41 <geekosaur> syntactically it's a tuple. not semantically
16:15:06 <jle`> yeah, (,) is a monoid append when used with constraints.  (,) is super over-loaded, though, heh
16:15:09 <hpc> you're not really even using (,) at all
16:15:16 <hpc> you're using a "," token as part of the syntax
16:15:25 <hpc> in much the same way that the dot in Control.Monad is not (.)
16:15:39 <jchia_1> geekosaur: So I suppose I can't simplify the type declarations of a & b further using forall?
16:16:04 <hpc> :k (Show, Num)
16:16:05 <lambdabot> error:
16:16:05 <lambdabot>     • Expecting one more argument to ‘Show’
16:16:05 <lambdabot>       Expected a type, but ‘Show’ has kind ‘* -> Constraint’
16:16:11 <hpc> aw, can't do that
16:16:14 <geekosaur> sorry, let me figure out *another* way to say "no:"
16:16:34 <jle`> huh i thought (,) on contexts was treatable as an operator but trying it again, i see that it isn't
16:16:46 <jle`> hm
16:16:59 <vktec> Is there a function for Either that works like fmap but applies the function to the Left value rather than the Right one?
16:17:05 <jle`> vktec: yes, 'first'
16:17:10 <jle`> in Data.Bifunctor
16:17:36 <jle`> ('second' applies a function to the Right value, too, if you feel like being consistent)
16:18:03 <vktec> Cool, thanks
16:18:06 <geekosaur> it doesn't ctually surprise me that it rejected the forall, precisely for the reason I mentioned earlier
16:18:28 <jle`> > Data.Bifunctor.first succ (Left 10)
16:18:30 <lambdabot>  error:
16:18:31 <lambdabot>      Not in scope: ‘Data.Bifunctor.first’
16:18:31 <lambdabot>      No module named ‘Data.Bifunctor’ is imported.
16:18:36 <jle`> @let import Data.Bifunctor
16:18:38 <lambdabot>  Defined.
16:18:40 <jle`> > Data.Bifunctor.first succ (Left 10)
16:18:42 <lambdabot>  Left 11
16:32:18 <sqooq> omg
16:32:21 <sqooq> this is driving me nuts
16:34:00 <MarcelineVQ> the one about the pirate at the bar?
16:34:47 <sqooq> http://lpaste.net/358280
16:34:48 <sqooq> halp
16:35:07 <sqooq> https://hackage.haskell.org/package/Chart-1.8.2/docs/Graphics-Rendering-Chart-Axis-Types.html#t:AxisData
16:35:25 <sqooq> I need to get the gtk coords for the origin of the graph... at least
16:35:32 <sqooq> and I have no clue how to get to that point
16:56:31 <sqooq> got [[x]]
16:56:38 <sqooq> wanna add y to [x]
16:57:07 <sqooq> I can think some convuluted way to do it
16:58:03 <andromeda-galaxy> sqooq: add y to [x]?
16:58:17 <sqooq> but it's one list inside of another
16:58:22 <sqooq> [[1]] for example
16:58:28 <sqooq> and I want to make it [[1,2]]
16:58:33 <andromeda-galaxy> no I meant, what do you mean by that?
16:58:42 <sqooq> I concat the first, then ++ the second, then wrapped the whole thing in a list
16:58:47 <sqooq> but htat seems ridiculous
16:58:52 <andromeda-galaxy> oh I see. do you want to append y to every internal list, or just the first
16:59:26 <sqooq> well there's only one, and I'm pretty sure there can only be one. It's this Chart library. I tested having two lists, and then no line is drawn so I'm confused why it's [[x]]
16:59:34 <andromeda-galaxy> > map (++[2]) [[1]]
16:59:37 <lambdabot>  [[1,2]]
17:00:50 <sqooq> hmm
17:00:54 <sqooq> this is not what I expected at all
17:02:21 <sqooq> andromeda-galaxy: you helped me so well yesterday. I need to figure out the gtk coords of the origin of the drawn graph
17:02:34 <erisco> AllowAmbiguousTypes and TypeApplications is what the cool kids do nowadays, right?
17:03:03 <sqooq> I think _axis_viewport might help
17:03:04 <sqooq> https://hackage.haskell.org/package/Chart-1.8.2/docs/Graphics-Rendering-Chart-Axis-Types.html#t:AxisData
17:08:23 <sqooq> also mouse clicks aren't registering
17:08:28 <sqooq> I did   drawArea `on` buttonReleaseEvent $ do
17:08:40 <sqooq> pretty sure my code is right otherwise
17:20:27 <sqooq> jeez
17:20:29 <sqooq> fixed it
17:20:35 <sqooq> ok i'm getting overloaded with this stuff now
17:20:39 <sqooq> I think I need to quit it
17:21:07 <sqooq> andromeda-galaxy: pls respond though if you have any ideas about how to get graph coords so I can normalize mouse coords to the graph.
17:31:29 <sqooq> newest
17:31:29 <sqooq> http://lpaste.net/358280
17:35:47 <et09> https://gist.github.com/djvs/9bbb3941b16931fa0e731b91a5eadc8b having this problem - any help?
17:38:38 <average> http://adrianzandberg.pl/cobol-on-wheelchair/
17:38:48 <average> how does COBOL stack up against Haskell nowadays?
17:39:10 <average> I https://news.ycombinator.com/item?id=15191012
17:39:35 <average> also everyone in that convo seems to agree cobol is where the big money is made today
17:41:32 <et09> average: about the same way punchcard assembly stacks up against haskell 
17:41:58 <average> et09: it's widely used tho, in production systems..
17:42:24 <average> i personally don't know anyone IRL having done haskell in production
17:42:33 <et09> it's true, and the ay thing is as well 
17:42:40 <et09> pay thing* - supply and demand
17:43:00 <et09> coders don't wanna invest their time into that but crappy 25 yo legacy systems still have it...
17:43:04 <boj> cobol is where the money is because there are very few cobol programmers these days
17:43:22 <rotaerk> and because of legacy systems
17:43:26 <et09> but it's been largely replaced by java, erlang, c++, etc.
17:43:32 <rotaerk> not because people are like "let's hire a cobal developer to build us a new system!"
17:43:35 <average> boj: how many haskell programmers are there? maybe about as many as cobol?
17:44:01 <average> et09: coders invest time in cobol because they know once they land a cobol gig they're gonna make some decent cash
17:44:05 <boj> rotaerk: yeah, that's an important point
17:44:10 <average> et09: at least that's what people say in lots of articles
17:44:16 <boj> average: i have no idea how many of us there are to be honest
17:44:39 <boj> i suspect a tad more than cobol
17:44:47 <average> rotaerk: what's exciting about new systems?
17:44:49 <et09> average: if that's how you want to live your life ;)
17:45:05 <average> rotaerk: all the cool stuff happens in maintenance, no?
17:45:19 <average> et09: i thought life was the off-work time, no?
17:45:42 <rotaerk> hmm, could've sworn haskell used to be in the top 50 on the tiobe index
17:45:45 <rotaerk> but it's not anymore
17:45:48 <et09> not in reality 
17:45:57 <et09> but that's #offtopic
17:46:39 <et09> does anyone know what "shadowed dependencies" means in cabal?  how to fix? dying here
17:47:03 <boj> same declaration twice maybe?
17:47:30 <boj> oh
17:47:41 <et09> (see my link above)
17:47:43 <boj> or you are trying to build something but didn't add it to the library to the cabal file
17:47:52 <et09> i'm doing "cabal install" from repos
17:48:22 <boj> you are probably missing a library whatever you are installing depends on
17:48:27 <et09> https://gist.github.com/djvs/9bbb3941b16931fa0e731b91a5eadc8b 
17:48:50 <boj> for some reason my terminal is misbehaving and i can't click/copy links, weird...
17:49:34 <et09> my whole cabal system is dead
17:49:37 <et09> DOA
17:50:11 <et09> boj: http://bit.ly/2wMQwAH
17:50:14 <average> here's an interesting thing tho
17:50:32 <average> if Haskell would leverage its parser combinators and whatnot
17:50:39 <average> and it would build an alternative to GnuCobol..
17:50:52 <average> maybe Haskell could create some context for money-making like.. for real
17:51:04 <average> possibly some language translators Cobol <-> something_else
17:52:09 <boj> that is indeed bizarre et09 
17:53:39 <et09> i had archlinux ghc + cabal, uninstalled them after the maintainer broke them, installed "haskell-platform" (https://www.haskell.org/platform/#linux-generic)
17:53:51 <et09> now i'm thinking of uninstalling that too 
17:54:10 <et09> and just doing ghc+cabal from scratch
17:54:24 <boj> arch seems to be the #1 distro with haskell problems that come up in here
17:54:38 <et09> yeah they totally screwed it up a few months ago
17:55:09 <average> yoi guys have arch pkg maintainers?
17:55:26 <et09> yeah
17:55:32 <et09> felix yan 
17:55:45 <et09> whoever that is
17:56:24 <average> isnt it better to have some packages than no pkgs at all?
17:56:34 <et09> not really here
17:57:13 <average> oh ok. could someone write something in haskell that generates packages tho?
17:57:58 <average> i know know debian f example theres debuild, dpkg-buildpackage
17:58:31 <average> arch must have smth like that..
17:59:18 <pikajude> what's the operation called where you take M lists of N things and produce all possible strings of length M
18:00:28 <erisco> pikajude, if all the lists are the same then these are the permutations
18:00:28 <et09> pkgbuild
18:00:34 <pikajude> nope
18:00:36 <Hafydd> pikajude: do you mean the cartesian product?
18:00:38 <pikajude> i'm talking about sequence as applied to the list monad
18:00:40 <pikajude> maybe
18:00:42 <et09> but idk what to do with it even
18:01:40 <erisco> I agree with product then
18:02:12 <bxc> pikajude: you mean pick an element from the first list, then an element from the second, up to the Mth list, and that done non-deterministically is your output list of strings?
18:02:15 <pikajude> yeah
18:02:17 <pikajude> it's cartesian product
18:02:20 <bxc> yeah
18:02:20 <pikajude> that's the operation i'm looking for
18:03:04 <erisco> and actually it wouldn't be the permutations like I thought it would
18:04:09 <erisco> that would be possible with a dependent product
18:05:26 <erisco> i.e. the selections for the ith position depend on the selections made for the previous positions
18:05:26 <Hafydd> You might also call it zipM.
18:05:33 <Hafydd> Wait, no...
18:05:49 <Hafydd> That would be something else.
18:06:45 <Hafydd> That's what happens when you only look at the type of a function.
18:07:59 <erisco> and this has a simple generalisation in Haskell but I'd have to dig it out of some rusting code
18:52:17 <tomasino> hiya
19:06:58 <erisco> tomasino, hello
19:14:16 <tomasino> how's things tonight? much chat-itude?
19:15:10 <orzo> I'm translating C code that multiplies two 64 bit numbers to obtain 128 bits as a pair of 64-bit words
19:15:24 <orzo> should i use Integer?
19:15:30 <orzo> or do something similar in haskell
19:16:17 <Hafydd> Why are you translating C code into Haskell?
19:16:38 <orzo> why not
19:16:47 <orzo> its a good way to grok c code
19:16:48 <Hafydd> You can just run the C program right away.
19:17:07 <Hafydd> And the Haskell you obtain by translating it literally will probably be horrible.
19:17:13 <orzo> eh
19:17:27 <orzo> you've never done this
19:17:32 <Hafydd> I would recommend using Integer, anyway, unless there is some special performance need.
19:17:32 <Axman6> orzo: there are ptimitives for that in GHC.Prim IIRC
19:18:10 <Hafydd> In which case you could use a 128-bit integer type, perahaps.
19:19:56 <Axman6> orzo: hmm, this is related, but not what I thought was there: https://hackage.haskell.org/package/ghc-prim-0.5.1.0/docs/GHC-Prim.html#v:mulIntMayOflo-35-
19:19:59 <dumptruckman> How can I add a debug print to a function?
19:20:43 <Axman6> (I was thinking of addIntC# whcih returns the any carry value of an add, useful for big int implementations)
19:21:01 <orzo> well i've got unsigned numbers
19:21:13 <Axman6> dumptruckman: that's generally not a good idea, but can be done, can you explain why you want that?
19:21:29 <dumptruckman> just to figure out why this function isn't working
19:21:32 <dumptruckman> it's not for the final version
19:21:48 <Axman6> dumptruckman: Look at Debug.Trace
19:22:31 <Axman6> orzo: timesWord2# might be what you want (but would need testing since there's no docs)
19:22:32 <dumptruckman> Ah, thanks
19:23:00 <Axman6> Anyone have a preferred library for parsing HTML and extracting links?
19:23:11 <tomasino> BTW, there's a bunch of bots rampaging around freenode spamming racist stuff in channels. They may come this way in a bit.
19:23:24 <tomasino> #vim just got bombarded
19:26:59 <alx741> tomasino: I think #vim is one out of very few victims
19:28:08 <tomasino> hope so! I just don't get why people bother
19:32:39 <orzo> Axman6: trying to test your suggestion, but I don't know how to make a literal of Word#.  I tried 1# but ghci says type error and infered Int#
19:35:44 <geekosaur> I don't think there is such a thing? at that level it's the operations that know whether something is a Word or an Int
19:36:04 <geekosaur> not the types, because Int# is a hardware word and the hardware doesn't have types
19:38:00 <monochrom> Dear friends, is there one extension that implies both RankNTypes and ExistentialQuantification?
19:38:14 <dumptruckman> the same bots were spamming on other networks a while back too
19:39:13 <MarcelineVQ> monochrom: ^^;  just -fglasgow-exts afaik
19:39:43 <MarcelineVQ> which isn't an extension of course, but just in case it matters
19:40:58 <monochrom> Ah excellent, PolymorphicComponents is deprecated and is aliased to RankNTypes.
19:41:47 <crucify_me> thanks all .. happy to report I understand this now:   gg f a c = f a  
19:42:00 <iqubic> How does that work?
19:43:06 <monochrom> I'm going to write out both RankNTypes and ExistentialQuantification. -fglasgow-exts is too much a sledgehammer.
19:43:17 <MarcelineVQ> it surely is
19:43:32 <monochrom> Don't worry! So far I'm only using five: RankNTypes, ExistentialQuantification, DataKinds, KindSignatures, TypeFamilies
19:43:36 <orzo> timesWord2# seems to be it.
19:46:02 <erisco> existential quantification… that thing you do with forall?
19:46:18 <MarcelineVQ> that thing what with the forall that isn't the 4.5 other things
19:46:59 <erisco> what use will they come up with next
19:47:26 <erisco> maybe if we don't like lambda binders we can use forall instead
19:47:34 <monochrom> Oh it's going to be fantastic. I'm having "data PairKind = forall a b. Pair a b" so it's an existential type and I'm promoting it with DataKinds so the real thing I care about is: the type "Pair a b" has kind "PairKind".
19:47:37 <erisco> (forall x. x + 1) 2 = 3
19:48:13 <MarcelineVQ> what is x is -1 :(
19:48:13 <Gurkenglas> Pretty much type application
19:48:35 <monochrom> And I'm turning on TypeFamilies because "type family Fst (p :: PairKind)", "type instance (Fst (Pair a b)) = a" is going to work. (Just learned from GHC users guide!)
19:48:54 <MarcelineVQ> em, nevermind :X
19:49:42 <erisco> and you can even shorten that to a closed family
19:51:18 <monochrom> So now I can haz "newtype F2F (p :: PairKind) (q :: PairKind) = F2F ((Fst p -> Snd p) -> (Fst q -> Snd q))"
19:51:58 <monochrom> It is an alternative way to say "newtype F2F a b c d = F2F ((a -> b) -> (c -> d))" but I packed up 4 type variables into 2.
19:52:25 <monochrom> It is important to pack them up because I want "instance Category F2F"
19:52:51 <monochrom> And this is only the mock story. The real story is this:
19:53:38 <monochrom> newtype Lens (p :: PairKind) (q :: PairKind) = Lens (forall f. Functor f => (Fst p -> f (Snd p)) -> (Fst q -> f (Snd q)))
19:54:43 <monochrom> Now let me read closed type families in the users guide.
19:55:11 <monochrom> Yeah it's nicer.
19:55:40 <monochrom> whee! Thanks.
20:02:37 <monochrom> Aw I'm a moron.
20:03:28 <monochrom> I can do it in one go: type instance Whee (Pair a b) = forall f. Functor f => a -> f b
20:05:33 <monochrom> Naw, I have a problem with having different f's.
20:13:13 <MarcelineVQ> monochrom: What are you up to? You've spelled it out above but I'm a bit of a plebian about type families and category.
20:13:39 <monochrom> I want lenses to be newtype-wrapped but still enjoy (.)
20:14:36 <monochrom> So I say "Category's (.) is a good compromise" but now I have to force things to conform to Category's formality.
20:17:20 <monochrom> Category refers to the class in Control.Category
20:24:27 <erisco> how do I use "monadic" as an adjective correctly?
20:25:04 <erisco> I hear "monadic this" and "monadic that" and I am not quite sure what is being said other than a Monad is somewhere
20:26:04 <dfeuer> erisco: damn good question
20:26:39 <dfeuer> Cale: what do you think of https://github.com/michaelt/streaming/issues/43 and https://github.com/michaelt/streaming/issues/44 ? Are those sensible things to do to a free monad transformer?
20:27:59 <erisco> x  is a "monadic value" iff there exists a Monad  m  and a type  a  such that  x :: m a
20:28:34 <dfeuer> erisco: you should also feel free to answer the question I just asked.
20:31:04 <erisco> I don't know a lot about Stream or Comonad, but to witness any performance differences I would specialise the definitions and see if GHC gives you the same code under -O
20:31:27 <dfeuer> erisco: Stream ~= FreeT
20:31:47 <erisco> yes I know the definition but I haven't worked with it before
20:32:05 <dfeuer> I think GHC's likely smart enough to optimize copy how I'd like, but the general unzip seems doomed to have some extra laziness.
20:32:21 <erisco> don't think, because GHC is weird, just try it
20:32:47 <erisco> for example, function composition with newtypes can add extra cost, and who would of predicted that
20:34:08 <dfeuer> erisco: I don't have time to test right now, but I'll bet you an ice cream cone. You don't happen to live near D.C., do you?
20:35:13 <erisco> you can then start tweaking it to try and overcome what GHC is getting stuck on, though
20:35:54 <dfeuer> Hmm..
20:36:23 <dfeuer> Actually, I forgot something; the strictness of the Step constructor might avoid the efficiency problem I was thinking about....
20:36:26 <erisco> the code I was reading earlier in Data.Foldable uses coerces instead of newtype constructors
20:36:51 <dfeuer> That strictness is a bit shady, but I guess the dark side has a light side.
20:36:55 <erisco> so, once you see where the problems arise, you can start thinking creatively
20:37:31 <dfeuer> erisco: I actually do have a decent sense of how to make library code fast ;-)
20:37:52 <erisco> I was hoping GHC would precompute some lists operations for a library I am making but turns out it doesn't
20:37:56 <dfeuer> My challenge it work is transferring to "how to make GHC fast", which is rather different.
20:38:01 <dfeuer> *at work
20:38:06 <erisco> so I did it differently… it is more aggressive with reducing lambdas
20:38:43 <dfeuer> Reducing lambdas?
20:39:09 <erisco> if I have  reverse [x,y,z]  GHC isn't inclined to reduce this to [z,y,x]
20:39:16 <dfeuer> No, it won't.
20:40:10 <erisco> but you can encode lists as functions, and it is more inclined to reduce those
20:40:14 <erisco> it reduces the applications
20:40:22 <dfeuer> Ugh.
20:40:27 <dfeuer> That sounds fragile.
20:40:46 <dfeuer> Why do you have reverse [x,y,z]?
20:41:24 <erisco> it is the simple way to change the associativity of a fold
20:44:03 <dfeuer> I guess, but it's not too hard to do it the other way around.
20:44:39 <erisco> once I figured it out, sure, it wasn't hard :P
20:44:53 <dfeuer> foldl f b (reverse xs) = foldr (flip f) b xs; foldr c n (reverse xs) = foldl (flip c) n xs
20:45:31 <dfeuer> But there's no shame in reversing a list by hand.
20:45:47 <erisco> I am folding function applications, and function application is left-associative
20:45:51 <dfeuer> Or with Template Haskell, if you can understand that scary stuff.
20:46:19 <erisco> so the simple way to define a right-associative fold is to make a list with the left fold, which is in reverse
20:46:31 <erisco> so, reverse this list, then do a right-associative list fold
20:47:00 <erisco> which is fine except that when I checked the Core output, GHC hardly reduced anything
20:47:29 <erisco> so that motivated me to be smarter
20:48:31 <erisco> and now when I check Core there is no difference… not that I can prove it for all cases, but it is so for the obvious use
20:48:46 <Cale> dfeuer: I don't know of anything that this is a special case of, or if it has a name or anything.
20:50:01 <dfeuer> erisco: I'd need to see the code to understand. But I don't have time now.
20:50:15 <erisco> you have a lot of IRC time though, seemingly ;)
20:50:24 <dfeuer> erisco: that's all time I shouldn't be here.
20:50:26 <dfeuer> ugh.
20:50:32 <dfeuer> Well, largely.
20:51:12 <erisco> I'll help. Copy/paste this and hit enter: /quit
20:51:42 <dfeuer> Cale: well, copy smells like it could be comonadic duplicate in some category? Maybe? I could be all wrong.
20:51:53 <dfeuer> But yeah, I Ishould do work or go to sleep.....
20:54:47 <erisco> and is a "monadic function" one with type of form  a -> m b  for Monad m?
20:55:22 <Cale> dfeuer: Yeah, though it's another level up -- maybe a comonad in some category of monad transformers or something?
20:55:32 <erisco> I would instead call that a Kleisli arrow
20:56:13 <erisco> are there any other monadic things?
20:56:16 <dfeuer> Cale: couldn't say; don't know enough category theory.
20:57:04 <dfeuer> Cale: the question would be whether it follows the laws to be whatever it looks like it should be...
20:57:25 <Svarog> has anyone tried using liquidhaskell and backpack at the same time? not tried it yet, just thought i'd ask
20:58:05 <Cale> dfeuer: Do you have some map  Stream f m r -> m r ?
20:59:29 <dfeuer> Cale: hrm.....
21:00:19 <dfeuer> Cale: I think if (Comonad f, Monad m), then yes. Not in the package though.
21:00:58 <Cale> (sort of an analogue for "extract")
21:02:32 <dfeuer> Cale: yes, you can get    (Comonad f, Monad m) => Stream f m r -> m r
21:02:47 <dfeuer> It generalizes the `effects` function in the package.
21:03:39 <erisco> one day you're going to make a whole program by choosing a couple morphisms and some instances
21:04:22 <dfeuer> erisco: I wish I were anywhere near that level of thinking. Maybe one day. It would be nice, but I don't feel like I'm getting much closer.
21:06:55 <erisco> I think "levels" is the wrong conceptualisation
21:07:16 <dfeuer> Okay?
21:07:26 <dfeuer> What is the right one?
21:08:16 <erisco> I am not sure what the analogy would be yet
21:08:38 <erisco> but, when I think "levels" I think of increasing difficulty, increasing burden
21:08:51 <erisco> I have to worry about more and more things, and that is not sustainable
21:10:22 <erisco> instead of levels I'd rather think… lets call it disjunctively, or I'd rather think by perspective
21:11:16 <erisco> so for example, do I need to concern myself with this being a level above, for some sense of "above", or can I just think about it completely independently
21:11:29 <erisco> forget and not care about what is underneath
21:11:44 <dfeuer> Hmmmm....
21:11:54 <erisco> that is sustainable because I only have to look at one level at a time, speaking in the level model
21:12:53 <erisco> thinking by perspective is to allow yourself to temporarily disassociate an object from other interpretations
21:13:10 <erisco> which can be tough to do
21:13:33 <erisco> for example, can you really disassociate this sentence from the meaning? can you really only see the letters, spaces, and punctuation?
21:13:42 <dfeuer> Yes, tough to keep track of what the abstraction "means".
21:14:04 <dfeuer> In a broad sense, while only temporarily "forgetting" the examples.
21:14:17 <erisco> but if you can achieve that, you can unburden yourself to see familiar things in new ways
21:14:31 <erisco> which is important when you have theories which overlap to describe similar things
21:14:46 <dfeuer> *nod*
21:16:57 <carlomagno1> 2017-09-07 
21:17:43 <geekosaur> not here :p
21:18:04 <erisco> for doing type level programming I attempt to disassociate my understanding of types from value level programming
21:18:07 <dfeuer> Nor even here.
21:18:12 <erisco> and I try to apply the perspective that my types are now values
21:18:31 <dfeuer> But that  seems .... relatively easy.
21:18:46 <erisco> which is easier than trying to conceptually balance kinds on top of types on top of values
21:19:10 <erisco> and don't get my started on sorts
21:20:14 <dfeuer> I wasn't planning to.
21:20:43 <erisco> it is tricky when you have a particular value-level objective in mind, though, but you do what you can
21:21:30 <dfeuer> The types are usually easier for me than the concepts.
21:21:43 <dfeuer> I can't remember what an adjunction is from one minute to the next.
21:22:22 <c_wraith> It's when you have two things with the right properties.
21:22:27 <c_wraith> Am I doing it right? :)
21:22:28 <dfeuer> Yes, that.
21:22:29 <erisco> I find it more difficult to remember what I have never needed
21:22:31 <dfeuer> :P
21:23:09 <dfeuer> Or what I've never known applied to what I've worked on....
21:23:49 <erisco> my brain likes it more when it first gets stuck and then sees the answer
21:23:58 <erisco> rather than seeing the answer and trying to retrospectively find the problems
21:24:17 <dfeuer> *nod*
21:24:19 <erisco> chronologically biased, I guess
21:24:22 <dfeuer> For sure.
21:25:21 <erisco> so if I really want to understand something, which is a serious commitment of time and effort, then I work ahead as much as I can
21:26:05 <dfeuer> Work ahead?
21:28:13 <erisco> for example, I am tepidly interested in AI, not yet committed to learning about it, but nonetheless can apply a "think ahead" principle
21:28:54 <erisco> merely starting with some intuition of what AI ought to look like you can reason a lot of things, without reading any particular technical answers
21:29:25 <erisco> for example, I did not know anything about "feature extraction" but I reasoned that a relevant problem for general AI
21:29:57 <erisco> on the other hand, if I just approached the topic as reading through a list of topics in AI I probably never gave myself the opportunity to think why these topics and not others
21:30:00 <erisco> or are some missing
21:30:33 <erisco> now when I look more deeply into material on feature extraction I know why I am there, what I need it for
21:32:04 <rosa> is this syntax universal for irc clients and irc servers? :es0x!~root@67.236.115.4 PRIVMSG ##linux :I saw that and was curious where it came from.  I have an idea lol
21:32:13 <erisco> you get to read a material and while learning new things you also see "oh, that's what they call it" and "oh, I had that problem too, how did they solve it?"
21:32:26 <monochrom> Yes rosa.
21:32:40 <pikhq> rosa: It is universal; https://tools.ietf.org/html/rfc2812 is the spec
21:33:48 <dfeuer> erisco: *nod*
21:34:20 <erisco> lately I am reading on rewrite systems which connects back to some messing around I did a couple years ago
21:34:44 <erisco> hadn't a clue what I was doing but stumbled onto some vague ideas
21:35:11 <erisco> some of them I saw again in context-sensitive languages but mostly now in rewrite systems
21:35:26 <erisco> which is incredibly satisfying to read now
21:38:37 <jared-w> What rewrite systems are you reading about now?
21:38:58 <erisco> well it is called "term rewriting"
21:39:49 <jared-w> ah, just the general topic of term rewriting rather than any specific implementation?
21:39:51 <erisco> so, none in particular, and so all of them ;)
21:39:56 <jared-w> gotcha :p
21:40:34 <jared-w> http://www.cs.cornell.edu/~ross/publications/eqsat/  have you seen anything about this at all?
21:41:05 <cocreature> heh, I still want to make a Haskell implementation of that paper
21:41:11 <erisco> no, but what I have seen is work on operational semantics which is based in term rewriting
21:42:33 <jared-w> Is it part of term rewriting or is it more of a related topic?
21:42:37 <erisco> and this is attractive because operational semantics are easier to give, they're executable (so it is also an implementation), and you can encode properties of these semantics as reachability rules
21:42:58 <jared-w> oh neat
21:43:50 <erisco> so, idealistically, you get a formal semantics for your language on the cheap and a proof system for free
21:44:25 <jared-w> but is it web-scale? :p
21:44:48 <erisco> I have been wondering for a while how our field is going to be transformed into one of assumptions into one of rigor
21:45:04 <erisco> and this seems a promising lead
21:45:24 <jared-w> What makes you say that our field is one of assumptions currently? (just wondering)
21:45:47 <rosa> this should reproduce my problem http://bpaste.net/raw/3dfd38855e61 as it is logically impossible to spawn infinite bash processes yet somehow it does and idk why
21:46:18 <cocreature> erisco: what’s the difference to the reduction system you get by a standard small-step semantics? that seems pretty close to a rewriting system already
21:47:13 <mbrock> I wish I had more time to look into http://fsl.cs.illinois.edu/index.php/K_and_Matching_Logic
21:47:22 <jared-w> rosa: this is probably the wrong channel for horrific bash abuse questions?
21:47:29 <erisco> cocreature, I don't know yet but I don't think anything is opposed here
21:47:50 <rosa> wich is  /bin/bash: warning: shell level (1000) too high, resetting to 1 (then it restarts x and fks everything up and i have to re-start the os to get all the applications working normally again)
21:47:59 <dfeuer> rosa: that is *off topic*.
21:48:31 <erisco> jared-w, specifications are typically stated informally, i.e. some document contingent on some understanding of natural language
21:48:54 <jared-w> ahh right, gotcha. Yeah that's always bugged me about programming languages
21:49:28 <erisco> the paper I was reading about the JavaScript spec was essentially a highbrow hit piece
21:49:31 <mbrock> erisco: have you looked into this K thing, or do you have some other interest?
21:49:41 <erisco> mbrock, yes, I have
21:50:03 <mbrock> their notion of the ideal language framework seems quite reasonable :)
21:51:10 <rosa> wtf even just catting the file reproduced the problem o.o
21:51:20 <erisco> jared-w, secondarily, for programs written in a language, the vast majority of properties we care about are unchecked
21:51:48 <erisco> jared-w, there is cost to formalising our intentions, but we also still need to develop ways to formalise them at all
21:52:11 <jared-w> And then hopefully from there figure out a way to avoid the cost; but you can't do that if nobody ever gets to the formalization step :p
21:52:59 <erisco> because there is the potential of a free proof system, that could be enough incentive for more people to start playing with it
21:53:28 <erisco> and it doesn't look so alien compared to the language itself
21:54:09 <pacak> o/
21:54:09 <pacak> Am I correct thinking that currently you can either pin thread to some capability by starting it with forkOn or to allow ghc to move it  around in any way it likes when it's started with forkIO?
21:54:12 <erisco> well, with K framework they plug problems into Z3, and are working on also having a Coq backend
21:54:14 <jared-w> It'd be neat if someone wrote a scheme or simple lisp in one of those so you got a nice language + proof system. Then a super rudimentary typed lambda calculus perhaps.
21:54:42 <erisco> the idea being that what Z3 cannot prove you can prove manually, which is a reasonable first step but will have to be much better integrated eventually
21:54:55 <jared-w> Which leads me to wonder; if you wrote a core language in one of those and then wrote languages which compiled down to the cores, could you get increasingly higher level languages "for free"?
21:55:43 <erisco> you can define LC in K framework, so you can go play with that if you like :)
21:56:49 <jared-w> sweet
21:57:04 <erisco> my first intention is to find and implement what can be given at zero cost, i.e. the programmer doesn't have to know anything, but it makes their life better
21:57:41 <erisco> I think there are some things you can assume about how the programmer wants their programs to behave to give useful help
21:57:52 <erisco> like, "don't crash" and "don't loop forever"
21:58:10 <erisco> or "you wrote this but it is simpler if you write that"
21:59:15 <erisco> there are some "code linting" tools that look for likely mistakes but I suspect they lack what this more complete approach could provide
21:59:17 <jared-w> In a completely off topic question: Regarding the trinity of computation (proofs <-> programs <-> generalized element of object, prepositions <-> types, X <-> category theory) what would X be? nLab only really gives X as "a relation between type theory and category theory"
21:59:46 <jared-w> erisco: most code linting seems to be blind "search for common error" so yeah, I'd say they're certainly lacking :p
22:00:08 <mbrock> static verification of the impossibility of assertion failures is pretty neat
22:01:13 <jared-w> But yeah, I'm wondering how one would really represent category theory /in/ a language. You can represent logic in a programming language as both the type system and a logical system (like Mercury or Curry allow or any other functional-logical programming system). I just don't know what category theory would be represented as in a language or how to "link" it with the other two...
22:03:37 <Cale> jared-w: https://github.com/jwiegley/category-theory
22:04:44 <Cale> https://github.com/jwiegley/category-theory/blob/master/Theory/Category.v#L37
22:05:03 <erisco> johnw is the oldest IRC user I know (by account age)
22:05:38 <jared-w> Cale: aww yiss, that's the good stuff; thanks!
22:06:00 <jared-w> is *.v Coq?
22:06:03 <Cale> yeah
22:06:24 * jared-w doesn't think this makes sense at all
22:06:47 <cocreature> I’m still annoyed that both Coq and Verilog use .v
22:06:55 <Cale> It's v for vernacular
22:07:34 <jared-w> cocreature: at least *.v feels normal for Verilog but really, "vernacular" for Coq? was *.dick already taken?
22:08:03 <cocreature> jared-w: well you can see why that didn’t use .c :)
22:08:29 <jared-w> hah, true, but .coq wouldn't have been too bad I think
22:09:31 <jared-w> "As a result, the definition of comonads is reduced to one line" *mind-blown*
22:10:23 <Cale> Definition Comonad `{M : C ⟶ C} := @Monad (C^op) (M^op).
22:10:26 <Cale> Yep
22:10:28 <dsal> Data.List \\ makes me sad.  I guess I could write a specialized one, but is there a handy one already that does something sensible for sorted lists?
22:11:03 <Cale> dsal: Would just turning them into sets be reasonable?
22:11:13 <Cale> dsal: Or do you need to preserve multiplicity?
22:11:17 <dsal> Yeah, they're sets.  I guess I could give that a go.
22:11:18 <pacak> dsal: Intersection? use set?
22:11:26 <jared-w> If they're sets, use set :p
22:11:27 <pacak> there's also multiset
22:11:27 <Cale> Not intersection, subtraction
22:11:31 <dsal> Difference, but yeah.  Let's see if set like... completes.
22:11:46 <Cale> Yeah, if they're sets, you shouldn't be using lists
22:11:59 <Cale> Data.Set has all the nice operations you want, and it's much more efficient
22:12:02 <jared-w> Leave that kinda monkey-typing to languages like C ;)
22:12:17 <MarcelineVQ> monochrom: thank you for your response
22:12:17 <erisco> a newtype list with a different Eq and Ord instance would be fine
22:12:46 <erisco> amusingly, compare would be more efficient than ==
22:13:17 <abrcdbr> f
22:13:34 <dsal> I don't quite understand strictness promises.  What's WHNF?
22:13:38 <dsal> weak something normal form.
22:13:41 <erisco> has anyone made a package for these lists? I might put it in acme
22:14:03 <erisco> they're at least a little bit interesting for the different == and compare complexity
22:14:19 <mniip> dsal, weak-head normal form
22:14:22 <erisco> and more general than Data.Set
22:14:43 <Cale> dsal: An expression is in weak head normal form if it is a lambda, or if it is a data constructor applied to any expressions.
22:15:34 <Cale> dsal: Evaluation to weak head normal form is what most practical evaluators for lazy functional languages do, because it's the least amount of evaluation you might need to do to be able to match a pattern
22:15:56 <Cale> (and ultimately, the main reason you evaluate anything is to match patterns)
22:16:13 <mniip> or apply functions
22:16:27 <Cale> indeed
22:17:33 <mniip> the first thing that happens is you apply the function main to State# RealWorld :p
22:19:34 <erisco> with very little you have computation happening… it sneaks up on you
22:19:51 <erisco> systems in motion
22:21:00 <jared-w> erisco: for what kinds of lists?
22:21:21 <erisco> jared-w, lists as sets
22:22:08 <jared-w> Mmm, to be honest I'm not quite sure why one would want lists as sets when there's sets and you can just turn them into lists or turn lists into sets at will
22:22:42 <erisco> they're more general by being less efficient
22:23:12 <erisco> but also I like examples of Eq and Ord which are not just the derived instances
22:25:28 <monochrom> You want list as set because it's an XYZ problem. You want a set, you recall that you used to use array as set in C, then you try to find an analogue of array in Haskell --- analogue in the sense that it's in the Prelude and it's an aggregate type --- and you arrive at list.
22:26:40 <monochrom> And yes I saw world-class ACM ICPC contestants using C array, unsorted, for priority queue in Dijksta's algorithm.
22:27:01 <monochrom> Then again, to be fair, Dijkstra's own first coding also did that.
22:28:30 <erisco> maybe someone else is thinking that way, and so I must oblige them
22:28:32 <dfeuer> erisco: how can compare ever be more efficient than ==?
22:28:56 <erisco> I like packages which are more like Rube Goldberg machines
22:29:10 <erisco> sure, something useful happens, but why do it in that way
22:29:23 <jared-w> monochrom: why would they do that? Like some sort of inane speed requirement thing?
22:29:35 <erisco> because it delights the senses :)
22:30:22 <erisco> dfeuer, think about how you'd equate two lists versus how you'd compare them
22:31:11 <erisco> dfeuer, or, think about the tools you'd have available
22:31:20 <monochrom> jared-w: Some sort of extreme laziness thing. Human laziness.
22:31:54 <dfeuer> erisco: I ... don't understand.
22:32:17 <dfeuer> You can always define  a == b = compare a b == EQ.
22:32:47 <erisco> mm, no, look at the types
22:32:50 <erisco> :t (==)
22:32:52 <lambdabot> Eq a => a -> a -> Bool
22:32:52 <erisco> :t compare
22:32:54 <lambdabot> Ord a => a -> a -> Ordering
22:33:28 <erisco> now think what the instance of this is for lists
22:33:35 <dfeuer> Oh, you mean that you can define == more efficiently if you use an Ord constraint on the Eq instance.
22:33:37 <dfeuer> Fine.
22:33:46 <dfeuer> So ... put one on there.
22:34:02 <erisco> no the point is you don't :P that is why compare ends up being more efficient
22:34:12 <erisco> and why lists and sets are more general than Data.Set
22:34:17 <erisco> lists as sets*
22:34:32 <dfeuer> More general?
22:34:39 <erisco> because to test two list-sets for equality you do not need Ord on the elements, only Eq
22:34:41 <dfeuer> Oh, I see.
22:35:16 <erisco> retrospectively maybe I should have just said that :P
22:35:51 <dfeuer> Well yes.
22:36:23 <erisco> I'm trying to stump you so you are more satisfied once you understand the brilliance of list sets
22:37:11 <dfeuer> Ha.
22:37:42 <erisco> and heck, you can stuff things into a list set without any constraint on elements
22:38:27 <dfeuer> erisco: fromDistinctAscList will do that for a Set :-P
22:38:58 <erisco> :t S.fromDistinctAscList
22:38:59 <lambdabot> [a] -> S.Set a
22:39:01 <dfeuer> You'll have to be very careful about what you do with it afterwards....
22:39:23 <olligobber> hey, Data.List sort is mergesort right? not quicksort?
22:39:33 <dfeuer> Right.
22:39:39 <olligobber> the code in it is really hard to read
22:39:57 <erisco> hm, the only useful operation after that I can think of is to go back to a list
22:40:22 <dfeuer> Proper randomized quicksort doesn't work too well for lists, and in Haskell would need to operate within some monad that offers randomness (or use unsafePerformIO).
22:40:43 <olligobber> I thought so
22:40:58 <dfeuer> olligobber: it's specially designed to take advantage of ascending and descending runs.
22:41:01 <monochrom> I'm actually OK with unsafePerformIO for this. :)
22:41:16 <olligobber> dfeuer, oh, that's what that is
22:41:29 <dfeuer> monochrom: yes, but you have to be careful! The unsafePerformIO goes around the *sort*, not the *random*.
22:41:57 <dfeuer> monochrom: oh, and you have to be sure that Ord is close enough to a total order.
22:43:42 <dfeuer> unsafePerformIO (sortIt xs =<< getSomeRandom) makes sense.  sortIt xs (unsafePerformIO getSomeRandom) does not.
22:44:16 <dfeuer> er, I mean  sortIt xs <$> getSomeRandom
22:45:22 <erisco> does it have to be a total order or just a partial order?
22:46:29 <dfeuer> erisco: I think it has to be total for an unstable unsafePerformIO-randomized sort to be safe.
22:46:40 <erisco> I am not actually sure how this relates to "compare"
22:46:54 <dfeuer> compare?
22:47:02 <erisco> the function
22:47:12 <monochrom> Oh we just liked to talk about quicksort.
22:48:14 <erisco> (\x y -> compare x y == LT) is a relation,  (\x y -> compare x y == GT) is another,  (\x y -> compare x y == EQ) is yet another, and so on
22:48:43 <erisco> but wholly I don't know what compare is, more specifically than a trinary relation
22:49:42 <olligobber> compare is part of the definition of Ord
22:49:59 <olligobber> if you have a type where compare happens, that type can be ordered
22:50:16 <mniip> erisco, compare is a total order homomorphism
22:50:22 <dfeuer> olligobber: erisco is well aware of this, and is trying to make some subtle point.
22:50:35 <dfeuer> I don't know what that point is.
22:50:42 <olligobber> ooh, are we doing algebra now
22:51:07 <erisco> dfeuer, the way I am seeing these as relations is by treating them uncurried and as characteristic functions for a set
22:51:28 <mbrock> wake up, have some coffee, observe some abstract and subtle discussions on #haskell, all feels right in the world
22:51:40 <dfeuer> uncurried? Do you mean curried?
22:51:41 <olligobber> wait, is compare valid as a group operator?
22:51:51 <dfeuer> Group?
22:51:58 <olligobber> algebraic group
22:52:10 <dfeuer> olligobber: no, I wouldn't think so. 
22:52:15 <mniip> you mean compare @Ordering ?
22:52:23 <dfeuer> olligobber: "homomorphism" in the categorical sense.
22:52:33 <mniip> yeah I don't think it makes a group
22:52:49 <olligobber> no, there is no identity element, never mind
22:53:25 <erisco> dfeuer, they are already curried. A relation as a set is a set of 2-tuples
22:53:27 <olligobber> I haven't studied much category theory yet
22:54:04 <erisco> dfeuer, so these characteristic functions are telling you if the tuple (x, y) is in the set
22:54:29 <mniip> hmm
22:54:31 <dfeuer> erisco: oh, I see.
22:54:36 <mniip> I think what I meant is,
22:54:42 <mniip> if we fix its second argument,
22:54:45 <mniip> compare is monotonic
22:55:15 <mniip> and anti-monotonic if we fix the first
22:55:23 <mniip> something about profunctors between partial orders
22:55:28 <mniip> but I can't quite pinpoint what
22:56:21 <erisco> mniip, can you help me see the homomorphism? what is the map and operation?
22:57:03 <mniip> erisco, if x >= y then compare x z >= compare y z
22:57:19 <erisco> I was kinda thinking of an answer where instead of being a characteristic function (i.e. 2-valued) we use something else that makes sense for 3-valued
22:58:08 <erisco> there should be something more we can do than just talk about "in the set" and "not in the set"
22:58:42 <monochrom> Suppose I have 3 binary relations L, E, R.  Their domains and codomains are all the same set or type S.  E is the identity relation on S.  L is irreflexive and transitive.  R is also irreflexive and transitives.  Lastly, they satisfy trichotomy: for all x,y in S, exactly one of xLy, xEy, xRy holds.  Does this induce a total order on S?
22:59:20 <mniip> if x >= y and z <= t then compare x z >= compare y t
22:59:24 <mniip> does that sound correct
22:59:43 <norc_> Is arrow to be understood as a morphism in hask?
23:00:02 <mniip> norc_, you mean Control.Arrow.Arrow?
23:00:03 <dfeuer> Are there classes for bifunctors that are monads/comonads in their first parameter?
23:00:19 <monochrom> Actually, does this induce a total order "<" on S such that xLy iff x<y iff xRy?
23:00:31 <norc_> mniip: Yup.
23:00:51 <mniip> norc_, no, Arrow is a morphism in a cartesian category
23:00:55 <mniip> not necessarily Hask
23:01:06 <mniip> instance Arrow (->)
23:01:09 <mniip> is the Hask morphism
23:01:18 <norc_> mniip: Oh! No way.
23:01:41 <erisco> mniip, do you mean that bidirectionally?
23:02:47 <norc_> mniip: Thank you, that made much sense. :)
23:03:00 <mniip> erisco, do I mean what bidirectionally
23:03:11 <erisco> mniip, your first if/then
23:03:17 <mniip> no
23:03:24 <mniip> only one direction need to hold
23:03:30 <erisco> well a homomorphism needs to be both ways
23:03:38 <mniip> no?
23:04:43 <mniip> homomorphism requires that for some operator S, f(S(x, y, ...)) = S(f(x), f(y), ...)
23:05:39 <norc_> erisco: Were you thinking about isomorphisms perhaps?
23:05:40 <erisco> yes, so I must be misunderstanding you
23:20:40 <plll[m]> What tends to be the standard for a WS server in haskell? Wai + Network.Websockets? 
23:21:09 <dsal> @pl (\x -> f x < n)
23:21:09 <lambdabot> (< n) . f
23:24:59 <erisco> monochrom, these exclusive or's are a pain, or I am doing it the hard way
23:37:57 <erisco> monochrom, what is used for the equivalence relation on S?
23:38:10 <erisco> you can't have a total order without an equivalence relation
23:40:46 <erisco> I guess obviously we just use the generic properties of the relation, since we don't know anything about S either
23:54:36 <kaffepanna> hum anyone here well versed with the ghc linker?
23:55:38 <cocreature> kaffepanna: you’ll get a better answer if you ask your actual question :)
23:56:02 <kaffepanna> cocreature: heh just trying to be polite and not just blurt things out :P
23:56:15 <opqdonut> on irc it's usually best to just ask
23:56:43 <cocreature> kaffepanna: it’s hard to know if you’re sufficiently “well versed” in a topic without knowing what the actual question is :)
23:56:55 <cocreature> so people tend to not respond to these kind of questions
23:56:55 <opqdonut> people reading your question 30min later are more inclined to answer if it's specific
23:57:06 <opqdonut> irc is asynchronous after all
23:57:22 <kaffepanna> well i have a stack project on my work project that i ultimatly use to build a docker image. but when i bring it home everythign breaks because the generated binary links against libgcc
23:57:35 <kaffepanna> and it did not use to link against libgcc so i dont have it in my base image
23:57:56 <kaffepanna> how cant that differ between two machines that use the same version of gcc? (via stack)
23:58:36 <cocreature> can you be a bit more specific? how exactly are you building the docker image and what does “bring home” mean
23:58:40 <cocreature> also what’s the error message
23:58:51 <geekosaur> the question may not be about gcc but about libraries linked in. system libraries (libc, libm, ...) in particular. if you have not forced all libraries used to be part of the docker image then you have no certainty about dependencies.
23:59:05 <geekosaur> and glibc and its components are not at all safe to force that way
23:59:11 <kaffepanna> sorry this keyboard is sticking and hard to type. well i brought the project home from my work laptop
23:59:32 <kaffepanna> trying to build it on a different machine that is
23:59:56 <kaffepanna> and the resulting binary that gets compiled differs
