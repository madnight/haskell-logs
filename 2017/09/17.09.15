00:01:11 <liste> zRecursive: well, pandoc, if you consider it an app
00:13:25 <haskellwel> ln = log in haskell?
00:13:38 <haskellwel> I.e. I want ln, but log can be used just fine?
00:17:24 <cocreature> haskellwel: yep, log is the logarithm to base e
00:25:39 <kadoban> A somewhat handy trick: no matter what the base of the logarithm is, you can always get a different one with: log my_num / log my_base
00:28:47 <nshepperd> > logBase 2 8
00:28:50 <lambdabot>  3.0
00:30:14 <cr1t1cal> are the ^ and ** operators the same
00:30:21 <cr1t1cal> ?
00:30:22 <olligobber> > putStrLn $ "Strings start from " ++ ["10"!!1]
00:30:26 <lambdabot>  <IO ()>
00:30:45 <olligobber> Well I guess...
00:30:54 <olligobber> > "Strings start from " ++ ["10"!!1]
00:30:57 <lambdabot>  "Strings start from 0"
00:31:34 <olligobber> cr1t1cal, no, ** works for decimals, ^ doesn't
00:31:40 <olligobber> > 2^1.5
00:31:42 <lambdabot>  error:
00:31:43 <lambdabot>      • Could not deduce (Integral b0) arising from a use of ‘^’
00:31:43 <lambdabot>        from the context: Num a
00:31:44 <olligobber> > 2**1.5
00:31:46 <lambdabot>  2.8284271247461903
00:32:01 <olligobber> also, ^ returns integers
00:32:23 <olligobber> well, ^ returns the same type as the thing you gave it I guess
00:32:36 <olligobber> I am not qualified to answer this :(
00:33:38 <olligobber> try checking the types of ^ and ** and you'll see the main difference
00:34:07 <Maxdamantus> > 2^1.5 :: Double
00:34:09 <lambdabot>  error:
00:34:09 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘^’
00:34:09 <lambdabot>        prevents the constraint ‘(Integral b0)’ from being solved.
00:34:20 <Maxdamantus> eh, nvm
00:34:35 <cocreature> cr1t1cal: if they both typecheck, they should return the same result. the difference is that (^) works for arbitrary instances of Num put only for non-negative integer exponents
00:34:41 <olligobber> ^ has type (Integral b, Num a) => a -> b -> a
00:34:55 <olligobber> so you have to raise to an integer power
00:36:04 <olligobber> > (2::Int)**2
00:36:06 <lambdabot>  error:
00:36:06 <lambdabot>      • No instance for (Floating Int) arising from a use of ‘**’
00:36:06 <lambdabot>      • In the expression: (2 :: Int) ** 2
00:36:13 <olligobber> cocreature, ^
00:36:30 <cocreature> olligobber: what are you trying to tell me by that?
00:36:58 <olligobber> cocreature, ** doesn't work on integers
00:37:39 <cocreature> fair point, although you can just use fromIntegral
00:37:49 <olligobber> yeah
00:38:22 <cocreature> (^) simply uses the implementation of (*) provided by the Num instance. (^) is something that needs to be implemented separately
00:38:29 <cocreature> eh the latter should be (**)
00:38:30 <nshepperd> a^b works - for any numeric a - for positive integer b
00:39:00 <nshepperd> a^^b works - for any fractional a (eg. Rational) - for integer b
00:39:07 <nshepperd> > 2 ^^ (-1)
00:39:10 <lambdabot>  0.5
00:40:01 <olligobber> > 2^^1.5
00:40:04 <lambdabot>  error:
00:40:04 <lambdabot>      • Could not deduce (Integral b0) arising from a use of ‘^^’
00:40:04 <lambdabot>        from the context: Fractional a
00:40:08 <olligobber> ok
00:40:15 <nshepperd> a**b for any a,b that are both floating point numbers
00:40:50 <cocreature> I still think overloading the type of the exponent in (^) was a mistake but it’s definitely too late to change it now
00:42:32 <olligobber> cocreature, can you explain what "overloading the type" means?
00:42:36 <nshepperd> so, (^) < (^^) < () in terms of the kind of exponents they accept... (^) for nonnegative integers, (^^) for positive or negative integers, () for anything
00:42:48 <nshepperd> whoops
00:42:51 <olligobber> lol
00:43:23 <cocreature> olligobber: accepting an arbitrary instance of Integral instead of limiting it to Integer or something like that
00:43:34 <nshepperd> I used to use ** to write bold in this client... I thought i deleted that script
00:43:53 <cocreature> in about 90% of the cases where I use (^), the exponent is fixed and I get annoying defaulting warnings
00:44:29 <cocreature> then again the 10% would be really annoying if it wasn’t overloaded, so I’m not sure what the best solution would be
00:44:31 <olligobber> cocreature, I think accepting arbitrary Integrals is better, and I don't get why some functions are limited to Ints
00:45:25 <cocreature> I’d agree with that for a lot of other functions, it’s (^) in particular where the overloading seems to be more annoying than useful
00:45:54 <haskellwel> >log 1
00:45:58 <haskellwel> > log 1
00:46:00 <lambdabot>  0.0
00:46:39 <haskellwel> > log 2.718
00:46:42 <lambdabot>  0.999896315728952
00:46:53 <kadoban> :t (^)
00:46:55 <lambdabot> (Num a, Integral b) => a -> b -> a
00:47:29 <kadoban> I use the overloading of both things in (^) fairly often ... though I don't think I ever have exponents bigger than Int
00:48:45 <nshepperd> does the compiler still complain about writing things like (^2)?
00:48:52 <kadoban> It's quite pleasing that it does the square-and-multiply thing, so if you just implement some Num for whatever random thing, you automatically have fast exponentiation.
00:49:02 <kadoban> nshepperd: I think you get a warning about it defaulting to Integer
00:49:02 <cocreature> nshepperd: with -Wall it does, that’s exactly what’s annoying me :)
00:49:07 <nshepperd> i'd hope it would just default it to Integer and chill out
00:49:19 <kadoban> Which, yeah is a tad tedious.
00:49:21 <cocreature> maybe I should just disable defaulting warnings
00:49:28 <cocreature> but I’m not a big fan of defaulting
00:49:45 <olligobber> > exp(1)
00:49:47 <lambdabot>  2.718281828459045
00:49:53 <olligobber> haskellwel, e is there ^
00:49:54 <kadoban> For performance reasons they're sometimes pretty important, but ... ya usually I just don't care, and when I do I dunno, doesn't seem too hard to find them.
00:54:21 <cr1t1cal> i have a problem
00:55:04 <cr1t1cal> (2 ^ 63) in ghci is equal to (using ==) minBound :: Int
00:55:06 <cr1t1cal> why?
00:55:17 <cr1t1cal> 2 ^ 63 is positive, minBound :: Int is negative
00:55:28 <cr1t1cal> and althought they produce the same number, they are technically not the SAME, right?
00:55:32 <cr1t1cal> *although
00:55:52 <cocreature> because the maximum positive integer that you can represent using a 64bit integer is 2^63-1
00:56:01 <cocreature> so you get an overflow
00:56:03 <kadoban> cr1t1cal: Int and other machine integer types wrap around
00:56:18 <nshepperd> > (2 ^63) :: Integer
00:56:21 <lambdabot>  9223372036854775808
00:56:28 <nshepperd> > (2 ^ 63) :: Int
00:56:30 <lambdabot>  -9223372036854775808
00:56:33 <phadej> > maxBound :: Int64
00:56:35 <lambdabot>  9223372036854775807
00:56:48 <cr1t1cal> > (2 ^ 63) == (minBound :: Int)
00:56:50 <lambdabot>  True
00:57:02 <cr1t1cal> > (2 ^ 63)
00:57:04 <lambdabot>  9223372036854775808
00:57:07 <cr1t1cal> > (minBound :: Int)
00:57:09 <lambdabot>  -9223372036854775808
00:57:19 <olligobber> cr1t1cal, one of those is an Integer, the other is an Int
00:57:32 <cr1t1cal> I dont understand why they are the same, and how integer overflow has anything to do with it
00:57:38 <cr1t1cal> olligobber: why?
00:57:43 <phadej> fwiw, report says
00:57:43 <phadej> data Int
00:57:44 <phadej> A fixed-precision integer type with at least the range [-2^29 .. 2^29-1].
00:57:48 <olligobber> cr1t1cal, to compare them, they have to be the same type, so you're actually comparing (2^63)::Int with minBound::Int
00:57:54 <bartavelle> cr1t1cal: when you write a numerical value, it is syntactic sugar for "fromInteger xxxx"
00:58:02 <nshepperd> cr1t1cal: when you just type '2^63' in the repl, it defaults the type to Integer
00:58:04 <phadej> so if you really need 2^n number, juse Int64, Int32 etc
00:58:14 <bartavelle> (but that is not relevant here, sorry)
00:58:30 <cr1t1cal> > (2 ^ 63 :: Int) == (minBound :: Int)
00:58:33 <lambdabot>  True
00:58:47 <cr1t1cal> > (2 ^ 63 :: Int)
00:58:48 <nshepperd> when you type 2^63 == (minBound :: Int), the type is Int, because the minBound is an Int
00:58:50 <lambdabot>  -9223372036854775808
00:58:56 <cr1t1cal> ahh
00:59:11 <cr1t1cal> holy shit that makes sense
00:59:24 <cr1t1cal> also explains this
00:59:30 <bartavelle> cr1t1cal: the other output, would, with warnings, tell you it chose "Integer" between all the types "2 ^ 64" could be
00:59:36 <cr1t1cal> > (2 ^ 63) == (maxBound :: Int)
00:59:38 <lambdabot>  False
00:59:39 <bartavelle> erm 63
00:59:57 <cr1t1cal> > (2 ^ 63 :: Int) == (maxBound :: Int)
00:59:59 <lambdabot>  False
01:00:04 <cr1t1cal> oh
01:00:06 <cr1t1cal> -_-
01:00:08 <bartavelle> > (2 ^ 63 - 1) == (maxBound :: Int)
01:00:11 <lambdabot>  True
01:00:18 <cr1t1cal> why the -1?
01:00:43 <bartavelle> that's how signed binary numbers are represented, there is a wraparound 
01:00:52 <olligobber> cr1t1cal, if the max int is one less than a power of 2, twos complement subtraction works nice
01:01:00 <bartavelle> (maxBound + 1 :: Int) == minBound
01:01:01 <bartavelle> > (maxBound + 1 :: Int) == minBound
01:01:04 <lambdabot>  True
01:01:04 <cr1t1cal> bartavelle: so the wraparound happens AT 2 ^ 63?
01:01:17 <bartavelle> > maxBound :: Int == minBound - 1
01:01:20 <lambdabot>  error:
01:01:20 <lambdabot>      Not in scope: type constructor or class ‘==’error:
01:01:20 <lambdabot>      Not in scope: type constructor or class ‘-’
01:01:28 <bartavelle> > (maxBound :: Int) == minBound - 1
01:01:31 <lambdabot>  True
01:01:41 <cr1t1cal> wait
01:01:43 <cr1t1cal> this is confusing
01:01:47 <cr1t1cal> why do we need the -1
01:01:55 <cr1t1cal> when the max IS 2 ^ 63?
01:02:04 <bartavelle> the max is "2 ^ 63 - 1"
01:02:10 <bartavelle> not "2 ^ 63"
01:02:15 <cr1t1cal> and the wraparound happens at 2 ^ 63?
01:02:19 <bartavelle> > minBound :: Int
01:02:22 <bartavelle> > maxBound :: Int
01:02:23 <lambdabot>  -9223372036854775808
01:02:26 <lambdabot>  9223372036854775807
01:02:40 <olligobber> 2^63 -1 is the biggest Int, one more than it wraps to the smallest Int
01:02:49 <cr1t1cal> thanks
01:02:58 <bartavelle> perhaps
01:03:05 <bartavelle> printf "%x" (minBound :: Int)
01:03:09 <bartavelle> > printf "%x" (minBound :: Int)
01:03:12 <lambdabot>  error:
01:03:12 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M387858403246...
01:03:12 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
01:03:23 <bartavelle> > printf "%x" (minBound :: Int) :: String
01:03:27 <lambdabot>  "8000000000000000"
01:03:31 <bartavelle> > printf "%x" (maxBound :: Int) :: String
01:03:33 <lambdabot>  "7fffffffffffffff"
01:03:34 <olligobber> is that hex?
01:03:43 <bartavelle> yeah, it makes the binary easier to see
01:04:29 <bartavelle> negative numbers have the most significant bit set
01:04:42 <bartavelle> the the larget positive number has this form
01:05:08 <nshepperd> twos complement with 3 bits: -4, -3, -2, -1, 0, 1, 2, 3
01:05:24 <nshepperd> 100, 101, 110, 111, 000, 001, 010, 011
01:06:39 <olligobber> take the binary representation of x, swap all the 1s for 0s and 0s for 1s, and you're at -x-1
01:06:57 <bartavelle> cr1t1cal: this is called 2's complement, and it is handy because you can do addition/substraction like it is unsigned
01:07:14 <bartavelle> > printf "%x" (-1 :: Int) :: String
01:07:17 <lambdabot>  "ffffffffffffffff"
01:07:31 <bartavelle> obviously, adding 1 wraps around and gives you 0
01:07:55 <will> Can anyone help me with a problem building my Yesod project?  stack build fails with "Process exited with code: ExitFailure (-9) (THIS MAY INDICATE OUT OF MEMORY)".  Yesod devel works fine.
01:08:07 <will> I have 16GB memory, it's not a huge project
01:08:28 <dminuoso> "this may indicate out of memory" - that's one mighty diagnostic.
01:08:37 <bartavelle> does it eat all memory anyway?
01:08:49 <bartavelle> will: are you using the latest stack version
01:08:50 <will> No
01:08:57 <will> Let me check
01:09:06 <bartavelle> perhaps it is a solved bug
01:09:18 <bartavelle> latests stable is 1.5.1
01:09:25 <will> I'm using 1.4.0
01:09:28 <will> Will check what the latest is
01:09:37 <bartavelle> try upgrading, perhaps your problems will go away
01:09:59 <will> Will do - thanks, good idea!
01:10:25 <merijn> bartavelle: In my experience upgrading usually increases the number of problems I have :p
01:11:39 <bartavelle> merijn: yeah, but maybe that makes them more interesting? :)
01:13:03 <olligobber> > (2^63 :: Integer) == fromIntegral (minBound::Int)
01:13:05 <lambdabot>  False
01:13:13 <olligobber> this is horrible
01:14:15 <kadoban> What's wrong with that?
01:15:01 <merijn> Why would minBound of Int equal 2^63?
01:15:05 <merijn> > minBound :: Int
01:15:07 <lambdabot>  -9223372036854775808
01:15:10 <cr1t1cal> weird question
01:15:14 <cr1t1cal> how to exit ghci?
01:15:19 <merijn> cr1t1cal: :quit
01:15:27 <cr1t1cal> merijn: thanks lol
01:15:29 <merijn> cr1t1cal: And/or ctrl-d (on unix, anyway)
01:15:45 <kadoban> Probably ctrl-z on windows?
01:16:14 <ongy> > 2^63 :: Integer
01:16:16 <lambdabot>  9223372036854775808
01:16:27 <ongy> olligobber: it's jus the wrong sign
01:16:54 <olligobber> I know why it's correct
01:16:57 <saurabhn_> does the type-inference work different for top-level definitions as compared to where-level expressions?
01:17:02 <ongy> > maxBound :: Int
01:17:04 <lambdabot>  9223372036854775807
01:18:01 <olligobber> the code itself looked bad, that's all
01:18:07 <bartavelle> saurabhn_: it probably is more a question of in which order unification happens, but I am no expert on the topic
01:18:36 <bartavelle> no expert on the english language either, apparently
01:19:02 <saurabhn_> hmm
01:19:25 <saurabhn_> where-definition seems to be inferring a very different type compared to top-level definintion. The latter is far more general.
01:19:48 <bartavelle> that is something I observed too
01:20:22 <bartavelle> for more complex types (such as functions taking lenses as arguments), it just will not work without type annotations in where clauses
01:22:11 <saurabhn_> bartavelle: exactly. lenses is my use-case as well.
01:22:47 <will> Upgrading stack didn't fix my problem, but weirdly I've tracked down a bit of code that makes the difference between stack build crashing and not crashing...
01:23:05 <barrucadu> saurabhn_: bartavelle: That sounds like the monomorphism restriction
01:23:08 <will> It is some code defining a Yesod form
01:23:22 <will> Replacing the definition with "undefined" makes stack build work without a hitch
01:23:45 <barrucadu> Let- or where-bound things which have a class constraint don't get the fully general type, because that could lead to recomputing things needlessly in some cases
01:24:17 <barrucadu> eg, imagine: let x = some expensive computation of type Num a => a in x + x, if that were totally polymorphic, x might be computed twice
01:25:03 <u-ou> why?
01:25:23 <will> If anyone is feeling helpful, this is the code that makes stack build crash: http://lpaste.net/358466
01:25:30 <barrucadu> There are a few examples here: https://wiki.haskell.org/Monomorphism_restriction
01:25:32 <will> stack exec yesod devel has no problem with it
01:25:46 <bartavelle> oh that is interesting :)
01:26:32 <bartavelle> sounds more like a GHC bug than a stack problem
01:29:37 <cr1t1cal> what is the point of the keyword cycle?
01:30:23 <dminuoso> cr1t1cal: there is no such keyword
01:30:37 <cr1t1cal> meh
01:30:41 <cr1t1cal> built-in function?
01:30:46 <dminuoso> cr1t1cal: not even that.
01:30:54 <cr1t1cal> operator?
01:30:58 <dminuoso> cr1t1cal: http://hackage.haskell.org/package/base-4.10.0.0/docs/Data-List.html#v:cycle
01:31:12 <cr1t1cal> what the heck is it called? haha
01:31:14 <dminuoso> cr1t1cal: From what I can tell, Haskell has almost nothing "builtin"
01:31:31 <MarcelineVQ> cr1t1cal: just a plain old function
01:31:31 <cr1t1cal> dminuoso: ok then. library function?
01:31:32 <dminuoso> cr1t1cal: It's just there because whoever wrote your prelude thought it would be useful
01:31:47 <cr1t1cal> right. that's good
01:31:50 <cr1t1cal> i like that
01:32:05 <cr1t1cal> anyways, what does this library function cycle do and what is it useful for?
01:32:15 <dminuoso> cr1t1cal: check out the link I just gave you :)
01:32:15 <bartavelle> > cycle [True..False]
01:32:17 <lambdabot>  error:
01:32:18 <lambdabot>      Not in scope: ‘True..’
01:32:18 <lambdabot>      No module named ‘True’ is imported.error:
01:32:22 <bartavelle> > cycle [True, False]
01:32:24 <lambdabot>  [True,False,True,False,True,False,True,False,True,False,True,False,True,Fals...
01:32:45 <bartavelle> > filter snd (zip [1..] (cycle [True, False]))
01:32:46 <cr1t1cal> > cycle [1, 2, 3]
01:32:48 <lambdabot>  [(1,True),(3,True),(5,True),(7,True),(9,True),(11,True),(13,True),(15,True),...
01:32:48 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
01:33:00 <cr1t1cal> so its replicate
01:33:01 <dminuoso> cr1t1cal: if you think of a list as a rope, cycle takes both ends and knots them together
01:33:02 <cr1t1cal> but
01:33:04 <dminuoso> no
01:33:35 <dminuoso> cr1t1cal: think of a finite list as a rope that has two ends. cycle just takes them, and ties them to a knot so that it becomes a cicle.
01:33:47 <dminuoso> *circle/cycle
01:34:01 <cr1t1cal> dminuoso: lol. not a bad pneumonic
01:34:02 <sphalerite> loop :D
01:35:00 <olligobber> (cycle a) returns (a ++ cycle a) right?
01:35:11 <cr1t1cal> dminuoso: have I talked to you on the c++ chan? not relevant but quick question
01:35:56 <dminuoso> cr1t1cal: Ive been around there.
01:41:10 <dminuoso> olligobber: Almost yeah. It also has a pattern match for [] for which it returns an error.
01:42:07 <dminuoso> olligobber: Also technically its implemented with tying the knot so that it wont cost you increasing amounts of resources.
01:42:47 <dminuoso> http://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.List.html#cycle
01:46:04 <saurabhn_> are there any examples of using Reflex FRP **outside** the context of browser/DOM? Specifically in the context of web APIs and databases?
01:50:46 <bartavelle> saurabhn_: you are certainly adventurous! What would that mean?
01:51:02 <bartavelle> I mean, what would be the events?
01:51:12 <saurabhn_> API requests.
01:51:23 <bartavelle> ah, interesting
01:51:29 <saurabhn_> eg. createUser, sendActivationLink, etc.
01:51:55 <saurabhn_> we've just gone through a cycle of architecting our backend and it seems we are either reinventing Elm/React for the backend OR Reflex.
01:52:16 <saurabhn_> and instead of the DOM being patched, it's actually the DB being patched.
01:53:09 <saurabhn_> the only difference is that the entire state is not held in the memory. A part of the state is loaded from the DB, the incoming even is applied, the reactive framework propagates the required changes, the DB is patched, and the resultant state is serialised (as JSON) and sent back to the browser.
01:54:46 <bartavelle> I have something like that, but it is probably not at the scale you are using, because I just handle the "shared state" with STM and am for now happy with it
01:55:00 <phadej> except Elm/React do keep the state in memory
01:55:24 <bartavelle> where the "shared state" is mostly caching for user permissions
01:55:31 <phadej> I also has something like that, but keep whole state in memory and write incoming events to db
01:56:09 <bartavelle> phadej: so the db is like a log?
01:56:14 <phadej> bartavelle: yes
01:56:34 <bartavelle> and the architecture is such that you can replay, rewind, etc?
01:56:47 <phadej> technically yes
01:56:55 <bartavelle> nice!
01:57:01 <phadej> in fact, it does replay on a startup now
01:57:18 <phadej> but could also have snapshots (don't bother, replaying is fast)
01:57:36 <phadej> developing company internal tools is nice, as working sets are small (but the logic is complex)
01:57:42 <bartavelle> do you use a specialized db for that, or plain old postgresql?
01:58:03 <phadej> postgresql :)
01:59:11 <saurabhn_> phadej: any article describing your architecture in detail?
01:59:17 <saurabhn_> phadej: handwritten, or reflex on the backend?
02:00:10 <bartavelle> but would something like reflex be a good fit for that problem?
02:00:13 <phadej> saurabhn_: essentially it's `Command -> MonadState World ()` (there is such function)
02:00:51 <saurabhn_> phadej: that sounds like Elm on the backend.
02:00:53 <phadej> bartavelle, saurabhn_: I don't think that reflex handles concurrent updates
02:01:09 <phadej> especially independent ones
02:01:15 <bartavelle> you don't reply to clients ? it is a kind of sink ?
02:01:39 <phadej> bartavelle: ah, there are replies yeah. MonadState World Reply, sorry
02:02:02 <phadej> it's damn simple, but it works for a <500 people company ;)
02:02:24 <bartavelle> you push all messages through a channel or something ?
02:02:30 <bartavelle> hum
02:02:41 <bartavelle> how do you handle concurrent updates?
02:03:04 <saurabhn_> phadej: reflex doesn't need to worry about concurrent updates -- that's the DB's problem. Essentially every request will be a mini-Reflex app that gets setup ONLY for that request, and later gets torn down once the request has been served.
02:03:05 <phadej> bartavelle: I don't atm, but I have only very short critical section
02:03:37 <bartavelle> saurabhn_: why use something like reflex when you will only have one event ?
02:03:45 <phadej> indeed
02:03:58 <bartavelle> aren't you looking for an excuse to have fun with FRP? :)
02:04:05 <scav> Has anyone tested cabal 2.0 and where does stack fit in with it now?
02:04:42 <scav> I assume its not changing anything for stack, but would love some input on this :)
02:04:48 <saurabhn_> the same reflex "widget" can handle multiple events. It's just that it gets re-built between every such event.
02:05:03 <bartavelle> why not just a plain function ?
02:05:19 <saurabhn_> eg. createUser, sendActivationEmail, disableUser, loginUser, can all be served from the same reflex "widget/network"
02:05:25 <bartavelle> if you have shared state, something like "Request -> STM (IO Reply)"
02:05:31 <saurabhn_> bartavelle: callback. cached columns. 
02:05:43 <bartavelle> ahhh
02:07:23 <phadej> I still don't think it's worth complexity. Something like user handling is so slow paced and critical that you would like to have SERIALIZABLE isolation anyway
02:09:43 <saurabhn_> btw, parallel question... is there ANY OTHER viable approach to splitting pk from the val while dealing with the DB (i.e. the persistent approach)?
02:12:19 <saurabhn_> rephrase: any other viable approach to DB interaction apart from splitting pk and entityVal?
02:12:53 <bartavelle> if you never insert, you don't have to split :)
02:13:08 <bartavelle> well, insert with a server-generated key at least
02:15:24 <saurabhn_> which would mean UUIDs
02:15:29 <saurabhn_> anything else?
02:15:52 <saurabhn_> I seem to have tried to NOT do this, but have replicated the same PK/Val splitting logic all over again in Opaleye
02:21:34 <bartavelle> (you should probably use uuids anyway)
02:23:55 <saurabhn_> bartavelle: why?
02:24:41 <bartavelle> saurabhn_: there is rant here https://www.clever-cloud.com/blog/engineering/2015/05/20/why-auto-increment-is-a-terrible-idea/
03:01:38 <jbergok> hi, im using vim with spf13 configuration, and im wondering what's the best/easiest way to get a nice haskell environment on top of that without breaking spf13's setup and do it somewhat automatic?
03:07:36 <kuribas> what's the recommended clean install for haskell on linux mint?  Stack or haskell platform?
03:07:53 <kuribas> or both?
03:09:30 <digitalkiwi> actually I was wondering if people use nixos
03:11:32 <speak> I'd use Stack probably but that's just me
03:13:17 <srk> digitalkiwi: I do, going to switch my primary laptop to it soon
03:13:35 <srk> it's pretty cool for development, especially haskell
03:13:51 <srk> *for
03:15:34 <kuribas> I tried installing stack, but it didn't work...
03:16:26 <speak> Try harder
03:17:06 <geekosaur> kuribas, I installed ghc from hvr's PPA and went from there
03:21:58 <mbrock> digitalkiwi: been using it on my laptops and servers since spring 2015 :)
03:23:53 <kuribas> well, it's on my work laptop, probably I am not going to write haskell here...
03:24:11 <kuribas> Maybe I can sneak it in for a one-time script ...
03:29:12 <balajeerc> Hi, I am a Haskell beginner. I am currently working my way through problems in the Haskell track of exercism.io While my solutions are expectedly too verbose, and other solutions by presumably experienced Haskellers weigh in at a fifth of the line count of my code, the solutions seem to be far too diverse. I am investing a lot of time reading other people's code but I can't seem to find the "idiomatic" way
03:29:14 <balajeerc> of doing things. Such diversity of solution is not common to other more mainstream imperative languages. I guess what I am asking for is if there are any linters that help hone in on "idiomatic haskell".
03:30:13 <kuribas> hlint does
03:30:35 <balajeerc> Also, is my observation of there being way many more ways to achieve a task in Haskell as compared to other mainstream languages along the lines of what experienced Haskellers have observed as well?
03:31:05 <maerwald> balajeerc: yeah, sometimes too many :>
03:31:32 <haskellwel> [Int] can this be a list of ints like [1,2,3,4,5,6]? Or is it just a list with one int like [1]?
03:31:51 <speak> balajeerc: Yes I've encountered the same. Tons of ways to do everything
03:32:19 <maerwald> because functions are practically also control flow things, not just for loops, then you have 20+ ways of combining something which ends up being the same
03:33:12 <mbrock> sometimes people try too hard to be "idiomatic", or perhaps rather than idiomatic I should say "clever"
03:33:22 <maerwald> yeah
03:33:46 <mbrock> this cleverness is kind of a beautiful aspect of Haskell tradition, and lots of cool things emerge from people playing around with the possibilities of the language...
03:34:00 <maerwald> it's also annoying :>
03:34:32 <balajeerc> mbrock: That is precisely it. It seems that for every Haskell solution I can think of, there is half a dozen other more consise solutions. Now, at some point, being too clever is NOT good. 
03:35:02 <mbrock> yeah, so when people on IRC look at your code and say "you can implement that with a simple `fmap (. fmap (<|>)) >>> msum`" you should probably mostly nod politely
03:35:27 <maerwald> it starts with pointless style, then people do their own operators/prelude, then they forge types, because simple types are too boring
03:35:43 <speak> balajeerc: Just don't try to find the optimal solution. Just move on
03:35:44 <balajeerc> I just cant figure out, and worse, figure out a learning path to figure out, the sweet spot between expressive/readable code and "clever" code.
03:36:03 <maerwald> never do "clever" code
03:36:42 <maerwald> correctness, readability, then if you have time... performance maybe or other secondary things
03:36:59 <balajeerc> maerwald: Agreed. But I suppose there is such a thing as too verbose as well. My last submission to exercism actually said as much: readable but too verbose.
03:37:09 <mbrock> part of the difficulty is that some things might seem excessively clever to one person but to another person it's just a natural use of some abstraction they think is great
03:37:18 <balajeerc> Er... I meant that a comment on my last exercism submission.
03:37:40 <maerwald> conciseness is only good if it either maintains or increases readability
03:37:48 <mbrock> like I know that some people consider the `lens` library to be way too clever and advanced, but for me it's just a practical way to make my code less verbose and in fact easier to read and understand
03:38:10 <maerwald> programming is not maths
03:38:20 <maerwald> so don't try to be as concise as possible just for the sake of it
03:38:46 <maerwald> we have compilers
03:40:22 <mbrock> my optimum is when code reads clearly in terms of the "domain language", perhaps so that someone who is familiar with the purpose of the program, but not so much with Haskell, can look at the code and go "yes, this seems to make sense"
03:40:25 <balajeerc> mbrock: Right. I feel there is much more consensus on "too clever" vs idiomatic in other languages. Such consensus seems difficult in Haskell.
03:41:01 <balajeerc> And I dont know if that is a bad thing or actually what makes Haskell wonderful.
03:41:01 <mbrock> probably true, although there are similar "issues" in other traditions. For example how much to use metaprogramming in Ruby, macros in Lisp, etc
03:41:06 <maerwald> balajeerc: because haskell is not just used for practical stuff
03:41:18 <maerwald> e.g. you won't see such conflict in Go
03:41:20 <dminuoso> balajeerc: idk. I can think of quite a few languages where that holds true as well.
03:41:51 <balajeerc> dminuoso: Like?
03:41:53 <dminuoso> balajeerc: When you write raw assembler that line between "too clever" and "idiomatic" is quite thin.
03:41:56 <maerwald> haskell is also used for a lot of experimentation and ofc people don't care about all those practical principles then
03:42:36 <JuanDaugherty> ofc?
03:42:58 <mbrock> it's a too clever idiom that means "of course" ;)
03:43:05 <maerwald> lol
03:43:08 <JuanDaugherty> ah
03:43:46 <JuanDaugherty> you seem to be arguing against what haskell is about
03:44:01 <maerwald> haskell is not about anything
03:44:01 <JuanDaugherty> and why it has a fervent following
03:44:05 <maerwald> it's just a language
03:44:40 <JuanDaugherty> and mathematics is just another kind of thinking
03:44:50 <mbrock> well, a language associated with a tradition/community. Or maybe a few different traditions/communities :)
03:44:51 <JuanDaugherty> thoughts is thoughts
03:45:08 <maerwald> there is no "maths"
03:45:12 <maerwald> it's not consistent
03:45:24 <maerwald> and neither is haskell, or the ecosystem
03:45:41 <maerwald> and that's ok
03:45:50 <JuanDaugherty> mathematics, although it is realized as a cultural system, is not culture dependent, the work product is universal
03:46:24 <maerwald> maths has a long history with very different "ecosystems/movements/arguments/axioms/...
03:47:40 <JuanDaugherty> Mathematics as a Cultural System, Raymond Wilder, UCSB, 1981
03:48:04 <maerwald> no idea what that means
03:48:17 <mbrock> balajeerc: anyway, if an instructor says your code is too verbose, there might be some nice way to improve it without making it harder to understand
03:48:33 <JuanDaugherty> it's a title, maerwald 
03:48:44 <maerwald> JuanDaugherty: I can copy paste book titles too
03:48:55 <maerwald> but I usually don't :>
03:49:11 <JuanDaugherty> i was going full Ken Burns on the topic
03:49:54 <JuanDaugherty> forgot ur actuall in de, had you confused with Welkin
03:50:07 <mbrock> balajeerc: and for example using standard combinators like map/fold instead of explicit recursion is almost always more idiomatic, and you basically need to learn such things to be proficient
03:50:11 <balajeerc> mbrock: Yeah. Just that I have no instructor. Hoping to get by by reading other people's code and each 'alternative' I see seems more elegant to me than the last one.
03:50:22 <JuanDaugherty> Ken Burns is a documentarian, who ends lil sniglets with credits like that
03:50:33 <mbrock> balajeerc: there's a funny old HTML article related to this... "The Evolution of a Haskell Programmer"
03:50:46 <mbrock> https://www.willamette.edu/~fruehr/haskell/evolution.html
03:51:25 <maerwald> correctness > elegance
03:51:29 <maerwald> worry about the things that matter
03:51:33 <mbrock> it's full of functional programming in-jokes :)
03:52:46 <JuanDaugherty> *actually
03:54:34 <JuanDaugherty> i guess FP is sort of the old senescent baby, the next OO which can't quite do what OO did, i.e. dominate computing
03:54:52 <maerwald> OO?
03:55:05 <JuanDaugherty> object oriented
03:57:37 <JuanDaugherty> although my perception is it has about the same cache as OO did c. '1990 and much greater actual penetration
03:57:47 <JuanDaugherty> *cachet
03:57:52 <maerwald> because the main thing which true FP does (purity, effects) is impractical for a lot of use cases and you need heavy knowledge, workarounds and architecture to do similar things you can easily do in languages where effects are "free"
03:59:16 <maerwald> to me it's the lack of easy, powerful and usable effects systems that is holding FP back
03:59:51 <maerwald> or leads to OCaml, F# and similar pseudo-functional languages with more or less free effects
03:59:52 <balajeerc> Had to lookup "cachet". :)
04:00:15 <JuanDaugherty> :)
04:01:01 <erisco> maerwald, well get implementing, because there is good research happening
04:01:31 <mbrock> Koka's effect system seems pretty sweet
04:03:17 <balajeerc> Having worked in an exclusively OO favouring, GoF design pattern toting environment for several years, everyone I have met and talked to about modeling your code in terms of pure functions and avoiding embedding state in deeply nested object hierarchies immediately see the benefits of it. I think that the ascent of Javascript, especially React-Redux is going to push a whole slew of programmers towards
04:03:19 <balajeerc> Haskell. I got here the same way.
04:03:50 <maerwald> F* does also an interesting thing, effects are not about "this or that effect", but about whether you can reason about the Totality of the function (simplified)
04:04:45 <mbrock> balajeerc: agreed. My mystical intuition sez that when the zeitgeist saw that React's VDOM approach was performant and intuitive, it began a strong turn towards purification
04:04:57 <erisco> balajeerc, well bring your friends… if enough people move maybe I will become employable
04:05:02 <balajeerc> mbrock: exactly.
04:06:17 <mbrock> maybe it's because there was a widespread perception that pure functions were academic and not really useful, but then they showed up as massively practical in the least academic field (JavaScript frontend coding)
04:07:07 <balajeerc> Yes. :)
04:07:59 <erisco> how do you program if you can't change variables?
04:08:15 <balajeerc> Of course, a massive chunk of that crowd is going to go to Clojurescript. But eventually people realize that they cannot do without a sane type system.
04:08:31 <mbrock> btw, for a while at my first job in a Java shop, we started to converge toward a style that wasn't purely functional, but kind of similar to it
04:09:16 <mbrock> using quite a lot of pure computations, but also e.g. using dependency injection with interfaces in a way that if you squint kind of looks like an "effect system"
04:10:03 <erisco> I have begun wondering if we naturally have an infatuation with complication
04:10:17 <mbrock> in OO we explained that as making unit testing easier, because you can inject your own time provider or randomness provider or file reader...
04:10:47 <mbrock> I'm kind of blathering abstractly but at least the benefits are similar to the "free monad" approach and stuff
04:10:58 <maerwald> reminds me: in one interview I said I hate OOP and will never do it, then I was asked about "dependency injection", lol
04:11:11 <asthasr> I used Clojure for a project and, honestly, I'd rather use Python.
04:11:56 <asthasr> I think that there's a place for the "hybrid" language, but ergonomics are very important... and I hope that there are hybrid languages with "pure" annotations and the like eventually
04:12:02 <erisco> when the brain is in high gear and solving problems it feels good, but maybe it shouldn't
04:12:22 <erisco> maybe instead we should be wondering why this needs to take so much thinking
04:12:39 <maerwald> heh
04:12:42 <mbrock> yeah, coders get dopamine kicks from being clever :)
04:13:03 <asthasr> erisco: Have you worked at a place with 1+ million lines of Java or C++?
04:13:04 <JuanDaugherty> because a collective is a broken unity of consciousness?
04:13:31 <erisco> asthasr, I have never worked with a code base that large in any language
04:14:01 <maerwald> sounds dreadful too
04:14:11 <asthasr> erisco: My experience with it is that "deferred thinking," i.e. doing it the "normal way," means that maintenance becomes next to impossible
04:14:29 <maerwald> thinking != overthinking 
04:14:35 <JuanDaugherty> rlY? 1 M LOC is no big deal
04:14:42 <asthasr> So, yeah, it's 'easier' up front because for feature X you just put in an if() statement in CalculateScores.java.
04:14:46 <erisco> the reality is that our minds are limited in how much they can think in a given time
04:14:55 <JuanDaugherty> any number of code sets are bigger than that
04:15:00 <JuanDaugherty> linux
04:15:05 <JuanDaugherty> any browser
04:15:08 <erisco> if it takes full capacity just to tread water then how will you move ahead?
04:15:10 <asthasr> but then later, you hit an exponential explosion where you can't predict what the methods you're calling are actually doing.
04:15:20 <maerwald> JuanDaugherty: yes and those are dreadful projects to contribute to
04:15:35 <maerwald> unless you only use a tiny portion of the API
04:15:37 <erisco> instead, when we reduce complications, which sometimes requires a painful period of learning, we free our minds to explore new things
04:15:41 <asthasr> JuanDaugherty: I didn't use it because it's ridiculous, it's very much a reality of traditional languages
04:15:54 <JuanDaugherty> oh , yeah, that doesn't concern me, just talking about wieldyness
04:16:17 <JuanDaugherty> oder
04:16:21 <asthasr> JuanDaugherty: also, a lot depends on how interconnected and well-architected it is... if it's just a blob, then it's pretty damn bad (speaking from experience).
04:16:29 <erisco> so when I am programming in a language without static types, I am concerned that I am wasting too much effort on rethinking what types could otherwise tell me
04:16:47 <tabaqui> which library do you use for IPC?
04:16:51 <erisco> if I just had static types as a tool to help me think, I'd be free to think about other things
04:17:07 <tabaqui> I have a main program that spawns new processes and have to talk with 'em
04:17:25 <tabaqui> sockets is a obvious solution, but maybe there is something better
04:17:26 <JuanDaugherty> asthasr, absolutely, and you have to be aware of what's what. For example with linux, the various conventions that enable movement
04:17:51 <mbrock> tabaqui: do you need to use communicating OS processes for some reason, or could you use Haskell green threads instead?
04:18:04 <tabaqui> mbrock: I need real processes
04:18:09 <asthasr> JuanDaugherty: Yeah. Well, for its (and his) flaws, Linux has a strong leader. That can stave off disaster for a while.
04:18:13 <JuanDaugherty> s/movement/development/ i.e. by an individual on the whole multi million LOC artefact
04:18:28 <erisco> I am experiencing in Coq recently that I often can have a very simple mind when proving theorems
04:18:47 <merijn> tabaqui: What's wrong with pipes?
04:18:52 <mbrock> tabaqui: are the subprocesses forks of the same Haskell program, or do you exec some other random code?
04:18:54 <erisco> because Coq is managing much of the proof for me, and remembering what is happening, and also has tactics to automate parts
04:19:17 <erisco> so I just have to look at the local state of the proof, pick out the few right things, and go to the next step
04:19:18 <merijn> tabaqui: process let's you trivially specify pipes to communicate with child processes
04:19:34 <erisco> which mentally is much less burdensome than trying to hold the whole reason for the proof in my head at once
04:19:45 <tabaqui> merijn, mbrock, now I'm using System.Posix.Process.forkProcess
04:19:55 <mbrock> erisco: sometimes I imagine retiring to a simple life for a few years until practical functional coding languages have advanced "proof search" tools :)
04:19:58 <tabaqui> but I didn't need the IPC
04:20:04 <maerwald> erisco: even easier when you are not proving anything
04:20:05 <merijn> tabaqui: Do you really want to fork or just to exec some other program?
04:20:28 <tabaqui> merijn: okay, okay, XY, right?
04:20:49 <merijn> tabaqui: If you're exec'ing stuff then you just want https://hackage.haskell.org/package/process-1.6.1.0/docs/System-Process.html
04:20:59 <tabaqui> I have to write some internet proxy with complicated logic
04:21:00 <mbrock> I really long for the day when my editor starts auto-suggesting type-correct expressions...
04:21:16 <erisco> maerwald, well we have to trouble ourselves with something else die of boredom :)
04:21:20 <tabaqui> with high load and hundreds clients
04:21:36 <tabaqui> for better security, I want to work with each client in dedicated process
04:22:31 <tabaqui> merijn: createProcess with stdin, stdout handles? hmm, maybe, maybe
04:23:01 <mbrock> there's supposed to be some libraries that can serialize Haskell values, including functions, efficiently in a way that is deserializable by forks of the same code, right? I don't know if they're operationally practical or just cool
04:23:30 <maerwald> erisco: the poison path maybe
04:23:47 <mbrock> probably better in most cases to be explicit about such IPC protocols, I suppose
04:24:24 <merijn> tabaqui: That's what I do now, just createProcess and pass in CreatePipe to allocate pipes
04:24:53 <merijn> tabaqui: Like here: https://github.com/merijn/ghc-modid/blob/master/Main.hs#L45-L60
04:25:46 <merijn> tabaqui: Avoids the hassle of binding ports, accepting clients, etc.
04:26:14 <merijn> mbrock: You're probably thinking of the StaticPointer stuff in recent GHCs
04:27:10 <tabaqui> merijn: it looks... simple
04:27:22 <tabaqui> I pocket this code :)
04:27:23 <tabaqui> thanks
04:27:56 <merijn> tabaqui: That's because it is :p Much easier than forkProcess generally :)
04:28:39 <tabaqui> not really, fork + exec is the most simple thing in the world, actually
04:29:04 <tabaqui> without ipc, of course :)
04:31:02 <merijn> tabaqui: createProcess is just a wrapper for fork + exec with stuff like pipes added for convenience
04:39:14 <Xion_> Unless the OS has no fork() :)
04:42:11 <arahael> Xion_: indeed
04:47:49 <maerwald> what does it do then?
04:49:37 <merijn> maerwald: Use whatever the OS does have
04:49:54 <merijn> Windows doesn't have fork, afaik
04:50:06 <maerwald> ah, so it's semi-defined abstraction?
04:50:32 <ggVGc> dealing with processes is such a pain in windows compared to *nix systems
04:50:32 <ggVGc> imo
04:50:47 <merijn> ggVGc: Until you try to properly daemonise/whatever
04:50:58 <merijn> *nix is just as much of a clusterfuck
04:51:02 <ggVGc> I usually end up falling back to python for quick stuff that I'd use bash for on linux
04:51:08 <ggVGc> because it has reasonable subprocessing
04:51:10 <merijn> But no one ever does things properly, so they don't notice
04:51:46 <maerwald> I guess createProcess is on my list of functions to never use then
04:51:57 <merijn> maerwald: Why?
04:52:09 <maerwald> because it's not properly defined
04:52:19 <merijn> How is it not properly defined?
04:52:29 <maerwald> because it abstracts over OS specific things
04:52:50 <maerwald> which probably have very different behavior, when you look at the details
04:53:34 <maerwald> so instead of hoping my code doesn't blow up or do something completely different than what I want on another OS, I prefer to not support that OS
04:53:59 <maerwald> cross-OS is difficult and abstraction is almost always the wrong way
04:54:49 <Athas> I think createProcess (at least in its common cases) only uses functionality that is exposed in all widely used operating systems.
04:55:09 <maerwald> and is that functionality 100% equivalent?
04:55:20 <Athas> The only really problematic thing to abstract is fork(), but I don't think you have that in Haskell anyway.
04:55:23 <maerwald> can you prove that? And do you know it will still be in 5 months?
04:55:43 <Athas> Equivalent how?  You're launching native programs.  They will be different on differing operating systems.
04:56:14 <cocreature> reading a file is probably not 100% equivalent on different OS, that doesn’t mean that you can’t make a reasonable abstraction that covers most usecases without reinventing the wheel in each program
04:56:35 <maerwald> equivalent in terms how native programs are launched and what properties the running program has that I might further rely on and so on
04:56:59 <Athas> createProcess does not seem to promise many properties.  Which ones do you care about?
04:57:07 <maerwald> cocreature: if you can come up with feature equivalence, then yes
04:57:09 <maerwald> otherwise, no
04:57:41 <ongy> you can get a lowest common featureset
04:57:57 <Athas> It looks like createProcess promises very little.  You get a few values back of specific types, and some unclear effect.
04:58:05 <ongy> which is shitty and afaik all that createProcess guarantees. "there's something running this now, unless there was an error" that's all you get
04:58:16 <erisco> maerwald, I think your 5-month criticism suggests an unfair balance of responsibilities
04:58:35 <erisco> maerwald, any OS can break whatever it wants in the next version, no matter how you have programmed
04:58:42 <merijn> POSIX doesn't promise equivalency either
04:58:46 <maerwald> erisco: no, I was talking about the abstraction
04:58:51 <merijn> So you can't interact at all with the OS, then
04:58:53 <erisco> maerwald, what is the difference?
04:59:04 <maerwald> it might change the way it interacts with OS xy
04:59:13 <Athas> The CreateProcess structure contains a bunch of fields that are defined to only work on some platforms.
04:59:19 <maerwald> resulting in slightly different behavior, most people won't notice
04:59:36 <cocreature> erisco’s point is that the OS itself can already change how it interprets your interaction
04:59:52 <cocreature> so even without an abstraction you’ve lost here
05:00:02 <maerwald> that's not reality
05:00:03 <erisco> it is the impetus of OS developers to ensure old programs still run on their new version
05:00:16 <erisco> this is because, otherwise, their users will be disadvantaged by upgrading
05:00:19 <maerwald> fork() doesn't randomly change semantics
05:00:45 <cocreature> maerwald: you haven’t presented an example where createProcess has changed behavior either, so I’m not sure you can claim that it’s reality that your code changes semantics in 5 months if you use it
05:00:51 <merijn> maerwald: Says who?
05:01:00 <Athas> maerwald: depends on how you assign blame.  fork() got a lot more involved when signals were added to Unix, and even more when threads entered the picture.
05:01:09 <Athas> Nowadays fork() is really easy to use incorrectly.
05:01:26 <merijn> Athas: s/fork() is really impossible to use correctly/
05:01:37 <merijn> posix_spawn is the correct syscall
05:01:41 <maerwald> cocreature: my point is that when you already have a hackish abstraction, chances are way higher that you change the underlying implementation compared to raw "OS calls"
05:01:47 <Athas> merijn: you just need to know everything about what your process is doing!
05:01:58 <kuznero> Hi All! What is the engine used behind Real World Haskell book online?
05:02:26 <Athas> merijn: that's not really a replacement if you want to do process-based concurrency.
05:02:30 <Athas> (With shared memory.)
05:02:37 <cocreature> maerwald: that’s correct in theory but if you’re playing the “this is not reality” card, I haven’t seen that becoming a problem in practise so I don’t think it’s the reality for createProcess
05:03:33 <asthasr> kuznero: it appears to just be static HTML?
05:03:52 <cocreature> if you need very strong assumptions about the behavior of createProcess than it’s the wrong thing to use but it doesn’t claim to satisfy these assumptions so I don’t think there is anything wrong with it
05:03:55 <kuznero> asthasr: but it allows to collect feedback for each paragraph
05:04:04 <cocreature> for most usecases it’s a perfectly fine abstraction
05:04:16 <royal_screwup21> what's a simple example of how "in" is used with "let"?
05:04:17 <asthasr> kuznero: my guess would be some simple JS
05:04:32 <cocreature> royal_screwup21: let x = 42 in x
05:04:47 <ertes-w> merijn: i disagree about properly daemonising…  i don't know when it started, but there is an anti-feature present in *lots* of software called "daemon mode", often even the default, which logs to syslog, closes standard FDs, writes PID files, forks, etc.
05:05:07 <royal_screwup21> cocreature: what's the difference between that and just let x= 42
05:05:08 <ertes-w> IMO this "feature" should disappear from all of them
05:05:11 <kuznero> JS, has to communicate to backend to store feedback. But I guess it was not interesting to make it an engine before...
05:05:12 <merijn> ertes-w: Ok, so what's the proper stop for daemonisation according to you?
05:05:18 <cocreature> royal_screwup21: let x=42 is a syntax error
05:05:27 <ertes-w> merijn: do nothing, keep logging to stderr
05:05:47 <ertes-w> i.e. just write a normal foreground program
05:05:48 <royal_screwup21> cocreature: Hmm, really? It seems to work fine on my ghci compiler
05:05:50 <merijn> ertes-w: do nothing doesn't work, because that means it gets killed when the session ends
05:05:57 <cocreature> royal_screwup21: that’s because ghci is weird
05:06:05 <asthasr> kuznero: I mean, here's the JS: http://book.realworldhaskell.org/support/hsbook.js
05:06:14 <asthasr> kuznero: the back end could be literally anything that can route a URL :)
05:06:15 <ertes-w> merijn: what's a session?  you *are* using a process supervisor for daemons, aren't you?
05:06:24 <cocreature> royal_screwup21: there is a special case for "let" in do blocks that doesn’t require "in" but apart from that you can’t use let without in
05:06:54 <royal_screwup21> cocreature: so basically let <variable> = <some value> in <variable> basically assigns a value to the variable?
05:07:31 <merijn> ertes-w: No, because I don't have access to one
05:07:47 <kuznero> asthasr: ok, I see. Thanks
05:07:51 <cocreature> royal_screwup21: "let <variable> = <some value> in <expression>" allows you to refer to use <variable> in <expression> and it will have the value <some value>
05:08:05 <royal_screwup21> thanks!
05:08:20 <cocreature> "let <variable> = <some value> in <variable>" is a silly special case that’s equivalent to <some value>
05:08:44 <cocreature> royal_screwup21: <variable> is only bound within the let expression, you can’t use it outside of it
05:09:48 <merijn> ertes-w: You're well meaning advice usually assumes some sort of deployment system/system access all of which is non-existent if you're stuck running in a constrained environment like a lot of my code :)
05:09:55 <merijn> s/You're/Your
05:11:00 <royal_screwup21> cocreature: so I typed out the same example on a file and tried to compile it and I got this error:  "Parse error: naked expression  Perhaps you intended to use TemplateHaskell"
05:11:35 <cocreature> royal_screwup21: you might want to read some intro-level Haskell tutorial
05:11:40 <merijn> royal_screwup21: Haskell doesn't allow expressions on the top level like python/ruby/JS do
05:12:05 <merijn> royal_screwup21: You're only allowed to have bindings at the top level
05:12:18 <royal_screwup21> ah okay
05:14:19 <woot_woot> What's a simple example of a haskell binding?
05:15:45 <merijn> woot_woot: eh...all the usual function/named value bindings? :)
05:17:12 <lyxia> x = x
05:17:42 <maerwald> lyxia: oh you
05:18:08 <ertes-w> merijn: well, even a shell functions as a poor man's supervisor ;)
05:18:48 <ventonegro> Can you use `let` at the top level?
05:19:17 <merijn> ertes-w: Yes, but I expect/need them to survive my single shell session :)
05:19:18 <ertes-w> merijn: but if you can run a shell, which i'm pretty sure you can, you can probably also run something like s6, because it's very cheap
05:19:36 <lyxia> ventonegro: only in ghci
05:19:50 <ventonegro> But that'
05:20:24 <ventonegro> But that's an extension... So in general I wouldn't say "Only bindings are allowed at the top level"
05:20:48 <ventonegro> "Only declarations" is more correct
05:21:09 <ertes-w> merijn: s6 has an extremely small footprint and might actually be cheaper than a home-grown, application-specific "daemon mode"…  it uses unix schemes for supervision, which does not involve stuff like PID files and doesn't require you to run a syslog daemon, etc.
05:22:07 <ongy> ertes-w: are you involved in the dev of s6?
05:22:22 <merijn> ventonegro: WhatDeclarations
05:22:33 <merijn> ventonegro: What's the difference between declarations and bindings?
05:22:40 <ertes-w> ongy: nope
05:23:29 <ventonegro> merijn: The `let` expression also creates bindings
05:23:43 <ertes-w> ongy: just a user…  i use it for my container
05:23:48 <ertes-w> … images
05:24:22 <merijn> ventonegro: Yes, let *expressions* create bindings, but since let is an expression it is not itself a binding and thus not allowed on the top-level
05:24:33 <ahf> vcake
05:25:22 <merijn> ventonegro: Any binding that goes on the top level is acceptable in a let expression to. (Although I guess I forgot to mention top level also allows imports, type declarations, etc.)
05:25:59 <ventonegro> merijn: declarations are not bindings themselves, but also creates them. "Binding" is not a syntactical thing, it's semantic
05:26:22 <merijn> ventonegro: I disagree :)
05:36:16 <ertes-w> well, they're really type *definitions*
05:36:27 <ertes-w> and definitions certainly bind
05:39:25 <saurabhn_> does anyone know of any blog/article talking about validation of nested records (or logically associated values in tuples) just before they're about to be inserted in the DB?
06:09:59 <Myrl-saki> Uptime: 10 days, 03:42:58
06:10:01 <lightstep> Can anyone help me with type families? I'm getting an error and can't figure out what I'm doing wrong. The relevant parts of the code are here http://lpaste.net/358476
06:10:12 <Myrl-saki>  4741M  6096 S  0.0 31.7 38:26.81 /home/myrl/.xmonad/xmonad-x86_64-linux
06:10:21 <Myrl-saki> Old issue, but always makes me life. :P
06:10:34 <Myrl-saki> (4.7 GB usage of xmonad)
06:12:28 <merijn> lightstep: You're defining a data family, not a type family :)
06:12:55 <lightstep> I don't know the difference... I want the one that comes with a type class
06:13:26 <maerwald> Myrl-saki: it leaks?
06:14:06 <merijn> lightstep: Presumably you mean "type RuntimeData view :: *"
06:14:20 <Myrl-saki> maerwald: Yeah, since 8.0 I think.
06:14:33 <maerwald> glad I use i3 :P
06:15:18 <lightstep> says I need AllowAmbiguousTypes, does this make sense?
06:16:20 <lightstep> the error is in the class definition, I added it as an annotation
06:20:35 <Psybur> What did they mean by this? "ghc.EXE: panic! (the 'impossible' happened)"
06:21:21 <merijn> Psybur: Means GHC crashed
06:21:33 <Psybur> Is that error rare?
06:21:56 <Psybur> Wondering if its just cheeky or I should legit report a bug like it says D:
06:22:03 <merijn> Psybur: Depends how much you try to abuse the typechecker
06:22:15 <merijn> Psybur: If no one has reported it, you should report it, yes
06:22:19 <Psybur> I havent been trying. Just using some lenses
06:22:22 <merijn> Psybur: It shouldn't crash
06:22:33 <maerwald> lenses crashing GHC, haha
06:22:42 <cocreature> if you don’t know what you did wrong, then it’s probably a bug :)
06:22:42 <maerwald> too much abstraction! :>
06:23:01 <merijn> Psybur: If you can make a minimal example that crashes and post it on the GHC trac that'd be useful
06:23:14 <Iceland_jack> Yes please file a bug report Psybur
06:23:24 <Iceland_jack> https://ghc.haskell.org/trac/ghc/newticket
06:23:37 <cocreature> trying a newer GHC release (if it exists) and an older one can also help narrow things down
06:23:42 <Psybur> https://pastebin.com/SKpVSa0p
06:24:12 <cocreature> looks like a bug to me
06:24:44 <erisco> hm, do we have a pragma to force inlining?
06:25:35 <Psybur> This looks like the code causing the problem. https://pastebin.com/5VDw1qWA
06:25:36 <erisco> actually I see a problem with that… could be nonterminating
06:25:42 <Psybur> Probably just using lenses wrong :D
06:26:13 <maerwald> that doesn't mean the compiler should crash
06:26:20 <lightstep> merijn, I think it's because the signature has just the associated type and not the original. IMO this means the feature is not mature yet, so I'm using a data family
06:32:55 <Psybur> Seems it was caused by not using the qualifier I defined during import for a certain data constructor
06:35:23 <merijn> Psybur: Still shouldn't crash, though :)
06:35:34 <Psybur> :D
06:40:11 <merijn> There isn't a library for parallel conduits, is there? i.e. I have have 1 section of my conduit running N times in parallel
06:57:10 <saurabhn_> two intero processes - one uses ~6GB the other ~4GB. Is this normal?
07:06:24 <cocreature> saurabhn_: ghci tends to be a memory hog so that doesn’t seem unreasonable
07:08:29 <Myrl-saki> Oh cool.
07:08:40 <Myrl-saki> `xmonad --restart` actually clears up the memory leak of xmonad.
07:09:04 <maerwald> run a cron job that does it every 30min
07:09:09 <erisco> so, does -O0 do some optimisations?
07:17:06 <lyxia> merijn: a pipes-concurrent for conduits?
07:18:16 <merijn> lyxia: Not quite. the goal of pipes-concurrency is to run different sections of the pipeline in parallel to each other
07:19:00 <maerwald> then someone mixed up concurrency and parallelism there :>
07:19:33 <merijn> lyxia: While I want, for example, something where I have one IO bound sink and I want to just run 5 sinks in parallel to chomp through my input faster
07:19:44 <lyxia> Oh I see.
07:21:03 <lyxia> I don't remember seeing anything like that either.
07:25:28 <erisco> how can I have GHC only inline local definitions during optimisation?
07:25:45 <erisco> I am trying to see if something inlines, but there is so much inlined from other modules I cannot tell
07:26:30 <osa1> erisco: you would see a reference to that identifier if it wasn't, right? if you can't find it then it's inlined
07:26:34 <tabaqui> is it good idea to use such type: ExceptT (IO ()) IO a?
07:26:55 <merijn> tabaqui: "It Depends (TM)"?
07:26:55 <tabaqui> I want to store some "finalize" action in Left side
07:27:07 <merijn> tabaqui: That sounds...suspicious
07:27:16 <tabaqui> that's why I'm asking
07:27:32 <merijn> tabaqui: Why aren't you using some kinda bracket approach if you need finalisation?
07:28:06 <erisco> osa1, that is a good point!
07:28:07 <tabaqui> f.e, I have a long sequence of actions with socket
07:28:23 <tabaqui> and if it fails on step1, then I should just close the socket
07:28:25 <erisco> I suppose what I want then is to see how well the code is optimised just locally
07:28:30 <tabaqui> step2 - close SSL connection
07:28:31 <merijn> tabaqui: Yeah, use bracket
07:28:35 <tabaqui> step3 - send error to socket
07:28:42 <merijn> :t Control.Exception.bracket
07:28:44 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
07:28:49 <erisco> I have now verified certain functions have inlined, but I cannot see how well their definitions have been simplified
07:29:03 <merijn> tabaqui: bracket is just try{}finally{} in Haskell
07:29:43 <erisco> maybe what I can do is mock the external functions and mark them as NOINLINE
07:30:24 <tabaqui> if I'll use bracket, then I can climb to the Heaven with the indentation stairs
07:30:51 <tabaqui> I really loved ExceptT beacause of error incapsulation
07:31:08 <merijn> tabaqui: ContT to the rescue! https://stackoverflow.com/questions/26436095/what-are-good-haskell-conventions-for-managing-deeply-nested-bracket-patterns
07:31:21 <tabaqui> maybe, each dangerous step could just return (Either Finalyze Result)
07:31:47 <cocreature> getting finalizers right is surprisingly tricky, so I would highly recommend to stick with bracket if you can
07:32:16 <cocreature> otherwise you’ll probably have some weird edge cases where your finalizers won’t be run
07:32:19 <merijn> tabaqui: Oh, see also: https://hackage.haskell.org/package/managed-1.0.0/docs/Control-Monad-Managed.html
07:32:41 <merijn> tabaqui: ContT/Managed let you use bracket, but write code like you're doing it the "regular way"
07:32:57 <tabaqui> oh, mtl
07:33:08 <tabaqui> I didn't read it yet :)
07:33:53 <erisco> now the problem is that GHC is too clever about the mock definitions and realises the value is never used… what now, hrm
07:34:09 <merijn> erisco: micro benchmarking is hard :)
07:34:29 <erisco> well I am just trying to look at the optimisations performed
07:34:42 <tabaqui> cocreature: these cases are related to haskell io or to pure logic?
07:34:58 <erisco> I added seq but it of course just keeps up to the weak head and throws out the rest
07:35:03 <erisco> maybe deepSeq…
07:35:46 <erisco> eh, doesn't have an NFData instance, poop
07:36:02 <cocreature> tabaqui: I’m not sure what finalizers are in “pure logic” but I’m talking about Haskell here. especially async exceptions mean that you need to be really careful when you’re not using one of the “builtin” ways to handle finalizers like bracket
07:37:14 <cocreature> tabaqui: if you’re interested in that, simon marlow’s book has the best coverage of that topic that I know of
07:37:21 <merijn> async exceptions are a bitch :)
07:37:22 <erisco> can I tell GHC to not optimise a particular definition?
07:38:47 <tabaqui> am I right that "async exceptions" means that you can go down through your evaluations, and instantly catch error from the code above?
07:39:24 <tabaqui> and if two lines of code raise exception, you cannot guarantee, that you'll catch the first one?
07:39:38 <cocreature> tabaqui: async exception means that any thread can throw exceptions to any other thread at any time
07:40:00 <cocreature> so assuming that you know what parts of your code throw exceptions and when is not possible.
07:40:43 <tabaqui> O_o, I cannot read the stack trace?
07:41:10 <erisco> I know… what if I make something which is not obviously nonterminating? then GHC shouldn't be able to optimise it any
07:42:56 <merijn> tabaqui: Are you familiar with posix signals?
07:42:59 <cocreature> tabaqui: the problem is that even when your code is not doing anything because it is between two steps, it can throw exceptions. so you easily end up with situations where your thread might die before the finalizer gets run
07:43:02 <erisco> it is real good at finding loops darnit… compiled program just spits out <<loop>>
07:43:04 <tabaqui> merijn: of course
07:43:32 <cocreature> tabaqui: just read http://chimera.labs.oreilly.com/books/1230000000929/ch09.html#sec_async-exceptions if you care about this :)
07:43:38 <merijn> tabaqui: async exception are similar to signals, basically. Thread A can throw an exception to thread B, similar to how you can send posix signals between processes
07:44:17 <merijn> tabaqui: But that means you might get an exception somewhere in code that normally wouldn't throw. For example, you're happily running "map (+1) [0..1000]" and suddenly, boom, exception in your face
07:46:15 <tabaqui> ok, what about IO? Can I jabber with web client, and crashed because some times before, he sent me invalid json?
07:46:30 <tabaqui> s/crashed/crash
07:46:37 <knupfer> erisco: just stumbled over this one http://www2.informatik.uni-freiburg.de/~thiemann/papers/modeling.pdf
07:46:54 <tabaqui> s/some times/*I dunno, how it is right
07:46:54 <merijn> tabaqui: It depends. IO has the same kinda exceptions you have in other languages like C++/java/python/etc.
07:48:13 <tabaqui> merijn: well, at least so
07:48:37 <erisco> knupfer, I am toying with representations right now and am trying to see if the optimiser hits it right
07:48:38 <dolio> erisco: It can only find loops that are like, "to evaluate the expression named `x` ... I have to evaluate the expression named `x`."
07:48:52 <dolio> So, if you consider that, it's not difficult to write things it can't detect.
07:49:07 <erisco> knupfer, my problem is that it pulls in so much from Builder that I can't tell what is going on, so I am trying to have it just optimise locally
07:49:25 <merijn> bleh...bracket using IO really limits my flexibility...
07:49:57 <merijn> The tricky question of "Do I add 'exceptions' as dependency or and try and make this work some other way"...
07:50:28 <erisco> dolio, well if you have an idea for me I'm all for it
07:50:39 <knupfer> erisco: most of the builder stuff is easily removable, it's there for perf
07:51:03 <maerwald> merijn: rust + error_chain, and you'll never miss haskell exception system again :P
07:51:19 <dolio> erisco: You want a non-terminating value that GHC won't turn into "<<loop>>"? `sum [1..] :: Integer`.
07:51:31 <erisco> dolio, but it has to depend on an x
07:51:39 <knupfer> erisco: i worked most time with a minimal example and staring at core...
07:51:40 <Cale> merijn: Which monad are you using?
07:51:45 <erisco> dolio, I am trying to mock a function f :: A -> B which it will not optimise
07:52:04 <erisco> dolio, the problem is that, even marked NOINLINE, it is smart enough to see the value is unused
07:52:22 <dolio> Which value?
07:52:23 <merijn> Cale: Right now the code works for any MonadIO, but I realised cleanup is tricky to get right
07:52:28 <erisco> dolio, the argument
07:52:50 <Cale> merijn: hmm
07:53:02 <dolio> erisco: Oh, so it floats out the constant body and only computes it once or something?
07:53:24 <merijn> Cale: I could add exceptions as a dependency and use MonadMask, but I was so proud of my tiny dependency footprint :p
07:53:33 <erisco> dolio, it does not compute it at all, because this mock function does nothing to the argument
07:53:41 <merijn> Cale: Because right now I only depend on base >.>
07:53:46 <erisco> dolio, I do not want to truly implement A -> B
07:54:04 <tabaqui> Allen's Mononoke's book has no mtl chapter
07:54:07 <tabaqui> that is sucks
07:54:14 <merijn> Cale: but afaik the only alternative to MonadMask is MonadBaseControl or whatever and that shit is even more confusing
07:54:29 <ventonegro> tabaqui: It's already quite big...
07:54:32 <shapr> tabaqui: what Haskell books have mtl chapters?
07:54:51 <merijn> Cale: Not to mention an even huger dependency footprint
07:54:52 <Cale> Most of the time, MonadBaseControl is worse than doing what it does by hand
07:55:01 <tabaqui> wait, are you guys Allen and Mononoke?
07:55:12 <shapr> not me
07:55:37 <ventonegro> tabaqui: I'm both when they meld their brains
07:55:53 <Cale> merijn: Typically, if I care about the polymorphism, I invent new type classes for the application-specific operations in the monads I want to discuss (which usually are more informative than what you'll get from mtl's classes)
07:55:58 <erisco> ventonegro, you tripped an interesting keyword of mine… just so you know
07:56:10 <Cale> merijn: and then implement instances of those classes for all the transformers that I care about
07:56:21 <tabaqui> ok, there is no too big digital book
07:56:29 <Cale> Or just for the specific monads in question.
07:56:32 <ventonegro> erisco: meld?
07:56:46 <merijn> Cale: This is a library, though, so I don't have an application specific operation
07:57:02 <Cale> Well, library-specific then :)
07:57:19 <merijn> ugh
07:57:20 <erisco> dolio, I am trying to think how to make an expression of type B given x :: A, but which is not obviously a loop, and is not the actual implementation
07:57:36 <Cale> I dunno, maybe it doesn't make sense in your context
07:57:42 <merijn> Cale: Well, but then I'd literally just be reinventing bracket :)
07:57:54 <erisco> dolio, options before me are loops and undefined … I do not see how to succeed with either right now
07:58:04 <erisco> unsafeCoerce perhaps…
07:58:06 <Cale> merijn: I would usually choose not just bracket, but whatever operation I was trying to perform using bracket
07:58:28 <merijn> Cale: The operation performed with the bracket is user specified
07:58:47 <merijn> Cale: I just have some IO I need to run before and after the user supplied operation
07:59:07 <erisco> woo-hoo! unsafeCoerce is the ticket!
07:59:09 <Cale> Well, okay, maybe just leave it as IO
07:59:10 <merijn> I just saw conduit doesn't have a MonadMask instance anyway, so that's out of the question
07:59:31 <Cale> I wouldn't generally try too hard to make stuff like that work in "any" MonadIO
07:59:58 <merijn> Cale: The entire thing becomes basically useless if I hard code it to IO
08:00:24 <merijn> Cale: Because then I'd still have to write the boilerplate I'm trying to eliminate here all the time
08:00:41 <Cale> The problem is, it's impossible to think through all of other people's monads and try to do something sensible with respect to state that you don't even know about
08:01:02 <Cale> That's sort of what MonadBaseControl tries to do, and that's why it's miserable to use and usually does the wrong thing
08:02:12 <merijn> Cale: My before and after actions are straight IO, though so they don't impact the underlying monad at all
08:02:32 <erisco> knupfer, it seems my idea is succeeding… I'll flesh it out some more and let you know where I get
08:03:13 <merijn> Cale: So there doesn't have to be anything sensible
08:04:58 <merijn> I just want "foo act = liftIO a >> act >> liftIO b" and ensure 'b' runs even if 'act' ends up being hit with an exception
08:08:37 <merijn> I suppose I could make people pass in a "bracket" of the appropriate type
08:08:49 <merijn> Although it becomes a bit ugly that way...
08:09:34 <knupfer> erisco: ok, cool!
08:11:23 <merijn> Cale: Do you see any reason why having people pass in a specific "bracket" operation wouldn't work?
08:14:26 <Cale> merijn: You could do that, I suppose.
08:17:05 <Cale> merijn: You could just have the "middle" continuation be an IO action, and then users of monads other than IO can just do whatever's required to run their monad.
08:18:48 <merijn> Cale: I'm basically trying to write something that plays well with both pipes/conduit (because I use both and don't want to tie it specifically to either of the two)
08:19:49 <merijn> Cale: So I want to pass in a "Consumer m r" (or the pipes equivalent) as "middle continuation" and then produce a Consumer as result so I can plug it into my pipeline
08:20:25 <merijn> Cale: So making the user run the "middle" continuation doesn't really work for that
08:20:42 <merijn> Because then I still don't have a pipe/conduit I can use
08:20:55 <merijn> But I'll fiddle more with this tomorrow.
08:21:14 <merijn> Welll...monday, actually, I guess
08:38:46 <infandum> I feel like I'm missing something with shake. If I have several rules, each with "need files", and x produces file1, y files2, and z files3, then if want for the main program points to the result z, it should first run x, not z.
08:39:16 <infandum> Does each individual rule get it's own "want"? In the documentation examples it doesn't have that.
08:43:29 <knupfer> infandum: a rule can `need` something
08:44:08 <knupfer> In your example, it should directly run z, and not x.
08:44:09 <infandum> knupfer: Exactly, so if it needs something, it first executes the rule for that need, right?
08:44:20 <knupfer> because you want the result of z which doesn't depend on other rules.
08:44:24 <infandum> but z "needs" the results from y
08:44:25 <knupfer> yep
08:44:42 <infandum> sorry, it's a pipeline, so it's x -> y -> z
08:44:49 <knupfer> and yep. It handles dependency resolution correctly
08:45:16 <cocreature> y should “need” files1, and z should “need” files2
08:45:44 <knupfer> note that a lot of `need` are implicit, like if you read a file etc.
08:45:49 <infandum> Hmm, that's what I have, but it starts at z
08:45:56 <infandum> and z has a need
08:46:12 <infandum> (which isn't anywhere in the folder already)
08:46:19 <knupfer> perhaps the need was satisfied one time, and afterwards the conditions didn't change?
08:46:36 <knupfer> infandum: where is your source
08:46:37 <knupfer> ?
08:46:44 <infandum> knupfer: Satisfied one time?
08:46:50 <infandum> knupfer: It's not public yet
08:47:14 <cocreature> infandum: shake won’t rerun a rule if its inputs haven’t changed
08:47:18 <knupfer> Well, if z needs y, and y doesn't change between multiple runs, it'll cache the result
08:47:41 <infandum> hmm, I'll see what happens if I start in a new folder
08:47:59 <knupfer> rm -r .*
08:48:01 <infandum> No, didn't work
08:48:16 <cocreature> infandum: how are you checking that it runs “z” first?
08:49:06 <knupfer> perhaps the name in "need" doesn't match precisely the rule of "y" ?
08:49:22 <infandum> It says "# cmd (for wantedFile)" basically
08:49:28 <infandum> as the first line
08:49:48 <infandum> and that wantedFile is from "want" as the first line of the program
08:49:51 <infandum> in main
08:50:22 <infandum> Does each rule need a want?
08:50:33 <infandum> I would assume not
08:51:13 <knupfer> "need" and "want" are aliases, if i remember correctly
08:51:20 <knupfer> but to answer your question: no
08:51:41 <infandum> knupfer: That's possible, as I'm using getDirectoryFiles "." ["*/outs/*.csv"]
08:51:44 <cocreature> they’re not, they have different types
08:51:49 <infandum> to get a list of them
08:51:51 <cocreature> but want calls "needs" internally
08:52:29 <knupfer> ah ok. some time ago i groked the code
08:53:09 <cocreature> infandum: can you at least share parts of your code or isolate the problem to a minimal example?
08:55:51 <infandum> But the need for the other rule is "*/outs/out.csv"
08:55:51 <infandum> sorry, that should be getDirectoryFiles "." ["*/outs/out.csv"] from before, the filename is exact
08:55:52 <infandum> I am calling them as functions if that's an issue. So in main it's want blah; phony blah; rule1 config; rule2 config; rule3 config, then in another file I have rule1 :: Config -> Rules () etc.
08:57:25 <cocreature> wait, you have a wildcard in your need? that’s not going to work
08:57:44 <cocreature> oh nvm I should have read your second message
08:57:46 <infandum> cocreature: It's called from getDirectoryFiles
08:58:33 <infandum> It's actually very annoying -- the commands I am using work on directories and produces many files, not just one at a time
08:58:51 <infandum> And shake wants predictable files
08:58:54 <infandum> file names
08:58:59 <infandum> not directories
08:59:03 <cocreature> needing the result from getDirectoryFiles sounds like a logic error. if getDirectoryFiles returns any files, they are already present so there is no need to build them
08:59:34 <infandum> cocreature: Then maybe I'm misinterpreting how to do this pipeline
09:01:22 <infandum> cocreature: Basically, cmd1 produces a directory with folder names from a file (which I take as input to help me out). cmd2 takes one of those subfolders to produce another folder in the root directory. cmd3 takes all of the files in the directories produced by cmd2 to finish with a final directory at the root.
09:02:00 <infandum> So there is no way to have need work on directories at all?
09:02:33 <cocreature> http://shakebuild.com/faq#how-can-i-depend-on-directories
09:03:41 <infandum> So I HAVE to know the exact name of the dependency, no wildcards?
09:04:20 <cocreature> think about it, how should a wildcard dependency work? if the file doesn’t already exist (which will be the case for a clean build), the wildcard won’t match anything
09:04:56 <cocreature> infandum: can you give us a bit more details on what those commands are or what kind of files they produce?
09:05:37 <cocreature> in particular, is there a one-to-one mapping between the files in each of those directories?
09:05:45 <infandum> cocreature: No
09:06:05 <infandum> cocreature: I did see this though: http://shakebuild.com/manual#dependencies-on-extra-information
09:06:44 <infandum> Okay, I'm going to see if I can make everything explicit and see if it works
09:07:35 <cocreature> if you really don’t have any specific files in those directories that you know will exist, you can make the cmds create dummy files that you "need"
09:07:58 <infandum> cocreature: Hey, that's a pretty good idea!
09:08:11 <infandum> So after each step it creates a checkpoint
09:10:46 <infandum> Like, after the first cmd it becomes predictable and you would need to re-run everything if you change that step anyway. Great! Thank you!
09:37:53 <dato112> !list
09:50:10 <linh> How do you understand all of the monads things?
09:50:13 <linh> I'm so confused
09:50:50 <Cale> By understanding examples
09:51:24 <Cale> There are many libraries which define instances of Monad, and by understanding each one, you get a sense for what these operations tend to mean in general.
09:51:52 <knupfer> At the beginning, I'd say it's not a concept that important. Just try to program and after a while you get an intuition.
09:52:43 <knupfer> linh: Or do you have a question more specific?
09:52:52 <linh> I just dont understand how monad like Reader, Writer are useful
09:53:00 <c_wraith> I agree with knupfer. understanding monads is just not important.
09:53:23 <Cale> Reader and Writer are often too simple to be useful on their own, but occasions do come up
09:53:27 <c_wraith> Reader isn't useful. :)
09:53:33 <knupfer> (at the beginning)
09:53:51 <c_wraith> ReaderT can be useful, but Reader basically never is.
09:55:02 <knupfer> linh: Monads begin to make sense when you know the difference between a Coconut and a Nut
09:55:07 <Cale> linh: A better example is something like a parsing library
09:55:36 <Cale> where you'll get some type like  Parser t  for parsers which consume some portion of the input in order to try to produce a result of type t
09:56:02 <Cale> and then return v will be the parser that consumes none of the input, but produces v successfully
09:56:24 <c_wraith> Writer (or ((,) a), the "anonymous" version, more often) is sometimes useful when you have a polymorphic function and just want to smuggle an extra value out. 
09:56:32 <Cale> and x >>= f will be the parser which consumes the beginning of the input with x, obtaining some result, say v, and then consumes the remainder of the input with f v
09:56:57 <ski> (`return v' is useful as a base case, e.g. .. or in a branch, generally)
09:57:24 <Cale> Then you'll have things like sequence :: [Parser a] -> Parser [a]  for the concatenation of parsers
09:57:24 <knupfer> linh: Do you know what an Applicative is?
09:57:34 <linh> yeah
09:57:52 <linh> I mean I know the basics of monads
09:58:14 <linh> but then there are something higher like State , Reader and Writer then i'm really confused
09:58:40 <Cale> Those three in particular usually aren't useful on their own, but might be building blocks for constructing the library you actually want
09:59:22 <ggVGc> linh: it's not that useful to "know the basics of monads". What's more useful is learning how to use each specific thing that is a monad
09:59:39 <ggVGc> you'll start benefitting from the fact that they are monads eventially
09:59:43 <ggVGc> but that's not the main point
09:59:53 <ggVGc> at least in my experience
10:01:44 <knupfer> linh: Think of monads as some sort of api for libraries and use them. You'll build up intuition. What they 'are' is actually quite simple if you look at the types of its methods.
10:02:01 <orion> What libraries would you all recommend for thread pooling? I want to create and maintain "n" workers pulling from a queue. If one worker dies I want it to be logged and restarted.
10:07:12 <linh> \help
10:21:18 <__monty__> Having some difficulty using data.map The main page of the documentation has only deprecated functions and they link to functions in data.map.internal it seems I've used some of those functions that aren't exported by data.map How do I use the module properly?
10:21:46 <Psybur> There a way to cross compile to linux from windows?
10:23:11 <cocreature> __monty__: Data.Map reexports Data.Map.Lazy which contains the interesting functions
10:27:18 <__monty__> cocreature: The functions I need are in Data.Map.Merge.Lazy how do I verify that's not reexported by Data.Map and is the proper solution to just import this module? (I know it's not reexported since the compiler says so but how do I check this in the documentation?)
10:28:32 <cocreature> __monty__: I don’t know of a better way than recursively following the links to reexported modules in the haddocks
10:31:20 <lyxia> __monty__: on the package's main page, below the links to modules there is a link to the [Index] where you can see where each identifier comes from.
10:34:26 <__monty__> What might cause a failure to load the interface for a module if the package is already installed?
10:39:22 <Welkin> __monty__: it's not declared in your .cabal file
10:39:32 <Welkin> the package name*
10:42:39 <__monty__> Welkin: Containers is declared in my .cabal
10:43:25 <glguy> __monty__: If you have a question about a specific error message it'll be easier if you paste the error message and then any imports or file contents that seem relevant
10:43:33 <glguy> than to ask generically about errors
10:46:02 <tomasino> I'm struggling with the difference of when to use (.) vs ($). I understand that $ has lower order precidence than pretty much everything. Is that the only difference? Is there something I'm missing?
10:47:31 <lyxia> tomasino: ($) applies a function to its argument. (.) composes two functions to make a new function.
10:48:06 <Welkin> tomasino: they are not actually alternatives; they are completely different
10:48:23 <Welkin> `$` is oftne used to reduce parentheses
10:48:28 <tomasino> I guess I was reading it like the (.) was applying a function to the result of another one
10:48:38 <tomasino> but composition is more than that
10:49:21 <__monty__> Error: http://ix.io/zXq Cabalfile: http://ix.io/zXm Head of .hs: http://ix.io/zXp
10:49:32 <Welkin> (.) f g x = f (g x)
10:49:45 <Welkin> = f $ g x
10:50:36 <tomasino> I must be missing something then because it still seems like with that logic: f . g x  would be the same as f $ g x
10:50:56 <Welkin> (f . g) x = f .g $ x
10:50:58 <Welkin> (f . g) x = f . g $ x
10:51:20 <__monty__> f . g x = f . (g x)
10:51:20 <Welkin> actually, above, when I wrote `f $ g x`, that is wrong and will be a type error
10:51:28 <tomasino> oooh, okay
10:51:54 <glguy> (f $ g x) === f (g x)     --while--   (f . g x) === (\y -> f ((g x) y))
10:52:18 <tomasino> glguy: I think that finally gets in into the grey matter. Thank you
10:52:36 <tomasino> I'm going to go ahead and read that 10,000 times more
10:53:54 <bjs> tomasino: it's easier to put brackets around to understand
10:54:13 <byorgey> Welkin: eh?  f $ g x  is not wrong
10:54:26 <bjs> Things like (f . g x) are visually ambiguous
10:55:19 <tabaqui> err
10:55:26 <tabaqui> (.) f g x /= f (g x)
10:55:35 <Psybur> > (f . g x)
10:55:35 <tabaqui> right: (.) f g x = (f . g) x
10:55:37 <lambdabot>  error:
10:55:37 <lambdabot>      • Could not deduce (Show b0) arising from a use of ‘f’
10:55:37 <lambdabot>        from the context: (FromExpr c, Show a)
10:56:24 <Psybur> > f x
10:56:26 <lambdabot>  error:
10:56:26 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M172069796709...
10:56:26 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
10:56:44 <Psybur> Hmm I thought we could show functions, must have missed something
10:56:50 <ski> > f x :: Expr
10:56:53 <lambdabot>  f x
10:56:57 <Psybur> ah
10:57:03 <Psybur> > (f . g x) :: Expr
10:57:05 <lambdabot>  error:
10:57:05 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘() -> c0’
10:57:05 <lambdabot>      • Probable cause: ‘(.)’ is applied to too few arguments
10:57:16 <ski> > (f . g x) :: Expr -> Expr
10:57:19 <lambdabot>  error:
10:57:19 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘f’
10:57:19 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
10:57:30 <ski> > not  -- showing functions
10:57:32 <lambdabot>  <Bool -> Bool>
10:57:44 <tabaqui> usually that is said to me, but
10:57:50 <tabaqui> you can /query lambdabot
10:58:10 <tomasino> one last question on the subject. I'm saying "f before g" based on the category theory videos I've been watching when referring to (f . g). How do you "say" (f $ g)?
10:58:38 <ski> "apply `f' to `g'" ?
10:58:46 <tomasino> thanks
10:58:48 <cocreature> “f applied to g”
10:58:51 <tabaqui> f deistvuet na g, I would say
11:00:28 <tabaqui> we have discussed earlier about "monoid over addition" and "monoid under addition"
11:00:48 <bjs> tomasino: f applied to g?
11:01:23 <bjs> tomasino: it's funny because I've always heard "f after g" for that notation
11:02:40 <tomasino> bjs: i don't really know for sure. "Before" was what Bartosz Milewski used in the videos about Category Theory. Maybe it's different in Haskell world, maybe not?
11:03:03 <tomasino> bjs: regarding (.) i mean
11:03:13 <dmwit> > (f :: Expr -> Expr) . g (x :: Expr)
11:03:15 <lambdabot>  <() -> Expr>
11:04:01 <dmwit> > ((f :: Expr -> Expr) . (g :: Expr -> Expr)) x
11:04:04 <lambdabot>  f (g x)
11:04:54 <bjs> tomasino: it's kind of hard to tell between all the lambdabot messages whether you got your answer or not :)
11:05:42 <tomasino> bjs I did. (f . g) = f before g.   (f $ g) = f applied to g.
11:13:11 <infandum> cocreature: In case you were wondering, that was the issue, the getDirectory wildcard stuff in shake.
11:13:11 <infandum>  
11:13:14 <infandum> It works now.
11:20:54 <cocreature> infandum: nice!
11:25:35 <saurabhnanda> intero: 7 GB+ ... why is this taking up so much memory?!
11:26:41 <d6e_> saurabhnanda: what is?
11:26:56 <saurabhnanda> d6e_: intero
11:27:06 <jared-w> saurabhnanda: it depends on a lot of things. How many modules do you have in your project, how many files do you have open, etc
11:27:28 <saurabhnanda> jared-w: 1,000+ modules and files. Mostly small.
11:27:37 <jared-w> The general LOC amount for the project can also affect that. The more you load into GHCi the more memory intero sucks up
11:27:58 <saurabhnanda> But 7 gigs! and it keeps growing with time. In the afternoon it was 5 gigs. Is there a space leak in intero?
11:28:15 <jared-w> saurabhnanda: In that case you're trying to load up 1,000+ modules and files into Intero simultaneously so it'll take quite a bit of ram in general :p
11:28:50 <jared-w> saurabhnanda: I'm not sure if it's a space leak or just a consequence of tracking changes and re-running checkers. Most of intero is really just GHCi wrapped around stack compatibility
11:29:26 <saurabhnanda> but why?! we have a similar sized project in Rails (in fact, accessing the same underlying DB schame), and irb (or rails console) doesn't take up anywhere close to this much RAM!
11:29:48 <glguy> Oh, maybe open the project in irb then
11:30:59 <saurabhnanda> what is going on internally for it to continuously keep increasing the RAM usage. Two problems: (a) too much RAM, and (b) RAM usage keeps growigng!
11:34:59 <mnoonan> i wonder if some intero action ends up binding a unqiue name in ghci or something.. then the gc would never let go of it
11:35:05 <mnoonan> can you get a heap profile on intero?
11:35:32 <saurabhnanda> mnoonan: how do I do that?
11:36:12 <mnoonan> ¯\_(ツ)_/¯
11:36:27 <mnoonan> maybe like this.. i've never tried: https://stackoverflow.com/questions/44698036/using-rts-profiling-within-interos-ghci
11:36:57 <mnoonan> actually, that probably isn't profiling intero itself
11:38:25 <saurabhnanda> has anyone tried keeping a GhCi open and constantly loading/reloading stuff in it?
11:38:25 <saurabhnanda> does the memory usage of GHCi also keep growing?
11:39:59 <mnoonan> actually, did you see this issue report? https://github.com/commercialhaskell/intero/issues/84
11:40:40 <mnoonan> and a possibly-related ghci report: https://ghc.haskell.org/trac/ghc/ticket/12848
11:41:38 <chakri> HELP
11:42:16 <saurabhnanda> checking
11:42:17 <chakri> are there any good exercises to understand types and typeclasses?
11:43:04 <monochrom> Most textbooks have some.
11:43:38 <saurabhnanda> mnoonan: thasnks for the links. Exactly what I'm facing!
11:44:02 <mnoonan> saurabhnanda: at least you aren't alone :)  good luck!
11:47:15 <saurabhnanda> restarted intero and it came down to 800MB (from 7 GB)
11:50:57 <jared-w> Sounds like a weird sort of leak then...
12:12:03 <chakri> ?
12:12:23 <geekosaur> ??
12:14:12 <ski> ???
12:14:13 <chakri> are there any good exercises to understand types and typeclasses?
12:14:33 <ski> <monochrom> Most textbooks have some.
12:15:43 <Welkin> @where typeclassopedia
12:15:44 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
12:15:49 <Welkin> chakri: use that
12:16:46 <ski> chakri : do you understand basics, like type signatures, lists, `Maybe', `Either', trees ?
12:17:16 <chakri> yes, I understand basics
12:17:21 <ski> ok, good
12:17:38 <ski> (that wasn't clear to me, from what you said)
12:17:58 <monochrom> Then again, don't trust it when people say they understand.
12:18:27 <mnoonan> "trust, but verify"
12:18:40 <Psybur> "trust, but don't trust"
12:18:47 <monochrom> Yeah, but Occam's Razor cuts it down to "just verify".
12:19:04 <ski> yea, but they thinking they understand has at least somewhat higher chance of being able to tackle that, than they knowing they don't understand
12:19:17 <mnoonan> "don't really trust, but act like a decent human being and put on a facade of trustiness"
12:19:33 <Welkin> admitting that you don't understand is the first step to recovery
12:19:52 <Psybur> "the grey matter in my head makes me do things!"
12:20:07 <nshepperd> thinking that you understand, but being wrong, is the most common form of non-understanding
12:20:11 <Welkin> what is they believe that they overstand?
12:20:14 <Welkin> if*
12:20:43 <ski> nshepperd : it's a step on the way ..
12:20:57 <Welkin> the more you know, the less you realize you know
12:21:08 <monochrom> I disagree that it is decent.
12:21:20 <Welkin> if you think you know everything, you know nothing. If you think you know nothing, you probably know a lot
12:21:20 <trevortknguyen[m> Does anyone know how to compare using frp-arduino to using Copilot from Galois for programming Arduinos?
12:21:42 <Welkin> the more you know, the less you realize you don't know*
12:22:03 <Welkin> the more you know, the more you realize you don't know*
12:22:03 <Welkin> o.o
12:22:05 <Welkin> that one
12:23:07 <monochrom> But I can agree that when trust vs distrust concerning a certain aspect doesn't matter, it is not a good idea to show distrust and make it larger than it is.
12:23:24 <mnoonan> that's a better way to say it :)
12:25:26 <monochrom> If you think you know everything, you can get a Bachelor's degree. When you realize you know nothing, you can get a Master's degree.
12:25:31 <ski> sometimes, you have to let people stumble a bit on their own, to realize that they need help
12:25:45 <monochrom> And when you finally realize that your thesis supervisor knows nothing either, you can get a PhD.
12:25:46 <ski> (not clear whether that's the case here. just saying that it could be)
12:26:04 <chakri> I am not sure when they add parenthesis around types how to read and interpret them, simple example filter :: (a -> Bool) -> [a] -> [a]
12:26:23 <ski> ok. you don't know basics :)
12:26:31 <chakri> I know the first argument must be a predicate
12:26:38 <chakri> but how do you read it?
12:27:05 <ski> `filter :: (a -> Bool) -> [a] -> [a]' says that `filter' takes two arguments, one of type `a -> Bool', and one of type `[a]', and returns a result of type `[a]'
12:27:24 <zachk> (a -> Bool) -> ([a] -> [a]) 
12:27:31 <zachk> is how you can read it
12:27:39 <ski> if it had been `filter :: a -> Bool -> [a] -> [a]', then it would have been declared to take three arguments, one `a', one `Bool', one `[a]', returning an `[a]'
12:27:58 <monochrom> Do you mind I add more parentheses? Because it's also (a -> Bool) -> ([a] -> [a]). Then some background rule about "-> associates to the right" implies that I can omit the second pair and the computer still understands it.
12:28:09 <chakri> filter (\x -> x > 0) [1,2,3,-1,0]
12:28:33 <chakri> I can write them but do can not read properly
12:28:41 <ski> with the actual `filter :: (a -> Bool) -> [a] -> [a]', it is saying that the first argumnt of `filter' is actually itself expected to be a function (a callback function). that callback is expected to accept `a's, and return `Bool's
12:28:43 <nshepperd> > filter (\x -> x > 0) [1,2,3,-1,0]
12:28:46 <lambdabot>  [1,2,3]
12:28:52 <chakri> <ski> thank you
12:29:18 <ski> chakri : please do not address me like that. it looks like you're quoting something i said
12:29:31 <ski> (and you're welcome)
12:30:35 <Welkin> chakri: all type signatures have invisible right-associative parentheses
12:31:05 <Welkin> `(a -> Bool) -> [a] -> [a]` is the same as `(a -> Bool) -> ([a] -> ([a]))`
12:31:27 <Welkin> `a -> Bool -> [a] -> [a]` is the same as `a -> (Bool -> ([a] -> ([a])))`
12:31:58 <Welkin> this is a result of all functions being curried
12:32:16 * ski sighs
12:32:33 <pikajude> how do I cabal haddock --ghcjs?
12:32:59 <digitalkiwi> monochrom ooh what can I get when I know all of those things but am not at school?
12:33:30 <Welkin> digitalkiwi: a life without debt
12:33:51 <JuanDaugherty> there is an entry level channel isn't there?
12:33:56 <monochrom> Um, I thought the point is to know nothing, not to know all those things. :D
12:33:56 <digitalkiwi> heh 
12:34:25 <ski> JuanDaugherty : this one ?
12:34:25 <monochrom> But anyway you could apply for getting into a school. It is never too late.
12:34:33 <digitalkiwi> well maybe experienced is the proper word...I've gone through those stages!
12:34:35 <Welkin> JuanDaugherty: haskell-beginners? that is bitemyapp's channel for his book I thought, or is mostly used for that and the cis course
12:35:13 <digitalkiwi> this is one size fits all channel
12:35:25 <jared-w> Nah this is just for haskell beginners but since the best resources tend to be haskell from first principles and the CIS course... :p
12:35:26 <monochrom> Alternatively, become a very famous and successful person, so that the university comes to you and say they want to give you an honory PhD!
12:35:28 <digitalkiwi> I don't even know haskell I just pretend like I might learn it someday :(
12:35:46 <dolio> monochrom: Yeah, that's the best strategy.
12:36:02 <JuanDaugherty> -beginners igess, does have 300 right now
12:36:03 <Welkin> you get an honorary doctorate just by speaking at a university
12:36:09 <MarcelineVQ> Welkin: it's for anyone who wants help from less than 4 people at once time :>
12:36:18 <ski> JuanDaugherty, both
12:36:29 * ski grins at MarcelineVQ
12:36:51 <monochrom> Afterall, that's how Steve Jobs did it, right? "Stay hungry. And throw your engineers' prototypes back at them because you realize they know nothing." >:D
12:37:07 <Welkin> they are all jon snow?
12:37:11 <digitalkiwi> I'm never helpful so if you're counting number of people talking as helping don't include me :|
12:37:28 <dolio> I don't know if emulating Steve Jobs is ideal.
12:37:39 <digitalkiwi> because he's dead
12:37:41 <Welkin> he was an asshole
12:37:50 <JuanDaugherty> well holding him up is revealing
12:37:59 <jared-w> He was an incredibly driven asshole who could motivate people to do more than was healthy for them
12:38:04 <Welkin> unfortunately, a lot of his behavior is idolized across silicon valley
12:38:09 <JuanDaugherty> as if he actually did stuff
12:38:09 <Welkin> so you see a lot of assholes
12:38:14 <jared-w> There's a reason people draw parallels between Apple and cults :p
12:38:34 <Welkin> being an asshole was not a requirement for his success
12:38:47 <Welkin> I believe he was successful in spite of it, not because of it
12:38:57 <dolio> This is rapidly getting further from the topic.
12:39:16 <shapr> what was the topic? I got lost
12:39:16 <chakri> ski: Is there a link that talks this language?
12:39:23 <dolio> shapr: Unicycling.
12:39:25 <jared-w> Then again we have the Steve Jobs v2.0 (ie Musk) and he seems to be similarly an asshole in the same way Jobs is. Perhaps it's not necessairly "required" but I think it's heavily correlated at least
12:39:32 <shapr> dolio: oh good!
12:39:46 <monochrom> Types.
12:40:09 <Welkin> we were discussing dependency injections for factory managers
12:40:10 <shapr> it's good to be kind when talking about types
12:40:18 <shapr> :k shapr
12:40:21 <lambdabot> error: Not in scope: type variable ‘shapr’
12:40:29 <shapr> I guess that makes me valuable.
12:40:48 <digitalkiwi> [14:40:07] Topic is https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | https://summer.haskell.org Summer of Haskell 2017
12:40:53 <digitalkiwi> topic ^^
12:41:02 <monochrom> chakri: It will help to recall some of your algebra skills. At first you can have an expression like "x - y". Then you say "ah but x could be a-b, y could be s-t, so you can have (a-b) - (s-t)", and you already know how to read it.
12:41:08 <Welkin> I don't believe I have seen the topic in years
12:41:21 <Welkin> the user list is so large it pushes it off the screen immediately
12:41:31 <digitalkiwi> /topic
12:41:38 <Welkin> who does that though
12:41:44 * digitalkiwi
12:41:52 <monochrom> The same can be said about "I can have X->Y, ah but X could be a->Bool, Y could be [a]->[a], so I can have (a -> Bool) -> [a] -> [a]". That's how I read it, at the very least.
12:41:57 <byorgey> Welkin: some clients display the topic at the top or bottom of the window.
12:42:44 <monochrom> Haha shapr.
12:42:51 <digitalkiwi> I just now noticed I can click the topic and copy it :o
12:42:59 <chakri> monochrom: Thank you
12:43:21 <digitalkiwi> when I tried to select the text and copy it the first time I accidentally the whole scrollback and client crashed...
12:47:16 <shapr> digitalkiwi: so I should only talk about Haskell here?
12:47:22 <shapr> dolio: sounds like unicycling is right out
12:47:34 <digitalkiwi> shapr I dunno you're the one with a hat you make the rules
12:47:43 <shapr> ooh, I have A HAT?
12:47:49 --- mode: shapr set -o shapr
12:47:49 <digitalkiwi> yup!
12:47:51 <shapr> oh, so I did
12:47:53 <shapr> look at that
12:48:08 <digitalkiwi> now you can talk about anything
12:48:12 <digitalkiwi> because no ops are on
12:48:14 <shapr> whew
12:48:21 <shapr> I'm safe!
12:48:24 <ski> shapr : well, we tend to allow talk about related topics as well .. but perhaps not as much, when people are talking about Haskell
12:48:24 <monochrom> Oh that reminds me. There was a ban I placed and it's time to expire it.
12:48:24 <shapr> no unsafeCoerce for me!
12:48:30 --- mode: ChanServ set +o monochrom
12:48:32 <shapr> ski: I agree
12:48:38 <shapr> uh oh, only Haskell now
12:48:43 <shapr> digitalkiwi: when did you start learning Haskell?
12:48:43 <ski> shapr : other than that, the basic channel rule is "be nice, or else !"
12:48:50 <shapr> right!
12:48:57 --- mode: monochrom set -b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.197.233.134.50
12:49:03 <shapr> I remember that rule! I think I made that rule.
12:49:07 --- mode: monochrom set -o monochrom
12:49:10 <ski> (i forgot who exactly coined that phrase)
12:49:18 <byorgey> ski: it was shapr =)
12:49:19 <ski> hm, that may in fact be so !
12:49:50 <digitalkiwi> I like you guys because you're nice and don't always threaten to ban me 
12:50:26 <digitalkiwi> shapr umm I probably started attempting to learn 5+ years ago
12:50:32 <digitalkiwi> it's not going so well :|
12:50:44 <shapr> digitalkiwi: how are you learning? book?
12:51:24 <digitalkiwi> currently I'm not, but I have tried the one with drawings
12:51:53 <shapr> learning is hard, it takes time
12:51:54 <digitalkiwi> and some other things and osmosis and that thing dibblego had on github 
12:51:59 <shapr> digitalkiwi: I'm a fan of haskellbook.com
12:52:10 <shapr> some people prefer Graham Hutton's "Programming in Haskell" more
12:52:35 <Welkin> I recently bought the hutton book and have only taken a brief look at it, but it looks good
12:52:41 <Welkin> (2nd edition)
12:52:42 <monochrom> I think I should buy Hutton's book and read it some day.
12:52:51 <shapr> yeah, I have both 1st and 2nd edition, but I've only read 1st
12:52:51 <digitalkiwi> 59 dollars is more money than I have
12:53:02 <Welkin> it is a good length too, at about 250 pages
12:53:41 <Welkin> I took a look at the sample chapters for haskellbook.com, and looked at the TOC and length, and wasn't sure if it's the right approach
12:53:50 <Welkin> 1200 pages for the basics?
12:53:51 <digitalkiwi> learn you a haskell that was the name of one I was reading
12:54:02 <Welkin> I started with LYAH, and that is great fun, but not too useful
12:54:07 <Welkin> it's a great marketing trick though
12:54:45 <Psybur> > foldl (f) o [k,i,e,d,o,k,e]
12:54:47 <lambdabot>  f (f (f (f (f (f (f o k) i) e) d) o) k) e
12:55:06 <monochrom> There are even more basic books like 1st-year economics textbooks that are even more than 1200 pages.
12:55:15 <Welkin> monochrom: and those are the worst
12:55:22 <Welkin> like the 1000+ page calculus textbooks
12:55:28 <digitalkiwi> I'm sure I've read other things too the majority of the problem is I can't ever decide on anything useful to write that I'm interested in which means I don't have a lot of incentive to spend time and it goes in one ear and out the other, so to speak...write :/
12:55:48 <Psybur> Wonder if anyone gets my joke haha
12:55:54 <Welkin> Psybur: smokey
12:56:16 <monochrom> It is a joke?!
12:56:24 <digitalkiwi> I have a C++ book that is like 1500 pages
12:56:48 <Psybur> https://www.youtube.com/watch?v=1LHBxsDYavo
12:56:55 <monochrom> OK I can see "okie doke" there but I don't understand the preceding f's.
12:56:57 <xormor> hello. how do I use the commandline arguments as variables to do a calculation? I need to do like this: "programexecname 9 3" so a=9 and b=3. It would be basically "program a b", print $ a + b, print $ a - b, print $ a * b, print $ a / b
12:57:03 <Psybur> if if if if if
12:57:35 <monochrom> OK!
12:57:36 <geekosaur> @index getArgs
12:57:36 <lambdabot> System.Environment, System.Posix.Env.ByteString, System.Posix.ByteString
12:57:41 <Psybur> D;
12:57:47 <geekosaur> :t System.Environment.getArgs
12:57:49 <lambdabot> IO [String]
12:58:14 <geekosaur> note that there are more involved but more capable ways to do this as well (e.g. the optparse-applicative library)
12:58:16 <shapr> digitalkiwi: write useful tools that help your daily work?
12:58:17 <xormor> geekosaur, do you have a working example code?
12:58:20 <monochrom> Well I guess I am outside the US therefore I didn't pay attention to every presidential speech.
12:58:29 <digitalkiwi> I keep it by my door in case of home invasion as it is quite heavy
12:58:36 <digitalkiwi> shapr I have no job
12:59:31 <xormor> geekosaur, how would I write the code if I needed number variable arguments?
12:59:31 <digitalkiwi> I could write a bot that annoys irc even while I'm afk but that would probably get me banned sooner
13:00:04 <geekosaur> xormor, pattern matching? getsArgs just gives you the equivalent of C's argv
13:00:39 <geekosaur> again, you might want to look at optparse-applicative for something a bit more getopts-like
13:01:11 <xormor> geekosaur, can you give an example paste code? I would like to have the variables as numbers. I do not care if the arguments are strings as long as I can convert them into integers or floats.
13:01:38 <shapr> digitalkiwi: you could write something that stays on irc and listens, so you could read it when you get back to your computer
13:01:48 <digitalkiwi> I have znc
13:01:58 <shapr> rewrite it in your language of choice?
13:02:03 <monochrom> There is Text.Read.readMaybe for converting one String to one number.
13:02:14 <Psybur> shapr, the channel is logged already why not just read the logs :D?
13:02:21 <digitalkiwi> well reading all of the scrollback takes long enough as it is ;_
13:02:22 <digitalkiwi> )
13:02:25 <shapr> it's good to have an excuse to write code!
13:02:36 <shapr> when you start writing code that does something, you get better at coding
13:02:44 <monochrom> So now you are only left with bridging to gap of how to start with ["45", "90"] and take out the "45" and the "90" and process them separately.
13:02:46 * ski recalls reading all the scrollback .. in the old days
13:02:48 <shapr> when you're better at coding, you can see more useful things to code!
13:03:03 <Psybur> digitalkiwi, write an autotrader that checks when certain currency pairs breaks correlation and then trades the pair that didnt break the support or resistance when the other pair did :D?
13:03:44 <Welkin> when did programming become "coding"?
13:03:45 <digitalkiwi> I wrote a python bitcoin arbitration bot once lol
13:04:02 <Welkin> the only people I hear using that temr are non-programmers
13:04:17 <Psybur> Welkin, coding is the least interesting part of programming :D
13:04:35 <shapr> Welkin: I teach coding to lots of non-programmers
13:04:37 <monochrom> I say "code it up" to my students all the time.
13:04:41 <digitalkiwi> real programmers are developers
13:04:43 <Psybur> Its fun to come up with a solution. Its a chore to code it haha
13:04:50 <monochrom> Well I guess that makes me a teacher not a programmer.
13:05:00 <digitalkiwi> those who can't, teach
13:05:13 <ski> how about those who can't teach, then ?
13:05:21 <digitalkiwi> status quo 
13:05:22 <Psybur> digitalkiwi, now write that bot in haskell. :D
13:05:26 <shapr> I love teaching programming, but I'd have to take a pay cut to do it full time
13:05:49 <Welkin> haha
13:05:50 <Psybur> shapr, do you like grading tests and assignments? Thats the worst part
13:05:53 <ski> hello again chakri
13:06:04 <chakri> hello ski
13:06:20 <digitalkiwi> Psybur it never saw action there were too many problems with logistics and then the markets kind of stabilized enough that arbitration wasn't really useful...oh and mtgox stole all of my bitcoins
13:06:23 <shapr> Psybur: I only teach interactive workshops, so the students are attempting to write working code during the class.
13:06:48 <Welkin> that reminds me of some article headline I saw earlier this week, "What you don't know about high potential employees", which I read as "high/intoxicated people you are interviewing"
13:06:52 <monochrom> But my wording "code it up" is chosen to carry the connotation that you should stop BSing and start showing at least a toy demo on a computer for real.
13:06:57 <shapr> Welkin: funny!
13:10:24 <chakri> In this type definition for fmap, fmap :: Functor f => (a -> b) -> f a -> f b, what does "f a" and "f b" mean?
13:11:07 <monochrom> "f a" could be "Maybe Int", i.e., "f" could be "Maybe", "a" could be "Int".
13:11:27 <monochrom> fmap is very general so it uses variables rather than actual things.
13:13:38 <chakri> fmap (2*) [1,2,3,4], (a->b) = (2*) callback, "f a" = [1,2,3,4] and "f b" = [2,4,6,8]?
13:13:47 <kadoban> `f a` is a bit like function application at the type level, in case that helps. You can see things like Maybe as functions at the type level, in that you give them a type, like Int, and they give you back another type (Maybe Int is a type)
13:14:40 <monochrom> No, "f a" refers to a type, not to a value. "[1,2,3,4]" is a value, not a type.
13:15:13 <monochrom> But this is right: f=[], a=Integer, so f a = [] Integer, syntax sugar [Integer].
13:15:40 <monochrom> But you be damned if you next said "OK so [1,2,3,4] = [Integer]"
13:15:55 <ski> chakri : instead of  "f a" = [1,2,3,4]  you should say  [1,2,3,4] :: f a
13:16:21 <ski> (the `::' can be read as "has type")
13:16:34 <Welkin> ski: but it's list cons!
13:16:41 <Welkin> D:<
13:16:45 <ski> Welkin : true, true :)
13:17:30 <monochrom> OK so next time you see the Haskell code "2^4" you're going to say "but it's bitwise xor!" ?
13:18:00 <monochrom> I mean what is your purpose here?
13:18:30 <Welkin> it's a joke
13:20:01 <chakri> <monochrom> But you be damned if you next said "OK so [1,2,3,4] = [Integer]"
13:20:14 <chakri> [1,2,3,4] :: Num t => [t] for :type [1,2,3,4]
13:20:29 <chakri> trying to understand the language
13:20:37 <chakri> looks very different from I know so far
13:20:43 <monochrom> OK that one involves a class called "Num".
13:21:07 <monochrom> At this point if you simplify it to [Integer] it is not too bad.
13:21:17 <chakri> yes, polymorphic type and fits [Integer]
13:21:20 <chakri> agree
13:26:59 <m1dnight_> hey guys, I'm trying to use megaparsec 6.1.1, but for some reason my stack keeps installing 5.3.1 or something. Is that normal? I already tried stack update and specifying a specific version in my cabal file, but it never seems to work
13:28:04 <kadoban> m1dnight_: What version gets chosen depends on the resolver. Is this in a project, ie do you have a stack.yaml file for it I assume?
13:28:28 <m1dnight_> ah, yeah, it says resolver: lts-9.4
13:29:31 <kadoban> That should be a relatively new lts resolver. If you need newer than that, you can try a nightly one. Or if you just need a newer version of megaparsec, you can set it as an extra-dep in the stack.yaml to override the version. That won't always work correctly though, it depends if it works with the other versions of stuff in the resolver.
13:29:44 <jared-w> https://www.stackage.org/lts-9.4/package/megaparsec-5.3.1
13:29:57 <jared-w> 5.3.1 is the one for the LTS 9.4. Stackage nightly has 6.1.1
13:30:19 <shapr> m1dnight_: what motivated the switch to megaparsec 6?
13:30:22 <m1dnight_> But the source of megaparsec uses lts-9.0 even
13:30:47 <m1dnight_> I've been using alex and happy for ages, wanted to try combinators, found 1 decent-ish tutorial and that one uses 6.1.1 afaik, hence that version
13:30:54 <kadoban> The source of megaparsec? It doesn't really matter what's in the stack.yaml that comes with libraries.
13:31:43 <monochrom> You could choose to step out of stack.
13:31:59 <jared-w> Megaparsec 6 also includes some major improvements so it's pretty nifty
13:32:04 <kadoban> Or they could just do the one minor change required to get the version they want.
13:32:11 <shapr> yeah, I agree, just wondering what exactly people like about megaparsec 6
13:32:38 <jared-w> I'd probably just switch to the nightly since that's easiest. Second would be using an external line in the stack.yaml thing to specify a newer one (I think you need like 'allow-newer' or something?)
13:32:58 <jared-w> shapr: v6 has much improved speed, some improved error messaging stuff, and quite a bit of work doen on it vs v5
13:33:27 <shapr> jared-w: I liked the fact that I don't have to parse Char and then cast to whatever
13:33:39 <jared-w> That changed in v6 iirc?
13:33:41 <kadoban> jared-w: Shouldn't need anything except the extra-dep usually
13:34:22 <MarcelineVQ> jared-w: I doubt (and hope) stack doesn't have such an allow-newer feature, that's not what stack is for, you're intended to pick specific package versions to work with. the usualy mechanism for doing this with hackage items is extra-deps like kadoban is suggesting
13:35:05 <MarcelineVQ> That wasn't a well made statement. Hopefully it came across.
13:35:21 <jared-w> https://docs.haskellstack.org/en/v1.0.2/yaml_configuration/ there is indeed an allow-newer. It matches the cabal option. Probably not the best idea but it does exist
13:35:30 <kadoban> It probably does have some allow-newer thing to tell Cabal to do whatever when the version constraints in the cabal file can't be satisfied. I don't think I've ever used that though, I'm not sure when it comes up.
13:36:32 <MarcelineVQ> Oh it's for getting around constraints other people chose. bad stack, naughty!
13:38:40 <geekosaur> I thought the way to do this was specify the version in the cabal file and then put that version in stack.yaml
13:39:43 <kadoban> stack doesn't care that much what version you put in the .cabal file (as long as it doesn't directly contradict), but ya it's probably a good idea to put a range that's good in the .cabal file before you release (for people that don't use stack)
13:40:31 <kadoban> IIUC, putting an exact version in the .cabal file isn't usually a good idea, unless literally only one version will work.
13:41:12 <remexre> Counterintuitive derive behavior: https://play.rust-lang.org/?gist=defd1fc6b96549745abe9674bb4d7d5f&version=stable
13:41:32 <kadoban> remexre: xD
13:41:34 <monochrom> That's right. But the fairly effortless "megaparsec == 6.0.*" is socially common.
13:41:47 <remexre> The derived Clone should require F::Inner be clone, not F
13:42:37 <kadoban> remexre: You know this is #haskell, right?
13:42:47 <remexre> Oh O_o
13:42:49 <remexre> whoops
13:42:53 <monochrom> Oh haha
13:42:58 <kadoban> :)
13:43:08 <remexre> That would explain the megaparsec mention
13:43:32 <monochrom> News Flash: megaparsec is coming to Rust
13:43:50 <kadoban> I wonder if rust has some decent parsec combinators
13:43:55 <m1dnight_> boy, this took me a while. Had to upgrade stack but I had haskell-platform installed so had to remove that etc etc, finally got it working :)
13:43:57 <m1dnight_> thanks a bunch guys
13:44:06 <remexre> kadoban: ish? they're a bit sketch
13:44:13 <kadoban> remexre: Darn :(
13:44:19 <digitalkiwi> m1dnight_ this is the rust channel now 
13:44:37 <m1dnight_> oh, well my haskell is rusty
13:44:40 <monochrom> That is strange, to have to remove Haskell Platform. (As opposed to just doing PATH tricks.)
13:44:40 <m1dnight_> does that count?
13:44:40 <digitalkiwi> haskell questions go to #rust-lang
13:44:42 <kadoban> Is this like planet of the apes, he was away so long upgrading?
13:45:04 <m1dnight_> monochrom: yes, but I figured it's pooped anyway, might as well fix it properly.
13:45:08 <m1dnight_> Seems to work still? :p
13:45:11 <monochrom> Haha kadoban
13:45:31 <monochrom> Then again may as well regain some disk space.
13:46:22 <monochrom> I just have a soft spot for Haskell Platform in my heart.
13:46:35 <monochrom> It brought me much happy times.
13:47:03 <kadoban> I had a very negative experience with it when I started :(
13:48:07 <monochrom> This year's Haskell Platform linux x86-64 full tarball has a serious flaw. A lot of the extra libraries are unusable as seen by GHC.
13:48:34 <kadoban> oof, that sounds bad
13:48:37 <monochrom> The exact error message is "xxx is unusable because parent-yyy is shadowed"
13:49:05 <monochrom> The thing is nothing seems to be shadowing parent-yyy at all.
13:50:24 <monochrom> Normally this error message happens when you have multiple versions of parent-yyy, and xxx is built against an older one.
13:50:39 <monochrom> (Cf my http://www.vex.net/~trebla/haskell/sicp.xhtml#pigeon )
13:50:58 <monochrom> But this being a pretty pristine installation from the Haskell Platform tarball!
13:51:28 <monochrom> And I still haven't found what caused it. (And kind of have given up.)
13:52:20 <xzhu> Has anyone done serious data science stuff using Haskell? What was your experience comparing to using R/Python?
13:52:48 <monochrom> And here is the irony or funny part or I-was-lucky. This year I begin to install the Haskell Platform by going: Let me install GHC 8.2.1 on my own, then I look at your package list, and pick a large subset I like, and I cabal-install that list myself.
13:52:51 <digitalkiwi> lmao http://vschart.com/compare/ada/vs/haskell search for "makes you angry" 
13:53:33 <monochrom> In past years I had been installing from the HP binary tarball. So basically I just missed this new problem!
13:54:09 <monochrom> (My change this year is because last year some haddock links were broken.)
13:54:26 <digitalkiwi> actually they have a ton of jokes on there >.>
13:54:46 <monochrom> Oh Ada vs Haskell! I love Ada!
13:55:18 <monochrom> Oh "makes you angry" contains an "s". Missed it the first time.
13:55:19 <digitalkiwi> ada willgetyoulaid
13:55:49 <Tuplanolla> Like "Documentation level" being "★★★★★", digitalkiwi?
13:55:49 <digitalkiwi> at some point it just degraded to high school antics
13:56:15 <digitalkiwi> easy to learn with a check ;p
13:56:30 <monochrom> Wait a second, Haskell has unsafe code support too.
13:57:21 <monochrom> Oh those people agree that Haskell is easy to learn?!
13:57:35 <digitalkiwi> Can be used to invoke demons <-- I'm not sure I want to know if this is a misspell or not
13:57:43 <monochrom> haha
13:59:33 <monochrom> Yeah there are a bunch of clearly joking ones.
13:59:44 <digitalkiwi> monochrom yeah, but they don't say your mom knows it, but maybe we should ask qu1j0t3 to be sure
14:00:07 <digitalkiwi> ^ was at they say it is easy to learn
14:20:38 <nshepperd> your grandmother could learn haskell, and probably already has!
14:21:05 * Clint squints.
14:25:17 <dmwit> Weird. At that "Ada vs Haskell" page, under "Scripting language support", the Haskell side lists Haskell twice. But the second one links to ANSI C.
14:26:18 <maerwald> Ada vs Haskell?
14:26:40 <maerwald> trying to imagine what that means gives me hadaches
14:27:02 <dmwit> Yeah, sounds like you got the gist of that page.
14:28:24 <digitalkiwi> nshepperd my grandparents are dead
14:29:49 <maerwald> lol
14:30:31 <Tuplanolla> The most appropriate reaction, maerwald.
14:30:39 <scav> digitalkiwi the documentation level is funny :)
14:30:49 <nshepperd> so are mine, that's how I know for sure that they know haskell
14:31:00 <maerwald> Tuplanolla: it was clearly a joke, don't pull of the political correctness nonsense
14:31:25 <Tuplanolla> I was going to say it too.
14:31:36 <maerwald> ;)
14:31:39 <digitalkiwi> I wasn't joking :|
14:31:43 <maerwald> haha
14:32:15 <maerwald> mine are dead too, all of them! so they cannot learn haskell. doh
14:32:18 <digitalkiwi> nshepperd the haskell killed them!?
14:32:42 <nshepperd> I prefer to believe that they ascended
14:32:50 <nshepperd> but we'll never know for sure
14:32:53 <digitalkiwi> maybe I can learn haskell before I die
14:32:58 <Tuplanolla> NetHack in the family.
14:32:58 <maerwald> I think they are still programming in assembler in heaven
14:33:13 <digitalkiwi> maerwald that would be hell, not heaven
14:33:21 <maerwald> no, in hell they program javascript
14:33:26 <digitalkiwi> heaven has lisp!
14:33:41 <mauke> ostensibly
14:33:47 <digitalkiwi> https://www.xkcd.com/224/
14:34:05 <nshepperd> heaven has lisp, but you're not allowed to use it, for health and safety reasons
14:34:28 <mauke> sub ($f) { $f->($f) }->(sub ($f) { $f->($f) })
14:44:07 <riaqn> Hello, what would be a haskell-style GUI library look like?
14:44:27 <riaqn> tried gi-gtk and seems just a wrapper around the C library
14:44:37 <mauke> @where frp
14:44:37 <lambdabot> http://conal.net/fran/ http://conal.net/papers/push-pull-frp/
14:44:38 <Cale> riaqn: You might try reflex-dom.
14:44:45 <kadoban> riaqn: Probably FRP based. Though the only one I use of that would be, ya that ^
14:45:15 <riaqn> mauke: Cale kadoban thanks you guys.
14:45:20 <riaqn> I will look into that.
14:45:55 <Cale> riaqn: If you want to try it, I highly recommend using reflex-platform to get set up.
14:45:56 <riaqn> Cale: Well I'm kind of looking at library for desktops(Xorg, windows,..)
14:46:16 <Cale> If you compile with GHC, it will build you a desktop application that uses webkit-gtk
14:46:26 <maerwald> riaqn: if you want serious functionality, you will be left with the gtk bindings, not frp
14:46:28 <Cale> (and controls the DOM with native code rather than JS)
14:46:45 <Cale> (well, now it's partly JS, thanks to how the new webkit-gtk works...)
14:47:07 <maerwald> haskell is awful for gui programming, I suggest python instead
14:47:35 <maerwald> except if you are doing webstuff
14:47:59 <jared-w> GUI programming is generally a shitshow regardless of language. There's a reason everyone's so excited to use javascript, HTML, and CSS for creating GUIs (think about how awful CSS and Javascript is...)
14:47:59 <riaqn> Cale: thanks I will try that. Do you mean it's cross-platform on web/desktop?
14:48:01 <digitalkiwi> could you use eta and java gui bindings?
14:48:03 <MarcelineVQ> idk about that but it's fairly safe to say it's not going to improve if people are dissuaded from trying
14:48:05 <Cale> I dunno, it seems mostly pretty fine to me to use the DOM as a GUI library.
14:48:12 <maerwald> jared-w: no, it depends on language
14:48:15 <Cale> riaqn: yes
14:48:44 <Cale> riaqn: Well, it might be fun getting things to work on Windows -- I don't know what's involved in that since I've never had to try it.
14:49:03 <Cale> But conceivably something ought to be possible
14:49:13 <maerwald> I have had bugs in haskell gtk I have neve seen anywhere else, due to GC and so on. You have to be extra careful. In addition, the bindings are not always correct
14:49:21 <riaqn> OK. now that I'm thinking about it, my app doesn't require deskctop that much
14:49:40 <maerwald> python has the advantage that it can properly map the object-oriented nature of glib
14:49:42 <riaqn> I mean, not intense on graphics. But I hope a decent canvas support.
14:49:50 <maerwald> haskell cannot
14:49:54 <riaqn> I mean like, pixel-level drawing.
14:51:42 <scav> Has anyone used any of the Cassandra libraries before? And if yes, any in particular you would recommend?
14:52:41 <maerwald> riaqn: the only reason I'd prefer haskell gui over something else is because I want to use diagrams 
14:53:35 <maerwald> https://archives.haskell.org/projects.haskell.org/diagrams/
14:53:46 <maerwald> maybe that's what you are looking for wrt "pixel-level drawing"
14:57:56 <riaqn> maerwald: cool. but I really mean bitmap instead of vector...
14:58:18 <riaqn> but that seems a good library to use in company with mine..
14:58:31 <maerwald> diagrams has several backends
14:58:50 <maerwald> it's not just "vector"
15:00:44 <riaqn> yeah but I will describe by pixels, not by lines or circles.
15:00:58 <riaqn> Cale: reflex seems very heavy with webkit..
15:11:04 <maerwald> riaqn: like opencv?
15:11:09 <maerwald> you better stay c++ then
15:11:32 <Welkin> or numpy/scipy
15:11:41 <Welkin> which is really C
15:11:52 <riaqn> no I just need a canvas and draw pixels.. and better be cross-platform
15:12:01 <riaqn> and very few buttons.
15:12:06 <Welkin> a canvas for drawing pixels?
15:12:09 <Welkin> use the html5 canvas
15:12:38 <maerwald> there are not many performant haskell libs wrt image processing and those there are... are very weird haskell
15:13:16 <maerwald> unreadable optimized-to-death code with odd API :o
15:13:39 <maerwald> https://github.com/RaphaelJ/friday
15:18:27 <maerwald> and opencv is still faster :>
16:12:38 <juri_> so, is hhdl not really a thing?
16:13:59 <_d0t> how do i disable simd use in ghc?
18:29:53 <cr1t1cal> how can I print a string with putStrLn without the newline?
18:30:35 <Ojd> cr1t1cal,  like using putStr?
18:30:36 <geekosaur> putStr
18:31:23 <cr1t1cal> also it tells me not to use tabs?
18:32:18 <geekosaur> yes. so does python. indentation-sensitive languages and tabs don;t generally go together well,  because different programs have different notions of how big a tab is
18:32:44 <geekosaur> some editors will tab to the next multiple of 8, some the next multiple of 4, etc.
18:33:19 <idolator> good editors will let you choose
18:33:25 <geekosaur> if you are careful to only ever use tabs for indentation then you can avoid problem, but in an 8-space-tab editor that will wrap around to the next line quickly
18:33:27 <cr1t1cal> i use 8
18:33:37 <cr1t1cal> and python doesn't like when I use spaces AND tabs
18:33:54 <cr1t1cal> but with just tabs for indentation
18:34:05 <cr1t1cal> it doesn't start crying. haskell apparently does
18:34:47 <idolator> i have my editor turn tabs into spaces
18:34:49 <c_wraith> idolator: your editor settings are irrelevant to the compiler
18:35:11 <geekosaur> also irrelevant to other people's editors if you distribute that code
18:35:46 <cr1t1cal> idolator: which editor is this?
18:36:06 <idolator> other people's editors are other people's problem
18:37:03 <idolator> cr1t1cal, i use spacemacs, but any vim-like will do it
18:37:18 <cr1t1cal> i use vim
18:37:24 <cr1t1cal> is there a built-in vim command?
18:37:30 <cr1t1cal> ^idolator
18:38:40 <idolator> in my .vimrc
18:38:51 <idolator> " Convert tabs to 2 spaces always
18:38:51 <idolator> :set tabstop=2 shiftwidth=2 shiftround expandtab
18:39:08 <cr1t1cal> ah. and why 2? i use 8
18:39:10 <cr1t1cal> hehe
18:39:11 <idolator> `expandtab` is the one
18:39:53 <cr1t1cal> ye i got that. thanks
18:40:11 <idolator> because my monitor isn't quadruple wide
18:40:27 <cr1t1cal> lol
18:40:31 <cr1t1cal> have fun ppl
18:45:27 <Welkin> what is a "vim-like"?
18:45:39 <juri_> bad.
18:45:39 <Welkin> vim came out in 1991. emacs came out in 1976
18:49:30 <idolator> emacs is quite not vim-like
18:58:06 <crucify_me> hi is the commented type signature here an error of an online solution set?   https://ptpb.pw/8CTc
18:58:20 <crucify_me> *ie is it in error?
18:58:57 <crucify_me> I don't understand that signature
18:59:15 <mniip> no that looks like a more generic type
18:59:22 <mniip> that is still valid for this function
18:59:52 <crucify_me> mniip thanks, really? I couldn't get it to run... one moment pls
19:00:49 <mniip> @let signum_ x | x < 0 = -1; | x == 0 = 0; | x > 0 = 1
19:00:49 <lambdabot>  Parse failed: Parse error: |
19:01:01 <mniip> @let signum_ x | x < 0 = -1 | x == 0 = 0 | x > 0 = 1
19:01:03 <lambdabot>  Defined.
19:01:10 <mniip> :t signum_
19:01:12 <lambdabot> (Ord a, Num a, Num t) => a -> t
19:02:49 <crucify_me> mniip, odd it does work thank you. could you explain why there are two Num constraints there?
19:03:10 <mniip> because there are two constrained types?
19:03:39 <crucify_me> mniip, er..
19:04:34 <crucify_me> sorry I don't know how that signature works
19:05:09 <idolator> a is both a Num and an Ord (Ord because you're applying order comparisons on it)
19:05:29 <mniip> well
19:05:30 <idolator> t need only be a Num
19:05:43 <mniip> signum_ is a function from any a to any t
19:05:50 <mniip> as long as a is Ord and Num
19:05:51 <mniip> and t is Num
19:06:34 <crucify_me> if idolator wanted to see the paste https://ptpb.pw/8CTc
19:06:51 <crucify_me> the first signature there I guessed and it works fine I thought
19:07:39 <crucify_me> the commented one is causing me trouble
19:08:13 <idolator> you're requiring that the output type also be of typeclass Ord
19:08:35 <idolator> which is fine
19:08:47 <crucify_me> but isn't the output type just a?
19:09:10 <idolator> but it doesn't need to be
19:10:13 <crucify_me> > signum 3.0
19:10:15 <lambdabot>  1.0
19:10:54 <idolator> it need not be. after all, you're losing all of the `a` value but the sign
19:11:42 <crucify_me> interesting please hold on
19:12:27 <idolator> any set of three elements with an equivalence relation should do
19:14:10 * hackagebot positron 0.1.0.0 – Experiment – https://hackage.haskell.org/package/positron
19:14:26 <idolator> Ord represents that the output set should have an ordering relation over it, which is a step further
19:15:49 <crucify_me> right, the last point you made, that program requires Ord because of the way the case statements are written
19:15:51 <crucify_me> idolator, 
19:16:43 <crucify_me> correct?
19:17:28 <olligobber> :t signum
19:17:30 <lambdabot> Num a => a -> a
19:17:40 <olligobber> :t signum_
19:17:41 <lambdabot> (Ord a, Num a, Num t) => a -> t
19:22:30 <crucify_me> sorry no capiche. signum doesn't require Ord at all?
19:23:01 <zoid1> Why did lambdabot spit out two different type signatures?
19:23:39 <crucify_me> one of the signums is signum_ which was written for helping me out
19:23:59 <crucify_me> I'm a bit confused as usual
19:24:32 <crucify_me> https://ptpb.pw/8CTc zoid1 see comments
19:25:02 <olligobber> zoid1, I asked about two functions, hence two types
19:25:54 <crucify_me> olligobber, et al , so because of the way the case statements are written sequentially, is that why it needs that longer signature?
19:27:30 <olligobber> I don't know enough about signum_ to answer that
19:28:37 <olligobber> oh, it was defined up there
19:29:13 <olligobber> it's because you used < on x, which can only happen if x is Ord
19:29:31 <olligobber> you compared x to a number, which can only happen if x is Num
19:29:56 <crucify_me> ok yes, so there are 2 versions of Num : Num a and Num a1. why is that?
19:29:57 <olligobber> and you returned numbers, so the return value of signum_ must be Num
19:30:13 <olligobber> crucify_me, because what it's given doesn't have to be the same as what it returns
19:30:29 <olligobber> that function is fine if I give it a Float and expect it to return an Integer
19:30:56 <olligobber> those two types can be the same too, it will work either way
19:31:03 <crucify_me> oh because ie if you enter 1.2   ..? excellent I see, yes you need to make it more flexible
19:31:22 <crucify_me> thanks!
19:31:44 <olligobber> in general if you don't tell Haskell what type something will be, it will make it as general as possible
19:31:55 <olligobber> if you want it to be less general, declare its type
19:32:37 <crucify_me> right, however with the Num a  alone, it does take a Float I believe olligobber 
19:33:09 <olligobber> yeah, it will take a Float as it is
19:33:27 <crucify_me> what would be a case where the Num a1 is essential?
19:33:45 <olligobber> if I give it 'a', it can
19:33:50 <olligobber> can't do 'a' < 0
19:34:11 <olligobber> cos 'a' isn't a number but 0 is
19:34:44 <olligobber> :t (<)
19:34:46 <lambdabot> Ord a => a -> a -> Bool
19:38:12 <crucify_me> yes, but what would be an input that illustrates how the Num a1 is utilized olligobber ?
19:38:48 <crucify_me> since a Float doesn't require the additional value in the signature
19:39:51 <idolator> signum -1.0
19:40:05 <idolator> signum (-1.0)
19:40:27 <idolator> lambdabot, help
19:40:37 <zoid1> > signum (-1.0)
19:40:38 <idolator> :help
19:40:40 <lambdabot>  -1.0
19:40:46 <idolator> ty
19:40:55 <idolator> > signum (-1.0)
19:40:56 <crucify_me> ok it goes unevaluated
19:40:58 <lambdabot>  -1.0
19:41:17 <idolator> that's your version
19:41:25 <crucify_me> > signum_ (-1.0)
19:41:27 <lambdabot>  -1
19:41:53 <olligobber> I'm not sure if we're talking about signum or signum_ right now...
19:42:00 <idolator> that's the version you're asking about
19:42:59 <olligobber> the reason signum_ needs the input to be Num is so it can compare the input to something that is a Num
19:43:40 <olligobber> so signum_ 'a' won't work, since signum_ tries to do 'a' < 0 which doesn't make sense
19:43:54 <olligobber> signum_ 0.1 will work, since signum_ can do 0.1 < 0
19:44:40 <olligobber> but signum_ (2::Integer) will also work, even though (2::Integer) isn't a Float, it can be compared to 0
19:46:47 <crucify_me> ok so the extra value, Num a1, is to distinguish between potential numerical types, and the numerical type, Integer, which is used in the case statements
19:47:47 <olligobber> no type is used in the case statements
19:48:15 <olligobber> in the case statements, the input is compared to 0
19:48:16 <olligobber> :t 0
19:48:17 <lambdabot> Num t => t
19:48:31 <olligobber> 0 can be any numerical type
19:48:58 <pikajude> because that secretly becomes "fromInteger 0"
19:49:00 <pikajude> i think
19:49:10 <pikajude> yeah it does
19:49:26 <pikajude> if you turn on RebindableSyntax and try to use an integer literal, you'll get an error about fromInteger missing
19:54:07 <JazzyEagle> Odd question...  Trying to figure out a web framework and a corresponding template language...  The only templating langauge I see that seems to support the three big web languages (HTML/CSS/JS) is Shakespeare, which has a more complex backend...
19:54:13 <crucify_me> thanks pikajude olligobber I need a tutor. still don't get why Num a and Num a1 are required, when signum seems to do everything that signum_ does . very sorry
19:54:25 <JazzyEagle> Most of the other templating languages I'm seeing appear to focus purely on HTML....
19:54:56 <JazzyEagle> blaze-html looks nice, but I'm not seeing a blaze-css nor blaze-js
19:55:09 <JazzyEagle> Does anyone have any other recommendations?
19:55:40 <boj> JazzyEagle: if you want to step into crazy SPA world look at Reflex/Reflex-Dom
19:55:51 <JazzyEagle> SPA?
19:55:58 <boj> single page application
19:56:16 <zoid1> What do you mean with 'backend'? I don't think you have to use Yesod for Shakespear templates
19:57:23 <boj> JazzyEagle: there's clay for css, and lucid as an alternative to blaze
19:57:28 <JazzyEagle> boj: Thanks, I'll take a look at it.
19:58:21 <JazzyEagle> zoid1: Yes and no.  For an individual file/QQ of hamlet/julius/cassius/lucius, you don't need Yesod.  To put them all together, you need a widget, which IS part of Yesod.
19:58:25 <boj> JazzyEagle: if you are familiar with react/angular/ember/whatever reflex is the haskell counterpart (but Functional Reactive Programming)
19:59:51 <JazzyEagle> I'm not really familiar with those, but I've heard of them before.  I should give them a look.  Hopefully, I can find some decent docs.  :)
20:00:37 <JazzyEagle> the reflex stuff, I mean.
20:01:06 <boj> sadly the docs are a bit lacking
20:02:02 <boj> worth it if you are willing to invest the time. maybe not a good choice if you need to release something in 3 months
20:02:59 <JazzyEagle> I don't have a need to release at all, but would like to.
20:03:49 <boj> if you want to get a working environment pulled together look at the reflex-platform project
20:03:59 <JazzyEagle> I was looking at Snap as a web framework, but I don't like their Heist templating.  Scotty uses blaze-html, which looks nice.
20:04:07 <pikajude> heist is annoying
20:04:14 <pikajude> i have no idea how they settled on that
20:04:22 <JazzyEagle> I agree, pikajude.  :)
20:06:22 <boj> has anyone had the unfortunate pleasure of having to talk to an IBM DB2 system? HDBC is the way to go here?
20:06:57 <JazzyEagle> The reflex-platform example doesn't show a web example.  The example appears to show some sort of console application.
20:07:21 <boj> JazzyEagle: the example is an app that runs in the browser
20:07:37 <boj> it gets built down into pure javascript
20:08:03 <pikajude> reflex is client side only
20:08:10 <pikajude> you can use websockets and stuff but it's designed for building in-browser apps
20:08:24 <boj> if you aren't familiar with single page apps reflex might not click immediately
20:08:54 <JazzyEagle> Yeah, not totally familiar.
20:10:16 <JazzyEagle> I've used single page apps before, but never really looked under the hood.
20:12:52 <boj> rather than ask the server to draw pages via templates and render html, you have something like reflex manipulate the browser DOM directly and change actions/views on the fly
20:14:04 <boj> tends to lead towards a smooth user experience (stuff is snappy), and less data over the wire (typically json instead of full html pages)
20:14:12 <JazzyEagle> Not sure that's what I really want to go for, though.  Most of the various pages on the site, I'd like to have folks have a direct URL to
20:14:45 <emmanuel_erc> Hello there! when I try to install ghc ( a new version) I am getting this error: https://pastebin.com/Z6XQ81Cb
20:15:14 <boj> that is possible of course. if you see sites with site.com/#!/deep/link that is a direct URL into the "page"
20:15:17 <JazzyEagle> Plus there's several people I know that tend to disable JS where possible, so using something that will pretty much be completely JS dependent would probably not fly with the or others likeminded.  Not sure that's a complete blocker, but I'm at least debating it.
20:15:37 <JazzyEagle> Hrm.
20:15:38 <boj> yeah, disabling JS is of course the drawback
20:16:10 <boj> you can't can wrong with boring old server side template rendering
20:16:22 <JazzyEagle> I don't think my pages will necessarily be all that big, anyway.
20:17:09 <boj> can't go*
20:17:32 <JazzyEagle> I'll probably need a little bit of JS on my site, but hopefully it'll end up being minimal.  JS and I typically don't get along so well.
20:17:52 <boj> usually the case :)
20:18:32 <JazzyEagle> lol
20:19:15 <JazzyEagle> Well, maybe I'll see first what I can finagle blaze-html into doing using stylesheet headers and <script> tags
20:20:15 * hackagebot apecs 0.2.0.0, perf 0.3.0, tart 0.1.1
20:20:15 * hackagebot  → https://hackage.haskell.org/packages/recent
20:22:10 <JuanDaugherty> disabling js in a browser is sick
20:22:41 <MarcelineVQ> yeah, what do you want, security or something?
20:22:45 <JuanDaugherty> in general, outside of a rationalizing situation
20:24:04 <JuanDaugherty> fully secure: not connected to the internet
20:24:31 <glguy> Yeah, it's all or nothing. If you don't own anything you have nothing to steal
20:24:44 <JuanDaugherty> or maybe actually do stuff for security
20:25:18 <MarcelineVQ> stuff like disabling js?
20:25:24 <pikajude> lol
20:27:14 <JuanDaugherty> also, a lot of time I'm wondering, what is it these individuals are protecting themselves from? ... . On the opposite track
20:27:37 <pikajude> javascript
20:27:46 <glguy> In any case , the topic here is Haskell programming
20:27:52 <JuanDaugherty> a thing I thought I would have to laborously migrate from flash to js can be done solely with amazingly little CSS
20:28:02 <JuanDaugherty> and a lil js/html
20:28:09 <JuanDaugherty> js html are a thing
20:28:56 <JazzyEagle> Yeah, unfortunately, so many companies have used proprietary JS in the background that tends to collect peoples' data.  I personally have nothing to hide, but other people prefer to not have everything they post be collected.
20:30:40 <JuanDaugherty> i wonder what the real deal is on the various hs-js things? Are they the monsters they appear, or does is somehow work out in practice?
20:30:59 <boj> works just fine in practice
20:31:12 <JuanDaugherty> which one, ghcjs?
20:31:16 <boj> yeah
20:31:40 <JuanDaugherty> on unprepared random clients?
20:31:56 <pikajude> what do you mean by unprepared?
20:31:56 <boj> with minification and compression you can get file sizes for a full app to ~300k (in a world where the average page size is 2.5mb)
20:32:05 <boj> i don't follow either
20:32:38 <JuanDaugherty> i mean a random user someplace with a browser that never heard of haskell
20:32:45 <pikajude> ok
20:32:47 <pikajude> and?
20:32:57 <pikajude> ghcjs compiles to javascript, not haskell
20:32:59 <boj> the end user doesn't care what it was originally written in
20:34:43 <JuanDaugherty> i see
20:39:20 <JazzyEagle> Oh, lucid apparently has some built in JS support...  It has functions e.g. onclick_, ondrag_, onformchange_, etc.
20:39:41 <JazzyEagle> I'm not exactly sure how they look yet, but that's a plus.
20:39:49 <boj> JazzyEagle: at the end of the day the just render out html text. you could write these yourself if they didn't exist
20:41:12 <JazzyEagle> Yeah, I know.  I'm just not confident enough in my Haskell skills to attempt that stuff.  I know most of these types of templating languages uses TH and QQ, both of which I have a little experience of using as part of an already existing lib, but neither of which I have ever used to write my own program.
20:42:26 <JazzyEagle> I haven't completely ruled out the idea, especially if it's extending an already existing set of libs (e.g. blaze or lucid), but I'm viewing that as kind of a last resort.
20:43:02 <boj> oh, i definitely suggest lucid or blaze. just saying, if one or the other is missing something you need it's easy to extend them
20:43:36 <JazzyEagle> Awesome.  :)
20:45:43 <dmj`> JazzyEagle: type-of-html will be faster, and safer
20:45:51 <dmj`> @package type-of-html
20:45:51 <lambdabot> http://hackage.haskell.org/package/type-of-html
20:46:08 <MarcelineVQ> dmj`: thank you, I was trying to remember what that one was called
20:47:55 <dmj`> MarcelineVQ: cheers
20:48:01 <dmj`> JazzyEagle: 8.2 only though
20:48:22 <JazzyEagle> I think I already have 8.2.
20:48:43 <JazzyEagle> It looks very similar coding-wise to lucid.  Is the primary difference additional type safety?
20:48:50 <JazzyEagle> or is there more to it?
20:52:31 <dmj`> JazzyEagle: it uses AppendSymbol which is a new way to append Symbols at the type level. 
20:53:08 <JazzyEagle> Not sure what that means...
20:55:10 <dmj`> JazzyEagle: at compile time it will assemble all the type level HTML into a single Symbol and call `symbolVal` to extract a String from the type. But, if you compile with optimizations ghc you can skip allocating the String, allocating a ByteString instead. So no intermediate values are created.
20:55:51 <dmj`> :t symbolVal
20:55:52 <lambdabot> error: Variable not in scope: symbolVal
20:56:17 <dmj`> symbolVal :: forall n proxy. KnownSymbol n => proxy n -> String
20:58:42 <JazzyEagle> I think I get it.
21:00:57 <dmj`> JazzyEagle: you can do type level computation in Haskell
21:01:01 <dmj`> > natVal (Proxy :: Proxy (2 + 2))
21:01:04 <lambdabot>  error:
21:01:04 <lambdabot>      Not in scope: type constructor or class ‘+’
21:01:08 <dmj`> > 4
21:01:11 <lambdabot>  4
21:03:08 <JazzyEagle> Ok, so type-of-html doesn't seem to have as many functions as lucid.  I wonder if this can be easily extended as well...
21:03:59 <JazzyEagle> Most, if not all, of the HTML tags I'll need are there, but lucid was extended to have the js functions as well.
21:04:39 <dmj`> JazzyEagle: it’s bad practice to use inline javascript in html anyways
21:06:12 <JazzyEagle> Even for onclick's and whatnot?
21:07:12 <JazzyEagle> I realize the function that one calls from the onclick should be in a separate script section, but the onlick call itself...  Doesn't that have to be part of the HTML tag?
21:08:00 <JazzyEagle> Mind you, I haven't tried dealing with JS in a LOOOOOOOOOONNNNNGGG time, so things could very well be different, but that's how I remember it.
21:10:47 <dmj`> JazzyEagle: you can get access to the DOM tree and manually bind the event. document.getElementById(‘foo’).addEventListener(‘click’, function (e) { console.log(e); }) Although, this is inefficient and not composable, so you’d probably want to use some higher level Haskell web framework. Unless you’re just writing some small script.
21:14:04 <JazzyEagle> Ok.
21:15:04 * hackagebot apecs 0.2.0.1 – A fast ECS for game engine programming – https://hackage.haskell.org/package/apecs
21:15:24 <JazzyEagle> Thank you all for the wonderful suggestions.  I have a lot to think about now and will sleep on it.  Take care, everyone.
21:57:57 <Fngl> hello~ what dose the dot mean in "  map parseMessage . lines"
21:58:48 <Clint> Fngl: it means function composition
22:01:23 <Fngl> Clint: thank you
22:03:51 <iqubic> :t (.)
22:03:52 <lambdabot> (b -> c) -> (a -> b) -> a -> c
22:05:30 <iqubic> > let func x = ((+5) . (*5)) x in func 10
22:05:33 <lambdabot>  55
22:05:47 <iqubic> It multiplies by 5 then adds 5
22:05:56 <iqubic> Composition example.
22:14:41 * hackagebot apecs 0.2.0.2 – A fast ECS for game engine programming – https://hackage.haskell.org/package/apecs
23:14:51 * hackagebot numhask-array 0.0.2 – See readme.md – https://hackage.haskell.org/package/numhask-array
23:29:37 <xzhu> I'm trying to use Haskell for some web scaping.
23:29:45 <xzhu> I'm looking at the HTTP package
23:29:48 <xzhu> @hackage HTTP
23:29:48 <lambdabot> http://hackage.haskell.org/package/HTTP
23:31:07 <xzhu> However it seems that it uses `String` too much as opposed to `Text`
23:31:08 <xzhu> Is there a faster package that uses `Text` instead?
23:33:40 <xzhu> G .. Guys?
23:34:12 <MarcelineVQ> if people know, and are around, they'll answer :>
23:35:15 <MarcelineVQ> I'd probably look towards http-conduit first and see if it's closer to what you're after
23:36:13 <MarcelineVQ> https://www.stackage.org/haddock/lts-9.4/http-conduit-2.2.3.2/Network-HTTP-Conduit.html also has a couple links at the top that might be useful
23:38:23 <xzhu> Ahh ... it's by Michael Snoyman -- that's a big assurance
23:44:33 <Cale> xzhu: Yeah, HTTP is just older than Text is
23:45:34 <Cale> I don't entirely love http-conduit (some of the exception usage is a little strange), but it's probably the best library of its kind right now.
23:47:51 <MarcelineVQ> wouldn't surprise me if an machines-http came along
23:50:08 <xzhu> Is http-client just a newbie-friendly version of http-conduit?
23:51:15 <xzhu> and for parsing and manipulating HTML, do you recommend blaze-html??
23:55:33 <Cale> xzhu: http-client is part of http-conduit -- you can use it on its own, but it provides a fairly low-level interface to HTTP.
23:56:20 <Cale> xzhu: blaze-html isn't a parser as far as I'm aware
23:57:22 <xzhu> I just realized that. Maybe xml-conduit?
23:57:37 <Cale> Yeah, xml-conduit is all right, why are you parsing HTML?
23:58:03 <Cale> If you're just trying to scrape some data out, often tagsoup is sufficient.
23:58:45 <Cale> (It doesn't parse the tree structure, just gives you a list of tags and some tools for chopping that up)
