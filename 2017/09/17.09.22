00:00:25 <saurabhnanda> can anyone give any pointers on how to debug this complicated type error: https://gist.github.com/saurabhnanda/d9641a6d376a270de78bd4e7305b3e3f
00:06:35 <tdammers> saurabhnanda: well, it would probably be easier to figure out if you pasted code, but generally speaking, a good approach to fixing type errors is to add explicit type annotations in strategic places until you hit the spot where what you think the type should be and what GHC thinks don't match
00:07:23 <saurabhnanda> tdammers: problem is, I have no idea what's going at the type-level when it comes to servant.
00:07:33 <saurabhnanda> tdammers: there is just **too much** type-level magic.
00:08:14 <[exa]> saurabhnanda: use type holes and copy the type
00:09:08 <saurabhnanda> [exa]: that approach has lead to an extremely complicated type signature that I do not understand. Now, that particular function compiled (the one with the inferred complicated type signature). But when I'm trying to use it -- it leads to another type error which I have no clue how to solve!
00:09:33 <saurabhnanda> this is the inferred complicated type-signature I"m talking about -- https://github.com/haskell-servant/servant/issues/812#issuecomment-331363078
00:09:59 <[exa]> not the funny kind of types, right
00:10:44 <[exa]> well, just from looking at the original errors: the first error is very probably about missing/redundant "Tagged" somewhere
00:12:05 <[exa]> second is similar, you see that there's "PK Autogenerated....." part even in the second type error in both unmatching types, so it's again going to be a wrapping issue
00:13:33 <saurabhnanda> what's a "wrapping issue"
00:13:37 <[exa]> but yes, servant should probably have less types. :]
00:14:45 <[exa]> saurabhnanda: you are passing type `a` and it's expecting type `B a` (or the other way around)
00:15:51 <saurabhnanda> ah okay
00:16:27 <saurabhnanda> hang on, let me try something...
00:18:22 <[exa]> saurabhnanda: uneducated guess is that toServant isn't exactly what run expects (it expects Application)
00:19:04 <[exa]> saurabhnanda: so probably something like `run 12345 $ serve (api) (toServant yourserver)`
00:19:55 <saurabhnanda> runServer = AppServer.run (Proxy :: Proxy (ToServant (Routes AsApi))) (toServant server)
00:20:01 <[exa]> saurabhnanda: also suggest you take a look at this https://github.com/chpatrick/servant-generic
00:20:10 <[exa]> (if you don't use it already)
00:20:15 <saurabhnanda> [exa]: have that open in a browser tab alread
00:20:20 <saurabhnanda> that's where toServant is coming from
00:20:57 <[exa]> oh cool :]
00:21:57 * hackagebot forest-fire 0.1.1.1 – Recursively delete CloudFormation stacks and their dependants – https://hackage.haskell.org/package/forest-fire
00:23:03 <saurabhnanda> isn't there any way to give more meaningful type errors for common cases?
00:24:14 <Axman6> saurabhnanda: you've seen :kind! in GHCi right? (I haven't followed all of this, just the error you pasted)
00:25:43 <saurabhnanda> Axman6: isn't that :kl
00:25:45 <saurabhnanda> sorry :k
00:26:23 <Axman6> :kind and :kind! di slightly different things, :kind! will expand the kind fully
00:26:44 <Axman6> so, you can ask what :kind! Tagges Handler Application actuallty is
00:27:08 <Axman6> I wonder if GHC 8.2's errors would be more useful
00:28:39 <Axman6> and likewise, :kind! ToServant (Routes (AsServerT AppM)) might be useful
00:29:17 <saurabhnanda> nice tip. thanks
00:29:58 <Axman6> Hopefully one day we'll see a) improvements to the type level errors stuff and b) servant make good use of them
00:36:10 * hackagebot vector-builder 0.3.2 – Vector builder – https://hackage.haskell.org/package/vector-builder
00:45:20 <saurabhnanda> this is very weird. If I use my type-level proxy and server handler directly, it works. If I was to pass them in, it can't figure out what's going in!
00:45:54 <saurabhnanda> gaah... I could've finished my feature development by now, had it not been a day wasted in this pointless type-error.
00:51:55 <maerwald> switch to python :>
00:52:05 <maerwald> no type errors, just runtime errors :P
00:52:16 * [exa] goes yay!
00:53:40 <tdammers> maerwald: -fdefer-type-errors
00:53:55 <m1dnight_> Does the choice function of Parsec consume input for each attempt?
00:53:58 <maerwald> don't tell people this flag exists plz
00:54:17 <tdammers> maerwald: don't tell people to use Python plz ;)
00:54:18 <saurabhnanda> no, seriously, this particular type-error has got nothing to do with the correctness of the program. It's not helping me in **any** way.
00:54:31 <saurabhnanda> it's just random shenegians to satisfy the compiler.
00:55:02 <saurabhnanda> tdammers: will -fdefer-type-errors work if the program is conceptually correct, but the compiler can't figure it out?
00:55:17 <tdammers> saurabhnanda: sort of, but please don't use it
00:55:27 <maerwald> tdammers: why? because they won't hire you for consulting then? :>
00:56:15 <tdammers> saurabhnanda: defer-type-errors is mainly intended for explorative coding, when you have work-in-progress code around that you can afford to have ill-typed for the time being, just to see how things would work out
00:57:07 <tdammers> saurabhnanda: if your code is conceptually correct, but the types don't work out, it still won't work, but the "not work" moment will be at runtime, not compile time. That's why it's called "defer"
00:58:06 <saurabhnanda> tdammers: in my particular use-case it's the same value that is being used in serveWithContext. It's just that if I want to pass it in to my 'run' function the type-checker starts getting all funky on me. What if I use -fdefer-type-errors ?
00:58:33 <maerwald> see, you opened a can of worms
00:58:35 <saurabhnanda> hard-coded value = works; want to pass-in the value = type-checker goes crazy.
01:01:35 <tdammers> defer-type-errors is not the solution you are looking for
01:02:13 <tdammers> unfortunately I'm not familiar enough with Servant to help you here, but I'm sure someone with a bit more clue would be able to help you
01:06:31 <ertes-w> helo
01:07:16 <maerwald> ertes-w: 250 OK
01:07:21 <ventonegro> hallo
01:12:04 <saurabhnanda> OLEH
01:12:23 <maerwald> that was a timeout already
01:19:42 <saurabhnanda> is it just me or is stackage search slow for e'one else?
01:21:05 <kreetx> hi channel! Question: is it possible to define a constraint shorthand in a way that when the shorthand is used it doesn't need to be fully saturated?
01:22:06 <kreetx> i.e `type C a = (A a, B a)` makes the C always require an argument when used
01:22:50 <kreetx> and so it can't be used in all places where A or B 
01:29:02 <kreetx> here is a paste of the issue: https://pastebin.com/B6a6qdSU
01:48:46 <kreetx> humble repost of my issue ): https://pastebin.com/B6a6qdSU
01:49:12 <ertes-w> kreetx: there are some places where type aliases must be fully saturated…  i believe this is related to the decidability of type checking
01:50:58 <cocreature> kreetx: you can make a new class that has A and B as superclasses
01:51:17 <cocreature> e.g. "class (A a, B a) => AB a"
01:52:36 <kreetx> cocreature: yes, and then an instance for all which have the superclasses as well.. I thought as this is the only function of AB, then the dance could be avoided altogether. Oh well..
01:53:00 <kreetx> but thanks!
01:53:11 <cocreature> kreetx: it’s a reasonable request, it’s just not possible atm :)
01:56:33 <kreetx> ertes-w: I remember reading about why type aliases needet to be fully saturated and that made sence, I wonder if it's the same with constraints -- then restriction would also makes sense
01:56:56 <kreetx> *sense
01:57:43 <mniip> constraints aren't really different from types
02:05:34 <dysfun> certainly not! : http://www.cs.uu.nl/research/techreps/repo/CS-2002/2002-031.pdf
02:07:01 <mniip> you can go back and forth between kinds k and k -> Constraint
02:07:10 <mniip> is what I mean
02:08:14 <kreetx> what I was getting at is that does the same problem arise with not fully applied constraint synonyms as it does with type synonyms
02:08:29 <mniip> sure does
02:09:01 <kreetx> found a so question here, but I can't grasp it yet: https://stackoverflow.com/questions/4922560/why-doesnt-typesynonyminstances-allow-partially-applied-type-synonyms-to-be-use
03:08:16 <terrorjack> hi, what is the fastest way to eval a javascript expression in haskell? i'm thinking of a proper node.js rpc service but that seems too heavyweight
03:09:40 <tdammers> for a one-shot thing, pipe javascript code into node.js; if you need more than one call, then the rpc service is probably the most pragmatic approach
03:10:01 <tdammers> alternatively, write a standards-compliant JS interpreter in Haskell, or write Haskell binding for an existing JS interpreter
03:10:10 <tdammers> to my knowledge, neither of these currently exists
03:10:53 <romanix> suddenly a node rpc does not look like overkill :)
03:12:00 <terrorjack> seems no one has written a node eval rpc for haskell before..
03:13:34 <tdammers> I've done the rpc thing myself once, except for phantomjs, not node
03:14:26 <terrorjack> or i could use webdriver and fire up a selenium-powered chrome window? ehhh
03:14:53 <tdammers> ewww
03:15:11 <tdammers> (fwiw, I used phantomjs because I actually needed to drive a web browser)
03:15:56 <brynedwards> isn't there headless chromium now?
03:16:51 <terrorjack> perhaps i can actually make this into a package: add a hook in Setup.hs, then cabal configure will do the npm install, and the rpc shall be available in user code
03:18:09 <Sornaensis> does anyone here have practical experience working with frp in haskell
03:19:21 <boj> Sornaensis: what is on your mind?
03:19:46 <Sornaensis> i just want to ask a few general questions
03:20:46 * hackagebot vector-builder 0.3.3 – Vector builder – https://hackage.haskell.org/package/vector-builder
03:20:50 <Sornaensis> what problems you solve it with, what you like about it, what you dislike about it, how it fits into your overall project(s)
03:22:23 <boj> one of the more up and coming FRP libaries in Haskell is Reflex. a lot of us are using it to do single page application web development in (it builds out to JS with the GHCJS compiler)
03:23:35 <terrorjack> reflex is nice but hackage releases are a bit lagging
03:23:58 <Sornaensis> neat
03:24:01 <boj> terrorjack: that came up in a reddit thread this week. ryan said they are aiming to do more consistent release cycles soon
03:24:18 <Sornaensis> anything you don't like about reactive programming
03:24:50 <Sornaensis> ?
03:25:11 <boj> Sornaensis: it's so completely different to anything else, at least for me. hard to really pinpoint what i don't like. a completely different paradigm means a lot of work figuring out what is what
03:25:23 <terrorjack> i guess for reflex users this ain't a big deal, they tend to use nix & ghcjs and tend to use the version on git
03:25:29 <Sornaensis> neato
03:26:14 <boj> Sornaensis: it's interesting to note that your whole DOM renders statically, and Events alter the state of everything as opposed to redrawing sub-components based on functions computing logic
03:27:59 <boj> terrorjack: yeah. i'm not sure that is is good for long term stability though. grateful they have reflex-platform to pull in and keep that whole ecossytem together, but it'd be nice to simply install GHCJS like you would GHC, and pull packages in as usual from hackage/stackage
03:28:43 <Sornaensis> how does threading work with ghcjs
03:29:39 <terrorjack> ghcjs has sync/async threads. most of the time you just need the latter
03:35:30 <ertes-w> Sornaensis: what i don't like about reactive programming is approaches other than FRP
03:37:07 <Sornaensis> I'm currently working with a pseudo-frp home rolled framework
03:37:12 <Sornaensis> that is written in java
03:41:03 <druidofluhn> Got a question about representing parsed vs unparsed data structure
03:41:49 <druidofluhn> I receive tokens with some fields and want a way of representing a parsed token, with the same fields and more
03:42:44 <druidofluhn> At the moment I can just do data Token = UnpToken { x, y, z } | ParsedToken { px, py, pz, ... }
03:42:53 <druidofluhn> But I think that there must be a nicer way of doing this
03:46:50 <druidofluhn> At the moment I have record type Token, which has a Maybe Dependency field, and the Dependency record type contains the extra information
03:47:36 <cocreature> druidofluhn: usually you would have separate types for unparsed and parsed tokens. then your parse function is something like "UnparsedToken -> ParsedToken"
03:47:54 <cocreature> druidofluhn: if you’re worried about duplication caused by that, factor out the common parts of both types into a separate type
03:48:31 <druidofluhn> OK, it was the duplication I wanted to get rid of
03:48:55 <druidofluhn> So I'm encoding the Maybe (parsed vs unparsed) in the type by havign two types
03:49:09 <cocreature> druidofluhn: "data SomeData = SomeData x y z", "data UnparsedToken = UnparsedToken SomeData", "data ParsedToken = ParsedToken SomeData otherdata"
03:49:42 <cocreature> the problem is that if you just use a Maybe, you are not guaranteed that your tokens are actually parsed after calling the parse function
03:49:58 <cocreature> by using separate types you enforce that all tokens are parsed after calling the parse function
03:50:41 <xacktm> Hi, got a maybe dumb question about persistent - how do I access the fields of the Entitys returned by a selectList ?  selectList returns [Entity MyData] , but I want MyDataField for every element
03:50:42 <druidofluhn> Yep, thanks!
03:53:05 <barrucadu> xacktm: You can go from Entity a -> a using entityVal
03:54:25 <xacktm> ok, let me try
04:04:16 <xacktm> ok got it now, had to import myDataField from my model, not EntityField(MyDataField), thanks!
04:18:17 <saurabhnanda> if I want the defaultOptions in Aeson to change for my entire app, so that I can using `deriving (ToJSON, FromJSON)` and have it use my defaultOptions, is backpack the only possible solution to do this?
04:22:54 <osa1> saurabhnanda: you can patch aeson and use your patched version :P
04:23:02 <osa1> (I have no idea how can backpack help with this btw)
04:25:31 * hackagebot mallard 0.6.0.4 – Database migration and testing as a library. – https://hackage.haskell.org/package/mallard
04:25:31 * hackagebot mallard 0.6.0.3 – Database migration and testing as a library. – https://hackage.haskell.org/package/mallard
04:27:47 <lyxia> saurabhnanda: Iceland_jack's https://gist.github.com/Icelandjack/d258b88a0e0b3be2c0b3711fdd833045 would be nice for that.
04:28:57 <saurabhnanda> interesting
04:29:04 <lyxia> The closest you can get is probably with template haskell or CPP
04:33:31 <bartavelle> TH let you change default options, and even though it is annoyingly slow to compile, it should have better performance than the generic version
04:33:56 <bartavelle> although it probably doesn't matter much
04:34:14 <saurabhnanda> bartavelle: has anyone done any benchmarks on TH version vs Generic version. In a webapp , I guess, the JSON encoding perf is going to be important!
04:34:41 <cocreature> bartavelle: are you sure it’s actually significantly slower when it comes to compile time than Generics? I remember that not too long ago, generics were so bad that a few packages switched to TH. although I think that was at least partially fixed in ghc since
04:34:55 <osa1> TH version is likely to optimize better because Generics-based version have one more layer of abstraction to optimize away
04:36:32 <lyxia> saurabhnanda: https://github.com/bos/aeson/pull/524 has some benchmarks
04:37:40 <merijn> ugh...why are recursive imports such a pain to achieve :\
04:53:11 <saurabhnanda> merijn: elaborate, please?
04:53:43 <ongy> the compiler will yell at you if module A imports module B and module B imports module A
04:53:49 <merijn> What's the to elaborate? I have two modules where recursively importing them would make my life very easy, but I can't
04:54:06 <merijn> ongy: Which is actually non-compliant with the report, which supports recursive imports
04:54:37 <ongy> https://wiki.haskell.org/Mutually_recursive_modules hs-boot is supposed to fix it, never tried it, but I imagine it works meh at best
04:54:48 <merijn> ongy: Yeah, but that's annoying to do
04:56:26 <saurabhnanda> lyxia: if I've understood the numbers in https://gist.github.com/Lysxia/7ea97543e1821ae7f73758e82d35b6a9 properly, it seems that TH is faster during runtime by a factor of 2-6x, right?
04:56:48 <saurabhnanda> merijn: sorry, misunderstood recursive with cyclic
04:59:53 * hackagebot pragmatic-show 0.1.0.0 – Alternative Show class that gives shorter view if possible. – https://hackage.haskell.org/package/pragmatic-show
05:37:10 <merijn> bleh...I hate it when 2 basically identical functions don't quite fit a single implementation :\
05:40:44 <maerwald> first world problems man! Other people don't even have functions, only methods :>
05:43:00 <[exa]> maerwald: all the daily victims of duck typing in developing countries
05:43:17 <maerwald> haha
05:58:42 <saurabhnanda> why doesn't openFile give the filename that it was trying to open?  Just got stumped by the following error message: `*** Exception: openFile: does not exist (No such file or directory)`
05:58:49 <saurabhnanda> how does one even begin to debug this?!
06:01:12 <merijn> saurabhnanda: Because no one thought to implement it. 
06:01:23 <merijn> saurabhnanda: Actually, looks like base-4.10 already does that
06:02:00 <merijn> saurabhnanda: Which GHC are you using?
06:02:46 <merijn> Actually, seems the path gets added for several versions. Maybe someone just forgot to update the Show instance for IOError
06:03:27 <merijn> Yeah. The show instance just doesn't display that info
06:04:04 <merijn> If you catch the error you can inspect it. And I'm sure a patch improving the Show instance for IOError would be welcome
06:04:48 <lyxia> saurabhnanda: you're right
06:07:45 <lyxia> saurabhnanda: BigRecord/encode seems to be an exception, where TH is slower than generic. I'll look into it soon.
06:10:23 <tsahyt> is there some way for an IO computation to determine whether it's being run in ghci or not?
06:10:28 <merijn> If I have two variations of a recursive (monadic) function that one of which should perform some additional action, how I can I best implement this. I could put in a "when flag $ doAction" in the body, but it seems wasteful to run that conditional everytime
06:10:37 <merijn> tsahyt: Not really
06:10:39 <merijn> tsahyt: Why?
06:11:35 <tsahyt> this app I'm working on uses sqlite for the database, and by now I've started using it outside of just development on the same machine. I'd like to make sure that I don't accidentally mess up my "production" database and use a path in /tmp/ instead
06:12:14 <merijn> tsahyt: Don't hardcode the path?
06:12:32 <tsahyt> well where should it pull it from, then I still have to switch something around in a config file or something
06:12:45 <merijn> tsahyt: Hard to say, depends on the code
06:13:33 <lyxia> saurabhnanda: In principle, generic can be optimized to run as fast as TH, but we're not quite there yet. That's mostly because of compiler issues with Generic for large types.
06:13:37 <tsahyt> some way to determine whether it's a dev build or a release build would also suffice I suppose
06:13:48 <tsahyt> I could do that with CPP and cabal flags
06:13:51 <tsahyt> but that also seems terrible
06:14:08 <cocreature> tsahyt: default to /tmp unless ENV=production is set or something like that
06:15:04 <tsahyt> ENV=production as in environment variable?
06:15:13 <cocreature> yep
06:15:47 <lyxia> merijn: if the flag is static, inlining should to the job with "when flag $ doAction"
06:16:13 <tsahyt> hm, if I can set environment variables in a .desktop file I suppose that'd work too
06:16:25 <lyxia> and if it's dynamic, it can be pinned down by pattern matching on it.
06:16:45 <merijn> lyxia: It's a function defined in a let block of another function. The flag is defined in the surrounding function, so stack for each let
06:16:59 <merijn> lyxia: Yeah, but I don't want to define the same function body twice if possible
06:16:59 <cocreature> tsahyt: not sure about that but in the worst case you could just make a oneline script that sets the env var
06:17:16 <merijn> lyxia: Any idea whether GHC will float that conditional out to the outer function for me?
06:24:54 * hackagebot cpsa 3.4.0 – Symbolic cryptographic protocol analyzer – https://hackage.haskell.org/package/cpsa
06:28:03 <lyxia> It seems unlikely. I'm not sure.
06:29:17 <Psybur> What do you guys think of scalaz?
06:30:12 <saurabhnanda> merijn: lts 9/ ghc 8.0.2
06:30:24 <merijn> Psybur: Scala is the only language I've ever heard Haskellers call "too difficult", so...
06:30:52 <merijn> saurabhnanda: Like I said, it actually stores the file path. The Show instance for IOError just doesn't render it
06:30:55 <jd823592> hi, when I pipe the output of a haskell program into less and then terminate less before all output is processed, the haskell program crashes with broken pipe (which is ok i guess) but my terminal is messed up, i see nothing I type, the shell continues to accept my commands, but i can't see any keystroke, how can i recover from this without killing the particular tty and restarting?
06:31:14 <Psybur> Interesting. Im actually referring to scalaz, which is Scala + things like monads/functors :D
06:31:31 <ystael> jd823592: the shell command `reset` will typically reset your terminal settings and return you to sanity
06:31:32 <saurabhnanda> tsahyt: we're using an APP_ENV environment variable for this.
06:31:34 <Psybur> I find scala easier than haskell D;
06:32:00 <byorgey> Psybur: my impression is that if you find yourself in the unfortunate situation of having to write scala, then scalaz can at least make it bearable ;-)
06:32:05 <jd823592> ystael: great, funny i never needed that command before, thanks a lot
06:32:15 <merijn> jd823592: Run "stty sane"
06:32:18 <saurabhnanda> tsahyt: you want to find the server's environment or **Specifically** if you're inside GHCi
06:32:34 <hodapp> mleh. Scala got me to learn Haskell, but the design a lot of things made no sense until I encountered them in Haskell.
06:32:40 <saurabhnanda> merijn: what's the best way to raise this PR against the Show instance?
06:32:56 <jd823592> Psybur: easier in that it can be used, not easier in the sense you can easily tell what a program does, right?
06:32:58 <merijn> saurabhnanda: File a ticket on the GHC Trac, probably
06:33:13 <byorgey> goodness. In scalaz, "Apply[Option].apply2(some(1), some(2))((a, b) => a + b)" is the way you write "liftA2 (+) (Just 1) (Just 2)"
06:33:22 <merijn> You can also attach a patch with a better one to that if you wanna speed up how soon it's fixed
06:33:25 <Psybur> jd823592, I suppose yes due to implicits
06:33:41 <merijn> saurabhnanda: https://ghc.haskell.org/trac/ghc/
06:33:46 <Psybur> Thats the part that I still struggle with :D
06:33:48 <hodapp> byorgey: It's Still Shorter Than Java(tm)?
06:34:48 <Psybur> > (+) <$> (Just 1) <*> (Just 2)
06:34:50 <lambdabot>  Just 3
06:35:11 <Psybur> Thats even shorter than liftA2 right :D?
06:35:36 <Psybur> > liftA2 (+) (Just 1) (Just 2)
06:35:38 <lambdabot>  Just 3
06:35:39 <Psybur> Actually no :D
06:35:44 <jd823592> Psybur: I mean more like any kind of guarantees, not that haskell enforces laws or anything, but scala can still run arbitrary java garbage, I only started looking into scala and I am so disgusted with it :)
06:35:49 <Psybur> One character less!
06:36:26 <Psybur> jd823592, I'm stuck with the JVM though. Big data shop here. Aka spark/mapreduce :D
06:36:50 <mnoonan> Psybur, not if you dump the parens from your <$> version :)
06:36:59 <Psybur> Even simple things like destructuring in pattern matching blew my colleagues' heads D:
06:37:08 <tsahyt> saurabhnanda: just some way to differentiate between dev and production environment. I settled with an environment variable.
06:37:17 <saurabhnanda> tsahyt: yup, that's what we do.
06:37:22 <merijn> Psybur: Parens around Just 1 and Just 2 are redundant there
06:37:25 <hodapp> Psybur: https://github.com/tweag/sparkle isn't good enough for you?!
06:37:32 <hodapp> disclaimer: have never used it.
06:37:41 <tsahyt> it's also actually not running on a server, since it's a GUI desktop app for my personal use
06:37:42 <Psybur> hodapp, I'm taking baby steps :D
06:37:44 <tsahyt> but that's as an aside
06:37:57 <tsahyt> though that's also what makes this necessary since I develop and use it on the same machine
06:38:07 <hicksy> Hi i am getting "Could not find module", "There are files missing in the base-4.10.0.0 package" all of a sudden, never seen this before. Any ideas how to fix this?
06:38:07 <saurabhnanda> merijn: it seems the show instance has the filename
06:38:11 <Psybur> Just giving them the FP tip with a bit of plain scala and it doesnt seem to be going too well haha
06:38:45 <Psybur> Turning a while loop into a tail recursive function was fun too xD
06:38:51 <saurabhnanda> merijn: https://gist.github.com/saurabhnanda/1bc83faccfcf664bc5da9ec945a6c567
06:38:52 <hodapp> I would have figured if they already use Spark that they'd have seen Scala
06:39:04 <Psybur> hodapp, thats whay I thought too, but they used the Java API D:
06:39:09 <hodapp> gaack
06:39:30 <Psybur> I use Scala, never understood why they dont at least like type inference
06:39:49 <jd823592> Psybur: I understand why scala gets picked up by programmers
06:41:16 <maerwald> I don't understand it
06:41:47 <maerwald> I could understand why people pick up Frege
06:41:50 <hodapp> being an FP person and having to write Java is a good way to start understanding the point of Scala
06:42:02 <maerwald> Scala is FP?
06:42:13 <Psybur> maerwald, idiomatic Scala is
06:42:16 <maerwald> I don't view it that way
06:42:34 <Psybur> Its not pure thought. You can get laziness with Streams
06:42:35 <hodapp> maerwald: it's more that it's closer to FP than Java
06:42:38 <Ojd> hello all, has anyone played with the plot library?
06:42:57 <maerwald> it has a different feature set than Java, mostly confused, not really related to FP, accidentially maybe in some cases, in others not
06:43:28 <merijn> Ojd: A little bit, once upon a time
06:43:39 <hodapp> it's meant to interface with Java libraries though
06:43:47 <maerwald> you can have that with Frege too :)
06:44:02 <saurabhnanda> does servant force clients to send an application/json header for JSON endpoints? otherwise the routing layer itself throws a 404
06:44:03 <saurabhnanda> ?
06:44:08 <hodapp> yeah, but Frege is a good bit newer and less-supported
06:44:27 <Psybur> maerwald, but including Java/Scala libraries in Frege looks ugly, at least from what I encountered in my skimming of it
06:44:42 <Psybur> maerwald, and what do you think of Eta vs Frege?
06:44:48 <Ojd> merijn, would you mind talking about it?
06:44:53 <Ojd> how did you like it?
06:44:54 <jd823592> maerwald: it tries to be functional to some extent, but I'd say it is just a desperate attempt at best, I guess people have a hard time realizing that building on Java is not a good thing, but you know how people have a hard time parting with the large number of libraries etc
06:44:59 <Psybur> From what Ive seen the eta community seems more active
06:45:28 <hodapp> jd823592: it's not so much a psychological thing as that sometimes it's just not really an option to leave the JVM.
06:45:30 <merijn> Ojd: It'd probably help to ask any specific question you have. It was fairly easy to do simple plots, but I ended up sticking with my old plotscripts due to not supporting textures for bar plots
06:45:44 <Ojd> (I am looking for something to use during my next ML course)
06:45:53 <hodapp> jd823592: also, the JVM legitimately *is* a very stable and well-tested platform on which to host sometihng.
06:46:03 <maerwald> jd823592: Scala to me is the C++ of the Java world. Desoriented feature-creep without focus, but you can do whatever you want, if you know how.
06:46:29 <hodapp> Ojd: hm, last time I did ML stuff in Haskell I feel like I just used the gnuplot bindings
06:47:02 <hodapp> also, found a bug in hmatrix-glpk, but that's another matter
06:47:34 <jd823592> hodapp: JVM is also one of the most bloated unprincipled uninteresting platform out there
06:48:12 <jd823592> maerwald: i wouldn't be that harsh with C++, yes it is all the things you said but scala seems worse to me
06:48:47 <merijn> Ojd: For simplish plots it works easy enough
06:49:03 <merijn> Ojd: Started breaking down when I started to try plotting 10 million+ points, though...
06:49:07 <hodapp> jd823592: I don't know about "most bloated"; that may have applied in the 2000s, but for long-running servers, it doesn't appear to hinder anyone except in the cases of really elephantine conglomerations like IBM WebSphere Application Server
06:49:08 <merijn> Oddly enough ;)
06:49:10 <merijn> gah
06:49:46 <hodapp> jd823592: Not even sure what "unprincipled" means in this context. "Uninteresting", when the platform is supposed to be stable, is something of an asset.
06:49:46 <Ojd> ok, I will take a look at the gnuplot
06:50:41 <Psybur> Anybody ever plugin Frege or Eta into an existing Java gradle project? :D
06:50:49 <Ojd> I am really new to haskell (I haven't completed the chapter about monads yet), but I managed to read a csv file and prepare the vectors to plot
06:50:49 <Psybur> Thats how Ive been sneaking scala in at work xD
06:50:56 <jd823592> hodapp: it can be stable and do something useful beyond eating your memory and freezing your cpu with gc :)
06:51:03 <Psybur> Would love to see peoples faces if they stumbled upon some haskell
06:51:06 <maerwald> it would be interesting if it had a formal memory model and have it verified
06:52:19 <hodapp> jd823592: the memory usage of the VM itself is restricted in particular ways, particularly, capped by default; it has been this way for quite awhile.
06:52:48 <maerwald> but then again, GHC doesn't have it either
06:53:23 <hodapp> jd823592: have yet to see GC actually cause any problems in this space besides people whining about it. People don't generally write hard real-time software in anything with GC.
06:53:24 <jd823592> hodapp: i know i am forced to use java too, and i know how easy it is to hit that limit
06:54:40 <hodapp> if you're hitting it that quickly, you're typically leaking resources or something.
06:55:46 <jd823592> hodapp: or doing legitimate memory heavy stuff
06:55:48 <hodapp> maerwald: what sort of things do have formal memory models? are the memory models themselves verified or are you talking about the compiler?
06:56:14 <maerwald> you verify the model and the implementation of it, sure
06:56:17 <hodapp> jd823592: so you're using large amounts of memory... and complaining that using large amounts of memory results in large amounts of memory being used?
06:56:52 <hodapp> maerwald: what languages has this been done for?
06:57:04 <hodapp> this seems vaguely like something folks have done in SML...
06:57:23 <hodapp> maybe Ivory too (if that counts, as it's an EDSL)
06:57:33 <jd823592> hodapp: i use large amount of memory, and jvm is not good at facilitating that usage
07:00:44 <maerwald> hodapp: not sure if that is baked into any GCed language
07:01:09 <maerwald> most projects that care about those things are C projects where that is all done manually
07:01:28 <hodapp> maerwald: afaik, no dynamic memory allocator has been proven to return in deterministic time, which throws a wrench in a lot of things
07:01:38 <merijn> There's no way to have early return with foldl, is there?
07:02:40 <tdammers> sort of... you can produce results that are not interesting to the caller so that they never get evaluated
07:02:45 <tdammers> but other than that, no
07:03:02 <merijn> tdammers: But that'd still traverse the entire input, right?
07:04:08 <merijn> oh, wait, maybe I don't need early return
07:04:46 <saurabhnanda> does anyone know why the ToJSON instance for Either not use defaultOptions in the encoding? It produces a completely inconsistent JSON from what one would expect.
07:05:21 <maerwald> hodapp: it would certainly make the JVM "interesting" though ;)
07:09:24 * hackagebot pragmatic-show 0.1.0.1 – Alternative Show class that gives shorter view if possible. – https://hackage.haskell.org/package/pragmatic-show
07:23:54 <bartavelle> saurabhnanda: probably because default options are ugly (I don't like them)
07:25:01 <saurabhnanda> larger context -- https://github.com/bos/aeson/issues/590
07:25:05 <saurabhnanda> @bartavelle ^^
07:25:05 <lambdabot> Unknown command, try @list
07:30:14 <bartavelle> saurabhnanda: the elm-brdige library does parse the "options" field for aeson and generates compatible code
07:30:28 <bartavelle> saurabhnanda: the other bridge libraries should do the same
07:31:32 <saurabhnanda> bartavelle: but Either is written in a very different way on Haskell side. Is it treated as a special case in Elm?
07:31:40 <saurabhnanda> elm-bridge, that is.
07:32:52 <bartavelle> saurabhnanda: it would not work actually :) elm-bridge as a TH "deriveBoth" that derives at the same time elm and aeson code
07:33:01 <bartavelle> so that they are guaranteed to stay in sync
07:33:18 <bartavelle> but either is already derived on its own, and elm-bridge has no way of knowing that
07:37:06 <saurabhnanda> I'm a little lost now. Is Either a problem for elm as well?
07:39:52 <hicksy> sorry for asking again but didnt get a response: i am getting "Could not find module", "There are files missing in the base-4.10.0.0 package" all of a sudden, never seen this before. Any ideas how to fix this? ghc-pkg check returns: https://pastebin.com/aCmr9igi
07:41:52 <bartavelle> saurabhnanda: if you use elm-bridge, you can derive it using the same options that were used in the aeson package (using deriveElm IIRC)
07:58:48 <Psybur> Is it possible in ghci to see how instances are implemented? Like if I want to see how Maybe implements MonadPlus, can I see the code inside ghci?
07:59:40 <bartavelle> Psybur: you should have dedicated "source" links per instance on hackage now, but I don't think you can do that from ghci
07:59:49 <Psybur> ok thanks
08:01:08 <Psybur> Doesnt seem like I can expand the instances in Data.Maybe D;
08:02:03 <Psybur> http://hackage.haskell.org/package/base-4.4.1.0/docs/Data-Maybe.html#t:Maybe
08:02:41 <brynedwards> Psybur: that's base-4.4.1.0 docs, you probably want the newest one https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Maybe.html#t:Maybe
08:03:03 <Psybur> Now we're cooking with oil!
08:03:25 <Psybur> Hmm just gives the types, not the implementation
08:04:36 <locallycompact> is there a way to be able to automatically use swap :: (a,b) -> (b,a) on a newtype with a tuple inside?
08:04:54 <locallycompact> newtype Foo = Foo (Int, Int)
08:05:12 <brynedwards> Psybur: looks like it uses the implementation from Alternative, so it would be here https://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#line-772
08:05:53 <brynedwards> err, looks like I linked to the Applicative, sorry...linking the source is confusing. Anyway just search 'instance Alternative Maybe'
08:07:11 <Psybur> brynedwards, how did you get to the docs/source? Did you get there from hackage docs?
08:07:29 <Psybur> Ah I see source in the top right corner
08:07:59 <brynedwards> Psybur: yes, there are also Source links at the right side of most definitions
08:08:20 <ski> locallycompact : not sure what you mean with "automatically use .."
08:08:34 <Psybur> brynedwards, yep found them. Thanks
08:08:46 <brynedwards> ski: I assume he means not having to unwrap the newtype
08:09:07 <ski> locallycompact : if you define a lens, i think you can probably do something like "map" `swap' over a `Foo'
08:09:25 <ski> locallycompact : but perhaps you mean that you want `Foo (0,1)' and `Foo (1,0)' to be considered equal ?
08:09:40 <ski> brynedwards : maybe. i'm not sure. more clarification needed
08:11:06 <erisco> let the horse do the talking
08:11:28 * ski looks at locallycompact
08:11:36 <Psybur> brynedwards, so if I am understanding this right, MonadPlus Maybe uses the default implementation of MonadPlus, which uses Alternative
08:12:00 <dminuoso_> Is there some generic name for a function that does something along the lines of \value -> if predicate(value) then transform(value) else value ?
08:13:37 <brynedwards> reminds me of guard
08:13:38 <erisco> yes
08:14:56 <ski> i've seen `cond predicate consequent alternate x = if predicate x then consequent x else alternate x'
08:15:12 <Athas> I note that some BSD/MIT-licensed libraries on Hackage depend on LGPL-licensed libraries.  How does that work?  This means that any executable using those libraries must have its source code made public, yes?
08:15:19 <brynedwards> Psybur: yeah that's right
08:16:09 <maerwald> (a -> Bool) -> (a -> b) -> a -> b?
08:16:45 <erisco> :t until -- not quite
08:16:46 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
08:17:08 <Tomsky> I notice there is no unsafeRunST in Control.Monad.ST.Unsafe. Do people just use unsafeSTToTIO and then unsafePerformIO on that?
08:17:27 <wz1000> :t (\p f x -> fromMaybe x $ guard (p x) >> return (f x))
08:17:29 <lambdabot> (t -> Bool) -> (t -> t) -> t -> t
08:17:50 <maerwald> you can write it with if-then-else
08:18:18 <erisco> > let f = liftA3 bool id (*2) (<3) in (f 2, f 5)
08:18:20 <lambdabot>  (4,5)
08:18:56 <dminuoso_> brynedwards: Huh, yeah actually. :-)
08:19:23 <c_wraith> Tomsky: what is the nature of the unsafety you are trying to get from ST?
08:19:47 <erisco> :t flip (liftA3 bool id)
08:19:48 <lambdabot> (d -> Bool) -> (d -> d) -> d -> d
08:20:29 <maerwald> dminuoso_: I'd call the function "ifThen", because "else" basically does "nothing"
08:21:30 * hackagebot ngx-export 0.8.0.0 – Helper module for Nginx haskell module – https://hackage.haskell.org/package/ngx-export
08:22:41 <mnoonan> Tomsky, what do you want it to do that runST doesn't?
08:24:59 <Tomsky> I'm writing something similar to runSTUArray but is runSTUHashTable. Where is uses (several) unboxed arrays to implement the HashTable. As with STUArray the idea is that it is mutable inside the ST monad but is returned immutable from runSTUHashTable
08:25:44 <Tomsky> runST would make a copy, which is unnecessary since I can use the Rank2Type restriction to prevent modification outside of the ST monad ...
08:26:29 <c_wraith> The unsafety issue you would need to face is that you lose serial guarantees when you leave ST
08:27:41 <c_wraith> You wouldn't have a persistent data structure, but GHC would think it was one.  Its optimizations could easily break things in amazing ways.
08:28:42 <Tomsky> It doesn't need to be persistent, as I say it's immutable once it leaves the ST monad. It is really nothing more than a reworking of runSTUArray into a HashTable.
08:28:57 <c_wraith> So you'd never need to bring it back into ST?
08:29:25 <Tomsky> correct
08:29:41 <c_wraith> seems like runST should be fine, then
08:30:05 <c_wraith> runSTUArray is just a helper function.  It wraps runST to make some uses cases easier.
08:30:16 <c_wraith> You could write your own wrapper using runST
08:31:07 <Tomsky> Right except runST will force you to make a copy :-) runSTUArray gets around that with unsafeFreeze.
08:31:37 <c_wraith> you can call unsafeFreeze.  It's fine as long as you don't mutate the source afterwards
08:34:20 <c_wraith> Do you have a bunch of STRefs around too?  Those would force some degree of copying to remove.
08:35:39 <Tomsky> I could indeed, although you either end up duplicating the HashTable lookup code for both UArray and STUArray ... or praying to the Haskell gods that GHC will in fact remove the dictionaries and specialise out the IArray properly.
08:36:43 <c_wraith> You'd need to have two versions of the code and the data structure, really.
08:37:32 <Tomsky> Yeah or you can use STUArray (or IOUArray) throughout and take the burden of proof that you don't mutate it with unsafePerformIO.
08:38:06 <Tomsky> Probably duplicating the code is going to be easiest ... even though I hate duplicating code :-)
08:38:35 <c_wraith> consider this:  IArray and MArray exist, despite having the same underlying structure.
08:38:57 <c_wraith> Or, you know.  despite instances of it having the same underlying structure.
08:39:23 <erisco> uh… damn… ghci is borked with ghc 8.2.1 on Windows
08:39:25 <erisco> up arrow breaks it
08:40:10 <c_wraith> well.. best remove the up arrow from your keyboard.
08:40:14 <Tomsky> c_wraith: true enough, thanks for your thoughts :-)
08:40:37 <erisco> that's how I get back to previous commands…
08:41:20 <c_wraith> ...  I may have just read a story about bank employees removing the F1 key from their keyboard because they would often hit it accidentally, and then have to wait for a very slow "help" system to chug open before they could close it.
08:46:43 <Psybur> What do you guys think about STM? Is it worth looking into?
08:46:49 <nisstyre> yes
08:47:09 <nisstyre> it's mature and reliable
08:47:20 <nisstyre> maybe not the lowest overhead though
08:47:42 <Psybur> There are alternatives? Possibly better?
08:48:04 <cocreature> STM is awesome, you should definitely look into it
08:48:29 <nisstyre> Psybur: it depends on what you want to do with it
08:48:35 <terrorjack> if you don't need on-disk persistence or multi-node syncing then stm is good
08:49:00 <nisstyre> check out this http://chimera.labs.oreilly.com/books/1230000000929/index.html
08:49:20 <nisstyre> specifically the concurrency half of the book
08:49:28 <cocreature> https://www.microsoft.com/en-us/research/publication/beautiful-concurrency/ is also worth a look
08:49:44 <nisstyre> the async module is also really handy
08:50:12 <nisstyre> Simon Marlow is the author of async as well
08:50:18 <nisstyre> didn't even realize that
08:50:36 <nisstyre> mapConcurrently is like magic
08:50:51 <Psybur> Will check them out. Thanks
08:51:15 <Tomsky> What are you trying to do Psybur?
08:51:46 <Psybur> Tomsky, I just stumbled across it and it seemed worth knowing :D
08:51:51 <Psybur> STM that is
08:51:58 <nisstyre> it is, but it's easier to learn if you have a specific project in mind
08:52:11 <nisstyre> the boring stuff like dining philosophers or w/e only gets you so far
08:52:26 <Tomsky> Ah, yes STM is definitely worth knowing about :-)
08:52:38 <Psybur> Have you guys ever had to use it?
08:52:40 <Tomsky> If you're interested in concurrent algorithms.
08:52:43 <nisstyre> I've used it
08:52:57 <Psybur> nisstyre, have you happened to blog about it? :D
08:53:01 <nisstyre> no, sorry
08:53:03 <nisstyre> maybe I will though
08:53:09 <erisco> ah it isn't the up arrow it is the ctrl+c
08:53:24 <erisco> how do I abort a program in ghci without ctrl+c then
08:53:24 <nisstyre> I've actually been learning Elixir lately, which is another language that does concurrency really well
08:53:31 <nisstyre> but it's very different (actor model)
08:54:10 <terrorjack> haskell has actors as well
08:54:19 <nisstyre> different from STM I mean
08:54:21 <terrorjack> distributed-process
08:54:26 <terrorjack> yup
08:54:27 <nisstyre> they use something called OTP
08:54:41 <nisstyre> Open Telecom Protocol
08:54:47 <nisstyre> *Platform
08:55:01 <hodapp> yeah, Elixir inherits a lot of stuff from running on Erlang'sVM
08:56:21 <terrorjack> if ghc got an erlang backend, can we have a magical forkIO which spawns to another node?
08:56:39 <Tomsky> terrorjack: see Cloud Haskell :-)
08:56:56 <Tomsky> http://haskell-distributed.github.io/
08:57:09 <Tomsky> It basically is Erlang style concurrency for Haskell.
08:57:17 <terrorjack> in cloud haskell we're stuck with Typeable Binary messages
08:58:28 <Tomsky> True enough, but I still prefer to Erlang because I like static types. So can't complain too much :-)
09:00:25 <hodapp> eh? Erlang doesn't have static types
09:00:38 <terrorjack> in scala/akka you can enjoy the jvm's default serialization for closures. first class closures dude
09:01:27 <Tomsky> hodapp: I still prefer Haskell to Erlang :-)
09:01:28 <terrorjack> although when you capture something not serializable, debugging hurts a lot since you're not backed by the types
09:01:55 <Tomsky> terrorjack: Yeah Cloud Haskell also has serializable closures, as I understand it.
09:02:29 <terrorjack> serializable closures are implemented with static pointers
09:02:35 <terrorjack> so pretty limited
09:03:19 <iqubic> terrorjack:
09:03:25 <Tomsky> True enough, swings and roundabouts I guess. Personally I prefer the strong types and have a bit more serialization code.
09:04:55 <terrorjack> the story of serialization gets a lot better with compact regions. but still you can't stuff a closure in a Compact
09:06:20 <iqubic> hodapp: that is the main reason I stopped doing erlang development and switched to Haskell. Lack of static types. Haskell has such a strong type system that will help you sanity check your programs.
09:08:03 <terrorjack> i prefer haskell too, because i prefer "no instance" compile errors to "not serializable" runtime exceptions :)
09:09:38 <iqubic> Compile errors are a lot easier to work with.
09:10:46 * hackagebot pragmatic-show 0.1.0.2 – Alternative Show class that gives shorter view if possible. – https://hackage.haskell.org/package/pragmatic-show
09:14:38 <amf> given a type where ive defined `Iso' A B` (and the functions to convert); how to do actually convert between one and the other? i know its some simple function, but im lost in the sea of lenses
09:15:02 <amf> oh hah. its just `view`
09:15:46 <c_wraith> the relative scarcity of types in Erlang does make some things easier.  I've done work with hot code swapping in Haskell.  If the interface to the code being swapped involves moving values of custom types around, it gets *really* hard to work with.  Type checks fail, there are lots of changes that you just can't swap in.  In Erlang, you maybe have a runtime error, and you can write the new code such that it handles either the old or the new representation
09:15:46 <c_wraith> .
09:16:32 <c_wraith> You could achieve that same flexibility in Haskell, but it means you have to nail down your interface types in such a way as to make them external to your system essentially. 
09:18:37 <c_wraith> This isn't to call types bad in any way - just to point out that weaker types allow you to ignore some really hard engineering tasks occasionally.  Instead of needing to create a complex, forward-looking schema, everything is just a value.
09:19:37 * hackagebot docker 0.4.0.2 – An API client for docker written in Haskell – https://hackage.haskell.org/package/docker
09:20:33 <c_wraith> the interesting thing about that is that the breakdown occurs precisely where things that Haskell assumed were internal interfaces suddenly became external interfaces. Erlang treats *everything* as much closer to an external interface.
09:23:33 <kuribas> > 1 @ Int
09:23:36 <lambdabot>  <hint>:1:3: error: parse error on input ‘@’
09:24:11 <kuribas> c_wraith: that's why people love python
09:24:35 <iqubic> kuribas: python basically has no types.
09:24:35 <Tomsky> c_wraith: Agreed, types can be a pain at times, but overall IMO they are worth it for most large pieces of code.
09:24:53 <kuribas> iqubic: sorry, I didn't read the backlog :)
09:26:27 <iqubic> Tomsky: and I have seen crazy things done with Haskell types. Someone solved the 8 queens puzzle using only Haskell type system. To get the answer, he just fired up the repl and typed ":t Solution"
09:26:56 <iqubic> And also, he used no built in functions at all. Only types and typeclasses.
09:27:08 <Tomsky> iqubic: Yeah type level programming is kinda scary :-)
09:27:38 <iqubic> https://aphyr.com/posts/342-typing-the-technical-interview
09:27:48 <iqubic> That's the article he wrote about it.
09:28:16 <iqubic> The types just work themselves out to an answer all on their own.
09:28:53 <kuribas> in dependend typing the distinction between type level and value level computation goes away (as I understand it)
09:30:11 <Tomsky> kuribas: it's kinda the same with type level programming in Haskell since even Haskell 98's type system is apparently Turing complete. 
09:30:37 <Tomsky> But dependent typing does turn it all up to 11 ...
09:31:13 <kuribas> Tomsky: yeah, but in idris it uses the same language
09:32:24 <Tomsky> *nods* one of my coworkers used to teach Idris to undergraduates.
09:33:09 <royal_screwup21> I'm trying to write a function that removes the kth number in a list https://thepasteb.in/p/nZhlNVk6BLkCY I got an error https://thepasteb.in/p/xGhmojzQYkMTM and googling for it didn't get me very far. Where am I going wrong?
09:34:46 <geekosaur> first obvious thing is you need parentheses
09:34:49 <geekosaur> (index-1)
09:35:24 <royal_screwup21> ahh yes thank you!
09:35:30 <geekosaur> function application is higher precedence than any operator, so what you wrote parses as (remove ys index) - 1
09:35:47 <royal_screwup21> I wish the errors were a little hairy :(
09:36:11 <royal_screwup21> by errors, I mean the traceback...is that the right term?
09:36:31 <kuribas> c_wraith: after programming two weeks without types in an unknown codebase, I really miss static types.
09:36:34 <royal_screwup21> little less**
09:37:36 <geekosaur> sometimes polymorphism does lead to difficult error messages. problem is, sometimes oddball Num instances are actually useful, so teaching the compiler "that doesn't make sense as a number" would be too limiting
09:38:36 * hackagebot vector-builder 0.3.3.1 – Vector builder – https://hackage.haskell.org/package/vector-builder
09:38:37 * hackagebot tree-diff 0 – Diffing of (expression) trees. – https://hackage.haskell.org/package/tree-diff
09:38:49 <Tomsky> royal_screwup21: something that really helps Haskell give better error messages is to write top-level type signatures.
09:38:56 <geekosaur> so then the compiler chokes on a language standard-imposed limitation on a different aspect of polymorphism, which is annoying
09:39:04 <Tomsky> In your remove example: 
09:39:24 <geekosaur> (one which is often too limiting so there's an extension to turnit off... but that would just make the error messages even more opaque)
09:40:04 <Tomsky> remove :: [a] -> Int -> [a]
09:40:12 <Tomsky> would help a lot (it's not the most general type, but it'll do for now)
09:42:27 <cmotoche> Is the FromJSON and ToJSON instance for ZonedTime isometric? I'm adding a property test for a type that is a Wrapper of ZonedTime (ZonedTimeStamp defined on PostgreSQL Simple) and it fails in the first test because it encodes a ZonedTime like this: "1864-05-09 05:44:07.889375238804 REJO" but the decoding returns something like this: "1864-05-09 05:44:07.889375238804 -1157"
09:44:35 <geekosaur> the difference is in the part that is not reliably reversible
09:44:36 <c_wraith> Oh, I much prefer Haskell to Erlang/elixir. I just envy the OTP. cloud haskell still has a long way to go, because it's just a harder problem.
09:44:45 <geekosaur> timezone names are duplicated, have overlaps, etc.
09:45:28 <geekosaur> you should not expect them to round trip, in fact whenever possible you should avoid them
09:45:53 <cmotoche> Then I'll do a `fmap zonedTimeToLocalTime` to make the tests pass. Thanks geekosaur 
09:46:05 <Tuplanolla> When you don't have inverses (`f . g = id` and `g . f = id`), you might still have generalized inverses (`f . g . f = f` and `g . f . g = g`), cmotoche.
09:47:54 <Sornaensis> is haskell the prettiest language?
09:48:25 <maerwald> ?
09:48:33 <Tuplanolla> No, Sornaensis.
09:48:55 <Sornaensis> oh, okay
09:49:00 <Sornaensis> thanks
09:49:01 <geekosaur> define 'prettiest'
09:49:02 <maerwald> is fish the most delicious dish?
09:50:07 <iqubic> I want to learn more about type level wizardry. Where can I go to do that?
09:50:16 <Sornaensis> google
09:50:22 <maerwald> -.-
09:51:26 <Tuplanolla> Regardless of your sense of aesthetics, there is probably something better, because Haskell is big and old.
09:52:20 <`Guest00000> iqubic: google dependent types
09:53:27 <Tomsky> I don't know if Haskell is the prettiest, but it is pretty good IMO. The syntax is well thought out.
09:53:50 <maerwald> there is practically zero style consistency
09:54:05 <maerwald> you want something like python with a maximum indentation level or so
09:54:20 <iqubic> Tomsky: it has no commas. It is good in that way.
09:54:32 <maerwald> sure it has :>
09:54:39 <dysfun> does python have a maximum indentation level?
09:54:42 <`Guest00000> (,,,,,,,,,,)
09:54:49 * dysfun never noticed it
09:54:55 <maerwald> dysfun: no
09:55:08 <maerwald> but that would be appropriate
09:55:29 <`Guest00000> what reason would be there for including a maximum indentation level?
09:55:38 <dysfun> to stop people getting ahead of themselves
09:55:50 <maerwald> well, prettiness for one thing and intellectual complexity for another
09:56:11 <maerwald> if you have indentation level of 12 you have basically 12 different contexts you have to think about
09:56:53 <`Guest00000> maerwald: but they are nested in a way
09:57:00 <`Guest00000> so it's not that complex
09:57:04 <maerwald> huh?
09:57:07 <maerwald> sure it is
09:57:08 <`Guest00000> they aren't completely different
09:57:14 <maerwald> wat?
09:57:18 <`Guest00000> not like 12 different functions
09:57:32 <maerwald> I am aware those are not 12 different functions, which is the whole point
09:57:46 <maerwald> scope
09:59:39 <maerwald> in haskell, you could do something similar, it's not indentation but let/where with 20+ different local definitions, none of them properly documented and ad-hoc with weird inter-dependencies
10:01:52 <Tuplanolla> @let never = case do not otherwise of such -> let in when such
10:01:54 <lambdabot>  Defined.
10:02:32 <c_wraith> :t such
10:02:33 <maerwald> perfect example: https://git.io/vdfp7
10:02:34 <lambdabot> error:
10:02:34 <lambdabot>     • Variable not in scope: such
10:02:36 <lambdabot>     • Perhaps you meant ‘succ’ (imported from Prelude)
10:02:39 <maerwald> scope overload
10:02:48 <byorgey> Tuplanolla++
10:02:48 <maerwald> 220+ LOC
10:03:10 <c_wraith> Oh, there it is. too many things.
10:03:14 <maerwald> impossible to see control flow, context or logical pieces
10:03:18 <monochrom> Ah! So, best of both worlds: Cap indentation, but don't cap nesting depth. >:)
10:03:21 <maerwald> similar to high indentation level
10:04:56 <maerwald> also, the whole function lives in IO :>
10:05:41 <monochrom> :type never
10:05:50 <monochrom> @type never
10:05:51 <lambdabot> Applicative f => f () -> f ()
10:08:34 <`Guest00000> maerwald: i would suggest isolating those let blocks inside of nested do blocks, then returning needed values from inner do blocks to outer do
10:08:57 <maerwald> `Guest00000: I suggest to rm -rf the whole module and rewrite it
10:09:05 <byorgey> > never (Just ())
10:09:07 <lambdabot>  Just ()
10:09:40 <iqubic> What does never do?
10:09:51 <byorgey> iqubic: it doesn't
10:09:58 <monochrom> Hehehe
10:09:59 <Tuplanolla> :t never (print "anything")
10:10:01 <lambdabot> IO ()
10:10:25 <iqubic> > never $ Left ()
10:10:27 <lambdabot>  Right ()
10:10:32 <iqubic> What?
10:10:33 <`Guest00000> why `f () -> f()`? could be `f a -> f ()`
10:10:35 <maerwald> `Guest00000: since I'm basically solving a similar problem I know what the solution is. You need more (intermediate) data structure and have atomic conversions from one to another. This functions tries to do a HUGE transformation in one blow. That cannot ever go right
10:10:49 <byorgey> > never [(), (), ()]
10:10:51 <lambdabot>  [()]
10:10:57 <iqubic> > never Right ()
10:10:59 <lambdabot>  error:
10:10:59 <lambdabot>      • Couldn't match type ‘Either a0 ()’ with ‘()’
10:10:59 <lambdabot>        Expected type: () -> ()
10:11:25 <iqubic> > never $ Right ()
10:11:27 <lambdabot>  Right ()
10:11:38 <iqubic> Huh, why does it do that?
10:11:38 <byorgey> `Guest00000: that would require a bit more code, it wouldn't read as nicely =)
10:11:41 <monochrom> @type when
10:11:43 <lambdabot> Applicative f => Bool -> f () -> f ()
10:12:03 <byorgey> iqubic: go study the implementation and read up on Applicative.
10:12:27 <iqubic> I know what Applicatives are.
10:12:27 <byorgey> and think about the Applicative instances for each of the types used as examples
10:12:39 <iqubic> I just don't know what never does.
10:12:54 <iqubic> > never Nothing
10:12:56 <lambdabot>  Just ()
10:13:23 <iqubic> Oh, it only gives you the "positive" form of the applicative.
10:13:43 <`Guest00000> maerwald: but you don't need -r in rm...
10:13:43 <byorgey> iqubic: Applicatives don't have positive and negative forms.
10:14:08 <`Guest00000> byorgey: define positive form = the form of `return`
10:14:19 <maerwald> `Guest00000: lol
10:14:39 <iqubic> Oh, yeah that makes sense. Now, why is that even a thing?
10:14:44 <byorgey> `Guest00000: I'd rather not, thanks =)
10:14:53 <nshepperd> if you say the wrong thing, define the wrong thing as the right thing
10:14:56 <maerwald> `Guest00000: you don't even need -f :P
10:15:23 <byorgey> iqubic: I happen to personally know that Tuplanolla typed it specifically in order to confuse you
10:15:56 <iqubic> Really? Why would they do that?
10:16:00 <byorgey> iqubic: (you did see that Tuplanolla defined it with a @let ?  It is not in any standard library.)
10:16:08 <byorgey> iqubic: (also, I am joking.)
10:16:36 <`Guest00000> maerwald: well, when you have alias rm="rm -i", you do
10:16:52 <maerwald> :>
10:17:05 <Tuplanolla> If only we had `ArgumentDo` so that I could also say `don't do`.
10:17:08 <byorgey> (12:01) <Tuplanolla> @let never = case do not otherwise of such -> let in when such
10:17:26 <byorgey> it is a nice exercise in Haskell syntax corner cases to figure out exactly how this works
10:17:39 <nshepperd> hehe
10:17:49 <monochrom> data MyFreeMonadForSteamRating a = Negative | Positive a | Mixed (Bool -> MyFreeMonadForSteamRating a) | OverwhelminglyPositive String (MyFreeMonadForSteamRating a)
10:17:51 <Tuplanolla> Also `runST do` without having to touch `$`.
10:18:19 <maerwald> you people are evil
10:18:24 <`Guest00000> > do False
10:18:26 <lambdabot>  False
10:18:37 <byorgey> monochrom: oh look, an Applicative with positive and negative forms!  I stand corrected.
10:19:03 <iqubic> Never confuses me when I look at the implementation.
10:19:07 <`Guest00000> bbut
10:19:18 <`Guest00000> > do x <- False; True
10:19:20 <lambdabot>  error:
10:19:20 <lambdabot>      • Couldn't match expected type ‘m a0’ with actual type ‘Bool’
10:19:20 <lambdabot>      • In a stmt of a 'do' block: x <- False
10:19:45 <`Guest00000> why do we need desugar `do a :: a` to `a :: a`?
10:19:56 <c_wraith> `Guest00000, that's just because do notation doesn't imply any typing rules.
10:19:58 <monochrom> Why not.
10:20:11 <`Guest00000> very funny
10:20:24 <c_wraith> `Guest00000, what matters is the inferred type of the expression after desugaring
10:20:29 <`Guest00000> do not otherwise
10:20:34 <byorgey> `Guest00000: seriously, because do-desugaring is defined recursively on syntax, and what else would you have as the base case?
10:20:48 <monochrom> For that matter you may as well question allowing "let in".
10:20:49 <`Guest00000> blablabla
10:21:03 <byorgey> having 'do a' desugar to anything other than 'a' would be a weird special case.
10:21:09 <`Guest00000> yeah, i question it even more
10:21:09 <maerwald> let's make a pure haskell: no sugar, no GHC extensions and a maximum amount of local let/where definitions
10:21:18 <`Guest00000> sugar-free
10:21:28 <iqubic> monochrom: what variable does "let in" bind?
10:21:38 <`Guest00000> none
10:21:40 <`Guest00000> hahaha
10:22:32 <c_wraith> > let 3 = 5 in 3 + 3
10:22:34 <lambdabot>  6
10:22:55 <c_wraith> allowing that annoys me more than allowing an empty let
10:23:00 <maerwald> when you exceed the maximum allowed number of local definitions, the compiler will error out with "are you sure you are writing haskell?"
10:23:01 <iqubic> Why is never defined with a case statement.
10:23:19 <geekosaur> just to maximize syntactic abuse? :p
10:23:23 <nshepperd> > do do do "duum"; do do do "duum"
10:23:25 <lambdabot>  "duumduumduumduum"
10:24:08 <`Guest00000> i tried searching "obfuscated haskell", i didn't find anything especially meaningful as haskell code
10:24:13 <maerwald> syntactic abuse will be punished by the compiler. It will remove your source files
10:24:24 <`Guest00000> pun unavoidable, but not intended
10:24:32 <iqubic> Why are you trying to find edge cases in the Haskell syntax?
10:24:32 <c_wraith> nah, that bug was fixed.
10:24:41 <`Guest00000> maerwald: will format your hard drive
10:24:45 <maerwald> :D
10:24:59 <maerwald> with reiserfs and compile the kernel module beforehand
10:25:02 <iqubic> :t never
10:25:03 <lambdabot> Applicative f => f () -> f ()
10:25:06 <Liskni_si> c_wraith: case trace "x" 5 of ~3 -> () ;-)
10:25:16 <kuribas> you can implement the list monad with the continuation monad, right?
10:25:23 <Liskni_si> s/()/3+3/
10:25:30 <`Guest00000> hmmmmmmm
10:25:43 <iqubic> Where the hell does the applicative constraint of never come from?
10:25:44 <`Guest00000> regarding never/when and on
10:25:56 <geekosaur> :t when
10:25:57 <nshepperd> :t when -- iqubic 
10:25:58 <lambdabot> Applicative f => Bool -> f () -> f ()
10:25:59 <lambdabot> Applicative f => Bool -> f () -> f ()
10:26:03 <nshepperd> heh
10:26:03 <iqubic> Oh.
10:26:04 <texasmynsted> Howdy Haskellers 
10:26:08 <c_wraith> `Guest00000, there was a short period of time many years ago when ghc (on one platform only, iirc) actually did delete all your source files if you had a type error.
10:26:15 <Tuplanolla> Now consider `module AncientGreekPhilosophy where Nothing = Nothing`.
10:26:40 <maerwald> is there something you cannot do with the continuation monad? :>
10:27:03 <c_wraith> implement MonadControl
10:27:03 <kuribas> but I am having trouble implementing it...
10:27:09 <Tuplanolla> You can tell Haskell is a very powerful language since it can express such deep concepts.
10:27:09 <`Guest00000> what if we had a language which defers specialization until application, so that `when True :: m a -> m a`, but `when False :: m a -> m ()`
10:27:18 <iqubic> case do false of such -> when such
10:27:23 <`Guest00000> can we have it? if we can, is it bad?
10:27:27 <iqubic> That is a start to making it simpler.
10:27:39 <iqubic> @src when
10:27:39 <lambdabot> when p s = if p then s else return ()
10:27:42 <`Guest00000> @let false = False
10:27:44 <lambdabot>  Defined.
10:28:07 <c_wraith> `Guest00000, you can do that with dependent types. I'm not sure it makes anything better.
10:28:13 <`Guest00000> it does
10:28:14 <monochrom> "when True :: m a -> m a" and "when False :: m a -> m ()" sounds like dependent typing.
10:28:38 <`Guest00000> okay
10:28:40 <iqubic> Sure does.
10:28:51 <Tuplanolla> Congratulations, you now have type erasure problems, `Guest00000.
10:28:55 <c_wraith> `Guest00000, well, it really doesn't. to know the return type, you need to case match the boolean.
10:28:55 <maerwald> I hope haskell will never get working dependent types or no one will use them
10:29:11 <texasmynsted> heh
10:29:12 <`Guest00000> wellll
10:29:19 <`Guest00000> okay, to erase xomplexit:
10:29:22 <`Guest00000> complexity *
10:29:38 <`Guest00000> what if this worked only for constants
10:29:40 <monochrom> And depending typing plus "but do it during run time" sounds like dynamic typing.
10:29:40 <texasmynsted> idris
10:29:50 <iqubic> maerwald: I want them
10:29:56 <monochrom> @quote monochrom poor.man
10:29:56 <lambdabot> monochrom says: dynamic type is poor man's dependent type, they are so poor they can't buy a theorem prover.
10:29:57 <maerwald> iqubic: use Idris, Agda or F* then
10:30:10 <maerwald> don't convolute a working existing language with a concept the language was not designed for
10:30:13 <iqubic> maerwald: but I like Haskell better.
10:30:19 <maerwald> you are breaking the language
10:30:20 <`Guest00000> ^
10:30:22 <monochrom> The road to dynamic typing is paved with dependent typing and well intention.
10:30:37 <`Guest00000> (pointing to iqubic's message)
10:30:53 <Tuplanolla> I bet nLab has a rigorous definition of well-intention.
10:31:00 <monochrom> haha
10:31:06 <iqubic> Tuplanolla: what is nLab?
10:31:17 <Tuplanolla> @google what is nLab
10:31:18 <lambdabot> Plugin `search' failed with: Network.Socket.connect: <socket: 13>: does not exist (No route to host)
10:31:56 <iqubic> Looks like lambdabot has no internet.
10:31:57 <`Guest00000> can we hack lambdabot using 13
10:32:28 <iqubic> 13 what?
10:32:36 <maerwald> goats?
10:33:24 <lyxia> > 13
10:33:26 <lambdabot>  13
10:33:36 <lyxia> Did I do it
10:33:38 <maerwald> amazing, so it's a number
10:33:47 <`Guest00000> :t 13
10:33:48 <lambdabot> Num p => p
10:33:59 <texasmynsted> maybe we need Haskell-2 or something where map is replaced with fmap, String is implemented like Text, etc.
10:34:03 <texasmynsted> H++
10:34:16 <maerwald> texasmynsted: nooo! string is removed, instead there is only ByteString
10:34:17 <maerwald> :P
10:34:24 <ski> c_wraith : why does allowing empty `let' annoy you ?
10:34:31 <`Guest00000> (+ 1) H
10:34:39 <nshepperd> remove all types, there is only ByteString
10:34:42 <nshepperd> and the ffi
10:34:47 <maerwald> back to C xD
10:34:53 <`Guest00000> i'd rather remove the ByteString
10:34:59 <maerwald> everything is a char, doh
10:35:19 <texasmynsted> sigh
10:35:44 <`Guest00000> i wish ByteString, Text, etc. were invisible
10:35:58 <texasmynsted> H++ , Text, map replaced with fmap, dependant types, all source files removed on type error, etc
10:36:08 <hydraz> d e p e n d e n t
10:36:11 <maerwald> -dependent types
10:36:16 <texasmynsted> oops
10:36:17 <maerwald> that would be H--
10:36:26 <hydraz> dependent types are great, yo
10:36:32 <maerwald> depends on the language
10:36:41 <texasmynsted> for H++
10:36:42 <hydraz> they're great in all languages, yo
10:36:44 <maerwald> no
10:37:03 <maerwald> that's like saying dynamic typing is great in all languages
10:37:04 <maerwald> just no.
10:37:16 <hydraz> except not at all comparable
10:37:20 <texasmynsted> what is wrong with _dependent_ types?
10:37:20 <maerwald> sure it is
10:37:24 <maerwald> it's a type system property
10:37:36 <maerwald> nothing is wrong with a concept, it depends where you inject/implement it
10:37:54 <hydraz> depends, you say?
10:37:56 <maerwald> F* without dependent types would be idiotic
10:38:00 <texasmynsted> lol
10:38:07 * ski idly wonders what the current discussion is about
10:38:12 <Tuplanolla> Communism, ski.
10:38:21 <texasmynsted> what is F*?  Is that like F#?
10:38:26 <maerwald> texasmynsted: not at all!
10:38:38 <`Guest00000> you would write a function using [Char], [Word8], etc with pattern-matching and list functions
10:38:42 <maerwald> texasmynsted: https://www.fstar-lang.org/
10:38:57 <maerwald> but you are right, it compiles to F# and Ocaml
10:39:00 <ski> Tuplanolla : like, communal processes for evolving a language ?
10:39:03 <maerwald> also to C (if they did it yet)
10:39:17 <maerwald> it makes perfect sense for their scope
10:39:22 <`Guest00000> and it would be automatically translated to a needed optimized type
10:39:46 <maerwald> I just don't want this layer of reasoning in haskell, because it is not trivial and doesn't only change the language, but also the whole ecosystem
10:39:57 <maerwald> sometimes it's better to not have features
10:40:16 <maerwald> I think edk even agreed with me once :P
10:40:18 <`Guest00000> `H--` = `H`
10:40:30 <Tuplanolla> The libraries would evolve from "you can understand anything" to "you can't understand anything", maerwald.
10:41:34 * ski idly wonders about a composable semantics for interpreting Tuplanolla's last sentence
10:41:59 <maerwald> imagine someone saying: "let's make C a memory-safe language"... no f**king hell
10:42:02 <texasmynsted> meh
10:42:05 <maerwald> go write rust or something else
10:42:16 <ski> (maerwald : i suppose <https://en.wikipedia.org/wiki/Principle_of_Least_Power>)
10:42:39 <c_wraith> maerwald, the thing is, a number of libraries people like are already using dependent typing. it's just weird and awkward and could be made much simpler
10:42:43 <texasmynsted> Maybe I would simple be happy with a nice prelude replacement.
10:42:49 <maerwald> c_wraith: remove the libraries.
10:42:56 <texasmynsted> Just do not know enough yet, to select one.
10:43:01 <hydraz> a much better solution indeed, that one!
10:44:03 <texasmynsted> anybody have a sane prelude replacement that would force somebody learning Haskell to make better choices? Hehe
10:44:04 <maerwald> we need more prelude alternatives on hackage for sure
10:44:12 <maerwald> there are too few
10:44:43 <texasmynsted> Just need one that says, if you are a beginner, use this one -->
10:44:46 <Tuplanolla> You could be our SubHask guinea pig, texasmynsted.
10:44:57 <maerwald> texasmynsted: I am sure it would be the only one saying that
10:45:12 <texasmynsted> SubHask?
10:45:15 <texasmynsted> Link?
10:45:20 <Tuplanolla> @hackage subhask
10:45:20 <lambdabot> http://hackage.haskell.org/package/subhask
10:46:03 <texasmynsted> "The goal is to make numerical computing in Haskell fun and fast." :-)
10:46:05 <texasmynsted> heh
10:46:19 <texasmynsted> I like that you are taking fun into account
10:47:07 <maerwald> if you want feature creep, go to C++. No one knows what the language even is about anymore
10:47:52 <texasmynsted> Sorry, not impressed with C++
10:47:58 <maerwald> heh
10:48:04 <texasmynsted> Rust maybe
10:48:08 <texasmynsted> Not C++
10:48:22 <texasmynsted> SubHask looks over my head
10:48:26 <texasmynsted> for now
10:48:35 <maerwald> sure, rust has a focused scope... for now
10:48:49 <maerwald> as soon as people want to mess with that scope, the language will go downhill
10:49:25 <texasmynsted> Even if I could get vim/syntastic to show me ALL the ghc warnings that I turn on...  That would be helpful.
10:49:26 <maerwald> since it has no spec, that might not be too far away
10:49:51 <texasmynsted> It is not what you add that makes it complete
10:49:57 <maerwald> exactly
11:02:42 <dysfigured> can i get an instance of lambdabot to run on another server?
11:03:13 <dysfigured> texasmynsted: are you in texas? if so what part?
11:03:48 <dysfigured> maerwald: use ALE instead of syntastic
11:04:02 <dysfigured> maerwald: https://github.com/w0rp/ale
11:04:22 <maerwald> uhm, what?
11:04:39 <dysfigured> oh shit, mixing up nicks, my bad
11:05:08 * dysfigured drinks more coffee
11:05:26 <maerwald> don't advertise drugs :P
11:05:30 <dysfigured> heh
11:09:02 <sm> g'day all
11:09:59 <sm> has anyone seen numeric options (eg: -8) implemented with cmdargs ?
11:12:24 <sm> or optparse-applicative, for that matter
11:12:40 <kuribas> I got it!
11:13:03 <dmwit> sm: Hah, fun question. I don't think I have -- usually I see it as an option with an argument instead (e.g. -v8).
11:14:02 <kuribas> > let contList =  cont . flip concatMap; retList x = cont ($ [x]) in flip runCont id $ do a <- contList [1::Int, 2::Int]; b <- contList [3::Int, 4::Int]; retList (a, b)
11:14:05 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
11:14:36 <Subeff> Hey Guys I am going through the haskell book and trying to finish the last exercise of the State chapter, I am pretty much there but the result I am getting for this expression https://github.com/subev/haskell-fun/blob/3c715a8d312dc844e4941805acffb5de5a68a42c/chapter-23/try-random/app/Main.hs#L131 is ((), 1) instead of ((), 2). The state type is defined on line 71. Any tips ? :)
11:14:43 <sm> somehow I doubt it's supported directly, I'll preprocess it I think
11:15:06 <kuribas> Now a good question is, can you implement the continuation monad on top of the list monad?
11:15:12 <kuribas> (I think no)
11:15:14 <fresheyeball> anyone out there using Dante?
11:15:15 <maerwald> sm: haven't seen anything either, especially since it's probably a bit more problematic to have an equivalent "long option"
11:15:34 <fresheyeball>  cabal: The 'repl' command does not support multiple targets at once.
11:15:37 <maerwald> what is the long version of -8? --8?
11:15:39 <c_wraith> Subeff, the problem is in your definition of (>>=)
11:15:40 <fresheyeball> this bug is destroying my workflow
11:15:57 <fresheyeball> is there any work around for cabal version 2
11:15:58 <dmwit> Subeff: Sure, you're throwing away the changes to the state in `(>>=)` and `(<*>)`.
11:16:03 <maerwald> so it would be kind of custom (I know some non-haskell apps that do that, but they probably parse manualy)
11:16:04 <c_wraith> Subeff, take another look at that, and make sure you somehow use every variable
11:16:06 <fresheyeball> that makes it actually respect a default target?
11:16:22 <dmwit> Subeff: Try writing a definition that doesn't use `_` (and doesn't name a variable and then not use it).
11:16:53 <Subeff> ok will review that part again
11:17:05 <c_wraith> Subeff, enabling -Wall will tell ghc to help you catch unused variables
11:19:13 <sm> maerwald: no need for a long version, since this is intended as a shortcut. Like git log -N
11:20:03 <sm> I mean, there is a long version, but it's context specific (it happens to be --depth in this case)
11:20:17 <texasmynsted> dysfigured: Was in Texas.  North Texas near Ft Worth.
11:20:34 <texasmynsted> Actually now in Tennessee
11:20:45 <maerwald> sm: I think it's kind of out of scope for simple argparse libraries
11:20:46 <texasmynsted> but do not want to change my nick
11:20:47 <dysfigured> texasmynsted: ah i'm just outside of houston. did you catch my comment below about replacing syntastic with https://github.com/w0rp/ale
11:21:09 <dysfigured> ALE will improve your QoL tenfold
11:21:10 <texasmynsted> oh, I did not see that
11:21:29 <dmwit> sm: Is -10 allowed?
11:21:31 <texasmynsted> Qol?
11:21:41 <dysfigured> Quality of Life
11:21:44 <texasmynsted> ha
11:21:46 <texasmynsted> ok
11:22:11 <texasmynsted> Ale was on my list but I never got around to it.  I guess I need to convert
11:22:57 <Subeff> c_wraith: The only thing that comes to my mind to not through away the changes is to append them like monoids, will give it a try
11:23:02 <texasmynsted> Do you have pointfree bound to anything?  Will Ale do pointfree also?
11:23:11 <dysfigured> texasmynsted: especially with haskell, since it can often take a few seconds to run, which leaves you stuck not being able to do anything after saving. ALE runs async, so it doesn't block the editor, and will even give you hints/errors without needing to save
11:23:20 <maerwald> good thing I never use pointfree
11:23:25 <c_wraith> Subeff, just don't ignore return values. make sure you use them all.
11:24:08 <monochrom> maerwald: Clearly, the long version of -8 is --eight :)
11:24:13 <maerwald> haha
11:24:20 <the_2nd> I have a fixed width and height and want to store width*height elements in a container. Is there anything that I can set to that size at compile time? ensuring there's no containers of incorrect size
11:24:25 <texasmynsted> oh nice.  No saving needed.  That is worth it right there.
11:24:31 <dysfigured> texasmynsted: what do you mean "pointfree bound to anything?"
11:24:45 <maerwald> now just come up with a consistent logic that doesn't mess up with -88 (yes, pun)
11:24:52 <texasmynsted> bound to keys in vim
11:25:07 <maerwald> probably most don't get the pun though, lol
11:25:10 <texasmynsted> like press this key combination and get pointfree hints 
11:25:44 <kuribas> there should be more literature about the continuation monad, how it can implement the list monad etc...
11:25:50 <texasmynsted> I used to have pointfree setup but I do not recall how.
11:25:54 <dysfigured> that sounds like a completely different plugin, like ghc-mod
11:25:55 <maerwald> kuribas: why? it's horrible
11:26:02 <maerwald> the least intuitive monad of all
11:26:18 <kuribas> maerwald: I disagree
11:26:29 <maerwald> I don't know how anyone could disagree with that
11:26:32 <ski> kuribas : seen "Reflecting Monads" by Andrzej Filinski ?
11:26:36 <maerwald> the things you can do with that are just weird
11:27:21 <texasmynsted> The other day I had added pandoc to my cabal file and then edited the source file in vim.  Vim just froze for aaaaaages while stack was pulling in dependencies in the background. 
11:27:29 <ski> maerwald : s/weird/fun/ ;)
11:27:35 <maerwald> no
11:27:48 <kuribas> maerwald: if you restrict the type to "Cont c c" it becomes easier
11:27:48 <texasmynsted> so now "note to self: stack build before opening vim"
11:28:05 <kuribas> maerwald: it's just flattening of nested callbacks
11:28:06 <monochrom> kuribas: Does my http://www.vex.net/~trebla/haskell/cont.xhtml count?
11:28:07 <ski> in one sense, continuation monad seems to correspond to classical logic
11:28:13 <ski> so if the former is weird, so's the latter
11:28:38 <sm> dmwit: yes, -10 will be fine
11:28:58 <texasmynsted> dysfigured: Did you get flooded?
11:29:21 <kuribas> monochrom: yeah, I agree that callbacks make it easier
11:29:29 <maerwald> kuribas: I had a session with Cale where I explored a few odd edge cases of that monad, I am suppressing that experience
11:29:43 <kuribas> maerwald: haha
11:29:48 <monochrom> Callbacks are weird too. Just look at how Java programmers congratulate themselves when they finally grok SAX for example.
11:29:49 <texasmynsted> all these storms are out of control
11:29:55 <ski> (can you prove that `A /\ (B -> C)' follows from `(A -> B) -> (A /\ C)' (and vice versa) ? what about a computational interpretation of the proof ?)
11:29:59 <dysfigured> texasmynsted: nah, i'm in gavleston actually, we have places for the water to go
11:30:01 <kuribas> maerwald: yeah it can get hairy
11:30:30 <texasmynsted> dysfigured: oh, that is good.
11:30:41 <texasmynsted> I wonder what happened to Crystal Beach
11:32:38 <maerwald> callbacks are simple, they are just function pointers :>
11:32:51 <monochrom> I once messed with the mind of a mathematician friend by merely pointing out that (A /\ B -> C) is equivalent to ((A->C) \/ (B->C)) in classical logic.
11:32:53 <kuribas> maerwald: you can flatten a nested callback by prepending (ContT . ) or (cont .)
11:33:25 <kuribas> like foreach:
11:33:32 <kuribas> :t ContT . for_
11:33:33 <lambdabot> (Applicative m, Foldable t) => t a -> ContT () m a
11:34:34 <ski> monochrom : they hadn't reflected before over such seemingly strange (why ?) equivalences in classical logic
11:34:53 <monochrom> The dialogue was like  <him> No way!  <me> Just look at the truth table!  <him> Oh yeah but um what is going on???!!!  [a few minutes later]  <him> Ohhhh I see why I didn't believe it...
11:35:28 <monochrom> It proves that even a classical mathematician can be more constructivist subconsciously than you think.
11:35:52 <ski> monochrom : .. i wonder how often (ostensibly) classical mathematicians actually use non-constructive reasoning principles, apart from the common ones, like PEM, PbC
11:36:11 <ski> monochrom :)
11:36:53 <monochrom> The initial disbelief can be explained by the initial reading of \/ as constructive-or.
11:37:00 * ski nods
11:37:23 <ski> sometimes i think that math should explicitly distinguish between additive and multiplicative disjunction
11:38:03 <ski> a proof of `A \/ B' that starts with "suppose not `A'" is a perfectly valid proof, if the disjunction is taken to be multiplicative
11:39:38 <ski> (i remember figuring out a computation interpretation of "no infinite descending chain" for the naturals)
11:40:08 <dolio> ski: I don't think that's true. It's only true if the entirety of your subsequent reasoning is linear, or something along those lines.
11:40:56 <ski> dolio : yea, the devil's in the details :/
11:41:04 <kuribas> maerwald: use these definitions: let idContT = flip runContT id; idCont = flip runCont id; retCont x = cont ($x); retContT x = ContT ($x)
11:41:49 <kuribas> maerwald: now you can flatten any nested callbacks by prepending (ContT $) to each level, and using retContT for the return value.
11:41:55 <maerwald> do you want to torture me? :(
11:42:20 <kuribas> > let idContT = flip runContT id; idCont = flip runCont id; retCont x = cont ($x); retContT x = ContT ($x) in idContT $ do a <- ContT $ for_ [1, 2]; b <- ContT $ for_ [3, 4]; retContT $ print (a, b) -- maerwald: like this: 
11:42:22 <lambdabot>  <IO ()>
11:42:26 <maerwald> help!
11:42:42 <kuribas> maerwald: it's just a mechanical transformation
11:42:44 <monochrom> Yes, it's either Cont or pulling your fingers. Choose one!
11:42:48 <kuribas> maerwald: no understanding required
11:42:52 <ski> kuribas : i tend to define `evalCont = flip runCont id' and `evalContT = flip runContT pure'
11:43:07 <kuribas> ski: right :)
11:43:22 <ski> (note the `pure'/`return' there in the transformer case, not `id')
11:44:02 <monochrom> @type flip runContT id
11:44:04 <lambdabot> forall k (r :: k) (m :: k -> *). ContT r m (m r) -> m r
11:44:18 <kuribas> ski: that gives me an error...
11:44:25 <monochrom> @type flip runContT pure
11:44:27 <lambdabot> Applicative m => ContT r m r -> m r
11:45:12 <ski> kuribas : i suppose you'll have to adjust your example to not return an action, if you want to use `evalContT'
11:45:21 <ski> (see what lambdabot said)
11:45:45 <kuribas> ski: dont I want an action?
11:45:53 <ski> i dunno ?
11:46:08 <kuribas> ski: like print (a, b) in my example
11:46:38 <ski> @let evalCont :: Cont o o -> o; evalCont = (`runCont` id); evalContT :: Applicative i => ContT o i o -> i o; evalContT = (`runContT` pure)
11:46:39 <lambdabot>  Defined.
11:50:04 <Psybur> I noticed the first code block doesnt work for me on https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
11:50:15 <Psybur> Is this an out of date article?
11:50:28 <Psybur> > map ($ 2) [(2*), (4*), (8*)]
11:50:30 <lambdabot>  [4,8,16]
11:50:35 <Psybur> Hmm, it doesnt work in ghci
11:50:42 <ski> @let forAll :: Foldable t => t a -> Cont Bool a; forAll xs = cont (`all` xs); thereExists :: Foldable t => t a -> Cont Bool a; thereExists xs = cont (`any` xs)
11:50:44 <lambdabot>  Defined.
11:51:02 <ski> > evalCont $ do x <- forAll [2,3,5,7]; y <- thereExists [0 .. 9]; return (x <= y)
11:51:04 <lambdabot>  error:
11:51:04 <lambdabot>      Ambiguous occurrence ‘forAll’
11:51:04 <lambdabot>      It could refer to either ‘Lambdabot.Plugin.Haskell.Eval.Trusted.forAll’,
11:51:10 <ski> > evalCont $ do x <- L.forAll [2,3,5,7]; y <- thereExists [0 .. 9]; return (x <= y)
11:51:13 <lambdabot>  True
11:51:57 <Psybur> I realize I was in a python repl
11:52:04 <Psybur> Wrong command line window lel
11:53:07 <erisco> os.system('echo "map ($ 2) [(2*), (4*), (8*)]" | ghci')  then, I think
11:53:13 <monochrom> Psybur: First code block? map ($ 2) [(2*), (4*), (8*)] ?
11:53:26 <monochrom> Oh nevermind hahaha
11:53:29 <Psybur> monochrom, :D
11:54:00 <kuribas> maerwald, ski: http://lpaste.net/358622
11:54:23 <maerwald> can you plase add types?
11:54:29 <kuribas> maerwald: right
11:54:31 <maerwald> I am not properly sober and can hardly guess what that is
11:54:52 <maerwald> looks like python
11:55:26 <kuribas> maerwald: http://lpaste.net/358622#a358623
11:55:28 <ski> kuribas : i suppose in place of your `retContT $ print (a, b)', i'd do `print (a,b); return ()'
11:55:41 <kuribas> ski: I see, thanks
11:55:52 <kuribas> maerwald: notice how they almost look the same?
11:56:32 <maerwald> kuribas: lol
11:56:37 <maerwald> but like switched
11:57:01 <ski> kuribas : now perhaps you had some idea in mind with using `ContT o m (m o)' rather than the simpler `ContT o m o'. but barring this, i think `evalContT' is to be preferred over `retContT'
11:57:30 <kuribas> ski: right
11:58:19 <ski> kuribas : .. however, to get the full power here, (iow using full-strength `for' rather than `for_'), we need indexed monads
11:59:38 <kuribas> ski: hmm, let me try
12:00:31 <ski> kuribas : iow, to be able to factor out the `for xs $ \x -> for ys $ \y ->' part out of `for xs $ \x -> for ys $ \y -> ..x..y..'
12:01:26 <ski> (so that you can define `forBoth' and then say `(x,y) <- forBoth xs ys; ..x..y..'. that's just a simple example to illustrate what i mean)
12:20:46 <erisco> can I use inline-c to define and export a function?
12:21:36 <erisco> it doesn't seem so, and that means I am more or less back to square one with figuring out the FFI
12:23:11 <erisco> I see how to implement a Haskell function with it, but then I have to use FFI to export this Haskell function
12:23:23 <erisco> and since structs are involved, I have to figure out that complication too
12:23:52 <cocreature> erisco: I’m not sure how you expect inline-c to help you with exporting functions to C?
12:24:01 <kuribas> ski: http://lpaste.net/358622#a358625
12:24:23 <kuribas> ski: That seems to work.  I cannot make it work with your evalContT though...
12:24:59 <erisco> cocreature, I was asking about FFI yesterday and this was recommended to me, but it wasn't clear I was specifically trying to export functions
12:25:37 <erisco> nonetheless, it seems like inline-c is capable of a lot … it apparently understands structs already, but I do not know how to leverage this understanding
12:26:16 <cocreature> afaik inline-c just reuses Storable instances
12:27:48 <cocreature> erisco: https://www.haskell.org/onlinereport/haskell2010/haskellch8.html search for “Export Declarations”
12:27:52 <erisco> https://wiki.haskell.org/Foreign_Function_Interface 4.7.2 or 4.7.3 is the best lead I gave
12:28:00 <erisco> have* so I will give that a go
12:29:12 <cocreature> I don’t think any of the packages aimed at simplifying FFI target exporting functions
12:29:47 <cocreature> you can use c2hs to simplify writing Storable instances if that’s what you’re trying to avoid
12:29:49 <erisco> fine, but I need to go through the rigmarole of a Storable instance, which hsc2hs or c2hs are supposed to help with
12:30:22 <erisco> then, given this, I am hoping I can just use my data type as a parameter type on an exported function … will find out
12:30:49 <cocreature> hsc2hs and c2hs don’t avoid Storable instances. they just simplify writing them
12:30:53 <erisco> there are some things I might use inline-c for yet still though
12:31:00 <erisco> "help with"
12:31:35 <cocreature> as I said, if it’s just writing Storable instances that’s independent of whether you’re importing or exporting
12:31:43 <erisco> I don't think they could have explained c2hs in any manner more confusing to a FFI newbie
12:34:01 <cocreature> c2hs does a few orthogonal things. 1. it parses C headers and checks that your FFI declarations are not completely bogus. 2. it generates some of the boilerplate for marshalling between C and Haskell types and 3. it simplifies writing Storable instances for structs
12:34:42 <cocreature> for foreign exports only 3 applies
12:35:39 <erisco> the structs are not exported, they're defined in a C header
12:35:47 <erisco> I have to mimic those
12:36:00 <cocreature> sure I was referring to exporting function definitions
12:36:06 <cocreature> you can’t export structs
12:36:20 <cocreature> and you can’t pass structs by value.
12:36:34 <erisco> I saw that… thankfully not a problem
12:37:14 <cocreature> so basically the underlying FFI bindings are just going to pass pointers and then the Storable instance en/decodes Haskell types to pointers
12:38:36 <cocreature> what c2hs provides is a way to automatically compute the offsets of struct fields so you don’t have to do that yourself when you’re writing Storable instances
12:39:20 <erisco> I don't know how I would do that … afaik these sizes change based on platform
12:39:42 <ongy> hsc2hs compiles a C program that outputs the final .hs file afaik
12:39:49 <ongy> not sure if c2hs does the same
12:40:04 <cocreature> c2hs does some educated guessing and gets things right most of the time :)
12:40:24 <kuribas> ski: I managed it with evalContT and return :-)  http://lpaste.net/358622#a358627
12:40:48 <ski> @type evalContT $ do a <- (ContT . for_) [1,2]; b <- (ContT . for_) [3,4]; liftIO (print (a,b))
12:40:50 <lambdabot> MonadIO i => i ()
12:40:52 <erisco> this is what happens when two countries build their railways with different widths
12:40:52 <ski> kuribas ^ ?
12:41:23 <ski> yeah, i should have mentioned `lift'/`liftIO'
12:41:39 <kuribas> ski: yeah, I used liftIO in my last example
12:42:09 <ski> kuribas : still, the indexed monad comment was a separate point, not directly related to `evalContT'
12:42:11 <erisco> can't just roll right on in… no… have to stop, unload, load onto a different train, then keep going
12:42:42 <kuribas> ski: not sure I understand the need for an indexed monad?
12:43:46 <ski> kuribas : say you want to turn `[[a]]' into `m [[b]]', by means of `for' over a transformation from `[a]' to `m [b]', in turn defined in terms of `for' over a transformation from `a' to `m b', which is whatever random body you like
12:46:02 <ski> kuribas : now, just like before, one could like to "flatten" or "factor out" (abstract) the two "for loops". but this requires an indexed continuation monad. composing `Cont2T [[b]] b m ()' from `Cont2T [[b]] [b] m ()' and `Cont2T [b] b m ()'
12:46:21 <ski> here `Cont2T o p m a' is `(a -> m p) -> m o'
12:46:57 <ski> (that's a rough sketch of it. if you try it, you'll hopefully see what i mean)
12:47:45 <kuribas> sort of...
12:48:31 <ski> as long as we use `for_', the monadic result is trivial, `()'. so it doesn't change as we step inside the loops
12:48:53 <ski> when we use `for', we need to keep track of changing "context"
12:49:40 <kuribas> ski: well, I managed with concatForM...
12:50:30 <ski> so we can define `return :: Monad m => a -> Cont2T o o m a' and `join :: Monad m => Cont2T o p (Cont2T p q m) a -> Cont2T o q m a', which yields `(>>=) :: Monad m => Cont2T o p m a -> (a -> Cont2T p q m b) -> Cont2T o q m b'
12:51:31 <ski> well, i was talking about an arbitrary `for', not just the specialized `concatForM' built from it
12:52:19 <ski> (an arbitrary `for :: (Applicative i,Traversable i) => t a -> (a -> i b) -> i (t b)')
12:56:00 <kuribas> ski: so an indexed continuation monad has flattening builtin?
12:56:10 <ski> kuribas : more specifically, try starting with an `[[Int]]' and end up with a (nontrivial) `[[Int]]', transforming the `Int' elements in some way, while also (optionally) having some other effects (like `IO')
12:57:16 <ski> (in your paste you end up with a singly-nested list, which is why `concatForM' together with the singleton `[(a,b)]' works)
12:58:46 <kuribas> hmm, right
13:13:18 <kuribas> ski: that >>= doesn't seem right, doesn't the type has to be the same?
13:13:53 <kuribas> ski: or that's what you mean by indexed monad?
13:14:23 * ski nods
13:14:35 <ski> this is not a plain monad
13:14:43 <kuribas> right
13:15:13 <ski> another example of an indexed monad is `State2T s t m a' being `s -> m (a,t)', where the type of the state can change, as we go along
13:15:33 <kuribas> that sounds pretty useful
13:29:41 <iqubic> @let bar x | let = x
13:29:43 <lambdabot>  Defined.
13:30:00 <iqubic> That means that let can be used in place of otherwise
13:30:17 <Hafydd> > bar 1
13:30:19 <lambdabot>  1
13:31:22 <iqubic> @define isPos x = if x > 0 then (Just x) let x
13:31:22 <lambdabot>  Parse failed: Parse error: let
13:33:10 <iqubic> @define isPos x; | x > 0 = Just x; | let = nothing
13:33:10 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
13:33:31 <iqubic> Well, looks like I can't use pattern guards with lambdabot.
13:33:42 <iqubic> https://www.reddit.com/r/haskelltil/comments/4r3t36/let_in_place_of_otherwise/
13:46:41 <jle`> iqubic: you can use pattern guards lambdabot
13:46:48 <jle`> iqubic: you just had a stray semicolon
13:47:12 <jle`> @let isPos x | x > 0 = Just x | let = Nothing
13:47:14 <lambdabot>  Defined.
13:51:44 <ski> iqubic :)
14:00:10 <erisco> why is there no liftA28? geez
14:05:00 <erisco> if I was looking for a library which defined a bunch of higher arity versions of these sorts of functions…
14:05:05 <erisco> what might I look for?
14:08:07 <monochrom> Perhaps acme. :)
14:08:59 <erisco> if you guys can help me put together a list of functions sensible to have high arities for I will put together a package
14:14:35 <monochrom> The problem is that high arities are seldom sensible.
14:15:05 <erisco> liftA, liftA2, liftA3, curry, curry3, uncurry, uncurry3
14:15:09 <monochrom> Apart from lens and Okasaki's trick of getting "begin push 3 push 4 end" to type-check.
14:15:13 <erisco> these sorts of function families is what I am talking about
14:15:40 <monochrom> Yes but even by the time of liftA4 it becomes not quite sensible.
14:16:04 <erisco> except I have a sense for liftA28, else I wouldn't be here
14:17:33 <erisco> flip, extended to reverse a prefix of parameters
14:17:49 * ski senses there's two different notions of the term "sense" being used here
14:18:19 <erisco> zip
14:18:50 <erisco> that's kinda pointless with liftA and ZipList
14:21:18 <erisco> this is your chance to be enshrined in an acme library of arbitrary proportions!
14:23:37 <benzrf> erisco: i have a better idea
14:24:42 <erisco> go
14:24:48 <benzrf> hold on im figuring it out
14:24:51 <benzrf> :>
14:28:50 <benzrf> hmm this is trickier than i expected
14:28:53 * maerwald stares at a wall
14:28:59 <erisco> if you happen to be wondering if we can just define the nary function, using some fancy type stuff, then yes we can, but it is different
14:29:16 <benzrf> well, i was thinking of a specific case of doing so, but yeah :)
14:29:47 <erisco> it is different in that it is greedy, or presumably is
14:29:58 <erisco> :t liftA (+)
14:30:00 <lambdabot> (Num a, Applicative f) => f a -> f (a -> a)
14:30:21 <erisco> whereas I can say exactly how many parameters I want to do something to here
14:30:44 <sdaiw> why not "a <$> b <*> c <*> d" etc?
14:31:08 <erisco> you could use type applications to pass in the number of arguments, like  liftAn @28  for example, sure
14:31:51 <erisco> in which case it is essentially a complicated implementation of the alternative
14:32:04 <erisco> the alternative being a pretty stupid copy/paste/edit affair
14:32:26 <maerwald> erisco: you are being very philosophical recently (in a technical sense)
14:32:44 <erisco> does that mean I've come down with something? :s
14:32:54 <monochrom> I think erisco has alway been pretty philosophical.
14:33:07 <maerwald> I have a feeling things are escalating...
14:33:15 <maerwald> (which is good)
14:33:46 * maerwald waits for the next GHC extension erisco will come up with
14:36:30 <erisco> after you become an op the world looks much different, up from here on Mount Olympus
14:36:52 <maerwald> infix?
14:38:50 <monochrom> Oh great now I can be an infix op too.
14:39:00 <erisco> the trouble is not to let the thin air get to you
14:40:25 <monochrom> But who became an op lately?
14:41:02 <maerwald> social status. Anyone who cares about that gives in to fear and hierarchy
14:43:43 <Unode> hi all, I'm running an haskell program written by a coworker. Given the memory usage, I suspect there might be a memory or space leak. We've had similar issues in the past and I wonder if this is a regression. On that note, is there any way to write a test (regression test?) to avoid changes that introduce memory or space leaks?
14:44:28 <Unode> other than good coding practices, are there any tools to help avoid these situations?
14:46:06 <maerwald> reasoning about space leaks is rather hard and often involves analyzing laziness properties
14:46:10 <maerwald> I don't know of any automation
14:46:23 <erisco> I dunno, maybe shapr was joking … can't seem to figure it out now
14:47:11 <Unode> From what I've been reading, seems like space and memory leaks is in the top 5 of hardest issues when programming in haskell.
14:48:02 <maerwald> and despite all that abstraction there are still no tools that can fix it for you :P
14:48:38 <monochrom> When building a test version of your exe, tell ghc the flag "-rtsopts" so that the following can be done: When running your test version exe, add "+RTS -M50G" to mean "use 50GB only".
14:49:17 <erisco> I'll say I renounced my transcendental existence to instead live amongst mortal men and women
14:49:23 <monochrom> Then the tester can just watch out for sudden program death due to trying to use more memory.
14:49:25 <Unode> but I'm still clueless on how to approach this. Can only think of something that runs a semi-large processing and considers a failure if memory rises above a given threshold. Highly unreliable though and likely to give many false positives or no true positives at all :P
14:49:29 <maerwald> if you look at high-performance libraries you will see a sh*tload of strictness and inline annotations
14:49:50 <Unode> monochrom: that's exactly what I was thinking.
14:49:59 <maerwald> to the point that you wonder why did he even write that in haskell
14:50:08 <Unode> monochrom: is this common practice?
14:50:18 <monochrom> I don't know.
14:51:14 <Unode> maerwald: yeah... I'm learning haskell myself and I'm going back and forth between these hard issues and the complexity of some of the concepts which I still don't fully grasp.
14:51:21 <Unode> monochrom: thanks
14:51:29 <c_wraith> Unode, space leaks and memory use aren't any more of a problem than any other language. most of the time everything works fine when you just remember how things work.
14:51:46 <maerwald> wat
14:51:50 <c_wraith> Unode, on rare occasions, you have to dig out the profiler to understand what's going on.
14:51:58 <maerwald> sure it is, GC and laziness impose additional headaches
14:52:03 <c_wraith> but most of the time, this game are just fine.
14:52:10 <dysfigured> thoughts on ghcjs vs purescript?
14:52:27 <c_wraith> maerwald, no, they impose *different* headaches
14:52:56 <c_wraith> maerwald, they're not worse than the problems you get in other languages. they're just less familiar at first.
14:53:10 <maerwald> I strongly disagree
14:53:43 <Unode> c_wraith: I'm not sure I completely agree on that. Lazyness puts a lot more mental burden on the programmer. I generally expect tools to help here or at least make that burden smaller.
14:54:01 <c_wraith> I have written large programs in Haskell. I am relating my experience doing so. about 1 memory use problem that took work to fix per person-year.
14:54:28 <maerwald> exactly, in languages like rust the worst problem you have are refcycles and there are very obvious solutions to that and debugging is very straight-forward
14:54:33 <maerwald> unlike laziness problems
14:54:35 <boj> anecdote at best, but i've only had to deal with one space leak in the last 3 years.
14:54:51 <erisco> is a void pointer Ptr Void?
14:55:36 <monochrom> Not necessarily.
14:55:53 <monochrom> Depends on the rest of the program. I am serious.
14:55:58 <maerwald> one of the reasons Idris decided against laziness by default is the ability to reason about performance (including space)
14:56:47 <c_wraith> where are all the problems you're talking about? why don't people actually using haskell run into them?
14:56:55 <maerwald> facebook did
14:57:22 <maerwald> and a game developer I forgot the project he was talking about
14:57:27 <maerwald> OpenGL stuff
14:57:38 <maerwald> not that uncommon
14:57:46 <maerwald> depends on the use cases
14:57:46 <c_wraith> you mean the project where they got a huge number of people who don't use haskell to write haskell code and had a very small number of problems?
14:57:51 <maerwald> no
14:58:11 <Unode> c_wraith: you missed my point. You are likely closer to the expert side. There's many features of haskell I probably won't use at the beginning. I've only recently heard about bangs. Makes me wonder why should I not always use bangs almost everywhere...
14:58:32 <c_wraith> Unode, because they usually make space use worse
14:58:54 <Unode> c_wraith: then you are making my initial point stronger.
14:59:04 <maerwald> Unode: exactly and if you need esoteric expert knowledge to tacle basic shortcoming of a language, then you can consider those non-trivial problems of the language :)
14:59:17 <maerwald> but I consider that one of the very few
14:59:28 <c_wraith> I didn't say there's nothing to learn. I said that it's not harder to learn than memory use in any other garbage collected language
14:59:30 <maerwald> but it IS a very hard one
15:00:05 <Unode> c_wraith: coming from python I can hardly compare the level of difficulty. And Python is garbage collected.
15:00:09 <maerwald> it's not just about GC, but also specifically about laziness
15:00:26 <maerwald> don't blame the GC alone ;)
15:01:08 <maerwald> and... we don't have laziness in the type system ;)
15:01:08 <c_wraith> Unode, you're comparing your ability at a beginner state to your ability an an experienced state.
15:01:40 <c_wraith> Unode, come back to it when you're experienced with both.
15:01:42 <maerwald> so reasoning about laziness is something you actually have to know about in detail... what breaks laziness properties, what does not and so on
15:01:44 <dysfigured> what are y'all even arguing about? this sounds like some kinda "hurr haskell is dum" argument and the channel having to defend itself
15:01:53 <erisco> monochrom, I am just trying to figure out how to translate it for the bindings
15:02:12 <maerwald> dysfigured: nah, it's just someone trying to oversimplify a problem, which isn't all that simple :P
15:02:17 <erisco> I am guess a return void translates to return unit but I am guessing wildly right now
15:02:25 <boj> Unode: at the end of the day it's just a matter of profiling your code, and understanding which functions are space leaking (usually do to laziness). unfortunately there's no quick fix, just a bit of hard work and elbow grease
15:02:34 <c_wraith> maerwald, yes. you have to understand the evaluation model in your language. when I picked up my current job, it took me a month to get over how complicated strict evaluation is.
15:02:48 <maerwald> *shrug*
15:02:57 <maerwald> I disagree.
15:03:20 <maerwald> strictness makes it exceptionally easier to reason about performance
15:03:30 <boj> Unode: we don't have a shortcut for this particular problem. as i pointed out though, anecdotally space leaks don't  seem to happen often
15:04:03 <Unode> c_wraith: no, I'm comparing the level of understanding. I understand memory and allocation but in the context of haskell lazyness adds an extra level that I'm not used to. I see some benefits but at this early stage I'm still weighting them compared to the difficulty.
15:04:32 <maerwald> Unode: blame the guy who wrote the codebase initially, it seems it was a lightly choice
15:04:47 <Unode> anyway, I'm digressing. My initial question was about ways (preferably automatic or semi-automatic) to handle introduction of space/mem leaks in the code. 
15:04:48 <maerwald> *light-hearted, or whatever you say
15:05:06 <monochrom> erisco: "void whee(void)" is going to be very different from, say, "void* wat(void*)". whee translates to "IO ()" very simply, yes. But void* means "I am emulating polymorphism in C. The recipient of void* is supposed to know the actual concrete type and cast the pointer to that type first". So you have to dig deep into either docs or other parts of the code to find out what the intended concrete type it.
15:05:10 <maerwald> there are none that I know of
15:05:19 <maerwald> it's debugging and analyzing
15:05:41 <Unode> maerwald: hehe yeah but given I know little about haskell it's hard to point the finger. That there is an issue is clear, but I'd perfer to be part of the solution :)
15:05:56 <erisco> monochrom, I get that, but I am just looking for an authority to say  void *  translates as  Ptr Void
15:06:04 <maerwald> haskell is hard to learn, how big is the codebase?
15:06:04 <Unode> when you say "debugging" do you also have any help on that?
15:06:14 <boj> Unode: this helped me when i ran into a space leak. worth a read http://neilmitchell.blogspot.jp/2015/09/detecting-space-leaks.html
15:06:21 <monochrom> Well there is going to be none. Because of the reason I stated.
15:06:45 <Unode> maerwald: about 10k lines of haskell.
15:06:53 <maerwald> that would be 30k in an imperative language
15:06:54 <monochrom> Any reasonable authority is going to say exactly what I said. "It depends on the context. This is already the authoritative answer."
15:06:54 <erisco> well I don't get it then… there has to be a way to define a binding for this
15:07:02 <Unode> (according to cloc)
15:07:15 <maerwald> if you have the resources to rewrite 30k loc in an imperative language, you might pick that as an option
15:07:32 <c_wraith> Unode, mostly just look for any expression that's recursively evaluated without any branching on the current state.
15:07:34 <Unode> maerwald: that's unlikely to happen.
15:08:03 <intset> Hello! I have a question about Data.Set vs Data.IntSet
15:08:06 <c_wraith> Unode, that's the dangerous pattern
15:08:12 <boj> alright, i give up on being helpful this morning
15:08:27 <c_wraith> intset, well, you're only named after the latter. :)
15:08:33 <intset> I have 16 Word8 values, and I want to check if a Word8 is in that set.
15:08:34 <erisco> also guessing that I just ignore const…
15:08:39 <maerwald> boj: good link though
15:08:54 <monochrom> If you say, your use case is such that you are just passing whatever void* you receive to someone else, you can make it "Ptr v" with "v" being an independent type variable.
15:09:00 <intset> I'm curious what the cost of fromIntegral will be in the code
15:09:12 <Unode> c_wraith: I don't know what 4 terms on your reply mean :). "recursively evaluated" -> there's lots of them. "without any branching" <- Don't know what this means. "Current state" <- not sure about this either.
15:09:13 <intset> So if I just use Data.Set, I can use the Word8 directly 
15:09:27 <intset> And if I use the Data.IntSet, I need to do a fromIntegral before the check
15:09:37 <erisco> monochrom, on the Haskell side, I'd expect Ptr a to be unsafely coercible to Ptr b
15:09:39 <c_wraith> intset, really hard to pick one answer over the other. it'll depend on your use patterns.
15:09:49 <intset> All lookups
15:09:52 <intset> It's a static set
15:09:53 <boj> Unode: i gave you a good link to debug your app. you should give it a try
15:10:11 <monochrom> You would be right. But with castPtr I can already cast Ptr Void to Ptr b too.
15:10:35 <monochrom> So Ptr Void just adds political correctness, not safety.
15:10:42 <intset> c_wraith, so I actually considered writing some logic to check since it's small :)
15:10:46 <erisco> yes, that is my intention behind saying that
15:10:48 <Unode> boj: reading through it. Thanks for the link
15:10:53 <intset> Surely the hard-coded one could be fastest
15:10:58 <c_wraith> intset, for *that* use case, I'd be tempted to just use a 256-element Vector Bool
15:11:01 <monochrom> Whereas "Ptr v" means you actually let people do useful work.
15:11:12 <intset> Ohhh, interesting! :D
15:12:05 <intset> I'm using ByteArray# for my project, so I wonder if there's some benefit in choosing that over Vector?
15:12:20 <intset> I really just need 256 bits
15:12:47 <intset> Is there some bitmask thing like this already?
15:12:52 <c_wraith> I believe Vector Bool is compact.. at least if you use the Unboxed variant
15:13:21 <intset> Wouldn't compact mean that the pointers to the Bool values are compact?
15:13:56 <intset> (Ah, I also wonder if True is allocated once per program, or if saying it multiple times leads to multiple allocations.)
15:13:57 <c_wraith> no. being unboxed means it doesn't have pointers. they're just embedded directly into the backing memory
15:14:17 <c_wraith> and it happens that there's only one True in ghc
15:14:28 <monochrom> Here is an example. What is malloc's type in C? "void *malloc(...)". And what is its type in Haskell? "mallocBytes :: Int -> IO (Ptr a)". This is right there in the standard library. This is as authoritative as you can get.
15:14:33 <intset> I think it is defined as "data Bool = True | False" though. How does that get unboxed?
15:15:33 * hackagebot ombra 1.0.0.0 – Render engine. – https://hackage.haskell.org/package/ombra
15:15:33 * hackagebot irc-client 1.0.0.0 – An IRC client library. – https://hackage.haskell.org/package/irc-client
15:15:45 <c_wraith> intset, it has to do with how unboxed Vector works. it provides an Unbox class that is responsible for converting between the standard representation and the Vector backing store.
15:15:54 <intset> Ah, gotcha!
15:16:17 <intset> I'm checking out https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Bits.html at the moment and I am quite tempted to go that way nonetheless :)
15:16:23 <intset> I kind of like the directness
15:17:12 <intset> I need four Word64 and then I can use `testBit` to ask about particular bits
15:17:44 <c_wraith> no downside to that approach either.
15:18:05 <intset> That means I think it'll be 3 operations to check for anything: Is it less than 128? Is it less than 64? Then run testBit on the number!
15:19:02 <c_wraith> well, testBit pri
15:19:17 <c_wraith> err. probably isn't a single machine operation.
15:19:29 <c_wraith> since it has to produce a Bool, after all.
15:21:15 <intset> c_wraith, yeah, I'm looking into the implementation for Word64 and it's a bit more
15:21:35 <erisco> well I broke c2hs
15:21:42 <intset> it seems to be a shiftL then an .&.
15:23:08 <Unode> boj: thanks for the link. I'll give this a try. Main issue for now is that I don't quite know what would be a reasonable -K (to set as target). Given the memory usage I'm seeing is in the 2 digit GB I guess the first -K won't be small.
15:23:45 <boj> Unode: keep shrinking it until your app blows up :)
15:24:26 <jared-w> I recommend the binary search method ;)
15:26:38 <intset> c_wraith, I cannot understand the Vector implementation at all
15:27:00 <c_wraith> that's... um, well, that's Vector.
15:27:07 <intset> How do you know that booleans are unpacked to a bit?
15:27:26 <c_wraith> I'm not 100% sure. I'd have to check.
15:27:36 <intset> I found the "Unbox" class, but I think it just gets derived
15:27:52 <intset> I don't know the fine details of Typeable or whatever the mechanism is there
15:28:15 <c_wraith> but every time I look at the Vector source, I remember it wasn't written to be understood without knowing the entire fusion framework it uses.
15:28:29 <intset> Ah, hmm.
15:28:43 <intset> Alright, well I'll just pick one and continue. Thank you for your help and ideas! :D
15:28:51 <c_wraith> It's probably using a default instance that depends on Data.Data
15:31:24 <iqubic> > isPos 30
15:31:26 <lambdabot>  Just 30
15:31:47 <iqubic> > isPos (-20)
15:31:49 <lambdabot>  Nothing
15:32:11 <iqubic> That was defined like, two hours ago, how is that still working?
15:32:39 <geekosaur> nobody felt the need to @undefine
15:50:30 <jared-w> huh, I would've thought that there was a timer on that
15:55:53 <monochrom> @undefine
15:55:53 <lambdabot> Undefined.
15:55:55 <monochrom> Done!
15:56:11 <monochrom> I have thought of doing that myself. But too lazy.
15:56:38 <monochrom> But I could code up a znc plugin on my end to issue an @undefine every 2 minutes or something.
15:57:16 <MarcelineVQ> youmonster
16:08:25 <erisco> I am confused by c2hs again… so I defined a data type which mimics a struct
16:08:55 <erisco> but, c2hs does not know about this data type inherently, so it isn't aware how to translate the struct type it sees in the header file to my data type
16:09:00 <erisco> and I can't figure out how to tell it…
16:16:56 <erisco> if anyone has any examples that would help a ton…
16:20:09 <erisco> just any example of defining a C struct, a corresponding Haskell data type, and how to tell c2hs what is what
16:20:48 <erisco> I have tried using the pointer directive, the typedef directive, and neither I can get working
16:21:02 <erisco> it doesn't even let me use "struct" in the C type name …
16:21:15 <maerwald> MarcelineVQ: monster?
16:23:27 <maerwald> trying to make something positive out of that term... what would a "type monster" be if you see it as something positive?
16:24:07 <MarcelineVQ> perhaps it could keep away scarier things with its monstrosity
16:24:13 <maerwald> probably continuation monad :(
16:24:39 <maerwald> what is the chinese word for continuation monad?
16:25:12 <MarcelineVQ> 无穷
16:25:28 <maerwald> how do you spell that?
16:25:33 <MarcelineVQ> 无穷
16:25:36 <maerwald> lol
16:27:02 <maerwald> I just know what "toilet" means in chinese and I cannot even spell it
16:27:27 <koz_> Is the streaming library any good? https://hackage.haskell.org/package/streaming
16:28:55 * hackagebot fadno-xml 1.1.0 – XML/XSD combinators/schemas/codegen – https://hackage.haskell.org/package/fadno-xml
16:29:04 <maerwald> MarcelineVQ: you like bao-tse?
16:29:45 <MarcelineVQ> never had it
16:30:31 <MarcelineVQ> looks like a fun thing to make though
16:30:57 <maerwald> the best thing is Sheng Jian Man Tou from Shanghai
16:31:44 <MarcelineVQ> you sure like stuffed buns :>
16:31:55 <maerwald> yes, but these are special
16:32:03 <koz_> Because stuffed buns are neat.
16:32:43 <maerwald> first time you have a bite, the hot water will splash everyone near you
16:32:54 <maerwald> if you don't know how to eat them :P
16:34:20 <maerwald> they are fried that way so there is really a lot of hot water inside
16:36:22 * maerwald imagines there would be a haskell job in shanghai so he could have bao-tse and haskell
16:36:48 <maerwald> unfortunately, only Go is popular in china
16:37:06 <MarcelineVQ> i see what you did there
16:37:15 <maerwald> :P
16:37:43 <maerwald> barely made it out without a single arrest
16:37:59 <maerwald> askes random people about their political alignment xD
16:38:28 <maerwald> one thing that is not particularly smart in that country xD
17:00:01 <erisco> okay, I think I licked it… heaven knows until I get something to run
17:00:28 <maerwald> what did you lick?
17:00:40 * maerwald is unsure whether he wants to know
17:01:04 <erisco> lick as in beat
17:01:47 <erisco> just realised a question that helped me on SO was asked by the fine sinelaw
17:01:51 <MarcelineVQ> beating and licking...
17:02:01 <hpc> yeah that doesn't exactly solve the innuendo
17:02:11 <maerwald> MarcelineVQ: stop :P
17:02:20 <MarcelineVQ> roger
17:03:08 <erisco> I copy your roger
17:03:39 <MarcelineVQ> in the pipe, five by five
17:04:09 <maerwald> ... then again, don't stop :P
17:04:18 <hpc> dang ol haskell, i tell you hwat
17:23:12 * mekeor can't decide between #haskell-blah or #haskell-offtopic
17:23:23 <erisco> don't decide
17:23:47 <mekeor> how, erisco? how?
17:23:58 <Welkin> -bleh has been dead to use for a long time
17:24:03 <Welkin> over a year at least
17:24:06 <erisco> get one scoop of each flavour
17:24:09 <Welkin> dead to us*
17:24:16 <mekeor> Welkin: -bleh? or -blah?
17:24:17 <maerwald> both are poor offtopic channels
17:24:20 <Welkin> -blah
17:24:35 <Welkin> -offtopic is still a decent channel
17:24:42 <maerwald> no
17:25:07 <mekeor> let's agree on using #not-haskell instead of splitting up into -blah and -offtopic!
17:25:09 <erisco> one can be overflow for the other, like beginner is to this channel
17:25:29 <erisco> oh, a unifying standard, I like this
17:25:37 <jdreaver> Has there been a lot of performance improvements to the "time" package in recent years? Is thyme still a more performant alternative?
17:26:38 <Welkin> there is #haskell-overflow too
17:26:41 <maerwald> a proper offtopic channel is not actively moderated by people who try to produce themselves, but is maintained by an implicit culture. Haskell does not have such a channel
17:27:47 <mekeor> maerwald: would you like to found a new, unmoderated offtopic irc-channel for haskell?
17:28:04 <maerwald> I did not say unmoderated
17:29:21 <mekeor> maerwald: is there something you would like to propose? :)
17:30:08 <maerwald> I feel like there is too much political correctness cancer and OPs who make themselves more important than they are, distracting a natural culture of offoptic-ism
17:30:35 <maerwald> I know channels where this is not a problem, but I won't name them
17:44:42 <WinchellsM> Is there a way to make it so that GHCi shows your current working directory at all times?
17:45:02 <WinchellsM> I.e., replacing `Prelude >` with `/home/user >` or something like that?
17:47:33 <geekosaur> no
17:48:14 <tabemann> you could always write a, well, hssh
17:48:54 <maerwald> wonder if ghcid can do that
17:49:31 <geekosaur> oh, hey, right, tw escapes
17:49:33 <geekosaur> er
17:49:40 <geekosaur> they did add new escapes, if your ghci is new enough
17:49:43 <geekosaur> %w
17:49:55 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghci-cmd-:set prompt
17:49:59 <geekosaur> about time
17:50:50 <Fylwind> cabal: symbol lookup error: cabal: undefined symbol: <blah>  haha, this is what i get for installing Cabal using the same Cabal library that is being overwritten :P
17:54:02 <WinchellsM> Stack is placing me at GHCi 8.0.1
17:54:08 <WinchellsM> How do I get to 8.2.1?
17:54:21 <geekosaur> maybe a nightly resolver will have it?
17:54:42 <Welkin> 8.2.1 is only on nightly
17:54:44 <Welkin> not on lts yet
17:54:55 <Welkin> https://www.stackage.org/
17:55:12 <WinchellsM> Do I have to edit my `~/.stack/config.yaml`?
17:55:30 <Welkin> yes https://www.stackage.org/nightly-2017-09-20
17:57:12 <kadoban> WinchellsM: If you want to use GHC 8.2.1 outside of the context of a project, yes. If you have a stack.yaml that applies to whatever you're doing, you change it there.
17:57:51 <WinchellsM> I added `resolver: nightly-2018-09-20` to my ~.stack/config.yaml
17:57:55 <WinchellsM> Changed to my home directory
17:58:08 <WinchellsM> and ran `stack setup; stack upgrade; stack ghci` and it will puts me on the old version of GHCi ?
17:58:30 <tabemann> not 2018
18:04:44 <WinchellsM> stack --resolver nightly-2017-09-20 ghci
18:04:44 <WinchellsM> Unable to parse cabal file: FromString "This package requires at least Cabal version 2.0" Nothing
18:05:07 <WinchellsM> I ran `stack setup --upgrade-cabal` and it didn't help.
18:05:55 <kadoban> WinchellsM: Cabal 2.0 is very new. There isn't a stack release yet that supports it at all AFAIK. If your .cabal file isn't actually using anything that needs cabal 2.0, you can change it to not require it. Or if you actually need it, you could try the development version of stack, but it's not a release for a reason presumably.
18:19:24 <WinchellsM> `stack setup 8.2.1` succeeeds
18:19:33 <WinchellsM> But then when I `stack ghci` I'm back to 8.0.1
18:21:00 <kadoban> WinchellsM: This sounds like a project, since you mentioned a .cabal file. Did you change the stack.yaml file?
18:21:47 <kadoban> Also, you never really acknowledged tabemann's comment. Did you see it?
18:23:45 <tabemann> I assume WinchellsM probably just mistyped 2018
18:23:58 <tabemann> considering that afterwards they wrote 2017
18:24:59 <kadoban> Well, that was a different context, so it's unclear if that was on purpose or just they didn't typo that time. But you might be right.
18:24:59 <tabemann> I need to figure out more stuff to do with my genetically-programmed robot fighting arena
18:25:16 <tabemann> so I have an excuse to not do the big job of revamping its UI
18:27:20 <WinchellsM> @kadoban Sorry I mistyped 2018 in IRC
18:27:20 <lambdabot> Unknown command, try @list
18:28:27 <WinchellsM> I've been doing it at the home directory level but have also tried projects
18:29:11 <kadoban> WinchellsM: Well, picking one will probably make for more coherent troubleshooting.
18:29:14 <WinchellsM> Can you specify your cabal version to 2.0 or later in a stack.yaml?
18:29:22 <WinchellsM> I'll pick project level then :]
18:29:48 <MarcelineVQ> WinchellsM: not yet
18:29:54 <kadoban> Then in the stack.yaml, change the resolver to be that nightly version. Make sure you're actually changing it, not adding a new line. I'm not sure what it does when you have two resolver lines, at best it probably errors.
18:30:08 <MarcelineVQ> but such a thing is on the radar last I checked
18:30:34 <kadoban> The dev version of stack includes at least some support for Cabal 2.0, not sure how stable it is yet.
18:31:13 <WinchellsM> I keep getting Unable to parse cabal file: FromString "This package requires at least Cabal version 2.0" Nothing
18:40:45 <WinchellsM> It's because my version of stack was compiled with 1.24
18:40:53 <WinchellsM> Unclear how to get a version of stack that was compiled against 2.0
18:50:27 <sm> WinchellsM: "stack upgrade" is one way
18:51:36 <sm> they released a fix for this
18:51:45 <WinchellsM> `stack upgrade --source-only` is what I'm trying now
19:00:51 * hackagebot GenI 0.25.0 – A natural language generator (specifically, an FB-LTAG surface realiser) – https://hackage.haskell.org/package/GenI
19:06:57 * hackagebot geni-gui 0.25, geniserver 0.25, geni-util 0.25.0
19:06:57 * hackagebot  → https://hackage.haskell.org/packages/recent
19:23:11 * hackagebot bindings-GLFW 3.1.2.3 – Low-level bindings to GLFW OpenGL library – https://hackage.haskell.org/package/bindings-GLFW
19:43:51 <pie_> why did haskell drop c backend support?
19:44:13 <Welkin> iqubic: what...
19:44:15 <Welkin> er
19:44:18 <Welkin> pie_: what...
19:44:28 <Welkin> it compiles to native machine code
19:44:42 <Welkin> what wold c give you an advantage over?
19:44:49 <Myrl-saki> Welkin: Undefined behavior.
19:46:49 <rotaerk> well, it's because he wants to get better at C, and obviously haskell can write better C than any human alive
19:47:09 <rotaerk> teach me, haskell senpai!
19:47:13 <Welkin> you can generate c with a haskell dsl like ivory
19:47:19 <Welkin> embedded c*
19:47:19 <pie_> portability?
19:47:31 <rotaerk> but haskell's portable
19:47:35 <pie_> *architecture portability
19:47:58 <pie_> well youd have to write your own code generator
19:48:10 <pie_> i mean it doesnt really influence me i dont think, just wondering
19:48:30 <Welkin> hypothetical situations are not worth talking about here...
19:48:49 <Welkin> it's like the whole "posix-compliant shell scripts" debate
19:48:55 <Welkin> it's a non-issue
19:49:02 <Welkin> nothing is posix compliant anyway
19:49:11 <Welkin> if you need a shell, just install it
19:49:13 <filthy_causual2_> Well it used to be recomended for best optimizations to generate c, and then run gcc's c compiler with optimizations on it.
19:49:49 <Welkin> if you need to compile for multiple architextures, then just do it
19:49:56 <Welkin> architectures*
19:50:15 <Welkin> I do run into that issue since I develop on mac and deploy on linux
19:50:19 <Welkin> but it's not that big of a deal
19:50:35 <pie_> also what filthy_causual2_ said
19:50:50 <pie_> now you're replicating optimization knowledge
19:51:06 <pie_> ah wait doesnt haskell actually output llvm ir? crap i cant remember
19:51:08 <Welkin> depending on another languages compiler is not ideal
19:51:21 <Welkin> there is an llvm backend I believe
19:51:32 <lambda-11235> https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/code-generators.html
19:52:37 <pie_> thanks
19:53:15 <Welkin> code portability is a lie anyway
19:53:21 <lambda-11235> From that it appears the C backend was deprecated because it was slow and messy.
19:53:26 <byorgey> note that page is for an old version of GHC, but the LLVM backend is still there: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/codegens.html#llvm-code-generator-fllvm
19:55:25 <geekosaur> also there's a better llvm backend in development
19:55:34 <geekosaur> with some hope it'll make 8.4
19:56:48 <et09> how can i wipe all my haskell stuff besides the obvious in .ghc and .cabal ?  i'm getting all these errors with base packages like text-1.2.2.2, regex-, etc.
19:56:52 <et09> like, files missing, no idea why
19:59:05 <kadoban> et09: What build system do you use?
19:59:18 <et09> cabal
19:59:33 <kadoban> Then AFAIK that's it, except the stuff inside each sandbox or whatever
20:00:15 <et09> well, i delete those, do cabal update, and then... (waits for logs)
20:01:21 <et09> https://gist.github.com/djvs/df33bbf46b3a05d13582da022b7fc272
20:01:54 <Xioouves> Hi guys. I'm writing a small DSL right now and I'm implementing non-ASCII identifiers. Anyone that knows about lexers?
20:05:32 <kadoban> et09: Not sure. That's about where I'd nuke the world and start over, but I don't use cabal-install anymore. Someone else might know. I guess you could try that command it suggests, but I'm not sure what you're then going to do with the output of it either way.
20:05:42 <et09> i am nuking the world and starting over atm 
20:05:56 <et09> recommended haskell ecosystem?
20:06:03 <et09> ditching the whole archlinux way of doing it
20:06:11 <kadoban> I like 'stack' personally
20:06:28 <et09> i've used it, time to try that for a while
20:06:50 <Welkin> stack is great
20:06:58 <Welkin> you really can't go wrong with it
20:07:10 <Myrl-saki> (But nix is better.)
20:07:26 <Welkin> Myrl-saki: if you can get it working
20:07:31 <Myrl-saki> Welkin: Yep. :/
20:07:37 <Welkin> it hasn't been better in my experience
20:07:40 <et09> really looking for no more headaches
20:07:44 <Welkin> because most of the time it doesn't even work
20:07:44 <pie_> pfffff
20:07:45 <Myrl-saki> I'd go with stack.
20:07:59 <Welkin> stack has never let me down yet
20:08:02 <Myrl-saki> Welkin: The problem with nix is that there's no lts whatsoever.
20:08:10 <pie_> doesnt nix use stack?
20:08:15 <Myrl-saki> pie_: It can.
20:08:21 <Myrl-saki> pie_: Well, stack can use nix.
20:08:39 <Myrl-saki> pie_: But it'd be a "stack for Haskell libs, and nix for system libs."
20:08:43 <et09> i can't stand i3 :(
20:08:51 <Myrl-saki> pie_: When you could do "nix for Haskell + system libs"
20:09:07 <Welkin> et09: try xmonad or bspwm
20:09:18 <et09> i use xmonad
20:09:27 <et09> but something just like broke down in the last hour
20:09:35 <Myrl-saki> pie_: The problem with this is that nix doesn't exactly have a Haskell lts(there's a nix lts, but I'm not sure how well it works.).
20:09:38 <et09> it's been hell since about june
20:09:45 <Myrl-saki> et09: How?
20:09:55 <geekosaur> et09, arch?
20:10:07 <et09> yeah
20:10:36 <geekosaur> yeh, arch has been hosed since around june, and everything they do just seems to make things worse
20:10:37 <et09> i've complained to like twenty people, no idea why it's not fixed yet ;)
20:10:47 <Welkin> lol
20:10:51 <pie_> aha...
20:10:58 <geekosaur> I'm about >< that close to declaring arch unsupported
20:11:01 <Welkin> I got one of my laptops all set up with arch dual booted
20:11:06 <geekosaur> (for xmonad)
20:11:08 <Welkin> and I haven't used it since I set it up
20:11:14 <Welkin> I use the windows partition to play games
20:11:20 <Welkin> but I do all my work on macbooks
20:11:36 <et09> wow my cabal was in /opt wtf
20:11:42 <et09> maybe that was the issue
20:13:11 <et09> one more time...
20:13:53 <rotaerk> I tried arch for a while, but well... I just can't stand its update model
20:14:05 <rotaerk> it's like living on the edge of a cliff
20:14:07 <et09> that's why i like it, most of the time
20:14:16 <et09> but i'm big into mountain climbing 
20:15:57 <et09> wow no luck.  this is so messed up i don't even know how to start over
20:16:09 <et09> where do packages get registered if you do --global
20:16:57 <rotaerk> Welkin, Myrl-saki, I've been using nix lately, and I don't see any reason to add in stack; seems completely redundant
20:17:18 <rotaerk> however, I will say that while nix makes building quite reliable, it certainly doesn't simplify configuration...
20:18:26 <Welkin> /usr/share/lib/ghc or something
20:18:26 <rotaerk> but I've gotten used to it at this point, I think
20:19:20 <Welkin> rotaerk: you have accepted a poor experience
20:19:22 <Welkin> that's not good
20:19:29 <et09> no 'ghc' in /usr/share except ./doc/ghc
20:19:56 <Welkin> et09: it's somewhere in /
20:19:57 <Welkin> :P
20:20:07 <et09> i'll just delete the whole thing then
20:20:17 <Welkin> I haven't had to deal with removing ghc/cabal in a long time
20:20:34 <Welkin> since I started using stack (and rarely nix) which are both trivial to remove if you need to
20:20:43 <rotaerk> Welkin, it's more that I've found ways to deal with the kinds of problems I had with it
20:21:55 <rotaerk> e.g. I've made it easy to use github to pull in newer versions of packages than are present in nixpkgs
20:22:20 <rotaerk> of course it's tedious when you have a cascade of dependencies to resolve that way
20:22:38 <rotaerk> like, the way reflex-platform is designed...
20:23:07 <rotaerk> I really hope that once development of reflex settles down, they do away with reflex platform and just make it play nicely with the latest versions in hackage
20:25:53 <Myrl-saki> rotaerk: Yep.
20:26:05 <Myrl-saki> rotaerk: That's why I no longer use `nix`.
20:26:13 <Myrl-saki> Err
20:26:15 <Myrl-saki> `stack`*
20:27:04 <Myrl-saki> rotaerk: But `stack` is also convenient that you can easily change the repo to use.
20:27:47 <rotaerk> Myrl-saki, what do you mean "change the repo"?
20:28:13 <Myrl-saki> rotaerk: `lts` `nightly` etc.
20:28:34 <Myrl-saki> rotaerk: And adding packages is way easier too.
20:28:36 <rotaerk> well, you can sortof do that with nixpkgs too
20:28:43 <Myrl-saki> rotaerk: Exactly. Sort of.
20:28:51 <rotaerk> I mean, just import from the latest nixpkgs revision
20:28:55 <et09> i can use stack to set up like a "sandbox" right?  it's different than a project (stack new [...]) ?
20:29:38 <kadoban> et09: You don't do sandboxes manually, they're implicit
20:29:50 <Myrl-saki> rotaerk: I mean more about the lts ones. And for some reason, either nix is using an outdated version of haskell webkit, or the dependency management broke, because the newest version should support webkit 16.
20:29:59 <et09> so what's my strategy heere
20:30:13 <kadoban> et09: Making a new project? 'stack new' is a decent place to start
20:30:19 <et09> got it
20:30:27 <rotaerk> isn't the lts just a "stable" snapshot of hackage basically?
20:30:37 <rotaerk> maybe I misunderstood what it' is
20:30:47 <Myrl-saki> rotaerk: Yep, it is.
20:30:54 <Myrl-saki> At least that's also how I understand it.
20:30:54 <et09> hmm... it might actually be working
20:31:59 <kadoban> It's a set of versioned packages that are known to all build together, yeah.
20:31:59 <Myrl-saki> anyways, I have somewhere to be.
20:32:05 <rotaerk> cya
20:32:57 <et09> wow, never using cabal again 
20:37:10 * hackagebot geni-gui 0.25.1 – GenI graphical user interface – https://hackage.haskell.org/package/geni-gui
20:54:01 <et09_> now how do i get xmonad to cooperate with stack?
20:54:08 <et09_> it starts but seems to be using the old cabal ecosystem?
20:55:25 <Welkin> you will want to completely remove your old cabal
20:58:20 <iqubic> et09_: I too want this. Mostly so that syntax highlighting with emacs will work, but also because I might want to stop depending on my package manager for updates to XMonad.
21:04:51 <et09> ok got it all working
21:04:59 <et09> for the first time in 6 mo (thumbs up)
21:15:33 <kadoban> et09: Nice
21:16:28 <iqubic> et09: did you get stack and xmonad to play nicely? If so, how?
21:18:07 <et09> made a 'xmonadecosystem' project, installed a whole bunch of dependencies, then stack exec xmonad + stack exec xmobar
21:18:15 <iqubic> See for the few programs I have that use Haskell confit files, I don't actually know the proper way to get emacs to not throw errors when I import something from a library not in scope to use in the config file.
21:18:25 <et09> xmobar miraculously instlaled with stack install xmobar --flag xmobar:all_extensions
21:19:13 <iqubic> et09: what do you have in your .xinit to start xmonad?
21:19:23 <et09> stack exec xmonad
21:20:08 <iqubic> And where do your configure files go? In the default xmonad place?
21:20:19 <iqubic> And does that work for you?
21:20:31 <et09> default place yep.  had to delete the old binaries
21:20:34 <et09> works great so far
21:21:12 <rotaerk> you aware there's a #xmonad channel?
21:21:18 <iqubic> rotaerk: yeah.
21:22:16 <iqubic> et09: old binaries being the stuff your distro's package manger installed? Or something else?
21:23:10 <et09> from cabal
21:23:29 <et09> stack's a lot like npm, very nice
21:23:59 <iqubic> Ah. I see. I should try that. Do you have xmonad and xmobar installed in the same stack project or what? How would that work?
21:24:31 <Welkin> et09: it's better than npm
21:24:53 <Welkin> also, yarn is better than npm if you are in the js ecosystem
21:25:07 <iqubic> However my laptop is being repaired now, so I can't actually get any of this set-up right now.
21:25:39 <et09> yes iqubic same stack
21:25:52 <iqubic> Also, what benefits does having xmonad as a stack project actually work?
21:26:26 <iqubic> et09: how did you install multiple things in one project? Isn't that kinda hard to do?
21:26:44 <et09> iqubic: stack install and some extra-deps...they went into ~/.local/bin though
21:26:51 <iqubic> s/work/give you/
21:27:41 <iqubic> et09: were the extra deeps dealt with automatically, or did you have to manually install those?
21:27:47 <et09> well it just keeps me out of the arch haskell ecosystem, which is garbage
21:27:56 <et09> extra-deps are due to ambiguous dependencies i guess
21:28:31 <kadoban> extra-deps are typically required when you need to use something that's not in the resolver (ie the resolver specifies no version for them)
21:28:42 <iqubic> Also, if you put "stack exec xmonad" in your .xinit, how does stack know where to find the program?
21:29:08 <kadoban> Presumably it's on your $PATH
21:29:22 <et09> yep 
21:29:53 <iqubic> Now, is it possible to avoid installing ghc through my package manager, and just use stack's version of ghc? I want to distance myself from the gentoo Haskell ecosystem, because it is really terrible.
21:30:08 <Welkin> iqubic: yes
21:30:18 <iqubic> How does that work?
21:30:19 <Welkin> you can have a global ghc installed using stack if you wish
21:30:28 <Welkin> along with as many local ones as you want
21:30:29 <kadoban> stack certainly doesn't need (or want) you to install GHC yourself or use your package manager's one
21:30:33 <et09> i went with a ghc installed by stack
21:30:35 <et09> 8.0.2
21:30:50 <et09> hence the npm/nvm analogy
21:31:00 <Welkin> stack install --install-ghc
21:31:09 <iqubic> Welkin: I'd like that. I'll put these questions on hold, and ask again when I have my laptop back from being repaired.
21:31:31 <iqubic> Because I can't actually implement the solutions that are being given ATM.
21:32:09 <Welkin> also see `stack setup --help`
21:32:38 <Welkin> iqubic: https://docs.haskellstack.org/en/stable/README/
21:32:52 <iqubic> I can't right now wel Welkin. My laptop is being repaired.
21:33:03 <Welkin> but you can read the docs
21:34:03 * hackagebot cryptocompare 0.0.3
21:34:03 * hackagebot  → https://hackage.haskell.org/packages/recent
21:34:39 <iqubic>  Well in, I have a large list of things I want to do with my laptop once I get it back from being repaired.
21:34:41 <Lira> hello!
21:36:01 <Lira> Can I make my stack ghci syntax highlighted code?
21:36:16 <iqubic> Hey Lira.
21:36:19 <Lira> Anyone?
21:36:29 <kadoban> Lira: Not really understanding the question
21:36:31 <Lira> hei iqubic!!
21:36:59 <iqubic> Lira: wouldn't that depend on the terminal you use?
21:37:44 <Lira> I would like to hilighted the code as I type on iterm
21:38:05 <kadoban> I don't think GHCi does that.
21:38:28 <Lira> I am using stack GHCi
21:38:32 <iqubic> Yeah, never heard of that feature myself.
21:38:43 <iqubic> Lira: that's the same thing in this case.
21:38:48 <kadoban> stack just wraps the usual GHCi, it doesn't change its base behavior really at all.
21:38:50 <boj> Lira: maybe https://wiki.haskell.org/GHCi_in_colour
21:39:28 <Lira> boj, Great!
21:40:10 <iqubic> Does that work Lira?
21:40:23 <Lira> yes!
21:40:38 <Lira> thank you guys!!!
21:40:50 <iqubic> Well color me surprised.
21:41:06 <iqubic> And color your Haskell syntax too.
21:41:35 <Lira> It better to see the code
21:42:02 <kadoban> I never write much code in ghci, so I haven't really cared if it's syntax highlighted or not.
21:42:48 <Lira> I started learning the haskell this week
21:43:08 <Lira> sometime I run the code to see what happens 
21:43:34 <kadoban> I use ghci, I just don't write much code there. I write code in files and load them into ghci and do minor playing with it.
21:44:17 <Lira> do you use vim or IDE like Intellij?
21:44:28 <kadoban> vim
21:44:44 <Lira> I came from Java and Scala 
21:44:59 <Lira> I know just the basic commands on vim lol
21:45:34 <boj> Lira: there are other editors like Atom or Visual Studio Code which work well with Haskell
21:46:05 <Lira> Intellij is a great IDE. So I am quite dependent on it
21:46:33 <boj> does it have a haskell plugin?
21:46:34 <Lira> I use Visual Studio Code, but I dont enable the plugins
21:46:41 <Lira> It's a great idea!
21:46:50 <tabemann> I use straight GNU Emacs with haskell-mode myself
21:47:04 <Lira> boj, it does!
21:47:10 <boj> there you go :)
21:47:45 * tabemann is too much of a traditionalist to use an IDE if he can help it
21:48:06 <boj> same. i'm a vim nerd, but wanted emacs power, so settled on spacemacs
21:48:48 <Welkin> Lira: there are two IDEs written in haskell for haskell
21:48:58 <Lira> really!
21:49:04 <tabemann> I've tried yi, but it feels very buggy and limited
21:49:05 <Lira> which names?
21:49:05 <Welkin> Yi and leksah
21:49:13 <Lira> lol
21:49:36 <Lira> I will try with vscode
21:49:36 <Welkin> I personally use emacs with haskell-mode
21:50:38 <dmwit> What does cabal use to detect C libraries? I'm seeing `cabal: Missing dependencies on foreign libraries: * Missing C libraries: blas, lapack`, but `pkg-config --modversion blas lapack` succeeds.
21:51:01 <monochrom> should be pkg-config but meh
21:51:20 <pacak> dmwit: pkgconfig ?
21:51:25 <tabemann> it uses pkg-config
21:51:35 <Lira> Welkin: I'll give a shot too
21:51:58 <dmwit> tabemann: How should I interpret the conflicting information I am seeing, then?
21:52:08 <Lira> see you guys!
21:53:09 <tabemann> dmwit: you probably don't have the development packages installed
21:53:26 <tabemann> there should be something like a libblas-dev or a liblapack-dev that you need to install
21:53:29 <dmwit> I definitely don't. I don't have root on this machine. I have built and installed the two packages myself.
21:54:49 <cocreature> dmwit: which Haskell packages depend on those C libs?
21:54:53 <dmwit> hmatrix
21:55:11 <iqubic>  My timezone is set correctly. I have verified that already.
21:55:21 <iqubic> Sorry, wrong channel
21:55:28 <dmwit> I have also tried adding --extra-lib-dirs and --extra-include-dirs to the correct places, which doesn't seem to help.
21:56:03 <monochrom> To try to reproduce your problem, I uninstalled libgsl-dev and liblapack-dev to see what pkg-config says.
21:56:21 <monochrom> pkg-config --modversion blas still says "3.7.0".
21:56:51 <dmwit> hah
21:57:05 <monochrom> pkg-config --modversion lapack is more interesting. It says "not found" and "Perhaps you should add the directory containing `lapack.pc'
21:57:05 <monochrom>  to the PKG_CONFIG_PATH environment variable"
21:58:09 <dmwit> `strace -e process cabal new-build` is surprisingly unhelpful.
21:58:10 <monochrom> This is very likely relevant if you plan to use your own installation of liblapack-dev. Because how else would pkg-config know.
21:58:32 <cocreature> unless you use pkgconfig-depends I don’t think cabal cares about pkgconfig?
21:58:36 <dmwit> monochrom: As I said above: both `pkg-config --modversion blas` and `pkg-config --modversion lapack` succeed for me.
21:58:46 <monochrom> And now, I will install them again because I use hmatrix too (but I saw no problem).
21:58:51 <cocreature> and hmatrix does not use that, it just uses extra-libraries
21:59:03 <piyush-kurur> Builders are now part of bytestring library, is it true that blaze builder project is no more actively working on the builder formalism? 
21:59:14 <dmwit> cocreature: So, we are back to my original question: what does cabal use to detect C libraries?
21:59:31 <cocreature> dmwit: have you tried -v3?
21:59:49 <dmwit> I will do so now.
22:00:30 <dmwit> (Give me a moment. For some reason it takes ages for cabal new-build to discover that the very first package in its install plan can't be configured. This mystifies me.)
22:00:40 <hamishmack> dmwit: with cabal new-build you need to add extra-lid-dirs to the cabal.project file
22:01:12 <dmwit> oh
22:01:22 <dmwit> I didn't even consider the fact that I should mention I was using new-build. Apologies.
22:01:39 <hamishmack> noticed it in your strace command
22:01:48 <monochrom> Heh
22:01:59 <cocreature> hamishmack: the cli option should work too, no?
22:02:10 <hamishmack> you need to add it it in a package section for the package you want it on
22:02:13 <dmwit> Wait, so `cabal new-build --extra-lib-dirs blah` just silently throws away `blah`? =/
22:02:21 <monochrom> But that's still strange. Because it is not like hmatrix is my project.
22:02:34 <cocreature> oh so it’s adding it to the wrong package
22:03:33 <hamishmack> https://github.com/haskell/cabal/issues/2997
22:04:56 <dmwit> hamishmack: thanks
22:05:47 <dmwit> hamishmack++ It just transitioned from "configuring hmatrix" to "building hmatrix"
22:07:44 <dmwit> hum, "relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC"
22:07:54 <dmwit> I wonder whether that means to add -fPIC when compiling blas or hmatrix.
22:11:18 <monochrom> GHC and cabal-install already adds -fPIC where necessary.
22:12:47 <cocreature> dmwit: where did you get GHC from? I’ve seen that issue when stack fetched a bindist that wasn’t meant for my system
22:12:51 <monochrom> OTOH blas's makefile would add -fPIC at all the right places too. How else could it generate a *.so.
22:13:05 <dmwit> monochrom: It seems to be complaining about the .a anyway.
22:13:16 <dmwit> I've added -DCMAKE_POSITION_INDEPENDENT_CODE=ON, let's see what happens.
22:13:32 <dmwit> cocreature: It's the deb7 release from the GHC release page (for 8.0.2).
22:13:41 <cocreature> dmwit: and you are on deb7?
22:13:45 <dmwit> nope =P
22:13:51 <dmwit> SN, AFU
22:14:33 <cocreature> SN, AFU is the name of an OS? :)
22:14:56 <dmwit> CentOS 6.8, but with a newer hand-build GMP because other dependencies need that, so I can't use the official GHC release made for CentOS
22:15:49 <dmwit> Situation Normal, All *ahem* Screwed Up
22:17:23 <cocreature> dmwit: I suspect that the default options of gcc are different on centos than they are on deb7. e.g. for arch the thing that caused problems was the change to default to -fPIC and -fPIE https://git.archlinux.org/svntogit/packages.git/commit/trunk?h=packages/gcc&id=5936710c764016ce306f9cb975056e5b7605a65b
22:17:56 <monochrom> Oh! That may be it.
22:18:35 <monochrom> Because when GHC (and cabal-install) aims at *.a, it definitely doesn't add -fPIC
22:19:20 <monochrom> But if blas's *.a came from *.o's that had -fPIC, you now have a mismatch.
22:19:48 <dmwit> Err, you are saying I should turn PIC *off* when building lapack?
22:20:05 <monochrom> No, it's probably worse than that.
22:20:30 <cocreature> what I’m saying is that using bindists made for other distros can cause problems, so you might want to consider building your own
22:20:31 <monochrom> No, wait, what I said makes no sense.
22:21:03 <dmwit> cocreature: I was hoping to build my actual tool and start it running and then sleep while it thought hard for a few hours. =/
22:21:39 <dmwit> GHC builds are hours long, right?
22:21:54 <dmwit> Well. Anyway thanks for the advice. It's not your fault that I'm in a crappy situation.
22:22:13 <cocreature> I think it takes something like 50minutes on my laptop which is a few years old
22:22:58 <dmwit> Hey, I think hmatrix actually built once I asked for PIC while building lapack!
22:23:30 <dmwit> yay
22:23:56 <cocreature> debian defaults to -fPIC these days so what’s happening is probably the opposite of what monochrom suggested:  lapack is built without -fPIC but GHC tries to build with it
22:26:04 <dmwit> cocreature++ monochrom++ for -fPIC discussions
22:26:37 <monochrom> I'm on Ubuntu. Do you happen to know whether its gcc defaults to -fPIC too? Or how do I find out?
22:27:36 <monochrom> I'm also using the GHC bindist for deb8. There has not been a problem. (And I have went through cabal-installing a lot of packages listed in Haskell Platform.)
22:28:10 <dmwit> From the man page: "when -fPIC is set, the macros __pic__ and __PIC__ are defined to 2"
22:28:15 <dmwit> So that could be an easy test.
22:28:17 <monochrom> (And hmatrix too. Though I just took libgsl-dev and liblapakc-dev from Ubuntu.)
22:28:24 <monochrom> Ah.
22:28:56 <dmwit> __pie__ and __PIE__ are set to 1 for -fpie and 2 for -fPIE
22:28:58 <iqubic> Just write a program to print the values of those macros.
22:29:21 <dmwit> Oh, 1 vs. 2 is upper vs. lower for -fpic as well, I just didn't read the section on -fpic. =P
22:31:11 <iqubic> I have no idea what any of these flags do at all
22:31:26 <monochrom> It prints out 2.
22:31:53 <iqubic> So the default is -fPIC it looks like.
22:32:45 <dmwit> Having read only one paragraph about the difference between pic/pie and PIC/PIE (so you *know* I'm totally an expert), -fpic and -fpie seem like a bad idea.
22:34:50 <monochrom> Although, the difference probably doesn't apply to x86.
22:35:41 <dmwit> Yeesh, the directory structure in dist-newstyle is one only its programmer could love.
22:36:28 <dmwit> I could four copies of my package name in the path I have to type to run my program, and two copies of the word "build".
22:36:33 <monochrom> Just go one level down to "build" and it's OK again. I think.
22:36:34 <dmwit> s/could/count/
22:36:50 <monochrom> Oh, yeah, there is that.
22:37:33 <dmwit> (Actually I suspect it's two copies of my package name and two copies of my executable name, which happens to be the same as the package name. But still. Two of everything.)
22:37:37 <monochrom> Are you using the very latest (but unreleased) version of cabal-install from github? Because it implements "new-run" that solves it for you.
22:38:05 <dmwit> No, I'm not. I could consider it, but I plan to just copy the executable to ~/.cabal/bin and move on to phase 3 (?????).
22:38:11 <monochrom> (In the released version "new-run" is aliased to "new-build" or something.)
22:38:19 <monochrom> Yeah.
22:38:30 <monochrom> Enough compiling today.
22:39:24 <monochrom> Anyway I normally just start with dist-newstyle/build then tab my way through.
22:39:53 <dmwit> yeah
22:40:09 <ongy> oh new-run is on HEAD now? cool
22:41:29 <Zemyla> What's the name of the property that Haskell has where there's only one implementation of a typeclass for a type?
22:42:38 <iqubic> Zemyla: are you asking for a specific language pragma, or what?
22:43:06 <dmwit> Zemyla: http://blog.ezyang.com/2014/07/type-classes-confluence-coherence-global-uniqueness/
22:43:14 <dmwit> tl;dr "global uniqueness"
22:43:19 <Zemyla> No, it's just a word. Like, Haskell typeclasses are _, so there's only one possible - there you go.
22:43:21 <monochrom> From the example in Cabal User Guide: "dist-newstyle/build/x86_64-linux/ghc-8.0.1/p-0.1/c/pexe/build/pexe/pexe" where p is the package name and pexe is the exe name (in p.cabal, has "executable pexe" section).
22:44:31 <monochrom> globalunique :)
22:44:51 <monochrom> More seriously, probably "unique" is enough.
22:45:13 <monochrom> But you don't want "typeclasses are unique". You want "instances are unique".
22:45:33 <monochrom> Also: In Haskell 98 and 2010, it's "type class", two words.
22:45:40 <dmwit> Zemyla: Slightly longer tl;dr: "global uniqueness, but some people say confluent or coherent"
22:45:48 <monochrom> I don't really understand why everyone Germanizes it.
22:46:02 <dmwit> monochrom: huh!
22:46:09 <monochrom> Ah yeah "confluent" is also a good word.
22:46:27 <dmwit> Why is confluent a good word for that?
22:47:02 <dmwit> There's not really a rewrite system in the picture.
22:47:43 <dmwit> (In fact, I came on this blog post because I was thinking "confluent", but then when I stopped to think about what "confluent" meant I was no longer sure I had the right property, and so googled it.)
22:47:54 <monochrom> Oh haha ezyang is precisely saying I shouldn't use "confluent".
23:24:50 <cocreature> monochrom: ffr if you compile a hello world C program using "gcc -Q -v" you’ll see the flags it’s actually using
23:27:28 * hackagebot hasql 0.19.18.2 – An efficient PostgreSQL driver and a flexible mapping API – https://hackage.haskell.org/package/hasql
23:33:56 <dmwit> cocreature: Neat. I think I could have read the whole manpage and still not come out the other side knowing that.
23:40:33 <jared-w> yeah I had no idea that was a thing :p
23:41:14 * jared-w has been installing/compiling reflex related stuff for over 6 hours now
23:41:30 <cocreature> dmwit: I think I got that from stackoverflow at some point :)
23:43:28 <jared-w> Also this linker is so goddamn slow. I have 27k things to link and I can almost verbally keep up with the counter ಠ_ಠ
23:44:10 <cocreature> jared-w: the ghcjs “linker”?
23:44:57 <jared-w> yeah...
23:45:00 <jared-w> (I think)
23:45:36 <jared-w> I'm on line 3600 of "CXX obj/$stuff"
23:46:39 <jared-w> I wanted to play with this stuff today :( didn't expect it all to take this long to get started... lol. Of course part of it is likely my fault for using Arch Linux
23:46:56 <cocreature> jared-w: can’t you just use reflex-platform? that should use binary caches for most stuff
23:48:25 <jared-w> I installed the reflex-platform, then I cloned the repo that queensland FP Lab has
23:49:07 <jared-w> It doesn't seem to be the case that the queensland FP lab repo is using any of the caching from reflex-platform? Or it is? I'm not really sure and the instructions for how to do this are really lacking in sanity checks 
23:50:24 <jared-w> Or should I have cloned the reflex-tutorial repo /inside/ the reflex-platform directory?
23:50:44 <cocreature> https://github.com/reflex-frp/reflex-platform/blob/develop/HACKING.md#hacking-on-the-reflex-platform
23:51:14 <cocreature> so you should be using work-on ghcjs path/to/reflex-tutorial
23:51:21 <jared-w> hmm...
23:51:59 <jared-w> https://blog.qfpl.io/posts/reflex/basics/exercises/introduction/
23:52:14 <jared-w> So this is the tutorial I'm going off of for funsies.
23:52:18 <cocreature> although you might need to make some changes to the default.nix in the reflex-tutorial. I’m not sure what exactly reflex expects to see here
23:52:30 <pimlu> how do you debug the logic of large haskell applications, the scale at which people would want/need stepping debuggers in imperative languages? trace is helpful but I doubt that's the solution
23:52:40 <jared-w> It said to checkout a copy of the reflex platform, then run ./try-reflex, then clone the reflex tutorial and run nix-shell
23:52:49 <opqdonut> pimlu: there's a stepping debugger in ghci
23:53:06 <opqdonut> pimlu: it takes some getting used to, laziness makes stepping a bit weird
23:53:11 <cocreature> pimlu: tbh I think trace and testing stuff in ghci is how most people debug things
23:53:37 <cocreature> as opqdonut mentioned there is a stepping debugger but ime it’s far less useful than stepping debuggers for other languages
23:53:42 <pimlu> cocreature: yeah I heard a lot of people run their functions manually in small increments in ghci
23:53:43 <opqdonut> pimlu: but I almost never use the debugger, unit tests for pure functions are an easy way to catch errors
23:53:57 <pimlu> opqdonut: I'll have to try that
23:54:09 <jared-w> Yeah and, tbh, in Haskell, the language is so useful for equational reasoning that pen and paper are as effective for most people as a time-traveling debugger is for javascript
23:54:23 <opqdonut> indeed
23:54:42 <c_wraith> Heck.  If you're careful, choosing types correctly can do most of the work.
23:54:56 <jared-w> Like, I don't even know how to use the debugger because I've yet to ever need it...
23:55:17 * jared-w says while not having ever worked on a large haskell program
23:55:39 <sternmull> but what do you do when you have a bug that only shows up in production... and only sometimes? For C i can set a breakpoint or maybe i get a crashdump that i can analyze offline. Not having such possibilities in haskell scares me.
23:56:10 <cocreature> tbf part of Haskellers’ aversion to debuggers is also just stockholm syndrome. we don’t have good debuggers so we tell ourselves we don’t need them :)
23:56:15 <jared-w> Those don't really tend to show up in the language. You tend to get either space leaks, or optimization issues or... idk what else
23:56:33 <pimlu> cocreature: yeah, while I would say there's less need, I kind of agree lol
23:57:20 <cocreature> pimlu: that said I think there’s definitely less of a need for it than in other languages
23:57:23 <jared-w> sternmull: What I'd do in that case is I'd track down the functions that are the issue and then I'd test the shit out of them with quickCheck, maybe Hedgehog as well
23:58:29 <jared-w> I don't really know of any Haskell developers who have been stuck on a super nasty bug for more than a few days at max; I've read stories of C/C++ bugs that took months to track down, though
23:58:32 <pimlu> the thing is, I spent the first 5 years of my life programming as a kid having no idea what a debugger was and just dumbly using print all the time
23:58:37 <pimlu> so it wouldn't even be far off lmao
23:58:59 <jared-w> pffh half the time I still use print in C/Java :p
23:59:49 <cocreature> jared-w: you’ve not read a lot of GHC bug reports, have you? :)
