00:03:21 <Axman6> is that just multiFilter ps xs = map (\p -> filter p xs) ps?
00:03:46 <cocreature> yeah I probably wouldn’t make a separate function for that
00:03:56 <cocreature> unless you can specialize it and give it a better name
00:04:13 <Axman6> @pl multiFilter ps xs = map (\p -> filter p xs) ps
00:04:13 <lambdabot> multiFilter = flip (map . flip filter)
00:04:18 <cocreature> but there’s nothing fundamentally wrong with that operation
00:05:32 <saurabhnanda> does anyone know how to print overlapping instances in intero / repl?
00:06:02 <halogenandtoast> How is it that `f (g x) x` can become `f =<< g` is this using the monad instance of arrow?
00:06:06 <saurabhnanda> “two instances involving out-of-scope types (use -fprint-potential-instances to see them all)” // {-# OPTIONS_GHC -fprint-potential-instances #-} // doesn’t seem to print the potential instances in th REPL
00:06:06 <sullyj3> Axman6: I guess so, but the idea is to do it in a single pass over the list
00:06:21 <erisco> halogenandtoast, of (->)a
00:06:30 <halogenandtoast> yes that arrow
00:06:32 <dmj`> saurabhnanda: you should get a warning about them if -Wall is in your cabal file
00:06:32 <Axman6> halogenandtoast: it's the monad instance for ((->) r) yes, ie, reader
00:07:02 <halogenandtoast> Okay, updating my vocabulary.
00:07:07 <sullyj3> Axman6: specifically a single pass over xs
00:07:57 <saurabhnanda> dmj`: I got a warning when I was defining the overlapping instance, which I resolved with the {-# OVERLAPS #-} pragma. But even with the overlap, the call-site should have been able to resolve to the most specific instance. Which is not happening. How do I print the two instances that are confusing GHC?
00:08:17 <Axman6> sullyj3: that's actually not likely to be much more efficient, if at all
00:08:57 <dmj`> saurabhnanda: if you remove the overlaps pragma, does it show them in the repl
00:09:03 <halogenandtoast> Okay found that source:  f >>= k = \ r -> k (f r) r any particular reason why that's the instance for Monad?
00:09:25 <cocreature> halogenandtoast: it’s typechecks :)
00:09:27 <cocreature> *it
00:09:29 <halogenandtoast> I'm assuming there was no other implementation that would fit the rules, but does it have particular qualities that make it good?
00:10:07 <erisco> halogenandtoast, find another implementation which has the same type
00:10:22 <cocreature> halogenandtoast: it’s useful for Reader (which is just a newtype around ((->) r))
00:10:32 <Axman6> halogenandtoast: if you can find another implementation which typechecks and doesn't break the laws, I'd like to know (I don't actually know if there are other possiblities, but I would guess there aren't)
00:11:08 <Axman6> :t (>>=) `asAppliedTo` show
00:11:10 <lambdabot> Show a => (a -> String) -> (String -> a -> b) -> a -> b
00:12:31 <halogenandtoast> Axman6: I'm pretty sure there isn't since (a -> m b) -> m a -> m b becomes (a -> r -> b) -> (r -> a) -> r -> b
00:12:58 <Axman6> yep
00:13:12 <erisco> the funny thing about "pretty sure" is that it means "not sure"
00:13:15 <saurabhnanda> shouldn't GHC be able to resolve to the most specific typeclass instance in this case -- https://gist.github.com/saurabhnanda/2075a2f96c8c83872d05b576678e5024
00:13:34 <Axman6> basically, Monad and Applicative for ((->) r) is the "I have several functions which take the same argument" monad
00:13:34 <halogenandtoast> erisco: I've never 100% certain of anything.
00:13:43 <Axman6> uh, s/monad/pattern I guess
00:13:44 <cocreature> saurabhnanda: GHC doesn’t automatically resolve to the most specific instance. you need OVERLAPPABLE or OVERLAPPING pragmas for that
00:14:01 <erisco> or OVERLAPS
00:14:33 <saurabhnanda> cocreature: which one of the instances should have these pragma's? any one of them, or all of them?
00:15:51 <cocreature> one of them is sufficient. either use OVERLAPPING on the more specific instance or OVERLAPPABLE on the general one
00:15:52 * saurabhnanda is waiting for magic to happen after randomly sprinkling OVERLAPS pragmas
00:16:02 <cocreature> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=overlappable#overlapping-instances 
00:19:56 <saurabhnanda> OVERLAPPABLE seems to be doing the trick. But why is it complaining about "out of scope" instances. It's forcing me to import Opaleye to be able to compile. It's good if one of the overlapping instances is out of scope, right? why is GHC complicating its work?
00:22:03 <saurabhnanda> nope, even that is not working.
00:47:53 <_sras_> What are my options for speeding up the bootstraping of stack? Maining the downloading of hackage package index and downloading of ghc?
00:55:58 <_sras_> What are my options for speeding up the bootstraping of stack? Mainly the downloading of hackage package index and downloading of ghc?
00:57:11 <digitalkiwi> the same as they were 8 minutes ago
00:59:47 <ertes-w> o
01:04:44 <bartavelle> _sras_: you can archive your ~/.stack directory just after these actions and redeploy it later ?
01:14:20 <fizbin> Is there any way to say in one's cabal file "this depends on base >= 4.8 or on both base and transformers"?
01:15:27 <fizbin> Sticking "build-depends: transformers" into a "if impl(ghc < 7.8)" block seems like it isn't quite saying what I really mean.
01:17:41 <ongy> why not? It says to additionally depend on transformers if the version does not meet >= 4.8
01:20:21 <jle`> fizbin: usually you'd use something like a "compat" package
01:20:38 <_sras_> bartavelle: Does it work across OSes? If not, Is there anyway to cache just the stuff that gets downloaded?
01:20:48 <jle`> fizbin: http://hackage.haskell.org/package/transformers-compat
01:21:07 <jle`> fizbin: http://hackage.haskell.org/package/base-compat
01:21:34 <fizbin> ongy: Because that's using the implicit assumption that ghc 7.8 means base 4.8.
01:22:12 <jle`> ghc versions and base versions are fixed together, anyway
01:22:37 <jle`> base version and ghc versions are basically proxies for each other
01:23:29 <jle`> but yeah it looks like you're running into an issue that base-compat or transformers-compat was made to solve
01:23:34 <fizbin> jle`: Unfortunately, base-compat doesn't provide what I use (Data.Functor.Identity)
01:24:55 <jle`> in this specific case it's probably fine to depend on transformers
01:25:05 <jle`> since ghc essentially comes with transformers
01:25:41 <erisco> x⃗
01:27:08 <ongy> from how I understand the way cabal manages flags, you could set them to automatic and have the >=4.8 under one flag and the combined onder the other and it should try to toggle the flags to meet the constraints. But I may be thoroghly wrong in how I understand cabal
01:30:04 <merijn> ongy: you're correct, automatic flags get toggled to find something that works
01:31:36 <merijn> but avoiding transformers as a dependency is rather pointless, since basically everything depends on transformers already anyway :p
01:55:13 <knupfer> How can I profile a library, when enabling profiling changes completely the performance characteristics because of different inlining?
01:58:53 <dminuoso> Given `instance Monad m => Monad (MaybeT m) where return = MaybeT . return . Just` - how does haskell know which typeclasses `return` to pick?
01:59:21 <dminuoso> Is that merely based on the assumption that whatever return produces must fit inside MaybeT?
02:00:02 <merijn> dminuoso: Type inference
02:00:09 <merijn> dminuoso: So, yes
02:00:24 <ongy> the MaybeT constructor has a type, so it knows what to put into there
02:00:50 <merijn> :t Control.Monad.Trans.Maybe.MaybeT
02:00:52 <lambdabot> m (Maybe a) -> Control.Monad.Trans.Maybe.MaybeT m a
02:01:46 <dminuoso> merijn: Mmm okay. This "reverse type inference" is somewhat mindboggling. :-\
02:02:00 <merijn> dminuoso: It's not "reverse type inference"
02:02:09 <merijn> dminuoso: Type inference is *always* bidirectional
02:03:01 <dminuoso> merijn: You mean with a HM type system?
02:03:26 <dminuoso> But fair enough, Ill just accept it. :)
02:03:39 <merijn> dminuoso: Well, also with a bunch of others, but yes :)
02:04:12 <merijn> dminuoso: Think of inference as creating a bunch of unification constraints that we check in the end
02:04:44 <bartavelle> _sras_: if you need cross os support, I don't think there is any simple solution
02:06:11 <merijn> dminuoso: Except I can't think of a nice/simple example to elaborate atm :)
02:07:19 <dminuoso> merijn: Im so used to the C++ type system which seems to be unidirectional, so that's where my confusion came from. :)
02:07:57 <merijn> dminuoso: C++ is very much unidirectional, yes. It's my main annoyance with it :p
02:08:59 <merijn> dminuoso: return (and things like read) aren't possible in C++ for that reason. Since their return type has to be inferred and C++ can only infer arguments
02:14:07 <halogenandtoast> If one was to be making a vim clone in Haskell, what type of data structure should they store the buffers in? Perhaps Seq?
02:15:06 <maerwald> halogenandtoast: you mean yi=
02:15:07 <maerwald> ?
02:15:10 <halogenandtoast> One constraint per the documentation: Each buffer has a unique number.  That number will not change
02:15:12 <maerwald> @hackage yi
02:15:13 <lambdabot> http://hackage.haskell.org/package/yi
02:15:22 <halogenandtoast> maerwald: those are registers
02:16:04 <maerwald> halogenandtoast: I was just pointing out there already is a clone
02:16:10 <maerwald> you could look up the source code
02:16:12 <merijn> halogenandtoast: Honestly, no I wouldn't use Seq
02:16:20 <merijn> halogenandtoast: I'd use something dedicated like a piece table
02:16:31 <merijn> halogenandtoast: But I have just the paper for you!
02:16:56 <halogenandtoast> lol
02:17:11 <merijn> halogenandtoast: http://sites.google.com/site/kingqj/DataStructuresforTextSequences.pdf
02:17:26 <merijn> halogenandtoast: Found it a couple years ago when I was thinking about writing my own editor
02:17:35 <Naughtmare[m]> Yi uses rope: @hackage yi-rope
02:17:43 <merijn> halogenandtoast: in-depth discussion of most common editor representations and pros/cons
02:17:44 <Naughtmare[m]> @hackage yi-rope
02:17:44 <lambdabot> http://hackage.haskell.org/package/yi-rope
02:18:10 <Naughtmare[m]> It is basically a fingertree of text
02:18:33 <merijn> The nice thing of piece tables is that they're very space efficient, very cheap to index and implementing infinite undo is basically free. The only downside is you need to do a bit of extra work when saving to disk
02:20:26 <halogenandtoast> This is what yi seems to be doing: buffers         :: !(M.Map BufferRef FBuffer)
02:20:54 <halogenandtoast> merijn: I'll check it out
02:21:23 <halogenandtoast> I'm just writing an editor for a fun excercise, doubt I'll get too far.
02:21:55 <merijn> halogenandtoast: If you go ahead and write an mmap based piece table in Haskell I can go and save myself the work ;)
02:22:20 <halogenandtoast> ha, I actually think my original question was misinterpreted...
02:22:31 <halogenandtoast> Looking at the answers I got...
02:22:48 <maerwald> halogenandtoast: I did that in Java in a couple of days lol. Always depends how "professional" you want that to be
02:23:00 <maerwald> a toy implementation should be doable
02:23:13 <merijn> halogenandtoast: Oh, you meant like file buffers? Just a map of whatever text data structure you have I think
02:23:32 <halogenandtoast> merijn: it's just a reference to "open" files and your location in them
02:23:45 <halogenandtoast> i.e. 3 %a + "version.c"              line 1
02:24:29 <merijn> halogenandtoast: Right, just, like a map or seq then
02:24:44 <halogenandtoast> buffer 3 is the current buffer, active (loaded), modified, named "version.c" and currently on line 1
02:24:46 <merijn> halogenandtoast: Doubt anyone has a number of buffers large enough to worry about it
02:24:58 <merijn> halogenandtoast: And if they do, screw 'em :p
02:25:35 <halogenandtoast> error "What do you think this is? A real editor?"
02:25:43 <maerwald> lol
02:26:13 <halogenandtoast> Naughtmare[m]: thanks for linking the rope library, that will be really interesting to parse through.
02:26:21 <maerwald> error "No, you can't, send a PR"
02:26:53 <halogenandtoast> maerwald: I'll just shell out and have it clone the repo and make a new branch for you
02:27:04 <maerwald> :D
02:27:46 <merijn> "patches or gtfo"
02:27:59 <halogenandtoast> As an aside, I've really been enjoying using Ncurses with haskell
02:28:13 <halogenandtoast> it's a breath of fresh air when compared to using it with C
02:28:25 <maerwald> how idiomatic is it? I have just done Gtk in haskell and it's not really pleasant
02:28:52 <halogenandtoast> I'll lpaste what I have (which isn't much) so you can see maerwald 
02:28:59 <merijn> maerwald: ncurses is dreadful, but vty-ui is pretty amazing. Although it's no deprecated for brick which I haven't used yet. Heard good things about it, though
02:29:20 <merijn> maerwald: So for ncurses like terminal UIs I'd probably go with brick
02:29:35 <halogenandtoast> http://lpaste.net/358399
02:30:21 <halogenandtoast> some of that is probably just bad Haskell, I'm just playing around at this point, but feel free to criticize me, I sometimes take it well.
02:33:11 <halogenandtoast> merijn: would you use brick for a vim clone?
02:33:18 <halogenandtoast> I don't need most of the fancy drawing
02:35:54 <ertes-w> merijn: i'm not overly fond of brick TBH
02:36:07 <merijn> halogenandtoast: I've not used brick, only played with vty-ui in the past. For vim it might be overkill, but it'd make doing things like splitscreen buffers, quickfix lists, etc. easier
02:37:03 <ertes-w> vty-ui was super-easy to bind to FRP frameworks…  brick not so much, because it really wants you to integrate your framework into its state loop
02:37:05 <merijn> ertes-w: I forgot what your objection to it was
02:37:24 <ertes-w> for example using vty-ui with reactive-banana was a breeze
02:44:36 <kahlil29> anyone has experience/knowledge of extracting JSON values via key/attribute from the db table using Opaleye ?
02:50:57 <halogenandtoast> Haskell wouldn't happen to have an embeddable runtime for itself would it (sounds weird perhaps but I'll eventually want a configuration layer for my editor and was thinking to have the config in Haskell)
02:51:08 <halogenandtoast> Otherwise I could probably just use hslua
02:51:31 <merijn> halogenandtoast: Depends, do you care about the size of your editor?
02:51:57 <halogenandtoast> Not really
02:51:58 <merijn> halogenandtoast: You could literally just embed GHC into your editor, since GHC-as-a-library is a thing
02:52:18 <merijn> halogenandtoast: Which would let you compile code at runtime
02:53:00 <merijn> halogenandtoast: https://downloads.haskell.org/~ghc/master/users-guide/extending_ghc.html#using-ghc-as-a-library
02:53:03 <halogenandtoast> Interesting
02:53:38 <merijn> halogenandtoast: The ghc executable is essentially a thin-ish wrapper around a library that implement all the functionality of compiling/linking :)
02:54:10 <halogenandtoast> Maybe I'll try hslua first, sounds slightly easier
02:54:58 <kahlil29> Having an issue with parsing/extracting JSON values from the db table using Opaleye. Here is the code and errors. http://lpaste.net/4552584742993657856
02:59:27 <mniip> ghc does what
02:59:31 <mniip> parse args?
02:59:42 <mniip> the rest is available in ghc-the-libraryh
03:01:03 <tdammers> halogenandtoast: I'd be very worried about sandboxability for that though
03:01:19 <catamorphe> hello, I reading about hkt and I'm wondering where is defined the data type (->) on hackage
03:01:19 <tdammers> halogenandtoast: using haskell as your configuration language exposes all of IO to the configuration file
03:01:48 <merijn> tdammers: He's writing a hacky vim clone for fun, doubt that's a high concern :)
03:01:48 <mniip> catamorphe, GHC.Prim
03:01:54 <mniip> (probably)
03:02:01 <catamorphe> thanks
03:02:11 <merijn> mniip: GHC.Prim doesn't really define things. Just list them to satisfy the type checker :)
03:02:12 <tdammers> merijn: good point, besides vim modelines are already plagued with a very similar problem ;)
03:02:20 <mniip> % :info (->)
03:02:21 <yahb> mniip: data (->) (a :: TYPE q) (b :: TYPE r) -- Defined in `GHC.Prim'; infixr 0 `(->)`; instance Applicative ((->) a) -- Defined in `GHC.Base'; instance Functor ((->) r) -- Defined in `GHC.Base'; instance Monad ((->) r) -- Defined in `GHC.Base'; instance Monoid b => Monoid (a -> b) -- Defined in `GHC.Base'; instance [safe] (PrintfArg a, HPrintfType r) => HPrintfType (a -> r) -- Defined in `Text.Printf'; instan
03:02:23 <merijn> tdammers: That's why every sane person disables modelines
03:03:10 <halogenandtoast> tdammers: so are you suggesting hslua as being a better alternative to embedding Haskell?
03:03:31 <tdammers> halogenandtoast: I guess. Or, probably even better, something even dumber, like YAML
03:03:43 <tdammers> or rather, the non-vulnerable subset of YAML
03:04:02 <halogenandtoast> tdammers: I want it to be slightly programmable
03:04:15 <halogenandtoast> so you can compose functions and write it to work the way you want
03:04:31 <halogenandtoast> Don't think yaml would let me do that.
03:04:38 <tdammers> halogenandtoast: then hslua, I guess, unless you want to implement your own DSL for that
03:05:06 <tdammers> yaml doesn't do functions, but you can define "variables" of sorts and reuse them
03:06:43 <maerwald> a turing complete config format is a vulnerability :>
03:07:18 <ventonegro> Dahl?
03:07:31 <maerwald> Dahl Bhat?
03:07:40 <ventonegro> http://www.haskellforall.com/2016/12/dhall-non-turing-complete-configuration.html
03:08:02 <catamorphe> yahb: thanks
03:13:55 <phaazon> hey, I have a sanity check failure with stack
03:14:00 <phaazon> any idea about how to solve that?
03:34:54 <halogenandtoast> Is there any reason the Monad instance of either couldn't be defined as: instance Monad (Either e) where Right r >>= k = k r; l >>= _ = l
03:35:21 <mniip> is it not?
03:35:39 <halogenandtoast> It pattern matches the left
03:35:42 <halogenandtoast> in source
03:35:45 <mniip> well
03:35:46 <halogenandtoast> and does it first
03:35:54 <mniip> it doesn't raelly matter
03:35:59 <halogenandtoast> ok
03:36:16 <guillaum2> (would'nt it matter for undefined ?)
03:36:27 <mniip> halogenandtoast, oh and there's this problem
03:36:45 <mniip> l >>= _ = l
03:36:48 <mniip> does not typecheck
03:37:32 <halogenandtoast> Ah okay
03:38:36 <mniip> :t (\case x of { Right r -> Right r; l -> l })
03:38:38 <lambdabot> error: parse error on input ‘of’
03:38:41 <mniip> err
03:38:50 <mniip> :t (\case { Right r -> undefined; l -> l })
03:38:52 <lambdabot> Either t1 t -> Either t1 t
03:38:58 <mniip> there
03:39:22 <mniip> see it doesn't infer Either t1 a -> Either t1 b
03:39:29 <mniip> if you don't pattern match on the Left
03:40:43 <halogenandtoast> :t (\case { Right r -> undefined; Left l -> Left l })
03:40:45 <lambdabot> Either a t -> Either a b
03:40:53 <halogenandtoast> interesting
03:41:14 <opqdonut> indeed
03:41:26 <mniip> is this not obvious to you?
03:41:40 <opqdonut> oh right it's not interesting
03:41:45 <opqdonut> I misread that as "Either a b -> Either a b"
03:47:53 <ocharles> alanz, mpickering: I'm looking at doing pretty printing with just ghc-exactprint - essentially just moving DPs around to get the formatting I want. It's pretty cool! But I have a q... ghc-exactprint seems to discard some locations, and I wonder why
03:48:17 <ocharles> for example, Annotate for HsLet in HsExpr ignores the location of the binds of the let statement, so this doesn't do anything:
03:48:30 <alanz> ocharles: have you looked at brittany? Does a similar thing
03:48:36 <ocharles> case expr of HsLet binds body -> setEntryDPT binds (DP (100000, 0))
03:48:55 <ocharles> alanz: yep, I know of brittany, but brittany actually does the printing itself
03:49:01 <alanz> ocharles: which GHC version?
03:49:06 <ocharles> I wanted to do nothing except move deltas around
03:49:35 <ocharles> 8.0.2
03:51:06 <ocharles> alanz: but https://github.com/alanz/ghc-exactprint/blob/master/src-ghc82/Language/Haskell/GHC/ExactPrint/Annotater.hs#L1877 seems problematic, it just discards the srcspan of the binds
03:51:32 <alanz> ok, you need to look in the src-ghc80 dir
03:51:46 <alanz> which is the same
03:51:57 <alanz> also discards the location
03:52:06 <ocharles> right
03:52:21 <alanz> That location was added to allow indexing the list by it, so it could move independently
03:52:36 <alanz> but before that the engine was set up to ignore it
03:52:45 <alanz> and I have not gone back to make use of it yey
03:52:47 <alanz> yet
03:52:57 <ocharles> ok, so this could be considered a bug?
03:53:10 <ocharles> hsmodName is similarly affected, setting the entry DP of that doesn't do anything
03:53:16 <alanz> There was some technical issue about managing the list in the surrounding scope, and breaking existing behaviuour
03:53:20 <ocharles> and I haven't tried transforming much more than that :)
03:53:28 <alanz> Well, it is more of a feature at the moment :(
03:53:57 <alanz> The thing it to look at the Annotater code and see what is used, and work from there
03:54:31 <alanz> You can also call showAnnData to see exactly what annotations exist
03:54:47 <ocharles> my use case is I want to "swing" bindings of a let statement under the let, so `let x =` becomes `let\n<space><space>x =`. Right now I'm doing that by using the first location of the binds, but that breaks if the let statement opens with a type signature
03:55:07 <alanz> What I normally do is run a test with the "from" source code, look at what I get, then with the manually formatted new one, and compare
03:55:52 <alanz> And that should be possible (it is a design goal), but you need to check what to work with
03:56:01 <alanz> (my brain is a bit rusty)
03:56:39 <alanz> iirc, I originally wanted the indent to be on the location of the binds, then each could start at zero and be freely re-arranged
03:56:52 <alanz> But that is not what ended up in the code, and it needs to be fixed
03:57:34 <alanz> The "setLayoutFlag" triggers the indentation, by the way
03:57:55 <alanz> no, sorry, markLocalBindsWithLayout
03:58:24 <ocharles> so far I haven't written my own interpreter for Annotate because I'm hoping the Print module should be sufficient
03:58:47 <alanz> it should be
03:59:21 <alanz> The problem you are seeing comes because the HsLet binds are not decls, so are split into sigs and binds
03:59:56 <alanz> which means you end up with this: https://github.com/alanz/ghc-exactprint/blob/master/src-ghc80/Language/Haskell/GHC/ExactPrint/Annotater.hs#L1738
04:00:06 <ocharles> well, that would be one explanation. my expectation was that each dp of the binds (and sigs) are relative to the dp of the whole HsLocalBinds
04:00:21 <alanz> that is what I want to see too.
04:00:46 <alanz> Unfortunately it did not happen originally, and needs to be retrofitted to be that way
04:00:49 <ocharles> ok, if we're in agreement there then I will at least open an issue
04:00:57 <alanz> please do
04:01:22 <alanz> by the way, take a look at the Transform tests, for some examples of doing things
04:01:45 <alanz> You can also try to bug Andrew Farmer, he is doing some good work with ghc-exactprint too
04:02:05 <alanz> and has a module that makes some of this stuff easier
04:02:13 <alanz> Which he claims he is going to open source
04:02:35 <alanz> ocharles: you can also make a PR.
04:02:44 <ocharles> I can do that if I fix it :)
04:02:49 <ocharles> but yes, would like to give it a try
04:02:56 <alanz> But I think you will find the innards are quite complex
04:03:14 <alanz> Feel free to talk about details if you get into it
04:03:17 <ocharles> I've done a fair bit of reading of the source so far just to understand what ghc-exactprint actually does, so I'm starting to get an understanding
04:03:27 <alanz> good
04:03:30 <ocharles> is Andrew known by anything on IRC/online?
04:03:35 <ocharles> anything else*
04:04:00 <mniip> Andrew who
04:04:03 <alanz> afarmer when he shows up, normally on #haskell-refactorer 
04:11:45 <hexagoxel> ocharles: out of curiosity, are you aiming for a layout where indentation only ever increases by the default indentation amount?
04:12:11 <ocharles> hexagoxel: not specifically, just playing around with formatting which looks more like `elm-format` -- but they do tend to aim for that
04:29:33 <merijn> argh
04:29:55 <merijn> Socket only has getContents for lazy ByteString and bytestring only has hGetLine for strict bytestring...
04:30:04 <merijn> Now I need to mix both in the same file...*sigh*
04:37:44 <tdammers> hGetLine for bytestrings seems conceptually wrong
04:38:56 <hpc> perhaps hGetUntil :: ByteString -> Handle -> IO ByteString or something along those lines?
04:39:01 <merijn> tdammers: Yeah, but since I'm forwarding stdout from a process over a socket it's what I need
04:40:47 <merijn> tdammers: So, either I interact with the handles using Text, then encode to bytestring, write to the socket and repeat on the other side OR I just fetch my input as bytestring since that's what I want anyway
04:43:04 <tdammers> hmm yes indeed
04:43:30 <tdammers> the concept of bytestring "lines" is real on Unix, despite being conceptually wrong
04:54:19 <ongy> unix has types?
05:00:28 <merijn> ongy: Yes, but only 1 :p
05:03:00 <WinterFox[m]> Is there any way to use filter on the chars in a string?
05:03:41 <ongy> > filter isDigit "112asdf11"
05:03:43 <lambdabot>  "11211"
05:03:46 <WinterFox[m]> I tried `filter (=="x") "xxxaaa"` and got an error/
05:03:59 <ventonegro> "x" is a string
05:04:04 <ongy> :t "x"
05:04:06 <ongy> :t 'x'
05:04:06 <lambdabot> [Char]
05:04:07 <lambdabot> Char
05:04:11 <WinterFox[m]> • Couldn't match type ‘Char’ with ‘[Char]’
05:05:27 <WinterFox[m]> Ah I see, Needed to swap " with '
05:05:51 <ongy> you need to give it a char, not a string. and that's how you do that
05:10:52 <merijn> hmmm, I still haven't decided on what is a nice way to linewrap long lists of explicit imports...
05:11:47 <ongy> I'm currently going with one import a line, but that's becomming too long
05:12:00 <merijn> ongy: Exactly
05:15:38 <merijn> Relatedly, CreateProcess always ends up looking ugly for me...since I end up doing "(proc foo opts) { ...}" due to precedence of {, suggestions there welcome to
05:16:22 <hpc> i usually just write another function that makes processes the way i want
05:16:33 <hpc> so i can go back to doing foo ["ls", "-la"] and such
05:26:00 <merijn> hmm, is there a common function for stripping trailing whitespace/newlines?
05:26:37 <ertes-w> merijn: Text has functions for that
05:27:19 <merijn> ertes-w: I don't have text, though. Converting to/from text seems about as practical as "reverse . dropWhile isSpace . reverse" others are using
05:27:23 <ertes-w> merijn: there are functions like dropAround, strip, stripStart, stripEnd
05:27:43 <ertes-w> merijn: what do you have?  String?
05:28:06 <merijn> String, yeah
05:28:55 <ertes-w> merijn: converting to a lazy Text is probably about as efficient as paying an extra traversal cost for the list equivalent of dropWhileEnd
05:29:25 <merijn> :\
05:29:35 <merijn> I wish base was string-type polymorphic :\
05:30:21 <ertes-w> i wish lazy Text was the default
05:30:42 <merijn> hmm, I wonder if it's more efficient if I just want to drop a single final character
05:31:22 <ertes-w> merijn: yes, definitely, because then you don't need to backtrack to the position where the last block of matching characters started
05:31:55 <merijn> ertes-w: I think I can safely assume I only need to drop a single trailing newline, which I suppose is just "init"
05:32:09 <ertes-w> merijn: do you need to keep newlines in the middle?
05:32:30 <merijn> ertes-w: Realistically? No. Although they could technically happen
05:33:01 <ertes-w> merijn: alternatively: would your use case allow faking strip by just ignoring empty lines?
05:33:04 <merijn> ertes-w: I'm using readProcess to grab the root dir of a project, which ends up appending a newline the way it reads output. I suppose *technically* the rootdir could have a newline in the path
05:33:31 <ertes-w> merijn: then you could just 'lines' and (filter (not . null))
05:33:52 <ertes-w> ah, no, then that's not safe
05:34:05 <ertes-w> are line feeds really allowed in paths?
05:34:09 * ertes-w tests
05:34:18 <merijn> ertes-w: Anything that's not a null byte is allowed in paths
05:34:34 <merijn> ertes-w: Including control codes like "bell" and others
05:34:34 <ertes-w> indeed, they are
05:34:50 <merijn> ertes-w: That's the sound of unix telling you to go fuck yourself :)
05:35:12 <ertes-w> loud and clear, yeah
05:36:00 <ertes-w> even my shell was prepared to handle them…  it actually inserted the proper $'\n' sequence when i tab-completed the file name
05:36:24 <merijn> ertes-w: Fun times with files starting with - and shell globs like * :)
05:36:49 <ertes-w> yeah, i have a file named "-rf *" in my home directory =)
05:36:51 <ertes-w> just for fun =)
05:37:03 <merijn> keeps you on your toes :p
05:37:37 <ertes-w> oh yeah…  kinda nerve-racking to actually delete that file =)
05:37:49 <merijn> just delete it from ghci :p
05:37:54 <ertes-w> heh
05:38:36 <merijn> removeFile "-rf *" -- no problem :p
05:39:21 <ertes-w> "… but it's kinda weird for you to have the KDE file browser installed, isn't it?" – "i use it to delete weirdly named files that my colleague keeps committing to troll me"
05:40:03 <merijn> hmmm
05:40:29 <merijn> Now it's happy "why is this program silently exiting?!" debug time...
05:40:45 <merijn> And exiting succesfully no less...
05:41:07 <merijn> oh...turns out I'm a moron...mystery solved!
05:41:55 <ongy> that solves way too many of my problems :(
05:42:01 <Psybur> Is there anyway to get GHCI to tell me what line of code caused an exception?
05:42:31 <merijn> ongy: Well, I had a moronic problem, but it seems fixing that doesn't actually fix my issue
05:42:41 <hexagoxel> (or you use `rm` to delete that file.. -- is your friend)
05:43:25 <Psybur> Trying out breakpoint on exception
05:43:56 <ertes-w> hexagoxel: you still look twice before firing that command =)
05:45:27 <ongy> hexagoxel: unlink pls
05:45:43 <merijn> hmm
05:58:43 <saurabhnanda> what's the best haskell plugin for VSCode? Any verdict?
06:01:48 <tdammers> vim :x
06:11:10 <merijn> Sockets are supposed to survive forking, yes?
06:11:19 <ongy> should, yes
06:11:27 <merijn> bleh...
06:11:41 <ongy> is that a problem? or does it not work for you?
06:11:54 <merijn> ongy: It's not working
06:12:19 <merijn> ongy: I'm basically binding/listening on a socket before forking my daemon (to prevent races between the daemon and the frontend)
06:12:28 <merijn> but the frontend keeps BSing me that there's no socket
06:12:56 <ongy> do you exec in between?
06:13:04 <merijn> ongy: no
06:13:20 <merijn> Just forkProcess from unix
06:13:53 <ongy> have you checked if the socket exists? netstat (or whatever equivalent you have for that)
06:13:54 <merijn> oh, actually I think I see the problem
06:19:14 <ongy> "merijn: oh...turns out I'm a moron...mystery solved!" again?
06:19:23 <merijn> kind
06:19:25 <merijn> *kinda
06:28:28 <ongy> byebye matrix
06:29:43 <aweinstock> is matrix a centralized system?
06:30:16 <ahihi> no, but a lot of people are on the matrix.org homeserver
06:31:22 <aweinstock> http://lpaste.net/358406
06:32:22 <aweinstock> I asked about church nats yesterday, and I've made progress on giving the more general wrapping function a type, but it still fails in some cases
06:34:16 <tabaqui> can I even use ExceptT with Exceptions?
06:34:16 <aweinstock> specifically, I've constructed g such that (let f = $SOME_LAMBDA in g f) fails to typecheck, but (g $SOME_LAMBDA) typechecks, under RankNTypes
06:34:33 <tabaqui> it lookis like functions throwE and catchE don't work with real exceptions
06:34:55 <aweinstock> and I'd like to know if that's fixable, or if not, why that transformation doesn't work in this instance
06:35:03 <tabaqui> only with "Left e" - not real exception
06:35:31 <tabaqui> f.e. How can I get "ExceptT e IO a" from dangerFunction :: IO a?
06:37:13 <aweinstock> :t try
06:37:15 <lambdabot> Exception e => IO a -> IO (Either e a)
06:37:53 <scav_> What is the best Cassandra driver/package to use?
06:37:57 <scav_> I am not having any luck using http://hackage.haskell.org/package/cassy
06:38:08 <scav_> cabal: Could not resolve dependencies
06:38:12 <merijn> Anyone know how I can inspect wtf is going on on a pipe between processes?
06:39:13 <tabaqui> merijn: write simple pipe proxy?
06:39:53 <fizbin> Is anyone here familiar with exceptions under older (i.e. 7.6.3) GHC? I've got something here where it looks like a computation can't get interrupted by my custom exception class, (used with throwTo) but will get interrupted by "killThread".
06:40:01 <tabaqui> btw, pipes are just another file descriptors of process, so you could use strace
06:40:11 <tabaqui> but I dunno, how it works with haskell RTS
06:40:12 <aweinstock> :t ExceptT . try -- tabaqui 
06:40:13 <lambdabot> Exception e => IO a -> ExceptT e IO a
06:40:47 <aweinstock> merijn: tee(1)
06:40:48 <fizbin> I thought that killThread was equivalent to "throwTo ThreadKilled", so is there maybe something special in older GHCs about the ThreadKilled exception?
06:41:31 <tabaqui> aweinstock: well, I obviously have to get some sleep :)
06:41:31 <aweinstock> merijn: err, how are the processes establishing the pipe? pipe(2) followed by fork(2)?
06:41:33 <tabaqui> thanks
06:41:34 <merijn> aweinstock: That's tricky to use, though
06:41:44 <`Guest00000> about list-based backtracking parsers: if i just (take 1) from the result, will it remove inefficiency?
06:41:48 <merijn> aweinstock: Well, I'm using process' CreateProcess, but yeah
06:45:26 <fizbin> Indeed, if I use "throwTo ThreadKilled" then the computation stops, but "throwTo myException" seems to have no effect.
06:46:20 <fizbin> The computation that's being interrupted is a huge long computation in pure code, being called inside a try (evaluate ) wrapper
06:49:37 <halogenandtoast> Is there any way to make this Applicative instance more performant: http://lpaste.net/358407
06:50:51 <halogenandtoast> I'm running the applicative tests from checkers on it and the compose tests are super slow
06:51:50 <merijn> halogenandtoast: Are you comparing against []?
06:51:58 <halogenandtoast> yes
06:52:07 <halogenandtoast> [] is very quick
06:52:11 <merijn> halogenandtoast: [] has a whole bunch of rewrite rules to make things fast :p
06:52:16 <merijn> halogenandtoast: Which you don't
06:52:33 <geekosaur> fizbin, try compiling with -fno-omit-yields?
06:53:09 <halogenandtoast> merijn: I don't care about being as fast as [], just wanted to know if there was anything obvious to make it quicker, at the moment the tests are so slow I cancelled them.
06:54:36 <halogenandtoast> but only the compose tests, the rest are quick speedy
06:54:39 <fizbin> geekosaur: ghc 7.6.3 doesn't understand -fno-omit-yields
06:55:13 <geekosaur> ok, that may be a hint then as to differences
06:55:22 <geekosaur> (although I thought it had existed by then)
06:55:44 <geekosaur> basically, code that doesn't allocate doesn't check for exceptions
06:57:53 <merijn> hmm
06:58:16 <merijn> I wish there were flipped versions for onException and finally :\
06:59:26 <shapr> @yow
06:59:27 <lambdabot> DON'T go!!  I'm not HOWARD COSELL!!  I know POLISH JOKES ... WAIT!!
06:59:27 <lambdabot> Don't go!!  I AM Howard Cosell! ... And I DON'T know Polish jokes!!
07:03:24 <ertes-w> halogenandtoast: one way to make your Applicative instance faster (potentially) is by flip-flopping between two recursive functions instead of using mappend
07:04:35 <halogenandtoast> ertes-w: what do you mean?
07:04:50 <halogenandtoast> one that recurses the functions and one that recurses the values?
07:06:05 <Psybur> Lets say I have a [[1,2],[1,3],[2,3]]. How would I turn that into a [[Just 1,Just 2,Nothing],[Just 1,Nothing,3],[Nothing,Just 2,Just 3]] ? Basically filling in gaps with Nothing
07:06:17 <fizbin> geekosaur: Right. I'm very surprised at the idea that this code wouldn't allocate memory, especially when "top" says that the process is using more and more memory.
07:06:44 <fizbin> Also, why would it be interruptible by ThreadKilled and not by my custom exception?
07:06:47 <Psybur> Im thinking a transpose first, manipulate, transpose again?
07:06:53 <halogenandtoast> Psybur: map on a recursive function with an index to match against
07:07:52 <ertes-w> halogenandtoast: see annotation
07:09:08 <halogenandtoast> ertes-w: thanks for the annotation!
07:09:42 <ertes-w> halogenandtoast: might not make a difference though, depending on how smart GHC is
07:09:56 <halogenandtoast> it doesn't make too much of a difference
07:10:06 <halogenandtoast> but I appreciated the effort!
07:10:34 <ertes-w> halogenandtoast: if you want it to take off, you should either introduce the same rewrite rules as [], or change the representation
07:10:35 <byorgey> Psybur: I don't think a transpose helps very much.
07:10:59 <ertes-w> halogenandtoast: newtype List a = List { fromList :: forall r. (a -> r -> r) -> r -> r }
07:11:57 <halogenandtoast> I have no idea what the representation means
07:12:07 * halogenandtoast feels dumb
07:12:16 <ertes-w> halogenandtoast: the idea is that a list can be identified with its fold
07:12:34 <ertes-w> halogenandtoast: instead of representing the list as actual data, you represent it as a fold function
07:12:50 <ertes-w> (this is called church encoding)
07:13:14 <byorgey> > (\m -> map (flip M.lookup m) [1..8]) . foldr (\a -> M.insert a a) M.empty $ [2,4,5,8]
07:13:16 <lambdabot>  [Nothing,Just 2,Nothing,Just 4,Just 5,Nothing,Nothing,Just 8]
07:13:22 <byorgey> Psybur: ^^^
07:13:38 <Psybur> byorgey, need to keep it as a matrix
07:13:40 <merijn> I don't suppose anyone here has found a way to use environment variables in ~/.cabal/config? Specifically writing the config file with a variable for my homedir so that I can keep it portable across different machines?
07:16:44 <halogenandtoast> ertes-w: thanks
07:17:46 <Psybur> byorgey, what is M in lambdabot's scope?
07:18:01 <ertes-w> halogenandtoast: try to write a Monoid instance for this type
07:18:05 <ertes-w> halogenandtoast: start with mempty
07:18:40 <ertes-w> halogenandtoast: if you can't figure it out, ask yourself: "what happens if i fold an empty list if f and z?", i.e.: foldr f z [] = ?
07:18:47 <ertes-w> then write: List (\f z -> ?)
07:19:38 <Psybur> IM going to assume its HashMap
07:19:56 <c_wraith> It's usually Data.Map
07:20:05 <Psybur> > :t M.empty
07:20:07 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
07:20:11 <Psybur> :t M.empty
07:20:12 <lambdabot> M.Map k a
07:20:27 <c_wraith> that doesn't say a whole lot. :P
07:20:30 <c_wraith> :t M.insert
07:20:32 <lambdabot> Ord k => k -> a -> M.Map k a -> M.Map k a
07:20:38 <c_wraith> yeah, that's Data.Map
07:21:20 <Psybur> bots?
07:21:39 <ongy> matrix
07:21:43 <c_wraith> the join flood?  It's the end of a split, it looks like
07:22:01 <Psybur> Whys everyone [m] D:
07:22:22 <ongy> because it's the matrix (matrix.org) a different chat service with an IRC bridge. so this "split" was just their bridge going down
07:22:44 <ongy> happens probably once every week. if you want to know more, ask glguy
07:22:51 <c_wraith> that's still a fully legit split, from the point of view of the network. :P
07:23:33 <cocreature> matrix seems to be pretty close to replacing IRC judging from how good they are at emulating netsplits
07:23:51 <ongy> I honestly have no idea how their bridge is bound into the network. but if it just creates a client connection for everyone, I wouldn't call that an IRC netsplit, if they connect as relay then ok
07:24:17 <c_wraith> is matrix the one written in Haskell?  I know one of those new chat apps is.
07:25:03 <thoughtpolice> cocreature: lololol brutal
07:26:06 <shapr> c_wraith: really?
07:26:13 <cocreature> c_wraith: you’re probably thinking of "wire"
07:26:20 <c_wraith> cocreature: that sounds right
07:27:21 <shapr> oh neat: https://github.com/wireapp/wire-server
07:28:00 <merijn> hmm, so the best solution I have to have a cabal config file for multiple machines is to simply 'sed' the right home dir into it before copying?
07:28:01 <shapr> I like the pirate themed services.
07:30:17 <Psybur> byorgey, thanks btw finally wrapped my mind around it
07:30:25 <byorgey> Psybur: great =)  glad to help
07:30:47 <Psybur> byorgey, why did you choose foldr instead of foldl or L.foldl' ?
07:30:58 <ertes-w> shapr: the architecture looks massive though
07:31:29 <Psybur> byorgey, I see that it just straight up doesnt work with foldl
07:32:01 <ongy> merijn: call the home directory the same on both machines?
07:32:46 <Psybur> byorgey, ok I think I see it, it has to do with how the fold function parameters get arranged
07:34:12 <Psybur> byorgey, besides allowing the fold function to be point free, was there any advantage of foldr over foldl in that situation?
07:36:35 <ertes-w> :t M.fromList . map (\x -> (x, x))
07:36:36 <lambdabot> Ord a => [a] -> M.Map a a
07:37:33 <ertes-w> :t M.fromList . join zip
07:37:34 <lambdabot> Ord k => [k] -> M.Map k k
07:37:38 <merijn> ongy: That's not an option
07:37:58 <merijn> ongy: Because of different OSes, lack of control of usernames and similar reasons
07:40:46 <byorgey> Psybur: no, not really
07:41:26 <byorgey> Psybur: if you were doing it with very long lists, maybe you would want to use foldl' and a strict Map?  I don't know though, I would have to play around with it.
07:42:38 <byorgey> For folding over lists with 2 elements, or even 20 elements, it really makes no difference.
07:43:19 <erisco> 30 is pushing it, though
07:43:20 <byorgey> ertes-w: ooh, fancy =)
07:44:09 <ongy> :t zip
07:44:10 <lambdabot> [a] -> [b] -> [(a, b)]
07:44:20 <byorgey> since it makes no difference for an empty list, and if it makes no difference for a list of length n then clearly it won't make a difference with n+1 either.  Hence by induction it makes no difference on lists of any length.
07:44:32 <ongy> :t join zip
07:44:34 <lambdabot> [b] -> [(b, b)]
07:44:56 <ongy> > join (+) 5
07:44:58 <lambdabot>  10
07:47:18 <ertes-w> :t flip (foldr (\x -> (. M.insert x x)) id) M.empty
07:47:19 <lambdabot> (Ord a, Foldable t) => t a -> M.Map a a
07:47:48 <ertes-w> :t flip (foldr (\x go -> (go $!) . M.insert x x) id) M.empty
07:47:50 <lambdabot> (Ord a, Foldable t) => t a -> M.Map a a
07:48:03 <ertes-w> this is a foldr variant that is actually efficient…  but it's just foldl' in disguise =)
07:48:17 <byorgey> heh, nice =)
07:49:54 <ertes-w> BTW, i wish the argument order for foldl's first argument were reversed
07:50:21 <ertes-w> i rarely found the current order useful…  usually it just gets in the way
07:50:48 <ertes-w> @let flippedFoldl' = foldl' . flip
07:50:50 <erisco> :t foldl . foldl
07:50:50 <lambdabot>  Defined.
07:50:51 <lambdabot> (Foldable t, Foldable t1) => (b -> a -> b) -> b -> t1 (t a) -> b
07:51:08 <erisco> it is actually foldr's that doesn't compose
07:51:16 <ertes-w> :t flippedFoldl' (\x -> M.insert x x) mempty
07:51:18 <lambdabot> (Ord a, Foldable t) => t a -> M.Map a a
07:51:30 <erisco> so if anything foldr should be flipped :)
07:51:52 <erisco> but it is meant to look similar to how the accumulation happens
07:51:52 <ertes-w> erisco: you're referring to the foldl' function itself, i'm referring to its first argument function
07:52:24 <erisco> I am referring to foldl, not foldl', and the fact it has the type it does (rather than foldr's type), is what allows it to compose
07:52:40 <erisco> the type difference between foldl and foldr is precisely that the first function is flipped
07:52:42 <ertes-w> well, yeah
07:54:53 <ertes-w> usually i prefer the current type of foldr
07:55:00 <erisco> or another reason for foldr is that it has the same order as (:)
07:56:22 <mniip> :t foldr . foldr
07:56:24 <lambdabot> (Foldable t1, Foldable t) => (a -> t1 a -> t1 a) -> t1 a -> t (t1 a) -> t1 a
07:56:30 <mniip> right...
08:05:52 <ertes-w> erisco: i rarely care about that though, because my target is rarely a list =)
08:06:20 <erisco> it is general to a pair of Foldables
08:09:59 <ertes-w> my most common target of foldr is actually an IO action
08:10:20 <ertes-w> or some other action
08:10:37 <erisco> maybe you're thinking of foldrM
08:10:59 <ertes-w> no, foldr
08:11:14 <ertes-w> i use it when i need to fold into an action with state
08:11:44 <erisco> I am not sure foldrM will work either
08:11:49 <erisco> what is an example?
08:13:12 <ertes-w> erisco: this pattern:  foldr (\x go s -> _) _ xs s0
08:13:32 <erisco> what is the type of foldr when you use it with IO?
08:13:50 <erisco> foldrM will work when m = IO but this is just folding into an action
08:14:17 <ertes-w> in this particular case:  foldr :: (Foldable f) => (a -> (s -> IO r) -> s -> IO r) -> (s -> IO r) -> f a -> s -> IO r
08:14:45 <erisco> how is the target an IO action, in that case?
08:15:13 <ertes-w> :t foldr
08:15:14 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
08:15:18 <ertes-w> b = s -> IO r
08:15:38 <erisco> I thought "IO action" referred to something like "IO r"
08:15:55 <erisco> and I thought "target" referred to the foldable
08:16:02 <ertes-w> in most cases when the target is not an IO *function* you can simply use 'traverse_'
08:16:19 <ertes-w> foldr becomes useful, when there is state involved
08:17:05 <erisco> it looks like you might be happy with foldrM and, say, ReaderT
08:17:42 <ertes-w> some cases can be handled with foldlM'
08:18:10 <ertes-w> but not all of them, and foldr fits those perfectly…  why should i use a transformer?
08:19:23 <erisco> for the purpose of forgetting how the state propagates and to just use 'ask'
08:20:11 <ertes-w> how am i even supposed to use ReaderT here?  it's state
08:20:19 <ertes-w> if anything i would have to use StateT
08:21:14 <erisco> okay, then use StateT
08:21:38 <erisco> I can't tell from that type if you read and write or just do one or none
08:21:50 <ertes-w> foldr is also nice for chaining two stateful traversals:  foldr f1 (foldr f2 z2 xs2) xs1 s0
08:22:06 <`Guest00000> imaginary extension: implied instances
08:22:20 <`Guest00000> when no instance for a type exists, a derived one is used
08:22:27 <`Guest00000> is it bad?
08:22:29 <erisco> it would be nice if not pointed :)
08:23:17 <erisco> `Guest00000, what is the motivation? I would write in the appropriate deriving declaration if I wanted an instance derived.
08:23:32 <`Guest00000> motivation is laziness at the interpreter prompt
08:23:47 <`Guest00000> or forgetfulness
08:23:53 <erisco> there is standalone deriving
08:23:59 <`Guest00000> still
08:24:12 <erisco> well, if you forget, you put in the standalone deriving
08:24:23 <`Guest00000> but the laziness is there
08:24:37 <c_wraith> it seems really dangerous to make that available outside of ghci
08:25:01 <`Guest00000> well, it's an extension, disabled by default
08:25:16 <erisco> I believe in pragmas allowing holes in feet
08:25:39 <dolio> You don't need a new extension, you can do it with overlapping instances.
08:26:18 <erisco> sounds plausibly useful, `Guest00000, and maybe you can leverage standalone deriving to implement it
08:26:57 <merijn> Is there a way to specify a maximum timeout for accept on a socket?
08:27:04 <erisco> dolio, how would that work?
08:27:25 <`Guest00000> oh
08:27:26 <`Guest00000> cool
08:27:41 <`Guest00000> erisco: you write a very generic instance head
08:27:50 <erisco> such as what?
08:28:00 <`Guest00000> then, where there are no instances for this class elsewhere
08:28:04 <erisco> class Show a where show _ = "You forgot a show instance dummy!"  -- ?
08:28:05 <`Guest00000> this one is used
08:28:18 <`Guest00000> erisco: deriving instance Eq a
08:28:25 <erisco> make that instance and not class
08:29:29 <erisco> if this can work then I am unaware of some significant feature
08:30:39 <`Guest00000> but i also wanted to restrict implicit instances to certain dumb types
08:30:44 <dolio> I don't think such instances are a good idea, though.
08:31:15 <`Guest00000> like, Eq is implied for types with single fieldless constructor, where this constructor is visible
08:31:26 <dolio> In your example, I don't see any reason why you'd want to wait until runtime to get a worse error message about your forgetting to implement Show.
08:31:31 <erisco> I inferred that the implicit instance we want is the deriving instance, i.e. something appropriate to our definition, not something uselessly generic
08:31:51 <`Guest00000> Ord likewise
08:31:56 <`Guest00000> Bounded likewise
08:32:09 <`Guest00000> Show more liberally
08:32:24 <dolio> You can derive all those.
08:32:52 <`Guest00000> but what if i don't want use OverlappingInstances for anything else than this
08:33:12 <erisco> I am not sure how you'd remove an implicit instance once an explicit one was added, assuming we're talking ghci
08:33:16 <`Guest00000> is there a generic way to restrict OverlappingInstances to only certain instances?
08:33:20 <glguy> Then don't, overlapping instances is turned on per instance
08:33:34 <`Guest00000> wow, cool
08:33:36 <glguy> the old LANGUAGE pragma at the top is old tech
08:33:42 <erisco> it is deprecated
08:34:26 <erisco> like, I don't want to clean up after a horse, so is there a way I can use a combustion engine to get around?
08:35:52 <erisco> twist ending: now we have to clean up after combustion engines
08:36:02 <merijn> Does ord produce the ASCII value of a Char (for the ascii subset of Char anyway)?
08:36:39 <erisco> this seems relatively easy to verify
08:37:12 <erisco> > map ord [minBound :: Char..]
08:37:14 <lambdabot>  error:
08:37:14 <lambdabot>      Not in scope: type constructor or class ‘Char..’
08:37:14 <lambdabot>      No module named ‘Char’ is imported.error:
08:37:24 <erisco> > map ord [minBound :: Char ..]
08:37:26 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
08:38:01 <erisco> > take 256 (map ord [minBound :: Char ..]) == [0..255]
08:38:03 <lambdabot>  True
08:38:21 <erisco> > take 512 (map ord [minBound :: Char ..]) == [0..511]
08:38:23 <lambdabot>  True
08:38:29 <erisco> works for extended ASCII too :)
08:39:06 <`Guest00000> > (== `on` take 512) (map ord [minBound :: Char ..]) [0..]
08:39:08 <lambdabot>  <hint>:1:5: error: parse error on input ‘`’
08:39:14 <`Guest00000> > ((==) `on` take 512) (map ord [minBound :: Char ..]) [0..]
08:39:16 <lambdabot>  True
08:39:48 <erisco> heh, on second glance, this is not correct
08:40:15 <erisco> we also need to verify [minBound..] actually produces the ASCII characters as a prefix
08:40:26 <`Guest00000> hehehe
08:40:49 <erisco> > chr [0..]
08:40:51 <lambdabot>  error:
08:40:51 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘[Integer]’
08:40:51 <lambdabot>      • In the first argument of ‘chr’, namely ‘[0 .. ]’
08:40:53 <erisco> > map chr [0..]
08:40:55 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
08:41:37 <erisco> we can use that to generate the list and manually verify it is ASCII
08:41:57 <erisco> then see if it is equiv to [minBound :: Char ..] for the prefix we're interested in
08:44:33 <__monty__> Having some trouble with nix-shell for haskell development. The cabal configure step complains about missing dependencies, among others mtl and text. I've specified these as build-depends in the cabal file (without version bounds) and generated default.nix and shell.nix with cabal2nix.
08:48:13 <dsal> It seems I can't use Crypto.Random as a generator for System.Random.  That kind of sucks.  I just wanted some good numbers.
08:54:03 <reactormonk> I've got a Fix f, and a Foldable f, is there a way to write a Fix f -> [Fix f] function which lists all elements in Fix f?
08:54:31 <reactormonk> The native implementation of `cata $ \t -> foldMap id t` doesn't really work, 0 elements
08:54:58 <glguy> reactormonk: You need to remember to put the top-most element in the list
08:55:36 <ertes-w> __monty__: are you using `cabal2nix --shell`?
08:55:51 <__monty__> ertes-w: Yes, for shell.nix.
08:56:10 <ertes-w> __monty__: how are you using nix-shell?
08:56:24 <__monty__> ertes-w: Simply "nix-shell".
08:56:26 <reactormonk> glguy, yeah, trying to do that with a para now, since the original element isn't available anymore in an ana
08:57:08 <ertes-w> __monty__: are you in a sandbox?
08:57:16 <__monty__> ertes-w: No.
08:58:09 <ertes-w> __monty__: what happens with `nix-shell --pure`? (note that you will have to use Setup.hs instead of cabal-install)
08:59:10 <__monty__> I don't have a setup.hs.
08:59:35 <jbergok> checking out for haskell?
08:59:40 <saurabhnanda> I just switched from spacemacs+intero to vscode+intero and on-the-fly typechecking has slowed down to a crawl. It used to take a few seconds to typecheck a file in spacemacs and it's taking ~5 minutes (!) in VSCode. Any known solutions?
08:59:46 <ertes-w> __monty__: create it with the following contents:  import Distribution.Simple; main = defaultMain
09:00:12 <jbergok> hi, im using vim with vim.spf13.com this configuration, but now im wondering what kind of haskell environment i should use. i've tried haskell-vim-now before, but that uses it's own config file so i need to just copy what i like manually i think. do you have any preferences as what is the best haskell environment?
09:00:28 <ertes-w> __monty__: then instead of typing "cabal", type "runhaskell setup.hs"
09:00:59 <ertes-w> jbergok: vim or in general?
09:01:06 <jbergok> ertes-w: vim
09:02:50 <__monty__> ertes-w: Reports the same missing dependencies: mtl -any, optparse-applicative, text and network (each -any).
09:03:32 <__monty__> base and containers installed just fine but I did provide version bounds for those.
09:03:42 <ertes-w> __monty__: please paste your cabal file
09:04:27 <__monty__> ertes-w: http://ix.io/zTX
09:05:22 <ertes-w> __monty__: also which channel are you using?  (`nix-channel --list`…  if the output is empty, try again as root)
09:05:39 <__monty__> nixpkgs-unstable
09:05:49 <__monty__> This is on arch btw, not nixos.
09:06:16 <ertes-w> i suppose you've done a channel update recently, and also installed a recent version of cabal2nix?
09:06:26 <__monty__> Yes, yesterday.
09:06:58 <ertes-w> __monty__: weird…  could you show the exact cabal2nix command you used and paste the generated shell.nix file?
09:08:12 <__monty__> "cabal2nix --shell . > shell.nix" and http://ix.io/zTZ
09:09:18 <ertes-w> looks fine to me…  let me try
09:10:22 <ertes-w> works here
09:11:22 <ertes-w> __monty__: do a channel update and try again…  if it still fails, report it in #nixos
09:11:33 <ertes-w> the nix-haskell folks hang around in there, too
09:14:05 <__monty__> Ok, I'll ask there again.
09:38:57 <knupfer> And another release of 'type-of-html' with another 20 % perf increase and 2x faster compile times.
09:39:09 <knupfer> Now 7x faster than blaze-html :)
09:40:36 <erisco> knupfer, is that your doing?
09:40:42 <knupfer> yep
09:41:08 <knupfer> https://user-images.githubusercontent.com/5609565/30388159-2281182c-98af-11e7-8b29-aac26b7fbb57.png
09:41:54 <knupfer> erisco: feel free to ask if you've got questions, I like to have input
09:41:57 <srhb> knupfer: nice, I did not know of it, thanks for that :)
09:42:05 <Geekingfrog> same, that looks very nice
09:42:31 <knupfer> srhb: And it's typesafe, invalid html documents are not inhabited
09:42:50 <srhb> knupfer: I saw, very convincing github intro :-)
09:43:05 <erisco> knupfer, what do you use to emit custom type error messages?
09:43:21 <knupfer> erisco: GHC.TypeLits.TypeError
09:43:48 <erisco> thanks
09:44:02 <knupfer> erisco: And *lots* of type families, which check conditions and trigger them when appropriat
09:44:05 <knupfer> e
09:44:43 <knupfer> I've more or less 300LOC term code and 1500LOC type code :)
09:44:51 <epta> what is the difference between EitherT from `either` and ExceptRT from `errors`?
09:46:08 <srhb> epta: Did you really mean ExceptRT (it exists, but not from there, I think)
09:46:32 <andromeda-galaxy> there's an ExceptT in transformers
09:47:37 <epta> https://hackage.haskell.org/package/either-4.4.1.1/docs/Control-Monad-Trans-Either.html https://hackage.haskell.org/package/errors-2.2.1/docs/Data-EitherR.html
09:50:28 <knupfer> srhb: Do you have any suggestions? I'm sort of an autodidact, never took CS classes.
09:50:36 <erisco> I am surprised the compile times are that high
09:51:28 <knupfer> erisco: Yes, that's the price for the type families. With -O0 its acceptable
09:51:54 <erisco> evaluating type families shouldn't take that long
09:51:55 <knupfer> I already spent a lot of time hand optimizing the type stuff for faster compilation
09:52:33 <erisco> if the difference is in -O0 versus -O1 doesn't this suggest the time is spent in the optimiser?
09:52:33 <knupfer> GHC -v says that it must grok more or less 1.000.000 types :)
09:52:45 <knupfer> yes
09:52:55 <knupfer> its mostly in the optimiser
09:52:59 <erisco> the optimiser doesn't know about type families
09:53:14 <knupfer> but beforehand it did take 2 hours, and mostly in the type checker
09:53:17 <__monty__> knupfer: What's your secret sauce? That's seems like a significant improvement over blaze.
09:54:29 <knupfer> __monty__: I use more modern technology, for example Data.ByteString.Builder.Prim and AppendSymbol
09:54:50 <andromeda-galaxy> __monty__: https://github.com/knupfer/type-of-html#performance
09:55:15 <erisco> I want to look at the guts to see what is up with the compile times
09:55:16 <knupfer> And I avoid *any* overhead I can think of. Blaze uses a monad ...
09:55:51 <erisco> how many LoC for 3 seconds at -O0 ?
09:55:59 <knupfer> erisco: It would be great if you find something, collaborating is great!
09:56:22 <knupfer> 400
09:56:24 <erisco> yeah well I am just interested in what pathological case is happening here
09:56:46 <knupfer> more or less a page of wikipedia
10:00:24 <erisco> also, did you consider TH?
10:00:56 <knupfer> erisco: I wanted to avoid TH at all cost
10:01:03 <erisco> why is that?
10:01:25 <knupfer> I don't like TH and it gave me quite a motivation boost to develop in a minimal environment.
10:01:53 <knupfer> It's an homage to AppendSymbol
10:02:39 <knupfer> Besides, I don't like the syntax of TH and the lack of modularity it imposes
10:03:36 <knupfer> And in this instance I don't think that it would compile faster with TH, as you said most time is spent in the simplifier and TH couldn't help here.
10:04:33 <erisco> well it could because you can do both document validation and optimisation in the qq
10:05:10 <erisco> the full details of which I am not certain, but my intuition says that is an option to explore
10:06:24 <knupfer> Hm, but validation and optimisation of tags and attributes is done in the type checker in the first 2 sec, the rest is the simplifier which get's nuts. And the stuff it simplifies is dependent on user input.
10:07:08 <knupfer> the simplifier sees something like:
10:07:19 <knupfer> e1 <> e2 <> e3 ...
10:07:32 <knupfer> ... e800
10:07:47 <knupfer> for medium sized document
10:08:21 <knupfer> everything is inlined to one huge chain of (<>)
10:09:08 <saurabhnanda> is there any modern editor (not vim, not emacs) that has a good haskell plugin, which works with minimal fiddling?
10:10:35 <ReinH> vim and emacs aren't modern?
10:10:53 <dolio> They're too fast and with too much functionality to be modern. :P
10:11:25 <cocreature> I’ve heard good things about vscode’s haskero and the hie integration for vscode
10:11:35 <cocreature> but I’ve not used either of them myself
10:12:10 <andromeda-galaxy> again I haven't used it, but I know a bunch of people in my group like atom's haskell support
10:12:19 <andromeda-galaxy> but seriously vim & emacs are both very modern
10:12:22 <erisco> knupfer, 2-3 seconds is still surprising to me
10:12:40 <erisco> I have to read the HTML spec first to know the scope of the problem
10:12:46 <saurabhnanda> cocreature: fiddling around with haskero and ran into https://gitlab.com/vannnns/haskero/issues/65
10:12:53 <erisco> what is the source you used?
10:13:50 <__monty__> saurabhnanda: Just curious, why do you want to ditch emacs?
10:13:52 <saurabhnanda> ReinH: there are too many things to learn in the haskell ecosystem. I don't want new team members to be struggling with vim/emacs. Really bad for productivity and initial confidence boost.
10:13:58 <saurabhnanda> __monty__: ^^
10:14:28 <ReinH> What if they already use vim or emacs?
10:14:58 <saurabhnanda> ReinH: then they are medium/power users and can figure out their own toolchain. I'm worried about newbies.
10:15:22 <knupfer> erisco: I've to go (giving piano lessons) and come back in an hour. If you find something, I'd be glad if you'd drop me a line or an issue...
10:16:03 <kebertx[m]> saurabhnanda: I disagree that using vim/emacs implies you're a power user
10:16:03 <erisco> knupfer, I'll let you know what I find
10:16:13 <saurabhnanda> parallel qn -- how  do I upgrade intero in m stack project?
10:16:31 <__monty__> kebertx[m]: You can't deny there's a strong correlation.
10:16:38 <saurabhnanda> kebertx[m]: well... what can I say :)
10:16:53 <kebertx[m]> Vim is really popular among programmers of all levels, and that's supposed to be the hard one
10:17:38 <saurabhnanda> kebertx[m]: the "millenials" are used to atom and sublime nowadays. Just the keybindings and mental model of vim/emacs add another 1-2 weeks to the learning curve.
10:17:53 <ReinH> Most of the OS X keybindings were borrowed from emacs.
10:18:07 <ReinH> You can ctrl-a, ctrl-k, etc.
10:18:24 <__monty__> ReinH: That's a readline thing afaik, not an os X thing.
10:18:31 <ReinH> No, it's an OS X thing.
10:18:35 <ReinH> It works in any app.
10:18:40 <ReinH> It is *also* a readline thing.
10:18:59 <ReinH> I'm pretty sure Safari doesn't use readline under the hood.
10:19:17 <kebertx[m]> I'm only saying someone could already be a vim user, but still not be such a power user that they don't need guidance on setting up their toolchain
10:19:38 <ReinH> There's also a difference between being a vim power user and knowing how to develop haskell.
10:19:55 <Cale> I used vim for quite a long time, but lately I've been trying Sublime. I got really tired of hitting 'u' when I meant to hit 'i', so something that has different annoyances instead is refreshing.
10:20:34 <kebertx[m]> Or know Unix or how to use a command line or compile programs
10:20:49 <__monty__> How are you hitting u instead of i? Are you not touch typing?
10:22:12 <Cale> __monty__: Just when my hands aren't correctly aligned -- which is common when you're just beginning to type and so want to enter insert mode
10:22:32 <knupfer> erisco: Type families have an impact for the simplifier but not for the runtime. When the type checker spits out ~5.000.000 coercions it get's expensive to just ignore that stuff. At last I recall from benchmarking that that had a direct impact on allocations and simplification times.
10:23:11 <knupfer> (allocations of the simplifier)
10:23:16 <kebertx[m]> Freshmen students I tutor are definitely adequate in vim and share tips and tricks with each other, even though they still get lost or confused on basic Python programming concepts
10:23:51 <Cale> __monty__: Normally it wouldn't be a big deal, but it tends to scroll you away from where you were looking, so not only do you need to redo, but you need to go find the place you were going to make your edit again.
10:24:06 <kebertx[m]> Frankly, that's probably because of an attitude that vim makes you cool, but ¯\\\_ (ツ) _/¯
10:24:29 <Cale> It was just this little thing that would happen every once in a while and slowly annoyed me more and more
10:24:40 <Cale> (along with a few others)
10:24:45 <erisco> knupfer, if by simplifier you mean optimiser then as I said before, the optimiser does not see type families
10:24:47 <__monty__> kebertx[m]: That might be a local thing. I was one of very few students using emacs/vim at my uni.
10:25:16 <__monty__> Cale: Ctrl-o?
10:25:49 <Cale> hm?
10:26:06 <kebertx[m]> monty: I can buy that, there are some real old fashioned professors in my department who encourage the old ways
10:27:26 <__monty__> Cale: It jumps back to previous locations.
10:27:29 <Cale> ah
10:27:31 <kebertx[m]> (not sure if raw or preprocessed markdown is sent to the irc channel, but on matrix your name comes up in bold)
10:27:41 <Cale> Yeah, that might help somewhat with it :P
10:27:57 <erisco> knupfer, it could be pathological type inference or maybe O(n^2) type families or something like that
10:28:22 <__monty__> kebertx[m]: That's because I'm such an important person ; )
10:28:47 <Cale> Maybe when I get tired of Sublime's annoyances, I'll switch back and remap Ctrl-o to something easier to hit.
10:29:33 <kebertx[m]> The <b>monty</b>???
10:30:11 <dolio> It is pretty easy, if you put your control in the right spot.
10:30:30 <dolio> Which modern keyboards don't.
10:30:58 <__monty__> Cale: Also, maybe a keyboard with more noticeable tactile bumps is all you need. Or just get in the habbit of feeling for them. I never have the problem in vim. Only when typing single handed but that's a rare situation anyway.
10:31:22 <__monty__> dolio: Are you talking about my sacred ESC space?
10:31:36 <dolio> There are two right places.
10:31:50 <dolio> One is where caps lock normally is, the other is where alt normally is.
10:32:00 <dolio> You can take your pick.
10:32:11 <__monty__> kebertx[m]: Yes, the boldness on matrix and the underlinedness on irc.
10:33:15 <dolio> I use the former, because I don't think putting escape there is actually more useful, if that's what you're talking about.
10:33:31 <__monty__> : o sacrilege
10:33:49 <dolio> Escape is ^[, so you don't need an escape button.
10:34:19 <dolio> Unless you're on a non-US layout.
10:34:22 <Cale> One thing that I have found really nice about Sublime is that it restores state really nicely when reopened.
10:34:53 <__monty__> Ctrl would be pinky where it is and at caps so I don't see the improvement really. At least ESC is miles away.
10:35:13 <Cale> Also, the multiple cursors thing is nice for working with Haskell indentation.
10:35:20 <__monty__> Cale: Vim can do that too though.
10:35:37 <__monty__> Also, vim's block selection is pretty good for indentation.
10:35:48 <Cale> vim's block selections is *okay* at that
10:35:51 <Cale> -s
10:35:57 <Cale> But not quite as nice
10:36:13 <Cale> Of course, really, no text editor does the thing I'd want it to do
10:36:28 <__monty__> Example where multiple cursors is nicer?
10:37:22 <Cale> It's just visually better while you're moving blocks around -- with block-mode you sort of have to do things without the correct visual feedback and then it repeats stuff across lines for you at the end
10:39:54 <dolio> __monty__: There's a pretty big difference between moving your pinky slightly to the left and rotation your hand to get to where the "ctrl" button is usually placed.
10:39:58 <Cale> But what I'd really want is for any edit that causes the first non-whitespace character following 'do', 'of', 'let', or 'where' (or 'rec' or 'mdo') to move to cause the rest of the block to move accordingly.
10:40:00 <__monty__> I understand it looks snazzier but a single line is enough feedback imo.
10:40:08 <dolio> Rotating, even.
10:40:35 <dolio> If you do it constantly, at least.
10:41:21 <__monty__> dolio: Caps feels like more of a reach, ctrl is just a bending of my pinky at the proximal interphalangeal joint.
10:41:23 <dolio> Anyhow, thumb is also good.
10:41:36 <dolio> But I actually use alt quite a bit now.
10:41:43 <__monty__> My hand doesn't move when hitting ctrl.
10:42:10 <dolio> Oh. Well, I'm not sure how you manage that. :)
10:42:26 <Cale> foot pedal
10:42:35 <glguy> mind link
10:42:48 <dolio> Maybe I need a finglonger.
10:45:27 <dolio> Anyhow, use whatever setup you want, of course. I just think that putting ctrl there makes esc easy enough to type in the situations I actually need it (terminals), _and_ it makes a bunch of other stuff easy to type.
10:45:34 <dolio> Which putting esc there doesn't.
10:46:55 <dolio> If hitting ctrl normally isn't a problem, you could do something cooler, like putting backspace there.
10:48:08 <__monty__> But, backspace is so easy to reach for.
10:48:24 <__monty__> It's really a strong pinky vs weak pinky thing.
10:48:29 <ongy> dolio: I press my ctrl button with the palm of my hand
10:49:51 <ongy> but then again, I don't work on a laptop
10:50:47 <dolio> I don't either, typically. But yeah, it wouldn't work well on most laptop keyboards.
10:50:48 <__monty__> What I imagine your keys must look like: http://gadgetsin.com/uploads/2010/02/usbkeypresslight5.jpg
10:52:20 <dolio> They look like that, but smaller.
10:53:05 <dolio> On the board I'm using now, if pressing backspace isn't inconvenient, escape wouldn't be, either, because it's where the tilde is by the markings on the keys.
10:56:01 <ongy> board? are you one of those people that buy their keyboard in pieces?
10:57:20 <dolio> Nah. That's too much work that I've never done before.
10:57:48 <cmotoche> Hello everyone. May you know how to set default values when expecting a list of values on optparse-applicative?
10:57:54 <dolio> I don't want my first soldering job to be on some multi-hundred-dollar item.
10:58:12 <cmotoche> I cannot use value
10:58:29 <cmotoche> because it causes unexpected issues with `some` and `many`
10:59:01 <cmotoche> http://hackage.haskell.org/package/optparse-applicative-0.14.0.0/docs/Options-Applicative-Builder.html#v:value
10:59:25 <monochrom> There is a very cheap laptop on which the backspace key is next to the power key. :D
11:03:05 <__monty__> cmotoche: Sounds like you need to work around the actual problem rather than ignore it ; ) You should probably wrap your some or many call.
11:25:22 <dsal> Is there any way to use crypto-api to generate numbers?  (assuming I don't want to do something that I think is good, but probably terrible from a crypto perspective).
11:26:29 <dmwit> [1..] seems like a good way to generate numbers, and doesn't even need crypto-api.
11:26:36 <dmwit> Or: what are your requirements on these numbers?
11:27:02 <dsal> I just made a little utility for generating random numbers on the commandline.  PINs and stuff (needed some PINs).
11:27:12 <dsal> Ideally, I'd like random n digits of [Char]
11:27:25 <dmwit> There is a module named Crypto.Random. Presumably that's a good place to start if you want random numbers.
11:27:39 <dsal> Yeah, it will make me a ByteString
11:27:46 <__monty__> Sounds like a simple bash script that reads from /dev/random would suffice.
11:28:10 <opqdonut> :D
11:29:46 <dsal> So,    Int -> [Char] -> ByteString -> [Char]      for n random chars selected from a specific set.
11:30:18 <dsal> System.Random has better facilities, but it doesn't seem that Crypto.Random's generator is useful for System.Random's useful bits.
11:37:57 <dsal> I guess I can probably adapt it myself.
11:43:27 <tabaqui> is there any overhead in using many "try" functions?
11:44:28 <tabaqui> I mean, even fail is impossible at all?
11:44:35 <tabaqui> s/even/if
11:46:53 <vimalloc> I'm pretty new to the haskell ecosystem. For new projects, is there any consensus on using stack vs cabal? (happens to be a rest api with servant, if that affects things at all)
11:47:13 <glguy> No, there isn't a consensus, and both work
11:47:34 <vimalloc> ok. Thx.
11:47:43 <sm> I'd say it depends what part of the community you ask
11:47:49 <tabaqui> afaik, stack cannot work without cabal
11:48:05 <tabaqui> I prefer cabal for small project without internal dependencies
11:48:10 <glguy> sm: That's how you know there isn't a consensus :)
11:48:14 <sm> each part has their own a strong consensus :)
11:48:44 <sm> for newcomers, I think's it's honest to say the consensus is stack
11:48:59 <monochrom> It is still useful to point out the stronger statement "some people think there is a consensus, but it's in their favour meaning they're biased".
11:49:16 <glguy> sm: No, I think that's just as divided
11:49:30 <__monty__> vimalloc: Check out nix as well ; )
11:49:44 <sm> well: vimalloc, as you see "it's complicated" :)
11:50:13 <monochrom> "Newcomers" is also a false classification.
11:50:23 <vimalloc> sm: heh, indeed :)
11:51:06 <monochrom> Some newcomers just want to focus on learning the language, in which case the extra scaffolding of stack is distracting.
11:51:46 <__monty__> Cabal is also unavoidable when working with haskell so it'd be good to learn to use it.
11:52:08 <sm> monochrom: I agree.. up until it saves them from dep headaches which would be very distracting
11:52:16 <monochrom> The other newcomers want "dive-in projects" (which is invariably distracting but meh) in which case stack is more sane because by the time you ask for "project" you are begging for scaffolding overhead anyway.
11:53:20 <sm> consensus as of 2017 = learn both ?
11:53:27 <monochrom> dep headache is a thing of the past
11:54:00 <monochrom> I don't like it but it's true: since sandboxing, the dominating cause of dep problems is gone.
11:54:33 <sm> but sandboxing is a headache. It isn't automatic, or free from gotchas
11:55:10 <__monty__> sm: While true, no problem letting people new to haskell find that out.
11:55:15 <nshepperd> cabal sandbox init; cabal install stuff; cabal exec ghc -- whatever.hs; continue until hacking complete
11:55:25 <sm> I'm not sure I'd go along with "dep headache is a thing of the past"...
11:55:40 <sm> it's never quite that simple
11:56:10 <sm> as always, it varies according to your usage patterns
11:56:23 <__monty__> I learned without sandboxing, just trashing the installed packages whenever there was a problem. It was a slight annoyance but not at all distracting from learning the language.
11:56:23 <glguy> Yeah, sometimes the package you use isn't compatible with the stackage snapshots you want to use and things get messy
11:56:53 <hexagoxel> learn and use make; at least that will be useful even after you find out in what mess the haskell ecosystem is :D
11:57:03 <glguy> or someone left off some upper bounds you and have to figure things out, but it's usually not that bad
11:57:12 <monochrom> Yeah, dep headaches now appear when using stack. But I was referring to cabal with sandboxing.
11:57:45 <monochrom> OK, so correction: Since sandboxing, the dominating cause of dep problems has shifted on to stack. There!
11:58:30 <hexagoxel> only if cabal enabled the require-sandbox flag by default
11:58:39 <hexagoxel> i don't think it does.
11:59:03 <monochrom> It doesn't. But it can be set in $HOME/.cabal/config
12:03:14 <tempay> so, say I have an expensive operation and a functor with multiple positions, like a list or something. Is there a way to wrap the function to be evaluated in parallel when I apply it to the functor with fmap? 
12:03:34 <tempay> or am I doomed to reimplement the Functor instance?
12:09:31 <tempay> ok, think i figured it out
12:31:10 <nshepperd_> 'parallel' package has parTraversable which works for anything with Traversable instance
12:31:25 <dsal> How do I tell what the host word size is?
12:33:15 <`Guest00000> emergency!!! how to pronounce <*, *> ?
12:33:51 <hrnz> inner product?
12:34:03 <hrnz> "weird looking smiley map"
12:34:50 <aweinstock> > Data.Bits.popCount (-1 :: Data.Word.Word) -- dsal
12:34:52 <lambdabot>  64
12:34:55 <dsal> heh, that's exactly what I just did.
12:34:58 <`Guest00000> (<*) and (*>)
12:35:00 <dsal> aweinstock: thanks
12:37:05 <__monty__> `Guest00000: *> == >> so seq? 
12:38:14 <dsal> I just made a RandomGen instance  for crypto's random thing so I could generate super secure four digit PINs.
12:38:42 <__monty__> `Guest00000: Maybe left and right cyclops respectively?
12:39:51 <__monty__> dsal: Why do you think it's more secure with crypto.random?
12:40:53 <dsal> I don't think it is, really.  It's a RandomGen instance of SystemRandom for crypto.  It's possibly just a really roundabout way of doing the default thing.
12:41:04 <aweinstock> (foldr1 (<*), foldr1 (*>)) are kind-of-like CL's prog1 and progn, respectively; should that inform their names?
12:42:55 <__monty__> They're not widespread nor self explanatory so I vote no.
12:57:03 <monochrom> But seq also stands for another thing. Try "seq undefined ()" some day.
12:58:07 <monochrom> Anyway I don't see how prounciation is an emergency rather than a passing curiosity. Does the ambulance dispatch really need you to convey (*>) over the phone?
13:00:44 <monochrom> The blurb "Sequence actions, discarding the value of the first/second argument" straight from the doc should be all you ever need.
13:06:59 <monochrom> But see http://lpaste.net/159152
13:10:12 <dsal> Is there a stack command that updates your local stack stuff the latest LTS?
13:10:30 <cocreature> dsal: no
13:10:43 <dsal> I keep not knowing there's a new LTS.
13:11:33 <cocreature> there is an rss feed iirc
13:13:03 <xzhu> If I translate a C program into Haskell, line-for-line, using IORefs, would it be as fast as the C version?
13:14:28 <cocreature> xzhu: no, a) IORefs are boxed so they always have an overhead b) the bigger problem are mutable arrays. IORef doesn’t really help you here
13:14:38 <dsal> Is LTS just this?  https://github.com/fpco/lts-haskell/
13:14:41 <[exa]> if you make everything strict and somehow persuade ghc to run the evaluation on stack and not STG, then probably
13:15:58 <dsal> Oh, I found the RSS.  yay.
13:16:15 <guillaum2> https://gist.github.com/guibou/700b889fb6c4ee7c10832873571c74e8 << is this a GHC bug or I did something weird? (Pattern synonym + unboxed sums)
13:16:27 <cocreature> dsal: https://www.stackage.org/ lists all snapshots
13:17:08 <dsal> Thanks.  I just don't want to fall behind since I know am almost up to a double-digit percentage understanding of what I'm doing.
13:22:11 <xzhu> Has there any efforts in creating a comprehensive imperative DSL (aimed for performance) in Haskell?
13:23:41 <dsal> Wasn't that perl6?
13:25:17 <pgiarrusso> xzhu, what's a "comprehensive imperative DSL"? Haskell Symposium, ICFP, PEPM and maybe GPCE are rich with performance-oriented DSLs, Haskell or not
13:25:50 <cocreature> you could see ST as an imperative performance oriented DSL
13:25:59 <MP2E> does Ivory count ? :P it's a restricted subset of C embedded in Haskell
13:26:09 <pgiarrusso> but usually they get lots of optimization benefits thanks to domain-specific optimizations
13:26:14 <pgiarrusso> well, OK
13:26:24 <aweinstock> xzhu: https://ivorylang.org/ivory-introduction.html ?
13:29:02 <pgiarrusso> OK, seems the point is to have a safer C using Haskell for typing and as a macro language
13:29:50 <aweinstock> yup, that's a decent summary of Ivory
13:31:18 <pgiarrusso> also, since it actually generates C to be compiled, it could have performance very close to C or even the same (modulo their restrictions on C)
13:32:25 <pgiarrusso> if you translate C to Haskell otherwise, beyond the issues mentioned, you probably have low-level constant factors slowdown just because more people work on low-level optimization of C compiler backends
13:32:36 <pgiarrusso> but generating C solves that
13:33:07 <pgiarrusso> (when compiling Haskell via C, however, you usually get unusual C to preserve Haskell semantics, and the result is not as good)
13:33:35 <pgiarrusso> all of this IIUC, I'm afraid I speak from the ivory tower
13:34:11 <Subeff>  ehi guys, thank you being so helpful! I wonder where to import that Reader I am reading about in the book, I do not have it in Prelude, and the one from Control.Monad.Trans.Reader does not seem to satisfy the compiler
13:34:29 <Subeff> The exercise looks something like "asks f = Reader ???"
13:34:36 <Subeff> with type asks :: (r -> a) -> Reader r a
13:35:00 <MarcelineVQ> chances are it's defined a little earlier in your material
13:35:20 <guillaum2> Subeff: how does it does not satisfy the compiler ?
13:35:53 <monochrom> If the intended code is "asks f = Reader ???" then it is definitely from the book itself or an exercise for you.
13:35:55 <MarcelineVQ> and by chances are I mean in section 22.5
13:36:23 <Subeff> hmmm maybe MarcelineVQ is right, I should probably copy it from the book 5-6 pages before that
13:36:28 <geekosaur> Subeff, I think you are seeing a change in the transformer library
13:36:28 <MarcelineVQ> and by defined I mean has an entire section about :>
13:37:00 <geekosaur> Reader is no longer a data constructor. use the lowercase version instead
13:37:12 <monochrom> -_-
13:37:40 <geekosaur> (this may change in a future release because backward compatibility is possible now)
13:37:56 <jle`> Subeff: yeah, Reader is now an abstract data type
13:38:16 <jle`> so instead of directly using a 'Reader' constructor, we use the abstract constructor 'reader'
13:38:17 <MarcelineVQ> geekosaur, jle` : in this case it's a Reader given in the book the user has to write in order to do an earlier exercise
13:38:43 <glguy> Reader isn't abstract now, it's a type synonym for ReaderT
13:38:58 <MarcelineVQ> the standard unfluff one   newtype Reader r a = Reader { runReader :: r -> a }
13:39:19 <xzhu> Even with current syntax of Haskell unchanged, do you think GHC could be much optimized (generating much faster machine code for various common architectures) in the forseeable future?
13:39:22 <jle`> yeah, 'Reader r' is no longer directly made using a constructor, it's abstracted over using a type synonym and a smart consturctor
13:39:33 <monochrom> Meanwhile, in an alternative universe in which Bird's textbook is the most popular one...
13:40:01 <monochrom> "Hi, where do I import Parser I'm reading about in the book?"  "cabal install parsec"
13:40:34 <xzhu> If more people were working on the lower-level optimization of GHC, that is
13:40:45 <MP2E> I think GHC still has some low hanging fruit, sure. I think that abstracting the garbage collector so that we can use plugins to swap them out depending on workload is a good start in this direction. Also Linear types, which will hopefully help us avoid the GC for tight inner loops
13:40:56 <MP2E> linear types is already happening
13:40:59 <MP2E> dunno about the former
13:41:08 <monochrom> and everyone ignores Delphi who cries "it's in the first line of code in 11.1"
13:41:26 <Subeff> yes jle` MarcelineVQ is right, it now works! Hopefully I will manage to twist my mind to understand the Reader
13:45:12 <[exa]> MP2E: I'm working on a compiler on that
13:45:29 <[exa]> MP2E: should be ready next month or so
13:45:48 <xzhu> I am reading https://ghc.haskell.org/trac/ghc/wiki/LinearTypes but it seems confusing to me
13:45:53 <MP2E> Nice! :) that's awesome
13:46:09 <xzhu> May I ask what is the motivation of it?
13:46:43 <xzhu> What is "linear logic"?
13:46:50 <[exa]> xzhu: this is the best read about linear types in FP now https://arxiv.org/pdf/1612.06633.pdf
13:47:20 <glguy> xzhu: The motivation for it is the first section of the page you've linked to
13:47:55 <[exa]> xzhu: anyways this is about the logic background http://homepages.inf.ed.ac.uk/wadler/papers/lineartaste/lineartaste-revised.pdf
13:49:13 <pierrot> Hi. Yesterday I used the Test.QuickCheck module in a program. Today, ghc can't find it. The only thing I can think about that could have broken this, is that I forced the reinstallation of the parsec module.
13:50:00 <pierrot> When I do `ghc -v` I see that "package QuickCheck-2.10.0.1-DTIBC3CyU6p3h4xSnOjkg1 is unusable due to shadowed dependencies: random-1.1-DtLcP2Z2iOOC0RwcSmXjBK tf-random-0.5-ABDhxe3mXYlHUEE5hzgewx"
13:51:29 <monochrom> But parsec wouldn't affect random or tf-random.
13:52:20 <pierrot> Hmm... I thought that the reinstallation of parsec had affected those modules...
13:52:38 <pierrot> Then I don't have any idea why QuickCheck was usable yesterday and not today
13:53:19 <glguy> pierrot: forced reinstallations breaks things, so if you did one and things are broken, then everything's working correctly
13:53:58 <pierrot> glguy: how can I clean this mess?
13:54:53 <sm> reinstall QuickCheck
13:56:39 <pierrot> I tried, but `cabal install quickcheck --reinstall` fails
13:56:59 <monochrom> quickcheck? QuickCheck?
13:57:09 <dolio> The original motivation for linear logic was to create models of System F, or something.
13:57:11 <monochrom> (Although, I think cabal doesn't mind the cases.)
13:57:33 <dolio> At least, I've heard.
13:57:37 <monochrom> At any rate what was the complete output before it failed?
13:58:14 <monochrom> Have you ever received complaints from your end users and found that they were infuriating (as opposed to ed)?
13:58:32 <pierrot> http://sprunge.us/dYZE
13:58:35 <monochrom> As in they just told you "it doesn't work" and nothing specific?
13:59:06 <erisco> isn't their job to educate you
13:59:53 <sm> pierrot: hmm.. nuke it from orbit ?
14:00:37 <sm> or, find a cabal expert to dig you out of this
14:01:24 <glguy> It's a GHC problem at this point. You can check the output of: ghc-pkg check  , to see what packages it thinks are broken now
14:03:02 <sm> maybe https://github.com/haskell/cabal/issues/4728 is related
14:03:10 <pierrot> `ghc-pkg check` gives an empty output.
14:04:16 <pierrot> Can I remove ghc completely and reinstall the haskell platform? Maybe it's easier than digging into cabal internals
14:04:40 <MarcelineVQ> are you using a sandbox for your project?
14:04:49 <pierrot> No, I'm not
14:05:10 <monochrom> "remove ghc completely" is going to do nothing for you.
14:05:47 <monochrom> If you want to act on sm's advice "nuke it from orbit", you need to read my http://www.vex.net/~trebla/haskell/sicp.xhtml#remove for what it means.
14:06:01 <monochrom> And it does not mean nuking GHC itself. Completely irrelevant.
14:06:13 <pierrot> I don't know where the libraries are saved... I thought it was something like /usr/local/haskell/lib or something...
14:06:33 <monochrom> In fact, read the whole thing for maximum melting away of all of your fundamental assumptions.
14:07:42 <geekosaur> "shadowed dependencies" means the global one's still there but there's a local one in the way. seems like cleaning ~/.ghc should work
14:10:59 <pierrot> Ok, I'll read all the document first and come back in case of any question
14:11:50 <pierrot> s/all the/the whole/
14:15:37 <dmwit> pierrot++ for being willing to read documentation
14:16:36 <dmwit> I have also read the whole thing and can affirm that it is well worth the read.
14:26:08 <`Guest00000> suppose (f :: Param -> Something). what is the convention for naming things like (g :: (Param, Param) -> Something -> Something), where (from, to) is the argument to `g` and `g` changes Something which was output by (f from) to as if it was output by (f to)?
14:26:33 <`Guest00000> correctParam?
14:31:07 <lyxia> I don't think there is a convention for such a thing
14:31:53 <lyxia> it's also too abstrat to make sense
14:32:37 <`Guest00000> data FooMode = Forward | Backwards
14:32:48 <`Guest00000> foo :: FooMode -> Something -> [Thing]
14:33:04 <`Guest00000> correctMode :: (FooMode, FooMode) -> [Thing] -> [Thing]
14:33:22 <`Guest00000> correctMode (m1, m2) l | m1 == m2 = l
14:33:32 <`Guest00000> correctMode (Forward, Backward) l = reverse l
14:33:41 <`Guest00000> correctMode (Backwards, Forward) l = reverse l
14:35:07 <lyxia> This looks functorial.
14:35:35 <`Guest00000> (foo Backwards == reverse (foo Forward))
14:36:19 <monochrom> (foo Backwards == reverse (foo Forward)) is a type error.
14:37:06 <monochrom> Expected type [a], inferred type Something->[Thing]. Or the other way round.
14:38:28 <`Guest00000> ouch
14:38:42 <`Guest00000> just add Something there
14:38:53 <lyxia> where
14:39:18 <monochrom> Not in scope: data constructor Something.
14:40:07 <ReinH> And (Forward, Forward)?
14:40:23 <`Guest00000> (i meant a value of the type, not the constructor)
14:40:32 <ReinH> Oh, I see.
14:40:36 <monochrom> Naw, that's for correctMode but I'm referring to foo.
14:40:52 <monochrom> OK, so insert what value?
14:40:56 <ReinH> Also you don't need the guard, just reorder your cases.
14:41:23 <`Guest00000> any value
14:41:25 <ReinH> Alternatively, use the guard and an otherwise rather than the separate cases.
14:41:26 <`Guest00000> make it up yourself
14:41:57 <monochrom> Where can I participate in that experiment in psychology where the participant is asked to press a button to electrocute a person for making compile-time errors?
14:42:30 <`Guest00000> swap participant and person
14:42:30 <lyxia> `Guest00000: foo :: FooMode -> [Thing]   seems to make sense
14:42:45 <lyxia> instead of having a dummy Something
14:42:46 <monochrom> (foo Backwards undefined == reverse (foo Forward) undefined)  Like this?
14:42:56 <`Guest00000> damn, that's just pseudocode
14:42:57 <monochrom> err
14:43:04 <monochrom> (foo Backwards undefined == reverse (foo Forward undefined))  Like this?
14:45:08 <monochrom> Don't make excuses. Pseudocode still has to make sense and show a minimum level of self-consistency and coherence.
14:45:58 <`Guest00000> it does in your head
14:46:17 <monochrom> Speak for yourself.
14:46:28 <`Guest00000> omg that's obvious mistakes
14:46:58 <monochrom> And you still haven't answered my question.
14:47:10 <`Guest00000> yes, obviously, like that
14:47:27 <monochrom> But I guess I have to break it down to you why my question matters.
14:47:35 <`Guest00000> foo is not the point, the point is correctMode
14:47:54 <monochrom> OK so why brought up foo?
14:48:06 <`Guest00000> for correctMode to exist
14:48:40 <monochrom> What do you mean? correctMode doesn't even mention foo or Something.
14:49:05 <`Guest00000> correctMode doesn't need to exist without foo.
14:49:20 <monochrom> OK so foo is half of the point.
14:49:37 <`Guest00000> that's meaningless technicalities
14:49:50 <`Guest00000> how did you even measure the half?
14:50:11 <monochrom> If you bothered to have foo take on an extra Something parameter, chances are its value actually affects the [Thing] produced.
14:50:24 <`Guest00000> yes, it does
14:50:56 <monochrom> It is completely unclear, in case x/=y, whether (foo Backwards x == reverse (foo Forward y)) should be true or false or "unknown, depends on actual x and actual y"
14:51:18 <monochrom> So what the hell were you thinking when you said "just make up a value"?!
14:51:26 <`Guest00000> a value means singular
14:52:08 <monochrom> And that's only one example.
14:52:17 <`Guest00000> of what
14:52:40 <monochrom> Of how unclear and un-thought-out you are.
14:53:07 <monochrom> How pseudocode still has to make sense and you are not.
14:53:29 <zoid1> #join haskell.de
14:53:30 <lyxia> `Guest00000: is the property you're interested in that for all x,y :: FooMode, s :: Something  correctMode (x,y) (foo x s) = foo y s
14:54:21 <`Guest00000> lyxia: yes
14:56:40 <lyxia> I can see that it's a functor but I'm not sure it would be a good idea to call it fmap
14:57:07 <wilornel> Hmmm that's weird.. I can't find a clear straighforward way to find the index of a substring in a string
14:57:26 <wilornel> I mean, with a function that does it for you. I would rather not reinvent the wheel here
15:01:24 <monochrom> It is not in the standard library or Text or Vector.
15:02:39 <monochrom> Actually it is in Text in a more useful form: breakOn.
15:09:02 <verement> > findIndex ("foo" `isPrefixOf`) (tails "abcfoobar")
15:09:05 <lambdabot>  Just 3
15:09:16 <wilornel> that is infact a better form, monochrom 
15:09:20 <wilornel> in fact*
15:10:22 <wilornel> is there breakOn for a list of substrings, returning the first matching one?
15:11:12 <monochrom> I strongly recommend migrating to Text altogether.
15:11:35 <dmwit> `Guest00000: There is some literature about self-adjusting computation: algorithms which can react to changes in their input, computing an updated output more efficiently than rerunning the whole algorithm.
15:11:35 <monochrom> But Data.List.Split (package "split") has something too.
15:11:49 <dmwit> `Guest00000: To the extent that there is a name for this, I would guess that's it.
15:12:54 <dmwit> wilornel: Usually when I start reaching for that function and others like it, I end up deciding it's worth writing an actual parser instead.
15:13:02 <dmwit> I've never been sad about this later, always happy.
15:14:13 <dmwit> (Sometimes that parser is just a regex! But usually not.)
15:14:16 <monochrom> Although, split is all about doing that kind of splitting recursively (to the rest of the list).
15:16:41 <monochrom> And yeah going all-out parsing is also a common practice and explains why there is little supply and demand on substring location functions. Because most would-be use cases would be parsing anyway.
15:17:16 <monochrom> Unfortunately we have a parsing technique that doesn't first ask about substring locations.
15:18:06 <dmwit> What does "ask about substring locations" mean? Why is it unfortunate that a parsing technique doesn't do that?
15:18:33 <monochrom> It means "at what index does 'needle' occur in a bigger string"
15:18:56 <monochrom> Unfortunate is for people who really want to ask for that index. :)
15:19:06 <dmwit> ah =)
15:19:24 <monochrom> For example for people from C background whose only parsing technique is to call those functions all the time.
15:20:38 <dmwit> I firmly believe that, in general, people do not know what they want.
15:22:44 <monochrom> Although, 'manyTill (string "needle")' has its share of problem as well e.g. performance.
15:25:18 <monochrom> Data.Text's breakOn is best of both worlds, assuming a parser library provides a parser combinator that calls breakOn and you use that parser combinator instead.
15:26:01 <monochrom> Unfortunately Data.List and Data.List.Split doesn't have it.
15:27:40 <monochrom> Ah Bytestring has breakSubstring. That's nice.
15:28:13 <monochrom> In fact it's even better. They have findSubstring and it's "findSubstring is deprecated in favour of breakSubstring"
15:30:03 <monochrom> People perform forgetful depth-first search.
15:32:41 <michalrus> Uhh. `withTransaction :: Connection -> IO a -> IO a` Can I change it into MonadIO easily? :c
15:32:59 <michalrus> liftIO works one way, but what about the argument?
15:33:13 <monochrom> Are you sure you have the right type there?
15:33:35 <michalrus> Well, it’s *their* fault! https://hackage.haskell.org/package/postgresql-simple-0.5.3.0/docs/Database-PostgreSQL-Simple-Transaction.html#v:withSavepoint
15:33:57 <michalrus> (Disregard the #fragment :p)
15:34:37 <michalrus> I want to use this in a Servant’s Handler.
15:34:58 <monochrom> It doesn't look like you need liftIO.
15:35:13 <michalrus> Which is (MonadThrow m, MonadError ServantErr m, MonadCatch m, MonadIO m), and maybe something additional.
15:35:16 <michalrus> Hmmmmm.
15:35:31 * michalrus scratching head
15:35:38 <verement> @let breakOn needle haystack = fromMaybe (haystack, "") $ find (isPrefixOf needle . snd) $ zip (inits haystack) (tails haystack)
15:35:39 <lambdabot>  Defined.
15:35:40 <monochrom> OK sure then your need of liftIO is due that that rather than due to withTransaction.
15:36:02 <monochrom> liftIO (withTransaction c (putStrLn "hello"))
15:36:29 <michalrus> Yes, yes. And my question is: how can I write Handler code (*not* just IO code) inside withTransaction?
15:36:41 <monochrom> Probably cannot.
15:36:43 <michalrus> Something like unliftIO but I don’t know how that would work.
15:36:47 * michalrus cries
15:37:05 <michalrus> So I can’t have SQL transactions inside Servant Handlers? :P
15:37:12 <michalrus> At least with that library.
15:37:26 <monochrom> Does Servant's tutorial show you some tricks for this?
15:37:48 <michalrus> I haven’t seen transactions, but let me look once more.
15:39:05 <michalrus> It doesn’t seem so. :(
15:39:57 <michalrus> And the old pgsql-simple used MonadIO, but they decided to go with IO.
15:40:05 <michalrus> In the newer versions.
15:43:17 <moghedrin> Question for the room, I'm looking to generate appropriate lenses for something like so: https://gist.github.com/daghack/2d854d0d3000c6bcb5c49000d54d4582
15:44:11 <moghedrin> Is there an easy way to do this?
15:47:45 <michalrus> monochrom: hsql is using IO, too. :/ There must be a way, uh.
15:48:59 <lyxia> moghedrin: try this:   makeLenses 'UserRow
15:50:36 <moghedrin> lyxia: That was my thought, initially. Comes back with the error `makeFieldOptics: Expected type constructor name`
15:51:38 <lyxia> ah maybe lens doesn't use that trick
15:55:22 <lyxia> moghedrin: what version of lens?
15:56:13 <erisco> if forall x y, xRy ⇒ xR(f(y)) then what property do we say f has?
15:56:31 <erisco> if we choose R as implication then (x⇒y)⇒(x⇒f(y))
15:56:46 <erisco> so by correspondence, (x → y) → x → F y
15:57:20 <monochrom> If R is a partial order, then we say that f is increasing.
15:57:37 <monochrom> If R is more arbitrary than that, I think I haven't come across it.
15:57:52 <moghedrin> lyxia: Currently microlens, so I guess not the lens library proper. Didn't even think about that.
15:58:05 <moghedrin> Let me go check to see if that works on the real lens library. XD
15:58:55 <lyxia> moghedrin: it works here
15:59:18 <monochrom> But it is some form of "f preserves R in some sense" or "R preserves f in some sense" and I don't know which way it is.
16:00:03 <erisco> I will call it… f is left-local, and the dual is right-local
16:00:12 <lyxia> 0 <= x and 0 <= f(x) for every f : N -> N and x : N
16:00:53 <erisco> f is left-local to R if forall x y, xRy ⇒ xR(f(y)) … so I am saying f stays around x
16:01:06 <erisco> hence "left local" … is this clever enough?
16:01:44 <moghedrin> lyxia: Yeah, now I feel a bit dumb. Works in lens, but not microlens. Thanks for helping me realize the obvious. <3
16:02:55 <erisco> actually I should probably think of how to use child/parent terminology instead
16:03:11 <erisco> visualising R as a directed graph
16:04:48 <erisco> I can say f preserves children if forall x y, xRy ⇒ xR(f(y)) and the dual is f preserves parents
16:05:03 <erisco> hows your taste, monochrom?
16:05:59 <erisco> then you could also have f preserves descendants and f preserves ancestors
16:10:33 <michalrus> monochrom: there’s https://hackage.haskell.org/package/unliftio ;O
16:10:36 <michalrus> But I dunno.
16:11:49 <michalrus> “Note that, in order to meet the laws given below, the intuition is that a monad must have no monadic state, but may have monadic context. This essentially limits MonadUnliftIO to ReaderT and IdentityT transformers on top of IO.”
16:12:07 <michalrus> That’s kind of expected but eshhh.
16:12:30 <biglambda> Does anyone happen to know how I can get stack to use a patched version of c2hs.
16:12:37 <michalrus> So, basically, I can’t have Handler code inside postgresql-simple transactions.
16:12:44 <biglambda> I’m able to do it with cabal build, but not stack.
16:13:26 <biglambda> I just have a path to the patched c2hs on my system, or I have url for the fork on github.
16:14:34 <lyxia> biglambda: if you have a path to it you can add it in your stack.yaml
16:14:54 <biglambda> What parameter would it be in stack.yaml?
16:15:48 <lyxia> biglambda: add the path under "packages:"
16:18:01 <biglambda> Hmmm… ok is there a sub parameter to specify that it’s the c2hs path?
16:29:13 <biglambda> To be clear I’m trying to repeat the behavior of the —with-PROG cabal option in stack for c2hs
16:29:41 <pierrot> monochrom: I've read your web page. I still don't understand why I have shadow dependencies. That would imply that I have more than one instance of the same package, but that doesn't happen.
16:30:34 <Fylwind> how do you get Cabal to ignore the global package DB when using a sandbox? --package-db=clear doesn't seem to have any effect
16:33:15 <pacak> Fylwind: You can pass -no-user-package-db to ignore user package db, but I'm not sure about global package db. cabal needs to get base from  somewhere...
16:33:44 <lyxia> biglambda: I think it picks the program from your PATH, doesn't it?
16:34:11 <biglambda> Possibly yes.
16:34:49 <Fylwind> pacak: well I have a substitute DB that has base and all that
16:35:02 <Fylwind> pacak: I'm looking for a cabal flag though, "-no-user-package-db" is a GHC flag
16:35:14 <lyxia> biglambda: so put c2hs in PATH
16:36:06 <pacak> Hmm... Not sure if base can be changed without changing ghc.
16:37:20 <monochrom> erisco: Ah, parent-child is a cool idea, because now you speak of inheritance :D
16:38:19 <monochrom> pierrot: That will need at least a "ghc-pkg list" to affirm or deny.
16:39:23 <monochrom> Also "ghc-pkg dot" but it tends to be too overwhelming.
16:39:47 <monochrom> "ghci -v" is usually right on.
16:41:15 <monochrom> Fylwind: GHC internal coding makes strong assumptions about the exact build of base and ghc-prim etc etc so in practice ignoring global will not work. Sure it is allowed but so what.
16:42:03 <monochrom> In the same sense that university students are always allowed to fail their courses. No one will sue them.
16:42:53 <pierrot> monochrom: Well, a bit late :P. I've decided to do `rm -rf ~/.cabal; rm -rf ~/.ghc; sudo rm -rf /usr/local/haskell/`. Since I've never installed the ghc package from Debian, now the actual state is as if I've never installed anything related to Haskell before. I'll reinstall it and let's see.
16:43:45 <monochrom> That is very clean indeed.
16:45:22 <sm> pierrot: did you look at the issue I linked ? it looked like this is a new error which may not be covered in the tome of monochrom
16:45:48 <sm> +1 for starting over
16:47:46 <pierrot> sm: Oh, no. I didn't read the whole thread in detail.
16:48:00 * sm neither
16:48:31 <sm> from my skimming, the error seemed specific to the new Cabal 2.0 / GHC 8.2
16:48:47 <monochrom> Oh w00t that's very new.
16:49:59 <pierrot> monochrom: Done. I've run ./install-haskell-platform.sh so I have the Haskell Platform again.
16:50:40 <pierrot> I still don't have any ~/.cabal or ~/.ghc folder since I haven't execute cabal or ghc respectively
16:53:30 <pierrot> This is the output of `ghc -v`: http://sprunge.us/RdCg
16:53:49 <monochrom> Already?!
16:54:02 <pierrot> Yes
16:54:26 <pierrot> There're lots of unusuable packages due to shadow dependencies...
16:54:56 <pierrot> One of them is QuickCheck-2.10.0.1
16:56:33 <pierrot> This is the output `ghc-pkg list`: of http://sprunge.us/cSec
16:57:49 <monochrom> Let me see if I can reproduce it.
16:59:44 <pierrot> Maybe I'll do that too (to install a virtuall machine with debian 9 and see if it also happens there)
17:00:19 <pierrot> virtual*
17:05:10 <Fylwind> monochrom: I'm using the same base library as the real global DB; i'm just intentionally excluding a bunch of nonboot libs
17:05:54 <Fylwind> I tried to do it with cabal (without sandboxes) and it looks like it chokes if the package db stack doesn't start with global: https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Simple/Program/HcPkg.hs#L478
17:05:58 <Fylwind> *sigh*
17:06:34 <Fylwind> this is seriously turning into a yak shaving
17:06:56 <monochrom> Or an XY problem.
17:08:06 <Fylwind> Arch tore out all the static libs except for boot libs => tried stack, it worked okay but it doesn't handle data dir properly => went back to cabal, but it keeps reading in the global package db which is contaminated with global packages that are missing static libs so builds won't succeed unless i explicitly reinstall every dependency
17:09:12 <monochrom> Perhaps don't use arch's GHC. Perhaps use arch's ghc-static. Perhaps don't use arch.
17:09:33 <Fylwind> monochrom: I'm writing an arch package
17:09:57 <Fylwind> i'm tempted to just create a new set of ghc wrappers and override $topdir; seems easier than trying to override global DB
17:12:45 <monochrom> Your heroism is to be commended.
17:15:15 <monochrom> pierrot: Reproduced. I conclude that this problem is straight from Haskell Platform's distribution tarball already.
17:16:31 <monochrom> I was extremely lucky. Normally I would just install Haskell Platform's tarball too.
17:16:41 <pierrot> monochrom: Thanks for your concern.
17:17:09 <monochrom> This year I decided to just take a look at their package list and do my own cabal install on that list. So I was spared of this mess.
17:17:47 <monochrom> So in other words I was that close to this problem! I was still using Haskell Platform when 8.0.2.
17:18:06 <pierrot> What can I do? I need to work with QuickCheck tomorrow for a school assignment. Maybe should I try the Debian package?
17:18:38 <monochrom> Does old vs new version matter to you? Because Debian's versions are old. (And Ubuntu. etc etc.)
17:18:49 <pierrot> I don't think so
17:18:58 <pierrot> what would you do in my place?
17:19:21 <verement> Debian stretch is up to 8.0.1
17:19:29 <monochrom> That kind of depends on the scope of "my place"... :)
17:19:41 <sm> pierrot: install stack, go
17:19:55 <sm> or install your os's haskell packages, go
17:20:06 <monochrom> I always either install GHC from GHC's website or install Haskell Platform. I completely ignore Ubuntu's GHC.
17:20:06 <sm> two easy/reliable options
17:21:10 <monochrom> But the prerequisite is a bit of self-confidence and a bit of sysadmin know-how.
17:21:30 <pierrot> I installed the Haskell Platform because our instructors recommended it. 
17:21:41 <monochrom> I reckon that a lot of programmers lack both.
17:23:43 <monochrom> Most programmers like stack and their linux distro so much because those two things promise a black-box-just-trust-me-automagic experience.
17:24:17 <iqubic> I like that set-up.
17:24:21 <monochrom> But I have a sysadmin inclination and precisely that promise rubs me the wrong way. Because every sysadmin knows there is no black box, there is only leaky abstractions.
17:24:45 <monochrom> The bigger and blacker the box (or rather, promised to be), the more leaky the abstraction is.
17:25:09 <monochrom> So I value transparency and minimality more. Antithesis to stack and linux distro packages.
17:25:51 <monochrom> To be sure cabal is also a promised black box and I surely exposed its leaks in my sicp.xhtml. But compared to stack, cabal is nothing.
17:29:07 <`Guest00000> are there any big resources on haskell naming conventions?
17:29:29 <monochrom> Yes. All of hackage. You did ask for big.
17:29:57 <monochrom> Unfortunately, Hackage's bigness does not even come close to Big Data.
17:30:08 <`Guest00000> heh
17:30:41 <RANGER2> https://www.999dice.com/?117705876
17:30:51 <monochrom> But you can still train an artificial neural network on Hackage and it will end up being superb in learned naming conventions.
17:31:06 --- mode: ChanServ set +o monochrom
17:31:12 --- mode: monochrom set +b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.197.233.134.50
17:31:12 --- kick: RANGER2 was kicked by monochrom (RANGER2)
17:31:46 --- mode: monochrom set -o monochrom
17:31:58 <pierrot> I'll try the Debian's haskell-platform package. It may be a bit old (and it's not what our instructors recommended us since they told us to download the Haskell Platform from https://www.haskell.org), but it may be reliable and stable too, and that's the reason I'm using Debian right now after all :)
17:33:37 <monochrom> It is certainly worth a try.
17:35:37 <monochrom> I am wondering why Haskell Platform's tarball comes with this brokenness.
17:43:55 <monochrom> Wait what? Haskell Platform's tarball forgot to build or include the *.so files?! Is that it?!
17:46:45 <monochrom> Haha I know how to test that hypothesis. I just have to switch back to a working installation of GHC plus libs and mess with some *.so
17:47:49 <geekosaur> "and .so it goes..."
17:48:24 <monochrom> hahaha
17:54:58 <monochrom> No, doesn't look like it. "ghc -v" isn't bothered by the missing *.so files.
17:56:11 <geekosaur> .so files for haskell libs is not the default
17:56:57 <monochrom> Well but ghci on linux needs them so their absence will be a problem eventually.
17:58:53 <monochrom> Oh, Haskell Platform's tarball has the *.so files, I just didn't look closely
18:28:49 <dfeuer> edwardk: it's possible to write a function expand :: (Monad m, Functor g) => (forall a b. f a -> b) -> g a -> h b) -> FreeT g m r -> FreeT f (FreeT h m) r. Note that this can be called with extend from Control.Comonad. Any thoughts about what this thing means?
19:24:53 <begriffs> I'm trying to find an article but having trouble. It was called something like "The seven kinds of haskell programmers." Anyone know what I'm talking about?
19:31:39 <`Guest00000> inlineAssembly :: String -> IO ()
19:31:44 <rotaerk> begriffs, are you thinking perhaps of http://www.cs.utexas.edu/~cannata/cs345/Class%20Notes/10%20Haskell%20Programmer%20Evolution.html
19:34:48 <begriffs> rotaerk: ha, that one is a classic, but not what I was trying to remember. The article I remembered tried to describe archetypes of haskell programmers, like the tool builder, the mathematician, the only-in-it-for-the-research, etc.
19:36:20 <rotaerk> hmm I should buy haskell programming from first principles, so that I can be confident when recommending it
19:43:32 <JuanDaugherty> or you could be dismissive of it, again on first principles
19:43:42 <JuanDaugherty> easy peasey
20:01:33 <vimalloc> I'm looking at either halogen (purescript) or reflex-dom (ghcjs) as a frontend for a REST api written in servant. I don't suppose anyone has used those before for and could offer any insight into which might be a better fit? Not finding much infomration comparing them on the google.
20:10:28 <sm> vimalloc: check there is recent discussion on haskell reddit
20:10:53 <dmj`> vimalloc: https://www.reddit.com/r/haskell/top/, top link
20:11:34 <vimalloc> sweet, thanks :)
20:14:43 <arahael> dmj`: Skipping the promoted link, did you mean the monoids one? :)
20:15:16 <arahael> Actually, which link?
20:15:21 <jle`> begriffs: i know what you are talking about
20:15:28 <dmj`> arahael: https://medium.com/@saurabhnanda/benchmarks-fp-languages-libraries-for-front-end-development-a11af0542f7e
20:15:30 <jle`> but, i cannot remember it
20:16:17 <begriffs> jle`: must be the curse of that article, those who know it shall never remember it.
20:17:56 <jle`> there's a creepypasta about this somewhere
20:18:03 <arahael> dmj`: Thanks for that. :)
20:18:37 <`Guest00000> is there a library like Data.Binary but lazy?
20:19:59 <`Guest00000> by lazy i mean `runGet (fix (\getWords8 -> (:) <$> getWord8 <*> getWords8)) (Lazy.repeat 123)` produces [123,123..]
20:25:02 <xacktm> Hi, I was reading the latest monoid article and the function `outside` doesn't make sense for me https://gist.githubusercontent.com/deque-blog/be35f5f8ecff7e1034cc6173058b97be/raw/eea0b57728440762c3662bb6f1c81bf5fae8cae3/outside.hs  It seems like it should be annotated outside :: Shape coord -> Shape Bool but that doesn't make sense either?
20:25:34 <xacktm> or maybe I don't understand what newtype does
20:26:56 <verement> xacktm: `outside` transforms a shape into its inverse
20:28:08 <xacktm> ok, but `not . isInShape s` returns a Bool, is this saying that coords are Bools?
20:28:36 <myrl> Is there a way to encode existential quantification as dependent sum?
20:29:27 <glguy> xacktm: No, that's not what that means.
20:29:35 <verement> xacktm: `not . isInShape s :: coord -> Bool`; the Shape constructor takes a function, not a Bool
20:29:47 <glguy> myrl: Kind of , see http://hackage.haskell.org/package/dependent-sum for an example
20:29:55 <myrl> glguy: Yeah, I'm checking that.
20:30:30 <myrl> glguy: I already have a dependent sum, but how do I "forget" the "index", if that's even possible?
20:30:39 <myrl> glguy: s/index/tag/
20:31:07 <myrl> glguy: I'm thinking of using `Some`?
20:31:15 <glguy> Yeah, you might be
20:31:46 <xacktm> aha, that makes sense now; I didn't understand that functions could be constructors
20:31:50 <xacktm> thanks guys
20:32:00 <myrl> data Black n = Black String 
20:32:02 <myrl> type AnyBlack = Some Black
20:32:07 <glguy> xacktm: That sentence doesn't really make sense
20:33:06 <xacktm> glguy: what do you mean?  I'm seeing now that Shape needs a function coord -> Bool to work, and the `not ... ` stuff fits the type
20:34:01 <glguy> xacktm: In newtype Shape a = MkShape (a -> Bool),   MkShape is the value constructor and Shape is the type constructor
20:34:13 <glguy> the (a -> Bool) part isn't the "constructor"
20:34:30 <jle`> myrl: what's your question actually?
20:34:45 <myrl> jle`: Owait, I think you're the one who introduced me to dependent sum types.
20:34:45 <glguy> in data Bool = False | True, False and True are the data constructors and Bool is the type constructor
20:34:48 <jle`> does 'Some' do what you want?
20:35:08 <jle`> if you want to be able to recover the 'n'
20:35:11 <myrl> jle`: I think it does, but the argument in `Some` is `tag`.
20:35:17 <myrl> jle`: Which confuses me a bit.
20:35:19 <jle`> you can use 'DSum' instead
20:35:28 <jle`> ah yeah that's a type variable, with an arbitrary name
20:35:30 <glguy> myrl: the name of the type variable doesn't matter
20:35:38 <jle`> like data Maybe a = Just a | Nothing
20:35:45 <jle`> i could have been data Maybe tag = Just tag | Nothing
20:35:46 <myrl> Yep.
20:35:48 <jle`> they're just variable names
20:36:10 <jle`> but yeah, remember that if you use Some with something isn't a GADT, you lose the ability to access the index you are forgetting
20:36:19 <jle`> you can gain it back by using something smarter like DSum Sing
20:36:26 <myrl> glguy: jle`: Just making sure, because `tag` is the argument name also used in the `DSum` argument.
20:36:40 <myrl> jle`: Yeah, I'm working with Nat.
20:37:11 <jle`> yeah, DSum Sing :: (Nat -> Type) -> Type is a nice way to hide the nat argument and then recover it back later by pattern matching
20:37:39 <myrl> jle`: Oh right.
20:38:03 <myrl> jle`: data AnyBlack = forall (n :: Nat). AnyBlack (Black n) (SNat n)
20:38:06 <myrl> That was my old code
20:38:18 <jle`> yeah, type AnyBlack = DSum Sing Black, esesntially
20:38:22 <myrl> Right, thanks.
20:38:29 <jle`> or DSum SNat Black
20:38:38 <jle`> (SNat is just a convenient type synonym for Sing)
20:39:57 <xacktm> glguy: ok, so the function a -> Bool isn't the constructor per se, but it needs the whole `MkShape (a -> Bool)` to be a value constructor which fulfills the Shape type
20:40:07 <xacktm> ?*
20:40:07 <lambdabot> Maybe you meant: v @ ? .
20:40:22 <xacktm> not this time lambdabot :)
20:40:50 <glguy> xacktm: MkShape is the value constructor, it has the type  (a -> Bool) -> Shape a
20:41:07 <glguy> If you apply MkShape to a value with type (a -> Bool) the resulting value will have type Shape a
20:41:52 <myrl> This reminds me.
20:42:22 <myrl> I'm thinking of some kind of typeclass which "requires a stream of as"
20:42:37 <myrl> I think I'm thinking of consumers(iteratee)?
20:45:01 <lyxia> MonadParsec?
20:46:15 <myrl> lyxia: Seems too much for me.
20:46:56 <xacktm> glguy: sorry got disconnected.  I understand now - thanks
20:47:13 <myrl> lyxia: I pretty much only need a `consume` function, which takes the current "pointer", and advances the pointer.
20:47:49 <myrl> lyxia: There can be an actual pointer, such as in the case of [a], but there's also the case of `IO a`.
20:58:45 <xacktm> there was another thing that surprised me, but I forgot it now - aren't (->) and/or (::) functions too and have a type?
20:59:05 <xacktm> I can't seem to do :type (->) in GHCI
20:59:19 <myrl> xacktm: :kind?
20:59:56 <xacktm> perhaps, I only barely remember it
21:00:13 <myrl> Prelude> :kind (->)
21:00:15 <myrl> (->) :: * -> * -> *
21:00:26 <myrl> (::) is not a type constructor though.
21:01:52 <xacktm> mmk, gotta dig down deeper :)
21:02:45 <geekosaur> :: is syntax
21:03:02 <pacak> * -> * -> * is not totally true. It also works for unboxed things and they have slightly different kind.
21:03:10 <jle`> xacktm: remember that :t works on values
21:03:13 <pacak> So actually (->) is a bit uglier.
21:03:25 <jle`> xacktm: :k works on types
21:04:16 <xacktm> noted, thanks
21:04:51 <pacak> Prelude> :k (->)
21:04:51 <pacak> (->) :: TYPE q -> TYPE r -> *
21:05:21 <jle`> (->)'s kind signature is a bit weird too because it uses a different (->)
21:06:02 <jle`> but that's not too unusual in haskell
21:06:28 <myrl> What's the "type" of a kind constructor? :D
21:07:04 <jle`> if you turn on -XTypeInType, the kind of Type is Type
21:07:13 <jle`> so that simplifies things a bit easier
21:07:51 <jle`> without that i think the next level is, internally, Sort ... and */Type :: BOX or something
21:08:14 <myrl> I forgot how to use KnownNat. :C
21:10:23 <myrl> (sing :: n) == SNat 0
21:10:26 <myrl> Is this correct?
21:18:34 <jle`> sing :: Sing 0
21:18:42 <jle`> or SNat :: Sing 0
21:18:48 <jle`> or SNat @0
21:19:31 <myrl> jle`: What's the @ syntax?
21:19:40 <jle`> TypeApplications
21:19:54 <jle`> it lets you specify a type variable
21:20:09 <jle`> so fmap :: Functor f => (a -> b) -> f a -> f b
21:20:16 <jle`> and fmap @Maybe :: (a -> b) -> Maybe a -> Maybe b
21:20:29 <jle`> fmap @Maybe @Int :: (Int -> b) -> Maybe Int -> Maybe b, etc.
21:21:12 <myrl> Ohhh
21:22:47 <myrl> jle`: How does it know to which variable it is applied to?
21:23:22 <jle`> it's roughly the order that the variables appear in the type signature, but more specifically, it's the order of the variables when you show the type with explicit forall's
21:23:27 <myrl> Ah.
21:23:37 <jle`> or if the type signature contains explicit foralls
21:24:09 <myrl> http://ix.io/zVi
21:24:12 <jle`> like if i had `weirdFmap :: forall b f a. Functor f => (a -> b) -> f a -> f b; weirdFmap = fmap`, then it's basically weirdFmap @b @f @a
21:24:14 <myrl> This is my current code.
21:24:28 <myrl> How do I pattern match on the type?
21:25:03 <jle`> in this case you can do something like `SNat @n` to get the singleton
21:25:16 <jle`> (if you have ScopedTypeVariables on, and add the forall n. KnownNat n => ... to your type signature
21:25:35 <jle`> and then you can either directly manipualte the singleton, or turn it into an Integer using fromSing :: SNat n -> Integer
21:25:48 <myrl> OH
21:26:11 <jle`> natVal card should also work actually
21:26:23 <jle`> so you wouldn't need singletons in this specific situation
21:31:05 <myrl1> Whoops.
21:31:14 <myrl1> I was cut off at "I think I get what you mean."
21:33:09 <myrl1> jle`: I think I get what you mean, I messed up my scoping in ScopedTypeVariables.
21:33:23 <myrl1> jle`: I was passing `card` whhen I shouldn't have and was recursing.
21:34:17 <jle`> also, what Vec are you using?
21:34:27 <jle`> is :> a pattern synonym?
21:34:48 <myrl1> jle`: Using https://hackage.haskell.org/package/clash-prelude-0.11.2/docs/CLaSH-Sized-Vector.html because it seems to be the sanest one to use when working with Nat.
21:35:35 <jle`> why not vector-sized?
21:37:05 <myrl1> jle`: I don't think I was able to find this before. Thanks. I'll use this, clash requires me to compile hundreds of modules that I don't use. :P
21:37:40 <jle`> no problem heh, just seems like kind of a heavy library to import if you just want sized vectors
21:37:50 <jle`> but also it is likely that you're going to run into problems here
21:38:10 <jle`> because you are doing some sort of recursion on successive Nat's, presumably using subtraction
21:38:17 <myrl1> jle`: Yep, I am.
21:38:28 <jle`> but the structure of Nat's is not something that GHC can take advantage of
21:38:53 <myrl1> jle`: Yep. I'll pray to my ghc plugins.
21:38:58 <jle`> so it can't prove that going down and then building back up is necessarily going to give you the same resulting type
21:39:06 <jle`> you can pray to ghc plugins, but you can also use a better type as well
21:39:16 <jle`> you might get lucky with plugins in this case
21:39:36 <myrl1> jle`: Use peano types?
21:39:54 <jle`> maybe, or else also some nice higher-order functions
21:40:17 <jle`> vector-sized has some useful higher-order functions that abstract over cases like these
21:41:17 <myrl1> jle`: Checking, thanks.
21:41:37 <jle`> i could help but i don't know how you want to recurse down on 'card'
21:42:07 <myrl1> jle`: Basically, `card`'s Nat is "number of arguments required"
21:45:53 <myrl1> jle`: Turns out that replicateM' is exactly the type.
21:46:01 <jle`> hooray :D
21:46:41 <jle`> it has the right type but make sure it's the right thing you want; it ignores 'p n'
21:46:59 <myrl1> Mhm.
21:47:01 <myrl1> forall n a. KnownNat n => Black n -> IO a -> IO (Vector n a)
21:47:19 <jle`> yeah, you can't take advantage ofany actual properties of the Black
21:47:27 <jle`> if there is anything in a 'Black n'
21:47:34 <jle`> it ignores completely the first argument
21:47:44 <myrl1> jle`: I have an outdated version of vector-sized though, so I'm using `replicateM` for now. :C
21:47:54 <myrl1> f _ = replicateM
21:48:05 <jle`> :C
21:48:07 <myrl1> (older versions use Proxy rather than p)
21:49:12 <jle`> oh i think that was my pr
21:49:15 <myrl1> jle`: Thanks. I'll probably do away with the function I made as a whole, since there's already replicate*
21:49:26 <jle`> mhm.  higher order functions are the best :)
21:51:34 <myrl1> jle`: Thanks again. I'm currently trying to do "best practices" in the sense of "use pre-made libraries," and "use dependent types"(though, some people would disagree that dependent types are best practice. :P)
21:52:19 <testlab> the getter functions of records are global right?
21:52:55 <testlab> so can you have getters with the same name for different records?
21:53:17 <dmj`> testlab: to that module only, unless re-exported elsewhere
21:53:47 <testlab> https://github.com/cmsaperstein/VEBTree/blob/master/src/Data/VEBTree.hs#L19-L31
21:54:28 <dmj`> testlab: snake types aren’t recommended, since calling 
21:54:38 <testlab> vmin and vmax are defined twice
21:54:47 <dmj`> ‘summary’ on VEBase will be problematic
21:55:05 <myrl1> What lens supports only set/modify?
21:55:09 <myrl1> Traversal?
21:55:21 <myrl1> Or setter?
21:58:19 <nisstyre> what is the state of the art in working with arrays and doing parallelism with them? I haven't done this in a while and it seems like a lot of stuff has become deprecated (e.g. data parallel haskell)
22:12:24 <cocreature> nisstyre: "accelerate" is one of the more actively developed libraries for that
22:12:35 <cocreature> afaik most of the people working on it have been working on dph before
22:16:23 <haskwelp> Pretty new to haskell. I'm using function (x:xs) a lot. If I don't have a way to handle empty strings/lists when it has recursed down to the bottom it will give me an error "non-exhaustive patterns" etc. Is there a nice way to handle empty lists, i.e. just return without any return value? 
22:17:18 <srhb> haskwelp: The pattern [] matches the empty list
22:17:35 <srhb> haskwelp: foo (x:xs) = ...; foo [] = ...
22:17:46 <cocreature> what is “return without any return value” supposed to mean?
22:17:49 <phadej> haskwelp: use Maybe in the return type, or NonEmpty http://hackage.haskell.org/package/base-4.10.0.0/docs/Data-List-NonEmpty.html as an input
22:18:06 <phadej> foo (x:xs) = Just ...; foo [] = Nothing;
22:18:51 <haskwelp> Thanks srhb but for example my value takes a string, returns a bool.  If I put function [] = True it will return true for all empty lists also, but if I put false it will return false for all lists/strings. 
22:19:41 <haskwelp> My current way has been to create an extra function just for empty lists, but surely there must be a nicer way?
22:20:21 <monochrom> I don't understand. You are writing recursion right? So the empty list is the base case right? So what do you mean you need an extra function?
22:21:31 <haskwelp> monochrom: correct recursion and the empty list is the base case. But the base case is true for all lists except for when the input value is an empty list
22:22:05 <haskwelp> Except for when the /first/ input in the recursion chain is empty
22:22:07 <geekosaur> if you need to handle empty lists specially then you probably want a wrapper function
22:22:36 <monochrom> I don't understand that sentence.
22:22:41 <geekosaur> foo [] = False; foo xs = foo' xs where foo' [] = True; foo' (x:xs) = ...
22:24:24 <monochrom> I also don't understand "the base case is true for all lists".
22:24:25 <myrl1> How to unwrap someNat?
22:24:30 <myrl1> SomeNat*
22:24:38 <myrl1> I know I'm sounding kinda stupid rn
22:24:50 <cocreature> myrl1: what do you mean by unwrap?
22:24:58 <monochrom> base case is not a sentence so it is neither true nor false. Do you also speak like "red is true"?
22:25:16 <myrl1> :: SomeNat -> (forall (n :: Nat). SNat n -> a) -> a
22:25:22 <myrl1> That should work, right?
22:25:39 <myrl1> cocreature: A bit like reification.
22:25:45 <haskwelp> geekosaur: is "foo xs = foo' xs where foo' [] = True" is this whole line actual code or should it be foo xs = foo' xs -- where foo' [] = True?
22:25:57 <myrl1> cocreature: or making it work like `Some` in dependent-sum
22:26:21 <geekosaur> haskwelp, it's all one line, although normally I would split it up
22:26:38 <phadej> myrl1: the GHC.TypeNats somenat?
22:26:43 <myrl1> phadej: Yep.
22:26:53 <myrl1> Or TypeLits
22:26:59 <myrl1> Not sure which version I'm using rn.
22:27:05 <haskwelp> That is cool, thanks a lot geekosaur . And thanks a lot monochrome (although I apologise for my bad explanation of what I was looking for)
22:27:12 <myrl1> ghc version 8.0.2 
22:27:16 <myrl1> Which base is that?
22:27:21 <phadej> myrl1: yes, you can write withSomeNat :: SomeNat -> (KnownNat n => Proxy n -> r) -> r function
22:27:38 <geekosaur> http://lpaste.net/358438 is how I'd normally write that
22:27:42 <phadej> withSomeNat (SomeNat p) f = f p
22:27:42 <geekosaur> but IRC is bad at multiole lines
22:28:03 <jle`> myrl1: what is SomeNat ?
22:28:04 <myrl1> phadej: Wait, there's no need for a forall?
22:28:12 <jle`> oh nvm
22:28:15 <phadej> myrl1: there is, sorry, didn't check.
22:28:24 <myrl1> phadej: Ah, it's fine. Thanks.
22:28:24 <jle`> myrl1: can't you just pattern match?
22:28:25 <phadej> (type-check)
22:28:35 <phadej> myrl1: +1
22:28:54 <myrl1> jle`: I'll try that too.
22:29:08 <phadej> jle`: btw, I tend to export such (rank2) function
22:29:17 <phadej> as to match on GADT user have to enable GADTs
22:29:31 <phadej> but to use withSomeNat one doesn't need to enable anything
22:30:08 <phadej> (and GADTs turns MonoLocalBinds)
22:30:21 <myrl1> jle`:       (SomeNat p) <- someNatVal <$> o .: "pick"
22:30:23 <myrl1> This is valid?
22:30:32 <jle`> yes, and you don't even need the parentheses :D
22:30:36 <myrl1> True. :P
22:30:45 <geekosaur> hm, I think I also needed braces on the one-liner version. but I'd usually write the multiple-line one and indentation does it there
22:31:33 <phadej> IIRC gadt matching in do blocks is only recentlty fixed  (but it's great it is!)
22:31:45 <iqubic> What are GADTs? Are they just a way to provide more constructors for a data type.
22:31:47 <iqubic> ??
22:31:48 <phadej> (you got funny error, where GHC (read SPJ's) brain exploded)
22:32:12 <monochrom> Are you asking that because you had constructors in your childhood?
22:32:37 <iqubic> monochrom: Is that directed at me?
22:32:38 <jle`> GADT matching on do blocks has always worked for me
22:32:41 <monochrom> Yes.
22:32:53 <jle`> i do it very often actually, it's one of the techniques i recommend often as well
22:33:01 <monochrom> Tell me more about direction.
22:33:01 <iqubic> Well, yeah. I'm coming from Java.
22:33:38 <pacak> Java. Oh noes.
22:33:45 <haskwelp> geekosaur: the ";" in your example are they just supposed to show line breaks on irc?
22:33:48 <phadej> iqubic: https://www.reddit.com/r/ocaml/comments/1jmjwf/explain_me_gadts_like_im_5_or_like_im_an/ or https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/gadtpm-acm.pdf
22:34:06 <phadej> haskwelp: you can actually use them in code
22:34:15 <geekosaur> haskwelp, they're actually entirely legal (except that I forgot the braces around the multiple equations in the where clause)
22:34:20 <phadej> > let foo [] = 1; foo _ = 2 in foo []
22:34:27 <lambdabot>  1
22:34:38 <geekosaur> indentation is actually translated to brackets and semicolons inside the compiler
22:34:45 <iqubic> are OCaml GADTs similar to the haskell type?
22:34:54 <iqubic> s/type/version/
22:35:11 <phadej> I don't know OCaml at all :(
22:35:36 <haskwelp> Oh that's really neat. What do you mean by multiple equations though?
22:35:54 <geekosaur> where I am defining the same name twice with different patterns
22:36:02 <geekosaur> I did it twice in that example, once for foo and once for foo'
22:36:37 <geekosaur> ghc will actually call it that, btw, if it reports an error involving it
22:38:42 <haskwelp> geekosaur: not sure of what you mean still to be honest
22:39:17 <geekosaur> foo [] = False; foo _ = True -- this is two equations defining "foo", each with a different pattern
22:39:23 <geekosaur> so they will be combined
22:39:24 <monochrom> If you see "=" appearing five times, you have five equations.
22:40:24 <geekosaur> it's cleaner and easier than having to write a case expression to differentiate them yourself
22:41:21 <iqubic> Yeah. Pattern Matching is the greatest part of Haskell IMO
22:41:22 <geekosaur> (the _ there is a wildcard pattern that matches anything without binding it to a name)
22:41:42 <myrl1> How to know my `base` version?
22:41:54 <haskwelp> Oh, but they're separate still, right?
22:42:01 <iqubic> base version of what myrl1??
22:42:22 <geekosaur> myrl1, ghc-pkg list base
22:42:43 <myrl1> Thanks.
22:43:14 <myrl1> natSing doesn't seem to be exported? :c
22:43:20 <geekosaur> haskwelp, they make one system of equations. internally it gets rewritten to a single equation with a case expression, but you can treat them as separate to some extent (i.e. I don't think ghc likes it if you stick other definitions between them)
22:43:26 <myrl1> Is this a bug?
22:47:24 <haskwelp> I see, thank you for explaining it :)
22:57:23 <norc_> Good morning. Am I right in understanding that a resolver is essentially a curated list of package versions?
22:58:10 <iqubic> I think that sounds right.
22:58:14 <monochrom> Yes, and a GHC version.
23:01:11 <norc_> Aha! That explains why I don't need to specify versions in dependencies specified in my project.cabal, but I do for dependencies specified in stack.yaml :)
23:09:39 <dsal> Hey, I'm doing the exercism stuff and I got to the triangle thing where you have to compare lengths that are all of class Num.  I feel like I'm missing something -- Num doesn't allow any sort of comparison, does it?
23:10:38 <iqubic> No.
23:10:55 <iqubic> You need Ord and Eq for comparisons.
23:10:58 <Axman6> Num used to  require Eq 
23:11:01 <dsal> Yeah.  I don't see how this is supposed to work.
23:11:17 <dsal> Oh.  OK.  I didn't think it was *that* tricky.
23:11:20 <Axman6> Can't remember if it also needed Ord (pretty sure it didn't, because things like Complex were Num)
23:11:38 <iqubic> Ord provides (>) and (<). Eq provides (=) and (/=)
23:11:57 <dsal> I bet that's the issue.  I just added the Eq constraint.
23:12:12 <dsal> I thought there could be something clever, but I couldn't see how to get anything out of Num.
23:12:19 <iqubic> Yeah, you need Ord for < and >
23:12:36 <iqubic> can't compare unordered things.
23:13:38 <ongy> equality is still a comparison. just can't get inequalities
23:15:33 <iqubic> ongy: (/=) is inequality.
23:16:01 <iqubic> You can't get relative positions without Ord.
23:30:09 <dsal> Yeah, most people did it with Ord.  I did it just Eq
23:30:34 <iqubic> How?
23:32:11 <dsal> https://www.irccloud.com/pastebin/5jWYDDuh/triangle
23:33:26 <dsal> Ord makes a certain type of elegance easier, but this is reasonably readable.  Some of the others wrote books about triangles.
23:35:38 <iqubic> Oh, I see how that works.
23:35:59 <iqubic> That an interesting way of doing that.
23:37:18 <dsal> It's certainly a bit more computationally expensive, but it reads really easily.  "if any a or b in the sides are equal, it's Equilateral"  etc...
23:38:05 <dsal> The signum thing is a little weird, but it's from how I was thinking about doing it when I just had Num.  It *almost* worked, but the value that comes from signum is of the same Num type, so you can't compare it.  Rather pointless.
23:38:52 <dsal> er, if all...  any is isosceles.
23:38:55 * dsal needs to go to bed
23:40:23 <iqubic> :t permutations
23:40:26 <lambdabot> [a] -> [[a]]
23:41:11 <dsal> :i permutations
23:41:18 <dsal> Oh yeah, it doesn't do i
23:41:59 <dsal> I could reduce the list a bit, but for [1,2,3], it's [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]   -- I only need to ensure each side is in c, and in either of a or b.  I do a bit more work than necessary.
23:50:03 <dsal> reduce [] = []
23:50:03 <dsal> reduce (x@[a,b,c]:xs) = x : filter (/= [b,a,c]) (reduce xs)
23:50:17 <dsal> I reduced the permutations with that and it still passes my tests.
