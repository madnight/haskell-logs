00:13:05 <syamaoka> the second type variable of `>>=` is ambiguous because the return value is an empty list.
00:13:54 <syamaoka> the signature of `>>=` is `(>>=) :: Monad m => m a -> (a -> m b) -> m b` not `m a -> (a -> m a) -> m a`
00:15:17 <syamaoka> for example, `print $ [1] >>= \x -> [3]` or `print $ [1] >>= \x -> [] :: [Int]` works fine. 
00:15:18 <norc_>  syamaoka: Ahh. 
00:16:00 <mac10688> https://www.stackage.org/haddock/lts-9.3/time-1.6.0.1/Data-Time-Clock.html#t:NominalDiffTime
00:16:12 <mac10688> anyone know how I can turn NominalDiffTime into a Word32?
00:16:21 <mac10688> I tried fromIntegral but that didn't work
00:16:31 <phadej> truncate
00:16:42 <phadej> but Word32 is bad idea
00:17:02 <mac10688> it has to be Word32 to be compatible with MySQL data type
00:17:06 <phadej> unless you very sure it will fit
00:17:11 <phadej> you are*
00:17:21 <phadej> and not e.g. underflow
00:17:40 <Axman6> you sure MySQL doesn't have support for a decent time type?
00:17:41 <mac10688> https://hackage.haskell.org/package/mysql-haskell-0.8.1.0/docs/Database-MySQL-Protocol-MySQLValue.html#t:MySQLValue
00:17:49 <phadej> doesn't mysql have proper type for time interal?
00:17:51 <mac10688> I have to make it fit the MySQLValue type.
00:17:55 <phadej> Axman6: exactly! :)
00:18:03 <mac10688> I'm working with an existing database
00:18:08 <norc_> syamaoka: Now Im beginning to see the point of NoExtendedDefaultRules
00:18:10 <mac10688> stores number of seconds since epoch
00:18:15 <Axman6> if the answer is no, yet another reason not to use MySQL for anything new
00:18:20 <norc_> Or rather ExtendedDefaultRules
00:19:12 <mac10688> so what should I do? truncate?
00:19:18 <phadej> mac10688: https://hackage.haskell.org/package/time-1.8.0.3/docs/Data-Time-Clock-POSIX.html
00:19:34 <phadej> ah you use that... then yes, truncate
00:19:52 <ertes-w> l
00:20:15 <mac10688> not sure how to truncate
00:20:25 <mac10688> I used fromIntegral but that didn't work
00:20:32 <phadej> > truncate (0.1 :: Double) :: Int
00:20:34 <lambdabot>  0
00:20:44 <phadej> > truncate (123.1 :: Double) :: Int
00:20:46 <lambdabot>  123
00:20:50 <mac10688> ah
00:20:58 <mac10688> let me see
00:21:56 <mac10688> thanks! That's working for me. I can understand why I wouldn't want to use truncate but I don't have a choice when working with an existing database
00:22:35 <mivael> :t let e = [Right (3::Word64), Left (5::Int)] in either absurd id (head e)
00:22:37 <lambdabot> error:
00:22:37 <lambdabot>     • Couldn't match type ‘Int’ with ‘Void’
00:22:37 <lambdabot>       Expected type: Either Void Word64
00:22:43 <mivael> :t let e = [Right (3::Word64)] in either absurd id (head e)
00:22:45 <lambdabot> Word64
00:23:59 <mivael> :t let e = [Right (3::Word64), Left (5::Int)] in either (error "Impossible") id (head e)
00:24:00 <lambdabot> Word64
00:24:55 <mivael> pacak, understood what you meant about typeckecks and error/absurd  :)
00:32:19 <norc_> Hafydd: interesting its showing more and more. Just staring at the definition of MonadPlus for a short while made me realize that the monad is being turned into something ring-like.
00:41:56 <Hafydd> norc_: if you view >> as being multiplication, I suppose you can say that m a, for some fixed a, becomes a semiring.
00:42:08 <Hafydd> However...
00:44:55 <Hafydd> I'm not sure if distributivity holds in all cases.
00:45:16 <opqdonut> I think distributivity of >> is basically one of the monad laws
00:45:29 <norc_> opqdonut: Its not
00:45:53 <opqdonut> right, mixed up distributivity/associativity
00:52:51 <Hafydd> Oh, it's not a semiring, because addition in a semiring must be commutative.
01:15:56 * hackagebot monad-recorder 0.1.0 – Record and replay the results of monadic actions – https://hackage.haskell.org/package/monad-recorder
01:49:39 <jakub> i wish to have a polymorphic function that does one thing for all types satisfying a constraint and some default thing otherwise, I guess I will hear that that is a bad design, instance C a => X a where f a = something; instance X a where f a = default wouldnt work right
01:50:28 <ventonegro> It's bad design
01:51:20 <jakub> ventonegro: any advice how to do things differently?
01:51:35 <jle`> what is the biggest problem you are trying to solve?
01:51:43 <jle`> *bigger
01:51:48 <ventonegro> Well, what's the actual problem?
01:51:56 <jle`> really?
01:52:00 <jle`> is that like...a class assignment or something?
01:52:31 <jle`> "Write a polymorphic function that does .... (10 pts)"
01:52:44 <jle`> surely you want to do this within the context of a real world problem
01:53:09 <jle`> unless this is just an exercise or wondering out loud, heh
01:53:20 <ventonegro> jle`: Are you answering me?
01:53:38 <jakub> jle`: its not class assignment ;) i am well passed that form of education :)
01:53:44 <jle`> ventonegro: ah, sorry, i thought your last message was from jakub  :)
01:53:53 <ventonegro> jle`: np :)
01:53:57 <jle`> jakub: so, what's the actual problem you're trying to solve?
01:54:09 <jakub> i am trying to formulate it conscisely
01:58:50 <jakub> i have a datatypes-ala-carte like expression language (constants, equality, comparison, logical connectives, quantification) all of which is indexed by 'sort'. An example of an expression would have type: fixpoint of a sum of functors (VarF, ArithmeticF, QuantifierF Int, QuantifierF Bool). But I can have infinitely many sorts (Array Int Int, Array Int (Array Int Int) ...) so there may also be different 
01:58:56 <jakub> quantifiers in the sum. I wish to take an expression and replace some terms with a fresh variable that gets quantified (only if that is supported within the language) so for example f(x + 1) = 3 becomes exists (y : int). f(y) = 3 and y = x + 1
01:59:45 <jakub> the point is to have this function that cleverly uses available quantifiers polymorphic so that it works when you extend the "language" with another construct
02:00:14 <jakub> i.e. there is no preferred sum of functors, any combination is as useful as any other, so hardcoding it wouldnt be nice
02:03:48 <jcjf> I'm trying to write a PGN parser, but I'm a little stuck at a conceptual level. Should my parser validate that moves "make sense" in the game of chess, or just parse anything that looks like a chess move?
02:04:26 <jcjf> If it parses anything that looks like a chess move, at what stage would I then check that a move makes sense in the context of a chess board?
02:04:31 <opqdonut> first parse anything, then have a separate analysis pass
02:04:49 <jcjf> Ah, thanks
02:05:20 <opqdonut> have something like applyMove :: Board -> Move -> Maybe Board
02:05:20 <ventonegro> jakub: quantifiers and fixpoints are a little bit over my head, sorry
02:05:26 <opqdonut> or perhaps Either String Board if you want errors
02:05:30 <jakub> jle`, ventonegro: basically i am trying to rewrite the ugly "flatten" in https://github.com/jakubdaniel/expressions/blob/master/src/Expression.hs
02:09:34 <drdo> jakub: I'm surprised there isn't an easy way to define some default instance when nothing else matches
02:10:47 <jakub> drdo: well i always run into overlapping (duplicate) instances (that differ only in constraints, which do not get involved in instance selection)
02:11:34 <drdo> jakub: right, but there could be an extension where you explicitly mark it as a default and don't have this issue
02:11:47 <drdo> It just gets ignored if there's a normal instance
02:14:39 <c_wraith> drdo: how will that interact with separate compilation?
02:15:19 <drdo> c_wraith: Ah, that nonsense again!
02:22:29 <dminuoso> With an IO monad, when is the IO action actually executed?
02:23:18 <joebetz> after main
02:23:35 <c_wraith> IO values are executed where they appear in main (or in something main uses transitively)
02:24:17 <c_wraith> unless you're dealing with lazy IO bugs, in which case..  *sigh*.  Maybe lazy IO was a mistake
02:24:46 <dminuoso> c_wraith: then why does evaluating a term `a` for `a = putStrLn "foo"` in GHCi print to stdout?
02:25:07 <c_wraith> dminuoso: because ghci is not a program
02:25:20 <c_wraith> err.  lines entered in ghci are not programs.
02:25:35 <c_wraith> ghci runs things interactively.  that's its purpose.
02:25:46 <c_wraith> It's unrelated to how haskell programs run
02:26:56 <c_wraith> we used to be able to pretend that lines in ghci were lines in main, but ever since the ability to use import and data declarations in ghci were added, it has become something else.
02:29:32 <dminuoso> c_wraith: So main is the thing that knows how to execute IO?
02:30:08 <c_wraith> the thing that knows how to execute IO is the thing that calls main and is added by the compiler. Main is just the entry point.
02:32:01 <dminuoso> c_wraith: Okay that is getting interesting. That means if a function does not return IO, it can not do any I/O.
02:32:04 <joebetz> they're still executed *after* main gets called, correct?
02:32:17 <joebetz> ^ yeah
02:32:17 <c_wraith> joebetz: They *are* main.
02:32:21 <ertes-w> dminuoso: 'main' is your program, and you can imagine a kind of IO "interpreter" that runs it
02:33:32 <joebetz> okay. my impression was that main outputs the colleted tree of IO actions that are then executed by the runtime.
02:34:09 <c_wraith> joebetz: it's much simpler to just model it as main *is* the graph (not necessarily tree) of IO actions.
02:36:22 <joebetz> I see
02:36:28 <dminuoso> araujo: Mmm, so essentially the entirety of main is pure (leaving specialties like unsafePerformIO aside), evaluating it does nothing? No database transactions, no `rm -rf /` ?
02:37:25 <dminuoso> Kept thinking of IO just as stdin/stdout, sounds like it's far more general than that :)
02:39:17 <c_wraith> dminuoso: sounds like you've got the basics at least
02:40:34 <dminuoso> c_wraith: After 10 years of imperative programming it's tough to get used to this.
02:41:15 <ertes-w> dminuoso: (IO Int) is not an Int that is "tainted"…  it's an action that returns an Int…  think of a kind of "scripting language"
02:41:50 <drdo> dminuoso: I'm not sure that there's any psychological difficulty in this
02:42:21 <drdo> You can think of main as the construction of an IO action
02:42:43 <drdo> And then running it does all the IO stuff
02:43:03 <ertes-w> dminuoso: there is just no way from within haskell to actually look at such IO programs…  you can only compose them, and then the haskell interpreter or compiler actually reads and interprets them…  this is a high-level explanation of course, as there is not a real scripting language involved, but it's a nice mental model
02:43:40 <ertes-w> in particular: if you compile to a native executable, then 'main' is the actual program that is executed
02:44:18 <ertes-w> that's why you shouldn't view 'main' as the "entry point", but more as the actual full program that just refers to other definitions, which you could just as well have dumped into 'main' directly
02:45:24 <ertes-w> and that is also why IO is actually pure, and why there is the difference between *evaluation* (which computes programs), and *execution* (which interprets programs)
02:51:38 <drets> I want to implement chatbot which will ask questions and based on answers show different questions, what the proper approach/data structure for that? Any thoughts would be appreciated :) (just asking in haskell since here are a lot of smart people)
02:52:57 <pacak> drets: Let's try playing this game. Suppose I want a datastructure, you can start asking questions...
02:54:59 <drets> pacak, Should I try to describe the properties of datastructure? 
02:56:27 <Ferdin> constexpr const int* addr(const int& ir) { return &ir; }constexpr const int* tp = addr(5); why 5 is not constant express
02:56:49 <pacak> drets: Probably. Expected pattern of use, desired cost constants, etc.
03:00:41 <drets> pacak I'm just trying to understand how can I code it in a proper way... I'll try to explain in a bit more details to you what I need, maybe it will help me somehow, if you don't mind :)
03:05:06 <drets> pacak I have a set of questions, each question has different answers (imagine Yes/No answer or more options from dropdown), based on answer I should show some next question (there some relation between answer (or few previous answers) and next question), also I need to track last answer since it's possible to edit it. Now I need to build data model from it. 
03:05:14 <pacak> What you want is  something like a binary tree
03:05:25 <pacak> with yes/no answers
03:05:51 <pacak> drets: Try googling "akinator" and do a few plays.
03:08:01 <ertes-w> drets: data Question = Question { question :: Text, answer :: Text -> [Question] }
03:08:56 <ertes-w> perhaps with an additional Maybe in 'answer' to account for invalid answers
03:09:48 <drets> pacak: yeah, like akinator, but answers has different types.
03:11:46 <ertes-w> if you have some session state manipulated by answering (e.g. information gain), perhaps even:  answer :: State Session (Maybe [Question])
03:16:29 * hackagebot mellon-core 0.8.0.2, mellon-gpio 0.8.0.2, mellon-web 0.8.0.2
03:16:29 * hackagebot  → https://hackage.haskell.org/packages/recent
03:17:56 <drets> ertes-w questions is always text yeah, but answer may be anything: text, just choose from dropdown some options, checkboxes options, request action from user (like take a picture, make a signature).
03:19:27 <drets> so, the question will be `data Question = Question { question :: Text, answer :: State Session (Maybe [Question]) }` (thinking_face)
03:20:21 <drets> Why [Question] and not Question in State Session (Maybe [Question]) ?
03:21:08 <drets> based on current answer and previous answers I should show next question...
03:22:56 <Ferdirand> do you assume the user never makes mistakes ?
03:23:09 <drets> Yep
03:23:26 <drets> We give to user an options every time
03:23:33 <drets> if it's an input
03:23:54 <drets> ok for example for typing address you need to provide a house number
03:24:01 <drets> and if you didn't
03:24:28 <drets> we need to re-ask the question, or show next question for clarifying the address
03:24:48 <drets> so, now sure if we assume that user never makes mistake
03:25:22 <Ferdirand> i don't know how akinator works exactly, but i would expect it uses previous games and bayesian probabilities to estimate the distribution of possible answers
03:25:41 <Ferdirand> and choose questions in a way that minimizes entropy 
03:25:57 <Ferdirand> and give an answer once the entropy crosses some threshold ?
03:26:30 <drets> heh, I think it's not what I want, I now the relation between previous answers and next question.
03:27:21 <drets> I mean I don't need to do bayesian probabilities :)
03:39:24 <dminuoso> ertes-w: Mmm yeah. I've heard this explanation of "monads often just represent a strategy to produce X", I suppose they were talking about IO. :)
03:39:42 <dminuoso> Or *monadic actions rather
03:50:22 <tdammers> point in case, list monads can be regarded as "strategies to produce lists", maybe is a "strategy to produce an optional result", etc
03:50:49 <tdammers> although the analogy kind of breaks down with things like Cont, State, Reader, etc.
04:12:21 <AndChat181649> ay.
04:13:30 <drdo> tdammers: Clearly the right analogy is a burrito!
04:14:06 <maerwald> drdo: I had a very delicious burrito last weekend and... guess what I had to think of?!
04:14:18 <maerwald> we have been hacked, cannot eat burritos without thinking of monads now :/
04:14:20 <AndChat181649> shiiit fam
04:15:27 <ertes-w> dminuoso: i would refrain from generic "monads are" interpretations
04:15:31 <ertes-w> dminuoso: IO is like that
04:15:58 <maerwald> analogies are not there to be an abstract mathematical model
04:16:08 <maerwald> they are to build intuition, not to be perfect
04:17:09 * hackagebot json-stream 0.4.1.5 – Incremental applicative JSON parser – https://hackage.haskell.org/package/json-stream
04:17:24 <tdammers> analogies are like burritos
04:17:29 <maerwald> lol
04:17:33 <phadej> maerwald: but there aren't good analogies for Monad. that's the problem
04:17:37 <maerwald> sure there are
04:18:07 <ertes-w> dminuoso: Monad just generalises the notion of sequencing to a rather extreme level, and in that it's similar to Monoid…  it doesn't really say much about *what* is being sequenced and what the actual semantics of sequencing is (except for the Monad laws, which put some constraints on the semantics)
04:18:07 <maerwald> it's just that people always come up with "analogy XY does not explain specific monad AB"
04:18:20 <tdammers> Monad analogies are easy: A Monad is like this thing where you have a bind operation and a return operation, and they follow these really simple laws.
04:18:25 <maerwald> it's ok if it doesn't, you will notice and adjust your understanding
04:18:35 <tdammers> now all you need is an intuition for bind, and an intuition for return, and you're done
04:19:02 <phadej> maerwald: all analogies are something about "box", but that's an analogy for containers, not Monads.
04:19:07 <dibblego> analogies are there to ensure perpetual confusion
04:19:13 <maerwald> phadej: I disagree
04:19:24 <phadej> all analogies* I remeber have heard
04:19:26 <dibblego> they are terrible teaching tools, especially in this context, and I spent countless hours helping the victims
04:19:27 <tdammers> seriously though, the problem with most monad analogies is that they are too specific - they depict how a particular type works that happens to be a monad, and how that type uses the monad pattern to do  its thing, but it doesn't actually illustrate what Monad itself is about
04:20:04 <tdammers> and indeed, the box thing is bad, because it suggests that things are being put into other things
04:20:15 <maerwald> depends on how it is explained
04:20:25 <tdammers> and, even worse, that *one* thing is put into *one* box
04:20:30 <ertes-w> you get a working intuition for monad, once you know a few monads and learn the notion of *abstracting* over Monad…  i.e. what can you see, if all you see is Monad?
04:20:32 <tdammers> and then you give people the list monad, and it baffles them to pieces
04:20:46 <maerwald> tdammers: that's fine
04:20:50 <ertes-w> and then you learn how things like MonadIO and MonadState make sense
04:20:56 <tdammers> which is why I like to mention list monads very early when explaining monads
04:20:58 <maerwald> that's exactly the process to understand it
04:21:05 <speak> Do people even need to understand monads, until they have all the necessary information to just get monads at their own pace?
04:21:05 <maerwald> I don't see why people are overcomplicating this
04:21:12 <dibblego> no it isn't, it's the method of confusion that I am constantly correcting
04:21:27 <tdammers> speak: they need to understand that there is an underwhelming amount of things to understand in the first place
04:22:09 <tdammers> I think the "box" analogy is something that occurs easily in many learners, and I believe it is worth challenging early on
04:22:20 <dibblego> "box" is not an analogy, it's a misintegration
04:22:41 <tdammers> it's a mental model - a wrong one, but it does pop up
04:22:46 <maerwald> tdammers: examining different analogies and see how they fail in other contexts is exactly the thing that people need
04:22:50 <dibblego> the student who suffers this sloppy teaching method is better off having never started
04:22:59 <maerwald> so instead of trying to come up with that one perfect analogy, just show them all
04:23:02 <tdammers> forming mental models, seeing them challenged, and discarding or adapting them, is kind of a natural learning process
04:23:08 <maerwald> exactly
04:23:13 <dibblego> a pot plant understands "monad" better than the poor victim of this model
04:23:16 <maerwald> so don't fight the analogies, let them flow
04:23:20 <tdammers> no - not show them all, disprove them all
04:23:25 <maerwald> that too
04:23:34 <tdammers> let them flow, but don't hand them to the student
04:23:51 <dibblego> no, prevent them, and aspire toward efficiency
04:23:51 <ertes-w> to be fair i don't think it's as hazardous as many people seem to think that beginners actually learn the "box"/"container" analogy
04:24:09 <tdammers> dibblego: we've disagreed on this before, haven't we
04:24:09 <ertes-w> rationale: there is benefit in having them experience this notion being challenged
04:24:15 <Rembane> I like the "staring at types" method.
04:24:17 <dibblego> let's just say this city would still be confused if I had deployed such an atrocity on them
04:24:22 <dibblego> tdammers: don't know
04:24:30 <maerwald> if you are that concerned about correctness of answers, just give the mathematical model of monads and be done with it. And see how your students are not(???) confused
04:24:43 <dibblego> tdammers: I know that this analogy method is a total failure, and I am very sympathetic toward its victims.
04:24:50 <tdammers> dibblego: agree this much
04:24:52 <ertes-w> "this is why your analogy does not work"…  you can't provide that experience, unless you let them make the mistake first-hand
04:25:10 <dibblego> no, give the mathematical definition *and appropriate exercises that reinforce a correct mental model from which accurate inferences can be made*
04:25:20 <dibblego> tell me that is hard, and I'll show you 500 of my students who disagree
04:25:27 <maerwald> the mathematical definition is meaningless for a lot of people
04:25:30 <dibblego> No.
04:25:35 <tdammers> dibblego: I don't think teachers should provide analogies at all. I'm just saying that learners will come up with mental models, and maybe analogies, themselves, and when they do, it is the teacher's task to challenge these with more examples, theory, etc., as needed
04:25:36 <dibblego> It is absolutely full of meaning.
04:25:42 <maerwald> dibblego: for maths people maybe :)
04:25:46 <maerwald> you are assuming a lot here
04:25:49 <dibblego> maerwald: all people are maths people
04:25:52 <maerwald> no.
04:26:03 <dibblego> my children are maths people, they didn't fall victim to this, they know what monad means
04:26:05 <Rembane> Don't you need the math language to understand the mathematical definition?
04:26:07 <dibblego> Yes.
04:26:12 <maerwald> oh jesus
04:26:22 <dibblego> jesus is a maths person
04:26:31 <Rembane> wb maerwald btw
04:26:40 <AndreasK> This is why we can't have nice things
04:26:52 <dibblego> "sorry, you're not a maths person, I am going to confuse you about monad more than a lamp post is confused about monad, k?" 
04:27:00 <tdammers> something like: teacher: "OK, so here's this >>= operator that I can use on Maybes, like so: ..." - student: "Oh, OK, I get it, so it's like there's this value inside the Maybe, and then >>= takes it out and feeds it to another function that then wraps it back in a Maybe" - teacher: "Not quite, because look, >>= also works on lists: ..."
04:27:37 <Rembane> tdammers: And so on until you have gone through all the common monads?
04:27:40 <dibblego> I can show you hundreds of "not maths people" who were first victims to this inefficient method, and are now productive with an accurate meaning. What now?
04:27:41 <maerwald> dibblego: everyone is a philosopher so let's build a lot of mental models and disprove them ;) there you go
04:27:53 <tdammers> student: "OK, so hmm, maybe my idea of 'inside' wasn't quite accurate, but surely if I broaden it a bit it'll still work for lists" - teacher: "ah, but let me show you the continuation monad: ..."
04:28:04 <Rembane> :D
04:28:09 <dibblego> show me the most "not maths person" you could know, and I will train a child to teach them what monad means faster than any broken analogy.
04:28:15 <maerwald> lol
04:28:16 <tdammers> Rembane: enough of them to carve down to the essence, yes
04:28:17 <dibblego> There's the challenge. I will put it to the test.
04:28:24 <Rembane> tdammers: Good stuff. 
04:28:37 <tdammers> Rembane: obviously the teacher's choice of monad instance matters
04:28:50 <maerwald> tdammers: hopefully they don't start with Cont :P
04:28:50 <Rembane> tdammers: I think using monad instances is one of the better ways to learn them.
04:28:51 <dibblego> It's such bullshit. Like I said, I am constantly correcting it, have been for years. So, I am no longer sympathetic to these broken teaching methods.
04:28:53 <Rembane> tdammers: Indeed.
04:29:08 <maerwald> dibblego: well and I disagree with you, kindly
04:29:24 <dibblego> maerwald: sure, just letting you know that I intend to continue corecting it, without apology :)
04:29:30 <tdammers> and of course all that requires keeping the formal definition around, and mechanically implementing the monad instances and testing them against the monad laws
04:29:43 <speak> What is the mathematicial definition for a monad?
04:29:52 <speak> Err nevermind, I'll just look it up
04:30:16 <ertes-w> speak: a useful mathematical definition of Monad the way it's used in haskell is best looked up in the Control.Monad documentation
04:30:24 <maerwald> dibblego: sure, you play into my methods by doing that ;)
04:30:30 <dibblego> I can have a room of 40 people implementing Monad.hs in three days. Many of them claim to be "not maths people." I have done this about 40 times over the last 15 years. https://github.com/data61/fp-course/blob/master/src/Course/Monad.hs (formerly Misty.hs)
04:30:37 <Rembane> speak: https://en.wikipedia.org/wiki/Monad_(functional_programming)#Formal_definition :D
04:30:38 <ertes-w> speak: Monad is really a special case of the monads from category theory
04:31:08 <dibblego> maerwald: No, I apologise for them having been misled, then I ask them to trust me (like they did for the broken method of teaching), by coaching them and obtaining their trust. Then with that blank slate, I install the correction (which is the easy bit).
04:31:21 <maerwald> whatever :>
04:31:55 <dibblego> Teaching children, or programmers who have not fallen into this trap, is much easier.
04:32:09 <dibblego> I do enjoy the challenge though.
04:32:52 <Rembane> Monads are like these sushirolls, and comonads are inside outs.
04:32:54 <dibblego> I also enjoy teaching people to recognise this trap, after having fallen into it.
04:33:09 <maerwald> Rembane: california roll
04:33:16 <maerwald> it's not traditional sushi
04:33:21 <Rembane> maerwald: Ah, indeed. 
04:33:25 <Rembane> maerwald: "Sushi"
04:33:25 <ertes-w> "monoids are like empty sushi rolls"
04:33:46 <dibblego> analogies are good for making jokes, once you recognise there is no other utility :)
04:33:55 <speak> Thanks Rembane & ertes-w 
04:33:58 <Rembane> speak: np
04:34:07 <Rembane> dibblego: They form hooks in the brain which is quite useful.
04:34:13 <Rembane> dibblego: ...for remembering stuff.
04:34:19 <maerwald> learning is all about associating stuff
04:34:21 <dibblego> again, let's put it to the test
04:34:37 <dibblego> I have spent countless hours on victims of this broken method. What now?
04:34:56 <maerwald> that's just... your opinion man
04:35:03 <dibblego> I am happy to watch it fail, after of course, having put it to an ethics board.
04:35:23 <speak> dibblego: I see only one fault in this whole discussion:   It is one thing for you to sit down with people and teach them. It is another thing to read an already written explanation of what a monad is what it does in Haskell
04:35:38 <speak> The latter is where a lot of the problems come in
04:35:50 <dibblego> speak: the test result can be measured by: is capable of making useful inferences from the method
04:35:55 <speak> Because I'm reading the mathematical definition, and I haven't got the slightest clue what's going on
04:36:10 <dibblego> show the poor student a "box", then ask them to complete an exercise that requires an understanding of the simplest inference, and observe failure
04:36:20 <ertes-w> speak: do you know a few monads?
04:36:26 <ertes-w> specific ones, i mean
04:36:33 <speak> What I mean is that you say that people just need the definition and a few examples. What I'm saying is no: they need a teacher who will sit down and explain stuff :P
04:36:42 <dibblego> speak: that's not how this works. I do not say, "go and read the mathematical definition, and measure for yourself your own progress."
04:36:45 <speak> ertes-w: Let's leave me out of the discussion as much as possible :D
04:37:01 <dibblego> speak: I am happy to help you, but I am not going to fall for this common teaching trap.
04:37:02 <speak> (maybe I should start)
04:37:03 <maerwald> speak: it's just about how you talk about analogies. If you make them seem to be a perfect mental model that can be applied anywhere, then it's wrong. If you show them that there are different mental models that apply to a subset of specific monads, then those are intuition points people can use, while still knowing the concept is more abstract than that
04:37:40 <ertes-w> speak: ok…  i was going to make the point that once you know a few monads, and you have memorised Monad together with the monad laws, it's actually fairly easy to explain what Monad is in general
04:37:40 <dibblego> amusingly, the joking analogies earlier are the most accurate, yet they are deliberately inaccurate
04:37:44 <Rembane> speak: http://dev.stephendiehl.com/hask/#eightfold-path-to-monad-satori
04:39:13 <maerwald> Rembane: well, that's just the suggestion "don't ever help people with building intuition and assume they can build it themselves"
04:39:13 <speak> Sorry I didn't mean to lead the discussion astray. I just thought it might be a viable point, that it doesn't matter whether you use a broken analogy or not, what matters is that you have a teacher who sits down with you and explains stuff, and goes through some examples
04:39:16 <maerwald> which is not very useful imo
04:39:36 <speak> ertes-w: I believe it
04:39:44 <speak> maerwald: Makes sense
04:40:31 <Rembane> maerwald: I think it's the "build patterns-approach" which is interesting. 
04:41:18 <dibblego> speak: I agree.
04:41:38 <Rembane> OTOH, I have used all the methods to learn how monads work. So I dunno which ones work and which ones don't...
04:41:38 <dibblego> but, broken analogies do matter, they hinder progress, they are a barrier, an additional thing that must be overcome
04:41:50 <dibblego> they are not without consequence, for if they were, my job would be a lot easier
04:41:56 <maerwald> no, only if you sell those analogies as absolute
04:42:02 <dibblego> No.
04:42:09 <dibblego> Show me the single counter-example. 
04:42:18 <maerwald> I don't know what that means
04:42:21 <maerwald> cut open someones brain?
04:42:27 <dibblego> I will concede to most generously designed test, and I will confidently watch the same result that I have seen for a very long time.
04:42:46 <dibblego> Design a test. I won't evn make it hard. That's how certain I am of what is going to occur.
04:42:52 <maerwald> results are hard to measure in teaching
04:42:54 <dibblego> I will agree to the most generous of terms.
04:43:13 <dibblego> Chicken :)
04:43:31 <dibblego> There is not a single counter-example on this planet.
04:43:42 <tdammers> maerwald: not "assume they can build it themselves", but "realize that they must build it themselves"
04:43:46 <maerwald> I think you are a little bit over-confident of your methods, but well
04:44:18 <dibblego> Not really. I am confident that this definitely does not work. I said nothing about the effectiveness of my methods.
04:44:39 <Rembane> dibblego: How do you measure does not work?
04:44:47 <maerwald> I don't really care that much. Arguing about "data points" wrt teaching makes no sense
04:44:57 <dibblego> Here is a generous test. There exists one person, not zero, that learned a thing by this method. 
04:45:05 <tdammers> I believe that, as a learner, forming hypotheses and refining or rejecting them as you learn is the way to go; but it is a common mistake for teachers to try and use such analogies as shortcuts... something like "if only I tell the student the right analogies, they will not have to come up with them themselves, and they will learn much faster"
04:45:25 <dibblego> Rembane: by giving the simplest of task, requiring a simple inference, that cannot be completed without an understanding of the concept.
04:46:02 <Rembane> dibblego: Ah. That's abstract. Hm...
04:46:02 <tdammers> dibblego: what would be a suitable such task to assert "understanding" of the monad concept?
04:46:06 <dibblego> that is the only bit I won't compromise on, in the test
04:46:08 <maerwald> tdammers: well, show some monads, then offer some analogies that cover some of them, but fail on others. I wouldn't expect everyone to be able to come up with that himself, even if he has seen several monads.
04:46:22 <dibblego> tdammers: for example, can write, use and explain sequence
04:46:34 <maerwald> smart people can, or those more familiar with abstract models, maths or whatnot
04:46:54 <maerwald> but it's too easy to say they just must build everything themselves
04:47:00 <maerwald> then you can just say "learn for yourself"
04:47:04 <maerwald> and give up
04:47:13 <dibblego> tdammers: by using the "box analogy", I claim that you will find a slightly lower success rate than if you had done nothing at all.
04:47:43 <dibblego> I must go. Be nice to learning people. Bye.
04:48:06 <ertes-w> Rembane: my point earlier is that going through bad learning methods is actually valuable to some people
04:48:23 <ventonegro> Monad Mondays
04:48:31 <maerwald> is it monday? :>
04:48:33 <maerwald> there you go
04:48:36 <tdammers> dibblego: I think it's a good test, except for the "explain" part
04:48:43 <tdammers> I would totally fail the explaining myself
04:48:56 <tdammers> can't think of any explanation that is better than the definition of the function itself
04:49:05 <ertes-w> Rembane: so yeah, it may very well be that your experience doing all of the "bad" approaches actually helped you understand
04:49:39 <Rembane> ertes-w: Indeed. And then using monad instances a lot was needed.
04:50:08 <tdammers> maerwald: no, that's not the same. You present people with the facts (definitions of bind and return, monad laws), and with examples (some specific monads and how their monad instances behave), and let the student form intuitions
04:50:28 <maerwald> haven't seen that work, only for a few smart people :>
04:50:31 <tdammers> maerwald: that's not the same as just saying "hey so this thing called Monad exists, you go figure it out"
04:50:43 <tdammers> it works fine
04:51:06 <tdammers> provided the learner has the prerequisites
04:51:11 <maerwald> different experience then
04:51:32 <tdammers> some familiarity with Haskell types, polymorphic types, that kind of thing
04:51:43 <tdammers> one should at least understand Functor before trying to tackle Monad
04:51:49 <maerwald> sure
04:52:19 <tdammers> and in fact, the path to understanding Functor is eerily similar
04:52:44 <tdammers> we have this generalized map function, and a bunch of types that come with functions that match the shape of map as well as its laws
04:52:49 <maerwald> anyway, we have just very nicely disproved that haskell is easy to learn :>
04:52:58 <tdammers> have we?
04:53:02 <tdammers> I don't think so
04:53:05 <maerwald> I think so
04:53:13 <tdammers> we have shown that Haskell is difficult to *teach*
04:53:22 <maerwald> that too
04:53:25 <Rembane> So eh... are functors boxes? :)
04:53:34 <tdammers> some are
04:53:40 <tdammers> most aren't
04:54:14 <maerwald> the amount of intuition you need for abstract concepts exceeds those of most other languages and therefor is definitely harder to learn, takes more time and meditation
04:54:35 <maerwald> goroutines you understand in one day, the language in 2
04:55:04 <tdammers> can't comment on Go, really
04:55:25 <tdammers> but when I first encountered the concept of coroutines and similar concurrency approaches, my brain hurt for weeks
04:55:58 <tdammers> there is a lot of abstraction in Haskell though, I give you that
04:56:53 <tdammers> I think the big boost comes when you realize that you can manage 99% of that entirely mechanically, just by manipulating symbols, which frees you from the need to deeply "understand" things
04:57:43 <tdammers> hey, this data structure has a Functor instance, so I can fmap over it, great - I don't need to know anything about the data structure, it is perfectly obvious what fmap will do, conceptually
04:58:12 <Rembane> maerwald: Isn't it that Go is a lot like languages you already know, while Haskell isn't?
04:58:54 <tdammers> fmapping over sets, trees, IO actions, continuations, etc.; it doesn't matter, you don't need to "understand" how any of these things work, all you need to know is 1) they're functors, 2) this means I can fmap over them, 3) the output of fmap has "the same structure" as the input, fsvo "structure"
04:59:32 <tdammers> I haven't seen any other language where you can do this to this extent (other than other Haskell-like typed pure FP languages)
05:00:04 <maerwald> Rembane: I have heard that argument a lot and I don't think it is really accurate
05:00:26 <Rembane> maerwald: Why?
05:01:46 <maerwald> Rembane: because it's not about what is new, but about how complex and abstract the concepts are
05:01:53 <Rembane> maerwald: Good point.
05:02:08 <maerwald> what is there really complex in C? I mean as a concept, not the pitfalls
05:02:11 <maerwald> pointers.
05:02:12 <maerwald> that's it
05:02:46 <ertes-w> tdammers: actually i disagree that haskell is difficult to teach…  it takes longer, because there are a lot of concepts, but it's not really more difficult
05:03:02 <Rembane> maerwald: That almost every behaviour is undefined?
05:03:06 <maerwald> heh
05:03:28 <maerwald> well, the compilers should not allow UB, not the fault of the language :P
05:03:30 <Rembane> maerwald: That it says that it is typed but really isn't.
05:03:33 <Rembane> maerwald: null pointers
05:03:40 <Rembane> maerwald: All the mechanical stuff you need to do all the time
05:03:50 <maerwald> those are pitfalls mostly, not concepts
05:04:02 <cocreature> if your language doesn’t say that compilers should not allow UB, it’s definitely the fault of your language
05:04:03 <tdammers> C is basically, "what if everything were an integer, and also simultaneously a pointer?"
05:04:24 <Rembane> A pile of bits.
05:04:57 <tdammers> anyway, most of the complexity in typical C programs stems from the lack of abstraction tools in the language itself
05:05:05 <maerwald> nah
05:05:14 <maerwald> it's the lack of formal verification
05:05:44 <tdammers> formal or semi-formal verification is one of the abstraction tools that are lacking
05:05:53 <tdammers> but there are more
05:05:56 <maerwald> I don't know if I'd call those abstraction tools
05:05:58 <ertes-w> the complexity of typical C programs, after subtracting the expense of bug hunting, is still very large and does stem from the lack of abstraction capabilities
05:06:17 <tdammers> a type system is a tool that aids you in forming and enforcing abstractions
05:06:23 <maerwald> formal verification is just formal verification, not reorganising your program to be more abstract
05:06:44 <maerwald> abstraction can provide similar things like formal verification does
05:06:51 <maerwald> like a typesystem indeed
05:07:03 <maerwald> that doesn't mean the problem is missing abstraction
05:07:03 <tdammers> true; but formal verification helps you in keeping your abstractions sound, and thus makes them practically manageable
05:07:15 <cocreature> the formal verification tools that don’t require that you change your code in some way don’t exist
05:07:24 <maerwald> C is not about abstraction and it shouldn't be
05:07:29 <tdammers> the problem is that high degrees of abstraction are much harder to achieve in C
05:07:46 <tdammers> I disagree
05:07:50 <tdammers> C is very much about abstraction
05:08:03 <maerwald> well, not we are nitpicking
05:08:05 <maerwald> *now
05:08:13 <tdammers> it just wasn't intended for a very high degree of it, compared to, say, Haskell
05:08:36 <ertes-w> C was originally regarded as a high-level language, but it never evolved much past its origins
05:08:48 <ertes-w> from today's perspective it's basically assembly
05:08:54 <tdammers> anyway, C lacks both certain crucial abstractions *and* supportive tools to manage and enforce abstractions
05:08:56 <AndreasK> high level is always a somewhat comperative term
05:09:14 <maerwald> C lacks correctness, not abstraction
05:09:30 <ertes-w> C also lacks modern abstraction capabilities
05:09:53 <tdammers> C has no metaprogramming features, no inline lambdas, no safe polymorphism
05:10:05 <maerwald> you don't have to make every language haskell-ish really
05:10:24 <tdammers> I didn't say Haskell-style metaprogramming/inline lambdas/polymorphism
05:10:39 <Freundlich> One positive aspect of C is that programmer's usually have a good intuition for what the compiled code will run like and how much memory it uses.
05:11:00 <Freundlich> If you go one level higher, e.g. to C++, there can be very huge and very surprising costs you pay for certain abstractions.
05:11:16 <cocreature> I have a very good intuition for what the compiled C code that I write will run like: it will segfault
05:11:18 <maerwald> C is a very well designed language actually, with a very narrow scope. It's just that it lacks correctness, because compilers allow a lot of weird crap and formal verification is not widespread
05:11:34 <maerwald> if you want it to be something else, don't do C
05:11:54 <tdammers> there are lots and lots of languages out there that lack correctness
05:12:07 <tdammers> many of them are still much better at making abstractions than C is
05:12:14 <ertes-w> i wish ML came before C
05:12:15 <maerwald> and actually, the formal verification tools for C are the most advanced
05:12:34 <tdammers> hah, yes, maybe because they are needed the most direly
05:12:40 <ertes-w> … and get the same marketing that C got
05:12:40 <maerwald> not only that
05:12:54 <maerwald> it's because of the low-level properties too
05:13:25 <maerwald> jesus, I need to do some work here
05:13:28 <maerwald> I guess :>
05:13:54 * maerwald books this under *research*
05:16:54 * hackagebot logging-effect 1.2.1 – A mtl-style monad transformer for general purpose & compositional logging – https://hackage.haskell.org/package/logging-effect
05:48:20 <ph88> if i have multiple lists like [1, 2] [10, 11] [98, 99] and i have to pick 1 from each to get all combinations so [1, 10, 98], [1, 10, 99], [1, 11, 98] .. how is this called ?
05:48:55 <Maxdamantus> ph88: cartesian product.
05:49:01 <ph88> thx
05:59:19 <jakub> is there a commutative monoid isomorphic to N | J1 a | J2 a such that N <> J1 a = J1 a, N <> J2 a = J2 a, J1 a <> J2 a = J2 a (intuition: there either is no value, there is a fallback value relevant if not overriden, or there is just a value)
05:59:28 <jakub> somewhere in base
06:04:00 <lieven> jakub: Last?
06:04:06 <lyxia> Maybe (Bool, a)
06:04:38 <lyxia> oh no nvm
06:06:17 <lyxia> jakub: what about   J1 a <> J1 b     and   J2 a <> J2 b
06:07:05 <jakub> lyxia: yeah i just realized, well scratch commutativity for these cases and make it for example biased to the left, i don't really care :)
06:09:21 <jakub> lieven: Last doesn't differentiate between J1 and J2, so [J2 a, J1 a] would be J1 while [J1 a, J2 a] would be J2, i wanted to prioritize J2 over J1 in all cases
06:09:57 <lyxia> maybe something using Arg...
06:10:09 <lieven> a Last over Either or something like that
06:12:07 <jakub> last is hardwired with maybe, it will only return last Just value or Nothing it cannot peek inside
06:17:46 <lyxia> Option (Either a a)
06:30:26 <ertes-w> ph88: or 'sequenceA'
06:30:28 <ertes-w> =)
06:30:47 <ertes-w> > sequenceA ["h", "e3", "l", "lL", "o0"]
06:30:49 <lambdabot>  ["hello","hell0","helLo","helL0","h3llo","h3ll0","h3lLo","h3lL0"]
06:35:19 <iqubic> > replicateM 3 "01"
06:35:22 <lambdabot>  ["000","001","010","011","100","101","110","111"]
06:35:32 <iqubic> What the hell is that???
06:35:43 * Axman6 adds this to his 1337h4x p4ssw3rd generator
06:35:59 <iqubic> Axman6: This is a weird thing, isn't it.
06:36:05 <Axman6> not really
06:36:08 <iqubic> :t (.) . (.)
06:36:09 <lambdabot> (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
06:37:33 <iqubic> :t \f x -> (x .). f
06:37:34 <lambdabot> (a1 -> a -> b) -> (b -> c) -> a1 -> a -> c
06:37:55 <iqubic> Oh, that's literally the same thing with flipped args.
06:39:33 <iqubic> Anyways, now that I know what forall a. does, when is it actually used in actual code?
06:39:56 <Axman6> it's used all the time in Lens
06:40:07 <iqubic> Err... Why?
06:40:25 <Axman6> type Lens s t a b = forall f. Functor f => (a -> f b) -> (s -> f t)
06:40:44 <Axman6> because lenses need to work for _any_ functor, which means all they can do is fmap things
06:41:13 <Axman6> and the user of them gets to decide which functor to use - Const for getters, Identity for setters and modify, etc
06:41:16 <iqubic> I see.
06:42:19 <iqubic> Lenses are weird. I still need to look at the type signatures whenever I want to use them.
06:42:44 <iqubic> And there's no way that I'll be memorizing half a dozen infix operators.
06:43:09 <Axman6> there is some method to the operator madness
06:43:20 <Axman6> they're generally very consitent
06:44:11 <phadej> have to promote: http://hackage.haskell.org/package/acme-operators
06:45:04 <phadej> have to upgrade it to work with newer base :)
06:48:12 <Axman6> on the other end of the spectrum, have you seen https://github.com/mxswd/flip-plus?
06:49:04 <Axman6> (the fact you have to view the file as a raw file should come as a warning, but it's worth it)
06:50:10 <geekosaur> @_@
06:51:40 <maerwald> sheesh
06:52:07 <maerwald> surprised github identifies it successfully as haskell source file :>
06:53:19 <tdammers> haskell is mainstream enough for github to bother
06:53:52 <iqubic> The hell is that stuff.
06:54:06 <iqubic> I hope no one uses it in any code anywhere.
06:54:27 <mnoonan> is it bad that the first thing annoying me about that module was that all of the operators ending in 'f' are redundant?
06:54:48 <iqubic> Why do you say that mnoonan
06:56:48 <mnoonan> like, you don't need a "flipFirstTwoOfThreeArgs".. that's just "flip"
06:57:11 <maerwald> tdammers: is it really? :P
06:57:38 <tdammers> maerwald: apparently
06:58:26 <mnoonan> (oops, i meant "all operators ending in & in that module are redundant")
07:42:40 <bs0d> Hello everyone
07:44:09 <bs0d> Is there any interactive website with lots of exercises of varying difficulty? I am a newb and wish to learn Haskell, so exercises building up from the very basic level would be very nice to have
07:50:41 <amx> bs0d: if you have a fairly strong math background project euler is an option, otherwise I really enjoyed Advent of Code
07:51:25 <maerwald> project euler has no implementation guidance and is not haskell specific
07:52:34 <maerwald> maybe http://exercism.io/languages/haskell/about ? but I really have no idea how good those exercises are, anyone?
07:52:48 <lieven> open.kattis.com supports haskell
07:59:51 <dmj`> @google 99 haskell problems
07:59:53 <lambdabot> https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems
07:59:58 <dmj`> bs0d: ^
08:00:33 <tdammers> not interactive though
08:00:53 <tdammers> then again, I find Haskell less suitable for interactive learning and more suitable for pen-and-paper driven learning
08:00:58 <bs0d> thanks. I am following http://learnyouahaskell.com and will be trying to practice exercises
08:01:11 <dmj`> tdammers: GHCi(nteractive) :)
08:01:16 <bs0d> I just started today, so I am a complete newb
08:02:08 <dmj`> bs0d: 99 is good, it starts very basic, and has answers, good way to get your feet wet
08:02:15 <tdammers> dmj`: I didn't say it's not *possible*, just that the language lends itself less to it
08:02:27 <dmj`> tdammers: fair :) and agreed.
08:02:49 <tdammers> (which, incidentally, I think is a good thing)
08:02:59 <awwper> hello
08:03:50 <locallycompact> Why is the mtl different
08:03:52 <locallycompact> https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Reader.html#t:ReaderT
08:04:05 <locallycompact> What's that k about
08:04:05 <lyxia> is it?
08:04:21 <geekosaur> oh, it's shwowing polykinds now
08:04:21 <locallycompact> type Reader r = ReaderT * r Identity
08:04:35 <geekosaur> but haddock shows them poorly
08:04:50 <lyxia> It's kind polymorphic, for no particular reason other than it can be.
08:05:07 <locallycompact> What does that mean though
08:06:02 <geekosaur> I think, if you have to ask, the correct answer is that you should just ignore it
08:06:34 <geekosaur> kind polymorphism is used with type level computations
08:06:48 <geekosaur> (a kind is the "type" of a type)
08:06:53 <locallycompact> I know what a kind is
08:09:01 <lyxia> Like you can have forall types, you can have forall kinds.
08:09:59 <locallycompact> where's the source for this newtype declaration
08:10:07 <lyxia> in transformers
08:10:56 <locallycompact> that looks like the old one
08:11:01 <geekosaur> it is the old one
08:11:15 <geekosaur> I said haddock displays kind polymorphism badly
08:11:19 <geekosaur> the definition did not change
08:11:39 <locallycompact> this is very confusing
08:12:07 <geekosaur> but if kind polymorphism is enabled, there is nothing in the definition forcing the type of the reader function to have kind *
08:12:23 <geekosaur> so it is made polymorphic. and then haddock displays it weirdly because haddock
08:13:41 <geekosaur> (well, result types of functions are always kind *. the parameter(s) may have any kind, if not otherwise constrained.)
08:14:22 <locallycompact> so r might be a different kind?
08:15:05 <lyxia> r is still of kind *
08:15:26 <lyxia> ReaderT k (r :: *) (m :: k -> *) (a :: k)
08:15:45 <bs0d> what does the /= operator mean? 5 /= 5 = False, but 5 /= 4 = True
08:15:56 <geekosaur> not equal
08:16:09 <lyxia> But k can generally be omitted, so you can still write ReaderT r m a as before
08:16:53 <locallycompact> That's going to be very difficult to explain to a new user
08:17:11 <tabaqui> rating system on hackage? rly?
08:17:50 <lyxia> locallycompact: I think we all agree here
08:43:18 <trevortknguyen[m> Hi. I'm a beginner and my interest is in using Haskell as an autonomous flight controller for a drone. I have an idea of how the program would work. It seems like crux of the program would be ```calculateMotorThrusts :: DroneState -> DroneState -> MotorThrusts``` where it has the current state of the drone and the desired state of the drone and the function calculates what the motors need to do in order to get to
08:43:19 <trevortknguyen[m> the desired state. I've seen some stuff about FRP and it might make sense to use a library for FRP like Sodium or Yampas. Could someone tell me if the way I am thinking about the problem is Haskell-like or at least logical?
08:43:53 <maerwald> hopefully not a war drone :>
08:44:38 <trevortknguyen[m> maerwald: I'm a hobbyist and a beginner at Haskell. I don't think I could afford to arm it unless I got a grant. :/
08:44:50 <mniip> haskell is terrible for realtime though
08:45:02 <tdammers> you'd be surprised how cheaply one could weaponize a drone
08:45:02 <mniip> I was thinking of programming a drone in ARM assembly
08:45:22 <apo> tdammers: water balloons? :D
08:45:27 <tdammers> apo: yes, totally
08:45:34 <maerwald> I'm not sure I'd go the FRP route so quickly
08:45:34 <tdammers> apo: filled with red wine
08:45:50 <trevortknguyen[m> mniip: what makes it bad for real-time? Does it have to do with the compiled code?
08:46:02 <ventonegro> Dropping metal rods would be nasty
08:46:02 <mniip> no
08:46:04 <tdammers> trevortknguyen[m: no, the garbage collection is what kills RT
08:46:13 <mniip> in general it's very hard to predict how much a piece of code takes
08:46:27 <tdammers> ventonegro: problem with metal rods is that they're heavy, so you need a rather hefty drone to carry them
08:46:27 <apo> mniip: assembly? Sounds painful
08:46:34 <trevortknguyen[m> maerwald: I think FRP was just something that I saw on the Wiki page for Haskell + Robotics. I very loosely understand reactive programming.
08:46:44 <apo> I do asm stuff, but only for single routines, when it's absolutely necessary :)
08:46:45 <mniip> you can apply asymptotic approximations from algorithm theory, but not for small inputs
08:47:00 <mniip> apo, well, maybe some C
08:47:10 <mniip> but definitely my own irq setup and stuff
08:47:22 <maerwald> wouldn't want my drone to crash because of memory corruption, so probably rather rust
08:47:34 <mniip> maerwald, memory?
08:47:44 <tdammers> I'd probably go with the "haskell DSL that outputs assembly" approach
08:47:45 <mniip> you wouldn't do allocation on a hard realtime application
08:47:55 * apo is working on another arm project atm, https://0au.de/~apo/draft/project/electronics/dcf77-frequency-reference/ - but there I actually went for C++ :)
08:48:01 <mniip> the idea was to drive all 4 ETCs from an STMF32
08:48:09 <apo> (Mostly so I could use templates for the fixed point arithmetics)
08:48:16 <tdammers> hmm, I wonder what kind of acceptable slack we're talking here
08:48:20 <mniip> and driving ETCs is a fairly hard tealtime
08:48:22 <trevortknguyen[m> maerwald: you're saying that because everything is immutable, you would get a lot of discarded memory pile up quickly?
08:48:39 <mniip> tens of microseconds?
08:48:42 <tdammers> probably not as hard as low-latency audio though
08:48:59 <maerwald> mniip: then just UB
08:49:02 <fizbin> Anyone have a really good sense of the world of Haskell web frameworks? I'm trying to decide if it would be easier to delve deep into the guts of snap-server to hack in the feature I want or switch to a different framework.
08:49:16 <mniip> maerwald, shrug
08:49:20 <Clint> fizbin: they're all frustrating in different ways
08:49:22 <maerwald> you don't need heap allocation to mess up in C :>
08:49:26 <fizbin> The specific feature I want is the ability to about long-running calculations when a client disconnects.
08:50:11 <geekosaur> fizbin, how do you know when the client disconnects? most web connections are ephemeral
08:50:46 <tdammers> coding against plain WAI is pretty tolerable, problem is you need to do a lot of stuff yourself
08:51:10 <fizbin> geekosaur: If I can fire up ethereal and see the web client sending a RST packet and the web server keeps doing the calculation, then the framework has failed.
08:58:30 <fizbin> If the web client disappears because, say, the machine or an intermediate networking device lost power that's something else. (Though I'd appreciate a framework that let me manipulate TCP keepalive settings so that when that machine/network comes back up it'll send a RST in response to keepalives on a connection it knows nothing about)
08:59:46 <fizbin> I found a vague post to the snap mailing lists from over five years ago, but couldn't understand what was being suggested. (and so certainly couldn't map what was being suggested onto the current code)
09:06:08 <ertes-w> trevortknguyen[m: i think FRP is the right abstraction here, although i would suggest using reactive-banana or reflex instead
09:06:38 <ertes-w> trevortknguyen[m: but keep in mind that FRP has a learning curve of its own…  if you're a haskell beginner, you may have to study it for a while, before it clicks
09:08:55 <ertes-w> trevortknguyen[m: also haskell's performance can be difficult to predict for a beginner due to a combination of GC and immutable data
09:10:02 <Athas> And also for an expert, but this time due to rewrite rules!
09:10:52 <ertes-w> trevortknguyen[m: i wouldn't recommend a project that requires real-time, as long as you're a beginner…  even once you're more advanced, you might choose not to go with haskell for this particular application
09:11:24 <ertes-w> perhaps check out rust, which is much more predictable and can be used for soft real-time applications
09:18:03 * hackagebot squeeze 1.0.4.13 – A file-packing application. – https://hackage.haskell.org/package/squeeze
09:18:03 * hackagebot regexchar 0.9.0.15 – A POSIX, extended regex-engine. – https://hackage.haskell.org/package/regexchar
09:19:27 <tomasmu> good evening
09:20:31 <tomasmu> i'm very new at haskell, and have gotten stuck at some weirdness
09:21:15 <tomasmu> i tried to create a simple factorial function in the ghci (factorial 0 = 1; factorial n = n * factorial (n-1)), but when i call it with factorial 5, it just hangs
09:21:22 <tomasmu> same thing on two computers
09:21:52 <tomasmu> but if i write the exact same thing in a file.hs and do ghc --make file.hs it works with the .exe
09:22:11 <tomasmu> so what's going on there?
09:22:23 <srhb> tomasmu: How you write it exactly is important. I think you're redefining the name factorial, so the base case (factorial 0) never exists
09:23:18 <srhb> tomasmu: If you write it exactly as you did here (with the semicolon) it should work.
09:23:30 <srhb> If you write it on two (regular, not multi-) lines, you will simply redefine the name.
09:23:40 <tomasmu> the semicolon was actually a newline.. :)
09:23:48 <srhb> There's your problem then.
09:24:08 <srhb> The second definition shadows the first one entirely, so there's no base case.
09:24:27 <tomasmu> ahh, tricky, thanks :)
09:25:08 <srhb> ghci is a bit tricky like that.
09:27:48 <tomasmu> from the little i've done in haskell i quite like it already
09:28:57 <srhb> Great! :-)
09:29:53 <pgiarrusso> I heard about GHCi's :set +m (for multiline), would it help here?
09:30:54 <geekosaur> or on-the-fly multiline with :{ :}
09:31:00 <geekosaur> both are annoying
09:31:15 <tomasmu> just tried it, :set +m did unfortunately not help
09:31:49 <cocreature> the trick is to make it easy enough to load the file you currently have open in your editor in ghci that you don’t have to bother having to figure out how to enter complex stuff in ghci
09:33:56 <tomasmu> oh yes, forgot about :l(oad)
09:43:40 <sm> tomasmu: also check out ghcid
09:46:05 <srhb> tomasmu: :e will also open your editor
09:47:05 <tomasmu> srhb: ah, neat :)
09:47:33 <tomasmu> sm: looking at it now
09:48:20 <tomasmu> i was looking for visual code + some haskell extension also
09:48:42 <tomasmu> there seems to be two, haskelly and haskero
09:49:35 <sm> tomasmu: there are many, and none of them is 100% reliable I believe
09:50:16 <sm> many IDE plugins, I meant
09:59:33 <exarkun> I read https://docs.haskellstack.org/en/stable/GUIDE/#docker and added https://github.com/LeastAuthority/config-file-liveness-server/blob/master/stack.yaml#L68 to my stack.yaml as a result
09:59:52 <exarkun> this gives me a container that basically works but that masks/ignores/disabled SIGTERM somehow
10:00:14 <exarkun> anyone have any idea what's going on?  I like the default SIGTERM behavior well enough, if I could have that when running in a container that'd be just fine.
10:03:34 <cocreature> exarkun: sounds like you might be looking for https://github.com/fpco/pid1, https://www.fpcomplete.com/blog/2016/10/docker-demons-pid1-orphans-zombies-signals contains an explanation although I have to admit it’s been so long since I’ve looked at it that I’ve forgotten what exactly is causing problems
10:04:14 <exarkun> Oohh right
10:04:27 <exarkun> I only remembered half of the "pid 1 is special" junk
10:04:32 <pgiarrusso> +1 to cocreature's link
10:04:42 <exarkun> And "pid 1 does not exit on SIGTERM" is in the half that I forgot
10:05:04 <cocreature> what’s the other half? :)
10:05:05 <pgiarrusso> exarkun: the world is full of containers whose authors forgot or never knew that
10:05:21 <exarkun> pgiarrusso: that's true.
10:05:41 <exarkun> all of the containers on my current project had random crap as pid 1 until last week
10:05:54 <pgiarrusso> cocreature: you don't want to actually hear the answer, do you? :-D
10:05:56 <exarkun> (today only this last haskell container is missing a proper init, guess I better give it one now)
10:06:08 <fresheyeball> I need to serve an html page I am building with blaze-html
10:06:23 <fresheyeball> I can do it with Servant, but it feels like crazy overkill to serve 1 endpoint
10:06:32 <fresheyeball> any better recommendation
10:06:39 <cocreature> pgiarrusso: I need to satisfy my masochistic tendencies somehow
10:07:42 <reactormonk> I have `Foo a c -> Foo b c`, and I would like to write a `Fix (Foo a) -> Fix (Foo b)`. (Fix from recursion-schemes)
10:16:11 <lyxia> \f -> cata (Fix . f)
10:18:36 <tomasmu> sm: got ghcid now, it was quite convenient to have in the bottom terminal in vs code :)
10:19:24 <exarkun> so ... https://docs.haskellstack.org/en/stable/GUIDE/#docker only documents `entrypoints` ... can I leave the "entrypoint" alone and just specify the command?
10:20:28 <tomasmu> and now i'm off to learn me a haskell for great good
10:20:36 <tomasmu> bye, and thanks :)
10:24:43 <exarkun> guess I can specify that stuff externally instead
10:29:52 <sm> tomasmu: yep, you're welcome!
10:37:18 <trevortknguyen[m> ertes-w: Thanks for the insight. Looking up "real-time Haskell", I see a couple of EDSL languages such as Ivory, Atom, and Copilot. Those seem to be specifically geared toward writing expressive Haskell code to generate C-level code. I am looking into them right now.
10:39:29 <radial> when i try to emerge ghc on gentoo, it warns me that it needs at least 8 gigs of disk space to proceed
10:39:58 <lyxia> it's one of the joys of building ghc
10:40:00 <radial> i like to have my compiles done fully in memory, so i usually have the dir where the compiles take place be in ram
10:40:07 <radial> but i only have 8 gigs of ram
10:40:22 <radial> is there any chance that ghc might some day be a bit more conservative in its disk space requirements?
10:44:52 <reactormonk> :t \f -> cata (Fix . f)
10:44:54 <lambdabot> error:
10:44:54 <lambdabot>     • Data constructor not in scope: Fix :: b -> a
10:44:54 <lambdabot>     • Perhaps you meant one of these:
10:46:23 <reactormonk> Any way to import the dependencies into lambdabot?
10:46:55 <hpc> @let import Control.Monad.Fix
10:46:57 <lambdabot>  Defined.
10:47:06 <reactormonk> :t \f -> cata (Fix . f)
10:47:08 <lambdabot> error:
10:47:08 <lambdabot>     • Data constructor not in scope: Fix :: b -> a
10:47:08 <lambdabot>     • Perhaps you meant one of these:
10:47:17 <reactormonk> @let import Data.Functor.Foldable
10:47:18 <lambdabot>  .L.hs:101:1: error:
10:47:18 <lambdabot>      Failed to load interface for ‘Data.Functor.Foldable’
10:47:18 <lambdabot>      Use -v to see a list of the files searched for.
10:49:11 <reactormonk> lyxia, I don't understand it, but it seems to work...
10:51:31 <jared-w> @let import Control.Monad.Fix
10:51:34 <lambdabot>  Defined.
10:51:42 <jared-w> :t \f -> cata (Fix . f)
10:51:44 <lambdabot> error:
10:51:44 <lambdabot>     • Data constructor not in scope: Fix :: b -> a
10:51:44 <lambdabot>     • Perhaps you meant one of these:
10:51:57 <jared-w> Those are separate parts of the bot, apparently
10:52:30 <jared-w> > let f = cata (Fix . f) in f 1
10:52:33 <lambdabot>  error:
10:52:33 <lambdabot>      • Couldn't match kind ‘* -> *’ with ‘*’
10:52:33 <lambdabot>        When matching the kind of ‘Mu’
10:52:48 <MarcelineVQ> Fix isn't in Control.Monad.Fix
10:53:01 <jared-w> oh, that would explain it :p
10:53:45 <Tuplanolla> @let import Data.Functor.Foldable
10:53:46 <lambdabot>  .L.hs:101:1: error:
10:53:46 <lambdabot>      Failed to load interface for ‘Data.Functor.Foldable’
10:53:46 <lambdabot>      Use -v to see a list of the files searched for.
10:53:54 <Tuplanolla> It would be there.
11:56:19 <sqooq> hello meine freunde
11:56:44 <hexfive> hallo
11:56:56 <sqooq> idk what to do
12:00:10 <sqooq> I want to make having default options easier
12:00:17 <sqooq> otherwise it requires multiple functions
12:00:23 <sqooq> and it would make sense to do a terminal program
12:00:31 <sqooq> kek I'm not explaining this very well
12:01:44 <cocreature> sqooq: one solution that’s relatively common is to take a record type as a parameter and provide a "defaultOptions" value. then users can selectively overwrite the things they care about
12:01:55 <sqooq> I have a program that works with a library (csound-expression). One builds the instrument using csound-expression, or uses a prebuilt one, then calls my functions using that instrument as an argument.
12:03:05 <sqooq> cocreature: hmm
12:04:52 <raynold> ahh it's a wonderful day :-D
12:05:23 <cocreature> sqooq: you can ofc also simply make your function take a Maybe and handle that appropriately.
12:05:58 <sqooq> cocreature, I kind of wanted to make a terminal program
12:06:14 <cocreature> sqooq: not sure how that’s related to default options
12:06:22 <sqooq> only problem is that usually the instrument is created interactively in ghci
12:06:59 <sqooq> cocreature, like you call the program with two necessary parameters, the input and output file, but  you can alter the other options, for example instrument to use, tempo, etc.
12:07:28 <cocreature> sqooq: can you be a bit more specific? what problem are you currently having?
12:08:03 <crucify_me> hello I'm still confused about sumptin'  ..  if we have this const id = flip const  .. when would you ever use that (in a very simple case)?
12:08:17 <sqooq> I want it to be like (my program is called gould) : gould input.txt output.wav -i instr1 -t 80
12:08:39 <sqooq> cocreature, only thing is that "instr1" is a haskell function using csound expression.
12:08:55 <sqooq> and it's quite comfortable to build that instrument in ghci
12:09:06 <sqooq> yeah nvm maybe a terminal executable isn't the right path
12:09:15 <geekosaur> could just make that a haskell expression via hint or whatever
12:09:59 <geekosaur> also I think a terminal program would be the hard way. run it in a terminal, go steal chunks from:
12:10:02 <geekosaur> @hackage ghci-ng
12:10:02 <lambdabot> http://hackage.haskell.org/package/ghci-ng
12:10:14 <geekosaur> which is a standalone ghci used as a testbed for ghci improvements
12:10:42 <sqooq> the instrument can be done in a file too
12:10:43 <cocreature> depending on how restricted these expressions are, making a custom parser might also be a reasonable option
12:10:44 <geekosaur> ("standalone" meaning you don't have to build all of ghc to change it)
12:10:58 <sqooq> honestly if the instrument is going to be complex, that's probably going to be the case
12:11:21 <sqooq> cocreature, well yeah my idea is to use getargs and figure something out from there
12:11:43 <geekosaur> so, the hint package lets you evaluate arbitrary Haskell expressions
12:11:57 <cocreature> sqooq: I highly recommend using a library such as "optparse-applicative" for parsing cli args instead of using "getArgs"
12:12:01 <geekosaur> if you also need sandboxing, consider the MuEval package oinstead (it's what lambdabot uses)
12:12:13 <sqooq> cocreature, noted, thank you
12:12:27 <sqooq> geekosaur, i'm trying to consider users too
12:12:55 <geekosaur> if you're considering users, you're building a GUI and letting that deal with e.g. defaults
12:13:14 <sqooq> kek who am I kidding, I'm not going to have any users
12:13:41 <geekosaur> and yes, the usual way to do defaults for this kind of thing is a record with the defaults and record updates for overrides
12:13:47 <sqooq> maybe I should alter my program to do midi with pitchbends instead
12:15:08 <sqooq> geekosaur: ok
12:15:23 <sqooq> problem with that, is that my function changes depending on the default
12:15:39 <sqooq> for example if the user doesn't include a line representation, then I have to omit that entirely from the final function.
12:15:49 <crucify_me> I mean, what is the concept behind " const id " or " flip const " ? (I read a comment that 'const id' was a "terrible way to express the concept")
12:16:00 <geekosaur> sqooq, so the default is id
12:16:22 <sqooq> geekosaur, sorry, no like within the function definition itself
12:16:37 <sqooq> it's basically a bunch of composed functions, and one section of that composition has to be removed
12:16:43 <geekosaur> yes, and?
12:16:58 <geekosaur> functions are first class...
12:17:30 <geekosaur> so you have a record of functions, at the end you compose them together, at the beginning they're all id
12:18:05 <geekosaur> or other suitable default
12:18:24 <crucify_me> sorry moved that to beginners channel
12:18:25 <sqooq> i'm missing something
12:19:09 <geekosaur> it would be easier to explain if you provided something to start with, so I can match it; a generic example might not help you much
12:19:17 <geekosaur> @paste
12:19:17 <lambdabot> Haskell pastebin: http://lpaste.net/
12:19:26 <sqooq> my code is here
12:19:26 <sqooq> https://github.com/Cypress-the-Kinaesthetician/Goulds-Mark
12:19:37 <sqooq> go to src/Parser
12:19:51 <sqooq> actually hold on
12:20:03 <pikajude> i've just created a program that's like stylish-haskell for cabal files
12:20:06 <pikajude> would anyone be interested in trying it out
12:21:02 <geekosaur> https://github.com/Cypress-the-Kinaesthetician/Goulds-Mark/blob/master/src/Parser.hs#L226 is this what you want to make changeable?
12:21:03 <sqooq> geekosaur, i would have to rework things. I lied it's not as simple as removing a composition but I can make it that way.
12:21:12 <sqooq> yes
12:21:20 <geekosaur> although, seems llike housekeeping finally reached this part of the building so I may vanish abruptly :/
12:21:27 <geekosaur> ("just a minute please" is not a thing...)
12:21:37 <sqooq> that's fine
12:22:30 <sqooq> right now it's like in testing form
12:22:42 <sqooq> really i would have to switch out quite a few function
12:24:13 <iqubic> Bottom is weird.
12:24:25 <iqubic> > fix id
12:24:31 <lambdabot>  mueval-core: Time limit exceeded
12:24:49 <iqubic> > fix (id 5)
12:24:52 <lambdabot>  error:
12:24:52 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M713643997305...
12:24:52 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
12:25:02 <iqubic> > fix id 5
12:25:08 <lambdabot>  mueval-core: Time limit exceeded
12:26:21 <iqubic> Fix is a funny beast.
12:30:13 <orzo> just think of it as a looping control structure
12:31:06 <c_wraith> In fact, think of it as *the* looping control structure.
12:31:21 <c_wraith> It's an abstraction of general recursion.
12:32:18 <orzo> it was years ago, but once improved performance by using fix rather than simple recursion
12:32:37 <c_wraith> > fix (\x loop -> if x == 0 then 1 else x * loop (x - 1)) 5
12:32:40 <lambdabot>  error:
12:32:40 <lambdabot>      • Occurs check: cannot construct the infinite type: t ~ t0 -> t
12:32:40 <lambdabot>        Expected type: t0 -> t
12:32:41 <orzo> so ghc, at least at the time, seems to prefer it
12:33:05 <orzo> c_wraith, arguments are reversed
12:33:06 <iqubic> orzo: How does one use fix as a looping construct.
12:33:12 <c_wraith> > fix (\loop  x-> if x == 0 then 1 else x * loop (x - 1)) 5
12:33:16 <lambdabot>  120
12:33:19 <c_wraith> orzo: yeah, I figured it out
12:33:22 <c_wraith> iqubic: like that
12:33:39 <iqubic> How does that work?
12:34:22 <jakub_> how are instances selected in haskell? at compile time? how does someone debug the reasons why some instances are / aren't picked?
12:34:44 <orzo> don't give the compiler much choice
12:34:46 <c_wraith> iqubic: The lambda represent an "open" version of factorial.  That is, instead of being recursive, it just hands off to some function passed as its first argument
12:34:51 <orzo> avoid overlapping instances
12:35:00 <Philonous> jakub_, They are selected at compile time, yes. 
12:35:00 <c_wraith> jakub_: don't use overlapping or incoherent instances.
12:35:12 <iqubic> jakub_: What issues are you having? Can I see the code?
12:35:29 <iqubic> but c_wraith, how does the recursion happen?
12:35:36 <c_wraith> iqubic: fix "closes" the definition, but passing the function to itself
12:35:42 <iqubic> I see.
12:35:44 <c_wraith> *by
12:35:57 <iqubic> And how does fix terminate the computation?
12:36:06 <jakub_> iqubic: i will have to make a gist of it, its rather complicated and i doubt most part are relevant to the problem, i will come back with code later :)
12:36:08 <c_wraith> It doesn't.  The lambda does that by not recursing.
12:36:59 <iqubic> Oh, I see.
12:37:16 <iqubic> @src fix
12:37:16 <lambdabot> fix f = let x = f x in x
12:37:47 <iqubic> OH, I see how that works.
12:38:02 <iqubic> Why does the loop argument have to come first?
12:38:19 <orzo> because of the way currying works
12:38:21 <c_wraith> :t (\loop  x-> if x == 0 then 1 else x * loop (x - 1))
12:38:23 <lambdabot> (Num t, Eq t) => (t -> t) -> t -> t
12:38:33 <c_wraith> iqubic: that's how you make the types line up :)
12:38:43 <orzo> a two argument function is actually a single-argument function that returns a function
12:38:53 <iqubic> orzo: I see that.
12:39:03 <orzo> so fix accepts a single argument function
12:39:13 <c_wraith> iqubic: you unify (a -> a) with ((t -> t) -> (t -> t)), and get fix :: ((t -> t) -> (t -> t)) -> (t -> t)
12:39:16 <orzo> if you give it a two-argument lambada, you're using currying
12:40:15 <c_wraith> orzo: the only way I can ever imagine fix being a performance win is if your general-recursion version missed tying a knot that the fix definition does tie, so used more memory
12:42:09 <c_wraith> Hmm.  that's not fully true.  since you pass non-recursive things to fix, the optimizer can be more aggressive with them without the loop-breaker nonsense.  That's also an avenue for better optimization, potentially
12:43:48 <pgiarrusso> c_wraith: that can actually matter a lot
12:43:58 <orzo> shrug, it's usually not hard to compare a fix-based version, so just keep it in mind when optimizing
12:44:35 <pgiarrusso> I forget details/source, but I've had GHC completely optimize away an interpreter (for a given source program), but only once some recursion was replaced via fix
12:45:36 <c_wraith> that sounds like a ridiculous amount of inlining/simplification.  That also sounds pretty cool.
12:45:53 <monochrom> Tomorrow's news headline all over Hacker News: GHC -O2 optimizes away all of GHCi. >:)
12:47:47 <pgiarrusso> well, GHC *does* remove interpretative overhead, doesn't it :-)
12:48:34 <pgiarrusso> it was a pretty academic example, but GHC still acted as a (Jones-)optimal partial evaluator on that interpreter, which was fun :-)
12:49:34 <Lazersmoke> is there a way to make haddock link to the documentation for the unit type () ? I tried '()' and it just left it with the single quotes in the generated docs
12:50:32 <c_wraith> Lazersmoke: haddock only really documents definitions, and () doesn't have a definition in Haskell source, because it's syntactically special.
12:50:42 <Lazersmoke> rip
12:50:55 <pikajude> it's data () = ()
12:51:08 <monochrom> https://mail.haskell.org/pipermail/haskell-cafe/2013-April/107775.html
12:51:17 <Lazersmoke> [()](https://www.youtube.com/watch?v=dQw4w9WgXcQ)
12:51:20 <Lazersmoke> :P
12:52:12 --- mode: ChanServ set +o monochrom
12:52:21 --- mode: monochrom set -o monochrom
12:52:59 <Tuplanolla> I recognize that heat differential.
12:56:57 <zen_> hey, does anyone know how to get a Data instance for `Cofree`?
12:57:42 <lyxia> why do you want that
12:58:08 <zen_> I'm trying to build a quasiquoter for an Ast I have in Cofree
13:01:32 <jle`> you can use standalone deriving i suppose, if orphan instances aren't a conern to you
13:01:46 <zen_> I've been trying that without much luck though
13:02:01 <zen_> orphan instances aren't an issue since this is for test helpers
13:02:21 <jle`> what do you mean by not much luck
13:02:42 <jle`> did you try to compile it?
13:02:54 <zen_> it doesn't derive
13:02:57 <zen_> yea
13:03:01 <jle`> is there a compile error?
13:03:04 <zen_> yea
13:03:07 <jle`> what is the error?
13:03:11 <lyxia> Cofree seems especially the kind of type where Data is the wrong approach
13:03:21 <zen_> that's my suspicion^
13:03:47 <zen_> error is about undecidable instances
13:04:03 <zen_> because you need to add a `Data (f (Cofree f a))` constraint
13:04:16 <jle`> did you turn on UndecidableInstances
13:04:39 <zen_> no, im not sure what the implications to that extension are
13:04:44 <jle`> try turning it on
13:05:02 <zen_> well it builds now :| idk _what_ it's doing though
13:05:21 <jle`> found your luck :)
13:05:34 <zen_> haha
13:05:36 <lyxia> What is the relation between the quasiquoter you want to write and the Data instance you are trying to define
13:06:06 <zen_> I need to lift the parsed AST to a `Q Exp`
13:06:16 <zen_> and `liftData` seems to be the method to do that
13:07:28 <lyxia> use DeriveLift https://hackage.haskell.org/package/template-haskell-2.12.0.0/docs/Language-Haskell-TH-Syntax.html#t:Lift
13:07:54 <Lazersmoke> Why do some people do NoImplicitPrelude, and then import an array of highly specific things from the Prelude? Like this: https://github.com/IxpertaSolutions/freer-effects/blob/master/src/Control/Monad/Freer/Internal.hs#L79
13:08:05 <lyxia> though you might need the undecidable instance anyway
13:08:11 <zen_> lyxia: wow that seems nicer
13:09:39 <lyxia> Lazersmoke: that way it is clear what identifiers are in scope and where they come from
13:10:47 <Lazersmoke> is there really any reasonable chance someone won't know where `fmap`, `Left`, or `(.)` came from and what they mean, though? Just seems kinda over the top. The idea is sound, but taking it to this extreme just feels weird :S
13:10:51 <zen_> is there any way to prevent orphan instances from leaking out of a module?
13:10:56 <zen_> does controlling the export list do that?
13:11:16 <c_wraith> there is no way to not export instances
13:11:27 <cocreature> that’s one of the reasons why orphan instances are bad
13:11:46 <monochrom> Instances are always exported and transitively exported too.
13:12:01 <Lazersmoke> you should always make a newtype or data if you want to write instances of existing types
13:12:08 <zen_> cool I'll just move the module into my test package
13:12:59 <kuribas> how would you test binary file reading/writing?  Types will not prevent wrong offsets, etc...
13:13:06 <kuribas> check it against an external library?
13:14:00 <zen_> property testing?
13:14:11 <kuribas> zen_: how?
13:14:15 <zen_> you could test that `decode . encode = id`
13:14:32 <zen_> https://hackage.haskell.org/package/hedgehog
13:15:00 <kuribas> zen_: that's one test I could do.  It wouldn't work when both the decode and encode are wrong though...
13:15:16 <zen_> it would give you a minimal failing counter example
13:15:19 <zen_> to help debug
13:15:33 <monochrom> When you said "test" you already gave up perfection, no? :)
13:15:52 <monochrom> All tests wouldn't work if the model answers were wrong, too.
13:15:53 <zen_> you can use a combination of property based tests + unit tests
13:16:31 <zen_> ie if you have a known example of valid data from other lib or RFC you can use that and test your impl against it
13:16:39 <iqubic> Are there any good Haskell test frameworks?
13:16:46 <zen_> i use hspec personally
13:17:07 <zen_> I like `hspec-discover`
13:17:14 <kuribas> monochrom: well, the file format itself isn't perfect (truetype), so my library cannot be either...
13:17:20 <iqubic> Not quickcheck?
13:17:51 <zen_> hedgehog is a bit nicer that quickcheck imo
13:18:01 <kuribas> zen_: cool, I'll check it out
13:18:05 <zen_> it's definitely newer and shinier
13:18:47 <kuribas> is running against an external program considered un-haskelly?
13:19:03 <zen_> what do you mean?
13:19:23 <zen_> are you trying to test an external program in haskell?
13:19:42 <kuribas> zen_: no, just validate the binary output using an external program.
13:19:50 <kuribas> like: https://github.com/Microsoft/Font-Validator
13:19:50 <monochrom> You can and should handcode a few examples of the binary format and what those examples should decode to. (And/or vice versa.) This is in addition to round-trips such as decode.encode
13:20:16 <kuribas> hm, okey
13:20:18 <cocreature> if you’re interested in matching the behavior of an external program, then sure test against it
13:20:32 <monochrom> Also handcode some wrong byte sequences and see if the decoder successfully flag them as erroneous.
13:20:36 <dsal> quickcheck is super nice for this sort of thing.
13:20:48 <kuribas> then the tests can only be run when the user has the external program.
13:21:27 <cocreature> well nobody is forced to run your tests
13:21:43 <zen_> as cocreature said, if you're trying to test against microsoft's standards then use their validator
13:21:54 <zen_> that seems totally reasonable
13:22:00 <dsal> Being able to run a battery against the reference implementation is nice.
13:22:26 <kuribas> right, I can separate tests which require the external program, and ones which don't.
13:22:35 <dsal> I had a CRC thing to do and just had quickcheck generate me 1000 inputs and exported those to my other implementation and harvested the values and pulled them back in.  That's fine for something so simple and static.
13:22:40 <zen_> ^ and validate whether the program is available before running
13:23:56 <kuribas> dsal: yes sure.  But truetype is hardly simple...
13:25:18 <kuribas> dsal: Microsoft and Apple don't even agree on many points.
13:26:01 <kuribas> dsal: which is why fonts are often distributed separately for Apple and Microsoft.
13:27:21 <zen_> are you implementing a TT parser?
13:27:58 <kuribas> zen_: yeah.  Well, opentype
13:28:20 <zen_> cool!
13:30:03 <kuribas> zen_: I want to make a compiler from metafont to opentype variable fonts.
13:30:41 <kuribas> zen_: or a metafont DSL in haskell.
13:31:51 <zen_> I didn't know about metafont
13:32:01 <zen_> is it widely used?
13:32:26 <kuribas> zen_: not really
13:32:45 <geekosaur> tex/latex, basically
13:32:55 <kuribas> zen_: the TeX font, and also the fonts from lilypond
13:33:13 <geekosaur> although it's vaguely useful as a common vector font source format that can be translated to other formats
13:33:59 <zen_> still seems like a fun challenge
13:34:01 <kuribas> geekosaur: well, currently metafont can only generate bitmaps.
13:34:18 <kuribas> currently meaning the last 40 years :)
13:34:47 <kuribas> zen_: yeah
13:35:29 <geekosaur> mm, I am remembering things that generated truetype from metafont, and not simply as bitmaps reencoded
13:36:14 <kuribas> geekosaur: well, there are programs that trace the bitmaps generated from metafont, and programs that actually use metapost, which doesn't implement the full metafont language.
13:36:38 <kuribas> geekosaur: the autotraced font have artifacts, and need to be cleaned up.
13:37:36 <kuribas> but metafont uses just bezier curves under the hood, so it can be done.
13:37:41 <kuribas> Just nobody did it.
13:43:12 <orzo> anyone have experience with GHC.TypeLits naturals?
13:43:18 <orzo> i find them pretty hard to use
13:44:07 <orzo> Typically, with type-level naturals, people define recursive code over the peano structure
13:44:17 <orzo> i don't know how to do the equivelent with the + and - type functions
13:44:41 <orzo> if it's possible, i'd really like to see how it's done
13:45:35 <orzo> I could always roll my own, but i really like being able to use numeric literals in the types
13:46:06 <jle`> orzo: GHC.TypeLits are just types for literals
13:46:09 <jle`> like literal ints
13:46:20 <jle`> there's a type for the 0 literal, the 1 litera, the 3 literal, etc.
13:46:29 <jle`> there is no internal structure
13:46:36 <jle`> it's basically like data Nat = 0 | 1 | 2 | 3 | 4 | ...
13:46:45 <jle`> (just like for Int, for instance)
13:47:06 <jle`> like for Int, ghc provides +/-/* as primitives of Int's public API
13:47:11 <jle`> and it's the same case for Nat
13:47:16 <orzo> is there a way to add the structure using extra foo while still using the literals?
13:47:24 <jle`> that's a different type
13:47:40 <orzo> maybe i could make a mapping to peano types
13:47:48 <orzo> and use the literal in the exported type
13:47:48 <jle`> yeah, similar to how you'd do it at the value level
13:48:00 <jle`> you can make a value-level peano type, and define an Int -> MyPeano function
13:48:22 <jle`> you can do the same thing at the type leve -- create a type-level peano, and write a Nat -> MyPeano type family
13:48:27 <geekosaur> orzo, did you notice https://github.com/konn/ghc-typelits-presburger#readme ?
13:48:51 <jle`> but yes first you should consider if you "really want" peano nats
13:48:58 <jle`> usually you don't
13:49:16 <jle`> peano nats are a tool to solve certain problems, they aren't usually a goal in and of themselves
13:49:38 <jle`> "i find them pretty hard to use" => "can i turn them into peano nats" seems like a funny way of thinking
13:50:02 <orzo> uh, i'm having to repeat a bunch of code, i have to do something for 0, and then something else for 1 2 and 3, and i'd rather not have to repeat the 1 2 and 3 cases
13:50:15 <orzo> seems like peano is what i'd want
13:50:26 <EvanR> not to mention 4
13:50:31 <jle`> well, what problem are you actually trying to solve?
13:50:32 <orzo> well, i don't actually need 4
13:50:39 <orzo> but if i did, then yeah, even more peano
13:50:47 <EvanR> then... youre talking about Fin 4, not Nat
13:50:52 <EvanR> 0 1 2 and 3
13:51:11 <jle`> my "XY problem" senses are tingling
13:51:30 <orzo> I'm doing onion routing, the number of cryptographic wraps is indicated in the type.  Theoretically 4 makes sense, but i'm going up to 3 layers tops
13:53:00 <orzo> i think nat is a better fit than Fin 4
13:53:43 <jle`> if you are using things to model some sort of inductive structure (like successive wrapping), peano nats might make sense
13:54:02 <orzo> yes
13:54:06 <jle`> you can provide type synonyms for 0/1/2/3/4
13:54:36 <jle`> you can write a Nat -> MyPeano type family as well, but GHC can't be used to prove properties about your Nat -> MyPeano
13:54:45 <jle`> it's basically 'FromInteger'
13:54:58 <jle`> in fact, the singletons library exports a promoted Num class with FromInteger
13:55:30 <jle`> 'FromInteger' meaning from Nat, of course, heh
13:55:45 <jle`> and you can use 'FromInteger 3', if you really really wanted to re-use Nat literals
13:56:08 <jle`> but if you really only are using 0/1/2/3, you can probably do just as well by exporting type synonyms for Z, S Z, S (S Z), and S (S (S Z))
13:57:26 <jle`> type-level literals are not polymorphic in the sense that value-level numeric literals are; you just have to manually fromInteger things if you want to use them to describe your custom type.
13:57:47 <orzo> I can't make synonyms that are the actual literals 0, 1, 2, 3, can I?
13:58:23 <orzo> You're saying One, Two, Three, or something
13:59:28 <orzo> file:///usr/share/doc/libghc-vec-doc/html/Data-Vec-Nat.html#t:N1
13:59:34 <orzo> oops
13:59:35 <orzo> sorry
14:00:23 <orzo> anyway, you're suggesting what Data.Vec.Nat does
14:01:34 <orzo> do people not want teh TypeLits nats to be peano structured?
14:01:50 <jle`> not where what Data.Vec.Nat is, but yeah, type N0 = Z, type N1 = S Z, type N2 = S (S Z)
14:01:56 <orzo> i mean, is there an advantage to the way it is
14:02:18 <jle`> well, that's like asking if you want numeric literals to come from value-level peanos
14:02:39 <jle`> then if you ever wrote 10000000 in code, you'd have to construct 10000000 in memory and then fromPeanoize that
14:02:43 <monochrom> Yes, like Roman vs Indo-Arabic notation.
14:02:44 <geekosaur> it also occurs to me that type level peano is likely rather hard on the typechecker
14:03:00 <jle`> `Integer` isn't the perfect choice but it's probably the best choice
14:03:23 <jle`> Integer is nice because it is decently memory-efficient and assumes very little about structure
14:03:49 <monochrom> While type-level Peano probably doesn't slow down your final exe, it probably takes forever to compile. But perhaps an xkcd shows why you positively want that.
14:04:02 <jle`> peano nats are only useful if you're doing some sort of structural induction, but really, that doesn't happen too often
14:04:17 <sqooq> ugh :(
14:04:18 <geekosaur> I mean, it didn't take long after people started doing Peano Nats that people started making packages to work with larger values without having to do e.g. 1500 Ss
14:04:38 <geekosaur> (but the typechecker still had to...)
14:04:56 <monochrom> I read a joke about the formal elegance of Roman numerals. "Addition is just formal concatenation!"
14:04:59 <jle`> i suppose you could say that peano nats were the first number system in a sense, until people realized that there were better ways to do things (roman numerals => indo-arabic numerals)
14:05:19 <jle`> since peano nats aren't really useful for anything except for structural induction
14:05:33 <monochrom> As for the inefficiency in multiplication and division, "That's why we have slaves!"
14:06:00 <geekosaur> um, they figured out actual numbers and actual math well before roman numerals
14:06:15 <jle`> to write things, i suppose i meant
14:06:24 <jle`> and... i did skip some steps >____>
14:06:50 <geekosaur> https://www.sciencedaily.com/releases/2017/08/170824141250.htm
14:06:54 <jle`> orzo: a semi-sensible proposal would be to make type-level literals polymorphic, like value-level literals are, but i'm not sure about the usability issues for that
14:07:23 <hpc> kind-level type classes?
14:07:26 <jle`> even if they are polymorphic, a structureless Nat type probably would be the way to go there, like for Integer for value-level literals
14:07:28 <orzo> Would it break the type system to allow code that enables peano-style instances, such as special casing the (1 +) type function for class instantiation?
14:07:32 <jle`> hpc: kind-classes, and that's a thing :)
14:07:35 <sqooq> geekosaur: you still willing to help me?
14:07:50 <Tuplanolla> On the topic of Roman numerals, is there a nicer way to define such a system? It would take less digits for XVIII to be XIIX for example.
14:07:51 <geekosaur> sqooq, willing but not necessarily able...
14:07:54 <jle`> orzo: you can already write peano-style types
14:07:56 <monochrom> geekosaur: Counter blog: https://blogs.scientificamerican.com/roots-of-unity/dont-fall-for-babylonian-trigonometry-hype/ :)
14:08:20 <monochrom> TL;DR: It is that "rational trig" guy again.
14:08:31 <jle`> singletons does something similar by promoting Num to the type level with a Num kindclass
14:08:34 <geekosaur> Tuplanolla, the Hebrew system didn't do the backwards stuff
14:08:43 <sqooq> aw man lpaste doesn't wrap?
14:08:45 <geekosaur> I think the only thing the Roman system had going for it was less carving
14:08:51 <jle`> and it lets you define your own (+)/(*)/FromIntegral/etc.
14:09:02 <jle`> it's all very possible in the same way that it's done at the value level
14:09:13 <sqooq> http://lpaste.net/358206
14:09:18 <sqooq> i tried my best
14:09:19 <orzo> it doesn't let you have literals though, does it?
14:09:21 <sqooq> to put it into one thing
14:09:44 <sqooq> but I'm thinking it's even more complex, because I can have multiple input files too, at which point the function would change once again
14:10:01 <sqooq> an executable has got to be the way to go about this
14:10:07 <Tuplanolla> I have a hunch we could have a Roman-like numeral system that's NP-complete, the way addition chain problems are.
14:10:19 <Tuplanolla> That would be great.
14:10:38 <jle`> orzo: you'd have to (FromIntegral) your literals
14:11:03 <jle`> but i'm saying that a semi-sensible suggestion would be to have litearls be 'automaticalyl fromIntegral'd
14:11:03 <monochrom> Tuplanolla: Haha neat. Perhaps the subset-sum problem with help.
14:11:15 <jle`> just like how value-level literals are "automatically fromIntegral'd"
14:11:45 <geekosaur> monochrom, that's more or less why I linked to the SD one, the headline was a bit lurid but the content was more circumspect and in fact looked at possible uses (which were fairly pedestrian, e.g. surveying plots)
14:11:46 <jle`> like 7 is sugar for (fromIntegral (7 :: Integer)), maybe one day 7 at the type level would be sugar for (FromNat (7 :: Nat))
14:11:58 <jle`> but i'm not sure about the usability/type checker implications
14:12:01 <geekosaur> and agreed that "trig table!" was stretching it
14:13:45 <orzo> jle`: TypeLits already exports (+) though, so instead of a conversion, ghc could just be made to know more about the special type function (+) exported by typelits
14:14:04 <orzo> meaning, structure is implicit in those type functions
14:14:17 <monochrom> I have a better conjecture. The Babylonians were trying to figure out screen diagonal lengths and aspect ratios for us. :)
14:14:20 <jle`> orzo: i mean that (+) would also be poylmorphic
14:14:35 <jle`> and every instance would be able to define its own (+)
14:14:53 <jle`> (+) in TypeLits is specifically (+) for Nat
14:14:55 <jle`> and only for Nat
14:15:15 <orzo> okay, but it's not neccessary to do this only to get the ability to define recursive code
14:15:50 <jle`> (+) exported by typelits is for Nat, which is has no structure
14:15:50 <orzo> the current Nat type does have more structure than you claimed because (+) 
14:15:59 <jle`> it doesn't, actually; (+) is opaque
14:16:07 <hpc> monochrom: fun fact: the rosetta stone is actually a critique of the academy ratio
14:16:34 <jle`> so, for instance, the polymorphic type `(n + m) + o` is not the same as `n + (m + o)`
14:16:51 <orzo> is that a feature?
14:16:56 <jle`> because one is `(+) ((+) n m) o`, and the other is `(+) n ((+) m o))`
14:17:03 <jle`> completely different trees to GHC
14:17:09 <monochrom> Yeah, GHC does not know algebra yet. It doesn't even know n+1 >= n.
14:17:17 <jle`> well, TypeLits is not meant to be used directly
14:17:27 <orzo> but you say "yet"
14:17:38 <jle`> it's meant to basically provide raw low-level ghc hooks so that other libraries can use it to implement actual useful things
14:17:50 <jle`> it's basically an "internal" library
14:17:51 <sqooq> I'm thinking I really should just fudge midi
14:18:00 <monochrom> You can go out of your way to write a whole suite of classes and families that teach algebra to GHC.
14:18:09 <jle`> other libraries *can* normalize expressions like the ones i gave, and unify them
14:18:26 <jle`> and other libraries do have a more fully-featured interface for type-level numerals
14:18:36 <jle`> those libraries are where you're supposed to get your actual functionality
14:18:55 <jle`> and those libraries need GHC.TypeLits as an internal module to provide primitives to let them implement their functionality
14:19:52 <jle`> really, GHC.TypeLits isn't meant to be used by any end user
14:20:23 <orzo> it's numeric literals you're talking about.  If you want people to think of them as internal, they should be given ugly internal looking names
14:20:40 <sqooq> any music haskellers in here?
14:20:51 <jle`> i'm talking about (+) etc.
14:20:53 <jle`> and its lack of structure
14:21:03 <sqooq> My daw of choice has an osc implementation, which if i'm not mistaken is superior to midi, especially for microtonal music.
14:21:21 <monochrom> Yikes microtonal.
14:21:30 <sqooq> more like Yummy, microtonal
14:21:34 <orzo> (+) is likely going to be more featureful in the future though, like monochrom pointed out, n+1 >= n will is intended to be sensible eventually
14:21:38 <monochrom> Like you want 0.05 Hz above concert A? :)
14:22:01 <jle`> `n + 1 >= n` is already sensible with external libraries
14:22:08 <sqooq> monochrom: the real "Yikes" is that midi is forcibly diatonic, unless you instantaneously bend every note played to the right note.
14:22:14 <jle`> it wouldn't be coming from GHC
14:22:19 <sqooq> or forcibly chromatic, pardon
14:22:32 <jle`> it'd be coming from the high-level libraries you use to work with (+) etc.
14:23:53 <sqooq> hmm 5 different osc libraries. Wonder which will be the one to use.
14:24:04 <jle`> it might be nice to imagine ghc offering fully-featured type level numeral functionality, but it has apparently been decided that this should be left up to high level libraries and the haskell ecosystem
14:24:34 <jle`> though i'm not sure if i 100% agree with this approach
14:26:02 <orzo> is FromIntegral going to happen also?
14:26:11 <orzo> polymorphic numerals
14:26:45 <jle`> polymorphic literals sounds something that would be nice to explore, but i'm not sure if there's any current discussion on this :'(
14:27:00 <jle`> but yeah, polymorphic literals would have to be something decided on the GHC end
14:28:50 <jle`> for now we're stuck with monomorphic literals, though people do use template haskell to fake polymorphic literals
14:28:59 <orzo> literal-envy will make it inevitable probably
14:29:22 <jle`> yes, since haskellers are accustomed to polymorphic numeric literals to drive a lot of useful APIs
14:33:53 <`Guest00000> is haskell ambiguous?
14:34:04 <monochrom> What do you mean?
14:34:27 <`Guest00000> is there a program which parses to two different ASTs
14:34:37 <monochrom> I think no.
14:34:39 <Tuplanolla> No.
14:34:47 <orzo> yes, it could be the person Haskell Curry, or it could be a computer language
14:34:53 <monochrom> Haha.
14:35:11 <monochrom> There is also a town.
14:35:26 <hpc> haskell curry's first, last, and middle names are all languages
14:36:46 <EvanR> theres also a recipe
14:37:14 <hpc> the purely functional dish
14:37:30 <orzo> sounds nutritious
14:39:52 <geekosaur> `Guest00000, Haskell98 was reported to have an infelicity in translation of layout that allowed two different compilers to interpret certain (very rare) constructs differently. This was corrected in haskell2010
14:40:31 <geekosaur> but it took considerable trickery to come up with something that would reproduce it, iirc
14:41:39 <jle`> sometimes when i search for the #haskell tag on twitter
14:41:45 <jle`> i get results for the university
14:41:54 <jle`> and sometimes for a jewelry company
14:43:49 <geekosaur> and given my search habits, rugby is another possibility
15:00:47 <maerwald> is it good jewelry at least?
15:12:43 <augur> is there a library function for something like   Maybe a -> MaybeT m a   ?
15:16:48 <c_wraith> augur: doesn't look like it.
15:17:48 <augur> probably it should be something like    (MonadTrans t, Monad m) => t Identity a -> t m a
15:17:53 <iqubic> That sounds like a comonadic operation.
15:18:43 <mniip> monadic actually
15:19:02 <mniip> augur, hoist return?
15:19:45 <augur> hoist?
15:20:02 <c_wraith> hoist generalize, actually.
15:20:16 <iqubic> what's hoist???
15:20:33 <c_wraith> But that doesn't work with MaybeT, because Maybe isn't defined as MaybeT Identity
15:20:51 <mniip> :t MaybeT . return
15:20:53 <lambdabot> error:
15:20:53 <lambdabot>     • Data constructor not in scope: MaybeT :: m0 a -> c
15:20:53 <lambdabot>     • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
15:20:55 <c_wraith> iqubic: https://hackage.haskell.org/package/mmorph-1.1.0/docs/Control-Monad-Morph.html#v:hoist
15:21:16 <mniip> :t Control.Monad.Trans.Maybe.MaybeT . return
15:21:18 <lambdabot> Monad m => Maybe a -> Control.Monad.Trans.Maybe.MaybeT m a
15:21:45 <c_wraith> mniip: yes, that's always been the fallback.  The question has always been why isn't that named?
15:23:52 <mniip> hoistEither sugests it should be named hoistMaybe
15:27:44 <tomasmu> i'm doing some functional programming challenges, and have gotten to lambda calculus, reduction and evaluating expressions
15:27:59 <iqubic> tomasmu: Need help with that?
15:28:11 <tomasmu> wondering if i should read up on lambda calculus or not.. is it important? interesting? useless? =)
15:28:20 <jle`> augur: i use (maybe empty return)
15:28:20 <iqubic> I can help you. I know a thing or two about lambda calculus.
15:28:23 <jle`> cause semantics and stuff
15:29:11 <`Guest00000> why is <|> infixl?
15:29:46 <iqubic> So it can short circuit I assume.
15:30:04 <tomasmu> iqubic: i've only heard the name before, so i'm currently beyond helpable ;D
15:30:04 <c_wraith> that requires infixr, actually
15:30:26 <`Guest00000> hmm
15:30:34 <tomasmu> iqubic: would it help knowing it if i want to get proficient in haskell some day?
15:30:48 <`Guest00000> c_wraith: no, (something <|> true)
15:31:22 <`Guest00000> ((smth <|> smth) <|> smth) <|> true
15:31:26 <c_wraith> `Guest00000: that should never short-circuit.
15:31:45 <c_wraith> `Guest00000: Alternative instances should be biased to the left side.
15:31:49 <iqubic> tomasmu: You don't need to know Lambda Calculus to get good at Haskell.
15:32:26 <orzo> yeah, i'm curious why (<|>) is infixl too now
15:32:49 <c_wraith> orzo: it's a great mystery
15:32:59 <jle`> i suppose it shouldn't matter, since it's associative anyway
15:33:41 <`Guest00000> well, if you have 30 subexpressions delimited by <|>
15:34:09 <c_wraith> `Guest00000: consider combining them with foldr (<|>) instead. :)
15:34:25 <tomasmu> iqubic: m'kay, then i'll only look it up and not learn too much of it ;D
15:34:31 <`Guest00000> but why can't <|> just be infixr
15:34:53 <jakub_> iqubic: i gave up on minimizing my example program, but what happens when an instance of one class relies on another class? is an instance of the latter picked statically
15:35:16 <`Guest00000> what's good from <|> being infixl?
15:35:19 <jakub_>  iqubic: or is the choice deferred until a all types are instantiated for the former instance?
15:36:17 <jakub_> iqubic: as in: class C c; instance C A; class D d; instance C a => D a where ...
15:37:02 <iqubic> I'm not sure. I'm not the right person to ask.
15:37:12 <Philonous> jakub_, instance C a => D a means you have an instance for _every_ type D
15:37:23 <Philonous> No matter if D is actually an instance of C or not
15:37:39 <Philonous> It will then go and try to find an instance of D 
15:37:47 <Philonous> And possibly not find it, in which case you get an error
15:38:06 <Philonous> Sorry, I meant an instance of D for every type a
15:38:25 <Philonous> And whether a is an instance of C or not
15:38:59 <orzo> yeah, basically it doesn't use the constraint when resolving the instance, only when verifying
15:39:20 <Philonous> Damn, I messed that one up pretty well :> 
15:40:51 <Philonous> OK, again, It means you have an instance of D for every type a, regardless of whether a is an instance of C, and it will look for C-instances of a after that and give you errors if it doesn't find them 
15:45:00 <orzo> jakub_: try to wrap your head around this, https://stackoverflow.com/questions/17863332/what-contraint-is-no-smaller-than-the-instance-head-means-and-how-to-solve-it
15:45:27 <orzo> the answer there gives some insight into instance solving
15:46:27 <jakub_> Philonous: i still dont know what happens... say i have a specific type A i get its instance of class D, that tries to use something from class C, is a specific instance already preselected by the instance chosen for D or is an instance of C selected with the knowledge of the exact type A
15:47:39 <jakub_> it seems to me that its the preselected (ie instance of D is fixed for ale types matching
15:48:15 <Philonous> jakub_, That can't be. Consider as an example Eq and Ord. Ord depends on Eq, but the concrete instance for Eq depends on the the type
15:48:25 <Philonous> I.e. (==) is something different for Bools than for Ints
15:48:48 <jle`> ooh
15:48:58 <jle`> new "Quick Jump" link for hackage docs
15:49:07 <jle`> who is making all these hackage/haddock changes
15:49:10 <jle`> they're amazing
15:49:15 <orzo> what's the quick jump?
15:49:18 <jle`> Fuuzetsu do you know who is responsible
15:49:38 <jle`> check out http://hackage.haskell.org/package/lens
15:50:05 <jle`> at the end of the module list
15:50:09 <Philonous> jakub_, Also, you can define A's instance of of C however you like, and that's the instance that will be used if you call it's methods in methods of D (or anywhere else)
15:50:45 <Philonous> I.e. you can define Eq on A however you fancy, and the Ord instance will use the (==) you defined
15:51:27 <Gurkenglas> Too bad you can't open quick jump from source pages
15:52:29 <verement> We have package ratings now too, though I'm not entirely sure how that works.
15:54:09 <jakub_> Philonous: my setting involves overlapping instances may that change things?
15:54:39 <Philonous> jakub_, Yes, when instances overlap, the "most concrete" one is chosen AFAIK.
15:54:46 <Philonous> I can't tell you exactly what that means though
15:54:47 <jakub_> it seems to pick the most generic instance for the referenced
15:55:29 <Philonous> jakub_, Really? I would have thought the opposite. 
15:55:40 <Philonous> But that's not something I know for certain, sorry
15:56:31 <orzo> overlapping instances are usually avoided
15:56:44 <orzo> it's not something to enable routinely
15:56:47 <jakub_> orzo: yeah i know, not very useful when i need them
15:57:09 <jakub_> i am trying to do something with datatypes ala carte which require overlapping instances
15:57:48 <Philonous> jakub_, Do keep in mind that each type can be an instance of each class in at most one way, though. So there's at most one C-instance of (and a C-dictionary for)  A. 
15:59:28 <Philonous> I need to go sleep though. 
16:00:11 <orzo> the reflection package offers a handy way to use type class based apis without hard wiring instances
16:22:42 <`Guest00000> okay, haskell is unambiguous as whole
16:22:58 <`Guest00000> but some of its lexical things is
16:23:37 <`Guest00000> namely, newline
16:26:04 <`Guest00000> this presents a question as to how i should organize my parser
16:36:50 <Cale> `Guest00000: hm?
16:37:26 <Cale> `Guest00000: The Report contains a description of how to translate whitespace into braces and semicolons
16:37:55 <trevortknguyen[m> For real-time Haskell - what would be the difference between Atom (tomahawkins) and Copilot (Galois)? They both seem to compile to C as EDSLs. Atom seems to be for specifically embedded C (as in on a device).
16:37:57 <Cale> `Guest00000: But there exist parsers for Haskell already, see haskell-src-exts, if you don't want to write one by hand.
16:38:08 <`Guest00000> my question is, when both a and b in "a | b" succeed, what should i do
16:39:11 <`Guest00000> should i keep all backtracking
16:39:34 <Cale> `Guest00000: oh, are you referring to the newline production in the Report?
16:39:39 <`Guest00000> yep
16:40:12 <Cale> It's probably fine just to let text decoding take care of that.
16:40:44 <Cale> But it's probably enough just to use maximal munch there
16:41:24 <`Guest00000> what do i do in the general case?
16:41:25 <Lazersmoke> tfw you realize why the original maintainers abandoned the library :O
16:42:02 <Cale> `Guest00000: Depends on a case by case basis. In this case, the reason for the production being like that is that different systems have different line endings
16:46:00 <mekaskk> Hi!. I am learning to use lenses, and have the following problem: I am running within StateT, the state has lenses on it, and I want to fetch some stuff from the state to use as input to a pure function. Hence, I do something like this: a <- use A, b <- use B, let c = f a b
16:46:11 <mekaskk> Is there a more idiomatic way to do this?
16:51:40 <boj> mekaskk: what do you mean by 'a <- use A' ?
16:51:40 <pacak> f <$> use A <*>  use B
16:52:13 <boj> oh
16:52:43 <mekaskk> boj: use A applies the lens to the state
16:52:47 <mekaskk> pacak: thanks! :)
16:53:05 <boj> :)
16:55:45 <mekaskk> Oh, and the other problem I have is that f produces a bool, which I only use once, so I get a g <- f <$> use A <*> use B, if g then ... else ...
16:56:10 <mekaskk> There doesn't seem to be in control monad anything to just put it inside the if or replace that if for somethign else
16:58:05 <tsani> mekaskk: you can enable LambdaCase and do this: `(f <$> use a <*> use b) >>= \case { True -> foo ; False -> bar }
16:58:56 <pacak> :t if'
16:58:58 <lambdabot> error:
16:58:58 <lambdabot>     • Variable not in scope: if'
16:58:58 <lambdabot>     • Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
17:00:46 <mekaskk> tsani: thanks :). I think I'll just define something like ifM, seems easier
17:39:34 <Fekinox> just started messing with ST
17:40:05 <Fekinox> feels a scary lot like an imperative language
17:41:19 <monochrom> It is. What else did you expect?
17:43:14 <Axman6> but with all the safety of guaranteed purity
17:43:26 <Fekinox> going in, I thought it would be pretty scary but it turned out to be quite simple
17:43:46 <Axman6> it's IO without all the hard parts
17:46:30 <Lazersmoke> I've heard so many different versions of this: is `IO a` actually `RealWorld -> (# a, RealWorld #)` or is it something else?
17:47:32 <monochrom> "RealWorld -> (# a, RealWorld #)" is an implementation detail, and only one of many possible implementations. You should not count on it.
17:48:12 <monochrom> You should leave IO as abstract and opaque and information-hiding and encapsulated and all that OOP ideal.
17:49:09 <monochrom> But if you cannot survive with abstraction and must need a concrete model, the fictional free-monad model is superior.
17:49:59 <monochrom> (Actually IIRC there was an old version of Hugs that used a free monad for its actual implementation. So there, it is not all fictional.)
17:50:51 <monochrom> Ironically, the fictional free-monad model is less lying than the "RealWorld" model.
17:51:36 <monochrom> The very name "RealWorld" is already a lie in its own right in the first place. It is a phantom type. It totally does not contain any information about the real world out there.
17:52:28 <monochrom> For example people who claim "oh the RealWorld type could be a data structure containing file handles" are making it up. No compiler actually ever did that.
17:56:32 <monochrom> Whereas the free-monad model, although fictional in the sense that GHC and later versions of Hugs don't do it, is actually consistent with the excellent analogy of "it's a recipe" and gives you correct predictions.
18:02:13 <orzo> it doesn't seem like it'd be very hard to verify a closed type family is injective.  All the compiler would have to do is swap the left and right sides of the equalities and if it still parses, it's injective
18:02:40 <orzo> s/parses/compiles/
18:02:53 <monochrom> That's interesting.
18:03:25 <monochrom> Have you really thought it through and are ready to write a proof upon request? :)
18:04:50 <monochrom> What if the right hand side uses types from another closed type family?
18:06:47 <orzo> it'd be useful even if it doesnt cover all cases
18:07:00 <monochrom> Yeah it's neat.
18:09:19 <orzo> it could make an implied Inverse operator too
18:15:39 <thoughtpolice> orzo: I mean, in a sense, yes, the injectivity check isn't much "more" than that. The person who implemented injective type families in GHC thought something like that too, and that it would only take a week to do. It turned out to be about 5 months and a research paper. :) There are of course subtle design choices that may throw a wrench into things, for example, shadowing.
18:19:45 <thoughtpolice> "Even if it doesn't work in all cases" is tricky as well. Many design decisions may result in high complexity or poor predictability for the user, so even if it only "works" 80% of the time, it has other costs.
18:20:31 <erisco> I think I want something like  | F x -> y  as a fundep where F is a type family
18:21:11 <thoughtpolice> (As an example of injective TF's, GHC could for example just try to check injectivity on every family, regardless of whether you ask, and never rely on the programmer asking for it, but this is probably poor form and bad from a design/usability POV -- it means subtle changes might cause injectivity checks to fail in non-obvious ways, and you can't tell where you wanted the check!)
18:21:19 <erisco> but I should be able to use an additional parameter for this
18:24:54 <orzo> hm
18:25:22 <orzo> so the extension is called TypeFamilyDependencies
18:25:47 <erisco> though I kinda want dynamic dependencies
18:26:24 <erisco> | F x y z  and F produces a dependency
18:27:17 <erisco> I have where one type for x can infer y and another type for x can infer z
18:36:17 <remexre> Hi, is there a way to get stack/cabal to automatically generate hs-boot files?
18:37:31 <orzo> i don't konw, but i hear backpack is released now
18:37:58 <monochrom> Backpack doesn't auto-generate hs-boot files.
18:38:18 <monochrom> If anything, it requires you to handwrite more files. Namely, *.hsig files for signatures.
18:39:05 <monochrom> Only tangential relation with hs-boot is "signature syntax is very similar to hs-boot syntax".
18:41:54 <remexre> Actually, I might be structuring things badly, so if there's suggestions for structure, I'd accept those too:
18:41:55 <remexre> I'm making an interpreter/compiler for a Lisp with macros, so I have a dependency loop: Macros depends on Interpreter depends on AST depends on Modules depends on Macros.
18:42:57 <remexre> where Macros has a function [SExpr] -> InterpreterMonad [SExpr], Interpreter provides the InterpreterMonad, AST provides a bunch of AST types, and Modules handles loading modules from files
18:43:22 <remexre> (by doing ModuleName -> IO [SExpr])
18:44:41 <remexre> I'm using type parameters like the wiki suggests to avoid a couple of other cycles, but I can't figure a way around this, as macros need to be processed before an AST is built
18:46:53 <orzo> why does Macros depend on Intepreter
18:47:11 <orzo> is SExpr part of your AST types?
18:48:01 <remexre> Macros require being run; they're common-lisp-style, where they can perform arbitrary code
18:48:13 <remexre> And SExpr is from a separate module with no dependencies
18:48:22 <remexre> Instead it has a bunch of type parameters :P
18:50:09 <brunocaad> question: Let's say I have a datatype `Foo a` and a typeclass for pretty printing. I want to be able to print diffentially depending on what `a` is in `Foo`. Is there another way than doing a newtype?
18:50:35 <monochrom> I wonder why AST depends on Modules.
18:51:02 <remexre> That one might be a design flaw, actually
18:51:05 <orzo> instance Pretty (Foo Int) ..
18:51:06 <remexre> To process import statements
18:51:29 <geekosaur> brunocaad, make a MyShow class for each possible a with its own myShow, and a Show instance for Foo a that delegates to myShow on a
18:51:44 <geekosaur> but, you should generally not abuse Show for this
18:52:10 <geekosaur> the convention is Show produces Haskell code, and the expectation is that what Show produces, Read can consume
18:52:21 <brunocaad> it's another class than show, don't worry haha
18:53:01 <monochrom> Maybe AST can focus on the part of the syntax that doesn't talk about modules. And Modules imports AST and defines the full syntax that talks about both modules and the stuff from AST.
18:53:20 <remexre> Hm, ok
18:53:30 <remexre> I think I still have a cycle with macros then
18:53:40 <geekosaur> also, if it's only certain choices of "a" that need special handling, you can have a default implementation of myShow or whatever and only specify one explicitly if it differs from the default (you still need to declare the instance though)
18:53:47 <remexre> Unless it's the entry point to the whole thing
18:54:00 <remexre> Modules -> Macros -> Interpreter -> Modules
18:54:35 <monochrom> Aw this is why cycle enumeration is NP-hard
18:55:59 <monochrom> Actually maybe not. Nevermind.
18:56:01 <geekosaur> brunocaad, if you want to see an example of what I described, look at the definition of showList
18:56:24 <geekosaur> (which is a method of Show, and is how we show String differently from other lists)
18:58:55 <brunocaad> I can't really add new method to the class :/
18:59:25 <geekosaur> well, I did not suggest it as exactly what to use here
18:59:49 <geekosaur> I suggested you create a subsidiary prettyprinting class for which you provide instances for the various possible "a"s
19:00:08 <geekosaur> and then your prettyprint for Foo a invokes the prettyprinting method in that class on the a
19:02:09 <geekosaur> instance FooPP a => PP (Foo a) where pp (Foo v) = fooPP v -- with: class FooPP a where fooPP :: a -> Doc; and then instances as needed
19:03:38 <geekosaur> (assuming Doc is what your prettyprinter class produces)
19:03:48 <geekosaur> er, what the originaal prettyprinter class produces
19:04:18 <brunocaad> but then, I can't really diffentiate `Foo ()` from `Foo a`
19:05:01 <geekosaur> huh? hat is exactly what the subclass does
19:05:23 <geekosaur> instance FooPP () where fooPP = ...; instance FooPP Int where fooPP = ...
19:05:51 <geekosaur> and if you put a default implementation for fooPP in the class, then you can just 'instance FooPP Double' to use it
19:06:18 <geekosaur> it's the showList thing I described, but using a helper class
19:06:39 <geekosaur> so you don't have to force a new method into the original class
19:08:13 <geekosaur> you still need to provide instances for all types that occur, but (a) you can default them if you don't need specific handling (b) the compiler will tell you when you need to add such an instance
19:09:42 <geekosaur> if you truly need a catchall for all possible a-s, and special handling for just one of them, then yes, a newtype is the only way
19:11:08 <geekosaur> I mean, you can attempt to mess with overlapping instances, but that tends to end badly
19:13:06 <brunocaad> sorry, I don't get it, can you do an example for `Foo ()` (which have the special behavior) and `Foo Int` (which doesn't)?
19:14:19 <brunocaad> like in the case of `Foo ()`, it output "()" and the case of `Foo Int` it output "Foo n"
19:15:07 <geekosaur> does that really need a special case? although I guess I don't know how your prettyprinter works
19:15:30 <geekosaur> but even if you can't defer to it, that isn't a special case really because you can just defer to show for both
19:17:15 <brunocaad> my real usecase is more complicated, I'm just simplifying sorry
19:17:54 <geekosaur> well, I am necessarily simplifying as well since I do not know your use case
19:18:04 <geekosaur> anyway http://lpaste.net/358210
19:18:48 <geekosaur> the "default" in there is because the default implementation of fooPP requires a constraint the specific instance implementations don't
19:19:01 <geekosaur> I think that may require a ghc extension, it'll tell you if it does
19:19:23 <brunocaad> oooooh I get it now, it seems so simple
19:19:29 <brunocaad> thank you so much!
19:26:10 <fresheyeball> how do you compose a lens and a prism
19:26:14 <fresheyeball> with the prism on the left
19:26:16 <geekosaur> actually, forgot a step... annotated the original for how you wedge this into an existing prettyprinter class (and refactored slightly)
19:26:33 <fresheyeball> foo ^. myPrism . myLens
19:26:39 <fresheyeball> I know ^. is not right
19:26:51 <fresheyeball> how can I get a 'view' into a thing this way?
19:27:03 <Gurkenglas> fresheyeball, you get a traversal.
19:27:14 <fresheyeball> what is the view thing for a traversal?
19:27:24 <Gurkenglas> ^? gives you a Maybe-value, because the prism might miss
19:27:47 <fresheyeball> I tried that too
19:28:05 <fresheyeball> foo ^? at k . myLens
19:28:16 <fresheyeball> but no luck
19:30:15 <fresheyeball> I see lots of examples where the prism is on the right of the lens
19:30:18 <fresheyeball> but not vice versa
19:30:52 <jle`> what do you mean by no luck
19:31:02 <jle`> is it compiling, but not giving you what you want?
19:31:05 <fresheyeball> I mean, that expression does not type check
19:31:09 <jle`> thank you
19:31:41 <jle`> keep in mind that 'at k' is not a Prism
19:31:45 <jle`> it's actually a Lens
19:31:53 <fresheyeball> oh
19:31:58 <fresheyeball> I thought it was a prism
19:31:59 <jle`> you might be thinking of 'ix'
19:32:19 <fresheyeball> what is ix?
19:32:21 <jle`> (which is also not a prism, but a traversal)
19:32:38 <jle`> ix is a traversal into a given index
19:33:04 <jle`> > "hello" ^? ix 1
19:33:06 <lambdabot>  Just 'e'
19:33:13 <fresheyeball> ok let me explain better
19:33:15 <jle`> 'at k' is a lens into *Maybe*
19:33:21 <fresheyeball> I have a record like this 
19:33:27 <jle`> at lets you remove items
19:33:36 <fresheyeball> data Foo = Foo { _bar :: Int }
19:33:47 <fresheyeball> and a map like this
19:34:01 <fresheyeball> Map String Foo
19:34:20 <fresheyeball> I was hopting to use lenses to access the Int
19:34:20 <jle`> 'at k' for Map String Foo is a lens into a `Maybe Foo`
19:34:29 <fresheyeball> yes
19:34:30 <jle`> you probably want a traversal into a Foo
19:34:36 <jle`> so you'd want myMap ^? ix k . myLens
19:34:46 <jle`> you can use at, too, but you have to go "into" the Just
19:34:53 <jle`> myMap ^? at k . _Just . myLens
19:35:05 <fresheyeball> oh that worked!
19:35:09 <jle`> ix k is a traversal into Foo, at k is a lens into Maybe Foo
19:35:30 <jle`> which is why it's complaining when you compose 'at k' with myLens
19:35:42 <jle`> myLens is presumably from Foo into Int, but you're trying to use it on a Maybe Foo
19:35:51 <fresheyeball> right ok
19:36:08 <fresheyeball> so I need to learn more about traversals
19:36:24 <fresheyeball> are traversals coupled to Maybe?
19:37:28 <jle`> a lens lets you focus into exactly 1 item
19:37:37 <jle`> a traversal lets you focus into 0 or more items
19:37:57 <jle`> ^? basically gets you the first item that the traversal runs into
19:38:27 <jle`> 'ix k' really only gets 0 or 1 item, but you wouldn't be able to know that frmo the type alone, unfortunately, heh
19:40:17 <jle`> fresheyeball: traversals are more closely linked to lists -- they're more naturally used with ^.., not ^?
19:40:31 <jle`> fresheyeball: but (x ^? myTraversal) is basically listToMaybe (x ^.. myTraversal)
19:45:14 <jollygood2> hi
19:47:43 <halogenandtoast> if I have a function a -> a -> b -> b and I want to uncurry it to (a, a) -> b -> b is that possible? calling uncurry seems to give me a -> (a, b) -> b
19:48:00 <jle`> it is possible
19:48:15 <jle`> uncurriedFoo (x,y) z = f x y z
19:48:31 <halogenandtoast> sorry right, I need to make my own function though
19:49:01 <jle`> @:t let f :: a -> a -> b -> b; f = undefined in uncurry f
19:49:01 <lambdabot> Maybe you meant: wn v rc pl let id do bf @ ? .
19:49:07 <jle`> :t let f :: a -> a -> b -> b; f = undefined in uncurry f
19:49:09 <lambdabot> (a, a) -> b -> b
19:49:11 <jollygood2> was the same field names in different types issue resolved in some way? there were several suggestions floating around
19:49:24 <jle`> halogenandtoast: it seems like uncurry already gives you what you want
19:49:51 <halogenandtoast> oh I was derping
19:49:56 <halogenandtoast> I was calling (uncurry . f)
19:49:59 <halogenandtoast> lol
19:50:05 <jollygood2> :t uncurry (undefined : a -> a -> b -> b)
19:50:06 <lambdabot> error:
19:50:06 <lambdabot>     Pattern syntax in expression context: undefined : a -> a -> b -> b
19:50:15 <jollygood2> :t uncurry (undefined :: a -> a -> b -> b)
19:50:17 <lambdabot> (a, a) -> b -> b
19:50:55 <halogenandtoast> :t (uncurry . (undefined :: a -> a -> b -> b))
19:50:57 <lambdabot> a -> (a, c) -> c
19:51:27 <halogenandtoast> alright thanks
19:59:02 <jle`> np
20:00:05 <jollygood2> i'm using ghc 7.8.4.  was the same field names in different types issue addressed in never versions?
20:01:56 <c_wraith> It can be done, but it's not really pleasant.  Further work is planned.
20:02:48 <jollygood2> DuplicateRecordFields <- this?
20:03:38 <jle`> same field names in different types no longer raise a compiler error (with certain extensions)
20:03:55 <jle`> which is probably the very very least that could have been done to address that issue, heh
20:03:57 <jollygood2> why is it unpleasant? it seems ok at a glance
20:04:01 <jle`> i guess it technically "solves it"
20:08:31 <erisco> jollygood2, it is not pleasant because there is no inference
20:10:55 <erisco> if x↓y means x and y are joined then what does x↑y mean
20:12:53 <erisco> it would, for example, make sense to state confluence as  ∀x.∀y. x↑y ⇒ x↓y  but I don't know the dual name for "join"
20:13:12 <erisco> if lattices are anything to go by then it is "meet"
20:19:04 <iqubic> What does that notation mean erisco? And how did you get type those fancy symbols?
20:19:43 <erisco> iqubic, it is term rewriting and I use WinCompose for the symbols
20:19:50 <iqubic> I get that this is a function that works forall x y. but I don't know the rest.
20:20:02 <iqubic> WinCompose?
20:20:10 <iqubic> Is that windows thing?
20:20:26 <iqubic> s/windows/a windows/
20:21:55 <erisco> Google it
20:22:20 <iqubic> I wll
20:22:31 <iqubic> s/wll/will
20:36:02 <erisco> it seems an obviously important relation because of this equivalence  ∀x.∀y. x↔*y ⇔ x↓y ∨ x↑y
20:36:28 <erisco> which then makes the equivalence of Church-Rosser and confluence obvious
20:46:34 <iqubic> I wish I knew what that syntax meant.
20:56:56 <erisco> this is a small idea for a package http://lpaste.net/358213
20:57:33 <iqubic> What is that supposed to do exactly?
20:57:53 <erisco> it lets you fold over function application, but I can't figure out how to strengthen the inference
20:58:14 <erisco> in effect, it lets you make variadic versions of functions
20:58:25 <iqubic> What does variabic mean?
20:58:45 <erisco> it means "variable arity"
20:59:09 <iqubic> Why not just have a function of type [a] -> b?
20:59:25 <iqubic> Or do you want the inputs to be different types?
21:00:04 <erisco> the point is to treat function applications like a list
21:00:26 <iqubic> I'm not sure how that code works, but I'm sure it's awesome
21:00:50 <erisco> vari (++)  becomes the variadic ++ function, and  vari (+)  becomes the variadic addition function, and so forth
21:01:26 <iqubic> I see.
21:02:04 <iqubic> I've never seen an arrow in an instance declaration before.
21:02:09 <erisco> but it is also more general in type so that  vari (flip (:))  constructs a list from the arguments in reverse
21:03:29 <erisco> so anyways, there's the code, and the idea… hopefully someone can run with it
21:04:14 <byorgey> iqubic: you are in for a treat: http://hackage.haskell.org/package/base-4.10.0.0/docs/Text-Printf.html#t:PrintfType
21:04:46 <iqubic> Why are you showing this to me?
21:05:09 <byorgey> iqubic: it has an arrow in an instance declaration.  And it's really cool.  Actually it's kind of similar to erisco's idea.
21:05:41 <erisco> well I took a look at how they did printf to get me started on this
21:06:05 <byorgey> erisco: it seems cool, but I'm not sure when I would ever want it
21:06:45 <erisco> it is mostly a curiosity
21:06:52 <byorgey> fair enough.
21:07:37 <erisco> vari (flip (:)) []  happens to be (:[]), [,], [,,], …
21:08:06 <erisco> and that sort of thing comes up time to time
21:10:38 <erisco> you can also type direct an arity, so  vari f :: Int -> Int -> Int -> Int  makes the arity-3 version of f
21:11:15 <mac10688> I'm having trouble adding suffixes to my module names. Like 'MyProject.Models'
21:11:30 <mac10688> if I just name the module, ghc complains the filename doesn't match.
21:11:43 <c_wraith> mac10688: directory structure.
21:11:49 <mac10688> oh
21:11:57 <geekosaur> there are some odd circumstances in which you can use Foo.Bar in Foo.Bar.hs
21:12:06 <geekosaur> mostly though it has to be Foo/Bar.hs
21:12:13 <mac10688> so right now everything is in my app folder
21:12:14 <c_wraith> geekosaur: really?  I've never seen that.  How does it happen?
21:12:22 <mac10688> I should make a 'MyProject' folder?
21:12:27 <c_wraith> yes, exactly
21:12:34 <c_wraith> then the file is just named Models.hs
21:12:42 <geekosaur> lemme see if I can find the past discussion
21:12:42 <mac10688> gotcha
21:14:18 <geekosaur> found locally, looking for online log
21:15:53 <geekosaur> ...or. not, because web goes through a different network path from irc and that path is being highly lossy :/
21:16:24 <geekosaur> /home/allbery/.config/hexchat/logs/ZNC [ttuttle ds] - FreeNode/#haskell.log:2017 Jul 11 01:08:57 <tikhon>one really nice thing I found out recently: you can name files Foo.Bar.hs
21:16:25 <erisco> byorgey, I imagine it can find uses with Applicative notation, particularly in the position of f in  f <$> x1 <*> x2 … <*> xn
21:16:44 <geekosaur> aside from the whole log path needing to be renamed... :/
21:17:33 <geekosaur> the interesting thing being that's from earlier thois year but I thought someone found it earlier and provided examples...
21:18:36 <mac10688> so I moved the files outside the main app folder and into a 'MyProject' folder and now ghc can't find them. Do I have to create a library portion in my cabal file to do this or can I tell my executable portion to have multiple hs-source-dirs?
21:18:52 <mac10688> I just tried adding my new folder to hs-source-dirs but it didn't work
21:19:05 <geekosaur> you can do the latter, but normally Myproject would be a subdirectory of your main source folder
21:19:21 <mac10688> then I shall make it a dubdirectory
21:19:33 <geekosaur> if it's outside that directory then you'd haveto do more work and some cases might just be rejected (like ../MyProject/...)
21:21:11 <geekosaur> oh, log in the /topic seems down
21:21:59 <geekosaur> have two hits in widened log search, one from before I added the year to the log format so less than helpful. and haskell irc logs are apparently not open to google spidering
21:22:29 <sqooq> I hate everything
21:22:41 <sqooq> I'm making my own csound haskell library, is that crazy talk?
21:22:58 <iqubic> geekosaur: are you looking for a specific thing in the logs?
21:22:59 <geekosaur> you might be the third to attempt that >.>
21:23:16 <mac10688> what is csound?
21:23:20 <geekosaur> iqubic, discussion of cases where ghc will check a file Foo.Bar.hs for module Foo.Bar
21:23:59 <iqubic> I don't think I have that.
21:24:19 <geekosaur> the one I really want is fairly old and I am not sure there are online logs at all for it now
21:24:23 <geekosaur> since tunes.org seems to be dead
21:24:30 <iqubic> sqooq: I wish I knew enough to do that my self.
21:24:59 <sqooq> iqubic, kek I just started coding a few months ago
21:25:10 <sqooq> I don't think I could do this even if I wanted to
21:25:28 <sqooq> this already exists https://hackage.haskell.org/package/csound-expression
21:25:44 <sqooq> but the types are bad, and the way it gets translated into csound is so bad, basically makes editing after the fact impossible
21:26:10 <geekosaur> mrr, and the other oe tells me it came up on a mailing list.
21:28:55 <geekosaur> aha. https://mail.haskell.org/pipermail/haskell-cafe/2016-December/125758.html
21:29:22 <sqooq> I think I might actually be able to do it
21:29:28 <sqooq> in a nice clean way
21:29:32 <geekosaur> I think this thread went into when ghc will do it and when it won't (and that non e of the tooling expects it)
21:30:43 <geekosaur> so bascally you can at least sometimes get ghc in default make mode to do it, but neither cabal nor stack will find such modules
21:31:19 <iqubic> A monad is a monoid in the catagory of endofunctors. WHAT THE HELL DOES THAT MEAN????
21:32:01 <geekosaur> it's only meaningful if you know enough category theory to understand it, and then you know it's just restating the CT definition of a monad
21:32:06 <geekosaur> i.e. it's useless
21:32:38 <geekosaur> in fact it's generally treated as a Haskell in-group joke
21:33:00 <iqubic> AH. I don't know what it means
21:34:23 <geekosaur> much as you don't have to understand CT monads to use Haskell's Monads, you don't need to know anything more about that bit of verbiage than that it's generally an in-joke
21:35:21 <sqooq> CT?
21:35:26 <pacak> Category Theory.
21:35:31 <pacak> Let's see....
21:35:44 <pacak> Endofunctor - a functor from category to itself.
21:35:50 <pacak> In this case category is Hask
21:36:00 <pacak> So it's a thing of type a -> m a
21:36:25 <iqubic> I see.
21:36:43 <pacak> Monoid needs mappend and mempty
21:37:09 <pacak> mappend: (a -> m a) -> (a -> m a) -> (a -> m a) (it's not really a, but something from Hask category)
21:37:12 <geekosaur> but note that these are at type level, not value level like Haskell's Monoid
21:37:23 <pacak> mempty - a -> m a
21:37:40 <pacak> There are nice diagrams explaining this kind of stuff.
21:37:55 <pacak> Hmm....
21:38:19 <pacak> iqubic: https://arxiv.org/abs/1406.4823
21:38:21 <pacak> this
21:38:58 <pacak> If you survive - you'll understand what it means.
21:40:10 <fresheyeball> if I have a Map like this
21:40:40 <fresheyeball> fromList [(0, "c"),(1,"a"),(3,"b")]
21:40:56 <fresheyeball> is there a way I can looking a preceeding value?
21:40:59 <fresheyeball> like
21:41:18 <fresheyeball> lookupPrev 2 myMap = "a" 
21:41:26 <fresheyeball> ?
21:41:33 <pacak> :t lookupLT
21:41:34 <lambdabot> error:
21:41:34 <lambdabot>     • Variable not in scope: lookupLT
21:41:34 <lambdabot>     • Perhaps you meant one of these:
21:41:52 <erisco> :t M.lookupLT
21:41:54 <lambdabot> Ord k => k -> M.Map k v -> Maybe (k, v)
21:42:18 <erisco> > M.lookupLT 2 (M.fromList [(0, "c"),(1,"a"),(3,"b")])
21:42:18 <fresheyeball> wow, you guys are good
21:42:21 <lambdabot>  Just (1,"a")
21:42:27 <fresheyeball> what is M?
21:42:35 <erisco> import Data.Map as M
21:42:37 <MarcelineVQ> fresheyeball: there's all kinds of neat stuff in the docs https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map-Laz
21:42:49 <fresheyeball> I'm in that module
21:42:51 <MarcelineVQ> not sure why that linked like that  https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map-Lazy.html
21:42:53 <fresheyeball> I don't see lookupLT
21:43:30 <pacak> fresheyeball: We do.
21:43:42 <fresheyeball> oic
21:43:46 <fresheyeball> its in .Lazy
21:43:48 <fresheyeball> but not Data.Map
21:43:53 <erisco> or in .Strict
21:43:56 <geekosaur> Dtaa.Map is basically a wrapper
21:44:13 <fresheyeball> so it has to be lazy for this to work?
21:44:25 <geekosaur> no, both .Strict and .Lazy have it
21:44:32 <geekosaur> Data.Map quietly rexports the .Lazy one iirc
21:45:14 <mud> fresheyeball: If you see in the docs it says "module Data.Map.Lazy", that means it's re-exporting the whole module. https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map.html in here for example
21:45:39 <mud> So all the stuff that's in the linked module is available too
21:45:46 <geekosaur> (Data.Map is slightly weird, anyway: there is only one Map. it's the *operations* that differ in strictness, not the data structure as with Text or ByteString)
21:45:57 <sqooq> AHA
21:46:22 <sqooq> I can affect my sound alone, before putting it anywhere, since it's actually a pretty good data representation
21:47:02 <sqooq> THEN, I can create a function that generates just the csound score part, 
21:47:32 <sqooq> Then, I can either parse a csd file and automatically put it in the right place, OR, just manually copy and paste lmao
21:47:46 <sqooq> this will likely be much better than working with csound-expression
21:50:02 <iqubic> How did you do that???
21:53:33 <sqooq> iqubic, I haven't yet
21:53:40 <sqooq> It shouldn't be hard at all
21:54:27 <iqubic> How do you plan to interface with csound?
21:54:29 <sqooq> like a recursive function that goes through my data structure and generates "i1 " ++ a ++ " " ++ b ++ etc.
21:55:26 <sqooq> then I can output to file, terminal, whatever, again easy. Parsing the file and automatically placing it in shouldn't be too hard either. I already have a parser. Csound clearly marks the score section with "<CsScore>"
21:55:48 <sqooq> just make a parser that finds that, inserts new line, then pastes the score my other function will generate
21:55:52 <sqooq> badda boom badda baby
21:56:01 <iqubic> How are you telling Haskell to play sounds?
21:56:11 <sqooq> iqubic, i'm not, I'm telling csound to
21:57:19 <sqooq> Then I'd like to make a gui to help create a line graph, that will be used as input to another function I have, to change note velocity
21:57:22 <sqooq> just like you would in a daw
21:58:08 <iqubic> sqooq: How are you using haskell to interface with csound?
21:58:47 <sqooq> currently by using the csound-expression library in a very painful manner
21:59:04 <iqubic> Oh, I see.
21:59:08 <sqooq> my plan as I just laid out is to just make the score part and put in a csound file
21:59:16 <sqooq> csound just takes text files as input and makes sound
21:59:31 <iqubic> I thought you were using FFI magic
21:59:54 <sqooq> nah, don't even think csound-expression uses ffi magic
21:59:59 <sqooq> since it just makes a text file anyway
22:00:06 <sqooq> that's somewhat the beauty of csound
22:00:10 <sqooq> but I guess also the curse
22:00:50 <sqooq> here's my thing rn btw https://github.com/Cypress-the-Kinaesthetician/Goulds-Mark
22:00:54 <boj> iqubic: https://tidalcycles.org is another approach, seems to be a lot of music nuts using haskell out there. it leverages ghci to hook into a different piece of music software, but uses haskell to program it live
22:01:38 <sqooq> Tidal is cool, definitely seems better than csound-expression which sort of tries to do something similar
22:01:53 <sqooq> not what I'm really doing though
22:07:54 <iqubic> boj: What's interested in is interfacing with libraries written in other languages.
22:09:14 <boj> iqubic: have you experimented with any particular language's FFI before? typically you are just building wrapper functions over (usually) C libraries
22:09:57 <iqubic> No. I have no idea how FFI works in any language.
22:11:58 <iqubic> But I'd like to learn about Haskell's FFI
22:13:38 <boj> is there a particular library you want to wrap?
22:14:15 <trevortknguyen[m> The Raspberry Pi Broadcom GPIO library!
22:14:45 <iqubic> boj: No. I just want to learn about FFI for the sake of learning.
22:15:23 <boj> iqubic: fair enough. maybe write a simple C library and try to wrap it with haskell's FFI?
22:16:01 <iqubic> I'll try that.
22:16:09 <iqubic> Does it have to be C?
22:16:26 <boj> i have heard stories of people successfully getting Rust to play nicely
22:16:55 <boj> if you use C++ you have to wrap it with C calls because the symbol names get mangled
22:17:10 <yushyin> same for rust
22:17:10 <mud> iqubic: Most languages have C FFIs, so you can go via C to other languages if you want. But then you have to learn two FFIs.
22:17:19 <mud> GHCJS has an FFI to JS if you prefer that.
22:18:58 <iqubic> I think I'd like to just use C. 
22:51:25 <iqubic> Good night all. I'm off to bed.
22:52:20 <norc_> What is () called?
22:52:25 <erisco> unit
22:53:44 <srhb> norc_: (Because it is inhabited by exactly one possible value (ignoring bottom))
22:54:09 <norc_> erisco: Thank you.
22:54:47 <erisco> why do we ignore botto
22:54:48 <erisco> m
22:55:13 <Axman6> because fast and loose reasoning is morally correct
22:55:21 <MarcelineVQ> because everyone's got one
22:55:33 <erisco> is it telling that conversations often include the caveat "ignoring bottom"?
22:55:34 <Axman6> https://pdfs.semanticscholar.org/a316/3d9097a87a713f0dd3f154f139e19dcb2a82.pdf
22:55:42 <srhb> Infinite recursions are just like bottoms, everyone has one?
22:55:47 <MarcelineVQ> it's mean to avoid pedantry, how foolish!
22:55:49 <norc_> I take it bottom is relevant because say a monadic action that returns nothing like putStrLn could possibly produce bottom?
22:55:53 <Axman6> erisco: read that paper to find out why it's ok to do so
22:55:57 <MarcelineVQ> *meant
22:56:15 <srhb> > a = a :: ()
22:56:17 <lambdabot>  <hint>:1:3: error:
22:56:17 <lambdabot>      parse error on input ‘=’
22:56:17 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
22:56:20 <srhb> Oops
22:56:21 <srhb> I forget
22:56:24 <srhb> anyway, norc_ ^
22:56:30 <norc_> erisco: Most "ignoring bottom" so far are in this series of category lectures that also happens to talk a lot about haskell :P
22:56:48 <srhb> norc_: `a` above is well-typed 
22:56:58 <srhb> norc_: (But not very useful)
22:57:25 <Axman6> > let a = a :: () in show a
22:57:31 <lambdabot>  mueval-core: Time limit exceeded
22:57:59 <norc_> srhb: Yeah Im currently getting confused by the state monad in the gentle introduction.
22:58:48 <norc_> And they happened to use unit, but its usage seems clear.
22:59:11 <srhb> This problem applies to any type in face of general recursion.
22:59:41 <erisco> Axman6, that's not really the point to make
22:59:54 <norc_> Also I have a question. I tried tossing that state monad from the gentle introduction into haskell, but it immediately complained about No instance for Applicative SM
23:00:02 <nshepperd_> Bottom represents nontermination. "ignoring bottom" is like "assuming this terminates"
23:00:12 <erisco> Axman6, the point to make is why we should have partiality, not why we can ignore it
23:00:17 <norc_> Is this related to the fact that Monad did not used to be a subclass of Applicative?
23:00:38 <srhb> norc_: Sounds like it, yes.
23:00:42 <MarcelineVQ> gentle introduction is 17 years old
23:00:45 <nshepperd_> Assuming my function eventually produces a value, that value must be ()
23:00:48 <norc_> nshepperd_: Not just non-determination. Errors too.
23:00:56 <norc_> MarcelineVQ: Oh. :-)
23:01:21 <c_wraith> norc_: yes.  Just fall back on the instant definitions.  Functor: fmap = liftM, Applicative: pure = return, (<*>) = ap
23:01:52 <norc_> c_wraith: Mmm, how do I do that? Am I not required to declare the instance Functor/Applicative separately first?
23:01:54 <c_wraith> norc_: those definitions will work (possibly not the best, but they'll always work) for any Monad
23:01:57 <c_wraith> norc_: no.
23:04:20 <norc_> Ah great. So a Functor instance declaration can use methods from a Monad declaration.
23:04:40 <c_wraith> yep
23:05:26 <c_wraith> The only restriction is that if a module declares a <onad instance for a type, it has to have the Applicative instance in scope one way or another.  
23:05:42 <Hafydd> That would be using the methods from the Monad class. The methods don't come from the instance.
23:05:54 <Hafydd> (Satisfaction of the constraint comes from the instance.)
23:06:24 <c_wraith> *Monad.  (interesting typo...)
23:49:37 <jle`> i thought it was my cursor at first
