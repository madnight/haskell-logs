00:02:50 <halogenandtoast> Using graphviz with fgl, I have a graph with nodes (1, Area "name") and have a Labellable instance for area to return "name", but when I generate a graph all my nodes are labelled with the node id rather than the name
00:03:09 <halogenandtoast> Is there any way to get it to label with the "name" instead?
00:05:14 <halogenandtoast> I assume I need to use fmtNode somehow
00:10:50 <dmwit> halogenandtoast: I used graphviz before, but I can't remember the details of how it all works now.
00:10:58 <cocreature> halogenandtoast: can you show us some code? which parameters did you use?
00:11:18 <dmwit> If you want to stare at some code which I know produces graphs with human-readable node labels, you can look here: https://github.com/GaloisInc/cryfsm/blob/master/Convert/LDAG/DOT.hs
00:11:24 <dmwit> I do indeed use fmtNode as you surmise.
00:12:11 <dmwit> You'll probably mostly want to look at `showParams`.
00:12:36 <dmwit> But `clusterBy` is also relevant.
00:12:58 <cocreature> "quickParams" should use the Labellable instances if you don’t care too much about the exact attributes
00:50:24 <erisco> foldr (-) 0  is interesting
00:50:48 <erisco> when the list is even length, the reverse list is the negative
00:51:02 <erisco> when the list is odd length, the reverse list is the same
00:51:20 <dmwit> > foldr (-) 0 [x,y,z]
00:51:23 <lambdabot>  x - (y - (z - 0))
00:51:59 <dmwit> > sum . zipWith (*) (cycle [-1,1]) $ [x,y,z]
00:52:02 <lambdabot>  0 + negate 1 * x + 1 * y + negate 1 * z
00:52:32 <erisco> with foldl, the reverse list is the same regardless of length
00:53:25 <erisco> how do we whip this up into some sort of puzzle/question
01:22:43 <paolino> hi, is it correct that minimal definition of ArrowChoice should be left and not (left, (+++)) ?
01:23:50 <erisco> what do the docs say?
01:23:58 <paolino> second one
01:23:59 <halogenandtoast> dmwit: cocreature sorry I was doing a haskell bookclub
01:24:01 <halogenandtoast> just finished
01:24:05 <erisco> why do you doubt it?
01:24:16 <cocreature> paolino: the minimal definition seems to be "left | (+++)" (which is for some reason not displayed in the haddocks) which seems to match the implementation
01:24:39 <paolino> because (+++) is implementable in terms of left
01:25:03 <cocreature> +++ is implementable in terms of left and left is implementable in terms of +++
01:25:04 <halogenandtoast> I had an fgl graph and I just called `graphToDot defaultParams fglGraph`
01:25:11 <cocreature> so you get left | +++
01:25:31 <paolino> oh thats an OR , pardon
01:25:35 <cocreature> halogenandtoast: the fact that defaultParams doesn’t have a Labellable constraint hints at the fact that it can’t use that instance
01:26:03 <halogenandtoast> yeah I was trying to do something like defaultParams { fmtNode = something }
01:26:10 <halogenandtoast> but couldn't get it right
01:26:23 <cocreature> try `quickParams`
01:26:36 <halogenandtoast> ok
01:29:28 <erisco> there is a way to generate just the core output with ghc, which I can never remember
01:29:50 <dmwit> -ddump-simpl
01:31:00 <erisco> so that dumped it all to my terminal and still built an executable
01:33:36 <ocharles> Am I going mad? I thought that in GHCI if I loaded a file (`:load`), I would be in an environment which had the same imports available
01:33:52 <ocharles> Yet all that i have available is Prelude (no `.ghci` or anything)
01:34:10 <ocharles> Urgh, GHCI is confusing me *again*. I can't see definitions in that file either
01:34:42 <ocharles> oh, I got it. The file had a type error so it wouldn't load. Time to turn -fdefer-type-errors on so GHCI is useful
01:34:43 <MarcelineVQ> no you don't get the same imports, you get whatever the file you :load'ed exports
01:35:20 <MarcelineVQ> at least, that's how I remember it, should double check :X
01:35:52 <MarcelineVQ> erisco: -ddump-prep -ddump-to-file  will get you file output, try  -fno-code  to see if it'll get you just code, unlikely though  is -fno-object-code an accepted flag?
01:35:54 <cocreature> I don’t think that’s true for :load
01:36:28 <cocreature> ahrg it looks like ghci’s behavior in that regard even changes when using -fobject-code
01:36:47 <cocreature> but in byte code mode it seems to load everything
01:37:16 <cocreature> the * in ":show imports" indicates that it loaded everything
01:37:25 <erisco> -fno-code gave me no output files
01:37:48 <MarcelineVQ> erisco: figured as much, I've never tried it myself
01:38:03 <erisco> after hours of searching I found the magic incantation to make this work
01:38:06 <erisco> and now I can't find the bookmark
01:39:25 <halogenandtoast> cocreature: Thanks, using quickParams worked (for some reason I didn't have quickParams in my Graphviz so I had to write the method myself)
01:39:29 <halogenandtoast> but it does exactly what I wanted
01:41:12 <cocreature> halogenandtoast: judging by the changelog `quickParams` was added in 2999.19.0.0
01:41:13 <erisco> eh, annoying but good enough for now, thanks
01:41:22 <erisco> I am just trying to see if ghc precomputes a list
01:41:26 <cocreature> also wtf are those version numbers supposed to represent
01:41:29 <erisco> answer was no
01:42:24 <MarcelineVQ> erisco: you can specify -no-link at least to cut down a bit on time
01:42:30 <halogenandtoast> cocreature: they coincide with GraphViz's versioning so you know if the version is supported
01:43:21 <cocreature> halogenandtoast: I don’t think they do, the latest version of graphviz is 2.41
01:43:22 <MarcelineVQ> allthough, the link for that option doesn't have a hyperlink in the manual, it may not be a thing
01:43:29 <cocreature> not 2999.something
01:43:32 <halogenandtoast> Yeah...
01:45:05 <halogenandtoast> I am wrong, I have no real idea.
01:46:25 <cocreature> halogenandtoast: https://github.com/ivan-m/graphviz/blob/master/FAQ.md#why-are-the-version-numbers-so-high
01:47:19 <halogenandtoast> lol
01:48:12 <halogenandtoast> Thanks for finding that
01:57:00 <toddWannaCode> If I have a Maybe Monad how can I compose it to print it with an IO Monad?
01:57:42 <toddWannaCode> Essentially, what can I do instead of say , `Just "Test" >>= putStrLn`?
01:58:12 <erisco> well now what do I call (a -> b -> b) -> [a] -> b -> b
01:58:36 <erisco> naming such a pita
01:59:03 <cocreature> erisco: isn’t that just a fold with swapped parameters?
01:59:08 <Cale> toddWannaCode: The fact that Maybe and IO happen to be monads won't help you with that.
01:59:17 <erisco> yes, it is
01:59:27 <cocreature> that seems more confusing than useful
01:59:36 <erisco> cool, but I want to name it
01:59:46 <Cale> toddWannaCode: They're distinct monads. The fact that Maybe is a monad will help you deal with combining a bunch of things which produce Maybe results.
02:00:02 <Cale> toddWannaCode: The fact that IO is a monad will help you with combining a bunch of IO actions together.
02:00:28 <Cale> toddWannaCode: You might just use print, if that does the right thing
02:00:44 <toddWannaCode> So using pattern matching?
02:00:54 <Cale> You could use pattern matching, with case
02:01:33 <toddWannaCode> Alright. Thanks. :D
02:01:36 <Cale> If you don't want to print in the case that the Maybe value is Nothing, you could use forM
02:01:37 <Cale> :t
02:01:40 <Cale> :t forM
02:01:42 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
02:01:50 <Cale> Maybe is an instance of Traversable
02:02:05 <cocreature> :t forM_ -- is probably more appropriate if printing is all you want to do
02:02:06 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
02:02:12 <Cale> indeed
02:02:19 <Cale> Or even mapM_
02:02:27 <Cale> (which is the same with the arguments swapped)
02:02:35 <Cale> mapM_ putStrLn maybeThing
02:03:14 <toddWannaCode> Ou. Alright. Thansk
02:03:18 <toddWannaCode> *thanks
02:04:18 <Cale> But yeah, often I don't bother even thinking about it, and just write the case expression
02:05:19 <Cale> It's quite common that you eventually want to handle the Nothing case with some kind of explicit error reporting or some such, and then if you were clever, you end up undoing the cleverness anyway
02:05:21 <halogenandtoast> erisco: flodr
02:05:33 <Cale> frodl
02:05:43 <cocreature> there is also MaybeT IO if you really need it but if you only want to print one thing, it’s definitely not worth the trouble
02:10:28 <erisco> well it can't be frodl because that looks like a left-associative fold
02:10:32 <erisco> but flodr is promising
02:11:07 <erisco> there is good reason for the madness
02:15:05 <erisco> this is part of my folding applications library
02:17:00 <Cale> erisco: Oh, haha, I hadn't seen your original question somehow
02:17:10 <Cale> erisco: I thought it was just a typo :)
02:29:27 <mbrock> > pattern Reads x <- (readMaybe -> Just x)
02:29:30 <lambdabot>  <hint>:1:1: error:
02:29:30 <lambdabot>      Parse error in pattern: pattern
02:29:30 <lambdabot>      Possibly caused by a missing 'do'?
02:29:52 <tabaqui> :t pattern
02:29:54 <lambdabot> error: Variable not in scope: pattern
02:30:34 <Hafydd> That is an attempt to use <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-synonyms>, but apparently lambdabot does not support it.
02:30:42 <mbrock> it's a thing I just noticed you can do with `PatternSynonyms` and `ViewPatterns`
02:30:52 <Hafydd> Unless...
02:30:54 <erisco> so, folding stuff goes in Data right?
02:30:57 <Hafydd> @let pattern Reads x <- (readMaybe -> Just x)
02:30:58 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
02:31:16 <mbrock> then you can pattern match on `Reads x`, and it will match whenever the input string correctly parses with `read`
02:31:20 <tsahyt> is there some lensy way to construct tuples, e.g. something instead of (view someLens r, view someOtherLens r)
02:37:23 <`Guest00000> can i force an instance to existence for debugging purposes?
02:38:17 <`Guest00000> i have a variable with ambiguous type and i'd like to use its Show instance when printing error message
02:54:30 <erisco> hehe, this is such a stupid and fun toy
02:54:42 <erisco> listOf 1 2 3
02:54:52 <erisco> this is the sort of nonsense you can write XD
02:56:40 <erisco> but will be useful for things like  listOf <$> Just 1 <*> Just 2 <*> Just 3
03:04:38 <erisco> what is a name for mconcat but reverse order
03:04:46 <erisco> there is a newtype called Dual
03:06:51 <erisco> ghc panic, hrm
03:22:36 <erisco> GHC is getting a bit weird as to what it will and will not infer
03:22:53 <erisco> once I give a name and a type decl it behaves differently
03:23:03 <erisco> manually inline and it starts working again
03:44:53 <SpicyChicken> hi
03:45:02 <Cale> hi
04:17:04 <mbrock> what is the effect called when GHC de-polymorphizes a function when you declare it as a let clause?
04:17:55 <mbrock> it happens a lot when I try to refactor repetitive lens subexpressions in a function
04:21:06 <erisco> what does it mean to declare a function as a let clause?
04:21:30 <cocreature> mbrock: monomorphism restriction
06:08:52 <cmotoche> Hello everyone. I'm getting the following error when compiling my library against LTS nightly: <no location info>: warning: [-Wmissing-home-modules]    These modules are needed for compilation but not listed in your .cabal file's other-modules: Paths_Library
06:09:07 <cmotoche> I think the problem is related to cabal. However, I'm not sure how to solve it.
06:09:35 <cmotoche> I'm using -Werror and it fails on the CI because of that warning.
06:11:55 <cocreature> cmotoche: the error message seems pretty clear to me. have you tried adding that module to other-modules?
06:15:11 <cmotoche> cocreature, sure I can do that. However, I old versions that wasn't necessary. The Paths_* module was available without writing it explicitly.
06:15:16 <cmotoche> cocreature, thanks.
06:16:02 <cocreature> cmotoche: it’s been a long-standing issue that GHC/cabal/stack don’t properly detect if you forget to add modules to other-modules so GHC 8.0 finally added that warning.
06:16:38 <cocreature> while in some cases the build seems to work without doing that, you end up with stack/cabal not rebuilding your project because it’s not tracking that module and other weird stuff like that
06:37:13 <paolino> I'm trying to make a vararg function http://lpaste.net/358251
06:38:10 <paolino> I guess I need some fundeps but random trying didn't help
06:41:40 <ertes-w> paolino: are all arguments of the same type?
06:42:34 <paolino> no the function should select the types
06:42:38 <ertes-w> no, they're not
06:42:46 <ertes-w> paolino: what's the purpose of the function?
06:43:17 <ertes-w> perhaps show some example equations
06:43:29 <lyxia> I don't understand either
06:44:01 <paolino> ok, I have this list of E and I want any function to use  it as argument
06:44:26 <`Guest00000> byorgey: let's say P parses "AB" and Q parses "A"; i want (p `diff` q) to still parse "AB"; but the solution for 'diff' you gave me, which is (notFollowedBy q *> p), refuses to parse "AB"
06:44:28 <ertes-w> paolino: BTW, E is just Dynamic from Data.Dynamic
06:44:35 <paolino> so a function f :: [a] -> [b] -> c should get what it needs
06:44:51 <paolino> ertes-w, yep, I forgot
06:45:04 <ertes-w> paolino: i don't understand this
06:45:06 <`Guest00000> if all parsers return the parsed token count / string length, though, we'll probably be able to correct this
06:45:15 <ertes-w> paolino: could you provide example equations?
06:45:39 <`Guest00000> no
06:45:41 <`Guest00000> we won't
06:45:43 <lyxia> Ah, so if you have a list [E 1, E "foo", E 2], f :: [Int] -> [String] -> c  would get applied as  f [1, 2] ["foo"] ?
06:46:09 <lyxia> Does it have to be a list
06:46:44 <ertes-w> paolino: my question would be what they're going to use that function for…  why it needs that level of dynamic typing in the first place
06:46:52 <ertes-w> *you're
06:46:58 <paolino> lyxia, yes
06:47:12 <paolino> ertes-w, select (take . head) xs == ["paolino"]
06:47:42 <lyxia> This smells strongly of an xy problem.
06:47:55 <ertes-w> paolino: try explaining the problem, not the solution
06:48:38 <paolino> ertes-w, it's an interaction space for a some components 
06:49:10 <paolino> they pull the news and write back 
06:49:28 <ertes-w> paolino: so far that sounds completely static
06:49:44 <ertes-w> why do you (think you) need dynamic typing?
06:51:00 <paolino> because we need to keep it component decoupled
06:51:17 <paolino> we are not settled down actually
06:51:30 <ertes-w> paolino: morphisms in a category are completely decoupled, and composition is still statically typed
06:51:53 <ertes-w> paolino: your abstraction is probably just not parametric enough
06:52:54 <paolino> yes, we have been working and we are still working with a polymorphic solution
06:53:50 <paolino> this is just an experimental branch we hope with a simpler semantic
06:53:53 <ertes-w> paolino: check if your question sounds like the following:  "we have a type Func, and now we're writing the composition function for Funcs, but we need Typeable and dynamic typing to compose them"
06:54:25 <ertes-w> solution:  increase the level of parametrisation of Func:  (Func :: * -> * -> *) instead of (Func :: *)
06:55:52 <ertes-w> this hypothetical Func type was designed to be a Monoid, but it really needs to be a Category
06:57:23 <paolino> well, the zoo of consumer and producers for that log is not very categorizable so to say
06:57:29 <lyxia> paolino: http://lpaste.net/358251 see annotation
06:58:47 <paolino> oh lyxia, I just owe you some beer
06:59:10 <paolino> thans
06:59:13 <paolino> thanks
07:02:07 <ertes-w> paolino: i'd still suggest that you revisit your component design…  i'd be suspicious of any code that uses the Select class
07:02:31 <ertes-w> and not only because it uses overlapping =)
07:05:42 <paolino> ertes-w, it's fine I'm suspicious too, but I want too see the result as a DSL. If I loose some type safety for easy expressivity it could be ok
07:11:49 <paolino> lyxia, I still have a missing Typeable a0 constraint on the print line
07:13:14 <paolino> no, it's ok :-) 
07:14:20 <paolino> how it is different to set (r ~ r') => Select r r' from Select r r ?
07:14:37 <paolino> (which produce the error ?)
07:15:46 <lyxia> So you know the result type    select (take . head) xs :: [String]
07:16:12 <lyxia> but at this point you only have    take . head :: [Int] -> [a0] -> [a0]
07:16:32 <lyxia> so you're looking for an instance matching   Select [a0] [String]
07:16:59 <lyxia> Which doesn't quite match Select r r because you don't know a priori that a0 ~ String
07:18:24 <lyxia> However, it matches Select r r', and only after the instance is selected does the typechecker look at its context, r ~ r', which helps unify a0 with String.
07:19:05 <royal_screwup21> I'm on my haskell and interpreter and I type in ":l filename". Now, while inside this module, I make changes to the file. How do I automatically refresh my session without having to exit my current module and start all over again?
07:19:18 <paolino> :r
07:19:28 <royal_screwup21> thanks paolino!
07:20:24 <paolino> lyxia, it make some sense, but I don't know why only some, so I have to take it like it is
07:20:29 <lyxia> paolino: so for type inference magic, never use the same variable twice in the instance head, and instead add type equalities in the context (where "context" and "instance head" are defined by "instance context => instance head")
07:22:02 <lyxia> I mean, an instance declaration looks like this:  instance ({- 'context' here -}) => ({- 'instance head' here -})
07:23:15 <paolino> yep, but the "a priori" condition in your wording remains a mistery to me
07:26:53 <toddWannaCode> Anyone got any good resources on learning Trifecta?
07:27:36 <byorgey> toddWannaCode: is there a specific reason you want to learn trifecta?
07:28:19 <toddWannaCode> Yeah, I am thinking of implementing a language myself to learn stuff.
07:29:22 <byorgey> the problem is that there aren't many (any?) good resources on learning it.  If you are just looking for a parser framework to use, I can highly recommend megaparsec, which has much better resources for learning, including some nice tutorials
07:30:12 <byorgey> https://github.com/mrkkrp/megaparsec
07:30:39 <toddWannaCode> Ah noice. Yeah I noticed the lack of resources on google which is why I asked here. My main reason for going with Trifecta were the error messages but appears like megaparsec have good error messages too.
07:33:01 <byorgey> yeah, I think trifecta has nice built-in support for fancy slicing/highlighting syntax in error messages, but other than that megaparsec does have good error message support
07:33:35 <sm> +1
07:36:11 <ertes-w> toddWannaCode: trifecta works pretty much like all other parser combinator libraries
07:36:53 <ertes-w> toddWannaCode: megaparsec's error messages aren't quite as detailed as trifecta's, as far as i know, so the latter is a good choice for human languages
07:37:42 <byorgey> "pretty much like" <--- I estimate there is approximately one week's worth of frustration packed into there
07:38:22 <byorgey> and if you haven't used other parser combinator libraries before, it doesn't help at all
07:39:20 <toddWannaCode> Yeah, this is the first time I  am using one. So I guess I will start with the easier ones and level up to trifecta with time.
07:40:18 <brynedwards> toddWannaCode: The haskellbook.com book has a Parser combinators chapter that uses trifecta. It's more so aimed at teaching parsing than being a library-specific tutorial
07:41:31 <toddWannaCode> Yeah man I will buy that book once I save a bit. It seems like a great book, almost like the present day Bible for Haskell.
07:42:51 <brynedwards> I certainly found the book help me a lot when picking up haskell
07:43:47 <Psybur> If you have hardcoded strings in your haskell code, are they visible in the executable with a hex editor?
07:44:04 <toddWannaCode> Is it still in Early Access mode or has it been completed?
07:45:52 <cocreature> toddWannaCode: afaik it has been completed content wise and they’re only doing a bit of proofreading now before producing printed copies
07:46:14 <dolio> Psybur: Probably.
07:46:51 <`Guest00000> how do you call the operation with type (Either a b -> Either b a)?
07:47:16 <dolio> I think GHC turns string literals into C-like strings and uses a decoder from those, at least in some cases.
07:47:27 <opqdonut> :t either Right Left
07:47:28 <lambdabot> Either b a -> Either a b
07:47:33 <opqdonut> `Guest00000: see above
07:47:35 <cocreature> :t swapEither
07:47:37 <lambdabot> error:
07:47:37 <lambdabot>     • Variable not in scope: swapEither
07:47:37 <lambdabot>     • Perhaps you meant one of these:
07:47:38 <dolio> And probably stores the C strings in the typical place.
07:47:43 <`Guest00000> opqdonut: but how do you call it
07:47:47 <cocreature> :t Data.Either.Combinators.swapEither
07:47:48 <lambdabot> error:
07:47:49 <lambdabot>     Not in scope: ‘Data.Either.Combinators.swapEither’
07:47:49 <lambdabot>     No module named ‘Data.Either.Combinators’ is imported.
07:48:08 <cocreature> meh, here it is https://hackage.haskell.org/package/either-4.4.1.1/docs/Data-Either-Combinators.html#v:swapEither 
07:48:47 <`Guest00000> ok, fine
07:49:30 <Psybur> Are there ways to protect strings in memory with Haskell?
07:49:40 <ertes-w> `Guest00000: "commute"?
07:49:49 <cocreature> Psybur: what do you mean by protect?
07:49:54 <davean> Psybur: "protect"?
07:50:07 <Psybur> Prevent unauthorized reads. People scanning your exe or looking in memory
07:50:17 <ertes-w> `Guest00000: ∀ a b. Either a b ≃ Either b a
07:50:21 <dminuoso> Psybur: No.
07:50:28 <dminuoso> Psybur: If your program can read it, anyone can read it.
07:50:40 <davean> Psybur: I mean, some CPUs, like I think the z14, has built in doman cryptography for memory
07:50:52 <ertes-w> `Guest00000: and "commute" is the isomorphism
07:50:59 <dolio> Intel was talking about that, too, I think.
07:51:07 <davean> Psybur: but that has nothing to do with any specificl language, anything like that is right to how the computer works in the first place
07:51:10 <dolio> Except, not for general purpose use. Just for DRM.
07:51:22 <dminuoso> dolio: That does not help for this case.
07:51:24 <Psybur> Guess I need to research how financial companies keep their accounts safe when using programs that access them
07:51:28 <davean> the z14s at least if for general purpose work
07:51:38 <dminuoso> dolio: The thing is that the data need to be present in the executable to begin with.
07:51:47 <dminuoso> dolio: Which means its accessible.
07:51:48 <dolio> Yeah.
07:52:03 <davean> dminuoso: not exactly
07:52:05 <cocreature> Psybur: by not giving people access to their servers :)
07:52:08 <Psybur> I dont trust AWS or other virtual private servers, but I need a virtual private server to be close to the exchange D:
07:52:09 <dolio> You'd need to have it encrypted in the exe, too, I guess.
07:52:10 <davean> dminuoso: it can be encrypted with a public key
07:52:16 <dminuoso> davean: And where is the public key?
07:52:16 <`Guest00000> Psybur: if compiler stores the string literals in binaries plainly and supports Template Haskell, you can scramble strings before they get stored, and unscramble at runtime
07:52:21 <dolio> And only decrypt it once it's in the 'safe' area.
07:52:23 <davean> dminuoso: in the HW
07:52:37 <davean> dminuoso: IBM uses a hierarch based off a proctected PCIe card
07:52:59 <Psybur> `Guest00000, but if you decompile the exe you would be able to find the scrambling algorithm?
07:53:02 <davean> and I believe the decryption is done in the memory controller?
07:53:26 <dminuoso> davean: That can work. But do you honestly thing an HSM is within the realms of reality if someone just drops into #haskell on freenode and asks "how to protect strings in memory" ?
07:53:49 <dminuoso> davean: The moment you get into this water you need to be an expert in hardware.
07:55:37 <davean> dminuoso: I mean, he asked if it could be done
07:55:46 <ertes-w> Psybur: compile your program to lazy k instead of native code
07:56:02 <dminuoso> davean: The issue is you still have the problem of transferring data.
07:56:24 <`Guest00000> Psybur: theoretically, any relevant data or algorithms can be recovered from any executable binary with enough dedication; practically, search the internet for "reverse engineering haskell programs"
07:56:26 <dminuoso> davean: if someone attaches a high speed logic analyzer to your precious HSM, he can extract any data that is transferred.
07:56:53 <davean> dminuoso: except the data only ever exists in the clear inside the chips
07:57:06 <davean> and logic analyzers can't handle that scale and frequency (fairly inherantly)
07:57:11 <dminuoso> davean: Yes they can.
07:57:30 <davean> if you wanted to avoid that you'd have to go to homomorphic encryption
07:57:50 <davean> dminuoso: debugging CPUs is notorious hard
07:57:57 <davean> dminuoso: esp ones operating over 5GHz
07:58:27 <davean> never midn that assumes you defeated the physical protections on the HSM
07:59:28 <dminuoso> davean: so you have a chain of trust issue still. 
08:00:05 <toddWannaCode> Okay one thing. <|> from Control.Applicative works like OR for Functors like?
08:00:26 <cocreature> toddWannaCode: depends on the instance :)
08:01:56 <dminuoso> toddWannaCode: <|> is defined by the fact that its associative and its type signature.
08:03:07 <toddWannaCode> Ou okay. Thanks
08:03:08 <`Guest00000> Psybur: https://www.reddit.com/r/haskell/comments/iqz0l/reverse_engineering_of_compiled_haskell/ 
08:03:58 <dminuoso> toddWannaCode: It took me a while to grasp it, but to really understand all these operators you have to approach them from an abstract point of view. When you then implement a specific instance and ask yourself "When I implement this operator with this signature and the required laws, what possible semantics could it do?"
08:04:16 <dminuoso> toddWannaCode: And it turns out that for quite a few types, there are only very few logical things to do within those restrictions.
08:06:16 <toddWannaCode> Yeah I think need to get a hang of the math like abstract reasoning of Haskell. The thing about Haskell is everything happens so naturally that coming from other languages it becomes a little hard to grasp at first.
08:06:17 <`Guest00000> Psybur: note that when descrambling strings, you don't want to store them for too long, or they could be recovered from memory easliy
08:08:39 <`Guest00000> e. g. don't bind descrambled strings to top-level variables
08:10:00 <adam__> sanity check: I want to 'fold' a list, but in consuming an item it should transform later items.  I think I should do this by having the accumulator type be (b, a -> a): it accumulates the transformations and applies them all at once to the item it's about to consume.  Am I missing some other useful built-in or structure?
08:12:25 <dminuoso> toddWannaCode: For me the cracking point was just looking at rings in math and realizing what actually differentiates "addition" from "multiplication". 
08:16:58 <ertes-w> adam__: functions are a bit unfortunate, because they are opaque, so every transformation you do on a function comes with a time and memory cost
08:17:07 <ertes-w> adam__: but you can use a stateful fold
08:17:40 <ertes-w> > foldr (\x go dx -> (x + dx) : go (dx + 1)) (const []) [10,20,30,40] 1
08:17:42 <lambdabot>  [11,22,33,44]
08:18:08 <ertes-w> adam__: http://ertes.eu/tutorial/foldr.html#stateful-folds
08:18:38 <adam__> ertes-w: thanks, I'll take a look at that.
08:25:28 <dminuoso> toddWannaCode: Superficially <|> is basically just (+). It's basically the monoid group operation. It allows you to combine to things from S into a new thing from S. It's also associative.
08:26:09 <dminuoso> toddWannaCode: So it really is just "combine these two applicative functors" with something that is meaningful in the functor.
08:27:05 <reactormonk> anyone got a mapParallel for conduit streams?
08:27:31 <dminuoso> toddWannaCode: And based on the idea that it just combines two things, you should be naturally be able to tell what [1,2] <|> [3,4] might do without even trying it.
08:37:08 <mantasg> Hi guys. Could somebody help me with getting field value from "maybe record" using lenses?
08:37:29 <mantasg> As in something like this "_myField <$> (maybeRecord :: Maybe MyRecord)" but a lensy way
08:38:14 <remexre> Is there a helper for IO (State s a) -> StateT s IO a and its inverse? I checked Hoogle but didn't see anything
08:39:13 <toddWannaCode> dminuoso, it concats? Thanks, that really helped clear things
08:42:17 <mantasg> never mind, found it
08:47:12 <dminuoso> toddWannaCode: The question becomes: why does it concat? It could have also interleaved the arrays.
08:48:06 <dminuoso> toddWannaCode: And the answer is: Lists in Applicative Functor and beyond model non-deterministic computation (its just a fancy word for something simple). And within that realm, the logical thing is to "concatenate" them.
08:48:52 <dminuoso> toddWannaCode: Now you can do the same thing with Just 3 <|> Nothing. What does it do? Note: <|> could have also been defined as `const Nothing`. It would have sufficed all laws. But it wouldnt have made in the realm of Maybe.
08:52:16 <dolio> Interleaving isn't associative.
08:52:54 <dminuoso> dolio: Doh. :(
08:53:29 <remexre> maybe a sorted merge works better?
08:53:34 <remexre> (as an example)
08:55:30 <dminuoso> remexre: That would impose Ord into the containing type
08:55:52 <dminuoso> But I suppose it would still work, because its just a detail :P
09:00:21 <shafox> Haskell-ide-engine how do I plug it in atom or sublime editor ? 
09:00:24 <shafox> Any resources ?
09:10:19 <cocreature> shafox: I don’t think you can do that atm. somebody will have to write the integration for those editors.
09:11:07 <cocreature> afaik only vscode, neovim and emacs are supported with vscode being the one that is being maintained the most actively
09:11:53 <shafox> cocreature, ohh ok. Any alternative. I tried to use this https://atom-haskell.github.io/ but it never works as it claims. 
09:12:14 <shafox> Is nevoid a viable solution atm ?
09:12:41 <shafox> I want a text editor rather than a full-blown ide like IDEA etc. 
09:13:24 <cocreature> I use intero with emacs
09:13:37 <cocreature> but vscode is also an editor and relatively close to atom if you’re familiar with that
09:15:54 <shafox> cocreature, I have never tried emacs or vim for the matter. Would try vscode as I am familiar with sublime. 
09:18:29 <dminuoso_> So I have made my own state monad. How can I splice this with IO?
09:34:23 <geekosaur> make your own state monad transformer?
09:40:21 <oryx> hello?
09:40:39 <remexre> oryx: hi
09:40:53 <oryx> why do you use haskell? (curious)
09:41:09 <srhb> Because it's enjoyable.
09:41:35 <c_wraith> oryx, it makes it easier to follow all of those rules of things that you "should" do in your code, but often are a pain.
09:41:39 <remexre> It's the most "safe" language I can use
09:42:58 <c_wraith> oryx, Haskell makes it much easier to do things like prefer immutable values, separate code that does IO from business logic, write easily-reused pieces, etc.
09:42:59 <oryx> huh
09:43:33 <oryx> I've never used Haskell and was wondering if I should give it a try
09:44:05 <Denommus> oryx: why not?
09:44:20 <oryx> Its hard, thats what i've heard
09:44:20 <cocreature> oryx: give it a try. even if you don’t end up using it, you’ll learn a different way of solving problems which can also be useful in other languages
09:44:26 <c_wraith> there is also the fun side, with lots of "whoa, I didn't know you could use a type system to help you do *that* in it"
09:44:33 <remexre> If you've done functional programming before (JS funcprog counts), then definitely. If not, I wouldn't (personally) recommend it until you're comfortable with recursion and HOFs instead of loops, expressive types, etc.
09:45:07 <c_wraith> err. move my close quote over a couple words.
09:45:35 <Denommus> oryx: it's not that hard, it just requires a different mindset
09:48:25 <monochrom> If you heard it's hard, why do you want to try?
09:49:31 <c_wraith> if you heard it's hard, why wouldn't you want to try?
09:50:00 <c_wraith> (when did the desire to learn for its own sake become anathema?)
09:50:54 <oryx> How different is Haskell to other p-lingos like Java or Pascal or something?
09:52:27 <remexre> pure functional vs imperative is the biggest difference, and most other things stem from that
09:52:40 <c_wraith> you will have to spend a bunch of time unlearning "I know how to solve this problem".
09:52:51 <kosmikus> oryx: very
09:53:21 <c_wraith> but eventually you discover that all your knowledge from other languages still applies, just.. differently.
09:53:54 <monochrom> I have learned that the most efficient way to learn (and also to solve problems) is to get the easy part done and use that to make the hard part easy. Not to confront the hard part first for the sake of heroism.
09:56:47 <c_wraith> that is how, not why.
09:58:46 <dminuoso_> geekosaur: Guess a monad transformer is what I was looking for.
09:58:54 <dminuoso_> Thank you. Doesnt look complicated. :)
09:58:54 <monochrom> Why and how are the same thing just living at different levels.
10:03:56 <remexre> oryx: Part of the reputation Haskell has for being hard is also because things like "monad transformer" get bandied about; don't let the math words scare you, they don't turn out to be that hard once you have the "base of knowledge" to understand them
10:05:24 <remexre> And that'll build naturally as you read and write idiomatic Haskell
10:09:16 <royal_screwup21> how do I raise a number to a power?
10:09:38 <oryx> In terms of a compiler would I have to run Linux/Solaris in a VM in order to run a compiler? Or am I just fine using Windows (7)
10:09:46 <koala_man> > 2^8
10:09:49 <lambdabot>  256
10:09:52 <monochrom> There are 3 ways. x^y, x^^y, x**y
10:11:06 <ongy> :t (^^)
10:11:07 <lambdabot> (Integral b, Fractional a) => a -> b -> a
10:11:15 <ongy> :t (^)
10:11:15 <cocreature> huh I didn’t know about (^^)
10:11:17 <lambdabot> (Num a, Integral b) => a -> b -> a
10:11:34 <cocreature> why is that even a thing? the type signature of (^) is strictly more general
10:11:58 <monochrom> Because x^(-1) = 1/x may or may not be supported.
10:12:16 <monochrom> Or rather, x^^(-1) = 1/x.
10:12:22 <cocreature> ah makes sense
10:12:49 <ongy> > (1 :: Integer) ^ (-1)
10:12:52 <lambdabot>  *Exception: Negative exponent
10:13:08 <cocreature> it’s a shame that non-negative integers are such a pain
10:13:50 <ongy> 0^0
10:13:50 <monochrom> Perhaps we need a marker class for non-negative integral.
10:13:57 <ongy> > 0^0
10:14:00 <lambdabot>  1
10:14:10 <ongy> > 0^^0
10:14:12 <lambdabot>  1.0
10:14:36 <cocreature> the fact that ^ is overloaded keeps annoying me
10:14:39 <fizbin1> Does anyone have handy a good example of taking Warp (as in Network.Wai.Handler.Warp) and turning it into an actual web app with proper routing and logging and all? Basically, I'm looking for pieces to borrow as I cobble mine together.
10:14:58 <cocreature> overloaded on the exponent
10:15:04 <Tuplanolla> > (1 / 0) ^ 0
10:15:06 <lambdabot>  1.0
10:17:16 <royal_screwup21> what would be a good self starter project for a beginner to Haskell? (I've got a decent amount of programming experience in Python)
10:17:24 <Rembane> fizbin: I have some stuff using Servant.
10:17:33 <Rembane> fizbin: Not much logging though.
10:17:34 <Tuplanolla> Risch integration, royal_screwup21.
10:17:45 <Rembane> fizbin: https://github.com/Rembane/lemmingpants/blob/master/src/Lib.hs
10:17:47 <cocreature> fairfieldt: are you looking at implementing your own webframework? usually you let that take care of things like routing.
10:17:57 <cocreature> eh ^ fizbin 
10:18:03 <geekosaur> fizbin, I find myself wondering what's wrong with all the others (servant, spock, ...)
10:18:31 * Rembane failed at the reading roll.
10:18:55 <fizbin> (In other news, I've found an ugly hack that lets me abort processing of a web call when the client disconnects, but I had to dive into Warp internal functions)
10:19:45 <fizbin> geekosaur: Mostly that I don't know them? If there's a framework that wraps everything up in wai's Application type, that'd also work.
10:20:23 <cocreature> pretty much all webframeworks give you a WAI Application that you can throw at warp
10:21:41 <fizbin> cocreature: My haskell web experience prior to this has been programming against the Snap monad from snap-server. So maybe I've been off in the woods?
10:22:48 <cocreature> ah right, snap has its own server
10:23:13 <cocreature> servant, spock, scotty all use warp
10:23:59 <cocreature> or rather WAI which means you can run them using warp
10:26:21 <fizbin> Rembane: Ah, thanks for the (indirect) pointer to wai-logger... 
10:32:12 <dsal> @pl (\x -> x / 100000)
10:32:12 <lambdabot> (/ 100000)
10:32:23 <dsal> heh.  man...  It's the easy things that confuse me.
10:33:41 <Rembane> fizbin: No worries.
10:36:45 <mlehmk> @pl (\a b -> b $ a)
10:36:45 <lambdabot> flip id
10:37:19 <mlehmk> and I thought of using (&)
10:38:26 <c_wraith> @pl \x -> 1 + 1 + x
10:38:26 <lambdabot> (2 +)
10:38:53 <c_wraith> that plugin does some funny things
10:39:47 <mlehmk> @pl (\a b -> a & b)
10:39:48 <lambdabot> (&)
10:39:50 <mlehmk> >.<
10:46:26 <jared-w> mlehmk: the plugin uses a few simple rewrite rules to expand the given string into combinators and then does a tiny bit of fairly stupid simplifying
11:02:56 <sqooq> what is ".~"
11:03:12 <APic> What shall it be?
11:03:30 <phadej> it's `set` from lens
11:03:33 <monochrom> Depends on context. What did you import?
11:03:59 <sqooq> phadej, you're right, that's it
11:04:07 <sqooq> crap do I need to learn lens too
11:04:07 <sqooq> https://github.com/timbod7/haskell-chart/wiki/example-1
11:04:19 <sqooq> the easy code there is easy
11:04:29 <sqooq> but i want to change the size of the circles
11:04:34 <sqooq> (in my own code)
11:04:48 <phadej> ha! I knew you use Chart
11:05:06 <phadej> (maybe because I wrote some Chart code myself today)
11:05:09 <monochrom> Or you can choose to not read that code. You can always find some other code to read.
11:05:31 <sqooq> monochrom?
11:05:36 <monochrom> sqooq?
11:05:52 <sqooq> what do you mean "find some other code to read"
11:06:06 <phadej> sqooq: `points` returns PlotPoints http://hackage.haskell.org/package/Chart-1.8.2/docs/Graphics-Rendering-Chart-Plot-Points.html#t:PlotPoints
11:06:17 <monochrom> Sorry, what is unclear about that?
11:07:01 <phadej> you can do something like do { p <- points ...; plot $ p & plot_points_style . point_radius .~ 10; }
11:08:31 <phadej> sqooq: or less magically like in https://github.com/futurice/haskell-mega-repo/blob/master/checklist-app/src/Futurice/App/Checklist/Charts/Done.hs#L35
11:08:37 <sqooq> monochrom: Idk. is that directed to me?
11:08:44 <monochrom> Yes.
11:09:01 <sqooq> monochrom: well I don't understand I guess
11:09:22 <monochrom> Do you understand "find", "other", "code", and "read"?
11:09:30 <sqooq> phadej, am I right in thinking I can use chart with chart-gtk and allow the user to place points down with the mouse?
11:10:02 <sqooq> monochrom, I understand the syntax
11:10:03 <phadej> sqooq: hmm, I don't know if any of Chart backend supports interactivity. I only used Chart-diagrams backend
11:10:06 <sqooq> I don't understand the semantics
11:10:23 <sqooq> phadej, crap.
11:10:35 <sqooq> That's what I need to do.
11:10:36 <monochrom> Sure. Do you understand the semantics "find", "other", "code", and "read"?
11:11:28 <sqooq> I understand the individual semantics, I do not understand the combined semantics
11:11:36 <phadej> sqooq: I think it's possible, but far from trivial. Chart is magical, as it automatically scales the viewport from "data coordinates" to "output coordinates", and inverting that might be hard
11:12:10 <sqooq> hmm
11:12:18 <monochrom> If you don't know lens, don't look at code that uses lens. Find some other code that doesn't use lens to look at.
11:12:28 <sqooq> ooo
11:12:29 <monochrom> Or at least, that's an option.
11:12:40 <phadej> monochrom: all code which uses Chart uses lens, more or less
11:12:40 <sqooq> well I need to use whatever will help me achieve my goal
11:12:51 <monochrom> Then maybe don't use Chart.
11:13:05 <sqooq> but why not just take the time to understand lens
11:13:13 <sqooq> then I can understand all code that uses lens
11:13:23 <monochrom> I don't know. How much time? 1 month? 1 year?
11:13:42 <sqooq> does it take that long to understand lens to an adequate level?
11:13:45 <phadej> sqooq: maybe something based on diagrams? like https://hackage.haskell.org/package/dynamic-plot ?
11:14:02 <monochrom> "Do I have to learn lens?" The answer is no.  "Oh so do I have to not learn lens?" The answer is also no.  You always have an option.
11:14:04 <phadej> I haven't ever used it though, just found via googling
11:14:42 <phadej> sqooq: or at least you probably can look how it's implemented
11:14:50 <dmwit> monochrom: I have found this philosophy very liberating, especially in my go play recently, but it does seem to drive some people nuts.
11:15:21 <sqooq> phadej, well that seems focused on like vector-esque display that you can zoom in on. I don't care about zoom. Just need to draw points with mouse, have it make a line, then press a button to save that into a data representation.
11:15:54 <dmwit> monochrom: When reviewing games, sometimes my opponent says something like "but now I *have* to play here" and I say "you always have a choice" and for whatever reason that doesn't seem to go over well. ¯\_(ツ)_/¯
11:16:12 <monochrom> Yeah people want to be told what to do. Down to what colour for their underwear they wear for programming. (Who would care?)
11:16:31 <sqooq> monochrom: I'd like to learn lens, why not. But if it would really take a year to understand it, then perhaps I'm better off focusing my time elsewhere and keeping my lens studies to a minimum.
11:16:36 <dolio> Has to be metallic gold.
11:17:33 <phadej> sqooq: but you can check how it does zooming (if e.g. it zooms around the cursor, as your need is to get the position)
11:17:55 <sqooq> ok
11:18:14 <phadej> sqooq: I learned most of Haskell by looking how libraries are implemented
11:18:22 <monochrom> Of course in practice in most contexts there are enough contextual assumptions and implicit objectives that basically force your hands. We all acknowledge that.
11:18:47 <monochrom> But yeah in the game of Go and in the programming style of Haskell there are really multiple ways to win.
11:19:38 <sqooq> phadej, same
11:19:46 <sqooq> It often feels like a rabbit hole
11:20:07 <monochrom> Go in particular is such that even in the darkest moment, you still have a lot of choices, even after making explicit "the goal is to win". In particular there are counterintuitive short-term concessions and sacrifices that you can do to attain eventual victory.
11:20:10 <sqooq> "ok i need to understand this type, ok I need to understand this type class, ok I need to understand lens, ok I need to understand ..."
11:20:22 <sqooq> then I forget what I even started with 
11:20:44 <fizbin> I remember starting down the road to learning Haskell seriously by implementing the solution to one of the "Perl Quiz of the Week" quizzes over a decade ago.
11:20:47 <jared-w> Just do what I do and open a new tab for everything. You'll end up with like 80 and it represents your exact trail of thought. It's great
11:20:48 <monochrom> Depth-first search leads to XY problems. XY problems lead to rabbit holes.
11:20:55 <geekosaur> it is ever so. see also "yak shaving"
11:21:14 <sqooq> phadej, this library seems adequate, it dynamically updates the display, they have a gif where a tangent line goes over a curve. So it should be able to update the graph based on my mouse information right? And I'm guessing mouse information has to do with gtk?
11:21:18 <fizbin> I'm not entirely sure that code would even compile on modern GHC.
11:21:19 <mbrock> I started with Haskell in 2004 and only used lens for the first time this year :)
11:21:38 <sqooq> mbrock: I started 3 months ago
11:21:43 <monochrom> Anyway, my strategy for learning lens is to postpone and procrastinate until someone teaches a bit of it to me.
11:22:47 <lavalike> I wish you went on: …and rabbit holes read to rabbits.
11:22:51 <mbrock> basically lens is nice and easy to use, very principled, consistent, concise, and convenient.  If there's a problem, it's that you can get exposed to some of the magic necessary to make it work, through type errors that are confusing
11:22:52 <lavalike> *lead
11:24:17 <monochrom> Anyway this is also why I am unsupportive of the "Hi I'm a beginner, I want to learn Haskell by doing a project."
11:24:28 <monochrom> It is a rabbit hole, not a learning process.
11:24:40 <jared-w> monochrom: what's the alternative? :p
11:24:48 <mbrock> if you have a code base that uses lens in a nice and sensible way, you should be able to look at the recurring patterns in that code and get a feeling for how to use the library
11:24:58 <monochrom> Follow a more conventional textbook and/or course.
11:25:12 <maerwald> depends on the project
11:25:17 <tomasmu> i'm trying to understand ("a" ++) "b" and (++ "a") "b", i'm guessing currying is involved, but can't figure out what's really happening here
11:25:19 <monochrom> Build up breadth on the basics first.
11:25:32 <jared-w> Well, I mean, I do that too but not everything has a textbook and project involved or an easy way to figure out the basics first
11:25:45 <jared-w> :t ("a" ++)
11:25:46 <lambdabot> [Char] -> [Char]
11:25:56 <jared-w> :t ("a" ++) "b"
11:25:58 <lambdabot> [Char]
11:26:03 <jared-w> :t (++ "a")
11:26:05 <lambdabot> [Char] -> [Char]
11:26:08 <monochrom> Well yeah I'm using most people's sense of "project" such as "w00t web app!" rather than like "write a binary search tree insert algorithm. that's a project"
11:26:14 <mbrock> tomasmu: those are operator slices, and e.g. the first one is equivalent to (\x -> "a" ++ x) "b"
11:26:43 <jared-w> They're basically super terse anonymous functions
11:26:47 <maerwald> most projects these days have a rather high amount of fancyness (use more GHC extensions! use lens! use lots of odd libraries and combinators!)
11:26:50 <tomasmu> operator slices you say, that's something new
11:27:15 <jared-w> > fmap (+2) [1..5] -- They're kinda common, actually
11:27:17 <lambdabot>  [3,4,5,6,7]
11:27:22 <phadej> sqooq: I'd say yes. Mouse is definitely from GTK, but how things are combined, you have to check the source
11:27:56 <mbrock> tomasmu: sorry wrong terminology, they seem to be called operator sections :) https://wiki.haskell.org/Section_of_an_infix_operator
11:27:59 <geekosaur> I think you mean sections, nto slices
11:28:03 <geekosaur> heh
11:28:33 <tomasmu> funny, i got to the same wiki page when i googled for operator slices :D
11:28:41 <sqooq> phadej, here I go jumping into the hole!
11:28:47 <fbacchin_> /server irc.brasnet.org 6667
11:28:54 <phadej> sqooq: good luck!
11:29:04 <mbrock> maerwald: after doing a few projects in Haskell, I'm in a mode of using more extensions, lens, etc, to cut down own boilerplate, make code more concise, and so on
11:29:05 <phadej> let the types guide you
11:29:29 <maerwald> mbrock: yeah, I consider that cancer
11:29:55 <mbrock> I consider it extending my environment to make it more pleasant and efficient to use
11:29:57 <tomasmu> okay, so i'm assuming the second would be equivalent to (\x -> x ++ "a") "b" then
11:30:04 <jared-w> Being able to be more declarative about the code and more efficient is cancer? :p
11:30:18 <tomasmu> this reminds me of lambda calculus i glanced at the other day
11:30:18 <maerwald> mbrock: that's why the haskell ecosystem is so unpleasant, because every library is now a whole new DSL
11:30:42 <monochrom> Or rather, pleasant.
11:30:46 <jared-w> maerwald: DSLs of abstract concepts are exactly what gives the libraries such generic utility that allow them to be so useful
11:30:49 <maerwald> depends on the DSL
11:30:57 <maerwald> most I found unpleasant
11:31:01 <jared-w> Depends on who designed it, really ;)
11:31:03 <maerwald> diagrams was an exception, very pleasant
11:31:18 <geekosaur> maerwald, if that bothers you, you're using the wrong langauge. this pretty much directly follows from Haskell's design
11:31:21 <jared-w> Most people just huck together DSLs and libraries without considering laws of behavior from a mathematical perspective
11:31:35 <geekosaur> ^ this is a more serious consideration
11:31:38 <monochrom> I don't actually know where to draw the line between library and DSL.
11:31:54 <maerwald> geekosaur: not really
11:31:56 <geekosaur> or even from a programmer friendliness perspective
11:32:08 <sqooq> DSL?
11:32:17 <geekosaur> (and occasionally from a UX perspective *glares at xmonad's StackSet*)
11:32:22 <mbrock> I don't know how using language extensions and lens makes my projects into unpleasant DSLs? Mostly I'm working on application-level projects that nobody will even depend on
11:32:23 <jared-w> But, consider lens. Very simple concept ('getters and setters'); write up some laws, figure out how those laws work, and then implement behavior that follows those laws. You can derive lens from nothing just doing that
11:32:59 <maerwald> mbrock: well, it's also about contribution. Most project are so weird, that I lose interest very soon
11:33:20 <jared-w> And if someone had just said "let's do some getters and setters yo" and smashed some random shit together, it would've been altogether unpleasant to use. As it is, the worst thing you can possibly complain about lenses is the complexity of its genericness and the abundance of ascii operators for common operations
11:33:24 <mbrock> sqooq: it means "domain-specific language", and sometimes means a full-blown language implementation, and sometimes just a library made to feel like a kind of sublanguage
11:33:47 <jared-w> sqooq: for example, "do notation" is nothing more than a DSL for monads and applicatives
11:33:53 <maerwald> jared-w: lens was created to write compilers, partly, afair
11:33:59 <mbrock> maerwald: well, for me, using lens and language extensions is a way to try to make the code less weird and more readable
11:34:01 <maerwald> and hence its complexity and power
11:34:47 <jared-w> I've always heard it described from the "getter/setter, laws, then abstraction" perspective of edward but perhaps I'm missing some bit of history regarding them? 
11:35:25 <sqooq> understood
11:35:28 <jared-w> I don't think the compiler writing bit is what resulted in its complexity and power; generalizing an intuitive concept almost always results in a ridiculous amount of power and a fair bit of complexity
11:35:48 <maerwald> jared-w: well, I asked him, at least what he really needs it for
11:36:01 <geekosaur> complexity and power just comes from elaborating the implications of what was originally a simple-looking concept
11:36:06 <mbrock> the main application I'm working on is full of nested record updates. Doing it without lens in Haskell98 would be in some sense "easier to understand", but it would also make the code way more verbose, tedious, and actually harder to understand
11:36:13 <geekosaur> but, the closer you look, the more detail emerges. it's fractal.
11:36:15 <maerwald> geekosaur: many people disagree
11:36:18 <mbrock> ...harder to understand for someone who understands the domain but may not care at all about Haskell syntax...
11:36:18 <phadej> lens spun off while implementing `linear`
11:36:27 <maerwald> but no one was able to come up with something simpler
11:36:30 <phadej> be able to say `v ^. x`
11:36:37 <jared-w> I'd imagine that "massive, complicated data structures" are always going to want easier ways to tinker with tiny bits of it :p
11:36:44 <monochrom> You may as well also remind us "rockets were invented for going to the moon" or maybe the other one "rockets were invented for going to war".
11:37:08 <monochrom> After some time the historical origin loses its significance.
11:37:17 <jared-w> maerwald: idk I think a lot of people agree with the sort of thing geekosaur is mentioning. You see it /everywhere/. Physics in particular, math, all of Science really...
11:37:20 <MarcelineVQ> rockets were inventened because they were cool
11:37:53 <monochrom> Wait, I thought they were hot.
11:38:12 <geekosaur> maerwald, as to something simpler: lots of people did. fclabels, semantic editor combinators, ...
11:38:12 <Gurkenglas> No, they were cool, then they were invented, now they are hot
11:38:21 <monochrom> Ah OK!
11:38:45 <phadej> oh, I remembered wrong, first Kmett made lenses for scala ermine, and then haskell lenses for linear: ref https://theinitialcommit.com/2017/01/10/edward-kmett/
11:38:58 <geekosaur> heck, lens is itself just one elaboration of van Laarhoven lenses
11:39:12 <maerwald> jared-w: I don't know how that's related to the specific discussion
11:39:18 <maerwald> that's just a very broad argument
11:39:52 <monochrom> What specific discussion? :)
11:40:06 <monochrom> Perhaps you're referring to cancer.
11:40:31 <monochrom> Yeah, cancer tissues look more detailed as you zoom in. :)
11:41:12 <mbrock> I do secretly dream of a Haskell spinoff that just moves a bunch of extensions into the language per se, and a bunch of libraries into the standard, so users don't have to think about ByteString, Text, lens, etc etc as external stuff to activate
11:41:19 <Psybur> I have a MonadIO variable. What does MonadIO mean? Can't wrap my head around it.
11:41:26 <jared-w> Simple concept: gravity. Look closer: quantum gravity(if even that? Nobody really knows).  Simple concept: Light travel's damn fast. Look closer: quantum physics, relativity, etc.  Simple concept: "get and set stuff". Look closer: lenses.  Simple concept: "Some types of recursion are somewhat repetitive". Look closer: folds, fix, etc.
11:41:26 <mbrock> but I recognize the political difficulties in such a thing :)
11:42:06 <mbrock> Psybur: it basically means "any monad in which you can do IO actions"
11:42:12 <monochrom> Also as you zoom in you see less and less cancerness. By the time you reach the DNA, you can't even tell a cancer cell from a "normal human" cell (or "normal rabbit" cell if you're talking about rabbits).
11:42:21 <Psybur> And I guess variable isnt even the right word to use in haskell since I cant redefine things :D?
11:42:46 <maerwald> jared-w: still unrelated
11:42:49 <monochrom> So at that level you can only apply broad cellular biology arguments, not even specific human value-judgment arguments!
11:43:01 <jared-w> Psybur: people use the word 'value' for most places where someone might want to say 'variable'
11:43:06 <jared-w> (iirc)
11:43:11 <mbrock> Psybur: well, variables in math are just the arguments to a function (commonly called e.g. x) that "vary" unlike constants (like pi)
11:44:09 <monochrom> No, variables in math are names and/or placeholders.
11:44:25 <monochrom> For example "x + 1 = 4" they call that "x" a variable.
11:44:56 <monochrom> Sometimes the context is "solve for x". Some other times it is "prove or disprove: the whole sentence is true for all x".
11:44:58 <geekosaur> monochrom, actually it's not difficult to spot most cancer cells by the DNA, because chromosomes get duplicated and fragmented
11:45:01 <mbrock> wikipedia sez: ``The concept of a variable is also fundamental in calculus. Typically, a function y = f(x) involves two variables, y and x, representing respectively the value and the argument of the function. The term "variable" comes from the fact that, when the argument (also called the "variable of the function") varies, then the value varies accordingly.''
11:45:11 <monochrom> Oh haha yikes.
11:45:59 <Psybur> How is MonadIO a different than IO a?
11:46:07 <Psybur> I thought IO was a monad Dx
11:46:09 <Tuplanolla> I doubt anything that calls `f(x)` a function, mbrock.
11:46:28 <geekosaur> Psybur, MonadIO is a convenience for monad transformer towers
11:46:44 <monochrom> Applying math to physics does make variables more varying, e.g., "the kinectic energy varies over time". At which point an equation in physics is stating an invariant.
11:46:52 <geekosaur> without it, to get from the end of the tower that you have to the IO at the other end, you need a chain of "lift . lift . ..."
11:46:59 <geekosaur> with it you use one liftIO
11:48:17 <mniip> hmm
11:49:14 <Psybur> Is it normal for an API to return a MonadIO? Wondering if Im starting in the right spot haha
11:49:15 <monochrom> We need a textbook that doesn't mention [Char] ever. (Instead, it uses Text.)
11:50:01 <monochrom> I have a cunning plan! From now on if a book uses mainly [Char] we call it a "stringbook" not a "textbook"! >:D
11:50:21 <koala_man> lol
11:50:23 <geekosaur> Psybur, you don't returrn a MonadIO. you have an operation *in* some MonadIO. which, practically, means that it does a liftIO for you instead of making you do it.
11:50:43 <monochrom> Example! "Bird's Haskell stringbook covers monad transformers."
11:51:23 <mniip> BS book
11:52:05 <geekosaur> Psybur, and what you gain from this is an operation that works the same way whether you are working in IO, or StateT Foo IO, or SpockM, or any other monad transformer based in IO
11:52:40 <Psybur> geekosaur, do you have any recommended reading on the subject?
11:52:50 <sqooq> hmm I'm having trouble building a library
11:52:56 <geekosaur> @google monad transformers step by step
11:52:58 <lambdabot> https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/monad-transformers-step-by-step.pdf
11:53:03 <sqooq> added the extra-deps recommended everytime but it just goes further and further
11:53:13 <sqooq> different versions require other version constraints
11:53:17 <Psybur> geekosaur, thanks
11:53:20 <sqooq> stack solver doesn't work
11:54:03 <geekosaur> Psybur, more fundamentally, I don;t know about good resources for *thinking* in a Haskell way, which I suspect is something more helpful here
11:55:17 <Psybur> geekosaur, I'm converting my python algotrader to haskell. I learned a lot of python making it, so I imagine if I get it close to parity to the python version I'll have learned a lot of haskell :D
11:55:58 <geekosaur> Psybur, it might or might not. syntax it would teach you, available functions it would teach you. but you will likely end up with imperative-looking Haskell, which is far from idiomatic
11:56:28 <Limeth_> Why am I getting the error `*** Exception: Prelude.read: no parse
11:56:32 <geekosaur> which is what I was getting at with "thinking in Haskell"
11:56:32 <Psybur> geekosaur, I've been doing a lot of functional scala, so lets hope that helps :D
11:56:37 <Limeth_> oops, meant to write the whole message
11:56:48 <Psybur> Ive at least been learning to think functionally, maybe not thinking haskelly ;D
11:56:56 <geekosaur> Limeth_, under what circumstances?
11:57:01 <Limeth_> Why am I getting the error `*** Exception: Prelude.read: no parse` when executing `read $ show ["testtest"]` in GHCI?
11:57:08 <Limeth_> There. sorry about that.
11:57:32 <geekosaur> Limeth_, read does not determine its type based on the string; it determines how to parse the string based on its type.
11:57:50 <geekosaur> ghci, not knowing anything about what type you intended, defaults it to () ("unit type")
11:58:24 <geekosaur> :t read $ show ["testtest"]
11:58:26 <Limeth_> geekosaur: Ah, right, I see, `read $ show ["testtest"] :: [String]` works fine!
11:58:26 <lambdabot> Read a => a
11:58:35 <Limeth_> Thanks!
11:59:00 <APic> 😎
11:59:16 <sqooq> crap I can't even get my project to build if I try to use that library
12:00:40 <geekosaur> Psybur, it's not just functionally. it involves laziness, which actually has a major effect on how you write some things; monad transformers are a concept that basically don't translate to other languages unless they were derived from Haskell, and again have a major effect on how you write things
12:02:59 <maerwald> monad transformers are just a library, not really haskell-ish
12:07:32 <sqooq> how do I fix build errors
12:11:28 <hexfive> /* */
12:11:33 <hexfive> err
12:11:35 <hexfive> {- -}
12:17:13 <mbrock> monochrom: I guess we also need a prelude that doesn't use strings for basic things like read and show
12:18:32 <royal_screwup21> How do I 'take' a value from a list  and assign the resulting to value to another variable? array2=take 1 array1 gives me "parse error on input ‘=’"
12:18:51 <mbrock> sqooq: it takes a while to learn to be friends with the compiler and its errors... there are some tricks though
12:19:01 <mbrock> sqooq: I don't know maybe you're asking something more specific :)
12:19:30 <mbrock> sqooq: but one really nice thing is the "hole" feature, which means that anywhere you would write an expression, you can just write _, and that means "I don't know what to write here, please help"
12:19:50 <mbrock> sqooq: and the help you get is that the compiler says "oops, at this _, you need something with the following type: ..."
12:20:04 <phadej> and you have many, something _foo _bar
12:20:36 <phadej> though the more constrained they are, the better
12:21:04 <mbrock> ah, yeah, that's useful, I forgot about that. Usually I call make from emacs and then use the shortcut to jump to the next error (C-x `) until everything works
12:21:52 <mbrock> I've spent the whole day jumping to the next error while doing major refactorings all over...
12:23:08 <mbrock> it's kind of an acquired taste to go for a whole day with a program that won't even compile
12:23:13 <mnoonan> royal_screwup21, it should be fine (perhaps with a "let" before array2, depending on the context)
12:23:33 <royal_screwup21> mnoonan: yup, the "let" got me there
12:24:09 <mbrock> but most Haskellers seem to enjoy it, because a lot of the time you can just go through type errors one by one, and when everything compiles again, it usually works correctly again
12:24:27 <dolio> But not an acquired taste to do the same thing with a program that would have no chance of actually working, even though the compiler didn't say so?
12:24:56 <mbrock> yeah, both are acquired tastes, and after you acquire one of the tastes you probably find the other taste really disgusting
12:26:12 <mbrock> and anyway, GHC can defer type errors until runtime, so :-)
12:36:36 <Gurkenglas> Will that impact speed if unsafeCoerce would have been safe?
12:48:45 <Limeth_> Why do people write commas (,) on the beginning of a new line? :|
12:49:41 <kadoban> My guess is that so the diffs are better in version control when you add/remove stuff.
12:49:43 <byorgey> Limeth_: because it looks nice, and makes it harder to forget them
12:50:13 <byorgey> as for diffs, I think it's not really any better or worse than putting commas at the end
12:50:40 <kadoban> It kind of looks awful though until you get used to it? Well the diffs has been my only guess. Then only the line you added/removed is different. as it's clearer what happened.
12:51:00 <thoughtpolice> Gurkenglas: I don't understand the question. "if unsafeCoerce would have been safe", and you prove that, well, you'd just use unsafeCoerce and be done. Deferred type errors are a different beast entirely, so talking about "speed" is weird.
12:51:02 <byorgey> kadoban: that's true if you put commas at the end too.
12:51:14 <Limeth_> I am not used to it at all, and can confirm, it does look awful
12:51:38 <kadoban> byorgey: Then when you add to the end of the list, the now-second-to-last element looks like it's changed too. (unless you use --word-diff or something)
12:51:43 <Tuplanolla> I tried it for a while, but regressed back to punctuation at the end, Limeth_.
12:52:09 <byorgey> kadoban: ah, but if you put commas at the beginning of the line, then you have that same problem with the beginning of the list instead =)
12:52:24 <thoughtpolice> DTEs effectively change the meaning of your program by taking any term that results in a type error, and synthetically creating a coercion that says "This is actually legitimate", except the coercion *value* is actually `error`. Which makes your program explode.
12:52:27 <Limeth_> Tuplanolla: Good to know. I was wondering whether there was a _greater_ reason to put them at the beginning, but guess not.
12:52:30 <kadoban> byorgey: True :)
12:53:04 <Gurkenglas> thoughtpolice, if you take a situation where unsafeCoerce is safe, you could replace it with id instead and defer type errors. Does this still crash at runtime because it effectively inserts error, or does it do nothing because it effectively inserts unsafeCoerce, or does it do a runtime check on whether the types match, which takes time and type annotations?
12:53:17 <thoughtpolice> Yes, it crashes, because it inserts error
12:53:35 <byorgey> Limeth_: my most serious answer is that I think it aids readability to have structural elements like punctuation, parentheses, operators, etc. at the beginning of lines.  You can scan down the left side of a program to see the overall structure, and then look at the content on the right side
12:53:57 <thoughtpolice> e.g. if you do 'isUpper True', then you get a type error, as Char is not equal to Bool. GHC creates a value, a coercion, that instead says "Actually, yes, Char is equal to Bool" (written `Int ~ Bool`). The coercion is a value -- its *type* is the statement `Int ~ Bool`
12:54:03 <byorgey> Limeth_: but it's definitely a matter of taste.
12:54:50 <thoughtpolice> However, this coercion's value is just `error`, so it'd look like `bool2char = error "Type error at <location>: Char is not the same as Bool" :: Char ~ Bool`.
12:55:04 <thoughtpolice> When you look at that coercion -- you try to use it as a proof of equality, in other words -- your program explodes.
12:55:33 <digitalkiwi> I still can't get over monochrom comparing haskell to cancer
12:55:49 <thoughtpolice> Gurkenglas: Section 2 of this paper (the first few paragraphs of Sec 2) is very readable and easy to follow and basically uses this exact example: https://www.microsoft.com/en-us/research/wp-content/uploads/2012/01/icfp12.pdf
12:57:05 <monochrom> Wait, when did I compare Haskell to cancer?
12:57:30 <max22> hi
12:57:50 <monochrom> Like "Haskell is like cancer. You can't rid of it from the world"? >:)
12:58:23 <monochrom> "Haskell is like cancer. Every company will eventually have it."
13:02:05 <mnoonan> Limeth_, fwiw we have a pretty large C++ codebase that uses leading commas in some places (especially initializer lists)
13:02:14 <mnoonan> I think I'll never be ok with SPJ
13:02:19 <mnoonan> 's leading-; style, though
13:02:37 <Limeth_> ah, that would make sense then
13:02:39 <monochrom> There was a time I did that too to help the indenter.
13:03:11 <Limeth_> What do the `{-# LANGUAGE OverloadedStrings #-}` lines mean?
13:03:48 <kadoban> Limeth_: They turn on language extensions. They're pragmas.
13:03:51 <monochrom> But your life is not complete until you see my http://lpaste.net/311978 :)
13:04:07 <geekosaur> that is a pragma enabling the OverloadedStrings extension, which allows string literals to be any type that has an IsString instance
13:04:21 <geekosaur> much as numeric literals have any type with a Num instance
13:05:14 <Limeth_> I see, thanks
13:05:19 <Limeth_> monochrom: Oh god, why
13:05:39 <monochrom> And this: https://twitter.com/UdellGames/status/788690145822306304
13:05:55 <digitalkiwi> monochrom what is the meaning of this lpaste
13:06:02 <geekosaur> someone wanted to write python in lisp >.>
13:06:11 <monochrom> Joke.
13:06:22 <geekosaur> although it wil always remind me of perl programmers hacking around bugs in cperl-mode >.>
13:07:50 <mbrock> that Java example looks pretty clever to me, I wonder if it's "objectively" a pretty good standard
13:08:12 <monochrom> It's just annoying to edit.
13:08:24 <mbrock> editing is fundamentally annoying :P
13:08:36 <Limeth_> The Java Example: When you want to code in Python but are stuck with Java
13:08:45 <Limeth_> "Example"
13:08:51 <mbrock> isn't it more like Lisp than Python?
13:09:08 <Limeth_> The left side looks like python to me
13:09:22 <monochrom> Most Lisp people don't put opening parentheses to the far right.
13:09:23 <Limeth_> It wouldn't be half bad if the right side was gotten rid of
13:10:02 <mnoonan> in the vein of "X as Y".. https://github.com/matt-noonan/haskell-as-templates/blob/master/fizzbuzz.cpp#L257-L264
13:12:37 <Limeth_> Hehe
13:21:38 <Psybur> Lets say I have a list of granularity 1: [1,2,4,6,7,9,10,11] and a list of granularity 5: [5,10,15]. How would I get a map of [(5,[6,7,9]),(10,[10,11]),(15,[])]
13:23:57 <kadoban> Psybur: Unclear what the goal is. Something about splitting into intervals based on the "5" list?
13:24:12 <Psybur> Yes
13:25:04 <kadoban> My first guess would be a recursive thing based on splitWhile
13:25:39 <kadoban> Or maybe it's not called that ... what's its actual name
13:25:57 <kadoban> Oh, span
13:26:35 <Psybur> kadoban, yeah that sounds like it would work
13:38:29 <berndl> Anyone familiar with Lambek's theorem?
13:39:10 <dolio> Yes.
13:39:13 <dmwit> monochrom: https://twitter.com/aisamanra/status/779057953542242304
13:39:38 <dolio> Although I'd only heard it called a 'lemma'.
13:39:52 <dolio> Too easy to be called a theorem, I guess.
13:39:57 <berndl> dolio: If F(X) = X and X is initial, then X is the least fix point of F. Question: under what ordering is it the least?
13:41:17 <monochrom> Yeah dmwit I've seen the SPJ style before.
13:41:27 <dmwit> monochrom: There are two other styles there.
13:42:14 <monochrom> Oh haha
13:42:17 <dolio> Oh, well, that's not the statement I'd heard. For algebras in something like sets, it's the smallest set.
13:42:38 * ski . o O ( <https://ncatlab.org/nlab/show/initial+algebra+of+an+endofunctor#LambeksTheorem> )
13:43:25 <dmwit> Psybur: How much do you care about efficiency?
13:43:25 <monochrom> The Lambek theorem (lemma?) I heard is about how catamorphism gives you pattern matching (but linear-time blowup).
13:43:29 <dolio> The other trivial way to interpret it is that the arrows of a category induce a preorder, so being initial is being 'least' in that preorder by definition.
13:43:59 <dolio> It is the 'least' F-algebra in that preorder.
13:44:02 <monochrom> And now, let's also talk about Euler constants and numbers!
13:44:14 <Psybur> dmwit, I would prefer the least amount of latency possible :D
13:44:14 <dolio> Or, a least F-algebra.
13:44:16 <dmwit> > let f xs ys yspan = [(y, filter (\x -> x >= y && x < y+yspan) ys) | y <- ys] in f [1,2,4,6,7,9,10,11] [5,10,15] 5
13:44:19 <lambdabot>  [(5,[5]),(10,[10]),(15,[15])]
13:44:34 <berndl> dolio: I thought about that, but would mean there is always an arrow between any two objects.
13:44:38 <dmwit> Psybur: If you know the lists are sorted...
13:44:45 <Psybur> Yes they will be
13:44:52 <dolio> And yeah, the Lambek lemma that'd I'd heard is that if X is an initial F-algbra, then X is isomorphic to F(X).
13:44:53 <Psybur> That doesnt seem right dmwit heh
13:45:07 <dmwit> > let f xs ys yspan = [(y, filter (\x -> x >= y && x < y+yspan) xs) | y <- ys] in f [1,2,4,6,7,9,10,11] [5,10,15] 5
13:45:09 <lambdabot>  [(5,[6,7,9]),(10,[10,11]),(15,[])]
13:45:15 <Psybur> Yeah thats it
13:45:40 <dolio> berndl: The definition of an initial object is that there exists a unique arrow to every other object in the category.
13:45:51 <ski> s/other //
13:45:58 <dolio> Oh, yeah.
13:46:01 <dolio> Every object.
13:46:09 <monochrom> dmwit: I am unable to understand the e.e. cummings style.
13:46:33 <kadoban> Not to be picky, but yspan seems redundant and "filter" could be bad if the lists are potentially long.
13:46:54 <Psybur> > let f xs ys yspan = [(y, filter (\x -> x >= y && x < y+yspan) ys) | y <- ys] in f [1,2,4,6,7,9,10,11] [5,15] 5
13:46:57 <lambdabot>  [(5,[5]),(15,[15])]
13:47:09 <Psybur> Hmm
13:47:13 <monochrom> I have also never checked out and E. E. Cummings stuff. It is an unfamiliar name.
13:47:20 <monochrom> s/and/any/
13:47:30 <dmwit> > let range lo hi xs = span (<hi) . dropWhile (<lo) $ xs; f xs [] yspan = []; f xs (y:ys) yspan = let (ls, hs) = range y (y+yspan) xs in (y,ls) : f hs ys yspan in f [1,2,4,6,7,9,10,11] [5,10,15]
13:47:32 <lambdabot>  <Integer -> [(Integer,[Integer])]>
13:47:36 <dmwit> > let range lo hi xs = span (<hi) . dropWhile (<lo) $ xs; f xs [] yspan = []; f xs (y:ys) yspan = let (ls, hs) = range y (y+yspan) xs in (y,ls) : f hs ys yspan in f [1,2,4,6,7,9,10,11] [5,10,15] 5
13:47:38 <lambdabot>  [(5,[6,7,9]),(10,[10,11]),(15,[])]
13:47:50 <dolio> berndl: Note that in something more like type theory, "smallest" doesn't necessarily make sense, either.
13:48:02 <dmwit> Psybur: This way is significantly more efficient if the lists are sorted.
13:48:05 <dmwit> (And lazier!)
13:48:13 <dolio> Because you might not think of types all being made up of some common stuff, such that one of them could contain the least amount of that common stuff.
13:48:31 <berndl> dolio: if you define the ordering A <= B to mean there is at most one morphism from A to B, the I can see how the initial object will be the smallest.
13:48:32 <dolio> So in that case, the only way to interpret it is the initial way.
13:48:49 <Psybur> dmwit, thanks a lot.
13:48:57 <dolio> I guess you could count values or something, still.
13:49:10 <dmwit> kadoban: Depends what's wanted, I guess. I took "granularity 5" to mean "I only want numbers between the given one and 5 bigger". I could also imagine "I want all numbers between the first and the second" but then why mention the granularity at all in the question?
13:49:24 <berndl> dolio: s/at most/exactly/
13:50:02 <dolio> berndl: Nah, I don't think it matters if there's more than one. 
13:50:26 <dolio> Note that the arrows are F-algebra homomorphisms, not just arbitrary functions on the carrier sets.
13:50:31 <kadoban> dmwit: Not sure, yeah it does depend.
13:50:50 <ski> berndl : .. reminds me a little bit of "Category Theory and Concrete Universals" by David P. Ellerman in 1998-05 at <http://www.ellerman.org/wp-content/uploads/2012/12/Erkenntnis-Concrete-Universals.CV_.pdf>
13:51:08 <ski> (that's philosophy related. cave canem)
13:51:11 <dmwit> :t Data.List.chop
13:51:12 <lambdabot> error:
13:51:13 <lambdabot>     Not in scope: ‘Data.List.chop’
13:51:13 <lambdabot>     Perhaps you meant one of these:
13:51:15 <berndl> dolio: I think it does. Say A and B are two fix points and there is only one arrow from A to B but two arrows from B to A.
13:51:18 <platz> If i have a prism or traversal for a Rec { _field1 :: Maybe int } e.g.  field1 :: Prism' Rec Int , then is it possible to set field1 in value of (Rec Nothing) ? When I have (Rec $ Just 1), the 'over' and 'set' combinators set the value, but when there is (Rec Nothing), 'set' leavs the Record alone
13:51:20 <dmwit> :t Data.List.Split.chop
13:51:22 <lambdabot> ([a] -> (b, [a])) -> [a] -> [b]
13:53:01 <dmwit> monochrom: e e cummings is famous for writing poetry where he put words just wherever "felt" right on the page.
13:53:27 <monochrom> Oh, that.
13:53:32 <phittacus> Hello. I have a function for looping in State monad, however, it isn't tail-recursive, so there might be a problem. It looks approximately like this `step a = do  {...} >>= step`. I can move monad into the function argument, so it will be `step m a`, but it's quite ugly, is there anything better i can do?
13:54:03 <glguy> phittacus: Why would it need to be tail recursive?
13:54:13 <ski> phittacus : why do you think you need tail recursion ?
13:54:58 <phittacus> Well, wouldn't otherwise every call consume stack?
13:55:12 <platz> or should I instead have a Lens' Rec (Maybe Int) ?
13:55:28 <platz> a lens to a maybe seems less composable
13:55:35 <ski> phittacus : calls don't consume stack
13:55:45 <dmwit> phittacus: Not necessarily. From the wiki: "In Haskell, the function call model is a little different, function calls might not use a new stack frame, so making a function tail-recursive typically isn't as big a deal—being productive, via guarded recursion, is more usually a concern."
13:55:51 <dmwit> https://wiki.haskell.org/Tail_recursion
13:56:43 <Gurkenglas> platz, setting the prism and traversal on a Rec Nothing won't do anything. A prism lets you make a Rec from an Int, though.
13:56:50 <dmwit> hm, that wiki page seems a bit odd in places
13:56:52 <dmwit> such as foldr
13:56:57 <dolio> berndl: What about it?
13:56:58 <dmwit> "such as foldr, where the recursive call to foldr occurs as an argument to (:)"
13:57:02 <dmwit> ?src foldr
13:57:02 <lambdabot> foldr f z []     = z
13:57:02 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:57:41 <ski> (did they mean for a particular call of `foldr' ?)
13:57:56 <phittacus> dmwit: If it's like that then I might leave it as it is for now, thanks
13:57:57 <dmwit> Dunno. It's not clear to me what they mean there.
13:58:04 <glguy> Perhaps the author was thinking of the argument 'f' as the replacement for (:)
13:58:12 <glguy> and just got a little confused
13:58:15 <ski> could be
13:58:43 <dmwit> (...but `f` is not necessarily a dat aconsutroct.r)
13:58:48 <dmwit> Wow, I made a hash of that one.
13:58:57 <bitemyapp> that'd be a bad hashing function
13:59:02 <ski> phittacus : if you're going to be bulky anyway, then tail-recursion can be important. but not for being incremental
13:59:08 <monochrom> Just blame it on the USB cable between your keyboard and your computer :)
13:59:16 <phittacus> ski:  > calls don't consume stack, why wouldn't they normally?
13:59:40 <dmwit> monochrom: Oh, right, where has my gaming training gone? LAAAAAAG
13:59:42 <platz> Gurkenglas: ok, that's that at least agrees with what I'm seeing.  So for a Rec { _field1 :: Maybe Int } , I could make a Lens' Rec (Maybe Int).. is that weird ?
13:59:44 <ski> just blame it on the glitchy nerves between your brain and your fingers
14:00:28 <monochrom> Anyway I think the current question on tail recursion is an XY problem.
14:00:36 <ski> phittacus : no. even in Scheme (a strict language), calls don't consume stack. setting apart another computation to be done later consumes stack, though
14:01:10 <monochrom> No one ever pursues tail recursion for its own sake. There is always a real agenda, one that's better served by some better dichotomy than "is it tail recursion?"
14:01:10 <ski> phittacus : in Haskell, forcing the scrutinee of a `case', in order to later select a branch, also consumes stack
14:01:52 <ski> monochrom : well, that makes me want to pursue tail recursion for its own sake :)
14:01:53 <platz> a better use case is Rec { _recCategory :: Maybe Category }; Category { _name :: Maybe Text }
14:02:17 <ski> (i suppose the real agenda is being contrarian, then)
14:02:27 <platz> I'm trying to figure out the best optics for this situation
14:02:32 <Gurkenglas> platz, nope not weird. That's how "at :: Ord k => k -> Lens' (M.Map k a) (Maybe a)" works.
14:02:35 <digitalkiwi> it's better than python approach of no tail recursion
14:02:58 <jared-w> Why?
14:03:06 <Gurkenglas> platz, why isn't Rec just a type alias of Maybe Category?
14:03:21 <platz> Gurkenglas: assume there are more fields in Rec
14:03:21 <jared-w> Tail recursion is a way to get rid of stack overflow and a potential optimization into a for-loop
14:03:36 <dolio> Lacking proper tail recursion is anti-OO.
14:03:43 <Gurkenglas> platz, is only ever one of the fields of Rec just?
14:03:49 <dolio> That's why.
14:03:50 <jared-w> If you're running the language in an interpreter you don't need tail-recursion to be able to examine the context and determine whether or not you can apply the correct optimizations or what not
14:04:02 <monochrom> Ah, but it's also a way to cause stack overflow and a potential barrier to optimizing into a for-loop.
14:04:16 <platz> Gurkenglas: no, there could be many Maybe fields in Rec
14:04:27 <Gurkenglas> You mean, many just fields
14:04:29 <jared-w> dolio: how does lacking tail recursion make something anti-OO? :p
14:04:35 <platz> sure
14:05:01 <dolio> Because you need to add a primitive looping construct to your language instead of having objects send each other messages.
14:05:02 * ski thinks tail calls shouldn't be left to optimization
14:05:03 <Gurkenglas> As in, values like Rec (Just 1) (Just 2) can arise in your programs
14:05:13 <platz> Gurkenglas: correct
14:05:51 <dolio> Yes, it's not an optimization.
14:05:51 <Gurkenglas> lenses into each field sound like what you want. Maybe provides a _Just prism.
14:06:44 <jared-w> dolio: and tail recursion means objects can just send each other messages rather than relying on a primitive looping construct?
14:07:03 <platz> I just wasn't sure I could use the _Just prism on these lenses
14:07:26 <dolio> Yeah. Looping can be defined by writing methods.
14:07:31 <monochrom> If "send message" translates to "procedure call, potential mutual calls".
14:07:34 <platz> in the composable case
14:07:46 <platz> where I want to set _name in Rec { _recCategory :: Maybe Category }; Category { _name :: Maybe Text }
14:08:11 <Gurkenglas> You'll probably want "category ?~ 2 :: Rec -> Rec" where category is Lens' Rec (Maybe Category)
14:08:31 <monochrom> But consider distributed objects and message passing instead.
14:08:45 <Gurkenglas> Whoops, Category isn't Int anymore
14:09:23 <dolio> object 3 { def for(f) { f(3) ; 2.for(f) } }
14:09:30 <Gurkenglas> 'category . _Just . name ?~ "asd"', which will do nothing if the category doesn't exist
14:09:38 <dolio> Repeat for all ordinals.
14:09:47 <Gurkenglas> *the Category
14:10:03 <L8> jared-w, hey again!
14:10:29 <platz> if that works for a Rec (Just (Category Nothing)), then it sounds perfect
14:10:54 <jared-w> L8: hey!
14:11:06 <platz> Gurkenglas: thank you
14:11:09 <jared-w> You'll have to remind me where I'm supposed to recognize your name; I'm quite hungry and thus absent minded at the moment :)
14:11:21 <L8> :)
14:11:39 <L8> we've talked few days ago about this go game board thing
14:11:54 <jared-w> oooh right, that. Did you ever get a solution you liked?
14:12:07 <L8> just finished, want to code-review?
14:12:17 <L8> https://repl.it/Klkv
14:12:29 <dolio> class nil extends list { def each(f) {} } ; class cons(a,b) extends list { def each(f) { f(a) ; b.each(f) } }
14:13:20 <jared-w> dolio: is that smalltalk or just an OOP-like pseudocode?
14:13:27 <dolio> Pseudocode.
14:13:41 <dolio> Smalltalk doesn't have braces, and has more colons, I think.
14:14:25 <jared-w> right, that makes sense; it didn't look like smalltalk but also definitely didn't look like any other OOP :p
14:15:36 <dolio> Anyhow, that's your slam dunk argument for OO people.
14:15:47 <monochrom> No one really pursues OOP for its own sake. They always have their own real agenda, they just shoehorn part of OOP into their own hidden agenda.
14:16:18 <dolio> If they don't implement proper tail calls, they can't do OO-based looping, so they are making concessions.
14:16:38 <monochrom> Or shoehorn part of tehcnique-of-the-day into their own hidden agenda.
14:16:45 <dolio> And forcing you to write unnatural things.
14:17:02 <jared-w> dolio: makes sense. I'll keep that one in my pocket the next time I'm talking to a super angry and aggressive OOP-fanboy :p
14:17:08 <monochrom> By this measure, the manager type is actually much more honest and forthcoming in admitting to increase profit.
14:18:59 <dolio> Like, it's pretty natural for a bunch of objects to just call one another arbitrarily, if that's how you're organizing things, but instead you have to invert that into a managed loop, or you risk overflowing the stack.
14:20:38 * ski . o O ( internal vs. external iteration )
14:20:47 * ski . o O ( delimited continuations )
14:21:26 <dolio> Yeah, all those languages with delimited continuations but not proper tail calls.
14:21:35 <monochrom> Anyway, do you recall where on Haskell Wiki is the IO explanation using a free monad?
14:22:18 <tomasino> Okay, I seriously need a service to come play with my crazy kid so I can get back to LYAH
14:23:00 <Lazersmoke> How good is GHC at converting things like (\() -> a) to a? I have a function that threads a piece of state through its internals, but I also want to have version that does not thread the state through. Am I incurring any overhead (compared to removing the state entirely) by simply setting the state to () and making all the functions that would otherwise consume the state just (const whatever)?
14:23:22 <dolio> Too good, probably.
14:23:56 <jared-w> tomasino: daycare? :p
14:24:12 <lyxia> I don't think State () gets optimized easily
14:24:27 <jared-w> L8: the getState type signature being almost 50 lines away from the function is a bit odd. I've never really seen that
14:24:45 <monochrom> You haven't tried the other option, forall s. State s a
14:24:52 <Lazersmoke> it's not actual state monad, just passing through recursion.
14:25:09 <L8> jared-w, in the actual quiz they 'provide' the getState implementation
14:25:14 <tomasino> jared-w: so expensive! gah. :)
14:25:16 <monochrom> OK? forall s. s -> a
14:25:33 <Lazersmoke> like `pureVersion x y = statefulVersion (\() -> x) (\() a b -> y a (b ())) ()`
14:25:53 <jared-w> L8: gotcha.
14:25:59 <Lazersmoke> oh that could be interesting
14:26:14 <digitalkiwi> http://neopythonic.blogspot.com.au/2009/04/tail-recursion-elimination.html
14:26:15 <digitalkiwi> http://neopythonic.blogspot.com.au/2009/04/final-words-on-tail-calls.html
14:26:16 <L8> that whole 'visualized board' part was just for actually testing the code and explaining somehow the quiz
14:26:21 <Lazersmoke> will GHC actually throw out things it can prove will never be able to be accessed because of the forall?
14:26:28 <L8> but yeah, I agree it looks weird :)
14:26:48 <monochrom> I don't know. But you can benchmark and you can read the core code etc etc
14:26:55 <glguy> () -> a   and   a    don't behave the same, and in particular if your definition is parameterized so that it's  r -> a , and not specifically () -> a   then the generated code won't make any assumptions about ()
14:27:14 <glguy> unless inlining or specialization happens, which may or may not
14:27:44 <Lazersmoke> I have an entirely different function. doStuffState vs doStuff, where doStuff doesn't even menntion () in its type signature
14:27:59 <jared-w> L8: normally I would suggest pulling out surrounding into its own function and cords into its own function since it's just much cleaner if you ever want more functionality
14:28:00 <monochrom> digitalkiwi: The text there is so small.
14:28:24 <digitalkiwi> the person who wrote it has a tiny intellect, so quite fitting
14:28:29 <Lazersmoke> I think I'll look at the core code, forgot that was possible lol
14:28:50 <digitalkiwi> cmd++
14:28:57 <monochrom> Oh haha yikes.
14:29:07 <jared-w> I also dislike using map over fmap, even when using lists, because if you want to change the code to use Vectors or some other container later you'll need to change the map to fmap. If it's fmap from the start, you can just change the imports and type signatures and then bam, free speedup
14:31:11 <jared-w> isOccupied is also a really nice fold waiting to happen
14:36:23 <L8> jared-w, how would you change 'isOccupied' to be just a one big fold?
14:36:35 <L8> also, you're right about the fmap, learnt something new, thanks :)
14:36:48 <jared-w> I'm not quite sure, honestly, but my spidy sense is tingling pretty hard on that function :p
14:37:39 <L8> I had the same feeling at the beginning but I just couldn't see a reasonable way doing fold
14:37:42 <L8> so just went with this
14:38:00 <L8> same goes with line 23 btw
14:39:44 <L8> jared-w, could I remove lambda somewhere around the code? any cleaner syntax I could use? any bad practice besides using map?
14:40:13 <jared-w> `isOccupied x []` is better off as `isOccupied _ []`
14:40:42 <L8> right!
14:42:21 <jared-w> cords = filter (`Set.notMember` visited) surrounding   avoids a lambda
14:42:45 <jared-w> anytime you have `concat $ map` you can probably use concatMap
14:43:45 <hpc> or (>>=)
14:44:05 <L8> what's >>= ?
14:44:13 <L8> same as concatMap?
14:44:16 <hpc> a more general concatMap
14:44:42 <L8> in what class it's defined?
14:44:52 <hpc> :t (>>=) -- Monad
14:44:54 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:45:06 <L8> cool :)
14:45:21 <ski> @src [] (>>=)
14:45:21 <lambdabot> xs >>= f = concatMap f xs
14:45:31 <jared-w> >>= is the monadic bind function :p
14:45:54 <jared-w> The $ in your main function is redundant as well
14:45:54 <dsal> What is "-- Monad" after :t?  I've not seen that.  Seems to do something.
14:46:01 <hpc> it's a comment
14:46:04 <L8> jared-w, btw, why have you surrounded Set.notMember with backticks?
14:46:19 <jared-w> L8: it converts the function to infix
14:46:35 <L8> why do we need infix in this case?
14:46:48 <L8> oh right
14:46:48 <dsal> Oh, I see.  :t spits the comment back out with the request.  That confused me.
14:46:53 <L8> took me a minute.
14:47:04 <jared-w> So (`Set.notMember` visited) becomes an operator slice (wording?) that doesn't require a lambda :)
14:47:14 <L8> yep, that was the reason I used lambda
14:47:16 <L8> because of the ordering
14:48:37 <hpc> jared-w: operator section, yep
14:48:38 <L8> jared-w, but in terms of clean code (or understandable code), is doing backticks is more cleaner/clearer than full lambda like in my case?
14:49:19 * ski thinks so
14:50:35 <jared-w> It depends but I also tend to think so
14:51:03 <hpc> it's a bit of an edge case here imo
14:51:05 <jared-w> I'd find it even clearer if you imported notElement unqualified and then were able to use (`notMember` visited)
14:51:20 <L8> right
14:51:22 <hpc> go with whatever you'll be able to read in a month
14:51:46 <L8> not gonna read this code probably again in my life
14:51:55 <digitalkiwi> famous last words
14:52:08 <dsal> If you're not going to see it again, make it epic.
14:52:25 * ski . o O ( .. why not monic ? )
14:52:30 <L8> gonna paste it in careercup together with the stupid question I got
14:52:49 <jared-w> Can anyone else figure out how to turn isOccupied into a fold nicely?
14:53:01 <jared-w> It's bugging me at this point that I can't figure it out
14:53:18 <ski> jared-w : definition ?
14:53:35 <jared-w> https://repl.it/Klkv in here, line 25
14:54:07 <glguy> jared-w: You just want to inline the definition of all?
14:54:11 <jared-w> isOccupied :: State -> [State] -> Bool.  isOccupied _ [] = False; isOccupied x xs = all (\state -> case state of E -> False; _ -> state /= x) xs
14:54:36 <L8> <jared-w> The $ in your main function is redundant as well
14:54:38 <jared-w> meh I guess that would be the only thing the fold would be doing...
14:54:51 <L8> right, wasn't redundent when I was debugging stuff :)
14:55:34 <jared-w> I just feel like the _ [] = False bit and the case could be simplified more
14:56:19 <monochrom> "all" is a fold. But it relies on giving you True upon the empty list.
14:56:51 <monochrom> If you absolutely want False then it is an exception. Exceptions can't be simplified.
14:56:58 <ski> jared-w :  isCaptured cord = selfState `notElem` [O,E] && ...
14:57:23 <jared-w> makes sense. I guess if I really wanted to simplify it I could make a falsy all function
14:57:30 <ski> jared-w : also  state `notElem` [E,x]
14:58:39 <ski> why do you want `False' on the empty list ?
14:59:01 <jared-w> That's the behavior of the isOccupied function in the code ¯\_(ツ)_/¯
14:59:34 <jared-w> (can't be occupied if there's no list of potential States that could be occupied)
15:01:48 <jared-w> ski: oooh, nice
15:02:47 <dsal> Man, this thing doesn't have Testing.QuickCheck
15:03:25 <dsal> Er, Test.
15:04:58 <jared-w> L8: still following the conversation? :p
15:05:13 <L8> 18<ski18> jared-w :  isCaptured cord = selfState `notElem` [O,E] && ...
15:05:20 <L8> part of my brain does understand what he mentioned
15:05:25 <elpfen> If i have a function that's like, foo = x*x where x = sum [1..5], is sum [1..5] evaluated once or twice?
15:05:30 <L8> but the other one is not communicating with it.
15:05:41 <jared-w> I'll write it out in full on your thing
15:06:02 <ski> oh, it's L8's paste ?
15:06:12 <L8> yeah
15:06:14 <jared-w> yeah, I probably should've made that a tiny bit clearer
15:06:23 * ski was wondering ..
15:07:05 <ski> (i vaguely seem to recall having a more .. advanced conversation with you, the other day)
15:07:08 <monochrom> elpfen: Once per what?
15:07:41 <jared-w> lol I have a weird smash-up of knowledge. Some bits of my knowledge veer into grad/post-grad territory and some bits make me look like I'm a bumbling beginner idiot
15:07:56 <elpfen> monochrom: once during the evaluation of foo
15:08:01 <monochrom> Yes.
15:08:17 <elpfen> Ah ok. I was misunderstanding lazy evaluation then
15:08:52 <L8> jared-w, in the meanwhile I think I've applied most of the comments, and changed a bit things
15:09:00 <jared-w> Anyway, L8, the `isCaptured` is broken up into two halves of the &&. The left hand side (selfState `notElem` [O,E]) says "False if selfState is either O or E, True otherwise".  False && x is always false, True && x is always x.
15:09:22 <ski> jared-w : no worry. it's a wonder i can remember the rough state of Haskell knowledge for more than a few denizens here
15:09:34 <elpfen> I assumed that because x is a function, the whole thing is re-evaluated whenever it's called. But that's not true? Because of referential transparency?
15:09:47 <monochrom> But x is not a function.
15:09:59 <jared-w> So all that remains is putting the otherwise clause on the right hand side of the &&. Does that make sense, L8?
15:10:16 <elpfen> so when something is declared with where it's evaluated?
15:10:27 <jared-w> ski: I have the same issue (except with ekmitt, I just assume he knows everything :p )
15:10:37 <dsal> elpfen: Are you asking because you want to understand performance implications?
15:10:49 <elpfen> Yeah
15:10:55 <monochrom> No, "where" still complies with lazy evluation.
15:11:39 <L8> jared-w, yep
15:11:40 <jared-w> L8: you can also replace (Set.fromList []) with Set.empty
15:15:32 <L8> jared-w, https://repl.it/Klkv/2
15:16:00 <L8> also changed getStates from let..in to where
15:16:37 <jared-w> Nice. I prefer where but it's completely an optional thing
15:17:17 <L8> since I've moved 'surrounding' to be a standalone function it seemed more right
15:17:44 <monochrom> w00t, who needs lambdabot when repl.it let's you paste a huge file and runs ghci right there. :)
15:18:14 <jared-w> L8: your isOccupied function can be:
15:18:29 <jared-w> isOccupied _ [] = False; isOccupied x xs = all (`notElem` [E,x]) xs
15:18:29 <monochrom> Remember to remind me, next time when someone asks "the best way to install haskell", to answer "repl.it" :)
15:18:58 <jared-w> @tell monochrom next itme when someone asks "the best way to install haskell," answer with "repl.it"
15:18:58 <lambdabot> Consider it noted.
15:18:59 <trigone> hi everyone!
15:19:18 <monochrom> Um, that's not what I mean :)
15:19:32 <jared-w> oh it's not? :p
15:20:08 <L8> jared-w, right!
15:20:14 <L8> way nicer
15:20:37 <monochrom> @type elem
15:20:39 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
15:20:43 <jared-w> L8: I also pulled out your entire if clause in getStates into a isSameState function in your where clause
15:21:11 <digitalkiwi> monochrom did you read those
15:21:22 <trigone> anyone here knowledgeable on using the conjunction of mtl and lenses as described in this lecture? https://www.youtube.com/watch?v=GZPup5Iuaqw edwardk advised it to me, and it was very enlightening (thanks again if you're around)
15:21:37 <monochrom> Sorry, what is "those"?
15:21:45 <L8> jared-w, agree :)
15:21:45 <digitalkiwi> guido
15:21:55 <monochrom> Yes I read the second one.
15:22:05 <trigone> whats a guido?
15:22:07 <c_wraith> trigone, if that's the presentation I think it is, not much has been done on that topic since then.
15:22:18 <L8> jared-w, although wait
15:22:30 <L8> you've just extracted getState self == getState c ?
15:22:32 <digitalkiwi> a character from FFX
15:22:41 <digitalkiwi> also the inventor of python
15:22:42 <trigone> c_wraith: what do you mean? that it's stale or that it's the latest improvement?
15:22:43 <L8> isSameState :: State -> State -> Boolean ?
15:22:58 <jared-w> L8: yeah. `isSameState x = getState self == getState x`
15:23:11 <trigone> it's called next-level mtl
15:23:16 <c_wraith> trigone, well, a quick check tells me it's not the same presentation. so my answer is irrelevant
15:23:18 <L8> just making (==) to be really concrete :)
15:23:29 <monochrom> trigone: I thought the code shown in the talk already works here and now?
15:23:32 <jared-w> Why not? It reads more clearly. if/then/else is usally pretty ugly unless the if-clause is a single predicate
15:23:38 <trigone> ha lol, would you have the link of the other?
15:23:52 <trigone> monochrom: i don't understand your sentence
15:23:57 <digitalkiwi> omg, google definition for it
15:23:58 <digitalkiwi> a man, especially an Italian American, regarded as vain, aggressively masculine, and socially unsophisticated.
15:24:04 <digitalkiwi> is this a joke by the Go developers?
15:24:09 <L8> jared-w, the right function name would be 'isCordsSameState'
15:24:12 <L8> or something like that
15:24:31 <L8> anyway, that whole if clause is indeed ugly
15:25:00 <L8> I'd prefer to find a nicer way to reduce it instead of just extracting the predicate
15:25:09 <jared-w> It gets much better if you just write the if/then/else on a new line
15:25:48 <trigone> monochrom: why do you imply i said it wasn't usable yet?
15:25:50 <jared-w> Although the predicate is really not that bad, it just is going to necessairly read a bit weird because it's not saying what the predicate is but rather how to test the validity of the predicate; hence why I extracted it
15:25:58 <monochrom> I misread.
15:26:03 <trigone> oh ok
15:27:21 <digitalkiwi> trigone we were talking about TCE and I said something about at least we have it unlike python and then linked http://neopythonic.blogspot.com.au/2009/04/tail-recursion-elimination.html http://neopythonic.blogspot.com.au/2009/04/final-words-on-tail-calls.html and well...the comments are worse than most youtube and the content than most jake paul... :<
15:28:18 <jared-w> L8: although one thing I just realized is that your entire if/then/else is designed to deal with the singular case of handling the one coordinate that is your own coordinate that's passed into the function (so that it becomes ignored)
15:28:22 <trigone> lol tail call religion
15:28:29 <dsal> jared-w: It doesn't work in this repl (I sent them a note), but:  quickCheck (\x xs -> isOccupied x xs == isOccupied' x xs)     is super handy for coming up with a new implementation.
15:28:37 <dsal> +   instance Arbitrary State where arbitrary = oneof $ map return [B, W, E, O]
15:29:05 <jared-w> dsal: nice. I love quickCheck so much. I gotta get better at using it
15:29:47 <dsal> It's awesome for this exact use case.  You have something that you know works, but you want to make a better one without changing the behavior.
15:31:18 <jared-w> L8: actually disregard what I said about that single case thing :p
15:31:34 <trigone> digitalkiwi: the author of those posts is the one who invented python?
15:31:46 <digitalkiwi> yes
15:32:00 <digitalkiwi> guido van rossum
15:32:51 <trigone> wow he's so incredibly ignorant of fp that's so weird
15:33:24 <trigone> who's jake paul?
15:33:58 <L8> jared-w, so my last question would be
15:34:02 <trigone> it's a very bad case of blub developper (or is it blob?)
15:34:13 <L8> I'm still trying to understand my change from concat $ fmap to (>>=)
15:34:16 <jared-w> it's blub :p
15:34:30 <jared-w> L8: that one is simple. concat $ fmap is equivalent to concatMap
15:34:44 <L8> right
15:34:53 <L8> and >>= is same?
15:34:58 <digitalkiwi> some annoying youtube content creator that you should be thankful to have not encountered
15:35:04 <jared-w> The >>= instance for lists happens to be exactly concatMap. However, most instances of >>= can be thought of as being very similar in behavior to a "concatMap for X data type"
15:35:07 <trigone> thx jared-w :P anyway eveyone knows blub is used for actual programming, not like the CS-useless blob language ^^
15:35:39 <trigone> digitalkiwi: i trust your word
15:35:45 <digitalkiwi> blob is a thing in computing
15:35:48 <L8> jared-w, can you give me an example for other type than list?
15:35:58 <digitalkiwi> especially wrt databases
15:36:00 <trigone> digitalkiwi: you mean like a blob of data?
15:36:29 <trigone> digitalkiwi: some sort of untyped thing you try to serialize or sth?
15:36:49 <digitalkiwi> https://en.wikipedia.org/wiki/Binary_large_object
15:37:31 <trigone> good to know :)
15:37:31 <hpc> gonna be honest, i did not know blob was an acronym until just now
15:38:08 <trigone> c_wraith: i was wondering something about this mtl+lenses technique
15:38:12 <jared-w> > Just "hi" >>= Just "stuff"
15:38:12 <lambdabot> Thank you for your honesty.
15:38:14 <lambdabot>  error:
15:38:14 <lambdabot>      • Couldn't match expected type ‘[Char] -> Maybe b’
15:38:14 <lambdabot>                    with actual type ‘Maybe [Char]’
15:38:29 <jared-w> oh whoops
15:38:33 <digitalkiwi> I can't recall what a blub would be, what are you thinking of
15:38:54 <trigone> http://wiki.c2.com/?BlubParadox
15:38:57 <hpc> blub is the hypothetical language that's just barely good enough for most things
15:38:58 <ski> (binary large undefined behaviour ?)
15:39:12 <trigone> what's this "thank you for your honesty"?
15:39:15 <jared-w> L8: Regardless,  >>= is what do notation desugars to
15:39:23 <hpc> languages that are simpler are bad because they lack some essential feature
15:39:35 <hpc> languages that are more sophisticated are bad because who needs that feature anyway
15:39:42 <ski> (Bepelt Lissoflagellate Unvaleted Blood ?)
15:40:21 <trigone> hpc: simplicity is a relative notion. to me haskell is simpler even than python to code in. i'd rather say, languages who lack abstraction are barely good enough
15:40:41 <digitalkiwi> huh
15:40:53 <trigone> hpc: oh nevermind i didn get your were quoting
15:40:58 <hpc> trigone: careful, soon you'll be admitting that certain languages are better for certain tasks than others
15:41:03 <hpc> and that way lies sensibility
15:41:19 <jared-w> And of course there's lisp and scheme, the cannonical "simple as shit" languages. Of course, due to metaprogramming, they're incredibly powerful even to this day :p
15:41:23 <trigone> hpc: lies sensibility?
15:41:53 <ski> as opposed to sense, perchance
15:42:06 <jared-w> trigone: it's sensible to admit that certain languages are better for things than others is what he meant
15:43:26 <digitalkiwi> I too wasn't sure if you meant it is a lie or it shows
15:44:24 <soLucien> on Windows how can I remove old GHC and packages installed by Stack? There seems to be no command for this
15:44:27 <trigone> jared-w: ok thx :)
15:45:23 <jared-w> soLucien: you can nuke your ~/.stack folder (however I'm not quite sure where exactly that folder is on windows)
15:45:25 <kadoban> soLucien: There isn't one, no. You can save your config from ~/.stack/ wherever that is on windows and delete the rest to start over, but then you'll have some rebuilding to do.
15:45:43 <hpc> it's probably %appdata%/.stack
15:45:58 <soLucien> jared-w there's a lot of folders which have packages in them
15:46:08 <jared-w> Or you can manually go inside the "~/.stack directory" and find the versions of ghc, etc, and delete those
15:46:15 <jared-w> ghc, etc., that you don't want**
15:46:26 <monochrom> Another possibility is %appdata%\stack
15:46:53 <monochrom> Because for example cabal on Windows uses %appdata%\cabal i.e. without the dot.
15:47:53 <monochrom> You may as well delete everything. Because library binaries compiled by-and-for an older GHC version is utterly irrelevant to a newer GHC version.
15:48:12 <monochrom> The newer GHC doesn't even see them.
15:48:20 <soLucien> so far i found appdata
15:48:28 <trigone> jared-w: arent those metaprog languages hard to use in large programs? it feels a bit like how some say dynamic typing allows more flexibility, but it doesn offer much safety. ofc metaprog is probably more useful than dynamic typing. in short i'm not sure metaprog scales very well, at least not without serious control. following the example of  IO i'm imagining maybe it'd be possible to hav a special functor into which metaprog wou
15:48:42 <glguy> Also keep in mind that there can be library dependencies across different stackage resolvers, so you can't just delete one resolver's directory; you have to delete them all
15:48:50 <digitalkiwi> glguy !
15:49:10 <monochrom> But if you're paranoid, first switch to a transactional file system so you can always rollback a bunch of delete operations. :)
15:49:13 <trigone> (though that's just random thinking)
15:49:23 <glguy> Hi, digitalkiwi.
15:49:38 <ski> trigone : ".. following the example of  IO i'm imagining maybe it'd be possible to hav a special functor into which metaprog wou"
15:49:39 <digitalkiwi> glguy You might not remember me I used to be DigitalKiwi but I had to go incognito (fogobogo gave the suggestion) 
15:49:47 <trigone> digitalkiwi: i just realized it was kiwi and not wiki
15:50:02 <digitalkiwi> that's probably why they don't know it's me
15:50:06 <trigone> ski: *would be possible, but nowhere else
15:50:26 <ski> trigone : have you looked into Template Haskell yet ?
15:50:33 <monochrom> Wait a second. "digitalkiwi" is more incognito than "DigitalKiwi"? :)
15:50:44 <digitalkiwi> it's all lowercase so it makes me invisible
15:51:00 <glguy> Who said that?
15:51:01 <ski> monochrom : upper case letters are more noticable in a crowd, mostly consisting of lower case ?
15:51:12 <monochrom> I guess that also explains why I'm invisible too.
15:51:19 <soLucien> %appdata%\stack - 1.2 GB , C:\sr (STACK_ROOT) -  1 GB , ~\AppData\Local\Programs - 3GB
15:51:32 <soLucien> that's a lot of haskell :D
15:51:48 <hpc> it adds up
15:51:49 <trigone> ski: no, and i actually don't know much at all about metaprog. as i said it was a random idea, probably not applicable; the general point would be to limit to some part of the program the ability to metaprog. not sure if lisp and co allow some form of restriction on that...
15:52:01 <monochrom> GHC takes a 1GB.
15:52:03 <kadoban> soLucien: A couple of gigs isn't much. GHC is *big* and libraries and etc. are too.
15:52:04 <digitalkiwi> fogobogo suggested it because the ops in #archlinux always get mad at me but they leave him alone and he's almost if not more nonsensical and ot
15:52:08 <trigone> ski: but TH is on my tolearn list
15:52:37 <soLucien> i don't mind that , but i have the feeling much of it is not used
15:52:49 <soLucien> if i want to start over from scratch
15:52:58 <soLucien> should i simply remove all these folders
15:53:02 <kadoban> If you don't mind it, then what are we doing?
15:53:10 <ski> trigone : depending on what you mean, part of the point of it is to try to not have such limits
15:53:14 <kadoban> That probably sounds rhetorical, but it's not meant to be.
15:53:17 <trigone> ski: you often come across lowercases in crowds? though since i never saw any i guess it proves they're good at hiding themselves :P
15:53:35 <ski> trigone : otoh, the actual metaprogramming code will be in `TExpr' or something like that
15:53:46 <trigone> ski: it's a type?
15:53:52 <kadoban> But yes, you can delete stack's caches in their entirity. But it'll mean more rebuilding and downloading when you want to do anything. Also you have to make sure you save your config.
15:54:01 <ski> trigone : yes. i might misremember the spelling, though
15:54:47 <trigone> ski: is TH used more than for generating boilerplate?
15:54:56 <ski> trigone : i suppose if you made a histogram of the content of the mesages here, lower case would be dominating over upper case
15:55:25 <hpc> don't quote me on it, but i think there's an sql library that uses template haskell to check that queries match a table layout
15:55:25 <glguy> trigone: The fact that you don't remember coming across any lowercase letters in crowds is telling
15:55:44 <trigone> glguy: isn it
15:55:47 <monochrom> The past 10 minutes have been purely lowercase nicknames.
15:55:52 <monochrom> Err nevermind.
15:55:58 <hpc> who said that
15:56:10 <L8> jared-w, thanks for the comments and help!
15:56:14 <monochrom> soLucien! Please change to purely lowercase so my sentence is true! >:)
15:56:32 <L8> it was quite nice solving this thing in Haskell.
15:56:33 <trigone> monochrom: won't erase the past though :P
15:56:48 <trigone> you'll have been wrong for eternity
15:57:16 <monochrom> However, it was true everyone's name started with lowercase. soLucien is just being camel case. It's fine.
15:57:27 <ski> well, the truth-value of the sentence varies with the current time
15:57:32 <hpc> nobody's ever seen a camel in a crowd either ;)
15:57:39 <jared-w> L8: no problem. ski also helped a lot too :)
15:58:19 <trigone> hpc: depends where you live, i think
15:58:50 <jared-w> I've definitely seen a camel in a crowd before :p
15:59:03 <trigone> ski: including the truth value of your latest sentence?
15:59:15 <jared-w> Course this was near the sahara...
15:59:35 <digitalkiwi> monochrom but it does point out the fact that person with a not all lowercase name is being singled out
16:00:02 <ski> trigone : well, i'm not sure that's quite the same thing
16:00:19 <trigone> digitalkiwi: mostly because you started the dogmatism about invisible all-lowercaseism
16:01:12 <digitalkiwi> he just because I made it a known reality doesn't mean it's not a reality
16:03:10 <digitalkiwi> hey*
16:04:14 <trigone> is there a way to write a bind-like operator which would work on two differently newtype-wrapped monadic values (well, one wrapped moadic value, and a kleisli that outputs a differently wrapped monadic value), provided we gave a way to unwrap the first and wrap the result to give it to the second? (am i making sense?) this with the condition that both wrapped monads could have different class constraints onto them too...
16:04:50 <trigone> digitalkiwi: reality of the belief is not reality of what is believed :p
16:05:44 <trigone> ski: what is not the same thing?
16:08:13 <ski> trigone : an indexial expression, and a vague referent ?
16:08:57 <dmwit> trigone: ETOOVAGUE
16:09:23 <trigone> ski: what are you answering to?
16:09:28 <dmwit> Certainly I can write `Identity a -> (a -> [b]) -> [b]`.
16:09:36 <dmwit> Does this help you?
16:09:49 <trigone> dmwit: well no i meant polymorphically, with a typeclass
16:10:04 <dmwit> Sure. But then you have to implement the typeclass.
16:10:31 <dmwit> I mean instantiate, not implement.
16:11:05 <dmwit> But honestly it sounds like you are just looking for `lift` or something.
16:11:06 <dmwit> :t lift
16:11:08 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
16:11:23 <dmwit> Or maybe just looking for "make your monadic values more polymorphic".
16:11:23 <trigone> dmwit: i don't think so but maybe
16:11:52 <dmwit> :t get >>= tell -- look ma, I combined monadic effects from two different kinds of monad!
16:11:54 <lambdabot> (MonadWriter w m, MonadState w m) => m ()
16:13:03 <dmwit> Dang. I up-front declared that the question was too vague to answer, and then fell into exactly the trap I was trying to warn others about, namely answering so many variants of the question that your answer is meaningless.
16:13:10 <dmwit> dmwit--
16:15:09 <trigone> dmwit: but you have sort of lost the knowledge that your expression is half strictily monadwriter-based and half strictly state-based. i'm wondering if there's no way to encode in your global expression's type that it's built out of typeclasses which are used in a very independent way, isolated...
16:16:22 <dmwit> Oh, yes, that's easy.
16:16:25 <trigone> BUT, after having started this discussion, i realized it was kinda logical that the type of (get >>= tell) wudn keep memory of it's internal structure. among others it permits writing it differently if needed, as long as the type (and the functionality) remain identical
16:16:37 <dmwit> :t (get, tell)
16:16:38 <lambdabot> (MonadWriter w m, MonadState s m1) => (m1 s, w -> m ())
16:18:19 <trigone> dmwit: hm well ... i don't know what to do of this actually, let me think
16:18:46 <dmwit> Good idea. =)
16:19:00 <trigone> what idea?
16:19:15 <dmwit> "Let me think."
16:19:22 <trigone> lol
16:20:23 <dmwit> <3
16:22:27 <jchia_> I'm trying to use clang-pure in stack nightly-2017-09-06. (It works under lts-9.1.) I think that means it needs to work with Cabal 2.0. So, I made one change, to the Setup.hs (The last commit on https://github.com/jchia/clang-pure/commit/9a666bd9d820ca6dbc5bc1ad51d64bd8510baab7), but when I try to use this github version as an extra-dep git package in a nightly-2017-09-06 project, I get this error when trying to "stack build clang-pure"
16:22:28 <jchia_> : http://lpaste.net/358255
16:22:57 <jchia_> They can't find one of the source files src/Language/C/Clang/Internal/FFI.c. What can I do to start investigating or fixing this error?
16:23:41 <dmwit> Well... does that file exist?
16:24:12 <jchia_> It is one of the source files in the package. I don't know whether it physically exists as experienced by the build tools. I can't tell which directory they are searching in.
16:24:26 <dmwit> The repo you linked doesn't appear to have it.
16:24:43 <dmwit> https://github.com/jchia/clang-pure/tree/9a666bd9d820ca6dbc5bc1ad51d64bd8510baab7/src/Language/C/Clang/Internal # no FFI.c here
16:25:02 <jchia_> ah, it comes from FFI.hsc
16:25:06 <trigone> if m1 is (X m) and m2 is (Y m), and there's a morph :: X m a -> Y m a (which could be say the method of a typeclass Class x y m), would it be possible to end up with something like expr :: (Class X Y m, MonadWrite w (Y m), MonadState s (Y m)) => ???
16:25:23 <jchia_> so, maybe the hsc processing is getting skipped somehow?
16:25:29 <dmwit> jchia_: Uh, really? I thought hsc files get turned into hs files, not c files.
16:25:59 <trigone> i think the type of expr would be vaguely similar to a free monad for which each functor/monad would be different (and maybe they could be stored in a type-level list?)
16:27:20 <dmwit> Presumably `morph m1 >> m2 :: Y m a`.
16:27:27 <glguy> dmwit: It goes .hsc -> .c -> .hs
16:27:33 <dmwit> Dunno what all these extra `m`s at the type level are about, though.
16:27:50 <dmwit> glguy: Huh!
16:28:37 <dmwit> trigone: Again, though, I would recommend rewriting `m1` so that it can be given either type from `X m a` or `Y m a`. This is the mtl style, and it works well. Then `m1 >> m2` just works.
16:29:17 <jchia_> dmwit: OK, I'm not sure where the FFI.c comes from exactly. It's not a source file, but when I build clang-pure itself directly as a stack project, both under lts-9.1 & nightly-2017-09-06, the FFI.c gets generated.
16:31:31 <dmwit> jchia_: Okay. I definitely don't know enough about stack to offer actually useful advice. Hopefully others here are more knowledgeable.
16:33:12 <jchia_> dmwit: Actually hsc does output C as an intermediate step at least: https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/hsc2hs.html
16:33:38 <trigone> dmwit: more like morph m1 >>= m2. the problem (which maybe isn one, as i said i realized it wasn't somthing problematic, but i'm still digging by curiosity) is that when you have just (m a) as type of the result, you lost all type-level checking that the content of the expression is separated into two isolated subexpressions each having a part of the global context, one needing the monadwriter (and nothing more), the other needing 
16:35:41 <trigone> dmwit: what i mean is, if i wanted to write the type of expr in a way which would guarrantee it'd be written as the sequence of a MonadWriter m and of a MonadState m (actually, the other way round ^^), and not as the sequence of two (MonadWriter m, MonadState m), would it be possible (regardless of the potential absence of advantages)
16:35:56 <trigone> ?
16:36:49 <dmwit> trigone: Yes, I showed how above.
16:36:59 <trigone> dmwit: where?
16:37:05 <trigone> oh you mean the tuple?
16:37:09 <dmwit> yes
16:38:25 <dmwit> Or, to answer another way: what do you plan to do with this expression that needs that guarantee?
16:38:43 <jchia_> Regarding the clang-pure build problem, I managed to hack the Setup.hs removing cSources but I'm not sure whether that's the right thing to do.
16:38:57 <trigone> dmwit: well i guess it could work but if you want to fuse them together and compute the result, is it still possible? and that doesn really allow larger expressions, or at least they couldn't be patter-matched recursively or something...
16:39:56 <trigone> dmwit: well nothing much more than the original get >>= tell, simply i wonder if we can encode the structure of the expression in the type, specifically encode the separation between the two contexts
16:40:09 <dmwit> Yes, you can compute the result with `let (l, r) = expr in l >> r`. If you want a larger expression with more fine-grained guarantees, presumably you need a different type anyway, so you might as well use a larger tuple.
16:41:15 <esteos> Hey there! I have this function that returns an `Either String a` but instead of returning a Left, it calls `error` at some point -.- Now as far as I know `catch` doesn't help, apparantly `evaluate`,`try` should do the trick. But I can't get this to work.. Here's a simplified example: http://termbin.com/65pe
16:42:12 <dmwit> `catch` should work fine, together with `evaluate`.
16:42:19 <trigone> dmwit: what if i want to scale it for any number of sequenced operation? could i write some constructor which would basically build a heterogeneous list (with maybe a type-level list?), provided each monad can be cast into the next monad o the (type) list?
16:42:41 <jchia_> Cabal (2.0) Setup.hs question: Does this change look legit? I had to make this change for make clang-pure build for my stack nightly-2017-09-06 project. I don't understand what cSources means. https://github.com/jchia/clang-pure/commit/4f450b893b55b8e7f692f804c816c25b53c84b41
16:42:48 <dmwit> trigone: Yes, HList exists.
16:43:26 <esteos> dmwit: Really? Because here it sais different: https://wiki.haskell.org/Error_vs._Exception 
16:43:28 <trigone> dmwit: i know, i was wondering if my idea was doable though. i'm not well versed in type-level lists...
16:43:35 <dmwit> esteos: Presumably the problem there is that `error "even.."` does not throw an `Error` but rather a `UserError` or whatever GHC calls it.
16:44:38 <dmwit> esteos: Without even looking: yes, `catch` doesn't work alone because it only catches IO exceptions. But `try` also only catches IO exceptions. It is not `try` that is the magic here, it is the `evaluate`, which turns pure exceptions into IO exceptions. (Roughly.)
16:44:44 <ski> esteos : `instance Exception Error' with no implementation doesn't look that useful
16:44:45 <glguy> esteos: You aren't really meant to catch the exception thrown by 'error', but if you need to try you need to catch ErrorCall
16:45:06 <monochrom> esteos: Your own Error type is completely ignored.
16:46:08 <monochrom> So, figure out, for real, which exception type is actually relevant to "error", and catch that one specifically.
16:46:09 <ski> the `join' means `try' will try to catch an `Error' of that type, no ?
16:46:21 <esteos> Hmm, I didn't realize that. But catching ErrorCall didn't help either :S
16:46:25 <dmwit> esteos: Of course, the correct solution here is not to call `error`. ;-)
16:46:47 <esteos> I can't.. It's Data.Matrix that does so
16:46:47 <dmwit> esteos: Can you show us how you tried to catch ErrorCall?
16:47:04 <trigone> data M xs m a = Z (x m a) | M xs m a :>>= (a -> y m a) -- ofc that would require gadts but you see the idea
16:47:06 <monochrom> Ah OK ski, I have to reevaluate this code. (pun!)
16:47:58 <ski> monochrom : try differentiating it first, in order to reuse work ?
16:48:34 <esteos> dmwit: http://termbin.com/regb
16:48:47 <esteos> Note that's different code, the one with Data.Matrix
16:49:14 <trigone> Z :: x m a -> M '[x] m a  ; (:>>=) :: M xs m a -> (a -> y m a) -> M (y ': xs) m a -- is that possible? mind you the reversed order of monadic wrappers is a bit annoying but well
16:49:23 <dmwit> % catch (evaluate (error "foo")) (\(ErrorCall s) -> print s)
16:49:23 <yahb> dmwit: "foo"
16:49:29 <monochrom> @type fmap join
16:49:30 <lambdabot> (Functor f, Monad m) => f (m (m a)) -> f (m a)
16:50:54 <monochrom> OK, so instead ErrorCall is ignored.
16:51:09 <rotaerk> hmm think I've settled on emacs+dante
16:51:18 <esteos> dmwit: Oh wow! This is much simpler, thanks a lot.
16:51:23 <rotaerk> intero, and haskero for VS Code, won't work for me
16:51:38 <rotaerk> since I don't use stack
16:51:41 <trigone> @google framing debate haskell dsl
16:51:44 <lambdabot> http://www.nytimes.com/2007/04/08/books/chapters/0408-1st-feld.html
16:51:44 <lambdabot> Title: ‘Framing the Debate’ - The New York Times
16:52:45 <dmwit> esteos: Okay, it's not obvious to me just from staring why `caught` wouldn't get used. Can you distill it to an example that doesn't depend on Data.Matrix so I can try it myself?
16:52:58 <trigone> google is weird tonight, it finds me abberrant things systematically...
16:52:59 <ski> yikes, Haskell's made it to the NY Times ?!
16:53:10 <rotaerk> fortunately no
16:53:16 <monochrom> dmwit: It is used. But it tells catch to look for Error only.
16:53:35 <dmwit> monochrom: Why? `caught :: ErrorCall -> ...`
16:53:36 <dmwit> :t catch
16:53:38 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
16:53:53 <dmwit> `e` is fixed to `ErrorCall` by this
16:54:04 <hpc> ski: https://youtu.be/9cyABXsjZcs?t=34
16:54:13 <dmwit> monochrom: (Perhaps we are not looking at the same code?)
16:54:41 <monochrom> I misread.
16:55:11 <esteos> So the second one I posted should work?
16:55:32 <monochrom> @type left
16:55:34 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
16:56:37 <dmwit> esteos: I guess it's probably also worth asking why you believe that catching ErrorCall didn't help, just in case you're misinterpreting the evidence. =P
16:56:38 <rotaerk> is there any reason to use stack when already using nix?
16:56:38 <rotaerk> seems redundant
16:57:10 <rotaerk> hrm, disconnected as soon as I asked that...
16:59:24 <pacak> rotaerk: I don't see reasons using stack even if not using nix, but if you are going to publish your project - those who are going to use it or help you developing it - they might not use nix.
16:59:46 <esteos> dmwit: Because with this code I get a "error, called at ./Data/Matrix...."
17:00:35 <rotaerk> well it's not really a question of whether I should or shouldn't use nix; I've already settled on using it
17:00:45 <rotaerk> it's just a question of whether adding stack on top of that adds anything
17:01:01 <rotaerk> (it DOES have nix-integration support ... but it just seems redundant with nix-alone)
17:01:36 <rotaerk> if I wasn't using nix, I'd use stack rather than using neither
17:02:12 <dmwit> esteos: Okay. Why do you believe this code is the source of that error?
17:02:24 * dmwit continues his role as rubber duck
17:02:41 <rotaerk> oh right, there's a #haskell-stack
17:02:42 <esteos> dmwit: I actually don't anymore.. 
17:02:57 <dmwit> yay!
17:03:01 <esteos> Haha
17:03:24 <esteos> Yeah, I tried to find a minimal example and that code works as expected..
17:03:46 <esteos> Still thanks!
17:04:00 <dmwit> I'm sorry you have to hunt down a call to `error`. I know from experience that it's no fun and totally unrewarding when you finally win.
17:04:04 <dmwit> Good luck. =)
17:04:43 <esteos> Thank you :)
17:06:04 <erisco> > printf "%d" 100
17:06:06 <lambdabot>  error:
17:06:06 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M824740219407...
17:06:06 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
17:06:16 <erisco> > printf "%d" (100 :: Int)
17:06:18 <lambdabot>  error:
17:06:19 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M554159712401...
17:06:19 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
17:06:31 <erisco> this aint how it works in my ghci
17:06:36 <monochrom> No, you have to choose String or IO () or Handle->IO()
17:06:53 <ski> > printf "%d" 100 :: String
17:06:55 <lambdabot>  "100"
17:07:16 <erisco> ghci has some extra defaulting powers then
17:07:23 <monochrom> This is how beautifully Text.Printf unifies C's printf, sprintf, and fprintf.
17:07:25 <ski> can one pass multiple handles ?
17:07:27 <erisco> I am particularly confused as to why that even works, ski
17:07:33 <erisco> because how did it decide what type 100 has
17:07:35 <monochrom> No.
17:08:18 <monochrom> Because the current instances only have those three instances. But maybe you can add one more instance to take multiple Handles.
17:08:31 <erisco> that must be back to defaulting rules, and it chose Integer
17:08:46 <monochrom> ghci has extra defaulting. This is old news.
17:08:49 <dmwit> % printf "%d" 100
17:08:49 <yahb> dmwit: 100
17:09:02 <erisco> that default is standard Haskell
17:09:08 <dmwit> no
17:09:19 <dmwit> ghci has extended defaulting that goes beyond standard Haskell.
17:09:28 <ski> > printf "%d" (100 :: Word8) :: String
17:09:30 <lambdabot>  "100"
17:09:37 <erisco> choosing Integer for a Num literal is standard
17:09:38 <dmwit> But this is an even more different thing, which is that ghci has special rules for what types it tries to unify your expression with.
17:10:03 <erisco> does lambdabot use ghci?
17:10:07 <dmwit> erisco: Even after choosing `100 :: Integer` the expression `printf "%d" (100 :: Integer)` has a typeclass-polymorphic type.
17:10:28 <dmwit> And the extra (non-extended-defaulting) rules that I'm talking about are used there.
17:10:35 <dmwit> lambdabot does not use ghci.
17:10:40 <monochrom> erisco: If you actually read the Haskell standard: (Num a) => a can default to Integer, but (Num a, AnotherClassTheStandardDidn'tList a) => a is not going to be defaulted at all.
17:11:06 <erisco> I did read it, thanks
17:11:29 <dmwit> :t \x -> printf "" x
17:11:31 <lambdabot> (PrintfType t, PrintfArg t1) => t1 -> t
17:11:36 <pacak> % (unsafeCoerce True) :: Maybe ()
17:11:37 <yahb> pacak: Just [Segmentation fault]
17:11:42 <pacak> Yay
17:11:45 <monochrom> OK so if you actually read Text.Printf: AnotherClassTheStandardDidn'tList is PrintfArg.
17:12:20 <pacak> % (unsafeCoerce [True]) :: Maybe Bool
17:12:22 <yahb> pacak: Just True
17:12:27 <dmwit> % readFile "/etc/passwd"
17:12:28 <yahb> dmwit: *** Exception: /etc/passwd: openFile: does not exist (No such file or directory)
17:12:40 <pacak> % (unsafeCoerce ([] :: [Bool]) :: Maybe Bool
17:12:41 <yahb> pacak: ; <interactive>:3:43: error: parse error (possibly incorrect indentation or mismatched brackets)
17:12:44 <pacak> % (unsafeCoerce ([] :: [Bool])) :: Maybe Bool
17:12:44 <yahb> pacak: Nothing
17:12:51 <pacak> Mwahahaha
17:13:34 <pacak> % getCurrentDirectory
17:13:34 <yahb> pacak: "/var/lib/xsbot/sandbox/root/data"
17:13:34 <ski> `Just [Segmentation fault]' sounds interesting
17:13:44 <dmwit> I wonder why the redundancy in the message "does not exist (No such file)".
17:14:21 <glguy> does not exist is used for lots of things
17:14:23 <lyxia> % unsafeCoerce (33 :: Int) :: Maybe Bool
17:14:23 <yahb> lyxia: Nothing
17:14:44 <monochrom> @quote monochrom isTrue
17:14:45 <lambdabot> monochrom says: isTrue = (unsafeCoerce :: Either a b -> Bool) . (unsafeCoerce :: Maybe c -> Either a b) . (unsafeCoerce :: Bool -> Maybe c)
17:14:47 <dmwit> glguy: Neat! How can I observe something different in the parentheses?
17:14:53 <geekosaur> dmwit, "does not exist" is Haskell level, the stuff in parentheses is from C strerror()
17:15:14 <lyxia> % unsafeCoerce (Just 0) :: Int
17:15:14 <yahb> lyxia: -8502796095368063892
17:15:18 <glguy> dmwit: Try resolving a Prelude Network.Socket>  getAddrInfo Nothing (Just "bad") Nothing
17:15:20 <glguy> *** Exception: Network.Socket.getAddrInfo: does not exist (nodename nor servname provided, or not known)
17:15:35 <dmwit> geekosaur: That is interesting, but doesn't really say why the implementors chose to include both pieces in the error message.
17:15:43 <pacak> % listDirectory "/var/lib/xsbot/sandbox/root"
17:15:43 <yahb> pacak: ["bin","include","lib","usr","data"]
17:16:06 <glguy> isDoesNotExistError :: IOError -> Bool
17:16:24 <pacak> % listDirectory "/var/lib/xsbot/sandbox/root/data"
17:16:24 <yahb> pacak: ["1","t.lua","repeat.sh","test.lua","hello.lua","t.sh","\56528\56511\56528\56504\56528\56500\56528\56510\56529\56448","test"]
17:16:30 <glguy> Having seen "does not exist" you know that you can test for it with that predicate
17:16:32 <lyxia> % unsafeCoerce GT :: Maybe Bool
17:16:32 <yahb> lyxia: Just True
17:16:46 <geekosaur> dmwit, because there's some collection of errors that can get the haskell level error. on OS level that could map to a number of possible things, of which EEXIST is likely most common
17:17:02 <pacak> % readFile "repeat.sh"
17:17:02 <yahb> pacak: "echo \n"
17:17:47 <dmwit> ok
17:18:51 <pacak> % appendFile "kaboom.sh" ":(){ :|: & };:" 
17:18:51 <yahb> pacak: 
17:19:01 <pacak> % readFile "kaboom.sh"
17:19:01 <yahb> pacak: *** Exception: kaboom.sh: openFile: does not exist (No such file or directory)
17:19:03 <glguy> You can terrorize yahb in /msg, too
17:19:11 <pacak> I know.
17:19:19 <glguy> Good, please don't spam #haskell
17:19:26 <pacak> Maybe it shouldn't expose all this stuff...
17:19:41 <dmwit> I just tested: setCurrentDirectory works and that state is actually preserved across runs. Neat!
17:19:59 <dmwit> Probably my test interleaved with your `kaboom.sh` test, and explains why it didn't work. =P
17:20:11 <monochrom> Talk about I/O.
17:20:42 <monochrom> And this is why "Step 1. Does the file exist?  Step 2. If yes, open it now." is broken.
17:21:54 <monochrom> Unless you're invigilating an exam and giving that instruction to the students.
17:22:38 <monochrom> (Five minutes before the start time.) "Check that you have the exam paper and the answer booklet. But do not open them!"  (At the start time) "You can open them now."
17:23:45 <dmwit> Yes, humans are surprisingly resilient to ill-formed instructions.
17:24:39 <dmwit> My wife and I agreed that if the dishwasher was locked, this meant the dishes were clean, and if it was unlocked, they were dirty. And then I didn't even have to specify that while I was putting them away they were still clean even though it was unlocked and that locking it didn't clean them magically. It was weird.
17:24:50 <nshepperd_> First, check that the file exists. Then check it again, in case the situation changed. Then check again... Then at t=infinity open the file
17:25:28 <glguy> dmwit: I've certainly put a dirty dish into an open dishwasher that was being emptied even though I didn't know it was being emptied :)
17:25:56 <dmwit> s/even though/because/ (I suspect)
17:26:24 <erisco> whoever fixes the "are they clean" problem they'll be a millionaire
17:26:47 <lavalike> just run your exams like SQL:  BEGIN;  SELECT COUNT(paper) FROM …;  SELECT paper.* FROM …;  ...  oh wait
17:26:57 <monochrom> You guys need double buffering!
17:27:22 <dmwit> glguy: In other words: even with correct instructions you would have made this mistake. So this is still not evidence against "humans are robust against bad instructions".
17:27:41 <erisco> we need type class classes
17:28:09 <glguy> dmwit: That may be, I didn't see the original seed of the discussion. I justed wanted to admit to putting dirty dishes in with clean ones :)
17:28:17 <dmwit> hehehe
17:28:23 <dmwit> you dog!
17:28:37 <erisco> since you can be polymorphic on classes
17:28:59 <dmwit> ?let class C c where foo :: c a => a -> a
17:29:01 <lambdabot>  .L.hs:163:9: error:
17:29:01 <lambdabot>      • Could not deduce: c0 a
17:29:01 <lambdabot>        from the context: (C c, c a)
17:29:01 <monochrom> Does TypeInType give type class classes?
17:29:27 <dmwit> I wonder why it wants to deduce c0 a.
17:29:42 <lyxia> it's ambiguous
17:29:51 <dmwit> ah right!
17:29:55 <erisco> -XAllowAmbiguousTypes
17:29:59 <dmwit> ?let class C c where foo :: c a => proxy c -> a -> a
17:30:00 <lambdabot>  Defined.
17:30:09 <dmwit> :kind C
17:30:22 <dmwit> ?kind C
17:30:24 <lambdabot> (* -> Constraint) -> Constraint
17:30:36 <monochrom> Oh, right, yeah.
17:30:38 <dmwit> erisco: We already have typeclass classes! =)
17:30:54 <glguy> It's part of  ConstraintKinds
17:31:07 <erisco> mm, that makes sense, thanks
17:31:18 <monochrom> This is evil.
17:31:32 <erisco> I thought of a possible way to generalise my foldable applications to be a generalisation of printf
17:31:51 <erisco> then, this sort of thing is needed
17:34:56 <erisco> if it works then it will be a fairly general framework for variadic functions
17:36:50 <erisco> hm, you could use type class classes instead of tagging instances for some uses, couldn't you, like Ord instances
17:37:32 <erisco> PartialOrder order => Set order a …
17:37:51 <erisco> instance PartialOrder Ord where compare …
17:39:17 <erisco> bonus is that you don't need a new Ord
17:42:37 <tedwing> I'm having a bit of trouble understanding monad transformers. I've been trying to integrate a ReaderT config-passing monad, but am stuck on this error: <http://lpaste.net/358256>, triggered by this line <https://github.com/teddywing/sorbot/blob/tmp/src/Plugin/GitHubCommit.hs#L55>. It makes sense that the types don't line up, but I can't figure out how to get the `IO` out of my `Bot` type (if that's even 
17:42:43 <tedwing> the right way of going about it) so that I can use the unwrapped `Plugin` on the next line.
17:44:25 <kadoban> tedwing: What's Bot and PluginAction and etc.? At a guess though, needs a liftIO? (total guess)
17:46:10 <dmwit> tedwing: Did you have the `respond :: Bot (Either Text Text)` annotation in the version of the code that produced that error?
17:46:11 <tedwing> Bot is <https://github.com/teddywing/sorbot/blob/tmp/src/Bot.hs#L13-L15>, and PluginAction is <https://github.com/teddywing/sorbot/blob/tmp/src/Plugin/Base.hs#L19>. Bot wraps IO
17:46:25 <dmwit> tedwing: If not, I understand the error and can suggest a fix; if so, I find the error very surprising indeed.
17:47:22 <dmwit> In particular: the error says it was "expecting `IO` and found `Bot`", which doesn't mesh with my intuition that the type signature should cause it to expect `Bot`.
17:48:10 <dmwit> If the signature *wasn't* there, then my guess would be that `Cli.lang` is an `IO` action, which caused to guess that `respond` had an `IO` type and complain about the second clause.
17:48:16 <dmwit> This can be fixed by lifting `Cli.lang` into `Bot`.
17:49:17 <tedwing> dmwit: oh, I forgot I added that type annotation. Looks like the error happens even with it there
17:49:51 <tedwing> oh! yes, `Cli.lang` is an `IO` action
17:50:00 <dmwit> tedwing: I expect the error is subtly different with the type annotation. Check it carefully. =)
17:50:30 <tedwing> I'll check
17:50:38 <dmwit> tedwing: Namely, with the annotation it should expect `Bot` and find `IO`, and point to the `Cli.lang` line rather than the `githubCommit` line.
17:51:12 <dmwit> So the expectation gets reversed and it points at a different line. =)
17:52:02 <monochrom> tedwing: I wonder if "liftIO $ respond rs" should be simply "respond rs".
17:52:45 <fresheyeball>     :> ReqBody '[OctetStream] ByteString
17:52:47 <fresheyeball>     :> Post '[JSON] Text
17:52:49 <dmwit> Oh yes, probably that too!
17:52:56 <fresheyeball> is there a way I can make an HTML form that posts to that?
17:55:47 <dmj`> fresheyeball: <form method=“POST” action=“/endpoint”>
17:57:40 <tedwing> dmwit, monochrom: thanks for the tips! Going to fiddle with the code to see what that does
17:59:53 <fresheyeball> I just want a dead simple file upload with Servant
18:00:01 <fresheyeball> do I really need servant-multipart for that?
18:03:17 <erisco> well it works on a small example
18:09:54 <erisco> the idea is you can define a converter so you can convert heterogeneous arguments to homogeneous arguments
18:10:24 <erisco> and then once homogeneous they are eligible to be folded
18:11:48 <erisco> so I have working an example where you can fold over lists and elements, where elements are turned into singleton lists
18:12:31 <erisco> this is the future of programming right here
18:15:44 <ski> erisco ?
18:16:27 <rotaerk> so dramatic
18:17:09 <erisco> ski, someone gave me a crazy idea, and I like crazy, so I am joking about the grandiosity ;)
18:18:37 <geekosaur> erisco, congratulations, you have reinvented perl :p
18:19:03 * ski was more thinking about Matlab
18:19:50 <erisco> but it is just one example! we can have a litany of Perl variants!
18:20:13 <remexre> Is there any way to write a function StateT s IO a -> IO (State s a)? I puzzled over it for a few hours and I don't *think* I can, but I just wanted to check to be sure
18:21:00 <erisco> it is a general framework for acme libraries
18:24:18 <monochrom> @unmtl StateT s IO a
18:24:19 <lambdabot> s -> IO (a, s)
18:24:35 <monochrom> Cannot.
18:26:37 <remexre> aw, damn. ok
18:27:06 <remexre> Is there a standard way to get catch (for IOException) inside a "complex" monad?
18:27:14 <remexre> i.e. a monad transformer stack?
18:27:22 <remexre> (sorry, too tired for proper terminology :/)
18:27:37 <rotaerk> :t catch
18:27:38 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
18:27:59 <kadoban> remexre: The MonadCatch typeclass I think?
18:28:06 <rotaerk> check the catch under the exceptions module
18:28:13 <rotaerk> it's more general than the one in the base
18:28:35 <geekosaur> remexre, there re simple ways, most of which have issues. MonadBaseControl is one attempt to address those issues. it is not simple.
18:28:37 <rotaerk> Control.Monad.Catch instead of Control.Exception
18:29:17 <geekosaur> basically it depends on how much you need to worry about leaking things like filehandles in case of an exception at the wrong time
18:29:25 <remexre> okay
18:29:52 <remexre> let's assume I don't care about resource leaks because I have more RAM than sense, is MonadBaseControl or MonadCatch what I want?
18:31:06 <geekosaur> MonadCatch if you don't care about resource leaks. (mmeory is *not* leaked. it's other things not under control of garbage collection that you generally have to worry about)
18:31:23 <remexre> yeah, pretend I meant kernel RAM usage
18:31:35 <remexre> I'm trying to multitask and failing hard
18:35:03 <CeilingHoles> Testing 123
18:51:05 <erisco> I think I have to rewrite the format string parser, bleh
18:51:16 <erisco> it seems buried and strewn about
19:30:28 <dsal> @pl \c -> c^2 <= n
19:30:28 <lambdabot> (<= n) . (^ 2)
19:32:24 <hololeap> if i have something like `i = length [1,2,3,4,5]`, will the compiler shrink this down to just a static "5" in the executable, or will it always have to span the whole list?
19:33:18 <monochrom> I don't know. Do you know how to read core? It can tell you.
19:33:40 <hololeap> core?
19:34:08 <hololeap> what is core?
19:34:35 <lyxia> it's the intermediate language GHC uses to optimize your programs
19:34:38 <monochrom> This refers to GHC's intermediate language. You can obtain some by "ghc -O -ddump-simpl -dsuppress-all"
19:35:26 <hololeap> ok, i'll check it out
19:35:53 <geekosaur> hololeap, in general ghc does not do compile time evaluation, only compile time replacement (via RULES). since RULES are type driven and literals do not have distinct types from computed values, it cannot know to apply a RULE to reduce it at compile time
19:47:53 <hololeap> geeokosaur, could you please give me a simple example of a rule that it uses?
19:48:06 <hololeap> just for reference
19:48:53 <geekosaur> not off the top of my head. thing is, RULES are not wired in, they are pragmas in library source.
19:49:49 <geekosaur> there is not a lot wired in at this level. hypothetically they could be, but as ghc is currently designed it would be difficult to do so
19:52:13 <monochrom> Data.List probably has a lot of them.
19:52:44 <geekosaur> I'm not sure it dfoes these days
19:52:49 <geekosaur> GHC.OldList likely does
19:53:09 <geekosaur> (Data.List is mostly reexports of Data.Foldable at this point)
19:53:42 <dfeuer> A lot of the list rules are in GHC.Base and GHC.List, IIRC.
19:53:46 <dfeuer> Some are in Data.OldList.
19:53:59 <dfeuer> Probably.
19:56:01 <andromeda-galaxy> hmm, I wonder what the nicest safe way to write partition :: (a -> Either b c) -> [a] -> ([b],[c]) is...
19:57:03 <jle`> probably using pattern matching
19:57:06 <geekosaur> :t Data.Either.partitionEithers
19:57:07 <lambdabot> [Either a b] -> ([a], [b])
19:57:10 <glguy> :t \f xs -> partitionEithers (map f xs)
19:57:11 <lambdabot> (a1 -> Either a b) -> [a1] -> ([a], [b])
19:57:48 <andromeda-galaxy> geekosaur, glguy: thanks, I have no idea why I didn't find that on hoogle
19:57:58 <jle`> if you're using official hoogle, it's out of date
19:58:02 <jle`> by about two or three years
19:58:13 <andromeda-galaxy> oh, is there a better one?
19:58:26 <geekosaur> more precisely there are two web hoogles
19:58:39 <geekosaur> one has working type search but is not being updated (haskell.org/hoogle)
19:58:40 <dfeuer> Why hasn't it been updated yet?
19:58:50 <geekosaur> one is updated but its type seach is broken (hoogle.haskell.org)
19:58:55 <dfeuer> Or why doesn't the updated one have type search?
19:59:02 <dfeuer> This has been broken far longer than seems sensible.
19:59:08 <geekosaur> because hoogle 5 is still a work in progress
19:59:28 <geekosaur> and hoogle 4 chokes if the database is too large, so it can only sensibly deal with base
19:59:29 <dfeuer> What was wrong with the old version? Why stop updating it?
19:59:55 <geekosaur> you can direct it at other databases, but you have to know which one(s) to look in
19:59:57 <jle`> um there was a blog post by it
20:00:20 <jle`> but i think the main gist was that indexing in hoogle 4 was super slow
20:00:40 <jle`> and hoogle 5 was apparently just around the corner
20:02:20 <jle`> here it is http://neilmitchell.blogspot.com/2015/02/why-is-hoogle-index-so-out-of-date.html
20:02:35 <dfeuer> "just around the corner". Any chance it really is?
20:02:44 <jle`> neil has gotten busy
20:03:35 <geekosaur> it is possible that someone else will need to take over hoogle development from ndm at this point
20:04:04 <jared-w> Wait is this Hoogle 5 the alpha version which is /still/ in alpha? Since 2015? wat
20:04:14 <geekosaur> or at least, someone else will have to start contributing to it (https://github.com/ndmitchell/hoogle)
20:04:36 <geekosaur> still in alpha, yes
20:05:28 <geekosaur> actually the latest alpha was released in July, so ndm is still working on it intermittently
20:06:15 <jared-w> "as a result, the haskell.org home page once said 'moo' for 10 minutes" lol
20:06:34 <andromeda-galaxy> hmm, the type search isn't /completely/ ineffective: http://hoogle.haskell.org/?hoogle=%5BEither%20a%20b%5D%20-%3E%20(a%2C%20b)
20:07:05 <jle`> for now i just use alpha hoogle and stackage hoogle, aka stoogle
20:07:21 <jle`> (disclaimer, i'm the only one i know who calls it stoogle)
20:07:25 <jared-w> Pretty sure the type search warning is somewhat obsolete
20:10:48 <jle`> that's encouraging :)
20:12:23 <geekosaur> not completely ineffective, just doesn;t handle all the cases hoogle 4 did yet
20:13:06 <andromeda-galaxy> hmm, that's good to hear
20:13:11 <andromeda-galaxy> thanks for the help!
20:14:58 <jle`> in neil we trust
20:19:31 <dumptruckman> it's really impressive that this channel is so active
20:19:49 <monochrom> Is it really active?
20:20:12 <jle`> by freenode standards, i suppose
20:20:19 <dumptruckman> Compared to other largish channels I frequent, yeeah
20:20:47 <jle`> it's because haskell increases our productivity so much that we have nothing better to do than sit around and talk about haskell
20:20:51 <dumptruckman> also like 3 times the users compared to ##java... and i don't heard about haskell just recently
20:20:56 <jle`> all that time we'd otherwise spend debugging
20:20:57 <dumptruckman> 🙃
20:21:05 <monochrom> No, it's because we're unemployed.
20:21:21 <jle`> that's also probably a contributing factor
20:21:24 <dumptruckman> alright well, maybe you can help me understand this problem
20:21:41 <dumptruckman> i'm trying to use a list comprehension but having a type mismatch
20:21:49 <monochrom> Just look at how Cale has become so inactive after he got employed.
20:22:09 <dumptruckman> https://hastebin.com/nimicedepu.hs
20:22:17 <jle`> yeah Tekmo left this channel as soon as he got hired by twitter
20:22:33 <jle`> dumptruckman: can you paste the error too?
20:22:43 <monochrom> It's why there is no dentist channel for example.
20:22:54 <dumptruckman> workin on it
20:23:15 <monochrom> Oh God why reverse.
20:23:37 <jle`> yeah your definition of append is likely to be the culprit
20:23:51 <dumptruckman> https://hastebin.com/uhefuqozar.scala
20:23:59 <jle`> right now it doesn't...really...make sense?
20:24:16 <jle`> oh that error is actually unrelated
20:24:17 <monochrom> haha scala for colouring error messages?
20:24:49 <dumptruckman> *shrug* hastebin is notoriously bad at guessing syntax
20:24:50 <jle`> that error is because by default, type variables in haskell are all "local" to only the type signature they are in
20:25:07 <jle`> they aren't scoped throughout helper functions in the function body
20:25:24 <dumptruckman> ...and? i don't see how that's relevant :(
20:25:40 <dumptruckman> it's highlighting e as the problem
20:25:56 <jle`> oh actually wait, i misread the error
20:26:11 <monochrom> I think I'm going to cut to the mustard and say that "append list res = [e : res | e <- reverse list]" is very wrong logic, and it is not just because of types. Even the intuition is wrong.
20:26:17 <jle`> yeah, for [(blah :: A)| ....], the result type is [A]
20:26:27 <Cale> monochrom: Yeah, I'm doing my best, but it's kind of tough to spend nearly as much time on IRC as before.
20:26:39 <sqooq> "Diagrams" is declarative?
20:26:48 <dumptruckman> monochrom: how so?
20:26:49 <Cale> I do consider it important though, so I don't think I'd ever completely disappear.
20:27:00 <jle`> yeah, i'm not really sure how you got at that definition for append
20:27:02 <dumptruckman> why can't i just reverse the whole list and cons it back together?
20:27:14 * dfeuer hugs Cale.
20:27:18 <jle`> that's not what list comprehensions do
20:27:25 <monochrom> Also concat' seems to be ignoring xs altogether. Isn't it supposed to recurse?
20:27:31 <jle`> they run that thing for every item in the list
20:27:43 <dumptruckman> ah, that would be a problem
20:27:54 <jle`> > [x*2 | x <- [1,2,3,4]]
20:27:56 <lambdabot>  [2,4,6,8]
20:28:00 <jle`> you see, the result is every item in the list *2
20:28:15 <jle`> append is actually really straightforward/simple to write using basic pattern matching
20:28:17 <dumptruckman> i haven't even really finished thinking this through
20:28:29 <jle`> so it might be worth just scrapping your append definition and taking it step by step
20:28:46 <dumptruckman> i was just trying to fix this error so i could continue
20:28:47 <jle`> append [] ys = ...; append (x:xs) ys = ...
20:28:56 <monochrom> And "[1,2,3] ++ [4,5,6]" already exists.
20:28:59 <jle`> if you want to just leave placeholder stubs, you can use 'undefined'
20:29:18 <jle`> concat is also fairly easy to implement directly using simple pattern matching too
20:29:28 <jle`> concat [] ys = ...; concat (x:xs) ys = ...
20:29:34 <dumptruckman> i figured... but i couldn't really think of out
20:29:37 <dumptruckman> how*
20:29:39 <monochrom> No, this type error is only a symptom. You need to go back to square 1 rather than patch unpatchable code.
20:29:51 <dumptruckman> hmm ok
20:30:03 <jle`> sorry, i mean concat [] = ...; concat (xs:xss) = ...
20:30:12 <jle`> try filling in the blanks
20:30:13 <dumptruckman> i know concat ++ exists.. but the goal is to implement it myself and also not doing the slow way
20:30:17 <jle`> what is concat [] = ???
20:30:22 <dumptruckman> []
20:30:23 <jle`> what happens when you concat no lists?
20:30:25 <jle`> sweet
20:30:28 <dumptruckman> i know how pattern matching works
20:30:34 <jle`> what about concat (xs:xss) = ?
20:31:08 <jle`> if you have (some list) consed with (a bunch of other lists), how do you concat the whole thing?
20:31:20 <dumptruckman> ¯\_(ツ)_/¯
20:31:22 <jle`> [1,2,3]:[[4,5,6],[7,8,9]] = ?
20:31:39 <jle`> if i concatenated [[1,2,3],[4,5,6],[7,8,9]], what's the answer?
20:31:53 <dumptruckman> [1,2,3,4,5,6,7,8,9]
20:32:05 <jle`> so, that's [1,2,3]   :   [[4,5,6],[7,8,9]]
20:32:19 <dumptruckman> O.o
20:32:23 <jle`> concatented = [1,2,3,45,6,7,8,9]
20:32:24 <dumptruckman> wouldn't that just make
20:32:32 <dumptruckman> the same thing i started with?
20:32:42 <jle`> yeah, you say that concat ([1,2,3]   :   [[4,5,6],[7,8,9]])  = [1,2,3,4,5,6,7,8,9]
20:32:48 <jle`> that was what you claimed
20:32:55 <dumptruckman> wait what
20:33:08 <jle`> you said that concat [[1,2,3],[4,5,6],[7,8,9]] = [1,2,3,4,5,6,7,8,9]
20:33:13 <dumptruckman> yes
20:33:25 <jle`> which is another way of saying that concat([1,2,3]  : [[4,5,6],[7,8,9]])  = [1,2,3,4,5,6,7,8,9]
20:33:28 <dumptruckman> oh
20:33:33 <dumptruckman> yeah ok
20:33:37 <jle`> since [[1,2,3],[4,5,6],[7,8,9]] is [1,2,3]  :  [[4,5,6],[7,8,9]]
20:33:56 <jle`> can you see how to get [1,2,3,4,5,6,7,8,9] from   [1,2,3] and [[4,5,6],[7,8,9]] ?
20:34:02 <dumptruckman> nope
20:34:02 <jle`> assuming you have 'append' written
20:34:08 <dumptruckman> oh
20:34:22 <jle`> assume you can append two lists together somehow
20:34:22 <dumptruckman> this is still using append
20:34:34 <jle`> indeed we are assuming we can append
20:34:36 <jle`> we can implement that later
20:34:39 <dumptruckman> ok
20:34:55 <jle`> you can write "append = undefined" somewhere in your code
20:36:04 <dumptruckman> lemme think about this for a bit
20:36:29 <jle`> (you can also recursively use 'concat')
20:36:41 <dumptruckman> right, and i'd have to
20:36:58 <dumptruckman> unless there's some magic i'm unaware of
20:37:20 <jle`> maybe, if you consider 'using the standard libraries' magic :)
20:37:38 <dumptruckman> well obviously i can't use concat here
20:37:51 <jle`> you can use the concat that you are defining
20:37:53 <dumptruckman> Prelude.concat that is
20:38:02 <dumptruckman> right
20:39:02 <dumptruckman> also trying to avoid ++
20:39:12 <dumptruckman> which is why i was using reverse before
20:39:32 <jle`> you can avoid (Prelude.++), but you can also write your own
20:40:59 <dumptruckman> concat (xs : xss) = append xs (concat xss)
20:41:03 <dumptruckman> seem right?
20:41:07 <jle`> mhm, makes sense
20:41:29 <dumptruckman> but an interative form would be better, right?
20:41:33 <jle`> quick unit test, append [1,2,3] (concat [[4,5,6],[7,8,9]]) is append [1,2,3] [4,5,6,7,8,9], which is [1,2,3,4,5,6,7,8,9]
20:41:34 <dumptruckman> iterative*
20:41:40 <jle`> what do you mean by an iterative form?
20:41:46 <Cale> dumptruckman: Depending on what you mean, possibly not.
20:42:05 <jle`> this is arguably an iterative algorithm, you're iterating through every item in the list
20:42:20 <dumptruckman> tail recursion
20:42:25 <jle`> anyway, just define append now (append [] ys = ...; append (x:xs) ys = ...)
20:42:32 <jle`> why is tail recursion better?
20:42:33 <Cale> dumptruckman: This way gets you closer to determining the first element of the result sooner than something which uses an accumulating parameter and only produces any result after travelling down the entire length of the input
20:42:50 <Cale> Tail recursion is not always a good plan.
20:42:57 <dumptruckman> hmm
20:42:59 <andromeda-galaxy> > (foldl (++) []) [[1,2,3],[4,5,6],[7,8,9]])
20:43:01 <lambdabot>  <hint>:1:42: error: parse error on input ‘)’
20:43:03 <andromeda-galaxy> > (foldl (++) []) [[1,2,3],[4,5,6],[7,8,9]]
20:43:06 <lambdabot>  [1,2,3,4,5,6,7,8,9]
20:43:11 <dumptruckman> my professor didn't really explain why you wouldn't prefer tail recursion
20:43:22 <Cale> Here, append xs (concat xss) is often going to be able to produce the first element of its result (which will be the first element of xs) without ever looking at (concat xss)
20:43:22 <jle`> i'm not sure if people who ask 'what about tail recursion?' even know why tail recursion is ever preferable
20:43:30 <jle`> dumptruckman: why would you *prefer* tail recursion?
20:43:39 <jle`> can you think of any actual benefit of tail recursion?
20:44:13 <dumptruckman> he said the compiler optimizes it better than normal recursion
20:44:24 <Cale> One of the main benefits of tail recursion, that it can be implemented without making use of the call stack, is a bit of a moot point when you don't have a call stack.
20:44:32 <monochrom> True of many languages. Not true of Haskell.
20:44:36 <jle`> dumptruckman: he said that about haskell?
20:44:48 <dumptruckman> yeah, he said that was a specific thing about haskell
20:44:52 <jle`> that's...
20:44:53 <dumptruckman> o.O
20:44:59 <jle`> "not even wrong"
20:45:01 <jle`> well,
20:45:03 <jle`> i suppose it is wrong
20:45:11 <monochrom> And not false of Haskell either.
20:45:18 <monochrom> It's a false dichotomy.
20:45:36 <andromeda-galaxy> hmm, I really thought that ghc could optimize strict tail recursive functions into tight loops more easily than the alternatives...
20:45:47 <Cale> Well, in specific cases, it can be appropriate in Haskell, but typically not for the same reason as when you're working with eager evaluation.
20:45:54 <andromeda-galaxy> it's why we have all those '= go x 0 where go !x !a =' in the standard libraris, right?
20:46:09 <andromeda-galaxy> but yeah, it's way more nuanced in haskell
20:46:16 <Cale> and yes, sometimes the compiler will optimise recursive functions into tight loops
20:47:19 <dumptruckman> hmm ok
20:47:27 <monochrom> The professor probably doesn't know the logical conclusion of "lazy list".
20:47:40 <jle`> it might be a general functional programming class, and not a haskell class
20:47:48 <jle`> we didn't really talk about this in my ocaml course
20:47:53 <dumptruckman> well i imagine to make this "as efficient as I can" in his mind, i should probably use tail recursion... but i can convert that once i get this working i guess
20:48:07 <jle`> what's the class about?
20:48:10 <jle`> writing efficient code?
20:48:21 <dumptruckman> "logical conclusion"? we were just talking about lazy lists yesterday
20:48:48 <monochrom> Sure. You don't know. But the prof is supposed to know.
20:49:00 <jle`> if this is a class about functional programming
20:49:17 <jle`> concat (xs:xss) = xs ++ concat xss is probably the answer he's looking for
20:49:21 <dumptruckman> advanced functional languages and object oriented programming
20:49:30 <andromeda-galaxy> dumptruckman: the problem with tail recursive versions of list functions is that they have to scan the whole input lists in order to get any part of the output (since the output is only returned after scanning the whole list). With lazy lists, this might be really bad: if you force the first element of the output list, the entire input list is scanned when it doesn't have to be
20:49:37 <dumptruckman> wait no
20:49:45 <dumptruckman> Advanced objected oriented and functional programming
20:50:13 <dumptruckman> ah, interesting andromeda-galaxy
20:50:47 <jle`> for what it's worth, `concat (x:xss) = xs ++ concat xss` is close to how it's defined in the base libraries
20:50:52 <monochrom> IMO any advanced class on anything is supposed to tell you to seek empirical evidence and get rid of simplistic rules of thumb.
20:51:05 <sqooq> how the heck do I track mouse position
20:51:38 <jle`> dumptruckman: `concat (xs:xss) = xs ++ concat xss` also makes sense in the context of the data structure that list is
20:51:51 <jle`> a list is a "streaming" linked list
20:51:58 <dumptruckman> it's a special topics class and tbh i think there's too much in the curriculum for him to cover these things as in detail as he probably should "for being an advanced class"
20:52:04 <jle`> so concatenating a list of streams is the first stream, then the next streams
20:52:36 <dumptruckman> yeah, that makes sense
20:52:46 <jle`> anything else betrays the streaming nature of lists
20:52:56 <dumptruckman> like
20:53:17 <rober____> if I have this data type:  data MyNums = One | Two | Three deriving (Read, Show)
20:53:29 <jle`> unless you are working on extremely tight code, tail recursion isn't something that you should really be considering in haskell
20:53:34 <rober____> how can i convert the type used to a string to use in an error message
20:53:46 <dumptruckman> if i get what yall are saying, trying to doing something like concat [[1..] [1..] [1..]] would be really bad if concat was tail recursive?
20:53:57 <jle`> rober____: you can use show :: MyNums -> String
20:54:33 <jle`> first you'd have to think of what it would even mean to write that it tail recursively
20:54:39 <jle`> and what that'd look like
20:54:49 <erisco> what is tail recursion
20:54:55 <jle`> but the worser example might be (repeat <$> [1..])
20:55:08 <dumptruckman> i don't even know what <$> means
20:55:11 <jle`> or, er, (take 5 . repeat <$> [1..])
20:55:13 <erisco> there is a sensible way to concatenate infinite lists
20:55:14 <jle`> sorry, that's just an infix version of map
20:55:24 <`Guest00000> but head of that returns:o
20:55:24 <jle`> > map (take 5 . repeat) [1..]
20:55:25 <dumptruckman> oh neat
20:55:26 <lambdabot>  [[1,1,1,1,1],[2,2,2,2,2],[3,3,3,3,3],[4,4,4,4,4],[5,5,5,5,5],[6,6,6,6,6],[7,...
20:55:28 <`Guest00000> 
20:55:31 <`Guest00000> o
20:55:39 <rober____> thanks, jle`!
20:55:42 <`Guest00000> ([Reserved Module],"module")
20:55:43 <jle`> no problem!
20:56:04 <`Guest00000> damn newlines in pastes
20:56:40 <dumptruckman> tbh, this guy knows a lot about a lot of programming languages... he's been around the block, but i don't know if haskell is really one of his strong suits or not
20:57:17 <dumptruckman> he has kind of been preaching that ++ is inefficient, or else i'm just imaginging things
20:57:36 <jle`> (++) is inefficient when you use it inefficiently
20:57:37 <erisco> it depends on the associativity
20:57:43 <jle`> but that's not really a blanket statement
20:57:54 <jle`> it is likely he knows his stuff about PL's
20:57:55 <erisco> (a ++ b) ++ c is inefficient, but a ++ (b ++ c) is efficient
20:58:07 <dumptruckman> huh
20:58:11 <jle`> but we're talking from the perspective of people who actually use haskell in their daily programming
20:58:12 <dumptruckman> why is that?
20:58:21 <erisco> look at the definition of ++ and see what it does
20:58:23 <jle`> think about what needs to be re-allocated
20:58:40 <jle`> for [1,2] ++ [5,6,7], we can keep the [5,6,7] in memory
20:58:46 <jle`> but the [1,2] we have to completely re-allocate
20:59:04 <jle`> (since these are immutable data structures, and we can't use them because it's 1 -> 2 -> [])
20:59:10 <dumptruckman> ahh
20:59:26 <dumptruckman> you know, i asked a question about what is going on under the hood with lists and cons
20:59:33 <jle`> [1,2] ++ xs is essetially re-allocating [1,2], and having the 2 point towards xs instead of []
20:59:35 <dumptruckman> and the answer i got seemed like a cop out
21:00:03 <dumptruckman> he said that often times it's not actually immutable under the hood
21:00:31 <jle`> so if you can see that (xs ++ ys) has to completely re-allocate all of xs, but can keep ys as-is
21:00:39 <dumptruckman> yeah
21:00:39 <monochrom> For a change, next time don't ask him for a theoretical answer. Ask him for actual code that shows the slowness or fastness. Ask him for a reproducible scientific experiment.
21:00:41 <jle`> then you can see why (xs ++ ys) ++ zs is pretty bad
21:00:49 <jle`> and why xs ++ (ys ++ zs) is pretty awesome
21:01:02 <dumptruckman> i would if it wasn't a large class that would probably hate me for such questions
21:01:14 <dumptruckman> most of them are just trying to get through it
21:01:22 <erisco> use office hours
21:01:24 <dumptruckman> it's undergrad after all
21:01:29 <dumptruckman> but yeah, i'm gonna have a talk with him
21:01:54 <jle`> i mean, i know C/python well enough to teach a fairly decent intro to comp sci class in C/python
21:02:08 <jle`> or at least, i'm at the level where my knowlege of C or python would not limit the quality of the class -- other things might
21:02:08 <dumptruckman> i could do the same for java
21:02:17 <jle`> but, i'm not soemone who uses C or python in my everyday coding for work
21:02:52 <jle`> and how people code in C these days is pretty much completely differently than how i'd use C to teach a comp sci class
21:02:57 <jle`> it'd be unrecognizable
21:03:25 <jle`> this is how you might want to look at haskell for this class
21:03:37 <jle`> it's used a vehicle to teach some deeper concepts about FP
21:03:50 <dumptruckman> indeed
21:04:09 <dumptruckman> i think the advanced part is really more related to the OOP half of the class
21:04:24 <dumptruckman> and the FP part is really to introduce FP cause no other course is going to
21:04:34 <dumptruckman> (at this school)
21:04:46 <erisco> what bothers me is attention to nitty performance
21:04:53 <dumptruckman> indeed
21:05:28 <dumptruckman> tbh, i think his point was more to explain recursion and tail recursion
21:05:28 <jle`> also saying something like things are not actually immutable under the hood isn't really a super useful statement for understanding performance at a practical level
21:05:41 <monochrom> I don't hinge my point and my view on petty things like course title or "is it about performance?".
21:06:02 <dumptruckman> jle`: that did only come because i asked how cons worked under the hood
21:06:18 <monochrom> A 3rd-year class is simply supposed to tell you to be critical rather than to just believe a prof's BS.
21:06:38 <dumptruckman> indeed
21:06:50 <dumptruckman> i never said he was a good teacher ;)
21:07:44 <dumptruckman> only a 3.0 on rate my professor
21:09:57 <erisco> I don't know if tail recursion is a thing with GHC
21:10:53 <remexre> afaik, laziness means it's not *really* a thing
21:11:09 <remexre> because we care about reductions, not calls
21:11:27 <monochrom> It is a thing in GHC.
21:11:34 <pacak> > let fact x = if x ==1 then 1 else x * fact (x - 1) in fact 1000000
21:11:39 <remexre> (but I also know GHC with a level of handwaving that causes planes to try to rescue me)
21:11:41 <lambdabot>  mueval-core: Time limit exceeded
21:12:01 <pacak> > let fact acc x = if x ==1 then acc else  fact (acc * x) (x - 1) in fact 1000000
21:12:03 <lambdabot>  <Integer -> Integer>
21:12:13 <pacak> lambdabot:  WAT?
21:12:26 <remexre> > let fact acc x = if x ==1 then acc else  fact (acc * x) (x - 1) in fact 0 1000000
21:12:26 <monochrom> At the very minimum you still talk in terms of procedure calls in IO code.
21:12:30 <lambdabot>  0
21:12:42 <remexre> pacak: you didn't give it an acc arg
21:12:50 <remexre> but yeah, point taken
21:13:04 <Natblida> Sorry for interrupting but I don't get the difference between lists and tuples. What is it?
21:13:28 <pacak> Oh noes. /me forgot about acc.
21:13:53 <erisco> lists store zero or more items of the same type, whereas tuples store a fixed number of items of possibly different types
21:13:56 <pacak> > let fact acc x = if x ==1 then acc else  fact (acc * x) (x - 1) in fact 1 1000000
21:14:02 <lambdabot>  mueval-core: Time limit exceeded
21:15:29 <Natblida> Why can't lists do that?
21:15:44 <erisco> because that is not what a list is, or what it can do
21:15:50 <foojs> how is haskell is pure functional language ?
21:15:59 <remexre> Natblida: HLists can, but they're an advanced topic
21:16:26 <rotaerk> foojs, do you know what a pure function is?
21:16:37 <erisco> foojs, purity (same inputs same outputs, no side effects), and higher order functions (functions may take functions as arguments or return functions)
21:16:42 <srhb> foojs: Pure means "no side effects." "Functional" is a bit more difficult to expand on. For one, functions are actually functions.
21:17:18 <jle`> remexre: hlists are essentially tuples
21:17:23 <monochrom> HList is also a tuple, not a list.
21:17:42 <jle`> Natblida: i mean, what would the type of 'head' be?
21:17:46 <Natblida> erisco: Now that's almost an existential crisis.
21:18:02 <pacak> @src []
21:18:02 <lambdabot> data [] a = [] | a : [a]
21:18:03 <jle`> head :: [a] -> a
21:18:08 <erisco> Natblida, I had a conversation with lists about this, but they seem quite content with their existence
21:18:16 <jle`> if lists could contain items of different types, the type that head returns wouldn't make any sense
21:18:17 <remexre> jle`, monochrom: I thought you could still do (with much simplification of the type signature) HList l => l -> a -> HCons a l?
21:18:24 <geekosaur> and if the question is "then how doyou do anything?", it's via a trick
21:18:36 <pacak> So list holds either an empty list or a value of type a and one more list of type a
21:18:50 <geekosaur> specifically, we do not do I/O. we build programs that do I/O, and produce them as the result of main.
21:18:57 <jle`> remexre: i'm not sure exactly what that's supposed to mean
21:19:05 <geekosaur> the "do" notation lets us make this look like normal programming
21:19:33 <remexre> jle`: consing an arbitrary a onto an arbitrary HList?
21:20:01 <jle`> yeah, it's basically a question of whether an hlist is more like an inductively defined tuple than a list
21:20:22 <monochrom> Do not be taken in by "meaningful" names. Names lie. All the time.
21:20:39 <foojs1> haskell is not pure
21:20:49 <foojs1> after going through lazy evaluation ,  dis-believe haskell as pure functional language
21:20:54 <erisco> for example, monochrom is actually many colours
21:20:57 <Natblida> foojs1: Monster!
21:21:07 <jle`> foojs1: if anything, you can say that the semantics that haskell describes is pure
21:21:13 <jle`> and haskell gives you a way to describe pure algorithms
21:21:16 <pacak> foojs1: If you insist. We don't mind.
21:21:24 <erisco> and I am not actually a biscuit company
21:21:38 <jle`> whether or not it is pure in implementation is a different story, but it's definitely pure in semantics
21:21:44 <foojs1> haskell is impure from the beginning !
21:21:59 <jle`> the denotational semantics of haskell are at least pure
21:22:09 <jle`> everything else is perhaps up for debate
21:22:22 <remexre> foojs1: is this the same lazy vs memoized hangup I used to have? Laziness isn't implemented with memoization
21:22:25 <erisco> foojs1, so, what are you actually saying then
21:22:34 <jle`> but, denotation is the core of haskell
21:22:43 <remexre> foojs1: Also, computation time isn't (treated as) a side effect
21:22:58 <erisco> even if memoisation was used that wouldn't change anything about purity
21:22:59 <foojs1> its not pure aka it has side effects
21:23:10 <jle`> computation can be considered a side effect, but it's not a part of the denotational semantics of haskell
21:23:30 <jle`> foojs1: the denotational semantics of haskell do not have implicit side effects
21:23:38 <jle`> the process of evaluating haskell obviously does
21:23:46 <jle`> (evaluating haskell on a physical machine)
21:23:54 <erisco> foojs1, I think you should more carefully study IO and purity. I think you'd have a less strident position.
21:23:59 <foojs1> lol 
21:24:01 <jle`> but that's like saying f(x) = x^2 isn't a pure function, because humans have to eat food to compute it
21:24:22 <foojs1> jle`, your making no sense
21:24:23 <dumptruckman> lol
21:24:30 <dumptruckman> what, that makes perfect sense
21:24:40 <jle`> even if technically, evaluating `f(x) = x^2` for f(10) is, in practice, a process that has side-effects in the world
21:24:45 <remexre> foojs1: what's an example of a side effect you see haskell having that makes it impure?
21:24:46 <erisco> foojs1, there was a lot of work put into IO so it agreed with pure semantics, and it is quite interesting
21:24:48 <kadoban> foojs1: Then please define what meaning of "pure" and "impure" you're using.
21:24:52 <jle`> it's still useful to talk about the function f(x) = x^2 as a pure function
21:24:56 * pacak suspects foojs1 is here just to troll people
21:25:05 <jle`> same but i don't have anything better to do with my time
21:25:05 <kadoban> Probably
21:25:36 <andromeda-galaxy> we've turned trolls around before after all
21:25:38 <remexre> nah, an undergrad class I was in covered lazy evaluation in broad strokes, and the questions for the lecturer sounded a lot like foojs1's
21:25:47 <pacak> ghc eventlog file. is there a specification somewhere?
21:26:26 <foojs1> by allowing lazy evaluation and IO , dis-believe haskell is pure in anyway.
21:26:37 <Axman6> IO is definitely pure
21:26:42 <remexre> foojs1: what about lazy evaluation do you believe breaks purity?
21:26:54 <foojs1> yes remexre 
21:27:08 <bigdaddytank> why would lazy evaluation break purity?
21:27:15 <geekosaur> I do not think you are speaking the same language here
21:27:18 <kadoban> foojs1: Is there anything that fits in the category of "pure" then? Please provide some examples.
21:27:19 <geekosaur> that was not a yes/no question
21:27:31 <pacak> foojs1: define purity plox before making any more statements...
21:27:32 <erisco> a lack of understanding of laziness will break purity
21:27:50 <Axman6> foojs1: if you brought up exceptions, you could be excused, somewhat, but laziness and IO are definitely pure
21:27:50 <remexre> erisco :)
21:27:51 <geekosaur> and I already said how IO works, but I suspect you ignored that because it doesn't fit your claim and therefore is not allowed to be true
21:28:06 <foojs1> purity doesnt depend on any state
21:28:22 <bigdaddytank> Sounds like there's a different definition of "pure" here.
21:28:23 <jle`> foojs1: in haskell, the results of IO functions do not depend on any state
21:28:26 <kadoban> foojs1: What's state?
21:28:28 <foojs1> but with lazy evaluation can be depend on state
21:28:36 <jle`> foojs1: can you show a specific example?
21:28:40 <andromeda-galaxy> pacak: is https://downloads.haskell.org/~ghc/master/users-guide/eventlog-formats.html helpful?
21:28:47 <jle`> where the result of an evaluation depends on state?
21:28:49 <remexre> foojs1: doesn't g in g(x) = f(x + 1) depend on the state of f?
21:28:51 <jle`> if so, this would help your case
21:29:00 <foojs1> k , sure i encountered this https://en.wikipedia.org/wiki/Generator_(computer_programming)#Haskell
21:29:42 <jle`> that's not quite state, that's just calling functions with different parameters
21:29:44 <jle`> (pure functions)
21:29:54 <remexre> The output there is also generated with the IO monad, which is pure
21:30:04 <bigdaddytank> foojs1: lazy eval is just a matter of when something will be evaluated. Nothing in whatever will be evaluated gets changed 
21:30:13 <bigdaddytank> it just when something is called
21:30:29 <jle`> calling the same function with different parameters can potentially give different answers, but that's still within the realm of pure functions
21:30:37 <jle`> in math, for example, sin(1) is different than sin(3)
21:30:39 <bigdaddytank> Exactly
21:31:12 <pacak> andromeda-galaxy: Nope. I guess I'll have to fix ghc-eventlog...
21:31:36 <monochrom> https://xkcd.com/386/
21:31:47 <jle`> pacak: ghc has a reputation for having a particularly unstable api
21:32:01 <andromeda-galaxy> pacak: oh well, sorry. It might still exist somewhere but probably not
21:32:15 <erisco> this is why I sometimes ask a question aggressively... receives far more attention
21:32:48 <monochrom> But I think I actually have a policy for banning people who ask questions aggressively.
21:33:04 <foojs1> i believe haskell is pure all these days :! , since i never knew the language . :) sorry guys for buddin in . Thank you for listening .
21:33:35 <remexre> erisco: Just ask your question as "haskell can't even do <x>, when it's really easy in C" /s
21:33:51 <monochrom> Yes, that's the kind I will ban.
21:34:24 <erisco> it riles all up all the pundits who can't help but explain to you why you're wrong
21:34:25 <pacak> Haskell can't event do theorem proving with dependent types, when it's really easy in Coq.
21:34:36 <monochrom> haha
21:34:44 <erisco> :P
21:34:48 <andromeda-galaxy> hasochism
21:34:55 <remexre> Haskell can't even FFI to Python, when it's really easy in Python
21:35:06 <andromeda-galaxy> remexre: C glue makes it easy
21:35:18 <remexre> :P
21:35:24 <pacak> jle`: It's not that bad. I support vacuum for example and it knows a bunch of intimate details about haskell heap.
21:36:00 <dumptruckman> that was interesting
21:36:06 <dumptruckman> i wonder what that guy's native language was
21:36:14 <andromeda-galaxy> remexre: https://wiki.haskell.org/Applications_and_libraries/Interfacing_other_languages#Python
21:36:52 <remexre> andromeda-galaxy: I really wasn't serious... see, I should've chosen fortran as my example language
21:37:19 <andromeda-galaxy> yeah, I just like answering humorous questions... sometimes the answers are interesting
21:37:23 <andromeda-galaxy> (not this time though)
21:37:38 <remexre> Eh, the MissingPy library sounds really cool
21:37:48 <pacak> Fortran... Untyped lambda calculus.
21:37:51 <monochrom> Wait what, TclHaskell?!
21:37:52 <remexre> although I'm not thrilled about the destination of the link
21:38:17 <remexre> "Welcome to Gopherspace! You are browsing Gopher through a Web interface right now. You can use most browsers to browse Gopher natively."
21:38:50 <monochrom> Good old memories of Gopher.
21:39:16 <remexre> as a current umn student, I can confirm that we don't miss it
21:39:42 <bigdaddytank> Gopher?
21:39:46 <remexre> yeah
21:39:52 <remexre> although we have been missing http recently (we're "transitioning" to eduroam)
21:40:01 <bigdaddytank> The hell is Gopher?
21:40:14 <remexre> oh, man, you're missing out
21:40:15 <bigdaddytank> Like that shitty Go mascot?
21:40:24 <remexre> imagine the web without HTML gunking everything up
21:40:24 <monochrom> I'm afraid that's something you have to find for yourself.
21:40:24 <andromeda-galaxy> bigdaddytank: https://en.wikipedia.org/wiki/Gopher_(protocol)
21:41:08 <monochrom> Wait, eduroam is supposed to just mean wifi, no? How does it affect http?
21:41:28 <dumptruckman> that's what i was wondering too
21:41:39 <remexre> It involves a hugely more complicated signin machinery than just the LDAP gateway we were running (which is now deprecated)
21:41:45 <monochrom> Unless you mean they broke wifi so nothing ever works, including http.
21:41:49 <remexre> ^^
21:43:01 <dumptruckman> alright, night yall. preciate all the help
21:43:52 <geekosaur> monochrom, consider a broken http proxy
21:43:59 <geekosaur> or a broken https proxy these days
21:44:09 <bigdaddytank> So what was so bad about Gopher, if I'm reading this right it doesn't sound terrible
21:44:21 <bigdaddytank> On paper at least
21:44:23 <remexre> bigdaddytank: they didn't say "free forever" before HTTP did
21:44:40 <bigdaddytank> ohhhhh
21:44:54 <bigdaddytank> that makes sense
21:51:24 <geekosaur> heh
21:51:38 <geekosaur> actually the main difference is that gopher didn't let you have links
21:51:53 <geekosaur> which was the essence of "hypertext", the HT in HTTP
21:52:33 <geekosaur> so text in one file could link to text in another file
21:53:11 <remexre> Oh, like the baz in http://foo.com/bar#baz ?
21:53:53 <monochrom> No, <a href="url">click me!</a>
21:54:11 <remexre> Aren't those Gopher's menus?
21:54:16 <remexre> Or you mean having those inline?
21:54:37 <monochrom> Having those inline.
22:01:44 <geekosaur> having those inline in the document, as opposed to being in a separate gopher menu, yes
22:03:11 <remexre> Is there a better way to define a datatype that's *almost* the same as a large record other than factoring the common parts into a type and having e.g. Foo (Common, Int) and Bar (Common, String) ?
22:03:58 <remexre> (in reality like 4 or 5 fields with different types, not just 1, otherwise I'd parameterize it)
22:05:16 <rotaerk> refactoring is how I'd do it, myself
22:06:47 <remexre> :P here's the problem domain: I have a generic Ast.Module type and a few IR modules with types like Ir.Anf.Module, Ir.Llvm.Module, Ir.JsBytecode.Module, etc.
22:07:27 <Cale> I've rarely regretted factoring a large record type into smaller parts when multiple types seemed to have similar fields present.
22:07:43 <remexre> So have a Common (or ModuleMetadata) type?
22:07:56 <Cale> Yeah, something of that sort.
22:08:01 <remexre> okay
22:18:13 <mbrock> I think I spend too much time switching to my browser to search for help about libraries. Probably I should get my Emacs set up in some amazing way so that I can browse/search right in the editor
22:19:19 <rotaerk> mbrock, perhaps get a more efficient window manager or something
22:19:30 <rotaerk> one with less overhead for switching windows
22:19:57 <remexre> with i3, Win-1 is vim, Win-2 is Vivaldi
22:20:05 <mbrock> I'm already using stumpwm and switching windows is as easy as it gets, but the browser workflow feels suboptimal anyway
22:21:53 <mbrock> possibly if I used some browser extension for mouseless navigation it would be better but I've never been really happy with those
22:22:10 <rotaerk> is it the transition back and forth between mouse and keyboard that's the problem?
22:22:16 <monochrom> You need eye-tracking. :)
22:23:44 <mbrock> yeah, and some ergonomic issues with Haddock's "user interface" I suppose
22:26:01 <mbrock> it would be great to see an entire library's documentation on one page, with good incremental search and some keyword menu based navigation, or something like that
22:26:55 <mbrock> yesterday I found out how to use nix-shell to get a Hoogle running with all my project dependencies, which is cool :)
22:27:27 <rotaerk> hmm I should do that too
22:29:29 <mbrock> https://github.com/lessrest/restless-git/blob/master/shell.nix is my shell.nix that works with a standard default.nix made by cabal2nix
22:29:42 <anon1634> Anyone made a pirate box from a raspi?
22:30:59 <ski> anon1634 : is this Haskell-related ?
22:33:50 <andromeda-galaxy> so sorry if this is too mathy of a question for this channel, but: is there a reasonable way of characterizing all the endiannesses that exist in the wild (including weird middle endian things like PDP-11 or generally k-data-invariant little/big-endian) that makes it possible to efficiently learn the int64 <-> memory representation bijection with (ideally nonadaptive) queries?
22:34:19 <andromeda-galaxy> (this is haskell related insofar as it came up while working on a haskell project and I have no idea where else to talk about it)
22:35:05 <dmwit> Man. I can't tell you just how hard I would work to avoid needing that.
22:35:16 <dmwit> Why are you supporting PDP-11?
22:35:41 <andromeda-galaxy> mostly just because its a well known example of weird endianness
22:35:42 * rotaerk had never heard of PDP-11 until now.
22:35:56 <andromeda-galaxy> certain ARMs and DSPs can result in similar things, I think
22:35:59 <dmwit> "YAGNI" comes to mind
22:36:21 <andromeda-galaxy> I'm trying to read values from the static data segment produced by a cross compiler onto any architecture on which ghc might possibly target
22:36:55 <monochrom> I brought up PDP-11 yesterday. It's my fault. :)
22:38:26 <dmwit> *Probably* most architectures use 2's complement with a fixed ordering of bits in memory. In which case `map setBit [0..63]` seems like a nonadaptive set of queries which really ought to cover all the bases.
22:38:41 <kadoban> andromeda-galaxy: Am I missing something or couldn't you get any possible endianness data out of just setting each bit (1,2,4,8,16,32,etc.) and then checking where it exists in the representation? Or if they're all 8-bit bytes, setting each byte to anything.
22:38:55 <dmwit> jinx
22:38:58 <kadoban> heh
22:39:23 * dmwit blames monochrom as hard as he can
22:39:27 <dmwit> monochrom: (Is it working?)
22:39:49 <andromeda-galaxy> actually yeah. I have no idea why I didn't think of that earlier
22:39:51 <dmwit> Oops, I wanted `bit`, not `setBit`.
22:40:02 <andromeda-galaxy> I've been doing too much statitical learning theory recently
22:40:11 <andromeda-galaxy> now I see it popping up everywhere, even where it isn't needed
22:40:48 <monochrom> Haha yeah.
22:40:52 <andromeda-galaxy> I think it's probably safe to assume that (1) all the long longs in the integer data segment are using the same endianness and that (2) there is a fixed ordering of bits in memory
22:40:52 <kadoban> PDP-11 is like the IEEE floating point of computers. It has so many weird properties, it's a nice example of "this breaks your rules"
22:41:16 <kadoban> I would hope so, though it'd be funny if that weren't true.
22:41:20 <andromeda-galaxy> afaik pdp 11 doesn't break those
22:41:23 <monochrom> "How do I learn the endian scheme of this environment in the fewest steps using Leslie Valiant's PAC methods?"
22:41:28 * erisco is currently raising capital for a hardware startup to break your standards
22:41:51 <c_wraith> erisco: I'll contribute $0.03
22:41:57 <andromeda-galaxy> monochrom: that is a nice phrasing
22:42:03 <andromeda-galaxy> erisco: which one? how so? why?
22:42:06 <dmwit> monochrom: Wrong question. How do I design an environment that makes it maximally difficult to apply a PAC method to learn the in-memory encoding?
22:42:49 <andromeda-galaxy> dmwit: well the obvious solution there is just to assign bit patterns to numbers completely at random
22:43:00 * dmwit decides that in-memory bit pattern 01101011 is going to represent logical bit pattern 01101101
22:44:17 <kadoban> I think the in-memory bit pattern should include parity bits in various locations, depending on the actual physical memory location. The location they exist at should be randomized at system startup.
22:44:46 <dmwit> oh ho ho
22:44:51 <andromeda-galaxy> kadoban: that's still more ordered than random representations for each logical value, right? Admittedly way easier to implement
22:44:52 <c_wraith> kadoban: it's a defensive measure against rowhammer, right?
22:44:57 <dmwit> We just blithely assumed that Int64 was going to fit in 64 bits, didn't we??
22:45:06 <kadoban> c_wraith: Hah, yes, let's go with that.
22:45:26 <kadoban> andromeda-galaxy: Yeah, it could get worse I suppose
22:45:38 <dmwit> Let's Huffman-encode our numbers. 0 is the most common Int64, so it should take fewer bits.
22:46:03 <kadoban> That's ... almost reasonable sounding until you think about it. I like it.
22:46:09 <c_wraith> dmwit: why not just drop all leading 0 bits?
22:46:11 <andromeda-galaxy> I like both of those suggestions
22:46:40 <erisco> dmwit, names lie, they lie all the time.
22:46:56 <erisco> dmwit, a person told me, can't remember
22:46:57 <kadoban> Wasn't there some mode in some old DOS version where you could turn on basically it'd use some compression algorithm on memory itself to try to give you more available memory?
22:47:04 <c_wraith> kadoban: doublespace
22:47:33 <kadoban> Oh, disk. I thought it was RAM for some reason. That makes more sense.
22:47:44 <c_wraith> Oh, there was a disk version too.  Was that... umm..  stacker?
22:47:49 <c_wraith> err, ram version too
22:48:32 <andromeda-galaxy> neither dos nor old but: https://en.wikipedia.org/wiki/Zram
22:48:37 <c_wraith> Stacker was also drive space.  Eh, not sure.
22:48:47 <monochrom> My Windows 10 Task Manager says that there is some compressed memory in use.
22:49:13 <monochrom> But DOS only ever tried disk compression.
22:49:29 <kadoban> Heh
22:50:25 <ongy> maybe compressed swap
22:50:32 <begriffs> I'm trying to upload a new version of my haskell package with "stack upload ." but it fails with "gpg: signing failed: No secret key." I don't remember it needing to sign the package when uploading in the past...
22:51:29 <phadej> changed default? --no-signature           Do not sign & upload signatures
22:51:37 <kadoban> New hackage thing maybe?
22:51:52 <phadej> nope, gpg signing is stack(age) thing
22:52:09 <andromeda-galaxy> but come to think of it I actually don't like having to assume two's complement. maybe it's time to revisit the pac methods?
22:52:10 <kadoban> Ah
22:52:50 <begriffs> OK, I'll see if --no-signature works. (Then maybe finally get around to generating a nice secure offline key for myself that I can use in the future)
22:53:22 <kadoban> andromeda-galaxy: You can probably tell two's complement apart from any reasonable other choices via just trying a few more numbers. Like .. negative ones.
22:53:58 <kadoban> Ideally without checking every possible Int64 I hope.
22:54:00 <andromeda-galaxy> kadoban: right, so recognizing twos complement is probably not terribly hard. but learning to decode the non-two's-complement value is weirder
22:54:01 <phadej> kadoban: https://github.com/haskell/cabal/issues/3845
22:54:11 <kadoban> andromeda-galaxy: Yeah, a little
22:54:25 <andromeda-galaxy> only a little?
22:54:44 <kadoban> Well, I mean what other than that actually exists anywhere? sign magnitude and ... that's it?
22:55:59 <andromeda-galaxy> I don't know which of these exist in hardware, but they seem possible: one's complement, sign-magnitude. offset complement represetnations like in ieee floating point exponents, negative bases
22:56:38 <andromeda-galaxy> probably good enough to just look for two's complement, one's complement, and sign-magnitude and throw an error asking the user to add a special case for their weird number format otherwise
22:56:40 <kadoban> Yeah, true. Though I don't know what one or two of those are, heh.
22:59:09 <geekosaur> I don't think 1s comp hardware exists any more. early computers used it but 2s comp was easier to implement
22:59:17 <dmwit> andromeda-galaxy: My answer would be to support big-endian and little-endian, and maybe toss in one or two sanity assertions, then release it on the unsuspecting wild and wait for complaints.
22:59:48 <andromeda-galaxy> geekosaur: nice to know - I know 2s comp is way more popular, but wasn't sure that others weren't still in occasional use
23:00:32 <begriffs> Interesting, I see cabal-install 2.0 is on hackage. Any recommended articles about the changes and how to use it properly?
23:00:49 <andromeda-galaxy> dmwit: yeah, maybe a better idea... then I'd actually get to write some code. afaik even arm's weird thing with nonaligned numbers isn't going to be how the compiler outputs it. (or at least, I hope so)
23:01:14 <geekosaur> the big thing about 2s comp was that it could be done easily without extra logic, whereas all other representations require extra logic to implement. sometimes you find those in software but the hardware is all 2s comp.
23:02:12 <ongy> -0 not being a thing can also simplify things
23:03:07 <andromeda-galaxy> I know the reasons that 2s comp is pretty much universal nowdays. I just also knew about the really old hardware that did things in 1s comp/sign-magnitude. I guess its probably safe to assume that no one is running haskell on one of those, though
23:03:15 <geekosaur> but they hadn't yet figured that out in the early days so they did 1s comp as what they thought was easiest, until someone proved that 2s comp needed less logic and worked (and didn't introduce a signed zero integer they had no idea how to treat)
23:03:53 <`Guest00000> andromeda-galaxy: just you wait
23:04:05 <andromeda-galaxy> `Guest00000: ?
23:04:18 <geekosaur> wasn't just about saving money, either; fewer tubes to replace meant fewer things crashing your calculations :p
23:05:34 <`Guest00000> andromeda-galaxy: in response to message about running haskell on old hardware
23:06:43 <andromeda-galaxy> geekosaur: fair enough
23:07:00 <andromeda-galaxy> `Guest00000: lmk when you do that and I'll special case your project because its so awesome
23:09:12 <dminuoso_> Hi. Im into the monad chapter of the gentle introduction and the implementation of the second state monad is somewhat confusing. I understand what it does and how its used (which is why lifting all those functions makes perfect sense), but I have a real problem understanding how it "suspends computation"
23:09:28 <dminuoso_> Or rather the exact "how does it work" is unclear to me.
23:09:56 <`Guest00000> i'm not promising anything, but i'm actually trying to achieve running haskell efficiently on a certain old platform
23:10:02 <dminuoso_> Im beginning to wonder whether the gentle introduction is the right step, because I feel like they handed me a brick walnut to crack on my own
23:10:05 <`Guest00000> further details are spoiler
23:10:17 <`Guest00000> i'm currently at writing the parser for haskell stage
23:10:45 <andromeda-galaxy> `Guest00000: sounds quite cool. plans for dealing with severe memory constraints?
23:12:30 <andromeda-galaxy> @learn -- dminuoso_
23:12:31 <lambdabot> https://wiki.haskell.org/Learning_Haskell
23:12:46 <andromeda-galaxy> dminuoso_: the second state monad?
23:13:07 <`Guest00000> andromeda-galaxy: basically, i want compiler to know about a family of 'representations' for every possible type and choose the best machine representation for given code
23:14:01 <dminuoso_> andromeda-galaxy: Yeah. The one following the type newtype R a = R (Resource -> (Resource, Either a (R a)))
23:14:40 <dminuoso_> I suppose just the (r', Right pc1) case of >>= confuses the hell out of me
23:14:52 <`Guest00000> so that [1..] will compile to "inc rax" in given situations on x64, for example
23:15:06 <andromeda-galaxy> `Guest00000: sounds nice. one of the things that I've had floating around in the back of my head is mildly related, which is making idris or whatever recognize that isomorphism between (ugly-but-fast) and (pretty-but-simple) types mean that code/proofs with the latter should be compiled to the former
23:15:20 <andromeda-galaxy> `Guest00000: your thing goes one step deeper, which I find cool to think about
23:16:01 <andromeda-galaxy> dminuoso_: let me find that example
23:16:26 <dminuoso_> andromeda-galaxy: Half way into 9.3 https://www.haskell.org/tutorial/monads.html
23:18:18 <andromeda-galaxy> dminuoso_: okay, so c1 r here represents the result of running this computaiton c1 with the given set of resources r, right?
23:19:08 <andromeda-galaxy> if c1 runs out of resources and can't finish, it's basically going to return, along with the resources that it has left, a continuation: if you give it more resources, it'll pick up where it left off, and, if it has enough resources now, eventually give you that 'a' value that you wanted
23:19:21 <andromeda-galaxy> pc1 here is that continuation
23:19:32 <andromeda-galaxy> so in this case, since we don't have the result value of c1, we cant pass it into fc2
23:20:18 <andromeda-galaxy> rather, we need to update the continuation that we return, so that when pc1 finishes computing the value that we were originally hoping c1 would compute, that result gets passed into fc2
23:21:00 <andromeda-galaxy> dminuoso_: does that make a little bit more sense? or if not, what specifically is confusing you?
23:25:15 <sqooq> I think i'm about to give up on my gui adventure
23:25:17 <sqooq> this is hopeless
23:26:50 <andromeda-galaxy> sqooq: hmm?
23:27:28 <sqooq> I'm trying to make a plottable graph by mouse
23:27:31 <sqooq> line graph
23:28:29 <andromeda-galaxy> sqooq: plottable graph? by mouse? haskell specific details?
23:28:43 <andromeda-galaxy> dminuoso: btw I personally recommend haskellbook.com for haskell learning
23:30:39 <sqooq> andromeda-galaxy: a line graph like with https://github.com/timbod7/haskell-chart/wiki but where the points come from mouse click and position.
23:30:57 <andromeda-galaxy> okay
23:31:06 <sqooq> It has a cairo backend
23:31:10 <sqooq> so I can use gtk
23:31:18 <andromeda-galaxy> sounds good
23:31:20 <sqooq> but that's as far as I get
23:31:34 <`Guest00000> is there a haskell2010-to-C compiler that Just Works?
23:32:01 <Axman6> I'm not sure there ever way. GHC's C backend has (thankfully) been removed IIRC
23:32:06 <Axman6> was*
23:32:21 <kadoban> I thought last time this came up it turned out that GHC could still do it. Or maybe I'm remembering wrong.
23:33:06 <`Guest00000> Just Works meaning it could output C code for given haskell2010 code without any non-trivial pre-efforts
23:33:20 <`Guest00000> and, correct C code
23:33:39 <andromeda-galaxy> sqooq: would https://lettier.github.io/posts/2017-08-30-haskell-gtk-video-player.html perhaps be useful?
23:34:06 <Axman6> `Guest00000: GHC has never really been able to do that, it always needed to postprocess the object files with the Evil Mangler
23:34:48 <hololeap> `Guest00000: not an expert, but i think the GC (among other things) would make it pretty difficult to replicate arbitrary haskell code exactly in c
23:34:59 <MarcelineVQ> andromeda-galaxy: hey neat
23:35:04 <Axman6> I'm not sure if any of the other research haskell compilers implement Haskell2010 (though it wasn't exactly a big change from 98)
23:35:13 <andromeda-galaxy> hololeap: well you can of course just make the garbage collector part of the C that you generate
23:35:19 <Axman6> `Guest00000: why do you want this?
23:35:32 <andromeda-galaxy> `Guest00000: the closest that I'm aware of is building ghc in unregisterised mode for porting to a new platform and then -fvia-C
23:35:51 <sqooq> andromeda-galaxy: not too much. Gtk isn't too bad actually. The hard part is connecting mouse clicks into Chart in the correct way. 
23:36:06 <sqooq> i'll still go through it though
23:36:09 <andromeda-galaxy> `Guest00000: jhc might be usable also?
23:36:11 <sqooq> will probably still learn something
23:36:20 <andromeda-galaxy> MarcelineVQ: yeah!
23:36:39 <andromeda-galaxy> sqooq: nvm, I wasn't sure where your problem was
23:36:53 <andromeda-galaxy> what particularly is giving you difficulty about connecting mouse clicks to the chart?
23:36:59 <hololeap> the only time i've considered converting haskell to c is to make live easier in embedded programming, and the GC was the big problem
23:37:17 <andromeda-galaxy> hololeap: jhc can do region inference afaik
23:38:09 <andromeda-galaxy> actually `Guest00000 not sure if it is Haskell2010 or not but I'm pretty sure jhc/ajhc is close to what you are looking for. It at least is H98 + several extensions
23:38:17 <`Guest00000> Axman6: imagine i want to write a haskell compiler. in haskell (duh). then, people want to compile it from source; but then they need a haskell compiler... then, some people may be suspicious of any haskell compilers' binaries. they want it all from-source. anything they will ever trust is some gcc. so, i just need a HS10toC to generate C code for my compiler for gcc to compile...
23:39:54 <dmwit> Yeah, if these folks don't trust your Haskell-to-ASM compiler, there's no way they're going to trust your Haskell-to-C compiler.
23:40:13 <hololeap> isn't that like the "ken thompson hack"? (how do they know if their gcc isn't compromised?)
23:40:13 <dmwit> And it's not like it's going to be producing readable C (or ASM).
23:40:43 <`Guest00000> hololeap: their last piece of sanity is trusting absolutely in their gcc
23:41:45 <sqooq> andromeda-galaxy: I guess I need to understand the chart-cairo backend better
23:43:03 <`Guest00000> dmwit: they can trust anything which they can read source for (and which doesn't have any actual backdoor of course); they can't trust any binaries which they didn't create themselves with a trusted compiler
23:43:31 <hololeap> `Guest00000: i would say, provide them with the haskell source and leave it to them to compile it in whatever manner they feel is safe
23:43:52 <`Guest00000> i always can distribute binary for my compiler; will they trust it?
23:43:52 <sqooq> nvm
23:43:56 <sqooq> the backend is like one page
23:43:58 <sqooq> doesn't help much
23:44:29 <Axman6> `Guest00000: that sounds pretty silly to me
23:44:35 <andromeda-galaxy> sqooq: oh well, sorry I'm not terribly much help here. if there is specific code causing you trouble I'm  happy to take a look though
23:44:51 <Axman6> I definitely don't trust GCC
23:44:53 <andromeda-galaxy> `Guest00000: why don't they just read the source for ghc and your haskell compiled via ghc?
23:45:11 <`Guest00000> andromeda-galaxy: they don't trust ghc binary
23:45:21 <Axman6> I may trust CompCert
23:45:24 <`Guest00000> they only trust gcc
23:45:40 <andromeda-galaxy> `Guest00000: cool, they can build ghc themselves then?
23:46:03 <ongy> ghc is writtin in haskell. there's a non trivial bootstrap problem here.
23:46:21 <andromeda-galaxy> ongy, `Guest00000: https://ghc.haskell.org/trac/ghc/wiki/Building/Porting
23:46:41 <`Guest00000> can you build ghc without ghc?
23:46:44 <sqooq> thanks anyway
23:46:49 <ongy> "This is no longer supported. " did you even read that?
23:47:17 <andromeda-galaxy> yeah, but if you really care about it you can probably still make it work
23:48:18 <cocreature> unless you are willing to set up a really long chain of bootstrappping compilers most of which probably don’t work without changes on todays systems you really can’t
23:48:48 <pacak> `Guest00000: You can try starting by compiling some ancient ghc with ancient hugs then compiling a few more versions
23:48:54 <andromeda-galaxy> but seriously `Guest00000 if you insist on satisfying this irrationality I would say look at jhc or nhc98, not super maintained and H98 + various extensions, but jhc at least does generate relatively nice C
23:49:27 <andromeda-galaxy> cocreature: darn, really? I have a vague memory of building unregisterized ghc a year or two ago and it working
23:49:57 <ongy> cross compiling from an existing GHC works. but bootstrapping out of a C compiler requires ages old GHC versions that then compile a chain of slightly newer GHC
23:50:07 <hololeap> jhc seems pretty cool. any chance it could allow me to code arduino in haskell?
23:50:32 <Axman6> I think it has been used for that
23:50:38 <Axman6> hololeap: you might also like copilot
23:50:42 <MarcelineVQ> you can already code arduino in haskell, it's a restricted runtime so you can make up a dsl
23:51:01 <andromeda-galaxy> hololeap: maybe, but copilot/atom/ivory edsls are probably more suited to that
23:51:34 <andromeda-galaxy> ongy: ah. but can't `Guest00000 use the ghc that he trusts to compile an unregisterized ghc, and then use that to compile his code to C?
23:51:53 <cocreature> andromeda-galaxy: you still need ghc to build an unregistered ghc.
23:52:04 <digitalkiwi> can't you build ghc with ghc and then compare the binaries (and since you have the source) you can prove that the binary you compiled is the same as the binary you used to build that one
23:52:08 <pacak> `Guest00000 left the room (quit: Ping timeout: 252 seconds).
23:52:18 <pacak> Hmmm... Maybe he was right and somebody is after him...
23:52:18 <MarcelineVQ> hololeap: specifically http://www.nongnu.org/avr-libc/user-manual/modules.html
23:52:53 <hololeap> sweet
23:53:18 <andromeda-galaxy> right. since `Guest00000 is writing a compiler: use a ghc that you don't trust to build an unregisterised ghc that you don't trust. use that to compile `Guest00000's new compiler to plain c, then read that C to make sure that it does what you want. done.
23:53:41 <cocreature> what could be more fun to read autogenerated C
23:53:43 <MarcelineVQ> hololeap: those are your primops, you can probbaly use a c dsl that exists already to stitch them together, dunno really I've no experience with that
23:53:51 <digitalkiwi> this seems like a lot of hoops when the OS is probably hacked anyway 
23:54:10 <ertes-w> l
23:54:11 <MarcelineVQ> hololeap: copilot/atom/ivory which andromeda-galaxy mentioned are worth looking at
23:54:13 <ongy> digitalkiwi: reproducable builds aren't trivial. and afaik GHC can mess it up. not sure if they took care for that in the GHC source
23:54:48 <`Guest00000> well, too much insanity. whatever. i'm postponing this problem.
23:55:20 <digitalkiwi> ++ indefinitely
23:56:50 <hololeap> the rabbit hole of trust seemingly goes on forever, unless you have an electron microscope and can be absolutely sure there isn't a hardware backdoor in your CPU
23:57:18 <MarcelineVQ> Unfortunately there is a hardware backdoor in your cpu
23:57:18 <cocreature> hololeap: but what about the hardware backdoor in your electron microscope :p
23:57:57 <hololeap> or the hardware backdoor in your eyeballs :)
23:58:23 <MarcelineVQ> there's even industry agreed apon backdoors common to major cpus. lots of fun to be had there  https://www.youtube.com/watch?v=KrksBdWcZgQ
23:58:41 <`Guest00000> let's try a simpler problem. i have a list of lists. every list in list is sorted. also, some or all inner lists and/or outer list may be infinite. i need to (sort . concat) the list of lists efficiently
23:59:27 <`Guest00000> well, outer list being infinite is unfortunate
23:59:47 <`Guest00000> maybe they all are finite
23:59:50 <cocreature> so you want a multi-way merge?
