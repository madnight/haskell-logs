00:11:00 <logan0405> what is the difference:
00:11:01 <logan0405> [(a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a+b+c == 24]
00:11:10 <logan0405> [(a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10], a^2 + b^2 == c^2, a+b+c == 24]
00:11:28 <logan0405> i don't understand what ..c and ..b does in the first?
00:14:12 <raynold> ahh it's a wonderful day
00:17:53 <logan0405> oh nvm i figured it out after staring at it for a while haha. i thought 1..b and 1..c would be the same as 1..10 but i guess it combines them into all possible combinations so won't always be 10
00:22:30 <[exa]> logan0405: it prevents the same pairs from occurring (see it as an area under diagonal)
00:23:30 * hackagebot aivika 5.3, aivika-experiment 5.1, aivika-experiment-cairo 5.1, aivika-experiment-chart 5.1, … and 3 more
00:23:30 * hackagebot  → https://hackage.haskell.org/packages/recent
00:23:46 <logan0405> yeah it confused me. i saw [1..10] and thought it would be calculated at start. but [1..c] seems to calculate it each loop through. pretty cool
00:23:55 <[exa]> logan0405: the point is better for infinite lists, if you have [(a,b) | a<-[1..], b<-[1..] ] then (2,1) won't ever happen
00:24:44 <[exa]> for b<-[1..a] all pairs will be there eventually
00:26:24 <logan0405> so what happens with b <- [1..c] ? i know it filters out b's which are less than c but is the logic behind that like zip? where if you have 2 lists of different lengths it takes the length of shorter one and zips those elements together?
00:26:52 <logan0405> trying to wrap my head around it
00:28:30 <logan0405> *filters out b's larger than c's
00:30:36 <[exa]> no, list comprehension (and monad) works more like prolog with multiple possibilities specified at once
00:31:12 <[exa]> a<-[1..] says "set a to 1 and after the computation finishes, restart it with a=2"
00:31:59 <[exa]> b<-[1..a] gets "called" for each such a, again creating multiple "branches" of restarted computation
00:32:07 <logan0405> am i correct that it filters out b's larger than c's?
00:32:55 <[exa]> there's no filtering, it just doesn't generate any 'c' that would be larger than actual 'b'
00:33:38 <logan0405> right but wouldn't there be less tuples then? so it's kind of like filtering?
00:34:04 <logan0405> or is it the same count but just no c's large than any b's
00:34:25 <[exa]> yeah I finally got what you're asking (probably), (1,2) won't be in the result
00:34:44 <logan0405> alright. haha yeah that's gonna take me a while to fully wrap my head around. thnaks
00:34:49 <[exa]> let's fix that while still generating all pairs :]
00:35:24 <[exa]> there's e.g. a method how to generate all rational numbers: https://upload.wikimedia.org/wikipedia/commons/thumb/8/85/Diagonal_argument.svg/429px-Diagonal_argument.svg.png
00:36:39 <[exa]> which would be, in haskell, something like:
00:36:55 <[exa]> > take 10 [(a-b+1,b) | a<-[1..], b<-[1..a] ]
00:36:58 <lambdabot>  [(1,1),(2,1),(1,2),(3,1),(2,2),(1,3),(4,1),(3,2),(2,3),(1,4)]
00:37:17 <logan0405> that's sick. the lazy evaluation is a really cool concept, never seen anything like it
00:40:58 * hackagebot colorless 2.1.0 – Colorless – https://hackage.haskell.org/package/colorless
00:42:43 <[exa]> logan0405: this is actually not necessarily lazy, except for the infinite list instance
00:45:10 <[exa]> > all (`elem` [(a-b,b-c,c) | a<-[0..], b<-[0..a], c<-[0..b]])  [(a,b,c) | a<-[0..10], b<-[0..10], c<-[0..10]]
00:45:13 <lambdabot>  True
00:45:27 <[exa]> oh great it works
01:27:08 <kuribas> what's the most popular (mainstream) functional language?
01:34:48 <barrucadu> kuribas: Maybe Scala?
01:34:56 <srhb> kuribas: Depends how you define functional... Erlang is pretty big in some sectors.
01:35:32 <srhb> And there's the whole French Ocaml thing :P
01:35:49 <kuribas> srhb: type inference, HOFs, prefering pure computations
01:35:58 <srhb> Haskell, then.
01:36:49 <kuribas> srhb: Erlang doesn't have type inference?
01:37:12 <srhb> It doesn't even have proper types.
01:37:40 <srhb> Or well, I guess it is technically typed, but dynamic typing feels so.. Useless.
01:38:22 <kuribas> after programming one month without type, I've sworn my next job will have static types.
01:38:34 <madknight> whats a short version of port <- (\p -> read p :: Int) <$> (getEnv "PORT")?
01:38:45 <srhb> kuribas: Right, exactly.
01:39:03 <barrucadu> madknight: Do you really need the ':: Int'?  Doesn't type inference figure that out for you based on where you use 'port'?
01:39:22 <kuribas> srhb: if just for the time lost running the program and waiting for it to crash.
01:39:39 <srhb> kuribas: Yeah. But I guess erlang programmers will disagree.
01:39:44 <srhb> And they do make some cool stuff.
01:39:53 <madknight> barrucadu, ghci complains otherwise, so yes i need Int param for scotty port
01:40:13 <kuribas> clojure doesn't seem to have static types neither.
01:40:18 <ahihi> scala is certainly more popular than haskell
01:40:34 <kuribas> how is scala's type system?
01:40:43 <madknight> barrucadu, i dont think that type inference is able to convert a "123" to 123 since its not a safe operation
01:40:45 <ahihi> it doesn't have referential trsnsparency, but pure functions are preferred by convention
01:41:34 <barrucadu> madknight: Type inference won't turn a "123" into 123, but if port is used as an int, `port <- read <$> getEnv "PORT"` should suffice
01:41:38 <ahihi> scala's type system is kind of a weird mashup of FP and OOP
01:42:39 <ahihi> so you have algebraic data types, type classes (traits), higher-kinded types but also a lot of subtyping
01:42:41 <exio4> madknight: type inference doesn't convert types
01:42:48 <madknight> barrucadu, ah smart, yes that was exactly what i was missing there
01:44:04 <[exa]> madknight: if you really want the type constraint there, shortest is probably (read <$> getEnv "PORT") :: IO Int
01:44:05 <madknight> exio4, maybe its fair to use it as thought model
01:44:35 <exio4> madknight: not really, type inference is meant to `understand` the code, and find the type of an expression, not convert things
01:45:49 <kuribas> ahihi: do scala programmers try to shoehorn OO into every problem?
01:46:14 <madknight> exio4, hmm but if i explicitly know that a type is String and haskell "understands" that i want a Int, than name it how you want, it is a kind of conversion / reinterpretation
01:46:15 <ahihi> kuribas: depends on their background, i guess :)
01:46:20 <ahihi> i sure don't
01:46:25 <Sornaensis> OOP was a mistake
01:46:32 <srhb> I am considering Scala as a way to "legitimize" FP in an enterprisey context
01:46:38 <srhb> Though I find it hard to let go of the Haskell dream.
01:46:42 <kuribas> Sornaensis: it made sense in the time
01:47:18 <exio4> madknight: I am failing to parse that sentence, if something is a String, then type inference shall give you an integer, or not give you anything (because for some peculiar reason, it failed, and doesn't know the type of the expression)
01:48:07 <exio4> madknight: "abc" is always a String, a [Char], no matter if it is you with a explicit type signature "abc" :: String or Haskell infering the type
01:48:24 <exio4> shall never give you an integer* sorry - it's 6AM :)
01:49:10 <madknight> exio4, if you know C++, i think of it as reinterpret_cast
01:49:24 <kuribas> madknight: you have an "expected type", the type of the hole in the expression, and the "actual" type, what you are putting there.  Haskell try to find a type that matches both.
01:49:28 <Sornaensis> think of what, type signatures?
01:49:32 <barrucadu> There is no casting going on
01:49:47 <Sornaensis> in some cases a type may be ambiguous-- multiple options
01:49:52 <Sornaensis> so you have to specify one
01:50:07 <[exa]> madknight: read actually works as lexical_cast
01:50:28 <kuribas> madknight: conversions are done by typeclasses, at the value level, not type level.
01:51:06 <exio4> madknight: reinterprest doesn't exist in Haskell (ignoring unsafe low-level libraries meant for very specialized tasks)
01:51:51 <kuribas> madknight: there is no type that matches both String and Int
01:52:04 <madknight> so you're saying i have a String and then i get an Int and that is not a conversion
01:52:26 <exio4> you need to apply a function to obtain an Int from a String, and it might fail
01:52:44 <exio4> you're not relying on the type system "making things work", but a function which has a type that matches String -> Int 
01:52:54 <kuribas> exio4: well, you could return 0 if the string doesn't parse
01:53:19 <exio4> kuribas: yup, "might" :)
01:53:38 <kuribas> exio4: I am not saying you should!
01:54:18 <madknight> exio4, yup but it seems as haskell types inference automagically applies that String -> Int function for me, can in think of it this way
01:54:46 <Sornaensis> :t read
01:54:48 <lambdabot> Read a => String -> a
01:54:52 <kuribas> madknight: that's simply wrong
01:55:02 <kuribas> madknight: show the code that you think does this?
01:55:04 <barrucadu> You are applying the function (which is 'read'), but type inference figures out which 'read' you mean.
01:56:28 <Sornaensis> > read "1234"
01:56:30 <lambdabot>  *Exception: Prelude.read: no parse
01:56:40 <kuribas> > read "()"
01:56:43 <lambdabot>  ()
01:56:45 <Sornaensis> > read "1234" :: Int
01:56:48 <lambdabot>  1234
01:57:16 <fakenullie> read defaults to unit?
01:57:16 <madknight> barrucadu, ah okay now i understand, currently looking at the Read Instance
01:58:03 <fakenullie> > read "(1,2)" :: (Int, Int)
01:58:03 <srhb> fakenullie: type defaulting in general.
01:58:04 <madknight> so let me put it this way, haskells type inference looks up the right function for me based on the type that i need
01:58:05 <lambdabot>  (1,2)
01:58:19 <kuribas> madknight: type classes do
01:58:40 <fakenullie> > read "(1,\"2\")" :: (Int, String)
01:58:43 <lambdabot>  (1,"2")
01:58:49 <Sornaensis> type inference is a different level
01:58:55 <kuribas> madknight: Int is an instance of the Read type class
01:59:09 <Sornaensis> the type checker just unifies the types
01:59:48 <srhb> fakenullie: (In ghci, that is, which includes extended defaulting)
02:00:04 <fakenullie> > read "123" : (Num a) => a
02:00:06 <lambdabot>  <hint>:1:22: error: parse error on input ‘=>’
02:00:16 <fakenullie> > read "123" :: (Num a) => a
02:00:19 <lambdabot>  error:
02:00:19 <lambdabot>      • Could not deduce (Read a1) arising from a use of ‘read’
02:00:19 <lambdabot>        from the context: Num a
02:00:29 <fakenullie> ok
02:00:44 <kuribas> madknight: if an expression wants an (Read a => a) value, and you give it an Int, it will try to find the Read instance for Int, then substitute the definition of the function.
02:00:44 <srhb> fakenullie: You can try setting :set -XNoExtendedDefaultRules
02:00:55 <srhb> fakenullie: You'll the find that read "" is properly ambiguous
02:01:07 <srhb> Or reverse [] or whatever.
02:01:14 <srhb> (Or even [])
02:02:30 <madknight> kuribas, so the type inference will put in (substitute) the right function for me, in case it exist (my target type is a read instance)
02:02:48 <kuribas> madknight: something like that
02:03:08 <Sornaensis> magic
02:05:10 <madknight> kuribas, okay so i adjust my thought model to think of it like that, anyway thx for assistance
02:05:42 <kuribas> madknight: if you think of types as sets, than unification means finding the intersection of two sets.
02:07:06 <kuribas> madknight: but I think reading up on typeclasses will help you more
02:07:40 <madknight> kuribas, makes sense, actually the unification is a set / type itself then right?
02:09:39 <kuribas> madknight: unification is how haskell takes two types, and tries makes a single type from it.
02:13:36 <madknight> kuribas, but if i think of it as sets, then its a subset (type)
02:14:28 <kuribas> madknight: unification can be though of as an operation over sets
02:15:27 <kuribas> hm, now I am actually not sure the analogy is sound...
02:16:14 <madknight> kuribas, hmm if i think it this way then the Int Set should actually be a proper Subset of String
02:16:30 <kuribas> madknight: yes, and it isn't
02:16:55 <kuribas> madknight: but the Int set is a subset of the Read set
02:17:14 <kuribas> > "123" :: Int
02:17:16 <lambdabot>  error:
02:17:16 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘[Char]’
02:17:16 <lambdabot>      • In the expression: "123" :: Int
02:17:38 <madknight> but why is that?
02:18:47 <kuribas> madknight: strings and integers are different things
02:21:00 <madknight> kuribas, but if Int is only a Subset of Strings then i could say Int is a specialized Instance of String or so and haskell could automatically infer that for me without the need for Read
02:21:12 <Sornaensis> you cant change types, only specify them
02:21:24 <Sornaensis> > "123" :: a
02:21:26 <lambdabot>  error:
02:21:26 <lambdabot>      • Couldn't match expected type ‘a1’ with actual type ‘[Char]’
02:21:26 <lambdabot>        ‘a1’ is a rigid type variable bound by
02:21:38 <Sornaensis> a String isn't some type a it's a string
02:22:22 <barrucadu> Types (eg, String, Int) and typeclasses (eg, Read) are different things.
02:22:31 <shloub> madknight, wouldn't you like "0123" mapped to 123? not sure it would be a subset
02:22:33 <barrucadu> Types are disjoint.  There are no subtypes in Haskell.
02:22:39 <madknight> Sornaensis, well ghc tells us what String is right? type [Char]
02:23:09 <barrucadu> :t read
02:23:11 <lambdabot> Read a => String -> a
02:23:23 <barrucadu> Read is a typeclass, String is a type, 'a' is a type variable
02:23:52 <madknight> shloub, depends on how i define my Int subset, if 0123 is included then yes
02:24:56 <shloub> madknight, for Int 123 and 0123 are the same, for String they are not
02:25:33 <kuribas> madknight: types with capital letters (not type variables), can never be the same, unless they are identical.
02:25:59 <kuribas> well, disregarding type synonyms
02:26:19 <fakenullie> In some languages 0123 I is treated as octal number
02:26:24 <kuribas> what's the name for that?  Primitive type?
02:26:37 <kuribas> like Int, or Char?
02:26:52 <madknight> shloub, okay so the mapping is injective then and not bijective
02:26:56 <fakenullie> Concrete type I think
02:27:20 <Sornaensis> > 123 :: Fractional a => a
02:27:23 <lambdabot>  123.0
02:27:26 <Sornaensis> concrete not asphalt
02:35:24 <madknight> i think i will continue reading Bartosz Milewski "Category Theory for Programmers" that might help for my understanding, since i'm somehow able to write programs in haskell, but i don't understand it
02:44:20 <Jenaf> hi there
02:44:28 <Jenaf> i forgot how to import my own .hs files
02:45:41 <ongy> import basename(file)
02:45:51 <Jenaf> okay I'll try it
02:46:10 <Jenaf> also i jsut found another old file wich imports the same function I can just copy and paste the import statement from tehre
02:51:00 <kuribas> madknight: better read that _after_ you have a good grasp on haskell.
02:52:15 <kuribas> madknight: if you want a better grasp on haskell, use one of the online courses
02:53:07 <kuribas> madknight: http://www.seas.upenn.edu/~cis194/spring13/lectures.html
02:53:26 <madknight> kuribas, hmm but i think i'm already able to program all the things that i want to program with haskell (and purescript also), i see no other way forward other than theoretical concepts
02:53:50 <kuribas> madknight: you're still confused about basic things like typeclasses
02:54:32 <kuribas> madknight: reading about CT will just increase that confusion
02:54:37 <madknight> kuribas, yes about why haskell made it so, but i'm not confused in simply using it
02:55:50 <madknight> kuribas, i walked through real world haskell + web comments, was a very good read
02:58:13 <kuribas> madknight: try to do the example code, maybe make a small test project.
02:58:58 <madknight> kuribas, i already write code in haskell (example https://github.com/madnight/grendy-api/blob/master/src/Data/Grendy/GraphQL.hs)
03:05:48 <maerwald> :>
03:08:53 <maerwald> madknight: you lack a readme, how do I use it?
03:09:27 <madknight> maerwald, its work in progress, just deployed it a few mins ago https://grendy.herokuapp.com
03:28:00 <kuribas> What do you think of my idea for an optional function arguments library?  http://paste.lisp.org/display/357284
03:28:37 <dibblego> kuribas: FYI, https://hackage.haskell.org/package/optional
03:29:55 <kuribas> ugh, been writing to much python: http://paste.lisp.org/display/357285
03:30:16 <kuribas> dibblego: that's an ugly solution
03:30:36 <kuribas> dibblego: I don't use typeclasses (except a monoid instance)
03:31:46 <dibblego> is "not using typeclasses except a little bit" less ugly?
03:34:12 <kuribas> dibblego: yes
03:34:22 <dibblego> ah ok, TIL no typeclasses
03:35:25 <kuribas> dibblego: because with my solution you don't need to create a typeclass for your type.
03:36:36 <kuribas> dibblego: and the number of optional values is not restricted to two :)
03:37:43 <dibblego> create a type class per "number of arguments" (even though all functions accept one argument); two is a moral limit  
03:37:54 <dibblego> no other type classes need to be created
03:38:13 <kuribas> that still looks like an arbitrary limit to me
03:38:34 <kuribas> dibblego: with my solution you combine them with <>
03:38:45 <dibblego> all functions take one argument, all of them
03:40:04 <maerwald> I disagree on that
03:40:06 <kuribas> like myFun 3 (opt1 3 <> opt2 "a string")
03:40:12 <kuribas> no need for type annotations
03:40:20 <kuribas> or typeclass hackery
03:40:32 <kuribas> dibblego: the monoid instance isn't even necessary
03:40:34 <dibblego> I have never met the function, that accepts more than one argument. I have written lots of functions.
03:40:48 <maerwald> f(x,y) = ...
03:40:48 <sigrlami> does anyone know of Haskell interpreter for Solidity (Ethereum) smart contract language? or something similar, edsl maybe?
03:40:57 <kuribas> dibblego: I have a function that takes like 20 arguments :)
03:41:10 <dibblego> I have seen these claims. I have never seen them substantiated.
03:41:10 <maerwald> only passing one argument will make it another function
03:41:11 <kuribas> maerwald: that's a single argument
03:41:22 <maerwald> kuribas: no
03:41:27 <dibblego> sigrlami: yes, there is a package on hackage
03:41:44 <kuribas> dibblego: which claim?
03:42:13 <dibblego> kuribas: that there exists a function, which does not take one argument (the one maerwald posted, clearly, is not such a function)
03:42:35 <maerwald> so there are no mathematical functions that take more than one argument? 
03:42:51 <dibblego> in haskell, no
03:42:53 <sigrlami> dibblego: can you provide a link? search not showing relevant https://hackage.haskell.org/packages/search?terms=solidity
03:43:12 <kuribas> dibblego: haskell or mathematics?
03:43:21 <dibblego> Haskell
03:43:24 <maerwald> dibblego: that's already a difference and then this is about details. I can still view haskell functions as mathematical functions, despite them being rewritten curry-style internally
03:43:40 <dibblego> I don't care about "views", only that which actually is
03:43:46 <dibblego> http://blog.tmorris.net/posts/haskell-functions-take-one-argument/index.html
03:44:11 <maerwald> uh, syntax is irrelevant for you?
03:44:16 <dibblego> sigrlami: struggling, but I have definitely seen it
03:44:23 <dibblego> maerwald: No.
03:44:33 <dibblego> The space character, in haskell, is left associative, for example.
03:44:37 <kuribas> maerwald: multiple argument functions in haskell are also one argument functions.
03:44:39 <dibblego> Very relevant to the fact that all functions take one argument.
03:44:47 <maerwald> kuribas: I am perfecly aware
03:44:47 <sigrlami> dibblego: https://github.com/airalab/hs-web3-solidity thus one?
03:45:03 <maerwald> I can still view them as functions with multiple arguments as well
03:45:04 <dibblego> sigrlami: I saw it on hackage, an abstract syntax tree for solidity
03:45:08 <maerwald> there is no collision of ideas
03:45:14 <dibblego> I can view a koala as a kangaroo, but it's still a koala
03:45:22 <maerwald> whatever
03:45:27 <dibblego> *shrug* just true thing
03:45:36 <maerwald> you're just being argumentative :>
03:45:43 <dibblego> No. It is important in teaching.
03:45:53 <maerwald> both things
03:45:55 <dibblego> It causes mistakes to believe otherwise.
03:46:04 <maerwald> I didn't say otherwise
03:46:05 <dibblego> I am being preventative, of mistakes, like the one you are making
03:46:12 <maerwald> no, you didn't listen
03:46:16 <dibblego> mhm
03:46:32 <dibblego> all functions take one argument
03:46:43 <dibblego> this is a matter of fact, an important matter of fact
03:46:55 <dibblego> I can view it as not true, but it keeps being true
03:47:20 <maerwald> no one said it's untrue
03:47:41 <dibblego> mhm
03:48:14 <dibblego> here is a function
03:48:18 <dibblego> @kind (->)
03:48:19 <lambdabot> TYPE q -> TYPE r -> *
03:48:23 <dibblego> it takes one argument
03:48:31 <dibblego> as an example
03:48:41 <dibblego> there will be no counter-examples
03:48:41 <maerwald> nothing of this needs explanation
03:48:50 <sigrlami> dibblego: https://hackage.haskell.org/package/ethereum-analyzer ??
03:48:53 <maerwald> you're not listening, so we shouldn't argue further
03:50:14 <dibblego> sigrlami: I dont think so, and sorry, I cannot find it
03:50:21 <sigrlami> ok (
03:53:03 <kuribas> So giving multiple options is as simple as: fun = myFun 2 $ intOpt 2 <> strOpt "2"
03:53:16 <kuribas> reading them: myFun x (getMyStructOptions -> options) = (x, _intOpt options, _strOpt options, _mbOpt options)
03:53:20 <kuribas> (with viewpatterns)
03:54:28 <kuribas> no advanced typehackery required
03:54:40 <kuribas> the monoid instance is just a convenience
04:03:18 <bbear> hello
04:03:38 <bbear> how can I build a list from a function and a seed value ?
04:03:45 <bbear> something like
04:04:04 <bbear> buildList :: (a->a) -> a -> [a]
04:04:33 <fakenullie> S
04:04:37 <fakenullie> scan
04:04:41 <bbear> iterate
04:04:43 <bbear> that's it 
04:04:46 <bbear> thanks guys
04:05:38 <fakenullie> You can also search for type signature on hoogle
04:06:29 <bbear> I found it that way
04:06:31 <bbear> btw
04:06:33 <kuribas> @hoogle (a -> a) -> a -> [a]
04:06:34 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
04:06:34 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
04:06:34 <lambdabot> GHC.OldList iterate :: (a -> a) -> a -> [a]
04:07:03 <bbear> do you know something better than length (filter (\x->x=='a') foo) to count the number of occurences in a list ?
04:08:17 <kuribas> bbear: (\x -> x == 'a') == (=='a')
04:08:56 <kuribas> bbear: that's fine, unless you have big performance needs
04:11:24 <bbear> is there more than one copy of the list being done ?
04:12:58 <kuribas> bbear: you create a list of 'a's, but it is being garbage collected immediately.
04:13:43 <kuribas> bbear: there's time overhead, but no space overhead
04:13:51 <Maxdamantus> "immediately" as in while it's being generated and traversed.
04:14:51 * hackagebot stemmer-german 0.1.1.1 – Extract the stem of a German inflected word form. – https://hackage.haskell.org/package/stemmer-german
04:17:30 <bbear> it is weird that my algorithm gives me a good answer but when I go up at scale it does not.
04:18:32 <bbear> it is here: http://vpaste.net/M3uHx , and I am doing advent of code http://adventofcode.com/2016/day/18
04:20:54 <bbear> certainly in the buildRow method there is a bug
04:23:47 <fakenullie> I wonder if length $ elemIndices is more efficient than filter
04:25:20 <bbear> if it is, not by far.
04:25:25 <bbear> barely noticeable.
04:26:25 * hackagebot xml-conduit-writer 0.1.1.2 – Warm and fuzzy creation of XML documents. – https://hackage.haskell.org/package/xml-conduit-writer
04:27:53 <fakenullie> foldr (\e a -> if e == 'a' then a + 1 else a)
04:34:56 <bbear> my bad it sayd 400 000
04:35:02 <bbear> I thought it was 40000
04:35:08 <bbear> my pc gonna freeze
04:35:23 <fakenullie> 400k is not that much
04:35:35 <shloub> http://paste.awesom.eu/fcTT
04:35:43 <bbear> lazy evaluation :)
04:35:43 <shloub> I'm trying to use Data.Set on Fedora 25
04:35:52 <bbear> should systematically use foldr'
04:35:57 <bbear> or something like that
04:35:57 <shloub> where should i get it?
04:37:05 <bbear> think about it when your data structure is replicated 400000 in the memory but you only need two of them.
04:37:10 <bbear> Can you enforce strictness sometimes ?
04:38:01 <fakenullie> shloub: can you use stack?
04:38:41 <fakenullie> shloub: otherwise install ghc-containers (I'm not sure about -devel)
04:39:21 <bbear> even with the strictness I use like 2GB of memory
04:39:34 <bbear> ho no it goes up again 
04:39:41 <bbear> stuck at 4GB
04:40:20 <shloub> fakenullie, ghc-containers-devel did the trick, thanks
05:02:38 <fabbbbbb> hi, i'm really knew to haskell , i don't understand something in an example , someone can help me ?
05:03:19 <vc> hi
05:03:39 <vc> are there good code examples of ForeignPtr use?
05:06:56 <ondrejs> fabbbbbb: post the example
05:08:59 <fabbbbbb> https://thepasteb.in/p/pghQ310EZx3tR
05:12:29 <ondrejs> fabbbbbb: I am quite confused. replicate' 0 [5,7] ~>* [] for me
05:12:30 <srhb> fabbbbbb: your question is unclear. Yes, it will return [] if n <= 0
05:14:35 <fabbbbbb> when i execute this replicate' 2 4 its returning [4,4]
05:14:58 <srhb> fabbbbbb: Yes, so? 2 isn't <= 0
05:15:53 <fabbbbbb> its recursive , the 2 is getting -1 no ?
05:15:54 <srhb> replicate' 2 4 = 4 : replicate' 1 4 = 4 : 4 : replicate' 0 4 = 4 : 4 : [] = [4,4]
05:15:58 <ondrejs> fabbbbbb: replicate' 2 4 ~> 4:replicate' 1 4 ~> 4:4:replicate' 0 4 ~> 4:4:[]
05:16:04 <fabbbbbb> ok
05:16:15 <fabbbbbb> so its getting at the end mylist:[]
05:16:17 <fabbbbbb> and not just []
05:16:40 <fabbbbbb> why i don't have to put x:[] then ?
05:16:51 <srhb> I don't understand your question. Put x:[] where?
05:17:08 <srhb> x:replicate' (n-1) x <-- this is it. 
05:17:11 <fabbbbbb> for n <= 0
05:17:38 <fabbbbbb> the function is automatically getting the return of the last recursion , sorry i'm quite confused
05:17:52 <srhb> There is only one result of the entire thing.
05:18:02 <fabbbbbb> yea yea i understand that
05:18:04 <srhb> You can see for yourself by running it by hand, we can help with the reductions if you need it.
05:19:31 <fabbbbbb> ok ok i understood , but just if n <= 0 = [] i thought it would just return a []
05:19:33 <fabbbbbb> without the x
05:19:58 <fabbbbbb> x = the list
05:20:27 <fabbbbbb> oh i think i understand now
05:20:32 <fabbbbbb> o my god , ok thanks
05:22:35 <srhb> fabbbbbb: Great :)
05:22:51 <fabbbbbb> i did it by hand
05:22:56 <srhb> That always helps :)
05:23:31 <fabbbbbb> what kind of project did you do at first when you were learning haskell ?
05:23:41 <srhb> Uh, I think my very first program was console snake.
05:26:08 <srhb> Well, aside from hello-worldy things.
05:29:41 <ondrejs> srhb: with curses or some other ui lib?
05:30:27 <Skm_> hi! what's the difference between #haskell and #haskell-lang channels? Anyone plz?
05:31:08 <Hafydd> #haskell-lang was probably created as a protest by someone who disliked #haskell.
05:31:46 <Hafydd> But 1500 users is hard to beat.
05:32:45 <srhb> ondrejs: Plain strings and putStr etc :)
05:34:56 <ondrejs> srhb: neat
05:35:18 <Hafydd> Or maybe it's a channel for <https://github.com/haskell-lang/haskell-lang>.
05:36:01 <Hafydd> Both seem to agree that Purple is the colour of Haskell.
05:36:12 <srhb> ondrejs: I later cleaned it up and changed it into a graphical version with gloss. I wasn't anywhere near able to before I wrote the first one though :)
05:37:03 <srhb> Hafydd: Well, *duh* :-)
05:38:30 <Hafydd> I've always thought of it as being more of a blue/cyan language, but probably just because that's the scheme I chose when first writing a text editor highlighter for it.
05:39:47 <srhb> I could accept greenish, but blue is just wrong. :-P
05:40:06 * srhb has strong opinions on this topic
05:40:18 <Hafydd> Actually, my scheme does contain a lot of green, too (but so do most others).
05:40:29 <Hafydd> Most of my other schemes, I mean.
05:40:38 <srhb> You have different schemes depending on the language?
05:41:11 <Hafydd> Yes. As opposed to what? Assigning colours to abstract syntactic categories?
05:41:31 <srhb> I... Touche.
05:43:06 <Hafydd> (This is my scheme (and preferred font, Terminus): https://i.imgur.com/TI3khl8.png)
05:54:20 <madknight> someone who switched from vim to neovim: differences for haskell programming? is it worth it?
05:56:54 <maerwald> well there is a neovim plugin for intero
05:58:54 <mbw> I have written a small interactive image scraper, which makes use of atomic blocks (STM), gi-gtk, and runs concurrently using the async package. I noticed that using withAsync, exceptions seem to be rethrown in the current thread *only* if I explicitly "link" them. Likewise, I have to use "link2" for an exception getting thrown in thread 1 to be rethrown in thread 2, but I think that is to be expected. But 
05:59:00 <mbw> is the first aspect the intended behavior? If I don't use "link", an exception will cause the program to hang, presumably because it is stuck inside Gtk.main. So this might be caused by some specific aspect of Gtk (which is not thread-safe, but I only invoke Gtk-related functions from the main thread), the FFI, or something else. Does anybody have an idea?
06:05:57 <mbw> If I read the docs correctly, async exceptions only get rethrown if I actually "wait" for them. Is this correct?
06:16:24 <itsu> I'm struggling with (what I think is) a basic problem with the Maybe Monad
06:16:42 <itsu> would love some help with it :-) https://glot.io/snippets/eu3vx07095
06:19:37 <maerwald> what an annoying site
06:19:52 <itsu> sorry, I took the first one I found on google
06:21:39 <maerwald> write down the type signature of the function you want
06:21:58 <maerwald> you're writing a lot of text what it should do, just write the type signature
06:22:59 <itsu> filterByAge :: [User] -> (Maybe Int) -> [User]
06:23:03 <itsu> something like this I guess
06:23:29 <maerwald> now start implementing it
06:23:31 <maerwald> :t filter
06:23:32 <lambdabot> (a -> Bool) -> [a] -> [a]
06:23:39 <maerwald> and use that function
06:23:59 <maerwald> you know how to pattern match on Maybe etc, I suppose
06:24:02 <itsu> yup
06:24:09 <itsu> but I don't want to pattern match
06:24:16 <maerwald> why
06:24:38 <itsu> I thought there would be a nice way to do filter on Maybe conditions
06:24:39 <maerwald> :t maybe
06:24:40 <lambdabot> b -> (a -> b) -> Maybe a -> b
06:25:22 <itsu> cause I can have multiple conditions, not only one so if I have to pattern match on all my conditions then it gets ugly I think
06:25:33 <maerwald> :t \b ma -> maybe b filter ma
06:25:34 <lambdabot> ([a] -> [a]) -> Maybe (a -> Bool) -> [a] -> [a]
06:26:00 <maerwald> uhm
06:26:02 <itsu> hmm yeah that could work
06:27:31 <itsu> but I was looking for a nicer way of doing it (rather than implementing a default value for all my conditions)
06:27:54 <itsu> but maybe there aren't :-(
06:28:32 <maerwald> but in filterByAge you only have one condition
06:28:43 <maerwald> why are you trying to do everything in one function?
06:29:15 <itsu> cause I could also have filterByName, filterBySex, filterBy... all using Maybe values
06:29:27 <maerwald> those are other functions
06:29:35 <itsu> yeah
06:30:28 <tremon> why not have your matching functions accept Maybes? (e.g. Maybe String -> User -> Bool)
06:30:32 <maerwald> filterUsers :: [User] -> (User -> Bool) -> [User]
06:31:14 <itsu> tremon: because I'm stupid and didn't think about it...
06:31:37 <maerwald> filterByName = filterUsers (withAge 3)
06:31:37 <itsu> (feeling ashamed...)
06:32:13 <tremon> no need :)
06:32:21 <itsu> maerwald: I have (Just 3) not 3. tremon's solution makes it quite simple
06:34:16 * hackagebot display 0.0.0 – Display things for humans to read – https://hackage.haskell.org/package/display
06:35:11 <maerwald> Maybe String will only work for the name
06:35:59 <maerwald> you probably want Eq
06:36:32 <itsu> yup thanks ;-) 
06:36:43 <itsu> thanks for the help guys
06:36:55 <tremon> you would need Ord for the age range match
06:37:23 <tremon> but yes, it can probable be made more generic
06:37:30 <tremon> *probably
07:15:03 <saurabhnanda> in aeson what's the function that goes from Parser a -> Value -> Maybe a 
07:15:21 <saurabhnanda> note, that is a Values, not a Bytestring.
07:17:15 <saurabhnanda> got it -- parseMaybe
07:35:06 * hackagebot Cassava 0.5.1.0 – A CSV parsing and encoding library – https://hackage.haskell.org/package/Cassava
07:54:20 <solv3d> hi there! i am trying to implement a custom show instance for my data type
07:54:20 <solv3d> http://lpaste.net/358827
07:54:34 <solv3d> the problem is in line 9
07:54:57 <solv3d> how do i access the member aChar of the literal (x) and (y)
07:55:20 <barrucadu> `aChar x` and `aChar y`
07:55:40 <solv3d> thanks
07:58:17 <solv3d> now if i have a custom Show instance for Literal too
07:58:26 <solv3d> how do i access this, "aChar x" will ignore it
07:58:55 <solv3d> http://lpaste.net/358829
07:59:13 <barrucadu> `show x`
08:00:17 <solv3d> show x instead of aChar x ?
08:01:02 <barrucadu> And outside the []s, yes
08:01:09 <vc> i'm using foreign pointers for memory management. it mostly makes sense but it's getting kind of cumbersome to work with
08:01:11 <barrucadu> [show x] would eb a type error, as that'd be a [String]
08:01:30 <solv3d> ok got it
08:01:34 <solv3d> thanks
08:01:52 <vc> wrapping all the operations in withForeignPtr ... etc. are there techniques to lessen the pain
08:03:21 <proofskiddie> http://lpaste.net/358828
08:03:28 <proofskiddie> Any ideas why main dosen't print 2^200 as expected?
08:03:29 <vc> i'd like to present an API that "feels" like working with native haskell data
08:05:45 <barrucadu> proofskiddie: 2^200 doesn't fit in an Int
08:06:01 <proofskiddie> oh
08:06:06 <barrucadu> > (2^200 :: Int, 2^200 :: Integer)
08:06:08 <lambdabot>  (0,1606938044258990275541962092341162602522202993782792835301376)
08:06:12 <proofskiddie> need to use Integer eh?
08:06:25 <proofskiddie> thanks!
08:22:44 * hackagebot aws 0.17 – Amazon Web Services (AWS) for Haskell – https://hackage.haskell.org/package/aws
08:56:11 * hackagebot aws 0.17.1 – Amazon Web Services (AWS) for Haskell – https://hackage.haskell.org/package/aws
09:35:40 <jmcarthur> Is there a more popular package that offers a type class like this one? https://hackage.haskell.org/package/compdata-0.11/docs/Data-Comp-Multi-HTraversable.html
09:43:26 <anelson> hi guys, is there a way to enable orphan instances for classes defined within the same package, but warn otherwise? It's making sense from a code org point of view for me to separate the class itself and its instances
09:43:50 <anelson> but I understand why orphan instances in general are not good
09:46:20 <anelson> alternatively, some kind of pragma...?
09:52:47 <fakenullie> anelson: {-# OPTIONS_GHC -fno-warn-orphans #-} ?
09:54:20 <anelson> fakenullie: but that will suppress all orphan warnings, no?
09:54:40 <anelson> oh I guess it's within that one module... well that's somewhat better
09:57:03 <bsima> how do I extend `SomeException`? I just have `instance Exception MyException` and I get `Couldn't match type 'SomeException' with 'MyException'`
09:57:41 <barrucadu> :t toException
09:57:43 <lambdabot> Exception e => e -> SomeException
09:57:45 <HallaSurvivor> vc: with complete sincerity, shove it in a monad
09:57:49 <c_wraith> bsima: it sounds like you're trying to use SomeException as MyException someplace.
09:58:23 <HallaSurvivor> vc: that's the point of >>=, it handles the memory lookup, management, and pointer shuffling for you
09:58:28 <c_wraith> bsima: There is no subtyping (in that sense) in Haskell.  You will need to use a conversion function like toException or fromException
09:58:33 <HallaSurvivor> vc: so that the api you expose is clean
09:58:47 <bsima> I'm trying to combine MyException with a library that throws SomeException
09:58:56 <bsima> okay so toException is what I want, will check it out
09:59:05 <c_wraith> bsima: no library should be throwing SomeException.  That's broken...
09:59:37 <c_wraith> bsima: you should always be throwing your specific type.  (You might be *catching* SomeException, but that's different)
10:00:03 <bsima> it's this: https://www.stackage.org/haddock/lts-9.6/xml-conduit-1.5.1/Text-XML.html#v:parseLBS
10:00:11 <bsima> maybe i misspoke
10:00:23 <c_wraith> Yeah, that's catching SomeException
10:00:36 <c_wraith> you want fromException to convert it back to MyException
10:01:33 <c_wraith> fromException will give you a Nothing back if it wasn't originally a MyException
10:03:09 <Athas> Has anyone looked into improving GHC's parse error messages?  Or is it not likely to be very useful?
10:03:49 <hpc> it only has a few specific issues in my experience
10:04:09 <hpc> mostly stuff like mentioning {-# LANGUAGE #-} comments that aren't at the top of the file
10:05:12 <Athas> Most parse errors in GHC just say 'parse error' and point at a source location, don't they?
10:07:40 <c_wraith> sometimes they say "Parse error" *after* the important location because everything before could have been right if some necessary thing was at the targeted location.
10:08:02 <c_wraith> Someone asked a question a few weeks ago about a parse error that was caused by a missing open paren 10 lines before it was reported
10:08:27 <hpc> a good way to put it is that parse errors point out the location where the compiler was surprised
10:08:45 <c_wraith> yeah.  sometimes the compiler tries surprisingly hard to make sense of your code
10:08:56 <c_wraith> and the point at which it gives up is far later than you'd expect
10:09:44 <Athas> Oh, it's actually much better now than it used to be.
10:10:28 <Athas> I'll have to check out what they do.  GHC uses Happy for the parser, and my own Happy-based compiler generates horrible parse errors.
10:11:23 <hpc> i... can't remember the last time i had a parse error
10:11:27 <hpc> now that i think about it
10:11:39 <hpc> type errors all the time, never parse errors
10:12:05 <Athas> You never make typos?
10:12:22 <hpc> very very rarely
10:12:36 <hpc> those usually end up being "not in scope: blahblah", which isn't quite a parse error
10:40:10 <glguy> You can use error productions in happy to make nicer error messages. One example is to point out an open parenthesis that was never closed
10:41:00 <glguy> https://github.com/glguy/language-lua/blob/master/src/Language/Lua/Annotated/Parser.y#L162-L170
11:06:56 * hackagebot lxd-client 0.1.0.0 – LXD client written in Haskell. – https://hackage.haskell.org/package/lxd-client
11:34:56 <hexagoxel> > case 13 of x | ((+1) -> y) <- x + 1 -> y
11:34:59 <lambdabot>  15
11:35:16 <hexagoxel> "terse syntax", they say :D
11:41:02 <geekosaur> they out 'dense'
11:41:04 <geekosaur> *left out
11:49:38 <rudol> glguy gave me a bit of direction, and a totally rewritten example solution, re the code I was extending from https://github.com/dag/all-about-monads/blob/master/examples/example24.hs (from the AllAboutMonads article. I was looking at my main issue/mental-blocker again today, somewhat inspired by glguy's respone quick help yesterday. 
11:49:51 <rudol> The idea though, is not to write a new solution, but to work within the limitation of the original tutorial code, for example, both "Var"s and "Value"s in the ProblemState can only be Strings (making that more typesafe is probably a future challenge, if I get past this one!).
11:50:02 <rudol> I wanted to keep the original types eg ProblemState and NDS (ie None Deterministic State, modelled with StateT of ProblemState and List) and primitive combinators (eg setVar :: Var -> Value -> NDS ()), and just add enough new functions to solve SEND+MORE=MONEY to get some practice and understanding of lifting functions to work in monads and monad transformers.
11:50:14 <rudol> So I ended up with nearly everything I need, staying as faithful to the traditions of the origianl code,but I am just not yet able to get the last few lines of code right in http://lpaste.net/358831. Could anybody give me a few tips on how to think about solving this (mainly re working/being in the right monad, I think) and also any tipson simplifying the few lines of code below the -- SEND+MORE=MONEY comment.
11:52:09 <rudol> pls excuse the Redundant brackets lint warnings - the original code was obviously written for readability and for pedagogical reasons. 
11:54:30 <rudol> So, I am not looking for advice on backtracking or the logic engine (at this point) it's more about writing haskell code and lifting pure functions into Monads and Transformers, or that's how it seems to me.
11:55:01 <rudol> s/haskell code/idiomatic and sensible haskell code/
12:06:02 <rudol> the way my functions, in particular digitFrom, readInt, readInts, num, num', digitsToInt seem to jump in and out of the NDS monad is something I feel like I did just to follow the types of the primitive combinators, rather than because I had a cohesive design in mind for them. Does my question even make sense?   I would like to learn to think more clearly about how to approach such problems, and reach solutions less, apparently, acci
12:16:50 * hackagebot ngx-export 0.8.0.6 – Helper module for Nginx haskell module – https://hackage.haskell.org/package/ngx-export
12:23:56 * hackagebot lxd-client 0.1.0.1 – LXD client written in Haskell. – https://hackage.haskell.org/package/lxd-client
12:31:16 <rudol> At some point, wasn't there a group of haskell experts that you could get adhoc, bite-sized bits of paid help from, on demand? That is what I would really like, just to go over my way of thinking (and hopefully straighten that out in the process!) and see how they approach it  - since I am working in an isolated environment (in terms of having no haskell experts around to ask when I get stuck) I think that would be a great help. Does
12:31:37 <hpc> you've sort of found that group
12:31:54 <rudol> :)
12:31:57 <monochrom> I've never heard of that.
12:32:06 <hpc> oh, paid help
12:32:18 <rudol> I think Henrik Apfelmus was part of it, but I can find no trace now.
12:32:53 <monochrom> Even edwardk who once posted an offer, but it was himself not group, and he has long withdrawn it.
12:33:40 <monochrom> Oh I used to have no local Haskell expert around too.
12:33:51 <monochrom> I solved that by becoming a Haskell expert.
12:33:57 <maerwald> lol
12:34:19 <rudol> that wouldbe a nice goal for me too, but I keep getting stuck, as described above!
12:34:28 <rudol> haskell is beautiful
12:34:48 <rudol> and I get more pleasure fromworking things out for myself
12:34:59 <monochrom> OK so at this point an obvious difference between you and me is I don't overthink or overengineer.
12:35:04 <kisame1> hia
12:35:12 <kisame1> ok so i got a quick question 
12:35:50 <rudol> OK, so is that whatthat code is suffering from? I thought the logic engine code I found (from 2003!) was very elegant.
12:36:03 <rudol> And I extended it to solve another logic puzzle.
12:36:09 <maerwald> elegance is meaningless
12:36:12 <kisame1> ive been interested in coding in haskell for a lil while now, except im not sure if its right to learn? im a not-so-smart 14 year old, ive only coded in python and C before, and shell scripting 
12:36:21 <rudol> it's not, it give a good feeling
12:36:24 <kisame1> if it matters i run gentoo linux so i have experience with computer stuff. 
12:36:41 <maerwald> rudol: except for your feeling, it is meaningless
12:36:53 <maerwald> it won't help anyone else looking at that code
12:36:56 <monochrom> So for example I couldn't care less about this "NDS" business.
12:37:23 <rudol> maybe,  but then I can use Scala (which is also nice) or Java, which I have used sine 1994, and tenfd not  to get stuck for days with, on simple probles ;)
12:37:23 <hpc> kisame1: if nothing else, learning haskell will make you better at structuring your own thoughts when coding in other languages
12:37:46 <monochrom> I do find [] useful. And if I want a little bit more generality or some more feature or better performance, I might consider the logict package on Hackage.
12:37:52 <maerwald> hpc: hasn't helped me with programming C, rust, go, python or anything else
12:37:56 <monochrom> But I'm not going to slap StateT on it.
12:38:03 <rudol> but the whole exercise is to make the NDS (based on Strings) work also with digits and numbers
12:38:25 <kisame1> i thought so. im ok at python, horrid at C, most ive ever done are things like quizzes and scripts to help around the computer
12:38:26 <maerwald> so unless you program similar haskell-like languages, I'd say it doesn't improve your general programming skills
12:38:27 <rudol> I do not want to change the engine (at this point - later I will make it more typeful)
12:38:45 <kisame1> i wonder, is haskell capable of that? say like, something along the lines of os.input 
12:38:49 <rudol> when I say exercise, I mean what I want to achieve
12:39:15 <kisame1> so like scripting to do stuff on the computer, to use bash or something (im so sorry for my inability to express my thoughts this is what i meant by not-so-smart)
12:39:32 <maerwald> kisame1: python is magnitudes more suitable for basic scripting
12:39:41 <maerwald> haskell has a different set of strengths
12:39:43 <rudol> I only want to understand why the last ~30 lines of code in that file look a bit clumbsy, and why I can't get the constartints right without calling runState every 5 seconds 
12:39:58 <rudol> (this is what I would say to someone I was payng ;)
12:40:20 <kisame1> mhm. what would haskell help me with? and i wouldnt use haskell for that, just wondering if capable. i wanna try and make an AI (lol) or like a chatbot for fun once im good, i could do that in py
12:40:38 <monochrom> Just delete that "State" part and do as glguy's first, elementary, low-tech solution.
12:40:43 <maerwald> when your python program grows beyond 5k LOC (or whatever), you wish you had written it in haskell... but the first few steps are so much easier/quicker. Python doesn't scale in the same way haskell does
12:40:45 <rudol> if I were to write a logic engine, my Var and Value would be higher order types
12:40:47 <monochrom> I mean look at the length, or lack of length.
12:41:25 <hpc> kisame1: most of what you will get out of haskell as a new programmer is compiler checks
12:41:31 <rudol> so the soluton for SSM would be no different to the one for his anthropolgist
12:41:57 <rudol> do you mean lines of code?
12:42:00 <kisame1> err.. what does that mean
12:42:21 <hpc> type checking eliminates large classes of mistakes, and if you learn to think in terms of types when structuring your code it improves the overall design as well
12:42:27 <maerwald> you have compiler checks in all strictly typed languages, including java
12:42:32 <monochrom> And even for general forward constraint propagation, you just need [], screw State. See my http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.html , click on the "Source" link, see how many lines of code (vs how many lines of doc, for good measure).
12:42:40 <monochrom> SCREW STATE
12:42:48 <monochrom> Instant simplification.
12:43:46 <rudol> monochrom, I will of course study that, in detail, thank you. But _all_ I am really after just now is how to get those last few lines of haskell code to work in the exisiting framework of code I downloaded for th elogic engine
12:43:50 <maerwald> what makes haskell special in the field of strictly typed languages is the explicitness of effects on type level. In java you can just see them via "throws <this-or-that>" if you are lucky
12:44:47 <rudol> the very helpful, and friendlypeople I come across here, always give me advise to rewite from scratch, but I am actually, today, just trying to lift my functions into the NDS/ProgramState monads
12:44:53 <Psybur> I
12:45:15 <Psybur> One of the biggest things that blows my mind with haskell is "flip"
12:45:20 <rudol> remember the guy wrote that in 2003 as a tutorial, and I think it is very good
12:45:40 <monochrom> Well what I said was not to fulfill your current quest which IMO is misguided. What I said was my secret of success. You are free to choose whether to become as successful as me or not.
12:45:43 <maerwald> Psybur: why?
12:46:00 <maerwald> lol
12:46:07 <rudol> I am just adding stuff to it (like using it to solve new puzzles, adding new combinators and functions to learn how to do that in a monadic setting)
12:46:08 <Psybur> maerwald, manipulating functions is not something I have ever experienced in other languages
12:46:24 <Psybur> Other than wrapping of course
12:46:33 <maerwald> "as successful as me" xD
12:46:43 <monochrom> So basically you're going after beautiful bureaucracy and I'm going after beautiful Occam razor.
12:46:49 <maerwald> Psybur: how is that manipulating functions?
12:47:05 <rudol> this is exactly the sort of help I would be more than happy to pay for.
12:47:11 <Psybur> maerwald, I guess not, it is a wrapper just like I would make in java
12:47:36 <maerwald> also a fairly useless one btw.
12:47:37 <Psybur> Well not just like, but conceptually
12:47:46 <rudol> It is more about, given this exisiting code which you can not change, add some new code to enable solving more numerical problems
12:48:19 <rudol> I want to see how someone working under those constraints analyses this problem and what solutions fall out of that.
12:48:49 <Psybur> But I cant think of a generic way in java to switch two arguments around, and I guess there is no reason to since theres no partial application
12:49:38 <Psybur> Sorry, switch two parameters around ;p
12:49:49 <rudol> Psybur - I was more taken aback by things like fmap (`infixfn` a) bs
12:50:14 <rudol> I really like flip :)
12:50:31 <maerwald> Psybur: afaik Java 8 has partial function application, no?
12:51:21 <geekosaur> most people dislike flip, fwiw
12:51:43 <maerwald> it's often used for pointless style
12:51:56 <rudol> when I as working out the type of (Nim .) . (. nimber) flip came in very handy
12:52:07 <Psybur> maerwald, from what Im seeing its only for functions designed in a certain way, not for everything
12:52:20 <maerwald> Psybur: sure, but it has the feature
12:53:25 <maerwald> haskell doesn't ask, it just curries everything behind your back :P
13:02:19 <rudol> monochrom, would it be considered bad etiquete to approach, via query (private message), anybody who I find to articulately share helpful information here and ask them if they would like to give a quick few tips over something like Skype? 
13:02:50 <monochrom> You can start with "may I PM you?"
13:02:54 <maerwald> if you want to be as successful as him, you probably should
13:02:59 <rudol> ;)
13:03:18 <rudol> I can aim for the stars and see what happens
13:04:03 <rudol> I think many people here oculd help me a lot, but there is also a bit of a  kudos thing going on too in front of an audience
13:04:27 <rudol> maybe I should just go back to Uni
13:04:39 <maerwald> then you are stuck with teachers again
13:05:10 <rudol> I just want to ask specific questions, and sometimes, I even need a bit of a nudge to get the question right
13:05:39 <monochrom> Eh, what's wrong with teachers?
13:05:39 <rudol> but people here, are looking sometimes more at the big picture rather than controversial little details
13:06:21 <rudol> monochrom, if you are a teacher too, on top of everything else, I am about to ping you privately - I take that as an invitation!
13:06:41 <monochrom> No please don't PM me.
13:07:04 <rudol> don't worry, I will pick on somebody else
13:07:50 <rudol> I want a teacher that can learn from me too :)
13:08:57 <maerwald> that's not what a teacher does, he lectures in front of people. What you want is a "friend" in the broader sense, a coach/companion. Pick up on an open source project and that's what you will find
13:09:49 <geekosaur> depends on your definition of teacher
13:10:14 <geekosaur> not all of them are the US's stupid notions of how to teach
13:10:15 <maerwald> it was a definition
13:11:10 <rudol> I want to start by just getting a few things straight in my head, and it helps me to talk through things sometimes. I have actually read quite a lot of stuff, but I have not practiced enough, partly because a little problem like the one I asked about above, can make me loose days at a time, and that takes its toll 
13:13:37 <rudol> I can guage if my thinking process is useful or not better as I guide a "mentor" to focus on what I am curious about, sometimes even if my way of thinking or target was misguided
13:14:51 <maerwald> abstract coaching is not very useful in programming. There are only two useful things: ask specific questions that can be answered... ask unspecific question in a specific project context, that someone can shed light on.
13:14:54 <rudol> and when s/he solves the problem much more serenely with another mental approach, that leaves a lasting impression that helps more than many other methods
13:15:29 <rudol> my question was - how can I make thos elast few lines of code work, and can they be improved to be more idiomatic
13:15:37 <rudol> is that too abstract?
13:15:39 <tdammers> rudol: one word of warning; people helping others on IRC are generally more inclined to answer questions in public, even if they're specific
13:15:59 <rudol> tdammers - that is a good point
13:16:03 <maerwald> what lines? I don't see a paste
13:16:29 <rudol> shall I copy paste my original post again?
13:17:00 <maerwald> it's probably more than 15 minutes ago, my scroll wheel will break
13:17:04 <rudol> http://lpaste.net/358831
13:17:56 <rudol> there's a couple of hundred lines there, mostly comments from the original author - I am interested only in fixing/improving th elast few lines (under the SEND+MORE=MONEY comment)
13:18:48 <maerwald> that looks like haskell code
13:18:53 <rudol> it (the original) is a very nice bit of code, I am just using it to learn how to think more appropriately
13:19:20 <rudol> OK, that's a good start - I wondered why ghci could nterpret/run it! 
13:19:31 <Tuplanolla> This reads like a book, which is not a bad thing, but means that the question you should be asking is whether anyone wants to read the book, rudol.
13:20:05 <maerwald> rudol: you mean there is a compile error?
13:20:22 <rudol> I know Tuplanolla - just read the last 40 lines
13:20:43 <rudol> OK, at last I have people asking about the actual code now :)
13:20:49 <maerwald> it's hard to know what the purpose is really, but it looks like normal haskell code
13:20:56 <maerwald> nothing really weird
13:21:24 <rudol> It compiles, and solves my other puzzles (ghci>   main >> swe)
13:21:25 * hexagoxel loves the "END OF FILE" comment in the middle of the file
13:21:38 <rudol> but I can't get the smm function right
13:21:55 <maerwald> so you have a _logical_ problem?
13:21:59 <rudol> I expect it is because I am bouncing around in different monads in an unctrolled fashion!
13:22:04 <rudol> NO!
13:22:16 <iqubic> What do people think of the nixos haskell ecosystem. Can/should I install programs from hackage via stack on nixos.
13:22:29 <maerwald> first you ask about style, then you indicate a compile error, now you indicate the function "is not right" 
13:22:33 <maerwald> it's a bit confusing
13:22:36 <rudol> the logic works, and I understand all that was in the tutorial, and I used it to sove othe puzzles too, all as explained since yesterday
13:23:10 <rudol> but the last 40 lines of code attempt to solve a slightly different problem (Vars and Values are really a good fit for its String type)
13:23:12 <iqubic> Mainly wondering how to install glirc from hackage on nixos.
13:23:50 <rudol> so I am asking, how do I get the constraints bit to compile in smm
13:24:09 <maerwald> ok, so it doesn't compile?
13:24:41 <rudol> the reason I believe (maybe incorrectly) that I am having any trouble at all, is probably because I am out-of-control jumping between the monads (NSD and ProgramSTate)
13:25:10 <rudol> if you look, you'll see the checksum logic is ocmmented out, so it does compile
13:25:14 <Tuplanolla> I, too, thought you were asking a style question, because you used words like "sensible" and "idiomatic", rudol.
13:25:44 <maerwald> you need to state your problem in a way so people know what it is about, not dump a lot of details before we know what it is about
13:25:55 <rudol> well, that is because I think if I wrote more idiomatic code above (from the -- comment in question) I would have had less trouble with the smm function
13:26:14 <maerwald> like "there is a compile error in line 259-262"
13:26:27 <maerwald> except requiring me to ask for the 3rd time :>
13:26:34 <maerwald> s/except/instead/
13:26:40 <rudol> maerwald, yes, but because I asked yesterday, I was reluctant to bore people wit it again today, so in rephrasing, I blurred things maybe
13:26:57 <rudol> maerwald, OK
13:27:01 <maerwald> I don't know what yesterday was, except I was probably drunk, but can you blame me?
13:27:20 <rudol> no, why would I blame you
13:27:42 <jared-w> 29 is always an odd number, anyway. Who wants to be sober on a prime number?
13:27:49 <maerwald> now... remove the comment from the paste in line 259-262 and add the compile error as a comment
13:28:00 <maerwald> so people actually know what the problem is
13:28:04 <maerwald> instead of guessing
13:28:29 <rudol> I know what the problem is, it is because the num function returns the values required in a Monad
13:29:03 <rudol> that is why I feel bad lifting is part of my problem
13:29:20 <maerwald> I refuse to get into the problem
13:30:59 <rudol> me too, but 2 days is not cheap!
13:31:01 <rudol> • Couldn't match expected type ‘NDS (Maybe Int) -> Maybe Integer’               with actual type ‘StateT s0 m0 s0’ • The first argument of ($) takes one argument,   but its type ‘StateT s0 m0 s0’ has none   In the first argument of ‘checksum’, namely     ‘(get $ num (map show "SEND"))’   In the second argument of ‘($)’, namely     ‘checksum        (get $ num (map show "SEND"))        (get $ num (map show
13:31:46 <rudol> maerwald, I thought you said refuse to give in, ignore the me too bit
13:32:30 <rudol> maerwald, may I ask how I would entie you into "get into" this problem?
13:32:38 <rudol> *entice
13:33:05 <rudol> is it because the code is too long?
13:33:08 <rudol> or too smelly?
13:33:15 <rudol> or ...?
13:33:47 <rudol> or, as I asked yesterday and today, is it just a bad question?
13:34:35 <Psybur> rudol, you need to SEND MORE MONEY
13:34:51 <rudol> that is what I have been trying to do for 2 days :)
13:35:20 <rudol> ping me if  you have PayPal :) 
13:35:54 <Psybur> https://stackoverflow.com/questions/13843687/how-can-i-build-a-nondeterministic-state-monad-in-haskell
13:36:19 <maerwald> rudol: as I said: 1. start with explaining the class of the problem, 2. show where the problem exists (with a proper compile error, that shows me what line the problem is), 3. get into details on demand
13:36:31 <maerwald> e.g. checksum is not a valid function, line 259 is already broken
13:36:43 <maerwald> it's unclear whether that was a typo or not
13:36:53 <maerwald> and thus it's unclear what the expected types even should be
13:37:51 <rudol> 1. I am extending xample24.hs with some new puzzles, dta constructors and combinators as required.
13:38:13 <rudol> 2. The problem exists from lien 224
13:38:15 <maerwald> no: 1. I get a compile error
13:38:30 <maerwald> no: 2. the problem exists in line 259-262#+
13:38:30 <rudol> 3. please let me know if I can provide any further useful info
13:39:37 <rudol> maerwald, thank you, that is indeed better for getting the type of answer that would help me
13:40:18 <rudol> and then I can move onto the more idiom-related question once people already feel good about helping me :)
13:42:24 <rudol> I think one has to relieve oneself of the reluctance/fear of asking stupid questions, to freely constract a good question
13:42:38 <rudol> *construct
13:44:13 <maerwald> do you know the type of 'get'?
13:44:35 <rudol> yes, but I can't see how to use it outsid a do :(
13:45:30 <rudol>  get :: Monad m => StateT s m s (I have used it above, in that code, iirc)
13:45:57 <Psybur> map show "SEND"? Why not map (flip (:) []) "SEND" :D?
13:46:27 <rudol> from line 259, it was just desperation, as I didn't want to call runStateT all over the place (as described yesterday and today) 
13:47:18 <rudol> Psybr, agreed, that is nicer, and semantically more reasonable
13:47:56 <rudol> in fact, most of the problem is borne of th efact that his Var and Value types are both String
13:48:21 <rudol> otherwise, we could skip most of this if we had higeher order tyoes for Vay and Value
13:48:30 <Psybur> Theres also Data.List group.
13:48:35 <Psybur> > L.group "SEND"
13:48:35 <hexagoxel> rudol: are you sure that sendmoremoney is a problem that _can_ be expressed in your ProblemState?
13:48:38 <lambdabot>  error:
13:48:38 <lambdabot>      Not in scope: ‘L.group’
13:48:38 <lambdabot>      Perhaps you meant one of these:
13:48:44 <rudol> but, as desvcribed, I will attack that one I have learnt to deal with thi sproblem
13:48:45 <Psybur> > group "SEND"
13:48:47 <lambdabot>  ["S","E","N","D"]
13:49:24 <rudol> hexagoxel that is a good question, and one I thought I would answer when I get that code to compile ;)
13:49:36 <hexagoxel> because it seems to me like you need something e.g. curry calls "finite domain constraint solving"
13:49:37 <rudol> Psybur - nice!
13:50:38 <hexagoxel> prolog uses the same terminology.
13:50:52 <Psybur> Are you guys getting compile errors with the code or something? It compiles fine for me
13:50:59 <Psybur> Wondering if Im missing something
13:51:03 <rudol> hexagonal - I believe it will solve it. The constraints are - Var in ["S","E","N","D","M","O","R","Y"] have distinct vales (from 0 to 9) and that the checksum works
13:51:08 <hexagoxel> rudol: how would it ever compile if the problem is not expressible?
13:51:19 <rudol> pls see above
13:51:39 <hexagoxel> but "the checksum works" is not expressible.
13:51:43 <rudol> the only issue is that the representation of digits and Vars has to be translated from Strings
13:52:00 <iqubic> Why is that?
13:52:42 <iqubic> Can't you leave the digits as int?
13:52:51 <rudol> it is if you traslate each single String (eg "S", "E" etc) as Var that has a Vale whicj you read into a digit to make an int
13:52:52 <hexagoxel> no no, the characters are just names for variables. am i completely of here?
13:53:25 <rudol> No, the Var names are String 
13:53:33 <rudol> and so are thier Values
13:53:40 <iqubic> thats fine.
13:53:53 <rudol> that is what I am trying not to change at the moment, that is how example24.hs was written
13:53:55 <hexagoxel> (ah right: Strings, not characters)
13:54:08 <rudol> hexagonal, exactly
13:54:29 <rudol> I am glad that it runs - try main >> swe
13:54:42 <rudol> main is the original problem he solves, and swe is one I added
13:54:58 <hexagoxel> and neither main nor swe require finite domain constraint solving.
13:55:06 <hexagoxel> but sendmoremoney does.
13:55:17 <iqubic> What exactly is your issue rudol?
13:55:50 <rudol> I would like to make the 3 lines with calls to  checksum compile
13:55:55 <rudol> (to start with!)
13:56:13 <iqubic> Hexagoxel, how is sendmoremoney different?
13:56:23 <maerwald> the types are completely wrong, to the point that I don't even know what he is trying to do on line 259-262. Even if you use evalStateT you end up with something completely different
13:56:29 <hexagoxel> rudol: make free use of undefined and/or unsafeCoerce. voila, it compiles. the problem is still not expressed, because it cannot.
13:56:29 <rudol> maybe hexagonal has seen beyond that though, but I still want to learn how to make that code compile 
13:57:01 <maerwald> get takes no parameter
13:57:17 <maerwald> see your checkSum functions as to what you need, then check the type of num
13:57:22 <maerwald> then check what you end up with
13:57:23 <rudol> so yo uneed to be in NDS, but I am in IO there
13:57:24 <maerwald> use type holes
13:58:15 <iqubic> Can I see the actual code we are working with?
13:58:15 <maerwald> I can make it compile, but it probably does something that is completely nonsensical
13:58:33 <rudol> http://lpaste.net/358831
13:58:42 <hexagoxel> just consider the constructors for `Predicate`, and try to express something like "sum" or any other arithmetic in it. your only chance is to make a _lot_ of use of `Is`.
13:58:59 <hexagoxel> which might even work here, i dunno.
13:59:05 <rudol> the constraints and vars can be tuned further to avoid silly solution (eg M has to be 1
13:59:39 <rudol> I already made a few new contructors for predicate (the last 3), partly for this puzlle
14:00:06 <rudol> I think it will work, if we could compile it. Th contraints are quite easy to specify and the state spae is limted
14:01:32 <rudol> it is actually quite an intersting little solution he has come up with that nicely shows off how to write a simple DSL in haskell, as well as the Non-determinism aspect and tranformers
14:01:56 <hexagoxel> (i suspect that even when using `Is`, you end up with a problem statement that scales roughly with 10^number of digits in the statement, which .. i choose to shorten to "not expressible")
14:02:35 <iqubic> Rudol: you have been told a few times now that sedmoremoney needs a different method to express it
14:03:05 <rudol> you can optimise once it compiles - for example, M has to be 1, and you can select and exclude digits already used in subsequent selections for the same candidate solution 
14:03:21 <rudol> this is how it works with a simpel for comprehension solution
14:03:36 <iqubic> Bft th
14:03:56 <rudol> iqubic - I am asking how to compile the haskell code, not whether the logic engine is th eappropriate one
14:05:03 <iqubic> And we are telling you that, because tha logic is wrong, it won't compile.
14:05:11 <hexagoxel> iqubic: the difference is that you need to express predicates that make use of arithmetic. here something like 1000*a + 100*b + 10*c + d = ...
14:05:29 <rudol> once it compiles, we will soon know if we can optimise our problem state space enough to enable  it to find solutions
14:05:54 <iqubic> Ah, I thought it was something like that.
14:06:28 <rudol> I have made a new "catch-all" type Predicate so I can express boolean expressiona s Prediactes (cf final data constructor of Prediacte type constructor)
14:06:52 <hexagoxel> for small (domains [0..9] here) you can solve such problems.
14:07:03 <rudol> exactly what I think too
14:08:54 <hexagoxel> if you dont support this, you can only emulate arithmetic by translating something simple like "a + b = c" to a=1,b=1,c=2 || a=1,b=2,c=3 || a=2,b=1,c=3   and so on.
14:09:39 <rudol> see  getVar and  the num function is trying to do
14:10:41 <rudol> and checksum, if the types worked out, can be wrapped in my new, shiny PBool predicate constructor
14:10:51 <rudol> ... that was the idea
14:12:00 <rudol> but the type of getVar :: Var -> NDS ... makes my life harder as everything (a lot anyway) seems to need to be done in the NDS monad 
14:12:13 <rudol> hence my unsuccess
14:12:16 <hexagoxel> PBool is useless. it cannot express what you hope it does.
14:12:24 <rudol> oh dear!
14:12:45 <rudol> not declarative enough?
14:13:04 <rudol> i tneeds to take a lambda, maybe
14:14:01 <rudol> hexagoxel - it woul dnot hinder compilation though, would it?
14:14:08 <rudol> hexagoxel - it would not hinder compilation though, would it?
14:14:33 <rudol> you see, if it would compile, I would discover and fix all these things that some of you are foreseeing already
14:15:18 <hexagoxel> why do you care if something compiles that is a doomed approach in the first place?
14:15:49 <rudol> are you certain it will not solve SSM?
14:15:52 <hexagoxel> and to be clear, there may be way to add to the `Predicate` type in a way to make the problem expressible.
14:16:28 <rudol> Why is SSM different to main or swe?
14:16:39 <hexagoxel> read above
14:16:42 <rudol> you have vars and constraints and a finite space
14:17:16 <rudol> I saw what you wrote, but a simple for comprehension (backtracking) solution works fien for SMM
14:17:51 <rudol> you can optimise the space a bit too, and it runs very quickly
14:19:02 <rudol> tryallvalues is effectively doing [(s,e,n,d ...) | s <- [0..9], e <- [0..9]...] isn't it?
14:19:55 <rudol> of course, you narrow the space a little by analysing the problem (eg M = 1, don't repeat usage of any preallocated digit etc, then no need to check distint ....)
14:20:36 <rudol> and the contraints do the same job as the guards 
14:20:44 <rudol> in the comprehension
14:21:11 <rudol> what is the reasoning for your assertion?
14:23:37 <rudol> iqubic - re "needs a different method to express it" - my next step, after getting this to compile and seeing it it can solve SMM, was to make the Var and Value types take params so Variables can be polymorphic. Do you think it would solve SMM then?
14:24:21 <rudol> maybe I've chewed off a bit more than a monad beginner should
14:24:36 <rudol> but I will still make it compile, eventually :)
14:24:43 <hexagoxel> the problem demands that you can express arithmetic in the `Predicate`. you don't seem to have tried much in this direction. PBool might be an attempt, but just does not make sense, because a pure `Bool` value simply cannot be sufficient.
14:25:49 <rudol> hexagonal, you are right. As soon as I can compile it I will improve the Predicate until I can be certain whether it will terminate for SMM 
14:26:38 <rudol> I suspect I need a Predicate that wraps a Var -> Bool 
14:26:57 <hexagoxel> do you want to solve a problem or do you want compiling code? your focus on the latter confuses me.
14:27:06 <rudol> compile first
14:27:16 <rudol> the logic engine works, since 2003 ;)
14:27:23 * hexagoxel has better things to do, in that case.
14:27:45 <monochrom> hexagoxel: "I want to compile it" is a proxy for the real agenda "I want to shoehorn everything into this model".
14:27:45 <rudol> I am trying to leanr hpow to lift those functions into NDS
14:28:26 <rudol> no ... I am trying to learn how to work with monds and transformers when my functions are for simple types
14:29:27 <rudol> but getVar returns a NDS ... and digitToInt is for simple types, and I thought I would be able to work out how to make them work together
14:29:47 <monochrom> You ever heard of "return" and "fmap"?
14:29:48 <rudol> I will then adapt the engine as a seperate exercise
14:30:04 <rudol> monochrom, I am glad you are back
14:30:29 <rudol> yes, I have heard of them, and read quite a lot too. But I have not written much code because i keep getting stuck ;)
14:30:48 <monochrom> OK, consider actually using them.
14:31:00 <rudol> monochrom, did t compile with return abd fmap?
14:31:12 <monochrom> I don't know and I don't care.
14:31:34 <rudol> it is only about 1o0 lines of code that needs attention (for the purpose of compilation, my first goal)
14:31:46 <rudol> monochrom, oh yeah, I  forgot
14:32:15 <rudol> s/1o0 lines of code/10 lines of code
14:32:22 <hexagoxel> rudol: use `PBool (NDS Bool)`. it is one of the worst ways i can think of to approach this problem, but maybe it tickles your fancy.
14:32:59 <hexagoxel> normally i would not give such bad advice, but you seem intend on ignoring any other.
14:33:05 <rudol> hexagonal, that crossed my mind too, but it seems like a terrible cyclic something 
14:33:18 <rudol> so then I could work in NDS all the time
14:33:32 <hexagoxel> nah, you can make it work. it will be horrible, but it will compile. probably. no idea
14:34:10 <monochrom> Also the fact that this tutorial came from 2003 is very telling. That was an era when people had a frenzy on these state monads and state monad transformers and tried to shoehorn everything under the sun into it.
14:34:22 <rudol> but then, I will reask my 2nd question - is there any way to improve this code to make it more idiomatic and sensible scalal code
14:34:33 <rudol> s/scala/haskell
14:34:39 <monochrom> In other words today no one do things this way. Fizzled construct.
14:35:08 <hexagoxel> monochrom: and i still _am_ curious if you can also shoehorn the finite-constraint-solving into it, too (properly, of course) :D
14:35:21 <rudol> yeah - it's a shame my mind is so warped and out of tune with the haskell way. I am sure one of you would have made it compile by now if it was possible
14:35:33 <monochrom> The [] monad is pretty OK though. It passes the test of time.
14:35:49 <monochrom> Just please don't slap StateT on top.
14:35:51 <rudol> StateT is hardly a new kid on the block either
14:36:20 <rudol> I didn't - it is the code I was given to work with (written in 2003)
14:37:09 <rudol> and I am trying to see in what ways I can extend it without changing the core design of the 2003 code (which I believe is quite neat, but more pedagological than production ready, probably)
14:37:49 <rudol> the whol eidea is to demonstrate StateT and List together supporting NDS
14:38:21 <rudol> it is not a statement on state of the art design for production constraint solvers
14:39:08 <rudol> it is like the difference between what a PhD student does, and soembody who has to sit in an office ;)
14:39:47 <rudol> yes, many of us would like to rewrite everything everytime we have to maintain a pice of somebody else's code, but it is not always feasile
14:39:52 <rudol> or desirable
14:40:05 <rudol> or likely to end happily
14:40:29 <monochrom> Are you actually getting paid for this? Is this actually code at your workplace?
14:40:50 <monochrom> Or are you just making up the rhetoric "at work you can't choose"?
14:40:58 <rudol> no, I am trying to learn how to lift simple functions to work with monadic code
14:41:43 <rudol> I feel that everybody has their own preconception of what I am doing because i have repeated my purpose at least 10 times todayt and yesterday ;)
14:41:58 <rudol> Ijust want to see if I can make those 4 lines of code in smm compile ;)
14:42:03 <Psybur> Are you trying to put a square peg in the circle hole? :D
14:42:13 <rudol> am I?
14:42:13 <epta> why Data.Text and Data.ByteString are not in base?
14:42:28 <monochrom> Historical reasons.
14:42:59 <geekosaur> and because base is not a dumping ground
14:43:06 <rudol> I was hoping somebody would tell me (but in teh context of getting the code to compile, not wrt to StateT vs List or Forward vs backward solver or ...
14:43:41 <geekosaur> ghc's interaction with versioning means you want as much as possible *outside* of the stuff that comes with it, otherwise the only safe way to upgrade it is to upgrade ghc
14:44:01 <geekosaur> base is not batteries-included
14:44:21 <monochrom> Wait, base is certainly a dumping ground of all new-fangled dependent type features such as GHC.TypeLit and levity polymorphism and ...
14:44:21 <Athas> geekosaur: this is because of Template Haskell, isn't it?
14:44:36 <geekosaur> no
14:44:38 <Athas> Usually I wouldn't expect the library dependencies of a compiler to have any influence on libraries used by the programs compiled by that compiler.
14:44:44 <rudol> anyway, I do appreciate that those of you who had a look did so, thank you. If I ever get it to compile, I will for sure let you know if Mr Newbern's beautiful tutorial code can even solve SMM.
14:44:50 <Athas> So how come the GHC version has any influence on which versions I can use?
14:45:02 <geekosaur> although TH is specifically why containers comes with ghc and therefore has safety considerations for upgrading
14:47:12 <geekosaur> for something ghc itself is not using, mostly it has to do with sandboxes. unless you do nix-style (stack or cabal new-build), you have to worry about whether something is built against the global package db or some sandbox's db, and whether they can be used wit each other
14:47:49 <geekosaur> stack does a lot of work specifically to avoid the nasty issues here; that's a large chunk of why it was developed
14:48:02 <Athas> Isn't there this notion of "hard-wired" packages, which are tied to GHC itself?
14:48:14 <Athas> I could have sword I've seen the stack and cabal developers complain about that.
14:48:30 <monochrom> base has to be tightly coupled to the compiler because this is where built-in opague types like Int are exported.
14:48:38 <hpc> i think base is the only package where that's the case
14:48:47 <geekosaur> and this falls out of the fact that internal library source gets exported via the .hi file for inlining for performance reasons, but this means the actual visible ABI of a library is much larger than you expect
14:49:05 <geekosaur> base and ghc-prim, actually
14:49:43 <geekosaur> and the integer package your ghc is built against (there are two, the gmp-backed one and a simple one for where LGPL is not accepotable)
14:50:19 <Athas> Is there a reason why GHC cannot load the definitions from another 'base' than it was itself compiled with?
14:50:49 <geekosaur> apparently the stuff just said didn't mean anything?
14:51:09 <geekosaur> so  let's try it again: base has hardcoded in it specifics of the runtime's representation and the compiler's interface to it
14:51:33 <geekosaur> it must therefore match the compiler and the runtime exactly or nothing will work
14:51:54 <Athas> Yes, but why is this hardcoded?
14:52:08 <geekosaur> there was exactly one ghc version (I think 2 releases for that version) that supported multiple versions of base. it was such a maintenance nighmare that it was never done again
14:52:08 <Athas> Presumably, if you wrote a Haskell compiler in a non-Haskell language, such baked-in constraints would not be present (how could they?).
14:52:25 <geekosaur> performance, as (again) already discussed
14:52:38 <Athas> Compilation speed?
14:53:31 <geekosaur> ...
14:53:35 <geekosaur> what does 'runtime' mean to you?
14:53:35 <rudol> group "ABC"
14:53:48 <rudol> > group "ABC"
14:53:50 <lambdabot>  ["A","B","C"]
14:54:08 <monochrom> So you mean that, say hypothetically, a compiler that uses the big-endian convention for numbers can just load a base that uses the small-endian convention, and everything fits together and no invariant is broken?
14:54:29 <Athas> geekosaur: it can mean both for a compiler, I suppose.
14:54:32 <geekosaur> ghc inlines everyhting it possibly can because you can end up with up to 90x slowdowns otherwise (this was measured in a prerelease of ghc 8.2.1)
14:54:38 <monochrom> To be sure I'm making this example up. No one ever does that.
14:54:49 <geekosaur> that is 90 TIMES not 90 percent
14:55:21 <geekosaur> lazy evaluation via graph reduction is expensive, ghc does everything it can to minimize the expense
14:55:33 <Athas> I am aware that GHC does heavy inlining.  I just don't understand why the base definitions apparently have to be part of the compiler binary itself, instead of being read from a data file during compilation.
14:55:35 <geekosaur> this leads to a lot of things ending up being 'hardcoded'
14:56:32 <geekosaur> other way around, you can think of parts of base being generated from the compiler. the effect is still the same, swap them out and things no longer fit together properly
14:57:34 <vc_> In linear, is there an operator to add a constant value to a matrix?
14:58:00 <vc_> not seeing one in the docs, but maybe I missed it
15:01:00 <rudol> monochrome, on a more general note, for when I want to unlearn what I am learning now ;) can you recommend any resource arguing why using  [] is more sensible than StateT + [] ? 
15:02:13 <monochrom> No.
15:03:05 <stevenxl> Hi folks. Can I get some feedback on my applicative instance for EitherT : https://gist.github.com/StevenXL/a4eabf4e00c8414c9a72dcda44fbb0a9
15:03:11 <rudol> OK, I'll take your word fo rit then.
15:03:12 <stevenxl> It's for the Haskell Book; one of the exercises.
15:03:46 <sm> g'day all!
15:04:42 <sm> seems like #haskell has turned a bit cranky :)
15:05:03 <monochrom> My fault I guess.
15:05:16 <sm> and we used to be the Friendliest Place On Earth
15:05:57 <rudol> no - I think I asked what appears to be a bad question, and people couldn't be as helpful as they always try to be. I will ask better questions
15:08:47 <vc_> i'm in a great mood :D
15:09:47 * hackagebot lxd-client 0.1.0.2 – LXD client written in Haskell. – https://hackage.haskell.org/package/lxd-client
15:10:18 <stevenxl> what's that language extension that lets you have multiple pattern matches in a lamda/
15:10:59 <monochrom> LambdaCase
15:11:08 <stevenxl> monochrom: thank you
15:11:39 <stevenxl> Hm.. I'm wondering If I have implemented the applicative of EitherT  correctly. Any thoughts anyone? https://gist.github.com/StevenXL/a4eabf4e00c8414c9a72dcda44fbb0a9
15:14:55 <monochrom> Yeah, say I have EitherT (return (Left something)) <*> EitherT (putStrLn "OK" >> return (Right 5))
15:15:38 <monochrom> Your current will perform the putStrLn OK, despite me putting a Left before.
15:15:45 <monochrom> Is this what you really want?
15:17:22 <stevenxl> monochrom: hm.. let me think about that for one second
15:19:35 <stevenxl> monochrom: No I don't think that's the correct behavior. Let me see what I can do. 
15:30:07 <jared-w> stevenxl: why did you define pure the way you did?
15:31:47 <stevenxl> jared-w: It's the easiest way I could think of of putting the a in both the monad context and the Either context. I guess now that I think about it, would you suggest it be `pure a = EitherT $ pure (Right a)`?
15:32:07 <stevenxl> Since Either already has an applicative, I thought I could leverage that. 
15:32:38 <monochrom> I think it's fine either way.
15:33:07 <stevenxl> monochrom: I'm still thinking through your question, but I have to go get the family dinner. (They need to eat 3 times a day ;)
15:33:17 <stevenxl> I'll get back on it. Maybe after dinner I'll think clearer.
15:33:30 <jared-w> Mm, yeah you're right; I was thinking they wouldn't be equivalent for a second then I realized I was reading it wrong
15:33:35 <stevenxl> (The behavior you described is not what I want, but I'm not sure how the implementation does that).
15:33:42 <stevenxl> jared-w: ;-)
15:34:19 <jared-w> I think the key is thinking of it as "two levels" of Either, perhaps? Not sure since monad transformers are still a bit beyond me
15:35:06 <monochrom> In EitherT (pure (pure a)), the second pure is Right. The first pure belongs to m.
15:35:35 <monochrom> More verbosely and less compilably, EitherT (pure_m (pure_Either a))
15:36:27 <jared-w> gotcha. I was thinking more for how to implement <*> but that helps as well :p
15:40:20 <monochrom> The spoiler is that you now need Monad m, not just Applicative m.
15:40:51 <monochrom> For more spoiler, just read Control.Monad.Trans.Except source code. :)
15:41:22 <jared-w> I was reading it already :p
15:41:31 <ggVGc> I've been asked to make a URI parser as a code test for a job. I can choose any language, and have so far implemented it in two. Thinking I'll make a haskell version that is a small DSL that generates C for the URI parser
15:41:47 <jared-w> Oh, does it need the Monad m because it's a monad transformer?
15:42:36 <monochrom> No, it needs Monad m because it wants to take a look at whether the first action returns a Left or Right before it decides to skip or pursue the second action.
15:48:49 <jared-w> oh right, it needs to choose and the choice is monadic in nature, gotcha.
15:49:34 <proofskiddie> http://lpaste.net/358838
15:49:47 <proofskiddie> Any suggestions for how to make this function use the heap less?
15:49:59 <jared-w> Haskell doesn't have a heap, so congrats! You're not using it!
15:50:49 <geekosaur> that's not true :) it doesnt have a callstack. it has a heap
15:51:19 <proofskiddie> semantics
15:51:21 <jared-w> Isn't that more like way deep down in the compiler implementation when it translates from the graph into something a von neumann architecture hates less?
15:52:08 <srhb> Not really.
15:52:37 <jared-w> Anyway, joking aside, are you wanting to know about how to make the function more performant, proofskiddie?
15:52:51 <proofskiddie> yes, general advice is also awesome
15:53:16 <monochrom> That is also not true. These days you see the phrase "HasCallStack" in a lot of runtime error messages. :)
15:53:49 <srhb> :q
15:53:53 <srhb> Woops.
15:54:21 <geekosaur> I still think that is misnamed, because there are (admittedly obscure and subtle) differences from that and a real call stack.
15:55:04 <monochrom> E37: No write since last change (add ! to override)
15:55:21 <srhb> :(
15:55:41 <monochrom> Yeah should have just said "HasStack".
15:56:02 <epta> E492: Not an editor command: (
15:56:02 <jared-w> You'll have some more performance by switching from Integral a to Integer and from Integer to Int. You'll also probably get a good bit more performance if you switch to a fold implementation. Lastly, concatenation is O(n) on linked lists and if you really care about performance you might want to switch the data structure to something with O(not n) concatenation. Of course, performance is fickle and none of
15:56:05 <jared-w> the advice I gave should be blindly implemented without benchmarking :p
15:56:06 <monochrom> But then that would send the wrong message too. "Oh so GHC comes with Stack!"
15:59:23 <proofskiddie> http://blog.ezyang.com/2011/04/the-haskell-heap/
16:00:19 <proofskiddie> "some presents [thunks] explode when you open them"
16:02:32 <ggVGc> haskell programmers quickly learn to not run their programs so much
16:02:49 <ggVGc> it's more rewarding just letting the type checker say you're all good
16:04:45 <monochrom> haha
16:05:09 <dysfigured> jared-w: i like how your message got split, so your last message was "the advice I gave should be blindly implemented without benchmarking :p"
16:05:17 <jared-w> s/haskell/<dependently typed language/proof-checker>/
16:05:41 <monochrom> Ooohhh you're appending little things to a long list. This is no good.
16:05:52 <jared-w> dysfigured: pffh, figures that would happen; I didn't even notice at first
16:06:52 * hackagebot hledger 1.4, hledger-api 1.4, hledger-lib 1.4, hledger-ui 1.4, … and 1 more
16:06:53 * hackagebot  → https://hackage.haskell.org/packages/recent
16:08:16 <monochrom> What is _0 ?
16:09:35 <marvinXP> if I have function a calling function b many times, with three args, and function b does some big calculation using arg 1&2 before looking at 3, but 1&2 are always the same, will haskell optimize this to not do that big calculation with 1&2 multiple times?
16:10:13 <monochrom> http://lpaste.net/358838#a358840
16:10:29 <proofskiddie> monochrom : Word8 sugar for ascii 0, its 48
16:10:38 <monochrom> Oh!
16:11:04 <zachk> break out the 1&2 function and let bind to it before calling the new function that uses that result and the third argument
16:11:28 <monochrom> OK, reload that, I have put back the _0
16:11:37 <proofskiddie> monochrom : thanks!
16:11:56 <marvinXP> zachk: so the answer is no, I guess?
16:12:51 <jared-w> proofskiddie: great series; I've never read it before, it was a fun read :)
16:13:06 <monochrom> I don't know about saving space, but my version should use much less time.
16:14:24 <proofskiddie> To the untrained eye, I, the difference between the two is subtle
16:14:36 <jared-w> Oh neat, I see what you did there, I think.
16:14:50 <proofskiddie> oh you used an accumulator right?
16:15:38 <jared-w> If I'm following it correctly, by pulling out the mutating state into a variable 's' it basically turns into a pure version of the state monad (I think?)
16:15:54 <geekosaur> marvinXP, usually to get that effect you want to name and reuse the partial application. and even then it might not work if the function is too strict. generally you need to be able to *produce a result* (e.g. the first part of a lazy list) with the partial application for laziness to be able to split the computation that way
16:16:54 <jared-w> It also seems to avoid sticking a small thing at the end of the list and instead allows you to cons it which is O(1) time.
16:35:32 <proofskiddie> http://lpaste.net/358838
16:35:51 <proofskiddie> PackIntegral_opt is the acumulator version
16:36:24 <proofskiddie> its very very much faster and uses less memory
16:37:13 <zachk> @src reverse
16:37:13 <lambdabot> reverse = foldl (flip (:)) []
16:37:43 <monochrom> It is not an accumulator. Accumulator would be "loop (div n 10) (...)" not "loop (div n 10) ++ ..."
16:37:53 <monochrom> There is also a reason I set a title.
16:38:07 <proofskiddie> I changed it actually to loop (div n 10) (...)
16:38:39 <proofskiddie> I assumed that is what you meant, it wouldn't compile as loop (div n 10) ++ (...)
16:38:45 <proofskiddie> because loop expected 2 args
16:38:59 <monochrom> Oh, right, yeah.
16:39:24 <Welkin> also, (++) doesn't work on (:: Num a => a)
16:39:56 <Welkin> :t (++)
16:39:57 <lambdabot> [a] -> [a] -> [a]
16:40:10 <Welkin> okay, [a]
16:45:28 <Psybur> @src group
16:45:28 <lambdabot> group = groupBy (==)
16:46:06 <Psybur> whoops looks like i gave someone bad advice earlier lel
16:46:35 <rudol> ...
16:46:57 <Psybur> Ah there you are. Dont use group to replace map show, use that map (flip (:) []) thing :D
16:47:04 <rudol> group "ABABBC"
16:47:08 <rudol> > group "ABABBC"
16:47:10 <lambdabot>  ["A","B","A","BB","C"]
16:47:23 <Psybur> > map (flip (:) []) "ABABBC"
16:47:24 <rudol> thanks
16:47:26 <lambdabot>  ["A","B","A","B","B","C"]
16:47:42 <rudol> in the previous case, the flipper is betta
16:48:48 <Psybur> @src show
16:48:48 <lambdabot> show x = shows x ""
16:48:56 <Psybur> @src shows
16:48:57 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
16:49:11 <Psybur> Ouch :D
16:50:03 <lroy> @src show
16:50:04 <lambdabot> show x = shows x ""
16:50:47 <Psybur> rudol, the reason you dont want to use show is because I think it messes up some unicode, if youre going to be using any of that :D
16:52:22 <rudol> thanks Psybur. I guess to make a Char into a String you just apply [] to it. 
16:52:32 <rudol> and for an Int?
16:53:28 <Psybur> rudol, Im not sure I follow. How do you turn an Int into an [Int] ?
16:53:40 <rudol> I guess you could go via intToDigit
16:53:55 <rudol> no, Int -> String without Show
16:54:16 <Psybur> Whats wrong with using show?
16:54:18 <monochrom> show is OK for Int->String
16:54:39 <rudol> OK, so it's just for more esoteric Unicode chars that one has to be cautious
16:55:36 <rudol> btw, monochrome, your forward constraint propogation is very nice, and I read your Fix article too. Thanks
16:56:24 <Psybur> @source showsPrec
16:56:25 <lambdabot> Unknown command, try @list
16:56:31 <Psybur> @src showsPrec
16:56:31 <lambdabot> showsPrec _ x s = show x ++ s
16:57:08 <rien> What is the state of the art in terms of a development environment and a workflow/deploy cycle for Haskell development? Is it Stack + Nix + Docker?
16:57:21 <Psybur> It also seems that using show for a string will be less efficient
16:58:39 <rudol> I guess it must waste some cycles, superflously. That should not be in the code for [String] s anyway - I changed from [Char] and that was not removed yet. 
16:58:43 <Psybur> so the flip cons empty way is better in more than just unicode (if Im navigating the source correctly)
17:04:31 <rudol> how does one use get if not in a StateT's  do  block?
17:04:58 <rudol> it takes no args, so how does it know which StateT I want without the context opf the do?
17:05:16 <zachk> if you are not in the State(T) monad you can't use get
17:05:17 <Welkin> rudol: you have multiple StateT?
17:05:35 <zachk> do you have nested stateT? merge your states into a record and use lens on it 
17:05:42 <monochrom> The outermost one.
17:07:03 <rudol> if I am not in a do block, I am trying to imagine what get would return
17:07:39 <monochrom> I don't think "do" is the point.
17:07:50 <monochrom> Look at the type. The type is the point.
17:08:15 <monochrom> People use "get" all the time without "do", and "do" all the time without any Monad instance.
17:08:21 <monochrom> > do True
17:08:24 <lambdabot>  True
17:08:27 <monochrom> QED
17:08:38 <rudol> I have used get a little, but I sort of imagined that the do provides some context which enables get to know the StateT instance to return
17:08:40 <crucify_me> hi if you helped me with this yesterday and feel annoyed, please ignore this. I almost have a good understanding of this ' foldl (flip (:)) [1,2] [10,11] '    there is a question I have about this stack overflow upvoted answer    :    https://stackoverflow.com/questions/30369954/how-does-this-foldl-based-function-work-myreverse-foldl-flip
17:09:26 <monochrom> That may be true but I'm going to bust it anyway.
17:09:28 <monochrom> @type do get
17:09:30 <lambdabot> MonadState s m => m s
17:09:32 <monochrom> @type get
17:09:34 <lambdabot> MonadState s m => m s
17:09:36 <jared-w> > foldl (flip (:)) [1,2] [10,11]
17:09:37 <monochrom> Same difference.
17:09:38 <lambdabot>  [11,10,1,2]
17:10:05 <hydraz> Does anyone use `do True`?
17:10:14 <monochrom> No. :)
17:10:16 <crucify_me> my question re: the definition of foldl , in the text it says "you see - the function you have to pass will here ...
17:10:25 <hydraz> monochrom: good.
17:11:26 <crucify_me> foldl :: (b -> a -> b) -> b -> [a] -> b
17:12:24 <crucify_me> my question does that signature indicate that the function is taking a list, then an element, producing another list? 
17:12:27 <crucify_me> is
17:12:49 <rudol> what does do get desugar to? Just get?
17:12:56 <monochrom> Yes.
17:13:38 <rudol> hmmm - I think that's made it worse :) 
17:14:08 <crucify_me> jared-w: can you help me here?
17:15:25 <crucify_me> I don't see how we can see that foldl :: (b -> a -> b) takes a list, then an element, then returns another list, from that function in the signature
17:15:50 <rudol> crucify_me the b param can be a list, or of any other type that the function knows how to use  
17:16:13 <rudol> typically, the b is an accumulator
17:16:48 <rudol> and the function combines it, somehow, with the head of the list
17:16:49 <geekosaur> crucify_me, b and a are any type, provided they match across all uses. it doesn't matter *what* type
17:17:16 <monochrom> @type flip (:)
17:17:18 <lambdabot> [a] -> a -> [a]
17:17:24 <monochrom> Perhaps you should sleep on that.
17:17:37 <geekosaur> ^ see that type. now unify it with the type of the function parameter
17:18:14 <zachk> @type flip flip 
17:18:16 <lambdabot> b -> (a -> b -> c) -> a -> c
17:18:24 <crucify_me> ok this is where I have trouble: the unifying, though Im getting closer to getting it
17:18:53 <zachk> @type flip
17:18:55 <lambdabot> (a -> b -> c) -> b -> a -> c
17:19:11 <geekosaur> rename the type variables it just gave you so they don't collide: (flip (:)) :: [t] -> t -> [t]
17:19:12 <rudol> see what   dup as = foldl (:) [] as  does
17:19:18 <geekosaur> the function parameter: b -> a -> b
17:19:24 <crucify_me> @type foldl
17:19:26 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
17:19:32 <geekosaur> in this case it's easy to see that b ~ [t], a ~ t
17:20:21 <geekosaur> hm, maybe I shouldn;t have used t since there's that Foldable constraint using it
17:20:24 <monochrom> If you use emacs haskell-mode, M-x haskell-mode-show-type-at is of interest.
17:20:29 <geekosaur> otoh I want the sipler case anyway, the list
17:20:52 <geekosaur> (b -> a -> b) -> b -> [a] -> b
17:21:34 <geekosaur> so now substitute in our relations of those to t (b ~ [t], a ~ t):  ([t] -> t -> [t]) -> [t] -> [t] -> [t]
17:22:29 <crucify_me> very sorry I don't follow that notation
17:22:53 <geekosaur> b unifies with [t], a unifies with t
17:24:36 <crucify_me> that's interesting. that I see geekosaur
17:26:07 <geekosaur> you should probably learn that syntax because ghc uses it in constraints
17:37:25 <crucify_me> geekosaur: ok thank you kindly, so in the foldl signature, only the second argument to the function must be a list (  [a]  ) , and the foldl function itself extracts an element (an 'a') out of that list , [a]. it's not any part of (flip (:)) that extracts its. 
17:39:13 <monochrom> second? third?
17:39:17 <geekosaur> right. flip (:) is handed the current base (b) and a list element (a) and produces a new base (b). you provide a list to get elements from (or in the more general modern form, a Foldable of some kind) and an initial base (sometimes mis-called an "accumulator")
17:39:31 <geekosaur> hm, right, reverse those
17:39:43 <geekosaur> function, initial base, Foldable
17:40:40 <crucify_me> ok thanks alot -- its dawning on me. 
17:42:21 <rudol> base sounds better
17:42:48 <monochrom> seed
17:43:23 <rudol> when you're dealing with a Monoid, its mzero
17:43:26 <monochrom> And for foldr: cons_replacement, terminator, list
17:44:15 <rudol> terminator?! As in final return type?
17:44:51 <monochrom> Actually, make it connor, terminator, bullet chain.
17:47:11 <geekosaur> rudol: you can think of foldr as taking a list, x:x:x:[], and replacing the (:) with the function and the [] with the terminator
17:47:53 <monochrom> 1 : (2 : []) --> 1 `connor` (2 `connor` terminator)
17:48:23 <rudol> yes, my foldl example would of course not compile. But why is it called terminator?
17:48:29 <geekosaur> foldr f z [a,b,c] is a `f` b `f` c `f` z
17:48:36 <geekosaur> its replkacing the [] that terminates a list
17:48:51 <rudol> of course
17:48:52 <geekosaur> remember that [a,b,c] is a:b:c:[]
17:49:13 <monochrom> Ah look up "bnc terminator"
17:49:35 <monochrom> s/Ah/Also/
17:49:43 <monochrom> Also look up "Dalek"
17:50:17 <rudol> $5.65 at amazon
17:51:49 * geekosaur sends monochrom a designer salt shaker with a toilet plunger attached
17:52:08 <jared-w> lol
17:52:25 <jared-w> Daleks--best used with the Tardis monad
17:53:51 <monochrom> haha
17:54:16 <monochrom> "exterminate all humans with toilet plunge"
17:54:53 <geekosaur> some of the early ones did have egg beaters instead...
17:55:02 <monochrom> haha neat
17:55:30 <jared-w> Fun fact: The entire Dalek costume was made in like 45 minutes in a mad scramble at a store before shooting began :p
17:55:57 <rudol> I wish I could make a monad in 45 minutes
17:56:03 <geekosaur> and every alien world looked strangely like an abandoned quarry in Cardiff
17:56:52 <jared-w> Surely that was just due to the film grain... It'd be an awful coincidence otherwise, y'know
17:57:03 <monochrom> Afterall Cardiff was also where King Arthur got his sword from aliens.  </moarrumours>
17:58:07 <jared-w> I thought that he got it from the river lady handing out strange swords n all that?
17:58:20 <jared-w> I suppose that wouldn't constitute a good system of government, though...
17:58:30 <monochrom> Alien river lady.
17:58:46 <geekosaur> bbc didn't have much of a location budget for shows like that in the 60s
17:59:01 <geekosaur> or prop budget
17:59:40 <jared-w> "budget"
17:59:48 <jared-w> didn't have much of anything for shows like that :p
18:00:56 <rudol> if anything they used was any more realistic, it would've looked awfully out of place, even artificial!
18:21:53 * hackagebot tinyfiledialogs 0.2.0.0 – Wrapper around the 'tiny file dialogs' C library – https://hackage.haskell.org/package/tinyfiledialogs
19:37:02 * hackagebot brick 0.25 – A declarative terminal user interface library – https://hackage.haskell.org/package/brick
20:04:22 <dustmote> Does anyone have experience with protobuf in haskell? Is it possible to use an external protobuf file like an alex or happy file?
20:05:13 <dogbitsman> I know I can pattern match to a list of one GADT by doing [Bool _] But How Do I pattern match with a list of arbitrary length
20:06:57 <dustmote> dogbitsman: use a recursive function, with each call pattern matching one element of the list
20:07:22 <dogbitsman> So like [Book _:xs]
20:07:56 <geekosaur> use parentheses instead of brackets
20:07:56 <dustmote> Yep. But pretty soon you'll just want to use foldl instead
20:08:07 <geekosaur> (x:xs) is a list split into head and tail
20:08:12 <geekosaur> [x] is a 1-element list
20:08:24 <geekosaur> [x,y] is a 2-element list etc.
20:08:35 <dogbitsman> ok but I want make sure it's that specific gadt
20:08:43 <geekosaur> you can also do (x:y:xs) to pull off the first 2 elements plus the tail
20:09:06 <geekosaur> (x@(Book _):xs)
20:09:17 <dogbitsman> Thanks
20:09:38 <geekosaur> if you mean you need the all the be the same constructor, you can't do that in a single expression; you will need to work recursively
20:09:48 <dogbitsman> I see
20:10:12 <dogbitsman> So I need to pattern match on each head
20:12:35 <dogbitsman> Is there a way I can take list and check there all the same constructer
20:13:41 <dustmote> dogbitsman: http://lpaste.net/358851 something like this
20:13:47 <dustmote> Not exactly right, heh
20:15:12 <dustmote> Last line should be [] not (_:[])
20:15:58 <dustmote> This style of programming will cause memory leaks for long lists though
20:19:21 <dogbitsman> Ok and then compare that number to original length
20:31:42 <dustmote> dogbitsman: sure.. or you could write the function to return the boolean directly
20:53:17 * hackagebot symmetric-properties 0.1.0.0 – Monoids for sameness and uniqueness. – https://hackage.haskell.org/package/symmetric-properties
20:58:33 <pussyslayer> hi
20:58:48 <pussyslayer> ??
20:59:11 <pussyslayer> anyone
21:00:10 <pussyslayer>  
21:00:19 <pussyslayer>  
21:00:20 <pussyslayer>  
21:00:21 <pussyslayer>  
21:00:29 <dogbitsman> Hello
21:08:04 <d6e> lol
21:47:47 <ackpacket> Now, there are dozens of ways I can do this using functions, tail recursion, all that good stuff.  But since there is *usually* some magic I'm missing out on, might as well ask:
21:48:27 <ackpacket> I want to transform a list of numbers into [ (X, Y) , ..... ]  Where X is the number, and Y is the number of occurances all numbers <= X
21:49:34 <ackpacket> so [3, 1, 2, 3, 2, 3] becomes [(1, 1), (2, 3), (3, 6)]
21:53:05 <Maxdamantus> ackpacket: fwiw, that's called a "histogram".
21:53:18 <ackpacket> Maxdamantus, Close, this is cumulative though
21:53:25 <ackpacket> Maxdamantus, so it's probably some variant of
21:53:33 <Maxdamantus> Oh, okay.
21:53:47 <ackpacket> Maxdamantus, Also, I believe a histogram is bucketed.  This only includes values that occured.
21:55:14 <dsal> I'm really confused by this:
21:55:15 <dsal> > [w | w <- (take 2 ['A'..'Z']) ++ (take 3 ['0'..'9'])]
21:55:18 <lambdabot>  "AB012"
21:55:26 <dsal> I'd expect that to generate a list of strings.
21:55:51 <dsal> But I guess I can see what it's doing now that I've said it here.
21:55:57 <ackpacket> dsal, Well, you're doing [w | w <- ("AB012") ]
21:56:07 <dsal> Yeah, I see that now.
21:56:11 <ackpacket> dsal, and "ABO12" is [Char]
21:56:14 <geekosaur> rubber duck debugging at its finest!
21:56:29 <dsal> Let me see if I can do the thing I'm actually trying...
21:56:32 <exio4> rubber duck debugging is quite useful 
21:56:44 <exio4> dsal: you might want replicate? 
21:57:18 <ackpacket> dsal, what are you actually trying?
21:57:34 <dsal> I'm trying to generate a list of random strings.
21:57:49 <dsal> That's the minimized bit that I was getting wrong.
21:58:03 <ackpacket> how random
21:58:08 <dsal> ish
21:58:11 <dsal> My code looks like this:
21:58:13 <dsal> [w | let l = randomRs ('A', 'Z') g1
21:58:14 <dsal>                    , let d = randomRs ('0', '9') g2
21:58:14 <dsal>                    , w <- (take 2 l) ++ (take 3 d)
21:58:14 <dsal>                    , w `notElem` seen]
21:58:34 <dsal> "seen" is a [String]  I just want to make sure the thing I generate isn't in the list of things I've seen
22:00:05 <ackpacket> what are g1 and g2?
22:02:27 <dsal> RandomGen g
22:02:35 <dsal>   g1 <- newStdGen
22:02:35 <dsal>   g2 <- newStdGen
22:06:21 <ackpacket> Might toss this question in ##programming to see what turns op, 'scuse the double post
22:08:12 <dsal> My brain's just getting confused by understanding that the w <- isn't an infinite list, but I'm trying to do it in a list generator.
22:09:36 <geekosaur> I suspect the problem here is w :: Char
22:10:04 <geekosaur> which is going to make that test against seen problematic, among other things
22:10:14 <dsal> Right, that's what I'm running into.
22:10:16 <geekosaur> (the result is the concatenated result of each passing w)
22:10:24 <geekosaur> er, the result of the list comp is...
22:10:24 <dsal> I see w as String, but it's Char
22:10:54 <geekosaur> "make me a list of ws, where ..."
22:12:00 <geekosaur> then read "<-" as "is taken from each element of"
22:12:16 <dsal> Yeah, that's a lot clearer.
22:12:21 <dsal> I think I just can't use a list comprehension here.
22:12:29 <dsal> It's pretty easy to think about how to do it without one.
22:13:04 <tabemann> does anyone know what channel the developers of gi-gtk use?
23:34:34 * hackagebot stache 1.2.1 – Mustache templates for Haskell – https://hackage.haskell.org/package/stache
23:46:39 <srhb> Is anyone using slack-api? I can't seem to connect with the trivial echobot example: *** Exception: user error (expected Bool, encountered String) -- which is less than helpful.
