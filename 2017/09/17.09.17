00:12:43 <orzo> I have a little quiz program with main: mapM_ doLesson <$> lessons
00:12:55 <orzo> i was shocked when the progrma did nothing at all
00:12:57 <orzo>  it just quit
00:13:06 <orzo> i switched to do syntax and that fixed it
00:18:09 <osa1> orzo: I don't think your one liner type checks. show us the code.
00:18:10 <cocreature> orzo: you’ll have to give us a bit more details. how are lessons and doLesson defined? also how does the version using do syntax look like?
01:23:11 <ongy> https://patrickmn.com/software/the-haskell-pyramid/ sounds about right
01:27:13 <int-e> good one
01:33:20 <[exa]> "The secret that keeps haskell avoiding success" :]
01:45:32 <maerwald> monads are overrated
01:49:07 <pacak> Monads... A like burritos.
02:46:34 <dminuoso> What does the Control in things like Control.Monad mean?
02:58:12 <bitonic> is there a way to export only the data constructors of a datatype, but not the type constructor?
03:23:31 <cocreature> dminuoso: doesn’t really mean anything. at some point, people thought that it should be possible to make a consistent distinction between Data.* and Control.* but now we have Data.Functor and Control.Monad and the distinction is mostly meaningless
03:33:50 <nickhs> Hey there, I'm trying to do create a record type with function types that include monads - but I keep getting back that my type variable is not in scope. Something like http://lpaste.net/358519
03:33:53 <nickhs> What am I missing?
03:34:59 <dminuoso> cocreature, I see. At times it's really hard to figure out where libraries I want are to be found.
03:35:39 <mauke> nickhs: well, what should the scope of 'a' be?
03:35:42 <cocreature> nickhs: that code won’t produce the error you claim it does. that’s a syntax error
03:35:45 <mauke> nickhs: how do you want this type to be used?
03:36:25 <nickhs> @cocreature sorry, it's meant to be `data Test = Test {...`
03:36:25 <lambdabot> Unknown command, try @list
03:37:17 <nickhs> @mauke I want to be able to construct a Thing with a function that fulfills that type signature, pass the Thing around to other functions and have them call it
03:37:18 <lambdabot> Unknown command, try @list
03:38:22 <mauke> nickhs: define "fulfills"
03:38:31 <Ulrar> Hi, is there a simple way to clean a bytestring of all utf8 emoji (or any "weird" symbols that could mess up a badly configured terminal) ?
03:38:31 <mauke> who gets to choose what 'a' is?
03:38:32 <cocreature> nickhs: the simplest solution is to change the type to "data Test a = Test { thing :: a -> a }" and put the "Num" constraint on the use site
03:39:04 <mauke> Ulrar: anything could mess up a badly configured terminal
03:39:37 <Ulrar> Sure, but most thinks are okay almost all of the time
03:39:43 <Ulrar> emojis though ..
03:39:48 <nickhs> mauke: the person who constructs the `Test` record get's to decide what a is concretely, given the bounds
03:39:49 <cocreature> that seems like a pretty vague requirement
03:40:09 <Ulrar> Removing all emojis would be enough
03:40:17 <mauke> nickhs: that means you can't actually call the function
03:40:34 <mauke> nickhs: because when you're given a value of type Test, you don't know what 'a' is
03:41:47 <cocreature> Ulrar: step 1. figure out what encoding is used in your bytestring; step 2. convert to Text; step 3. figure out what unicode endpoints are used for emojis and filter those; step 4. convert back to a bytestring
03:42:06 <Ulrar> It's all utf8
03:44:02 <dminuoso> Every functor that I have been looking at seems to be also an applicative/monad/monadplus. What is an example of a functor that is not an applicative?
03:47:04 <nickhs> mauke: right...but you do know the bounds that a can be in
03:47:14 <cocreature> dminuoso: Const is always a Functor, but in general it is not an instance of Applicative (you need additional constraints)
03:47:40 <cocreature> nickhs: what bounds are you referring to? Num doesn’t give you any bounds
03:48:08 <mauke> nickhs: ... no?
03:48:29 <nickhs> err, sorry, maybe bounds isn't the right word. I mean the type constraints.
03:48:34 <cocreature> and even a Bounded constraint only gives you some abstract bounds of a type a that you don’t know so it’s not useful either
03:48:52 <cocreature> nickhs: right but what does knowing that a is an instance of Num give you?
03:48:58 <cocreature> you can’t do anything useful with that information
03:49:44 <nickhs> cocreature: well you know what typeclasses it fulfills, so in the case of Num you can call math operations on it for example
03:50:41 <cocreature> nickhs: but what good are math operations if you can’t do anything with the result of those operations because you have no way to convert it to something else?
03:50:57 <nickhs> (here's a better example I think http://lpaste.net/358520)
03:51:26 <mauke> nickhs: 'func num' is a type error
03:51:40 <mauke> num is an Int, but func requires an (unknown) 'a' type
03:52:34 <nickhs> so `a` is a specific type, not a collection of potential types?
03:53:27 <mauke> that's what you said
03:53:34 <cocreature> you said it yourself “the person who constructs the Test record get’s to decide what a is”
03:53:42 <cocreature> so the user of that type can’t assume anything about a
03:53:46 <cocreature> apart from the constraints
03:54:12 <mauke> now if you had said "the user of funcToCall gets to decide what a is", things would be different
03:54:36 <nickhs> sure, but why are the constraints not sufficient? `func` is generic across all Num, no? `func` is then called with an Int, which implements Num?
03:55:19 <mauke> func is not generic
03:55:28 <mauke> func is specific to a single (unknown) a
03:55:56 <mauke> at least in our current fantasy world
03:56:06 <mauke> <mauke> now if you had said "the user of funcToCall gets to decide what a is", things would be different
03:56:17 <mauke> this describes the universe you're currently talking about
03:57:09 <mauke> anyway, the generic thing would look like: data Env = Env { funcToCall :: forall a. (Num a) => a -> a }
03:57:29 <nickhs> okay, I agree the latter statement does describe the paste better
03:57:42 <mauke> whereas the other one (where the person who constructs the Env gets to decide) would look like ... I'm not sure actually
03:57:51 <mauke> how do you do existential record types?
03:58:09 <mauke> data Env = forall a. (Num a) => Env { funcToCall :: a -> a } or something?
03:58:26 <cocreature> whether the rank-n solution is better than "data Env a = Env { funcToCall :: a -> a}" and a constraint on the use site is also depatable
04:00:07 <nickhs> @mauke it looks like I need a language extension to use `forall a.` - the compiler recommends RankNTypes. Is that what you're getting at?
04:00:08 <lambdabot> Unknown command, try @list
04:00:41 <mauke> well, yes
04:00:45 <mauke> RankNTypes is assumed
04:00:57 <mauke> also, please stop giving the bot nonsense commands :-)
04:01:26 <nickhs> yeah I apologize, using @ is a force of habit
04:02:42 <nickhs> okay, that looks to be more along the lines of what I want. I guess the next step is to read up on RankNTypes. Thanks!
04:11:03 <clinton> Is there a way to write a constraint like so: "type MyConstraint (a :: k) = (k ~ Type, Ord a)"
04:11:33 <clinton> I'm getting the error "'a' has kind 'k'", but it really doesn't due to the constraint.
04:12:29 <[exa]> what would semantic meaning of that be?
04:14:25 <cocreature> ghc probably checks that constraints are well-kinded before it starts resolving them
04:32:12 <clinton> I worked it out, this does the trick I think:
04:32:25 <clinton> type ToType (a :: k) = ToType' k a
04:32:44 <clinton> type family ToType' k (a :: k) where
04:32:58 <clinton>   ToType' Type a = a
04:40:09 <monoidal> Hello, fellow haskellers
04:43:08 <dminuoso> monoidal, I was thinking of a nerdy way of responding that with `const`, but it wasn't funny. :( 
04:45:24 <monoidal> question that has been going in my head recently, why is Monad not a subclass of Functor even if in the mathematical sense it should be, but a subclass of Applicative which *is* a subclass of Functor?
04:47:01 <Tuplanolla> What's the difference, monoidal? Hierarchies are transitive.
04:47:05 <mauke> monoidal: what
04:48:17 <monoidal> Tuplanolla, but I mean, why is it necessary to be an applicative to be an instance of Monad?
04:48:38 <mauke> because every monad is an applicative?
04:48:58 <monoidal> hm
04:50:21 <Tuplanolla> Prove this yourself by implementing `pure` and `<*>` in terms of `return` and `>>=` and observing the laws, monoidal.
04:53:46 <Eduard_Munteanu> monoidal, it's just useful in practice, although strictly speaking monads aren't necessarily applicatives
04:55:38 <Eduard_Munteanu> You can derive an Applicative from Monad but they are different concepts.
04:58:25 <dminuoso> The question Im wondering, if fmap/pure/<*> can be implemented in terms of return and bind, then why is there no such default implementation?
04:59:06 <Tuplanolla> Can you give an example of an applicative that's not derivable from a monad, Eduard_Munteanu?
04:59:16 <Tuplanolla> I'd like to see how this is done in Haskell.
04:59:20 <monoidal> Eduard_Munteanu: such as f <*> x = f >>= \f' -> x >>= \v -> return $ f' v
05:15:13 <Poi_> :t fix
05:15:15 <lambdabot> (a -> a) -> a
05:21:54 <whoisxy> I'm a bit confused with the $ function
05:22:02 <whoisxy> :t ($)
05:22:04 <lambdabot> (a -> b) -> a -> b
05:22:09 <dminuoso> whoisxy, fixity
05:22:16 <dminuoso> That's all there is to that function.
05:22:43 <whoisxy> map (+1) $ map (+1) [1,2,3]
05:23:10 <whoisxy> but in that example surely map is one argument and (+1) is another
05:23:19 <dminuoso> nope
05:23:44 <whoisxy> so map (+1) is it's own function
05:24:07 <dminuoso> whoisxy, the point of $ is to introduce a low precedence that is the same as if you placed parens around _everything_ to the right of it
05:24:17 <Fekinox> map (+1) $ map (+1) [1,2,3] is the same as map (+1) (map (+1) [1,2,3])
05:24:38 <whoisxy> dminuoso: sure I get that it's just they type which confuses me
05:25:13 <dminuoso> whoisxy, it's an infix operator.
05:25:20 <dminuoso> whoisxy, so the left side is its first argument
05:25:35 <dminuoso> the implementation is just f $ x = f x
05:25:48 <whoisxy> so "map (+1)" = (a -> b)
05:26:18 <dminuoso> yup
05:27:20 <whoisxy> actually I think it helps if I evaluate the right hand side first
05:28:46 <kuribas> :t map (+1)
05:28:48 <lambdabot> Num b => [b] -> [b]
05:31:01 <whoisxy> thats quite cool, thanks
05:32:31 <dminuoso> whoisxy, precedence is the same as you are used to with arithmetic. * has higher precedence than +, which means if you wrote 1 + 2 * 3, you might as well write it as 1 + (2 * 3)
05:33:03 <dminuoso> whoisxy, $ is no different, except it has a precedence of 0 - so there's nothing that has a lower precedence. ;-)
05:33:12 <ertes> whoisxy: keep in mind that function application has a higher precedence than any operator
05:33:36 <ertes> f x !!! g y = (f x) !!! (g y)  -- regardless of what (!!!) is
05:35:07 <ertes> whoisxy: also you may find it interesting that ($) is just 'id', and that works in haskell, because function application is left-associative
05:35:15 <ertes> id f x = (id f) x = f x
05:35:35 <ertes> ($) is just an infix version of 'id' with very low precedence, as dminuoso explained
05:38:33 <whoisxy> Okay thanks. I think the part where I was getting most stuck was of the kind of partial evaluation of one side in order to get a new type 
05:38:53 <whoisxy> but it makes sense when you take into account lazy evaluation 
05:40:04 <lyxia> it would work the same if Haskell were strict.
05:40:21 <ertes> whoisxy: this has nothing to do with laziness…  it's just precedence
05:40:46 <whoisxy> e.g :t (+) vs :t (+1)
05:41:25 <ertes> whoisxy: that's partial application…  almost
05:42:18 <ertes> (+ 1) is syntactic sugar for (\x -> x + 1)
05:43:49 <whoisxy> what about something like let map1 = map (+1); map1 [4,5,6]; map1 [3,4,5]
05:44:06 <ertes> what about it?
05:44:20 <whoisxy> would that be considered partial application?
05:44:26 <ertes> yes
05:44:41 <dminuoso> whoisxy, technically Haskell has no notion of partial application
05:44:52 <dminuoso> That is because functions are curried.
05:45:07 <ertes> whoisxy: in reality though all functions take a single argument…  there is no special mechanism to support partial application
05:45:20 <dminuoso> If you think of map as _lifting_ you will save yourself lots of headaches in the long run
05:45:24 <dminuoso> map transforms a function into another function
05:45:38 <ertes> the type notation (A -> B -> C) really just means (A -> (B -> C))
05:45:43 <dminuoso> ^-
05:45:52 <ertes> in other words: a "binary" function is really a unary function that returns a function
05:46:09 <whoisxy> I'm not sure what you mean by lifting 
05:46:15 <ertes> combine that with the left-associativity of function application:  f x y = (f x) y
05:46:24 <dminuoso> :t fmap
05:46:26 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:46:27 <whoisxy> ertes: so anything thats not a constant is a function
05:47:06 <ertes> you could think of 'f' as a "binary" function, but in reality it takes one argument and returns a function…  when you write (f x y) you're really applying 'f' to 'x', and then the resulting function to 'y'
05:47:11 <dminuoso> whoisxy, it turns some function (a -> b) into another function (f a -> f b), and that's all there is to it. it just "lifts" it into a different setting. map lifts a function into the world of lists
05:47:33 <ertes> whoisxy: i'd put it this way: all functions are values, but not all values are functions
05:48:04 <ertes> whoisxy: what dminuoso means by "lifting" is just this logic applied to 'map':
05:48:10 <ertes> map :: (a -> b) -> [a] -> [b]
05:48:13 <ertes> is the same as:
05:48:17 <ertes> map :: (a -> b) -> ([a] -> [b])
05:48:43 <ertes> you give it a function of 'a', and it returns a function of [a], so you have "lifted" a function to a list function
05:51:47 <whoisxy> ahh okay thats a bit clearer
05:51:51 <dminuoso> whoisxy, https://gist.github.com/anonymous/e67a13058daef3bb9a10d661dcd2c582
05:53:17 <dminuoso> addOne should have said inc there. *shrugs*
05:55:09 <whoisxy> what's the difference between fmap and map
05:55:21 <dminuoso> whoisxy, map is specific to lists, fmap is more general
05:55:42 <dminuoso> whoisxy, you might as use fmap instead, or even liftM :P
05:59:47 <whoisxy> the f a -> f b bit I havn't yet seen
06:00:13 <ertes> liftM is a historical mistake…  never use liftM
06:00:45 <dminuoso> whoisxy, incidentally thats why map exists -> it allows you to introduce concepts without scaring you off about some rather general concepts 
06:01:46 <dminuoso> whoisxy, in reality what map does, is take a function from one world and transfrom it into a structurally similar function in another world. fmap knows how to do this with a lot of worlds (f is a representation of that world), map just knows how to do this with the list world.
06:02:05 <whoisxy> is that used to imply they both have to belong to the same typeclass but not nessisarily be the same type ?
06:03:50 <ertes> whoisxy:
06:03:57 <ertes> :t fmap :: (a -> b) -> [a] -> [b]
06:03:59 <lambdabot> (a -> b) -> [a] -> [b]
06:04:11 <ertes> 'map' is a special case of 'fmap' in every way, including its type
06:04:19 <whoisxy> couldn't it just as easily be Functor f => (f -> f) -> f -> f
06:04:37 <ertes> whoisxy:
06:04:40 <ertes> :t map length
06:04:42 <lambdabot> Foldable t => [t a] -> [Int]
06:04:48 <ertes> well…
06:04:54 <ertes> :t map (length :: String -> Int)
06:04:56 <lambdabot> [String] -> [Int]
06:05:02 <ertes> [String] ≠ [Int]
06:05:30 <ertes> ((f -> f) -> f -> f) would imply that String = Int = [String] = [Int]
06:05:54 <whoisxy> yes I see
06:05:57 <ertes> much like you can't apply (+) to an Int and a Double, because the argument types need to be the same
06:05:59 <ertes> :t (+)
06:06:00 <lambdabot> Num a => a -> a -> a
06:06:17 <dminuoso> whoisxy, the f is that exact bit of confusion map tries to avoid. In the map world, the f is the list itself.
06:06:44 <whoisxy> I thought the that'd be handled would be (Functor a, Functor b) => (a -> b) -> a -> b
06:06:46 <ertes> whoisxy: just to give you a second example:
06:06:57 <ertes> :t fmap :: (a -> b) -> Maybe a -> Maybe b
06:06:58 <lambdabot> (a -> b) -> Maybe a -> Maybe b
06:07:07 <ertes> here f = Maybe
06:09:06 <whoisxy> ohh okay now it's coming togeather
06:11:03 <ertes> whoisxy: BTW, it's useful to know that the type notation "[a]" is really syntactic sugar for "[] a"
06:11:18 <ertes> so ([] Integer) is the type of lists of integers
06:11:27 <ertes> 'map' is just 'fmap' with f = []
06:15:22 <whoisxy> okay thanks for your help that's cleared up a lot.
06:20:25 <monoidal> Hello, I was playing with monads and i have a little question about this code: do { l <- [1,2,3]; return l }; it returns [1,2,3], as pretty much expected; but if (<-) takes the elements "out" of the monad, what is `l` after that binding? It can't be a list because the (<-) took the ekements out; so how can it restore the full list with `return` after unboxing the list elements?
06:20:44 <monoidal> Don't know if i've explained myself correctly
06:21:06 <dminuoso> monoidal, so return just produces [l]
06:22:15 <dminuoso> monoidal, that's that tiny difference between >>= and fmap. >>= knows how to "flatten" [[1], [2], [3]]
06:22:36 <monoidal> dminuoso but after doing l <- [1,2,3] how can it take all the elements out without putting them in a list? And rebuilding the list with return
06:23:13 <dminuoso> monoidal, l <- [1,2,3] is just syntax sugar for [1,2,3] >>= (\l -> ...)
06:23:22 <dminuoso> monoidal, and that's precisely what >>= knows how to do
06:24:01 <dminuoso> monoidal, so for a list it takes out every element, calls your function concatenates the result, and flattens the result
06:24:35 <monoidal> Okay, so it is like: join $ fmap (\x -> [x]) [1,2,3] ?
06:26:51 <dminuoso> monoidal, yeah.
06:26:57 <dminuoso> or uh
06:27:57 <dminuoso> :t join
06:27:59 <lambdabot> Monad m => m (m a) -> m a
06:28:27 <dminuoso> monoidal, technically you just shifted the problem around. 
06:29:15 <monoidal> dminuoso, I think I probably missed the detail of that (>>=) transfers the values of the list lazily?
06:29:38 <dminuoso> monoidal, the thing is, what `return` does is rebox, and then join knows how to.. do its thing.
06:30:19 <monoidal> in this case the same as `concat`
06:32:58 <dminuoso> monoidal, one thing that helped me was not thing of <- as "taking it out" but rather "accepting a value"
06:33:23 <dminuoso> monoidal, you get something either way. But you can either ignore it >> or accept it >>=
06:35:05 <monoidal> dminuoso, and the code lets the list untouched because >>= accepts the value, and because of the law m >>= return = m
06:35:13 <monoidal> am i right?
06:35:48 <dminuoso> monoidal, yup
06:36:50 <monoidal> okay dminuoso, thx
06:39:37 <dminuoso> monoidal, that "you get something either way" can easily be seen in putStrLn by the way, which gives you () -> so if you did a <- putStrLn "blah" you'd get a unit for free. ;p
06:42:13 <monoidal> dminuoso, I didn't understand because I had the idea of: m a -> a -> m a; but actually it does m a -> m (m a) -> m a which has more sense
06:44:17 <dminuoso> monoidal, yeah. >>= is just convenience. 
06:44:29 <dminuoso> monoidal, its quite obvious if you compare =<< with fmap, rather than >>=
06:44:39 <dminuoso> then its incredibly obvious how to do this with fmap and join
06:44:58 <dminuoso> This is also why other languages call it flatMap ;)
06:46:27 <monoidal> dminuoso, I was taught that (<-) took the value out of the monad but as (>>=) can be defined in terms of fmap and join I realised it's technically wrong :)
06:48:11 <dminuoso> monoidal, yup. Or you could go the other way around and define join in terms of bind: join m = (m >>= id)
06:48:46 <dminuoso> Or define =<< as join . fmap
06:49:12 <dminuoso> But you need either one. ;-)
06:56:49 <angerman> > fromRat (-0 :: Rational) :: Double`
06:56:52 <lambdabot>  <hint>:1:36: error:
06:56:52 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
06:56:58 <angerman> > fromRat (-0 :: Rational) :: Double
06:57:00 <lambdabot>  0.0
06:57:05 <angerman> m(
07:03:46 <pja> Did anyone answer monoidal's question?
07:03:51 <rostero> is this a silly idea?  `data AlwaysData d e = Loading d | Success d | Failure d e`.  i need to keep track of the status and data (or d) is always present, but i want to make sure you don't have an error message when status is loading or success since that dosn't make sense
07:04:54 <monoidal> pja, dminuoso did
07:05:28 <pja> monoidal: Oh good. My laptop must have gone to sleep as I missed the response!
07:05:30 <cocreature> rostero: "data LoadStatus e = Loading | Success | Failure e" and then (d, LoadStatus) would also work. which of those two is preferable is mostly a matter of taste
07:05:59 <monoidal> pja, you are curious about the answer too? :)
07:06:49 <rostero> cocreature: thanks
07:07:01 <epta> pja: logs link in the topic might be useful
07:07:08 <pja> No, just checking it had been answered! My Haskell is at that awkward point where I can answer that one easily, but plugging together higher-level concepts still doesn't come naturally...
07:07:28 <pja> epta: true!
07:18:14 <wob> GenericPretty must match -any, but the stack configuration has no specified version (latest applicable is 1.2.1)
07:18:34 <wob> how can that be a conflict?
07:19:35 <wob> I tried to add 'GenericPretty >= 1.2', but that just changes the '-any' to '>= 1.2' in the error message.
07:32:38 <juri_> so, i've got a package that i was just about to upload to hackage, but a newer version of one of my dependencies breaks another dependency... and to make matters worse, neither package is one i directry depend on.
07:33:10 <lyxia> wob: GenericPretty is not part of stackage
07:33:29 <erisco> welcome to OSS… send in a patch for the broken package
07:33:43 <lyxia> wob: you must add it in the extra-deps section of your stack.yaml
07:34:10 <juri_> but i don't know how to fix the second package, only that a newer version of the first breaks it.
07:34:42 <cocreature> you can at least open an issue
07:35:17 <cocreature> juri_: I’m curious, which packages are you talking about?
07:35:57 <juri_> template-haskell, and math-functions.
07:36:50 <cocreature> math-functions doesn’t seem to depend on template-haskell?
07:37:45 <juri_> ... but math-functions fails to compile if you use a version of template-haskell greater that 2.11.1.0.
07:38:40 <cocreature> what’s the error?
07:40:09 <dminuoso> `fmap (+1) (1,2)` how does that work and what does that do? O_o
07:40:33 <maerwald> > fmap (+1) (1,2)
07:40:36 <lambdabot>  (1,3)
07:40:39 <maerwald> there
07:40:42 <cocreature> dminuoso: the functor instance of tuples targets the second element
07:41:01 <maerwald> avoid using it, it is not intuitive
07:41:04 <dminuoso> cocreature, that's what it seemed like -> but didn't want to draw a conclusion.
07:41:07 <dminuoso> Now the obvious question:
07:41:09 <dminuoso> Why?
07:41:09 <cocreature> if you take a look at the type, that’s the only thing it can do. Functor requires something of kind *->* so you need to partially apply it
07:41:18 <dminuoso> Ohhh
07:41:36 <mniip> dminuoso, here's a more curious consequence of higher kinded types
07:41:41 <cocreature> now whether making that instance is a good idea, is a different question and one that has been debated at length
07:41:41 <mniip> > length (3, 5)
07:41:44 <lambdabot>  1
07:41:44 <maerwald> there is bimap if you want to target both elements
07:41:47 <juri_> i don't have it on hand, but it's happening on line 97. if you are really curious, i can reproduce it.
07:41:56 <maerwald> or use arrows
07:42:05 <juri_> Numeric/Sum.hs:97:1: error:
07:42:16 <mniip> cocreature, uhhhhhh
07:42:16 <cocreature> juri_: *shrug* if you’d like help, you need to show us the error. if not, you’ll have to fix it yourself :)
07:42:19 <mniip> Writer is a monad
07:42:22 <mniip> has to be a functor
07:42:33 <dminuoso> maerwald, yeah or lenses.
07:42:39 <juri_> Numeric/Sum.hs:97:1: error:
07:42:40 <juri_>     Expecting a type of the form: cxts => typ -> rep
07:42:41 <maerwald> no thanks :>
07:42:52 <cocreature> mniip: Writer is a newtype, that doesn’t require an instance for tuples
07:43:02 <marvin2> why is length (3, 5) => 1?
07:43:11 <mniip> Writer is a synonym for WriterT
07:43:22 <mniip> having a (,) instance is good for the same reasons as (->)
07:43:23 <cocreature> which is a newtype
07:43:38 <dminuoso> :t length
07:43:39 <lambdabot> Foldable t => t a -> Int
07:43:52 <mniip> marvin2, length :: Foldable f => f a -> Int
07:43:58 <cocreature> I’m not even saying that the instance shouldn’t exist, I just said that there has been a fair amount of heated debate on the subject
07:44:04 <mniip> it has to return the number of the 'a's
07:44:13 <cocreature> juri_: post the full error message in an lpaste
07:44:26 <juri_> that is the full error message.
07:44:36 <mniip> or rather, here's a more convincing argument
07:44:44 <dminuoso> cocreature, the more I think about it the less intuitive that implementation becomes. But it's good enough to know that it exists.
07:44:50 <mniip> length = foldr (\_ x -> x + 1) 0
07:45:17 <mniip> foldr :: Foldable f => (a -> b -> b) -> b -> f a -> b
07:45:47 <mniip> with 'f ~ ((,) w)' the implementation is kind of the only thing that's possible
07:45:58 <cocreature> dminuoso: instead of "fmap" you can also use "second" from Bifunctor which makes it significantly more clear what the code is doing
07:46:13 <juri_> someone else has the same error, at https://hackage.haskell.org/package/HsHTSLib-1.3.2.2/reports/2
07:46:14 <cocreature> and it also gives you "first" for mapping over the first element of a tuple
07:46:23 <maerwald> it's a stupid thing to abstract
07:46:29 <marvin2> mniip ok makes sense
07:46:40 <maerwald> > (\(_, x) -> x + 1) (1,2)
07:46:42 <lambdabot>  3
07:46:44 <maerwald> good enough, move on
07:47:12 <inhortte> Has anyone seen this?
07:47:12 <inhortte>     ghc: panic! (the 'impossible' happened)                         
07:47:12 <inhortte>       (GHC version 8.0.2 for x86_64-unknown-linux):                 
07:47:12 <inhortte>         Loading temp shared object failed: /tmp/ghc44867_0/libghc_89.so: failed to map segment from shared object: Operation not permitted
07:47:12 <inhortte> --  While building package foundation-0.0.13 using:                 
07:47:12 <inhortte>       /home/polaris/.stack/setup-exe-cache/x86_64-linux-nopie/Cabal-simple_mPHDZzAJ_1.24.2.0_ghc-8.0.2 --builddir=.stack-work/dist/x86_64-linux-nopie/Cabal-1.24.2.0 build --ghc-options " -ddump-hi -ddump-to-file"
07:47:38 <maerwald> @paste
07:47:38 <lambdabot> Haskell pastebin: http://lpaste.net/
07:47:41 <cocreature> juri_: looks like the error is coming from vector-th-unbox, I’ll take a closer look
07:47:42 <maerwald> don't spam
07:47:55 <inhortte> I can't seem to find a solution anywhere. I'm trying to build "generics-sop-0.3.1.0".
07:48:02 <inhortte> maerwald: sorry. I will not again.
07:49:07 <juri_> cocreature: thanks.
07:50:15 <dminuoso> cocreature, And here I sat thinking "the CT basics I picked up ought to be enough to navigate through haskell" - and bifunctors were where I gave up because it seemed to abstract to be useful.
07:51:58 <kosmikus> inhortte: not really an answer to your question (and no, I haven't seen this before); but generics-sop should not depend on foundation
07:53:18 <juri_> cocreature: if you're attacking that bug, it's worth noting that i'm having it on 8.0.1 in debian stable, but the report i just sent you is on 8.0.2.
07:53:57 <cocreature> juri_: I can’t reproduce that bug using 8.2.1 and 8.0.2. does the problem arise if you try to compile math-functions on its own?
07:55:14 <inhortte> kosmikus: It dies after step 13 (of 14) and gives me that error. It builds fine on my local machine, but I have a debian server elsewhere where this is happening.
07:55:41 <inhortte> kosmikus: but thanks.
07:55:53 <cocreature> juri_: and which version of TH are you using? the version of TH is coupled to the version of GHC so I doubt that you are using a newly released one
08:00:31 <juri_> ccreature: let me reproduce, and drop you my insalled packages.
08:13:44 <juri_> cocreature: my package is http://kalli1.faikvm.com/ImplicitCAD/Stable , my packages after a build fail are http://lpaste.net/358523, you have the error, and adding the line '        template-haskell == 2.11.1.0,' into my build-depends fixes it.
08:15:11 <juri_> that list was generated immediately after rm -rf ~/.cabal ~/.ghc
08:21:53 <cocreature> juri_: if it works with 2.11.1.0, I don’t see the problem? using a new minor release seems like a pretty reasonable solution
08:22:10 <cocreature> I thought it failed with a newer version
08:22:37 <cocreature> oh nvm you’re using 2.12, I got confused because it’s listed twice in the output
08:26:25 <Limeth_> Is there a non-partial function like (!!) in the standard library?
08:27:52 <Limeth_> I am looking for one with type `[a] -> Int -> Maybe a` instead of `[a] -> Int -> a`
08:32:07 <mauke> @hoogle [a] -> Int -> Maybe a
08:32:07 <lambdabot> Safe atMay :: [a] -> Int -> Maybe a
08:32:07 <lambdabot> Agda.Utils.List (!!!) :: [a] -> Int -> Maybe a
08:32:07 <lambdabot> CLaSH.Util indexMaybe :: [a] -> Int -> Maybe a
08:33:32 <lavalike> @type (listToMaybe .) . drop
08:33:33 <lambdabot> Int -> [a] -> Maybe a
08:34:43 <lavalike> @type flip $ (listToMaybe .) . drop -- :P
08:34:45 <lambdabot> [a] -> Int -> Maybe a
08:36:48 <lavalike> @type (listToMaybe .) . flip drop
08:36:49 <lambdabot> [a] -> Int -> Maybe a
08:38:27 <cocreature> juri_: sorry I still can’t reproduce this. I’m not sure how you even managed to convince cabal to build with template-haskell-2.12 if you’re using 8.0.1. when I try to do that using 8.0.2, cabal complains because template-haskell can’t be upgraded. I would recommend that you upgrade to 8.0.2 (upgrading to minor releases is generally a very good idea) and try again
08:39:09 <cocreature> juri_: also try if you can reproduce this if you just build math-functions instead of the plethora of dependencies pulled in by your package
08:39:10 <juri_> 8.0.1 is what's shipped by debian stable.
08:39:18 <juri_> sure.
08:39:23 <cocreature> that doesn’t change my recommendation :)
08:39:42 <cocreature> if debian stable doesn’t upgrade to bugfix releases then you shouldn’t get your GHC that way
08:40:06 <cocreature> there are a fair amount of bugs that have been fixed in 8.0.2 and there is nothing more annoying than trying to hunt down a problem only to discovre that it has already been fixed
08:41:18 * juri_ nods.
08:43:59 <Gurkenglas> Does the hip library allow me to "convolve" an image in a way that uses not a linear combination, but some other function, of each point's surroundings?
08:44:16 <juri_> yeah, debian stable is always a mess to support.
08:45:20 <Gurkenglas> at the moment I'm reduced to http://lpaste.net/9045949931449221120
08:45:23 <juri_> trying a fresh math-functions build now.
08:47:10 <lavalike> Gurkenglas: this is the definition http://hackage.haskell.org/package/hip-1.5.3.0/docs/src/Graphics-Image-Processing-Convolution.html#convolve
08:49:00 <juri_> .. crud. it just builds on it's own.
08:49:09 <juri_> no wonder you can't reproduce.
08:49:33 <cocreature> something is very weird here
08:49:54 <Gurkenglas> https://hackage.haskell.org/package/hip-1.5.3.0/docs/Graphics-Image-Processing.html#v:convolve uses the aforementioned linear combination. I'm looking for another way that doesn't necessitate me actually shuffling around the coordinates.
08:50:51 <lavalike> Gurkenglas: what would you want to write?
08:51:33 <Liskni_si> juri_: shouldn't be too much hassle to just pull ghc from testing or unstable
08:51:51 <Gurkenglas> lavalike, http://lpaste.net/9045949931449221120 ought to be as short as possible
08:52:28 <juri_> cocreature: http://lpaste.net/
08:52:41 <juri_> that's math-functions built...
08:53:27 <lavalike> Gurkenglas: maybe using correlate directly, just like gaussian does
08:54:22 <lavalike> if you look at its implementation, it does not get down to coordinates
09:09:21 <cocreature> juri_: that link is just linking to the main lpaste site not your specific paste
09:09:39 <juri_> gah. sorry.
09:10:57 <juri_> http://lpaste.net/358525
09:15:20 <Gurkenglas> correlate does handle coordinates, but that's okay, as long as I don't have to. correlate and gaussian use a linear combination of the surroundings though, seeing as how correlate takes a kernel image and not a kernel function.
09:15:26 <Gurkenglas> *lavalike
09:15:53 <lavalike> right, that I see it does
09:16:46 <lavalike> I wonder if you can steal the pattern of creating the image too
09:18:15 <int-e> @bot
09:18:22 <lambdabot> :)
09:26:01 <x-gosda> what is the first library that you have mastered after Prelude?
09:38:50 <juri_> http://lpaste.net/358527
09:39:02 <juri_> ^-- my packages, after a successful build.
09:40:43 <juri_> reproduced the issue on my newer box, running GHC 8.0.2.
09:43:01 <ertes> it's that time again, isn't it…  time for my quarterly library survey: are there any command line UI library alternatives to optparse-applicative?  perhaps a library that also integrates environment variables and configuration files
09:59:01 <ertes> data Some (* -> Constraint) where Some :: c a => a -> Some c  -- i remember this being predefined somewhere…  where was it?
09:59:10 <ertes> err
09:59:18 <ertes> data Some :: (* -> Constraint) -> * where Some :: c a => a -> Some c  -- i remember this being predefined somewhere…  where was it?
09:59:32 <hpc> Exists, i think
10:00:19 <lavalike> ertes: https://github.com/pcapriotti/optparse-applicative/issues/118
10:00:51 <ertes> i found the "exists" package, but looks like the author abandoned it
10:01:56 <ertes> lavalike: well, open since dec 2014 =)
10:02:29 <ertes> also i can't really explain why, but i don't like optparse-applicative
10:02:49 <ertes> i find myself happier just using System.Console.GetOpt these days
10:05:47 <paolino> hi, are there plans for partially applied type synonyms especially to be use  in Constraint kind 
10:06:43 <paolino> as it is now it seems I have to use empty class + empty instance to mimic that, is there another way ?
10:08:27 <juri_> cocreature: you still around, digging into that bug? :)
10:11:00 <paolino> example: http://lpaste.net/358528
10:15:33 <lyxia> paolino: https://github.com/ghc-proposals/ghc-proposals/pull/52
10:31:43 <cocreature> juri_: sry no, got busy with other stuff and I still can’t reproduce anything even if I try to built your package
10:32:15 <cocreature> juri_: I also have no idea how you even manage to use template-haskell-2.12 with GHC 8.0. TH is not upgradable
10:37:12 <AlienIndustries_> Library question. Is it wiser to use an xml spec file for the generation of a bindings library or the header? Specifically the Vulkan Graphics API
10:38:35 <lavalike> the xml seems easier to parse, I guess
10:39:08 <cocreature> that said, there are existing vulkan bindings so I would recommend to try and improve those instead of making a new package
10:40:58 <AlienIndustries_> One of the two on Hackage is not really anything yet. The other does do xml generation but I am getting a failure on HS.Type in LTS-9.4. HS.Type has kind *-> * expected Type
10:41:44 <cocreature> please show us the full error message
10:41:54 <AlienIndustries_> Let me pull it up.
10:44:51 <AlienIndustries_> Paste bin the best way to share? New to IRC
10:45:00 <cocreature> @where lpaste
10:45:00 <lambdabot> http://lpaste.net/
10:45:35 <erisco> what keeps lpaste running?
10:45:44 <sm> "In this rare photography we can see dcoutts (top) while he invokes a nix-style build on cabal (below)" -- http://fgaz.me/posts/2017-09-13-hsoc-cabal-new-build-status-update-1/ :)
10:46:00 <erisco> do they need money? because lpaste is unresponsive often
10:46:15 <AlienIndustries_> Speaking of which gateway timeout. lol
10:46:34 <cocreature> heh, then use some other pastebin service
10:46:49 <cocreature> erisco: it’s chris done’s project. no idea if money, man power or something else is the problem
10:46:51 <erisco> suggests to me they are using some crowded, crappy shared host
10:46:58 <dcoutts> sm: :-)
10:49:03 * JuanDaugherty looked at regulat pastebin and it seemed to be thriving as the main thing in its niche
10:49:11 <JuanDaugherty> *regular
10:50:48 <erisco> but lpaste is nice and simple and doesn't have ads… should be able to get some money together for hosting it
10:51:36 <cocreature> erisco: maybe drop chris an email, he was looking for people to take over his open source projects a while back
10:51:47 <erisco> I am doing that as we type ;)
10:51:54 <cocreature> nice :)
10:52:21 <AlienIndustries_> https://pastebin.com/5tu5Ks4e
10:52:23 <cocreature> I would definitely throw a few bucks at whoever takes care of it
10:53:26 <JuanDaugherty> that's the thing. nobody wants no damn tip money, unless they're indigent or whatever
10:53:40 <cocreature> AlienIndustries_: which command did you ran to get this error?
10:54:02 <AlienIndustries_> This was a from a stack test, stack build gives the same
10:54:40 <cocreature> in which repository did you ran those commands?
10:55:15 <sm> darcs hub takes (and receives) donations, and would probably do better if I were organised about it
10:55:26 <AlienIndustries_> From the package directory on my local system.
10:55:46 <cocreature> AlienIndustries_: what’s the content of your cabal file?
10:56:13 <sm> I think lpaste could easily cover its hosting costs in donations, probably not ops time though
10:56:23 <AlienIndustries_> Let me point you at the github for this.
10:56:42 <cocreature> AlienIndustries_: basically what I’m trying to figure out is which package are you actually building?
10:56:53 <sm> but even a little regular revenue is a nice thank you
10:57:38 <cocreature> because the most popular vulkan bindings are https://github.com/expipiplus1/vulkan afaik and that doesn’t have a TypeConverter module afaict
10:57:46 <stevenxl> 1:57 PM <stevenxl> Hi folks. I am trying to contribute to an open source Haskell project, and I picked an issue marked "beginner" (https://github.com/parsonsmatt/servant-persistent/issues/17), where I need to integrate a logging library called katip. Anyway, I must be pre-beginner because i am finding the task challenging.
10:58:25 <AlienIndustries_> That is the package I am working on.
10:58:42 <AlienIndustries_> It is in the generate section 
10:59:25 <stevenxl> I have this code up (https://github.com/StevenXL/servant-persistent/blob/add-katip/app/Main.hs) but I am getting an error that `defaultScribeSettings` is not defined, even though I am importing the `Katip` module, and I thought that that module exports that value.
10:59:45 <stevenxl> https://hackage.haskell.org/package/katip-0.5.0.1/docs/Katip.html#v:defaultScribeSettings
11:00:01 <cocreature> AlienIndustries_: ah so you are hacking on the package itself and not just building it as a dependency
11:00:39 <AlienIndustries_> correct. Bringing it up to the current release of Vulkan. Just swapping out the vk spec file had issues.
11:01:21 <AlienIndustries_> Im also using LTS-9.4 which had changes from the original ghc setup they had.
11:01:41 <sm> stevenxl: check you are using the expected version of the package - perhaps the api changed
11:01:45 <cocreature> AlienIndustries_: did you change the bounds on haskell-src-exts?
11:02:10 <AlienIndustries_> Change my bounds on all packages to match those included in LTS-9.4
11:02:18 <Cale> lpsmith: Hey, I just made a quasiquoter which basically lets you do  uncurry query [sqlv| SELECT * FROM 'Book' b WHERE title = ?title AND author = ?author |]  and it basically is equivalent to  query [sql| SELECT * FROM 'Book' b WHERE title = ? AND author = ? |] (title, author) -- still have to test it, but it should be a nice improvement for queries with dozens of parameters :)
11:03:15 <stevenxl> sm: What's the idiomatic way to check what version I have locally? I can go into my .stack-work/logs but I don't know if that's the right way
11:03:27 <cocreature> AlienIndustries_: ah now we’re getting closer to the root cause here :) haskell-src-exts changed the API in 1.18
11:03:28 <sm> I do: stack exec -- ghc-pkg list katip
11:03:43 <Cale> lpsmith: If you'd like I can give you the code and maybe we can add it to postgresql-simple :)
11:04:26 <AlienIndustries_> Yep. I was trying to find where the change to the Type happened between the source exts package so I can point to the correct function.
11:05:04 <stevenxl> sm: ah -thanks. I can see that I was using 0.2.0.0 while the docs I was reading is for 0.5.0.1
11:05:33 <stevenxl> Because this is a stack project, the reason why I am getting that version even though I didn't specify a version in the cabal file is because it's the version that's in the resolve (stack.yaml)?
11:05:48 <sm> right. Perhaps you could specify a newer resolver
11:05:57 <sm> https://www.stackage.org/package/katip shows what version is in recent resolvers
11:06:29 <stevenxl> Yea I'll try and update the resolver, and if something breaks, well, ghc will tell me. 
11:06:29 <stevenxl> :-)
11:06:44 <sm> or, since your code depends on that function introduced in 0.5.x, probably specifying the lower bound in your cabal file is the correct fix
11:06:49 <sm> then stack will know what to do
11:06:57 <sm> and so will other tools
11:07:05 <stevenxl> Oh - that's even better.  I'll go ahead and do that instead. 
11:07:07 <stevenxl> Thank you. 
11:07:17 <sm> np
11:07:25 <stevenxl> Appreciate the help. Wish I could continue workign on this but I have to spend tiem with the sig fig since I am flying out later
11:07:26 <stevenxl> ;0
11:07:28 <stevenxl> thanks!
11:07:58 <cocreature> AlienIndustries_: you can probably just change "HS.Type" to "HS.Type ()"
11:10:45 <AlienIndustries_> Ill give it a try. Thanks for the guidance.
11:11:50 <cocreature> AlienIndustries_: in general, most of the AST now takes a parameter representing source locations. if you don’t care about that (which given that they aren’t used currently) you can just use ()
11:19:29 <mpickering> Is cassava the library people still use for parsing csvs?
11:20:54 <AlienIndustries_> Gotta run for a bit but thanks for the help cocreature. The () addition did not resolve the issue so I will have to do some digging later. Thanks again.
11:31:13 <maerwald> nice, ghc-8.2.1 uses integer-gmp-1.0.1.0, but hackage does not have that version
11:31:16 <maerwald> I hate ghc updates
11:44:20 <sm> that would normally come with your ghc-8.2.1 then ?
11:45:38 <Myrl-saki> I can't use getProtocolByName when copying to a different machine
11:45:40 <maerwald> I need it as a seperate package
11:46:11 <Myrl-saki> someone
11:46:13 <Myrl-saki> save me
11:47:05 <Myrl-saki> I don't wanna use docker or anything.
11:52:26 <dmwit_> I wrote my first rewrite rule ever. https://www.reddit.com/r/haskell/comments/70ixk0/code_challenge_bad_id/dn3xijg/
12:03:15 <ertes> mpickering: i use it
12:28:07 <dminuoso> Been following some lectures on CT, and the lecturer implies that the monad is actually the kleisli arrow related to the type m. Is there any truth to that?
12:28:58 <hpc> https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Arrow.html#t:Kleisli - i don't know about saying it "is" that
12:29:01 <hpc> but the relationship exists
12:30:19 <dminuoso> hpc, I mean it does sound tons more elegant when describing the associativity laws with >=> over >>=
12:31:54 <hpc> it is
12:34:58 <dminuoso> hpc, https://wiki.haskell.org/Arrow_tutorial seems to imply that an the arrow a -> m b is exactly then a kleisli arrow, if m is a Monad
12:35:17 <hpc> yeah
12:35:27 <dminuoso> So it seems a slip of the tongue to call the kleisli arrow the monad itself
12:35:45 <hpc> you're right on the rest of it though
12:37:30 <c_wraith> dminuoso: by the way, (Kleisli mº only needs to be a Category for m to be a monad.  It doesn't need the rest of the Arrow stuff.
12:37:42 <c_wraith> err, (Kleisli m)
13:34:55 <maerwald> where does stack host packages?
13:36:47 <dminuoso> c_wraith, ah so that's just another way of describing the associativity and identity laws
13:37:05 <c_wraith> dminuoso: yes.
13:39:33 <sm> maerwald: IIRC it has a cache of hackage on amazon
13:39:57 <maerwald> I want to download https://www.stackage.org/nightly-2017-09-17/package/integer-gmp-1.0.1.0 but I don't know how
13:39:58 <sm> maybe stack issue tracker more
13:40:13 <sm> um.. I accidentally the.. never mind
13:41:17 <sm> doesn't stack install integer-gmp-1.0.1.0 do it ?
13:41:25 <maerwald> I don't have or use stack
13:41:34 <maerwald> I need the url
13:42:07 <sm> I humbly beg your pardon for suggesting that you did :)
13:42:24 <maerwald> I pardon you!
13:45:12 <sm> I think stack gets that by unpacking the ghc 8.2 tarball or whatever
13:45:37 <maerwald> annoying
13:46:56 <sm> are you trying to use that newer integer-gmp with older ghc ?
13:47:11 <maerwald> no, I am packaging ghc and the libraries need to be explicit to the package manager
13:48:14 <sm> ok.. maybe #ghc will help
13:48:21 <maerwald> already tried
13:48:59 <sm> bah. stupid haskell
13:51:01 <Liskni_si> maerwald: http://hackage.fpcomplete.com/package/integer-gmp-1.0.0.1.tar.gz
13:51:09 <maerwald> that's the old version
13:51:24 <maerwald> ghc-8.2.1 uses integer-gmp-1.0.1.0
13:51:30 <Liskni_si> oh, sorry, I just did stack -v unpack integer-gmp and pasted the url
13:51:48 <sm> look for discussion of this from past packaging events ? Otherwise you could ping one of the wizards like bgamari
13:52:19 <maerwald> in the past I waited 4 weeks until someone fixed it
13:52:35 <Liskni_si> then I guess stack unpack with nightly will fail as well :-)
13:54:43 <Liskni_si> yeah
13:54:51 <Liskni_si> $ stack --resolver nightly-2017-09-17 unpack integer-gmp
13:54:55 <Liskni_si> Updating package index Hackage (mirrored at https://s3.amazonaws.com/hackage.fpcomplete.com/) ...The following package identifiers were not found in your indices: integer-gmp-1.0.1.0
14:17:08 <maerwald> nice, people update .cabal files of packages in-place without bumping too
14:18:01 <maerwald> https://hackage.haskell.org/package/echo
14:18:11 <maerwald> says process <1.7, but the tarball still does <1.5
14:20:07 <maerwald> how can people even build cabal-install? the dep-chain is broken
14:30:12 <mniip> maerwald, last time I had to do it I had to patch the dependencies on the bootstrap script
14:31:40 <maerwald> Every ghc release is basically a nightmare, because not even the most important packages build. And that after how many months?
14:33:43 <knupfer> maerwald: ghc 8.2 with nix works like a charm
14:33:55 <maerwald> good for you :>
14:34:21 <knupfer> and potentially good for you :>
14:34:27 <maerwald> no
14:35:24 <knupfer> n8
14:35:49 <benzrf> just succumb already
14:35:54 <benzrf> give in to the nix collective
14:35:57 <benzrf> hope this helps
14:36:07 <maerwald> I prefer correctly working distros
14:36:45 <hydraz> great thing nix is a package manager
14:37:06 <maerwald> gl using it without nixpkgs
14:37:17 <hydraz> great thing nixpkgs is a package collection..?
14:37:41 <maerwald> *yawn*
14:46:00 <maerwald> next package monkey-patching dependency constraints without a bump
15:34:35 <orzo> Anybody have any advise on laying out module names for a project?
15:35:24 <orzo> i've been following the haskell library convention of Data/Control/Crypto/ top levels
15:35:46 <orzo> but i wonder if it wouldn't make more sense to name modules based on where they occur in the dependency graph
15:36:07 <orzo> so that you could import the bottom layer with a single import statement
15:36:15 <orzo> or the next layer
15:36:51 <orzo> So I would classify top-levels by layer rather than semantic scope
15:50:34 <derek_c> Is there a meaningful difference between a program interpreted in ghci and one compiled via ghc?
15:50:50 <derek_c> in terms of performance
15:51:02 <isaac__> I'm pretty sure there is
15:51:10 <geekosaur> define 'meaningful'
15:51:28 <derek_c> it's a number crunching program of some sort
15:51:31 <geekosaur> ghci compiles to interpreted bytecode instead of native code. ghci doesn't support optimization at all.
15:51:36 <derek_c> fairly memory/cpu intensive
15:51:38 <derek_c> I see
15:51:42 <derek_c> thanks
15:51:50 <hpc> geekosaur: if you're a nihilist does haskell perform better? :D
15:53:53 <dminuoso> derek_c, you could have just rent two apartments, set up a bitcoin miner in each - and have the implementation run in ghci in one and ghc in the other. And then look at the electricity bill at the end of the year.
15:54:01 <dminuoso> Then you would have known.
15:54:25 <dminuoso> Gives you all information such as speed and efficiency.
16:03:22 <mibaz_1> boom easy profiling
16:03:54 <mibaz_1> check which one can factor the first 10^23 primes first
16:06:32 <kadoban> That's a lot of primes
16:23:30 <orzo> When working with Maybe, is mplus or <|> prefered?
16:23:43 <orzo> or yet another alternative to that
16:23:51 <erisco> ba dum tsh
16:23:58 <orzo> i just want a sensible default to reach for
16:24:25 <erisco> whichever one looks prettier to you
16:24:43 <orzo> they both require an import over the Prelude
16:24:46 <erisco> I'd go for the least constrained one, which is <|>
16:24:52 <orzo> any prelude option?
16:24:54 <systemfault> :t (<|>)
16:24:55 <lambdabot> Alternative f => f a -> f a -> f a
16:25:23 <erisco> get used to imports
16:25:27 <orzo> lol
16:26:27 <orzo> there should be a standardized big prelude
16:26:44 <erisco> why do you want everything in Prelude?
16:26:53 <orzo> for quickie scripts
16:27:13 <erisco> there are custom Preludes on Hackage
16:27:13 <orzo> or iduno, just because i use certain theings so damned offten
16:27:36 <orzo> like Control.Monad. Data.List, Data.Maybe
16:28:29 <orzo> those things are so common that newbies should avoid naming functions that look like their exports
16:29:08 <orzo> they might as well be prelude 
16:29:09 <jared-w> orzo: that type of thinking is common in C and Python but I really don't like the idea of big standard preludes
16:29:11 <erisco> import qualified
16:29:23 <jared-w> "prelude is where code goes to die" is something I find pretty true
16:30:23 <jared-w> orzo: however if you /always/ find yourself using a ton of stuff, it's not too difficult to create a custom prelude that imports tons of stuff for you everywhere. Some stack templates even provide something like that out of the box
16:30:57 <orzo> then my projects would have a dependency though that could annoy someone when i share
16:31:50 <orzo> if everyone did that, there'd be a zillion prelude packages
16:33:03 <erisco> organising all your imports is fun, though, like model railroads
16:33:04 <jared-w> Well it wouldn't be a custom prelude package, just a module inside your project that re-exports a ton of stuff
16:33:44 <jared-w> MyProject.Imports or something like that
16:33:56 <erisco> a third of a page for extensions, one page for exports, one page for imports… a good start to a Haskell module
16:34:41 <orzo> can you re-export qualified 'as' imports so they are pre-qualified?
16:36:08 <geekosaur> no
16:37:14 <erisco> then the rest of the file has a comment and pragma to code ratio of 10:1
16:38:11 <jared-w> {- INLINE -} {- NOINLINE -} {- BLACK MAGIC GOES HERE -}
16:38:36 <erisco> such an elegant language
16:38:51 <orzo> heh
16:39:10 <monochrom> s/BLACK MAGIC/REWRITE RULE/
16:39:30 <orzo> the number of extensions should ultimately go down when new standards are published, right?
16:39:45 <monochrom> OTOH, I agree that it looks like black magic to most users.
16:39:47 <orzo> some common ones may go into the core language
16:40:09 <monochrom> No, because new extensions happen faster.
16:40:54 <jared-w> orzo: well what will happen is the number of extensions used right now will go down quite a bit when the mythical 'haskell 2020" happens
16:41:07 <monochrom> Every decade, 10 new extensions are created, and 2 previous extensions are absorbed into an updated standard.
16:41:18 <jared-w> because things like GADTs, Dependent Types, and all the other fun whiz-bangs will be put into the language
16:41:19 <orzo> heh
16:41:25 <jared-w> On the other hand, what monochrom said :p
16:41:38 <erisco> dependent types? where?
16:42:03 <jared-w> They're slated for like 2019 or something
16:42:41 <erisco> a feature that comes out in 2019 they'll put into the 2020 standard?
16:43:06 <jared-w> It's a feature that gets rid of and obsoletes like 15 pragmas we have currently lol
16:43:28 <jared-w> Plus it's a fundamental change to how Haskell works in general. The core language itself will change quite a bit as well
16:44:09 <mibaz_1> cannot wait
16:44:40 <jared-w> I wouldn't be surprised if it made it into the 2020 standard at all
16:44:49 <orzo> ScopedTypeVariables shoudl be standard for sure
16:45:06 <orzo> it's hard to do much wtihout it
16:45:06 <jared-w> (although, let's be honest, none of the standard stuff really matters a whole lot because GHC is the only compiler in town for Haskell right now)
16:46:15 <orzo> well, there's a lot of versions of ghc in use at any particular time.  Extensions/Standards still play a role
16:47:56 <jared-w> True
16:48:31 <jared-w> Man... I think the most annoying thing about searching for a job is the fact that nobody really wants to hire someone part time
16:49:06 <orzo> split half your shift under the table
16:49:27 <orzo> surely you know somebody who looks like you and has similar skills
16:50:00 <erisco> if both you and your double wear groucho glasses they won't know
16:53:21 <jared-w> Hmm. I already wear glasses...
16:53:26 <jared-w> It could work
17:56:46 <orzo> Typically, when ghc tells me to use RankNTypes or Rank2Types, I use RankNTypes. Is there ever a reason to use Rank2Types instead?
18:00:45 <geekosaur> Rank2Types is for backward compatibility
18:01:13 <geekosaur> currently Rank2Types just turns on RankNTypes.
18:01:26 <centril> Is it possible to put a class constraint on an associated type?
18:01:44 <geekosaur> just list it in the class constraints, yes
18:02:43 <centril> as in: class MyClass self where type Assoc self :: k;  and ensure that forall a. MyClass a => Constraint (Assoc self)
18:03:02 <centril> geekosaur: what's the syntax for that?
18:04:10 <geekosaur> is that a typo?
18:04:40 <lyxia> centril: class Constraint (Assoc self) => MyClass self where ...
18:04:54 <geekosaur> if by 'self' in that example you meant 'a' then ^
18:04:56 <centril> lyxia: oh, right
18:05:01 <centril> geekosaur: yep, typo
18:05:02 <geekosaur> if not, hat constraint is illegal regardless
18:05:22 <centril> lyxia: cheers
18:48:42 <jle`> what's the best way to cross-compile for OSX?  is it just to acquire a physical machine?
18:51:32 <JuanDaugherty> well you want to test don't you?
18:52:04 <JuanDaugherty> i think in practice most people just set up a mac build
18:53:31 <jle`> (does that involve getting a physical machine?)
18:53:41 <JuanDaugherty> practically yes
18:53:51 <jle`> i thought it would be as easy as spinning up an osx image on the cloud but there isn't any nice options
18:54:03 <jle`> (isn't? aren't?)
18:54:06 <glguy> travis can do mac builds
18:54:10 <JuanDaugherty> in principle you could waste a lot of time trying to defeat apple's protections but it's not really worth it
18:54:24 <JuanDaugherty> you can just get a used mac for a small sum
18:54:26 <jle`> yeah, travis can do mac builds which is why i thought it would be easy to just spin up an osx image
18:54:42 <jle`> i suppose i could figure out a way to make travis build my things for me and export the results
18:55:50 <JuanDaugherty> last I knew, and may be out of date, "spinning up an osx image" outside of a licensed apple product that would do the spinning up was a major hassle
18:56:02 <JuanDaugherty> but that was as much as 5 ya
18:57:02 <JuanDaugherty> they do all kinds of crippling with their bios and interlocking with hardware ids
18:57:26 <JuanDaugherty> should have a vm'able product by now though
18:58:14 <JuanDaugherty> unless I'm mistaken ghc users on mac is not huge, I have but never use
18:58:38 <jle`> hm thanks
18:58:39 <zoid1> Well there are some mac hosting providers - what they do is provide you access to a dedicated apple machine
18:58:40 <JuanDaugherty> substantial, but prolly still less than windows
18:59:01 <jle`> my school lets me temporarily rent macbooks so i can just go to school and cross compile there for free
18:59:11 <jle`> but i have to set up brew/download everything again every time, heh
18:59:11 <glguy> You can run macOS in VMWare, but you're supposed to run it on mac hardware when you do it
18:59:37 <jle`> is that a 'supposed to' as in how you're supposed to only download ROMs of games you already own?
19:02:22 <JuanDaugherty> if you can get to a terminal prompt, you're probably OK. But they'd likely trip you up on OS boot.
19:04:10 <jared-w> jle`: as far as I'm aware, pretty much. I haven't actually ever done it but I can't imagine there's a magical way to break it if you're not on mac hardware
19:05:24 <jared-w> But yeah the easiest way is probably to find an on demand AWS-like place that lets you spin up an OSX image on their mac servers. I'm pretty sure those places exist...
19:07:38 <JuanDaugherty> mac stuff is just directories, so you could put on a stick and then attach that to the macbook
19:08:01 <JuanDaugherty> i.e. setup the stick
19:08:41 <JuanDaugherty> copy onto macbook when using if it's too slow and the macbook has a ssd
19:11:45 <koz_> Could someone help me remove these type defaulting warnings? http://lpaste.net/358536
19:12:32 <pacak> Protolude.... Ugh.
19:13:00 <JuanDaugherty> that's a thing?
19:13:18 <JuanDaugherty> i thought it was ihr experiment/whatever
19:15:03 <jared-w> Well it's a thing just like any other prelude alternative
19:15:41 <jared-w> koz_: type defaulting warnings can be prevented by either a) turning the warning off. b) picking a type in the case of ambiguity
19:16:02 <jared-w> String literals with OverloadedStrings are ambiguous; Number literals are always ambiguous
19:16:07 <geekosaur> ^
19:16:07 <geekosaur> and that's the only way here
19:16:15 <pacak> jared-w: Basically saying "It's not really Haskell, have fun looking for usual functions and types".
19:16:32 <geekosaur> if you do not have anything else fixing their types, you either explicitly specify or you turn off the defaulting warning
19:16:57 <geekosaur> (you only need to attach a type annotation to one of each, not all of them)
19:17:25 <jared-w> In this particular case ([1..4] :: Integer) and (["a","b","c"] :: [[Char]]) will work
19:17:57 <jared-w> Also are you sure you want a list of lists for the ["a","b","c"]? Seems like you want ['a'..'c'] instead or "abc" or ['a','b','c']
19:18:54 <geekosaur> ...and, sadly for you, this is kinda when you *want* those warnings: if you're doing a lot of string processing, you'd usually like to make sure strings default to Text instead of String.
19:19:00 <jared-w> ([1..4] :: [Integer]), I mean
19:19:46 <jared-w> especially when using Protolude which assumes you always want Text and most of their stuff works with isString and implicitly really wants Text instead of [Char]
19:34:48 <koz_> jared-w and geekosaur: Thanks, will try.
19:38:26 <koz_> Yep, that works fine, yay!
20:07:34 <slevin> is there anyone using arch linux? if so, any experience with converting to using stack? not sure if i should remove my haskell libraries installed through pacman (local/haskell-foo)
20:08:10 <kadoban> slevin: Recent stack shouldn't care about them AFAIK
20:09:13 <jared-w> Stack has never cared about how arch linux works its packages. The ony thing that changed with Arch is you want to install stack statically if at all possible and to avoid using the package manager for any haskell libraries if at all possible since it's all dynamic and the dynamic linking screws with Haskell
20:09:51 <kadoban> It used to care a bit about globally installed packages I think *way* long ago. Could be wrong.
20:11:55 <slevin> jared-w: so maybe i should remove all arch packages, install stack-static, and use that? would like to avoid having several installations 
20:12:16 <jared-w> Yeah that's generally the route I'd go with
20:12:25 <jared-w> If you use XMonad as your window manager things get a little trickier
20:13:12 <slevin> great! thanks for the help 
20:14:49 <slevin> jared-w:  just removed around 120 arch packages.. i like stack already
20:15:27 <jle`> koz_: these days you can do a lot using TypeApplications
20:15:46 <jared-w> hah nice, you're welcome. The Shellshock and pandoc packages also pull in everything from haskell so if you have those installed you can install the static versions instead for a huge amount of space saving.
20:30:01 <evelone> Hey !
20:31:21 <evelone> I can't seem to get OpenGlRaw to compile..
20:31:30 <evelone> It compiles fine on Windows
20:31:38 <evelone> but on my manjaro install, it doesn't
20:32:25 <evelone> http://lpaste.net/57698290006753280
20:34:19 <geekosaur> what version of stack?
20:35:34 <evelone> 1.3.2
20:36:05 <evelone> Version 1.3.2, Git revision 3f675146590da4f3edf768b89355f798229da2a5 (4395 commits) x86_64 hpack-0.15.0
20:36:06 <geekosaur> interesting. I found a stack bug report about that but it was claimed to have been fixed in 1.2.1
20:36:17 <evelone> aww
20:36:31 <geekosaur> too many weirdball linuxes with weird linking defaults these days :/
20:36:39 <glguy> In any case you should be using stack 1.5.1 (the  current version)
20:36:44 <evelone> never had problems with manjaro and stack before
20:36:45 <evelone> yeah
20:36:47 <evelone> I'll update
20:36:51 <evelone> actually I didn't even think of that
20:36:58 <evelone> x)
20:37:31 <evelone> thanks
20:42:13 <slack1256> the ability of grab a subexpresion, put it in a function at top-level/let-binding and use such function instead of the subexpression is allowed thanks to purity
20:42:25 <slack1256> I want to understand how much does that also depends on laziness
20:42:58 <evelone> try a pure, strict language and try to do the same stuff
20:43:22 <evelone> at least that's how I did it 
20:43:51 <slack1256> evelone: what was your general experience with it?
20:44:11 <slack1256> did extracting subexpresions work well on a strict setting?
20:45:35 <evelone> You have to care about the order in which you evaluate things, and there are some tricks that you can't do
20:45:49 <evelone> But really, just try it. Install Idris or Elm and have a go at it
20:46:27 <slack1256> !!! elm...  (I was having problems installing ocaml, elm seems more accesible)
20:56:49 <jared-w> Elm is like Haskell-lite so it's not a bad way to get started with functional programming at all
20:56:55 <sqooq> ugh I'm so stupid
20:57:51 <sqooq> I have a function `printChord nts = concat $ zipWith printPitch [1..] nts` which produces something like "1 ..., 2 ..., 3 ..., "
20:58:02 <sqooq> I want it to not do the last ", "
20:58:12 <sqooq> What kind of function do I need here
20:59:06 <geekosaur> where's the ", " coming from?
20:59:17 <sqooq> `printPitch`
20:59:27 <geekosaur> my guess is you want it to not be there, and replace concat with intercalate ", "
20:59:28 <sqooq> its a bunch of ++ and then the last one is ++ ", "
20:59:37 <kadoban> Can you make it ... not do that?
20:59:44 <sqooq> ah yes
20:59:48 <sqooq> Intercalate
20:59:51 <sqooq> I knew I was thinking of something
20:59:53 <sqooq> that should work
21:01:40 <sqooq> yup that done diddly diddly done it thanks geekosaur
21:05:11 <evelone> Aw shucks
21:05:20 <evelone> Even with the latest slack version I get the same error
21:06:35 <evelone> stack
21:06:38 <evelone> x)
21:07:17 <evelone> http://lpaste.net/57698290006753280
21:07:28 <evelone> If anyone has an idea..
21:07:51 <glguy> Maybe your distro has a wiki or a forum?
21:19:47 <sqooq> Is there a zipWith for IO?
21:19:56 <sqooq> or
21:20:07 <sqooq> hold on
21:22:53 <slack1256> @type zipWith
21:22:54 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
21:23:24 <slack1256> (a -> b -> c) -> IO a -> IO b -> IO c 
21:23:32 <slack1256> is that what you want?
21:23:45 <slack1256> if so read about Applicative and Functor
21:24:24 <pacak> :t zipWithM
21:24:26 <lambdabot> Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]
21:27:17 <sqooq> slack1256
21:27:19 <sqooq> maybe
21:27:41 <sqooq> pacak too
21:27:47 <sqooq> umm should I try it first
21:28:10 <sqooq> I just want to have one single filpath, but writefile across [String] such that the filepath has numbers for each one
21:28:21 <sqooq> output1, output2, output3
21:28:25 <sqooq> are filenames
21:28:34 <pacak> o_O
21:28:50 <sqooq> what
21:29:51 <sqooq> is that too crazy
21:31:06 <sqooq> ah shoot
21:31:10 <sqooq> wait
21:33:24 <sqooq> aha
21:33:30 <sqooq> zipWithM did the trick
21:33:40 <sqooq> but for now I'm assuming the user doesn't give an extension
21:33:53 <sqooq> because if they do they'll end up with output.txt1 output.txt2 ...
21:34:16 <sqooq> I'm not trying to parse the dang filepath too to do this crazy crap lmao
21:34:26 <sqooq> unless y'all see an easier way to resolve that?
21:38:21 <slack1256> you should organize your thoughts. Try to write a pastebin with code explaining what are you trying to do and what is happening
21:39:29 <pacak> sqooq: I can't even parse whatever you are saying.
21:43:46 <sqooq> slack1256, pacak, I'm already done lmao
21:43:49 <sqooq> zipWithM_ worked
21:44:33 <sqooq> What I was just saying is that if "output.txt" is the FilePath, then the output will end up being output.txt1,output.txt2,output.txt3,...
21:44:43 <sqooq> rather than output1.txt, output2.txt, ...
21:45:10 <sqooq> because I literally did `flname++x` where x comes from [1..]
21:45:14 <sqooq> in zipwith
21:45:35 <sqooq> I mean I could make quick parser that finds the extensions and places the number before it
21:45:44 <sqooq> but i feel like that's overkill for something so simple
21:48:19 <sqooq> For now my filepath is "output" so I get correctly output1,output2, ...
21:48:24 <sqooq> which on linux is fine
21:48:32 <sqooq> idk if windows can do extensionless text files idk
21:50:40 <geekosaur> ever since vfat
22:09:21 <Tehnix> If I have a function with `myFunc :: Either String [Token]` is it possible to recursively append to the `[Token]` inside the function, or is this an entirely wrong way to go about it?
22:09:38 <Tehnix> More or less want to add error handling in my recursive function :/
22:12:02 <cocreature> Tehnix: what do you do if one of your recursive calls returns "Left something"?
22:12:13 <kadoban> Is that the right type? Then I wouldn't call that a function. Which I wouldn't normally be that pedantic, but it leads me to believe that maybe it doesn't look quite like that?
22:12:22 <Axman6> sqooq: there are modules for working with file paths, which include things like splitting them into the path, base name and extension etc.
22:12:41 <jle`> yeah looking at that type it is definitely 100% not a function
22:13:03 <Axman6> All functions take (only) one argument, so that's not a function
22:13:07 <jle`> Tehnix: Either is just a normal data type
22:13:11 <jle`> so like it's not magical
22:13:17 <Tehnix> cocreature: end the recursion I suppose
22:13:19 <jle`> you can recursively refer to myFunc in the definition of myFunc
22:13:35 <jle`> it's basically the same thing as using recursion to make a list
22:13:43 <jle`> @let myList = 1 : myList
22:13:46 <lambdabot>  Defined.
22:13:52 <jle`> > take 10 myList
22:13:54 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
22:14:27 <jle`> Either is just data Either e a = Left e | Right a, so you can just like...pattern match on the constructors, recurse normally, etc.
22:14:36 <jle`> there isn't anything particuarlly interesting about using recursion with Either
22:14:46 <cocreature> Tehnix: what does that mean? throw away all tokens and exit with "Left something"?
22:14:55 <Axman6> Tehnix: what do you actually want to do anyway?
22:15:02 <Axman6> ehat is the higher level goal?
22:15:05 <Tehnix> jle`: I guess I'm having a bit of trouble transferring that to e.g. `tokenize :: String -> Either String [Token]` when it would build up the token list unless it encountered an error, upon which it would return Left "err"
22:15:05 <Axman6> what*
22:15:26 <Axman6> Tehnix: this is what the Eithe rmonad gives you
22:15:26 <jle`> tokenize can indeed call tokenize within itself
22:15:55 <cocreature> Tehnix: can you show us at least parts of the code you have?
22:16:01 <Tehnix> Sure!
22:17:01 <evelone> Invalid package name: "$everything"
22:17:04 <Axman6> foo str = case getNextToken str of Nothing -> Left "can't get token!"; Just (x,"") -> pure [x]; Just (x,str') -> fmap (x:) (foo str')
22:17:08 <evelone> uh
22:17:41 <Tehnix> The program is fairly small, so all the code is included https://gist.github.com/Tehnix/047aec9e559a69919e70fdce19d6d520 -- what I want is a more graceful way to exit out of `tokenize` than `error`
22:18:11 <kadoban> evelone: Package names are pretty restricted (and also odd).
22:18:40 <cocreature> Tehnix: in the recursive call you have to pattern match on the result and check if it is Left or Right
22:18:51 <cocreature> Tehnix: are you already familiar with Functor and Applicative?
22:19:08 <Tehnix> yeah, but not the best at applying Applicative though
22:19:21 <Tehnix> as in, lacking a bit of the intuition still I think
22:19:29 <cocreature> Functor is probably sufficient here
22:19:45 <cocreature> do you know the behavior of the Functor instance of "Either String"?
22:19:48 <pacak> @hackage acme-everything
22:19:49 <lambdabot> http://hackage.haskell.org/package/acme-everything
22:19:55 <pacak> evelone: ^
22:20:06 <Tehnix> cocreature: nope :/ I'll look it up
22:20:30 <cocreature> Tehnix: trying to come up with it yourself might be a nice exercise :)
22:20:37 <cocreature> Tehnix: it’s very similar to the instance of Maybe
22:20:56 <evelone> wow.
22:21:17 <jle`> actually i think it's even nicer than the Maybe instance because there's only one way to write it that's typechecking (without bottom/infinite recursion)
22:21:22 <Axman6> acme-everything - v. handy when you don't know what libraries an airgapped machine is going to need
22:21:36 <Axman6> also for warming your office
22:22:54 <pacak> Downloads           644 total (21 in the last 30 days)
22:24:40 <kadoban> I don't think hackage's download numbers are at all accurate. At least they never seem to make much sense
22:25:16 <cocreature> mirrors and the cdn make them mostly meaningless
22:25:39 <kadoban> Ah, that would explain it
22:26:38 <cocreature> maybe the cdn is being proberly accounted for these days, but that still excludes mirrors like stackage and nix is probably also counted in weird ways
22:27:17 <sophiag> what are some examples of semigroups that aren't monoids? all the examples on typeclassopedia are also monoids. the only associative operations i can think of without identities are over finite groups that just happen to exclude the identity element. and i can't think of anything like a data structure that would be a semigroup, but not a monoid.
22:27:30 <Zemyla> sophiag: max
22:27:33 <jle`> sophiag: there are some nice examples in base
22:27:37 <jle`> Max/Min, non-empty list
22:27:44 <jle`> Max/Min are semigroups that are very useful
22:27:46 <sophiag> max/min are good examples
22:27:55 <kadoban> sophiag: Data structures won't usually be just semigroups, because it's a rare datastructure that can't be empty.
22:28:01 <sophiag> non-empty list feels a bit contrived like i mentioned above
22:28:10 <sophiag> kadoban: exactly
22:28:17 <sophiag> that's mostly been my confusion
22:28:28 <jle`> > foldMap Max [1..10]
22:28:28 <Axman6> non-empty lists are also extremely useful
22:28:31 <lambdabot>  error:
22:28:31 <lambdabot>      • Data constructor not in scope: Max :: Integer -> m
22:28:31 <lambdabot>      • Perhaps you meant variable ‘max’ (imported from Data.Ord)
22:28:39 <remexre> Hey, I'm getting a mysterious linker error from Stack: https://paste.rs/hS9
22:28:43 <jle`> non-empty lists are not really contrived, i use them all the time
22:28:47 <pacak> @src First
22:28:47 <lambdabot> newtype First a = First { getFirst :: Maybe a }
22:29:12 <sophiag> jle`: i meant lists that *cannot* be empty. isn't that a necessary condition?
22:29:20 <cocreature> remexre: archlinux?
22:29:25 <remexre> Yeah
22:29:32 <cocreature> remexre: try removing libtinfo
22:29:33 <evelone> Ok
22:29:36 <Axman6> that Maybe is only there to make First a Monoid, if it were just a, it would only be a semigroup
22:29:51 <evelone> works when I add -optl-no-pie to stack.yaml ghc options
22:29:55 <sophiag> Axman: ah, thanks. that's great
22:29:56 <jle`> sophiag: not sure what you're saying; lists that cannot be empty is a common useful data structure
22:30:28 <jle`> and their non-emptiness is often exploited for great gain
22:30:30 <Axman6> @src Max
22:30:30 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
22:30:33 <Axman6> :(
22:30:59 <jle`> shoot me your facebook lambdabot
22:31:06 <sophiag> jle`: i guess what i mean is that [1..10] is not necessarily of a different type than []
22:31:19 <sophiag> but seems you're saying there are cases where you'd want to say it can't be []
22:31:53 <sophiag> i suppose i can easily imagine cases where i'd want to say a list has to have at least one element
22:32:03 <jle`> yeah, a list type that doesn't include [] is useful
22:32:17 <jle`> more useful than a list type that does include it, in some cases
22:32:21 <sophiag> i just never thought about encoding that as a distinct list instance before
22:32:34 <jle`> list instance?
22:33:01 <jle`> btw, `data NonEmpty a = a :| [a]`, which is isomorphic to a list without []
22:33:07 <sophiag> as opposed to the regular monadic list we all use
22:33:16 <jle`> but you have nice things like non-partial maximum/minimum
22:33:20 <jle`> non-partial head
22:33:25 <jle`> it can be a Comonad
22:33:28 <jle`> normal lists can't
22:33:30 <sophiag> non-partial?
22:33:41 <Axman6> head :: NonEmpty a -> a
22:33:45 <Axman6> whichis safe
22:33:46 <jle`> a partial function is a function that is not defined for all inputs
22:33:46 <sophiag> ah, ok. i haven't ever used comonads either tbh
22:33:50 <Axman6> > head [] :: Int
22:33:50 <jle`> i guess non-partial = "total"
22:33:52 <lambdabot>  *Exception: Prelude.head: empty list
22:33:57 <sophiag> oh gotcha
22:33:58 <jle`> so maximum for empty lists is a partial function
22:34:09 <jle`> but maximum for non-empty lists is total
22:34:15 <sophiag> i just never heard someone refer to total as non-partial :)
22:34:16 <jle`> it is defined for all inputs
22:34:18 <Axman6> aha, the "shit, what idiot used head in this codebase" exception
22:34:26 <sophiag> ah
22:34:31 <Axman6> aka*
22:34:38 <jle`> head is also total for NonEmpty
22:34:41 <xzhu> Stack seems to have a very random pack of templates, what are chrisdone and franklinchen? They seem like personal templates slipped into public space ...
22:34:46 <jle`> also there are some functions that really should be returning NonEmpty
22:34:46 <sophiag> i never would have thought of that (re: max on non-empty lists)
22:34:54 <jle`> :t group
22:34:56 <lambdabot> Eq a => [a] -> [[a]]
22:35:05 <jle`> group :: [a] -> [NonEmpty a] is the type it really should have
22:35:06 * pacak uses head
22:35:12 <cocreature> pacak: heretic!
22:35:14 <sophiag> i was going to say
22:35:24 <Axman6> xzhu: yeah the stack template stuff is pretty ad hoc, there was discussion at some point about making it less so, but no idea if it went anywhere
22:35:26 <sophiag> i use [a] -> [[a]] all the time
22:35:31 <kadoban> xzhu: They are fairly random. You can create your own and make it the default if you like, or just use one of the ones you like as a default
22:35:35 <jle`> there are legitimate [a] -> [[a]]
22:35:40 <jle`> but the type of group should be [a] -> [NonEmpty a]
22:35:41 <kadoban> Axman6: Not really so far
22:35:41 * pacak also uses tail, init, last and a bunch more partial functions
22:35:43 <sophiag> but those aren't what we're talking about
22:35:52 <jle`> since all of the lists in the list that it returns are non-empty
22:35:58 <xzhu> kadoban: How BTW?
22:35:59 <sophiag> right
22:36:03 <jle`> i guess my point is that NonEmpty is a separate/distinct type from []
22:36:10 <jle`> that is useful for different things
22:36:12 <sophiag> yeah i get it
22:36:16 <sophiag> now at least :)
22:36:17 <kadoban> xzhu: Which part, the create your own or the setting the default?
22:36:23 <jle`> and can be considered a type on its own right, and so is not a contrived semigroup :)
22:36:39 <xzhu> kadoban: I guess I need both
22:36:41 <Axman6> kadoban: do you know if any work has been done to make them less weird? (I've been burned by mustache in other projects so its use does not inspire much confidence from me :P)
22:37:26 <sophiag> now that i know a non-empty list is a comonad i'm trying to understand comonads :p
22:37:41 <remexre> cocreature: that worked great, thanks!
22:37:51 <sophiag> is a comonad a semigroup in the category of endofunctors?
22:37:54 <kadoban> Axman6: There hasn't been much work on them, just discussion AFAIK. But the mustache part doesn't seem to burn people too much as far as I've noticed
22:38:17 <jle`> sophiag: a comonad is a comonoid in the category of endofunctors
22:38:28 <kadoban> xzhu: https://github.com/commercialhaskell/stack-templates so if you grab one of the files from here, whichever is closest to what you like, that's how you can start one the easy way.
22:38:29 <jle`> the thing is that that definition is only meaningful to you if you already understand comonads
22:38:31 <jle`> :)
22:38:37 <kadoban> You can create them from scratch, but probably easier not to.
22:38:53 <jle`> sophiag: comonad is basically just monad with the arrows flipped
22:38:59 <sophiag> ha. okay. so starting with comonoids isn't a great way to understand them i guess
22:39:01 <jle`> sophiag: so Monad m has `a -> m a`
22:39:01 <xzhu> kadoban: Okay. Then how do I set mine as default?
22:39:08 <jle`> sophiag: Comonad w has `w a -> a`
22:39:16 <jle`> and that's not possible with []
22:39:20 <Axman6> kadoban: it'd be nice to have something more powerful, so you can have flags and say "I want a servant based web service, using hasql instead of persistent", which is possible currently, but painful
22:39:29 <kadoban> You can specify a local file or a remote URL to 'stack new' and use that template you created that way. If you want to set an actual default, in ~/.stack/config.yaml you set uhm ... I think it's the default-template: 'whatever' configuration
22:39:44 <sophiag> ah. ok. i knew the standard defintion, but the non-empty list example gives me *some* intuition
22:39:48 <kadoban> Axman6: Oh yeah definitely, there's about 100 things I wish it could do.
22:40:09 <kadoban> And like 5 I wish it really just wouldn't. It being tied to some random github repo is just funky.
22:40:30 <kadoban> I do random PRs to stack occasionally, and doing a lot of work on 'stack new' is something I'd like to get to sometime, but I dunno if I ever will before someone else does.
22:40:45 <sophiag> i'm happy i can explain monads to friends who don't even program. don't think i could do that yet with comonads
22:41:20 <Axman6> kadoban: actually, possibly more useful than that would just be the ability to easily add a package if you need it (say if I add Foo.Bar.Baz from package quux, I want quux added to the .cabal, with appropriate bounds [including upper :3] and the stack.yaml updated appropriately
22:41:40 <jle`> i mean, you can just give the operations it supports and its laws :)
22:42:12 <sophiag> i actually never found thinking about the monad laws particularly helpful relative to starting with monoids
22:42:29 <jle`> yes they are not particularly helpful with the usage of monads
22:42:52 <kadoban> Axman6: Yeah, that kind of stuff would be nice too. A small part of that is also on my list of crap I'd like to implement, lol. (trying to plan out how to write a thing for modifying parts of .yaml files while leaving the rest alone, also .cabal files would be nice as well, but probably harder)
22:42:55 <jle`> but it is the fastest way to see the actual definition of a monad, without worrying abuot using them
22:43:23 <sophiag> yeah, but not if i want to explain them to someone in a way that makes haskell seem not purposefully obfuscated
22:44:09 <kadoban> sophiag: "They're a pattern that comes up a lot that Haskell is powerful enough to abstract over." Boom, done.
22:44:36 <sophiag> but it doesn't just come up in haskell. that adds to the bad image i think. we just have a way to formalize it
22:44:54 <kadoban> It comes up elsewhere, just other languages don't have type systems powerful enough.
22:45:03 <kadoban> Or are missing other things
22:45:15 <sophiag> it's very easy to explain to people, "hey btw, you know classes? we have them for types."
22:45:59 <geekosaur> the problem here is that people tend to not handle very general abstractions well.
22:46:08 <geekosaur> and Monad is just such an abstraction. it's *too* abstract]
22:46:58 <Axman6> there's a post showing three different monads in ruby which I quite like for helping people grok "what actually is a monad"
22:47:24 <Axman6> makes the "and then" really clear, in several contexts (list, Maybe/null handling, futures)
22:47:36 <sophiag> ugh, last week i spoke to this consultant related to a startup that gave me an offer and he was literally under the impression that haskell programmers purposefully obfuscate code. then i got to listen to him try to explain scalaz's version of mappend to me...he referred to it as "crazy" as in complicated and still didn't seem to understand it other than a method of some OO classes he uses :/
22:47:38 <geekosaur> @google you could have invented monads
22:47:39 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
22:47:39 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Al...
22:47:49 <sophiag> geekosaur lol
22:48:09 <geekosaur> betting the ruby thing is actually based on that, even
22:48:16 <kadoban> Any language which has like Optional and maybe a few other what-would-be-Monad-instances-in-haskell makes it easy to show why Monad exists, but ... that's not that many, or people don't use them.
22:48:42 <sophiag> oh, i've read that...i took your comment as a joke on google inc.
22:48:45 <kadoban> Like explaining Monad to my friend who came from rust was trivial xD
22:49:34 <sophiag> kadoban: options types are becoming popular (only 50 years later!). they have them in swift and kotlin
22:49:54 <kadoban> sophiag: Yeah, finally in C++17, yay
22:50:18 <kadoban> But still, most languages don't have too many of them? I think you need at least like one more for it to make a lot of sense to show that the same functions apply to them.
22:50:24 <dibblego> sophiag: I find those people hilarious. I wrote scalaz mappend in 2005. Please more jokes.
22:51:05 <sophiag> dibblego: worse is that the startup is under the impression this guy is like a famous computer scientist or something
22:51:15 <dibblego> sophiag: that just adds to the comedy.
22:51:20 <sophiag> he specializes in devops stuff, though, so i'll assume he knows that
22:51:48 <sophiag> and he was nice at least?
22:52:29 <sophiag> but no...no amount of comments will allow a java or python programmer to understand haskell without trying...
22:52:47 <tdammers> I get the impression that there is a fairly hard line in the programming world between those who have a desire to make their programming better through abstraction and those who don't
22:53:01 <sophiag> pretty much
22:53:20 <sophiag> it's the "don't give a fuck" aspect that really frustrates me
22:53:33 <tdammers> I call it the "why, but it works" mentality
22:53:43 <dibblego> why? If those people admitted, "don't give a fuck", I'd say, "fair enough"
22:54:10 <tdammers> dibblego: that's fine, as long as their work and my work can coexist without ever relying on one another
22:54:17 <dibblego> you don't get to say "oh so hard, boo hoo, so complicated", then insist then everyone else also find it hard, which is what often occurs
22:54:21 <Axman6> "Fair enough, but please let me know before I use your code or systems"
22:54:54 <sophiag> no, i mean like not just accepting some of this stuff is hard if you have no experience with it rather than blaming it on the language or programmers
22:54:57 <dibblego> I think it's impossible to not use incompetent systems. I use them every day. Even today, when I am on holiday.
22:55:31 <tdammers> there are degrees, though
22:55:49 <dibblego> I used windows last week. Show me worse.
22:56:04 <dibblego> I am using aviation tools now. Maybe that is worse, but try harder.
22:56:06 <tdammers> easy. Drupal.
22:56:14 <dibblego> pfft not even close
22:56:18 <geekosaur> win10's not that terrible compared to some web abominations I;ve had to deal with
22:56:21 <sophiag> i don't want to talk about drupal :(
22:56:38 <dibblego> I am driving to the airport, to use a colour photocopier, so I can draw straight lines on a map.
22:56:41 <tdammers> aviation tools, never used any, but I believe you when you say they're the worst
22:56:45 <geekosaur> (in fact I'd argue its not tat terrible period. win7 fixed a whole lot of legacy crap and win8 dealt with much of the rest.)
22:56:55 <tdammers> I've had to code against airline reservation systems at some point, and it was terrible
22:57:03 <sophiag> i don't even know how i'm aware of drupal drama, but i got defriended on fb for commenting about it
22:57:05 <dibblego> I used SAP last week, on IE7 because it works on nothing else
22:57:24 <tdammers> sophiag: yeah, that's the worst - the Stockholm Syndrome is really strong in the Drupal world
22:57:49 <sophiag> i'm not sure if we're referring to the same thing
22:58:02 <sophiag> the group of friends aren't drupal people either
22:58:15 <norc_> sophiag: Agreed. My experience allowed me to drop into elixir by just skimming through the manual for 10 minutes and I can write complex programs. It simply doesn't quite work for haskell.
22:58:18 <tdammers> oh
22:58:26 <Axman6> dibblego: why do you have to remind me these things exist man :(
22:58:26 <dibblego> I am transcribing, by binary search, a point on a paper map to narrow down a latitude/longitude, by finding a tower on google earth, somewhere in a national forest/mountain, right now
22:58:45 <dibblego> Axman6: SAP SAP SAPETTY BAPPETY SAP WE LOVE SAP
22:58:53 <Axman6> :'(
22:59:04 <Axman6> I feel harassed 
22:59:15 <dibblego> You're hired!
22:59:39 <sophiag> norc_: same. once i got beyond just writing simple numerical programs i was a bit frustrated for a month or a few even. and i thought it'd be easy coming from a lisp background
23:01:14 <norc_> sophiag: try explaining homoiconicity to a Java developer in under 2 minutes ;p
23:01:55 * geekosaur has worked with EDI systems, it;s likewise terrible
23:02:36 <xzhu> This might be off-topic, but when I was looking at Rust's homepage I didn't understand what is a *systems* programming language? What does it mean?
23:04:00 <norc_> xzhu: It's a fuzzy distinction that tries to differentiate between people writing boring programs for endusers, and important people writing important programs that are not used by endusers but by.. things.
23:04:09 <geekosaur> xzhu, generally a programming language for writing operating systems and their core utilities, and general 'bare-metal' programming
23:04:36 <kadoban> xzhu: Something like a language that you can write device drivers in, one where you can easily care what exact memory locations and such you're messing with.
23:04:50 <geekosaur> although yes, this has become a bit fuzzy as 'core utilities' grow to include things like web servers
23:05:04 <geekosaur> and package installation GUIs
23:05:45 <sophiag> norc_: fair... although i think homoiconicity is probably easier to understand for people who don't program. then you don't have to explain why it's different from Java syntax or whatever or get into what a lexxer is
23:05:58 <norc_> sophiag: easier to understand it concept, but really hard to understand why its so useful 
23:06:51 <sophiag> hmm... i like to use the example of "this is how OOP started," but that's not so easy to communicate without a whiteboard or something
23:08:10 <norc_> sophiag: That's another great example. People have this rigid concept of OOP in mind, completely disregarding other more profound concepts that can be found in Smalltalk
23:08:14 <geekosaur> oh, also making ot fuzzy is that in the old days, system programming languages really were different, because they did things like treat all variables as their addresses and require you to dereference them if you wanted their contents
23:09:16 <Axman6> edwardk: do you know if there's a copy of Runar's machines talk linked in the documenttion? it's a 404 on dropbox
23:13:12 <norc_> sophiag: For what its worth, that's what some consultants are about. Bullshitting their way into companies that simply don't know better. To them they will be "senior enterprise java developers", and compared to them he probably is a software god.
23:15:02 <wz1000> saurabhn_: ping
23:17:00 <tdammers> java has ruined OOP
23:17:09 <norc_> tdammers: https://img.youtube.com/vi/I7IdS-PbEgI/0.jpg
23:18:19 <tdammers> norc_: interesting... my thought right now was that the problem was kind of the opposite, that people would use OOP to *replace* all previous programming wisdom, rather than using it as a framework to *complement* it
23:18:31 <tdammers> but maybe both happened, really
23:19:04 <tdammers> people took the less important parts from OO, and used them to replace the parts of earlier paradigms that actually made sense along with those that were problematic
23:22:17 <sophiag> norc_: the consultant thing wasn't quite that bad. he doesn't claim to have any experience with haskell at all yet didn't dissaude them from hiring new haskell devs instead of starting from scratch. and he may have convinced them to switch from mongodb to postgres so that's cool
23:26:04 <wob> http://lpaste.net/5684070100185907200 -- trying to build a project where this clock package seems to be a dependency on a package called GenericPretty. it seems related to this issue: https://github.com/commercialhaskell/stack/issues/2712https://github.com/commercialhaskell/stack/issues/2712 -- but how do I add -fPIC to the build parameters? changing -fno-PIE into -no-pie in the mentioned 'settings' file does
23:26:10 <wob> n't change things.
23:26:50 <wob> /usr/bin/ld: .stack-work/dist/x86_64-linux-tinfo6-nopie/Cabal-1.24.2.0/build/System/Clock_hsc_make.o: relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC
23:28:00 * wob tries to add -fPIC to 'settings'
23:29:42 <geekosaur> did you recently upgrade your OS?
23:30:09 <Axman6> and is the OS Arch? they recently broke everything
23:30:36 <geekosaur> this sounds like recent debian upgrades that switched to position independent executables by default, but stack is still using the compiler for the old release
23:30:38 <wob> Axman6, yes!
23:30:52 <wob> Axman6, the OS is Arch. :) I'm using stack, though.
23:31:18 <wob> Axman6, can the problem be circumvented by using another stack?
23:31:24 <geekosaur> you need to *remove* the -fno-PIE
23:31:30 <wob> geekosaur, oh!
23:31:42 <geekosaur> or possibly add it somewhere else
23:32:08 <Axman6> no idea, all I know is Arch broke everything, but don't use it so don't know how to fix things
23:32:23 <geekosaur> because it's trying to build PIE (position independent executable, essentially a shared object that is executable) anyway
23:32:33 <wob> geekosaur, yes, that github issue mostly mentions debian.
23:32:58 <wob> geekosaur, okay. I'll try and remove that then.
23:33:47 <geekosaur> or rather it's trying to do things that only work with PIE enabled
23:34:46 <cocreature> wob: remove libtinfo
23:35:20 <wob> cocreature, in my operating system?
23:35:43 <cocreature> yes
23:36:14 <cocreature> libtinfo results in stack fetching a ghc bindist that doesn’t work on arch
23:40:47 <wob> cocreature, I don't have a package called libtinfo when doing pacman -Ss libtinfo (or even just tinfo)
23:41:29 <wob> cocreature, but admittedly, stack does fetch x86_64-linux-tinfo6-nopie for some reason.
23:41:33 <cocreature> wob: try pacman -Q libtinfo
23:41:42 <cocreature> wob: it’s in the AUR
23:42:50 <wob> cocreature, okay, thanks. removing it and re-initializing ~/.stack to see.
23:46:45 <saurabhn_> wz1000: here
23:48:13 <saurabhn_> has anyone tried the Haskell Language Server on VSCode: https://marketplace.visualstudio.com/items?itemName=alanz.vscode-hie-server -- does it work well?
