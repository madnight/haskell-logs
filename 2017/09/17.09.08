00:00:08 <kaffepanna> with it now linking against libgcc
00:00:48 <kaffepanna> also created a new project without any dependencies and that also links against libgcc
00:01:30 <kaffepanna> so im curious why is it linking against libgcc on one computer and not the other
00:02:36 <cocreature> I assume you got GHC via stack on both systems?
00:02:41 <kaffepanna> yes
00:02:49 <cocreature> I would guess it picked slightly different bindists
00:03:59 <kaffepanna> cocreature: sorry not so familiar with the terinology how is the bindist determined
00:07:04 <cocreature> depends on various factors like your architecture, whether your system compiles with pie, your version of ncurses, …
00:08:05 <cocreature> kaffepanna: if you run "stack path --bin-path" there should be a directory that points somewhere in ".stack/programs/…". the name of that directory identifies the bindist
00:08:28 <cocreature> e.g. on my system it’s x86_64-linux/ghc-nopie-8.0.2
00:09:25 <olligobber> I don't get this language, why would do {fmap putStrLn a; return ()} return [(),()]
00:09:31 <olligobber> > do {fmap putStrLn a; return ()}
00:09:34 <lambdabot>  error:
00:09:34 <lambdabot>      • Couldn't match expected type ‘m String’ with actual type ‘Expr’
00:09:34 <lambdabot>      • In the second argument of ‘fmap’, namely ‘a’
00:09:44 <olligobber> um, hold on
00:09:53 <olligobber> > do {fmap putStrLn ["a","b"]; return ()}
00:09:55 <geekosaur> ghci?
00:09:55 <lambdabot>  [(),()]
00:10:06 <cocreature> olligobber: where have you gotten this code from? that doesn’t look particularly useful.
00:10:10 <opqdonut> olligobber: that expression runs in the list monad
00:10:17 <cocreature> oh you asked why this returns something not why you use this
00:10:24 <geekosaur> oh, that is because you fmap-ed over a list, so it is in the list monad
00:10:24 <opqdonut> :t fmap putStrLn ["a","b"]
00:10:26 <lambdabot> [IO ()]
00:10:28 <geekosaur> not the IO monad
00:10:50 <geekosaur> and you are seeing the specific behavior of the list monad here
00:10:53 <kaffepanna> cocreature: well it is ghc-8.0.2 which is the same at my other machine
00:11:16 <olligobber> I thought do returned what the last command did, ie return ()
00:11:30 <cocreature> kaffepanna: hm k, maybe one of the system libs that GHC links against is built differently on those systems
00:12:01 <geekosaur> > ["a", "b"] >>= \_ -> return ()
00:12:03 <lambdabot>  [(),()]
00:12:43 <kaffepanna> cocreature: yeah probably.. i do use arch on one machine and ubuntu on the other..
00:12:57 <geekosaur> the semicolon is what got you the \_ -> that discards the list element's value
00:13:26 <cocreature> kaffepanna: in general building binaries on one linux distro and using them on another distro is not going to work
00:13:37 <olligobber> clearly semicolons don't do what I thought they would
00:14:03 <geekosaur> do notation is not "whoopie, we're procedural now!" although it acts that way in IO, because that is how IO is defined
00:14:11 <geekosaur> in the list monad, it behaves differently
00:14:18 <olligobber> oh
00:14:31 <olligobber> interesting
00:14:37 <geekosaur> everything depends on what (>>=) does in that monad
00:14:49 <cocreature> kaffepanna: if you really need that, you’ll have to build fully static binaries with musl and even then I’m not sure about the exact guarantees you get on compatibility
00:14:52 <geekosaur> @undo do {fmap putStrLn ["a","b"]; return ()}
00:14:53 <lambdabot> fmap putStrLn ["a", "b"] >> return ()
00:14:59 <geekosaur> @src (>>)
00:14:59 <lambdabot> m >> k = m >>= \_ -> k
00:15:07 <kaffepanna> cocreature: yeah i know.. one can dream tho... im putting the binary on fcp/haskell-scratch:integer-gmp and thats where it breaks
00:15:30 <cocreature> kaffepanna: you can tell stack to build in a docker image as well
00:15:44 <kaffepanna> cocreature: yep thats my next step :)
00:15:47 <olligobber> :t do {fmap putStrLn ["a","b"]; return ()}
00:15:49 <lambdabot> [()]
00:16:01 <geekosaur> so in the list monad, this discards the list elements and replaces them with (). the list elements here are (putStrLn "a") and (putStrLn "b") so that is what is replaced by ()
00:16:22 <olligobber> ok
00:16:48 <olligobber> this originated from trying to do fmap putStrLn ["a","b"] and the return type being unprintable
00:16:57 <olligobber> :t fmap putStrLn ["a","b"]
00:16:58 <lambdabot> [IO ()]
00:17:03 <geekosaur> in the IO monad, it chains I/O operations together instead, with the (>>) variant discarding the result of the first IO action
00:17:13 <opqdonut> :t mapM putStrLn ["a","b"]
00:17:15 <lambdabot> IO [()]
00:17:18 <opqdonut> olligobber: ^ try that
00:17:27 <opqdonut> also known as:
00:17:30 <olligobber> I guess mapM is like replicateM
00:17:37 <opqdonut> :t sequence (map putStrLn ["a","b"])
00:17:38 <lambdabot> IO [()]
00:17:50 <geekosaur> actually we normally do this with mapM_ because a list of () is kinda useless
00:17:51 <olligobber> > sequence (map putStrLn ["a","b"])
00:17:53 <lambdabot>  <IO [()]>
00:17:55 <opqdonut> in this case, sequence :: [IO a] -> IO [a]
00:18:06 <geekosaur> :t mapM_ putStrLn ["a","b"]
00:18:08 <lambdabot> IO ()
00:18:28 <olligobber> does mapM_ just discard the return value?
00:18:41 <geekosaur> yes
00:18:52 <olligobber> handy, thanks all
00:19:11 <olligobber> note to self: do only works on lines that are IO a
00:19:22 <geekosaur> so you use it when you know the return value from each one will be (). typically mapM_ is more efficient because it's not building a list of () just to throw it away after
00:19:25 <kaffepanna> cocreature: im gonna try that, thanks for rubber ducking ;)
00:19:58 <geekosaur> untrue, do works fine on other monads. it just doesn't do what you might expect
00:20:05 <geekosaur> have you played with list comprehensions yet?
00:20:19 <geekosaur> the list monad works the same way as list comprehensions do
00:21:58 <geekosaur> and the list monad's behavior will make a lot more sense when you've worked with list comprehensions a bit, since they have a fairly obvious translation to the list monad
00:23:32 <tdammers> > do { x <- Just 2; return x + 3 }
00:23:34 <lambdabot>  error:
00:23:34 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘show_M333065131606...
00:23:34 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
00:23:45 <tdammers> > do { x <- Just 2; return x + 3 } :: Maybe Int
00:23:47 <lambdabot>  error:
00:23:47 <lambdabot>      • No instance for (Num (Maybe Int)) arising from a use of ‘+’
00:23:47 <lambdabot>      • In a stmt of a 'do' block: return x + 3
00:24:00 <tdammers> > do { x <- Just 2; return (x + 3) } :: Maybe Int
00:24:02 <lambdabot>  Just 5
00:24:04 <tdammers> jeez
00:24:18 <tdammers> olligobber: see above for do notation used on the Maybe monad
00:24:35 <tdammers> > do { x <- [1,2,3]; return (x + 3) } :: [Int] -- same for list monad
00:24:37 <lambdabot>  [4,5,6]
00:25:22 <tdammers> > do { x <- [1,2,3]; y <- ["pizza", "olives"]; return (y + ": $" + show x) }
00:25:26 <lambdabot>  error:
00:25:27 <lambdabot>      • No instance for (Num [Char]) arising from a use of ‘+’
00:25:27 <lambdabot>      • In the first argument of ‘return’, namely ‘(y + ": $" + show x)’
00:25:43 <tdammers> > do { x <- [1,2,3]; y <- ["pizza", "olives"]; return (y ++ ": $" ++ show x) }
00:25:45 <lambdabot>  ["pizza: $1","olives: $1","pizza: $2","olives: $2","pizza: $3","olives: $3"]
00:26:25 <tdammers> olligobber: do notation works fine. but to understand what it does, you need to desugar it, at least until you develop the correct intuition for it
00:27:46 <tdammers> > [1,2,3] >>= \x -> ["pizza", "olives"] >>= \y -> return (y ++ ": $" ++ show x)
00:27:48 <lambdabot>  ["pizza: $1","olives: $1","pizza: $2","olives: $2","pizza: $3","olives: $3"]
00:28:40 <tdammers> once desugared, you can substitute the specific implementations for (>>=) and return (for List, these are concatMap and the singleton list constructor)
00:43:23 <Ted___> hi all
00:55:19 <vaibhavsagar> Hi Ted___!
00:58:22 <olligobber> so I'm trying to submit some haskell code, but the system I'm submitting to has a broken compiler, so I complained that their compiler is broken
00:58:29 <olligobber> their response was "Haskell?"
00:59:23 <olligobber> good thing ghcrun still works on their system
01:04:56 <olligobber> the output from their broken compiler: http://lpaste.net/2488964914178162688
01:05:41 <cocreature> are they using archlinux? :)
01:06:10 <olligobber> cocreature, I have no idea how to find that out
01:06:13 <cocreature> try passing "-dynamic" to GHC
01:08:08 <olligobber> cocreature, that fixed it
01:08:10 <olligobber> wow
01:08:48 <olligobber> does this channel have a karma bot?
01:09:07 <cocreature> I think lambdabot tracks karma but nobody cares about it or at least I don’t :)
01:09:19 <cocreature> @karma olligobber
01:09:19 <lambdabot> olligobber has a karma of 0
01:11:04 <olligobber> cocreature++
01:11:09 <olligobber> @karma cocreature 
01:11:09 <lambdabot> cocreature has a karma of 9
01:11:12 <olligobber> nice
01:13:52 <olligobber> I got another response: "Or use python"
01:24:32 <ongy> where are you submitting that code to? o.0
01:35:29 <ertes-w> "our compiler is broken, so just drop to the worst language on planet earth after PHP"
01:45:16 <Ferdirand> ertes-w: have you tried tcl ?
01:47:22 <royal_screwup21> ertes-w: what is this "worst language" that you speak of?
01:52:01 <vaibhavsagar> ertes-w: have you heard of JavaScript? or Bash?
01:53:21 <tdammers> bash doesn't count, you're not supposed to do actual programming in it
02:00:14 <vaibhavsagar> tell that to every sysadmin ever tdammers :)
02:04:25 <ertes-w> royal_screwup21: i've had the distinct displeasure to work with python for a few weeks…  it has been my worst experience since zabbix
02:05:46 <ertes-w> yes, yes, i'm aware that python is not that bad, but i hated every minute of it
02:06:06 <halogenandtoast> ertes-w: In my experience, learning Haskell ruins you.
02:06:25 <LiaoTao> Honestly can't understand animosity against decent languages when things like TCL exist
02:07:08 <halogenandtoast> LiaoTao: One thing being worse doesn't make a bad thing good.
02:07:18 <halogenandtoast> Also opinions.
02:10:21 <ertes-w> halogenandtoast: i would probably have had the same experience without knowing haskell…  python tries to do so many things, and it gets none of them right…  and none of what i'm talking about is about types
02:11:02 <halogenandtoast> ertes-w: My experience was that Python was fine, it's the people who use it that are the problem.
02:11:45 <halogenandtoast> Granted I only used it for around 3 to 4 months.
02:12:14 <ertes-w> believe it or not, python has coroutine-based concurrency and an I/O manager around it (asyncio), but the way it works is soooooo stuuuuuupid that it's borderline useless
02:14:15 <royal_screwup21> ertes-w: so let me get this straight: you're saying...you would prefer php over python?
02:14:32 <ertes-w> royal_screwup21: no
02:14:37 <ertes-w> i would prefer python over PHP
02:14:45 <halogenandtoast> royal_screwup21: I stand by that PHP is not a programming language, it is a hypertext processor
02:14:48 <halogenandtoast> says so in the name
02:15:57 <halogenandtoast> sorry "hypertext preprocessor"
02:17:18 <ertes-w> (i would actually prefer python over most of those interpreted by default, dynamically typed, imperative languages, thanks to one particular feature: generators)
02:18:40 <ubsan> I would prefer python because I like the syntax
02:18:56 <ubsan> and it's fairly easy to make typed
02:18:58 <ventonegro> Aren't generators just poor coroutines?
02:19:19 <ubsan> ventonegro: I think they're just coros
02:19:26 <olligobber> ongy, educational institution
02:19:33 <halogenandtoast> Does Ruby not have something equivalent?
02:20:18 <halogenandtoast> Lazy Enumerators maybe?
02:20:35 <ubsan> ventonegro: oh, coros can apparently accept arguments after the initial call
02:21:06 <halogenandtoast> olligobber: Nice that you get to submit Haskell code
02:21:15 <ubsan> while generators cannot
02:21:27 <halogenandtoast> I got to write in the university trifecta of 2004: C, C++, Java
02:21:48 <ubsan> man, not even modern C++
02:21:54 <ubsan> that's no fun
02:22:10 <ertes-w> ventonegro: yes, but they are good enough to get the kind of separation i'm used to from stream processing…  it's more work, it's not first-class and it's not as composable, but this is python…  it's like a loaf of bread to a starving programmer
02:22:14 <ubsan> halogenandtoast: hey, at least you didn't have to write lisp :3
02:22:18 <olligobber> halogenandtoast, python has since been added to that list
02:22:29 <halogenandtoast> ubsan: the coolest language I got to write in was Oz
02:22:52 <ubsan> halogenandtoast: are you french?
02:23:02 <halogenandtoast> ubsan: Only in my last name.
02:23:12 <ertes-w> also python's coroutines are based on an extension on generators
02:23:20 <ventonegro> ertes-w: Lua has syntax sugar for first-class coroutines, so I don't see why Python is special
02:23:43 <ertes-w> ventonegro: it's special in that i'm familiar with it…  i've never written a single line of lua
02:23:53 <ventonegro> ertes-w: Good point
02:23:53 <halogenandtoast> olligobber: I know, and it makes me sad.
02:24:07 <olligobber> I think java might be dropped soon
02:24:08 <ongy> olligobber: \o/ at least they allow it, even if it's (slightly) broken
02:24:16 <halogenandtoast> olligobber: that is probably for the best
02:24:22 <ongy> My numerics course required java of all things -.-
02:24:24 <ubsan> python is better than Java or C, at least
02:24:33 <halogenandtoast> ubsan: You take that back!
02:24:36 <ubsan> at least you get HOF
02:24:40 <ubsan> halogenandtoast: ... no
02:24:49 <olligobber> python is a lot easier to teach than C
02:24:52 <halogenandtoast> ubsan: but... I love C
02:25:00 <sphalerite> Rust > C
02:25:01 <ventonegro> How is Python better than C? It's like saying  a boat is better than a truck
02:25:16 <halogenandtoast> sphalerite: That might be true, I need to do more rust. It's on my list.
02:25:17 <ubsan> halogenandtoast: why
02:25:19 <olligobber> ventonegro, exactly, sometimes it is
02:25:34 <halogenandtoast> ubsan: I like writing programming languages as a hobby and "getting" to manage memory is fun.
02:25:35 <ubsan> C is an incredibly outdated and boring language
02:25:49 <ubsan> manual memory management is so crap tho
02:25:55 <ubsan> RAII is just... better
02:26:01 <ubsan> there's no point to manual memory management
02:26:14 <APic> Embedded Systems.
02:26:14 <ongy> ubsan clearly never worked in constrained environments
02:26:15 <drdo> ubsan: Unless you're writing a memory manager!
02:26:19 <halogenandtoast> ubsan: yeah but I have fun with it.
02:26:21 <mauke> RAII is still pretty manual
02:26:23 <ventonegro> Meh "Some Were Meant for C" https://www.cl.cam.ac.uk/~srk31/research/papers/kell17some-preprint.pdf
02:26:31 <ubsan> if you're doing anything reasonable, you'll reinvent RAII, but worse
02:26:36 <ubsan> or GC, but worse
02:26:41 <mauke> or better
02:26:42 <halogenandtoast> ubsan: I wouldn't use it for anything real.
02:27:00 <sphalerite> ongy: RAII ≠ dynamic allocation everywhere
02:27:08 <ubsan> drdo: I would rather write it in a language with a good standard library
02:27:14 <ubsan> ongy: yes, I have
02:27:19 <ubsan> and I'd rather use C++ or Rust
02:27:26 <mauke> the big problem with traditional C++ RAII is that it forces you to define a whole class every time you want to reliably clean up something
02:27:34 <drdo> I don't even understand what the discussion is
02:27:37 <drdo> C is fine for what it is
02:27:50 <mauke> drdo: debatable :-)
02:27:51 <ubsan> drdo: C is B with typing
02:27:56 <ubsan> it is not fine for what it is
02:27:57 <ventonegro> drdo: Well, it's trendy to bash it
02:28:00 <drdo> It's supposed to be assembly with a nicer syntax
02:28:15 <mauke> disagree
02:28:17 <ubsan> no it isn't, and it's a fundamental misunderstanding of history to say so
02:28:23 <drdo> And some facilities for organisation
02:28:47 <olligobber> I like this channel..
02:28:49 <ubsan> drdo: C is a high level language which maps reasonably to a computer
02:28:59 <ubsan> (at least, to a minicomputer)
02:29:02 <drdo> ubsan: I'm not invoking history, just stating my opinion
02:29:14 <ubsan> drdo: "it's supposed to be assembly with a nicer syntax"
02:29:16 <ubsan> no it isn't
02:29:34 * drdo removes himself from this fruitless discussion
02:29:59 <mauke> "supposed to be" is a bit vague
02:30:09 <mauke> I mean, it's not what it actually is
02:30:13 <ubsan> that's like saying "Haskell is supposed to be a fast language with strict semantics"
02:30:15 <mauke> so supposed by whom?
02:30:20 <ubsan> I mean... you can sure use it that way
02:30:34 <ubsan> but that's never been its intended use
02:31:01 * ubsan owns both the first and second editions of the C programming language, and has read the majority of the C standard
02:31:12 <mauke> which C standard? :-)
02:31:13 <ubsan> so this is coming from someone who intimately knows C
02:31:19 <ubsan> mauke: generally, C99
02:31:30 <ubsan> I've also obv. read the updated parts of the C11 standard
02:32:12 <ubsan> mauke: also, I disagree with the whole "forces you to define a class any time you want to clean something up"
02:32:36 <[exa]> ubsan: in what manner does C have higher level than assembly, except for the type check?
02:32:52 <ubsan> I'd rather say "you should probably define a class any time you want to clean 'something' up, because generally that's a linear resource that you want to treat as a part of the type system"
02:33:04 <ongy> [exa]: the obvious one would be that no manual register management is required
02:33:22 <ongy> you don't have to worry about fpu/alu/sse unless you specificly want to
02:33:26 <[exa]> that's subsumed by the portability requirement
02:33:32 <ubsan> [exa]: automatic memory management, easy calls, fairly first class functions
02:33:35 <mauke> ubsan: I disagree
02:33:42 <ongy> automatic memory management in C?
02:33:43 <[exa]> ubsan: automatic MM in _C_ ?
02:33:47 <ubsan> ... yes
02:33:51 <[exa]> c'mon
02:33:52 <ubsan> clearly y'all have never done assembler
02:34:16 <mauke> C even has a keyword for this: auto
02:34:18 <olligobber> I spelled Haskell wrong in my post -_-
02:34:19 <yushyin> automatic storage class
02:34:20 <ubsan> you generally have to, you know, clean up the stack
02:34:28 <ubsan> which C does for you
02:34:33 <ubsan> you also have to clean up function parameters
02:34:45 <ubsan> slash arguments, depending on CC
02:34:50 <ubsan> usually it's arguments
02:34:59 <[exa]> ubsan: well you can write 1950 assembly or 1980 assembly, most assemblers have reasonable macros to do that for you
02:35:18 <[exa]> (which feature is largely forgotten by now)
02:35:22 <ubsan> [exa]: looping constructs; C is a structured language
02:35:25 <[exa]> (sad face)
02:35:30 <ubsan> first class functions
02:35:32 <ubsan> yes, typing
02:35:39 <[exa]> first class functions?
02:35:42 <mauke> more like first order functions
02:35:51 <ubsan> `int (*)()`
02:35:56 <mauke> but yeah, asm doesn't have functions at all
02:35:59 <[exa]> ubsan: that's a pointer
02:36:03 <ubsan> [exa]: to a function
02:36:05 <[exa]> completely unrelated to function
02:36:22 <ubsan> ... no, it isn't
02:36:28 <[exa]> well, what's good with integers in language with first-class integers? (you can combine them)
02:36:36 <[exa]> q: what do you do with functions in C?
02:36:39 <mauke> call 'em
02:36:43 <mauke> or take their address
02:36:59 <ubsan> but, in general, functions have an actual value
02:37:04 <ubsan> and you can create higher order functions
02:37:17 <maerwald> it's not actually pleasant though
02:37:26 <ubsan> maerwald: that's not the point
02:37:43 <ubsan> maerwald: it's a feature not all languages have
02:38:30 <cocreature> without being able to create functions dynamically, that breaks down very quickly
02:38:31 <maerwald> well, you can do OOP in haskell, you can call that a feature, but you don't want to actually write that code :>
02:38:34 <ubsan> [exa]: that reminds me, value/object semantics
02:39:19 <ubsan> maerwald: that's not on the same level
02:39:26 * [exa] sees himself creating first-class functions from interpreting gödel numerals in lua (or whichever language can't reference functions)
02:39:33 <ubsan> in some languages, you literally cannot pass a function to another function
02:39:44 <ubsan> off the top of my head, COBOL
02:39:50 <ubsan> and I think Fortran as well
02:39:53 <mauke> java?
02:39:57 <[exa]> :]
02:40:00 <ubsan> mauke: fair
02:40:04 <ubsan> java as well
02:40:16 <APic>  ;]
02:40:17 <Ferdirand> java has lambdas now
02:40:29 <ubsan> the point is, C is a high-level assembler as haskell is a high-performance strict language
02:40:36 <ubsan> yeah, you can use it that way
02:40:43 <ubsan> but don't expect it to be supported very well
02:41:02 <ubsan> and that's nowhere near the intention of C
02:42:25 <ventonegro> Huh, Lua has first-class lexical closures
02:42:29 <[exa]> ubsan: what I'm saying is that your point is wrong; translation C-asm can be done by a context-free grammar; you need either a runtime or a giant bunch of non-local tricks to make haskell strict
02:42:53 <ubsan> [exa]: ... no, you can't
02:43:10 <ubsan> have you ever like... used C?
02:43:17 <ubsan> that's easily untrue
02:43:27 <[exa]> I actually write a compiler with students each year for it
02:43:29 <ubsan> `int main() { float f = 1 + 2; return 0; }`
02:43:32 <ventonegro> C has a runtime...
02:43:59 <mauke> just parsing C can't be done without context
02:44:03 <ubsan> ^
02:44:59 <[exa]> mauke: forced ordering of the definitions actually allows you to embed a (brutal, but) working attributed grammar to it
02:45:06 <ubsan> `int x = (ident) * ident;`
02:45:21 <[exa]> well not that I'd like to do it
02:45:21 <mauke> ubsan: a(b);
02:45:24 <ubsan> [exa]: but definition ordering isn't forced
02:45:40 <ubsan> mauke: well, I think that's only an issue in C99
02:45:44 <ubsan> *C89
02:45:58 <ubsan> C99 removed implicit int
02:46:06 <ubsan> or maybe it deprecated it, and it's still a problem
02:46:29 <ubsan> or wait... actually, what is an issue about that?
02:46:45 <mauke> ubsan: typedef int a; int b; int main(void) { a(b); }
02:46:56 <mauke> ubsan: void a(int); int b; int main(void) { a(b); }
02:47:14 <michalrus> Hey, can I turn off hindent for just a fragment in code? Like `-- format: off` or something?
02:47:15 <ubsan> mauke: I don't think it's valid to declare an anonymous function in that way
02:47:26 <mauke> ubsan: dude, what
02:48:04 <ubsan> https://godbolt.org/g/whAP1S
02:48:14 <ubsan> you need the identifier
02:48:34 <mauke> ubsan: the identifier is 'b'
02:48:54 <ubsan> mauke: no, I mean, a(b) where `a` is a type is invalid
02:49:02 <mauke> ubsan: wrong
02:49:06 <ubsan> umm
02:49:07 <Ferdirand> i think his point is you can't distinguish a cast from a call
02:49:13 <mauke> Ferdirand: no
02:49:15 <ubsan> look at the godbolt?
02:49:16 <Ferdirand> if you don't know if you are looking at a type or at a symbol
02:49:22 <mauke> ubsan: 'int' is not an identifier. 'b' is.
02:49:41 <ubsan> https://godbolt.org/g/Do9fqu
02:49:45 <ubsan> fine, fixed
02:49:52 <ubsan> if you remove the typedef, however, it's well formed
02:49:59 <mauke> ubsan: you're still using 'int' instead of 'b'
02:50:06 <mauke> 'int' is still not a valid identifier
02:50:22 <ubsan> wait what the actual fuck
02:50:27 <mauke> there we go
02:50:30 <ubsan> oh, no
02:50:35 <nakal> haha
02:50:37 <ubsan> it's implicitly declaring a function `x`
02:50:43 <ubsan> I think?
02:50:45 <mauke> no
02:50:48 <mauke> it's declaring 'b'
02:51:01 <ubsan> oh shit
02:51:04 <ubsan> that's crazy
02:51:07 <mauke> uh
02:51:08 <[exa]> anyways
02:51:16 <mauke> welcome to C declarations 101
02:51:19 <ubsan> well, anyways, there are actually apparently three valid parses for that
02:51:29 <mauke> you can put parens in there
02:51:36 <ubsan> `ident(ident);` can be
02:51:46 <ubsan> `call function ident1 with the argument ident2`
02:52:01 <ubsan> `declare a function ident1 with type `int(ident2)``
02:52:13 <[exa]> there should be a photo of the ICFP crowd when C++ guys won the second half of the programming contest
02:52:13 <reactormonk> Anyone happen to know if there's a (c -> d) -> ConduitM a b m c -> ConduitM a b m d ?
02:52:17 <ubsan> and `declare a variable ident2 with type ident1`
02:52:20 <[exa]> that was fun.
02:52:24 <mauke> I think interpretation #2 is C89 only
02:52:29 <ubsan> correct
02:52:46 <ubsan> but in any case, it makes [exa] very, very wrong about being able to implement C in a CFG
02:52:54 <ubsan> even ignoring like... struct types
02:53:16 <mauke> ubsan: btw, this kind of problem is about 1000 times worse in C++ :-)
02:53:24 <ubsan> mauke: oh, no, I know
02:53:27 <olligobber> @djinn (c -> d) -> ConduitM a b m c -> ConduitM a b m d
02:53:27 <lambdabot> Error: Undefined type ConduitM
02:53:47 <olligobber> reactormonk, ^
02:53:50 <ubsan> mauke: anyways, back to interesting things
02:54:03 <reactormonk> olligobber, ran it through hayoo and stackage already
02:54:06 <ubsan> what time would you want to use RAII for something where it's not a linear resource?
02:54:16 <mauke> what's a linear resource?
02:54:20 <Philonous> reactormonk, Isn't that just fmap?
02:54:21 <Ferdirand> coudl't you use also type(expr) instead of (type)expr for casts, in very early versions of C ?
02:54:26 <Ferdirand> or maybe it was C++ only
02:54:28 <Ferdirand> i don't remember
02:54:30 <ubsan> Ferdirand: C++ only
02:54:36 <ubsan> mauke: umm
02:54:47 <reactormonk> Philonous, ... yeah.
02:54:51 <ubsan> let me find some papers/links
02:55:06 <ubsan> https://en.wikipedia.org/wiki/Linear_logic#The_resource_interpretation
02:55:12 <olligobber> reactormonk, wouldn't it just be like \f -> \(ConduitM w x y z) -> ConduitM w x y (f z)
02:55:37 <ubsan> https://www.cis.upenn.edu/~stevez/papers/MZZ10.pdf
02:55:39 <reactormonk> olligobber, there's a Functor instance for ConduitM which does exactly what I want
02:55:54 <ubsan> see section 1.2 for examples
02:56:25 <mauke> ubsan: I don't see how that relates to RAII
02:56:34 <ubsan> mauke: RAII is an implementation of linear resources
02:56:48 <mauke> ok, but why should I care?
02:56:56 <ubsan> because it's a useful abstraction?
02:57:10 <mauke> I don't want an abstraction, I want to clean up my stuff
02:57:27 <ubsan> (it's more like, linear resources plus automatic cleanup)
02:57:30 <mauke> let's say I have a program with several functions in it
02:57:45 <mauke> one of them uses a temp file that I want to delete when I'm done
02:58:04 <[exa]> I thought RAII is implementation of "please don't be java with the nulls"
02:58:24 <mauke> I don't want to introduce a whole new class definition for running 'unlink(file)' at a single point in my code
02:58:43 <ubsan> mauke: that is a very C way of looking at things lol
02:58:56 <mauke> not particularly
02:59:05 <mauke> it applies in other languages as well (e.g. Haskell)
02:59:09 <ubsan> in Haskell, I would use a monad...
02:59:26 <ubsan> to pretend to have linearity
02:59:26 <mauke> in Haskell you could use 'bracket' or 'finally' to do the cleanup
02:59:35 <ertes-w> or Codensity =)
02:59:43 <[exa]> or actual linear haskell :D
03:00:17 <ertes-w> i'd vote for adding Codensity to base =)
03:00:19 <Philonous> [exa], Has that landed in HEAD yet?
03:00:21 <mauke> also, bonus annoyance: in C++ you get to worry about what should happen when you copy objects of your "resource" class
03:00:47 <ubsan> mauke: don't implement copy semantics
03:00:56 <mauke> then you get whatever the compiler is cool
03:01:05 <[exa]> Philonous: not sure but I've heard it works just right
03:01:07 <mauke> which is usually wrong in the presence of a destructor
03:01:10 <mauke> er
03:01:15 <mauke> *then you get whatever the compiler thinks is cool
03:01:17 <ubsan> you know C++11 exists, right?
03:01:22 <ubsan> move semantics yo
03:01:37 <mauke> ah, so now we have to worry not just about copying, but moving as well
03:01:41 <ubsan> (and even then, C++'s implementation of RAII is pretty crap in comparison to, say, Rust)
03:01:49 <[exa]> mauke: you can actually delete the copy constructor now so that the compiler tells you a sad message instead
03:01:51 <ubsan> that doesn't make the concept bad
03:02:02 <[exa]> ubsan: what was your whole point anyway?
03:02:07 <mauke> [exa]: you still have to be explicit about it and remember to delete the copy constructor
03:02:25 <mauke> and then you get to worry about compatibility because older compilers don't support the syntax
03:02:36 <ubsan> [exa]: C is pretty not great, and RAII is good
03:02:50 <ertes-w> what is this even about?
03:02:51 <mauke> I haven't seen RAII outside of C++
03:02:54 <Philonous> ertes-w, Do you have an example of the use of Codensity except for speeding up free monads?
03:03:00 <ubsan> mauke: I just said Rust
03:03:06 <mauke> I haven't seen rust
03:03:08 <ertes-w> @let import Control.Monad.Codensity
03:03:09 <lambdabot>  Defined.
03:03:19 <ertes-w> :t \o c -> Codensity (bracket o c)
03:03:20 <lambdabot> IO a -> (a -> IO b) -> Codensity IO a
03:03:22 <[exa]> mauke: it can behave reasonably to a limit (eg if you have a member with deleted constructors)
03:03:22 <ubsan> okay, then python, C#, and any other language with `with`
03:03:25 <ertes-w> Philonous: ^
03:03:35 <mauke> ubsan: that's very different
03:03:46 <ertes-w> Philonous: the resource you acquire using this action will be freed once you leave the lowerCodensity block
03:03:46 <ubsan> not... really
03:03:50 <Philonous> ertes-w, Ohh, I thought you needed ContT for that. Neat!
03:04:04 <ertes-w> Philonous: Codensity is like a restricted version of ContT
03:04:10 <ertes-w> @src Codensity
03:04:10 <lambdabot> Source not found. Maybe if you used more than just two fingers...
03:04:16 <[exa]> ertes-w: wow cool
03:04:38 <ertes-w> newtype Codensity m a = Codensity { runCodensity :: forall r. (a -> m r) -> m r }
03:04:45 <mauke> ubsan: 'with' is a special language construct. RAII specifically refers to encoding resources as custom types so that initializing a value of that type acquires the resource
03:05:07 <mauke> (and destroying the object releases the resource)
03:05:36 <Philonous> ertes-w, I'll have to play around with this. 
03:05:37 <ubsan> mauke: `with` is an encoding of RAII in a language that does not have it built in from the beginning
03:05:53 <mauke> ubsan: I'd say that's not RAII, then
03:06:06 <ubsan> mauke: okay, you can be wrong
03:06:11 <ubsan> lol
03:06:45 <mauke> I mean, you could sort of squint and say Perl has RAII, even though it's technically construction, not initialization
03:07:26 <ubsan> it feels like this channel has some misguided ideas about language design... and implementation...
03:07:32 <ertes-w> Philonous: c = Codensity (\k -> _)  -- 'k' is the remainder of the action (what follows after 'c'), parameterised on the result of 'c'…  now that that's a first-class value, and that Codensity is delimited by lowerCodensity, you can actually do something *after* 'k'
03:07:47 <mauke> the whole point of RAII was that you shouldn't add special constructs to your code to make sure things get cleaned up (like try/finally, or with)
03:07:52 <ertes-w> Philonous: example: registerFinally c = Codensity (\k -> k () `finally` c)
03:08:59 <ertes-w> Codensity even allows some ContT-like effects: for example you can use 'k' multiple times:  fork :: Codensity (\k -> k () <|> k ())
03:09:08 <ubsan> the whole point of RAII is to make it impossible to forget to clean up stuff
03:09:26 <Philonous> ertes-w, I'll just try to implement shift and reset in Codensity and see where it breaks down
03:09:34 <ubsan> which is really bloody possible in C and functional languages that don't have linear types
03:10:47 <mauke> ubsan: would you say Go has RAII?
03:10:51 * ubsan looks in no uncertain terms at OCaml or Haskell
03:10:52 <Tomsky> Hi all, I'm having stack dependency hell trying to install intero and could use some help is someone is willing?
03:10:54 <ertes-w> Philonous: i don't think that's possible, because Codensity does not support delimiting effects
03:11:06 <ubsan> mauke: no, because defer is not type based
03:11:18 <ubsan> just... go read some papers on linear typing
03:11:20 <ertes-w> Philonous: in particular you can't get the current continuation
03:11:21 <mauke> ubsan: 'with' isn't type based either
03:11:32 <reactormonk> ... how would you debug fusion not happening in a conduit stream? Somehow the constant memory guarantee isn't being held up.
03:11:38 <ubsan> mauke: yes... it is...
03:11:49 <ubsan> you have some sort of interface you implement in order to get cleaned up
03:11:52 <mauke> ubsan: how? python isn't even typed
03:11:59 <Philonous> ertes-w, Ah, I guess because the existential type variable would escape
03:11:59 <mauke> you just call a method on an object
03:12:12 <ertes-w> Philonous: universal, and yes, it would escape
03:12:29 <Philonous> Right, universal
03:12:42 <ubsan> mauke: just go read some papers dude
03:12:55 <ubsan> it's not my job to explain basic substructural type theory to you
03:13:01 <ertes-w> Philonous: but try anyway…  it's useful to understand where Codensity and ContT differ
03:13:14 <ubsan> (and it's also not my job to explain what interfaces are)
03:13:38 <Philonous> ertes-w, Yes, I realize you can't implement them. That much is obvious (otherwise we'd just have ContT again). The point was to see where it breaks :)
03:13:55 <[exa]> ubsan: why would anyone create a mess that needs to be cleaned up in a pure language?
03:14:38 <ubsan> [exa]: I dunno, maybe you want to write to a file
03:14:38 <mauke> defer { do_stuff(); } ... auto r = defer([]{ do_stuff(); });
03:15:04 <ubsan> https://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-IO-Handle.html#v:hClose
03:15:06 <[exa]> ubsan: how does that create mess?
03:15:33 <ubsan> https://hackage.haskell.org/package/system-fileio-0.3.16.3/docs/Filesystem.html
03:15:41 <ubsan> <c-f> openFile
03:16:05 <ubsan> > The Handle should be closed with hClose when it is no longer needed.
03:16:07 <lambdabot>  <hint>:1:69: error:
03:16:07 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
03:16:34 <ertes-w> :t \sel -> Codensity (\k -> let again me = catchJust sel (k me) (again . Just) in again)
03:16:35 <lambdabot> error:
03:16:35 <lambdabot>     • Couldn't match type ‘IO’ with ‘(->) (Maybe a)’
03:16:35 <lambdabot>       Expected type: IO b
03:16:49 <ertes-w> :t \sel -> Codensity (\k -> let again me = catchJust sel (k me) (again . Just) in again Nothing)
03:16:51 <lambdabot> Exception e => (e -> Maybe a) -> Codensity IO (Maybe a)
03:16:55 <ubsan> withFile is an implementation of scope-based dependency management using functions
03:17:05 <ubsan> as opposed to something built into the language
03:17:13 <phaazon> hey, does it make sense to use stack test with --fast?
03:17:19 <phaazon> so that it compiles the binaries with --fast?
03:17:28 <ubsan> and, in fact, can leak the file, so it's strictly worse than linear types or RAII
03:17:30 <ertes-w> Philonous: retry to remainder of the action until it succeeds…  this action returns the last exception that was caught =)
03:17:35 <ertes-w> s/to/the/
03:17:48 <Adeon> most handles are subject to garbage collection
03:17:58 <ertes-w> you can get quite funky with Codensity, and i have used all of that in practice =)
03:18:01 <Adeon> so you could say it'll clean up the mess eventually...but typically you want to be a bit more prompt
03:18:02 <[exa]> Adeon: I wanted him to realize that himself :]
03:18:09 <ertes-w> funky as in funktional =)
03:18:19 <ubsan> for one, don't assume I'm a dude
03:18:27 <[exa]> oh sorry
03:18:27 <ubsan> that's just shitty
03:18:35 * [exa] punishes self
03:18:58 <ubsan> and two, I'm pretty damned sure that the GC doesn't collect non-memory resources
03:19:13 <mauke> ubsan: it does, but it doesn't feel pressured
03:19:20 <mauke> so you can still run out of file descriptors
03:19:32 <ertes-w> ubsan: how did you know that mauke is male?
03:19:47 <ventonegro> And three, it seems this whole discussion has become a nuisance already
03:19:49 <ubsan> ertes-w: I... don't?
03:19:49 <Philonous> ertes-w, Yeah, I've always used ContT for all that. 
03:19:50 <Adeon> handles are closed and garbage collected but some other resource you'd get from C FFI for example clearly is not
03:19:59 <Adeon> but it's possible to use some weak pointers etc. to sort of implement that yourself
03:20:13 <Adeon> so you can have your opaque "handle" to something and attach finalizer to it
03:20:20 <ertes-w> ubsan: in that case you should be sorry as well =)
03:20:20 <mauke> ertes-w: huh?
03:20:31 <ubsan> ertes-w: what?
03:20:34 <ertes-w> "just go read some papers dude"
03:20:42 <ertes-w> SCNR =)
03:20:47 <ubsan> "dude" is gender neutral
03:20:59 <[exa]> this is going technical
03:21:11 <[exa]> plz stop
03:21:24 <ubsan> ah, apparently you have finalizers
03:21:54 <ubsan> that's not really better... but w/e
03:22:06 <ubsan> I mean, it's better than nothing, I guess
03:22:22 <mauke> yeah, finalizers are just a last resort
03:22:23 <ubsan> but it's still not "you can't use a handle after it's been dropped"
03:22:25 <mauke> it's not something to rely on
03:22:30 <ubsan> which is what linear typing nets you
03:22:40 <ubsan> (or RAII, assuming you have no UB)
03:22:51 <mauke> RAII is orthogonal
03:22:58 <ubsan> I disagree
03:23:10 <mauke> with RAII, you can use a handle after it's gone, and you can avoid leaking without RAII
03:23:14 <mauke> e.g. C++ iostreams aren't RAII
03:23:29 <mauke> but you still can't accidentally forget to close them
03:23:43 <ubsan> 1) no you can't? 2) I mean, you can, but not without linearity 3) C++ iostreams are RAII
03:24:14 <ubsan> assuming you don't use an actual C handle, like, you're actually using RAII and move semantics correctly
03:24:15 <mauke> std::ofstream x;  // where's the RA?
03:24:51 <ubsan> oh, that's... people use RAII to mean the scope based resource management part of it
03:25:03 <megaTherion> mauke: default constructor
03:25:09 <ubsan> it's just kind of a meaningless initialism now
03:25:10 <mauke> I use it to mean Resource Acquisition Is Initialization
03:25:21 <ubsan> okay, fine, SBRM
03:25:23 <mauke> megaTherion: the default constructor doesn't A R
03:25:38 <megaTherion> mauke: ?
03:25:46 <ubsan> (acquire resources)
03:25:53 <ubsan> (it's implicitly `optional`)
03:25:58 <megaTherion> depends on the object
03:26:21 <ubsan> unfortunately, C++'s reliance on default initializers mean that many options implicitly include optionality
03:26:25 <knupfer> It seems that in some cases mconcat on a list of lazy texts can be more efficient than appending builders. I'm a bit buffled.
03:26:44 <ubsan> but I don't think that that's a problem with SBRM - just C++'s history
03:26:54 <ubsan> see: Rust, for a language that does it better
03:27:33 <ventonegro> knupfer: Maybe it's fused
03:28:12 <knupfer> ventonegro: nope, I looked at the core and there is still the list.
03:28:54 <knupfer> The list consists of ~1000 texts of length ~4
03:29:05 <knupfer> perhaps a special case with small texts?
03:34:57 <Tomsky> Is it normal for stack to ask for something to be put into extra-deps every time, even just for "stack install intero" and such like?
03:35:10 <Tomsky> Because I'm sure it didn't use to do that ...
03:40:11 <Orbstheorem> Hello, I have `data Direction = North | South | East | West` I would like to create a function `revDir :: Direction -> Direction`, but instead of redefining revDir for every case, is there any way to specify the reverse in the data Declaration? ie. in OOP I'd create an Enum method reverse and pass it's reverse argument in the constructor.
03:41:36 <sphalerite> Is there a nicer way to get a String from a lazy ByteString than (T.unpack . T.decodeUtf8 . B.pack . BL.unpack) where T is Data.Text, B is Data.ByteString, and BL is Data.ByteString.Lazy?
03:41:49 <jollygood2> revDir North is West?
03:42:54 <jollygood2> you could derive Enum
03:44:17 <Orbstheorem> jollygood2: Can you walk me through it?
03:44:28 <Orbstheorem> I'm new to haskell x)
03:45:24 <ventonegro> Orbstheorem: What would you gain by putting the reverse direction directly in the data declaration?
03:46:22 <Orbstheorem> implementing logic in a single place instead of separate locations
03:47:11 <ventonegro> Orbstheorem: You mean putting all logic in the data, like in a... OOP class?
03:47:49 <Philonous> sphalerite, import Data.Text.Lazy as TL; Data.Text.Lazy.Encoding as TL;  then T:.unpack . TL.decodeUtf8 ?
03:48:00 <Philonous> TL.unpack I mean
03:48:16 <sphalerite> aaah, that is nicer, thanks
03:48:19 <ventonegro> Orbstheorem: May I suggest you try the functional approach for a while, until you are more confortable with Haskell?
03:48:53 <Philonous> sphalerite, Or if you want to keep using strict Text you could use BL.toStrict rather than going via an intermediate list of Word8s ;)
03:49:06 <sphalerite> oh yeah
03:49:19 <Orbstheorem> maybe I'm still thinking in OOP-terms, but I can think in situations in which the behavior itself it's independent of the data
03:49:20 <sphalerite> but no, I don't really need strict text
03:50:31 <ventonegro> Orbstheorem: then you can write a polymorphic function
03:52:55 <jgt> in Yesod, how do I flatten out nested Eithers like this? http://sprunge.us/jjih
04:03:46 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | https://summer.haskell.org Summer of Haskell 2017'
04:03:46 --- topic: set by mauke!5lzdiZJQGk@p3m/member/mauke on [Mon Jul 31 05:45:11 2017]
04:10:11 <jgt> cocreature: am I on the right track with this? http://sprunge.us/DCSY
04:11:23 <cocreature> jgt: almost, you’ll have to wripe the "IO (Either …)" in ExceptT instead of using liftIO
04:12:32 <jgt> cocreature: this caught my eye: "It is almost always wrong to wrap an ExceptT, EitherT, or ErrorT around an IO-based transformer stack." from https://www.schoolofhaskell.com/user/commercial/content/exceptions-best-practices#exceptt-io-anti-pattern
04:12:58 <jgt> I'm not skilled enough yet to know whether that is relevant in this case
04:13:37 <cocreature> some people like ExceptT some don’t. but if you have a bunch of "IO (Either …)" and you want to shortcircuit on Left, ExceptT does exactly that
04:15:01 <boj> hmm, i wish i would have known that a few months ago https://gist.github.com/boj/fedd3e9cea6f2fac43eb36806d0c680b
04:16:18 <jgt> this pattern appears a few times in my project. It's really something I need to grok.
04:16:52 <sphinxo> How can I turn (IO Bool, IO Bool) into IO (Bool, Bool)
04:17:16 <sphinxo> something something, join?
04:17:25 <Ferdirand> :t liftM2 (,)
04:17:27 <lambdabot> Monad m => m a -> m b -> m (a, b)
04:17:38 <phadej> :t uncurry (liftM2 (,))
04:17:40 <lambdabot> Monad m => (m a, m b) -> m (a, b)
04:17:57 <Ferdirand> :t uncurry (liftA2 (,))
04:17:58 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
04:18:25 <Philonous> Or less golfed: \(x,y) -> (,) <$> x <*> y
04:18:33 <Philonous> :t \(x,y) -> (,) <$> x <*> y
04:18:35 <lambdabot> Applicative f => (f a1, f a) -> f (a1, a)
04:18:53 <mauke> :t \(mx, my) -> do x <- mx; y <- my; return (x, y)
04:18:54 <phadej> :t \(a,b) -> do { a' <- a; b' <- b; return (a', b') }
04:18:55 <lambdabot> Monad m => (m t1, m t) -> m (t1, t)
04:18:56 <lambdabot> Monad m => (m t1, m t) -> m (t1, t)
04:19:28 <Philonous> With -XApplicativeDo you don't even lose the generality of Applicative 
04:19:32 <boj> sphinxo: there you go, a handful of answers to choose from :)
04:19:39 <sphinxo> :) thanks all
04:19:45 <sphinxo> enough answers for a lifetime
04:20:01 <mauke> @undo \(mx, my) -> do x <- mx; y <- my; return (x, y)
04:20:01 <lambdabot> \ (mx, my) -> mx >>= \ x -> my >>= \ y -> return (x, y)
04:20:27 <badAtRecursion> is there any "general" type in Haskell, so to speak. Say if I wanted to do the exact same thing with two very similar datatypes? 
04:21:31 <sphinxo> badAtRecursion: what do they have in common
04:22:39 <badAtRecursion> sphinxo : I want to write a simple function that return their names, but it looks really ugly to do 2 base cases and 2 lines just to do that
04:22:59 <sphinxo> are they records?
04:23:53 <badAtRecursion> sphinxo they're dna and protein sequences with names
04:23:57 <jollygood2> Orbstheorem, I am no longer sure if you just wanted to avoid manually writing out all the combinations or if you wanted to have OOP style code. if it is the former see this http://lpaste.net/358288 , in this particular case I'm not sure you are gaining much
04:24:55 <sphinxo> badAtRecursion: could you share the datatypes? lpaste.net
04:26:25 <sphinxo> lazy way could be http://www.parsonsmatt.org/overcoming-records/#/3/8
04:27:15 <sphinxo> ( not lazy in the delayed computation way )
04:28:08 <badAtRecursion> Sorry, they're even the same datatype, I'm wondering is if there's a cleaner way of writing this: https://pastebin.com/0fp2UsGW sphinxo
04:28:13 <badAtRecursion> I'm really new to haskell so I
04:28:20 <badAtRecursion> am super noob.
04:29:12 <sphinxo> what are you trying to do?
04:29:15 <mauke> can be simplified to: seqName (DNA x _) = x; seqName (PROTEIN x _) = x
04:29:27 <mauke> not sure why you have 4 cases
04:29:39 <mauke> is this a record type?
04:29:44 <badAtRecursion> the compiler complained about a non exhaustive pattern
04:29:51 <badAtRecursion> What's a record type?
04:30:11 <sphinxo> put seqName _ = "" for the last case and only handle the cases you're interested in
04:30:26 <mauke> are there more than 2 constructors?
04:30:33 <badAtRecursion> Cool, thanks. 
04:31:23 <badAtRecursion> No, mauke. 
04:31:47 <sphinxo> Also in haskell, we generally have datatype constructors as CamelCase(Protein, DNA), rather then ALLCAPS
04:32:06 <sphinxo> ( DNA is different as it's an abbrev.
04:32:16 <badAtRecursion> sphinxo : thanks, I'll make sure to correct that
04:32:31 <mauke> badAtRecursion: can you show your type definition?
04:38:52 <badAtRecursion> mauke it's just data MolSeq = DNA String String | Protein String String, but everything seems to be working properly now.
04:38:55 <badAtRecursion> Really appreciate the help
04:41:17 <Orbstheorem> jollygood2: thanks!
04:41:18 <mauke> data MolSeq = DNA{ seqName :: String, seqData :: String } | Protein{ seqName :: String, seqData :: String }
04:41:28 <mauke> this would be record style
04:41:30 <Orbstheorem> (Sorry, I had lost connectivity)
04:43:12 <JuanDaugherty> dmj`, is #moby about the docker thing?
04:44:26 <JuanDaugherty> (asking here because it's the only place ur not marked away)
04:44:47 <jollygood2> Orbstheorem np. you could try writing a generic rev function that works with any enum. you may need Bounded constraint as well
04:44:57 <badAtRecursion> Ah, cool!
04:58:13 <Jalina> ciao
04:58:15 <Jalina> !List
05:10:17 <jollygood2> foo :: Class a => a -> a     foo x = ..  bar :: <how do I refer to `Class a => a' constraint declared above?  :: a does not work>
05:13:28 <ertes-w> jollygood2: you want to refer to the type 'a'?
05:13:35 <cocreature> jollygood2: enable ScopedTypeVariables and change your type signature to "foo :: forall a. Class a => …"
05:28:09 <jollygood2> sorry I had to answer a call. ertes-w yes. cocreature no way to do it in standard haskell?
05:28:33 <ertes-w> jollygood2: in standard haskell you have to use unification
05:28:36 <ertes-w> :t asTypeOf
05:28:37 <lambdabot> a -> a -> a
05:29:11 <ertes-w> (asTypeOf = const), so you can do something like:  f x = … blah `asTypeOf` x …
05:29:45 <jollygood2> ok, that works too. kind of surprising though that I can't do :: a directly
05:30:01 <cocreature> ScopedTypeVariables is a harmless extension so unless you have a good reason to avoid it, just enable it
05:30:38 <jollygood2> cocreature you're right. but asTypeOf seems to work just as well
05:30:55 <jollygood2> even better, since I don't have to duplicate constraints
05:31:11 <cocreature> "asTypeOf" requires that you actually have something of type "a" which is not always the case.
05:31:28 <cocreature> and even if you have something, I still find it easier to see what’s going on with an explicit type annotation
05:33:06 <Philonous> ertes-w, OK, after banging my head against it for some time and acquiring a Codensity-shaped impression in my forehead I think I have acquired some understanding of how it works and what it can do. Thanks :)
05:34:30 <ertes-w> jollygood2: plus asTypeOf is an actual function, so now you're relying on optimisations to make it free =)
05:35:01 <ertes-w> jollygood2: in general i'd go with ScopedTypeVariables
05:35:02 <jollygood2> yeah.. don't care :)
05:35:19 <jollygood2> no extensions, not repeating constraints
05:35:23 <ertes-w> Philonous: you're welcome =)
05:35:32 <ertes-w> jollygood2: not sure what you mean by repeating constraints
05:36:00 <ertes-w> jollygood2: f :: forall a. (Class a) => a -> a; f x = … (blah :: a) …
05:36:49 <jollygood2> ertes-w, I have to add constraint in the function definition, and then repeat those same constraints in the expression
05:36:58 <ertes-w> jollygood2: no
05:37:16 <ertes-w> @let quadruple :: forall a. (Num a) => a -> a; f x = y + y where y :: a; y = x + x
05:37:17 <lambdabot>  .L.hs:171:1: error:
05:37:17 <lambdabot>      The type signature for ‘quadruple’ lacks an accompanying binding
05:37:25 <cocreature> it’s the same type variable so there is no need to add the constraint explicitely
05:37:29 <ertes-w> @let quadruple :: forall a. (Num a) => a -> a; f x = y + y where { y :: a; y = x + x }
05:37:30 <lambdabot>  .L.hs:171:1: error:
05:37:30 <lambdabot>      The type signature for ‘quadruple’ lacks an accompanying binding
05:38:01 <ertes-w> > let { quadruple :: forall a. (Num a) => a -> a; f x = y + y where { y :: a; y = x + x } } in quadruple 5
05:38:03 <lambdabot>  error:
05:38:03 <lambdabot>      The type signature for ‘quadruple’ lacks an accompanying binding
05:38:11 <ertes-w> d'oh, i'm so stupid
05:38:18 <ertes-w> @let quadruple :: forall a. (Num a) => a -> a; quadruple x = y + y where { y :: a; y = x + x }
05:38:20 <lambdabot>  Defined.
05:38:21 <ertes-w> there
05:38:34 <ertes-w> conclusive proof that it's friday
05:39:42 <Philonous> ertes-w, I'm now trying to puzzle out what we are gaining by restricting ourselves to Codensity instead of ContT. Do you have a hint?
05:40:53 <olligobber> > quadruple 5
05:40:56 <lambdabot>  20
05:41:07 <jollygood2> ertes-w I see. btw, unrelated, is minBound x of an Enum required to be 0? documentation isn't quite clear
05:41:11 <olligobber> ertes-w, yay
05:41:48 <ertes-w> Philonous: Codensity fits the domain better…  firstly a type-level benefit: with ContT, unless you ignore the continuation at some point, there is a redundancy:  ContT R M R
05:41:54 <jollygood2> "Instances of Enum may be derived for any enumeration type (types whose constructors have no fields). The nullary constructors are assumed to be numbered left-to-right by fromEnum from 0 through n-1."
05:42:22 <olligobber> > minBound :: Int
05:42:25 <lambdabot>  -9223372036854775808
05:42:28 <olligobber> that's not 0
05:42:28 <ertes-w> Philonous: secondly a semantic benefit: if you forget to use the continuation with ContT, you effectively ignore cleanup actions
05:42:32 <Philonous> ertes-w, It's only a redundancy if you restrict yourself to effects that fit into Codensity, no?
05:42:44 <ertes-w> Philonous: yes
05:42:59 <ertes-w> Philonous: the following is a ContT effect that Codensity does not allow:
05:43:12 <jollygood2> olligobber good point. what are "nullary constructors" in the quote above?
05:43:16 <ertes-w> :t ContT . pure . const
05:43:17 <lambdabot> r -> ContT r ((->) b) a
05:43:19 <ertes-w> err
05:43:22 <ertes-w> :t ContT . const . pure
05:43:24 <lambdabot> Applicative m => r -> ContT r m a
05:43:35 <ertes-w> Philonous: call that one 'abort', for example
05:43:47 <olligobber> jollygood2, I have no idea
05:43:49 <Philonous> ertes-w, That doesn't actually cancel cleanup actions, does it?
05:43:55 <Philonous> Let me check
05:43:57 <phadej> another way to see it: Codensity doesn't allow any new effect underlying monad doesn't allow
05:45:09 <ertes-w> Philonous: hmm, you might be right
05:45:12 <ertes-w> phadej: it does
05:45:26 <ertes-w> :t Codensity (\k -> k () <|> k ())
05:45:28 <lambdabot> Alternative m => Codensity m ()
05:45:47 <Philonous> phadej, Actually, Codensity turns ReaderT into StateT, for example
05:47:13 <ertes-w> well, AlmostStateT =)
05:47:29 <ertes-w> you need an in-monad effect to get the final state
05:47:43 <Philonous> Well, point is, it allows you to mess with the underlying monad, just not with the return values
05:47:52 <ertes-w> :t Codensity (for [0..])
05:47:53 <lambdabot> error:
05:47:54 <lambdabot>     • Couldn't match type ‘b’ with ‘[b]’
05:47:54 <lambdabot>       ‘b’ is a rigid type variable bound by
05:48:18 <Philonous> for = flip fmap ?
05:48:47 <ertes-w> :t Codensity (\k -> foldr (\x go -> k x *> go) undefined [0..])
05:48:48 <lambdabot> (Enum a, Num a, Applicative m) => Codensity m a
05:48:57 <ertes-w> Philonous: for = flip traverse
05:50:06 <Philonous> ertes-w, I think this makes much more sense in ContT because you can actually collect the result
05:50:57 <ertes-w> sure, sometimes ContT makes sense, but i rarely need it, and Codensity is kinda nice on the type level
05:57:38 <royal_screwup21> I want to find the length of  a list. Suppose I declare len' []=0 and then len' (x,y)=1+y. My question is regarding the "(x,y)" part: how is the list split just like that so that x is the head and y is tail? I mean, what is the logical sense to it?
05:58:44 <royal_screwup21> oops, it is len'(x:y)**, not len' (x,y)
05:59:07 <bvad> (x : xs) = [1,2,3]
05:59:33 <royal_screwup21> oh
05:59:35 <royal_screwup21> I get it now
06:00:05 <royal_screwup21> but...eh never mind
06:00:14 <bvad> But? :)
06:00:58 <royal_screwup21> what if it was (x: y: xs)?
06:01:10 <bvad> > let (x : y : rest) = [1,2,3,4] in print x >> print y >> print rest 
06:01:12 <lambdabot>  <IO ()>
06:01:19 <jollygood2> (:) is a constructor that takes head and tail. so it can also be used as "deconstructor", that splits list into head and tail
06:01:29 <mauke> x : y : z parses as x : (y : z)
06:01:45 <mauke> :t (:)
06:01:47 <lambdabot> a -> [a] -> [a]
06:01:52 <Philonous> royal_screwup21, Your definition had another defect, you are missing the recursive call: len' (x:y) = 1 + (len y) 
06:01:59 <mauke> len'
06:02:06 <Philonous> royal_screwup21, So the way you gave it it wouldn't even type check
06:02:15 <royal_screwup21> Philonous: ah yup thanks for pointing that out!
06:03:33 <royal_screwup21> what if I wanted to grab the first 2 elements as my "head" and leave the rest out as the "tail"?
06:03:48 <brynedwards> :t take
06:03:49 <lambdabot> Int -> [a] -> [a]
06:03:57 <jollygood2> mauke not helpful. he's pattern matching not constructing a list 
06:04:42 <Philonous> royal_screwup21, You can nest pattern matches: foo (x : (y : rest)) = frob x y (foo rest)
06:05:04 <maerwald> mauke: who won the discussion about all that C smacktalk? :>
06:05:17 <Philonous> Because of how (:) associates you're allowed to write that as (x : y : rest).
06:05:23 <Gurkenglas> :t \(Codensity c) s -> c (const return) s -- ertes-w, you need no such effect for execStateT
06:05:25 <lambdabot> Monad m => Codensity ((->) t) b -> t -> m t
06:05:31 <mauke> jollygood2: ???
06:05:59 <mauke> see what Philonous just said
06:06:21 <jollygood2> :t (:) was not helpful
06:06:23 <lambdabot> error:
06:06:23 <lambdabot>     • Couldn't match expected type ‘t0 -> t’ with actual type ‘[a0]’
06:06:23 <lambdabot>     • The function ‘(:)’ is applied to three arguments,
06:06:26 <kim031> am I in the legendary #haskell channel? this is the first time i am using irc
06:06:34 <brynedwards> hi
06:06:41 <maerwald> kim031: yes, all the legends are true
06:06:43 <kim031> hi :)
06:08:25 <mauke> jollygood2: it is if you notice that it's not symmetrical: the first argument is an element but the second argument is a list
06:08:48 <mauke> so in (x : y) x always refers to the first element
06:08:50 <ertes-w> Gurkenglas: well, it depends on whether you consider the argument to 'c' to be an effect
06:09:17 <ertes-w> Gurkenglas: but sure, you don't necessarily need to restrict yourself to lowerCodensity
06:10:34 <Gurkenglas> ertes-w, I don't get the argument that it would be AlmostStateT even though there's a bijection to StateT
06:11:25 <ertes-w> Gurkenglas: read above
06:18:20 <kim031> can anyone suggest some channels for front-end web development? -Newbie
06:26:24 <maerwald> kim031: there are framework specific channels I think, otherwise you might as well ask here 
06:27:33 <maerwald> e.g. #yesod or #snapframework
06:28:43 <tdammers> kim031: #purescript :x
06:29:02 <maerwald> pfft
06:30:40 <tdammers> maerwald: frontend.
06:30:46 <maerwald> yes.
06:30:46 <tdammers> OK, maybe ghcjs
06:30:57 <maerwald> I can do fronted without any of those :>
06:31:17 <tdammers> these days, when folks say 'frontend', they usually mean 'client-side'
06:31:25 <maerwald> yes
06:31:36 <maerwald> html is client side, isn't it?
06:33:11 <Psybur> maerwald, I think the hot thing is templating engines these days :D?
06:33:36 <maerwald> you can do those things with Snap
06:36:24 <tdammers> rendering the HTML is client side. composing HTML on the server is serer-side
06:36:36 <maerwald> yeah
06:37:09 <maerwald> "frontend" doesn't mean there must be js involved though
06:37:23 <ertes-w> haskell has the best templating framework built right into the language: (->)
06:40:49 <maerwald> great... snapframework.com has expired, haha
06:48:07 <Tixik> speaking of FE, does anyone here have experience with building single page apps with haskell? and ideally compare it to react? i have a lot of experience with react, and want to get into haskell, don't know if its a good usecase though
06:49:08 <olligobber> @djinn (a -> b) -> (b -> b -> c) -> a -> a -> c
06:49:08 <lambdabot> f a b c _ = b (a c) (a c)
06:49:47 <olligobber> hmm
06:52:37 <Philonous> :t flip on
06:52:38 <lambdabot> (a -> b) -> (b -> b -> c) -> a -> a -> c
06:52:55 <olligobber> Philonous, woah, wait
06:53:31 <sm> Tixik: it's a frequent topic on haskell reddit
06:55:02 <Ojd> hello, I am wondering if there is any difference in efficiency between list comprehensions and "filter map". E.g., [x*3|x<-[1..10], odd x] vs map (*3) $ filter (odd) [1..10]
06:56:19 <bergey> Tixix: I've done a bit of React & GHCJS, nothing large.  I find static typing is a big win in react-style apps, and it's nice to be able to use the same libraries I know from the backend.  I expect if you're using Flow already, or aren't already using Haskell, that the benefit is less.
06:57:00 <olligobber> Philonous, (compare `on` snd) is what I was looking for, thanks
06:57:57 <ertes-w> Tixik: check out reflex…  while it's a generic FRP library, it's most commonly used with reflex-dom and GHCJS to make web frontends
06:59:20 <ertes-w> Tixik: https://github.com/reflex-frp/reflex-dom
07:00:55 <Tixik> ertes-w: Thanks, ill check it out
07:00:55 <olligobber> Ojd, I don't think there would be significant difference in runtime, especially after compiling
07:01:13 <olligobber> Philonous++
07:05:50 <jakub> can I somehow check how a dependency is pulled into my cabal project? i created a sandbox yesterday and it works great, today i set up another sandbox on another computer and all of a sudden one of the dependencies fails to build, turns out that dependency is pulled in only in the new sandbox (transitively over some other dependency), how can I know who causes this package to be pulled in (btw its 
07:05:56 <jakub> semigrupoids that fails to compile due to some bifoldable instance)
07:06:20 <michalrus> Hey, I’d need to have `instance Serialize UUID`, but I’m not the owner of uuid nor of cereal, and Haskell warns me about orphan instances. What to do here?
07:08:04 <jakub> michalrus: wrap in a newtype?
07:08:50 <michalrus> But that’s inconvenient. Now use sites have to take this wrap into consideration, while the need for Serialize is only a small use case. :(
07:08:59 <Ojd> thanks olligobber
07:09:13 <olligobber> Ojd, actually, now I'm not sure
07:09:16 <cocreature> michalrus: if you’re writing an executable and not a library, you don’t need to worry too much about the warning
07:09:21 <michalrus> jakub: regarding you question, that’s probably an overkill, but you could use Nix for your Haskell projects. https://github.com/Gabriel439/haskell-nix
07:09:30 <sm> jakub: you can ghc-pkg unregister it and see which packages ghc-pkg warns about
07:09:32 <michalrus> cocreature: oh, OK. :)
07:10:00 <olligobber> Ojd, I think the list comprehension is more likely to be optimal
07:10:02 <jakub> sm: it is the first install, i presume there is not yet any user of the library
07:11:54 <sm> well, something has probably pulled it
07:14:14 <jakub> sm: yeah, in the end my cabal project, but the first cabal install --dependencies-only fails to build one of the packages in the "pipeline", so what is broken is my package in the end but how do i find what dependency that I directly use causes this package to be pulled in, when I know for a fact that dependency is not vital
07:14:34 <jakub> (i.e. some other versions can be used to not require semigrupoids at all)
07:15:15 <ertes-w> language extension proposal:  add a variant of 'newtype' with implicit coercion
07:15:47 <Psybur> When I want to add an extra dependency to my stack project from hackage, do I have to modify both stack.yaml and my .cabal file every time? I can't just do it in one spot? Or is there a stack tool that will update the cabal file for me after I update the yaml file?
07:15:49 <infandum> Can I write a function that takes in any binary tree of type (Tree a = Leaf a | Node (Tree a) (Tree a))? Like f (_ x) = blah; f (_ x x) = blah?
07:16:19 <infandum> Because there are a lot out there, just with different names
07:17:01 <brynedwards> Psybur: If the dependency is in the stackage list, you can just put it in your .cabal file. If it isn't, you'll also need to add it to extra-deps in stack.yaml.
07:17:22 <ertes-w> infandum: if you write a class for it, then you can use ViewPatterns
07:17:34 <ertes-w> infandum: but note that you're giving up performance in exchange
07:18:26 <ertes-w> infandum: alternatively pick a generic representation and convert others to/from it
07:18:30 <cocreature> infandum: it kind of sounds like you are looking for a way to write functions that only take into account the shape of a datatype. for that you can use GHC.Generics or one of the other generics solutions, e.g. generics-sop but it’s not as straightforward as you might hope
07:18:37 <brynedwards> Psybur: this should explain what I mean in more detail https://docs.haskellstack.org/en/stable/GUIDE/#adding-dependencies
07:18:43 <ertes-w> infandum: yet another alternative: use generics
07:19:05 <infandum> cocreature: Yeah, exactly that. Why would it not be straightforward?
07:19:59 <cocreature> infandum: because solving that problem in general instead of only for trees as GHC.Generics tries to do is not easy so the API is a bit complicated
07:20:12 <infandum> ah
07:20:58 <ertes-w> infandum: and yet another option: use traversal APIs that fit your problem…  for example you can use Foldable, Traversable, Monad (yes, your Tree type is a monad), and also lenses and traversals
07:21:50 <infandum> ertes-w: I was thinking about that, but the type of one of the trees to convert (Dendrogram from hierarchical-clustering) has a traversable instance that keeps the names "Leaf" and "Branch", hard coded in
07:22:52 <infandum> The foldable does not, however...
07:23:28 <Psybur> brynedwards, thanks
07:24:39 <jakub> sm: I geniunely do not follow how I should check and track the dependencies
07:28:17 <olligobber> on is so useful :o
07:29:10 <ertes-w> infandum: what do you mean?
07:31:09 <ertes-w> infandum: the Traversable instance does exactly what i'd expect, according to the source code
07:31:54 <sm> jakub: it can be tricky, but I don't understand your situation. You have a package A currently listed by ghc-pkg list ? If you ghc-pkg unregister it, that will show what caused it to be installed
07:34:13 <jakub> sm: no, as I said, the package failed to compile, so it cannot be registered
07:34:39 <infandum> ertes-w: Yeah, but it doesn't look like I can convert one traversable to another, it needs to stay the same
07:38:50 <ertes-w> infandum: yes, that's not what Traversable is for…  you can use Iso from the lens package for that
07:39:16 <infandum> ertes-w: Interesting...
07:39:22 <sm> jakub: why does it fail to compile ?
07:39:27 <ertes-w> Traversable is for structure-preserving maps with effects
07:39:41 <jakub> sm: i have no pkgs, i start pulling dependencies of a cabal project and at some point one of the dependencies fails to compile, i want to find out why the package got selected for installation
07:39:53 <sm> what is the package ?
07:40:28 <jakub> sm: dont see why it matters but some instance was missing
07:40:38 <infandum> Boy that is a complex api
07:40:41 <sm> http://packdeps.haskellers.com/reverse/PKG might give some ideas
07:41:42 <ertes-w> infandum: yes, lens has a learning curve, but if you want to learn it, i can offer a few short exercises that should get you started
07:41:49 <jakub> sm: ok i was asking for an automated way that would find the specific pkg in my scenario
07:42:10 <infandum> ertes-w: I familiar with the basics of lens, I never went into Iso
07:42:28 <jakub> surely cabal knows why it pulls in a pkg, are you telling me there is no way to print that info out?
07:42:30 <ertes-w> infandum: Iso is like a Lens that is fully information-preserving, so you can go in both directions
07:43:47 <ertes-w> infandum: for example 'swapped' is an Iso
07:43:52 <sm> jakub: I am eliciting information to help me give more useful advice
07:43:53 <ertes-w> > (2, 3) ^. swapped
07:43:55 <lambdabot>  (3,2)
07:44:07 <sm> as I said, it can be tricky
07:44:07 <ertes-w> err, not a good example
07:44:51 <infandum> (1,3) ^.. each
07:44:59 <infandum> something like that?
07:45:00 <Psybur> If we look in the main method definition first code example, we see a "do" block where the first operation looks like a lens setter. And I the "def" function is returning a default plot. I believe this "default plot" is whats being modified in the "do" block. Is this accurate?
07:45:00 <ertes-w> infandum: better example: _polar is an Iso (modulo floating point imprecision)
07:45:05 <Psybur> https://github.com/timbod7/haskell-chart/wiki/example-4
07:45:20 <ertes-w> > (2 :+ 3) ^. _polar
07:45:22 <lambdabot>  (3.605551275463989,0.982793723247329)
07:45:34 <ertes-w> > (3.605551275463989,0.982793723247329) ^. from polar
07:45:36 <lambdabot>  error:
07:45:36 <lambdabot>      • Couldn't match type ‘(Double, Double)’
07:45:36 <lambdabot>                       with ‘Control.Lens.Internal.Iso.Exchange
07:45:58 <ertes-w> > (3.605551275463989,0.982793723247329) ^. from _polar
07:46:00 <lambdabot>  2.0 :+ 3.0
07:46:34 <ertes-w> infandum: 'from' turns an Iso around into its inverse
07:46:40 <infandum> And what if there is information loss?
07:46:52 <ertes-w> then you need a Lens
07:47:14 <infandum> Cause I'm only going one direction
07:47:32 <ertes-w> because you *can* only go one direction
07:47:40 <ertes-w> (2, 3) ^. _1
07:48:00 <ertes-w> > (2, 3) ^. _1  -- there is no way to invert _1 such that it could turn 2 back into (2, 3)
07:48:02 <lambdabot>  2
08:16:13 <Ojd> I have been working on several things to practice what I have learn so far in Haskell (not a lot, honestly). Today I start looking at games, based on a Lips book called "Land of Lisp"
08:16:51 <Ojd> I was able to implement the simplest game over there, but I got a strange message from ghc
08:17:23 <Ojd> here is my source code for the game https://bitbucket.org/lijantropique/landofhaskell/src
08:17:45 <Ojd> and the message I got is about shadowing (it is actually a warning)
08:18:15 <c_wraith> can you put the full message on lpaste or something?
08:20:00 <c_wraith> Ojd: oh, I guess I see it anyway.  the x and y variables on line 33 shadowing the x and y variables on line 21
08:20:05 <Cale> Ojd: It's because you're using otherwise as a variable
08:20:19 <c_wraith> Oh, that's happening too.
08:20:19 <Cale> wait what?
08:20:23 <Ojd> chapter2.hs:28:9: warning [-Wname-shadowing] This binding for 'otherwise' shadows the existing binding imported from 'Prelude' at chapter2.hs:1:1 (and originally defined in 'GCH.Base')
08:20:46 <Cale> Ojd: Just use _ -> ...
08:20:51 <c_wraith> err, not too.  I was wrong, Cale got it.
08:20:59 <c_wraith> somehow I totally misread line 33
08:21:15 <Cale> Ojd: That's not a guard, any name you put there will be defined to be equal to reply
08:21:28 <Ojd> Ohhh I see now
08:21:32 <Ojd> thanks :)
08:22:55 <c_wraith> (This is why it's important to actually have the text of the error message.  Preferably the *full* text, because the output isn't just there to amuse the compiler writers - it provides information about what went wrong)
08:27:20 <royal_screwup21> suppose you have int a=20. Doing something a++"greater than 10" returns an error ( https://thepasteb.in/p/mwh1NDW0Mnqs5) I think it's because a is supposed to be an integer and I need to typecast it to a char? I'm not sure. Nevertheless, how do I make it so that I get "20 is greater than 10"?
08:28:46 <ertes-w> royal_screwup21: 'show' converts things that can be rendered as a String to a String
08:28:54 <ertes-w> > 20 ++ " greater than 10"
08:28:56 <lambdabot>  error:
08:28:56 <lambdabot>      • No instance for (Num [Char]) arising from the literal ‘20’
08:28:56 <lambdabot>      • In the first argument of ‘(++)’, namely ‘20’
08:29:01 <ertes-w> > show 20 ++ " greater than 10"
08:29:03 <lambdabot>  "20 greater than 10"
08:40:16 <Orbstheorem> Hello, I'd like to find a function of signature (Bool -> a -> Maybe a) that returns Just a if Bool is true or Nothing if false. I know I can extract this in a where and use guards, but I was wondering if there's a one liner for it. My original problem is has signature (Bool -> a -> a -> a (the ternary operator '?')), but I figured that I could use fromMaybe and reduce it to my former question.
08:40:40 <Orbstheorem> I tryed hoogle, but the closest I get is assert, which is not what I want
08:41:01 <Orbstheorem> s/problem is has/problem has/
08:41:08 <lyxia> @pl \b x -> when b (pure x)
08:41:08 <lambdabot> (. pure) . when
08:41:21 <ertes-w> > 5 <$ guard True
08:41:24 <lambdabot>  error:
08:41:24 <lambdabot>      • Ambiguous type variables ‘f0’, ‘a0’ arising from a use of ‘show_M43810...
08:41:24 <lambdabot>        prevents the constraint ‘(Show (f0 a0))’ from being solved.
08:41:30 <ertes-w> > 5 <$ guard True :: Maybe Integer
08:41:31 <lambdabot>  Just 5
08:41:33 <ertes-w> > 5 <$ guard False :: Maybe Integer
08:41:35 <c_wraith> :t \b x -> guard b >> pure x
08:41:35 <lambdabot>  Nothing
08:41:37 <lambdabot> (Alternative m, Monad m) => Bool -> b -> m b
08:41:50 <c_wraith> Oh, right.  <$ is better anyway
08:42:42 <ertes-w> Orbstheorem: Maybe is kind of like Bool on steroids…  the idea is to just convert the Bool to a (Maybe ()) and then use Maybe combinators
08:43:37 <c_wraith> Orbstheorem: for what it's worth, if you can avoid ever having had a Bool in the first place, that's even better.
08:43:43 <ertes-w> (<|>) is Maybe's version of (||), and (<*>) is Maybe's version of (&&)
08:43:56 <ertes-w> and (<$) replaces the value in the case of Just
08:44:41 <joe9> Does anyone know where the paper describing this https://github.com/osa1/StrictCore is at? the Readme mentions a paper. but, I could not find the paper from the web search.
08:45:40 <eschnett> Orbstheorem: i would define a function “ifthen c x y = if c then x else y”
08:46:04 <Orbstheorem> c_wraith: I have some data with lenses and I want to return a modified version of it only if a property is true. I don't see how to match the property
08:48:39 <osa1> joe9: https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/tacc-hs09.pdf
08:49:31 <mnoonan> Orbstheorem, hoogle 5 (I think? the one at hoogle.haskell.org) turns up toMaybe :: Bool -> a -> Maybe a in utility-ht
08:49:54 <ertes-w> Orbstheorem: 'filtered'?
08:49:57 <c_wraith> Orbstheorem: you might be able to use filtered
08:50:19 <joe9> osa1: cool, thanks.
08:50:26 <ertes-w> > let makeOdd = _Just . filtered even +~ 1 in (makeOdd 5, makeOdd 6)
08:50:29 <lambdabot>  error:
08:50:29 <lambdabot>      • Ambiguous type variable ‘b1’ arising from a use of ‘show_M228627736094...
08:50:29 <lambdabot>        prevents the constraint ‘(Show b1)’ from being solved.
08:50:47 <ertes-w> > let makeOdd = _Just . filtered even +~ 1 in (makeOdd (Just 5), makeOdd (Just 6))
08:50:49 <lambdabot>  (Just 5,Just 7)
08:51:34 <joe9> osa1: would you mind adding the paper to the github repo, please? The Readme refers to the paper and it would be convenient to have the paper in the repo to refer to.
08:52:05 <osa1> joe9: I was about to do that :) I'm thinking about where to add it
08:52:20 <osa1> maybe right below the title saying that the paper mentioned below is this paper ...
08:52:57 <dghsh> hi, understanding that a haskell-program like xmonad can be run without haskell onboard, is it possible to run pandoc statically compiled without 2.5gb of haskell ? I would use it exclusively for converting ebook(epub,mobi,azw,djvu) into pdf or ps. thanks
08:53:10 <joe9> osa1: you could add it to the Readme. I was thinking about adding the paper as a file in the repo.
08:53:46 <osa1> joe9: OK yeah let's do both
08:54:51 <joe9> osa1: btw, is the effort discontinued? what happened? It seems to be a good idea.
08:55:16 <wz1000> I have x :: (Maybe a) and f :: a -> IO (Maybe b). is there any nicer way to compose this than fmap join <$> traverse f x
08:55:37 <brynedwards> dghsh: what OS are you installing pandoc on?
08:55:40 <c_wraith> wz1000: do you count using MaybeT as nicer? :)
08:55:48 <wz1000> I mean join <$> traverse f x
08:56:02 <osa1> joe9: I think it's a great idea that's worth pursuing but I have no time or energy to work on that anymore unfortunately. I have other things to do these day (since moved from academia to industry a 9 months ago)
08:56:11 <wz1000> c_wraith: not really...
08:57:20 <joe9> osa1: ok, Thanks.
08:58:40 <osa1> joe9: pushed the paper to the repo and updated the readme
08:58:55 <wz1000> @pl \f x -> join <$> traverse f x
08:58:56 <lambdabot> ((join <$>) .) . traverse
09:00:15 <joe9> osa1: if you think of any pointers that would help me get upto speed, please feel free to share with me. I like the idea of a typed core and am interested in learning about it.
09:01:17 <c_wraith> wz1000: more or less, if it's one-off, I'd just do what you have.  If things keep happening involving Maybe values in IO, I'd use MaybeT
09:01:39 <dghsh> sorry my connection is very bad, join again later...
09:02:04 <osa1> joe9: the idea was introduced with the paper I just checked in to the repo, and AFAIK no relevant work done after that. so it's pretty much an unxplored path I think. are you a grad student by any chance?
09:03:28 <joe9> osa1: no, a hobbyist. I was exploring the idris IR and the ghc core and found that it would be a lot more helpful if the types were maintained instead of erased.
09:04:53 <osa1> joe9: are you at ICFP right now? it's actually a tradeoff, some optimizations are not easy (or impossible) to do in a type-preserving way. but yeah I agree that StrictCore is really cool.
09:05:49 <joe9> osa1: no, not at ICFP. ok, Thanks.
09:11:52 <Orbstheorem> what's the difference between (https://www.haskell.org/hoogle/) and (hoogle.haskell.org)?
09:12:19 <Orbstheorem> mnoonan, ertes-w thanks!
09:14:34 <phaazon> trivial question: flip fmap?
09:14:44 <phaazon> :hoogle flip fmap
09:14:49 <phaazon> @hoogle flip fmap
09:14:50 <lambdabot> No results found
09:14:51 <phaazon> :(
09:17:39 <chelfi2> phaazon: si tu acceptes lens, https://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Operators.html#v:-60--38--62-
09:17:49 <chelfi2> oups
09:17:51 <phaazon> chelfi2: on a lens, donc… ouais :D
09:17:52 <chelfi2> I meant
09:18:11 <chelfi2> If you can depend on lens, you can use https://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Operators.html#v:-60--38--62-
09:18:36 <chelfi2> pardon my french
09:18:56 <phaazon> :)
09:21:15 <mnoonan> phaazon, <&> maybe?
09:21:30 <phaazon> yep, thanks guys
09:22:07 <mnoonan> Orbstheorem, I think the www.haskell.org/hoogle one is hoogle 4, and the other is hoogle 5. it's kind of a coin flip which one gives better results, it seems
09:32:22 <royal_screwup21> where am I going wrong with this function https://thepasteb.in/p/KOh85mMmKE9SJ I'm getting the error : parse error on input ‘=’
09:32:48 <raichoo> bgamari: Hi, did you find out that the exact issue is?
09:33:51 <bgamari> yes
09:35:43 <bgamari> raichoo, ^
09:36:45 <dsal> royal_screwup21: What's giving you that error?
09:37:11 <raichoo> bgamari: What was it then ^^. Can't see anything in my backlog.
09:40:02 <royal_screwup21> dsal I'm not sure I understand :(
09:40:25 <dsal> royal_screwup21: You said you're getting a parse error.  What are you getting it from? 
09:41:19 <royal_screwup21> I think it's the compiler - because when I type in :l <filename>, I get that error
09:41:38 <dsal> What's the filename?
09:42:32 <dsal> I just pasted the content of your paste into a file, opened up ghci, and ":l thing.hs" and it works fine.
09:42:33 <royal_screwup21> initials.hs
09:42:44 <royal_screwup21> wha
09:43:33 <royal_screwup21> I'm using GHCi, version 7.10.3: for what it's worth
09:43:50 <monochrom> At this point it shouldn't matter whether you call it thing.hs or initial.hs
09:45:23 <dsal> Yeah.  It'd matter if it were... something else.
09:45:26 <royal_screwup21> haskell isn't indentation dependent, right?
09:45:37 <dsal> I was getting -Wall complaints about tabs.
09:45:58 <monochrom> It is. But it works for us. Cannot reproduce error.
09:49:05 <royal_screwup21> shite it's the tab
09:49:09 <raichoo> bgamari: And even more interesting… how did you debug it :) I've learned a lot in the process but I'm not sure how to make it better. Was is even on the right track?
09:49:22 <royal_screwup21> changed it to spaces and it works now
11:09:37 <bollu> Does anyone have a good name for this combinator?
11:10:04 <bollu> weaveEffect :: (Traversable f, Applicative f, Monad t, Traversable t) => (a -> f (t b))
11:10:14 <bollu> argh
11:10:15 <bollu> weaveEffect :: (Traversable f, Applicative f, Monad t, Traversable t) => (a -> f (t b))
11:10:15 <bollu>   -> t a -> f (t b)
11:10:32 <bollu> @djinn  (Traversable f, Applicative f, Monad t, Traversable t) => (a -> f (t b)) -> t a -> f (t b)
11:10:32 <lambdabot> Error: Class not found: Traversable
11:10:35 <bollu> o_O
11:10:42 <bollu> how does djinn not know traversable?
11:11:52 <geekosaur> there's a lot djinn doesn't know
11:12:02 <geekosaur> :exf "(Traversable f, Applicative f, Monad t, Traversable t) => (a -> f (t b)) -> t a -> f (t b)"
11:12:03 <exferenceBot> \ f1 b -> sequenceA (b Control.Monad.>>= (sequenceA . f1))
11:12:31 <bollu> https://www.reddit.com/r/haskell/comments/6ywhw6/what_is_this_combinator_called/
11:12:34 <bollu> Hm, yes
11:12:34 <geekosaur> in particular, djinn doesn't know about recursive data types
11:12:42 <bollu> but, well, is there some common name for this?
11:20:21 <Psybur> How would I turn an IO (a) into an IO ()?
11:21:35 <monochrom> x >> return ()
11:21:39 <athan> Psybur: if `foo :: IO a`, then `fmap (const ()) foo :: IO ()`
11:22:00 <athan> or `() <$ foo` for extra legibility
11:22:06 <monochrom> @type void
11:22:08 <lambdabot> Functor f => f a -> f ()
11:22:13 <monochrom> @type Data.Functor.void
11:22:15 <lambdabot> Functor f => f a -> f ()
11:22:33 <monochrom> void does that for you, too.
11:22:43 <monochrom> Usage: void x
11:23:19 <Psybur> Thanks a lot
11:23:28 <Psybur> I finally got a chart written >.>
11:26:20 <monochrom> @type void null
11:26:22 <lambdabot> Foldable t => t a -> ()
11:26:26 <monochrom> :)
11:26:49 <monochrom> @type null . void
11:26:51 <lambdabot> (Functor t, Foldable t) => t a -> Bool
11:27:18 <monochrom> > null (void Nothing)
11:27:21 <lambdabot>  True
11:31:10 <Psybur> Anybody know of any good clustering algorithms that can give me a list of centroids of clusters?
11:31:23 <Psybur> Rather, the above but implemented in haskell
11:31:34 <average> k-means?
11:32:01 <average> its resource intensive tho. the best implmentations are in C
11:32:09 <average> imo, better call it from Haskell
11:32:58 <average> Psybur: what will you do with the results after you get them?
11:33:31 <monochrom> average is an expert on averages :)
11:33:46 <Psybur> Basically Im attempting to draw support/resistance lines on a price history chart
11:34:19 <Psybur> And seeing if I can find a clustering algorithm that can find these lines
11:34:38 <average> isnt that called regression?
11:34:40 <Psybur> I saw this, but its for python. http://jon.io/machine-beats-human-using-machine-learning-in-forex.html
11:35:00 <Psybur> The meanshift library in hackage doesnt quite look the same
11:35:54 <average> if you see the word ml in an article, that should ring some alarm bells if not accompanied by detailed explanation, analysis , proofs
11:36:06 <average> i would throw away most things labelled ML
11:36:41 <average> Psybur: anyway, I recommend looking into regression
11:36:53 <average> also define your terms, what is "support line"
11:37:11 <average> this is domain specific, has nuthin to do with haskell
11:37:19 <average> haskell is just some programming language
11:37:53 <Psybur> Yes, support/resistance lines are horizontal lines where the price seems to return to frequently
11:38:18 <Psybur> Support is where the price resists going down, and resistance is where the price resists going up anymore
11:39:52 <Psybur> So these areas would create a cluster. If I get the centroid and put a horizontal line there I'd be able to draw a support or resistance line for that area
11:40:59 <Psybur> I might play around with kmeans
11:41:09 <Psybur> It doesnt really need to be fast (at least for now)
11:43:07 <dmwit> monochrom: Yeesh, I had to think for too long to figure out what `void null` does. (Well, I mean, *why* it does it. The type is pretty clear about *what* it does.)
11:44:42 <monochrom> teeheehee!
11:47:31 * jared-w is currenty learning JavaScript and php
11:47:38 <jared-w> Every day I stray further from god's light ಠ_ಠ
11:48:38 <monochrom> Learn Purescript for redemption. Bonus: Its file extension is "purs" --- cute eh?
11:51:20 <geekosaur> . o O { https://xkcd.com/224/ }
11:51:33 <jared-w> Still one of my favorites
11:52:08 <jared-w> Another is this quote "If God was using Haskell, he could've put the whole universe together in an hour but instead he thought to himself 'real programmers use C' and it took the whole damn week"
11:52:35 <hvr> oh that's why it's so buggy?!
11:52:58 <jared-w> You didn't seriously think platypuses and tapirs were, like, the original design did ya? :p
11:53:58 <monochrom> hvr: No. It's why the universe has quantum entanglement >:D
11:54:38 <jared-w> Hey quantum entanglement is fukkin beautiful
11:55:36 <pikajude> void null, huh
11:55:44 <pikajude> does void take a function and make it return ()
11:56:01 <dolio> Not just a function.
11:56:05 <pikajude> well
11:56:11 <pikajude> i mean, null is a function
11:56:17 <pikajude> i know what void does
11:56:18 <dolio> Yeah.
11:56:22 <pikajude> i just don't remember how (->) works
11:57:00 <pikajude> other than that `join foo` applies foo to 2 of the same argument
11:57:17 <dolio> I mean, the thing that void changes is the result position for functions.
12:03:15 <monochrom> > void null (undefined :: [Int])
12:03:18 <lambdabot>  ()
12:03:56 <Psybur> Dang kmeans is slow Dx
12:05:29 <mniip> :t void
12:05:30 <lambdabot> Functor f => f a -> f ()
12:27:37 <c_wraith> monochrom, cute choice of functor
12:29:00 <monochrom> hehe
12:31:35 <c_wraith> > void show ()
12:31:37 <lambdabot>  ()
12:31:51 <c_wraith> look, it voided the show operation!
12:31:56 <shapr> :t void
12:31:58 <lambdabot> Functor f => f a -> f ()
12:39:27 <Psybur> average: So here's what I am talking about support/resistance lines: https://pasteboard.co/GJsw3sJ.png
12:39:52 <Psybur> I used kmeans to generate the y values for those lines
12:40:47 <average> hm ok
12:41:56 <Psybur> And kmeans is actually pretty fast for what Im doing at the moment. I accidentally had a freak mapping accident earlier that was taking forever :D
12:45:51 <average> mkay
12:46:32 <average> Psybur: btw, thanks for not shoving me into Haskell terminology and keeping it real while we talked about this
12:46:36 <average> I appreciate that :)
12:48:39 <Psybur> Haha no problem. You think another person would be sneaky about their using a clustering algo to find these lines on price charts? heh
12:49:01 <average> it's a bit sneaky too yeah, which is nice
12:50:26 <dfeuer> @ask edwardk What do you think of https://github.com/ekmett/free/pull/164/files
12:50:26 <lambdabot> Consider it noted.
12:59:25 <hongminhee> I have a question. Is there any way to limit every instance of typeclass' associated type must be an instance of Eq/Ord?
13:00:02 <c_wraith> hongminhee, you can add that constraint to the members of the class.
13:01:01 <hongminhee> How the syntax for that does look like? (Or could you give a keyword for searching resources to learn them?)
13:01:35 <c_wraith> hongminhee, class Foo a where type Bar a ; baz :: (Eq (Bar a)) => a -> Bar a -> X
13:02:04 <c_wraith> hongminhee, the important part is that you can add that constraint where it is needed.
13:03:03 <hongminhee> Thanks!
13:03:52 <sellout-> Ok, seriously diving back into Haskell after ~three years away … I see there are at least a couple yacc-is-dead parsers around (derp, robrix/derivative-parsing). Do either of those (or perhaps one I’m not aware of) implement the performance improvements from last year (http://dl.acm.org/citation.cfm?id=2908128)?
13:05:08 <reptar_> do anyone know of a simple way to convert from "YYYY-MM-DD" to day of week?
13:13:24 <sm> reptar_: combination of Data.Time.Format parseTime and Data.Time.Calendar.WeekDate toWeekDate
13:14:32 <reptar_> sm: was tipped of this http://rosettacode.org/wiki/Day_of_the_week#Haskell
13:14:45 <reptar_> but thank you
13:14:51 <sm> np
13:15:32 <sm> yikes. appveyor: "Cache 'C:\Users\appveyor\AppData\Local\Programs\stack' - Zipping...Compressed cache item cannot exceed 1,048,576,000 bytes."
13:15:44 <shapr> !
13:16:17 <sm> a windows stack binary is not that big, is it ? GHC 8.2.1 ?
13:16:27 <Strenn> Hey everyone
13:16:51 <shapr> sellout-: is there an author's website version of that paper?
13:17:16 <Strenn> I have a question about the isomorphism of n-graphs to lists and its implications on haskell
13:17:34 <sellout-> Yes, sorry – I just copied the link from elsewhere, didn’t realize it was the ACM URL.
13:17:46 <sellout-> https://michaeldadams.org/papers/derivatives2/
13:17:49 <MarcelineVQ> sm: you're sure that's a program, not the stack folder? because the stack folder is easily larger than that
13:18:14 <MarcelineVQ> sm: just the hackage indicies approach that size :X
13:19:19 <sm> MarcelineVQ: note sure at all, that could be it
13:19:26 <sm> s/note/not/
13:19:32 <Strenn> So as we all know, graphs on n vertices can be uniquely represented as lists of length n^(n-2)
13:19:50 <Strenn> using this equivalence, has anyone constructed a monad instance for graphs?
13:19:59 <Strenn> or a traversable instance?
13:20:23 <sm> thanks. Sounds like building with multiple stack resolvers on free appveyor isn't going to work
13:20:27 <Strenn> since the n^(n-2) cayley encoding of a graph requires a well ordering on the set of vertices we can add a constraint of Ord a for those instances
13:20:53 <sm> or, caching anyway
13:21:42 <Psybur> Lets say I have a: data E = A | B | C
13:22:01 <Psybur> How would I convert "A" into A if E doesnt derive Read
13:22:26 <StrangeLoop> Hi, newbie question, what does $= do? I saw it in some code and I don't know how to google that...
13:22:38 <Tuplanolla> @hoogle ($=)
13:22:39 <lambdabot> Data.Conduit ($=) :: Monad m => Conduit a m b -> ConduitM b c m r -> ConduitM a c m r
13:22:39 <lambdabot> Data.Conduit.Internal ($=) :: Monad m => Conduit a m b -> ConduitM b c m r -> ConduitM a c m r
13:22:39 <lambdabot> Data.StateVar ($=) :: (HasSetter t a, MonadIO m) => t -> a -> m ()
13:22:58 <lyxia> Psybur: by hand
13:23:12 <Psybur> lyxia, :{
13:23:22 <Strenn> the one thing I dislike about the haskellian culture is package writers inventing obscure operators
13:23:25 <Tuplanolla> Look for Conduit, StrangeLoop.
13:23:36 <Strenn> you see some weird character combinations in code and can't make sense of it
13:23:56 <StrangeLoop> Thanks
13:24:36 <sm> you can search for em in hoogle
13:26:05 <c_wraith> Strenn, how is that different from seeing a sequence of letters that doesn't mean anything to you?
13:27:03 <Tuplanolla> I don't much like operators either, because I can't chant them, Strenn.
13:28:30 <geekosaur> gregorian haskell?
13:29:38 <Strenn> sequences of letters can convey meaning
13:29:51 <Strenn> if I name my function huhwduaweiuh it is equally bad and I should be ashamed
13:30:33 <Strenn> making it an infix operator and calling it %==> is no better
13:31:05 <MarcelineVQ> hmm? it's lot better, there's less letters to remember
13:31:47 <Strenn> sure, if I want to use a shorthand infix notation I can
13:31:58 <Strenn> but if I don't use comments to clarify what function it refers to
13:32:04 <Strenn> I'm doing a disservice to anyone reading the code later
13:33:18 <Strenn> if I import 10 libraries and then use the %==> operator, will you look through all 10 libraries to find out what it is?
13:33:32 <MarcelineVQ> I'm not sure I agree there, but I do think eveyone's code should have more comments in general
13:34:27 <Strenn> however, if you see a function named "cobind" you'll know it probably comes from Control.Comonad
13:34:49 <Strenn> and the best is if you see =>> with a comment after its first usage clarifying that it's from Control.Comonad
13:35:37 <Strenn> so I'm wondering about those trees
13:35:54 <Strenn> originally the issue with giving them a traversable instance was that you'd have to arbitrarily choose if you wanted to traverse them inorder, postorder or preorder
13:36:31 <Strenn> but if you treat them as their equivalent list counterparts using the cayley encoding, you are basically outsourcing that arbitrary decision to the choice of ordering noted by the "Ord a" constraint
13:36:36 <sellout-> Strenn: Can’t you see the doc/type/origin on hover or with some keybinding?
13:36:50 <sellout-> That’s a sincere question, because I haven’t worked with Haskell tooling in a while.
13:37:01 <Strenn> I use Atom with some extensions
13:37:01 <shapr> hoogle helps
13:37:18 <Strenn> if there's a thing for Atom that provides that kind of functionality, I'd love to know about it
13:37:32 <MarcelineVQ> "<Strenn> if I import 10 libraries and then use the %==> operator, will you look through all 10 libraries to find out what it is?" If I'm working on the code you wrote I should be expected to know or learn what's in the libs you used, yes. What if cobind is really from Data.Encoder.Foo? Or Jazz.Type.Glue? Why is an opertor more mysterious somehow? It's the same process to search for either. I do agree that comments are awesome.
13:38:08 <MarcelineVQ> you can use ghc-mod with Atom but it's a bit annoying, there's other things in the works atm that will use ghci directly like dante does.
13:38:32 <Strenn> what text editor has the best set of haskell development tools out there?
13:39:05 <MarcelineVQ> very likely emacs
13:39:14 <Tuplanolla> It's always Emacs.
13:39:18 <Strenn> and cobind conveys a lot more meaningful information than <$=$>
13:39:20 <MarcelineVQ> I get by with ghcid and atom currentl
13:39:34 <Strenn> I know fairly certainly that cobind won't come from the graphics library
13:39:45 <geekosaur> also I will note that many libraries that use operators have a consistent naming convention you only need to learn once. for example, lens has a metric crapton of operators, btu they're all built consistently out of standard components so you can easily decode what some operator is once you have learned the naming convention
13:39:59 <sellout-> I use Emacs, and I would _love_ to see something that explains how to set up a comprehensive Haskell environment there … especially using Nix.
13:40:09 <sellout-> Right now, I can’t seem to get Scion to build.
13:40:40 <sellout-> And I’m not sure which packages are intended to be used together vs. duplicate each other.
13:40:50 <MarcelineVQ> Why not? cobind could be for binding an opengl context
13:41:36 <Strenn> if I'm writing a package that among other things binds opengl contexts
13:41:40 <Strenn> and I know that comonads are a thing
13:41:44 <Strenn> like people should
13:41:54 <Strenn> I won't call stuff cobind unless there's a pretty good reason
13:42:17 <Strenn> just like you won't name your operator <=< or <*>
13:42:18 <MarcelineVQ> You say you there, but isn't your argument about someone reading your code? Do they already know the things you know?
13:44:29 <Strenn> If there's this kind of ambiguity you might as well use a qualified import
13:45:29 <monochrom> Use both qualified import and infix symbols for the best of both worlds!  1 Prelude.+ 2
13:45:42 <MarcelineVQ> That's definetly a strength of qualified imports if you're willing to be verbose
13:47:27 <monochrom> Every library should give every function/operator three candidate names. This way the user has more choices and headroom for avoiding clashes.
13:47:36 <Cale> heh
13:47:48 <monochrom> Best intuitive idea ever.
13:48:27 <monochrom> (Counterintuitive consequence: With three times as many names, you're looking at more clashes, not fewer.)
13:48:35 <Strenn> when using these packages you can always synonymize those functions at the start of your code if you want to use better names
13:49:10 <Strenn> not sure how common of a practice that is though
13:49:25 <monochrom> More seriously, I wish people liked "rename while importing".
13:49:25 <Tuplanolla> It would be nice if operators were merely aliases for functions or we had a mechanism similar to Coq's `Notation`.
13:51:03 <Xandaros> https://hastebin.com/udabaxived.hs - Using binary:Data.Binary - I'm fairly certain floats are 4 bytes, so why is it complaining? :(
13:51:40 <monochrom> Perhaps because binary
13:51:55 <monochrom> Perhaps because binary's own format for Float is not what you think?
13:52:47 <Xandaros> I did actually look at the implementation of the Get instance and it is the exact same as for Double, but you'd think a Float instance also consumes 4 bytes when reading it...
13:52:54 <monochrom> I mean have you told binary to write a Float lately and see what bytes you get? Or do you just pressume?
13:53:24 <Xandaros> Ah, you are making a very good point. I just assumed it to be IEE 754
13:54:20 <Xandaros> ...It's 13 bytes long
13:57:48 <monochrom> In general binary's out-of-the-box Binary instances use a fairly redundant format for sanity checks etc.
13:59:14 <monochrom> If you want absolute control and certainty over the format itself, you're better off with forgetting the Binary class and directly use getWord16le, getDoublebe, etc.
13:59:43 <monochrom> Those ones comply with machine formats.
14:01:08 <Xandaros> Well, considering I'm going to need to decode a LOT of datatypes, I think I will just give those types that are causing issues wrapper-types and make a binary instance for those. Otherwise, it would be ridiculous amounts of boilerplate
14:01:44 <Xandaros> But thank you for pointing me to getFloatbe - I was looking for that :D
14:02:47 <monochrom> It pays to read the doc from cover to cover.
14:04:05 <Xandaros> There is probably some truth to that. Or just not assume the encoding is as I expect :D
14:04:09 <epta> question about 'errors': how to 'a -> ExceptRT a IO ()'?
14:05:40 <monochrom> The opening paragraphs of Data.Binary doc should be alarming enough. For example, "Values encoded using the Binary class are always encoded in network order (big endian) form, and encoded data should be portable across machine endianness, word size, or compiler version. For example, data encoded using the Binary class could be written on any machine, and read back on any another."
14:06:29 <monochrom> If that sentence is true, there is no way the Binary instance of Float and Double will just do the usual 4-byte or 8-byte thing.
14:07:26 <Tuplanolla> If you read the language report carefully, it makes no guarantees about the exact representation of integers or floating-point numbers either, Xandaros.
14:08:10 <monochrom> Or maybe s/no way/very unlikely/
14:08:36 <monochrom> At any rate it should set off a lot of alarms in your mind.
14:09:29 <monochrom> Over history, everything that promises wide portability and compatibility has always achieved it by highly unnatural, unguessable means.
14:09:37 <monochrom> Take for example XML...
14:11:02 <Xandaros> Well, I made a wrapper for Floats and I can properly read these packets now, so I guess all is well. Just need to remember not to rely on the binary-supplied instances too much.
14:36:54 <dmwit> :t throwError -- epta
14:36:55 <lambdabot> MonadError e m => e -> m a
14:38:15 <dmwit> epta: (in case your client only pings you when the message starts with your name and not whenever your name appears, as mine does)
14:40:24 <StrangeLoop> Hi, I'm reading a tutorial about openGL and there is this line " let color3f r g b = color $ Color3 r g (b :: GLfloat)". Is there a rationale to this weird syntax?
14:41:02 <mauke> uh. it's haskell?
14:41:08 <StrangeLoop> Yes
14:41:14 <Rembane> StrangeLoop: Do you think about the type signature?
14:41:17 <zachk> the $ is function apply, and it casts the b and I guess the other ones to GLfloat for you 
14:41:18 <Rembane> StrangeLoop: Is that the weird part?
14:41:27 <StrangeLoop> That it is only applied to b, yes
14:41:43 <Rembane> StrangeLoop: It makes all of the variables the same type... I think.
14:41:53 <Rembane> variables = parameters
14:41:59 <mauke> presumably Color3 has a type like a -> a -> a -> Color a
14:42:03 <StrangeLoop> Ohhhhh
14:42:12 <zachk> that could force it if Color3 :: (Num a) -> a -> a -> a -> Color3Struct a
14:42:15 <StrangeLoop> OK, yeah, that makes sense
14:42:28 <zachk> you can force lists like that as well
14:42:48 <mauke> > [1, 2, 3 :: Double]
14:42:50 <lambdabot>  [1.0,2.0,3.0]
14:42:52 <Rembane> You can force anything like that! Muahahahahahahahahaha!!!
14:42:59 <StrangeLoop> Cool :)
14:43:07 <mauke> > (1, 2, 3 :: Double)
14:43:07 <monochrom> [4, 5, 6 :: SevenAteNine]
14:43:09 <lambdabot>  (1,2,3.0)
14:43:52 <zachk> you can't force tuples like :: (a,b) 
14:44:05 <zachk> well you can't force them that way you have to be more explicit
14:49:00 <jollygood2> hi. is it possible to get a list all the top-level variables of certain type?
14:49:41 <zachk> jollygood2, hoogle command or google hoogle and try the site
14:49:48 <zachk> cabal install hoogle
14:50:41 <jollygood2> hoogle is a program iirc? I wanted to get it programmatically in haskell
14:51:27 <Rembane> :t SevenAteNine
14:51:29 <lambdabot> error:
14:51:29 <lambdabot>     Data constructor not in scope: SevenAteNine
14:51:33 <Rembane> :(
14:51:41 <zachk> yea hoogle can be integrated into your ghci prompt with a small amount of work 
14:51:58 <jollygood2> i want to use it in my own haskell program
14:52:03 <Rembane> monochrom: How did you do the SevenAteNine? And what is it? :)
14:52:18 <jollygood2> how does hoogle do it? using reflection, or does it parse haskell source files
14:52:36 <zachk> it makes a database out of your haskell src directories
14:52:37 <pikajude> doesn't it read haddocks?
14:52:38 <monochrom> It is a type. I didn't do anything. I didn't even use lambdabot.
14:52:42 <pikajude> or does it read .hi files
14:53:21 <jollygood2> haskell has no infrastructure to do this? i want a list of all the top level things in scope
14:53:29 <Rembane> monochrom: Magical!
14:53:34 <pikajude> infrastructure? no
14:53:43 <pikajude> you can hit tab in ghci
14:53:49 <pikajude> and it'll try to autocomplete everything in scope
14:54:01 <dmwit> jollygood2: Template Haskell can do that kind of thing.
14:54:03 <jollygood2> i want to do this in my own haskell program not in ghci
14:54:06 <monochrom> Hoogle comes with a library. The module name is Hoogle again.
14:54:08 <geekosaur> :browse
14:54:16 <geekosaur> jollygood2, haskell is not interpreted, it is compiled
14:54:21 <pikajude> why do you want to do this in your own haskell program
14:54:30 <dmwit> jollygood2: e.g. check out QuickCheck, which uses this kind of feature to run all the tests named `prop_Something` in a given module.
14:54:33 <geekosaur> your own haskell program cannot introspect an interpreter to find out what it knows
14:54:50 <geekosaur> neither can a C program. C++ and Java can only do so via expensive, slow hacks
14:54:59 <pikajude> even if you did write this code using Template Haskell, you would be fetching a static list of all the identifiers in scope during the compilation process
14:55:02 <geekosaur> (there are limited forms of those hacks also available for haskel)
14:55:03 <jollygood2> ok I'm getting pretty mixed messages. can this be done or not
14:55:15 <pikajude> nope
14:55:19 <monochrom> But the refreshing desert of my right-on answer is going to be buried under the warm-fuzzy oasis of tangential disputes.
14:55:41 <jollygood2> what about QuickCheck running all the tests named `prop_*', as pointed out above?
14:56:04 <pikajude> quickcheck needs a module name
14:56:06 <geekosaur> our visitor knows all languages have EVAL. so¸ they have never used C or C++
14:56:22 <jollygood2> haskell has eval
14:56:23 <dmwit> I am so confused by pikajude's answers. And geekosaur's.
14:56:31 <pikajude> me too
14:56:37 <geekosaur> haskell doe snot have eval in the context of your program
14:56:57 <monochrom> geekosaur's isn't an answer. It's a complaint. :)
14:56:59 <geekosaur> it has it in the context of a new interpreter without access to your program's data structures unless you explicitly serialize those to and from the interpreter
14:57:07 <monochrom> All confusions are caused by wrong assumptions.
14:57:25 <dmwit> Perhaps I have not understood jollygood2's question. I suspect I haven't, and neither has anybody else.
14:57:37 <zachk> you want a function, that takes a type and returns a list of all functions/constants/variables bound to that type, you will need some sort of type level extension as well 
14:57:47 <jollygood2> if the only issue that makes this impossible is "in scope" then I don't mind changing requirements to "in particular module"
14:58:09 <pikajude> so you want to take a module and get a list of all the identifiers in it that have such and such type
14:58:32 <jollygood2> yes
14:58:38 <pikajude> why
14:59:13 <jollygood2> does it matter? can this be done or not
14:59:18 <monochrom> Let's just recommend the package called "hint" and be done with it.
14:59:20 <pikajude> yeah, i think you have to use the GHC API for it though
14:59:31 <pikajude> which is a bit sticky
14:59:35 <pikajude> there aren't a lot of docs for it
14:59:54 <dmwit> What are you on about.
15:00:25 <pikajude> i'm on about jollygood2's question
15:00:40 <monochrom> (Of course, it will not be done. Two days later, they will come back to haunt you on how to get it to work.)
15:01:24 <pikajude> how are you going to get module information at runtime dmwit 
15:01:25 <jollygood2> wow.. sorry for asking a topical question
15:01:29 <pikajude> without using GHC API/hint
15:02:18 <pikajude> jollygood2: http://hackage.haskell.org/package/hint-0.7.0/docs/Language-Haskell-Interpreter.html#v:getModuleExports
15:02:20 <pikajude> there you go
15:02:23 <monochrom> No, I think you just rubbed people the wrong way when you insisted wrongly "Haskell has EVAL. I know for sure."
15:02:41 <jollygood2> it doesn't take a lot to rub you  the wrong way
15:02:43 <jollygood2> does it
15:02:57 <jollygood2> I used eval in haskell before
15:03:00 <monochrom> No. So you be careful.
15:03:03 <zachk> EVAL, the reason your code can't be compiled 
15:03:11 <jollygood2> monochrom is that a threat?
15:03:14 <pikajude> the face of eval
15:03:26 <monochrom> I don't know. What is a threat?
15:03:35 <jollygood2> "be careful"
15:03:47 <monochrom> Yeah. What counts as a threat?
15:04:19 <jollygood2> threat to ban me because I didn't kneel down on your command?
15:04:28 <MarcelineVQ> I can't imagine how this conversation line is going to get the questin answered. Did you have a look at what pikajude suggested jollygood2, does it fit the question you're wanting to ask?
15:04:35 <pikajude> wait, who's kneeling down now
15:04:46 <pikajude> how does one kneel in an IRC chatroom
15:05:05 <jollygood2> MarcelineVQ I am looking at it now
15:05:10 <monochrom> zachk: That is not quite true. The way some Lisp and SML implementations do it is that the REPL is a compiler, it compiles then eval.
15:05:17 * pikajude . o O ( forM_ mods $ \ mod -> kneelTo mod )
15:05:53 <jollygood2> I guess even #haskell has to has its own share of asshole mods
15:06:01 <pikajude> indeed
15:06:14 <dmwit> pikajude: Okay, having done some source diving: I can confirm that the way QuickCheck does it is dirty and wrong, and hint would probably be a better route.
15:06:30 <pikajude> how is it possible to be wronger than hint
15:06:39 <pikajude> does quickcheck use grep or something
15:06:45 <dmwit> pikajude: Easy: look at the first word on every line and assume it's the name of a function.
15:06:50 <pikajude> oh, ok
15:07:08 <monochrom> Wait, QuickCheck looks at your source code?!
15:07:09 <pikajude> i really should have eta reduced my thought
15:07:11 <dmwit> Congratulations, you get both false positives *and* false negatives!
15:07:13 <dmwit> monochrom: yep
15:07:33 <dmwit> monochrom: http://hackage.haskell.org/package/QuickCheck-2.10.0.1/docs/src/Test-QuickCheck-All.html#forAllProperties
15:07:41 <sqooq> I need help with optiparser
15:07:44 <sqooq> anyone can help?
15:07:49 <dmwit> monochrom: An excerpt: `fmap lines (readUTF8File filename)`
15:08:55 <dmwit> sqooq: 
15:08:57 <dmwit> ?where justask
15:08:57 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
15:09:06 <pikajude> to be fair, can you even put a word on a line without it being part of a definition
15:09:06 <sqooq> dmwit I was going to lol
15:09:12 <sqooq> but I'm trying something real quick
15:09:16 <pikajude> i suppose you can with TH
15:09:20 <sqooq> if it fails then I'll put my lpaste adn explain
15:09:41 <dmwit> pikajude: Sure, by indenting it. Or need I remind you that explicit braces and semicolons means you can break lines anywhere?
15:09:50 <pikajude> you can indent definitions?
15:09:53 <pikajude> what
15:10:08 <pikajude> i thought they had to be on col1
15:10:25 <dmwit> You asked if you can put a word on a line *without* it being part of a definition.
15:10:44 <dmwit> Which you can do with `foo x = \n\tx + 1`. The second line starts with the word `x`, but does not define `x`.
15:11:00 <pikajude> no the second line starts with a tab character
15:11:13 <dmwit> But the answer to "you can indent definitions" is also yes. `module Main where \n\tmain = return ()` is perfectly fine.
15:11:28 <pikajude> well, i've only been using this language for 2 years, how would i have known that
15:12:31 <dmwit> pikajude: No problem: `module Main where { foo x = \nx + 1 }` puts `x` at the beginning of a line but does not define `x`.
15:12:43 <sqooq> http://lpaste.net/358299
15:12:45 <pikajude> yeah you said that already
15:13:08 <dmwit> pikajude: Okay. So: you can get both false positives and false negatives with the "look at the first word on each line" strategy.
15:13:14 <pikajude> yeah i know
15:13:20 <pikajude> we established this
15:13:25 <pikajude> i'm with you
15:13:52 <sqooq> so i just started with optparser today. I want to have two options -n and -o which can only be one or the other and which the rest of the parssing is the same for both (so it's not a command), but something different happens depending on which is performed
15:14:03 <dmwit> pikajude: ...oh, okay. Then I very much misunderstood you.
15:14:27 <pikajude> no it was resolved when you said definitions can be indented
15:14:31 <pikajude> long, long ago
15:16:09 <dmwit> sqooq: `(<|>)` selects between parsers (and matches only one of them).
15:16:31 <dmwit> uh, well
15:16:36 <monochrom> But does optparse-applicative support <|> ?
15:16:41 <sqooq> yes that's what I try
15:16:41 <dmwit> If you have an Alternative instance. 
15:16:43 <sqooq> monochrom: yes
15:17:09 <monochrom> Ah good.
15:17:12 <sqooq> dmwit: I don't know how to piece it in there. douing Bool <|> Bool
15:17:16 <sqooq> is pointless
15:17:19 <dmwit> monochrom: Joke's on you, they're using "optiparser" or maybe "optparser", not "optparse-applicative". =P
15:17:26 <sqooq> because it will always return true then I won't be able to distinguish
15:17:38 <sqooq> I'm using optparse-applicative
15:18:16 <sqooq> And right now I only have two options
15:18:20 <sqooq> but later I may add more
15:18:25 <monochrom> Then you shouldn't use a Bool and a separate FilePath. You should have one single field of type Maybe FilePath.
15:18:43 <sqooq> ?
15:18:49 <monochrom> ?
15:18:51 <dmwit> sqooq: data Output = File FilePath | New; fun = (New <$ New) <|> (File <$> fileOutput)
15:18:59 <dmwit> ack
15:19:02 <dmwit> sqooq: data Output = File FilePath | New; fun = (New <$ new) <|> (File <$> fileOutput)
15:19:28 <dmwit> :t (<$) -- did I get this one right?
15:19:29 <lambdabot> Functor f => a -> f b -> f a
15:19:33 <dmwit> yes =)
15:19:50 <sqooq> I need output and input for both options
15:20:29 <sqooq> right now it may not looks like it, but that's because my program isn't quite finished, so I want to be able to use it and prepare this right now
15:20:38 <sqooq> that's why it's just PutStr
15:20:46 <sqooq> but eventually it will output a file
15:20:54 <dmwit> sqooq: Okay. Do you understand the idea I am trying to transmit into your brain, independent of whether I have the business details of your application correct?
15:21:09 <sqooq> Dude
15:21:13 <sqooq> I'm going to die in a few days
15:21:19 <sqooq> I just want to finish my program
15:21:24 <pikajude> wow
15:21:26 <pikajude> that's a shame
15:21:36 <Xe> what an argument
15:21:36 <dmwit> I want you to finish your program, too, and I am trying to help.
15:21:57 <sqooq> maybe I should use getArgs instead
15:22:46 <sqooq> the format is "gould new input output optional(-l);   gould update input output optional(-l); gould write input output optional(-l)"
15:34:35 <monochrom> https://hackage.haskell.org/package/webcloud  "Turn an optparse-applicative program into a CGI program!"  :D
15:35:32 <MP2E> huh, neat
15:36:09 <dfeuer> monochrom: wait, what?
15:36:21 <monochrom> Yeah! What I thought too!
15:36:48 <monochrom> getCloud :: [([Char], Input)] -> [[Char]]
15:37:10 <monochrom> The cloud is very simple. It's just [([Char], Input)]
15:37:30 <dfeuer> execParserWebCloud :: ParserInfo a -> IO a
15:37:31 <dfeuer> Source
15:37:39 <dfeuer> That type signature looks like a joke.
15:37:57 <dfeuer> monochrom: what is this "cloud"?
15:38:15 <monochrom> I don't know!
15:39:18 <monochrom> My sentence "The cloud is very simple. It's just [([Char], Input)]" was just a joke.
15:40:02 <dfeuer> *nod*
15:42:58 <sqooq> how do I actually run the executable
15:43:08 <sqooq> terminal says it's not found but I pointed directly to it
15:43:19 <sqooq> it even shows up in `ls`
15:43:59 <dmwit> Perhaps you could link to a paste showing the exact commands you ran and the exact output you saw from them.
15:44:40 <sqooq> hmm weird doing ./gould works
15:44:42 <sqooq> why is that?
15:45:12 <dmwit> https://unix.stackexchange.com/questions/254711/history-of-unix-not-including-current-directory-in-path
15:46:34 <sqooq> hmm
15:46:35 <sqooq> it works
15:46:38 <sqooq> weird
15:47:15 <MP2E> if you just type the name of an executable it searches all the directories defined in the environment variable $PATH, but doesn't actually check the current directory
15:47:20 <MP2E> so you need to be explicit with ./
15:47:31 <MP2E> not actually sure why that is, perhaps the link dmwit just posted has some reasoning
15:47:33 <sqooq> MP2E, ok thanks
15:48:10 <sqooq> nvm it doesn't work right
15:48:15 <MP2E> hmm
15:48:17 <sqooq> both flags can be present at the same time
15:48:28 <sqooq> MP2E, i'm talking about my cli thingy btw
15:51:12 <sqooq> maybe I should use commands
15:53:26 <sqooq> actually you know what. Update can contain write in it. I can let my program handle the two cases automatically.
15:53:47 <sqooq> and I'll make update the default and -n be the flag to make a new
15:57:51 <sqooq> can I make an option not require a flag since it's always required?
15:58:35 <dmwit> That is usually called an "argument", and every command-line parser library I know of supports them.
15:59:21 <dmwit> So the answer to the question as asked is "yes".
16:03:06 <sqooq> dmwith: yes you were right
16:03:11 <sqooq> thank you <3
16:03:15 <sqooq> it works as expected now
16:03:33 <sqooq> now I need to figure out whether I can remove text from a file directly
16:03:35 <sqooq> lol
16:03:47 <sqooq> because that's what update is supposed to do
16:03:54 <geekosaur> "no"
16:04:09 <sqooq> really ? :(
16:04:12 <geekosaur> if by directly you mean somehow modifying the file on disk without copying it
16:04:24 <dmwit> What does "remove text from a file directly" mean?
16:04:33 <geekosaur> when "text" files were fixed length records (think punch cards), that was a thing
16:04:41 <sqooq> wait so most programs copy the file and delet the original?
16:05:06 <geekosaur> yes
16:05:23 <geekosaur> editors do even fancier things but it still means loading into memory
16:05:51 <zachk> memory mapped files?
16:06:14 <geekosaur> and when it comes to binary data, you still can't just make some chunk of it disappear. you can mark it as deleted and something else can reuse the space or compact it.
16:06:35 <geekosaur> (which is why you periodically have to "vacuum" or etc. databases)
16:07:01 <sqooq> ok
16:07:04 <sqooq> I'm fine with that tbh
16:07:21 <sqooq> although it would mean that the user would have to reload the file in the program everytime an update is made
16:07:23 <geekosaur> but text files do not have that concept
16:08:03 <sqooq> well
16:08:09 <sqooq> the user would have to reload the file either way
16:08:12 <sqooq> I just tested
16:08:13 <geekosaur> (and even if they did, the user would have to reload the file unless it is memory mapped. and in *that* case you still need to notify readers somehow that the file changed out from under them
16:08:22 <sqooq> ^
16:08:48 <sqooq> ok
16:08:52 <geekosaur> this is why you find things using e.g. inotify to automatically reload on change
16:09:01 <sqooq> but my original question still stands just in a different form
16:09:11 <geekosaur> you still have to copy it
16:09:24 <sqooq> how do I copy the file with the part I want to remove, removed
16:10:12 <dmwit> What problem do you foresee arising when you try?
16:10:45 <sqooq> hmm
16:10:55 <sqooq> I mean I guess I just don't know what functions I would use
16:10:59 <geekosaur> manually. there is no magic function that does this because there is no magical way to tell it what part is to be removed. which is why sed and grep -v and perl and python and etc. all have their own ways to do it
16:11:02 <sqooq> I know how to add to a file easily
16:11:37 <sqooq> I guess I just need to do some parsing magic
16:11:59 <dmwit> The right function to use depends on what you want it to do.
16:12:21 <sqooq> I guess I can do it
16:12:34 <sqooq> no i'm still foreseeing issues
16:12:39 <sqooq> give me a sec
16:13:40 <geekosaur> might not even be parsing magic depending on what exactly you need to remove
16:14:07 <dmwit> monochrom: Your wise tautologies have infected me. =(
16:14:10 <geekosaur> but, that's why there are no canned tools for this; every program that needs to do it, needs something different.
16:14:37 <sqooq> ok so I need to parse until "<CsScore>" is found, keeping everything, parse all the items after that until "</CsScore>" is found, store that separately, return only the first storage and my new data. Does that sound about right?
16:14:59 <dmwit> How could we possibly know if that's right?
16:15:11 <dmwit> Also: if it's right, you may like the tagsoup package.
16:15:29 <sqooq> dmwit: I mean, knowing what you know about parsers, would that do what I expect
16:15:55 <sqooq> that is, delete everything between "<CsScore>" and "</CsScore>" and put my new data there instead.
16:16:04 <sqooq> new data comes from elsewhere
16:16:16 <geekosaur> see, if this is not firmly structured (e.g. strictly conforming XHTML or XML), the best you will do there is tagsoup and you may still have to tweak the result
16:16:19 <dmwit> Again: how could I possibly know what you expect?
16:16:29 <sqooq> because I just told you
16:16:50 <geekosaur> because strict conformance is not very common
16:17:16 <sqooq> geekosaur: what's strict conformance
16:17:21 <sqooq> csound has those exact tags
16:17:34 <sqooq> to separate every section (luckily)
16:17:44 <geekosaur> hope it's reliable.
16:17:48 <geekosaur> if this were html, it wouldn't be
16:18:04 <sqooq> what do you mean by that. html has tags too no?
16:18:13 <geekosaur> (you could reliably expect some generator to swap the order of open and close tags, for example)
16:18:38 <geekosaur> html is an example of where what's out there in the wild does not bother with strict conformance. <i><b>foo</i></b> is far too common
16:18:39 <sqooq> what if I told you that no other tags could possibly go inbetween these tags
16:18:43 <dmwit> Okay. I don't know what "parse until '<CsScore>'" means (and several other things in that sentence). I don't know what "delete everything between '<CsScore>' and '</CsScore>'" means. In both cases I can think of many possible meanings.
16:19:17 <geekosaur> meanwhile, it would help if you did not assume that everyone here knows csound's file format
16:19:41 <sqooq> dmwit: example : "<CsScore> blah blah blah </CsScore>" I wnat to make it "<CsScore> new blahs </CsScore"
16:19:57 <sqooq> oops "</CsScore>"**
16:20:05 <sqooq> geekosaur: true
16:20:29 <sqooq> well I guess if I mentioned that no other tags could go between these, then perhaps y'all could understand
16:32:38 <monochrom> dmwit: >:D
16:33:22 <dmwit> "The solution depends on the problem" is especially poisonous for surviving in this environment.
16:34:31 <monochrom> Do you like the latest addition (at the end, "no one gets out alive")? :)
16:34:47 <dmwit> I did not know the list was growing!
16:34:56 <monochrom> I added it after going to the movie The Hitman's Bodyguard. Great ending song.
16:34:59 <Rembane> Is it a secret list?
16:35:06 <monochrom> Oh it grows very slowly.
16:35:10 <dmwit> https://www.vex.net/~trebla/humour/tautologies.html
16:35:33 <monochrom> Also added a photo about "X is like Y".
16:36:10 <Rembane> Ah, good stuff. Thank you.
16:36:48 <monochrom> It grows slower than the amortized time function for disjoint sets.
16:37:09 <Lazersmoke> is there actually a good reason to name tests really weird, or is this silly? https://github.com/IxpertaSolutions/freer-effects/blob/39a7e62cc049d43d36ece4ac24ba19e545f0b726/tests/Tests/Reader.hs#L54
16:37:45 <monochrom> But it's commented out.
16:37:46 <hpc> that test's name is t2rrr1'
16:37:53 <hpc> from the planet criterion persei 8
16:38:15 <hpc> i bet it's short for something
16:38:17 <Eduard_Munteanu> Heh.
16:38:31 <monochrom> There is also a t1rr' earlier. Commented out again.
16:38:56 <monochrom> At this point my model is "weird names happen in comments".
16:39:09 <sqooq> Shoot
16:39:14 <sqooq> if I'm testing for a string
16:39:18 <sqooq> then how do I consume items
16:39:19 <hpc> {-# LANGUAGE SillyNamesOnly #-}
16:39:49 <koala_man> probably came about just like cdddr in lisp. test2 for triple-nested readers or something
16:40:26 <dmwit> What is "testing for a string"? What is "consume items"?
16:40:39 <monochrom> I think you're right. After a small adjustment: run-runReader-runReader
16:41:04 <monochrom> Actually what is "run" anyway?
16:41:19 <monochrom> Oh Freer's run.
16:41:51 <monochrom> At least the author should be commended for very helpful explicit imports.
16:42:09 <sqooq> shoot this is harder than I thought
16:44:56 <sqooq> ok I built my own monadic parser which is what I've been using, so maybe I don't know about some techniques
16:45:13 <sqooq> but how would you parse everything until you found a certain string
16:48:10 <sqooq> I can do it for a single character
16:50:37 <Lazersmoke> monochrom: :P https://github.com/Lazersmoke/freer-effects/commit/ed2d51e5245d76590b60ee9d5cee1d661370a4b9#diff-5bce9025eb286c20d70bc0db25fb79f8L3
17:06:12 <sqooq> man I can't figure it out
17:06:20 <sqooq> the fact that consuming one item is type Char
17:06:36 <sqooq> and a string of course is String
17:06:43 <average> I have no problems handling strings/characters in Bash..
17:06:48 <sqooq> I can't just do it like I expect
17:07:08 <average> in fact, I just wrote this in Bash https://gist.github.com/wsdookadr/e6765f481b5695532923f6ddef5da37c
17:07:22 <average> to write that in Haskell.. it would've taken me.. decades
17:09:34 <sqooq> o derp
17:12:05 <sqooq> if anyones curious : find = string "<CsScore>" <|> ( (:) <$> item <*> find)
17:21:48 <dgpratt> a type describes a set of values, am I wrong to think it doesn't need to be more complicated than that?
17:23:56 <erisco> dgpratt, yes, you're wrong :) there are different meanings for types
17:24:23 <dgpratt> I figured :)
17:26:32 <dgpratt> what's an example of a type that my overly-simplistic definition doesn't cover?
17:26:57 <boj> data PhantomType
17:27:04 <boj> has no value
17:27:19 <dgpratt> an empty set of values then
17:27:27 <geekosaur> types used as type level tags, types used as value level tags (Proxy), types used as kinds, ...
17:28:19 <erisco> the point is that you can have different meanings for types
17:29:21 <erisco> that you might wrangle sets to agree with any particular type system is not surprising
17:29:29 <erisco> sets are used as a foundation of mathematics, after all
17:29:50 * geekosaur wonders if he even dares mention Russell's original type theory :p
17:34:11 <erisco> <> is set as infixr, why?
17:34:37 <erisco> makes sense for ++ but is there a more general reason?
17:35:16 <Lazersmoke> I think many <> are more efficient when right associated
17:35:50 <erisco> for functions such as mconcat, why do we not have the choice of associativity?
17:36:05 <Lazersmoke> as in most recursive data structures are (very) generalizd cons lists
17:36:07 <erisco> why not a mconcatl and mconcatr instead?
17:36:13 <Lazersmoke> yeah there should be a way to choose tbh
17:37:26 <erisco> there can be performance differences and even semantic differences
17:37:32 <jollygood2> I'd find it weird if you could decide associativity on a per function basis
17:37:44 <Lazersmoke> should also be a mconcat binary tree version
17:37:58 <Lazersmoke> aren't semigroups required to be associative, though?
17:38:05 <Lazersmoke> oh you're talking about bottoms
17:38:21 <erisco> if mconcat is left associative then it is undefined on an infinite list of lists, but defined if right associative
17:40:33 <erisco> then I look at Foldable and wonder similarly about foldMap
17:40:57 <Lazersmoke> is fold the same as mconcat, just for any foldable?
17:41:18 <erisco> maybe, I don't know
17:41:41 <Lazersmoke> maybe there should be a typeclass of terminating foldables or something
17:41:51 <Lazersmoke> FiniteFoldable
17:42:13 <Lazersmoke> so you could have left associative, semantic preserving fold
17:43:06 <average> are you guys spending hours doing what you could be doing in 10 seconds in Bash, with a oneliner?
17:43:25 <erisco> average, don't make me sic monochrom on you
17:44:18 <jollygood2> bash is for crappy throwaway scripts, not for anything serious
17:46:01 <Lazersmoke> bash is elmers, haskell is loctite
17:46:11 <sqooq> geekosaur: how do I remove a file and rename a file in haskell
17:46:29 <average> sqooq: ^^ my point exactly..
17:46:29 <sqooq> I found System.Directory which seems to be what I'm looking for but just want to confirm
17:46:35 <average> use rm and mv..
17:46:57 <sqooq> average?
17:47:24 <erisco> I think I appreciate totality more than general recursion
17:47:58 <jollygood2> :t removeFile
17:48:00 <lambdabot> error: Variable not in scope: removeFile
17:48:28 <jollygood2> try to guess the other function name
17:50:05 <monochrom> average: Suppose I want a program that does a hundred things. It is true that each thing has an optimal language. But it is also true that they are a hundred different languages. Do I now use all one hundred languages and then worry about getting them to talk to each other so that I have some faint hope that they work somewhat coherently 10% of the time?
17:50:31 <sqooq> o god
17:50:33 <sqooq> to rename the file
17:50:40 <sqooq> do i have to also parse it too?
17:51:20 <sqooq> wait
17:51:24 <sqooq> i already have the name of the original
17:51:26 <sqooq> ayyyy
17:52:54 <sqooq> wait
17:53:26 <average> monochrom: so you basically painted the here and now of the software industry, but are pretending to not know the answer
17:53:55 <monochrom> Am I pretending?
17:54:34 <monochrom> Or are you the one pretending?
17:55:40 <monochrom> Should we all pretend to ask questions when making points and arguments?
17:57:32 <sqooq> dangit
17:57:41 <sqooq> i can't rename
17:57:49 <sqooq> or
17:57:57 <monochrom> FWIW I do start with shell scripts for many simple programs I want, and it does take only 10 seconds as you said.
17:57:59 <sqooq> idk what i'm saying anymore
17:58:09 <sqooq> "  x <- readFile inp     y <- readFile out     z <- pure $ updateCsd y $ csoundScore $ processStartPosition' $ parserToNotes x     updated <- writeFile ('1':out) z     removeFile out     renameFile ('1':out) out"
17:58:12 <sqooq> dangit
17:58:14 <average> monochrom: you start with shell scripts but then you write a Monad, right?
17:58:30 <monochrom> But feature creep and ambition being a fact of life, a month later even bash is not enough.
17:58:42 <average> so then you need to use Haskell, right?
17:59:04 <average> and use some Monoids, Matroids, some Hypergraphs maybe.. functors..
17:59:07 <average> right? :)
17:59:11 <monochrom> No I don't write a Monad in shell scripts. I am not maschosistic or whatever it's spelt.
17:59:18 <average> ah ok
17:59:31 <monochrom> I still haven't learned matroids.
17:59:34 <lysergia> Any way to refactor this Maybe-heavy code? http://sleepanarchy.com/p/3qYW55
17:59:45 <sqooq> http://lpaste.net/5928130409895297024
17:59:49 <sqooq> help pls
17:59:56 <sqooq> how do I do this file moving crap correctly
17:59:58 <monochrom> In fact after proving 5 greedy algorithms correct, I still haven't felt the need to learn matroids.
18:00:03 <average> monochrom: but you seem to have made your mind that scripts really need to be ported to Haskell
18:00:10 <sqooq> I stupidly thought I could just put '1' at the beginning of the file name
18:00:15 <monochrom> No.
18:00:17 <sqooq> but the file name is /path/to/file
18:00:19 <sqooq> lol
18:00:24 <sqooq> so i just did 1/path/to/file
18:00:26 <average> shouldn't you learn Greedoids to prove greedy algorithms correct?
18:00:38 <monochrom> I still have a large proportion of shell scripts I'm happy with.
18:01:41 <monochrom> But I also have a program that started as a shell script but later it needed either Perl or Haskell (or SML or...) and I chose Haskell but I reckon that Perl would be just as OK.
18:02:01 <monochrom> The program's purpose is to merge log files.
18:02:30 <monochrom> I have irc bots and irc bouncers that produce daily logs, one file per day, filename contains date.
18:02:50 <average> did someone pay money for this irc log thing?
18:03:07 <monochrom> But 365 files per year is too hairy. And in some cases I have had 5 years of them.
18:03:10 <monochrom> No.
18:03:22 <average> so is this a philantropic activity?
18:03:32 <boj> average: you should take that massive bash one liner you wrote and try to achieve the same thing with Haskell. i recommend looking at megaparsec. the code will end up being short and elegant
18:03:38 <monochrom> So I wanted a program that merges daily log files into monthly log files. At first a shell script did it.
18:03:59 <monochrom> No, I am selfish, I write it and use it for mysself
18:04:13 <monochrom> And so selfish I have two s's in "mysself"!
18:04:52 <average> so basically you don't want to lose more money by making it opensource?
18:05:05 <average> and you decided to keep it private?
18:05:47 <boj> is there some kind of point you are trying to make?
18:06:11 <monochrom> But later I also want it to merge past years' monthly logs into yearly logs. So it has to be a bit smarter in the date part of the filename. It has to tell apart daily filenames, monthly filenames, and yearly filenames.
18:06:46 <average> monochrom: would you rather put those in a database, and do those operations there?
18:06:46 <monochrom> So after a while shell script isn't quite enough. Almost enough, but much less convenient than Perl or Haskell or other languages.
18:07:10 <monochrom> So I switched to Haskell. But it could be Perl. I just like Haskell more than Perl.
18:07:37 <erisco> I am so exhausted over arguing about PLs
18:07:49 <average> yes.. but.. I don't understand how a programming language is the main thing in a data-centric project.
18:08:15 <monochrom> But I will let you in on a secret.
18:08:30 <average> ooh! secrets! I love secrets
18:08:55 <monochrom> The program needs go to the correct working directory before it does its work.
18:09:02 <erisco> what if next time I just agree with whatever contentious opinion and keep doing what I'm doing anyways
18:09:13 <boj> erisco: probably for the best
18:09:26 <erisco> yeah, Haskell is hours of wasted time, but I like to waste my time, so Haskell is a great fit
18:09:33 <monochrom> I leave that one single cd command external to the program. The cron job is "cd $HOME/xxx/yyy && mergelog"
18:09:49 <monochrom> So I am still using a shell command.
18:10:03 <monochrom> Like you said, it only takes 10 seconds to do "cd" in a shell, so why not.
18:10:07 <average> monochrom: but bro.. cd in bash .. I mean.. go all the way, you can change CWD with Haskell can't you..
18:10:24 <monochrom> I AM TRYING TO AGREE WITH YOU!
18:10:35 <boj> this story seems a good candidate for /q
18:10:44 <average> that guy sqooq above, he spent 15 minutes figuring out how to delete/rename a file
18:11:15 <monochrom> He's just unfamiliar with the standard library. It takes only 10 seconds to call renameFile.
18:11:16 <average> monochrom: ok man, you're right
18:12:21 <average> and since we're talking IRC logs..
18:12:45 <average> I too wrote something in Python https://gist.github.com/wsdookadr/7cbe3bc69ebdf54922f98cbf1cf7c35e#file-python-irc-channel-graph-svg
18:12:55 <average> that took some one hour of my free time.
18:13:10 <average> how long would I have to spend in Haskell to write that piece of s*** ?
18:13:25 <boj> average: give it a shot and we'll critique it
18:13:38 <average> critique my Python
18:13:57 <boj> you are in the wrong channel it seems
18:14:21 <average> I actually don't mind if we talk Python, or Haskell.
18:14:23 <boj> unless you are curious what libraries to use to write it haskell?
18:14:27 <boj> i did suggest megaparsec
18:14:46 <erisco> somehow I have a little bit of energy now to suggest you could be biased, because you know one language better than the other
18:15:11 <average> erisco: do you really believe I know just one language?
18:15:25 <average> let's not be deluded
18:15:27 <sqooq> average: what
18:15:29 <boj> "one language better than", not "one language"
18:15:31 <sqooq> I spent like 2 minutes
18:15:41 <erisco> hm, nope, not sure why you think I think that
18:15:42 <jollygood2> do you know haskell? are you learning it?
18:15:44 <sqooq> I literally googled "remove file haskell" and found System.Directory
18:15:54 <sqooq> everything else was user error lmao
18:16:04 <average> omg.. user error..
18:16:10 <average> PEBKAC and stuff..
18:16:22 <Psybur> When does one "know" haskell?
18:16:23 <sqooq> well I mean if I new how to "update" files in some other language
18:16:31 <sqooq> I'm sure I would know to do it right in haskell
18:16:32 <monochrom> Oh, here is the reason shell is not enough. The program has to prepend a date to each daily log line.
18:16:32 <boj> Psybur: in my experience, so far never :)
18:16:39 <sqooq> I just started coding 3 or 4 months ago
18:16:42 <erisco> one reason for saying a language is better than another is because you know how to do the same task in both, and so you can equivocate the solutions
18:16:50 <average> monochrom: and?
18:16:58 <monochrom> THE END.
18:16:59 <erisco> another reason for saying a language is better than another is because you know how to find the solution in one language and not the other
18:17:11 <average> monochrom: I guess I missed the point
18:17:29 <erisco> but, the latter is biased to the person doing the programming
18:17:31 <Psybur> I remember hearing someone say haskell is the Dark Souls of programming. Challenging yet still fun.
18:17:34 <average> prepending some stuff, for me.. is not enough reason to reach to some particular language. most offer that feature..
18:17:42 <erisco> I am sure you can find a programmer in the reverse situation
18:17:48 <Psybur> Probably why I keep coming back for me ;p
18:17:53 <erisco> for example, bash is confusing as hell to me
18:17:54 <Psybur> *more
18:18:00 <boj> average: you've been in this channel for a couple days, and honestly seem like you just want to fight/troll. do you have a genuine interest in using/learning haskell at all?
18:18:26 <average> boj: get used to my style, it's the best and everyone loves it
18:18:35 <average> monochrom and me are best friends
18:18:39 <boj> it's offputting
18:18:48 <monochrom> I agree with boj.
18:19:20 <Psybur> Is there a haskell certification? One similar in prestige to the oracle Java certifications?
18:19:59 <sqooq> wow
18:20:02 <sqooq> my programs so close now
18:20:07 <sqooq> just gotta figure out the gui
18:20:20 <sqooq> god wheres andromeda-galaxy when you need them
18:20:42 <monochrom> Psybur: Erik Meijer ran an online course. It probably had a certificate for finishing the course. Would it count?
18:21:44 <monochrom> I heard that andromeda-galaxy is heading our way for a clash with the milky way. So just wait. :)
18:22:18 <erisco> ugh, I hope it hurries up
18:22:22 <Psybur> monochrom, I dont think Im in a position to certify certifications :D
18:23:03 <monochrom> I haven't heard of a Haskell certification other than what most online courses do.
18:23:12 <c_wraith> Psybur: that's the great thing about certifications.  You can just make one up and it counts!
18:25:36 <sqooq> dangit does string require newlines to be literal '\n'
18:25:40 <sqooq> i get lexical error in string/character literal at character '\n'
18:25:45 <sqooq> when trying to use <enter>
18:26:28 <jollygood2> strings or string literals?
18:26:39 <sqooq> umm
18:26:42 <sqooq> I copied from a text file
18:26:43 <sqooq> and pasted
18:26:58 <sqooq> would you be willing to teach me the difference?
18:27:29 <erisco> sqooq, other than using ++ another trick is to use a list of strings and concat it
18:27:58 <jollygood2> string literal is a string between quotes that you are typing in the source code. putStrLn "hello"   <- "hello" is string literal
18:28:22 <sqooq> ok it's a string literal then
18:28:30 <sqooq> I just want to store a file as a template
18:28:36 <sqooq> store text as a template rather
18:28:47 <jollygood2> i don't think you can use actual newline in a string literal
18:28:53 <sqooq> ah
18:29:06 <erisco> actually, instead of concat, use unlines
18:29:17 <erisco> > unlines ["hello", "sailor!"]
18:29:19 <lambdabot>  "hello\nsailor!\n"
18:29:29 <jollygood2> if you have everything you need already saved in a file why not just read it? readFile
18:29:47 <erisco> you can also use TH to read the file and splice a string
18:29:49 <sqooq> jollygood2: I thought to do that, but wouldn't that require the file to always exist?
18:30:01 <jollygood2> yes
18:30:03 <erisco> actually that sounds like a fine utility… might be a package already
18:30:10 <sqooq> since I want this to be a template for my program, I wouldn't want the user to have that file somewhere
18:30:41 <monochrom> Look for "string-qq" or something along that line. On hackage.
18:30:59 <sqooq> like if I put it in my source files, and only read it to store it as a variable, when I build the executable, will the executable work by itself?
18:31:39 <monochrom> But if you're dying in five days, then maybe just KISS and use unlines.
18:31:54 <erisco> if you're referring to use TH to splice the file contents as a string, then yes, the string will be in the executable
18:32:08 <sqooq> what's TH
18:32:20 <sqooq> and what I was thinking can't work. It's wrapped in IO
18:32:28 <erisco> hm, yeah, so when is Andromeda getting here?
18:32:40 <erisco> TH is Template Haskell
18:33:05 <sqooq> that's the default right?
18:33:16 <erisco> the default of what?
18:33:18 <jollygood2> not sure you want to go down the TH rabbit hole at this point
18:33:27 <sqooq> nvm sorry
18:33:40 <sqooq> I just want to store text as a template
18:33:54 <sqooq> It's a lot, but I mean I guess I could type it manually with all the '\n'
18:33:57 <erisco> another option is to just do what monochrom suggested
18:34:17 <erisco> … read harder ;)
18:34:48 <erisco> we passed the need to use \n explicitly a while ago
18:35:11 <monochrom> The irony being unlines was suggested by erisco first, I was just agreeing.
18:35:14 <sqooq> string qq?
18:35:40 <sqooq> what, writing ["text a", "text b", "text c"] is way worse
18:35:53 <monochrom> This is totally what dolio was talking about about two objects calling up each other.
18:35:59 <jollygood2> sqooq if the string is large you could write a haskell program that reads text file and outputs a haskell string in whatever style you wish (\n, unlines, etc)
18:36:26 <sqooq> it would be wrapped in IO no?
18:36:48 <jollygood2> what I said? yes
18:36:59 <sqooq> then I could just use readFile
18:37:20 <sqooq> ?
18:38:21 <jollygood2> just readFile and print would work yes
18:38:39 <sqooq> why do I feel
18:38:44 <sqooq> ok let me just test it
18:38:58 <jollygood2> you may want to tidy it up though, split it into lines, or something
18:39:18 <jollygood2> whole text file as one string literal will look ugly, but it will work
18:40:28 <erisco> http://hackage.haskell.org/package/file-embed-0.0.10/docs/Data-FileEmbed.html
18:40:51 <jollygood2> that is kind of neat
18:41:34 <sqooq> ok it works with the file there
18:41:39 <erisco> the reason you don't just jam everything into your executable is that the OS has to load the whole thing to memory before your program starts running
18:41:51 <erisco> but for some text files that is probably no big deal
18:42:01 <sqooq> but it doesn't otherwise
18:42:02 <sqooq> "gould: src/Gould/template.txt: openFile: does not exist (No such file or directory)"
18:42:04 <sqooq> :(
18:42:09 <sqooq> I had a feeling that would happen
18:42:17 <sqooq> how do I embed it into the executable itself
18:42:46 <erisco> that link was for you, sqooq
18:42:46 <sqooq> maybe it's because I put it in the main block?
18:43:08 <jollygood2> sqooq you didn't understand me. I meant to write a separate program that reads the file, outputs it (in whatever format you prefer), and then you copy/paste that output into your original source
18:43:41 <jollygood2> but library pasted above would make things easier and quicker
18:43:56 <sqooq> oooo
18:43:58 <sqooq> ok
18:44:07 <sqooq> yeah what erisco linked looks useful
18:44:12 <erisco> I got paid to spend hours rewriting megabytes of text to a different format
18:44:30 <erisco> hint: find/replace with regexp helps a lot
18:45:02 <erisco> ideally it is regular enough you don't have to go through it with a careful eye, but life isn't always fair :P
18:46:09 <sqooq> I just put embedFil anywhere?
18:47:02 <erisco> you use $(embedFile "myfile.txt") where you expect there to be a ByteString term
18:47:49 <sqooq> umm, is that the same as String
18:47:57 <erisco> no
18:48:29 <sqooq> ok, so then how do I use it
18:48:36 <sqooq> I want to ++ the file
18:48:39 <sqooq> to another string
18:49:03 <erisco> how would you normally look for such a function?
18:49:35 <sqooq> is the answer you're looking for google?
18:49:54 <jollygood2> hoogle :)
18:50:26 <erisco> if it is a ByteString, look for the package/module that defines ByteString, and you'll probably get good leads there
18:50:35 <erisco> Hoogle, Hayoo, Hackage will all help you
18:50:37 <jollygood2> https://www.haskell.org/hoogle/  <- type ByteString -> String
18:50:50 <sqooq> wow hoogle is great
18:50:53 <erisco> you might also try, cheaply, looking on Hoogle or Hayoo for ByteString -> String
18:51:11 <sqooq> unpack right?
18:51:24 <jollygood2> yeah
18:51:28 <erisco> be wary of encodings, sqooq
18:51:36 <sqooq> ?
18:51:47 <sqooq> god I have to add yet another package to build-depends
18:51:55 <jollygood2> there seems to be a version that can give String directly? embedStringFile
18:52:11 <erisco> sqooq, read the top of http://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString-Char8.html
18:52:21 <erisco> which is the docs for the module where unpack is defined
18:53:27 <erisco> yeah embedStringFile might work, but I don't see where it mentions how it handles encodings
18:53:42 <erisco> I am guessing there is some underlying machinery, defined elsewhere, it leverages to detect encoding
18:53:58 <sqooq> I mean it's just english alphabet, newline, <, and >
18:54:02 <sqooq> I should be fine right?
18:54:49 <erisco> if you know the file is ASCII then you're fine with unpack
18:55:05 <erisco> and I am guessing embedStringFile will be fine too
18:55:24 <sqooq> kek
18:55:35 <sqooq> it's [GHC.Word.Word8]
18:55:40 <sqooq> not [Char]
18:56:07 <erisco> what is?
18:56:13 <sqooq> o
18:56:17 <sqooq> nvm I imported wrong module
18:56:25 <sqooq> there's at least two `unpack`s
18:56:44 <jollygood2> embedStringFile works, just add type declarations
18:56:59 <sqooq> i did char8
18:57:27 <jollygood2> as it returns a more general type than String
18:57:33 <lysergia> Any way to refactor/simplify this JSON decoder? http://sleepanarchy.com/p/3qYW55
18:58:30 <erisco> well yes, but IsString types merely define some function from String
18:59:33 <erisco> part of the machinery for OverloadedStrings iirc
18:59:58 <jared-w> lysergia: You have a /ton/ of Maybe types where the Nothing means "throw some error"; that to me means you should be using the Either type instead of Maybe
19:00:12 <sqooq_> i lost connection
19:00:31 <sqooq_> openFile: does not exist (No such file or directory)
19:00:37 <sqooq_> it didn't work :(
19:01:06 <sqooq_> I unpacked it in the IO block maybe that's the problem?
19:01:07 <jollygood2> did you use relative path?
19:01:14 <sqooq_> I think
19:01:20 <sqooq_> `template = $(embedFile "src/Gould/template.txt")`
19:01:29 <jollygood2> try full path. it is reading the file at compile time
19:02:25 <sqooq_> nope
19:02:30 <sqooq_> that didn't work either
19:02:36 <sqooq_> let me try moving unpack out of the io block
19:02:50 <jollygood2> works for me
19:03:04 <sqooq_> did you remove the file?
19:03:07 <sqooq_> after the fact
19:03:08 <jollygood2> that shouldn't matter
19:03:12 <sqooq_> it works when the files there
19:03:14 <sqooq_> I rename it 
19:03:18 <sqooq_> then I get can't open file
19:03:20 <jollygood2> let me try that
19:03:42 <erisco> each time you compile the program you will need the file in place
19:03:57 <jollygood2> how are you running it? from ghci or you compiled it to executable, which you ran?
19:04:59 <sqooq_> compiled it to executable
19:05:04 <sqooq_> which I'm running
19:05:21 <sqooq_> I just moved unpack into the definition of template instead
19:05:23 <sqooq_> that didn't work either
19:05:23 <sqooq_> gould: src/Gould/template.txt: openFile: does not exist (No such file or directory)
19:05:47 <erisco> this error occurs during compilation?
19:07:22 <sqooq_> erisco: no, only when running the exe
19:07:31 <jollygood2> I compiled it to executable, renamed the file, still works
19:07:33 <erisco> why are you trying to open the file?
19:07:40 <sqooq_> I'm not
19:07:44 <erisco> you have it as a string in your program already
19:07:45 <jollygood2> post a test case?
19:07:54 <sqooq_> I'm not trying to open it
19:08:27 <sqooq_> I have "template = Bs.unpack ($(embedFile "/home/cypress/gould/src/Gould/template.txt"))"
19:08:43 <sqooq_> in my main function I have writeFile out (template ++ y ++ endtemplate)
19:09:12 <erisco> this is a hard story to believe… can you just paste the program?
19:09:59 <sqooq_> http://lpaste.net/358305
19:10:38 <erisco> why do I read line 45 tem <- readFile "src/Gould/template.txt"
19:10:39 <jollygood2> this works; http://lpaste.net/358306
19:10:53 <sqooq_> erisco: ah shoot that was from earlier experiment
19:10:55 <sqooq_> that's probably it
19:11:47 <sqooq_> ayyy
19:11:50 <sqooq_> that was it lol
19:11:58 <sqooq_> sorry 
19:13:00 <lysergia> jared-w: What I'd love is the ability to try parsing w/ a list of decoders
19:13:18 <jared-w> You're looking for a package like megaparsec then :)
21:36:37 <olligobber> @djinn (a->b) -> IO [a] -> IO [b]
21:36:37 <lambdabot> Error: Undefined type IO
21:36:51 <olligobber> @djinn (a->b) -> m [a] -> m [b]
21:36:51 <lambdabot> Error: Undefined type []
21:37:00 <olligobber> really?
21:37:12 <olligobber> @djinn (a->b) -> m l a -> m l b
21:37:12 <lambdabot> -- f cannot be realized.
21:37:26 <olligobber> *throws a brick at lambdabot 
21:37:29 <boj> lol
21:37:41 <olligobber> I'll just use fmap (fmap f)
21:38:38 <olligobber> > let f a = b
21:38:41 <lambdabot>  <no location info>: error: not an expression: ‘let f a = b’
21:38:41 <olligobber> wait
21:38:53 <olligobber> I give up, stupid bo
21:38:55 <olligobber> I give up, stupid bot
21:41:21 <geekosaur> the bot is not ghci. it takes expressions
21:41:57 <geekosaur> and yes, djinn's algorithm is stupid, it does not understand IO, it doesn't even understand recursive types (e.g. lists, trees, ...)
21:42:00 <geekosaur> try :exf
21:42:27 <olligobber> :exf (a->b) -> m l a -> m l b
21:42:37 <olligobber> or in ghci
21:42:53 <exferenceBot> could not find expression
21:43:32 <olligobber> :exf (a->b) -> IO [a] -> IO [b]
21:43:33 <exferenceBot> fmap . fmap
21:43:37 <olligobber> thought so
21:43:55 <olligobber> oh, but with the dot looks nicer than what I had
21:51:30 <erisco> Kmett's lens talk begins with the basics of Haskell oO
21:58:07 <Eduard_Munteanu> erisco, basics like profunctors and stuff, right? :D
21:58:19 <erisco> no, like "what is functional programming"
21:58:25 <Eduard_Munteanu> Hm.
21:58:30 <erisco> I feel like Penny being taught physics from Sheldon
21:58:33 <Eduard_Munteanu> erisco, link?
21:58:43 <erisco> first we must start with: "what is physics?"
21:59:08 <erisco> "Lenses: A Functional Imperative"
21:59:24 <erisco> he has other talks on lenses though. I was just surprised that one could start so basically
21:59:43 <erisco> optimistic to teach lenses to people who don't know FP!
22:00:13 <Eduard_Munteanu> Hm, it's for a Scala audience, kinda makes sense.
22:00:31 <erisco> Scala is a functional programming language
22:00:42 <erisco> not sure how many Scala programmers are functional programmers, though :P
22:08:18 <jle`> heh heh
22:20:56 <dmj`> jle`: o/
22:21:16 <jle`>  \o
23:44:54 <olligobber> this line of code I wrote is terrible: mid = base $ takeWhile ((==m) . fst) $ dropWhile ((<m) . fst) xs
23:53:31 <erisco> > (\x -> groupBy (\y z -> compare x y == compare x z)) 3 [1..10]
23:53:33 <lambdabot>  [[1,2],[3],[4,5,6,7,8,9,10]]
23:53:51 <olligobber> erisco++
23:53:59 <olligobber> That's so cool
23:54:51 <erisco> it doesn't tell you which group is what though, which is something that annoys me about groupBy
23:55:02 <erisco> I often need that information, and so do we here
23:55:48 <olligobber> > (\x -> groupBy (\y z -> compare x y == compare x z)) 2 [1,1,2,2,2,3,3]
23:55:51 <lambdabot>  [[1,1],[2,2,2],[3,3]]
23:55:58 <olligobber> perfect
23:56:29 <erisco> how do you get just the middle, though
23:56:33 <olligobber> erisco, wait, is it possible that it returns them in a different order?
23:56:40 <olligobber> erisco, I needed all 3 anyway
23:56:56 <erisco> you can't tell which is which
23:57:09 <erisco> if all three are present, you know, but less than that, you do not
23:57:30 <olligobber> erisco, oh...
23:57:39 <olligobber>  > (\x -> groupBy (\y z -> compare x y == compare x z)) 2 [2,2,2,3,3]
23:57:47 <olligobber> > (\x -> groupBy (\y z -> compare x y == compare x z)) 2 [2,2,2,3,3]
23:57:50 <lambdabot>  [[2,2,2],[3,3]]
23:58:00 <olligobber> oh, scrap that then
23:58:47 <olligobber> I thought what it was returning was of type ([a], [a], [a])
23:58:52 <olligobber> not [[a]]
23:59:58 <erisco> that is maybe possible with some fancier definitions but I think we can have something else
23:59:58 <kadoban> You could do it as a couple uses of 'span'
