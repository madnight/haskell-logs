00:00:43 <mbrock> xzhu: the left hand side and the right hand side are similar; you instantly see how the transformation works (well, of course RB-tree balancing is still pretty weird)
00:01:13 <pacak> saurabhn_: Not sure, mostly worked for us. I think it got writter implemented via state so it can also be used.
00:01:23 <kadoban> Anyone who complains about balancing RB-trees in haskell-ish hasn't done it in C-ish.
00:02:09 <xzhu> kadoban: No I acutally think that Haskell code is stunningly elegant
00:02:14 <pacak> I did both. Haskell version was much less painful.
00:02:36 <xzhu> I see the point better
00:02:43 <kadoban> The haskell thing would be a lot cuter if haskell had "or patterns", so the right side didn't need to be repeated so much. But ya, it's still pretty nice.
00:04:50 <mbrock> compared to a typical (say) Java implementation, it's not just showing off pattern matching, but also functional style since it's not mutating the tree
00:05:23 <mbrock> and the fact that matching and constructing are so symmetrical I guess shows the beauty of the whole approach
00:05:30 <MarcelineVQ> you can balance RB at the type level if you really wanted to get into it
00:06:30 <MarcelineVQ> fun content available https://www.youtube.com/watch?v=P4Io2CRpwyg
00:06:37 <xzhu> MarcelineVQ: Lol, how would that be useful since most of the time the insertions comes from run-time data
00:07:15 <mbrock> type-level programming is a thing in Haskell, more and more common these days because of language extensions that make it more powerful :)
00:07:19 <MarcelineVQ> mostly proof that your insertion is correct
00:07:26 <MarcelineVQ> *insertion code
00:07:40 <pacak> coq and idris :)
00:08:44 <xzhu> MarcelineVQ: What do you mean "insertion code is correct"? How do you insert "incorrectly?"
00:09:36 <mniip> >using RB trees instead of AVL
00:09:39 <mniip> >haskell
00:10:38 <mniip> cool implementation but seriously RB trees' strongest point is the 1-bit metadata that can be sometimes stored for free
00:10:49 <mniip> obviously not in haskell
00:11:40 <kadoban> xzhu: By screwing up balance invariants.
00:11:53 <kadoban> Or by putting stuff in the wrong place I guess, but that's probably less of a worry.
00:13:07 <digitalkiwi> what is AVL
00:13:32 <kadoban> AVL trees are a balanced binary search tree scheme. It's named after the inventors
00:32:33 <ertes-w> helo
00:43:14 <Unhammerd> what are the prerequisites for doing `stack exec hoogle -- generate --local mypackage` ?
00:43:31 <Unhammerd> I tried doing it from ~/src/mypackage, but I get "Packages not found: mypackage"
00:44:17 <Unhammerd> even though I have a Mypackage.cabal with "executable mypackage"
00:49:36 <Unhammerd> oh, no haddock for executables https://stackoverflow.com/a/32718946/69663
00:50:01 <Unhammerd> no cutting corners in haskell land
00:52:01 <Unhammerd> Invasion of the Matrix
00:52:19 <ski> whee
00:52:57 <MarcelineVQ> :(
00:54:36 <ski> i wonder why some short nicknames there don't end with `[m]'
00:55:12 <ski> (for some of the long ones, there's cutoff)
00:56:57 <ertes-w> i rarely see anyone with [m] talking…  is it just very quiet over there, or is it a one-way gateway?
00:57:48 <ski> i've seen them talk in at least #haskell-beginners
00:59:03 <merijn> I've seen some of them talk here
00:59:19 <merijn> ertes-w: Let's face it, some 70-80% of the people here don't talk :p
00:59:29 <merijn> And that's good, we'd never get anything done otherwise :p
00:59:56 <int-e> and they're just 222 of 1581 users
01:03:44 <Unhammerd> ski, https://github.com/matrix-org/matrix-appservice-irc/blob/master/HOWTO.md#changing-nicks 
01:11:36 <ertes-w> merijn: we never get anything done anyway ;)
01:11:44 <ertes-w> haskell is the number one procrastination language
01:13:50 <dyreshark> i prefer to say "i'm being side-effect free" instead of "i'm doing absolutely nothing with my time"
01:14:01 <a6a3uh> Hi! I have a function (a -> m b) and function (b -> c) is it possible get (a -> m c)?
01:14:29 <a6a3uh> m being a monad
01:14:45 <merijn> Assuming "f :: a -> m b", "g :: b -> c" you can just do "fmap g . f"
01:14:45 <liste> :t fmap
01:14:47 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:15:16 <merijn> :t \f g -> fmap g . f
01:15:17 <lambdabot> Functor f => (a1 -> f a2) -> (a2 -> b) -> a1 -> f b
01:17:59 <phaazon> is there the author of the Docker Store haskell image here?
01:18:03 <phaazon> the PR for 8.2.1 was merged
01:18:05 <phaazon> but not Docker Store
01:21:14 * hackagebot line 4.0.0 – Haskell SDK for the LINE API – https://hackage.haskell.org/package/line
01:22:06 <a6a3uh> thanks friends! thats worked well for mee :)
01:24:43 <Shaunthesheep[m]>  > haskell is the number one procrastination language
01:24:44 <Shaunthesheep[m]> I agree!
01:25:56 <foldr> Hi, is it possible to load a sequence of commands from a file into GHCi, then continue with stdin? It is not a Haskell module, but a sequence of lines that I would otherwise type into GHCi manually.
01:27:37 <merijn> foldr: Yes, see the GHC manual on .ghci files
01:27:42 <foldr> It seems like `:script' is what I am looking for.
01:28:24 <foldr> merijn: thanks.
01:29:59 <ertes-w> foldr: see the manual anyway, there are some useful mechanisms regarding .ghci files
01:30:04 <ertes-w> like directory-specific ones
01:30:17 <merijn> You really shouldn't enable those
01:30:40 <ertes-w> they are enabled by default though
01:30:45 <merijn> No, they're not
01:30:50 <ertes-w> huh?
01:30:51 <merijn> only .ghci from your home dir is
01:31:25 <ertes-w> can't confirm that…  my GHC loads ./.ghci
01:31:37 <ertes-w> i haven't explicitly enabled it
01:31:44 <ertes-w> and yes, it's a security risk
01:32:00 <merijn> I'd be really annoyed if they changed that default..
01:32:25 <ertes-w> it has been that way since i remember discovering that for the first time, which was a few years ago
01:32:52 <ertes-w> that's why i pay attention to where i run GHCi
01:33:04 <merijn> hmmm
01:33:16 <merijn> I coulda sworn I made a ticket about this sorta thing in the past
01:33:44 <ertes-w> if you make one now, i'll give it a 'succ'
01:35:12 <merijn> ertes-w: At least it ignores world writable .ghci files and .ghci files in world writable dirs, but that doesn't help much
01:35:40 <ertes-w> it doesn't help at all, since most untrusted .ghci files would come from repos
01:36:08 <merijn> ertes-w: Welp, they fixed another annoying bug while I wasn't looking, so there's a work around!
01:36:18 <davean> Can confirm ghci loads an executes .ghci files in the current directory by default - also annoyed by that!
01:36:26 <merijn> ertes-w: "ghci -ignore-dot-ghci -ghci-script ~/.ghci"
01:36:42 <merijn> Before -ignore-dot-ghci couldn't be overwritten, but apparently it can now
01:37:01 <merijn> So just alias ghci to that
01:37:14 <ertes-w> that's gonna be a lot of work
01:37:25 <ertes-w> i run GHCi from lots of places, not just the shell =/
01:37:52 <merijn> ertes-w: Put a bash script in your path before GHCi that calls it with those flags?
01:37:54 <ertes-w> i wish it would load ~/.ghci first, and then there would be a command that would stop further .ghci processing
01:37:56 <davean> If you make a ticket, I'll also succ it 
01:40:07 <davean> ertes-w: that seems a reasonable solution IMO
01:45:51 <merijn> ertes-w, davean: https://ghc.haskell.org/trac/ghc/ticket/14250#ticket
01:47:40 <merijn> Unrelatedly is there a better way to document impossible conditions than 'error'?
01:48:03 <ertes-w> short and sweet, i'll succ it when i'm at home
01:48:15 <ertes-w> that…  sounded wrong…
01:48:38 <ertes-w> merijn: what do you mean by "document"?
01:49:07 <merijn> ertes-w: I have a pattern match and one branch shouldn't be able to occur, but then GHC yells at me for incomplete patterns
01:50:06 <davean> merijn: This strikes me as a fairly easy thing to fix too, very newcomer friendly
01:50:12 <merijn> davean: yeah
01:50:13 <ertes-w> merijn: well, you could use 'throw' with a custom exception type
01:50:39 <ertes-w> other than that i can't think of anything
01:51:07 <merijn> ertes-w: Yeah, but that means making an exception type for something that should never run anyway, so there's no sane way to handle it beyond "file a bug"
01:51:33 <ertes-w> merijn: what do you want to happen instead?
01:51:40 <ertes-w> or not to happen, i suppose
01:52:27 <merijn> ertes-w: It's more of a "it can be hard to find the right error position in source", so something that helps pinpoint which line f'ed up
01:53:11 <davean> merijn: oh, I think theres a way to include the file and line
01:53:16 <davean> ... I forget what it is
01:53:22 <ertes-w> ah, well, i just add the function name and if necessary the name of the local definition, if there is more than one with such a pattern
01:54:53 <davean> Ah, right, TH, like https://hackage.haskell.org/package/file-location
01:55:03 <davean> ... I thought there was a better option then that
01:56:03 <davean> Maybe it was the callstack stuff?
01:57:01 <davean> https://ghc.haskell.org/trac/ghc/wiki/ExplicitCallStack
02:02:25 <ertes-w> i'm still not sure what "call stacks" even mean in haskell
02:02:34 <ertes-w> i can't imagine that they're useful
02:02:52 <merijn> ertes-w: I think they are
02:03:10 <ertes-w> unless you manually annotate functions that should be tracked or something
02:03:17 <merijn> ertes-w: You can
02:03:30 <merijn> ertes-w: But easier to use auto annotation
02:03:54 <ertes-w> how does it work?  just skip recursive applications?
02:04:35 <merijn> Don't think so
02:04:55 <merijn> ertes-w: You can limit how far the callstack gets generated/propagated, though
02:05:48 <cocreature> getting a source location for calls to "error" is pretty handy
02:06:34 <ertes-w> i care more about the surrounding function name than the exact source location, because the latter changes too frequently anyway
02:09:59 <davean> ertes-w: well, you need to write in the git commit id also ;)
02:11:01 <cocreature> callstacks also tell you the function name
02:11:42 <merijn> Any good naming convention for library specific datatypes with rather generic names?
02:12:35 <merijn> bleh
02:13:11 <merijn> There's no way to distinguish whether the cleanup from a bracket runs due to an exception or graceful termination, is there?
02:13:45 <cocreature> sounds like you want something like bracketOnError
02:14:00 <davean> uh, sure, you COULD make it do that, you'd need to write something into the type though?
02:14:04 <cocreature> and for the non-error case just have a normal statement at the end of the main block
02:14:06 <merijn> Not quite
02:14:25 <AndreasK> merijn: You can use complete pragmas afaik if ghc doesnt recognize a pattern as such
02:14:26 <merijn> hmm, actually that might work, I guess
02:15:07 <davean> merijn: You can always augment the a with an IORef or something that you set on success?
02:15:12 <davean> unless you're worried about masking
02:15:39 <merijn> bracketOnError would make this a bit trickier to use, though :\
02:16:10 <cocreature> merijn: tbh I would probably just write my own custom bracket replacement if I need this
02:16:47 <merijn> cocreature: The problem is that this code is taking the bracket as input parameter
02:17:30 <merijn> Actually, I suppose ResourceT already depends monad-control and lifted-base so I'll just tell people to use bracket from that
02:19:03 <davean> merijn: why does it take backet as input?
02:19:13 <cocreature> resourcet also doesn’t differentiate between exits due to exceptions and normal exits or does it?
02:19:29 <merijn> davean: Because I'm writing some code that I want to use with both pipes and conduits
02:19:43 <merijn> davean: And there's no general bracket that will work with both
02:20:21 <merijn> davean: So easier to just write it in a way that I can do "myStuff Pipes.bracketOnError ..." or "myStuff Conduit.bracketOnError"
02:20:35 <merijn> davean: Because depending on both is not a sane solution, obviously
02:21:35 * hackagebot currency-codes 2.0.0.0, dollaridoos 0.1.0.0, nakadi-client 0.2.0.0
02:21:35 * hackagebot  → https://hackage.haskell.org/packages/recent
02:22:05 <merijn> davean: Although I'm open to better suggestions :)
02:22:44 <davean> merijn: huh, I see, curious
02:23:26 <davean> merijn: well, a type class comes to mind
02:23:39 <merijn> davean: The problem is that we already have 3 such classes
02:23:41 <davean> save your users a little tping
02:23:50 <ertes-w> davean: that's gonna be interesting: "sorry, can't compile…  be sure to check out the repo instead of downloading the tar.gz"
02:24:02 <merijn> davean: Pipes has MonadSafe and MonadMask (from edwardk's exceptions)
02:24:14 <merijn> davean: Conduit uses MonadResource and MonadBaseControl + lifted-base
02:24:45 <merijn> davean: MonadResource and MonadBaseControl are out, because they have ginormous dependency footprints. MonadMask wouldn't work with conduit
02:25:38 <merijn> davean: So either I introduce a new typeclass (which I can't instance without depending on either conduit or pipes) or I just make users define a local alias "myFun = Qualified.myFun Pipes.bracketOnError"
02:25:46 <merijn> davean: The latter seems much easier and flexible, tbh
02:25:50 <davean> merijn: still as a user, I think I'd prefer you just make the hacky type class you need for this instead of making me pass a param - I don't mean its a good solution I just mean its more user firendly
02:26:09 <davean> and I'd make it depend on both with flags for disabling building each of them myself
02:26:11 <merijn> davean: the typeclass is more typing than a simple partial application you do once
02:26:18 <merijn> davean: That's awful
02:26:29 <merijn> davean: Because users of a library can't specify flags for their dependencies
02:27:14 <davean> sure you can
02:27:29 <merijn> Eh, no you can't and shouldn't
02:27:30 <davean> Its in the cabal.project
02:28:02 <davean> http://blog.ezyang.com/2016/05/announcing-cabal-new-build-nix-style-local-builds/
02:28:04 <cocreature> but that’s not part of your cabal file
02:28:05 <merijn> davean: Almost no one uses new-build yet
02:28:16 <merijn> davean: And new-build isn't ready for prime-time
02:28:18 <davean> cocreature: he said users
02:29:04 <davean> merijn: I wasn't aware of people not using new-build these days really
02:29:29 <cocreature> davean: let’s say user B depends on a lib by user A that depends on merijn’s lib. then user B suddenly needs to take care of compiling merijn’s lib with the right options which they really shouldn’t have to since they’re not depending directly on it
02:29:40 <merijn> davean: Except for hvr, the people hacking on cabal and a handful of people including me I don't think anyone's using it
02:29:50 <merijn> davean: new-build has to many rough edges, tbh
02:30:38 <davean> merijn: like what?
02:31:01 <merijn> davean: There's no new-install, builddir project setting is ignored, none of the ide/build tools actually support it yet
02:31:03 <davean> I think all the Haskell users I talk to regularly switched to new-build over a year ago
02:31:17 <merijn> davean: I think you're living in a bubble of early adopters :)
02:31:27 <davean> The only issue anyone ever mentioned was haddock support and thats fixed
02:31:47 <cocreature> you can’t build haddock for deps so you can’t build docs for hackage, new-test doesn’t allow you to pass arguments, dist doesn’t work properly and there is no new-dist, new-exec does not exist, …
02:32:06 <merijn> davean: I go through an incredible amount of hacks to make type-checking in my editor work and it's brittle as hell
02:33:58 <merijn> davean: Don't get me wrong, I like new-build, but I can't honestly recommend people switch to it (well, I do recommend that, but that's selfish self-interest, hoping they'll be motivated to fix issues for me :p)
02:34:49 <cocreature> for some workflows it works pretty well and if it does work, it’s a lot more pleasant than old build
02:37:23 <a6a3uh> HI! I have a memoization question. I'm using MemoT from Control.Monad.Memo for mutual recursion memoization. It uses Map which is not most efficient. There are vector implementations as well but there is no transformer for these. Is there any way to use vectors with MemoT to combine 2 monads for mutual recursion?
02:38:32 <merijn> 60 lines Haskell function. I think this is a new record for me :>
02:40:59 <maerwald> are you sure that's haskell and not C?
02:41:35 <maerwald> the only times I did that was when using gtk+ and initializing widgets
02:41:49 <maerwald> could be deduplicated with TH, but then again, TH sucks
02:49:43 <AloeVenom> Gloss doesn't capture my numpad on arch ;-(
03:02:22 <maerwald> -Wdodgy-imports lol, didn't know that exists
03:04:27 <maerwald> am I the only one thinking that since stack has gained more popularity new GHC releases take way longer to be adapted by the ecosystem?
03:05:11 <Arahael> maerwald: It would make sense.
03:21:34 * hackagebot List 0.6.1 – List monad transformer and class – https://hackage.haskell.org/package/List
03:22:29 <saurabhn_> lifehack for anyone using intero -- while true; do sleep 3600 && killall intero; done
03:25:15 <barrucadu> Does it leak memory?
03:28:06 <AndreasK> maerwald: Stackage nightly supports new ghc releases pretty fast though (1-2 weeks). But maybe most people just stick to the lts ones
03:29:09 <saurabhn_> barrucadu: leak is an understatement. it gushes memory. 
03:29:15 <maerwald> most things are broken with 8.2.1, including ghc-mod, hdevtools and whatnot
03:29:24 <maerwald> I don't remember it taking so long for previous releases
03:33:34 <tabaqui> I'm playing with MonadCont now
03:33:52 <tabaqui> what "is" the type 'b' in callCC definition?
03:33:56 <tabaqui> callCC :: ((a -> ContT r m b) -> ContT r m a) -> ContT r m a 
03:34:24 <tabaqui> It looks like I can change it arbitrary and nothing happens
03:38:12 <AndreasK> maerwald: For ghc-mod it is because daniel can't spend time to update afaik. There isn't even a issue to support ghc 8.2.1 for hdevtools it seems. Seems more that individual packages hold many people back in that regard
03:46:30 <[exa]> tabaqui: iirc it's the discarded argument from callCC definition; the original "ignored but saved" continuation
03:46:43 <[exa]> tabaqui: try putting _ there
04:04:24 <ertes-w> tabaqui: the continuation never returns
04:04:29 <ertes-w> tabaqui:
04:04:31 <ertes-w> :t forever
04:04:33 <lambdabot> Applicative f => f a -> f b
04:04:54 <ertes-w> 'forever' never returns, so when you use it, you can pick an arbitrary result type
04:06:06 <ertes-w> tabaqui: in fact it would be even better if callCC's type were:  ((forall b. a -> ContT r m b) -> ContT r m a) -> ContT r m a
04:24:33 <tabaqui> [exa], ertes-w: ok, I catch it
04:26:06 <ski> tabaqui : `b' represents the type of an argument of an unused continuation/function
04:26:18 <ski> [exa] : not "ignored but saved", just ignored
04:28:44 <ski> > (`runStateT` 1) . forever $ do n <- get; put (2 * n); when (n >= 1000) (lift (Left n))
04:28:46 <lambdabot>  Left 1024
04:30:32 <josephlw> .
04:30:53 <ski>      '
04:32:03 <lavalike> ·
04:32:38 <[exa]>    :
04:32:40 <pacak> `
04:32:45 <lavalike> ruined
04:32:52 <[exa]> over the line!
04:33:12 <tabaqui> ski: your example is confusing me
04:33:26 <ski> tabaqui : it's not an example of `MonadCont'
04:33:32 <ski> (but of `forever')
04:33:34 <tabaqui> yeah, I see the State
04:33:40 <pacak> StateT
04:33:44 <tabaqui> but you can get out of forever
04:34:08 <tabaqui> Left 1024 >>= (const $ Left 1024) >>= (const $ Left 1024)
04:34:42 <tabaqui> that should not ends, but haskell somewhat returns just "Left 1024"
04:35:09 <ski> it "throws an exception"
04:35:51 <ski> in this case, `>>=' sometimes doesn't use its right argument
04:36:54 <tabaqui> yeah, right, forever doesn't mean "bind forever"
04:36:54 <ski> thereby aborting the infinite chain `... >>= (\x0 -> ..x0.. >>= (\x1 -> ..x0..x1.. >>= (..x0..x1..)))'
04:37:41 <ski> > foldr f (error "not reached") [0 ..]  :: Expr
04:37:44 <lambdabot>  f 0 (f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 (f 11 (f 12 (f 13 (f ...
04:37:51 <ski> is a bit similar
04:38:15 <ski> in case `f' sometimes doesn't use its right argument (or at least not right away), this can terminate
04:38:30 <ski> > foldr const (error "not reached") [0 ..]
04:38:33 <lambdabot>  0
04:39:21 <ski> > execWriter . (`runStateT` 1) . forever $ do n <- get; tell [n]; put (2 * n)
04:39:24 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
04:40:03 <ski> here, `Writer' is able to incrementally output parts of the "log", before the whole "process" terminating (which won't happen in this case)
04:40:48 <tabaqui> that is pretty easy, if you know how to deal with "fix"
04:41:48 <tabaqui> question for a interview: write factiorial function without recursion
04:42:29 <Psybur> Is there some flag I need to pass to get rid of "cant find .dll/.so" errors? I was able to build a dependency that needs these libraries just fine, but now my project that uses this dependency is getting this error
04:42:36 <Oipo> I'm having some difficulty filtering over lists of IO values, can someone take a look at this and help me along? http://lpaste.net/6740028040866168832
04:42:41 <Psybur> Do I need to add that library to my project too?
04:45:05 <Psybur> https://pastebin.com/nBhVYcwn
04:45:22 <Psybur> adding extra-libraries to .cabal didnt help
04:45:35 <Psybur> Also have extra-lib-dirs set to dir where the library is
04:45:41 <Psybur> stack build runs fine
04:45:52 <ski> > evalCont $ do f <- argFC; mapM f [0,1,2]  -- tabaqui, a `MonadCont' example
04:45:55 <lambdabot>  [0,0,0]
04:46:19 <ski> @type argFC  -- "argument of First Call"
04:46:20 <lambdabot> MonadCont m => m (a -> m a)
04:46:39 <cocreature> Psybur: what command did you ran to produce this error?
04:47:02 <Psybur> stack ghci produces that, and running the executable produces a similar error
04:47:34 <mniip> :t evalCont
04:47:36 <lambdabot> Cont o o -> o
04:47:45 <Psybur> Is the fact that that particular file is a symlink a problem?
04:48:14 <mniip> just admit that Cont is black magic already
04:49:18 <tabaqui> ski: yeah, thx, I've already written some simple code for learning, just want to dig deeper - how it is implemented
04:50:21 <ski> > let n = 5 in evalCont . liftM snd . callCC $ \k -> do (k,(i,p)) <- replicateCC n (k,(1,1)); k (i + 1,p * i)  -- here's factorial of `5'
04:50:24 <lambdabot>  120
04:50:29 <ski> @type replicateCC
04:50:31 <lambdabot> (MonadCont m, Integral i) => i -> (a -> m Void, a) -> m (a -> m o, a)
04:50:33 <ski> @type replicateCC1
04:50:35 <lambdabot> (MonadCont m, Integral i) => i -> (a -> m o, a) -> m (a -> m o, a)
04:51:02 <ski> tabaqui : how is what implemented ? `callCC' ? `argFC' ?
04:51:04 <Psybur> cocreature, if I set my LD_LIBRARY_PATH to /usr/lib the error is gone
04:51:24 <Psybur> I imagine there has to be a more elegant way to solve this? Or maybe not
04:51:39 <tabaqui> callCC and the whole monad
04:52:07 <ski>   newtype Cont o a = MkCont ((a -> o) -> o)
04:52:29 <ski> i think defining `return' isn't *that* hard (agree ?)
04:52:34 <ski> can you define `(>>=)' ?
04:52:41 <lyxia> Oipo: filterOnProps :: Int -> [IO Forms] -> IO [Forms]
04:52:44 <tabaqui> I can read how it is defined
04:52:58 <tabaqui> now I want to understand how it works
04:53:08 <Oipo> lyxia: *facepalm*
04:53:15 <Oipo> Thanks a bunch
04:53:27 <tabaqui> ski, I'm fine, just need to write all this stuff with pen and carefully inspect it
04:53:42 <ski> tabaqui : do you know about Continuation-Passing Style (CPS) ?
04:53:58 <tabaqui> just read yesterday
04:54:47 <ski> let's say we want to implement a function for computing the product of integers
04:54:51 <ski> we can do
04:55:04 <ski>   product :: [Integer] -> Integer
04:55:10 <ski>   product [    ] = 1
04:55:21 <ski>   product (n:ns) = n * product ns
04:55:59 <ski> however, we might prefer it if `product ([2,1,0] ++ [3 .. 1000])' could answer `0' without having to traverse the whole tail of the list
04:56:02 <tabaqui> ski, okay, okay, I read articles at wikipedia and wikibooks, that was the easiest thing
04:56:16 <ski> so, we could add before the recursive clause here :
04:56:24 <ski>   product (0:_ ) = 0
04:56:42 <BernhardPosselt> how do you deal with records that have 20+ fields?
04:56:56 <tabaqui> BernhardPosselt: no deal
04:57:02 <tabaqui> avoid them
04:57:28 <ski> however, if we now do `product ([1 .. 99] ++ [0] ++ [100 .. 1000])', we still have to multiply all the ninetynine preceding elements into zero
04:57:38 <tabaqui> if you really need them, I mean Really, then look at haskell templates
04:57:50 <ski> using CPS, we can avoid this, aborting the computation early
04:57:57 <BernhardPosselt> we have data with a lot of fields
04:58:03 <BernhardPosselt> products mainly
04:58:34 <ski> the idea is that instead of directly returning, we'll take a function (called "continuation") as argument, which we'll "return to" by passing it our previous return value
04:58:40 <toppler> Is there a recommended approach to serialising very large ADTs in a way which captures the sharing (so no pointer equal parts of the tree appear more than once)?
04:58:41 <ski> we get
04:58:53 <tabaqui> BernhardPosselt: use accessors, define Default instance
04:58:56 <ski>   product :: [Integer] -> (Integer -> Integer) -> Integer
04:59:04 <cocreature> Psybur: hm that seems wrong, can you show us your cabal file
04:59:06 <ski>   product [    ] k = k 1
04:59:13 <BernhardPosselt> product type alone has 130 fields :D
04:59:16 <ski>   product (0:_ ) k = 0
04:59:33 <ski>   product (n:ns) k = product ns (\p -> k (n * p))
04:59:42 <BernhardPosselt> tabaqui: i see
05:00:17 <ski> hm, er. rename this `product' to `productCPS', to account for the changing type. we can recover the original `product', with unchanged interface from this, as
05:00:19 <tabaqui> BernhardPosselt: but with 130 fields, it can be more handy to use 130-ary tuple
05:00:30 <ski>   product n = productCPS n (\p -> p)
05:00:40 <BernhardPosselt> tabaqui: whats the argument limit?
05:00:43 <tabaqui> and template function, to get the fields with indexes
05:00:50 <Psybur> cocreature, https://pastebin.com/LaW5L3YD
05:01:20 <BernhardPosselt> right, so basically create a default and then use setters
05:01:44 <tabaqui> https://www.haskell.org/onlinereport/basic.html#basic-tuples
05:01:54 <ski> `k' is the continuation here. note that we have decomposed the body of the original `product (n:ns) = n * product ns' into `n * (...)' and `product ns', turning the former into the function/continuation `\p -> n * p', and passing this as argument to the recursive call
05:02:23 <cocreature> Psybur: hm that looks reasonable, sry not sure what’s going on here. maybe try cabal to see if it’s a potential bug in stack
05:02:49 <ski> more accuratly, since the current call is passed a context/continuation `k', we also make this a part of the new continuation argument `\p -> k (n * p)' (aka `k . (\p -> n * p)')
05:03:17 <ski> thereby we *invert* the control structure, turning it inside-out
05:04:36 * tabaqui out for 20 minutes
05:09:12 <merijn> hmmm, any pipes experts here? I wanna buffer a number of awaits, but I'm not sure what the right way to do that is, if it's at all possible
05:09:40 <cocreature> merijn: pipes-async?
05:10:30 <merijn> cocreature: No, not what I want
05:10:40 <cocreature> then I don’t understand what you want :)
05:10:45 <maerwald> is Cabal config format specced?
05:11:10 <merijn> cocreature: Basically, I want a pipe that awaits up to N values before yielding anything
05:11:44 <cocreature> merijn: just call await 5 times before calling yield?
05:11:55 <cocreature> sry if I’m sounding stupid, I really don’t understand your goal here
05:12:34 <merijn> cocreature: The question is: I'm not sure how that interact with a push-based pipe that only yields 4 values :)
05:13:42 <merijn> I think I might need pipes-group or pipes-parse to cache N elements, which is a bit unfortunate :\
05:13:43 <cocreature> merijn: sounds like the usual problem of dealing with left-overs which is solved by pipes-parse which gives you "draw"
05:13:55 <ertes-w> toppler: GHC has introduced a feature called "compact regions" recently…  those can be serialised, but there is a caveat: you can only deserialise with the same executable
05:14:21 <ertes-w> toppler: if that's not good enough, then you need observable sharing, for which i found data-reify to be the best package
05:14:21 <merijn> cocreature: Except I feel pipes-parse is overkill, since I will never actually have left-overs
05:15:12 <merijn> cocreature: basically, I have a 1-to-1 relation between awaits/yields, I just don't want to start yielding until I've awaited N values (or I run out)
05:16:20 <ertes-w> merijn: i know you're probably sick of me suggesting machines by now, but PlanT is an Alternative, so you can branch on whether there is more data
05:16:54 <ertes-w> also no, pipes does not support it directly…  if you await and there is no corresponding yield, the 'await' will never return
05:17:05 <ertes-w> if you want to do it with pipes, you have to use pipes-parse
05:17:14 <merijn> ertes-w: That doesn't help me, because I'm not writing something for pipes either
05:17:43 <merijn> ertes-w: I'm writing something that I want to be able to use with both pipes and conduit. Perhaps machines too if that's not too hard
05:18:07 <merijn> ertes-w: The problem is figuring out how to formulate it in such a way that I can actually use it for both
05:18:48 <ertes-w> merijn: conduit is more likely to support that, because it lets consumers clean up in case there is no more data
05:19:12 <merijn> ertes-w: So tying it to machines is useless to me, because that wouldn't tackle my main problem of "I want to use this with all my existing pipes and conduit code" and that code won't be converted to machines since I'm using libraries that are tied to for example conduit
05:19:46 <ertes-w> i doubt that it's possible…  with pipes your only options are either pipes-parse or sending a termination signal explicitly, and it's not very nice to change everything from (Consumer a) to (Consumer (Maybe a))
05:20:36 <saurabhn_> in servant, when you're composing **functions**, not types with :<|>, can one pass lambdas instead of named functions?
05:20:38 <merijn> ertes-w: That's ok if the pipes-parse solution can fit the same code :)
05:20:49 <cocreature> tbh it some point just writing two modules to support pipes and conduit is easier than trying to share the code
05:20:49 <merijn> ertes-w: But if I can get by without requiring pipes-parse that'd be a bonus
05:20:51 <cocreature> *at
05:21:01 <ertes-w> merijn: pipes-parse is very different though…  it works like python generators, so it's not composable in the same way
05:21:16 <merijn> cocreature: And how would I do that without adding dependencies on both?
05:21:36 <cocreature> merijn: write your base package and then write a package-pipes and a package-conduit package
05:21:52 <ertes-w> merijn: if you're writing a consumer, write a fold…  it's easy to translate folds into streaming frameworks
05:22:13 <ertes-w> just take the 'yield' action as an argument
05:23:13 * hackagebot hledger-iadd 1.2.6, hsyslog-tcp 0.2.0.0, nakadi-client 0.2.0.1
05:23:13 * hackagebot  → https://hackage.haskell.org/packages/recent
05:23:18 <merijn> cocreature: I've considered that, but 1) duplicating the async safety code is a no-go since it's tricky enough as-is and keeping it safe across two copies is hell. 2) that approach would require duplicating/reexporting a bunch of stuff
05:23:43 <merijn> ertes-w: I already have the fold, that's easy. It's the pipe I'm suffering through right now
05:23:49 <cocreature> merijn: sure, it’s not pretty either but at least it gets the job done
05:24:13 <ertes-w> merijn: well, then you're done, aren't you?
05:24:36 <merijn> cocreature: It boils down to finding a common enough formulation that can work with either so I can share the async/threading code and allow the "implementation" to be passed in as a record or whatever
05:24:54 <merijn> cocreature: And then that can be either packaged up as a separate package-pipes library or done by the user
05:24:55 <ertes-w> merijn: ah, no, i mean write the pipe as a fold…  use the fold for receiving and abstract over the 'yield' action for sending
05:25:32 <merijn> ertes-w: I already have that, but that doesn't work for what I want unless I can buffer N values first
05:25:55 <ertes-w> why?
05:26:07 <merijn> ertes-w: Because it's kinda pointless to process 1 value in parallel :p
05:26:30 <merijn> ertes-w: I need enough values to actually feed my parallelism before :)
05:26:37 <ertes-w> you can have arbitrary state in your fold…  just buffer until you have received enough values
05:27:02 <merijn> ertes-w: My entire question was about how to implement that specific thing
05:28:00 <merijn> ertes-w: I don't know how I can write a fold that yields values in pipes
05:28:14 <merijn> I mean, I know how to do it by hand
05:29:17 <ertes-w> > foldr (\x go (n, xs) -> if n >= 5 then reverse xs : go (0, []) else go (n + 1, x:xs)) (pure . snd) [0..13] (0, [])
05:29:17 <merijn> That's the entire issue I'm trying to figure out :)
05:29:19 <lambdabot>  [[0,1,2,3,4],[6,7,8,9,10],[13,12]]
05:29:31 <ertes-w> merijn: like that, but effectful
05:30:58 <ertes-w> and with a Seq buffer rather than [] perhaps =)
05:31:16 <merijn> ertes-w: I don't need to group after the initial N
05:32:35 <ertes-w> aren't you doing parallelism?  i thought you're going to buffer groups of n, then process, then yield, then start buffering again
05:33:14 <merijn> ertes-w: Well, with N threads if I managed to feed in N then every time 1 finishes I know I can start the next one
05:33:44 <ertes-w> merijn: actually, why don't you just fire up n workers and feed the values into a bounded channel?
05:34:14 <merijn> That's what I do for the consumer. The problem is yielding the results from processing again
05:35:05 <merijn> ertes-w: I need to yield a result for every input from the pipe again
05:35:32 <ertes-w> yeah, coroutines aren't particularly great at that
05:36:01 <merijn> ertes-w: I can produce a single consumer and producer that have to be run in different threads, but that's...not very nice
05:36:03 <ertes-w> something like this i'd probably not do with a streaming processing framework…  except perhaps with concurrent-machines
05:36:10 <merijn> It's my fallback plan, but I'd rather produce something nicer
05:36:31 <ertes-w> concurrent-machines has that particular data flow built in
05:36:44 <ertes-w> distribute to workers, then collect
05:36:54 <ertes-w> not "then", but "and at the same time"
05:37:18 <merijn> ertes-w: Well, it's not actually that bad, you can pair each await with a yield, if you can manage to fill the pipe first
05:37:45 <merijn> ertes-w: machines doesn't seem to have much in the support of libraries, though
05:38:04 <merijn> In general we need a better story for libraries supporting streaming library agnostic tools in Haskell
05:38:38 <merijn> Wanna use http-conduit/persistent? Welp, better use conduit for everything, since you can't really use any of the other streaming libraries with them
05:38:52 <ertes-w> yes, i find myself writing more boilerplate code with machines…  i'm going to package some of that and release it though in the hope to make it more popular =)
05:39:35 <merijn> ertes-w: With the "m (Maybe a)" from pipes-parse and conduit it should be fairly straightforward to write this, though
05:39:44 <ertes-w> unfortunately the only way i see to support multiple frameworks is by writing folds and unfolds
05:40:00 <ertes-w> pipes-parse is not very nice
05:40:09 <ertes-w> it's basically python generators
05:40:41 <ertes-w> they share the same composability limits
05:41:03 <merijn> ertes-w: Yeah, but conduit's lack of push-based abstraction isn't nice either :)
05:42:02 <merijn> I just want to be able to pick which streaming library to use based on what I need at the moment
05:42:35 <ertes-w> the problem is: none of the frameworks are good at encoding concurrent data flow
05:42:38 <merijn> Maybe ezyang's Backpack stuff will result in a nice streaming interface so we can indeed write streaming agnostic libraries in, like, a decade when it's production ready
05:42:53 <ertes-w> even concurrent-machines is, on some level, just a hack, because machines is still coroutines
05:43:03 <Alovenom> Sad
05:43:23 <merijn> ertes-w: pipes-concurrency works for running pipes concurrently, but not for running a section of your pipeline concurrently
05:43:44 <Alovenom> http://lpaste.net/358557
05:44:12 <Alovenom> Now that I made it work in Linux it doesn't in Windows anymore
05:44:22 <Alovenom> at least stack ghci works
05:44:47 <merijn> ertes-w: What do you imagine for streaming other than coroutines, then?
05:44:51 <ertes-w> merijn: concurrent-machines does support that, but on a lower level it does the same thing as pipes-concurrency…  the missing feature is to pick between awaiting and yielding based on whether data is available through an 'await' vs. some concurrency abstraction like MVar
05:45:21 <ertes-w> in other words: something like STM that integrates with 'await'
05:45:25 <merijn> ertes-w: Yeah, but always using MVar would probably cost you quite a bit of overhead
05:45:40 <ertes-w> yeah, MVar was just an example
05:46:37 <ertes-w> so far i'm not await of a framework that supports "concurrent retry"
05:46:59 <ertes-w> s/await/aware/  -- too much talking about streams =)
05:53:56 <merijn> ertes-w: Hence why I'd rather struggle 2 days and write something that solves this issue permanently for me rather than hackily reinventing it every time I need it :)
05:55:26 <ertes-w> merijn: the other option is to just do it using concurrency and leave it to your future self to do the framework integration =)
05:56:07 <merijn> ertes-w: I already have 3 hacky versions in different packages, I'm trying to get rid of those
05:57:36 <ertes-w> merijn: i see no other option, as long as awaiting blocks
05:58:32 <merijn> ertes-w: I think I'll just rely on the existence of "m (Maybe a)" for now
06:01:21 <ertes-w> merijn: you don't have to…  you're writing a fold, so you can handle EOS anyway
06:01:36 <merijn> ertes-w: I don't see how to do it with the fold, tbh
06:01:48 <ertes-w> did my foldr example not make sense?
06:02:08 <merijn> I understand the fold example, but I don't know how to adapt/make it work for me
06:09:38 <ertes-w> merijn: if you're patient i can write a small example later…  right now i'm busy unfortunately
06:11:16 <maerwald> lazy question: anyone knows a package offhand that has a lot of extra-libraries and pkgconfig-depends in the cabal file?
06:12:28 <merijn> ertes-w: I'll probably go home in a few hours, but if you don't have time before then an lpaste + @tell works for me :)
06:34:15 <Psybur> Is there a way to construct a vector in a way similar to constructing a list? Like prepending values to empty
06:35:40 <Psybur> Guess not if hoogle doesnt give me anything for a -> Vector a -> Vector a ?
06:35:45 <ertes-w> Psybur: you can unfold vectors
06:36:15 <ertes-w> Psybur: you shouldn't 'cons' a vector, because each time you prepend an element, the whole vector needs to be recreated
06:36:23 <Psybur> I see
06:37:05 <ski> @type Data.Vector.unfoldrN
06:37:06 <lambdabot> Int -> (b -> Maybe (a, b)) -> b -> Data.Vector.Vector a
06:37:37 <ertes-w> Psybur: unfoldr is ok, and unfoldrN is ideal
06:37:45 <merijn> Psybur: There's a whole bunch of construction methods in Data.Vector
06:37:53 <merijn> Psybur: https://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector.html#g:7
06:38:09 <merijn> Also
06:38:12 <merijn> "cons :: a -> Vector a -> Vector a"
06:38:14 <ertes-w> Psybur: whenever you can, use one of the specialised methods like 'generate' or 'construct'
06:38:17 <tabaqui> great, mtl has no MaybeT, AccumT and SelectT classes
06:38:21 <merijn> But the performance is awful
06:38:26 <tabaqui> *types
06:38:44 <ertes-w> tabaqui: there is an effect class for MaybeT: it's called Alternative
06:38:57 <Psybur> merijn, interesting. I searched exactly for a -> Vector a -> Vector a and cons didnt pop up
06:39:14 <ertes-w> tabaqui: import Control.Applicative
06:39:17 <merijn> Psybur: Does Hoogle even index vecotr? :)
06:39:41 <Psybur> merijn, Warning: Unknown type Vector
06:39:45 <Psybur> hmm
06:39:53 <ski> @hoogle Int -> (s -> (a,s)) -> a -> Vector a
06:39:53 <lambdabot> Data.Vector unfoldrN :: Int -> (b -> Maybe (a, b)) -> b -> Vector a
06:39:54 <lambdabot> Data.Vector accum :: (a -> b -> a) -> Vector a -> [(Int, b)] -> Vector a
06:39:54 <lambdabot> Data.Vector unsafeAccum :: (a -> b -> a) -> Vector a -> [(Int, b)] -> Vector a
06:40:05 <Psybur> @hoogle a -> Vector a -> Vector a
06:40:06 <lambdabot> Data.Vector cons :: a -> Vector a -> Vector a
06:40:06 <lambdabot> Data.Vector snoc :: Vector a -> a -> Vector a
06:40:06 <lambdabot> Data.Vector (++) :: Vector a -> Vector a -> Vector a
06:40:10 <merijn> Psybur: Sounds like a no :p Hoogle doesn't index all of Hackage. Although you can install it locally and make it index everything you have installed
06:40:17 <Psybur> Hmm it shows up here, but not on the web interface
06:40:23 <tabaqui> ertes-w: ehm, can you explain more?
06:40:23 <merijn> Psybur: Lambdabot might be using a local Hoogle instance
06:40:54 <tabaqui> I want combine IO and Maybe in MaybeT
06:41:21 <tabaqui> *want to
06:44:02 <orion> Hey. The amqp library requires me to pass in a callback which runs in IO. I wish to pass the library a callback which runs within a monad transformer whose base is IO. I've read that monad-control can help me with this so long as MonadBaseControl is an instance of every layer.
06:44:08 <orion> Is this true? Is this recommended?
06:44:41 <merijn> orion: I wouldn't recommend monad-control just because it's confusing as fuck :)
06:45:17 <merijn> orion: But in some cases you might be unable to do anything else. Depends what the API of amqp looks like
06:46:03 <orion> merijn: https://www.stackage.org/haddock/lts-9.5/amqp-0.15.1/Network-AMQP.html#v:consumeMsgs
06:46:56 <merijn> What transformer stack do you plan to pass in?
06:47:23 <merijn> Because I suspect monad-control might not even let you do what you want :)
06:47:45 <orion> ReaderT AppEnv (LoggingT IO) a -- https://www.stackage.org/haddock/lts-9.5/logging-effect-1.2.1/Control-Monad-Log.html#t:LoggingT
06:48:07 <orion> Note the existence of a MonadBaseControl instance for LoggingT.
06:48:11 <tabaqui> mtl ExceptT has no throwE, catchE functions
06:48:44 <tabaqui> if such things continue to happen, I will refactor this libraries by myself
06:49:15 <tabaqui> *these
06:50:21 <merijn> orion: The issue is that every callback is going to run separately and the return value of consumeMsgs is never going to be something other than IO
06:50:52 <merijn> tabaqui: What's wrong with using the exports of transformers?
06:51:17 <ertes-w> tabaqui: 'pure' corresponds to Just, 'empty' corresponds to Nothing, (<|>) is "or", (<*>) is "and"
06:51:28 <merijn> orion: You probably want to use runReaderT and runLoggingT to turn your "ReaderT AppEnv (LoggingT IO) a" into "IO a" and pass that to consumeMsgs
06:51:29 <orion> merijn: I don't understand the implications of this. Could you explain?
06:51:51 <orion> "is never going to be something other than IO"
06:52:31 <ertes-w> tabaqui: and (>>=) is kind of a "dependent and"
06:52:37 <tabaqui> merijn: if mtl is high-level transformers, then it have to reexport its api
06:52:37 <merijn> orion: You cannot make the result consumeMsgs have access to the LoggingT/ReaderT you want in the callback
06:53:04 <tabaqui> ertes-w: empty :: IO () throws an error
06:53:19 <ertes-w> tabaqui: you were talking about MaybeT
06:53:29 <tabaqui> hm, sec
06:53:42 <ertes-w> empty = MaybeT (pure Nothing)
06:53:45 <merijn> tabaqui: throwE is replaced with "throwError" in Control.Monad.Except
06:54:01 <orion> merijn: Would this situation be different if I changed the type of consumeMsgs to (MonadIO m) => Channel -> Text -> Ack -> ((Message, Envelope) -> m ()) -> m ConsumerTag ?
06:54:29 <ertes-w> tabaqui: (<|>) is MaybeT's 'catch' function
06:54:35 <merijn> orion: That wouldn't really change all that much, tbh
06:55:07 <tabaqui> merijn: ok, sorry, throwE is replaced, yes
06:55:19 <merijn> So is catchE, with catchError
06:55:48 <tabaqui> ertes-w:yeah
06:55:56 <orion> merijn: You're saying that the type above would not allow me to access the logging functions in LoggingT?
06:55:56 <tabaqui> *merijn, yeah
06:56:03 <merijn> orion: The idea is that the IO action runs until completion for every message, so the only way to communicate state/data between callbacks for different messages is to store it somewhere
06:56:35 <merijn> orion: You can just use "runReaderT" and "runLoggingT" to turn your LoggingT into a function returning IO and pass that to your callback?
06:56:39 <tabaqui> ertes-w: ah, ok, I understand what are you talking about
06:57:08 <tabaqui> that makes sense, if we consider mtl as classes, not as high-level api
06:57:21 <tabaqui> then MonadMaybe is Alternative, yes
06:57:29 <orion> merijn: Isn't that precisely what MomadBaseControl does?
06:57:34 <orion> MonadBaseControl*
06:57:39 <merijn> orion: No
06:57:52 <tabaqui> ertes-w, merijn, thanks
06:57:54 <merijn> orion: That does way more complicated things in a confusing way :)
06:58:32 <merijn> orion: So, you have like "(Message, Envelope) -> ReaderT AppEnv (LoggingT IO) ()", yeah?
06:58:44 <orion> Sure.
06:59:39 <ertes-w> tabaqui: yes, 'empty' throws, (<|>) catches
07:00:00 <merijn> orion: You'd pass something like this to the callback: "\msg -> runStderrLoggingT (runReaderT (yourFun msg) yourEnv)"
07:00:02 <orion> Sure.
07:00:12 <merijn> And then you're done
07:00:15 <orion> Yes, I understand your solution.
07:00:51 <orion> I was just hoping there was a super slick category theory heavy solution to this.
07:01:04 <merijn> Probably, but why make your life difficult?
07:01:42 <orion> Because there is value in suffering. I want to suffer so hard that I become as knowledgeable and experienced as Ed Kmett.
07:04:40 <orion> If MonadBaseControl is *incorrect* but works, that's something I wish to avoid. However, if it's mathematically correct but horribly complicated, that's a different situation.
07:07:24 <merijn> orion: The problem MonadBaseControl tries to solve is: 'bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c", but I want my bracket to run in some monad stack, so I need to somehow lift, e.g., StateT to persist state across the init/finalisation operations
07:07:36 <merijn> orion: Which is not quite the problem you have
07:13:50 <orion> I'm not sure what the difference is. I want my consumeMsgs callback (resp. bracket) to run in some monad stack.
07:18:09 <merijn> orion: Because consumeMsgs is run as a callback (presumably in some other thread) the effects of that stack can never propagate back into the IO result that consumeMsgs gives you
07:18:36 <merijn> orion: How could it? The IO returned from consumeMsgs is completely detached from your callback. Unlike what bracket does
07:19:33 <nshepperd_> MonadBaseControl is about turning (a -> IO b) -> IO c into (a -> m b) -> m c
07:20:21 <merijn> nshepperd_: That only makes sense if you can actually propagate stuff from the 'm b' to the 'm c' which you usually can't for callbacks
07:21:16 <nshepperd_> Yes, it won't work if you want to run things concurrently
07:21:35 <orion> In the case of StateT you want to propagate state, which I understand. I Also understand that you could never hope to propagate state back (since it's a callback). However in this case my stack is stateless.OC
07:22:19 <orion> I am only interested in the side effects IO provides.
07:22:35 <orion> I don't mind "losing" information because there is nothing to lose.
07:22:48 <merijn> orion: Right, but then there's also no point in using monad-control
07:26:17 <orion> hmm
07:33:59 <ski> orion : hm, so in the environment case, you'd want to go from `(a -> IO b) -> IO c' to `(a -> r -> IO b) -> r -> IO c' ? how should `r' be propagated into the callback here ?
07:34:36 <Psybur> How do I figure out exactly what name of the file ghc is looking for when its looking for a c library? Im able to get everything working fine on linux, but on windows it cant find the library.
07:35:06 <Psybur> The windows lib folder looks like it has a bunch of different .lib files with different name suffixes for different releases. Wondering if I need to rename one of them or something
07:35:08 <nshepperd_> You could use liftBaseDiscard from MonadBaseControl for this application. But it would just act as a wrapper around runLoggerT and runReaderT, not much better than doing that directly
07:36:32 <cocreature> Psybur: try compiling with -v3 to see how ghc invokes gcc for linking
07:38:15 <quchen> What’s the current-and-cool Regex lib for Haskell?
07:38:37 <merijn> quchen: Was there ever a current-and-cool regex lib? :p
07:38:55 <quchen> What’s the most current-and-cool Regex lib for Haskell?
07:38:55 <cocreature> quchen: I like regex-applicative, not sure if it’s current and cool :)
07:39:11 <cocreature> but at least it has a pretty nice API
07:48:17 <quchen> Alright, thanks!
07:48:29 <Psybur> cocreature, seems like when I pass --extra-lib-dirs=C:\ta-lib\c\lib its not getting passed to ghc?
07:48:39 <Psybur> stack build --extra-lib-dirs=C:\ta-lib\c\lib 
07:49:23 <orion> ski: I see.
07:49:49 <cocreature> Psybur: maybe try setting extra-lib-dirs in your cabal file?
07:50:06 <Psybur> cocreature, they are there in each library and executable section
07:51:47 <cocreature> Psybur: sorry, I’m out of ideas
07:57:55 <Psybur> cocreature, seems when I get rid of the = sign it gets used, lets see if it works now D;
08:08:30 <orion> ocharles: Are you in?
08:14:56 <fuzzball909> yo
08:15:12 <erisco> laugh it up
08:15:32 <Psybur> ~erisco++
08:19:24 <geekosaur> Psybur, might see if you can see exactly what is being passed via some verbose option
08:19:34 <geekosaur> I am wondering if this is another leaky unixism
08:19:57 <geekosaur> (or maybe overcompensation, so a Windows API is seeing double backslashes!)
08:22:25 * hackagebot apecs 0.2.0.3 – A fast ECS for game engine programming – https://hackage.haskell.org/package/apecs
08:23:24 <bolver> quick question -- what's the difference, if any, between using an accumulator vs using a difference list?
08:23:53 <merijn> bolver: I don't see how those things relate to eachother?
08:25:02 <bolver> merijn: well, i came across something on stackoverflow, where a responder said difference list is clearly better than an accumulator
08:25:19 <merijn> Needs more context
08:25:24 <int-e> Psybur: lambdabot is using the hoogle command line tool (cabal install hoogle; hoogle generate); no special tweaks.
08:25:53 <bolver> merijn: see https://stackoverflow.com/questions/34430622/reducing-space-usage-of-depth-first-tree-traversal/34432102#34432102
08:28:44 <bolver> over there in stackoverflow link i pasted, /u/ andras kovacs, in his response, says that difference list is superior to an accumulator.  i am wondering why
08:29:07 <merijn> bolver: I don't think you can generalise the statements there from this specific example
08:29:16 <merijn> Actually, I'm pretty sure you can't
08:29:58 <bolver> merijn: ok, but what could be their differences?
08:30:14 <c_wraith> bolver, difference lists are cheaper when you do a lot of appending, and then materialize the result on me.
08:30:22 <c_wraith> ... once
08:30:30 <c_wraith> stupid autocorrect
08:30:43 <bolver> c_wraith: ok
08:30:45 <erisco> dirty
08:31:04 <c_wraith> bolver, specifically, appending a small list to the end of a long one
08:32:15 <bolver> c_wraith: yeah, i thought so, but using difference list, you sort of the cons the thing, right?
08:33:01 <geekosaur> it's a chain of evaluations instead of a chain of conses
08:33:25 <bolver> geekosaur: something like showString?
08:34:00 <erisco> what if you use Church lists?
08:34:37 <bolver> c_wraith: and what about accumulators? where are they appropriate?
08:34:55 <toppler> ertes-w: Thanks for the info on the serialisation stuff.
08:35:17 <erisco> cons x xs f z = f x (xs f z); snoc x xs f z = xs f (f x z)
08:35:51 <c_wraith> accumulators are most appropriate when the accumulated value is "small" (usually meaning not recursive)
08:36:08 <bolver> c_wraith: i see
08:36:41 <c_wraith> you have to be careful with strictness while using an accumulator, though.
08:36:41 <bolver> c_wraith: but i see a lot of recursive functions implemented using accumulators
08:36:53 <bolver> a common example is reverse
08:37:27 <c_wraith> well, reverse is at least strict. :)
08:38:19 <bolver> c_wraith: in a difference list, you wouldn't have that problem?
08:38:22 <c_wraith> it just depends on laziness properties of the operation.
08:38:26 <bolver> i mean lazy vs strict?
08:39:54 <c_wraith> which problem?
08:41:09 <c_wraith> difference lists are very funny to think about, in terms of evaluation.
08:41:33 <bolver> well, i was looking at something on stackoverflow, where replacing an implementation with accumulator with difference list made a huge difference in space complexity
08:41:36 <bolver> https://stackoverflow.com/questions/34430622/reducing-space-usage-of-depth-first-tree-traversal/34432102#34432102
08:41:40 <c_wraith> as it depends in how a bunch of calls to (.) get associated.
08:42:39 <bolver> see /u/ andras kovacs -- he proposed a difference list implementation that solved the issue
08:43:02 <Fawaz_> hi
08:43:04 <bolver> i just wanted know why the difference list worked better in this case 
08:45:33 <bolver> basically, the problem is that when an accumulator is used, the traversed nodes are not garbage collected, so we have a huge space usage.  but the problem goes away if we use a difference list
08:46:09 <erisco> Church lists give O(1) cons and snoc, afaik
08:46:11 <bolver> i couldn't understand why this improvement happens with difference list
08:47:08 <erisco> of course you could also use Sequence and apparently that is something magical
08:47:22 <shapr> has anyone tried haskey?
08:49:00 <bolver> appreciate any help
08:49:40 <c_wraith> bolver, well, the big difference is that the original definition builds a giant function expression that depends on 2^n nodes of the tree,
08:50:17 <c_wraith> bolver, and the way it is constructed, it can't evaluate any if it without evaluating the whole thing
08:50:23 <c_wraith> *of
08:50:30 <bolver> c_wraith: ok, could you elaborate a bit?
08:50:58 <bolver> c_wraith: it sort of builds the list from the last element
08:51:38 <c_wraith> the accumulator argument in the original is of type ([Int] ->[Int])
08:51:54 <bolver> c_wraith: yes, correct
08:51:57 <c_wraith> so what it's actually accumulating is a function.
08:52:09 <bolver> c_wraith: yes, true
08:52:40 <erisco> hm that'd be smart… a cons then snoc is the same as a snoc then cons, but the latter is less strict
08:53:17 <erisco> my "then" is a bit confusing… am thinking of inside out
08:53:40 <bolver> c_wraith: so you are saying that the whole function has to be built-up by traversing the entire list before it can be applied?
08:53:46 <erisco> so if you annotated these operations, with newtypes, you can optimise on the fly
08:54:20 <erisco> er, I guess newtypes don't work … then the overhead of an ADT makes it not worth it … hrm
08:54:53 <erisco> maybe with overloaded functions…
08:55:28 <c_wraith> and in the resursive case, the accumulated function is built from right to left, (it calls t2 as the outermost call), but lists are generated left-to-right
08:56:10 <c_wraith> bolver, that conflict is why the whole thing has to be materialized in memory before it can make progress.
08:56:58 <c_wraith> the problem isn't the accumulator, per se. it's that it accumulates the wrong direction to be productive.
08:57:33 <bolver> c_wraith: yes, i have see that .. so because it is constructed from right to left, haskell waits for the whole list to be constructed before GCing any nodes traversed?
08:59:02 <c_wraith> basically, think of it as it had to build the whole tree to know what to do first. then it keeps the remainder of it around until it's done with it.
09:00:29 <bolver> c_wraith: i see.  so the order of how a list is built up in haskell matters? i mean, it should be from left to right, rather than right to left?
09:00:58 <c_wraith> if you want to be able to consume it as it is produced, yes.
09:01:14 <bolver> c_wraith: i see
09:02:02 <ertes-w> bolver: "direction" is a bit confusing…  in principle lists are always built and consumed from left to right, but it's often useful to think of constructing from right to left
09:03:06 <ertes-w> for example often when you 'foldr' to a list, your question becomes: "ok, given a recursively built xs, what would i prepend?"
09:03:24 <bolver> c_wraith, ertes-w: i see.
09:03:58 <bolver> ertes-w: same with foldl as well?
09:04:04 <c_wraith> bolver, in contrast, the naive solution only depends on one path through the tree being materialized at once. then it produces the first element of the result, and the rest of the computation is hidden behind the (:) constructor.
09:05:01 <bolver> c_wraith: yes, it sort of builds the list "backwards" as you mentioned eralier
09:05:09 <c_wraith> bolver, switching to a difference list from the naive solution just removes some of the list-copying overhead in (++)
09:05:42 <ertes-w> bolver: foldl is a completely different thing…  in fact you would rarely use foldl to build a list with one of the few examples being 'reverse'
09:05:47 <bolver> c_wraith: where does the (++) come in the naive solution?
09:06:56 <bolver> ertes-w: i see .. 
09:06:59 <c_wraith> bolver, it is used to concatenate the recursive results from the left and right subtrees
09:08:39 <bolver> c_wraith: i stepped through the code, and what i saw was a chain of cons, but starting from the right (end of the list) -- something like a : (b : (c : (d : [])))
09:09:35 <c_wraith> bolver, well, yes. (++) reduces to a chain of conses
09:10:52 <bolver> c_wraith: so if you build list starting from the right, as this naive code does, then haskell basically ends up using (++)?  i am just trying to make sure i understand what you are saying
09:11:34 <c_wraith> bolver, maybe we're not looking at the same thing. I mean the solution labeled "naive" in the answer.
09:12:15 <bolver> c_wraith: oh, sorry
09:13:25 <bolver> c_wraith: i am not looking at the naive solution -- but the the one using the accumulator.  but even more puzzling is that the "naive" solution performs better than the accumulator-based solution
09:14:10 <c_wraith> well, as I said. the accumulator works backwards, so it gets in the way.
09:15:15 <c_wraith> you could write a solution with an accumulator that works forwards, and it would be fine. I think the answer erred in emphasizing the accumulator as the problem.
09:15:26 <Gurkenglas> Should/Does anything on hackage use functions as data structures? I keep seeing them used as O(1) write, O(n) read key-value-maps in assignments from homework questions
09:15:43 <bolver> c_wraith: ah, yes!  thanks for clearing that up.
09:16:10 <c_wraith> Gurkenglas, relative to the current conversation, there's the DList package. :)
09:16:33 <bolver> c_wraith: if the accumulator built the list from the left, it would be essentially identical to the difference list solution, right?
09:16:56 <Psybur> Does haskell support loading in .lib c libraries?
09:17:14 <c_wraith> bolver, pretty much. possibly it would even reduce to identical, if you worked on it for a while.
09:17:36 <Psybur> Or should I have a dll somewhere? I dont see a dll being made when I compile the c library though strange
09:18:11 <bolver> c_wraith: yes, that's what i thought.  i think, like you said, the stackoverflow erred in empasizing the accumulator as the problem
09:18:38 <ertes-w> bolver: BTW, if you're interested, i have written an extensive tutorial on foldr: http://ertes.eu/tutorial/foldr.html
09:18:45 <bolver> c_wraith: thanks very, very much.  that was a big relief, indeed!  i was quite confused, and now i am clear
09:19:04 <bolver> ertes-w: thanks, i will look that up
09:19:07 <c_wraith> bolver, happy to have helped
09:19:37 <ertes-w> bolver: it should deepen your knowledge about folds in general, and it also explains how foldl is really just a special case of foldr (and why the converse is not true)
09:20:01 <bolver> c_wraith: i am quite impressed by how fast you analyzed the problem ... thanks indeed for your time
09:20:46 <bolver> ertes-w: yes, i really need to study foldr and foldl, so will definitely read your tutorial
09:20:51 <bolver> thanks
09:20:53 <c_wraith> bolver, I guess I've been using haskell for 10 years or so now. apparently, you do learn as you go. :)
09:21:10 <bolver> c_wraith: :)
09:21:22 <bolver> c_wraith: have a good day!
09:22:57 <erisco> dynamically there is no difference and statically you can just use a rewrite rule, so w/e
09:23:15 <ertes-w> Gurkenglas: church encoding is also a common use of functions as data structures
09:24:21 <erisco> Gurkenglas, well I was just talking about Church lists having constant-time cons and snoc
09:25:43 <ertes-w> erisco: that's misleading though: [] also has constant-time snoc
09:26:11 <erisco> can you demonstrate that?
09:26:37 <ertes-w> erisco: you mean this, right?  snoc xs x f z = xs f (f x z)
09:26:50 <erisco> I mean give me the constant-time snoc with []
09:27:18 <ertes-w> snoc xs x = foldr (:) [x] xs
09:27:33 <ertes-w> that's "constant time" the same way the church version is =)
09:27:47 <ertes-w> anyway, i have to go…  happy to continue tomorrow =)
09:28:56 <erisco> you just changed the list to the Church encoding and then snoc'd
09:30:23 <erisco> that conversion will cost you O(n)
09:34:16 <erisco> if we wanted to get closer to [] then we'd use endofunctors [a] -> [a]
09:36:11 <Gurkenglas> Hm, I suppose any data structure can be represented by a function, its catamorphism.
09:36:12 <nshepperd> ertes-w: the church version is actually constant time in that you only pay O(1) to evaluate the snoc once
09:36:34 <erisco> Gurkenglas, I don't know what happens for GADTs though
09:37:57 <Gurkenglas> What about GADTs would be hard to translate? The method of multiple constructors and multiple arguments to them carries over
09:38:03 <nshepperd> foldr (:) costs O(n), deferred as you pay O(1) for each element that you uncons later
09:39:00 <Gurkenglas> Values as type arguments or something?
09:39:19 <erisco> Gurkenglas, I said "I don't know" because I put no thought into it :) hoping you could tell me
09:40:07 <phadej> Gurkenglas: i wrote once about GADTs in Purescript (where you emulate them with rank2 functions): http://futurice.com/blog/more-gadts-in-purescript
09:41:07 <Gurkenglas> Splendid! Does that mean ImpredicativeTypes can be reduced to RankNTypes?
09:41:34 <nshepperd> irregular recursive types won't have a catamorphism
09:41:37 <phadej> Gurkenglas: very shortly (about GADTs) that's the same reason why Coq has inductive types and didn't stay with "basic" calculus of constucts
09:43:22 <Gurkenglas> "very shortly" meaning "soon" or "in basic terms"?
09:43:37 <phadej> in basci terms
09:45:29 <erisco> @let cons x = Endo (\f xs -> x : f xs)
09:45:32 <lambdabot>  Defined.
09:45:42 <erisco> @let snoc x = Endo (\f xs -> f (x : xs))
09:45:45 <lambdabot>  Defined.
09:45:53 <erisco> @let getList (Endo f) = f id []
09:45:57 <lambdabot>  Defined.
09:46:49 <Gurkenglas> snoc appends to the front of the second half of a list constructed by snocs and conses, not the back, btw
09:47:05 <phadej> Gurkenglas: expanding on that, even you can encode type-equality using rank-n-types (Leibniz), you can do less (useful) things with it
09:47:11 <erisco> > getList (snoc 4 <> snoc 3 <> cons 1 <> snoc 2)
09:47:14 <lambdabot>  error:
09:47:14 <lambdabot>      Ambiguous occurrence ‘snoc’
09:47:14 <lambdabot>      It could refer to either ‘Lens.snoc’,
09:47:43 <erisco> thanks Lens… no idea what module my snoc is in
09:48:12 <Gurkenglas> > getList (L.snoc 4 <> L.snoc 3 <> L.cons 1 <> L.snoc 2)
09:48:15 <lambdabot>  [1,2,3,4]
09:52:03 <erisco> > (getList . foldMap snoc) [1..10]
09:52:05 <lambdabot>  error:
09:52:05 <lambdabot>      Ambiguous occurrence ‘snoc’
09:52:05 <lambdabot>      It could refer to either ‘Lens.snoc’,
09:52:10 <erisco> > (getList . foldMap L.snoc) [1..10]
09:52:13 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
09:53:44 <Gurkenglas> Ah, it doesn't, and I should have known after all these years.
10:02:21 <erisco> how to reverse a list in 12 difficult steps
10:16:03 <Psybur> Anybody know how to get around:  Loading package <pkg> ... Segmentation fault/access violation in generated code
10:16:06 <Psybur> On windows?
10:16:34 <Psybur> Besides patching ghc? D:
10:20:26 <orion> I have a Foo { fooA :: String, fooB :: String, ... }. I have environment variables FOO_A, FOO_B, ... . Is there a clean/neat/concise way of constructing a (Maybe Foo) from a bunch of maybeFooA, maybeFooB, ... and explicitly returning Nothing if *any* environment variable is nothing?
10:20:41 <orion> I suspect Alternative might be useful here?
10:22:47 * hackagebot checkmate 0.1.0 – Generate checklists relevant to a given patch – https://hackage.haskell.org/package/checkmate
10:24:46 <monoidal> orion: you mean by looking up the env variables :: Maybe a ?
10:25:45 <orion> monoidal: Yes: lookupEnv.
10:26:29 <lyxia> Foo <$> getFooA <*> getFooB <*> ... <*> getFooZ
10:27:09 <orion> Ah, great.
10:27:57 <monoidal> lyxia's solution, but you should go myFoo <- Foo <*> ...
10:28:55 <lyxia> monoidal: what do you mean
10:29:12 <orion> Wow, I just found this: http://hackage.haskell.org/package/envy
10:29:28 <orion> It pretty much solves my problem and provides other cool features.
10:29:41 <monoidal> I mean the plain (Foo <*> ...) works by constructing a (IO Foo) so remember to "unbox" it
10:29:55 <monoidal> you probably already know it but just in case ;)
10:30:44 <orion> Thanks for the suggestions.
10:34:28 <lyxia> orion: this package looks very cool
10:34:41 <orion> I never heard of it until today.
10:56:00 <karshan> is there a way to map over a list of lenses ?
10:56:28 <karshan> > let ls = [_1] in map (\l -> view l (1,"hello")) ls
10:56:31 <lambdabot>  [1]
10:57:11 <karshan> > let ls = [_1] in map (\l -> (view l (1,"hello"), set l 2 (1, "hello"))) ls
10:57:14 <lambdabot>  error:
10:57:14 <lambdabot>      • Couldn't match type ‘Const a (a, [Char])’ with ‘Identity b’
10:57:14 <lambdabot>        Expected type: ASetter (a, [Char]) b a Integer
10:59:43 <karshan> for some reason putting the lens inside a list fixes its Functor. http://lpaste.net/358553
11:01:02 <cocreature> karshan: yep, you can’t unify the a in [a] with "forall f. (a -> f b) -> s -> f t". that’s called impredicative polymorphism and is not supported by GHC (there is an extension for it but it’s completely broken)
11:01:04 <Gurkenglas> Types of form "[forall x. <something using x>]" need the ImpredicativeTypes extension, which doesn't work. Use ALens to fix the lens to the functor which encodes enough information for cloneLens to make a general lens again
11:17:52 <dan_> Hi, I'm trying to use the hybrid-vectors package, but I'm running into a GHC panic caused by (bad?) rewrite rules.  Any help would be much appreciated.
11:18:52 <user____3> hi Chan
11:19:16 <shapr> salut
11:19:34 <user____3> incoming error link
11:19:54 <shapr> dan_: this one? https://ghc.haskell.org/trac/ghc/ticket/13874
11:20:37 <dan_> shapr, oh wow! yeah, that looks right
11:21:10 <dmj`> where can I find an Arbitrary instance for Value
11:21:18 <jle`> karshan: you can deranknify the lens
11:21:19 <shapr> dan_: looks like the easy fix is to upgrade to ghc 8.2.1
11:21:36 <user____3> i have an error that is confounding me and what i know so far of haskell: 
11:21:40 <jle`> karshan: you can use 'ALens'
11:21:48 <shapr> dmj`: which Value?
11:22:08 <dmj`> shapr: aeson’s Value
11:22:16 <user____3> http://lpaste.net/358562 can someone explain to me why the return type of my function isn't what i set the type signature to be please?
11:22:18 <dan_> shapr: Sounds like a plan.  Thanks so much for your help!
11:22:26 <jle`> karshan: you just need to use clonseLens :: ALens s t a b -> Lens s t a b
11:22:50 <cocreature> jle`: you’re too late, Gurkenglas already said that :)
11:23:00 <jonge> hey there. if "f a == f b" holds, i can assume that "a == b" holds if f follows certain rules. what are these? just bijectivity or something else/more?
11:23:07 <jle`> > let ls = [_1] in map (\l -> (view (cloneLens l) (1, "hello"), set (clonseLens l) 2 (1, "hello"))) ls
11:23:09 <lambdabot>  error:
11:23:09 <lambdabot>      • Variable not in scope:
11:23:09 <lambdabot>          clonseLens
11:23:15 <jle`> > let ls = [_1] in map (\l -> (view (cloneLens l) (1, "hello"), set (cloneLens l) 2 (1, "hello"))) ls
11:23:17 <jle`> aw i'm too late
11:23:18 <lambdabot>  [(1,(2,"hello"))]
11:23:34 <Tuplanolla> Injectivity suffices, jonge.
11:23:39 <cocreature> jonge: f x == f y -> x == y is called injectivity
11:23:56 <jonge> Tuplanolla, cocreature thank you
11:24:38 <jonge> Tuplanolla, cocreature is there something in the compiler that can see if functions are injective and optimizes such stuff away perhaps?
11:24:41 <jle`> Ero: that's a weird error message
11:24:49 <Ero> tell me about it :'(
11:24:53 <dolio> Also make sure you complain if any mathematician gives you a different definition of injectivity.
11:25:02 <jle`> Ero: because the thing in the error message doesn't show up in the code
11:25:06 <jle`> does GHC invent the term "truther" ?
11:25:13 <jle`> is that like hard-coded into ghc?
11:25:14 <Ero> oops
11:25:26 <Ero> i have lied to you guys hold on i'll past the correct version
11:25:31 <Ero> its very similar though
11:25:44 <Tuplanolla> Not that I know of, jonge.
11:26:12 <shapr> dmj`: All I can find is https://github.com/bos/aeson/blob/master/tests/Instances.hs
11:26:16 <shapr> and that doesn't have Value
11:26:40 <Tuplanolla> Aside from data constructors, that is.
11:27:00 <dmj`> shapr: yea, neither does `quickcheck-instances`
11:27:11 <jle`> jonge: i suppose that the newtype language feature is all about that
11:27:15 <shapr> oh, I did find something: http://hackage.haskell.org/package/json-autotype-1.0.2/src/Data/Aeson/AutoType/Test.hs
11:27:19 <Ero> please excuse me jle` : http://lpaste.net/358563
11:27:26 <jle`> newtype constructors are all injective, so ghc optimizes them 'away'?
11:28:25 <Ero> i rephrased my function in a desperate act to understand why the return is Bool and not a tuple 
11:28:27 <shapr> dmj`: does that help?
11:28:35 <jle`> Ero: hm i don't know what the error message is from exactly
11:28:40 <jle`> but your function seems to have the wrong number of arguments
11:28:43 <jonge> jle`: i well if you transform an instance of a type to the newtype version of this type, then this looks quite bijective to me.
11:29:07 <jle`> Ero: it looks to be something like 'a -> State s b', but the type you gave implies two arguments?
11:29:17 <jonge> jle`: that looks more like a help for the human that comes with no cost at compile time and run time, rather than an optimization
11:29:22 <jle`> jonge: indeed newtypes are indeed injective and bijective
11:29:56 <jle`> jonge: it's an optimization in the sense that 'f x' is replaced with just 'x'
11:30:05 <jle`> or well
11:30:16 <jle`> so that 'f x == g y' is really just 'x == y'
11:30:29 <jle`> so if ghc sees 'f x == g y', it will really only do 'x == y'
11:30:34 <jle`> which takes advantage of injectivity
11:30:35 <shapr> dmj`: and more - https://www.reddit.com/r/haskell/comments/6i1utt/quickcheck_randomly_generates_data_im_wondering/
11:31:21 <jle`> er actually you're right, that's not really taking advantage of injectivity
11:31:25 <jonge> jle`: yes, but i would seldomly compare values of one type with another which is of another type (although just newtyped)
11:32:03 <cocreature> jonge: do you have some actual goal here or are you just curious about the optimizations performed by ghc?
11:32:05 <jle`> i mean that (Identity x) == (Identity y), to GHC, would be, internally, x == y
11:32:06 <jonge> jle`: actually i regard newtype as a help of NOT mixing several things together by constructing "artificial" types
11:32:19 <jle`> i'm not talking about comparing things of different types, here
11:32:35 <jonge> cocreature: just curious. i have no goal right now. plz just ignore me if i consume your time and you need it for some other important task. :)
11:32:40 <jle`> i'm saying that ghc can see that if (Identity x) == (Identity y), then also x == y
11:33:01 <jle`> and also if x == y implies runIdentity (Identity x) == runIdentity (Identity y)
11:33:04 <jonge> jle`: yes, but that is the way you would naively implement it anyway.
11:33:21 <cocreature> jonge: oh no, I wasn’t trying to come off as dimsissive. I just wanted to know if there was some underlying problem that we might be able to help you with :)
11:33:46 <Ero> i must have been delusional when i wrote this last night. Sorry jle` thx for your time
11:33:49 <cocreature> afaik ghc doesn’t do any optimizations based on injectivity
11:34:40 <marchdown> hello
11:34:52 <iqubic> Hey marchdown.
11:34:57 <iqubic> How's life?
11:35:38 <dmj`> shapr: nice, jdreaver’s implementation looks good. Thanks.
11:35:59 <marchdown> Good, iqubic, and yours?
11:36:09 <Ero> jle`: i think i was halfway through constructing a useful function when i got stuck at the compiler infering a type i didnt intend. Can you see any reason why the function returns a Bool and not a (Bool, PrimeThing)?
11:36:21 <marchdown> What brings me here today is IHaskell kernel being obstinate about graphics
11:36:33 <marchdown> import IHaskell.Display fails on MacOS
11:36:59 <marchdown> I tried fiddling with rebuilding packages to no avail.
11:37:04 <marchdown> Anyone encountered that?
11:37:17 <iqubic> marchdown: school is a pain. I don't really want to learn about the US constitution right now, but my teacher is going to lecture for the next half hour.
11:37:25 <cocreature> marchdown: how does it fail?
11:38:12 <marchdown> simply `Could not find module ‘IHaskell.Display’` when run in GHCi; `Failed to load interface for ‘IHaskell.Display’` in Jupiter session.
11:38:45 <marchdown> seems like ihaskell-rlangqq  fails to build properly but it shouldn't be necessary in the first place
11:39:33 <marchdown> iqubic: I think US constitution is awesome and way ahead of its time, like, the founding fathers were real visionaries. If you find it boring... have you seen Hamilton the musical?
11:39:50 <cocreature> marchdown: how did you install ihaskell?
11:40:05 <iqubic> No. I really should though. But that's off topic for now marchdown.
11:40:44 <marchdown> pulled from GitHub, then stack build && stack install as per the instructions
11:41:21 <iqubic> marchdown: what errors did you get?
11:41:23 <cocreature> marchdown: how are you starting ghci?
11:42:27 <marchdown> cocreature: by typing `ghci` at the shell prompt. are there many different ways to start it? 
11:42:41 <cocreature> marchdown: if you install packages via stack, you’ll have to use "stack ghci"
11:43:16 <iqubic> stack ghci loads all the modules needed for your current project.
11:43:31 <marchdown> The errors I've mentioned above, they seem to indicate that there's no such package as IHaskell.Display (or no such symbol in the relevant namespace, I don't know how it's being resolved)
11:44:18 <cocreature> marchdown: also pay attention to the instructions: you need to use "stack exec" to start jupyter
11:45:48 <marchdown> cocreature: thanks. I think I used to do that before... before doing `ihaskell install --stack` which made ihaskell kernel appear in the Jupiter dropdown and I used it from there.
11:48:18 <iqubic> What is ihaskell?
11:48:43 <cocreature> iqubic: we’re back to you being too lazy to google things, please stop doing that :)
11:49:11 <iqubic> I will just google it now.
11:54:28 <marchdown> cocreature: I was missing a space in `stack exec jupyter -- notebook`. It seems to be working... better now. There are still some glitches.
11:55:02 <marchdown> Say, how do I hide synonyms. E.g. Diagrams.Prelude..= when I have just imported a module that defines its own (.=)?
11:56:18 <marchdown> Thank you for pointing me in the direction of stack. I seem to be confused about what it does and where it fits in between all the other pieces.
11:58:06 <c_wraith> stack manages the entire haskell ecosystem for projects that use it. compiler + set of packages available
11:58:53 <c_wraith> it's an easy way to control exactly what is used to build a project.
12:10:53 <jkoppel>     Running 1 benchmarks...
12:10:53 <jkoppel>     setup-Simple-Cabal-1.22.5.0-ghc-7.10.3: Error: Could not find benchmark
12:10:54 <jkoppel>     program
12:10:55 <jkoppel>     ".stack-work/dist/x86_64-osx/Cabal-1.22.5.0/build/mainbench/mainbench". Did
12:10:56 <jkoppel>     you build the package first?
12:11:11 <jkoppel> I'm having a fit trying to run benchmarks through stack
12:11:14 <jkoppel> Can anyone help me?
12:17:30 <codedmart> I feel like I forgot something again. Can't I write this cleaner: `maybe "" (fromMaybe "" . (recordId :: Maybe Text)) (d :: Maybe Record)`
12:18:50 <erisco> :t \f -> maybe "" (fromMaybe "" . f)
12:18:51 <cocreature> codedmart: are you sure that typechecks? I would expect recordId to have type "Record -> Maybe Text" and not just Maybe Text
12:18:52 <lambdabot> (a -> Maybe [Char]) -> Maybe a -> [Char]
12:19:41 <codedmart> cocreature: I am sorry `recordId :: Record -> Maybe Text`.
12:19:45 <codedmart> I typed it out wrong.
12:19:53 <erisco> :t maybe "" . fromMaybe ""
12:19:55 <lambdabot> error:
12:19:55 <lambdabot>     • Couldn't match type ‘[Char]’ with ‘a -> [Char]’
12:19:55 <lambdabot>       Expected type: Maybe [Char] -> a -> [Char]
12:19:59 <cocreature> codedmart: fromMaybe "" (recordId =<< d)
12:20:07 <erisco> :t maybe "" . (fromMaybe "" .)
12:20:08 <lambdabot> (a -> Maybe [Char]) -> Maybe a -> [Char]
12:20:29 <codedmart> Hmm I thought I tried that.
12:20:44 <codedmart> I guess I had a typo. Thanks!
12:21:23 <erisco> there is something familiar about this
12:23:08 * hackagebot userid 0.1.3 – The UserId type and useful instances for web development – https://hackage.haskell.org/package/userid
12:23:09 * hackagebot hmatrix-gsl-stats 0.4.1.7 – GSL Statistics interface – https://hackage.haskell.org/package/hmatrix-gsl-stats
12:24:43 <erisco> @djinn (((a1 -> b) -> a1 -> c) -> c1) -> (a -> b -> c) -> a -> c1
12:24:44 <lambdabot> f a b c = a (\ d e -> b c (d e))
12:28:38 <erisco> yeah…
12:29:11 <erisco> @let mdot f g = f . (.) . g
12:29:13 <lambdabot>  Defined.
12:29:18 <erisco> :t mdot mdot maybe "" fromMaybe ""
12:29:20 <lambdabot> (a1 -> Maybe [Char]) -> Maybe a1 -> [Char]
12:33:22 <royal_screwup21> Suppose I have a function that returns an integer. How do I make it so that it return *anything*, including say strings? I know I need to use "flexible constraints" but I'm not quite sure how
12:33:33 <royal_screwup21> can return **
12:34:11 <erisco> more generally  \f -> fmap (f . fmap)  or  fmap . (>>>) fmap
12:34:24 <erisco> @undefine
12:34:24 <lambdabot> Undefined.
12:34:43 <erisco> @let mdot f = fmap (f . fmap)
12:34:45 <lambdabot>  Defined.
12:34:48 <erisco> :t mdot
12:34:50 <lambdabot> (Functor f1, Functor f2) => ((f2 a -> f2 b1) -> b2) -> f1 (a -> b1) -> f1 b2
12:35:12 <erisco> :t mdot mdot
12:35:13 <lambdabot> (Functor f4, Functor f3, Functor f2) => f2 (f3 b2 -> b3) -> f2 (f4 (a -> b2) -> f4 (f3 a -> b3))
12:35:21 <erisco> :t mdot . mdot
12:35:22 <lambdabot> (Functor f2, Functor f1) => ((f2 a1 -> f2 b1) -> b2) -> f1 (a2 -> b1) -> f1 ((a1 -> a2) -> b2)
12:35:34 <erisco> a little toy…
12:36:21 <wz1000> To maintain state in a threaded environment, I have recently started using ReaderT MyStateIface IO, with data MyStateIFace = { readState :: IO State, updateState :: Event -> IO () }
12:37:03 <wz1000> where MyStateIface uses TVars/MVars/IORefs to manage the state under the hood.
12:37:27 <wz1000> Are there any better approaches?
12:39:59 <royal_screwup21> Suppose I have a function that returns an integer. I want it to return a string for an edge case. How do I do this? I know I need to use "flexible constraints" but I'm not quite sure how
12:40:45 <geekosaur> you don't do it that way, you use a type Either String Int
12:41:02 <hexagoxel> wz1000: don't you want at least an atomic modify as well?
12:42:06 <wz1000> hexagoxel: yes, MyStateIface contains whatever I need to interact with the state
12:45:33 <erisco> :t mdot mdot either id fromMaybe ""
12:45:34 <lambdabot> (b -> Maybe [Char]) -> Either [Char] b -> [Char]
12:45:42 <erisco> I don't quite know what mdot is yet
12:45:56 <shapr> :t mdot
12:45:57 <lambdabot> (Functor f1, Functor f2) => ((f2 a -> f2 b1) -> b2) -> f1 (a -> b1) -> f1 b2
12:48:29 <dsal> I thought I saw something recently that was     f1 f . f2 f
12:48:33 <dsal> Is that a thing?
12:49:39 <erisco> the polymorphism of mdot lets it type check in a lot of situations
12:57:57 <hexagoxel> erisco: the way you use it there, the first fmap is (.)
12:59:20 <erisco> :t (mdot . mdot) id id
12:59:22 <lambdabot> Functor f2 => (a1 -> b1) -> (a2 -> a1) -> f2 a2 -> f2 b1
12:59:28 <erisco> :t (mdot . mdot . mdot) id id
12:59:29 <lambdabot> Functor f2 => (a1 -> b1) -> (a2 -> a1) -> (a3 -> a2) -> f2 a3 -> f2 b1
12:59:35 <erisco> :t (mdot . mdot . mdot . mdot) id id
12:59:36 <lambdabot> Functor f2 => (a1 -> b1) -> (a2 -> a1) -> (a3 -> a2) -> (a4 -> a3) -> f2 a4 -> f2 b1
13:00:32 <hexagoxel> :t pdot
13:00:33 <lambdabot> Functor f => ((f a1 -> f b) -> c) -> (a2 -> a1 -> b) -> a2 -> c
13:00:47 <hexagoxel> :t (pdot . pdot . pdot . pdot) id id
13:00:48 <lambdabot> Functor f => (a2 -> b) -> (a3 -> a2) -> (a4 -> a3) -> (a5 -> a4) -> f a5 -> f b
13:06:14 <erisco> haha here is a fun type
13:06:28 <erisco> @djinn (a1 -> b) -> ((a -> a1) -> a) -> (a -> a1) -> b
13:06:28 <lambdabot> f a b c = a (c (b c))
13:09:50 <Ero> Hi all. Can anyone explain to me why my functions is returining Bool and not matching my given type signature? Thanks http://lpaste.net/358563
13:14:58 <ahihi> Ero: what is S.state?
13:15:01 <geekosaur> you haven't provided enough information
13:15:26 <hexagoxel> Ero: With your usage of `state`, what do you expect `m` to be?
13:15:58 * hexagoxel is assuming MonadState.state ..
13:16:59 <centril> Given that reordering type parameters becomes a breaking change, is using TypeApplications bad style?
13:17:42 <Ero> ahihi: import qualified Control.Monad.State as S
13:18:46 <Ero> hexagoxel: I think m in my fnuction should be State PrimeThing
13:19:26 <Ero> i have never used a monad before and am going by what i learnt from 'learn you a haskell' . It could be that i need to re-read the chapter
13:19:34 <hexagoxel> Ero: but you function does not return any `State s a`
13:20:14 <Ero> hexagoxel: do you mean my function body or my type signature/both?
13:20:25 <erisco> a (b a)  is actually a metaphor for mentoring…
13:20:44 <hexagoxel> the type signature
13:21:00 <erisco> student (mentor student)
13:21:01 <Ero> i'll play around with it some more. Thanks hexagoxel 
13:22:02 <erisco> the mentor considers the student and determines what they need
13:22:03 <hexagoxel> Ero: you might want to add a pattern binding for the PrimeThing argument.
13:23:22 <geekosaur> Ero, quite possibly rereading won't help. LYAH tends to do this to people :(
13:23:28 <geekosaur> @where cis194
13:23:28 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
13:24:06 <Ero> geekosaur: any recommended re-education reading?
13:25:09 <geekosaur> if you need a book, I recommend Graham Hutton's (preferably 2nd edition as it is up to date with recent ghc). I just had the bot link to an online course that will do a better job of teaching you Haskell than LYAH does
13:25:49 <geekosaur> LYAH is a great '30 ports in 14 days' sightseeing cruise. it's not very good for actually learning anything
13:26:16 <Ero> hopefully thats note necessary. I got it to compile :)
13:28:09 <Ero> i changed my type signature to something :: Prime -> S.State PrimeThing Bool(I had forgotten that the State constructor takes the state parameter away from the function that is wrapping the state function)
13:29:03 <[exa]> hint: when in doubt, use type holes
13:29:05 <Ero> thx for the recommendation geekosaur, i have been longing for a book which is current and whoes library usage i could trust
13:33:12 <Ero> geekosaur: an online course is interesting. Do i have to wait till spring to signup?
13:33:39 <geekosaur> no, that's the course notes from the Spring 2013 course, fleshed out into a full online course
13:33:43 <geekosaur> take it at your own speed etc.
13:34:02 <iqubic> Is it free?
13:34:05 <geekosaur> yep
13:34:41 <erisco> what's your time worth?
13:35:25 <Ero> thanks again geekosaur 
13:36:26 <royal_screwup21> I'm trying to check if a given string is a palindrome https://thepasteb.in/p/oYhl3wL0ZM6fZ but I keep hitting this error: parse error on input ‘=’. Where am I going wrong?
13:36:55 <erisco> lots of palindromes lately
13:37:20 <geekosaur> you have '|head string==' on line 4, I suspect you meant =
13:37:25 <geekosaur> er, no
13:37:30 <geekosaur> you are missing the =
13:37:37 <erisco> string=pal
13:37:44 <geekosaur> no, sigh, I am misreading it because of all the squashed ops
13:37:53 <erisco> try adding some whitespace around operators and we'll go from there
13:38:08 <erisco> MTBF on your spacebar is pretty high… I wouldn't worry about it
13:38:13 <geekosaur> oh, indentation on line 7
13:38:26 <geekosaur> you have one space too many and its being read as a continuation of line 6
13:38:36 <zachk>  > let isPalidrome string = string == reverse string in isPalidrome "racecar"
13:38:52 <geekosaur> *it's
13:38:56 <zachk> > let isPalidrome string = string == reverse string in isPalidrome "racecar"
13:38:58 <lambdabot>  True
13:38:59 <geekosaur> apparently I'm typing as well as I read today :/
13:39:01 <royal_screwup21> ahhh
13:39:04 <royal_screwup21> thanks so much guys!
13:39:15 <erisco> why solve it for them, zachk
13:39:21 <zachk> :( 
13:39:29 <erisco> if you're doing to do that you need to do it in a uselessly cryptic way
13:39:34 <zachk> because it is so simple with reverse
13:39:38 <isBEKaml> royal_screwup21: you only messed up a palindrome. You can relax, there are folks who have it much worse :-)
13:39:50 <erisco> > ((==) <*> reverse) "racecar"
13:39:52 <lambdabot>  True
13:40:34 <zachk> oh wow
13:40:59 <isBEKaml> yeah, leave it to #haskell folks to do some golfing on a trivial problem :P
13:41:22 <Rembane> Fin!
13:41:26 <Rembane> *Fun!
13:45:44 <hexagoxel> can i runST at the bottom of a transformer stack without the type variable escaping?
13:46:30 <hexagoxel> :t mapStateT (\m -> Identity (runST m))
13:46:31 <lambdabot> error:
13:46:32 <lambdabot>     • Couldn't match type ‘m’ with ‘ST s1’
13:46:32 <lambdabot>         because type variable ‘s1’ would escape its scope
13:47:40 <jle`> Ero: it might be because of some greedy parsing with if
13:49:39 <iqubic> erisco: how does hat palindrome function with fmap work?
13:49:59 <erisco> fmap? I don't see no stinkin' fmap!
13:50:07 <isBEKaml> fmap? That's applicative
13:50:32 <iqubic> :t ((==) <*> reverse)
13:50:34 <lambdabot> Eq a => [a] -> Bool
13:50:41 <iqubic> How does that work?
13:50:43 <isBEKaml> :t (<*>)
13:50:45 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:50:54 <erisco> iqubic, do you know SK combinators perchance?
13:51:19 <lavalike> f = ([t] ->), a = [t], b = Bool
13:51:49 <iqubic> erisco: I do know S K combinatory.
13:51:58 <iqubic> How does that help here?
13:52:02 <erisco> iqubic, then know S = <*>
13:52:11 <iqubic> Does it?
13:52:18 <erisco> no, I am lying
13:53:04 <iqubic> \f g x -> f x (g x)
13:53:31 <lavalike> f = (==), g = reverse
13:54:00 <erisco> (<*>) (==) reverse  -- maybe this makes it more obvious
13:54:12 <iqubic> Yeah, I guess.
13:54:33 <iqubic> I don't get how <*> is S
13:54:43 <lavalike> you use f = (t ->)
13:55:11 <erisco> you do that and then get zero choices on how to implement it
13:55:23 <iqubic> Right, that makes sense.
13:55:25 <lavalike> 1 choice
13:56:05 <hydraz> Succ Zero choices on how to implement it
13:56:26 <iqubic> I still don't get it. S has three parameters. <*> has 2
13:56:43 <lavalike> parameters are in the eye of the beholder
13:56:49 <erisco> this language is too imprecise and misused to care
13:57:35 <lavalike> iqubic: for all you know f could be t0 -> t1 -> t2 -> ... how many parameters does it have then
13:57:38 <erisco> iqubic, step 1) set f to (t ->), step 2) count the parameters
13:57:48 <lavalike> !quote stereo
13:57:54 <lavalike> :/
13:58:05 <hydraz> let me try something, and fail horridly at it
13:58:10 <hydraz> :t (<*>) @ ((->) _)
13:58:12 <lambdabot> error: parse error on input ‘->’
13:58:17 <hydraz> I was expecting that.
13:58:36 <hydraz> (<*>) @ ((->) _) :: (w -> a -> b) -> (w -> a) -> w -> b
13:58:46 <hydraz> iqubic: ^
13:59:25 <ocharles> orion: 
13:59:27 <erisco> :t asAppliedTo
13:59:28 <lambdabot> (a -> b) -> a -> a -> b
13:59:29 <ocharles> i am around now, what' sup?
13:59:34 <ocharles> jesus. keyboard fail
13:59:38 <erisco> :t (<*>) `asAppliedTo` (==)
13:59:39 <lambdabot> Eq a => (a -> a -> Bool) -> (a -> a) -> a -> Bool
13:59:50 <hydraz> cute
14:00:53 <erisco> ocharles, function Application is what' sup
14:01:00 <ocharles> dayam straight
14:01:07 <erisco> Applicative… my fails have to do with suffixes
14:01:14 <hydraz> :D:
14:23:33 * hackagebot pusher-http-haskell 1.5.0.0 – Haskell client library for the Pusher HTTP API – https://hackage.haskell.org/package/pusher-http-haskell
14:23:33 * hackagebot checkmate 0.1.1 – Generate checklists relevant to a given patch – https://hackage.haskell.org/package/checkmate
14:58:19 <jcondor> Hi there! I'm pretty new to Haskell (I've been studying it for about 1 month), I actually run Arch Linux and I wanted to try xmonad. Do you know any interesting tutorial or link on how to configure xmonad **from scratch**?
14:59:20 <jcondor> Of course, also for future use, when I will be more skilled with the language
15:00:00 <vktec> Arch wiki has a good guide to get you started
15:00:06 <vktec> iirc that's what I started with
15:00:13 <vktec> You might be better off asking #xmonad though
15:00:36 <jcondor> Thank you very much for answering
15:00:51 <Denommus> so
15:01:02 <Denommus> what's the current "modern" solution for Haskell web development?
15:02:28 <jcondor> Do you mean web frameworks for websites?
15:03:21 <jcondor> I remember that I was reading something about that on the Haskell wiki, but it was somehow.. generic, you know
15:03:50 <orzo> is it possible to, at runtime, output the stack trace of a thread in BlockedOn* state?
15:04:08 <erisco> jcondor, you will be more skilled every time you learn something true and unlearn something false
15:04:44 <jcondor> erisco: good advice
15:05:24 <jcondor> I'm just a newbie to Haskell
15:05:54 <maerwald> web frameworks are annoying
15:07:09 <orzo> I want something like GHC.Conc.threadStatus that can give me a call stack for the thread
15:07:14 <erisco> I think we have to take a time machine back to 2005 to have discussions on the justification for web frameworks
15:07:52 <maerwald> not really. in Go, where web development is a language focus, web frameworks are considered rather nonsensical
15:08:03 <maerwald> and it's rather clear why that is
15:08:20 <Denommus> I don't expect anything like yesod, btw
15:08:20 <orzo> your off-topic discussionis scrolling my haskell question away
15:08:29 <maerwald> then again, I don't consider Snap a web framework
15:08:39 <Denommus> I want something more akin to servant, but maybe continuation-based
15:08:56 <maerwald> orzo: we are not offtopic.
15:08:56 <hexagoxel> data STWrap m a = STWrap (forall s . Monad (m s) => m s a)
15:09:07 <hexagoxel> will this thing get me anywhere?
15:09:11 <thekyriarchy> no minimal installers for linux i suppose: https://twitter.com/thekyriarchy/status/910263606264123392
15:09:15 <erisco> maerwald, a bulk of the discussion was in confusion of what "web framework" entails
15:09:16 <Denommus> orzo: why is my doubt off-topic? I'm explicitly asking about Haskell
15:09:20 <maerwald> Denommus: did you have a look at Snap?
15:09:39 <hexagoxel> orzo: you gotta rephrase your question slightly or pretend to have made some progress and ask again. like i did there.
15:09:54 <maerwald> you _could_ consider it a web framework, but it really leaves anything open on how to use it, so to me it's more like a few building blocks, not a web framework like angular stuff etc
15:10:05 <erisco> which is just about nothing… it is a build-a-bear workshop
15:10:49 <Denommus> maerwald: isn't snap more or less like servant?
15:10:52 <maerwald> but then again, the trend in haskell is for DSLs and frameworks, less for libraries
15:11:03 <lavalike> orzo: does this work http://hackage.haskell.org/package/base-4.10.0.0/docs/GHC-Stack.html#v:currentCallStack
15:11:26 <Rembane> orzo: Can you crash your application on BlockedOn? :) 
15:11:29 <Rembane> orzo: https://ghc.haskell.org/trac/ghc/wiki/ExplicitCallStack <- some pointers
15:11:34 <maerwald> Denommus: mh, maybe a bit more "heavy", I don't know how to describe it
15:12:03 <Denommus> maerwald: maybe like F#'s Suave.IO?
15:12:17 <Denommus> maerwald: have you ever seen OCaml's Ocsigen?
15:12:48 <maerwald> no, never done F# or OCaml
15:13:11 <maerwald> Snap exposes a lot of IO
15:13:24 <maerwald> so it's kinda low-level in a sense
15:13:57 <maerwald> but not in the sense that you have to handle the IO details
15:14:29 <maerwald> yesod is probably the opposite
15:14:43 <orzo> i have my own wrapper instrumentation on every forked thread, so I could trigger an exception in any thread and get the call stack, but then then I'm not sure how i would resume unless i can actually use the callstack info as a continuation
15:14:52 <erisco> the worthwhile results were 1) abstract inputs from protocol, 2) abstract outputs from protocol
15:15:03 <orzo> thanks guys btw
15:15:12 <orzo> that is useful stuff you pointed me too
15:15:31 <lavalike> orzo: what are you working on?
15:15:42 <orzo> a p2p application
15:15:45 <orzo> kademlia based
15:15:53 <orzo> but it runs as a server
15:16:05 <orzo> and has a commandline interface that lets me dump memory and thread info
15:16:10 <erisco> if you can write a CLI frontend for your web app (a custom presentation, not telnet) then you did it right
15:17:40 <orzo> currentCallStack doesn't quite work because it does not accept a threadId argument
15:18:34 <Denommus> this looks promising: https://github.com/transient-haskell/transient
15:18:40 <orzo> i could do it by writing wrappers on everything that blocks
15:18:44 <orzo> heh
15:18:48 <orzo> i don't want to do that
15:21:14 <lavalike> orzo: I wonder if you can get something out of this https://ghc.haskell.org/trac/ghc/ticket/12096
15:23:43 * hackagebot checkmate 0.1.2 – Generate checklists relevant to a given patch – https://hackage.haskell.org/package/checkmate
15:25:04 <orzo> lavalike: even with that, i don't see how i could query the callstack for some other thread given a threadid
15:25:29 <lavalike> can you run some code in a thread given its threadid?
15:26:00 <orzo> sort-of, you can throw-to
15:26:16 <orzo> Control.Concurrent.throwTo
15:26:26 <orzo> so you can throw an exception in the thread
15:26:56 <lavalike> would a catch at the root of the thread code show the right call stack info then
15:27:37 <orzo> even if it did, it's no good fo rme
15:27:40 <lavalike> :/
15:27:44 <orzo> i don't want the thread to die or change its behavior
15:27:57 <orzo> i just want the callstack for where it's weighting
15:27:59 <orzo> waiting
15:28:08 <orzo> the stack to the mvar or whatever
15:28:45 <lavalike> does profiling help you with this
15:28:58 <orzo> i dont know
15:29:16 <lavalike> what are you trying to do with the call stack?
15:29:19 <orzo> i mean, eventlog maybe
15:29:31 <orzo> eventlog might have it
15:33:28 <orzo> hm, eventlog would probably show me when a thread transitions to blocking, time-wise, but not give me a stacktrace
15:33:56 <lavalike> I was looking at this but I don't see it showing stack traces https://wiki.haskell.org/ThreadScope
15:34:04 <lavalike> it does use the event log for its data though
15:35:09 <orzo> you cannot use -eventlog and profiling at the same time that i'm aware
15:35:25 <orzo> which is odd
15:37:18 <orion> ocharles: 
15:37:23 <orzo> maybe i should make a feature request for GHC.Conc to include a getCallStack :: ThreadId -> CallStack
15:37:48 <orzo> forgot the IO on that type, but it's meant
15:39:51 <orzo> actually, it'd probably be best to give ThreadStatus and CallStack combined atomically
15:40:10 <orzo> if that's convenient for ghc
15:58:04 <ucenna> Hey! I had a question regarding functional programming. I'm actually using javascript, but I was curious about the theoretical implications of memory, so I thought here would be a better place to ask my question: If I needed to keep a history of something, such as a series of user actions. How would I do that? Or rather how would I do that without violating immutability? Is there a concept that I'm missing, or is this 
15:58:04 <ucenna> considered a seperate case?
15:59:12 <zachk> ucenna, use a list to store the series of all user actions
15:59:29 <zachk> ucenna, if its javascript have you looked at bacon.js for functional stuff?
15:59:34 <orzo> well, one way to do it would be to use a tail-recursive function whose argument is the current history
16:01:09 <ucenna> No I haven't looked at that yet, thank you.
16:01:21 <ucenna> I've been trying to learn the functional paradigm
16:01:56 <ucenna> Oh!!
16:02:22 <ucenna> I just remembered, immutable data structures.
16:02:38 <ucenna> I don't know how to work with them, does anyone have any suggested reading?
16:06:38 <ucenna> I have to go, but thank you for all your help!
16:11:35 <zachk> ucenna, with immutable data structures in a language that doesn't support them out of the box, you never mutate a value and always return a new version of the data structure from functions that "modify" it
16:12:43 <pacak> You can still use immutable structures in javascript, it's just harder since it's (unlike in superiour languages) enforced and can explode in your face when you forget something.
16:13:05 <hpc> *unenforced
16:14:03 <pacak> Right.
16:14:15 * pacak is still waking up
16:15:06 <Hafydd> You can enforce immutability of properties in JS using property descriptors.
16:15:34 <hpc> pacak: i am falling asleep so it averages out
16:15:56 <Hafydd> But it doesn't work properly in Internet Explorer, I think.
16:16:56 <Hafydd> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty
16:18:04 <Hafydd> Oh, and there's also Object.freeze().
16:18:40 <Hafydd> But it is still more possible to make a mistake and leave something mutable, yes.
16:19:54 <wadadli> why can't we just write haskell in the browser instead
16:20:44 <erisco> wadadli, that ship has sailed
16:21:09 <wadadli> darn!
16:21:39 <Hafydd> What do you mean?! You make it sound like the opportunity to write Haskell in the browser has passed.
16:23:31 <mlehmk> What about Elm?
16:23:41 <zachk> wasn't there ghcjs ?
16:23:59 <erisco> I am talking about a different sense of "write Haskell in the browser"
16:24:00 <Arahael> there is also haskell, purescript, and reasonml
16:35:00 <orzo> ls
16:35:13 <geekosaur> .: No such file or directory
16:35:47 <orzo> doh!
16:38:56 <wedify> is anyone able to guess what i can do here? http://lpaste.net/358570. I have two types that are apparently the same but ghc says they are different
16:40:41 <lyxia> wedify: is that the whole error message
16:41:11 <erisco> I have seen such errors… problem is I cannot remember the circumstances
16:41:33 <erisco> but I am pretty sure it was some rank-n business
16:42:48 <wedify> lyxia: oops. the rest says that ShapeT may not be an injective function. the type variable a0 is ambiguous 
16:43:06 <erisco> some type family business
16:43:18 <lyxia> ShapeT is a type family and ShapeT 'D is not defined
16:44:50 <lyxia> where is newMat defined
16:45:59 <orzo> wh is it talking about ShapeT 'D when it seems only ShapeT (Proxy 'D) occurs
16:46:25 <wedify> OpenCV.Internal.Core.Types.Mat
16:46:30 <lyxia> ShapeT (Proxy a) = ShapeT a
16:46:38 <lyxia> so it reduces and then gets stuck
16:50:57 <orzo> https://hackage.haskell.org/package/opencv-0.0.1.1/docs/src/OpenCV-Internal-Core-Types-Mat.html#ShapeT
16:51:50 <lyxia> wedify: so you want the size to be dynamic?
16:53:37 <wedify> lyxia: yeah. as far as i can tell the stich function from opencv will return an array that is as big as it needs to be. at least i can't see any size specifications in the example code i've been looking at
16:54:56 <lyxia> wedify: use the type   ShapeT (Proxy [Int32])
17:12:29 <wedify> lyxia: the example types now. now to see if it actually works. thanks a bunch
17:59:18 <robertkennedy> So now I have some parser that require MonadFail - the archetypical example, `parse x = A <$> parse x <*> parse x`, where each parse might `fail`. But if I later just want to access the second field of A, `parse` must first make sure the first field doesn't fail. When parsing some GBs of data, I'd prefer to lazy that `parse` out. What is the correct abstraction for this?
18:01:01 <robertkennedy> I profiled, and parsing the `A` - in this case documents from mongo - is indeed the roadblock, at least in memory. 
18:03:10 <lyxia> what format are you parsing?
18:04:41 <syamaoka> 1
18:05:01 <robertkennedy> In this case, it's documents from mongoDB. The individual parses are all like `lookup :: Monad m => FieldName -> Document -> m B`
18:05:36 <robertkennedy> Indeed, `Vector`'s bind operation takes a huge amount of the time 
18:06:07 <lyxia> Uh, so "parsing" in your case happens in just about any Monad?
18:06:11 <robertkennedy> ( `type Document = Vector (FieldName,MongoValue)` )
18:06:47 <dumptruckman> mapProd' :: [[Int]] -> [Int];  mapProd' = map (foldr (*) 1) -- returns a list of the product of each sublist
18:07:03 <dumptruckman> giving me an error that i don't understand
18:07:15 <robertkennedy> Yeah, `class FromDocument a where fromDocument :: (Monad m, Alternative m) => Document -> m a`
18:07:23 <dumptruckman> https://ghostbin.com/paste/qzkzs
18:07:45 <aavogt> is djinn ever able to write illegal (=<<) etc?
18:08:53 <robertkennedy> > let mapProd = map (foldr (*) 1) in mapProd $ map (\n -> [1..n]) [..5]
18:08:56 <lambdabot>  <hint>:1:66: error: parse error on input ‘..’
18:09:01 <dumptruckman> and now it's working fine..
18:09:09 <geekosaur> dumptruckman, that error does not go with what you pasted
18:09:12 <robertkennedy> Gosh I suck, missed that one
18:09:25 <dumptruckman> geekosaur, i think the problem was the atom terminal i was using
18:09:33 <dumptruckman> it does really funky stuff
18:09:34 <dumptruckman> i forgot..
18:09:41 <dumptruckman> works fine in a normal terminal
18:09:44 <lyxia> robertkennedy: If you want the fields to be lazy you will have to run the parser for each field independently. Maybe pick m = Maybe and then    A (fromJust (fromDocument doc)) (fromJust (fromDocument doc))
18:10:43 <aavogt> one more condition I suppose: the inferred type must be the same (not more general)
18:12:39 <robertkennedy> lyxia: my hope was to be able to reuse the parsers for each field, without needing each field to actually have a `FromDocument` instance. But yeah, just giving the fields FromDocument instances will work in this case. Just a question on if this is a problem that's been generally solved
18:15:08 <lyxia> robertkennedy: How else could the compiler know how to parse fields?
18:15:18 <lyxia> robertkennedy: and that is a separate issue from laziness, isn't it?
18:16:30 <lyxia> aavogt: djinn doesn't know anything about monad laws.
18:16:57 <aavogt> it does not yet it seems to obey them
18:22:55 <aavogt> another perspective: djinn writes instances that break laws means the laws are wrong
18:23:15 <kadoban> Pretty sure that doesn't make any sense
18:23:54 <lyxia> aavogt: why
18:24:25 <aavogt> because I haven't seen any counterexamples
18:25:25 * hackagebot fltkhs 0.5.4.1 – FLTK bindings – https://hackage.haskell.org/package/fltkhs
18:25:40 <aavogt> and it can be trivially true if you read the conjecture as a definition for "correct laws"
18:30:34 <dumptruckman> how come this doesn't work? dotProd = sum . zipWith (*)
18:30:56 <aavogt> @unpl dotProd = sum . zipWith (*)
18:30:56 <lambdabot> dotProd x = sum (zipWith (*) x);
18:31:36 <dumptruckman> composition can't take multiple args?
18:31:51 <lyxia> dumptruckman: zipWith takes a list and produces a function
18:31:54 <Axman6> look at the typo of (.)
18:31:58 <Axman6> :t (.)
18:32:00 <lambdabot> (b -> c) -> (a -> b) -> a -> c
18:32:02 <lyxia> I mean, zipWith (*)
18:32:06 <Axman6> type*
18:32:30 <lyxia> dumptruckman: then you give that function to sum, which doesn't know what to do with it.
18:32:35 <Axman6> @pl dotProd xs ys = sum (zipWith (*) xs ys))
18:32:35 <lambdabot> (line 1, column 40):
18:32:35 <lambdabot> unexpected ')'
18:32:35 <lambdabot> expecting variable, "(", operator or end of input
18:32:39 <Axman6> @pl dotProd xs ys = sum (zipWith (*) xs ys)
18:32:39 <lambdabot> dotProd = (sum .) . zipWith (*)
18:32:39 <dumptruckman> wat
18:32:46 <dumptruckman> it produces a function?
18:33:03 <lyxia> :t zipWith (*)
18:33:04 <lambdabot> Num c => [c] -> [c] -> [c]
18:33:14 <lyxia> dumptruckman: takes a [c], outputs a [c] -> [c]
18:33:41 <dumptruckman> doesn't it take [c] -> [c] and outputs a [c]?
18:33:54 <Axman6> [c] -> [c] -> [c] === [c] -> ([c] -> [c])
18:34:06 <Welkin> [c] -> ([c] -> [c])
18:34:07 <Welkin> lol
18:34:10 <Welkin> beat me to it
18:34:20 <Welkin> all haskell functions are functions of one parameter
18:34:35 <Welkin> they potentially produce another function of one parameter
18:34:36 <dumptruckman> ah
18:34:37 <Welkin> and so on
18:35:02 <dumptruckman> i don't understand the syntax of (sum .) . zipWith (*)
18:35:12 <Welkin> that's expected
18:35:15 <Welkin> it's not easy to parse
18:35:22 <Welkin> it could be written more simply
18:35:26 <dumptruckman> oh wait
18:35:31 <dumptruckman> actually i think i get it
18:35:41 <Axman6> remember, _all_ functions take exactly one argument
18:35:41 <Welkin> :t sum (.).(.) zipWith (*)
18:35:43 <lambdabot> (Num (([b -> c1] -> [b] -> [c1]) -> [b -> c1] -> c2), Num (b -> c1), Foldable ((->) (([b] -> [c1]) -> c2))) => (b -> c1) -> [b -> c1] -> c2
18:35:49 <Welkin> oh lol
18:35:51 <dumptruckman> you're composing sum . to the function that zipWith (*) returns
18:35:55 <Welkin> yes
18:36:38 <Welkin> because `sum` takes two parameters
18:36:46 <Welkin> :t (.).(.)
18:36:48 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
18:38:31 <Welkin> takes two parameters before it is fully applied
18:40:04 <robkennedy> lyxia: well, using `parse` for individual fields is specific to the case `data A = A B C`. Generally you could imagine `data A = A Int Int`, with `instance Parsable A where parse x = A <$> f x <*> g x`
18:40:14 <marvin2> you mean zipWith (*) takes two parameters
18:40:40 <Welkin> marvin2: yes, my mistake
18:42:53 <robkennedy> lyxia: and it seems similar to laziness: I'm requesting an abstraction where `snd (A (div 1 0) 1) == 1`, except more like `snd (A <$> safeDiv 1 0 <*> safeDiv 1 1) == Just 1`
18:43:14 <Welkin> :t safeDiv
18:43:15 <lambdabot> error: Variable not in scope: safeDiv
18:43:17 <Welkin> ?
18:43:36 <Welkin> does throw an exception on division by zero?
18:43:41 <Welkin> produces a Maybe?
18:43:44 <Welkin> doesn't*
18:44:05 <Welkin> isn't there an Infinity?
18:44:10 <Welkin> > 1/0
18:44:11 <robkennedy> let safeDiv x 0 = fail "div by 0"; safeDiv x y = return ( x / y)`
18:44:12 <lambdabot>  Infinity
18:44:15 <Welkin> yeah
18:44:24 <Welkin> only for non-integral values though right?
18:44:30 <Welkin> > 1 `div` 0
18:44:33 <lambdabot>  *Exception: divide by zero
18:44:46 <monochrom> Only for Double and Float which on GHC enjoy IEEE754 infinities.
18:44:47 <Welkin> what...
18:44:50 <pacak1> How about negative zero?
18:44:54 <Welkin> how is that safe?
18:44:58 <lyxia> robkennedy: since your parsers work with pretty much any monad, you can pick Identity or some isomorphic monad with a dummy Alternative instance and it'll probably do what you want
18:45:05 <Welkin> it has the same behavior as `div`
18:45:35 <robkennedy> Welkin: trying to use a universally understood function with a MonadFail requirement, sorry
18:45:47 <monochrom> Also safeDiv is better off using Alternative than Monad.
18:46:12 <robkennedy> lyxia: pretend we are post MFP and parse requires MonadFail, so Identity wouldn't work
18:46:34 <robkennedy> monochrom: suee
18:46:36 <lyxia> robkennedy: it would if you write a dummy instance
18:46:38 <robkennedy> Sure
18:46:38 <Welkin> what was the MFP about?
18:47:00 <Welkin> `fail` is removed from Monad?
18:47:03 <geekosaur> pacak, negative zero is an IEEE floating point thing, so not applicable to div
18:47:07 <monochrom> MFP is about taking "fail" out of Monad and restoring the MonadFail class for it.
18:47:08 <lyxia> robkennedy: you will give up safety with the kind of laziness you are looking for
18:47:21 <monochrom> And yes, restoring. Haskell used to have it in Haskell 1.x
18:48:31 <robkennedy> lyxia: really? I'd agree we might not have an abstraction we can think of in this IRC, but the idea I'm talking about doesn't seem unsound...
18:49:44 <lyxia> robkennedy: don't you want to get an A without having to wait for its fields to be parsed?
18:49:56 <lyxia> Then what happens if the fields are actually incorrect?
18:51:10 <robkennedy> lyxia: if my program doesn't depend on every field of A, id want it produce results
18:51:40 <geekosaur> this does not have potential security implications?
18:51:45 <geekosaur> or correctness implications?
18:52:41 <lyxia> robkennedy: still, what if the fields it does depend on fail to parse?
18:53:22 <robkennedy> Geekosaur: In the end tbh I don't especially care - which in the history of math v physics tends to side with physics
18:53:46 <robkennedy> lyxia: yes, those should produce the `Nothing` that I'll handle correctly 
18:55:14 <robkennedy> I'm not asking to give up all safety, just safety on the fields I don't care about/use (which sounds like laziness)
18:55:43 <lyxia> okay so you have fields that are Maybe, not just any B or C
19:11:07 <sullyj3> Hey, what's going on with the following?:
19:11:26 <sullyj3> :t liftM (+1) $ return 1
19:11:27 <lambdabot> (Num r, Monad m) => m r
19:11:34 <sullyj3> liftM (+1) $ return 1
19:11:41 <sullyj3> > liftM (+1) $ return 1
19:11:44 <lambdabot>  error:
19:11:44 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M542518867778...
19:11:44 <lambdabot>        prevents the constraint ‘(Show (m0 Integer))’ from being solved.
19:12:08 <sullyj3> hm on my machine that gives 2
19:13:35 <Welkin> liftM is fmap
19:13:55 <Welkin> also, what are you `return`ing into?
19:14:45 <geekosaur> ghci speculatively tries m as IO. lambdabot does not do IO
19:14:51 <Welkin> > fmap (+1) $ return 1 :: [Int]
19:14:53 <lambdabot>  [2]
19:24:23 * hackagebot checkmate 0.1.3 – Generate checklists relevant to a given patch – https://hackage.haskell.org/package/checkmate
19:31:56 <rotaerk> hmm I kind of wish ==> from DSum was a pattern
19:33:39 <lyxia> you can make one
19:38:42 <rotaerk> I guess the way ==> works it couldn't quite be one; I'll just make one like:  pattern t :=>| v = t :=> Identity v
19:42:09 <lyxia> Have you tried just matching   t :=> Identity v  first, then pattern matching on t alone?
19:42:54 <lyxia> rotaerk: I remember seeing lots of Stuff :=> Identity v and didn't think of factoring that earlier.
19:43:42 <rotaerk> not sure what you mean by matching that first, then matching on t
19:43:58 <rotaerk> but I'm making patterns to eliminate all the explicit Identity stuff
19:44:01 <lyxia> Or I guess I did do it in my solution but just didn't realize it as a separate step
19:44:40 <lyxia> Okay, nevermind.
19:47:15 <rotaerk> hmm doesn't seem like I can pattern match inside of a pattern definition
19:47:36 <rotaerk> was going to try something like:  pattern Foo (tag :=> Identity y) = ...
19:51:23 <Welkin> rotaerk: view patterns? https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns
19:53:31 <Welkin> rotaerk: it looks like you can use ViewPatterns with PatternSynonyms
19:54:16 <Welkin> under the "more complex example" https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms#Staticsemantics
19:54:48 <rotaerk> hmm thanks; not sure if that'll address what I was trying to do
19:54:55 <rotaerk> but I've changed my mind about trying to do that
20:01:07 <dumptruckman> hmm
20:01:18 <dumptruckman> my mergeSort function is hanging... not really sure how to debug it
20:01:34 <dumptruckman> https://ghostbin.com/paste/p6o3q
20:02:02 <dumptruckman> i'm sure there's also probably a simpler way to do left and right
20:02:07 <monochrom> Have you tested with very short lists? Like lengths 0, 1, 2, 3?
20:02:28 <dumptruckman> yeah, still hangs
20:02:52 <monochrom> You can at least walk through your code by hand for those short lists.
20:03:09 <dumptruckman> i tried throwing in some traceShow and/or traceShowId and it screws up the types
20:03:15 <dumptruckman> true
20:08:09 <dumptruckman> ah
20:08:12 <dumptruckman> i see what i missed
20:08:20 <monochrom> Yes.
20:08:27 <dumptruckman> mergeSort [x] = [x]
20:08:29 <dumptruckman> 🙃
20:09:46 <lyxia> dumptruckman: you can use div for integer division rather than rounding a floating point division...
20:10:41 <monochrom> And now it's a good time to take a look at these slides: https://perl.plover.com/classes/OOPSLA/samples/slide067.html
20:17:31 <dumptruckman> lyxia: yeah i wasn't sure how to do that and get one to round up and the other to round down
20:18:30 <Welkin> monochrom: wtf?
20:18:59 <monochrom> How do you mean?
20:19:10 <Welkin> was that a joke?
20:19:35 <monochrom> *shrug*
20:19:50 <dumptruckman> Welkin: make sure to click next
20:20:27 <lyxia> dumptruckman: x `div` 2 rounds down, (x+1) `div` 2 rounds up.
20:20:37 <dumptruckman> oh right
20:20:48 <lyxia> x - (x `div` 2) also works here
20:21:27 <Welkin> :t floor
20:21:29 <lambdabot> (Integral b, RealFrac a) => a -> b
20:21:32 <Welkin> :t ceil
20:21:33 <lambdabot> error: Variable not in scope: ceil
20:21:37 <Welkin> :t ceiling
20:21:38 <lambdabot> (Integral b, RealFrac a) => a -> b
20:24:58 * hackagebot static-tensor 0.2.0.0 – Tensors of statically known size – https://hackage.haskell.org/package/static-tensor
20:24:58 * hackagebot goatee-gtk 0.3.1.2 – A monadic take on a 2,500-year-old board game - GTK+ UI. – https://hackage.haskell.org/package/goatee-gtk
20:52:50 <totoro> I have a beginner's question. Can/Should I learn Type Theory if I am a beginner in Haskell?
20:53:59 <monochrom> Not enough information for a meaningful answer. Beginner vs not is beside the point.
20:54:26 <monochrom> Instead, whether you have an aptitude for formal logic is the point.
20:54:34 <monochrom> But you can always give it a try.
20:54:36 <totoro> monochrom: What should i provide as a meanigful information?
20:55:29 <totoro> monochrom: How can i determine if i have an aptitude for formal logic?
20:56:42 <kadoban> Try it I guess? If it's not going well, learn something else first
20:57:13 <totoro> ok
20:57:16 <monochrom> If you do not already know, learn "natural deduction", it's a precursor of type theory.
20:57:50 <monochrom> Or learn Haskell, it's also resembles a precursor of type theory, from another angle.
20:59:03 <totoro> ok, i will start by learning "natural deduction". Thank you monochrom 
21:25:08 * hackagebot threepenny-gui 0.8.2.0 – GUI framework that uses the web browser as a display. – https://hackage.haskell.org/package/threepenny-gui
21:26:33 <jeanne> Interesting
22:07:56 <pierrot> Good night. I have these programs: b-i (code->https://glot.io/snippets/etsh431q8n, heap profile->https://i.imgur.com/GUQKc8M.png) and b-ii (code->https://glot.io/snippets/etsh3bianb, heap profile->https://i.imgur.com/VNKT0bx.png). Can someone explain me why the version with foldl uses more than 600 MB while the version with foldr runs almost in constant space?
22:09:17 <elvishjerricco> Is there anything you can put in a stack.yaml to make it pass `+RTS -N -RTS` to ghci in `stack repl`? You can put it in `--ghci-options` on the command line, but this is inconvenient. I'd like for it to be in the stack.yaml file.
22:20:51 <`Guest00000> ghci can't parse decimal digits other than 0-9
22:21:18 <`Guest00000> (thus breaking spec)
22:21:56 <peddie> what is an example of a decimal digit that's not in 0-9?
22:23:49 <`Guest00000> peddie: ■ ■ ■ ■ ■ ■ ■ ■ ■ ■
22:24:19 <peddie> `Guest00000: that shows up as a series of black boxes for me
22:24:19 <`Guest00000> wait, i pasted wrong charactets
22:24:48 <`Guest00000> > take 10 ['\xff10'..] -- those
22:24:51 <lambdabot>  "\65296\65297\65298\65299\65300\65301\65302\65303\65304\65305"
22:26:33 <peddie> interesting
22:26:39 <peddie> file a bug report if you think it's a bug?
22:27:19 <`Guest00000> but "nobody implements the Haskell spec", so maybe nobody cares
22:27:27 <peddie> only one way to find out
22:27:58 <`Guest00000> it's not at all harmful to me right now, just a curiosity
22:28:02 <peddie> `Guest00000: I can't help but wonder how you encountered this problem
22:28:04 <peddie> ah OK
22:28:13 <`Guest00000> which i found out trying to implement a Haskell
22:28:14 <`Guest00000> lol
22:28:25 <`Guest00000> i wondered, "does ghci implement this?" - no
22:28:48 <`Guest00000> well, at least version 8.0.2
22:29:30 <nshepperd> > isDigit '０'
22:29:33 <lambdabot>  False
22:30:59 <`Guest00000> isDigit == \c -> c >= '0' && c <= '9'
22:31:35 <`Guest00000> > generalCategory '\xff10'
22:31:39 <lambdabot>  DecimalNumber
22:32:46 <`Guest00000> a Haskell implementation should/must accept any characters that are ((== DecimalNumber) . generalCategory) as digits
22:36:09 <iqubic> How hard is it to write a web browser purely in Haskell?
22:36:41 <phadej> iqubic: chris done did it recently
22:36:52 <phadej> iqubic: search reddit for recent posts
22:36:57 <iqubic> phadej: how hard was it for him?
22:37:13 <phadej> iqubic: he explains in his blog post :)
22:50:14 <jle`> hi all
22:50:30 <jle`> what's the best way to run a sandboxed process?  maybe restricted io access, timeouts
22:50:56 <someconductor> main = putStrLn "hello all."
22:51:10 <jle`> hi!
22:52:33 <c_wraith> jle`: have you looked at mueval?
22:52:54 <jle`> c_wraith: yeah, actually just started now
22:52:54 <c_wraith> jle`: it may not be what you want, but it certainly uses the sandbox techniques you'd want
22:54:08 <jle`> i guess right now i'm going to use launch under a custom user, and enforce a time-out
22:54:27 <jle`> i'll see how mueval manages memory restrictions
23:05:02 <pierrot> I had asked before this question:
23:05:28 <pierrot> pierrot: ―Good night. I have these programs: b-i (code->https://glot.io/snippets/etsh431q8n, heap profile->https://i.imgur.com/GUQKc8M.png) and b-ii (code->https://glot.io/snippets/etsh3bianb, heap profile->https://i.imgur.com/VNKT0bx.png). Can someone explain me why the version with foldl uses more than 600 MB while the version with foldr runs almost in constant space?
23:08:24 <pacak> pierrot: because foldl allocates a bunch of thunks
23:08:28 <pacak> pierrot: use foldl'
23:08:50 <jle`> hm, looks like mueval uses the 'unix' package to do most of is resource limiting stuff
23:10:06 <cocreature> this is not about foldl' vs foldl. this is about foldl vs foldr
23:11:12 <cocreature> pierrot: basically foldl has to run through the full list before it can start producing results. foldr on the other hand can yield elements one by one so it never has to allocate the full list
23:12:26 <digitalkiwi> when do you use which
23:12:38 <pierrot> cocreature: ohhh. I see it now!
23:13:12 <cocreature> pierrot: you can make it even more obvious if you make the first argument to f an infinite list
23:13:34 <cocreature> pierrot: in that case foldr will keep yielding elements from that list while foldl will never output anything
23:15:20 <cocreature> digitalkiwi: typically you use foldl' for small constant-space accumulators, e.g., calculating the sum of a list of integers, while you use foldr if your accumulator grows and you can produce parts of it lazily, e.g., you’re producing a new list.
23:15:45 <cocreature> foldr is also strictly more powerful. you can implement foldl in terms of foldr but you can’t do it the other way around
23:16:17 <digitalkiwi> why not just always use foldr
23:16:36 <pierrot> cocreature: foldr, in this case, goes like this: foldr (:) [1..n] [1..n] = (:) 1 (foldr (:) [1..n] [2..n]) = 1 : (foldr (:) [1..n] [2..n]) so the first element of the list is 1, then it's producing the elements one by one as you said
23:16:53 <cocreature> pierrot: exactly
23:16:55 <osa1> anyone know if GHC has an API for starting/stopping tick/allocation attribution and heap profiles? I have a program that runs for several minutes and I want to profile only some part of it.
23:17:18 <cocreature> digitalkiwi: because there is no reason to reinvent foldl' in terms of foldr every time
23:18:19 <cocreature> osa1: iirc there is startProfTimer and stopProfTimer but that only changes the attribution of ticks not allocation
23:19:16 <osa1> cocreature: right, and I'm trying to optimize for allocations ;-(
23:20:30 <digitalkiwi> if you never run your program you will have optimized away all of the allocations
23:21:00 <cocreature> osa1: it looks like startHeapProfTimer and stopHeapProfTimer are a thing. you could try ffing those. admittedly I’m not sure what exactly they do :)
23:22:48 <osa1> cocreature: IIRC those are supposed to be called once in a program's lifetime but I should check again
23:22:55 <osa1> I need this feature too often, maybe I should implement it myself
23:24:13 <osa1> I guess one problem with this feature is that I'll need one more layer of branching on each allocation which may slow things down significantly
23:24:20 <cocreature> osa1: they don’t do anything too fancy, so it might actually work https://github.com/ghc/ghc/blob/master/rts/Proftimer.c#L45
23:25:37 * hackagebot hackage-db 2.0 – Access Hackage's package database via Data.Map – https://hackage.haskell.org/package/hackage-db
23:26:29 <pierrot> cocreature: how the print works in the case of a list? I mean 'print $ f [1..n] [1..n]' doesn't have to wait for the creation of the whole list until printing the first element, right? it can consume it one by one if it's possible. is that correct?
23:27:33 <cocreature> pierrot: "print" is just "putStrLn . show" and "putStrLn" will print strings lazily
23:27:37 <cocreature> > print [1..]
23:27:40 <lambdabot>  <IO ()>
23:27:44 <cocreature> eh yeah
23:27:47 <cocreature> try that in ghci :)
23:27:57 <pierrot> :)
23:28:00 <pierrot> Thanks!
23:44:26 <olligobber> > show [1..]
23:44:29 <lambdabot>  "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
