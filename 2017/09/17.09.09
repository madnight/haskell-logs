00:00:29 <erisco> what I want is a function with type Eq b => (a -> b) -> [a] -> [(b,[a])]
00:00:47 <erisco> it works like group, but we retain what is similar about each group
00:00:49 <olligobber> @djinn Eq b => (a -> b) -> [a] -> [(b,[a])]
00:00:50 <lambdabot> Error: Undefined type []
00:00:55 <olligobber> grr
00:06:12 <olligobber> erisco, what about something like group f xs@(x:_) = (f x,takeWhile (\y -> f x == f y)):(group dropWhile (\y -> f x == f y))
00:06:21 <olligobber> oops I left some xs out
00:06:32 <olligobber> erisco, what about something like group f xs@(x:_) = (f x,takeWhile (\y -> f x == f y) xs):(group dropWhile (\y -> f x == f y) xs)
00:08:02 <erisco> hold on
00:09:12 <erisco> :t gang
00:09:14 <lambdabot> Eq b => (a -> b) -> [a] -> [(b, [a])]
00:09:30 <erisco> > gang (flip compare 4) [1..10]
00:09:32 <lambdabot>  *Exception: /tmp/mueval10252023621350490027.hs:(180,9)-(184,40): Non-exhaust...
00:10:48 <erisco> > gang (flip compare 4) [1..10]
00:10:50 <lambdabot>  [(LT,[1,2,3]),(EQ,[4]),(GT,[5,6,7,8,9,10])]
00:11:04 <erisco> had a parsing mishap trying to reduce it to one line
00:11:43 <erisco> so, like I was saying, a more useful function than groupBy is one where we remember what was similar
00:12:12 <olligobber> interesting
00:12:45 <erisco> now you might recognise a list of 2-tuples
00:13:33 <olligobber> that's not really helpful for my problem, thanks though
00:14:17 <erisco> > M.fromListWith (++) (gang (flip compare 4) [1..10])
00:14:19 <lambdabot>  fromList [(LT,[1,2,3]),(EQ,[4]),(GT,[5,6,7,8,9,10])]
00:14:34 <olligobber> :t M.fromListWith (++) (gang (flip compare 4) [1..10])
00:14:36 <lambdabot> (Enum a, Num a, Ord a) => M.Map Ordering [a]
00:15:04 <erisco> > M.lookup GT (M.fromListWith (++) (gang (flip compare 4) [1..10]))
00:15:06 <lambdabot>  Just [5,6,7,8,9,10]
00:15:15 <olligobber> Oh no, it's a maybe
00:15:25 <erisco> > maybeToList (M.lookup GT (M.fromListWith (++) (gang (flip compare 4) [1..10])))
00:15:28 <lambdabot>  [[5,6,7,8,9,10]]
00:15:36 <erisco> > concat (maybeToList (M.lookup GT (M.fromListWith (++) (gang (flip compare 4) [1..10]))))
00:15:39 <lambdabot>  [5,6,7,8,9,10]
00:15:43 <erisco> oh ye of little faith
00:15:49 <olligobber> that's even longer than what I had before!
00:16:02 <erisco> longer does not imply it is more complicated
00:16:29 <olligobber> it uses a map though
00:16:35 <erisco> so what
00:16:48 <erisco> it doesn't *have* to, I just thought that was an interesting connect with the list of 2-tuples
00:16:52 <olligobber> that seems to overcomplicate it a bit
00:16:54 <erisco> because we can collect all the similar groups
00:16:59 <olligobber> yeah
00:17:02 <erisco> we can instead find the first group, for example
00:17:14 <erisco> :t find
00:17:15 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
00:17:47 <erisco> > find ((==GT).fst) (gang (flip compare 4) [1..10])
00:17:49 <lambdabot>  Just (GT,[5,6,7,8,9,10])
00:19:55 <erisco> now there is another pattern which comes up over and over that annoys me
00:20:33 <erisco> we annotate elements so that we may effectively use other functions such as find, but then we want to forget these annotations
00:21:23 <olligobber> for that you could do concat . maybeToList . (fmap snd)
00:21:33 <erisco> yes but it is annoying
00:21:42 <olligobber> > concat . maybeToList . (fmap snd) Just (GT,[5,6,7,8,9,10])
00:21:45 <lambdabot>  error:
00:21:45 <lambdabot>      • Couldn't match type ‘Maybe (Ordering, [Integer])’
00:21:45 <lambdabot>                       with ‘(a0, a1 -> Maybe [a])’
00:21:53 <erisco> I have to project fst to do what I want, then I have to project snd to get what I want
00:22:18 <olligobber> that didn't work
00:22:30 <erisco> so what we want is to general this idea
00:22:33 <erisco> generalise
00:22:59 <erisco> here is gang, btw http://lpaste.net/358307
00:26:26 <erisco> could be made less strict, hm, but anyways
00:30:07 <dhbdhb> Hello, is there a way to use wreq responses without binding them?  I'd like to avoid having to write `response <- get "https://google.com"` and would like to do something like `"get "https://google.com" >>= (\x -> doSomething x)`
00:32:12 <kadoban> dhbdhb: Sure, how you would like should exactly work. That's about exactly how do notation is desugared.
00:32:18 <pyrotex> hello!!!
00:33:02 <pyrotex> hi jrm
00:33:11 <dhbdhb> I don't want to have to use "do" notation.  I'd prefer to use "bind" or some other way of processing the result.
00:33:18 <dhbdhb> kadoban^^
00:34:07 <pyrotex> parse error
00:34:29 <pyrotex> 'blow me
00:34:33 <kadoban> dhbdhb: Right. So ... the thing you said you want to do doesn't use 'do' notation, and is correct syntax. So I'm a bit confused by the question.
00:37:25 <kadoban> :t getLine >>= \x -> putStrLn x
00:37:26 <lambdabot> IO ()
00:37:33 <kadoban> :t do {x <- getLine; putStrLn x}
00:37:34 <lambdabot> IO ()
00:37:40 <kadoban> Those two do the same thing, for instance.
00:38:57 <erisco> this is my initial thought for generalising the pattern http://lpaste.net/358308
00:39:11 <erisco> which is probably intersecting with lens somehow, so I'll let a lens expert digest that
00:40:07 <dhbdhb> I feel like getLine >>= \x -> putStrLn x is a better representation than the do notation
00:40:16 <dhbdhb> So I want to do that with the Wreq request
00:40:19 <erisco> the idea of an  Extractor s a t  is it extracts an  a  from an  s  and leaves us with a  t
00:40:29 <dhbdhb> I know they achieve the same effect.
00:40:45 <erisco> so, findExtract needs an  Extractor s Bool t
00:41:11 <kadoban> dhbdhb: Then feel free to do so?
00:41:13 <erisco> the point of having extractors is that we can manipulate them as their own objects
00:41:22 <erisco> which is done by mapExtraction, in the example
00:41:43 <erisco> given the  first  extractor, we can map the extracted value
00:42:11 <dhbdhb> kadoban:  I thought it wasn't possible because I didn't see it in the documentation anywhere >.<
00:43:26 <kadoban> dhbdhb: Ah. Yeah, it's always possible. The Monad typeclass is defined in terms of (>>=) and return, so they *have* to exist. If do notation works, you must be able to use (>>=) instead as you like.
00:43:54 <olligobber> @djinn Ord a => l a -> a -> (l a, l a, l a)
00:43:55 <lambdabot> Error: Class not found: Ord
00:44:08 <olligobber> that's weird
00:45:22 <erisco> I imagine you can do more work with this to refine it
00:45:31 <dhbdhb> kadoban:  Thanks for the info! I'm still picking up Haskell 
00:46:01 <kadoban> Anytime. Sorry for my above confusion :)
00:49:41 <pyrotex> yo yo yo
00:52:54 <Kovalski> Why do you choose haskell over, say lisp? I'm trying to decide where I'll go first.
00:55:12 <cocreature> Kovalski: because I prefer having the compiler catch my errors via types over finding those errors at runtime
00:55:32 <Kovalski> cocreature, that's it?
00:55:51 <erisco> here is the lazier version of gang http://lpaste.net/358309
00:56:45 <cocreature> Kovalski: that’s the main part, we can argue for hours about little details but in the end it’s the type system that keeps me using Haskell
00:58:11 <Kovalski> cocreature, have you ever given lisp a shot?
00:58:18 <cocreature> yes
00:59:22 <Kovalski> ok, cool.
01:00:44 <cocreature> after the type system, the second most important thing for me is probably Haskell’s support for concurrency
01:01:18 <cocreature> but I’m not too familiar with how the various lisps do in that area
01:03:21 <Kovalski> I've no idea either. I guess I'll go with perl for now. LOL
01:03:49 <Kovalski> It's a boring night.
01:08:50 <cocreature> Kovalski: I’m not sure how you end up with perl if you’re trying to decide between lisp and Haskell but if it works for you, that’s fine :)
01:09:50 <Kovalski> cocreature, oh no it was probably just a bad joke.
01:10:11 <Kovalski> Haskell or lisp is still up.
01:10:37 <cocreature> just learn both and decide for yourself which one you like better :)
01:10:52 <erisco> if you can't decide then choose neither
01:11:33 <Kovalski> cocreature, I will but what will I learn to-night is the question.
01:11:42 <Kovalski> erisco, like you?
01:12:23 <erisco> I can listen to instructions but don't trust I'll execute them exactly
01:12:50 <erisco> its all wetware up in here
01:13:37 <Kovalski> As it is with boring times, I feel uninspired. I needed some pointers.
01:13:54 <Kovalski> erisco, wetware works for me.
01:15:02 <erisco> okay, if you can't decide between Lisp and Haskell, learn Lambda Calculus
01:15:15 <cocreature> erisco: typed or untyped lc? :)
01:15:24 <raichoo> dependently typed LC
01:15:27 <raichoo> :P
01:26:15 <erisco> you can also apply the extractor pattern to  (Profunctor f, Functor g) => f -> g
01:26:22 <erisco> and then abstract the arrow even, I imagine
01:26:53 <erisco> find :: (a -> Bool) -> [a] -> Maybe a  can become  [a] -> (a -> Bool) -> Maybe a
01:28:11 <erisco> you just need the contrafunctor though, but then (->) needs more wrapping… annoying
01:31:40 <erisco> point is that you don't want to rewrite find, you just want to adapt it
01:31:56 <erisco> but you also want to rewrite all the other annoying functions in the same way
01:34:03 <erisco> so, different topic… stuff in Data is for datatype definitions and stuff in Control is for other stuff? roughly?
01:37:23 <cocreature> erisco: at this point it’s mostly arbitrary and nobody understands the distinction
01:37:56 <cocreature> Data.Functor and Control.Applicative just makes no sense
01:38:12 <[exa]> naming is hard.
01:38:24 <[exa]> (also, ontologies)
02:30:07 <terrorjack> Hi, I notice that cabal configure has a --split-objs flag. But why is there no --split-sections, or just tell people to add such flags via --ghc-options?
03:18:19 <cocreature> terrorjack: I don’t know why there is a cabal flag for --split-objs but ghc-options seems like the right solution
03:37:01 <thblt> Hi!  I'm having a bit of trouble with Intero on NixOS.  When automatically building Intero on a new project, the build fails with "configure: error: curses library not found, so this package cannot be built".  Any ideas?
03:37:27 <thblt> Thanks :)
03:41:47 <thblt> Also, from Intero's source tree, stack build works.
03:50:57 <jchia_> Question about Text.Megaparsec.Byte from megaparsec-6.1: 'char' parses one byte. I want to parse one ASCII character from a ByteString, i.e. not a Char but a Word8. If I want to parse ':', I could do "MP.char . fromIntegral . ord $ ':'", but is there a less verbose way? I couldn't find any convenience function that allows me to skip the fromIntegral & ord.
03:53:22 <cocreature> jchia_: if you want to parse an ASCII character why not use "asciiChar"?
03:53:27 <cocreature> that gives you a Word8
03:53:47 <jchia_> cocreature: not just any ASCII character, I'm looking for some specific value.
03:54:04 <cocreature> oh ok
03:55:06 <cocreature> jchia_: can you show us the code you’re using? "char" should be sufficiently general that for a bytestring you’ll get a Word8
03:55:10 <jchia_> cocreature: If parsing a Char from a String or Text, I can just use char. If parsing a Word8 from a ByteString, I can also use char, but because I'm trying to match against against an ASCII character, I have to do the 'fromIntegral . ord' dance.
03:55:36 <cocreature> oh you’re converting the target character rather than the parsed character?
03:55:50 <cocreature> I should have taken a closer look at what you actually wrote
03:56:12 <cocreature> jchia_: I don’t think there is a less verbose way. if you find yourself using that more than once just define your own helper
03:57:46 <jchia_> cocreature: http://lpaste.net/358313
03:57:52 <jchia_> OK
04:01:29 <erisco> SPJ made hacking on Core sound like a lot of fun
04:03:06 <erisco> an optimisation I think would be interesting is evaluating terminating expressions to whnf
04:03:30 <erisco> which then requires inference of termination
04:05:24 <cocreature> fancy constant folding :)
04:05:33 <erisco> yes
04:08:19 <cocreature> afaik ghc is not particularly good at constant folding so you might not even need super-fancy terminating detection to do better than it currently does
04:10:57 <erisco> a problem is that you may not this to happen
04:11:21 <erisco> for example, take 1000000 [1..] terminates, but you might not really want a million numbers in your executable
04:11:49 <cocreature> yeah either you come up with some heuristic or you expose some primitives to control this (or both)
04:15:22 <erisco> maybe the heuristic is monotonically nonincreasing term size
04:19:20 <Myrl-saki> I haff a queshun.
04:19:37 <Rembane> Myrl-saki: Shoot!
04:19:49 <Myrl-saki> I think this is generalized by a iteratee consumer
04:19:50 <erisco> that might be strange to measure though, hrm
04:20:06 <erisco> you could measure it up to a recursive call site, so after all other reductions take place
04:20:19 <erisco> reverse [x,y,z] gets you up to rev [y,z] [x] assuming rev is the internal helper
04:20:26 <Myrl-saki> Wait.
04:20:30 <cocreature> erisco: it’s probably also too strict, a small increase in size is not unreasonable
04:20:30 <Myrl-saki> Something like
04:20:32 <Myrl-saki> HVect a -> b
04:20:38 <Myrl-saki> Err no.
04:20:41 <erisco> but is this the same size or smaller? guess we can count nodes of the expression, lets see
04:20:54 <erisco> yeah but a small increase might be like boiling the frog
04:20:56 <Myrl-saki> Is there a term for something  that does (HVect a -> b)?
04:21:18 <cocreature> Myrl-saki: what’s HVect here?
04:22:43 <Eduard_Munteanu> Myrl-saki, forall a. exists b. HVect a -> b?
04:22:58 <erisco> might have miscounted but I get size 9 for reverse [x,y,z] and size 11 for rev [y,z] [x]
04:23:18 <Eduard_Munteanu> I presume it's a heterogenous list type.
04:23:36 <cocreature> sure but those exist in various forms
04:24:09 <erisco> there is an extra apply and an extra empty list
04:25:13 <erisco> so I feel like not only do we need to know termination, but we might also need to know relative sizes of terms to their normal forms
04:25:29 <erisco> reverse [x,y,z]  is actually smaller when normalised
04:25:37 <erisco> but along the way the expression gets bigger
04:26:58 <Eduard_Munteanu> But I guess a more reasonable type is   HVect (a ': as) -> a
04:27:22 <Eduard_Munteanu> aka head for HVect.
04:27:50 <erisco> if we did have this info though our heuristic would be trivial
04:29:59 <Myrl-saki> rr
04:30:04 <Myrl-saki> Back now.
04:30:25 <erisco> I just worry about letting anything become bigger because this may have a cascading, exponential effect
04:30:26 <Myrl-saki> Eduard_Munteanu: Nah.
04:30:49 <Myrl-saki> basically
04:30:57 <Myrl-saki> I wanna generalize `a -> ... ->b `
04:31:15 <Myrl-saki> That's also why I was thinking of consumers.
04:31:19 <thblt> cs
04:31:29 <erisco> Myrl-saki, I already did, if I'm thinking like you're thinking
04:32:00 <erisco> Myrl-saki, how are you implementing the functions with those types?
04:32:13 <Myrl-saki> erisco: HVect for the "vararg".
04:32:26 <erisco> yeah but how are you using the var ags
04:32:28 <erisco> var args*
04:32:38 <erisco> I am soon going to publish a framework for variadic functions
04:32:47 <Myrl-saki> Right, that's the problem.
04:32:55 <erisco> perhaps you can instruct me on possible uses
04:33:08 <Myrl-saki> My actual type is something along the lines of generating a's with IO.
04:33:21 <Myrl-saki> For example, using `read` to get as.
04:33:31 <erisco> does not compute… you want to generate types with IO?
04:33:38 <Myrl-saki> erisco: Nooo
04:33:54 <Myrl-saki> erisco: generate values of the arguments.
04:34:19 <erisco> so, what does this mean? are you looking for liftA3 or something?
04:35:18 <Myrl-saki> Hmmm
04:35:26 <erisco> such as, you have an n-ary function, and you want the liftAn for it
04:35:43 <erisco> imagine it was a 3-ary function, then
04:35:46 <erisco> :t liftA3
04:35:47 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
04:35:48 <Myrl-saki> Right.
04:36:00 <erisco> f = IO
04:36:49 <erisco> I was thinking of this earlier today but it doesn't fall into the form of variadic functions I am writing the library for
04:37:07 <Myrl-saki> Let me try to construct the type of what I wanna do
04:37:08 <erisco> but I was going to implement it and see if I could wrangle everything into something more general yet
04:37:58 <erisco> the liftAn idea is a map on variadic functions
04:39:50 <erisco> Myrl-saki, the trick I find is not defining it but getting inference to work
04:39:54 <Myrl-saki> I should have opened the project before trying to theorize of how to make functions. :C
04:40:24 <erisco> you can do all the craziness you want, usually isn't so hard, but then GHC can't figure out wtf you want
04:40:31 <Myrl-saki> erisco: Right.
04:43:02 <Myrl-saki> erisco: Also, do you have a repo online for your variadic functions?
04:44:02 <erisco> I haven't got it up yet because I am still refining it, but it is working
04:44:22 <Myrl-saki> Ah. :P
04:44:25 <Myrl-saki> wei2912: omg hi
04:44:29 <erisco> I can see an idea for how to define liftAn using a similar technique but I have to generalise further, and so need to think about that
04:45:02 <erisco> Myrl-saki, what is your f going to be, by the way? because if it is not arbitrary then I might already have that solved
04:45:17 <Myrl-saki> erisco: Right.
04:46:22 <erisco> I can, for example, write  listOf <$> x <*> y <*> z  and it creates  (\x y z -> [x,y,z])  for  listOf
04:46:51 <Myrl-saki> erisco: I'm thinking of a generalized monad which is like the Reader monad, but it's "stateful"
04:46:55 <erisco> doing this sort of stuff with applicatives is the only real use I could come up with so far
04:47:05 <erisco> printf is possible but it is such a weird thing in the first place
04:47:48 <Myrl-saki> erisco: Basically, a `read` consumes the state, it's a bit like streaming.
04:49:23 <erisco> so, what, like State?
04:50:37 <wei2912> Myrl-saki: hi!
04:50:38 <Myrl-saki> erisco: That's also kinda what I was thinking, yeah.
04:50:40 <wei2912> haven't seen you in ages
04:50:45 <Myrl-saki> Wait.
04:50:51 <Myrl-saki> wei2912: Me neither.
04:50:58 <wei2912> Myrl-saki: pm?
04:51:26 <Myrl-saki> wei2912: Sure.
04:51:33 <erisco> Myrl-saki, how does it differ from State and how are variadic functions involved?
04:51:59 <Myrl-saki> erisco: Right.
04:52:24 <Myrl-saki> erisco: It's a bit similar to `State [a]`
04:52:46 <Myrl-saki> erisco: Except you have `get` and `put` which removes and adds to the list respectively.
04:52:47 <erisco> are you thinking of an indexed state, perhaps?
04:52:53 <Myrl-saki> erisco: Yep.
04:53:01 <Myrl-saki> erisco: But type safety is not exacty requried.
04:53:43 <Myrl-saki> erisco: And generalizing that to allow, for example, IO, where you can use `readLn` for `get`
04:54:36 <erisco> so, the state is some record, i.e. we have labeled fields
04:54:46 <erisco> this could be number indexes or field names or whatever
04:54:57 <erisco> I am not sure how readLn makes sense with that picture
04:56:17 <erisco> readLn accesses the world state, so maybe you'd want a world state with everything labeled?
04:56:34 <Myrl-saki> erisco: I don't need it to be able to access the world.
04:56:42 <Myrl-saki> erisco: For example, we can do `run [....] a`
04:56:46 <Myrl-saki> Err
04:56:48 <Myrl-saki> m
04:57:04 <erisco> how does readLn not access the world?
04:57:25 <Myrl-saki> erisco: I want it to generalize that it has state, but not necessarily world state.
04:57:50 <average> so you're debating how to read a line?
04:58:02 * average smiles
04:58:08 <Myrl-saki> average: :P
04:58:15 <erisco> no, we're debating how to finally defeat Bash
04:58:23 <average> erisco: you know that's not happening
04:58:47 <Myrl-saki> erisco: OTOH, I love using Haskell + Bash.
04:58:53 <erisco> maybe not now, but Bash will become arrogant, and in its arrogance will become complacent
04:58:57 <erisco> and that is when we shall strike
04:58:59 <Myrl-saki> I feel like something broke in me.
04:59:16 <average> Myrl-saki: your heart?
04:59:37 <Myrl-saki> average: My brain.
04:59:44 <average> ok
04:59:46 <cocreature> bash does that to your brain
04:59:59 <erisco> Myrl-saki, what generalised sense would you give to readLn?
05:00:21 <Myrl-saki> erisco: I mean yeah, it "consumes the world state"
05:00:28 <erisco> we could say something like readLn only cares about a particular index, call it stdin
05:00:34 <Myrl-saki> Just as how "get" "consumes one unit of the stream" in the example of indexed state
05:00:44 <erisco> and so any state featuring this index can have readLn used on it
05:01:23 <erisco> is consumption the feature you want or merely that it reads it?
05:01:44 <erisco> you could talk about the *effect* of readLn, which is that it reads and writes
05:02:30 <erisco> and there is work done on generalising monads for multiple effects, rather than one
05:02:31 <Myrl-saki> erisco: I don't want `read` to be strictly nullipotent. That's the case of State, right?
05:03:12 <erisco> and I even spotted a Haskell library which implements some of the ideas but I haven't used it yet
05:04:42 <erisco> in a nutshell, the idea is that instead of a transformer stack you have a flattened monad which gives you the least upper bound of effects you use
05:04:59 <average> erisco: and all that.. to read a line.. right?
05:05:17 <Myrl-saki> average: Not exactly. :P
05:05:19 <erisco> so if you only read you only get Reader, and if you only write you get Writer, and if you read and write you get State (essentially)
05:06:16 <erisco> and whether you can use this to simplify stacks containing multiple state transformers… I am not sure, but perhaps
05:08:18 <erisco> Myrl-saki, I can link you to some material if any of that sounds vaguely relevant
05:08:29 <erisco> I still don't know what variadic functions have to do with it, though
05:09:21 <Myrl-saki> erisco: Sure.
05:09:45 <erisco> generally speaking you'd be looking at "effect systems"
05:09:52 <Myrl-saki> erisco: Right. I'll finish my implementation first before asking more, because I mght change the design anyway. :P
05:09:59 <erisco> http://hackage.haskell.org/package/effect-monad
05:12:35 <erisco> "Type and Effect Systems" Nielson & Nielson, "A Generic Type-and-Effect System" Marino & Millstein, "Polymorphic Effect Systems" Lucassen & Gifford, "A Flexible Semantic Framework for Effects" Tate & Leijen
05:12:52 <erisco> I would particularly look at the first and last listed
05:13:40 <erisco> and if that is fun then also read on coeffect systems
05:14:44 <average> this programming business is pretty complicated. reaching out to read a paper in order to learn how to read a line. at this pace.. when does one even get paid?
05:15:33 <erisco> I think you just become a professional student
05:16:10 <average> erisco: a broke professional student?
05:16:33 <erisco> you're only broke if you need the money you don't have
05:16:57 <average> sometimes I contemplate on the financial situation and well-being of Haskell programmers..
05:18:24 <`Guest00000> average: (they are well, they just don't write in Haskell for their job?)
05:18:27 <Hafydd> Whatever deficiencies are there are surely made up for by the intellectual wellbeing afforded by studying Haskell.
05:18:52 <average> Hafydd: for real?
05:19:10 <average> :)
05:19:14 <Hafydd> average: I have not proven this fact, but I believe it to be true.
05:19:32 <average> Hafydd: so it's a gut-feeling or maybe anecdote
05:20:28 <erisco> average, if we were somehow on IRC in the 20's, would I be hearing you advocating for punch cards and never mind these ideas of "programming languages"?
05:20:34 <Hafydd> Haskell programmers seem to be to be more relaxed than other programmers, perhaps because writing Haskell is often pleasurable.
05:21:53 <average> erisco: punchcard programmers were being paid a decent wage actually, and they also had stable jobs
05:22:04 <average> at least from my reading..
05:22:41 <average> Hafydd: well, but wouldn't you say Myrl-saki got lost in details if he was trying so hard to read a line?
05:23:29 <Hafydd> average: I haven't read the conversation, but I wouldn't say that getting lost in the details of something is necessarily unpleasurable.
05:23:30 <Myrl-saki> average: It's not exactly reading a line. :P
05:23:34 <Myrl-saki> average: It's more like streaming.
05:23:55 <erisco> I see, so a difference is that I do not use market forces to weigh ideas in computer science
05:23:57 <Myrl-saki> average: For example, you can explicitly pass the "lines" to the function.
05:24:05 <average> Hafydd: I'm reminded by certain ppl that getting lost in details is actually a really bad thing when you're trying to GTD
05:24:10 * Hafydd . o O (If you never use your program in practice, you never have to deal with the stress of deployment.)
05:24:27 <average> haha Hafydd 
05:24:35 <average> no deployment, no problem
05:24:36 <Hafydd> average: whether or not it's a bad thing, it may still be pleasurable.
05:24:48 <Myrl-saki> Hafydd: Why handle the stress of deployment when you can just edit in prod?
05:25:18 <average> erisco: would you qualify Bash as a market force? :)
05:25:50 <erisco> get O'Reilly in here! I hear he has spare time now
05:26:09 <Hafydd> average: on that note, I would observe that once you are familiar with the language, it's easier and faster to "GTD" in many cases in Haskell than in other languages.
05:26:39 <average> I will write a book "Bash: An beginner's guide for Haskell technicians"
05:27:42 <erisco> average, I just look at the merits of the language, and I see it alright for some small things… usually when it is just running one program
05:28:15 <average> erisco: but Haskell is for "large things" ?
05:29:46 <maerwald> Hafydd: huh?
05:29:58 <maerwald> haskell is terrible for prototyping quickly, it's more suited for doing things properly
05:30:34 <erisco> Haskell has better tools to manage larger ideas
05:30:39 <maerwald> yeah
05:30:43 <marvin2> I don't find it terrible for prototyping
05:30:59 <maerwald> marvin2: then write a tool that downloads and parses CVE and puts it into a mysql DB
05:31:10 <Hafydd> maerwald: this is not my experience. Perhaps there is a domain of programs in which it's harder to prototype in Haskell, but I have encountered many problems (especially those of an algorithmic/mathematical nature) where it's excellent for it.
05:31:11 <maerwald> I did that and also looked at how I would do that in haskell
05:31:27 <maerwald> in python it was 2 days, in haskell I would have to learn huge xml DSLs first
05:31:44 <erisco> I can't give any detailed critique of Bash because I hardly understand it
05:32:18 <Hafydd> I would not be surprised if programs that need to explicitly use IO are harder to prototype well in Haskell.
05:32:35 <maerwald> marvin2: when you are prototyping, you usually don't know the domain yet, so the time you need to get comfortable with libraries has to be LOW
05:32:36 <maerwald> not high
05:33:41 <marvin2> maerwald, I find it far easier to get comfortable with libraries in haskell than in python, with its freestyle description of what each method does (due to lack of types)
05:33:43 <Hafydd> maerwald: do you mean CVE or CVS?
05:33:49 <maerwald> CVE
05:33:51 <average> erisco: you don't know Bash?
05:34:09 <maerwald> marvin2: I think that is an opinion, not a practical experience :>
05:34:10 <Hafydd> maerwald: as in Common Vulnerabilities and Exposures?
05:34:12 <average> erisco: will you read my best-seller book about Bash intended for Haskellers?
05:34:15 <maerwald> Hafydd: yes
05:34:17 <Hafydd> I see.
05:34:48 <maerwald> Hafydd: actually, CAPEC, CWE and CVE
05:34:49 <maerwald> all 3
05:35:20 <erisco> average, I saw enough to where I no longer have hope for it
05:35:21 <average> maerwald: I could've probably done that in one hour in Bash
05:35:29 <maerwald> by the time the tool grew bigger the lack of types became a problem -> which was the time to ditch the prototype and rewrite it in haskell
05:35:42 <maerwald> BUT... at that point I knew what the problem areas were, so 
05:36:00 <average> erisco: so you're ready to throw under the bus that which makes it possible for GHC to be built into binaries for you to use? (I mean in the build system)
05:36:03 <maerwald> still would never do that kind of prototyping in haskell :>
05:36:06 <maerwald> average: maybe
05:36:19 <maerwald> average: git was written in bash in 2 weeks
05:36:26 <maerwald> as a prototype
05:36:27 <erisco> average, I also threw C under the bus and that runs most of the software I use. So what of it.
05:37:22 <erisco> time goes forward, we learn more, we have better ideas… no attachments
05:37:37 <average> well, I'm glad to hear there's also people not interested that much in practical matters
05:37:43 <erisco> you could, I don't know, give C modules and immediately have a better language
05:37:50 <erisco> or give it some polymorphism and immediately have a better language
05:37:52 <cocreature> average: the GHC build system is being rewritten in Haskell for a reason :)
05:38:43 <Hafydd> Terrorism idea: delete every GHC binary in existence, so bootstrapping becomes impossible.
05:38:55 <average> erisco: but isn't it interesting that very few(if any) of the criticial software is written in stuff that have polymorphism and all that fancy stuff?
05:39:05 <erisco> maybe having a multi-pass compiler so you don't need header files… hey we have faster CPUs and SSDs
05:39:13 <olligobber> Hafydd, good luck
05:39:39 <maerwald> average: well, you mean safety critical probably
05:39:46 <maerwald> that is true, they also avoid OOP like its cancer
05:40:00 <erisco> average, I don't have a measure of that
05:40:06 <average> I mean critical as in.. it's used by a lot of people
05:40:06 <Hafydd> average: critical software like OpenSSL?
05:40:14 <average> OpenSSL is critical yes
05:40:23 <maerwald> well, I was thinking of industrial embeded safety critical software
05:40:25 <Hafydd> Which had a fatal vulnerability because it's written in a language not much better than assembly.
05:40:29 <average> there's a huge number of things relying on it
05:40:42 <erisco> and you can have a company using a lax language like C but then using sophisticated tools and methods to prove it correct
05:40:44 <maerwald> Hafydd: not the reason. The reason is the lack of formal methods
05:41:03 <Hafydd> maerwald: formal methods like what? Type-checking?
05:41:05 <maerwald> seL4 is written in C, so what?
05:41:08 <maerwald> lol no
05:41:22 <maerwald> do I have to explain "formal methods" now? :/
05:41:30 <average> formal methods will never be used except for luxurious budget projects
05:41:39 <average> it's not cheap or easy
05:41:42 <maerwald> true
05:41:48 <average> the world needs cheap and easy Bash scripts..
05:41:51 <erisco> … it'll get easier
05:41:51 <Hafydd> maerwald: summarise what you mean by it. I don't think you have to "explain" it.
05:41:53 <maerwald> but seL4 is used in space afaik
05:42:26 <maerwald> Hafydd: https://en.wikipedia.org/wiki/Formal_methods
05:42:31 <erisco> you keep writing Bash… like I said, you win for now… we'll strike when your ideas become tired
05:42:50 <ggVGc> bash is great for what bash is good for
05:42:54 <average> but Bash is winning for many decades now..
05:42:56 <maerwald> you can write C and still prove there are no memory errors
05:42:56 <ggVGc> which is essentially hooking together processes
05:42:59 <ggVGc> haskell is less good at this
05:43:01 <ggVGc> imo
05:43:23 <Hafydd> maerwald: so you're saying that the problem came about because the C language was not extended with external tools to make up for the language's deficiencies.
05:43:26 <maerwald> you start with a formal memory model and verify it in e.g. promela or something
05:43:47 <maerwald> Hafydd: no, the tools are exceptionally good for C, because it is low level, people just don't use them
05:44:59 <olligobber> would it be easy to make 3 distinct versions of Float that cannot be compared?
05:45:07 <maerwald> ofc you can embed those techniques into the language (see the everst project)
05:45:23 <erisco> olligobber, what does that mean? what is a distinct version of Float?
05:45:26 <maerwald> but that doesn't mean you cannot write a correct TLS implementation in C
05:45:36 <Hafydd> maerwald: well, I suppose that would have been one way to prevent the problem. Using a higher-level language would have been another one.
05:45:49 <maerwald> Hafydd: higher-level languages are dangerous for crypto
05:46:05 <maerwald> timing behavior and so on
05:46:16 <olligobber> like, I have something of type (Float, Float, Float), but I want something more like (A, B, C) where A, B and C can't be compared
05:46:22 <olligobber> but still contain Float data
05:46:28 <maerwald> even C is too high-level for some things in crypto
05:46:33 <cocreature> olligobber: use newtypes
05:47:03 <maerwald> again: see the everest project, they have an interesting approach imo
05:47:12 <olligobber> cocreature, ty
05:47:26 <maerwald> use a high-level language, but then extract it to C and prove those properties on the extracted code you cannot prove on the high-level code
05:47:48 <maerwald> the protocol can be proven on the high-level language via dependent types and whatnot (F*)
05:48:15 <erisco> you can give an operational semantics to C and then prove things about C programs, it is being done as we speak
05:48:16 <Hafydd> I have some doubt that using a high-level language makes it harder to prove formal properties, but I'll take your word for it.
05:48:21 <erisco> not sure if Everest is based on that work
05:48:53 <Hafydd> (It seems like less progress has been made with higher-level languages just because fewer people care about them.)
05:49:00 <maerwald> no
05:49:09 <maerwald> crypto is just a different problem
05:49:41 <erisco> how does the level of language have anything to do with crypto?
05:50:11 <maerwald> parts of crypto code are written in ASM because of reasoning about timing
05:50:35 <ggVGc> what if you had a strongly times high level language
05:50:40 <erisco> is the relevancy timing attacks, then?
05:50:45 <maerwald> ggVGc: show me one :>
05:51:13 <average> maerwald: he will start writing one
05:51:24 <maerwald> GHC is so far away from that like you can only imagine
05:51:31 <ggVGc> maerwald: my point is, if crypto is an important problem for the world, then it should be reasonable to formalize the timing concepts so that you can use a better tool to write robust crypto code
05:51:46 <Hafydd> "High level" does not entail having GC or a RTS or anything like that.
05:51:57 <average> ggVGc: but people don't have time for all that
05:52:01 <erisco> last time I checked it meant "not assembly"
05:52:07 <maerwald> Hafydd: C is high-level and at some point it's hard enough to reason about CPU cycles
05:52:15 <maerwald> when you want exact results
05:52:15 <average> business needs things to get done, on schedule, with deadlines
05:52:37 <erisco> why are the CPU cycles relevant? I don't know a thing about crypto but would like a basic understanding here
05:53:04 <average> erisco: you can potentially guess things depending on the time it took to compute them, that's why
05:53:12 <average> that's the essence of a timing attack afaik
05:53:39 <erisco> ah, yes
05:53:51 <erisco> reminds me of… what did they call it… where you monitor the power use of a device
05:54:09 <cocreature> the general term is “side channel attacks”
05:54:17 <erisco> yes, that was it
05:54:42 <erisco> kind of a problem if there is a discernible wave form when you press the right key versus the wrong one
05:54:56 <cocreature> whether the risk of a timing attack is actually more of a problem than a bufferoverrun in your C or assembly is another question
05:55:00 <maerwald> ggVGc: it's hard to write such a language. Then compare the tools you have at hand for low-level languages (a lot) ... the tooling isn't even the problem
05:55:06 <maerwald> it's that OpenSSL project does not use them
05:55:13 <average> "The article describes interviews with
05:55:13 <average> pizza delivery personnel who claimed to be able to predict the announcement of major
05:55:14 <average> military operations based upon pizza delivery orders to places such as the Pentagon, the
05:55:17 <average> White House, and the CIA" -- http://repository.cmu.edu/cgi/viewcontent.cgi?article=1052&context=jpc
05:55:25 <Hafydd> LOL
05:55:27 <average> erisco: ^^ similar to that too
05:55:51 <cocreature> formal verification tools don’t come for free. they usually require that you restrict yourself in various ways, restructure code, …
05:55:51 <average> Hafydd: take off, it's true
05:56:07 <erisco> look for the smoke, even if that smoke is topped with cheese
05:56:08 <cocreature> so not using them is not just arrogance or ignorance
05:56:12 <Hafydd> average: I don't doubt it, but it's still funny.
05:56:31 <[exa]> side channels are underestimated I see
05:56:56 <maerwald> ggVGc: nor does LibreSSL :>
05:57:14 <maerwald> so they are not even "better" except they think they are smarter (and maybe they are, but..)
05:57:27 <ggVGc> I think the issue here is that everyone started using software, before anyone knew how to actually create it
05:57:33 <maerwald> heh
05:57:50 <erisco> and this is why I am worried about AI
05:58:01 <ggVGc> erisco: don't worry, the AI will fix it
05:58:03 <maerwald> I think this is what computer engineering is currently discovering. We are not an engineering science (yet).
05:58:07 <average> "A Haskell programmer is worried about AI"
05:58:10 <[exa]> btw I remember libgcrypt (of gnutls) crypto was specified in scheme or something
05:58:14 <average> (sounds like a title out of n-gate.com)
05:58:19 <erisco> seems we're inclined to find the depth of a hole by jumping in first
05:58:27 <[exa]> erisco: why worried?
05:58:35 <maerwald> we will, IoT will help us jump into that hole
05:58:47 <maerwald> full speed
05:58:49 <erisco> [exa], because it will become more useful faster than we understand it
05:59:23 <[exa]> erisco: and so?
05:59:27 <erisco> [exa], and there will be the incentive to have it handle substantial responsibilities
05:59:39 <ggVGc> maerwald: I've been sahying this my entire career. I hate the term computer engineer, and I'm fairly certin it's a PR ploy by the universities. My grandather was an engineer, and it's very clear to me that the software world is in no way even aware of what it actually means to work as an engineer
05:59:41 <erisco> because humans cost too much, and this AI stuff is smarter anyways
05:59:52 <ggVGc> most software developers have no concept of standardized processes etc.
05:59:56 <ggVGc> which is what engineering is all about
06:00:12 <ggVGc> of risk managements
06:00:39 <[exa]> erisco: there's still the evolution thing working; I wouldn't worry that much
06:00:42 <ggVGc> and it's now becoming really dangerous that software developers call themselves engineers
06:00:47 <ggVGc> and others believe they are engineers
06:00:51 <erisco> right, so I am both a computer scientist and a software engineer, but not actually a scientist or an engineer
06:00:58 <ggVGc> exactly
06:01:24 <ggVGc> softwre developers are among the least unscienfitic people I know
06:01:25 <maerwald> ggVGc: the safety standards for automotive embeded programming and so on have a checklist of methods. There is ++ (you need a vey good reason to not use it) and + (you can just say "not applicable"). Formal methods has a +, so pretty much everyone in the industry ignores it. It would just take a minor step to make this ++ and suddenly most projects would be forced to do it
06:01:29 <ggVGc> it's way closer to art
06:01:33 <erisco> [exa], the evolution thing where the weak die and the strong prevail?
06:01:34 <maerwald> industry would boost the whole area, because they depend on it
06:01:58 <maerwald> otherwise they don't get certified
06:02:33 <ggVGc> I obviously meant "the least scientific"
06:02:34 <ggVGc> anyway
06:02:40 <ggVGc> yeah, I'm fairly bothered about this
06:02:51 <ggVGc> in my last job interview they asked "why do you just call yourself a programmer?"
06:02:54 <ggVGc> and I was glad they asked
06:03:13 <maerwald> did you get the job? xD
06:03:38 <maerwald> when you go full rant :>
06:03:59 <ggVGc> yes I did
06:04:02 <ggVGc> but I just quit
06:04:15 <ggVGc> it wasn't very spectacular
06:04:31 <ggVGc> I'm making android-based infotainment stuff for trucks..
06:05:02 <maerwald> I think all programmers should quit
06:08:46 <olligobber> I made a bad type: (Double -> Boolean) -> Integer -> [PointImp] -> [PointImp] -> [PointImp]
06:09:09 <olligobber> where PointImp = ((Double, Double, Double), Integer)
06:09:16 <olligobber> I feel bad
06:09:52 <erisco> try records
06:10:42 <erisco> ggVGc, I am going to be experimenting with the idea of not being thrilled about work but getting on with life anyways
06:11:32 <erisco> ggVGc, because I think trying to caress "interesting" into "work" has given me misery
06:11:36 <[exa]> erisco: no, where the environment changes drive out the non-fit
06:11:48 <[exa]> (dinosaurs were strong, weren't they)
06:12:05 <erisco> they use the word "fit", I used the word "strong"
06:12:23 <ggVGc> erisco: yeah that's fair, but the reason I quit is because I was hired by a consultant agency, which means I have no career path either
06:12:43 <ggVGc> so, if I end up being employed again, it'll be at a product company
06:13:13 <[exa]> erisco: the meaning is completely different though
06:13:16 <ggVGc> if I'm doing consultant work, I'd rather be self employed as I have been the past years
06:13:20 <[exa]> nvm
06:14:18 <erisco> [exa], weak and strong just made for a more dramatic comparison than unfit and fit ;)
06:14:55 <[exa]> erisco: I kindof wanted to know what's to fear about AIs
06:15:39 <erisco> [exa], well, pick something that sounds important, and then imagine wiring up a black box to control it that no one understands
06:16:08 <[exa]> so the 'collateral damage' before someone cleans the stuff after the blackbox?
06:16:20 <[exa]> (incl. the blackbox)
06:17:49 <erisco> which will be tragic, and hopefully the worst of it, but possibly we can't tell damage is being done, or if we can then we might not know why
06:18:07 <[exa]> erisco: what country do you live in?
06:18:12 <erisco> Canada
06:19:40 <erisco> there are so many things we do not understand… it is difficult to see the way it could happen but also difficult to see the way it couldn't… but there are more patterns than we know about
06:19:47 <[exa]> you might want to pay a visit to e.g. western africa or some similar territory, to correctly relativize the meaning of tragic
06:20:33 <erisco> I don't think any tragedy is out of reach
06:21:40 <[exa]> what I wanted to say, there will be trouble as with each technology (remember the jets with comet disaster) but that's just the price for people being incompetent
06:22:15 <[exa]> just by learning haskell you're probably kindof helping it, so that when the time comes you won't hack the blackbox in C or what. :D
06:22:50 <erisco> I don't know if it is so simple as "pulling the plug"
06:23:05 <erisco> comet was the one they sent back up after failing to figure out the problem, right?
06:23:08 <erisco> then it exploded, again
06:23:19 <Hafydd> That's just good science.
06:23:24 <Hafydd> Repeat the experiment to make sure.
06:23:30 <[exa]> :]
06:23:45 <erisco> well why did they do that? because we weren't about to stop having jet travel
06:24:01 <erisco> we keep having financial crises with stock markets and economies and whatnot
06:24:11 <erisco> well why do we keep doing that? because we aren't about to stop having these trading systems
06:24:50 <olligobber> no one noticed I wrote Boolean instead of Bool :P
06:25:12 <[exa]> olligobber: advanced AIs auto-fixed that for you :D
06:25:14 <erisco> so when we start using something we're going to quickly acclimate to the world where we *need* it
06:25:43 <[exa]> if we didn't need it, why would we use it in the first place?
06:25:58 <[exa]> except for toys and so
06:26:07 <erisco> hence when something goes wrong it isn't as simple as "stop using it"
06:26:39 <[exa]> you need to actively make it obsolete instead, yeah
06:26:40 <erisco> instead we'll be trying to patch it while the system is still running, fingers crossed and hoping for the best
06:27:06 <erisco> and AI just enables us to put even more into the trust of systems we do not understand
06:27:50 <erisco> minds that will do the thinking of a lifetime in a week, on a single chip
06:28:09 <maerwald> AI is only mildly relevant for security
06:28:51 <erisco> communicating over a global network
06:29:24 <maerwald> the main problem of insecurity has been formally described by LANGSEC and AI cannot help with that problem
06:29:44 <maerwald> trustworthy systems is the best we have there
06:30:08 <maerwald> https://ts.data61.csiro.au/projects/TS/
06:30:54 <maerwald> expanding the term trustworthy to what you mean though seems reasnoable
06:31:00 <maerwald> so it entails even more than security and safety
06:31:52 <trigone> hi! in this talk (which i only superficially understand) https://www.youtube.com/watch?v=Bxcz23GOJqc edwardk says there are perf issues with class-based monad transformers, esp apparently when recursion is involved. is it (still) true? will it be optimized in the future? what's the solution? is it really a big deal? how does it compare perf-wise to using a free monad based style (with ADTs)?
06:31:54 <maerwald> (safety as in: within specified environment)
06:35:17 <bbear> hello
06:35:23 <bbear> I got something weird here
06:35:43 <bbear> ha forget it
06:37:54 <trigone> just found this thing, claims to be more flexible than mtl (https://github.com/feuerbach/monad-classes). anyone knows of it?
06:39:44 <hawnzug> Hi, I encountered an error when using stack to install ghcid on Arch Linux. Error message here: http://lpaste.net/358314
06:40:03 <hawnzug> Does anyone know about it?
06:40:58 <erisco> [exa], I wasn't concerned until I realised how carelessly we're going to apply the technology
06:41:57 <erisco> initially I felt fine because an infinite genius trapped in a box can't have any effect on the outside
06:42:10 <erisco> i.e. intelligence alone is not a super power to start breaking the laws of physics
06:42:40 <erisco> so, just don't give the thing machine guns for arms and we'll all be okay
06:42:59 <maerwald> machine guns break the laws of physics?
06:43:31 <maerwald> only if yielded by a scientist I guess?
06:44:03 <erisco> but now I see this is irrelevant, because we're not smart enough to keep things contained… the intelligence doesn't have to escape… we're going to let it out :P
06:44:43 <erisco> so, fundamentally, no, I don't fear this sort of black hole thing where suddenly sky net happens because the computer got too smart
06:45:23 <erisco> but if we connect this computer to a bunch of other computers and say "hey you fly all our airplanes now" then I can see the potential for problems
06:46:21 <Tuplanolla> Are we talking about those programs that just learned to play board games?
06:46:38 <maerwald> I think we are already talking about terminators
06:46:44 <erisco> am I worrying about overpopulation on Mars? :P
06:47:00 <maerwald> and whether terminators are programmed in haskell
06:47:21 <trigone> the matrix is written in haskell that's for sure :P
06:47:41 <maerwald> with all those memory errors?
06:48:17 <erisco> agent Smith exploited all those side channel attacks due to Haskell being too high level…
06:48:21 <trigone> neo has access to unsafePerformIO ^^
06:49:00 <erisco> one pill is return, the other is unsafePerformIO, which do you choose?
06:49:15 <trigone> erisco: what are those side channel attacks things? is haskell found to be an unsafe language regarding cracking?
06:50:00 <olligobber> my code was infinite looping until I added two $ to it
06:50:13 <[exa]> maerwald: "yielded by scientist" lol
06:50:22 <erisco> trigone, the idea with a side channel attack is you can gain information on a system by analysing another system affected by it
06:50:22 <olligobber> apparently sort x++y does (sort x)++y
06:50:23 <trigone> olligobber: well nothing's free in life or programming
06:50:31 <erisco> I am sure there is a more rigorous meaning, but that is my gist of it
06:50:41 <maerwald> trigone: you cannot even reason properly about performance in haskell, even less about timing or even memory
06:50:45 <trigone> erisco: what would be either systems in practice?
06:51:06 <Tuplanolla> Watch this, trigone: https://media.ccc.de/v/33c3-8044-what_could_possibly_go_wrong_with_insert_x86_instruction_here
06:51:12 <[exa]> erisco: you sortof implying centralization of responsibilities to single AI, that is never a good idea even without AIs
06:51:16 <erisco> trigone, you can look at CPU time, for example
06:51:44 <trigone> maerwald: but you can reason about functionality. in most other languages it's the opposite: you can control memory and time but you have no guarrantee of what is gonna happen when you run the program
06:52:01 <maerwald> trigone: that's an exaggeration
06:52:44 <erisco> trigone, so if the CPU time the process takes varies by what you input to the program, that might tell you something about what is happening in the program
06:53:18 <Tuplanolla> Security is a platform property, so security depends completely on observable properties, trigone.
06:53:36 <maerwald> trigone: actually in C you have pretty accurate guarantees, given by the standard. Since most haskell programs are GHC-isms, you basically don't even have that anymore
06:53:54 <trigone> erisco: and that's a weak point for haskell? i'm surprised
06:54:01 <maerwald> because now the behavior depends on underspecified GHC extensions
06:54:12 <erisco> yes, absolutely
06:54:18 <trigone> maerwald: i kinda disagree
06:54:19 <Tuplanolla> I don't think any of the C standards talk about time, maerwald.
06:54:29 <maerwald> Tuplanolla: I didn't say they do
06:54:43 <maerwald> but saying you cannot reason about functionality in e.g. C is plain wrong
06:54:45 <erisco> lets say you had a program that does  x == "swordfish"  to see if the entered password matches
06:54:50 <Tuplanolla> Indeed.
06:54:59 <erisco> well, how is string compare done? it shorts on the first mismatch
06:55:05 <erisco> so the more characters you get right, the longer the program takes
06:55:46 <erisco> now suddenly the task of finding the password is much easier, because you can get one character right at a time
06:55:54 <trigone> maerwald: you can but it's harder, i'd say way harder. moreover you won't know if there's a bug until someday something goes wrong. at least in haskell you know what you don't know most of the time
06:55:54 <maerwald> trigone: there is nothing to disagree on, it's a fact :>
06:56:10 <erisco> to hide this you have to take as much time rejecting the password as accepting it
06:56:17 <maerwald> you mean there are no space leaks in haskell due to laziness? :>
06:56:23 <trigone> erisco: hm so it's a laziness issue
06:56:28 <erisco> no
06:56:29 <maerwald> sheesh
06:56:39 <maerwald> exaggeration, as I said
06:56:44 <erisco> string equality is programmed like this in many strict languages
06:57:04 <maerwald> strongly typed languages are useful, seperation of effects too, but that doesn't mean haskell solves all bugs or reasoning problems
06:57:14 <maerwald> in fact it introduces new ones too
06:57:41 <trigone> maerwald: so in the end do you like haskell at all?
06:57:49 <trigone> erisco: so why's it worse in haskell?
06:57:52 <maerwald> is this about feelings? :>
06:58:01 <trigone> maerwald: nvm
06:58:22 <Tuplanolla> It seems that you completely missed the point, trigone.
06:58:25 <erisco> trigone, maerwald was simply saying that higher level languages do not give you guarantees about how many CPU cycles are consumed
06:58:56 <Tuplanolla> I must repeat that "security is a platform property", trigone.
06:59:08 <erisco> and others were saying this is not necessarily so, and then maerwald agreed but asked for any high level languages which *do* have this feature
06:59:11 <trigone> well i never said it was untrue, i said you gained the ability to reason about code more easily, at least in my opinion
06:59:26 <trigone> Tuplanolla: yeah but i don't understand that sentence ^^
06:59:29 <erisco> to which there was a stunning silence… at least that is my memory of recent past
06:59:39 <trigone> erisco: oh ok
07:00:09 <maerwald> erisco: I think the closest is really a transpiler, but even then you would carry out correctness proof on the resulting C/ASM code, binary
07:00:20 <Tuplanolla> It means that your reasoning at the language level may be meaningless if they tell you nothing about how the platform actually behaves, trigone.
07:00:26 <maerwald> that's roughly what F* developers are trying too
07:00:30 <maerwald> not sure how far they got
07:00:52 <trigone> Tuplanolla: in concrete terms, what's the platform?
07:01:25 <Tuplanolla> Everything from the hardware up, trigone.
07:01:39 <Tuplanolla> If you watch that talk I linked, you'll see why.
07:02:15 <Tuplanolla> Here's another good example: http://www.tau.ac.il/~tromer/acoustic/
07:02:55 <trigone> Tuplanolla: i'm not sure i'm gonna be able to understand much about the talk, though it looks very interesting and i'll definitely try watching it later 
07:04:09 <erisco> using squeals of capacitors for hacking? amazing
07:04:22 <erisco> reminds me of listening for hard drive seeks…
07:04:30 <erisco> never a mystery when your computer goes to disk :P
07:04:55 <Hafydd> I can usually tell when it's midnight by when my PC starts some scheduled taskss.
07:05:08 <erisco> so, you look at these very nonobvious and sophisticated patterns, and then wonder how much of the world we are not seeing
07:05:10 <Hafydd> I used to use it to get out of bed for a regular meeting.
07:05:16 <maerwald> Hafydd: you're part of a botnet?
07:05:23 <erisco> what is so plainly obvious, so plainly transmitted to us, but we cannot perceive it
07:05:38 <erisco> can be as simple as other colours of light or smells
07:05:40 <Hafydd> maerwald: I hope not.
07:06:07 <Tuplanolla> Here's another fun one, trigone: https://en.wikipedia.org/wiki/Row_hammer
07:06:14 <Myrl-saki> I never realized this
07:07:07 <Myrl-saki> But I could have used HVect for (heterogenous) dependently-typed vectors, right?
07:07:10 <Myrl-saki> Err
07:07:12 <Myrl-saki> homogenous*
07:07:35 <erisco> well this language does not have dependent typing, so that seems suspect
07:07:51 <Myrl-saki> erisco: I mean
07:08:02 <Myrl-saki> erisco: Faking using GADTs. :P
07:08:04 <Myrl-saki> And some other things.
07:09:21 <erisco> Tuplanolla, that is pretty amazing that you might nick someone's key during a lecture
07:09:37 <erisco> that's an hour, and proximity to their laptop for the duration
07:11:15 <erisco> and I bet no one is thinking their magic box of wires is broadcasting their deepest secrets out to the world :P
07:11:33 <erisco> only to those who know how to listen
07:11:59 <Tuplanolla> It's easier to read it from their Facebook pages.
07:12:23 <trigone> Tuplanolla: nothing is secure in CS it seems :) i kinda wonder how easy it is to actually implement these exploits given the mass of variables that you either need to know or control... like are those exploits only observed in laboratories or are they a real potentail security risk?...
07:12:54 <erisco> hehe
07:13:37 <Tuplanolla> They're definitely practically possible, but very expensive to carry out properly, trigone.
07:13:49 <erisco> I remember a few years back watching a video on a hack using keyboard audio
07:13:56 <erisco> because different keys make slightly different noises
07:14:18 <[exa]> trigone: did you see the "$10 microphone listens to RSA all the way through conference room?" paper
07:16:15 <trigone> [exa]: no, but it's quite impressive... are there parallel advances in securing systems better? aka countering all those exploits?
07:16:26 <erisco> and there is the classic movie hack of looking at the keypad in infrared or contaminating the victim's fingers with some residue
07:17:13 <[exa]> trigone: people try hard
07:17:21 <Tuplanolla> Security is all about the return of investment, trigone. For targeted attacks it's very poor and that's why people are more worried about things like mass surveillance.
07:17:55 <erisco> I'll wager that people are usually the weak point
07:18:13 <Tuplanolla> That too.
07:18:56 <trigone> Tuplanolla: so it's easier to protect from relatively weak massive spying than it is to protect yourself when you're the only target? makes sense
07:19:46 <trigone> can you write security tools in haskell or is it a bad choice?
07:20:03 <tdammers> depends on the kind of tool
07:20:36 <trigone> tdammers: well you tell me
07:20:43 <tdammers> the GC introduces a number of issues that are easier to address in languages with manual memory management
07:21:03 <tdammers> it also makes it hard to tell what is currently still in memory and what isn't
07:21:22 <tdammers> so defending against attacks that rely on scanning local memory is pretty hard
07:21:32 <tdammers> then again, it's hard to do that in *any* language, garbage collected or not
07:21:57 <erisco> I am going to guess that if they get to put probes on your board that you're in trouble
07:22:07 <trigone> tdammers: hm...
07:22:08 <tdammers> timing is another issue - performance characteristics of a Haskell program are hard to reason about, so it's more difficult to defend against timing-based side channel attacks
07:22:26 <trigone> erisco: physical probes or softwares?
07:22:43 <tdammers> erisco: I was thinking more of attacks where you exploit a vulnerability elsewhere that allows you to access the image of another process
07:23:19 <tdammers> but then, if your system has such vulnerabilities and they are being exploited, then you're pretty much fucked anyway, aren't you
07:23:20 <erisco> so you'd have to find a hole in the OS or CPU I'd hope, because memory should be protected
07:23:31 <tdammers> yes
07:23:41 <tdammers> or in the GHC runtime, or in some C library you use
07:23:43 <Ferdirand> i remember seeing a crackme written in haskell, at some CTF
07:23:57 <Ferdirand> reversing the binary was a total nightmare
07:24:07 <tdammers> on the upside, haskell's type system makes it very easy to avoid certain common pitfalls
07:24:07 <hpc> haha
07:24:28 <Ferdirand> but pintool broke it in a few minutes because it was using a string compare vulnerable to instruction counting
07:24:56 <tdammers> Ferdirand: side channel attack?
07:25:03 <trigone> how did you all learn about CS security? at the university or in books or on the net? are there good books/websites out there to start on that?
07:25:45 <erisco> Ferdirand, are you saying my string compare example earlier was actually relevant to a real hack? heh
07:25:47 <tdammers> I used to work at an infosec shop
07:25:53 <hpc> trigone: personally, by seeing what the common exploits are and what they have in common
07:26:01 <hpc> and extrapolating from there
07:26:09 <tdammers> a large part of my job was auditing code for security issues, and fixing them
07:26:16 <Tuplanolla> Read books and articles, watch conferences and instruct on courses, trigone.
07:26:34 <Tuplanolla> It has mostly happened by accident.
07:26:36 <tdammers> anyway, good starting points are OWASP and security stackoverflow
07:26:57 <tdammers> and in fact, most attacks boil down to the same handful of concepts
07:27:54 <hpc> the three big ones are "can i make the system do something stupid?", "can i monopolize the system?", and "can i tell what the system is doing"
07:28:57 <trigone> hm sounds pretty logical indeed
07:29:35 <hpc> unless you are writing something that stores particularly important information, you usually only ever need to deal with the first question
07:29:56 <hpc> just to prevent your servers from joining a botnet
07:30:04 <trigone> hpc: what's a botnet?
07:30:06 <erisco> one of us
07:30:10 <hpc> one of us
07:30:18 <Tuplanolla> One of us.
07:30:28 <trigone> so what does it mean? and you're being creey :P
07:30:32 <hpc> ^.^
07:30:39 <trigone> creepy*
07:30:54 <tdammers> a botnet is a network of compromised machines that can be controlled in concert through some sort of command-and-control system
07:31:07 <Tuplanolla> Exactly what it says on the tin: a net of bots.
07:31:09 <erisco> a fun one I read about was a possible worm to attack Parse.com
07:31:13 <hpc> the botnet will do things like steal CPU time for mining bitcoin
07:31:18 <tdammers> typical uses are spamming and DDoS attacks
07:31:19 <hpc> or send spam, or whatever
07:31:35 <hpc> anything you wouldn't want to use your own servers for
07:31:41 <trigone> oh right, using other computers as hosts?
07:31:46 <hpc> yeah
07:31:48 <erisco> because Parse.com allows you to run code on their cloud, for free, and because this code has access to the outside world…
07:32:28 <erisco> you could, in theory, make a worm that eats all of Parse.com by registering new accounts and installing itself to those accounts, recursively
07:36:06 <erisco> but why is that called a worm and not an ouroboros?
07:37:43 <trigone> are there good apps written in haskell out there which have a very concrete functionality, which are very well written and which i could study? i'd prefer if they were not too big but not too small, for obvious reasons...
07:37:51 <hpc> pandoc
07:39:23 <trigone> erisco: the ouroboros doesn't reproduce or infects, it merely eats itself. it's a bit #!/bin/rm or something. the notion of virus would be closer, but actually i'm not sure of the official difference bwn worms and viruses...
07:39:51 <trigone> hpc: i'll look into it thx! :)
07:40:06 <erisco> maybe "worm" is meant to evoke "parasite"
07:40:15 <trigone> btw are there ever graphical programs written in haskell?
07:41:07 <trigone> erisco: lol they could have been called xenomorphs...
07:41:09 <Ojd> Virus need a host
07:41:20 <trigone> Ojd: worms don't?
07:41:22 <erisco> but virus are not alive
07:41:35 <Ojd> Worms don't
07:42:06 <trigone> erisco: measuring life is pretty arbitrary. and computer viruses aren't alive either anyway
07:42:26 <trigone> Ojd: really so how do they work without a host?
07:42:30 <tdammers> a virus reproduces by injecting its DNA into a host cell, reprogramming it to produce virus material; a computer virus injects itself into an executable, modifying it to reproduce the virus by injecting it into other executables
07:42:47 <Ojd> So the virus attach themself to some existing file and they deliver the payload once such file is executed
07:43:01 <tdammers> a worm doesn't attach itself to other binaries, it is a standalone binary that copies itself onto the target system and somehow hooks itself into it so that it gets executed
07:43:21 <trigone> oh ok, host at the software level. i was thinking computers as hosts
07:43:31 <Ojd> Tdammers just provide a better definition
07:43:46 <erisco> this has been computer biology with tdammers
07:43:49 <Ojd> :)
07:43:56 <tdammers> there's also trojans, which rely on the *user* to actively execute them
07:44:08 <erisco> allow or deny?
07:44:31 <trigone> allow or deny what?
07:44:33 <erisco> train users to click the "allow" button without thought, that'll work
07:45:13 <trigone> oh right
07:46:23 <Ojd> I am a bit late in the conversation, why are we talking about this?
07:46:41 <JuanDaugherty> dummy ass shit about malware folk names
07:46:43 <Ojd> (it's a very interesting subject for me though)
07:48:33 <trigone> is pandoc using the arrow-based parsing strategy?
07:49:15 <erisco> what do you call a virus that infects both humans and computers?
07:50:01 <trigone> erisco: do you have an example at hand? and is that the start of some bad pun-based joke?
07:50:12 <erisco> a meme
07:50:51 <trigone> erisco: what's the punch line?
07:50:53 <erisco> we're kinda the rats in this plague, though… sorry computers
07:52:02 <sm> trigone: there have been some haskell programs with GUIs, but not many. Most use a web, text or command-line UI instead
07:52:38 <trigone> sm: why is that? does it mean that tools to write guis in haskell are bad (bc not much demand for it)?
07:52:51 <sm> GUI frameworks are a big headache, and extremely costly to build
07:53:05 <sm> but we do have several
07:53:20 <trigone> costly in what sense?
07:53:21 <erisco> trigone, it is agonisingly funny if you know where "meme" originates
07:53:32 <sm> time, effort, know-how
07:53:53 <trigone> erisco: oh got it
07:54:06 <trigone> erisco: not bad :)
07:54:45 <trigone> sm: well yeah but if you want to/have to write a GUI app the cost is pretty much irrelevant right?
07:55:17 <sm> actually, we don't have GUI frameworks in haskell; we have haskell bindings to several well-established GUI frameworks
07:55:33 <StrangeLoop> Hi, I have this file which contains only the line of code "main = (\x z -> x ++ z) <$> getLine <*> getLine". When I run it nothing happens. If I copy whatever's after the equality sign to ghci it works as expected, what am I doing wrong here?
07:55:36 <sm> SDL, GTK, wxwindows, FLTK
07:55:43 <sm> GLUT
07:55:45 <trigone> sm: but do they work without trouble?
07:55:55 <sm> don't be silly :)
07:56:09 <erisco> :t (\x z -> x ++ z) <$> getLine <*> getLine
07:56:11 <lambdabot> IO [Char]
07:56:19 <erisco> StrangeLoop, I do not believe your program. That doesn't type check
07:56:31 <StrangeLoop> Yeah, it expects imput
07:56:36 <StrangeLoop> *input
07:56:39 <erisco> no, main :: IO ()
07:57:00 <erisco> how did you compile your program and what is the exact source file? use lpaste.net
07:57:06 <sm> trigone: just kidding. The answer will is no. But fltkhs is probably relatively low trouble
07:57:47 <trigone> sm: what's fltk? is is good?
07:57:55 <sm> yes. old but good
07:58:56 <trigone> erisco: i heard recently main allowed other type parameters than (), just kinda silently, probably, added >> pure () or sth
07:59:48 <erisco> are you telling me Haskell has C mains?
07:59:49 <trigone> sm: hm ok. if it is a binding to that library, does it mean that to make the resulting hs binary work, you gotta have that library installed already?
07:59:55 <trigone> erisco: dunno
08:00:09 <StrangeLoop> erisco: I just ran "ghc foo.hs" no irregular output. I get "foo.exe" which gets two inputs and then terminates
08:00:22 <sm> trigone: yes that's the case for all of these
08:00:40 <erisco> so, it compiled? … time to dig out the report
08:01:01 <erisco> StrangeLoop, if it did compile then yes, that is what I'd expect it to do… read two lines and then terminate. What did you want it to do
08:01:06 <trigone> sm: hm ok... how much is this library widespread? and how much are the other bindings buggy?
08:01:24 <sm> there is also gloss, that's a pure haskell GUI framework (though limited)
08:01:27 <StrangeLoop> erisco: to print the concatenated line, as it does on ghci
08:01:33 <erisco> believe it or not but I haven't used IO in Haskell :P
08:01:51 <trigone> erisco: well when you use ghci, presumably it automatically prints the IO[Char] to console
08:02:22 <erisco> StrangeLoop, so you'll want to putStrLn then
08:02:35 <trigone> sm: hm ok... what about TUI (terminal-based UI), are there good ones out there for haskell?
08:02:45 <StrangeLoop> I tried that, gets a compile error
08:02:53 <sm> why yes, brick is an excellent TUI lib
08:03:01 <erisco> probably didn't type check… fix it :)
08:03:14 <trigone> sm: hm i heard of it, i'll look into it :)
08:03:22 <StrangeLoop> https://pastebin.com/USyQ45RA
08:03:24 <trigone> sm: thx!
08:04:02 <erisco> StrangeLoop, use lpaste.net please
08:04:31 <erisco> also, look at the type of putStrLn and the type of the thing you're applying it to
08:05:14 <sm> ps I don't say our GUI lib bindings are buggy, just that there will be headaches, mainly about setup and lack of maintenance. Also the situation is different if you want to deploy GUI apps to users, vs just building one for yourself
08:06:02 <sm> trigone: also, I'm biased but I could suggest hledger as another concrete haskell app
08:07:08 <trigone> sm: i'll look into it too! :) how big is your app?
08:08:49 <erisco> it is not obvious to me where the report talks about the type of main, if it does at all… because I found numerous instances of it using main without a type declaration
08:09:54 <sm> trigone: the CLI is about 11k lines
08:10:24 <Hafydd> https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-980005 "The value of the program is the value of the identifier main in module Main, which must be a computation of type IO τ for some type τ (see Chapter 7)."
08:10:33 <trigone> hm ok. it's the main part of your app?
08:10:58 <trigone> "When the program is executed, the computation main is performed, and its result (of type τ) is discarded. "
08:11:21 <erisco> in the modules chapter... yeah... not obvious
08:11:36 <tdammers> τ... bonus points for Greek letter there...
08:11:59 <erisco> fascinating, so as long as it is tau, you're good
08:12:15 <Hafydd> The modules chapter is referenced from https://www.haskell.org/onlinereport/haskell2010/haskellch1.html#x6-100001.1 "Program Structure", which is the obvious place to look for information about a top-level feature.
08:12:35 <erisco> the obvious places are everything on IO
08:13:01 <Hafydd> Perhaps you should revise your heuristics.
08:13:05 <erisco> I did skim program structure but didn't see the relevant link… and even knowing where it is now… still not obvious
08:13:27 <erisco> no I think my heuristics worked brilliantly
08:13:47 <Hafydd> What do you mean? You failed to find what you wanted, and I succeeded.
08:13:55 <erisco> then you told me
08:14:10 <Hafydd> I would consider asking in #haskell to be outside the domain of discourse.
08:14:17 <trigone> lol
08:14:36 <erisco> ah, I see, then I failed miserably, you win ;)
08:16:54 <StrangeLoop> OK, so apparently my editor was a bit misleading. Anyway, it works like this: http://lpaste.net/1379041087380783104 but I wonder, is there a way to get rid of naming a?
08:17:40 <erisco> do x <- getLine; z <- getLine; putStr (x ++ z) -- is perhaps a more natural way to write it
08:18:31 <StrangeLoop> That doesn't count! I now replace naming one point by naming two points!
08:18:56 <erisco> well, so what, you have  \x z -> x ++ z  which has two points
08:19:12 <erisco> you could eta reduce this twice to (++) but then I can't make the argument ;)
08:19:13 <StrangeLoop> erisco: I just put a lambda there so there would be something, it could be any function
08:19:48 <erisco> it would be nice if liftM2 was useful and joined on the end
08:19:51 <Hafydd> Why not just "putStr =<< (++) <$> getLine <*> getLine"?
08:20:10 <Tuplanolla> @pl ((\ x z -> x ++ z) <$> getLine <*> getLine) >>= putStr
08:20:11 <lambdabot> putStr =<< (++) <$> getLine <*> getLine
08:20:19 <Hafydd> Ohoho.
08:21:09 <hexagoxel> automate the whole path!
08:21:11 <hexagoxel> @@ @pl @undo do { a <- (\x z -> x ++ z) <$> getLine <*> getLine; putStr a }
08:21:11 <lambdabot>  putStr =<< (++) <$> getLine <*> getLine
08:21:55 <StrangeLoop> OK, I wasn't aware of =<< but it seems to do exactly what wanted, thanks
08:22:39 <Hafydd> Alternatively, "(++) <$> getLine <*> getLine >>= putStr".
08:23:10 <trigone> @pl (\x f -> f x x)
08:23:10 <lambdabot> flip =<< flip id
08:23:42 <tdammers> .oO( @pl can be pretty evil )
08:24:30 <erisco> just use join
08:25:32 <Hafydd> Of course, it is behaviourally equivalent to "getLine >>= putStr >> getLine >>= putStr".
08:25:44 <Hafydd> Oh... well, not quite.
08:25:44 <erisco> :t \x f -> f x x
08:25:46 <lambdabot> t1 -> (t1 -> t1 -> t) -> t
08:25:48 <erisco> :t flip join
08:25:49 <lambdabot> b -> (b -> b -> c) -> c
08:25:57 <erisco> see, @pl isn't always a genius
08:26:16 <trigone> erisco: indeed
08:26:27 <pierrot> Hi. An expression like this one 1 : [2,3] ++ [4,5] is reduced like 1 : [2,3,4,5] or like [1,2,3] ++ [4,5] ?
08:27:10 <Hafydd> pierrot: (:) and (++) are both infixr 5.
08:27:12 <erisco> well both operators are infixr 5
08:27:22 <Hafydd> So it's the former.
08:27:46 <trigone> erisco: how do you manage the reader monad? i have trouble keeping the intuition of how monadic operators work with it...
08:28:00 <pierrot> thanks Hafydd and erisco 
08:28:15 <StrangeLoop> Hafydd: You can always use :i to check infix precedence of stuff
08:28:24 <StrangeLoop> Sorry, I meant pierrot 
08:28:29 <Hafydd> Although the evaluation doesn't happen like that, as you may know. It occurs lazily.
08:29:13 <Hafydd> So it's more like 1 : ([2,3] ++ [4,5]), where the tail of that expression is evaluated when needed.
08:30:10 <pierrot> Thank you for clarifying.
08:30:42 <erisco> trigone, I am not sure, I guess it depends on what you're looking to understand about it
08:31:51 <trigone> well i just would never have recognized flip join in the lambda of above
08:32:07 <trigone> at least not without actively seeking it or sth
08:32:29 <erisco> how is that related to Reader?
08:32:35 <Hafydd> :t \f x -> f x x
08:32:37 <lambdabot> (t1 -> t1 -> t) -> t1 -> t
08:33:06 <Hafydd> That is join for the (r ->) monad.
08:33:10 <erisco> I knew it was  flip join  because I know  f x x  from memory is join, nothing special on my part
08:33:25 <trigone> erisco: i call informally (r ->) the reader monad
08:34:05 <Hafydd> Tee one to tee one to tee... to tee one to tee.
08:34:22 <trigone> erisco: oh ok
08:34:29 <trigone> Hafydd: eh?
08:34:35 <trigone> oh lol got it
08:34:46 <Hafydd> %D
08:35:18 <Hafydd> I can imagine someone saying that out loud, and passer-by thinking they're having a seizure.
08:35:20 <erisco> but that is how you'll internalise it when you look at it a lot
08:35:28 <erisco> you just remember it, and you use brain power for other things
08:35:33 <trigone> lol that was my first thought too
08:44:24 <erisco> :t (<**>) id
08:44:26 <lambdabot> (a -> a -> b) -> a -> b
08:44:40 <erisco> also comes off the top of the head
08:47:07 <Hafydd> :t (<*> id)
08:47:09 <lambdabot> (a -> a -> b) -> a -> b
08:47:32 <hpc> :t (<**>)
08:47:33 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
08:47:45 <Hafydd> (<**>) = flip (<*>)
08:47:53 <hpc> oh, dur
08:49:20 <rotaerk> (<***>) = flip (<**>); (<****>) = flip (<***>)
08:49:23 <rotaerk> am I doing this right?
08:49:25 <Hafydd> Hahah.
08:50:03 <ahihi> (<*>) = flip (<>)
08:50:19 <rotaerk> d'oh
08:52:52 <erisco> just remember pure = return = const = \x y -> x  and  (<*>) = (=<<) . flip = \f g x -> f x (g x)
08:54:27 <Hafydd> Now you're equipped to be an emergency stand-in for @pl in case lambdabot is down.
08:54:38 <monochrom> @type (=<<) . flip
08:54:40 <lambdabot> (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
08:54:49 <monochrom> Interesting.
08:54:56 <erisco> or just more directly remember  (>>=) = \g f x -> f (g x) x
08:55:33 <erisco> and (=<<) = \f g x -> f (g x) x
08:55:55 <erisco> the latter probably being easier since you can just imagine f swapping arguments
08:56:20 <idontdie> Just diving into functional programming. What's the most recommended resource for learning haskell? Or is that a question for another channel?
08:56:33 <erisco> armed with these shapes you can think of fun stuff
08:57:07 <erisco> :t (>>=) id -- for example, this obviously works too
08:57:09 <lambdabot> (a -> a -> b) -> a -> b
08:58:56 <erisco> your reader monad is no more interesting than your reader applicative
09:00:11 <erisco> monochrom, where are my manners... clearly should have said  fmap (=<<) flip  heh
09:00:46 <erisco> :t [(<*>), fmap (=<<) flip] -- also fun
09:00:47 <lambdabot> [(a1 -> a -> b) -> (a1 -> a) -> a1 -> b]
09:02:13 <monochrom> Did you see my "null (void Nothing)" yesterday? :)
09:02:43 <erisco> no, I did not
09:02:45 <[exa]> now THAT is a negative approach.
09:03:08 <monochrom> Ah but it has a silver lining.
09:03:15 <monochrom> > null (void Nothing)
09:03:17 <lambdabot>  True
09:03:30 <erisco> [(<*>), (=<<)] I guess is the more interesting example… I just thought it was fun how that type is figured out
09:03:46 <erisco> since you are unifying  f (a -> b) -> f a -> f b  with  (a -> m b) -> m a -> m b
09:04:06 <monochrom> haha neat.
09:04:21 <monochrom> Also of interest: void null
09:05:02 <hpc> :t [(<*>), (=<<)]
09:05:03 <lambdabot> [(a -> a -> b) -> (a -> a) -> a -> b]
09:07:17 <erisco> > void Just Nothing
09:07:19 <lambdabot>  ()
09:08:39 <monochrom> @type void Just
09:08:41 <lambdabot> a -> ()
09:08:48 <monochrom> Ah.
09:09:08 <erisco> it maps the return type to unit :)
09:09:45 <rdococ> @type yay
09:09:46 <lambdabot> error: Variable not in scope: yay
09:10:03 <rdococ> what is the "Just" datatype anyway?
09:10:13 <hpc> @src Maybe
09:10:14 <lambdabot> data Maybe a = Nothing | Just a
09:10:16 <hpc> :t Nothing
09:10:17 <lambdabot> Maybe a
09:10:17 <hpc> :t Just
09:10:18 <lambdabot> a -> Maybe a
09:10:19 <rdococ> ag
09:10:20 <rdococ> ah
09:10:44 <hpc> it's one of my favorite types
09:12:34 <rdococ> @drc Either
09:12:34 <lambdabot> Maybe you meant: src rc
09:12:37 <rdococ> @src Either
09:12:37 <lambdabot> Source not found. I am sorry.
09:13:13 <[exa]> wut
09:13:33 <barrucadu> src is a hand-curated list, I believe
09:13:44 <rdococ> ah
09:13:57 <[exa]> rdococ: anyway its something like data Either l r = Left l | Right r
09:14:28 <rdococ> makes sense
09:14:31 <hpc> src is also not the whole truth in a few places
09:14:34 <hpc> @src sort
09:14:35 <lambdabot> sort = sortBy compare
09:14:38 <hpc> @src sortBy
09:14:38 <lambdabot> -- The actual definition used by GHC is an optimised mergesort.
09:14:39 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
09:14:49 <cocreature> not including Either in that hand-curated list seems a bit weird
09:15:09 <rdococ> :t 3
09:15:10 <lambdabot> Num t => t
09:15:13 <rdococ> ah
09:15:19 <erisco> but the new version will have fromLeft and fromRight, aren't you excited
09:45:19 <aplainzetakind> Hello. Is there a standard library function taking a list of functions and an argument and returning the list obtained by applying each function to that argument? whatIWant [f,g] a = [f a, g a]
09:45:52 <cocreature> :t flip (map ($a))
09:45:53 <lambdabot> error:
09:45:53 <lambdabot>     • Couldn't match type ‘[b]’ with ‘b1 -> c’
09:45:53 <lambdabot>       Expected type: [Expr -> b] -> b1 -> c
09:46:06 <cocreature> :t \xs a -> map ($a) xs
09:46:07 <lambdabot> [a -> b] -> a -> [b]
09:46:15 <cocreature> ^ aplainzetakind is that what you’re looking for?
09:47:29 <aplainzetakind> I think so, I'm just learning and I'm not too clear on the use of $, but looks like it. Thanks.
09:47:55 <cocreature> aplainzetakind: do you know how "f $ x" is just  f applied to x?
09:47:58 <bjs> aplainzetakind: ($) is just function application
09:49:40 <aplainzetakind> I know the definition, I just don't fully appreciate the cases where it makes sense to use, but here's one, so yeah.
09:50:01 <bjs> aplainzetakind: well here it's being used a shorthand, ($ a) is a function (\f -> f a)
09:50:49 <monochrom> aplainzetakind: The missing information is the precedence of $, and the precedence of other things.
09:50:57 <cocreature> aplainzetakind: there are two orthogonal usecases: 1. it gives a name to function application so you can pass it to higher order functions or use sections such as in this example and 2. it has a very low precedence
09:51:04 <monochrom> The devil is in the precedence.
09:51:06 <aplainzetakind> In parenthesis notation ($a)f is fa, but is it the case that (f$) is simply f?
09:51:31 <monochrom> Oh wait nevermind, ($ a) doesn't need to know precedence.
09:51:32 <cocreature> which means you can use "f $ long and complex expression" and it will parse as "f (long and complex expression)"
09:51:33 <erisco> gah, I cannot parameterise a type class with a type family… what hack do I use now
09:51:50 <bjs> > [(+1), (+2)] <*> [1]
09:51:52 <lambdabot>  [2,3]
09:51:53 <bjs> I guess is another way of doing it
09:51:54 <cocreature> aplainzetakind: (f$) is simply f if f is a function, if f is not a function it’s a type error :)
09:51:56 <Boomerang> :t flip (map . (&))
09:51:57 <lambdabot> [a -> b] -> a -> [b]
09:52:07 <monochrom> Yeah you need to know "sections" and therefore ($ a) = (\x -> x $ a) = (\x -> x a).
09:52:18 <monochrom> And also (* 5) = (\x -> x * 5) etc.
09:52:39 <aplainzetakind> cocreature: yeah I knew and used it to remove parenteses clutter, but I didn't realize its usefulness beyond that.
09:52:45 <aplainzetakind> Thanks.
09:52:59 <cocreature> (*5) might not be the best example since * is commutative (for all reasonable instances) :)
09:52:59 <monochrom> (f $) is simplifiable to f.
09:53:12 <glguy> > (undefined $) `seq` ()
09:53:15 <lambdabot>  ()
09:53:29 <monochrom> Yeah there are fine prints.
09:54:01 <erisco> I guess I can use tags… ugh
09:54:07 <rdococ> > (/2) 3
09:54:09 <lambdabot>  1.5
09:54:20 <rdococ> :t $
09:54:22 <lambdabot> error:
09:54:22 <lambdabot>     parse error on input ‘$’
09:54:22 <lambdabot>     Perhaps you intended to use TemplateHaskell
09:54:25 <ongy> :t ($)
09:54:27 <lambdabot> (a -> b) -> a -> b
09:54:28 <rdococ> ah
09:55:05 <cocreature> > (() `undefined`)) `seq` ()
09:55:07 <lambdabot>  <hint>:1:17: error: parse error on input ‘)’
09:55:15 <cocreature> > (() `undefined`) `seq` ()
09:55:17 <lambdabot>  *Exception: Prelude.undefined
09:55:20 <rdococ> > ($ $)
09:55:21 <lambdabot>  <hint>:1:4: error:
09:55:22 <lambdabot>      parse error on input ‘$’
09:55:22 <lambdabot>      Perhaps you intended to use TemplateHaskell
09:55:26 <rdococ> > ($) ($)
09:55:28 <lambdabot>  error:
09:55:28 <lambdabot>      • No instance for (Typeable a0)
09:55:29 <lambdabot>          arising from a use of ‘show_M876810576282134704719172’
09:55:36 <cocreature> > (\x -> undefined () x) `seq` ()
09:55:38 <lambdabot>  ()
09:56:13 <rdococ> > data Peano = Inc Peano | Zero
09:56:15 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
09:56:19 <rdococ> uhm
09:56:27 <[exa]> you need @let
09:56:38 <[exa]> but you might also want to use your ghci
09:56:50 <[exa]> esp. for random testing purposes
09:57:01 <rdococ> true
09:58:33 <bjs> rdococ: if you have specific questions it's probably better to ask those, though
09:58:40 <rdococ> true too
09:59:30 <erisco> so,  type family f :$ x
10:00:01 <erisco> then  data XId; type family Id a where Id a = a; type instance XId :$ a = Id a
10:00:12 <erisco> this seems really roundabout, but if that is what Haskell wants me to do…
10:01:47 <erisco> the point being that I can parameterise things with XId
10:15:57 <aplainzetakind> Is there a function that checks if all members of a list are the same?
10:16:14 <glguy> Not in base, but 'all' can help you make one
10:17:07 <aplainzetakind> all is just (and.map), no?
10:17:36 <glguy> It's very close to that
10:17:52 <erisco> I have one which uses null, drop 1, and group
10:18:27 <aplainzetakind> I'm trying to write a palindrome checker in a point-free manner.
10:19:06 <aplainzetakind> Just as an exercise.
10:19:40 <c_wraith> aplainzetakind: what algorithm are you using?
10:20:38 <aplainzetakind> I intend to take [id,reverse] and see if they are the same.
10:20:58 <aplainzetakind> After taking an argument.
10:21:13 <Hafydd> > ((==) . reverse) "hello" "olleh"
10:21:14 <glguy> Try: ap reverse and (==)
10:21:15 <lambdabot>  True
10:21:21 <Hafydd> Is that what you're trying to do?
10:21:57 <c_wraith> Hafydd: does that really help someone learn?
10:22:50 <aplainzetakind> palindrome :: Show a => a -> Bool
10:22:58 <aplainzetakind> I want this
10:23:02 <cocreature> Show?
10:23:07 <cocreature> that seems like the wrong constraint
10:23:20 <cocreature> "Eq a => [a] -> Bool" is what I would have expected
10:23:29 <Hafydd> Oh... I suppose it isn't.
10:23:36 <aplainzetakind> It will eventually work on strings.
10:23:46 <cocreature> String is just a list of chars
10:23:56 <cocreature> so "Eq a => [a] -> Bool" will work for that too
10:24:47 <aplainzetakind> If given a number, it will work on the string representation, which is the easiest way to manipulate digits.
10:24:56 <aplainzetakind> Is this a bad idea?
10:25:26 <cocreature> it’s a reasonable solution for numbers but it doesn’t really make sense for all instances of Show
10:25:42 <glguy> aplainzetakind: Using show on a string would give you the wrong answer for some strings
10:26:03 <cocreature> so I would recommend to use show before you pass things to your palindrome function for things where it makes sense instead of baking it into the palindrome function
10:26:11 <glguy> so you shouldn't bake Show into your palendrome check, rather you should use show outside of the palendrome check only for types where it makes sense
10:26:40 <monochrom> Palindrome check should only use Eq.
10:26:42 <cocreature> aplainzetakind: I would recommend to first write the straighforward implementation in a non-pointwise fashion and then try to convert that into a pointfree style instead of trying to come up with the pointfree version directly
10:26:45 <aplainzetakind> Well, ok then.
10:26:47 <glguy> > "résumé"
10:26:50 <lambdabot>  "r\233sum\233"
10:27:19 <glguy> That's not a palendrome, but do note that you'll get the wrong behavior of a palendrome check on non-ASCII
10:27:48 <monochrom> > reverse (show "é")
10:27:50 <lambdabot>  "\"332\\\""
10:27:57 <monochrom> > show "é"
10:27:59 <lambdabot>  "\"\\233\""
10:28:19 <aplainzetakind> palindrome a = ( a == reverse a )
10:28:30 <aplainzetakind> Non point-free is trivial.
10:28:46 <monochrom> Sure. You don't need pointfree for this.
10:29:08 <monochrom> I don't see how Show improves it anyway.
10:29:23 <erisco> the pointfree is pretty easy too, once you know some definitions
10:29:34 <monochrom> Yes.
10:29:35 <cocreature> aplainzetakind: alright, do you know the standard trick to make "\x -> f x x" pointfree?
10:29:45 <monochrom> For example, define p = \a -> reverse a.
10:29:57 <monochrom> Now palindrome = p.  Point free.
10:30:03 <aplainzetakind> Show was little more than a passing thought. I get it it's bad.
10:30:25 <monochrom> err, define p = \a -> a == reverse a
10:30:43 <aplainzetakind> I don't know the trick.
10:31:03 <aplainzetakind> Oh well.
10:31:08 * [exa] guesses (f .)
10:31:15 <erisco> you missed the discussion earlier
10:31:38 <cocreature> aplainzetakind: I don’t want to spoil the fun so maybe spend some time and see if you can come up with it yourself :)
10:31:46 <aplainzetakind> OK I will.
10:32:01 <cocreature> aplainzetakind: once you have that try refactoring your implementation of palindrome such that it matches this pattern
10:32:08 * [exa] guessed wrong
10:32:12 <cocreature> i.e., find what f is in your case
10:32:17 <cocreature> and then try to make that pointfree
10:32:32 <erisco> pure = return = const = \x y -> x;  (<*>) = \f g x -> f x (g x);  (=<<) = \f g x -> f (g x) x
10:33:18 <erisco> these can help you a lot for pointfree
10:34:08 <cocreature> aplainzetakind: it might also be worth pointing out that while making things pointfree can be a fun exercise it’s not something that necessarily improves your code. in this case the non-pointfree version is definitely simpler
10:35:42 <monochrom> math : closed form solution :: programming : pointfree
10:36:38 <tdammers> point-free is great when the points in question have no particularly interesting meaning
10:37:00 <tdammers> if your variables are called 'x' and 'f' and 'a', then they're good candidates for elimination, usually - but not always
10:37:11 <aplainzetakind> cocreature: Yes I assume so, really this is just for exercise.
10:37:33 <erisco> that is probably the nicest explanation I've heard tdammers, what you first said
10:38:19 <tdammers> erisco: I find it amazing how much programming wisdoms like this one, which should be straightforward, regularly get cargo-culted or yak-shaved into oblivion
10:39:00 <monochrom> Yeah. Bear in mind I am also the author of http://www.vex.net/~trebla/weblog/pointfree.html
10:39:03 <tdammers> "you shall write short functions" - uhm, no, not the point; you should write functions that are simple and as self-contained as possible, and such functions are usually (but not always) short
10:39:48 <monochrom> In math you see the analogous newbie unhealthy pursuit for "closed-form formulas".
10:39:48 <hpc> sometimes simple code is longer than complicated code
10:40:12 <tdammers> hpc: that, too
10:40:24 <tdammers> "DRY" is another one of those principles
10:40:39 <tdammers> repeated code is not always a sign of redundancy
10:40:39 <erisco> but if you're like me then you like pointfree as a fun thing to do
10:40:43 <monochrom> Like one power series "has a closed-form solution" because it happens to be sine, and another "doesn't" because it happens to be one of those Bessel functions.
10:40:45 <erisco> like a Sudoku
10:40:57 <erisco> regardless of whether it is a good idea or not :)
10:41:03 <tdammers> sure, it's a fun exercise
10:41:08 <ahihi> > let x = "é" in x == reverse x
10:41:10 <lambdabot>  False
10:41:20 <tdammers> probably even somewhat useful as such
10:41:24 <hpc> tdammers: i try to think of programming languages in the same terms as actual languages
10:41:29 <monochrom> Sole difference being the highly artificial: someone put sine on the approved-for-exams "scientific" calculator.
10:41:45 <hpc> tdammers: and the goal of good programming is for the text to be as close to 1:1 with the ideas behind it as you can
10:41:53 <tdammers> hpc: that's a good starting point IMO - after all the main purpose of a programming language is communication between humans
10:42:12 <Hafydd> That's an interesting claim.
10:42:13 <hpc> and DRY taking to its bad extreme is like an author trying as hard as they can to not use the same adjective twice
10:42:15 <monochrom> Similarly a function has or has not a pointfree form simply depending on solely the highly artificial: what's available in Prelude? or base?
10:42:25 <Welkin> DRY is very stupid for many reasons
10:42:31 <hpc> sometimes two unrelated things do just have the same steps involved
10:42:41 <Welkin> it follows with many oop prinicples
10:42:43 <hpc> or you can describe them in the same way
10:42:47 <hpc> cars can be white, dogs can be white
10:42:52 <hpc> but they are unrelated
10:42:59 <hpc> so just repeat yourself there, maybe
10:43:07 <tdammers> it's not a matter of "how much DRY is DRY enough"
10:43:20 <tdammers> the problem is that "repeating yourself" is generally interpreted too literally
10:43:30 <tdammers> I prefer the principle of "Single Source of Truth"
10:43:48 <tdammers> which says that every truth about your problem should be expressed exactly once
10:44:10 <tdammers> any other part of the codebase that deals with such a truth must reference it, not repeat it
10:44:46 <tdammers> but if it's not the same truth, but a different truth with some superficial similarities, then factoring it out leads to pain and suffering down the road
10:44:47 <hpc> perhaps what you mean is that "DRY" should be applied to the ideas instead of the text
10:44:58 <tdammers> maybe
10:45:11 <tdammers> but that difference is too hard to explain and gets misunderstood all the time
10:45:19 <erisco> I see the vagueness of the first spec to be used to justify the similarity between inevitably dissimilar things
10:45:21 <tdammers> so I prefer to call it Single Source of Truth
10:45:28 <hpc> it's a way fuzzier linguistic-type concept than programmers are used to dealing with, for sure
10:45:29 <erisco> then you end up with a nightmarish regressive code base
10:46:08 <erisco> where once abstractions have now become riddled with special needs
10:46:56 <erisco> I think UI is a good example… I just copy and paste UI nearly wholesale, initially
10:47:07 <erisco> this form looks like that form now… but you wait
10:47:25 <tdammers> yes, exactly
10:47:45 <tdammers> two forms that differ only by two fields - but that is actually a coincidence, not a sign of a shared truth
10:47:53 <Welkin> that happened to me when using yesod-forms
10:48:14 <Welkin> it ended up being much mroe complicated to try to write forms using it than just hardcoding my forms in html
10:48:36 <tdammers> although shared truths appear a lot in UIs; but when they do, they typically take the shape of reusable widgets, or some sort of global-ish state
10:48:39 <Welkin> and then manually handled the form processing
10:48:53 <tdammers> exactly
10:49:17 <tdammers> I mean, it makes sense to reuse things like date pickers, map location pickers, address widgets, etc.
10:49:25 <tdammers> but beyond that? almost certainly not
10:58:51 <Rembane> I want to create somekind of storage data type in memory where I can lookup records in different ways, by for instance on their title or uuid, and I want to be able to update the records and let the changes update everywhere. Can you give me some directions?
10:59:09 <Welkin> Rembane: Acid state?
10:59:23 <Welkin> https://hackage.haskell.org/package/acid-state
11:00:34 <Rembane> Welkin: Thank you, I'll look into it.
11:16:53 <erisco> Could not deduce: (rmap :$ (rmap :$ r1)) ~ (rmap :$ (rmap :$ r1))
11:16:58 <erisco> now this is reminding me of Idris
11:17:57 <c_wraith> erisco: you're probably being bitten by non-injectivity somewhere
11:18:31 <erisco> but that particular complaint looks absurd
11:19:18 <c_wraith> I've managed to get messages about not being able to convert forall a. a -> a to forall b. b -> b
11:19:44 <c_wraith> But that requires enabling -XImpredicativeTypes, and they're known to be broken...
11:22:23 <erisco> I don't know how to clearly explain what I am trying to do
11:22:33 <erisco> that is probably the first reason I can't solve it
11:27:49 <erisco> (\k f a b -> pure f `k` a `k` b) :: Applicative f => (forall a b. f (a -> b) -> f a -> f b) -> (a -> b -> c) -> f a -> f b -> f c
11:28:15 <erisco> then, I can apply this to <*>
11:28:31 <erisco> then I have the type  Applicative f => (a -> b -> c) -> f a -> f b -> f c
11:29:36 <erisco> what I am trying to do now is capture the pattern of functions like <*>
11:30:42 <erisco> b -> a -> F b  is a first guess, where F is some type family
11:30:56 <erisco> maybe  F b a  instead but lets stick to  F b  for now
11:31:19 <erisco> and I have the  f :$ b  nonsense instead but we can ignore that too
11:31:44 <erisco> so, for <*> this F takes f (a -> b) to f b, which is simple
11:32:03 <erisco> the problem is that  (b -> a -> F b)  does not have the quantification necessary
11:32:31 <erisco> recall my earlier example with  \k f a b -> ...  this had  a  and  b  quantified
11:32:47 <erisco> but with this simplistic view of  b -> a -> F b  I don't see how to accomplish this
11:33:13 <erisco> I can't say  forall b a. b -> a -> F b  because this is too general… the types need some shape
11:36:18 <erisco> then I thought, okay, I have no idea how I'd implement this, but say I had some function  (forall b a. b -> a -> F b) -> F b -> a -> F (F b)
11:36:28 <erisco> well then I got that goofy error :P
11:36:57 <erisco> er, that  forall b a  should be on the outside
11:37:33 <erisco> is F injective? no
11:39:16 <erisco> I can have  F b a -> a -> b  which would be for <*> but I don't see this happening generally
11:39:32 <crucify_me> << see moniker
11:55:53 <knupfer> What is the really fastest way to embed ByteString.Builders which are already known at compile time?
11:56:20 <knupfer> foo a = bl1 <> a <> bl2
11:56:44 <knupfer> let's say that bl1 and bl2 are each surely known at compiletime
11:58:01 <knupfer> My current state of affairs is that I write them as Addr# and run on them unsafePackAddressLen from the internal modules
11:58:35 <knupfer> ... and accursedUnutterablePerformIO
11:59:41 <knupfer> looking at core, it doesn't look that bad, but I wonder if it would be more efficient concatting the Addr# beforehand and just index the ByteString differently
12:01:19 <knupfer> any thoughts?
12:01:19 <benzrf> is theres something like: (a -> b) -> [a] -> [(b, [a])]
12:01:28 <benzrf> er, with appropriate eq/ord constraints of course
12:02:07 <knupfer> benzrf: elaborate, there are various implementations possible
12:02:24 <benzrf> group together the a's that have the same b
12:02:44 <benzrf> i suppose it would be more accurate to use Set instead of []
12:03:05 <lyxia> nothing like that in the standard libraries
12:03:07 <zachk> might want to invert a map and use nub or nubBy 
12:03:22 <zachk> with a sort first
12:03:25 <zachk> well not sure...
12:03:44 <hexagoxel> groupOn?
12:03:53 <hexagoxel> groupOn :: Eq b => (a -> b) -> [a] -> [[a]] 
12:04:12 <benzrf> hm
12:04:24 <benzrf> well, its nbd
12:05:17 <knupfer> Any idea on my bytestring munging?
12:05:30 <knupfer> Trying to squeeze the last bit of perf...
12:05:31 <zachk> nbd?
12:05:40 <knupfer> not bad?
12:08:20 <knupfer> Hm, another try: who knows
12:08:35 <knupfer> addrVal :: KnownSymbol a => Proxy a -> Addr#
12:10:03 <knupfer> there is the obvious symbolVal, but is statically known, therefore in core it's always embedded via Addr#
12:11:20 <dmwit> I'm fairly certain there's nothing more asymptotically efficient than `\s1 s2 -> null (S.intersection s1 s2)`, but is there a specialized function for that somewhere in `containers`?
12:11:47 <dmwit> (I took a peek myself and didn't see it, but there's a lot of stuff and it would be easy to miss.)
12:12:22 <dmwit> zachk: "nbd" stands for "no big deal"
12:13:18 <dmwit> benzrf: Yes, that's `M.fromListWith (++)`
12:13:40 <dmwit> :t \f as -> M.fromListWith (++) [(f a, [a]) | a <- as]
12:13:42 <lambdabot> Ord k => (a -> k) -> [a] -> M.Map k [a]
12:16:20 <trigone> hi! say i have two IO handles for two files. i truncated file B and i'd like to copy the end of file A (from the current position onwards) right at the end of file B. what's the easiest and fastest method?
12:16:35 <trigone> (binary files, if it makes a difference)
12:18:02 <dmwit> hGetContents hA >>= hPutStr hB
12:18:14 <dmwit> Use Data.ByteString if you want to skip decoding/encoding.
12:18:33 <zachk> trigone, try using strict bytestrings, are they text files? hGetLine, hPutStrLn from bytestring though, laziness might interferre
12:18:45 <zachk> listen to dmwit
12:19:07 <trigone> thanks, i'll do all of that!
12:19:30 <dmwit> (The Lazy version is probably better unless you're unconcerned about memory footprint.)
12:19:35 <trigone> as regards lazy IO, it's only when working with streams that it doesn cause problems right?
12:20:05 <dmwit> Um. I don't think it's very common to use lazy IO and streams together.
12:20:08 <zachk> it can cause problems if you try to rewrite to a file 
12:20:12 <dmwit> Streams are an alternative to lazy IO.
12:20:19 <trigone> dmwit: i think the strict version still uses a buffer, doesn't put everything on memory, but i could be wrong
12:20:27 <dmwit> trigone: You are wrong.
12:20:58 <knupfer> lazy IO is problematic for effectful computations
12:21:05 <trigone> dmwit:  i meant streams informally, in the notion of "files" without clear-cut start and ends, like stdin
12:21:21 <trigone> knupfer: effectful in what meaning?
12:21:28 <trigone> dmwit: wrong in what way?
12:21:33 <tsahyt> How can I print a Double with bounded precision, e.g. 3.1415 -> "3.15", but 3.00 -> "3"?
12:21:46 <knupfer> trigone:  f :: ByteString -> ByteString would be fine
12:21:50 <dmwit> trigone: The strict ByteString `hGetContents` stores the entire remainder of the handle's contents in memory at once.
12:21:50 <glguy> tsahyt: String manipulation
12:22:06 <knupfer> trigone: but f :: ByteString -> IO ByteString  :(
12:22:13 <tsahyt> glguy: so printf can't do that?
12:22:14 <dmwit> tsahyt: You can use `approxRational`, perhaps.
12:22:27 <trigone> dmwit: hm so i'd better use a lazy bytestring, the file could be several gigabytes long
12:22:56 <trigone> knupfer: the former isn't lazy IO though, you spoke of lazy IO at first
12:23:24 <trigone> can i use strict bytestring first then lazy bytestring on the same handle xwithout problems?
12:23:48 <dmwit> Yes. But you can't use anything on the handle after `hGetContents` of any flavor.
12:24:15 <dmwit> (Not even `hClose` is guaranteed to work!)
12:24:16 <trigone> dmwit: i can't move the cursor to say the start of the file, or any other previous position?
12:24:49 <dmwit> If that question had an implicit "after `hGetContents`", then no.
12:24:56 <knupfer> trigone: I wanted to say, that it's fine to get an IO Lazy.ByteString iff you just run pure functions on it and at the end spit it out
12:25:01 <dmwit> There are other functions for reading that don't semiclose the handle.
12:25:11 <dmwit> (If you want to do more manipulations afterwards.)
12:25:15 <trigone> dmwit: so i maybe shouldn't use it? so far i was making a manual loop of taking a block of file A (strict bytestring) and writing it on file B...
12:25:32 <dmwit> Yes, that's another normal way.
12:26:01 <trigone> knupfer: hm ok... so you mean as long as you don't want to use the result in an effectful and non-lazy way after processing
12:26:26 <knupfer> yep
12:26:37 <trigone> dmwit: is there a function already written? i feel like rewriting the wheel...
12:26:43 <trigone> *that does that
12:28:22 <knupfer> dmwit: do you know of a function  f :: KnownSymbol a => Proxy a -> Addr#
12:28:38 <dmwit> knupfer: I know little about the singletons stuff, sorry.
12:29:18 <knupfer> dmwit: https://github.com/knupfer/type-of-html
12:29:38 <knupfer> I'm writing a html generator on the type level ^^
12:30:26 <dmwit> I hope you're having fun with it. =)
12:33:17 <knupfer> dmwit: yeah :), writing directly Addr# and stuff
12:33:36 <knupfer> at least it's safer and ~10 times faster than blaze
12:34:14 <c_wraith> knupfer: are you requiring valid nesting structure according to some particular set of HTML rules?
12:34:45 <knupfer> c_wraith: yes
12:35:14 <knupfer> c_wraith: invalid tag nesting isn't possible, but invalid attributes are
12:35:51 <knupfer> td_ (tr_ "a")      <- compile time error
12:36:01 <knupfer> tr_ (td_ "a")   <- compiles
12:36:14 <Welkin> not `text "a"`?
12:36:31 <geekosaur> might be OverloadedStrings
12:37:14 <knupfer> c_wraith: tags are all represented as Proxy Symbol, which get fused via AppendSymbol while compiling
13:06:28 <dmj`> knupfer: 8.2 only right?
13:07:30 <adelbertc> what is the difference between cabal new-repl vs cabal repl?
13:07:34 <adelbertc> i cant seemt o find any docs online
13:07:42 <pikajude> base >= 4.10 && < 4.11
13:07:45 <pikajude> yeah, looks like 8.2
13:08:49 <geekosaur> adelbertc, the new-* stuff is not quite fully baked yet.
13:09:06 <adelbertc> geekosaur: is it intended as sort of a preview of what's to come?
13:09:10 <geekosaur> in particular new-repl is very recent and still evolving. but in general the new-* all work together
13:09:15 <pikajude> will GHC core libraries get backpackified in an incoming release?
13:09:30 <geekosaur> so new-repl should only be used with new-build (the "nix-like" sandboxes)
13:09:33 <pikajude> whoops, upcoming is the word i wanted
13:09:37 <pikajude> yikes
13:10:20 <adelbertc> ah got it
13:10:26 <adelbertc> that might explain why it freakked out for me
13:10:51 <geekosaur> right, with old-style sandboxes or no sandbox it'll blow up about not having the right config
13:12:14 <geekosaur> consider the new-* a technology preview. new-repl in particular is still changing (there's a number of changes already in cabal HEAD, if I've been following the devel talk correctly)
13:12:39 <adelbertc> sounds good, ill stick with vanilla repl in the interim
13:13:14 <geekosaur> although new-build is already fairly usable and should be fairly well documented --- but will not go live until it's got all the support stuff that goes along with it, including new-repl
13:13:55 <geekosaur> (all fully worked out and operational, that is)
13:14:31 <cocreature> at least in 2.0, new-repl should be relatively stable
13:15:02 <geekosaur> right, but it throws errors when not used with a new-build sandbox, apparently
13:15:35 <cocreature> sure using it outside of new-build won’t work, I was just trying to say that new-repl is not changing as much as you seemed to be suggesting
13:40:51 <knupfer> dmj`: Sry, was offline.  Yes, it needs ghc8.2 because of AppendSymbol. I don't know if I'll backport it, because it would need a lot of CPP and would be perhaps 2 times slower (but still a lot faster than blaze)
13:41:49 <monochrom> Wait, faster than blaze?! That's like faster than light. :D
13:42:40 <monochrom> Ah, you do really low level stuff.
13:42:43 <knupfer> monochrom: Yes, it's about 5 times faster in the average case
13:43:06 <knupfer> for the big table benchmark from the blaze homepage it's 10 times faster
13:43:45 <knupfer> monochrom: The speed is mostly because of the type hackery (look at Html.Type)
13:45:05 <monochrom> Is Html.Type an exposed module? Because it isn't listed on Hackage doc.
13:45:19 <`Guest00000> question: can i have a parser implementation which efficiently parses `aNYseq = many aNY `diff` (many aNY *> (opencom <|> closecom) *> many aNY)`, where (p `diff` q) parses everything p does but q doesn't, which doesn't override the default definitions for some and many?
13:45:27 <monochrom> But yeah I can browse github.
13:45:48 <knupfer> monochrom: can you paste your last mesages, my connection broke
13:46:06 <monochrom> Is Html.Type an exposed module? Because it isn't listed on Hackage doc.
13:47:06 <`Guest00000> aNY parses any character from a certain set; opencom and closecom each parse a certain fixed string
13:47:14 <knupfer> No, it's "low level" type stuff for optimization.
13:47:17 <knupfer> https://github.com/knupfer/type-of-html/blob/master/src/Html/Type.hs
13:47:37 <knupfer> 1200 LOC just type level
13:51:16 <knupfer> monochrom: The perf trick is that every tag is represented as Symbol and after construction checked if it's got a neighbouring Symbol which will get appended at compile time and embedded as an strict ByteString. Furthermore, it removes redundant Tags on the *type level* (like omittable closing tags).
13:52:32 <knupfer> so if you want    <div><table><tr><td>a</td><tr></table></div>
13:53:50 <knupfer> the compiler optimizes it to the following pseudo code     "<div><table><tr><td>"# <> escape "a" <> "</table></div>"
13:53:56 <knupfer> #
14:03:38 <dmj`> knupfer: The spec forbids certain tags from being nested (i.e. nesting anchor tags), despite most browsers allowing for it, does this library attempt to disallow these states at compile time.
14:07:03 <knupfer> dmj`: It forbids (nearly) every nesting which the html spec forbids
14:07:09 <knupfer> according to https://developer.mozilla.org/en-US/docs/Web/HTML/Element
14:12:55 <knupfer> (at compile time)
14:17:52 <dmj`> knupfer: well done. This is great work.
14:18:41 <knupfer> dmj`: Thanks, that means a lot to me
14:19:30 <knupfer> dmj`: Perhaps I should post somewhere the benchmark
14:19:59 <knupfer> dmj`: Or make a bit reddit publicity, hm.
14:20:45 <sm> don't forget the how-does-it-compare-to in README. Eg how does it compare to lucid
14:22:16 <knupfer> sm: lucid has the same perf as blaze, so it's about 5 times faster than lucid but with a more verbose syntax (especially if you write type signatures which i don't recommend with my library)
14:23:12 <knupfer> sm: You can for example put the html code in a separate module and deactivate for this module the ghc warnings for missing signatures.
14:25:22 <knupfer> sm: The only real downside is that because of the very thorough optimization it raises compile times (perhaps a min. per average html page), another argument for putting it in a seperate module of your project
14:26:35 <dmj`> knupfer: Nice usage of TypeError as well. Interested to see how you got the perf. My only fear would be that in `convert`, calling symbolVal would have to first allocate a String, but that doesn’t seem to be an issue here.
14:27:53 <sm> knupfer: great, that'll be good in the readme
14:27:55 <knupfer> dmj`: That's not the case, GHC optimizese it to  (unpackCString# (foo :: Addr#)) which will get rewritten directly into a bytestring
14:28:53 <knupfer> dmj`: Looking at the core of a medium sized generated html page shows: No intermediate structure whatsoever, no String, no List.
14:29:09 <knupfer> sm: Thanks for the input
14:32:23 <sm> my next question would be, do I want this enough to make compilation even slower.. in what kind of apps would this make a useful difference ? 
14:33:22 <monochrom> When you need to be faster than blaze. Such as nuclear fusion. :)
14:34:01 <dmj`> knupfer: re:optimizations: Incredible, bravo.
14:34:04 <knupfer> sm: Webapps of any kind. Note that it's not only about 5x faster, but it's also a *lot* type safer. Blaze is actually a lot like string munging
14:34:55 <knupfer> sm: Besides, you can write an instance of Convert for Blaze, so you can mix and match both
14:35:40 <sm> I maintain darcs hub, eg. It's not a high-traffic site. I don't think switching to this would affect me much
14:36:12 <sm> or if I'm contemplating lucid for a project (I am).. is this more type safe than lucid ?
14:36:23 <knupfer> sm: yep
14:37:04 <knupfer> sm: In lucid and in blaze, you can form arbitrary nestings of arbitrary elements because they are all the same to the type checker
14:37:25 <sm> excuse the skeptical questions, these are just the kinds of things I love to answered in a project's readme
14:37:27 <sm> see
14:37:49 <knupfer> sm: in type-of-html, every single element is a different type of kind Element, and type families will refuse to compile on unlawful children
14:38:09 <sm> cool
14:38:11 <sm> bbl
14:38:44 <knupfer> sm: It's quite new, so hadn't really time for writing a good readme, at least in the module is a small tutorial
14:39:04 <knupfer> sm: but please note that you need at least ghc 8.2
14:39:26 <knupfer> dmj`: Thanks!
14:55:45 <dmj`> knupfer: Really like how few deps this has. Expected at least singletons. Again, great work.
15:04:16 <knupfer> dmj`: :)
15:11:35 <epta> how to run `runghc' with scope of modules of arbitrary `dist/dist-newstyle' folder?
15:14:56 <Welkin> knupfer: is there a specific use case or was this just for fun?
15:16:40 <cristipp> hello :)
15:17:26 <knupfer> Welkin: just for fun, but well, if you need high perf html...
15:18:07 <cristipp> Fairly newbie at Haskell things. I was wondering if there is a tool to convert pure code to monadic code automagically
15:18:26 <Eduard_Munteanu> Hi.
15:18:27 <knupfer> cristipp:  pure
15:18:45 <knupfer> Welkin: I'd be glad if other people would find it useful
15:18:54 <Eduard_Munteanu> cristipp, any example of what you mean?
15:19:07 <Hafydd> The tool is called (return $).
15:19:13 <cristipp> i have a scala one :)
15:19:23 <cristipp> i can spend 15 minutes to convert it to haskell
15:19:33 <Hafydd> (Or just "return". IDK why I wrote it as a section.)
15:19:52 <monochrom> Convert pure Scala code to monadic Haskell code? I don't know what that means.
15:19:52 <wz1000> how do I test "this expr should fail to typecheck"?
15:20:15 <cristipp> oh, no, i have pure scala code i want to convert to monadic [do notation] scala code
15:20:42 <cristipp> but then again, i thought haskell people would know best how to solve this kind of problems :)
15:21:01 <monochrom> Yes, we do --- for Haskell.
15:21:28 <c_wraith> wz1000: https://hackage.haskell.org/package/should-not-typecheck
15:22:08 <wz1000> c_wraith: neat
15:22:25 <monochrom> Ah deferred type errors.
15:22:59 <c_wraith> It's a cute side effect of that feature.
15:24:37 <dmwit> epta: `cabal run` (for `dist`) or `cabal new-run` (for `dist-newstyle`, and needs the latest cabal from github)
15:24:49 <dmwit> epta: Sorry, I meant `exec` and `new-exec`.
15:25:31 <epta> dmwit: new-exec is supported in latest master?
15:26:30 <dmwit> epta: Hm, maybe not yet: https://github.com/haskell/cabal/pull/4722
15:27:14 <rotaerk> hmm when I run ghci, if I try to import a module from my own project, it doesn't find it unless I specified the source file for it as an argument when launching it
15:27:27 <rotaerk> is there some way to set it up such that it can find all my modules?
15:27:51 <rotaerk> https://github.com/rotaerk/iircc
15:27:57 <rotaerk> this is my current project structure
15:28:17 <dmwit> How do you run ghci?
15:28:22 <dmwit> Consider `cabal repl`
15:28:58 <epta> or `cabal new-repl`, right
15:29:01 <rotaerk> I just run 'ghci'
15:29:12 <dmwit> Or `cabal exec ghci` if you don't like having all the modules loaded by default.
15:29:28 <dmwit> epta: right
15:29:29 <rotaerk> but I have to provide source files explicitly, one by one, in order for them to be found
15:29:36 <rotaerk> hmm I'll try that
15:30:14 <dmwit> cristipp: Depending on what you mean by "convert pure code to monadic code", you might like the paper "Lightweight Monadic Programming in OCaml".
15:30:18 <monochrom> ghci (and ghc) has no notion of project. cabal passes arguments to ghc.
15:31:35 <monochrom> As far as ghci is concerned, you may import a module iff either the module is in a library already installed or the module has been "loaded" 
15:31:42 <rotaerk> hmm, my cabal file has a library and two executables; when I did cabal repl, it actually loaded all the modules from the library
15:31:51 <rotaerk> but it didn't load the executables
15:32:03 <dmwit> rotaerk: You can `cabal repl exe:name-of-exe`.
15:32:07 <monochrom> "loaded" is iff you used ":load" or used command line argument.
15:32:41 <rotaerk> when I say "loaded" I mean when the repl started, it listed each of my modules and said "Compiling"
15:32:50 <monochrom> Me too.
15:32:51 <rotaerk> (but only the library modules); lemme try dmwit's suggestion
15:33:11 <rotaerk> I wasn't at all aware cabal had this capability...
15:33:23 <rotaerk> though I never use cabal directly
15:33:57 <rotaerk> cool, thanks dmwit; that worked perfectly
15:34:02 <dmwit> This is why I struggle with IDEs. They hide too much, I don't learn what the underlying tools are capable of.
15:34:11 <rotaerk> I don't use IDEs either
15:34:19 <Welkin> use emacs
15:34:40 <rotaerk> I've been programming haskell with vim for a while, without any kind of IDE-ish features other than syntax coloration
15:34:42 <Welkin> load your repl using stack
15:34:56 <monochrom> Try "cabal repl -v" some day and see how many arguments cabal passes to ghci.
15:35:08 <dmwit> rotaerk: Mostly the same, though hasktags is great, too.
15:35:35 <rotaerk> I'm trying to switch to emacs, but it's gonna take a while to get used to
15:35:47 <rotaerk> I don't use stack since it seems redundant with nix, which I'm already comfortable with
15:35:59 <rotaerk> but that limits me from using VS Code with Haskero, or Intero for emacs
15:36:29 <MarcelineVQ> rotaerk: have a look at dante if you use emacs
15:36:30 <Welkin> I gave up on nix for now
15:36:37 <Welkin> using stack again now
15:36:46 <rotaerk> just installed dante actually; haven't figured out how it WORKS yet though
15:36:54 <Welkin> dante?
15:36:56 <rotaerk> but yea, this cabal repl command... very helpful
15:37:14 <rotaerk> dante is a haskell minor mode for emacs
15:37:14 <monochrom> MarcelineVQ: How do I google for dante accurately?
15:37:19 <rotaerk> https://github.com/jyp/dante
15:37:26 <MarcelineVQ> "emacs dante"
15:37:33 <monochrom> Yeah, I should try that.
15:37:42 <MarcelineVQ> but rotaerk has linked it as well
15:38:16 <MarcelineVQ> Welkin: dante provides access to ghci's ide features from emacs
15:38:31 <rotaerk> I think the reason I haven't had to deal with the cabal command itself is because I resolve all my dependencies with nix
15:38:34 <Welkin> I haven't used intero, or even ghc-mod
15:39:21 <Welkin> maybe I should start using something though, just to try it
15:40:24 <rotaerk> if you use stack, Welkin, intero for emacs, or haskero for VS Code, are supposedly good
15:40:35 <rotaerk> my impression is dante is more for those who don't use stack
15:41:33 <rotaerk> hmm now the problem I'm facing is how to get *dante* to be able to see all my project's modules
15:41:53 <rotaerk> running 'ghci' doesn't work, but running 'cabal repl' does... and dante faces the same problem as the former
15:42:26 <monochrom> Yes, tell dante to call "cabal repl" or something.
15:42:33 <MarcelineVQ> tried going up a level? open emacs in the context of the projct
15:42:58 <rotaerk> I launched it from my iircc folder, the folder containing the cabal file
15:42:59 <MarcelineVQ> dunno if that's intended but I go around my share of ghc-mod issues that way
15:43:09 <monochrom> current working directory may be important
15:43:18 <Welkin> stateful computers
15:43:29 <monochrom> Yeah, iircc folder is right.
15:43:45 <Welkin> can we have a stateless computer?
15:43:47 <epta> what is the correct syntax for passing packagedb to runghc? `runghc A.hs -- -package-db --ghc-arg=../p/dist-newstyle/packagedb/ghc-8.2.1' didn't do a trick
15:43:48 <rotaerk> actually, it's not underlining my own modules, it's underlining some external dependencies which ARE resolvable since I'm running within nix-shell
15:44:01 <monochrom> Oh dante already knows "cabal repl" as under "bare"
15:44:19 <monochrom> What is mafia? :)
15:44:27 <MarcelineVQ> mafia is pretty neat
15:44:38 <MarcelineVQ> https://github.com/ambiata/mafia
15:44:46 <rotaerk> yea, dante's underlying Control.Concurrent.Async and suggesting that I put async in my cabal file
15:44:58 <rotaerk> but it IS in my cabal file, under the executable
15:45:02 <monochrom> Haha great photo of lego figures
15:45:08 <rotaerk> wonder if I need to add it to the library part of tthe cabal file for it to resolve...
15:45:34 <MarcelineVQ> does your project use async?
15:45:35 <Welkin> lol, they also have a library called "hadron"
15:45:42 <Welkin> should have been "hardon" like the lua library
15:46:18 <zachk> the super large hardon collider
15:46:33 <Welkin> it's a collision detection library called "hardon collider"
15:47:00 <monochrom> Hahaha "Locking down your user package database" is brutal. It means chmod -w.
15:47:05 <rotaerk> MarcelineVQ, looks like adding async to the cabal file under my library resolved the dante issue
15:47:11 <rotaerk> but my library doesn't use async, only the executable
15:47:23 <rotaerk> so dante seems to only pay attention to the depends of the library
15:47:30 <MarcelineVQ> sounds like a good item to make an issue about
15:47:46 <rotaerk> or I'm just a noob and there's already a solution
15:48:04 <MarcelineVQ> maybe, or you could save lives
15:48:15 <rotaerk> :P
15:48:21 <MarcelineVQ> stress kills!
15:48:54 <MarcelineVQ> erring on the side of making a bug report is good practise, especially if you've already narrowed down the problem
15:50:12 <rotaerk> yea, I might do that if I don't figure it out soon
15:51:31 <monochrom> rotaerk: Most likely dante is simple-minded in where/how to auto-edit your *.cabal file.
15:52:23 <rotaerk> auto-edit?
15:52:31 <rotaerk> I don't think it's touching my cabal file
15:52:38 <monochrom> OK I misread.
15:53:02 <rotaerk> also, huh:  it looks like dante has explicit nix-shell support
15:53:42 <monochrom> Well if it even knows about mafia, it ought to know about nix...
16:12:48 <cristipp> on pure => monadic conversion
16:12:52 <cristipp> I have the code at https://repl.it/KtFz/0
16:13:05 <cristipp> I wrote a pure "_eval" function
16:13:15 <cristipp> and I'd like to convert it to a "Boxed" version
16:13:55 <cristipp> can't get the types right [even if I have an equivalent working Scala version]
16:14:19 <cristipp> is there a tool that coud do the conversion for me?
16:20:23 <glguy>  cristipp: You'll get better type errors if you put type signatures on your top-level definitions
16:21:18 <glguy> cristipp: You're forgetting to use 'Box' in a few places
16:24:41 <cristipp> ok, got the pure / monadic version to both compile
16:25:40 <Welkin> all haskell is "pure"
16:26:24 <Welkin> unless you mean "not using IO"
16:26:24 <cristipp> now for the harder question: Is there a tool where I could point, say to the return type of '_eval' and ask 'rewrite this code such that the function now returns Box Tree instead of Tree'
16:26:36 <cristipp> code here: https://repl.it/KtFz/2
16:27:42 <cristipp> essentially have it write "eval" for me :)
16:28:39 <glguy> no
16:30:34 <Hafydd> That tool is called "Box".
16:30:42 <Hafydd> Or "(Box .)", rather.
16:32:30 <cristipp> @Hafydd Not sure what you mean? Is there some code I could write?
16:32:31 <lambdabot> Unknown command, try @list
16:33:38 <monochrom> IMO it is actually better to leave it as Tree as much as possible, not wrapping with Box prematurely, and only add the Box at a use site that really needs it.
16:33:54 <Hafydd> cristipp: given a function _eval :: Tree -> Tree, Box . _eval :: Tree -> Box Tree.
16:34:12 <monochrom> Premature boxing is the major cause of the wrong conclusion "I am stuck in a monad".
16:34:30 <Hafydd> (But this doesn't make the other code using _eval work, which is perhaps what you were expecting.)
16:34:55 <monochrom> In fact even at those use sites that need it, it is better done by fmap.
16:36:54 <cristipp> @Hafydd That works, but it removes the monad from the inside of the function. Imagine the monad is a box where I store log messages. What I really want is to add a log message inside _eval, and have it convert autmagically to mnadic version, tracking the exact logging point.
16:36:54 <lambdabot> Unknown command, try @list
16:40:06 <Hafydd> cristipp: I see. It would be easier if you wrote all your pure code in the Identity monad and then used a monad transformer, but I don't recommend actually doing that.
16:41:51 <Hafydd> If your code is already monadic, it isn't hard to add a monad transformer by hand; and if it's not monadic, you're going to have to restructure to to add an action at "a certain point", anyway.
16:42:27 <cristipp> not monadic, i need to restructure. jut wondering if there is some tooling help for that kind of work
16:42:45 <Hafydd> I don't know of any such tool, and I doubt one exists.
16:47:15 <sqooq> hi
16:47:18 <sqooq> tomorrow I die
16:47:38 <sqooq> jk my family finally decided to leave tampa, we went to orlando
16:49:10 <sqooq> now help me make gui before i die pls
17:08:13 <sqooq> andromeda-galaxy
17:08:16 <sqooq> pls be here
17:12:06 <iqubic> anyone here?
17:16:04 <lyxia> You're alone.
17:18:15 <monochrom> sqooq: On average it takes 1-2 weeks to learn GUI programming in Haskell. You need to re-adjust your expectation.
17:18:34 <Welkin> I never learned gui programming in haskell
17:18:36 <monochrom> But maybe try threepenies-gui.
17:18:41 <Welkin> if you mean gtk/qt or similar
17:19:02 <Welkin> or do you mean in the browser?
17:19:10 <Welkin> or using opengl?
17:19:22 <Welkin> it could mean anything
17:19:27 <monochrom> Or is it called threepeny-gui? Anyway it uses your web browser. It is already the least overhead (of installing things and other sysadmin chores).
17:19:31 <Welkin> ncurses?
17:21:36 <MarcelineVQ> doh
17:22:42 <Eduard_Munteanu> Unfortunately, web UIs are messy as hell.
17:23:02 <Welkin> that depends on what you mean
17:23:08 <glguy> VTY's good if you're doing a console app
17:23:18 <Welkin> I find react extremely easy to work with
17:23:35 <Welkin> or anything else that handles the rendering for you
17:23:59 <Eduard_Munteanu> I mean HTML is terribly unsuited to a GUI.
17:24:10 <geekosaur> @hackage threepenny-gui
17:24:10 <lambdabot> http://hackage.haskell.org/package/threepenny-gui
17:24:11 <Welkin> it's perfectly well suited for it
17:24:34 <Welkin> you may be using applications that are rendered with html right now and not even know it
17:24:45 <Welkin> the atom text editor, the slack application, for example
17:26:05 <Eduard_Munteanu> Sure it can be done. That doesn't save us from the huge amount of fiddling one needs to do to get even basic results going.
17:26:22 <MarcelineVQ> hlml is fine, css is where the horrors breach the eldritch barrier
17:27:59 <Welkin> Eduard_Munteanu: reacts solved these problems a long time ago
17:27:59 <Eduard_Munteanu> HTML barely has any sensible concepts you find in a GUI, such as a navbar, menus, dropdowns, lists and this could go on and on. Not to mention it's fugly without a lot of styling.
17:28:02 <Welkin> React*
17:28:42 <Eduard_Munteanu> React is just the behavioral component.
17:28:55 <Welkin> take your pick of the numerous component libraries available
17:29:51 <Welkin> sure, css sucks, but that's another issue entirely
17:29:57 <Eduard_Munteanu> Yeah, and pile in a mountain of divs to get it done, and hours spent debugging why it doesn't work well with other components.
17:32:34 <Eduard_Munteanu> Native GUI toolkits kinda suck too, but at least it's not all that painful to do basic things.
17:33:21 <Welkin> it's not painful to do anything with react
17:33:34 <Welkin> compared to working on native iOS, it is much easier on the web
17:34:05 <Welkin> not the fancy animations, but meaningful functionality
17:35:37 <Eduard_Munteanu> The problem isn't React, that's ok, the problem is directly manipulating HTML, which offers no abstraction over components.
17:37:04 <Welkin> you aren't manipulating html
17:37:08 <Eduard_Munteanu> For example, there's no real concept of a menu. You just pick your favorite CSS framework, copy and paste a bunch of fragile code, then wire it up with React and pray it works.
17:37:33 <Welkin> it is plain javascript where jsx is just a dsl for generating html
17:38:21 <Welkin> that depends on the component
17:38:32 <Welkin> you can build abstraction on top of that
17:38:51 <Welkin> some off-the-shelf components do that (like the airbnb calendar component)
17:40:51 <Eduard_Munteanu> The default browser styles are fugly as hell too. Actually, I'm not sure if it's that or just lack of semantics for modern UI components.
17:41:45 <Eduard_Munteanu> Meanwhile, just about any native toolkit comes with semi-reasonable styling and you don't have to touch it (actually, shouldn't, in most cases).
17:42:02 <iqubic> So Existential Qualifications gives you the ability to make hetrogenous data structures?
17:42:06 <ezyang> pikajude: Definitely not: we have to at least wait for GHC's bootstrap support window to consist exclusive of Backpack packages :) 
17:42:15 <pikajude> so, in 2 weeks
17:42:17 <pikajude> nice
17:42:41 <Eduard_Munteanu> iqubic, in some ways
17:45:16 <iqubic> Basically it let's you have "Data Shape = Circle Int | Rectangle Int Int" And printShapes :: Shape a => [a] -> IO ()
17:45:56 <iqubic> And it lets [a] contain Circles and Rectangles.
17:46:08 <glguy> No, that's just: printShapes :: [Shape] -> IO ()
17:46:37 <iqubic> So why is existential qualifications a thing?
17:48:23 <monochrom> I wouldn't say that it gives you heterogeneous data structures.
17:48:35 <iqubic> What does it give you?
17:48:49 <monochrom> After all, the whole point is to stay with homogeneous data structures.
17:49:02 <iqubic> Some of the ghc extensions confuse me.
17:49:24 <iqubic> So I'm just going to learn the ones that seem interesting one by one.
17:49:48 <monochrom> If you have an existential type called "Foo" then all you can do is a list of type [Foo] which is homogenous again.
17:50:17 <monochrom> And depending on how you misdesigned the details of Foo, you may actually suffer data loss.
17:50:30 <sqooq> Can I not access type synonyms that take a value? I have something like `A B a` where A,B are type synonyms that get really complex, and a is an argument it takes. I just want to make a function that returns a (since one isn't already defined in this library)
17:50:40 <sqooq> I get `Not in scope: data constructor ‘Program’`
17:51:04 <iqubic> And you can't pattern match on those Foo objects?
17:51:10 <glguy> sqooq: Type synonyms don't exist at the value level, only the type level. What are you doing?
17:51:12 <monochrom> So this is not making heterogeneous anything. This is projection back to a homogeneous world again.
17:51:47 <sqooq> glguy: You mean the grand scheme of what I'm doing, or the function specifically that I'm trying to do?
17:51:53 <monochrom> Or s/projection/slicing/
17:51:55 <sqooq> the function would look like findcoo (Program CharBackendInstr y) = y
17:52:05 <monochrom> Cutting away all the differences.
17:52:26 <glguy> sqooq: Type synonyms don't introduce new data constructors
17:52:40 <glguy> sqooq: You can put your code on lpaste to help demonstrate where you're getting confused
17:52:42 <sqooq> but it gets complex with `Program` and requires all these other dependecies
17:53:09 <sqooq> glguy: i mean that's it
17:53:30 <sqooq> if I put my code then I might as well ask deeper questions 
17:53:37 <iqubic> So when are existential qualifications even used?
17:54:03 <sqooq> I'm using the Chart library, which makes like cartesian graphs basically, and I need to normalize my mouse position relative to the graph drawn. Obviously they aren't the same as the window
17:54:09 <monochrom> Read the docs of the base library from cover to cover. There is one.
17:54:40 <sqooq> monochrom: trust me I've been looking
17:54:43 <monochrom> Solitude reading sessions are part of learning. Since you mentioned "learning".
17:54:48 <sqooq> I think RectSize might be what I'm looking for
17:54:51 <monochrom> No sqooq, I mean iqubic.
17:55:12 <iqubic> what do you mean monochrome?
17:55:17 <iqubic> what do you mean monochrom?
17:55:28 <sqooq> here's code if anyone wants
17:55:29 <sqooq> http://lpaste.net/358331
17:55:34 <monochrom> I mean: Read the docs of the base library from cover to cover. There is one.
17:55:41 <monochrom> What is unclear about that?
17:55:43 <sqooq> allows one to draw a graph 
17:56:12 <iqubic> monochrom: There is one what? 
17:56:25 <iqubic> Why are you telling me to read the docs?
17:56:33 <monochrom> There is one use of existential quantification.
17:56:48 <monochrom> Because solitude reading sessions are part of learning. Since you mentioned "learning".
17:57:28 <iqubic> I see.
17:57:59 <monochrom> If you like Q&A sessions you can change your objective to politics or news reporting.
17:58:28 <monochrom> "Hi I like to do politics of GHC extensions, so here I have a dozen of questions"
17:58:37 <iqubic> LOL.
17:58:52 <Welkin> mine is YUGE
17:58:54 <Welkin> I win
17:59:17 <iqubic> What the...
17:59:45 <iqubic> So what should I learn about next???
18:00:08 <monochrom> Learn how to learn.
18:00:14 <iqubic> I know how to learn
18:00:29 <MarcelineVQ> make something, learn what you need to figure out how to make what you're making
18:00:47 <monochrom> Not if I were the judge. And I am a fairly trusted judge on this one.
18:01:12 <iqubic> I've even watched Edward Kmett's video on the topic of learning to learn
18:01:44 <monochrom> Yeah 90% of Americans watch football games too. So?
18:01:57 <iqubic> So I know how to learn.
18:02:09 <sqooq> nvm I've been understanding these types waaaay wrong
18:02:12 <sqooq> a is not an argument
18:02:16 <sqooq> it's a constraint
18:02:18 <monochrom> That's my point. Just having watched is not enough.
18:02:21 <sqooq> or whatever
18:03:25 <ertes> iqubic: exercise: write an index-preserving traversal that points to all letters in a string
18:03:33 <monochrom> Actually it may be even safe to go out on a limb and conjecture that 80% of those who have watched edwardk's videos (or any videos) still haven't learned what's taught in the videos.
18:03:42 * glguy realizes he might not be as qualified to play professional football has he'd previously thought
18:03:57 <iqubic> ertes: What does that even mean?
18:04:05 <monochrom> The fundamental issue is that learning is not a spectator sport. You don't just watch. (Not even just reading docs, but since you even haven't done that...)
18:04:09 <iqubic> Can I get a type signature?
18:04:22 <ertes> iqubic: figuring that out is part of the job…  i intentionally picked an exercise that isn't straightforward to understand
18:04:38 <iqubic> Well, I guess I have some things to learn.
18:04:52 <monochrom> Yeah you probably need to do some independent looking-up and research on those words first.
18:05:09 <iqubic> I know what a travesal is.
18:05:15 <monochrom> Or you can keep spamming this channel until someone answers.
18:05:16 <ertes> iqubic: you are not allowed to ask questions regarding this exercise in any interactive medium
18:05:32 <monochrom> Ah how do you enforce that?
18:06:01 <ertes> i can't, but it's a self-test…  "do i really know how to learn?"
18:06:06 <monochrom> Even I don't know how to enforce "don't ask on the Internet" even though I stated it in my courses.
18:06:19 <monochrom> Ah OK yes that works.
18:06:24 <glguy> monochrom: That probably requires physical restraints
18:06:40 <monochrom> Well yeah we enforce it during exams all the time...
18:07:08 <AxelAlex> If I could insert a quick question, is it the case that the State monad, (as in StateT Identity), does not do any actual mutation at runtime and just gives an interface that looks like mutation while the ST monad is slightly magical and does actual mutation at runtime? 
18:07:09 <monochrom> kind of regrettable because that makes exams all the more irrelevant to real problem solving.
18:07:55 <monochrom> That's righ AxelAlex. It's just s -> Identity (a, s). Function.
18:07:56 <ertes> AxelAlex: correct
18:08:11 <monochrom> And just parameter passing.
18:08:20 <ertes> AxelAlex: ST is pretty much just a restricted variant of IO
18:09:15 <AxelAlex> Thanks!
18:09:27 <monochrom> ST is the one that really needs to do mutation. You can infer this from the fact that mutable array operations in ST take constant time.
18:16:48 <sqooq> aw maaaan]
18:16:58 <sqooq> please anyone
18:17:41 <Bleem> :t \f (l, r) (l', r') -> (f l l', f r r')
18:17:42 <lambdabot> (t2 -> t1 -> t) -> (t2, t2) -> (t1, t1) -> (t, t)
18:22:51 <Bleem> if f is (+) I'd like this function to sum any pair of Num e.g. (1::Int, 1.5) and (2::Int, 2.5). but it insists on having both l and r the same type. can I get around that somehow?
18:25:14 <iqubic> I think that l and r can be the different types.
18:25:20 <iqubic> What error are you getting?
18:26:07 <Bleem> It wants 1::Int to be Fractional. No instance of Fractional Int
18:26:42 <iqubic> Ertes, this travesal thing is being a really pain in the butt.
18:26:53 <iqubic> I found this however: https://queertypes.com/posts/37-functor-traverse-fold-tree.html
18:27:24 <iqubic> Just to teach me what a traverse function should look like.
18:28:04 <ertes> iqubic: i'll give you this much: you're going to need to study lenses
18:28:19 <iqubic> I figured that out already.
18:28:23 <mcbears> Bleem: The problem is that once you pass in (+) :: Num a -> a -> a -> a, `a` is fixed at a certain type, so `f` can only be applied to the same `a` within the function. the fractional thing is a bit of a red herring
18:28:33 <mcbears> What you need is a rank 2 type
18:31:50 <iqubic> How do you tell ghci that you want to use RankNTypes?
18:31:54 <Bleem> Oh interesting. where do I need this rank 2 type?
18:32:01 <mcbears> :set -XRankNTypes
18:32:02 <Bleem> @mcbears
18:32:02 <lambdabot> Unknown command, try @list
18:32:33 <mcbears> assuming you're going to pass in something like Num a => a -> a -> a
18:33:09 <mcbears> your function would be something like (Num s, Num t) => (forall a. Num a => a -> a -> a) -> (s, t) -> (s, t) -> (s, t)
18:34:47 <Bleem> Ah thanks! That works
18:35:03 <iqubic> But you can generalize that.
18:35:10 <mcbears> mhm!
18:35:38 <mcbears> Here's a simpler example of rank n types
18:35:47 <iqubic> You can have the function return something of type b if you want and have the final result be (b, b)
18:36:48 <iqubic> ghci is not accepting this: let combinePairs :: (forall a. => a -> a -> b) -> (l, r) -> (l', r') -> (b, b) = \f (l, r) (l', r') -> (f l l', f r r')
18:37:06 <iqubic> even though I have :set -XRankNTypes 
18:37:11 <mcbears> > let f :: (forall a. a -> a) -> Int -> Char -> (Int, Char); f g i c = (g i, g c) in f id 5 'a'
18:37:13 <lambdabot>  (5,'a')
18:37:25 <iqubic> error: parse error on input ‘=>’
18:37:41 <mcbears> Well there's nothing on the left of your =>, yeah
18:37:56 <iqubic> I put forall a.
18:38:16 <mcbears> Right, but => expects a constraint on the left hand side. If there's no constraint, there's no need for it
18:39:49 <iqubic> Now I get this error if I remove '=>' http://dpaste.com/27C3NMJ
18:40:26 <iqubic> Why is that?
18:41:20 <mcbears> Yeah, there's a couple other things wrong with your definition :) You're using the syntax `let a :: T = b`, which doesn't work. You can do `let a = b :: T` or `let a :: T; a = b`
18:41:21 <iqubic> ghci is not playing nicely with me.
18:41:27 <MarcelineVQ> because even without forall at all your line isn't correct haskell
18:42:02 <iqubic> MarcelineVQ: I see.
18:42:24 <iqubic> And now I have a bunch of other errors because my fuction doesn't actually work.
18:42:53 <mcbears> Also your `f` expects its parameters to be the same type, but you give it an `l` and an `l'`, then an `r` and an `r'`
18:43:15 <iqubic> Ah, I see.
18:43:56 <mcbears> That's what you can gather from the "Couldn't match expected type `l` with actual type l'" message
18:44:38 <iqubic> Yeah.
18:44:50 <iqubic> Is there a way to write this so that it works?
18:45:20 <iqubic> got it.
18:45:27 <mcbears> nice!
18:45:43 <iqubic> http://dpaste.com/22ZMB11
18:46:20 <ertes> note that a function of type (forall a. a -> a -> b), is practically a constant function
18:46:56 <iqubic> And it doesn't work
18:47:50 <ertes> iqubic: you can only pass it a constant function
18:48:15 <ertes> a function of type (forall a b. a -> b -> c) has to be constant
18:48:46 <iqubic> What does that mean?
18:49:22 <Bleem> oh, could this really be generalized? I could replace Num with Monoid and have f = mappend, but could one construct a general function?
18:50:07 <iqubic> Is it possible to write a function like this: combinePair (+) (1::Int, 1.5) (1::Int, 1.5) = (2::Int, 3)?
18:50:42 <iqubic> s/combinePair/combinePairs
18:51:04 <mcbears> (forall a b. a -> b -> c) says this function can take any two things of type a and b at all, and returns some other unrelated type c. when you have two things that you don't know anything about, you can't really decide what to do based on what they are. so in effect you just have to take an `a` and a `b` and return the same `c` every time
18:51:17 <Bleem> I just called it lift2 from wiki.haskell.org/Lifting
18:54:31 <mcbears> iqubic: yes, the type I posted earlier would work for that: (Num s, Num t) => (forall a. Num a => a -> a -> a) -> (s, t) -> (s, t) -> (s, t)
18:55:46 <mcbears> whoops. iqubic: yes, the type I posted earlier would work for that: (Num s, Num t) => (forall a. Num a => a -> a -> a) -> (s, t) -> (s, t) -> (s, t)
19:07:21 <Lazersmoke> Holy shit, GHC 8's custom type errors are *beautiful* https://imgur.com/hjSFFGg
19:07:42 <Lazersmoke> once I added them I literally solved the problem like 20 seconds later
19:07:47 <Lazersmoke> new favorite feature
19:10:51 <Lazersmoke> shoutout to lexi-lambda for IxpertaSolutions/freer-effects #48 for the original inspiration
19:14:44 <lexi-lambda> Lazersmoke: :)
19:14:53 <rotaerk> hmm in a cabal file, what are the things called that are either library or executable? targets?
19:15:15 <lexi-lambda> now, if only that PR actually got merged…
19:17:25 <rotaerk> hmm I guess they're "packages", though what if the cabal file builds multiple things... is it building multiple packages?
19:17:37 <rotaerk> or is it one package that contains a library and an executable
19:18:08 <Lazersmoke> one cabal file is one package
19:18:10 <MarcelineVQ> a cabal file is a package
19:18:57 <rotaerk> k
19:18:57 <Lazersmoke> you can have one or zero libraries per package, and zero to infinity executables, and zero to infinity test suites
19:19:03 <MarcelineVQ> rotaerk: each section like that in a cabal file is called a stanza, target is a good word though
19:19:12 <rotaerk> k thanks
19:24:10 <jle`> Lazersmoke: nice :)
19:24:24 <jle`> whenever i see it used it always is pretty cool
19:25:23 <jle`> also i didn't realize lexi-lambda was on this channel; that is also awesome
19:26:24 <lexi-lambda> I don’t really ever read this channel unless I get pinged.
19:26:45 <lexi-lambda> but yes, I am technically here!
19:26:54 <jle`> :D
19:27:25 <jle`> this is like when i found out that randall munroe used to idle here but never said anything
19:32:05 <lexi-lambda> I don’t think I’m quite as important as randall munroe, but I appreciate the sentiment :p
19:38:44 <alx741> hello everyone. I would like to have a typeclass that ensures its instances offer a numeric value (constrained by 'Num'), but when I attempt to instantiate it, I get a rigid type bound error
19:38:59 <alx741> this is what I have: http://sprunge.us/Cbde
19:39:56 <lyxia> alx741: the type of number says the caller can choose a and b independently
19:40:00 <alx741> Is there a relatively simple solution (without a lot of trickery or substantial change?)
19:40:16 <lyxia> alx741: but in your implementation you are assuming b ~ a ~ MyData
19:40:31 <mcbears> fromIntegral will do it
19:40:58 <lyxia> uh b ~ Int
19:41:22 <lyxia> mcbears++
19:42:37 <alx741> lyxia, mcbears: it did! Is it possible to extend this so instead of a Num constraint I have another typeclass in there?
19:43:44 <alx741> say for instance I have 'class MyClass a where...' and want the offending function to be 'number :: MyClass b => a -> b' 
19:44:49 <lyxia> what happens if you try?
19:44:51 <mcbears> Nothing to stop you from doing that as long as you alter the MyData instance appropriately
19:48:51 <alx741> Hmm, this is what I get: http://sprunge.us/XJBP
19:50:21 <mcbears> someOtherF is expecting to return something with a MyClass1 instance. you return an Int, which isn't an instance of MyClass1
19:51:54 <alx741> oops, sorry about that, I was thinking this instead: http://sprunge.us/eWcQ
19:55:15 <mcbears> ah, this is the same problem you had originally: the type of someOtherF says it can return any instance of MyClass1, so the caller gets to decide. But your implementation always returns a MyData
19:57:47 <alx741> exactly, how can I do that? after all, If I would have another instance like `instance MyClass1 (Int, Int) where ...` then making '(Int, Int)' an instance of MyClass2 will produce the same problem
19:59:12 <alx741> I can't really think of an instance of MyClass2 that doesn't hit that issue actually...
20:03:55 <lyxia> you really can't
20:04:51 <alx741> In the end, what I'm wishing for is a way of ensuring that a datatype will have a piece of data of some arbitrary class. Is that possible with some other mechanism?
20:05:25 <lyxia> You might be looking for existential types. But they're also often a code smell.
20:06:50 <alx741> Will take a look at existential types. Maybe I'm just striving for too much generalization... 
20:07:01 <alx741> mcbears, lyxia: thanks a lot guys!
20:07:01 <mcbears> Yeah, you can technically alter someOtherF to return an existential type instead, which inverts the "who gets to choose what this type is" thing, but it probably wouldn't be very useful
20:09:12 <lyxia> They arise when doing OOP in Haskell.
20:16:32 <iqubic> So I went out to dinner, and now I'm back
20:17:02 <iqubic> Still trying to write an indexed traversal for the chars in a string
20:17:21 <erisco> a fold with index?
20:18:39 <jle`> alx741: simple fix would be number (MyData val _) = fromIntegral val
20:19:03 <jle`> oh didn't see your second paste
20:19:06 <iqubic> erisco: I'm trying to do this on my own as a learning excercise. Please only give me help when I explicitly ask for it.
20:19:55 <jle`> alx741: yes the type you gave is fundamentally wonky
20:19:58 <jle`> `someOtherF :: MyClass1 b => a -> b`
20:20:10 <jle`> basically `someOtherF x :: forall b. MyClass1 b => b`
20:20:19 <iqubic> That's a weird type sinature.
20:20:23 <jle`> meaning that `someOtherF x` can be made to be any instance of MyClass1 b that the caller asks
20:23:11 <alx741> jle`: In which case there is no possible instance for MyClass2 of a particular type that works, apparently
20:23:28 <jle`> alx741: this is basically unfulfillable because there is no way from the MyClass1 instance to generate a value of type forall b. MyClass1 b => b
20:23:44 <jle`> just like there's no possible value of type `forall a. Show a => a`
20:24:00 <jle`> in contrast, there do exist values of type `forall a. Num a => a`
20:24:11 <iqubic> There do?
20:24:13 <jle`> and like, `forall m. Monoid m => m`
20:24:34 <jle`> mhm, there are actually an infinite number of unique values of type forall a. Num a => a, and of forall m. Monoid m => m
20:24:40 <iqubic> What makes Show different?
20:24:50 <jle`> but, there are no non-bottom values of type, say, forall a. Show a => a
20:25:03 <iqubic> Why not?
20:25:07 <jle`> iqubic: well, the Monoid and Num typeclass includes methods to generate values of any instance
20:25:14 <jle`> mempty :: forall m. Monoid m => m
20:25:25 <jle`> fromInteger 1 :: forall a. Num a => a
20:25:36 <jle`> but the Show typeclass has no method that can fulfil the same role
20:25:39 <iqubic> :t fromInteger
20:25:40 <lambdabot> Num a => Integer -> a
20:25:46 <jle`> it just has things like show :: Show a => a -> String
20:26:00 <iqubic> What the heck does fromInteger actually d?
20:26:05 <iqubic> s/d/do/
20:26:17 <jle`> every Num instance provides it when defining the instance
20:26:27 <jle`> but it lets you convert any Integer to a value of your Num instance
20:26:58 <iqubic> Ah. I see.
20:27:15 <iqubic> > fromInteger 1 :: Complex Int
20:27:17 <lambdabot>  error:
20:27:18 <lambdabot>      • No instance for (RealFloat Int)
20:27:18 <lambdabot>          arising from a use of ‘fromInteger’
20:27:28 <iqubic> Err...
20:27:43 <jle`> instance RealFloat a => Num (Complex a)
20:27:49 <jle`> so 'Complex Int' does not have a Num instance
20:27:58 <jle`> > fromInteger 1 :: Complex Double
20:28:00 <lambdabot>  1.0 :+ 0.0
20:28:14 <iqubic> That's so weird.
20:28:21 <jle`> yeah it's kind of silly
20:28:56 <geekosaur> iirc it's because abs is part of Num and can't work with Complex Int (since abs, in a complex number, is the magnitude and involves trig)
20:28:57 <jle`> alx741: if you edit MyClass1 to provide a method to create a value of any instance, then your 'number' type signature is possible to fulfil
20:29:21 <jle`> geekosaur: yes but that would mean Floating a => ...
20:29:30 <jle`> RealFloat a is for a performance hack i think
20:29:46 <iqubic> It means I can't use the scientific number package from hackage with complex.
20:29:53 <geekosaur> I'm not sure if that's performance or also forbidding Complex (Complex Double))
20:30:04 <jle`> they use a RealFloat method i believe
20:31:06 <geekosaur> yeh, I recall digging through that once
20:31:10 <geekosaur> come to think of it
20:31:26 <jle`> http://hackage.haskell.org/package/base-4.10.0.0/docs/src/Data.Complex.html#magnitude
20:31:41 <geekosaur> I still suspect forbidding a nested Complex is justification for that
20:31:57 <alx741> jle`: how would that be? something like ` pure' :: a ` ?
20:32:13 <jle`> alx741: yeah, fromInteger from Num is another such example
20:32:17 <jle`> as long as the return type is 'a'
20:32:35 <jle`> geekosaur: but, nested complex is a nice way to get quaternions for free, right?
20:33:06 <geekosaur> is it? I thought things didn't quite work out in Haskell
20:33:07 <jle`> ;)
20:33:17 <iqubic> quaternions are rather cool.
20:33:26 <geekosaur> maybe if we had a real numeric hierarchy...
20:33:34 * jle` ¯\_(ツ)_/¯
20:33:49 <iqubic> Are Haskell numbers screwed up?
20:34:01 <geekosaur> depends on what you mean
20:34:16 <jle`> the typeclass hierarchy is often a source of complaint
20:34:27 <geekosaur> Haskell numbers are well structured for computability and compatibility with other languages
20:34:36 <geekosaur> it is not a mathematical hierarchy
20:35:04 <iqubic> Oh, that sucks
20:35:05 <jle`> i mean, we've made some fixes in the name of practicality
20:35:14 <iqubic> We have???
20:35:27 <jle`> but there are still issues where their design has unpractical implications
20:35:31 <jle`> yeah, Num used to require Eq
20:35:40 <erisco> and Show
20:35:49 <geekosaur> and, to be quite honest, as long as Float and Double represent IEEE floating point, they will never quite fit in a proper numeric hierarchy 
20:36:10 <iqubic> > fromIntegral 1 :: Complex (Complex Double)
20:36:12 <lambdabot>  error:
20:36:12 <lambdabot>      • No instance for (RealFloat (Complex Double))
20:36:12 <lambdabot>          arising from a use of ‘fromIntegral’
20:36:26 <iqubic> Looks like that's not a thing.
20:36:26 <erisco> I don't think it is that hard
20:36:43 <erisco> stop pretending things are one kind of number when they're not
20:37:27 <iqubic> erisco: I was referring to the nested complex thing I just tried.
20:38:30 <erisco> if we accepted Int is bounded, or is modulus whatever, and has NaN, we'd have better programs
20:39:17 <iqubic> Haskell doesn't have NaN?
20:39:38 <jle`> haskell has IEEE floating points so so those types have NaN
20:56:22 <mmaruseacph2> > round (1/0)
20:56:25 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
20:56:45 <iqubic> The hell is that???
20:56:55 <mmaruseacph2> > 1/0
20:56:57 <lambdabot>  Infinity
20:57:19 <geekosaur> :t round
20:57:21 <lambdabot> (Integral b, RealFrac a) => a -> b
20:57:23 <mmaruseacph2> it's 2^power - 1, as Haskell rounds Infinity to that
20:57:24 <geekosaur> failure to deal with inf and nan because they can't be represented in the target type
20:57:45 <geekosaur> but Integer doesn't have a bound
20:57:56 <geekosaur> and defaulting gets you Integer
20:58:21 <erisco> so, we don't know all the digits of infinity, but it definitely starts with 1797…
20:58:44 <jle`> yeah the most significant digit is obviously the easiest to guess
20:59:22 <jle`> also benford's law tells us that 1.. is a good guess for the first digit of infinity
20:59:29 <iqubic> LOL
21:00:33 <u-ou> in what base
21:01:28 <erisco> all bases are base 10
21:01:43 <jle`> benford's law is true in all bases
21:01:44 <geekosaur> if it's base infinity then it's exactly 1 :p
21:02:04 <u-ou> 10
21:02:10 <MarcelineVQ> coincidentally -1 is a good guess for the numerator of the sum of infinity
21:03:11 <u-ou> couldn't it just be 1 with infin. zeroes after it
21:03:22 <u-ou> in base not infinity
21:03:49 <u-ou> I don't know about this 1797 business
21:04:49 <erisco> well that's what you get when you round it to the nearest whole number
21:05:31 <u-ou> I guess there are different infinite values then
21:05:50 <MarcelineVQ> possibly an infinite amount of them
21:06:02 <u-ou> probably
21:06:03 <MarcelineVQ> or 7
21:06:18 <u-ou> or infinity - 1
21:07:11 <u-ou> how does haskell work out 1797
21:07:16 <u-ou> lol
21:07:32 <u-ou> it is a random infinite value?
21:07:39 <u-ou> > round (1/0)
21:07:41 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
21:07:46 <u-ou> obviously not
21:07:53 <erisco> how scientific of you
21:10:20 <erisco> > length (show (round (1/0)))
21:10:23 <lambdabot>  309
21:10:52 <geekosaur> 1/0 defaulted to Double, then using the RealFrac instance to get properFraction (see discussion in Prelude)
21:11:30 <jle`> > properFraction (1/0)
21:11:33 <lambdabot>  (179769313486231590772930519078902473361797697894230657273430081157732675805...
21:11:35 <jle`> > snd $ properFraction (1/0)
21:11:38 <lambdabot>  0.0
21:11:42 <jle`> fair
21:12:49 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.10.0.0/src/GHC-Float-RealFracMethods.html#line-233
21:13:23 <jle`> what's modern way to write extensible plugins for haskell programs these days?
21:13:56 <jle`> i have half a mind to just shell out to external scripts
21:14:21 <rotaerk> MarcelineVQ, hmm, actually, just noticed there's a setting called "dante target".  I can pass the name of my exe stanza to it, to be passed to cabal repl
21:14:46 <rotaerk> thing is I don't want to have to manually change that setting every time I decide to work on a different part of the project...
21:15:01 <rotaerk> seems like it'd ideally be somehow based on which file I'm looking at
21:23:08 <benzrf> mrw floating point numbers: 0.0
21:26:46 <jle`> i'm going to shell out to external scripts
21:26:52 <jle`> and parse their stdout
21:27:06 <jle`> it's the unix way(tm) isn't it
21:35:06 <rotaerk> MarcelineVQ, ah. directory local variables solves that I think
21:49:52 <iqubic> jle`: I think that's the unix way yes.
21:54:56 <Draggor> I have this QuickCheck-2.10.0.1-DTIBC3CyU6p3h4xSnOjkg1 is unusable due to shadowed dependencies:
21:55:01 <Draggor> random-1.1-DtLcP2Z2iOOC0RwcSmXjBK tf-random-0.5-ABDhxe3mXYlHUEE5hzgewx
21:55:20 <Draggor> Is this something that's not a problem on haskell platform 8.2.0?
21:55:34 <Draggor> (I'm on 8.2.1 in this case)
21:57:02 <kadoban> Draggor: Hm, I think I saw a bug report in ... maybe Cabal about that, let me see if I can find it again
21:57:15 <Draggor> I saw one that had comments up through 3 days ago yeah
21:58:19 <kadoban> Oh okay, yeah. I don't know more than the issue will say personally.
21:58:22 <Draggor> Also: how does one uninstall haskell platform?  I grabbed the .tar.gz and it's got an installer sh script
22:01:54 <Draggor> In particular I'd like to try this: https://github.com/jtdaugherty/tart (I'm encountering errors in attempting that)
22:14:00 <dsal> @pl (\c -> c ^ p)
22:14:01 <lambdabot> (^ p)
22:18:44 <cocreature> Draggor: did you recently change your GHC installation? I’ve encountered that problem when I switched to a GHC that was built with slightly different options
22:23:32 <jchia_> Is it normal for 'stack ghci' to compile my project's code every time instead of just once? Here's the transcript: http://lpaste.net/5462933164806635520 Every time I run 'stack ghci', I get messages that it's compiling this and that and for a large project, it takes a long time.
22:24:08 <cocreature> jchia_: try "stack ghci --ghci-options=-fobject-code"
22:26:06 <jchia_> cocreature: It doesn't help. (I've updated the lpaste.)
22:26:20 <jchia_> I thought the 'i' means interpretation. I don't understand why interpretation requires compilation
22:28:17 <cocreature> it compiles to bytecode
22:53:47 <dsal> @pl (\l -> sum $ map f l)
22:53:47 <lambdabot> sum . map f
22:53:55 <dsal> Weird, I tried that.
22:54:07 <dsal> Guess not.
22:55:14 <jcarpenter2> hey, i just did: cabal update; cabal sandbox init; cabal install idris but i'm getting the error "cabal: The following packages are likely to be broken by the reinstalls:
22:55:14 <jcarpenter2>  HTTP-4000.3.3"
22:55:25 <jcarpenter2> i thought installing in a sandbox was supposed to prevent those kinds of errors!
22:55:48 <cocreature> jcarpenter2: just nuke the sandbox of your current project and make a new one
22:55:57 <cocreature> i.e., "cabal sandbox delete && cabal sandbox init"
22:56:29 <jcarpenter2> cocreature: i just did that, it's a fresh sandbox
22:57:04 <cocreature> jcarpenter2: huh, do you have HTTP installed globally somehow? what’s the output of "ghc-pkg list"?
22:57:19 <jcarpenter2> ok so i did "cabal install idris --avoid-reinstalls" as per a stackoverflow answer, and it is installing...
22:57:36 <jcarpenter2> i literally just ran "sudo apt install haskell-platform" (i'm on debian)
22:57:49 <jcarpenter2> it should be completely pristine
22:58:16 <jcarpenter2> ghc-pkg list: https://pastebin.com/HAFaHgEM
22:58:35 <cocreature> that’s not the full output, at least the first line is missing
22:58:59 <jcarpenter2> oh my bad https://pastebin.com/5G6ah8Ka
22:59:21 <cocreature> looks like the haskell-platform package on debian includes HTTP and sandboxes don’t exclude the global package db
22:59:31 <cocreature> I would recommend to just install GHC and cabal instead of the haskell-platform
22:59:40 <jcarpenter2> okay
23:04:27 <cheater> same
23:56:06 <olligobber> does ghc have a flag that will spot dumb mistakes like "if a then b else b"?
23:57:17 <kadoban> olligobber: Sounds a bit like a job for hlint if ghc can't do it.
23:57:41 <olligobber> kadoban, atom probably has a linter, yeah
23:59:23 <cocreature> fwiw that’s not a noop, it should force the evaluation of "a"
23:59:55 <srhb> But a linter should suggest seq a b instead, I hope :P
