00:00:22 <koz_> Mealy machines made much more sense, but that's because I know what finite-state transducers are all about.
00:00:39 <koz_> But Moore machines are some kind of restricted finite-state transducer and I was having some trouble following what the hell they do.
00:01:29 <cocreature> basically moore machines emit outputs in states while mealy machines emit outputs on edges
00:01:48 <cocreature> so for a moore machine your output is determined by the current state
00:01:59 <cocreature> for a mealy machine it’s determined by the current state and the next input
00:02:02 <koz_> Ah, OK, that makes sense.
00:02:16 <koz_> What's the advantage of restricting to Moore machines?
00:02:23 <koz_> (I assume efficiency or something?)
00:06:23 * hackagebot urlpath 6.0.3 – Painfully simple URL deployment. – https://hackage.haskell.org/package/urlpath
01:52:00 <ongy> is there a good example of how to wrap kernel style lists in the FFI? I'm thiking 1 generic function to get all elements of a list as `[Ptr List]` and then something that wraps those, applying pointer arithmetic to get the containing struct
02:01:37 <ADG> I have problem taking input a tree, can someone help me https://hastebin.com/vafaxumumu.hs
02:03:15 <cocreature> ADG: I’m not sure what exactly the problem is. the comments suggest that you’re having problems with addChild but that function already has an implementation. does the current implementation not do what you’d like it to do? if so what does it currently do and what would you expect?
02:04:58 <cocreature> ADG: one problem is probably that "Map.adjust" will return the original map if the key is not present. since you’re starting with an empty map that means that you will never insert anything
02:05:24 <ADG> I'm not sure if this is the correct way
02:05:54 <cocreature> I can’t tell you if it’s the correct way if you don’t explain what you would like to do
02:08:09 <ADG> yes you are correct that i start with empty map and still wish to insert children
02:08:47 <cocreature> alright, you are going to want to use "insertWith" instead of "adjust" for that
02:08:58 <ADG> oh thanks!
02:09:35 <cocreature> as to the first comment on how to keep the state, just write a recursive function that passes the state around instead of using replicateM_
02:10:24 <ADG> thankyou!
02:22:53 <ADG> @cocreature How does this look https://hastebin.com/qonoteqito.hs, it workd btw
02:22:53 <lambdabot> Unknown command, try @list
02:23:07 <ADG> ping cocreature
02:24:36 <cocreature> ADG: looks pretty good! I would probably replace the guards in `insertEdges` by a pattern match and maybe remove the `getVal` field in Node since that is already represented by the key in the map
02:24:52 <cocreature> oh nvm it isn’t
02:25:02 <cocreature> getVal just seems to always be 0
02:25:40 <ADG> that is my next task that i am doing
02:25:51 <ADG> taking an input array and initializing
02:52:06 <Habib> Does anyone know why I've got this weird type mismatch? I don't really know how to succintly describe it, so here's an lpaste link - http://lpaste.net/358176.
02:53:50 <cocreature> Habib: looks like you somehow managed to end up with two versions of wai. how are you building your project?
02:56:19 <Habib> I'm using Stack. I came across someone else who has a similar problem and has two versions of WAI installed, but running stack exec ghc-pkg check, stack exec ghc-pkg list wai, and stack exec ghc-pkg check hasn't revealed anything weird, I don't think. I even rm -rf'ed the .stack-work directory to start the build again. The thing is, stack build doesn't give me this error, but hdevtools check does.
02:56:56 <cocreature> sorry I have no idea how hdevtools works
02:58:12 <Habib> Do you know how to authoritatively check that I've only got the one version of WAI? I mean, it's referencing the right version I've got in my build-depends, so even if that were the case, I don't know why it'd break. Changing an import from Network.Wai to Network.Wai.Internal fixes it.
03:01:15 <statusbot> Maintenance update: Hackage restarting now! -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/59abc846d031972d050001c3
03:01:15 <cocreature> maybe hdevtools has some kind of verbose mode to see how it invokes ghc
03:01:40 <Habib> Good idea, I'll check.
03:03:22 <Habib> Huh, it has a debug output option, but it just outputs the Cabal file, Stack file, and the socket file (it runs a persistent server) before running the check.
03:10:20 <cocreature> Habib: do you have wai installed outside of stack? i.e. in ~/.ghc or globally?
03:11:54 <Habib> No, I use stack for all of my Haskell development. I've just double-checked, and ~/.ghc just contains my GHCi history and some empty package.cache.lock files.
03:12:16 <statusbot> Maintenance update: Hackage maintainenance completed -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/59abc846d031972d050001c3
03:15:24 <Habib> Okay, I've rm -rf'd all the cached data in ~/.stack except for my config, downloaded templates and my Hackage credentials. I've removed .stack-work directory, too, rebuilding from scratch. Let's see how it goes.
04:10:04 <joel135> I want to make a small geometry desktop application that draws points and allows points to be dragged around using a multitouch screen. What libraries can be used?
04:12:10 * hackagebot aivika-distributed 0.7.3 – Parallel distributed discrete event simulation module for the Aivika library – https://hackage.haskell.org/package/aivika-distributed
04:49:31 <hexagoxel> there is no way to get any type witness out of wild-card matching on a GADT, is there? 
04:52:47 <hexagoxel> or any form of matching all of the GADT's (remaining) constructors whose type argument belongs to some class/type family.
04:57:25 <lyxia> maybe you can refactor your GADT
05:11:33 <fnurglewitz> anyone knows what could be causing these error messages? https://pastebin.com/Xz0Yr8i1
05:12:09 <fnurglewitz> (I'm using stack)
05:12:56 <Axman6> fnurglewitz: can you point out what you've changed?
05:13:22 <fnurglewitz> just added a shortcut, that's the problem :/
05:13:42 <fnurglewitz> it looks like it's trying to use xmonad-contrib from a different snapshot
05:20:49 <ongy> can I somehow get the thread Id of the current OS thread something is executed in?
05:36:37 <BadAtRecursion> Hello, does anyone know how I should go about splitting a string into a list of words? I have managed to split the string into words separated by whitespace but I'm not sure how I can create a list with the words instead
05:39:30 <Fendor> BadAtRecursion, what do you mean  a list of the words? something like [String]? then `words` would already do that
05:39:36 <Fendor> > words "Hello, World!"
05:39:38 <lambdabot>  ["Hello,","World!"]
05:40:27 <BadAtRecursion> Fendor exactly, but I'm not sure how to implement words into my function. I keep getting compile errors. 
05:41:07 <Fendor> BadAtRecursion, you could show us the function via pastebin, maybe somebody could help you understand your problem?
05:42:44 <BadAtRecursion> Fendor : https://pastebin.com/b0AvUU4H
05:42:57 <BadAtRecursion> So that doesn't compile obviously
05:43:04 <BadAtRecursion> but I'm not sure how to implement words there so it does?
05:43:24 <BadAtRecursion> if I just return a regular string it works
05:44:36 <Subeff> Hey guys I wanted to use the `checkers` library to validate one Applicative instance that I created, it is pretty straight forward. The type is defined like this `data List a = Nil | Cons a (List a)`, i load the file in ghci and it works, however I am not sure how to actually test it with quickCheck, I believe it should be something like `quickBatch $ applicative (undefined :: ThisIsWhatIMiss)`. Any suggestions :)
05:45:04 <Fendor> well, lets look at the part `x:splitter xs`
05:45:43 <Fendor> what type does `x` have and what does `splitter xs` return?
05:46:24 <lyxia> BadAtRecursion: Use the break function instead of simple pattern matching to break on whitespace
05:47:03 <Fendor> lyxia, if it is for practice, i think the manual pattern matching and recursion is ok
05:47:08 <BadAtRecursion> Fendor  I believe x is a char, right, but the function returns a list with strings, so yeah, I get that it doesn't work, but not sure how to get it to do what I want
05:47:17 <BadAtRecursion> yeah it is for practice
05:49:17 <Fendor> BadAtRecursion, before creating an entry for the list, you want to build the whole word. so, you need something to split the string, into a part before a space, and a part after it, hence the recommendation to use break, however, you should implement it yourself for practice
05:49:37 <Fendor> :t break
05:49:39 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
05:50:02 <Fendor> you could implement a function with the same signature like break, as shown by lambdabot
05:50:58 <lyxia> Subeff: applicative (undefined :: List (Int, Int, Int))
05:51:34 <lyxia> this type is an awful hack though.
05:51:47 <Fendor> and as an example, what you are looking for:
05:51:51 <Subeff> lyxia thanks it worked!
05:52:03 <Fendor> > break (\x -> x == ' ') "Hello World"
05:52:06 <lambdabot>  ("Hello"," World")
05:52:35 <Fendor> > break (\x -> x == ' ') "foo bar foo"
05:52:37 <lambdabot>  ("foo"," bar foo")
05:55:05 <Fendor> BadAtRecursion, for your personal implementation you could delete the space immiately
05:55:18 <Fendor> s/immiately/immediately
05:55:31 <lyxia> Subeff: applicative :: _ => m (a,b,c) -> TestBatch    m specifies the applicative type to test, and you also need some concrete types to test the various laws (3 for composition), in practice Int is good enough.
05:57:23 <absence> anyone know what the status is for ghc 8.2 in stackage lts?
05:57:47 <BadAtRecursion> Fendor : but break returns a list tuple? 
05:58:20 <Fendor> BadAtRecursion, yes
05:59:51 <Fendor> BadAtRecursion, in your case it is a tuple of strings, so you can write the signature more concrete like: (Char -> Bool) -> String -> (String, String)
06:03:59 <Subeff> lyxia: Thanks it for the info, got it!
06:06:49 <ga2arch> hi, i'm trying to implement a dsl with the free monad but i want that when the interpreter to be able to yield the execution with the remaining state so that it can be resumed later, what is the best way to add this feature to this code? http://lpaste.net/6074870879550963712 i have no clue how to do it, tried different ways without success.
06:07:10 <ga2arch> *but i want the interpreter 
06:12:07 <marvin2> x@(Constructor _ _ _) <- can someone remind me of the nicer way of writing this?
06:13:43 <byorgey> ga2arch: what state?
06:14:16 <byorgey> ga2arch: I'm only guessing, but perhaps you want to write interpreters to   StateT String IO   instead of just IO?
06:14:22 <Casa> @run 1+1
06:14:25 <lambdabot>  2
06:14:43 <ga2arch> byorgey: my bad, i mean i want to return the rest of the computation
06:15:19 <byorgey> ga2arch: OK, but I don't understand what you mean by "the rest of the computation".  The rest of the computation after what?
06:15:51 <ga2arch> byorgey: you can see at line 69, i want to yield there
06:16:40 <ga2arch> stop the interpreter, await a condition and resume the interpreter with the new data
06:16:54 <byorgey> ga2arch: yes, since you are interpreting into the IO monad, I would expect something there like    input <- nextLine;  next input
06:17:05 <byorgey> sorry, I meant  'getLine'  rather than  nextLine
06:17:28 <byorgey> Java Scanner on the brain
06:17:33 <ga2arch> byorgey: yes but i don't want the interpreter to know how to await the condition
06:18:38 <ga2arch> byorgey: i want to save the continuation and use it to resume
06:19:25 <ga2arch> byorgey: the IO monad is there just to try out the dsl with print
06:20:20 <cocreature> marvin2: x@(Constructor {})
06:21:39 <byorgey> ga2arch: OK, I think I understand what you mean, but I am not sure how to do it off the top of my head.
06:24:51 <marvin2> cocreature thanks!
06:30:36 <Casa> @search java
06:30:36 <lambdabot> Unknown command, try @list
06:30:44 <Casa> @list
06:30:44 <lambdabot> What module?  Try @listmodules for some ideas.
06:30:59 <Casa> @listmodules
06:30:59 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
06:30:59 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
06:32:00 <cocreature> Casa: you can communicate with lambdabot in private messages to avoid spamming the channel
06:32:31 <Casa> @gwiki java
06:32:32 <lambdabot> https://wiki.haskell.org/Applications_and_libraries/Interfacing_other_languages
06:33:18 <Casa> @google fetch
06:33:19 <lambdabot> https://fetchsoftworks.com/
06:34:20 <Casa> @help
06:34:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:34:45 <Casa> @help vixen
06:34:45 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:35:19 <Casa> @list
06:35:19 <lambdabot> What module?  Try @listmodules for some ideas.
06:35:35 <Casa> @vixen
06:35:36 <lambdabot> I can see clearly now... that I was wrong in not acting more decisively and more forthrightly in dealing with Watergate.
06:36:25 <trevortknguyen[m> Could anyone tell me what the typedef "Signal a ~ Time a -> a" means? This is from the Yampas library. I just read LYAH Ch. 1-8 and haven't encountered the tilde character yet.
06:37:24 <Casa> the tilde is for lazy eval, i guess
06:37:40 <phadej> Tilde is type equality
06:37:43 <petercommand> No, that's at type level
06:37:50 <phadej> > :t (a ~ Int) => a 
06:37:52 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
06:37:54 <phadej> :t (a ~ Int) => a 
06:37:56 <lambdabot> error: parse error on input ‘=>’
06:38:03 <phadej> :t x :: (a ~ Int) => a 
06:38:05 <lambdabot> error:
06:38:05 <lambdabot>     • Couldn't match type ‘Expr’ with ‘Int’
06:38:05 <lambdabot>       Expected type: a
06:38:09 <phadej> :t 1 :: (a ~ Int) => a 
06:38:11 <lambdabot> Int
06:38:11 <petercommand> trevortknguyen[m: link to the doc?
06:38:43 <phadej> but in yampa doc it means "denotationally equivalent"
06:39:15 <phadej> i.e. the model is "Time a -> a", but implmentation is (most likely) something else
06:39:40 <trevortknguyen[m> I read it in a paper: www.cse.unsw.edu.au/~pls/thesis/munc-thesis.pdf section 2.4.1 Signal Functions
06:40:29 <petercommand> the ~ should have higher precedence than -> right?
06:40:43 <petercommand> i.e. Signal a ~ (Time a -> a)
06:41:10 <trevortknguyen[m> Oh, I think I made a typo. I should be "Signal a ~ Time -> a"
06:41:40 <phadej> trevortknguyen[m: true, good spot
06:42:25 <trevortknguyen[m> If it means type equality (that's a new concept for me), is it saying that a time-variant signal is a function that takes a time and returns the value of the signal at that time?
06:42:29 <lyxia> Signal a ~ Time -> a   being parsed as   Signal a ~ (Time -> a)   means -> has higher precedence than ~
06:42:43 <petercommand> phadej: what does "denotationally equivalent" mean?
06:43:13 <phadej> petercommand: https://en.wikipedia.org/wiki/Denotational_semantics
06:44:03 <petercommand> how do you decide whether two types are denotationally equivalent?
06:44:43 <phadej> petercommand: in this case, that's definition
06:44:51 <BadAtRecursion> Damn, i really don't know how to proceed with break. How do I go about "splitting" words into a list based on all non alphabetic letters? 
06:45:09 <phadej> BadAtRecursion: check `split` package
06:47:08 <trevortknguyen[m> phadej: thanks for the help!
06:47:42 <phadej> no worries
06:55:20 <Fendor> BadAtRecursion, do you know the functions takeWhile and dropWhile?
06:55:26 <Fendor> :t takeWhile
06:55:28 <lambdabot> (a -> Bool) -> [a] -> [a]
06:55:28 <Fendor> :t dropWhile
06:55:30 <lambdabot> (a -> Bool) -> [a] -> [a]
06:55:45 <Fendor> > takeWhile (\x -> x /= ' ') "Hello World"
06:55:48 <lambdabot>  "Hello"
06:55:57 <Fendor> > dropWhile (\x -> x /= ' ') "Hello World"
06:55:59 <lambdabot>  " World"
06:56:14 <soLucien> hi guys ! I am trying to remind myself some Haskell . I remember that you could create new functions or partially apply functions . I want to create a function last [a] -> a , and i am trying to use (head reverse)
06:56:43 <soLucien> i know that head is [a]-> a, and reverse is [a]->[a]
06:57:06 <soLucien> so it should theoretically work to pipe them
06:57:37 <soLucien> can i write a curried function that would do this ? 
06:57:38 <Axman6> you use . to compose functions
06:57:41 <Axman6> head . reverse
06:57:52 <dminuoso> soLucien, actually "partially applied functions" dont exactly exist. Its better to just think that each function that _appears_ to have multiple functions is actually curried.
06:57:54 <soLucien> okay yes thanks i remember now
06:58:07 <dminuoso> *to have multiple parameters
06:58:22 <Axman6> head reverse says "give reverse as an argument to head", which clearly doesn't have the right type, since reverse has type [a] -> [a], and head expects [a]
06:59:16 <Axman6> also, rull #1 of Haskell: All (I repeat, all) functions take one argument only
06:59:20 <Axman6> rule*
07:00:24 <ongy> :t all -- you sure? :P
07:00:26 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
07:01:37 <Axman6> yep, see, one argument
07:01:57 <Tuplanolla> :k All -- Are you still sure, Axman6?
07:01:57 <Fendor> Axman6, is a function only argument, too?
07:01:58 <dminuoso> Axman6, I have a feeling it was just a word play on "all"
07:01:58 <lambdabot> *
07:01:59 <soLucien> thanks Axman6 !
07:05:57 <dminuoso> Gah. Do people actually write list comprehensions with multiple "terms" in one line?
07:06:12 <dminuoso> Im browsing so much code that is making me claw my eyes out.
07:12:07 <ignamv> dminuoso: for example?
07:12:53 <dminuoso> Right now I just stumbled over this on the wikibooks: pythags = [ (x, y, z) | z <- [1..], x <- [1..z], y <- [x..z], x^2 + y^2 == z^2 ]
07:13:03 <dminuoso> Makes me wish the do notation allowed arrows to be in the other direction
07:14:03 * hackagebot concrete-haskell-autogen 0.0.0.3, product-isomorphic 0.0.1.0, threepenny-editors 0.5.5
07:14:03 * hackagebot  → https://hackage.haskell.org/packages/recent
07:30:05 <byorgey> dminuoso: people do write such code occasionally, if there are just a few short terms.  But (a) people don't actually write list comprehensions all that often, and (b) a lot of times people write them with each term indented
07:30:20 <sternenseemann> is there a package which provides a map like data structure which allows lookup by a value of the stored type
07:30:31 <byorgey> dminuoso: that example is just a toy example to illustrate list comprehensions anyway.  It's a terrible way to generate Pythagorean triples.
07:30:32 <sternenseemann> e. g. I have a type User { id :: Text, name :: Text }
07:30:59 <Axman6> sternenseemann: what operation do you want given that?
07:31:23 <sternenseemann> I want to create a new map giving the accesor, e. g. ID
07:31:25 <dminuoso> byorgey, oh yeah. That's kind of implied by calling it "the brute force approach" :)
07:31:31 <sternenseemann> so I can lookup Users by ID
07:31:42 <lyxia> Data.Map?
07:31:50 <sternenseemann> I think this could be easily done using a wrapper around Data.Map
07:32:12 <byorgey> why do you need a wrapper?  ie. why doesn't Data.Map already do what you want?
07:32:26 <Axman6> I've always wanted a function with type (v -> k) -> [v] -> Map k v
07:32:26 <sternenseemann> because insertion is a bit tedious then
07:32:36 <sternenseemann> Axman6: yeah like that
07:32:45 <sternenseemann> but I guess I can write it by myself
07:32:49 <Axman6> fromListBy or something
07:32:49 <sternenseemann> should be fairly easy
07:32:58 <Axman6> yeah it's pretty trivial
07:33:00 <byorgey> sternenseemann: it sounds like you really don't need a new type, just a utility function like that to make inserting nicer
07:33:12 <Axman6> it's fromList . map (f &&& id)
07:33:50 <sternenseemann> byorgey: yeah
07:34:03 <Axman6> :t (&&&)
07:34:05 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
07:34:21 <sternenseemann> byorgey: I possibly could wrap Map, so I can store (v -> k) and Map k v
07:35:03 <dminuoso> Mmm, the gentle introduction used lex as a simple tokenizer to parse trees in the form of <<2|3>|3>, turns out that the lex tokenizer is too greedy and wont work with any tree other than <1|2>, since it considers >| to be a single token for example
07:35:20 <byorgey> sternenseemann: yes, I see what you mean.  It hardly seems worth it though, since you would have to make a wrapper version of every Map operation you ever wanted to use
07:35:32 <dminuoso> Does this example only work properly for Haskell 98?
07:35:45 <dminuoso> (I mean Im glad that it didnt work properly, because it forced me to learn GHCi debugging a bit)
07:36:07 <byorgey> . o O ( Getter s k -> Getter s v -> [s] -> Map k v )
07:36:20 <sternenseemann> byorgey: I'll think about it
07:37:09 <sternenseemann> byorgey: probably it'd be enough to wrap the define the insertion function curried with the accessor function for every project
07:48:31 <jchia_> Anybody using the package 'store'? (http://hackage.haskell.org/package/store) Am I right that the premise of deserializing with store is that you need to know the number of bytes before you even try to deserialize, so that you can't simply 'decode' to deserialize if the number of bytes is variable? (For example I have a sum type that has a different binary representation depending on which data constructor is used.)
07:55:28 <cocreature> jchia_: I haven’t used store myself but looking at the API I see nothing that requires that you know the size when deserializing
07:55:52 <Axman6> jchia_: I guess the size needs to be the maximum size then?
07:56:18 <jchia_> cocreature: I think the signature doesn't tell you anything about the number of bytes consumed or outstanding.
07:56:20 <Axman6> cocreature: seems you need to know the size when serialising, which sort of implies that
07:57:05 <cocreature> Axman6: I’m not sure it does. the size is used for preallocating the buffer when serialising. I don’t see how that affects deserialization
07:57:19 <Axman6> jchia_: you might find the cborg and serialise packages interesting (the latter being based on the former) - hopefully it'll become the replacement for the Binary package
07:57:24 <dmj`> jchia_: doesn’t seem like you need to know the size when decoding, or encoding
07:57:37 <dmj`> decode :: Store a => ByteString -> Either PeekException a
07:57:38 <cocreature> and the size for serializing can still be dynamic
07:58:13 <Axman6> hmm, and Size a supports dynamic sizes anyway
07:59:00 <jchia_> dmj`: decode doesn't tell you how many bytes were unconsumed. PeekException also doesn't tell you how many bytes were lacking in case there were too few bytes. If deserializing a stream of objects, decode can't help.
07:59:34 <Axman6> serialise has the nice property that it's both space efficient and based on a standard
08:00:08 <dmj`> jchia_: stream parsing is a different thing altogether
08:00:33 <jchia_> dmj`: Well, another way to describe it is that decode requires you to represent the bytecount externally.
08:01:16 <jchia_> dmj`: But if I already hava tag in the binary representation denoting which branch of the sum type is being stored, and each sum type has a fixed byte count, the external byte count is unnecessary and wasteful
08:02:36 <jchia_> cocreature, dmj`: Does decode return the number of bytes consumed or leftover? I think it doesn't and that's the problem.
08:04:42 <jchia_> Axman6: What's problems does binary have that is fixed by serialise? I vaguely remember something about Double?
08:04:49 <cocreature> jchia_: maybe you’re looking for decodeExPortionWith
08:06:24 <dmj`> decode assumes the ByteString you provide is all you want to decode, not that it is some string part of a larger group of ByteStrings that are being streamed in IO, for that you’d need a lower level primitive. 
08:06:26 <jchia_> cocreature: Yeah, that solves part of the problem.
08:06:52 <cocreature> I don’t think store provides a fully incremental interface if that’s what you’re looking for
08:08:24 <dmj`> jchia_: The io-streams parseFromStreamInternal function is a good example, it will step the stream in IO until it is exhausted, applying the parser and handing leftovers correctly.
08:08:38 <jchia_> cocreature: Yeah, I'm looking for an interface that doesn't require me to know beforehand the number of bytes being read and can at least tell me the number of bytes lacking or extra. binary package does that.
08:09:07 <dmj`> jchia_: parseFromStream :: Parser r -> InputStream ByteString -> IO r
08:12:17 <jchia_> dmj`: OK
08:13:08 <dmj`> you’ll want to `catch` (e :: ParseException) though iirc 
08:33:03 <marvin2> > let roundTrip a = read (show a) in roundTrip 10 :: Double
08:33:06 <lambdabot>  10.0
08:40:50 <Philonous> Is there a package that implements sort :: Ord a => Vector a -> Vector a  or something equivalent?
08:42:21 <dmj`> @package vector-algorithms
08:42:21 <lambdabot> http://hackage.haskell.org/package/vector-algorithms
08:42:34 <dmj`> @Philonous I also have a quicksort if you’d like to see it
08:42:34 <lambdabot> Unknown command, try @list
08:43:46 <Philonous> dmj`, It's OK, I just want to have some reasonable sort
08:44:06 <dmj`> Philonous: https://gist.github.com/dmjio/768d6dfff947ca65a1e4449ffe519e38
08:44:26 <Philonous> Thanks
08:46:22 <mightybyte> Is it possible to make your own equivalent to the Show type class?  Or does "deriving (Show)" have special treatment by GHC?
08:47:35 <jollygood2> hello. does haskell support reflection? can I get a list all the top-level variables that start with foo, for example?
08:47:59 <jollygood2> or all the functions that match some signature
08:50:50 <Philonous> mightybyte, Show is treated specially wrt. deriving, but you can write your own derivable class by using -XDeriveAnyClass 
08:51:28 <Philonous> mightybyte, GHC will insert an empty instance declaration when the class is derived, so you have to fill it in with defaults (possibly via Generics) at the class definition site
08:53:35 <Philonous> mightybyte, This works for example with Exception from Control.Exception 
08:55:13 <mightybyte> Philonous: Cool, thanks.
08:58:15 <Philonous> jollygood2, Definitely not at run time, no. You might be able to do something like that using Template Haskell. 
09:11:51 <eschnett> @hoogle data FSum f g a = FSum (f a) (g a)
09:11:51 <lambdabot> package base
09:11:51 <lambdabot> package bytestring
09:11:51 <lambdabot> package containers
09:13:02 * hackagebot jukebox 0.3, libgraph 1.14, salve 0.0.2, twee 2.0
09:13:02 * hackagebot  → https://hackage.haskell.org/packages/recent
09:20:35 <MichaelBurge> Do Agda or Idris embed themselves easily into Haskell programs? It'd be convenient to take a data structure in Haskell, and prove its correctness in another language without having to duplicate too much work.
09:23:19 <lyxia> https://github.com/antalsz/hs-to-coq sounds relevant, for another language.
09:38:13 <eschnett> i have a data type definition, and i think it might exist in a library somewhere. hoogle isn’t very useful — it lists libraries, but doesn’t tell me what the type is called there
09:38:14 <eschnett> @hoogle data Sum m f g a = Sum (m a -> (f a, g a))
09:38:15 <lambdabot> package base
09:38:15 <lambdabot> package bytestring
09:38:15 <lambdabot> package containers
09:38:39 <eschnett> is there a better way to look for this?
10:13:12 * hackagebot salve 0.0.3, yi 0.15.0, yi-core 0.15.0, yi-dynamic-configuration 0.15.0, … and 12 more
10:13:12 * hackagebot  → https://hackage.haskell.org/packages/recent
10:16:07 <jle`> eschnett: hm, hoogle wouldn't search for data type definitions like that
10:16:18 <jle`> maybe type signatures like 'm a -> (f a, g a)'
10:16:35 <jle`> but as far as I know, there is no popular library with that type
10:16:48 <jle`> it looks like you're representing natural transformations between 'm' and products of f and g
10:16:57 <jle`> (so it's kind of weird to call it Sum)
10:17:07 <jle`> type Sum = m ~> (f :*: g)
10:22:29 <shafox> How can I use pipes and pipes-group to group a xml file.  My xml file is a media wiki data dump: https://gist.github.com/shadow-fox/1873170c9ae35659b5a0dec77c767e58 . I want to preserve the siteinfo  node and also the page node. 
10:27:15 <AWizzArd> Android itself already is a linux. GHC is available for Linux. Is there an effort that tries to make ghc natively available under Android?
10:27:33 <dminuoso> AWizzArd, GHC is not available for Linux in the same sense.
10:27:46 <AWizzArd> No?
10:27:59 <dminuoso> AWizzArd, when people say that Android itself is a linux it just means it uses the raw linux kernel.
10:28:11 <hpc> android is linux in the same way that mac is bsd
10:28:27 <dminuoso> AWizzArd, when people say that GHC is available for Linux, it means there are implementations that run on most of the popular linux distributions.
10:28:30 <AWizzArd> With those new mobile phones it’s possible to plug them into a docking station and have a desktop-like UI. With an octacore phone with 6 GB RAM I think we are in principle very close to be able to sit at home and hack Haskell on Android.
10:30:24 <dminuoso> AWizzArd, Android cant even execute ELF files, it wouldnt know what they are.
10:31:22 <dminuoso> In other word: Android wont run any "linux program" casually.
10:31:28 <AWizzArd> Right.
10:31:48 <elpfen> Is there a "do nothing" io action? Or is that an anti-pattern?
10:31:57 <hpc> return ()
10:32:32 <elpfen> Hmm. The issue is that I'm trying to use it with either, and the Just action is syste
10:32:35 <elpfen> m
10:36:12 <barrucadu> What type do you need?
10:37:44 <elpfen> IO GHC.IO.Exception.ExitCode... Maybe I can just give it ExitSuccess
10:39:57 <dminuoso> Got a question about this code from the gentle introduction: https://gist.github.com/anonymous/5aae0323cb8f3ce418e0470e11960300
10:40:24 <dminuoso> It took me a while to figure out what that list concatenation was about, but it seemed like a weird way to describe an alternative action should the first list comprehension fail 
10:41:47 <dminuoso> Is this kind of style regular or are there better more expressive ways to describe this kind of "if it parses do this, else do this" ?
10:43:11 <geekosaur> Gentle Introduction predates Applicative
10:43:16 <cocreature> shafox: what have you tried? where did you get stuck?
10:43:25 <geekosaur> and that code looks to me like it's using a list comprehension to simulate it
10:47:07 <joemar> hey
10:47:50 <dminuoso> geekosaur, okay that's interesting. Can you throw me a bone how an applicative would be helpful in here?
10:47:51 <Philonous> dminuoso, It's not either or, it will try both parses. Also, each of the recursive calls may return more than one parse. It collects all of them in a big list
10:47:52 <geekosaur> dminuoso, so I think more modern code would make use of <|>, but back when GI was written that didn't exist
10:48:37 <geekosaur> but also what Philonous said, neither one will be "if then" or "either or", it tries all of them
10:49:06 <geekosaur> (Applicative just as much as the list comprehension form; you need to use the full monadic interface to do better than that)
10:49:08 <dminuoso> Oh you meant Alternative rather than Applicative
10:49:41 <geekosaur> Alternative is a subcase thereof, yes. Thw two together are probably best understood in terms of parsing since "some" and "many" don't fit the usual view of Applicative
10:50:45 <Philonous> I think really modern Haskell might make use of ApplicativeDo , which looks similar to this list comprehension. 
10:51:08 <Philonous> (Do notation is often easier to read than Applicative) 
10:52:04 <dminuoso> geekosaur, trying to wrap my head around what you suggested. Which Alternative would that be? Maybe?
10:52:30 <Philonous> dminuoso, List 
10:52:34 <geekosaur> ApplicativeDo is still a bit weird though
10:52:35 <Philonous> I.e. []
10:52:53 <geekosaur> and yes, just as the list comprehension is using lists, the Applicative+Alternative version would be using lists
10:52:57 <Philonous> Yeah, I don't know how ApplicativeDo interactis with pattern failures
10:53:10 <Philonous> I have to say, I like the code as it is. 
10:53:56 <absence> anyone know what the status is for ghc 8.2 in stackage lts?
10:54:26 <Philonous> absence, It's in the nightlies, no LTS has been released with it yet. 
10:54:52 <geekosaur> check what packages are still missing in the nightlies, I suspect
10:55:10 <absence> Philonous: that much i know, i wonder if there's anything holding it up, or if it's just a matter of waiting for it to mature
10:55:45 <Philonous> absence, Ah, sorry, I that I that I don' know either 
10:56:17 <Philonous> (Ooops, now idea how that happened)
10:58:39 <absence> ok thanks though
10:58:53 <dminuoso> Seeing as <|> = (++) for lists, how would that change anything?
10:59:18 <absence> geekosaur: yeah, not so easy to tell from this list though: https://www.stackage.org/diff/lts-9.3/nightly-2017-09-03
11:00:05 <dminuoso> Although I do begin to see that <|> just encapsulates the generalization of combining trying to reads a leaf, and trying to reads a branch
11:01:45 <Philonous> dminuoso, If you keep it specialized for List it doesn't change anything (which is kinda the point). But you can instantiate it at different Alternatives and get those for free 
11:02:47 <dminuoso> Alright great. Alternative is simple, haskell really isn't so difficult after all.
11:09:17 <Joemar> Anyone know any good irc clients for iphone
11:11:19 <dsal> Joemar: I use irccloud for phone and desktop
11:13:27 * hackagebot rss-conduit 0.4.0.0 – Streaming parser/renderer for the RSS standard. – https://hackage.haskell.org/package/rss-conduit
11:15:19 <joemar> H
11:20:55 <stevenxl> Hi folks. I am trying to check out the kind of an infix type constructor
11:21:04 <stevenxl> How do I import it into a module?
11:21:12 <stevenxl> I tried: import Servant.API.Sub ((:>))
11:22:26 <ongy> stevenxl: that looks correct to me. what was the error?
11:22:42 <stevenxl> ongy sorry, for some reason stack is not loading my project 
11:22:55 <stevenxl> I tried `stack ghci` in order to get a repl with my project in memory.
11:23:30 <lyxia> what's the error message
11:24:08 <vimalloc> Any opaleye users around? Trying to set something up based on this (https://github.com/tomjaguarpaw/haskell-opaleye/blob/master/Doc/Tutorial/TutorialBasic.lhs), but am getting the error `Module ‘Opaleye’ does not export ‘table’` and `Module ‘Opaleye’ does not export ‘tableColumn’`
11:24:16 <stevenxl>   Not in scope: type constructor or class ‘:>’
11:24:35 <stevenxl> oh wait I see. I am importing Lib but Lib is not exporting everything
11:26:07 <stevenxl> I had to import it in Main, not sure why the Lib module didnt' re-export what it had imported.
11:26:18 <stevenxl> Is that not how it works? It only exports declarations defined in it/
11:26:39 <jared-w> It depnds on how your modules are setup
11:26:43 <Tuplanolla> That's how it works, stevenxl.
11:26:52 <stevenxl> Tuplanolla: thank you !
11:27:17 <Tuplanolla> You can, however, reexport modules as a whole, stevenxl.
11:27:26 <geekosaur> you can tell it to re-export stuff but by default it exports only its own definitions
11:27:36 <geekosaur> as if you'd said module Lib (module Lib) where ...
11:27:41 <Tuplanolla> Like `module Lib (module Sub) where import Sub`.
11:28:38 <stevenxl> great thank you 
11:28:58 <jared-w> I have a weird setup for my stack project for working through exercises to "haskell programming from first principles" so I have to import everything again in Main
11:30:11 <trampel> Utter beginner here. On this well-established "quick tour of haskell syntax" (http://prajitr.github.io/quick-haskell-syntax/) we see this example function:
11:30:23 <trampel> allEqual :: (Eq a) => a -> a -> a
11:30:30 <trampel> allEqual x y z = x == y && y == z
11:30:38 <jared-w> (The book /really/ isn't designed from the viewpoint that someone will actually go through and write all the exercises down in a single project. It also doesn't take a whole lot of steps to prevent clashes from prelude consistently; sometimes the author renames things, sometimes the author doesn't. More often you'll end up writing a function called 'a' 6 times over 12 chapters
11:30:54 <trampel> Isn't something missing like a " -> Bool" in the type line?
11:31:22 <jared-w> :t (x == y && y == z)
11:31:24 <lambdabot> Bool
11:31:26 <monochrom> Yes trampel
11:31:29 <vimalloc> trampel: yeah
11:31:50 <trampel> thank you!!  it's the little things that drives one nuts when learning a new language.
11:32:06 <geekosaur> and for "well established" my logs tell me that's the first time that site has ever been mentioned here >.>
11:32:15 <jared-w> no problem. Yeah that one should really be fixed...
11:32:41 <stevenxl> So if the kind of an infix type construct is given by ghci has `k1 -> k -> *`, can I read that has the type constructor (:>) takes a type, another type, and returns a type, or are the `k`s somehow significatn?
11:32:50 <jared-w> (I've also never seen this blog mentioned here before. Although it does trigger something in my head that makes me think I've seen it mentioned /somewhere/ before...)
11:32:58 <stevenxl> Also, sorry for the brackets, I know that that has semantic meaning. I'll try and not do that
11:33:44 <jared-w> eh, it doesn't matter either way. It's good to know you don't need them but some people use them anyway 'cause they like them
11:34:05 <lyxia> vimalloc: it looks like this tutorial is based on a yet unreleased version of opaleye
11:34:30 <jared-w> nvm I read what you said wrong, stevenxl :p
11:34:45 <stevenxl> no worries
11:34:59 <vimalloc> lyxia: Yeah, I cam to the same conclusing. Looking at the git log for those tutorials to find out the correct stuff for the current version.
11:35:02 <vimalloc> Thanks :)
11:35:18 <jared-w> I use `code here` all the time since it's a habit from markdown. It's usually pretty obvious what way people are using ``s for
11:36:10 <jared-w> trampel: The other thing you can do is you can write the function in GHCi without the type signature and then use `:t function_name` and it'll be able to tell you the correct type
11:37:12 <trampel> jared-w: thank you.  i've been missing the C language cdecl  english<->type_signature functionality, and that'll fill my hole.
11:38:07 <jared-w> no problem. Speaking of holes, something that I don't see mentioned /nearly/ often enough in beginner material is type holes
11:38:24 <trampel> typing of that.  is there a resource to a haskell table of precedence?  so that, for instance, one might learn that "=>" is higher in precedence that "->"?
11:38:43 <geekosaur> most beginner material predates type holes...
11:38:45 <jared-w> You can write a function in a haskell file (or in GHCi) and use _var (note the leading underscore) in place of a variable you don't know and Haskell will tell you what that type should be
11:39:56 <jared-w> geekosaur: even the stuff that doesn't predate type holes often doesn't have it mentioned... :'(
11:41:28 <hpc> they could do with being mentioned more
11:41:45 <hpc> they're the best window into the type system you have available, at the moment
11:41:55 <hpc> like a type-level debug print statement
11:41:59 <jared-w> trampel: The haskell report is surprisingly readable and is the cannonical source of information on nitty gritty details like that. Although, it does mention /everything/ so it's a very high noise to signal ratio until you're familiar with all of the stuff in Haskell
11:43:19 <trampel> jared-w: thank you again  so... https://www.haskell.org/onlinereport/  ?)
11:43:29 <jared-w> yup
11:43:31 <hpc> as an addon to the report, ghc's online docs
11:43:45 <hpc> which document even more everything
11:43:54 <lyxia> stevenxl: k and k1 here mean that (:>) can take other things than types (of kind *), it can be type constructors (Maybe :: * -> *, Proxy :: foo -> *, foo -> bar -> *, etc), or promoted values (42, "42", 'Just '[]).
11:44:07 <jared-w> That being said, the 90% of what you need to know is that => is used for typeclasses. So a function `foo Eq a => a...` can be thought of as "a implements Eq"
11:44:38 <geekosaur> trampel, jared-w, the more recent one is https://www.haskell.org/onlinereport/haskell2010/
11:45:29 <trampel> geekosaur: thank you all.
11:45:31 <crucify_me> hi I need to revisit these two examples. could you guys show me how to flesh out the first example into something that I can follow? https://ptpb.pw/JFBD
11:45:39 <geekosaur> although arguably onlinereport/ should redirect tto that and the older one should be onlinereport/haskell98/
11:46:12 <crucify_me> the let..in clause
11:47:26 <jared-w> geekosaur: I agree. Although quite a few webadmins consider it a grade A cardinal sin to change any permalink... ever... :p
11:47:42 * jared-w is firmly not in that camp
11:47:58 <hpc> this is why javascript makes web development so easy
11:48:07 <geekosaur> then it is on them to not camp on the wrong real estate
11:48:09 <hpc> if everything is served on / all you have to do is keep the same domain name :P
11:48:17 <geekosaur> if it's a versioned document, it should be a versioned permalink
11:48:23 <jared-w> hpc: ಠ_ಠ
11:48:47 <hpc> anyhoo there isn't a whole lot changed in 2010
11:48:59 <hpc> n+k patterns, language extensions were formalized, and the FFI
11:49:07 <hpc> and maybe one or two other small things i am forgetting
11:49:26 <jared-w> n+k patterns being removed, you mean?
11:49:29 <hpc> yeah
11:49:37 <geekosaur> clarification of translating the layout rule to brace insertion
11:50:15 <jared-w> Hmm... I actually wonder, is brace and semicolon insertion a thing all "whitespace-only" languages do when compiling?
11:50:42 <lyxia> crucify_me: are you trying to find more and more complicated ways of writing x = 1 : x
11:50:56 <hpc> jared-w: an obvious counterexample is python, which has no brace syntax
11:51:38 <crucify_me> lyxia, thanks, I'm trying to understand a closure and those are two examples that I never really got. definitely don't know how either works there
11:52:04 <jared-w> hpc: right, I was curious as to how python "compiled". Haskell makes braces and semicolons and all that "optional" but inserts them in when compiling. I always thought that was one of the stranger design choices and kinda fail to see why anyone would want to do it that way
11:52:11 <crucify_me> I don't know what x = 1 : x means lyxia 
11:52:14 <lyxia> jared-w: markdown has some layout rules too, though it's not a *programming* language
11:52:31 <orzo> is there a common operator equivelent to flip fmap ?
11:52:40 <geekosaur> jared-w, I don't think it's required to actually do it, only to conform to the semantics obtained that way
11:52:59 <Rotaerk> :t (<&>)
11:53:01 <lambdabot> Functor f => f a -> (a -> b) -> f b
11:53:05 <lyxia> crucify_me: it means x = 1 : 1 : 1 : 1 : ... -- ad infinitum
11:53:18 <orzo> thanks, Rotaerk 
11:53:27 <Rotaerk> :t &
11:53:29 <lambdabot> error: parse error on input ‘&’
11:53:33 <Rotaerk> :t (&)
11:53:35 <lambdabot> a -> (a -> b) -> b
11:53:49 <geekosaur> also I feel like some 60sish languages did things like that, although not specifically brace insertion
11:53:53 <Rotaerk> <&> is analogous to & as <$> is analogous to $
11:54:16 <crucify_me> oh.. but it is a suspended computation (according to my patchy notes)
11:54:22 <crucify_me> ?
11:54:25 <jared-w> geekosaur: yeah it feels like a very 60s-ish thing to do
11:54:33 <hpc> jared-w: ultimately it's a parser implementation detail, and it all becomes ASTs in the end
11:54:34 <jared-w> crucify_me: they're referring to laziness in an obtuse way
11:54:53 <crucify_me> meaning what?
11:55:14 <jared-w> hpc: makes sense. I guess I'd just prefer it if the parser left ; and {} alone so I could use them for naming data structures or other shiny things like that
11:55:50 <jared-w> crucify_me: x = 1 : x won't destroy your computer because the language is lazy and only takes what it needs. It evaluates the 1, then goes to the : x which is 1, then goes to the : x, which is... 
11:56:05 <jared-w> If the language was strict it would have to go through the whole list before printing and evaluating it out
11:56:38 <jared-w> (x = 1 : x might be the wrong example for that. I'm not sure how corecursion is handled in strict languages; it probably depends?)
11:57:02 <lyxia> ocaml allows it with the same result.
11:57:13 <lyxia> there's nothing to suspend, it's just a constructor pointing to itself.
11:57:36 <crucify_me> sorry I really would need to see how its used (or not used, suspended?) in a program that did something 
11:58:09 <crucify_me> I was hoping to flesh it out into an interesting sample I could sink my teeth into
11:58:10 <jared-w> lyxia: I thought so. Halfway through writing that I was like "hmm... Pretty sure 1:x is one of the few counterexamples to what I'm writing out" lol
11:58:43 <geekosaur> pattern matching forces an expression to the next constructor. since a list is a chain of (:) constructors terminated with a [] constructor, each evaluation forces exactly one more list element
11:59:18 <orzo> Rotaerk: do i need lens for <&> ?  I want a base operator if their is one
11:59:18 <geekosaur> (of course if your pattern matches more than one element, it will go further e.g. foo (x:y:s) = ...
11:59:36 <jared-w> > let x = 1 : 1 : zipWith (+) x (tail x) in x -- Here's an interesting example for you, crucify_me ;)
11:59:38 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
11:59:42 <geekosaur> er (x:y:xs) or (x:x':xs)
12:00:39 <Rotaerk> orzo, <&> is defined in multiple packages, it looks like, but it's not is base
12:00:49 <crucify_me> thats fibonacci?
12:00:58 <Rotaerk> you could always just redefine it locally if you don't want to add a dependency just for it
12:00:58 <jared-w> crucify_me: yes
12:01:18 <Rotaerk> (<&>) = flip (<$>)
12:01:20 <geekosaur> > let x:x':xs = [1,2,undefined] in x' -- xs is merely bound, not evaluated
12:01:23 <lambdabot>  2
12:01:57 <jared-w> or (<&>) = flip fmap if you hate parens :p
12:02:12 <CindyLinz> > fix ("bug" :) -- Yet another interesting example
12:02:14 <crucify_me> excellent jared-w   ..  sorry hold on geekosaur
12:02:14 <lambdabot>  ["bug","bug","bug","bug","bug","bug","bug","bug","bug","bug","bug","bug","bu...
12:02:33 <hpc> > fix error -- the best example
12:02:36 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
12:02:42 <jared-w> lol
12:03:27 <CindyLinz> XD
12:03:43 <dminuoso> How exactly does join implement a natural transformation?
12:03:45 <c_wraith> despite the name, it doesn't fix any error
12:04:16 <dminuoso> I mean I keep looking at T∘T -> T, and it just does not look similar at all
12:06:07 <Rotaerk> hmm is EmptyDataDecls enabled by default now or something
12:06:17 <Rotaerk> I see it's an extension, but I can do "data Foo" without it
12:06:29 <lyxia> dminuoso: A natural transformation between functors (T . T) and T is given by, for every object a, a morphism from (T . T) a to T a. In other words, forall a. T (T a) -> T a.
12:07:14 <c_wraith> lyxia: it has to preserve some sort of morphisms along the way, right?
12:07:23 <lyxia> Indeed.
12:09:54 <dminuoso> lyxia, yeah about that. join just seems to give me the mapping between the objects, what about morphisms?
12:10:02 <crucify_me> more drama soon
12:10:08 <dminuoso> Or.. mmm.
12:10:40 <lyxia> dminuoso: morphism = function  in the Hask category.
12:11:49 <geekosaur> Rotaerk, it's not an extension as of Haskell2010
12:12:05 <geekosaur> but still supported for backward compatibility
12:12:24 <Rotaerk> ah, gotcha
12:12:28 <lyxia> I omitted some work in there but parametricity basically implies the naturality conditions. There might actually be natural transformation between Hask functors that are not expressible as polymorphic functions, I'm not sure.
12:13:11 <geekosaur> crucify_me, http://lpaste.net/358187 is a breakdown of what I showed
12:13:14 <dminuoso> lyxia, well how do I "join" two fmap functions?
12:13:43 <lyxia> dminuoso: what does that mean
12:14:43 * hackagebot pipes-concurrency 2.0.8 – Concurrency for the pipes ecosystem – https://hackage.haskell.org/package/pipes-concurrency
12:14:43 * hackagebot harp 0.4.3 – HaRP allows pattern-matching with regular expressions – https://hackage.haskell.org/package/harp
12:15:04 <elpfen> any good imagemagick or similar packages?
12:15:29 <hpc> juicypixels, maybe
12:15:51 <crucify_me> geekosaur, thanks very much ! looking now
12:16:00 <elpfen> Optimally, full imagemagick capability. Otherwise just looking at sizes
12:16:26 <hpc> ah, i think juicypixels can do that then
12:16:42 <elpfen> Nice!
12:17:13 <hpc> when i briefly looked at getting the full imagemagick featureset, i ended up settling on calling the convert utility
12:17:31 <lyxia> dminuoso: the definition of a natural transformation is just a mapping from object to morphism, with a commutative diagram, which is equivalent to an equation   fmap f . join = join . (fmap . fmap) f
12:17:40 <hpc> which if you can get past the syntax and learn the model behind it, isn't too terrible
12:18:19 <elpfen> it looks like there's a bunch of FFI bindings for imagemagick...what are ffi bindings? just bindings to the underlying utility?
12:18:30 <elpfen> I might do that then, because I already have all the commands written
12:18:39 <hpc> ffi is short for foreign function interface
12:18:47 <hpc> and yeah, it's just bindings to the imagemagick c library
12:20:42 <Subeff> Hey again guys, It is the third time I face something I have no clue and it should be pretty easy I guess, but when I implement an instance of Applicative, for the data type `data Three a b c = Three a b c` I have no clue how to implement the `pure` function. How is that even possible if one argument is coming how do I construct something that needs actually three values? As for the <*> I just restrict the first two types to be Mono
12:21:13 <lyxia> it's not possible
12:21:29 <hpc> Subeff: you need additional constraints on the a and b types such that you can pick a value for them
12:21:33 <hpc> :t mempty
12:21:34 <lambdabot> Monoid a => a
12:22:08 <Subeff> laaal yes guys <3 you
12:22:11 <lyxia> Ah, you already restricted the types to be monoids for <*> ...
12:22:27 <Subeff> yes yes, how come I completely forgot of mempty
12:22:31 <Subeff> thank you so much
12:22:32 <dminuoso> lyxia, just found this: https://wiki.haskell.org/Category_theory/Natural_transformation
12:22:43 <dminuoso> This is gold, exactly what I was looking for. Just couldn't find the words. :)
12:26:02 <dminuoso> lyxia, so just staring at that diagram made me realize that the "mapping of functions" ψ(f) and ϕ(f) parts dont need to be "mapped". The natural transformation just cares about ϕ(x) and ψ(y)
12:31:35 <elpfen> How do I use `when` when the IO Action i want to use doesn't return IO () ?
12:32:15 <cocreature> :t void -- elpfen 
12:32:16 <lambdabot> Functor f => f a -> f ()
12:32:25 <phadej> :t when . void
12:32:26 <lambdabot> error:
12:32:26 <lambdabot>     • Couldn't match type ‘f1 ()’ with ‘Bool’
12:32:27 <lambdabot>       Expected type: f1 a -> Bool
12:32:36 <phadej> :t \b -> when b . void
12:32:37 <lambdabot> Applicative f => Bool -> f a -> f ()
12:32:48 <jared-w> also, when is applicative, not monadic... can you use it for IO actions?
12:33:09 <cocreature> jared-w: Applicative is a superclass of Monad
12:33:45 <phadej> keywords: covariance & contravariance
12:33:54 <jared-w> riiight... duh, brainfart on my part.
12:34:52 <crucify_me> jared-w, hey with that fibonacci example, how would you concisely describe how the fib numbers are being generated, using that method?
12:35:02 <elpfen> That's what void is for!!
12:35:05 <elpfen> thanks
12:35:29 <jared-w> elpfen: you can also abuse it in fun ways with pseudo-dependent typing if you're so inclined :p
12:36:05 <jared-w> crucify_me: it's zipping a list with the tail of that list using addition
12:36:18 <jared-w> > zipWith (+) [1..5] [10..15]
12:36:21 <lambdabot>  [11,13,15,17,19]
12:37:20 <crucify_me> thanks, could you say that is forcing evaluation without a bottom value? ..trying to get the terminology in order
12:37:27 <jared-w> [(1 + 10), (2 + 11), (3 + 12), (4 + 13), (5 + 14)] (and the zipWith function stops since we ran out of one list even though there's a 15 in the other list)
12:37:40 <orzo> If I have a literal expression 1 + 4 + 2 + 32 can I count on GHC to evaluate it at compile time?
12:37:54 <orzo> I'm not talking about evaluating general constant expressions, but simple math formula like that
12:38:00 <crucify_me> ok thanks gotta go through that
12:38:03 <jared-w> crucify_me: no, that's the entirely wrong terminology and wrong context to use that sort of terminology in
12:38:25 <crucify_me> ok thanks 
12:38:31 <jared-w> crucify_me: Do you understand what `tail` does? Given a list [1..5] tail gives you [2..5]
12:38:44 <crucify_me> yeah that's like cdr
12:39:19 <jared-w> So with zipWith (+) x (tail x) you're adding x_n and x_(n+1) together which is precisely the co-recursive method for generating a fibonacci number
12:40:16 <jared-w> I start the list off with `1 : 1 : ` so that x and (tail x) have value to work with to get the third item in the list (which will be 2)
12:41:17 <crucify_me> thanks right you need two 1's to start it. you can
12:41:20 <crucify_me> t
12:41:27 <jared-w> so it's:  1 : 1 : (1+1) : (1 + (1+1)) : ((1+1) + (1 + (1+1))) : ...
12:41:29 <crucify_me>  *can't use the zero
12:41:40 <jared-w> You could use zero just fine ¯\_(ツ)_/¯
12:41:49 <lyxia> orzo: yes
12:41:55 <jared-w> > let x = 0 : 1 : zipWith (+) x (tail x) in x
12:41:58 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
12:43:20 <jared-w> In fact you could use any two numbers to 'kick start' the fibonacci series. It is merely convention that the "traditional" fibonacci function is defined as f0 = 1; f1 = 1; fn = f(n-1) + f(n-2). The two base cases could really be whatever you wanted them to be
12:43:28 <c_wraith> > let x = 0 : scanl (+) 1 x in x
12:43:30 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
12:43:39 <jared-w> But that's more a mathematical aside than anything that's actually relevant to programming
12:43:46 <c_wraith> > let x = (0 :) . scanl (+) 1 $ x in x
12:43:48 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
12:44:00 <c_wraith> > fix (0 :) . scanl (+) 1
12:44:03 <lambdabot>  error:
12:44:03 <lambdabot>      • Couldn't match expected type ‘[b] -> c’
12:44:03 <lambdabot>                    with actual type ‘[Integer]’
12:44:07 <c_wraith> > fix $ (0 :) . scanl (+) 1
12:44:09 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
12:44:14 <crucify_me> excellent. yeah you just need to fib numbers in sequence to prime the sequence
12:44:24 <jared-w> c_wraith: now you're just screwing around :p
12:44:53 <jared-w> > fix $ (1 :) . scanl (+) 1
12:44:55 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
12:45:16 <koz_> :t scanl (+) 1
12:45:17 <lambdabot> Num b => [b] -> [b]
12:45:34 <crucify_me> that's also fibonacci?
12:45:34 <jared-w> idk, while shiny and cool, I don't really like this definition as much. It's not quite the clearest representation of the fibonacci sequence, to me
12:46:24 <crucify_me> is that using a fold or something?
12:46:35 <jared-w> crucify_me: yeah. Don't think too hard about that. fix is a way to define recursion without having a recursive call. scanl is a co-recursive method... etc
12:46:40 <jared-w> Not a fold, but an unfold
12:46:41 <c_wraith> > scanl (+) 0 [1..10]
12:46:43 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
12:47:09 <c_wraith> If that helps explain what scanl does
12:47:29 <crucify_me> interesting that's overload, thanks though!
12:47:53 <c_wraith> > scanl (+) 0 (repeat 1)
12:47:56 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
12:47:58 <jared-w> crucify_me: yeah I can barely follow the pointfree fix and scan version myself. Don't worry too much about it :p
12:48:30 <c_wraith> crucify_me: scanl is a variant of foldl that gives a list of every intermediate state.
12:49:09 <jared-w> And the reason it doesn't break on infinite lists is because it's co-recursive, right?
12:49:21 <c_wraith> yes
12:49:37 <crucify_me> thanks so much I gotta go over the log and make a nice file with notes (and footnotes for scanl / foldl)
12:50:51 <c_wraith> jared-w: though technically that isn't much of a statement.  Anything that works with infinite lists has to be co-recursive.
12:51:47 <c_wraith> or recursive over an argument other than the list, I suppose.
12:52:04 <c_wraith> > take 5 [1..]  -- recursive over the Int argument
12:52:07 <lambdabot>  [1,2,3,4,5]
12:52:42 <Tuplanolla> let f = (1 !) \/ plus; g = ((() !) -|- pred /\ (pred . pred)) . ((<= 1) ?) in hylo (_L :: Mu (Const () :+: (Id :*: Id))) f g -- Here's an even better way to do it with the `pointless-haskell` package.
12:58:13 <crucify_me> so these examples I have, where exactly is the closure operating, say in the fibonacci example jared-w  ? geekosaur entitled their sample with "when evaluation is and isn't forced by a pattern match; so how do you look at those examples and say: "there's the closure"
12:58:48 <jared-w> c_wraith: fair point :p I just like to keep recursive vs co-recursive straight in my head even though Haskell blurs the lines quite a bit
12:59:38 <crucify_me> ^ no wonder I'm having trouble. the fibonacci is co-recursive?
13:02:50 <jared-w> The particular examples we've been doing are. Fibonacci can be written in a co-recursive or recursive way
13:03:12 <jared-w> "the fibonacci" is nothing more than a mathematical function. It's how it's implemented that matters
13:03:45 <Mirandag> ciao
13:03:48 <Mirandag> !list
13:05:53 <crucify_me> jared-w, thanks a lot for all the help .. et al
13:13:56 * hackagebot Villefort 0.1.1.12, io-streams 1.5.0.1, openssl-streams 1.2.1.2, snap-core 1.0.3.1, … and 2 more
13:13:56 * hackagebot  → https://hackage.haskell.org/packages/recent
13:18:40 <c_wraith> I'm still so slow at this...  and wow does it look like alphabet soup.
13:18:42 <c_wraith> :t \f z t -> foldr (\c g x -> x : g (f c x)) (:[]) t z
13:18:43 <lambdabot> Foldable t => (t2 -> t1 -> t1) -> t1 -> t t2 -> [t1]
13:19:56 <ignamv> is there a tidy way to access variables bound in an inner do block in the outer do block?
13:20:08 <c_wraith> ignamv: return them.
13:21:06 <hpc> ^
13:21:09 <hpc> it's the only way
13:21:19 <Welkin> nested do-blocks sounds like perhaps a badly written function
13:21:46 <ignamv> what's the alternative?
13:21:56 <mniip> mutable references!
13:22:02 <hpc> the alternative is not returning them ;)
13:22:08 <cocreature> mniip: heretic!
13:22:19 <geekosaur> I think that alternative thing is aimed at Welkin
13:22:25 <ignamv> yes
13:22:32 <hpc> ignamv: see acme-dont for a basic example of where extracting something from a do-block is simply impossible
13:22:38 <Welkin> it depends on your code
13:22:52 <ignamv> I understand that the function that gets the inner do has to do the work
13:23:04 <ignamv> or rather cooperate in passing along the vars
13:24:04 <ignamv> anyway thanks, I guess there's no sugar for this situation
13:24:56 <eschnett> @jle` thanks! yes, the name “sum” is misleading in this context; however, if f and g are vector spaces, then this corresponds to the sum space.
13:24:56 <lambdabot>  Parse failed: Parse error: name
13:25:08 <eschnett> jle`: (see above)
13:27:00 <mniip> oh yes
13:27:08 <mniip> direct sum spaces are product objects
13:27:16 <mniip> and tensor products are exponentials!
13:34:02 <jared-w> tensor products are exponentials?
13:34:10 <jared-w> So many things make sense now :p
13:38:29 <iqubic> Like what?
13:47:02 <dminuoso> Mmm. Interesting, so there's other natural transformations than >>= id! Found about maybeToList :)
13:53:23 <ga2arch> hi, i'm trying to get a better understanding of this code http://lpaste.net/1291693641697329152, i don't understand how the third instance recurses
14:01:24 <apo> hey
14:01:31 <apo> does nomeata still hang out in here?
14:03:08 <hexagoxel> ga2arch: it doesn't recurse in the sense "inj = let f = Inr . f in f" only in the sense that it redirects to the (f :>: g) instance.
14:03:39 <hexagoxel> eh, the f :<: g instance I mean.
14:03:52 <ga2arch> hexagoxel: mmm, how does the redirect work? 
14:03:54 <geekosaur> the second inj is referencing a different instance than the first
14:03:54 <c_wraith> apo: I can't say as I recall him saying anything recently.  He's still active on the mailing lists
14:04:01 <geekosaur> by the types
14:04:30 <apo> c_wraith: Well, as long as he still joins occasionally, I should be able to catch him
14:05:14 <ga2arch> geekosaur: mmm still confused :|
14:05:14 <geekosaur> nomeata was last in here 18 Aug, according to my logs
14:05:38 <geekosaur> for about half an hour
14:05:39 <hexagoxel> inj :: f a -> (h :+: g) a; inj = Inr . (inj :: f a -> g a)
14:05:57 <apo> geekosaur: oh, dang.
14:06:11 <apo> thanks for checking :)
14:07:55 <ga2arch> hexagoxel: thanks, i'm getting there i think
14:10:44 <ga2arch> hexagoxel geekosaur: i'm retarded, got it now, thanks 
14:10:56 <geekosaur> ga2arch, basically you know the first one from the instance definition; you can derive the second by the fact that you applied Inr to its result to get the type from the first
14:13:59 * hackagebot Villefort 0.1.1.13, throttle-io-stream 0.2.0.0, tsuntsun 0.2.0.0
14:13:59 * hackagebot  → https://hackage.haskell.org/packages/recent
14:16:00 <richardmar> hey boys
14:16:45 <ignamv> is there agreement on what constitutes readable Haskell?
14:17:20 <hpc> in the sense of consensus, or a list of rules, or a linter?
14:17:25 <jared-w> ignamv: if you can send the code to 3 people and only 2 of them disagree with how you wrote it, it's readable :p
14:17:59 <MarcelineVQ> jared-w: I had to read that twice, pretty clever though
14:18:02 <hpc> as the supreme court so hilariously put it, you'll know it when you see it
14:18:46 <ignamv> haha
14:18:49 <ignamv> dirty
14:19:22 <ignamv> any guidelines though?
14:19:58 <hpc> the most consistent guideline i can think of is "make it look like what it does"
14:20:01 <iqubic> ignamv: use top level type signatures always.
14:20:06 <MarcelineVQ> ignamv: oh sure, good ones too  https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
14:20:19 <hpc> which is admittedly vague
14:20:47 <ignamv> hpc: like this? http://blog.aerojockey.com/post/iocccsim
14:21:52 <ignamv> argh, I pressed a shortcut with focus on the wrong window and now my PC is launching ze missiles
14:22:42 <ignamv> MarcelineVQ: thanks
14:22:51 <monochrom> Use your own sense of aesthetics. Go with your heart.
14:22:53 <hpc> a contrived example might be, if part of your algorithm is printing a newline, use putStr "\n" instead of putStrLn ""
14:23:03 <hpc> this goes beyond just haskell
14:24:50 <monochrom> Eliminate XY problems.
14:27:45 <hpc> it's really hard to clarify any further, i keep arriving at "readable code is code you can read"
14:28:03 <hpc> other than to list classes of mistake and say "avoid these"
14:28:41 <monochrom> I think that the most important cause of unreadable code is XY problems, not petty things such as indentation style or pointfree vs pointful.
14:28:51 <monochrom> Debug your mind, not your code.
14:29:03 <Tuplanolla> Haskell always becomes a mess, so the best thing you can do is a consistent mess.
14:29:11 <MarcelineVQ> readable code is code that when you lpaste it and your error to ask what you did wrong, people can answer you
14:34:35 <meijiJAPAN>  Is there any book for functional implementations of data structures and algorithms 
14:35:01 <erisco> meijiJAPAN, yeah
14:35:06 <hpc> https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
14:35:12 <erisco> that one
14:35:32 <osfameron> I'm surprised that's still the only one people ever mention though
14:35:45 <hpc> it's a good book
14:35:47 <osfameron> okasaki is good but it's dense and hard to read if you haven't got a maths/cs backgound
14:36:07 <osfameron> yeah, it's great.  I'm just surprised there isn't a mid-market equivalent
14:36:16 <osfameron> or one that covers more/different data-structures
14:36:28 <eikke> cocreature: makes sense, thanks
14:36:37 <hpc> there probably is, it's just lacking the reputation
14:36:57 <hpc> i imagine it's similar to how if you ask about a book for writing compilers, everyone suggests the dragon book
14:36:58 <monochrom> Not enough demand. Plus for most programmers they just need to know "use Data.Map" and "use Data.HashMap".
14:37:22 <monochrom> Ha but I'll suggest the tiger book.
14:38:21 <monochrom> Although, as more years go by, the tiger book suffers the same old problem.
14:39:13 <hpc> there's only one solution
14:39:18 <hpc> we have to stop advancing computer science :P
14:40:09 <Tuplanolla> There are many ways to a Pyrrhic victory.
14:40:38 <Tuplanolla> Say nothing of substance and you will never be wrong.
14:41:23 <monochrom> Like this? http://www.vex.net/~trebla/humour/tautologies.html
14:42:48 <jared-w> Nobody's going to mention the great Pearls of Functional Algorithm Design?
14:43:12 <ignamv> aaand hackage is down
14:43:26 <jared-w> (of course it's got a slight bit of a reputation for being, ahem, mathy)
14:43:38 <epta> @hackage base
14:43:38 <lambdabot> http://hackage.haskell.org/package/base
14:43:38 <bennofs> ignamv: works for me
14:44:26 <monochrom> Oh damn I still have to read Pearls!
14:44:40 <epta> ignamv: can confirm there was a temporary glitch with 503 response
14:45:37 <monochrom> Bought it for myself to celebrate finishing my thesis. Read chapter 1. Since then sitting on the bookshelf along with all the other decorative textbooks such as John Mitchell's Foundations for Programming Languages!
14:45:47 <Tuplanolla> We need Perils of Functional Algorithm Design to balance it out.
14:47:25 <monochrom> But Pearls tends to be a life-long collection of cute little pieces rather than a systematic textbook.
14:48:23 <Lazersmoke> Is there way to add haddock documentation to individual constructor fields? Like `data Stuff = Things A B C` and I want to document the A B and C individually
14:49:07 <monochrom> Yes, see http://haskell-haddock.readthedocs.io/en/latest/index.html
14:50:16 <monochrom> Err I guess no, unless you switch to the record syntax.
14:50:29 <Lazersmoke> ok
14:51:18 <ignamv> yep, it's up
14:51:38 <Lazersmoke> I just tried GADTs and they didn't work either :(
14:52:53 <ignamv> anyone know of a shapefile library that reads the actual shapes?
14:52:54 <monochrom> It is also record syntax if it's GADTs.
14:53:14 <ignamv> the package "shapefile" just gives you the bytes for each shape entry
14:54:23 <eikke> Is there any way to get the above to work, assuming I can't change A, B or C's definitions, but can change M? http://lpaste.net/358190
14:55:49 <eikke> I'm aware how instance selection works so I know why this doesn't work, but I'd love to find some kind of work-around :)
15:02:23 <Lazersmoke> does anyone have any advice on what to do about this module? It has a whole bunch of similar `data` definitions in it, with one or two support functions each. I don't really want to use records/lenes because I think it would clutter the namespace. Should I make one module for each type? https://github.com/Lazersmoke/civskell/blob/master/src/Civskell/Packet/Serverbound.hs#L171
15:09:15 <epta> what is 'takeWhile' analogue in trifecta?
15:10:05 <pavonia> Lazersmoke: Have you considered using TH?
15:10:21 <stevenxl> hi folks
15:11:31 <Lazersmoke> I have, but idk how far that will really get me, since they don't all use Generics for serialization
15:11:57 <Lazersmoke> so I'd have to write so many special cases that it would cancel out the benefit I get from TH
15:14:11 * hackagebot data-fix 0.0.7, th-typegraph 1.0.2, throttle-io-stream 0.2.0.1
15:14:11 * hackagebot  → https://hackage.haskell.org/packages/recent
15:19:12 <jared-w> Lazersmoke: is there any reason you can't use Generics for serialization everywhere in the module so that TH is useful?
15:20:43 <Lazersmoke> I could kludge it a little more and make that happen, but most of the information is not the same between different types. For instance, the handler functions are all unique
15:21:44 <Lazersmoke> I think I'm just gonna put everything in its own module, and put all of that plus an export aggregator thingy in another package later (was planning on doing that for some unrelated stuff anyway)
15:23:04 <jared-w> That doesn't sound too bad. It's a shame there's no way to have multiple modules per file
15:27:11 <dminuoso> Mmm, so the composition (natural transformation) of monads is constrained to "from functor f to f"? I mean I can't just `join [Just3]` 
15:28:04 <Cale> dminuoso: I'm not sure what the first part means, but you can't join [Just 3], indeed
15:28:06 <Cale> :t join
15:28:08 <lambdabot> Monad m => m (m a) -> m a
15:28:16 <Cale> Has to be the same monad.
15:28:20 <Tuplanolla> The composition of monads usually means something else, dminuoso.
15:28:59 <monochrom> The problem with "express in your own words to confuse the hell of yourself"
15:29:38 <Tuplanolla> Take `newtype Jist a = Jist [Just a]` for example. Is `Jist` a monad?
15:29:56 <Cale> Tuplanolla: What type constructor is Just?
15:30:05 <monochrom> +1
15:30:07 <Tuplanolla> Pfft...
15:30:31 <Tuplanolla> I meant to write `newtype Mist a = Mist [Maybe a]`.
15:30:53 <monochrom> That's better. Was wondering "what does jist mean?" too.
15:31:42 <monochrom> Hrm that's going to be a difficult question.
15:34:51 <Tuplanolla> In my experience accidentally writing jist is more common than correctly writing gist.
15:35:51 <koz_> Tuplanolla: English's semi-phonetic nature strikes again!
15:35:52 <DigitalKiwi> are you someone that pronounces gif like the peanut butter?
15:36:14 <jared-w> DigitalKiwi: you mean "wrong"? :p
15:36:22 <DigitalKiwi> your words
15:36:24 <DigitalKiwi> they hurt
15:36:35 <koz_> jared-w: I'm confused.
15:36:40 <dminuoso> Cale, Im still a bit stuck on some details of "monads are monoids in the category of endofunctors". The thing that Im not entirely clear on, is that group operation of the monoid.
15:36:42 <hpc> someone needs to make a photoshop now of "peanut buttery cat"
15:37:16 <orzo> How do I write an instance for type-level naturals?  I'm getting Illegal type synonym family application in instance when I use (n+1)
15:37:17 <dminuoso> Cale, I mean if I can't do join [Just 3], then it seems like the monoid operation is constrained to only some functor compositions
15:37:33 <Eduard_Munteanu> dminuoso, unit is the unit and join does the "multiplication"
15:37:50 <orzo> GHC.TypeLits doesn't seem to havea Succ operator
15:37:50 <Cale> dminuoso: Well, okay, so in the monoidal category (Set, ×, 1)
15:38:14 <Cale> dminuoso: You have that a monoid comes equipped with a multiplication map: M × M -> M
15:38:24 <jared-w> koz_: There are two ways to pronounce the file extension .gif--with a hard g or a soft g. I'm joking that only the hard 'g' is a valid pronounciation of 'gif' (even though, ironically, the creator of the format insists the soft 'g' is the correct way to pronounce it)
15:38:59 <koz_> jared-w: Hard g is like 'leg', while soft g is like 'germ'?
15:39:20 <jared-w> precisely
15:39:31 <Tuplanolla> Then there's the rally driver g, which is like k, jared-w.
15:39:50 <Eduard_Munteanu> I thought it was the other way around.
15:40:09 <koz_> jared-w: So what's the peanut butter thing about?
15:40:24 <hpc> there's a company that makes peanut butter called "jif"
15:40:27 <monochrom> I propose the new naming scheme "the gift g and the gist g".
15:40:44 <koz_> hpc: Ah, I see.
15:40:48 <Cale> In the monoidal category (End(C), . , id), i.e. endofunctors on C with natural transformations between them, with the tensor product being functor composition (which importantly is a bifunctor on this category), and the unit being the identity functor
15:41:10 <hpc> (also the cat comment was because of giffycat
15:41:11 <hpc> )
15:41:15 <Cale> You have that a monoid object M is equipped with a natural transformation ("multiplication")  M . M -> M
15:41:17 <koz_> The only 'Jif' I'm familiar with: https://en.wikipedia.org/wiki/Cif#Name
15:41:21 <Cale> right?
15:41:25 <hpc> or gfycat or however it's spelled
15:41:27 <koz_> (although it also used to be called Vim, for extra confusion)
15:41:55 <DigitalKiwi> http://imgur.com/a/VAKh0
15:42:01 <Cale> This natural transformation has, for each object X in C, a component at X, which is a map M (M X) -> M X
15:42:20 <hpc> koz_: that's hilarious
15:42:23 <koz_> DigitalKiwi: Consider me enlightened.
15:42:23 <Cale> In Haskell, we would render that as a polymorphic function M (M a) -> M a
15:42:26 <Cale> which is exactly join
15:42:37 <Cale> dminuoso: Does that help?
15:42:38 <monochrom> "Use Vim to clean your windows!"
15:42:48 <hpc> let's see emacs do that
15:42:55 <jared-w> M-x windex ;)
15:42:55 <koz_> monochrom: A 'Vim is not Emacs' joke seems... dammit hpc.
15:42:57 <DigitalKiwi> that's a jif gif
15:47:04 <monochrom> https://emacsconference.com/about-emacs/
15:47:29 <koz_> monochrom: Is it Confusing Names Day or something?
15:47:49 <DigitalKiwi> monochrom can we make a thing where we say gift like jift and gist like jist so they are the same g?
15:48:01 <DigitalKiwi> simplifies things, really, it's for the good of all
15:48:02 <Eduard_Munteanu> It's RSI injury awareness day. :P
15:49:15 <MarcelineVQ> gist is like jist already
15:49:21 <DigitalKiwi> also I need a citation on that the creator of gif pronounces it the way I do thing...cause that is one battle I want to win
15:50:06 <dminuoso> Cale, well here's the thing I dont get: The natural transformation η: M x M -> M means for every a,b out of M, there exists a mapping from (a,b) 
15:50:08 <koz_> DigitalKiwi: On a somewhat-related note, is your name the demonym, the fruit or the bird?
15:50:22 <dminuoso> Cale, so I guess the question is: What is this set limited to?
15:50:54 <DigitalKiwi> [17:50:15]  <phrik>	Digitized, chirping, fruit with citizenship, ftw! lolque? http://i.imgur.com/AT40oPm.jpg
15:51:26 <koz_> Well, that just explains everything! :P
15:51:42 <DigitalKiwi> all and none at the same time, I'm not even from NZ >.>
15:51:59 <koz_> DigitalKiwi: Not many people are. :P
15:52:11 <Eduard_Munteanu> dminuoso, you mean mu
15:52:18 <dminuoso> Eduard_Munteanu, uh yes.
15:52:22 <DigitalKiwi> too bad they're like the friendly version of australians
15:52:24 <dminuoso> Or. No
15:52:51 <koz_> DigitalKiwi: I'm from NZ, so thanks! :)
15:53:03 <Eduard_Munteanu> dminuoso, eta is 1 -> M
16:00:24 <Cale> dminuoso: I'm not sure I understand the question. There's another map (actually usually the one you wrote there is called μ and the other one is η) for the unit, and then they satisfy some laws.
16:01:12 <Cale> Oh, also, that's not a natural transformation in that case
16:01:15 <Cale> It's just a function
16:01:34 <Cale> dminuoso: You wrote ×, so you must be talking about Set monoids.
16:02:02 <Cale> In the case of the category of endofunctors and natural transformations, × gets replaced by functor composition, so pairs aren't around.
16:03:02 <dminuoso> Cale, for a monoid (S, ., 1), the monoid operation is defined as .: S x S -> S right?
16:03:43 <milesrout> data Pair a = (a, a); Free Pair = BinaryTree. Free [] = RoseTree. Free Maybe ~ Maybe. Free Tree ~ Tree
16:03:47 <milesrout> is that right?
16:06:39 <milesrout> Free Maybe = Pure x | Free Nothing | Free (Just (Pure x)) | Free (Just (Free Nothing)) | ..., so it's either something, or nothing, so it's basically just Maybe...?
16:07:13 <milesrout> plus the let x = Free (Just x) in x case?
16:10:52 <Cale> dminuoso: We're talking about *Set* monoids now?
16:11:06 <Cale> dminuoso: yes
16:11:56 <dminuoso> Cale, wait a second. So in the world of haskell, that set is implicitly reduced to just one element?
16:12:37 <Cale> dminuoso: The "a monad is a monoid in the category of endofunctors" thing is using a vastly more general notion of what the word "monoid" means.
16:13:01 <Cale> https://en.wikipedia.org/wiki/Monoid_(category_theory) -- specifically, this one
16:14:04 <Cale> It's so called, because if you pick the category of sets, and for the tensor product ⊗ you pick Cartesian product, and for 1 you pick a one element set, then you get something equivalent to the original definition of a monoid.
16:14:19 <Cale> But when we're talking about monads, those aren't the choices we make
16:14:58 <Cale> Instead of the category of sets and functions, we choose the category of endofunctors on whatever category C it is that we're interested in, and the natural transformations between them
16:15:16 <Cale> Instead of the Cartesian product, we choose ⊗ to be composition of functors
16:15:28 <Cale> and instead of a one-element set, 1 becomes the identity functor
16:16:04 <Cale> and then out falls the definition of a monad
16:16:54 <c_wraith> Yeah, the important thing to know about "monoid in the category of endofunctors" is that it's a restatement of the definition that only makes sense if you already know category theory.
16:17:10 <Cale> haha, yeah, that's one way to put it
16:17:28 <Cale> I'm assuming that dminuoso is trying to learn some category theory, and is not just interested in learning about monads in Haskell.
16:17:39 <Welkin> and category theory is *not* required (or even all that helpful) in understanding and being able to use haskell
16:17:50 <Cale> (If not, this whole thing might as well be considered offtopic)
16:18:00 <dminuoso> Cale, monads I have understood rather early actually.
16:19:01 <Welkin> haskell monads are easy, but people think they are some special thing that is heavy in theory
16:19:11 <Cale> It's somewhat helpful, but it's not worth its time cost to learn if you're only interested in Haskell. As far as applications are concerned, category theory becomes more and more worthwhile the more other mathematics you're interested in.
16:19:13 <Welkin> even though it's just an interface with >>= and join
16:19:18 <Welkin> er
16:19:21 <Welkin> >>= and return
16:19:27 <Cale> But it's also quite nice for its own sake too.
16:19:30 <hpc> it's even less than that now
16:19:42 <hpc> the entirety of Monad can be summed up in join, since return is always pure
16:19:54 <Profpatsch> Cheatsheet for the Dhall Configuration language
16:19:56 <Profpatsch> https://github.com/Profpatsch/blog/blob/master/notes/dhall-cheatsheet.md
16:19:58 <Profpatsch> non-turing-complete, typed, functional, interplolation/templating
16:20:00 <Profpatsch> Would be happy about feedback. The cheatsheet should give a good overview if one already knows Haskell.
16:20:12 <Cale> hpc: Well, you need to define it somehow.
16:20:18 <Profpatsch> (Dhall is by Gabriel Gonzalez)
16:20:36 <Cale> hpc: You could say (>>=) and Applicative
16:20:41 <Cale> though that's a bit redundant
16:20:59 <Cale> You'll get (<*>) for free from (>>=) and return also :)
16:22:03 <Cale> Usually, I prefer just to write a Monad instance and then use it to get Functor and Applicative
16:22:19 <dminuoso> Cale, oh. I think I may have been conflating "a monoidial category" and a "monoid"
16:22:38 <dminuoso> Which might explain exactly the confusion I have been experiencing for a while
16:22:47 <Welkin> Cale: you can only do that in haskell though because of liftM, ap, and pure
16:23:18 <Welkin> in purescript you can't do this, because liftM, ap, and return don't exist
16:24:01 <c_wraith> You could define them to use as helpers.
16:24:46 <c_wraith> much like Traversable provides foldMapDefault and fmapDefault as helpers in the module.  (in case you don't want to derive those definitions, I guess?)
16:24:52 <dminuoso> Cale, oh yeah. Thanks a lot for your patience and that last link on monoid. The term is truly overloaded in math it seems. :(
16:27:49 <dminuoso> Cale, so monads are monoid *objects* of the monoidal *category* of endofunctors?
16:28:58 <dminuoso> I definitely need a book on this.
16:29:11 <paf31> Welkin: ap exists https://pursuit.purescript.org/packages/purescript-prelude/3.1.0/docs/Control.Monad#v:ap
16:29:36 <paf31> liftM is liftM1
16:35:10 <Welkin> paf31: is there still no way to auto-derive a show instance in purescript liek you can in haskell withou importing Generic, deriving a generic instance, then deriving a show instance?
16:35:43 <c_wraith> sounds like Purescript needs DeriveAnyClass
16:35:56 <Cale> dminuoso: yes, that's correct
16:37:00 <CantFindMyPants> Hey there
16:37:21 <hpc> guess they weren't here
16:37:38 <monochrom> I did a /whois CantFindMyPants and then they left.
16:38:19 <c_wraith> you scared them
16:38:40 <Welkin> was that larry david?
16:40:42 <paf31> c_wraith: we need default instances first :)
16:40:54 <paf31> but we've been thinking of adding something like that
16:41:33 <c_wraith> paf31: Honestly, if you plan to avoid the issues haskell had with DeriveAnyClass, it sounds like a big win to add it.
16:42:00 <paf31> Which issues are you referring to?
16:42:54 <c_wraith> The ambiguity it created..  "Should this be derived using a default instance, GND, an extension that explicitly allows deriving that class?" etc
16:43:10 <c_wraith> I suspect you don't have half that trouble in purescript anyway
16:43:26 <paf31> Ah ok
16:43:28 <c_wraith> So it's much less of an issue, if it's a problem at all.
16:43:35 <paf31> Yeah we have keywords to disambiguate
16:43:50 <c_wraith> that's what the most recent version of DeriveAnyClass ended up doing, too
16:43:50 <paf31> "derive newtype instance ..." and so on
16:43:59 <c_wraith> though not exactly like that
16:44:02 <paf31> right
16:46:09 <MarcelineVQ> there is something for that, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-strategies
16:59:15 <al__> hi, can anyone enlighten me on the current state of calling C++ from Haskell. How up to date is the following: https://wiki.haskell.org/CPlusPlus_from_Haskell ?
16:59:25 <ignamv> is cabal install --reinstall the normal way to upgrade a package?
17:00:06 <hpc> al__: 2.1 on that page is still accurate afaik
17:00:21 <hpc> all the ugly stuff underneath it, no clue
17:00:32 <geekosaur> al__, that page itself says it was written for a much older g++
17:00:48 <geekosaur> in particular it predates c++11 which changed things a bit
17:01:14 <geekosaur> the correct way to call C++ from anything else is to use extern "C" stubs in the C++ code
17:01:15 <al__> Is there any updated documentation I could consult or any case study?
17:01:28 <geekosaur> because there is no standard for direct calling
17:01:41 <geekosaur> as much as people want there to be one, there is not one and there will not be one
17:01:53 <hpc> al__: use the C++ documentation for making something that uses the C ABI, and then use the regular haskell FFI documentation
17:02:51 <al__> I was looking for something as much as automated possible
17:03:23 <al__> But one could postulate to build a code generator for all the extern "C" functions since there are many parsing libraries for C++
17:03:27 <fendor> does someone else experience problems with the nightly builds of stackage? in this case, an error message like "This package requires at least Cabal version 2.0", although this should be satisfied?
17:03:37 <al__> And then use FFI as yo usuggest
17:03:48 <peddie> al__: you might check out https://hackage.haskell.org/package/fficxx
17:04:12 <geekosaur> al__, you can only automate on the assumption the C++ folks won't change things whenever they want
17:04:17 <geekosaur> they do not support direct calling
17:04:48 <hpc> more precisely, they don't have a stable ABI
17:05:23 <al__> So ABI is architecture specific at the moment?
17:05:25 <hpc> an ABI is like a compiled down version of an API, it's what two libraries interact through
17:05:42 <hpc> worse than that, it's version-specific to the exact g++ you have on your machine
17:05:53 <hpc> it could change in a point release for all you know
17:06:11 <geekosaur> al__, yes
17:06:34 <al__> Just to make sure what an ABI exactly define? How to call procedures? Like how to push function arguments on the stack and stuff like that
17:06:51 <hpc> imagine if you updated from ghc 8.0.0 to 8.0.2, and in between someone renamed tail to butt
17:06:57 <geekosaur> and while there are arch-specific annexes, there is no guarantee anyone follows them. in particular, while clang++ and g++ generally try to use the same arch ABI, Microsoft does not
17:07:00 <hpc> you'd have to totally rewrite everything
17:07:08 <hpc> same goes for having an unstable ABI
17:07:54 <hpc> al__: all of it
17:08:09 <hpc> al__: it defines the exact method by which one compiled library can call another
17:08:59 <al__> Ok makes sense. And last question and I promise I will quit! How come does not a consensuns on a common ABI emerged?
17:09:06 <fendor> for anyone interested, it was just a problem with not using the latest stack verison
17:09:30 <al__> I mean from the C++ community side
17:09:59 <hpc> the trivial reason might be that the conditions to make a stable ABI required don't exist
17:10:12 <hpc> if you need one, use C's
17:10:37 <al__> Ok makes sense. WIll investigate the fficxx package then
17:10:48 <al__> I thank you so much for your answers
17:10:48 <hpc> that's probably a better question for C++ people though, they would know the full history
17:11:04 <al__> I guessed so but it is good to hear from different point of view
17:11:11 <hpc> ghc does the same thing, btw
17:11:18 <hpc> internally it has a wildly unstable ABI
17:11:24 <hpc> but foreign exports use the C ABI
17:15:36 <geekosaur> al__, largely it constrains how a C++ compiler can work and potentially constrains platform-specific limitations
17:16:12 <geekosaur> like, neither the microsoft nor the apple linker support the options the gnu linker does (nor does gnu ld.gold support everything ld.bfd does, which is one reason it's faster)
17:17:58 <geekosaur> and while some compilers make an effort to work together (e.g. g++ and clang++) not every compiler available does so (e.g. Microsoft's compiler)
17:40:19 <fresheyeball> is there a quasi quote that just makes a mutliline string?
17:40:27 <fresheyeball> I have a sqlite query that is getting long
17:44:50 <geekosaur> http://hackage.haskell.org/package/heredoc
17:45:07 <geekosaur> and several others of the same ilk
17:45:10 <geekosaur> %hackage heredocs
17:45:13 <geekosaur> er
17:45:17 <geekosaur> @hackage heredocs
17:45:17 <lambdabot> http://hackage.haskell.org/package/heredocs
17:45:21 <geekosaur> @hackage here
17:45:21 <lambdabot> http://hackage.haskell.org/package/here
17:46:01 <fresheyeball> geekosaur: is there a way that doesn't involve having a dependency?
17:46:18 <geekosaur> no, ghc does not come with that kind of quasiquoter
17:46:44 <geekosaur> if you insist on not adding a dependency then you get string gaps
17:47:21 <geekosaur> cf. end of https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-200002.6
17:47:44 <fresheyeball> boo, I would have expected that one would be built in
17:57:02 <milesrout> what's wrong with having a dependency?
17:57:16 <milesrout> haskell is nice nowadays with dependencies using stack and such
17:59:00 <DigitalKiwi> sometimes having a dependency is useful come tax season
18:04:33 <crucify_me> https://ptpb.pw/w-zU   hi again, the constant function looks like it takes more than two arguments in the ghci examples. but isn't it defined to take just 2?
18:05:41 <c_wraith> > const id () 5
18:05:43 <lambdabot>  5
18:06:12 <c_wraith> crucify_me: any function with a sufficiently polymorphic return type can return a function
18:07:42 <c_wraith> > const const () const () id 5
18:07:44 <lambdabot>  error:
18:07:44 <lambdabot>      • No instance for (Typeable a0)
18:07:44 <lambdabot>          arising from a use of ‘show_M326319284077136244216352’
18:07:48 <c_wraith> heh, whoops
18:08:09 <c_wraith> > const const () const const () id 5
18:08:11 <lambdabot>  error:
18:08:11 <lambdabot>      • Couldn't match expected type ‘Integer -> t’ with actual type ‘()’
18:08:11 <lambdabot>      • The function ‘const’ is applied to 7 arguments,
18:08:18 <c_wraith> Hmm.  I should give up now.
18:08:36 <crucify_me> sorry I don't see what you're doing. 
18:09:07 <erisco> crucify_me, all functions take exactly one argument
18:10:20 <crucify_me> actually yeah erisco that I see...
18:10:37 <crucify_me> so here's the thing...
18:10:53 <erisco> so, the mystery can be reduced to: why does const take two arguments if all functions just take one argument?
18:11:28 <crucify_me> that I know the answer to
18:11:39 <crucify_me> because
18:11:42 <DigitalKiwi> higher functions?
18:12:26 <crucify_me> const id 6 is all const takes there. it *resolves* to id
18:12:46 <erisco> reduces to, yes
18:13:04 <c_wraith> crucify_me: but then how do you apply that function to an argument?
18:13:10 <c_wraith> crucify_me: (whitespace!)
18:13:42 <crucify_me> right, it reduces to id, then whitespace, then you get 5
18:13:54 <erisco> const x  reduces to the function  \y -> x
18:14:06 <erisco> (\y -> x) z  reduces to  x
18:14:14 <erisco> hence  const x z  reduces to x
18:14:24 <erisco> const x z a  reduces to  x a
18:14:43 <crucify_me> thanks hold on please
18:14:43 <erisco> adding parentheses may help
18:15:03 <crucify_me> erisco there's an example there with the parens
18:15:07 <c_wraith> :t \f z t -> foldr (\c g x -> x : g (f c x)) (:[]) t -- let's just admit this was sort of hard to write the first time.
18:15:08 <lambdabot> Foldable t => (t3 -> t2 -> t2) -> t1 -> t t3 -> t2 -> [t2]
18:15:23 <erisco> I mean that adding parens to what I just said may help
18:15:48 <erisco> (const x) z  reduces to  x;  ((const x) z) a  reduces to  x a
18:16:10 <c_wraith> Err.  I have no idea where that t1 snuck in from
18:16:15 <erisco> the latter is evident by the former
18:16:31 <crucify_me> wha?
18:17:04 <crucify_me> let me ask some questions about the beginning of the paste, where ....
18:17:40 <erisco> if  x reduces to y  then  x a reduces to y a
18:18:08 <crucify_me> all 3 of these functions are combinators.
18:19:09 * hackagebot wai-secure-cookies 0.1.0.2 – <i>Added by alaminium, Mon Sep 4 00:18:43 UTC 2017.</i> – https://hackage.haskell.org/package/wai-secure-cookies
18:19:43 <crucify_me> so is there something more grand going on in this example, that will help me understand combinators and their opposites(?) closures
18:19:44 <crucify_me> ?
18:20:02 <erisco> which example?
18:20:07 <crucify_me> https://ptpb.pw/w-zU
18:20:33 <crucify_me> the whole thing with const id = flip const
18:20:39 <erisco> what particular thing do you not understand?
18:21:40 <erisco> I don't know any grand reason for their equivalence other than you can show it by their definitions
18:22:19 <crucify_me> so, what exactly does the constant func do?
18:22:41 <erisco> it throws away the second argument and keeps the first
18:22:41 <crucify_me> like I know pi is a constant
18:23:27 * jle` just now realizes how weird of a name 'direct sum' is
18:23:45 <Cale> crucify_me: A constant function is one which gives the same result no matter which argument is supplied
18:23:50 <jle`> ( eschnett, mniip )
18:23:55 <erisco> ah, well it constructs constant functions
18:24:19 <erisco> you are familiar with lines, yes? y=mx+b ?
18:24:30 <crucify_me> essentially
18:24:54 <erisco> well, const lets you make all the flat (horizontal) lines
18:25:24 <erisco> the ones which remain constant as x varies
18:25:53 <erisco> so,  const 2  is the horizontal line at y=2,  and generally  const x is the horizontal line at y=x
18:26:13 <crucify_me> right, y doesn't change
18:26:21 <erisco> that's right
18:27:42 <erisco> lines are a specialisation, since const doesn't depend on theory to talk about lines, but it is a valid application of it
18:28:36 <erisco> generally speaking it just constructs the constant functions
18:29:23 <crucify_me> thanks I feel its easy, but I think I'm also trying to see what links these 3 functions together, the common thread that makes them "combinators"
18:29:25 <crucify_me> erisco, 
18:29:28 <crucify_me> Cale
18:30:26 <crucify_me> is it just coincidence that these 3 are combinators?
18:32:20 <erisco> crucify_me, well you said at the top they are combinators because they have no free variables
18:33:55 <erisco> that is a necessary and sufficient condition
18:34:56 <erisco> but "combinator" might also be used in a nontechnical sense
18:35:23 <crucify_me> I was reading about that. I think its technical in this context
18:35:27 <erisco> so, just an operator that puts two things together into a like object
18:35:38 <erisco> in lambda calculus yes, it is techincal
18:36:05 <crucify_me> then there's the y-combinator, which I don't understnad
18:37:12 <fresheyeball> hey out there
18:37:13 <erisco> it is important but I haven't spent the time to study it
18:37:26 <erisco> you should figure it out and teach it to me sometime :)
18:37:26 <fresheyeball> I have a sqlite db with a column of type timestamp
18:37:35 <fresheyeball> the date times are stored as unix time
18:37:40 <crucify_me> also , at the bottom of the paste, where it says const id is a terrible way to express the concept. word erisco will do !
18:37:49 <fresheyeball> I'm using the sqlite-simple library and can't get it to parse
18:38:17 <erisco> nothing wrong with const id that I can see
18:38:49 <DigitalKiwi> dibblego help we need timedate help
18:39:04 <dibblego> u wot m8?
18:39:16 <DigitalKiwi> this person is having time problems! we need a link
18:39:30 <erisco> const id  is the constant function of id
18:39:35 <Axman6> when is their problem???
18:39:58 <DigitalKiwi> UTC NOW 
18:40:24 <Axman6> oh, I can't help for 10 hours then, until they catch up!
18:40:24 <erisco> but if a human is more likely to think about the problem as "I want the second argument" then maybe this is a convoluted process
18:40:50 <dibblego> https://gist.github.com/tonymorris/90522094bb964fd0d7bb42acd43ff4fb#times
18:40:55 <crucify_me> the constant function of id ?  
18:40:56 <erisco> if instead they're likely to be thinking about constant functions then const id is better
18:41:03 <erisco> since flip const doesn't make constant functions
18:41:17 <erisco> yes, same as the constant function of 3 and so forth
18:42:45 <erisco> using const as "I want the first argument" is a bit strange but common
18:43:06 <erisco> more deliberate might be  curry fst
18:43:22 <erisco> then the second argument is  curry snd
18:44:31 <crucify_me> its sort of trippy, this
18:44:41 <crucify_me> just pure logic
18:44:58 <crucify_me> thanks.. I'm going to sleep on it
18:44:59 <erisco> variables are not unlogic
18:45:26 <erisco> they're just cretinous warts
18:45:43 <crucify_me> lovely, why?
18:45:59 <nisstyre> programming is a total sham
18:46:18 <nisstyre> variables are definitely warts
18:46:42 <crucify_me> funny
18:46:45 <erisco> I am using hyperbole, but first of all they're horribly complicated to explain relative to the rest of the system
18:46:53 <erisco> definitely easy to get wrong
18:47:31 <erisco> secondly, they can be a symptom of… poor design
18:47:46 <erisco> not that @pl is a design genius either
18:48:06 <crucify_me> >const id 6 5
18:48:18 <erisco> you've probably been advised not to use explicit recursion. why? because we have functions that do that already
18:48:39 <erisco> in a similar vein, why use variables if we have functions which do the appropriate plumbing already
18:50:04 <crucify_me> erisco, how do we invoke lambdabot here?
18:50:11 <erisco> > const id 6 5
18:50:13 <lambdabot>  5
18:50:15 <nisstyre> erisco: how would you implement binary search without explicit recursion?
18:50:23 <Axman6> fix
18:50:24 <nisstyre> just curious
18:50:38 <crucify_me> > const id 6 5
18:50:40 <lambdabot>  5
18:50:43 <erisco> well, like @pl is not a design genius, neither is fix ;)
18:51:07 <crucify_me> well this is how I finally got it:
18:51:19 <crucify_me> > const (id 6) 5
18:51:22 <lambdabot>  6
18:51:46 <crucify_me> so not rocket science
18:52:08 <crucify_me> thanks gotta go I'm turning into a cretinous wart.
18:52:21 <crucify_me> thanks alot
18:53:38 <eschnett> is there (un)currying for arrows? i’m looking for the signature   Arrow a => a b (a c d) -> a (b, c) d
18:54:26 <eschnett> `app` seems related, but has the other arrow in the first argument.
18:58:18 <erisco> nisstyre, with a tree or what?
19:00:25 <nisstyre> erisco: no tree, just a list or an array maybe
19:01:17 <nisstyre> I was working on some code for suffix arrays, and that's how you find a match, by doing binary search
19:01:23 <nisstyre> so that's why I thought of it
19:01:35 <lyxia> eschnett: I don't know if that helps but that looks like the adjunction between functors (a c) and (,c)
19:01:55 <erisco> an array does not have an inductive structure, so there is nothing to recurse on
19:02:15 <nisstyre> you could build a binary search tree from it
19:02:24 <nisstyre> it has the same recursive structure either way
19:02:44 <erisco> the point of a binary search is the time complexity
19:02:54 <nisstyre> tree recursion or divide and conquer
19:03:08 <erisco> perhaps you can lazily build a binary search tree in logn time, I am not sure
19:03:13 <Rotaerk> not speaking generally, speaking specifically for haskell development, which is a smoother experience? vim or emacs? or are they pretty much even and a matter of which one you're most familiar with
19:03:16 <nisstyre> it's the same thing I think
19:03:25 <eschnett> lyxia: yes, good point… i don’t think it’ll help.
19:03:27 <lyxia> eschnett: it looks too monadic to be an arrow thing
19:03:28 <erisco> but since we're in the vein of performance I am not sure this is a good route
19:03:31 <Rotaerk> I currently use vim but wondering if I should switch to emacs for haskell
19:04:11 <erisco> a list defeats the purpose altogether, may as well do a sequential scan
19:04:36 <nisstyre> yeah a list is a bad data structure for this
19:04:46 <Rotaerk> (or is there something other than emacs/vim that provides better haskell developmennt support)
19:05:27 <nisstyre> sometimes I'll do things like this with lists just to make sure I have correct code, and then convert it to something else
19:05:38 <nisstyre> even into other languages, like JS
19:05:47 <nisstyre> because I find it easier to think in Haskell
19:11:55 <systemfault> Rotaerk: Visual Studio Code with Haskero
19:12:05 <systemfault> It's surprisingly good.
19:12:29 <Rotaerk> is that speaking from experience with the vim and/or emacs options as well?
19:12:35 <systemfault> Yes.
19:12:42 <systemfault> I know both vim and emacs.
19:12:53 <Rotaerk> k, I'll try that; thanks
19:13:01 <systemfault> Of course, since VSC is browser-based... it not as light.
19:14:08 <Rotaerk> yea
19:15:01 <glguy> Rotaerk: If you're a vim user, and not a regular emacs user, you might try spacemacs with evil mode and dante to see if you like it
19:15:10 <systemfault> ^
19:15:33 <Rotaerk> yea I wouldn't say I like vim, I'm just used to it
19:15:40 <Rotaerk> might try that
19:16:15 <Rotaerk> my main gripe with VSC is it's not as snappy ... not something you want to launch on a whim and close when done
19:17:16 * hackagebot postmark 0.2.1 – Library for postmarkapp.com HTTP Api – https://hackage.haskell.org/package/postmark
19:17:37 <systemfault> True... but it does use intero for Haskell (The same thing as emacs' intero-mode0
19:17:50 <Rotaerk> k, cool
19:18:00 <Rotaerk> thanks for the suggestions
19:50:51 <erisco> :t (\a -> arr (\b -> a . arr (\c -> (b, c)))) :: Arrow a => a (b, c) d -> a b (a c d) -- eschnett
19:50:53 <lambdabot> error:
19:50:53 <lambdabot>     • Couldn't match type ‘a1’ with ‘(->)’
19:50:53 <lambdabot>       ‘a1’ is a rigid type variable bound by
19:51:06 <erisco> :t (.)
19:51:08 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:51:18 <erisco> :t (\a -> arr (\b -> a <<< arr (\c -> (b, c)))) :: Arrow a => a (b, c) d -> a b (a c d) -- eschnett
19:51:20 <lambdabot> Arrow a => a (b, c) d -> a b (a c d)
19:52:04 <erisco> no app required
19:52:16 <Rotaerk> hrm, I'm encoding "aoeu" to a ByteString, and I get "\NUL\NUL\NUL\NUL\NUL\NUL\NUL\EOTaoeu"
19:52:22 <Rotaerk> are all those nulls and the EOT expected ?
19:52:55 <Rotaerk> actually, just the 8 nulls are returned if I encode the empty Text
19:53:23 <glguy> Rotaerk: Encoding using the binary package?
19:53:39 <Rotaerk> using cereal-text, which uses Data.Text.Encoding's encodeUtf8
19:53:47 <c_wraith> Rotaerk: it's a binary length field
19:53:52 <glguy> Yeah, that's expected, it's the length field
19:53:53 <geekosaur> Rotaerk, looks like a length encoding
19:53:57 <Rotaerk> ah k
19:54:14 <glguy> Rotaerk: If you get to pick your package, look at http://hackage.haskell.org/package/serialise
19:54:16 <Rotaerk> thanks, makes sense...
19:54:39 <Rotaerk> hmm I'd looked at binary and cereal; hadn't seen this onne
19:54:43 <Rotaerk> why this over them?
19:54:51 <glguy> More efficient encodings
19:55:07 <Rotaerk> k, cool
19:55:19 <glguy> and a standardized encoding that other languages and libraries will understand is the other reason
19:56:52 <glguy> serialise ("asdf"::Text) ==> "dasdf"
19:58:07 <glguy> 'd' is 0x64, which is the tag for a 4-byte UTF-8 encoded string
20:04:45 <eschnett> erisco: thanks!
20:13:29 <erisco> :t (\a -> app <<< first app <<< arr (\(b,c) -> ((a,b), c))) :: ArrowApply a => a b (a c d) -> a (b, c) d -- eschnett
20:13:31 <lambdabot> ArrowApply a => a b (a c d) -> a (b, c) d
20:13:50 <erisco> I am not too experienced with Arrow so don't be confident these are good solutions
20:15:03 * hackagebot forest 0.2 – Tree and Forest types – https://hackage.haskell.org/package/forest
20:42:14 <jchia1> Question about Filesystem.Path.CurrentOS.toText. How can the conversion from FilePath to Text fail? Is there an example (any OS)? Is there an example for Linux?
20:42:36 <malkss> Given this data: https://pastebin.com/raw/ggkzDshW how can I match the 2 columns so that each of the same value is displayed next to eachother?
20:42:53 <jchia1> I suppose toText fails if the UTF-8 decoding fails?
20:45:04 <Lazersmoke> is there any standard data type that looks like `data G f s a = (s,f a)`? I tried to search that on hoogle and it gave me an error
20:45:11 <malkss> Given this data: https://pastebin.com/raw/ggkzDshW how can I match the 2 columns so that each of the same value is displayed next to eachother?
20:45:16 <geekosaur> jchia1, filepaths on posix (linux, *bsd except os x) are not guaranteed to be utf8
20:45:59 <geekosaur> thats a very common "but of course they are" (and then gtk file dialogs drop core, etc., because no, they are NOT)
20:47:09 <kyagrd> Lazersmoke: shouldn't it be "type G f s a = (s, f a)"? unless you are introducing a data constructor for G
20:47:21 <Lazersmoke> yeah that's what I meant
20:47:35 <Lazersmoke> and on second though I think I can just use the pair directly
20:47:50 <jchia1> cocreature: OK
20:48:16 <jchia1> malkss: You seem to have two sorted input lists. You can make a function like this : f: [Int] -> [Int] -> (Maybe Int, Maybe Int)
20:48:33 <jchia1> I mean f: [Int] -> [Int] -> [(Maybe Int, Maybe Int)]
20:48:56 <Lazersmoke> actually, it has to be behind a data constructor to partially apply it
20:49:11 <jchia1> Each item in the output is a line to print. At least one of the items in the pair is a Just. You can define f recursively matching the head of the two lists.
20:50:00 <lyxia> Lazersmoke: Compose ((,) s) f a
20:50:30 <Lazersmoke> oh, that works! forgot about Compose. thanks lyxia
20:50:49 <jchia1> geekosau: OK. That's what I thought. I think I could just treat the FilePath as latin1 and skip decoding errors.
20:51:06 <jchia1> geekosaur: OK. That's what I thought. I think I could just treat the FilePath as latin1 and skip decoding errors.
20:51:16 <lyxia> Lazersmoke: EnvT s f a https://hackage.haskell.org/package/comonad-5.0.2/docs/Control-Comonad-Env.html
20:52:56 <lyxia> Lazersmoke: Biff (,) Identity f s a https://hackage.haskell.org/package/bifunctors-5.4.2/docs/Data-Bifunctor-Biff.html
20:55:55 <iqubic> How do type declarations work again?
20:56:05 <Lazersmoke> I think I'm gonna go with EnvT cause it makes the code the simplest out of the three. I'll have to meditate on why that's applicable here at all, though
20:56:43 <Lazersmoke> what kind of type declarations, iqubic? type synonyms or data constructors?
20:56:59 <iqubic> type synonyms
20:58:04 <Lazersmoke> you just write `type ImASynonym a b c = [((a,b),c)]` or something similar, then whenever you write `ImASynonym a b c` it gets replaced with the thing on the RHS
20:58:16 <iqubic> Ah I see.
20:59:52 <iqubic> I've used magit for so long that I've forgotten how to do command line git.
21:01:37 <iqubic> Oh, here's something I wrote for a tic-tac-toe game using Data.Array:
21:01:39 <iqubic> type Board = Array (Int, Int) Piece
21:02:49 <iqubic> And that let's me do stuff like: 
21:02:50 <iqubic> isOnBoard :: Board -> (Int, Int) -> Bool
21:02:57 <iqubic> isOnBoard board = inRange (bounds board)
21:03:23 <iqubic> That's a good way of using type synonyms.
21:03:44 <iqubic> I've just never seen type synonyms with parameters before.
21:04:04 <Lazersmoke> just beware they aren't as first class as you might think
21:04:15 <Lazersmoke> you can't partially apply them
21:04:55 <iqubic> You can't partially apply data constructor either.
21:05:03 <jle`> you actually can
21:05:07 <jle`> surprise ~
21:05:27 <jle`> instance Functor (Either e) where
21:05:38 <jle`> er well, those are type constructors, but i think that's what you mean
21:06:11 <iqubic> Ah, but each constructor of Either only takes one argument.
21:07:05 <jle`> we were talking about type constructors, but you can also partially apply data constructors too
21:07:08 <jle`> :t (,) 10
21:07:09 <lambdabot> Num a => b -> (a, b)
21:07:24 <jle`> :t (,) True
21:07:25 <lambdabot> b -> (Bool, b)
21:07:33 <jle`> data constructors are just normal functions
21:07:41 <iqubic> What the difference between type constructors and data constructors?
21:08:08 <jle`> type constructors make types
21:08:15 <jle`> data constructors make data/values
21:08:22 <jle`> one is in the type level and the other is in the data level
21:08:26 <malkss> Given this data: https://pastebin.com/raw/ggkzDshW how can I match the 2 columns so that each of the same value is displayed next to eachother? For example: column A has 4157, so does column B, now since both columns have 4157 sort them so that they are next to eachother in rows.
21:08:50 <jle`> iqubic: example of tpe constructors: Maybe, IO, Bool, Int
21:09:04 <jle`> iqubic: example of data constructors: Just, Left, Right, True, (,)
21:09:08 <iqubic> I see.
21:09:12 <jle`> i guess people sometimes call them value constructors
21:09:22 <iqubic> So IO has no data constructors?
21:11:43 <jle`> most types don't export their data constructors
21:11:51 <jle`> they're what we call "abstract data types"
21:12:15 <jle`> internally IO has a data constructor, but it's not exported.  we just have "smart constructors"
21:13:35 <jle`> other popular abstract data types are Map/Set/Seq from the containers package
21:13:51 <vimalloc> Does anyone have thoughts on elm vs purescript for a website frontend?
21:14:25 <iqubic> Right, but we use stuff like getLine to get an IO String.
21:14:32 <iqubic> :t reads
21:14:34 <lambdabot> Read a => ReadS a
21:14:37 <jle`> yeah, getLine is a part of IO's public API
21:14:45 <iqubic> :t ReadMaybe
21:14:45 <jle`> you can think of it like a smart constructor for an IO primitive
21:14:46 <lambdabot> error: Data constructor not in scope: ReadMaybe
21:14:50 <jle`> getLine :: IO String
21:14:53 <iqubic> :t readMaybe
21:14:54 <lambdabot> error: Variable not in scope: readMaybe
21:15:01 <jle`> it's a way to 'construct' an IO action with given semantics/actions
21:15:11 <iqubic> What's the function that I'm looking for?
21:15:18 <jle`> i don't know what function you are looking for
21:16:18 * hackagebot io-streams-haproxy 1.0.0.2 – HAProxy protocol 1.5 support for io-streams – https://hackage.haskell.org/package/io-streams-haproxy
21:16:18 * hackagebot counter 0.1.0.2 – An object frequency counter. – https://hackage.haskell.org/package/counter
21:16:57 <iqubic> @import Text.Read
21:16:57 <lambdabot> Unknown command, try @list
21:18:55 <jle`> @let import Text.Read
21:18:57 <lambdabot>  Defined.
21:19:05 <iqubic> :t readMaybe
21:19:07 <lambdabot> Read a => String -> Maybe a
21:19:14 <iqubic> That's what I was looking for,
21:19:27 <iqubic> I thought that had something to do with IO.
21:19:40 <iqubic> But I guess I was wrong.
21:19:47 <c_wraith> :t readLn
21:19:48 <lambdabot> Read a => IO a
21:20:17 <iqubic> But how do you make sure you get the right type there?
21:20:44 <c_wraith> Same way you make sure you get the right type with any other function that uses Read
21:20:54 <iqubic> And what if the getting of a string fails to return the right type?
21:21:07 <iqubic> Does that just keep looping until it gets the right type?
21:21:12 <c_wraith> > read "hello" :: ()
21:21:14 <lambdabot>  *Exception: Prelude.read: no parse
21:22:09 <jle`> iqubic: remember that functions like `foo :: a -> b` have to actually be 'used' with specific types
21:22:19 <jle`> in normal haskell
21:22:28 <jle`> so you don't actually use a readLn :: Read a => IO a
21:22:36 <jle`> you use readLn :: IO Int, or readLn :: IO Bool
21:22:47 <jle`> when you actually use readLn, you're using it with a specific type
21:22:49 <c_wraith> and usually inference figures out which one you want
21:22:52 <jle`> cause of static typing
21:23:22 <jle`> if you ever actually use readLn in your program, it's always readLn :: IO Foo, for some specific type Foo
21:23:49 <iqubic> jle`: but what parser does readLn use?
21:23:57 <jle`> unless you're doing some advanced RankNTypes stuff, you're always using readLn to read a specific type that you know at compile-time
21:24:03 <jle`> iqubic: the parser for the type you're using it for
21:24:08 <jle`> if you use `readLn :: IO Int`, it uses the Int parser
21:24:15 <jle`> if you use readLn :: IO Bool, it uses the Bool parser
21:24:29 <jle`> if you use readLn :: IO Double, it uses the Double parser, etc.
21:24:53 <jle`> it uses a mechanism called typeclasses
21:26:05 <iqubic> jle`: I get that. But what if I want to use readLn to read a foo? 
21:26:11 <jle`> what is a foo?
21:26:19 <jle`> you mean something of type Foo ?
21:26:24 <jle`> then it'd use the parser for Foo
21:26:49 <jle`> if you use `readLn :: IO Foo`, it'll use the Foo parser
21:26:55 <iqubic> but would I have to write a parser for said Foo?
21:27:08 <jle`> if you want, or GHC can derive one for you
21:27:23 <jle`> data Foo = ... deriving (Read)
21:27:25 <iqubic> GHC is smart.
21:27:31 <jle`> usually we use the automatically derived instance
21:28:03 <iqubic> but if GHC can derive that for you, then what's the point of parsec and other parser combinators?
21:29:16 <jle`> it derives a very simple and non-flexible parser
21:29:39 <iqubic> Ah. I see.
21:29:46 <jle`> parsec and parser combinators let you write parsers for whatever you want
21:29:49 <jle`> in whatever format you want
21:30:04 <jle`> Read isn't actually really used much in practice; it's mostly for debugging
21:30:18 <jle`> just like Show
21:30:33 <jle`> Read/Show are useful in the debugging phase but you don't see too much of it in actual application code
21:30:57 <jle`> *in the development phase
21:31:10 <iqubic> Ah. I see.
21:31:35 <jle`> it's useful just for 'i need to print my values to debug them for now and i don't want to worry about writing my own printer/reader, ghc make one for me quickly temporarily'
21:31:55 <iqubic> I used readMaybe in my code.
21:32:01 <jle`> most programming languages have similar functionality
21:32:17 <iqubic> it was to make sure that the user entered the an int for me.
21:32:37 <jle`> python has inspect()
21:33:17 <iqubic> I don't use python.
21:33:29 <jle`> yeah, Read can be useful sometimes for quick code and in some situations
21:34:56 <Hafydd> jle`: what package is inspect() in?
21:35:20 <jle`> heh, i was just saying that python generates automatic "display contents of my value" printers for your types at runtime
21:35:27 <jle`> um i might have gotten the name wrong
21:35:35 <jle`> maybe i'm thinking of ruby
21:35:35 <iqubic> Yeah. Eventually I'll be migrating to a GUI interface.
21:35:41 <Hafydd> I see.
21:35:54 <Hafydd> I don't know that Python has such a feature.
21:36:04 <Hafydd> But it would be possible to write one, as Python has good runtime reflection.
21:37:24 <iqubic> How the heck do RankNTypes work? I get that they use Forall a. but I'm not sure how that works?
21:38:09 <jle`> are you asking about how they are implemented?
21:38:13 <jle`> or how you use it?
21:38:28 <iqubic> How to use them.
21:38:40 <jle`> Hafydd: hm apparently it's actually not built in, but there are some libraries that can do it for you, as you guessed
21:39:22 <jle`> this was one of my favorite tutorials for rankntypes http://sleepomeno.github.io/blog/2014/02/12/Explaining-Haskell-RankNTypes-for-all/
21:39:35 <jle`> also its title is a grade-a pun
21:39:47 <iqubic> Yeah, I noticed right away.
21:39:50 <jle`> top notch
21:40:29 <iqubic> Yep.
21:41:56 <monochrom> haha why didn't I think of that pun
21:42:24 <monochrom> Oh I guess "Haskell existential types for all" is sitll not too late.
21:51:39 <erisco> and the sequel "Haskell for all existential types"
21:52:30 <iqubic> Why do RankNTypes require a langauge pragma?
21:52:46 <erisco> they are not part of the Haskell standard
21:53:01 <iqubic> Why not?
21:53:38 <erisco> because they were not ready in time for the last standard
21:54:15 <iqubic> When is the next standard?
21:54:26 <erisco> no idea
21:54:40 <pikajude> Haskell existential types exists
21:56:24 <erisco> they're probably not ready now, either
21:56:35 <jle`> pikajude: hm, A-
21:56:45 <pikajude> wow, THAT is a generous score
21:56:47 <jle`> points for following the format
21:56:54 <iqubic> Are RankNTypes ready?
21:57:00 <jle`> don't test me
21:57:36 <erisco> I doubt it, but I am not a Haskell historian so I don't know the likelihood
21:58:49 <erisco> there needs to be a final word on impredicativity
22:03:35 <iqubic> why is return still a thing? It's such a misnomer of a function name.
22:03:53 <erisco> it is a fine function name
22:04:32 <erisco> we don't have to agree with the way other languages use "return"… maybe they're wrong instead
22:05:22 <vaibhavsagar> even if they're wrong, it can still be a bad name
22:05:32 <vaibhavsagar> get rid of it and use `pure` everywhere
22:05:56 <vaibhavsagar> it's also shorter
22:05:57 <cocreature> that’s already planned but if you don’t want to break all code at once you have to do it in small steps
22:06:19 <erisco> maybe they should replace pure with return :)
22:06:24 <vaibhavsagar> I didn't realise we were getting rid of `return`
22:06:39 <vaibhavsagar> I thought it would hang around forever as a vestigial thing
22:06:53 <cocreature> https://ghc.haskell.org/trac/ghc/wiki/Proposal/MonadOfNoReturn
22:07:27 <vaibhavsagar> yeah, like that
22:07:31 <vaibhavsagar> a vestigial function
22:07:35 <vaibhavsagar> return = pure
22:07:54 <cocreature> but outside of the monad class
22:11:12 <erisco> inject may have been a nice name to be dual to extract
22:11:24 <iqubic> what does extract do?
22:11:48 <jle`> oooh
22:11:52 <jle`> new hackage search
22:11:54 <jle`> nice
22:11:56 <erisco> it is the function with the flipped type of return
22:12:11 <iqubic> Hackage changed?
22:12:13 <erisco> extract :: Comonad w => w a -> a
22:12:28 <iqubic> I see.
22:12:48 <cocreature> jle`: nice!
22:13:20 <erisco> "pure" is a stranger name than "return" in my opinion, because it is not a verb
22:14:16 <c_wraith> Oh hey.  Writer is one of the very few monads that is also a comonad
22:14:39 <jle`> sorta
22:14:49 <jle`> there's a similar story (but flipped) with (->)
22:15:14 <erisco> what about… mid hehe
22:15:18 <iqubic> c_wraith: It's both?
22:15:18 <jle`> `Writer w` only has a Monad instance if Monoid w
22:15:29 <erisco> I am guessing that is what the suggestion of "unit" was thinking of
22:15:39 <jle`> but `Writer w` is a Comonad no matter what 'w' is
22:15:54 <jle`> similarly, `(->) r` only has a Comonad instance if Monoid r
22:16:01 <jle`> but `(->) r` is a Monad no matter what 'r' is
22:16:08 <iqubic> Comonads are weird.
22:16:11 <c_wraith> Hmm.  the comonad package doesn't have an instance for Writer.  Is that because there's no obvious way WriterT is a comonad?
22:16:32 <iqubic> Functions can be comonads?
22:16:35 <c_wraith> Oh, it does have the ((,) e) instance.
22:16:46 <jle`> iqubic: types can be comonads
22:16:49 <jle`> just like types can be monads
22:16:50 <c_wraith> iqubic: functions aren't special.
22:17:15 <iqubic> What's a comonad again?
22:17:24 <c_wraith> https://hackage.haskell.org/package/comonad-5.0.2/docs/Control-Comonad.html  
22:17:26 <mniip> a comonoid in the category of endofunctors
22:17:53 <iqubic> mniip: I don't understand that.
22:18:05 <iqubic> I'm not a catagory theorist.
22:18:09 <jle`> iqubic: it's like a Monad but the function arrows are backwards
22:18:22 <jle`> Monad has return :: a -> m a, Comonad has extract :: w a -> a
22:18:25 <jle`> etc.
22:18:33 <iqubic> Huh? How does that work?
22:18:38 <jle`> it's a typeclass
22:18:40 <mniip> a pair of natural transformations F --> F (x) F  and  F --> I
22:18:47 <c_wraith> It works for different types than Monad does, mostly.
22:18:51 <jle`> iqubic: so like, you write instances for types
22:18:55 <jle`> and you give them those definitions
22:18:56 <mniip> which in haskell looks like f a -> f (f a)  and  f a -> Identity a
22:18:59 <iqubic> mniip: I don't know catagory theory
22:19:02 <mniip> with the Identity usually omitted
22:19:16 <jle`> iqubic: so like, instance Comonad Identity where extract (Identity x) = x
22:19:18 <jle`> etc.
22:19:25 <jle`> you just write an instance and define the methods
22:19:33 <jle`> instance Monad Identity where return x = Identity x
22:19:40 <jle`> just like for Monad, Functor, etc :)
22:19:42 <iqubic> I see.
22:19:44 <mniip> gotta honor the laws tho!
22:20:03 <iqubic> Are the laws backwards too?
22:20:07 <jle`> good guess
22:20:10 <jle`> and
22:20:12 <jle`> you're right
22:20:14 <jle`> :)
22:20:41 <mniip> left identity: extract . duplicate = id
22:20:48 * jle` realizes that he probably has the lowest average letter count per message on this channel
22:20:50 <mniip> right identity: fmap extract . duplicate = id
22:21:02 <erisco> if you compile your code on opposite day it has the dual behaviour
22:21:09 <mniip> associativity: duplicate . duplicate = duplicate . fmap duplicate
22:21:47 <mniip> err
22:21:49 <mniip> that's backwards
22:21:57 <mniip> duplicate . duplicate = fmap duplicate . duplicate
22:22:06 <erisco> use cokleisli
22:22:09 <jle`> there are laws but if you know the monad laws, you can just flip 'em
22:22:18 <jle`> that's how you play the dual game
22:22:24 <mniip> jle`, do you know the monad laws in terms of join?
22:22:54 <erisco> you just need extract as an identity of =>= and for =>= to be associative
22:22:56 <jle`> they're my favorite
22:23:02 <erisco> which is exactly the same laws as Monad
22:23:10 <erisco> they're both… monoids!
22:23:26 <jle`> heh
22:23:27 <jle`> not quite monoids
22:23:29 <jle`> but categories
22:23:29 <mniip> that's not a monoid
22:23:40 <mniip> yeah
22:23:47 <mniip> monoidoids
22:23:49 <jle`> aka a "partial monoid"
22:23:50 <erisco> I can't tell the difference syntactically
22:24:10 <erisco> look harder
22:24:10 <iqubic> @define loeb fs = xs where xs = fmap ($ xs) fs
22:24:12 <lambdabot>  Defined.
22:24:17 <iqubic> :t loeb
22:24:18 <lambdabot> Functor f => f (f b -> b) -> f b
22:24:20 <jle`> they're not monoids because you can't use =>= between every iteem necessarily
22:24:27 <iqubic> What the heck is that thing.
22:24:30 <jle`> so it's kind of like a "partial monoid".  aka, a category
22:24:48 <iqubic> It's the first example in a talk on comonad that I have found
22:24:56 <erisco> or actually just a monoid
22:25:05 <erisco> how is it not a monoid? show me the counter-example
22:25:14 <jle`> it's a monoid if you fix 'a'
22:25:19 <jle`> and talk about (A -> m A)'s
22:25:30 <erisco> doesn't look important to me
22:25:33 <mniip> > loeb [(\xs -> (xs !! 2) + 3), (\xs -> (xs !! 1) * 4), (\xs -> 5)]
22:25:33 <jle`> it's the "EndoM" monoid
22:25:39 <lambdabot>  mueval-core: Time limit exceeded
22:25:45 <mniip> oh err
22:25:46 <iqubic> > loeb [length, (!! 0), \x -> x !! 0 + !! 1]
22:25:48 <mniip> > loeb [(\xs -> (xs !! 2) + 3), (\xs -> (xs !! 0) * 4), (\xs -> 5)]
22:25:48 <lambdabot>  <hint>:1:38: error: parse error on input ‘!!’
22:25:50 <lambdabot>  [8,32,5]
22:25:50 <jle`> but, if you have two (A -> m B)'s
22:25:55 <jle`> you can't use >=> with themn
22:26:03 <iqubic> > loeb [length, (!! 0), \x -> x !! 0 + x !! 1]
22:26:06 <lambdabot>  [3,3,6]
22:26:07 <jle`> so it's not a monoid for (A -> m B)'s, or (a -> m b)'s in general
22:26:18 <iqubic> How does that loeb function work?
22:26:29 <mniip> iqubic, you have its definition
22:26:32 <mniip> ...that's how it works
22:26:40 <erisco> jle`, mm, okay
22:26:51 <jle`> well, it's not a monoid in the sense that a category is not a monoid
22:26:58 <iqubic> I don't understand fmap ($ xs) fs
22:27:07 <jle`> it's the same distinction, pretty much
22:27:17 <jle`> whether or not you consider it pedantic is not something i can really argue, heh
22:27:21 <mniip> iqubic, come on, you know all the parts it's made of
22:27:24 <iqubic> I get that it's a recursive definition, but I don't get what ($ xs) is doing there.
22:27:33 <iqubic> :t \x -> $ x
22:27:35 <lambdabot> error:
22:27:35 <lambdabot>     parse error on input ‘$’
22:27:35 <lambdabot>     Perhaps you intended to use TemplateHaskell
22:27:36 <erisco> so you need extra squinting to cope with the types
22:27:44 <iqubic> :t \f x -> f $ x
22:27:45 <mniip> iqubic, it's an operator section
22:27:45 <lambdabot> (t1 -> t) -> t1 -> t
22:27:46 <jle`> > ($ 10) succ
22:27:48 <pacak> :t \x -> ($) x
22:27:48 <lambdabot>  11
22:27:49 <lambdabot> (a -> b) -> a -> b
22:28:11 <mniip> like (+3) but ($x)
22:28:17 <iqubic> I see.
22:28:22 <iqubic> :t $
22:28:24 <lambdabot> error:
22:28:24 <lambdabot>     parse error on input ‘$’
22:28:24 <lambdabot>     Perhaps you intended to use TemplateHaskell
22:28:33 <jle`> what an unfortunate error message
22:28:48 <iqubic> I'm just used to seeing $ as a way of removing parens
22:28:52 <iqubic> :t ($)
22:28:54 <lambdabot> (a -> b) -> a -> b
22:29:21 <jle`> indeed it is a function
22:29:26 <iqubic> Anyway, why is the loeb function helpful?
22:29:40 <jle`> if you're seeing it in a talk...i suggest watching the rest of the talk
22:29:48 <jle`> presumably they present the motivation for bringing it up
22:29:58 <iqubic> > loeb (Maybe (+1))
22:30:00 <lambdabot>  error:
22:30:01 <lambdabot>      • Data constructor not in scope:
22:30:01 <lambdabot>          Maybe :: (Integer -> Integer) -> f (f b -> b)
22:30:07 <iqubic> > loeb (Just (+1))
22:30:10 <lambdabot>  error:
22:30:10 <lambdabot>      • Occurs check: cannot construct the infinite type: b ~ Maybe b
22:30:10 <lambdabot>        Expected type: Maybe (Maybe b -> b)
22:30:26 <iqubic> https://www.youtube.com/watch?v=F7F-BzOB670
22:30:35 <iqubic> That's the talk.
22:31:00 <mniip> good. Have you watched it
22:31:11 <iqubic> just the first 3 minutes.
22:31:22 <iqubic> I see the function definition, and an example usage.
22:31:46 <iqubic> > fmap (+1) [1,2,3,4,5]
22:31:48 <lambdabot>  [2,3,4,5,6]
22:32:45 <iqubic> > fmap ($ 1) [1,2,3,4,5]
22:32:47 <lambdabot>  error:
22:32:47 <lambdabot>      • Could not deduce (Num a0)
22:32:47 <lambdabot>        from the context: (Num (a -> b), Num a)
22:33:05 <michi7x7> :t ($)
22:33:07 <lambdabot> (a -> b) -> a -> b
22:33:28 <iqubic> the dollar sign is mysticall operator.
22:33:37 <mniip> it isn't?
22:33:47 <mniip> one of the simplest there is?
22:34:00 <iqubic> When used like this ($ xs) is xs the fuction, or the input to the function?
22:34:10 <erisco> no, it isn't, it isn't as simple as id
22:34:16 <mniip> iqubic, think about it
22:34:33 <mniip> what does (# x) mean for some operator #
22:34:34 <iqubic> :t \xs -> ($) xs
22:34:35 <lambdabot> (a -> b) -> a -> b
22:34:37 <mniip> what does it translate to
22:35:00 <MarcelineVQ> ($) xs  isn't  ($ xs)
22:35:00 <iqubic> it translates to \x -> # x.
22:35:03 <mniip> no
22:35:12 <iqubic> :t \xs -> ($ xs)
22:35:14 <lambdabot> a -> (a -> b) -> b
22:35:29 <michi7x7> > (fmap ($) [map (+1), reverse, negate]) [1,2,3,4]
22:35:32 <lambdabot>  error:
22:35:32 <lambdabot>      • Couldn't match expected type ‘[Integer] -> t’
22:35:32 <lambdabot>                    with actual type ‘[[b0] -> [b0]]’
22:35:37 <mniip> (\x -> # x) is invalid syntax and violates the specification of my question
22:35:49 <iqubic> What the hell? Is that a flipped version of before?
22:35:51 <mniip> because x is a free variable
22:35:52 <michi7x7> hmm,no
22:36:10 <mniip> iqubic, ok, what does (/ 3) translate to
22:36:20 <iqubic> Divide by three.
22:36:26 <mniip> in code
22:36:29 <erisco> what if we stopped teaching $ and just let it die
22:36:41 <iqubic> Not sure mniip.
22:36:50 <erisco> proposal for the report…
22:37:13 <iqubic> oh wait. (\ 3) translates to \x -> x \ 3
22:37:20 <MarcelineVQ> erisco: beginners would probably invent it anyway
22:37:34 <mniip> so what about (/ x)
22:37:35 <erisco> wouldn't be in Prelude :)
22:37:50 <iqubic> mniip: \y -> y \ x
22:37:56 <iqubic> for some x
22:39:29 <iqubic> > loeb [length, sum]
22:39:35 <lambdabot>  mueval-core: Time limit exceeded
22:40:02 <erisco> :t loeb
22:40:04 <lambdabot> Functor f => f (f b -> b) -> f b
22:40:10 <opqdonut> > loeb [length, succ.head]
22:40:12 <lambdabot>  [2,3]
22:40:31 <opqdonut> it's a spreadsheet!
22:40:32 <iqubic> erisco: I defined loeb earlier.
22:40:45 <iqubic> opqdonut: why do you say that?
22:40:59 <iqubic> :t succ
22:41:00 <lambdabot> Enum a => a -> a
22:41:25 <erisco> oh so it isn't this http://hackage.haskell.org/package/prelude-generalize-0.4/docs/Prelude-Generalize.html#v:loeb
22:41:27 <opqdonut> > loeb [const 3, const 5, \xs -> sum (take 2 xs), \xs -> xs !! 0 + xs !! 2]
22:41:29 <lambdabot>  [3,5,8,11]
22:41:38 <opqdonut> that's clearly a spreadsheet
22:41:57 <opqdonut> each cell is a formula, and loeb computes them "all at once"
22:42:06 <iqubic> No.
22:42:33 <iqubic> loeb fs = xs where xs = fmap ($ xs) fs
22:42:48 <iqubic> opqdonut: yes. I believe that's right.
22:42:56 <opqdonut> a fixed point of sorts
22:43:19 <koz_> Oh, the Loeb function.
22:43:27 <koz_> Or, as I like to call it, 'What, how does this even?'.
22:43:49 <iqubic> But the way it's evaluated each function only gets to see the results of the functions before it.
22:44:22 <iqubic> koz_: Yeah it came up in a talk on comonads that I'm looking at.
22:44:35 <koz_> iqubic: I think I know the one you mean.
22:44:48 <iqubic> Also, erisco, I keep confusing cofunctors and comonads
22:45:07 <koz_> iqubic: A cofunctor is just a functor... do you mean contravariant functor?
22:45:09 <opqdonut> iqubic: no, all functions see all the results
22:45:12 <opqdonut> > loeb [last, const 3]
22:45:14 <lambdabot>  [3,3]
22:45:33 <iqubic> How the hell does that work?
22:45:42 <opqdonut> c.f.
22:45:44 <opqdonut> > fix $ \xs -> [3, 5, sum (take 2 xs), xs !! 0 + xs !! 2]
22:45:46 <lambdabot>  [3,5,8,11]
22:45:54 <Axman6> magic
22:45:56 <opqdonut> laziness, tying the knot
22:46:25 <koz_> I agree with Axman6: When I saw the Loeb function, I was like '?!??!'.
22:46:28 <iqubic> > loeb [sum, last, const 3]
22:46:33 <lambdabot>  mueval-core: Time limit exceeded
22:46:40 <opqdonut> sorry, sum doesn't really work
22:46:47 <iqubic> > loeb [head, last, const 3]
22:46:50 <Axman6> the implementation wasn't very enlightening for me either
22:46:52 <lambdabot>  mueval-core: Time limit exceeded
22:46:58 <opqdonut> that's a head->head loop
22:47:19 <michi7x7> > loeb [last, head, const 7]
22:47:22 <lambdabot>  [7,7,7]
22:47:24 <opqdonut> yep
22:47:52 <iqubic> > loeb [last, head, length, (!! 0)]
22:47:58 <lambdabot>  mueval-core: Time limit exceeded
22:48:06 <michi7x7> > loeb [sum . tail, const 3, const 4]
22:48:09 <lambdabot>  [7,3,4]
22:48:22 <iqubic> > loeb [last, head, ,(!! 0) length]
22:48:26 <lambdabot>  <hint>:1:19: error: parse error on input ‘,’
22:48:27 <iqubic> > loeb [last, head, (!! 0) length]
22:48:29 <lambdabot>  error:
22:48:29 <lambdabot>      • Couldn't match expected type ‘[[b] -> b]’
22:48:29 <lambdabot>                    with actual type ‘[a0] -> Int’
22:48:32 <iqubic> > loeb [last, head, (!! 0), length]
22:48:35 <lambdabot>  [4,4,4,4]
22:49:01 <iqubic> > loeb [last, head, (!! (length -1)), length]
22:49:04 <lambdabot>  error:
22:49:04 <lambdabot>      • Couldn't match expected type ‘Int’
22:49:04 <lambdabot>                    with actual type ‘t0 a0 -> Int’
22:49:22 <iqubic> michi7x7: how did you get sum to work??
22:49:38 <iqubic> Oh, you summed all but head
22:50:10 <michi7x7> iqubic: yeah, that way you don't recursively sum the sum
22:50:34 <michi7x7> > tail $ loeb [sum, const 3, const 4]
22:50:37 <lambdabot>  [3,4]
22:50:54 <iqubic> so loeb is weird.
22:52:06 <iqubic> :t contrmap
22:52:08 <lambdabot> error:
22:52:08 <lambdabot>     • Variable not in scope: contrmap
22:52:08 <lambdabot>     • Perhaps you meant ‘contramap’ (imported from Control.Lens)
22:52:12 <iqubic> :t contramap
22:52:14 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
22:52:23 <iqubic> How does that work exactly?
22:52:39 <Axman6> @src loeb
22:52:39 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
22:52:45 <MarcelineVQ> aren't you watching a talk about it?
22:52:55 <koz_> @src contramap
22:52:55 <lambdabot> Source not found. Whoa.
22:53:01 <iqubic> No, I'm watching a comonad talk
22:53:05 <koz_> lambdabot: Son, I am disappoint.
22:53:14 <iqubic> loeb fs = xs where xs = fmap ($ xs) fs
22:53:27 <iqubic> Axman6: that's the definition I gave to lambdabot
22:54:35 <Axman6> you should apply ther Feynman technique to figuring out how it works.
22:55:32 <jchia1> What's the advantage of using FilePath instead of Text other than that many packages require it? I could assume latin1 encoding & use Text in all my code and convert to and from FilePath when I need to use those libraries. I see convenience functions like (</>) but that alone is not a compelling reason as I could easily define something similar for Text. At the end of the day, what's intrinsically special about FilePath that we cannot just use Text instead?
22:55:51 <Axman6> (or, not not quite feynman technique) - 1) Write down the problem 2) think really hard 3) write down the answer
22:56:02 <iqubic> Axman6: that sounds good.
22:59:00 <jchia1> I'm also quite confused about the different types with the name FilePath defined in different places like System.FilePath.Posix (filepath) & Filesystem.Path (system-filepath)
23:00:19 <monochrom> jchia1: On top of that---or rather, underneath that, different OSes store filenames differently, Windows uses UTF-16 and Linux uses UTF-8.
23:00:28 <jchia1> So when I read the docs for some library that uses FilePath, I have to spend some time figuring out which FilePath they mean and whether the libraries I'm using all man the same thing when they say 'FilePath'.
23:00:44 <mac10688> anyone know how to turn Maybe a into a and ignore the Nothing? I guess I can do it myself, I'm just wondering if there's a quick built in function
23:01:03 <erisco> mac10688, fromJust, now shoot yourself in the foot :)
23:01:19 <jchia1> monochrom: I think on Linux, the filesystem doesn't designate any encoding -- it's just bytes. For windows I'm not sure.
23:01:27 <Axman6> fromMaybe is the safer way to do it though
23:01:30 <Axman6> :t fromMaybe
23:01:32 <lambdabot> a -> Maybe a -> a
23:01:39 <dminuoso> Cale, okay that solves all the confusion in the world. I kept thinking the set of that monoid was the set of all endofunctors, which is why I was trying to understand why there was no join [Just 3].
23:01:41 <dminuoso> Cale, thank you :)
23:02:03 <mac10688> thanks erisco and Axman6 
23:02:15 <erisco> mac10688, it is a bit better to do the pattern matching yourself so you can give a custom error message
23:02:46 <monochrom> @quote monochrom safeFromJust
23:02:46 <lambdabot> monochrom says: I use safeFromJust :: Maybe a -> Maybe a
23:02:56 <mac10688> yeah I see fromJust throws an error message if something is wrong, not a fan of that
23:03:00 <mac10688> lol safeFromJust
23:03:22 <mac10688> Maybe I've had to much to drink but safeFromJust is funny to me
23:04:05 <erisco> abortWithOnNothing :: String -> Maybe a -> a   summin like that
23:05:16 <erisco> it'd be slick if there were compiler constants for current file location
23:05:31 <Axman6> "SafeFromJust: The Essence of Safety"
23:05:35 <erisco> such as  abortWithOnNothing __LOC__ m
23:05:48 <opqdonut> erisco: I guess CPP gives you stuff like that
23:06:05 <erisco> does it? I don't know cpp
23:06:25 <Axman6> HasCallstack does give you that though
23:06:32 <phadej> that ^
23:06:54 <erisco> never heard of it
23:08:17 <opqdonut> this looks like a good intro to CPP, https://guide.aelve.com/haskell/cpp-vww0qd72
23:08:31 <opqdonut> but HasCallstack is probably neater
23:09:29 <erisco> what package is that
23:10:11 <Axman6> base?
23:11:06 <erisco> what module
23:11:39 <erisco> GHC.Stack
23:11:42 <opqdonut> https://hackage.haskell.org/package/base-4.10.0.0/docs/GHC-Stack.html
23:14:37 <wz1000> why do mtl classes have seperate instances for every transformer? Why doesn't a catch all instance like instance (MonadTrans t, MonadReader r m) => MonadReader r (t m) work?
23:14:49 <erisco> reqJust :: Maybe a -> a; reqJust (Just x) = x; reqJust _ = error (prettyCallStack callStack)
23:16:34 <c_wraith> wz1000: two major reasons.  1. that overlaps everything, and overlapping is really awkward.  2.  Some combinations aren't valid.
23:20:04 <wz1000> c_wraith: which combinations?
23:23:17 <Axman6> generally ContT breaks things
23:23:27 <Axman6> (well, in some cases anyway)
23:32:00 <iqubic> :t absurd
23:32:02 <lambdabot> Void -> a
23:32:14 <iqubic> Does that create a from nothing?
23:32:20 <iqubic> :k Void
23:32:22 <lambdabot> *
23:32:35 <erisco> > fix absurd
23:32:41 <lambdabot>  mueval-core: Time limit exceeded
23:33:09 <erisco> lost in the void
23:33:32 <c_wraith> iqubic: sort of.  except there are no values of type void, so it can never be called
23:33:43 <c_wraith> err, type Void
23:33:54 <erisco> primed
23:35:48 <iqubic> So why does Void exist?
23:35:57 <iqubic> Why write absurd?
23:36:13 <pacak> A typesafe way of handling impossible cases
23:36:36 <iqubic> Morning pacak.
23:37:16 <pacak> If your function needs to return Either but you know that only one of them is ever possible - you make return of type Either Void a, and when handling - use either absurd handeFoo
23:37:34 <opqdonut> that's a good example
23:37:41 <nshepperd> Void is 0, () is 1, Bool is 2
23:37:47 <opqdonut> another would be typing "forever :: IO a -> IO Void"
23:37:55 <opqdonut> :t forever
23:37:56 <lambdabot> Applicative f => f a -> f b
23:37:59 <opqdonut> sadly, that's not the type
23:38:03 <nshepperd> if you ask, why does 0 exist the reason is kind of similar
23:38:10 <pacak> If you need to change your function - absurd won't typecheck.
23:38:16 <opqdonut> but "forall b. IO b" is pretty close to "IO Void"
23:38:27 <pacak> so it's better than either (error "impossible") handleFoo
23:38:35 <opqdonut> there was actually a blog post I saw about when to use forall a. a vs. Void
23:39:20 <opqdonut> this one: https://www.fpcomplete.com/blog/2017/07/to-void-or-to-void
23:41:17 <nshepperd> forall b. IO b is better isn't it
23:41:21 <nshepperd> as an output
23:41:21 <mac10688> actually erisco I didn't ask the right question. I want to filter the Just from a list a of maybes. I found catMaybes fit my needs perfectly
23:41:27 <nshepperd> the user can choose Void if they want
23:44:37 <opqdonut> nshepperd: yeah
23:49:57 <norc_> Good morning. Got two questions, first: https://www.haskell.org/tutorial/monads.html in 9.1 when its defining `mzero >>= m = mzero`, is that a typo and supposed to say >> 
23:50:00 <norc_> ?
23:51:20 <iqubic> :t mzero
23:51:21 <lambdabot> MonadPlus m => m a
23:51:35 <iqubic> :t (>>)
23:51:37 <lambdabot> Monad m => m a -> m b -> m b
23:51:48 <iqubic> :t (>>=)
23:51:50 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:51:51 <ackpacket> ow :t (>>=)
23:52:21 <iqubic> Yes, I think that should be (>>)
23:52:28 <ackpacket> :t (=<<)
23:52:30 <lambdabot> Monad m => (a -> m b) -> m a -> m b
23:52:44 <ackpacket> So the arguments are just reversed?
23:52:48 <iqubic> Yes.
23:52:50 <norc_> ackpacket: Yup.
23:52:53 <iqubic> Basically
23:53:09 <norc_> ackpacket: =<< makes the relationship to fmap more obvious :)
23:53:16 <norc_> :t fmap
23:53:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:53:23 <ackpacket> :t (<$>)
23:53:24 <norc_> :t (=<<)
23:53:25 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:53:25 <iqubic> :t \m -> mzero >>= m
23:53:26 <lambdabot> Monad m => (a -> m b) -> m a -> m b
23:53:27 <lambdabot> MonadPlus m => (a -> m b) -> m b
23:53:30 <iqubic> :t \m -> mzero >>= m
23:53:32 <lambdabot> MonadPlus m => (a -> m b) -> m b
23:53:48 <iqubic> :t \m -> mzero >> m
23:53:50 <lambdabot> MonadPlus m => m b -> m b
23:54:00 <iqubic> Yes, that really should be >>
23:54:07 <nshepperd> mzero >>= f = mzero
23:54:19 <norc_> Okay second question. Why does this give me an ambiguous type variable b0 [...] error? print $ [1] >>= \x -> []
23:54:26 <iqubic> But is that the correct version of that?
23:54:34 <nshepperd> looks a bit weird to use 'm' for a function but it's the same thing
23:54:35 <norc_> Is this because its not clear what type [a] should have for the final [] ?
23:54:37 <Hafydd> norc_: it is supposed to be >>=, but m is an unusual name. Perhaps it should be f.
23:54:57 <Hafydd> Compare https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.10.0.0/Control-Monad.html#t:MonadPlus
23:55:14 <norc_> Hafydd: Ahh. Indeed.
