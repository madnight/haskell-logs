00:01:26 <xzhu> I'm still reading the documentation, but is there like a way to quickly pull out things using CSS queries like "#container>.info-block"
00:02:39 <Cale> No, it doesn't implement CSS selectors, that would be fairly ambitious.
00:03:08 <Cale> Apparently someone implemented them for HXT though
00:04:03 <xzhu> I just found @hackage scalpel
00:04:10 <xzhu> @hackage scalpel
00:04:10 <lambdabot> http://hackage.haskell.org/package/scalpel
00:04:54 <xzhu> Seems to be sufficient, and it's very parsec-y
00:05:09 <Cale> ah, that looks nice
00:06:24 <essa> ..
00:07:05 <essa> 11vdfv
00:07:11 <essa> ljj
00:07:17 <essa> sgfhjhf
00:07:19 <essa> jd
00:07:59 <essa> fgnm
00:08:02 <essa> ghkhgk
00:08:36 <eacameron> xzhu: I've used scalpel
00:08:52 <eacameron> It's pretty nice; a couple things are not-ideal, but pretty nice all around
00:08:56 <eacameron> Don't use curl...
00:09:35 <pacak> essa: Keep us informed.
00:11:53 <xzhu> eacameron: I think the `hasClass` is unnecessarily verbosed
00:12:05 <xzhu> should've been a infix operator
00:12:11 <xzhu> like `@.`
00:12:51 <eacameron> xzhu: Possibly. Depends on how much you use it in your scraper probably.
00:12:59 <eacameron> But the beauty is... you can just define one!
00:13:02 <Cale> You can always do that yourself
00:13:05 <Cale> yeah
00:13:58 <eacameron> The one thing scalpel doesn't support that I've found is grabbing siblings
00:14:07 <eacameron> There's an issue for it on GitHub
00:14:32 <eacameron> Hard to do "find the p tag with this class and get the one *after* that"
00:14:47 <eacameron> You can sort of kind of do it with "position"
00:15:07 <erikd> is it possible to catch Control.Monad.fail ? i'm not in IO.
00:15:20 <Cale> erikd: not in general
00:15:31 <eacameron> erikd: What is `fail` defined to be for your monad?
00:15:35 <Cale> erikd: Mostly I try to pretend that fail doesn't exist.
00:15:52 <erikd> its just uses Monad.fail
00:15:55 <Cale> It doesn't belong in the Monad type class
00:16:00 <Cale> huh?
00:16:04 <erikd> i agree
00:16:11 <eacameron> Cale: Didn't they pull it out recently?
00:16:17 <eacameron> MonadFail
00:16:28 <Cale> eacameron: Oh, if so, that's great :)
00:16:30 <erikd> it going to be pullsed out. hasn't happened yet
00:17:08 <Cale> I'm still mostly stuck on 8.0.2 anyway
00:17:21 <Cale> (because GHCJS)
00:17:23 <eacameron> "Stuck on 8.0.2" <- sad times lol
00:17:46 <eacameron> 8.2.1 did JUST come out like a month ago
00:17:47 <eacameron> hahah
00:18:38 <Cale> There's a bunch of optimisations that 8.2.1 does which would be really nice to have
00:18:45 <eacameron> erikd: fail by default is errorWithoutStackTrace 
00:19:03 <eacameron> You could possibly define a newtype around your monad and define a new fail
00:19:30 <eacameron> But I don't know if that would actually help
00:19:31 <Cale> erikd: I'm not sure I understood your answer to the question about how fail was implemented
00:19:38 <Cale> Which monad are we talking about?
00:20:16 <xzhu> Cale: BTW, this question just came to me, how does GHCJS compile the unboxed vectors in the vector library? 
00:21:12 <xzhu> Cale: do the unboxed vectors have the same performance characteristics as they do when compiled to machine code? (Can't imagine they do)
00:21:20 <erikd> Cale: its the Unpacking monad from Data.Packer which is just an instance of Monad
00:21:58 <Cale> xzhu: No, nothing is the same
00:22:08 <kuribas> xzhu: I have numerical code that is about 1000 times slower in ghcjs.  It doesn't use vector much though...
00:22:18 <Cale> erikd: Yeah, the question is about how that instance implements fail
00:22:29 <kuribas> xzhu: IMHO ghcjs isn't quite ready for numerical code
00:22:44 <erikd> Cale: it doesn't. i think it just falls through to the one in Monad
00:23:01 <Cale> Right, it's just using the default implementation which errors out
00:23:12 <Cale> So, yeah, practically uncatchable
00:23:15 <xzhu> kuribas: But I guess I'm more curious if GHCJS + vector can generate code as fast as hand-written JS code?
00:23:17 <eacameron> You can catch that though...at the top
00:23:38 <kuribas> xzhu: I really doubt it
00:23:44 <erikd> eacameron: unfortunately i need to catch it locally
00:23:50 <Cale> eacameron: Sort of...
00:24:07 <Cale> You can catch it from IO, but it relies on careful evaluation order trickiness
00:24:20 <Cale> and so you'd really rather not even attempt to
00:24:34 <eacameron> Cale: right...yeah. rnf
00:24:48 <Cale> I would go so far as you grab the source code for the package which is using fail and modifying it to not do that before trying to catch such an exception
00:24:58 <Cale> to*
00:25:13 <eacameron> The trick is...what do you make it fail *to*?
00:25:18 <erikd> anyway, looking at the code, it seems to use throwIO for the things i'm interested in, so i should be able to catch it
00:25:31 <Cale> eacameron: Make it produce Either or use Maybe or something instead
00:25:42 <Cale> and just refactor everything until it makes sense again
00:25:53 <eacameron> Cale: Yeah I see. That's a lot of refactoring.
00:25:56 <Cale> Ah, throwIO is nicely catchable
00:26:05 <eacameron> which means...it must be running in IO
00:26:17 <xzhu> Is GHCJS just mapping assembly instructions 1-1 to a subset of js?
00:26:30 <Cale> xzhu: Pretty much
00:26:32 <eacameron> And it's only catchable locally if the monad is *also* an instance of MonadCatch, etc.
00:26:42 <Cale> xzhu: Not *exactly* that
00:27:03 <Cale> xzhu: There are a bunch of handwritten shims for a bunch of stuff which would normally come from C libraries
00:27:19 <Cale> or which are from lower level Haskell libraries
00:28:03 <xzhu> Huh. I wonder if WebAssembly is going to make Haskell perform better then
00:28:27 <Cale> Probably
00:28:48 <Cale> That's the hope anyway
00:29:09 <Cale> Depends on how good the implementations of WebAssembly are
00:30:57 <Cale> https://github.com/ghcjs/shims/blob/master/pkg/bytestring.js -- here's a shim containing translations of some bits of C that are part of bytestring.
00:32:30 <hous> when installing a program with stack, it is not detecting that I already have packages installed with cabal
00:32:51 <hous> global install on osx
00:33:04 <Cale> https://github.com/ghcjs/shims/blob/master/pkg/process.js probably just enough of System.Process to get some Template Haskell somewhere to work ;)
00:34:01 <Cale> hous: That is correct.
00:34:54 <hous> that is standard behavior?
00:35:07 <Cale> hous: There might be a way to configure it to use your globally installed GHC packages as part of resolving which packages to use, but by default it doesn't, and I've never seen that done.
00:36:27 <Cale> One of the major design goals of Stack is to avoid conflicts that arise from packages which were compiled against different sets of dependencies, so it doesn't tend to care about what you have installed by hand.
00:37:08 <Cale> It also tends to use its own ghc on top of that...
00:38:09 <hous> Cale: OK so when I use stack to install a program that I want to run globally, it will basically attempt to resolve all dependencies and build all of them for that program, and also will it place those dependencies within that program directory
00:38:33 <Cale> hous: Usually they'll just get statically linked into the executable
00:38:41 <hous> so that when I install the next program, it will re-download and re-build all dependencies over again?
00:38:57 <Cale> Well, it has its own cache of the packages and compilers that you've used.
00:39:13 <hous> ok
00:39:50 <hous> it's just funny because I spent a bunch of time installing packages via cabal so that I could install stack (old computer, can't download pre-built binaries)
00:40:00 <Cale> I'm actually not a great person to be answering questions about stack, since I've actually never had a good chance to use it.
00:40:18 <hous> and now that I want to use stack going forward, I have to re-build a bunch of packages I just built
00:40:18 <Cale> We use nix to build all our stuff where I work
00:41:37 <hous> I can keep looking at how it works globally
00:41:52 <Cale> Usually you don't want to install packages system-globally
00:41:56 <Cale> That turns into a mess
00:42:36 <kuribas> what's your dayjob language?
00:42:39 <hous> maybe I'm using the word globally wrong
00:42:47 <Cale> Leave the set of packages that came when you installed GHC separate, and that way if your package database gets messed up somehow, you can just blow away ~/.ghc and not worry about it
00:43:08 <Cale> kuribas: Me? Haskell.
00:43:17 <kuribas> anyone?
00:43:32 <boj> my team also uses haskell
00:43:42 <hous> I'm following this page: http://hledger.org/download.html
00:43:52 <kuribas> do you need to relocate if you want a haskell job?
00:44:03 <xzhu> Did I just find a bug
00:44:05 <xzhu> ghc: panic! (the 'impossible' happened)
00:44:06 <xzhu>   (GHC version 8.0.2 for x86_64-unknown-linux):
00:44:06 <xzhu>         initTc: unsolved constraints
00:44:06 <xzhu>   WC {wc_insol =
00:44:06 <xzhu>         [W] many_a1ku :: t_a1kt[tau:1] (CHoleCan: many)
00:44:08 <xzhu>         [W] scrapeUrl_a2kI :: t_a2kH[tau:1] (CHoleCan: scrapeUrl)}
00:44:10 <xzhu> Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
00:44:14 <mauke> xzhu: ...
00:44:15 <hous> and specifically installing this program via stack install command
00:44:18 <boj> kuribas: probably. they are so uncommon
00:44:33 <hous> so, it's not like I'm using stack to install packages into a specific project directory
00:44:43 <boj> unless you can find a remote team, but your skillset tends to need to be high
00:45:01 <hous> it's just a stack install, so it's going into my user folder, I call that global as opposed to local
00:45:31 <eacameron> xzhu: Ew. :(
00:46:24 <Cale> xzhu: Probably, yes.
00:46:27 <boj> xzhu: a) please most multiple lines to lpaste or something, b) that isn't a bug. i've seen that recently and if i recall you may have some out of order TH
00:46:44 <mauke> boj: dude, it's totally a bug
00:46:49 <boj> *post
00:47:10 <mauke> it says so right there: "Please report this as a GHC bug: ..."
00:47:14 <boj> mauke: maybe it is
00:47:37 <Cale> Well, it's sometimes possible to trigger that message in ways that would be questionably GHC bugs
00:47:37 <kuribas> boj: if it is not a bug, then it's a bug that ghc says it's a bug :)
00:48:09 <boj> ok, then my "fix" was a workaround, i accept that
00:48:12 <mauke> kuribas: exactly
00:48:31 * eacameron twiddles bits in GHC's memory address space -- "hehehe, I found a 'bug'"
00:48:35 <boj> i don't entirely recall what it was, i thought that it was because i did something horrible wrong
00:48:45 <Cale> But yeah, that looks very much like a bug. Try 8.2.1 if it's not too difficult, and see if it still happens.
00:49:33 <eacameron> Yeah 8.2.1 fixed a lot of bugs...some of them big
00:50:12 <eacameron> I've had a weird segfault in one of my servers ever since 7.10. I haven't tried 8.2 yet, but the workaround was to "print" the value before calling the function I wanted.
00:50:57 <boj> sounds like you had a thunk full of bad logic that wasn't apparent until you called it out
00:51:03 <eacameron> Pretty convenient that my debugging "print" statement "fixed" the issue :rage:
00:51:39 <mauke> does 'evaluate' also fix it?
00:52:04 <eacameron> mauke: It's been a long time, I was gonna have to fork the project and make it an instance of NFData, etc.
00:52:08 <mauke> or maybe evaluate . length . show
00:52:18 <eacameron> fork the dependency
00:52:55 <eacameron> I've since found the evil NFData without NFData trick
00:53:22 <eacameron> https://hackage.haskell.org/package/deepseq-magic
00:56:33 <xzhu> I was trying to use stack nightly instead of LTS but when I changed the resolver in the stack.yaml, and tried to do `stack setup`, I got
00:56:34 <xzhu> Unable to parse cabal file: FromString "This package requires at least Cabal version 2.0" Nothing
00:57:02 <xzhu> stackoverflow suggests `stack setup --upgrade-cabal`. I tried -- same error
00:57:45 <eacameron> xzhu: I always clear out .stack-work when I do stuff like that
00:57:48 <eacameron> just in case
00:58:44 <xzhu> I just did -- same error
00:59:37 <eacameron> Sorry, I haven't tried 8.2 yet with stack (or anything else for that matter)
01:05:08 <xzhu> It's a bug of stack 1.5.0, which has been fixed in 1.5.1: https://github.com/fpco/stackage/issues/2742
01:05:26 <eacameron> xzhu: Ah
01:10:41 <marcelo> Hello
01:13:34 <cr1t1cal> marcelo: hello
01:20:12 <cr1t1cal> how is it possible for a language to be statically typed and also have type inference?
01:20:50 <mauke> uh
01:21:01 <mauke> how could a language have type inference without static types?
01:21:13 <lefinch> xhmhx
01:22:26 <[exa]> cr1t1cal: how's that weird?
01:22:28 <cr1t1cal> mauke: if it was dynamically typed, an assignment like "x = 5" could dynamically find the type of x by evaluating 5
01:22:40 <cr1t1cal> i think i am missing something here
01:22:50 <[exa]> cr1t1cal: that's dynamic type inference
01:22:58 <mauke> cr1t1cal: that's not type inference
01:23:19 <[exa]> cr1t1cal: static one does that on compile time without actually evaluating anything
01:23:19 <cr1t1cal> so it is?
01:23:29 <cr1t1cal> ok
01:23:39 <mauke> it's not types in the "type system" sense
01:23:42 <cr1t1cal> you know virtual in c++ yes?
01:23:51 <[exa]> yes
01:24:02 <mauke> dynamic types are assigned to (runtime) values
01:24:11 <cr1t1cal> that dynamically figures out the type of y in "x = y" during runtime
01:24:16 <mauke> static types are assigned to expressions, i.e. parts of your program code
01:24:22 <mauke> cr1t1cal: no, it doesn't
01:24:34 <cr1t1cal> ?
01:24:50 <[exa]> cr1t1cal: C++'s RTTI doesn't figure anything out. The object of 'x' contains a pointer to the exact implementation of '=' that should be used
01:24:51 <mauke> C++ 'virtual' says "this function can be called through a pointer/reference to a base class"
01:25:29 <[exa]> (or, more exactly, pointer to vtable that contains the pointer to the = implementation)
01:25:37 <cr1t1cal> and the function is specified at runtime by the type of the derived class assigned to the base class pointer?
01:25:39 <cr1t1cal> i think i remember now
01:25:56 <mauke> struct Base { void foo() {} }; struct Derived : Base { void foo() {} };
01:26:24 <mauke> Derived d; Base *p = &d; p->foo();  // no virtual, so this calls Base::foo()
01:26:25 <cr1t1cal> Base *b = new Derived; b->foo() will call the Base foo
01:26:34 <cr1t1cal> ah
01:26:36 <cr1t1cal> yeah I remember
01:26:56 <cr1t1cal> python is dynamically typed right?
01:26:59 <[exa]> cr1t1cal: there's some specification of exact implementations in the runtime, using the pointer; but that has nothing in common with dynamic types
01:27:26 <[exa]> yeah python is dynamically typed
01:27:27 <cr1t1cal> sorry if this is not relevant to haskell but just trying to understand this concept of type inference
01:27:32 <cr1t1cal> ah okay
01:27:39 <[exa]> no problem :]
01:27:44 <cr1t1cal> so when haskell is interpreted, is IT dynamically typed?
01:27:57 <cr1t1cal> like with runghc
01:28:32 <nisstyre> cr1t1cal: there's something called type erasure
01:28:34 <[exa]> the types still need to be inferred statically before anything is run, iirc
01:28:39 <nisstyre> usually it's a phase in the compiler
01:28:59 <nisstyre> once it has translated your code into a certain form it gets rid of the type information
01:29:43 <nisstyre> you could say that the code that the actual runtime system runs is dynamically typed I guess, but that's machine code
01:30:10 <cr1t1cal> ok so haskell interpretation is just "compile then execute"?
01:30:49 <[exa]> the main thing is that it's typechecked so it doesn't need to check out types of everything at runtime, like traditional dynamic languages do
01:30:57 <nisstyre> I mean I don't know exactly what ghci does but that's basically it yeah, it would run your code automatically for you (interpret it)
01:31:04 <nisstyre> when you compile it then it would produce a binary
01:31:10 <nisstyre> which does not have any idea about type info
01:32:45 <nisstyre> there's https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Typeable.html
01:33:04 <nisstyre> but that's not something in the language specification
01:33:14 <nisstyre> well it's in base so idk
01:37:21 <[exa]> cr1t1cal: if you know c++, the difference between the C++ typecheck and type inference is that c++'s typecheck can only derive the types of stuff in the direction of evaluation (like, say 5+5 will be integer); haskell-style inference can do it backwards (e.g. very simplified example, if it knows that a+b should result in integer, it will know a and b will be integers)
01:38:57 <nisstyre> that's also what unification is, it will take the type of + (say Int -> Int -> Int for argument's sake) and then it will say that the first argument is of type "a", and the second "b"
01:39:07 <nisstyre> then it knows that a and b aren't bound to anything yet
01:39:17 <nisstyre> so it tries to unify a with the first argument (Int)
01:39:27 <nisstyre> which succeeds because it hasn't got a type
01:39:32 <nisstyre> then it does the same with b
01:39:40 <nisstyre> so now it knows the types of both args
01:40:01 <Bind> anyone out there?
01:40:06 <nisstyre> that's type unification more or less
01:40:24 <nisstyre> if a is already bound to something like String say
01:40:40 <nisstyre> then it would fail because it can't unify Int and String
01:41:18 <Bind> What does "to unify" mean?
01:41:23 <nisstyre> make the same
01:41:46 <Bind> I mean, in this context
01:41:51 <Bind> Conversion?
01:41:57 <[exa]> Bind: no, it's like in prolog
01:42:15 <Bind> Hm, okay
01:42:21 <nisstyre> it's that you can use both types wherever either one would be required
01:42:33 <[exa]> Bind: e.g. (Int -> a) unified with (b -> Float) returns  (Int -> Float) and substitution {a:=Float, b:=Int}
01:42:44 <nisstyre> yeah, you have a substitution
01:42:49 <nisstyre> which is like a dictionary
01:42:58 <nisstyre> that's called your unifier
01:43:35 <Bind> Yeah
01:43:43 <nisstyre> this also requires you to generate unique type variables in that scope
01:43:48 <[exa]> Bind: the algorithm is "robinson unification" afaik, also described by Martelli-Montanari or some similar 2 italian names starting from M that I can't remember
01:44:28 <ski> Bind : "What does \"to unify\" mean?" -- to make equal, to equate
01:45:10 <Bind> So it's like "mixing" two types via the type variables where you can "puta" Int and Float like un that example?
01:45:11 <ski> Bind : like solving equations, the equation `(Int -> a) = (b -> Float)' has the solution that `a = Float' and `b = Int'
01:45:25 <Bind> Put*
01:45:51 <[exa]> Bind: btw also consider the 2 cases when the unification fails; try unifying (Int) with (Int->Int), and for a more interesting example (a) with (a->Int) where 'a' is a variable
01:46:10 <ski> you can also think of pattern-matching (if that term in a technical sense makes any sense to you)
01:46:24 * ski suspects Bind might not know any Prolog
01:46:49 <cr1t1cal> is LT and GT actually.. "values"
01:46:53 <ski> yes
01:46:58 <cr1t1cal> lol
01:47:00 <cr1t1cal> k thx
01:47:17 <[exa]> Bind: yeah, equation solving by assigning content to variables so that 2 things are same.
01:47:28 <Bind> No, I don't know Prolog so that's probably why i didn't understand at first
01:47:49 <ski> <cr1t1cal> and python doesn't like when I use spaces AND tabs  <cr1t1cal> but with just tabs for indentation  <cr1t1cal> it doesn't start crying. haskell apparently does
01:47:51 <[exa]> Bind: try out why the 2 failure cases can't unify :]
01:48:56 <ski> cr1t1cal : ^ well, if you use *only* tabs for indentation, it also works in Haskell. but you must be disciplined enough to always break line after a layout-introducing keyord (that's `where',`let',`of',`do') followed by a block of several lines
01:49:30 <[exa]> cr1t1cal: problem with tabs is that people can't agree how many spaces they actually have
01:50:21 <[exa]> cr1t1cal: also, LT/GT/EQ is in C++ as -1/+1/0 returned from strcmp-like functions
01:50:24 <ski> (and this is not the norm, among people who use spaces for indentation in Haskell, so it might be more difficult to adapt and adhere to, especially if you haven't identified that this is what you would need to do, to use tabs for indentation in Haskell)
01:51:02 <ski> [exa] : the above solution makes so that it doesn't matter how many spaces one considers a tab equivalent to .. if you adhere strictly to it
01:51:21 <[exa]> there should probably be a wiki entry that shows how to make popular editors output spaces instead of tabs
01:51:28 <ski> i've heard a few people here claim that they do this .. but it's not that common
01:52:26 <[exa]> well the problem comes when the code goes to any other programmer
01:52:27 <[exa]> :]
01:52:35 * [exa] -> afk
01:52:47 <ski> well, only if they decide to put in spaces, right
01:53:01 <ski> if they just read it (in their editor of choice), then there's not a problem
01:53:08 <nisstyre> good old :retab in vim helps
01:54:16 <ski> (well, depending, the code might drift a bit more (or less) to the right than would be desirable. but the relative indentation should be viewed consistently and reliably)
01:54:46 <nisstyre> I know some people like to perfectly align their code, especially when let or where are involved
01:54:56 <nisstyre> that involves a variable number of spaces unfortunately
01:55:12 <nisstyre> if they used tabs and spaces that would be totally impossible to convert automatically
01:55:15 <ski> yeah, i often align corresponding argument patterns from different defining equations
01:55:57 <ski> if i used tabs for that, either i'd get very "spacy" code (drifting off to the side quickly), or i'd have to set local tab stops, &c.
01:57:43 * ski isn't sure GHC would be happy with such ANSI escapes in code, hmm ..
01:58:01 * xzhu tries irc actions
01:58:48 <cr1t1cal> so how would i return a value without a return keyword?
01:59:24 <ski> cr1t1cal : just write the expression that computes to it, in the appropriate place ?
01:59:40 <ski> @paste
01:59:40 <lambdabot> Haskell pastebin: http://lpaste.net/
01:59:50 <ski> any particular piece of code you're wondering about ?
02:00:36 <cr1t1cal> yeah
02:01:19 <monoidal> cr1t1cal : Haskell is declarative so you say "x is y" and not "do this, then this" so you don't go "return", but the expression that computes the desired value
02:01:35 <cr1t1cal> myOdd n = do  *indent*  if mod n 2 /= 0 then *what goes here?* 
02:02:04 <monoidal> Why do you want a do block?
02:02:04 <ski> replace "*what goes here?*" with the expression that you want to compute the answer (for that branch)
02:02:16 <ski> looks like you want a boolean expresion there, perhaps just `True'
02:02:20 <cr1t1cal> so True?
02:02:28 <cr1t1cal> but that throws an error
02:02:38 <ski> also, you need an `else' with an `if', as well
02:02:55 <cr1t1cal> oh you HAVE to?
02:02:58 <ski> yes
02:03:12 <monoidal> It should be, i think: myOdd n = n `mod` 2 == 0
02:03:23 <ski> otherwise, what should the poof function `myOdd' do when the `if' condition is false ?
02:03:27 <ski> abort the program ?
02:03:33 <ski> that wouldn't be very nice
02:03:48 <ski> monoidal : one step at a time :)
02:03:50 <cr1t1cal> monoidal: that is a simpler way yes
02:03:58 <cr1t1cal> and what is wrong with a do block?
02:04:01 <ski> (also that's buggy)
02:04:18 <ski> `do' is only needed when you actually want more than one command, "sequenced"
02:04:40 <ski> here you don't need that, so it's just extra noise
02:04:46 <monoidal> Nothing, but for that kind of computations it's better to use a pure function, no need for do block a which are for monads
02:06:01 <cr1t1cal> also, can a type variable be any character?
02:06:06 <ski> as a beginner, you'll probably use `do' for Input/Output (communicating with the Operating System, and through that, to the outside world), and nothing else. some other uses will crop up later
02:06:11 <cr1t1cal> maybe even a string?
02:06:22 <ski> cr1t1cal : yes, or even multiple characters. but must start with a lower case letter
02:06:29 <cr1t1cal> ty
02:06:36 <cr1t1cal> thats something else I noticed
02:06:42 <cr1t1cal> i can't start names with uppercase letters
02:06:49 <cr1t1cal> like in maths I would use a capital X for a set
02:06:56 <ski> if you can give a *meaningful* name (or abbreviation) for a type variable, go ahead
02:07:04 <cr1t1cal> i can't do that in haskell although I really do think the lang is in line with maths
02:07:16 <cr1t1cal> :(
02:07:20 <monoidal> cr1t1cal : for short, do blocks are for monadic computations such as IO, to see if a number is odd it's enough with myOdd n = n `mod` 2 == 0
02:07:32 <ski> but when there isn't really a meaningful name, people tend to prefer stuff like `a',`b',`t',`u' rather than `object',`object2',`value',&c. which just adds verbosity
02:08:21 <ski> codrinb : you use names starting with upper case for *specific* types. for type *variables*, they have to start with lower case
02:08:22 <maerwald> ski: might only make sense if there are typeclass constraints
02:08:24 <ski> er
02:08:26 <ski> cr1t1cal ^
02:09:13 <ski> maerwald : i think something like `data Tree branch element = Leaf element | Branch (branch (Tree branch element))' is ok
02:10:11 <cr1t1cal> ah
02:12:38 <ski> cr1t1cal : .. anyway, if you have `if ... then True else False', then this is the same as just `...' (a boolean expression that'll already yield `True' or `False', no need to check it, just to answer the same back)
02:14:15 <ski> cr1t1cal : similarly, `if ... then False else True' is the same as `not (...)', `if foo then True else bar' is the same as `foo || bar', `if foo then bar else False' is the same as `foo && bar', &c.
02:15:19 <ski> cr1t1cal : when you see one of the former versions, you should typically always replace it by the simplified (easier to understand) latter form
02:15:21 * hackagebot http2-client 0.4.0.0 – A native HTTP2 client library. – https://hackage.haskell.org/package/http2-client
02:15:21 * hackagebot ghcjs-base-stub 0.1.0.4 – Allow GHCJS projects to compile under GHC and develop using intero. – https://hackage.haskell.org/package/ghcjs-base-stub
02:15:39 <ski> cr1t1cal : similarly, `... == True' is just `...' and `... == False' is `not (...)'
02:16:34 <maerwald> also remember that if then else in haskell is not as powerful as in other languages, so it's not what you think it is
02:17:09 * ski isn't sure what you think it is ..
02:22:01 <maerwald> ski: ?
02:22:14 <ski> just wondering what you had in mind
02:22:20 <ski> (if you'd like to elaborate)
02:22:35 <maerwald> e.g. in Java AST-wise: if ( Expression ) Statement [ else Statement]
02:22:41 <maerwald> then check the Expression type
02:22:46 <maerwald> it's not what it is in haskell
02:23:29 <ski> ok, i suppose you mean because we have to check the types of the branches agree and that that's the type of the whole, in Haskell ?
02:23:38 <ski> or something else ?
02:23:40 <maerwald> side effects
02:23:43 <Ferdirand> what if you make Statement an IO ()
02:23:46 <ski> yea, that too
02:24:11 <ski> (both)
02:24:26 <maerwald> so it's quite more flexible which can be confusing if you use it in haskell at first
02:26:43 <ski> hm. usually i tend to think of it as less flexible (apart from allowing missing `else'), since you can't use it in expressions (though there's `... ? ... : ...', of course)
02:27:14 <maerwald> huh?
02:27:25 * ski isn't not too sure on what flexible should mean here, though
02:27:46 <ski> i can't say `foo(if ... then ... else ...)' in Java
02:28:12 <ski> there's a distinction between expressions and commands, and that construction is only allowed in the latter
02:28:36 <ski> (hrm, s/isn't not/isn't/)
02:29:04 <maerwald> yeah, that's what ternary operators are for I guess
02:29:37 <ski> aye
02:29:39 <maerwald> maybe that would have been better for haskell syntax sugar instead of if then else
02:29:55 <ski> i don't know
02:31:03 <ski> now i'm recalling some language design principles from a book
02:32:17 <ski> one of them stating e.g. that to every parameter passing mechanism, there is a corresponding local declaration form, and vice versa
02:33:49 <ski> so, if you allow passing parameters by reference, you should also consider allowing local alias declarations
02:34:37 <ski> if you allow passing an input parameter by copying, you should also consider allowing a local variable with initialization (copying) declaration
02:35:34 <ski> also principles that allow local declaration forms, as well as conditionals, for any syntactic category in the language thay can be said to express some kind of computation
02:36:08 <ski> unfortuately, Haskell doesn't have the latter, neither for declarations, nor patterns (nor types)
02:37:13 <ski> imagine if instead of
02:37:45 <ski>   (x,f) | ...       = (...,\y -> ..y..)
02:37:58 <ski>         | otherwise = (...,\y -> ..y..)
02:38:02 <ski> you could say
02:38:06 <ski>   if ...
02:38:14 <ski>     then x = ...
02:38:20 <ski>          f y = ..y..
02:38:24 <ski>     else x = ...
02:38:25 <ski>          f y = ..y..
02:39:04 <ski> (the two branches giving different implementations for `x' and `f')
02:39:44 <ski> (this would be not an `if'-expression, but an `if'-*declaration*)
02:43:08 <maerwald> I just think it breaks with intuition, but it's not a big deal
02:43:28 <ski> breaks which intuition ?
02:44:14 <maerwald> about what if-then-else is
02:44:28 <ski> mhm
02:44:56 <maerwald> it's not really a "functional" thing, but then is pulled into the functional domain with different properties
02:45:08 * ski thinks monochrom might interject something related to intuition ..
02:45:21 <ski> (.. but then i'm not sure i'm fully convinced of that point)
02:46:49 <ski> well, if we want to go to basics, `if'-`then'-`else' is, in Haskell, explained in terms of `case'
02:47:40 <ski> so, feel free to replace the above use of `if' by an equivalent use of `case', which would the general mechanism, that i'd also like to see working on declarations (and commands) in Haskell
02:47:54 <ski> (i'm not sure whether that makes any difference in your mind)
02:52:34 <ski> (but if you're not that interested in discussing this, that's also ok. it's just something i'm annoyed by the lack of in Haskell)
02:54:42 <kuribas> somehow I find the tuple clearer
02:55:05 * ski nods
02:58:03 <kuribas> maerwald: there is also when
02:58:06 <kuribas> :t when
02:58:08 <lambdabot> Applicative f => Bool -> f () -> f ()
02:58:14 <maerwald> I am aware
02:59:59 <kuribas> when I write scheme or emacs lisp, I always make sure to use when if there is no second clause.
03:00:17 <maerwald> and it's extremely poorly named
03:01:01 <kuribas> maerwald: I guess it is taken from LISP
03:01:04 <ski> (iirc Racket doesn't like `if' with not alternate clause)
03:04:40 <ski> kuribas : although, i think in Emacs Lisp and Common Lisp, you can put definitions in the body of a `let' ?
03:04:56 <ski> (i don't mean just local definitions)
03:05:57 <kuribas> ski: I don't think that putting a defun inside a let body will make it a local definition in emacs lisp.
03:08:05 <ski> hm, seems to work
03:08:46 <ski> (both when the `if' form is on top-level, as well as when it's local inside some other `defun')
03:09:02 <maerwald> maybe I should make a library with real if/for/while etc. Did that that for loops some time back
03:10:16 <ski> (perhaps CL is more strict. though istr seeing someone on #lisp doing this, or claim it works)
03:32:50 <`Guest00000> i keep forgetting about the composition order of monad transformers, how can i make it firm in my mind?
03:47:57 <erisco> `Guest00000,  XT m a  is  m (X a)  ? I dunno
03:50:03 <erisco> just read it inside-out, which ends up being a sort of right-to-left
03:50:38 <erisco> CT (BT (AT m)) a  is m, A, B, then C
03:50:45 <erisco> m (A (B (C a)))
04:32:28 <hexagoxel> does Control.Arrow.(***) have a pronounceable name?
04:37:14 <erisco> hexagoxel, split
04:38:17 <erisco> or maybe that is &&&, let me think
04:38:46 <hexagoxel> (&&&) names "fanout" in the docs
04:41:03 <erisco> "Split the input between the two argument arrows and combine their output. Note that this is in general not a functor.
04:41:03 <erisco> "
04:41:16 <erisco> that is how I remember "split", but I am still suspect of it
04:41:39 <erisco> diagrammatically, &&& looks like "split", and "fanout" is a synonym
04:44:00 <hexagoxel> and (***) looks like.. parallel?
04:44:51 <erisco> I guess
04:49:23 <asthasr> Aren't arrows out of favor now? :)
04:57:18 <ski> hexagoxel : i suppose i might call it "cross" or "times" or "product"
05:04:19 <bwe> Golang handles each http request as its own thread afaik. Comparing Haskell's Warp to Golang: Is the `one request spawns one native thread` paradigm equivalent there?
05:08:39 <osa1> bwe: if I understand the question correctly, warp spawns a GHC thread, not an OS thread. so it's the same with Go in this regard.
05:10:58 <bwe> osa1: hm. afaik golang does handle http requests multi-threaded by default. Does warp do the same?
05:11:37 <osa1> bwe: yes
05:11:48 <osa1> bwe: each request spawns a lightweight thread
05:12:10 <bwe> Okay. Thanks for your kind clarification.
05:12:29 <asthasr> also please note that "Golang" does not handle any http requests. It's a web library that does that
05:12:39 <asthasr> Depending on which one you're looking at, they could handle requests differently
05:13:24 <osa1> AFAIK it has an HTTP server in the standard library
05:13:45 <asthasr> sure :)
05:14:24 <asthasr> but so does, for example, Python, but I would not refer to it as "Python" handling requests in the way that http.server does.
05:16:16 <bwe> osa1: Confirmed. asthasr: I meant that. I should have been more precise! — I am looking for an ecommerce system in Haskell. What's out there?
05:25:29 <asthasr> bwe: there's clckwrks, but I've never used it or anything -- http://hackage.haskell.org/package/clckwrks
05:33:12 <erisco> knupfer, I can explain to you the method I am using for typed HTML but I personally do not have the impetus to complete a library
05:37:58 <erisco> or what I can do is implement a small subset, which is probably a better way to convey the ideas
05:38:16 <m1dnight_> Hey guys, I have changed my resolved in my project to nightly, but now my IDE is complaining that y ghcmod version no longer matches.
05:38:24 <m1dnight_> should I install ghc-mod for each project seperately?
05:38:45 <bwe> asthasr: It provides the login and profile mechanism for users. What I miss is a library to tinker with products like http://docs.satchless.com/en/latest/index.html
05:39:16 <emme[m]> Any good resources for starting with Spock?
05:44:21 <zoid1> I am also currently learning Spock and Spock's tutorials: https://www.spock.li/tutorials/ and the documentation as well as the documentation on hackage https://hackage.haskell.org/package/Spock are a great resources. For an overview of how everything fits together this example project is also good: https://github.com/agrafix/funblog
05:58:04 <erisco> what do I do when the package I need is broken, using Mercurial, and on Bitbucket
06:01:46 <maerwald> erisco: what do you mean?
06:10:22 <cloudhead> hey is there a function I can use like 'race', but for STM? Something with type STM a -> STM b -> STM (Either a b)?
06:11:31 <cloudhead> I guess perhaps that doesn't make sense, since STM executes atomically?
06:11:55 <cloudhead> although there is an `orElse`
06:21:50 <lyxia> it's possible    \x y->Left<$>x<|>Right<$>y
06:22:47 <lyxia> <|> is orElse in fact
06:31:44 <cloudhead> lyxia: ah yes very simple indeed, thanks
07:42:35 <emme[m]> zoid1: Thank you!
07:52:40 <knupfer> Just implemented a type level fingertree, but the typechecker clearly doesn't like it.
07:56:30 <erisco> monochrom, remember when we came up with good suffixes for constructor and type names (when they would otherwise clash)?
08:01:24 <cranej>  /quit
08:03:45 <wz1000> knupfer: I suspect insertion could be exponential, if you have any branching involved
08:04:22 <wz1000> because the type level language is strict, so If 'True a b would evaluate both a and b
08:06:45 <knupfer> Yeah, if I remember, but you can emulate lazyness. For every usage of If, you can define a specialized type family which takes only a bool and returns accordingly.
08:07:16 <knupfer> It evaluates only the types on the RHS of a definition if it matches the LHS
08:07:27 <knupfer> But it's at least a *very* ugly solution
08:16:27 * hackagebot microgroove 0.1.0.0 – Array-backed extensible records – https://hackage.haskell.org/package/microgroove
08:16:27 * hackagebot data-constructors 0.1.0.0 – Generically compare data by their constructors – https://hackage.haskell.org/package/data-constructors
08:38:20 <ltielen> is there a helper function to get the base part of the URL for a servant server in a generic way? 
08:51:06 <the_2nd> does anyone know how to have template values within a markdown file for hakyll?
08:51:18 <the_2nd> most examples have a "one item per file"
08:51:27 <the_2nd> but I want "multiple items per file"
09:00:22 <monochrom> erisco: Yeah.
09:01:07 <erisco> monochrom, do you remember what they were?
09:02:28 <monochrom> newtype Yum = YumOf{deYum :: Int}.  I am not sure about the "deYum" part.
09:03:29 <erisco> yeah that is the one I forget too… I thought we had a suffix for both
09:03:52 <erisco> I have possibly rediscovered it but I don't want to contaminate your recollection
09:03:59 <monochrom> But I like punning French "de" with English "of".
09:05:12 <erisco> oh, I misread, I thought we did something for both types and constructors
09:05:22 <erisco> maybe projectors were involved too
09:14:58 <dpacbach[m]> howdy
09:40:14 <Darwin226> Can someone explain to me why this is illegal? http://lpaste.net/6335466087500480512
09:40:35 <Darwin226> Says "Illegal constraint in a type: Num x0"
09:44:50 <monochrom> Which line? There are two.
09:52:27 <lyxia> Haskell doesn't allow constraints at the kind level, perhaps.
09:55:17 <orion> If types are objects in Hask, what are kinds?
10:04:19 <Drinfeld> cabal install hsdev on Windows 10 with Haskell Platform 8.2.1 gives the following errors: https://pastebin.com/iUP9Pway Can someone help me?
10:07:46 <Drinfeld> it already fails here: https://pastebin.com/iUP9Pway
10:08:22 <Drinfeld> sorry, here: https://pastebin.com/43UFKbr0
10:08:44 <Drinfeld> do I need cygwin?
10:12:12 <[exa]> Drinfeld: cygwin probably not, do you have a working shell?
10:12:23 <glguy> haskell platform should have come with the network package installed
10:12:25 <Drinfeld> powershell or cmd?
10:12:32 <[exa]> Drinfeld: shell like sh
10:12:42 <[exa]> powershell nor cmd aren't sh-compatible
10:13:03 <Drinfeld> where can I get sh?
10:13:07 <[exa]> (try typing sh in cmd)
10:13:41 <Drinfeld> [exa]: this gives command not found
10:15:19 <[exa]> Drinfeld: I'd go for installing MSYS as the cabal warning advices
10:15:31 <[exa]> but I'm not an expert on this :]
10:15:40 <[exa]> maybe someone other here can comment
10:15:59 <Drinfeld> it gives almost the same errors with cygwin. I will try MSYS
10:16:59 * hackagebot graphite 0.0.2.0 – Graphs and networks library – https://hackage.haskell.org/package/graphite
10:17:18 <[exa]> Drinfeld: it also kindof looks like the shell warning might be unrelated to the actual problem
10:17:59 <Drinfeld> [exa]: What do you think is the actual problem?
10:18:08 <[exa]> Build log ( C:\Users\Keller\AppData\Roaming\cabal\logs\ghc-8.2.1\network-2.6.3.2-N4O3tHnIF53aUjogAgmsr.log ):
10:18:22 <[exa]> oh so, that's the actual build log
10:18:58 <[exa]> maybe if you already have Cygwin, you could just add the cygwin's sh executable to PATH
10:19:19 <[exa]> no idea about cygwin internals though; just try to find sh.exe somewhere ;]
10:24:20 <Drinfeld> I am trying to install MSYS, but it takes a long time.
10:40:14 <Drinfeld> now I have installed MSYS, but executing cabal install hsdev from sh still gives the same error :(
10:57:55 <vimalloc> I just discovered MonadClasses (MonadReader for example) compared to monad stacks with transformers (ReaderT for example). I'm migrating my stuff to the former, and am trying to understand the point of this `MonadBaseControl IO m`.
10:59:07 <geekosaur> MonadBaseControl is about exception handling
10:59:10 <vimalloc> I'm using Data.Pool, which has the `MonadBaseControl IO m` for the `withResource` function, so I include that in my function and everything works. But I'm trying to figure out why that is different then MonadIO and why it is needed compared to MonadIO
10:59:49 <geekosaur> basically, it's really difficult to correctly thread an exception through multiple monads which control external resources, without leaking the resource
11:00:22 <geekosaur> for example an exception thrown at the wrong time could cause a connection to a database to be lost; the process is still holding it but it can't be accessed from Haskell any more
11:00:56 <geekosaur> MonadBaseControl provides fine grained exception control and routing, so you can always clean up after an exception without losing track of any resources.
11:01:51 <vimalloc> Ah, makes sense why it would be in the Data.Pool then. Thanks for the info.
11:01:58 <vimalloc> used in*
11:03:22 <zachk> would handling the resources using cloud haskell processes be cleaner then regular threads, as far as exceptions are concerned?
11:16:59 * hackagebot haskell-names 0.9.0 – Name resolution library for Haskell – https://hackage.haskell.org/package/haskell-names
11:17:07 <cloudhead> is there an Async package which works with MonadIO?
11:19:30 <cloudhead> hmm I guess MonadConc is the equivalent, is this used in the wild?
11:20:38 <barrucadu> cloudhead: I know of very few users
11:20:42 <barrucadu> So, not really :(
11:21:22 <hous> how do I edit the cabal file for a stack package
11:21:26 <hous> I can't find it anywhere
11:21:47 <barrucadu> hous: Is there a package.yaml?  The package might be using hpack (which stack supports)
11:21:48 <cloudhead> barrucadu: do people just not mind using IO directly? or is the async package not used that much?
11:22:03 <glguy> cloudhead: Using IO directly is the most common
11:22:05 <barrucadu> cloudhead: The async package is pretty widely used, but people just use IO.
11:22:14 <cloudhead> I see
11:22:21 <glguy> and using IO directly isn't in conflict with using the async package
11:22:24 <glguy> that's also quite common
11:22:50 <cloudhead> yeah it seems difficult to do otherwise
11:23:19 <hous> barrucadu: it's definitely a cabal file. I guess I just don't know where it's downloading the package, and then where it unzips it, and then where it's building it, and then after it fails build is stack deleting that folder?
11:23:46 <barrucadu> Yes, stack cleans up after it builds things
11:24:17 <hous> can I tell it to just download and unzip the package and then not build it so I can do that manually?
11:24:28 <barrucadu> If you want to modify the package, you'll probably have to fork it (or download a local copy), make your changes, and point to your copy in your stack.yaml.  I'm not sure if there's a way to just tell stack to use a different cabal file manually.
11:25:49 <hous> what's the easiest way to do that, and after I install it, will stack recognize the package as installed so it can use it as a dependency?
11:26:29 <zzq> cloudhead: The lifted-async package is like the async package with the functions lifted to MonadBase/MonadBaseControl instead of IO.
11:27:04 <barrucadu> Here's an example: https://github.com/barrucadu/dejafu/blob/master/stack.yaml  I needed to use a different version of test-framework, so I did that in my stack.yaml.
11:27:04 <cloudhead> zzq: ah thanks, will have a look
11:28:23 <hous> ok I'll fork it
11:28:24 <hous> thanks
11:30:18 <Ojd> hello  i am wondering if there is any way to library to solve equations in haskell... for example P=P*y1 + P*y2. If I have y1 I can find y2 easily (and vicerversa) by re-arranging elemnts
11:30:35 <Ojd> but more complex equations are difficult to solve like that
11:30:49 <EvanR> is that a recursive definition
11:31:22 <zachk> ojd, if it's a linear equation you can use a linear algebra package to solve the system of linear equations
11:31:28 <EvanR> > fix (\p -> p * 3 + p * 4)
11:31:34 <lambdabot>  mueval-core: Time limit exceeded
11:31:36 <EvanR> oh well
11:31:38 <cloudhead> barrucadu: didn't realize you wrote dejafu - I think I'll give it a try since I'm having a hard time with concurrency testing
11:31:49 <barrucadu> Cool, let me know if you have any problems
11:31:56 <cloudhead> cheers :)
11:32:39 <Darwin226> monochrom: Sorry, I had to go. The line that errors is the last one (http://lpaste.net/6335466087500480512)
11:32:48 <Darwin226> More precisely, the second parameter
11:33:51 <Ojd> EvanR, you would likely have y1 and P, or y2 and P... so it would be more like \y1 P -> P = y1 *P + y2*P and I would like to find y2
11:34:30 <Ojd> zachk, I would look for the linear algebra package as recommended
11:35:53 <zachk> you can solve single variable equations of degrees greater then 1 using the quadratic or like ilk up to the 4th degree, sadly, it is proven no general formula for solving 5th degree or higher equations exists
11:35:56 <geekosaur> Darwin226, 'class C k (a :: k)' tells ghc that k is a kind. You cannot simultaneously use it as a type, which you are trying to do there
11:36:17 <Darwin226> geekosaur: Oh but you can with TypeInType
11:36:39 <Darwin226> the class definition works fine
11:36:45 <Darwin226> the instance errors out
11:36:55 <geekosaur> not exactly. you have T identifying both a kind and a type. but technically you are using 'T there not T
11:36:57 <Darwin226> and even the instance works if I remove the Num constraint from the constructor
11:37:27 <Darwin226> Sure, and ('T :: T x)
11:38:11 <monochrom> "no general formula for 5th degree" is an urban legend.
11:38:56 <monochrom> The precise sentence is "no general formula if you only allow + * - / nth-root"
11:39:30 <c_wraith> that is, algebraic numbers
11:39:50 <c_wraith> err, not quite.
11:39:56 <monochrom> But there are formulas like http://mathworld.wolfram.com/QuinticEquation.html
11:40:06 <epta> in cabal file one can wrap test-related library dependency (like quickcheck) with a flag. Instead of a custom flag, can '--enable-tests' flag be used somehow?
11:40:07 <c_wraith> It means there are algebraic numbers without a representation with just radicals
11:44:21 <monoidal> Well well well, what's going on in the Haskell community?
11:45:03 <ongy> everything!
11:45:21 <monoidal> That's what makes us Haskellers I suppose
11:45:47 <monoidal> Always everything is going on
11:46:11 <monochrom> Nothing.
11:47:25 <monoidal> I have a little question, how's Haskell 2020 going? I haven't heard much about it recently. It's still under development? 
11:50:00 <monoidal> do you know something about its current state?
11:55:09 <monoidal> anyone out there?
11:56:46 <AndreasK> As far as I know it's still worked on. But I don't really know much more about it
11:57:21 <Ojd> yup
11:57:36 <Ojd> question, what would be a good package for plotting?
11:58:42 <monoidal> Look at its Hackage section, and find out which is more appropiate to you from there
11:59:54 <nshepperd> you can write a general formula for anything, by just defining a new function as "the solution to X"
12:00:37 <nshepperd> so any talk of there being "no general formula" for something needs to circumscribe what formula would 'count'
12:04:06 <cloudhead> barrucadu: any reason your MonadSTM can't be an Alternative? I see you have a note there.
12:04:14 <monochrom> I grew out of "formulas" a long time ago. The issue that matters is never "formulas", but rather algorithms and computability.
12:04:46 <nshepperd> having an effective procedure to approximate the value would be a minimal requirement
12:04:47 <monochrom> Not to mention that a lot of nice-looking formulas are computationally dumb.
12:05:35 <monochrom> There is even a sum-and-cosine formula for spitting out the prime numbers (all prime numbers and only prime numbers).
12:05:45 <AndreasK> Quiz question, given {f 1 True = 1; f 2 False = 2; f 1 False = 3} . How can (f x True == f x False) give true
12:05:50 <monochrom> It is also grossly impractical.
12:07:18 <erisco> AndreasK, do you have some work to show?
12:08:07 <AndreasK> erisco: As in hints? I already have a solution if that is what you meant
12:08:24 <erisco> so you are quizzing us? okay
12:09:10 <monochrom> I don't understand the question. Is it "for all x" or is it "for some x" or is it "find x such that" or what?
12:09:32 <nshepperd> is it a trick question. f undefined True = f undefined False = undefined
12:09:33 <monoidal> AndreasK : that sounds like doesn't have any solution, the pattern matching wouldn't behave un any way that returns True afaik
12:10:01 <monoidal> Oh, undefined
12:10:08 <AndreasK> nshepperd: It actually gives the result true in ghci, undefined would give an exception
12:10:19 <erisco> do you mean True?
12:10:23 <AndreasK> yes
12:10:37 <monoidal> AndreasK : doesn't make sense to me
12:10:56 <nshepperd> then the output :: Z2 instead of Integer
12:11:25 <nshepperd> such that 1 == 3
12:11:26 <monoidal> For any x, either the pattern matching fails or It returns False
12:11:34 <AndreasK> Thats the beaty of it. It didn't make sense for me at first either. Has to do with how literals are desugared
12:11:50 <erisco> well I thought about making a num instance
12:11:55 <erisco> but I am not sure if there is one available
12:12:01 <monoidal> First, have you bound that x to a value?
12:12:17 <AndreasK> Yes x is just a regular value
12:12:46 <monoidal> It's either 1 2 or 3 otherwise the pattern matching fails
12:13:22 <AndreasK> monoidal: But what does it mean if the expression is "1"
12:13:58 <erisco> we can just pick any Num instance such that 1 == 3
12:14:22 <erisco> but I don't know what sensible Num instance has this… and partly because I don't know what is expected of good Num instances
12:14:43 <monochrom> I think "valuation ring" is good enough.
12:14:49 <AndreasK> Not sure about sensible. But the only law I know for Num is the abs one
12:15:03 <erisco> my first though is whether () works
12:15:04 <monochrom> Mostly you just need "ring" but the abs adds the "valuation" part.
12:15:19 <monochrom> () should be pretty OK.
12:15:25 <monoidal> erisco: overriding the Integer instance if that's possible?
12:15:41 <monochrom> () is the {0} ring.
12:15:52 <erisco> if that is the case, then why is () not already an instance of Num, but okay, I'll trust your summary judgement monochrom
12:16:49 <monochrom> Although there is 50% chance a mathematician disagree because they insist 0/=1 for rings.
12:17:02 <erisco> heh
12:17:15 <erisco> though we're going to run into a type defaulting problem for  f x True == f x False
12:17:16 <monochrom> But bear in mind there is also 50% chance a mathematician insists "ring means commutative ring".
12:17:34 <erisco> f was defined without a type declaration, so we get the general inferred type, whereby the output type is independent of the input type
12:17:46 <monoidal> Don't understand how It could actually work with (), shouldn't that be a type error or something?
12:18:04 <erisco> now we get default Integer for the equality test, and (1 :: Integer) == (3 :: Integer) is False
12:18:07 <barrucadu> cloudhead: It can be an Alternative, but isn't required to be.  Having said that, I don't think the testing implementation I have is an Alternative or MonadPlus, and that definitely should be.
12:18:27 <erisco> monoidal, (1 :: ()) == (3 :: ()) is True
12:18:32 <barrucadu> Maybe I should put a MonadPlus constraint on MonadSTM anyway
12:19:06 <monoidal> erisco: isn't () the only possible value of type ()?
12:19:09 <monochrom> monoidal: Prelude doesn't make () a Num instance but you can.
12:19:23 <erisco> monoidal, precisely (and technically no)
12:19:23 <cloudhead> barrucadu: ok I see, just find it convenient to use <|> etc.
12:19:26 <monochrom> And yes () + () = (), () * () = (), etc
12:20:04 <AndreasK> I forgot one type signature in the initial claim. But http://lpaste.net/3646718291352748032 is one way
12:20:13 <monoidal> So that quiz question has no answer?
12:20:35 <monoidal> For me at least, i might have missed something
12:20:48 <erisco> AndreasK, it looks to me that FNum is iso to ()
12:20:50 <MarcelineVQ> data FNum = F = ()
12:20:53 <AndreasK> monoidal: FNum might not be a valid ring, but its a valid Num instance according to all laws I know for Num
12:21:54 * hackagebot graphite 0.2.0.0 – Graphs and networks library – https://hackage.haskell.org/package/graphite
12:21:54 * hackagebot errors 2.2.2 – Simplified error-handling – https://hackage.haskell.org/package/errors
12:22:10 <AndreasK> But yes sorry for the missing last type sig. Even weireder is if you give f the type FNum -> Bool -> Num
12:22:37 <monoidal> Yeah, but the type inference for the number would be Integer afaik, not Num a => a ?
12:22:56 <AndreasK> Depends on the Monomorphic restriction
12:23:05 <AndreasK> I used ghc so it's off by default
12:23:11 <monoidal> Okay
12:23:11 <AndreasK> ghci
12:23:40 <monoidal> So you have to modify its type signature?
12:23:53 <monoidal> To make the expression return True
12:24:10 <AndreasK> For the initial one yes sadly. That was a mistake of mine
12:24:47 <erisco> I don't have any new quizzes lately… so I'll have to repeat my quiz of finding a correct type for \x -> x x
12:25:15 <monoidal> erisco: It would be infinitely recursive
12:25:27 <monoidal> I thought about it recently
12:25:29 <AndreasK> But my own takeaway from that was that one can't trust numbers unless they are typed to something concrete
12:25:38 <erisco> monoidal, there is an answer, and it is not an infinitely recursive type
12:26:04 <monoidal> Well, that goes beyond my knowledge then
12:27:04 <pierrot> Good afternoon. If I have a function g such that g x xs = xs ++ [x], then the evaluation of (foldr g []) [1..n] goes like this: http://sprunge.us/MYKF ? Is it correct?
12:27:17 <monochrom> Actually I wonder if you can really write that as "\x -> x x" in Haskell. I mean "f x = x x" plus type sig would be accepted but lambda has an extra restriction that function binding doesn't have.
12:28:01 <erisco> does it? I don't know what it is actually, but yes  \x -> x x  can work
12:28:18 <monoidal> I tried it once and gave me an error "couldn't resolve type signature" or something like that
12:28:32 <AndreasK> Someone ping me when someone posts an answer. I'm interest but need to get back to other things. 
12:29:44 <monoidal> I thought It would be recursive because It takes a function which operates in functions which operate in functions, etc
12:32:11 <monochrom> Oh, I guess lambda's restriction is lifted under that context. I see an example in the GHC users guide.
12:32:40 <monoidal> Ghci tells me it's a infinite type
12:33:01 <erisco> it wouldn't be a quiz if you could just put  :t \x -> x x  into GHCi, now would it? :)
12:33:28 <monochrom> There is also a reason I said "under that context". So, what context?
12:33:33 <c_wraith> Am I allowed to use extensions?
12:33:40 <monochrom> Or perhaps computer environment
12:33:41 <c_wraith> Because I can do it with extensions.
12:33:43 <Ferdirand> i'd like to see the solution as well
12:33:43 <erisco> c_wraith, yes
12:33:44 <monochrom> Yes.
12:33:57 <monochrom> Indeed my "context" means turning on an extension.
12:34:01 <monoidal> I didn't type that, i just went: f x = x x; and then used f which gave that error
12:34:44 <c_wraith> So yeah.  With the correct extension enabled and a type signature provided, I can make "f = \x -> x x " work
12:34:56 <monoidal> A forall maybe
12:36:21 <Ferdirand> when you write f = \x -> x x, both x must refer to the same monomorphic value, yes ?
12:36:38 <monoidal> Yes
12:36:44 <c_wraith> Ferdirand: that depends on the extensions...
12:36:54 <erisco> it is actually a good demonstration of the difference between  let x = y in m  and  (\x -> m) y
12:37:29 <monochrom> erisco: So the extra restriction I'm referring to is when standard Haskell (or ML for that matter) "let f x = x in (f 5, f 'x')" cannot be rewritten as "(\f -> (f 5, f 'x')) id"
12:37:57 <erisco> monochrom, right :)
12:38:50 <erisco> you can choose other things too, like const
12:39:02 <monochrom> So lambda monomorphizes your bound variable. Or maybe let is giving you a bonus feature of polymorphizing your bound variable.
12:40:05 <pierrot> I first thought that (foldr g []) [1..n] would go like this http://sprunge.us/eEba, but that is wrong, right? I mean.. in each step, the outer function g should be applied first like in this reduction http://sprunge.us/MYKF... Is that correct?
12:40:05 <monoidal> Why does lambda give such restriction, and what exactly is It?
12:40:08 <erisco> SPJ mentioned briefly in a talk on Core that he kept let/in (rather than rewriting to a lambda) but it wasn't clear whether this was the reason
12:40:51 <c_wraith> monochrom: are you talking about the explicit let-generalization step in HM?
12:40:59 <monochrom> YES!
12:43:07 <c_wraith> pierrot: it's most accurate to say foldr g [] [1..n] = g 1 (foldr g [] [2..n]) where you can't say anything further without knowing what g is
12:43:41 <monochrom> monoidal, I was hinting that it depends on your point of view, you could call it "lambda is being restrictive" or you could call it "no, let is being generous".
12:43:44 <pierrot> In my first message:
12:43:45 <pierrot> pierrot: ―Good afternoon. If I have a function g such that g x xs = xs ++ [x], then the evaluation of (foldr g []) [1..n] goes like this: http://sprunge.us/MYKF ? Is it correct?
12:43:50 <pierrot> I gave a definition for g
12:43:55 <c_wraith> pierrot: ah, missed that one.
12:44:39 <monochrom> If you look into Hindley-Milner type inference, or the very definition of "rank-1 types", when you try to infer the type of "\x -> whatever" you are pretty much forced to monomorphize x.
12:45:17 <c_wraith> pierrot: foldr's strictness is entirely dependent on how the function argument treats *its* second argument.  You've picked a case that's incredibly complicated. :)
12:46:01 <monochrom> And you could hold the opinion that "let x = ... in whatever" should get the same treatment. Except then in practice it will be a let-down because people like to write "let f x = x in (f 5, f 'x')" all the time.
12:46:29 <c_wraith> pierrot: with that definition, the first thing g does is pattern-match on xs.
12:47:13 <c_wraith> pierrot: that forces evaluation of the next level of foldr, which means another evaluation of g, which means another pattern-match on xs, recursively all through the list.
12:47:22 <monochrom> So H & M decided to relax let to make everyone happy, and it didn't really cost the theory anything.
12:47:34 <erisco> how generous of them!
12:47:55 <bbear> are you using array in Haskell ?
12:48:04 <bbear> (I mean are you using them a lot ?)
12:48:26 <monochrom> Yes. I use Data.Vector a lot of times.
12:48:37 <c_wraith> pierrot: But there's more to it than that.  Once it's evaluated the entire input, it calculates enough to determine that the result of g has a form (_:_), at which point it constructs the two thunks, passes them as arguments to (:), and returns.
12:49:15 <c_wraith> pierrot: it's really a pain to trace the exact evaluation process through all the suspensions caused by laziness and (:) constructors.
12:49:27 <c_wraith> pierrot: also, it will depend on how the result is consumed.
12:49:33 <monoidal> monochrom, but in your example f is just id, what "permissive" part of the typesystem does that show?
12:49:48 <monoidal> As in let
12:50:34 <pierrot> c_wraith: I ask this question because I have to explain the graphic of a heap profile of a program that prints the list generated by that foldr
12:51:09 <c_wraith> pierrot: that's a rather different question, though.  It cares mostly about sharing of the results, not the process of lazy evaluation
12:51:17 <monochrom> I don't understand the question. But how about "let {n [] = True; n _ = False} in n [1,2,3] && n ['1','2','3']"
12:52:06 <c_wraith> pierrot: you can pretend it's entirely strict and still get the same sharing graph
12:52:38 <maerwald> https://mars-lang.appspot.com nice, wonder if that will ever takt off. They have IO type too
12:52:43 <monoidal> Okay, so n is polymorphic, and that doesn't happen in lambdas?
12:52:48 <bbear> I am wondering something. Lets say you are using Data.Map.Lazy and you are filtering against the keys in a certain integer range.
12:52:55 <monochrom> erisco: In your "SPJ kept let/in", were you referring to Core?
12:53:03 <bbear> Do you still need to compute all the keys ?
12:53:08 <erisco> monochrom, yes
12:53:42 <c_wraith> maerwald: is that an IO type, or just a flag on definitions?  The difference matters.  Being a real type in haskell means things like IO (IO Foo) make sense.
12:54:12 <maerwald> I have no idea, but it's a pure language
12:54:42 <c_wraith> pierrot: arg.  Sorry, I misread that as "heap graph", not heap profile.  Nevermind, laziness does matter, and I clearly should have had more sleep.
12:55:03 <monochrom> OK so I think the main concern is this. You are about to generate asm code. And you want to distinguish "this is a function" from "this is a thunk". So use lambda for function, use let for thunk.
12:55:08 <eitanChatav> does anyone here use hledger?
12:55:16 <pierrot> c_wraith: this is the program http://sprunge.us/SJMa
12:55:27 <JuanDaugherty> eitanChatav, i do but you want #ledger
12:55:35 <maerwald> eitanChatav: sm certainly does :>
12:55:40 <pierrot> and this is the graph I've generated https://i.imgur.com/WNDOWhU.png
12:56:05 <monoidal> Okay monochrom, i was a little bit Lost..
12:56:06 <pierrot> I have to explain in words that behaviour...
12:56:18 <c_wraith> pierrot: as I always forget these things, which profile is -hc ?
12:56:21 <erisco> "my bank account"
12:56:26 <eitanChatav> @JuanDaugherty, ledger as opposed to hledger or #hledger as opposed to #haskell
12:56:26 <lambdabot> Unknown command, try @list
12:56:34 <maerwald> and sm is a friendly guy, so I don't mind pinging him :P
12:56:55 <MarcelineVQ> sm?
12:57:02 <eitanChatav> simon michael presumably
12:57:06 <maerwald> yeah, it's simon
12:57:23 <eitanChatav> I just have stupid beginner questions
12:57:31 <MarcelineVQ> so many simons.
12:57:37 <JuanDaugherty> eitanChatav, it's a common ecosys and more people hang in #ledger
12:57:39 <pierrot> c_wraith cost center
12:57:59 <maerwald> MarcelineVQ: not the cat
12:58:19 <eitanChatav> JuanDaugherty, thanks I guess I'll try there but I'll post my first q here too in case someone can just bat it out
12:58:32 <eitanChatav> I'm just trying to get started with hledger; As step 0 I downloaded the CSV from a single checking account and wrote a rules file; Now I'm a little confused how to use hledger to run using the rules file on the CSV.
12:58:36 <MarcelineVQ> maerwald: they come in pairs you know
12:58:55 <eitanChatav> they're all closed under the simonoid operation
12:59:35 <maerwald> MarcelineVQ: cats or simons?
13:00:28 <c_wraith> pierrot: have you done any analysis to see what curve those are?  I'd guess they're both roughly sqrt(total runtime - current time) curves.
13:01:54 <c_wraith> pierrot: as in, the current runtime memory use is proportional to the square of the number of elements left to output.
13:02:44 <monochrom> bbear: Yes it still computes all the keys.
13:03:23 <monochrom> Or rather, compute each key enough to determine where it should sit in a binary search tree.
13:04:38 <pierrot> c_wraith: Yeah, I see.
13:05:19 <pierrot> But why the curve is jagged?
13:05:47 <c_wraith> pierrot: that's normal. the GC doesn't run constantly, only when the nursery generations are filled
13:06:12 <lpsmith> Hmm, did travis remove support for GHC <= 7.8
13:06:15 <lpsmith> ?
13:06:19 <c_wraith> pierrot: so any memory profile is going to have a little spikiness.  It can be ignored.
13:07:09 <pierrot> Hmm.. I'm not sure. I thought that the peaks were there for a reason...
13:08:19 <pierrot> For example, I also have to explain the graph for this program http://sprunge.us/bUbd. It's this: https://i.imgur.com/hcUh6QK.png
13:08:38 <pierrot> It also reverses the list but using a foldl
13:09:29 <pierrot> the graph is quite simpler
13:09:33 <pierrot> and isn't jagged
13:09:41 <c_wraith> pierrot: yes, it allocates a lot less.  the GC doesn't constantly run. :)
13:10:06 <hexagoxel> pierrot: it ran for a total of 0.0 seconds. have you compared the number of data points for both graphs?
13:10:17 <c_wraith> pierrot: also, consider that heap profiling is done by sampling.  the number of...  hexagoxel beat me to it. :)
13:10:45 <pierrot> yeah, the number of points isn't the same
13:11:27 <c_wraith> it looks like you have maybe 30 samples in the foldl' version.  there's no way it can be that spiky with so few samples
13:14:33 <hexagoxel> what happens when you decrease GC amount on purpose (passing +RTS -H..)? if c_wraith is correct, this should make things smoother, right?
13:15:34 <pierrot> hexagoxel: hehe. yeah. I did that with -i2 (sample each two seconds) and the graph is smoother..
13:17:09 <hexagoxel> that's different though. i don't completely trust that GC affects heap profiles yet.
13:18:09 * hackagebot concurrency 1.2.0.0, data-fix 0.2.0, dejafu 0.7.2.0, graphite 0.2.1.0
13:18:10 * hackagebot  → https://hackage.haskell.org/packages/recent
13:18:22 <pierrot> back to my original question... the evaluation of (foldr g []) [1..n] goes like this http://sprunge.us/eEba or like this http://sprunge.us/MYKF ?
13:21:22 <pierrot> c_wraith: ―pierrot: with that definition, the first thing g does is pattern-match on xs.
13:21:35 <pierrot> why it does pattern matching in xs?
13:21:50 <c_wraith> @src (++)
13:21:50 <lambdabot> []     ++ ys = ys
13:21:50 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
13:21:50 <lambdabot> -- OR
13:21:50 <lambdabot> xs ++ ys = foldr (:) ys xs
13:22:27 <c_wraith> pierrot: that's just what (++) does.  and it's the top-level expression in the function
13:23:59 <pierrot> c_wraith: hmm I see. so the foldr should be reduced first
13:25:04 <pierrot> Then this is more accurate: http://sprunge.us/eEba
13:25:28 <c_wraith> pierrot: with that g, yes
13:26:04 <pierrot> and with the lambda function of the code I shared before?
13:26:35 <pierrot> instead of g, (\x r -> r++[x])
13:26:42 <pierrot> it should be the same because of ++
13:27:22 <c_wraith> it's the same function
13:27:29 <c_wraith> writing it differently doesn't change anything. :)
13:27:55 <pierrot> it makes sense :)
13:28:23 <`Guest00000> is there a library which interprets (Num a => [a])'s as numbers? in this way: toInteger = sum
13:28:56 <c_wraith> `Guest00000: that seems unlikely.  what would [1,2,3] * [4,5] be?
13:29:29 <`Guest00000> c_wraith: concat ((`replicate` [1,2,3]) <$> [4,5])
13:30:26 <c_wraith> `Guest00000: hm.  I guess that makes some sense if (+) is just (++), then
13:30:31 <`Guest00000> yeah
13:30:37 <`Guest00000> the idea is
13:30:42 <`Guest00000> partial list is partial number
13:31:02 <jle`> is there any advantage of over just usming the sum of the list the entire time?
13:31:06 <jle`> *using
13:31:07 <c_wraith> `Guest00000: I haven't seen that anywhere, though
13:31:17 <`Guest00000> a number which you know for sure is greater or equal than N
13:31:37 <jle`> N ?
13:31:50 <`Guest00000> where N is the sum of the already known part
13:32:03 <jle`> sounds like the same thing as if you just used numbers
13:32:23 <jle`> and also your guaruntee isn't true if any of the lists contain negative numbers
13:32:49 <jle`> like, if n and m are both positive, then 'n + m' is a number that is greater than or equal to n
13:32:51 <`Guest00000> so that if there is a big computation which returns a long such list and you need to compare it to another number, you can abort the computation after you're sure
13:33:12 <`Guest00000> jle`: i don't use negative numbers in the list.
13:33:23 <jle`> oh so the advantage is basically faster > and <
13:33:29 <jle`> potentially lazy >/<
13:33:33 <`Guest00000> usual integers are strict
13:33:37 <`Guest00000> this is more lazy
13:34:25 <jle`> yeah, this only works if all of the items are positive, but Num a => [a] makes no guaruntees
13:34:39 <Newdell> how can i get list of packages with more filter?
13:34:39 <jle`> so such a Numeric type would be useless even for this
13:35:07 <jle`> if you're only using Integer, and not *all* Num's, you can use [Natural]
13:36:05 <koala_man> how would you check whether one simple wildcard pattern (e.g. *.txt) is a superset of another (e.g. f??.txt)? I don't intend to support any fancy regex grouping or alternation
13:36:30 <jle`> is ? a special character there or do you mean the literal '?' character
13:36:41 <ski> @check \m n -> (min m n >= (0 :: Integer)) ==> (m + n >= max m n)
13:36:43 <lambdabot>  +++ OK, passed 100 tests.
13:36:46 <koala_man> any one character, as per DOS rules
13:36:48 <c_wraith> jle`: I'm assuming glob rules
13:36:50 <geekosaur> also do you mean shell globbing or regex or ?
13:37:04 <geekosaur> (and, er, which variant of regex, if so?)
13:37:17 <c_wraith> a leading * really says 'glob' to me
13:37:32 <`Guest00000> jle`: Natural is exotic, GHC-specific
13:37:49 <jle`> are you planning on compiling with things other than GHC ...?
13:38:20 <koala_man> just *, ? and literals. no glob ranges or regex features
13:38:38 <`Guest00000> i may
13:38:51 <koala_man> I mean, full regex would be pretty sweet, but significantly harder
13:39:25 <jle`> if you use a compiler other than GHC then you can just write a Natural there, too
13:39:40 <jle`> it doesn't exactly use compiler hacks...it's just a normal Haskell type
13:40:30 <jle`> but unless you are doing something extremely specialized, it's pretty safe to assume GHC
13:40:55 <jle`> like planning for non-GHC usage only makes sense in very esoteric cases
13:41:11 <c_wraith> or if you're doing something for Utrecht
13:41:25 <koala_man> if one pattern matches another as a string, though with * only matching at least another *, then it should be a superset, right? 
13:42:32 <erisco> @check \n -> let collatz :: Integer -> (); collatz 1 = (); collatz n | (n `mod` 2) == 0 = collatz (n `div` 2) | otherwise = collatz (3*n + 1) in collatz n
13:42:35 <lambdabot>  error:
13:42:35 <lambdabot>  • No instance for (STestable ()) arising from a use of ‘myquickcheck’ • In t...
13:42:46 <c_wraith> I could swear that when I did automata theory, I proved there was an efficient algorithm to determine if one regular language was a subset of another.  But I can't remember it now at all.
13:42:55 <erisco> oh, needs to be True or False I suppose
13:42:59 <erisco> @check \n -> let collatz :: Integer -> (); collatz 1 = (); collatz n | (n `mod` 2) == 0 = collatz (n `div` 2) | otherwise = collatz (3*n + 1) in collatz n == ()
13:43:05 <lambdabot>  mueval-core: Time limit exceeded
13:43:17 <erisco> must have tried 0 or a negative :)
13:44:30 <erisco> @check \n -> let collatz :: Natural -> (); collatz 0 = (); collatz 1 = (); collatz n | (n `mod` 2) == 0 = collatz (n `div` 2) | otherwise = collatz (3*n + 1) in collatz n == ()
13:44:33 <lambdabot>  error:
13:44:34 <lambdabot>  • No instance for (Arbitrary Natural) arising from a use of ‘myquickcheck’ T...
13:45:01 <erisco> gee this quickcheck program… well, the idea was, maybe if we add that to a test suite somewhere it will get run enough that it finds a counter example
13:45:53 <Tuplanolla> Is the inclusion problem for regular languages decidable, koala_man?
13:45:53 <koala_man> c_wraith: ah. given two languages L and M, you can check whether L intersect (not M) is empty
13:46:05 <c_wraith> koala_man: that would do it
13:46:31 <koala_man> I wrote a regex complement tool at some point, and it was... not straight forward
13:47:38 <monochrom> Yeah, expect an exponential blowup when complementing.
13:49:17 <c_wraith> well that algorithm isn't efficient then.
13:50:41 <erisco> I was working on a reg lang lib as a means for defining lexers more sensibly
13:52:51 <erisco> you can say something like  identifer = word \ keyword \ number
13:52:52 <hexagoxel> could you not also just intersect both, and check that all final states are paired with final states?
13:53:17 <hexagoxel> (re regex stuff)
13:53:44 <hexagoxel> or is that trivially the same thing?
13:54:51 <koala_man> wouldn't that get me equivalence and not inclusion?
13:56:01 <hexagoxel> ah, indeed. i mean implication, not equality, to compare the is-final-state
14:00:09 <hexagoxel> any state reachable that is a final state in the first but not in the second means the first language is not a subset of the second.
14:00:57 <hexagoxel> (in the intersection of the two DFAs)
14:10:15 <hexagoxel> (it is trivially the same, isn't it..)
14:30:27 <theoprov> Hello everyone, I was wondering why many people think the standard Num typeclass is a mess
14:31:03 <theoprov> Is it because It has many "subclasses" or something?
14:31:08 <m0rphism> Hi, does someone know the definition of "compatible closure"? I'm currently reading about dependent types and am wondering what precisely is meant by "In Pure Type Systems the equivalence relation between terms is defined as the compatible closure of beta reduction". 
14:32:33 <geekosaur> theoprov, the numeric hierarchy in Haskell is mostly about making numbers behave roughly "the way people expect". as such it is idiosyncratic and doesn't have much in the way of laws
14:33:32 <theoprov> geekosaur, so it's like a quick hack with no solid roots or rules?
14:34:00 <sveit> i know some basic-intermediate category theory from the mathematics point of view, and understand applications to topology and groups, and have also programmed in Haskell and am comfortable /using/ monads. What I am having trouble with is seeing how the mathematics knowledge is actually "useful" as regards Haskell. I know, for example, that the Yoneda lemma can be used to show the lens isomorphism to a pair of functions, but that is
14:34:01 <sveit> somewhat involved and it wasn't the way the isomorphism was found anyway. Are there examples of concrete (arbitrarily small) questions where thinking categorically actually helps?
14:34:39 <sveit> for example, does it somehow motivate the forms of the monad transformers in a simple way?
14:35:24 <`Guest00000> how to pronounce (-)?
14:35:47 <`Guest00000> ...minus?
14:36:02 <`Guest00000> so that i have safeMinus
14:36:25 <geekosaur> theoprov, not that "quick" but not especially well thought out from a mathematical standpoint
14:37:51 <theoprov> geekosaur and why did they decide to make it that way, as a big part of Haskell is primarily based in mathematical concepts?
14:38:48 <theoprov> `Guest00000, yeah, minus
14:39:01 <`Guest00000> just 'safeMinus' is funny
14:39:29 <`Guest00000> initially wanted to name it more like 'safeSubtract', because verb
14:39:43 <geekosaur> theoprov, that is one of many questions to which the only nswer is 'try to find someone on the Haskell '98 committee and see if they will explain it'
14:39:44 <`Guest00000> but subtract = flip (-)
14:40:10 <theoprov> geekosaur ouch
14:40:58 <geekosaur> (a number of their decisions have been revisited; Num is not yet one of them, mostly because there is no consensus about what to do about it. which may be why we got stuck with Num as it is...)
14:41:18 <theoprov> `Guest00000 safeMinus, safeSubtract, safeSubtraction
14:43:58 <Tuplanolla> The issue is that the all the good solutions to the `Num` problem are bound to be enormous, theoprov.
14:44:04 <Tuplanolla> @hackage subhask
14:44:05 <lambdabot> http://hackage.haskell.org/package/subhask
14:44:15 <Tuplanolla> Here's an example.
14:52:13 <Darwin226> Is there a way to write a type family that gives 'True for any type, but 'False if the whole type is a type variable/completely unknown?
14:52:55 <erisco> Darwin226, what is the difference between "any type" and a "completely unknown type" ?
14:53:33 <Darwin226> Ok let's say it's a class constraint instead, or a Constraint kinded family
14:53:54 <Darwin226> It must be satisfied for any type, but only if the type isn't completely unknown
14:54:12 <erisco> what is the difference between any type and a type that isn't completely known?
14:54:23 <Darwin226> So `C a` must not be able to disappear, but if `a` is replaced by anything more concrete, it must be satisfied
14:55:08 <Fekinox> so it gives True for something like Int or Char, but False if it's (Num n) => n or something similar?
14:55:10 <erisco> I am afraid I do not understand
14:55:13 <Fekinox> do correct me if I'm wrong
14:56:03 <Darwin226> Basically, C Int is satisfied, C (Maybe a) is satisfied, C a isn't satisfied
14:56:31 <ski> isn't stable under substitution
14:56:37 <Darwin226> Sure, the type can have constraints on it. Neither classes nor type families can observe those so it doesn't matter
14:56:59 <Darwin226> ski: What do you mean?
14:57:12 <Eduard_Munteanu> You'd have to enumerate all types, at the very least, I think.
14:57:37 <ski> if `a' later becomes known to be equal to `Int', you've now gotten `C Int' to be false ..
14:58:08 <Darwin226> ski: That's why I changed my question from a bool kinded type family to a constraint kinded one
14:58:28 <Darwin226> I don't want to "observe" that something is a variable. I just want to block compilation
14:58:39 <ski> (in Prolog terms, you're asking for something like var/1 .. which is known to be an illogical kludge)
14:58:48 <geekosaur> how does this combine with separate compilation?
14:59:14 <Darwin226> How does it?
14:59:51 <erisco> lets say we are working with terms, and I have some definition like  f x = a; f (C x) = b;
15:00:20 <erisco> what it seems like you are saying is that  \y -> f y  should be  \y -> a
15:00:39 <erisco> but this doesn't make sense, because  (\y -> f y) (C z)
15:01:01 <erisco> this makes reductions non-confluent
15:01:16 <Darwin226> Yes, but in this case a/b are not actual values that you can touch and compare and what not
15:01:58 <Darwin226> I guess the closest analogy is Typeable
15:02:21 <Darwin226> An instance for every type exists, but you can't just discard a Typeable a constraint
15:02:45 <erisco> so what are you saying? a = b?
15:03:15 <Darwin226> I don't know what I'm saying in terms of your analogy because I don't think your analogy captures what I'm talking about
15:03:56 <erisco> type families are type functions, and I am showing that, at least with my understanding of your idea, that the reductions are not confluent
15:04:45 <Darwin226> Because you're insisting on the family returning something tangible like a type level Bool
15:05:20 <erisco> no, I am not, all I am saying is that it is not known whether a = b
15:05:37 <erisco> if a = b then sure, no difference, but unless we know that we don't know
15:06:02 <Darwin226> In that case I don't understand your term level analogy
15:06:21 <Darwin226> the type level function is `type family C (a :: k) :: Constraint`
15:07:04 <Darwin226> I don't see how that can easily translate to term level because the Constraint kind doesn't make any sense at the term level
15:07:38 <erisco> I am just removing the clutter, it is the same rewriting that takes place, as far as I am aware
15:09:21 <erisco> now types are terms, kinds are types, and all our functions are first order
15:09:34 <Darwin226> I guess the closest interpretation would be that `f x` isn't defined
15:10:59 <erisco> so the Constraint type is inhabited by terms such as  Num Int  and  (String ~ Char, Foldable [Double])  and so on
15:11:09 <Darwin226> This probably isn't a "can type families do this" question, but more of a "can I insist that the compiler knows at least something about this type"
15:11:59 <geekosaur> knows about it when?
15:12:18 <Darwin226> I don't want GHC to conclude that `C a` isn't satisfied. I just want to prevent the constraint being discarded
15:12:38 <Darwin226> if later it is found out that `a` is something more precise, the constraint can be removed
15:13:35 <erisco> well, doesn't seem that is going to happen, so maybe we can think of a different way to solve the problem (what is the problem?)
15:13:46 <Darwin226> Sure
15:14:07 <Darwin226> I want to pass around proof-like value, except I don't want them to be values but exist only at the type level
15:14:39 <Darwin226> Basically this means that my functions look like `f :: forall (p :: SomeProofKind) ... a -> b -> ...`
15:15:20 <Darwin226> p is ambiguous since it doesn't appear on the right, but that' fine because it's intended to be explicitly provided with type applications
15:15:52 <Darwin226> the problem is that since it doesn't apper on the right OR in the constraints, GHC is real happy to just ignore it even when you don't provide any proof
15:16:25 <glguy> Darwin226: Do you have some example code where these contraints are discarded?
15:16:47 <Darwin226> There are no constraints to discard, just an "unused" type variable
15:17:48 * hackagebot type-of-html 0.5.1.1 – High performance type driven html generation. – https://hackage.haskell.org/package/type-of-html
15:17:48 * hackagebot log-warper 1.2.1 – Flexible, configurable, monadic and pretty logging – https://hackage.haskell.org/package/log-warper
15:18:20 <Darwin226_> Sorry, laptop ran out of power. Anyone say anything since my last message?
15:18:42 <byorgey> Darwin226_: nope
15:18:56 <Darwin226_> thanks
15:20:57 <Darwin226_> Ok so to continue. Since I'm deciding how the types of my SomeProofKind are constructed, if you manage to construct it I consider that a proof. But I don't know how to force the user to provide that proof
15:21:21 <erisco> Darwin226, does this proof use 'a' or 'b'?
15:22:09 <Darwin226_> Uh... I don't know? :D
15:22:11 <glguy> Darwin226_: You use the type variable 
15:22:41 <glguy> Either as part of a constraint or not, but you'll have to actually use it
15:22:59 <glguy> You could use Tagged to trivially use it
15:23:12 <Darwin226_> glguy: Yeah, but I want to avoid a value parameter
15:23:25 <erisco> Darwin226_, it should be using some other type variables, otherwise what is the purpose of it?
15:23:27 <glguy> Darwin226_: OK, Tagged avoids a parameter
15:23:30 <glguy> and so does a constraint
15:24:00 <Darwin226_> hmmm
15:24:01 <koz_> How do I change Stack's default resolver?
15:25:00 <Darwin226_> I think I'm starting to realize the flaw in my plan
15:25:42 <geekosaur> koz_, https://docs.haskellstack.org/en/stable/yaml_configuration/#non-project-specific-config ?
15:25:43 <Darwin226_> even if I had a `Proxy p` parameter, what's stopping the user from defining `anyProof :: Proxy (p :: SomeProofKind)`
15:25:49 <Darwin226_> and then just using that in all my functions
15:26:08 <koz_> geekosaur: User config is what I was looking for. Thank you!
15:26:14 <Darwin226_> Is that why these proof things are kept at the value level?
15:27:31 <erisco> maybe you need to go back another step and talk about what it is you want to be proving
15:27:48 <Darwin226_> erisco: Oh, nothing in particular. I'm just playing around with stuff
15:28:56 * hackagebot log-warper 1.2.1, type-of-html 0.5.1.1
15:28:56 * hackagebot  → https://hackage.haskell.org/packages/recent
15:30:12 <erisco> if you pick something then we can talk specifics
15:33:32 <Darwin226_> erisco: I guess I have more to think about before I get specifics
15:37:59 * hackagebot log-warper 1.2.1, type-of-html 0.5.1.1
15:37:59 * hackagebot  → https://hackage.haskell.org/packages/recent
15:40:44 <koz_> I'm getting odd Stack output, and I'm not sure how to figure out what it's not happy about: http://lpaste.net/2160732028675293184
15:43:59 <Darwin226_> the concurrent-machines package has a base < 4.10 constraint
15:44:15 <glguy> Darwin226_: If you want a type variable to be a proof you'll have to make sure that finding a type having the correct kind is a proof on its own
15:44:41 <koz_> Darwin226_: I understand, but I permit such a base in my .cabal, right?
15:44:58 <Darwin226_> koz_: The compiler version you're using is fixing the base version to 4.10
15:45:11 <koz_> Darwin226_: Ah. That's why, OK.
15:45:29 <Darwin226_> glguy: That was kind of my idea but it seems I can't really stop someone from making "polymorphic type" of my proof kind
15:46:30 * hackagebot log-warper 1.2.1 – Flexible, configurable, monadic and pretty logging – https://hackage.haskell.org/package/log-warper
15:46:30 * hackagebot type-of-html 0.5.1.1 – High performance type driven html generation. – https://hackage.haskell.org/package/type-of-html
16:42:04 <Psybur> So I come from a java background where all my libraries come precompiled :D. Is the compile time for a haskell project with lots of dependencies comparable to a similar project with similar dependencies in another language? This is taking a looong time D;
16:42:54 <Rembane> Psybur: I think it takes longer time in Haskell. GHC does quite some passes where it does advanced things with the code.
16:43:09 <Rembane> Psybur: But it gets better when all the dependencies are built.
16:43:31 <deech> Hi all, in Cabal is there a way of setting a environment variable in a dependency's build script and having that available in my package. For instance, in a dependency I update the LIBRARY_PATH environment variable but it doesn't make it to the package.
16:50:34 <deech> PsyBur: Yes, long build times are normal. To make things more frustrating a repl build has to recompile everything but is much faster but unfortunately a profiling build has to also recompile from scratch but it is *way* slower.
16:51:40 <juri_> Numeric/Sum.hs:97:1: error:
16:51:53 <juri_>     Expecting a type of the form: cxts => typ -> rep
16:52:03 <juri_> cabal: Leaving directory '/tmp/cabal-tmp-1284/math-functions-0.2.1.0'
16:52:07 <juri_> not a good day.
16:52:32 <juri_> anyone else seen that compiling their dependencies yet?
16:55:25 <glguy> juri_: The author of this package shirked responsibility for figuring out what versions of things this package supports on to you.
16:55:38 <glguy> maybe you've got a set of versions that it doesn't support?
16:56:36 <juri_> ... i am the author of the package i'm trying to compile.  I have one node it's working on.
16:56:59 <glguy> I'm talking about math-functions, which you don't appear to be the author of
16:57:42 <juri_> ;)
16:58:02 <juri_> I'm running that version on my operational node...
16:58:21 <juri_> must be something it depends on having changed versions.
18:07:08 <`Guest00000> > error "1" + error "2"
18:07:10 <lambdabot>  *Exception: 2
18:07:12 <`Guest00000> > error "1" * error "2"
18:07:14 <lambdabot>  *Exception: 1
18:14:25 <WinterFox[m]> Using pattern matching how would I match anything of the type [()]?
18:15:22 <geekosaur> types are static, you can't determine a type by pattern matching because the type has long since been fixed (else the code would not have compiled)
18:27:30 <`Guest00000> WinterFox[m]: you can use the extension ScopedTypeVariables and write the pattern (_ :: [()])
18:34:20 <`Guest00000> heh, in addition to safeMinus, unsafeMinus emerges
18:35:52 <`Guest00000> which doesn't fully check that right operand isn't greater than left 
18:37:24 <`Guest00000> which is just (\x y -> if x < y then 0 else x - y), except that here this can be actually more efficient
18:43:32 <jle`> WinterFox[m]: pattern matching things of type [()] is the same as pattern matching any list
18:43:38 <jle`> you can use : and []
18:44:13 <jle`> `Guest00000: i think what you are seeing is from some optimization of 0 * x = 0
18:45:38 <dfeuer> jle`: I believe that optimization was only in one GHC version. It was almost certainly a bad idea.
18:50:34 <`Guest00000> how can i name the operation (Ord a => [a] -> [a] -> ([a], Maybe (Either [a] [a]))) which merges two lists and maybe returns either remainder?
18:51:07 <`Guest00000> merges only until one is empty
18:57:39 <joncfoo> zipRemainder?
19:00:58 <`Guest00000> it doesn't exactly zip, and it doesn't zip remainder, it returns remainder, which is slightly incompatible with "zipRemainder"
19:01:14 <`Guest00000> mergePrefix? mergeCommon?
19:15:32 <pierrot> Hi. I have these programs c-i (code->http://lpaste.net/358514, heap profile graph->https://i.imgur.com/otv0CRB.png), and c-ii (code->http://lpaste.net/358515, heap profile->https://i.imgur.com/QQWMIXk.png)
19:15:58 <pierrot> it seems that let xs = [1..n] force the allocation of the whole list
19:16:33 <pierrot> why that is happening?
19:16:35 <iqubic> I think that sounds right. Not sure what we are discussing though.
19:17:11 <Cale> pierrot: It doesn't force the allocation of anything on its own...
19:17:17 <Cale> let me look at your pastes
19:17:43 <Cale> Ah, length xs will cause the entire list to be evaluated
19:18:10 <pierrot> hmm but why that doesn't happen with the second program?
19:18:13 <Cale> and because there's still a reference to it (head xs), the list will remain in memory once evaluated
19:18:32 <Cale> Because you now have two separate lists
19:19:07 <Cale> You didn't bind [1..n] to a variable, so it will be evaluated once, discarded, and then head [1..n] will start over again
19:19:21 <Cale> length xs > 0 is a terrible way to discover that a list isn't empty
19:19:28 <Cale> because it has to compute the entire list
19:19:43 <Cale> better to use not (null xs), or better still, just pattern match
19:19:59 <Cale> let f = case [1..n] of [] -> 0; (x:xs) -> x
19:21:11 <pierrot> but why length [1..n] doesn't force the creation of the whole list?
19:21:21 <Cale> It does
19:21:37 <Cale> However, that list is immediately discarded
19:21:56 <Cale> and there's no reason to keep any part of it in memory, so each element of the list will become garbage immediately
19:22:07 <Cale> So length [1..n] will run in constant space
19:22:24 <Cale> but length xs won't if there's still a reference to xs somewhere else in the program
19:22:28 <iqubic> What are we discuss
19:22:40 <pierrot> Cale: Hmmm now I understand
19:22:48 <Cale> iqubic: The two programs that pierrot pasted and their differing space behaviour
19:23:22 <iqubic> Cale: I didn't see either program. I just joined.
19:23:33 <Cale> <pierrot> Hi. I have these programs c-i (code->http://lpaste.net/358514, heap profile graph->https://i.imgur.com/otv0CRB.png), and c-ii (code->http://lpaste.net/358515, heap profile->https://i.imgur.com/QQWMIXk.png)
19:24:46 <pierrot> Thank you very much, Cale :)
19:24:57 <Cale> No problem
19:25:15 <iqubic> Cale: Why are those any different?
19:25:34 <Cale> The key thing to keep in mind is that with lazy evaluation, expressions which are bound to a variable will be evaluated at most once so long as the variable remains in scope
19:26:04 <Cale> So if the expression evaluates to some list which consumes a huge amount of memory, that list won't become garbage if there's another usage of the variable yet to be evaluated
19:26:31 <iqubic>  Right and the nth element of the list is only found when it is needed
19:27:04 <Cale> In the first program, xs is bound to the list [1..n], and the fact that we have the unevaluated expression head xs sitting in one branch of the if expression is enough to ensure xs won't become garbage, and so a lot of memory is used
19:27:06 <iqubic> But that's not what's happening here.
19:27:25 <Cale> (while computing the length of xs, which evaluates the entire list)
19:27:28 <iqubic> What is N in that case.
19:27:32 <iqubic> ?
19:27:36 <Cale> I don't know, something large
19:28:16 <Cale> Perhaps about a million?
19:28:33 <Cale> 10 million?
19:28:55 <iqubic> That's a lot of memory being used to store the list.
19:29:00 <Cale> yep
19:31:41 <Cale> You have a machine word integer tag, and then two pointers, and then the list element itself, which is a boxed Integer consisting of an integer tag and then what will likely be a machine word, since these numbers are small
19:32:15 <c_wraith> and on 64-bit ghc, that will be 8 bytes each
19:32:20 <Cale> yep
19:32:38 <Cale> So something like 40 bytes per element.
20:29:41 <mrkgnao> is anyone here familiar with Trifecta? (or, more generally, with making parsers backtrack properly)
20:35:50 <lyxia> mrkgnao: what about it
20:45:20 <dbousamra> I'm getting this error: "Expected type: ST s1 Word8         Actual type: ST s Word8" when trying to work with two ST's. Any ideas how to combine?
20:47:24 <geekosaur> you can't, by design
20:48:09 <geekosaur> you do things in one ST. you cannot pull stuff out that has the 's' constraint and use it elsewhere
20:54:27 <mrkgnao> lyxia: I've actually fixed the problem I was stuck on, but I have a new one.
20:55:16 <mrkgnao> So I'm trying to parse the command-line switches for ls (I'm trying to write a very basic shell). I have a simple data LsOpt = Recursive | All | ... type.
20:56:46 <mrkgnao> Now I have a functions that associate, e.g. Recursive to 'R', All to 'a', and so on -- and also a (partial!) function in the other direction. My parser has to use both, and it feels kinda icky
20:57:00 <mrkgnao> since I'll have to extend the list of switches anyway, and I'd prefer not to do this.
20:57:30 <geekosaur> most shells don't have "ls" built in...
20:57:43 <mrkgnao> Something I just thought of is to pass in a [(LsOpt, Char)] alist into oneOf ... which I could do by writing CharParsing for it?
20:58:19 <mrkgnao> geekosaur: well, this is actually a Powershell-like experiment, so ls would have to return something like a "rich" list of file "objects".
20:58:32 <mrkgnao> think of it as a frontend to Turtle if you'd like :)
21:00:16 <mrkgnao> (ugh, CharParsing is for *monads*, not the input type.)
21:00:51 <geekosaur> in any case, there are lots of options parsers out there
21:01:46 <mrkgnao> yeah, I kind of just wanted to write my own. I'm familiar with optparse-applicative, for example, and it would be trivial to use it for this.
21:02:09 <geekosaur> that's kinda a thankless PITA
21:04:32 <mrkgnao> this project is going to involve a lot of parsing anyway, so I might as well get started. 
21:04:59 <mrkgnao> and I haven't written a parser in a while, and also never used anything outside of Megaparsec before, so ... I like it. *shrug*
21:39:17 <juri_> ok, so if you're running into problems compiling math-functions on haskell 8.0.1, add template-haskell == 2.11.1.0 to your build dependencies.
21:47:20 <hous> well, fingers crossed, I may have finally gotten hledger to build on OSX 10.6.8
21:47:27 <hous> just wanted to celebrate
21:47:51 <hous> that took forever
21:51:35 <hous> no binaries that I could find for 10.6 snow leopard.
21:55:00 <hous> so, I built ghc 7.10.3, bootstrapped on 7.6.3, from an old homebrew formula with the help of a kind man on the homebrew IRC channel
21:55:58 <hous> then built cabal install after figuring out the sandbox wasn't using my updated curl, but the old system curl which didn't work
21:56:13 <hous> I forget how I worked around that.
21:56:21 <hous> Then built stack with cabal
21:56:28 <hous> lts 6.35
21:56:57 <hous> it also choked on cryptonite around this time, need to disable support_aesni and support_rdrand
21:57:53 <hous> let's see, then I tried building hledger but ran into trouble, among other things, with a package called double-conversion which was apparently updated for newer OSX versions which use libc++ not libstdc++
21:58:02 <hous> so I had to fork that
21:58:22 <hous> and set a new URL in my stack.yaml
21:58:50 <hous> but now I think I'm in the home stretch!
22:05:26 <Cale> hous: Is there something preventing hledger from building with a recent compiler?
22:06:41 <hous> no but I believe that's the latest ghc I can support
22:06:46 <hous> I forget why
22:10:37 <hous> anyway, good night. I hope that made for good reading
22:23:26 <`Guest00000> why is parsing so difficult?
22:23:59 <Cale> Is it?
22:24:18 <`Guest00000> it looks so well in imagination, yet gives rise to complexity in code
22:24:28 <`Guest00000> it isn't conceptually
22:39:09 <`Guest00000> i find tutorial about how to use parser combinators but none about how to write them
22:39:13 <`Guest00000> tutorials *
22:41:45 <kadoban> `Guest00000: Have you gone through https://github.com/data61/fp-course ? IIRC it has you create a simple at some point.
22:51:06 <`Guest00000> custom list type
22:51:22 <`Guest00000> for nothing
22:51:41 <`Guest00000> very mindfucky
23:53:11 <mach> `Guest00000: i got bored and did pretty much the entire course just now
23:53:23 <mach> those custom types are annoying af
