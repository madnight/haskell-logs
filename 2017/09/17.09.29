00:08:06 <kellytk> Hi, would you please recommend a link to a worthwhile Haskell vs Idris discussion?
00:13:26 <vc> i'm having some difficulty with FinalizerPtr
00:13:39 <vc> type FinalizerPtr a = FunPtr (Ptr a -> IO ())   	-- Defined in ‘GHC.ForeignPtr’
00:14:00 <vc> it has one constructor that takes a function Ptr a -> IO ()
00:14:46 <vc> but if I actually try to use the constructor i get a type error, for example
00:14:47 <vc> FunPtr (\x -> pure ()) :: FinalizerPtr CInt
00:14:53 <vc> Couldn't match expected type ‘ghc-prim-0.5.1.0:GHC.Prim.Addr#’
00:14:59 <vc> with actual type ‘p0 -> f0 ()’
00:16:20 <alp> vc, 'type' introduces a type synonym, not a new data type with a constructor (like data/newtype)
00:16:52 <alp> so to build a 'FinalizerPtr CInt', you equivalenty have to build a 'FunPtr (Ptr a -> IO ())'
00:17:08 <ClaudiusMaximus> the error indicates there is a "FunPtr :: Addr# -> FunPtr a" in scope
00:17:29 <ClaudiusMaximus> but the real way to create FunPtr is i think via foreign import wrapper
00:18:07 <vc> alp i see so the constructor should be FunPtr ghc-prim-0.5.1.0:GHC.Prim.Addr#
00:18:41 <vc> what's foreign import wrapper
00:19:04 <royal_screwup21> Suppose I have a string with digits and letters. I wanted to filter out the digits so I have only the letters. What's the easiest way to accomplish this without using the Data.char module? (I know I need to use filter at one point but I'm not sure how to tie it in with the function)
00:19:07 <vc> do you mean foreign import ccall
00:19:14 <vc> ..
00:19:37 <Axman6> royal_screwup21: can you write a function which takes a Char and tells you if it's a digit?
00:20:07 <ClaudiusMaximus> vc: https://wiki.haskell.org/Foreign_Function_Interface#Function_pointers
00:20:29 <ClaudiusMaximus> foreign import ccall "wrapper" createAddPtr :: (Int -> Int) -> IO (FunPtr (Int -> Int))
00:20:51 <Axman6> royal_screwup21: hint, a digit is greater than or equal to '0' and less than or equal to '9'
00:21:30 <royal_screwup21> thanks for the pointer, I'll try that approach!
00:24:52 <vc> thanks i will try this
00:25:46 <akfp> why am I getting "Could not deduce (Integral (Sum Int))"  - shouldn't  Integral a => Integral (Sum a) be derived for me?
00:44:44 <raduom> Hi. Is anyone that worked on the llvm-hs package around?
00:46:51 <halogenandtoast> Anyone have a suggestion on how to make this aeson code look clean? http://lpaste.net/6510871156004749312
00:51:56 <kahlil29> I have an Aeson.Value that contains `String "someString" ` . What function do I use to get just the string (from the Value)
00:53:03 <halogenandtoast> kahlil29: you can pattern match it
00:53:33 <halogenandtoast> keep in mind, the type is (String !Text)
00:53:55 <halogenandtoast> s/type/constructor/
00:55:03 <kahlil29> still not clear how to go ahead with that. My main confusion is due to it being (String !Text)
00:55:16 <halogenandtoast> so: case jsonValue of; String t -> Just t; _ -> Nothing
00:55:24 <halogenandtoast> would give you a Maybe Text
00:56:16 <halogenandtoast> that should give you some idea on how to get the text out
00:56:33 <halogenandtoast> if you don't care about errors you write some bad code.
00:56:53 <kahlil29> lol this is making my head spin. I already had a Maybe Value which gave me the Value. So I am ending with a 3 level nexted case right? :P 
00:57:01 <kahlil29> nested
00:57:24 <kahlil29> but sounds good. I'll try it out. thanks for the help :) 
00:57:26 <halogenandtoast> traversing a nested structure can do that.
00:57:39 <halogenandtoast> I sometimes use aeson-lens to make it slightly easier
00:57:53 <halogenandtoast> but to get started just write nested cases (or pull them into their own functions)
00:57:57 <kellytk> Pardon my certainly trite question, how ambitious would it be to model program logic in Haskell and then write some more Haskell to generate the program in a certain target language?
00:58:32 <halogenandtoast> kellytk: like a compiler?
00:59:03 <ventonegro> kellytk: EDSLs and Free monads come to mind
00:59:29 <halogenandtoast> kahlil29: btw, if you make a custom record type to parse into, it can often be much easier to parse.
00:59:36 <MP2E> certainly possible, https://ivorylang.org/ivory-introduction.html comes to mind
01:00:00 <halogenandtoast> but nesting can still be painful, you need to write records for each nested type and give them FromJSON instances
01:00:58 <kahlil29> yep I think since this is just the case with one column of my table, I'll stick with the nested cases for now ^_^ 
01:02:09 <kellytk> halogenandtoast: Yes
01:02:53 <roscode> Hey guys I'm thinking of writing a program for homework in haskell, one stipulation is that the submission needs to be contained in a single directory and provide a makefile to build the project, libraries we use should be included as source and designated as vendor code. Currently I have in my make file basically just a cabal update and cabal installs because I haven't figured out how to include the source for normal modules like 
01:03:03 <roscode> Sorry 4 wall of text
01:03:58 <ongy> roscode: if you have a recent enough cabal-install you can use a cabal.project file and just drop the dependencies into the directory
01:04:32 <ongy> and have your makefile just call cabal new-build, and it should do everything
01:05:08 <roscode> By recent enough cabal-install do you mean the version of cabal being recent? Because I think it might be terribly old
01:05:44 <ongy> it works for me on debian stable, so if you have to use anything older, yell at whoever set it up. But it can't be anciant
01:06:35 <roscode> I'll see if I can make it happen, thank you for the direction!
01:07:37 <ongy> documentation on this isn't the nicest yet, since the entire new-* isn't completly done. However it should be possible to get it up
01:08:48 <Li[m]1> I was under the impression that a purely functional language couldnt have any effect
01:11:51 <Ferdirand> evaluation cannot have effects. but you can still manipulate effects as pure values
01:14:42 <akfp> roscode: the Makefile requirement is probably just so someone can write `make`.  you probably don't need to express dependencies in the Makefile language.
01:15:26 <kellytk> Can a Haskell program dynamically load Haskell while operating?
01:19:05 <Axman6> there are ways to do it, yes
01:21:47 <kellytk> Axman6: Take a case where a chat bot can have new code (plugins) loaded to it, interactive, at run-time; and ideally the plugin code wouldn't need to be in the program binary
01:22:23 <Axman6> yes, this is something glirc, a haskell irc client, does
01:24:23 <kellytk> That's encouraging.  Do you know if that functionlity carries over to GHCJS?
01:25:29 <vandenoever> "Could not deduce (Text.Blaze.ToMarkup GHC.Show.ShowS)"
01:26:21 <vandenoever> this is in hamlet file from the expression "#{showFFloat (Just 2) fraction}"
01:29:52 <gkbrk> Hello!
01:30:55 <gkbrk> Is there a way in Haskell to turn a function into a string. I don't mean the output btw. Something like (show (5 + 5)) it should return something like (5+5) or 5 + 5
01:31:35 <Axman6> ventonegro: ShowS is a synonym for String -> String, you need to add a "" to the end of that expression
01:31:41 <Axman6> #{showFFloat (Just 2) fraction ""}
01:32:28 <Axman6> (ShowS is a fairly old way to get more efficient Show instances by using the DList/Endo trick, where composition becomes O(1) because it's just (.))
01:33:35 <vandenoever> Axman6: thanks, that fixes it. the DList/Endo explanation escapes me
01:34:09 <vandenoever> Axman6: is there a more idiomatic way to format a real?
01:37:46 <ClaudiusMaximus> gkbrk: sort of, to a limited extent - you can define your own expression data type with custom Show instance, and make it an instance of Num too
01:38:15 <ClaudiusMaximus> gkbrk: foldr (+) 0 [a,b,c] -- this is Debug.SimpleReflect, iirc
01:38:26 <ClaudiusMaximus> > foldr (+) 0 [a,b,c]
01:38:29 <lambdabot>  a + (b + (c + 0))
01:40:35 <ventonegro> Axman6: You called? :)
01:45:28 <gkbrk> ClaudiusMaximus: Thank you
01:51:05 <Axman6> ventonegro: uh, sorry, meant vandenoever (I think this is like the second time this week I've done this to you, sorry!)
01:52:58 <ventonegro> Axman6: :)
01:59:03 <jle`> ventonegro: i use printf to format floats heh
01:59:27 <jle`> > printf "%.2f" pi
01:59:31 <lambdabot>  error:
01:59:31 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M486254734525...
01:59:31 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
01:59:36 <jle`> > printf "%.2f" pi :: String
01:59:39 <lambdabot>  "3.14"
02:00:03 <ventonegro> Oh no, it's spreading
02:01:35 <jle`> oh sorry ;_;
02:01:38 <jle`> i just v<tab>'d
02:01:54 <ventonegro> no worries :)
02:02:02 <jle`> :)
02:05:00 <vandenoever> v<tab> ignores the alphabet
02:05:13 <ongy> depends on the client :)
02:05:30 <brynedwards> irssi seems to tab through alphabetically
02:05:46 <vandenoever> my client also suggests ventonegr first
02:06:04 <vandenoever> what makes ventonegr special? time of joining?
02:06:05 <brynedwards> ok irssi is actually just random
02:07:19 <vandenoever> konversation finds the match that spoke most recently and is not you
02:09:07 <Sose> same with weechat
02:09:41 <brynedwards> hmm irssi could be the same then
02:18:20 <jle`> for my client v<tab> looks for the last person who sent any messages
02:18:24 <jle`> whose name starts with v
02:18:32 <jle`> so if i v<tab> now i get vandenoever 
02:22:00 <maerwald> anyone knows of a security focused web framework or has tried to apply IFC/MAC to one of the lower-level ones?
02:34:28 <mniip> ha!
02:34:36 <mniip> hexchat can do eitehr because it's configurable!
03:27:31 <ertes-w> hllo
03:28:28 <Itkovian> Hi. Anybody having experience with conduits and concurrency? I currently have this http://lpaste.net/6459243974069583872 code (cleaned up a bit, not sure if it would compile completely). The main loop that's processing information is on lines 110-112.  I've tried the operators from stm-conduit Data.Conduit.Async, but I suspect I'm missing something still, as the number of lines I could process per second went down drastically.
04:12:39 <ertes-w> Itkovian: before that you didn't use concurrency?
04:13:10 <Itkovian> I just use what there now, so a whatever regular conduit, I suppose that is.
04:15:00 <ertes-w> Itkovian: do you observe a performance difference between -threaded and no -threaded?
04:16:23 <ertes-w> Itkovian: switching from mere coroutines (conduit/machines/pipes/…) to fully fledged concurrency together with STM it's kinda expected to see some extra latency, because now you have the extra cost of STM and the extra cost of context switching and concurrent GC
04:16:44 <ertes-w> coroutines are lightning-fast, but of course single-threaded…  they are really just CPS under the hood
04:17:05 <Itkovian> I do see GC parallelism going up from ~1% over -N2 to 30% 
04:17:31 <ertes-w> Itkovian: you might find that without -threaded you get much better performance
04:17:53 <ertes-w> but consider that a dirty hack…  in general you should always compile with -threaded, if you use concurrency
04:18:07 <ertes-w> (i'd go as far as to say that you should always compile with -threaded by default)
04:18:09 <Itkovian> better performance with regular non-concurrent consuits, you mean
04:18:17 <Itkovian> I do compile with -threaded
04:18:25 <ertes-w> no, better concurrent performance
04:18:39 <ertes-w> with the code you have right now you might see better performance without -threaded
04:21:00 <ertes-w> haskell doesn't need multiple OS threads for most concurrency tasks, and if you don't compile with -threaded, then all of the synchronisation code that causes those kinds of latencies goes away…  the obvious caveat of course is that you can only use a single OS thread
04:24:25 <Itkovian> Right. But the idea would be to be able to process incoming messages concurrently as there's no sharing of anything between them and parsing/normalisation takes a while. Hence my though of using some concurrent conduit system.
04:32:46 <ertes-w> Itkovian: concurrency doesn't necessarily descrease your throughput, but it can increase your latency
04:33:03 <ertes-w> Itkovian: you may find that you're now able to process more messages *concurrently*
04:33:34 <Itkovian> I'm looking at total time to process ~ 9M messages
04:33:48 <Itkovian> But maybe there's a bottleneck elsewhere
04:33:54 <merijn> Itkovian: I'm actually putting the finishing touches on my parallelised conduit/pipe :p
04:34:19 <Itkovian> anything I can testdrive?
04:34:56 <merijn> Itkovian: I'm hoping to put an early alpha version on github today or monday
04:35:11 <Itkovian> cool. let me know :)
04:37:05 <merijn> Currently doing some benchmarking/testing to see if it's actually working. But benchmarking is tricky, as you need non-trivial amount of work to illustrate speedup, but those benchmarks take way too long to run :p
04:38:57 <Itkovian> I may have one :)
04:39:36 <merijn> Right now I'm just having a function that does "threadDelay" but the overhead seems to kill any scaling above 5 threads
04:39:54 <ertes-w> also to maximise throughput, you shouldn't use fine-grained STM =)
04:40:32 <merijn> ertes-w: huh, why? I'd say fine-grained is much preferred over coarse grained STM
04:40:37 <ertes-w> trivial STM is very cheap, but as soon as you use STM for…  you know…  transactional memory, it becomes very expensive very quickly
04:40:42 <merijn> ertes-w: coarse grained STM increases conflicts
04:40:51 <merijn> Which increases recomputation
04:40:59 <ertes-w> merijn: no, i mean use it only where necessary
04:41:05 <ertes-w> not to use larger transactions
04:42:18 <merijn> 1000 messages with a 1e4 delay takes 1/4th sequential time on 5 threads, but also for 10 threads, so...
04:42:39 <merijn> I think I should restructre my benchmarks so I can run more of them
04:52:03 <merijn> Is there some sort of concurrent map data structure?
04:52:22 <ertes-w> merijn: TVar (Map k a)?
04:52:40 <merijn> ertes-w: I suppose that works
04:53:00 <ertes-w> merijn: sometimes i use (TVar (Map k (TVar a))), so i can update individual values without triggering an update to the map TVar
04:53:26 <ertes-w> helps my threads sleep better =)
04:53:29 <drdo> In one module I have instances for [a] and String and the String one is marked OVERLAPPING. When importing this module and trying to use the String instance, I get an overlapping instance error
04:53:35 <drdo> Except in ghci, where it works fine
04:53:39 <drdo> What's up with that?
04:53:44 <merijn> ertes-w: I have a relatively simple issue. Basically I have a test generating function that compares against a sequential baseline, but that's triggering recomputes of the base line, which is useless and slow
04:54:05 <merijn> ertes-w: So I figure I can simply try and cache the sequential results in a Map and call it a day
04:54:17 <ertes-w> merijn: do you need to update often?
04:54:28 <ertes-w> or mainly insert and read?
04:54:34 <merijn> just insert and read
04:54:41 <ertes-w> then go with (TVar (Map k a))
04:55:02 <merijn> ertes-w: Basicallly, if I have 10 benchmarks and the sequential one takes 1 minute than I wanna avoid wasting my life on waiting :p
04:55:37 <ertes-w> merijn: one day i will write a variant of 'rapid' that can be used in production =)
04:55:49 <ertes-w> right now you can/should only really use it with GHCi
04:56:25 <drdo> What the hell, changing the String instance to [Char] made it work
04:58:04 <merijn> ertes-w: hmmm, actually "TVar (Map k (MVar a))" might be nice
04:58:32 <merijn> ertes-w: If I parallelise my test-suite I avoid recomputing long benchmarks, I just block trying to get the results (if the first thread there doesn't have it yet)
05:01:29 <ertes-w> merijn: if you use a TVar at the leaves you can update transactionally, if your use case requires it
05:01:42 <merijn> ertes-w: My usecase is "run-once"
05:01:48 <ertes-w> if not, you can probably use an MVar for both
05:02:12 <merijn> ertes-w: Well, the Map should be updated concurrently, but leaves only computed once
05:02:36 <merijn> ertes-w: But since computing a leave can take a while you want it to only run once and any other takers should just wait for the first guy to finish
05:02:52 <ertes-w> merijn: yeah, makes sense
05:03:40 <ertes-w> merijn: but you may still run into a race: if two threads find the key to not exist, they both insert the key – sequentially
05:04:22 <ertes-w> so you probably need a TMVar anyway: either insert the key, or find that it already exists
05:04:53 <merijn> ertes-w: That shouldn't be possible, right? If you check it's there and then insert, that happens atomically
05:05:02 <merijn> ertes-w: If anyone else modifies you endup retrying
05:05:17 <merijn> That's the entire point of STM...
05:05:42 <ertes-w> merijn: you mean create the MVar before entering the transaction?  yeah, that might work
05:06:05 <merijn> yeah
05:06:26 <ertes-w> creating an MVar is cheap enough
05:26:07 <solV3d> hi ! :)
05:26:50 <solV3d> i am trying to write bubble sort. my problem is that i only "loop" once through the whole list http://lpaste.net/358790
05:27:32 <solV3d> currently i have no idea how to loop until no more swaps are performed
05:28:09 <solV3d> in other language i would set a global flag and do a while(flag) { ... } but haskell is different :D
05:28:22 <opqdonut> you could try writing a predicate that checks if the list is sorted
05:28:51 <opqdonut> and rename the bubbleSortList to something like bubbleSortIteration
05:29:19 <opqdonut> and have a bubbleSort function that returns the input if it is sorted, otherwise calls bubbleSortIteration and recurses
05:29:49 <opqdonut> in general a loop in an imperative language translates to a recursive function in haskell
05:30:01 <solV3d> yes i could that but that would take another function :)
05:30:10 <solV3d> do*
05:30:11 <opqdonut> well you'll need multiple functions
05:30:25 <opqdonut> you can use where or let to make the helper functions local
05:30:30 <solV3d> ok ill try that :)
05:30:36 <solV3d> thanks for the hint
05:30:52 <opqdonut> anyway, something like "while (condition(x)) { x = foo(x) }" translates to "go x = if condition x then x else go (foo x)"
05:31:26 <opqdonut> (you can use guards or pattern matching instead if if-then-else of course)
05:43:48 <solV3d> this is so hard to debug
05:43:51 <ertes-w> solV3d: during your traversal maintain a state flag
05:46:20 <solV3d> whooo i think it works
05:46:36 <solV3d> http://lpaste.net/358791
05:47:30 <ertes-w> @let bubble1 = foldr (\x (b, xs) -> case xs of [] -> (False, [x]); (x':xs') -> if x < x' then (b, x : xs) else (True, x' : x : xs')) (False, [])
05:47:32 <lambdabot>  Defined.
05:47:36 <ertes-w> > bubble1 "abcd"
05:47:38 <lambdabot>  (False,"abcd")
05:47:42 <ertes-w> > bubble1 "acbd"
05:47:45 <lambdabot>  (True,"abcd")
05:47:55 <ertes-w> @undef
05:47:56 <lambdabot> Undefined.
05:48:24 <solV3d> lets looks more complicated :D
05:48:31 <ertes-w> @let bubble1 = foldr (\x ~(b, xs) -> case xs of [] -> (False, [x]); x':xs' -> if x < x' then (b, x : xs) else (True, x' : x : xs')) (False, [])
05:48:33 <solV3d> that*
05:48:33 <lambdabot>  Defined.
05:48:53 <ertes-w> solV3d: this fold bubbles and checks in one traversal
05:49:35 <solV3d> thanks i will save this for later
05:49:51 <solV3d> right now i prefer to not introduce new things and do it the old fashion way :D
05:50:01 <ertes-w> @let bubble xs = case bubble1 xs of (True, xs') -> bubble xs'; (False, xs') -> xs'
05:50:02 <lambdabot>  Defined.
05:50:13 <ertes-w> > bubble "dcba"
05:50:16 <lambdabot>  "abcd"
05:51:35 <ertes-w> solV3d: sure…  you might find this helpful though: http://ertes.eu/tutorial/foldr.html =)
05:52:54 <Sornaensis> > bubble [1,4,6,2]
05:52:57 <lambdabot>  [1,2,4,6]
05:55:50 <solV3d> wow thats a lot of new stuff :D
05:56:17 <solV3d> i am wondering, in what field do you need haskell
05:56:29 <solV3d> like, where do people using haskell work :D
05:56:40 <merijn> solV3d: Banks, facebook, startups...
05:56:45 <ertes-w> solV3d: these days it's used for pretty much everything that isn't embedded
05:57:13 <Sornaensis> using haskell to make backends and single page web applications is pretty popular right now
05:57:14 <solV3d> embedded in what sense?
05:57:40 <ertes-w> solV3d: writing haskell code for very small systems
05:57:42 <ertes-w> that's not something haskell supports
05:57:50 <ertes-w> also no real-time guarantees
05:57:59 <ertes-w> there are better languages for those cases, like rust
05:58:26 <ertes-w> alternatively there is a semi-popular approach to write embedded DSLs in haskell that are compiled to those systems
05:58:28 <solV3d> oh you are a german guy as well :D Hallo
05:58:35 <ertes-w> see e.g. the 'atom' and 'accelerate' libraries
05:58:44 <ertes-w> hallöchen =)
06:00:26 <solV3d> i have been doing a lot of c# but i am failing (or at least need a lot of time) when i do just simple things in haskell
06:00:55 <solV3d> maybe because i did not use recursion very often
06:01:09 <Psybur> Ich habe eine Wurst in meiner Hosen. Hast du eine broetchen fur ihr?
06:01:36 <ventonegro> Psybur: This is not Tinder
06:01:44 <ertes-w> haskell patterns and conventions are very different from those used in C#, so that's expected…  in fact it's the exact opposite for me now: i have a hard time using other languages
06:01:50 <Psybur> ;p
06:02:22 <merijn> solV3d: Also, different problems are simple in haskell vs C#. Dunno what kinda stuff you normally do
06:02:24 <ertes-w> Psybur: let's keep it clean, shall we =P
06:02:42 <solV3d> hm yea i guess i need more practice
06:03:07 <solV3d> and try to stop thinking in a non-functional way
06:03:12 <Sornaensis> haskell also uses pretentious mathematical terms wherever possible which can be confusing at first
06:03:26 <Psybur> Still dont know my morphisms :{
06:04:14 <maerwald> Psybur: what the... 
06:04:16 <Ferdirand> pretentious mathematical terms could be easily replaced by ridiculous ones, no ?
06:04:28 <Ferdirand> Functor will now be Banana, etc etc
06:04:35 <Sornaensis> yea
06:04:52 <Psybur> maerwald, jetzt hast du Hunger? :D
06:06:56 <maerwald> I could have a burrito now...
06:07:22 <Psybur> Im probably gonna get a pepperoni, mushroom and clams pizza later ;p
06:08:05 <maerwald> haskellers usually only eat burritos
06:08:42 <Sornaensis> I actually prefer tuna sausage
06:09:04 <rotaerk> I eat monads for breakfast !
06:09:17 <maerwald> cannibalism!
06:09:22 <Psybur> https://neoeinstein.github.io/monads-are-not-burritos/#/
06:09:23 <Psybur> :D
06:10:54 <Psybur> hmm that sucked
06:14:53 <ertes-w> solV3d: just write more haskell…  that's the way to train yourself
06:15:30 <ertes-w> (and there is really no other way)
06:15:35 <Sornaensis> ^^^
06:15:45 <Sornaensis> like any other lang
06:18:48 <Psybur> solV3d, if you need inspiration, I find algotraders/backtesting frameworks are good for learning languages :D
06:30:17 <solV3d> ertes-w i agree
06:30:26 <merijn> I don't suppose there's like a generic "diff" function for diffing data structures?
06:31:47 <Sornaensis> how do you diff a function
06:32:08 <merijn> Sornaensis: I don't see how that's relevant for a question about diffing data structures?
06:32:59 <Athas> merijn: yes, as long as the data structure has an isomorphism to text.
06:33:31 <merijn> Athas: Not quite what I was looking for, since unix diff is line-based
06:34:28 <Psybur> What is the most efficient way of getting text files into vectors of CDouble?
06:34:39 <Sornaensis> because data structures may contain functions
06:35:06 <merijn> Sornaensis: By that logic we can't check data structures for equality since they may contain functions
06:35:29 <Sornaensis> yes that is what im getting at 
06:35:50 <Athas> Psybur: not sure what's the fastest way to parse the textual representation of a single double, but I'd recommend using Data.Vector.Unboxed.Mutable.STVector to construct the vector.
06:36:19 <merijn> Sornaensis: Except we are perfectly capable of checking data structures for equality. What I mean is completely obvious, so I don't see the point in being so pedantic
06:36:43 <Sornaensis> . _.
06:36:52 <Athas> I do that for my own reasonably efficient parsing of double vectors, but I use an Alex-based lexer as a preprocessor.
06:37:36 <Psybur> Athas, I have to use a Data.Vector.Storable
06:39:10 <Psybur> So its a csv, and I want to turn columns into vectors. Right now I am reading in as String and splitting on ",". Would I see a significant speedup by switching to reading in as ByteStrings?
06:39:20 <Athas> Psybur: then use Data.Vector.Storable.Mutable.STVector and freeze it to a Data.Vector.Storable.Vector at the end.
06:39:24 <merijn> Psybur: Yes
06:39:30 <merijn> Psybur: String is slow as fuck
06:39:44 <Athas> Never use String in anything that is supposed to be fast.
06:39:47 <Athas> Text would also be good.
06:39:59 <Psybur> Ok Ill take a look into it
06:40:00 <merijn> Text would be better for CSV
06:40:29 <Athas> But you really need mutable vectors while you are constructing the result.
06:40:40 <Athas> It's a pretty common pattern in high-performance Haskell.
06:40:56 <Psybur> Athas, even if I know the length before hand and can use fromListN ?
06:42:52 <Athas> Psybur: no, if you use lazy IO, that might also work.
06:47:31 <sulemankm> Can anyone plz let me know the purpose of monads?
06:49:04 <c_wraith> sulemankm: they don't have a purpose.  They just are.  Kind of like cats.
06:49:46 <ventonegro> sulemankm: They model a sequence of computations where the input of some computation depends on the result of a previous computation.
06:50:01 <c_wraith> sulemankm: if you're asking because you think you need to "understand monads" before learning haskell...  Don't bother.  It's not necessary or helpful
06:50:50 <Sornaensis> monads are a post hoc qualia phenomenon
06:51:03 <Sornaensis> oh darn he missed my joke
06:51:12 <fqwefwff> check my freenode sourcecode ULTRA GPL FREE EVEN LINUS TORVALDS APPROVED 100%: https://pastebin.com/7SMJW1JM
06:51:13 <fqwefwff> check my freenode sourcecode ULTRA GPL FREE EVEN LINUS TORVALDS APPROVED 100%: https://pastebin.com/7SMJW1JM
06:51:59 <merijn> Yeah...that's not a suspicious link at all
06:52:17 <sulemankm> Hi everyone! Can anyone plz let me know why do we have monads?
06:52:41 <fqwefwff> because my open source code it just released
06:52:42 <fqwefwff> check my freenode sourcecode ULTRA GPL FREE EVEN LINUS TORVALDS APPROVED 100%: https://pastebin.com/7SMJW1JM
06:53:03 <barrucadu> "Linux Torvalds approved"
06:53:06 <barrucadu> Now there's a review
06:53:10 <ventonegro> haha
06:54:40 <c_wraith> sulemankm: You're probably asking the wrong question.  You probably want to just learn haskell.  "Monads" aren't necessary or helpful in that process.  On the off chance you actually mean the question you're asking, https://stackoverflow.com/questions/28139259/why-do-we-need-monads/ has some useful answers.
06:54:52 <texasmynsted> anybody use lushtags and tagbar with vim to navigate Haskell tags, that has it working?
07:10:00 <ertes-w> merijn: i don't see any real difficulty in implementing a generalised diff using pretty much the same algorithms you would use for one-dimensional data
07:10:09 <ertes-w> merijn: but no, i'm not aware of anything ready-made
07:14:07 <akr> Hello, can anyone tell me which extension does the following pattern come from: `Just{}`
07:14:22 <merijn> akr: No extension
07:14:28 <merijn> akr: That's just standard Haskell
07:14:33 <akr> oh, hm
07:14:41 <merijn> akr: It's just record syntax
07:15:17 <akr> so it's the same as `Just _`?
07:15:23 <merijn> akr: Basically
07:16:11 <c_wraith> the only difference is that if Maybe ever changed the arguments to the Just constructor, it wouldn't need to be updated.
07:16:12 <akr> alright, thank you very much
07:16:25 <c_wraith> That seems exceptionally unlikely in the case of Maybe. :)
07:17:05 <merijn> c_wraith: You never know!
07:17:19 <c_wraith> should I make a libraries proposal?
07:17:39 <c_wraith> I've got a 100% success rate on getting library proposals adopted at the moment!
07:17:55 <c_wraith> ...  that would drop my success rate to 50%
07:20:38 <sulemankm> c_wraith: read the link you posted above.  It explains how a funcion g which returns a Maybe type would be composed with a normal function f() and the monad is supposed to provide the glue.  I wonder if that is that the sole purpose of the monads?
07:23:53 <sulemankm> c_wraith: read the link you posted above.  It explains how a funcion g which returns a Maybe type would be composed with a normal function f() and the monad is supposed to provide the glue.  I wonder if that is that the sole purpose of the monads?
07:25:44 <merijn> Whoo! My tests and shit all finally work and pass...now I just need to cleanup the godawful mess I made getting to this point...
07:26:31 <halogenandtoast> If I have two functions that return an IO (Maybe Text) and I want to basically get back an IO [(Something, Text)] what would be the best way to do that?
07:27:13 <merijn> halogenandtoast: You already have the something?
07:27:41 <halogenandtoast> merijn: yes it's hardcoded
07:27:54 <halogenandtoast> basically I'm grabbing video sources from an HTML video tag
07:27:59 <merijn> halogenandtoast: fmap fromMaybe?
07:28:08 <merijn> eh, no "maybe"
07:28:27 <halogenandtoast> :t maybe
07:28:29 <merijn> :t maybe [] (\x -> [(True, x)]
07:28:30 <lambdabot> b -> (a -> b) -> Maybe a -> b
07:28:31 <lambdabot> error:
07:28:31 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
07:28:37 <merijn> :t maybe [] (\x -> [(True, x)])
07:28:40 <lambdabot> Maybe b -> [(Bool, b)]
07:28:50 <merijn> Replace True with something and fmap over IO
07:29:16 <halogenandtoast> okay I'll try something like that around those lines
07:29:32 <merijn> Or, I suppose maybeToList
07:30:07 <merijn> :t maybeToList . fmap ((,) True) <$> (return () :: IO ())
07:30:09 <lambdabot> error:
07:30:09 <lambdabot>     • Couldn't match type ‘()’ with ‘Maybe b’
07:30:09 <lambdabot>       Expected type: IO (Maybe b)
07:30:21 <merijn> eh
07:30:26 <serses> if haskell is so great how come no one use it?
07:30:29 <merijn> :t maybeToList . fmap ((,) True) <$> (return (Maybe ()) :: IO (Maybe ()))
07:30:31 <lambdabot> error:
07:30:31 <lambdabot>     • Data constructor not in scope: Maybe :: () -> Maybe ()
07:30:31 <lambdabot>     • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
07:30:38 <merijn> I suck at typing today
07:30:55 <ventonegro> Is Friday troll day?
07:31:29 <merijn> ventonegro: Every day is troll day
07:31:32 <serses> i'm not trying to troll just state the obvious
07:31:50 <halogenandtoast> serses: the people in this channel use it
07:31:56 <halogenandtoast> the people in this channel != no one
07:32:02 <halogenandtoast> Your math is off
07:32:03 <ventonegro> halogenandtoast: Nooooooooooooooooooooooooo
07:32:09 <serses> no, ur math is off
07:32:19 <serses> i don't use it but still im in the chat
07:32:32 <merijn> halogenandtoast: Don't waste your time
07:32:39 <halogenandtoast> Yup
07:32:51 <serses> anyway lisp or haskell?
07:32:55 <serses> for beginners
07:33:08 <halogenandtoast> どちもいい
07:33:17 <Psybur> serses, HTML
07:33:42 <serses> that isn't a language is a syntax
07:33:55 <halogenandtoast> the L stands for Language
07:34:16 <ventonegro> You people are like sitting ducks for trolls
07:34:40 <merijn> ventonegro: People are bored, since there's no questions :p
07:34:57 <serses> which haskell to install on linux?
07:34:58 <merijn> Which means they could be writing my tests for me instead!
07:35:22 --- mode: ChanServ set +o shapr
07:35:25 <serses> is there any IDE for the language?
07:35:26 <ventonegro> Quickly, Free monads vs MTL: Discuss
07:35:33 <shapr> ventonegro: good call
07:36:01 <shapr> serses: I'm using stack
07:36:08 <shapr> hoi tromp!
07:36:11 <merijn> I've got a better one: Does the detailed-1.0 test type actually work in cabal 2.x?
07:36:18 <halogenandtoast> ventonegro: Free Monads
07:36:32 <halogenandtoast> but I don't understand either very well yet.
07:37:01 <ventonegro> halogenandtoast: Have you seen the latest posts on Reddit?
07:37:13 <halogenandtoast> looking
07:37:21 <serses> shapr: thanks
07:37:33 --- mode: shapr set -o shapr
07:37:40 <halogenandtoast> ventonegro: this? A tale of two Monads: Free vs MTL
07:37:57 <ventonegro> halogenandtoast: The harmful free monads one
07:38:05 <ertes-w> serses: stack is not an IDE though, so you still need an editor to use it
07:38:18 <ertes-w> serses: emacs and vim come to mind as obvious candidates
07:38:19 <ventonegro> https://markkarpov.com/post/free-monad-considered-harmful.html
07:38:26 <halogenandtoast> ventonegro: I haven't
07:38:33 <ventonegro> And then the other one
07:38:45 <serses> Ye but vim and emacs are waste of time, i want to learn haskell not some editor lang
07:39:02 <ertes-w> serses: you can use any text editor you like
07:39:27 <halogenandtoast> use the microsoft one, it has decent haskell support that is easy to install
07:39:49 <brynedwards> halogenandtoast: vscode?
07:39:54 <halogenandtoast> yeah
07:41:03 <halogenandtoast> I mean it's no vim, but it'll do for plebs
07:41:06 <tromp> hi @shapr
07:41:07 <serses> does anyone know a good haskell book?
07:41:30 <halogenandtoast> serses: my favorite: http://www.cs.nott.ac.uk/~pszgmh/pih.html
07:41:42 <brynedwards> @where learnhaskell
07:41:43 <lambdabot> https://github.com/bitemyapp/learnhaskell
07:41:51 <halogenandtoast> I suggest avoid lyah
07:41:52 <rfmind> Learn you a haskell for great good
07:41:55 <callmecabman> serses: LYAH, RWH, PCH
07:42:02 <brynedwards> also haskellbook.com ...
07:42:09 <halogenandtoast> *avoiding
07:42:25 <serses> thanks
07:42:40 <halogenandtoast> No one ever links the book I linked, but having read them all, I think it is far superior
07:43:17 <callmecabman> halogenandtoast: Graham Hutton hm. It's pretty new I see.
07:43:32 <axis_of_adam> halogenandtoast: sorry i came in after you gave a book recommendation, what was it?
07:43:33 <ertes-w> it's a new edition of an older book
07:43:55 <ertes-w> basically updating it to modern haskell
07:43:59 <halogenandtoast> axis_of_adam: http://www.cs.nott.ac.uk/~pszgmh/pih.html
07:44:09 <axis_of_adam> ty
07:44:13 <halogenandtoast> no problem
07:44:45 <mnoonan> tromp: we haven't met before, but I wanted to say thanks for inventing my favorite Go rule set *and* my favorite IOCCC entry :)
07:45:04 <ristos> nice, it looks like pih has some recs from some notable figures
07:45:07 <halogenandtoast> I basically like the fact that all the examples are relevant and aren't some funny-named methods designed to make the reader "interested"
07:45:55 <ristos> I think the biggest hurdle with learning haskell is that you're learning category theory and the type system at the same time. If you're tring to grok one, you have to grok the other at the same time
07:45:56 <halogenandtoast> and they do a great job of showcasing lazy programming
07:45:58 <ventonegro> I ordered PIH for my company's library and nobody was curious enough to pick it up. The Universe sucks.
07:46:12 <halogenandtoast> ventonegro: womp womp
07:46:20 <ertes-w> i'd like to review PIH
07:46:36 <callmecabman> halogenandtoast: that's what I dislike in LYAH, it's great for total newbies but for a CS specialist reading it is painful
07:46:44 <ertes-w> while i have a lot of faith in it, i don't like to give blind recommendations
07:47:03 <ristos> lyah is an intro book though
07:47:15 <ristos> none of them really cover advanced topics as far as I can tell
07:47:16 <ertes-w> but i have so many issues with HPFFP that i can't bring myself to recommend it
07:47:25 <ertes-w> even though some aspects of it are good
07:47:31 <halogenandtoast> ertes-w: I agree on HPFFP
07:47:37 <ristos> whats hpffp?
07:47:43 <brynedwards> Interesting that PIH is only 318 pages whereas HPFFP one is over 1000
07:47:46 <ertes-w> ristos: you may know it as "haskellbook"
07:47:48 <brynedwards> ristos: haskellbook.com
07:48:06 <piyush-kurur> anyone knows how to get an import Foo line in a coq extracted Haskell file?
07:48:07 <ristos> yeah
07:48:13 <merijn> brynedwards: Haskell Book is also rather slow, and covers more topics
07:48:23 <ristos> it covers transformers at least
07:48:24 <callmecabman> don't you know an advanced book about Haskell?
07:48:25 <halogenandtoast> brynedwards: PIH assumes you know what programming is.
07:48:37 <halogenandtoast> even though it says it doesn't
07:48:42 <merijn> halogenandtoast: Haskell Book isn't great for non-programmers, IMO
07:48:49 <ristos> but 1000 pages though, it would take forever to get through
07:48:49 <brynedwards> I guess I should've gone with PIH then
07:49:27 <merijn> halogenandtoast: It focuses too much on things that aren't very interesting for people who don't know programming and puts of some important things that should be way earlier, imo
07:49:48 <ventonegro> I honestly enjoyed the "haskell book", mostly because of monad transformers which were still mystical to me
07:50:08 <ventonegro> Like, "WTF they are inside-out"
07:50:20 <ristos> I hope some day there's a good comprehensive learning material for haskell that isn't a book that you have to read front to back
07:50:24 <axis_of_adam> is haskell book a good second book on the language?
07:50:35 <halogenandtoast> axis_of_adam: in my opinion no
07:50:40 <merijn> axis_of_adam: I think it's probably better as 2nd book than first
07:51:01 <halogenandtoast> I think I would just read select chapters
07:51:04 <merijn> axis_of_adam: I suppose it also depends on *which* first book :)
07:51:09 <ventonegro> Now I want a book on lenses/optics
07:51:11 <halogenandtoast> the lambda Calculus one is interesting, but only with context first.
07:51:34 <ristos> yeah, none of the books cover a lot of the stuff people use all the time, like lenses
07:51:42 <axis_of_adam> merijn: well i started with lyah, but it isn't really geared to people who know how to program and just want to learn haskell
07:51:44 <callmecabman> ventonegro: try artyom.me
07:51:49 <merijn> ristos: Honestly, I still don't really use lenses
07:52:08 <axis_of_adam> so i'm thinking about reading PIH
07:52:25 <merijn> axis_of_adam: How masochistic are you? i.e., ever spend any amount of time reading the C/C++ specs?
07:52:46 <ristos> yeah but you should at least know what people are referring to when the talk about optics, free monads/whatever else, comonads, coproducts, coroutines, etc
07:52:51 <axis_of_adam> merijn: do IANA or IETF RFCs count?
07:52:54 <halogenandtoast> merijn: is that a metric of masochism?
07:53:22 <merijn> halogenandtoast: eh...yes? Have you seen the damn things? They're inpenetrable for no damn reason
07:53:30 <merijn> axis_of_adam: meh...those are usually quite readable
07:53:34 <axis_of_adam> merijn: or anything from the ACM digital library?
07:53:38 <ventonegro> ristos: Oh yeah, all the co- stuff too... I need a book on that
07:53:39 <halogenandtoast> I've read a C spefification at some point
07:53:48 <halogenandtoast> except spelled correctly
07:53:55 <callmecabman> ventonegro: can you be more specific please?
07:54:03 <halogenandtoast> but not C++, that sounds dangerous
07:54:10 <merijn> axis_of_adam: There's the "tutorial" which is geared at people who already know the basics of functional programming and the Report (which is actually quite readable)
07:54:11 <axis_of_adam> i don't necessarily enjoy spending a couple hours on a 14 page paper, but i can do it
07:54:25 <axis_of_adam> links?
07:54:29 <merijn> @where tutorial
07:54:29 <lambdabot> http://www.haskell.org/tutorial/
07:54:32 <ventonegro> callmecabman: comonads, codata, corecursion, co-...
07:54:33 <ristos> does anyone else think that taking 12 weeks to learn what monads (up to them) is way too long?
07:54:34 <merijn> @where report
07:54:34 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
07:54:46 <halogenandtoast> Just wondering, but I started reading the Category theory book by bartowsz, worth it?
07:55:04 <halogenandtoast> *Bartosz
07:55:08 <callmecabman> ventonegro: google a paper by Jacobs and Rutten "A tutorial on coalgebras and coinduction"
07:55:15 <callmecabman> halogenandtoast: absolutely!
07:55:19 <ventonegro> callmecabman: Ah ha, thanks!
07:55:24 <merijn> axis_of_adam: Be warned, though
07:55:34 <merijn> @quote Brend gentle.intro
07:55:34 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
07:55:54 <halogenandtoast> okay time for sleep, more haskell tomorrow
07:56:07 <merijn> halogenandtoast: Depends on why you're reading it :)
07:56:18 <halogenandtoast> axis_of_adam: read PIH and if you don't like it tell me.
07:56:29 <halogenandtoast> merijn: to write my own compilers :\
07:56:32 <callmecabman> ventonegro: also try "Codata and comonads in Haskell" by Kieburtz, "Should I use a monad or a comonad" by Dominic Orchard
07:56:33 <halogenandtoast> speaking of masochism
07:56:40 <merijn> halogenandtoast: Oh, absolutely useless then
07:56:53 <merijn> halogenandtoast: If you wanna write compilers, grab Types and Programming Language by Pierce
07:56:53 <ventonegro> callmecabman: I'm gonna create a bookmark folder :)
07:56:58 <halogenandtoast> merijn: yes, that was my takeaway.
07:57:09 <merijn> halogenandtoast: Far easier to read and with lots of examples and useful things
07:57:10 <edwardk> the kieburtz paper is good, just skip the OI stuff at the end
07:57:12 <halogenandtoast> merijn: I have it, I just wish the digital copy wasn't amazon editions
07:57:16 <codedmart> My hoogle fu is eluding me. I am looking for something along the lines of `(a -> b) -> (a, a) -> (b, b)`.
07:57:30 <edwardk> :t join bimap
07:57:30 <callmecabman> ventonegro: I have a goddamn folder for whitepapers because there are many topics not covered even in blog articles not mention books
07:57:32 <lambdabot> Bifunctor p => (c -> d) -> p c c -> p d d
07:57:39 <edwardk> codedmart: ^-
07:57:39 <halogenandtoast> aww edwardk beat me to it
07:57:44 <codedmart> Thanks!
07:57:45 <merijn> halogenandtoast: If the goal is "write compiler" I'd say skip the CT stuff by Bartosz for later
07:57:59 <halogenandtoast> merijn: no, that was my goal when reading the C spec
07:58:04 <halogenandtoast> I was young and naive
07:58:33 <halogenandtoast> Now I'm just reading the CT stuff for fun, and hoping it will impact my Haskelling somehow
07:58:34 <merijn> I get the edwardk and all his fancy category, coyoneda, free transformers, optics, and shit sounds hip to people. But here I am writing all of my Haskell without all that stuff and being quite happy :)
07:58:35 <codedmart> @edwardk Thanks!
07:58:35 <lambdabot> Unknown command, try @list
07:59:03 <halogenandtoast> codedmart: this is not Slack
07:59:05 <halogenandtoast> :p
07:59:05 <merijn> Hell, probably 80% of my Haskell is just slinging IO around everywhere and it's super nice :)
07:59:06 <edwardk> merijn: its okay, it'll all still be here when you decide you're interested ;)
07:59:15 <callmecabman> halogenandtoast: anyway his CT lectures are quite interesting, they can make you click on some topics so you'll be able to read some real CT stuff
07:59:24 <merijn> edwardk: I'm interested, but I don't have the time to wade through all the stuff ;)
07:59:28 <codedmart> halogenandtoast: Ah right sorry. Habit.
07:59:48 <halogenandtoast> codedmart: I just recently found out slack has IRC like tab complete now
07:59:54 <merijn> edwardk: Because I still haven't found a decent CT intro to understand all those blogposts :p
07:59:59 <edwardk> merijn: i always figure there is a cost to using the wrong abstraction. integrating that cost over ones entire career... ;)
08:00:05 <halogenandtoast> so you can type a name without an @ and tab complete it
08:00:21 <codedmart> Hmm good to know. Didn't realize that.
08:00:31 <callmecabman> merijn: go Catsters into Bartosz into Awodey into MacLane
08:01:19 <merijn> I've read a lot of Bartosz' posts, but half of it I already understand, the other half is too vague. I started Awodey (a few times), but it was clearly not written for people like me
08:01:34 <edwardk> the catsters videos are fantastic in that they show you a bit of how 'category theory is done' that a dead tree book fails miserably at. e.g. a diagram after it has been drawn is almost a dead, near useless thing. It is the process of drawing the diagram and pasting it together that is the informative part
08:01:48 <merijn> All the examples are math, whereas I'm sitting here going "I just wanna know enough CT to read the hip new type theory papers"
08:02:23 <merijn> Anyway, I haven't time for this in ages anyway
08:02:25 <ristos> the abstract algebra stuff seems a lot easier to grok, you can just read the wikipedia articles :P
08:02:44 <c_wraith> sulemankm, monads don't have a "purpose". they are an observation that a bunch of things have some similar properties. using monads in programming is about acknowledging those properties.
08:04:46 <kuribas> I have an idea for an optional argument library: if you have a datatype OptArgs = {_a :: A, _b :: B} and defaultArgs = {a = defaultA, b = defaultB}, then there is some template haskell that generates "a :: A -> Option OptArgs", "b ::  B -> Option OptArgs", where Option a is a monoid.
08:05:38 <kuribas> How could you document the Option functions with haddock?
08:06:02 <kahlil29> the Opaleye like and ilike function signatures are `Column PGText -> Column PGText -> Column PGBool`. how are they used? do we have to use 4 'like' calls within a restrict? 
08:06:34 <c_wraith> sulemankm, however, you are on the right path with "is that all"? The hype around monads is baffling. they aren't anything amazing. they're just different. this is why I keep saying learning about them isn't necessary or helpful for learning haskell.
08:07:10 <serses> how do I print a function with 2 arguments? for example i have " print doubleNumbers 2 2" but doesn't work
08:07:31 <mnoonan> print (doubleNumbers 2 2)
08:07:49 <serses> thanks lol
08:08:38 <mnoonan> print doubleNumbers 2 2 is trying to pass the three arguments { doubleNumbers, 2, 2 } to print
08:08:49 <Psybur> Could also do print $ doubleNumbers 2 2
08:09:01 <serses> yes, i get an error about the numbers of args
08:09:10 <callmecabman> edwardk: do you know where to see some cool CT-foo like Catsters? I'm not much into CT by myself but I absolutely love to read up on some stuff ala Tom Leinster's categorification of the good old stuff.
08:09:14 <tromp> thx @mnoonan !
08:09:34 <edwardk> there are a couple of videos by awodey on the net iirc
08:10:18 <kuribas> how do you document TH generated functions?  For example lenses?
08:10:30 <edwardk> kuribas: sadly you don't
08:11:38 <edwardk> they sort of neglected to give us a hook to add haddocks via TH
08:12:31 <kuribas> :(
08:21:00 <callmecabman> I used to use wreq package for a project and it was awesome. But some guys have just shielded their site by freaking CloudFlare and now i'm in jeopardy. Can you recommend some headless Haskell browsers or inline js interpreters?
08:21:26 <serses> yeah, IE
08:21:31 <inkbottle> [noob] Have the two columns (last 3 rows) the exact same semantic: https://wiki.haskell.org/Declaration_vs._expression_style#Syntactic_elements
08:21:46 <shapr> serses: be nice
08:22:36 <serses> shapr: ok
08:23:51 <callmecabman> hs-webdriver is the most recent one but Travis tells me it fails to build and I don't wanna open the can of worms blindly
08:24:04 <brynedwards> callmecabman: um, this might be useful https://www.reddit.com/r/haskell/comments/71za1t/ann_nodejseval_execute_nodejs_scripts_in_haskell/
08:24:28 <michalrus> Why does Wai just throw random `error "string"`. ;( Eh. https://github.com/haskell-servant/servant-multipart/issues/9
08:24:56 <callmecabman> brynedwards: thanks a lot, gonna look into it
08:28:02 <jle`> inkbottle: i believe so, except the typechecker does make some performance optimizations that make the two 'practically' different
08:28:30 <jle`> @where dmr
08:28:30 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
08:28:37 <jle`> ^ inkbottle 
08:28:45 <jle`> I believe that's the only potential difference
08:29:17 <inkbottle> jle`: OK, thanks
08:30:05 <jle`> np
08:33:03 <serses> can I apply do something like "tail last [1,2,3,4]" to a list?
08:33:24 <shapr> you'd need parentheses
08:33:31 <shapr> > tail (last [1,2,3,4])
08:33:34 <lambdabot>  error:
08:33:34 <lambdabot>      • No instance for (Num [()]) arising from a use of ‘e_11234’
08:33:34 <lambdabot>      • In the expression: e_11234
08:33:43 <shapr> > last [1,2,3,4]
08:33:46 <lambdabot>  4
08:34:10 <shapr> and your types won't work, last returns the last element
08:35:03 <serses> shapr: yeah thanks i meant last init 
08:36:20 <shapr> serses: yeah, that would work, with the parens
08:37:47 <edwardk> kuribas: you could always write a code generator in your Setup.hs and then have it spit out extra files you pick up later...
08:37:50 <edwardk> oh kuribas left
09:16:55 <inkbottle> is "weak head normalization strategy" exact synonymous to "lazy evaluation"?
09:22:23 <[exa]> inkbottle: do you have a definiton of "weak head" ?
09:23:02 * Psybur is really struggling to hold it back
09:25:16 <inkbottle> [exa]: there is one there https://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR581
09:25:35 <[exa]> oh, found a paper about it
09:26:42 <[exa]> Biernacka, Danvy, Stolving: Program extraction from proofs
09:26:43 <[exa]> of weak head normalization
09:27:40 <inkbottle> there too https://www.irif.fr/~krivine/articles/Lambda.pdf
09:28:57 <[exa]> Psybur: btw lol
09:29:42 <[exa]> inkbottle: according to danvy paper it works on weak-head normal forms just as leftmost strategy on normal forms, on STLC
09:29:44 <nshepperd_> weak (head normalization)
09:30:21 <inkbottle> STLC?
09:30:32 <[exa]> simply typed lambda calculus
09:30:36 <inkbottle> ok
09:31:46 <[exa]> but it doesn't seem equal, lazy evaluation is afaik defined as "leftmost abstraction first", this is defined as "leftmost non-closed abstraction first", and well, it should produce different normal form
09:31:48 <nshepperd_> I think "lazy evaluation" normally implies sharing of results. Ie. call-by-need
09:33:16 <[exa]> ok maybe it will be better to wait for someone who knows dark magic
09:33:22 <barrucadu> I thought "lazy evaluation" required sharing
09:33:29 <barrucadu> If you don't have sharing it's just "non-strict"
09:34:31 <[exa]> barrucadu: 'lazy evaluation strategy' means afaik something else in LC terms
09:34:58 <[exa]> (and there's no sharing)
09:35:23 <[exa]> maybe I'm thinking too far from actual haskell
09:35:29 <Athas> So, using Haskeline, what's a good way to get persistent history in a portable way?
09:35:49 <Athas> Do I really need to do the XDG_CONFIG stuff by hand (and SPJ knows what on Windows/macOS)?
09:37:01 <inkbottle> I think the book of Chris Allen says Haskell strategy is WHN strategy, that's why I hypothesized it is so; But I haven't found confirmation yet
09:37:37 <inkbottle> Also WHN strategy is very well defined, in academical papers
09:39:50 <Psybur> Which haskell book is for the reader who doesn't necessarily want to learn to write better haskell, but to have their mind blown apart
09:41:20 <inkbottle> Psybur: was that a question or a statement about some previous thing?
09:41:33 <Psybur> inkbottle, no, its a new question
09:41:51 <Psybur> inkbottle, s/no,//
09:42:48 <monochrom> Oh, that's the job of LYAH :)
09:43:07 <Psybur> monochrom, already read it
09:43:10 <[exa]> yeah they have pictures
09:43:35 <Psybur> Think my mind needs more of a beating
09:43:35 <monochrom> Well, mind-blowing is not guaranteed. Conditions apply.
09:43:59 <[exa]> Psybur: for beating read the HoTT book
09:44:29 <monochrom> OK so how about Richard Bird's «Thinking Functionally»?
09:44:33 <Psybur> https://homotopytypetheory.org/book/ ?
09:44:52 <[exa]> Psybur: but still probably not very much "mind blown"
09:45:04 <Psybur> https://www.amazon.com/Thinking-Functionally-Haskell-Richard-Bird/dp/1107452643 ?
09:45:10 <monochrom> «Thinking Functionally with Haskell»
09:45:17 <[exa]> someone could rewrite 'art of unix programming' to haskell
09:45:42 <monochrom> I didn't buy it when it was 25% cheaper. Now I'm beating myself.
09:45:48 <inkbottle> Psybur: "The goal of this article is to present a one-pass transformer into monadic normal forms" in http://www.brics.dk/RS/02/52/BRICS-RS-02-52.pdf
09:46:33 <inkbottle> say if you need more beating after that
09:46:59 <monochrom> What is "beating" anyway?
09:47:55 <inkbottle> don't know just repeating words I've just read
09:47:59 * maerwald tries to suppress a moms joke
09:48:04 <Psybur> :}
09:50:23 <maerwald> I wouldn't go for beating anyway, it will just show you things you shouldn't do yourself in real world
09:53:59 <Psybur> maerwald, who likes real world though
09:54:09 <Psybur> I make it a habit of never going there
09:54:12 <Psybur> 'tis a silly place
09:56:06 <Psybur> inkbottle, seems I can't quite grasp enough of that article for there to be any transformative effects on my mind ;_;
09:56:39 <inkbottle> What do you think of "Haskell Programming from First Principles"?
09:57:04 <inkbottle> Psybur: are you kidding, you didn't even spent 20 hours on it yet
09:57:59 <Psybur> inkbottle, I'm lazy :D
09:58:06 <Psybur> inkbottle, havent read that book
09:59:00 <inkbottle> did you heard comments about it?
10:00:33 <Psybur> inkbottle, I've heard that its supposed to be a good book. Sixty ballers though man, a bit steep :D
10:00:49 <inkbottle> sure
10:07:06 <solV3d> http://lpaste.net/358796
10:07:14 <solV3d> can i simplify that?
10:12:56 <Psybur> solV3d, I think you could just do andGate = Gate (&&)
10:13:07 <Psybur> And get rid of f
10:13:27 <solV3d> oh ye^^
10:13:28 <solV3d> thanks
10:13:35 <Psybur> @let data Gate = Gate (Bool -> Bool -> Bool)
10:13:37 <lambdabot>  Defined.
10:13:48 <Psybur> :t Gate (&&)
10:13:50 <lambdabot> Gate
10:14:27 <Psybur> > print $ Gate (&&)
10:14:29 <lambdabot>  error:
10:14:30 <lambdabot>      • No instance for (Show Gate) arising from a use of ‘print’
10:14:30 <lambdabot>      • In the expression: print $ Gate (&&)
10:14:36 <Psybur> D;
10:18:48 <solV3d>  parse error on input `='
10:19:16 <solV3d> oops sorry
10:20:07 <solV3d> i am trying to build a custom comparison between gates
10:20:35 <solV3d> http://lpaste.net/358798
10:20:52 <solV3d> line 8 should be False False
10:22:48 <solV3d> Couldn't match expected type `Gate' with actual type `Bool'
10:23:02 <solV3d> so my understanding was that i can compare the results of two gates
10:25:52 <Psybur> solV3d, the result of two gates is a Bool, which is already Eq
10:26:25 <geekosaur> solV3d, you defined Gate as a function, it can't be directly compared. Also a Gate is not simply a Bool, it is a function wrapped in a data constructor
10:26:46 <geekosaur> the result of applying a Gate can be compare dalready. there is no way to define Eq on functions, so Gate itself cannot be Eq
10:27:20 <solV3d> how is gate a function ?
10:28:14 <geekosaur> Gate (Bool -> Bool -> Bool)
10:28:30 <geekosaur> what do you believe this is?, given it has two function arrows in it?
10:28:54 <geekosaur> it is a wrapper around a function. doing anything with it will involve uwrapping it, which leaves you with a function.
10:29:03 <Psybur> solV3d, https://glot.io/snippets/eu2z8cal55
10:29:21 <geekosaur> for Eq, there is nothing other than the function to work with, and functions cannot be compared or tested for equality
10:31:39 <Psybur> solV3d, To hammer the point in even better https://glot.io/snippets/eu2zas87bp
10:33:46 <Psybur> Realized I just left andGate floating in space ;p https://glot.io/snippets/eu2zd0i6md
10:35:10 <solV3d> hm thanks, i try to understand this now^^
10:38:24 <Psybur> solV3d, even more hammering :D https://glot.io/snippets/eu2zhn9hl4
10:42:51 <solV3d> its weirds, its even an exam task
10:42:59 <solV3d> to implement Eq for Gate
10:43:15 <solV3d> or better, make Gate a member of Eq
10:46:26 <nshepperd_> You can build the table of the function, and compare those for equality. Ie. Exhaustively check that f x == g x for all x in the domain
10:56:09 <saurabhnanda> error:ghc: panic! (the 'impossible' happened) -- No skolem info: k_a43OJ[sk] -- what next?
10:56:33 <saurabhnanda> second time I've caused the compiler to crash in a week!
10:56:40 <Psybur> solV3d, https://glot.io/snippets/eu2zzshy31
10:57:45 <Psybur> Thats changing the Gate type but thats the only way I can think of putting a gate in Eq.
11:00:52 <solV3d> ok thanks, i will try to understand whats going on here
11:01:27 <fishythefish> Psybur: why change the type? there are only 4 combinations of inputs to check
11:01:31 <solV3d> basically what i thought is this, i have two Gates, andGate, orGate and if I do something like andGate == orGate i want to change the implementation
11:01:34 <fishythefish> i.e. what nshepperd_ said
11:01:41 <solV3d> of  ==
11:02:09 <solV3d> so if GateA return False and GateB return True and would maybe return True on GateA == GateB
11:02:36 <fishythefish> you basically just need `gateA False False == gateB False False && ... && gateA True True == gateB True True`
11:02:42 <zachk> solV3d, you can define your own instance of Eq a where a is any type you want, just the instance declaration should make sense
11:03:16 <zachk> might want to wrap your Gate in a newtype to get Eq a to work 
11:04:07 <fishythefish> isn't it data Gate already?
11:04:36 <solV3d> the task is to (re) implement the Eq implematation
11:05:38 <fishythefish> well, there have already been a couple of explanations of how to implement the logic. is it writing an instance you're confused about?
11:06:14 <solV3d> http://lpaste.net/358800
11:06:24 <solV3d> this is given, so i cannot change the Gate itself
11:06:32 <fishythefish> again, you don't have to
11:06:35 <fishythefish> see what nshepperd_ or I said
11:07:03 <solV3d> i thought this is what i did with my code
11:07:26 <solV3d> http://lpaste.net/358801
11:07:43 <fishythefish> no
11:07:49 <fishythefish> you need to be comparing two Gates, not two Bools
11:07:55 <solV3d> Hm ok
11:08:30 <solV3d> then i need to find the syntax now
11:08:31 <solV3d> thanks
11:08:42 <fishythefish> It should look something like (Gate f) == (Gate g) = ...
11:08:43 <fishythefish> implement the rhs
11:09:19 <solV3d> rhs?
11:09:24 <fishythefish> right hand side
11:09:27 <fishythefish> where the ... is
11:10:31 <greatgig1> hey, does anyone knows a good machine learning package?
11:10:34 <solV3d> i see
11:11:39 <solV3d> http://lpaste.net/358802
11:11:43 <solV3d> like so i guess
11:13:41 <fishythefish> Well, that implementation says that any two gates are equal
11:14:08 <fishythefish> You probably want it to evaluate f and g on all possible input combinations and base your result on that
11:14:29 <fishythefish> also note that you don't need to define both (==) and (/=)
11:15:44 <solV3d> well, no idea
11:15:46 <solV3d> nevermind, thanks
11:17:04 <Psybur> solV3d, https://glot.io/snippets/eu30k003o3
11:18:41 <solV3d> Psybur thank you!
11:19:49 <Psybur> solV3d, do you understand the code?
11:20:00 <solV3d> now that i read it, yes
11:20:48 <Psybur> solV3d, and you understand the difference between: True && True, and (&&) True True
11:21:06 <solV3d> that just infix and prefix isnt it
11:21:11 <Psybur> Yes
11:21:17 <solV3d> then i do
11:21:53 <Psybur> You could also make that code look like True `f` True if you want it to look more like the infix versions of the gate functions
11:23:29 <kaychaks> need some help with a `lens-aeson` error  mentioned along with the code here - http://lpaste.net/358787
11:28:14 <bsima> should I use xml-conduit or taggy for working with Atom feeds?
11:32:36 <geekosaur> kaychaks, I'm not an expert on this, but ... do you intend that this be `(js ^.. values) . nameAndAge`, or `js ^.. (values . nameAndAge)` ?
11:32:58 <geekosaur> What you wrote means the latter. You may have wanted the former; you ahve to use parentheses for that
11:45:47 <crucify_me> hi could people please look at this stackoverflow? the upvoted answer has a recent comment "this is downright false." I wondering if I should focus on the second answer. thanks
11:45:51 <crucify_me> https://stackoverflow.com/questions/1757740/how-does-foldr-work
11:53:48 <srhb> crucify_me: It's hard to find a way to justify "starts from the right", yes. I mean, it's a linked list after all. There's no way to get to the "right" (end) without going through all of it.
11:54:30 <srhb> crucify_me: Also, foldr can work over infinite lists (given compatible arguments) which should give another inkling that it cannot be true.
11:56:24 <crucify_me> srhb, thank you, your first comment above is what I need to work on. the part about infinite lists makes sense
11:56:42 <NemesisD> hi all, new to performance-based pragmas. i'm working on some code w/ a bunch of RULES pragmas https://github.com/ozataman/csv-conduit/blob/master/src/Data/CSV/Conduit/Conversion/Internal.hs#L28 and i get warnings the rule may never fire because it might inline. says i should either inline or noinline the function
11:56:57 <NemesisD> i'm not really sure which i should do...
11:57:43 <crucify_me> the next answer is very concise. Is that a good place to start ? (Im working through examples nicely on the 'zvon' site) srhb 
11:58:16 <srhb> crucify_me: Sure, if concise works for you. :)
11:58:44 <srhb> crucify_me: You might also want to look up the definition of foldr and work a few examples out by hand using that.
11:58:56 <srhb> That always seems to most straightforward path to understanding for me.
11:59:05 <srhb> (And it's mechanical, no matter the function you're examining)
12:05:57 <crucify_me> srhb, thanks ! also I've been looking at scanr which helps explain it
12:20:48 <crucify_me> srhb if you have time, why is the first commented definition included here: ' foldr _ z [] = z '  ?     it produces a non-exhaustive pattern. a bit confused there
12:20:56 <crucify_me> https://ptpb.pw/n7t1
12:21:18 <fishythefish> crucify_me you have to take all the patterns together
12:21:25 <fishythefish> the second one is non-exhaustive too; it doesn't handle an empty list
12:22:15 <fishythefish> when you call the function, it'll use the first matching pattern. it's only really a problem if none of the patterns match the input
12:22:22 <crucify_me> sorry that is a base case listed first there?
12:22:26 <fishythefish> yup
12:22:49 <crucify_me> sorry of course, my tea's just coming on. thanks !
12:22:51 <fishythefish> folding an empty list should just give you the initial accumulator value
12:23:09 <crucify_me> makes perfect sense thank you kindly
12:23:14 <fishythefish> no problem
12:23:34 <crucify_me> I have a caffeine problem
12:23:55 <fakenullie> don't we all
12:24:24 <kit__> > 1 + 1
12:24:27 <lambdabot>  2
12:24:46 <kit__> ^o^
12:30:27 <crucify_me> btw the definition says '( typically the right-identity of the operator) could anyone explain that ? why typically and does that mean the 'accumulator value' ? https://ptpb.pw/n7t1
12:32:13 <crucify_me> lpaste.net/358805 << better paste.
12:32:43 <fishythefish> e.g. the identity of (+) is 0, and 0 is typically your accumulator for summing
12:32:57 <fishythefish> it happens to be a two-sided identity because (+0) and (0+) are both the identity operation
12:33:19 <Psybur> http://planetmath.org/leftidentityandrightidentity
12:33:21 <fishythefish> basically, your accumulator is typically the value such that folding [x] just gives you x
12:33:45 <crucify_me> fishythefish, in the case of (/), does that not hold true?
12:33:55 <Psybur> No
12:34:22 <crucify_me> yeah division is what is confusing me with this function
12:34:30 <Psybur> 1 / 100 vs 100 / 1
12:37:12 <crucify_me> thanks Psybur fishythefish
12:37:22 <fakenullie> Are there operators without identity?
12:39:21 <Psybur> fakenullie, if you make an operator that multiplies your value by a random number sure :D
12:40:05 <crucify_me> fakenullie, Psybur does (/) have identity. ?  
12:40:34 <crucify_me> I understand the random number possibility
12:40:34 <Psybur> Yeah /1
12:40:51 <crucify_me> ok right same as (*)
12:41:16 <fakenullie> / has only right identity
12:41:37 <crucify_me> right ok there's my answer duh! fakenullie 
12:41:45 <crucify_me> thanks!
12:42:17 <crucify_me> sometimes its just English that I cannot get. I should stop reading about it unless its code
12:43:10 <fakenullie> Ok, natural numbers without 0 have no identity for addition
12:43:53 <crucify_me> identity is important in category theory. I can't wait until I get my head around it
12:44:29 <crucify_me> natural numbers without 0 ?
12:45:23 <fakenullie> Yeah, definitions of natural numbers do not include zero
12:45:32 <fakenullie> Some definitions
12:47:04 <crucify_me> thanks more drama later
12:51:01 <crucify_me> fakenullie, sorry one thing so I'm certain: (-) also is only right identity, right?
12:51:27 <fakenullie> Yeah, I think so
12:51:54 <fakenullie> ^ too
12:51:55 <crucify_me> thanks just forcing my brain to learn right now.
12:52:16 <crucify_me> right good call
13:12:50 <Anton-weekday> \Q
13:25:14 <saurabhnanda> GHCi is consistently crashing on my while loading a particular file. Is there any way to debug this?
13:27:02 <saurabhnanda> why doesn't it give any meaningful message to help debug? Even Mac OSX crash report have more details than this.
13:27:31 <saurabhnanda> No skolem info. What?
13:29:18 <geekosaur> saurabhnanda, you really need to ask that in #ghc or, probably better, the glasgow-haskell-users mailing list
13:29:28 <saurabhnanda> geekosaur: thanks. will do.
14:06:53 <c_wraith> if a monad is a monoid in the category of endofunctors, does that make an indexed monad a category in the category of endofunctors?
14:19:23 <pikajude> well, clearly
14:19:38 <AManHasNoUName> Clearly.
14:22:19 <bsima> does anyone know where this `stripNamespace` function comes from? https://stackoverflow.com/a/10876086/1146898
14:22:28 <bsima> hoogle and stackage turn up zero results
14:23:40 <boj> i think it is an imaginary function demonstrating what the commentor would do
14:24:02 <bsima> ah
14:46:19 <AManHasNoUName> Anyone else go to this Haskell Discord server? https://discord.gg/wVSJUY5
14:54:48 <glguy> AManHasNoUName: No, no one does
15:00:24 <hexagoxel> is 'GHC.Types.LiftedRep == *  ?
15:01:17 * hexagoxel should have asked in #ghc..
15:02:16 <monochrom> No, TYPE LiftedRep is
15:03:21 <monochrom> Look for "Levity polymorphism" in the GHC Users Guide
15:11:18 <pikajude> we like to encourage levity in the haskell community
15:11:56 <MarcelineVQ> almost wore my coffee just there
15:17:21 <boj> MarcelineVQ: :o
15:17:46 <maerwald> MarcelineVQ: hi
15:18:17 <MarcelineVQ> hello
15:25:20 <jle`> c_wraith: sounds right to me
15:25:54 <jle`> indexed applicatives too, it seems
16:13:11 <rudol> this code at http://lpaste.net/358809 for effectively just pulling digits (actually Strings) out of an environment that happens to be in a StateT to create numbers seems inelegant. I feel like I'm missing something.
16:15:28 <n_blownapart> head (scanr (*) 10 [2,3,4]) == foldr (*) 10 [2,3,4]      strange this is the closest I've come to find the definition of scanr. hoogle has only the signature for it. could someone direct me to the func definition please?
16:16:04 <n_blownapart> I don't know how to use hoogle very well yet
16:16:27 <n_blownapart> I have a general understanding of what both functions do
16:18:22 <lyxia> rudol: why do you need state
16:18:56 <lyxia> n_blownapart: the definition of scanr?
16:19:40 <rudol> it is actually a cut down version of a more interesting example that builds a simple logic engine (from the "All About Monads" article). 
16:19:44 <n_blownapart> yeah I couldn't find it anywhere lyxia
16:20:01 <rudol> example24.hs, in particular.
16:20:25 <n_blownapart> foldr is everywhere. I guess I'm missing a point.
16:20:29 <rudol> It demonstrates the use of StateT and [] for non-determinism and state
16:21:05 <lyxia> n_blownapart: hoogle scanr, click on it, click on source, https://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.List.html#scanr
16:21:35 <n_blownapart> ok thanks a lot
16:21:45 <glguy> rudol: I annotated your paste
16:21:57 <glguy> You don't need any StateT or [] backtracking
16:22:30 <glguy> Your example wasn't actually demonstrating the functionality of either of the two
16:22:54 <rudol> Both Var and Value types are aliases for String. It is very a very neat and illustrative example
16:23:26 <rudol> but I am trying to adapt it to solve SEND+MORE=MONEY
16:24:23 <rudol> so, I need to jump through a few extra hoops due to the simplistic use of Strings for the env
16:24:35 <rudol> glguy - thank you
16:24:48 <glguy> rudol: You don't need any of the computations in this paste to know about your StateT business
16:25:46 <rudol> glguy: that was my gut feeling too. But I didn't find a way yet to abstract that back to that level, as you have shown.  
16:27:12 <rudol> so, presumably, I just need to lift your functions to work in the StateT, is that the right way to think?
16:31:01 <rudol> glguy: why do you need the $! here?
16:32:31 <Wizek> Hello. On windows, if during build I am told `Missing C library: xyz` since `extra-libraries: xyz` is specified in the .cabal file, how could I begin to satisfy the said package? I've tried `include-dirs:`, `--extra-lib-dirs=C:/abs/path/to/libxyz`, and similar, to no avail so far.
16:39:23 <zachk> wizek, I have had decent luck with msys2 on building stuff on windows
16:41:59 <Wizek> zachk: yes, I've set up mingw64, and already satisfied most packages through that. However, this library in question doesn't seem to be there when I searched for it via `pacman -Ssq zyz`
16:42:17 <Wizek> zachk: but I have the source code checked out
16:43:01 <zachk> sometimes the library will be there for proper building with a mingw64- in front of it
16:44:00 <Wizek> zachk: -Ssq searches in a substring, prefixes and suffixes don't matter
16:44:47 <zachk> Wizek, oh wow thanks for the tip 
16:47:09 <Wizek> So, having the source code, and the all-important `xyz.h`, how can I make this c lib visible to ghc? 
16:47:50 <Wizek> When I comment out the "extra-libraries" section in the .cabal file, I get further with the compile, to this point: `ghc.EXE: C:\Users\Wizek\exp-xml\.stack-work\install\63a7b83c\lib\x86_64-windows-ghc-8.0.2\xyz-0.2.5.2-88zInqkawLDHfnQqe2nfmi\HSxyz-0.2.5.2-88zInqkawLDHfnQqe2nfmi.o: unknown symbol `mdb_dbi_close'`
16:47:53 <rudol> glguy: your Help module code is very neat, and I already learnt from it, thank you. So far, I cannot quite work out how I would use it with the NoDetState type and, in particular, the fromenv function  in my original code. The real aim is to solve SEND+MORE+MONEY but using 
16:48:08 <rudol> This is the original code https://github.com/dag/all-about-monads/blob/master/examples/example24.hs
16:49:24 <Wizek> Anyone any ideas how I could entice ghc to notice the .h file?
16:49:26 <geekosaur> Wizek, you need both --extra-include-dirs to point to the directory with the .h file, and --extra-lib-dirs to point to the directory with .dll or (for mingw32) .a files
16:50:16 <rudol> before I have a go at making Var and Value more flexible and typesafe, I am trying to solve SEND+MORE=MONEY just by using the functions in http://lpaste.net/358809 , but it seems like I am not writing simple enough functions, like your, which I could hopefully just lift to work within his NDS monad transformer
16:50:34 <Wizek> geekosaur: since I only have the source at this point, does that mean that I need to compile that separately to get the .dll/.a files too?
16:50:43 <geekosaur> yes
16:51:16 <geekosaur> otherwise you would need to integrate it into the cabal project directly, which is potentially quite a lot more work
16:51:47 <Wizek> hmm, looking into if I can simply `gcc` in that folder
16:52:12 <glguy> rudol: Check out this version http://lpaste.net/358813
16:53:08 <rudol> glguy - did you just write that?
16:53:09 <monochrom> Aw, what is "augend"? :)
16:53:14 <glguy> rudol: Yeah
16:53:22 <glguy> monochrom: It's apparently the first addend!
16:53:31 <rudol> that's amazing! Thank you
16:53:33 <glguy> monochrom: I had to look that up just now
16:54:07 <monochrom> It begins to sound like augent, addend, summand are all the same thing.
16:54:39 * geekosaur thought augend was the back of the augean stable >.>
16:55:56 <MarcelineVQ> well they all end with d, except tht first one, so they must be pretty similar
16:56:17 <glguy> MarcelineVQ: That 't' was a typo
16:56:30 <monochrom> I prefer Italian restaurant menu. So: summand primi, summand secondi, summand terti, insalata, antipasti, ducci
16:56:38 <MarcelineVQ> the exception that proves the rule
16:57:53 <zachk> @src replicate
16:57:53 <lambdabot> replicate n x = take n (repeat x)
17:04:16 <rudol> glguy: that is a very nice solution, and I've already learnt a lot from it. In terms of adapting https://github.com/dag/all-about-monads/blob/master/examples/example24.hs (without changing the Var and Value types, which are both just String) for SEND+MORE=MONEY, do you think I would need messy code similar to my original effort in http://lpaste.net/358809 ? I think what I am trying to grasp there is how I would lift functions like in
17:04:50 <rudol> in hos NDS monad transformer. Am I thinking the wrong way?
17:12:02 <glguy> rudol: The code you pasted is using its NonDet type in a pretty trivial way, so it's hard to know what you're doing with it
17:13:28 <glguy> ideally you'll only use runStateT at the very "beginning" and not all throughout the code
17:13:47 <rudol> I tried to simplify so as to make it less work for someone trying to help, but it is probably better if we just review what is possible in terms of the example24.hs code. 
17:14:58 <rudol> My aim was to change non of his types, and to keep his getVar function. And, see if I could write new functions to solve SMM, but I ended up with something like the mess in my original paste.
17:16:09 <rudol> The exercise was probably more about how to lift functions to work in hid NDS monad transformer rather than explore how to do backtracking.
17:17:45 <rudol> but my functions looked similar to http://lpaste.net/358809 (pre your annotations, of course) which I was not happy about.
17:17:51 <halogenandtoast> quit
17:19:18 <rudol> in    readInt k = head $ map (fmap ifs.fst) $ runStateT nds ms   for example, it seems having to use runStateT is overkill
17:20:05 <rudol> and that    num keys = foldl (\b a -> (+) <$> a <*> ((*10) <$> b))          is operating at the wrong level of abstraction.
17:20:11 <tomsn> hey, im a beginner and try to write a tui program with brick tui library. i got lots of code like "somefcn a = mkWidget1 a <+> mkWidget2 a <+> mkWidget3 a" where <+> is some kind of layouting method. it feels wrong to pass "a" to every widget instancing. is there a better method? sry 4 stupidity
17:21:59 <geekosaur> somefcn = liftA3 (<+>) mkWidget1 mkWidget2 mkWidget3 -- ?
17:22:40 <boj> tomsn: is the problem that you don't want to pass 'a' around everywhere?
17:22:55 <boj> like, some kind of state for example?
17:24:00 <tomsn> yes, i want to write tui widgets, and they all need to access different states. and over time even more. and its so verbose to pass all these states to all fcns
17:26:32 <boj> tomsn: you may want to look into the State monad. as a beginner it may be an advanced topic, but it will allow you to pass state around without all the function boilerplate
17:32:58 <zachk> tomsn, consider wrapping the individual states in a big state record and just passing that
17:34:51 <tomsn> boj: i read about it in the 4greatgood book. i didnt get that it could be used that way, but it seems to give a concise syntax in the outer levels of the code. thx!
17:35:15 <boj> tomsn: cool, good luck! :)
17:47:26 <libman> I have a little benchmark trying to identify compilers that can produce very lean Unix executables (ideally static):  https://github.com/lbmn/crap/tree/master/bench/helloWorld .   Are there ghc arguments that would make it competitive at this?  Is there another Haskell compiler better suited?
17:50:52 <geekosaur> probably not. and 'preferably static' don't use glibc then unless you guarantee the exact same glibc version on other system because it WILL dlopen() various things, even when static
17:53:29 <libman> Yeah, musl support gives a language a great advantage at this.
17:55:34 <MichaelBurge> I have a Haskell program that's running in parallel(CPU load much greater than 100%) and I'm not sure why. I understand something must be using forkIO or par annotations for that to happen. I don't think it's forkIO. Is there a way to see the source locations where things are being added to the queue?
18:05:45 <dmj`> MichaelBurge: can you show us your code
18:06:43 <alx741> hello everyone. When there is a function that transforms some data type like, which order of parameters tends to be more convenient: `f :: a -> Type a -> Type a` OR `f :: Type a -> a -> Type a`?
18:08:26 <geekosaur> alx741, generally depends on which one ends up being more useful for partial application. which for a very general function will likely the latter, but it depends on the use case
18:08:27 <MarcelineVQ> that's too vague but typically parameters that will be changed more often should go later
18:09:07 <MichaelBurge> dmj`: I would have to minimize the example. I was just wondering if it left e.g. a trace in the assembly or an interface file, or had an option
18:09:10 <geekosaur> (and sometimes there's enough variability that providing both via flip is a good idea, see for example mapM vs. forM)
18:11:10 <alx741> could it be said that "when in doubt, use the latter"? 
18:11:49 <dmj`> MichaelBurge: time and space profiling can help
18:12:34 <MarcelineVQ> ehe, when it doubt it doesn't matter since you'll surely need to change it based on how you end up using it.
18:12:50 <geekosaur> libman, to be honest, if all you care about is executable code golf, you've come to the wrong language
18:13:29 <libman> I just wanted to include Haskell (which I know very little about) and give it a fair shot in that benchmark.
18:14:00 <alx741> right! got it, thanks guys!
18:16:39 <geekosaur> we're still working on getting non-golfed stuff down to size without blowing ld's mind (and memory usage). turns out when your evaluation strategy involves reducing a large graph, you have a lot of data representing the graph...
18:19:01 <libman> MLton did OK.  I'm probably doing something wrong with GHC.  
18:19:59 <geekosaur> MLton is not lzy evaluation via graph reduction
18:21:23 <MarcelineVQ> libman: which stat on your graph are you trying to reduce for ghc?
18:22:19 <libman> "Total bytes".
18:22:35 <MarcelineVQ> ah excutable filesize?
18:23:13 <libman> Including library dependencies.  Right now the Haskell binaries don't run without a large number of libraries installed.
18:29:13 <MarcelineVQ> I'm not sure there's much in the way of options there :X  Do try asking in #ghc though just in case someone there has a good idea. I imagine you've checked out the linking options here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#linking-options
18:29:19 <Welkin> what is MLton?
18:30:30 <MarcelineVQ> I wonder if there's anyone on earth that does all their searching through lmgtfy because someone linked that to them as an answer one time
18:31:29 <geekosaur> Welkin, whole-program compiler in the SML family
18:35:53 <kaychaks> geekosaur: 
18:42:59 <kaychaks> geekosaur: `( js ^..  values ) . key "name"` is giving a different error 
18:42:59 <kaychaks> ```
18:42:59 <kaychaks> Couldn't match expected type ‘(t0 -> f0 t0) -> c0’
18:42:59 <kaychaks>                   with actual type ‘[aeson-1.1.2.0:Data.Aeson.Types.Internal.Value]’
18:42:59 <kaychaks>     • Possible cause: ‘(^..)’ is applied to too many arguments
18:42:59 <kaychaks> ```
18:44:19 <kaychaks> geekosaur: `( js ^..  values ) . nameAndAge` gives similar error 
18:44:43 <geekosaur> then I cannot help.
18:44:52 <pikajude> that looks really backwards
18:44:54 <pikajude> usually when you use ^..
18:45:01 <pikajude> the RHS is a dot-composed list of lenses
18:45:06 <pikajude> why would the parentheses be there
18:45:08 <geekosaur> (but nobody else was answering --- I did see your questions yesterday --- so I did what I could)
18:45:30 <geekosaur> pikajude, you probably want to look at the original queston. which nobody else was, apparently
18:45:33 <pikajude> oh ok
18:45:59 <geekosaur> http://lpaste.net/358787
18:46:51 <crucify_me> hi when you have foldl (flip (:)) [5,6,7] [1,2,3,4] , I see what's happening, except how the (flip (:)) takes in values from [1,2,3,4]
18:46:52 <geekosaur> they asked several times yesterday with no response and a couple times today. I don't know lens but that was all I could come up with; relaly needs someone who knows more details
18:46:54 <crucify_me> http://lpaste.net/358815
18:47:25 <geekosaur> ..."except"? I mean, that's what folds do
18:47:39 <geekosaur> so if you are not seeing that then I'm not sue what you are seeing at all
18:47:56 <pikajude> wow that's such a confusing snippet
18:48:09 <pikajude> but the issue is that it needs a $ before the "f a" at the end of line 12
18:48:12 <pikajude> that's about it
18:49:33 <crucify_me> put differently, the [1,2,3,4] list goes into the left operand position, and is flipped? is that how to visualize that?
18:54:28 <geekosaur> no
18:55:00 <geekosaur> flip iterates through the list, invoking its function parameter on each element and a base value, resulting in a new base value
18:55:03 <geekosaur> er, fold does
18:55:16 <geekosaur> foldl / foldr use different strategies to go through the list
18:55:22 <crucify_me> my problem is that I don't see why foldr doesn't work with the flip and foldl doesn't work without it.
18:55:35 <geekosaur> flip is just a convenient way for fixing the ordering of the parameters passed to the function
18:55:44 <geekosaur> :t foldl
18:55:46 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
18:55:52 <geekosaur> guh
18:56:31 <geekosaur> :t foldl ?f ?z `asAppliedTo` [undefined]
18:56:32 <lambdabot> (?z::b, ?f::b -> a -> b) => [a] -> b
18:56:36 <geekosaur> :t foldr ?f ?z `asAppliedTo` [undefined]
18:56:38 <lambdabot> (?z::b, ?f::a -> b -> b) => [a] -> b
18:56:42 <crucify_me> but with (:) why does the ordering matter?
18:56:48 <geekosaur> :t (:)
18:56:49 <lambdabot> a -> [a] -> [a]
18:56:53 <pikajude> it's head : tail
18:56:54 <geekosaur> it is not symmetrical
18:56:56 <pikajude> you can't do tail : head, doesn't typecheck
18:57:45 <crucify_me> so each element in a list here, ie head and tail, are typed differently? sorry
18:57:49 <pikajude> no
18:57:54 <pikajude> head is one element
18:57:57 <pikajude> tail is a list of elements
18:58:05 <geekosaur> crucify_me, have you even looked at lists yet?
18:58:17 <geekosaur> Haskell lists are cons-lists
18:58:24 <geekosaur> elem : elem : elem : ... : elem : []
18:58:32 <crucify_me> that I understand
18:58:48 <geekosaur> but you can;t see why it is not allowed to be [] : elem ?
18:58:59 <geekosaur> even from the type?
18:59:21 <crucify_me> put that way I can see it. but I think I'm visually the operation incorrectly
18:59:29 <crucify_me> visualizing
18:59:35 <geekosaur> > foldl f z [a,b,c]
18:59:38 <lambdabot>  f (f (f z a) b) c
18:59:42 <geekosaur> > foldr f z [a,b,c]
18:59:44 <lambdabot>  f a (f b (f c z))
18:59:59 <crucify_me> er..
19:00:31 <geekosaur> this visualization brought to you by the simple-reflect package
19:01:39 <kaychaks> pikajude: on the lens error snippet, `$` at the end is giving me other errors. My use case is to generate a tuple of name and age from the json mentioned in the snippet 
19:01:53 <pikajude> kaychaks: are you sure there's an applicative instance that does what you want?
19:02:05 <pikajude> i don't recall ever trying that with lenses
19:02:50 <pikajude> you might want to ask edwardk about this
19:02:52 <pikajude> or even in #haskell-lens
19:02:57 <kaychaks> ok
19:03:04 <pikajude> i vaguely recall asking if there was a way to combine lenses in that way and i don't remember what the answer was
19:03:09 <pikajude> hope that's specific enough
19:06:46 <crucify_me> sorry, all we're doing is consing [10,11,12 onto [1,2,3] with foldl. why does flipping the order of the elements 10 11 12 allow foldl to work? very sorry I understand essentially what is going on I think
19:06:56 <crucify_me> [10,11,12]*
19:07:19 <kaychaks> yeah I have tried to look for examples as the theories are still above my head mostly. I got some idea from #haskell-beginners but stuck at that error.
19:08:06 <geekosaur> you are not flipping those. I said that alreadu
19:08:28 <geekosaur> you are flipping the current element taken from the list and the base value
19:10:38 <crucify_me> am I correct to say 10 is the first element consed?
19:10:39 <geekosaur> you start out with the base value being [1,2,3]. the first time through, foldl does (yourFunction [1,2,3] 10) and expects a list back
19:11:51 <crucify_me> oh so 10 is the second argument, we need it to be the first
19:12:11 <crucify_me> yourFunction needs it to be the first, so we flip it.
19:12:30 <geekosaur> yes, because the effectoive type here is [a] -> a -> [a] but we want to use (:) which is a -> [a] -> [a]
19:12:49 <geekosaur> so we use (flip (:)) and now it takes them in the right order
19:12:50 <crucify_me> thanks geekosaur you rule
19:13:55 <crucify_me> right. when I first tried one of these functions I got a non-exhaustible error, so perhaps it was for a related reason
19:14:11 <crucify_me> I forget exactly what I had tried
19:15:12 <geekosaur> that doesn't sound like an existing error, and the closest one I can think of it 'non-exhaustive patterns' which makes me wonder what you tried (and if you forgot to deal with empty lists or something)
19:18:06 <crucify_me> geekosaur, if I work another hour, I think I'll really get foldl foldr. I figured out much by using scanl scanr. the flip (once again) was tripping me up geekosaur 
19:21:48 <crucify_me> here's the thing: I thought when 10 was first "extracted" from the second list, it was put into the left operand spot for (:). so it was how I visualized it that put me in error. In fact, the element 10 stays* in place, in foldl's 3rd argument spot.
19:21:52 <crucify_me> geekosaur, ^
19:23:40 <crucify_me> is that valid?
20:40:06 <ackpacket> Wrote the first makings of a decision tree training in haskell and would love some critique.  The logic is simple:  Given a mass of data in two categories, look at all the conditions you could use to split the data, and pick the best one.  The problem is as someone who's new to haskell I'm sure there's a great deal of this that's un...haskell-y. 
20:40:07 <ackpacket> http://lpaste.net/861378939870773248
20:40:24 <ackpacket> This doesn't split the tree multiple times, it just makes one split which I used to do initial profilign
20:40:27 <ackpacket> *profiling
20:53:50 <boj> ackpacket: the lpaste gives a few warnings for code cleanup on the bottom, but sides that i don't see anything that stands out
20:56:49 <boj> maybe minor (subjective) style changes. like  (fromIntegral . length) treeData  or  fromIntegral . length $ treeData  -- the "lesson" there as putting emphassis on the compositional operator to make things more composable
21:13:00 * hackagebot micrologger 0.4.0.1 – A super simple logging module. Only for use for very simple projects. – https://hackage.haskell.org/package/micrologger
21:22:09 * hackagebot turtle 1.4.4 – Shell programming, Haskell-style – https://hackage.haskell.org/package/turtle
21:22:39 <Arul> http://lpaste.net/358818 - Can somebody take a look at this sample code and let me know how to avoid the partial pattern matching that I have in my code? #newbiequestion
21:34:45 <lyxia> Arul: make getUTCTime return Maybe UTCTime?
21:43:18 <kaychaks> Arul: `getUTCTime` need to be referentially transparent, if should be consistent in its output for every input it gets. As your intent is to `just` work on a DateTime type of input and in all other case it should do `nothing`, `Maybe` is the data structure you can use to encode the same.
21:44:11 <Arul> Thanks lyxia: kaychaks: for your inputs
21:50:00 <tabemann> I'm having a very strange problem with the Haskell GI-Gtk bindings
21:50:35 <woodson_> anyone knows how i can create a common share folder in haskell and get my project to pull types from that folder?
21:50:57 <tabemann> my code is crashing with all kinds of weird errors, usually X11-related but never consistent, when I try to open and write to a file in one thread while another thread is inside a Gtk callback
21:54:15 <sm> tabemann: I have no clue, but: built with -threaded ?
21:54:31 <tabemann> sm: well yes
21:57:44 <MarcelineVQ> tabemann: is all your gtk interaction in the main thread? gtk is notoriously unthread-safe   https://github.com/haskell-gi/haskell-gi/wiki/Using-threads-in-Gdk-and-Gtk--programs
21:57:58 <tabemann> MarcelineVQ, yes
21:58:43 <tabemann> what seems to be happening is it doesn't like it if file IO is occurring in *any* thread when a Gtk thread is executing, even if it is not in the Gtk thread itself
21:59:13 <tabemann> mind you this is with -threaded on a multicore system, so the two different threads could be executing side by side
22:00:09 <tabemann> and now they've deprecated trying to do locking to prevent the Gtk thread from doing anything, so that I can prevent the Gtk thread from executing while I do my file IO
22:47:11 <orion> In this day and age, how difficult would it be to dynamically load and execute Haskell source code with GHC 8.2?
22:49:49 <JuanDaugherty> you mean dynamically compile and run?
22:50:33 <JuanDaugherty> or create a library?
22:51:05 <orion> The former.
22:51:13 <JuanDaugherty> (commonly called a dll, dynamic load library)
22:52:13 <JuanDaugherty> it would be fairly easy but contrary to static type regime ethos somewhat
22:52:24 <JuanDaugherty> *static typing
22:52:29 <orion> Why?
22:52:36 <JuanDaugherty> just the optics
22:53:06 <orion> It's still 100& statically typed.
22:53:19 <JuanDaugherty> assuming the sources (which would be dynamically generated as well?) compiled
22:55:08 <JuanDaugherty> haskellers like to think of their code as crystalline, doing stuff on the fly and compiling in real time is in lisps wheelhouse
22:55:30 <JuanDaugherty> or other dynamic, non static lang
22:55:58 <JuanDaugherty> *lisp's
22:56:57 <JuanDaugherty> there are the js in hs things, which generally do stuff like that
22:57:46 <JuanDaugherty> or hs in js actually igess
22:58:54 <dysfigured> can function be monoids? using the identity function and composition?
23:49:29 <jle`> dysfigured: yes
23:49:37 <jle`> but only for "endofunctions"
23:49:52 <jle`> functions whose inputs are the same type as their outputs
23:50:07 <jle`> there's actually a newtype wrapper for functions in haskell that provides thsi monoid instance
23:50:33 <jle`> > appEndo (fold [Endo (*2), Endo negate, Endo (+3), Endo succ]) 5
23:50:36 <lambdabot>  -18
23:50:59 <dysfigured> neat
23:51:04 <dysfigured> i think i'm starting to understand this stuff
23:51:35 <jle`> we need it to be a newtype wrapper because there's actually another Monoid instance for some functions
23:51:40 <jle`> and that other instance is the "default" one
23:52:01 <jle`> > fold [reverse, drop 2, take 4, map toUpper] "hello world"
23:52:04 <lambdabot>  "dlrow ollehllo worldhellHELLO WORLD"
23:52:29 <jle`> um sorry, fold = mconcat, if you aren't familiar with it
23:52:53 <jle`> (fold = foldr mappend mempty for lists)
23:53:17 <jle`> > (reverse <> drop 2 <> take 4 <> map toUpper) "hello world"
23:53:19 <lambdabot>  "dlrow ollehllo worldhellHELLO WORLD"
23:53:32 <jle`> > appEndo (Endo (*2) <> Endo negate <> Endo (+3) <> Endo succ) 5
23:53:35 <lambdabot>  -18
