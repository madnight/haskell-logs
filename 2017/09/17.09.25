00:05:10 * hackagebot sensei 0.3.0 – Automatically run Hspec tests on file modifications – https://hackage.haskell.org/package/sensei
00:16:21 <jvliwanag> I'm building a haskell app for windows and macos using stack. But building on mac requires some flags to be enabled (for gtk2hs). Is there an easy way to do this other than having to manually add --flags while doing stack build?
00:17:21 * hackagebot strict-types 0.1.0.6 – A type level predicate ranging over strict types – https://hackage.haskell.org/package/strict-types
00:21:19 <sm> jvliwanag: you can enable flags conditionally based on os in the cabal file
00:21:54 <cocreature> that won’t really help here since you can’t specify the flags of your dependencies (gtk2hs in this case)
00:22:34 <sm> hmm. Maybe you need an install script
00:22:54 <sm> or, fix gtk2hs so it applies those flags automatically
00:25:28 <jvliwanag> hm yeah. wanted to avoid an install script. still starting out with haskell, so I wouldn't want to touch gtk2hs stuff yet :)
00:25:41 <cocreature> jvliwanag: which flag do you need to specify?
00:26:10 <jvliwanag> on mac, it only builds with "have-quartz-gtk"
00:28:02 <cocreature> hm yeah looks like gtk2hs doesn’t attempt to set this automatically
00:28:28 <cocreature> jvliwanag: fwiw, the gtk2hs authors also recommend to use https://github.com/haskell-gi/haskell-gi instead of gtk2hs when developing new applications
00:30:47 <jvliwanag> hm yeah, was afraid to give haskell-gi a go since I need it on ghc 7.10. sadly need to support winxp. but I guess I better try it out
00:32:00 <cocreature> looking at the constraints in haskell-gi’s cabal file, it claims to support GHC 7.10
00:32:42 <jvliwanag> I'll go try it out :)
00:48:26 <ackpacket3> Would be nice if haskell supported validated versions of data types
00:49:30 <phadej> validated?
00:49:30 <ackpacket3> e.g., if you could do 1) assert "a" in my_hashmap, and then 2) HashMap.lookup "a" my_hashmap
00:49:39 <ackpacket3> but 2) doesn't return a Maybe type
00:49:48 <ackpacket3> it becomes unnecessary because of the earlier assertion
00:50:35 <phadej> ackpacket3: https://www.reddit.com/r/haskell/comments/6qu04u/justify_your_existence_with_justifiedcontainers/
00:50:47 <phadej> you can, but it has far from ergonomic API :)
00:51:47 <ackpacket3> haha, agreed...
00:51:49 <ackpacket3> a bit of a ways off
00:52:03 <ackpacket3> just pondering
00:52:38 <phadej> extensible-records is however a bit what you ask for
00:52:49 <phadej> like vinyl or other implementations
00:53:12 <ackpacket3> Maybe I can get some advice on something I'm writing right now:  I have a list of hashmaps.  They all should have the same set of keys.  I want to get a set of "keys that are being used", and right now the only way I can think to do this is to take the head of the list of hashmaps and get the keys from that
00:53:31 <ackpacket3> Is there an elegant way of doing this other than taking the head of the list, throwing to get out of the maybe, and then taking keys of that?
00:54:54 <phadej> Set.intersections (Set.fromList . HM.keys <$> listOfHashMaps)
00:56:12 <ackpacket3> is that efficient?  Is it going to ignore the assumption that all the maps have the same keys, and proceed to check *each* map?
00:56:14 <phadej> (there's isn't "Set.intersections", but it's simple to write for NonEmpty (Set k)"
00:56:35 <phadej> ackpacket3: first do the correct thing, than benchmark whether it's efficient enough
00:56:38 <phadej> usually: it is.
00:57:06 <ackpacket3> I suppose we're talking about a few million maps each with 200-400 keys
00:57:30 <phadej> another thing to think is "why you have million maps with 200-400 keys", what makes you think they all have same key set?
00:57:55 <ackpacket3> By virtue of their creation
00:58:15 <ackpacket3> If they don't I'd like to check that and abort early in the program
00:58:38 <phadej> the key set is dynamic, i.e. depends on the input data?
00:58:52 <ackpacket3> yes
00:59:50 <phadej> I'd probably do "read first one, make a reader-validator, and use it to read the rest"
01:00:32 <Unhammerd> When I compile the same project in two folders on my computer, should stack not share dependencies in ~/.stack? (I see it doing configure/build/copy/register all over again)
01:00:55 <phadej> Unhammerd: it will share snapshot dependencies
01:00:58 <phadej> but not extra-deps
01:03:42 <Unhammerd> oh :/
01:04:22 <Unhammerd> it's a project recently converted to stack, so quite a bit of extra-deps, that explains it. Thanks phadej 
01:04:35 <phadej> Unhammerd: but that will be fixed in 1.6.0, where you can make a proper custom snapshot
01:05:01 <Unhammerd> cool =D automatically, or do I have to do something special?
01:05:43 <Unhammerd> oh, found the docs https://docs.haskellstack.org/en/latest/custom_snapshot/ :)
01:05:48 <phadej> Unhammerd: https://github.com/commercialhaskell/stack/pull/3249 & https://www.fpcomplete.com/blog/2017/07/stacks-new-extensible-snapshots
01:06:04 <phadej> I don't remember the details, so there are references
01:06:16 <Unhammerd> :)
01:07:01 <Unhammerd> that's pretty cool
01:51:29 <anohigisavay> hi. i have a question about parsec. Is it better to use different types for lexer and parser, e.g. `type Lexer t = forall s u m. Stream s m Char => ParsecT s u m t` and `type Parser t = forall s u m. Stream s m Token => ParsecT s u m t`, and pass the lexer result, e.g. [Token] to parser
01:52:31 <anohigisavay> or to use the same type and mix lexers and parsers
01:52:42 <merijn> anohigisavay: I usually do the latter
01:53:43 <anohigisavay> merijn, thanks. i was about to go with the first but then i realize i'd lose location info
01:54:34 <merijn> anohigisavay: I have a parser that preserves locations with trifecta, you can probably steal the basic idea and reuse it for Parsec, though: https://github.com/merijn/lambda-except/blob/master/Lexer.hs
01:54:55 <merijn> anohigisavay: You might also wanna consider switching to megaparsec, which is a fork of Parsec that's is actively developed/maintained
01:55:17 <anohigisavay> merijn, cool thanks :)
01:55:29 <merijn> And a bit more up to date (i.e. doesn't shadow operators from Control.Applicative, etc.)
02:15:11 <tdammers> anohigisavay: it depends on the grammar you're parsing. if it's highly contextual, then writing a separate lexer becomes cumbersome, because the lexer needs to have context-dependent lexing rules, or you need multiple levels of lexing, or something like that, so in those cases, it's easier to go from input stream -> parse tree directly, embedding the lexer in the parser
02:15:46 <tdammers> anohigisavay: but for some languages, having an explicit lexeme type and doing lexing and parsing separately can make things easier to follow and understand
02:33:55 <anohigisavay> tdammers, i see. but then how does one deal with the highly contextual situation with alex/happy? because they are completely separated (though i've never used them before ._.)
02:34:44 <tdammers> Haskell isn't that contextual
02:36:12 <anohigisavay> _(:з」∠)_
02:42:24 <phaazon> is there a package to hash a password via SHA2-512 with a salt?
02:42:28 <phaazon> I’m looking at Crypto
02:42:34 <phaazon> but I don’t find a function that takes a salt
02:48:00 <phaazon> nevermind, I found my joy
02:48:28 <merijn> phaazon: Don't use SHA for passwords >.<
02:48:39 <phaazon> merijn: I use argon2, actually
02:48:48 <phaazon> and why shouldn’t I use SHA?
02:48:52 <phaazon> glibc does.
02:48:55 <phaazon> SHA2-512
02:48:57 <phaazon> for crypt()
02:49:24 <merijn> phaazon: SHA is designed for being fast, so the opposite of what passwords should be.
02:49:37 <phaazon> interesting
02:49:42 <phaazon> so what would you use SHA for?
02:49:52 <cocreature> things like file hashing
02:49:54 <merijn> phaazon: File integrity (where you want to be fast)
02:50:12 <phaazon> right, thanks!
02:50:17 <cocreature> the algos in Crypto.KDF.* are the ones that you want to use for password hashing
02:50:22 <Athas> Or random number generation!
02:50:24 <merijn> For passwords you want something like PBKDF2 (which is just a scheme for making fast hashes like SHA2, etc.) slow
02:50:35 <merijn> Or, libraries like bcrypt and scrypt
02:51:35 * hackagebot wide-word 0.1.0.4 – Data types for large but fixed width signed and unsigned integers – https://hackage.haskell.org/package/wide-word
02:53:58 <phaazon> merijn: cryptonite seems good enough
02:54:09 <phaazon> hash :: (ByteArrayAccess password, ByteArrayAccess salt, ByteArray out) => Options -> password -> salt -> Int -> CryptoFailable out
02:54:12 <phaazon> this seems okay to me
02:54:51 <cocreature> well that doesn’t say anything about the algorithm you use
02:54:57 <merijn> phaazon: Well, as you'll see cryptonite's KDF (Key Derivation Function = password hash) module lists all three of my suggested candidates ;)
02:55:08 <phaazon> right
02:55:15 <phaazon> I can’t :m + KDF.Argon2
02:55:17 <phaazon> wtf :(
02:55:29 <cocreature> it’s called Crypto.KDF.Argon2
02:55:37 <phaazon> yeah, thank you, I know
02:55:38 <phaazon> but look:
02:55:52 <phaazon> <no location info>: error:
02:55:53 <phaazon>     Could not find module ‘Crypto.KDF.Argon2’
02:55:58 <phaazon> I installed cryptonite already
02:56:40 <cocreature> how did you start ghci?
02:56:47 <phaazon> stack exec ghci
02:56:47 <cocreature> and did you restart it since you installed cryptonite?
02:56:51 <ventonegro> phaazon: If you installed with Stack, maybe you need `stack exec ghci`
02:56:52 <phaazon> yes
02:56:53 <cocreature> use "stack ghci"
02:57:02 <cocreature> and have you added it to your build-depends?
02:57:08 <phaazon> same error
02:57:12 <phaazon> cocreature: no
02:57:14 <phaazon> :D
02:59:20 <phaazon> I added it to my stack.yaml, I think that was causing the issue
02:59:47 <cocreature> it’s in stackage so I don’t think you should need to add it to your stack.yaml, you need to add it to the build-depends in your cabal file
03:04:02 <Fendor> is there an tutorial on how to write FFI bindings to a lib.so? 
03:04:43 <Athas> Fendor: I had to do that yesterday, and I found https://wiki.haskell.org/Foreign_Function_Interface quite readable.
03:04:58 <Athas> When calling ghc you have to add '-lfoo', just like when using gcc.
03:05:19 <Fendor> Athas, and how does it work with stack?
03:05:59 <Athas> Not sure, probably fine.  My guess is you just add it to the GHC options in your foo.cabal (or package.yaml)..
03:06:29 <Fendor> yeah, found on stack overflow something like that. thanks!
03:06:30 <Athas> A nice trick for handling pointers to C structs is to define an empty Haskell data type for the struct:
03:06:30 <Athas> data SomeStruct
03:06:31 <Athas> Then use values of type 'Ptr SomeStruct'.
03:06:55 <Athas> This gives you type-safe pointers.
03:06:56 <Fendor> luckily i just have to call functions of the type IO ()
03:07:12 <Athas> Oh, then your case is pretty simple.  You'll have no trouble.
03:07:16 <Fendor> since i only need to call some kind of api which does the rest 
03:07:29 <Fendor> yeah, hope so too :D 
03:13:36 <Fendor> Athas, if i may ask you, is it enough to copy a lib.so into a subfolder of my porject and create a file which imports the function via `foreign import ccall safe "libpcm.so likwid_markerInit"? 0.o`
03:13:42 <Fendor> because that compiled just fine
03:26:18 <phaazon> ok, so, argon2
03:26:25 <phaazon> and output length set to 512 bytes
03:26:29 <phaazon> it should be good, right? :D
03:35:26 <cocreature> Fendor: no, that’s not correct. 1. "libpcm.so likwid_markerInit" is not a correct import specification, the first identifier needs to be the name of a header (or just not be present, afaik ghc simply ignores this) and 2. you still need to tell GHC to link your lib
03:36:15 <Fendor> ok, thanks, can i link with stack build --ghc-options?
03:36:41 <cocreature> you should add it to ghc-options in your cabal file
03:36:50 <cocreature> in extra-libraries
03:37:21 <cocreature> eh that was confusing. it should be in extra-libraries, not in ghc-options
03:38:40 <Fendor> if i got a libpcm.so in ./pcm/, do i link with extra-libraries:  [ ./pcm/ ] or something liek that? 
03:50:16 <mfngjgz> Is there any data structure that preserves duplicates but performs as fast as Data.Set or Data.Map?
03:50:43 <mfngjgz> I am having trouble as converting to Set or Map eliminates duplicates in my list.
03:51:07 <fakenullie> you can count objects with Map
03:51:28 <fakenullie> well, that's how I do it in python
03:51:43 <mfngjgz> count objects?
03:52:15 <Fendor> mfngjgz, it depends, what you need, if you need fast checks if something is already in the container, or do you want fast remove, insert?
03:52:26 <fakenullie> map maps object to count, so duplicates will go to same key and value will be number of those duplicates
03:53:14 <fakenullie> if duplicates are different, then key maps to a list of those duplicates
03:54:07 <fakenullie> so essentially like handling collisions in a hash map
03:55:07 * hackagebot servant-rawm 0.1.0.0 – Embed a raw 'Application' in a Servant API – https://hackage.haskell.org/package/servant-rawm
03:59:36 <fakenullie> mfngjgz: fromListWith (++) [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"a")] == fromList [(3, "ab"), (5, "aba")]
04:18:47 <cocreature> huh I don’t get why that servant-rawm package exists. servant already provides a Raw type itself
04:27:19 <tabaqui> how can I clear the ghci cache?
04:27:36 <tabaqui> I want to measure time taking by function
04:27:45 <merijn> tabaqui: Don't time ghci
04:27:53 <merijn> tabaqui: It's going to be *wildly* inaccurate
04:28:36 <tabaqui> probably
04:28:48 <tabaqui> how can I force ghc do not cache function results than?
04:28:59 <tabaqui> *then
04:29:00 <merijn> tabaqui: What makes you say it caches function results?
04:29:43 <tabaqui> because it does? I dunnot if pure function returns the same value for the same inputs, we can cache it
04:29:59 <tabaqui> and one of the unsafe functions is caching
04:30:14 <merijn> tabaqui: ah, this sounds like an entirely different problem
04:30:19 <merijn> @quote is.not.a.bug
04:30:20 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
04:30:44 <merijn> tabaqui: What are you doing and what is the actual problem?
04:32:00 <tabaqui> I need to write some "port manager" that handles two operations: "Give me a free port" and "I release my port"
04:32:45 <tabaqui> It should not be very optimized code, but set with 40000 elements doesn't seem like a good solution
04:33:24 <merijn> tabaqui: Port as in network port?
04:33:28 <tabaqui> yeah
04:33:36 <tabaqui> *about the set
04:34:13 <tabaqui> I do not keep the set of free ports, only the set of taken
04:34:15 <Athas> It is unfortunate that Haskell does not have something like unsafePerformIO that is memory-safe.
04:34:28 <tabaqui> and I cannot just ask the OS for a new port
04:34:45 <merijn> tabaqui: Why do you have to manage that in your program? Usually your OS' syscall can do that for you
04:34:48 <tabaqui> because "Give me" doesn't mean that client will open it actually
04:34:48 <Athas> I wonder if it is inherently impossible for an otherwise pure language.  Probably.
04:35:08 <merijn> tabaqui: Why do you need to hand out ports without using them?
04:35:40 <merijn> Athas: What do you mean by memory safe?
04:36:18 <tabaqui> it's a some kind of proxy server, and if one side disconnects accidently, we have to be sure, that it can get back its port within next minute
04:36:24 <Athas> merijn: no segfaults.
04:36:48 <merijn> Athas: Pretty sure unsafePerformIO is memory safe IFF you don't use any of the FFI/pointer stuff
04:36:51 <Athas> In ML you can "cheat" and have a function that looks pure, but really performs side effects, but it cannot go beyond the language semantics.
04:36:55 <Athas> merijn: IORef is unsafe.
04:37:03 <merijn> Athas: It is? How so?
04:37:13 <merijn> Athas: If you don't use atomicModify, I guess?
04:37:19 <Athas> merijn: http://lpaste.net/358700
04:37:19 <tabaqui> I mean, I have opened ports on the other side, that must be closed after disconnect of the other side, and be reopened on the same place
04:37:36 <Athas> It's the same reason SML bans value polymorphism.
04:38:24 <merijn> tabaqui: I don't think I understand what you're trying to do
04:38:39 <tabaqui> merijn: I can imagine :) So what about caching?
04:38:56 <merijn> tabaqui: I don't understand how you think GHC is caching either
04:40:20 <tabaqui> dunno, If I would write GHC, then I would try to predict function calls
04:40:45 <tabaqui> and if in closest future there will be call with the same argument
04:41:02 <tabaqui> I would keep the result for some time
04:41:15 <merijn> tabaqui: yeah...you're assuming way too much there :)
04:41:58 <Athas> tabaqui: that would be a really risky optimisation.
04:42:06 <Athas> It's hard enough to reason about space usage in Haskell as it is.
04:42:45 <tabaqui> okaay
04:42:48 <tabaqui> so how it does?
04:43:54 <Athas> How what?
04:44:31 <tabaqui> how ghc caches functions results?
04:44:38 <Athas> It does not.
04:44:42 <merijn> tabaqui: Like I said, what makes you think it does?
04:44:49 <Athas> But it does use lazy evaluation, which can look a bit like it does.
04:45:35 <Athas> Like, if you have a top-level definition
04:45:35 <Athas> randomValue = unsafePerformIO generateRandomNumberSomehow
04:45:36 <tabaqui> merijn: because "unsafePerformIO (print "test" >> return 1)"
04:45:36 <Athas> Then 'randomValue' will have the same value every time you reference it.  The 'generateRandomNumberSomehow' action will only run the first time it is accessed.
04:45:44 <tabaqui> called twice doesn't print twice
04:45:52 <merijn> tabaqui: Refer to my earlier quote
04:45:57 <merijn> @quote is.not.a.bug
04:45:57 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
04:45:58 <Athas> That's because you didn't define it as a function.
04:46:16 <Athas> You can try a making it a function that takes () as a single argument.
04:46:27 <cocreature> if you care about how often unsafePerformIO is evaluated you probably shouldn’t be using unsafePerformIO
04:46:41 <tabaqui> I do not
04:46:43 <tabaqui> never before
04:46:52 <tabaqui> and I never in 2017
04:46:56 <tabaqui> *I hope
04:47:14 <cocreature> then why are you bringing up unsafePerformIO?
04:47:30 <Athas> You should try rewriting your code to not make use of unsafePerformIO.  It is useful/necessary in some cases, but they have to be minimised.  It really is unsafe.
04:47:37 <tabaqui> cocreature: I didn't! I just say that GHC have to cache functions because it can
04:47:53 <tabaqui> Athas: I do not use unsafe functions
04:48:09 <Athas> GHC does not memoize functions.
04:48:23 <tabaqui> ok, I'll just trust you, guys
04:48:23 <Ferdirand> you are ignoring the cost of keeping all these results around, forever
04:49:07 <tabaqui> Ferdirand: not, if keeping is less expensive than re-evaluating
04:49:14 <cocreature> tabaqui: now if you bind the result to something in a let binding, it will not be “cached” but that’s not fundamentally different from assigning the result of a function call to a variable in other languages
04:49:27 <cocreature> eh s/not be/be/
04:50:05 <cocreature> and parts of functions that don’t depend on arguments might also be floated out to separate definitions and will be cached
04:50:09 <merijn> ugh...conduit has no "bracketOnError"?
04:50:16 <Ferdirand> tabaqui: but how could ghc know the cost of evaluating something, short of actually running the code ? 
04:50:25 <cocreature> but there’s no cache for actual function results
04:50:31 <Ferdirand> and how do you know if the result will ever be needed again ?
04:51:02 <tabaqui> Ferdirand: I can keep it for some short time
04:51:27 <tabaqui> cocreature: ok
04:52:03 <cocreature> tabaqui: if you provide some example of why you think it caches things, we might be able to explain what’s actually going on. that’s why merijn asked what makes you think that it caches function results.
04:52:24 <tabaqui> I will try
04:52:53 <merijn> ok, any suggestions on how I can manage to cobble together a bracketOnError for conduit/MonadResource?
05:00:57 <bartavelle> is there a syntax to "import Foo from package foo" ?
05:01:26 <merijn> bartavelle: Yes, but it's best avoided at all costs
05:01:38 <merijn> bartavelle: I think it's called PackageImports?
05:01:46 <bartavelle> merijn: lemme look that up, thanks
05:01:51 <cocreature> merijn: what’s so bad about it?
05:02:51 <bartavelle> merijn: works like a charm, thanks
05:02:53 <cocreature> I’ve seen people use it in tutorials and found it quite nice to see immediately where imports are coming from
05:02:57 <merijn> cocreature: Because it means your dependencies are using the same module namespace, making it confusing to read the code
05:04:21 <cocreature> merijn: 1. even if they aren’t using the same module namespace it can be handy to immediately see where modules are coming from and 2. your dependencies are often not under your control so avoiding package imports might simply not be an option
05:04:34 <cocreature> if your point is “avoid reusing module names” I completely agree
05:05:48 <merijn> cocreature: The correct solution to "my dependencies are reusing module names" is "relentless persecution of the authors until they mend their ways"
05:06:38 <merijn> I'm confused why ResourceT has no "with/bracket" that works for any MonadResource. There is "allocateAcquire" which seems it should make it easy to implement that?
05:07:45 <merijn> Or am i missing something obvious here?
05:08:09 <michalrus> Hey, I don’t get something. I’ve got a module with just oprhan instances. When I don’t use -fno-warn-unused-imports in other modules, GHC complains that `import Project.Orphans` is unused. If I don’t do that import, it complains about missing instances that `Project.Orphans` defined.
05:08:11 <michalrus> What to do?
05:08:34 <merijn> michalrus: "import Project.Orphans ()", which, that warning should mention
05:08:50 <cocreature> merijn: what’s wrong with "allocate"? do you need the allocation and the freeing happen outside of IO?
05:08:52 <michalrus> merijn: yes, and if I do that, it still complains that the warning is unused.
05:09:02 <michalrus> s/warning/import
05:09:06 <merijn> michalrus: Are you using those orphans?
05:09:23 <michalrus> Yes, if I *don’t* import orphans, it won’t compile, because it’s missing them.
05:09:47 <ocharles> Is there anyway in a `.cabal` file that I should be reporting that my setup phase requirements the `thrift` binary to be reachable from `$PATH`?
05:09:49 <merijn> cocreature: Doesn't let me run something *only* when an exception occurs
05:10:05 <merijn> cocreature: The free only runs
05:10:09 <cocreature> merijn: well you said you want "bracket" that doesn’t let you do that either :)
05:10:11 <merijn> cocreature: s/only/always
05:10:18 <merijn> cocreature: No, I said bracketOnError
05:10:39 <cocreature> “14:06 <merijn> I'm confused why ResourceT has no "with/bracket" that works for any MonadResource.”
05:10:48 <merijn> cocreature: and next I said 'bracket for allocateAcquire" which does let me specify "exceptiononly"
05:11:06 <merijn> cocreature: "with :: MonadBaseControl IO m => Acquire a -> (a -> m b) -> m b"
05:11:14 <merijn> cocreature: I want that, but without MonadBaseControl
05:11:19 <ocharles> https://cabal.readthedocs.io/en/latest/developing-packages.html#pkg-field-build-tools seems to suggest that `build-tools` would look on `$PATH`, but it's now deprecated
05:11:33 <merijn> cocreature: allocateAcquire seems to imply that functionality is possible
05:11:36 <michalrus> Oh, wonderful. I need to do module Backend.Orphans () where
05:11:45 <michalrus> Without (), it complains.
05:11:47 <michalrus> ¯\_(ツ)_/¯
05:11:50 <michalrus> Thanks anyway. :]
05:11:57 <rudol> could somebody give me some ideas on how to make this simple stack (for which I previously used State, alone, with no logging) http://lpaste.net/358684 keep a record of all push and pop calls using StateT for the stack state and Writer for recording calls to push and pop?
05:12:03 <merijn> cocreature: Since that lets me register an exception only cleanup for any MonadResource
05:12:13 <merijn> cocreature: But my API needs a bracket like function
05:14:11 <cocreature> merijn: so you’re wondering why there is no synonym for "\a b -> allocateAcquire (mkAcquire a b)"?
05:14:20 <merijn> cocreature: Or I have to rejigger my cleanup to not break shit in the case of no exception
05:15:43 <merijn> cocreature: I've been fighting different types long enough I'm not sure what I'm wondering/wanting anymore, tbh :p
05:16:24 <cocreature> merijn: maybe you should start by figuring that out first :)
05:18:31 <merijn> cocreature: Ah, no, I remember why your suggestion is wrong
05:18:42 <merijn> cocreature: It's not exception safe
05:19:08 <rudol> should I assume that this is totally the wrong way to think, and that is why nobody can offer any advice onthis channel last night or today?
05:19:17 <merijn> cocreature: ah, hmm, maybe it is
05:19:18 <cocreature> merijn: huh? allocateAquire properly masks things
05:20:01 <rudol> I thought I was trying to do something fairly rational and simple ;) Just log all push and pop using a Write under my StateT.
05:20:30 <cocreature> rudol: what exactly is the problem you’re facing? is there a compile error? if so add it to the paste
05:21:21 <rudol> here's the hpaste again http://lpaste.net/358684. That compiles fine, but I can't see how to add logging to push and pop.
05:22:03 <rudol> how should push look, for example, if I want to "tell" everytime it is called?
05:22:23 <cocreature> rudol: what do you want to log?
05:22:39 <cocreature> just "push" and "pop"?
05:22:45 <rudol> all calls to push and pop. With push, also the new value.
05:23:12 <rudol> so, I was thinking I'd be ale ot somehow add a call to tell in the body of push and pop ot do that
05:23:18 <rudol> but I can't see how
05:23:34 <rudol> perhaps I am thinking very wrongly??
05:23:51 <rudol> is that not a valid use case for a StateT and writer
05:23:55 <rudol> ?
05:24:35 <mrkgnao> hey, is there a local for State? I can write my own (get, put modified, do thing, put back original) but I feel like this might be a common thing for people to need
05:26:03 <cocreature> mrkgnao: do you just want to throw away the new value?
05:26:09 <cocreature> rudol: how about http://lpaste.net/358701
05:26:31 <cocreature> mrkgnao: in that case, I usually find it simpler to just use ordinary functions instead of State
05:34:03 <rudol> cocreature: that looks exactly what I want - somehow I couldn't make it compile before, but yours is fine thank you!
05:35:06 <rudol> so what's the idiomatic way to run the state and retrive the log? something like 
05:35:07 <rudol> runStateT play'' [1,2,3] 
05:35:29 <cocreature> combine runStateT and runWriter
05:36:13 <rudol> again, I tried and couldn't compile - but will try again now you have boosted my confidence that I wasn't going about this totally unidiomatically
05:37:09 <kakashiAL> I am still a haskell noob, who is learning haskell to make my javascript programming better :)
05:37:28 <kakashiAL> there is something that you know in haskell called "either"
05:37:54 <kakashiAL> either is a function, well, its a higher order function with two argument that are also functions
05:38:05 <merijn> rudol, cocreature: Also, that might be nicer using RWS(T)
05:38:08 <kakashiAL> either(left, right)   <---left and right are also functions
05:38:46 <kakashiAL> what I want to know is that either is called TYPE, is that a haskell thing?
05:39:06 <kakashiAL> because for me either is just a function
05:39:09 <rudol> merijn, ty, I read about that, but I was first trying to get this to work as it seemed it should be so simple, yet I got bogged down somehow
05:39:20 <merijn> rudol: Story of my life :p
05:39:24 <cocreature> kakashiAL: "either" is not a type "Either a b" is the type
05:39:29 <rudol> ;)
05:39:33 <merijn> rudol: I've been working for 4 days to get this "simple" thing working :p
05:40:24 <kakashiAL> cocreature: could you explain that in more detail please
05:40:43 <kakashiAL> I mean is either a function, also in haskell?
05:40:48 <cocreature> yes
05:41:08 <cocreature> do you know what types are and how they relate to values?
05:42:08 * hackagebot accelerate-blas 0.1.0.1 – Numeric Linear Algebra in Accelerate – https://hackage.haskell.org/package/accelerate-blas
05:42:19 <kakashiAL> cocreature: hmm...in a haskell perspectibe?
05:42:23 <kakashiAL> perspective
05:42:23 <cocreature> yes
05:42:27 <kakashiAL> cocreature: not realy
05:44:05 <cocreature> kakashiAL: so values are the things that you’re actually computing with, i.e., the things that are present at runtime. every value has a type which is statically determined and checked by the compiler. if the types don’t match the compiler yells at you. types are not present at runtime.
05:44:07 <cocreature> :t either
05:44:09 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
05:44:26 <cocreature> "either" is a function of type "(a -> c) -> (b -> c) -> Either a b -> c"
05:45:33 <kakashiAL> cocreature: okay, so "TYPE" of a function in haskell, is its API/signature, the arguments it takes, and how it maps its arguments etc.
05:46:22 <cocreature> kakashiAL: saying that something is a “function” is already making a statement about its type. in particular functions are things of type "a -> b" for some type a and b 
05:46:54 <kakashiAL> cocreature: okay, got it
05:47:25 <kakashiAL> cocreature: so in haskell we dont realy take care what is a function or not, because if you give me its type, I get all informations that I need
05:47:48 <kakashiAL> because a type tells me what it is, what it does and so on
05:49:25 <kakashiAL> cocreature: thanks :)
05:59:43 <merijn> hmm
06:00:38 <merijn> I want a folding version of https://hackage.haskell.org/package/conduit-1.2.12/docs/Data-Conduit.html#v:awaitForever so I can keep some state
06:01:17 <merijn> I guess I'm stuck hand-rolling one?
06:01:30 <merijn> or using stateC, I guess
06:01:43 <mrkgnao> cocreature: I'm using something that's almost certainly a good fit for State, and this is a one-off thing where I want to run a "subcomputation" with a different environmentf.
06:02:12 <mrkgnao> but yeah, I've found myself using Reader when simple functions would do in the past
06:09:32 <Hafydd> (+) :: Num a => ReaderT a (Reader a) a
06:11:07 <mrkgnao> not sure having two readers in a stack is going to be looked upon kindly by the fundep gods
06:11:58 <Hafydd> Or if you prefer: (+) :: Num a => Reader (a, a) a
06:16:30 <Sornaensis> how many monads is a good amount
06:17:14 <Psybur> Sornaensis, about tree fiddy
06:17:42 <cocreature> over 9000
06:22:23 <Psybur> I am doing a sliding window on a series of prices. Each window I might open new orders, and existing orders might be closed. And I might do IO operations each window when I open new orders. Is this looking like a StateT (OpenOrders,ClosedOrders,Prices) IO NewOrders ?
06:22:42 <Psybur> Or would prices be kept out of the StateT?
06:22:59 <opqdonut> if the Prices don't change, perhaps ReaderT
06:23:35 <opqdonut> also, I'd try very hard to keep IO out of that iteration
06:23:48 <opqdonut> output some actions that are then performed by a separate interpreter, for instance
06:29:35 <Psybur> opqdonut, in order to generate the new orders, I might want to troll (poll) some internet data. I could avoid the IO in opening orders logic by returning a continuation but that seems overly complex
06:31:29 <Psybur> Also, what I am doing is creating a backtesting framework, so the framework isnt going to know what to do with the IO actions save getting continuations from the strategy that places orders
06:32:23 <Psybur> I will be looking into ReaderT, that does seem to ring a bell.
06:45:25 <Gurkenglas> "stack foo.png" will result in 'stack: Data.Conduit.Text.decode: Error decoding stream of UTF-8 bytes. Error encountered in stream at offset 0. Encountered at byte sequence "\137PNG"'?
06:46:45 <shapr> wat
06:47:19 <brynedwards> Well...I assume stack's default behaviour is to treat a file as a script
06:47:29 <merijn> Gurkenglas: That seems logical to me?
06:56:08 <Gurkenglas> "stack run hip-susan-exe susanpicture 10 10 beforesusan.png susan.png" also led to something like that instead of saying that run isn't a stack command, which I then reduced to that minimal example.
07:03:08 <geekosaur> Gurkenglas, what brynedwards said is correct, it's a side effect of script support.
07:03:17 <geekosaur> which it sounds like could use some sanity checking added
07:11:22 <maerwald> Sornaensis: just one, Eff r ()
07:11:54 <ocharles> maerwald: or Cont :)
07:12:16 <maerwald> don't see how Cont gives me extensible effects
07:15:23 <saurabhnanda> is there any reason (perf, maybe) for not having _1, _2, ... lenses for large tuples, say 64-tuples?
07:15:57 <fakenullie> heh
07:16:24 <fakenullie> I've heard that large tuples are inefficient themselves
07:17:59 <fakenullie> saurabhnanda: I guess nobody want to define something for every tuple size up to 64
07:19:54 <merijn> Anyone here have a solution for sharing test code between multiple cabal packages?
07:20:13 <merijn> Am I stuck packaging it as a separate library?
07:20:28 <osa1> merijn: that's what we do
07:21:47 <merijn> osa1: Guess that's what I'll do then :)
07:22:30 <maerwald> fakenullie: is such a thing not possible with TH hacks?
07:22:42 <fakenullie> I don't know
07:23:21 <cocreature> saurabhnanda: one reason is that it would make compile times of lens even worse and the size of executables depending on lens might grow depending on how smart GHC is these days at eliminating unused stuff
07:23:32 <saurabhnanda> cocreature: hmm...
07:24:38 <cocreature> compile time performance of code depending on lens probably also gets worse if there are more instances
07:27:50 <Psybur> opqdonut, when you mentioned ReaderT, did you mean ReaderT instead of StateT, or use them in conjunction? Because now Im thinking I nead a ReaderT Config (StateT (OpenOrders,ClosedOrders,Prices) IO NewOrders)
07:29:18 <johnw> Psybur: at that point, you might want to use RWST, with a Writer type of ()
07:29:22 <geekosaur> together, for sanity checking you'd like the compiler to verify that the Config is read-only
07:29:35 <geekosaur> and yes, RWST would work just as well for that
07:30:49 <Psybur> Now I gotta go back and review writier >{
07:30:54 <Psybur> *writer
07:32:43 <geekosaur> ?
07:33:09 <geekosaur> you're not using it here, so you're using a null type ('unit' aka ()) just to fill the slot. otherwise, ignore it
07:33:21 <geekosaur> its sole value is spelled the same way as the type
07:33:32 <Psybur> Why use it if Im just going to ignore it?
07:33:56 <geekosaur> this is only if you use RWST instead of separate ReaderT and StateT
07:34:21 <geekosaur> RWST will be a little faster and a little easier to plumb, but you need to deal with a Writer slot you aren't going to use
07:34:53 <geekosaur> (RWS = Reader+Wrier+State all in one monad)
07:36:14 <cocreature> tbh, if you’re already in IO, just using an IORef and can be a lot simpler than messing with State
07:37:33 <Psybur> Now Im thinking what if I should use writer? I am doing a sliding window on a series of prices. Each window I might open new orders, and existing orders might be closed. And I might do IO operations each window when I open new orders. I was originally thinking it was looking like a StateT (OpenOrders,ClosedOrders,PriceWindow) IO NewOrders. But now Im thinking maybe PriceWindow doesnt belong in state, but should be pulled 
07:37:33 <Psybur> out into a writer. Since Im applying pricewindows and the state to the order logic
07:45:52 <greymalkin> Hi, I'm having trouble grokking arrows (specifically in regards to hxt) -- any suggestions of reference/research material?
07:50:43 <Psybur> cocreature, are you referencing the pattern in https://www.fpcomplete.com/blog/2017/06/readert-design-pattern ?
07:54:00 <cocreature> Psybur: not specifically, I’m just saying that storing your state in an IORef can be simpler than working with layers of monad transformers and if you’re already in IO anyway you’re not losing much
08:08:20 <michalrus> Hey, how can I read a file to Text in Dhall?
08:17:08 <michalrus> Anyway https://github.com/dhall-lang/dhall-haskell/issues/139
08:22:57 <monochrom> greymalkin: Try my http://www.vex.net/~trebla/haskell/hxt-arrow/index.xhtml
08:23:49 <greymalkin> tx monochrom, I'll take a look at it in a bit. I found `listA` which solved my current need.
08:24:26 <cocreature> greymalkin: fwiw you might also want to look at xml-conduit which at least I find significantly easier to use than hxt
08:25:12 <greymalkin> cocreature: Part of this is getting my head around arrows, too; As an alternative to Monads for some use-cases it's interesting.
08:25:57 <cocreature> fair enough, I never found a good usecase for arrows. hxt in particular could just as well use Monads and there is even an unfinished branch to switch the API to monads
08:28:50 <Fendor> where is the difference between forkOn and forkIO?
08:29:23 <cocreature> Fendor: have you read the docs? the docs for forkOn explicitely point out the difference to forkIO
08:30:44 <Fendor> cocreature, ok, then my true question is, if i call forkOn twice on the same processId, would it be possible that sideeffects caused by the first invocation are still present on the second call?
08:31:29 <Fendor> i would need to execute some kind of setup code for each thread spawned by +RTS -N 
08:32:33 <cocreature> Fendor: my processId you mean capability?
08:32:49 <cocreature> also what kind of side effects are we talking about here?
08:32:59 <Fendor> performance counters
08:33:30 <Fendor> side effects caused by a foreign function call
08:34:45 <maerwald> is "show" the only way to convert from Integer to Text? It feels wrong. But even pretty-print does it
08:36:56 <tdammers> maerwald: printf doesn't
08:38:17 <Fendor> cocreature, the docs from the c library says, i have to invoke a special function on every thread that should monitored. Since I am using the implicit parallalism of the GHC Runtime, i dont know how i would be able to call such a function on every thread that is being used, hence my weird questioning
08:38:30 <maerwald> tdammers: but, type safety :(
08:39:01 <fakenullie> Is something wrong with show?
08:39:07 <maerwald> yes, it's for debugging
08:39:25 <[exa]> trace?
08:39:54 <tdammers> maerwald: it does, however, use this: http://hackage.haskell.org/package/base-4.10.0.0/docs/Numeric.html#v:showIntAtBase
08:40:25 <maerwald> bah
08:42:28 * hackagebot git-annex 6.20170925 – manage files with git, without checking their contents into git – https://hackage.haskell.org/package/git-annex
08:43:23 <cocreature> Fendor: I don’t think forkOn is going to work here. the problem is that in unbound threads (which include those made by forkIO and forkOn) foreign calls might be made by a different thread. you can create bound threads using forkOS but I’m not sure how you can actually guarantee that an initializer is run on each capability.
08:44:39 <Fendor> cocreature, ok, thought the same, so it might be just not possible? or an idea where i could ask? ghc channel?
08:46:38 <cocreature> trying #ghc can’t hurt I guess :)
08:52:34 * hackagebot ekg-statsd 0.2.2.0 – Push metrics to statsd – https://hackage.haskell.org/package/ekg-statsd
08:53:07 <Fendor> cocreature, k, thanks :)
09:00:25 <inkbottle> I'm a beginner and I would like to learn about templates: what are they for? their syntax?...
09:00:53 <maerwald> I forgot how annoying it is to use with Text, is there nothing that allows me to do this simpler without enabling OverloadedStrings as a shotgun-solution?
09:01:06 <ezyang> inkbottle: https://wiki.haskell.org/A_practical_Template_Haskell_Tutorial seems like a decent start 
09:01:35 <maerwald> I've had very subtle bugs with OverloadedString before, I try to avoid it
09:01:51 <cocreature> inkbottle: what do you mean by “templates”?
09:02:00 <inkbottle> yes indeed
09:02:20 <inkbottle> I meant stacks template
09:02:40 <cocreature> the templates used for "stack new"?
09:02:47 <inkbottle> yes
09:03:27 <cocreature> take a look at the README here https://github.com/commercialhaskell/stack-templates
09:03:43 <inkbottle> OK, I do that
09:04:25 <cocreature> but there’s really not much too it. it’s just a way to specify the files created when you run "stack new myproject templatename" and the content of those files
09:04:25 <inkbottle> ezyang: thanks for the link, it will come handy, later
09:04:58 <inkbottle> yes, not much indeed
09:06:16 <inkbottle> cocreature: Oh, but you just gave the "definition" I was looking for, thanks
09:07:45 * hackagebot servant-purescript 0.9.0.0 – Generate PureScript accessor functions for you servant API – https://hackage.haskell.org/package/servant-purescript
09:07:45 * hackagebot apecs 0.2.2.0 – A fast ECS for game engine programming – https://hackage.haskell.org/package/apecs
09:10:24 <maerwald> tdammers: know any good printf lib for Data.Text?
09:25:16 <MichaelBurge> Contravariant has Divisible and Decidable subclasses, which can be interpreted as conjuctions and disjunctions. I'm trying to write the equivalent of implies, to get a short-circuiting for performance. Is this actually possible?
09:25:21 <MichaelBurge> I think this is the signature I want: https://hastebin.com/tagababixu.coffeescript
09:26:22 <tsahyt> oh wow, Chart is actually reasonably quick. I'm drawing directly to a cairo context provided by gi-gtk, and it resizes nice and smooth.
09:28:20 <sm> tsahyt: nice
09:28:45 <tsahyt> the executable size problem is rather massive with non-trivial GUI applications though. I'm up to 96M by now.
09:28:54 <tsahyt> I'll have to look into -split-objs or what it was called
09:30:14 <monochrom> Yeah, -split-objs. There is also a new one, -split-sections
09:31:28 <geekosaur> ...which is to be preferred as it is both more effective and much, much faster to link
09:31:40 <geekosaur> but is 8.2 only
09:31:56 <tsahyt> I see. Does stack have decent support for either of those by now? Last I checked there were some problems with -split-objs in stack
09:32:02 <geekosaur> (also more portable iirc)
09:32:13 <tsahyt> I suppose I can use cabal for building a binary for distribution
09:32:15 <geekosaur> that I don't know
09:32:33 <geekosaur> -split-sections might not need special support though
09:32:56 <tsahyt> as far as I understand, -split-objs requires rebuilding all dependencies too, right?
09:34:17 <cocreature> split-sections is even the default for 8.2 iirc
09:34:45 <monochrom> No.
09:35:37 <monochrom> I know the doc seems to say it is. But empirical experiments refute it. I still have to add -split-sections by hand.
09:35:52 <cocreature> ah ok, good to know
09:36:04 <maerwald> sad, formatting also depends on OverloadedStrings somewhat
09:36:20 <cocreature> monochrom: hm https://git.haskell.org/ghc.git/commitdiff/8f71d9581ee0a1826c0105e51a7048f0c7669492
09:36:25 <cocreature> that looks like it is the default?
09:36:44 <cocreature> maybe you have a bindist that explicitely disables it?
09:37:25 <geekosaur> tsahyt, I don't think so
09:37:54 <monochrom> My bindist is straight from GHC website and the one for x86_64 deb8.
09:37:56 <geekosaur> you may not gain as much if the deps aren't also -split-objs
09:38:20 <geekosaur> but it's expensive enough that, unless some dep is fairly large, it's not worth it
09:38:31 <geekosaur> which is why only base is built that way normally
09:38:51 <monochrom> And don't forget the ambiguity of the sentence. Is it "every time you run GHC it does -split-sections"? Is it "the libraries that come with GHC were built with -split-sections"?
09:39:15 <cocreature> hm good point
09:39:38 <geekosaur> that code looks like the code that builds base etc. --- bootlibs --- with SplitObjs
09:39:46 <geekosaur> so I'd go with the latter
09:40:07 <monochrom> This is why empirical tests are so valuable.
09:40:55 <cocreature> hm, when I’m compiling a hello world, I’m getting the exact same file size with -split-sections and without it
09:41:09 <maerwald> afair Cale wrote a printf library too with odd types, I forgot what it was
09:41:36 <geekosaur> cocreature, that's not a good test unless your program also includes dead code.
09:41:47 <geekosaur> otherwise you're testing whether base was built with split-sections
09:42:04 <geekosaur> (and the patch says it likely was)
09:42:32 <cocreature> geekosaur: so -split-sections for libs has an effect even if you’re not compiling your executable with -split-sections?
09:43:00 <monochrom> You need to build a huge library like lens, with or without -split-sections. Then you test with a hello world exe that depends on lens but doesn't really use anything.
09:43:09 <geekosaur> if a library you link against was built with split-sections, then it can be dead-code-stripped
09:43:16 <monochrom> But that's an expensive test.
09:43:27 <cocreature> yeah I think I’m too lazy for that now :)
09:43:29 <geekosaur> if you code was built with split-sections, then *it* (but not libraries!) can be dead-code-stripped
09:43:46 <geekosaur> ...unless htose libs were also built with -split-sections
09:43:55 <monochrom> A much cheaper test is to build anything with or without -split-sections, then use readelf -S
09:44:31 <cocreature> geekosaur: what I was trying to say is that I expected that while libs _can_ be dead-code-stripped, dead-code-stripping is off if I don’t use -split-sections for linking the executable
09:45:33 <geekosaur> no? this controls whether the lib is built in a way that allows dead code stripping to work. the linker strips dead code by default, and you want that --- expect non-haskell libs to break or cause odd linking issues otherwise
09:45:50 <cocreature> ok, thx :)
09:45:57 <cocreature> linking will forever remain a mystery to me :)
09:46:06 <geekosaur> well, perhaps not expect. it is possible especially in the presence of otherwise circular references
09:47:06 * hackagebot texbuilder 0.1.0.1 – View your latex output while editing – https://hackage.haskell.org/package/texbuilder
09:48:16 <geekosaur> static linking (which is where this is relevant; shared libs are single chunks, but given that they are shared this doesn't matter as much) is fairly complex
09:50:22 <monochrom> Here is how to test. Write some module F.hs = module F where ...  put some random function definitions there.
09:50:37 <geekosaur> default behavior: if a file entry in a static archive is referenced by a symbol it defines, it will be included in the resulting object. this requires reading and remembering symbols for archive members. making the individual members smaller results in more compact output but slower link times; making them larger makes for larger but gfaster output
09:50:48 <geekosaur> haskell default is the latter, split-objs is the former
09:51:02 <monochrom> ghc -O -fforce-recomp -c F.hs -o xxx.o
09:51:22 <monochrom> ghc -O -fforce-recomp -c -split-sections F.hs -o yyy.o
09:51:50 <geekosaur> split-sections is: each function is put into its own section. linker is told to build the final object by concatenating all such sections where symbols are referenced and discard the rest. single objects can have multiple sections
09:52:03 <monochrom> Now compare "readelf -S xxx.o" with "readelf -S yyy.o". The latter has more sections. The extra sections are one per function you defined in F.hs
09:52:12 <geekosaur> so you get the speed of larger individual archive entries but the fine control of smaller entries
09:54:00 <geekosaur> it's also faster because static archive search, even with archive symbols tables, is slow and done per undefined symbol at the point the archive is encountered. combining sections is done all at once at the last step of linking
09:54:21 <monochrom> You should also observe -split-objs. You will get, in addition to F.o, a F_o_split directory full of moar *.o's.
09:54:35 <monochrom> Basically one extra *.o per function.
10:01:12 <cocreature> alright, looks like -split-sections is (sadly?) not the default on my system either. thanks for all the info!
10:02:12 * hackagebot dom-parser 3.0.0 – Simple monadic DOM parser – https://hackage.haskell.org/package/dom-parser
10:02:12 * hackagebot miso 0.8.0.0 – A tasty Haskell front-end framework – https://hackage.haskell.org/package/miso
10:03:13 <monochrom> But you should also do a "readelf -S /usr/local/haskell/ghc-8.2.1-x86_64/lib/ghc-8.2.1/base-4.10.0.0/libHSbase-4.10.0.0.a" or whatever the path is on your computer.
10:03:37 <monochrom> This shows you whether your copy of base was built with -split-sections or not.
10:05:52 <monochrom> You can also quickly whip up a cabalized library project and build with "cabal install --ghc-options=-split-sections" vs just "cabal install" and use readelf -S to compare their respective *.a's
10:06:59 <cocreature> so what are the downsides of -split-sections? bigger archive files?
10:06:59 <monochrom> I now put "ghc-options: -split-sections" in my $HOME/.cabal/config. What can possibly go wrong!
10:07:11 <monochrom> I think there is no downside.
10:07:19 <geekosaur> I think that's fine
10:07:45 <geekosaur> it's off by default currently because they want to see it in the real world on a wide range of codebases before making it default for anything but bootlibs
10:08:05 <geekosaur> but iirc the intent is to make it the default once it's gotten that wide testing
10:08:16 <cocreature> looks like https://ghc.haskell.org/trac/ghc/ticket/11445 is the tracking issue
10:08:25 <cocreature> (for making it the default)
10:15:00 <raynold> ahh it's a wonderful day
10:31:01 <woodson> Hi everyone, 
10:31:01 <woodson> Can anyone help me understand how to save state in memory?
10:31:02 <woodson> For example in elixir/erlang I can save a state in a genserver (thread that acts like a message passing) and I can perform async and syn call. In haskell there is the State monad but I think this just acts like passing your state over to a fuction over and over. However, if I want to all multiple threads to just access a state is there an abstraction for it? 
10:32:10 <rblaze> woodson are you looking for the mutable shared state between threads?
10:32:29 <cocreature> woodson: store it in an MVar or a TVar
10:32:48 <woodson> yes im trying to connected dots by referring to what i learning in elixir/erlang
10:33:24 <woodson> so yes it would be a mutable shared state between threads has long as the module has access to the share module
10:34:01 <rblaze> woodson: in short, use STM monad. For the simplest cases, MVars. In long, read this chapter: http://chimera.labs.oreilly.com/books/1230000000929/pt02.html
10:34:56 <rblaze> There are some patterns you don't want to reinvent by trial and error.
10:36:38 <ggVGc> rblaze: that's why you first go to uni and study type theory for 10 years, and then reinvent thm
10:36:42 <ggVGc> (by trial and error)
10:39:03 <woodson> rblaze: Thanks for the links looks interesting
10:39:26 <nickhs> Hi, I was hoping to better understand why this (toy case) doesn't compile http://lpaste.net/358708 - but inlining the putStrLn does?
10:39:30 <woodson> quick question does haskell provide an abstract to perform these task like elixir/erlang?
10:39:55 <woodson> i see that you wrote "There are some patterns you don't want to reinvent by trial and error"
10:40:14 <woodson> are you referring to the abstractions ?
10:40:47 <cocreature> nickhs: you mean inlining the putStrLn in line 26?
10:42:02 <nickhs> @cocreature correct (and commenting out logger)
10:42:03 <lambdabot> Unknown command, try @list
10:42:38 <cocreature> nickhs: envLog needs to have type "String -> IO ()" and that’s the type of "putStrLn" so that’s the reason why things compile in that case
10:43:20 <cocreature> nickhs: the reason why it doesn’t compile without inlining is that you have given "logger" a more general type signature, namely "String -> m ()" (and a bunch of constraints on m)
10:43:20 <nickhs> cocreature: sure, but pretend the logger had to fetch some value from the reader
10:43:54 <cocreature> nickhs: you can use liftIO to get from IO a to MonadIO m => m a which is what you need here
10:45:32 <nickhs> cocreature: hmm that does work, thanks
10:46:52 <cocreature> nickhs: it’s like saying that something has type "Num a => a" but then giving it something of type Int. Int is an instance of Num but by declaring the type as "Num a => a" you are saying that the _user_ of this definition can choose "a" and in particular they can choose something other than "Int"
10:48:55 * hackagebot amqp-utils 0.2.1.5 – Generic Haskell AMQP Consumer – https://hackage.haskell.org/package/amqp-utils
10:56:21 <gleachkr> ????????????????????????????????????????????????????????????jkjjjjjjj/buffer close
11:00:51 <hydraz> you tried
11:02:04 <nickhs> err sorry, cocreature you're right that solves the first type error. However I still don't understand why I'm getting the second type error http://lpaste.net/358708#line52
11:05:19 <cocreature> nickhs: logger has type "(MonadReader Env m, MonadIO m) => String -> m ()", envLog has type "String -> IO ()", so GHC first figures out that m~IO and then it tries to satisfy the constraints. IO is an instance of MonadIO so that’s fine but IO is not an instance of "MonadReader Env" so that’s what the error is trying to tell you
11:05:28 <cocreature> nickhs: you can just remove that constraint from the type signature
11:09:07 <nickhs> cocreature: that makes sense, I tried it like this and got back a different error however http://lpaste.net/358709
11:09:50 <cocreature> nickhs: well you still haven’t removed the "MonadReader Env" constraint from "logger"
11:12:16 <monochrom> logger doesn't even use any of the MonadReader methods.
11:12:29 <nickhs> cocreature: sorry I wasn't clear, what if I wanted to fetch something from the Env in the logger
11:12:41 <nickhs> (I realize now that it's not in the example)
11:13:00 <cocreature> nickhs: then you’ll need a "MonadReader Env m" constraint in the type of envLog
11:13:05 <monochrom> Then the definition of Env needs to change.
11:13:15 <cocreature> or some concrete monad that is an instance of MonadReader Env
11:13:41 <monochrom> This is beginning to look like premature generalization.
11:13:52 <monochrom> Either that, or two conflicting generalizations.
11:14:20 <monochrom> Both are signs of OOP thinking anyway.
11:16:06 <nickhs> monochrom: I'm tried to slim down the case to better understand, imagine the logger needs to read a `logPrefix :: String` from the Env object or something
11:17:07 <erisco> Are you showing the signs of OOP thinking? See your functional programologist.
11:17:13 <monochrom> heh
11:18:12 <monochrom> Imagined.
11:19:21 <jocker> hi
11:20:40 <maerwald> I am looking for a printf-like (not necessarily the exact syntax) library that is a) properly typesafe, b) doesn't depend on OverloadedStrings and c) allows easy use of Data.Text and String literal mixing
11:21:09 <erisco> and the one in base doesn't qualify?
11:21:26 <maerwald> as properly typesafe? definitely not.
11:21:56 <erisco> do you mean so that formatting options are valid for the type of data given?
11:22:14 <maerwald> like... code that doesn't crash
11:22:25 <jocker> hi
11:22:43 <erisco> what about the printf in base is not typesafe by your standard, then?
11:23:03 <monochrom> maybe https://hackage.haskell.org/package/category-printf
11:23:11 <jocker> hi
11:23:14 <jocker> ??
11:23:20 <monochrom> But I'm too lazy to check (b) and (c).
11:23:31 <monochrom> I think (b) and (c) contradict each other anyway.
11:23:45 <maerwald> ah, that's the cale lib I forgot the name of
11:23:52 <jocker> no
11:23:56 <maerwald> I don't think that's contradictory at all
11:24:05 <maerwald> OverloadedString is kinda randomly inserting function calls
11:24:16 <maerwald> everywhere where it finds IsString
11:24:18 <maerwald> not what I want
11:24:19 <monochrom> OK I think I see.
11:24:40 <maerwald> had non-trivial trouble with that when using Glib bindings once
11:24:43 <jocker> bot fuck you
11:24:54 <maerwald> which bot?
11:24:58 <monochrom> Anyway I did https://hackage.haskell.org/packages/search?terms=printf
11:25:45 <jocker> ??
11:25:48 <nickhs> great, so that all works. Now when I try and generate lenses however I end up with this scaryish looking type error? http://lpaste.net/358710#line51
11:25:50 <jocker> your real
11:25:57 <maerwald> lolwat
11:25:58 --- mode: ChanServ set +o monochrom
11:26:12 --- mode: monochrom set -o monochrom
11:28:44 <erisco> that library is certainly one to study
11:28:47 <maerwald> meh, is Cale not on github? there is no repository information. Tarballs... oldschool really
11:29:08 <maerwald> odd types were to be expected
11:29:09 <monochrom> I don't actually know whether Cale's satisfies all of your requirements, but it looks like it's the closest in existence.
11:29:14 <erisco> I also wonder what you might do with singletons and OverloadedStrings
11:29:27 <erisco> particularly if you can get a type level representation of the string
11:29:46 <cocreature> the problem is that type-level strings are opaque
11:29:51 <cocreature> you can’t analyze them
11:29:57 <erisco> really? shame
11:30:25 <monochrom> I think more recently you can finally concatenate them.
11:30:47 <cocreature> yeah but that doesn’t help here, you would need a way to decompose them
11:31:02 <erisco> even with those hurdles overcome, it is always an issue to have adequate inference ... at least in my experience of implementing such things
11:31:38 <cocreature> category-printf is cute because it gets away without any complicated type-level stuff
11:31:41 <erisco> I realised a couple days ago you cannot introduce new variable bindings with a type family
11:32:11 <erisco> that's a big problem for having good inference
11:32:39 <monochrom> I would count crazy classes and having four type variables as complicated type-level stuff.
11:33:03 <maerwald> he exports (.) 
11:33:07 <maerwald> oh boy
11:33:20 <erisco> it is essential to the library
11:33:37 <monochrom> Oh it's re-export of Control.Category.(.)
11:33:44 <cocreature> monochrom: maybe complicated is not the right word but it doesn’t need a lot more than Haskell98 iirc
11:33:50 <monochrom> Or is it (Control.Category..)?
11:33:59 <erisco> the latter, monochrom
11:34:03 <monochrom> \∩/
11:34:29 <erisco> totally unconfusing notation amirite
11:34:36 <the_2nd> When buying the Haskellbook.com , is there also a print version? Will there ever be one?
11:34:39 <monochrom> Anyway there is a reason the name is Control.Category.Printf
11:35:17 <maerwald> that's just calling for trouble :>
11:36:15 <maerwald> type errors look fascinating
11:36:41 <maerwald> those that the Hello World example throws xD
11:36:44 <Tuplanolla> > [Prelude.not Prelude..Prelude.not$prelude|prelude<-[Prelude.False ..Prelude.otherwise]]
11:36:47 <lambdabot>  [False,True]
11:37:15 <monochrom> Congratulations Tuplanolla \∩/
11:37:57 <monochrom> A Haskell expression now looks like a Windows library symbol.
11:38:56 <tdammers> maerwald: unfortunately, no
11:38:58 <maerwald> definitely does not satisfy c)
11:39:17 <maerwald> it seems I'd have to explicit still convert string literals
11:40:10 <maerwald> wonder if one could hijack the combination operator and inject string -> text conversion
11:40:41 <maerwald> actually, that should be resolved by the result type!
11:41:04 <maerwald> probably need edward here :P
11:41:36 <maerwald> but then it's all Profunctors and Spaceships
11:42:14 <tester123> Q: Is there a way to jump to instance definitions in Emacs? Intero jumps to class definitions, which aren't useful.
11:42:36 <monochrom> I think no.
11:43:19 <maerwald> I think the only alternative is TH and I dislike that even more than OverloadedStrings
11:43:20 <monochrom> But use ghci's ":info Int" or ":info Num" to see which file has it.
11:43:22 <erisco> I don't understand (c)… if you do not want to write in Text.pack, and you do not want overloaded Strings, I fail to find what you actually want
11:43:46 <maerwald> erisco: as I said, OverloadedStrings does way more than just converting string literal to text 
11:44:00 <erisco> so, then, what?
11:44:15 <maerwald> I don't like shotgun approaches and have had trouble with that before
11:44:18 <monochrom> erisco: Suppose x::String and y::Text. Presumably there is a way "f x y x ..." could work by a mixture of type inference and instance selection etc.
11:45:02 <erisco> an OverloadedStrings exclusively for String to Data.Text conversion?
11:45:06 <maerwald> kind of
11:45:32 <maerwald> but maybe even more precise
11:45:46 <maerwald> OverloadedStrings is for a whole module, it's not even clear I want that at all times
11:45:59 <maerwald> currently I want it for all printf-like stuff I do
11:46:04 <maerwald> for the other stuff, I don't know, depends
11:46:48 <maerwald> or stop fighting in give in to String :/
11:46:56 <erisco> having smaller contexts (smaller than a file) for extensions might be nice
11:47:38 <tester123> Is there a way to load ALL source code of all dependencies into a stack project so that Intero can jump to any definitions (including external definitions)?
11:47:40 <erisco> and you can perhaps have contextual implicit conversions, too
11:47:47 <erisco> for your String to Data.Text conversion
11:47:47 * tabemann wishes there were an OverloadedLists extension
11:48:01 <cocreature> tabemann: there is
11:48:03 <hydraz> I mean..
11:48:20 * maerwald closes his eyes and plugs gis ears
11:48:32 <hydraz> tabemann: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overloaded-lists
11:48:46 <erisco> this may be more generally seen as a weakness in Haskell modules…
11:49:03 <monochrom> Yeah go Backpack
11:49:11 <tabemann> nice
11:49:16 <johnw> does anything use backpack yet?
11:49:23 <monochrom> I think no.
11:49:27 <tabemann> so now I can stop putting fromList before all my list, well, literals
11:49:28 <erisco> what is Backpack?
11:49:45 * tabemann is a fan of Data.Sequence
11:50:21 <erisco> an Edward (I wonder who) special for modules, I see
11:50:34 <MarcelineVQ> yang in this case
11:51:17 <monochrom> You will want to either read the thesis https://github.com/ezyang/thesis/releases or try out http://blog.ezyang.com/2017/01/try-backpack-cabal-packages/
11:52:00 <monochrom> And don't be turned off by the word "thesis". It's Chapter 2 is a very pragmatic tutorial.
11:52:30 <MarcelineVQ> haskell related ones tend to be for some reason or another
11:52:31 <monochrom> But in short it's mixins at the module or package level.
11:53:12 <monochrom> I think because their authors actually join #haskell? :)
11:53:37 <monochrom> The way you write is affected by the kind of people you hang out with. You end up writing for them.
11:54:37 * hackagebot propellor 4.8.0 – property-based host configuration management in haskell – https://hackage.haskell.org/package/propellor
11:54:38 <monochrom> #haskell is a healthy mix of we-want-theory and we-also-want-working-code.
11:54:50 <erisco> well, if you can use that to introduce a new context, for things like imports, extensions, etc
11:55:04 <Tuplanolla> On that note, I might have just gotten myself into doctoral studies involving Haskell.
11:55:17 <johnw> Tuplanolla: congrats!
11:55:33 <erisco> seems sensible that if you added general implicit conversions (a generalisation of all these Overloaded* extensions) that you could also contextualise these
11:55:53 <Tuplanolla> Thanks, johnw.
11:56:08 <monochrom> However, Backpack doesn't give you scoping within a few lines of code. It's at the module/package level, so it's even more coarse-grained.
11:56:24 <erisco> I am not particularly fond of implicit conversions but seeing the utility of OverloadedStrings and OverloadedLists there are clearly some situations to warrant them
11:56:44 <monochrom> But what it can relief is it can get rid of some classes so at least you no longer worry about globally-existing instances.
11:57:30 <cocreature> erisco: OverloadedStrings and OverloadedLists are not really implicit conversions. they just make literals polymorphic. if there is a non-literal of type String it won’t be converted.
11:57:52 <cocreature> it’s similar to the situation we have for numeric literals
11:57:54 <erisco> yes but implicit conversions generalises this, as I said
11:58:03 <Tuplanolla> I won't be direct collaboration, however, because my name prevents me from being absorbed into the Simon--Edward condensate.
11:58:49 <monochrom> Also, if you decide to follow the "try backpack: cabal packages" tutorial, don't worry about its "in the last post".
11:58:55 <erisco> whether you could regain the specificity… that'd require some extra hokey business
11:59:24 <monochrom> The "last post" plays with an intermediate language you won't ever use.
12:00:32 <ezyang> monochrom: You think I should deemphasize it in the post? 
12:00:36 <maerwald> I think a pragmatic approach would be to have a per-type module and import the combination operator from there, which then converts string literals to the module type
12:01:02 <monochrom> Although, if you finally worry about "what's the actual semantics of 'mixins: XXX(A as B) requires YYY(C as A)'", then that will be a good time to learn the intermediate language.
12:01:46 <erisco> while we're at it, why not add more powerful syntactical definitions
12:01:58 <monochrom> No, I think you should have written the two articles in the other chronological order. :)
12:02:08 <erisco> mixfix, and if we're adventurous, what if we could define new literal notations? hm? :)
12:02:20 <monochrom> Anyway I think you'll be happy to know I'm now convinced and converted. :)
12:02:26 <ezyang> monochrom: Haha 
12:02:32 <ezyang> monochrom: That's really good to hear! 
12:02:59 <monochrom> Because I actually read the damn thesis. OK, I only read chapters 2 and 3. And for 3, only a little bit.
12:03:02 <ezyang> I'd always be happy to hear about your experiences, if you ever decide to write it up (or just chat about it) 
12:03:07 <monochrom> You have many typos.
12:03:19 <ezyang> uh oh! 
12:03:31 <monochrom> There is a place you wrote "Section 5" or I forgot what the number is but it should be "Chapter 5".
12:03:50 <monochrom> Sometimes the pictures say "Reg" and the code says "Regex" or something like that.
12:03:53 <lambdamu> Is there any way to make cabal link against static libraries (either .o or .a) that works in ghci, too? I can add them to ld-options, but that doesn't work in ghci. The only thing that works also in ghci, is adding c-sources if the object file would habe been derived from a c-file
12:04:38 <ezyang> monochrom: Duly noted 
12:04:47 <lambdamu> Im surprised there seems no way to do this as this seems to be the most straightforward way to integrate arbitrary foreign code in a portable manner
12:05:14 <monochrom> Anyway I toy-demoed Backpack (the end-user Cabal story) in the Toronto meetup last week.
12:05:34 <c_wraith> how did that go?
12:06:20 <monochrom> Oh, we liked it. We only argued over "aren't type classes enough?"
12:06:49 <c_wraith> not even with data families.
12:07:01 <monochrom> But of course ezyang already wrote enough about the horrors of sticking to type classes in the thesis and on the blog.
12:07:26 <monochrom> I personally think the regex type class fiasco is very convincing.
12:08:56 <monochrom> Also look at https://hackage.haskell.org/package/category-printf and its Control.Category.Printf.{String, ByteString.{Lazy, Strict}, Text.{Lazy, Strict}} and you feel like this could use some Backpack help.
12:09:40 <erisco> cocreature, a simple idea is to give new types to literals, and add a default implicit conversion for compatibility. For example,  "hello world" :: StringLit  and default implicit  StringLit -> String
12:11:47 * hackagebot ghcjs-fetch 0.1.0.0 – GHCJS bindings for the JavaScript Fetch API – https://hackage.haskell.org/package/ghcjs-fetch
12:15:11 <MichaelBurge> What's the language extension to make this work? https://hastebin.com/pixoteyati.vbs
12:16:28 <byorgey> MichaelBurge: that instance does not make sense.  I think you mean   instance Semigroup (Function' a) where ...
12:16:37 <byorgey> in which case you need TypeSynonymInstances
12:16:48 <johnw> monochrom: and everything else that's split across all the various string types, like parsec
12:17:18 <byorgey> MichaelBurge: that error message is telling you that there is a kind mismatch, which language extensions cannot fix =)
12:17:38 <monochrom> Yeah it hurts the parsec and megaparsec depend on bytestring and text, especially if/when a user doesn't really use one of them.
12:21:55 <monochrom> In the aspect of writing down an API (just the interface, not the implementation), type class vs Backpack sigs represents centralized vs decentralized.
12:24:06 <monochrom> A group of people are surrounding an elephant and interacting with it.
12:24:26 <maerwald> ok, this sounds like a horror movie
12:24:36 <pikajude> "interacting" with the elephant
12:24:40 <monochrom> One of them says, "as far as I'm concerned, the elephant has a big flappy ear and that's all I care".
12:24:49 <zachk> are they each going to take one bite of the elephant?
12:25:04 <monochrom> Another of them says, "as far as I'm concerned, the elephant has a big trunk nose and that's all I care".
12:25:11 <monochrom> And so on so forth.
12:25:21 <johnw> https://en.wikipedia.org/wiki/Blind_men_and_an_elephant
12:25:23 <cocreature> let’s hope the ear and the nose don’t collide
12:25:25 <maerwald> and then they eat the elephant!
12:26:04 <monochrom> They don't have to pool all those aspects into one single type class. They don't have to design that type class by committee or dictatorship.
12:26:06 <pikajude> no, they all beat each other up
12:26:13 <pikajude> because they are all lying about the elephant
12:26:44 <maerwald> I think the problem is that starting a story with "people are surrounding an elephant and interacting with it" is just way too polymorphic :>
12:27:00 <tdammers> people are way too polymorphic
12:27:01 <pikajude> respect to the elephant for remaining so calm though
12:27:11 <johnw> I ponder the passivity of the elephant in all of this
12:27:13 <tdammers> talk about the elephant in the room
12:27:19 <johnw> yes, pikajude, exactly :)
12:27:37 <monochrom> They can each go off to write just each person's take in separate signature files, and let Backpack do the union. And when a new person comes in with a new angle, this can be added or ignored at a whim as you see fit, you don't have to modify an existing type class.
12:28:22 <MichaelBurge> byorgey: Thanks - I think I briefly confused MultiParamTypeClasses with some kind of implicit type-level forall, by analogy with terms. 
12:28:31 <pikajude> if only Indian people had had GHC 8.2 handy 2,100 years ago
12:28:37 <pikajude> they could have solved the elephant issue much more easily
12:28:38 <monochrom> haha
12:29:12 <maerwald> I think they were more advanced in intuition and less so in useless technical details!
12:29:35 <monochrom> No no.
12:29:36 <pikajude> "My friends," said the seventh man, who had remained quiet. "Worry not, for we can simply use the package manager's constraint solver to perfectly describe the elephant."
12:29:56 <maerwald> and then the depgraph was circular :>
12:29:59 <monochrom> They were more advanced in unusable intuition and less so in useless technicality.
12:29:59 <johnw> "Six blind elephants were discussing what men were like. After arguing they decided to find one and determine what it was like by direct experience. The first blind elephant felt the man and declared, 'Men are flat.' After the other blind elephants felt the man, they agreed."
12:30:32 <monochrom> hahaha johnw. Where did you find this?
12:30:37 <erisco> that's great
12:30:48 <johnw> monochrom: that Wikipedia page I linked to above
12:30:51 <pikajude> that's what happens when an elephant "interacts" with a human
12:30:53 <monochrom> Oh!
12:31:25 <parsnip> so, software flattens people?
12:31:34 <maerwald> technology flattens people!
12:31:47 <pikajude> "Elephant jokes were a fad in the 1960s, with many people constructing large numbers of them according to a set formula."
12:31:55 <pikajude> will the next GHC major version release have an elephant joke generator?
12:32:12 <maerwald> we still have no mascot for haskell
12:32:16 <maerwald> how about an elephant
12:32:20 <erisco> a blind elephant
12:32:26 <maerwald> who flattens people
12:32:26 <johnw> awesome
12:32:36 <pikajude> we could take the Haskell logo and replace the arms of the logo with elephants
12:32:53 <maerwald> know it's going the horror-direction again
12:32:56 <maerwald> *now
12:32:57 <greatgig1> hey, can I ask for a quick help?
12:33:05 <hydraz> ask away
12:33:07 <pikajude> sure
12:33:14 <pikajude> maybe we should take this discussion to #haskellephants
12:33:35 <johnw> next up: Elephantom Types
12:33:42 <hydraz> yes.
12:33:44 <monochrom> haha
12:33:51 <greatgig1> I'm learning haskell (first few days) and I wanted to design a function that sums the first N elements of a list
12:34:08 <maerwald> elephentable effects
12:34:13 <shloub> https://imgur.com/a/5fAwP
12:34:23 <greatgig1> I dunno what I'm doing wrong :(
12:34:38 <erisco> I sense this should be a secret society
12:34:42 <cocreature> greatgig1: you’ll have to show us some code and the error you’re seeing
12:34:42 <hydraz> greatgig1: what code do you have right now?
12:34:53 <zachk> > let f list = \x->sum . take x $ list in f [1..10] 5
12:34:56 <lambdabot>  15
12:35:04 <hydraz> why the \x
12:35:19 <zachk> just the way I thought it up 
12:35:21 <[exa]> more syntaxes!
12:35:31 <greatgig1> http://lpaste.net/358714#a358714
12:35:33 <hydraz> haha, fair
12:35:34 <parsnip> > let f xs = 42 in f [1..10]
12:35:38 <lambdabot>  42
12:36:09 <maerwald> :t e l e p h a n t
12:36:12 <lambdabot> error:
12:36:12 <lambdabot>     • Couldn't match expected type ‘Expr
12:36:12 <lambdabot>                                     -> Expr -> Expr -> t0 -> Expr -> Expr -> Expr -> t’
12:36:14 <maerwald> wat?
12:36:15 <cocreature> greatgig1: so the first error is that you need parenthesis around (x:xs)
12:36:28 <[exa]> greatgig1: how much is sum of 0 numbers?
12:36:29 <greatgig1> Oh!
12:36:41 <greatgig1> hmmm
12:36:47 <greatgig1> Also a good point
12:37:04 <Ferdirand> also, how do you want your function to behave if the list contains less than n numbers ?
12:37:06 <monochrom> http://learnyouahaskell.com/  had an elephant before it was cool.
12:37:12 <cocreature> greatgig1: I don’t understand what exactly you’re trying to do in the second line. can you explain that in english?
12:37:31 <zachk> are you guys trying to say haskell is the elephant in the room?
12:37:38 <pikajude> no
12:37:46 <erisco> it was planted there as a secret communication between Haskellephants
12:37:48 <greatgig1> You guys are making too much sense
12:37:50 <[exa]> greatgig1: it seems that you kindof lured yourself into decomposing the list that is already decomposed to head/tail, try it just with recursing to tail
12:38:15 <[exa]> greatgig1: i.e. without using `head` and `tail` explicitly
12:38:17 <parsnip> cocreature: i think the line is doing like `[3, 5, 7] ==> [8, 7]`
12:38:33 <greatgig1> Yes, that's what I wanted to do
12:38:47 <monochrom> I don't think it's a good idea.
12:38:49 <cocreature> that seems like a weird way to go about this
12:38:49 <parsnip> i think write `x:y:ys`
12:39:10 <greatgig1> parsnip: Can I do this?!
12:39:17 <zachk> @source take
12:39:17 <lambdabot> Unknown command, try @list
12:39:21 <zachk> @src take
12:39:21 <lambdabot> take n _      | n <= 0 = []
12:39:21 <lambdabot> take _ []              = []
12:39:21 <lambdabot> take n (x:xs)          = x : take (n-1) xs
12:39:32 <monochrom> Don't try to put your intermediate answer back into the list.
12:39:34 <Ferdirand> are you allowed to split it into two functions ? one that takes the first n elements, and another that computes the sum ?
12:40:19 <parsnip> greatgig1: what is the actual error?
12:40:21 <greatgig1> I am allowed to do anything :) 
12:40:43 <greatgig1> It was the parse error at first, but it didn't give me much
12:40:49 <parsnip> greatgig1: seems you're going to get into trouble when the tail gets short
12:40:52 <greatgig1> now I'm trying to do what was suggested here
12:40:57 <parsnip> oh, good
12:41:28 <[exa]> greatgig1: also, why would you accumulate the numbers in the beginning of the list (and not create a separate accumulator for the sum?)
12:41:28 <greatgig1> Thank you a lot guys, when I come up with the better function I'll paste the answer :)
12:41:29 <erisco> artificial restrictions are the worst…
12:42:27 <hexagoxel> pikajude: yeah, there will be a generic joke generator in ghc. they already introduced "levity polymorphism" in preparation for this.
12:42:28 <greatgig1> [exa]: I just wanted to keep the list until I had my answer, trying to solve it with the limited knowledge I know
12:43:16 <zachk> you might want to use a helper function as your main workhorse and try using an accumulator variable that you return when xs == []
12:44:16 * hackagebot checkmate 0.2.1 – Generate checklists relevant to a given patch – https://hackage.haskell.org/package/checkmate
12:44:45 <kakashiAL> in javascript I saw something like this: Box(' foo').map(s = s.trim()).map(s => s.length).map(n => n + 2)
12:44:53 * maerwald suggests to replace fmap with elephmap
12:44:59 <kakashiAL> my question is how do you call this "Box" in haskell?
12:45:25 <zachk> a functor?
12:46:35 <[exa]> greatgig1: general pattern for transforming an accumulator-less function to one with accumulator is this: `sumFirstN n list = sumFirstNAcc 0 n list' (and continue with implementing `sumFirstNAcc a n (x:xs)' )
12:46:49 <maerwald> zachk: elephunctor
12:46:54 <Psybur> So I have windows of prices. Each window I consume (OpenOrders,ClosedOrders) and produce another (OpenOrders,ClosedOrders). I have an Env I want to pass between windows. I also want to Log what goes on each window. And each window I want to be able to perform IO. Does this sound like I need a combination of foldM on the windows and using RSWT?
12:47:05 <kakashiAL> zachk: yes a functor, I thought they calling it Box :)
12:47:29 <kakashiAL> one very stupid question, but I dont see the benefits of composition :(
12:47:39 <kakashiAL> many examples show stuff like that:
12:48:09 <kakashiAL> compose(add, multiply)  <---now you have a function that multiplies and add
12:48:10 <erisco> maerwald, you seem to like this elephant thing a lot, so I put you in charge of authoring the acme-elephant package, for all proboscidea needs.
12:48:20 <Psybur> forM windows $ \w -> do ??? profit? :D
12:48:24 <maerwald> I will dedicate my life to it
12:48:58 * ystael looks forward to the replacement of hackage and stackage by pachyage
12:49:40 <johnw> ystael++
12:50:20 <maerwald> it will probably require a lot of unicode hackery to make this useful though, so we can replace (.) by elephant symbols
12:50:26 <mizu_no_oto> > map ((* 2) . (+ 1)) [1,2,3,4,5]
12:50:29 <lambdabot>  [4,6,8,10,12]
12:50:29 <zachk> :t (.)
12:50:31 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:50:34 <mizu_no_oto> kakashiAL: ^
12:50:38 <zachk> @src (.)
12:50:39 <lambdabot> (f . g) x = f (g x)
12:50:59 <mizu_no_oto> composition is nice when you're passing the composed function to something.
12:51:44 <kakashiAL> mizu_no_oto: you dont get my point :)
12:52:01 <kakashiAL> I studied math, I know that composition is, its rules and so on
12:52:15 <kakashiAL> but in a programming point of view
12:52:25 <kakashiAL> I dont see the need or a function compose()
12:52:45 <erisco> did you find a use in math?
12:53:29 <erisco> you're going to have a challenge with your argument when we have hundreds of thousands of lines of code on Hackage using function composition
12:53:52 <maerwald> only counting the direct use?
12:53:55 <mizu_no_oto> kakashiAL: Which is nicer: "map ((* 2) . (+ 1))" or "map (function (x) { val x' = x + 1; val x2 = x * 2; return x2;})"?
12:53:57 <kakashiAL> erisco: could you give me maybe a realworld example (comming from a webapp or such)
12:54:13 <[exa]> kakashiAL: it kills parentheses. this ain't no lisp.
12:54:54 <erisco> this is like asking for a real world example of why you'd declare a variable … I don't even know … you just do it all the time
12:55:13 <[exa]> kakashiAL: also it's a kind-of reverse representation of "pipeline" (unixish |find|grep|awk becomes awk.grep.find)
12:55:29 <kakashiAL> hmm....I need to give it more time
12:55:59 <kakashiAL> at the moment, if I need a function, I think of its input, and in its body, I use this inputs and user other functions
12:57:37 <maerwald> body?
12:58:51 <zachk> function body, (I think he means)
12:58:58 <maerwald> I think getting rid of the body image is a good start, we don't write function bodies, we define functions
12:58:58 <[exa]> in haskell russia, functions are inputs
12:58:59 <greatgig1> thanks for the help, I think this is the final solution I wanted http://lpaste.net/358715
12:59:43 <[exa]> greatgig1: wait a sec, what about a challenge?
12:59:48 <shapr> ooh, a challenge!
12:59:48 <erisco> kakashiAL, if you have a function f which takes input type A and gives output type B, and a function g which takes input type B and gives output type C, then g . f is a function which takes input type A and gives output type C
12:59:49 <zachk> greatgig1, how about x == [] = 0 
13:00:17 <erisco> kakashiAL, function composition is a way of defining new functions given existing functions
13:01:06 <greatgig1> zachk: but then the list has no numbers right? So should it return 0? 
13:01:19 <kakashiAL> erisco: read above please. I dont have a problem to understand composition or how to implement it (no matter what language you giving me) I have a problem to see a real world use for it :/
13:01:19 <hydraz> > sum []
13:01:23 <lambdabot>  0
13:01:27 <greatgig1> wah
13:01:30 <greatgig1> Okay!
13:01:32 <[exa]> greatgig1: what about defining the function so that it ignores bad inputs (giving reasonable output anyway) without parentheses 
13:01:39 <zachk> hydraz, but he is pattern matchin on the list == [] and erroring
13:01:45 <[exa]> greatgig1: btw you already won the first part of challenge with sum/take combo.
13:01:55 <greatgig1> Oh thanks!
13:01:58 <maerwald> kakashiAL: then start using haskell
13:02:02 <barrucadu> kakashiAL: It's kind of hard to think of a particular real-world use because it crops up all the time.  For instance, if I want to filter a list to elements not matching a predicate, I'd write that as "filter (not . p)"
13:02:05 <maerwald> it gets obvious pretty soon
13:02:10 <erisco> kakashiAL, stop looking for a real world use and just look at function composition. Understand it first, then look for that pattern in your regular work.
13:02:50 <greatgig1> [exac]: Hmmm, so what is the challenge? 
13:02:53 <maerwald> it's like jumping into the java channel and saying I don't see the point in OOP :>
13:03:00 <erisco> kakashiAL, what languages do you know? I think you can implement function composition.
13:03:01 <greatgig1> Oh, I saw it now
13:03:22 <[exa]> greatgig1: make it absolutely minimal
13:03:40 <hydraz> spoilers: it involves function composition :p
13:03:46 <parsnip> kakashiAL: you're familiar with imperative programming?
13:03:53 <[exa]> lol
13:04:14 <greatgig1> you mean like this? addFirstNNumbers n x  = sum (take n x)
13:04:33 <hydraz> that's good, but you can do better
13:04:39 <zachk> try using (.) with it 
13:04:58 <[exa]> I'd first get rid of the parentheses, just with $
13:05:09 <[exa]> seeing $ in action is always useful
13:05:22 <greatgig1> what is this $ you talk about?
13:05:36 <maerwald> let's put it this way... you don't need (.) but you will( need( more( brackets( than( you( wish
13:05:36 <hydraz> @src ($)
13:05:37 <lambdabot> f $ x = f x
13:06:05 <[exa]> just a function application operator. you write  show $ f a b  instead of show (f a b)
13:06:15 <[exa]> it saves parentheses
13:06:39 <erisco> no, it destroys them
13:06:43 <maerwald> lol
13:06:48 <maerwald> it flattens them
13:06:53 <[exa]> saves them for lisp guys
13:07:04 <erisco> parentheses are an endangered species and $ is the weapon of the parenthesis poacher
13:07:20 <parsnip> $ is low precedence
13:07:52 <fishythefish> erisco: they're already good at pairing up. if they can't figure out how to reproduce, that's just natural selection
13:08:10 <greatgig1> like this? a addFirstNNumbers n x  = sum $ take n x
13:08:13 <erisco> well you guys keep jamming a bunch of stuff between them
13:08:22 <greatgig1> addFirstNNumbers n x  = sum $ take n x?
13:08:24 <[exa]> greatgig1: yeah.
13:08:38 <[exa]> $ is like "ok it's all the last argument from now on"
13:08:42 <parsnip> greatgig1: if you have `x y z $ a b c`, it means, first do x y z ==> w and then a b c ==> d, then do w d
13:09:22 <greatgig1> how interesting...
13:09:35 <[exa]> greatgig1: and the last thing; look at this pattern  (f.g) x == f (g x) and try to apply it
13:09:53 <parsnip> because it's like f $ x ==> f x, except very low precedence.
13:09:54 <[exa]> that should probably give the minimal practical implementation
13:10:19 <greatgig1> [exa]: ok I'll try it :)
13:10:30 <greatgig1> and thanks parsnip :)
13:10:34 <parsnip> :)
13:10:35 <[exa]> (without the $ now)
13:12:01 <[exa]> btw, are there any good reasons why parameters of (.) are in the non-math order, other than it makes refactoring much less painful?
13:12:35 <erisco> it seems you think there is a standard order in maths notation
13:12:47 <[exa]> good point
13:12:58 * [exa] feels silenced
13:13:03 <shapr> hoi tromp, how's life?
13:13:21 <tromp> hi, shae. never better!
13:13:32 <shapr> glad to hear it! Are you writing Haskell at work?
13:13:43 <shloub> not sure what you mean [exa] 
13:13:45 <shloub> https://en.wikipedia.org/wiki/Function_composition
13:13:52 <shloub> looks like the « math order » to me
13:14:15 <tromp> I retired and work on my hobbies now
13:14:23 <shloub> f.g is basically f∘g, isn't it?
13:14:25 <tromp> mostly on Cuckoo Cycle
13:14:29 <shapr> tromp: oh wow, any coding hobbies?
13:14:30 * shapr googles
13:14:33 <tromp> which cannot be in Haskell :(
13:14:51 <shapr> aw
13:14:58 <tromp> it's the most performance critical possible
13:15:51 <erisco> maybe Atom? :)
13:15:58 <greatgig1> addFirstNNumbers n x = (sum . take n) x
13:16:21 <fommil> hi, I'm trying to create a docker image with stack and all deps I want to use pre-loaded so that I can point it at a .hs file and have it compiled into a binary inside the container. But I am new to Haskell (and stack) and I don't understand how stack downloads dependencies.
13:16:25 <[exa]> shloub: wow, even wikipedia adapted the more natural order. cool
13:16:29 <fommil> I've created this https://github.com/cakesolutions/docker-images-public/tree/master/hmonad
13:16:38 <shapr> tromp: for the ASIC section, wouldn't large FPGAs with large RAM still give a speedup?
13:16:40 <greatgig1> so I first curry the take function and then compose it with sum to receive a list and sum the n first elements?
13:16:49 <[exa]> greatgig1: great, and now take it mathematically like an equation and remove the x on both sides
13:17:10 <tromp> shapr: depends on memory interface
13:17:12 <shapr> and what about NUMA systems?
13:17:19 <shapr> tromp: oh this is nifty stuff!
13:17:23 * shapr hops cheerfully
13:17:26 <greatgig1> addFirstNNumbers n = (sum . take n)
13:17:33 <hydraz> and drop the parentheses
13:17:35 <fommil> you can see the stack.yaml that's used for the global setup, and that the run.sh is calling `stack ghc --system-ghc -- ...` This is basically how I compile xmonad, with the xmonad-contrib in the stack system. But my example app isn't able to find scotty
13:17:40 <tromp> shapr: I think GPU are pretty well optimized for memory bandwidth bound computations
13:17:53 <erisco> greatgig1, now bonus points for eta reducing the 'n' as well ;)
13:17:54 <greatgig1> and it just works?! ahahah
13:18:04 <shapr> tromp: are you still in the northeast USA?
13:18:06 <tromp> and tons cheaper than fpgas
13:18:08 <ongy> tromp: ask merjin when he's around about that
13:18:15 <tromp> no i moved back to holland
13:18:19 <shapr> aw, too bad
13:18:21 <hydraz> greatgig1: now remove the ‘n’ parameter.
13:18:28 <shapr> I was hoping I could bribe you to give a talk in Atlanta
13:18:48 <tromp> talk about what?
13:18:54 <shapr> about cuckoo!
13:18:54 <maerwald> careful, composition is one thing, eta reduction another. and the latter is not necessarily something useful to programming, because it's about shortening expressions, while programming is about making things most obvious (which can also mean to be more verbose)
13:19:08 <shapr> and proof of work in general
13:19:29 <tromp> what event are you running in atlanta?
13:19:41 <greatgig1> but then it breaks :(
13:19:43 <shapr> I run lots of random events
13:19:43 <tdammers> eta reduction is beneficial to making things more obvious when the variable removed from the expression doesn't carry significant meaning
13:19:58 <tromp> is that where you live?
13:20:02 <erisco> greatgig1, you have to make valid reductions, not just remove the parameter
13:20:08 <maerwald> tdammers: when does a variable not carry significant meaning?
13:20:17 <[exa]> greatgig1: the moral of the story is that `sumN n = sum . take n' is "mostly english", thus probably the best form. Anyway removing the `n' is a bit harder I guess
13:20:47 <tdammers> maerwald: the second argument to fmap, for example, often carries no meaning beyond "the thing we're fmapping over"
13:20:57 <shapr> tromp: Yes, I live in Atlanta at the moment. I'm currently organizing and teaching Python and Haskell workshops, and knitting and I give classes on other things, next month I'm doing a class on: https://twitter.com/PaintYourDragon/status/901158586977353728
13:20:59 <tdammers> maerwald: writing it out doesn't add any information, it's just line noise
13:21:28 <maerwald> it's not about meaning, really, it's about patterns people are used to and when they are working on their own codebase, they see recurring patterns and start reducing expressions... then the next person looks at it, and hasn't seen those patterns yet, so he will be confused
13:21:46 <tromp> my wife is big on knitting
13:21:47 <tdammers> maerwald: that's a matter of exposure, both ways
13:21:48 <shapr> I also organize a hardware hackers evening, and I give talks at various conferences.
13:21:57 <madknight> whats the difference between https://hackage.haskell.org/package/aeson-1.2.2.0/docs/Data-Aeson.html#eitherDecode and eitherDecode' ?
13:21:57 <maerwald> tdammers: nah, it's a matter of readability
13:22:00 <tdammers> maerwald: neither makes it intrinsically easier to understand code
13:22:12 <shapr> tromp: oh cool! She does continental aka left-handed knitting, right? It's much better for not having wrist pain.
13:22:13 <maerwald> the increase and reading speed by eta reduction is almost zero
13:22:28 <maerwald> s/and/in/
13:22:35 <tdammers> maerwald: maybe so, but it does add an additional variable that occupies a spot in the reader's working memory
13:22:37 <tdammers> vOv
13:22:38 <maerwald> but the increase in readability is often higher
13:22:47 <tromp> i have no idea:-(
13:22:49 <maerwald> for people not familiar with the codebase
13:22:54 <shapr> This past weekend I helped my gf teach "programming without code" where participants wrote down instructions for making a peanut butter & jelly sandwich, and then I got to be the robot who did EXACTLY what the card said.
13:22:57 <maerwald> I like to keep the contribution bar low
13:23:03 <greatgig1> [exa]: removing the n is really hard :(
13:23:09 <tromp> i didnt know knitting has a handedness
13:23:12 <johnw> shapr: getting quite off-topic :)
13:23:12 <greatgig1> but I won't give up!
13:23:16 <shapr> johnw: whoops, sorry
13:23:20 <shapr> HASKELL IS AWESOME
13:23:25 <johnw> there you go
13:23:26 <shapr> johnw: thanks :-)
13:23:31 <hydraz> nice recovery
13:23:34 <shapr> whew
13:23:35 <johnw> I'm just pondering the deep irony of having to kick you from the channel :)
13:23:38 <shapr> noooo
13:23:43 <shapr> johnw: I've done that to myself before
13:23:48 <noteventime> I'm having some strange performance regression from 8.0.2 to 8.2.1, In a Criterion benchmark taking the sum of a Vector of doubles takes three times as long in 7.2.1 compared to 8.0.2, but there appears to be no difference when not using criterion (just doing something like print (sum ...))
13:23:53 <tdammers> maerwald: eta reduction however opens the door to compositional style, which, once you're familiar with the paradigm, is really really nice for readability
13:24:01 <tdammers> a . b . c . d $ z
13:24:06 <maerwald> no, eta reduction is not needed for composition style
13:24:07 <noteventime> 8.2.1*
13:24:10 <tromp> sounds like you're having fun, shapr
13:24:14 <shapr> yeah!
13:24:19 <tdammers> maerwald: it's not needed, but it helps find opportunities
13:24:21 <[exa]> greatgig1: the form with n is probably the simplest so I'd stay with it :]
13:24:35 <maerwald> tdammers: obfuscation opportunities maybe
13:24:36 <erisco> greatgig1, the first step I'll give you because it is a notational equivalence  sum . take n ≡ (.) sum (take n)
13:24:38 <shapr> tromp: have you considered generating C from Haskell, like Atom or copilot or etc? or are those also too slow for cuckoo?
13:24:53 <maerwald> if you think more than 10 seconds about how to shorten your expression you just wrote... don't do it
13:24:54 <tdammers> maerwald: vOv ... apply taste, is all I'm saying
13:24:59 <maerwald> the next person looking at it will be confused
13:25:06 <tdammers> not shortening, simplifying
13:25:10 <maerwald> nope
13:25:24 <maerwald> those are rarely simplifications ime
13:25:25 <tdammers> I think about making things simpler. not shorter.
13:25:34 <tromp> i fear even C++ is not performant enough for Cuckoo Cycle. best miner will probablu end up being hand optimized GPU assembly
13:25:49 <maerwald> depends on the writing style ofc, sometimes I write something overcomplicated, because I found a shorthand function
13:25:59 <maerwald> but most of the time that thing I wrote intuitively is the thing I should write
13:26:05 <maerwald> and not reverse fix it 
13:26:32 <tdammers> boostPlayerHealth = over playerHealth (+1)
13:26:34 <tdammers> vs.
13:26:40 <tromp> but for CPUs I should get pretty close to optimal with carefully coded C++
13:26:55 <tdammers> boostPlayerHealth = over playerHealth (\health -> health + 1)
13:27:09 <erisco> greatgig1, and there is a second notational equivalence you may need to see, but I'll leave you there for now, good luck! :)
13:27:10 <maerwald> I wouldn't intuitively write the latter form
13:27:16 <tdammers> point in case, that's not exactly eta reduction
13:27:28 <maerwald> exactly, because I already wrote it that way ;)
13:27:31 <tromp> generating from Haskell doesnt sound promising to me
13:28:20 <shapr> yeah, I'm tempted to look into the low power FPGAs and see if I can find a sweet spot. Have you seen clash-lang? (back to the Haskel topic!)
13:28:38 <greatgig1> thanks again! I think I'm slowly learning haskell 
13:28:38 <tromp> no i haven't
13:28:45 * shapr hugs greatgig1 
13:28:48 <shapr> greatgig1: yay!
13:29:00 <greatgig1> :)
13:29:01 <tdammers> spawnUnit unitID unit game = over gameUnits $ Map.insert unitID unit
13:29:07 <tdammers> eh
13:29:12 <tdammers> spawnUnit unitID unit = over gameUnits $ Map.insert unitID unit
13:29:14 <erisco> knowing how to rewrite terms like this will help you
13:29:14 <tdammers> sorry
13:29:20 <tdammers> why not
13:29:22 <erisco> whether the result ends up being an improvement or not
13:29:49 <tdammers> damn, sorry I'm too tired to haskell right now
13:30:24 <maerwald> tdammers: my point is... having short expressions in maths has a more important role than in programming. In programming it's simply not about it, but we still entertain ourselves with that art, sometimes for worse
13:30:33 <[exa]> erisco: is there a human language that would be able to read the result we're going to in a way that sounds semantic? :D
13:30:49 <erisco> [exa], yes
13:31:18 <[exa]> ok, waiting for it
13:31:28 <erisco> it requires thinking in a curried way
13:31:55 <maerwald> tdammers: and when I get a review for a random PR on project XY and someome tells me "hey, you can eta reduce that"... I am about to say "no, f... I mean, do that yourself if you think that's useful" ;P
13:32:00 <greatgig1> this curry guy really thought things the other way around
13:32:03 <[exa]> yeah I have a solution here, but "translating it to english" doesn't seem quite straightforward
13:32:19 <maerwald> it's sometimes really annoying the possibilities of style nitpicking in haskell
13:32:36 <erisco> [exa], the usual description of (.) is that it takes two functions and gives you the composition of those functions
13:32:51 <erisco> [exa], and the explanation can be elaborated with the types
13:33:20 <erisco> [exa], this is not the curried way of thinking about it, quite evidently, because we've jumped from (.) to saying it takes *two* arguments
13:33:23 <[exa]> erisco: 'compose the composition with A with B' is more lambda calculus than english imo :D
13:33:59 <erisco> so, describe to me (.) as applied to one argument
13:34:22 <[exa]> oh so, I guess I'm starting to get the point
13:36:43 <[exa]> that's "wrap in", so probably "compose wraping the function in sum with taking elements"
13:37:48 <erisco> how about, it takes any map and gives you a map on function returns
13:37:52 <erisco> :t (.)
13:37:53 <[exa]> I somehow assume you have better names for that
13:37:54 <lambdabot> (b -> c) -> (a -> b) -> a -> c
13:38:10 <maerwald> :t (<<<)
13:38:12 <lambdabot> forall k (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
13:38:17 <erisco> elaborated with types, it takes a map B -> C and gives you a map (A -> B) -> (A -> C)
13:38:57 <erisco> and, the funny thing is, if I wrote  fmap (fmap g) f  you probably would see this immediately
13:39:46 <[exa]> ....and I was afraid there wouldn't be functors!
13:40:31 <maerwald> all you need is arrows
13:42:23 <[exa]> yeah I just wrote it instantiated to (->)
13:43:10 <[exa]> kewl.
13:43:13 <[exa]> erisco: thanks. :]
13:43:22 <erisco> no problem
13:43:56 <erisco> now you have  fmap (fmap g) f ≡ (fmap (fmap g)) f ≡ ((fmap . fmap) g) f
13:44:36 <erisco> then, with loss of generality,  (((.) . (.)) g) f   and after two eta reductions  (.) . (.)
13:44:46 <erisco> so, there's that contraption explained
13:44:51 <[exa]> is this getting closer to english? :D
13:45:51 * hackagebot testCom 0.1.1 – Write your tests in comments – https://hackage.haskell.org/package/testCom
13:46:41 <geekosaur> too close maybe, try a language that isn't quite so polymorphic? :p
13:47:08 <[exa]> greatgig1: free hint?
13:47:32 <[exa]> maybe I should stop trying to explain programming&logic in natural language
13:49:04 <maerwald> you are not using enough elephant metaphors
13:50:13 <[exa]> my childhood was spoiled by car analogies
13:50:19 <Peaker> hey, what parsing library is nice for tokenizing and then parsing tokenized input (performance matters)?
13:50:49 <erisco> [exa], well, a method for understanding (.).(.) directly could be done from (.)(.)(.) and asking what (.) means as a map
13:51:10 <[exa]> :t (.)(.)(.)
13:51:12 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
13:51:19 <Peaker> Just two passes with parsec-style libraries sound like it should work - but tokenizing would be really nice if it were incremental (lazily done)
13:51:24 <erisco> [exa], because we know (.) takes any map and gives us a map on function returns, so if we give (.) (.) then this asks us what (.) is as a map
13:51:33 <Peaker> i.e: have the 2 passes be streaming / in constant memory
13:51:35 <[exa]> whoa, it composes just nicely
13:52:20 <[exa]> :t (.)((.)(.)(.))(.)
13:52:22 <lambdabot> (b -> c) -> (a1 -> a2 -> a3 -> b) -> a1 -> a2 -> a3 -> c
13:52:35 <[exa]> :t (.)((.)((.)(.)(.))(.))(.)
13:52:37 <lambdabot> (b -> c) -> (a1 -> a2 -> a3 -> a4 -> b) -> a1 -> a2 -> a3 -> a4 -> c
13:53:31 <[exa]> :t (.).(.).(.).(.)
13:53:33 <lambdabot> (b -> c) -> (a1 -> a2 -> a3 -> a4 -> b) -> a1 -> a2 -> a3 -> a4 -> c
13:53:44 <maerwald> :t (>>>) (<<<)
13:53:47 <lambdabot> forall k (cat :: k -> k -> *) (a :: k) (b :: k) (c1 :: k) c2. Category cat => ((cat a b -> cat a c1) -> c2) -> cat b c1 -> c2
13:54:05 <[exa]> too cool to be true
13:54:08 * [exa] goes for beer
13:54:10 <maerwald> :t (>>>) (>>>) (>>>) (>>>) (<<<) (<<<) (<<<) (<<<)
13:54:12 <lambdabot> forall k (cat :: k -> k -> *) a1 a2 (a3 :: k) (b :: k) (c1 :: k) c2. Category cat => (a1 -> (a2 -> cat a3 b -> cat a3 c1) -> c2) -> a1 -> (a2 -> cat b c1) -> c2
13:54:24 <Tuplanolla> It's less bad than I expected.
13:54:36 <erisco> somehow talks of function composition always end in this :P
13:55:18 <zachk> :t (.).(.)
13:55:20 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
13:55:23 <maerwald> wait
13:55:25 <maerwald> I have an idea
13:55:29 <erisco> I therefore direct you to control-dotdotdot on hackage to sate yourself
13:55:41 <maerwald> :t (>>>) (>>>) (>>>) (>>>) . (<<<) (<<<) (<<<) (<<<)
13:55:43 <lambdabot> forall k1 k2 (cat1 :: k2 -> k2 -> *) (cat2 :: k1 -> k1 -> *) (a1 :: k2) (b1 :: k2) c1 a2 (b2 :: k1) (c2 :: k1) (c3 :: k2) (a3 :: k1). (Category cat2, Category cat1) => ((cat1 a1 b1 -> c1) -> a2 ->
13:55:43 <lambdabot> cat2 b2 c2) -> ((cat1 b1 c3 -> cat1 a1 c3) -> c1) -> a2 -> cat2 a3 b2 -> cat2 a3 c2
13:55:45 <zachk> :t (.)(.)
13:55:48 <lambdabot> (a1 -> b -> c) -> a1 -> (a2 -> b) -> a2 -> c
13:56:11 <maerwald> :t (>>>) . (>>>) . (>>>) . (>>>) . (<<<) . (<<<) . (<<<) . (<<<)
13:56:14 <lambdabot> forall k (cat :: k -> k -> *) (b :: k) (c1 :: k) a1 a2 a3 (a4 :: k) c2 c3 c4 c5. Category cat => cat b c1 -> (((((a1 -> a2 -> a3 -> cat a4 b) -> c2) -> c3) -> c4) -> c5) -> ((((a1 -> a2 -> a3 -> cat
13:56:14 <lambdabot> a4 c1) -> c2) -> c3) -> c4) -> c5
13:56:20 <maerwald> ok, let's not rape lambdabot 
13:56:23 <erisco> [exa], another idea is to use our usual description of (.) as applied to two arguments
13:56:23 * [exa] pledges to stop the madness
13:56:39 <maerwald> argument are relative :P
13:57:24 <maerwald> wait what?
13:57:31 <maerwald> I have to show one more
13:57:38 <maerwald> :t (>>>) . (>>>) . (>>>) . (>>>) . (<<<) . (<<<) . (<<<) . (<<<) $ ($)
13:57:40 <lambdabot> (((((a1 -> a2 -> a3 -> a4 -> a5 -> b) -> c1) -> c2) -> c3) -> c4) -> ((((a1 -> a2 -> a3 -> a4 -> a5 -> b) -> c1) -> c2) -> c3) -> c4
13:57:45 <maerwald> category is gone
13:58:04 <[exa]> I seriously rofl'd on this
13:58:11 <maerwald> :(
13:58:47 <erisco> [exa], so from  (.).(.)  which I will call  g.f  we have  f takes a map to a map on function returns, and g takes the map on function returns and gives us a map of function returns on function returns
13:59:35 <[exa]> maerwald: no seriously, it's too good.
13:59:39 <maerwald> haha
13:59:49 <maerwald> I broke haskell
14:00:11 <[exa]> kindof reminds me the joke with goto on ContT
14:00:56 <erisco> the natural language is not important, but the understanding is
14:02:05 <erisco> with the right ideas in your head, understanding becomes easy, and easy is what you need to strive for in all aspects
14:02:29 <erisco> not until the first thing is easy can you move onto the second difficulty
14:04:58 <monochrom> "explain in my own words" is overrated. Teachers invented it for easy grading, not for understanding or usefulness. In fact, it degenerates to "explain in my own words to show it's empty talk".
14:05:28 <[exa]> interesting.
14:05:51 <maerwald> teachers invented most things for easy grading
14:06:04 <monochrom> Instead, you need to go for either intuition or a formal model that has predictive power.
14:06:08 <smyds> hi, could someone tell me (or point me to somewhere where it's explained) what the | and -> mean in a typeclass definition like this : 
14:06:14 <smyds> class Build d f c e | d -> c, c -> d, f -> e, f -> d, f -> c, c e -> f, d e -> f where
14:06:23 <geekosaur> functional dependencies 
14:06:37 <smyds> (from Numeric.LinearAlgebra.Data)
14:06:38 <[exa]> smyds: functional dependencies, that avoid problems from ambiguity
14:06:46 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#functional-dependencies
14:07:02 <smyds> geekosaur, [exa] : thanks, I'll check this out
14:07:23 <geekosaur> basically it helps type inference: if you know what type d is then you know there is only one possible c, etc.
14:07:42 <[exa]> smyds: it tells the compiler that if it knows 'd' and has any idea of how 'c' could look like, then this idea of 'c' is correct and unique
14:07:54 <geekosaur> without this, methods in typeclasses like that would always have to be annotated with the the type you wanted to use them at
14:08:22 <monochrom> My favourite way is to acquire a formal model that has predictive power first. (My "acquire" is a mixture of thinking up something myself and learning something from existing ones.) Then after I use this model many times, I start to have intuition.
14:08:46 <monochrom> But a lot of people do it in the other chronological order and it's OK too.
14:11:51 <[exa]> smyds: btw this is a good read about functional dependencies (also funny): https://aphyr.com/posts/342-typing-the-technical-interview
14:12:50 <[exa]> (btw. compare with prolog terms: Term(+Input,-Output). Is this analysis also called 'modding' in english?)
14:17:07 <erisco> we just have ways to reason about programs that are effective in our own muddled way
14:17:58 <erisco> such as saying  h . g . f  is like an assembly line… the saying is an over-detailed analogy of what we're really thinking of
14:18:22 <erisco> we're thinking of something being given to f, then f giving a result to g, and so on
14:18:52 <jle`> smyds: for the most part, for every day usage of the API, you can ignore the actual fundeps
14:18:59 <erisco> we're not rewriting the whole term with the definition of .
14:19:01 <jle`> smyds: it's mostly for the library developer to work with ghc
14:19:41 <erisco> why we have to think in these tortured ways, or at least explain our thoughts in these tortured ways, I don't know, but that's how we are
14:21:13 <monochrom> That's a good example I can use to explain what I meant. I started with the formal model "(h . g . f) x = h (g (f x)) = let y = f x in let z = g y in h z". After using it many times, I start to imagine a picture of three processors connected linearly --- an intuition.
14:23:19 <monochrom> When I am designing new stuff and wondering whether I should make it "h . g . f" or equivalent, the picture is a good heuristic for answering "yes my goal looks like it" or "no, look for another organization".
14:23:44 <monochrom> But the formal model has the final say on whether it actually works or not.
14:24:17 <erisco> developing an intuition for many special cases is probably how we get ahead cognitively… it reduces the work
14:24:20 <monochrom> The intuition is useful for guessing. The formal model is useful for checking.
14:25:15 <erisco> knowing the minimum of LC technically means I know everything that I can know using the rules
14:25:24 <erisco> but summoning any particular fact may take a long time
14:25:43 <monochrom> Now the interesting thing is that Dijkstra shows how the formal model can also be used for guessing. That's something much less taught but I doubt that it is really harder.
14:26:04 <monochrom> To a large extent if your picture is precise enough, it is equivalent to a formula.
14:27:04 * hackagebot propellor 4.8.1 – property-based host configuration management in haskell – https://hackage.haskell.org/package/propellor
14:27:12 <erisco> where does he write about that?
14:27:32 <monochrom> But basically if your mind has a dictionary using pictures for keys and formulas or code templates for values, it's super easy to do lookups.
14:27:45 <monochrom> Basically all of his EWDs.
14:28:12 <monochrom> Everytime you see him writing "the formula shape guides the design/next step/proof".
14:28:38 <monochrom> which is like every paragraph.
14:29:31 <monochrom> Try to find the one where he shows how you could have reinvented the proof of "no bijection between S and Powerset(S)".
14:30:07 <monochrom> Actually maybe I already have the url.
14:30:25 <monochrom> http://www.cs.utexas.edu/users/EWD/ewd12xx/EWD1294a.PDF
14:31:18 <monochrom> Bookmark this: http://www.vex.net/~trebla/ewd.html  This is a short list of my curation!
14:31:47 <erisco> done!
14:35:03 <zachk> > foldr (.) id [(.),(.)] -- is there anyway to get something like this to work?
14:35:06 <lambdabot>  error:
14:35:06 <lambdabot>      • Occurs check: cannot construct the infinite type: b ~ a0 -> b
14:35:06 <lambdabot>        Expected type: (b -> c) -> b -> c
14:35:31 <zachk> > foldl (.) id [(.),(.)] -- is there anyway to get something like this to work?
14:35:35 <lambdabot>  error:
14:35:35 <lambdabot>      • Occurs check: cannot construct the infinite type: b ~ a0 -> b
14:35:35 <lambdabot>        Expected type: (b -> c) -> b -> c
14:35:40 <zachk> :(
14:35:43 <erisco> zachk, well, that example is nonsense, so maybe start from an explanation we can make sense of
14:35:59 <zachk> shouldnt it be the same as (.).(.) ? 
14:36:02 <monochrom> OK first of all what's the type of [(.),(.)] and why do you care.
14:36:14 <monochrom> @type [(.),(.)]
14:36:16 <lambdabot> [(b -> c) -> (a -> b) -> a -> c]
14:37:10 <zachk> wanted to infinitely fold an infinite list of (.) to break the typechecker, instead the finite example doesn't even work
14:37:59 <erisco> they've thought of this stuff… if you managed to break it then someone made a boo-boo
14:38:55 <monochrom> Secondly, it is most unconfusing if you allow me to rename some of your (.)'s. Call it foldr (.) id [c1, c2].
14:39:27 <monochrom> So, suppose it were typeable. Then the answer would be "c1 . (c2 . id)".
14:40:22 <Tuplanolla> > foldr (.) id [shows 42, shows 13, shows 20] [] -- What you expect to break is actually a common pattern we use, zachk.
14:40:26 <lambdabot>  "421320"
14:40:45 <zachk> :t shows
14:40:47 <lambdabot> Show a => a -> ShowS
14:41:02 <erisco> foldl (.) (.) [(.)]  is  ((.) (.)) (.)  if we just rewrite terms, but remember in Haskell we have to also appease typing
14:41:02 <monochrom> ShowS = String -> String
14:41:53 <Tuplanolla> Observationally `shows x = (show x ++)`, zachk.
14:43:59 <monochrom> So I think if you try to typecheck c1 . (c2 . id), bearing in mind that id wants to look like "X -> X", c2 and c1 want to both look like the same "A -> B -> C" (same because you put them in the same list [c1,c2]), you should run into problems.
14:45:17 <monochrom> foldr (.) (.) [(.), (.)] would make more sense.
14:45:24 <monochrom> @type foldr (.) (.) [(.), (.)]
14:45:26 <lambdabot> error:
14:45:26 <lambdabot>     • Occurs check: cannot construct the infinite type: b ~ a -> b
14:45:27 <lambdabot>       Expected type: ((a -> b) -> a -> c) -> (a -> b) -> a -> c
14:45:38 <monochrom> Ah interesting.
14:46:52 <Fendor> well, you can probably kill the elm compiler with these types
14:48:53 <monochrom> If you say, "I once tried (.) . (.) . (.) . (.), it worked just fine, so why can't I write it as foldr on a list?", you are just deceiving yourself by superficial lookalikes.
14:49:50 <monochrom> In "(.) . (.) . (.) . (.)", or let's be more honest and call it "c1 . c2 . c3 . c4", nothing says that c1, c2, c3 and c4 have the same type.
14:50:06 <erisco> I might have a funny idea here…
14:50:21 <monochrom> In fact if you actually try to infer types yourself, they are forced to get different types. So you simply can't put them into a list.
14:50:45 <Tuplanolla> I repeatedly fell for this and other such things when I wrote more Scheme, monochrom.
14:51:08 <monochrom> Similarly you can do [show 1, show True, show 'x'] but you can't do map show [1, True, 'x']. That latter list simply doesn't exist.
14:51:56 <maerwald> -fdefer-type-errors?
14:52:33 <geekosaur> ... heh
14:53:22 <geekosaur> go whole hog, -fdefer-all-errors
14:53:44 <monochrom> That is not the whole hog yet.
14:54:15 <monochrom> To go all the way, you should simply never let the compiler see your code. Call it pseudocode.
14:54:43 <monochrom> To avoid falsification, make unfalsiable statements only.
14:54:54 <monochrom> and I can't spell.
14:55:11 <geekosaur> I try to leave that to politicians
14:56:13 * hackagebot gjk2d 0.1.0.1 – <i>Added by suzumiya, Mon Sep 25 21:45:32 UTC 2017.</i> – https://hackage.haskell.org/package/gjk2d
14:56:14 <monochrom> Anyway, a way out is to keep the polymorphism of (.). Write a newtype wrapper for that.  newtype X = X{forall a b c. (b -> c) -> (a -> b) -> (a -> c)}
14:56:35 <monochrom> Define c = X (.)
14:57:38 <monochrom> Define a new version of (.) that does X -> X -> X. Then you can foldr on that.
14:58:16 <maerwald> I want safe ducktyping
14:58:18 <maerwald> lol.
14:58:27 <monochrom> Basically because the list [c, c, c] now makes sense and each c stays polymorphic and so different copies of c can be specialized to different types.
14:58:53 <geekosaur> there's at least one language trying to work on that >.>
14:59:26 <maerwald> I can only imagine program verification to attempt that. Type systems are too limited
14:59:27 <monochrom> conduit and pipes provide safe ducttyping.
15:02:42 <monochrom> Hrm maybe X->X->X cannot be done.
15:02:52 <monochrom> @type (.) . (.)
15:02:53 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
15:03:08 <erisco> monochrom, haha I was toying with just that
15:03:34 <erisco> monochrom, problem is you can't do much with two X's
15:04:03 <monochrom> Well, I guess parametricity requires X->X->X to return either X(undefined) or X(.)
15:04:35 <erisco> then by the time I added enough information I just had an AST for the (->) Category
15:04:49 <monochrom> Yeah heh.
15:05:46 <monochrom> Next attempt is to give up on [] and write your own GADT list-like type so its "element type" keeps changing as you cons more (.)s.
15:05:56 <erisco> that is what I am talking about
15:05:58 <erisco> I'll lpaste it
15:07:16 <monochrom> I learned that trick when I read the paper on defunctionalizing several things in one swoop but oh the new data have incompatible types you can't just write an ADT what to do what to do?
15:07:56 <blehman> Does anyone know of any good resources to learn haskell for someone who has never touched a functional programming language, but has some non-functional programming experience?
15:08:12 <monochrom> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.9.4715&rep=rep1&type=pdf
15:08:29 <monochrom> "polymorphic typed defunctionalzation"
15:08:38 <zachk> I knew some basic scheme, and programming in haskell by graham hutton cleared up most of my newbie questions
15:08:55 <zachk> but I guess you could consider scheme kinda of functional in nature
15:08:59 <monochrom> Apparently what we call "generalized ADT", the ML community call it "guarded ADT".
15:09:13 <erisco> monochrom, http://lpaste.net/358716
15:09:21 <monochrom> But isn't it nice, if you use the acronym "GADT" it works both ways. :)
15:09:42 <erisco> acronym polymorphism
15:09:48 <jle`> ML as in SML?
15:09:58 <monochrom> yeah!
15:10:18 <blehman> Cool, thanks. I have some very basic scheme knowledge so that sounds perfect.
15:11:06 <erisco> you could also modify for  (.) (FList g) (FList f) = FList (g . f)  if you wanted to flatten it
15:11:11 <monochrom> Hrm speaking of which, what's Hutton's market price today?  (Hahaha greatest misworded question.)
15:11:15 <zachk> monochrom, so the list forces the polymorphism of all the (.) to all be the same, so it breaks when you try to chain them?
15:13:07 <monochrom> Yeah.
15:13:43 <zachk> so it could work with a fold over a heterogenuous list?
15:13:48 <c_wraith> can we get a redo on the overloaded lists extension? I'd really like it if it desugared to some sort of cons and nil.
15:14:02 <monochrom> Yeah, erisco's lpaste is making one such list.
15:14:22 <erisco> it is just… not that interesting once you see it :P
15:15:03 <erisco> you can generalise it further for any category
15:15:55 <monochrom> c_wraith: Perhaps more people would support it (or rather, fewer people would object it) if you call it a new extension OverloadedConsNil.
15:16:45 <monochrom> Hmm what does the current OverloadedList do? Let me check.
15:18:52 <erisco> fromList iirc
15:19:50 <monochrom> Yeah, [a] -> YourType
15:20:39 <monochrom> If you have your own cons and nil, you write your version of fromList as foldr cons nil. That is not too bad.
15:20:54 <Ero> hi all
15:20:59 <monochrom> Add some rewrite rules to do fusion if you fancy it.
15:39:16 <erisco> tried something like this but that didn't go anywhere http://lpaste.net/358717
15:39:56 <jle`> if you're using GADTs, why bother with the type family?
15:40:27 <erisco> just for the possibly generality
15:40:46 <jle`> you could parameterize that based on a profunctor or type constructor then
15:41:13 <erisco> feel free to carry the torch
15:41:14 <jle`> data Comps :: * -> * -> * where CNil :: Comps a a; CChain :: (a -> b) -> Comps b c -> Comps a c
15:41:20 <jle`> or, parameterized:
15:41:37 <erisco> well I already went through that version
15:41:50 <jle`> data Comps :: (k -> *) -> k -> k -> * where CNil :: Comps f a a; CChain :: f a b -> Comps f b c -> Comps f a c
15:41:56 <jle`> and the original one would be Comps (->)
15:42:15 <jle`> or 'Kleisli m' for some monad m for great fun
15:42:24 <erisco> I gave a version like this earlier
15:42:39 <erisco> I was thinking of something more reminiscent of lists, and thought of polymorphic recursion
15:52:19 <Ero> ?
16:03:29 <Ero> hi
16:03:43 <Ero> if i wanted to map (a -> State s b) into [[a]]. what is the most 'appropriate' way to chain the computations together, and should i put as much of the algorithm  into the (a -> State s b) as possible (seems verbose?) and then have as little code in the 'glue' as possible, or should i put minimal code in the 'glue' as possible, or should i put minimalcode into the workhorse computation and put the rest in the 
16:03:49 <Ero> 'glue'?
16:08:54 <lyxia> (traverse . traverse)
16:12:00 <koz_> If I have a computation producing a Vector n Int, using vectors from vector-sized, how do I tell GHCI that I want a Vector 5 Int for that particular computation?
16:12:12 <koz_> I tried doing 'computation :: Vector 5 Int', but it didn't like it much.
16:13:16 <lambdamu> koz_: What did it say?
16:13:35 <koz_> lambdamu: Illegal type: ‘5’ Perhaps you intended to use DataKinds
16:13:46 <hydraz> Perhaps you intended to use DataKinds? :P
16:13:48 <lambdamu> koz_: try :set -XDataKinds
16:13:51 <hydraz> :set -XDataKinds
16:13:58 <lambdamu> koz_: try :set -XTypeLiterals
16:14:03 <lambdamu> koz_: also
16:14:10 <koz_> hydraz and lambdamu: DataKinds does the trick.
16:14:21 <hydraz> In my attempt to be snarky I was slow.
16:16:27 <Ero> any takers? :)
16:16:42 <lambdamu> TypeLiterals is not an extension apparently, so scratch that
16:17:53 <lambdamu> Ero: I'm not sure what mean actually, do you have some code?
16:20:00 <lambdamu> for starters im no sure I know what it means to map a -> State s b into [[a]]
16:20:12 <hydraz> GHC.TypeLits only depends on DataKinds.
16:20:22 <adjointfunctor> @Ero, I guess you need `sequence`?
16:20:22 <lambdabot> Unknown command, try @list
16:31:10 <lyxia> Ero: are you looking for (traverse . traverse)
16:40:08 <adjointfunctor> lyxia: snd $ (traverse . traverse), for that matter
16:40:39 <zachk> is there a first few comonads I should try to learn, ones that can make them click?
16:42:22 <adjointfunctor> zachk: when I asked that question here, I was pointed at the notion of coeffects, and context dependent computations
16:44:12 <adjointfunctor> zachk: There is a PHD research project on them, http://tomasp.net/coeffects/
16:46:55 <adjointfunctor> That duality notion from category theory is so useful it's hard to believe you get theorem for free =)
16:57:37 <zachk> adjointfunctor, some of this coeffect stuff sounds like things from reactive programming
16:58:55 <erisco> no that is just what they are applying it to as an example, zachk
16:59:08 <adjointfunctor> zachk: yes, it does. Coeffect notion is more general.
16:59:17 <Ero> lyxia: adjointfunctor sorry i fell asleep lol. i'lll check out traverse tomorrow. thanks for the signpost :) nightynight x
16:59:35 <adjointfunctor> zachk: I was comparing that to Reader monad at first
16:59:43 <zachk> could I do all the comonad stuff using Control.Arrow ?
16:59:51 <zachk> adjointfunctor, that is what I was thinking
17:00:14 <adjointfunctor> Ero: I just modified answer of another human, thank him =)
17:00:57 <erisco> a hugh-mon
17:02:16 <erisco> now what links that and elementary particles?
17:08:47 <adjointfunctor> zachk: :t arr (extract)
17:09:05 <adjointfunctor> welp, better check how lambdabot works
17:10:41 <adjointfunctor> @type arr extract
17:10:43 <lambdabot> error: Variable not in scope: extract :: b -> c
17:11:45 <adjointfunctor> @type arr Control.Comonad.extract
17:11:47 <lambdabot> (Control.Comonad.Comonad w, Arrow a) => a (w c) c
17:11:52 <adjointfunctor> finally
17:12:16 <dmwit> You can use :t, too, it just has to start off the line.
17:12:29 <dmwit> :t id -- you can put nicks at the end in a comment
17:12:31 <lambdabot> a -> a
17:12:59 <adjointfunctor> :dmwit, thanks for the info =)
17:13:11 <adjointfunctor> oh cmon
17:13:24 <adjointfunctor> time to go to bed
17:17:12 <adjointfunctor> zachk: https://hackage.haskell.org/package/comonad-5.0.2/docs/Control-Comonad.html#g:3
17:17:37 <adjointfunctor> zachk: Yeah, you can do comonad stuff with arrows
17:21:25 <zachk> playing around with comonad store over a list with !!, seems kind of nifty, guess it has to offer some nice power...will get it into it more tommorow
17:21:56 <WinterFox[m]> A functor is just a data type that fmap can be run on right?
17:22:08 <hydraz> yeah
17:22:12 <hydraz> @src Functor
17:22:13 <lambdabot> class Functor f where
17:22:13 <lambdabot>     fmap :: (a -> b) -> f a -> f b
17:22:15 <hydraz> hey, that worked
17:22:23 <edwardk> zachk: a few thoughts. have you seen kenny foner's talk on getting a quick fix for comonads?
17:22:28 <WinterFox[m]> I guess thats just Haskell specific?
17:22:36 <jle`> WinterFox[m]: a Functor yeah, but it also follows the laws as well
17:22:47 <edwardk> zachk: that covers the sort of spreadsheet-like usecase where they really shine for things like lists
17:22:47 <hydraz> I'm not qualified to comment on category theory or other languages
17:22:54 <rotaerk> is there a such thing as a type-level list-of-types?
17:22:57 <jle`> WinterFox[m]: so knowing that something is a Functor means that you can use fmap with it, and also that fmap respects functor laws
17:23:03 <pikajude> which typeclass is (a -> b) -> f b -> f a
17:23:06 <pikajude> i don't remember
17:23:07 <jle`> rotaerk: yes that's just a list [*]
17:23:14 <jle`> :k '[Int, Bool, Double, Maybe String]
17:23:16 <lambdabot> [*]
17:23:23 <jle`> or [Type] if we're being fancy
17:23:32 <hydraz> pikajude: Contravariant
17:23:37 <pikajude> very long name
17:23:37 <rotaerk> what extension or whatever does that draw on? something I can use to google
17:23:38 <edwardk> WinterFox[m]: Functor is just any 'f' that offers fmap, and where fmap id = id, fmap f . fmap g = fmap (f . g) -- there are surprisingly few languages with the latter quality
17:23:50 <jle`> rotaerk: DataKinds
17:23:51 <hydraz> rotaerk: DataKinds
17:23:53 <rotaerk> thanks
17:23:56 <hydraz> or TypeInType, if we're being fancy.
17:23:57 <jle`> rotaerk: DataKinds
17:24:06 <rotaerk> thanks
17:24:07 <rotaerk> thanks
17:24:09 <rotaerk> :P
17:24:12 <jle`> 'Type' is just a type synonym for * that Data.Kind exports
17:24:18 <jle`> module Data.Kind where type Type = *
17:24:27 <hydraz> oh right
17:24:33 <hydraz> I'm not counting on this working..
17:24:35 <hydraz> @src Type
17:24:35 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:24:39 <edwardk> pikajude: before i took that name a whole lot of people started calling it a 'Cofunctor' which was shorter but had the unfortunate burden of being wrong
17:25:01 <pikajude> but words are all made up, so if you *really* think about it...
17:25:01 <edwardk> which then led to people wondering why Comonads weren't Cofunctors
17:25:16 <edwardk> Co has a pretty rigid meaning in a categorical setting
17:25:17 <pikajude> this is just part of the linguistic evolution of humanity really
17:25:28 <jle`> i just like using Type since it's a little more readable
17:25:31 <pikajude> i'll get 800 thousand teens together and i bet you we can change that
17:25:48 <hydraz> jle`: I like using Type because it's not a horrid parser hack :)
17:25:52 <edwardk> *shrug* i managed to fight back this trend once. ;)
17:26:09 <pikajude> why not go all out and call it ContravariantFunctor
17:26:20 <edwardk> Because I wanted users ;)
17:26:26 <pikajude> or maybe, to keep the name short, CntrvrntFnctr
17:26:40 <hydraz> dropping the vowels is too clichéd
17:26:43 <monochrom> ContraFunctor
17:26:47 <edwardk> Contrafunctor or Contra were the only real serious alternatives on hand
17:26:51 <pikajude> Contrunctor
17:26:53 <adjointfunctor> pikajude: But teens are scared of math, let alone math of math =)
17:26:57 <monochrom> Also, contraalto and antibaritone
17:26:59 <pikajude> functors aren't math
17:27:01 <edwardk> I don't randomly abbreviate class names
17:27:07 <edwardk> and on that note i'm out
17:27:09 <roboguy`> type Cofunctor = Functor ?
17:27:16 <jle`> hydraz: yeah i'm not even sure if the original haskell spec included rules for parsing kinds
17:27:17 <edwardk> roboguy`: exactly
17:27:22 <pikajude> the vegan version would be Tofunctor, surely?
17:27:24 <jle`> i think all talk about kinds in haskell was like metalanguage talk
17:27:38 <hydraz> probably not, given KindSignatures is still and extension
17:27:49 <hydraz> pikajude: Stop it, get some help.
17:28:07 <jle`> http://hackage.haskell.org/package/acme-cofunctor
17:28:11 <jle`> (obligatory link)
17:28:14 <pacak1> @hackage acme-cofunctor
17:28:15 <lambdabot> http://hackage.haskell.org/package/acme-cofunctor
17:28:17 <edwardk> jle`: kinds weren't present in the surface language until the language got complicated enough that we started needing ways to talk about them
17:28:18 <pacak1> Hmm.. Too late.
17:28:37 <monochrom> hahaha
17:28:40 <hpc> awesome
17:28:49 <pikajude> oh, cool, cocoyoneda
17:28:54 <jle`> i mean, even the Functor typeclass requires haskell to think about kinds
17:28:55 <pikajude> that's my favorite flavor
17:29:06 <jle`> but that doesn't mean that kinds necessarily had to be a part of the actual syntax/accessible language
17:30:25 <monochrom> Haskell2010 specifies kinds (generated by * and ->) but it is for describing the type system rather than for adding it to Haskell syntax.
17:30:57 <edwardk> jle`: functor wasn't a thought you could think at first, that wasn't until mark p jones added constructor classes in gofer, and then they got backported to haskell
17:31:53 <monochrom> In the same way that another language standard would define and use a notation like [|xxx|] for denotation semantics but it's only for specifying the semantics of the language rather than letting you access it in the language.
17:31:54 <benzrf> woah
17:32:34 <adjointfunctor> edwardk: Are haskell typeclasses HomSets?
17:32:43 <monochrom> (Yeah yeah, a language standard that actually uses denotational semantics, dream on. :) )
17:33:04 <edwardk> adjointfunctor: that question doesn't typecheck for me, so no =)
17:33:14 <monochrom> (I mean, even SML chose to go operational...)
17:33:31 <edwardk> you can build a category of haskell typeclass constraints, in which the objects are things like "Ord [[[a]]]"
17:33:47 <edwardk> and the morphisms in that category are well defined, see my constraints package
17:34:04 <pie_> i wish more languages had unfold in their common vocabulary
17:34:09 <edwardk> but the typeclasses themselves aren't Hom-like in any way that seems to make sense
17:35:47 <monochrom> Most languages don't give you unfold because they think giving you mutable variables is enough.
17:37:21 <rotaerk> hmm is there a cons-based syntax for [*]?
17:37:31 <rotaerk> something like Int:String:[]
17:37:56 <rotaerk> just would like to take a [*] and append a type to it
17:38:00 <monochrom> I think yes? I mean I think I saw that example in the GHC Users Guide.
17:38:37 <monochrom> And I think I saw some webapp library doing that kind of thing.
17:38:38 <erisco> Int ': String ': '[]
17:38:38 <stack_help> Hey, so I got the following error for a cipher function I wanted to call: Ambiguous module name ‘Crypto.Cipher.AES’:       it was found in multiple packages:       cipher-aes-0.2.11@cipher-aes-0.2.11-14OkZqkxQFLGRuDjhymyTm cryptonite-0.21@cryptonite-0.21-Er8yd96TMUKJhhoyDY0pav
17:38:38 <roboguy`> > Proxy :: Proxy (Int : String : '[])
17:38:42 <lambdabot>  Proxy
17:38:53 <rotaerk> oh ': .. thanks
17:39:00 <stack_help> so I tried deleting all instances of cipher-aes-0.2.11 in ~/.stack
17:39:05 <rotaerk> having trouble finding good documentation for DataKinds
17:39:06 <stack_help> and it's not listed in ghc-pkg anymore
17:39:26 <stack_help> but I still get the same error, even though I'm pretty sure I deleted all instances of it
17:39:47 <edwardk> rotaerk: have you read http://www.seas.upenn.edu/~sweirich/papers/tldi12.pdf ?
17:40:01 <rotaerk> no; thanks
17:40:04 <rotaerk> will do
17:40:12 <stack_help> is there anything else I would need to delete? (I used find . -name 'cipher-aes*' to find all instances in .stack)
17:40:24 <rotaerk> the type-level Nat examples are all I kept encountering when googling for DataKinds
17:40:25 <pie_> monochrom, :P
17:40:35 <edwardk> stack_help: is this when running stack ghci or just ghci?
17:40:41 <stack_help> stack ghci
17:40:49 <geekosaur> stack_help, just deleting that will not help, the package database entry is still there and will be used
17:41:00 <geekosaur> stack exec ghc-pkg recache
17:41:12 <edwardk> you can always nuke your .stack folder.... or do what geekosaur proposed
17:41:29 <geekosaur> hm, actually that win't be enough either because it'll still reindex a dangling entry
17:41:46 <monochrom> When in doubt, nuke.
17:41:46 <stack_help> yeah, I tried recache and it didn't work either
17:41:50 <geekosaur> use "stack exec ghc-pkg check" to find the package that should not fail checks because the actual library objects are gone
17:41:56 <geekosaur> or packages
17:42:02 <stack_help> oh, nice! I'll try that
17:42:04 <geekosaur> er, should now fail
17:42:15 <stack_help> I get what you mean haha. Thanks!
17:42:35 <adjointfunctor> stack_help: you need to use PackageImports pragma in your source file, and write import like this: import "cryptonite" Crypto.Cipher.AES 
17:42:41 <geekosaur> then remove those packagedb files, then recache
17:42:57 <geekosaur> also, there is ~/.stack_work
17:43:43 <geekosaur> PackageImports should only be used as a last resort, adjointfunctor 
17:44:03 <stack_help> I actually don't have a ~/.stack_work
17:44:05 <adjointfunctor> geekosaur: explain why please?
17:44:42 <geekosaur> that said, this should not happen unless the stack.yaml or cabal file mentions (or uses via dependency) Crypto.Cipher.AES, and in that case stack will just reinstall it
17:45:27 <geekosaur> adjointfunctor, that information belongs in the cabal file, duplicating it in a source file is asking for problems if things change in the future
17:45:34 <geekosaur> and this is not one of the things people would look for
17:45:51 <adjointfunctor> stack_help: Can you check if you have any haskell-related distributive packages installed?
17:45:59 <geekosaur> and, not just people; I think this can confuse cabal and stack because they expect that ifnrmation to be in the cabal file
17:48:11 <stack_help> geekosaur: I ran the "stack exec ghc-pkg check" command. Aside from a bunch of missing haddock warnings (none of which were for cipher-aes), it lists a few packages that are broken
17:48:18 <stack_help> still cipher aes isn't one of them
17:49:06 <geekosaur> ok, tht sounds wrong. unless it's being brought in by a stack.yaml?
17:49:13 <geekosaur> in which case you should fix that
17:49:37 <geekosaur> this .. is really a situation that should not happen uness the cabal file or stack.yaml is specifically asking for it to happen
17:51:01 <geekosaur> I mean, the whole point of sandboxes is to hide packages you are not specifically requesting
17:51:43 <geekosaur> and if something is specifically requesting it then removing it will just cause it to be reinstalled
17:52:12 <stack_help> yeah, it wasn't it my global stack.yaml file
17:52:20 <stack_help> should I be checking ~/.cabal next?
17:52:56 <stack_help> if I decide to nuke ~/.stack, would I have to just reinstall stack from scratch from the website, and install libs one by one as I need them?
17:53:06 <geekosaur> stack itself iwll still be installed
17:53:14 <geekosaur> it'll redownload and reinstall a lot of stuff
17:54:05 <stack_help> okay, so "rm -rf ~/.stack", and then "stack install" whatever I need?
17:54:10 <geekosaur> yes
17:54:23 <stack_help> thank you so much for all of the help, I really appreciate it
17:54:27 <geekosaur> it may also change your default resolver if there's been a new LTS released
17:54:33 <adjointfunctor> stack_help: Can you paste your project .cabal file?
17:55:22 <stack_help> This is actually just a stack script, I didn't create a new projct
17:55:25 <stack_help> *project
17:55:54 <stack_help> @adjointfunctor
17:55:54 <lambdabot> Unknown command, try @list
17:55:57 <monochrom> stack does things in mysterious ways.
17:57:05 <Welkin> just like god
17:57:07 <Welkin> oh wait
17:57:23 <stack_help> this is hilarious
17:57:26 <stack_help> I nuked .stack
17:57:29 <stack_help> same error
17:57:44 <stack_help> but now I'm reinstalling things
17:57:51 <geekosaur> well. you may in fact be forced to use PackageImports
17:58:04 <adjointfunctor> stack_help: what distro are you using?
17:58:18 <geekosaur> although, also look at the stack manual, it has a way of specifying that for scripts that doens't go behind stack's back
17:58:29 <adjointfunctor> stack_help: also, are you installing everything user-wide?
17:58:33 <Axman6> this isn't how stack works - the problem is either you're using two packages which rely on cryptonite and cipher-aes, or because you're using a stack script, it's finding the needed deps based on module name, and there are multiple modules using the same module name
17:59:21 <stack_help> @adjointfunctor, I'm using version 1.4
17:59:22 <lambdabot> Unknown command, try @list
17:59:56 <stack_help> and yeah, I did stack install too many times probably, when I should be doing stack build
18:00:10 <geekosaur> https://docs.haskellstack.org/en/stable/GUIDE/#using-multiple-packages
18:00:15 <lyxia> stack_help: @ on IRC confuses lambdabot
18:00:17 <geekosaur> and following sections
18:01:50 <stack_help> lyxia, thanks haha
18:01:52 <WinterFox[m]> I saw the base haskell package `(<$) =  fmap . const`. Is the `(<$)` just a function name or is there something special going on with it?
18:02:04 <stack_help> and geekosaur, perfect, I'll try that
18:02:08 <hpc> yeah, it's how you define operators
18:02:14 <hpc> @src (.)
18:02:14 <lambdabot> (f . g) x = f (g x)
18:02:17 <monochrom> When I said "when in doubt, nuke", I had a clean install of an OS and a cleanly newly created user account in mine.
18:02:28 <hpc> the parens mean to treat it like a regular identifier when parsing
18:02:36 <hpc> it's the opposite of backticks
18:03:03 <stack_help> Axman, I only import Crypto.Hash.SHA256 and Crypto.Cipher.AES, which are both apart of cryptonite I beleve
18:03:24 <stack_help> along with bytestring and Data.Serialize
18:03:43 <geekosaur> ah. I think in that case you are encouraged to use a real project --- but of course that doesn;t work for scripts. the dtuff I pointed to will warn you about that and possible consequences
18:03:52 <geekosaur> but sometimes that's what you need to do
18:04:21 <stack_help> fair enough, either way, this has been pretty helpful
18:05:02 <stack_help> I appreciate the effort. I usually get so anxious when I try to tackle a stack problem on my own haha
18:05:16 <monochrom> I have a cunning plan. Use the Backpack language. You specify packages and program code in the same *.bpk file. >:)
18:05:59 <monochrom> http://blog.ezyang.com/2016/10/try-backpack-ghc-backpack/
18:06:10 <Welkin> it's a language?
18:06:31 <hpc> even gzip is a language ;)
18:06:37 <geekosaur> in the same way the contents of cabal files is a language
18:06:55 <monochrom> Well, Backpack is not just a language, but it includes a language, intended to be an intermediate language you never need to use, but there is a way if you want.
18:07:02 <stack_help> oh wow, that's neat. I'm not really surprised, considering how many PL people love haskell
18:07:18 <stack_help> I should try it out sometime (dunno for this though)
18:07:44 <monochrom> And this language is more advanced than the stack language by 10 years.
18:07:57 <adjointfunctor> stack_help: your case just need `stack new` =)
18:08:30 <Welkin> how is gzip a language?
18:08:33 <Welkin> it's an application
18:09:09 <monochrom> hahaha
18:09:44 <hpc> Welkin: the file format is a binary-encoded language that when interpreted, outputs a file
18:10:01 <adjointfunctor> Welkin: But application is just processor tongue =)
18:10:02 <monochrom> I am not extreme enough to claim "gzip is a language" or even "gzip specifies a language" but I do enjoy watching these semantic wars.
18:10:10 <hpc> Welkin: you can even write quines in it - http://compgroups.net/comp.compression/gzip-decompression-quine/169305
18:10:33 <Welkin> I don't get what backpack is for
18:10:49 <monochrom> I understand. I was like you 6 months ago.
18:11:23 <hpc> monochrom: it's a useful thought exercise when learning how to design DSLs ;)
18:11:30 <monochrom> Investing time in a solitude, turn-off-IRC reading session fixed it for me.
18:11:52 <monochrom> But I be damned about gzip quines.
18:12:55 <hpc> monochrom: perhaps you learned something today too :D
18:12:56 <monochrom> Also, http://www.smbc-comics.com/comic/kids-vs-adults
18:14:25 <Welkin> https://github.com/ekmett/quine ?
18:14:44 <Welkin> not sure what a quine is, besides an animal and kmett's toy project
18:14:52 <hpc> a quine is a program that outputs itself
18:15:08 <hpc> a simple example in bash would be #!/bin/env cat
18:15:29 <hpc> a file with that at the top will be executed with cat, and its own source will be spat out
18:17:47 <Welkin> is that useful in any way?
18:18:05 <monochrom> No.
18:18:14 <adjointfunctor> Yes.
18:18:47 <monochrom> But still more useful than watching TV.
18:19:07 <KoH> hm.. I haven't been around this ecosystem for as long as >20 years: why are Float/Double instances of Ord? IEEE does not specify any ordering for e.g. NaN/Inf. Is this going to be fixed/deprecated by a future standard?
18:19:11 <Axman6> stack_help: the problem is that crypto-aes _also_ has the module Crypto.Cipher.AES, and when using stack scripts, the module name is what's used to figure out which package is needed - did you try the PackageImports idea that was suggested to you?
18:19:11 <monochrom> And more people watch TV than writing or reading quines.
18:19:43 <Ojd> hello all, I am wondering if anyone has played with EasyPlot
18:19:59 <Ojd> i have some questions about the graphic settings
18:20:04 <monochrom> Kind of bring us to the inconvenient question: Are people useful?
18:21:04 <avatias0[m]> Not when they deliberately misinterpret the meaning of a question
18:21:07 <adjointfunctor> monochrom: Define utility dunction first =)
18:21:13 <adjointfunctor> function*
18:21:34 <geekosaur> KoH, becuase people get confused when they can't compare or sort Double-s
18:21:42 <geekosaur> most people don''t think about NaN or Inf
18:22:18 <KoH> geekosaur: so it's a convenience thing, ok.
18:23:04 <Welkin> could you pay someone else to watch your TV for you?
18:23:15 <Ojd> I am trying to replicate this https://github.com/rasbt/python-machine-learning-book-2nd-edition/blob/master/code/ch02/ch02.ipynb using haskell
18:23:16 <Welkin> what's the purpose of watching a TV?
18:23:52 <Ojd> and I am almost done, except for putting titles on the axis
18:23:55 <monochrom> I'm too cheap to do that. But if I had more money, I could.
18:24:04 <geekosaur> KoH, in general the Num hierarchy and related typeclasses are convenience things
18:24:16 <monochrom> I also think I heard that such a job actually exists.
18:24:21 <geekosaur> people who want actual math hierarchoies should look into e.g. numeric-prelude or other alternatives
18:24:39 <KoH> thanks, will do
18:25:24 <KoH> is there some formulation of computations with real numbers, there?
18:25:57 <monochrom> Oh yeah, here it goes: Governments hire people to watch a TV show to determine whether it is PG-13 or not etc.
18:28:44 <monochrom> Are you OK with restricting to cyclotomic numbers? There is a package for that on hackage.
18:29:41 <monochrom> Personally I am OK with IEE754.
18:29:58 <KoH> hm, no, not really :)
18:53:50 <Axman6> I thought the PG-13 ratings in the US come from a (very conservative) third party
18:53:53 <dumptruckman> what does this type signature signify? [Float -> Float]
18:54:02 <rotaerk> yay, solved my abstraction problem:  http://lpaste.net/358719
18:54:11 <Welkin> they are not from the government
18:54:16 <Axman6> KoH: have you looked at the numeric package?
18:54:21 <ezyang> monochrom: I think I fixed the Section/Chapter typos. There was only one case of Reg/Regex in diagrams I could find in the tutorial, but I think it's legit (I added a clarifying comment to the figure) 
18:54:22 <Axman6> > pi :: CReal
18:54:26 <lambdabot>  3.1415926535897932384626433832795028841972
18:54:37 <Welkin> > pi
18:54:41 <lambdabot>  3.141592653589793
18:54:43 <Axman6> > showCReal 80 pi 
18:54:47 <lambdabot>  "3.1415926535897932384626433832795028841971693993751058209749445923078164062...
18:54:55 <Welkin> what
18:55:07 <Welkin> what is CReal?
18:55:58 <geekosaur> "computable reals"
18:56:37 <avatias0[m]> > let secret = "shh"
18:56:41 <lambdabot>  <no location info>: error: not an expression: ‘let secret = "shh"’
18:56:54 <geekosaur> @hgackage numbers
18:56:54 <lambdabot> http://hackage.haskell.org/package/numbers
18:57:02 <geekosaur> ...i akn type...
18:57:03 <dumptruckman> what does this type signature signify? [Float -> Float]
18:57:32 <dumptruckman> why is the arrow inside the brackets
18:57:34 <geekosaur> a list of functions, each of which takes a Float and produces a Point
18:57:39 <dumptruckman> oh
18:57:41 <geekosaur> er, a Floayt
18:57:51 <dumptruckman> gotcha
18:58:04 <rotaerk> my FList, perhaps a better name would be HFList or something
18:58:32 <rotaerk> is like an HList but with a functor wrapping each sublist
18:58:33 <monochrom> geekosaur: A paper by Ralf Hinze contains the pun "yes we kan" as a pun for "yes we can" and "use Kan extensions"
18:58:35 <Axman6> KoH: https://www.youtube.com/watch?v=LJQgYBQFtSE also
18:59:51 <adjointfunctor> rotaerk, did you try to implement heterogeneous lists?
19:00:42 <rotaerk> adjointfunctor, not what I set out to do, but after building it I realized it was pretty close
19:01:19 <rotaerk> my goal was to be able to represent a data type as a series of values, but where prefixes are also valid, albeit a different type
19:01:39 <monochrom> Axman6: That looks neat, thanks.
19:01:40 <rotaerk> in this case, a DSum TestTag (FList Identity) is a type that can only represent complete values
19:01:53 <rotaerk> a DSum TestTag (FList Maybe) is a type that can represent prefixes of values
19:02:14 <rotaerk> e.g. in that snippet, flistMaybeTest is a prefix of flistIdentityTest
19:02:28 <monochrom> Now in "watch later" which is a backlog of 50 videos or something.
19:02:55 <Welkin> flist?
19:03:26 <rotaerk> F as in functor, but I'm not sure what a better name would be :P
19:03:30 <rotaerk> perhaps HFList
19:03:38 <rotaerk> like an HList but with a functor twist to it
19:03:41 <Welkin> and C is for Cookie
19:04:36 <rotaerk> Welkin, did you figured out DSums?
19:04:50 <monochrom> System FC = functor cookie? :)
19:04:59 <rotaerk> figure *
19:05:09 <Welkin> rotaerk: yes I think I understand them after your explanation
19:05:37 <Welkin> what does haskell use? system F-omega?
19:05:41 <Welkin> or was it system W?
19:05:50 <Welkin> I never found any information on system W
19:05:51 <rotaerk> with a DSum, the tag part provides a type specification that must be matched by the functor on the right
19:05:59 <monochrom> F-omega or very close to.
19:06:03 <rotaerk> if the functor is Identity, then that value must be exactly what the type specification states
19:06:34 <rotaerk> if you use the functor (FList Identity) though, then the type spec is going to be a list of types
19:07:09 <monochrom> Or more precisely, GHC uses it.
19:07:27 <rotaerk> and the actual value in the DSum is going to be basically an HList of those specific values
19:07:35 <rotaerk> err of those specific types
19:08:00 <rotaerk> if you use FList Maybe, then it's going to be like an HList of those types, but the list can end prematurely
19:08:59 <rotaerk> Tag 1 :=> 5 >:> flNothing;  Tag 1 :=> 5 >:> "hi" >:> flNothing;  Tag 1 :=> 5 >:> "hi" >:> 6.2 >:> FNil
19:09:08 <rotaerk> all of those are valid instances of DSum TestTag (FList Maybe)
19:09:35 <rotaerk> but only the last one is a valid instance of DSum TestTag (FList Identity)
19:10:13 <rotaerk> anyway... this resolves the abstraction issue I was trying to figure out...
19:10:27 <rotaerk> s/Tag 1/Tag1/
19:11:31 <adjointfunctor> rotaerk, can you elaborate on the issue?
19:11:36 <KoH> Axman6: briefly, yes; nothing usable wrt. Reals so far ... David Lester's package I know, but not what I'm looking for
19:12:10 <KoH> Axman6: yeah, exact real arithmetic is what I mean
19:13:06 <rotaerk> adjointfunctor, I'm going to be sending serialized messages across a ZMQ socket.  In ZMQ, a subscriber can specify a filter of which messages to subscribe to, but this filter is strictly a prefix of the message
19:13:35 <KoH> don't need much more than 'type Real = Int -> Approx'
19:13:39 <rotaerk> so, I wanted to be able to represent either a complete message or a prefix of the message (but with one type guaranteeing a complete message)
19:14:04 <rotaerk> so I initially had something like this:  https://github.com/Rotaerk/iircc/blob/master/src/common/Network/IIRCC.hs
19:14:49 <rotaerk> ClientEventTag's FromSessionF, for instance, consists of a session name, a session event tag, and then the details of the session event
19:15:57 <rotaerk> but to support ONLY having the client event tag (i.e. the smallest prefix), I needed to make the rest of the tag optional... so I wrap them in a f
19:16:12 <rotaerk> and then within that I wrap the next part after the session name in a f, and so on
19:16:31 <rotaerk> if f = Identity, then it's a complete message; if f = Maybe, then prefixes are allowed
19:17:02 <rotaerk> ClientEventFilter = ClientEventTag Maybe;  ClientEventHeader = ClientEventTag Identity;  ClientEvent = DSum ClientEventHeader Identity
19:17:29 <rotaerk> but I didn't like having to manually weave these f's into the types... error-prone
19:17:46 <rotaerk> so this FList thing provides an abstraction of this
19:19:36 <rotaerk> ClientEventTag can be defined like:  data ClientEventTag :: [*] -> * where { SessionStarted :: ClientEventTag '[SessionName]; FromSession :: ClientEventTag [SessionName, SessionEventtTag rest, rest]; ... }
19:20:18 <rotaerk> err no, that last one should be:  FromSession :: ClientEventTag (SessionName : SessionnEventTag rest : rest)
19:20:38 <rotaerk> adjointfunctor, does that make sense?
19:22:21 <adjointfunctor> rotaerk, not really know anything about ZMQ, but that seems to solve your problem
19:23:02 <adjointfunctor> rotaerk, still seems to me overly abstract, but that is because of my ignorance
19:23:52 <rotaerk> it's more abstract than I need it to be (e.g. can support FList []), but I don't see a simpler abstraction
19:24:52 <rotaerk> adjointfunctor, ZMQ is just a messaging system; you can, for instance, create a publisher endpoint through which you'll be sending messages (as raw bytestrings), and then something else can subscribe to that endpoint to receive published messages
19:25:08 <rotaerk> but the subscriber, when they subscribe, can supply a filter which says ... only send me messages that have this prefix
19:26:33 <rotaerk> for publisher-side filtering
19:27:16 <rotaerk> but I need to make sure that I can represent filters *and* that their encoding is a prefix of the full message's encoding
19:29:02 <monochrom> Aw, I have to write (Eq a, Num a, Eq b, Num b)
19:29:47 <rotaerk> why?
19:29:53 <geekosaur> type OldNum a = (Eq a, Num a, Show a) -- ConstraintKinds extension
19:30:01 <monochrom> Heh
19:30:05 <rotaerk> doesn't Num imply Eq?
19:30:10 <geekosaur> not any more, no
19:30:13 <geekosaur> hence OldNum
19:30:18 <rotaerk> ah
19:30:19 <monochrom> "That ship has sailed"
19:31:10 <rotaerk> are there non-equatable numbers or something?
19:31:26 <adjointfunctor> rotaerk, how do you model messages, again? Just prefix and data?
19:31:27 <Welkin> perhaps for irrational numbers?
19:31:30 <geekosaur> the snarky answer to that is Double
19:31:36 <Welkin> how would you know if they equate
19:31:47 <rotaerk> true
19:32:36 <monochrom> CReal is also pretty non-equatable.
19:32:46 <KoH> reals never are
19:33:04 <rotaerk> adjointfunctor, conceptually, a message is just an ADT, but to allow prefixes without duplicating my definitions, I had to represent it differently
19:33:05 <monochrom> The current CReal implementation approximates (==) by looking at just 40 digits or something.
19:33:17 <KoH> xD
19:33:49 <monochrom> Think about it. This is no better than IEEE754. Pot vs kettle.
19:33:52 <rotaerk> adjointfunctor, simple representation:  data Message = Foo Int String | Bar (Maybe String) [Int]
19:33:58 <geekosaur> equality is futile, you will be approximated?
19:34:30 <rotaerk> representation to allow for working with FList, and to allow prefixes:  data Message :: [*] -> * where { Foo :: [Int, String]; Bar [(Maybe String), Int] }
19:34:35 <KoH> equality is an overrated concept
19:34:49 <rotaerk> err sorry, that should be MessageTag, not Message
19:35:08 <rotaerk> then:  type Message = DSum MessageTag (FList Identity)
19:35:31 <rotaerk> and:  type MessageFilter = DSum MessageTag (FList Maybe)
19:35:42 <koz_> What exactly is the semigroup function stimes meant to do?
19:36:25 <adjointfunctor> rotaerk, why not `data Message = Message Prefix String; data Prefix = Foo | Baz`? 
19:37:38 <rotaerk> adjointfunctor, say you have this messagae: (Foo 5 "hi").  a prefix might be (Foo) or it might be (Foo 5) or it might be the full message
19:37:50 <KoH> == :: Algebraic t => t -> t -> Bool
19:38:13 <lyxia> KoH: stimes 5 a = a <> a <> a <> a <> a
19:38:17 <lyxia> koz_: ^
19:38:19 <rotaerk> adjointfunctor, a (Foo) filter would mean "give me all the Foo messages"; (Foo 5) would mean "give me all the Foo messages where the first field is 5", etc
19:38:40 <koz_> lyxia: Ah, I see.
19:38:56 <rotaerk> so when I say "prefix" I don't simply mean the constructor
19:39:01 <KoH> lyxia: sry, fail to parse
19:39:30 <lyxia> KOH sorry that was tabcompletion failure, that was meant to koz_.
19:39:48 <rotaerk> adjointfunctor, another problem with your example is that you're shoehorning a String into both Foo and Baz, when Foo expects an Int and a String, and Bar expects a (Maybe String) and a [Int]
19:39:57 <rotaerk> so it's not typesafe
19:39:58 <KoH> ack
19:40:13 <adjointfunctor> rotaerk, is there a way to use partially applied constructors?
19:41:02 <rotaerk> Foo :: Int -> String -> Message;  Foo 5 :: String -> Message;  Foo 5 "hi" :: Message
19:41:36 <rotaerk> they're all of different types; also I couldn't exactly encode Foo, since it's a function, not an ADT
19:41:54 <rotaerk> or whatever the term is for a fully applied constructor
19:42:40 <adjointfunctor> rotaerk, can you use partially applied constructor to filter a list of messages?
19:43:00 <rotaerk> ZMQ requires a bytestring as a filter
19:43:15 <rotaerk> I would need to encode my prefix (e.g Foo) as a bytestring and pass it to ZMQ
19:44:57 <rotaerk> now, I would do something like:  encodeMessageDSum (Foo :=> 5 >:> "hi" >:> FNil) to encode a complete message
19:45:20 <rotaerk> and:  encodeMessageDSum (Foo :=> flNothing)  to encode the prefix of Foo
19:45:36 <rotaerk> or:  encodeMessageDSum (Foo :=> 5 >:> flNothing)  to encode the prefix of Foo 5
19:47:28 <rotaerk> I should find some better operator identifiers though...
19:47:52 <adjointfunctor> rotaerk, what happens, if you use []?
19:48:06 <rotaerk> you mean FList [] ?
19:48:11 <adjointfunctor> +
19:48:35 <rotaerk> +?
19:49:00 <adjointfunctor> rotaerk: yes, I mean `Flist []` =)
19:49:04 <rotaerk> k
19:49:46 <dumptruckman> Can someone help me understand strictness? More specifically how to determine if a function is strict?
19:50:13 <rotaerk> adjointfunctor, well, that would allow you to have, say, Foo, followed by a list of Ints, and *each* Int would be followed by a list of Strings
19:50:19 <rotaerk> so it's like a set of prefixes I guess
19:50:32 <rotaerk> set of filters
19:50:39 <pacak> dumptruckman:  Function is strict when it produces no thunks in the result.
19:50:42 <rotaerk> which I might actually utilize, now that I think aboutt it
19:51:06 <rotaerk> since the subscriber will want to subscribe to a multiple filters
19:51:11 <pacak> > take 2 (1:2:undefined)
19:51:15 <lambdabot>  [1,2]
19:51:19 <dumptruckman> pacak: but how do i tell if that is going to happen?
19:51:35 <pacak> take is lazy with respect to parts of the list it's not touching
19:51:44 <pacak> > tail $ take 2 (undefined:2:undefined)
19:51:47 <lambdabot>  [2]
19:51:53 <pacak> Or elements
19:52:12 <rotaerk> something analogous to:  (Foo, [(5, ["hi", "lo"]), [(7, ["bar"])])
19:52:19 <pacak> dumptruckman: Hmm... You need to look for case expressions, seq and !
19:52:47 <pacak> If you making a decision based on something - it will be evaluated
19:52:48 <adjointfunctor> rotaerk, does a concept of set of prefixes exist in ZMQ?
19:53:03 <adjointfunctor> pacak, https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Demand
19:53:20 <jle`> dumptruckman: you'd have to look at the definition
19:53:20 <dumptruckman> hmm ok
19:53:29 <rotaerk> adjointfunctor, with ZMQ you can subscribe and provide multiple filters
19:53:30 <jle`> dumptruckman: one easy way is to try to evaluate it yourself
19:53:32 <jle`> by hand
19:53:36 <dumptruckman> and try out some sample inputs?
19:53:39 <jle`> dumptruckman: and not 'force' anything you don't need to, or that you ignore
19:53:41 <jle`> yeah
19:53:47 <jle`> take 2 (1:2:undefined)
19:53:49 <jle`> @src take
19:53:49 <lambdabot> take n _      | n <= 0 = []
19:53:49 <lambdabot> take _ []              = []
19:53:49 <lambdabot> take n (x:xs)          = x : take (n-1) xs
19:53:52 <rotaerk> so I'd just have to iterate through the individual filters represented by that FList [], encode and subscribe to each
19:54:09 <jle`> take 2 (1:2:undefined) = 1 : take 1 (2 : undefined) = 1 : 2 : take 0 undefined = 1 : 2 : []
19:54:10 <rotaerk> not sure if I'll end up using it or not; maybe
19:54:14 <adjointfunctor> rotaerk, did you try to plug other types?
19:54:25 <rotaerk> I could just as easily use [FList Maybe] for tthat
19:54:27 <jle`> dumptruckman: haskell semantics follow this 'hand evaluation', as long as you only expand if you ever need to
19:54:40 <pacak> adjointfunctor: Or that, yes. I'm not sure if explaining worker/wrapper transformation to somebody who tries to understand basic idea of laziness will help.
19:54:42 <rotaerk> FList [] would just be a bit more efficient representation, and guarantees uniqueness of a filter
19:54:49 <rotaerk> well no, doesn't guarantee
19:55:00 <lyxia> dumptruckman: f is strict if   f undefined `seq` ()   throws an error
19:55:05 <jle`> dumptruckman: haskell as a language tries follow 'denotative semantics', for the most part, which means that the behavior of your code can be analyzed in terms of what the values represent mathematically
19:55:09 <lyxia> or hangs
19:55:20 <rotaerk> adjointfunctor, nope, Identity and Maybe are what I designed it for; [] I speculated about; haven't considered others yet
19:55:29 <jle`> dumptruckman: so the way 'take' behaves is exactly the way you'd have it work if you treated the definition literally
19:55:53 <jle`> it's literally just take 2 (1:2:undefined) being replaced by 1 : take 1 (2:undefined)
19:55:56 <rotaerk> also while this is very helpful for ZMQ filters, I can't imagine any other application of FList...
19:56:06 <jle`> because take n (x:xs) = x : take (n - 1) xs
19:56:12 <pacak> dumptruckman: Do you have any specific code that you are trying to understand?
19:56:43 <rotaerk> but maybe it would have other uses
19:57:04 <dumptruckman> eh, i'm just given a list of functions i have to determine if they are strict or not and if strict, which argument they are strict on
19:57:13 <adjointfunctor> rotaerk, since there is a type variable in your definition, either restrict it, or plug something to it, and see what happens =P
19:57:32 <jle`> dumptruckman: ah yeah, if you understand what it means to be strict, then you can just approach it by unraveling a few sample inputs
19:57:38 <adjointfunctor> rotaerk, that abstraction may be useful for other stuff
19:58:06 <dumptruckman> alright, i'll try it out, thanks
19:58:07 <jle`> dumptruckman: usually if there's a pattern match involved, it's strict in that argument
19:58:38 <jle`> to varying degrees of strictness
19:58:39 <dumptruckman> is there a good way to see the source of prelude functions without spamming this channel?
19:58:47 <rotaerk> hmm let's see what happens if it's a ((->)a)...
19:58:48 <jle`> you can look at the source on hackage
19:58:52 <jle`> but also you can pm lambdabot
19:58:58 <pacak> dumptruckman: Try looking at what it's doing to input. Passing it around usually lazy - that's what take does to elements. Using case statement or pattern matching is strict.
19:58:58 <jle`>  /q lambdabot @src take
19:59:00 <dumptruckman> ah ok
19:59:13 <jle`> be advised that @src doesn't actually return the sources of those functions
19:59:27 <jle`> it's basically a bunch of canned answers for different queries people cared about
19:59:33 <jle`> kind of like @quote
19:59:36 <jle`> @quite ls
19:59:36 <lambdabot> Maybe you meant: quote quit
19:59:40 <jle`> @quote
19:59:40 <lambdabot> expo873 says: This guy just sat down in the adjacent cubicle at the library. he smells homeless. I looked over and he's doing problems out of petersen's riemannian geometry textbook, it's always
19:59:40 <lambdabot> weird seeing other math students out in the wild.
20:00:07 <dumptruckman> ah
20:00:23 <jle`> and some of the snippets are actually out of date
20:00:35 <jle`> well, the "official" Prelude definitions are actually all in the Haskell report
20:00:52 <dumptruckman> how do i see those?
20:01:09 <jle`> https://www.haskell.org/onlinereport/haskell2010/haskellch9.html#x16-1710009
20:01:27 <dumptruckman> awesome, thanks
20:01:35 <jle`> these are also "out of date" in the sense that modern GHC does not follow them
20:01:40 <jle`> but it's useful for learning
20:01:58 <dumptruckman> well this is kind of confusing then
20:02:20 <dumptruckman> since School of Expression gives several definitions of reverse and is then asking me if reverse is strict
20:03:15 <jle`> maybe. does it specify which one?
20:03:27 <jle`> s/.//
20:03:29 <dumptruckman> nope
20:03:50 <jle`> well, there are some denotational aspects of reverse for lists that you can try to answer in terms of
20:04:14 <monochrom> Oh! I found out that I just need (Eq a, Num a, Num b), i.e., b doesn't need Eq
20:04:18 <dumptruckman> what do you mean by that?
20:04:18 <jle`> namely, can you figure out if the result uses (:) or [], without checking if the input uses (:) or [] ?
20:04:37 <dumptruckman> eh?
20:04:42 <jle`> like, if reverse _ = []
20:04:48 <jle`> reverse (something) = []
20:04:54 <jle`> how would you know if the answer should be []?
20:05:02 <jle`> you'd have to *look* at the input, and resolve whether it's : or []
20:05:25 <dumptruckman> which would make it strict?
20:05:31 <jle`> reverse can't say "The answer is []" or "the answer is _:_", unless it looks at its input to see if the input is [] or _:_
20:05:34 <jle`> which makes it strict yes
20:05:40 <Welkin> what does strict mean here?
20:05:45 <dumptruckman> but if i'm not seeing the definition used, then ?
20:05:46 <Welkin> Normal Form?
20:05:48 <jle`> if it *can* answer without pattern matching on the input, then it is not strict
20:05:55 <jle`> dumptruckman: well, this is kind of a theoretical thing
20:06:07 <jle`> there's no way you can implement reverse that doesn't peek at the input
20:06:15 <jle`> that doesn't pattern match eventually on the input
20:06:18 <dumptruckman> oh
20:06:23 <Welkin> so even WHNF is strict?
20:06:24 <jle`> like, can you imagine a way to do it?
20:06:24 <monochrom> "function f is strict" means f bottom = bottom
20:06:26 <dumptruckman> really?
20:06:39 <dumptruckman> i thought foldl wasn't strict though
20:07:25 <jle`> "foldl isn't strict enough" is more about the intermediate evaluations
20:07:51 <monochrom> So more stepping-back-ly, "xxx is strict" refers to how a function xxx behaves, not to an expression.
20:08:37 <dumptruckman> jle': i don't get it
20:08:42 <jle`> dumptruckman: about foldl?
20:08:46 <dumptruckman> yeah
20:09:08 <jle`> foldl defers evaluation to the very end
20:09:21 <jle`> where foldl' forces evaluation as you go along
20:09:36 <dumptruckman> ok, so both force evaluation
20:09:37 <jle`> but also this is kinda irrelevant to this
20:10:11 <jle`> the reason we know that reverse is strict is that reverse can't give any form of answer (at minimum, the constructor that the answer uses) without pattern matching on the input
20:10:29 <jle`> in general foldl doesn't have to obey this
20:10:39 <jle`> we're talking about a specific function, but foldl is a little more general
20:10:47 <monochrom> If anyone is interested, I will tell you my take on how foldl and foldl' are equally strict and therefore knowing strictness still does not tell you how much space is used.
20:11:47 * hackagebot SVGFonts 1.6.0.3 – Fonts from the SVG-Font format – https://hackage.haskell.org/package/SVGFonts
20:12:58 <adjointfunctor> dumptruckman, you need to grasp a concept of thunk. Thunk is a promise to evaluate an expression. `foldl` creates a lot of promises, and defers evaluation till the very end of it, while `foldl'` creates no promises, but evaluates as it goes.
20:13:21 <adjointfunctor> offtopic, SVGFonts have a huuuuge space leak
20:14:51 <rotaerk> I'm still confused, and have to think hard, about which fold to use
20:15:00 <pierrot> monochrom: I'm interested. In some situations like `foldl (+) 0 [1..10000000]` and `foldl' (+) 0 [1..10000000]`, it's obvious that the latter is more efficient in terms of space
20:15:21 <rotaerk> though really I don't use list folds all that much for some reason
20:16:01 <Welkin> you can fold lots of data structures
20:16:23 <Welkin> mostly commonly I will use them on Maps or Sets
20:16:57 <pacak> :t foldl
20:16:59 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
20:17:26 <pacak> > foldl (+) 0 (1,2)
20:17:31 <lambdabot>  2
20:17:42 <pacak> :)
20:17:42 <Welkin> foldl with be eplaced with foldl' when you compile with optimizations most of the time right?
20:17:50 <pacak> Welkin: Nope.
20:17:51 <dumptruckman> ok yeah, i still don't understand this
20:18:23 <dumptruckman> i worked out reverse [1, 2, 3] using reverse = foldl (flip (:)) []
20:18:41 <geekosaur> Welkin, sucg replacements can only be done if they are known not to affect strictness. But here affecting strictness is the point
20:19:01 <geekosaur> otherwise they change the meaning of code in ways that may make that code incorrect
20:19:06 <Welkin> and of course we have `product`
20:19:10 <Welkin> @src product
20:19:11 <lambdabot> product = foldl (*) 1
20:19:15 <Welkin> @src sum
20:19:16 <lambdabot> sum = foldl (+) 0
20:19:30 <Welkin> > product [1..10000]
20:19:31 <pierrot> but some of them are in fact replaced, aren't they?
20:19:34 <lambdabot>  2846259680917054518906413212119868890148051401702799230794179994274411340003...
20:19:37 <Welkin> > product [1..1000000000]
20:19:44 <lambdabot>  mueval-core: Time limit exceeded
20:19:56 <Welkin> > foldl' (*) [1..1000000000]
20:19:59 <lambdabot>  error:
20:19:59 <lambdabot>      • No instance for (Num [Integer])
20:19:59 <lambdabot>          arising from a use of ‘e_111000000000’
20:20:09 <Welkin> > foldl' (*) 1 [1..1000000000]
20:20:09 <monochrom> pierrot: Suppose I wrote a function "f x y" that takes two parameters and promise that f is strict in both --- f bottom y = bottom, f x bottom = bottom. And suppose the two actual parameters you pass to f are related --- maybe y is part of x, or maybe x is part of y, or maybe they share some subexpression.
20:20:15 <lambdabot>  mueval-core: Time limit exceeded
20:20:30 <Welkin> > foldl (*) 1 [1..10000]
20:21:07 <Welkin> lambdabot: hello?
20:21:12 <dumptruckman> flip (:) (flip (:) (flip (:) [] 1) 2) 3 => flip (:) (flip (:) (1 : []) 2) 3 => flip (:) (2 : (1 : [])) 3 => 3 : (2 : (1 : []))
20:21:12 <dumptruckman> at what point is this forcing evaluation?
20:21:12 <pacak> dumptruckman: http://www.well-typed.com/blog/2017/09/visualize-cbn/
20:21:12 <monochrom> So at this point you know my strictness but you still don't know my evaluation order, i.e., do I evaluate x first? do I evaluate y first?
20:21:12 <monochrom> I will evaluate both but I don't tell you which order and "strict in both" doesn't care.
20:21:18 <lambdabot>  2846259680917054518906413212119868890148051401702799230794179994274411340003...
20:21:29 <Welkin> > foldl (*) 1 [1..100000]
20:21:35 <lambdabot>  mueval-core: Time limit exceeded
20:21:37 <Welkin> > foldl' (*) 1 [1..100000]
20:21:44 <lambdabot>  mueval-core: Time limit exceeded
20:21:47 <Welkin> lol
20:21:48 <monochrom> Then space usage can still differ based on the order. Maybe it takes less space if I evaluate x first, more space if I evaluate y first.
20:22:18 <pacak> Welkin: Yea, foldl' is clearly superior.
20:22:36 <pierrot> monochrom: hmm yes
20:22:51 <pacak> > foldl' (+) 1 [1..100000]
20:22:54 <lambdabot>  5000050001
20:23:11 <pacak> Welkin: Problem is Integers are slow and you are doing a bunch of stupid computations by the end,
20:23:21 <Welkin> > sum [1..100000]
20:23:22 <monochrom> I used to have a simple example but I don't recall it now. OTOH foldl and foldl' are ready-made examples. foldl 0 (+) (a million bottoms) = bottom = foldl' 0 (+) (a million bottoms) so same strictness different space usage.
20:23:24 <lambdabot>  5000050000
20:23:45 <pacak> > foldl' (*) (1 :: Int) [1..100000]
20:23:48 <lambdabot>  0
20:23:52 <monochrom> So strictness is beside the point, you have to dig deeper into actual evaluation order, i.e., operational semantics.
20:23:56 <jle`> monochrom++
20:24:06 <adjointfunctor> monochrom, that is educating.  
20:24:31 <monochrom> Strictness is at the denotational level and it doesn't tell you shit.
20:25:28 <Welkin> what is the difference in space usage then?
20:25:39 <Welkin> won't the lazy version finish early?
20:25:39 <pierrot> it depends on the situation
20:25:41 <monochrom> It tells you "the final answer ought to be 5" or "there will not be a final answer" and it doesn't tell you how a computer should take steps to achieve that and it is deliberate, they defined denotational semantics to abstract away the computer.
20:25:50 <Welkin> one the first bottom
20:26:10 <Welkin> on
20:27:02 * pacak knows some of those words as well
20:27:47 <Welkin> wait
20:27:52 <Welkin> (+) is strict
20:28:27 <geekosaur> for the built--in numeric types, yes
20:28:46 <pacak> > const () (undefined + undefined :: Int)
20:28:50 <lambdabot>  ()
20:29:06 <monochrom> Then again, it is tempting to just compare the code of foldl with the code of foldl', see that the only difference is that foldl' has one more "seq", and conclude that this makes foldl' more strict, afterall seq's definition is "make things more strict", eh?
20:29:20 <geekosaur> it more or less compiles directly to the machine code applied to the value inside the internal constructor (for Integer, the appropriate gmp function)
20:29:42 <monochrom> Ah but in this case foldl and foldl' are equally strict, with or without the extra seq. The real explanation is less exciting.
20:30:05 <Welkin> I don't get it
20:30:10 <Welkin> how are they equally strict
20:30:20 <monochrom> The real explanation is that the compiler is not aware that foldl is strict. The addition of seq in this case increases the compiler's awareness.
20:30:37 <pacak> They are not equally strict in general case.
20:30:44 <adjointfunctor> also, about built-in numeric types, GMP supports numbers of form x*10^y, but in haskell they are not hardwired, is there any reason for that?
20:32:23 <monochrom> And also a leaky-abstraction knowledge that when you increase the compilers awareness to strictness, it re-orders evaluation in a predictable way that you find desirable.
20:32:35 <pacak> adjointfunctor: Integer uses some strange magic to avoid touching GMP if both integers are "small". Adding more tags will require more bits so slow mode will start sooner. Or so it seems.
20:32:44 <monochrom> foldl' works because of an abstraction leak. Yes.
20:33:12 <geekosaur> pacak, no magic, just a different constructor
20:33:15 <geekosaur> @src Integer
20:33:15 <lambdabot> data Integer = S# Int#
20:33:15 <lambdabot>              | J# Int# ByteArray#
20:33:35 <geekosaur> except in recent ghc there's a third constructor for negative GMP integers
20:33:58 <geekosaur> if it fits in a machine word then it gets S#, if not then it's handed to gmp and put in J#
20:34:51 <geekosaur> note that it does not check after operations and re-shrink it will fit; once a value gets switched to J#, it stays there in subsequent computations using it
20:34:52 <pacak> geekosaur: Hmm... I thought there was something more magical going on in ghc.
20:35:15 <adjointfunctor> I mean, is there a need to reimplement that in package like `scientific`, if there are support on the level of GMP?
20:35:26 <geekosaur> you may be remembering that the Report permits stealing bits
20:35:30 <geekosaur> ghc does not do so
20:35:45 <pacak> Maybe.
20:35:56 <geekosaur> (well. there is one special case where it does, because it knows pointers have to be aligned so it can use those bits as flags)
20:36:30 <geekosaur> (but that applies to *all* thunks, iirc, not just Integer values)
20:38:04 <monochrom> That doesn't count as stealing bits. The lower bits are unused anyway.
20:38:05 <mmaruseacph2> and is there a way to cast the value to go from the J# to the S#?
20:39:01 <monochrom> But it counts as robbing you a huge amount of memory because now Word8 takes 16 bytes because alignment has to be defended at all costs.
20:39:31 <monochrom> "This is not stealing, this is a heist". :)
20:40:53 <monochrom> Just earlier today in #haskell-beginner I explained how the following [Char]: [ '\NUL' .. ] takes n*(24 + 16) bytes.
20:41:58 <adjointfunctor> monochrom, damn, people coming from something like C will surely be shocked by that
20:42:10 <Welkin> monochrom: 3 bytes for the constructor and 2 for the character
20:42:42 <monochrom> Right, except s/byte/machine word = 64 bits = 8 bytes/
20:42:46 <Welkin> but what about the list consructor?
20:43:22 <monochrom> OK, (x : xs) the (:) takes 8 bytes, the x pointer 8 bytes, the xs pointer 8 bytes. 24.
20:43:53 <geekosaur> mmaruseacph2, not that I know of, but there might be some internal thing
20:43:59 <Welkin> and then the character is boxed
20:44:21 <Welkin> oh, you already accounted for that
20:44:44 <monochrom> The good news is, usually that's it, you don't have to count the actual Char's, because GHC generates an exe that carries a flyweight table of reusable shared common Char's. If you have "replicate n 'a'", you just have one copy of 'a', not n copies.
20:46:02 <monochrom> But [ '\NUL' .. ] is going to exceed that small table of flyweights and you have every different character under the sun appearing once, no reuse to speak of, so now you should count the content too.
20:46:53 <Welkin> isn't there a #Char like #Int ?
20:47:07 <monochrom> Yes. You can use it if you need to.
20:47:10 <Welkin> there are just integers after all
20:47:15 <Welkin> they are*
20:47:49 <geekosaur> mmaruseacph2, so I don't see one but oen could write one using guards and GHC.Integer.smallInteger
20:48:02 <monochrom> So for example Data.Text is a much better idea than [Char] if you are storing content rather than using [a] as a for-loop.
20:48:35 <monochrom> Data.Text is n*2 + O(1) bytes if you stay in the Basic Multilingual plane.
20:48:41 <Welkin> Text uses a sequence of 16-byte values
20:48:50 <monochrom> 16-bit, but yes.
20:48:58 <Welkin> yes
20:49:06 <Welkin> is this like a C array?
20:49:14 <monochrom> Yes, that's the idea.
20:49:39 <monochrom> Text is pointer to that array and a length field and an offset field.
20:49:43 <Welkin> would unboxed arrays be the same?
20:49:52 <monochrom> Yeah.
20:50:21 <monochrom> Well, maybe not quite.
20:50:34 <geekosaur> not sure about Text but there is a vector-bytestring package that handles ByteString as unboxed Word8 vectors
20:50:46 <monochrom> Data.Vector.Unbox for Char is going to be n*8 bytes.
20:51:13 <monochrom> Actually I don't know about that. n*4 or n*8
20:53:35 <mmaruseacph2> thanks, geekosaur, was mostly curious
21:38:55 * hackagebot directory 1.3.1.4 – Platform-agnostic library for filesystem operations – https://hackage.haskell.org/package/directory
21:40:23 <mutable_vector_n> hello! I'm trying to make an MVector (an unboxed mutable vector) of bytestrings into a type synonym, but I'm having trouble finding documentation on how to do this. Most sources explain how to use MVectors, but never how to declare their types. I tried MVector RealWorld ByteString, but I'm not sure if that's correct. I'm guessing that for the type MVector v a, a represents the type of the elements contained in the vector, 
21:41:11 <c_wraith> Well, the first major problem you're going to have is that you can't have an unboxed vector of bytestrings...
21:41:38 <mutable_vector_n> whoops! thanks for pointing that out
21:41:42 <mutable_vector_n> so boxed would be the way to go?
21:42:08 <c_wraith> for that, it's what you'll have to do
21:42:50 <c_wraith> So with Data.Vector imported, the type you want is just Vector ByteString
21:43:17 <c_wraith> Oh, wait, you said mutable
21:44:27 <c_wraith> So then, sure.  With Data.Vector.Mutable imported, MVector RealWorld ByteString would work, but the alias IOVector ByteString is easier to type.
21:47:57 <mutable_vector_n> c_wraith, thank you!
21:48:05 <mutable_vector_n> that helps a lot. I appreciate it
21:49:05 * hackagebot fast-mult 0.1.0.1 – Numeric type with asymptotically faster multiplications. – https://hackage.haskell.org/package/fast-mult
21:57:34 <Arahael> so, i like using pugs (used to be jade) for templating. is there a similar package that does it with haskell instead?
22:01:00 <Welkin> Arahael: there are lots
22:01:15 <Welkin> blaze-html is one of the original html combinator libraries
22:01:20 <Welkin> lucid is an improvement on it
22:02:00 <Welkin> then there are template languages that are not actual code, like hamlet and heist
22:05:28 <Arahael> Welkin: i meant like, a haskell implementation of something similar to, specifically, pugs
22:06:22 <Welkin> I'm not familiar with pugs
22:06:25 <Arahael> Welkin: to provide a means of generating an html file from a terse, whitespace sensitive input file that can include embedded script.
22:06:34 <Welkin> you can take a look at the suggestions I gave though
22:07:02 <Arahael> Welkin: from memory blaze is a set of haskell primitives that let you programmatically generate the file.
22:07:30 <Welkin> pugs looks like a standard template system to me
22:07:44 <Welkin> hamlet or heist would be most similar
22:08:03 <Arahael> thanks, i'll check those two out :)
22:08:18 <Welkin> no, blaze is not a set of "primitives", it is a collection of combinators (functions) to construct an html expression
22:09:50 <dsal> I'm having (hopefully) syntax pain.  How do I make an Eq instance for a type that has a type param that I need to constrain to have an Eq class    e.g.   instance Eq (Thing a)  ...    where Eq a
22:10:50 <Maxdamantus> Eq a => Eq (Thing a)
22:11:06 <Arahael> Welkin: hamlet is interesting and does seem similar.
22:11:32 <dsal> Maxdamantus: Thanks.  I tried a bunch of variations.  heh
22:12:34 <Maxdamantus> dsal: fwiw, the :info command in GHCi can probably help in figuring out how various type-level declarations work.
22:13:05 <Maxdamantus> dsal: eg, can see that structure when doing `:i Maybe`, since there's an `instance Eq a => Eq (Maybe a)`
22:13:10 <sm> Arahael: here is an incomplete list of possibly relevant options
22:13:13 <sm> https://stackoverflow.com/questions/5770168/templating-packages-for-haskell
22:13:17 <Arahael> heist looks verbose
22:13:28 <Arahael> thanks sm, will look at those too
22:13:42 <sm> heist is hard to figure out!
22:15:09 <Arahael> thinking hamlet might be the closest, more verbose than pugs, but not by much.
22:16:03 <Welkin> I enjoyed using hamlet when I used yesod
22:16:20 <Welkin> I've since moved away from template languages and prefer html combinators like blaze or lucid
22:17:11 <Arahael> Welkin: any particular reason?
22:17:58 <Arahael> Welkin: the nice thing about template systems is you can often use them without a supporting backend.
22:18:11 <dsal> Maxdamantus: Ah, I always forget about :i
22:18:18 <Arahael> eg, i can push v1 just out to a static site.
22:19:57 <Welkin> Arahael: html combinators give you the same output (a static html file), but you write it in a slightly different way
22:20:15 <sm> if you're interested in building static sites, you might also want to check out hakyll, yst, sprinkles, and a newer one I forget
22:20:23 <Welkin> it is part of your normal code instead of being a made-up language that needs to be parsed and doesn't have access to basic language features
22:20:39 <Welkin> yes, hakyll is good for building static sites (based on jekyll)
22:22:10 <Welkin> the main problems with template languages is that: 1) they don't allow you to use the full power of your programming language, and instead provide a gimped excuse for handling logic, and 2) it can be very easy to mess up your template syntax and get unhelpful parsing errors rather than a compiler error
22:22:29 <Arahael> Welkin: thats indeed the problem i have with pugs
22:22:44 <Welkin> html combinators eliminate both of these issues
22:23:36 <Arahael> maybe i should take another look at heist.
22:23:46 <Welkin> you mean lucid?
22:23:55 <Welkin> heist is similar to hamlet, a template language
22:24:42 <Arahael> ah, yes :)  lucid
22:28:48 <Arahael> thanks!
22:44:44 <Arahael> News from work: If upgrading to APFS for High Sierra, make sure you have "plenty" of free disk space.
22:44:53 <Arahael> Otherwise, it apparently just crashes and you have to reinstall.
22:46:59 <Rembane> Arahael: Ouch. How plenty is plenty?
22:48:05 <Arahael> Not specified.
22:48:33 <Arahael> And you can't opt out of it.
22:49:11 <Rembane> :D
23:08:33 <vector_newb> Let's say you're in a do block, and in the beginning, you use a mutable vector, then you use a when statement to modify the vector. After the when statement is over and you are back in your original do block, would the effect be visible?
23:09:52 <nshepperd> vector_newb: 'when' is like an imperative language's if (without else)
23:10:49 <Axman6> vector_newb: yes
23:11:53 <Axman6> if you have something like when (even i) $ do write vec i x, then that effect will be observable after the when clause
23:12:33 <vector_newb> okay, that's what I was hoping for! Thanks!
23:13:06 <Axman6> @src when
23:13:06 <lambdabot> when p s = if p then s else return ()
23:13:56 <Arahael> vector_newb: Haskell?
23:14:27 * Arahael could've sworn this was ##apple.
23:14:46 <Arahael> Sorry about my previous statement about APFS :)
23:15:13 <vector_newb> oh, okay! that makes sense for a definition for when. I think I was just not realizing you could have multiple return statements in a do block (even though it makes sense)
23:15:16 <vector_newb> thanks again!
23:22:36 <Axman6> ventonegro: return is a function, not a statement, it is nothing special - it does not work at all like return in other languages
23:23:06 <Axman6> bleh, sorry ventonegro, vector-newb left
23:32:16 <myname_> quit
23:44:26 <ongy> Axman6: that's why we should switch to pure as much as possible. return just confuses people coming from other languages
23:44:36 <Axman6> sure
