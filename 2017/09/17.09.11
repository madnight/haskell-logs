00:00:53 <dsal> @pl (\(a,b) -> a * b)
00:00:53 <lambdabot> uncurry (*)
00:01:02 <dsal> Man, I keep thinking I typed that...
00:02:11 <saurabhn_> parsnip: is it supposed to be my u/p for hub.docker.com ? tried multiple times but it just doesn't work!
00:03:32 <bvad> saurabhn_: What image are you trying to pull?
00:03:33 <Axman6> you probably need to read some socker-machine getting started docs (or docker for mac docs)
00:04:00 <saurabhn_> supreme nonsense -- https://stackoverflow.com/a/40921773/534481
00:04:13 <saurabhn_> wasted 10mins of my life on this!
00:04:25 <saurabhn_> works now.
00:04:32 <bvad> saurabhn_: Don't worry, you'll get to waste a lot more time on docker 
00:14:00 <jle`> anyone know where i can find a sample show instance i can use for my types
00:14:09 <jle`> like the haskell code with all of the showsPrec stuff
00:14:18 <jle`> i just want something i  can copy and paste/fix up to work for my types
00:14:58 <ertes-w> o
00:16:19 <bvad> 'lo
00:22:30 <ski> jle` : sample type ?
00:23:40 <jle`> data Foo = Foo Int
00:23:58 <jle`> er, it's ok now, i found an old version i did in some source code i wrote a while ago
00:24:39 <ski>   instance Show Foo
00:24:43 <ski>     where
00:24:52 <ski>     showsPrec p (Foo n) = showParen (p > 10)
00:24:54 <jle`> showsPrec p (Foo x) = showParen (p > 10) $ showString "Foo " . showsPrec 11 x
00:24:57 <ski>                         $ showString "Foo "
00:24:58 <jle`> oh sorry
00:25:00 <ski>                         . showsPrec 11 n
00:25:09 <ski> aye
00:25:22 <jle`> i wonder if there's some place this is online
00:25:42 <cocreature> jle`: -ddump-deriv :)
00:25:49 <ski> precedence is incremented to the right for `infixl', to the left for `infixr', and both to the right and to the left for `infix'
00:26:00 <jle`> oh, is ddump-deriv readable enough for this?
00:26:19 <ski> (and application is `infixl 10')
00:26:52 <cocreature> jle`: for your Foo type you get http://lpaste.net/358343
00:26:56 <cocreature> which is reasonably readable
00:27:23 <jle`> ah, not too bad
00:27:36 <jle`> much better than i was bracing for
00:28:32 <cocreature> jle`: with -dsuppress-module-prefixes and -dsuppress-uniques you get http://lpaste.net/358344
00:28:41 <ski> `Read' is pretty similar with `readParen' and `readsPrec'. `lex' for chopping off tokens
00:28:52 <cocreature> which apart from not using (.) in infix form is pretty much what you would write yourself
00:29:41 <ski> jle` : are you doing an existential or GADT ?
00:30:08 <jle`> it is coincidentally a GADT, but the gadt-ness isn't what is causing the issue
00:30:18 <ski> mhm, ok
00:30:25 <ski> irregularity, somehow ?
00:30:27 <jle`> i just want one of the fields to have a different show behavior than the automatically derived behavior for that type
00:30:39 <jle`> well, that sounds bad
00:30:40 <ski> mhm
00:30:41 <jle`> when i say it like that
00:30:55 <jle`> typically the Show instance requires a constraint on a type variable
00:31:22 <jle`> but in my case that constraint is unnecessary for that type, and i don't want the constraint to leak
00:31:50 <ski> sounds strange
00:32:12 <ski> not a phantom parameter then, i suppose
00:32:13 <cocreature> like a phantom type variable? does ghc really add constraints on those?
00:32:48 <jle`> it's a phantom but the constraint is coming from a type that uses the type that uses the phantom.  to state as vaguely as possible
00:33:08 <cocreature> *shrug* you probably know what you’re doing :)
00:33:12 <jle`> :)
00:33:22 <jle`> it's a type that is parameterized by a Functor
00:33:44 <jle`> and the show instance requires Show (f Blah)
00:34:18 <ski> oh, and you'd like something like `forall a. Show a => Show (f a)' required, i suppose ?
00:34:19 <jle`> er, i think i oversimplified it to the point where the problem shows up
00:34:40 <jle`> *doesn't show up
00:34:45 <ski> (or `Show1 f', possibly)
00:35:54 <jle`> to be specific, it's that parameterized hlist type (sometimes called Record), data Prod :: (a -> *) -> [a] -> * where PNil :: Prod f '[]; PCons :: f a -> Prod f as -> Prod f (a ': as)
00:36:24 <ski> oh, even polymorphic
00:36:44 <jle`> and the library that provides it for me provides a fancy Show instance based on a recursive type family
00:37:04 <saurabhn_> does anyone know how rust's #[something] annotations work, and the equivalent in Haskell?
00:37:16 <jle`> which works in many cases, but here i'm using f ~ Const String
00:37:18 <ski> so i suppose you want something like `All Show as', possibly
00:37:34 <Axman6> I've written that a few times
00:38:00 <ski> er, rather `All (Compose Show f) as' ? i think
00:38:20 <cocreature> All seems unnecessarily strong
00:38:31 <ski> (letting the `a's handle themselves)
00:38:38 <cocreature> oh nvm, I can’t read
00:39:04 <jle`> all great things but the problem is that the library defines an instance that's polymorphic for all f's
00:39:24 <jle`> so i just want to bypass the library's instance in this case, heh
00:39:48 <ski> so you're making a `newtype' ?
00:40:05 <cocreature> I’m still not sure why "f ~ Const String" causes problems
00:40:11 <ski> or making a custom instance for whatever uses `Prod' here ?
00:40:30 <jle`> i'm converting the Prod into a list of String's and showing that >______>
00:40:34 <[exa]> saurabhn_: what does it do in rust?
00:40:47 <saurabhn_> seems to be some sort of decorator or annotation.
00:40:51 <jle`> cocreature: it leaks an extra constraint
00:40:58 <Axman6> so, if I have data Average = Average !Double !Int, this is a Monoid. I'd also like to be able to subtract/cancel one average from another - is this as simple as remove  (Average a n1) (Average b n2) = Average (b-a) (n2-n1) (assuming n1 < n2)?
00:41:03 <saurabhn_> eg.
00:41:05 <saurabhn_> #[get("/world")]
00:41:06 <saurabhn_> fn handler() { .. }
00:41:07 <jle`> because of the way the Show instance for Prod is defined in this library
00:41:25 <jle`> it's possible to define Show for Prod that doesn't leak this constraint but in this case it sort of pops out.  not sure if i appreciate this design choice
00:42:05 <ski> Axman6 : .. i suppose ?
00:42:19 <[exa]> saurabhn_: so it takes the function definition and modifies it in some way or adds some additional processing to it?
00:42:44 <saurabhn_> [exa]: I'm guessing that's what it does. the same thing in python would be decorators, right?
00:42:48 <Axman6> trying to make sliding windows efficiently
00:42:55 <Axman6> hmm, actually, this doesn;t wuite work
00:42:58 <Axman6> quite*
00:43:47 <jle`> saurabhn_: in the case of python, it's basically syntactic sugar
00:43:56 <ski> jle` : what is the auxilary constraint that you don't want ?
00:44:05 <saurabhn_> what's the equivalent of this in Haskell?
00:44:10 <jle`> saurabhn_: i believe it's sugar for re-defining a new class that happens to have the same name as the old class
00:44:12 <jle`> and shadowing the old class
00:44:54 <jle`> i don't think there is any syntactic sugar for decorating functions in haskell
00:45:19 <jle`> all you are doing is basically defining a new function with the same name as your old function, and shadowing the old function
00:45:27 <jle`> which is kind of a weird design pattern
00:45:33 <jle`> in haskell you'd probably just use higher order functions
00:46:00 <ski> the new using the old ?
00:46:24 <ski> one could do open recursion stuff, if needed
00:47:10 <jle`> actually one similar thing from a high-level api standpoint might be quasiquoters
00:47:46 <jle`> a lot of libraries have $(something [d|  ....... |])
00:47:54 <jle`> where the ...... is normal haskell source code/definitions
00:48:00 <jle`> and the output is some transformed version of those definitions
00:48:45 <jle`> so those might be the closest literal analogy to python decorators....except haskell probably has better non-TH ways to do what people use decorators to do in python
00:50:04 <Axman6> saurabhn_: generally we prefer to use code rather than annotations for things like that
00:50:32 <saurabhn_> they're called attributes in Rust - https://doc.rust-lang.org/1.15.0/reference.html#attributes
00:51:28 <[exa]> saurabhn_: you usually don't need attributes in a system that's expressive enough
00:52:03 <saurabhn_> [exa]: please don't get me started on my "expressive enough" rant.
00:52:16 <[exa]> saurabhn_: sorry :] still, what's the thing you'd want to have working that would require attributes
00:52:24 <cocreature> if you’re just interested in adding metadata to definitions you can use annotations https://ghc.haskell.org/trac/ghc/wiki/Annotations
00:52:57 <saurabhn_> cocreature: have annotations been merged?
00:53:21 <cocreature> yes
00:53:30 <cocreature> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/extending_ghc.html?highlight=annotation#source-annotations
00:53:39 <saurabhn_> [exa]: if we had attributes, then one could do whatever servant is doing without the additional type machinery -- it seems.
00:54:04 <cocreature> but it’s up to you to define what the attributes do and it will at least involve TH or even a GHC plugin
00:55:06 <saurabhn_> attributes seem like what I need.... right now I've built hacky TH utils to get basic stuff done, which should be part of GHC IMO. but that's a rant for another time. Right now I just want a better less boilerplatish way of getting this done.
00:55:40 <cocreature> if you think it should be part of GHC, make a patch and submit it :)
00:58:38 <[exa]> saurabhn_: can you show the specific example?
00:59:17 <saurabhn_> [exa]: record subsets. There is no way to express that record A should have a subset of fields in record B in haskell.
00:59:28 <saurabhn_> Typescript has that, btw.
01:00:21 <[exa]> oh, records, yeah
01:01:43 <phadej> won't `Lens' A B` (B is subset of A) witness that?
01:01:57 <[exa]> phadej: target was to get rid of type machinery, not quite sure with lenses :]
01:02:06 <[exa]> but yes, that would be the obvious solution
01:02:39 <phadej> I mean, don't try to write "python in haskell", write haskell.
01:03:37 <[exa]> I'm kindof searching for argument why people should just forget about stuff with rigid structure (json/xml/partially even records) in functional programming
01:03:59 <arahael> why?
01:04:37 <arahael> saurabhn_: purescript also has that
01:05:00 <[exa]> arahael: mostly for the reason to see if those can be replaced
01:05:37 <phadej> [exa]: the arguments are similar to "why newtype and not just type"
01:06:26 <phadej> if I understand you right
01:06:46 <[exa]> I guess so, it's a good point
01:11:51 <ertes-w> saurabhn_: see how scotty works
01:12:24 <ertes-w> saurabhn_: we don't need that kind of "decorator" stuff in the language, because you can encode something like that in monadic semantics
01:14:44 <phaazon> hi
01:14:50 <phaazon> pacak: let’s fight again.
01:14:53 <phaazon> just kidding :D
01:17:04 <tdammers> attributes are isomorphic with type wrappers
01:17:30 <tdammers> or functions, depending
01:18:27 <[exa]> btw is there some kind of defaulting when OverloadedStrings are active?
01:19:06 <geekosaur> iirc not for 7.8 (defaulting needed some beefing up?), String for 8.x
01:20:09 <[exa]> cool
01:21:01 <geekosaur> er I meant 7.x but I don't know exactly when it changed
01:21:15 <cocreature> saurabhn_: you might be interested in https://www.reddit.com/r/haskell/comments/6zdc73/ghcdevs_a_type_checker_plugin_for_row_types/
01:21:46 <geekosaur> the bigger problem is that, absent ExtendedDefaultRules, defaulting isn't operable in most places you'd like it to be
01:22:46 <[exa]> wow there's even overloaded lists
01:23:02 <ertes-w> OverloadedLists is kinda stupid
01:23:09 <cocreature> overloaded lists is kind of annoying since it doesn’t work for a lot of usecases
01:23:34 <ertes-w> the IsList class insists on having a way to uncons
01:24:01 <cocreature> it also forces your list fo be homogenous
01:24:23 <cocreature> which excludes any kind of hlist for which I would really want OverloadedLists
01:24:56 <ertes-w> yeah…  i haven't found a single legitimate use case for it so far, and it has been there for quite some time now
01:25:07 <cocreature> I sometimes use it for vector
01:25:27 <magthe> Are there any known examples of tying the version in the Cabal file to the latest tag in the VCS (preferably git)?
01:26:17 <cocreature> magthe: I don’t think you can do that. the best you can do is write some script that generates the cabal file
01:33:22 <magthe> cocreature: yeah, that's what I assumed
01:34:47 <magthe> cocreature: do you know if there's a project that gets its version number that way already, something to look at and be inspired by? :)
01:34:47 <cocreature> magthe: sry, not aware of any project that does this
01:34:47 <cocreature> magthe: what seems to be more popular is release.sh scripts which create tags and bump versions numbers simultaneously
01:34:56 <cocreature> but even for that I don’t have an example at hand
01:35:47 <ertes-w> magthe: for local projects that i don't publish there is a 1:1 correspondence between cabal versions and git tags, so that i can refer to certain versions easily via nix
01:36:11 <ertes-w> it's a bit ugly, because maintaining that correspondence is a manual task, but it works well enough for me
01:36:25 <magthe> ertes-w: so no handy scripts or anything?
01:36:50 <cocreature> I thought the whole point of magthe’s question was to not have that be a manual task
01:36:59 <ertes-w> well, you could write a little version-bump script that updates the cabal version and creates a git tag in one command
01:37:22 <ertes-w> should be a two-liner: one sed command, one git command
01:37:40 <ertes-w> well, two git commands, because you need to commit first
01:37:46 <magthe> true, though the ideal situation would be if there weren't two things that need to be in sync... DRY and all that
01:38:05 <ertes-w> i'd rather not have cabal be git-aware =)
01:38:50 <ertes-w> in part because i hope not to have to use git for the rest of my life
01:44:01 <magthe> ertes-w: good point :)
01:45:11 <maerwald> should be doable via post-commit hook
01:45:18 <magthe> it could be "shell aware" though... the ability to call out to something to get a version number would be useful for me
01:45:39 <magthe> maerwald: yes, maybe that's the way to go
01:45:41 <cocreature> magthe: that seems like a really fragile solution
01:46:21 <cocreature> you’d end up with different versions on different systems or just can’t calculate the version because the script doesn’t run for you
01:47:23 <cocreature> and shipping .git just to be able to calculate the version number seems a bit overkill
01:48:18 <magthe> cocreature: it would be OK if sdist runs that script and puts a modified version of the .cabal in the tar-ball
01:48:46 <magthe> of course that would limit the ability to use something like `git archive` for distribution
02:14:26 <APic> Why, hello.
02:14:28 <APic> Sorry for yesterday.
02:14:33 <APic> I was severly disturbed.  ☺
02:15:40 <cheater> hi
02:15:49 <cheater> how can i simplify the following two lines to get rid of pathInsert?
02:15:50 <cheater>   pathInsert <- path --> "insert"
02:15:50 <cheater>   _ <- PyO.callArgs pathInsert [PyO.toObject idx, PyO.toObject newPath]
02:18:25 <ongy> with (<$>), (<*>) and join I think
02:18:55 <cheater> i thought i'd do something like:  ((path --> "insert") >>= PyO.callArgs) [.....]
02:19:03 <ski>   (`PyO.callArgs` [PyO.toObject idx, PyO.toObject newPath]) =<< (path --> "insert")
02:19:04 <cheater> but that doesn't seem to be the right thing to do.
02:19:21 <cheater> ski: why does my form not work?
02:19:46 <ongy> what's the type of PyO.callARgs
02:19:57 <cheater> oh, i get it, PyO.callArgs is a -> b -> m c, and we need the right argument of (>>=) to be d -> m e
02:20:00 <LiaoTao> Parameter order
02:20:05 <ski> `>>=' wants a function taking an intermediate result to an action, as right argument. you passed a function (curriedly) expecting two arguments and producing an action
02:20:14 <ski> aye
02:20:31 <ski> you can also use `flip' instead of the section, if you prefer
02:20:44 <LiaoTao> I was writing up the flip version when ski interjected
02:20:44 <LiaoTao> :)
02:20:48 <cheater> sure
02:20:54 <cheater> i think neither is really worth it then
02:21:00 <cheater> i'll just keep it on two lines
02:21:03 <cheater> LiaoTao: :)
02:21:11 <ski>   join (PyO.callArgs <$> path --> "insert" <*> pure [PyO.toObject idx, PyO.toObject newPath])  -- is an alternative. but looks a bit ugly, imho
02:21:29 <ongy> that was the first thing I came with... completly forgetting about (>>=)
02:21:32 <cheater> why do we need join?
02:21:37 <cheater> @type join
02:21:39 <lambdabot> Monad m => m (m a) -> m a
02:21:40 <cheater> :t join
02:21:41 <lambdabot> Monad m => m (m a) -> m a
02:22:10 <ongy> :t (<$>)
02:22:11 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:22:36 <cheater> :t \f a b -> (f <$> a <*> b)
02:22:38 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
02:22:50 <ski> @let infixl 4 <*>>; mamb <*>> ma = join (mamb <*> ma)  -- sometimes i define this
02:22:52 <lambdabot>  Defined.
02:23:09 <cheater> so in my last query, what is the functor f?
02:23:10 <ski>   PyO.callArgs <$> path --> "insert" <*>> pure [PyO.toObject idx, PyO.toObject newPath]  -- then it becomes this
02:23:38 <ski> (the `pure' there still looks silly to me, though)
02:23:39 <cheater> interesting, sky, but i still don't get where join comes from
02:23:46 <ongy> cheater: the monad you are using is also a functor (enforced in the newer base)
02:23:51 <cheater> sure it is
02:23:53 <cheater> i know that
02:24:01 <cheater> but that's not the monad i'm using
02:24:03 <ski> `join' because you're really doing monadic stuff. `PyO.callArgs' returns an action
02:24:04 <cheater> it's another functor
02:24:11 <cheater> i think
02:24:41 <ongy> the one lambdabot talks about? that's just *any* functor (applicative functor)
02:25:03 <ski> if you have `f :: A -> B -> C',`ia :: I A',`ib :: I B', then `f <$> ia <*> ib :: I C'
02:25:32 <ski> but now you have `f :: A -> B -> M C',`ma :: M A',`mb :: M B', and so `f <$> ma <*> mb :: M (M C)'
02:25:42 <ski> need the extra `join' to get back to `M C'
02:26:35 <ski> see ?
02:27:40 <cheater> got it
02:27:59 <cheater> that's well explained, thanks
02:28:34 <ski> just like `\f ia ib -> f <$> ia <*> ib' is `liftA2', one could name `\f ma mb -> f <$> ma <*>> mb' (iow `\f ma mb -> join (f <$> ma <*> mb)'), `extendM2'
02:28:47 <ski> `extendM' being just `(=<<)'
02:29:04 <ski>   (=<<) :: Monad m => (a -> m b) -> (m a -> m b)
02:29:17 <ski>   extendM2 :: Monad m => (a -> b -> m c) -> (m a -> m b -> m c)
02:29:22 <ski> &c.
02:29:58 <ski> (and `extendM0' would be just `id :: Monad m => m a -> m a')
02:30:02 <cheater> what if we wanted extendM3?
02:30:19 <cheater> we would still only ever use join once, right?
02:30:20 <ski>   \f ma mb mc -> f <$> ma <*> mb <*>> mc
02:30:26 <ski>   \f ma mb mc -> join (f <$> ma <*> mb <*> mc)
02:30:36 <ski>   \f ma mb mc -> join (liftA3 f ma mb mc)
02:30:48 <ski>   extendM3 :: Monad m => (a -> b -> c -> m d) -> (m a -> m b -> m c -> m d)
02:30:53 <ski> cheater, yep
02:34:15 <ski> (btw, for the original `PyO.callArgs', of course you can use `>>=' instead of `=<<'. that ordering may perhaps be preferable in your case)
02:35:10 <ski>   (path --> "insert") >>= (`PyO.callArgs` [PyO.toObject idx, PyO.toObject newPath])  -- i.e.
02:35:33 <cheater> sure
02:36:00 <ski> that might in fact be a habit i should pick up
02:36:02 <cheater> thanks, i guess that makes sense
02:37:39 <cheater> this python calling lib isn't so bad
02:37:50 <cheater> someone should wrap numpy with it.... /s
02:38:09 <cheater> (i think it would be a huge amount of work)
02:50:50 <NextHendrix> hi guys, is it possible to search with stack
02:55:21 <barrucadu> What do you mean?
02:55:43 <NextHendrix> well i can stack install, stack runghc etc
02:55:46 <NextHendrix> can i stack search
02:55:49 <NextHendrix> somehow
02:56:09 <phadej> search for what, packages?
02:56:15 <NextHendrix> yeah
02:56:51 <phadej> afaik no, I do "google hackage <topic>"
02:57:20 <NextHendrix> sure, command line option would be nice though 
02:57:23 <NextHendrix> cheers
03:25:20 <lavalike> NextHendrix: `cabal info <name>` is sort of search
03:32:21 <lavalike> these are quite different though http://hackage.haskell.org/packages/search?terms=either https://www.haskell.org/hoogle/?hoogle=either+%2Bpackage
04:06:18 <ertes-w> NextHendrix: i usually just go to <https://hackage.haskell.org/packages/> and search on the page
04:07:19 <ocharles> alanz: 
04:07:29 <alanz> hi
04:07:37 <ocharles> whoops, alanz - in ghc-exactprint, is there a way to recover the {-# LANGUAGE #-} pragmas?
04:07:48 <ocharles> is that an annotation? surprised it's not actually in the AST itself
04:07:55 <alanz> how do you mean, recover them?
04:08:10 <ocharles> as in work out which language extensions are used
04:08:18 <alanz> They should show up as comments, and if you parse with ghc-exactprint parsing utils they will be honoured?
04:08:27 <ertes-w> hint for firefox users:  create a bookmark to <https://hackage.haskell.org/package/%s>, open the bookmark properties and add a keyword "p", then you can go to the package 'bytestring' by typing "p bytestring" into the address bar…  if you just type "p", then hackage will redirect you to the page i just mentioned, so you can search on the page
04:08:42 <ocharles> I'm only using ghc-exactprint as an entry to parsing. I'll check the annotations on the module. Ta!
04:08:49 <alanz> ocharles: have a look at the ghc-exactprint parsing source, it will be in there
04:09:06 <ocharles> 👍
04:10:42 <alanz> ocharles: see https://github.com/alanz/ghc-exactprint/blob/master/src/Language/Haskell/GHC/ExactPrint/Parsers.hs#L269
04:11:15 <ocharles> super, thank you
04:11:51 <hexagoxel> ocharles: brittany's --dump-ast-full will display interleaved syntax tree and annotations
05:11:05 <jakub> how do you add curly braces into cabal description field in preformated bloc ('>')? 
05:11:42 <phadej> jakub: you don't yet, but it will work with next-Cabal
05:12:50 <jakub> phadej: oh ok, hmm, how am i supposed to add a multiline ghci input in the description then :D
05:13:17 <phadej> jakub: e.g. http://hackage.haskell.org/package/snippet-extractor-0.2.0/snippet-extractor.cabal is rendered correctly with Cabal HEAD atm
05:14:27 <jakub> phadej: ok, i think it will have to wait then :)
05:16:05 <phadej> jakub: you can write {} in cabal description today, eventually Hackage will be fixed
05:16:52 <jakub> phadej: yes, thats what i am going to do
05:25:35 <ertes-w> jakub: note that hackage renders your README.md, if you have one
05:26:04 <ertes-w> jakub: you need to include it via extra-source-files
05:26:45 <ertes-w> maybe that's a better place for examples, since it will also be rendered by services that aren't cabal-aware like online RCS providers
05:28:28 <jakub> ertes-w: good to know, thx, any good example (just to know where, what, and how it gets rendered)?
05:29:33 <ertes-w> jakub: lens
05:29:53 <ertes-w> on hackage it's rendered at the bottom, so scroll down
05:31:11 <k0ala> ay.
05:59:21 <haskellwelp> If I have a function like this "seperatorFunction (xa:xb:xc:xd) = " how do I use recursion to combine them again? seperateFunction ([xa]++[xb]....]) etc doesn't seem to work
06:02:03 <opqdonut> haskellwelp: if you want to rebuild the same list, just use (:), like "dropSecond (x:y:xs) = x:xs"
06:02:09 <opqdonut> haskellwelp: not sure why you mention recursion
06:02:52 <opqdonut> haskellwelp: when recursing over a list, a common pattern is something like this: doubleElements (x:xs) = x:x:doubleElements xs
06:07:52 <lavalike> NextHendrix: here's a start, json is pretty flexible to do something else with :D https://pastebin.com/raw/EGcUm10N
06:26:09 <haskellwelp> Feel silly for asking but how do I save a variable to increment as I go through a list?
06:26:25 <ertes-w> haskellwelp: you use recursion
06:26:36 <ertes-w> > let go x = x : go (x + 1) in go 0
06:26:38 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
06:27:08 <ertes-w> go 0 = 0 : go (0 + 1) = 0 : (1 : go (1 + 2)) = 0 : (1 : (2 : go (2 + 1))) = …
06:28:45 <haskellwelp> ertes-w: thanks but I don't understand what you mean
06:29:25 <Ferdirand> haskellwelp: tell us what you want to achieve
06:29:25 <ertes-w> haskellwelp: the way you represent state in haskell is via recursion…  instead of updating a variable in a loop, you use a function recursively with modified arguments
06:34:53 <Psybur> haskellwelp, you can also use zip and an infinite list
06:34:57 <Psybur> > zip [0..] ["dude","bro","sweet"]
06:34:59 <lambdabot>  [(0,"dude"),(1,"bro"),(2,"sweet")]
06:35:15 <mnoonan> haskellwelp, see http://lpaste.net/358348 for a (over-)simplified example
06:35:29 <mnoonan> it sums the list, and also keeps a counter of how many items are in the list
06:35:56 <mnoonan> (and leaks space :)
06:36:31 <ertes-w> > foldr(join(.).(:))[] "abc"
06:36:33 <lambdabot>  "aabbcc"
06:36:49 <ertes-w> imma call this the doubNip operateur
06:37:27 <ertes-w> it's monday…  don't pay attention to me
06:37:50 <haskellwelp> what is go in the code?
06:38:27 <[exa]> ertes-w: very swag
06:38:33 <mnoonan> haskellwelp, think of it kind of like the body of a loop
06:43:30 <haskellwelp> go is inline recursion?
06:44:07 <[exa]> yes, a recursive function that's defined inline
06:45:13 <[exa]> haskellwelp: btw if I got your original question you actually _have_ a list and want to iterate through it while saving some kind of 'state' ?
06:46:12 <Psybur> Oh no dont break out the monads! :D
06:46:22 <Psybur> Please don't! (oh god yes please do)
06:46:34 <EvanR> that is not a monad situation
06:46:47 <Psybur> Oh I see "state" and I think the state monad
06:46:58 <[exa]> Psybur: don't worry I am from arrows people
06:47:30 <EvanR> iterate through a list while saving some kind of state, the baseline here is a fold
06:47:46 <EvanR> fancier things exist for more specialized such task
06:47:58 <ertes-w> Arrows People… that sounds like a village from a horror movie
06:48:07 <[exa]> EvanR: still the monad instance for list is tempting isn't it
06:48:12 <mniip> hmmm
06:48:18 <[exa]> *maniacal laugh of arrows people*
06:48:23 <EvanR> that was what i thought Psybur was going at
06:48:27 <mniip> if arr :: (b -> c) -> a b c
06:48:39 <mniip> then what's a? a co-concrete category?
06:48:46 <[exa]> ertes-w: certainly sounds tribal
06:49:09 <mnoonan> mniip: "ncrete", surely
06:49:20 <[exa]> lol
06:49:21 <EvanR> n-crete
06:49:28 <haskellwelp> yeah exa I do have a list
06:49:38 <Psybur> > foldl (\(c,s) x -> (c+1,s+x)) (0,0) [1,2,3,4,5]
06:49:40 <lambdabot>  (5,15)
06:49:45 <[exa]> EvanR: like multi-islands
06:51:09 <[exa]> haskellwelp: you can save an extra parameter to the function. E.g. you call `processlist l i` where `i` is the initial value, and recurse using something like `processlist next_l updated_i`
06:51:33 <haskellwelp> http://lpaste.net/358349 have i understood this correctly?
06:51:48 <[exa]> btw is there an idiom for this? it's like map but with the extra memory (and don't try mapM)
06:52:08 <bartavelle> mapM!
06:52:27 <EvanR> mapAccum ?
06:52:38 <[exa]> oh
06:52:42 <[exa]> thanks.
06:52:43 <EvanR> :t mapAccum
06:52:45 <lambdabot> error:
06:52:45 <lambdabot>     • Variable not in scope: mapAccum
06:52:45 <lambdabot>     • Perhaps you meant one of these:
06:52:51 <EvanR> thats probably wrong
06:53:12 <[exa]> haskellwelp: yes, that looks reasonable. You might want to look at foldl / foldr functions that express this kind of behavior generically
06:53:13 <EvanR> :t mapAccumL
06:53:15 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
06:53:34 <[exa]> haskellwelp: e.g. foldl (+) 0 [1..10
06:53:54 <[exa]> haskellwelp: (forgot the ] )
06:54:21 <Psybur> haskellwelp, and what I pasted earlier was how to use foldl to get the length and the sum of the list in one pass: foldl (\(c,s) x -> (c+1,s+x)) (0,0) [1,2,3,4,5]
06:54:40 <[exa]> haskellwelp: you only replace the (+) by some function that takes '(sum,count)' and 'nextval', and returns '(sum+nextval, count+1)'
06:54:54 <pierrot> Hi, I'm trying to define a Show instance for the Tree datatype. It's this: http://sprunge.us/JbJh However, I'm getting the error "Ambiguous occurrence ‘show’" in the line that prints the element of a node (show e). How can avoid this ?
06:54:59 <[exa]> also Psybur already did it, I only didn't see it :]
06:55:26 <Psybur> > foldl1 (+) (take 10 [1..])
06:55:28 <lambdabot>  55
06:55:30 <mnoonan> haskellwelp, I think you have the bits about naming wrong.. e.g. the last case names the first element of the list x, the rest xs, the current sum s, and the current count c
06:56:16 <mnoonan> the 'xs' in the definition of sumcount is just a name for the input list, so we can plumb it into the recursive function that will do all of the heavy lifting
06:56:48 <ertes-w> [exa]: foldr
06:57:18 <ertes-w> > foldr (\x go s -> (x + s) : go (s + 1)) (const []) [10,20,30,40] 1
06:57:21 <lambdabot>  [11,22,33,44]
07:00:29 <Psybur> haskellwelp, and here's what it looks like in practice https://glot.io/snippets/etiz0xu0cc
07:02:27 <pierrot> Could you check what's wrong with this? http://sprunge.us/JbJh Why is it ambigous?
07:05:52 <mniip> pierrot, firstly, I think that 'show' should be indented
07:06:22 <mniip> secondly, no instance Show a arising from use of show
07:06:28 <mniip> near: 'show e'
07:13:41 <pierrot> mniip: the compiler tells me that a possible fix is to "add (Show a) to the context of the instance declaration"
07:14:09 <mniip> that is correct
07:14:50 <pierrot> how can I tell it that a is "showable"?
07:15:09 <mniip> exactly by adding a 'Show a' context
07:15:25 <Psybur> pierrot, https://glot.io/snippets/etizg2wj5v
07:19:44 <pierrot> oh, cool. It's adding "(Show a) =>"
07:19:48 <pierrot> Thanks, Psybur 
07:19:52 <Psybur> np
07:20:05 <Psybur> You also needed to concat your replicate n "\t"
07:20:23 <Psybur> It was making [["\t"]..] before
07:20:36 <pierrot> Yes, because [Char] and [[Char]] aren't the same
07:20:39 <pierrot> I forgot that...
07:23:20 <pierrot> Thanks to mniip as well.
07:27:03 <Psybur> Is there a speed difference between f . g $ x and f $ g x ?
07:27:44 <Psybur> Memory use difference?
07:28:11 <Psybur> Does the first make one pass over x and the second one has to build up all of g x first?
07:28:41 <opqdonut> Psybur: the difference is purely syntactic
07:28:55 <opqdonut> Psybur: GHC inlines . and $
07:29:08 <Psybur> I see
07:29:48 <opqdonut> . is preferred to $ usually
07:30:10 <Psybur> Yes I would think. Quicker for the brain to process than all those pixels in $ ;D
07:33:24 <EvanR> theres a better rationale for that
07:33:36 <EvanR> chains of . are easier to refactor than chains of $
07:33:43 <EvanR> because . is associative and $ isnt
08:24:31 <ghghgh> sup niggers
08:25:50 <reactormonk> I'm running -hm profiling, what's SYSTEM?
08:50:33 <`Guest00000> how do i call the function `\case Just _ -> Nothing; Nothing -> Just ()` ?
08:51:25 <mnoonan> that's a weird one. why?
08:51:26 <JazzyEagle> `Guest00000: That is an...  odd function...
08:51:58 <`Guest00000> i need to continue on failure and fail on success
08:52:19 <`Guest00000> so i have code `thisFunction foo >> return bar`
08:52:23 <jared-w> Hmm... I'm not quite sure how I would go about making a dynamic website in Haskell. Most of the stuff I see out there focuses on static websites but what if I want user interaction? I'm guessing that's where FRP and the like comes in?
08:52:57 <EvanR> dynamically generated as in PHP or dynamic like web 2.0
08:53:02 <EvanR> or dynamic like video game
08:53:02 <cocreature> jared-w: dynamic as in ghcjs or php?
08:53:08 <cocreature> eh nvm I’m too late
08:53:33 <jared-w> Dynamic as in a functional todo app :p
08:53:39 <jared-w> So probably JS-related
08:53:55 <EvanR> ghcjs
08:54:01 <cocreature> sounds like you’re looking for one of the ghcjs frameworks, e.g. reflex or miso
08:54:25 <cocreature> https://github.com/reflex-frp/reflex-todomvc https://github.com/haskell-miso/miso/tree/master/examples/todo-mvc
08:54:32 <jared-w> gotcha. I figured that would be what I want. I downloaded a scotty template for funsies and liked it
08:55:13 <cocreature> scotty is a backend webframework, you still need one of those but the choice for that is mostly independent of the one you make for the frontend
08:56:58 <jared-w> Right. I still get back-end and front-end stuff mixed up all the time... I suppose it'll make sense eventually lol
08:57:30 <EvanR> middle-end bottom-end side-end
08:57:37 <EvanR> beginning-end
08:57:50 <cocreature> jared-w: I mean you can probably get away with only a backend framework. but every interaction will then require a page-reload
08:57:50 <mnoonan> `Guest00000: (guard . not . isJust) :: Maybe a -> Maybe()
08:58:11 <mnoonan> it almost is readable :)
08:58:13 <jared-w> cocreature: right, and that's just a pain in the arse
08:58:31 <jared-w> :t guard
08:58:34 <lambdabot> Alternative f => Bool -> f ()
08:58:42 <jared-w> neat
08:58:51 <cocreature> mnoonan: tbh I find that pretty easy to read
08:59:13 <jared-w> Yeah that's like the definition of readable to me ¯\_(ツ)_/¯
08:59:40 <jared-w> mfw I need to apply to a shitton of jobs super quick and see if I can get hired in like 30 days :|
08:59:47 <mnoonan> I think I'd need to see it used in context to be fully convinced, but it did come out not too bad :)
09:02:41 <c_wraith> :t maybe (Just ()) (const Nothing)
09:02:42 <lambdabot> Maybe b -> Maybe ()
09:03:06 <Gurkenglas> `Guest00000, I think you should avoid implementing that and treating it as a code module if it's type would be "Maybe a -> Maybe ()", because that looks like it only has one sensible implementation. I would do explicit case matches or see if I can avoid the smell by using <|>
09:03:31 <c_wraith> Gurkenglas: there are two implementations.  the ones above and void
09:04:44 <Gurkenglas> c_wraith, yep, void is what I meant by the one sensible implementation
09:05:10 <c_wraith> Gurkenglas: what's not sensible about the other direction?
09:05:58 <Gurkenglas> You destroy the Maybe and make a whole new Maybe, and that's quite a coincidence that the two Maybes in that type are not one and the same
09:08:33 <Gurkenglas> Can I look at the code and reassure myself that there isn't actually a situation where you should want this abomination?
09:16:12 <dolio> It corresponds to logical negation.
09:16:16 <c_wraith> Gurkenglas:  Use?  I don't have a use for either.
09:16:28 <dolio> Succeed iff this computation fails.
09:16:38 <c_wraith> Gurkenglas: but there's nothing privileged about Just
09:17:16 <c_wraith> Gurkenglas: There is no "same" between Maybe a and Maybe ().  You have to tear down and construct whether you're negating or not
09:19:09 <Gurkenglas> You can pretend that you don't have to by seeing Maybe as a Functor. Perhaps what I want to say is that when you actually want that perversion of justice, it deserves to be spelled out
09:19:47 <Gurkenglas> So that it might be more readily refactored out of existence
09:23:01 <epta> what cloud CI you'd suggest to run 'cabal new-test' on each commit from github repo with ghc-8.2.1?
09:23:11 <dolio> logict has a generalization of this.
09:23:32 <dolio> Although I don't remember if Maybe is a MonadLogic.
09:24:04 <cocreature> epta: travis and https://github.com/hvr/multi-ghc-travis
09:26:37 <dmwit> There's certainly more than two implementations of `Maybe a -> Maybe ()`.
09:26:44 <dmwit> :t const (Nothing @())
09:26:46 <lambdabot> error: parse error on input ‘@’
09:26:59 <dmwit> :t const (Nothing :: Maybe ())
09:27:00 <lambdabot> b -> Maybe ()
09:27:03 <dmwit> :t const (Just ())
09:27:05 <lambdabot> b -> Maybe ()
09:27:33 <dmwit> Plus various strictnesses of `undefined`.
09:30:08 <Gurkenglas> dmwit, as lambdabot tells you it's not "Maybe a -> Maybe ()", and undefined is even further
09:30:23 <dmwit> :t const (Just ()) :: Maybe a -> Maybe ()
09:30:25 <lambdabot> Maybe a -> Maybe ()
09:31:56 <Gurkenglas> Though I suppose I must forbid that same argument applying to typeclass generalizations, or void wouldn't count either
09:32:53 <dmwit> Tacking on additional awkward rules is one way forward. Removing the original awkward rule instead is another.
09:34:36 <`Guest00000> Gurkenglas: i didn't understand your first message; i don't see how this function is bad
09:35:10 <epta> cocreature: is GHCVER=8.2.1 supported, or there is only HEAD?
09:35:29 <cocreature> epta: 8.2.1 works
09:35:39 <dmwit> `Guest00000: It isn't bad. It does hit a certain surprising point in the "complexity" vs "how often have I seen it used before" space.
09:35:45 <epta> cocreature: thanks, will try it
09:36:03 <cocreature> epta: make sure to use make_travis_yml_2.hs, that uses new-build
09:36:23 <dmwit> `Guest00000: Often unusual simple functions are a sign that you might want to rethink something. But without more context it's really hard to say.
09:39:08 <Wizek> Anyone might have a recommendation for a library to deal with tcp sockets?
09:41:49 <dmwit> network?
09:43:52 <Wizek> dmwit: looking into it now, thanks for the pointer.
09:56:15 <nshepperd> (there are four total implementations of Maybe a -> Maybe (), corresponding to the total inhabitants of Bool -> Bool)
10:08:27 <dsal> @pl (\b x -> b * 10 + x)
10:08:27 <lambdabot> (+) . (10 *)
10:25:42 <Psybur> !help
10:28:13 <Psybur> @help
10:28:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:28:21 <Psybur> @list
10:28:21 <lambdabot> What module?  Try @listmodules for some ideas.
10:28:26 <Psybur> @help list
10:28:27 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
10:35:51 <Gurkenglas> `Guest00000, google boolean blindness
10:42:20 <Cale> Gurkenglas: Well, we're not about to solve boolean blindness in Haskell :P
10:42:53 <dolio> I'm not sure how it's related anyway.
10:42:53 <Cale> (though I might be missing the context)
10:43:43 <dolio> There are other situations where this operation is natural, as well.
10:43:58 <dolio> For instance, the negation of any regular language is a regular language.
10:44:42 <dolio> So if you present your regular language spec as an Applicative, which can return a result from recognizing, then there can be a negation operator.
10:44:51 <dolio> And that's `F a -> F ()`.
10:45:01 <wz1000> are there any kind of discontinuous namespaces in haskell? by that I mean any two non overlapping regions in the soure where the exact same name is in scope?
10:45:12 <wz1000> *source
10:46:13 <Cale> wz1000: uhh, sure?
10:46:40 <Cale> wz1000: You can have two lambdas which both bind the name x
10:47:10 <Cale> (neither of which is inside the body of the other)
10:56:59 <Gurkenglas> Cale, I advised not to give \case Just _ -> Nothing; Nothing -> Just () a name, because if the perversion of justice is written explicitly it might yet be refactored away
10:58:37 <c_wraith> Gurkenglas, why are you so emotionally invested in this?
10:59:22 <c_wraith> Gurkenglas, do you hate Boolean not just as much?
10:59:26 <monochrom> Wait, you ask the why of emotion? >:)
10:59:38 <mnoonan> moral objections to getting something from Nothing? :)
10:59:54 <Gurkenglas> Refactoring uses heuristics, heuristics beget intuition, intuition begets emotion
11:00:40 <monochrom> We need a programming language syntax based on emoticons.
11:00:55 <monochrom> Best syntax since APL.
11:01:01 <Psybur> monochrom, :D :D <:D <<<<:D xO :P~
11:01:07 <monochrom> Yeah!
11:01:26 <tdammers> monochrom: php has you covered: http://larvel.fideloper.com/
11:03:39 <Gurkenglas> c_wraith, sure, get rid of Booleans where possible. Maybe is one such safe space. 
11:05:33 <pikajude> :D @_@ c:
11:06:47 <Gurkenglas> elem is Bool's domain, but hopefully most of its usecases already have libraries to wrap the unsafe stuff
11:07:29 <monochrom> The crying and tearing face stands for throwing an exception, and the laughing and tearing face stands for catching an exception. :D
11:08:04 <Gurkenglas> Or should it be treated as just a combination of find and (==), hmm
11:08:08 <[exa]> type ¯\(°_o)/¯ a = Maybe a
11:08:37 <monochrom> Woah, boolean is unsafe?!
11:09:04 <Gurkenglas> It makes errors that the compiler can't catch!
11:09:20 <[exa]> monochrom: "Nothing" is much better "no" then "False, and also please don't use this value"
11:09:23 <mauke> Cale: they probably mean the same entity, not just a string-equal name
11:09:38 <mauke> and presumably shadowing doesn't count
11:12:11 <monochrom> [exa], that assumes a specific scenerio and doesn't support a broad judgment of "boolean is unsafe".
11:12:12 <`Guest00000> there is no way to use two instances for a same class and type with different method implementations in one program, right?
11:12:29 <jle`> find is probably better than elem
11:12:38 <jle`> since elem produces a proof in the process of its computation
11:12:40 <jle`> and throws it away
11:12:42 <jle`> gross
11:12:45 <[exa]> monochrom: I agree, but I kindof understood the "unsafeness" as that :]
11:13:11 <hc> Hi, I have a function called "newSession :: IO Session". Session is an opaque data structure that contains a ThreadId. I'd like to terminate the thread identified by that Id when a Session datastructure is garbage collected. Is that possible/recommeded?
11:13:15 <monochrom> Also, even in that scenerio, it is (Bool, a) that is unsafe, not Bool.
11:13:54 <[exa]> hc: how did you make an "opaque" data structure, is there some FFI or so?
11:14:00 <mauke> did someone say go?
11:14:02 <jle`> (Bool, a) is safe, just look at SQL databases
11:14:10 * JazzyEagle hears monochrom in his head:  "That's not Bool, man.  Not Bool at all!!  TOTALLY UNBOOL!!!"
11:14:13 <monochrom> I now understand why c_wraith brought up "emotionally". It is. Rational thinking would not oversimplify it down to an issue with Bool per se.
11:14:43 <mauke> hc: that's not a function, but check out finalizers
11:15:10 <hc> sure it's a function, one that returns an IO action
11:15:20 <hc> or what do you mean by saying it's not a function?
11:15:34 <hc> [exa]: no, just opaque to anyone using the library
11:15:41 <mauke> hc: a function takes a value and returns a value. something of type A -> B
11:15:51 <mauke> what you have is an IO something
11:16:13 <jle`> it's not a function in the same way that a Bool is not a function
11:16:20 * ski . o O ( <http://www.pathwayslms.com/swipltuts/())).pl> )
11:16:21 <hc> mauke: well, it's a function that returns an IO action.
11:16:25 <mauke> no
11:16:31 <hc> sigh
11:16:38 <monochrom> I don't think it's healthy to argue over this.
11:16:43 <hc> absolutely ;-)
11:16:50 <hc> I'll have a look into finalizers
11:16:58 <jle`> it's just that in haskell, function has a specific non-ambiguous meaning
11:16:58 <monochrom> IIRC even the Haskell Report uses the word "function" for this.
11:17:02 <mauke> two can play at this game
11:17:02 <ski> all functions in Haskell take exactly one argument
11:17:11 <mauke> it's a function that returns a function that returns an IO action
11:17:20 <ski> `newSession' takes no argument, ergo not a function
11:17:53 <ski> (you could say it's an action, or `IO'-action to be more specific)
11:18:11 <jle`> it's just not very helpful or useful to refer to non-(->) values as functions...the only reason to do it is if you just feel like it and want to confuse people
11:18:30 <StrangeLoop> Hi. So I wrote a small program for simulating a riffle shuffle. It works but I feel its kinda clunky. Would it be terribly imposing to paste it and ask you to have a look and tell me what you'd have done differently? I really don't feel that I applied the basic Haskell toolbox properly
11:18:53 <jle`> StrangeLoop: just paste it and the people who care would read it
11:18:58 <jle`> and if they don't, they won't :)
11:19:28 <jle`> it's not too much noise and it's not like you're forcing everyone to help you :)
11:19:33 <jle`> a lto of poeple here would be happy to
11:19:54 <hc> So basically I'll use "addFinalizer" from the System.Mem.Weak package?
11:19:58 <hc> That sounds easy enough :)
11:20:10 <StrangeLoop> OK, so here it is. I am especially displeased with the way I incorporated randomness: http://lpaste.net/7901426131583107072
11:21:02 <jle`> handling randomness there looks fine to me, as a simple way to start off
11:21:08 <monochrom> hc: But how do you obtain the ThreadId?
11:21:20 <jle`> StrangeLoop: be aware that the convention is to have functions that regurn (g -> (a, g))'s
11:21:26 <jle`> s/the/a
11:21:41 <jle`> so taking your 'g' as the last argument is a common convention when working with seeds/state like that
11:21:46 <hc> monochrom: forkIO
11:21:55 <ski> StrangeLoop : the type ascriptions in `values' and `suits' are redundant
11:22:07 <jle`> StrangeLoop: it's that way because there are a lot of higher-order functions and combinators that can take advantage of that particular argument order
11:22:15 <hc> The purpose of the thread is to close idle network connections.. It's a connection pool I'm managing
11:22:18 <jle`> and so it makes it a bit more convenient to use it with those hof's/combinators
11:22:21 <monochrom> Oh, you are the author of newSession and you can do this in its code.
11:22:28 <hc> precisely
11:22:33 <ski> (the brackets around `RandomGen g' are also redundant)
11:22:36 <monochrom> OK yeah I didn't know that.
11:22:44 <hc> I should have mentioned that.. sorry
11:22:46 <jle`> StrangeLoop: you don't use any of such combinators at this moment so it's not too bad either way; just letting you know in case you do one day decide to take advantage of them
11:23:04 <[exa]> StrangeLoop: you might want to have data Card = Card Suit Deck explicitly (it looks nicer)
11:23:43 <[exa]> StrangeLoop: also, for capturing randomness there's a nice tutorial somewhere that teaches you to write a StateM-like monad, so that you don't have to pass the 'g' around yourself
11:24:28 <StrangeLoop> passing that g around was a real hassle, and made the code considerably more clumsy
11:24:42 <StrangeLoop> So if that's avoidable I'm all ears :)
11:24:47 <[exa]> StrangeLoop: (in fact the code almost looks like if you just inlined the StateM into that :] ) Lemme find the tutorial
11:25:08 <StrangeLoop> Other than that you'd say that code is fine, for a first program?
11:25:18 <StrangeLoop> I'm trying to evaluate myself here :P
11:25:25 <jle`> passing g this way is fine for a simple start and it wouldn't be too bad to see it in production code
11:25:32 <jle`> the main issue is that you might accidentally pass in the wrong 'g'
11:25:36 <ski> possibly better to get in the habit of using `newStdGen' rather than `getStdGen', if you're going to use `StdGen'
11:25:40 <jle`> and the type system wouldn't check this
11:25:46 <[exa]> StrangeLoop: this is probably good: https://en.wikibooks.org/wiki/Haskell/Understanding_monads/State#Introducing_State
11:25:48 <jle`> *wouldn't catch this
11:25:57 <[exa]> StrangeLoop: are you new into monads?
11:26:26 <StrangeLoop> I read LYAH about a a year and a half ago and made some toy programs, and then I forgot all about it, and now I'm repeating
11:26:27 <jle`> State is a nice abstraction for this because (1) it handles passing g's properly so you can't accidentally mess up and pass the wrong one or re-use them and (2) it allows you to use the many useful combinators in the Control.Monad module
11:26:41 <[exa]> yes
11:26:47 <jle`> like replicateM :: Int -> Rand g a -> Rand g [a]
11:26:58 <jle`> for taking something that samples once and turning it into something that samples 'n' times
11:27:10 <StrangeLoop> Oh I need that
11:27:13 <jle`> but at this point the complexity is low enough that you won't gain too much
11:27:26 <jle`> it's when you build more complex code that this would become useful
11:27:50 <StrangeLoop> I think what I like about Haskell is how clean the code is and all this g juggling doesn't feel clean
11:28:13 <ski> that's what the `State' monad was invented for
11:28:16 <StrangeLoop> I'm all for the aesthetics :D
11:28:38 <StrangeLoop> ski: "possibly better to get in the habit of using `newStdGen' rather than `getStdGen', if you're going to use `StdGen'" Could you elaborate a bit?
11:28:38 <[exa]> if it looks like a program could generate it just right (which it looks like), it's best to generate it by program right.
11:32:18 <ski> StrangeLoop : "What the hell are monads?" by Noel Winstanley in 1999-02-17 at <http://www-users.mat.uni.torun.pl/~fly/materialy/fp/haskell-doc/Monads.html> (one of the first monad tutorials) might perhaps be interesting to take a glance at, even considering it's a bit dated (names of some operations are now different)
11:32:57 <StrangeLoop> Does it have any advantage over "Understanding Monads" from the Wiki?
11:33:08 <ski> StrangeLoop : `getStdGen' just grabs the global `StdGen' residing in `IO'. if you do it twice, you get the same PRNG state. `newStdGen' calls `split' to split it, so that you get a new one each time
11:33:24 <monochrom> I still have the much procratinated secret project of translating Wadler's monad tutorial to today's notation.
11:33:29 <ski> well, it's short and to the (pragmatic) point
11:33:43 <maerwald> Maybe is a poor way to model failure :>
11:33:47 <monochrom> Then again since AMP it is no longer a straight translation either.
11:33:58 <maerwald> so the tutorial starts alread weird
11:34:14 <ski> not getting lost in analogies about whether to liken monads to spacesuits or burritos
11:36:21 <ski> (not intending to insinuate that the wiki one does that. but a lot of the tutorials found in the wild seem to be preoocupied with such matters, to the detriment of practicalities)
11:36:57 <maerwald> I find it funny
11:37:20 <maerwald> haskell and monads have been there for so long and there is still widespread confusion about how to explain them :>
11:39:17 <royal_screwup21> https://thepasteb.in/p/98hRE36WRMyIk super noob question, but why isn't this valid in haskell?
11:39:36 <ski> @type getStdRandom  -- there's also this one
11:39:37 <lambdabot> (StdGen -> (a, StdGen)) -> IO a
11:39:49 <ski> @type getStdRandom . runState
11:39:51 <lambdabot> State StdGen a -> IO a
11:39:52 <monochrom> It is valid in Haskell.
11:40:16 <mnoonan> royal_screwup21, it is (afaict), but  in "x=x+1", the LHS x is the same as the RHS x. in other words, you wrote a recursive definition.
11:40:25 <monochrom> Or rather, it is valid Haskell.
11:40:35 <ski> `x' is defined to be `x' plus one
11:41:03 <ski> this local variable `x' shadows the parameter `x'. the local variable `x' is the one that's used in `x+y'
11:41:20 <monochrom> In general next time you need to say something more specific than "valid" or "works".
11:41:25 <ski> (and similarly for `y')
11:41:40 <royal_screwup21> thanks guys! And yeah, I should have rephrased my question :)
11:41:59 <monochrom> Because as a programmer, even you know how end-users are unhelpful when they just say "your software doesn't work" without saying what they tried and what they observed.
11:42:41 * ski idly considers the case when implementors coincide with end-users
11:42:42 <monochrom> Programmers should be the ones most sensitive to this. Because they suffer it from end-users all the time.
11:42:52 <monochrom> And yet programmers are also the worst offenders of this.
11:43:24 <monochrom> Is this some kind of revenge psychology?
11:43:38 <tomasmu> :D
11:48:03 <tomasmu> i'm trying to use getLine or readLn, and sending it to a function that takes (x:xs)
11:48:47 <monochrom> Probably it's getLine.
11:49:34 <mauke> >>=
11:49:44 <tomasmu> with getLine, i'm getting Couldn't match type ‘Char’ with ‘[Char]’  Expected type: [[Char]]  Actual type: String
11:49:59 <tomasmu> only four data types involved in the error message :P
11:50:10 <mauke> three
11:50:12 <mauke> String = [Char]
11:50:24 <tomasmu> oh :)
11:50:46 <mauke> your function expects a list of strings
11:50:52 <mauke> you're giving it a single string (a list of chars)
11:53:09 <tomasmu> oh, so this is where function definition is useful :)
11:53:27 <monochrom> If you use readLn for this, the input format is going to be a bit strange.
11:54:39 <StrangeLoop> Is there a reason to use "liftA2 foo bar baz" rather than "foo <$> bar <*> baz" like I see a lot of tutorials do?
11:55:04 <monochrom> There is no reason to reject either one.
11:55:17 <mauke> liftA2 is nicer if you don't have bar/baz at hand
11:55:36 <mauke> like quux = liftA2 foo
11:56:03 <StrangeLoop> Ohhh cool
11:59:04 <tomasmu> so yeah, i think the function definition was the missing piece of the puzzle
12:00:10 <tomasmu> thanks mauke for sending me in the right direction :)
12:01:23 <tomasmu> and monochrom for getLine =)
12:06:47 <tomasmu> and now when i tried to replicate the issue i failed
12:06:59 <tomasmu> removed the function definition and it still worked
12:07:20 <tomasmu> so i think the error lied in having : or ++ in the wrong place?
12:08:57 <tomasmu> i have no idea, but this is confusing
12:11:52 <tomasmu> i've been doing too much powershell lately, which is implicit and dynamic typed, so everything "just works" :)
12:14:21 <jakub> can I somehow mark an orphan instance so that compiler does not complain?
12:18:50 <byorgey> jakub: there is no way to mark a particular instance (see https://ghc.haskell.org/trac/ghc/ticket/602) .  However, you can ignore orphan instance warnings in an entire module with {-# OPTIONS_GHC -fno-warn-orphans #-} .
12:19:10 <jakub> byorgey: thanks
12:59:04 <royal_screwup21> have a statement within a guard like so: "otherwise = n:(replicate' (n-1) x)". What's the difference between that and "otherwise = n:(replicate' n-1 x)". Doing the latter returned an error https://thepasteb.in/p/oYhl3qR9566tZ  (the function is replicate' n x)
13:00:10 <monochrom> precedence.
13:00:28 <royal_screwup21> I guess the more general question is: when should you put parantheses?
13:00:32 <monochrom> Clearly, "sin x - 1" does not mean "sin (x - 1)".
13:00:48 <royal_screwup21> ah okay
13:00:49 <monochrom> Be aware of all operator precedence.
13:01:04 <royal_screwup21> thanks monochrom
13:02:09 <StrangeLoop> Ok. So I'm trying this monadic random thing. The thing is, that it uses mkStdGen. If I want the execution to be random every time I need to use newStdGen, but it is an IO, so either I make everything IO, or I pass a seed around, which kinda contradicts using a state monad to avoid passing the generator around, am I missing something?
13:03:25 <Psybur> In the case of using (++), its better to use foldr than foldl?
13:03:38 <Psybur> So that you dont iterate over the accumulation each step?
13:05:06 <maerwald> Psybur: foldl' maybe
13:05:17 <maerwald> or was that (+)
13:05:22 <maerwald> I'm too drunk to remember
13:05:27 <maerwald> https://wiki.haskell.org/Foldr_Foldl_Foldl%27
13:05:28 <lyxia> StrangeLoop: how does passing a seed around contradict using a state monad
13:06:00 <StrangeLoop> lyxia: I thought the entire point of the state monad is to avoid passing the random generator around. What is the benefit if I still have to pass the seed around?
13:06:12 <Psybur> So that we get ("dude" ++ ("bro" ++ "sweet")) instead of (("dude" ++ "bro") ++ ("sweet")). The former there will be iteration over "bro" and then "dude" whereas the latter there will be iteration over "dude" and then "dudebro" ?
13:06:54 <Psybur> Since a ++ b means iterate over a until we get to the end then put and the end?
13:07:15 <maerwald> see the conclusion in the wiki article
13:07:19 <Psybur> *  Since a ++ b means iterate over a until we get to the end then put b at the end
13:07:24 <maerwald> foldl' has different strictness properties than foldl
13:07:28 <maerwald> depends on what you are doing
13:08:24 <lyxia> StrangeLoop: the point is to not have to pass the generator *explicitly* because it is a source of bugs. You still have to say where the seed comes from.
13:09:22 <barrucadu> StrangeLoop: If all your things are in 'State g' for some random generator 'g', then you create the generator once when you call 'runState'.
13:11:16 <dsal> @pl (\x -> x * x < n)
13:11:17 <lambdabot> (< n) . join (*)
13:11:59 <jared-w> dsal: why do I get the feeling you're obsessed by point free notation? :p
13:12:16 <StrangeLoop> I'm trying to implement a function which takes a list and splits it in a random location, how would you achieve this?
13:12:24 <dsal> heh.  I'm just looking to see if there's a nice way to do a thing.  I don't like a lot of these, but sometimes I miss something obvious.
13:13:58 <jle`> StrangeLoop: how do you want the splits to be distributed?
13:14:00 <monochrom> Not obsessed. Just a beginner and getting a feel of what looks good and what looks bad and what it looks like at all.
13:14:15 <StrangeLoop> jle`: say uniformly
13:14:16 <barrucadu> Well, I probably wouldn't.  But if I did want such a function I'd use something like :: RandomGen g => [a] -> g -> ([a], g)
13:14:26 <jle`> StrangeLoop: uniformly in proportion?
13:14:41 <jle`> lists are kind of a weird data structure for this
13:15:00 <jle`> but you could do it by picking a random number from 0 to the length, and then splitting at that spot using 'splitAt'
13:15:14 <jle`> a better data structure for this sort of operation would be vector/array
13:15:20 <StrangeLoop> I want to do splitAt r a where r is chosen uniformly at random from (1..length a)
13:15:26 <jle`> exactly
13:15:57 <jle`> lists are actually really good for splitting according to the geometric distribution
13:16:02 <monochrom> That doesn't sound very much like riffling, but meh.
13:16:33 <barrucadu> splitRandomly [] g = ([], [], g); splitRandomly xs g = let (i, g') = randomR (0, length xs - 1); (before, after) = splitAt i xs in (before, after, g') -- something like that, perhaps?
13:16:44 <jle`> riffling follows the geometric distribution very well so there's that
13:16:49 <barrucadu> Whoops, pass 'g' to 'randomR' there
13:17:38 <monochrom> My riffling is first splitting at a normally distributed point with the middle as the mean and a very small variance. And then the real random fun begins, the interleaving is randomized.
13:17:48 <StrangeLoop> When you say geometric distribution you mean that I should think of the splitting point as the first point where I tossed a tail?
13:17:53 <monochrom> At least that's how I do it by hand.
13:18:34 <jle`> StrangeLoop: yes that's one method to produce a split following the geometric distribution
13:18:45 <jle`> and lists are a particularly good data structure for this
13:18:52 <jle`> like amazingly good
13:19:04 <jle`> (they are a bad data structure for uniform random splits)
13:19:13 <ltielen> :q
13:19:24 <monochrom> That's neat, jle`
13:19:43 <StrangeLoop> Anyway, I don't see why choosing the splitting point geometrically is a good model for cutting a deck. I would guess normal distribution around the middle.
13:20:11 <jle`> StrangeLoop: it's good for riffling two halves back together
13:20:26 <jle`> you iterate adding between one stack and the other to a final combined stack
13:20:47 <jle`> and the number of items you pull from either half every time follows the geometric distribution
13:21:10 <jle`> ie, you pick from a random half every time
13:22:21 <StrangeLoop> jle`: I recently read that empirical data showed that a random coinflip merge is a very good model of how non professional players riffle
13:22:33 <dsal> Is there a thing that does @pl without having to spam the channel?  :)
13:22:38 <jle`> StrangeLoop: indeed :)
13:22:47 <jle`> huh that's nice to see that there's actual data
13:22:51 <jle`> dsal: you can pm lambdabot
13:22:57 <jle`> using /query lambdabot
13:23:00 <dsal> Oh cool.  Seems obvious.
13:23:04 <jle`> not obvious!
13:23:06 <jle`> :)
13:23:21 <StrangeLoop> I recently studied shuffles a bit, so I want to implement them to see the stopping and mixing times in action
13:23:25 <Tuplanolla> You can also install the program separately, dsal.
13:23:29 <dsal> Obvious as in, "I should've tried that."
13:23:37 <Tuplanolla> @hackage pointfree
13:23:53 <Tuplanolla> Serve us, lambdabot.
13:24:22 <StrangeLoop> I can tell you that the first conclusion is that using randomness in Haskell is significantly harder for me than doing a Markovian analysis of card shuffling methods
13:24:52 <jle`> StrangeLoop: if you write coinflip merge in haskell you'll find that it's actually very pleasant if you use lists
13:25:12 <jle`> it's a bit similar to how merge part of merge sort is so fun to write in haskell
13:25:15 <jle`> (using lists)
13:25:39 <StrangeLoop> jle`: I currently want to get the randomness thing down, then I could have my fun with different data types and shuffling methods
13:26:21 <Tuplanolla> If you just want to wrangle indices, I'd expect your type to be `RandomGen g => Vector a -> State g (Vector a)` or `MonadRandom m => Vector a -> m (Vector a)`, StrangeLoop.
13:27:52 <StrangeLoop> I think there's something fundamental about how randomness works in Haskell which I am not getting. Something about where the actual obtaining of random values takes place
13:28:34 <jle`> StrangeLoop: the basic method you're working here is using a PRNG from an initial seed
13:28:40 <jle`> (there are other approaches as well)
13:28:59 <jle`> 'State' is just an abstraction that makes this method nicer to use/cleaner and also less error-prone
13:29:23 <jle`> getRandom :: g -> (a, g) is a pure function, so it returns the same 'random value' when given the same initial seed
13:29:53 <jle`> getRandom is a typeclass method for an instance for 'a', so basically every type is allowed the ability to define how to construct a random value of that type
13:30:20 <monochrom> You need to understand that "random" and "pure function, i.e., deterministic" is at a fundamental conflict.
13:30:22 <jle`> so if i define my type Foo, i can write a Random instance for Foo, and if i do that, i have to define getRandom, or how it would be possible to make a random value of Foo from an input seed
13:30:49 <monochrom> And understand that other languages "simplify" it by giving you effectful procedures not functions.
13:31:01 <jle`> Int, Bool, String, Double, etc. all provide their own methods, and so 'getRandom', as a typeclass method, uses the implementation that each gives
13:31:13 <mlehmk> but a random function can return another function, which can give a random number once and another function, which can do the same with the next random number...
13:31:20 <monochrom> So that random(6) + random(6) ≠ (\x -> x+x)(random(6))
13:31:40 <mlehmk> I think this would be a reader monad then
13:32:07 <StrangeLoop> Man, Haskell is so fun until you try to actually write something
13:32:23 <mlehmk> something that can behave like a list of random numbers, where you can use head and tail
13:32:28 <jle`> that has been the opposite of my experience :O haskell is fun when you actually start writing real things
13:32:37 <jle`> cause then you get to reap all of its benefits in real projects
13:32:54 <monochrom> So the logical conclusion is that when you insist on pure functions you have to expose the presence of a PRNG, and that the initial seed has to come from an external source such as IO.
13:32:58 <royal_screwup21> is this a correct implementation of the "take" function https://thepasteb.in/p/oYhl3qnZjpYtZ It seems to work okay on my ghci console but the implementation on LYAH looks a little different (or maybe it's basically the same - I just have to look harder)
13:33:14 <StrangeLoop> Anyway, I get that everything is pseudorandom, and will get the same results every time unless you change the seed, and if you want to change the seed with every run you need IO
13:33:37 <StrangeLoop> What I am really not getting, is at which point of the code should I use evalState
13:33:38 <lyxia> royal_screwup21: take' 1 []
13:33:54 <monochrom> Also it is a biased to view that Haskell becomes hard as soon as you "actually write something".
13:34:05 <jle`> StrangeLoop: you can think of 'State' as a way to build up a big fat (g -> (a, g)) by composing smaller simpler ones
13:34:11 <royal_screwup21> lyxia ah thanks, missed that edge case!
13:34:13 <StrangeLoop> monochrom: Yeah, it's a survivor bias, I was just kidding
13:34:19 <monochrom> It is biased because it is true for your current project but false for other projects.
13:34:27 <jle`> StrangeLoop: if you have a bunch of random actions, you can use State to "sequence" them in a nice way
13:34:28 <monochrom> Or rather, in this case, the victim bias.
13:34:46 <monochrom> Dead men tell grave tales.
13:34:53 <mniip> royal_screwup21, as it stands your function is a bit too lazy
13:34:56 <StrangeLoop> monochrom: If you were hinting that I am being a bit of a crybaby, you aren't too far off from the truth I guess
13:35:03 <jle`> StrangeLoop: at the end of the day, once you get the "g -> (a, g)" of your high-level program, then you can evalState :: State g a -> g -> a that
13:35:03 <mniip> take 3 [] = [_|_, _|_, _|_]
13:35:03 <lyxia> royal_screwup21: and turn on -Wall
13:35:32 <ski> > length (take 3 [])
13:35:33 <jle`> StrangeLoop: the benefit of State is that you can manipulate (g -> (a, g))'s in a "first class way"; you can combine simple ones to create more complex ones
13:35:38 <jle`> using useful combinators
13:35:43 <StrangeLoop> So the state monad is a fancy way to abstract a composed calculation, whereas evalState is an abstraction of the result of that calculation?
13:35:51 <monochrom> For a more balanced view, if your project is to code up AVL tree algorithms, Haskell is the easy one, C/Java/PHP are the ones "become hard as soon as you actually write something".
13:35:59 <jle`> evalState is a part of the API/interface of the State monad
13:36:00 <mniip> "composed calculation" is vague af
13:36:03 <mniip> state monad is specific
13:36:24 <jle`> StrangeLoop: so if 'State g a' describes a stateful computation, evalState "executes" that stateful computation to create a result :: a
13:36:32 <royal_screwup21> mniip thanks for the feedback!
13:36:34 <StrangeLoop> mniip: vague, abstract, potato, potato
13:37:06 <mauke> vaguetables
13:37:43 <mauke> :t runState
13:37:51 <monochrom> I don't think it's healthy to pick on "composed calculation" so early.
13:37:51 <mauke> :-(
13:38:09 <jle`> using state, you build the (g -> (a, g)) you want at the high level...and you get the ability to build it by composing simpler ones together
13:38:11 <ski> `evalState' (or `execState' or `runState') is used (typically only once) when you're satisfied with your big `State s'-action, and want to "get out"
13:38:14 <mniip> ha!
13:38:16 <mniip> my chance to shine
13:38:25 <StrangeLoop> I have a functioning code which does not use it but its ugly af
13:38:28 <ski>   runState :: State s a -> (s -> (a,s))
13:38:31 <mniip> % :t runState
13:38:31 <yahb> mniip: runState :: State s a -> s -> (a, s)
13:38:36 <ski>   evalState :: State s a -> (s -> a)
13:38:41 <ski>   exexState :: State s a -> (s -> s)
13:38:44 <monochrom> I mean you will have to pick on it eventually. Just not now. Get the code to work first. Then you can pick on semantics.
13:39:02 <monochrom> It's all empty talk until you have both an example and a counterexample.
13:39:17 <StrangeLoop> monochrom: I have a working code
13:39:20 <mlehmk> a reader monad from a list generator would be enough for prng I think
13:39:54 <mniip> mlehmk, no?
13:39:56 <mauke> mlehmk: how do you consume things?
13:40:02 <StrangeLoop> monochrom: http://lpaste.net/2214921880157028352
13:40:14 <mlehmk> am I confusing reader and writer?
13:40:21 <mniip> neither of those work
13:40:21 <barrucadu> StrangeLoop: Here's how I did it, without using State: https://gist.github.com/barrucadu/8996405669274d6b1567ed3a4c49a9c0
13:40:34 <monochrom> Yeah, but I mean after you convert that into using some State monad.
13:40:38 <mniip> unless by writer you really mean Writer (Endo s) which is really just state
13:40:39 <barrucadu> There's lots of blank lines so you can avoid looking at the definition of a function if you want to think about it first
13:42:10 <StrangeLoop> So generating a newStdIo and dropping it whenever I want a new random number is an acceptable practice? Seeing your code I realize I was subconsciously avoiding it
13:42:58 <StrangeLoop> Because that's definitely the easiest solution
13:43:42 <jle`> hm, i think the point is to chain together your (g -> (a, g)'s
13:43:47 <barrucadu> Unless I were already in an IO context, I'd tend to use the pure shuffle function
13:43:47 <jle`> so that you only need to newStdIO once
13:43:55 <jle`> like you do already
13:44:03 <monochrom> Do you all mean newStdGen?
13:44:31 <StrangeLoop> OK
13:44:49 <monochrom> Also yeah newStdGen is a better habit than getStdGen.
13:45:02 <jle`> StrangeLoop: note that your whole program is building up to your shuffle function, which is one complicated g -> (a, g), built up from simpler ones
13:45:04 * ski blinks slowly
13:45:12 <mauke> % :t randomIO
13:45:12 <yahb> mauke: randomIO :: Random a => IO a
13:45:14 <monochrom> Not to say that getStdGen is always wrong, but you need to know what it does and doesn't.
13:45:16 <mauke> fuck the police
13:46:10 <StrangeLoop> getStdGen gets a seed and creates a pseudorandom generator, newStdGen chooses an external seed for me via an IO action, right?
13:46:26 <monochrom> No. Did you read that from the doc?
13:46:46 <StrangeLoop> no, I extrapolated from :t'ing them in GHCi :(
13:47:09 <ski> `getStdGen' grabs the current contents of a mutable location, but doesn't change it
13:47:16 <ski> `newStdGen' also changes it
13:47:29 <monochrom> With IO and a secret mutable variable behind it, you can't deduce much from types. You learned that from stupid imperative languages.
13:48:11 <monochrom> getStdGen doesn't mutate the seed, so every time it gives you the same damn thing again. Until you quit the program and run it anew.
13:48:22 <monochrom> newStdGen does mutate the seed.
13:48:37 <ski> `newStdGen' does both a `getStdGen' and a `setStdGen'
13:49:18 <StrangeLoop> OK
13:49:39 <monochrom> If you getStdGen but you promise "I'll setStdGen promptly" that's also OK. But with the convenience of newStdGen why bother.
13:49:40 <ski> (`newStdGen' uses `split :: RandomGen g => g -> (g,g)' inbetween those two operations)
13:50:31 <jle`> StrangeLoop: i rewrote your original code using state to demonstrate how your logic would be managed using the State abstraction
13:50:33 <jle`> http://lpaste.net/358354
13:50:39 <mauke> horizontal split or vertical split?
13:50:52 <StrangeLoop> jle`: That was seriously awesome of you
13:51:01 <jle`> i tried to use the same logic that you used
13:51:28 <jle`> but jsut to show how State makes the threading nicer
13:51:39 <jle`> and how you use runState only at the very end
13:51:39 <StrangeLoop> threading?
13:51:43 <jle`> threading of 'g'
13:51:48 <StrangeLoop> oh
13:51:57 <jle`> basically, your whole program exit point is 'riffleShuffles'
13:52:07 <ski> versions of `g' being passed in and out of function calls
13:52:07 <mniip> mauke, it just splits the numbers generated by the input generator. Namely at index infinity/2
13:52:28 <jle`> and the definition of riffleShuffles explains the point: "riffleShuffles 0 d is just a no-op returning d"
13:52:43 <jle`> "riffleShuffles n d is riffleShuffling once d, and then riffleShuffles (n - 1) to taht result"
13:53:08 <mauke> mniip: how big is that infinity?
13:53:11 <jle`> the Monad instance for State is what defines the behavior of do notation/>>= to compose the functions correctly
13:53:21 <mniip> mauke, the size of the numbers list duh
13:53:33 <mniip> aleph-null or something
13:54:18 <jle`> StrangeLoop: so, as you see, your main exit point is riffleShuffles, but riffleShuffles is made out of "simpler" State g's
13:54:25 <jle`> namely, riffleShuffle
13:54:27 <Psybur> You guys are g's
13:54:44 <jle`> and riffleShuffle itself is a State g, but riffleShuffle is written in terms of two simpler State g's (randomSplit and randomMerge)
13:55:09 <jle`> the State abstraction is what allows you to build complex State g's (like riffleShuffles) by composing simpler ones (like riffleShuffle, randomSplit)
13:56:26 <jle`> "and so you see, Haskell is the best imperative language"
13:58:40 <StrangeLoop> I must say, that I have been using Freenode for over a decade now, and frequented many support channels of all kinds and types. And people here are by far the nicest :)
13:58:58 <jle`> :3
13:59:02 <monochrom> Thanks.
13:59:03 <jle`> maybe we're just not grumpy because haskell does our debugging for us
13:59:21 * monochrom is not nice.
13:59:31 * ski thinks that's nice of monochrom
13:59:45 <monochrom> I am grumpy because Haskell doesn't debug people's minds for me.
14:00:20 <monochrom> Although, there is a problem with ghci not showing docs.
14:00:43 <jle`> it'd be nice if ghci showed docs
14:01:33 <jared-w> although just being able to use an editor super easily with hoogle and hackage/stackage doc lookup would be pretty good for me I think
14:02:12 <monochrom> I guess there is that.
14:02:43 <monochrom> We have long forgotten manatee.
14:03:05 <monochrom> It is an IDE in the sense that it consists of an editor, a web browser, and an IRC client.
14:03:27 <monochrom> Why? Because that's how you work when you work in Haskell!
14:04:16 <monochrom> Use the web browser to read Haddock docs. Use the IRC client to whine on #haskell or procrastinate.
14:05:51 <monochrom> Alternatively it could be how you hang out in #haskell in the first place.
14:06:33 <monochrom> Use the web browser to see other people's pastebin pastes. Use the editor for further testing.
14:06:45 <ReinH> I think you're describing a properly-configured emacs.
14:07:04 <MP2E> hah :p
14:07:08 <monochrom> yeah haha
14:07:20 <Tuplanolla> Renaming is still painful.
14:07:29 <jle`> i like how the wiki page for manatee is sure to include two demo videos, one with and one without an Owl City soundtrack
14:07:48 <jle`> to accommodate all
14:08:20 <StrangeLoop> Yeah, just being on Freenode makes me feel bad about being on Windows and using SublimeText
14:09:03 <epta> http://lpaste.net/1082395976943009792 how to do it simpler?
14:09:31 <ski> oh, haven't been reminded of Manatee in a long while
14:10:14 <sm> yeah manatee.. wonder how things developed over in that alternate universe
14:11:23 <sm> http://hackage.haskell.org/package/manatee , tested-with GHC 7.0.3
14:11:26 <barrucadu> epta: See Data.HashMap.insertWith, you provide a function to handle the conflict
14:13:45 <epta> barrucadu: I want to wrap the fact of updating existing value into some kind of effect instead of doing it silently, thus there is a 'Maybe' 
14:16:51 <ski> epta : i suppose `insertWith' probably rebuilds the path in the map, in case the key was already there
14:23:01 <epta> (key was there, value is the same) -> Just leave as is, (key was there, value is different) = Nothing, (key wasn't there) -> Just Insert 
14:23:18 <epta> `insertWith' cannot distinguish these
14:24:07 <epta>  s/= Nothing/-> Nothing/
14:28:16 <barrucadu> I suspect there isn't a simpler way of doing it, that sounds like a pretty uncommon operation
14:29:20 <monochrom> @type guard
14:29:26 <monochrom> sob
14:29:33 <glguy> :t M.alter
14:29:53 <glguy> Oh, no lambdabot?  alter :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a
14:30:01 <monochrom> alter also just gives you back a HashMap without telling you what happened.
14:30:05 <barrucadu> lambdabot has deserted us.
14:30:48 <glguy> If you need extra-feedback you can thread it through with alterF
14:31:42 <monochrom> Ah but happily Hashmap doesn't have alterF
14:32:06 <glguy> I don't think that's what happily means
14:32:26 <epta> @info alterF
14:33:53 <epta> oh, found it. Btw, Note: alterF is a flipped version of the at combinator from At.
14:34:32 <monochrom> What is At?
14:34:38 <glguy> A class from lens package
14:34:49 * monochrom sobs more
14:35:30 <monochrom> Anyway. Control.Lens and Data.Machine.  Worst categorizations ever.
14:36:14 <monochrom> Or best? IngSoc would be proud.
14:36:29 <Rembane> Why is it the worst?
14:36:37 <marvin2> is there a function that will escape printf specific flags? such as % (not sure if that is the only one)
14:36:43 <epta> what can 'flipped version of the at' mean here, since "at :: Index m -> Lens' m (Maybe (IxValue m))"?
14:37:09 <monochrom> Control.Lens is more about data, and Data.machine is more about control flow.
14:37:18 <epta> maybe it's too late to flip
14:37:36 <glguy> marvin2: Better to use a string literal for the format string along with a %s parameter where you want the string to go
14:37:46 <Rembane> monochrom: Good point. I think we need a new category. DataControl.
14:38:04 <marvin2> glguy good point
14:38:14 <glguy> epta: It means that the first two arguments are in the other order like if you'd used 'flip'
14:38:21 <monochrom> Ah, now the other half of the people will argue with you about "why is it not ControlData?" >:)
14:38:45 <Rembane> Muaha! Let them be aliases of each other. :D
14:39:00 <ski> but which one is it *really* !?
14:39:22 <Rembane> It's like Endianess.
14:39:43 <geekosaur> monochrom, because CDC's long gone? :p
14:40:14 <geekosaur> (well, probably absorbed into someone else 5 or 6 times...)
14:40:25 <epta> glguy: anyway, 'at' returns the value, not the whole map, which is not pretty useful here
14:40:44 * ski . o O ( "DDC" )
14:40:48 <glguy> epta: No, at returns the whole map, not the value
14:41:08 <glguy> epta: one of the ways to use at is to ignore that map and just look at the value
14:41:26 <monochrom> Although, to be fair, we are always pressed to make a premature categorization before we have time to understand.
14:41:51 <geekosaur> marvin2, printf isn't really intended for general use anyway, it's more a demonstration of evil typeclass hackery. the Numeric module has formatting combinators
14:46:31 <glguy> epta: http://lpaste.net/358356
14:50:22 <epta> glguy: nice,great. Btw, can Maybe be used as a Functor there instead of Either?
14:50:41 <glguy> epta: Yes, but not to solve this problem
14:50:57 <epta> ah, nope, we need to distinguish Left Just and Left Nothing
15:18:08 <hexagoxel> (has anyone pinged int - e yet about lambdabot?)
15:19:28 <hexagoxel> int-e: ^
15:19:37 <hexagoxel> hexagoxel: yes :D
15:20:48 <milesrout> The whole Data, Control, etc. categorisation is pretty silly
15:21:14 <milesrout> better than the awful com.shit.idiocy.that.Java uses
15:24:01 <barrucadu> Some of it makes sense, but "Control" and "Data" are definitely far too vague to be useful
15:31:50 <lambdamu> Is there any proposal for closed type classes?
15:32:56 <hpc> have you looked at GADTs?
15:33:08 <hpc> iirc data families can be closed too
15:33:54 <lambdamu> And type families also, but im interested I want to associate values with types, I believe that is only possible with type classes
15:35:22 <hpc> GADTs can associate data constructors with types
15:35:40 <lambdamu> for example with some overlapping annotations one can define an fmap that works on all functions Functor m => a0 -> a1 -> .. -> an -> m a
15:35:51 <hpc> you get the same result, but inside out-ish
15:36:14 <hpc> instead of a central definition of class methods and dispersed instances
15:36:27 <hpc> you have a central definition of "instances" (the data constructors in the GADT)
15:36:36 <hpc> and dispersed functions that pattern match on that type
15:37:05 <hpc> since it's closed, every function can be defined by matching on every data constructor that's valid for the type
15:39:11 <lambdamu> Hm I would have to try but do you think functions with variable argument numbers like the mentioned fmap generalization could be expressed like that?
15:41:34 <lyxia> you can do a lot with closed type families
15:42:39 <Cale> lambdamu: You can do things of that sort with type classes already, but they often turn out annoying. It would be especially annoying in the case of fmap, because m might be a function type constructor.
15:43:47 <Cale> lambdamu: But see Text.Printf
15:44:48 <lambdamu> Yeah I know I can do that, but as you say type classes are rather unwieldy due to the open world assumption, so I thought given we already have closed type families and they work rather well (except that there is no partial application) there would have been a propsal at some point for closed type classes
15:45:16 <lambdamu> If not I will think about one
15:47:51 <lambdamu> I imagine overlapping wouldn't be hideously unsafe, we could have meaningful backtracking, etc.
15:49:51 <geekosaur> but it'd be a whole new mechanism
15:50:25 <geekosaur> I don't think you could reuse very much; the open world assumption is pervasive
15:51:20 <lambdamu> Hm yes I don't know how different it would be in terms of implementation and mechanics but the use cases are disjoint
16:16:25 <sm> I'd like to load multiple main modules (and their deps) into GHCI at once, for ghcid testing, but GHCI doesn't like more than one main module. Is there a way to make this work ?
16:16:44 <sm> without changing the code, I mean ?
16:23:02 <lambdamu> Wouldn't that be nice? http://lpaste.net/358358
16:47:54 <lambdamu> That didn't make much sense, this is better: http://lpaste.net/358359
16:48:04 <lambdamu> But it gets frankensteinian
17:07:09 <monochrom> Fortunately "m" overlaps with "(->) a", too.
17:27:49 <joncfoo> What's a good method for composing a combination of the following functions - http://lpaste.net/358360
17:28:33 <joncfoo> I've found fmapL from the errors package to be quite helpful but I still have case expressions floating around
17:29:50 <joncfoo> I've created a sum type to represent the various errors so I can unify them (that helps a lot)
17:31:48 <joncfoo> I'm thinking I might punt all the validation functions under ExceptT - that seems reasonable?
17:32:02 <lyxia> yes
17:34:20 <joncfoo> thanks for the confirmation lyxia - I'll give that a shot
17:36:56 <lambdamu> joncfoo: Do you have more information on your use case, how exactly do you want to compose those functions?
17:37:27 <lambdamu> fmap (>>= fn2) . fn1
17:37:27 <lambdamu> fmap (either (pure . id) fn3) . fn2
17:37:31 <lambdamu> Something like that?
17:38:05 <jle`> joncfoo: yeah, all of those can be used in ExceptT, so the monad instance works well for you if you want short-circuiting chaining
17:38:18 <jle`> ExceptT :: IO (Eithere e a) -> ExcepT e IO a
17:38:24 <jle`> liftIO :: IO a -> ExceptT e IO a
17:38:38 <jle`> (either throwE return) :: Either e a -> ExceptT e IO a
17:38:52 <jle`> ExceptT e IO a can be considered a common denominator of sorts
17:39:11 <jle`> natural transformations to the rescue ~
17:42:48 <joncfoo> lambdamu, I don't want to nest them, binding would be preferable as it's easier to read (for me)
17:43:36 <joncfoo> thanks jle`, I'm going down that road and using: type MyConfigValidationT = ExceptT MyError IO
17:43:47 <lambdamu> joncfoo: Yeah the second one was nonsense anyway, try ExceptT if you think it helps you
17:43:54 <joncfoo> hoistEither is a godsend :)
17:44:38 <Welkin> :t hoistEither
17:44:54 <Welkin> @type hoistEither
17:44:58 <Welkin> > :t hoistEither
17:44:59 <jle`> lambdabot is down atm
17:45:02 <Welkin> :(
17:45:39 <lambdamu> I think I remember that I got annoyed with ExceptT around IO because MonadThrow throws in the base monad
17:46:39 <lambdamu> But of course you don't have to use that
17:50:49 <joncfoo> thanks everyone!  I've updated with actual usage: http://lpaste.net/358360
17:51:53 <joncfoo> it's much, much, nicer to have: runExceptT $ loadYaml f >>= parseURI >>= makeConfig
17:52:58 <joncfoo> btw, is there a flipped version of <$> in base perhaps?
17:53:12 <jle`> not in base, but if you're already using lens, there's <&>
17:53:52 <joncfoo> ah, perfect!
17:54:12 <Welkin> but don't use lens just for that operator
17:54:17 <Welkin> you can define it yourself
17:54:26 <Welkin> it is `flip <$>`
17:54:48 <Welkin> er, even just `flip fmap`
17:54:52 <Gurkenglas__> If you're looking for an excuse to use lens, import ahead!
17:54:57 <joncfoo> thanks Welkin - I'm already using lens :)
17:55:22 <joncfoo> I only know a little bit about lens but I'm hoping with this little project of mine I get to know it further
17:55:24 <jle`> if you define it yourself remember to pick a sensible fixity
18:38:27 <sqooq> can I somehow fmap readFile across a list of FilePaths and then use a function that takes [String] on the result?
18:39:14 <sqooq> do i have to like
18:39:15 <sqooq> map bind
18:39:18 <sqooq> across it
18:39:43 <sqooq> or fold bind or something
18:40:37 <marvin2> :t mapM readFile
18:40:56 <jle`> mapM :: (a -> IO b) -> [a] -> IO [b]
18:41:08 <sqooq> ooh didn't know that existed
18:41:12 <sqooq> neato
18:41:13 <jle`> it's also called traverse
18:41:17 <jle`> it's like an "effectful map"
18:41:21 <jle`> pretty handy :)
18:41:35 <sqooq> that's traverse?
18:41:42 <jle`> yeah
18:41:53 <sqooq> dang i guess I don't really know my traverse then
18:41:54 <jle`> traverse :: (a -> IO b) -> [a] -> IO [b]
18:42:30 <jle`> should always be the same behavior
18:48:55 <joncfoo> Is there a library that allows you to tag fields in a record with some data (e.g. text) and then pull them out?  I've seen that optparse-generics uses a type operator to do such a thing - curious if anyone knows if a lib for such functionality exists?
18:50:23 <joncfoo> I'm thinking it'd be useful for generating documentation for configuration options
18:52:53 <dysfigured> tfw no lambdabot
18:52:56 <Cale> joncfoo: One thing you could do is to parameterise the type by an arbitrary choice of functor, which is then applied to all the fields, and you could plug in (,) Text in the case that you want the fields annotated, and Identity if not.
18:53:07 <Cale> However, I don't know if that's what you meant
18:53:22 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/extending_ghc.html#source-annotations might be interesting, if somewhat heavy
18:54:59 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/extending_ghc.html#using-annotations is how to retrieve them
18:57:04 <joncfoo> geekosaur, I think that's a little heavy handed for me :)
18:57:45 <joncfoo> Cale, I'll give that a shot
18:57:48 <geekosaur> yeh, it's mostly intended for compiler plugins but it is a way to attach arbitrary data at compile time that is available at runtime without disturbing the rest of the data (aside from the necessary instances)
18:58:57 <joncfoo> it is pretty neat though
19:15:56 <joncfoo> Cale - http://lpaste.net/358364
19:16:08 <joncfoo> ^ that is very easy, thanks!
19:20:30 <rotaerk_> I forget... is haskell platform the thing that's no longer recommended
19:21:19 <rotaerk_> ah right it was https://github.com/bitemyapp/learnhaskell that said not to do haskell platform
19:33:09 <monochrom> In an ideal world, it depends on what you need, what your use case is.
19:33:23 <sqooq> can I do define two functions with one helper?
19:33:32 <sqooq> since they're both almost identical except one thing switches out
19:33:49 <sqooq> and Idk what to name the abstracter function
19:34:19 <monochrom> In this sick sick world, it depends on who you ask, therefore what someone else needs, what their use case is, and what their invested private interest is.
19:35:08 <pierrot> Hi. When I try to compile a simple program, I get a bunch of errors like this one: /usr/bin/ld.gold: error: /usr/local/haskell/ghc-8.2.1-x86_64/lib/ghc-8.2.1/base-4.10.0.0/libHSbase-4.10.0.0.a(Base.o): requires unsupported dynamic reloc 11; recompile with -fPIC
19:35:17 <pierrot> I'm on Debian 9
19:35:32 <sqooq> rotaerk_: I had problems with it, started fresh with just stack, no problems
19:39:05 <pierrot> I don't know what to do.
19:39:42 <sqooq> what is ld.gold?
19:40:03 <sqooq> what exactly are you typing to compile it
19:40:19 <pierrot> ghc --make Main.hs
19:41:59 <sqooq> pierrot: i'm not sure, you'll have to wait for the more experienced users to respond
19:42:08 <sqooq> did you try -fPIC?
19:42:46 <pierrot> yes, and I get the same errors
19:43:12 <sqooq> yeah idk
19:44:02 <pierrot> Thanks for your help anyway
19:44:45 <geekosaur> pierrot, you need to install a ghc that can deal with the switch to default position independent executables (which implies compiling main programs as if they were shared libraries_
19:44:57 <geekosaur> did you install the Platform?
19:45:07 <pierrot> Yes, I installed the platform
19:45:14 <monochrom> It is 8.2.1 so it already does that.
19:46:03 <geekosaur> the platform install page still has the instructions for adapting to PIE systems
19:46:32 <geekosaur> but they're hidden. you have to click the "Generic" icon, then scroll to point 3
19:46:42 <geekosaur> (yes, they've been made aware this is a trainwreck)
19:47:45 <pierrot> Ohh, yes. I hadn't read that
19:49:39 <monochrom> Oh interesting, the Haskell Platform set it to "NO"...
19:49:57 <geekosaur> because most generic linux distros have not switched yet
19:50:10 <geekosaur> but that is changing somewhat rapidly
19:50:47 <geekosaur> plus, if you install the generic one on a PIE OS because the packaged one is ancient, you'll run into it
19:50:52 <pierrot> It did compile now. Thank you very much, geekosaur !
19:51:04 <pierrot> What's PIE?
19:51:11 <geekosaur> position independent executables
19:51:52 <pierrot> Oh, I see.
19:51:55 <geekosaur> an intermediate step toward address space layout randomization to make stack-smashing attacks harder
19:52:10 <monochrom> So I wonder why mine was set to "YES". To be sure, my GHC is from the GHC website itself rather than Haskell Platform. So, does GHC's ./configure script check and set it?
19:52:30 <geekosaur> I don't know.
19:53:01 <monochrom> OK I'm going to untar it and see.
19:53:12 <geekosaur> (I get mine from hvr's PPA; I only know about this because others have hit it.)
19:54:10 <pierrot> This issue is rather new, isn't it? I used ghc like 3 months ago (ghc-8.0.2) and I didn't change any setting and compilation was successful
19:54:32 <geekosaur> but my guess is as I said, most of the smaller distributions still have not moved toward PIE or ASLR (it's a big job and they generally aren't in a good position to do anything until debian/RH force it on upstreams) so a default of "NO" is appropriate
19:54:43 <monochrom> No, it's like a year old.
19:55:13 <geekosaur> 8.2.1 is recent; the default may have changed, or if you got 8.0.2 from elsewhere then it may have had a different default, as monochrom mentioned
19:56:34 <monochrom> Yeah ./configure has a check on "checking whether GCC supports -no-pie"
19:57:18 <pierrot> I installed ghc-8.0.2 from the Haskell platform like 3 months ago, as I said. And I didn't change anything and the compilation worked. Today, when I tried to compile a simple program, I got these error messages
19:57:56 <monochrom> Were you using Debian 9 back then?
19:58:23 <pierrot> so I installed the new Haskell Platform (the one with ghc-8.2.1) today, but I got the same errors.
19:58:26 <pierrot> hmm
19:58:29 <pierrot> No, Debian 8
19:58:38 <pierrot> I upgraded
19:58:48 <pierrot> Maybe that's the reason..
19:58:52 <geekosaur> right, and 8 didn't have this problem
19:59:02 <monochrom> I also happen to keep around the Haskell Platform 8.0.2 tarball!
20:01:23 <geekosaur> debian has a wiki page about their plans for this stuff https://wiki.debian.org/Hardening
20:01:30 <monochrom> I guess I manually set it to "YES" back then when I used Haskell Platform 8.0.2. Because it's a "NO" in the tarball.
20:02:13 <monochrom> I'm on Ubuntu so I need it "YES" one way or another, automagic or manual.
20:04:42 <monochrom> Now let's see when will the dynamic-libs-only religious war hits Ubuntu and Debian!
20:07:34 <pierrot> Another question: ghc seems to not find Text.Parsec.* ... I checked with `ghc-pkg list` that parsec-3.1.11 is installed
20:07:42 <pierrot> Why isn't it found?
20:11:59 <rotaerk_> seems like haskell.org should be updated to either fix the haskell platform or start recommending stack instead
20:13:46 <Welkin> oh lol
20:13:52 <Welkin> you'll start a holy war
20:13:56 <monochrom> What needs fixing?
20:14:21 <rotaerk_> was just listening to someone trying to get it working on windows, and it just didn't set things up correctly, so stuff just didn't work out of the box
20:14:33 <rotaerk_> e.g. an error complaining about msys being missing; he had to manually add it to his path
20:14:40 <Welkin> windows is broken as
20:14:51 <monochrom> OK I see.
20:15:16 <rotaerk_> whereas I just tried out stack on windows (which I've never done haskell on) and it worked flawlessly
20:15:30 <monochrom> OK, I hear you.
20:15:33 <pierrot> `cabal install parsec --reinstall --force-reinstalls` made the compilation succeed
20:15:54 <monochrom> But using the Occam Razor, I cut it down to "recommending GHC itself instead"
20:16:26 <rotaerk_> I don't use stack, myself; but I use nix
20:16:27 <arahael> rotaerk_: The downloads page clearly mentions stack first, before it metniosn the platform. When it talks about Stack, it clearly mentions that it handles management of the toolchain.
20:16:43 <arahael> rotaerk_: Did they choose to grab the version that does NOT handle management of that toolchain?
20:18:04 <rotaerk_> ah, didn't realize; now I'm curious why he picked the platform
20:22:43 <arahael> Hmm, my resposnes are getting agressive, I probably should grab my coffee fix.
20:23:04 <rotaerk_> I just made the assumption that it's what it recommended still
20:23:14 <rotaerk_> since that's what he ended up with
20:23:21 <rotaerk_> but yea, stack's first...
20:26:21 <iqubic> What are we discussing right now?
20:28:55 <monochrom> Are you asking that because of some event in your childhood?
20:37:29 <rotaerk_> lol
20:37:58 <arahael> rotaerk_: Actually, it's entirely possible they grabbed the "minimal" installer.
20:38:25 <arahael> rotaerk_: But if so, then that should be their issue!
20:38:41 <rotaerk_> hmm maybe
20:41:09 <jle`> hi all is there a ConstT anywhere
20:42:49 <rotaerk_> doesn't look like it
20:45:45 <iqubic> What the heck is Cont and why does one use it?
20:46:33 <peddie> iqubic: http://vaibhavsagar.com/blog/2017/05/22/discovering-continuations/
20:46:49 <vaibhavsagar> hey it me
20:47:00 <peddie> it you!
20:47:24 <peddie> I like your article
20:47:30 <iqubic> why the heck do you use (>>-) as a constructor?
20:47:30 <vaibhavsagar> thanks :)
20:47:44 <vaibhavsagar> see https://github.com/quchen/articles/blob/master/cont_monad.md
20:48:19 <vaibhavsagar> and also http://www.haskellforall.com/2014/04/how-continuation-monad-works.html
20:50:24 <rotaerk_> just try not to read Cont out loud with people around
20:50:39 <vaibhavsagar> unless you're in Australia
20:50:44 <iqubic> Because it sounds like a vulgar word?
20:52:05 <vaibhavsagar> indeed
20:53:02 <iqubic> What different about 'Straylia
20:53:11 <rotaerk_> it's apparently not particularly offensive there
20:53:16 <vaibhavsagar> https://www.pedestrian.tv/news/judge-ruled-not-actually-offensive-call-tony-abbott-cunt/
20:53:47 <vaibhavsagar> "the word is less offensive there than in other english-speaking countries"
20:54:28 <vaibhavsagar> but we're getting off-topic now
21:16:48 <jle`> ghc has been building for six hours now on one of my less powerful boxes, this is fun
21:16:53 <jle`> at least it's still churning on
21:22:50 <monochrom> That is unusually long. I have an 8-year old laptop too, it doesn't take six hours.
21:23:08 <monochrom> I think 1 or 2 hours? It's been a while last time I did this.
21:23:46 <jle`> i did not mention that i'm running it on the Ubuntu on Windows bridge
21:24:22 <Jeanne-Kamikaze> Is it churning on, or is it churching on?
21:25:03 <jle`> churchin' alonzo
21:25:45 <jle`> it is not clear from this written medium that alonzo was meant to be a pun on along
21:27:47 <Axman6> vaibhavsagar: I sitll can't imagine you using the word though :P
21:36:05 <Axman6> iqubic: 'straya*
21:46:33 <arahael> rotaerk_: But if so, then that should be their issue!
21:46:53 <arahael> Oops - lag-monster attacked me again.
22:16:47 <int-e> @bot
22:16:59 <lambdabot> :)
22:19:39 <jle`> :D
22:28:29 <int-e> Maybe this version of socat (which is used by lambdabot for TLS) works better. (It does fix a bug where a subprocess would enter an infinite loop instead of terminating...)
22:31:31 <vaibhavsagar> Axman6: :angel:
22:34:03 <int-e> But at least it was an interesting infinite loop... a sigsegv handler returning without disabling itself.
22:46:15 <iqubic> I don't know what that means int-e.
22:51:25 <Axman6> that sounds like a fun bug
22:52:55 <tabemann> why would Haskell code lock up but neither raise an exception nor fully occupy a core when trying to evaluate a circular reference?
22:53:15 <tabemann> I've noticed this on a number of occasions, where the code will freeze but use zero CPU
22:53:29 <Axman6> blackhole?
22:53:37 <Axman6> (this is a real thing)
22:53:37 <tabemann> I thought those raised exceptions
22:54:49 <`Guest00100> is there a notion of reverse-bind, where a 'result' value from an action M is fed into a function which produces the first action to be performed, then action M is performed secondly?
22:55:10 <Axman6> sounds like MonadFix?
22:55:13 <Axman6> maybe?
22:55:16 <jle`> try asking again with types
23:02:13 <`Guest00000> ( snd <$> mfix (\(a, _) -> do b <- f a; a <- m; return (a, b)) ) probably does what i'm thinking about
23:09:23 <jle`> might be easier to do with recursive do notation
23:12:58 <norc_> Good morning. The gentle introduction specifies a type signature that looks like a typo, `index :: (a, a) a -> Int`
23:13:29 <norc_> Supposedly for Data.Ix, is this really a typo or am I looking at something obsolete from Haskell 98?
23:13:41 <pacak> :t index
23:13:43 <lambdabot> Ix a => (a, a) -> a -> Int
23:13:53 <pacak> Looks like a typo to me.
23:15:14 <MarcelineVQ> What course keeps pointing people at the gentle inroduction? It's coming up a lot recently
23:15:50 <norc_> MarcelineVQ: the #haskell course on freenode.
23:16:16 <norc_> Been using it based on some discussions about various resources. This is the first that has the feeling of beeing relatively thorough and accurate.
23:16:37 <MarcelineVQ> I'm not sure what that is, do you mean chat reccomendations?
23:17:07 <speak> Yeah I'm curious too
23:17:13 <norc_> It was recommended in here because I was not satisfied with realworldhaskell, haskellbook, etc.
23:17:29 <MarcelineVQ> gotcha
23:18:00 <speak> What is "the #haskell course on freenode" ? :o
23:18:08 * speak didn't getchait
23:18:31 <norc_> Just a poor joke.
23:18:33 <MarcelineVQ> speak: just learning resource reccomendations from here appearantly
23:18:49 <speak> Alright gotcha finally norc_ :P
23:18:53 <speak> Yeah MarcelineVQ 
23:18:57 <norc_> Though in retrospect I should have just picked up the haskell report.
23:19:04 <MarcelineVQ> it's a fine joke I just didn't expect it ehe
23:19:05 <norc_> Unlike the C++ specs its actuallyr eadable.
23:19:50 <jle`> yes it's actually a pleasant read
23:19:55 <jle`> i read it sometimes for leisure
23:42:06 <kahlil29> Having an issue with replacing the arguments of orderBy in Opaleye (for a select query) http://lpaste.net/358366  Any help would be appreciated. Thanks 
23:43:42 <cocreature> kahlil29: please add the code that’s actually causing the problem
23:46:25 <kahlil29> cocreature: Updated. 
23:46:55 <kahlil29> I'm guessing I need to find the correct types for sortColumnName and sortDirection instead of just using String
23:47:09 <kahlil29> But the error message is going above my head quite a bit
23:47:26 <cocreature> kahlil29: that’s still not the code causing the error message. the error message mentions "sortDirectionStr" but that’s not in the code you’re showing us
23:48:31 <Axman6> kahlil29: you're applying the string sortDirection to a function?
23:48:57 <Axman6> what is the type of orderBy?
23:49:11 <cocreature> I suspect the problem is that you are trying to pass "asc" as a string instead of using the type that asc has in opaleye https://hackage.haskell.org/package/opaleye-0.5.4.0/docs/Opaleye-Order.html#v:asc
23:49:37 <Axman6> `(sortDirection (\r -> r ^. sortColumnName))` definitely doesn't make sense if sortDirection :: String
23:50:53 <kahlil29> yes you're right 
23:51:13 <kahlil29> but what type do I have to make them? I referred to the doc also 
23:51:16 <kahlil29> but what type do I have to make them? I referred to the docs also 
23:51:38 <cocreature> kahlil29: use the type of the thing that you are trying to make a parameter, i.e., in your case "asc"
23:51:48 <cocreature> see the link I pasted above for the exact type
23:52:43 <cocreature> you’re probably going to have to specialize it a bit to your column types
23:54:31 <kahlil29> yes I think I got it cocreature: thanks 
