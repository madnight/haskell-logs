00:00:11 <jared-w> GHC bug reports are a whole different category of pain than "using" Haskell, though ;)
00:00:27 <sternmull> jared-w: I often have to debug complex C++ programs, and often the problems can only be reproduced on the system of the user. In that case i just don't know where to look at until i can attach the debugger and watch the program. So i often have no chance to narrow the problem without the debuggers help.
00:01:28 <jared-w> Sure, if the compiler itself is breaking the language, you're gonna have a bad time... But barring that, I don't know of any "x bug stumped me for weeks/months" stories from Haskell developers ¯\_(ツ)_/¯
00:01:59 <jared-w> sternmull: that's definitely a different story; debuggers are invaluable then :)
00:04:22 <boj> pimlu: i spent the first 5 years of my life learning to walk and talk. what kind of super genius are you? o.O
00:04:42 <sternmull> I read about GDB support for haskell. But that seems to be work in progress and probably will never be as helpful as debugging an imperative language with GDB.
00:08:05 <jared-w> cocreature: yeah nix-shell in the code/exercises folder is trying to build xorg-server, two different chromium versions, reflex-dom-core, ghc-8.0.2-with-packages (and the other like 80 packages I already spent hours installing)
00:08:35 <WinterFox[m]> Why does ghci complain about tab indentation?
00:08:41 <jared-w> Because tabs are evil
00:08:48 <WinterFox[m]> How?
00:08:54 <boj> so say we all
00:09:52 <jared-w> Well, for Haskell, the indenter uses spaces for alignment and indention and treats tabs weirdly since things have to be aligned correctly on the column for certain things and it doesn't know how many spaces to pretend the tabs are
00:10:02 <jared-w> s/indenter/parser+lexer
00:10:06 <cocreature> WinterFox[m]: in languages where indentation matters (Haskell, python, …) tabs are confusing since you can’t just arbitrarely choose how many spaces a tab maps to
00:10:08 <pimlu> boj: lol
00:10:27 <pimlu> this is why lojban is a thing
00:11:16 <pimlu> although tbh it sounds like the description would be attached the other way
00:11:21 <jared-w> This is less noticeable in python because most people usually indent things a consistent amount every time. Haskell indenting is an /art/ and anywhere from 2 spaces of indenting to 13.5 is totally normal
00:11:45 <cocreature> python discourages tabs as well
00:11:57 <c_wraith> also, it gets really tiring answering questions about "why is this a parse error?" with "because you used tabs"
00:12:03 <pimlu> indentation always bothered me in python but never haskell
00:12:06 <WinterFox[m]> jared-w: why would you want to change your indentation level?
00:12:21 <pimlu> I guess cause it means a lot more and it's optional
00:12:34 <boj> WinterFox[m]: because you work on a team where everyone has different opinions about how far a tab should indent
00:12:39 <jared-w> WinterFox[m]: because most people hate having 8 spaces be your indenting level and they change their tab key to insert something /sane/ like 4 (or 2 if you like lisp, or 3 if you hate everyone)
00:12:50 <c_wraith> WinterFox[m]: if you can use tabs perfectly, disable the warning.  But don't be surprised if it's tricky.
00:13:14 * jared-w flips table
00:13:17 <WinterFox[m]> jared-w: yeah but if you use tabs everyone can set it to what suits them.
00:13:50 <jared-w> WinterFox[m]: no they can't if they use tabs and then spaces intermixed for alignment :p
00:15:03 <jared-w> imagine a function that has a 10 char long name and you use guards below the function name
00:15:34 <WinterFox[m]> I just use one tab under it.
00:15:36 <jared-w> If my tab looks like 4 spaces, I'm probably going to insert 2; however GHC thinks my tabs are 8 spaces and so it'll be equivalent to 16 spaces
00:16:13 <jared-w> so if I have a case statement inside the function I need to space it in a way that either breaks haskell on my end or on the compiler's end; nobody's happy
00:17:06 <boj> then you get the teammate that thinks they are using tabs, but actually has their editor set to tabs-to-spaces
00:17:16 <jared-w> Also, regarding the flip table comment; the building for reflex whatever "ran out of space" and killed and now it's starting over on the linking bit and I'm about to shoot something
00:17:55 <jared-w> boj: and then there's the intern--you set their tabs to 3 spaces so they get yelled at by the prick who thinks he's the hotshot :p
00:18:04 <boj> lol
00:19:26 <AndreasK> Is there a way to make ghc generate implicit callstack arguments? I found that post: https://simonmar.github.io/posts/2016-02-12-Stack-traces-in-GHCi.html but that hangs  ghci on windows.
00:19:55 <jared-w> anyway I'm off to bed; this will take a few hours I think. I'll see if it broke in the morning
00:24:20 <monochrom> Tabs are not evil. Editors that try to be a smartass by letting you "configure" "the meaning" of tab are.
00:25:46 <jared-w> If my typewriter can let me change my tab-stop size then as gawd is my witness, it shalt ever be so. #team4space
00:26:29 <c_wraith> I'm a big fan of half-indented `where'
00:26:44 <jared-w> Same. 2 spaces for where is nice
00:27:00 <monochrom> I mean, it surely sounded like a cool feature for C when you liked to indent by 3 spaces and your friend likes 7 spaces instead and the two of you could never reach an agreement so you said "let's use one tab and set our respective editors to fake 3 or 7 spaces respectively".
00:27:36 <monochrom> But with layout-sensitive languages like Python and Haskell, this simply doesn't scale.
00:28:28 <monochrom> Yeah, 2 spaces for "where" and 4 spaces after "do\n" is a very honest and responsible choice.
00:29:24 <monochrom> Because it reminds the reader (who may be a beginner who wouldn't realize otherwise) that the "where" is not part of the do-block and cannot see things defined/bound inside.
00:30:51 <monochrom> Not to mention that in other contexts as well the "where" stands out as a separator so the whole code is really well-structured.
00:38:29 <Liskni_si> monochrom: why doesn't it scale for python? there are no do/where/let in python, are there? so every indentation can be a multiple of some n
00:39:24 <monochrom> Oh, I guess that's true.
00:41:01 <dmwit> monochrom: Just in case you somehow haven't seen my evangelism, in dmwit.com/tabs I describe a style that lets you return to "tabs can be 3 or 7 spaces" without screwing layout over royally.
00:43:07 <dmwit> WinterFox[m]: I guess you should probably read it, too; if you are going to use tabs, you should know where discipline is needed to make that work.
00:44:27 <monochrom> The 3rd goal is a special case of the 2nd goal.
00:46:20 <dmwit> monochrom: No, "the style should keep Haskell's flexibility about where blocks can start" is new.
00:47:19 <monochrom> Hrm, OK.
00:51:39 <dmwit> And anyway I think it is okay to have two different goals ("works for different people" and "works for compiler") that are both achieved with the same mechanism ("works with any tabstops").
00:56:49 <monochrom> Neato.
00:59:44 <dmwit> =D
01:18:31 <marvinXP> If I have a two stage parsing thing. First step produces [Maybe String], then I have a function that does String -> Maybe Float. I'm stuck getting a result of type: [Maybe (Maybe Float)]  (or sequence'd, Maybe [Maybe Float]).
01:19:04 <geekosaur> :t join
01:19:05 <lambdabot> Monad m => m (m a) -> m a
01:19:17 <geekosaur> but, more likely, you have used fmap when you wanted
01:19:21 <geekosaur> :t (>>=)
01:19:23 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:20:02 <tabemann> I've tried to turn my current project into a cabal package, and I'm having a lot of problems with shadowed dependencies, even though it built fine when I built the dependencies by hand under ghc 8.0.2 (I'm now using 8.2.1)
01:21:08 <geekosaur> :t \f a -> join (fmap f a)
01:21:09 <lambdabot> Monad m => (a1 -> m a2) -> m a1 -> m a2
01:22:18 <tabemann> http://lpaste.net/3030882825067823104
01:22:27 <geekosaur> tabemann, your options are (a) update all deps to go with 8.2.1 (b) use a cabal sandbox (or cabal new-build) (c) use a stack sandbox
01:22:47 <tabemann> geekosaur: I nuked my cabal directory
01:23:03 <geekosaur> so now you have lots of broken packages
01:23:11 <geekosaur> what did you do to ~/.ghc ?
01:23:18 <tabemann> ah that's it
01:25:04 <marvinXP> geekosaur: thanks! Yes, 'join' will fix up the mess. I've tried to use >>= suspecting it'd prevent it in the first place. I'll try a bit more.
01:26:52 <geekosaur> marvinXP, you might note above where I showed join + fmap... note the type. in particular that it's swapped around (don't worry about the names of the type variables, just that they match up in the same places)
01:36:29 <tabemann> why would there be a package that a package refers to as a dependency, but which cabal says does not exist when I try to manually install it?
01:37:23 <marvinXP> geekosaur: I'm not succeeding. Here's something that *works*, but is ugly: map (join . fmap Just) ([Just 1,Just 2])
01:37:37 <tabemann> namely, hashtables refers to a package hashtable, but I can't manually install hashtable
01:37:51 <marvinXP> (the "fmap Just" is "fmap ModifyingFunction")
01:40:52 <marvinXP> hmm, a bit better: map (\x -> x >>= Just) [Just 1,Just 2]
01:41:40 <geekosaur> :t (Just =<<)
01:41:41 <lambdabot> Maybe b -> Maybe b
01:42:44 <dmwit> tabemann: cabal will only look on Hackage by default; if the package is only available elsewhere you have to find it yourself.
01:43:03 <dmwit> tabemann: But, uh, hashtables depends on hashable (note no 't').
01:43:13 <geekosaur> however that ... ok, I kinda need to know what you are actually trying to do
01:43:22 <tabemann> ah
01:44:47 <dmwit> marvinXP: `Just` is `return` for the `Maybe` monad, and if you remember your monad laws, you know `(>>= return)` is `id`, so `map (\x -> x >>= Just) xs = map (\x -> x) xs = xs`. Not such a useful thing to do!
01:45:39 <dmwit> :t let firstStep :: [Maybe String]; firstStep = undefined; function :: String -> Maybe Float; function = undefined in map (>>=function) firstStep
01:45:41 <lambdabot> [Maybe Float]
01:46:34 <tabemann> okay, I am frustrated - I erased all signs of my previous GHC install or any software assocated it (I had previously saved their directories, now I erased them entirely), and still no luck; it is as if the code in hackage does not fit with the code in the haskell platform
01:46:50 <geekosaur> yeh, that's why I'd like to know what they are actually doing. either overthinking things or just plumbing them together wrong
01:47:07 <tabemann> I'm almost thinking I'm going to have to, for now, downgrade back to 8.0.2
01:47:52 <geekosaur> tabemann, that can easily happen, hackage has to support multiple versions of everything and when a new ghc comes out it often takes time for everything to work with it
01:48:06 <marvinXP> dmwit & geekosaur: thank you both. This unblocks me and I'll let it sink in.
01:48:40 <geekosaur> (which is why, for example, stackage has not made an LTS for 8.2.1 yet; likely there are missing packages not yet upgraded, so stackage can't be fully supported on 8.2.1 yet)
01:50:55 <dmwit> tabemann: That looks like a cabal-install bug to me. I'd complain in #hackage or directly file a bug report.
01:51:08 <dmwit> tabemann: (re: the latest lpaste you posted)
01:51:38 <tabemann> I'll see if my code works with 8.0.2 first
01:52:20 <dmwit> Okay. But I encourage you to complain whether things work out well with 8.0.2 or not.
02:25:45 * hackagebot hackport 0.5.4 – Hackage and Portage integration tool – https://hackage.haskell.org/package/hackport
02:49:42 <pal4hs> In Cassava, when updating a field in a record, I have to read two txt files and use them as a map to look up the field as the key. But in that case, it will return 'IO Text' instead of 'Text', resulting in Type mismatch. How could you solve this problem?
02:51:05 <pal4hs> Is using 'unsafePerformIO' the only way..?
02:51:15 <lavalike> pal4hs: you bump the reading up the stack of calls nearer to main, and then trickle down the data you need throughout your pure functions, instead of invoking the IO action near where you need the "map"
02:51:46 <lavalike> you can either do it explicitly or encapsulated within a reader/state monad
02:52:09 <lavalike> actually, I don't know what Cassava is, maybe this is not your problem :D
02:52:23 <pal4hs> hm... sounds like a bit hardcore to me..
02:52:46 <lavalike> yep, I looked it up, that's how you do it
02:53:08 <pal4hs> I'm not yet familiar with the use of reader/state :|
02:53:20 <pal4hs> Thanks for the advice though
02:53:27 <lavalike> do not worry about that then, in your main construct the "map", then pass it through to the functions that need it
02:53:45 <lavalike> no problem (:
02:54:06 <pal4hs> That could be easier for me. Thanks :)
02:58:04 <pal4hs> What could be the worst thing to happen if I use unsafePerfomIO in a simple processing program?
02:58:49 <lavalike> your code might not do what you think it does
02:59:12 <Svipal_> Hey
02:59:18 <Svipal_> can I develop in haskell on FreeBSD
02:59:23 <lavalike> I think so
03:00:42 <ons> Why would it be a problem?
03:01:11 <lavalike> «Building GHC on FreeBSD is currently supported on 8.4-RELEASE or later, on i386 (x86) and amd64 (x86_64) architectures.»
03:01:36 <Svipal_> well here I go then
03:02:39 <sternmull> Svipal_: Just out of curiosity... what are you going to do?
03:02:53 <lavalike> there are also binary distributions
03:03:10 <lavalike> https://www.haskell.org/ghc/download.html
03:04:56 <Svipal_> sternmull : install BSD on my laptop
03:05:06 <Svipal_> and develop there
03:05:18 <Svipal_> because arch doesn't work for me anymore since last update
03:05:31 <Svipal_> sourcemage is awesome but I don't have the time for it right now
03:05:46 <Svipal_> and I was always curious about BSD
03:07:59 <ons> Beeing curious is nice and all until it bites you in the ass :)
03:08:00 <sternmull> Svipal_: Did that a few years ago (using FreeBSD for my desktop). But switched back to arch after a while.
03:08:32 <Svipal_> what were the reasons ?
03:10:11 <sternmull> I think the primary reason was keeping my system up to date with the ports meant running builds over night or when i was at work.
03:12:24 <sternmull> Also the infrastructure of the BSDs feels out of date. They still use CVS (FreeBSD at least did it when i tried it, and OpenBSD does it today... tried that a few weeks ago). And they build strange tools around it to make it less painfull... instead of switching to a more modern CVS like git or at least svn.
03:13:55 <sternmull> But for FreeBSD i think ZFS and jails are a pretty cool thing if you have use for them.
03:16:24 <Svipal_> CVS !
03:17:17 <Svipal_> oh; apparently FreeBSD uses SVN
03:18:33 <sternmull> Ok, it was more than 5 years ago when i had my FreeBSD experience.
03:19:41 <sternmull> But OpenBSD uses it today... and it totally sucks. Takes hours to fetch or update the ports. And clutters everything with CVS metadata-files.
03:29:47 <raichoo> sternmull: You can use the github mirror if you really want to use git https://github.com/freebsd/freebsd
03:30:46 <sternmull> raichoo: Already noticed that they switched to svn in 2012. So my experience is probably totally outdated.
04:36:18 * hackagebot gjk2d 0.1.0.0 – <i>Added by suzumiya, Sat Sep 23 11:30:18 UTC 2017.</i> – https://hackage.haskell.org/package/gjk2d
04:52:30 * hackagebot hprotoc 2.4.4, protocol-buffers 2.4.4, protocol-buffers-descriptor 2.4.4
04:52:30 * hackagebot  → https://hackage.haskell.org/packages/recent
05:10:31 <terrorjack> if anyone's looking for a js eval function in haskell, i wrote a simple node.js rpc binding today: http://github.com/TerrorJack/nodejs-eval
05:11:08 <terrorjack> not up on hackage yet, seeking suggestions :)
05:11:17 <cocreature> terrorjack: what do you need this for?
05:12:18 <terrorjack> i'm writing a blog engine and would like to use katex static rendering for math
05:12:39 <cocreature> ah makes sense
05:14:32 <terrorjack> ideally i'd like a v8/spidermonkey binding via c ffi, but that will consume a lot more time
05:37:51 <CorneliusVanderb> > head [1,2]
05:37:53 <lambdabot>  1
05:37:57 <CorneliusVanderb> awesome
05:39:02 <CorneliusVanderb> > print "hello"
05:39:04 <lambdabot>  <IO ()>
05:39:28 <CorneliusVanderb> > print "<IO ()>"
05:39:30 <lambdabot>  <IO ()>
05:39:35 <CorneliusVanderb> awesome
05:39:38 <lavalike> haha
06:01:16 <Myrl-saki> ...
06:01:37 <Myrl-saki> Is lambdabot not evaluating `IO` for safety?
06:01:49 <Myrl-saki> > forever $ print "Hello world!"
06:01:51 <lambdabot>  error:
06:01:51 <lambdabot>      • No instance for (Typeable b0)
06:01:52 <lambdabot>          arising from a use of ‘show_M302358844282145041314690’
06:02:02 <Myrl-saki> Well
06:02:09 <Myrl-saki> > print "Hello world!"
06:02:11 <lambdabot>  <IO ()>
06:02:54 <Myrl-saki> > fix $ (print "Hello world!" >>)
06:02:56 <lambdabot>  error:
06:02:56 <lambdabot>      • No instance for (Typeable b0)
06:02:56 <lambdabot>          arising from a use of ‘show_M867833218253070953514739’
06:03:01 <Myrl-saki> Okay...
06:03:24 <Myrl-saki> fix $ True &&
06:03:28 <Myrl-saki> > fix $ True &&
06:03:30 <lambdabot>  <hint>:1:14: error:
06:03:30 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
06:03:38 <Myrl-saki> I'll just do it in PM.
06:03:43 <cocreature> Myrl-saki: yep, once you start evaluating IO. preventing people from compromising your system becomes tricky
06:04:10 <Myrl-saki> cocreature: This is awesome tbh.
06:04:20 <cocreature> what?
06:04:46 <Myrl-saki> cocreature: The fact that Haskell's type can allow you to *not* perform IO.
06:04:55 <Myrl-saki> type system*
06:05:00 <Myrl-saki> I mean.
06:05:11 <Myrl-saki> That should be obvious, but it's interesting to see it being used practically.
06:05:31 <Myrl-saki> wei2912: Hallu~
06:05:41 <cocreature> well it’s not quite as simple. Haskell provides a few escape hatches. but with SafeHaskell you can get relatively close
06:05:53 <Myrl-saki> cocreature: Yeah, I was also thinking of unsafePerformIO
06:07:13 <Myrl-saki> cocreature: What escape hatches are known to be "checked" by lambdabot?
06:08:15 <cocreature> Myrl-saki: it uses SafeHaskell which catches most of the common ones like unsafePerformIO. not sure what other checking it does
06:09:02 <srhb> Is SafeHaskell basically automating "preventing" importing unsafePerform and friends?
06:09:16 <Myrl-saki> Whoops. Accidentally S-w'd.
06:11:27 <cocreature> srhb: yeah, the rough idea is that you can’t circumvent the type system if you use Safe Haskell https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/safe_haskell.html
06:11:35 <cocreature> so no unsafeCoerce, unsafePerformIO, …
06:12:00 <Myrl-saki> cocreature: What happens if you unsafeCoerce an IO action?
06:12:10 <Myrl-saki> It wouldn't evaluate, would it?
06:12:16 <cocreature> Myrl-saki: you can’t use unsafeCoerce in Safe Haskell :)
06:12:24 <Myrl-saki> cocreature: I mean in normal Haskell. :P
06:12:39 <Myrl-saki> Or in GHC Haskell?
06:12:41 <cocreature> Myrl-saki: well what do you coerce it to?
06:12:47 <Myrl-saki> cocreature: :: IO a -> a
06:13:01 <cocreature> that will probably just cause a segfault in most cases
06:13:03 <hpc> Myrl-saki: someone else will probably know better, but in ghc unsafeCoerce :: IO a -> a is the same as unsafePerformIO
06:13:17 <cocreature> hpc: oh it is?
06:13:23 <cocreature> I wasn’t aware of that
06:13:29 <Myrl-saki> hpc: That's kinda interesting.
06:13:45 <hpc> oh, i guess it isn't
06:14:09 <hpc> it's actually pretty weird, at least in ghci
06:14:09 <hpc> Prelude Unsafe.Coerce> unsafeCoerce (putStrLn "test" >> return "test2") :: String
06:14:12 <hpc> ""
06:14:52 <hpc> maybe that's IO data constructor #0 mapping to [] data constructor #0
06:14:59 <Myrl-saki> Prelude Unsafe.Coerce> unsafeCoerce $ putStrLn "test"
06:15:03 <Myrl-saki> Interesting.
06:15:18 <Myrl-saki> Errr
06:15:19 <hpc> i know at some level, ghc IO is implemented as impure values
06:15:23 <Myrl-saki> I just realized what just happened. Lmao.
06:15:27 <cocreature> “(unsafeCoerce (putStrLn "hello world") :: ()) `seq` ()” just doesn’t do anything
06:15:40 <Myrl-saki> cocreature: Also here.
06:16:14 <Myrl-saki> OTOH, where does unsafeCoerce actually make sense?
06:16:38 <Myrl-saki> I've only used unsafeCoerce for "dependent-typed" data.
06:16:49 <hpc> oh, IO is a newtype, now i am really confused
06:16:56 <hpc> http://hackage.haskell.org/package/ghc-prim-0.5.1.0/docs/src/GHC.Types.html#IO
06:17:00 <cocreature> that sounds wrong, why do you need unsafeCoerce for dependent-typed data?
06:17:30 <Myrl-saki> cocreature: I used it, but that was because of me not knowing how to do it properly :P
06:17:38 <cocreature> fair enough :)
06:17:50 <Myrl-saki> cocreature: Basically, :: Finite n -> Finite m
06:17:59 <Myrl-saki> I didn't know how to do it properly, so I just dropped unsafeCoerce.
06:18:23 <cocreature> Myrl-saki: a more reasonable usecase is converting "Map Int Int" to "Map Age Int" where "newtype Age = Age Int" if Age has the same Ord instance as Int
06:18:50 <Myrl-saki> cocreature: How does it "rewrap" it to newtype?
06:18:55 <Myrl-saki> Err
06:18:56 <Myrl-saki> s/re//
06:19:07 <cocreature> Myrl-saki: it doesn’t. newtypes have the exact same runtime representation
06:19:11 <cocreature> so it’s just a noop
06:19:12 <Myrl-saki> cocreature: Ah.
06:19:37 <Myrl-saki> cocreature: Thanks.
06:19:57 <cocreature> in a lot of cases you can use "coerce" instead of "unsafeCoerce" to do these conversions but for non-trivial reasons you can’t always safely convert to a different newtype
06:20:19 <cocreature> e.g. if there was a different Ord instance for Age, the internal invariants of Data.Map would be violated
06:21:08 <Myrl-saki> What is the function that does `:: a -> Maybe b` again?
06:21:49 <cocreature> the only reasonable implementation of that type is "const Nothing" and that’s probably not what you’re looking for
06:22:06 <Myrl-saki> cocreature: It also "breaks" the type system.
06:22:12 <cocreature> there is "cast :: (Typeable a, Typeable b) => a -> Maybe b"
06:22:17 <Myrl-saki> Oh. cast.
06:22:19 <Myrl-saki> Right.
06:22:28 <Myrl-saki> cocreature: Does `cast` also work for newtypes?
06:22:29 <cocreature> the important point is that you need the Typeable constraints
06:22:46 <hydraz> :t Just . unsafeCoerce
06:22:48 <lambdabot> error:
06:22:48 <lambdabot>     Variable not in scope: unsafeCoerce :: a -> a1
06:22:52 <hydraz> ugh
06:22:56 <Myrl-saki> hydraz: lol
06:22:58 <Myrl-saki> hydraz: I mean. True.
06:23:00 <hydraz> Myrl-saki: regardless, that's what you want.
06:23:20 <Myrl-saki> hydraz: What if I wanted `const Nothing`? :P
06:23:31 <cocreature> Myrl-saki: cast checks if the types match not if things can be safely converted. so for newtypes it definitely will not just convert from one to the other
06:23:34 <hydraz> that's less funny, though
06:23:53 <Myrl-saki> cocreature: Mkay. Thanks.
06:24:20 <Myrl-saki> cocreature: Do you use this for like, dependent-sum or something?
06:24:43 <Phillemann> "data Foo Ω α = Foo ..." fails with "unexpected type Ω", what's that?!
06:24:49 <wei2912> Myrl-saki: hi!
06:24:51 <Myrl-saki> I guess you could also do some weirdness like `test :: a
06:24:53 <Myrl-saki> Err
06:25:00 <Myrl-saki> `foo :: a -> IO ()`
06:25:06 <Myrl-saki> Which only works if given the proper type.
06:25:07 <hydraz> Phillemann: Ω is upper case, so it's interpreted by GHC as a /type/ name, not a type variable
06:25:08 <Myrl-saki> wei2912: Nyanpass~
06:25:16 <Myrl-saki> wei2912: Water you doing?
06:25:24 <Phillemann> hydraz: Ahhhh, of course. Nice :D
06:25:31 <Phillemann> hydraz: Thanks.
06:25:39 <cocreature> Myrl-saki: no, otherwise you would have Typeable constraints in the API
06:25:42 <hydraz> np
06:25:57 <Myrl-saki> cocreature: True.
06:26:09 <Myrl-saki> cocreature: Thansk.
06:26:11 <Myrl-saki> Thanks*
06:26:37 <cocreature> Myrl-saki: Typeable is useful for things like Data.Dynamic https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Dynamic.html
06:26:57 <hydraz> Isn't Typeable the other kind of generics GHC supports?
06:27:40 <cocreature> no Typeable has nothing to do with generics
06:28:07 <cocreature> typeable gives you a runtime representation of types so you can compare them for equality
06:28:29 <hydraz> "to support the «Scrap your boilerplate» style of generic programming."
06:29:22 <cocreature> hydraz: read closer, it says Data.Data is the thing that gives you generics
06:29:26 <cocreature> not Typeable
06:46:36 <terrorjack> what are the differences between weak references/foreignptrs with haskell finalizers?
06:58:24 <wei2912> Myrl-saki: pm
07:45:21 <user____2> hi all
07:46:05 <Ero> heres a weird one. ghci is reporting 'enumeration is empty' when i try to [10..0] and evaluates it to []
07:46:18 <mauke> what's the weird part?
07:46:43 <Ero> im expecting it to create a list [10,9,8,7,6,5,4,3,2,1,0]
07:46:59 <Ero> what am  i doing wrong?
07:47:05 <mauke> expecting weird things
07:47:31 <lavalike> > enumFromTo 10 0
07:47:33 <lambdabot>  []
07:47:39 <lavalike> > enumFromThenTo 10 9 0
07:47:42 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0]
07:47:46 <Ero> thx 
07:47:48 <mauke> > [10, 9 .. 0]
07:47:51 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0]
07:47:59 <lavalike> (those are the desugared versions)
07:48:03 <Ero> cheers
07:49:03 * hackagebot Win32 2.6.0.0 – A binding to part of the Win32 library – https://hackage.haskell.org/package/Win32
07:51:22 <Ero> [1..10]
07:51:43 <michi7x7> > reverse [0..10]
07:51:45 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0]
07:51:47 <lavalike> you need to prepend the expression with "> " to get the bot to evaluate it
07:51:54 <Ero> ty
07:52:05 <lavalike> np (:
07:54:07 <michi7x7> > sortBy (flip compare) $ takeWhile (<=10) [1..]
07:54:10 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
07:54:30 <mauke> > map (10 -) [0 .. 10]
07:54:32 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0]
08:25:00 * hackagebot megaparsec 6.2.0 – Monadic parser combinators – https://hackage.haskell.org/package/megaparsec
08:33:06 * hackagebot free-functors 0.8.1 – Free functors, adjoint to functors that forget class constraints. – https://hackage.haskell.org/package/free-functors
08:41:14 <va> hi
08:41:39 <lavalike> howdy
08:55:31 * hackagebot strict-types 0.1.0 – A type level predicate ranging over strict types – https://hackage.haskell.org/package/strict-types
08:55:31 * hackagebot apecs 0.2.1.1 – A fast ECS for game engine programming – https://hackage.haskell.org/package/apecs
08:58:31 <Myrl-saki> Thinking of working on a little project. How would I compile and evaluate IO in, say an MCU?
08:58:43 <digitalkiwi> I like how you guys just gave like 5 ways of doing the same thing 
08:59:10 <Myrl-saki> > [10,9..]
08:59:11 <erisco> id whatever they said
08:59:13 <digitalkiwi> now we need to benchmark and find out which is fastest and which is most efficient!
08:59:13 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-...
08:59:13 <Myrl-saki> Whops
08:59:17 <Myrl-saki> Close enough.
08:59:47 <Myrl-saki> digitalkiwi: IIRC, [a,b..c] is syntactic sugar for enumFromThenTo.
09:00:00 <[exa]> Myrl-saki: what do you mean by 'MCU' ?
09:00:16 <Myrl-saki> [exa]: Microcontroller.
09:00:40 <digitalkiwi> what about the map and reverse and sortby ones
09:00:46 <Myrl-saki> I'm not going to be porting Haskell to a microcontroller though.
09:00:56 <[exa]> Myrl-saki: oh so. the anwer is "you mostly don't"
09:00:57 <Myrl-saki> I'm thinking of making another language, but with the same principles.
09:01:20 <[exa]> Myrl-saki: but I'm writing a compiler for almost-haskell for low-level platforms, kernels & pals, wanna join? :]
09:01:35 <Myrl-saki> [exa]: Link to the project? :P
09:02:02 <[exa]> not public yet, I was presenting it just only as a poster on last ICFP
09:02:10 <[exa]> lemme post the poster somewhere
09:03:11 * hackagebot strict-types 0.1.0.1 – A type level predicate ranging over strict types – https://hackage.haskell.org/package/strict-types
09:04:58 <va> what do you count as almost haskell?
09:05:13 <va> similar to fay?
09:05:51 <[exa]> currently no support for polymorphic recursion on types and related stuff
09:05:52 <Myrl-saki> va: I'm not [exa], but I'd think something like Haste.
09:06:58 <va> anyone doing machine learning / data science haskell projects?
09:07:06 <[exa]> haste is similar kind of haskell compatibility, but it adds features instead of stripping them to gc-less invironment
09:08:05 <Myrl-saki> [exa]: Is there support for linear types in your compiler?
09:08:09 <[exa]> yep
09:08:17 <Myrl-saki> [exa]: Okay, now I want in. :P
09:08:25 <[exa]> lemme put the poster somewhere
09:09:24 <va> is there a good tutorial on how to marshall struct data back and forth with FFI?
09:09:55 <johnw> va: bindings-DSL really makes that quite easy to do
09:10:04 <johnw> if it's C structs you mean
09:10:10 <cocreature> c2hs and hsc2hs also help
09:10:15 <johnw> and c2hsc
09:10:17 <[exa]> Myrl-saki: http://oi65.tinypic.com/123mmwl.jpg
09:10:33 <va> haskell wiki is such an unreadable mess :|
09:11:38 <va> would like a simple case before going the DSL route
09:11:55 <va> is there a hello world for marshalling / pulling data out of a pointer to a struct
09:11:56 <[exa]> va: wiki principles say: "it was your choice not to fix us"
09:12:00 <johnw> the name DSL is a misnomer
09:12:23 <johnw> bindings-DSL it's a macro setup for declaring FFI constructs; it's a compile-time DSL, if you will
09:12:45 <Myrl-saki> [exa]: The question is, is the wiki convergent?
09:12:59 <va> exa: we're all partially at fault, but there's the platform aspect as well. i'll never understand the gnu style of writing where random splatter of random user questions and answers are barfed on a page
09:13:01 <Myrl-saki> [exa]: Bad pun. :(
09:13:06 <johnw> i mean, it is a DSL, just not one represented at runtime
09:13:08 <[exa]> :D np
09:13:29 <va> with random signed commentary
09:13:29 <hpc> i always liked perl docs
09:13:33 <[exa]> va: sorry I was really just in the trolling mood :D
09:13:50 <va> sorry in a ranting mood :D
09:14:19 <[exa]> too bad I never did proper marshalling in haskell, it could have been a great flame
09:15:41 <va> i feel the same way about emacs wikis though :P
09:15:43 <[exa]> Myrl-saki: anyway if you liked the compiler write me a mail/PM, I guess it's not too much work and the would be marvelous.
09:16:00 <[exa]> s/compiler/poster/
09:16:35 <Myrl-saki> [exa]: How low-powered are you thinking?
09:16:41 <Myrl-saki> [exa]: w.r.t. microcontrollers
09:16:58 <[exa]> basically anything that can do C/C++
09:17:06 <Myrl-saki> [exa]: Sounds fun.
09:17:08 <digitalkiwi> 8088
09:18:08 <[exa]> kindof hoping to finally produce a functional "micro"-kernel
09:18:20 <[exa]> but that's pure science fiction
09:33:21 <emmanuel_erc> Does anyone know how to diagnose linking problems during file compilation?
09:33:36 <emmanuel_erc> file --> source code 
09:34:28 <erisco> http://lpaste.net/358641 GHC whines that 'forall a. a' is an "illegal polymorphic type"
09:34:50 <erisco> is this not something I can do with GHC at this time?
09:39:27 <DCCSENDSTARTKEYL> ?�DCC SEND STARTKEYLOGGER 0 0 0
09:39:28 <lambdabot> Unknown command, try @list
09:39:34 <DCCSENDSTARTKEYL> ?�DCC SEND STARTKEYLOGGER 0 0 0
09:39:34 <lambdabot> Unknown command, try @list
09:39:40 <DCCSENDSTARTKEYL> GODDAMNIT IT WORKING ON #MINECRAFT
09:39:52 <nullset[m]> ?
09:40:13 <erisco> we have lambdabot antivirus here
09:43:51 <erisco> I don't see the principle reason why I can't bind new type variables … maybe it is just not a feature
09:54:51 <rdococ> lol
09:55:03 <rdococ> lol @the keylogger attempt
09:55:57 <rdococ> > 0.1 + 0.2 == 0.3
09:56:00 <lambdabot>  False
09:56:16 <rdococ> lol
09:57:16 * hackagebot marvin 0.2.4 – A framework for modular, portable chat bots. – https://hackage.haskell.org/package/marvin
10:00:39 <maerwald> nice
10:02:16 <ongy> I love the new rating stat on hackage
10:05:34 <cocreature> erisco: it seems relatively close to impredicative polymorphism but I haven’t thought long enough about it so see if it runs into the same problems (also I’ve forgotten what the problems with impredicative polymorphism are :))
10:08:47 <cocreature> emmanuel_erc: can you show us the error you’re seeing?
10:13:12 <jle`> i've started just thinking that avoiding impredicative polymorphism is more of an implementation issue than an actual fundamental one
10:14:14 <jle`> (implementation on ghc's end)
10:17:17 <[exa]> jle`: it's the same problem as with recursion-polymorphism, you can avoid it easily but the typechecking possibilities it gives you are just too neat.
10:21:04 <emmanuel_erc> cocreature: it was an arch problem, there was a separate library ghc-libs that was not installed properly
10:21:19 <emmanuel_erc> unfortunately, solving that has led to another problem
10:22:29 <monochrom> Oh archlinux. Yeah, it has a problem.
10:22:41 <cocreature> it would be nice if it had only one problem
10:24:38 <maerwald> lol
10:26:35 * hackagebot GPipe 2.2.2 – Typesafe functional GPU graphics programming – https://hackage.haskell.org/package/GPipe
10:34:47 <RedNifre> Hi.
10:34:59 <RedNifre> Which scripting language do you use for smaller projects?
10:35:28 <maerwald> python
10:35:48 <monochrom> Shell (Bourne), bash, Haskell.
10:36:03 <RedNifre> There's no Haskell-like scripting language, right?
10:36:18 <hpc> haskell is a haskell-like scripting language
10:36:20 <hpc> if you script with it
10:36:24 <monochrom> I don't know.
10:36:32 <kadoban> What is a "scripting language" anyway?
10:36:44 <monochrom> But I don't draw a hard dichotomy anyway.
10:36:57 <RedNifre> Well, I mean a language where you just put some code in a txt file and run it, without a big project setup.
10:37:12 <maerwald> python
10:37:23 <kadoban> RedNifre: You can do that with haskell (stack's script interpreter or just runghc)
10:37:28 <monochrom> http://www.smbc-comics.com/comic/a-heap-of-trouble
10:37:32 <maerwald> haskell is a poor scripting language though
10:38:48 <RedNifre> Yeah, guess I'll stick with Ruby for scripts and Haskell for larger stuff.
10:38:55 <monochrom> That's how I almost always use Haskell. I put some code in a txt file and run it. No big project setup. No cabal, no stack.
10:39:08 <hpc> you don't even have to compile it
10:39:13 <RedNifre> hm. maybe I should try that.
10:39:23 <hpc> runghc foo.hs
10:39:36 <monochrom> I usually compile it because runghc startup time is pretty unattractive.
10:39:39 <maerwald> that doesn't make a language a good scripting language :>
10:40:02 <monochrom> But I don't even bother with "cabal init".
10:40:51 <kadoban> maerwald: I'm still unsure what a "scripting language" is, so I'm having a hard time coming up with a determination of what makes a good one or a bad one.
10:40:58 <monochrom> To be sure Haskell so much less casual than bash if you want casual.
10:41:20 <kadoban> So far our definition seems to be "you just write in a txt file and execute it", which appears to be mostly a binary true/false condition.
10:41:27 <monochrom> Like 5 and "5" are different in Haskell but bash doesn't care.
10:41:40 <emmanuel_erc> monochrom: Yeah, I'm sensing something unpleasant in arch... I'm geting an error message saying that it cannot find Prelude
10:41:50 <maerwald> kadoban: I think it's a pretty widely used term
10:42:25 <kuribas> there is turtle for shell scripting: https://hackage.haskell.org/package/turtle
10:42:28 <kadoban> maerwald: Yes, without much of a good definition.
10:42:38 <maerwald> we are not being scientific here
10:42:39 <hpc> emmanuel_erc: arch has a haskell packaging issue that breaks everything, you might have hit that
10:43:04 <emmanuel_erc> should I just install from the source directly then?
10:43:15 <kadoban> maerwald: We're communicating, presumably. Communicating without any sane definition of terms isn't terribly useful.
10:43:27 <maerwald> haskell requires a lot of up-front thought, even for seemingly simple tasks, that's not a property you want in a scripting language
10:43:41 <cocreature> emmanuel_erc: https://wiki.archlinux.org/index.php/haskell#Building_statically_linked_packages_with_Cabal_.28without_using_shared_libraries.29
10:43:53 <yushyin> emmanuel_erc: https://wiki.archlinux.org/index.php/Haskell#Problems_with_linking
10:44:02 <RedNifre> kadoban What I mean is it's very simple to solve a simple problem with it.
10:44:22 <maerwald> exactly
10:44:23 <cocreature> emmanuel_erc: tldr remove everything Haskell related that you installed via pacman except for ghc, ghc-libs and ghc-static and get a statically linked cabal from somewhere (or build it yourself)
10:44:28 <kuribas> maerwald: you mean import statements?
10:44:31 <maerwald> RedNifre: and python has that property
10:44:43 <maerwald> kuribas: I have no idea what you are talking about
10:44:47 <emmanuel_erc> cocreature: thanks for the help
10:44:47 <RedNifre> e.g. Ruby allows you to read yaml files synchronously, automatically parsing strings that look like dates to date, do some JSON/REST calls etc.
10:44:59 <RedNifre> It has a fat practical standard library with over 9000 methods.
10:45:09 <RedNifre> maerwald yeah, python and ruby are nearly identical.
10:45:16 <maerwald> not sure I agree with that
10:45:19 <kuribas> maerwald: sorry, I read your comment wrongly...
10:45:22 <RedNifre> (In the 'do something quickly' sense)
10:45:35 <maerwald> I am unable to do anything useful with ruby
10:45:41 <maerwald> maybe I suck at it
10:45:54 <kuribas> maerwald: and that up-front thought will help you when the script grows beyond it's initial purpose.
10:46:17 <monochrom> I am not sure why we're arguing over this.
10:46:42 <monochrom> But I certainly migrated a small program from shell to Haskell.
10:46:47 <RedNifre> Well, I was hoping for a more haskelly alternative to Ruby.
10:46:48 <maerwald> kuribas: sure and therefor it's not a very good scripting language
10:47:07 <hpc> my experience with ruby has been that very little is written to be modular
10:47:10 <RedNifre> Ruby is nice but it doesn't have currying included (though you can add it with a library).
10:47:21 <hpc> it's very difficult to take any single piece of something in ruby, and reason about it in isolation
10:47:23 <monochrom> But I also have some smaller programs still as shell scripts and in no need of expansion.
10:47:44 <kuribas> maerwald: if you cannot write it in bash, you may as well use a real progrmaming language.
10:47:55 <maerwald> I have no idea what that means
10:48:02 <monochrom> But anyway there are a few libraries on hackage that brings Haskell closer to the average shell commands.
10:48:11 <monochrom> turtle, shelly, etc.
10:48:27 <monochrom> s/brings/bring/  # English sucks
10:48:54 <kuribas> it's not at all difficult to write simple programs in haskell, and parser combinators make it much cleaner than perl/ruby/python
10:49:33 <monochrom> Then again maybe your "scripting" means "json scripting" rather than "shell scripting".
10:49:54 <maerwald> kuribas: not really. XML in python is very easy. In haskell you have to learn a whole DSL
10:50:29 <monochrom> I'm OK with people saying "there is such a thing as scripting" but bear in mind different people have different expectations on what the word means.
10:50:38 <maerwald> when I want quick results, I don't care about smart frameworks and DSLs, I want quick results
10:50:43 <kuribas> maerwald: I am not saying haskell is easier to learn.
10:50:45 <monochrom> Basically because different people have different hidden agendas for why they write code.
10:50:45 <RedNifre> exactly
10:50:58 <maerwald> kuribas: I wasn't talking about learning haskell
10:51:16 <monochrom> And also everyone just wants to hijack every word to server their hidden agendas.
10:52:16 <RedNifre> for example, you can do an xml/json call in ruby and get the response as some nested map/array thing where the values can be of mixed types, e.g. you get a map where "id" points to an int and "name" to a string and the interpreter trusts you to not mix them up (if you do you'll get a runtime error, but that's not a problem when solving small problems).
10:52:46 <RedNifre> Haskell's correctness is nice for serious problems, but for tiny problems "it's probably fine" is good enough.
10:52:57 <hpc> > enter stage left "x" wearing "5" -- the only correct way to use a "scripting" language
10:53:00 <lambdabot>  error:
10:53:00 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘left’
10:53:00 <lambdabot>        prevents the constraint ‘(ArrowChoice a0)’ from being solved.
10:53:12 <hpc> :(
10:53:15 <RedNifre> ?
10:53:17 <maerwald> RedNifre: exactly and it's hard to meet both properties at the same time
10:53:28 <maerwald> python tries it with type annotations, but they don't really work out
10:53:52 <kuribas> RedNifre: for a one time throwaway script, use wathever you can write the fastest.
10:53:55 <RedNifre> Well, I don't need a "one size fits all" language, Haskell is fine for medium to large projects.
10:54:02 <monochrom> But if you want casual programming, then Haskell is not going to be casual. And probably weakening to "Haskell-like" is of no use because it is for example the Haskell-like type system that makes things so much less casual.
10:54:07 <RedNifre> kuribas I do, but I wish it was more haskelly.
10:54:07 <maerwald> yes and it shouldn't be a one size fits all language
10:55:03 <kuribas> RedNifre: I recently found this: https://github.com/lihaoyi/macropy
10:55:18 <monochrom> Like I said, a Haskell-like type system is going to make a big fuzz discriminating 5, '5', and "5". Something a lot of casual languages don't inflict on you.
10:55:40 <cocreature> RedNifre: maybe you’re looking for a lisp?
10:55:47 <kuribas> monochrom: which is bad why?
10:55:55 <jle`> RedNifre: not sure if i missed too much context to make a meaningful interjection, but the main json/yaml library does let you parse responses as a nested map/array thing where values can be of mixed data types
10:56:08 <jle`> it's just decode :: String -> Maybe Value
10:56:11 <monochrom> That's a loaded question, kuribas.
10:56:31 <kuribas> monochrom: inflict sounds like it's bad...
10:57:04 <monochrom> That's from the point of view of someone seeking casual coding.
10:57:22 <monochrom> Is math discovered or inflicted? :)
10:57:43 <RedNifre> cocreature maybe I am. I tried Clojure but I found the "map returns Seq instead of the original functor type" a bit weird. Maybe I should give it another chance.
10:58:15 <RedNifre> Here's a ruby library that auto-curries functions and allows using "*" for function composition: https://github.com/banister/funkify
10:58:29 <jle`> i've actually recently been using haskell for a lot of scripting recently
10:58:36 <jle`> i had to write an auto-grader for a course
10:58:48 <jle`> and the fastest way to write them has been to use haskell scripts
10:58:50 <jle`> one-off files
10:58:53 <RedNifre> By the way, I haven't used Haskell for two years and want to get back into it, what did I miss?
10:58:54 <hpc> @quote cried
10:58:54 <lambdabot> Ferdirand says: I was TA for a C++ programming course aimed at 1st year physics once. Some girl asked for help "i wrote pseudo-code but I cannot translate it to C++". Her pseudo-code was valid
10:58:55 <lambdabot> haskell. I cried.
10:59:00 <kuribas> monochrom: it still escapes me how someone could find "True - 1 == False" to be reasonable.
10:59:06 <monochrom> Oh auto-grader was also how I started with a shell script but later moved to Haskell.
10:59:35 <erisco> wow, that is tragic
10:59:44 <hpc> kuribas: obviously True - 1 == "-1"
11:00:00 <kuribas> hpc: lol
11:00:06 <hpc> kuribas: interpret True as a string, then interpret 1 as a string, then for the subtraction "True" = 0
11:00:11 <sm> RedNifre: stack, ghcid, newer GHC/libs
11:00:11 <hpc> and the result obviously has to be a string too
11:00:14 <tabemann> for some reason, I find "casual languages", e.g. javascript or shell, to be harder to work with than ones like haskell
11:00:16 <RedNifre> Regarding lisps, is Racket any good?
11:00:26 <RedNifre> sm thanks, I'll look those up.
11:00:27 <tabemann> because when they don't work, they're harder to debug
11:00:44 * sm can't think of much else that matters, alarmingly
11:00:53 <tabemann> whereas with haskell once I've got it to compile, at least half of the time it just works
11:01:08 <tabemann> which is a really major plus
11:01:10 <jle`> RedNifre: the biggest ecosystem change in the past two years is probably stack/stackage
11:01:47 <jle`> yeah i use haskell for my autograder too because i can just load in language-python and analyze their python code as an ADT
11:01:57 <kuribas> RedNifre: perhaps Functor/Applicative/Monad?
11:02:12 <RedNifre> Also, what's the situation regarding Reactive Extensions (Rx), FRP etc.? Neither Pipes nor Conduit is very Rx compliant, huh?
11:02:34 <kuribas> RedNifre: and that much of the standard library is much more general now?
11:02:56 <RedNifre> kuribas oh right, I heard about that in the news! Monads being Applicatives is nice.
11:03:42 <kuribas> RedNifre: you should now use pure, traverse, fmap, etc.. instead of return, mapM, liftM
11:04:11 * RedNifre still hates that fmap isn't just map.
11:04:34 <tabemann> now I feel like I have to go through my codebase and replace every instance of "return" with "pure"
11:05:23 * Rembane hands tabemann find -name '*.hs' -execdir sed -i -e 's/return/pure/g' {} \;
11:06:23 * hackagebot cabal2nix 2.6 – Convert Cabal files into Nix build instructions. – https://hackage.haskell.org/package/cabal2nix
11:07:00 <RedNifre> Oh, right, what's up with Nix and NixOS? I vaguely know what NixOS is about, but what's the situation regarding Haskell + Nix? I heard it's a good fit?
11:07:11 <hpc> it's a pretty good fit
11:07:38 <hpc> or rather
11:07:48 <hpc> given nix, haskell compares favorably against other languages
11:07:57 <hpc> given haskell, stack probably compares more favorably than nix
11:08:08 <monochrom> tabemann: Oh yeah if I use shell for something, it has to be so simple it obviously contains no mistakes, because what you said about what happens if there are mistakes.
11:10:14 <taktoa> hpc: that's probably only true if your build is relatively simple. if you are working on a Big Project, nix is much more scalable and customizable than stack
11:10:37 <monochrom> jle`: Wait, what does your program look for in students' python code?
11:14:45 <monochrom> My use of Haskell in this context is I just enjoy the convenience of async so I can spawn one job of running the student code and another job of timeout and just have them race.
11:14:45 <kuribas> jle`: why not just run it in python?
11:14:45 <hpc> kuribas: code written by students is only slightly safer to run than code written by nigerian princes
11:14:45 <ongy> I agree with hpc. even if those students are not malicious
11:14:45 <tabemann> couldn't you spawn self-contained virtual machines to run each student program in?
11:15:04 <taktoa> or use cgroups with resource limits
11:15:07 <ongy> we do that with lxc containers and zfs
11:15:19 <monochrom> Also shell's idea of "trap" is not much better than BASIC's "on error goto". This is 2017 already.
11:15:41 <jle`> monochrom: it depends on the assignment
11:15:49 <jle`> one of them was that they had to use subtraction to do something
11:15:58 <jle`> so i looked for the presence of the Minus operator
11:16:06 <monochrom> Ah neat.
11:16:11 <jle`> which is neat using lens
11:16:20 <jle`> it's just anyOf (template . _Minus)
11:16:21 <Welkin> jle`: are you sure it wansn't just a comment?
11:16:23 <tabemann> did you actually execute these assignments?
11:16:34 <jle`> Welkin: comments would not be parsed as a Minus operator
11:16:46 <jle`> tabemann: i try not to unless necessary
11:16:49 <kuribas> hpc: code written by nigerian princes would be very safe probably.
11:16:53 <tabemann> or did you regard them as so much radioactive waste to be safe to actually execute
11:16:55 <jle`> for behavior tests i have to do some sort of sandboxing
11:17:10 <monochrom> Welkin: jle` uses a python parser from the language-python library first.
11:17:26 <jle`> er sorry, has (template . _Minus)
11:17:29 <ongy> jle`: that sounds pretty cool \o/ but why do you force your students to use python?
11:17:35 <jle`> template is a pretty crazy useful traversal
11:17:39 <monochrom> This is a Haskell program! jle` is not going to just treat the code as string! :)
11:17:46 <jle`> it traverses a data type for any nested values of a given type
11:17:53 <jle`> ongy: not my choice unfortunately :'(
11:17:58 <monochrom> It is also why jle` didn't choose Tcl. :)
11:18:06 <ongy> we just allow any language they want! it's fun
11:18:12 <Welkin> jle`: why do you hate your students
11:18:12 <tabemann> because schools think that people shouldn't be taught low level languages like C anymore, yet at the same time won't understand truly high level languages like Haskell
11:18:20 <kuribas> jle`: ah, so it's to sort out obviously wrong answers?
11:18:31 <jle`> well certain assignments test out language concepts
11:18:34 <tabemann> so Python is chosen because it's the language that is seen as requiring the least knowledge to use
11:18:40 <jle`> this assignment was 'do you know how to use operators like + and - to manipulate numbers'
11:18:54 <jle`> there are several such tests
11:19:18 <jle`> it was just an example that had a really cute implementation using lens and language-python hehe
11:19:26 <Welkin> in python, True + 1 = 2
11:19:47 <monochrom> No I think those schools choosing python did it for the quick gratification. Going back to what we said about why Python counts as a scripting language.
11:19:48 <ongy> Welkin: I think that happens in C aswell (provided the defines for true and false are in scope)
11:19:58 <tabemann> when I went to school in the early 2000s they used java for the first entry level CS course... and everything else was in C, except for one computer graphics course which was in C++
11:20:08 <monochrom> At the very least I did ask the profs in my school and that's what they said.
11:21:10 <tabemann> wait - I did have a course where I programmed in MIPS assembly
11:21:19 <jle`> on one project they had to guess an age by subtracting a year from 2017, so i searched all numeric literals using template for one that was 2017.  and then i realized they might try something fancy with the datetime library so i also searched all import statements for datetime and checked all function calls for 'year', which was all really easy using template/lens
11:21:26 <monochrom> (Previously, they chose Java. And found it too much headers, all that "public class X { public static void main(String[] args)" jazz.
11:21:39 <ongy> we do java in first semester, a functional language in third (I got lucky and had Haskell, some have to do OCaml) and some C distributed over other courses (mostly required, less learning)
11:21:43 <jle`> uses2017 = anyOf (== 2017) template
11:22:03 <jle`> * anyOf template (== 2017)
11:22:07 <monochrom> Aw don't look down upon OCaml, it has something interesting to offer that Haskell doesn't.
11:22:08 <ongy> monochrom: because if __name__ = "__main__": is so much better
11:22:25 <iqubic> monochrom: which is?
11:22:38 <ongy> haven't tried it. and not sure about the langauge, but I hear the prof that uses OCaml is less enjoyable than the one that uses Haskell for the course. so I consider myself lucky
11:22:53 <tabemann> I tend to be of the opinion of that people should be taught a low level language (C, and if possible also assembly) and a very high level language (e.g. Haskell, OCaml, Scheme, etc.) simultaneously
11:23:13 <iqubic> tabemann: why?
11:23:14 <monochrom> Heh well I suspect in practice they just work in DrPython or something so they never need a main.
11:23:17 <hpc> i would favor assembly over C
11:23:41 <hpc> iqubic: learning the full range of abstraction power is a good way to fight the blub effect
11:23:45 <iqubic> Where can one go to learn assembly? That's on my todo list.
11:23:59 <iqubic> hpc: what is the bulb effect?
11:24:04 <ongy> monochrom: have you seen BlueJ? we used that back in school. it's pretty cool
11:24:19 <monochrom> I haven't. They haven't either.
11:24:42 <hpc> iqubic: imagine a programming language called blub, in terms of abstraction power it sits somewhere in the middle and it's all you know
11:24:53 <hpc> iqubic: languages that are weaker than blub are bad because they can't even do X
11:24:57 <iqubic> ongy: I used IntelliJ in school
11:25:05 <tabemann> iqubic: so that people learn both how the machine works in a direct fashion, while also learning very high level abstractions and programming techniques that are not readily available if one is solely programming in a low level language
11:25:10 <hpc> iqubic: and languages with more abstraction power are bad because nobody needs Y
11:25:10 <ongy> I highly agree with tabemann. Learning Haskell showed me a lot of what I was missing. Learning C mostly helped to be able to understand kernel code :)
11:25:20 <iqubic> hpc: oh, i have heard about that.
11:25:34 <Welkin> ongy: that is the "blub paradox"
11:25:49 <ongy> Welkin: hm?
11:25:59 <monochrom> Oh hahaha template and tinplate.
11:26:21 <johnw> tabemann: one could argue that Software Foundations does this somewhat: by first teaching Gallina and Coq, and then building an imperative language called Imp and showing the relation between the two.  Although it's Coq and Imp, the division has similarities to Haskell and C.
11:26:23 <Welkin> I mean, hpc ^
11:27:13 <ongy> I learned some isabelle/HOL after Haskell. Maybe I didn't get far enough in, but the new concepts I learned there aren't as eye opening as going from java->C++->C to Haskell
11:27:33 <Welkin> I don't see why anyone would start with java or c++...
11:27:42 <Welkin> I started with c and assembly, then went to haskell
11:27:45 <iqubic> Welkin: that's all my school offered.
11:28:03 <Welkin> my school didn't offer haskell either
11:28:21 <rotaerk> I had a class that touched on ML, but that's about it
11:28:41 <hpc> it's easier to teach java because you don't have to teach the teachers first :(
11:28:42 <tabemann> I didn't learn anything about functional languages in school; I completely taught myself about them
11:28:52 <[exa]> hpc: +1
11:28:52 <Welkin> 98% of what I know and use today, I learned outside of school
11:29:52 <tabemann> but then the only programming language I was actually taught in school was MIPS assembly; everything else I taught myself, even if I needed them for school (e.g. Matlab)
11:30:34 <ongy> Welkin: what school? When I say school for java I mean primary education. Uni offers more and does things a bit different
11:30:37 <iqubic> Welkin: me too. Just because I know Java doesn't mean I'll be using in my daily life
11:30:49 <Welkin> ongy: engineering at university
11:31:17 <ongy> yea no, I did java back in primary education. Didn't get into programming before that, at least not farther than simple scripts
11:32:18 <tabemann> by primary education do you mean before university?
11:32:18 <Welkin> he means in the womb
11:32:18 <romanix> lol
11:33:00 <monochrom> Naw that's natal education.
11:34:11 <tabemann> my first language was Applesoft BASIC
11:34:15 <monochrom> "I am giving my baby in my belly a head start by listening to Mozart and audiobooks reading out Java code loud."
11:34:23 <tabemann> lol
11:34:37 <tabemann> after that, LOGO and 6502 assembly
11:34:59 <romanix> monochrom, the baby will be damaged for life :)
11:35:07 <ongy> I think the first language I got something done in was C#. I made a small utility that sits in the systray and allows to change proxy settings with 1 click. But I don't have that anymore
11:35:24 <monochrom> It dawned on me that my really first programming language was LEGO bricks.
11:36:02 <hpc> if we're counting stuff like that, my first programming was the incredible machine
11:36:12 <[exa]> TIM yay!
11:36:25 <maerwald> lego mindstorms
11:36:48 <maerwald> programming with pictures is the future
11:36:50 <maerwald> text sucks
11:36:52 <monochrom> 20 years after, I realized that I used essentially the same mentality, probably the same part of the brain, for all of the following: composing a thing from LEGO bricks, composing a math proof from theorems and rules, composing a program from programming constructs.
11:37:19 <ongy> you got on stackoverflow and copied lego?
11:37:42 <tabemann> I'm wondering how I can indoctrinate my daughter into programming; I've got an older machine that is less capable than this one but is still plenty usable that I can donate to her
11:37:58 <kadoban> ongy: Nice
11:37:59 <monochrom> More specifically I aced both math proofs and computer programming and observed that most other students have to suck at one of them and I wondered why and I came to that conclusion.
11:38:05 <maerwald> don't indoctrinate
11:38:07 <jmcarthur> I'd say don't force it.
11:38:10 <maerwald> that's what teachers do
11:38:23 <tabemann> I wasn't being serious about the word "indoctrinate"
11:39:27 <maerwald> programming is a mess, you should be glad if she is not interested
11:39:37 <ongy> tabemann: create something that's just slightly not what she wants and tell her how to fix that
11:40:30 <monochrom> Err why was I uppercasing all of LEGO? It's just Lego.
11:40:49 <monochrom> It must be because I was recently reading about LIGO and got them mixed up.
11:40:59 <ongy> probably because their logo looks like all uppercase
11:41:16 <maerwald> people also write TOR all the time, uppercase makes things more dramatic
11:41:36 <hpc> they don't call it cruise control for cool for nothing
11:42:55 <monochrom> If you want a child to grow up to like a thing: Ban this thing in your household.
11:43:07 <hpc> bahahaha
11:43:26 <ongy> tell them it's an adult thing, unfit for children
11:43:42 <monochrom> If you want a child to grow up to avoid a thing: Make this thing a mandatory compulsory training regime.
11:44:05 <monochrom> To be sure, in either case, there will be exceptions.
11:44:31 <tabemann> I plan on just letting her use my old machine, and see what comes of that
11:44:37 <maerwald> maybe just not take education advice from IRC people :P
11:45:53 <tabemann> monochrom: how I got into computing was not like that - starting in 3rd grade at my elementary school kids could go to a computer club after school, and one day I just out of the blue asked the teacher who ran it how I could program these things, and then she gave me a boot disk and an Applesoft BASIC manual, and the rest is history
11:46:36 <iqubic> tabemann: wow. That is hardcore.
11:47:15 <tabemann> I ended up getting every computing book I could from the local library and begging my parents to get a computer, which they eventually did
11:47:22 <shloub> <maerwald> people also write TOR all the time, uppercase makes things more dramatic
11:47:27 <shloub> ELO ranking in LUA
11:47:55 <tabemann> but yeah
11:49:25 <tabemann> I want to just nudge my daughter in the direction that she is exposed to more, well, serious computing, while showing her things like, say, libraries for drawing things for her to do stuff with
11:49:48 <maerwald> this is still the wrong channel for education advice :P
11:50:19 <iqubic> tabemann: teach her gloss.
11:50:51 <tabemann> iqubic: the haskell library, right?
11:51:15 <iqubic> tabemann: yeah.
11:51:27 <iqubic> Good for drawing things IMO
11:52:00 <tabemann> I've kinda looked at gloss, but never used it
11:52:30 <tabemann> I've been using cairo, but it's a pain getting it to work with gi-gtk/gi-gdk
11:52:45 <hpc> gloss is really easy
11:53:09 <Welkin> use the html5 canvas
11:53:38 <hpc> you can't really do anything fancy with it (it doesn't give you a gl context), but putting /anything/ in a window is so easy i could even make it work on windows
11:59:23 <sm> would anyone happen to know if you can run another app within a sub-area of a brick screen ? without taking over the whole terminal
12:00:05 <Welkin> sm: iframes!
12:00:23 <sm> yes, I want iframes :)
12:01:11 <sm> ha, those used to be such a big deal, and now I don't remember how they differ from regular frames
12:02:28 <dnovick> help
12:04:45 <cocreature> docdave: you’ll need to be a bit more specific if you’d like us to help you
12:07:26 <docdave> Sorry, it was a stupid error for me to type "help". It's been a long time since I've used IRC....skills are rusty
12:07:48 <cocreature> ah fair enough :)
12:10:14 <rotaerk> data Foo (f :: * -> *) a where { Bar :: f (T1, f (T2, f T3)) -> Foo f BarType;  Baz :: f (T4, f T5) -> Foo f BazType }
12:10:31 <rotaerk> hmm is there some kind of generalization of types like this?
12:11:08 <rotaerk> it's kind of like:  data Foo2 = Bar2 T1 T2 T3 BarType | Baz2 T4 T5 BazType
12:11:24 <rotaerk> but where each subsequent argument is nested within a functor
12:11:44 <rotaerk> so if f = Identity, Foo is the same as Foo2, but f might be Maybe or []
12:12:49 <shafox> What is the package for this type of date ? 2017-05-22T11:53:06Z 
12:13:36 <hpc> https://hackage.haskell.org/package/time-1.8.0.3/docs/Data-Time-Format.html#v:iso8601DateFormat
12:18:44 <ongy> cocreature: you around?
12:55:37 <cocreature> ongy: now I am but probably not for too long, what’s up?
13:11:53 <zenspider> I'm having a bitch of a time w/ emacs' haskell-mode + haskell-interactive-mode. The simplest file (that compiles clean on the cmdline) raises an error if I try to C-c C-l w/ "Unexpected response from haskell process."
13:12:06 <zenspider> that's ALL the info I get tho, and I can't really act on that
13:12:21 <zenspider> can someone provide a clue-by-four? I've stripped my haskell setup almost entirely
13:12:32 <geekosaur> did you change your ghci prompt?
13:13:06 <zenspider> geekosaur: nope. Don't know how :)
13:13:11 <geekosaur> haskell-interactive-mode has to be able to recognize when ghci is prompting for input, some prompt changes will confuse it and it will produce that error
13:13:35 <zenspider> I looked at the elisp and it's doing some regexps on the process... but it doesn't log what it DID get or what the regexps were
13:14:11 <geekosaur> alternately it might simply be unable to find it; this iwll happen for example if you use stack and need to 'stack ghci' to run ghci.. have top set a variable to tell haskell-interactive-mode the same thing or it will try to run ghci directly and not find it
13:14:16 <zenspider> I'm doing plain vanilla ghci while doing a course via u of glasgow... I've not tweaked much at all
13:14:40 <zenspider> it does fire up the repl... just won't load my file
13:14:48 <zenspider> or...maybe it does? I can't tell
13:15:47 <cocreature> if you set haskell-process-log to t it will output some debug info but it’s been a while since I’ve done that and I don’t recall if that info will be helpful here
13:15:50 <geekosaur> hm. what version of ghc?
13:16:11 <geekosaur> it just occurred to me that 8.2.1's fancy new errors will likely confuse the heck out of haskell-interactive-mode
13:16:41 <geekosaur> and warnings, some of which you migt get because ghci and ghc behave differently in some ways (see ExtendedDefaultRules)
13:16:44 <zenspider> cocreature: I'll try that...
13:16:55 <zenspider> geekosaur: I am running the latest version I think
13:17:01 <zenspider> yeah
13:19:48 <zenspider> I'm trying to strip this down to replicate with emacs -Q
13:19:54 <zenspider> might still be my shit
13:23:12 <zenspider> ok... confirmed... this reproduces with `emacs -Q --load wtf.el week4test.hs` and then trying C-c C-l
13:24:06 <c_wraith> zenspider: so what does ghc --version tell you?
13:25:12 <zenspider> The Glorious Glasgow Haskell Compilation System, version 8.2.1
13:25:36 <zenspider> the output in the process log looks totally benign... I guess I need to track down the regexps
13:25:39 <c_wraith> there's a good chance geekosaur was on to something, with the error format change in 8.2
13:26:01 <c_wraith> Unless you really need ghc 8.2 features, maybe try ghc 8.0.2?
13:26:35 <zenspider> process log: https://gist.github.com/zenspider/4dd21402a1efbda091327f3e7b909e09
13:27:58 <cocreature> https://github.com/haskell/haskell-mode/issues/1553 seems relevant
13:28:16 <cocreature> in particular older GHCs apparently have a different message for showing that modules have been loaded
13:28:25 <rotaerk> hmm having trouble forming a problem statement...
13:28:53 <cocreature> ongy: going to bed now, I’ll try to read the backlog or I’ll be around tomorrow
13:29:17 <zenspider> thank you
13:45:12 <zenspider> ok... ghci 8.2.1 doesn't print out the list of modules when it loads stuff... the regexps are wrong and I've fixed that... but is there a flag to tell newer ghci to print out the module names when they are loaded?
13:45:16 <zenspider> verbose or somesuch?
13:46:41 <erisco> cabal install --reinstall --enable-shared base-4.10.0.0  fails trying to resolve dependency base
13:46:50 <geekosaur> errrr
13:47:02 <geekosaur> I don't think it's possible to rebuild base separately from ghc
13:47:03 <erisco> I am using Haskell Platform on Windows and it doesn't seem to have the dynamic base libraries
13:48:42 <erisco> so… do I have to build ghc myself? =\
13:49:33 <c_wraith> are you using 32-bit ghc?
13:49:50 <jared-w> erisco: What are you trying to do, out of curiosity?
13:49:57 <erisco> I don't think so…
13:50:01 <monochrom> zenspider: To a large extent, the list of modules loaded is only important if you turn on haskell-process-reload-with-fbytecode and also use -fobject. If you don't, then you don't need that list.
13:50:24 <erisco> jared-w, compile a shared library
13:50:41 <jared-w> Base isn't really a library though
13:51:03 <jared-w> Like, "it's a library" but it's built into GHC pretty tightly and I don't think you can upgrade your base independently of GHC
13:51:04 <monochrom> So basically what I did is I also fixed the regex but now it doesn't extract that list and nothing breaks for me because I don't use that feature anyway.
13:51:34 <erisco> so what I am hearing twice now is that I need to build my own ghc
13:51:49 <erisco> so I can stick a little --enable-shared flag on it
13:52:13 <jared-w> If you want base v4.10 you need a version of GHC that has base v4.10, yes. I don't know why you need base v4.10 to have --enable-shared though
13:52:42 <erisco> so that I have the dynamic libraries for base
13:52:46 <zenspider> monochrom: cool... because I'm getting nowhere. The --help is awful 
13:53:22 <zenspider> monochrom: you might want to comment on that github issue
13:53:26 <monochrom> While we're at it, you may also like to look for "prompt2" and replace some of them by "prompt-cont" because that's also a change from 8.0 to 8.2.
13:53:33 <jared-w> I'm not sure why you need dynamic libraries on windows? GHC works terribly with dynamic libraries *anywhere* and that goes double for windows which hates dynamic libraries in general :p
13:53:46 <erisco> because… I need to compile a shared library…
13:55:03 <monochrom> More precisely replace ":set prompt2" to ":set prompt-cont"
13:55:17 <jared-w> oh, it's the library that's shared that you need to compile. Sorry, my brain isn't fully on today apparently :p
14:02:18 <nshepperd> how come you can't make a shared library out of static libraries
14:03:35 <glguy> nshepperd: You can if those static libraries were compiled with PIC
14:03:49 <zenspider> monochrom: where am I looking for this?
14:04:09 <zenspider> tho... that's for multiline repl stuff? I haven't bothered with that much yet
14:04:28 <monochrom> haskell-commands.el and haskell-interactive-mode.el
14:04:54 <monochrom> But yeah if you don't go to the ghci prompt and start entering ":{", you don't have to worry now.
14:05:49 <zenspider> kk... I mostly stick to reloading my file over and over if I have multiline stuff to tweak
14:06:00 <zenspider> not the most graceful, but it works better for me so far
14:07:10 <monochrom> Yeah I agree, I have never used :{ either.
14:09:23 <ackpacket> Are there circumstances where haskell's performance suffers compared to other languages, because data structures are remade so often VS mutating existing ones?
14:09:43 <johnw> that remaking isn't quite what you might be thinking
14:09:56 <johnw> for example, "making a new list" by consing onto another one just makes a new cons cell
14:10:07 <ackpacket> mmmm
14:10:17 <johnw> persistence gains back a lot of the efficiency that would be lost otherwise
14:10:43 <hpc> there's a log(n) upper bound on the slowdown from translating mutable data structures to immutable ones, iirc
14:11:16 <monochrom> zenspider: Oh! There is also another setting that wants the module list. If you turn on haskell-process-auto-import-loaded-modules.
14:11:25 <zenspider> monochrom: what else do you use w/ haskell? I've been trying out dante+flycheck but like... I can't get company mode hooked up properly
14:11:50 <monochrom> Nothing. Just haskell-mode itself.
14:11:53 <zenspider> as in, I should turn that off?
14:11:57 <kadoban> ackpacket: It depends. I can often gain extra performance by moving to ST and using mutable arrays or something of that sort, compared to using other more haskelly data structures.
14:12:20 <monochrom> I don't know. I turn it off, never needed it. But I don't know your use case.
14:12:22 <zenspider> boo... same with the profs. I was hoping to get a bit more hand holding w/ emacs 
14:13:02 <ackpacket> Let's say I wanted to do back-propogating neural nets for example.  1000s of weights.
14:13:08 <ackpacket> and millions of rounds of training
14:13:12 <ackpacket> er.... sorry not millions
14:13:23 <ackpacket> But a large volume.
14:13:36 <ackpacket> There is no concern about constantly re-making the data structure representing the network?
14:13:39 <monochrom> We would use a mutable array for that.
14:13:44 <kadoban> You'd probably not want to use Data.Map in that case for instance
14:14:08 <johnw> ackpacket: yeah, in some circumstances, just directly managing a mutable array or buffer makes more sense
14:14:22 <zenspider> hrm... :m + Module seems to be for setting current repl scope?
14:15:10 <ackpacket> Sounds like after so much effort to think "haskelly" it would be a pain for me to begin managing mutable buffers/arrays
14:15:13 <zenspider> ah. ok. so far I'm not declaring modules in my files... but that'll probably bite me at some point
14:15:47 <kadoban> ackpacket: There's a reason they're part of the language.
14:16:15 <johnw> ackpacket: sometimes you can still do clever things, like make the transactional updates to the network into a monoid so that you can aggregate the transformations more conventiently, ala map/reduce style
14:17:08 <johnw> even if the underlying mode is imperative, you still have Haskell's abstraction capabilities available
14:17:32 <johnw> or at the other extreme: use C and call it through the Haskell FFI :)
14:17:53 <monochrom> zenspider: Suppose you load this file "import X; import Y; z = True". Then all of the following are accessible: z, what X exports, and what Y exports. So you are not really missing a lot this way, until you want to get into X's internal unexported stuff. (But then you could ":m +X" manually, yeah.)
14:18:08 <zenspider> I think I can patch this up w/ :show modules
14:18:27 <monochrom> So this is why I haven't needed auto-import-loaded-modules.
14:18:44 <johnw> zenspider: I keep thinking that a zen spider would intuitively understand the eightfold path
14:18:45 <monochrom> Aw :show modules has a long verbose output that you need to parse out...
14:19:00 <zenspider> yup. shouldn't be too hard?
14:19:31 <monochrom> Oh I'm just being lazy.
14:20:24 <zenspider> johnw: O_o I don't think I realized you did haskell... what version are YOU using?
14:21:16 <a_h> anyone use megaparsec? trying to figure out how to express negation
14:21:22 <zenspider> hrm... I know how to read from the repl, but I don't know how to send a cmd to the repl (to do :show module)
14:21:40 <johnw> zenspider: of Haskell?  8.0.2 still
14:21:42 <rotaerk> hmm is there some extension I need in order to use operators as data constructors
14:21:58 <johnw> a_h: negation?
14:22:02 <zenspider> johnw: hrm... haskell-mode could use some love for 8.2.1... it's pretty broke
14:22:46 <a_h> johnw for example how can i express 
14:22:51 <a_h> not (string "foo")
14:23:18 <a_h> idea being, i want the parser to fail for certain inputs
14:23:27 <johnw> what does that mean?  a sequence of characters, terminated by whitespace, that is not foo?
14:23:43 <rotaerk> nm, not sure why it was erroring earlier but it's working now...
14:23:45 <johnw> there are lots of things that aren't string "foo", like eof
14:23:55 <a_h> johnw yes 
14:24:08 <a_h> i'd like something along the lines of 
14:24:21 <a_h> not (string "foo") >>= (some (notChar '\n') >> eol)
14:24:30 <johnw> maybe you could do this: x <- manyTill anyChar (try whitespace); if x == "foo" ...
14:24:41 <johnw> that is, parse whatever string is there, and then examine what you got
14:25:02 <johnw> you could fail the parser if need be with guard
14:25:39 <a_h> more specifically there's a skip condition for the parser that skips irrelevant lines
14:25:54 <a_h> but for a specific prefix, the parser should attempt to parse the line
14:26:12 <a_h> currently, what happens is if there's a prefix and it fails to parse the line, it skips it as an irrelevant line
14:26:33 <a_h> which kind of works, but i'd rather have it fail with an error message
14:26:44 <madknight> what kind of abstraction would be necessary to "fix" (write this much shorter) this https://github.com/bos/aeson/blob/master/Data/Aeson/Types/ToJSON.hs#L2452
14:26:46 <johnw> you don't really want "not string 'foo'", you want "a string of alpha numeric characters, whose content is not foo"
14:27:19 <a_h> yes, well "a line whose content does not start with 'foo'" (as the skip condition)
14:27:44 <a_h> so that:
14:27:59 <a_h> foo [... valid input ...] -> parses
14:28:14 <a_h> sADFefeffe -> parses (skipping contents, parsing as Nothing)
14:28:32 <a_h> foo [... invalid input ...] -> does not parse (to get error information)
14:29:07 <johnw> ok, then do what I suggested above, returning Just/Nothing as needed
14:29:23 <johnw> leaving it to error as normal if you take the "foo" branc
14:29:49 <hexagoxel> megaparsec has notFollowedBy, is that not exactly what you want, apart from the error message?
14:30:42 <monochrom> Oh so this is where (string "foo " >> xxx <|> yyy) will do the right thing actually.
14:30:45 <hpc> can you not refactor your parser to not need negative lookahead?
14:31:09 <hpc> that usually helps more in the long run
14:31:21 <a_h> hexagoxel i don't see how notFollowedBy would do it
14:31:51 <a_h> hpc how do you define negative lookahead?
14:32:49 <a_h> hpc to be clear, the parser itself "works" as is. it's just harder to develop when there's no error messages.
14:33:27 <hpc> http://perldoc.perl.org/perlre.html#Lookaround-Assertions
14:33:29 <hpc> ah
14:34:41 <rotaerk> hmm, time to climb out of the rabbit hole of attempted-and-failed abstraction, and take a break...
14:35:51 <johnw> monochrom: good one, I was trying to think of that
14:37:20 <a_h> monochrom johnw it seems like that would work, where yyy forces a parse failure
14:37:39 <monochrom> madknight: I can only think up mapM_ and maybe throw in zip/zipWith [0..], but this only saves repeating "VM.unsafeWrite mv" ten times. You still have to write out "toJSON" eleven times, because they're all different types and you can't put them in the same list.
14:37:47 <a_h> how can i force yyy to fail there?
14:38:11 <monochrom> No, yyy is meant to force a success because it's for "sADFefeffe".
14:38:58 <a_h> oh yeah i see
14:39:08 <monochrom> Instead, xxx is the one that either succeeds with "Just ???" or gives a user-friendly parser error message.
14:39:22 <a_h> i think, precedence is read as ((string "foo " >> xxx) <|> yyy)
14:39:28 <monochrom> yyy slurps up a long string and then succeeds with "Nothing"
14:39:36 <a_h> problem is yyy is currently too general
14:39:54 <a_h> i want to exclude any (string "foo") prefix from yyy
14:40:07 <monochrom> Yes it's ((string "foo " >> xxx) <|> yyy) that I meant.
14:40:23 <monochrom> Oh the beauty is that yyy will never get to see "foo".
14:40:51 <a_h> how so, if xxx doesn't parse, doesn't that go to yyy?
14:40:55 <monochrom> NO
14:41:39 <a_h> hm because what you describe looks like what i have now
14:42:08 <monochrom> In "(p >> q) <|> r", if p succeeds and consumes input, then <|> says it will forget about r altogether.
14:42:35 <a_h> r goes to Nothing right?
14:42:48 <monochrom> This is done to kill backtracking for a gain in efficiency.
14:43:08 <monochrom> Yes for your case. Why?
14:43:36 <a_h> consider the 3 cases
14:43:57 <monochrom> Considered.
14:44:26 <a_h> foo [valid] -> do something with it
14:44:37 <monochrom> Yes.
14:44:37 <a_h> garbage -> Nothing - skip it
14:44:42 <monochrom> Yes too.
14:45:07 <a_h> foo [invalid] -> a_h looks at the error message and line number to modify the parser
14:45:14 <a_h> until it becomes valid
14:45:58 <monochrom> Well I don't know how to code a_h into a Haskell program but I know how q can give an error message.
14:46:04 <a_h> anything with foo ZZZ should parse, if it doesn't it means i have to add conditions to the parser
14:46:26 <monochrom> OK look, have you finished reading my sentence carefully: <monochrom> In "(p >> q) <|> r", if p succeeds and consumes input, then <|> says it will forget about r altogether.
14:47:29 <a_h> maybe i don't understand - if p succeeds but q fails, then what?
14:47:43 <monochrom> The whole thing fails too.
14:47:55 <monochrom> Do you not see "then <|> says it will forget about r altogether."
14:48:12 <a_h> i see
14:48:47 <a_h> but that doesn't seem to be what the parser is does in practice though
14:49:25 <a_h> even though i think that's how it's written, it doesn't "forget about" r
14:49:43 <a_h> since p >> q is not satisfied, it falls back to r
14:50:14 <hexagoxel> a_h: for this example or in general? because you omitted the "and consumes input" part when rephrasing.
14:51:57 <monochrom> You've got to read the doc for "try" to see an example of what I said.
14:52:40 <monochrom> Incidentally it also means maybe my (string "foo") has a bug and it is better off as (try "fo" >> char 'o')
14:53:40 <monochrom> Oh haha it also says (string "foo") now has an implicit try. No wonder.
14:53:43 <hexagoxel> i don't think so. if it succeeds, it succeeds. implicit try or not.
14:54:32 <hexagoxel> ah, you meant without the implicit try. yeah, then it wouldn't be correct :)
14:54:57 <trepanger> channel diagrams
14:55:16 <trepanger> channel #diagrams
14:55:25 <a_h> reading about try...
14:56:19 <a_h> does that mean i want to match string "foo" without the implicit try somehow?
14:56:35 <monochrom> But anyway (string "fo" >> char 'o') is a much better idea than (string "foo")
14:57:08 <monochrom> It says whether you add try or not, it still behaves as having try.
14:57:21 <monochrom> string x = try (string x)
14:57:26 <a_h> is try what causes it to go to r if it fails?
14:57:30 <monochrom> Yes.
14:57:50 <a_h> and so char 'o' doesn't have a try so it doesn't backtrack is that what you mean?
14:58:03 <monochrom> Yes.
14:58:17 <hexagoxel> .oO mapM char "foo"
14:58:26 <monochrom> I love how they emphasize "this feature does not affect performance"
14:58:34 <a_h> looks kind of ugly though to do string "fo" >> char 'o'
14:58:44 <a_h> is there a no-try string equivalent maybe?
14:58:52 <madknight> whats the currently recommended way to make a https post request to an api with haskell?
14:59:16 <monochrom> hexagoxel: Well there is this problem when the input looks like "fo@#$#%$#%" you want to call it "this doesn't have the prefix foo"
14:59:58 <hexagoxel> and without try, p failed while consuming input, so r is ignored.
15:00:09 <hexagoxel> seems you want try
15:00:12 <a_h> madknight servant perhaps?
15:01:04 <hexagoxel> am i confused?
15:01:18 <monochrom> Yes. :)
15:01:24 <monochrom> The specification is this:
15:01:45 <monochrom> If the input goes like "foo [good stuff]", return (Just something)
15:01:57 <monochrom> If the input goes like "foo [bad stuff]", error out
15:02:03 <monochrom> Else, return Nothing
15:03:24 <hexagoxel> so, "fo@)(/!"§)" -> return Nothing
15:03:43 <a_h> exactly
15:03:49 <madknight> a_h, seems to be a bit "enterpisy", with curl its a one-liner, looking for something very concise
15:04:07 <hexagoxel> and r == return Nothing, right?
15:04:51 <monochrom> Half. r should consume one line worth of input or something first. Then return Nothing.
15:05:19 <a_h> madknight you want a one-liner haskell program? servant could probably do it in 10-ish lines ... have you tried it before?
15:05:41 <a_h> yeah
15:06:29 <madknight> a_h, no it don't have to be exactly one line, but it shouldn't be lets say 20 for simple https post ...
15:07:01 <madknight> a_h, i tried wreq but somehow there seems to be a different with the post mechanism that i dont understand, get works fine for me
15:07:16 <hexagoxel> so on "fo@@@@" we want r to apply.
15:07:30 <hexagoxel> if i am the confused one, i am as confused as before.
15:09:11 <a_h> hmm, maybe it's been working all along and the problem is parseFile
15:09:20 <iqubic> Are there any Haskell curl libs?
15:09:49 <a_h> just tried parseTest on my parser and it fails with the prefix (with location specified)
15:10:07 <Welkin> there are tons of http clients
15:10:09 <a_h> parseFile doesn't seem to though, this is weird.
15:10:18 <iqubic> How does curl work?
15:10:19 <Welkin> if you mean bindings to curl directly, no idea
15:10:25 <Welkin> it is a command-line http client
15:10:55 <a_h> I mean parseFromFile, not parseFile
15:11:01 <erisco> http://hackage.haskell.org/package/signal supports xplatform signal *handling* but can't processes also send signals to other processes? is that possibly xplatform?
15:12:29 <a_h> madknight give servant a try, i think it's doable in <5 LOC if you don't count imports/extensions :p
15:13:09 <madknight> iqubic, well i could spawn a curl process and read the output :)
15:13:30 <Welkin> that would suck
15:13:35 <erisco> seems windows doesn't have signals in the same way
15:13:37 <Welkin> we have tons of great http clients in haskell
15:15:46 <madknight> a_h, well if i can find a example where someone made a servant https post then yes, thats such a common task, it would be overkill to dive into the servant docs for that
15:18:57 <Welkin> servant-client is for defining an interface to an http api
15:19:07 <Welkin> not for just making an http request
15:19:58 <Welkin> you can also check out wreq http://hackage.haskell.org/package/wreq
15:20:07 <madknight> curl --data 'post "api" (200 OK) vs post "api" (toJSON (T.unpack "post")) (500 Internal Server Error)
15:22:22 <madknight> thats with wreq
15:22:42 <rotaerk> I made a thing:  http://lpaste.net/358656
15:23:20 <rotaerk> not sure how useful it'll turn out...
15:24:24 <rotaerk> and not sure if there already existts something akin to it; was just tinkering to try to find a solution for a problem I'm having
15:27:02 <rotaerk> the idea is:  a data structure that's actually sequence of values, and any prefix of that sequence is also valid (albeit a different type)
15:27:28 <rotaerk> and what type must come next is determined by the preceding subsequence
15:27:58 <Welkin> so a heterogeneous list?
15:28:33 <c_wraith> sounds more like a type-threaded list
15:29:24 <rotaerk> not just a heterogenous list; not familiar with the term "type-threaded list" though
15:30:33 <Cale> @hackage thrist
15:30:33 <lambdabot> http://hackage.haskell.org/package/thrist
15:30:33 <johnw> the base case uses the tag to form the type of its argument
15:30:58 <rotaerk> I *was* having data structures like...  data ClientEventTag f a where { TFromSession :: f (SessionName, f (SessionEventTag f a)) }
15:31:10 <rotaerk> which allowed me to put either Identity or Maybe into the f
15:31:32 <rotaerk> and thus I could have a *complete* client event, or a partial one (but strictly prefix of an event)
15:31:48 <c_wraith> rotaerk: oh hey.  that package Cale linked to.  That's what I meant.  Is it in any way similar?
15:31:51 <rotaerk> but I don't like having to explicitly interject all those fs when defining my data structure
15:31:57 <rotaerk> hmm lemme check
15:35:10 <johnw> c_wraith: it is, except for the addition to the base case
15:39:21 <rotaerk> thanks for the link, Cale; will take me a bit to understand it though
15:39:41 <Cale> rotaerk: no problem
15:49:28 <rotaerk> think I understand how it works now; I think what Thrist doesn't do for me is allow me to specify ALL the subsequent types in one signature for a given tag
15:50:06 <rotaerk> whereas with mine, I was able to do:  TConnecting :: SessionEventTag (HostName, (PortNumber, ())
15:50:20 <Welkin> what is a "tag" here?
15:50:29 <rotaerk> it's akin to the tags in dependent sums
15:51:05 <Welkin> what is a tag in dependent sums?
15:51:11 <Welkin> what is a dependent sum?
15:51:59 <rotaerk> check the examples here:  https://hackage.haskell.org/package/dependent-sum-0.4/docs/Data-Dependent-Sum.html#v::-61--62-
15:52:11 <johnw> Welkin: a pair where the type of the second component depends on the value of the first
15:52:44 <Welkin> isn't that a product?
15:52:48 <Welkin> a tuple
15:52:55 <johnw> tuple are non-dependent
15:53:39 <rotaerk> Welkin, think of the types of the values in the second component as being summed, and the tag allows you to discriminate between them
15:53:42 <johnw> now, I'm thinking of sigma types here
15:53:49 <johnw> I really don't understand why they're called dependent sums
15:54:44 <rotaerk> simple ADTs can be thought of as sum types, and the constructors can be thought of as tags for discriminating between the types being summed
15:55:50 <Welkin> so it is a generalization of Either
15:56:15 <rotaerk> ADTs could be thought of as a generalizattion of Either I guess
15:56:39 <rotaerk> DSum vs ADT though... allows you to have the tags separate from the attached values
15:58:10 <rotaerk> in this:  data Foo = Bar String | Baz Int   there's not really a type to store either Bar or Baz into; you have to fully apply them to get a common type (i.e. Foo)
15:59:07 <rotaerk> but you can alternatively represent that with:  data FooTag a where { Bar :: FooTag String; Baz :: FooTag Int };  type Foo = DSum FooTag Identity
15:59:26 <rotaerk> so now you can have a value representing Bar or Baz themselves, independent of the string/int that's attached to them
15:59:58 <rotaerk> you can even use them in different ways, such as DSum FooTag []
16:00:18 <rotaerk> to produce something like:  data Foo = Bar [String] | Baz [Int]
16:00:32 <rotaerk> or DSum FooTag Maybe, to produce data Foo = Bar (Maybe String) | Baz (Maybe Int)
16:02:21 <rotaerk> or DSum FooTag (Const Int)  to produce data Foo = Bar Int | Baz Int
16:02:39 <rotaerk> (I guess if for some reason you wanted to, say, count the number of instances of a given constructor)
16:04:44 <rotaerk> Welkin, make sense?
16:04:53 <Welkin> rotaerk: I'm trying to understand it still
16:05:02 <Welkin> I don't get FooTag
16:05:10 <rotaerk> do you know GADT syntax?
16:05:17 <rotaerk> the a in Footag a is just a phantom type
16:05:22 <Welkin> I can read it yes
16:05:30 <rotaerk> and the specific constructors can fill in whatever they want to that
16:05:59 <rotaerk> Bar doesn't have a String in it, but its type *indicates* a String
16:06:00 <Welkin> actually, I guess it is DSum that I don't get
16:08:05 <rotaerk> Welkin, ignoring the constructor, in case the operator identifire for it throws you off (it does for me sometimes...)..  given a (tag :: * -> *) and some (f :: * -> *), a DSum is just a pair:  (tag a, f a)
16:08:31 <rotaerk> so if you fill Bar into the first component (i.e. its type was defined as FooTag String)
16:08:40 <rotaerk> then the a in (tag a, f a) becomes String
16:08:44 <rotaerk> so (Bar, f String)
16:09:04 <rotaerk> so now you can put some f String in there, say... Identity String
16:09:09 <rotaerk> (Bar, Identity "hi")
16:09:25 <rotaerk> but using the actual constructor:  Bar :=> Identity "hi"  :: DSum FooTag Identity
16:09:58 <rotaerk> Bar :=> Nothing   :: DSum FooTag Maybe
16:10:45 <rotaerk> bbiab
16:11:32 <rotaerk> <rotaerk> so (Bar, f String)     I should've said:  (FooTag String, f String)
16:11:41 <rotaerk> the value of that FooTag String is just called Bar
16:20:32 <tabemann> http://lpaste.net/358658
16:20:55 <tabemann> I just installed leksah, and suddenly my haskell code using gi-gtk refuses to compile
16:21:04 <tabemann> with the above error message
16:22:57 <hamishmack> tabemann: Are you using stack or cabal new-build?
16:23:15 <tabemann> I just used plain cabal build
16:24:01 <hamishmack> The overloading feature of haskell-gi makes compile times very slow so leksah turns it off
16:24:04 <tabemann> I'm now trying again with new-build
16:24:13 <tabemann> ah
16:24:17 <tabemann> how do I turn it back on?
16:24:28 <hamishmack> If you use cabal new-build it should keep the setting sepparate
16:25:15 <hamishmack> If you add build-depends: haskell-gi-overloading >= 1.0 
16:25:20 <hamishmack> to your cabal file
16:25:57 <hamishmack> it should make sure overloading is on for your project
16:26:49 <tabemann> thanks
16:27:17 <hamishmack> Keep in mind though that GHC is a lot slower when it is on.  So if you find your project takes a long time to rebuild you might want to consider turning it off.
16:27:59 <hamishmack> and using windowTitle instead of #title in your code
16:28:22 <tabemann> I'll do that
16:28:30 <hamishmack> To turn it off just use build-depends: haskell-gi-overloading < 1.0
16:47:33 <tabemann> okay, I have a minor problem
16:47:54 <tabemann> cabal new-build isn't seeing my code changes
16:50:20 <freeman42y> is there any cloud computing platform (Azure, Google, Amazon, etc.) that is more suited for Haskell?
16:50:42 <Welkin> any of them
16:51:05 <Welkin> you can install haskell on any server, but you genrally don't
16:51:15 <Welkin> instead, you'll compile locally and then push the binaries
16:52:03 <tabemann> Haskell is a general-purpose programming language, and supports Linux, Windows, and macOS
16:52:31 <tabemann> the only problem is if you want to use an OS other than those, or an processor arch other than x86, x86-64, or ARM
16:52:48 <Welkin> maybe freeman42y wants to run TempleOS
16:53:05 <Welkin> on a MIPS
16:53:18 <logan0405> why can't I do this? [ x+y | x <- [1..10] | y <- [1..10] ] "Unexpected parallel statement"
16:53:31 <Welkin> replace the second | with a ,
16:54:10 <tabemann> do you have any idea as to why cabal new-build wouldn't see source code changes?
16:54:23 <Welkin> I haven't used it yet
16:54:31 <logan0405> thank you, though now it spits out a list of length 100. i expected it to add each element of this list. what did it do to make a 100 length list?
16:54:47 <Welkin> logan0405: the Monad instance for List
16:55:02 <Welkin> you are constructing a cartesian product of the lists
16:55:07 <Welkin> 10 * 10 = 100
16:55:21 <Welkin> if you want to zip the ists together, use zipWith
16:55:22 <freeman42y> Welkin, tabemann all of them can run Haskell obviously lol. But is any of them more suitable for Haskell usage? Do any of them come with some pre-baked Haskell-related capabilities?
16:55:50 <Welkin> > zipWith (+) [1..10] [1..10] -- logan0405 
16:55:53 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
16:57:08 <tabemann> freeman42y: the Haskell environment does actually have pretty decent Windows support, since it was developed partially at Microsoft (surprise surprise), but a lot of the developers working with Haskell use Linux, so their code may be more biased towards Linux
16:57:13 <logan0405> got it, i figured that out. thought there was a way to do it with comprehensions. why does x+y create a 'cartesian product' in that comprehension but [1..10]+[1..10] doesn't?
16:57:38 <tabemann> a cartesian product is a vector operation on two different vectors
16:57:41 <Welkin> logan0405: list comprehensions are syntactic sugar for monadic bind
16:57:48 <tabemann> what you want is just what Welkin said
16:57:53 <Welkin> so it is using =<< underneath
16:58:01 <logan0405> okay. still got a lot to learn. thanks guys
16:58:04 <freeman42y> tabemann, I am aware of that and wish to deploy on Linux, what I am wondering is if any compute platform is better for Haskell because of Haskell specific features it might have
16:58:59 <tabemann> not really
16:59:13 <tabemann> Linux probably has better support for things like windowing toolkits
16:59:17 <madknight> okay got it, damn that was not so easy in the end i use a "Data.ByteString.Lazy" as post input, explicitly disabled url encode and manually build the request with Network.HTTP.Conduit
16:59:23 <tabemann> but from what you describe that isn't an issue
16:59:40 <tabemann> because "compute platforms" do not really imply that support for GUI toolkits is an issue
16:59:55 <Welkin> madknight: conduit is... overkill
16:59:59 <Welkin> that is a streaming library
17:00:21 <Welkin> just using wreq would that been far simpler
17:00:40 <Welkin> or, if you know the api you want to interact with, write bindings to it using servant-client
17:00:49 <Welkin> I did that to write bindings to many third-party apis
17:00:56 <madknight> Welkin, well, its less overkill than servant and wreq seems to miss options or atleast i dont know how to set them in wreq
17:01:36 <Welkin> if you use servant, you can send a http request by applying what looks like a normal function
17:01:43 <Welkin> after youo define the bindings
17:04:35 <madknight> Welkin, according to github source servant seems to be the bigger beast compared to conduit
17:04:50 <Welkin> ?
17:11:08 <madknight> "?" could be considered as the empty question and can only correctly be answered with the empty answer, fun, conduit works i think thats okay for now
17:11:27 <iqubic> Welkin: ()
17:14:45 <logan0405> > show [1..]
17:14:47 <lambdabot>  "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:14:54 <logan0405> haha
17:15:23 <tinytusk> Is there a very concise way of writing this function?: http://lpaste.net/8322136955823325184
17:15:36 <tinytusk> I'm searching for a one-liner.
17:16:43 <Welkin> tinytusk: sure, just put it all on one line
17:16:56 <hydraz>  replace layout for {;} and you got yourself a one liner :p
17:17:04 <Welkin> you can disable the whitespace syntax using { ...; ... }
17:17:11 <hydraz> :t maybe
17:17:12 <lambdabot> b -> (a -> b) -> Maybe a -> b
17:17:14 <mibaz_1> Trying to figure Servant out, but I can't get this to work: http://lpaste.net/358660 If anyone has a second I'd be grateful for help
17:17:22 <hydraz> tinytusk: would `maybe` be applicable?
17:17:55 <Welkin> tinytusk: you are doing what `fmap` can do for you
17:18:37 <Welkin> :t mapM
17:18:39 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
17:18:57 <madknight> tinytusk, https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Maybe.html#v:fromMaybe
17:19:49 <tinytusk> Thanks all!
17:20:02 <a_h> hello
17:20:13 <zachk> hi 
17:27:40 <a_h> anyone working on an interesting project?
17:32:20 <pacak> I am.
17:32:53 <iqubic> pacak: what is it?
17:33:44 <pacak> Trying to reconstruct exact thread scheduler state at any point of time in ghc runtime from generated eventlog.
17:33:54 <iqubic> a_h: do you count configuring a new gentoo install?
17:34:15 <Welkin> no
17:34:23 <Welkin> configuring a new linux install is just time wasted
17:34:32 <iqubic> Welkin: why?
17:34:50 <Welkin> unless you find it therapeutic
17:34:55 <WinterFox[m]> Does anyone know what I did wrong here? https://bpaste.net/show/9377272ffade
17:35:13 <Welkin> WinterFox[m]: you used bpaste
17:35:56 <Welkin> WinterFox[m]: you can't cons a list onto something
17:36:24 <Welkin> line 5 should be `x1*x2 : adj xs`
17:36:25 <WinterFox[m]> ?
17:36:31 <WinterFox[m]> Oh
17:36:33 <pacak> WinterFox[m]: x2 on line 4 is a list, not an int.
17:36:46 <Welkin> that too
17:37:49 <WinterFox[m]> Ah
17:38:07 <WinterFox[m]> It should be (x1:x2:[]) I think.
17:38:28 <Welkin> you could also write [x1, x2]
17:39:12 <Welkin> you could eliminate one case too
17:39:49 <Welkin> `adj xs = fmap (*) xs`
17:40:00 <Welkin> put that after your line where you match on (x1:x2:xs)
17:40:05 <Welkin> the nyou can remove the other lines
17:40:12 <Welkin> er
17:40:14 <Welkin> not fmap
17:41:23 <Welkin> :t pure . foldr1 (*)
17:41:25 <lambdabot> (Num a, Foldable t, Applicative f) => t a -> f a
17:42:00 <Welkin> > pure 3 :: [Int]
17:42:02 <lambdabot>  [3]
17:42:06 <Welkin> > pure . foldr1 (*) [] :: [Int]
17:42:09 <lambdabot>  error:
17:42:09 <lambdabot>      • Couldn't match expected type ‘[Int]’
17:42:09 <lambdabot>                    with actual type ‘a0 -> f0 a1’
17:42:29 <Welkin> > (pure . foldr1 (*)) [] :: [Int]
17:42:32 <lambdabot>  [*Exception: Prelude.foldr1: empty list
17:42:35 <Welkin> lol
17:42:45 <Welkin> > (pure .  product) [] :: [Int]
17:42:48 <lambdabot>  [1]
17:42:52 <Welkin> what!
17:43:06 <Welkin> eh, whatever
17:43:52 <Welkin> maybe it won't be worth it then :P
17:43:58 <Welkin> too many little details to take care of
17:44:04 <Welkin> it will be simpler to keep 3 lines
17:45:17 <hydraz> @src product
17:45:17 <lambdabot> product = foldl (*) 1
17:46:11 <Welkin> yeah
17:46:17 <Welkin> makes sense
17:47:03 <Welkin> oh wait... WinterFox[m] you can get rid of the second line anyway
17:47:11 <Welkin> because your 3rd and 1st line take care of it
17:47:52 <Welkin> `x1 * x2 : adj xs` when `xs` is an empty list, will be the same as [x1 * x2]
18:32:02 <a_h> is there a good tutorial on Storable somewhere?
18:44:15 <ezyang> What is it called when you take Functor f => f a, and turn it into [a] and f ()? 
18:44:30 <ezyang> (also, you can't do it for all functors; what's the correct condition?) 
18:44:47 <geekosaur> specialization?
18:45:03 <ezyang> Intuitively, I want to split the values from the structure holding them 
18:45:11 <ezyang> geekosaur: I don't... think so? 
18:45:49 <iqubic> ezyang: so you want to go from f a -> a?
18:45:55 <ezyang> iqubic: Not quite 
18:46:03 <ezyang> so, some functors are basically data structures with holes in them (for a) 
18:46:11 <ezyang> so I want to get my hands on the *structure*, without the values 
18:46:19 <iqubic> Give me an an example?
18:46:35 <isd> Hey all. Is there a way to get hlint's --report option not to skip report generation, even when there are no suggestions?
18:46:48 <ezyang> sure 
18:47:13 <ezyang> iqubic: So, suppose you have 'Just 3'. Then, the "Structure" is 'Just HOLE', and the value(s) (one in this case) is 3 
18:47:33 <iqubic> How does that help you?
18:48:10 <ezyang> iqubic: Well, for example, this way, I could test if two "structures" are the same, without saying anything about the values themselves 
18:48:37 <iqubic> Just use pattern matching in that case.
18:49:40 <ezyang> Well, I need it to work for arbitrary Functor (or subset of Functors; I don't think 'Functor' is enough) 
18:50:12 <iqubic> ezyang: but it looks like you want f a -> (a -> f a)
18:50:27 <iqubic> You'd have to write the function yourself
18:50:52 <ezyang> I don't think that's the function I want? 
18:51:10 <ezyang> so, it's pretty easy with just plain Functor to get the "structure" (sort of) 
18:51:20 <ezyang> getStructure :: Functor f => f a -> f () 
18:51:25 <ezyang> getStructure = fmap (const ()) 
18:51:44 <iqubic> Why not just use that then?
18:52:14 <ezyang> but now I've lost all the values! 
18:54:19 <iqubic> No, you haven't. You still have access to the variable that held the functor before the fmap was done.
18:56:51 <ezyang> Sure, in a "programming" sense, I haven't lost it. 
18:57:42 <ezyang> but it is not very satisfying. I'm looking for an f :: f a -> (Structure f, Values a), where there is also an inverse g :: (Structure f, Values a) -> f a 
18:58:04 <ezyang> If, as you suggest, I simply say type Values a = f a (well, I don't even have enough type parameters haha) 
18:58:06 <iqubic> You may have to write that yourself.
18:58:58 <iqubic>  I don't think those exist.
18:59:02 <ezyang> then the identities don't hold (intuitively, you have too much information) 
18:59:25 <iqubic> Also, for some functors, like Either, the result is a bit weird.
18:59:52 <ezyang> that's OK 
19:00:00 <d34df00d> Hi!
19:00:01 <ezyang> Right x ===> (Right (), [x]) 
19:00:09 <ezyang> Left e ===> (Left e, []) 
19:00:13 <ezyang> no "value" in the Left case 
19:00:18 <iqubic> @src never
19:00:18 <lambdabot> Source not found. :(
19:00:37 <Welkin> iqubic: @source is a lie
19:00:48 <d34df00d> I'm digging into some third-party cabal-only project (Hashtables) for the first time in my life, and I'm having trouble building its tests. Long story short:
19:00:52 <Welkin> it's just a key-value store of text
19:00:54 <d34df00d> http://bpaste.net/show/0dc44c5ba49f
19:00:55 <Welkin> hardcoded
19:00:57 <d34df00d> What's the right fix?
19:01:33 <iqubic> Anyone have the implementation of the never function talked about yesterday.
19:01:45 <iqubic> It was defined with @let never
19:01:54 <ezyang> d34df00d: HAve you run 'cabal update' recently? 
19:02:04 <d34df00d> ezyang: just before that one.
19:02:15 <ezyang> iqubic: What's the type signature 
19:02:20 <geekosaur> 2017 Sep 22 17:01:30 <Tuplanolla>	@let never = case do not otherwise of such -> let in when such
19:03:09 <ezyang> d34df00d: I think this is one of those cases where building the test suite for hashtable might be difficult because the test deps depend on hashtable itself 
19:03:18 <ezyang> If you use Stack, I think it should work out of the box 
19:03:33 <d34df00d> No stack.yaml in that repo :(
19:04:15 <ezyang> ok, so I think the way to do it 
19:04:21 <ezyang> is manually install all of the test suite deps 
19:04:33 <ezyang> and then run cabal configure -ftest, and then it should work 
19:05:13 <d34df00d> ezyang: yeah, I thought about that option, but I was afraid that's terribly wrong. Thanks!
19:05:48 <a_h> ezyang i'm reading your 6 part c2hs series right now...
19:06:32 <d34df00d> BTW do you folks think another integer set library, but just a wrapper on top of some C or C++ implementation with freeze/unfreeze support, might be useful?
19:06:53 <ezyang> a_h: Hope it is not too out of date at this point! :) 
19:06:54 <d34df00d> Some stuff of mine is limited by Data.IntSet performance, and I wonder whether others might be interested.
19:07:32 <a_h> ezyang all i wanted to do was pass some structs back and forth and now i'm reading a book :p
19:08:13 <ezyang> d34df00d: There will always exist someone who is interested :) But for C bindings, the bar for correctness is much, much higher 
19:08:14 <a_h> I kid I kid, i'm glad it exists but man somehow this happens everytime I try to write a little haskell ...
19:08:27 <ezyang> a_h: Well, you could always do it manually, and skip reading the book :) 
19:08:34 <d34df00d> Sure, that's to be expected.
19:09:04 <a_h> I'm kind of going back and forth TBH, references on Storable are kind of scattered
19:09:45 <a_h> look at this beautiful documentation https://wiki.haskell.org/FFI_cook_book
19:10:37 <a_h> "(Shouldn't that be "... else peek ptr?) (yes, it should. Fixed)" ... "Please check me"
19:13:47 <Welkin> what's with the c ffi and playing peek-a-boo?
19:14:00 <a_h> sort of thing that kills me a little... we're never going to win over more python users in my lifetime at this rate.
19:14:26 <a_h> if only more docs were as good as yours
19:14:31 <Welkin> I came to haskell from python several years ago
19:14:31 <Welkin> o.o
19:14:48 <Welkin> everything about python sucks compared to haskell
19:15:03 <Welkin> the language, the libraries, the tooling, the community, the documentation
19:15:07 <d34df00d> Except for popularity.
19:15:16 <a_h> the documentation? did you see that page?
19:15:21 <d34df00d> I'm probably gonna be forced to rewrite a project of mine from haskell in some other more popular languages.
19:15:25 <Welkin> popular things usually suck
19:15:25 <d34df00d> :'-(
19:15:35 <a_h> "please check me" what the hell?
19:15:41 <Welkin> a_h: python tends to have no documentation...
19:15:51 <a_h> can you imagine showing that to your python colleague and trying to convince them to switch?
19:15:51 <isd> Python is really hit-or-miss on docs
19:15:59 <isd> there's some really good stuff out there and some really bad stuff.
19:16:05 <Welkin> I don't jave python colleagues
19:16:20 <a_h> on the whole, orders of magnitude more good than haskell's good
19:16:27 <d34df00d> Re documentation, this one is marvellous (and I also love the naming conventions!): https://hackage.haskell.org/package/gnuplot
19:16:31 <d34df00d> Every data type is `data T`
19:16:37 <a_h> unfortunately it's the total amount that matters the way the market works
19:17:14 <Welkin> total amount of what?
19:17:15 <geekosaur> ...and every class is C? welcome to Henningskell
19:17:42 <a_h> Welkin the total amount of well-documented libraries
19:18:01 <a_h> it doesn't matter that 90% of python code / docs is amateur hour
19:18:21 <d34df00d> I also "loved" takusen, seems like only the library developer-relevant parts are documented.
19:18:25 <a_h> when the 10% of well documented stuff is 1000x more documentation than haskell has
19:18:26 <d34df00d> And it segfaulted :(
19:19:13 <a_h> anyway /rant for me ... are there good docs on Storable somewhere?
19:19:40 <pacak> a_h: What's wrong with current docs?
19:19:58 <d34df00d> Wonder if hashtables tests are even run by the author... They don't even compile.
19:20:06 <a_h> pacak the docs are okay, but i could use some more detailed examples/tutorials
19:20:37 <a_h> the hackage docs are good if you already know what you're doing
19:21:49 <Welkin> tutorials are one area where haskell could improve
19:21:59 <Welkin> it has been getting better over the last few years
19:22:33 <Welkin> gabriel's pipes library is a really good example
19:24:05 <sm> I've heard that good docs consist of a guide, reference, how-tos, and general topic discussions
19:25:01 <a_h> i think the trick really is that the relevant metric is the total amount of quality docs, which is unfortunately closely tied to # people available to do them
19:25:19 <a_h> pipes docs are great
19:25:42 <sm> it's also related to the available tools and prevailing norms in the community
19:25:50 <sm> the racketeers seem to have the best tools for building docs
19:26:08 <a_h> true hackage is pretty dated
19:26:27 <Welkin> purescript docs are nice
19:26:31 <Welkin> on pursuit
19:26:45 <Welkin> I think hackage is great though
19:26:46 <a_h> eta docs are a thing to behold... but there's 1 doc right now.
19:26:51 <Welkin> it may look dated, but it works
19:26:57 <a_h> hackage could be so much better
19:27:19 <Welkin> functionality is better than something that looks pretty but sucks to use
19:28:34 <a_h> sure but that's not the choice, could be pretty and great to use. right now it looks pretty bad and is only so-so to use.
19:29:35 <Welkin> I don't think it looks bad at all
19:29:40 <Welkin> I have seen this too many times before
19:30:07 <a_h> apparently there have been attempts to overhaul it but with resistance
19:30:11 <Welkin> something that looks fine and works great is "redesigned" so that it "looks nice" and then it makes you want to rip your hair out because it doesn't work any more
19:30:12 <a_h> anyway, that's not my fight
19:30:36 <a_h> yeah but why the dichotomy?
19:30:43 <a_h> i'm saying it shoudl work better than it does not worse
19:31:32 <ongy> what feature ar eyou missing from hackage?
19:34:09 <a_h> it's less the feature count, more rethinking the usability. I don't know what optimal looks like, but there could be better navigation, perhaps more structured organization for things like tutorials
19:34:20 <a_h> which are now scattered throughout modules haphazardly
19:34:25 <Welkin> it is for docs, not tutorials
19:34:34 <a_h> maybe hoogle could be better integrated
19:34:37 <Welkin> they are not the same thing
19:35:05 <a_h> or examples at least, if not tutorials. the line gets pretty blurry from the hackage pages i've read.
19:36:02 <a_h> anyway, i'm not sure why i'm arguing about this. like i said, it's not my fight beyond that I want to see haskell succeed and I think it has a long way to go.
19:37:20 <Welkin> haskell has already succeeded beyond the original creators wildest beliefs
19:37:53 <Welkin> success for haskell is not the same as success for javascript
19:37:59 <Welkin> they have different goals
19:38:44 <Welkin> maximizing the number of users is not and has never been a goal of haskell, which is why it has been so successful with the people who use it
19:39:21 <mibaz_1> Figured out my issue, was using old Servant tutorial before they switched to exceptT. The old one is first result
19:40:50 <a_h> where you see success, i see unrealized potential. potential for more programmers to _get_ to use haskell, more jobs so people to not be relegated to weekend/grad student haskell programming. i don't think we're going to get to an agreement, but that's ok.
19:41:29 <Welkin> mibaz_1: yeah, that would be a problem
19:41:52 <Welkin> the old website is still around, which is weird
19:44:43 <ackpacket> I don't suppose there is a way to compare if one data structure is the same (not a copy) of another?
19:45:24 <geekosaur> there is, but it is as reallyUnsafe as its name implies
19:45:37 <ackpacket> =\
19:46:03 <mibaz_1> Welkin: Yeah, that should definitely be removed so people like me don't see it
19:46:06 <geekosaur> because garbage collection + laziness means things can move in mid-comparison
19:46:35 <Myrl-saki> How is IO compiled?
19:47:03 <Myrl-saki> I heard Purescript uses FFI for IO, but I still don't quite get how that becomes executable.
19:48:16 <ackpacket> I guess what I'm driving at is, what if I'm trying to compare two *large* lists.  I know there is a possiblity I am comparing the same list (literally, the same variable, in the same memory space) and in those instances wouldn't it be wasteful to bother compare each and every element between the two
20:32:51 <iqubic> How does on install ghc through stack. I want to avoid the gentoo Haskell ecosystem as much as possible.
20:32:59 <Myrl-saki> iqubic: stack setup
20:33:03 <Myrl-saki> or something.
20:33:32 <monochrom> You probably want to read the Stack manual.
20:33:44 <Myrl-saki> monochrom: That too.
20:33:46 <Myrl-saki> :P
20:35:43 <Welkin> stack install --install-ghc
20:38:12 <Myrl-saki> Welkin: Is that legit?
20:38:26 <Welkin> yes
20:38:35 <Myrl-saki> Mkay.
20:38:39 <kadoban> Kinda sorta. Most commands that need GHC take --install-ghc which means "install GHC if you have to". 'stack install' usually does other stuff as well.
20:38:44 <Welkin> there are mutliple ways to do it though
20:38:49 <Myrl-saki> Oh.
20:38:55 <monochrom> There is a guy who blogged why they quit stackoverflow despite scoring a lot of points there. One point is that stackoverflow is now encouraging people to ask shallower and shallower questions and answerers actually bite.
20:39:12 <Myrl-saki> Welkin: No wonder `stack install` doesn't list --install-ghc.
20:39:13 <Welkin> who is "they"?
20:39:14 <Myrl-saki> kadoban: *
20:39:35 <monochrom> The guy who blogged that.
20:39:49 <Welkin> who are you talking about?
20:40:02 <monochrom> I forgot the url so I can't show you.
20:40:15 <monochrom> Anyway I agree with that sentiment.
20:40:28 <Myrl-saki> monochrom: I'll be honest, it's because most answerers are not exactly good either.
20:40:38 <Myrl-saki> monochrom: Such as, well, me.
20:40:42 <Welkin> I often find that the _real_ best answer is second or third
20:40:48 <Welkin> not the one that is marked "best answer"
20:41:09 <rotaerk> the real best answer often has the most votes though
20:41:20 <kadoban> Well, the one choosing the "best answer" is the person asking the question, right? Which usually means they have no idea wtf they're talking about, or they wouldn't be asking the question. So that's pretty much guaranteed.
20:41:42 <Myrl-saki> kadoban: lmao
