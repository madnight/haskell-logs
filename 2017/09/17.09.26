00:01:45 * hackagebot fast-mult 0.1.0.2 – Numeric type with asymptotically faster multiplications. – https://hackage.haskell.org/package/fast-mult
00:03:50 <jvliwanag> in aeson, how do i convert a `Parser a` to `Either String a`?
00:04:18 <vaibhavsagar> jvliwanag: `parse`?
00:05:19 <vaibhavsagar> oops, `eitherDecode` sounds like what you want
00:06:38 <vaibhavsagar> or not, can you tell me more about the use case?
00:08:11 <jvliwanag> hmm. I already have some `foo :: Value -> Parser Something`. how do I change it so that I'd end up with `bar :: Value -> Either String Something`?
00:08:24 <vaibhavsagar> it's based on Attoparsec's parseOnly so you might need to use that: https://hackage.haskell.org/package/attoparsec-0.13.2.0/docs/Data-Attoparsec-ByteString.html#v:parseOnly
00:08:31 <ackpacket> In my path to learn haskell a bit better I decided to write a decision tree classifier.  One thing I noticed -- I find myself naturally writing very OOP-like code.  Data structure representing the class, getters, setters... is this common?
00:09:37 <cocreature> jvliwanag: https://hackage.haskell.org/package/aeson-1.2.2.0/docs/Data-Aeson-Types.html#v:parseEither
00:10:15 <jvliwanag> thanks cocreature!
00:21:44 <phadej> jvliwanag, ackpacket: http://hackage.haskell.org/package/aeson-1.2.2.0/docs/Data-Aeson-Types.html#v:parseEither
00:21:53 <phadej> ah, it's answered already
00:21:55 <phadej> +1
00:22:09 <Axman6> ackpacket: if you're writing lots of getters and setters, you should look into a) records and the getters and setters that gives you for free, and b) lens, which gives you much more powerful getters and setters (much more powerful than OOP programmers are used to)
00:23:42 <pacak> Axman6: I'm not sure if jumping directly to lens is a good idea for somewhole who only tries to get into haskell...
00:24:13 <Axman6> ackpacket: you might want to spend some time reading the code of some haskell projects to get an idea of how others do it (I can't think of a good example project of the top of my head however)
00:25:12 <Axman6> pacak: sure, hence the records suggestion, but it doesn't take long to run into the limitations of records
00:31:12 <maerwald> does it?
00:32:34 <ongy> nested updates with records are a pain. and that's something most poeple will find out quickly
00:34:11 <maerwald> I've only had those problems when I was over-engineering data structures
00:34:19 <maerwald> which sometimes is necessary
00:34:23 <maerwald> but I still avoid it
00:34:30 <ventonegro> Axman6: no worries
00:37:29 <ackpacket> Have been using record syntax, and oddly at some point I even found myself setting a function as one of it's fields... then it truly felt oop
00:42:14 * hackagebot tasty-discover 4.1.0 – Test discovery for the tasty framework. – https://hackage.haskell.org/package/tasty-discover
00:50:13 <maerwald> I wouldn't mind "non-idiomatic" language features that allow record updates, similar to what purescript does. But not without changing the language report
00:51:27 <opqdonut> clojure has nice utils for deep updates, but of course it's dynamic
00:51:47 <opqdonut> I guess lenses make these things expressible in haskell
00:52:21 <maerwald> without changing the core language, sure
00:52:37 <maerwald> then again, not sure, probably depends on 10+ ghc extensions :P
00:55:23 * hackagebot accelerate 1.1.1.0 – An embedded language for accelerated array processing – https://hackage.haskell.org/package/accelerate
01:02:52 <royal_screwup21> what's the difference between "type", "type definition" and "type signature"?
01:03:57 <maerwald> uh, purescript is going to remove the row type parameter from Eff?
01:05:54 <Gopinath> hello everyone!
01:06:03 <tdammers> maerwald: it was kind of silly anyway
01:06:18 <maerwald> royal_screwup21: type: Int, type definition: data Foo a = Foo a, type signature, Foo :: a -> Foo a
01:06:21 <maerwald> or something
01:06:31 <pacak> royal_screwup21: Type signature - something attached to a thing in haskell that tells what type that thing is.
01:07:01 <tdammers> a type definition defines a type. a type signature tells the compiler what the type of something should be. a type is, well, a type.
01:07:04 <pacak> royal_screwup21: type definition - you defining a specific type to be either something new or as an alias to a different type.
01:07:28 <royal_screwup21> so if I have a function foo and if I type in ":t foo on my compiler, I should be getting the type signature?
01:07:33 <pacak> royal_screwup21: type... Well... something that let's you to tell different object apart without looking at values I guess.
01:07:47 <liste> royal_screwup21: yes, the type signature of `foo'
01:07:56 <royal_screwup21> thanks folks!
01:07:58 <pacak> :t head
01:08:00 <lambdabot> [a] -> a
01:08:07 <maerwald> "type" is often used lazily for "type signature" though
01:08:08 <pacak> That was type signature for head.
01:10:31 <maerwald> mind that you don't need type signatures most of the time
01:10:43 <maerwald> so asking what the type signature is, is not the same as asking for the type
01:11:06 <pacak> But if you don't write type signatures for top level  functions ghc won't be able to warn you when you start doing something stupid.
01:12:53 <maerwald> tdammers: basically removes the last reason to really get into the language
01:14:19 <royal_screwup21> suppose I have function square x =x*x -- what would be the type definition for this? I think it's basically a -> a because we're taking in a number and returning a number
01:14:35 <maerwald> you mean the type
01:14:42 <ventonegro> royal_screwup21: You can't multiply any `a`
01:15:13 <Ferdirand> :t (\x -> x*x)
01:15:15 <lambdabot> Num a => a -> a
01:15:39 <cocreature> royal_screwup21: you’re looking for a type signature, not a type definition
01:16:21 <royal_screwup21> yeah that makes sense
01:16:32 <royal_screwup21> so the type signature is a -> a right?
01:16:45 <ventonegro> 10:14 <lambdabot> Num a => a -> a
01:17:09 <maerwald> royal_screwup21: something like: Int -> Int, the other stuff is generalization via type classes
01:17:28 <ventonegro> royal_screwup21: The only possible thing a function with type `a -> a` can do is return the argument back to you
01:18:02 <merijn> ventonegro: Or infinite loop!
01:18:11 <merijn> ventonegro: bottom ruining the day once again :)
01:18:20 <royal_screwup21> you mean type signature? (because type is things like Int, Char iirc)
01:18:41 <maerwald> a -> a is also a type
01:18:52 <cocreature> "a -> a" is also a type
01:18:57 <maerwald> :o
01:19:18 <cocreature> a type signature declares the type of a value
01:19:40 <cocreature> "name_of_value :: type" means that name_of_value has type "type"
01:20:10 <royal_screwup21> oh that clears it up!
01:21:18 <maerwald> value or binding?
01:21:39 <tdammers> maerwald: so far purescript is still the only language I know of that meets the requirements: 1) compile to JS suitable for browsers, 2) doesn't take a PhD or 20 years of sysadmin experience to get a development environment set up, 3) isn't significantly more difficult to use than Haskell
01:22:14 <maerwald> lol at 2) ;D
01:22:26 <tdammers> it's a serious practical concern
01:22:47 <maerwald> the thing is, I don't care about 1) ...I'd rather have it compile to whatever, C, for instance
01:22:58 <tdammers> like it or not, ghcjs + reflex-dom does not give you the "just npm install" experience
01:23:10 <tdammers> oh, of course, 1) is only relevant when you need to build web frontends
01:23:31 <tdammers> if you're not doing that, you're probably better off with haskell
01:23:32 <merijn> tdammers: Have you tried UHC?
01:23:41 <merijn> tdammers: AFAIK they have 2 JS backends
01:23:47 <tdammers> merijn: no, I haven't. Maybe I should check it out.
01:24:25 <merijn> tdammers: Although my knowledge of UHC is mostly "what I've managed to pickup at various NL-FP days" :p
01:24:32 <tdammers> merijn: frankly, I just assumed it was more of an academic research thing than a practical "production ready" tool
01:24:59 <maerwald> tdammers: at some point, they might as well remove IO then to make it more simpler ;)
01:25:20 <merijn> tdammers: It does Haskell2010 and a number of the more basic GHC extensions, so it's not as portable as ghcjs, but it can actually compile Haskell, unlike Haste and co
01:26:04 <cocreature> Haste compiles actual Haskell too iirc, they’re mainly missing TH
01:26:13 <tdammers> maerwald: remove IO? Purescript doesn't have an IO type. That's the whole point of Eff.
01:26:14 <merijn> tdammers: They don't have the manpower to truly compete with GHC, but it's fairly mature, given that's been around for a while
01:26:24 <merijn> cocreature: No, Haste, AFAIK compiles a subset of Haskell
01:26:25 <cocreature> fay is the one that compiles something else
01:26:33 <merijn> cocreature: That is, any Haste code is valid Haskell, but not vice versa
01:26:43 <merijn> cocreature: But I might be wrong
01:27:12 <cocreature> merijn: “Haste is based on the de facto standard GHC compiler, which means that it supports the full Haskell language, including GHC extensions and produces highly optimized code but comes with an extended set of standard libraries.” the website claims it does
01:27:30 <merijn> hmmm
01:27:38 <merijn> cocreature: My knowledge is about 2 years old, so ;)
01:27:46 <cocreature> merijn: I think you might be confusing Haste with Fay
01:28:05 <cocreature> Fay is definitely a subset of Haskell
01:28:18 <maerwald> tdammers: they will have ;)
01:28:34 <maerwald> tdammers: they are probably going to rename the Eff without row types to IO
01:29:19 <maerwald> and there is purescript-io already
01:30:20 <tdammers> purescript-io is built on top of Eff, so it doesn't really solve the row type issue
01:30:48 <tdammers> the problem with old-style Eff is that restrictions go in the wrong direction
01:30:55 <maerwald> it's a newtype for Aff
01:31:18 <tdammers> with something like Haskell's IO, you have the "anything can happen" type at the top level (main :: IO ()); and then you narrow it down to fewer effects as you drill down the call graph
01:31:24 <maerwald> but as said, they will have an IO type very likely
01:31:31 <maerwald> at which point the next step is to remove IO entirely
01:32:21 <tdammers> but in purescript, there is no "anything can happen" type, there is just Eff, and it says "anything can happen but you have to list it here, and everywhere up the call graph all the way up to main"
01:32:59 <tdammers> so you can't have a main that says "I'm OK with anything happening here", you have to bleed all effects up to main
01:33:05 <tdammers> one by one, and explicitly
01:33:14 <maerwald> I think that's fine
01:33:23 <tdammers> it's a maintainability problem
01:33:24 <maerwald> it's basically documentation about what your program does
01:33:36 <tdammers> yes, that's the idea, but it doesn't work
01:34:05 <maerwald> I'd rather try to fix it instead of removing it
01:34:17 <tdammers> in practice, I found myself using the get-out-of-Eff-with-Free card a lot
01:34:18 <ventonegro> merijn: damn partial languages! :)
01:35:22 <tdammers> or just using unsafePerformEff
01:36:29 <maerwald> tdammers: well, it should be possible to annotate an Eff to say "everything can happen" without introducing new types or removing the row type parameter entirely, no?
01:36:45 <royal_screwup21> map :: (a -> b) -> [a] -> [b] In this type signature, why is the latter half of it [a] -> [b], as opposed to [a] -> [a]. Here's why I ask that: suppose i have a function add x y = x+y, the type signature is add :: Num a => a -> a -> a, where everything is 'a' , implying that ALL of the types are the same. Doesn't the same reasoning hold for map?
01:37:23 <ventonegro> royal_screwup21: Why restrict map this way?
01:37:30 <ventonegro> :t length
01:37:33 <lambdabot> Foldable t => t a -> Int
01:37:42 <ventonegro> :t map length
01:37:45 <lambdabot> Foldable t => [t a] -> [Int]
01:37:55 <ventonegro> From `a` to Int
01:38:09 <tdammers> maerwald: but it's not. if you write just forall e. Eff e (), then you can't call something of type, say, forall e. Eff (console :: CONSOLE | e) () from that context
01:38:48 <maerwald> that's not what I meant
01:38:54 <maerwald> it would be a language feature
01:39:04 <tdammers> oh, you mean it should be added
01:39:06 <maerwald> not something idiomatically expressed via the type system
01:39:29 <tdammers> it would have to be hooked into the type system somehow though
01:39:34 <ventonegro> :t isAlpha
01:39:37 <lambdabot> Char -> Bool
01:39:47 <tdammers> or it could be done by redesigning the effect hierarchy from scratch
01:39:52 <ventonegro> :t map isAlpha -- royal_screwup21
01:39:54 <lambdabot> [Char] -> [Bool]
01:39:57 <tdammers> define a few basic effects, from which the others could be derived
01:40:14 <tdammers> but then I guess it would more or less boil down to Haskell's IO
01:40:39 <royal_screwup21> ventonegro: thanks, haha, I'm going to have to ponder over this haha
01:40:40 <tdammers> only difference would be that you use row types instead of transformer stacks
01:40:47 <maerwald> which is way way better
01:40:54 <tdammers> agree
01:41:03 <tdammers> Eff in purescript is not great
01:41:08 <maerwald> then again, we already have a solution in haskell to, except no one is using it
01:41:10 <ventonegro> royal_screwup21: There is no hurry :)
01:41:43 <maerwald> tdammers: https://gitlab.com/queertypes/freer/issues/7#note_23220562
01:41:52 <maerwald> but because those are libraries, no one is using it
01:42:02 <maerwald> which makes it a moot point
01:42:16 <maerwald> this can only be fixed by language dictatorship
01:42:50 <tdammers> I think there are more reasons why people aren't using them
01:43:15 <maerwald> well, I think the main reason is base doesn't use it
01:43:17 <maerwald> nothing else, really
01:43:49 <tdammers> you see, at some point in my program, I don't really care whether a function uses, say, AVARs, as long as it doesn't bleed any mutable variables to the rest of the code
01:44:04 <tdammers> but just because something uses AVARs internally, I have to bleed the effect all the way up to main
01:44:13 <tdammers> and I see a similar thing happening there
01:45:10 <maerwald> nah, you can define it in any general way you want here
01:47:03 <maerwald> in the example code getline and putline are separated, but I could as well merge them into a single thing. The problem is rather to agree on a set of those definitions or have a lot of conversion functions
01:48:19 * hackagebot dejafu 0.7.3.0 – Systematic testing for Haskell concurrency. – https://hackage.haskell.org/package/dejafu
01:55:03 <maerwald> ideally there should be an effects system which allows me to have the granularity I want. Socket syscall -> Network stuff -> IO and allow to have specific effects leak into more general effects based on a hierarchy without any explicit conversion needed
01:56:33 <maerwald> then stuff like base would _always_ choose the most specific definitions possible
01:57:39 <maerwald> but I'm just daydreaming without any idea on how to do that
02:00:39 <maerwald> duck typing on effects level!
02:14:08 * hackagebot gtk2hs-buildtools 0.13.3.0 – Tools to build the Gtk2Hs suite of User Interface libraries. – https://hackage.haskell.org/package/gtk2hs-buildtools
02:34:01 <Darwin226> Anyone know what the performance implications are of using NonEmpty? How well does it work with the fusion machinery for lists?
02:39:24 * hackagebot cairo 0.13.4.0 – Binding to the Cairo library. – https://hackage.haskell.org/package/cairo
02:49:34 <maffh>  I am trying to use template haskell in a stack package, so I added "template-haskel >= 2.10" to the build-depends in the .cabal file. However,  when I want to install the packages I receive the following error: template-haskel must match >=2.10, but the stack configuration has no specified version". Does somebody know what I did wrong?
02:49:52 <merijn> hmmm, anyone here able to build conduit-1.2.12 on GHC 8? I'm getting a whole bunch of build errors caused by rules
02:50:00 <barrucadu> maffh: You spelled "haskell" wrong
02:50:29 <maffh> O, wauw. Thanks!
02:51:29 * hackagebot cairo 0.13.4.1, glib 0.13.5.0, uri-bytestring-aeson 0.1.0.3
02:51:29 * hackagebot  → https://hackage.haskell.org/packages/recent
02:54:36 <merijn> what the hell?
02:55:57 <merijn> I managed to build conduit a couple of times yesterday and today it just fails?
02:56:18 <mfukar> Progress!
02:57:40 * hackagebot pango 0.13.4.0 – Binding to the Pango text rendering engine. – https://hackage.haskell.org/package/pango
02:58:32 <ongy> merijn: I get a bunch of warnings, but no error on 8.0.1
02:59:42 <merijn> lpaste down?
03:00:06 <phaazon> I have to rant
03:00:17 <phaazon> I HATE IT when people import a module without import list nor qualified
03:00:18 <merijn> Any non-sucky paste sites other than lpaste?
03:00:20 <phaazon> I truly HATE IT
03:00:21 <phaazon> goddammit.
03:00:38 <ongy> looks down
03:00:53 <phaazon> I feel like Dr. Engineer grepping around.
03:00:55 <phaazon> ffs
03:01:01 <phaazon> that was the end of my ranting
03:02:06 <merijn> gah, all the non-lpaste sites I know suck :\
03:02:14 <maerwald> merijn: gist.github.com
03:02:36 <merijn> ongy: For conduit-1.2.* I get http://dpaste.com/1VN0174
03:02:53 <merijn> ongy: I've tried everything from 1.2.0 up to 1.2.12, all broken
03:03:06 <merijn> 1.1 refuses to build due to conflicting dependencies
03:03:49 <ongy> I just build 1.2.12, cabal get conduit; cd conduit-*; cabal new-build
03:03:54 <merijn> ongy: And somehow it was compiling fine yesterday
03:05:14 <merijn> ongy: I get a shit ton of warnings when I do that, but when I use it as a dependency it refuses to compile
03:06:23 <ocharles> Can anyone help me work out what `cabal new-build all` is telling me about this Backpack-ed setup? https://gist.github.com/ocharles/1d212641a8a597af4465d74e41f04f87
03:06:34 <ocharles> "Something is amiss; requested module  opentracing-client-0.1.0.0[OpenTracing=<OpenTracing>]:OpenTracing differs from name found in the interface file opentracing-client-0.1.0.0[OpenTracing=<OpenTracing>,OpenTracing.Tag=<OpenTracing.Tag>]:OpenTracing (if these names look the same, try again with -dppr-debug)"
03:06:46 <ocharles> opentracing-client provides signatures OpenTracing and OpenTracing.Tag
03:06:50 <merijn> ocharles: Might wanna try #hackage where all the cabal-install nerds hangout
03:06:58 <ocharles> Ah, thanks. I couldn't remember which channel they were in
03:07:34 <ongy> merijn: I don't have anything here that uses it as dependency. But that sounds broken
03:07:50 <merijn> ongy: Well, yes, hence my confusion
03:07:57 <merijn> ongy: Especially since it was working fine yesterday
03:08:57 * hackagebot crdt 0.4 – Conflict-free replicated data types – https://hackage.haskell.org/package/crdt
03:08:57 * hackagebot gtk3 0.14.7 – Binding to the Gtk+ 3 graphical user interface library – https://hackage.haskell.org/package/gtk3
03:08:58 <osa1> where can I see the list of stackage lts releases?
03:10:36 <lyxia> stackage.org
03:12:27 <osa1> lyxia: where exactly in that page?
03:12:32 <osa1> I don't see a list of lts releases
03:13:01 <lyxia> hmmm
03:13:19 <lyxia> "What are long term releases" links to https://github.com/fpco/lts-haskell#readme
03:13:56 <lyxia> and the list is above the readme
03:14:32 <lyxia> there's also https://www.stackage.org/diff/lts-9.5/lts-9.6
03:15:32 * hackagebot gtk 0.14.7 – Binding to the Gtk+ graphical user interface library. – https://hackage.haskell.org/package/gtk
03:20:38 <osa1> I don't think it's documented but I was able to override ghc version in a lts release by adding a `compiler: ...` field in stack.yaml
03:24:56 <merijn> Can I somehow force GHC to ignore rules in my dependencies?
03:28:15 <toppler> Sorry for the random cosmetic question. But I've moved to hdpi, and I'm no longer happy with my fill-column. Any offers of people's preferred fill-column value for Haskell?
03:31:34 <osa1> 100
03:32:00 <merijn> 80
03:32:08 <osa1> 120 too much, 80 not enough, I find 100 to be ideal
03:32:31 <merijn> 100 is too much, can't find 3 columns on my UHD screen with 100 :p
03:32:51 <ventonegro> Heh, and then it starts
03:32:53 <osa1> for 3 yeah. I use 2 columns + one smaller column for NERDTree
03:33:27 <merijn> osa1: I need 1 column for irssi to rant while coding :p
03:33:46 <osa1> heh
03:33:55 <merijn> No one have a clue how I can beat GHC into ignoring RULE pragmas?
03:38:07 <merijn> ongy: Looks like it's GHC having a case of retardation
03:38:43 <merijn> ongy: Could you try building conduit with "--ghc-option=-fdefer-typed-holes"?
03:39:46 <ongy> fails
03:39:55 <ongy> looks like the errors you posted earlier
03:40:14 <merijn> That's a dumb bug
03:40:59 <lyxia> merijn: -fno-enable-rewrite-rules?
03:41:29 <merijn> lyxia: Looks like I found the culprit already
03:42:09 <lyxia> Lock him up!
03:42:17 <ongy> that flag combined with the defer-types-holes builds, with even more warnings :)
03:42:42 <merijn> Wouldn't be the first time changes in GHC broke my beloved defer-typed-holes
03:43:44 * hackagebot github 0.17.0 – Access to the GitHub API, v3. – https://hackage.haskell.org/package/github
03:43:47 <pimlu> is it bad if I'm having so much trouble with TH that I'm thinking of just making some unsafe script to generate the code I want? do others avoid TH for a reason like this?
03:44:22 <merijn> pimlu: What are you trying to do/why are you getting stuck?
03:44:31 <ongy> TH is a bit bothersome, but it's not *that* bad
03:45:29 <pimlu> trying to make dynamic dispatch with TH, and I'm totally clueless
03:47:15 <pimlu> when I can get my TH generator to typecheck in the first place the code using it will have other problems like "the declaration inside TH quote can't see my normal type names and I don't know why"
03:49:23 <pimlu> basically, my plan was to pass in a version of the typeclass I'm generating that has undefined for the methods, and have it generate the methods doing the dynamic dispatch
03:49:44 <pimlu> and just replace the undefineds
03:50:06 <pimlu> but I can already tell I'm doing something wrong having to pattern match all the way in
03:50:34 <pimlu> and when I tried to move the declaration of my type that I'm making an instance of outside the quote, it couldn't see it anymore
03:50:55 <merijn> pimlu: Is the type defined in the same module as you're running the TH?
03:51:24 <pimlu> different module, it errored if I tried to call the method and such within the same one
03:51:32 <pimlu> telling me to separate lol
03:52:27 <merijn> pimlu: I'm not quite sure what you're trying to generate?
03:52:45 <pimlu> basically, I have a typeclass T
03:53:03 <pimlu> and a union type A of lots of types that all are instances of T
03:53:54 <pimlu> I want to generate code that makes A an instance of T by calling the particular instance implementation, which to my understanding requires one function/conditional for each type somewhere down the line
03:54:10 <pimlu> I was hoping to make it log(n) using a map with typeable
03:54:19 <pimlu> since it has ord
03:54:48 <pimlu> basically I would look up the type and then cast with typable and call
03:54:58 <merijn> pimlu: Why would it require one conditional for each type? I would expect that to produce a single case-of
03:55:37 <pimlu> well, the end result is the same, I mean - case of will also be linear, right?
03:55:45 <merijn> pimlu: Why?
03:56:04 <merijn> pimlu: Could become a jump table
03:56:11 <merijn> Dispatching on the tag
03:56:30 <pimlu> if GHC did that it would save a lot of time
03:57:03 <pimlu> not sure how to find out easily
03:58:23 <pimlu> apparently it's a binary search at least in some circumstances
03:58:44 <merijn> pimlu: I'd say: Do the easy thing first and profile/optimise later
04:00:03 <pimlu> yeah, makes sense
04:02:56 <pimlu> well, I think TH is a bit hopeless for me at the moment, so maybe I'll just generate with a script for now... lol
04:04:41 <WinterFox[m]> I'm struggling to understand the difference between function application vs function composition.
04:04:53 <WinterFox[m]> Is there a simple explanation how they differ?
04:07:17 <maffh> Are there any libraries that consist of the sel functions of this example: https://wiki.haskell.org/Template_Haskell#Examples
04:08:25 * hackagebot stache 1.2.0 – Mustache templates for Haskell – https://hackage.haskell.org/package/stache
04:09:29 <maerwald> function composition is the application of the function composition function to two functions? :>
04:10:01 <aphorisme> Is there a way to see which libraries are needed for a haskell lib, running on linux? (I've a problem with libbz2 and I don't know which is used.)
04:11:02 <pimlu> to be a bit more specific with that, here's the definition of the function $: http://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#%24
04:11:07 <pimlu> all it does is call f on x
04:11:16 <pimlu> the magic that makes it useful is that it's very low precedence
04:11:37 <pimlu> so it splits your code into two "chunks" on the left and right side, where the left represents a function
04:12:00 <Unhammerd> I feel like these functions could be merged, is that possible:̉ http://sprunge.us/RAbT 
04:13:28 <merijn> Unhammerd: realToFrac might help
04:14:07 <pimlu> the definition of the function . is a little more complicated: http://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#.
04:14:17 <merijn> Most (all?) Integrals appear to be instance of Real
04:14:50 <pimlu> it uses the lambda to pass the parameter through both functions, which is what people use it for
04:15:32 <WinterFox[m]> They are both used for the same thing right? Removing () from the code?
04:16:19 <pimlu> almost always for $, yeah, and quite a bit for ., but sometimes . does things that can't be reproduced just with extra parentheses
04:16:25 <pimlu> for example
04:16:40 <pimlu> if I want to add one to a list
04:16:57 <pimlu> I can do map (+1) myList
04:17:12 <pimlu> or to add two, I can use . to compose incrementing twice
04:17:20 <merijn> WinterFox[m]: What something does and what it is used for aren't the same thing
04:17:38 <pimlu> map ((+1) . (+1)) myList
04:18:05 <Unhammerd> merijn,  thanks! just what I needed =D
04:18:16 <pimlu> although this is a parentheses heavy example, the point is in ((+1) . (+1)) you can't get rid of the . just with more parentheses
04:18:26 <WinterFox[m]> pimlu: interesting. Makes a bit more sense now.
04:44:15 <merijn> API design question: If I have a function that's not intended to be directly used by users (it's intended to be wrapped by other libraries before being useful) should I move that into a separate Internal module, or just keep it in the regular module with a warning/note that's not intended for the "average" user?
04:51:40 * edwardk waves hello.
04:52:12 <barrucadu> merijn: Depends, are you likely to break that interface?  Some people don't treat breaking changes in Internal modules as breaking for PVP purposes
04:52:16 <edwardk> Does someone here who loves dependent types or interesting type checking puzzles want to try to give me a hand? I wrote https://www.irccloud.com/pastebin/RNyta0OX/Suspension.hs last night, but I've got a tricky bug for typechecking conj.
04:53:21 <merijn> barrucadu: Well, they can't do anything unsafe with it, worst thing that could happen is you write code that wastes a bunch of resources (memory/threads) and runs some IO actions in a confusing order
04:53:33 <edwardk> I'm basically playing with a dependently typed lambda calculus with "explicit substitutions" being pushed through the terms, which is kinda neat because it means infer/check don't need to take environments as they get baked into the terms themselves
04:54:09 <merijn> barrucadu: The main reason not to move it into a .Internal module would be that I'd have to basically move ALL the code into the internal module and re-export it from a non-internal module
04:54:44 <barrucadu> Then that sounds like a good enough reason to keep it where it is
05:00:46 <edwardk> and i just realized it is 8am and most of the US is still asleep ;)
05:01:25 * Clint grunts.
05:01:30 <merijn> edwardk: All the european Haskellers are here, they're just busy working/being frustrated with tools :p
05:01:38 <merijn> edwardk: That might just be me, though ;)
05:01:38 <edwardk> heh
05:15:12 <edwardk> mostly just banging my head against a wall because its so close to working
05:15:22 <edwardk> bitonic's version has the benefit of having stronger types
05:15:30 <edwardk> which means i can have a dialogue with the compiler when this goes wrong
05:15:31 <merijn> edwardk: Story of my life :)
05:15:35 <merijn> (head against wall part)
05:17:07 * hackagebot crdt 0.5 – Conflict-free replicated data types – https://hackage.haskell.org/package/crdt
05:20:21 <Behnoud> Hello, "CCTV must be on different IP range" why?
05:20:39 <cocreature> that doesn’t sound like a Haskell question
05:23:02 <Behnoud> cocreature sorry wrong channel
05:24:56 <Behnoud> but any suggestion to where to ask network security? any channel suggestion?
05:27:41 <merijn> Is there any Haskell library that makes it easy to compare the outputs of various computation against each-other/golden versions?
05:29:02 <lyxia> deriving Eq
05:30:05 <merijn> lyxia: I mean output as in stdout/stderr, not result values
05:33:20 <stevenxl> Hi folks. I am on the Reader chapter of the Haskell Book. I'm supposed to implement a function bolt :: Integer -> Bool using (&&), (> 8), and (< 3). It is trivial to do this in a way that doesn't rely on the material that I learned in this chapter, but I think there's something about using the applicative of Reader that I'm supposed to use. 
05:34:43 <stevenxl> If I look at this type signature: (<*>) :: Reader r (a -> b) -> Reader r a -> Reader r b
05:36:04 <cocreature> stevenxl: are you aware of liftA2?
05:37:15 <stevenxl> cocreature: Yes indeed. Let me see if I can figure out how to use that here.
05:37:28 <cocreature> :t liftA2
05:37:31 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
05:37:54 <cocreature> now try substituting ((->) r) for f and see what you end up with
05:38:50 <stevenxl> cocreature: Ah - thank you. Yea I can see that I just apply liftA2 to those arguments, but I need to spend a little more type playing with the types to see what is doing. 
05:39:01 <stevenxl> liftA2 (&&) (> 3) (> 8)
05:42:44 <black0range> Hey, having a problem when compiling a stack project (it requires the ghc settings "compiler supports nopie" option to be set to yes) However i am unable  to locate this settings file for stack. Any ideas?
05:45:46 <merijn> API design question again (I realised I could move code more easily): Should I put functions that are not intended for end users (but other library authors to use for extending/wrapping) in an Internal module or Utils? (Internal to me implies possible dangerous invariant breakage, which can't happen here)
05:46:49 <cocreature> black0range: ~/.stack/programs/$yourarch/$compiler
05:47:08 <cocreature> black0range: but you shouldn’t need that. let me guess, you’re on Archlinux?
05:48:16 <black0range> cocreature: That is a very good guess :)
05:48:41 <cocreature> this is getting boring, I should write a bot that figures out when people are on Archlinux and tells them how to fix their setups.
05:48:45 <cocreature> black0range: which resolver are you using?
05:48:54 <lyxia> merijn: Utils sounds appropriate
05:49:10 <black0range> cocreture: Defult one
05:49:27 <cocreature> black0range: there is no default resolver (also your a key seems to be broken)
05:50:16 <black0range> cocreature: Then i am unsure of what you mean :)
05:50:24 <black0range> cocreature: key?
05:50:25 <greatgig1> does anyone has any experience with HackerRank functional programming module? Is it worth doing for a complete begginer like myself?
05:50:34 <greatgig1> *have
05:51:02 <black0range> cocreature: Write a stackoverflow post! :) 
05:51:10 <cocreature> black0range: what’s the value of the resolver field in your stack.yaml
05:52:28 * hackagebot schematic 0.2.0.0 – JSON-biased spec and validation tool – https://hackage.haskell.org/package/schematic
05:53:08 <black0range> cocreature: ah in stack! lts-9.3
05:53:54 <cocreature> black0range: alright, do you have libtinfo or libtinfo5 installed?
05:54:26 <michalrus> Hey! “Reflection” question: if I have `data SomeName = … (deriving Generic)` — how can I get the `"SomeName"` string?
05:55:29 <michalrus> `deriving Show` does that somehow, hmm. But that might be built-in.
05:57:38 <black0range> cocreature: I do not seem to have it installed
05:58:24 <bitonic> michalrus: it's attached to the `M` constructor thing
05:58:25 <bitonic> it's there
05:58:27 <cocreature> black0range: which ncurses packages do you have installed? (pacman -Qs ncurses)
05:58:55 <black0range> cocreature: 6
05:59:03 <bitonic> michalrus: http://hackage.haskell.org/package/base-4.10.0.0/docs/GHC-Generics.html#t:Meta
05:59:22 <cocreature> black0range: huh weird, what does "stack exec which ghc" tell you?
06:00:39 <black0range> cocreature: ~/.stack/programs/x86_64-linux/ghc-nopie-8.0.2/bin/ghc
06:01:15 <cocreature> black0range: that compiler should already have “supports nopie” set to yes, what makes you think it doesn’t?
06:01:21 <michalrus> bitonic: wonderful. ♥ Thanks!
06:01:49 <bitonic> michalrus: you'll need to get it with `symbolVal`
06:02:13 <black0range> cocreature: Okey i am a complete and utter retard that doesn't read error messages correctly...
06:02:13 <michalrus> OK. :) Awesome.
06:03:06 <cocreature> black0range: I take it that means you figured out what the problem is? :)
06:04:25 <black0range> cocreature: Yeah, I mispelled the name of the main-is file in the executable section... I am so ashamed
06:11:11 <stevenxl> cocreature: So I have a question. Once you mentioned `liftA2` it's trivial to see how to use it to get the results I wanted: liftA2 (&&) (> 3) (> 8), but I don't think I'd ever think to write it that way. I would have just done \x -> (x > 3) && (x > 8). Does it every get easier to think in terms of these abstractions? Is it just a matter of practice. I can unfold the liftA2 expression so i can see how we end up with
06:11:11 <stevenxl> the end result, which in my case looked like this (\a -> (\a -> (&&) (a > 3) (> 8 a)) but again, i dont' think I'd be able to use that when programming.
06:11:50 <stevenxl> )I forgot a few parenthesis to turn infix to prefix but you get the idea)
06:30:54 * hackagebot extrapolate 0.2.4 – generalize counter-examples of test properties – https://hackage.haskell.org/package/extrapolate
06:32:49 <kotrunga> Hello. Looking for an advanced haskell book for a coworker
06:33:02 <kotrunga> any recommendations?
06:34:27 <merijn> kotrunga: Simon Marlow's Parallel & Concurrent Haskell book?
06:34:33 <ventonegro> kotrunga: Richard Bird books
06:38:07 <kotrunga> merijn: Yeah, found that one. How quickly does Haskell become out of date? (that book is from 2013, wasn't sure if that's "old" in the haskell world or not)
06:38:39 <maerwald> haskell the language doesn't change a lot, but what people do and use does
06:38:52 <merijn> kotrunga: I'd say that's still very up to date
06:39:06 <kotrunga> ventonegro: saw that one too
06:39:08 <merijn> kotrunga: It mostly uses things from base/stm, neither of which have changed dramatically since it was written
06:39:28 <kotrunga> And that's good to know. I'm still using the k&r book haha, but wasn't sure about other languages
06:43:59 <stevenxl> Hello. 
06:44:27 <stevenxl> I am looking at the haskell wiki (https://wiki.haskell.org/All_About_Monads#Maybe_a_monad), and this sounds very wrong to me: -- return is a type constructor that creates monad instances 
06:44:27 <stevenxl> return :: a -> m a
06:44:47 <stevenxl> They mean data constructor right? Or am I the one that is confused?
06:44:55 <stevenxl> also, what does an instance mean?
06:45:14 <byorgey> stevenxl: that sounds very wrong to me too.  return is neither a type constructor nor a data constructor.
06:45:20 <byorgey> and it does not create instances.
06:45:46 <stevenxl> cool - i'll try to do a PR, which should at least point that out.
06:46:11 <stevenxl> ;-)
06:46:24 <byorgey> it's a wiki, no PR necessary =)
06:46:37 <byorgey> oh, I missed the note about a github repo
06:46:49 <stevenxl> Yea. 
06:47:04 <stevenxl> ok well I gotta get to work but wrote that down. Thanks @byorgey 
06:47:04 <byorgey> stevenxl: notice, however, that the github repo has not been touched in 6 years
06:47:09 <stevenxl> oh..
06:53:21 <merijn> So, no suggestions for a test library that makes it convenient to verify stdout/stderr of programs with eachother/golden outputs?
06:54:02 <byorgey> merijn: http://hackage.haskell.org/package/tasty%2Dgolden ?
06:56:17 <merijn> byorgey: Thanks, I'll have a look
06:57:18 <mmaruseacph2> it's a nice package
06:58:50 <merijn> mmm, annoyingly it seems to really want me to compare with a file :\
06:59:12 <merijn> Ah, no, the Advanced module has a more generic one
07:10:40 <jackhill> vkhktdglfnkuutfuvjjdejjukvivfcbv
07:13:15 <[exa]> Always good to see the good practice of complicated passwords.
07:13:36 <shapr> cat like typing detected
07:20:52 <merijn> bleh...naming things is way too hard
07:24:50 <Psybur> Anybody have a good article on how to use RWS and RWST? And maybe in conjunction with a fold?
07:29:10 * geekosaur thinks that's more "bumped the yubikey"
07:32:30 <greatgig1> I'm currently trying to solve this problem in haskell https://www.hackerrank.com/challenges/diagonal-difference/problem. But I think it might be above me
07:32:38 <int-e> Psybur: probably not; RWST just provides a combination of ReaderT, WriterT and StateT in a single type after all. With that in mind, http://book.realworldhaskell.org/read/monad-transformers.html may be a suitable starting point.
07:33:49 <greatgig1> I'll probably get back once I have something done :)
07:41:13 <merijn> Can I rely on Data.Foldable.toList being implemented lazily in most/all cases?
07:42:25 <merijn> Or should I just implement my own fold and avoid any conversion/list building costs
07:58:59 * hackagebot schematic 0.2.1.0 – JSON-biased spec and validation tool – https://hackage.haskell.org/package/schematic
08:00:29 <mizu_no_oto> greatgig1: where are you running into issues?
08:03:19 <tabaqui> I receive error in ghci while loading my working module
08:03:30 <tabaqui> Compile itself goes well
08:03:35 <cocreature> tabaqui: which error?
08:03:37 <tabaqui> /home/spirit/saas/common/src/SaaS/IO/Common.hs:175:38: error:
08:03:39 <tabaqui>     Cannot parse data constructor in a data/newtype declaration: 1
08:03:48 <tabaqui> data MessageType = WARNING | ERROR | DEBUG | INFO | EMPTY             deriving Show
08:03:55 <tabaqui> here is my data
08:04:14 <tabaqui> 38th symbols starts DEBUG
08:04:49 <tabaqui> actually I cannot ghci any project with more then 500 strings - there is always an error somewhere
08:05:22 <tabaqui> any ideas?
08:05:57 <dsfox> do you have a ~/.ghci file?
08:06:37 <tabaqui> dsfox: I've configured only prompt format
08:06:56 <tabaqui> and ghci is an alias for stack ghci
08:07:46 <int-e> tabaqui: that looks like some C preprocessor has run on the file, and DEBUG was defined
08:08:22 <tabaqui> I have the flag with the same name in one of the stack subprojects
08:08:38 <tabaqui> more precisely
08:08:49 <tabaqui> flag "debug" add cpp option "-DDEBUG"
08:09:37 <int-e> that's the issue then. though you may just be able to wiggle out if it with -DDEBUG=DEBUG
08:09:40 <greatgig1> I did it :) http://lpaste.net/358723
08:11:26 <tabaqui> int-e: with -DDEBUG=DEBUG, I get 
08:11:32 <tabaqui> >/home/spirit/saas/common/src/SaaS/Types/Messages.hs:381:0: error:
08:11:33 <tabaqui>      error: detected recursion whilst expanding macro "DEBUG
08:11:51 <mauke> ah, a non-compliant preprocessor
08:12:55 <tabaqui> maybe there is another option for conditional compilation?
08:13:06 <tabaqui> I very need it
08:13:56 <cocreature> tabaqui: well simply don’t use flag names as Haskell identifiers
08:13:57 <davidm-d> hi, does anyone know what order the types in type applications are applied if you don't do an explicit forall in your function?
08:14:29 <tabaqui> cocreature: hmm, it's so hard, but I'll try :)
08:14:34 <merijn> davidm-d: Only GHCs internal gremlins know
08:14:53 <mauke> I'd assume it's in order of use
08:14:54 <cocreature> tabaqui: all upper case is kind of a weird naming convention anyway tbh :)
08:14:59 <cocreature> at least for Haskell
08:15:00 <merijn> davidm-d: And it might change between GHC versions. Which is why, IMO, using TypeApplications is a bad idea
08:15:16 <cocreature> you can take TypeApplications from my cold dead hands
08:16:03 <mauke> :t undefined :: t1 -> Maybe t2 -> t3 Maybe -> ([t4], t5)
08:16:05 <lambdabot> t1 -> Maybe t2 -> t3 Maybe -> ([t4], t5)
08:16:15 <mauke> :t (undefined :: t1 -> Maybe t2 -> t3 Maybe -> ([t4], t5)) @Int
08:16:18 <lambdabot> error: parse error on input ‘@’
08:16:35 <merijn> mauke: I think GHC currently does left-to-right, but that might be off for more complex types
08:16:50 <merijn> mauke: In any case, it's certainly not documented or stable
08:17:00 <mauke> bah
08:17:12 <mauke> it should be made stable and documented :-)
08:17:16 <mauke> regex style
08:18:56 <int-e> mauke: oh well, cpphs doesn't like the trick either... it just loops gobbling up memory. sad :)
08:21:08 <merijn> cpphs is explicitly not a proper C preprocessor, though
08:23:33 <tabaqui> ah, no chance
08:23:44 <tabaqui> haskell templates
08:23:50 * tabaqui is out
08:25:05 <davidm-d> merijn: I'm just in the process of rewriting the signature selections proposal. I was also under the impression it was gremlins. Signature selections are a waaay nicer way of dealing with things.
08:25:44 <lurind> hello
08:31:32 * hackagebot cmv 1.0.6 – Detailed visualization of CMs, HMMs and their comparisions – https://hackage.haskell.org/package/cmv
08:36:11 <woodson> hi everyone. I am trying to use STM as way to save state its just to learn not a crazy project. Im stuck its seems TVar would be the wrapper that the STM functions needs, but each function return an 
08:36:25 <woodson> wrap my values in an STM wrapper
08:36:36 <woodson> how to unwrap to get the TVar value again?
08:37:18 <Geekingfrog> The same way you "unwrap" to get a string from IO String for example.
08:37:43 <monochrom> "wrap" and "unwrap" are very wrong ideas.
08:37:56 <Geekingfrog> woodson, when you are inside an STM context, you can do `content <- readTVar myTvar`
08:38:32 <monochrom> You run a transaction to get any STM work done. This is what "atomically" is for, it runs a transaction.
08:38:53 <mauke> runSTM is spelled 'atomically'
08:39:02 <mauke> which is kind of a weird name, if you think about it
08:40:23 <monochrom> And it doesn't unwrap. It may actually re-try your transaction several times without you needing to know, because your transaction may conflict with another one from another thread so one of them needs to be rolled back and re-tried and it may be yours.
08:40:45 <woodson> here is my code
08:40:46 <woodson> https://gist.github.com/Woody88/66c064c703697eaea88cf68eea5d2f84
08:40:53 <monochrom> This is why "wrap" and "unwrap" are so wrong models.
08:41:11 <woodson> well it does promotes the type right?
08:41:31 <woodson> Tvar [random list] becomes STM ([random list])
08:42:03 <woodson> :t readTVar 
08:42:05 <lambdabot> error: Variable not in scope: readTVar
08:42:23 <Geekingfrog> readTVar :: TVar a -> STM a
08:42:53 <woodson> yea now i get STM a
08:43:08 <woodson> how would i read it again with the STM a
08:43:17 <monochrom> I think you completely misunderstood STM and you need to unlearn and learn from scratch again.
08:43:20 <woodson> if readTVar needs the TVar
08:43:33 <woodson> im still in the learning
08:43:35 <mauke> why are you using STM at all?
08:43:45 <woodson> so im not saying that i knwo it
08:43:54 <mauke> do you have multiple threads?
08:44:22 <ezyang> woodson: You will probably get better learning materials if you consider why readIORef :: IORef a -> IO a 
08:44:36 <ezyang> once you understand that, the STM version will make more sense 
08:44:53 <monochrom> I mean I am looking at "newUser = User{ ... xxx = newTVar}" and whatever idea that brought you to that conclusion you must abandon it.
08:45:05 <monochrom> You simply can't do that.
08:46:02 <monochrom> I don't understand what newUser is supposed to accomplish so I can't say what to do instead. But delete that piece of code already. SImply delete.
08:47:15 <woodson> ya i made in mistake it was supposed to be TVar [Room]
08:47:32 <woodson> but ok can someone clarify something for me
08:47:50 <monochrom> I am actually pretty skeptic about needing TVar[Room] there. But whatever.
08:48:13 <woodson> monochrom: i believe yesterday i was talking to you
08:48:36 <woodson> like i said last time i still have messsaging passing in mind from elixi/erlang
08:48:46 <woodson> and im linking stm to that
08:48:57 <monochrom> In this case you need a transaction that creates your user record. Not a value definition.
08:49:24 <monochrom> newUser :: STM User
08:49:55 <monochrom> newUser = do { r <- newTVar []; return ( User{... , xxx = r} ) }
08:50:32 <monochrom> Generally "x = newTVar[]" is not the same as "do { ... ; x <- newTVar[]; ...}"
08:51:06 <monochrom> And what ezyang said. Figure out IO properly first (or prove that you did) before this.
08:51:23 <woodson> yes if i remember well the do is the same as >>=
08:51:35 <woodson> ok thanks
08:51:41 <monochrom> (Remark: "prove" does not mean you just claim that you understand. No one ever believes that. "prove" means you show working code.)
08:52:53 <woodson> i having claimed nothing yet im just trying things as i follow along the wiki book haskell
08:53:00 <woodson> but things for the advice
08:53:49 <MichaelBurge> A list is a generalized tuple, for products. What is a generalized Either, for sums?
08:54:34 <monochrom> No, list doesn't generalize tuple. (True, 'x') is allowed, [True, 'x'] isn't.
08:55:02 <monochrom> Premise error. Rest of question skipped.
08:55:34 <monochrom> But look for "existential quantification".
08:55:57 <mauke> MichaelBurge: (Integer, a)?
08:56:01 <MichaelBurge> monochrom: You can assume all elements of the list have the same type, and that all elements of the Either have the same type
08:56:17 <monochrom> So look for "existential quantification".
08:56:38 <pierrot> it looks quite contradictory that "existencial quantification" uses forall keyword
08:56:39 <MichaelBurge> mauke: That's a good one. A constructor index and a witness.
08:57:06 <mauke> pierrot: it's CPS transformed
08:58:11 <monochrom> The "forall" looks better if you use GADTs syntax.  data X where{ forall a. a -> X }
08:58:35 <monochrom> err, data X where{ Ctor1 :: forall a. a -> X }
08:59:38 <monochrom> Actually go with mauke's (Integer,a). Either is tagged, so you need the Integer there for infinitary tagging.
09:00:07 <monochrom> But existential quantification will be useful elsewhere.
09:00:40 <nshepperd_> pierrot: de Morgan's laws
09:02:14 <pierrot> yeah
09:04:26 <monochrom> The GHC devs also want to avoid reserving one more common English word.
09:12:13 <Psybur> So MultiCase isnt a thing yet?
09:14:30 <cocreature> Psybur: multicase?
09:14:56 <Psybur> cocreature, https://wiki.haskell.org/MultiCase
09:15:14 <Psybur> Wondering if theres something like that in haskell. Tried the | in a pattern match and it didnt work
09:15:27 <Arul_> Hello Everyone,
09:15:45 <Arul_> Can someone help me understand how to get this expression to work ? 
09:15:45 <Arul_> toEnum . fromEnum $ True
09:16:07 <cocreature> Psybur: we might get it relatively soon https://github.com/ghc-proposals/ghc-proposals/pull/43
09:16:34 <verement> :t toEnum
09:16:36 <lambdabot> Enum a => Int -> a
09:16:45 <hydraz> > toEnum . fromEnum $ True
09:16:48 <lambdabot>  *Exception: Prelude.Enum.().toEnum: bad argument
09:16:53 <verement> Arul_: what do you want the result type to be?
09:17:23 <hydraz> > toEnum . fromEnum $ True :: Bool
09:17:26 <kakashiAL> stupid question, but if I have a function, that I define, something like square x = x * x   <---why are devs still implementing square :: Int -> Int ???
09:17:27 <lambdabot>  True
09:17:52 <Arul_> I want the result type to be Boolean
09:18:23 <[exa]> True doesn't look boolean?
09:18:27 <cocreature> kakashiAL: I don’t understand that question, can you be more specific?
09:18:51 <verement> then say so (see hydraz's example)
09:19:03 <adjointfunctor_> kakashiAL, what devs are implementing `square`?
09:19:09 <adjointfunctor_> :t square
09:19:12 <lambdabot> error: Variable not in scope: square
09:19:52 <kakashiAL> cocreature: if you define a function:   foo x = x * x     <---this is enough, this works, but why do you see sometimes stuff like   foo :: Int -> Int ?
09:20:17 <kakashiAL> cocreature: is it to define the type of the function, to get debug support?
09:20:40 <[exa]> kakashiAL: maybe there's some reason that the definition should only be used for ints?
09:21:08 <cocreature> kakashiAL: making types explicit makes it easier to understand how the code works and you can make sure that the definition actually has the type that you expect it to
09:21:24 <cocreature> kakashiAL: in fact, I often start by _first_ declaring the type and only then start implementing things until they typecheck
09:21:24 <kakashiAL> [exa]: okay, so foo :: Int -> Int is only to define and to restrict the function
09:21:45 <dave24> I'm a bit confused by the default Bifunctor implementation, is that because it actually makes no sense unless either `first` and `second` or `bimap` is overridden?
09:21:55 <cocreature> for more complex types, GHC is also simply unable to infer them in some cases but that’s the exception rather than the rule for most Haskell code
09:21:55 <[exa]> it actualy kindof "specializes" it, the most general signature the foo can have is this
09:21:57 <Arul_> hydraz: veewmonr: Thanks for the tip
09:21:59 <[exa]> :t \x -> x*x
09:22:00 <kakashiAL> furthermore you will get an error from the compiler if you "misuse" the function
09:22:01 <lambdabot> Num a => a -> a
09:23:13 <kakashiAL> okay, so if I would not do foo :: Int -> Int   I could use everything in foo and it would not complaint
09:23:17 <kakashiAL> thanks guys!
09:23:34 <cocreature> kakashiAL: no that’s not true, the typechecker is still active
09:23:51 <cocreature> it’s just that in this particular case the type signature that GHC implicitely infers is more general than Int -> Int
09:24:02 <cocreature> in particular it’s "Num a => a -> a"
09:24:08 <[exa]> kakashiAL: if you're asking why anyone cares to write the explicit typing, it is sometimes very useful for locating type error in complicated programs (especially with mutual recursion where the inference is a bit complicated)
09:24:16 <cocreature> but that still doesn’t mean you can use everything. you can only use things that are an instance of Num
09:24:42 <cocreature> think of it like this: if you don’t specify "foo :: Int -> Int" the code behaves as if you had written "foo :: Num a => a -> a"
09:33:34 <monochrom> "everything" is right, but the opposite of what you think. "foo :: Num a => a -> a" means I, the user, can use everything, and you, the author of foo, have no rights.
09:34:33 <cocreature> “everything” is still not right, you need to satisfy the Num constraint
09:34:37 <monochrom> You have no right to make it Int because I am going to use Integer. And you have no right to make it Integer because I am going to use Int.
09:39:14 <Psybur> If anybody needs any help with the RWST transformer, I modified the Simple_StateT_use example to add in reader and writer. https://glot.io/snippets/etzmrorvkr
09:39:39 <Psybur> Modified the guessing game from this page https://wiki.haskell.org/Simple_StateT_use
09:41:25 * hackagebot blank-canvas 0.6.1 – HTML5 Canvas Graphics Library – https://hackage.haskell.org/package/blank-canvas
09:41:55 <Psybur> Cleaned up the state retrieval https://glot.io/snippets/etzmuvgiah :D
09:42:41 <Jimbo> hey guys, I'm attempting to understand how the sequence function works
09:42:48 <Jimbo> I have a pastebin, is it ok to link to it here?
09:42:55 <monochrom> Yes.
09:45:56 <Psybur> If I wanted to add my example to the haskell wiki, do I just find or add it wherever and the mods approve/deny? I feel like my example would be helpful for someone else who ends up struggling with RWST/monad transformers
09:46:14 <Jimbo> https://pastebin.com/XUZk0Ygr
09:46:20 <Psybur> *find an appropriate page/add a new page
09:47:24 <monochrom> Psybur: I think actually the mods just decide whether to give you an account, and once you have an account you can do add wherever.
09:47:35 <Psybur> Ok
09:49:36 <Jimbo> So yeah I'm not sure if I am thinking of the sequence function properly
09:50:25 <monochrom> I think yes. But you should also try your hands at sequence [Just 1, Just] and sequence [Just 1, Nothing].
09:51:49 <Jimbo> so I've interpreted p >>= \x -> correctly by treating return as a monad?
09:52:09 <Jimbo> and ok I'll give those a shot
09:52:18 <monochrom> I don't know what that means
09:58:36 * hackagebot dejafu 0.8.0.0, hunit-dejafu 0.7.0.1, tasty-dejafu 0.7.0.1
09:58:37 * hackagebot  → https://hackage.haskell.org/packages/recent
10:11:47 * hackagebot hpack 0.19.0 – An alternative format for Haskell packages – https://hackage.haskell.org/package/hpack
10:11:47 * hackagebot log-warper 1.2.2 – Flexible, configurable, monadic and pretty logging – https://hackage.haskell.org/package/log-warper
10:21:46 <Psybur> Is it generally preferable to use a Sequence instead of a List when using a Writer?
10:22:01 <t7> how do people who use stack do their random repl stuff (not a project)
10:22:22 <Psybur> t7, I just type in stack ghci
10:22:46 <t7> doesnt it come with zero packages
10:22:51 <t7> no Data.Set etc
10:23:23 <Psybur> I just import what I need
10:23:49 <Psybur> You type: import Data.Set
10:24:05 <Psybur> You can also import qualified Data.Set as S
10:24:06 <mpickering> I have an instance FromField a => FromField (Tagged t a) where... but GHC doesn't seem to want to select this instance for Tagged "myString" Int
10:24:26 <mpickering> ok.. I have to enabled PolyKinds
10:28:43 <dsal> Is there parallelism without IO?
10:29:40 <pikajude> par, right?
10:29:51 <dsal> I'm trying to do this exercism thing, and it says to do the a thing with parallelism, but the function signature given doesn't have IO.
10:31:29 <kuribas> dsal: yes
10:32:44 <kuribas> dsal: parallelism is about doing computations in parallel.
10:33:48 <dsal> Yeah.  I'm confused that Control.Concurrent is all about thread and stuff.  Concurrency and threads don't seem to be the same thing.
10:36:48 <kuribas> dsal: Concurrency and parallelism are two different things.
10:37:45 <dsal> Yes, I know.
10:37:55 <dsal> parallelism implies threads.  Concurrency doesn't.
10:38:09 <tdammers> no, parallelism does not imply threads
10:38:26 <tdammers> you can parallelize at the process level too, or even at the machine level
10:38:55 <tdammers> you can also use parallel processing pipelines on suitable hardware, such as GPUs or FPGAs
10:39:01 <t7> > (!! 10129) $ map (take 3) $ permutations ['m'..'t']
10:39:03 <lambdabot>  "tom"
10:39:34 <tdammers> you could even argue that the "pairing" feature on somewhat modern x86 CPUs would count as parallel
10:39:54 <Tuplanolla> Processor pipelining is also parallel processing in some sense.
10:40:35 <t7> i heard amd processors use ANNs to do branch prediction 
10:40:38 <dsal> The two processes requires at least two threads.  Saying we're doing parallel processing in a single thread is... confusing.
10:40:45 <kuribas> dsal: parallelism is about computing faster using the ability of hardware to computations in parallel.  Concurrency is about making the user experience smoother by not letting external effects block the program.
10:41:58 <kuribas> Tuplanolla: GPU's to pipelining as well, since they have less efficient memory caching.
10:42:11 <dsal> That sounds specific to haskell.  Concurrency in general doesn't require you to be dealing with external effects.   I can concurrently traverse two data structures without any side effects.
10:43:05 <kuribas> dsal: the distinction is more blurred in other languages, yes.
10:44:02 <Tuplanolla> I like the definition that concurrency means things appearing to happen at the same time while parallelism means things actually happening at the same time (even if you cannot directly observe it).
10:44:48 <kuribas> SIMD is paralellism as well
10:46:26 <terrorjack> Hi fellas, what is your goto lib for a mutable intmap/hashmap?
10:46:31 <kuribas> dsal: I can really recommend Simon Marlow's book, Parallel and Concurrent Programming in Haskell.
10:47:08 <kuribas> terrorjack: I don't, I use unordered containers.
10:47:36 <terrorjack> kuribas: like IORef (HashMap k v) or something?
10:47:38 <dsal> So what does `par` actually do?  I don't understand its use from the docs.
10:48:21 <kuribas> terrorjack: you don't need IORef
10:48:44 <ahf> 1/90
10:49:43 <terrorjack> I'm writing a websockets based app, not an algorithm challenge..
10:50:16 <kuribas> dsal: it signals to the compiler that it may evaluate the first value in parallel with the second.
10:50:26 <pikajude> you may like parTraversable
10:50:58 <dsal> ooh, you can just inject it between parameters.  
10:52:38 <dsal> pikajude: Thanks.  This is helpful.
10:56:43 <vimalloc> Can anyone suggest a simple command line arg parsing library for a stupid simple cli app? Looking at optparse right now, but wondering if there are any better choices out there for a cli with just a few flags
10:57:38 <johnw> still optparse-applicative
10:57:45 <srhb> vimalloc: optparse-applicative gets really simple if you have a short definition.
10:57:49 <johnw> once you've done it for one app, you'll have boilerplate that's trivial to copy for any other app
10:57:55 <vimalloc> kk, great. Thanks :)
11:18:36 <sshack> Hi are there any good current tutorials on optimizing haskell builds for heroku like environments? 
11:35:02 <pierrot> is there any difference between these two sections: (+1) and (1+)?
11:35:11 <Clint> yes
11:36:04 <pierrot> Clint: the order in which the argument applies?
11:38:18 <srhb> pierrot: \a -> a + 1 vs \b -> 1 + b
11:38:58 <pierrot> srhb: thanks, then it's what I had thought
11:39:15 <srhb> > ((/2) 1, (2/) 1)
11:39:19 <lambdabot>  (0.5,2.0)
11:39:20 <srhb> pierrot: Right :)
11:46:56 <qwz> If I have a type where all the constructors have the same first field is there a way to access that field regardless of the constructor?  In other words I'd like to pattern match doing something like f (_ foo) = -- do something with foo.
11:49:23 <lyxia> Either write a function foo to extract the field, then "f x = case foo x of ...", or refactor your type.
11:50:20 <lyxia> with view patterns it could also be "f (foo -> y) = -- do something with y"
11:51:33 <qwz> View patterns?
11:56:43 <johnw> I love view patterns
12:02:51 <maerwald> that's quite a commitment
12:13:03 <johnw> yeah, I'm all in where Haskell is concerned
12:13:21 <MarcelineVQ> omy
12:13:53 <qwz> "I've tasted the Kool-Aid and it was good."
12:14:38 <maerwald> hope it doesn't break your heart :>
12:14:39 <erisco> OH YEAH!
12:14:45 <OtterCoder> Hi! I'm looking for the meaning of an operator. I encountered the <> op while trying to build a project, it's undefined. 
12:15:31 <shapr> OtterCoder: is there an import for Control.Applicative ?
12:15:46 <shapr> er wait, I bet that's monoid
12:15:59 <shapr> how about Data.Monoid ?
12:16:09 <adjointfunctor_> semigroup, actually
12:16:12 <shapr> aw man
12:16:15 <maerwald> haha
12:16:16 <hydraz> Monoid still exports it
12:16:22 <hydraz> Data.Monoid, that is
12:16:40 <OtterCoder> @shapr That might be it.
12:16:41 * lambdabot orders her trained monkeys to punch That might be it.
12:17:51 <OtterCoder> shapr: Would Options.Applicative count?
12:18:16 <shapr> nah, that's for command line argument parsing
12:20:07 <OtterCoder> shapr: Ah, looks like Data.Monoid is littered everywhere.
12:20:18 <MarcelineVQ> this is a good case for why a person writing code they'll share should always use explicit imports, so people don't have to guess where <> came from, it'll be right at the top
12:20:24 <shapr> yup, I agree
12:20:37 <shapr> I do that for any 'real' code, though not for one off scripts
12:20:40 <OtterCoder> MarcelineVQ:  Agreed!
12:20:43 <maerwald> when the import statements are more loc than the actual code, lol
12:20:44 <maerwald> gj
12:21:23 <OtterCoder> I'm coming to Haskell from Elm, and explicit imports are a lifesaver in my experience.
12:21:38 <MarcelineVQ> maerwald: Possibly, but when you read the code and you see an operator you can glance upwards and be sure it's imported or defined elsewhere on that same file
12:22:10 <shapr> OtterCoder: how's that going? Are Elm and Haskell roughly the same thing?
12:22:34 <maerwald> MarcelineVQ: I like to live in danger, even if it's just rogue import statements!
12:23:42 <OtterCoder> shapr: Yes and no. Elm seems to have many more fancy ways to avoid parens. I've dabbled in Haskell before, and they're similar enough conceptually that it's not hard to pick up on the syntax differences.
12:24:32 <shapr> OtterCoder: that's cool, I know a pile of javascript devs who are jumping into Elm
12:24:41 <OtterCoder> Elm especially has a different concept for their main function structure, which really benefits its UI domain.
12:24:55 <OtterCoder> shapr: Yep, that's me.
12:25:26 <adjointfunctor_> Any thoughts on diagrams-blender backend?
12:25:39 <OtterCoder> shapr: Now I'm jumping again to haskell for the backend.
12:26:14 <shapr> OtterCoder: cool! are you documenting your experience?
12:26:28 <shapr> I'd be interested in reading blog posts or whatever
12:26:46 <OtterCoder> shapr: Not as well as I should. I'll try to work on writing down my thoughts. :)
12:26:57 <shapr> OtterCoder: was the Elm syntax an obstacle when jumping from javascript?
12:27:13 <shapr> I've tried to teach Haskell to Go coders, but they just cry.
12:27:41 <MarcelineVQ> "what do I do with all these options?"
12:27:48 <shapr> OtterCoder: I suggest installing hoogle, then you can find operators or functions easily.
12:28:00 <maerwald> shapr: why would you do that
12:28:04 <OtterCoder> shapr: Oh, elm syntax was a dream. I'd already moved my JS to a more functional style, arrow currying and such, elm made everything easier.
12:28:24 <shapr> huh, wow
12:29:02 <OtterCoder> Elm modules get a bit wordy though. It's a toss up whether Elm or JS would be more terse for a given widget. Elm is consistently more neat though.
12:29:57 <shapr> OtterCoder: any other comparisons come to mind?
12:30:52 <Tuplanolla> How does the lack of type classes really feel like, OtterCoder?
12:31:20 <OtterCoder> shapr: Elm's compiler is really quite powerful. Tossing in a large elm program is much, much smaller and faster than a tiny function using a framework in JS.
12:31:43 <shapr> huh, wow
12:31:58 <OtterCoder> Tuplanolla: Heh, I'm coming from JS to Elm to Haskell, so I'm not as deprived from the other direction.
12:33:20 <Tuplanolla> I'm going to have to do some web development eventually and I already dread it.
12:33:52 <shapr> Tuplanolla: use Elm?
12:34:15 <OtterCoder> Tuplanolla:  Oh, you are correct in feeling that way. I do full stack so that I can take brakes from UI nonsense.
12:36:27 <Tuplanolla> That was the relief plan, shapr.
12:39:42 <shapr> I can't find an Elm tutorial aimed towards Haskellers
12:41:34 <OtterCoder> shapr: I don't think I've seen one either. The Elm Architecture is a good read though. It starts from a basic level, but it does a really good job of teaching how to cleanly implement FRP for UI.
12:43:00 <OtterCoder> shapr: https://guide.elm-lang.org/architecture/
12:48:56 <Psybur> So when I am working with monads, and I do something like: r <- execM functionThatRecursivelyBuildsMonad values, whats going on is execM is building up the initial monad and then combinging the results of the recursive function together? With >> ?
12:51:59 <maerwald> FRP? I thought elm has finally given up on it
12:54:26 <padre_angolano> OtterCoder: http://elm-lang.org/blog/farewell-to-frp
12:57:21 <maerwald> "so I was delighted to stumble upon a path that would take us farther with fewer concepts" -- wise words though
12:57:27 <erisco> Psybur, are you asking about how execM works?
12:58:08 <Psybur> Oh is execM an actual function? I just meant it as a general constructor for monads
12:58:39 <erisco> constructor? :s
12:59:20 <erisco> if I said  r <- [1..]  would that be a clearer example?
13:00:18 <Psybur> Ok, Ill be concrete. In this rwst code I made https://glot.io/snippets/etzsaoz1xl How is each frame of "guessSession" made available to the next? Is it through >> ?
13:01:42 <OtterCoder> padre_angolano: Yeah, it's not 'pure' frp now, but it still has the soul of it, and a much better end result.
13:01:45 <Psybur> And I imagine what happens here is similar to other monads constructed in a similar way?
13:02:21 <maerwald> OtterCoder: definitely different priorities than haskell
13:03:49 <OtterCoder> maerwald: Totally different domain. UI, especially web UI, is a horrible, messy, ugly world. Elm is a shining beacon of light in a dark world.
13:04:22 <maerwald> I wouldn't say domain, you can do the same in haskell, but the scope is different and the priorities
13:04:52 <conal> OtterCoder: elm is fine in itself, but it never really did have the soul of frp, since elm lacked both foundational properties of frp. if interested, see https://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language#5878525 and the links there.
13:05:38 <maerwald> I don't think anyone actually cared whether it met some specific definition of FRP
13:05:53 <geekosaur> aside from the frpedants?
13:05:57 <maerwald> ...
13:06:16 <geekosaur> we've had some ... interesting ... arguments in here abot whether something is actually frp or not
13:07:26 <OtterCoder> Sorry for bringing up a sore topic re. FRP. :P As a recovering JS dev, I'm still in awe of its beauty.
13:07:48 <maerwald> recovering xD
13:07:56 * shapr hugs OtterCoder
13:08:03 <maerwald> what did they do to you?!
13:08:06 <erisco> Psybur, >> is generic like >>= is, so it is not really any answer as to *how* it happens
13:08:18 * geekosaur is ... less tham impressed with mathematical arguments about such things. maybe because xmonad's stackset is mathematically correct but horrid UX
13:08:56 <Psybur> erisco, I cant seem to figure out how the results of guessSession are being combined :D
13:09:07 <geekosaur> and, GUI? the UX matters to me far more than the abstract mathematical precision
13:09:10 <Psybur> All I know is that they are :{
13:09:28 <maerwald> geekosaur: hehe
13:09:31 <erisco> Psybur, if you want to know how then you have to look to the definition of RWS. I am not familiar with it.
13:09:39 <adjointfunctor_> OtterCoder, did you hear a story about how somebody done full layout by matrices in css?
13:09:44 <maerwald> which is why I said elm has a refreshingly attitude, in a way
13:10:21 <adjointfunctor_> Psybur, execRWS is defined in terms of runRWS
13:10:40 <maerwald> but I think the only reason it can really focus on ease-of-use is that it has a very limited scope
13:10:41 <Psybur> erisco, actually I think it might be able to be answered more generically. Monads constructed with a recursive "do" are combined with >> right?
13:10:43 <OtterCoder> adjointfunctor_:  No. That sounds interesting. I have heard of how someone built a click-pumped turing machine in css though.
13:11:06 <Psybur> OtterCoder, that sounds horrifying
13:11:49 <erisco> Psybur, everything in do-notation is stuck together with >>= and >> is just a special case of that
13:11:56 <OtterCoder> Psybur: I think it used rule 110 to create a computer via cellular automata. Something like that. Clicking mindlessly advanced the state.
13:13:14 <[exa]> sounds like the arkanoid in sed
13:13:29 <Psybur> You guys are gonna give me nightmares
13:13:46 <[exa]> computability conversions are m'kay
13:14:07 <erisco> to see what the recursive definition means, just begin unfolding it
13:15:21 <[exa]> Psybur: the best proof of np-existence theorem is based on putting colored bathroom tiles together
13:15:45 <Psybur> !
13:16:22 <maerwald> bathroom tiles?
13:16:28 <[exa]> and also there is a tetris in game of life somewhere, with a catch -- the guys decided to simulate Tetris in RISC CPU in PCB in GoL
13:17:40 * maerwald imagines standing next to the tile layer and saying "hey, you just proved np-existence theorem"
13:18:12 <[exa]> maerwald: you have 4-sided tiles with 4 different colors on each side, N tile types, M colors, and need to fill a rectangle with them so that neighboring colors are the same
13:18:13 <erisco> "About time you computer scientists figured that out!"
13:18:50 <[exa]> solving a turing machine using this is more picturesque than with SAT
13:19:21 <maerwald> it also sounds like a way to torture OCD people
13:19:23 <mpickering> Is there a lens _Tagged defined somewhere in a package?
13:19:29 <[exa]> OCD?
13:19:33 <maerwald> nvm
13:19:45 <[exa]> oh. :]
13:20:01 <esap> >[mat3x4|1 2 3 1;3 5 6 7;7 5 6 5|] %*% [mat4x3|4 3 2;4 4 4;6 6 6;1 1 1|]
13:20:01 <esap> [31.0,30.0,29.0]
13:20:01 <esap> [75.0,72.0,69.0]
13:20:01 <esap> [89.0,82.0,75.0]
13:20:10 <[exa]> yeah, these are very good for solving NP-complete trouble
13:20:18 <[exa]> *they
13:20:53 <esap> wrote quasiquoter on matrices
13:21:07 <erisco> free conversion to Double!
13:21:13 <[exa]> <3
13:22:38 <adjointfunctor_> esap, there is a different QQ for each matrix shape?
13:23:12 <esap> adjointfunctor: yes. I also support case where the dimensions are lists, but that doesn't have good properties as matrix.
13:24:40 <adjointfunctor_> esap, did you put your project on Hackage?
13:25:51 <esap> adjointfunctor: no this is not in Hackage. I've got 40kLOC on it and it needs to cleanup before can be published.
13:28:08 <conal> OtterCoder: If interested, you can learn more about the why and what of FRP here: https://github.com/conal/talk-2015-essence-and-origins-of-frp/blob/master/README.md
13:30:02 <maerwald> purist FRP :>
13:30:58 <esap> adjointfunctor: but I do have quite a chunk of basic mathematics implemented in it, e.g. matrices, streams, graphs etc.
13:31:06 <shapr> I'd love to see that
13:31:20 <shapr> is the code on github for others to jump in and help clean?
13:31:50 <esap> shapr: no not publicly available
13:32:48 <esap> shapr: I've been thinking of publishing for a long time, but there have always been so much cruft that cannot be published that it never happened.
13:33:15 <shapr> I'd just throw it on github and ask for help
13:33:27 <shapr> Be the Linus that you want to see!
13:34:01 <shapr> of course, I'm being selfish, I like reading Haskell code.
13:34:53 <esap> shapr: I only recently started using cabal and haddock for this
13:35:15 <shapr> private github repo, invite some people?
13:35:42 <shapr> 40kloc of Haskell could keep me busy reading for weeks
13:36:23 <MichaelBurge> Is there an easy way to see all the packages that depend on a specific one?
13:36:49 <shapr> MichaelBurge: https://packdeps.haskellers.com/reverse
13:37:01 <MichaelBurge> shapr: Thanks!
13:37:55 <shapr> MichaelBurge: I've been enjoying your blog very much, btw (assuming you're @TaurineAndCode )
13:38:58 <MichaelBurge> shapr: I'm him. Should be a new one out soon, actually.
13:39:04 <shapr> yay!
13:41:43 <adjointfunctor_> MichaelBurge, can you link your blog please?
13:42:49 <MichaelBurge> adjointfunctor_: Here's a fun one to start with: http://www.michaelburge.us/2017/09/10/injecting-shellcode-to-speed-up-amazon-redshift.html
13:43:46 <shapr> The blockchain article was great, I learned some details I'd never quite grasped before.
13:43:57 <adjointfunctor_> MichaelBurge, tnx =)
13:44:36 <shapr> I still don't really get Cofree, but I have a much better understanding of Free monads, so that's something.
13:46:50 <greatgig1> hey, what's the difference between using  `div`  and (\)
13:47:00 <greatgig1> (/)*
13:47:06 <mauke> div is integer division
13:47:13 <mauke> / is for fractions
13:47:22 <greatgig1> @-@
13:47:51 <greatgig1> Thanks :D
13:47:58 <adjointfunctor_> :t div
13:48:01 <lambdabot> Integral a => a -> a -> a
13:48:05 <adjointfunctor_> :t (/)
13:48:08 <lambdabot> Fractional a => a -> a -> a
13:48:24 <mauke> looking at the types? that's cheating
13:48:30 <greatgig1> ahahah
13:48:50 <adjointfunctor_> yeah? lets duck-type them :^)
13:48:55 <MichaelBurge> shapr: I mostly use Cofree to get the free typeclass instances. You use a variable wherever you want Traversable to recurse into; otherwise you use a fixed type.
13:49:04 <greatgig1> I am really confused at some stuff, but I guess it does make sense
13:50:21 <greatgig1> is there anyways to cast types?
13:50:45 <mauke> no
13:50:58 <mauke> there are some conversion functions, of course
13:51:07 <mauke> > floor pi :: Int
13:51:11 <lambdabot>  3
13:51:25 <adjointfunctor_> greatgig1, Yes, but you don't need that in your everyday code
13:52:10 <greatgig1> Thanks guys :)
13:52:52 <Psybur> So now when I switch from Control.Monad.RWS to Control.Monad.Trans.RWS.Lazy I have to start using liftIO instead of lift. Is using the Trans package the right way to do it? https://glot.io/snippets/etztra8kwo
13:53:13 <Psybur> Or should I stick with Control.Monad.RWS ?
13:53:30 <Psybur> Or, would Strict be better than lazy? D:
13:54:04 <greatgig1> fromIntegral also works 
13:54:04 <adjointfunctor_> Psybur, you are using a monad transformer, this has nothing to do with strictness
13:54:07 <greatgig1> :D
13:54:37 <Psybur> adjointfunctor_, what is the difference between  Control.Monad.Trans.RWS.Lazy and  Control.Monad.Trans.RWS.Strict then?
13:55:11 <greatgig1> because the HackerRank website asks for a fraction print, I had to use that convert
13:55:22 <adjointfunctor_> Psybur, one is lazy, other is strict =)
13:55:27 <Psybur> D:
13:55:33 <Psybur> How do I know which one to use?!
13:55:43 <Psybur> And should I use one of these instead of Control.Monad.RWS
13:56:35 <MichaelBurge> Psybur: You should always use the strict version.
13:58:58 <[exa]> Psybur: use lazy only if you plan saving bottoms/undefineds to the state
13:59:36 <Psybur> ALso lets say I am building up a monad using a recursive function and a list. What do I return on the empty list? I dont think return () would be what I want?
14:00:23 <Psybur> Lets say I have Just 1 >> Just 2 >> ??? what could I put in for ??? that would return Just 2
14:00:56 <Psybur> (thats not Just 2 :D)
14:01:01 <Psybur> []
14:01:03 <johnw> nothing
14:01:17 <johnw> >> means dropping the '2'
14:01:52 <[exa]> Psybur: you can try Just 2 >>= Just (which should move the value just right)
14:02:02 <johnw> yeah, >>= carries the 2
14:02:19 <[exa]> but this example is super-artificial. :]
14:02:37 <[exa]> also, you can use "return" as a synonym for Just if you're in Maybe monad
14:03:18 <Psybur> So lets say Im building up a RWST using a list. I get to []. How do I just return the current rwst?
14:03:44 <johnw> how do you "build it up using a list"?
14:03:57 <adjointfunctor_> Psybur, also, what do you mean by "building up a monad"? Are you trying to `sequence` your states?
14:04:17 <Psybur> Using a recursive function
14:04:58 <[exa]> so you have a function that manipulates the RWS state and calls itself, and need to terminate the recursion?
14:04:58 <Psybur> https://pastebin.com/XmjkEjHC
14:05:16 <Psybur> Yes. Line 2 is where Im stuck
14:05:39 <[exa]> return ()
14:05:45 <[exa]> your type signature says it
14:06:22 <[exa]> (maybe with some lifting)
14:06:24 <Psybur> Ok. Thanks. Was thinking that, but wasnt sure.
14:06:51 <Psybur> IT compiles, lets see how it goes ;p
14:07:59 <Psybur> See you guys later. Thanks for all the help
14:08:31 <[exa]> the RWS internal state gets conserved automatically from how monads work, you don't need to return that state. Only if you wanted to return some value that someone else would bind later, ie. the 'a' from (RWST r w s m a)
14:08:43 <[exa]> if i remember the type right
14:18:32 <Athas> Can I get stack to tell me why it's recompiling a seemingly unrelated module when I change a module in my application?
14:27:38 <zachk> > let f n = foldr (.) id . take n $ repeat (.) --was thinking about this last night and even if you get past the polymorphism problems of the list of (.) the return type depends on the value of n , so would this require depdendent types?
14:27:43 <lambdabot>  <no location info>: error:
14:27:43 <lambdabot>      not an expression: ‘let f n = foldr (.) id . take n $ repeat (.) --was t...
14:27:52 <zachk> in f 2 even
14:32:12 <erisco> first figure out how to make sense of  foldr (.) id [(.)]
14:32:44 <zachk> even if I could, I think it requires dependent types
14:33:22 <erisco> first figure out how to make sense of  foldr (.) id (Identity (.))
14:33:46 <zachk> is Identity the Identity functor?
14:34:40 <erisco> :t (Identity, runIdentity)
14:34:42 <lambdabot> (a1 -> Identity a1, Identity a2 -> a2)
14:38:22 <ioref_question> Let’s say I’m in a do block, with byte strings x and y, and IORefs x’ and IORefs y’. I write “writeIORef x’ x” and “writeIORef y’ y” one line after another. Why would it be then when I check the contents of x’ and y’, both have x written to them, and not x and y?
14:38:44 <zachk> :t foldr (.) id (Identity ($))
14:38:46 <lambdabot> (a -> b) -> a -> b
14:39:10 <ertes> ioref_question: please paste your code
14:39:14 <ertes> @paste
14:39:14 <lambdabot> Haskell pastebin: http://lpaste.net/
14:39:35 <ertes> ideally including the reading part
14:39:54 <WarmCookie> Hi. Does Haskell has any facility to load a dynamic library and find (and call) arbitrary symbols at runtime? Everything I read on the FFI always mentions foreign imports to add to your code, but it's not what I'm trying to achieve.
14:40:23 <ioref_question> http://lpaste.net/4432026273715322880
14:40:36 <ioref_question> sorry about the line numbers xP
14:41:27 <ioref_question> key and counter are of type IORef ByteString, and Seed is of type bytestring
14:41:36 <ertes> ioref_question: what are the types of 'reseed' and 'inc'?
14:42:25 <ioref_question> type GeneratorState = (IORef ByteString, IORef ByteString), type Seed = ByteString, reseed :: GeneratorState -> Seed -> IO (Either String GeneratorState)
14:42:35 <ioref_question> inc :: ByteString -> Either String ByteString
14:43:14 <WarmCookie> I feel like I'll need an FFI wrapper around the C libdl, just so I can do dlopen() and dynamically do the rest.
14:44:56 <ertes> ioref_question: no obvious mistakes there, as far as i can tell…  so you're getting the output "key=…" and "counter=…" with the same value?
14:46:18 <ertes> WarmCookie: there are ways to load haskell objects by using the GHC API…  there is also a high-level wrapper around it called 'hint', and i know that you can use it to embed a haskell *interpreter*, but not sure about dynamic loading
14:46:44 <ioref_question> ertes: yes, here's the output when I run it in stack ghci
14:47:01 <ertes> WarmCookie: there are a bunch of plugin systems on hackage, and they usually have "plugin" in the name or synopsis, so you can easily find them here: https://hackage.haskell.org/packages/
14:47:32 <ertes> WarmCookie: not sure if any of them are good, but at least you can check out how they do it
14:47:41 <ioref_question> "key=\"\\NUL\\NUL\\NUL\\NUL\\SOH\"" "counter=\"\\NUL\\NUL\\NUL\\NUL\\SOH\""
14:47:52 <Tuplanolla> Here's the dirty way, WarmCookie: https://github.com/Tuplanolla/ld-prehaskell
14:48:27 <ertes> ioref_question: are you sure 'inc' and 'sha256' work as intended?
14:49:11 <ioref_question> http://lpaste.net/1215684050681856000
14:49:14 <ertes> ioref_question: (side note: you may want to use 'putStrLn' here rather than 'print')
14:49:53 <ioref_question> http://lpaste.net/7052849132012044288
14:50:24 <ertes> ioref_question: test those functions first
14:50:43 <ioref_question> ertes: putStrLn on these bytestrings produces empty strings (the only nondeprecated putStrLn is in Data.ByteString.Char8, and my bytestrings aren't necessarily ascii)
14:50:53 <ioref_question> they work as expected
14:51:08 <ioref_question> I even printed the values of the bytestrings before I used writeIORef
14:51:12 <ioref_question> they were different
14:51:29 <ioref_question> but when I used writeIORef, both IORefs got written with the same value
14:51:31 <ertes> ioref_question: huh?  as far as i can tell you're printing String, not ByteString
14:51:55 <ertes> ioref_question: that sounds like a bug
14:52:22 <ioref_question> all of the strings (Sans the one in a Left constructor) are bytestrings in the function
14:52:29 <ioref_question> so it's a problem with IORef?
14:52:40 <ertes> ioref_question: try atomicModifyIORef instead of atomicWriteIORef
14:54:02 <ertes> ioref_question: i'm not sure…  what happens if you use a different hash function?
14:55:01 <ioref_question> still same deal
14:55:05 <ertes> background: hash functions are often implemented using mutation for efficiency reasons…  it's easy to produce a bug there, particularly with ByteString that doesn't offer a nice safe mutable API like e.g. Vector does
14:55:41 <ioref_question> atomicModifyIORef key (\_ -> (newKey, ())) is what I tried
14:55:55 <ertes> ok, as a final test, please try a different hash function
14:56:14 <ioref_question> and hmm. initially it worked when it wasn't mutable. I just had to make it mutable for another part of this project to work
14:56:26 <ioref_question> okay, sounds good
14:57:36 <ertes> well, IORef is kinda magic…  it might interact badly with other unsafe tricks when there are subtle bugs
14:59:48 <ioref_question> ertes: I can see that haha. MD4 doesn't do anything either
14:59:55 <ioref_question> maybe it's the entire cryptonite package
15:00:20 <ertes> ioref_question: try this: atomicWriteIORef key (BS.copy newKey)
15:00:27 <ertes> perhaps use BS.copy on both
15:02:02 <ioref_question> nope, same deal :/
15:02:18 <ioref_question> I appreciate all of the avenues of attack you're supplying though!
15:02:58 <zachk> ioref_question, is your code multithreaded or parallel at all? maybe an MVAR or stm reference then
15:03:04 <ertes> ioref_question: what happens, if you don't use a hash function at all?  replace 'sha256' by 'id' or by 'inc' or any other simple operation
15:03:25 <ertes> err, not 'inc' though =)
15:04:10 <ioref_question> nope, all singlethreaded. And I'll test that out!
15:04:34 <ioref_question> same exact thing
15:04:38 <ioref_question> so it's not the has function
15:04:41 <ioref_question> *hash
15:05:10 <ertes> that's weird…  it might be a bug in bytestring
15:05:52 <ioref_question> maybe for GeneratorState, instead of a tuple of IORef ByteStrings, an IORef of a tuple of bytestrings would help?
15:06:06 <ioref_question> and that's be pretty bad, considering how important the library is haha
15:06:45 <ertes> if you combine that with atomicModifyIORef, then would improve your API in many ways, including being thread-safe, if you do it properly =)
15:07:53 <ertes> well, if it's really a bug in bytestring, you must have somehow caused some kind of super-unlikely bug
15:07:58 <ioref_question> okay, wish me luck! thanks for all of the help!
15:08:04 <ioref_question> hurray? lol
15:08:15 <ertes> a cynical hooray!
15:08:23 * supercynic waves
15:08:29 <Cale> I just missed that, what was the potential bug?
15:08:45 <supercynic> Cale: http://lpaste.net/4432026273715322880
15:09:09 <supercynic> the IORefs have the same value after the two atomicWriteIORefs
15:09:22 <supercynic> but ioref_question has verified that the values they write are not equal
15:09:25 <ioref_question> ^what supercynic said
15:10:10 <Cale> hmm
15:10:19 <Cale> and this is the only thread?
15:11:04 <ioref_question> yup, don't touch any MVars or STM
15:11:30 <supercynic> ioref_question: ok, one final test before i go to bed: could you print newKey and newC as well?
15:11:34 <Cale> Well, IORefs can be modified by multiple thread
15:11:34 <Cale> s
15:12:23 <supercynic> just to be safe
15:12:40 <erisco> mutable state in a multi-threaded environment
15:12:54 <adjointfunctor_> ioref_question, can you paste all your code to https://glot.io/new/haskell
15:13:06 <supercynic> <ioref_question> nope, all singlethreaded.
15:15:02 <ioref_question> supercynic: okay
15:15:38 <WarmCookie> Tuplanolla: ertes  Can `plugins` load C .o files dynamically? Ideally .so or .dll would be best but .o is fine too.
15:16:04 <Tuplanolla> No clue.
15:16:07 <ioref_question> "newC=\"\\NUL\\NUL\\NUL\\NUL\\SOH\"" "newKey=\"\\SOH\\212H\\175\\217(\\ACKTX\\207g\\v`\\245\\165\\148\\215\\&5\\175\\SOHr\\200\\214\\DEL\\\"\\168\\SYN\\128\\DC3&\\129\\202\"" "key=\"\\NUL\\NUL\\NUL\\NUL\\SOH\"" "counter=\"\\NUL\\NUL\\NUL\\NUL\\SOH\""
15:16:12 <WarmCookie> Tuplanolla: My use case is a little interpreter written in Haskell for a language that needs to have a FFI with C.
15:16:18 <WarmCookie> Okay thanks.
15:16:34 <ioref_question> so the counter is right
15:16:42 <ioref_question> but key should be identical to newKey
15:17:23 <ioref_question> http://lpaste.net/4678529900125093888
15:17:59 <ioref_question> stack ghci prompt and output used to test the code:
15:18:00 <ioref_question> http://lpaste.net/3633245004714999808
15:23:04 <supercynic> i'm out of ideas, but i'd be very interested how this goes
15:23:10 <supercynic> but for now: good night =)
15:23:45 <ioref_question> supercynic: no worries! I appreciate the help regardless! I'll try changing my GeneratorState type and see what happens
15:23:46 <ioref_question> good night!
15:32:03 <Cale> ioref_question: where's that sha256 coming from?
15:32:39 <Cale> ioref_question: (and does the behaviour still happen if you replace that with something else?)
15:33:02 <MichaelBurge> ioref_question: Stack runs your program multithreaded by default. If you're using stack, you could try explicitly disabling that
15:34:11 <Cale> Well, it runs it with the threaded runtime, but that shouldn't matter too much if you're not actually using forkIO
15:35:13 <Cale> oh, also what is inc?
15:35:50 <byorgey> adjointfunctor_: a diagrams-blender backend would be super cool
15:36:40 <MichaelBurge> Cale: It could be stack exec specifically, but I have code that isn't using forkIO explicitly anywhere which still uses 800% CPU, and I can see 16 subthreads on a 16-core process with strace.
15:36:51 <MichaelBurge> Cale: I assumed GHC had something to automatically parallelize code
15:38:06 <Cale> MichaelBurge: It might use libraries which forkIO, or else there might be pure parallelism in use
15:38:28 <Cale> There's nothing to automatically parallelise code, but there are par annotations
15:38:58 <Cale> par x y will evaluate to y but add x to a queue of expressions to be evaluated if there's time available before they are needed
15:41:47 <adjointfunctor_> byorgey, it would be, it is a matter of generating .blender files correctly, and their binary format is unusual, they have C function names saved to file and called while loading, for instance
15:42:20 <adjointfunctor_> byorgey, and that function names are different between versions, and blender takes care of it on the fly
15:49:00 <ioref_question> For all those who were curious, changing GeneratorState from (IORef ByteString, IORef ByteString) to IORef (ByteString, ByteString) fixed the problem :)
15:53:38 <adjointfunctor_> ioref_question, it is still interesting why that happened
15:58:11 <poindontcare> is there somewhere some sort of  heuristics for debugging functional programs ...so hard
16:03:52 <edwardk> There are days when type level programming in Haskell lead me down some very loong deep rabbit holes.
16:04:03 <edwardk> *leads
16:04:45 <erisco> I'm late for an important date!
16:04:58 <ioref_question_> adjointfunctor_: maybe IORefs inside data constructors are just bad news
16:05:14 <edwardk> erisco: spending more time checking my pocketwatch might have been a good idea this time ;)
16:05:56 <edwardk> -- and at this point is where I realized I reached for the wrong data structure for vec... https://www.irccloud.com/pastebin/WLzn54fa/Zeroless.hs
16:06:30 <edwardk> if nothing else, it might be informative to someone who wants to play around with zeroless binary numbers
16:06:57 <edwardk> unfortunately it doesn't serve the original purpose i was putting it to
16:07:36 <poindontcare> embrace the zero
16:07:37 <edwardk> the zeroless vector type is kinda cute
16:08:06 <edwardk> it was also the first time i think actually bothered to write addition for zeroless binary
16:11:23 <edwardk> time to go figure out how to implement brodal's fast join tree instead
16:41:45 <cryptonite_quest> hey, so I'm trying to use cryptonite's aes256 block cipher, but when I try to use bytestrings, I get a keysize invalid error
16:41:47 <cryptonite_quest> http://lpaste.net/150328889061670912
16:42:14 <cryptonite_quest> and I'm not entirely sure how to remedy it. Cryptonite's documentation isn't the greatest...
16:44:07 <verement> cryptonite_quest: AES key size probably needs to be 16, 24, or 32 bytes
16:45:29 <verement> actually aes256 is probably 32 bytes
16:45:50 <cryptonite_quest> oh!
16:45:58 <cryptonite_quest> zero is 5 bytes in bytestring
16:46:07 <cryptonite_quest> so basically any key that goes into that function has to be elongated to 32 bytes?
16:47:13 <verement> you probably want to use a key derivation function that outputs the correct size
16:48:03 <cryptonite_quest> right now I'm using Data.Serialize's encode function to turn the integer 0 into a bytestring
16:48:17 <cryptonite_quest> would I have to create an alternative encoding function?
16:48:23 <verement> yeah that's not a very good key derivation function
16:49:07 <verement> look for something like PBKDF2
16:50:44 <cryptonite_quest> okay, I will try that. Thanks, verement!
17:29:53 <pierrot> If I do `:t (<*>)` in ghci I get the more general type of that operator. How can I paritularize it to case of lists?
17:30:12 <pierrot> s/more/most/
17:30:26 <erisco> :t (<*>) @[]
17:30:28 <lambdabot> error:
17:30:28 <lambdabot>     Pattern syntax in expression context: <*>@[]
17:30:28 <lambdabot>     Did you mean to enable TypeApplications?
17:30:35 <erisco> yes, yes I did lambdabot
17:30:56 <erisco> :t (<*>) `asAppliedTo` [undefined]
17:30:57 <lambdabot> [a -> b] -> [a] -> [b]
17:31:46 <pierrot> Thanks, erisco :)
17:39:35 <pierrot> Where is the function asAppliedTo defined? Or is it just a bot feature?
17:40:18 <geekosaur> @where L.hs
17:40:19 <lambdabot> what lambdabot has in scope is at http://silicon.int-e.eu/lambdabot/State/Pristine.hs
17:42:26 <Welkin> :t asAppliedTo
17:42:28 <lambdabot> (a -> b) -> a -> a -> b
17:43:33 <pierrot> thanks, geekosaur 
17:45:34 <pierrot> in the case of (<*>) `asAppliedTo` [undefined], what's the role of a and b (in the definition of asAppliedTo) ?
17:45:53 <erisco> they cast as type variables
17:46:01 <pierrot> I know
17:46:05 <pierrot> but what types would be those?
17:46:12 <pierrot> (in this particular case)
17:47:09 <erisco> :t asAppliedTo `asAppliedTo` ((<*>) `asAppliedTo` [undefined])
17:47:11 <lambdabot> ([a -> b] -> [a] -> [b]) -> [a -> b] -> [a -> b] -> [a] -> [b]
17:47:26 <geekosaur> unspecified, which is the point were they specified theyd not be returned as type variables
17:48:22 <pierrot> Thanks, erisco 
20:19:02 <MarcelineVQ> What other mostly lazy languages are there besides haskell? And/or mostly non-strict
20:19:20 <monochrom> LazyML.
20:23:08 <MarcelineVQ> thank you
20:23:55 <Axman6> @pl \x -> if p x then f x else pure x
20:23:56 <lambdabot> ap (liftM2 if' p f) pure
20:33:58 <vimalloc> So for working with code that can fail in IO monad, I've been using Either, but it feels kinda cumbersom to use. I'm thinking it might make more sense to use exceptions instead (added bonus that some underling calls could fail as well, and already use exceptions). Does that seem reasonable?
20:34:54 <vimalloc> If so, follow up, would safe-exceptions be a better choice then Control.Exception. Can I mix and match those?
20:35:07 * vimalloc could probably google the last question. I'll do that :)
20:42:31 <robertkennedy> Should I expect to lose anything using polymorphism for extremely local functions? Ie `module M where {f :: [Either String a] -> IO [a]; g xs = h xs >>= f}
20:42:59 <robertkennedy> I should have made clear it's `module M (g)`
20:43:59 <robertkennedy> Ie, f is only called in g, and let's say g is monomorphic. Can I write the general f with no expected loss?
20:44:44 <rotaerk> what are you thinking you could lose?
20:45:49 <robertkennedy> Well with ie unpacked sum types, it seems like GHC has really sophisticated specialization. That's what I'm afraid of losing
20:46:39 <nshepperd> performance i assume
20:46:46 <edwardk> Data.Sequence without split but O(1) append while retaining O(log n) indexing https://www.irccloud.com/pastebin/0iFqKNuN/Seq.hs
20:47:03 <edwardk> ^- i wasn't able to get the brodal type to work, but i did get the parts of the asymptotics i wanted in another structure.
20:47:38 <nshepperd> robertkennedy: un-constrained polymorphism is free in terms of performance afaik
20:48:22 <robertkennedy> In example, I believe that `fmap f . fmap g` is not generally rewritten to `fmap (f . g)`, but `map f . map g` is. Can I expect single module compilation to factor away these annoyances?
20:49:19 <nshepperd> it'll be fast if it's inlined
20:49:23 <edwardk> robertkennedy: the problem is that fmap f . fmap g = fmap (f . g) is only sound in the presence of the fmap id = id rule (and a free theorem) so its not something the compiler can safely do for all instances. it just don't know if your Functor instances are sound.
20:51:13 <robertkennedy> edwardk: right. So if in the module I write an `h` with the fmap version, and only use `h` in `g` which is specialized to List , can I trust GHC?
20:52:15 <edwardk> robertkennedy: if you crank up to -O2, etc. and only ever use a function at one type, its a reasonable bet that it might specialize. if you don't trust it, you can always write the SPECIALIZE pragmas yourself
20:53:34 <edwardk> alernately if you just want to force fusion regardless there are always options like smacking your types upside the head with yoneda.
20:53:42 <robertkennedy> Tight. I was refactoring and rewriting some 1.0 code that had internal functions with needlessly specialized type signatures, wanted to make sure I did no harm
20:54:01 <robertkennedy> I've not heard of yoneda
20:56:06 <edwardk> newtype Yoneda f a = Yoneda [ runYoneda :: forall r. (a -> r) -> f r } -- is a functor even if f is not. putting on my scary category theorist hat i can make high-minded sounding claims about how its the cofree functor... but basically you can view it as fmap partially applied to its second argument. repeated fmaps over Yoneda   merge together the calls so that hen you finally lower back to f a  by passing it 'id' you get all the calls
20:56:06 <edwardk> made at once.
20:56:30 <edwardk> its basically a way to enforce fmap fusion through types
20:56:56 <edwardk> Codensity similarly right associates all of your >>='s for you. both are provided by my kan-extensions package IIRC
20:59:25 <robertkennedy> while I have you, can I ask what category theoretic notion hits you with types like `withX :: (X -> m a) -> m a`?
21:00:04 <robertkennedy> Codensity is what reminded me of this
21:00:07 <mniip> that's just a continuation
21:00:14 <robertkennedy> Yeah it is
21:01:24 <edwardk>  ContT a m X -- is what i see when i'm given that =)
21:01:59 <robertkennedy> But I'm trying to write functions that provide limited sets of X's to run these functions against, so that's why I'm asking if it's well solved
21:02:50 <edwardk> well, i use a variant on it for talking about vector spaces and the like, but there i know something about 'a'
21:02:50 <robertkennedy> edwardk: `a` isn't the last variable? Wouldn't you want a Functor with a?
21:03:06 <edwardk> 'a' occurs in both co and contravariant position in that type
21:03:25 <edwardk> newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
21:03:33 <edwardk> alpha renaming gets you ContT a m X
21:04:33 <edwardk> anyways due to a occurring both co and contravariant that isn't even a Functor in 'a' let alone something fancier
21:06:42 <pacak> Hmm... Any links on code that uses ContT in a good way?
21:07:21 <robertkennedy> I'm imagining something like `withSession :: (Session -> IO a) -> IO a`, exposing functions like `getOne :: Url -> Session -> IO ByteString`, where the Functor on IO is used throughout
21:09:29 <pacak> withSession looks like something that would handle exception and ensure that any resources are released if action fails.
21:10:03 <pacak> "withFile name mode act opens a file using openFile and passes the resulting handle to the computation act. The handle will be closed on exit from withFile, whether by normal termination or by raising an exception. If closing the handle raises an exception, then this exception will be raised by withFile rather than any exception raised by act. "
21:11:13 <robertkennedy> Then I'm doing something like `withSemaphore :: Int -> ContT a m x -> (b -> x -> m a) -> [b] -> m [a]`
21:13:10 <robertkennedy> withFile is a difficult example to fit in here, I think. withDB and withSession work well
23:31:53 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | https://summer.haskell.org Summer of Haskell 2017'
23:31:53 --- topic: set by mauke!5lzdiZJQGk@p3m/member/mauke on [Mon Jul 31 05:45:11 2017]
23:31:53 --- names: list (clog Antoxyde nullifidian_ ackpacket jesuspv _vaibhavingale_ danvet seveg leat robb fresheyeball felixonmars shangxiao pimlu connrs xzhu HallaSurvivor infinity0 olligobber dec0n alfredo total1ty thunderrd Warrigal samrat_ boj rickerbh shafox btk ThomasLocke dan_f takuan forgottenone martingale eacameron hamishmack ccomb descender Lokathor osa1 robertkennedy `Guest00000 alex`` osfameron toblorone sgflt cyberlard runde erikd Amadiro marienz et4te hodapp)
23:31:53 --- names: list (mikeplus32 Orbstheorem apeyroux amx _ashbreeze_ kwantam meck fakenullie SCHAPiE peddie dminuoso Atlantic777 plutoniix suppi oldsk00l Foritus nek0 sveit dpepsilon zipper pelegreno a3Dman m00n alexbiehl ggherdov sdothum vili_ danieli dysfun knmae aweinstock garphy brynedwards datajerk jared-w __main__ jbalint Velpoman tsani Guest15255 kloeri bogdanteleaga fryguybob gnusosa catern kuttifunk Cathy filwisher anderson __name__ anhduy Sornaensis baweaver spion_)
23:31:53 --- names: list (c_wraith wadadli armyriad nurupo lambdabot eddsteel cheshircat koz_ martintrojer henrytill rmarko ramatevish mimi_vx sleepynate levex_ benonsoftware waylon531 Raptor8m3_ Methos_ parsnip richi238 WhereIsMySpoon_ alveric3 a3f cods_ hongminh1e predator217 frontend1oader fgaz_ [exa]_ ycheng_ destiny__ nshepperd Liskni_s1 tomasino1 quicksilver amiri_ klugez yoneda_ eagleflo_ bcoppens_ Guest18532 fxrs nahra` Wamanuz2 CindyLin1 jamiis_ carlomagno1 kloplop321)
23:31:53 --- names: list (lachenmayer_ okuu robotroll seliopou_ implementation Burnout641_ rirc_3083 iqubic hiratara juhp augur schoppenhauer dfeuer otto_s govg chrissl eazar001 perrier-jouet hulufei liyang DTZUZU aarvar quazimodo Parraki KoH banc ncvvdoc mjamal14[m] hucksy_ lambdamu efm Youmu zv hackagebot Destol ammazza Nik05 cschneid_ athaller mulk nighty- Khisanth andyhuzhill MP2E justanotheruser XorSwap sellout- louispan dcoutts jrabe codesoup theDon cpup cpup- petervaro)
23:31:53 --- names: list (ericsagnes m0rphism2 nakal_ adamCS jimmyrcom dysfigured tv atomi stelleg hive-mind zzq OnkelTem mitchty zero_byte ericdwhite jdevlieghere Fubar^ Vq eschnett mad[m] ahihi kus_ubuntui686 butterthebuddha kolko asthasr beerdrop stoopkid__ riatre ortmage toby1851 xinming bastelfreak poindontcare revprez_stg mkoenig mlen revprez_1k revprez_atlanta ekr Vorpal Someguy123 voice_ftp Unhammerd marvin3 verement raynold hjshf revprez_yk megaTherion_ mauke Jesin dsfox)
23:31:53 --- names: list (LiaoTao midiparse kuwze byorgey zaquest pacak CurryWurst greatgig1 MarcelineVQ ph88 Benzi-Junior Ranhir dmiles ssarah TommyC Majiir cyphase lassulus mk-fg fergusnoble xpinguin froztbyte piyush-kurur magthe Yuras zariuq wonko7 athan mzf sw1nn eatman twomix araujo fonadius[m] geekosaur revprez electrostat Sgeo clinton baetheus orcus SuprDewd takitus g2 avatias0[m] xaviergmail MitchW Tesseraction_h taktoa sheyll bluepixel Sonderblade chlong smyds Philonous)
23:31:53 --- names: list (lkolstad kensan slackman esssing tessier sqrt2 hc wrengr_away troydm dedgrant vimto taaperotassu electrocat wisha[m]1 ephemera_ SlashLife xdelv Adeon lopex jdnavarro stevenxl TheBrayn cchalmers rossberg dynrzk Natch Sigyn whald MichaelBurge maerwald beaky prooftechnique ambrosia Durbley caasih qwertydvorak besenwesen LnL cgfbee owickstrom solatis mark_c wto atk bydo otulp notshloub jamiecook_ texasmynsted SkyPatrol Bmw^ Mistv[m] Digit WorldControl gehmehgeh)
23:31:53 --- names: list (ertes grumble heurist acro noam__ srhb Tharbakim geetam catsup coup_de_shitlord dmj` bsmt AndreasK thallada alexelcu dashed jgornick m3tti[m] hiq[m] M-kitsune bramvdbogaerde[m Squidnyan[m] rizo[m] Verandetten[m] dpacbach[m] R0b0t1_ defanor nesqi tnks duncan^ hiredman aijony ego Maxdamantus Shatnerz leothrix thomashoneyman abrar xxpor jfredett mt Dykam Reyu[m] jsonhigh[m] leah2 StoneToad ons APic Robin_Jadoul hrnz obiwahn max-m malt3 charlag[m] Intensity)
23:31:53 --- names: list (remexre pfoetchen arw sdx23 ClaudiusMaximus bs Xal _6a68 cschneid c0ff33[m] Forkk oozz[m] swalladge dolio falafel Fairy Cthalupa pikhq milli mdarse nille jtcs amf xormor bsima Pilfers teqwve reu madknight dxtr kmicu runawayfive Reisen Immune jluttine dustinm rotaerk hvr nick1234 ph88^ robogoat hpc NinjaTrappeur jophish mjo theorbtwo Xe ijp rjeli zekt Akii cynick Ankhers Meanirelli lstrano amatecha telser barrucadu dogui tokik mathu hanDerPeder gargawel kg)
23:31:53 --- names: list (kini Guest22103 bustillo[m] nullset[m] o0o[m] kyren_ stay_noided wagle Purlox Limeth_ qzo m1dnight_ Brando753-o_O_o bwe mendez paroxp cgag dsm__ ixian yahb minad gleber_ m4lvin Niamkik vikraman andirc8000 NemesisD aniketd[m] gareth__ rbocquet terrorjack Lord_of_Life Klumben chriswk tazjin Guest63586 rodarmor nelll canta wyvern stig ids1024 fbreitwieser[m] asenski[m] rembo10 SegFaultAX jzl Guest17559 S007 huonw Ninja3047 cocreature mstruebing valkyr2e soncodi)
23:31:53 --- names: list (davl jmct peteretep ephemeron nyuszika7h andyo altooid sujeet Laney sivs tarcwynne__ rjungemann fingerzam mbeidler h30 mikedlr tjpeden Blkt pierrot abbe asjo BytesAndCoffee echoreply Sose ziman centril Tuplanolla Deadhand changyj phadej drcode iw00t etXzat[m] jdt jameseb sdhand Taneb drdo yeeve nathyong Emantor ps-auxw dibblego bollu mceier Zemyla statusbot bencryption papapishu lyxia pdxleif anishathalye tomku RayNbow`TU hanna Hafydd iphy staffehn gilbertw1)
23:31:53 --- names: list (Guest52504 himmAllRight[m] brixen wting mutsig DustyDingo amerlyq nekomune opqdonut AWizzArd fiddlerwoaroof mniip zeroed mou shutdown_-h_now monochrom Kneiva dumptruckman rdococ jchia mgttlinger Mcpurplemuffin[m noteventime vishesh logcat Guest431 cjwelborn toppler vfs tpreston tabaqui gspia woggin nwf Guest291964[m] eyenx Rubas[m] rprospero[m] rimon[m] Guest312594[m] Bimmie[m] Vipernet1220[m] sssi1ver[m] scrypso[m] Guest1573[m] seto[m] jnonpony[m])
23:31:53 --- names: list (hesiodos[m] yaspoon[m] dlandau[m] Monad[m] akshay7777[m] boash[m] ptek[m] magog[m] ElliotKiyomizu[m mk[m] zmre[m] Andry976[m] grahf[m] Jasonjunsu[m] joakimf95[m] JohnnyReb[m] prot[m] KENNYNR1[m] shekel[m] mascht[m] M0xfiras[m] Guest340521[m] toa[m] psan[m] M\u202e[m] guest121[m] ArrayWindrunner[ mrhunky[m] kebertx[m] KevinMGranger lixiang4u[m] am2on dbramucci[m] sphalerite M-HirmeS fgaz[m] Zarthalan[m] nimbus[m] peel[m] howsiwei[m] asm[m]1 BartGroeneveld[m)
23:31:53 --- names: list (adziahel[m] Niboor[m] mrgraffe[m] km42[m] gylpm[m] astronavt[m] scanleft[m] goolord[m] nine-h[m] jsgrant[m] ramirezD[m] mrdaak[m] djquant[m] Drakonis[m] caro401 ycy[m] razvanc-r[m] antiless[m] ya-alex[m] pacmansyu[m] Cadey[m] DavesTestingAcco pyrtheibarit[m] XertroV[m] Shaunthesheep[m] JHBrannam[m] TimWolla[m] MarkusK[m] polux[m] riaqn felipeac[m] mlainz[m] joncfoo[m] rcat[m] jvalleroy[m] Luguber[m] ajtowns[m] thekyriarchy__ tobim[m] saci[m] cuddly[m])
23:31:53 --- names: list (WinterFox[m] SansFr[m] magnap Courage[m] unclechu schum[m] adampaigge[m] WolfLightning[m] TristanBKildaire moka[m] Naughtmare[m] superobserver[m] lucnx[m] chominist[m] Akito[m] Nerka[m] beemo[m] M-herah ThousandLions[m] abbiya intheclouddan[m] laaksoan[m] mrhania[m] M-rgh Deleh[m] Barnabas[m] mtncoder[m] el_tejon[m] ltq520[m] talesmantovani[m memoryruins[m] AX3L[m] dkellner[m] synopz[m] LucasFrancesco[m ninegua[m] levzhazeschi[m] Michi[m] ttk2[m] softashell)
23:31:53 --- names: list (emme[m] Dako300[m] okkk tommy0010[m] jacobleach[m] wisn[m] rydia5[m] psYchotic[m] roninkaizen[m] elpfen[m] Maikel_Experius[ phittacus stites[m] ddbbuu[m] lonokhov[m] pingfreud[m] zhangjiji[m] lkh[m] thisLight[m] NickSeagull[m] testtt55[m] spotter[m] innaytool[m] kimchi[m] yashi[m] kilian[m] Adau[m] ItevNabdifNi[m] sebisebi[m] mith[m] romanzolotarev[m toumi124[m] closures999[m] masaeedu[m] zukonake[m] naviknair7[m] Novitsh[m] ketanhwr subz[m] Asiannoodles42[m)
23:31:53 --- names: list (phil_frontal[m] futpib[m] CryptoCalsius[m] plll[m] M-schmittlauch M-ms wubbalubbadubdu4 equalunique[m] khac[m] crapman[m] moonrunes[m] Rifa[m] idnar[m] puffnfresh etcinit[m] M-Illandan Obscurity[m] strixy[m] thekyriarchy wizzup[m] Matthew[m] ElyKar[m] TFX[m] dtcristo riadvargas[m] trikl[m] LangeOortjes[m] slartibartfast[m octalsrc[m] schplaf[m] M-whoops sudoreboot[m] Alexander_Hansen redviking[m] thejonny[m] trevorriles[m] Mike[m]1 s0ra[m] arslanatajanov[m)
23:31:53 --- names: list (SuperW[m] piluex[m] fib11235[m] romanofski[m] MikasiCoyote[m] RGamma rellen hakan[m] undu[m] Nuva[m] kritzcreek goodboy[m] MohdSKhoeini[m] hpd_m M-krsiehl zaphar_ps[m] rakete Soif[m] TylerCecil[m] drasich[m] M-kevinliao Aidan[m] lysgaard[m] NickHu sn[m] angelbeats[m] ollieh M-BostonEnginerd scde WilliamHamilton herzmeister[m] tester668[m] davidar srenatus[m] hendrik[m] cutie davidar_ MatrixTraveler[m aspiwack[m] aer[m] sirius[m] spacekitteh[m] unlmtd bb010g)
23:31:53 --- names: list (berton turt2live tfc[m] jmnoz pellegrino M-berdario trevortknguyen[m reactormonk[m] monomon[m] bennofs[m] jyp[m] unknownln xplat rexor[m] inr dt343gs[m] bod_ chrzyki raibutera grandy____ stass Quintasan Jaxan greeny__ cbaines Paks brolin_empey chelfi3 unidan acfoltzer_ kaffepanna freusque MagneticDuck niluje AlainODea flebron ryanbooker Meow-J Kamuela strmpnk jzelinskie rgrinberg etrepum milessabin johtso Cir0X Athas marcel JoJoen pchiusano JSharp lexi-lambda)
23:31:54 --- names: list (micmus stephe nano- nshepperd_ liste prg318 happy0 worch Zoddo pmn l_zzie spoonm trevorriles Randy joachifm ongy ventonegro int-e joehillen lavalike noexcept x1n4u mngrm4 tekacs Morsicus heath sleblanc bmeynell flux jchia_1 JoelMcCracken tabaqui1 procgen tjbp hiptobecubic cic jrpls erratum newsham lukky513 joeyh pikajude uwap pyrtsa michi7x7 sdrodge rofer Draggor numberten zmanian SAL9000 jinblack ubsan ccase MindlessDrone wedify raatiniemi Ulrar niklasb)
23:31:54 --- names: list (Arguggi Moyst CrazedProgrammer dmwit Qommand0r d6e jorj dfranke fr33domlover ggVGc Ke Deewiant tsahyt vimalloc cfoch-al1 adjivas linduxed vin-ivar Soft MalfaitRobin_ greymalkin japesinator kiboneu vaibhavsagar michalisko treehaqr swhalen janne pasukon carbolymer aminb benzrf navilan comboy cesardv luigy michalrus pita lispy kav gareth_ glguy jlewis asm89 danzimm rootmos jrm pandem cow-orker hsiktas chaosdav iross_ tolt jokester wladz dxld tomasmu przemkovv)
23:31:54 --- names: list (ralu DexterLB jlouis crosleyt twk- StianL Ralith_ sclv tg xacktm brisbin niklasl LeaChim SiCC slester akemot dhtns Ewout markhuge guios squisher byte512 nikivi Gabemo kubrat ljhms sm heinrich5991 Rembane mitch_ sanitypassing statusfailed M2tias ntinos jonrh yrid hydraz kefin bshelden geppettodivacin jrslepak cpallares ByronJohnson Axman6 TakumoKatekari Elsi cheater Willis Morgawr mivael edran Squarism u-ou Ferdirand gesindel scinawa nisstyre aaron7 langkid1)
23:31:54 --- names: list (oberste1n exferenceBot pmade bjs GreySunshine scav grayhatter intelux_ Bigcheese angular_mike___ TRMander1on idupree2 xnyhps bjobjo PotatoGim OliPicard Xorlev ocharles adelbertc jml billstclair lumimies mpickering mkurkov_ bgyss feltnerm solidsnack ryantm noobst spinda wavewave dgonyeo gornikm monad_cat mystfox thoradam nbouscal sa1 mnoonan Enigmagic aib integral c-rog vodkaInferno [swift] dan64 andromeda-galaxy nonzen AntiSpamMeta wtw Guest82765 fairfieldt)
23:31:54 --- names: list (zymurgy magicman eikke HalfEatenPie marble_visions yushyin noctux juri_ syamaoka chirpsal1 ahf dschoepe Ornedan Chobbes Raynes earldouglas harmaahylje fnurglewitz tolt_ aidecoe Voldenet mattp__ agrif Zowlyfon Chousuke malthe fredsir edwtjo petercommand Fylwind bbee shikhin urdh jix jassob stux|RC-only mdupont matthavener codebje posco kshannon RevJohnnyHealey Flonk ctag dh scopedTV ocramius mearnsh lokydor _kit_ epta bgamari pleiosaur nerteren naudiz burp)
23:31:54 --- names: list (aatxe oherrala Gothmog_ miklcct relrod mmaruseacph2 dgpratt _flow_ NocnaShada stefan- sbrg_ hegge_ solarus tumdedum Saizan cjay- tomus Igloo_ bxc caw__ pdgwien- bigs redcedar xplat|work yaknyasn zph wayne Profpatsch Ober xpoqp omilu zebrah michaelw reynir jackhill Clint L8 Frans-Willem admwrd Tourist Frankablu ircbrowse Fuuzetsu dredozubov jsb madsj julmac Xandaros tdammers trcm mak` magnuson ChongLi TimWolla pygospa biancat wizonesolutions tippenein bus000)
23:31:54 --- names: list (Logio ynyounuo bbaren Solarion johnw Geekingfrog lukexi koala_man trosa bartavelle bananagram cross da-x nemesit|znc dpn` tortal ft hexagoxel monty tctara ezyang zerokarmaleft nopf orzo gonekiwi dqd lpsmith zenzike Eliel Yaiyan Unode micro_ kosmikus Deaddy Tehnix davean phaazon libscott e unsymbol avn TyOverby__ Tritlo runeks houli si14 niveus fuziontech RazorX reinh1 discrttm acowley_away fluxit Adluc raid alanz c0dehero Nycatelos fall_ sbauman thoughtpolice)
23:31:54 --- names: list (heyj edofic simony bitonic joel135 rootnode lieven SuperTux88 Netwolf yorick Twey Jinxit bind1 bno2 nshepperd1 chu wedens Tspoon edwardk S11001001 vikram__________ noplamodo Jaak majoh_ andjjj23 brennie Stratege int0x27h geal caro abra0 ncl28 niko padre_angolano Jonno_FTW libbyk Boreeas Drezil supki oleks tek0 bitemyapp hsyl20 arkeet bengt_ ec2-user_ speak zomg raek EvanR wamaral Nikotiini platz alek skeuchel cjh` Desoxy alpounet xa0 brent80_plow ftop sns)
23:31:54 --- names: list (banjiewen TallerGhostWalt hjklhjklhjkl emmflo joeytwiddle quakestor bob_twinkles absence gabiruh Oipo yarou Guest60956 Biohazard amuck Belgarion0 DDR esph Xnuk eL_Bart0 KaneTW MasseR CosmicRay buoto1 qz thoros zachary12 jw358 przembot Jello_Raptor dyreshark blackdog Ring0` suzu myme odamn coeus betawaffle kipras d3lxa jonge nikolah shapr kfish Tristan-Speccy ehubinette mantovani nilOps mgaare wz1000 Hijiri croben bvad exio4 ManiacTwister reptar_ PHO \u so)
23:31:54 --- names: list (zyla tgeeky SolitaryCypher armlesshobo oldsnakey rann karce SolarAquarion tomaw @ChanServ pringlescan carter zgrepc jorendorff dstockwell thi_ ebutleriv zpconn__________ Guest4509 cansis ReinH kyagrd mbrock nkpart SaidinWoT chindy QuantumLogic carc akermu ab9rf ij dsal bbielsa_ tharper_ andrew_n_ angerman georgew stasku cdornan_ spicydonuts rotty elvishjerricco TabAtkins Bengi CARAM___ codedmart iravid Argorok gothos isaac__ mbrcknl_ mindtree jxv bytesighs)
23:31:54 --- names: list (customminer rizary ericbmerritt_ prizim metalrain twold darthThorik joedevivo shans_ Scorchin_ baamonde Heero__ hansihe prefork Tallenz yminsky poga sdemos killtheliterate kgadek lynn frew rom1504 kipd reem noxd paf31 incomprehensibly cmdv gsingh93 afcondon_ capicue akl avdi trig-ger cstrahan wenzowski gridaphobe)
23:33:42 <nshepperd_> Making this a data family may not actually be the right answer for your situation. If these are all just a single Text at bottom, what about a single newtype with a phantom type variable and some constructor functions?
23:36:29 <xzhu> Is Idris mission to be a "better" Haskell?
23:36:59 <xzhu> Like -- beat it at its own game sort of fashion?
23:37:19 <cocreature> xzhu: not really, it’s mission is to be a language with dependent types that is targetted at programming instead of proving things
23:38:00 <cocreature> now obviously it draws a lot of inspiration from Haskell but I don’t think they have the explicit goal of replacing it
23:38:45 <tdammers> indeed, no, the goal is really just to build a language that is dependently typed from the ground up, and they take from Haskell whatever makes sense, which turns out to be quite  alot
23:39:04 <cocreature> they also explicitely drop some things like lazyness by default
23:39:04 <tdammers> <Esc>Fajxp
23:39:18 <cocreature> Fajxp? :)
23:39:23 <tdammers> vim command
23:39:47 <cocreature> lol
23:39:50 <tdammers> should be h not j btw
23:40:31 <xzhu> cocreature: Really? I just tried `take 10 [1..]` seems to have been lazily evaluated
23:41:04 <cocreature> you can do lazy things but it’s not the default
23:41:11 <cocreature> just like you can be strict in Haskell but it’s not the default
23:41:26 <cocreature> it’s been a while since I’ve looked at idris so I don’t know what [1..] desugares to
23:41:48 <Maxdamantus> [1..] doesn't require strictness, since it doesn't produce an actual list.
23:42:13 <xzhu> Huh ...  it's `Stream Integer` instead of `List Integer` ...  interesting
23:42:18 <Maxdamantus> It's just some thing with at least one function inside it.
23:42:34 <xzhu> Sos `Stream` is basically a lazy `List`
23:43:10 <Maxdamantus> Yeah, or maybe more accurately, a list modelled with functions.
23:44:13 <geekosaur> yeh, you can also do it with a Range type whose iterator defaults lazy when other types default strict, if you're designing a language
23:44:24 <xzhu> What's more interesting is [1..] desugars to `enumFrom 1 :: Stream Integer`, but [1..10] desugars to `enumFromTo 1 10 :: List Integer`
23:45:12 <Maxdamantus> Well, the sugar would presumably be `enumFrom 1` and `enumFromTo 1 10`
23:45:25 <Maxdamantus> It shouldn't specify the types.
23:46:02 <Maxdamantus> You should be able to write `the (Stream Integer) [1..10]`
23:46:40 <Maxdamantus> Hm, or maybe not. /me doesn't really understand how its definition inference works.
23:47:04 <xzhu> What's the?
23:47:23 <Maxdamantus> (a : Type) -> a -> a
23:47:45 <xzhu> Wait .. you can mix types and values in an expression?
23:47:49 <geekosaur> equivalent to the (::) section that's supposed to be coming?
23:47:52 <Maxdamantus> It takes a type and returns the identity function for that type.
23:48:01 <geekosaur> oh
23:48:04 <Maxdamantus> Types are values.
23:48:16 <xzhu> Wow
23:48:31 <Maxdamantus> You can even say `the Type Type` or `the Type Integer`
23:48:44 <xzhu> So there's no separation of types and values in Idris?
23:49:33 <Maxdamantus> Well, types are just a particular type of value.
23:49:51 <xzhu> Why isn't it the case in Haskell?
23:50:29 <geekosaur> because people insist on writing data Foo = Foo Integer
23:50:35 <geekosaur> and now you have no idea what Foo is
23:50:37 <Maxdamantus> Because it makes some things tricky.
23:50:58 <xzhu> This is interesting:
23:50:59 <xzhu> Idris> :t Type
23:50:59 <xzhu> Type : Type 1
23:51:09 <geekosaur> (rtaher the compiler doesn;t, when it encounters it at value level)
23:51:10 <xzhu> What's `Type 1`
23:51:11 <fresheyeball> http://lpaste.net/7146115107053895680
23:51:14 <fresheyeball> http://lpaste.net/6101672768263159808
23:51:15 <cocreature> saying that shared namespaces are the only thing stopping Haskell from getting dependent types seems a bit of an understatement
23:51:23 <fresheyeball> I can get it compiling fine as a GADT
23:51:32 <fresheyeball> but the type family newtype version is still not working out
23:51:39 <Maxdamantus> Dunno. I probably have an old version of Idris, since mine just says `Type : Type`
23:51:59 <geekosaur> cocreature, that;s not what that says; it only says why a type is not a value in (non-dependent) Haskell
23:52:12 <cocreature> ah fair enough :)
23:52:17 <fresheyeball> xzhu: I think the 1 is the type universe
23:52:19 <geekosaur> which does make it *one* of the complications in making dependent Haskell, but there are bigger ones than that around
23:53:31 <cocreature> fresheyeball: protip: if you want people to look at your code, a) provide samples that compile/should compile on their own, in particular include imports and b) show us the error if it doesn’t compile
23:53:47 <fresheyeball> cocreature: fair!
23:54:26 <cocreature> I don’t mean this in a snarky way, I’m just way more likely to look at things if it requires less effort on my part and I’m sure I’m not alone with that :)
23:54:34 <xzhu> fresheyeball: What is the type universe? And isn't Type having the Kind *?
23:54:46 <moriarty> cocreature++
23:55:02 <fresheyeball> xzhu: think of it like in Haskell
23:55:08 <fresheyeball> normal types are in universe 1
23:55:16 <geekosaur> wouldn't 1 there be the equivalent of Haskell's * kind?
23:55:19 <fresheyeball> but if you promote with data kinds
23:55:27 <fresheyeball> the new kinds are in universe 2
23:55:34 <Maxdamantus> `*` is just `Type` in Idris.
23:55:38 <fresheyeball> if you continue to promoet you keep going up
23:55:39 <Maxdamantus> `* -> *` is `Type -> Type`
23:55:57 <fresheyeball> I think you have to have these type levels inorder to avoid the russel paradox
23:56:04 <fresheyeball> in Agda it's manual
23:56:10 <fresheyeball> but in idris its automagic
23:56:10 <moriarty> russell*
23:56:33 <fresheyeball> moriarty: RuSeLLL
23:56:41 <moriarty> fresheyeball, atta boy
23:56:56 <xzhu> fresheyeball: So I guess by-design you are not allow to access this Type 1?
23:57:06 <Maxdamantus> r where r = "Russel" ++ r
23:57:14 <fresheyeball> yes I beleive so
23:59:37 <fresheyeball> cocreature: http://lpaste.net/4340038974862000128
23:59:41 <fresheyeball> here it is with the error
