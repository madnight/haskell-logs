00:00:01 <trigone> so algebra is better
00:00:16 <mniip> erisco, that ignores the other boolean ring
00:00:20 <erisco> anyways, if you dig through these materials I am sure you can find the proper abstract structure you want
00:00:32 <mniip> you can have || as multiplication, and xor as addition
00:00:40 <mniip> or
00:00:42 <mniip> no wait
00:00:43 <erisco> yes, I just pasted what I read that agreed with you
00:00:45 <mniip> you can have || as multiplication, and xnor as addition
00:01:16 <trigone> at any rate the only purpose was to be able to use wrapped booleans as custom, type safer booleans (sometimes it's just impossible to get rid of them, apparently...) btw if anyone got good resources relative to techniques to get rid of booleans in code, i'd be interested :)
00:01:45 <trigone> mniip: who's gonna xnor booleans though? :P
00:01:45 <erisco> trigone, generally you use GADTs
00:01:52 <trigone> what?
00:02:00 <trigone> oh you mean to get rid of booleans?
00:02:04 <erisco> yes
00:02:09 <trigone> i'm not sure to follow
00:02:12 <jared-w> Booleans mean something is true or false. Very rarely do you actually care about a true or false but rather the existance or non-existance of something, or whether or not some constraint is satisfied
00:02:18 <erisco> well, provide an example and we'll see
00:02:43 <jared-w> If it's the existance or non-existance of something, you can use a sum type quite trivially. If it's about encoding some constraint, that's what a GADT helps with
00:03:43 * hackagebot data-interval 1.3.0 – Interval datatype, interval arithmetic and interval-based containers – https://hackage.haskell.org/package/data-interval
00:04:05 <trigone> jared-w: encoding constraints, you mean type-level constraints, like the length of a vector?
00:04:44 <jared-w> Any constraint you'd use a boolean for, really. Doesn't even have to be "constraint" in the normal sense of the word
00:05:10 <trigone> erisco: well say i have two strings, and depending on their size compared to a norm and whether they're different one from the other, i need to take a decision. without using booleans... well actually i don't really think you can do without. and since i wanted a nice abstraction i wrote a function taking four booleans as input... that's pretty messy without at least newtype wrappers...
00:05:30 <trigone> jared-w: i have trouble imagining actual cases though...
00:05:31 <erisco> mniip, so it seems there is just an abstract "boolean algebra" which is a whopping 6-tuple
00:05:46 <erisco> someone needs to teach these mathematicians record notation
00:06:26 <mniip> erisco, you should look at model theory
00:06:40 <erisco> I first tried to discern what model theory was
00:06:42 <mniip> they define a set, and two injection functions
00:06:45 <erisco> that task has not terminated
00:07:01 <mniip> one for operator symbols, other for predicate symbols
00:07:09 <jared-w> Is model theory the one that's also called 87-tuple theory? :p
00:08:02 <trigone> i'm thinking the ideal would be writing one boolean type with a phantom member maybe...
00:14:26 <boj> is there a way to add constraints to 'data V = MkV Int Int' and verify the first value is less than the second upon construction? is that dependent types territory?
00:15:05 <erisco> boj, it is pain territory
00:15:18 <boj> ok, i figured as much
00:16:02 <erisco> more easily you can define "smart constructors" which check this at runtime
00:16:24 <boj> yeah, that was the obvious path. was hoping to solve it with types
00:16:59 <jared-w> Well you /can/ if you're willing to fire up the trusty ol' singletons and get ready with the whips n chains :p
00:17:37 <boj> well, i'm not that hell bent on doing it. it's just some generalized validation code. if the programmer screws up the values so be it :p
00:17:57 <jared-w> hah, fair 'nuff
00:30:32 * Taneb is traveling to Oxford for ICFP today!
01:06:24 <mbrock> cool, I only saw the list of papers from ICFP and there were like at least 5 of them I had to click and skim immediately
01:08:28 <mbrock> ("Compiling to Categories", "A Pretty But Not G
01:09:08 <mbrock> meh :( ... "A Pretty But Not Greedy Printer", "No-Brainer CPS Conversion", "Super 8 Languages For Making Movie", and "Testing and Debugging Functional Reactive Programming"...
01:56:23 <k0ral> Hello, would you guys please be so kind as to review my humble code at https://codereview.stackexchange.com/questions/173893/extensible-xml-parser ? I've got no reviewer up to now, and I suspect my code is more complicated than it should be
01:57:40 <trigone> if we know with certainty that the `a` of some monadic value (ma :: m a) will never be evaluated, because ma will always be used with (*>), is there is a risk to having a bottom as value for the type `a`?
02:01:50 <mniip> trigone, you could enforce it with m Void
02:03:34 <trigone> mniip: but i don't have the opportunity to choose the type of `a`, hence using undefined to fill any hole.
02:04:33 <cocreature> I’m not sure how using *> means that it will never be evaluated
02:06:43 <trigone> cocreature: well that was part of my question, though i don't see how it could be evaluated if *> is defined as (>>= \_ ->). but then maybe an alternative definition could make things ugly...
02:07:19 <Rembane> trigone: Doesn't it evaluate and throw away?
02:07:59 <trigone> Rembane: dunno...
02:08:43 <cocreature> trigone: you could define a version of >>= that always forces the argument
02:09:46 <Rembane> > undefined *> (return "So...")
02:09:48 <lambdabot>  error:
02:09:48 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M306436787852...
02:09:48 <lambdabot>        prevents the constraint ‘(Show (f0 [Char]))’ from being solved.
02:10:00 <Rembane> > undefined *> (return "So..." :: Identity)
02:10:01 <trigone> cocreature: hm well that'd suck. do you really think it ever happens?
02:10:02 <lambdabot>  error:
02:10:02 <lambdabot>      • Expecting one more argument to ‘Identity’
02:10:02 <lambdabot>        Expected a type, but ‘Identity’ has kind ‘* -> *’
02:10:07 <Rembane> Bah.
02:10:12 <trigone> > pure undefined >> Just 5
02:10:14 <lambdabot>  Just 5
02:10:21 <Rembane> Ah.
02:11:45 <cocreature> trigone: I don’t know an instance offhand but it doesn’t seem to unreasonable. can you be a bit more specific on what you are trying to do? I think we might have an xy problem here
02:13:59 <Athas> Does anyone here have experience with using multiple versions of Stack on Travis?  I can make it work, but the caching seems broken, in that dependencies are re-built often.
02:15:37 <trigone> cocreature: xy problem? at any rate my problem is really complex... the limited story is i want to instanciate a record, there's a function in that record, and the function ends with (m Foo), but i need to instanciate it with a function that doesn't output anything a priori. in my case, Foo is known so i *could* choose a random member of that type as output, but i'm thinking about a case when the record would contain a function tha
02:15:43 <trigone> *some unknown a
02:16:07 <cocreature> trigone: http://xyproblem.info/
02:21:52 <trigone> cocreature: thinking about it, it seems unreasonable to imagine a monad forcing the evaluation in such a way. there are more banal types of bottoms, like infinite lists, which you simply couldn't pass around as such, and in a lazy language that's pretty problematic...
02:22:37 <trigone> what do you think?
02:22:43 <mniip> infinite lists aren't bottoms
02:23:23 <cocreature> trigone: I’m not saying that such an instance would necessarily be particularly useful or even reasonable. what I’m saying is that using "undefined" is probably not particularly reasonable either and there’s probably a nicer solution to your problem.
02:23:33 <trigone> mniip: but if you evaluate them the program would hang, wouldn't it?
02:24:05 <mniip> you mean deepSeq?
02:24:14 <mniip> sure, *deepSeq will return a bottom*
02:24:16 <trigone> mniip: oh right
02:35:47 <the_2nd> "stack setup"   no information found for ghc-8.0.1 . Supported versions ... 8.0.2   8.2.1    . What do I have to do?
02:36:47 <the_2nd> ghc -V   returns 8.0.2
02:37:05 <the_2nd> Do I need an older ghc for stack to work?
02:37:10 <cocreature> the_2nd: what’s the content of your stack.yaml?
02:37:55 <the_2nd> I wanted to stack install hakyll which suggested using the setup command
02:38:04 <the_2nd> currently I'm simply in ~
02:38:26 <cocreature> what’s the content of ~/.stack/global-project/stack.yaml
02:38:30 <the_2nd> so stack install hakyll --install-ghc yields the same error as above
02:38:49 <the_2nd> lts-7.10
02:39:01 <the_2nd> rest is empty
02:39:14 <the_2nd> need all of the content?
02:39:33 <cocreature> sure
02:39:43 <cocreature> also is the above the full error message you get from "stack setup"?
02:42:31 <the_2nd> cocreature, http://lpaste.net/2125785778163286016
02:42:52 <cocreature> the_2nd: let me guess, you’re on archlinux?
02:42:56 <the_2nd> yep
02:43:19 <cocreature> I should really find a way to make money from helping people fix Haskell problems on arch. I’d be rich by now
02:43:33 <the_2nd> won't get any from me ;p
02:43:47 <cocreature> the_2nd: either install ncurses5-compat-libs or use a resolver corresponding to 8.0.2 or 8.2.1
02:44:25 <the_2nd> what does the ncurses install do? (I get the resolver change)
02:45:03 <cocreature> it searches for linux64-nopie instead of linux64-ncurses6-nopie distributions of ghc
02:45:16 <cocreature> and those distributions exist for more versions
02:58:41 <the_2nd> I bumped the lts version
02:59:01 <trigone> if i wrap a monadic value into a newtype, do i still have a monad?
02:59:01 <the_2nd> wanted to tell you once it works, but the hakyll compilation seems to take an eternity
02:59:11 <the_2nd> so I think it worked but am not 100% sure
02:59:58 <trigone> nevermind, that's obvious. is there a deriveMonad extension?
03:00:29 <trigone> or is it newtypederiving?
03:02:17 <cocreature> trigone: GeneralizedNewtypeDeriving, note that your newtype still needs to be polymorphic. you can’t do "newtype X = X (m Int)" and make X an instance of Monad
03:03:29 <trigone> cocreature: ok thx!
03:03:33 * hackagebot alex 3.2.2 – Alex is a tool for generating lexical analysers in Haskell – https://hackage.haskell.org/package/alex
03:04:40 <mniip> I don't think polymorphic is the right word here?
03:05:20 <cocreature> mniip: yeah I’ve noticed that myself. not sure what the right word is
03:05:37 <trigone> parameterized perhaps?
03:07:07 <mniip> parameterized, abstract
03:07:58 <trigone> can GeneralizedNewtypeDeriving (thank god for copy-paste) be trusted to do the right thing?
03:08:09 <trigone> (or worst case to complain)
03:08:17 <mniip> depends on what is right
03:08:27 <mniip> and whether your right coincides with ghc's
03:09:20 <trigone> mniip: ?
03:10:53 <trigone> actually, i'd need to be able to extrapolate a monad instance for data W m a = X (m a), at the moment when m is known... is it doable?
03:10:53 <ski> trigone : a monadic value is not a monad
03:11:15 <ski> cocreature : s/polymorphic/parametric/
03:11:23 <mniip> trigone, I think that will infer Monad m => Monad (W m)
03:11:24 <trigone> ski you're right
03:11:31 <mniip> don't quote me on that though
03:11:59 <ski> or parameterized, yes
03:12:44 <trigone> mniip: really? that sounds strange...
03:13:11 <mniip> trigone, what else could it infer
03:13:32 <cocreature> just try it out. in the worst case ghc will yell at you :)
03:13:54 <trigone> i'm not sure i strictly understand what you mean... what do i do after defining my data type?
03:14:49 <mniip> newtype ... deriving (Monad)
03:15:04 <ski> "I think that will infer Monad m => Monad (W m)" -- works here
03:15:28 <trigone> wait can newtype have more than one parameter?
03:15:34 <cocreature> sure
03:15:34 <ski> you also need to derive (or explicitly instance) `Functor' and `Applicative'
03:15:46 <the_2nd> cocreature, worked, thanks
03:15:58 <trigone> well i didn't know... (i think)
03:16:21 <trigone> ok, i'll try it
03:19:05 <trigone> do i really need to derive Functor and Applicative? doesn't it know they're required to instanciate Monad?
03:19:56 <cocreature> sure it knows that they’re required but it doesn’t know if you want to derive them or implement them yourself
03:21:09 <trigone> oh of course nevermind
03:27:05 <trigone> i wrote a typeclass with two parameters, and one member of that typeclass doesn't use one of the parameters, and ghc doesn't seem to like that...
03:28:43 <trigone> is that normal?
03:29:04 <ski> perhaps you want to use an FD ?
03:29:07 <cocreature> how do you expect ghc to choose the correct instance if you use that member if it only specifies one type parameter?
03:29:33 <ski> or perhaps you want to normalize (as in relational database theory) your type relations
03:30:10 <trigone> no i don't want a functional dependency, i don't know about the other thing
03:30:25 <ski> one can also workaround by passing a proxy, or perhaps annotating an argument type or the result type with a phantom
03:31:10 <cocreature> or just move it to a separate typeclass that doesn’t have two parameters if you intend that member to be uniquely determined by a single parameter
03:31:52 <trigone> hm yeah maybe... thanks for the ideas :)
03:33:19 <trigone> by enabling allowambiguoustypes, worst case scenario i'll have to add annotations, right?
03:36:58 <ski> trigone : fwiw, the "move it to a separate typeclass .." option is what i meant by "normalize (as in relational database theory) your type relations"
03:37:24 <trigone> ski: oh ok :)
03:38:02 <trigone> i think the problem is, i shouldn't have a parameter here...
03:45:18 <ski> trigone : "by enabling allowambiguoustypes, worst case scenario i'll have to add annotations, right?" -- simple type ascriptions (`blah :: type') won't be enough. but <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTypeApplications> will
03:45:23 <ski> see <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ambiguous-types-and-the-ambiguity-check>
03:54:57 <trigone> thx ski!
04:02:59 * hackagebot push-notify-apn 0.1.0.2 – Send push notifications to mobile iOS devices – https://hackage.haskell.org/package/push-notify-apn
04:03:00 * hackagebot happy 1.19.6 – Happy is a parser generator for Haskell – https://hackage.haskell.org/package/happy
04:12:54 <FerdinL> how to make GHCi give more information about compiling error?
04:13:15 <FerdinL> now it just say: Parse error in pattern. 
04:17:50 <foojs> hi guys
04:18:10 <cocreature> FerdinL: for parse errors you are not really going to get better error messages
04:19:23 <ski> FerdinL : can you paste the offending code ?
04:19:25 <ski> @paste
04:19:25 <lambdabot> Haskell pastebin: http://lpaste.net/
04:20:02 <FerdinL> well, I should be a manually compiler xD
04:45:58 <WilliamHamilton[> (if you'll excuse the OT, I'd like some help for an agda snippet, given it's saturday and all the #agda regulars seem to be away) (in #agda)
04:46:32 <Rembane> WilliamHamilton[: Put it on lpaste.net and see if anyone takes the hook. :)
04:46:44 <Rembane> WilliamHamilton[: Also, put the link to that lpaste code snippet here.
04:46:53 <novakboskov> Does anyone use stack on Arch Linux?
04:47:27 <WilliamHamilton[> http://lpaste.net/358158 thanks for the tip, Rembrane
04:49:04 <FerdinL> http://lpaste.net/358159 how to fix the compile error?
04:50:12 <cantom> Rebuttal? https://hastebin.com/ikajotoloc.txt
04:51:04 <cocreature> novakboskov: lots of people do. you are going to get a better answer if you ask your actual question
04:51:05 <Rembane> novakboskov: I use stack on Arch.
04:52:21 <ongy> FerdinL: could you please attach the compile error you get? But I would guess it's something like [Integer] is not Num?
04:53:06 <novakboskov> I've got into -FPIC problem, found this https://docs.haskellstack.org/en/stable/faq/#i-get-strange-ld-errors-about-recompiling-with-fpic but it's a bit outdated since hardening-wrapper is no longer available
04:53:37 <FerdinL> desktop\hsTest.hs:11:6: error:
04:53:38 <FerdinL>     Variable not in scope: x :: Integer
04:53:38 <FerdinL>    |
04:53:38 <FerdinL> 11 |   | (x:xs) `mod` 2 == 0 = (x:xs) ++ doubleEveryOther xs    |      ^
04:53:38 <FerdinL> \desktop\hsTest.hs:11:28: error:
04:53:38 <FerdinL>     Variable not in scope: x :: Integer
04:53:40 <FerdinL>    |
04:53:53 <ongy> poor FerdinL
04:54:16 <ongy> oh right it fails even earlier. The guards can not pattern match
04:54:38 <FerdinL> what's the proper way?
04:54:44 <ignamv> what does (x:xs) `mod` 2 mean?
04:54:47 <ongy> if you want the (x:xs) match to work and give you x into scope, you have to do that on line 2 where you have the function body with argument
04:55:14 <FerdinL> I want to take one elem in list and mod it by 2
04:55:17 <ongy> and then probably want to replace the (x:xs) where you treat it like a single Integer with x (which would be the head of your list)
04:56:15 <ongy> if you have (x:xs) as an expression, that's the list xs with x prepended
04:56:33 <ongy> > let xs = [1..5]; x = 0; in (x:xs)
04:56:35 <lambdabot>  [0,1,2,3,4,5]
04:57:11 <novakboskov> Rembane: cocreature: How do you overcome -fPIC problem?
04:57:13 <ongy> > let (x:xs) = [0..5] in x -- and you can match like this, when you bind the list to a name
04:57:15 <lambdabot>  0
04:58:19 <cocreature> novakboskov: what is the exact error message?
05:01:54 <novakboskov> cocreature: Here it is http://lpaste.net/new/haskell
05:02:16 <cocreature> novakboskov: that’s the wrong link
05:03:15 <ongy> FerdinL: got any further with what I told you?
05:04:15 * hackagebot threadscope 0.2.9 – A graphical tool for profiling parallel Haskell programs. – https://hackage.haskell.org/package/threadscope
05:04:37 <FerdinL> I got wrong type, (head xs) `mod` 2 is not my type [Integer], how i can peek the number in guard?
05:04:47 <novakboskov> cocreature: Sorry, it is too large for lpaste. Here are only last few lines of error http://lpaste.net/358160
05:05:25 <FerdinL> Maybe I should use 'if' in func body, not in guard?
05:06:06 <ongy> FerdinL: can you paste your current code? That looks correct to me (provided you didn't change the xs in line 2)
05:06:25 <cocreature> novakboskov: try installing ncurses5-compat-libs from the aur
05:06:26 <petercommand> FerdinL: if you want to know the result of the guard, then you should probably use let abstractions instead
05:06:51 <FerdinL> http://lpaste.net/358161 this is my current code
05:06:55 <petercommand> so you can have sth like let y = x `mod ` 2 in blah
05:07:20 <petercommand> FerdinL: the variable x is still unbounded
05:08:01 <petercommand> FerdinL: so that's not going to work
05:08:09 <FerdinL> thanks, I will check my code.
05:12:47 <petercommand> FerdinL: if you are not doing pattern match on xs, then you will have to replace every occurrence of x with head xs
05:15:38 <novakboskov> cocreature: Didn't help, same error on stack setup
05:16:18 <cocreature> novakboskov: are you on the newest stack release? maybe try "stack setup --reinstall"
05:17:03 <novakboskov> cocreature: stack --version is Version 1.5.1, Git revision 600c1f01435a10d127938709556c1682ecfd694e (4861 commits) x86_64 hpack-0.17.1
05:18:01 <cocreature> novakboskov: did you mess with ld somehow? your error message shows "clang" which it normally shouldn’t on archlinux
05:18:14 <ski> FerdinL : fwiw, to "attach the compile error", you'd use the "Annotate" button on the existing paste. such updates will turn up on the same page as the original paste. ("Edit" will replace. it can be used for minor corrections)
05:19:04 <trigone> am i right if i say that functional dependency (m -> n) must be proven by the fact that type `m` would somehow "contain" type n, whereas by contrast type families allow arbitrary associations of types, regardless of whether m is defined in terms of n or not?
05:19:41 <ski> FerdinL : it's also good to *annotate* your subsequent current versions that you seek input on, as you make them, on the same page, instead of making a brand new one for each of them
05:19:59 <novakboskov> cocreature: It could be... I have export CC=clang and export CXX=clang++ in my .bashrc
05:19:59 <novakboskov>  
05:20:16 <cocreature> novakboskov: try removing that
05:21:38 <ski> FerdinL : you forgot one `x' .. and anyway, using pattern-matching is (usually) to be preferred to using partial accessors and predicates like `head',`tail',`null',`fst',`snd',&c.
05:21:49 <trigone> nevermind apparently i'm wrong and functional dependency can be arbitrary too...
05:24:42 <novakboskov> cocreature: I've removed it and rebooted.
05:24:59 <trigone> in a fundep, if type m uniquely defines types a and b, what's the syntax? m -> a b?
05:25:19 <novakboskov> cocreature: Didn't help. What is problem with clang on Arch? What if I need it for other projects?
05:26:52 <cocreature> novakboskov: there is not a problem in general but clang and gcc behave differently so just globally swapping one for the other can cause problems. in particular since some programs don’t respect CC and CXX so you end up mixing gcc and clang
05:27:55 <cocreature> novakboskov: setting it locally for the projects that actually need it is probably a better idea unless you’re sure what you’re doing
05:28:59 <lyxia> trigone: m -> a, m -> b  
05:29:55 <cocreature> novakboskov: one last idea, do you have libtinfo installed? if so try uninstalling it, that has caused problems for me in the past
05:34:17 <novakboskov> cocreature: Sorry, it looks like it works now when CC is removed from .bashrc and stack setup --reinstall is used. Thank you for your time.
05:35:38 <cocreature> trigone, lyxia: "m -> a b"  should work too, see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=functionaldependencies#adding-functional-dependencies
05:35:47 <cocreature> “More generally, dependencies take the form x1 ... xn -> y1 ... ym”
05:37:04 <lyxia> ah
05:44:58 <cantom> Rebuttal? https://hastebin.com/ikajotoloc.txt
06:10:22 <ski> trigone : logically, `class Foo a b c | a -> b' requires `forall a. unique b. exists c. Foo a b c', which can also be stated as `forall a b0 b1 c0 c1. (Foo a b0 c0,Foo a b1 c1) => b0 = b1'
06:10:40 <trigone> (quite a bit later, as i hadn't seen your answer) thanks lyxia, cocreature! :)
06:11:38 <hustler> Hi
06:11:40 <trigone> hm interesting ski
06:11:55 <ski> trigone : the FD forbids two instances with the same `a' to have differing `b's (never mind the `c's). so `a' "functionally determines" `b'
06:12:43 <ski> trigone : as you noticed, there is no containment relation implied, it just forbids such "multiple indeterminations" (including implicit ones arrived at by specializing more general, overlapping, instances)
06:14:08 <ski> trigone : also, if you use an operation of `Foo' twice, generating constraints `Foo a0 b0 c0',`Foo a1 b1 c1', and other things force `a0' and `a1' to be equal, it now knows `b0' and `b1' must also be equal (reducing ambiguity, and often reducing number of constraints)
06:14:10 <trigone> yes i understand! eariler i think i mixed up with something else
06:15:20 <trigone> i'm not sure to understand the reducing number of constraints bit
06:15:44 <pussyslayer> hi
06:16:01 <trigone> oh nevermind i got it
06:16:44 <pussyslayer> what up
06:17:30 <ski> trigone : let's forget about the `c'. if we say that we know `a0 = a1' (call it just `a'), forcing `b0 = b1' (call it `b') by the FD `a -> b' on `Foo a b', then instead of having two constraints `(Foo a0 b0,Foo a1,b1)', which we now know is `(Foo a b,Foo a b)', we simply replace these two by the single `Foo a b'
06:18:39 <ski> (this is safe, because there can be at most one instance for a particular choice of parameters for a type class. not so in some other languages having something similar to type classes, btw)
06:19:19 <trigone> ski: really, like what other languages?
06:20:31 <ski> trigone : if you know anything about functional dependencies in relational data base theory, then it's at the core the same concept as here. also normalization of relations (3NF,BCNF,4NF,&c.) from there can be applied to type classes
06:20:41 <ski> trigone : well, Scala, Agda
06:21:48 <trigone> ski sadly i know nothing about all that :P
06:22:03 <ski> implicit arguments, which can be automatically synthesized from other such, if need be, doesn't per se give you uniqueness of value
06:22:25 <trigone> value of what?
06:22:39 <ski> of the implicit argument(s)
06:23:23 <ski> this means that it may matter which implicit argument it picks up / in which way it synthesizes it, if several fits the bill
06:23:51 <ski> one alternative might be to refuse, when there appears to be multiple ways
06:24:56 <ski> instead of a constraint `Monoid a', you'd have that as an (the type of an) implicit argument
06:25:18 <ski> but if in some situation, there's several monoids on the same `a' to choose from, what to do ?
06:25:59 <ski> or, there could be several ways to synthesize `Ord (a,b)' from `Ord a' and `Ord b', or something
06:26:45 <trigone> sure, from there we need to wrap things to inject artificial differences at the type level, right?
06:26:53 <trigone> (with newtypes)
06:27:49 <ski> imho, implicit, *unnamed* arguments, are mostly useful when they're unique, at least locally, or at least "syntactically" unique
06:28:06 <trigone> unnamed?
06:28:09 <ski> trigone : in Haskell yes .. though i don't really like this approach
06:28:25 <ski> GHC has (named) implicit parameters. basically dynamic scoping
06:28:35 <trigone> ski: me neither... what do you specifically not like by curiosity?
06:29:28 <trigone> ski: oh right, i heard of those, they seem nice
06:29:29 <ski> > let y = ?x ^ 2 + 1 in map (\x -> let ?x = x in y) [0 .. 9]
06:29:32 <lambdabot>  [1,2,5,10,17,26,37,50,65,82]
06:29:49 <ski> `y' has type `(?x :: Integer) => Integer'
06:30:09 <ski> in math terms, `y' would be a dependent variable, and `?x' an independent variable that it depends on
06:31:09 <trigone> yeah, i see. when should we think about using them, and when should we think not? do they have drawbacks?
06:32:01 <ski> (except in math there's no special syntax for either. and i suppose if there was, it possibly would be the "dependent" variable that'd get it, since that's thought of as the "ususal" thing here. in GHC, one instead has to specially mark (with `?') the implicit variables something depends on)
06:33:43 <ski> one example could be configurations, that we usually want to pass down unchanged to all the operations possibly needing access, without cluttering up the call with extra parameters or `Reader r'/`ReaderT '/`(r ->)'
06:34:29 <ski> one could perhaps also imagine stuff which changes (locally) more frequently than almost never, such as indentation count, bracket nesting level, &c.
06:35:15 <trigone> ski: is it used a lot out there?
06:35:25 <trigone> wait you mean it can simulate state? how so?
06:35:56 <trigone> and i couldn't parse "more frequently than almost never"
06:36:35 <ski> no, not state
06:36:39 <ski> @type local
06:36:41 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
06:36:56 <ski> environments can change, *locally*
06:38:06 <trigone> oh right, so say in a loop that depends on such implicit parameter, you'd change its value of the sake of deeper-nested scopes?
06:38:20 <trigone> change in a shadowing sense
06:38:45 <ski> > let f :: (Num a,?x :: a) => ((?x :: a) => b) -> (a,b); f y = (?x,let ?x = ?x+1 in y) in let ?x = 2 in f (?x ^ 2)
06:38:48 <lambdabot>  (2,9)
06:39:01 <ski> note that `?x = ?x+1' is not a recursive binding
06:39:11 <ski> trigone : correct
06:40:04 <ski> (that uses rank-2 types to illustrate the point better, with more separation of concerns. but rank-2 isn't needed for this)
06:40:04 <trigone> do you need the double let because of it?
06:40:14 <aarvar> ski: why not state? type State s a = forall r. (?state :: s) => ((?state :: s) => a -> r) -> r
06:41:28 <aarvar> other than that there's no reason to do that of course
06:41:35 <ggVGc> forall cream. eat cream
06:41:48 <trigone> aarvar: other than what?
06:41:55 <ggVGc> do you guys feel haskell should have explicit forall like purescript?
06:42:24 <ggVGc> in one sense it'd make the language less confusing in the long run
06:42:32 <ggVGc> but initially it's a fair bit more confusing I think
06:42:38 <ski> aarvar : that's using `ContT o (ReaderT rs m) a' being iso to `StateT rs (ContT o m) a' ..
06:42:42 <ski> @unmtl ContT o (ReaderT rs m) a
06:42:43 <lambdabot> (a -> rs -> m o) -> rs -> m o
06:42:47 <ski> @unmtl StateT rs (ContT o m) a
06:42:47 <lambdabot> rs -> (a -> rs -> m o) -> m o
06:43:12 <ski> (and a sprinkling of yoneda)
06:44:05 <trigone> ggVGc: more than confusion, to me it severely hits readability, for a priori no gain (to my knowledge). it's better to just allow it only when needed, i believe.
06:44:34 <ski> ggVGc : sometimes i lean in that direction. especially when trying to explain to newbies that it's not the presence of type variables in a type signature that makes the operation polymorphic, but rather the presence of the (often implicit/invisible :/ ) `forall'
06:44:59 <ggVGc> trigone: in one sense it helps readability, but in another sense it hindres it, because when you're used to explicit foralls it actually is much clearer
06:45:08 <ggVGc> less implicit things is usually prefered
06:45:09 <ggVGc> imo
06:45:09 <aarvar> ski: sure, but with implicit params
06:45:28 <ggVGc> ski: I know I definitely got another understanding when I started using purescript
06:45:39 <ski> ggVGc : so .. i'd say that initially, (or perhaps just after initially), it makes it more confusing .. and then somewhat less confusing in the long run (when you're used to it) (but not going away completely)
06:45:39 <aarvar> ggVGc: what about when you have polykinds?
06:45:40 <ggVGc> and realised there were things in haskell I didn't think really correctly about
06:46:18 <trigone> ggVGc: maybe. if we really make it necessary everywhere i think we should choose some shorter symbol to represent it, otherwise type signatures will never end...
06:46:24 <ski> trigone : gain is to better understand polymorphism, `forall' (and that type variables are only incidentally related to that)
06:46:29 <ski> aarvar : same deal
06:47:30 * ski dislikes the term "polykinds"
06:47:41 <aarvar> ggVGc: map :: forall (i :: *) (j :: *) (p :: i -> i -> *) (q :: j -> j -> *) (f :: i -> j) (a :: i) (b :: i). Functor p q f => p a b -> q (f a) (f b)
06:47:52 <aarvar> seems a bit long
06:49:17 <trigone> aarvar: you're pushing it :P kinds are easily calculated from the signature, aren't they, so it's mostly redundant (but so is forall if you consider its absence as implicit presence)
06:49:22 <aarvar> ggVGc: also would effect type applications, as currently implemented
06:49:44 <ski> aarvar : lets infer most of the `:: ...' stuff there, and it's more reasonable ?
06:50:02 <trigone> aarvar: what's the Functor p q f thing?
06:50:14 <ski> yeah .. i'd be happier if type applications would start resolving from the right, not from the left
06:50:33 <ski> trigone : some generalization to arbitrary categories, presumably
06:50:34 <aarvar> ski: can you though? you'd have to make i and j explicit, and then you need to make all the kinds explicit
06:50:42 <trigone> oh
06:50:47 <ski> aarvar : see my other comment
06:51:17 <aarvar> otherwise how can the compiler infer if it's (p :: i -> i -> *) or (p :: j -> j -> *)
06:51:32 <ski> ggVGc : i presume you got a better understanding of higher-rank as well, then
06:51:58 <ski> it doesn't matter if it's called `i' or `j' ?
06:52:21 <ski> as long as the two argument kinds of `p' agree with the argument kind of `f'
06:52:33 <aarvar> unless you're using type applications...and why should the i and j need to be explicit if they arent even visible in the type signature
06:52:44 <aarvar> or are you suggesting it should have to be forall p q f a b.
06:53:06 <ski> yes .. but now that we have `TypeInType', perhaps that's less reasonable
06:53:29 <ski> but still, i think it would be nice if type applications could be made to resolve from the right
06:53:29 <aarvar> it would be fine. Just allow types which arent visible in the signature to be implicit?
06:53:43 <trigone> i'll leave you to your very complex discussion :) thanks ski again for your useful explanations!
06:54:38 <ski> aarvar : i suppose so
06:55:36 <ski> i think when type applications are used, we're more likely to want to specify the most specific ones, over the more "abstract" ones
06:56:04 <ski> and specifying the specific ones often can implicitly determine the more abstract ones
06:56:27 <ski> if we know `p' and `q', then of course we know `i' and `j'
06:57:08 <ski> (and this goes in general for positional implicit arguments, with some version of dependencies)
06:57:42 <aarvar> ski: but what if you did want to specify i and j. Does it make sense to specify them after p and q, when you want that information to be available to the p and q arguments?
06:58:06 <ski> in that case, they'd be specified before `p' and `q'
06:58:36 <aarvar> but then which is it?
06:58:42 <aarvar> are they specified in reverse order or not?
06:59:18 <ski> consider `foo : {n : Nat} -> {f : Finite n} -> ..n..f..' in Agda
06:59:28 <ski> the `{...}'s signify implicit parameters
07:00:07 <ski> i want it so that if i write `foo {x}' (specific explicitly an otherwise implicit parameter), then `x' would get matched to `f' (not `n')
07:00:27 <ski> but if i write `foo {x} {y}', i want `y' to be matched to `f', and `x' to `n'
07:00:51 <aarvar> ski: sounds confusing
07:01:04 <aarvar> and what happens if you change the number of implicit params
07:01:17 <ski> so, given a sequence of implicit actual arguments, we should match that with a *suffix* (not a prefix) of the implicit arguments in the signature
07:01:29 <eikke> I learned yesterday you can't UNPACK a Bool field in a record. I was wondering: what if GHC changed the Bool implementation from an ADT into a newtype around a Word8 (not exporting the constructor), then provide bidirectional pattern synonyms for True and False, and alter ifThenElse, wouldn't this allow UNPACKed Bool's without any further work to be done?
07:01:50 <ski> perhaps the adverse effects of this would be too much to bear .. but i'm not sure, i'd like to do the experiment
07:02:37 <ski> but i'm tired of having to specify all the `n' first implicit arguments explicitly, just because i wanted to specify the `n'th one explicitly
07:03:00 <aarvar> then put the nth one first
07:03:01 <ski> (the `n'th commonly being the last implicit argument)
07:03:12 <ski> aarvar : can't be done. its type depends on the previous ones
07:03:26 <aarvar> ski: sure it can, dont have an explicit forall for those
07:03:33 <ski> similar to your `forall (i :: *) (j :: *) (p :: i -> i -> *) ...' case
07:03:58 <ski> i may need to state those explicitly, because the system can't infer it
07:04:10 <aarvar> > let f :: forall a. Proxy a; f = Proxy in f @Int
07:04:12 <lambdabot>  error:
07:04:12 <lambdabot>      Pattern syntax in expression context: f@Int
07:04:12 <lambdabot>      Did you mean to enable TypeApplications?
07:04:17 <ski> or i may want to state them explicitly, for documentation purposes
07:04:20 <aarvar> :/
07:04:40 <ski> aarvar : do you see the problem, now ?
07:04:45 <aarvar> have different versions of the function then?
07:05:22 <ski> could sometimes work, but that's not really that happy either, for maintainability
07:05:25 <aarvar> or have named arguments for top level definitions
07:06:05 <aarvar> or just use proxies
07:06:25 <ski> i could just as well use explicit arguments
07:06:46 <aarvar> I suppose so
07:07:47 * hackagebot github-release 1.0.6 – Upload files to GitHub releases. – https://hackage.haskell.org/package/github-release
07:08:21 <aarvar> ski: hm, or take the arguments as a tuple so that you can choose which ones to specify
07:11:07 <ski> aarvar : .. that brings up another issue (donkey sentences)
07:12:03 <ski> (i'm not ungrateful for all the alternative suggestions. it just seem to me they'd be less attractive than what i'd prefer. but in the absence of that, they may have merit. ty)
07:13:24 <aarvar> ski: well, I think I've only ever really used type applications in combination with ambiguous types, and only to specify the ambiguous parameters
07:13:46 <aarvar> in which case none of this really matters
07:15:02 <aarvar> usually you know which parameters are going to be ambiguous ahead of time, and in the cases where you don't it isn't that painful
07:16:40 * ski supposes it's probably more of an acute problem in a dependent language
07:16:51 <ski> (hence why i brought up an Agda example)
07:19:17 <aarvar> do named arguments not solve the problem?
07:28:56 <cocreature> eikke: sounds like it would work but imho the better solution is to improve GHC so it can unbox sumtypes just like it can unpack other types. we already have a primitive type for unboxed sums in GHC 8.2 so getting that to work should be relatively easy (famous last words) and afaik people are working on it
07:31:01 <cocreature> or did we already get that in GHC 8.2 too? I can’t find it in the docs but maybe I’m just being stupid
08:02:31 <[exa]> ertes: btw thanks for the polymorphic recursive types challenge from yesterday :D
08:03:03 <ertes> [exa]: did you solve it?
08:03:20 <[exa]> no, started reading papers about it. :D
08:28:15 <ertes> [exa]: just let the types guide you
08:29:58 <ertes> [exa]: the idea is that all bound variables are indexed (rather than named), so if you only use bound variables, then the variable name type (the argument to Expr) will never be used
08:30:23 <ertes> [exa]: that in turn means that you can change the name type without changing the expression
08:30:35 <ertes> that's what the type of 'closed' communicates
08:30:41 <ertes> closed :: Expr a -> Maybe (Expr b)
08:31:07 <[exa]> Can we use the Bind a = Zero | Succ a from the paper, instd. of maybe?
08:31:12 <ertes> much like you can change the content type of a Maybe, if Just is not used
08:31:20 <[exa]> anyways
08:31:23 <ertes> nothing :: Maybe a -> Maybe (Maybe b)
08:31:35 <ertes> sure, if you want to
08:31:55 <ertes> it's just Maybe in disguise though =)
08:32:22 <[exa]> the original question I wanted to ask is whether there's some direct mapping from polymorphic-recursive code to non-poly-recursive code that one can use to translate the P.R. to, say, weaker language
08:32:27 <[exa]> yeah
08:33:29 <ertes> well, in the case of Expr you would need to come up with a representation that works without PR
08:33:42 <ertes> like using named binders
08:33:57 <ertes> but it's not a mechanic translation
08:34:05 <ertes> mechanical
08:34:36 <[exa]> certainly not. I was actually thinking about some overloading (whole-program compilation allowed for now)
08:35:10 <[exa]> which in the naive form gets an infinite term quickly, but we have loopbreakers and so
08:35:36 <ertes> you're basically asking whether RankNTypes can be translated into standard haskell
08:35:42 <[exa]> (I need a coffee -- getting infinite term quickly... :D )
08:36:02 <ertes> my initial response is no, because GADTs certainly aren't possible in standard haskell, and RankNTypes is powerful enough to express GADTs on its own
08:36:36 <ertes> (well, almost…  you also need type equalities)
08:36:58 <[exa]> how's the Term a rankNtype ?
08:37:28 <ertes> err, ignore that
08:38:36 <ertes> wait…  if a language is powerful enough to express parametric polymorphism, then it should be powerful enough to express polymorphic recursion
08:38:52 <[exa]> yes it is, as we have just seen on Term
08:39:22 <ertes> i don't know what Term is
08:39:34 <[exa]> Term from your challenge :]
08:39:38 <ski> ertes : ML isn't
08:39:40 <ertes> ah, you mean Expr
08:39:44 <[exa]> oh sorry. :]
08:40:07 <ertes> ski: huh?
08:40:14 <[exa]> (btw it's here http://www.jucs.org/jucs_9_8/practical_type_inference_for/Vasconcellos_C.pdf )
08:40:36 <[exa]> (around page 4)
08:40:40 <knupfer> Is it possible to inline all function definitions in a module? Using lots of pragmas makes the code quite larger and uglier.
08:41:13 <ski> ertes : ML had parametric polymorphism, but no polymorphic recursion
08:41:38 <ertes> ski: so if you want to apply a function recursively you must use the types that you received?
08:41:42 <[exa]> knupfer: do you have some kind of promise that force-inlining everything will not infinitely loop on recursion?
08:41:50 <ski> (also no declaration signatures in modules)
08:42:04 <ski> ertes : aye
08:42:18 <ertes> that's…  very limiting
08:42:35 <ski> ertes : this was because of the focus to not have to declare any types of variables (type inference, which was what ML brought to the table)
08:42:57 <knupfer> [exa]: Well, it could behave like adding inline, which also doesn't inline recursive calls.  Besides in my case I know that it would be save.
08:43:01 <[exa]> ski: actually iirc the lack of polymorphic recursion was due to missing feature in type checking, see HM^\forall here https://open.bu.edu/bitstream/handle/2144/1532/2004-004-polymorphic-recursion-progams.pdf
08:43:04 <lyxia> [exa]: the compiler breaks recursive inlining for you
08:43:44 <lyxia> knupfer: maybe you can generate inline pragmas with template haskell
08:44:03 <knupfer> Well, I'd prefer not to use TH.
08:44:09 <[exa]> forcing inline doesn't break loopbreakers?
08:44:11 <[exa]> :(
08:44:23 <ertes> data Tree a = Branch (Tree a) (Tree a) | Leaf a | DeadEnd
08:44:25 <knupfer> I'd like {-# INLINE_ALL #-}
08:44:33 <ertes> noDeadEnds :: Tree a -> Maybe (Tree b)
08:44:39 <ertes> err
08:44:41 <ertes> onlyDeadEnds :: Tree a -> Maybe (Tree b)
08:44:48 <ertes> ski: so you couldn't write this function in ML?
08:45:05 <ertes> wait, nevermind, it doesn't need polymorphic recursion
08:45:11 <knupfer> [exa]: If you're looping via classes on the type, it gets all inlined :)
08:45:43 <ertes> ski: but you couldn't use the locally nameless encoding in ML?
08:47:27 <ski> [exa] : ".. type inference for polymorphic recursion using ∀-types has been proved undecidable."
08:47:41 <[exa]> ertes: I kindof expect that the missing rule for P.R. in ML was on purpose, since compiling PR stuff down doesn't look useful
08:47:53 <ski> [exa] : which missing feature were you thinking of ?
08:47:58 <knupfer> I'd also be able to specify that a value must be known at compile time when used in an executable.
08:47:59 <ski> [exa] : looks like an interesting paper, ty
08:48:33 <knupfer> add :: (Known a, Num a) => a -> a -> a
08:49:00 <[exa]> ski: there are rulesets for 4 different type systems, one standard HM with usual recursion, second HM that can ignore some stuff to type PR, then 2 variants of intersection types (there are extra interesting though)
08:49:01 <knupfer> so the compiler could safely evaluate such functions at compile time
08:49:41 <[exa]> ski: anyway it doesn't quite relate to our problem here, they mostly tackle stuff that haskell solved with dependency-ordered binding groups
08:50:08 <[exa]> just the thing about polymorphic ML
08:53:01 <[exa]> ertes: the minimal example for "compiling" the thing down to non-PR types would probably be something like T a b = X (T b a) | Y
08:54:03 <[exa]> maybe even without |Y as we're lazy
08:54:34 <[exa]> ok guys thanks for the discussion I'm going to the cellar to think about it. :D
08:54:54 <ski> ertes : i just checked to make sure, `val onlyDeadEnds : 'a tree -> 'b tree option' is no problem
08:55:18 <ski> (and doesn't require polymorphic recursion .. which i of course only now notice you already said)
08:57:13 <ski> [exa] : "the thing" being ?
08:57:30 <ski> ertes : remind me of what "locally nameless encoding" is ?
08:58:00 <[exa]> ski: I'm writing a compiler to a lower-level language that can't afford run-time type information that haskell uses to work with P.R.
08:58:38 <ski> [exa] : which run-time type information would that be ? in the GC ?
09:00:28 <[exa]> ski: on a second thought, it's just the ability to pass in a "generic" run-time object
09:00:48 <[exa]> the PR function doesn't need to know anything, and the rest gets solved by overloading
09:02:20 * ski doesn't get the point [exa] is making
09:03:31 <ski> what is it that this lower-level language can't afford, that's not a problem in Haskell ?
09:08:11 <ski> knupfer : looks like you want staged programming (such as TH) or macros
09:08:19 <ski> (and i don't mean to generate inline pragmas)
09:09:40 <knupfer> ski: yes, with TH I could solve this, but I'm disliking TH and its syntax, so I try to convince the compiler with pragmas.
09:10:23 <ski> [exa] : exercise : formulate a catamorphism for the `SwapList' type (your `T')
09:10:38 * ski doesn't like TH that much, either
09:11:04 <ski> staged programming and macros in Lisp and MetaML/MetaOCaml is nicer
09:11:22 <knupfer> ski: I'm writing sth like blaze-html, but mostly on the type level and not on the value level for type safety and ~2x faster. But the reification uses a lot of type classes which have to be inlined...
09:11:59 <ski> mhm
09:12:13 <knupfer> disadvantage: a typical page of wikipedia needs to compile 30sec
09:12:15 <knupfer> :)
09:12:29 <knupfer> -freduction-depth=0 ...
09:34:34 <[exa]> ski: not quite knowledgeable about CT&catamorphism, but the haskell wikipage on that could say it's "fold on a fixpointed type" on the first line :]
09:43:27 <ski> [exa] : i just thought it might be a fun exercise to figure out, if you have some basic understanding of catamorphisms for lists, various forms of tree, and so on ..
09:43:54 <ski> oh, yes. "fold" is also a common name for it
09:44:18 <ski> (however, there's also "fold" as in `Foldable', `foldr'&`foldl', which is something else)
09:46:29 <[exa]> ski: I at least learn something :D
09:48:54 <ski> (but it so happens that `foldr' is also a catamorphism .. which probably is the source of the confusion here)
09:52:08 <[exa]> ski: yeah. Well, I'm going kindof in the direction of double fixpoint
09:52:16 <[exa]> data SL a b x = SL a b x | SLN
09:52:21 <[exa]> data Mu2 a b = InF1 { out1F :: a (Mu2 a b)} |InF2 {out2F :: b (Mu2 a b)}
09:52:30 <[exa]> type SL' a b = Mu2 (SL a b) (SL b a)
09:52:56 <[exa]> but that is probably too general
09:53:37 <ski> [exa] : no need for anything `Fix'-like
09:54:13 <ski> (you do need that if you want to write a general catamorphism operation. but not if you just want one specialized for a particular data type)
09:55:22 <[exa]> ski: so any catamorphism (like fold) will do?
09:56:23 <ski> (also, if you want to do that anyway, you're going about it the wrong way. your `Mu2' stores extra run-time information. that means your will allow not alternating between `a' and `b')
09:56:37 <[exa]> I see
09:56:44 <ski> [exa] : like `foldr',`foldTree',&c.
09:57:42 <ski> [exa] : but .. since your data type is not "regular" (technical term), it will require a further insight
10:01:17 <[exa]> ski: well this is "standard" foldl that folds on a's and b's https://pastebin.com/EWgR0scP, I kindof expect it's not a catamorphism
10:02:45 <ski> you should not be tail-recurring with an accumulator, with catamorphisms, no
10:03:03 <ski> the usual list `foldl' is not a catamorphism
10:04:00 <ski> a catamorphism should take one argument for each data constructor, then the data structure itself, and return a "copy" of it, will all the data constructors replaced by the corresponding arguments
10:04:03 * hackagebot logic-TPTP 0.4.5.0 – Import, export etc. for TPTP, a syntax for first-order logic – https://hackage.haskell.org/package/logic-TPTP
10:04:04 * hackagebot dhall 1.6.0 – A configuration language guaranteed to terminate – https://hackage.haskell.org/package/dhall
10:04:12 <ski> e.g. for lists
10:04:17 <ski>   foldr cons nil = loop
10:04:19 <ski>     where
10:04:25 <ski>     loop [    ] = nil
10:04:37 <ski>     loop (a:as) = cons a (loop as)
10:04:48 <ski> > foldr f z [a,b,c]
10:04:50 <EvanR> :t [    ]
10:04:50 <lambdabot>  f a (f b (f c z))
10:04:52 <lambdabot> [t]
10:05:27 <ski> (and `[a,b,c]' is sugar for `a : (b : (c : []))')
10:06:03 <[exa]> ok
10:06:10 <ski> another example
10:06:17 <ski>   data Tree a = Node a [Tree a]
10:06:47 <ski>   foldTree :: (a -> [a] -> o) -> Tree a -> o
10:06:54 <ski>   foldTree node = loop
10:06:56 <ski>     where
10:07:24 <ski>     loop (Node a ts) = node a (map loop ts)
10:07:34 <ski> (er, sorry, that should be `[o]', not `[a]')
10:08:13 <ski> in this case we need to use list `map' to access the children, so the recursion is slightly indirect
10:08:50 <[exa]> ok well, this is pretty much standard folds
10:09:06 <ski> (one could imagine also simultaneously replacing the data constructors of the lists in there ..)
10:09:12 <[exa]> where are we supposed to get with the swaplist?
10:09:30 <ski>   data SwapList a b = Nil | Cons a (SwapList b a)
10:09:44 <ski> the implementation ought to look more or less like
10:09:52 <ski>   foldSwapList nil cons = loop
10:09:54 <ski>     where
10:10:18 <ski>     loop  Nil         = nil
10:10:43 <ski>     loop (Cons a bas) = cons a (loop bas)
10:12:42 <ski> the trick is to figure out the correct signature. the implementation is not a problem
10:12:59 <ski> here's two other examples that may or may not be easier to think about
10:13:14 <[exa]> oic, the extra binding group causes the polymorphism to be just right
10:13:42 <ski>   data NestTree a = Nil | Node a (NestTree [a])
10:14:06 <[exa]> no wait
10:14:10 <ski>   data PerfectlyBalancedBinaryTree a = Leaves a | Double (PerfectlyBalancedBinaryTree (a,a))
10:14:14 <[exa]> foldSL :: (t1 -> t -> t) -> t -> SL t1 t1 -> t
10:14:26 <[exa]> my haskell thinks a==b in the type
10:14:52 <ski> [exa] : i just used a local `loop' for convenience. one could easily do without it (inlining it)
10:15:01 <[exa]> which is caused by using the single function to do that
10:15:10 <ski> note that you can't infer the intended type from the implementation !
10:15:13 <[exa]> so it's not polymorphic recursion
10:15:31 <ski> (if it was that easy, it'd not be much of a challenge, now would it ? :)
10:16:12 <ski> (s/can't infer/can't let the interactor infer/)
10:16:24 <fresheyeball> hey folks
10:16:51 <fresheyeball> I'm looking at creating a type level proof
10:16:58 <fresheyeball> that a rational is within a bound
10:17:12 <[exa]> ski: well since the `cons' there is rigid, the inferred type is OK, isn't it? f->f is the only thing that satisfies f1->f2 and f2->f1
10:17:13 <fresheyeball> I started out looking at TypeLits
10:17:18 <fresheyeball> which seem very nice
10:17:31 <fresheyeball> but I'm not sure how to promote a term level nat to a type level one
10:17:35 <ski> [exa] : the inferred type is too restrictive
10:17:39 <fresheyeball> natVal does well for going the other way
10:17:48 <ski> (it works, but is not what i had in mind)
10:18:02 <[exa]> ski: what would the correct one be?
10:18:10 <[exa]> (or, less restrictive)
10:18:27 <ski> one ought to be able to apply `foldSwapList' to a value of type `SwapList Integer (Integer,Integer)', e.g.
10:18:42 <ski> [exa] : well .. that's the challenge
10:19:44 <[exa]> oldtimer solution is a class for Integer and (Integer,Integer) but let's forget about that
10:22:04 <ski> [exa] : .. one needs to be thinking "in the right direction", to do it. no sweat, if you don't figure it out (i can tell the answer i had in mind, whenever). i was just thinking that perhaps you (or innocent bystanders) would think it interesting to mull over, for some time
10:22:59 <ski> the intended implementation is obvious. the task is to find a type that can capture the generality of it
10:23:02 <[exa]> ski: well at worst I can get the Mu to construct the swaplist from parts, also stuffing the correct functions right into the structure in that process. Which will get a bit more complicated than a simple function, but will work
10:24:48 <ski> btw .. and this is *not* what i had in mind .. but, one can also imagine how one might *change* the implementation somewhat, in order to more easily be able to give it a type signature
10:24:52 <EvanR> (Integer, Natural)
10:25:06 <ski> in the `foldSwapList' case, one could pass *two* `cons' functions instead of one
10:25:29 <[exa]> I thought you'll have a solution to do it with one :D
10:25:33 <ski> (hm, and probably also two `nil's, now that i think about it)
10:25:45 <ski> [exa] : yes, that was the point
10:26:06 <ski> i'm just noting some alternate directions of departure, that could be interesting to explore
10:28:06 <[exa]> good point though, does SLN return the a-nil or b-nil?
10:28:15 <[exa]> SLN = SwapListNil
10:28:47 <ski> (btw, your  SL' a b  is basically just  [Either a b]  ..)
10:29:09 <[exa]> oh we only have one thing in each SL, so it's obvious
10:29:18 <[exa]> ok what next?
10:29:18 <ski> `SLN' has type `SwapList a b', for all `a' and `b'
10:29:29 * [exa] expecting some dramatic turnaround
10:29:59 <ski> (i didn't follow the "does SLN return the a-nil or b-nil?" question)
10:30:55 <[exa]> I viewed it from a bad direction and didn't know what type should the end of the list convert to, but it's obvious from type info
10:31:17 <ski> [exa] : what next ? well, explore, ponder, have fun ?!
10:34:12 <ski> (on further reflection, i think it was not `[Either a b]', but `([Either (a,b) (b,a)],Bool)' .. not that it matters much)
10:35:34 <[exa]> ski: anyway still getting foldSL2
10:35:34 <[exa]>   :: (t1 -> t1 -> t1) -> (t1 -> t1 -> t1) -> t1 -> t1 -> SL t t -> t1
10:35:57 <ski> passing the `cons'es around wrong ?
10:36:02 <[exa]> any better method to make haskell think about it than instantiating 2 different foldSL2 so that the poly-recursive HM succeeds?
10:36:21 <ski> also, you seem to not be using any element of the list ?
10:36:35 <ski> (unless your data type definition is borked)
10:36:43 <[exa]> no
10:37:23 <ski> i don't think you'd need two different versions, to get poly-rec.
10:37:43 <ski> (but you'd need a type signature)
10:39:35 <[exa]> trying it now
10:41:34 * [exa] leaves this for another time
10:42:38 <BadAtRecursion> So I was given an assignment to calculate the average length of words within a string, where the words are separated by numbers, whitespaces etc. I'm really not sure how to approach this problem. I can calculate the amount of letters just fine but counting the words is really difficult for me for some reason. Need some guidance if anyone is interested in helping a total newbie.
10:43:02 <ski> [exa] : *nod*. yell if you want to discuss it more
10:43:15 <[exa]> in fact I kindof expect this to get always unified to a single type, at least based on what THIH says. The extension
10:43:35 <[exa]> ...what's the name of the extension that gets type variables to inner function bindings?
10:43:53 <MichaelBurge> ScopedTypeVariables?
10:44:01 <fresheyeball> why is there no type family for division of type level naturals?
10:44:05 <Boreeas> Hi, I'm trying to write a mini-parser. In particular, given f, g of type '[Token] -> Maybe AST', I'm looking for a way to have f consume some prefix of the token stream and pass the remainder on to g, but I can't find a way to do that without returning tuples of '([Token], Maybe AST)' instead of just 'Maybe AST'
10:44:18 <ski> BadAtRecursion : would first collecting all the words in a list be a good intermediate step ?
10:44:22 <Boreeas> I know there are libraries like parsec that could do that for me, but I'm trying to solve it on my own
10:45:03 <[exa]> MichaelBurge: yes, thanks
10:45:08 <ski> Boreeas : then go ahead and try that instead ?
10:45:24 <ski> (not libraries, i mean. what you outlined)
10:45:57 <BadAtRecursion> ski : I have managed to split the string into a list of words (or I at least know how to) it's how to calculate the average afterwards that's really confusing.
10:46:07 <monochrom> BadAtRecursion: Write a function that spits out the words. Your own recursion, or Data.List.Split (package "split") can help.
10:46:17 <monochrom> Oh nevermind.
10:46:30 <ski> BadAtRecursion : ok, what is the definition of average ?
10:46:40 <MichaelBurge> Boreeas: I would probably move the parsers into a StateT, with the remaining text as the state. You could probably use Control.Monad.Cont to clean up the backtracking code, too.
10:46:42 <Boreeas> ski: That's my problem, I'm not sure where to go from here, because I don't know how much of the stream f will consume ahead of time
10:47:01 <BadAtRecursion> ski : all the letters/number of words
10:47:02 <ski> BadAtRecursion : perhaps it'd help if you defined an `average' function ? (you don't have to do this, but if you prefer, it might be nicer)
10:47:53 <ski> MichaelBurge : heh, Boreeas wanted to do it on their own, without libraries :)
10:48:28 <ski> Boreeas : exactly. so the alternative idea you mentioned seemed like a promising start ?
10:48:51 <BadAtRecursion> ski : yes, that's what I'm thinking too. I have an average :: String -> float, but I'm not sure how to deal with the list of words to get what I want
10:49:31 <monochrom> Do you know how to get the number of words from the list of words?
10:49:48 <ski> BadAtRecursion : i was more thinking of a function that computed the average of a bunch of *numbers*. i'm not quite sure i can guess what your `average' there does (perhaps it should be slightly renamed ?)
10:50:06 <Boreeas> ski: return tuples? yeah, that'd work, but it's kind of ugly, right?
10:50:36 <ski> (perhaps it computes the average count, for each kind of character in the string. that's the best guess i can make. but perhaps it's something else)
10:50:50 <ski> Boreeas : a little bit, yes
10:50:57 <monochrom> Ah yes, average of a list of numbers is more helpful.
10:51:18 <monochrom> Because now you just have to map the list of words to a list of numbers.
10:51:19 <ski> Boreeas : that's where "combinators" can help, hiding most of the clutter .. but that's the next step after getting it to work at all
10:51:38 <BadAtRecursion> ski : you mean I should start with a function that takes 2 ints and calculates the average as a float? (for instance)
10:52:08 <ski> BadAtRecursion : not necessarily two. it could take a list of numbers, couldn't it ?
10:52:26 <EvanR> [Number] -> Number
10:52:26 * monochrom frowns. "Two ints" sounds like you have very wrong concept about average.
10:52:32 <ski> BadAtRecursion : so that `average [2,2,2,10] = 4'
10:54:00 <BadAtRecursion> monochrom : ?? two ints and returns a float
10:54:13 <EvanR> average is an operation of a collection of numbers
10:54:14 <BadAtRecursion> it's not like the length of a word can be anything but a whole number
10:54:15 <ski> i think monochrom is saying "why two ints ?"
10:54:24 <monochrom> "two" is the wrong part.
10:54:36 <ski> or "why two *ints* ?", rather
10:54:43 <BadAtRecursion> I was thinking the number of letters (in total) divided by the number of words
10:54:47 <monochrom> Knowing how to average two numbers does not help you how to average fourteen numbers. Does not work that way.
10:55:08 <BadAtRecursion> if you bothered to read my question, we wouldn't need to have this conversation
10:55:20 <BadAtRecursion> fml
10:55:40 <EvanR> i dont recommend trying to write a function that takes 2 ints and returns a float
10:56:01 <EvanR> if you need to know more about that, then we can discuss it more
10:56:02 <ski> "number of letters (in total) divided by the number of words" will not help
10:56:17 <ski> BadAtRecursion : i'm sorry, what makes you think we didn't ?
10:56:47 <BadAtRecursion> ski : sorry, that was not directed to you. So you're saying that it should take the list with words? 
10:57:07 <ski> BadAtRecursion : from our perspective, it appears that you may be making some oversights, and so we're trying to gently prod you in the right direction, without revealing too much about the solution
10:57:07 <EvanR> average of a bunch of numbers = sum of numbers / number of numbers
10:58:51 <BadAtRecursion> Okay so... Let me rephrase. I have a list of words, I want to find the average length of the words in the list. And since ski suggested I'd write a function for the average first, I thought he meant one that takes the total amount of letters as well as the number of list elements
10:59:06 <EvanR> it should take a list of numbers
10:59:12 <Cale> BadAtRecursion: Yeah, just the average of a list of numbers, in general
10:59:32 <BadAtRecursion> So how do I turn the list of words into a list of numbers?
10:59:34 <EvanR> then you can get the list of numbers from your input data, somehow
10:59:37 <ski> BadAtRecursion : ok, sorry, i was unclear. i meant an average function that takes a list of numbers (could be counts or whatever), and computes the average of those numbers
11:00:25 <BadAtRecursion> yes, that sounds like a very good idea, ski, but I'm not sure how to go from list of letters to list of numbers
11:00:35 <Cale> BadAtRecursion: Well, we'll break that up into two parts as well: 1) a function turning a single word into a number and 2) applying a function to each of a list of elements to obtain another list
11:00:54 <EvanR> if you had a list of words, do you see how to get a list of numbers?
11:01:06 <ski> BadAtRecursion : to answer that question, you need to somehow look through the whole list, keeping track of which words you've already seen, and how many times. when you're done with that, you should have a count for every word occuring in the string
11:01:15 <ski> (or in the list of words, really)
11:01:40 <Cale> BadAtRecursion: So, do you know how to do (1)?
11:03:32 <ski> BadAtRecursion : when doing problems like this, it's useful to break it up into smaller problems, and then focusing on one of them at a time, ignoring the others. start focusing on the subproblem that you prefer, perhaps the one that seems most obvious/easy to you
11:03:33 <BadAtRecursion> Cale: Yes, is there a better way than to do it recursively though? 
11:03:46 <BadAtRecursion> ski : thanks, that's a very good suggestion
11:04:40 <ski> BadAtRecursion : e.g. you could implement the average of bunch of numbers function first. or the function that given a list of *words* (not letters) computes the counts, ignoring for the moment how to get from the initial string (i.e. list of characters, such as letters, digits, &c.) to the list of words
11:04:58 <ski> BadAtRecursion : or perhaps you'd prefer starting with how to get to the list of words
11:05:02 <ski> it's your choice
11:05:22 <ski> you could also imagine some alternative subdivision of the problem into subproblems, if you prefer
11:05:55 <ski> BadAtRecursion : recursion will probably be a part of it, one way or another
11:06:09 <ski> (for at least some of the subproblems)
11:07:00 <ski> (in some cases, you may be able to use standard list processing functions from the `Prelude'. but most of them internally hide some recursion anyway, even if you don't see it explicitly)
11:07:34 <BadAtRecursion> I'll try Cales way of breaking down the problem, creating a function that calculates letters for single words and then applying it to a list of words.
11:07:57 <BadAtRecursion> Yeah, I know I have to know a lot of recursion, it's just that I'm not very good at it. 
11:08:01 <ski> 1) a function turning a single word into a number
11:08:08 <ski> he said "numbers", not "letters"
11:08:18 <BadAtRecursion> Sorry, I meant number of letters.
11:08:19 <ski> (may just have been a typo/thinko on your part)
11:08:21 * ski nods
11:08:25 <ski> no worry
11:09:20 <BadAtRecursion> Wait, I'll hop back on as soon as I'm home. I really appreciate the help so far!
11:10:20 * hackagebot dhall-nix 1.0.6 – Dhall to Nix compiler – https://hackage.haskell.org/package/dhall-nix
11:10:38 <monochrom> ski, why is it not also the total number of letters divided by the number of words?
11:18:00 <jared-w> Because the average length of a word is dependent on how long each word is and that formula is only the correct average when each word is the same length
11:18:46 <ski> monochrom : i dunno, maybe it is ? it's not obvious to me, though
11:19:01 <jared-w> Given 499 words each 2 letters long, and 1 word 10,000 letters long. The average length of a word should still be very close to 2 should it not?
11:19:57 <monochrom> Do you agree (499*2 + 10000*1)/500 is right?
11:19:58 <ski> > (499 * 2 + 1 * 10000) / 500
11:20:01 <lambdabot>  21.996
11:20:38 <monochrom> But then 499*2+10000*1 is the total number of letters.
11:21:04 <jared-w> > (10000 + 499*2) / 500
11:21:06 <lambdabot>  21.996
11:21:30 <jared-w> oh right, ski already wrote that, m'bad
11:21:43 <ski> monochrom : ok, seems it works, then :} cool !
11:23:37 <monochrom> More fusionly, (\xs -> sum xs / length xs)  (map length words) = sum (map length words) / (length words) = length (concat words) / (length words)
11:27:03 <jared-w> ooooh
11:27:22 <jared-w> What monochrom said was the arithmetic average (the mean) and that's the correct calculation for that
11:27:44 <jared-w> I was thinking of the geometric average
11:27:53 <jared-w> geometric mean*
11:27:56 <monochrom> :S
11:28:04 <ski> with `words = extractWords string', we have `concat words = string'
11:28:13 <ski> jared-w : hehe .. any idea why ?
11:28:24 <jared-w> (2^499 * 10000)^(1/500)  -> 2.0343605977...
11:28:30 <monochrom> No, you probably want to drop the commas and the spaces and ...
11:28:32 <Cale> It's unusual to use the geometric mean for things which are not naturally multiplicative
11:28:47 <ski> er, right. modulo a `filter' or two, then
11:29:10 <jared-w> Because I was thinking "if you have 500 words with length 2 and one word that's super friggin long, I'd still expect the average to be very very close to 2"
11:29:39 <ski> jared-w : perhaps medians also lurked in your mind ?
11:29:58 <jared-w> Also quite possible. I know just enough statistics to use it for great evil ;)
11:30:32 <Cale> If you were taking the average of a bunch of scaling factors (e.g. % improvements in time across a bunch of benchmarks), the geometric mean would be appropriate.
11:30:56 <monochrom> jared-w, when I was a student, my marks were way above the rest of the class. I had very first-person experience how I single-handedly distort the class average. >:)
11:31:04 <Cale> haha
11:31:14 <jared-w> lol people like me hated people like you :p
11:31:24 <jared-w> There's also the weighted mean and like 20 others I didn't even know about that I just found out about while reading the wikipedia page...
11:32:10 <Cale> I remember one time in highschool, in one of the three OAC (grade 13) math courses we had, the homework was optional, but after the midterm, the teacher made a plot of homework completed vs. the midterm grade
11:32:33 <[exa]> oh, education.
11:32:57 <Cale> and while everyone else was nicely correlated, I had done none of the homework and had the best grade on the midterm
11:33:13 <ski> exercise, write a function `orderStatistic :: Ord a => Int -> [a] -> a' such that `orderStatistic k as', for a list `as' of length greater than `k', gives `sort as !! k', using only `max' and `min' from `Ord'
11:33:21 <monochrom> If you have a lot of students, the median is a better measure.
11:33:23 <jared-w> lol nice. Why did you do so well on the midterm? Was it just math you already knew?
11:33:34 <ski> (so, don't use `sort')
11:33:36 <Cale> jared-w: Yeah, I already knew everything there
11:33:54 <monochrom> Then again, if you have a lot of students, various statistics theorems such as the law of large numbers also imply that the average is also OK.
11:33:57 <Cale> I was practically helping to teach the course :P
11:34:21 <ski> (you may assume that `compare x y = EQ' implies `x = y'. so sort stability is not an issue)
11:34:30 <jared-w> I've done that before with an AI course at college
11:35:42 <jared-w> except my ADHD and deafness kicked in and I got pretty low grades on a lot of stuff and then the professor called me in around finals all pissed and she's like "how am I supposed to give you a D when you're the brightest kid in the class? I'm giving you an A because your final was excellent even though we both know you spent only a tiny bit of effort on it. Please don't make me regret this"
11:36:02 <monochrom> ski: I can use max and min. Can I also use (==) ? For example I have exactly in mind "max x y == x".
11:37:27 <Cale> jared-w: I usually had the opposite problem in university. I would do excellent at everything except the finals, which I often felt ended up being very unrepresentative of what I knew.
11:37:46 <monochrom> Cale: Optional homework should be modelled by the Option type in SML so that your case was not a deviation. :)
11:37:53 <jared-w> Odd ¯\_(ツ)_/¯  that was just the one final though
11:38:01 <ski> Cale : hm, in a course, there were optional (but strongly recommended) computer tests (with time limit). i didn't bother to try them. after the exam (which got close to full on, iirc), i heard there was a strong correlation between people doing the computer tests and getting high points on the exam .. with one or a couple notable exceptions
11:38:17 <ski> monochrom : you shouldn't need to
11:38:21 <jared-w> Generally for me I end up understanding everything quite well in the abstract and in the larger picture but often struggle with the minor details
11:38:30 <monochrom> Ah OK!
11:38:34 <ski> monochrom : it's more of a math exercise, than a programming one
11:38:45 <jared-w> and my homework/final grades never reflect my actual knowledge of the course since I often end up being able to explain everything to the A students... *sigh*
11:39:21 <Cale> jared-w: In my case, it was usually that I'd have trouble when feeling the time pressure on an exam.
11:40:04 <maerwald> Cale: and... you never really have that time pressure (as in: finish within hours) in real-world, so it's just constructed crap :P
11:40:30 <Cale> maerwald: Usually anyway -- especially not with pure mathematics
11:40:42 <monochrom> Wait, I thought every programmer said they were under time pressure in the real world.
11:40:42 <maerwald> solve maths problems at gunpoint!
11:40:45 <Cale> There are deadlines in the real world, but they're much softer
11:40:53 <ski> (well, even correlation with not failing the course)
11:41:18 <Cale> It's usually not like "do this thing from start to finish in 3 hours"
11:41:48 <maerwald> the maths soldier... maybe school is just a military program that accidentially derailed?
11:42:09 <maerwald> code behind enemy lines
11:42:38 <monochrom> Marks are complicated.
11:42:56 <maerwald> nah, they are just nonsense :)
11:43:45 <monochrom> For example, there is also the conflict between "we want to assess you, so we have to monitor you and not allow you to talk to other people" and "but in the real world you usually work with other people".
11:46:11 <monochrom> I did my part in making exams less artificial. I made my exams open-book.
11:47:35 <maerwald> teachers are an obsolete concept, as are exams. But the alternative methods take more care about individuals, so they seem impossible to implement in our society
11:48:20 <monochrom> Yeah they are way more expensive than conventional school and exams.
11:48:46 <monochrom> The upshot is no one wants to pay that price.
11:49:08 <maerwald> IRC is... in a sense... almost what school should have been. Go somewhere and ask questions, get help when you _need_ help. Don't get dictated.
11:49:10 <ski> i don't think teachers are obsolete
11:49:33 <Limeth_> Hello, I'd like to learn Haskell! Is some step-by-step guide on how to create some fun project?
11:50:01 <Limeth_> Something I could follow along while learning the concepts of the language?
11:50:15 <monochrom> No, especially if it has to be fun.
11:50:59 <maerwald> ski: well, you cannot remove them in our system. But that was not the point
11:51:14 <ski> (while people can and do learn on their own, thinking about and processing material from various (static) sources, a teacher can attempt to give more fine-tuned answers, taking the situation, current knowledge, learning style, &c. into account)
11:51:19 <Limeth_> Fun as in interesting.
11:51:40 <monochrom> Same.
11:51:43 <maerwald> ski: that's effectively not a teacher anymore ;)
11:51:50 <maerwald> that's a _guide_
11:51:58 <ski> it's what i mean by a teacher
11:52:07 <maerwald> that's not what a teacher is today, not at all
11:52:17 <ski> may well be
11:52:25 <monochrom> OK, I think we can more precisely say "lecturer vs private tutor".
11:52:28 <maerwald> @learnhaskell
11:52:28 <lambdabot> Unknown command, try @list
11:52:34 <maerwald> @where learnhaskell
11:52:34 <lambdabot> https://github.com/bitemyapp/learnhaskell
11:52:38 <maerwald> Limeth_: ^
11:53:17 <monochrom> But seeing how people say "I love watching youtube lectures", "where are some youtube lectures for monads?", I don't think lecturers are obsolete yet.
11:54:27 <maerwald> good lecturerers are entertainers. Very rare
11:54:32 <monochrom> As for why they don't ask around for private tutors, I think it's simply because they saw edwardk's price quote and chicken out. :D
11:55:12 * ski . o O ( "There’s no constructive theory of fun" in 2008-10-13 at <http://viridia.org/2008/10/13/theres-no-constructive-theory-of-fun/>,"What game designers should never do" in 2007-04-16 at <http://viridia.org/2007/04/16/game-designers-should-never-do/>, both by Talin (David Joiner) )
11:55:25 <ski> Limeth_ ^
11:56:11 <ski> monochrom : which quote would that be ?
11:56:45 <maerwald> ski: lol
11:57:21 <monochrom> I forgot. Maybe $100/hour?
11:57:38 <Limeth_> Thanks for the link, maerwald.
11:57:52 <maerwald> Limeth_: specifically https://www.seas.upenn.edu/~cis194/spring13/lectures.html is recommended
11:58:07 <maerwald> you can walk through it at your own pace, good homeworks
11:58:40 <maerwald> and it deals with pretty much the strongest show-case solution haskell has: parser combinators
12:00:13 <ski> Limeth_ : it's also recommended to ask e.g. here (or #haskell-beginners, perhaps), or on the mailing lists (or usenet, if you're into that), for help with tackling errors, problems, &c.
12:00:28 <monochrom> edwardk registered himself on one of those hire-a-coder website and put his very-high price quote there. I forgot the url. But next time I come across it I'm going to bookmark it! Priceless.
12:00:41 <ski> (ftr, newbie questions are welcome on this channel)
12:01:03 <monochrom> "Hiring edwardk for one hour: $100. Your face when you learn that price: Priceless."
12:01:25 <maerwald> 100$? lol
12:01:30 <maerwald> must be a joke
12:01:32 <EvanR> undervalued
12:01:56 <monochrom> It's probably even more than $100. I forgot the actual price. I'm making it up based on "double monochrom's price".
12:02:54 <EvanR> my cello teacher's price = monochrom's price
12:03:02 <EvanR> food for thought
12:03:37 <monochrom> And aw, I haven't checked comp.lang.haskell for a while.
12:04:26 <Limeth_> ski: Good to know, thanks.
12:04:49 <monochrom> hahaha "can haskell obsolete oracle and ibm and microsft fabook google apple? on freebsd?"  What a crackpot.
12:05:49 * hackagebot dhall-bash 1.0.4, dhall-json 1.0.6, dhall-text 1.0.2
12:05:49 * hackagebot  → https://hackage.haskell.org/packages/recent
12:06:51 <monochrom> Hey maybe I should answer.
12:06:56 <EvanR> speaking of which, anyone want to hire a coder, PM me
12:07:23 <monochrom> Nevermind, it's a month ago.
12:07:59 <maerwald> EvanR: I'd hire you for playing cello, but not for coding
12:08:21 <maerwald> (I can code myself, but cello is nice)
12:08:53 <EvanR> i guess i figured out my retirement plan, in 2080 when everyone and their dog can code i will be useless
12:09:26 <maerwald> 2080?
12:09:30 <maerwald> ambitious
12:09:42 <maerwald> you will live on mars then? :P
12:10:13 <EvanR> by then people dont retire until they are 95
12:11:09 * maerwald thinks of soylent green
12:11:15 <maerwald> retirement? ;)
12:11:21 <EvanR> "retirement"
12:11:24 <maerwald> if you can't code, you'll be food.
12:12:05 <maerwald> with that in mind, maybe even Cale will write a good exam
12:12:25 <monochrom> Will you code for food?
12:12:30 <maerwald> lol...
12:12:49 <EvanR> yes
12:13:21 <monochrom> Yeah, let's make a movie about the future dystopia in which these two statements are true: "if you can code, you code for food" and "if you can't code, you are said food".
12:13:23 <ski> will you code the processing of food ?
12:14:19 <fresheyeball> is there a way with singletons to have a constraints that is Ord?
12:14:27 <fresheyeball> I'm looking for something like
12:14:49 <fresheyeball> (Compare n d ~ LT || Compare n d ~ EQ)
12:15:00 <maerwald> monochrom: imagine you eat a smart coder then and suddenly solve unsolved algorithmic problems!
12:15:11 * ski hasn't tried making division constraints
12:15:43 * maerwald is going to write a script for a trash movie
12:17:04 <ski> haven't you heard, the new hip thing is to let a neural network write your movie scripts for you ?
12:17:11 <MarcelineVQ> but if you code a robot that codes does the robot get the food?
12:17:37 <ski> it gets power, maintainence
12:17:49 <ski> possibly from burning calories in foodstuffs
12:17:50 <monochrom> The robot gets the food and then gives it to me.
12:18:12 <platz> is there a way to pass command-line arguments to "stack build --test"? when I try using --test-arguments "http://0.0.0.0/v2" i am able to access it via getArgs, but the Hspec tests fail with tests: unexpected argument `http://0.0.0.0/v2'
12:18:33 <MarcelineVQ> monochrom: now you're thinkin like a CEO
12:19:27 <monochrom> If that is true, almost every circus owner thinks like CEOs, too.
12:19:43 <MarcelineVQ> surely
12:19:59 <platz> maybe i can just use an environment variable
12:20:46 <monochrom> OK! Back to continue reading the Backpack thesis.
12:21:01 <monochrom> err, continuing! Damn English.
12:22:19 * ski yesterday was about to misspell "continuous" as "continuation"
12:23:09 <MarcelineVQ> ski: you monster
12:23:45 <ski> (by mistake, of course)
12:38:37 <ignamv> writing parsers in HS is sort of fun
12:39:45 <[exa]> "it works" type of fun? :]
12:42:08 <pikajude> is there a straightforward way to modify async's mapConcurrently to only execute a specific number of threads at a time?
12:44:34 <pikajude> maybe I could just use QSem
12:44:44 <ski> if you have a list, i suppose you could group it, then concat at the end
12:44:54 <pikajude> well, that'll do things in chunks of 10 (or whatever number)
12:44:58 <pikajude> but i'd rather have at most 10 tasks running at a time
12:45:05 <pikajude> and i think that's what qsem is designed for, so I'll use that
12:45:10 <ski>   transpose . chunksOf 10
12:45:27 <ski> (`concat . transpose' at the end, if you care about the order)
12:45:56 <pikajude> yeah, but if a chunk of 10 has a really long-running job, there will be an interval where only one task is running
12:46:24 <ski> not talking about chunks of ten
12:46:40 <pikajude> ?
12:46:49 <ski> > (transpose . chunksOf 3) ['a' .. 'z']
12:46:51 <lambdabot>  ["adgjmpsvy","behknqtwz","cfilorux"]
12:46:58 <ski> three chunks, not chunks of three
12:47:07 <pikajude> oh ok
12:47:08 <pikajude> cool
12:48:17 <ski> of course, you might still be really unlucky, and get very unbalanced tasks .. but at least less likely here than with what you were describing
12:49:12 <ski> (a `QSem'-solution wouldn't do static assignment at all, so would be most flexible i suppose .. at least without no prior information on what to expect about the time taken for the tasks)
12:50:17 <ski> (.. but knowing about the `transpose . chunksOf n' trick can be useful)
12:52:15 <jared-w> Writing documentation is difficult *sigh*. I think it mostly comes from the fact that the brain never stores anything linearly or in some sort of wiki format yet somehow all the knowledge has to be unwravled into that format...
12:54:15 <monochrom> Yes, this is half of why writing a thesis is so hard, and whoever gets it done is celebrated with a party.
12:54:40 <monochrom> (The other half is choosing a good problem and its scope to work on.)
12:57:05 <[exa]> jared-w: draw a thinkmap or a diagram and use rigorous flattening tools on that
12:58:00 <Tuplanolla> Tell a story, but keep it shallow, jared-w.
12:58:14 <jared-w> oooh, that's a good idea [exa]
12:59:44 <Tuplanolla> See `texdoc tikz` or `texdoc beamer` for examples, jared-w.
13:04:00 <Yuuri> Is aeson a library of choice for JSON parsing? Are there reasons to prefer any other?
13:05:00 * hackagebot mbtiles 0.6.0.0 – Haskell MBTiles client. – https://hackage.haskell.org/package/mbtiles
13:05:20 <jared-w> Tuplanolla: I'll check those out, thanks :)
13:05:49 <epta> is there any way to add all library deps as a test deps automatically (except hpack)?
13:06:31 <monochrom> Yuuri: I use aeson. I don't know there are others.
13:12:30 <cocreature> there are some other libs but aeson is by far the most popular one
13:14:00 <Limeth_> Any easy way to run `stack ghci` with "syntax highlighting"? Like some sort of colored mode?
13:15:43 <jared-w> syntax highlighting? In GHCi?
13:16:20 <jared-w> There's ghci --color
13:16:21 <Limeth_> Something like this: https://camo.githubusercontent.com/7ba745679887b0192bb52045e2eca1f4b3377c77/68747470733a2f2f7261772e6769746875622e636f6d2f72687973642f676863692d636f6c6f722f6d61737465722f6361702e6a7067
13:18:15 <epta> jared-w: any way to pass it to 'cabal new-repl'?
13:19:07 <cocreature> jared-w: are you sure that’s a thing? doesn’t seem to work for me
13:19:16 <jared-w> oh whoops, I was reading the wiki page wrong
13:19:19 <Limeth_> jared-w: It outputs 'ghc: unrecognised flag: --color' when I run `ghci --color`
13:19:41 <cocreature> jared-w: for a short moment I was very exited :)
13:19:45 <Limeth_> Yeah, I was reading the same thing :D
13:20:13 <jared-w> my apologies lol. I was also excited
13:20:23 <geekosaur> I think there's a hack to pipe ghci output through hscolour, but that's it
13:20:46 <Tuplanolla> It breaks a lot.
13:20:48 <jared-w> https://github.com/rhysd/ghci-color  there's this which implements the 'sed' hackery that's mentioned in the wiki
13:22:06 <Limeth_> I've found this, which uses hscolour, but the post is from 4 years ago. https://www.reddit.com/r/haskell/comments/144biy/pretty_output_in_ghci_howto_in_comments/
13:22:21 <jared-w> That's the one that breaks a lot :)
13:23:41 <Limeth_> I'll give 'ghci-color' a try, then
13:28:41 <L8> hey guys, question: how can I pattern match a record of a specific value? for example, having: "data Car = Car { name :: String }"; I want to return a value when I'm calling my function with Car "Tesla"
13:29:19 <L8> so that my function (someFunc :: Car -> Bool), will do: someFunc Car("Tesla") = True
13:32:11 <geekosaur> you can match it positionally like a non-record: someFunc (Car "Tesla") = ...
13:32:48 <geekosaur> or do the same with field selection sntax: someFunc (Car {name = "Tesla"}) = ...
13:33:16 <geekosaur> te positional form requires you have fields in the same order as declared; record syntax can be in any order
13:34:03 <L8> geekosaur, right, thanks!
13:34:21 <L8> I did the same thing initially but GHC complained about redundant pattern matching
13:34:45 <L8> I was thinking that maybe he's ignoring concrete values, but looking again I actually had redundent definitions
13:34:50 <L8> silly me.
13:38:05 <thoughtpolice> L8: For the record, you can even be super fancy if you want: `someFunc car@(Car {}) | name car == "Tesla" = ...`
13:38:31 <thoughtpolice> I'm weird, but I like this style. It's also more convenient IMO if you want to check multiple things (for example, if you wanted to check cost, you could change the clause to `| name car == "Tesla", cost car < 50000 = ...`, etc)
13:39:49 <L8> thoughtpolice, for my case I just want to apply some "sample data", so my actual function is called "getState" and for a given x and y it returns a boolean
13:39:51 <thoughtpolice> The empty `{}` syntax also means that the pattern match is independent of the number of arguments to the constructor; e.g. if you add another argument to `Car`, the match still works as expected.
13:40:18 <L8> and thanks for the alternative! :)
13:41:07 <mac10688> http://lpaste.net/358168
13:41:27 <mac10688> anyone know how to make the buildItemArmor function simpler?
13:41:52 <thoughtpolice> L8: Right, there are many, many ways to pattern match in Haskell, so you can pick and choose. Most of those features work in any place a pattern match occurs, too.
13:43:38 <thoughtpolice> So you can also do `case x of { Foo a b | a == 10 -> ...; Foo a b -> ...; _ -> ... }` by using `|` on the case clause. Or you can use it with `let` too, like `let x | b == True = ...`, etc
13:44:39 <thoughtpolice> So practically any place you can do a pattern match, you can add a guard, @ patterns, etc. If you keep this in mind you can keep some code pretty clean, especially with -XPatternSynonyms.
13:45:32 <thoughtpolice> It's especially useful with `case`, IMO.
13:49:14 <edwardk> monochrom: the price was for 15 minutes actually
13:49:24 <monochrom> Oh haha
13:49:36 <edwardk> monochrom: I wanted to make sure that if someone had an urgent haskell question they could always get an answer
13:49:44 <edwardk> As a sort of support backstop
13:49:45 <monochrom> What is that URL again where you have your coding/coaching rate?
13:49:54 <edwardk> I since dropped it
13:50:00 <monochrom> booo...
13:50:07 <edwardk> It was getting too many false positives
13:50:32 <edwardk> And I never actually charged any of the folks who asked me questions
13:50:49 <monochrom> Wait, false positives? People enquired you for PHP help or something?
13:51:26 <edwardk> The meta discussion was more noise than the discussion
13:52:58 <crucify_me> hi I have an error on the last line here. not sure what's going on: https://ptpb.pw/ztjA
13:54:29 <Limeth_> Done customizing my Haskell REPL: https://i.imgur.com/MRnITWO.png
13:55:21 <monochrom> crucify_me: It looks like it should be palbool :: Bool -> String
13:55:45 <crucify_me> thanks! checking that
13:56:52 <c_wraith> crucify_me: I suspect that code isn't what you want at all.
13:57:14 <c_wraith> crucify_me: as it stands, you might as well replace palbool with const "no"
13:57:26 <edwardk> Managed to get the relative map stuff to work on the flight out here, now I just need to finish up some convenience relative Foldable stuff so I can have nice show/eq/ord for relative containers
13:57:30 <monochrom> There is also that.
13:58:04 <edwardk> Also managed to finish up my relative catenable lists
13:58:20 <c_wraith> edwardk: at the risk of falling into the rabbit hole, got a reference for relative data structures?
13:59:39 <edwardk> c_wraith: github.com/ekmet/coda the Coda.Relative.Delta  and Class
13:59:58 <edwardk> Data structures where I can act on them "slowly" with a particular monoid
14:00:08 <c_wraith> For anyone following that link, edwardk can't spell his own name correctly.
14:00:14 <edwardk> In this case the monoid is the # of chars
14:00:17 <c_wraith> I would tease him for that, but I have similar problems. :)
14:00:21 <edwardk> Hah on a phone
14:01:04 <edwardk> Anyways the classes in there extend the concept in various ways so that I can say relocate all the keys and values in a map in O(1)
14:01:20 <edwardk> Which is key to the project in that folder
14:04:33 <crucify_me> thanks that compiles mono*chrom . but I thought compositions are read from left to right 
14:05:32 <monochrom> I wouldn't hardcode myself to always reading left-to-right or always reading right-to-left. It depends on the purpose of reading.
14:05:46 <epta> http://lpaste.net/raw/4724907489563246592 is there any way to do that except standalone deriving declarations?
14:06:46 * hackagebot Villefort 0.1.1.11, google-static-maps 0.5.0.1, grammatical-parsers 0.2, servant-purescript 0.8.0.1, … and 1 more
14:06:46 * hackagebot  → https://hackage.haskell.org/packages/recent
14:06:50 <edwardk> c_wraith basically rel can be used to move whole containers of errors, token sequences, parse trees, etc around
14:06:52 <c_wraith> epta: Well, technically, you could write the instance yourself.  But I don't think that's what you mean.
14:07:28 <c_wraith> epta: StandaloneDeriving allows you to specify constraints.  That's why it will work there.
14:08:54 <edwardk> To let it relocate map keys you need x < y implies rel d x < rel d y. But this is a really common property
14:10:01 <edwardk> So I have classes in there for if rel distributes over the monoid, is monotone, etc
14:10:52 <c_wraith> Yeah, I see what's going on.  It's one of those things that seems obvious in retrospect
14:11:57 <edwardk> Coda.Syntax.Line has machinery for converting to a more traditional line/col
14:15:30 <artem> what's the idiomatic way of appending one element to the end of array?
14:15:41 <edwardk> i'm currently using # of utf-16 codepoints rather than line/col because it is a bit more compact internally to be able to annotate a syntax tree with just an extra int here and there and because it gives me a full abelian group rather than just a monoid for merging partial positions
14:15:57 <edwardk> er code units
14:16:39 <ski> artem : the idiomatic way would be to not do that
14:16:42 <glguy> artem: The idiomatic solution would probably be to pick a different type
14:17:01 <edwardk> c_wraith: the cost of it is you never really want to do all the usual functory things to your containers.. because they'd be too slow anyways
14:17:22 <ski> artem : if by "array" you mean "list", then one option may be adding to the front instead. and then perhaps, once finally, do a reverse
14:17:54 <artem> by array i mean Data.Array
14:18:06 <c_wraith> Array is a terrible structure to add to
14:18:43 <artem> okay, what would be a good structure for O(1) index access
14:18:45 <edwardk> TIL people still use Data.Array
14:18:57 <artem> i'm learning
14:19:09 <edwardk> artem: you want O(1) access and cheap cons? can't have it
14:19:19 <edwardk> you can have log time access and O(1) cons
14:19:52 <crucify_me> monochrom, pardon, as it stands, how can I be sure all 3 functions are utilized?  https://ptpb.pw/O4iW
14:20:16 <edwardk> Data.Sequence offers O(1) cons and log time access
14:20:21 <edwardk> and log time append
14:21:13 <ski> edwardk : i occasionally use immutable arrays for dynamic programming (at least when there's not an easy pattern of only needing to remember some items, like the last `n' ones)
14:21:20 <monochrom> I don't understand the question. Apart from: If you use palBool, it will use pal' and boolToString. Done.
14:21:23 <edwardk> the problem is in a functional setting you don't have enough time to build the structure between conses.
14:22:02 <crucify_me> palbool doesn't take an argument. sorry, confused here
14:22:34 <monochrom> That is true and false depending on what you mean.
14:23:07 <monochrom> The code doesn't show a parameter. But when you use it you can provide one. It won't hate you.
14:23:07 <crucify_me> sorry , how to call the function on "asisa"
14:23:25 <monochrom> The parameter has type Bool. Use True or False.
14:23:31 <edwardk> ski: I often use a dynamization scheme like this one where the 'a's might be array types and the like. https://www.irccloud.com/pastebin/VeOv5tnH/Dyn.hs
14:23:42 <monochrom> It's Bool -> String, not String -> ???.
14:24:04 <jared-w> monochrom: earlier on I showed how to split pal' into a palindrome and boolToString function and accidentally wrote `palbool = palindrome . boolToString` instead of the other way around. I think that's where most of the confusion comes from so far...
14:24:35 <edwardk> to take a container type that is a monoid that has some form of query that is a monoid homomorphism and turn a static structure that has a linear mappend into one with a log time slower query and log time mappend on an amortized basis
14:24:50 <monochrom> The problem is that "boolToString . pal' " is a type error.
14:25:53 <L8> http://lpaste.net/358170
14:26:02 <jared-w> monochrom: yeah the first time I wrote this out I typed pal' twice, but meant two different palindrome functions in my head. I didn't convey all of that as cleanly as I should have, apparently :p
14:26:03 <monochrom> But perhaps palindrome has the correct type for boolToString.palindrome to make sense.
14:26:08 <c_wraith> crucify_me: I think the real problem is that pal' should not be duplicating the logic of boolToString.  I think it should have the type String -> Bool
14:26:16 <L8> I'm missing something, but my function returns True / False only considering the first element for some reason
14:26:57 <crucify_me> I thought that duplication would cause it not to compile at first, but it did. so I'm lost right now c_wraith et al
14:27:12 <monochrom> This is why programming is so hard.
14:27:19 <crucify_me> bloody hard
14:27:56 <L8> nvm, understood my mistake:)
14:28:04 <jared-w> L8: what was it? 
14:28:05 <c_wraith> L8: did you want any instead of all?
14:28:13 <L8> indeed
14:28:27 <monochrom> If it doesn't type-check, you're back to square 1. If it gives the wrong answer, you're back to square 1. If it doesn't give any answer at all after an hour, you're back to square 1. On every slightest pretext it sends you back to square 1.
14:29:12 <crucify_me> so just looking at that, the 2 logic statements appear that it would be tripped up
14:29:18 <jared-w> L8: you can also write 'isOccupied x xs = all (/= x) xs` which is the same as `isOccupied x = all (/= x)`
14:29:44 <jared-w> (or, rather, 'any' since that's the function you actually wanted)
14:29:47 <L8> jared-w, cool!
14:29:59 <L8> there's so much syntax tricks I need to remember
14:30:04 <L8> I'll get that eventually
14:30:15 <jared-w> There's two separate syntax "tricks" there, both related concepts
14:30:18 <L8> but the reason I started writing this because I'm also adding case of clause over the lamba
14:30:38 <jared-w> The first trick is a slice, related to the concept of partial application
14:30:43 <jared-w> :t (+2)
14:30:44 <lambdabot> Num a => a -> a
14:30:52 <jared-w> :t (/= 3)
14:30:53 <lambdabot> (Num a, Eq a) => a -> Bool
14:31:25 <crucify_me> no doesn't pal' need to return a Bool ?
14:31:37 <jared-w> (+2) is a function taking one argument and returning that argument +2. /= 3 takes one argument and returns whether or not it's not-equal, etc.
14:31:39 <crucify_me> it returns a "yes" or "no"
14:32:06 <jared-w> The second trick is eta reduction, again related to partial application.
14:33:03 <L8> jared-w, http://lpaste.net/358170
14:33:06 <L8> any nicer way doing that?
14:34:26 <jared-w> there's lambda-case to make things slightly prettier
14:35:39 <L8> jared-w, I saw that here: https://downloads.haskell.org/~ghc/7.6.2/docs/html/users_guide/syntax-extns.html
14:35:51 <L8> but it says that I need to set the XLambdaCase flag explicitly
14:35:57 <L8> this feature enabled by default?
14:36:12 <jared-w> You need to use a pragma for LambdaCase
14:36:19 <jared-w> Not really worth it in most cases, fo rme
14:36:35 <L8> then I'll stick with this :)
14:36:58 <jared-w> What's much cleaner is to just indent the case statement. Lambda functions can be multiline
14:37:07 <jared-w> (refresh your lpaste; I edited it)
14:37:46 <L8> jared-w, agree
14:37:51 <L8> added another small change
14:37:54 <L8> state => _
14:38:57 <jared-w> E is empty, O is occupied, B and W are black and white?
14:39:02 <L8> yep
14:39:43 <jared-w> What's the purpose of the isOccupied function then? It seems to be lying (only Empty is actually not occupied)
14:40:39 <L8> so I'm interviewing currently at some company, and last Friday I had a last phone/screen interview asking me a game-board question (I'll explain more if you'd like), so now I'm implementing the same solution I did just in Haskell
14:41:14 <L8> mostly to force myself feel more comfortable in Haskell, so next time I could implement the solution in Haskell during the interview :)
14:41:18 <jared-w> The 8 queens question?
14:41:42 <L8> not familiar with the 8 queens question, it was a go board game question
14:42:02 <jared-w> ahh gotcha, now isOccupied makes sense
14:42:22 <L8> jared-w, once I'll done with my code I'll paste it here so you could code-review me if you want :)
14:42:29 <jared-w> (8 queens is "given a NxN chessboard, how many ways can you place 8 queens on the board such that they can't kill each other?")
14:42:36 <jared-w> L8: sure
14:43:10 <L8> jared-w, every time I see such questions I have this uncomfortable feeling
14:43:27 <L8> I don't know, I just dislike this kind of questions
14:43:37 <L8> same goes with this question I'm solving now
14:44:36 <jared-w> What question is the one you're solving now? Just out of curiosity
14:45:35 <L8> jared-w, (sorry for badly copied board): http://lpaste.net/2169715399451475968
14:46:07 <L8> for a given cords, you need to tell if a piece is captured or not
14:46:34 <L8> captured defined by if there's opposite piece surrounding your piece
14:47:23 <L8> for example, looking at (x=1, y=1), it's captured because there's no up (O = out of bound), no left (O), right is W and down is W
14:47:50 <L8> same goes with line 7: B is surrounded by W
14:48:04 <L8> (sorry, line 8)
14:48:26 <L8> if like 7 didn't had white piece, the black on 8 line would be free
14:50:21 <jared-w> This would be great for comonads, I think
14:52:48 <jared-w> edwardk: would a capture analysis of a Go-game board be a good usage of comonads?
14:58:59 <edwardk> jared-w: no idea. give it a shot =)
14:59:32 <edwardk> i expect in practice you probably want a super-cheap bitboard representation rather than a big array of values
14:59:38 <edwardk> so probably not
15:01:50 <jared-w> Thanks! I was thinking they might because people often implement the game of life to show off comonads and it feels similar... But it's also not, y'know?
15:02:28 <jared-w> I'd probably implement it for giggles and funsies if I actually knew how to use comonads... I'll make a note for my (+2 years age) self :p
15:04:52 * hackagebot conduit-audio 0.2.0.3, monad-metrics 0.2.0.0, conduit-audio-lame 0.1.2.1, conduit-audio-samplerate 0.1.0.3, … and 1 more
15:04:52 * hackagebot  → https://hackage.haskell.org/packages/recent
15:05:34 <epta> Is there any way to suppress single unused import? For some reason 'import Test.QuickCheck.Instances' seem redundant for ghc, but without it there is no Arbitrary instance for ByteString
15:08:23 <geekosaur> doesn't te message tell u7 what to do n tat case?
15:08:25 <geekosaur> urgh, tis keyboard :/
15:09:06 <geekosaur> it shoudl tell you to use a empt import list if al you want is insances
15:09:11 <geekosaur> oh ffs. doe with this keyoard
15:09:44 <monochrom> haha u r mking sense
15:09:49 <gehmehgeh> geekosaur: 'Tis better thou changeth thine keyboard
15:09:58 <monochrom> hahaha
15:11:01 <edwardk> jared-w: comonads are actually pretty straightforward. just look at the operations.
15:11:11 <edwardk> jared-w: have you looked at the class?
15:11:30 <edwardk> epta: 'import Test.QuickCheck.Instances ()'
15:13:19 <geekosaur> gruuuump
15:13:47 <geekosaur> bought a new keyboard because I damaged the usb connector on this one and it was dropping runs of keys
15:14:35 <geekosaur> the new one drops keys even worse, and in particular keys pressed too quickly
15:16:12 <edwardk> you're sure this isn't a PEBKAC situation?
15:17:10 <geekosaur> reasonably, yes. it's quite reliae if you type slowly
15:17:11 <monochrom> It is. But it takes a keyboard and a chair to dance.
15:17:57 <geekosaur> now on the old one and I can tell that one is usb related because the charging light flickers every time it reconnects
15:18:06 <geekosaur> (it's usb/bt switchable)
15:20:43 <zachk> edwardk, PEBKAC?
15:21:22 <geekosaur> 'problem exists between keyboard and chair'
15:21:49 <rudol> liftM2 ((/) . realToFrac) sum genericLength - if ((/).realToFrac) is the (a->b->c) arg, how is sum the m a & genericLength the m b?
15:22:22 <monochrom> Consider m = (->) a
15:22:25 <geekosaur> m ~ ((->) e)
15:22:45 <monochrom> err, m = (->) [a]
15:22:46 <rudol> nice!
15:22:46 <geekosaur> (partially applied function application)
15:24:03 <rudol> so does that also help explain how, passing in a single [Real], it calculate the average (ie count the list and sum it)
15:25:57 <edwardk> in this case it seems geekosaur that the problem exists between keyboard and computer. =)
15:26:04 <edwardk> so either way it is a pebkac situation
15:26:24 <rudol> or maybe a better question would be: what is the intuition behind "how" this calculates the average of a [Real]?
15:28:33 <rudol> or even; how would I (one) come up with that impl rather than a pointful one that passes in list so it can be counted and summed?! 
15:28:56 <monochrom> I do the opposite of intuition. I do formalism. Formally: liftM2 op m n = \x -> m x `op` n x  (when the monad is (->) e)
15:29:12 <fresheyeball> hey out there
15:29:20 <fresheyeball> anyeone know how to get from a 
15:29:29 <fresheyeball> Natural -> SNat n
15:32:43 <rudol> monochrome - I see, now that you have shown me liftM2's impl it makes much more sense, thank you. I was trying to go by the types ie liftM2 :: (a->b->c)->m a->m b->m c. Could I (one) have grokked this just from the types or is that possible here?
15:34:08 <jared-w> edwardk: I haven't looked at the class yet, actually. I've barely gotten to the point where I understand monads. I've yet to write any "real" ones or use them a whole lot in code (the vast majority of my Haskell code continues to be answers to exercises in textbooks, unfortunately)
15:35:49 <monochrom> The type story is also possible. You have to expand m to (->)e.  (a->b->c) -> (e->a) -> (e->b) -> (e->c). djinn knows how to code this up.
15:36:37 <edwardk> jared-w: up for an exercise?
15:36:49 <edwardk> jared-w: let's work through how the comonad for (,) e works!
15:36:52 <jared-w> woooo exercises! 'Course I am :)
15:37:19 <edwardk> class Functor w => Comonad w where extract :: w a -> a; extend :: (w a -> b) -> w a -> w b
15:37:30 <edwardk> picking w = (,) e         extract :: (e, a) -> a
15:37:31 <rudol> how should I have noticed that this is the (e->) monad?
15:37:34 <edwardk> ideas for a definition?
15:39:24 <jared-w> Hmm... Given a w a, you get an a, should extract just be `snd`?
15:39:25 * edwardk wasn't expecting this one to be a hard question ;)
15:39:30 <edwardk> yeah
15:39:36 <edwardk> now, let's do extend
15:39:47 <jared-w> I was like "this should just be snd" and then had to double check myself because it felt too obvous :p
15:39:51 <edwardk> extend :: ((e, a) -> b) -> (e, a) -> (e, b)
15:41:02 <edwardk> to really make it feel like romper room stuff defining it using duplicate :: (e, a) -> (e, (e, a))   is more fun
15:41:05 <byorgey> rudol: experience.  That is, you shouldn't have noticed.  But next time you see it, you will =)
15:41:06 <rudol> I mean from just studying liftM2 ((/) . realToFrac) sum genericLength ? 
15:41:30 <rudol> yes, actually it already looks obvious now I asked the question ;)
15:41:31 <byorgey> rudol: by thinking about the types of sum and genericLength
15:41:38 <byorgey> =)
15:41:41 <jared-w> extend f x = (fst x, f x)  ?
15:41:45 <edwardk> s/:: //    s/->/=/   is enough todefine the latter.
15:41:46 <edwardk> yeah
15:42:16 <edwardk> that's it
15:42:28 <edwardk> congratulations you've written your first comonad
15:42:33 <rudol> byorgey yes, ty for the confirmation & encouragement
15:42:42 <edwardk> extend extract = id
15:42:47 <jared-w> hah, nice. Thanks :)
15:42:53 <edwardk> the other laws can be checked if you feel overly cautious
15:42:54 * byorgey throws lambda confetti on top of jared-w and also on rudol
15:42:59 <edwardk> next one
15:43:16 <edwardk> this one is harder: instance Monoid e => Comonad ((->)e)
15:43:25 <edwardk> extract :: Monoid e => (e -> a) -> a
15:43:42 <rudol> I better watch this one too!
15:44:23 <ignamv> extract f = f empty
15:44:25 <jared-w> Hmm, I feel like this involves mempty
15:44:34 <ignamv> it's the only value we know right?
15:44:39 <edwardk> ignamv: mempty, but yeah
15:44:52 <ignamv> right, thanks
15:45:01 <ignamv> might be the only value if we're being silly
15:45:38 <edwardk> jared-w: next up: duplicate :: Monoid e => (e -> a) -> e -> e -> a
15:46:42 <ignamv> mappend both e?
15:46:58 <ignamv> I'm just typechecking and not thinking
15:46:58 <jared-w> That looks like you can just arbitrairly pick one of the 'e's and then grab the a out of one using the (e -> a)
15:47:12 <edwardk> jared-w: you could, but then you would fail the laws
15:47:30 <edwardk> but we have a class constraint. if only we had some way to combine e's....
15:47:31 <jared-w> ahh right, so it has to be mappend e e', then
15:47:47 <edwardk> duplicate f a b = f (mappend a b)
15:48:45 <edwardk> this one is a bit trickier to see. but its kind of like writer. the other is kind of like reader, but notice how the roles of (->) and (,) have swapped? in monads, instance Monoid e => Monad ((,) e)    and instance Monad ((->) e) exist   
15:49:22 <edwardk> coask :: (e, a) -> e; is fst
15:49:29 <jared-w> oh interesting. I mean, it makes sense since monad and comonad are duals after all
15:49:48 <edwardk> now, let's do my favorite comonad
15:49:58 <edwardk> data Store s a = Store (s -> a) s
15:50:07 <edwardk> extract :: Store s a -> a
15:50:45 <edwardk> a store is 'an experiment to perform and a value you can perform the experiment with'
15:51:05 <ignamv> "be a dear and apply this function to this value"?
15:51:10 <jared-w> in that case, we're extracting the value after running the experiment are we not?
15:51:15 <edwardk> ignamv: indeed
15:51:17 <edwardk> jared-w: yep
15:51:24 <edwardk> extract (Store f s) = f s
15:51:38 <ignamv> how would you normally use it?
15:51:50 <jared-w> For all kinds of goodies, ignamv :p
15:51:51 <edwardk> ignamv: i'll hit some usecases once we get duplicate
15:51:58 <edwardk> duplicate :: Store s a -> Store s (Store s a)
15:52:00 <ignamv> yay
15:52:23 <edwardk> this one is a pain in the ass to figure out until you look at the signature of the Store data constructor (this is why i picked the argument order i did)
15:52:32 <edwardk> Store :: (s -> a) -> s -> Store s a
15:52:35 <ignamv> can we use the constructor?
15:52:38 <edwardk> sure
15:52:45 <jared-w> The a is a second store so you stick an experiment in an experiment, I'm guessing?
15:52:54 <edwardk> jared-w: yeah
15:53:09 <edwardk> the trick is you use the 's' you're given to feed the s of the second experiment
15:53:18 <edwardk> duplicate (Store f s) = Store (Store f) s
15:53:19 <jared-w> Feels very fmappy
15:53:57 <jared-w> ahh that's clever
15:53:58 <edwardk> that definition is incrediby pithy and needs some unpacking to really get comfortable with
15:54:57 <edwardk> now let's use it
15:55:28 <edwardk> Store Natural a -- is like having an infinite stream of a's, with a selected cursor but where you know where you are in the stream.
15:56:17 <edwardk> Store (Natural, Natural) a is like a spreadsheet with a 2 dimensional sheet of 'a's with the current position marked.
15:56:20 <Mirandag> ciao
15:56:24 <Mirandag> !list
15:57:26 <ignamv> Natural?
15:57:29 <edwardk> you can go back and forth between data Stream a = Stream a (Stream a)  and Store Natural a
15:57:32 <jared-w> Natural is a non-negative number
15:57:33 <edwardk> ignamv: natural numbers
15:57:36 <edwardk> starting from 0
15:57:42 <jared-w> Non negative integer, rather*
15:57:44 <monochrom> @tell ezyang It seems that if I use mixins I cannot use "cabal sandbox etc", I have to use "cabal new-*", is that right?
15:57:44 <lambdabot> Consider it noted.
15:58:14 <ignamv> ok, but what is the function Natural? a constructor?
15:58:21 <edwardk> Natural is a data type
15:58:32 <edwardk> https://hackage.haskell.org/package/base-4.10.0.0/docs/Numeric-Natural.html
15:58:51 <jared-w> edwardk: Do we know the current position because of the extract function of a comonad?
15:58:53 <edwardk> sorry, Store Natural a there was a type, not the term
15:59:21 <edwardk> jared-w: you can write a function that gets your position      pos :: Store s a -> s     pos (Store _ s) = s
15:59:28 <edwardk> extend pos :: Store s a -> Store s s
16:00:06 <rudol> could this be generalised as far as what-if analysis in multi-dimensional olap model?
16:00:22 <edwardk> rudol: the comonad stuff?
16:00:23 <jared-w> ahh okay, so s is the 'position', that makes sense
16:00:33 <rudol> Store in particular
16:00:53 <edwardk> rudol: you can use store to do lots of things. i wouldn't be surprised
16:00:54 <ignamv> sorry, got confused and thought the first arg to Store was a function
16:01:13 <edwardk> ignamv: the first argument to it as a data constructor is a function. the first argument to it as a type constructor is the type of the state
16:01:20 <ignamv> right, thanks
16:02:07 <edwardk> jared-w: an example of where store comes up is in lenses
16:02:08 <jared-w> (don't worry it's confusing for a while to most people)
16:02:16 <edwardk> one way to encode a lens is to use the 'common sense definition'
16:02:28 <edwardk> data Lens s a = Lens { get :: s -> a, set :: s -> a > s }
16:02:58 <edwardk> now we can note that both the get and set functions have a common s -> prefix
16:03:07 <rudol> if you imagine sales/budget/forecast vs products ve regions (ie 3 Naturals), the what-if would be something like how would the global performance against budget look if sales in Europe were 10% higher?
16:03:39 <edwardk> and use newtype Lens s a = Lens (s -> Store a s)  -- note the roles of the a and s arguments are backwards from what we've used so far, unfortunate
16:04:09 <edwardk> now if you want to get super-fancy you can observe that we don't allow you any pair of functions get and set' but rather ones where the obvious consistency laws hold
16:04:47 <edwardk> get (set l s a) = a; set l s (get l s) = s; set l (set l s b) a = set l s a
16:05:01 <edwardk> these conditions turn out to be the same as saying that a lens is a 'store comonad coalgebra'
16:05:29 <edwardk> and Store is also useful for converting between lens style lenses and the simple common sense getter/setter pair like that
16:06:11 <edwardk> heh, i can't think of a concrete lens in the lens library that isn't overloaded
16:06:14 <edwardk> um, hrmm
16:06:45 <edwardk> > (_2 :: Lens (c,a) (c,b) a b) (Context id)
16:06:47 <lambdabot>  error:
16:06:47 <lambdabot>      • No instance for (Typeable c0)
16:06:47 <lambdabot>          arising from a use of ‘show_M68037522257269220148652’
16:07:04 <edwardk> :t (_2 :: Lens (c,a) (c,b) a b) (Context id)
16:07:05 <lambdabot> (c, a) -> Context a b (c, b)
16:07:09 <edwardk> thats what i wanted
16:07:12 <edwardk> :t Context
16:07:13 <lambdabot> (b -> t) -> a -> Context a b t
16:07:24 <edwardk> context is like store, but where 's' has been split into two types
16:07:42 <edwardk> anyways, i realize i've run away with the topic
16:07:49 <jared-w> nah nah it's all good
16:08:02 <jared-w> comonads are intrinsically tied to the notion of lenses so it makes sense that it'll come up a lot :p
16:08:05 <edwardk> another example of a comonad i like is sort of like mashing up parts of what we've already seen
16:08:33 <edwardk> data Fold a b where Fold :: (r -> b) -> (r -> a -> r) -> r -> Fold a b
16:08:34 <jared-w> Besides, the more someone talks about it and the different ways things come together helps me understand stuff. It's why I'll read something, leave it, then read it again later
16:08:56 <edwardk> extract :: Fold a b -> b; extract (Fold k _ r) = k r
16:09:01 <edwardk> is like extracting from a store
16:09:09 <edwardk> but we don't get to know what the state is outside of the Fold
16:09:13 <jared-w> edwardk: I'm not gonna lie, though, it's weird to see folds and other things as data-types when I'm used to them being functions... Although I guess the lines get blurred, especially the fancier things get
16:09:18 <edwardk> just that we can feed it 'a's in a left fold setting
16:09:42 <pikajude> @type \ f -> mapM f . sequence
16:09:43 <lambdabot> (Monad t, Monad m, Traversable t1, Traversable t) => (t1 a -> m b) -> t1 (t a) -> m (t b)
16:09:51 <edwardk> if you look at a 'Fold' like that it is a foldl' with a final function being applied sort of packaged up into a data tye
16:09:54 <pikajude> isn't there a convenience function for this
16:09:56 <edwardk> jared-w: yeah, it happens a lot
16:09:57 <pikajude> I can never remember these things
16:10:13 <pikajude> wait, that's not right
16:10:22 <pikajude> @type \ f g -> mapM f =<< sequence g
16:10:24 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t (m a) -> m (t b)
16:10:34 <edwardk> duplicate :: Fold a b -> Fold a (Fold a b)
16:10:36 <pikajude> is it really just traverse?
16:10:50 <edwardk> duplicate (Fold k f r) = Fold (Fold k f) f r
16:10:59 <edwardk> see the same trick i used for Store?
16:11:31 <edwardk> we 'sneak in before the end of the fold and grab the seed, even though we're not allowed to talk about the seed type outside of a Fold and use it to build a new Fold.
16:11:54 <edwardk> an example of where this could be useful is a CRC calculation or a streaming hash function or something
16:12:18 <edwardk> crc32 = Fold complement update 0
16:12:30 <jared-w> the Fold example is pretty sweet
16:12:50 <edwardk> where update :: Word32 -> Word8 -> Word32 -- updates the internal hash state
16:13:08 <edwardk> now the 'Fold' doesn't leak the details of the internal state of your hash function to the world
16:13:25 <jared-w> ahh right, right, I remember skimming your article about a hash function (and CRC calculation). It's coming together now :)
16:14:25 * hackagebot wai-middleware-content-type 0.5.1 – Route to different middlewares based on the incoming Accept header. – https://hackage.haskell.org/package/wai-middleware-content-type
16:14:25 * hackagebot aeson-injector 1.0.10.0 – Injecting fields into aeson values – https://hackage.haskell.org/package/aeson-injector
16:14:27 <edwardk> you can feed it input: feed :: [a] -> Fold a b -> b;  feed as (Fold k f r) = k (foldl' f r as)
16:14:39 <jared-w> That's really interesting. Can you use that sort of "non-leaking by construction" to enforce certain memory safety constraints that crypto programs use?
16:14:47 <edwardk> extend (feed someInput) -- leaves you a new fold the starts where the input left off
16:14:55 <edwardk> possibly, never tried
16:15:19 <edwardk> going to guess not without doing some fancy stuff around  IO or ST to scrub memory
16:15:42 <pikajude> oh, no, it's not traverse
16:15:46 <pikajude> why isn't it traverse
16:15:49 <jared-w> right, that makes sense. Even if it works in the theory you still have to make it safe in the implementation ;)
16:15:49 <pikajude> it's like traverseM or something
16:16:24 <edwardk> jared-w: anyways with (,) e   (->) e  and Store e   you've seen the 'reader' 'writer' and 'state' of comonads.
16:16:51 <edwardk> Fold is something like a mixture of the 'state' and 'reader' bits, with an extra trick that hides the environment
16:17:01 <edwardk> so you can see that you might use comonad transformers to put these things together
16:17:11 <edwardk> the comonad package offers up some comonad transformers
16:17:18 <edwardk> in practice they are less useful than monad transformers
16:17:26 <edwardk> they exist because the theory says they should exist
16:17:34 <edwardk> but few people care unless they use lots of recursion schemes
16:17:37 <edwardk> where they show up a lot
16:17:49 <edwardk> and that is where i first encountered needing them
16:18:33 <edwardk> now, there is a last fun example i really like
16:18:39 <edwardk> it is 'how to turn any comonad into a monad'
16:18:53 <MarcelineVQ> any :O
16:18:54 <jared-w> oooh that one sounds fun
16:19:09 <edwardk> data Co w a = Co { runCo :: forall r. w (a -> r) -> r }
16:19:19 <jared-w> Is there one to turn a monad into a comonad? Because then it's just co's all the way down :D
16:19:29 <edwardk> jared-w: nope. this isn't symmetric in haskell
16:19:40 <edwardk> which hurts your brain at first
16:19:49 <edwardk> in fact you can upgrade Co into a monad transformer
16:19:50 <AWizzArd> Why are many Haskellers kind of critical about Template Haskell? Coming from Lisp&Clojure I see no problem in using such a macro mechanism. *Of course* only when it really helps to reduce boilerplate code, and when it is not about something that can also be solved with just functions.
16:19:54 <jared-w> Aww :(  I'm guessing it's symmetric in CT?
16:19:58 <edwardk> saying that every comonad in Hask gives rise to a monad transformer
16:19:59 <edwardk> no
16:20:13 <edwardk> this is using the fact that we have exponentials but not co-exponentials in haskell
16:20:21 <edwardk> and you can't have them both in general
16:20:47 <edwardk> Set isn't symmetric. you have functions, but not 'cofunctions'
16:20:55 <jared-w> ahh okay. So even if we could have monad -> co-monad we wouldn't be able to go the other way
16:21:06 <edwardk> where is the analogue to how (->) and (,) interoperate   for ???? and Either.
16:21:08 <jmcarthur> AWizzArd: I think TH is basically fine for reducing boilerplate, other than that it's pretty clunky to write.
16:21:24 <edwardk> without ???? there you can't flip this around
16:22:30 <jared-w> You'd need something like "Both" to work with Either, right? But I don't think you can make a Both in haskell and I'm not sure it even works at all
16:22:54 <AWizzArd> jmcarthur: what else could it be used for?
16:23:10 <edwardk> curry and uncurry witness the fact that ((a, e) -> b)   is isomorphic to (a -> (e -> b))   but there isn't something that  you can use that has the opposite relationship such that there exists an ???? with the property that (a -> Either e b) ~ ((a ???? e) -> b)
16:23:11 <jared-w> (nvm I think I just read what you said wrong; now I gotcha)
16:23:42 <edwardk> if you squint at -> and replace it with <=   and then you can read ???? as -
16:23:47 <jmcarthur> AWizzArd: You said it yourself: "something that can also be solved with just functions"
16:24:13 <edwardk> (a <= e + b)   <->  (a - e <= b)
16:24:15 <jmcarthur> AWizzArd: But there are some other things, too, like compile-time precomputation.
16:24:23 <edwardk> there isn't such a 'subtraction' in our types
16:24:44 <ski> edwardk : heh, i've constructed that `Fold' before
16:24:46 <edwardk> and can't be, as having it and function spaces would collapse the entire category down to where there is at most one arrow between any two objects
16:24:49 <AWizzArd> jmcarthur: and are Haskellers typically „against” precomputing stuff via TH?
16:24:50 <jmcarthur> AWizzArd: I think it's annoying to use TH this way, but it's "pragmatic".
16:25:08 <jmcarthur> AWizzArd: I wouldn't say that.
16:25:12 <edwardk> ski: the folds package offers it as does the foldl package or whatever that gabriel has
16:25:39 <edwardk> ski: if you squint at it, its basically just hitting the usual moore machine encoding i like to use with (co?)yoneda
16:25:50 <ski> (though i don't remember realizing it's a comonad)
16:25:57 <edwardk> data Moore a b = Moore b (a -> Moore a b)
16:26:00 <AWizzArd> jmcarthur: in the past, have there been issues with TH? Maybe it wasn’t producing type-checked code?
16:26:02 <jared-w> That makes sense. But I do remember seeing subtraction types in some more interesting type theories or something like that...
16:26:10 <edwardk> is just Cofree ((->) a) b
16:26:28 <ski> edwardk : i derived it as a concrete representation for list continuations, in order to do more fusiony operations
16:26:37 <edwardk> ski: that's how i use it as well
16:26:42 <jmcarthur> AWizzArd: The resulting code is always type checked (and I think always was). Not all TH guarantees to generate code that type checks, though.
16:26:54 <ignamv> monads are a gateway drug to other maths
16:27:01 <jmcarthur> *that successfully type checks, that is
16:27:20 <hpc> Monad is hard math
16:27:25 <hpc> it does things to your brain, man
16:27:34 <hpc> Monoid is way more casual ;)
16:27:50 <edwardk> hpc: until you realize that monads are just monoids. monoids are a gateway drug
16:27:58 <AWizzArd> jmcarthur: so you mean TH can sometimes produce code which is rejected by the compiler, but about which you, as the Dev, know that it _should_ typecheck?
16:28:13 <hpc> all the cool stuff has monoidal properties
16:28:17 <jared-w> edwardk: that fact bugged the shit out of me once I realized we can't just get monad for free by writing monoid
16:28:17 <hpc> Monad, Category, Alternative
16:28:28 <ignamv> AWizzArd: encode an unprovable true statement into the types?
16:28:39 <edwardk> jared-w: well you need a more general form of monoid that can live as a monoid object in other categories
16:28:41 <ignamv> assuming that's possible in Haskell
16:28:42 <jared-w> Then I realized that since monad is a monoid in the category of endofunctors, and if you have a functor instance and a monoid instance... then all the sudden 'Free monads' clicked and my brain exploded
16:29:02 <edwardk> https://github.com/ekmett/hask/blob/master/src/Hask/Tensor/Compose.hs#L137
16:29:10 <ski> AWizzArd : last i tried, it felt too clunky, and iirc didn't do hygiene by default that well
16:29:24 <ski> (`gensym' is a PITA)
16:29:28 <edwardk> with sufficiently general classes you can turn the 'monoids in the category of endofunctors' into a line of code
16:29:41 <jared-w> oooh, sweet
16:29:57 <ski> (also, `gensym' only helps with one half of hygiene, not with the other half)
16:30:12 <AWizzArd> ski: ah okay, good, so one reason to be against it is that it is not userfriendly enough yet, and could in principle be extended/simplified.
16:30:51 <ski> AWizzArd : it used to be even more annoying, when there was just a single type of expressions. not at least its parameterized over the type of value the expression will compute (like in MetaML/MetaOCaml)
16:31:12 <ski> s/not/now/
16:31:49 <jared-w> holy shit, that pragma list. Did you actually leave out any extensions, edwardk? lol
16:33:46 <jared-w> y'know sometimes I'm surprised you even still keep using Haskell for this kinda stuff. I would've expected you to graduate to Coq or something by now with the amount of abuse you subject Haskell to sometimes :p
16:34:22 <trigone> hi! does anybody knows about the alternative to monad transformers called "Emm"? i just started watching https://www.youtube.com/watch?v=E5Tri3Yow0U and it sounds very interesting. however everything is in scala and i only get half of it...
16:34:26 <hpc> jared-w: sometimes you just gotta do some IO
16:35:09 <monochrom> Coq doesn't have our awesome unordered-containers library. :)
16:35:16 <AWizzArd> jared-w: wouldn’t Liquid Haskell also be okay-to-use instead of switching to a different system like Coq alltogether?
16:35:30 <jared-w> AWizzArd: not for the kinda black magic edwardk gets up to :)
16:35:44 <edwardk> jared-w: i've done worse =)
16:36:14 <edwardk> jared-w: haskell is where i find my sweet spot lies between being able to express this stuff and having users who actually care
16:36:16 <jared-w> trigone: that looks like a talk about algebraic effect systems
16:36:48 <jared-w> edwardk: that's fair. I'm sure Coq, Agda, or even Idris might be better for expression but then... no users :p
16:36:54 <edwardk> i use coq and agda and lean and isabelle and whatever for the 2% of the code that i write that needs me to think that way
16:37:07 <edwardk> well, consider even haskell
16:37:19 <trigone> jared-w: is that the Eff technique?
16:37:21 <edwardk> if you go super-crazy with all sorts of GADTs and stuff you can write all sorts of invariants into your haskell code
16:37:26 <edwardk> but you lose the nice classes
16:37:34 <edwardk> and everything becomes bespoke one-off nonsense
16:37:34 <trigone> (bc if so it's said to be different)
16:37:38 <jared-w> trigone: yeah, Eff is the language that implements Algebraic effect types
16:37:49 <edwardk> _everything_ in coq/agda/idris/etc. tends to have that feel.
16:37:57 <trigone> jared-w: no apparently here it's different...
16:38:03 <jared-w> It's only one particular method of doing so. There's like 4 main ways to do that iirc (parroting edwardk at this point)
16:38:06 <trigone> wait a language? you mean like programming language?
16:38:22 <jared-w> http://www.eff-lang.org/  <-- yup, trigone 
16:38:22 <edwardk> if you're conor you can maybe use algebraic ornaments or ornamental algebras or whatever to avoid making your 500th copy of the natural numbers to do some induction proof
16:38:48 <monochrom> Haha 500th copy of the natural numbers.
16:39:13 <jared-w> edwardk: that makes sense. I definitely don't like the feeling of writing the universe by scratch to get the head of a list :p
16:39:37 <trigone> jared-w cool, i guess :) i don't know much about it though... i think i heard in the video it was based on free monads + coproduct, is that true?
16:39:38 <hpc> agda technically has a standard library
16:39:42 <hpc> but it's hideously dense
16:40:09 <edwardk> hpc: agda at least forces you to consider the software engineering aspects of your proofs. i can respect that
16:40:14 <hpc> i have the opposite problem, where i want to use relatively minimal dependent typing to make programming just a bit nicer
16:40:19 <jared-w> trigone: You can think of the Eff language's handlers as "tagged IO"
16:40:26 <edwardk> hpc: likewise
16:40:32 <hpc> idris is almost ideal, it just needs the libraries to do things with
16:40:43 <trigone> jared-w: you mean phantom type-tagged?
16:40:50 <jared-w> yeah
16:41:09 <trigone> oh... so you mean it separates the IO monad into subparts?
16:41:24 <edwardk> i'll probably keep producing little languages as as much as i like and respect the developers of idris, their goals and priorities and mine don't align enough
16:41:30 <hpc> haskell developing linear types and dependent types is probably going to be what makes it feasible for me i bet
16:41:32 <jared-w> They deride monad transformers but they merely trade one poison for another. There's no free lunch with effects :)
16:41:47 <hpc> especially if someone goes and makes a type-safe rust FFI
16:41:54 <jared-w> trigone: more or less. It's less ad-hoc than that since it's backed by theory, but that's the general idea
16:42:10 * ski . o O ( uniqueness types )
16:42:28 <jared-w> edwardk: I can understand that. I have somewhat of an idea in my head for my ideal language and I'm pretty sure it's impossible :p
16:42:48 <trigone> to describe what i just heard of Emm, it among others define a monad out of a (Monad m, Traverse m, Monad m2) it uses traverse to solve the joining of (m (m2 (m (m2 a)))) into (m (m2 a))
16:42:53 <edwardk> jared-w: i have a laundry list myself. i keep doing little language experiments to see how much of it i can actually have
16:43:00 <trigone> jared-w: hm ok
16:43:11 <jared-w> You have that laundry list anywhere, edwardk? It'd be fun to compare notes :)
16:43:28 <ski> AWizzArd,jmcarthur : "The resulting code is always type checked (and I think always was). Not all TH guarantees to generate code that type checks, though." -- this is what the parameterized expression type buys, yes -- it always type-checked the code, when splicing ("macro call"), afaik. but with typed expressions, it wouldn't need to (at least if done right), because then it can't even try to generate type-incorrect code (but there's also scoping issues ..
16:43:37 <edwardk> trigone: emm is basically what you get when you come to the mistaken belief that all monads come from distributive laws of other monads
16:43:42 <edwardk> trigone: ignore it
16:43:48 <ski> (hrm, ".., because then it can't even try to generate type-incorrect code (but there's also scoping issues ..)")
16:43:51 <edwardk> jared-w: not written down
16:44:01 <edwardk> grab me at a conference some time for an in-person rant ;)
16:44:18 <jared-w> Mine aren't either. I'm gonna write mine down right now because this is the third conversation I've had this week about this and I'd like to be able to have a more coherent rant :p
16:44:39 <jared-w> edwardk: hah, sure thing
16:45:04 <trigone> edwardk: really? hm... the guy did say he hadn't managed to prove it was an actual monad lawfully. does it really break in practice? or does it just limit the types of monads you can combine (or how you can combine them)?
16:45:48 <edwardk> trigone: http://web.cecs.pdx.edu/~mpj/pubs/RR-1004.pdf is the oldest reference i know of to composing monads in this fashion. it predates monad transformers
16:46:11 <edwardk> even in that paper mark p jones notes that there are at least 3 ways to produce monads from a pair of a monad and a pointed functor and a distributive law
16:46:30 <edwardk> spiewak basically pretends that they all come from _one_ of these constructions
16:46:42 <edwardk> but even that doesn't handle things like state
16:46:45 <edwardk> its just noise
16:47:04 <edwardk> state isn't built off a simple distributive law, but rather from an adjunction.
16:47:50 <edwardk> given any adjunction F -| G    like (,)s -| (->)s       GF is a monad, (in this case State s) but so is GMF (in this case (StateT s m)
16:48:22 <trigone> so basically it's very limited? (and inconsistent maybe) couldn't it be used in conjunction with stacks of monads though, to combine things which can be combined and leave the rest to stacks?
16:48:37 <edwardk> -- to call back to my earlier comments for jared-w the 'Co' construction is using the fact that (->r) -| (->r)  is an adjunction that goes through Hask^op   and is putting a monad in Hask^op in the middle
16:48:38 <trigone> i'm not sure i have the knowledge to follow your explanations ^^
16:49:02 <c_wraith> trigone: most of us run into that sometime. :)
16:49:03 <edwardk> trigone: its just a sort of non-interesting bit of code masquerading as a grand theory
16:49:36 <edwardk> trigone: you're better off ignoring that it was even attempted than trying to get something productive out of it existing
16:50:19 <trigone> edwardk: ok... so what would be a comprehensive list of viable methods to combine monads nowadays?
16:51:02 <jared-w> I'll see if I can translate that a bit... "In Haskell, you can turn any co-monad into a monad. However, monads can be constructed in several different ways. This theory pretends there are only 3 ways to make a monad"
16:51:21 <trigone> (in haskell, since i'm mostly limiting myself to it for the time being)
16:51:36 <edwardk> monads do not compose in general. there are common tricks used to make monad transformers, e.g. if you have a distributive law for m over n then you can turn mnmn  into mmnn and do the joins separately. this was the gist of jones and duponcheel's paper that i linked.
16:52:20 <trigone> edwardk: does the distributive law amounts to the traverse constraint?
16:52:20 <edwardk> and then if you can absorb m into n or n into m you can also come up with something (with suitable laws) or mnm -> mn
16:52:23 <edwardk> etc.
16:52:34 <edwardk> these are the sort of messy ad hoc constructions that jones and duponcheel considered
16:52:43 <hpc> edwardk: is this how ListT m is only a monad if m is distributive?
16:52:48 <hpc> er, commutative?
16:52:53 <trigone> hm ok...
16:52:56 <edwardk> statet arises from how (->) e and (,) e interact
16:52:59 <jared-w> And since monads do not compose in general there will never be a way to fully generalize and compose monads (transformers, Freer, algebraic effects) that doesn't include some significant drawback somewhere, right?
16:53:10 <edwardk> ListT isn't a monad transformer as it exists. 'ListT done right' is
16:53:13 <trigone> ok i'll rephrase cos i didn't mean actually composing monads, more like composing effects
16:54:37 <edwardk> there is the mtl and there is using a free monad of some sum type of effect requests. the latter subdivides int different categories depending on if you cps the whole thing, use coyoneda to automatically make everything a functor, and/or use reflection without remorse
16:54:54 <trigone> hm ok
16:55:36 <edwardk> but in the act of trying to get away from the mtl the latter makes a bunch of commitments that destroy lazy state/writer which aren't based on a sequence of request/response pairs, and in the interest of trying to cover Cont (if they do) you give up composability of handlers
16:55:36 <trigone> is there an implementation of some free monad technique which is as fast as mtl? i heard there was a bit of a perf loss associated with free monads...
16:56:07 <jared-w> That performance loss is fundamental to how 'Free' methods work
16:56:08 <edwardk> trigone: i'm personally of the opinion the whole effect system business is a boondoggle. your mileage may vary
16:56:18 <jared-w> (which is why edwardk has that opinion ;) )
16:56:45 <trigone> edwardk: hm so mtl is strictly more powerful than free monads, in terms of composing effects? ofc there are other advantages to free monads, at least i think so
16:56:55 <trigone> what's a boondoggle ? ^^
16:56:58 <jared-w> Not 'powerful' just faster
16:56:59 <ski> @wn boondoggle
16:56:59 <lambdabot> *** "boondoggle" wn "WordNet (r) 3.0 (2006)"
16:57:00 <lambdabot> boondoggle
16:57:00 <lambdabot>     n 1: work of little or no value done merely to look busy
16:57:00 <lambdabot>     v 1: do useless, wasteful, or trivial work
16:57:17 <edwardk> there are limited scenarios in which it is useful to be able to talk about composable effects, but they handle a subset of the mtl approach. the win is that you don't have n^2 instances, but n shrinks because you have fewer effects that you can actually encode
16:57:40 <trigone> edwardk: i see...
16:58:05 <edwardk> e.g. Cont and Writer effects don't freely interchange. if you 'handle' the cont effects, then you silently break the writer laws.
16:58:16 <edwardk> so if you're saying 'Cont' is an effect you can't have nice things
16:58:31 <trigone> edwardk: and what does it mean in practice, what you said about the effect system business? like what should i do myself?
16:58:40 <edwardk> this fundamentally _requires_ the n^2 instance approach from the mtl to deal with what effects work with what other effects
16:58:49 <mniip> hey edwardk!
16:59:02 <trigone> edwardk: tbh i don't know much about cont (i know what it means mostly but i couldn't use it, nor write it)
16:59:09 <edwardk> trigone: https://www.youtube.com/watch?v=GZPup5Iuaqw follows my own style
16:59:16 <ski> "don't freely interchange" ~ "doesn't commute" ?
16:59:18 <edwardk> heya mniip 
16:59:33 <edwardk> ski: one order of handling the effects works
16:59:51 <edwardk> ski: if you view it as a monad transformer stack, then yes, its commutativity
17:00:05 <edwardk> handlers kind of encode things into a mess of stuff that its hard to say is commuting =P
17:00:15 <mniip> edwardk, I discovered a marvelous proof that FreeT is the ultimate DSL grammar construction type, and it is even small enough to fit on this margin!
17:00:21 <trigone> edwardk: thanks for the link! you advocate the video's technique? just to check. i'm gonna watch it :)
17:00:32 <edwardk> "Cont" isn't a series of requests/responses in the fashion sold by the effect folks
17:00:50 <edwardk> trigone: yeah, george gave the talk after i ranted at him about how i use the mtl in practice
17:01:03 <trigone> haha really ok
17:01:11 <ski> it seems like there ought to be a way to specify a list of effects (referenced by-name, not by-position), where only some pairs of components commute
17:02:06 <mniip> edwardk, suppose we have a functor family f called a "Mode", that can do tkn :: (Eq t, Alternative b) => t -> f t (b t)
17:02:14 <trigone> thanks again edwardk, and jared-w too :) i'll look into it
17:02:17 <mniip> edwardk, example modes are Reader and Writer
17:02:27 <edwardk> ski: hrmm, maybe you could use a nested series of types.. s (t (u m)) a
17:02:31 <edwardk> ski: =)
17:02:36 <jared-w> don't thank me, I'm just the person people correct when I get stuff wrong :p
17:02:53 <ezyang> monochrom: That's right 
17:02:57 <trigone> edwardk: just while i'm here, would you know about tagless final interpreters, and what would you think of it as alternative to free monads?
17:02:58 <mniip> edwardk, then we can write token :: (Functor (f t), Mode f, Eq t, Alternative b) => t -> FreeT (f t) b t
17:03:00 <ski> edwardk : except that get us back to by-pos :)
17:03:04 <edwardk> ski: and then you can define how to work with them with monad monomorphisms and map them into that structure. oh wait, i've given a talk on the topic =P
17:03:35 <mniip> edwardk, and that is the ultimate parsing monad!
17:03:37 <edwardk> ski: oh, the by name thing
17:03:45 <edwardk> there is a tagged transformer mess of a library someone has, roman?
17:04:00 <mniip> you can write parse :: MonadPlus b => FreeT (Reader t) b a -> [t] -> b (a, [t])
17:04:04 <edwardk> but i find that approach awful to use
17:04:11 <ski> what i've been toying with would require type system extensions
17:04:13 <trigone> mniip: what you're talking about sounds interesting (though i'm not sure to understand much of it right now), do you have a reference or did you just found thta yourself?
17:04:13 <mniip> or you can write enumerate :: Monad b => FreeT (Writer t) b a -> b (a, [t])
17:04:29 <ski> edwardk : *nod*, agree
17:04:37 <mniip> trigone, I came up with it, partly a year ago, partly recently
17:04:39 <mniip> http://lpaste.net/358149
17:04:49 <trigone> mniip: thanks!
17:04:56 <edwardk> btw- all opinions expressed are solely my own. folks are free to disagree =P
17:05:30 <edwardk> but i figure it doesn't do anybody any good when it comes to figuring out what matters if i hold them back too much
17:05:41 <mjhoy> I've noticed a typo on one of the ghc wiki pages. Do I submit a bug to the issue tracker about that?
17:05:56 <jared-w> mjhoy: where's the typo?
17:06:08 <trigone> edwardk: you just mentioned "tagged transformer", did that answer my latest question? i'm just not sure
17:06:17 <mjhoy> jared-w: the git url rewrite rule at https://ghc.haskell.org/trac/ghc/wiki/Building/GettingTheSources is incorrect, the last one.
17:06:26 <trigone> *was that an answer to may latest question
17:06:29 <edwardk> trigone: it was to ski
17:06:39 <ski> edwardk : fwiw, any link to said talk ?
17:06:57 <jared-w> mjhoy: what should it be instead?
17:07:04 <edwardk> ski: https://www.youtube.com/watch?v=YTaNkWjd-ac
17:07:13 <trigone> oh ok
17:07:17 <mjhoy> git config --global url."git@github.com:ghc/packages-".insteadOf      git@github.com:ghc/packages/ 
17:07:23 <mjhoy> (remove the slash after the colon)
17:07:34 <ski> edwardk, ty
17:07:39 <jared-w> ahh whoops, thanks
17:07:43 <jared-w> I'll edit that page real quick :)
17:07:47 <mjhoy> thanks!
17:08:01 <edwardk> trigone: anyways re tagless interpreters. the approach cowley uses seems to have a lot of power
17:08:18 <edwardk> https://www.youtube.com/watch?v=_KioQRICpmo
17:08:56 <jared-w> mjhoy: the #ghc channel will also be able to help if there's something like that in the future :)  feel free to refresh the page now, it should be fixed
17:08:57 <trigone> :t mapErrorT
17:08:58 <lambdabot> error: Variable not in scope: mapErrorT
17:09:01 <edwardk> but building up a bag of constraints on a dsl feels a lot like building up a bag of MonadFoo constraints when you talk about effects
17:09:09 <trigone> cowley?
17:09:14 <edwardk> so its not clear its anything new
17:09:22 <jared-w> trigone: the speaker in the youtube video
17:09:25 <mjhoy> jared-w: ah, good to know.
17:09:26 <edwardk> Anthony Cowley. the link i just gave
17:10:14 <trigone> edwardk: well yeah that's actually one advantage of it, you can mix it with mtl. the idea i guess is to expand it to the DSL+interpreter design (at least i think so, i just started )
17:10:29 <trigone> edwardk: oh sorry i hadn't seen the link, thanks, i'll look into that too! :)
17:11:15 <trigone> oh right i had started watching it. it does seem very interesting
17:12:00 <edwardk> my general problem is that i find i actually need the extra power given by the mtl that is lost in all these extensible effect frameworks, so i don't see the point in using something that is usually slower for a subset of my effects when i have to code switch for half of them anyways
17:12:29 <trigone> also regarding perf trade-off of free monads, is it still measurable?
17:12:40 <edwardk> its like wow i can continue eating breakfast or i can shoot myself in the foot and then eat breakfast ;)
17:13:06 <edwardk> it was at last check. the benchmarks that are pro eff are all against things like using 20 layers of reader or something stupid
17:13:25 <trigone> edwardk: how could tagless interpreters be slower than mtl? they both use as you said more or less the same class-based approach (right?)
17:13:49 <edwardk> trigone: mtl isn't a set of requests/responses
17:14:11 <trigone> edwardk: i'm not sure i understood what you just said about benchmarks, can you reformulate?
17:14:38 <jared-w> MTL is fast as hell compared to all the Eff systems
17:14:41 <edwardk> all of the free monad based things (tagless or not) are based on the model that you are interested doing a series of steps one after another, and that binding is just gluing together these queues
17:14:46 <trigone> edwardk: oh i'll have to watch Cowley's video then because i didn't know there was a notion of requests/responses involved
17:15:00 <jared-w> unless you stack the benchmark against mtl so much it's almost satire :p
17:15:13 <edwardk> trigone: just saying, the act of interpreting a 'free' monad starts at the outside constructor and works in
17:15:34 <edwardk> you can switch free encodings to make it so that this doesn't affect the cost of subsequent binds, etc.
17:15:41 <edwardk> or so that you have to do it all at once
17:15:43 <trigone> edwardk: er... i wasn't actually talking about using free monads, more like an alternative to free monads, without ADTs, like http://okmij.org/ftp/tagless-final/course/lecture.pdf
17:15:58 <edwardk> but its an act of reading something, then giving an answer so you can continue into the tower of 'f's you have
17:16:09 <edwardk> trigone: same approach just 'final'
17:16:24 <edwardk> in scare quotes because as you can recover the initial encoding it isn't technically final
17:16:27 <trigone> jared-w: ok, so mtl in practice is always faster?
17:16:38 <trigone> edwardk: yeah i heard that it was a misnomer
17:16:41 <jared-w> I hesitate to say /always/ but... basically
17:16:57 <edwardk> anyways, consider Control.Monad.State
17:17:00 <edwardk> despite appearances
17:17:09 <edwardk> it isn't actuallys tarting from the front of your do block!?!
17:17:30 <edwardk> we're in a lazy language, and Control.Monad.State is much lazier
17:17:54 <mniip> ooh curious
17:18:01 <mniip> it's working backwards isn't it
17:18:03 <edwardk> foo = do foo; modify (1:)
17:18:08 <edwardk> will work just fine
17:18:27 <mjhoy> jared-w: whoops, there were two instances of the `:/`... i think you missed the second
17:18:48 <edwardk> > let foo = do { foo; modify (1:) } in runStateT foo undefined
17:18:50 <lambdabot>  error:
17:18:50 <lambdabot>      Ambiguous occurrence ‘modify’
17:18:50 <lambdabot>      It could refer to either ‘Control.Monad.State.modify’,
17:19:00 <jared-w> oh darn, I can't read at all today can I? Thanks, mjhoy 
17:19:01 <edwardk> > let foo = do { foo; Control.Monad.State.modify (1:) } in Control.Monad.State.runStateT foo undefined
17:19:04 <lambdabot>  error:
17:19:04 <lambdabot>      • Ambiguous type variables ‘m0’, ‘a0’ arising from a use of ‘show_M88731...
17:19:04 <lambdabot>        prevents the constraint ‘(Show (m0 ((), [a0])))’ from being solved.
17:19:08 <edwardk> blech
17:19:13 <edwardk> > let foo = do { foo; Control.Monad.State.modify (1:) } in Control.Monad.State.runState foo undefined
17:19:15 <lambdabot>  ((),[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:19:19 <edwardk> yay
17:19:36 <edwardk> now, anything that starts trying to 'pump' the sequence of commands from the start will fail to find the first command
17:20:10 <edwardk> the state monad we use (and the writer monad we use) aren't emulable with any of the free based effect systems
17:20:16 <jared-w> mjhoy: /now/ it should be correct ;)
17:20:35 * ski . o O ( "control.monad.state.lazy" by monochrom in 2010-11-25,2013-02-27 at <http://lpaste.net/41790>)
17:21:04 <mjhoy> jared-w: except it is out of alignment! ;)
17:21:10 <edwardk> this can lead to some silly failures of expectation
17:21:25 * jared-w throws his table through the wall
17:21:29 <edwardk> > let foo = do { fail "DO NOT PASS"; put 1 } in Control.Monad.State.runState foo undefined
17:21:32 <lambdabot>  error:
17:21:32 <lambdabot>      Ambiguous occurrence ‘put’
17:21:32 <lambdabot>      It could refer to either ‘Control.Monad.State.put’,
17:21:42 <edwardk> > let foo = do { fail "DO NOT PASS"; Control.Monad.State.put 1 } in Control.Monad.State.runState foo undefined
17:21:44 <trigone> edwardk: from what i understood of tagless interpreters, it's really not like free monads, it doesn't pump up the sequence of commands, it only restricts the operations you can perform using classes which represent EDSLs, so you enjoy aspect-oriented and mocking capabilities (like the free monads). the interpreting stage is merely instanciating the class, and it means a priori there's really no overhead or change in the structure o
17:21:45 <lambdabot>  ((),1)
17:22:27 <edwardk> trigone: yes. the mtl can be viewed as such, its delaying the problem enough that you can execute it by building up a bad of constraints and letting you pick instances later
17:22:38 <ski> trigone : cut off at ".., and it means a priori there's really no overhead or change in the structure o"
17:22:39 <edwardk> so this _is_ the mtl solution
17:23:01 <trigone> ski: oh, the end is "structure of the computation"
17:23:14 <jared-w> mjhoy: Fixed the alignment :p
17:23:48 <trigone> edwardk: well yeah :) but used for more than combining effects, also for mocking and aspect oriented. but sure both technologies are strictly based on haskell classes and not much else
17:24:00 <edwardk> i could write a paper or given a talk on 'finally tagless effect systems' and point out the early pioneering work in this space by andy gill ;)
17:24:30 <trigone> edwardk: what do you mean?
17:24:34 <mjhoy> beautiful! thank you.
17:24:51 <jared-w> np. Hopefully nobody makes fun of me making 3 edits in the span of 5 minutes lol
17:25:02 <edwardk> trigone: when you work finally tagless with effects you are building the mtl.
17:25:13 <edwardk> MonadState s m => ... now you can work with get put, etc.
17:25:26 <edwardk> that is a 'finally tagless' encoding
17:25:35 <edwardk> not almost, it is exactly.
17:26:27 <edwardk> re andy gill he did a lot of the early work on the mtl
17:26:48 <edwardk> i just maintain it these days
17:27:08 <jared-w> Hmm, and of course since that's just one particular subset of the mtl... Is that just hardcoding the mtl into a subset, painting it a pretty color, and hoping it saves you some work here and there?
17:27:15 <trigone> edwardk: or using it to build more abstraction. btw how do you do if you need two state monads? and i thought sometimes there was semantical differences between m (n a) and n (m a), how is mtl addressing it? does it just wait for the implementation to decide how to structure all of it?
17:27:47 <edwardk> trigone: the talk covers that topic by using lenses into a larger state
17:28:06 <trigone> hm yeah i guess you could have that
17:28:10 <edwardk> i can count on one hand the number of occurences of 'lift' in my code that aren't being used to define 'lift' or 'liftIO'
17:28:26 <edwardk> or to hack around third-party libraries
17:28:49 <trigone> edwardk: so how do you instanciate the code at the very end? don't you need stack transformers? (or writing the monad yourself)
17:28:49 <edwardk> trigone: the 'next level mtl' talk by george that is... i realize i've linked to several talks by now =)
17:29:10 <trigone> yeah i'll most certainly watch it :)
17:29:36 <edwardk> trigone: at the end? it depends on the particular stack of effects i want. i may pick out a concrete monad transformer stack. i may write my own hairy instance if i want part of my state to backtrack and the other to not
17:29:51 <trigone> ok :)
17:29:51 <edwardk> i care about the mtl classes. i almost don't care about the basic _instances_
17:30:51 * hackagebot nested-routes 8.0.1 – Declarative, compositional Wai responses – https://hackage.haskell.org/package/nested-routes
17:31:14 <trigone> edwardk: the interpreter design is also focused on things like aspect-oriented (se and mocking. that's not really intrinsically implied by mtl, is it?
17:31:23 <edwardk> i'm not above writing instances of the existing classes for my own problems to make the code clearer or faster: https://github.com/ekmett/ermine/blob/master/src/Ermine/Unification/Sharing.hs#L118
17:31:25 <ignamv> is there an easy way to extract a Right value in the repl?
17:31:27 <trigone> *aspect oriented (separating concerns)
17:31:48 <jared-w> ignamv: easier than pattern matching?
17:32:10 <ski> ignamv : `let Right x = ...' ?
17:32:27 <edwardk> trigone: i generally 'mock' using an mtl style. make up classes for how to say, open/close files, etc. make a base instance for IO that i actually use in the code, then my test suite can make up local instances for mock testing or that build some free structure i can inspect
17:32:27 <ignamv> ahh thanks
17:32:36 <trigone> ski:  don't you need parentheses around the pattern?
17:32:54 <ignamv> never really pattern match on let, thanks
17:33:05 <trigone> edwardk: yeah :) well that's exactly what i was talking about :) cool
17:33:52 <edwardk> in practice i try to keep the bits of evil mutation stuff small enough that i don't have to do that often, but meh
17:34:27 <ski> trigone : nope why would you ?
17:34:41 <trigone> edwardk: what about aspect oriented? do you do that kind of thing? like say, logging aspect put at one place only versus logging all around the place in every atomic operation of the program
17:34:45 <ski> ignamv : in the interactor, in this case
17:34:49 <trigone> ski: oh well i thought it was required
17:34:55 <ski> not at all
17:35:03 <trigone> > let Right x = pure "a" in x
17:35:05 <lambdabot>  "a"
17:35:20 <trigone> ha lol everyday something new to learn
17:35:46 <trigone> ski: is it only necessary for infix operators? like list cons?
17:35:48 <edwardk> my personal opinion is that AOP itself was sort of a dead-end. it tried super-hard to separate concerns and failed. your logging and locks often interact in non-trivial ways so applying AOP to the problem in an imperative setting leads to a mess of conflicting layers. even scala gave up on using mixins for concurrency for their maps and the like
17:36:18 <jared-w> AOP? == aspect oriented programming?
17:36:20 <trigone> edwardk: hm maybe
17:36:22 <edwardk> your mileage may vary
17:36:32 <edwardk> jared-w: yeah
17:36:38 <ski> trigone : nope, not there either (though a lot of newbies seem to be convinced otherwise, for whatever reason)
17:36:51 <edwardk> trigone: thats why i'm trying very hard to clarify that that is my personal opinion, not verified fact
17:36:57 <ski> > let x:xs = "foo" in x
17:36:59 <lambdabot>  'f'
17:37:13 <jared-w> ski: probably because /literally/ every beginner thing uses (x:xs) :p
17:37:15 <ignamv> > myhead x:xs = x
17:37:17 <lambdabot>  <hint>:1:13: error:
17:37:17 <lambdabot>      parse error on input ‘=’
17:37:17 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
17:37:26 <trigone> no i think you're right. the ideal would be to have three sides: one focused on the logging functionality, one on whatever's being logged onto, and one focused on fusing both together, but in a case-by-case basis...
17:37:35 <edwardk> trigone: its necessary around function arguments like foo (x:xs) = ... so people tend to over generalize
17:38:00 <trigone> ok ^^ what about case of? same deal, no need for parens?
17:38:09 <edwardk> trigone: no need for parens in cases
17:38:17 <jared-w> It's only function arguments that need all the extra parens for 'no reason'
17:38:17 <ski> ignamv : that doesn't work, because application binds tighter than (has higher precedence level than) `:'
17:38:29 <trigone> thinking about it it's kinda logical, since with functions it's only there because there's more than one pattern on the same line
17:38:30 <edwardk> i find them liberally strewn through third party code and i'm sad
17:38:51 <trigone> edwardk: parens?
17:39:00 <jared-w> ((why? Don't (you (enjoy the fancy (lisp (feel?)))))))
17:39:01 <ski> ignamv : this is similar to having to write `(x + y) * z' if you mean that, since `x + y * z' means `x + (y * z)', which is something else
17:39:03 <edwardk> yeah extra ones around patterns, let bindings, etc.
17:39:13 <edwardk> jared-w: i like $
17:39:14 <edwardk> =)
17:39:16 <trigone> jared-w: lol it's like a rollercoaster
17:39:32 <ski> ignamv : similarly, if you mean `myhead (x:xs)', you must write that, since `myhead x:xs' means `(myhead x):xs', which is something else
17:39:43 <trigone> edwardk: me too but i feel like we'd have been better off with a `|` bikeshed (much easier to see from far away)
17:39:52 <trigone> (instead of $)
17:39:58 <ski> ignamv : it's just a matter of having to override precedence with explicit brackets, nothing else
17:40:00 <jared-w> edwardk: I'm a fan of $, I'm not a fan of the symbol chosen for it. I really like |>, <|, .>,  and <. 
17:40:16 <edwardk> trigone: maybe, $ is a particularly ugly symbol choice
17:40:16 <jared-w> (although tbf I enjoy the unicode variants more...)
17:40:44 <ski> trigone : "what about case of? same deal, no need for parens?" -- yep
17:41:04 <trigone> edwardk: i agree. the worst is it makes haskell look a bit like pearl :P or bash
17:41:17 <trigone> no wonder lots of people think haskell is also read-only
17:41:30 <ski> jared-w : except in the lisps, every bracket is sacred, every bracket counts
17:41:37 <trigone> ski: ok thx
17:41:41 <edwardk> the mess with | is that it interacts badly with existing list comprehension syntax, etc.
17:41:49 <trigone> ski: lol
17:41:56 <edwardk> | is already stolen for more important work and so isn't available.
17:42:15 <edwardk> it'd pair nicely with lens's (and now base's) use of &
17:42:19 <trigone> edwardk: hm well we could systematically replace $ by | and vice versa... since `|` is much rarely used
17:42:27 <trigone> *could have 
17:42:29 <crucify_me> hi anyone know what this vim setting would do ?   ' let g:haskell_indent_disable = 1 '
17:42:47 <edwardk> trigone: | for pattern syntax is used a _lot_
17:42:58 <edwardk> foo x | x < 12 = ...
17:43:38 <trigone> edwardk: well yeah but if you use $ to me it's not too bad in that position, esp when it starts the line... but then tha's a bikeshed issue
17:43:42 <edwardk> $ became an element of haskell style much later
17:43:52 <trigone> edwardk: oh really i didn't know
17:43:59 <trigone> did they use parens instead?
17:44:17 * ski uses `$' sparingly, often preferring e.g. `(f . g . h) (...)'
17:45:04 <edwardk> when i joined cale was still exhorting folks to pointfree everything f $ g $ h i    to f . g $ h i then see if you can scrub it out of your code.
17:45:08 <edwardk> i think cale doesn't like $
17:45:17 <trigone> ski: well very often me too i kinda avoid it unless it's like calling for a lambda or something. i think it's mostly because i don't read well the symbol (and i don't dare using a custom alternative symbol for fear of never being understood)
17:45:25 <ski> if i could use `\',`do',`let',`if',`case' to start the last argument in an application, most of my remaining `$'s would be gone
17:45:33 <Cale> I like $ I just don't like the right-associativity of $
17:45:34 <jared-w> Yet another reason to hate list comprehension syntax!
17:45:37 <edwardk> given my early attempts to hire him back in the day i think that must be the case , actually ;)
17:45:45 <edwardk> Cale: agreed
17:46:09 <trigone> ski: there's a great proposal for that, me too i hope it gets into haskell as normal syntax
17:46:12 <edwardk> right associativity of $ and $! bother me
17:46:24 <crucify_me> what about the <- which is a 'stylized epsilon' that is nice to read, no?
17:46:25 <edwardk> foo $! arg1 $! arg2 with more stuff $! whatever
17:46:27 <edwardk> would be awesome
17:46:41 <ski> yep
17:46:56 <Cale> If it were left-associative then 1) we could remove more parens from code (whether this is a good thing or not to-be-determined), and 2) it would be much easier to use along with left-associative $! to strictly apply specific arguments
17:47:07 <Cale> yes
17:47:09 <Cale> haha
17:47:19 <ski> jared-w : list comprehensions ?
17:47:24 <jared-w> !|>  <|!  <.  .>  <.!  !.>  
17:47:38 <jared-w> ski: their usage of | annoys me
17:47:44 <ski> oh
17:47:55 <ski> TH quasiquotations, then ?
17:47:56 <edwardk> that said, we switched assocativities of $ in ermine and it always screwed us up.
17:47:57 <jared-w> ski: their general existance annoys me but the usage of | also annoys me :p
17:48:02 <ignamv> oh man
17:48:15 <trigone> edwardk: i'm not sure to follow... i thought $ was right-assoc for a reason
17:48:26 <ignamv> I should make a vim plugin that adds parentheses to an expression
17:48:32 <Cale> trigone: It is, but it's kind of a bad reason
17:48:33 <jared-w> edwardk: Do you not like symbols like |>  ?
17:48:49 <jared-w> trigone: much bike shedding, weeping and gnashing of teeth were wasted over that reason :p
17:48:55 <edwardk> trigone: f $ g $ h = f . g $ h  -- so you an flip the associativity of $ as you never need it on the right of another $  then you get the semantics i sketched
17:48:57 <jared-w> ignamv: check out surround.vim
17:49:25 <edwardk> jared-w: |> doesn't play nice with haskell's alternative class. <|> has a different connotation
17:49:27 <trigone> edwardk: hm
17:49:31 <ignamv> jared-w: thanks, that's quite useful
17:49:37 <crucify_me> as in biblical gnashing of teeth.?
17:49:39 <edwardk> so i expect |> to be something like m a -> a -> m a
17:49:43 <edwardk> filling in a default
17:49:45 <jared-w> crucify_me: yes lol
17:49:45 <Cale> If $ were left associative, then we could replace f (g x y) (h z) with f $ g x y $ h z
17:49:47 <ignamv> but I was thinking take a line and explain how it will be evaluated using parens
17:49:58 <trigone> edwardk: there's (&) which is the same as |>
17:50:02 <trigone> :t (&)
17:50:04 <lambdabot> a -> (a -> b) -> b
17:50:07 <edwardk> trigone: yeah. i wrote it =P
17:50:07 <jared-w> edwardk: That's quite true. I suppose I'm really meaning the unicode triangles rather than |>
17:50:08 <trigone> i meant jared
17:50:14 <ignamv> good night
17:50:37 <jared-w> trigone: I'm aware of it, but & is just as ugly of an operator as $ :p
17:50:46 <crucify_me> brutal heat wave in california usa
17:50:52 <Cale> jared-w: How so?
17:50:58 <trigone> edwardk: ah ok ^^ well to be fair i must admit i don't really like it much better than `$` (but then all the good symbols are already taken, like / or > ...)
17:51:13 <edwardk> jared-w: anyways, & (formerly %) won out for me for lens because it comes with a built-in reading that reads right. foo & whatever .~ 12       reads as foo and whatever = 12..
17:51:18 <trigone> jared-w: agreed :) but it's one golf shorter!
17:51:25 <edwardk> (it read better when the operator was .=)
17:51:27 <jared-w> I got a lot of shit on r/haskell for this but I still think & is a stupid name. Symbolic operators should be mnemonic in the symbolic sense, not in the aural sense
17:51:32 <edwardk> which was as close to := as i could get
17:51:54 <jared-w> That being said, it's one of the better choices when confined to the ascii list of symbols
17:52:00 <Cale> jared-w: & isn't symbolic of anything in any sense, it's just a character that was freely available
17:52:12 <edwardk> trigone: it was selected because it was underutilized and one character. # is often overloaded. % aws taken by Data.Ratio and pissed of yitz
17:52:26 <Cale> Same with $ -- there are only so many symbols which can easily be typed
17:52:30 <edwardk> and &'s natural pairing | was taken by syntax in haskell
17:52:32 <trigone> the best symbol would probably be `->` but it's already reserved too ofc ^^
17:52:39 <jared-w> Right, which makes it a stupid choice to me. It's a symbol that's supposed to denote a meaning and the only reason we choose the symbol is 'cause it looked cute and you can type it easily'
17:52:54 <Cale> What meaning was it supposed to denote?
17:53:04 <trigone> edwardk: yeah as i said, i know there wasn't lots of viable alternatives
17:53:15 * ski . o O ( conjunctive coordination )
17:53:33 <Cale> My complaint about & isn't so much which symbol was picked
17:53:39 <edwardk> anyways the only other one character easily typed symbol available was #   -- which we avoided for a long time because of its comparatively common third party use
17:53:41 <Cale> It's that people are actually going to use the damn thing
17:53:43 <jared-w> &'s mnemonic is "and then" but it's a operator that shunts data down a pipeline, same with $
17:53:46 <edwardk> before giving in and using it for prisms
17:53:51 <edwardk> > _Left # 12
17:53:53 <lambdabot>  Left 12
17:54:06 <Cale> jared-w: I don't think of it that way
17:54:13 * edwardk was waiting for cale to climb up on that high high horse ;)
17:54:18 <Cale> haha
17:54:35 <jared-w> How do you think of it, then? If I may poke you a bit :p
17:54:43 <edwardk> soon i'll have him regressed to where he's ranting that . should be fmap
17:54:52 <Cale> jared-w: It's just function application with the function on the wrong side
17:55:22 <jared-w> So the fact that it's `flip $` is the only thing that's wrong with it?
17:55:29 <Cale> x & f = f x
17:56:06 <trigone> what i'm wondering more than anything is why we don't write compositions of functions from left to right. i know mathematicians (for some reason) sold the habit of reversing everything for fun, but it's still very much easier to read something when you don't have to constantly read from right to left in the middle of a left-to-right language...
17:56:16 <Cale> Well, yeah, it just tends to be a less readable choice than other options for that reason
17:56:17 <ski> edwardk : .. or that `flip' should be `\f x -> fmap ($ x) f' ?
17:56:30 <edwardk> :t (??)
17:56:32 <lambdabot> Functor f => f (a -> b) -> a -> f b
17:56:32 <jared-w> trigone: there's plenty of things that read left to right, right ot left, up to down, down to up
17:56:43 <edwardk> ^- flip
17:57:00 <edwardk> stolen shamelessly from ski
17:57:10 * ski smiles
17:57:15 <edwardk> i really should have stuck to my guns and taken ? for that operator
17:57:24 <jared-w> :t (?)
17:57:25 <lambdabot> error: Variable not in scope: ?
17:57:31 <Cale> I actually dislike >>= for the same reason. Occasionally I grep for instances of >>= and I tend to find that unless it's immediately followed by \case (or part of an instance declaration) there's some code there which is awkward and annoying.
17:57:33 <edwardk> (?) isn't taken
17:57:43 <jared-w> edwardk: there's still a chance, then! :p
17:57:55 <trigone> jared-w: well yeah but even function application i think would have been better off left arg to right function. i don't see the logic in having things the other way round. it's like saying "to cook a cake, you'll end by putting it to the oven, just before tha you'll do this and that" etc, it's absurd
17:58:09 <ski> trigone : "why we don't write compositions of functions from left to right" .. because we write `f(x)' (or `f x' in Haskell), not `(x)f'
17:58:22 <edwardk> jared-w: i took ? at first but it broke diagram which was using it at the time
17:58:33 <jared-w> ski: although some branches of math do write (x)f quite pervasively
17:58:36 <trigone> ski: well i'd advocate for (x f) notation actually
17:58:36 <edwardk> jared-w: so i renamed out of courtesy
17:58:36 <Cale> trigone: You just have to pick some convention and stick with it
17:58:46 <Cale> jared-w: Which ones?
17:59:02 <lyxia> trigone: right-to-left composition is not that bad. If you see  f x = sort . ...  you know that f x is a sorted list.
17:59:18 <Cale> jared-w: There might be some weirdo out there which actually does that, but as far as I know, it's not a common convention.
17:59:30 <ski> trigone : typically (and this is probably what Cale is about), `x' tends to be a larger expression than `f'. and for some reason we usually think it's nicer to first read the operator, rather than the operand
17:59:40 <edwardk> i tend to use & and <&> and for_ the like because the function is usually the big messy thing
17:59:47 <edwardk> and it saves me more parens ;)
17:59:54 <ski> trigone : also, in a definition `f(x) = ..x..', the thing defined comes first, while `x' could be a large pattern
18:00:25 <edwardk> whatever >>= \case             pops up a lot in my code for that same reason.
18:00:31 <jared-w> Cale: to be honest I only know that some branches of math do it; I always forget which ones...
18:00:33 <trigone> ski: well i guess there are arguments for either...
18:00:43 <trigone> edwardk: i love lambda case
18:00:50 <Cale> edwardk: Yeah, \case is the one place where >>= is probably okay
18:00:56 <ski> trigone : fwiw, sometimes i think we ought to do `A <- B', rather than `B -> A', if we're going to stick with `f(x)' / `f x'
18:00:57 <edwardk> i just wish it had been \of
18:01:07 <Cale> edwardk: I wanted case of ...
18:01:08 <trigone> Cale: you don't like the bind operator?
18:01:22 <Cale> edwardk: Just leaving out the scrutinee to get a function, similar to operator sections
18:01:33 <edwardk> that would have been tolerable too
18:01:50 <ski> edwardk : "because the function is usually the big messy thing" -- yep, often (not always) the case
18:01:53 <edwardk> \of or case of both have the benefit that they don't add a new keyword that introduces layout some o the time
18:02:04 <trigone> ski: there's that too. esp if you have to split the sig over several lines, the first will always contain the result (modulo currying), which is much more logical
18:02:34 <ski> trigone : the MLs had "lambda case" from the start. unfortunately Haskell didn't
18:03:30 <trigone> at any rate, gotto go to sleep :) got a big day tomorrow! thanks a lot everybody for the info and discussions! :)
18:03:31 <ski> trigone : in SML, `case <scrutinee> of <matches>' is sugar for `(fn <matches>) (<scrutinee>)'
18:03:57 <trigone> ski: i don't know the language syntax at all
18:04:10 <trigone> (sorry)
18:04:23 <trigone> bye all!
18:04:31 <edwardk> anyhow, i don't have a particular objection to there being multiple styles, its relatively bounded, the problem only spans a dozen names or so in the standard library and locally can make a lot of difference to readability. so while cale has the more defensible view in terms of 'fewer things to learn' i tend to want more expressiveness. having both let and where is redundant too =P
18:04:34 <ski> trigone : `fn x => x+1' is `\x -> x+1'. ..
18:05:34 * hackagebot tile 0.1.0.0 – Slippy map tile functionality. – https://hackage.haskell.org/package/tile
18:05:34 * hackagebot hopenpgp-tools 0.19.5 – hOpenPGP-based command-line tools – https://hackage.haskell.org/package/hopenpgp-tools
18:05:35 <ski> edwardk : .. only mostly
18:06:54 <Cale> edwardk: Yeah, it's okay if it's not abused too much also.
18:07:19 <jared-w> Cale: Pointfree ascii gibberish is my favorite pasttime though...
18:07:44 <edwardk> Cale: if it makes you feel better, i feel the same way about killing 'let's wherever i find them in my code ;)
18:08:01 <Cale> jared-w: It's fun right up until you have to deal with someone else's pointfree ascii gibberish in what ought to have been boring code.
18:08:18 <ski> i don't know of a better solution to the `for_' vs. `traverse_' thing
18:08:31 <jared-w> edwardk: oh you also hate 'let'? What about 'where'?
18:08:32 <edwardk> ski: ? :)
18:08:51 <edwardk> ski traverse ? whatever $ do
18:09:00 <Cale> edwardk: Killing lets in which way?
18:09:22 <edwardk> Cale: usually by turning them into pattern guards or shoving them into where clauses
18:09:26 <jared-w> With fire, season with salt and pepper, then heat on medium high for 4 minutes each side and top with garnish
18:09:26 <Cale> ah
18:09:30 <ski> edwardk : hm. i suppose
18:09:32 <edwardk> let ... in is an unindentable nightmare
18:09:53 <edwardk> it just causes me to sit there with a nervous twitch reformatting the lines its on
18:09:58 <Cale> heh
18:10:32 <Cale> Can't decide if 'in' should line up with the 'let' or be one space deeper?
18:10:46 <ski> edwardk : this is one reason we ought to have "message-dispatching" aka "copattern" syntax, at least for `newtype's
18:11:07 <Cale> 'let' doesn't actually bother me at all
18:11:35 <jared-w> let actually bugs me for an entirely different reason
18:11:35 <edwardk> i can somethings bring myself to 'let in' if its a one line statement in a larger thing
18:11:50 <edwardk> but if the in floats down i get twitchy
18:12:00 <jared-w> "let (some stuff I don't care about yet) in (now I need to figure out how to care about it)"
18:12:10 * ski is thinking of `blah = Foo $ \x -> let ... in ...'
18:12:29 <edwardk> ski blah = foo go where go x = ... ;)
18:12:54 <edwardk> now i can use another where =)
18:12:55 <ski> edwardk : but then i have to make a silly name that's not even recursive
18:13:02 <jared-w> vs "(high level implementation of function) where (ugly details details I can now reason about)
18:13:26 <ski> i'm offended
18:13:30 <edwardk> ski: yeah. that is the one case i do tend to let myself 'let' just because i can't pattern guard a lambda.
18:13:41 <edwardk> \ x | y <- whatver -> ..
18:13:41 <ski> it ought to be `unFoo blah x = ... where ...'
18:13:47 <edwardk> is what i want
18:14:01 <jared-w> multiWayIf does that, does it not?
18:14:13 <edwardk> the if | whatever could work there
18:14:15 <edwardk> yeah
18:14:22 <edwardk> \x -> if | whatever -> ...
18:14:41 <edwardk> i haven't used it to replace let yet, maybe i'll try.
18:15:17 <edwardk> its a 5 character tax over my 'ideal' version, but only 5 characters
18:15:38 <jared-w> plus you can add yet another pragma to your list! Win win, really
18:15:48 * ski grins
18:16:05 <edwardk> i used to use multiway if pretty heavily
18:16:15 <edwardk> not i adopt a sort of 'hanging if' style that reduces the pressure on my code to use it
18:17:30 <edwardk> \x -> if whatever       and then i outdent the 'then' and 'else' like everything else two spaces
18:18:05 <edwardk> er now i adopt i mean
18:19:36 <jared-w> Is there any benefit of one style over another? I'm not quite picturing that in my head
18:20:42 <edwardk> it fits with the surrounding code style i use. i tend to do hanging do blocks, hanging case statements, etc.
18:23:07 <edwardk> the cascading case style sort of crept up on me from writing lots of low level system code directly against State# RealWorld and the like where i had to use it, or where i can't let' bind my way through anyways because it makes ghc's head explode
18:28:49 <jared-w> gotcha, that makes sense
18:40:24 <fresheyeball> I've made much progress toward my strange mission
18:40:37 <fresheyeball> but I've hit a +4 block of stumbling
18:40:42 <fresheyeball> http://lpaste.net/1793278755955802112
18:40:50 <fresheyeball> how to tell GHC that the numbers are LT?
18:43:18 <Axman6> hmm, I feel using a GADT is probably the right thing to produce the proof that the values are LT
18:43:29 <Axman6> like, you need some whitness that that's true
18:43:29 <fresheyeball> Axman6: Splain!
18:43:44 <Axman6> but... I'm not sure I know enough to make it work
18:43:57 <fresheyeball> lame!
18:44:01 <fresheyeball> me too!
18:44:05 <fresheyeball> !!-!!-!!
18:44:44 <Axman6> data LTWitness (a :: Nat) (b :: Nat) (ord :: Ordering) where... yeah dunno
18:45:17 <Axman6> I would poke edwardk in the first instance "(as the person who's most likely to know the answer, no matter what the question is)
18:45:28 <edwardk> ?
18:45:36 <fresheyeball> edwardk: hi! Was about to poke ya
18:45:47 <fresheyeball> *don't hit me, Axman6 told me to
18:45:57 <fresheyeball> http://lpaste.net/1793278755955802112
18:46:09 <fresheyeball> edwardk: how to inform GHC that these number are 'LT
18:46:16 <fresheyeball> ?????????
18:46:27 <edwardk> what am i looking at other than a twisty maze of singletons?
18:46:59 <edwardk> oh
18:47:08 <fresheyeball> edwardk: come now, its not that twisty
18:47:10 <edwardk> have you seen the code in Data.Constraints.Nat?
18:47:15 <fresheyeball> I have not!
18:47:24 <edwardk> http://hackage.haskell.org/package/constraints-0.9.1/docs/Data-Constraint-Nat.html
18:47:40 <edwardk> that gives you machinery for proving stuff with out natural number kinds
18:47:47 <edwardk> as they are? they are basically useless tags
18:48:04 <edwardk> you need something like that or the ghc plugin someone has to actually work with them in earnest
18:49:03 <fresheyeball> edwardk: so apparently I have seen this, given it was already in a tab in my browser
18:49:13 <fresheyeball> I don't see how it could help me
18:49:41 <edwardk> you need something to reify the comparison of the value level singletons into a comparison of the type level ones
18:49:47 <edwardk> i don't have the actual combinator you need in there
18:49:51 <fresheyeball> yes I do
18:50:00 <fresheyeball> HOW TO DO?
18:50:18 <edwardk> by copying the 'axiom' trick i use in that code
18:50:22 <edwardk> its a little bit of unsafety
18:51:02 <edwardk> you need something like (KnownNat n, KnownNat m) => Maybe (Dict (n <= m))
18:51:23 <fresheyeball> is context
18:51:32 <fresheyeball> I don't know what Dict is in this context
18:51:43 <edwardk> data Dict p where Dict :: p => Dict p
18:51:44 <fresheyeball> I know its not a normal term level dictionary
18:51:46 <edwardk> using constraint kinds
18:51:56 <fresheyeball> Ouch!
18:51:58 <fresheyeball> ma brains!
18:52:23 <fresheyeball> so its a reified Constraint?
18:52:50 <edwardk> fresheyeball: http://comonad.com/reader/2011/what-constraints-entail-part-1/ is an article i wrote up when max bolingbroke first added the "Constraint" kind to haskell
18:52:52 <edwardk> it covers Dict
18:52:58 <edwardk> and my :- data type, etc.
18:53:04 <edwardk> you probably want to start there
18:53:11 <edwardk> you'll need a lot of this machinery to make this code go
18:53:18 <edwardk> then you can understand the constraints package
18:53:38 <edwardk> and from there the code in Data.Constraints.Nat should make sense
18:53:45 <edwardk> well more sense
18:53:57 <edwardk> you might need to understand reflection first
18:54:01 <edwardk> also have articles on that!
18:54:39 <fresheyeball> crapes
18:54:43 <fresheyeball> this is alot
18:55:54 <koz_> edwardk's motto should become 'I have an article for that!'.
18:56:00 <koz_> s/article/library also works
18:56:18 <edwardk> fresheyeball: you did jump into the deep end of the pool
18:58:07 <koz_> edwardk: In your Rotten Bananas article, you talk about the lambda cube, but I'm not sure how your data type maps to what is described here: https://en.wikipedia.org/wiki/Lambda_cube
18:58:12 <koz_> Am I looking at the wrong cube?
18:58:56 <crucify_me> I have an article called bananas with small brown sugar spots
18:59:01 <fresheyeball> edwardk: just for fun
18:59:02 <fresheyeball> but yeah
18:59:34 <fresheyeball> also I'm using the compactable package you helped me with at work
18:59:41 <fresheyeball> and it's been very nice so far
19:03:13 <edwardk> crucify_me: related to my rotten bananas article?
19:04:01 <edwardk> derp, just saw koz reference it
19:04:44 <edwardk> koz_: are you familiar with the notion of a 'pure type system'?
19:04:51 <edwardk> it provides a sort of generalization of the lambda cube
19:04:53 <koz_> edwardk: Never heard that term before, so no.
19:05:14 <edwardk> let me see if i can find you an article i like as a quick intro to the topic
19:05:33 <koz_> edwardk: Thanks - it'd help.
19:05:46 <edwardk> http://www.staff.science.uu.nl/~jeuri101/MSc/jwroorda/
19:06:12 <edwardk> jan willem roorda's masters' thesis is a good intro
19:06:22 <edwardk> and far more accessible than most of the literature on the topic
19:06:40 <koz_> edwardk: OK, I'll have to read it. Thanks!
19:06:43 * koz_ appends to reading queue.
19:07:38 <edwardk> the lambda cube corresponds to a certain subset of PTSs based on the presence or absence of 3 different typing rules
19:07:45 <edwardk> each one is independent
19:07:49 <edwardk> so you get 3 dimensions
19:07:56 <edwardk> hence a cube
19:08:00 <koz_> edwardk: Yeah, I got that part.
19:08:10 <koz_> I'm just not quite clear how your datatype corresponds to the cube.
19:08:15 <edwardk> PTSs allow more general families
19:08:29 <edwardk> I have Star and Box there as the 'sorts' involved.
19:08:34 <edwardk> it was a quick sketch
19:11:13 <koz_> Is Erik Meijer fond of bizarre paper names or something? Everything I see with his name on it has the oddest name.
19:12:08 <fresheyeball> edwardk: I'm trying to read your article, its very clear, but I don't think I like programming anymore
19:12:15 <fresheyeball> I'm going to bed
19:12:25 <edwardk> fresheyeball: hahaha
19:13:11 <edwardk> koz_: (->) gives you function spaces, bananas are the syntax he used for catamorphisms, so when you go to extend catamorphisms to cover function spaces you get bananas in space
19:13:35 <koz_> edwardk: Yeah, I get why the name is there, but it's just ... rather unconventional naming for a compsci paper.
19:13:41 <koz_> s/there/what it is/
19:13:51 <edwardk> koz_: the data type there corresponds to a program written in one of the languages of the cube, not the cube itself
19:14:04 <koz_> edwardk: Which corner of the cube did you represent there?
19:14:36 <edwardk> i represented well-formed if not necessarily well-typed programs from all corners. the syntax doesnt change, just which things pi is allowed to take as the type of its argument
19:14:48 <koz_> Ah, OK.
19:15:08 <edwardk> in pure type system terms so long as your only sorts are Star and Box this can represent the program in a slightly extended lambda calculus
19:15:50 <edwardk> you might find the code in https://hub.darcs.net/dolio/pts informative
19:15:59 <edwardk> also https://hub.darcs.net/dolio/upts
19:16:11 <edwardk> the former is more general, the latter is a concrete programming language example as a pts
19:16:21 <koz_> edwardk: Thanks for that - I'll take a look once I've read Bananas in Space.
19:16:45 <edwardk> http://www.cs.kun.nl/~janz/yarrow/ is a proof assistant project in the style of a PTS
19:16:57 <edwardk> and has some interesting thoughts about how to write binders, etc.
19:17:46 <edwardk> i don't know if that latter thing has seen any traffic in a decade or two though
19:18:02 <edwardk> i learned a lot skimming the docs though
19:19:01 <edwardk> http://www.rbjones.com/rbjpub/logic/cl/tlc004.htm is another intro to pure type systems, even if its very mid-90s in formatting
19:19:27 <koz_> edwardk: Thanks - my reading queue is now fuller.
19:19:29 <koz_> Considerably so.
19:20:09 <edwardk> i switch machines to get away from my backlog on a fairly regular basis ;)
19:20:38 <edwardk> otherwise they sit there in my documents folder taunting me
19:20:40 <koz_> I do too, but I actually wanted something else to think about, because I want something else to think about instead of prepping for my supervisory meeting tomorrow.
19:20:54 <edwardk> ah
19:20:57 <koz_> Mostly because I've spent all morning on it, feel about as ready as I should be, but need to give it time to sit.
19:21:02 <koz_> But I still have energy to learn and think.
19:33:40 <cobreadmonster> Hello everyone.
19:34:46 <koz_> cobreadmonster: Hihi!
20:05:42 * hackagebot pipes-group 1.0.8 – Group streams into substreams – https://hackage.haskell.org/package/pipes-group
20:05:42 * hackagebot foldl 1.3.1 – Composable, streaming, and efficient left folds – https://hackage.haskell.org/package/foldl
20:06:43 <iqubic> What's the point of Church Encodings?
20:07:21 <iqubic> Why would you ever want to Church Encode your data.
20:12:03 <Lokathor> @pl \more -> fromMaybe "noparse" (readMaybe $ unwords more)
20:12:03 <lambdabot> fromMaybe "noparse" . readMaybe . unwords
20:14:16 <Lokathor> iqubic, makes it more catholic
20:14:41 <Eduard_Munteanu> Hah.
20:15:16 <Eduard_Munteanu> iqubic, well, there isn't much else you can do in barebones lambda calculus
20:15:19 <koz_> Lokathor: Christian, you mean? :P
20:15:37 <Lokathor> it's a christian subgroup, whatever
20:19:49 <iqubic> Eduard_Munteanu: What do you mean? Do you mean that if I Church encode my data, then I can express it with just lambdas?
20:20:23 <Eduard_Munteanu> iqubic, well, yes.
20:21:28 <iqubic> Oh. Why in the world is that helpful?
20:21:53 <JuanDaugherty> interesting is the new helpful
20:23:34 <Eduard_Munteanu> iqubic, if you're not working with plain lambda calculus, it isn't particularly helpful
20:24:10 <iqubic> How does lambda calulus deal with numbers?
20:26:09 <Eduard_Munteanu> iqubic, it doesn't
20:27:17 <iqubic> Oh. What is lambda calculus good for?
20:27:27 <petercommand> iqubic: The reason why church encoding is used to encode numbers in lambda calculus is that you don't have numbers as primitive construct in lambda calculus
20:27:58 <iqubic> How can you use church encoding to encode numbers?
20:28:27 <Axman6> 3 = \f z -> f (f (f x))
20:28:43 <petercommand> Axman6++
20:29:07 <iqubic> Axman6: where did the z go? where did the x come from?
20:29:10 <Axman6> iqubic: understanding lambda calculus is a pretty fundamental idea in computer science
20:29:11 <koz_> petercommand: So now it's Axman7? :P
20:29:15 <Axman6> uh, x = z
20:29:30 <petercommand> koz_: :P
20:30:21 <iqubic> Axman6: I learned the basics of S K I combinators yesterday, as well as how to do a total case analysis for an ADT to get the church encoding. erisco was a great teacher.
20:30:27 <Axman6> iqubic: iirc tere are some performance advantages to using chruch encoding in some cases, since everything becomes continuation passing, you get some nice guarantees about... things
20:34:02 <iqubic> so Axman6 can you write the lambda calculus addition function?
20:34:27 <iqubic> provided you have two number functions like the one there.
20:36:42 <Axman6> uh, I'd have to remember how to do it...
20:36:58 <koz_> Axman6: Isn't it just composition?
20:36:59 <Eduard_Munteanu> \m n f z -> m f (n f z)   -- I think
20:37:09 <Axman6> add a b = \f x -> a f (b f z)
20:37:13 <Axman6> yeah
20:37:27 <Axman6> @pl add a b = \f x -> a f (b f z)    
20:37:27 <lambdabot> add = ((const .) .) . (. flip flip z) . ap
20:37:42 <iqubic> How the heck does that work???
20:37:46 <Axman6> and multiplication becomes...
20:37:59 <koz_> iqubic: Think about the representation for 2 and 3.
20:38:03 <koz_> Then think of the representation for 5.
20:38:04 <Axman6> mul a b = \f x -> a (b f) x IIRC
20:38:19 <koz_> You'll see that if you compose the functions representing 2 and 3, you'll get the rep for 5.
20:38:34 <Axman6> iqubic: what "3" mean is "apply the function fo to the argument x three times"
20:38:35 <byorgey> it's not exactly composition.
20:39:02 <byorgey> composition is multiplication.
20:39:09 <Lokathor> "The standard functions for encoding and decoding text are strict, which is to say that they throw exceptions on invalid input. This is often unhelpful on real world input, so alternative functions exist that accept custom handlers for dealing with invalid inputs."
20:39:22 <Lokathor> I love how they just say "the standard mode is unhelpful in the real world"
20:39:28 <byorgey> addition is  \f -> a f . b f,  multiplication is  a . b
20:39:46 <iqubic> I see.
20:39:48 <Axman6> what's exponentiation again? it's just a b or something right?
20:40:03 <byorgey> Axman6: yes, but I can never remember whether it's a b or b a
20:40:36 <iqubic> The thing that trips me up is the partial appliction in mult = \a b f x -> a (b f) x
20:41:08 <Axman6> > let three = \f -> f . f . f; five = \f -> f . f . f . f . f in three five f x :: Expr
20:41:10 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
20:41:22 <Axman6> maybe I shouldn've chosen smaller numbers...
20:41:26 <byorgey> hahaha
20:41:28 <koz_> Axman6: Maybe pick something like 2 and 3 instead. :P
20:41:29 <Axman6> > let three = \f -> f . f . f; five = \f -> f . f . f . f . f in three five (+1) 0 :: Expr
20:41:32 <lambdabot>  0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + ...
20:41:36 <Axman6> > let three = \f -> f . f . f; five = \f -> f . f . f . f . f in three five (+1) 0 Int
20:41:38 <lambdabot>  error:
20:41:39 <lambdabot>      • Data constructor not in scope: Int
20:41:39 <lambdabot>      • Perhaps you meant one of these:
20:41:41 <Axman6> > let three = \f -> f . f . f; five = \f -> f . f . f . f . f in three five (+1) 0 :: Int
20:41:42 <iqubic> And the people of #emacs officially hate me.
20:41:43 <lambdabot>  125
20:41:55 <Axman6> ok, looks like it's b a
20:42:03 <koz_> Axman6: Yeah, that seems like it.
20:42:17 <Axman6> I forgot how large thos numbers were :P
20:42:37 <byorgey> yeah.  I guess that makes sense because  a^b  means you do a, b times.
20:42:50 <byorgey> so it has to be  b a
20:43:11 <Axman6> iqubic: well, that's the same as: mult = \a b f x -> a (\x' -> b f x) x
20:43:53 <iqubic> Axman6: yeah.
20:44:00 <monochrom> One x there should be x'
20:44:06 <Axman6> uh, yes
20:44:07 <iqubic> We just use eta-reduction to remove the x'
20:44:17 <iqubic> monochrom: the inner x should be x'
20:44:24 <Axman6> typing faster than I'm thinking
20:44:38 <iqubic> That's usually not good.
20:44:52 <iqubic> I like true and false in lambda calculus a lot.
20:45:02 <iqubic> true = \x y -> y
20:45:16 <iqubic> false = \x y -> x
20:45:23 <iqubic> or other way around.
20:45:39 <iqubic> true is const, and false is flip const.
20:46:25 <iqubic> true returns arg 1. false returns arg 2.
20:46:42 <iqubic> not = \p -> p false true.
20:46:58 <Axman6> so, can you now make the if function? iff :: bool -> a -> a -> a
20:47:07 <iqubic> What would that do?
20:47:27 <iqubic> what are the three a there?
20:47:27 <Axman6> if the given bool is true, return the first argument, if it's false, return the second
20:47:43 <Axman6> (well, second and third I guess)
20:47:55 <iqubic> Ah. \p a b -> p a b
20:48:02 <Axman6> otherwise know as...
20:48:08 <iqubic> now to reduce
20:48:17 <iqubic> \p a -> p a 
20:48:24 <iqubic> and then to \p -> p
20:48:27 <iqubic> it's id.
20:48:30 <Axman6> a.k.a...
20:48:34 <Axman6> good
20:48:56 <iqubic> But I don't get how \p -> p is different from p
20:48:57 <Axman6> things start getting fun when you get into how you make recursive programs
20:49:15 <iqubic> Axman6: loop = \x -> x x
20:49:24 <Axman6> not quite
20:49:28 <iqubic> or not that.
20:49:44 <monochrom> (\x -> x x) (\x -> x x) is the loop you sought.
20:49:52 <iqubic> Yeah.
20:50:04 <iqubic> Now let's try adding in a function to that.
20:50:25 <Axman6> Y f = (\x -> f (x x)) (\x -> f (x x)) right?
20:50:42 <monochrom> yeah
20:51:04 <iqubic> That's what I was going to get to.
20:51:36 <Axman6> anyway, before getting to recursion, it's helpful to define some comparison functions, for checking if two numbers are equal, less than or greater than
20:51:43 <Axman6> (I can't remember how to do this...)
20:52:20 <iqubic> Well, that would require a way to translate from numbers to boolean.
20:52:59 <iqubic> Can you write and?
20:55:13 <iqubic> \x y -> x y x
20:55:18 <iqubic> That's and
20:55:25 <Axman6> starting with and, or, not etc is a god place to start
20:55:57 <iqubic> Once you have and + not, you can chain them to get nand.
20:56:04 <Axman6> (I always wrote that as \x y -> x y false)
20:56:13 <iqubic> Axman6: that works too.
20:56:29 <iqubic> or = \x y -> x true y
20:57:23 <iqubic> zero = \f x -> x
20:58:11 <iqubic> iszero = \n -> n (\x -> false) true
20:59:03 <iqubic> If that function \x -> false is executed any times, we get false. zero is the only number that executes its function zero times.
21:01:42 <iqubic> I need a nice simple haskell project to get work on.
21:01:56 <koz_> iqubic: Write a command-line utility.
21:01:59 <Cale> The way I like to think about the Church encoding is to actually start by thinking about the algebraic data type.
21:02:13 <koz_> Cale: You mean Z | S n ?
21:02:22 <Cale> yes, if we're talking about numbers
21:02:55 <monochrom> Me too. There is a mechanical translation both ways.
21:03:06 <Cale> So, in order to turn something like S (S (S Z)) into its Church encoding, we need to bring Z and S into scope, and the only way to do that is by binding them with lambda
21:03:38 <Cale> So you get \z s -> s (s (s z))
21:03:46 <Cale> Or you can swap the arguments if you prefer
21:04:50 <iqubic> how do Peano numbers work?
21:05:36 <iqubic> data PNum = Z | S n
21:05:43 <iqubic> is that all there is to it?
21:05:46 <Cale> yeah
21:06:01 <Cale> Also often named "Nat"
21:06:03 <monochrom> S PNum
21:06:11 <Cale> oh, yes :)
21:06:17 <iqubic> And you use those a lot like the lambda numbers we were just describing?
21:06:31 <orzo> i just upgraded 8.0.1 -> 8.0.2 and it's a much bigger improvement than i expected
21:06:32 <iqubic> Why are peano numbers ever useful?
21:07:13 <orzo> compiles are much faster, and typed-holes behaves a little different and more usefully
21:07:14 <iqubic> It seems like it would be hard to write a function like IsEven :: Nat -> Bool
21:07:32 * hackagebot turtle 1.4.3 – Shell programming, Haskell-style – https://hackage.haskell.org/package/turtle
21:08:01 <iqubic> is it possible to write a function like IsEven?
21:08:17 <monochrom> Have you seen one of those comics that depict a prisoner? And how he/she marks the number of days imprisoned by horizontal and vertical strokes? That's when Peano numbers are used.
21:08:32 <iqubic> Really?
21:08:59 <monochrom> Each stroke stands for one S. The Z is implicit.
21:09:18 <iqubic> LOL
21:09:37 <iqubic> So when are Peano Numbers used in actual code?
21:09:45 <monochrom> For easy visualization, strokes are grouped into groups of five, consisting of four vertical strokes and one horizonal stroke that crosses the four vertical strokes.
21:09:45 <koz_> iqubic: To write isEven, consider this: zero is even, 1 is odd, and x is whatever x - 2 is.
21:11:23 <Hafydd> So -1 is <<Loop>>
21:11:39 <koz_> Hafydd: Peano numbers are nats - there is no -1.
21:11:46 <Hafydd> I see.
21:13:33 <monochrom> Another use of Peano numbers is in connecting NP-completeness with a fundamental goal of mathematics, and why it is so fundamental that it is worth a Clay Millennium Prize.
21:14:50 <koz_> Peano arithmetic also describes arithmetic formally without needing to resort to arithmetic.
21:15:09 <koz_> It can actually demonstrate that 1 + 2 = 2, for example.
21:15:18 <koz_> And that addition and multiplication work 'how we expect'.
21:15:32 <koz_> s/1+2/1+1/
21:15:38 <koz_> I should type more slowly, lol.
21:16:45 <monochrom> Take your favourite open conjecture in math. The decision problem "Input: A number n in Peano form. Yes/No Question: Is there a proof of length at most n for the conjecture?" is an NP problem.
21:17:32 <monochrom> If P = NP, then that question can be answered in polynomial time.
21:18:26 <koz_> monochrom: What's the name of this problem?
21:18:33 <iqubic> monochrom: what do you mean by "proof of length at most n"?
21:18:57 <iqubic> How can proofs have lengths, and why does n need to be in Peano form?
21:19:19 <koz_> iqubic: A formal proof certainly can have length.
21:19:28 <koz_> It's the number of steps to derive the conclusion from the premises.
21:19:44 <iqubic> Ah.
21:19:47 <orzo> hmm
21:20:13 <orzo> I just went through adding top-level signatures that ghc complained were missing and that fixed a compiler panic
21:20:16 <monochrom> That means, for example, if in practice you can only afford to read a proof/disproof of length 10MB, and if P = NP, then basically all open conjectures can be resolved as { there is a readable proof, there is a readable disproof, solution is too hard I have to give up }.
21:20:38 <iqubic> Ah, I see.
21:20:38 <orzo> it's weird it'd panic since i was just pasting the signatures that it infered from the error messages
21:20:55 <iqubic> orzo: That is super bizzare.
21:21:12 <orzo> it's 8.0.2
21:21:22 <orzo> but it also paniced with 8.0.1 before upgrade
21:21:46 <iqubic> For those of you that use Emacs, what are your go to packages for editing haskell code?
21:21:46 <monochrom> In fact, the significance is not just "can be resolved". It is "can be resolved in a short time".
21:21:49 <orzo> i think it has to do with -fdefer-typed-holes, iqubic
21:22:03 <iqubic> orzo: Does you code have type holes?
21:22:06 <orzo> yeah
21:22:08 <koz_> iqubic: Flycheck is pretty cool.
21:22:21 <iqubic> koz_: I've heard of that. 
21:22:51 <iqubic> What about ghc-mod and intero?
21:24:02 <monochrom> In other words, if P = NP, then all of mathematics is a "solved problem" for all practical purposes. It can shake the very foundation. That kind of fundamental.
21:24:15 <koz_> iqubic: Some people use them; I didn't when I still used Emacs, and it worked OK.
21:24:45 <monochrom> "Very foundation" not as in whether you use set theory or HoTT. As in what are you going to do next.
21:24:59 <iqubic> koz_: what editor do you use now?
21:25:42 <iqubic> Does the set of all sets which don't contain themselves contain itself?
21:30:57 <hodapp> nah.
21:31:45 <iqubic> Why no hodapp?
21:32:08 <monochrom> Na.
21:32:19 <hodapp> since we're dealing with nonconstructive things, the 'why' doesn't really matter
21:32:40 <iqubic> Alright then.
21:33:02 <iqubic> I wish someone would write an editor that can be configured in Haskell.
21:33:13 <MarcelineVQ> have you looked for one?
21:33:15 <iqubic> Or at least a way to convert Haskell to Lisp
21:33:18 <hodapp> There's Yi.
21:33:22 <hodapp> up to you if you want to use it.
21:33:33 <iqubic> MarcelineVQ: no. I like emacs to much to switch to something like Yi
21:33:53 <hodapp> Compiling Haskell to something Lispy probably wouldn't be that hard, I'm just not sure it'd accomplish much
21:34:19 <iqubic> hodapp: I don't want to learn elisp to configure emacs.
21:38:09 <koz_> iqubic: Neovim.
21:39:04 <iqubic> koz_: You use neovim?
21:39:14 <iqubic> Why did you switch away from emacs?
21:39:25 <koz_> iqubic: I find Neovim easier to work with.
21:39:33 <koz_> YMMV of course.
21:40:28 <iqubic> Ah. I just use evil and that's that.
21:49:36 <monochrom> koz_: The book «The Nature of Computation» names it "SHORT PROOF". I don't know whether it's a standard name.
21:59:39 <koz_> edwardk: The machines talk link is 404ing.
21:59:51 <koz_> edwardk: Namely this one: https://dl.dropboxusercontent.com/u/4588997/Machines.pdf
22:00:29 <iqubic> koz_: it 404s for me too.
22:01:09 <xacktm> fyi dropbox disabled public hotlinking a few months back.. :/
22:02:35 <iqubic> I think that might be the cause of this issue.
22:02:54 <koz_> iqubic and xacktm: This link was working as recently as 48 hours ago.
22:03:12 <iqubic> Oh, well I don't know then.
22:05:19 <TRS-80> xacktm then what's the point of Dropbox any more? lol
22:06:19 * hackagebot chart-unit 0.5.1, path-extra 0.0.5, urlpath 6.0.0
22:06:19 * hackagebot  → https://hackage.haskell.org/packages/recent
22:06:28 <iqubic> I use Dropbox for cloud storage and backup.
22:07:09 <iqubic> However, it didn't like me trying to upload all the files in my \etc and \home folders all at once.
22:07:39 <xacktm> TRS-80: there's workarounds, and you can still share links (through many hoops)
22:07:44 <iqubic> Those two folders alone were way too big for me to store for free.
22:08:01 <geekosaur> not that many hoops
22:08:07 <geekosaur> you just have to be explicit about it now
23:06:12 * hackagebot urlpath 6.0.1 – Painfully simple URL deployment. – https://hackage.haskell.org/package/urlpath
23:06:12 * hackagebot markup 4.0.1 – Abstraction for HTML-embedded content – https://hackage.haskell.org/package/markup
23:40:14 <koz_> How do you run a Moore machine from machines? The 'run' function doesn't seem to work for them.
23:47:09 <koz_> Never mind - auto is a thing.
23:54:05 <koz_> In fact, I'm a bit confused about Moore machines in general, and specifically unfoldMoore - what do s, b and a represent in its definition?
23:58:33 <cocreature> koz_: afaik s is the internal state of the moore machine, b is the observable output and a are the inputs
23:59:10 <cocreature> so `(s -> (b, a -> s))` describes the output in a given state and how you transition to the next state
23:59:11 <koz_> cocreature: And the Moore machine expects inputs of type a?
23:59:16 <cocreature> yep
23:59:21 <koz_> Namely, just 'a', or [a]?
23:59:43 <cocreature> the transition function is "s -> a -> s" so just a
23:59:51 <koz_> Ah, OK, that makes more sense.
23:59:52 <cocreature> but ofc you can repeatedly apply that
