00:02:28 <`Guest00000> hmm
00:02:58 <`Guest00000> i can't compare ('x',1) and (['x'], 2) with (==) `on` snd
00:03:31 <`Guest00000> because `on` requires equal types, but how would you fix `on`?
00:04:47 <`Guest00000> on' :: (b -> b -> c) -> (forall x . a x -> b) -> a x -> a y -> c?
00:05:20 <`Guest00000> but would (Char, Int), (String, Int) unify with a x, a y?
00:06:33 <`Guest00000> > (undefined :: a x -> a y -> ()) ('x', 0) ("x", 0)
00:06:36 <lambdabot>  error:
00:06:36 <lambdabot>      • Couldn't match expected type ‘Char’ with actual type ‘[Char]’
00:06:36 <lambdabot>      • In the expression: "x"
00:06:50 <`Guest00000> hmm, yes, they would
00:07:20 <`Guest00000> no, stop
00:08:02 <`Guest00000> > (undefined :: a x -> a y -> ()) (0, 'x') (0, "x")
00:08:04 <lambdabot>  *Exception: Prelude.undefined
00:08:10 <`Guest00000> pity
00:08:33 <`Guest00000> need to manually insert type-reordering newtypes
00:14:48 <olligobber> `Guest00000, you could make a function of type (c->c->d) -> (a->c) -> (b->c) -> (a->b->d) that acts like on
00:15:02 <olligobber> :exp (c->c->d) -> (a->c) -> (b->c) -> (a->b->d)
00:15:41 <olligobber> :exf (c->c->d) -> (a->c) -> (b->c) -> (a->b->d)
00:15:42 <exferenceBot> \ f1 f2 f3 d -> f1 (f2 d) . f3
00:15:42 <exferenceBot> \ f1 f2 f3 d e -> f1 (f3 e) (f2 d)
00:16:12 <olligobber> let on_ = \ f1 f2 f3 d -> f1 (f2 d) . f3
00:16:17 <saurabhnanda> is there any standard data structure, like Either, but which doesn't imply error/success? My use-case is being able to pass alternative arguments to functions. If a PK (eg. OrderId) is passed, then the function is going to fetch the Order from the DB, however, if an Order is passed, then it will use the Order that has been passed-in (i.e. a needless roundtrip to the DB will not be made). Is there any other standard way of doing this 
00:16:18 <saurabhnanda> in Haskell or FP?
00:17:18 <olligobber> saurabhnanda, usually in Haskell, if a function does different things depending what you give it, we would write two different functions
00:17:24 <woggin> Pattern matching?
00:17:38 <woggin> f Order = ..
00:17:38 <olligobber> saurabhnanda, Either doesn't have to imply error/success
00:17:42 <woggin> f OrderId = ..
00:17:44 <Hafydd> saurabhnanda: Either does not imply error/success, except in its Applicative/Monad/etc instances. What makes you think it does?
00:17:58 <saurabhnanda> olligobber: that doesn't bode well across a large team. There is nothing in FP which helps you in the **discoverability** of alternative functions.
00:18:22 <saurabhnanda> woggin: how do you unify Order & OrderId at the type level?
00:18:42 <saurabhnanda> Hafydd: general use-case of Either. Nothing else.
00:19:48 <Hafydd> saurabhnanda: I don't know what you mean by that, but it sounds like a misconception. There's nothing in the name "Either" implying one is treated differently from the other, and there certainly are examples of usage where the Left value is not used as an error.
00:20:10 <Hafydd> saurabhnanda: but, for the record, you could define a data type like this: data OrderSpec = SpecOrder Order | SpecOrderID OrderID
00:20:40 <olligobber> @let on_ = \ f1 f2 f3 d -> f1 (f2 d) . f3
00:20:42 <lambdabot>  Defined.
00:21:13 <olligobber> >compare `on_` snd snd ('a',1) ("a",1)
00:21:18 <olligobber> > compare `on_` snd snd ('a',1) ("a",1)
00:21:21 <lambdabot>  error:
00:21:21 <lambdabot>      • Couldn't match expected type ‘(a1,
00:21:21 <lambdabot>                                       (Char, Integer) -> ([Char], Integer) ->...
00:21:31 <olligobber> hmm
00:22:46 <olligobber> > on_ compare snd snd ('a',1) (['a'],1)
00:22:49 <lambdabot>  EQ
00:22:55 <olligobber> `Guest00000, I did it ^
00:22:57 <fakenullie> what's type of compare
00:23:08 <olligobber> :t compare
00:23:09 <lambdabot> Ord a => a -> a -> Ordering
00:23:47 <mfukar> Are you looking for `comparing`?
00:24:04 <x-x> :t comparing
00:24:05 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
00:24:35 <olligobber> mfukar, that will only work if both inputs are the same type
00:25:38 <olligobber> though comparing will be useful in future
00:25:41 <olligobber> @hoogle comparing
00:25:42 <lambdabot> Data.Ord comparing :: (Ord a) => (b -> a) -> b -> b -> Ordering
00:25:42 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
00:25:42 <lambdabot> Distribution.Utils.Generic comparing :: Ord a => (b -> a) -> b -> b -> Ordering
00:26:00 <`Guest00000> damn
00:26:06 <`Guest00000> never ending errors
00:26:17 <`Guest00000> now "module" parses like [QVar (U (VarId "modul")),QVar (U (VarId "e"))]
00:26:45 <fakenullie> > comparing snd ('a', 1) ("a", 1)
00:26:48 <lambdabot>  error:
00:26:48 <lambdabot>      • Couldn't match expected type ‘Char’ with actual type ‘[Char]’
00:26:48 <lambdabot>      • In the expression: "a"
00:27:06 <`Guest00000> because varid is earlier than reservedid in lexeme....
00:28:13 <olligobber> @karma mfukar
00:28:13 <lambdabot> mfukar has a karma of 1
00:28:25 <olligobber> mfukar++
00:28:36 <mfukar> > compare (snd ('a', 1)) (snd ("b", 2))
00:28:39 <lambdabot>  LT
00:28:43 <mfukar> ^ now rewrite `comparing` :)
00:29:09 <olligobber> mfukar, those two snd have different types though >:(
00:29:15 <mfukar> Sure
00:29:19 <`Guest00000> lexes, not parses
00:29:32 <mfukar> their arguments do
00:31:01 <fakenullie> @lel on_ f  d = \f d -> f  d
00:31:03 <lambdabot>  .L.hs:162:1: error:
00:31:03 <lambdabot>      Multiple declarations of ‘on_’
00:31:03 <lambdabot>      Declared at: .L.hs:158:1
00:31:05 <fakenullie> @let on_ f  d = \f d -> f  d
00:31:06 <lambdabot>  .L.hs:162:1: error:
00:31:06 <lambdabot>      Multiple declarations of ‘on_’
00:31:06 <lambdabot>      Declared at: .L.hs:158:1
00:31:10 <fakenullie> heh
00:31:11 <x-x> but the comparison values do not, eh.
00:31:39 <olligobber> fakenullie, try clearing lambdabot first
00:31:53 <olligobber> @undef on_
00:31:53 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
00:32:03 <olligobber> @undef
00:32:03 <lambdabot> Undefined.
00:32:34 <olligobber> that definition is silly anyway
00:32:53 <olligobber> id would do the same thing in most cases
00:44:14 <x-x>  /join #clojure
00:44:51 <olligobber> lel
01:23:01 <jakub> Hi, is there any good reason why Num class includes abs and signum?
01:25:22 <[exa]> jakub: I guess you have an instance where abs/signum don't make much sense?
01:25:39 <fakenullie> I don't see why it shouldn't
01:25:40 <jakub> [exa]: yes
01:26:01 <merijn> jakub: Because Num isn't very principled
01:26:15 <merijn> jakub: What are you trying to make an instance of Num?
01:27:06 <jakub> a GADT with constructors Const n, Add a a, Mul a a
01:27:42 <fakenullie> not including negative numbers?
01:27:55 <[exa]> (wouldn't it be great if the whole set/monoid/group/ring/field topology was respected by haskell? :] )
01:28:04 <jakub> including negative numbers, but not including non-linear stuff
01:28:46 <fakenullie> why do you need it to be Num?
01:29:04 <merijn> fakenullie: Probably because he wants to use + * etc
01:29:14 <jakub> I don't *need to*
01:29:16 <merijn> jakub: What's the issue with implementing abs/signum?
01:29:19 <jakub> merijn: exactly
01:29:34 <saurabhnanda> is there any heterogenous map library that doesn't force you to first generate keys using specific functions, eg. withKey or createKey?
01:29:41 <[exa]> abs/signum require actual computation I guess
01:29:57 <[exa]> (nonlinear)
01:30:14 <jakub> merijn: ok so 1) I dont want it to be possible to construct nonlinear expressions such as abs and signum
01:30:20 <[exa]> jakub: you can leave abs/signum just `undefined` to see what will hit it
01:30:30 <jakub> merijn: and 2) there is yet another constructor Var String
01:30:55 <merijn> jakub: Do you plan to use +, *, /, and co in the same module?
01:31:03 <jakub> [exa]: for abs to work on Var i would need to have yet another IfThenElse or some such
01:31:04 <merijn> jakub: If not, you could just shadow the existing ones?
01:31:08 <[exa]> jakub: anyway Num is supposed to be for first-class numberish numbers, if you want operators, why not go with something like +' ?
01:31:51 <jakub> [exa]: I do have those, but unfortunatelly the user of my code is confused by the duplicity of symbols
01:31:59 <[exa]> jakub: which would work unless you would want one function definition to work with both your linear ASTs and numbers
01:32:05 <[exa]> oh so.
01:32:57 <jakub> anyway, Num is an ugly class :) there is no clean and standard way around it, i get it, i will have to accept that :)
01:33:00 <[exa]> I guess undefined will work best in that case
01:33:56 <jakub> [exa]: undefined is something i am not willing to accept, the user might rightfully expect abs and signum to be applicable and raise a runtime error
01:34:28 <[exa]> I can't see any possibility to circumvent that actually
01:34:55 <[exa]> by instantiating Num you're promising the type system that abs will be there :]
01:35:55 * hackagebot yst 0.5.1.2 – Builds a static website from templates and data in YAML or CSV files. – https://hackage.haskell.org/package/yst
01:36:40 <[exa]> maybe you could force the type system into adhoc overloading/instantiation just as in C++, but that'd be black magic
01:44:08 <ertes-w> hllo
01:45:06 <saurabhnanda> is anyone outside of FB using Haxl?
01:45:15 <ertes-w> jakub: you can always just do this:  signum 0 = 0; signum _ = 1
01:45:21 <ertes-w> jakub: then: abs = id
01:46:29 <ertes-w> jakub: problem is that Num builds on an equivalence relation in order to establish something like that, so for an AST type you would have to either include 'abs' and 'signum', or you would have to build evaluation into 'abs' and 'signum'
01:47:08 <ertes-w> saurabhnanda: check out the 'dependent-map' package
01:48:16 <ertes-w> jakub: also Num is not an ugly class…  it's a class for rings =)
01:49:29 <jakub> ertes-w: ok, it is ugly in that it is monolithic and does not promote stuff from simpler concepts to rings
01:49:39 <saurabhnanda> ertes-w: thanks!
01:54:51 <ertes-w> jakub: i don't know how to do that sanely with haskell's type class mechanism…  ideally a ring would be built from a group and a monoid, but that doesn't quite work…  you could probably use type families to achieve it, but then Num is no longer h2010
01:55:01 <saurabhnanda> is there any data-type/structure that maintains an in-memory changelog? I'm fetching a record from the DB, changing some fields, and storing it back to the DB. I need to know which fields have changed from the original record. What's the best way to do this, without introducing another vector for possible bugs?
01:56:24 <jakub> ertes-w: i see and don't want to offend anyone, yet the statement about it being ugly is independent of a statement of better version being impossible
01:56:45 <ertes-w> saurabhnanda: one option: if rows form a vector space, then "changelogs" form an affine space over it
01:58:10 <saurabhnanda> ertes-w: umm... don't know what you meant :)
01:59:22 <ertes-w> saurabhnanda: an affine space is basically a space of "changes" or "differences" over a vector space
02:00:30 <ertes-w> saurabhnanda: https://hackage.haskell.org/package/linear-1.20.7/docs/Linear-Affine.html
02:01:08 <ertes-w> as i said, this only really works for vector spaces, so you would have to establish that structure first
02:06:03 <jakub> ertes-w: any chance of next haskell report making the base of haskell better principled?
02:06:52 <ertes-w> jakub: hardly
02:07:10 <saurabhnanda> ertes-w: **finding the difference** is not the problem. Making sure that the before/after values are available is the problem. In an OOP world, the object can hold state. Once a setter changes a field, the original value can be maintained internally. What's the equivalent in FP world?
02:07:32 <ertes-w> jakub: the biggest milestones we have achieved so far were AMP and FTP, which weren't quite as invasive as this would be
02:08:03 <ertes-w> saurabhnanda: just keep the original around
02:08:20 <ertes-w> saurabhnanda: you never *change* it, because it's immutable anyway
02:08:24 <DawidLoubser> Exactly - most FP data structure are immutable (persistent) - just don't throw the original version away :-)
02:08:30 <ertes-w> saurabhnanda: i thought you need a way to maintain changes *efficiently* =)
02:08:36 <merijn> There's been many attempted redesigns of the Num hierarchy, all with their own warts
02:08:55 <cocreature> saurabhnanda: make a type that tracks changes, don’t expose the constructors and make all modifiers add changes
02:09:04 <tdammers> rewriting the Num hierarchy is a rabbit hole
02:09:23 <tdammers> you start with the blatant problems (addition implying subtraction etc.)
02:09:43 <tdammers> but then one thing leads to another...
02:11:39 <saurabhnanda> cocreature: wouldn't it make working with such structures extremely cumbersome. For example, there wouldn't be an easy way to construct a record of such type, or modify the record
02:12:02 <lamdevhs> hi! what's the problem with my function tails [] = [[]]; tails (x:xs) = xs : tails xs ? ghci breaks right when the list should end, telling me there's a non-exhaustive pattern...
02:13:15 <merijn> lamdevhs: lpaste the entire code + error
02:14:36 <maerwald> I am converting between two representations of cabal dependencies (or rather 3): Cabal API -> extended internal structure -> distro-specific structure. The extended internal structure is used to gather information about dependencies like what flag it depends on etc, which is not in the Dependency type of Cabal.
02:14:36 <maerwald> Somehow, I seem to end up needing lenses to build the 3rd structure in a sane way, which leads me to think something is over-engineered: https://git.io/v5pgb
02:15:05 <lamdevhs> merijn: actually nevermind, it seems there was some weird bug. i copied my function in a file and the bug wasn't reproduced... doesn't ghci work well with mutilines definitions?
02:15:22 <lamdevhs> (with let)
02:15:41 <merijn> lamdevhs: No, ghci doesn't work well with that, no :)
02:16:05 <lamdevhs> merijn: well that sucks, esp since it screws up silently...
02:16:21 <merijn> lamdevhs: How did you write the definitions? Using let?
02:21:23 <lamdevhs> merijn: yes, i used let, over two consecutive lines (but with one prompt, if that makes qsense)
02:23:50 <merijn> lamdevhs: In that case you defined two independent tails functions, the second shadowing the first :)
02:24:22 <DawidLoubser> Exactly.
02:24:24 <DawidLoubser> It's quite tedious to try to write multi-line function definitions in GHCI. I would really rather define them in a file (easy to load, and easy to re-load using :r)
02:24:28 <DawidLoubser> If you really want to do it in GHCI, an option is to not do multi-line, but separate your definitions on a single line using semicolons.
02:25:45 <merijn> I always just use a file + :reload, yeah
02:26:03 <merijn> Also because ghci didn't have multi-line support when I started :p
02:26:46 <vaibhavsagar> IHaskell!
02:27:47 * hackagebot knead 0.2.3 – Repa array processing using LLVM JIT – https://hackage.haskell.org/package/knead
02:33:36 <ertes-w> jakub: this is how i imagine how Num *should* work: https://gist.github.com/esoeylemez/d40316f60f268fda71425774fbdeae80
02:33:41 <ertes-w> but you can see, it's quite heavy
02:33:50 <ertes-w> it's not complicated, but it's heavy on extensions
02:37:21 <ertes-w> if you separate the instance definitions from the class definitions, you can see that it's only slightly more work to implement a instances of Ring and Field
02:37:40 <ertes-w> s/a instances/instances/
02:39:18 <ertes-w> (well, it builds on Num to remove some boilerplate related to Sum and Product, but it doesn't have to…  if it wouldn't, you would have the primitives in Monoid instances instead of Num)
02:44:02 <merijn> hmm, there was this trick to ensuring that monadic recursion stayed reasonably fast, but I forget what it was
02:44:46 <merijn> Something like using fix instead of recursively calling itself and the end of the block?
02:46:16 <ertes-w> merijn: 'fix' only ensures sharing
02:46:41 <ertes-w> merijn: you can use Codensity/ContT to flatten associativity, which may improve performance
02:47:05 <merijn> ertes-w: My question is more: Does it make sense to use fix over the dumb recursion?
02:47:57 <ertes-w> merijn: sometimes…  what is more helpful is to find opportunities to do mutual recursion
02:48:46 <ertes-w> f = begin where { begin x y z0 = … go z0 … where { go z = … begin _ _ _ … } }
02:48:59 <ertes-w> merijn: like this…  notice that 'go' has a reduced view on the state
02:50:48 <merijn> Not sure I understand what that is intended to illustrate?
02:53:16 <merijn> Actually, I just remember I was planning to rip this code out anyway, so maybe I shouldn't think about this too much
02:54:43 <merijn> ertes-w: I though I had an epiphany on how to do the fold approach you suggested, but I'm not sure that'll actually work, since afaict pipes doesn't actually have the fold combinator I'd need to make it work (i.e. the folds in Pipes.Prelude are all in 'm', not in the Pipe monad)
02:55:52 <jakub> ertes-w: thx, eventually extensions become part of the language, extensions should not always be seen as abominations :)
03:01:37 <ertes-w> merijn: if you don't exploit opportunities for mutual recursion, recursive calls will always be made with the full state…  sometimes GHC can optimise that away, but sometimes it fails
03:02:05 <merijn> ertes-w: Currently it doesn't have any state :p
03:02:26 <merijn> ertes-w: Anyway, time for lunch. I'll try and figure out the fold formulation after food
03:02:29 <ertes-w> jakub: if i were in charge, i would add a lot of GHC's extensions to standard haskell =)
03:03:10 <ertes-w> merijn: i can write an example of how i imagined it later
03:03:16 <ertes-w> merijn: (regarding the fold)
03:14:13 <ertes-w> merijn: https://gist.github.com/esoeylemez/6c0d346d1a026fd3d8261a4bc16847cc
03:14:41 <ertes-w> merijn: this one can be integrated into all stream frameworks i know, even enumerator
03:18:03 <ertes-w> merijn: the 'foldl' library exposes Trav as FoldM and has a slightly better encoding as well as some very useful instances
03:18:18 <ertes-w> i wrote it with explicit recursion to get the idea across
03:25:42 <ertes-w> merijn: this is the FoldM version: https://gist.github.com/esoeylemez/ab949eda974e60779745ab7f672d073b
03:26:43 * hackagebot cassava-embed 0.1.0.0 – CSV-file embedding library – https://hackage.haskell.org/package/cassava-embed
03:27:53 <`Guest00000> heh, broke associativity for Applicative and it worked correctly and linearly
03:32:56 <felixsch__> I want to convert Text to Int,Bool,Double,Text is there already an implementation for this or do I have to write it myself. Quick searching didn't reveal anything except (Data.Text.Read)
03:35:23 <merijn> felixsch__: For what sorta purpose? Are you parsing files/protocols/user input?
03:35:58 <felixsch__> just for files (ini files using Data.Ini)
03:36:44 <merijn> felixsch__: Well, ini already depends on attoparsec, so I'd just use attoparsec
03:37:36 <merijn> felixsch__: Hell, that library already has "parseValue" for converting via attoparsec parsers
03:38:07 <felixsch__> merijn: I know, just tought there is already a implementation I don't know of :)
03:38:56 <merijn> felixsch__: attoparsec has parsers for numbers already, so you just need one for Bool
03:40:29 <felixsch__> merijn: yes, just tough there is already some kind of Read a class which can be used :)
03:40:50 <merijn> felixsch__: Well, the Read class exists, but it has *awful* performance
03:41:07 <merijn> felixsch__: So you should really avoid using it for anything other than hacky debug things
03:42:10 <felixsch__> merijn: yep true
03:43:07 <cocreature> felixsch__: for Int and Double, https://hackage.haskell.org/package/text-1.2.2.2/docs/Data-Text-Read.html contains parsers
03:43:36 <felixsch__> cocreature: yep I found them already :)
03:44:31 <Sornaensis> how do I turn java into haskell
03:44:51 <speak> You use the philosophers stone
03:45:05 <Sornaensis> I just started working at this new company
03:45:07 <merijn> cocreature: He already depends on attoparsec and his library exposes a function to use attoparsec parsers
03:45:13 <merijn> cocreature: So he should really just use those
03:45:30 <Sornaensis> and they use a java framework that tries to do things functionally
03:45:43 <merijn> felixsch__: attoparsec has "decimal :: Integral a => Parser a" and "double :: Parser Double"
03:48:50 <felixsch__> merijn: cocreature: Implementing with attoparsec is no problem just wanted to know if there is already a implementation of fromText or what ever it's called :)
03:50:55 <merijn> felixsch__: You don't even need to implement them, you can literally just do "import Data.Attoparsec.Text (decimal, double)" and use them with ini's parseValue
03:52:23 <felixsch__> merijn: that's what I'm doing now. I admit I didn't see the parseValue good catch :)
03:54:52 <merijn> ertes-w: Right, your solution looks mostly like what I already came up with, the problem is that pipes doesn't seem to have a fold matching the type I need
03:55:04 <saurabhn_> are single-use variables already available in GHC (is this Linear types?)
03:55:41 <merijn> ertes-w: Pipes' Foldl combinators produce an 'm r', not a Pipe/Producer
03:57:07 <merijn> ertes-w: I'd need something halfway between 'for' and 'foldM'
03:58:18 <ertes-w> merijn: you can't use a Pipe
03:58:33 <cocreature> saurabhn_: exactly one use is linear types, at most one use are affine types. neither of those exists in ghc
03:58:41 <cocreature> people are working on linear types
03:58:44 <ertes-w> merijn: there is no way to do it with Proxy alone…  you *need* something like pipes-parse
03:59:04 <saurabhn_> cocreature: thanks
03:59:58 <merijn> ertes-w: I think it should be possible, actually. By having a proxy that returns a Proxy and joining them
04:00:19 <`Guest00000> `many a = optional a >>= \x -> case x of Nothing -> pure []; Just x -> (x:) <$> many a` what can be wrong with this definition?
04:00:37 <saurabhn_> any other way to enforce that a callback function MUST be called?
04:00:55 <merijn> oh, hmm, actually, maybe not
04:01:06 <merijn> I'd have to test this
04:07:30 <ubsan_> which ones at least one use
04:07:47 <ubsan_> relevant type systems
04:07:59 <ubsan_> those are interesting and weird and, afaik, kinda useless except for warnings :P
04:08:59 <jakub> ertes-w: let me know if i can ever vote for you :D
04:09:33 <ertes-w> merijn: the problem is that neither Pipe nor Consumer can handle EOS
04:09:43 <ubsan_> saurabhn_: you can create a function
04:10:00 <ubsan_> (Resource -> a) -> a
04:10:17 <ubsan_> which creates the resource, passes it to the function, and then calls the cleanup function
04:10:25 <ubsan_> and then returns the result of the last function
04:10:32 <ubsan_> (if I understand what you're saying
04:10:36 <ubsan_> you want)
04:10:46 <ertes-w> merijn: the only way to handle EOS is to make it explicit, e.g. by wrapping everything in Maybe, and that's not a great solution
04:12:32 <ertes-w> merijn: well, perhaps you could use a suitable underlying Alternative to handle EOS and end streams with 'empty' instead of just stopping, but that's not a great solution either
04:13:51 <merijn> ertes-w: I don't think I actually have to detect EOS, though
04:14:01 <jakub> ertes-w: a very bold question, would it make sense to build an alternative prelude that is principled and modern with respect to current technology (ghc extensions and such, and whenever someone finds more elegant/flexible way of defining something that is already in prelude)
04:14:14 <merijn> ertes-w: Because my termination actually doesn't require any of my fold's state
04:14:22 <ertes-w> merijn: what if you process by chunks of 5, but the the final chunk has only 3?
04:15:09 <merijn> jakub: There's like a billion alternative preludes already that do that
04:15:10 <ertes-w> jakub: such alternative preludes already exist
04:15:23 <merijn> jakub: You can't use them in any libraries if you want others to use your library, though
04:16:04 <ertes-w> and since other libraries can't really use them, if you use them for your program, it's much more difficult to use other libraries
04:16:33 <ertes-w> say you want to use the 'scientific' library…  boom, you're back to Num and Fractional
04:18:32 <jakub> ertes-w, merijn: nice (and shame at the same time :)), where could one find the nicer ones
04:19:52 <merijn> jakub: I think some of the banks using Haskell have custom internal preludes, but most people just use Prelude itself
04:20:05 <merijn> jakub: Turns out the pain of Num and friends isn't worth the pain of using another
04:20:53 <ertes-w> jakub: realistically we're stuck with the base classes for the time being
04:21:16 <jakub> merijn: i get the practicality, i would just like to experiment with a library that is built somewhat more in compliance with what I learned in school (regarding groups, rings etc)
04:22:16 <ertes-w> jakub: i've seen a few of those, but none that did it in a way i like
04:22:34 <ertes-w> class MultiplicativeGroup  -- if i see a class like this, i'm out
04:22:55 <`Guest00000> let's just use a new language
04:22:58 <`Guest00000> with a new prelude
04:23:11 <`Guest00000> the new prelude will be standard in the new language
04:23:17 <barrucadu> We could call it Curry
04:23:58 <jakub> ertes-w: what do you think about Meet/Join SemiLattices then :)
04:24:12 <ertes-w> jakub: ""
04:24:54 <jakub> ertes-w: ?
04:25:21 <ertes-w> jakub: let me expand that thought: "err, yeah…  they're… defined, i guess"
04:25:30 <`Guest00000> barrucadu: no, we couldn't, such language already exists
04:26:30 * hackagebot wrecker-ui 2.4.1.0 – A web interface for Wrecker, the HTTP Performance Benchmarker – https://hackage.haskell.org/package/wrecker-ui
04:26:30 <jakub> ertes-w: :), well in what sense are they the same/completely something different from what you said was off-putting
04:26:54 <merijn> ertes-w: I think I found a formulation that works with Pipe :) Gimme a bit to actually implement and see if the result actually works
04:27:07 <merijn> hmmm
04:27:27 <ertes-w> merijn: without Maybe-wrapping?
04:27:27 <jakub> ertes-w: i ask because if there is something wrong with this type of thing i want to learn, and i want to be able to circumvent it in future
04:27:45 <merijn> ertes-w: Hold on, now I'm second guessing, lemme try a second experiment
04:27:58 <ertes-w> jakub: i haven't really thought about them, because i've never needed to abstract over lattices
04:29:44 <jakub> ertes-w: i see, so could you explain why MultGroup is so bad, please :)
04:29:48 <merijn> ertes-w: Well, like I said, I think I can detect EOS by simply returning a monadic action as a result and joining that. As long as I make sure that the returned monadic action, since my handling of EOS doesn't actually care about any state or anything
04:30:37 <ertes-w> jakub: because i can't use foldMap with MultGroup
04:30:58 <ertes-w> jakub: see my Ring solution above…  it uses Monoid for both addition and multiplication
04:31:17 <ertes-w> (well, Group for addition)
04:33:32 <merijn> ertes-w: So if I wrap "await" directly, I can just do "replicateM_ n wrappedAwait; forever (await >>= doStuff)". This will handle the (up to 'n') elements in the stream, then handle each new element at a time (like I need). Now, this MIGHT terminate prematurely (for example, when there's less than 'n' incoming elements), but that doesn't matter, as long as my terminating action gets run, because that one 
04:33:38 <merijn> takes care of draining results and doesn't depend on whether the replicateM actually finished and made it to the individual element loop
04:33:57 <merijn> ertes-w: None of this actually needs to know whether the upstream ended or not
04:34:19 <merijn> ertes-w: I'm fairly confident it *should* work, but I'll have to try and implement it to find out
04:34:48 <merijn> ertes-w: (unless you see any obvious flaws?)
04:35:57 <ertes-w> merijn: that's exactly what i mean: Pipe doesn't support terminating actions
04:36:20 <ertes-w> you need to hack your way around that limitation by using a suitable underlying monad like ResourceT or Codensity
04:36:50 <merijn> ertes-w: How would a Proxy that returns a (Proxy ...) and then calling "join" not work?
04:37:25 <ertes-w> merijn: how *would* it work?  in the end you want to have a regular Pipe, don't you?
04:37:42 <ertes-w> something like: Pipe A B M ()
04:38:27 <ertes-w> returning a proxy is a means to *delimit* a stream, not a means to handle failure of 'await'
04:38:48 <merijn> I don't understand what you mean by that
04:39:38 <ertes-w> Pipe a b m (Pipe a b m r)  -- this is a delimited pipe with one "border"
04:39:54 <ertes-w> FreeT (Pipe a b m) m r  -- this is a delimited pipe with arbitrarily many "borders"
04:40:36 <merijn> ertes-w: "join (undefined :: Pipe a b m (Pipe a b m r))" Will give me a "Pipe a b m r" with the returned "Pipe a b m r" running after the initial one, yes?
04:40:49 <ertes-w> merijn: yes
04:41:01 <merijn> i.e., when the initial one has exhausted upstream
04:41:13 <ertes-w> merijn: no
04:41:19 <merijn> ertes-w: Why not?
04:42:01 <ertes-w> if p consumes 5, then (join p) consumes those 5 and then whatever the resulting pipe consumes
04:42:18 <ertes-w> if p does not receive 5, then the resulting pipe never gets to run
04:42:34 <ertes-w> 'await' kills the entire pipeline
04:42:50 <merijn> ertes-w: Right, but in my case p consume all input and the result consumes nothing
04:43:06 <ertes-w> merijn: how does it consume the whole input?
04:43:27 <ertes-w> there is no way to express "get all inputs" in a Pipe
04:43:42 <merijn> ertes-w: "forever (await >>= f)"
04:43:57 <ertes-w> merijn: then the resulting pipe is meaningless
04:44:09 <merijn> Well, not forever I suppose
04:44:16 <jakub> ertes-w: looking back at your example with rings, isn't it too much to require Ring for addition? wouldn't it be better to use + for (Group (Add a)) and * for (Group (Mul a))?
04:44:21 <ertes-w> merijn: if not 'forever', then what?
04:44:34 <ertes-w> how do you get *all* inputs and *then* do something afterward with a Pipe?
04:45:32 <ertes-w> jakub: unfortunately (Add a ≠ a)
04:45:58 <ertes-w> jakub: you can use (Add a), but it gets awkward, because you need to convert to (Mul a) for multiplication
04:46:27 <ertes-w> jakub: and that's fine…  "addition" is really a ring concept, not a monoid concept
04:46:32 <ertes-w> monoids only know "composition"
04:52:14 <jakub> ertes-w: are you sure? i can imagine addition being used in contexts where additive inverse is not a thing and yet ring requires one, doesn't it?
04:52:59 <geekosaur> you can't *designate* one as addition until you reach rings
04:53:00 <jakub> ertes-w: addition of natural numbers is still addition, altough you might call it composition
04:53:53 <ertes-w> jakub: i skipped semirings in my example above
04:54:19 <ertes-w> jakub: unless you find even Monoid too strong, addition is a semiring concept
04:55:06 <ertes-w> jakub: composition only becomes "addition" in relation to another operation called "multiplication"
04:55:39 <ertes-w> jakub: what makes addition "addition" is the distributive law
04:55:51 <jakub> ertes-w: yeah
04:57:18 <jakub> ertes-w: but a different point of view is that addition does not need multiplication for its definition, and thus can exist on its own (you know you could find multiplication but maybe you just don't care)
04:57:42 <ertes-w> jakub: that's "composition"…  you're just abusing the word "addition" =)
04:58:12 <ertes-w> jakub: if it's not related to another operation, why not call it "multiplication"?
04:59:12 <geekosaur> I wuold put that as you have a composition that you can think of as addition, but you can't prove it is such without a semiring relating it to another composition
04:59:14 <jakub> ertes-w: well it is a product or tensor or what the hell the right word is
05:00:39 <jakub> ertes-w: the problem is, we both refer to the same function (computes the same thing in exactly the same way) only I dropped one additional function out of context (because it is not referred to from anywhere else) and you argue that that makes my function suddenly change its name
05:01:21 <ertes-w> jakub: there is a common confusion in group theory that i observe a lot in the context of cryptography: the diffie-hellman key exchange scheme works over arbitrary groups, but for whatever reason it's called "multiplication" in traditional modular groups, but "addition" in elliptic curve groups…  then you have elliptic curve "multiplication", which is really group exponentiation
05:01:40 <geekosaur> you two are talking about different contexts. ertes-w is talking formal mathematics, you're talking informal usage
05:01:41 <jakub> ertes-w: take 3 * 5 + 2... here we see addition in its natural habitat, 2 + 7 the habitat has changed sligthly but you know... its still the same beast
05:02:11 <ertes-w> jakub: this is entirely just an abuse of terminology, and it leads to a lot of confusion…  i would call neither "addition" or "multiplication"…  they are both "composition"
05:02:52 <ertes-w> jakub: again, there is no reason not to call (+) "multiplication" *before* you reach the distributive law
05:03:19 <jakub> geekosaur: i understand the formal math, I talk from a point of view of language, signatures, and model theory
05:03:20 <ertes-w> my point is: let's not allow those terms at all, before you reach it
05:03:58 <ertes-w> overloading the term "addition" is just a recipe for exactly the kind of confusion i mentioned above
05:04:29 <jakub> ertes-w: you are not overloading anything if the same label is realized by the same means in all contexts
05:05:21 <ertes-w> jakub: answer the question: *why* do you call (+) over Integer "addition"?
05:07:44 <jakub> ertes-w: the answer you would like to hear, because of the naming conventions arising from the definition of semiring, the more honest answer, because of the history of the word addition that latter lead to designate a concept of a semiring but initially always described a specific function (operation)
05:08:25 <ertes-w> jakub: ok, would it be accurate to say that (+) is the "addition" of the (Integer, (+)) monoid?
05:09:32 <jakub> ertes-w: no, monoid does not have the concept of addition :)
05:10:03 <ertes-w> jakub: what does have that concept?
05:12:14 <jakub> ertes-w: semiring, but not exclusively (that is probably what i am trying to argue), addition is what it is no matter the multiplication, think of an arbitrary algebra, you still can call your operation addition and it can coincide with an addition of integers which would justify your choice of the name, it is customary to call semiring + an addition, but it is not patented by semiring
05:12:27 <ertes-w> the problem with history and conventions is that they are mostly from a time when there was indeed just one particular function called "addition"
05:12:47 <ertes-w> but we're abstracting away from that, and then it becomes very important to use precise terminology
05:13:56 <ertes-w> yes, (+) is addition in one semiring, but it might be multiplication in another…  without semirings, (+) is just an associative function with an identity and inverses, and we have a precise term for that: it's a group operation
05:14:52 <merijn> ertes-w: Hmm, you're right that join on Pipe doesn't work, although I can get similar functionality without pipes-parse. Now I just need to figure out how to make it fit a nice API
05:15:13 <jakub> ertes-w: i would not say it needs the inverses but we already discussed that
05:15:19 <ertes-w> merijn: it's one of the reasons why i stopped using pipes =)
05:15:52 <ertes-w> jakub: it doesn't necessarily need them, but it does have them…  (+) on Integer is a group, and therefore it's also a Monoid and a Semigroup and a Magma and …
05:16:12 <jakub> ertes-w: + on Nat
05:16:35 <merijn> ertes-w: As soon as you compose the pipe with a Producer you get a Producer and then simply running a Producer after the "Producer >-> Pipe" works, but I'm not sure I can easily capture that into some non-awful API
05:16:36 <ertes-w> jakub: that's a different function (in type theory)
05:17:15 <jakub> ertes-w: of course it's different, so is + on complex numbers
05:17:21 <ertes-w> merijn: not sure i understand
05:19:12 <jakub> ertes-w: but all share a lot in common, which justifies the use of a same abstraction ... the abstract concept of addition
05:19:25 <merijn> ertes-w: If my pipe is 'foo' and I have a producer 'prod' that supplies it and my termination action is 'bar', then "(prod >-> foo) >> bar" gets met the desired behaviour. i.e. "foo" consumes and handles all output and my finaliser takes care of the wrap-up
05:20:06 <ertes-w> jakub: again: my suggestion is not to call it addition, but composition, unless you're in the context of a semiring
05:20:30 <merijn> ertes-w: Now I just need to figure out how make that more usable. Whether that is taking a producer as argument and returning this composition or something else
05:21:11 <ertes-w> merijn: unfortunately that's not compatible with the FoldM variant
05:21:38 <ertes-w> merijn: notice that the final action needs the current state
05:21:39 <merijn> ertes-w: Well yes, that was what I was saying :p
05:22:01 <merijn> ertes-w: Which is why the FoldM doesn't work for me
05:22:06 <ertes-w> merijn: personally i wouldn't bother…  pipes users are used to having to use pipes-parse to handle exhaustion and leftovers
05:22:38 <ertes-w> the problem with your approach is that 'foo' and 'bar' are disconnected, and their only means to communicate is via effects of the underlying monad
05:22:53 <merijn> ertes-w: Why is that a problem?
05:23:48 <merijn> ertes-w: That's all I need
05:23:48 <ertes-w> merijn: it's a failure of Proxy to capture a very simply communication pattern…  FoldM is the proper solution, it's just that Proxy is not flexible enough on its own to support it
05:24:00 <d3xter> hey guys, just started to tinker with haskell. I've written a simple programm that prints out a string and then reads the response from the console. strange thing is, a "putStr" happens AFTER readLn, but "putStrLn" prints BEFORE readLn. what am I missing?
05:24:09 <ertes-w> *simple
05:24:12 <merijn> ertes-w: I disagree FoldM is the proper solution, because it's not what I want
05:24:27 <merijn> d3xter: Line buffering on stdout
05:24:44 <merijn> d3xter: That's the default in almost all programming languages (on *nix anyway)
05:24:58 <merijn> d3xter: You need to either flush stdout or change the buffering
05:25:11 <ertes-w> d3xter: see 'hFlush' and 'hSetBuffering' from System.IO
05:25:14 <jakub> ertes-w: fair enough, i just give you the point of view of a signature (fixes symbols) and structure (assigns semantics / implementation), I say it is better for understandability to use same symbols in different signatures as long as the structure assigns the same semantics to that symbol... it is imho much more closer to importing additional symbols once you decide you need them (as in import in 
05:25:20 <jakub> Haskell), imagine you had to rename you addition to composition unless you also imported multiplication :D
05:25:28 <d3xter> merijn, ertes-w: thanks guys :)
05:25:42 <ertes-w> jakub: i get your point, i just don't think a haskell prelude should be designed that way
05:25:47 <merijn> ertes-w: I'm not to concerned with the failure of pipes to capture this abstraction as I'm with "how to get it workable"
05:26:19 <ertes-w> jakub: and there is a very simple reason for that: i can't use foldMap with MultGroup
05:26:48 <jakub> ertes-w: i probably agree with that, altough I guess i'd be pissed to name my plain old addition "composition" just because i am lazy to define multiplication too :)
05:26:57 <jakub> ertes-w: :D
05:27:41 <ertes-w> jakub: no, you do call it addition, but not at the point where you're implementing the Monoid instance, but later, when you implement Semiring/Ring/Field
05:27:46 <jakub> ertes-w: thanks for this discussion, don't get me wrong, I agree with your stand point, I just am not sure it is the ideal one (maybe better than what I said, but has its limitations)
05:29:40 <jakub> ertes-w: I meant I was declaring a type that generalized numbers (which ever type) and I needed addition, couldn't care less for multiplication and yet had to call it composition just because of that
05:29:44 <ertes-w> jakub: well, my viewpoint is backed by practical concerns: 1. the confusion makes learning difficult and notation inconsistent (e.g. multiplicative groups vs. elliptic curves), 2. i can't use foldMap with MultGroup =)
05:31:25 <ertes-w> jakub: that's because it *was* composition…  if you want to name it addition, you *should* have to define multiplication
05:31:50 <jakub> ertes-w: I wholeheartedly agree, altough naming is comporomised anyway (Add, Mul) are rather arbitrary labels, aren't they
05:32:16 <ertes-w> jakub: Additive and Multiplicative are only helper classes for Ring…  you never use them directly
05:32:24 <ertes-w> consider this a shortcoming of haskell
05:32:36 <jakub> ertes-w: i do, i do
05:33:01 <ertes-w> but they don't compromise my ability to use foldMap with both (+) and (*)
05:38:36 <jakub> ertes-w: thanks for the discussion, i hope addition doesn't get generalized even more very soon, else we would have to promote the name to a completely new concept and find a yet another renaming for + in semiring :) :D
05:39:15 <ertes-w> jakub: there are categorical notions of ring-like structures =)
05:39:35 <Ulrar> hi, I have a Vector that I want to map and convert to a list. I can do both separatly, but is there an existing function to do both at the same time ? Something like mapToList. Seems a bit silly to go through the whole list twice
05:40:03 <ertes-w> jakub: https://ncatlab.org/nlab/show/2-rig
05:41:02 <jakub> Ulrar: why'd you go over it twice? if the conversion happens lazily then as soon as you start evaluating the resulting list you start pulling values from the vector and applying the function to them
05:41:38 <Ulrar> Oh, right
05:41:54 <Ulrar> Didn't think about that
05:42:08 <Ulrar> So Vector.map then Vector.toList should be fine
05:42:25 <ertes-w> Ulrar: you should probably map over the list
05:42:57 <ertes-w> although the vector map should fuse with the conversion, mapping over the list is a guarantee that you don't get a copy first
05:43:30 <Ulrar> So toList then map, allright
05:43:36 <Ulrar> Thanks !
05:45:36 <cocreature> Ulrar: it can also be useful to look at the output of -ddump-simpl when compiling with optimizations to see if GHC generates the code you expect. e.g. for mapToList f = map f . Vector.toList you get http://lpaste.net/358579. if you squint a bit you can see what it’s doing
05:46:52 <Ulrar> Yeah that looks easy to read
05:47:01 <cocreature> for some definition of easy :)
05:47:19 <Ulrar> Interesting to know about anyway
05:47:27 <jakub> cocreature: i find your definition of "easy" rather non-standard
05:47:29 <cocreature> but you see that it’s just a single loop with an integer that is compared to the length
05:47:43 <Ulrar> Not that I really need to worry about optimization for this, but might as well
05:48:46 <cocreature> jakub: that’s your fault not mine :P
05:50:29 <jakub> cocreature: i never meant to suggest otherwise :)
06:04:04 <merijn> Is there a sorta "trivial" timer somewhere? i.e. "IO a -> IO (a, Time)"?
06:04:43 <merijn> I don't care about criterion fancy graphs and accuracy, I just want rough ballpark numbers after 1 run
06:06:07 <opqdonut> merijn: you know of ghci's :set +s?
06:07:28 <merijn> opqdonut: No, but I'd prefer something I can run inside a test anyway
06:09:49 <ertes-w> merijn: i'd use the 'clock' library with one of the monotonic clocks
06:10:05 <ertes-w> it doesn't offer that function, but it's a three-liner
06:14:17 <ertes-w> timeAction c = do tv <- newMVar 0; threads <- for [1..1000000] (\d -> forkIO (threadDelay d >> writeMVar tv d)); liftA2 (,) c (readMVar tv) <* traverse_ killThread threads
06:26:43 * hackagebot userid 0.1.3.1 – The UserId type and useful instances for web development – https://hackage.haskell.org/package/userid
06:26:43 * hackagebot syb-with-class 0.6.1.8 – Scrap Your Boilerplate With Class – https://hackage.haskell.org/package/syb-with-class
06:44:12 <Psybur> Is there a better way to convert a list of Double to a list of CDouble than this? map (fromRational . toRational)
06:44:56 <merijn> realToFrac, maybe?
06:44:59 <merijn> :t realToFrac
06:45:00 <cocreature> coerce
06:45:00 <lambdabot> (Fractional b, Real a) => a -> b
06:45:16 <cocreature> :t coerce :: [Double] -> [CDouble]
06:45:17 <lambdabot> error:
06:45:17 <lambdabot>     Not in scope: type constructor or class ‘CDouble’
06:45:17 <lambdabot>     Perhaps you meant ‘Double’ (imported from Prelude)
06:45:28 <cocreature> @let import Foreign.C.Types
06:45:29 <lambdabot>  Defined.
06:45:31 <cocreature> :t coerce :: [Double] -> [CDouble]
06:45:33 <lambdabot> error:
06:45:33 <lambdabot>     • Variable not in scope: coerce :: [Double] -> [CDouble]
06:45:33 <lambdabot>     • Perhaps you meant ‘coerced’ (imported from Control.Lens)
06:45:39 <cocreature> @let import Data.Coerce
06:45:40 <cocreature> :t coerce :: [Double] -> [CDouble]
06:45:41 <lambdabot>  .L.hs:81:1: error:
06:45:41 <lambdabot>      Data.Coerce: Can't be safely imported!
06:45:41 <lambdabot>      The module itself isn't safe.
06:45:42 <lambdabot> error:
06:45:42 <lambdabot>     • Variable not in scope: coerce :: [Double] -> [CDouble]
06:45:43 <lambdabot>     • Perhaps you meant ‘coerced’ (imported from Control.Lens)
06:45:45 <cocreature> well I give up
06:45:59 <cocreature> but that should work and is definitely the fastest option (i.e. it has no runtime cost)
06:46:57 <Psybur> > import qualified Data.Coerce as DC
06:46:59 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
06:47:04 <Psybur> :D
06:47:17 <cocreature> just try it in your local ghci :)
06:47:49 <Psybur> Yeah that works
06:47:50 <Psybur> thanks
06:51:20 <michalrus> Hey, how can I automatically document websockets? For normal REST there’s wonderful servant-swagger, but websockets?
06:51:58 <ertes-w> :t Data.Coerce.coerce :: [Double] -> [Foreign.C.Types.CDouble]
06:51:59 <lambdabot> [Double] -> [CDouble]
06:56:23 <maerwald> can someone give me a pointer what lens stuff to use wrt this problem http://git.io/v5hfV it seems like I need something like 'at' except for my own type
07:03:06 <ertes-w> maerwald: use (Map String (Set Int)) instead of [Flag], then use M.unionWith S.union
07:03:28 <ertes-w> :t M.unionWith S.union
07:03:30 <lambdabot> (Ord a, Ord k) => M.Map k (S.Set a) -> M.Map k (S.Set a) -> M.Map k (S.Set a)
07:03:48 <ertes-w> maerwald: or M.insertWith S.union
07:03:53 <ertes-w> :t M.insertWith S.union
07:03:54 <lambdabot> (Ord a, Ord k) => k -> S.Set a -> M.Map k (S.Set a) -> M.Map k (S.Set a)
07:04:07 <maerwald> can't I have that without breaking my types apart?
07:04:37 <ertes-w> of course you can, but it's more work and less elegant
07:04:53 <Psybur> maerwald, you could convert back and forth :D?
07:04:57 <maerwald> awful!
07:05:11 <maerwald> I wonder if some traversable-style thing might help
07:06:05 <ertes-w> you can construct a lens into a flags existence
07:06:27 <ertes-w> flag :: String -> Int -> Lens' [Flag] Bool
07:07:02 <ertes-w> however, it would only be a proper lens, if you view the list of deps modulo duplicates and empty lists
07:07:09 <ertes-w> you should really just use Map of Set
07:08:32 <maerwald> not an option, it's an expressive type for a reason and will be used further down the callstack, I'd basically be converting back and forth
07:08:44 <shapr> YOW! EXCITEMENT!
07:09:35 <ertes-w> maerwald: if it's not an option, my approach would be to make it an option =)
07:10:10 <maerwald> I want lens to help me, not the other way around :>
07:13:58 <ertes-w> you can still construct the existence lens
07:14:15 <ertes-w> but i question the usefulness
07:15:22 <maerwald> and there I thought this is a simple use case
07:26:35 <c_wraith> :t has
07:26:36 <lambdabot> Getting Any s a -> s -> Bool
07:26:53 <c_wraith> maerwald: would that work for you?  It should work with any Traversal or Fold
07:27:40 <maerwald> I'm just writing the function manually without lenses, seems easier
07:28:41 * hackagebot mysql-simple 0.4.3 – A mid-level MySQL client library. – https://hackage.haskell.org/package/mysql-simple
07:28:57 <ertes-w> > "abx" ^. has (traverse . filtered (== 'x'))
07:28:59 <lambdabot>  error:
07:28:59 <lambdabot>      • Couldn't match type ‘Bool’ with ‘[Char] -> Const a [Char]’
07:28:59 <lambdabot>        Expected type: Getting a [Char] a
07:29:08 <ertes-w> > has (traverse . filtered (== 'x')) "abx"
07:29:10 <lambdabot>  True
07:29:13 <ertes-w> > has (traverse . filtered (== 'x')) "ab"
07:29:15 <lambdabot>  False
07:29:32 <ertes-w> i guess that might be useful
07:30:12 <ertes-w> > has (traverse . _1 . filtered (== "name1")) [("name1", [1,2,3]), ("name2", [4,5])]
07:30:15 <lambdabot>  True
07:34:17 <ocharles> kosmikus, kosmikus_: Could Generics.SOP have a `shapeProxy :: SListI xs => proxy xs -> Shape xs`? I want this so I can `hcollapse (hliftA ... ctor)`, where `ctor :: ConstructorInfo xs`
07:34:48 <ocharles> I've pattern matched on `ctor` and I know it's a `Constructor{}`, so I have `SListI xs` in scope
07:37:56 <ocharles> oh, actually, I might not have thought this through, as you can't collapse a Shape. Hm
07:49:06 <boothead> Can anyone answer a quick question on kind k vs kind *?
07:50:04 <JuanDaugherty> ur supposed to just ask
07:50:21 <boothead> specifally the :> thing from servant has kind: (:>) :: k1 -> k -> *
07:51:00 <boothead> Now I want the second argument but I have a bit of code that's complaining it's of kind k rather than *
07:51:05 <maerwald> are there "lens" libraries that work better with lists?
07:51:30 <maerwald> e.g. mutating an item in the list based on a predicate
07:51:42 <c_wraith> lens does that pretty well.
07:51:57 <boothead> so I had to write a type family  that does this:  type family Chan (chan :: *) :: * where Chan (chan :> a) = a
07:51:58 <maerwald> haven't seen a solution to my use case though
07:52:02 <maerwald> so I suspect it doesn't
07:52:02 <boothead> I feel like I'm missing something
07:52:30 <ertes-w> > (traverse . filtered even *~ 10) [1,2,3,4,5]
07:52:32 <lambdabot>  [1,20,3,40,5]
07:52:38 <boothead> I also don't really understand how the type family is managing to change to k to a * here
07:52:40 <ertes-w> maerwald: ^
07:52:59 <boothead> Anything I can read? I'm not even really sure what to search for
07:53:52 <c_wraith> maerwald: that seems a bit underspecified.  what do you want if fdep is already in the list?
07:54:05 <lyxia> boothead: can you paste the offending code and the type error
07:54:21 <maerwald> c_wraith: what do you mean?
07:54:37 <maerwald> deduplication is not the job of those functions
07:55:00 <maerwald> just the flag names are supposed to not have duplicates
07:55:15 <maerwald> flags are unique
07:55:20 <ertes-w> maerwald: optics don't really support the notion of traversing into something and adding it, if it doesn't exist
07:55:41 <ertes-w> maerwald: so you need two separate steps:  first check, then traverse, then check again, then traverse again
07:56:01 <ertes-w> (two times two steps i guess)
07:56:14 <kosmikus> ocharles: what do you need Shape for?
07:56:24 <ertes-w> maerwald: the latter two steps you do while zoomed in into the dep list
07:56:34 <c_wraith> maerwald: If that's the most common operation, wouldn't you rather have a Map anyway?
07:57:18 <ocharles> kosmikus: I'm not sure I do. But basically, I'm trying to turn a DatatypeInfo into a pretty printed doc to generate Elm code. The DatatypeInfo gives me the name of a constructor, but it doesn't give me any handle on the fields (unless it's a record). The fields are of course the elements in the list parameterizing the whole DatatypeInfo, and I do have SListI instances available
07:57:21 <boothead> lyxia: https://gist.github.com/boothead/87656bd13f277e19654cef8374e7a16b is the gist of it. The offending line is 17. Doesn't with without Chan
07:57:46 <boothead> *Doesn't work without I mean
07:58:52 <ocharles> for example:: `printDataType (ADT _ dtName (ctor@(Constructor ctorName) :* Nil)) = "type" <+> pretty dtName <+> equals <+> pretty ctorName <+> ???` <-- it's this '???' that I'm working on, which would generally come out of the type
07:59:22 <erisco> I want to do IPC … what is a good Haskell choice? Sockets?
07:59:51 <merijn> erisco: Just pipes?
07:59:54 <ertes-w> erisco: on the lowest level: sockets, stdin/stdout, fifos, …
08:00:08 <kosmikus> ocharles: so that part would contain the field labels and their types?
08:00:26 <kosmikus> ocharles: oh no, there aren't any field labels in the "Contructor" case
08:00:27 <ocharles> that `???` I thought would be  some variation of `sep  $ hcollapse (hcpure (K . prettyPrintTypeName) ctor)`
08:00:28 <boothead> actually - I just removedthe Chan and it's still working... Odd ignore me lyxia, but I would like to know where I can go to understand more about this..
08:00:40 <ocharles> kosmikus: right
08:00:43 <erisco> I asked a stupid question… how about this… I want to do IPC and not think about it much
08:00:55 <johnw> erisco: I wrote ipcvar for that purpose
08:00:57 <ocharles> I have no concrete value at hand to transform, it's implied in the type
08:01:07 <ertes-w> erisco: sockets + aeson, stdin/stdout + aeson, fifos + aeson, …
08:01:12 <johnw> it's like a TVar that you write in one process and read in another
08:01:26 <kosmikus> ocharles: right, so do you have a function turning a proxy into a string representing the type?
08:01:27 <erisco> johnw, thanks I'll take a look
08:01:39 <ertes-w> erisco: you will have to think about it much anyway, regardless of how you do it, at least if you want something robust
08:01:58 <ocharles> kosmikus: I have `class ElmType a where elmType :: proxy a -> Type`, and `pretty :: Type -> Doc ()`
08:02:10 <ertes-w> erisco: as soon as you cross process borders all kinds of things can go wrong, and you need to be prepared to handle that
08:02:25 <ocharles> boothead: can you paste some code with an error message?
08:02:35 <ocharles> it's easier to see where GHC is complaining
08:02:39 <erisco> ertes-w, this is a prototype, so errors being crashes is fine
08:02:59 <kosmikus> ocharles: right, then you probably want to call cpure for ElmType with (pretty . elmType ...) in order to either generate an NP of type names (for one constructor) or even a POP of type names (for all constructors)
08:03:23 <lyxia> boothead: what is the error
08:03:26 <kosmikus> ocharles: and then merge that with the constructor names coming from the metadata by zipping the two structures together
08:03:31 <lyxia> boothead: the full error message
08:03:49 <ocharles> yea, that was my plan. A kind of `asShapeOf :: f xs -> g xs -> f xs` const might be useful
08:03:56 <ocharles> oh, hadn't considered zipping, I'll try that
08:04:19 <erisco> johnw, I suspect this won't work on Windows
08:04:48 <johnw> erisco: I suspect you're right; unknown constraint :)
08:04:54 <boothead> I can't seem to unfix it now :-)
08:05:00 <johnw> erisco: it wouldn't be hard to add support, though
08:05:00 <kosmikus> ocharles: ok, but to call (h)cpure on a single constructor, you only need SListI for the current constructor, and you should have that; if you call it on the whole datatype, you should have it as well. so I don't see how Shape comes into it.
08:05:13 <johnw> erisco: the "File" method is pretty generic
08:05:19 <ertes-w> johnw, erisco: also ipcvar doesn't seem to support messaging, which is probably the most common form of IPC
08:05:26 <johnw> correct
08:05:27 <erisco> eh maybe, but that requires thinking… :P
08:05:32 <ocharles> kosmikus: shape was a red herring
08:05:46 <johnw> it was meant to be "the dumbest thing that will work" for simple use cases
08:06:18 <ertes-w> johnw: stdin/stdout + aeson/binary is even dumber and simpler and does support messaging =)
08:06:23 <lyxia> boothead: That may be why I can't guess what it was :)
08:06:27 <kosmikus> ocharles: ok. good luck then. if you still run into problems, feel free to point me at the actual code and I can try to fix it for you. what you want definitely sounds doable.
08:07:16 <johnw> ertes-w: what do you mean by messaging, exactly?
08:07:29 <ocharles> kosmikus: I think it's the Newtype constructor that is giving me the most problem, because it doesn't mention NP at all. That is probably why I started looking at Shape
08:07:45 <ocharles> but let me play more and i'll come back to you with code if I get stuck again
08:08:03 <ertes-w> johnw: blocking on data
08:08:11 <ertes-w> like readChan
08:08:26 <johnw> ertes-w: hmm.. since ipcvar just uses fd + binary, it could be added
08:08:29 <ocharles> I'll probably just turn that single `ConstructoInfo '[x]` into a one-element `NP` and zip that
08:08:49 <kosmikus> ocharles: yes, exactly. in the Newtype case, you know the (trivial) shape of the NP completely.
08:08:50 <johnw> (well, for it's "file" backend, that is)
08:09:09 <ertes-w> johnw: you could, but then you need to watch the file
08:09:53 <johnw> ertes-w: not if the file is a named pipe
08:10:59 <ertes-w> johnw: then how does readIpcVar work?  if called twice in a row, shouldn't it return the same value twice?
08:11:19 <ertes-w> *readIPCVar
08:11:22 <johnw> ertes-w: right now, I believe so.  I think the idea was to add take/put in future
08:11:34 <johnw> I was trying to mimic the use of IORef as closely as possible
08:12:04 <johnw> gn
08:12:21 <ertes-w> yeah, you could turn this into a fully fledged MVar, but you still couldn't use named pipes, unless you want to have a separate IPCChan
08:12:47 <johnw> IPCChan would be the better way to go, I think
08:13:14 <johnw> opening up backends like rabbitmq, etc., to reduce such messaging to a super simple interface
08:14:04 <ertes-w> note that network-transport is solving a similar problem
08:15:16 <ertes-w> BTW, i'd still prefer JSON over Binary for two reasons: with JSON you can have fault tolerance (protocol mismatches), and you can (easily) do netcat-debugging
08:15:19 <texasmynsted> would somebody please show me an example of reading meta data from a pandoc doc?  I could make a doc like this 'let doc = readMarkdown def "% Foo"'
08:15:29 <texasmynsted> So that would set the title to Foo
08:16:00 <texasmynsted> and doc would be 
08:16:01 <texasmynsted> Right (Pandoc (Meta {unMeta = fromList [("title",MetaInlines [Str "Foo"])]}) [])
08:17:07 <ertes-w> texasmynsted: https://hackage.haskell.org/package/pandoc-types-1.17.1/docs/Text-Pandoc-Definition.html
08:17:37 <ertes-w> texasmynsted: i.e. pattern-match on Pandoc, unMeta the Meta, then use Data.Map.Strict
08:19:42 <texasmynsted> what does unMeta the meta mean?
08:20:11 <c_wraith> texasmynsted: that's how derived Show instances for records look
08:20:31 <c_wraith> texasmynsted: Meta is the constructor of some type, unMeta is the name of a field in it.
08:20:58 <maerwald> lol, i used ST now
08:21:59 <erisco> this Network.Transport ecosystem looks neato burrito
08:22:10 <c_wraith> texasmynsted: the way records work, you can use the field name as an accessor.  Since there's only the one field name, unMeta, you can get the entire contents out by using it.
08:23:52 <maerwald> c_wraith: https://git.io/v5h3N :>
08:23:58 <maerwald> so simple without lens... or not
08:28:42 <Psybur> maerwald, go p :D
08:31:01 <maerwald> go imperative programming
08:32:45 <maerwald> f**k abstraction, move on, lol
08:33:04 <maerwald> and pretend this thing never happened
08:33:36 <maerwald> will write a vim plugin that automatically hides code blocks I don't ever want to see again
08:33:45 <maerwald> so I can pretend my codebase is clean
08:34:26 <texasmynsted> I got as far as this let foo (Right (Pandoc (Meta x) ys)) = x
08:34:59 <texasmynsted> but that still leaves me with fromList [("title",MetaInlines [Str "Foo"])]
08:35:04 <ertes-w> erisco: i find it more complicated than necessary, but it's a good start
08:35:47 <ertes-w> texasmynsted: what's the type of 'x'?
08:36:06 <erisco> ertes-w, for networking it looks rather straightforward
08:36:23 <erisco> I am used to seeing a more jumbled mess that I can't even squint at
08:36:31 <texasmynsted> Data.Map.Base.Map String MetaValue ?
08:36:48 <erisco> but JSON is just garbo… can't do numbers right… need a different format
08:36:49 <ertes-w> erisco: try to figure out what happens when a connection is lost, whether and when it's reestablished and whether and when messages that got lost are delivered
08:37:02 <ertes-w> erisco: from the documentation that is
08:37:21 <ertes-w> texasmynsted: yes…  that should help you
08:38:22 <texasmynsted> heheh yeah
08:38:34 <texasmynsted> I should have saw that with "fromList"
08:38:41 <texasmynsted> thanks
08:39:31 <erisco> ertes-w, I am looking but documentation doesn't seem to exist… but that is par for the course…
08:39:45 <erisco> if you know of a better library I am all ears
08:40:47 <ocharles> kosmikus: ok, now I am stuck. https://gist.github.com/ocharles/a57eca09fc47caf692a01096559a002a. Essentially when I use `hcliftA` on the fields of a single record constructor, I seem to have lost my ElmType constraint, even though I required it with All2
08:41:24 <ocharles> line 41 in that paste is where it becomes problematic
08:44:06 <ertes-w> erisco: i don't think there is one right now
08:44:19 <tdammers> JSON can do numbers fine, the problem is it is underspecified, so not all implementations agree on how to deal with numbers
08:44:40 <ertes-w> erisco: well, failure is documented, but it's not exactly transparent, and i find it very difficult to extract actual semantics from it
08:46:47 <erisco> ertes-w, I am clicking through looking for where the docs/manual is but there is where it ends up http://haskell-distributed.github.io/tutorials/2.nt_tutorial.html
08:47:11 <ertes-w> erisco: the haddocks document failure modes
08:49:11 <ertes-w> erisco: BTW, actually there is one more way to do IPC that i use fairly often: sqlite =)
08:49:21 <erisco> oh lordy lord
08:50:12 <erisco> IPC with a non-concurrent RDBMS
08:51:41 <monochrom> So Byzantine. Much fog of war.
08:56:00 <ertes-w> erisco: sqlite is concurrent, especially with WAL, but it has one flaw that's often annoying: it won't block, it will fail and you have to retry
08:56:21 <erisco> the drivers I used for it certainly were not
08:56:35 <ertes-w> "drivers"?
08:56:46 <erisco> yes
08:57:06 <ertes-w> it's just a library…  i'd hardly call it an "RDBMS"
08:57:53 <erisco> well we can argue about words or you can believe me that the libraries I used for sqlite did not support concurrency ;)
08:58:56 <c_wraith> I think concurrency support in sqlite is a relatively new thing
08:58:57 <ertes-w> erisco: there is only one official sqlite library…  you can compile it with thread safety disabled, but that's not the default
08:59:20 <c_wraith> Though for a library as old as sqlite, "relatively new" means "sometime in the last 15 years"
08:59:39 * Clint doesn't believe that sqlite supports any features
09:00:22 <texasmynsted> sorry what I have tried has not worked... ertes-w could you show me another hint?
09:00:36 <ertes-w> erisco: in any case, at least for the last few years (i.e. since i became a heavy user) sqlite is concurrent
09:00:57 <erisco> okay, good to know
09:01:30 <ertes-w> texasmynsted: you can use 'lookup' from Data.Map.Strict to get values from a Map
09:01:52 <texasmynsted> that did not work
09:02:03 <ertes-w> texasmynsted: note that meta values are not strings, but a richer structure called MetaValue…  you need to pattern-match on it
09:02:34 <ertes-w> texasmynsted: (i believe there is also helper function somewhere in pandoc or pandoc-types that lets you convert MetaValue to a string)
09:02:55 <texasmynsted> I could not construct MetaValue
09:02:57 <texasmynsted> let foo (Right (Pandoc (Meta x) ys)) = lookup "title" x
09:03:17 <ertes-w> texasmynsted: the way you write it i suspect that's the wrong 'lookup' function
09:03:26 <ertes-w> texasmynsted: import qualified Data.Map.Strict as M
09:03:31 <ertes-w> texasmynsted: then use M.lookup
09:04:17 <texasmynsted> ok
09:05:38 <texasmynsted> That was closer, so now I need to try to pattern match and construct a MetaValue from a string
09:06:05 <ertes-w> texasmynsted: not the other way around?  i thought you want to *get* the title rather than *setting* it
09:06:45 <texasmynsted> I do 
09:06:54 <texasmynsted> I thought I would have to pattern match on in
09:07:06 <texasmynsted> so if I do this
09:07:34 <texasmynsted> let foo (Right (Pandoc (Meta x) ys)) = M.lookup "title" x
09:07:52 <texasmynsted> I get Just (MetaInlines [Str "Foo"])
09:08:52 <ertes-w> texasmynsted: now you can do:  … = case M.lookup "title" x of Nothing -> _nothingCase; Just mv -> _justCase
09:09:27 <texasmynsted> that would give me a MetaInlines [Str "Foo"] right?
09:09:38 <texasmynsted> rather than a "Foo"?
09:10:04 * texasmynsted trying
09:10:06 <ertes-w> texasmynsted: not necessarily that, but 'mv' is a MetaValue you need to pattern-match on
09:11:14 <ertes-w> texasmynsted: note that this will probably not lead to a solution, because MetaValue is a recursive type…  you should write a separate helper function of type (MetaValue -> String) that does the conversion for you
09:12:20 <ertes-w> texasmynsted: on what i estimate your haskell level to be this is not an easy function to write, but it will be a good recursion exercise
09:13:09 <texasmynsted> lol 
09:13:12 <texasmynsted> yeah
09:13:46 <texasmynsted> So this seems over complicated for something that is likely common for reading a pandoc, doc.
09:14:07 <ertes-w> texasmynsted: it's only complicated, because i'm making you do all this by hand =)
09:14:37 <ertes-w> and i'm only giving you vague directions…  that's on purpose
09:14:38 <texasmynsted> heh 
09:18:35 <texasmynsted> This is a bit more terse let foo (Right (Pandoc x ys)) = lookupMeta "title" x
09:19:44 <texasmynsted> sigh
09:20:01 <ertes-w> texasmynsted: and also a bit more wrong =)
09:20:04 <ertes-w> oh, wait
09:20:07 <ertes-w> no, it's correct
09:20:10 <ertes-w> sorry
09:20:34 <texasmynsted> But it still only gets me to Just (MetaInlines [Str "Foo"])
09:21:24 <texasmynsted> I really want a Maybe String
09:21:29 <ertes-w> you don't want to do my little exercise i take it =)
09:21:29 <texasmynsted> for title
09:21:48 <texasmynsted> I think it is over my head for this morning
09:22:32 <texasmynsted> I will quickly try 
09:23:34 <texasmynsted> I wish I would have done this in a file rather than ghci
09:23:38 <maerwald> if I have something like ([Int], Bool) can I traverse the list and while doing that also modify the Bool with lenses (e.g. depending on a condition during traversal)?
09:23:40 <monochrom> I see a list there. [Str "Foo"]. Is it always of length 1? Is it always an Str inside?
09:24:22 <ertes-w> maerwald: yes, but you need two layers
09:24:42 <johnw> maerwald: that sounds like mapAccumL
09:24:47 <maerwald> then I could just set Bool to True if I injected anitem successfully into the list
09:24:50 <maerwald> and avoid traversing twice
09:26:58 <ertes-w> oh, wait, i misread the type
09:27:05 <texasmynsted> can I skip the MetaValue -> String function for now, or can you show my how that would look?
09:30:33 <maerwald> Johnw: mapAccumLOf?
09:31:14 <gilbertw1> Hi, I recently updated to the lastest ghc/haskell packages on arch linux (8.2.1) and xmobar has begun crashing periodically with the following coredump: https://www.pastiebin.com/59c28d04a2562 ... does this coredump mean anything to any of you guys?
09:31:24 <johnw> :t mapAccumL
09:31:25 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
09:31:43 <johnw> if you're in a sense "accumulating a boolean" while mapping a list
09:32:04 <ertes-w> @let setInsertL x = flip (foldr (\x' go b -> x' : go (b || x == x')) (\b -> if b then [] else [x])) False
09:32:06 <lambdabot>  Defined.
09:32:20 <ertes-w> > setInsertL 5 [1,3,5,7,9]
09:32:23 <lambdabot>  [1,3,5,7,9]
09:32:24 <ertes-w> > setInsertL 6 [1,3,5,7,9]
09:32:26 <lambdabot>  [1,3,5,7,9,6]
09:32:41 <ertes-w> > setInsertL 6 [1,3..]
09:32:44 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
09:32:52 <ertes-w> maerwald: traverses only once
09:33:15 <ongy> I've seen gilbertw1 coredump in #xmonad, I mainly directed them over here, because I wanted to get some educated opinion whether that coredump implies we get a segfault in parsec (which would obviously be bad)
09:33:37 <ertes-w> you can probably express that more concisely with mapAccumL
09:34:08 <maerwald> weird, that's not even using lenses
09:34:08 <ertes-w> texasmynsted: let me give you a different exercise then:
09:35:23 <ertes-w> texasmynsted: write a function of the following type that returns the sum of all elements; write it using explicit recursion:  (Num a) => [Maybe a] -> a
09:35:27 <texasmynsted> I wonder if lpaste.net can load pandoc...
09:36:39 <ertes-w> maerwald: lenses don't solve *every* problem well =)
09:36:58 <monochrom> "lens" has a vague boundary anyway.
09:37:21 <monochrom> @type traverse
09:37:23 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
09:37:50 <monochrom> This one was not invented with lens in mind. But lens considers it a lens.
09:38:16 <monochrom> You can't draw a hard boundary. There may also be a sense in which mapAccumL counts as a lens.
09:38:54 <monochrom> Now consider what counts as "functional programming"...
09:43:47 <ertes-w> :t _1 print
09:43:48 <lambdabot> (Show a, Field1 s t a ()) => s -> IO t
09:44:43 <ertes-w> :t _1 print :: (Show a) => (a, b) -> IO ((), b)
09:44:44 <lambdabot> Show a => (a, b) -> IO ((), b)
09:44:45 <paolino> is it possible to write a function which can execute an argument of type (IO a) but nothing else in IO ?
09:45:49 <monochrom> I don't understand the question. Is it not simply "f m = m"?
09:46:23 <ClaudiusMaximus> perhaps   f m = m >> m
09:46:33 <paolino> but f could be m >> print 1
09:46:43 <paolino> I want to avoid that
09:46:56 <ClaudiusMaximus> you could make f's type more polymorphic than IO, perhaps
09:47:18 <monochrom> But I didn't write "f m = m >> print 1". I wrote "f m = m". I have m, the complete m, and nothing but the m.
09:47:33 <paolino> monochrom, correct my wording is wrong
09:48:26 <ClaudiusMaximus> f :: a -> a ; f = id  ; g :: Monad m => m a -> m a ; g a = some monadic stuff that must involve a ; or so
09:48:31 <paolino> I'm looking for constraining functions to behave like that
09:49:21 <johnw> paolino: one way to let people express the _desire_ to execute IO performing actions, but not letting them actually do it, is to separate expression from evaluation by using a Free monad style of abstraction
09:49:50 <monochrom> Incidentally I think the type "forall a. a -> a" does it. For example it doesn't even allow you to use >>.
09:49:53 <johnw> you could even have your DSL accept an IO a action as an argument; but only the evaluator would be able to decide when/how to execute it
09:50:06 <monochrom> It also doesn't allow you to ignore its argument.
09:50:50 <iqubic> How do DSLs work?
09:51:12 <iqubic> How does on make a DSL?
09:51:26 <johnw> iqubic: https://softwareengineering.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern
09:51:49 <johnw> the first answer there gives a good introduction to the idea
09:51:57 <johnw> it has _many_ flavors of implementation, but that's the general approach
09:52:09 <paolino> johnw I will look up for it, but I suspect it's more in the direction of some higher rank stuff, which I just cannot see
09:53:31 <paolino> or some phantom 
09:53:44 <paolino> anyway I read that now, thanks
09:54:24 <mnoonan> paolino: no, it is much simpler (in some ways, at least)
09:55:16 <iqubic> Why are phantom types even a thing?
09:55:42 <monochrom> Why not.
09:55:43 <texasmynsted> I am sure there is a better way but ertes-w, how about http://lpaste.net/4794902915183542272
09:56:09 <mnoonan> iqubic: https://stackoverflow.com/questions/28247543/motivation-behind-phantom-types
09:58:31 <mnoonan> phantom types are just ghosts of departed proofs :)
10:00:45 <ertes-w> texasmynsted: did you find that difficult to write?
10:02:25 <iqubic> I see what phantom types do,
10:03:05 <iqubic> They let us encode information about our data in the types themself.
10:03:18 <ertes-w> paolino: if you want to limit effects, use effect classes:  f :: (Monad m) => m a -> m a  -- this function can only sequence the effect the user provided
10:03:42 <ertes-w> paolino: replace Monad by Functor, then it can't even do that…  it can only be the identity function
10:07:41 <iqubic> If you had data Unit = Miles | Kilometers and data Length (a :: Unit) = Length Double, can you then have type classes like Length
10:08:38 <iqubic> Sorry, type classes like Instance Num Length Miles and Instance Num Length Kilometers?
10:08:53 <texasmynsted> no
10:08:56 <iqubic> And will those separate typeclasses both be valid?
10:09:02 <iqubic> texasmynsted: why not?
10:09:02 <texasmynsted> sorry had to step away
10:09:35 <texasmynsted> sorry was answering ertes-w 
10:09:55 <ongy> iqubic: because Miles and Kilometers aren't types, but value constructors. so you don't have the type Length Kilometers
10:10:06 <ertes-w> texasmynsted: now the conversion from MetaValue to String is basically the same thing, except that you do string concatenation instead of addition
10:10:18 <ertes-w> texasmynsted: just try it
10:10:25 <iqubic> ongy: so how are phantom types used then
10:10:27 <ongy> I'm not even sure the `Length (a :: Unit)` is valid syntax, since that's basically `Length Unit` (you are forcing a type variable to a single type there)
10:10:54 <ongy> You could have two types 'data Miles' and 'Data Kilometers' and do these things (EmptyDataDecls)
10:11:29 <iqubic> ongy: it's supposed to be a kind signature. It's a GHC language pragma.
10:11:30 <texasmynsted> MetaValue or MetaLines?
10:12:05 <iqubic> ongy: you also need DataKinds to make this work I do believe.
10:12:36 <ongy> ah, I haven't played with DataKinds, maybe it's possible with that. but phantom types work with less fancy extensions
10:12:50 <iqubic> ertes-w: can you tell me if this is the right kind of thinking?
10:13:02 <iqubic> ongy: how do you use phantom types?
10:15:17 <ertes-w> texasmynsted: MetaValue…  i have to go now, so good luck till tomorrow =)
10:15:22 <nshepperd> yes, 'data Length (a :: Unit) = Length Double' is exactly the sort of thing you would do with DataKinds
10:15:31 <texasmynsted> thank you ertes-w 
10:16:18 <iqubic> nshepperd: and can I then make separate type classes like Num Length Miles and Num Length Kilometers?
10:16:33 <nshepperd> yep
10:16:50 <nshepperd> Num (Length Miles) though
10:16:58 <nshepperd> gotta have those parentheses
10:18:14 <iqubic> Right. And I need to use kind signatures to force the phantom type to be of kind LengthUnit, right?
10:18:28 <nshepperd> yes
10:19:05 <mnoonan> iqubic: no, just use two different empty types "data Miles" and "data Kilometers"
10:19:07 <nshepperd> non-DataKinds uses of phantom types include Ptr and ForeignPtr from the ffi library
10:19:31 <iqubic> And in a function, can I pattern match and do different things for Length Miles vs Length Kilometers?
10:19:36 <mnoonan> you don't need to be able to construct values inhabiting the types, since you're only using them for phantom parameters anyway
10:19:59 <iqubic> mnoonan: and your point is?
10:20:11 <mnoonan> no, but "Length Miles" and "Length Kilometers" are different types, so you can write Num instances for each or whatever you want
10:21:06 <iqubic> Right. I see.
10:21:25 <nshepperd> iqubic: no, you can't pattern match on types in functions
10:21:31 <iqubic> And I can pattern match to pick out the double.
10:21:37 <mnoonan> right
10:21:40 <nshepperd> but you can have a class that has a different instance for Miles and Kilometers
10:21:55 <mnoonan> instance Show (Length Miles) where show (Length x) = show x ++ " mi"
10:23:11 <iqubic> mnoonan: right and then I don't need to worry about which function is called when I do "show distance"
10:23:51 <mnoonan> right
10:25:09 <iqubic> Phantom types are cool.
10:25:34 <nshepperd> or you can use singletons to get at the unit at runtime. data SUnit (u :: Unit) where { SMiles :: SUnit Miles; SKilometers :: SUnit Kilometers }; class KnownUnit (u :: Unit) where { unitVal :: Proxy u -> SUnit u }
10:25:45 <ongy> nshepperd: do you by chance know if FunPtr ever cares about the type? Or is that just for the typechecker?
10:26:21 <iqubic> How do I create a new Length and tell GHC what type units are, without singletons?
10:27:15 <iqubic> Do I specify the type when telling GHC what the return type of my function is?
10:27:23 <nshepperd> then a function with (KnownUnit u) constraint can pattern match on an SUnit u to find out whether it is Miles or Kilometers
10:27:44 <iqubic> nshepperd: I don't know how to use singletons yet.
10:28:21 <iqubic> Also, I like doing things the old school way.
10:28:31 <Unicorn_Princess> I get a memory leak when putting modifyIORef' into replicateM_, but can't figure out how to fix it: http://lpaste.net/358584 - compiling with -XStrict does not affect the behaviour
10:28:42 <nshepperd> well, singletons are just as I described
10:28:46 <nshepperd> it's very simple :)
10:29:17 <nshepperd> iqubic: (Length 2 :: Length Miles) i guess
10:30:13 <iqubic> What is that proxy thing doing there?
10:31:13 * hackagebot servant-checked-exceptions 0.4.1.0 – Checked exceptions for Servant APIs. – https://hackage.haskell.org/package/servant-checked-exceptions
10:31:30 <nshepperd> oh, I suppose you don't need it
10:31:42 <nshepperd> it could just be { unitVal :: SUnit u }
10:33:16 <nshepperd> instance KnownUnit u => Show (Length u) where { show (Length x) = show x ++ " " ++ case (unitVal :: SUnit u) of { SMiles -> "mi"; SKilometers -> "km" } }
10:35:29 <nshepperd> ongy: i think that FunPtr is always represented as just a pointer, probably
10:35:34 <nshepperd> ongy: so the type is phantom
10:36:21 <nshepperd> ongy: but of course, it matters in that the type tells you what kind of arguments the function has. if you call it with the wrong arguments presumably your program will crash
10:36:55 <ongy> I'm aware. I was mainly wondering if I need the right type to freeHaskellFunPtr it, or if I can just claim it's any FunPtr
10:37:31 <nshepperd> I would guess that it doesn't matter, apart from calling the function
10:39:24 <erisco> what is a package for parsing GHC output? I found http://hackage.haskell.org/package/error-analyze for parsing errors but it is old
10:39:37 <ongy> the interesting part for that is the part not visible in the type either way (what's captured, not what's required)
10:39:50 <erisco> maybe this can be teased out of ghc-mod
10:40:10 <ongy> doesn't that use ghc as library?
10:40:39 <erisco> yes
10:41:37 <monochrom> Seems like an overkill to get the GHC API involved.
10:44:15 <erisco> I don't assume GHC includes a parser for its own output
10:48:39 <c_wraith> erisco, recent versions of ghc have a flag to produce json output specifically for other tools to ingest
10:50:46 <c_wraith> erisco, https://ghc.haskell.org/trac/ghc/ticket/13190
10:51:31 <erisco> neato burrito … I'll keep that on the radar
10:51:34 <c_wraith> Apparently that's only *really* recent.
10:52:20 <monochrom> Interesting.
10:53:37 <monochrom> Haha neato.
10:54:49 <monochrom> boo ghci refuses to honour my -ddump-json
10:55:09 <c_wraith> I heard it has some bugs with ghci.
10:55:25 <c_wraith> like.. it only prints the json when you quit ghci
10:56:37 <monochrom> It will get better next time! :)
10:56:39 <erisco> needs to jiggle the handle
10:57:00 <Zemyla> Is there a library for a Free MonadFix?
11:02:13 <aweinstock> > case undefined of _ -> 5 -- I was under the impression that case acted like seq, what subtlety am I missing?
11:02:16 <lambdabot>  5
11:02:47 <c_wraith> aweinstock, case only evaluates enough to match the pattern.
11:03:13 <c_wraith> aweinstock, maybe you're thinking of case in core? *that* case always evaluates.
11:06:09 <erisco> if that acted like seq then it wouldn't have had to be a special GHC feature
11:09:37 <fizbin> Hey, if the dependencies on hackage for a given package are incorrect, where do I file the bug?
11:09:57 <erisco> someone needs to suffer putting together the semantics of Haskell… I know there is that wikibooks (or whatever) entry which is a good start
11:11:38 <erisco> ideally an executable semantics … then with a transpiler we can see clearly the meaning of Haskell programs at work
11:12:37 <erisco> Q: "Why does Haskell do this?" A: "Type your code in here and click 'run'."
11:13:30 <cocreature> fizbin: most packages on hackage have links to issue trackers or source repos
11:13:37 <erisco> then we can all retire and turn #haskell just into a fan club.
11:14:04 <aweinstock> c_wraith: thanks
11:14:17 <Chobbes> Is there a way to convert RealFrac a to RealFrac b?
11:14:38 <cocreature> Chobbes: that doesn’t make sense, "RealFrac a" is a constraint not a type
11:15:06 <Chobbes> cocreature: I mean (RealFrac a, RealFrac b) => a -> b
11:15:11 <cocreature> :t realToFrac :: (RealFrac a, RealFrac b) => a -> b
11:15:13 <lambdabot> (RealFrac b, RealFrac a) => a -> b
11:15:28 <erisco> @hoogle (RealFrac a, RealFrac b) => a -> b
11:15:29 <lambdabot> Prelude truncate :: (RealFrac a, (Integral b)) => a -> b
11:15:29 <lambdabot> Prelude round :: (RealFrac a, (Integral b)) => a -> b
11:15:29 <lambdabot> Prelude ceiling :: (RealFrac a, (Integral b)) => a -> b
11:15:34 <Chobbes> Hoogle, why :(
11:15:59 <erisco> never mind, I guess we don't get to retire
11:16:06 <Chobbes> Anyway, thanks! Hoogle lead me to believe it didn't exist.
11:16:43 <erisco> we'll just be relegated to work an info desk… "it is over there, sir"
11:20:08 <cocreature> Chobbes: it’s even more general than you need it to be
11:20:12 <cocreature> :t realToFrac
11:20:14 <lambdabot> (Fractional b, Real a) => a -> b
11:20:27 <cocreature> but Fractional and Real are superclasses of RealFrac so it works in your case as well
11:20:56 <erisco> do those search engines consider the class hierarchy? I suspect not
11:21:11 <cocreature> @hoogle (Fractional b, Real a) => a -> b
11:21:11 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
11:21:11 <lambdabot> Data.GI.Base.ShortPrelude realToFrac :: (Real a, Fractional b) => a -> b
11:21:11 <lambdabot> CorePrelude realToFrac :: (Real a, Fractional b) => a -> b
11:21:16 <cocreature> that’s better :)
11:27:36 * hackagebot dotenv 0.5.0.2 – Loads environment variables from dotenv files – https://hackage.haskell.org/package/dotenv
11:31:05 <erisco> > { "hello world" }
11:31:07 <lambdabot>  <hint>:1:1: error: parse error on input ‘{’
11:32:19 <erisco> it would be nice if for layout-based syntax that merely increased indentation begins a block and decreased indentation ends a block
11:34:57 <texasmynsted> giving up for today.
11:35:12 <texasmynsted> can't seem to conver [Inline] -> String
11:36:08 <cocreature> texasmynsted: where is Inline coming from?
11:39:07 <erisco> then you just grammatically let blocks be used just about anywhere
11:39:21 <erisco> { 5 } + 6  like this
11:40:48 <Tuplanolla> It would be pretty funny since `x / {y / z}` would be `(x / y) / z`, erisco.
11:42:59 <erisco> sure, but you don't use braces explicitly anyways
11:43:37 <erisco> of course if you're doing this for braces then you need similar for semicolons
11:43:57 <erisco> x /; {y / z};
11:44:55 <Tuplanolla> How about `(x / {y) / z}` then, erisco?
11:45:18 <erisco> sure
11:45:53 <Tuplanolla> I get HTML vibes from this and they're not good vibes.
11:46:21 <erisco> the point is to have easy, simple, consistent rules for layout, and then different interpretations for braces and semicolons
11:46:37 <erisco> so in this context they're meaningless, thus it is equivalent to (x / y) / z
11:48:09 <erisco> (x / "{y) / z}")
11:48:26 <erisco> your eyes are just used to quotes and not to braces yet
11:59:44 <texasmynsted> Inline is a pandoc type
12:05:50 <cocreature> texasmynsted: looks like the easiest way is to construct a Pandoc out of [Inline] and then render that
12:07:02 <texasmynsted> yeah if I can get a Pandoc from an [Inline] then I could use writeHtmlString to get a string from it
12:07:34 <Psybur> Anybody have an idea why putStrLn output isnt ending up in nohup.out when I use nohup on a haskell binary?
12:07:42 <cocreature> texasmynsted: it’s not too hard "Pandoc (Meta Data.Map.empty) [Plain <yourinlineshere>]" should work
12:08:32 <cocreature> Psybur: is it not ending up there immediately or not ending up there at all? in the first case, you might need to flush buffers
12:08:41 <Psybur> Not at all
12:08:45 <texasmynsted> where did you find that?
12:09:17 <cocreature> texasmynsted: I just looked through the haddocks
12:09:28 <cocreature> texasmynsted: https://hackage.haskell.org/package/pandoc-types-1.17.0.5/docs/Text-Pandoc-Definition.html#t:Pandoc and https://hackage.haskell.org/package/pandoc-types-1.17.0.5/docs/Text-Pandoc-Definition.html#t:Block
12:10:35 <Psybur> Im using forever $ do, think that would cause problems? But when I dont run it in nohup I can see output in the terminal
12:10:43 <cocreature> Psybur: worksforme™. can you show us some code? how exactly are you testing things?
12:11:04 <Psybur> cocreature, you dont wanna see this code >D
12:11:08 <Psybur> Im trying to replicate hold on
12:12:39 <cocreature> Psybur: "forever" sounds like your program doesn’t terminate. so how are you sure that the output is _never_ written to the file?
12:12:45 <cocreature> did you kill it?
12:13:28 <Psybur> cocreature, maybe I have a misunderstanding on how redirection works. If the program doesnt terminate, does its output not get put to disk?
12:14:00 <cocreature> Psybur: oh it will get to disk at some point but if you’re writing to a file, things might get buffered for a while before they are written to a file
12:14:05 <cricalixwood[m]> hi. Complete newbie to haskell. Just decided it would be fun to learn something different. 40+years of programming in imperative languages (and 20 in SQL). Where should I go to get what is probably really simple stuff answered, please?
12:14:28 <Psybur> cocreature, it doesnt put out a lot of data and it sleeps for about 45 minutes at a time
12:15:12 <cocreature> Psybur: you can try putting "hSetBuffering stdout NoBuffering" at the beginning of your code
12:15:28 <cocreature> if you’re not writing a lot of data, chances are you never fill the buffers
12:15:46 <cocreature> cricalixwood[m]: beginner questions are totally fine here
12:15:49 <Unicorn_Princess> got my memory leak down to 4 lines, but no closer to a solution: http://lpaste.net/358584 . it's just modifyIORef' inside replicateM_
12:16:39 <iqubic> Well, phantom types are really cool.
12:17:02 <geekosaur> Psybur, when output is going to file, it is buffered typically in 8kB buffers. until output reaches that size, it stays in the buffer
12:17:20 <geekosaur> and if you do not terminate the program normally, it'll stay in the buffer and not get written at all
12:17:32 <texasmynsted> Woot.  That worked.
12:17:37 <geekosaur> C works the same way
12:17:39 <texasmynsted> Thank you cocreature 
12:17:44 <cocreature> texasmynsted: yw :)
12:17:48 <Psybur> geekosaur, interdasting.
12:17:58 <iqubic> Can Psybur try flushing the output writing stream?
12:18:35 <iqubic> Forgive me if that doesn't work. I don't know what the problem is that we are tackling.
12:18:53 <Psybur> The app is backgrounded and nohup'd
12:19:20 <Psybur> Wondering how to make each line of output go straight to the file. I think I can use stdbuf -oL
12:19:24 <geekosaur> C programs that care can use a signal handler to tell the rest of the program to exit normally --- you cannot safely do things like buffered I/O from a signal handler because ther is no guarantee the signal was delivered at a safe time. (This applies to all languages)
12:19:34 <Psybur> In bash. Not sure if hSetBuffering would work?
12:20:12 <geekosaur> hSetBuffering will work fine to set flush-at-newline or no buffering
12:20:34 <geekosaur> stdbuf might not because it relies on programs using C stdio, whereas Haskell does its own buffering
12:20:57 <cocreature> Unicorn_Princess: your code is not sufficiently strict. modifyIORef' only evaluates things to whnf. in your case that will only force the first constructor of the list but not the value contained inside it
12:21:41 <cocreature> Unicorn_Princess: "modifyIORef' ref (\[x] -> x `seq` [x+1])" works
12:21:54 <Psybur> Ill check out hSetBuffering
12:22:25 <geekosaur> note, you need to do hSetBuffering before doing any output to that Handle. (C stdio has similar restrictions on setvbuf.)
12:24:49 <Psybur> hSetBuffering works
12:24:50 <Psybur> Thanks
12:25:00 <cricalixwood[m]> ok, here goes the first one. I have built a list of lists of pairs. Each list of pairs has 10 elements, and the potential size of the list of lists is 6^10. So I want to cut it down using some constraints. So I want to take each of my lists of pairs, and sum the first element of each pair to get a total, then sum the second element of each pair to get a second total. Based on those totals I want to exclude certain
12:25:00 <cricalixwood[m]> lists. In reality, what I have is a list of all the possible scores in a table-tennis match, which consists of 10 best-of-3 matches. So each of my lists of pairs looks something like [(3,0),(3,0)..(1,3),(2,3)]. Purely for fun, knowing the final score in both sets (say 6-4), and games (say 23-17) I want to derive all the possible sets of scores, (and then throw away the dupes).
12:27:00 <erisco> this feels like one of those problems that can be solved on paper
12:27:14 <Unicorn_Princess> cocreature: it works indeed, but I can't figure out how to make the equivalent of the old code work (if e.g. x = [1,2]) - where can I learn more about this horror?
12:27:32 <cricalixwood[m]> If it helps, I have a shiny new copy of LYAH, and this is day 1 of actually trying to do something with it.
12:28:22 <erisco> cricalixwood[m], what is the final answer you are looking for?
12:29:07 <Unicorn_Princess> e.g. modifyIORef' ref (\x -> x `seq` fmap succ x) doesn't work, but I have no idea why. how do I force the evaluation of all of 'x'?
12:29:07 <cocreature> Unicorn_Princess: sry, I don’t really know of any good resources on handling lazyness and strictness. for [1,2] or in general arbitrary lists and a bunch of calls to "map", deepseq’ing the list in each iteration might be helpful
12:29:08 <cricalixwood[m]> a list of lists of pairs, which match the sum and count criteria.
12:29:50 <cocreature> Unicorn_Princess: are you familiar with whnf?
12:29:53 <cricalixwood[m]> I can do it by eye easily.
12:30:08 <erisco> cricalixwood[m], maybe lpaste some examples… I need more detail
12:30:49 <Unicorn_Princess> cocreature: fraid not, though I've heard of it - weak head normal form, right? that's where my knowledge ends
12:30:52 <cricalixwood[m]> ok sure give me a minute or two
12:31:04 <erisco> there may just be a smarter way of generating the lists in the first place
12:31:20 <erisco> and, if not that, then I may have some helpful techniques for searching these lists
12:31:34 <erisco> but it depends a lot on how they're generated in the first place
12:31:54 <erisco> and what the criteria are…
12:32:49 <cocreature> Unicorn_Princess: the basic idea is that to evaluate a term to whnf, you evaluate it until you encounter a constructor but no further. so for a list you evaluate until you have [] or _x : _xs. in particular _x and _xs are not being evaluated.
12:33:02 <iqubic> Bu5
12:33:06 <erisco> or a lambda
12:33:16 <erisco> "function constructor"
12:33:30 <cocreature> Unicorn_Princess: seq x y evaluates to y but if y is evaluated to whnf, x will also be evaluated
12:33:35 <cocreature> erisco: sure but that doesn’t matter here
12:34:04 <cocreature> Unicorn_Princess: so the problem is that you want to evaluate all values in a list and not just evaluate the list to whnf
12:34:14 <cocreature> Unicorn_Princess: that’s what the deepseq package is for.
12:34:15 <iqubic> But that leaves you with stuff like (x:xs) where the head and the tai might still be rather complex.
12:34:50 <iqubic> Try opening ghc and playing around with :sprint car.
12:35:05 <iqubic> s/car/var/
12:35:44 <Unicorn_Princess> and deepseq is like, the 'standard' way to get rid of lazyness?
12:36:06 <cocreature> deepseq is for evaluating things to normal form instead of weak head normal form
12:36:22 <iqubic> It will print the value of a variable without evaluating it at all. Unevaluated parts of a variable will look like underscores.
12:36:45 <iqubic> :sprint is the ghci thing you can try playing with.
12:37:22 <iqubic> Or rather it will not evaluate the variable any further than it already is.
12:38:37 * cricalixwood[m] sent a long message: cricalixwood[m]_2017-09-20_19:38:15.txt <https://matrix.org/_matrix/media/v1/download/matrix.org/KFuoxQYkYRbglmOVftdYKwPs>
12:39:20 <Unicorn_Princess> cocreature: so if I understand correctly, seq is for "compute this thing now", and deepseq is for "compute this thing, and all the things it's made from, now"? roughly speaking
12:39:38 <erisco> cricalixwood[m], put it on lpaste.net
12:39:59 <iqubic> Unicorn_Princess: yes, but as always, try it in ghci with :sprint
12:39:59 <cricalixwood[m]> Sorry (continuing) m as follows:
12:40:00 <cricalixwood[m]> Prelude> let m =[[a,b,c,d,e,f,g,h,i,j]|a<-tt,b<-tt,c<-tt,d<-tt,e<-tt,f<-tt,g<-tt,h<-tt,i<-tt,j<-tt]
12:40:01 <cricalixwood[m]> So now I want to iterate through each entry in m and get the scores for the pairs in each of those elements.
12:40:27 <cricalixwood[m]> ok sorry, new to IRC too.
12:40:38 <Unicorn_Princess> iqubic: is there a non-ghci version of :sprint?
12:40:49 <cricalixwood[m]> But that was the extent of my code so far - all 2 lines of it!
12:41:00 <iqubic> Unicorn_Princess: what Haskell repl do you use?
12:41:33 <erisco> cricalixwood[m], okay, we can work with this… and what are the criteria?
12:41:34 <cocreature> Unicorn_Princess: “now” is the wrong term. "seq x y" does not magically evaluate things now. "seq x y" only guarantees that if you end up evaluating that term to the whnf of y, x will also be evaluated to whnf
12:41:53 <erisco> cricalixwood[m], and also give me tt
12:42:07 <cocreature> Unicorn_Princess: contrary to seq, deepseq is also not builtin magic. it’s implemented in terms of seq so you can take a look at how it works for different datatypes
12:42:46 <Unicorn_Princess> iqubic: well, ghci through stack, but I usually just compile and run
12:42:49 <cocreature> Unicorn_Princess: e.g. here it is for lists https://hackage.haskell.org/package/deepseq-1.4.3.0/docs/src/Control.DeepSeq.html#line-547
12:43:00 * cricalixwood[m] sent a long message: cricalixwood[m]_2017-09-20_19:42:40.txt <https://matrix.org/_matrix/media/v1/download/matrix.org/TqDCTUGvyExXZFmreUYVlLba>
12:43:16 <erisco> please just use lpaste.net … I don't know what this "sent a long message" thing is
12:45:09 <cricalixwood[m]> Sorry not sure what you mean by the criteria.  The parameters to my final funtion would be 6,4,25,11. My answer will be several lists of 10 pairs that match those score lines. (Sorry if I am not putting this well).
12:45:33 <cricalixwood[m]> Ok will try that. I am not seeing what you are seeing, obviously.
12:46:12 <erisco> I don't know… I think your client is automatically uploading your too-long messages to some service and telling us about it
12:46:26 <iqubic> Unicorn_Princess: http://chimera.labs.oreilly.com/books/1230000000929/ch02.html#sec_par-eval-whnf see this
12:46:30 <erisco> pretend this is Twitter. If you want to Tweet Longer, use lpaste.net
12:46:38 * Clint twitches.
12:47:20 <erisco> I want to know 1) what is tt, 2) how do you determine if you want to keep or throw away a particular list?
12:47:43 <iqubic> Unicorn_Princess: feel free to skip the parallelism stuff there if you want. Still a good read regardless.
12:48:18 <Unicorn_Princess> thanks y'all. I'll read it after dinner :)
12:49:08 <cricalixwood[m]> @erisco http://lpaste.net/358586  I think.
12:49:09 <lambdabot> Unknown command, try @list
12:49:27 <erisco> cricalixwood[m], thank-you, and what are the criteria?
12:51:45 <cricalixwood[m]> Updated the pastebin
12:51:47 <erisco> eh, 6^10 is only 60M … just let it run for a bit … thought it was bigger
12:52:42 <cricalixwood[m]> My problem is how to code the sums of the first elements...so I can compare them.
12:53:03 <erisco> sum . fmap fst
12:54:33 <erisco> cricalixwood[m], how did you get 6-4? I count 7-3
12:55:53 <cricalixwood[m]> I cannot count, that's how. Sorry. New to this IRC thing, and getting flustered. I need to go and read up fmap, and see if I can get something together.
12:56:09 <erisco> sum . map fst   then
12:56:35 <cricalixwood[m]> What does the dot . mean?
12:56:38 <erisco> I don't know what 25-11 is or how it becomes involved in the problem
12:56:45 <erisco> that is right-to-left function composition
12:57:34 <cricalixwood[m]> it's the sum of the first elemnts of each pair, and the sum of the second elements of each pair (and I may have got those totals wrong too)
12:57:44 <cricalixwood[m]> ok
12:58:11 <erisco> okay, I get the problem now
12:59:59 <erisco> sum (map fst xs) == 25; sum (map snd xs) == 11; sum (filter (uncurry (>)) xs) == 7; sum (filter (uncurry (<)) xs) == 3;  solve for xs
13:00:47 <erisco> oops, I mean genericLength after the filter
13:01:44 <cricalixwood[m]> OK thanks! Now I need to go and digest all of that. Leave it with me and I'll see how it goes. I'll come back tomorrow if I'm still stuck. Much appreciated.
13:02:32 <erisco> implicitly I added your other constraints of what a "best of 3" game is
13:02:54 <erisco> and that there are exactly 10 sets
13:03:35 <cricalixwood[m]> ok...so that's the whole thing?!  Wow that's powerful!
13:03:56 <erisco> no, I am just restating your problem in an exact language
13:04:32 <erisco> if you wanted to solve your problem like that though then maybe a logic language, or an SMT solver like Z3 could do that
13:05:50 <erisco> actually I am quite certain Z3 can crank out all the solutions… don't know how fast it would be
13:06:28 <cricalixwood[m]> oh this is not important - it was just to see if I could write something that worked, and exercised my list handling skills (non-existent at the moment).
13:07:58 <erisco> I did some work with — lets say "nontrivial" — searching in Cartesian products
13:08:38 <erisco> have to do some code archeology though…
13:09:29 <cricalixwood[m]> No don't waste your time, I'll have a go at it. Many thanks for your help.
13:10:20 <erisco> iirc it is this gem that will help here:  foldlM . ((=<<) .)
13:17:07 <iqubic> erisco: why would logical programming be any better than Haskell for this problem?
13:17:23 <iqubic> Logic programming seems confusing and hard.
13:17:38 <erisco> because you write programs as constraints
13:18:15 <erisco> "give me the list which is ordered and is a permutation of xs"
13:18:25 <iqubic> But how is that different from functional programming?
13:18:27 <erisco> that would be how you write a list sort, for example, in simplicity
13:19:45 <iqubic> erisco: also \xs -> filter (isSorted xs) (permutations xs)
13:20:46 <iqubic> Not sure if isSorted is in prelude, but that's not too hard to write with haskell.
13:21:33 <iqubic> So why is logical programming better.
13:22:40 <johnw> iqubic: sometimes it allows a very clear expression of the problem, where the solution can be determined by backtracking search
13:22:57 <johnw> rather than directly encoding the search to be performed, thus obscuring the problem being solved
13:22:59 <erisco> iqubic, because permutations is an algorithm saying how to find all the permutations
13:23:27 <erisco> iqubic, same as filter is an algorithm saying how to filter a list
13:23:33 <Tuplanolla> @let isSorted = and . (zipWith (<=) <*> tail)
13:23:34 <lambdabot>  Defined.
13:24:11 <erisco> you can implement these things and give them names, and that is fine, but it is missing the point entirely
13:24:24 <erisco> you could have jumped straight to  sort xs
13:27:03 <erisco> an implementation of filter and permutations would be stating what those things mean, not necessarily how to derive them
13:27:17 <kotangent> does anyone have experience with Scotty and websockets? Should I be using wai-websockets? Any directly is helpful, thanks
13:27:29 <erisco> so, for example, if I give you xs and ys, how do you determine if xs is a permutation of ys? that is the implementation of "permutations"
13:27:48 <erisco> same for filter… given p and xs, how do you determine if ys is xs filtered by p? that becomes the implementation for filter
13:28:48 <erisco> and as you might imagine, a problem is having a way to efficiently compute, or compute at all, these wondrous things we come up with
13:29:48 * hackagebot shake 0.16 – Build system library, like Make, but more accurate dependencies. – https://hackage.haskell.org/package/shake
13:29:48 * hackagebot aeson 1.2.2.0 – Fast JSON parsing and encoding – https://hackage.haskell.org/package/aeson
13:34:17 <erisco> @let foldlBind = foldlM . ((=<<) .)
13:34:18 <lambdabot>  Defined.
13:34:20 <iqubic> erisco: do you like logic programming.
13:34:46 <erisco> iqubic, I am aware of it but I have not used it for anything substantial
13:35:13 <iqubic> erisco: no, neither have I.p
13:35:24 <erisco> what I like is not being blinded to the variety of ways in which we can program
13:35:35 <erisco> at one point in time, no one knew what "programming" was, or could be, or should be
13:35:46 <iqubic>  I have no idea how one would do something like a GUI in prolog for example.
13:35:59 <maerwald> it's possible
13:36:03 <erisco> not all methods of programming will be suitable to all problems
13:36:25 <erisco> that is the strength of a plurality… you give up something in one area to be better in another
13:37:37 <iqubic> On a different topic, can I use ffi for getting bindings to a C GUI?
13:38:45 <geekosaur> that's how it's usually done, yes
13:39:03 <iqubic> Oh. I'd like to learn how to do that.
13:40:25 <iqubic> Is ffi hard to learn, or is it a pain in the butt?
13:41:25 <dmiles> the way i do gui's in prolog is often by rendering html or by having the asserta database be a dictaction of c# forms
13:41:38 <dmiles> c#/.net
13:41:53 <dmiles> dictation*
13:42:24 <kadoban> iqubic: I haven't done much of it, but what I've done was fairly painless
13:42:45 <kadoban> I've done more of the JS FFI than the C one I suppose
13:43:35 <iqubic> kadoban:  did you do that for web development or what? I know more c than is.
13:43:36 <noteventime> iqubic: inline-c seems to generally make it quite painless 
13:43:49 <kadoban> iqubic: Yeah, in ghcjs
13:44:50 <erisco> to witness the power of foldlBind, here is a search through 10^10 (10 billion) lists
13:44:57 <erisco> > length $ foldlBind (\(s, xs) x -> if s + x <= 10 then [(s + x, x:xs)] else []) (0, []) (replicate 10 [0..10])
13:45:01 <lambdabot>  184756
13:45:32 <erisco> this is finding all the length-10 lists, elements drawn from [0..10], such that the sum is <= 10
13:47:55 <erisco> and all it is is a short-circuit when the criteria is falsified, but this culls swaths of possibilities
13:49:19 <erisco> so, if you have some criteria such that if it is false for a prefix then it is false for the whole, this will help
13:50:34 <erisco> you could also imagine a generalisation which includes looking at suffixes too
13:50:54 <Fendor> morning everyone, did someone try to implement 2d stencil algorithm with repa that is better than the implemetation of repa-algorithms?
13:51:18 <erisco> I think this is best done as merely knowing the current element index, because from that we know how large the suffix is
13:51:40 <erisco> and coupled with knowledge of what the elements are drawn from, we can write additional tests
13:52:05 <erisco> you could imagine that if the elements were drawn from [1..10] then we know a n-length suffix must at least have sum n
13:53:12 <erisco> another thing you can do is have a much more intelligent enumeration of the Cartesian product (that example just uses [])
13:53:41 <erisco> that is relevant if you only need some solutions and not all of them (the idea being that you can enumerate more likely solutions first)
13:56:02 <erisco> actually… [0..10] is length 11, so that was a search through 10^11 or 100 billion lists
13:56:08 <quazimodo> so we use foo <- monadicValue
13:56:40 <quazimodo> how do we do that inline (so we can pass the monadic value directly into a function) rather than have this 'bind' line
13:57:36 <geekosaur> >>=
13:57:52 <geekosaur> :t (>>=)
13:57:53 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:57:57 <erisco> is it wrong to learn do-notation before bind?
13:58:07 <geekosaur> some believe so
13:58:46 <geekosaur> quazimodo, the translation from do notation is entirely mechanical, and lambdabot can even show you it
13:59:00 <geekosaur> @undo do { x <- foo; bar x }
13:59:00 <lambdabot> foo >>= \ x -> bar x
13:59:15 <erisco> well, it is sort of smart
13:59:16 <geekosaur> @. pl undo do { x <- foo; bar x }
13:59:16 <lambdabot> bar =<< foo
13:59:24 <quazimodo> geekosaur: i see
13:59:27 <quazimodo> that's cute
13:59:40 <quazimodo> so how do we chain it in the other direction?
13:59:43 <erisco> eta reductions are left as an exercise for the reader
14:00:12 <quazimodo> how would you write it so it's like   bar <some operator> foo
14:00:23 <quazimodo> oh
14:00:28 <quazimodo> you already told me
14:00:36 <quazimodo> and i was guessing it'd be =<<
14:00:44 <quazimodo> thank you geekosaur 
14:01:03 <geekosaur> yeh, I composed @undo with @pl to eliminate the mechanical translation-introduced lambda
14:01:59 <quazimodo> oh i don't have any idea what @unda and @pl means
14:02:06 <geekosaur> @help undo
14:02:06 <lambdabot> undo <expr>
14:02:06 <lambdabot> Translate do notation to Monad operators.
14:02:12 <geekosaur> @help pl
14:02:12 <lambdabot> pointless <expr>. Play with pointfree code.
14:02:22 <geekosaur> ... there's a helpful help text :/
14:02:39 <quazimodo> these aren't available in ghci though are they
14:02:40 <geekosaur> @pl removes 'points' (explicit bindings) from an expression
14:02:40 <lambdabot> (line 1, column 11):
14:02:40 <lambdabot> unexpected "o"
14:02:40 <lambdabot> expecting variable
14:02:56 <geekosaur> only if you hook lambdabot up to ghci
14:03:02 <geekosaur> @hackage goa
14:03:02 <lambdabot> http://hackage.haskell.org/package/goa
14:03:28 <quazimodo> :t <$>
14:03:29 <lambdabot> error: parse error on input ‘<$>’
14:03:29 <geekosaur> unfortunately goa is rather tricky and cranky and hard to get and keep working :/
14:03:33 <quazimodo> hrm
14:03:36 <quazimodo> :t $
14:03:37 <erisco>  @pl is Variable-Be-Gone spray for the betterment of your programming experience
14:03:37 <lambdabot> error:
14:03:38 <lambdabot>     parse error on input ‘$’
14:03:38 <lambdabot>     Perhaps you intended to use TemplateHaskell
14:03:39 <geekosaur> and they're not generally available as separate libraries
14:03:42 <geekosaur> :t ($)
14:03:43 <lambdabot> (a -> b) -> a -> b
14:03:56 <geekosaur> have to use parens so they are function syntax instead of operator syntax
14:04:08 <quazimodo> oh, makes sense
14:04:19 <quazimodo> so i don't think i understand <$> very well then
14:04:27 <quazimodo> foo a vs foo <$> a
14:04:29 <quazimodo> why?
14:04:29 <erisco> though be warned: @pl employs "whatever works" rather than "whatever makes sense"
14:04:31 <geekosaur> :t (<$>)
14:04:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:04:44 <geekosaur> ... which you might note is the same as
14:04:45 <geekosaur> :t fmap
14:04:46 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:05:19 <quazimodo> yes very familiar
14:05:27 <quazimodo> and it seems like maybe it's being used in this way here
14:05:33 <quazimodo> intercalate " " <$> getArgs
14:06:03 <geekosaur> thing is, there are a lot of things wth Functor instances, and sometimes which one is being used isn't obvious. the ((->) e) Functor is a common source of confusion
14:06:12 <quazimodo> getArgs is monadic, so then this line is applying an fa to a curried 'intercalate' which is (a -> b) to produce an fb, isn't it
14:06:44 <quazimodo> :t intercalate
14:06:45 <lambdabot> [a] -> [[a]] -> [a]
14:07:15 <quazimodo> :t getArgs
14:07:17 <lambdabot> error: Variable not in scope: getArgs
14:07:17 <geekosaur> you can think of that here as applying (intercalate " ") 'under' the IO
14:07:24 <geekosaur> :t System.Environment.getArgs
14:07:26 <lambdabot> IO [String]
14:07:50 <quazimodo> geekosaur: is that different to what I said, is it not the same as fmap?
14:08:22 <geekosaur> although that can't be done literally, so a more correct way to think of it for IO is as attaching a callback to the IO action
14:08:41 <geekosaur> h? that's still fmap
14:08:46 <geekosaur> *huh?
14:09:07 <geekosaur> :t fmap (intercalate " ") System.Environment.getArgs
14:09:08 <lambdabot> IO [Char]
14:09:41 <geekosaur> in fact it was often written that way before Applicative made it into the libraries
14:09:53 <erisco> I don't know geekosaur… the involved gymnastics seems Olympic-level
14:10:05 <quazimodo> you've shot past me in domain knowledge
14:10:42 <fishythefish> I think we might have skipped stating that <$> is just infix fmap
14:10:52 <geekosaur> no, that's where this started
14:10:57 <fishythefish> rip
14:11:15 <geekosaur> scan back to 'which you might note is the same as'
14:11:37 <quazimodo> ok my confusion came from :t ($) => (a -> b) -> a -> b
14:11:57 <fishythefish> I did see that, just wasn't sure if quazimodo realized it's really just a syntactic convenience
14:12:10 <erisco> just my opinion on that particular analogy… but generally my rule is not to offer analogies which takes an expert to decipher correctly
14:12:17 <geekosaur> right, ($) is just function application at lowest precedence instead of highest. it's a hack to eliminate parentheses, more or less
14:12:49 <quazimodo> i did not realize that :t ($) and :t (<$>) are describing different things. I guess when you said @pl employs whatever works etc... it threw me off
14:13:02 <quazimodo> so then it stands to reason that $ is an operator too
14:13:09 <quazimodo> and is different to <$>
14:13:14 <geekosaur> right
14:13:27 <quazimodo> yep makes sense
14:13:34 <erisco> by "whatever works" I mean @pl is going to give you a lot of nonsense (but correct) code
14:13:43 <quazimodo> ahhhhhhhh ok nice so i was wondering how to get rid of all those ()
14:13:52 <quazimodo> i've noticed over time that haskell was strangely lacking in them
14:14:03 <erisco> by "whatever makes sense" I mean code which is both correct and human readable (which means adhering to some well-known structure)
14:14:08 <quazimodo> gotcha
14:14:27 <dolio> pl won't necessarily generate correct code.
14:14:38 <quazimodo> is there a way to combine the effects of $ and =<< ?
14:14:51 <erisco> no… please no… parentheses are endangered species, quazimodo, and we need you to help bring them back!
14:14:57 <quazimodo> so foo =<< (some stuff) becomes foo <mystery> (...)
14:14:58 <quazimodo> lolol
14:15:13 <quazimodo> sorry, no (...) just ...
14:15:52 <erisco> dolio, do you have some pathological cases? I saw something on the bug tracker but it is actually a bug
14:15:54 <fishythefish> Depending on what operators are being used in the (some stuff), you can just drop the parentheses immediately
14:16:00 <fishythefish> If they bind tighter than =<<
14:16:42 <dolio> erisco: Well, it's just a dumb syntactic transformation. I think it's possible to get it to produce code that doesn't type check.
14:17:33 <geekosaur> yes, it's entirely possib;e
14:17:35 <dolio> Also it doesn't understand some syntax, and will misinterpret it as other syntactic elements such that the transformation doesn't make sense.
14:17:35 <quazimodo> fishythefish: gotcha
14:17:46 <dolio> But I meant more of the former.
14:17:59 <geekosaur> because it recognizes some syntactic patterns, but it knows nothng of types
14:18:03 <quazimodo> do we have a dynamic debugger in haskell?
14:18:13 <quazimodo> something that'll throw up a repl?
14:19:24 <erisco> okay, so type check your @pl results before flashing your car brake firmware
14:20:25 <erisco> I find quite often you can come up with a better answer than @pl, though, unless it is already trivial
14:20:47 <maerwald> if you need to use @pl, you are already doing it wrong
14:20:51 <erisco> better in that it does not lose readability
14:21:27 <erisco> you also have the benefit of domain knowledge to wiggle things around
14:21:31 <quazimodo> erisco: i'm no trying to hurt you :P but i need to investigate. Is there a paren free way to do fmap (intercalate " ") getArgs
14:21:58 <geekosaur> isn't that where we started?     intercalate " " <$> getArgs
14:22:19 <erisco> I am a guardian of parentheses, and I cannot advise you on this misadventure.
14:22:25 <geekosaur> now *that* may need to be parenthesized if it is part of a larger expression... removing those parentheses requires knowing the larger expression
14:22:36 <geekosaur> and you can't always eliminate *all* parentheses
14:23:32 <iqubic> quazimodo: do you know any lisp?
14:23:57 <iqubic> I think you'd throw up upon seeing the syntax.
14:24:03 <quazimodo> iqubic: ive written a bunch of emacs lisp and some commonlisp. Not saying i'm any good at it
14:24:10 <erisco> quazimodo, there is, though
14:24:30 <iqubic> quazimodo: do you like the syntax?
14:24:41 <quazimodo> geekosaur: yes, i was actually more curious about the situation of func1 (curried func2) value 
14:24:56 <erisco> and I think it is painful enough that you won't use it
14:24:58 <quazimodo> he fmap exmaple got me thinking
14:25:07 <erisco> :t fmap `id` intercalate " " `id` getArgs
14:25:08 <lambdabot> error:
14:25:09 <lambdabot>     Variable not in scope: getArgs :: f [[Char]]
14:25:09 <quazimodo> iqubic: i do, quite a lot
14:25:16 <erisco> IO [Char]
14:25:36 <iqubic> quazimodo: so why are you so keen to remove parens from haskell?
14:25:44 <quazimodo> iqubic: oh, just learning :)
14:27:04 <quazimodo> my teachers alwyas hated me because i learn by contemplating weird edge cases, they haaaated me for that
14:27:34 <erisco> I like that, but I am tired of this particular thing
14:27:36 <Tuplanolla> You should read Counterexamples in Topology, quazimodo.
14:27:59 <maerwald> quazimodo: oh, I had a prof who taught languages exactly that way, you would have loved him
14:28:10 <quazimodo> maerwald: maybe? 
14:28:14 <maerwald> everyone else hated him :>
14:28:26 <quazimodo> i feel like i'd hate him too, for you
14:28:26 <maerwald> his C++ lessons were... outch
14:28:32 <maerwald> too many edge cases in that language xD
14:29:04 <erisco> half the class bled out… I mean dropped out…
14:29:05 <quazimodo> C++ felt like one big clusterfuck to me
14:29:06 <MP2E> learning C++ by edgecases, aka, iteratively explaining every rule in the language :D [/s]
14:29:30 <iqubic> Did he ever teach Haskell, I'd love a lecture on Haskell edge case so and how language pragmas help fix them. That'd be interesting as heck.
14:29:31 <hydraz> /s not needed
14:29:50 <quazimodo> i learnt later that everyone basically felt that way. Then i learnt later that delivering a big C++ project meant you had real hair on your chest
14:29:59 <erisco> okay, but $ is an edge case you have to be active in using
14:30:08 <erisco> so, just don't do it
14:30:09 <iqubic> erisco: whys
14:30:10 <iqubic>  Is
14:30:31 <iqubic> Why is $ an edge case?
14:30:40 <quazimodo> ersico so in `id` what's going on?
14:30:47 <erisco> okay, here is how it always goes…
14:30:47 <quazimodo> is the ` ` special or the id
14:31:20 <erisco> person tries to learn Haskell, person gets confused by all the syntax features
14:31:21 <iqubic> The backticks are the special part there. It takes a prefix function and make it infix.
14:31:34 <erisco> why are my dots and dollars not working in the way I wanted them to, etc
14:31:52 <maerwald> iqubic: haskell doesn't have too many edge cases, does it? I mean, if you count out the GHCism things
14:31:59 <iqubic> Dots and dollars are confusing yeah. Just learn to right
14:32:19 <iqubic> Just learn to write everything with parens always.
14:32:19 <erisco> so, instead of playing games with infixities and precedences and so forth, learn the important stuff
14:32:38 <erisco> then when you get bored with being so serious, come back and play with the nonsense
14:32:45 <knupfer> Is it possible to demote a kind to a kind * in an elegant way? Or do need to write a class with an instance for every constructor?
14:32:53 <erisco> and make things like '...' operators
14:33:05 <maerwald> :t .!.
14:33:06 <lambdabot> error: parse error on input ‘.!.’
14:33:11 <iqubic> knupfer: what kind are you looking to demote.
14:33:12 <maerwald> :t (.!.)
14:33:14 <lambdabot> error:
14:33:14 <lambdabot>     • Variable not in scope: .!.
14:33:14 <lambdabot>     • Perhaps you meant one of these:
14:33:22 <maerwald> is '!' not allowed?
14:33:56 <iqubic> maerwald: it is allowed. lambdabot just doesn't know that operator.
14:33:56 <knupfer> iqubic: Well, I've got a quite huge sum type which I promote via datakinds.
14:33:58 <fishythefish> sure, that's a common name for indexing
14:34:07 <quazimodo> erisco: ohh i see, yes that infixed id "operator" is some gnarly ugly
14:34:18 <erisco> parentheses are the no-questions-asked everything-is-a-nail problem fixer
14:34:32 <iqubic> :t (+!)
14:34:34 <lambdabot> error:
14:34:34 <lambdabot>     • Variable not in scope: +!
14:34:34 <lambdabot>     • Perhaps you meant one of these:
14:34:57 <iqubic> Oh, I was looking at :+
14:35:04 <knupfer> iqubic: And I'd like to be able to demote it at certain uses. E.g. to access the show instance.
14:35:10 <quazimodo> erisco: but, to make a point i feel strongly about, when i read haskell code i see stuff like <$> and $ and =<< and i've even seed `id` in the past, though maybe it was in a tutorial
14:35:13 <erisco> the worst thing you can do with parentheses is use them redundantly
14:35:22 <iqubic> erisco:
14:35:30 <iqubic> erisco: like how?
14:35:33 <quazimodo> so they confused me, not in the application but in reading other code and thinknig what even is that girl?
14:35:39 <fishythefish> ((1 + 2))
14:35:46 <knupfer> ()
14:35:47 <knupfer> :)
14:35:53 <fishythefish> ahem, () is useful
14:36:01 <knupfer> That was a joke...
14:36:09 <fishythefish> yeah, but you have to be sure everyone gets it :P
14:36:27 <iqubic> quazimodo: Girl???
14:36:41 <fishythefish> =<< is the girl operator, cmon
14:36:51 <knupfer> ?
14:37:12 <maerwald> hm? needs more explanation
14:37:19 <quazimodo> iqubic: usually when anyone says 'what even is that' i imagine them saying 'girl' in a californian accent
14:37:22 <quazimodo> sorry
14:37:43 <knupfer> That's weird
14:37:53 <quazimodo> my hands did something my brain didn't authrise 
14:37:54 <erisco> quazimodo, and on top of that it may be using several extensions and other language features you don't know yet either
14:38:32 <iqubic> I love
14:38:33 <knupfer> So, I assume there isn't a comfortable way to convert some kind to kind *?
14:39:15 <iqubic> I really hate my cat right now.
14:39:18 <iqubic> Ugcfyifi
14:39:37 <quazimodo> erisco: to be clear though, i prefer immediately obvious to wizardly. I guess i abandoned academic english for simpler english for the same reason, waaaay better signal to noise, in my opinion
14:41:04 <quazimodo> that being said, i read once that 'reading haskell requires the assistance of rainman sometimes' or something like that... and it was like ... the perfect way to say what i'd felt reading haskell for a long time
14:41:16 <knupfer> > length "waaaay" <= length "way"
14:41:19 <lambdabot>  False
14:41:55 <maerwald> quazimodo: depends what kind of haskell, golfing and needless abstraction is probably more popular here then elsewhere
14:42:00 <maerwald> doesn't mean everyone does it
14:42:16 <erisco> I can't remove the 4 key from your keyboard… I guess I try to hard to persuade
14:42:24 <maerwald> after all, people don't just do haskell for productivity reasons
14:42:58 <quazimodo> maerwald: correct me if i'm wrong but it seems like functional languages make it very easy to abstract without restraint
14:43:12 <quazimodo> i know that I felt that in lisp far more than in ruby, my main language
14:43:22 <maerwald> quazimodo: I don't know
14:43:58 <maerwald> I have a feeling the "functional" bit isn't so much the key to the abstraction doors, but specific type system details you could have in imperative languages as well
14:44:40 <maerwald> e.g. purity
14:44:43 <quazimodo> i wasn't so confident about that statement. I'd only correlated heaps of abstraction to functional to be honest
14:44:47 <erisco> is it because in other languages you can't declare new infix operators at all? have you been released from abstinence?
14:45:03 <quazimodo> maerwald: yeah you might be onto it, purity might be the reason
14:45:09 <maerwald> quazimodo: check https://mars-lang.appspot.com/
14:45:13 <maerwald> not functional
14:45:39 <maerwald> the next step would maybe be to have a proper effects system
14:45:44 <quazimodo> right
14:45:57 <quazimodo> interesting
14:46:25 <erisco> do other languages not use parentheses? there is something I am not understanding about the psychology here
14:46:36 <quazimodo> erisco: me?
14:46:50 <maerwald> quazimodo: and ofc polymorphism, but we know that it's not specific to functional programming
14:47:19 <maerwald> and in fact, we have "functional" languages that are impure, have poor poylmorphism and so on
14:48:09 <maerwald> one thing is maybe more the style of thinking (functional vs imperative vs whatever), the other thing are actual properties, which can be implemented in different paradigms
14:48:22 <quazimodo> erisco: when i said i prefer immediately obvious i meant that i'd prefer () to $ if it made it easier to understand, so i'm not about to use $ or even <$> everywhere, i kinda like reading fmap... so familiar to me in a way from all the 'map' usage i've done
14:48:48 <erisco> <$> exists, I hope, because it has a good use in Applicative-style notations
14:48:51 <maerwald> I tend to overuse fmap, because I don't have to think about it, it always works :P
14:49:09 <erisco> other uses are much more arguable
14:49:18 <quazimodo> maerwald: also i think that the more the work is about the 'job', the more deadlines and 'get it done' play a role
14:49:27 <quazimodo> in which case... don't abstract unless you are rewriting shit
14:49:52 <quazimodo> i've wasted more time creating generic, 'good' code than anything else during my consultancy time
14:50:13 <maerwald> not sure, java programming is full of useless abstraction and patterns that lead to API locks and unmaintainable code... it's kind of a culture
14:50:18 <quazimodo> honestly 95% of the time never got used. inevitably the specific case was the only one that really needed handling
14:50:57 <quazimodo> i can't blame the java people, that language gives me the mental runs too
14:51:06 <erisco> though, it is only a replacement for  pure f <*>  and so not that thrilling… a small improvement
14:51:17 <quazimodo> ruby was lovely for this. Everything expressed super clearly and just did what it was meant to without fighting you
14:51:17 <maerwald> my main goal when programming is not adhering to principles or patterns, I just want a) have the control flow be as clear as possible and b) make it obvious where entry points are
14:51:29 <quazimodo> then i realised i want composition and ... possibly, types
14:51:56 <quazimodo> i'm not sold on types as a personal preference. I am sold on types as an amazing industrial strength tool, so no criticisms here!
14:52:09 <maerwald> I tend to have clearer control flow in languages like C, in fact, compared to my haskell code
14:52:18 <maerwald> I don't know why
14:52:37 <geekosaur> because C has more ways to bite you if you get tricky
14:52:43 <erisco> types are a 6th sense for programmers, and unfortunately most programmers are senseless to them
14:52:47 <maerwald> geekosaur: ?
14:52:47 <quazimodo> i guess it's about writing sensible function names in any language, that alwyas helped
14:53:18 <quazimodo> faaaar easier to understand 'concateTheInputArrays' than fmap (intercalate " ") getArgs
14:53:20 <erisco> be warned: once you see, you may not unsee, nor will you want to
14:53:33 <maerwald> erisco: there are other approaches too
14:54:00 <quazimodo> erisco: what little haskell code i do have, i have _zero_ anxiety about
14:54:07 <quazimodo> so, that's the type system doing it's thing for me
14:54:27 <quazimodo> but i did have to fight every step of the way (because i'm shitty at haskell actually)
14:54:31 <maerwald> you can describe control flow via data structures or embed them directly into functions skipping the explicit data, I wouldn't say one is better than the other per se
14:54:56 <maerwald> currently I'm moving logic from ad-hoc functions to data structure though, because stuff becomes unmaintainable
14:54:58 <maerwald> and cannot be extended
14:55:03 <erisco> maerwald, yeah, the worse ones
14:55:07 <quazimodo> maerwald: you know that might just be one of those things that makes haskell hard for me. I'm not used to thinking of data structures in that way
14:55:37 <maerwald> quazimodo: I think in transformations, these might involve new explicit data structures... or not
14:55:37 <zachk> quazimodo, thinking of data structures in what way?
14:55:39 <maerwald> I kind of don't care
14:56:35 <quazimodo> zachk: well, to me they are 'objects' with keys/accessors/etc on them
14:56:36 <maerwald> but I always want to compose transformations and be able to clearly see the flow and not have it hidden behind abstraction, implicitness or even objects
14:56:37 <quazimodo> and they hold some state
14:56:47 <quazimodo> your functions check that state, and then do stuff
14:56:59 <geekosaur> that's pretty much the problem, yes. you have an OO mindset, Haskell has a funcional programming mindset
14:57:02 <quazimodo> it's a super limited view of data structures, but somehow that's all i have
14:57:22 <maerwald> ADTs are not objects
14:57:27 <maerwald> there is a paper describing it
14:57:48 <geekosaur> and haskell's laziness and purity gives you the tools to exploit functional programming style to its fullest... so Haskell programmers do
14:57:52 <quazimodo> grr i still can't find a way to multiline this ++ operator
14:58:08 <geekosaur> the result will be very confusing if you try to understand it through an OO lens
14:58:33 <quazimodo> someLongListstuff ++ otherStuffThatgeneratesAList is getting too long
14:58:40 <geekosaur> indentation
14:59:06 <geekosaur> also end lines with the operator, so the parser knows something else must follow and the indentation of the next line becomes less critical
15:00:06 * hackagebot miso 0.7.6.0 – A tasty Haskell front-end framework – https://hackage.haskell.org/package/miso
15:00:06 * hackagebot checkmate 0.1.4 – Generate checklists relevant to a given patch – https://hackage.haskell.org/package/checkmate
15:00:09 <geekosaur> (this is also why haskellers tend to do things like lists with the , at the front of lines; the parser is less likely to pull indentation issues when your lines don't end in , or ])
15:00:19 <quazimodo> geekosaur: yep gotcha
15:00:41 <geekosaur> also why SPJ does the { ... \n ; ... } in do notation
15:01:06 <maerwald> quazimodo: https://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf
15:01:06 <quazimodo> ok, now ghci complains about multiple lines lol
15:01:20 <quazimodo> it doesn't end
15:01:32 <geekosaur> yes, ghci is not good at multiline stuff. put it in a file and :l it
15:01:51 <quazimodo> ok
15:02:23 <geekosaur> (ghci does have two different ways to do multiline input:  :{ :} for one-shots and `:set +m` for default multiline where a completely empty line is necessary to end a logical "line")
15:03:01 <geekosaur> but you will still run into problems because ghci just isn't very smart about the whole thing. it's very different from what the compiler accepts in a file.
15:03:15 <quazimodo> geekosaur: yeah I'm seeing this
15:03:28 <quazimodo> i absolutely can't copy paste file lines into ghic
15:03:38 <quazimodo> breaks easily
15:03:41 <geekosaur> REPLs have to deal with a lot of weirdness that a normal compiler doesn't
15:03:59 <erisco> one window is your text editor, the other window is ghci
15:04:02 <erisco> :r to reload the file
15:05:01 <quazimodo> erisco: so this is actually a shell script file
15:05:12 <quazimodo> using #!/usr/bin/env runhaskell
15:05:28 <geekosaur> that shouldn't be an issue...
15:05:31 <quazimodo> ok
15:06:47 <quazimodo> hrm. Any way to load a file not ending in '.hs' ?
15:07:45 <quazimodo> i'll figure that out
15:07:53 <quazimodo> Guys you've bene truely wonderful
15:08:09 <quazimodo> thank you all for the time, the discussion and the help. It's really, really helped me along these past couple days
15:09:19 <erisco> sure thing, good luck
15:10:25 <quazimodo> i'll be back tomorrow to ask a bajillion more things. maerwald thanks for that paper :)
15:23:18 <__monty__> I was wondering whether there's a big performance difference between repeatedly append'ing to a Text value or making a list and feeding it to Text's concat. Is there a general rule of thumb for such things?
15:25:51 <fishythefish> generally, concat should be faster
15:26:01 <jle`> __monty__: well, cons for lists is very efficient
15:26:06 <jle`> for Text I believe it re-allocates the entire string
15:26:18 <jle`> barring some potential optimizations
15:26:19 <fishythefish> each append will create an intermediate Text (although these are subject to fusion)
15:26:36 <jle`> for lists, `xs ++ ys` will re-use 'ys' in memory
15:26:44 <jle`> so it will only re-allocate xs
15:26:59 <jle`> but i believe t1 <> t2 for text re-allocates both t1 and t2
15:29:31 <erisco> it will rebuild the spine of xs
15:29:55 <erisco> "re-use" … I read "use"
15:30:10 <__monty__> Would fused appends be more efficient than concat?
15:30:34 <jle`> fusion is a bit finnicky at times, the best bet if you really care is just to benchmark
15:30:55 <jle`> but if you do a lot of list-efficient things (like proper ++ association, and conses) then it just makes more sense to do it for lists
15:31:52 <jle`> instead of relying on fusion
15:31:56 <fishythefish> +1 for benchmarking
15:32:34 <fishythefish> rewrite rules can be nice when the compiler applies them, but ensuring that happens can be difficult
15:32:58 <jle`> yes there is a prominent user here whose answer to all performance questions is "all answers are meaningless without benchmarking"
15:36:14 <__monty__> I know performance guidelines are rarely set in stone but it's useful to have a good first guess.
15:36:52 <iqubic> Why is it impossible to have Haskell types that depend on values know only at run time?
15:37:06 <fishythefish> how would you statically check such types?
15:37:20 <iqubic> fishythefish: you can't.
15:37:34 <iqubic> What is dependent Haskell?
15:37:56 <fishythefish> the values used in dependent typing are known at compile time
15:38:08 <iqubic> They are?
15:38:39 <iqubic> So why is it called dependent Haskell then?
15:39:24 <fishythefish> because it adds dependent types
15:39:40 <iqubic> But what are deep
15:39:52 <iqubic> What are dependent types?
15:40:17 <fishythefish> perhaps an example would help
15:40:30 <Tuplanolla> Are you capable of researching anything by yourself, iqubic?
15:40:32 <erisco> if you want great performance for static list spines then try Church lists
15:40:41 <fishythefish> without dependent types, you can have a type like Vector Int - this doesn't say anything about the length of the vector
15:40:49 <erisco> this is because GHC is aggressive with reducing lambdas
15:41:05 <fishythefish> dependent types let you express something like Vector 5 Int - a vector of exactly 5 ints
15:41:31 <iqubic> And that's not possible with current Haskell?
15:41:33 <jle`> you can "technically" have `Vector 5 Int` without dependent types, it just wouldn't be very useful
15:41:42 <jle`> well, semi-useful
15:41:58 <iqubic> Why not make vector int int?
15:41:59 <jle`> a variation of Vector 5 Int is possible with haskell98
15:42:56 <iqubic> jle`: so why not just use that?
15:43:23 <erisco> iqubic, you can accomplish this with singletons (to answer your original question) … the trick being that there is only one value per type
15:43:41 <iqubic> Huh, how does that work?
15:43:43 <erisco> so there is nothing to determine at runtime that you can't know statically
15:44:10 <iqubic> How do singletons work?
15:44:18 <erisco> there is one value per type, like I said
15:44:38 <iqubic> And how do you use singletons?
15:44:52 <erisco> carefully
15:44:59 <MarcelineVQ> one at a time
15:45:09 <MarcelineVQ> doh ho ho
15:45:10 <erisco> :)
15:45:14 <iqubic> MarcelineVQ: not what I meant.
15:45:25 <fishythefish> it's worth googling these keywords first but...
15:45:34 <erisco> well, give me a problem and we'll talk about it… I don't come up with problems for people
15:46:12 <fishythefish> https://typesandkinds.wordpress.com/tag/singletons/
15:46:21 <Ero> Hi Friends. I just implemented a recursive data structure to form  a factor tree in haskell with optimisations to solve for project euler q3. quite proud of myself and wanted to share lol
15:46:22 <iqubic> Well, I don't have a problem, I just want to learn about stuff for the sake of learning.
15:46:39 <iqubic> I'll ask again when I have a problem that needs solving.
15:46:39 <erisco> look up the singletons package… they have a paper you can read
15:46:49 <MarcelineVQ> Ero: woo!
15:47:05 <fishythefish> iqubic: returning to your question about that Vector type, you're misunderstanding what Vector 5 Int represents
15:47:06 <zachk> iqubic, if you want dependent types in haskell today, just cabal install idris, it looks close to haskell and has dependent types
15:47:10 <Ero> I wondered if anyone might give my code a quick review to see if if there are some obvious haskell idioms i could use to tidy my code?
15:47:14 <fishythefish> the type itself constrains the vector to have 5 elements
15:47:24 <erisco> Ero, go for
15:47:31 <Ero> :D
15:48:31 * hackagebot wai-middleware-json-errors 0.1.2 – Converts errors from plaintext to json – https://hackage.haskell.org/package/wai-middleware-json-errors
15:49:24 <Ero> please review my code fellow Haskeletons: lpaste.net/358588
15:55:22 <erisco> Ero, I left an annotation. I suggest using $ a lot less as well.
15:56:09 <erisco> instead of  a $ b $ c $ d  try  (a . b . c) d  or  a (b (c d))
16:00:05 <erisco> I missed a reduction…  isPrime = isPrimeFrom 2
16:02:01 <Ero> thanks erisco :) how come i should use $ less? I will tryout the suggested forms in my next excersize
16:05:01 <erisco> because I don't like it
16:05:32 <MarcelineVQ> ehe
16:07:09 <Ero> hah fair enough. I'll have to get over my fear of the layout rules too. I get scared i'll break my code by hitting return lol
16:07:12 <Ero> thx
16:07:13 <erisco> I can try and argue it is a needless operator that depends on careful assessment of infixities and precedences
16:07:34 <erisco> but there is no deep reason … I don't like it
16:07:45 <Ero> thats fair
16:08:08 <Ero> thanks for reviewing my code :) now onto euler 4. night all
16:10:15 <erisco> also there is a direct correlation between parenthesis proclivity and intelligence… true fact
16:12:57 <Ero> erisco are you a lisper per chance? :P
16:14:38 <erisco> an instructor of mine once challenged if being honest is worth leaving another astray
16:15:14 <erisco> lying may be the only way to convince someone to do the right thing, and only later can they understand that
16:17:41 <MarcelineVQ> nothing cryptic about that
16:21:28 <jle`> iqubic: a variation of static-lengthed vectors is possible in haskell98, but without dependent types, it's not very useful
16:21:39 <MarcelineVQ> I submit to the council the notion that it's not neccesary to tell people to avoid $, as someone writing code that cares about what they write will get tired of $ all on their own, maybe probably
16:22:10 <iqubic> jle`: you can even use nats to track the length.
16:22:20 <jle`> that's what i mean yes
16:24:06 <erisco> MarcelineVQ, yes, sometimes lying won't work either
16:28:29 <royal_screwup21> what's the simplest example of a function with '@' syntax?
16:28:51 <erisco> > id @Int 5
16:28:54 <lambdabot>  error:
16:28:54 <lambdabot>      Pattern syntax in expression context: id@Int
16:28:54 <lambdabot>      Did you mean to enable TypeApplications?
16:29:01 <erisco> yes, yes I did lambdabot
16:29:21 <erisco> or are we talking about @ in patterns?
16:29:46 <royal_screwup21> yup
16:30:07 <royal_screwup21> @ in patterns
16:30:12 <erisco> > let f a@_ = a in f 5
16:30:15 <lambdabot>  5
16:30:20 <quazimodo> I'm back with a gist. I feel accomplished that I got it done. What can be improved (as far as doing haskell properly, as well as more convenient use of syntax/modules/naming etc)
16:30:23 <geekosaur> someone had one the other day where they were splitting a list and needed both the split element and the original list
16:30:23 <quazimodo> O.putStrLn ("Executing: " <> command <> "\n")
16:30:25 <quazimodo> shit
16:30:27 <quazimodo>   stdout (inproc "emacsclient25" argsList empty)
16:30:29 <geekosaur> (but they didn't know about as-patterns)
16:30:33 <quazimodo>  https://gist.github.com/0448e3d1b41da240f054825b89698b77
16:30:44 <erisco> you see, if you pattern match, say (x:xs), then what if you want to refer to the whole of x:xs ?
16:30:52 <jle`> @let stutter str@(x:xs) = x : str
16:30:52 <erisco> so @ lets you give a name to that,  xxs@(x:xs)
16:30:54 <lambdabot>  Defined.
16:31:00 <jle`> > stutter "hello"
16:31:03 <lambdabot>  "hhello"
16:31:15 <jle`> ^ royal_screwup21 
16:31:28 <jle`> i'm not sure if it's the provably the "simplest" example
16:31:32 <jle`> but it is a simple example
16:32:00 <erisco> :t \a@_->a
16:32:01 <lambdabot> p -> p
16:32:09 <erisco> I submit this as a candidate
16:33:09 <royal_screwup21> thanks folks!
16:33:33 <jle`> :t \h@skell -> h
16:33:35 <lambdabot> p -> p
16:33:49 <jle`> :t \ex@mple -> mple
16:33:50 <lambdabot> p -> p
16:33:57 <erisco> that's almost good enough for a t-shirt
16:34:08 <zachk> except it says pp
16:34:21 <jle`> s/except/especially because
16:34:45 <erisco> we just need something more clever for the body
16:35:43 <erisco> or maybe just leave it off
16:37:07 <jle`> give me a day to brainstorm
16:38:16 <jle`> haskell = \be@utiful -> be
16:38:21 <jle`> not exactly the best grammar
16:38:58 <erisco> I don't really go for phrases sprinkled with symbols
16:39:08 <erisco> if there is something particularly clever about it, maybe
16:39:15 <jle`> maybe if you are against TED talks
16:39:21 <jle`> haskell = \defe@ted -> ted
16:39:35 <erisco> for example, the  student (mentor student)  example I had yesterday
16:40:16 <erisco> you have to contort your thinking so much that by the time you explain it no one is less confused
16:41:24 <royal_screwup21> so I was looking at a function that eliminates consecutive duplicates in a list and I couldn't figure out the purpose of the *last* line. Here's the code https://thepasteb.in/p/Y6hk29W4xg6S7 I mean, the recursion's already being set off in the "guards" anyway, so I'm kind of at a loss trying to understand the purpose of the last line
16:41:46 <jle`> royal_screwup21: you need to handle the empty case
16:41:49 <erisco> royal_screwup21, what is  compress []  ?
16:41:57 <jle`> and also the single-item case
16:42:01 <royal_screwup21> eek
16:42:10 <jle`> so it probably could have been more clearly written
16:42:14 <jle`> compress [] = []
16:42:17 <jle`> compress [x] = [x]
16:42:42 <royal_screwup21> makes more sense
16:43:03 <erisco> > (map head . group) "hello world"
16:43:05 <lambdabot>  "helo world"
16:43:14 <jle`> i like to write my functions with the [] cases first
16:43:41 <erisco> jle`, we're two birds of a feather
16:43:44 <jle`> > (map head . group) "hellllllllllllo" 
16:43:46 <lambdabot>  "helo"
16:44:46 <jle`> oh i think this matches the pasted implementation
16:45:56 <zachk> > nub [1,1,1,2,2,3,3]
16:45:58 <lambdabot>  [1,2,3]
16:46:19 <zachk> if nub isn't in Prelude it is in Data.List
16:46:20 <erisco> @check map head . group == nub
16:46:22 <jle`> nub is slightly different
16:46:23 <lambdabot>  error:
16:46:23 <lambdabot>  • No instance for (Eq ([()] -> [()])) arising from a use of ‘==’ (maybe you ...
16:46:39 <erisco> @check \xs -> (map head . group) xs == nub xs
16:46:42 <lambdabot>  +++ OK, passed 100 tests.
16:46:46 <jle`> ha
16:46:53 <jle`> i guess that closes that case
16:46:57 <erisco> yup, ship it
16:47:07 <jle`> there are only 100 lists anyway
16:47:13 <jle`> we checked 'em all
16:47:23 <erisco> "finite simple lists" or something, yeah
16:47:29 <fishythefish> > nub [1, 1, 2, 1]
16:47:31 <lambdabot>  [1,2]
16:47:34 <fishythefish> > map head . group $ [1, 1, 2, 1]
16:47:36 <lambdabot>  [1,2,1]
16:47:38 <jle`> @check \xs -> (map head . group) xs == nub (xs :: [Int])
16:47:40 <lambdabot>  *** Failed! Falsifiable (after 6 tests and 2 shrinks):
16:47:40 <lambdabot>  [-4,5,-4,1]
16:47:42 <fishythefish> etc.
16:47:47 <jle`> @check \xs -> (map head . group) xs == nub (xs :: [Char])
16:47:50 <lambdabot>  *** Failed! Falsifiable (after 11 tests and 5 shrinks):
16:47:50 <lambdabot>  "e\ESC\NUL\"\ACK\NUL@\9274"
16:47:55 <erisco> chose unit, didn't it, heh
16:48:09 <jle`> @check \xs -> (map head . group) xs == nub (xs :: [()])
16:48:11 <lambdabot>  +++ OK, passed 100 tests.
16:49:20 <jle`> i wonder why lambdabot hasn't turned on type applications
16:49:33 <jle`> i mean, it's on ghc 8.2
16:49:42 <jle`> > (compilerName, compilerVersion)
16:49:44 <lambdabot>  ("ghc",Version {versionBranch = [8,2], versionTags = []})
16:50:16 <erisco> https://www.youtube.com/watch?v=BipvGD-LCjU
16:53:08 <tippenein> http://lpaste.net/358590 <- question about stack build throwing a Cabal-related version issue on build
16:55:28 <proofskiddie> I can't make it through that whole video, too much cringe
16:55:37 <tippenein> hmm, stack setup --upgrade-cabal looks like it uses a different cabal binary
17:02:16 <tippenein> found it. .stack-work/dist/ /Cabal-2.0 existed and was taking preference in a sub project..
17:02:36 <tippenein> I guess stack clean doesn't do sub projects? *shrug*
17:02:49 <jle`> erisco: ooh, remastered
17:22:43 <HallaSurvivor> Hey, if I have [(Int,Int)], and I want to turn that into [(Int,[Int])] by grouping all the elements who share the first part of their tuple
17:23:13 <HallaSurvivor> so [(1,1), (1,2), (2,3), (3,4)] => [(1,[1,2]), (2,[3]), (3,[4])]
17:23:20 <HallaSurvivor> I can have
17:23:29 <HallaSurvivor> levelset a = filter (==a)
17:23:30 <erisco> convert to Map using Set union, then back to lists
17:24:00 <HallaSurvivor> but that gives me [(a,x1),(a,x2),...]
17:24:27 <HallaSurvivor> I feel like there's a clever way to turn that into (a,[x1,x2,..]), but all I can think of is (a,map snd xs)
17:24:28 <erisco> > ((fmap . fmap) S.toList . M.toList . M.fromListWith S.union . (fmap . fmap) S.singleton) [(1,1), (1,2), (2,3), (3,4)]
17:24:31 <lambdabot>  [(1,[1,2]),(2,[3]),(3,[4])]
17:24:49 <HallaSurvivor> :O thaaaaaaaaaat seems a bit overkill
17:24:57 <HallaSurvivor> probably way more efficient than my version
17:25:00 <HallaSurvivor> but still
17:25:17 <erisco> oh, I wasn't aware we need a special kind of solution
17:25:21 <HallaSurvivor> I know how to solve the problem, I was more curious as to a slick way of pulling the (a,) out of the list
17:26:50 <HallaSurvivor> some oneliner that abuses the fact that you can shove applicatives into a traversible, for instance
17:26:53 <HallaSurvivor> but like... backwards
17:27:03 <erisco> > sortBy fst [(1,1), (1,2), (2,3), (3,4)]
17:27:05 <lambdabot>  error:
17:27:05 <lambdabot>      • Occurs check: cannot construct the infinite type:
17:27:05 <lambdabot>          a ~ (a, b) -> Ordering
17:27:18 <erisco> that never does what I want it to
17:27:22 <HallaSurvivor> lol, relatable
17:27:53 <HallaSurvivor> so like, could you sequenceA using (Int,) as your applicative?
17:27:59 <HallaSurvivor> is what I'm looking for
17:28:13 <HallaSurvivor> again, I know how to solve it, I was just curious if there was a clever thing like that
17:28:13 <hydraz> > sortOn snd [(1, 1), (1, 2), (2, 3), (3, 4)]
17:28:15 <lambdabot>  [(1,1),(1,2),(2,3),(3,4)]
17:28:32 <hydraz> ... that list *is* sorted, erisco
17:28:48 <erisco> that is unimportant
17:28:58 <erisco> > (groupBy (on (==) fst) . sortBy (comparing fst)) [(1,1), (1,2), (2,3), (3,4)]
17:29:01 <lambdabot>  [[(1,1),(1,2)],[(2,3)],[(3,4)]]
17:29:07 <erisco> so you're here, HallaSurvivor?
17:29:38 <hydraz> sortOn f is equivalent to sortBy (comparing f)
17:29:40 <erisco> this is another irksome thing… what one really wants here is to retain what is familiar about each group
17:29:59 <HallaSurvivor> erisco, yeah
17:30:31 <erisco> I gave a different version of group which I called gang, I think, which does this
17:30:32 <HallaSurvivor> filtering out all the elements whose first component is c, then mapping over all c
17:30:48 <erisco> other than that we can transform the result we get from group, unpleasantly
17:34:47 <erisco> gang :: (b -> b -> Bool) -> (a -> (b, c)) -> [a] -> [(b,[c])]
17:34:55 <erisco> that wasn't exactly what I did before but that'll work now
17:37:17 <HallaSurvivor> meh, I ended up just doing
17:37:47 <HallaSurvivor> getLevelSet c = (c, map snd $ filter ((==c) . fst) xs)
17:37:59 <HallaSurvivor> it works, even if it's kind of ugly
17:38:11 <erisco> why suffer that, then
17:38:18 <HallaSurvivor> hm?
17:38:56 <erisco> instead of leaving yourself with a "kind of ugly" solution, make something better
17:39:34 <HallaSurvivor> cuz this is just a thing to help me visualize a variant of the collatz conjecture
17:39:54 <HallaSurvivor> part of an assignment is to find a simple expression for the minimum stopping time of a function
17:40:19 <HallaSurvivor> so I was going to group together all the stopping time = 1, 2, 3, .. n to look for a pattern in what numbers stop when
17:40:28 <HallaSurvivor> so good enough is honestly good enough :P
17:40:42 <HallaSurvivor> Once I'm not working on this, I'll go back and remember that I wanted to make this pretty
17:40:44 <HallaSurvivor> but not now
17:41:03 <HallaSurvivor> anyways, thanks all!
17:41:45 <erisco> well, I am tired of having this problem, so I am going to write the solution for myself
17:41:47 <erisco> again…
17:55:19 <erisco> :t gang
17:55:21 <lambdabot> (Eq a1, Foldable t1) => (t2 -> (a1, a2)) -> t1 t2 -> [(a1, [a2])]
17:56:07 <erisco> :t gang id
17:56:08 <lambdabot> (Eq a1, Foldable t1) => t1 (a1, a2) -> [(a1, [a2])]
17:56:22 <erisco> so there is quite trivially the function which "pulls out" the first element
17:57:15 <erisco> but we are also enabled to provide other maps, so here is another one
17:58:09 <erisco> > gang (\x -> (length x, x)) (words "the quick brown fox jumps over the lazy dog")
17:58:12 <lambdabot>  [(3,["the"]),(5,["quick","brown"]),(3,["fox"]),(5,["jumps"]),(4,["over"]),(3...
17:59:20 <erisco> maybe it is sensible to generalise beyond ==, I am not sure
18:03:06 <erisco> now to petition someone with a library of list functions to put this in…
18:07:58 <xzhu> I keep hearing the term "continuations." Are those just function callbacks?
18:09:02 <erisco> they give you a result, and you can give them some more input to get yet another result
18:09:25 <xzhu> Ohh I see, like pythong generators
18:09:28 <xzhu> Python
18:09:58 <xzhu> More precisely Python co-routines
18:12:32 <erisco> what if I want to petition base package for my definition? do I open a GHC ticket?
18:13:22 <davean> just go make your own library?
18:13:30 <erisco> it is just one function
18:14:26 <davean> Ok, so?
18:14:39 <davean> Either submit it to an existing library you tihnk it belongs in, or make your own
18:14:50 <erisco> reread my question, then
18:15:06 <davean> I'm answering that - base likes to see it tested in a package first
18:15:16 <davean> For obvious reasons
18:16:16 * hackagebot katip 0.5.0.2 – A structured logging framework. – https://hackage.haskell.org/package/katip
18:16:44 <xzhu> erisco: Why do you think `gang` should be in base?
18:17:29 <erisco> because group/groupBy is, and it covers many situations that that function is inadequate for
18:17:58 <erisco> list-extras is the next obvious place for it
18:18:31 <erisco> and what measure is used to determine if something has been "tested in a package"?
18:22:52 <xzhu> erisco: What's your implementation of gang?
18:23:09 <xzhu> erisco: Sorry I don't have older chat log
18:23:17 <erisco> I'll tell you after I visit the patent office
18:24:44 <xzhu> erisco: Good one. My point is isn't it trivial to make your own on the fly?
18:25:04 <erisco> so are many definitions featured in base
18:29:23 <xzhu> erisco: But gang is not that flexible. It's results contain two things: processed data and original data (grouped)
18:29:47 <erisco> I don't know what "processed data" and "original data" are
18:29:57 <xzhu> You can get the latter by using groupBy and the former by `nub . map f`
18:30:23 <erisco> you can define it in terms of group and it sucks
18:30:31 <erisco> or groupBy, whichever
18:31:06 <xzhu> > nub . map length (words "the quick brown fox jumps over the lazy dog")
18:31:09 <lambdabot>  error:
18:31:09 <lambdabot>      • Couldn't match expected type ‘a -> [a1]’ with actual type ‘[Int]’
18:31:09 <lambdabot>      • Possible cause: ‘map’ is applied to too many arguments
18:31:17 <xzhu> > nub . map length $ (words "the quick brown fox jumps over the lazy dog")
18:31:20 <lambdabot>  [3,5,4]
18:31:36 <erisco> nub does not do the same thing
18:32:20 <xzhu> Sorry that was wrong
18:32:32 <xzhu> isn't there something like uniq
18:32:59 <erisco> I'll argue it with someone who can decide if it goes in their lib or not
18:34:44 <xzhu> Wait, there's no uniq? Does anyone know how to turn [5,5,5,3,3,5,2] into [5,3,5,2]?
18:35:04 <erisco> > (map head . group) [5,5,5,3,3,5,2]
18:35:06 <lambdabot>  [5,3,5,2]
18:35:22 <xzhu> that sucks.
18:35:36 <erisco> which part of it?
18:35:59 <xzhu> if we had uniq, your gang would have just been uniq . map f
18:36:10 <erisco> no, it wouldn't be
18:36:35 <erisco> I gave you uniq… it is  map head . group
18:37:02 <geekosaur> suspect they really means sort -u
18:38:02 <xzhu> Well, uniq . map f is the first part of Gang (the lengths in your example), the second part is just groupBy (compare f)
18:38:10 <xzhu> if you want you can zip them togethre
18:43:02 <erisco> :t (\f -> zip <$> map head . groupBy f . fmap fst <*> (fmap . fmap) snd . groupBy (f `on` fst)) -- so you mean this lovely thing
18:43:03 <lambdabot> (a -> a -> Bool) -> [(a, b)] -> [(a, [b])]
18:43:40 <nshepperd> surely we should want less things in base if possible
18:43:46 <nshepperd> what with being built into ghc
18:44:26 <erisco> I am not sure why they grow base when it could be broken into many pieces
18:47:20 <dumptruckman> Anyone familiar with the SIR model?
18:48:48 <xzhu> :t (&&&)
18:48:49 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
18:48:58 <xzhu> > gang f = uncurry zip . (uniq . map f &&& groupBy ((==) `on` f))
18:49:00 <lambdabot>  <hint>:1:8: error:
18:49:00 <lambdabot>      parse error on input ‘=’
18:49:00 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
18:49:10 <xzhu> @let gang f = uncurry zip . (uniq . map f &&& groupBy ((==) `on` f))
18:49:10 <lambdabot>  Parse failed: Ambiguous infix expression
18:49:28 <erisco> it really doesn't matter at that point, xzhu, because it is at a complication where a new definition is worthwhile
18:49:40 <xzhu> @let gang f = uncurry zip . ((uniq . map f) &&& (groupBy ((==) `on` f)))
18:49:42 <lambdabot>  .L.hs:173:26: error:
18:49:42 <lambdabot>      Variable not in scope: uniq :: [(a1, a)] -> [a1]
18:49:42 <lambdabot>      |
18:49:45 <xzhu> ...
18:49:46 <erisco> never mind the horrors of how many list passes that is, if such things keep you up at night
18:53:12 * hackagebot b9 0.5.34 – A tool and library for building virtual machine images. – https://hackage.haskell.org/package/b9
19:01:18 * hackagebot b9 0.5.35 – A tool and library for building virtual machine images. – https://hackage.haskell.org/package/b9
19:01:27 <erisco> on the other hand,  groupBy == \f -> fmap (uncurry (fmap . (,))) . gangBy f
19:01:53 <erisco> which is not trivial but it is better than the other way around
19:07:44 <byorgey> erisco: Your 'gang' function feels very reminiscent of http://hackage.haskell.org/package/discrimination
19:09:16 <erisco> huh, I have not seen that library before … can ask ekmett if it fits
19:09:59 <erisco> edwardk, does http://lpaste.net/358592 fit your discrimination library?
19:10:01 <c_wraith> you missed the O(n) sorting library? :P
19:11:15 <erisco> ha, I missed that part… well, radix sort is linear for a fixed word size, and sorts that have more available than a compare …
19:11:44 <byorgey> yes, the point is that pretty much *everything* has more available than a compare.
19:12:10 <c_wraith> it's more or less a radix sort by constructor tags. except top-down instead of bottom-left.
19:12:32 <c_wraith> er. bottom-up
19:12:36 <erisco> definitely a bookmark
19:12:59 * byorgey had been wondering whether 'bottom-left' was some technical term for a particular style of radix sort
19:13:31 <c_wraith> just autocorrect going awry
19:16:32 <c_wraith> though, you know.. it's actually O(n log n) in the sense that to have n distinct entries, you need to examine log n bits to distinguish them, on average.
19:16:57 <c_wraith> but that same analysis applies to comparison based sorts and hash tables, too.
19:17:19 <c_wraith> and really upsets people when you point it out, because it's not what they were taught.
19:18:17 <`Guest00000> are there parsers or generally monads that are of the form `(a, Maybe ())`, that is, they provide the answer and the error coding independently? applied to writer, this would be `(a, Maybe w)`; applied to state, this would be `s -> (a, Maybe s)`
19:18:42 <`Guest00000> are the libraries like this or programs that use this
19:19:17 <erisco> something something word machine
19:20:03 <c_wraith> `Guest00000, sure, it happens all the time with MaybeT. you just have to be careful about the order you compose the transformers in.
19:20:47 <c_wraith> MaybeT (State s) is different from State s Maybe
19:20:58 <c_wraith> er. StateT s Maybe
19:21:32 <`Guest00000> can you provide an example of a complete type with MaybeT which has the construction `(a, Maybe ())`, where `a` is the monad parameter?
19:22:00 <c_wraith> Oh. wait, why do you want that?
19:22:16 <c_wraith> Maybe () is the same as Bool
19:22:26 <c_wraith> (for most practical purposes)
19:22:41 <`Guest00000> i want to have answer earlier than i generally can know the error state
19:22:50 <`Guest00000> c_wraith: okay, `s -> (a, Maybe s)`
19:25:03 <c_wraith> I mean, you can write a Monad instance for that if you constrain s somewhat, but I'm still not convinced of the utility. I don't think that appears in any libraries.
19:25:08 <erisco> c_wraith, I see you are aware to couch that statement in "on average"
19:25:38 <c_wraith> erisco, sure, you can always have two short elements, but they must be outnumbered by longer ones.
19:25:57 <`Guest00000> my parser is of the form `things = many thing` and i want to have the lazy list of things; it will never fail, because `many` never fails, although (it seems that) if the monad/applicative doesn't have the specific support for this, you can't implement `many` in such a way that allows to "promise" the program that `many` will never fail, so you can get answers earlier than error state
19:27:11 <`Guest00000> so when you force the fst of the tuple, you have the lazy list; when you force the snd, you walk through the whole input and have the final state
19:28:08 <`Guest00000> when you force the fst of `empty`, you get an error
19:28:20 <`Guest00000> (when you force the snd of `empty`, you get Nothing)
19:28:33 <`Guest00000> does this exist anywhere?
19:28:38 <erisco> c_wraith, can you recommend a source of information theory which is not encrypted in notations?
19:29:00 <erisco> I bought a book and it is unfortunately precisely that
19:29:30 <erisco> … became a monumental effort to decipher and decode what was being said
19:30:01 <Hafydd> Would you prefer if everything were expressed in prose, like in the Dark Age?
19:30:23 <c_wraith> erisco, not really. Shannon's original papers from Bell Labs are available now, and have to be pretty clear because they're inventing everything.
19:30:33 <erisco> just something a little more digestible by the modern computer programmer
19:30:43 <c_wraith> but the ones that have been declassified are all foundational rather than advanced
19:39:41 <`Guest00000> but it's not clear how to rewrite this for [] instead of Maybe
19:40:22 <`Guest00000> because there are already many results
19:56:49 <texasmynsted> any vim users know if there is a way to get syntastic to show warnings like the ones I have defined in my foo.cabal file, like -Wincomplete-patterns
19:57:16 <texasmynsted> It shows some, like absent signatures, but not incomplete-patterns.
19:58:38 <texasmynsted> maybe this is more of a vim question.
20:13:19 * hackagebot accelerate 1.1.0.0 – An embedded language for accelerated array processing – https://hackage.haskell.org/package/accelerate
20:35:37 * hackagebot servant-snap 0.8.0.1 – A family of combinators for defining webservices APIs and serving them – https://hackage.haskell.org/package/servant-snap
20:39:23 <Alovenom_> Heyo
20:39:49 <texasmynsted> o/ Alovenom_ 
20:39:56 <Alovenom_> Does anyone have a good and simple solution for loading and playing sound files with haskell ?
20:40:11 <Alovenom_> I know how to use csound-expression but it seems really overkill for what I want to do
20:40:42 <Alovenom_> ALUT is deprecated and I can barely find recent exemples for OpenAL but I'm still looking into it atm
20:48:02 <Axman6> Alovenom_: is https://hackage.haskell.org/package/hsndfile helpful?
20:49:33 <Alovenom_> thank you, I will look.
20:59:35 <anohigisavay> hi. a question about parsec. why `try` is need in `manyTill anyChar (try (string "-->"))`?
20:59:59 <anohigisavay> the doc says "Note the overlapping parsers anyChar and string "-->", and therefore the use of the try combinator."
21:00:13 <anohigisavay> but i don't understand what it means
21:00:17 <c_wraith> anohigisavay: so that on the input "------->" you get back "-----"
21:00:22 <Axman6> because if the string parser consumed _any_ data, they it is not considered to have failed, IIRC
21:00:31 <anohigisavay> OH i see!
21:00:34 <anohigisavay> thank you!
21:01:18 <c_wraith> without the try, you'd actually get a parse failure error with Parsec
21:02:18 * hackagebot kraken 0.1.0 – Kraken.io API client – https://hackage.haskell.org/package/kraken
21:19:38 <DijonMustard> So I'm thinking about start a functional programming club at my university. Advice?
21:20:36 <proofskiddie> Scala may be a good segue language, if you have people familar with java
21:20:59 <proofskiddie> assuming people at your uni generally know little about fp
21:21:47 <jle`> DijonMustard: have fun with it! :D
21:21:51 <jle`> it'll make a difference
21:22:56 <DijonMustard> Dude, I go to UT. I'm gonna fucking link to dijkstra's letter to administration in my post. But I am not familiar with Scala at all
21:23:44 <DijonMustard> https://www.cs.utexas.edu/users/EWD/transcriptions/OtherDocs/Haskell.html
21:24:45 * hackagebot accelerate-llvm 1.1.0.0, accelerate-llvm-native 1.1.0.0, accelerate-llvm-ptx 1.1.0.0
21:24:45 * hackagebot  → https://hackage.haskell.org/packages/recent
21:24:49 <proofskiddie> soo .. did they switch to java?
21:25:05 <DijonMustard> yup. I'm in the eletrical/computer engineering department
21:25:12 <proofskiddie> nooooo
21:25:27 <DijonMustard> you start with ARM/C then c++
21:25:28 <DijonMustard> then java
21:25:31 <DijonMustard> haha
21:25:56 <DijonMustard> but even the cs department does c# + whatever
21:26:01 <DijonMustard> but no haskell, trust me, I checked
21:26:03 <proofskiddie> well if the know quicksort, the haskell quicksort is black magic and easy to understand. might be a good motivating example if you have a call out
21:27:11 <Alovenom_> I'm teaching java where I am... really makes you appreciate typeclasses
21:28:26 <DijonMustard> Yeah man, I also like the powerset example: f = filterM (const [True, False])
21:28:38 <Alovenom_> Showing the flexibility you can gain from the typesystem is also a good lure for java programmers (unless they're already rigidly thinking in objects )
21:29:07 <Alovenom_> you can also start from the lambda java functionalities and go, there's a whole world out there...
21:29:17 <DijonMustard> idk man, I used to think in objects too. Infact, I still do. But I did a project over the summer that completely changed my prespective
21:30:26 <DijonMustard> I think the hardest part of going from a strict OOP language to a language like Haskell or even fucking Rust is insately difficult
21:30:40 <DijonMustard> Changing the way you think about "
21:30:43 <DijonMustard> classes"
21:30:48 <DijonMustard> in the strictess sense
21:31:10 <jle`> ugh why is there no python source file parser that works for ghc 8.2 :'(
21:31:22 <jle`> that's what i get for being an early adopter
21:31:48 <Alovenom_> I'd agree Dijon
21:31:59 <Alovenom_> oh
21:32:07 <Alovenom_> what else does ghc 8.2 break ?
21:32:28 <proofskiddie> I have a problem with how classes are taught, at least at my school. The examples were always contrived. Here is a house class, it has an int address and ..., but no matter how awesome my code is it will never be like an ... actual house
21:32:48 <Alovenom_> yeah
21:32:52 <proofskiddie> why not implement actual things, like lists and maps and so forth!
21:33:01 <Alovenom_> I think they're good in the very very beginning
21:33:13 <Alovenom_> but then show actual things
21:33:21 <proofskiddie> ^
21:33:30 <Alovenom_> you're not really trying to recreate a thing that exists
21:33:36 <Alovenom_> just implement behaviors
21:34:11 <jle`> i think it's actually a happy issue, not a ghc 8.2 issue
21:34:26 <Alovenom_> I love that sentence
21:34:45 <DijonMustard> The thing I'm worried about is, how do I show how important a strong type system is within and hour?
21:35:10 <proofskiddie> show that wat video
21:35:29 <DijonMustard> ?
21:35:31 <proofskiddie> https://www.destroyallsoftware.com/talks/wat
21:36:49 <Alovenom_> hah
21:37:27 <mbrock> then maybe suggest that static types are a matter of engineering, kind of like CAD telling you that your structure just doesn't make sense, or something
21:38:55 <DijonMustard> holy shit, I've never seen that
21:39:53 <mbrock> though it's not just about checking for errors, but also giving you the language tools to discuss and show what your program is all about
21:40:58 <DijonMustard> ok does anyone know how to explain the batman thing in the destroyallsoftware video?
21:41:33 <proofskiddie> you mean why it prints Nan?
21:41:38 <DijonMustard> yeah
21:41:51 <DijonMustard> I've never done any js stuff
21:42:12 <proofskiddie> I imagine its converting the string to an int and then overflowing or something like that, never done js either
21:42:13 <kadoban> JS has *weird* type coersion rules, that's pretty much the only explanation
21:42:42 <DijonMustard> yeah... I guess... I've seen the []etc stuff
21:43:01 <c_wraith> proofskiddie: javascript has no ints. all numerical values are doubles.
21:43:15 <proofskiddie> oh ok, well same idea
21:43:36 <Alovenom_> I actually like js
21:43:38 <kadoban> Yeah, also that. So probably something about it tries to convert "wat" to a number, because it has to subtract 1, it's not a number, then NaN is sticky
21:44:05 <kadoban> I like JS too. It's a pretty wacky language in a lot of ways though.
21:44:19 <Alovenom_> ye
21:44:35 <DijonMustard> lol
21:45:08 * mbrock writes JS using mostly functions of the kind ({ a, b, c, ... }) => ({ x: a + b, y : c })
21:45:39 <DijonMustard> What do you guys think about Idris? Why doesn't haskell have dependent types?
21:45:46 <mbrock> it's a pretty okay expression-oriented functional language with extensible records, if you squint :P
21:47:22 <c_wraith> DijonMustard: when Haskell was created, it was mostly abut unifying all the work being done on lazy functional programming at the time.  Dependent types really weren't being used much back then.
21:48:15 <c_wraith> DijonMustard: regardless of that, there is an ongoing project to add real dependent typing to Haskell, but the completion date is scheduled years in the future, and it's not going to be much like any other dependently-typed language.  (If it's completed as the design currently stands)
21:48:29 <DijonMustard> So is laziness the reason why haskell can't have a depent type pragram?
21:48:35 <DijonMustard> pragma&
21:48:43 <mbrock> in my experience, Haskell programmers are typically aware of and appreciative of dependently typed languages like Idris and Agda, but continue working with Haskell as a pragmatic choice
21:49:35 <c_wraith> Laziness doesn't prevent dependent typing.  I mentioned it to point out that Haskell wasn't intended to duplicate the work in the ML family, but rather to unify and standardize language like Miranda
21:49:38 <DijonMustard> Sorry, I didn't make any sense. Is laziness making a dependent type system more difficult?
21:50:31 <c_wraith> Miranda is the one I can remember the name of, anyway.  There were a bunch more in the late 80s
21:52:18 <c_wraith> Wow.  The first meetings of what led to the creation of Haskell were 30 years ago this month, according to Being Lazy With Class
21:53:01 <proofskiddie> https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/history.pdf
21:54:59 <c_wraith> DijonMustard: in any case, my point was that Haskell was created to unify a family of existing languages, and none of them had dependent typing.
21:58:26 <DijonMustard> Right. I'm just curious why Haskell doesn't have dependent typing at this point. Is it because of laziness?
21:59:36 <c_wraith> laziness has a small impact.  much bigger factors that make it difficult are being turing-complete and having a strong desire to make as much as possible work with type inference
22:00:42 <monochrom> DijonMustard: The Batman reference is because the 1960s TV series (so, played by Adam West who passed away recently, now literally Holy Batman) theme song lyrics went like "na na na na na na na na na Batman!"
22:00:55 <DijonMustard> I get that monochrom haha
22:01:01 <monochrom> Ah OK good.
22:01:10 <DijonMustard> I just don't get why javascipt outputs that vs the + haha
22:01:30 <c_wraith> like, if adding dependent typing broke type inference in code that didn't use the feature, that would pretty much be an automatic rejection.
22:05:27 <anohigisavay> how to consume all spaces except newlines and eof in parsec?
22:08:16 <glguy> EOF isn't something you can consume in parsec, and you can use  skipMany (char ' ')
22:11:38 <anohigisavay> glguy, i see the space parser can consume "any Unicode space character"
22:11:48 <anohigisavay> glguy, i think it's not only ' '
22:14:09 <anohigisavay> glguy, i can go with `skipMany (oneOf " \t")` for now but maybe it's better to stick with the that same behavior
22:17:56 <Axman6> > show (filter isSpace [minBound..])
22:17:59 <lambdabot>  "\"\\t\\n\\v\\f\\r \\160\\5760\\8192\\8193\\8194\\8195\\8196\\8197\\8198\\81...
22:19:47 <anohigisavay> Axman6, wow_(:з」∠)_
22:19:50 <opqdonut> hehe
22:20:18 <Axman6> probably didn't need the show...
22:20:22 <Axman6> > (filter isSpace [minBound..])
22:20:25 <lambdabot>  "\t\n\v\f\r \160\5760\8192\8193\8194\8195\8196\8197\8198\8199\8200\8201\8202...
22:22:18 <anohigisavay> i can do (oneOf $ drop 2 $ filter isSpace [minBound..]) _(:з」∠)_
22:22:25 <Alovenom_> way harder to play a sound file than i'd thought
22:22:34 <Alovenom_> I wonder if I could just use FFI for that
22:24:49 <`Guest00000> are there any tools in haskell for making websites which both work dynamically with JavaScript and non-dynamically, refreshing-and-cookie-settingly without JS?
22:26:51 <`Guest00000> like, output a message on page which can be closed by a button with JS or by a submit button / link with refresh?
22:26:59 <`Guest00000> ?^H
22:26:59 <lambdabot> Maybe you meant: wn v rc pl id do bf @ ? .
22:28:43 <dmj`> `Guest00000: miso can do this, if you use it’s pre-rendering support (ala “isomorphic” javascript)
22:29:13 <dmj`> @package miso
22:29:13 <lambdabot> http://hackage.haskell.org/package/miso
22:30:30 <dmj`> `Guest00000: https://github.com/FPtje/miso-isomorphic-example is an example
22:33:42 <saurabhn_> is there any data structure in haskell that wraps an existing value, allows one to use the value normally (i.e. all lenses work, record updates work, etc.) BUT can give you back the original value AND the changed value at any point in time?
22:34:45 <saurabhn_> or, is there any built-in way, to get the parent value which was used to construct a new immutable value?
22:36:23 <Alovenom> I don't get what you mean
22:36:41 <saurabhn_> Alovenom: which question?
22:36:49 <Alovenom> 1st
22:37:12 <Alovenom> can't you just store the value somewhere upon creation ? what's the context
22:37:38 <Alovenom> either in a monad or in a parent object
22:38:12 <saurabhn_> data Trackable a = Trackable a; let myrec = Trackable $ MyRec{field1=.., field2=.., field3=..}; let myrec2 = myrec{field3=..}; (originalValue myrec2 == myrec)
22:38:32 <saurabhn_> ^^ that's the idea.
22:38:43 <`Guest00000> ahh
22:38:46 <`Guest00000> everything's too big
22:39:38 <c_wraith> saurabhn_: do you want a full history, or just the original and current?
22:39:47 <saurabhn_> c_wraith: original and current.
22:40:21 <`Guest00000> i don't know what's worse by me: deciding to write my own, minimal things, piling more work to further increase the chances of not finishing the project, or using existing libraries
22:41:21 * hackagebot mole 0.0.6 – A glorified string replacement tool – https://hackage.haskell.org/package/mole
22:41:47 <dmj`> saurabhn_: sounds like a Reader and a State
22:41:49 <c_wraith> saurabhn_: Well, you could just use (,) and do all the modifications with _2 as the first lens
22:41:58 <dmj`> where both contain the initial value
22:42:35 <saurabhn_> c_wraith: that makes working with the tracked object harder and error prone. Nothing stops me from erroneously changing the original value, right?
22:42:52 <dmj`> saurabhn_: if you use a Reader you can’t change it
22:43:20 <saurabhn_> dmj`: how many readers will one use? how does one compose this?
22:43:22 <saurabhn_> eg.
22:44:58 <saurabhn_> do; order <- fetchByPk orderId_; lineItems <- filterTable1 tableForLineItems ((orderId, pgEq, orderId_)); orderChanged <- patch order incomingOrder; lineItemsChanged <- patch lineItems incomingLineItems
22:45:20 <saurabhn_> how would I use reader and state monads in code like this?
22:45:43 <dmj`> saurabhn_: can you paste your code on lpaste.net
22:46:34 <saurabhn_> dmj`: I'm making a DB access library. The save function needs to know what changed in the original record so that it writes out only the changed fields to the DB.
22:46:54 <saurabhn_> dmj`: would an lpaste help in this case?
22:47:45 <saurabhn_> the simplest way of doing this is to pass original and changed values to the save function, but that simply puts the mental overhead on the programmers, and open up another bug vector which is *extremely* simple to hit (you pass the wrong version of the original value).
22:50:45 <dmj`> saurabhn_: so you’re diffing records
22:50:55 <saurabhn_> dmj`: yes.
22:52:23 * hackagebot colour-accelerate 0.2.0.0 – Working with colours in Accelerate – https://hackage.haskell.org/package/colour-accelerate
22:55:16 <dmj`> saurabhn_: might take a look at gdiff 
22:55:21 <dmj`> @package gdiff
22:55:21 <lambdabot> http://hackage.haskell.org/package/gdiff
22:55:48 <saurabhn_> thanks for gdiff, dmj`
22:55:53 <saurabhn_> but the problem is not computing the actual diff
22:56:27 <saurabhn_> the problem is *correctly* passing the original value along with every changed value, so that one can obtain the original value from the changed value at any point in the computation.
22:58:48 <Alovenom> you want a blockchain basically ?
23:00:43 <`Guest00000> saurabhn_: "bug vector" use newtypes `newtype A a = A { getA :: a }`, `newtype B b = B { getB :: b }`?
23:01:18 <Alovenom> oh nvm read wrong
23:01:37 <`Guest00000> and don't unwrap them in the dangerous area
23:04:12 <saurabhn_> is there no way to hide the internal works of something in FP/Haskell?
23:04:19 <saurabhn_> *internal workings
23:04:27 <saurabhn_> `Guest00000: didn't understand.
23:05:00 <mbrock> there is, but maybe not exactly like you want. I can't see how to make existing lenses work as if you hadn't changed the type by adding the extra original value
23:05:00 <Alovenom> one sec
23:05:17 <`Guest00000> saurabhn_: wrap the original in A, changed in B in the caller; then they will have different types; don't unwrap them in the callee, and you're safe?
23:05:25 <mbrock> but if you define a lens for the current value, it'll still be convenient to use
23:05:26 <`Guest00000> values *
23:06:11 <mbrock> furthermore you might hide the field of the original value from users of your library using the module system (say, only exporting it from a `Foo.Internal` module)
23:06:37 <mbrock> you could also define a `Functor` instance that only works on th current value, for example
23:07:15 <cocreature> saurabhn_: if all you want to do is pass the original value along, that sounds very much like Reader
23:07:37 <saurabhn_> cocreature: how many readers is one going to define? 
23:07:40 <dmj`> cocreature: +1
23:07:53 <saurabhn_> do; order <- fetchByPk orderId_; lineItems <- filterTable1 tableForLineItems ((orderId, pgEq, orderId_)); orderChanged <- patch order incomingOrder; lineItemsChanged <- patch lineItems incomingLineItems
23:08:04 <saurabhn_> ^^ how do you generalise the reader for code that looks like that
23:08:09 <dmj`> but he wants the original and to modify it, so maybe a reader + state
23:08:25 <dmj`> :t \(originalValue :: Int) -> flip runReaderT originalValue $ flip evalStateT originalValue $ do { orig <- ask; modify (+1); newVal <- get; pure (orig, newVal) }
23:08:27 <lambdabot> Monad m => Int -> m (Int, Int)
23:08:30 <saurabhn_> you have a reader for Order, separate reader for LineItem, separate reader for Payment, etc?
23:08:32 <glguy> Neither Reader nor State seem relevant to me
23:08:37 <cocreature> ah yeah Reader doesn’t work in that case
23:09:49 <cocreature> you could do something like "data WithOriginal a = WithOriginal { original :: !a, changed !a }" and then have the functions that modify the values return a WithOriginal with the value that’s passed in
23:12:14 <mbrock> yes, and how about defining `instance Functor WithOriginal where { fmap f (WithOriginal o c) = WithOriginal o (f c) }`
23:12:42 <cocreature> mbrock: that doesn’t typecheck at least for my definition of WithOriginal
23:12:54 <mbrock> ahh, yeah, sorry
23:13:10 <Alovenom> something like this ? http://lpaste.net/8558560929644544000
23:14:07 <Alovenom> oh, sorry for the "SF" it's because I originally called "KeepOriginal" "Safeguard"
23:14:43 <Alovenom> I guess it'd be annoying to use lenses with that tho
23:15:27 <saurabhn_> so, it seems none of the obvious solutions can keep the call-sites uncluttered, right. The mechanism of tracking is essentially going to "leak" all over the place?
23:16:49 <Alovenom> well, you can write your own functions.
23:17:08 <Alovenom> operators, I mean
23:17:22 <Alovenom> then it's not uncluttered. Just not the same ones
23:18:59 <mbrock> say your value is an Integer and you have `factorial :: Integer -> Integer`. There's no way that function is going to work unchanged with a new type `WithOriginal Integer` that actually contains two Integers, at least not in regular Haskell (there might possibly be some unsafe hack, but I doubt it)
23:19:29 <Alovenom> can't you extend the typeclasses
23:19:57 <Alovenom> for it to work with only the fresh value
23:19:58 <mbrock> but using lenses, the code to operate only on the current value will at least not be horrible
23:20:18 <Alovenom> but you would have to write a very long amount of code
23:20:43 <Alovenom> if you are absolutely fixated on using the exact same function as if it wasn't wrapped
23:20:58 <Alovenom> and you want your WithOriginal type to be general
23:21:02 <Alovenom> generic*
23:21:10 <Alovenom> still, it's possible
23:21:13 <mbrock> Integer isn't a typeclass, so it still wouldn't work in this case :)
23:21:18 <Alovenom> aw
23:21:41 <Alovenom> isn't Integral one
23:23:06 <Alovenom> ya
23:56:09 <[exa]> Is there some implementation of SCC algorithm for Data.Graph that would also output the graph components in topological order?
23:56:38 <[exa]> (purpose: convert [Impl] to [[Impl]] for binding group type inference)
