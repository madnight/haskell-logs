00:05:01 <dminuoso> I remember there was some book people repeatedly recommended for functional algorithms, which is it?
00:05:32 <cocreature> dminuoso: maybe “pearls of functional algorithm design”
00:06:05 <cocreature> dminuoso: or if you’re more interested in data structures “purely functional data structures”
00:06:37 <DigitalKiwi> oh that sounds fun
00:06:43 <dminuoso> cocreature: Ah, both look like something to pick up.
00:07:08 <dminuoso> cocreature: Okasaki looks really old, is it still applicable?
00:07:25 <DigitalKiwi> https://perl.plover.com/yak/fp/ I'm not sure if I'm inclined to read this or not read this :|
00:07:30 <cocreature> dminuoso: I have admittedly not read that book but I’m pretty sure it still is.
00:10:34 <halogenandtoast> Is there a cleaner way to write:     findKey v m = find (\k -> Map.lookup k m == Just v) (Map.keys m)
00:11:05 <halogenandtoast> I feel like there should be something built in for this
00:12:16 <phadej> findKey v m = listToMaybe [ k | (k, v') <- Map.toList m, v == v' ]
00:12:29 <cocreature> kind of looks like you’re using the wrong data structure tbh
00:12:41 <phadej> also that ^
00:12:53 <halogenandtoast> cocreature: I'm trying to build a map of adjacent regions, but I want these regions to have labels
00:13:07 <halogenandtoast> so I was trying to find adjacent regions
00:13:24 <cocreature> if you need bidirectional lookups wrap two maps in a custom type and make sure they are updated appropriately
00:13:45 <phadej> like http://hackage.haskell.org/package/bimap
00:13:54 <halogenandtoast> That's what I had I believe
00:13:54 <halogenandtoast> data World = World (Map Int Area) Graph
00:14:06 <cocreature> phadej: ah I was just about to search on hackage for that :)
00:14:14 <halogenandtoast> Graph is just type Graph = Map Node [Node]
00:14:24 <phadej> cocreature: trustee's perk, you accumulate knowledge about "what's on Hackage" ;)
00:14:52 <cocreature> heh
00:14:56 <halogenandtoast> looking at bimap for use or ideas
00:15:35 <halogenandtoast> Oh right, I do not have a bidirectional map
00:15:40 <halogenandtoast> I see what you are saying
00:16:34 <cocreature> if you give us a bit more info, we might be able to provide other solutions. reverse lookups on a Map just feel very wrong :)
00:17:29 <halogenandtoast> I'm basically trying to implement a game that features a map with adjacent areas. For example North America is adjacent to South America, North Atlantic, North Pacific, and the Arctic Ocean (in this game at least)
00:17:57 <halogenandtoast> so given an area, I want to find what's adjacent and print the labels
00:18:41 <halogenandtoast> areas have other attributes I want to store as well
00:18:54 <halogenandtoast> aside from name. For instance whether it is land or ocean
00:19:23 <halogenandtoast> and a list of special attributes (for map specific game effects)
00:19:53 <halogenandtoast> right now, for better or worse, I have something like: northAmerica = Area "North America" Land []
00:19:56 <cocreature> what defines if two areas are adjacent? is it just coordinates on a grid or is it some arbitrary graph with edges that define adjacency?
00:20:22 <halogenandtoast> It's up to me to define the storage for this, I was doing it with edges.
00:20:59 <halogenandtoast> I currently have a list of edges     edges = [ (1, 2), (1, 9), (1, 3), (1, 15)
00:21:10 <halogenandtoast> which I build "earth" with:     earth = foldr addNode emptyGraph [1..17]
00:21:11 <cocreature> so basically your problem boils down to, given a node in a graph find all adjacent nodes?
00:21:24 <halogenandtoast> cocreature: yes :[
00:21:45 <halogenandtoast> CS1 stuff, but it's unfamiliar Haskell (or functional) territory for me.
00:21:53 <cocreature> can’t you just do a simple lookup in your "Map Node [Node]" for that?
00:22:31 <halogenandtoast> Node are currently Int, I support they could be Areas
00:22:35 <halogenandtoast> *suppose
00:23:15 <cocreature> ah so you are using the reverse lookup on "Map Int Area" to find the Int corresponding to an Area?
00:23:23 <halogenandtoast> but if I leave Node alone, I need to take an Area, find the corresponding Node (Int), for that Node, lookup the neighbors (Nodes) and convert them to Areas again
00:23:39 <cocreature> can you make "Map Int Area" bidirectional?
00:23:46 <halogenandtoast> cocreature: sure why not
00:23:50 <cocreature> or just store the Int in the "Area" itself
00:24:05 <cocreature> then you don’t need to do these reverse lookups
00:24:36 <halogenandtoast> cocreature: Storing the int in the area feels a little weird to me since the Int is not directly tied to the area
00:24:49 <halogenandtoast> only using it for convenience of storage if I do that.
00:24:58 <cocreature> halogenandtoast: well make something like "data WithId a = WithId !Int !a"
00:25:26 <halogenandtoast> okay, I suppose that makes sense
00:26:09 <halogenandtoast> thanks cocreature!
00:26:17 <halogenandtoast> I'll mess around with this and see where I get.
00:48:59 <AndChat181649> hello
01:02:09 <halogenandtoast> cocreature: does this adjacentTo look reasonable? http://lpaste.net/358215#line130
01:04:11 <cocreature> halogenandtoast: you still seem to be doing a linear scan to find the id instead of some logarithmic lookup in a map. that doesn’t seem like a good idea.
01:06:45 <cocreature> halogenandtoast: in your actual game, do you really only have the "Area" when you need to find adjacent areas? I would expect that you would have the id at this point as well since you probably don’t make up an area out of thin air.
01:07:40 <halogenandtoast> I suppose I have the id
01:08:52 <cocreature> halogenandtoast: basically I would try to refactor your code such that you just work with ids for almost everything and only when you actually need the info stored in an Area you do lookups in a map
01:09:07 <halogenandtoast> okay something more akin to: adjacentTo (World g as) a = fromMaybe [] $ Map.lookup a g >>= mapM (`Map.lookup` as)
01:09:17 <halogenandtoast> except this can just return the ids and can translate them later
01:09:50 <halogenandtoast> so adjacentTo becomes just a lookup
01:10:49 <cocreature> exactly
01:11:09 <halogenandtoast> alright, I suppose that keeps it rather simple.
01:11:18 <cocreature> try to postpone the conversion to Area as far as possible
01:12:34 <halogenandtoast> Okay updated to do conversion at the last possible second.
01:14:15 <halogenandtoast> cocreature: thanks again
01:14:49 <cocreature> halogenandtoast: you might also want to look into "fgl" for handling your graphs
01:15:29 <cocreature> if a lookup is all you need, it’s probably overkill but once you start implementing graph algorithms, it’s definitely worth a look
01:15:33 <halogenandtoast> yeah someone mentioned that before, I was just trying to do something simple.
01:16:03 <halogenandtoast> The only thing I'll need to be able to do is lookup neighbors, and neighbors 2 steps away
01:16:52 <halogenandtoast> I actually couldn't figure out how to build a graph with fgl so I gave up. Couldn't find good examples.
01:17:04 <halogenandtoast> I might not have looked hard enough
01:17:44 <cocreature> heh, funnily enough I was contemplating writing a blogpost on fgl
01:18:09 <halogenandtoast> cocreature: am I supposed to build my own graph and just make it an instance of Graph or DynGraph?
01:18:29 <cocreature> no fgl provides instances for a type called "Gr"
01:18:52 <halogenandtoast> Yeah I thought so, but when I tried to use Gr it wasn't imported, and then I think I gave up
01:19:00 <halogenandtoast> probably could have looked up where that's defined.
01:19:45 <halogenandtoast> ? Data.Graph.Inductive.PatriciaTree
01:19:54 <halogenandtoast> that doesn't seem intuitive
01:21:20 <cocreature> "Data.Graph.Inductive" reexports that type
01:22:38 <halogenandtoast> lol hard to tell from: https://hackage.haskell.org/package/fgl-5.6.0.0/docs/Data-Graph-Inductive.html
01:22:47 <cocreature> yeah haddock seems to screw up badly here
01:25:45 <TiD91> Hello! I wanted to ask what is the suggested method to install Haskell in non-standard locations (i.e. not having admin rights so installing, for example, in $HOME/.local)? Building from sources? Because the precompiled bindist assumes to be resident however in /usr/local...
01:28:15 <FerdinL> does all 'if' statment can convert to 'guard' ?
01:35:51 <halogenandtoast> in type LEdge b = (Node, Node, b) what is b supposed to be here?
01:36:24 <halogenandtoast> I assume my own data type if I want to store information about the edge? Like weight?
01:37:28 <geekosaur> FerdinL, if isn't a statement, it's an expression. and the language report defines it in terms of case directly, but it can equivalently be done as a guard in a case expression
01:37:43 <geekosaur> however you may mean a guard in some particular context; I can't tell
01:38:54 <geekosaur> (the generic guard desugaring would be: if expr then ifTrueExp else ifFalseExp   ===>   case () of () | expr -> ifTrueExp | otherwise -> ifFalseExp
01:40:12 <FerdinL> I want to konw wether I should perfer to use guard?
01:40:15 <geekosaur> or if you meant the guard combinator, then no because if is more general --- it can produce any type
01:40:20 <geekosaur> whereas
01:40:23 <geekosaur> :t guard
01:40:25 <lambdabot> Alternative f => Bool -> f ()
01:40:39 <cicolus> Hi everyone! Haskell newbie here, I'm working my way through learn you a haskell but really got stuck on this one: (+) <$> (+3) <*> (*100) $ 5, could anyone give me some insights on how to understand this?
01:41:08 <FerdinL> guard looks more elegent, I thought..
01:42:04 <geekosaur> I generally find it less useful because I have to be able to use it in Alternative situation, whereas if can be used anywhere
01:42:14 <ventonegro> cicolus: Did you look at the types piece by piece?
01:42:30 <ventonegro> :t (+) <$> (+3)
01:42:32 <lambdabot> Num a => a -> a -> a
01:42:40 <geekosaur> it is something of a pity that we have "guard" and we have guards, so your question was ambiguous...
01:42:54 <cicolus> yeah, that's where I got stuck, I don't know how that's derived
01:43:50 <geekosaur> also wanting to use guard and therefore Alternative kinda smacks of wanting to pretend you're programming imperatively instead of declaratively
01:44:34 <ventonegro> cicolus: Yes, it's a bit tricky. (<$>) is `fmap`, and then the functor is a function, it's just function composition
01:44:35 <Philonous> cicolus, The trick here is that ((->) r) has an Applicative instance. 
01:45:12 <ventonegro> :t (+1) <$> (*5)
01:45:14 <lambdabot> Num b => b -> b
01:45:32 <halogenandtoast> Not sure why LYaH would ever show anybody that.
01:45:37 <geekosaur> cicolus, the ((->) r) instance is fairly mind-bending until you get used to it
01:45:38 <ventonegro> > (+1) <$> (*5) $ 42
01:45:41 <lambdabot>  211
01:46:30 <`Guest00000> :t ((+) <$>)
01:46:32 <lambdabot> (Num a, Functor f) => f a -> f (a -> a)
01:46:34 <cicolus> okay, so basically (+) <$> (+3) is acting as if placing (+3) in one place of (+)?
01:46:39 <`Guest00000> :t ((+) <$>) :: [a] -> [a -> a]
01:46:41 <lambdabot> error:
01:46:41 <lambdabot>     • No instance for (Num a1) arising from a use of ‘+’
01:46:41 <lambdabot>       Possible fix:
01:46:59 <`Guest00000> :t ((+) <$>) :: Num a => [a] -> [a -> a]
01:47:01 <lambdabot> Num a => [a] -> [a -> a]
01:47:17 <`Guest00000> :t ((+) <$>) :: Num a => (a -> a) -> (a -> a -> a)
01:47:20 <lambdabot> Num a => (a -> a) -> a -> a -> a
01:47:21 <ventonegro> cicolus: It applies (+3) and then (+), but the last one is a partial application
01:47:37 <ventonegro> cicolus: Tha's where <*> comes into play
01:47:49 <ventonegro> :t (<*>)
01:47:50 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
01:48:26 <halogenandtoast> cocreature: updated to use fgl, wasn't as bad as I thought it would be: http://lpaste.net/358215
01:48:27 <ventonegro> :t ((+) <*>)
01:48:29 <lambdabot> Num a => (a -> a) -> a -> a
01:48:33 <halogenandtoast> thanks for the fgl pointers, it helped a lot
01:48:47 <cicolus> Okay, I will probably struggle with it a bit more, but thank you guys!
01:49:05 <halogenandtoast> cicolus: don't
01:49:07 <halogenandtoast> just keep going
01:49:35 <halogenandtoast> it's really not "that important"
01:50:04 <Philonous> cicolus, You can think of a function (a -> b) as a (possibly infinite) Map a b. That intuition helped me a lot to understand the Functor and Applicative instances for it
01:50:13 <halogenandtoast> at least in terms of functions being Functors
01:50:25 <ogrady> Why does Map.member expect my key type to be of type (Either Int Int)? https://pastebin.com/D6mcWtfN
01:51:29 <cocreature> halogenandtoast: you can probably simplify "buildEarthGraph" with "mkGraph"
01:51:49 <halogenandtoast> cocreature: probably, I'll check it out
01:52:11 <halogenandtoast> cocreature: ah yeah most definitely
01:52:43 <Philonous> ogrady, It seems that your "id" is of type Either Int Int but your Map has key type Int
01:52:56 <ogrady> Philonous: ah, that could be the case, thank you!
01:56:06 <halogenandtoast> cocreature: is there any way to turn my list of Edges into UNodes?
01:56:47 <halogenandtoast> aside from what I'm doing of course
01:56:59 <halogenandtoast> sorry not Unodes
01:57:01 <halogenandtoast> UEdges
01:58:50 <halogenandtoast> ah maybe `labUEdges`
02:00:13 <halogenandtoast> apparently Data.Graph.Inductive.Example isn't re-exported
02:00:16 <`Guest00000> is way of parsing haskell by straightforwardly translating the syntax rules from the specification to applicative/alternative code adequate?
02:10:53 <cocreature> halogenandtoast: not sure I understand that question. how do you want to convert Edges into UNodes? throw away one side of each edge? merge both sides?
02:11:18 <Jamaic> Hello. I'm learning haskell and I tried making mergesort. It works, but I wanna know what do you think about it -> https://pastebin.com/TKZwSTMQ
02:11:33 <halogenandtoast> cocreature: I clarified a line below I wanted Edge to UEdge
02:11:42 <cocreature> oh right :)
02:11:51 <halogenandtoast> there is a function in Data.Graph.Inductive.Example called labUEdge
02:11:54 <cocreature> yeah then "labUEdges" seems to be what you’re looking for
02:12:08 <halogenandtoast> Yeah, but that's not exported by default from Data.Graph.Inductive
02:12:13 <halogenandtoast> so I just used my own
02:12:15 <cocreature> just import the other module?
02:12:16 <halogenandtoast> it's a simple function
02:12:20 <cocreature> fair enough :)
02:12:47 <halogenandtoast> I don't trust something named Data.Graph.Inductive.Example to stick around or be consistant
02:13:05 <halogenandtoast> *consistent
02:13:36 <cocreature> *shrug* it doesn’t state that it’s some internal module so it’s probably pretty safe
02:14:40 <Ferdirand> Jamaic: i don't think using an accumulator is a good idea in this context
02:16:47 <Ferdirand> also lines 2 and 3 are quite suboptimal
02:22:13 <Jamaic> Ferdirand: I got rid of the accumulator and optimized those lines -> https://pastebin.com/321HPAtE
02:26:19 <halogenandtoast> If I want to parse out a specific field using Aeson is there any way to do that basically I have { area: [Area] } and I just want to get back [Area]
02:26:37 <halogenandtoast> or do I need some wrapper around the whole JSON object to do that
02:26:55 <jle`> you can parse it as a Map String [Area]
02:27:00 <jle`> and lookup the "area" key
02:27:27 <halogenandtoast> thanks jle` 
02:27:43 <jle`> np
02:28:26 <JJKKLLL> Is there any place I can ask newbie question?
02:28:43 <jle`> yes
02:28:45 <cocreature> JJKKLLL: yes this channel
02:28:45 <jle`> here :)
02:28:59 <jle`> this channel was explicitly designed for newbie questions
02:29:03 <JJKKLLL> thanks
02:29:11 <JJKKLLL> I have a question
02:30:03 <halogenandtoast> proceed
02:30:08 <JJKKLLL> I'm new to haskell, I follow this tut: http://www.cis.upenn.edu/~cis194/spring13/hw/01-intro.pdf, after reading chpter1, I almost did those excrise.
02:30:36 <JJKKLLL> I have question on ex2
02:31:24 <JJKKLLL> could you please point out that how can I design that function?
02:32:10 <mniip> immediately I can think of 2 different ways
02:32:15 <cocreature> JJKKLLL: what have you got so far?
02:32:29 <ventonegro> JJKKLLL: You can use pattern-matching to get every other element
02:32:40 <mniip> ventonegro, yeah it has to go from the right
02:32:47 <JJKKLLL> I have no idea how to get the list index
02:32:48 <ventonegro> mniip: Ah, sorry
02:32:55 <mniip> you kinda have to traverse the spine before you can produce the first element
02:33:36 <cocreature> JJKKLLL: start by writing a function that doubles every other element starting from the _left_
02:33:40 <mniip> JJKKLLL, well, one way to achieve this would be to reverse the input and implement a simpler function
02:33:54 <mniip> yeah, what cocreature is suggesting
02:33:55 <mniip> can you implement that?
02:34:02 <JJKKLLL> haskell really make me thought differently, but I still not  familiar with it.
02:34:56 <michi7x7> JJKKLLL: getting the index is easy
02:35:08 <michi7x7> > zip [1..] [4,5,8,2,1,6]
02:35:10 <lambdabot>  [(1,4),(2,5),(3,8),(4,2),(5,1),(6,6)]
02:35:31 <michi7x7> and then map with a function that takes (i,v) as argument
02:36:13 <ggVGc> haskell made me think differently. all of a sudden I was doing type theory instead of writing a program
02:37:17 <JJKKLLL> thanks all, I'm trying on it.
02:38:11 <halogenandtoast> Any suggestions on how to simplify this?     countries <- fromMaybe [] . Map.lookup ("regions" :: String) . fromMaybe Map.empty . decode <$> BS.readFile "earth.json"
02:42:26 <halogenandtoast> mniip: Actually I think you could avoid having to traverse the whole list if you just build two lists and return the correct one.
02:42:41 <halogenandtoast> before building the first element I mean
02:43:17 <michi7x7> halogenandtoast: like countries <- fromMaybe [] ( decode >>= Map.lookup "regions") <$> BS.readFile "earth.json" ?
02:44:43 <halogenandtoast> michi7x7: maybe? That doesn't type check for me, I also don't think I can get away from typecasting "regions" because of OverloadedStrings
02:44:48 <aarvar> Jamaic: you can still improve the first 3 lines
02:45:15 <mniip> halogenandtoast, I was thinking of a smarter version of that
02:45:17 <Jamaic> aarvar: how?
02:45:43 <mniip> a double traversal with a single recursion
02:46:00 <halogenandtoast> ggVGc: How often do people comment on your name?
02:46:07 <aarvar> Jamaic: get rid of the first line and remove the as patterns
02:46:09 <mniip> halogenandtoast, he's got a page about it
02:46:11 <ggVGc> not much anymore
02:46:17 <ggVGc> usef to be a lot
02:46:27 <cocreature> halogenandtoast: try replacing fromMaybe with maybe in michi7x7’s solution
02:46:54 <halogenandtoast> cocreature: no go, it's alright
02:46:54 <cocreature> personally I would also use `(Map.lookup "regions" =<< decode)` since I find it confusing to swap the order within a single expression but that’s a matter of taste
02:47:08 <mniip> @let doubleOther [] = ([], True); doubleOther (x:xs) = case doubleOther xs of (rs, e) -> ((if e then x else x * 2):rs, not e)
02:47:11 <lambdabot>  Defined.
02:47:16 <mniip> > doubleOther [1,2,3,4,5]
02:47:19 <lambdabot>  ([1,4,3,8,5],False)
02:47:30 <cocreature> halogenandtoast: what’s the error?
02:48:19 <halogenandtoast> https://gist.github.com/halogenandtoast/b2f89d124dd6f08e221005d570b5bd49
02:49:01 <michi7x7> > doubleOther [1,2,3,4]
02:49:03 <lambdabot>  ([2,2,6,4],True)
02:49:04 <aarvar> Jamaic: also, [x] ++ xs is the same as x : xs
02:49:14 <Jamaic> aarvar: done -> https://pastebin.com/PZT1rGAK ... also removed unused line #14
02:49:57 <halogenandtoast> cocreature: updated to have the source
02:51:08 <Jamaic> aarvar: oki, modified those too -> https://pastebin.com/JiJPPTCQ
02:52:14 <cocreature> halogenandtoast: “fromMaybe [] . (Map.lookup ("regions" :: String) <=< decode) <$> BS.readFile "earth.json"” should do the trick
02:52:18 <Jamaic> also, got rid of some redundant brackets https://pastebin.com/90E6RQ5x
02:53:38 <aarvar> Jamaic: also, the last function doesn't need to pattern match
02:53:59 <halogenandtoast> cocreature: yes it does
02:54:12 <halogenandtoast> Kleisli and I don't yet get along
02:54:27 <aarvar> and I would just use map rather than a list comprehension
02:55:04 <halogenandtoast> thanks cocreature and michi7x7 
02:56:16 <Jamaic> aarvar: got rid of redundat pattern matching -> https://pastebin.com/7SVfgvaa
02:56:32 <cocreature> halogenandtoast: "f <=< g" is just "\x -> f =<< g x" so if you understand the latter the former shouldn’t be too hard to understand
02:58:30 <halogenandtoast> okay, makes sense enough, still won't know when to use it just yet.
02:58:49 <cocreature> it’s very similar to (.)
02:58:51 <cocreature> :t (.)
02:58:53 <lambdabot> (b -> c) -> (a -> b) -> a -> c
02:58:53 <cocreature> :t (<=<)
02:58:55 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
03:00:06 <Jamaic> aarvar: agree with using map instead of list comprehension, it makes more sence -> https://pastebin.com/AZTszjhU
03:02:06 <halogenandtoast> cocreature: Ah neat, I'll try to watch for situations to use it
03:07:43 <aarvar> Jamaic: (\x -> [x]) can also be written as (: []), or you could use return
03:12:32 <ertes-w> @let chunks n f [] = pure []; chunks n f xs = let (xs1, xs2) = splitAt n xs in (++) <$> f xs1 <*> chunks n f xs2
03:12:34 <lambdabot>  Defined.
03:13:00 <ertes-w> > (reversed . chunks 2 . ix 0 *~ 2) [1..9]
03:13:03 <lambdabot>  [2,2,6,4,10,6,14,8,18]
03:13:17 <ertes-w> > (reversed . chunks 2 . ix 1 *~ 2) [1..9]
03:13:20 <lambdabot>  [1,4,3,8,5,12,7,16,9]
03:13:23 <Jamaic> aarvar: neat, didn't know I could write it that way, thanks ( https://pastebin.com/QGCxqmM0 )
03:14:07 <ertes-w> > (both . reversed . chunks 2 . ix 1 *~ 2) ([8,7,6,5], [1,2,3])
03:14:10 <lambdabot>  ([16,7,12,5],[1,4,3])
03:14:57 <ertes-w> Jamaic: (ignore me, i'm just lens-golfing)
03:16:05 <aarvar> Jamaic: also, mergesortalgo [] will loop infinitely
03:16:20 <aarvar> you avoid that by having a pattern match in the mergesort function, but that's not good
03:19:49 <Jamaic> aarvar: well, trying to sort empty list should return empty list. the "mergesort" function is the main one, the rest is just helper functions.
03:21:17 <Jamaic> aarvar: so the helper ones are "private ones", but since I'm new to haskell, I don't know how to privatize them yet :P
03:22:14 <aarvar> Jamaic: it's still not good
03:25:58 <mniip> ertes-w, hold my beer
03:27:36 <mniip> > over (reversed . traversed . Control.Lens.Indexed.indices odd) (*2) [1..5]
03:27:39 <lambdabot>  [1,4,3,8,5]
03:27:40 <Jamaic> aarvar: well, I can fix it by adding "mergesortalgo [] = []", but I feel like there should be a way to optimize that.
03:27:54 <mniip> cursiously
03:27:56 <aarvar> Jamaic: or you could use a NonEmpty list type
03:28:02 <mniip> :t  over (reversed . traversed . Control.Lens.Indexed.indices odd)
03:28:04 <lambdabot> (Reversing (f b), Traversable f) => (b -> b) -> f b -> f b
03:28:06 <aarvar> data NonEmpty a = NonEmpty a [a]
03:28:32 <Jamaic> mergesuperlists and mergesortalgo seems unusable in real-life, so I feel like I should get rid of them and move the functionality to mergesort, but I don't know how (yet)
03:30:27 <aarvar> Jamaic: you can define them locally in the mergesort function with let or where
03:31:15 <ertes-w> :t indices
03:31:17 <lambdabot> Ix i => Array i e -> [i]
03:31:21 <aarvar> (also, is there a reason you're not just splitting the list in half, sorting each half, and merging them?)
03:31:23 <ertes-w> :t Control.Lens.Indexed.indices
03:31:25 <lambdabot> (Applicative f, Indexable i p) => (i -> Bool) -> Optical' p (Indexed i) f a a
03:32:05 <ertes-w> @let isPrime x = all (\d -> x `mod` d /= 0) [2..x - 1]
03:32:08 <lambdabot>  Defined.
03:32:58 <ertes-w> > (traversed . Control.Lens.Indexed.indices isPrime %~ toUpper) "hello world"
03:33:01 <lambdabot>  "HELLo wOrld"
03:33:05 <ertes-w> err
03:33:16 <ertes-w> @let isReallyPrime x = x >= 2 && all (\d -> x `mod` d /= 0) [2..x - 1]
03:33:19 <Jamaic> aarvar: I'm learning haskell, and I tried making my favorite sorting algorithm in it. It's just for purpose of learning, it's not for real use. If I wanted to do usable sorting algo. I would use quicksort :P
03:33:19 <lambdabot>  Defined.
03:33:23 <ertes-w> > (traversed . Control.Lens.Indexed.indices isReallyPrime %~ toUpper) "hello world"
03:33:26 <lambdabot>  "heLLo wOrld"
03:33:29 <ertes-w> cool
03:49:41 <Jamaic> aarvar: okay, moved those two functions inside, https://pastebin.com/DzJCLsiW
03:50:09 <aarvar> Jamaic: you can write let f x = x + 1, you don't need to use a lambda
03:50:47 <aarvar> you can also have multiple clauses in a let; you don't need to use a case expression either
03:52:54 <Jamaic> aarvar: okay, didn't know I could use pattern matching in there, thanks ( https://pastebin.com/4qhhV3rt )
03:58:59 <ski> Jamaic : fwiw, when you use `case', you don't need to wrap the whole patterns in brackets. also, you could use a `where' rather than a `let'-`in' in the latter paste
04:00:45 <ski> Jamaic : `(result:[])' can be sugared to `[result]'
04:03:34 <Jamaic> ski: how excatly you use that? (please post whole line)
04:03:53 <joel135> Does this have a name? https://pastebin.com/uiEZbN74
04:04:13 <ertes-w> :t mzip
04:04:15 <lambdabot> error:
04:04:15 <lambdabot>     • Variable not in scope: mzip
04:04:15 <lambdabot>     • Perhaps you meant one of these:
04:04:31 <ertes-w> :t Control.Monad.Zip.mzip
04:04:33 <lambdabot> Control.Monad.Zip.MonadZip m => m a -> m b -> m (a, b)
04:04:57 <ertes-w> err, no, that's not the same
04:05:15 <ertes-w> joel135: liftA2 (,)
04:06:11 <joel135> ok!
04:06:37 <ski> Jamaic : use what ?
04:06:48 <Jamaic> ski: `(result:[])' can be sugared to `[result]'
04:06:59 <ski> simply replace the former by the latter ?
04:07:44 <Jamaic> oh, yeah, sorry, I was stupid and I removed the " = result" with it :|
04:08:01 <ski> (it's in two place, btw)
04:08:11 <Jamaic> yup, replaced it in both
04:09:28 * ski would personally also avoid `$' here
04:09:46 <Jamaic> aaaaand I reached pastebin's limit :|
04:10:07 <ertes-w> limit?
04:10:08 <ski> length/size limit ?
04:10:17 <Jamaic> "You have reached your guest paste limit of 10 pastes per 24 hours. Either wait a little or sign up for a free account to get higher limits."
04:10:26 <ski> @paste
04:10:27 <lambdabot> Haskell pastebin: http://lpaste.net/
04:10:33 <ski> you can use that ?
04:11:09 <Jamaic> thanks :3 http://lpaste.net/3756990958202257408
04:11:12 <ski> (you could include links to the original pastes, if you want)
04:12:26 <ski> looks fine, to me
04:12:34 <Jamaic> thanks :D
04:12:36 <ski> (modulo the `$'s, as mentioned)
04:13:54 <ertes-w> Jamaic: you can fuse 'mergesuperlists' and 'mergesortalgo' into a single function
04:14:15 <ertes-w> there is no real reason to keep them separate
04:14:49 <ertes-w> and i agree about the ($)
04:18:05 <Jamaic> ertes-w: How would you fuse them? I can't see a way.
04:19:29 <ertes-w> Jamaic: let's call that function (go :: [[a]] -> [[a]])
04:19:51 <ertes-w> if you get a list ["ac", "bd", "wy", "xz"], you would merge the first two sublists and 'go' the rest…  that would give you ["abcd", "wxyz"]
04:19:58 <ertes-w> then you would 'go' that resulting list
04:25:14 <ski> ertes-w : hm, won't that associate differently ?
04:26:37 <ertes-w> ski: nope
04:26:59 <ertes-w> the outer 'go' only sees the full result
04:27:15 <ertes-w> that's why you need to apply 'go' recursively *twice*
04:27:38 <ertes-w> hmm, wait…  actually i'm not entirely sure
04:27:49 <Jamaic> ertes-w: sorry, but I can't understand that ... seems like I would have to use "double recursion" in one function (mind that I'm a newbie, so I don't know a lot of things you can do in Haskell yet)
04:28:57 <ertes-w> go ["ab", "cd", "ef", "gh"] = go ("abcd" : go ["ef", "gh"]) = go ("abcd" : go ("efgh" : go []))
04:29:33 <ertes-w> ski: you're right
04:29:47 <ertes-w> Jamaic: sorry, scratch that
04:29:52 <ski> > let loop [x] = x; loop xs = loop (pair xs); pair [] = []; pair [x] = [x]; pair (x0:x1:xs) = x0 + x1 : pair xs in loop [a,b,c,d,e,f,g,h]
04:29:54 <lambdabot>  a + b + (c + d) + (e + f + (g + h))
04:29:55 <ski> > let loop [] = []; loop [x] = [x]; loop (x0:x1:xs) = loop (x0 + x1 : loop xs) in case loop [a,b,c,d,e,f,g,h] of [x] -> x
04:29:55 <Jamaic> done, :3
04:29:57 <lambdabot>  a + b + (c + d + (e + f + (g + h)))
04:30:12 <ski> (i assume you had something like that in mind ?)
04:31:05 <ertes-w> yeah, exactly
04:32:20 <Jamaic> ertes-w: btw what you wrote is not exactly what I want, you are concatenating the string there, but I need to merge them sorted, so it's more like go(go("ax"):go("zc"))
04:32:43 <ertes-w> Jamaic: no, i'm actually merging
04:32:56 <ertes-w> go (xs1 : xs2 : xss) = go (merge xs1 xs2 : go xss)
04:32:57 <Jamaic> errrr. go(go(["a","x"]):go(["z","c"]))
04:33:09 <Jamaic> ertes-w: you are mergin them, but the result is not sorted ;)
04:33:24 <ertes-w> Jamaic: yes, it is
04:34:25 <ertes-w> @let merge2 cmp (x:xs) (y:ys) = case cmp x y of EQ -> x : y : merge2 cmp xs ys; GT -> y : merge2 (x:xs) ys; LT -> x : merge2 xs (y:ys)
04:34:26 <lambdabot>  .L.hs:163:19: error:
04:34:26 <lambdabot>      • Couldn't match expected type ‘[a]’ with actual type ‘[a] -> [a]’
04:34:26 <lambdabot>      • Probable cause: ‘merge2’ is applied to too few arguments
04:34:39 <ertes-w> @let merge2 cmp (x:xs) (y:ys) = case cmp x y of EQ -> x : y : merge2 cmp xs ys; GT -> y : merge2 cmp (x:xs) ys; LT -> x : merge2 cmp xs (y:ys)
04:34:41 <lambdabot>  Defined.
04:35:07 <Jamaic> ertes-w: go ["ae", "bf", "cg", "dh"] = go ("abef" : go ["cg", "dh"]) = go ("abef" : go ("cdgh" : go [])) = "abef":"cdgh" = "abefcdgh"
04:35:27 <Jamaic> but I want "abcdefgh"
04:35:40 <ertes-w> @let badMergeSort cmp = concat . go . map pure where go (xs1 : xs2 : xss) = go (merge2 cmp xs1 xs2 : go xss); go xss = xss
04:35:42 <lambdabot>  Defined.
04:36:00 <ertes-w> > badMergeSort "aebfcgdh"
04:36:02 <lambdabot>  error:
04:36:02 <lambdabot>      • Couldn't match expected type ‘a -> a -> Ordering’
04:36:02 <lambdabot>                    with actual type ‘[Char]’
04:36:03 <ertes-w> > badMergeSort compare "aebfcgdh"
04:36:06 <lambdabot>  "a*Exception: /tmp/mueval10252023621350490027.hs:(163,1)-(167,40): Non-exhau...
04:36:15 <ertes-w> d'oh
04:36:17 <ertes-w> @undef
04:36:18 <lambdabot> Undefined.
04:36:23 <aarvar> that was certainly bad
04:36:42 <ertes-w> @let merge2 cmp (x:xs) (y:ys) = case cmp x y of { EQ -> x : y : merge2 cmp xs ys; GT -> y : merge2 cmp (x:xs) ys; LT -> x : merge2 cmp xs (y:ys) }; merge2 cmp xs [] = xs; merge2 cmp [] ys = ys
04:36:44 <lambdabot>  Defined.
04:36:49 <ertes-w> @let badMergeSort cmp = concat . go . map pure where go (xs1 : xs2 : xss) = go (merge2 cmp xs1 xs2 : go xss); go xss = xss
04:36:51 <lambdabot>  Defined.
04:36:55 <ertes-w> > badMergeSort compare "aebfcgdh"
04:36:57 <lambdabot>  "abcdefgh"
04:37:02 <Jamaic> :o
04:37:24 <ertes-w> it's bad, because it's not binary-tree-shaped, not because it's incorrect =)
04:37:38 <ertes-w> it's more eager about the later sublists
04:38:22 <Jamaic> oh, right, I can see it now, sorry, was stupid back there
04:38:47 <maerwald> bottom-up mergesort is supposed to be more efficient anyway, but I'm not sure what GHC does with the recursive code
04:40:28 <ertes-w> @let mergeSort cmp = concat . begin . map pure where begin xss@(_:_:_) = begin (go xss); begin xss = xss; go (xs1 : xs2 : xss) = merge2 cmp xs1 xs2 : go xss; go xss = xss
04:40:29 <lambdabot>  Defined.
04:40:39 <ertes-w> > mergeSort compare "aebfcgdh"
04:40:41 <lambdabot>  "abcdefgh"
04:40:49 <ertes-w> this one should be proper merge-sort
04:45:48 <Jamaic> well, thanks for help guys, I learned something new today :)
04:49:02 <Jamaic> > mergeSort compare "ba"
04:49:04 <lambdabot>  "ab"
04:53:32 <ertes-w> @let mergeSort2 cmp = concat . go . map pure where go xss@(_:_:_) = go (uncurry (zipWith merge2) (foldr (\x ~(xs, ys) -> (x:ys, xs)) mempty xss)); go xss = xss
04:53:34 <lambdabot>  .L.hs:175:27: error:
04:53:34 <lambdabot>      • Couldn't match type ‘a1 -> a1 -> Ordering’ with ‘[a]’
04:53:34 <lambdabot>        Expected type: [[a1]] -> [[a]]
04:53:44 <ertes-w> @let mergeSort2 cmp = concat . go . map pure where go xss@(_:_:_) = go (uncurry (zipWith (merge2 cmp)) (foldr (\x ~(xs, ys) -> (x:ys, xs)) mempty xss)); go xss = xss
04:53:46 <lambdabot>  Defined.
04:54:00 <ertes-w> > mergeSort2 compare (reverse ['a'..'z'])
04:54:03 <lambdabot>  "klmnopqrstuvwxyz"
04:54:12 <ertes-w> wow, that went wrong =)
04:54:23 <reactormonk> edwardk, I created an infinite recursion in Grouping instances with https://gist.github.com/reactormonk/28ba4377308e282897ab16d53759bdcf when trying to summon `Grouping (Fix (JSONTypeF Label))`
04:57:21 <reactormonk> ... I was wondering if the Grouping1 on JSONTypeF is correct
05:07:55 <michi7x7> > mergeSort compare (reverse ['a'..'z'])
05:07:57 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
05:10:33 <michi7x7> > (randomIO :: IO Int) >>= print
05:10:35 <lambdabot>  <IO ()>
05:10:48 <michi7x7> Can lambdabot do IO ?
05:10:53 <ski> @help run
05:10:53 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
05:11:12 <michi7x7> @run (randomIO :: IO Int) >>= print
05:11:14 <lambdabot>  <IO ()>
05:11:21 <michi7x7> @run (randomIO :: IO Int)
05:11:23 <lambdabot>  <IO Int>
05:11:24 <ski> `> ...' is short for `@run ...'
05:11:34 <michi7x7> aahh
05:38:38 <beemo> @ski too bad no IO
05:38:38 <lambdabot> Maybe you meant: wiki src ask
05:44:08 * ski blinks
06:06:36 <`Guest00000> how do i implement the operation "parse everything that's parsed by P, but not by Q"?
06:06:59 <byorgey> `Guest00000: what parsing framework are you using?
06:07:26 <`Guest00000> byorgey: i'm trying to write my own Applicative/Alternative parser
06:08:54 <byorgey> `Guest00000: ah, I see.  in that case I suggest implementing a function  notFollowedBy :: Parser a -> Parser (), which succeeds if and only if its argument fails; afterwards, no matter what, it leaves the input as it was, i.e. it does not consume any input
06:09:18 <byorgey> `Guest00000: then you can write your "parsed by P but not by Q" very simply as   notFollowedBy p *> q
06:09:31 <byorgey> uh, the other way around, sorry
06:09:36 <byorgey> notFollowedBy q *> p
06:13:42 <`Guest00000> byorgey: thanks
06:20:52 <mniip> byorgey, that's not a very nice operation tbh
06:20:58 <mniip> you'd rather want P\Q
06:21:16 <mniip> I mean, the operation you describe is not at all possible in a yoctoparsec-like parser type
06:31:10 <byorgey> mniip: you're probably right.  But in the event that notFollowedBy is possible, I think it will probably be much simpler to implement.
06:31:16 * byorgey has never heard of yoctoparsec
06:31:43 <byorgey> oh, heh, you wrote it =)
06:31:55 <opqdonut> I'd name my parser library ångström
06:33:02 <ertes-w> mniip: why FreeT and not FT?
06:35:18 <mniip> ertes-w, FT?
06:36:22 <ertes-w> mniip: Control.Monad.Trans.Free.Church
06:36:52 <`Guest00000> byorgey: your solution first excludes the unwanted parses, then tries to parse the needed parses; my thinking was trapped in trying to exclude unwanted parses after parsing needed ones
06:37:55 <ertes-w> mniip: there are some performance advantages in constructing parsers via FT and only dropping to FreeT when necessary
06:38:05 <michalrus> Hmm, what happened to the Hasql quasi-quoter? Do we now have to do everything like in https://github.com/nikita-volkov/hasql/blob/a1a5e15da828617ca25104e702c03a95e04ecfc8/tasty/Main.hs#L25-L59 ? :’
06:53:54 <kahlil29> I want to make a front-end for my basic web-app. Using Lucid, I'm able to make the skeleton HTML and add classes, etc to the elements. But how do I use bootstrap classes? 
06:57:24 <Rembane> kahlil29: I think you do it like the other css classes.
06:57:36 <shapr> kahlil29: import Lucid.Bootstrap and use these? https://hackage.haskell.org/package/lucid-2.9.4/docs/Lucid-Bootstrap.html
06:58:06 <kahlil29> alright thanks both of you :) 
07:02:20 <Rembane> kahlil29: No worries. :)
07:02:37 <shapr> kahlil29: any other questions?
07:03:09 <trigone> hi, is there a haskell-stack channel?
07:03:43 <shapr> yes!
07:04:05 <trigone> thx! how do i join it from within another channel?
07:04:20 <shapr> usually you can do "/join #haskell-stack"
07:04:32 <trigone> worked, thanks a lot!
07:04:34 <shapr> sure!
07:15:26 <Xandaros> I'm generating some records with TH and I want those to get lenses, as well. Is there any chance I can use makeLenses from my TH? Naively calling it just results in http://tcpst.net/ppax
07:17:09 <Xandaros> The problem seems to be that it tries to reify the record, which doesn't actually exist yet. It just exists as an AST and would become an actual thing once the quasi-quoter terminates. However, I'd like my quasiquoter to add the lenses, as well
07:37:22 <c_wraith> Xandaros: https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-TH.html#v:declareLenses maybe?
07:39:08 <Xandaros> I tried that and it did seem to work, but I seem to run into issues with records having the same fields. Same issue with declareClassy. This does not appear to be an issue when using it directly, so it has me a bit confused
07:54:57 <Xandaros> I just made a new TH function 'lensify' that you call afterwards. Not the end of the world. (And, actually, this is not even user-facing, so I don't know why I'm making such a big deal out of it)
07:57:35 <Xandaros> Only that it still doesn't like duplicate record fields *sigh*
08:19:35 <[exa]> favorite package to parse commandline?
08:19:54 <cocreature> [exa]: optparse-applicative
08:23:01 <[exa]> cocreature: perfect, thanks
08:24:08 <Xandaros> In case anyone is wondering, I'm prepending the type name and using makeFields now. This works, but the normal field accessors are ridiculous now. Guess I'll just use lenses everywhere
08:26:07 <DigitalKiwi> when does dibblego come around
08:26:36 <DigitalKiwi> that's not a philosophical question... like when does he get active on IRC >.>
08:26:43 <shapr> oh
08:27:17 <DigitalKiwi> though an answer to the philosophical question would be possibly entertaining
08:29:09 <Gurkenglas> Wasn't there a site that provides statistics for that based on #haskell's logs?
08:29:33 <shapr> oh right, another of chrisdone's projects
08:40:16 <andromeda-galaxy> I've been trying to work on some of the bugs against hsc2hs cross compilation that have been biting me.  Does anyone know why hsc2hs in cross compile mode does its painstaking binary search to determine integer values at compile time instead of just generating c wrappers and 'foreign import ccall' ing them?  Or, ideally for GHC, just 'foreign import capi'
08:42:47 <shapr> andromeda-galaxy: ask on the mailing list(s) or ping Manuel Chakravarthy?
08:45:26 <c_wraith> andromeda-galaxy: do you know how hsc2hs works in general?
08:45:49 <c_wraith> andromeda-galaxy: it's both fascinating and terrifying, and definitely does *not* play nicely with cross-compilation
08:49:14 <shapr> I've seen recent posts about inline-c, is that easier for cross-compilation?
08:50:02 <c_wraith> Well, it uses template haskell, so it has the potential to be just as bad.
08:50:12 <c_wraith> Though I don't know what it actually does
08:55:17 <andromeda-galaxy> shapr: okay, I will, thanks
08:55:52 <andromeda-galaxy> c_wraith: I think so - it basically creates a C file that generates an HS file on stdout via printing the values of all the constants, etc.
08:56:30 <andromeda-galaxy> Actually, do you know the reasoning behind doing all of that instead of just generating C wrapper stubs and foreign import'ing them?
08:56:40 <c_wraith> andromeda-galaxy: yep.  It does that so that values it can only get by compiling C code are filled in properly.
08:56:59 <andromeda-galaxy> no, so, right now it compiles C code and then runs it at compile time to generate haskell
08:57:13 <andromeda-galaxy> instead it could compile C wrappers and link it to the haskell and get those values at runtime instead
08:57:23 <andromeda-galaxy> which is significantly simpler & works painlessly with cross compilation
08:58:20 <c_wraith> It could, but those wrappers have overhead.  The way hsc2hs works has zero runtime overhead.
08:58:47 <andromeda-galaxy> oh well, I thought that might be it
08:59:04 <c_wraith> But yes, it means it doesn't work at all for cross compilation.
08:59:29 <andromeda-galaxy> thanks
08:59:51 <c_wraith> So..  I guess it does other crazy stuff instead, and you should ask the authors about that. :)
09:09:15 <cocreature> couldn’t hsc2hs “just” invoke the C compiler for cross compiling as well to get the right options?
09:09:35 <andromeda-galaxy> cocreature: the problem is that hsc2hs runs the resulting binary at compile time to get the values
09:09:48 <cocreature> ah ok
09:10:11 <andromeda-galaxy> so in cross compile mode, it instead uses whether or not compilation fails to leak 1 bit of information about each integer constant the compiler knows about
09:10:48 <andromeda-galaxy> via basically 'static int test_array[1 - 2*( value >= guess )];' kind of thing
09:10:59 <cocreature> ouch
09:11:17 <andromeda-galaxy> (side note: this seems to work better, at least on ghc and clang, if you instead do 'enum { TEST_ENUM = <expr> }; static int test_array[TEST_ENUM]; '
09:11:47 <andromeda-galaxy> (since the former only accepts integer constant expressions, and the latter accepts initializer constant expressions with types representable as integers, which are, annoyingly, different things)
09:14:35 <Lokathor> http://lpaste.net/358225 generalized a neat little helper
09:20:52 <andromeda-galaxy> Lokathor: May I suggest http://lpaste.net/358226 or some pointfreeing thereof?
09:21:35 <Lokathor> that makes it a CAF dealy doesn't it
09:23:39 <sqooq> hi
09:24:08 <sqooq> whenever I need to store information in a function, I do a helper function with an extra parameter that gets updated every recursive cycle
09:24:11 <sqooq> is this bad practice?
09:25:57 <andromeda-galaxy> Lokathor: hmm, I'm not sure - wouldn't quite have expected it, but maybe. Is that a problem?
09:27:51 <Cale> sqooq: That's okay. You might prefer to use higher order functions somehow though.
09:28:16 <Cale> (and avoid explicit recursion altogether)
09:28:56 <sqooq> avoid recursion, what
09:29:09 <andromeda-galaxy> sqooq: that sounds about right to me. If you are writing a lot of primitive recursive functions, though, it might be worth thinking about whether your functions can be neatly re-expressed as folds
09:29:14 <Cale> e.g. by using map or foldr or something like that.
09:29:23 <nshepperd> just how much runtime overhead could there be in getting the values of constants? wouldn't it be just one ffi access at startup after which they would be fully evaluated?
09:29:30 <andromeda-galaxy> oh sorry I missed Cale's reply
09:30:05 <andromeda-galaxy> nshepperd: I would have assumed that, but haven't benchmarked it. 
09:30:12 <nshepperd> you wouldn't get constant folding though
09:30:40 <andromeda-galaxy> true
09:30:49 <Lokathor> andromeda-galaxy, not a problem really, but every time i see something that's maybe a CAF it makes me want to go back and read the chapter about them
09:30:53 <sqooq> andromeda-galaxy, well there's only like 3 functions so far like this. One of them I swore was impossible with folds. Not sure about the other two. This one I'm stumped though, because things change depending on the input
09:30:57 <Lokathor> i always forget the next time it comes around
09:31:30 <Lokathor> sqooq, functions that are almost folds are the most annoying
09:31:32 <Cale> sqooq: Yeah, if you don't understand the function very well, then explicit recursion is okay.
09:31:51 <andromeda-galaxy> Lokathor: makes sense
09:32:26 <sqooq> http://lpaste.net/358227
09:32:28 <Cale> You'd always like to be able to pull it apart into simpler higher order operations, but this isn't always very easy to do.
09:32:29 <sqooq> thats an example
09:32:57 <andromeda-galaxy> sqooq: if you want to learn more about different kinds of folds/unfolds and don't mind reading a bit of math, can I suggest "Funtional Programming with Bananas, Lenses, Envelopes, and Barbed Wire"?
09:33:14 <sqooq> i'm a capitalist realist
09:33:16 <sqooq> i don't read
09:35:27 <andromeda-galaxy> sqooq: I think we can turn that into a fold
09:35:29 <andromeda-galaxy> give me 1 second
09:37:38 <nshepperd> andromeda-galaxy: i wrote something like this for the pypy project (which i think we didn't end up using, because i went away and other things to do), which instead would compile an object file containing lots of linker initialized structs like this: { char uuid[32]; int value; char uuid_again[32]; }
09:38:09 <nshepperd> andromeda-galaxy: you would then scan the output file for the uuids relating to each value and pull out the constants or whatever like that
09:38:57 <nshepperd> this also works with cross compilation, but has the benefit that it doesn't require a billion compiler calls
09:39:13 <sqooq> andromeda-galaxy, if you need to see the types definitions let me know
09:39:23 <andromeda-galaxy> nshepperd: thanks for the suggestion, I was vaguely thinking about doing something like if that it turns out to be really necessary to get this working better than it is now
09:39:28 <andromeda-galaxy> or just as a performance improvement
09:40:22 <andromeda-galaxy> sqooq: will do
09:40:27 <nshepperd> (you do have to also put in a few calibration variables like value = 0x12345678 to establish alignment and endianness)
09:40:59 <andromeda-galaxy> nshepperd: btw did that work with string literals? the biggest problem with the current approach imo is that const_str doesn't work
09:43:09 <nshepperd> i don't remember, but I think it would work. {char uuid[32]; char value[sizeof <literal>]; char uuid_again; }
09:45:44 <andromeda-galaxy> sqooq: look at the lpaste again. It is a bit verbose because I tried to spell things out a bit. It uses the same "trick" but removes the explicit recursion. Anywhere that you have a function that does something in an empty list and otherwise only examines the head and calls itself recursively on the tail of the list, it can be easily converted into a fold like this
09:46:44 <andromeda-galaxy> nshepperd: cool. I'll have to think about doing it that way again.
09:47:08 <sqooq> thanks
09:47:15 <sqooq> maybe i do need to brush up on my folds
09:49:36 <sqooq> I think I fixed my other one
09:49:45 <Cale> sqooq: You can also turn it into a scanl and a zipWith
09:49:59 <andromeda-galaxy> sqooq: if you don't want to read anything, https://hackage.haskell.org/package/recursion-schemes encapsulates most of the stuff in that paper
09:50:04 <sqooq> Hmm
09:50:05 <sqooq> interesting
09:50:10 <andromeda-galaxy> also a nice solution
09:50:11 <sqooq> my other one I already used fold
09:50:15 <sqooq> kek I don't even remember doing that
09:50:45 <Cale> http://lpaste.net/358227#a358229
09:51:32 <Cale> Unfortunately, this is a bit worse if the list of notes is very long
09:52:00 <Cale> actually, hmm
09:52:04 <Cale> Maybe it's just fine
09:52:13 <Cale> Yeah, should be okay :)
09:52:20 <Cale> Had to think a bit about the space usage
09:52:44 <sqooq> omg
09:52:48 <sqooq> whatd u do
09:53:07 <Cale> I added a bunch of stuff so I could actually test that my solution is correct :P
09:53:22 <Cale> processStartPosition' ns = concat (zipWith csoundNoteAtPos (scanl (+) 0 (map duration ns)) ns)
09:53:26 <Cale> that's the important bit
09:55:05 <sqooq> o nice
09:55:31 <sqooq> but which is better
09:55:50 <Cale> Well, whichever one you find easiest to think about
09:55:51 <sqooq> I just have 1 function left in my old style
09:55:58 <sqooq> i'm gonna try and see if I can fold it
09:55:59 <Cale> Mine computes the list of positions from the list of durations separately
09:56:30 <sqooq> I mean I think that's closer to how I originally tried to do this
09:56:33 <sqooq> but couldn't figure it out
09:56:43 <sqooq> My idea was to just add up all the durations to figure out position
09:57:00 <Cale> Yeah basically, that's what scanl (+) 0 does
09:57:08 <Cale> > scanl (+) 0 [1,20,300,4000]
09:57:10 <lambdabot>  [0,1,21,321,4321]
09:57:14 <andromeda-galaxy> this sort of thing is really nice when it works. oh well, there goes my explanation of recursion schemes
09:58:00 <sqooq> dang i wasn't aware of scanl
09:58:03 <Cale> > scanl (+) 0 [a,b,c]
09:58:05 <lambdabot>  [0,0 + a,0 + a + b,0 + a + b + c]
09:58:48 <Cale> (Some lambdabot magic courtesy of simple-reflect)
09:59:17 <andromeda-galaxy> is that lambdabot newish?
09:59:29 <Cale> Nope
09:59:36 <andromeda-galaxy> *lambdabot magic
09:59:40 <sqooq> i'm confused at csoundNoteAtPos
09:59:52 <Cale> That's been around since ~2008
10:00:07 <andromeda-galaxy> nice
10:00:16 <Cale> sqooq: That computes the list of CSound notes corresponding to a position and Note data structure
10:00:19 <andromeda-galaxy> not sure how I missed that these past two years ;)
10:00:31 <Cale> (Just because it might be 0 or 1 things we have to generate)
10:00:46 <Cale> We could use Maybe here, but it's a little easier just to generate a list so we can concat
10:01:00 <andromeda-galaxy> or we could generate either (n:) or id and then compose all the fns in the list
10:01:01 <sqooq> nvm i got it
10:01:17 <sqooq> it just takes the position data and fits it with the corresponding note ya?
10:01:36 <sqooq> then you're zipping that to match up with every note in the list
10:01:49 <sqooq> that's pretty much exactly the way I initially wanted to do this kek
10:01:57 <sqooq> I literally couldn't figure out how
10:02:06 <sqooq> interesting
10:02:40 <Cale> yep
10:03:06 <sqooq> the function i'm on now is some sh
10:03:22 <sqooq> i think i'm almost done then I'll paste so you guys can scrutinize my terrible code
10:04:29 <sqooq> btw does your test thing test complexity or just whether they give the same result?
10:04:42 <andromeda-galaxy> result
10:05:05 <tsahyt> is there some cleaner way to express this: over _2 (view someLens)?
10:05:28 <Cale> sqooq: Just whether they give the same result
10:06:08 <Cale> sqooq: If you want to test runtime, there's a library called criterion which might help with that
10:06:14 <tsahyt> not that this would be particularly unclean or anything, but I suppose lens has something special for that case too
10:06:35 <sqooq> i mean I don't care really
10:06:42 <sqooq> it all runs instantaneously
10:06:44 <Cale> sqooq: The constant factors on these things might be a little different, but I wouldn't expect there to be a huge complexity difference.
10:07:12 <Cale> It's pretty much linear in the length of the list and constant space
10:07:27 <vimalloc> Could someone help me understand why an imported operator would work by itself in one part of my file, but need to be prefaced by the qualified library import in a different part of the same file? (:<|> vs S.:<|>). 
10:07:33 <vimalloc> https://gist.github.com/vimalloc/dd3be5d181c0e24e0c1a1a59936a1d9a
10:07:41 <andromeda-galaxy> Cale: this scanl isn't strict, so isn't it linear space?
10:08:32 <Cale> vimalloc: That's not the same operator! :)
10:08:56 <Cale> vimalloc: It's textually the same, but one is the type, the other is a data constructor, you only imported the type
10:09:05 <vimalloc> aaaaahhh
10:09:19 <Cale> vimalloc: If you import it like (:<|>)(..)
10:09:24 <Cale> I think it'll work
10:09:52 <Cale> (The (..) means to import all data constructors of the type)
10:10:22 <vimalloc> perfect. Thanks so much Cale! :)
10:10:28 <andromeda-galaxy> nshepperd: sorry to keep bugging you about this btw but were your aligment/padding diagnostics portable as in the standard says they should be sufficient, or portable as in gcc + clang both work?
10:10:45 <Cale> andromeda-galaxy: The scanl will be computed incrementally as demanded by the zipWith, and each element of the result becomes garbage after it's used
10:11:19 <`Guest00000> in ghci, i want to see the list of unexported declarations in the currently loaded module. can i do it? just pressing Tab shows a list which includes declarations in Prelude and imported modules
10:11:26 <Cale> andromeda-galaxy: So at least assuming that we access the result in the straightforward order, it should be constant space
10:11:43 <Cale> (though perhaps it'll make the GC work a bit more)
10:12:13 <monochrom> `Guest00000: No, I'm afraid you have to do the subtraction yourself.
10:12:22 <Cale> `Guest00000: I don't know about unexported, but there's :browse
10:12:33 <andromeda-galaxy> Cale: ah of course
10:13:02 <nshepperd> andromeda-galaxy: the c standards don't even guarantee that your bytes are eight bits wide. so... the latter, lol
10:13:38 <Cale> andromeda-galaxy: I was initially worried about the same thing -- in general this kind of pattern can result in ns being retained for longer than necessary, but not in this case :)
10:14:36 <andromeda-galaxy> nshepperd: I wonder if I can make it more robust by using the AC_COMPUTE_INT/lots of compiler invocations trick to compute the struct offsets, instead of inserting "alignment padding"
10:14:38 <nshepperd> however, it would be surprising if it would break on any real compiler
10:15:02 <monochrom> You can take the stance of x86_64 ABI conformance. This is more general and less general than gcc+clang.
10:15:41 <andromeda-galaxy> monochrom: I don't want to break people that are currently using hsc2hs --cross-compile to cross compile from x86/amd64 to arm
10:15:41 <monochrom> More general because compatible with every compiler for the x86_64 ABI. Less general because incompatible with, say, gcc on PDP 11.
10:15:42 <Gurkenglas> tsahyt, can you give more context? I've got a hunch of a smell
10:16:43 <andromeda-galaxy> but yeah, we can probably forgot about the PDP 11 for now
10:17:50 <nshepperd> andromeda-galaxy: what i mean by that was you would have one struct like the above where you would set the value to 0x12345678. you get then scan for that value within the two uuid "brackets" to measure how much padding the compiler inserts itself, as well as what byte order it has
10:18:14 <nshepperd> that would give you the struct offsets you are looking for
10:18:25 <monochrom> Most likely amd64 and arm differ in how they use registers, but common in struct layout. You may actually need to do nothing.
10:19:11 <andromeda-galaxy> nshepperd: ah right. that should be robust enough
10:19:20 <andromeda-galaxy> monochrom: probably! I just like to have the most compatibility possible
10:19:23 <monochrom> Although, watch out big endian vs little endian!
10:21:54 <sqooq> andromeda-galaxy, yours has type errors that I can't seem to fix
10:22:27 <`Guest00000> can i undefine an instance at ghci?
10:22:31 <sqooq> nvm
10:22:32 <sqooq> fixed
10:22:39 <sqooq> let's see if it works correctly though
10:24:35 <sqooq> it works but it's reversed lmao
10:24:52 <sqooq> the latest start position is the first in the list, the earliest start position is the last
10:25:13 <sqooq> (I know I can just use `reverse`)
10:25:20 <andromeda-galaxy> sqooq: oh right sorry I meant to reverse it
10:27:20 <sqooq> ok my other function is a hot mess
10:27:23 <sqooq> let's see if it works
10:29:28 <sqooq> it works but how do I do new line?
10:29:35 <sqooq> O that doesn't work in strings does it
10:29:42 <sqooq> I need to output to terminal
10:30:47 <geekosaur> \n ?
10:31:13 <geekosaur> > text "foo\nbar"
10:31:15 <lambdabot>  foo
10:31:15 <lambdabot>  bar
10:31:35 <michi7x7> :t text
10:31:37 <lambdabot> String -> Doc
10:31:44 <tsahyt> Gurkenglas: I've got a tuple of records, I needed a tuple of fields in said records. there's really not much more to it
10:31:50 <tsahyt> the whole thing is in an Applicative, if that matters
10:31:55 <geekosaur> it's abusing what is arguably a bug in a prettyprinting library
10:32:09 <geekosaur> basically the Show instance for Doc outputs literally
10:34:18 <sqooq> shoot it didn't work
10:34:51 <wedify> https://paste.ubuntu.com/25473391/ , can someone help me understand the type error? paraphrasing it says "couldn't match 'ShapeT h w' with 'ShapeT h0 w0'"
10:35:37 <aweinstock> It looks like System.Console.Readline doesn't expose the readline's {read_history,write_history} functions; I can probably hack around that with FFI, is there a better way?
10:35:50 <aweinstock> s/the readline/the readline library/
10:35:56 <geekosaur> wedify, I think you need to make w scoped
10:36:05 <cocreature> wedify: you need ScopedTypeVariables. by default you can’t refer to variables in your type signature so the h in your body is different than the h in your type signature
10:36:07 <geekosaur> as is, you have referred to a w that is not the one in the signature
10:36:13 <geekosaur> so it will never match
10:36:31 <geekosaur> hough :: forall h w . ...
10:36:39 <geekosaur> and enable ScopedTypeVaribles
10:45:05 <sqooq> is lpaste down
10:45:32 <wedify> sqooq: it was for me
10:45:51 <wedify> geekosaur, cocreature: thank you
10:45:51 <sqooq> I'll use pastebin then
10:45:59 <sqooq> who wants to see my monstrosity
10:46:00 <sqooq> https://pastebin.com/Trq0pw2P
10:46:05 <sqooq> it doesn't even work 
10:48:10 <Lol> hi
10:48:12 <Lol> ciao
10:48:21 <Lol> !list
10:48:46 <Psybur> sqooq, wheres Pitch
10:49:00 <mniip> byorgey, huh
10:49:09 <sqooq> O sorry
10:50:11 <sqooq> https://pastebin.com/rWFzjqwS
10:50:21 <sqooq> my go function does recursion badly
10:50:35 <sqooq> I think I should redefine it and map it across the pitches instead
10:51:41 <aweinstock> w.r.t. the readline stuff I was asking about: the FFI hackery was only 4 lines and it works as expected, so there probably isn't a better way
10:52:42 <`Guest00000> @pl \x -> x
10:52:42 <lambdabot> id
10:52:56 <`Guest00000> @pl \a b c d e f g -> g b c d e f a
10:52:56 <lambdabot> flip (flip . ((flip . ((flip . ((flip . (flip .) . flip) .) . flip) .) . flip) .) . flip . flip id)
10:53:21 <Psybur> :o
10:54:26 <sqooq> i can fix it
10:55:19 <tsahyt> @pl \a b c -> c b a
10:55:20 <lambdabot> flip (flip . flip id)
10:55:25 <tsahyt> @pl \a b c d -> d c b a
10:55:25 <lambdabot> flip (flip . (flip .) . flip (flip . flip id))
10:59:13 <`Guest00000> omg why can't GHC derive Eq for constructorless datatype
10:59:30 <byorgey> mniip: ?
10:59:47 <tsahyt> `Guest00000: what would (==) be?
10:59:52 <tsahyt> always true or always false
10:59:57 <glguy> `Guest00000: That's coming
10:59:58 <mniip> tsahyt, it would have 0 equations
11:00:09 <tsahyt> mniip: how do you even define that
11:00:16 <glguy> Last I'd heard it was going to be implemented as _ == _ = True
11:00:21 <mniip> (==) = \case {}
11:00:26 <tsahyt> oh
11:00:29 <tsahyt> I didn't know that's possible
11:00:35 <mniip> x == y = case x of {}
11:00:37 <mniip> or whatever
11:01:12 <mniip> :t \case {}
11:01:13 <lambdabot> t1 -> t
11:01:54 <`Guest00000> woohoo, coerce
11:02:17 <mniip> uhh
11:02:19 <mniip> no?
11:03:30 <`Guest00000> it's a silly joke
11:07:08 <glguy>  https://github.com/ghc-proposals/ghc-proposals/pull/63 - Overhaul deriving instances for empty data types proposal #63
11:07:33 <`Guest00000> 49 type errors
11:07:39 <`Guest00000> it's a new record
11:08:44 <dolio> That's nothing. I've had hundreds of type errors before.
11:08:53 <dolio> Get on my level.
11:09:36 <cocreature> “how many levels of type errors are you on?”
11:11:47 <`Guest00000> no, it's not even 49, half of them is not type
11:12:02 <lyxia> Imagine GHC with an achievement system. Achievement unlocked "Are you doing it on purpose?", more than 100 type errors in one file.
11:12:26 <tdammers> well, duh, of course I am doing it on purpose
11:12:48 <tdammers> I introduce type errors so that the compiler tells me where to refactor things
11:14:19 <sqooq> Ok I seriously don't think I understand folds. So I have a list of strings,x, that I want to attach to the end of a string,y, that's almost the same everytime except that one number increments in y for every x. 
11:14:29 <sqooq> this is fold?
11:15:09 <Cale> You could do that as a fold, sure
11:15:20 <Cale> Er, well...
11:15:22 <mniip> sounds like you need to zip x with [1..]
11:15:36 <Cale> I'm not quite sure what the "one number increments in y" means
11:15:37 <mniip> and then it's a map over that zip
11:15:51 <Cale> It might be annoying to do that edit, even if it's possible
11:15:54 <mniip> a map is a fold but more importantly it's a map
11:16:23 <sqooq> Cale: the string is `"i1" ++ "." ++ show x ++ " " ++ show (csStart cur) ++ " " ++             show (csDuration cur) ++ " "` where x starts with 1 and goes up 1 everytime
11:16:52 <sqooq> this string is "y" that i mentioned earlier
11:17:00 <Cale> Ah, so this is like a map and a zip
11:17:35 <Cale> > map (\n x -> show n ++ " " ++ x) (zip [0..] (words "here are some words"))
11:17:37 <lambdabot>  [<[Char] -> [Char]>,<[Char] -> [Char]>,<[Char] -> [Char]>,<[Char] -> [Char]>]
11:17:40 <Cale> oops!
11:17:49 <Cale> > map (\(n, x) -> show n ++ " " ++ x) (zip [0..] (words "here are some words"))
11:17:51 <lambdabot>  ["0 here","1 are","2 some","3 words"]
11:18:00 <Cale> or, equivalently
11:18:12 <Cale> > zipWith (\n x -> show n ++ " " ++ x) [0..] (words "here are some words")
11:18:14 <lambdabot>  ["0 here","1 are","2 some","3 words"]
11:18:36 <sqooq> :scratchhead:
11:18:56 <Cale> zip [0..]  is a way to add indices to the elements of a list
11:19:04 <sqooq> yes I see it
11:19:11 <sqooq> but idk i'm missing something
11:19:12 <Cale> You could start it off with 1 of course, if that's appropriate
11:19:22 <sqooq> yes
11:19:24 <sqooq> hmm
11:19:25 <Cale> So, you have a list of values cur
11:19:27 <sqooq> feels too easy
11:19:35 <Cale> curs, let's say
11:20:03 <Cale> zipWith (\x cur -> "i1" ++ "." ++ show x ++ " " ++ show (csStart cur) ++ " " ++ show (csDuration cur) ++ " ") [1..] curs
11:20:22 <eschnett> i’m using intero mode in emacs, and it’s freezing up — emacs doesn’t accept any keys until i hit ^G several times. then, after a second, it freezes up again. any ideas for debugging this? getting a backtrace?
11:22:58 <sqooq> Cale: I get type
11:23:15 <sqooq> Couldn't match type ‘[Char]’ with ‘[Char] -> c’   Expected type: Int -> [Char] -> c     Actual type: Int -> String
11:24:40 <shapr> what's the emacs thing that's newer than intero? I want to try it, but I forgot the name.
11:24:47 <sqooq> Cale, see the thing is that cur is actually constant
11:24:53 <sqooq> it's csChord that changes
11:25:08 <sqooq> I thought this would work
11:25:09 <sqooq> chordstring csN y = zipWith (replaceNum csN) [1..] (map disect $ csChord csN)
11:25:34 <sqooq> ignore that y
11:27:32 <sqooq> o derp fixed
11:27:33 <sqooq> thanks cale
11:41:46 <MarcelineVQ> shapr: dant
11:41:50 <MarcelineVQ> dante
11:41:56 <shapr> thanks!
12:10:26 <`Guest00000> type-error-driven development
12:10:50 <shapr> I've done it.
12:10:58 <andromeda-galaxy> the best kind of development
12:11:00 <shapr> I think the politically correct term is Type Driven Development
12:11:09 <shapr> but yeah, ghc error driven dev is my jam
12:11:09 <andromeda-galaxy> TDD
12:27:47 <maerwald> I prefer CDD
12:28:32 <Psybur> Cant do development?
12:28:46 <pedrorolo_> hi there! is there any parser combinator library that is meant to parse Lists of something generic instead of some sort of Strings
12:28:51 <tdammers> Type Driven Development is the idealized version, where you write down the types and then derive the implementation from them
12:29:00 <pedrorolo_> something thought to work with Text.Parser.Combinators.Parsing rather than with Text.Parser.Combinators.CharParsing
12:29:06 <pedrorolo_> ?
12:29:20 <remexre> Is there a Parsec parser for ascii chars -> Word8?
12:29:21 <tdammers> Type-Error Driven Development is where you write down the types, and then keep fixing compiler errors until they go away, at which point the code will be correct
12:29:23 <pedrorolo_> (I am a begginer, this question might not make sense)
12:29:28 <maerwald> Psybur: correctness driven development :P
12:29:49 <maerwald> types are barely correctness
12:30:13 <pedrorolo_> 8:28 PMhi there! is there any parser combinator library that is meant to parse Lists of something generic instead of some sort of Strings
12:30:23 <tdammers> pedrorolo_: Parsec can consume most anything, it's just that some of the parsers that ship with it are specific to Chars and string data
12:30:44 <ystael> maerwald: here i was thinking "chain driven development", as in you have to pedal to make the compiler go
12:31:14 <tdammers> my take was "Customer-Driven Development", where you keep changing the code because the customer demands it, but it never gets any closer to completion
12:34:52 <cocreature> pedrorolo_: parsec is parametrized over the stream type and it provides an instance for lists of tokens https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#t:Stream
12:35:52 <pedrorolo_> thanks tdammers cocreature. Npw I know where to look into
12:35:56 <pedrorolo_> :-)
12:38:54 <Gurkenglas> pedrorolo_, https://hackage.haskell.org/package/yoctoparsec-0.1.0.0/docs/Control-Monad-Yoctoparsec.html :D
12:50:03 <orzo> i have a type that involves two peano numbers that sum to a constant (3)
12:50:48 <orzo> i tried making a ThreeMinus type function, but it was unable to infer that S (ThreeMinus (S n)) and ThreeMinus n are the same
12:51:04 <orzo> What's a better way?
12:54:36 <sqooq> Hey I need to implement a gui interface where there's a graph presented and one can draw points on it with the mouse, where do I start to do something like that?
12:55:12 <sqooq> is that considered gui or graphics?
12:55:47 <tdammers> both
12:56:16 <mniip> it's also user interface
12:56:36 <mniip> also UI and interface as well
12:56:53 <tdammers> and a graphical interface, let's not forget that
12:56:55 <tdammers> :P
12:57:17 <mniip> not a user though
12:58:10 <maerwald> sqooq: gtk+ canvas with cairo and diagrams
12:58:13 <Gurkenglas> A graph as nodes connected by edges, or as a curve on graph paper? gloss is easy.
12:58:41 <sqooq> as a curve I think
12:58:46 <sqooq> y axis and time axis
12:59:00 <mniip> maerwald, can cairo draw fast enough to provide an interactive interface?
12:59:03 <sqooq> cartesian
12:59:25 <eikke> are there any guarantees in which haskell thread a ctrl-c exception will be delivered?
13:00:02 <maerwald> mniip: whole of gtk depends on it?
13:03:28 <thoughtpolice> eikke: Main thread, according to the docs https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Exception.html#t:AsyncException
13:03:47 <mniip> hmm, perhaps my experience with cairo has been hindered by other software in the way
13:04:41 <Gurkenglas> sqooq, you may be able to learn from the Chart library
13:06:20 <Gurkenglas> Maybe you can use Chart to make the plot, and use http://hackage.haskell.org/package/Chart-gtk-1.8.2/docs/Graphics-Rendering-Chart-Gtk.html#v:createRenderableWindow to get a Window that'll tell you when and where it's clicked
13:08:14 <sqooq> Gurkenglas: Yes, that seems like the right track
13:08:15 <sqooq> thanks
13:13:35 <LesterLee> Hi, I'm lost in lens operators. I want to add a SecurityRequirement to every GET-Operation of a Swagger object. My attempt: line 58 of http://lpaste.net/495376949485502464
13:14:50 <LesterLee> I think I understand the issue (get returns a Maybe Operation not a Operation), but find myself unable to specify that I want leave each Nothing unchanged.
13:15:38 <Gurkenglas> LesterLee, replace get with _Just . get
13:16:39 <eikke> thoughtpolice: thanks
13:17:08 <Gurkenglas> By the way, you can do "paths . traverse . _Just . get . security"
13:17:12 <dsal> I'm having a moment of stupid -- how do you make a function to add (a,a) ?
13:17:56 <LesterLee> Gurkenglas: sry afk, brb :/
13:18:18 <Gurkenglas> :t \(x,y) (z,w) -> (x+z, y+w) -- dsal
13:18:20 <lambdabot> (Num t, Num t1) => (t1, t) -> (t1, t) -> (t1, t)
13:18:59 <Gurkenglas> dsal, the NumInstances package lets you just do (x,y) + (z,w)
13:19:02 <dsal> Gurkenglas: Sorry, I get that -- I mean I want to make (a,a) applicable to +.  Seems like some combination of • and uncurry would do it, but that's not it.
13:19:24 <Gurkenglas> :t uncurry (+)
13:19:26 <lambdabot> Num c => (c, c) -> c
13:19:49 <dsal> oh.  ha.
13:20:03 <dsal> I was putting a . in there and really confusing myself.
13:20:23 <dsal> Thanks.  That seems really obvious.
13:20:36 <Gurkenglas> LesterLee, or "paths . each . _Just . get . security" if you prefer
13:20:51 <Gurkenglas> You can even replace _Just with traverse.
13:21:39 <mniip> Gurkenglas, this is the future - literally just writing code in english
13:21:42 <Gurkenglas> LesterLee, compare with if that Maybe had been []
13:24:34 <Gurkenglas> Oh wait, it's "paths . each . get . _Just . security", was confused by the position of the ^ in the paste :P
13:25:12 <Gurkenglas> If you like english you can turn that _Just into each.
13:31:19 <sqooq> I upgraded stack but it's still using the older version
13:31:31 <sqooq> .local/bin is in my environmental vairiables already
13:31:36 <sqooq> and stack is in there
13:33:00 <MarcelineVQ> enrionment variables?
13:33:26 <sqooq> ye
13:33:44 <MarcelineVQ> What do you mean by that?
13:33:53 <sqooq> my PATH
13:33:59 <MarcelineVQ> ah good, is it at the front of your path?
13:34:05 <sqooq> yes
13:34:16 <geekosaur> hash -r
13:34:30 <MarcelineVQ> what does  which stack  say?
13:34:49 <geekosaur> if you already ran stack and it was found at one place in $PATH, that will be remembered; if a new one is added later, even if it is earlier in $PATH, it will not be used
13:34:51 <MarcelineVQ> and have you tried it in a new terminal
13:34:58 <geekosaur> "which" often does not show you this!
13:35:02 <sqooq> it says .local/bin
13:35:06 <geekosaur> use "type"
13:35:14 <sqooq> type stack?
13:35:25 <geekosaur> yes
13:35:31 <sqooq> It shows the right location
13:35:33 <sqooq> hmm let me try again
13:35:41 <sqooq> O
13:35:42 <MarcelineVQ> and what does  stack --version  say?
13:35:43 <sqooq> it's updated now
13:35:44 <sqooq> nvm
13:35:57 <sqooq> Guess it took a bit to kick in idk
13:36:02 <geekosaur> did you do the hash -r I suggested?
13:36:04 <geekosaur> that resets the remembered locations of things
13:36:07 <sqooq> o
13:36:08 <sqooq> yes
13:36:09 <sqooq> i did lol
13:36:25 <MarcelineVQ> I've never ran into that but now I know to look for it, thanks geekosaur 
13:36:55 <sqooq> "In the dependencies for gould-0.2.1:     chart must match -any, but the stack configuration has no specified version     chart-gtk must match -any, but the stack configuration has no specified version"
13:37:04 <sqooq> wat
13:37:06 <shapr> what's the difference between hash -r and rehash?
13:37:54 <MarcelineVQ> sqooq: put plainly stackage doesn't currently have gould
13:38:24 <MarcelineVQ> https://docs.haskellstack.org/en/stable/GUIDE/
13:38:30 <Cale> sqooq: That means that chart and chart-gtk are not available from any of the sources that stack is configured to use.
13:38:37 <MarcelineVQ> er chart sorry
13:39:03 <sqooq> but it's in hackage
13:39:04 * sm has which aliased to type -a
13:39:09 <sqooq> and csound-expression worked
13:39:15 <MarcelineVQ> however it might have Chart
13:39:17 <geekosaur> shapr, they're the same. "rehash" is how csh (which introduced the idea) did it, "hash -r" is how ksh did it]
13:39:19 <sm> one of bash's fearsome arsenal of foot guns
13:39:25 <geekosaur> various shells may support one or the other or both
13:39:39 <shapr> geekosaur: neat, I learned something new!
13:39:56 <geekosaur> and "hash -r" is the one blessed by POSIX
13:40:13 <sm> slightly related, would anybody recommend using oil shell ?
13:40:17 <shapr> what's type?
13:40:36 <Xe> the action of inputting things with a keyboard
13:40:40 <sm> shapr: a built in command, like /usr/bin/which but knows about shell aliases etc.
13:40:42 <sqooq> o it is a capital C
13:40:46 <shapr> oh neat
13:40:50 <geekosaur> shows what the shell knows about something: builtin, alias, function, hashed executable, exeuctable found on $PATH (and here it is in the latter two cases)
13:41:02 <geekosaur> in shells that can autoload functions it may show you where it was autoloaded from
13:41:13 <shapr> ohh
13:41:21 <Infinisil> sm: Have heard lots about oil shell with the blog posts, but I won't use any new shell unless it has significant benefits
13:41:37 <shapr> I like my heavily customized zsh
13:41:39 <geekosaur> it is required by POSIX to show state like whether it's been hashed, so in general it's the best bet to see where your current shell thinks some command came from
13:42:06 <shapr> nifty
13:42:49 <sm> Infinisil: I just discovered those posts, going to start at the beginning
13:43:16 <shapr> zsh has whence, neat
13:45:45 <LesterLee> Gurkenglas: Thanks for the suggestions! (That looks nice! :)) Sadly ghc is not yet convinced: http://lpaste.net/495376949485502464
13:45:59 <Infinisil> shapr: What's the difference to which?
13:47:44 <shapr> Infinisil: which is a separate binary, whence is built into zsh
13:47:59 <shapr> oh well, maybe not
13:48:01 <Gurkenglas> LesterLee, oh for some reason I expected paths to be a list. Use traverse instead of each
13:48:27 <shapr> Infinisil: I don't know
13:49:36 <SenzaVita> Hi
13:50:08 <shapr> uhh
13:50:09 <shapr> bye?
13:50:24 <shapr> I've seen people get frustrated with Haskell, but that was INSTANT
13:50:25 <geekosaur> it will depend on the shell. whence and which came from different unix development origins, type was created by POSIX. type *must* be a shell builtin; traditionally BSD which was an external command and "whence" was built into some shells. these days' your best bet is to check your shell's documentation
13:50:59 <LesterLee> Gurkenglas: Awesome, that did it - thanks! :) http://lpaste.net/495376949485502464
13:51:45 * geekosaur wonders if that was another Italian bot probe (the "ciao"/"!list" bit which seems to be happening a bit more often than usual the past couple days; some users seem confused about how to use it though so you get other behaviors...)
13:52:36 <Gurkenglas> Do we have the thing yet that lets you use @Foo to not need "Proxy :: Proxy Foo"?
13:55:59 <lyxia> TypeApplications?
13:56:40 <lyxia> We have that since 8.0
14:04:25 <nshepperd_> Some people just aren't used to a response to their messages taking longer than 30 seconds, and assume the room is empty
14:05:53 <mud> Is there an instance of Floating somewhere that's arbitrary precision in some way? Or at least possible to get more precise values than Double can give?
14:06:02 <sm> Decimal
14:06:29 <mud> Ah, thanks
14:06:45 <ClaudiusMaximus> any library to solve matrix system A x = b over Rational?
14:08:18 <mud> sm: Hm, doesn't actually appear to be an instance of Floating
14:08:21 <ClaudiusMaximus> mud: there's 'compensated' for double-double style arithmetic, and 'rounded' which binds to mpfr (though i don't think rounded is on hackage, there are a couple of pull requests on github to bring it up to date)
14:08:39 <sm> mud: I'm not sure, then
14:09:03 <mud> ClaudiusMaximus: Thanks, I'll peek at those
14:09:05 <mud> sm: Thanks anyway
14:09:27 <alpounet> mud: https://hackage.haskell.org/package/numbers-3000.2.0.1/docs/Data-Number-CReal.html might be close to what you want?
14:10:11 <mud> Ah, that sounds quite likely, yeah
14:10:49 <sm> does that mean you can't easily do trigonometric functions with Decimal ? 
14:10:57 <sm> slightly unfortunate
14:11:05 <nshepperd_> Is there a quad precision type
14:22:26 <sbditto85> anyone know if there is a way to have a session backend, but just “turn it off” for a request … meaning it doesn’t persist anywhere and basically just becomes a Map you can use during the request?
14:29:53 <ClaudiusMaximus> https://hackage.haskell.org/package/Vec-1.0.5/docs/Data-Vec-LinAlg.html#v:solve works with Rational, but the types are hairy, particularly as I want to choose the dimension at runtime - is there anything else out there?
14:35:13 <mud> sm: Seems like it, ya
14:46:45 <ClaudiusMaximus> found that the list-based code referenced by Vec works over Rational too, still compiles and works fine (after adding an Eq constraint)  https://mail.haskell.org/pipermail/glasgow-haskell-users/2007-May/012648.html
14:51:23 <verement> mud: You might also consider https://hackage.haskell.org/package/decimal-arithmetic
15:14:14 <taktoa> hmm, I have a value of type [(Time, (Bool, UUID))], where the bool is true if a user with that uuid connected and false if it's a disconnect (my actual code is cleaner than that but I'm using bool for simplicity here)
15:14:14 <taktoa> does anyone know of a type Foo such that there exist functions `genFoo :: [(Time, (Bool, UUID))] -> Foo` and `atTime :: Foo -> Time -> Set UUID` and atTime takes O(log(n)) time and genFoo takes O(n) space
15:15:30 <taktoa> I feel like there might be some kind of binary search tree I could use but idk
15:17:46 <akr> Hello, does anyone know how I can generate a redirect with Blaze?
15:18:14 <hpc> what kind of redirect?
15:18:48 <akr> a user clicks a link, and sometimes it starts a download, sometimes it's supposed to just redirect you to a different website
15:19:16 <taktoa> ah, I think this is what I want https://en.wikipedia.org/wiki/Interval_tree
15:20:22 <hpc> akr: i mean in terms of what html you want to create
15:20:34 <hpc> what you've described does not sound like a redirect
15:21:17 <akr> okay, I should generate the html so that it either starts a download or is just a link
15:21:22 <akr> I supppose
15:22:06 <hpc> possibly
15:22:25 <hpc> blaze's API is 1:1 with html, so to understand what you want to do with it, you need to know what html it should make
15:23:01 <akr> hmm, yeah
15:23:05 <akr> I don't really know much HTML
15:23:14 <akr> thanks for the help though
15:24:24 <hpc> it shouldn't be terribly hard to figure out, as long as you stick to features that have been around a while getting visible results of any sort is very quick
15:25:34 <akr> yeah I'll figure something out
15:26:03 <boj> akr: redirects like what you described are typically server side
15:26:24 <boj> blaze isn't the tool that would do this
15:26:26 <akr> that's what I was thinking originally
15:26:30 <akr> hmm
15:26:40 <akr> so what would do it?
15:26:55 <akr> I suck at frontend :/
15:26:56 <boj> what are you using to serve the blaze html?
15:27:33 <akr> cgi
15:27:51 <boj> something non-haskell?
15:28:05 <akr> no it's some cgi haskell library
15:28:09 <boj> gotcha
15:28:21 <andromeda-galaxy> akr: are you using a wai cgi interface?
15:28:30 <boj> i don't know much about that library specifically, but that is where you'd do a redirect
15:29:02 <akr> alright, I see
15:29:08 <akr> I'll have a look at the docs
15:29:51 <akr> ah, nice
15:29:56 <akr> found it, thanks!
15:29:58 <andromeda-galaxy> akr: do you want to serve a redirect response that just asks the browser to go to a different uri, or do you want to just serve the content of some other uri?
15:30:04 <boj> akr: :)
15:30:18 <akr> andromeda-galaxy: I want to go to a different uri
15:30:31 <akr> this should do it https://hackage.haskell.org/package/cgi-3001.3.0.2/docs/Network-CGI.html#v:redirect
15:31:15 <andromeda-galaxy> akr: oh okay, I was going to suggest https://hackage.haskell.org/package/cgi-3001.3.0.2/docs/Network-CGI.html#v:redirect
15:31:18 <andromeda-galaxy> sorry I mean
15:31:22 <andromeda-galaxy> https://hackage.haskell.org/package/wai-util-0.8/docs/Network-Wai-Util.html#v:redirect
15:31:33 <andromeda-galaxy> but your cgi interface isn't wai
15:32:01 <akr> I suppose mine's more ancient :)
15:32:34 <andromeda-galaxy> it's probably a good choice if you're planning on continuing on cgi
15:32:50 <andromeda-galaxy> if you might want to switch to like warp or something later is the main reason that I would use wai
15:33:10 <hpc> you can also get pretty far with fastcgi
16:05:17 <slack1256> nice, hackage has better voting mechanism now
16:05:38 <koz_> slack1256: What's changed, out of interest?
16:06:47 <slack1256> voting on a "stars" metric that when pressed ask you directly for your username + password without going to another page
16:06:58 <slack1256> little UX thing, but make voting more relevant
16:13:09 <Rotaerk2> hmm not sure if this is an issue with the HUnit package, or with nixpkgs's configuration for it
16:13:47 <Rotaerk2> but if I use the latest nixpkgs and try to build HUnit from ghc8+, with executable profiling enabled, it fails
16:14:47 <Rotaerk2> I can get it to work by targeting the latest ghc7 *or* by disabling executable profiling
16:18:53 <dmj`> Rotaerk2: what’s the error?
16:20:39 <Rotaerk2> hmm hold on; I'm now seeing a different error than I did before
16:22:09 <slack1256> Rotaerk2: the binary cache of nixpkgs has already ghc8 as haskellPackages?
16:22:34 <orzo> is fromIntegral guaronteed to take the low bytes when converting from Int64 to Int (32 bit)
16:22:44 <Rotaerk2> dmj`, this is what I was seeing earlier:  https://ptpb.pw/5IYU
16:22:51 <orzo> i actually want the high bytes
16:23:26 <Rotaerk2> this is what I'm seeing now:  https://ptpb.pw/VHo0
16:23:50 <Rotaerk2> now back to figuring out the pattern to this...
16:24:18 <Rotaerk2> slack1256, what do you mean?  the latestt nixpkgs has ghc801, ghc802, and ghc821
16:24:41 <Rotaerk2> and I think the binary cache has at least some of them
16:24:50 <Rotaerk2> didn't have to build from scratch
16:28:52 <Rotaerk2> yea ignore the first paste; that was a different scenario with confounding factors
16:29:04 <Rotaerk2> the second paste, https://ptpb.pw/VHo0, should be straightforward to reproduce
16:29:12 <Rotaerk2> in which case it's not HUnit failing, but one of its dependencies
16:30:56 <Rotaerk2> testing to see if my own project builds now, if I disable executable profiling
16:31:05 <slack1256> Rotaerk2: I mean that the haskellPackages set point to ghc821 instead of ghc802 
16:31:56 <Rotaerk2> slack1256, oh, I don't use haskellPackages
16:32:12 <Rotaerk2> I use haskell.packages.ghc***
16:32:18 <slack1256> oh, ok
16:32:44 <Rotaerk2> but yea, the latest haskellPackages still points to 802, it looks like
16:39:10 <jollygood3> is the whole point of Applicative to have fmap that maps over than one functor? ie liftA2, liftA3, etc
16:39:44 <hpc> it's /a/ whole point ;)
16:41:23 <jollygood3> such an intimidating name for something so simple
16:41:51 <Rotaerk2> well, it's a functor with the ability to trivially move a single value into that functor's context (pure), and to apply functions in the functor's context to arguments in the functor's context
16:42:04 <Rotaerk2> applicative seems applicable
16:43:15 <Rotaerk2> <*> is just like <$> (or fmap) except that the mapping function is in the functor context instead of outside of it
16:43:56 <jollygood3> Rotaerk2 but is that ever useful in itself? other than by using it to implement liftN
16:44:07 <andromeda-galaxy> Applicative Functor makes sense as a term because it is a functor where you can apply a function inside the functor
16:45:06 <Rotaerk2> :t (<*>) . pure
16:45:08 <lambdabot> Applicative f => (a -> b) -> f a -> f b
16:45:18 <Rotaerk2> (<$>) = (<*>) . pure
16:45:55 <jollygood3> yes, but we already had fmap even without applicative or <*>
16:46:54 <andromeda-galaxy> jollygood3: Applicatives give a notion of "sequencing" that is weaker than that given by monad
16:46:54 <Rotaerk2> that's not for showing a way to get <$> from applicative, that's just showing how fmap and <*> are related
16:47:03 <andromeda-galaxy> this makes them useful for lts of stuff
16:47:14 <Rotaerk2> that fmap could be thought of as a special case of <*>, particularly where you're always dealing with a pure function
16:47:47 <Rotaerk2> so <*> is a generalization of fmap
16:48:51 <andromeda-galaxy> jollygood3: what would be a better name? The core thing that makes an Applicative stronger than a functor is a notion of application, so to me it makes perfect sense to name it after
16:49:24 <andromeda-galaxy> agh is there any way to do ExistentialQuantification in plane H'98?
16:50:03 <hpc> nope
16:51:13 <hpc> although there's a certain pattern called existential type classes, which you can do with an ordinary data structure
16:51:18 <hpc> (it's an anti-pattern)
16:51:34 <hpc> https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
16:52:00 <andromeda-galaxy> Rank 2 Types?
16:52:24 <andromeda-galaxy> also afaict that is a thing that uses existentialquantification?
16:52:41 <andromeda-galaxy> (the forall on AnyWidget)
16:53:06 <jollygood3> Rotaerk2, interesting. but is it commonly useful outside of implementing liftN? I can't think of cases where I'd have function wrapped in some context
16:54:21 <Rotaerk2> jollygood3, it's sometimes used as an almost-monadic effect mechanism
16:54:25 <jollygood3> other than doing something like this (and liftA2 covers this case)
16:54:38 <jollygood3> :t fmap (+)
16:54:40 <lambdabot> (Num a, Functor f) => f a -> f (a -> a)
16:54:49 <Rotaerk2> particularly the *> and <* functions
16:57:41 <Rotaerk2> jollygood3, parse $ ABS.takeTill (`BS.elem` "\CR\LF") <* (pCR <* optional pLF <|> pLF)
16:58:58 <Rotaerk2> ABS.takeTill (`BS.elem` "\CR\LF") means to consume and capture all the bytes up until (but not including) CR or LF
16:59:03 <jollygood3> hmm ok, didn't get to <* yet
16:59:14 <jollygood3> :t (<*)
16:59:15 <lambdabot> Applicative f => f a -> f b -> f a
17:00:13 <Rotaerk2> jollygood3, thing is, you can think of the applicative functor f x as an *action* that results in an x
17:00:15 <jollygood3> > Just 10 <* Just 20
17:00:15 <erisco> I just paid attention to the fact number literals with decimals are Fractional, not Floating
17:00:17 <lambdabot>  Just 10
17:00:43 <erisco> > 3.141592654 :: Rational
17:00:44 <Rotaerk2> a <*> b sequences the action a, which produces functions, followed by the action b, which produces arguments, and then applies the functions to the arguments
17:00:45 <lambdabot>  1570796327 % 500000000
17:01:26 <erisco> but unfortunately they default to Double!
17:01:27 <Rotaerk2> a *> b sequences the action a followed by action b, (with no actual function application going on), and returns the b
17:01:52 <Rotaerk2> though the "action" metaphor doesn't always make sense, such as for Maybe and such
17:02:01 <Rotaerk2> but you can *> an IO
17:02:28 <hpc> Rotaerk2: sure it does, the "action" of Maybe is checking success
17:02:38 <hpc> a *> b = check if a succeeds, then do b
17:02:51 <Rotaerk2> putStrLn "Hello" *> getLine
17:02:52 <jollygood3> > Nothing <* Just 10
17:02:54 <lambdabot>  Nothing
17:03:07 <Rotaerk2> hpc, I guess
17:03:32 <jollygood3> Rotaerk2 print, run getLine action, return result?
17:04:24 <jollygood3> kind of like >>= that ignores the argument
17:06:15 <Rotaerk2> monads can do a bit more than applicative, but the sequencing concept is similar
17:06:38 <Rotaerk2> anyway, bbl
17:07:48 <jollygood3> *> can be implemented with liftN too I think? just return the second argument
17:08:05 <jollygood3> or Nth argument
17:08:06 <slack1256> reminder kids, good people don't tell other good people that monads are not about sequencing, at least in haskell
17:08:30 <lavalike> jollygood3: this is a neat application https://github.com/pcapriotti/optparse-applicative
17:10:29 <erisco> what is "sequencing"
17:13:34 <andromeda-galaxy> so I'm trying to make applicatively-composable functions that scan through text. conceptually the "primitive" values of the applicative are a pair of some identifier string and some function to run on the first instance of text bracketed by that identifier. The obvious thing to do is to have the applicative representation be Text -> a and convert these into scan functions and then compose them 
17:13:40 <andromeda-galaxy> the normal way, but that is rather inefficient because the whole (potentially large) input text is scanned over once for every time a "primitive" values are used.  Fairly obviously this can be converted into a linear scan while remaining semantically the same, but I can't figure out any way to do that in H'98 without ghc specific extensions - does anyone know if there is one?
17:14:39 <jollygood3> lavalike that looks neat. Sample can take arbitrary number of options? you just keep chaining them with <*>?
17:15:20 <erisco> andromeda-galaxy, what is an example text input and the corresponding output?
17:17:58 <andromeda-galaxy> erisco: suppose we have f :: ThisThing (String -> String) where f's identifier is "F" and its function is \x -> \y -> x ++ y. also G is ThisThing String with identifier "G" and function \x -> x. Then f <*> g "run" on the input "FaFblahGbG" would b "ab".  Running it on "GbGblahFaF" would also give ab
17:55:11 <erisco> andromeda-galaxy, I do not understand. Maybe if you start explaining more basically, such as from what the problem is
18:06:23 <andromeda-galaxy> erisco: the problem that I want to solve right now is to make an easy interface for these programs that generate C code, compile it, and inspect the binary.
18:07:12 <erisco> I do not yet understand what problem these programs solve. Then I have to understand the intention of how to construct these programs
18:07:28 <andromeda-galaxy> the problem that these programs solve is related to hsc2hs cross compile mode
18:07:35 <andromeda-galaxy> or rather a reimplementation of it
18:07:38 <erisco> then I might have some advice, but no guarantees
18:08:15 <andromeda-galaxy> you can create static enums in C filled in with information that is a compile time constant and the values will be serialized in relatively predictable ways to the output binary of the compiler
18:08:31 <andromeda-galaxy> so if we are processing some hsc2hs file with a bunch of say #const directives in it,
18:09:08 <andromeda-galaxy> for each directive we want to add to the C program a static enum that uses the #const expression in a certain way and happens to have easily identifiable start and end markers
18:09:37 <andromeda-galaxy> then we want to load the binary file up, find out what's between the start/end markers, read it in a certain way, and return that as some useful information to the user (by writing it to a .hs file)
18:10:21 <andromeda-galaxy> so the idea is to make a way to easily compose these "actoins"
18:10:41 <andromeda-galaxy> the idea is to make the bit that generates C code take in the start/end markers as an argument and then promise to generate the right C
18:11:37 <andromeda-galaxy> and then to efficiently and in a single pass scan the generated object file: every time that we see any of the identifiers that we generated and passed to the c-code-generator, we call the corresponding action on whatever is between the markers
18:11:45 <erisco> okay, so it sounds like there is a parsing problem and a code generation problem
18:12:03 <andromeda-galaxy> right
18:12:08 <andromeda-galaxy> the C-code-generation is reasonably easy
18:12:10 <andromeda-galaxy> the object-file-parsing is harder
18:12:15 <erisco> why
18:12:50 <erisco> do you have a grammar for the object file format?
18:13:36 <andromeda-galaxy> re: grammar: it would depend on what happened when we generated the C code earlier
18:13:57 <andromeda-galaxy> basically the object file is a big thing of text and we have some 'n' identifiers that generated and gave to the C generator earlier
18:14:21 <andromeda-galaxy> every time that we see any text surrounded by any one of those identifiers we want to do the corresponding right thing
18:14:35 <andromeda-galaxy> so to do this efficiently we need to know all of the identifiers up front and then we can use like Aho-Corasick or whatever
18:15:25 <erisco> are you saying the transformation is on the structure of text (a list of characters) and not on the structure of the object file or C program?
18:15:45 <andromeda-galaxy> what transformation?
18:15:55 <erisco> I don't know
18:16:07 <boj> hmm
18:16:12 <andromeda-galaxy> so the issue at hand is to take in this object file and extract a bunch of information from it
18:16:17 <andromeda-galaxy> the object file is just text
18:16:22 <erisco> I am trying to distill a fire hose of information
18:16:26 <andromeda-galaxy> we want to turn that into some nice haskell object
18:17:07 <erisco> so, why can we not just parse the object file using the grammar of object files?
18:18:13 <andromeda-galaxy> there isn't any aot known grammar of object files
18:18:18 <andromeda-galaxy> we are just viewing it as a flat string
18:18:50 <erisco> well, I suggest looking at the specification/standard for object files and obtaining the grammar
18:19:09 <andromeda-galaxy> sadly impossible here
18:19:11 <erisco> and that is if there is not already a package for parsing object files of this format
18:19:19 <erisco> why is this impossible?
18:19:20 <andromeda-galaxy> the specification for the object file is whatever the users cross compiler spit out
18:19:22 <boj> andromeda-galaxy: are you familiar with haskell's parsing libraries? parsec/attoparsec/etc?
18:19:33 <andromeda-galaxy> and it has to work for any cross compiler that people want to use to build a cross ghc
18:20:19 <andromeda-galaxy> boj: indeed. and building up an attoparsec parser is a reasonable but inefficient way to do this - the algorithmic problem for the string scanning really comes down to multiple substring matching which we can do with Aho-Corasick much more efficiently than via attoparsec
18:20:22 <erisco> so then, have different parsers for different known formats of object files
18:20:36 <andromeda-galaxy> but we don't actually care about the object file format
18:20:49 <erisco> alternatively, develop a grammar that describes the structure you are interested in common to these formats
18:20:54 <andromeda-galaxy> and all the data that we are trying to extract is inside the static data segment somewhere
18:21:12 <erisco> one problem at a time
18:21:23 <erisco> you have an object file, you want some information in this object file, figure out how to get that first
18:21:32 <andromeda-galaxy> the object file format standards don't specify the structure of the static data segment
18:21:47 <andromeda-galaxy> right that's what I'm trying to do. that approach doesn't get that information
18:21:50 <erisco> but can you locate the static data segment?
18:22:05 <boj> andromeda-galaxy: i guess what is puzzling is that if you can't define a grammar, then how do you know what to extract in the first place?
18:22:48 <andromeda-galaxy> erisco: sure but I don't need to - anything that I can run to extract the data from inside .bss I can run on the whole object file with small enough epsilon negative consequences
18:23:40 <andromeda-galaxy> boj: there is a runtime known grammar which is that there are some set of keywords and we want to extract data from inside matched sets of keywords. But the keywords aren't known ahead of time.  It's fine at runtime to build up a parsec parser that looks for these matched keywords, but that's asymptotically inefficient compared to just looking for them using an optimized multi substring matching 
18:23:46 <andromeda-galaxy> algorithm
18:24:31 <boj> ok, so the method of parsing aside, what is your actual problem?
18:25:10 <andromeda-galaxy> every time that we find a keyword pair we need to run the associated action on the text between them
18:25:32 <andromeda-galaxy> that action will parse the data from between them into some haskell format
18:25:48 <andromeda-galaxy> but we need to be able to aggregate the data from multiple of these keyword pairs into the final haskell value
18:26:08 <ClaudiusMaximus> why not do something like  { magicvalue, constantid, constant, checksum }  so you only have to substring search for the magic value (modulo endianness), collect the data into a Map using fromListWith or similar?
18:27:18 <andromeda-galaxy> ClaudiusMaximus: that's basically what's being done, but we need to be able to combine data from multiple of the 'constants' because of annoying things like alignment
18:27:23 <ClaudiusMaximus> if you're in control of the object file data, make it more expressive and avoid the multi substring matching problem
18:27:57 <andromeda-galaxy> sadly, the C standard doesn't say enough about how structs are layed out to make that possible
18:28:51 <boj> so is this an efficiency problem? i still have no clue what you are having trouble actually doing
18:28:52 <andromeda-galaxy> boj, erisco: so the problem is that when we see a matching pair of keywords we need to hang onto the parse result of the data which is going to be of some type 'a' and properly combine it with the parse results of the other pieces of data from the file which are of disparate types
18:29:19 <andromeda-galaxy> boj: okay so lets say I'm writing an applicative instance for this thing
18:29:40 <andromeda-galaxy> and I'm writing (<*>)
18:29:49 <andromeda-galaxy> f <*> x say
18:30:13 <andromeda-galaxy> then the obvious thing to do is to basically say parse (f <*> x) string = (parse f string) (parse x string)
18:30:35 <erisco> okay, so this is like parsing XML tags
18:31:35 <erisco> what is the need of this thing with Applicative?
18:32:07 <boj> i assume that was a path towards dialing the explanation back from 11 to a 3
18:32:11 <andromeda-galaxy> combining together the "actions" (C generator + obj "parser") that compute data
18:33:18 <andromeda-galaxy> so that for example I can write dealWithAlignment <$> figureOutAlignment <*> theRawData
18:33:27 <erisco> this problem is too big to fit into my head
18:33:57 <boj> well, if erisco doesn't get it i definitely don't
18:34:52 <andromeda-galaxy> erisco, boj: we can reduce the problem from composing these generators+parsers to composing just parsers, would that help?
18:35:25 <boj> andromeda-galaxy: maybe take a deep breath and distill your problem down to 1 to 2 lines, maybe an lpaste
18:35:31 <erisco> if you want to focus on just the parsing problem, that is more manageable
18:35:49 <andromeda-galaxy> yeah
18:35:51 <erisco> am I right that it is like parsing XML tags?
18:35:59 <ClaudiusMaximus> there are some parser/printer pairs out there in research-land, probably some of them use Applicative
18:36:47 <andromeda-galaxy> erisco: maybe? except that there's no nesting and the each tag might have different delimiters
18:37:13 <erisco> what do you mean by tags having different delimiters? I thought tags were delimiters
18:37:19 <ClaudiusMaximus> eg http://www.staff.science.uu.nl/~swier004/publications/2017-tyde-a.pdf
18:37:27 <andromeda-galaxy> oh okay I misunderstood you
18:37:52 <andromeda-galaxy> then the differences are: no nesting, no delimiters around tags (no '<', '>') and the possible tags are known aot
18:38:13 <andromeda-galaxy> or, not aot, but while building/before running the parser
18:38:51 <erisco> what have you tried to parse these tags thus far?
18:39:06 <andromeda-galaxy> ClaudiusMaximus: this is dead easy to do using standard applicative parsing techniques but those aren't efficient
18:39:58 <andromeda-galaxy> erisco: well the obvoius and relatively easy implementation is to just scan the string once for each kind of tag that we want to get the value out of
18:40:25 <andromeda-galaxy> that makes it easy because your parser for f <*> x is just (parse f) (parse x) and you can just let each of the subparsers do its own scan
18:40:58 <c_wraith> andromeda-galaxy: what's the basis of your claim that applicative parsers aren't efficient?
18:41:05 <andromeda-galaxy> the problem is that I would rather lift all the scans up to the top so that they can be fused into one scan via Aho-Corasick
18:42:13 <andromeda-galaxy> c_wraith: not that they aren't efficient in general, but that they can be beaten in this case. this particular case comes down to lots of basically (string a <|> string b <|> string c <|> char) kinds of parsers where the standard applicative parsing techniques will run a string comparsion once for each option once on every charactor
18:42:22 <erisco> eh, I took a few second look at this algorithm and it seems to me to throw the needles into a trie
18:42:40 <andromeda-galaxy> erisco: so implementing the algorithm isn't the hard part, the hard part is what to do when you find a needle
18:42:45 <erisco> I don't see the importance of this unless your tags are very long
18:43:05 <erisco> what have you tried?
18:43:27 <andromeda-galaxy> oh so I'm not trying to do it this way because there are actual performance problems with the other way
18:44:28 <andromeda-galaxy> I'm trying to do it this way because I'm doing this project for fun and want to do everything the "right" way
18:44:46 <erisco> lesson one: the right way is the simple way.
18:45:09 <andromeda-galaxy> oh sure I agree in lots of cases
18:45:28 <andromeda-galaxy> in this case I'm interested in the challenge of doing it neatly with a better but weirder algorithm
18:45:53 <erisco> have you done it neatly with a less weird algorithm?
18:46:22 <c_wraith> andromeda-galaxy: write your own parser library that builds a data structure reifying the parser and analyze that to derive your target algorithm.
18:46:47 <c_wraith> andromeda-galaxy: that's a thing you can do with Applicative, and the main advantage of Applicative over Monad - the structure is statically available.
18:46:53 <andromeda-galaxy> erisco: yes, with standard applicative parsing techniques
18:47:06 <andromeda-galaxy> c_wraith: yeah, I know - that's what I'm trying to do now, and why I've been talking about Applicative instead of Monad
18:47:15 <erisco> c_wraith, what do you suggest for reification? I got stuck with the technique I tried
18:47:30 <c_wraith> I'm lazy and would use a free Applicative.
18:47:35 <c_wraith> Someone else has already done the work.
18:48:00 <andromeda-galaxy> oh right, I also know how to do this if we have existentialquantification, rankntypes, any/unsafecoerce, etc. but this has to be in vanilla H98
18:49:10 <erisco> andromeda-galaxy, I would figure out if there is a known class of grammars this falls into
18:49:51 <erisco> andromeda-galaxy, because then I can focus on implementing combinators for this class of grammars and be less confused with unnecessary detail of this particular problem
18:51:30 <andromeda-galaxy> the difficulty is in putting the functons being fmapped over things into the reified structure/using them in the string matcher loop, because they return arbitrary types
18:52:04 <andromeda-galaxy> erisco: I did try to look into that a bit, but I couldn't figure out an obvious way to generalize the grammar
18:52:41 <erisco> you just look at the class of grammars and see "yes, all the grammars I am interested in are in this class"
18:53:26 <andromeda-galaxy> afaict all the grammars that I'm interested in are sub-regular in the chomsky hierarchy
18:53:59 <erisco> okay, and so dig around and see what you can find
18:54:07 <andromeda-galaxy> using an overly powerful class of grammar like regular languages leads to not being able to work as efficiently
18:54:09 <erisco> or alternatively, figure out a construction for your grammars
18:54:23 <andromeda-galaxy> no I mean the bottom of the standard hierarchy of grammars is way to high for this particular problem
18:54:30 <erisco> Haskell is definitely not the place to start with this problem
18:54:47 <Cale> Why not?
18:55:10 <erisco> because it is going to add unnecessary noise
18:55:38 <erisco> if regular languages are too much then, again, dig around for even simpler ones
18:55:46 <erisco> I don't know any myself but I am sure there is something to find
18:55:55 <erisco> alternatively, figure out a construction for your grammars
18:56:02 <Cale> Well, if you're suggesting the right place to begin is pure mathematics, I might agree :)
18:56:08 <erisco> yes, I am
18:56:22 <andromeda-galaxy> the language class is only "languages" that are recognizable purely by looking up constant substrings
18:56:36 <andromeda-galaxy> the math formulation is completely trivial and doesn't shine any light on the haskell problem at all
18:56:53 <Cale> Sometimes Bird-style equational reasoning about programs can produce good results
18:57:02 <erisco> the problem you described to me does not suggest only grammars of constants
18:57:12 <erisco> you said there were tags which delimited blocks of text
18:58:14 <andromeda-galaxy> oh sure but now we're talking about math and they're reducable to the same easily: since we know the tags we're interested in we only need to look up the indices of all of them, and at that point we know that the string is a member of the language. To construct which member of the language we can just run arbitrary functions on the string and those indices
18:58:14 <erisco> the point is to make clear what simple things you need for your program to work, and then you worry about implementing this in Haskell
18:58:21 <erisco> at least then you're directed in what you need to do
18:58:41 <erisco> so problems with reification and type systems and so forth must serve this ideal you already have defined
18:59:20 <andromeda-galaxy> I already basically have that though. I know what the parsing algorithm should look like and what the grammar construction should look like
19:05:11 <erisco> well, how do you construct a grammar in your language then
19:05:16 <erisco> a grammar for your languages
19:06:40 <andromeda-galaxy> applicatives
19:07:44 <erisco> that seems weaksauce to me
19:08:20 <erisco> if you look up how to construct regular grammars then you will see it is precise and clear
19:08:33 <erisco> I am not sure how "applicatives" is a sufficient description
19:10:05 <c_wraith> You won't really be able to reify this without existentials using Applicative.
19:10:24 <c_wraith> The nature of Applicative composition is that intermediate type information is lost.
19:10:32 <andromeda-galaxy> c_wraith: thank you. that is what I've been trying to get at during this whole thing
19:10:38 <andromeda-galaxy> that is precisely what was wrong
19:10:43 <c_wraith> So just create a tree.
19:10:50 <andromeda-galaxy> I was looking for solutions
19:10:55 <andromeda-galaxy> ah right
19:11:02 <andromeda-galaxy> so that's the obvious way to do it
19:11:16 <c_wraith> Yes, the obvious solution is usually the good one.
19:11:24 <andromeda-galaxy> not quite here though
19:11:41 <andromeda-galaxy> the tree has the same problem that we can't run the optimized string matcher
19:11:41 <c_wraith> I'd just use existentials.  They work.
19:12:06 <c_wraith> You can if you build the right tree.
19:12:24 <andromeda-galaxy> re: existentials: they don't exist in nch98 though
19:12:28 <andromeda-galaxy> re: the right tree: how?
19:13:16 <c_wraith> However you need to.
19:13:32 <andromeda-galaxy> don't you end up losing the type information again inside the scanner function?
19:13:45 <andromeda-galaxy> the type of the produced data depends on the keyword that we just scanned is the problem
19:14:30 <c_wraith> so get rid of the typed intermediate representation
19:14:46 <c_wraith> If you refuse to use language extensions that let you type it, you can't type it.
19:15:22 <andromeda-galaxy> I'd love to use them but I'm working on a project that I /think/ wants to remain compatible with nhc98
19:17:25 <andromeda-galaxy> how do you get rid of the typed intermediate representation without using Data.Dynamic or GHC.Prim.Any/unsafeCoerce?
19:20:26 <c_wraith> I mean, it sounds like the intermediate representation you actually want is slices of the input, anyway.
19:21:09 <andromeda-galaxy> yeah, but you can't get the slices of input while building the tree - only after you've finished - since the input-slicing algorithm needs to consider all the leaves of the tree
19:22:10 <c_wraith> I had envisioned those as independent phases. phase 1: grammar tree. phase 2: anything that actually handles input.
19:22:27 <andromeda-galaxy> oh yeah exactly
19:22:40 <andromeda-galaxy> but you can't build the grammar tree out of slices of input if you don't have the input until phase 2
19:23:30 <c_wraith> was the entire point here to build a self-modifying data structure?
19:24:00 <c_wraith> I was operating on the assumption that reading the rules and using them were independent
19:24:23 <andromeda-galaxy> no. I think I must have misunderstood what you said
19:24:45 <c_wraith> but if the rules impact how further rules are parsed, you're in a world of trouble.
19:24:46 <andromeda-galaxy> when you said that the intermediate representation should be slices of input I thought you were talking about the representation of the grammar tree
19:24:57 <andromeda-galaxy> rules do not impact how further rules are parsed
19:29:40 <c_wraith> So let me back way up here.  Why doesn't something as simple as [(Input, [Input] -> Output)] work as your rule representation?
19:30:19 <andromeda-galaxy> what do the elements of that tuple represent?
19:31:43 <c_wraith> The first is the input to match, the second is the processing function to run over the list of extra attributes to produce a value of your output type.
19:32:00 <c_wraith> If this grammar isn't recursive, it seems like a flat representation should be perfectly fine.
19:32:32 <andromeda-galaxy> yes
19:32:44 <andromeda-galaxy> the issue is that the type of Output is not fixed
19:33:51 <c_wraith> How is it not fixed?  If you're parsing these functions out of some rules, there is obviously a sum type that represents every possible result that the rules have specified
19:34:10 <c_wraith> It may be recursive, but that's ok
19:35:09 <andromeda-galaxy> one could come up with some least upper bound type
19:35:17 <andromeda-galaxy> it would make the applicative interface impossible though
19:36:03 <c_wraith> Well, yes.  I'm pretty sure Applicative doesn't fit this use case.
19:36:44 <andromeda-galaxy> I'm reasonably sure that it does
19:38:35 <c_wraith> Anyway, that's what I meant about untyped representations.  There's no type information in Output that guarantees what it contains is useful.  That information is only available at runtime.
19:39:57 <halogenandtoast> c_wraith: Are you using an emacs client?
19:40:30 <c_wraith> halogenandtoast: what leads to that question? (no)
19:40:45 <halogenandtoast> The double spaces, it's the only client I've seen that does that and they drive me insane :p
19:41:02 <halogenandtoast> They shouldn't, but they do.
19:41:22 <halogenandtoast> It's one of the reasons I couldn't stay in the lisp channel
19:41:24 <c_wraith> I use double-spaces because I learned to type before "beautiful typography" ruined everything.
19:41:51 <c_wraith> Hint: double-spaces aren't wrong.  The insistence on making fonts look bad when the inputs are typed correctly is wrong.
19:42:02 <andromeda-galaxy> c_wraith: ah, I see. The applicative interface is impossible with the kind of thing that you were thinking of, right?
19:42:40 <andromeda-galaxy> re: typography: you're both wrong, you really want 1.2 to 1.5 spaces per sentence, and insisting on fixed-width typefaces for large amounts of text is what's wrong
19:43:02 <andromeda-galaxy> c_wraith: btw: http://lpaste.net/3138729466755284992
19:43:09 <halogenandtoast> c_wraith: Most major style guides claim they are wrong. I don't think one can claim they are right or wrong, they just make it really hard for me to read things.
19:43:31 <c_wraith> andromeda-galaxy: for typeography, that's trivial to get right with ligatures.  typographers decided to get it wrong instead.
19:43:36 <andromeda-galaxy> halogenandtoast: variable pitch ftw
19:43:47 <halogenandtoast> Especially when there are many sentences, it creates "rivers" which become distracting. Apparently, they are also distracting for dyslexics, but as far as I know I'm not dyslexic.
19:43:49 <c_wraith> andromeda-galaxy: And so we all suffer.
19:44:20 <c_wraith> andromeda-galaxy: and yeah..  Any interface using Applicative that you intend to reify is going to have to deal with existentials somewhere.
19:44:57 <andromeda-galaxy> c_wraith: re: typography: it isn't entirely the typographer's fault (although they certainly have part of the blame), but the applications/programmers that insiste on fixed-pitch fonts are also guilty since they make ligatures and/or fractional spacing in general either obscenely difficult or impossible
19:45:05 <halogenandtoast> I wonder if I can configure irssi to collpase two spaces into 1
19:45:42 <halogenandtoast> and if I can't find a client that can, I guess I could write my own client.
19:46:09 <halogenandtoast> Everyone wins in that scenario.
19:47:53 <c_wraith> andromeda-galaxy: I meant more that you *need* independent ways of signaling space and end-of-sentence.  Otherwise you just can't get spacing right, no matter what font is in use.  You shouldn't put more whitespace after "Mr." than you do after "mister".  Since there isn't an end-of-sentence key, we need some form of in-band signaling.  The "two-space" convention was agreed upon a long time ago.
19:48:10 <andromeda-galaxy> oh yeah, absolutely.  totally with you on that one
19:48:19 <andromeda-galaxy> I just wish that we were better at rendering end of sentence spaces
19:48:47 <halogenandtoast> I solved this problem by never using abbreviations.
19:49:07 <halogenandtoast> Abbreviations are for the weak.
19:49:46 <halogenandtoast> I think using a period for abbreviations was a mistake.
19:49:56 <halogenandtoast> Using a different character would have made this point moot.
19:50:38 <c_wraith> which point would it have made moot? ., ., or .?
19:51:07 <c_wraith> since we have at least 3 semantically different uses of that glyph in English writing. :)
19:52:08 <halogenandtoast> So have 3 different glyphs?
19:53:43 <halogenandtoast> Hmm apparently ignore -regex -pattern won't let me use lookahead or lookbehind...
19:55:18 <Cale> メイビーウイシュドジュストユーズカタカナフォルエングリシュ。
19:55:29 <halogenandtoast> so much katakana
19:56:07 <halogenandtoast> And no Cale, we should not
19:56:11 <Cale> hahaha
19:58:09 <Cale> halogenandtoast: Makes the spacing real easy though.
19:58:28 <JJKKLLL> Hi,  I have a question, I pasted it on http://lpaste.net/358240
19:59:13 <JJKKLLL> the func need a list as param, but (x:xs) is a element in list, is it?
19:59:22 <Cale> JJKKLLL: Try not to use head and tail -- you're already pattern matching, why not pattern match a little bit more?
19:59:35 <Cale> (x:xs) is the list whose first element is x and where the rest of the list is xs
19:59:54 <Cale> That pattern will only match a nonempty list, as such
20:00:01 <JJKKLLL> oh, I missunderstand (x:xs)?
20:00:12 <JJKKLLL> thanks so much!
20:00:24 <Cale> > let (x:xs) = [1,2,3,4,5] in (x, xs)
20:00:27 <lambdabot>  (1,[2,3,4,5])
20:00:54 <JJKKLLL> It's a list and I can caputrue the first elem? So elegent!
20:01:19 <Cale> Yep :)
20:02:47 <andromeda-galaxy> c_wraith: actually, is ExistentialQuantification even quite to make this type safe w/Applicative? afaict it leds you hide the types inside the applicative tree but not get them back out, so to speak. although the liberal application of unsafeCoerce does allow it to work
20:04:05 <JJKKLLL> Cale, by the way, could you please show me a more pattern way ? I'm new to haskell and wanna learn more to open up my thought
20:05:32 <JJKKLLL> I really thought to use a more pattern matching to resolve that problem but I give up, I don't know use what syntax to achive that.
20:07:10 <monochrom> JJKKLLL: You need two bases cases and one recursive case. The two base cases are [] and x:[]. The recursive case is x1:x2:xs.
20:08:07 <JJKKLLL> good start point, thanks monochorm!
20:09:40 <Camm> Hello everyone. I've been trying to run a project against GHC 8.2.1 using the nightly LTS from stackage. 
20:09:40 <Camm> $ stack build --resolver nightly
20:09:40 <Camm> and I get the following output:
20:09:40 <Camm> Selected resolver: nightly-2017-09-06 Unable to parse cabal file: FromString "This package requires at least Cabal version 2.0" Nothing 
20:09:40 <Camm> Then I install Cabal-2.0.0.2:
20:09:40 <Camm> $ stack install Cabal-2.0.0.2
20:09:41 <Camm> The installation is correct. However, if I run `stack build --resolver nightly` again it still failing.
20:09:46 <Camm> What am I doing wrong?
20:15:05 <geekosaur> Camm, stack itself is built against the Cabal library. you need to upgrade/reinstall stack, rebuilding against the new Cabal library
20:27:54 <boj> does anyone have any opinions on Earley for parsing a lot of small custom config files? would megaparsec be preferable? (i actually wrote my original in attoparsec before i understood the differences in regards to error handling vs. speed, etc)
20:29:34 <erisco> boj, if your config files have a nonambiguous grammar then I would use a more efficient parser
20:29:59 <erisco> boj, Parsec is probably fine
20:30:12 <c_wraith> Sometimes you can write things as an ambiguous grammar more nicely. :)
20:30:21 <MarcelineVQ> boj: are you making the config lang yourself?
20:30:42 <erisco> then try a parser generator which will rewrite your ambiguous grammars to be nonambiguous
20:30:45 <monochrom> If your config file format is looks-like-context-free-but-there-is-a-catch, clearly Earley will require hacks and megaparsec is natural. :)
20:31:03 <erisco> there are such tools which let you state precedence or associativity rules
20:31:41 <erisco> thus allowing the simplicity of stating an ambiguous grammar but not suffering the operation of it
20:31:56 <MarcelineVQ> boj: the reason I ask is because glguy made this recently and it may interest you https://github.com/glguy/config-schema
20:31:59 <monochrom> Actually if you have already written for attoparsec, then migrating to megaparsec (or parsec, or trifecta, or...) is more natural than migrating to Earley.
20:32:13 <EvanR> trifecta really
20:32:33 <boj> monochrom: yeah, that is what i was considering. was just curious if there was an advantage to using Earley at all (or other)
20:34:53 <boj> MarcelineVQ: thanks. it's an interactive telnet parser, so the templates to grab the data are custom to the device being talked to
20:36:24 <boj> sadly telecoms use network gear that dates back to the 90s
20:42:24 <boj> i think my edwardk:other library ratio is skewing towards edwardk these days
20:42:54 <EvanR> recommended daily value of edk libraries
20:43:09 <EvanR> 38%
20:44:01 <boj> EvanR: what is the advantage to trifecta? edk stamp? (beautiful error messages?)
20:44:29 <EvanR> i dont know
20:44:44 <EvanR> it seems to be nicely decomposed, so you could feed it in various ways
20:44:53 <EvanR> but i couldnt figure out how to use it
20:45:09 <EvanR> missing docs
20:45:09 <boj> the interface isn't similar to parsec?
20:45:14 <EvanR> not really
20:45:19 <boj> hmm, ok
20:45:30 <EvanR> at least i cant tell if it is
20:45:38 <boj> maybe my edk ratio stays constant today
20:53:48 <nshepperd> I think the interface to trifecta is just https://hackage.haskell.org/package/parsers
20:53:55 <nshepperd> it implements all the instances
20:55:43 <nshepperd> so it should be pretty similar to parsec
20:58:36 <boj> nshepperd: thanks for the clarification. still looking through the docs
21:00:24 <nshepperd> so I think the main things you will want are probably parseString from trifecta to actually run it, plus the various typeclasses from 'parsers' which seem to collectively implement the entire parsec api
21:02:33 <erisco> can I ask ghci to evaluate my type family application?
21:03:05 <glguy> :kind!
21:03:24 <erisco> oh, :k! doesn't work… thanks
21:10:22 <JJKKLLL> how to implement a pattern like xs:last3:last2:last1 ?
21:10:38 <JJKKLLL> AFAIK, only
21:10:50 <monochrom> Cannot.
21:10:55 <JJKKLLL> AFAIK, only x:xs work
21:11:35 <mud> JJKKLLL: You can't, with pattern matching anyway. Common tricks are to reverse the list (either permantently or just when you need to do that) or to use a different data structure, like Seq
21:11:55 <mud> If you're reversing big lists all the time though, that's a problem (it's very expensive)
21:12:18 <Cale> JJKKLLL: That pattern makes sense, but it doesn't mean what you want it to mean
21:12:38 <Cale> JJKKLLL: x:y:z:xs will be a list with at least 3 elements, whose first three elements are x, y, and z, and the rest is xs
21:12:53 <erisco> from x:xs a list is made, and so from x:xs shall a list be unmade
21:14:29 <monochrom> Haha that's catchy but overgeneralized.
21:15:29 <monochrom> If you use 50-4 to make 46, later you can't use a pattern x-y to recover that 50 and that 4.
21:16:17 <Axman6> > let (x:y:z:xs) = [1,2,3,4,5] in (x,y,z,xs)
21:16:20 <lambdabot>  (1,2,3,[4,5])
21:16:21 <u-ou-> there's more than one way to do it
21:18:19 <erisco> what if we were allowed to pattern match on injective applications?
21:19:45 <monochrom> Then the computer would be able to solve the injectivity problem.
21:20:06 <monochrom> The injectivity problem: Input: A function. Question: Is it injective?
21:20:38 <halogenandtoast> Cale: are you in Japan?
21:20:47 <Axman6> erisco: :kind! should do it - if you get the same thing back, you may be missing something a case for the type family
21:20:52 <halogenandtoast> And subsequent question, have we met already?
21:20:58 <erisco> what if we had a constructive definition for injective functions?
21:21:14 <erisco> I was thinking similarly about identity functions a while ago
21:21:58 <monochrom> Then nothing changes. The current definition is already constructive.
21:22:18 <andromeda-galaxy> erisco:how about https://coq.inria.fr/library/Coq.Logic.FinFun.html?
21:22:24 <erisco> but it is overgeneralised, it makes noninjective functions
21:22:35 <Cale> halogenandtoast: no, Canada
21:22:40 <erisco> I am saying, if you can construct it then it is injective
21:22:58 <monochrom> Data constructors are a way to guarantee injective functions.
21:23:35 <erisco> yes, and are the inspiration to think about functions more generally
21:23:41 <monochrom> OK, then you have a model of computation more restrictive than reversible computing.
21:24:19 <erisco> you do not need to be restricted to only injective functions in the language
21:24:26 <monochrom> Err, maybe less restrictive.
21:24:30 <andromeda-galaxy> monochrom: less restrictive!
21:25:45 <monochrom> Actually no one really actually used surjectivity in reversible computing, did they?
21:26:12 <monochrom> It seems like they have only ever used injectivity to talk about "can rewind".
21:27:03 <erisco> double x = x + x  wouldn't it be cool if you could pattern match on that?
21:31:10 <monochrom> Perhaps that's lens.
21:31:13 <halogenandtoast> Cale: Ah then we have probably never met.
21:31:18 <halogenandtoast> I haven't been to Canada in a long time.
21:35:29 <erisco> I have a  class X a b f  and I want it such that if f has the form  p -> m  that  a ~ p  and recursively so on  m  if  m  has form  _ -> _  and otherwise  m ~ b
21:36:01 <erisco> been fiddling with the possibility of this but am getting nowhere, but can't see whether it is impossible
21:36:34 <erisco> I should clarify… I want this to be inferable
21:38:43 <erisco> this means that if  x1 -> x2 -> ... xn -> r  is inferred for f that it is also inferred that x1 ~ a, x2 ~ a, ..., xn ~ a
21:39:43 <erisco> and if  r  is inferred as some type not of the form  _ -> _  then it is inferred  r ~ b
21:41:12 <andromeda-galaxy> can you simulate f :: x -> (forall a. Foo a -> Foo a) with only ExistentialTypes?
21:41:18 <erisco> that last part doesn't seem good
21:41:28 <andromeda-galaxy> it's not
21:42:29 <erisco> Haskell isn't quite smart enough about class contexts
21:42:43 <andromeda-galaxy> erisco: re: your problem
21:42:46 <erisco> it will infer something too general for what will actually work
21:42:57 <erisco> inevitably failing to satisfy the context later
21:43:16 <andromeda-galaxy> afaik the haskell typeclass dispatch is never going to use constraints on the instance head as material for type inference
21:43:42 <erisco> no it seems not, which is a shame
21:44:11 <erisco> but I am not talking about instance heads, or instances, I am just talking about a class
21:44:14 <andromeda-galaxy> typeclass resolution in haskell does a syntactic match of the instance head, constraints are then added to the context. If they can't be discharged, typechecking fails
21:44:20 <andromeda-galaxy> hmm
21:44:37 <andromeda-galaxy> maybe you can use functional dependencies or something?
21:44:48 <erisco> it will infer some things from the context
21:46:07 <erisco> class (a ~ b) => X a b where x :: (a, b)   it gets that  x :: (b, b)
21:46:24 <erisco> x :: X a a => (a, a)
21:46:47 <erisco> but with more sophisticated constraints it doesn't always understand
21:46:54 <erisco> leading to types too general to actually work
21:48:18 <erisco> I can have a constraint that is only satisfied if all the parameters of a function have the correct type
21:48:46 <erisco> but it does not understand this in inference
21:52:13 <erisco> http://lpaste.net/358242
21:53:58 <erisco> then look at the annotation http://lpaste.net/358242
21:55:36 <erisco> sorry slight boo-boo
21:56:24 <erisco> I fixed the boo-boo
21:57:00 <EvanR> boo-boo = 0
21:58:18 <erisco> then interestingly,  x (0 :: Int) "" :: t
21:59:02 <erisco> of course it can go forward and see from the inferred type for f that it does not satisfy the constraint
21:59:44 <erisco> interesting that it gives this term, which doesn't actually exist (because x does not exist), any type
22:00:44 <erisco> it can't go backwards and see that the only acceptable parameters are Ints
22:01:07 <erisco> i.e. we get  \y -> x y (0 :: Int) :: X a (Int -> t) => a -> t  rather than  \y -> x y (0 :: Int) :: X Int (Int -> t) => Int -> t
22:08:07 <andromeda-galaxy> erisco: probably not going to work, but what happens if you rewrite everything with functional dependencies instead of type families?
22:09:13 <erisco> what functional dependencies would I use?
22:09:43 <andromeda-galaxy> oh wait, that would require OverlappingInstances and would fail because of open world. nvm
22:09:53 <erisco> there are no instances
22:10:02 <andromeda-galaxy> rewrite P as a typeclass with fundeps
22:10:05 <andromeda-galaxy> was th eidea
22:10:38 <andromeda-galaxy> did you read https://wiki.haskell.org/GHC/SuperClass?
22:10:46 <erisco> I am not sure how I could do that
22:11:09 <andromeda-galaxy> well you'd need OverlappingInstances, and the result wouldn't help
22:12:23 <erisco> I expect a stronger inference algorithm for these kinds of contexts, i.e. ones involving non-injective type families, would help
22:12:29 <andromeda-galaxy> yeah
22:12:56 <andromeda-galaxy> actually I'm really surprised by that behavior
22:13:24 <erisco> I don't know the first thing about hacking on GHC though
22:13:49 <erisco> I know a possible solution based on tree grammars
22:14:29 <erisco> you can infer satisfying inputs as a tree grammar for some functions
22:14:53 <erisco> I can't recall what class of functions, but at least some ;)
22:15:31 <erisco> I was toying with that as a possible type system a couple years ago
22:18:08 <andromeda-galaxy> erisco: look at the annotation
22:18:16 <andromeda-galaxy> http://lpaste.net/358242#a358249
22:18:25 <andromeda-galaxy> oh , that sounds neet
22:18:40 <andromeda-galaxy> (last thing re: the tree grammar comments)
22:22:21 <erisco> ah right, I didn't think about returning a constraint
22:22:51 <erisco> what about returning a list of constraints
22:23:21 <erisco> that is constraining the first parameter but not the rest
22:23:34 <andromeda-galaxy> give me 1 second
22:24:40 <andromeda-galaxy> erisco: edited
22:24:48 <erisco> P p (a -> f) = (p ~ a, P p f)
22:24:55 <erisco> I decided to give that a whirl and waddaya know
22:25:00 <andromeda-galaxy> I just put that into lpaste ;)
22:25:23 <erisco> well doesn't this just change life
22:25:46 <erisco> this means contexts can be dynamic, neato burrito
22:25:48 <andromeda-galaxy> I was like 99% sure that ghc automagically works there and doesn't give you (Constraint, Constraint) but wanted to check
22:25:51 <andromeda-galaxy> and yeah!
22:26:48 <andromeda-galaxy> erisco: glad that was helpful
22:27:11 <erisco> yes, thank-you, this may be enough to make my variadic function builder work
22:27:17 <erisco> it worked but there was no inference
22:28:18 <andromeda-galaxy> ooh, that sounds cool, if inference works right
22:28:42 <erisco> it is more generally a fold over function application, so lets see if that can work now
22:31:58 <erisco> a weakness is I don't think I can have it work when you're accumulating a function
22:36:56 <erisco> the inference is working a treat :)
22:41:39 <erisco> haha, wow, great :D
22:47:49 <erisco> that was so easy I am going to think about the possibility of a right-associative fold
23:13:18 <norc_> Good morning. Quick question, what is the purpose of that elaborate `c = where..` form in this gist? https://gist.github.com/anonymous/acd12f4ba22c7f12979819d0d126e409
23:13:54 <norc_> Seems much simpler to just do https://gist.github.com/anonymous/005160199d8cc48d3fe4c0cf980546c6
23:14:19 <jle`> norc_: usually ti's to take advantage of sharing
23:14:23 <c_wraith> norc_: tying the knot creates a circular data structure
23:14:42 <c_wraith> norc_: your version is going to use more memory the further it's explored
23:15:08 <jle`> remember that in Haskell, function calls aren't automatically memoized or cached
23:15:22 <jle`> so every time you call 'step v', that's a brand new invocation and allocation of 'step' for 'v'
23:17:28 <norc_> c_wraith, jle`: Ahh, that makes sense. Thank you for the quick response. 
23:17:40 <norc_> Time to study this more in depth.
23:17:50 <c_wraith> norc_: the definition of cycle is a good one
23:17:51 <jle`> when i started out with haskell i had this assumption that calling the same function with the same input would require no recomputation
23:17:53 <c_wraith> @src cycle
23:17:54 <lambdabot> cycle [] = undefined
23:17:54 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
23:18:33 <jle`> i'm not sure where this assumption came from...maybe it's the "idea" that pure functions are functions that return the same thing when called with the same arguments, so why not just save them and look them up again?
23:18:44 <jle`> but it turns out that a lot of people also come in with this assumption
23:19:06 <norc_> jle`: I suppose in a way it's an obvious optimization potential
23:19:36 <jle`> indeed
23:19:53 <jle`> but after giving it some thought, i realized that it was sort of impractical
23:19:58 <norc_> Be right back, gotta catch the train. Hope there's wifi on there.
23:20:07 <jle`> especially for inputs like Double where 'same input' isn't even meaningful
23:21:25 <jle`> also this would potentially lead to huge space explosions when you call a function with many different inputs and ghc naively caches all of them
23:22:19 <jle`> that's why i think it's nice that 'memoization' behavior is possible in Haskell, because we can take advantage of purity.  but it should be done explicitly, and indeed there are many libraries that implement the ability to explicitly cache/memoize your functions
23:24:50 <Saler78> ciao
23:24:53 <Saler78> list!
23:25:08 <norc__> jle`: Mmm, it is a recurrent theme in other compilers though.
23:26:42 <norc__> Though I suppose realistically this sort of memoization might only be possible with JIT compilation
23:27:24 <davean> norc__: I mean, those don't really do memoization, they do local compile time computation really
23:27:32 <davean> Thats rather fundimentally different?
23:30:51 <norc__> davean: Most can trivially memoize for hot cases by just constant folding the function but de-optimizing when the arguments change
23:32:50 <norc__> SpiderMonkey, v8, Java HotSpot, they all do it.
23:35:50 <davean> norc__: and thats basicly what I said
23:35:58 <davean> Think about how that gets implimented
23:36:35 <norc__> davean: Must have misunderstood. Not sure whether its really that different.
23:37:11 <norc__> I mean with JIT this kind of optimization is steered from the outside, whereas here it would have to be done by the runtime that reduces expressions
23:37:23 <norc__> Doesn't seem too different
23:38:43 <jle`> ah yeah expression reduction is different than memoization
23:38:56 <jle`> but i can see how this relates to the original issue
