00:24:23 <wob> cocreature, so that worked. thanks! can you tell me what it is that doesn't work with the bindist that libtinfo imposed? is it one that enables PIE for Arch that doesn't support it, or is it the other way around?
00:40:31 <ertes-w> ello
01:06:01 <kurolox> Hello! Quick question, it's there any way to support unicode characters in haskell?
01:06:19 <kurolox> Doing something like main = putStrLn "À" will throw an error.
01:07:53 <liste> kurolox: what encoding is your source file?
01:08:03 <liste> that should work if everything is set up correctly
01:09:52 <kurolox> it's utf-8
01:11:09 <geekosaur> works fine here
01:11:58 <merijn> oh, oh, oh! Is it time for the "did someone screw up their locale"-game again? :)
01:12:11 <merijn> kurolox: lpaste the output of "locale"
01:17:06 * hackagebot data-category 0.7 – Category theory – https://hackage.haskell.org/package/data-category
01:17:06 * hackagebot arithmoi 0.6.0.0 – Efficient basic number-theoretic functions. – https://hackage.haskell.org/package/arithmoi
01:19:23 <Athas> Is there a way to get Stack to only build/link one of the executables listed in the .cabal file?
01:20:28 <kurolox> sorry, I wasn't here
01:20:44 <kurolox> locale seems fine to me though.
01:20:49 <kurolox> https://hastebin.com/qumizizipe.rb
01:23:06 <MarcelineVQ> Athas: userguide https://docs.haskellstack.org/en/stable/GUIDE/#targets-locals-and-extra-deps
01:23:12 <merijn> kurolox: Should work fine then, because copy/pasting that into my ghci with the same locale "just works"
01:25:51 <Athas> MarcelineVQ: looks like it has been buggy for years, and only recently got fixed in Git.
01:30:22 <maerwald> it seems hackage encourages to ship broken tarballs 
01:33:26 <Athas> maerwald: how so?
01:35:37 <maerwald> the tarballs don't have up2date metadata
01:36:21 <Athas> What metadata?
01:36:37 <maerwald> dependencies
01:37:35 <MarcelineVQ> maerwald: did you make/find a ticket about it?
01:37:42 <maerwald> what ticket?
01:38:10 <ongy> it's a feature. you can update dependencies after uploading something.
01:38:18 <maerwald> it's a misfeature
01:38:27 <maerwald> it causes everyone relying on tarballs to reverse-fix them
01:38:44 <merijn> You think everything about Haskell is a misfeature anyway, so I'm not quite sure why you even bother with Haskell...
01:38:46 <maerwald> e.g.: all distros
01:38:48 <MarcelineVQ> I'm not sure I understand the question, what ticket service? https://github.com/haskell/hackage-server/issues
01:39:01 <maerwald> MarcelineVQ: see https://github.com/haskell-infra/hackage-trustees/blob/master/cookbook.md#best-practice-for-managing-meta-data
01:39:24 <maerwald> and it requires distros to downstream patch all of these metadata updates
01:39:34 <maerwald> because they are not contained within the tarballs
01:39:54 <maerwald> merijn: don't misrepresent my opinion please
01:40:04 <ongy> are the tarballs signed? if not, add a patch that patches the tarball
01:40:32 <maerwald> ongy: maerwald: and it requires distros to downstream patch all of these metadata updates
01:41:36 <MarcelineVQ> good link, that's an even more apt place to make a ticket expressing your issue, iirc there's also a channel for infrastructure here
01:41:46 <ongy> maerwald: you complained about outdated tarballs, then fix them. or actually state your problem properly if that's not what you are complaining about
01:41:48 <Athas> Distros include hackage tarballs?
01:41:57 <Athas> I didn't know any distros used source tarballs for Haskell.
01:42:00 <maerwald> ongy: I think you didn't get what the problem was, see the link
01:42:06 <maerwald> Athas: ofc
01:42:10 <Athas> How should a tarball contain metadata?  Is it supposed to?
01:42:22 <maerwald> yes, the cabal file??
01:42:37 <Athas> Oh, Hackage tarballs don't contain the cabal file?
01:42:41 <maerwald> sure they do
01:42:43 <maerwald> but outdated ones
01:43:10 <Athas> Surely it's the author of the tarball that gets to decide what the tarball contains?
01:43:25 <Athas> I would be disturbed if Hackage re-packaged my tarballs.
01:43:33 <maerwald> no no no
01:43:48 <maerwald> you are supposed to do a version bump if you change significant metadata, that's what every rolling release distro does
01:43:49 <ongy> Athas: you can modify the metadata hackage uses live, without changing the tarball behind it
01:43:49 <merijn> Athas: He's complaining about the fact that Hackage lets you update dependency constraints for released versions
01:43:58 <maerwald> and the only correct way to propagate that metadata to the user
01:44:08 <maerwald> everything else is assumptions (how do people use hackage, tarballs and so on)
01:44:12 <merijn> Athas: If you fucked up a dependency bound which doesn't build you can update the bound without releasing a new version
01:44:31 <Athas> merijn, ongy: yes, I know.  I'm not sure how I feel about that, but I would definitely feel bad about it if the mechanism included synthesising new tarballs.
01:44:47 <maerwald> I didn't suggest that
01:44:48 <Athas> I think I'm OK with Hackage being able to supply supplemental information.
01:45:10 <Athas> Although it still feels a little weird.
01:45:18 <Athas> Do other languages do this, too?
01:45:30 <maerwald> cargo not, afaik
01:45:33 <Athas> I know we didn't use to do it in the Common Lisp community...
01:51:44 <phadej> note: releasing a new version doesn't solve one as the old and broken release is still on hackage. That's different from some distributions, where old versions vanish.
01:53:50 <Athas> I'm mostly curious why Haskell needs to do this differently than others.  Is the reason that Haskell is unusual in being a compiled language that depends heavily on inlining (i.e. no stable ABI for compiled libraries)?
01:54:03 <maerwald> phadej: the package gets updated to the new version, it doesn't matter whether an old one still exists, unless it's slotted
01:54:36 <merijn> Athas: Cabal is a lot more principled about handling dependency bounds
01:54:37 <maerwald> Athas: probably trying to be smart again and optimizing disk space usage of hackage
01:54:51 <phadej> maerwald: it does, because (and that's different from others) Hackage eco-system relies on a solver.
01:54:54 <Athas> merijn: why?
01:55:06 <phadej> if there is too loose bound, that "infectious version" will be picked
01:55:12 <maerwald> phadej: I'm not talking about cabal
01:55:32 <phadej> maerwald: Hackage is made for Cabal, you cannot speak about them in separation
01:55:42 <maerwald> lol
01:55:46 <phadej> at least reasonably
01:55:51 <maerwald> whatever
01:55:55 <Athas> maerwald: disk space usage seems like a dubious reason.  Hackage stores source code; it should be relatively tiny.
01:56:08 <black0range> Hey! I'm trying to solve a little school challange where Given a lexicon and a list of misspelled words it should for each mispelled word output the mispelled word and which words in the lexicon is closest to it. I've allready solved this in java with the same logic and it passed the time limit however the same logic in haskell is too slow. Can i (Without chaning the logic) make this piece of code more efficient? (I must use mutable
01:56:08 <black0range> vectors as there's a memory limit of 1gb). Acording to the profiler most of the time is spent inside  "evaluateCell". http://lpaste.net/358540
01:56:15 <merijn> Athas: Well, npm for example takes more of a "we'll just discover issues with new versions at runtime" approach :p
01:56:18 <cocreature> how do other languages handle things if they don’t use a solver? afaik they don’t all have something curated like stackage either or do they?
01:56:31 <maerwald> cocreature: his statement was wrong
01:56:47 <maerwald> gentoo, exherbo and others rely on a solver and they don't pick old versions, why would they
01:56:51 <Athas> merijn: but do they have more issues in practise than we do/did with Cabal?
01:56:53 <phadej> cocreature: e.g. maven has a solver, but not as smart
01:57:12 <maerwald> this just looks like a cabal solver bug, nothing more
01:57:43 <Athas> From my own anecdata, pre-stack Haskell had by far the worst dependency hell of any language I've used.
01:57:54 <Athas> (Should probably say pre-sandbox, actually.)
01:58:18 <cocreature> phadej: which part of the smartness results in us needing to care more about updating bounds than other languages?
01:58:21 <maerwald> Athas: yeah, they didn't talk to people who have done rolling release distros for a decade or two. That might have avoided some common mistakes
01:59:03 <Athas> black0range: how much slower is this than the Java implementation?
01:59:34 <cocreature> afaik npm has package-local deps so that explains why the situation is different there since you don’t need to come up with a consistent snapshot
01:59:59 <black0range> Athas: The java implementation takes 1.31 on avrage for the test (500000 word lexicon and 50 mispelled words) This takes more then 2 seconds which is the time limit
02:00:19 <phadej> cocreature: yes, that's the differene in npm world
02:00:33 <cocreature> phadej: but that’s no the case for java, rust and other languages afaik
02:00:35 <Athas> black0range: okay.  I can't see an immediate smoking gun in your code, so it's possible that Haskell is just slower than Java here.
02:00:41 <cocreature> so something needs to be different in Haskell-land
02:00:44 <Athas> (This does not mean you can't optimise it further with some low-level hacking.)
02:00:44 <phadej> cocreature: it's the case for rust in fact
02:00:48 <cocreature> oh ok
02:01:01 <cocreature> so they don’t have reexports?
02:01:14 <cocreature> otherwise that model seems to break down quickly
02:01:32 <phadej> https://blog.rust-lang.org/2016/05/05/cargo-pillars.html
02:01:43 <black0range> Athas: Do you have any pointers on what kind of low level hacking i could do?
02:01:56 <maerwald> cocreature: nah, it still doesn't explain why cabal would pick the lower version of two if both are a solution to the depgraph
02:01:59 <black0range> Athas: More then one thread is not permitted btw
02:02:04 <maerwald> it's just a bug
02:02:12 <Athas> black0range: no, sorry.  Your use of unboxed vectors is usually as far as I bother going with Haskell for performance reasons before switching to another language.
02:02:28 <cocreature> maerwald: if I have an explicit upper bound to forbid using a newer version, then it has to pick a lower version
02:02:37 <phadej> maerwald: I didn't say that. I should been more precise: "if the only solution is to pick old one, cabal will pick it"
02:02:37 <maerwald> that's something different
02:02:50 <maerwald> phadej: that's expected behavior
02:02:56 <Athas> black0range: maybe look into whether frequent random access into Text is slow.
02:03:04 <maerwald> and there is nothing wrong with it
02:03:20 <maerwald> rolling releasing doesn't require old versions to be dropped, that's not how it works
02:03:26 <phadej> maerwald: and if situation is that packagee foo doesn't build with base-4.10 but had base <5 bound, you cannot fix it with new version
02:03:30 <maerwald> but I'm tired to explain it every time
02:03:57 <phadej> maerwald: because if user of GHC-8.2 will ask for that package, the old one will be picked
02:04:25 <maerwald> reverse deps need to be fixed as well
02:04:38 <maerwald> just look at how rolling release distros do it
02:04:46 <phadej> rolling release: stackage nightly
02:05:06 <maerwald> phadej: they provide non-broken tarballs?
02:05:20 <phadej> maerwald: what you mean by non-broken tarballs?
02:05:27 <maerwald> those with up2date metadata
02:05:47 <phadej> they provide consistent snapshot "these package will build together"
02:05:52 <ertes-w> black0range, Athas: indexing Text is O(n)
02:05:53 <maerwald> that's not what I asked
02:06:27 <phadej> but in Hackage ecosystem you cannot require "update revdeps" as Hackage is distributed system
02:06:42 <maerwald> so are rolling release distros
02:07:00 <phadej> which are?
02:07:04 <maerwald> ?
02:07:08 <phadej> arch?
02:07:10 <maerwald> no
02:07:17 <ertes-w> black0range: consider using Vector Char instead of Text, if you need a lot of random indexing, slicing, etc…  basically any operation that requires an index into a Text (e.g. splitAt, drop) is O(n)
02:07:35 <black0range> ertes-w: Ohh will try that! 
02:07:48 <phadej> maerwald: what distros then?
02:08:48 <maerwald> gentoo and exherbo for instance
02:08:59 <maerwald> they are distributed, source-based and rolling release
02:11:34 <phadej> maerwald: I can see from https://gitweb.gentoo.org/repo/gentoo.git/tree/app-emacs/ghc-mod/ghc-mod-5.7.0.0.ebuild
02:11:39 <phadej> that there are no bounds, but exact versions
02:12:05 <maerwald> that's incorrect
02:12:10 <phadej> or do I read it wrong
02:12:12 <cocreature> >= and < looks very much like bounds to me
02:12:14 <maerwald> yes
02:13:32 <maerwald> and from here https://git.io/v5FhH you can see that cabal definitions have to be reverse-sedded/patched all the time 
02:13:36 <ertes-w> black0range: caveat: if you're dealing with latin words, Vector will be twice as expensive in terms of memory
02:14:02 <phadej> maerwald: and revisions are same kind of patches, so how gentoo is better then hackage?
02:14:09 <maerwald> phadej: what?
02:14:40 <phadej> maerwald: hackage revisions are patches to metadata so builds are successful?
02:14:41 <ertes-w> black0range: you can restrict yourself to a byte encoding like latin-1 and go with ByteString or even ShortByteString
02:15:03 <maerwald> phadej: if you download the tarball and use that then no
02:15:31 <ertes-w> black0range: that's probably where most of the speed of java comes from
02:15:39 <black0range> ertes-w: It needs to handle  utf8
02:16:12 <phadej> maerwald: but *you should* download updated metadata too. the tarball can be signed by the author (in theory now, and hopefully in future in practice too)
02:16:20 <maerwald> phadej: how would you do that?
02:16:27 <maerwald> and how would you know when there is new metadata?
02:16:31 <ertes-w> black0range: Text uncons is O(1), so if you can implement the distance algorithm only using that, then it should be much faster
02:16:36 <maerwald> because the version of the package indicates neither
02:16:41 <maerwald> you're not understanding the exact problem
02:16:59 <maerwald> it's a broken release model
02:16:59 <phadej> maerwald: https://github.com/haskell/cabal/blob/master/cabal-install/bootstrap.sh#L326-L334
02:17:17 <maerwald> jesus christ
02:17:38 <maerwald> now you are pulling an unversioned file
02:17:46 <maerwald> do you know the problems that causes?
02:18:12 <phadej> maerwald: in gentoo the metadata isn't tied to the version of package, it's version of portage isn't it?
02:18:25 <maerwald> I don't want to explain a whole distro now
02:18:28 <phadej> maerwald: and in Hackage the version of metadata is in index.tar.gz
02:18:41 <phadej> maerwald: you should, write a blog post and post it to /r/haskell
02:19:02 <maerwald> the metadata we are talking about are dependencies
02:19:03 <ertes-w> black0range: if not, there is also a middle ground: unicode can be encoded in three bytes per character, so if you create something like a Char24 type with a compact Unbox instance, you can save some memory, which will in turn improve the speed
02:19:08 <maerwald> and they are ALWAYS part of the package version
02:20:02 <black0range> ertes-w: That is a good idea
02:20:38 <ertes-w> black0range: however, first check if that's really necessary, because it's a lot of work and a lot of boilerplaty code
02:21:16 <phadej> maerwald: yes, gentoo adds own revision to the upstream version, so does hackage (the revision number).
02:21:25 <maerwald> no
02:21:35 <black0range> ertes-w: Will try the vector char thing first! :)
02:21:38 <maerwald> the metadata is not spread across different logical instances
02:21:45 <maerwald> the metadata is always where the package is
02:21:58 <maerwald> in gentoo that's the ebuild file, on hackage that is supposed to be the _tarball_
02:22:15 <phadej> maerwald: no to you. In Hackage it's index.tar.gz
02:22:21 <ertes-w> black0range: if yes, just do this:  newtype Char24 = Char24 Char  -- only the Unbox instance really needs to be special
02:22:56 <phadej> maerwald: there's everything you need to perform dependency solving.
02:22:57 <maerwald> phadej: and that's just utter crap, because now you cannot a) rely on the consistency of a tarball b) have to reverse fix it c) have to check whether there is new metadata d) have to handle the cases that that metadata is _unversiond_
02:22:59 <maerwald> and more
02:23:48 <maerwald> the cabal file is updated in-place, that breaks Manifests, repeatable installs and whatnot
02:24:17 <maerwald> so they cannot be reasonably used
02:24:26 <maerwald> instead distros have to downstream patch the tarballs
02:25:17 <phadej> maerwald: a) tarball is consistent, it's what author uploaded. b) in gentoo you have to use ebuild file, I don't see how it's different from applying different .cabal file c) not really, you use what you have in your index.tar.gz d) index.tar is versioned. (and secure)
02:25:44 <phadej> if you want hard-repeatable install, you can choose to not apply revisions
02:26:15 <maerwald> a) no it isn't, it refers to an old state, b) that's a LOT of maintenance work c) yes you have d) wat?
02:26:17 <phadej> you'll just get frustrating amount of compilation errors, especially for older GHC
02:26:43 <maerwald> do you even know what you are proposing?
02:26:47 <saurabhn_> dealing with a hard-to-describe design problem in FP world. The most succinctly I can describe it is -- how do I implement "cached columns" of ActiveRecord in any pure FP language?
02:27:26 <merijn> saurabhn_: I have no clue what ActiveRecord or "cached columns" are?
02:27:57 <maerwald> if I use index.tar consistently, I have to mimic the new metadata to _real_ ebuild versions, that's just about as much work as manually patching it
02:28:29 <phadej> maerwald: there is always an old state. the Hackage is trully rolling, as you don't need to roll to the HEAD all the time. b) that's downstream problem, gentoo could pull new revisions automatically if they build proper tool (maybe they do?)
02:28:37 <maerwald> it isn't truly rolling
02:28:47 <phadej> maerwald: and yes, index.tar is versioned and signed
02:28:51 <maerwald> and you don't understand all the implications of what you are proposing
02:28:55 <maerwald> and I am too tired to explain it all
02:29:07 <phadej> maerwald: explain it once well in a blog post
02:29:24 <maerwald> wasted enough time on this nonsense already
02:30:03 <boj> saurabhn_: i know what AR is, but not what you mean by "cached column". what kind of behavior do you desire?
02:31:03 * hackagebot consumers 2.1.0.0 – Concurrent PostgreSQL data consumers – https://hackage.haskell.org/package/consumers
02:31:40 <saurabhn_> merijn: row in table A (say, order) is associated with multiple rows in table B (say payments). Whenever something in "payments" changes, the order.total_payment column should get recomputed. 
02:31:50 <saurabhn_> boj: ^^
02:34:32 <saurabhn_> one way of doing this is via DB triggers, but that has two downsides: (a) there may be some computations which are needlessly hard to express in plpsql, and (b) if an 'order' (table A) has already been fetched in the memory, you end-up working with an incorrect representation of the 'order' on the haskell side.
02:35:37 <boj> your crazy ruby AR has to do something to make that work anyways. do you know the mechanics behind it?
02:35:52 <tdammers> AR is a dead end IMO
02:36:10 <vktec> I'm struggling with specifying type constraints in a data declaration. I've got this, which doesn't compile because the type variables aren't in scope. I'd like to a) make it compile and b) ensure that all of a, b, c and d are members of the Num typeclass. https://ptpb.pw/vitP/haskell
02:37:16 <saurabhn_> so, don't hate on AR. It has a solution which works 85-90% of the time if your code/db-structure is well within the design boundaries of the framework. What is the idiomatic solution on the FP side?
02:37:35 <merijn> vktec: And 'a', 'b' and 'c' should be able to be different types?
02:37:42 <vktec> Yes, they should
02:38:03 <boj> saurabhn_: that's kind of the problem. you are taking AR, which is full of idioms and a lot of code to drive it, and trying to find a "simple" way to duplicate it with FP. i don't think it's that easy
02:38:04 <merijn> vktec: Then for a) you can't get out of listing them in the type
02:38:24 <merijn> vktec: As for b) don't, just constraint the functions working with Expr
02:38:53 <saurabhn_> boj: don't worry about the amount of code. what is a possible idiomatic solution in the FP world, without introducting mutable state?
02:39:15 <vktec> merijn: Okay, thanks for the help
02:39:24 <lavalike> vktec: have you considered this approach https://en.wikibooks.org/wiki/Haskell/GADT#GADTs (using class constraints on the constructors)
02:39:51 <merijn> lavalike: He shouldn't do that either, because that's using ExistentialQuantification which almost certainly is not what he actually needs
02:40:14 <lavalike> okay (:
02:40:53 <ertes-w> saurabhn_: so technically total_payment is redundant information?  how about using a view instead of a table then?
02:41:43 <ertes-w> saurabhn_: i gather that you're using postgres?  it will cache total_payment for you, and i believe there is even a way to allocate actual storage that will be updated automatically for it
02:42:00 <saurabhn_> ertes-w: materialised or non-materialised? also, this is not an FP solution, but pushing the pushing everything down to the DB.
02:42:32 <ertes-w> saurabhn_: this *is* a DB problem…  you have redundant data in your DB
02:43:12 <saurabhn_> ertes-w: and my hunch is that the problem will show up elsewhere now. What will get loaded into memory when you're loading the order row, i,e, will it be with or without the total_payment column?
02:44:11 <boj> saurabhn_: are you looking at triggering a change of *in memory* data that hasn't been flushed to the db based on it's relationship to other active data being manipulated?
02:44:37 <saurabhn_> ertes-w: sure. if you're being 100% theoretical, then, yes. It is a DB problem. But not having completely normalised tables, is a fact of life for gaining performance out of them.
02:45:11 <saurabhn_> boj: you've probably described what activerecord does out of the box.
02:45:14 <ertes-w> saurabhn_: with my approach 'order' is no longer a table, but a view…  postgres has lots of features for views, and i'm sure you can tell it to use disk storage, so the view functions like an auto-updated table
02:45:53 <ertes-w> saurabhn_: i believe with postgres there is rarely a need to use redundancy for performance…  this hacky way of doing things is largely a mysql disease
02:46:00 <saurabhn_> ertes-w: which would put the problem back in the same bucket as using triggers. What happens to the 'order' value/record in haskell, when in the same thread of execution, it has been changed behind its back!
02:46:12 <saurabhn_> ertes-w: yes, we're using PG.
02:46:23 <black0range> ertes-w: Doesn't work with Vectors either :( 
02:46:26 <ertes-w> saurabhn_: that's why you use transactions and do *not* cache in your application
02:46:36 <boj> yup
02:46:43 <black0range> ertes-w: But it doesn't complain about the space
02:46:53 <saurabhn_> ertes-w: boj: same problem with transactions.
02:47:42 <saurabhn_> you've loaded order first, then loaded a bunch of payments, then you change `payment.amount` for one row, which trigger a change to order.total_payment at the DB level, in the same DB txn. However, a stale version of 'order' is sitting around in Haskell.
02:47:42 <ertes-w> saurabhn_: caching in the application is not the proper way to use databases in general…  what if another application updates concurrently?
02:48:21 <boj> saurabhn_: you said to ignore all the fancy AR code, but if i recall (my knowledge is 10 years out of date), it uses a lot of dirty flags to mark data that needs to be refetched in case of cases like you describe. at the end of the day you still have to go to the db to get a consistent world view of your data
02:48:25 <ertes-w> that's what views are there for…  they are not just a convenience mechanism to write shorter queries…  they are a performance and correctness mechanism
02:49:04 <saurabhn_> boj: the way rails makes this easier, is that you can say `payment.order.update_total_payment` and the re-computation is triggered from the Rails side of things, not the DB.
02:49:29 <saurabhn_> if you squint, it's some sort of weirt FRP thing happening there.
02:49:37 <saurabhn_> not FRP, just RP.
02:49:54 <ertes-w> saurabhn_: so basically the rails way is "if you use a different language/framework, you're on your own…  we just do it our way, because we're fucking ruby"?
02:50:31 <saurabhn_> ertes-w: the rails way is, here's a solution that works. FP way is....?
02:50:55 <ertes-w> saurabhn_: the FP way is irrelevant…  there is no proper FP way, much like there is no proper rails way
02:51:01 <ertes-w> the rails solution is just wrong
02:51:16 <ertes-w> again: this is a DB problem
02:51:30 <ertes-w> you're not doing yourself a favour by making it an application problem
02:51:44 <boj> making a lot of work for yourself for sure
02:52:20 <boj> you really need to drop your "rails does it this way..." mentality like a bad habit
02:52:23 <saurabhn_> ertes-w: not going anywhere. stop hating rails, and think about how you'd solve thi problem. Even if this was pushed down to the DB layer. The problem of having invalid data in the same thread of execution, in the same DB txn, still exists.
02:52:28 <boj> you'll see the FP solutions faster i imagine
02:53:20 <boj> (or in this case, the fact that it's not even a language problem)
02:53:34 <ertes-w> saurabhn_: i told you how i would solve it
02:54:00 <ertes-w> saurabhn_: if you think the problem still exists with my solution, then i didn't understand the problem
02:54:02 <saurabhn_> boj: I'm using a known frame of reference. And I'm open to dropping idioms from that world. But I don't have access to mapping idioms on the FP world.  If you feel just saying Rails in a statement makes it invalid, then I'm sorry, I'll have to disagree. 
02:54:13 <boj> saurabhn_: if you have bad data in the same thread of execution then something is seriously wrong with your model
02:54:18 <merijn> saurabhn_: How can you have invalid data within a thread while using db transactions?
02:55:04 <ertes-w> saurabhn_: with my solution invalid data simply doesn't exist (save for solar flares)
02:56:08 <saurabhn_> here's how ==> load order ID 10 (you now have a copy in Haskell) ==> load payments ==> change a payment ==> trigger an update to the order ID 10 only on the DB side ==> isn't Order ID 10 in Haskell in an incorrect state now?
02:56:22 <boj> saurabhn_: my point wasn't a stab any your language/framework you've used in the past, it's to help you consider that maybe now that you are a solid year into haskell it's time to drop it and get your head into a pure FP game. you are just slowing yourself down at this point - not eveything has a 1:1 mapping
02:56:47 <ertes-w> saurabhn_: yes, it is, but why did you load the order in the first place?  is this ORM?
02:56:47 <merijn> saurabhn_: So requery the order instead of storing it in your application
02:56:53 <saurabhn_> boj: I know that not everything is a 1:1 mapping. How else do I frame my question when I don't know what the eff-ing thing on the other side is called?
02:57:10 <ertes-w> saurabhn_: and if you really have to load it, then either load it *after* the update, or reload it
02:57:47 <boj> saurabhn_: fair enough. sometimes it's hard to answer you because we don't have the same frame of reference
02:58:42 <ertes-w> saurabhn_: you're in a transaction, so if you do an update, you have a guarantee of determinism…  if you don't want to requery (which may be reasonable sometimes), recompute your data
02:59:31 <saurabhn_> ertes-w: this a simplified view of the whole process. In my real application 'order' has some column which needs to be read before the payment can be processed. 
03:00:11 <saurabhn_> and re-reading rows which may be changed places a **lot** of mental overhead on the programmer. This is just introducing a new type of bugs in the system. Oh... I forgot to call reload again.
03:00:42 <boj> that is what i meant by all the AR code doing a lot of work (that you asked me to ignore), sigh
03:00:53 <wob> saurabhn_, I'm a bit unsure what you're working with. either 'do stuff in a transaction' is the answer, but that doesn't make your problem different in an impure web-framework setting, or you're wondering if there's a database library in Haskell that lets you both update the state of the database and the application's state at the same time?
03:01:38 <saurabhn_> wob: I know the latter part doesn't really exist (a mature enough DB library, save BEAM, which is probably going to get there the fastest).
03:01:50 <saurabhn_> wob: I'm wondering how FP, in general, deals with this problem.
03:02:13 <saurabhn_> when you know that you're changing external state, which is going to invalidate, some or part of your internal state, and you can't really mutate your internal state.
03:02:25 <saurabhn_> AR/Rails has it easy. It can simply mutate the object to match the state in the DB.
03:03:31 <wob> saurabhn_, you don't have to mutate your internal state as long as you can update it.
03:04:16 <saurabhn_> I was wondering if the savePayment function should be `savePayment :: PaymentId -> blah -> (Payment, Order)` -- so that the caller knows that the `Order` has been changed, and he/she should not use the older version in memory, if any.
03:05:01 <boj> saurabhn_: ok, so 1) you've acknowledged there are no haskell libraries that seem to do this, 2) you are asking what FP people would do - it sounds like they would push the work to the DB (which we all seem to agree on), 3) you seem to be after an "FP-only" way which doesn't invoke building a library?
03:05:42 <saurabhn_> actually we're half-way into (3)
03:06:10 <boj> we are?
03:06:54 <wob> saurabhn_, I don't know what web framework you're thinking of, but I seem to recall that both Snap and Servant have a state-part of their monad that can be updated.
03:06:54 <sphinxo> How can apply a function to the left ( if it's left ) and get an either back
03:07:30 <boj> :t either
03:07:31 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
03:07:38 <saurabhn_> boj: not you. but people in my team :)
03:07:40 <boj> sphinxo: that may be what you want
03:07:49 <sphinxo> boj: not quite, but thanks
03:08:13 <sphinxo> I want (a -> c) -> Either a b -> Either c b
03:08:14 <saurabhn_> sphinxo: look at the _Left lens.
03:08:43 <saurabhn_> something to the tune of `over _Left (\leftVal -> newLeftVal) eitherVal`
03:09:29 <boj> oh, get an either back
03:09:48 <saurabhn_> wob: is there any other technique apart from mutable state to get this done... I'm wondering if we have to essentially build an in-memory query cache to get this kind of stuff working.
03:10:27 <AndreasPK> sphinxo: (flip either id)
03:10:46 <AndreasPK> Oh right the getting either back part
03:12:36 <wob> saurabhn_, I don't know. I try to not build my own web-frameworks. (-:
03:13:17 <AndreasPK> there is bimap
03:13:53 <saurabhn_> sphinxo: did you try lenses?
03:13:57 <wob> saurabhn_, I'm sure there are performance complications in using a regular state monad with multiple threaded event handlers.
03:14:07 <AndreasPK>  :t flip bimap id
03:14:14 <saurabhn_> :t (over _Left)
03:14:16 <lambdabot> (a -> b) -> Either a c -> Either b c
03:14:25 <AndreasPK> :t flip bimap id
03:14:27 <lambdabot> Bifunctor p => (a -> b) -> p a d -> p b d
03:14:37 <AndreasPK> And either has a bifunctor instance
03:15:08 <wob> saurabhn_, but alternatively, one could refrain from distributing cache-sensitive information from the database across multiple event handlers in the web application...
03:15:21 <sphinxo> AndreasPK: yeah I can use first 
03:15:25 <wob> saurabhn_, I don't really know what's what.
03:15:28 <sphinxo> ( from bifunctor )
03:15:50 <sphinxo> saurabhn_: Lenses are too big a dependency to bring into this project
03:15:54 <sphinxo> atmo
03:16:02 <AndreasPK> Didn't even know Bifunctor that was part of base
03:16:40 <cocreature> AndreasPK: it’s in base since GHC 7.10 iirc
03:16:40 <saurabhn_> sphinxo: Here's what I've learnt. either you just use lenes, or you end up reinventing them. use microlens if you don't want to you lens.
03:16:45 <cocreature> Bitraversable is too
03:18:45 <saurabhn_> sphinxo: lenses is a swiss-army toolkit for standardized read/write access to a lot of data-types. unless you know that already and are just worried about the dependency issue.
03:19:30 <cocreature> if all you need is "first" from Bifunctor, lens is just unnecessarily complex
03:19:32 <AndreasPK> The only drawback of lenses is that you have to use lenses. But it makes record updates look so much cleaner
03:19:36 <cocreature> use the simplest tool that gets the job done
03:19:57 <sphinxo> yeah I'm sticking with first for the moment
03:20:35 <sphinxo> I've used lenses before and I do appreciate what they offer
03:33:49 <Gurkenglas> What do I do instead of "./try-reflex" on Windows?
03:33:55 <ertes-w> saurabhn_: well, some form of reactive programming can solve this, but i generally just write transactions by hand, because even most haskell DB frameworks are based on ORM or similar models
03:35:07 <ertes-w> saurabhn_: also reactive programming is not really a great solution either, because it would be very difficult to update data *efficiently* without doing actual requerying
03:35:52 <saurabhn_> ertes-w: agree. that's what we thought as well... hence this discussion here. not completely happy with whatever solutions we have come up with till now.
03:37:20 <ertes-w> saurabhn_: i found manual transactions to be just fine…  yes, there is some additional potential for bugs, but it's so local that it hardly ever mattered for my use cases, and i did have some rather complicated transactions
03:42:57 <maerwald> can someone download/install hackage-security via stack and tell me where it downloads it from?
03:43:27 <maerwald> preferably nightly
03:50:01 <merijn> What's the equivalent of 'bracket' for MonadBaseControl?
03:50:36 <ertes-w> merijn: see lifted-base
03:51:09 <ertes-w> merijn: https://hackage.haskell.org/package/lifted-base-0.2.3.11/docs/Control-Exception-Lifted.html#g:9
03:51:40 <merijn> ah, thanks
03:52:01 <ertes-w> merijn: read the docs carefully
03:52:15 <merijn> ertes-w: Why?
03:52:39 <ertes-w> merijn: because 'bracket' has some semantical caveats
03:52:51 <knupfer> Just realized, that cabal uses even for benchmarks -O1, I think that's misleading.
03:53:04 <ertes-w> merijn: i mean specifically the MonadBaseControl variant
03:53:37 <merijn> I don't actually use it, I'm just writing something that's parameterised over some bracket so I can use the same code with conduit, pipes, etc.
03:53:46 <knupfer> (my lib is 20% faster with -O2 and I wonder if I've wasted my time optimizing some code with -O1)
03:53:50 <merijn> ertes-w: So that's Someone Else's Problem (TM)
03:54:15 <ertes-w> ah
03:55:27 <merijn> ertes-w: I'm just writing something that lets you do "foo bracket" with either regular bracket, MonadBaseControl, or MonadMask so I 1) don't incur extra dependencies and 2) don't tie myself to one particular strategy :)
03:55:55 <merijn> ertes-w: So I just wanted to make sure I formulat it the most convenient way so people don't end up having to write obnoxious wrappers
03:58:15 <merijn> ertes-w: but it looks like bracket/bracketOnError looks the same for basically everything except MonadResource, so I can get away with only making people write a wrapper for MonadResource
04:00:08 <Athas> Which editors do people use for Haskell these days?  I find Emacs with intero-mode to be intolerably slow quite often (I also remember plain haskell-mode being pretty slow).
04:00:49 <Athas> Maybe I just write shitty Haskell and my code is an order of magnitude larger than it ought to be.
04:01:06 <merijn> Athas: Still vim, with ghc-mod (since I couldn't get hdevtools to work with new-build), but ghc-mod is still rather slow IMO
04:01:25 <merijn> Athas: Part of that problem is me being stuck with shitty old vim so no async checking
04:04:33 <Unhammerd> is there a way with intero or similar to find the functions within your project that take a certain data ?
04:05:08 <Unhammerd> like with OO things, you can typically type "myobject.<TAB>" to get accessors
04:05:27 <Unhammerd> maybe people hoogle 
04:06:08 <digitalkiwi> I'm really struggling to tolerate nix
04:07:18 <merijn> digitalkiwi: Have you looked at new-build?
04:07:26 <digitalkiwi> on nixos at that, wondering if I'm missing something, but it is a huge pita to do anything, and as many cool features as it has, it seems to be lacking more essential ones...
04:07:51 <maerwald> and there I thought it solves all my problems, since that is what people keep telling me ;P
04:09:43 <digitalkiwi> and the man page is essentially useless so far...there are only 3 things I wanted to do that I am able to, afaict, and they don't even work well, weren't really explained well, hard to even find, and I don't even know all of the intricacies of them
04:09:46 <merijn> bleh...why is bracket such an annoying pattern when nested :\
04:09:54 <merijn> digitalkiwi: What are you trying to do?
04:09:59 <digitalkiwi> those three things are installing removing and searching...
04:10:10 <saurabhn_> Unhammerd: hoogling your project is the only solution. This is one of the downsides of FP. If the function you need is inside a known module, then autocomplete may work. Not otherwise (at least, not yet).
04:10:39 <merijn> Unhammerd: I think ghc-mod supports limited form of type-based auto-completion/suggestion
04:10:42 <maerwald> digitalkiwi: what many people don't understand is that a distro is not mainly about technology, but about consistency and correctness, which is an ongoing packaging effort
04:10:48 <ertes-w> merijn: understandable, although for these cases i tend to just write new/close functions/actions separately
04:10:52 <digitalkiwi> and when I try to install things it takes like 4 times to actually get the name right and uninstalling mostly did nothing ...like it didn't even error but it didn't do anything
04:10:54 <merijn> Unhammerd: And HIE (Haskell IDE Engine) too, but those are both a bit rough still
04:11:10 <merijn> ertes-w: That doesn't help with the "march to the right" issue
04:11:20 <Unhammerd> aha
04:11:23 <ertes-w> Athas: i use emacs with haskell-mode and a custom script for nix integration
04:11:24 <Unhammerd> thank saurabhn_ merijn 
04:11:39 <maerwald> digitalkiwi: if you have a good PM, but the input to it is junk, the distro is still junk too
04:11:46 <merijn> ertes-w: Normally I'd probably use Managed/ContT, but since I'm currently so blissfully dependency free I'd like to keep it that way :)
04:12:05 <ertes-w> Athas: i never had performance problems with that setup, except that GHC can use a lot of memory
04:13:45 <ertes-w> merijn: well, since almost all of my packages depend on kan-extensions, i don't really care too much =)
04:14:30 <ertes-w> merijn: Codensity is also compatible with monad-control, so in principle you could even transform Codensity actions into MonadBaseControl actions
04:14:34 <digitalkiwi> the only PM I ever liked using was pacman or clyde, finally got used to yum and it's not too bad for the most part every once and a while I lose hair...apt is pretty annoying for some of the same reasons as nix is pissing me off with a ton of different binaries, even homebrew is not as annoying as nix...maybe eventually it'll click
04:14:36 <merijn> ertes-w: This library currently only depends on base and transformers (and for GHC >8 it only depends on base)
04:15:19 <merijn> ertes-w: And it's probably the first library of mine I'd try and convince people to use if/when I hit v1.0, so having such a small footprint might help
04:16:07 <maerwald> digitalkiwi: pacman is simple, because it doesn't allow multiple versions of the same package
04:16:17 <maerwald> and it has practically zero conflict resolution skills
04:16:25 <maerwald> it will just bail out and tell you to read the fking news ;)
04:16:27 <maerwald> and you should
04:17:13 <digitalkiwi> I haven't had news worthy conflicts in a long time...
04:17:30 <cocreature> merijn: now I’m curious, what lib are you working on? :)
04:18:12 <merijn> cocreature: I wrote https://hackage.haskell.org/package/broadcast-chan a while back. I'm turning it from a minimal implementation into something useful
04:18:33 <digitalkiwi> and of all people I should have the most, I almost never use arch, I only have a few VMs, every once and a while I update them after anywhere between 3 months usually more and in a few cases up to 4-6 years >.>
04:19:00 <maerwald> digitalkiwi: you probably don't have a lot of packages then
04:19:01 <ertes-w> merijn: sure, it's a huge selling point
04:19:04 <merijn> cocreature: So, including easy ways to combine channels with pipes/conduit, and one think I keep wanting but never have: A convenient method setup a parallel pipeline
04:19:27 <cocreature> merijn: neat! I’ll definitely have a look at it
04:19:40 <merijn> cocreature: Basically, what I often end up wanting is take some IO bound computation and just have it run in N parallel instances
04:19:44 <ertes-w> merijn: personally i don't really care too much about dependencies, mostly because i have an effective safety net against dependency hell
04:19:52 <digitalkiwi> the update I did a few days ago was 562
04:20:16 <merijn> cocreature: Well, right now the hackage version only does "make channel" and read/write to it :p
04:20:40 <merijn> cocreature: My goal is to basically obsolete Control.Concurrent.Chan
04:20:48 <cocreature> merijn: I meant that I’ll take a look at it once you’ve got to the point where it does something a bit more useful :P
04:21:05 <digitalkiwi> which is one of my smaller systems, when I actually had it on hardware and was using it I had probably 1200+ packages
04:21:29 <ertes-w> merijn: what's the advantage of yours over Chan?
04:21:39 <ertes-w> and how does it compare to TChan?
04:21:52 <merijn> cocreature: My main complaints about Chan are: 1) it's not closable so if you want to consume a finite stream of input there's no way to know you're finished, 2) you cannot have a Chan that broadcasts data without consumers
04:21:54 <digitalkiwi> but yes nixos is a lot better for having multiple versions of things if you actually need that, but that entails actually being able to use it... :(
04:22:19 <merijn> ertes-w: TChan is probably faster, but TChan like all STM channels has two major failings: 1) no fairness, 2) no single wakeup
04:22:24 <rockman37> digitalkiwi: Wow, that's a lot of packages.
04:22:33 <ertes-w> digitalkiwi: side note: you can use nix without NixOS
04:22:45 <maerwald> ertes-w: and what packages would you use then?
04:22:47 <ertes-w> merijn: Chan is fair?
04:22:55 <merijn> ertes-w: It's MVar based, so yes
04:23:04 <merijn> ertes-w: MVar's guarantee fairness
04:23:11 <ertes-w> ah
04:23:15 <ertes-w> maerwald: hmm?
04:23:23 <sphinxo> Best way to dump haskell datastructures in xml?
04:23:31 <cocreature> oh I didn’t know MVar guarantees fairness
04:23:32 <maerwald> ertes-w: packages... where do you think nixpkgs comes from? NixOS
04:23:43 <ertes-w> sphinxo: dump to JSON using aeson, convert to XML
04:23:44 <ertes-w> =)
04:23:45 <maerwald> so using nix without NixOS means you have basically no packages
04:24:14 <ertes-w> maerwald: you can use nixpkgs without using NixOS as your distribution?
04:24:14 <Yotam> Anybody using stack on nixos?
04:24:30 <maerwald> ertes-w: you are confusing "using a distro" with "installing and booting it" I think
04:24:32 <merijn> cocreature: "No thread can be blocked indefinitely on an MVar unless another thread holds that MVar indefinitely. One usual implementation of this fairness guarantee is that threads blocked on an MVar are served in a first-in-first-out fashion, but this is not guaranteed in the semantics."
04:24:38 <ertes-w> merijn: so your version of Chan can be deleted explicitly?
04:24:42 <cocreature> merijn: yeah I just read the docs :)
04:24:51 <ertes-w> maerwald: yes, i am
04:24:54 <merijn> ertes-w: In what sense?
04:25:00 <sphinxo> ertes-w: that'd be perfect since I already have ToJSON instances, any haskell library that does that?
04:25:12 <ertes-w> merijn: you said that you can *close* channels, or do you mean closing the write end?
04:25:13 <sphinxo> I see https://github.com/tel/xml-mapping exists
04:25:21 <maerwald> ertes-w: I have several chroots of various distros, I use them all ;) but I never "boot" them
04:25:34 <merijn> ertes-w: You can close the write end (which you can then detect at the read end)
04:26:18 <merijn> ertes-w: If you have no read-ends then all writes get dropped on the floor, but that's done by the GC, no specific action you need to take
04:26:33 <ertes-w> sphinxo: nothing as lovely as aeson…  there is xml-conduit, but it doesn't have something as nice as From-/ToJSON
04:27:09 <merijn> ertes-w: One issue I "frequently" have is: I want a library to expose events in a Chan so other code can effectively listen for events to hook. But with Chan you have the issue that if there are no readers events just accumulate permanently, leaking memory
04:27:42 <maerwald> ertes-w: you could say "you can install NixOS packages chrootless via nix in your running distro"
04:27:43 <merijn> ertes-w: That's the initial problem I tried to solve. The closing bit came later, since I noticed there was almost no noticable performance impact from that (and I often find myself wanting to close channels too)
04:27:49 <sphinxo> there's some library's that use generics : https://github.com/finnsson/Text.XML.Generic and https://hackage.haskell.org/package/tofromxml
04:28:01 <sphinxo> but it's difficult to pick which one, and they all look rather unmaintained
04:28:53 <ertes-w> merijn: i try to avoid using channels in the first place…  my worker pipelines usually use some STM *state* rather than messaging
04:29:05 <digitalkiwi> it just feels like a really feature rich multi tool, it can do a lot of things better than the competition, but it's missing a few really important ones, and it has the most uncomfortable handle and hurts to use :(
04:29:11 <ertes-w> merijn: reason is that i find it much easier to recover from failure, and to lock/share resources
04:29:24 <merijn> ertes-w: Depends on the kind of stuff you write I suppose. Channels work nicely with streaming pipelines
04:30:24 * hackagebot llvm-extra 0.7.3 – Utility functions for the llvm interface – https://hackage.haskell.org/package/llvm-extra
04:30:26 <digitalkiwi> and I still haven't figured out how to install the useful parts of kde :|
04:30:51 <maerwald> digitalkiwi: it's slightly offtopic
04:31:06 <maerwald> at least kde is :P
04:31:20 <merijn> Athas: btw, what is "intolerably slow" to you? wrt intero
04:31:27 <ggVGc> isn't kde written in haskell?
04:31:50 <maerwald> that would be awful
04:32:29 <ertes-w> merijn: my primary use case for concurrency is transforming data in stages…  for example one thread per site streams a list of objects into a queue, then a bunch of other threads fetch the actual objects, another bunch writes them to disk, etc.
04:32:52 <ertes-w> merijn: i used to do that using a streaming pipeline, but i always had the problem of responding to failures properly
04:33:09 <ertes-w> once a thread takes something, it can never give it back
04:33:13 <digitalkiwi> nixos has the bare minimum of it to the point of being useless
04:34:18 <maerwald> digitalkiwi: they have a channel where you can rant, but I'll tell you they probably won't listen :P
04:34:44 <maerwald> the core is well maintained configuration wise, the rest is not and full of inconsistency and undocumented things
04:34:59 <maerwald> they'd need a change of workflow and policy to fix it
04:35:02 <maerwald> but that won't happen
04:35:57 <maerwald> configuration simplicity was THE killer argument for it, but you cannot just add configuration, you have to make it consistent and look at the global picture
04:35:59 <ertes-w> #haskell is not a good place to discuss this…  it's off-topic and won't be read by the right people =)
04:36:04 <maerwald> yeah
04:37:15 <Athas> merijn: typing, scolling, deleting... everything.
04:37:27 <Athas> I suspect intero is computing all kinds of expensive things for syntax purposes.
04:37:48 <Athas> merijn: it is particularly bad in files that use quasiquotes.
04:37:51 <merijn> Athas: Isn't that more of an issue with the emacs side, most likely?
04:38:06 <Athas> merijn: probably.
04:38:28 <`Guest00000> :t uncurry $ flip $ curry id
04:38:28 <ertes-w> merijn: BTW, if you know a better solution to this than STM-based state i'm all ears =)
04:38:30 <lambdabot> (b, a) -> (a, b)
04:38:55 <ertes-w> it's not exactly an elegant solution, just one that works
04:40:12 <Athas> My Haskell program is a single 45 KSLOC package split into 180 modules.  I'd be surprised if that's bigger than what these tools are built for.
04:41:22 <cocreature> Athas: fwiw I’ve found that a relatively minimal setup + ghcid works reasonable well when the other tools break/are too slow
04:41:58 <ertes-w> Athas: is intero slow, or is GHC slow?  look at 'top' while using
04:42:02 <Athas> cocreature: ghci would be waaaaaaay too slow for me, but thanks for the suggestion.  I should probably just start turning off features.
04:42:23 <Athas> ertes-w: Primarily Emacs is slow.
04:42:42 <Athas> For example, I see that 25% of runtine during editing is spent in `eldoc-print-current-symbol-info`, which I think tries to look up symbol information under the cursor.
04:42:47 <Athas> If it does that synchronously, well...
04:42:51 <cocreature> Athas: intero, ghc-mod and friends don’t do anything fundamentally different from ghci so I would be surprised if they are significantly faster
04:43:11 <ertes-w> Athas: according to my observations haskell-mode's performance is bound to GHC's performance…  that's why in haskell i avoid large modules
04:43:21 <Athas> cocreature: no, they are also really slow if I want a prompt, but it looks like ghcid reloads frequently, which would be a killer.
04:43:29 <Athas> It takes many minutes to load my code into ghci from scratch.
04:43:53 <Athas> The module I am currently frustrated by is 1380 lines of code, but it uses a lot of quasiquotes, which expand into giant ASTs.
04:43:54 <ertes-w> Athas: perhaps haskell-mode offers a smoother experience than intero, but it's an uneducated guess based on my experience with haskell-mode
04:44:01 <merijn> Athas: Are you letting ghci use object code?
04:44:04 <digitalkiwi> sorry
04:44:07 <merijn> Athas: That should speed stuff up
04:44:16 <cocreature> Athas: ghcid tweaks the right options to get code to load fairly fast (e.g. -fno-code) and reloading is a lot faster than loading your code from scratch
04:44:30 <ertes-w> using object code with GHCi has some rather nasty caveats
04:44:40 <Athas> merijn: will it speed up loading the code?
04:45:03 <merijn> Athas: Depends on how often you rebuild, I suppose
04:45:06 <cocreature> -fobject-code speeds up reloading, it makes the initial load slower
04:45:09 <ertes-w> Athas: one way -fobject-code speeds up reloading is by reusing compiled objects of *other* modules
04:45:11 <cocreature> so it’s a trade off
04:45:31 <Athas> Hm.  Maybe I will try that one day.
04:45:50 <ggVGc> do you guys have problems with compilation times with haskell_
04:45:51 <ggVGc> ?
04:46:08 <ggVGc> I mean, with GHC I guess
04:46:17 <ertes-w> ggVGc: GHC is slow, so i tend to compile only for deployment
04:46:18 <cocreature> ggVGc: would I like them to be smaller? sure! are they unbearably slow? no
04:46:43 <ggVGc> yeah I've never been bothred really
04:46:49 <Athas> ggVGc: depends on "problem".  I find the linking times much much worse.
04:46:51 <ggVGc> but my largest project is like 4000 lines
04:46:58 <ertes-w> ggVGc: also i benefit a lot from using nix, because it saves me from having to compile most of hackage
04:47:19 <cocreature> Athas: if linking times are a problem, try using gold or lld
04:47:27 <Athas> I wonder how well ghcid works with stack... guess I can just 'stack exec ghcid'.
04:47:46 <Athas> cocreature: I think those are already used behind the scenes.
04:48:03 <Athas> Actually, I think the major cost centra may well be copying the resulting binaries.
04:48:07 <cocreature> Athas: by default they are not, at least not before GHC 8.0
04:48:26 <Athas> When using stack, the files are written once to disk by the linker, then again for moving them into another directory in .stack-work, and then (if you use 'stack install'), to $HOME/.local.
04:48:27 <knupfer> ggVGc: If you do a lot of type level stuff, it gets quite bad.
04:48:43 <ggVGc> now, who would do a lot of type level stuff in haskell
04:49:05 <knupfer> ertes-w: but sadly, nix doesn't cache modules of a project, only libs and entire projects
04:49:26 <Athas> My Haskell project generates 400MiB of binaries, so copying all of that three times can be felt, even on an SSD.
04:49:26 <knupfer> ggVGc: Me. Why not?
04:49:31 <ggVGc> knupfer: it was a bad joke
04:49:34 <ggVGc> I regret typing it
04:49:35 <ertes-w> knupfer: yeah, nix only works on the package level…  for development it's best not to compile, unless you really have to
04:50:29 <cocreature> Athas: regarding ghcid and stack, if a stack.yaml or a .stack-work directory is present it automatically sets up things correctly
04:50:51 <knupfer> ertes-w: I'm usually benchmarking a lot. I would profit immensely from a more granular nix.
04:51:59 <boj> knupfer: maybe drop down to nix-shell and build with cabal?
04:54:52 <knupfer> boj: Yes, that's my usual workflow. But it's annoying anyway. For example if you switch between profiled and not profiled, nix could save a lot of time.
04:55:13 <knupfer> boj: And it's not easily shareable between colleges.
04:55:59 <cocreature> knupfer: new-build is better at not invalidating things if you switch between profiled and non-profiled builds
04:57:05 <Yotam> Can someone help me update stack on nixos?
04:57:58 <Athas> cocreature: sounds good; I will try it out.
04:58:55 <Athas> It's installing an xml package.  Ominous signs...
04:59:10 <knupfer> cocreature: Good advise. When will new-build be equal to build?
04:59:51 <cocreature> knupfer: it’s ready when it’s done™ :) but it’s already quite usable in 2.0 and if you’re willing to use HEAD (which is reasonably stable) then it’s even closer
05:18:33 <Athas> Wow, ghcid is really fast and good.  How come everything else is so bloated and slow by default if it's possible to make it this fast?
05:18:40 <Athas> Initial loading was slow, but it's pretty snappy now.
05:20:15 <merijn> Sadly all the ghcid plugins for vim are for neovim :\
05:20:47 <Athas> The only thing I miss is enough editor integration for next/prev-error shortcuts to work, but that's a small sacrifice for not having to wait on my editor.
05:23:08 <ertes-w> knupfer: haskell-ng only works on the package level…  i have written nix expressions for haskell "scripts" that i deliver without cabal files, and those could in principle be written for uncabalised *libraries* as well…  however, it would not integrate well with anything; neither haskell-ng nor your development workflow
05:24:12 <ertes-w> knupfer: that said you can still use a compilation-based dev workflow with nix that does 'cabal build'-style builds…  i've done that in the past, before i switched to a GHCi-based workflow
05:25:54 <ertes-w> knupfer: see the targets 'all', 'dist', 'Setup', 'shell.nix' and 'dist/setup-config' here: https://github.com/esoeylemez/skeleton/blob/skeleton/Makefile
05:26:07 <stevenxl> Hi folks. Is there a name for (<=<), like how (>>) is pronounced "then".
05:26:31 <ertes-w> knupfer: if you put this Makefile in a cabalised project, you can just type 'make' to perform a nix-based build, and rebuilding will share the stuff that has already been built
05:27:13 <ertes-w> knupfer: this is an actual cabal build, not something homegrown
05:27:20 <knupfer> ertes-w: Cool, thanks!
05:28:02 <ertes-w> knupfer: oh, actually you can ignore the 'dist' target =)
05:29:46 <norc_> Is there a way I can invoke type constructors in GHCi just for the sake of looking what it produces?
05:30:04 <merijn> norc_: With type families you mean?
05:30:12 <ertes-w> stevenxl: "after"?  "composed with"?
05:30:43 <ertes-w> stevenxl: (<=<) is the composition function for Kleisli categories
05:31:17 <norc_> merijn: Yeah. Im applying monad transformers im my head and I wanna be sure that the types I think they produce are correct.
05:31:20 <stevenxl> ertes-w: Thanks. I think I'm going to call it "after" if those are my two options. 
05:31:56 <merijn> norc_: ah, that doesn't sound like type families to me. Maybe you want lambdabot's @unmtl?
05:32:19 <merijn> @unmtl StateT s (ExceptT e m) a
05:32:19 <lambdabot> s -> ExceptT e m (a, s)
05:32:30 <norc_> That looks right great!
05:32:44 <merijn> @unmtl StateT s (ErrorT e m) a
05:32:44 <lambdabot> s -> m (Either e (a, s))
05:32:44 <norc_> merijn: Yup thanks. Seems to work great in a query too.
05:32:45 <norc_> :)
05:33:02 <merijn> Someone should probably fix that to work with ExceptT
05:38:04 <bartavelle> is intero supposed to work for largish projects? it takes all my 32GB of memory and bricks my computer
05:38:14 <bartavelle> hdevtools works fine thouhg
05:38:55 <Athas> bartavelle: I was unable to use intero until I upgraded from 8GiB to 16GiB on my laptop.
05:39:03 <Athas> So yeah, I'd say high memory usage is expected.
05:39:39 <merijn> bartavelle: hdevtools is kinda brittle though
05:39:58 <merijn> bartavelle: No one seems to maintain it, so expect it to break in the near future
05:40:10 <bartavelle> merijn: I use it all the time, and noticed it *seems* brittle
05:40:31 <bartavelle> however, running it manually usually tells me I did not install some package required by the test suite
05:40:54 <merijn> bartavelle: It assumes a bunch of things about your cabal/stack setup that are not very portable. It also has a tendency to keep reconfiguring your cabal project
05:41:10 <merijn> bartavelle: I'm using ghc-mod now which is more robust, although a bit slower
05:41:24 <saurabhn_> bartavelle: open GHCi issue is causing this, probably.
05:41:25 <bartavelle> oh, I moved from ghc-mod which was too slow
05:41:32 <saurabhn_> bartavelle: I can confirm the behaviour.
05:41:37 <merijn> bartavelle: Vim?
05:41:37 <bartavelle> saurabhn_: thx!
05:41:39 <bartavelle> yes
05:41:44 <saurabhn_> I'm trying out VSCode+HIE and happy with the results so far.
05:41:50 <maerwald> ghc-mod robust? Afair the API was fluctuating so much that some vim plugin developers just dropped support
05:41:50 <saurabhn_> but even they have the memory leak issue.
05:41:52 <bartavelle> well, I just tried vscode + intero
05:41:59 <saurabhn_> it's an upstream GHCi issue. 
05:42:03 <merijn> bartavelle: Yeah, the vim plugins for ghc-mod don't use a long lived session causing it to recompute every time
05:42:13 <saurabhn_> vscode + intero/haskero is worse than spacemacs+intero
05:42:29 <bartavelle> saurabhn_: the intero side you mean?
05:42:32 <saurabhn_> bartavelle: how large is your project?
05:42:45 <bartavelle> hard to say
05:42:56 <merijn> bartavelle: I wrote a drop-in for ghc-mod that lets neomake work with cached sessions
05:43:22 <ertes-w> > let x͏ = 1 : x; x = 2 : x͏ in x͏
05:43:24 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
05:43:28 <bartavelle> 17k loc, between ~10 packages, but a lot of TH in some places
05:43:51 <saurabhn_> bartavelle: no, your main project. that you're loading in your IDE. how large is it?
05:44:00 <bartavelle> merijn: I didn't like neovim the last time I tried it, don't remember why
05:44:03 <saurabhn_> bartavelle: how many modules/ files?
05:44:13 <bartavelle> 126 files
05:44:14 <saurabhn_> bartavelle: please try vscode + HIE.
05:44:22 <merijn> bartavelle: Neomake works with regular vim
05:44:25 <saurabhn_> bartavelle: it's amazingly responsive. I'm blown away.
05:44:31 <bartavelle> saurabhn_: does it prints type as you hover over expressions ?
05:44:38 <merijn> bartavelle: I can't use neovim, neomake works fine with vim7 and vim8 for me
05:44:40 <saurabhn_> bartavelle: yeps... seems to be working.
05:44:42 <bartavelle> merijn: oh I did not realize !
05:44:48 <merijn> bartavelle: https://github.com/merijn/ghc-modid
05:44:54 <merijn> bartavelle: http://lpaste.net/358541
05:45:13 <merijn> bartavelle: That launches a daemon instance when you open a haskell buffer and closes it when the last one in a project is opened
05:45:20 <bartavelle> merijn: but even though vscode is slow is hell, I like that it has vim bindings and I can see types by moving my pointer over expressions
05:45:36 <merijn> bartavelle: initial typecheck takes about 5s for me, after that it's about 1s for me. A bit slow, but workable
05:45:44 <bartavelle> merijn: scribbling this right now
05:45:49 <AndreasPK> If vscode is slow as hell what is atom? glacial? :D
05:45:56 <bartavelle> AndreasPK: unusable
05:46:01 <ertes-w> > let let͏ = 1 : let͏ in let͏
05:46:04 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:46:07 <saurabhn_> bartavelle: just. try. HIE+VSCode. 
05:46:14 <bartavelle> saurabhn_: yup
05:46:19 <merijn> bartavelle: If you have vim8 neomake should use async processing so then you won't be blocked while it checks
05:46:56 <AndreasPK> bartavelle: Guess thats accurate enough for most people.
05:47:21 <bartavelle> AndreasPK: IDK, java devs seem immune to IDE lag ;)
05:47:40 <merijn> bartavelle: Sadly ghc-mod doesn't cache types, so checking the type of an expression is still a bit slow, but that's not as annoying as slow saves (to me, anyway)
05:47:42 <norc_> @unmtl StateT Int [Int]
05:47:43 <lambdabot> Plugin `unmtl' failed with: `StateT Int [Int]' is not applied to enough arguments, giving `/\A. Int -> [Int] (A, Int)'
05:47:50 <norc_> merijn: ^- it appears to be slightly buggy.
05:47:54 <norc_> :D
05:48:13 <merijn> norc_: Well, it's right. You didn't give it enough arguments :)
05:48:20 <norc_> Mmm. Ohh.
05:48:21 <norc_> @unmtl StateT Int [] Int
05:48:22 <lambdabot> Int -> [] (Int, Int)
05:48:41 <merijn> norc_: StateT expects 3 arguments, by pre-applying [] it breaks down :p
05:49:35 <AndreasPK> bartavelle: Tbh I don't mind using things like IntelliJ so pretty immune, but even I found Atom borderline unuseable. It got better recently afaik but still pretty bad.
05:50:41 <bartavelle> AndreasPK: I also use intellij when interacting with java, but you would be happy to know they have some "0 latency hack" somewhere
05:57:07 <norc_> @unmtl StateT so (State s) a
05:57:07 <lambdabot> so -> s -> (a, so, s)
05:57:13 <norc_> Uhh.
05:57:23 <norc_> merijn: well its really helpful thank you for the tip :)
05:57:47 <merijn> norc_: np :)
05:59:50 <norc_> So a monad transformer wraps the inside of a monad with another monad it looks like.
06:01:00 <merijn> norc_: I wrote up an exercise that helps understand transformers here: https://gist.github.com/merijn/098106abd45c940dab09
06:01:25 <merijn> norc_: Step 1) try and implement regular (non-transformer) State yourself. Step 2) try to generalise it
06:02:50 <norc_> merijn: That looks like an interesting excercise.
06:03:59 <norc_> merijn: Am I free to "cheat" on the Functor/Applicative? :p
06:04:14 <merijn> norc_: You mean reusing the Monad implementations?
06:04:16 <norc_> Yeah
06:04:34 <merijn> Sure. Those are just there because else it doesn't compile :p
06:06:38 <merijn> I wish there was a less obnoxious way to lift several statements via liftIO. I end up either having a single liftIO and returning a tuple or something, which is annoying. Or having a lot of separate liftIO's :\
06:06:45 <merijn> I can't decide which I dislike more...
06:07:05 <tdammers> rewrite all IO functions in Prelude in terms of MonadIO :x
06:07:36 <merijn> tdammers: Most of them aren't from Prelude :p
06:07:52 <tdammers> rewrite all IO functions in Hackage in terms of MonadIO
06:08:41 <maerwald> haha
06:08:45 <maerwald> tdammers++
06:09:05 <norc_> merijn: Alright gotta run. Im on the task :)
06:12:11 <ertes-w> :t join . liftIO
06:12:13 <lambdabot> MonadIO m => IO (m a) -> m a
06:12:23 <ertes-w> merijn: ^ sometimes i use this approach
06:12:49 <ertes-w> :t \f c d -> (join . liftIO) (liftA2 f c d)
06:12:51 <lambdabot> MonadIO m => (a1 -> b -> m a2) -> IO a1 -> IO b -> m a2
06:13:20 <ertes-w> merijn: i also use it a lot with STM
06:13:24 <ertes-w> :t join . atomically
06:13:25 <lambdabot> error:
06:13:25 <lambdabot>     Variable not in scope: atomically :: a -> m (m a1)
06:13:28 <merijn> How does that help?
06:13:33 <ertes-w> :t join . Control.Concurrent.STM.atomically
06:13:35 <lambdabot> GHC.Conc.Sync.STM (IO a) -> IO a
06:13:53 <merijn> "IO (m a)" seems like the opposite of what I need?
06:14:15 <ertes-w> merijn: instead of building a tuple and using it outside of liftIO, build an m-action inside liftIO, then embed it from outside
06:14:37 <merijn> ertes-w: The problem is that I'm building multiple m-actions :)
06:14:48 <ertes-w> merijn: the idea is:  join . liftIO $ do …; pure theRestOfTheAction
06:14:48 <merijn> ertes-w: So I'd end up building a tuple of m actions
06:15:24 <ertes-w> you can then easily embed results from the IO action into the future m-action
06:15:28 <merijn> ertes-w: I have a let block that defines functions using bound values.
06:16:11 <merijn> ertes-w: So I'd still be building a tuple of 5 m-actions in that scenario :)
06:17:02 <ertes-w> merijn: your complaint is that (do (x, y, z) <- liftIO c; f x y z) is ugly and inconvenient, right?
06:18:03 * hackagebot hformat 0.3.1.0 – Simple Haskell formatting – https://hackage.haskell.org/package/hformat
06:18:03 * hackagebot cmv 1.0.5 – Detailed visualization of CMs, HMMs and their comparisions – https://hackage.haskell.org/package/cmv
06:18:13 <ertes-w> let's make it more specific:  do (x, y, z) <- liftIO (do x <- c1; y <- c2 x; z <- c3 y; pure (x, y, z)); f x y z
06:18:32 <merijn> ertes-w: My complaint is that I either have "do { (x, y, z) <- liftIO $ do {block here}; {- stuff with x y and z -} }" or "do { x <- liftIO foo; y <- liftIO bar; z <- liftIO baz; {- stuff with x y z here -} }"
06:18:50 <ertes-w> merijn: yeah, that's how i understood it
06:19:11 <ertes-w> merijn: taking the specific example i just mentioned, here is what it would look like in the 'join'-based style:
06:19:43 <ertes-w> merijn: join . liftIO $ do x <- c1; y <- c2; z <- c3; pure (f x y z)
06:20:05 <ertes-w> err
06:20:13 <ertes-w> merijn: join . liftIO $ do x <- c1; y <- c2 x; z <- c3 y; pure (f x y z)
06:20:16 <ertes-w> like that
06:20:40 <merijn> ertes-w: I don't have a single f x y z. x/y/z are functions/m-actions that are used in a few different places
06:20:52 <merijn> ertes-w: hold on, lemme cleanup and paste this
06:21:09 <ertes-w> merijn: shouldn't make a difference, but let's see your paste =)
06:29:23 <merijn> ertes-w: http://lpaste.net/358542
06:33:16 <ertes-w> merijn: see my annotation: lines 9-14, lines 44-47
06:33:49 <ertes-w> merijn: you can also introduce a do-block, if you see fit:  pure $ do …
06:34:49 <merijn> hmm, I guess that works
06:35:53 <ertes-w> merijn: it's just an inversion: instead of starting in m, going to IO and back, you start in IO and then go into m
06:36:38 <ertes-w> and your scenario is a typical use case: you have IO initialisation followed by the actual logic in m
06:37:15 <ertes-w> so your example was just perfect =)
06:37:24 <merijn> Now I just need to figure out how to avoid duplicating all these let/where functions for the other version of runParallel I'm working on, 'cause I haven't found a sane way to generalise them into a single version >.>
06:39:44 <merijn> A problem for another day :)
06:48:13 <tabaqui> in one of Continuations example is such code:
06:48:23 <tabaqui> facCPS n'@(n + 1) k = ...
06:48:43 <tabaqui> which extension is used here>
06:48:46 <tabaqui> *?
06:48:59 <tabaqui> I mean, I cannot pass (n + 1) in pattern matching
06:50:06 <ventonegro> tabaqui: n+k patterns
06:51:17 <mpickering> Can shake output ninja files as well as read them?
06:52:18 <maerwald> mpickering: I see ninja tests
06:52:57 <maerwald> "Shake supports the `.ninja` file format"
06:53:30 <mpickering> That describes reading ninja files but I want to convert a shake build system into a ninja one
06:53:49 <mpickering> Seems like the answer is probably no
06:53:52 <tabaqui> ventonegro: very detailed and distinct explanation on "downloads.haskell.org"
06:53:57 <tabaqui> thx :)
07:06:32 <cocreature> mpickering: given that you can use arbitrary Haskell code in your shake rules, that doesn’t seem possible
07:08:05 <mpickering> It must eventually evaluate to a dependency graph of some kind or not? 
07:08:30 <cocreature> mpickering: right but that graph does not need to be static
07:09:57 <cocreature> mpickering: e.g. in your shake rules you might use getDirectoryContents. you don’t want to translate the static result of that, you need to figure out some kind of glob pattern that matches the Haskell code
07:10:10 <mpickering> What does "static" mean here? Determined at compile time?
07:10:44 <cocreature> yep or in your case the time when you generate the ninja files
07:11:35 <mpickering> So "getDirectoryContents" is evaluated at make-time to generate some more rules? 
07:11:41 <cocreature> I guess if regenerating it often is an option, then you could make it work
07:12:18 <mpickering> Should you not write "getDirectoryContents" in a template haskell splice which generates the right static information at compile time
07:13:37 <mpickering> Seems like I don't really understand how it works :(
07:13:44 <mpickering> thanks for your help
07:13:50 <cocreature> mpickering: take the hello world example in http://shakebuild.com/manual. that uses getDirectoryFiles to find all source files. but when you convert your build system to ninja you don’t want to check one time which C files exist and generate rules based on those which exist at that point. you want to create a build system which finds all C files
07:15:15 <cocreature> now you could make getDirectoryFiles some special builtin so that you can translate it but in general you can use arbitrary Haskell code here so that does not really help
07:53:18 <orion> What's the current state-of-the-art in logging?
07:53:41 <ertes-w> orion: what's the use case?
07:55:19 <orion> ertes-w: A production application running in Kubernetes (docker, stdout) with many parallel threads.
07:55:38 <orion> Stateless too.
07:55:49 <ertes-w> orion: write to stderr
07:56:02 <orion> That's interesting. Why?
07:56:08 <ertes-w> orion: because docker
07:56:10 <orion> That's interesting. Why?
07:56:15 <orion> err
07:56:26 <orion> I'll research that more.
07:56:47 <ertes-w> orion: docker is in essence a process supervisor with an integrated logging mechanism…  you should use it
07:56:56 <ertes-w> and the way to use it is to write to stderr
07:57:23 <prg318> what if you don't want to run in a docker container?
07:57:37 <prg318> oh; read the question
07:57:38 <orion> Interesting. While I realized that docker had its own integrated logging mechanism, I did not realize that stderr was the proper way to utilize it.
07:57:40 <prg318> doh
07:57:40 <ertes-w> prg318: then orion lied about using docker =)
07:58:08 <prg318> hehe
07:58:30 <ertes-w> orion: docker is not quite the shining example when it comes to following the unix philosophy, but in this particular respect it's a love letter to unix =)
07:59:21 <ertes-w> orion: in terms of application design you should probably fire up a logger thread, and make sure that you handle termination properly, otherwise you might lose final log messages
07:59:56 <ertes-w> orion: then just pass a logger action around in your application:  type Logger m = String -> m ()
08:01:07 <ertes-w> orion: personally i do it via async + STM: when the logger thread receives a ThreadKilled, it flushes all remaining log lines before actually quitting, and the main thread makes sure to 'waitCatch' on the logger
08:04:11 <orion> ertes-w: Interesting.
08:04:50 <ertes-w> orion: you can use a simpler design: your logger action could just use an MVar lock
08:06:34 <ertes-w> main = do logLock <- newMVar (); let { log = liftIO . bracket_ (takeMVar logLock) (putMVar logLock ()) }; …
08:06:53 <ertes-w> type Logger = forall a m. (MonadIO m) => IO a -> m a
08:09:28 <c_wraith> ertes-w: that degree of serialization is rather slow.
08:12:22 <orion> Separate question: Is it a good idea to use a MVar () to pause the main thread until something occurs, like Ctrl+C?
08:12:38 <c_wraith> yeah, MVars are good for that.
08:13:12 <tsani> orion: yeah, MVar () is nice as a lock for a resource you can't represent conveniently, or as a notification
08:13:53 <ertes-w> c_wraith: serialisation?
08:15:19 <c_wraith> ertes-w: it prevents threads from logging concurrently.  That's the whole point of it.  But it becomes a bottleneck that puts a hard upper bound on how much concurrent work you can do, once it has 100% utilization
08:16:39 <ertes-w> c_wraith: yes…  depending on the application this may be what you want: "do not continue, until this log action has been performed"
08:16:52 <ertes-w> if that's not important, go with the separate thread
08:17:43 <orion> Would a TChan be more robust for logging?
08:17:54 <c_wraith> no.  don't do that.
08:18:00 <c_wraith> That's a good way to run out of memory
08:18:18 <c_wraith> At the very least, use one of the bounded Chan variants
08:19:49 <c_wraith> ertes-w: there are other approaches.  You can have multiple loggers going to individual sinks, with striped access.  Then you get greater concurrency and blocking semantics at the cost of needing a more complex system for log analysis.
08:19:55 <ocharles> orion: i wrote logging-effect, I consider it the best
08:19:58 <ocharles> obviously ;)
08:20:53 <c_wraith> ertes-w: but a log of log analysis tools are designed to work with logs spread over multiple machines already.  Multiple files on a single machine is basically the same to them.
08:22:05 <ertes-w> c_wraith: that something i would avoid, because if all of them end up writing to stderr, you have gained nothing
08:22:17 <c_wraith> ertes-w: yes.  don't log to stderr. :P
08:22:31 <ertes-w> c_wraith: why not?
08:23:06 <c_wraith> because it's inherently serial, and puts a hard cap on concurrency?
08:24:14 <orion> ocharles: Cool, thanks. I'll check it out.
08:24:56 <orion> I think I might do what nginx does: Write to a log file in the container, but in the docker image, symlink /dev/stdout (and stderr) to their respective log files.
08:25:28 <ertes-w> c_wraith: this is a docker setup…  you should log to stderr anyway, and if logging seriously becomes your bottleneck, you should use load balancing on the container level instead
08:25:59 <c_wraith> I don't buy that you should throw away performance just because that's "how it's done"
08:26:18 <ertes-w> c_wraith: by that logic you shouldn't be using haskell in the first place
08:26:25 <iqubic> What's going on here?
08:26:36 <c_wraith> haskell isn't "how it's done".  :P
08:26:55 <c_wraith> So that doesn't really apply.
08:27:08 <iqubic> c_wraith: it more like, "how many ways can i do this?"
08:27:39 <ertes-w> c_wraith: first determine whether your logging traffic is really that extreme
08:27:48 <c_wraith> It has been in the past.
08:27:55 <iqubic> Unless it's GUI in case the answer is none. There are no good ways to do Haskell GUI
08:28:50 <orion> ertes-w: Could you like me to an authoritative source that specifically says to use stderr instead of stdout? Everything I've googled so far says that docker supports both. Nothing I've read favors one over the other.
08:29:00 <ertes-w> c_wraith: the point is that you're giving up a lot of the basically free infrastructure and abstraction that docker provides just to get fast logging…  first determine whether that's necessary
08:29:32 <c_wraith> We were using an unbounded Chan at first, until it started using all memory because it the logger couldn't keep up.  Then we introduced a bound, but that just resulted in a lot of wasted performance.  Switching to a logger that provided striping already resolved that nicely.
08:30:01 <ertes-w> orion: docker supports both, but logging is traditionally done on stderr rather than stdout…  think of the latter as the "output" of your program
08:30:31 <ertes-w> orion: long-running programs like servers usually don't have an "output"…  they have diagnostics, which are stderr material
08:31:00 <orion> ocharles: I use multiple parallel worker threads which all use postgres. One thing I want to accomplish is log messages formatted like this: [INFO] [postgres/fooComponent] successfully connected to postgres" Note the "postgres/fooComponent" part.
08:31:16 <ertes-w> c_wraith: yes, i understand that there are use cases where that might be a problem
08:31:21 <orion> Is there an easy to accomplish that in a generic way with your library?
08:31:32 <ocharles> orion: shouldn't be a problem. The whole point of this library is that you can map over all log messages and add more information
08:31:42 <orion> I see.
08:32:08 <ocharles> orion: look at 'mapLogMessage' for one possibility
08:32:10 <ertes-w> c_wraith: and that's why i suggest problem analysis to determine whether one really needs to make that trade-off
08:32:31 <c_wraith> ertes-w: and I described that approach as "another way".  Not "the only way"
08:32:51 <ocharles> mapLogMessageM lets you use m effects in the underlying monad to map the log message, so maybe you could ask the underlying monad "which postgres/fooComponent am I logging?" and then prepend the result
08:33:04 <ertes-w> <c_wraith> ertes-w: yes.  don't log to stderr. :P
08:33:40 <ertes-w> that's "there are other ways, but yours sucks, don't do it" =)
08:42:49 <haskell_noob> http://lpaste.net/358546
08:43:02 <haskell_noob> Can someone help me understand why this doesn't work?
08:43:50 <srhb> haskell_noob: It's in your title.
08:44:01 <c_wraith> haskell_noob: just a rule of haskell.  All equations for a function must be adjacent.
08:44:01 <srhb> haskell_noob: Splitting definitions like that is simply not allowed.
08:44:41 <AWizzArd> They may be separated by whitespace though, empty lines.
08:45:15 <AWizzArd> Interesting… type signatures can go anywhere in the file?
08:45:28 <erisco> just comment out the line starting with "lol"
08:45:42 <haskell_noob> srhb: hmm, okay. I just assumed this would work too
08:46:13 <haskell_noob> it's a little unintuitive I suppose
08:51:15 <monochrom> If it were intuitive, there would be nothing to learn.
08:52:12 <c_wraith> AWizzArd: yes, the signatures can be elsewhere.  That's mostly because some people really wanted to be able to write "a, b, c, d :: Int" and then write the definitions afterwards.
08:52:52 <maerwald> monochrom: couldn't be more wrong :>
08:53:16 <saurabhnanda> haskell_noob: my suggestion, stop fiddling around with random syntax and get down to the real stuff :)
08:55:06 <jared-w> But if you're not fiddling around with random syntax are you really being productive in Haskell?
08:55:46 <saurabhnanda> jared-w: tongue-in-cheek I presume?
08:56:22 <jared-w> hah, indeed; haskell has a million ways to write any one thing and one of my favorite time-wasting pasttimes is golfing my Haskell into terser-yet-more-readable code
08:56:50 <ertes-w> > filterM (pure [False ..]) "abc"
08:56:53 <lambdabot>  ["","c","b","bc","a","ac","ab","abc"]
08:56:56 <ertes-w> very readable indeed =)
08:58:12 <wedify> iqubic: a sentiment i've heard before but i don't know why 
08:59:53 <jared-w> wedify: probably because there aren't really any good ways to do GUI, period. You want a fast, native like GUI but you want a very declarative way to describe GUI, you want very precise control over how it looks yet you want it to automatically look native to every platform and it has to look correct on every single imaginable window size
09:00:25 <jared-w> There's like 1-2, MAYBE 3 GUI toolkits that don't suck utter ass out there and pretty much all of them are terrible to use in an OOP language much less in a language like Haskell
09:01:32 <monochrom> Random fiddling is a legit way to learn, but there are two conditions. First you have to be really random (or really exhaustive). Second you don't prematurely try to "understand" each individual case, you collect all cases and look for patterns statistically, aggregately, holistically, globally.
09:02:35 <monochrom> But most humans are incapable of doing either. So they are better off not learn randomly. But Nature is a good example of satisfying both conditions and therefore being successful in this method.
09:05:25 <wedify> jared-w: interesting. i've been working on a toy gui where appearance is controlled by theme files. in the source you are just creating widgets and binding to their event streams. no worrying about layout in the code.rr
09:05:39 <wedify> s/rr//
09:06:00 <jared-w> wedify: seems pretty similar to HTML/CSS in concept
09:06:17 <ertes-w> @let perm = foldr(\x->(>>=zipWith((++).(x:))<$>tails<*>inits))[[]]
09:06:20 <lambdabot>  Defined.
09:06:22 <ertes-w> > perm "abc"
09:06:25 <lambdabot>  ["abc","acb","abc","abc","acb","abc"]
09:06:34 <cocreature> > permutations "abc"
09:06:37 <lambdabot>  ["abc","bac","cba","bca","cab","acb"]
09:06:44 <wedify> jared-w: maybe, i don't know any web stuff
09:07:14 <jared-w> Honestly the ideal GUI library that I see coming out is one that takes HTML + CSS and super-compiles that shit down into the equivalent using native code for each OS; not because HTML and CSS are great but because /everyone/ uses it for everything now and because web browsers are the new OS people care about writing apps for.
09:07:23 <jared-w> But that's just me on my soapbox :p
09:07:34 <cocreature> ertes-w: what is that supposed to be? a broken version of permutations or does it actually do something useful? :)
09:09:02 <ertes-w> cocreature: it's not the same function, but it's a nice code golf example =)
09:09:36 <ertes-w> > perm [0..]
09:09:39 <cocreature> ertes-w: but what function is it?
09:09:43 <lambdabot>  mueval-core: Time limit exceeded
09:10:07 <ertes-w> cocreature: it returns a list of all permutations of a finite list
09:10:18 <cocreature> ertes-w: no it doesn’t, take a look at the output of lambdabot
09:10:27 <cocreature> ertes-w: it contains abc 4 times and acb 2 times
09:10:32 <cocreature> that’s not all permutations
09:11:23 <ertes-w> err…  huh?
09:11:31 <ertes-w> oh, yeah, i screwed up
09:14:02 <ertes-w> @let reallyPerm = foldr(\x->(>>=zipWith(\l->(++x:l))<$>tails<*>inits))[[]]
09:14:04 <lambdabot>  Defined.
09:14:13 <ertes-w> > reallyPerm "abc"#
09:14:15 <tabaqui> why ContT in mtl and transformers packages don't correspond with each other?
09:14:15 <ertes-w> > reallyPerm "abc"
09:14:15 <lambdabot>  error:
09:14:16 <lambdabot>      • Couldn't match expected type ‘[a]’
09:14:16 <lambdabot>                    with actual type ‘GHC.Prim.Addr#’
09:14:17 <lambdabot>  ["abc","bac","bca","acb","cab","cba"]
09:14:22 <ertes-w> cocreature: there =P
09:14:25 <cocreature> that looks better :)
09:14:28 <tabaqui> they have different type definition
09:14:42 <tabaqui> and some original functions in each module
09:14:55 <cocreature> tabaqui: huh? I can’t even find a definition in mtl
09:15:12 <tabaqui> https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Cont.html#t:ContT -- cocreature 
09:15:28 <cocreature> tabaqui: that’s just a reexport from transformers
09:15:49 <tabaqui> but in transformers haddock there is not ExistentialQuantification
09:15:57 <tabaqui> s/not/no
09:16:30 <cocreature> there is no existential quantification in mtl either, that’s a kind signature
09:16:48 <cocreature> if your question is why it’s being displayed differently, I would suspect that different versions of haddock have been used to generate those docs
09:16:53 <cocreature> I agree that it’s a bit confusing
09:17:56 <cocreature> it would be great if reexports would be displayed clearer in haddock
09:18:05 <tabaqui> again, mtl dock has examples and wide description of the monad, while transformers has a link to original paper
09:18:31 <ertes-w> tabaqui: consider 'transformers' to be a lower-level library
09:18:39 <ertes-w> if in doubt, just use mtl
09:19:05 <tabaqui> ertes-w: okaay, that makes sense
09:19:09 <cocreature> transformers provides the types, mtl provides typeclasses that abstract over those types
09:19:18 <cocreature> and mtl reexports the types from transformers
09:19:27 <tabaqui> I'm new with all these monads
09:19:57 <tabaqui> just want to speak my confusions
09:20:01 <iqubic> Monads are fun.
09:20:17 <tabaqui> iqubic: not all of them, actually
09:20:19 <iqubic> Functions are fun. Therefore Monads are functors.
09:20:43 <iqubic> s/function/functor/
09:20:46 <tabaqui> I'm fun too, but I'm not a functor!
09:21:05 <cocreature> tabaqui: are you sure? have you tried fmapping yourself?
09:21:12 <iqubic> No, I suppose not.
09:21:26 <ertes-w> "go fmap yourself"
09:21:40 <iqubic> LOL
09:21:40 * Clint goes to fmap himself
09:22:21 * iqubic fmaps themselves too.
09:22:51 <tabaqui> please, don't <*> each other
09:23:01 <lavalike> error: • Occurs check: cannot construct the infinite type: Clint ~ f Clint
09:23:08 <iqubic> What everybody's favorite monad?
09:23:18 <tabaqui> Identity, ofc
09:23:24 <ertes-w> iqubic: IO
09:23:24 <int-e> Identity
09:23:43 <ertes-w> it's the one monad i miss most in other languages
09:24:47 <ertes-w> my second favourite monad is Codensity IO
09:24:47 <iqubic> ertes-w: most other languages handle IO differently than Haskell does. I like haskell's IO style a lot.
09:25:09 <ertes-w> my third favourite monad is Codensity (Codensity IO)
09:25:41 <cocreature> ertes-w: wild guess, but is your fourth favourite monad Codensity (Codensity (Codensity IO))? ;)
09:25:41 <iqubic> ertes-w: do you like free
09:25:50 <ertes-w> cocreature: no, STM
09:25:58 <tabaqui> STM is sweet
09:26:16 <iqubic> What is stm? Is that state or what?
09:26:25 <tabaqui> software transaction memory
09:26:30 <ertes-w> iqubic: i like FT =)
09:26:40 <iqubic> What is FT?
09:26:46 <ertes-w> the church encoding of FreeT
09:26:58 <iqubic> Too many monads spoil the code.
09:27:28 <iqubic> ertes-w: how do you Church encode a recursive data type?
09:27:41 <ertes-w> iqubic: you encode it as its fold
09:27:51 <c_wraith> iqubic, look at foldr
09:27:52 <ertes-w> iqubic: type List a = forall r. (a -> r -> r) -> r -> r
09:28:35 <iqubic> How does that make a list?
09:28:59 <ertes-w> iqubic: a list is fully determined by what happens when you (foldr f z) it
09:29:01 <iqubic> Wait, that the type of folder
09:29:17 <ertes-w> for example the empty list is (\f z -> z)
09:29:17 <iqubic> *foldr
09:29:26 <iqubic> Yeah, I get that.
09:29:38 <iqubic> How is FT defined then?
09:30:03 <ertes-w> iqubic: https://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Trans-Free-Church.html
09:30:30 <ertes-w> the definition is slightly more complex than it has to be…  it's a trade-off to get rid of the Functor constraint as well as the Monad constraint
09:30:30 <iqubic> I will look at that later.
09:30:49 <ertes-w> iqubic: understand List first…  make it a newtype and write a Monoid instance for it
09:32:30 <ertes-w> the definitions of (<*>) and (>>=) for church lists are particularly cool =)
09:58:23 <fizbin> Hey, can someone tell me, in https://hackage.haskell.org/package/influxdb-1.2.2/docs/src/Database-InfluxDB-Types.html#Precision what extension is it that allows "data Precision (ty :: RequestType) where" ?
09:58:45 <fizbin> It looks like it's a type parameterized on a specific value, yes?
10:04:58 <fizbin> Ah, "DataKinds"
10:14:14 <cocreature> fizbin: DataKinds creates a new kind RequestType with is inhabited by the types QueryRequest and WriteRequest. KindSignatures allows you to specify the kind of type parameters in this case ty
10:15:21 <lyxia> What about the kind RequestType makes it different from the type RequestType
10:16:30 <hydraz> uh, one is a kind.
10:16:32 <Alovenom> How do you prevent gcc from using -pie by default ? it's breaking OpenGLRaw
10:17:02 <Alovenom> apparently arch decided it would be a default now
10:17:11 <oherrala> Alovenom: -no-pie?
10:17:19 <Alovenom> I mean; from stack
10:17:29 <Alovenom> since I don't call gcc directly
10:17:35 <Alovenom> I tried this
10:17:53 <Alovenom> ghc-options:
10:17:54 <Alovenom>     # All packages
10:17:54 <Alovenom>     "*": -optl-no-pie
10:18:00 <Alovenom> but no dice
10:18:16 <ertes-w> recently i ran into a problem that would require a kind of dual notion to lenses…  i didn't really know what they are and called them Colenses, and in the end i realised that just the regular Lens type can actually express them, but they are improper lenses
10:18:36 <ertes-w> now i call them "escalators": instead of zooming in, they zoom out
10:19:24 <cocreature> Alovenom: try -optc-no-pie
10:19:28 <alexknvl> ertes-w: are there any advantages to church-encoding data types in Haskell?
10:19:31 <lyxia> hydraz: Why don't we say RequestType is both a kind and a type
10:19:43 <ertes-w> my initial attempt was based on the idea that they are really just the opposite notion of lenses:  type ColensLike f s t a b = (f a -> b) -> f s -> t
10:19:51 <ertes-w> it's an interesting type, but i couldn't really make it useful
10:19:56 <Alovenom> cocreature: thank you I'll try
10:20:14 <ertes-w> alexknvl: yes, and i'm happy to explain tomorrow, if nobody else does…  see you =)
10:20:40 <cocreature> Alovenom: the exact error might also be helpful. you might be misinterpreting the error message
10:20:46 <Alovenom> ok I think it will work - but it's breaking my windows installation now
10:21:10 <Alovenom> stack used to be supremely comfortable, I could just switch OS and it would work the same 
10:21:10 <cocreature> huh? I thought you’re on arch
10:21:28 <Alovenom> cocreature: I'm dual booting. I'll go on arch and tell you how it goes.
10:21:51 <lyxia> Why do we say that "DataKinds creates a new kind" instead of saying "DataKinds makes every type a kind"?
10:24:10 <AloeVenom> back, trying to compile now
10:25:27 <AloeVenom> hahaha
10:25:47 <AloeVenom> it works ! I no longer have the old error
10:25:48 <AloeVenom> which was btx
10:26:37 <AloeVenom> http://lpaste.net/57698290006753280
10:26:55 <AloeVenom> but now I have another error. hahaha.
10:27:02 <AloeVenom> thanks for your help cocreature, much appreciated
10:27:57 <AloeVenom> I prefer arch over windows to compile because I can just compile for arch, win64 and win32 with wine from the same workspace
10:29:18 <AloeVenom> the error is in bytes now..
10:29:29 <dolio> lyxia: It doesn't make every type a kind, I think.
10:29:46 <dolio> And there can be discrepancies between the type and the kind.
10:34:36 <jared-w> lyxia: Probably because DataKinds makes a new kind :p
10:36:20 <jared-w> the kind Vec :: Nat -> * -> * is different than the kind Vec :: Silly -> * -> *
10:47:37 <knupfer> erisco: new release, a lot of fixes and some perf improvements (upto 500 times faster than blaze when everything is known at compile time)!
10:49:17 <AloeVenom> https://pastebin.com/uVpwBrh8
10:49:36 <AloeVenom> I cri
10:53:17 <cocreature> AloeVenom: do you have libtinfo installed?
10:54:25 <AloeVenom> nope
10:54:51 <AloeVenom> ..wait
10:55:40 <AloeVenom> no, I don't.
10:56:10 <cocreature> AloeVenom: it’s an AUR package so make sure you’re checking with pacman -Q libtinfo and not pacman -S libtinfo
10:56:28 <AloeVenom> yeah that's why I held on a sec ^^
10:56:42 <cocreature> do you have ncurses5-compat-libs installed?
10:57:15 <AloeVenom> no !
10:57:44 <cocreature> hm no idea then, I have seen similar problems with the GHC bindist stack chooses if you install libtinfo but without that things seem to work
10:58:00 <AloeVenom> aw, shucks
10:58:05 <AloeVenom> thanks for the help!
10:58:08 <cocreature> wait, how did you install ghc?
10:58:13 <AloeVenom> stack
10:58:15 <cocreature> it doesn’t seem to use the one stack installed
10:58:20 <cocreature> it uses one in /usr/local/…
10:58:25 <AloeVenom> Oo
10:58:29 <AloeVenom> did I 
10:58:35 <AloeVenom> ..
10:58:45 <AloeVenom> I sure feel dumb, one sec
11:01:09 <AloeVenom> yeah
11:01:17 <AloeVenom> thanks for catching that
11:01:27 <int-e> (to me it looks as if that particular ghc doesn't pass -no-pie to gcc when linking.)
11:01:31 <AloeVenom> downloading external verson now
11:01:43 <AloeVenom> yeah it's downloading "ghc-nopie" now
11:01:53 <AloeVenom> x)
11:04:11 <erisco> knupfer, well done
11:04:25 <texasmynsted> I am not sure the best approach for the following.  I have a markdown file, written as a pandoc source.  I want to read the file and return either the title defined from a YAML header 
11:04:47 <texasmynsted> or the first part of the filename, if the YAML header does not exist, or does not contain the title.
11:05:07 <texasmynsted> I know there are a few YAML libs.  There is also a pandoc lib...
11:05:47 <jle`> texasmynsted: the most robust way wouild probably be just to use pandoc
11:05:58 <jle`> pandoc represents documents as an ADT
11:05:59 <texasmynsted> the pandoc lib?
11:06:15 <texasmynsted> i.e. https://hackage.haskell.org/package/pandoc
11:06:28 <jle`> yeah the pandoc lib, and pandoc-types
11:06:30 <jle`> mhm
11:06:43 <jle`> 'pandoc' has the parsers
11:06:49 <jle`> 'pandoc-types' defines the document ADT
11:07:01 <cocreature> depends on how specific your markdown is to pandoc. pandoc can be a bit annoying if you only care about a specific format
11:07:33 <jle`> data Pandoc = Pandoc (Map String MetaValue) [Block]
11:07:44 <jle`> so your 'title' would be in the 'Map String MetaValue'
11:08:21 <jle`> indeed i am only recommending the library because 'a pandoc source' was explicitly specified
11:08:51 <texasmynsted> yes.  These are file that will be later converted using pandoc.
11:08:53 <jle`> so there might be pandoc-isms like metavalues scattered around the document, or in % header blocks
11:09:17 <jle`> so the best way to robustly catch all of the pandoc-accessable meta values is using the pandoc library
11:09:30 <jle`> (pandoc lets you specify titles anywhere in the document)
11:09:32 <texasmynsted> ah.  yes.  This makes sense
11:09:35 <jle`> s/titles/the title
11:09:52 <cocreature> yeah if you need pandoc, use the lib
11:09:55 <texasmynsted> eeuuu.  I did not know that about the title being anywhere in the doc
11:09:58 <Tuplanolla> How do you tell Pandoc to grab the title from the first header?
11:10:33 <jle`> you can even give a title from the command line
11:10:41 <jle`> or an external file
11:11:04 <jle`> well, pandoc treats all metadata as a 'Map String MetaValue', and title is just one normal metadata that goes into that map
11:11:22 <jle`> but you can provide arbitrary key/value pairs through the commandline or in inline yaml metadata blocks
11:12:30 <jle`> it's kind of nice because 'title' is not a special-case thing
11:12:39 <texasmynsted> ok, so yes, in this case I surely would want to use pandoc to find the title.
11:14:25 <mniip> does lens define an operator for foldr?
11:15:09 <jle`> mniip: i usually just ctrl+f http://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Operators.html
11:15:54 <jle`> in this case i think no
11:16:18 <jle`> there are only like three categories of lens operators anyway i think
11:17:42 <jared-w> What kinda operator would you want anyway?
11:17:52 <jared-w> (just curious)
11:20:55 <texasmynsted> thanks again jle` 
11:22:50 <Tuplanolla> I wonder what I should tell a student who used 93 lines to define `foldl` correctly.
11:23:04 <srhb> Tuplanolla: "A bit verbose"
11:25:01 <[exa]> Tuplanolla: does it work?
11:25:06 <Tuplanolla> Yes, [exa].
11:25:14 <[exa]> damn, tricky situation
11:25:19 <fresheyeball> anyone know a way to `MonadBaseControl IO m -> MonadIO m` ?
11:25:46 <kadoban> Tuplanolla: How did they use 93 lines to define foldl?
11:27:09 <jle`> fresheyeball: what do you really mean
11:27:11 <Tuplanolla> She defined `data F a b = F {f :: (b -> a -> b), x :: Either b (Either (b -> b) a)}` and `data T a b = T {t :: Maybe (F a b)}` and made `T a b` a `Monoid` and wrote a massive case statement and it's all downhill from there, kadoban.
11:27:13 <jle`> cause that's a kind error
11:27:17 <jle`> that's not a valid thing
11:27:42 <jle`> do you mean (MonadBaseControl IO m, MonadIO n) => m a -> n a    ...?
11:28:11 <kadoban> Tuplanolla: That sounds interesting. Maybe it was a joke or she was bored? Sounds a bit hard to accidentally do.
11:28:32 <jle`> sounds like something from 'evolution of a haskell programmer'
11:28:36 <Tuplanolla> I'll have to ask.
11:29:44 <Psybur> Anybody ever have "stack solver" just fail?  error, called at src/Stack\Solver.hs:187:16 in stack-1.5.1-6vAgdEAY6cq2iNQCmZsucn:Stack.Solver
11:29:51 <Psybur> Cant find anything on giggle
11:30:26 <kadoban> Psybur: What's 'stack --version' say?
11:30:38 <Psybur> Version 1.5.1, Git revision 600c1f01435a10d127938709556c1682ecfd694e x86_64 hpack-0.17.1
11:30:57 <kadoban> Let's see what's on that line ...
11:32:15 <kadoban> Psybur: Something about being able to parse the output from cabal-install. Is your cabal-install version interesting in any way?
11:32:46 <kadoban> Psybur: Is there more to the message too? It looks like there should be a list of lines it couldn't make sense of
11:33:34 <Psybur> Im seeing this, maybe need to try downgrading
11:33:34 <Psybur> Warning: Installed version of cabal-install (2.0.0.0) is newer than stack has been tested with.  If you run into difficulties, consider downgrading.
11:33:44 <texasmynsted> I am totally blown away by this slideshow heheh http://www.johnmacfarlane.net/BayHac2014/#/readers-and-writers
11:33:48 <texasmynsted> ooops
11:33:56 <texasmynsted> I mean http://www.johnmacfarlane.net/BayHac2014
11:34:12 <texasmynsted> Just found this
11:34:19 <kadoban> Psybur: Hm. You might want to make a bug report anyway if you have a minute? It's possible that that's not fixed yet https://github.com/commercialhaskell/stack/issues
11:40:38 <Psybur> kadoban, https://github.com/commercialhaskell/stack/issues/3441
11:42:50 <kadoban> Psybur: Does 'stack --verbosity debug solver' output any more at the end there by any chance?
11:43:54 <Psybur> kadoban, doesnt seem to
11:44:11 <jle`> ls
11:48:41 <dmwit> Tuplanolla: Time-intensive answer: figure out how to iteratively simplify their code to the right solution, then do a one-on-one session with them to discuss it. It's probably 2-3 hours to figure out what you plan to present and a solid hour or so for the presentation itself.
11:49:07 <Tuplanolla> Not happening unfortunately, dmwit.
11:49:16 <dmwit> yep, understandable
11:49:26 <Tuplanolla> Maybe fifteen minutes.
11:49:52 <dmwit> At that time investment level, you have little choice but to showcase the correct solution and give a short explanation of it.
11:50:30 <Tuplanolla> I do want to know the thinking that went into it.
11:50:44 <dmwit> Then you need to book more time. =)
11:54:30 <KaneTW> i'm having a problem where my callbacks are on a different ThreadId than my main rendering loop
11:54:43 <KaneTW> and this is causing issues with finding the right opengl context
11:55:13 <dmwit> Yes, you need to make sure all GUI code happens on a single bound thread (usually the main thread).
11:55:22 <maerwald> meh, new Cabal breaks pattern matching
11:55:22 <dmwit> Most GUI libraries include a way to post actions back to that thread for execution.
11:55:26 <maerwald> is that a new thing now?
11:56:58 <dmwit> (Usually GUI libraries want to be in charge of the "main GUI loop", which rules out the usual ways of communicating between Haskell threads, so definitely do look for the library-specific way to send events to the main loop.)
11:57:40 <ggVGc> KaneTW: I've been working with game development quite a lot in the past, and in general you'd always post any form of input(or other async events) to a thread safe queue, then process it as part of the beginning of your frame, or process it in another background thread and have that post it's results to a second thread safe queue which is in turn used at the beginning of a frame
11:57:58 <ggVGc> usually the second scenario is overkill
11:58:38 <caseliang> hello
11:58:50 <caseliang> newbie here
11:59:03 <dmwit> welcome =)
11:59:12 <caseliang> what is this all about?
11:59:29 <ggVGc> type safety
11:59:31 <ggVGc> and procrastination
11:59:32 <ggVGc> mostly
12:00:28 <dmwit> Haskell is a lazy functional language with a strong but silent type system.
12:00:37 <cement> silent?
12:00:42 <dmwit> inference =)
12:01:00 <cocreature> the ghc typechecker can be quite loud :)
12:01:00 <cement> I mean, fighting the type system was like my first year with the language
12:01:18 <dmwit> cement: Yes, isn't it lovely?
12:01:29 <dmwit> All those bugs you never had to discover through confusing and wrong executions!
12:01:29 <cement> it's my favorite part of the language, now
12:01:41 <caseliang> I just got in to a functional program course
12:01:46 <cement> was kinda scary to have GHC yell at me at first
12:01:55 <caseliang> first class in college
12:02:11 <dmwit> As a buddy of mine would say: "Imagine you had a coworker that just sat and wrote hundreds of tests all day. You'd give him a high five, wouldn't you?"
12:02:36 <cement> I'd love to give quickcheck a high five
12:02:55 <dmwit> I was thinking of the type system, but sure, QuickCheck too.
12:03:28 <Psybur> Anybody happen to know of any technical analysis libraries in haskell? Seems like I cant get https://github.com/elsen-trading/talib to work with my other packages D;
12:04:00 <Psybur> Might try forking it and seeing if I can get it to work with latest ghc maybe
12:08:07 <AloeVenom> works like a charm with stack's ghc ofc
12:08:56 <AloeVenom> thanks again cocreature, I guess I was tired !
12:09:18 <cocreature> AloeVenom: yw :)
12:13:08 <maerwald> anyone worked with the new Cabal API?
12:14:53 <rotaerk> in emacs haskell-mode, when I insert a '(', it automatically adds a ')'; any idea how to turn this off?
12:15:25 <cocreature> rotaerk: sounds like you might have turned on electric-pair-mode
12:15:45 <rotaerk> hmm, k; lemme look into that; thanks
12:16:49 <rotaerk> cocreature, nope; it was off
12:17:00 <rotaerk> turning it on and back off didn't change the behavior
12:17:21 <cocreature> rotaerk: what is ( bound to? I don’t have that behavior
12:17:50 <monochrom> Me neither.
12:18:08 <rotaerk> well I'm using the haskell layer of spacemacs; maybe it's turning on something...
12:18:22 <rotaerk> I'll go through the enabled minor modes, and see if it's one of them
12:18:36 <cocreature> rotaerk: check C-h k (
12:18:37 <monochrom> Mine is merely emacs 25.
12:19:04 <cocreature> smartparens or paredit could probably also be responsible
12:20:04 * hackagebot type-of-html 1.0.0.0 – High performance type driven html generation. – https://hackage.haskell.org/package/type-of-html
12:21:24 <maerwald> and robust ghc-mod ofc doesn't build with 8.2.1 
12:22:58 <Subeff> hey guys, how do you write a pointfree predicate that basically compares a number `x` if it is both >1 && <5
12:23:24 <cocreature> @pl \x -> x>1 && x<5
12:23:24 <lambdabot> liftM2 (&&) (> 1) (< 5)
12:23:36 <Subeff> lambdabot you are the man!
12:24:02 <geekosaur> although these days it'd be liftA2 or <*> and <$>. there's probably also something Arrow-y
12:24:36 <cocreature> tbh I’d probably just use a lambda
12:25:25 <lyxia> (<2) . abs . (3-)
12:26:50 <erisco> > map (inRange (1,5)) [0..10]
12:26:53 <lambdabot>  [False,True,True,True,True,True,False,False,False,False,False]
12:27:20 <epta> inRange (1,4) *
12:27:49 <epta> inRange (2,4) **
12:32:58 <Subeff> ok I believe it that lifting(&&) over two bool resulting functions will give back a function that waits, but I still do not understand why does it provide the argument to both the functions at the same time, where is that explained
12:33:53 <geekosaur> it's the Reader Monad/Applicative, essentially
12:34:00 <geekosaur> also known as ((->) e)
12:34:03 <cocreature> Subeff: https://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#line-697 take a look at the miplementation of liftA2
12:35:44 <Subeff> cocreature this was exactly the proof I was looking for, you guys rock <#
12:38:17 <cocreature> Subeff: if you know that liftA2 f x y = f <$> x <*> y you can also construct the behavior of liftA2 based on the implementation of fmap and <*>
12:42:54 <Subeff> but here is what goes in my mind,  here x and y are the applicative structures and they might hold different values, why would you make liftA2 with Reader feed both structures with the same value 
12:43:01 <tsani> oh wow, I didn't even know that liftA2 was baked into Applicative
12:43:28 <cocreature> tsani: I think that might be new in 8.2 or at least 8.0
12:43:52 <tsani> ah
12:44:15 <AloeVenom> why is stack telling me that it cannot satisfy the package ID of .. my current build
12:44:16 <cocreature> Subeff: we are looking at the Applicative instance of ((->) e) i.e. functions with domain e, so in your case x and y are functions with the domain Int (assuming 1 and 5 have type Int)
12:44:22 <AloeVenom> I'm too tired for this now I should sleep
12:44:30 <AloeVenom> but I'd really like to see this working before
12:44:43 <cocreature> Subeff: so you need to take a look at the Applicative and Functor instance of ((->) e)
12:45:28 <AloeVenom> ..works from the terminal, guess leksah is doing something weird
12:45:36 <AloeVenom> i'll look at it tomorrow, good enoug 4 me
12:45:40 <AloeVenom> gnite peeps
12:46:00 <cocreature> Subeff: f <$> x <*> y = (f <$> x) <*> y = (\r -> f (x r)) <*> y = \r -> (\r -> f (x r)) r (y r) = \r -> f (x r) (y r)
12:46:18 <cocreature> I’ve probably screwed up somewhere in there but hopefully you get the idea
12:50:51 <Subeff> cocreature: thank you for breaking it down, will review it carefully
12:53:48 <cocreature> Subeff: I’m going to bed now but I’m sure someone else can help you if you have further questions
12:54:04 <Subeff> :) thank you, I was just discussing
12:54:25 <rotaerk> it *is* smartparens-mode; now to figure out how the heck to prevent the haskell layer from starting it...
12:55:11 <vktec> Is there a function f :: ([a] -> b) -> [a] -> Maybe b whereby f g xs returns Nothing if xs is empty and Just (g xs) otherwise? I kinda want to convert the list monad into the Maybe monad, but don't know if that's possible in a more generic way
12:58:12 <kadoban> vktec: Well, there's "maybeToList"
12:58:15 <kadoban> :t maybeToList
12:58:16 <lambdabot> Maybe a -> [a]
12:58:26 <kadoban> :t listToMaybe
12:58:27 <lambdabot> [a] -> Maybe a
12:58:28 <rotaerk> you can represent any 'Maybe a' as a singleton '[a]', but not all '[a]' can be represented as a 'Maybe a'
12:58:28 <kadoban> Sorry, that one
12:59:17 * vktec tries out listToMaybe
12:59:37 <kadoban> It's not quite what you asked for, but I didn't quite understand part of what you asked for, so maybe it's good enough?
12:59:38 <erisco> vktec,  f :: (a -> [a] -> b) -> [a] -> Maybe b  is more sensible otherwise f does nothing interesting
12:59:50 <vktec> :i listToMaybe
13:00:08 <vktec> Huh. I thought lambdabot did that...
13:00:44 <vktec> erisco: What do you mean by that?
13:01:14 <ski> kadoban : that was my first thought, but i don't think it helps here
13:01:21 <ski>   f g xs = g <$> partial (not . null) xs
13:01:29 <ski> i think that is basically what was asked for
13:01:36 <ski> @hoogle (a -> Bool) -> a -> Maybe a
13:01:36 <lambdabot> Control.Monad.Plus partial :: (a -> Bool) -> a -> Maybe a
13:01:36 <lambdabot> Agda.Utils.Maybe filterMaybe :: (a -> Bool) -> a -> Maybe a
13:01:36 <lambdabot> Agda.Utils.Maybe.Strict filterMaybe :: (a -> Bool) -> a -> Maybe a
13:01:40 <ski> @hoogle+
13:01:40 <lambdabot> Hpp.StringSig predicateJust :: (a -> Bool) -> a -> Maybe a
13:01:40 <lambdabot> System.Console.Wizard ensure :: (a -> Bool) -> a -> Maybe a
13:01:41 <lambdabot> Control.Monad.Plus predicate :: (a -> Maybe a) -> a -> Bool
13:01:45 <Subeff> ok I ended up with the following idea how I thought it was implemented (tell me if I am completely wrong) f <$> x <*> y = ... first part same as cocreature's solution and then = \r' -> (\r -> f (x r)) r (y r') = \r' -> \r -> f (x r) (y r') 
13:01:54 <cog314> The REPL on haskell.org seems to be "down". It appears to have cached some answers eg 2*3 and not others eg 2*10
13:01:59 <ski> but i'm not sure what would be a sensible package to import it from
13:02:05 <kadoban> ski: Hm, right
13:02:18 <ski> one could want it to be in `Data.Maybe', or perhaps `Control.Monad' ?
13:02:39 <sqooq> can I compile for other os's
13:02:43 <sqooq> with my linux os
13:02:48 <erisco> vktec, f is going to match on the list but then not tell g what it learned
13:02:57 <ski> vktec : no `info' command in lambdabot
13:03:24 <erisco> so now g is either partial or has to do matching again
13:03:46 <vktec> erisco: I guess so
13:04:15 <vktec> kadoban: listToMaybe should work fine for my usecase. Thanks
13:04:27 <geekosaur> sqooq, cross compilation is painful at best; usually easier to install the target OS in vbox or etc.
13:07:08 <sqooq> geekosaur: what if my program does nothing crazy at all and I have a user who successfully compiled on windows (though it apparently didn't work right)
13:07:24 <ski> erisco : well .. you can see something similar in e.g. `Foreign.Marshal.maybePeek :: (Ptr a -> IO b) -> Ptr a -> IO (Maybe b)', checking whether the pointer is a null pointer or not
13:07:40 <cog314> help: does anyone know why the haskell.org REPL might be showing such strange behavior?
13:07:41 <sqooq> geekosaur: installing oses in vbox takes forever
13:07:53 <sqooq> then i'd have to get stack too
13:08:05 <ski> vktec : `listToMaybe' drops all but the first list element. it looked like you possibly wanted to retain the other ones as well
13:10:00 <vktec> ski: Yeah, ideally I would, but I can use the original list (by name) from within g
13:11:21 <geekosaur> got nothing to do wth 'crazy' and everything to do with the toolchain being cranky even with a 'hello world' program. if you insist on cross compile, people have managed to do it but I couldn't tell you how.
13:17:26 <Ero> HiGang. Is Control.Monad.Writer still a thing? I'm having trouble using it 
13:19:48 <geekosaur> it's not in base, you need to install mtl
13:20:56 <Ero> Thanks geekosaur. Is there anything in base resembling the writer monad?
13:21:24 <geekosaur> nope
13:21:54 <geekosaur> ghc is not batteries-included, the base contains the minimum necessary for ghc itself.
13:21:58 <lyxia> (,)?
13:22:06 <Ero> thanks geekosaur 
13:22:27 <lyxia> Ero: instance Monoid a => Monad ((,) a) -- Defined in ‘GHC.Base’
13:45:53 <sfogarty> Is there a way to get the (maybe?) last character output to stdout? I need a "soft newline" and don't really want to play with the state monad.
13:47:07 <monochrom> What is "soft newline"?
13:47:18 <AWizzArd> Are Pipe and Conduit used for very similar things?
13:47:47 <sfogarty> A newline if we're not at the start of a line, essentially.
13:48:00 <sfogarty> the right solution is to fold isntead of map, or use a monad.
13:48:04 <sfogarty> I'm hoping there's a hacky IO solution
13:48:54 <geekosaur> there isn't
13:49:30 <dysfun> AWizzArd: loosely, yes
13:50:00 <monochrom> I know right? Use strace to monitor yourself what yourself has sent to stdout...
13:50:55 <sfogarty> okay, strace might be TOO hacky. :)
13:51:15 <AWizzArd> dysfun: what is Pipe good for and what is Conduit good for?
13:51:40 <ski> vktec : hm, ok
13:51:45 <Tuplanolla> You could `LD_PRELOAD` over `write` and access it via ffi, sfogarty.
13:51:56 <dysfun> pipes is simpler, conduit gives more guarantees about resource management
13:53:21 <dysfun> these days, pipes and conduit are fairly similar
13:53:25 <jb55> streaming is even simpler an works with both pipes and conduits
13:54:15 <sfogarty> ...foldM it is :)
13:54:48 <AWizzArd> dysfun: okay, they are converging to some extent.
13:55:13 <dysfun> pretty much
14:10:03 <dsal> I don't think I fully understand `
14:10:14 <dsal> :t elem "abc"
14:10:16 <lambdabot> Foldable t => t [Char] -> Bool
14:10:23 <dsal> :t (`elem` "abc")
14:10:25 <lambdabot> Char -> Bool
14:10:40 <dsal> It seems to flip the parameters.
14:10:52 <rotaerk> what does
14:11:02 <dsal> (elem l) vs (`elem` l)
14:11:17 <rotaerk> `elem` turns elem into an infix operator
14:11:18 <erisco> yes… the latter is a section
14:11:30 <rotaerk> the first parameter goes on the left, the second parameter on the right
14:11:51 <rotaerk> so when you do (`elem` l) you're saying the *right* parameter (the second one) is l
14:11:56 <AWizzArd> Is there a tool that can translate between chaining data via >> or >>= and do-notation and vice versa?
14:12:05 <rotaerk> (x `elem`) would be the same as elem x
14:12:29 <dsal> OK.  It just feels odd that it tosses the left parameter over to the right in that construct.
14:12:33 <ski> @undo do x <- foo; bar x; y <- baz x; quux x y
14:12:33 <lambdabot> foo >>= \ x -> bar x >> baz x >>= \ y -> quux x y
14:12:35 <dsal> I guess I can understand why that makes sense.
14:12:37 <erisco> @undo { x <- a; y <- b; f x y }
14:12:37 <lambdabot> <unknown>.hs:1:1:Parse error: {
14:12:43 <erisco> @undo do { x <- a; y <- b; f x y }
14:12:43 <lambdabot> a >>= \ x -> b >>= \ y -> f x y
14:12:44 <ski> @do foo >>= \ x -> bar x >> baz x >>= \ y -> quux x y
14:12:44 <lambdabot> do { x <- foo; y <- do { bar x; baz x}; quux x y}
14:12:52 <ski> heh
14:13:24 <dsal> rotaerk: Thanks.  I think I kind of see how this is working.  It wasn't obvious to me.
14:13:30 <AWizzArd> Okay nice, the bot can do this.
14:13:44 <ski> `undo' also works for list comprehensions
14:13:57 <AWizzArd> Is this also available in ghci or ghc? Or via some library?
14:14:30 <ski> @undo [(x,y,z) | x <- foo,bar x,let y = f x,z <- baz x y]
14:14:30 <lambdabot> concatMap (\ x -> if bar x then let { y = f x} in concatMap (\ z -> [(x, y, z)]) (baz x y) else []) foo
14:14:34 <dsal> AWizzArd: Most of my conversations lately have been PMs to lambdabot 
14:14:47 <AWizzArd> dsal: :-)
14:15:15 <geekosaur> probably easiest to just use /query windows. you could also build lambdabot locally, and goa still exists although it's bitrotted I think
14:15:21 <geekosaur> afaik there's no separate library
14:15:29 <AWizzArd> I just thought that in principle ghci already understands this, and possibly makes this functionality available somehow.
14:15:38 <geekosaur> although someone could probably pull the relevant plugin out of lb and make it available standalone
14:16:05 <geekosaur> well, there's -ddump-ds but that will also translate a bunch of other things
14:17:06 <AWizzArd> At least one direction should be implemented in ghc. I suppose that at later compilation steps DOs no longer exist.
14:17:17 <geekosaur> and you have to give it a whole program, not a fragment or things with e.g. missing bindings
14:17:30 <dsal> This partially applied infix thing actually makes a lot of sense in use.  (/ 2) vs. (2 /) etc...  I just would've expected it to do something dumber.
14:18:10 <dsal> What's the deal with let bindings and lambdabot?  Does it just get full and restart on occasion?
14:18:22 <ski> dsal : one "corner case" is `(- 2)', which is not a section, but a negated literal
14:18:31 <geekosaur> people have the bad habit of doing @undefine any time someone's alreasy used the name they want
14:18:34 <ski> > map (subtract 2) [0 .. 9]
14:18:36 <lambdabot>  [-2,-1,0,1,2,3,4,5,6,7]
14:18:37 <dsal> Oh, is "section" the word for that/
14:18:46 <geekosaur> it's a shared sandbox dso that wipes the @let for everyone
14:20:34 <dsal> @undefine allthethings
14:20:34 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
14:20:56 <dsal> Oh wow, so that like, does allthethings.
14:21:24 <ski> yep
14:21:25 <geekosaur> @where L.hs
14:21:25 <lambdabot> what lambdabot has in scope is at http://silicon.int-e.eu/lambdabot/State/Pristine.hs
14:22:16 <geekosaur> that's what lambdabot starts with. @let appends to a local copy of that (after validating); restarting lambdabot or running @undefine resets it to the Pristine.hs again
14:23:00 <dsal> And it's just got the one context -- right?
14:23:25 <dsal> i.e.,  I don't get a special namespace in my query session.
14:23:27 <ski> aye
14:23:40 <ski> one person can use things another has defined
14:23:59 <ski> (this can sometimes be helpful, when explaining something)
14:24:02 <geekosaur> 'shared sandbox', as I said
14:25:00 <dsal> Sure.  It's unreasonable for every channe/session to have its own context, I suppose.
14:26:03 <geekosaur> it could be done, not very difficult to set up the basics but then you need logic to clean up abandoned contexts periodically (and then code to block that for specific contexts/sessions...)
14:26:33 <geekosaur> but eventually you probably just want to run your own lambdabot in a private channel or something
14:26:41 <ski> (rudybot in #scheme has separate sandboxes. however there's a command to give a value to another user, which they can then grab)
14:26:52 <dsal> Yeah.  I'd like to run something like this with perhaps more interfaces.
14:27:21 <Tuplanolla> > (How about that?)
14:27:24 <lambdabot>  It sucks.
14:28:45 <geekosaur> if you run  locally then you would have both IRC and a local console. people have tried to add other protocols in the past but it hasn't gone well; lambdabot really needs to be rearchitected
14:29:12 <geekosaur> despite there being an IRC 'plugin', knowledge of IRC (and its speciifc quirks) is spread all over the codebase
14:29:15 <dsal> I could probably use a simple http thing that could define and evaluate code.
14:29:35 <dsal> How do you parse/eval haskell code in haskell?
14:29:58 <geekosaur> http://tryhaskell.org/ ?
14:30:27 <geekosaur> the raw way is via ghc-api. the hint package wraps that. the mueval package is a sandboxed version, and is how lambdabot does it
14:30:29 <dsal> Yeah, but I was thinking about something like a little function server.  No idea what I'd do with such a thing.
14:31:16 <dsal> I like the sandboxing.  If it's safe enough for derelicts on irc, it'd be useful.
14:31:22 <dsal> > sum [1..]
14:31:29 <lambdabot>  mueval-core: Time limit exceeded
14:32:04 <ski> @help run
14:32:04 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
14:32:21 <dsal> Oh nice.
14:32:36 <dsal> I couldn't think of anything exciting in three seconds, though.  :(
14:33:02 <wob> haha
14:33:05 <peddie> dsal: lolol
14:34:03 <dsal> So "let in" doesn't create a binding, right?
14:34:14 <geekosaur> it does
14:34:27 <geekosaur> it also creates a new lexical scope for that binding
14:34:28 <sclv> let x in y binds the variable x in the expression y
14:34:30 <dsal> heh
14:34:34 <sclv> it doesn't extend past y
14:34:48 <geekosaur> it doesn't record to L.hs for future evaluations, if that is what you meant
14:35:00 <Tuplanolla> > let in do Nothing -- Not in the most literal sense, dsal.
14:35:04 <lambdabot>  Nothing
14:35:06 <dsal> do/let is another thing I don't quite understand.
14:35:27 <dsal> Tuplanolla: Ha, I didn't even know you could do that.
14:35:32 <geekosaur> @undo do { let {a = 5}; print a }
14:35:32 <lambdabot> let { a = 5} in print a
14:35:37 * dsal is still quite the haskell noob
14:35:48 <geekosaur> it desugars to a normal let-in
14:35:51 <dsal> Oh wow.  It's like you can ask.
14:36:02 <dsal> Do is still about 40% magic to me.
14:36:24 <geekosaur> play around with @undo and @redo
14:36:35 <geekosaur> it's just a mechanical translation, really
14:36:36 <dsal> Yeah, that looks really helpful.
14:36:40 <Tuplanolla> > do or die -- Haskell has the syntax to do all kinds of stupid tricks, dsal.
14:36:43 <lambdabot>  False
14:37:19 <monochrom> @redo x >>= y
14:37:19 <lambdabot> Maybe you meant: undo todo do
14:37:28 <geekosaur> oh, sigh
14:37:28 <kadoban> :t die
14:37:29 <lambdabot> [a]
14:37:32 <monochrom> @do x >>= y
14:37:32 <lambdabot> do { a <- x; y a}
14:37:46 <dsal> @help todo
14:37:46 <lambdabot> todo. List todo entries
14:38:12 <monochrom> Yado says: Do or undo, no redo there is. :D
14:38:20 <geekosaur> also at some point I should pull back in my old lambdabot help guide and add the parts I didn't have because that bot was running in a channel that didn't care about haskell code
14:38:29 <ski> > [() | let]
14:38:31 <lambdabot>  [()]
14:39:04 <geekosaur> even so it's useful because it's possibly the only documentation for the admin commands...
14:39:27 <wob> ski :o
14:39:41 <ski> that's `let {}'
14:40:15 <wob> still, that's more than
14:40:20 <wob> > [() | _ <- []]
14:40:22 <lambdabot>  []
14:40:49 <wob> @undo do { let; return () }
14:40:49 <lambdabot> <unknown>.hs:1:21:Parse error: }
14:40:51 <ski> the components after `|' can be generators, conditions, and `let'-bindings
14:41:19 <ski> > do let {}; return ()  :: Maybe ()
14:41:21 <lambdabot>  Just ()
14:41:42 <vktec> Is there a way to mix pointfree and pointful styles in a single function definition? ie. I'd like some equations for my function to take x arguments, and others to take x - 1. I guess that messes up pattern matching though...
14:41:44 <wob> aha.
14:41:48 <monochrom> @undo do { let{}; return () }
14:41:48 <lambdabot> let { } in return ()
14:41:53 <maerwald> programming haskell with your editor plugins not working: 50 types in one block of code, no way to check them... look them up on clunky hackage docs :>
14:41:55 <maerwald> a bliss
14:41:56 <ski> (answering your question in the affirmative. in your query, the `}' was inserted in the wrong place)
14:42:01 <kadoban> vktec: Unfortunately not
14:42:05 <geekosaur> oh, feh, they turned off access. have to dig out my backup
14:42:44 <erisco> vktec, I don't understand… what is an example of how you would mix these styles?
14:42:51 <vktec> kadoban: Okay. At least I sorta understand why
14:43:03 <Tuplanolla> > ( {- Here's another fun -} ) { {- consequence of the odd syntax. -} }
14:43:05 <lambdabot>  ()
14:43:26 <dsal> erisco:     f :: String -> Char  ;  f [] = 'x'   ;   f = tail
14:43:53 <erisco> dsal, wrong person?
14:44:10 <dsal> Er, s/tail/head/  --  I had a similar problem as vktec today.
14:44:10 <vktec> erisco: Some equations of my function just match the first argument and pass the rest on to another function. Others handle all of them
14:44:21 <monochrom> erisco: dsal means this is an example of what vktec means.
14:44:52 <geekosaur> vktec, there's a note somewhere in the ghc docs that this is not supported and would be painful to add for various reasons
14:44:54 <monochrom> But anyway this is disallowed.
14:45:04 <vktec> Yeah, I can understand that
14:45:10 <vktec> It makes sense
14:45:35 <dsal> I don't understand enough to understand it.  :)
14:45:44 <dsal> I get "painful to add for various reasons" as a valid reason.
14:46:04 <erisco> maybe you need more pointfree
14:46:40 <vktec> dsal: I'm guessing it would add significant complications to pattern matching
14:46:51 <vktec> Someone else can probably explain in more detail though
14:47:16 <dsal> As someone not doing any implementations of haskell, I don't see how this could be an issue and demand others get on it.
14:47:26 <vktec> Haha
14:47:33 <geekosaur> keep in mind that multiple definitions desugar to a single one using case
14:47:54 <vktec> Ahh, of course. I'd forgotten that
14:47:58 <geekosaur> and that would mean some of your equations need to be eta-expanded as part of that --- but this can alter strictness
14:48:33 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/bugs.html#expressions-and-patterns discusses that in a slightly different context
14:50:14 <geekosaur> so this really does have a number of traps hidden in it
14:53:20 <ski> `case x of <pat0> -> (case y of <pat2> -> <expr0>; <pat3> -> <expr1>); <pat1> -> (case y of <pat2> -> <expr2>; <pat3> -> <expr3>)' need not be the same as `case (x,y) of (<pat0>,<pat2>) -> <expr0>; (<pat0>,<pat3>) -> <expr1>; (<pat1>,<pat2>) -> <expr2>; (<pat1>,<pat3>) -> <expr3>', i think
14:54:56 <erisco> TL;DR
14:56:01 <ski> it's a case of factoring
15:03:34 <rotaerk> hmm do people make use of data types a la carte very much?
15:05:55 <hexagoxel> why isn't the expected kind mentioned for holes in types just like type is mentioned for value-level holes?
15:05:55 <monochrom> GHC.Generics does. :)
15:06:58 <hexagoxel> or is there some magic ghc flag to enable this?
15:09:16 <geekosaur> -fprint-explicit-kinds ?
15:10:01 <hexagoxel> (i guess for kind signatures the same would not make too much sense :)
15:16:46 <hexagoxel> geekosaur: you sure it does this?
15:17:19 <geekosaur> no, I was suggesting it as a possibility. aside from maybe that I don't know of any other way; might be worth a trac ticket
15:19:26 <hexagoxel> ah, right. i'll make a ticket.
15:20:26 * hackagebot graphite 0.3.0.0 – Graphs and networks library – https://hackage.haskell.org/package/graphite
15:32:11 <rotaerk> anyone have any advice for boilerplate elimination here?  https://github.com/Rotaerk/iircc/blob/master/src/common/Network/IIRCC.hs
15:32:47 <rotaerk> hmm ignore the fact that I've mismatched my tag numbers in some of the functions...
15:35:25 <rotaerk> I'm using 0MQ, and I intend to put a "header" for each message into an envelope, followed by the payload; in this case the header will encode the DSum tag, and the payload will encode the DSum value
15:35:45 <rotaerk> so when I enncode an event, I get two encodings... one for the header, one for the payload
15:36:05 <rotaerk> that's also why I have Decoder s (Decoder s BlahEvent)
15:36:20 * Unicorn_Princess waves at rotaerk
15:36:31 * rotaerk waves back.
15:37:05 <rotaerk> and then the event filters are intended to represent prefixes of headers, to be used in 0MQ's subscription filtering mechanism...
15:37:29 <lyxia> rotaerk: what is :=>
15:38:10 <rotaerk> :=> is the DSum constructor
15:38:24 <lyxia> ok
15:40:44 <rotaerk> oh and I append encodeNull in a lot of places not because deserializing would be ambiguous without it, but because I want my filters to be able to fully match a section of the header, and the null indicates that section is complete
15:49:15 <lyxia> I don't have a neat way to merge encode and decode here
15:49:39 <lyxia> But there's probably something to be done about encode*Event and encode*EventFilter
15:50:52 <rotaerk> I made the tag types take a functor parameter just so that I could reuse them for both the filter and the actual header
15:51:15 <rotaerk> but given all the "Identity" constructors I have to specify... wondering if it's even worth it
15:51:45 <rotaerk> I can, afterall, just split it into two types that are structured very similarly, but then I have two types to modify for every new event
15:52:07 <rotaerk> and easy to fail to keep them in sync
15:53:03 <lyxia> indeed
15:53:47 <rotaerk> brb food
16:07:27 <lyxia> rotaerk: http://lpaste.net/358548
16:16:07 <rotaerk> lyxia, interesting; lemme try to adapt that to mine
16:19:46 * hackagebot ghc-syb-utils 0.2.3.3 – Scrap Your Boilerplate utilities for the GHC API. – https://hackage.haskell.org/package/ghc-syb-utils
16:27:02 <lyxia> I wonder whether we can write a bidirectional encoder/decoder for such GADTs with sufficiently dependent types
16:35:33 <rotaerk> of course, I'm doing the encoding/decoding a bit unconventionally...
16:35:47 <rotaerk> since most encoding just result in a single serial output
16:36:01 <mikeplus32> anyone know how to start ghci with a custom .ghci? like, the flag for ghci --ghcirc=foobar
16:36:55 <hpc> now i want an easter egg where you can replace '--ghcirc' with '#ghc'
16:37:41 <mikeplus32> good thinking :p
16:39:27 <koz_> What do I need to do to be able to write constraint synonyms? Like, instead of having (TypeClassA a, TypeClassA b, TypeClassC m, SomeUnfriendlyMonad m2) everywhere, I could have a synonym like 'myFriendlyConstraints = ...'.
16:39:39 <hydraz> {-# LANGUAGE ConstraintKinds #-}
16:39:57 <hydraz> then you can write type Foo a = ( Show a, Read a, Ord a, ... )
16:39:58 <koz_> hydraz: And then I can just use 'type FriendlyConstraints = ...'?
16:40:01 <koz_> Oh, thanks!
16:40:31 <MarcelineVQ> mikeplus32: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#the-ghci-and-haskeline-files
16:41:00 <MarcelineVQ> mikeplus32: more directly it's -ghci-script but that whole section is useful
16:41:58 <MarcelineVQ> I wonder if you can specify -ignore-dot-ghci and then -ghci-script to override .ghci files
16:42:42 <pacak> mikeplus32: Overriding $HOME will allow you to use .ghci  from a different folder, but that's about it.
16:45:42 <orion> ocharles: Hi, two questions: 1. Is logging-effects at all related to extensible-effects or the ideas there of by Oleg? 2. What do I do if I want to use logging in a callback of type (Blah -> IO ()) as in the amqp package?
16:49:54 <rotaerk> lyxia, hmm, in your encodeSessionEvent, I don't believe that'll compile because in that context, the type of 'v' is a, which isn't known to be an instance of Serialise
16:50:48 <rotaerk> though that might be solvable if I could say that the a in 'data SessionEventTag f a' must be an instance of Serialise
16:52:12 <rotaerk> looks like DatatypeContexts can't be used on a GADT
16:54:24 <rotaerk> hmm yea I don't see any way to get a common interface for the phantom type of all the GADT constructors
17:03:59 <lyxia> rotaerk: ? the snippet I pasted compiles
17:04:34 <rotaerk> hmm
17:04:56 <lyxia> the trick is that the constraint is handled by the encodeSessionEventTag function
17:06:21 <rotaerk> how is (Encodable a => Word8 -> r) any different from (Word8 -> r)?
17:06:33 <rotaerk> since a doesn't appear in the signature following the constraint
17:08:28 <lyxia> rotaerk: encodeSessionEventTag is providing the context to the function
17:09:22 <lyxia> rotaerk: If you think of type class constraints as implicit arguments, the difference is that of   forall r. (X -> r) -> r   vs.   X -> r -> r
17:11:00 <rotaerk> hmm, yea mine compiles now
17:12:11 <rotaerk> still don't quite get it, but that's interesting...
17:13:18 <rotaerk> it's like, that constraint is telling the function some information about a type that that function MIGHT want to pull in from elsewhere
17:19:56 * hackagebot graphite 0.4.0.0 – Graphs and networks library – https://hackage.haskell.org/package/graphite
17:20:22 <rotaerk> anyway, thanks lyxia 
17:21:19 <lyxia> rotaerk: you're welcome
17:22:03 <koz_> Is there a function with a signature like Applicative f => (k -> v -> f ()) -> HashMap k v -> f ()?
17:22:36 <koz_> The closest I could find is traverseWithKey, but that does too much.
17:24:22 <rotaerk> koz_, https://hackage.haskell.org/package/unordered-containers-0.2.8.0/docs/Data-HashMap-Lazy.html#v:foldrWithKey
17:24:25 <rotaerk> what about that?
17:24:48 <rotaerk> or foldlWithKey' above it
17:25:31 <Gurkenglas> koz_, comfortable with lens? http://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Indexed.html#v:itraverse_
17:25:46 <koz_> Gurkenglas: I am comfortable with lens, but that's a huge dep to drag in just for that, lol.
17:25:57 <koz_> rotaerk: I'm not sure how either of those can help me.
17:26:52 <koz_> Oh well, guess I'll have to do it the daft way, and probably send unordered-containers a patch for obvious functionality.
17:27:10 <rotaerk> koz_, well, in those functions 'a' would be 'f ()'
17:27:28 <Gurkenglas> itraverse_ for HashMaps just uses traverseWithKey anyway
17:27:51 <koz_> rotaerk: foldlWithKey' wouldn't match that signature.
17:27:59 <koz_> Gurkenglas: Definitely patch time.
17:28:08 <koz_> I'm sure they'll be happy, and I'm happy writing Haskell.
17:28:19 <rotaerk> it doesn't match it exactly, but it's close
17:28:20 <koz_> (generating some data for an assignment for my <s>victims</s>students)
17:28:25 <Gurkenglas> koz_, but what do you mean by it doing too much? Wouldn't lazy evaluation mean that that doesn't matter?
17:29:09 <koz_> Gurkenglas: If I use traverseWithKey, I'd end up with an f (HashMap k ()), right?
17:29:24 <koz_> Are you saying it wouldn't bother constructing it?
17:29:41 <Gurkenglas> Yep. And if you then fmap (const ()) over that it never ends up in memory in the first place
17:29:54 <koz_> Gurkenglas: Would void do the same?
17:30:05 <hydraz> void is just (() <$)
17:30:09 <rotaerk> yourFunction f = foldrWithKey (\k v a -> a *> (f k v))
17:30:12 <Gurkenglas> void is fmap (const ()) :D
17:30:21 <hydraz> Gurkenglas: fmap . const is (<$)
17:30:21 <koz_> Yep, that makes sense. Thanks Gurkenglas - I keep forgetting Haskell is teh lazies.
17:31:13 <pacak> @src void
17:31:13 <lambdabot> void = fmap (const ())
17:31:23 <hydraz> hey, that's wrong
17:31:25 <hydraz> http://hackage.haskell.org/package/base-4.10.0.0/docs/src/Data.Functor.html#void
17:31:34 <pacak> @src (<$)
17:31:34 <lambdabot> (<$) = (<$>) . const
17:31:35 <Gurkenglas> I suppose there'd be a cycle wasted on each recursive step of traverseWithKey, in order to discard the "... <$>" part
17:31:57 <koz_> Gurkenglas: It's not nearly as bad as I thought though.
17:32:14 <koz_> I thought it'd actually build up a HashMap k () and then chuck it.
17:33:00 <Gurkenglas> Even strict data structures aren't evaluated if you discard them as a whole
17:35:20 <lyxia> It's the (f :: * -> *) wrapper that needs to be strict in its contents, it rarely is.
18:00:36 <koz_> What's an easy way to turn an Int into a hex string?
18:00:57 <koz_> (well, a hex Text would be better)
18:01:43 <Axman6> > showIntAtBase intToDigit 16 255
18:01:46 <lambdabot>  error:
18:01:46 <lambdabot>      • No instance for (Integral (Int -> Char))
18:01:46 <lambdabot>          arising from a use of ‘showIntAtBase’
18:01:54 <c_wraith> :t showAtBase
18:01:54 <Axman6> > showIntAtBase 16 intToDigit 255
18:01:56 <lambdabot> error:
18:01:56 <lambdabot>     • Variable not in scope: showAtBase
18:01:56 <lambdabot>     • Perhaps you meant ‘showIntAtBase’ (imported from Numeric)
18:01:56 <lambdabot>  <[Char] -> [Char]>
18:01:58 <geekosaur> > Numeric.showHex 255 ""
18:02:01 <lambdabot>  "ff"
18:02:02 <Axman6> > showIntAtBase 16 intToDigit 255 ""
18:02:04 <lambdabot>  "ff"
18:02:34 <geekosaur> (the trailing "" is because both of those produce ShowS)
18:02:49 <koz_> Thanks everyone!
18:03:10 <c_wraith> I always forget there's an Int in that name
18:03:35 <mach> has anyone gotten flycheck and inferior-haskell wor work with nix?
18:03:39 <c_wraith> oh hey, there's also showHex
18:03:59 <mach> * to
18:42:52 <quazimodo> hi all
18:43:27 <quazimodo> It's been a while since I've dabbled with haskell, i _vaguely_ remember htere being some issue with cabal and dependency hell, though it could be my imagination
18:43:40 <quazimodo> is htere a preferred way to manage haskell and package versions/bundling ?
18:44:33 <quazimodo> also will someone hold my hand as I try to script something
18:45:14 <quazimodo> and by hold my hand i mean kick me till i get my game together
18:47:05 <plugin> There’s probably a simple solution for this (but I can’t seem to see it):  Acclerate encodes array shapes by using the constructors `Z` and  `:.` as a snoc:  ```Z :. 3 :. 2 :.4```  This would represent a 3 x 2 x 4 array.  I would like to map a list of integers to it’s equivalent shape but I can’t get GHC to give me the go-ahead on the types.  Could someone give me a prod?
19:06:45 <orion> If a transformer is a valid instance of MonadBaseControl, is it safe to assume it is automatically a valid instance of MonadTransControl?
19:20:14 * hackagebot hjsonpointer 1.3.0 – JSON Pointer library – https://hackage.haskell.org/package/hjsonpointer
19:27:17 <quazimodo> hrm
19:27:34 <quazimodo> if i want to join "foo bar" ++ getArgs and am using {-# LANGUAGE OverloadedStrings #-}
19:27:56 <quazimodo> then I'll have an issue with Text, [String] types won't I
19:29:52 <pacak> quazimodo: Hmm... Seems odd. Show full code?
19:30:04 <pacak> Or at least a bit more code with full error message?
19:30:34 <quazimodo> pacak: sure, i'll gist it up
19:31:07 <quazimodo> https://gist.github.com/5d037b0d27d7e0da883b7d92fe04b599
19:31:18 <quazimodo> basically just trying to create a shell script 
19:32:08 <pacak> And the error message?
19:32:26 <quazimodo> sorry, just updating now
19:33:31 <quazimodo> updated :)
19:34:14 <pacak> inproc seems like a monadic value
19:34:31 <quazimodo> yes, it surely must be
19:34:35 <pacak> put =<< between stdout and ( ?
19:34:57 <quazimodo> i think stdout is built to take what inproc put sout
19:35:11 <quazimodo> as in in other examples, stdout (inproc...) works
19:35:12 <pacak> Hmm..
19:35:19 <pacak> intercalate is not a monadic value
19:35:20 <pacak> so
19:35:31 <pacak> let argString = intercalate " " args
19:35:54 <pacak> or
19:35:54 <pacak> argString <-  intercalate " " <$> getArgs
19:39:06 <quazimodo> ok so if we use <- it's for monadic values 
19:39:12 <quazimodo> i didn't know that
19:40:43 <quazimodo> intercalate " " <$> getArgs this one i'm not certain of, though I think you're applying intercalate to the monadic value and so it returns a monadic value with intercalate applied via the monadic rules, yes?
19:40:54 <quazimodo> so we need to "unwrap" with <-, eh?
19:41:46 <vaibhavsagar> yes, what happens if you try that
19:42:28 <quazimodo> i'll updat ethi gs
19:42:56 <quazimodo> I think the ++ bit is broken 
19:43:57 <vaibhavsagar> I think you're trying to add Text to String
19:44:12 <quazimodo> yeah, certainly it's ++, so maybe i've messed up by assuming "foo" ++ (pack argString) is sensible
19:44:35 <vaibhavsagar> so OverloadedStrings doesn't mean that you can add different types of strings together
19:44:56 <quazimodo> vaibhavsagar: isn't pack String -> Text
19:44:59 <Welkin> it means that a string literal isn't necessarily a String
19:45:03 <vaibhavsagar> it only means that you can use the string literal syntax "blah" to be different string types
19:45:11 <vaibhavsagar> what Welkin said :)
19:45:35 <vaibhavsagar> also ++ is for adding lists
19:45:37 <Welkin> when using OverloadedStrings, it better to use <> instead of ++
19:45:41 <vaibhavsagar> and Text is not a list
19:45:49 <quazimodo> Oh!
19:45:51 <quazimodo> you're right
19:45:54 <Welkin> but String, Text, and ByteString all have monoid instances
19:46:10 <quazimodo> i used ++ because i read strings are lists of chars, but obviously this isn't hte case for Text
19:46:21 <quazimodo> string literals, thatis
19:46:49 <quazimodo> yaaay it works
19:46:52 <quazimodo> <#
19:46:55 <vaibhavsagar> \o/
19:46:58 <quazimodo> <3 actually
19:47:04 <vaibhavsagar> I love when things work
19:47:27 <quazimodo> haskell's gonna take some time. I'll struggle with domain knowledge more that concept i reckon
19:47:38 <vaibhavsagar> there's a lot of both
19:47:49 <vaibhavsagar> and the distinction is fuzzy
19:48:17 <vaibhavsagar> but that's what #haskell and #haskell-beginners are for :)
19:48:44 <quazimodo> time to join the latter
19:49:08 <rotaerk> http://lpaste.net/358550  is there anyway to avoid the repetition in the implementation of encodeSessionEvent, there?
19:49:19 <rotaerk> any way *
19:49:59 <rotaerk> encode requires v's type to be an instance of Serialise
19:50:05 <Akaz> wheres gwern
19:55:27 <rotaerk> actually, nevermind; I think I got it
19:56:22 <rotaerk> or not..
19:56:41 <digitalkiwi> nope too late you already got it can't go back now
19:58:43 <rotaerk> :P
20:00:27 <rotaerk> nope, don't think I can avoid it...
20:20:24 * hackagebot servant-snap 0.8 – A family of combinators for defining webservices APIs and serving them – https://hackage.haskell.org/package/servant-snap
20:38:03 <lyxia> rotaerk: didn't we already do that earlier
20:44:00 <rotaerk> lyxia, I ran into some issues with what we had before
20:44:44 <rotaerk> restructured things a bit, and ended up with the above problem, which I tried solving in a similar way, but couldn't get that to work
20:46:49 <rotaerk> lyxia, https://github.com/Rotaerk/iircc/blob/master/src/common/Network/IIRCC.hs
20:46:52 <rotaerk> that's what I've got now
20:47:15 <rotaerk> unified the filter and header encoding
20:49:01 <lyxia> I still see the duplication
20:49:33 <rotaerk> well I split out the header encoding and the payload encoding
20:50:25 <rotaerk> but the header and filter are now just encodeClientEventTag, and encodeSessionEventTag
20:52:03 <rotaerk> the problem I ran into with your approach was that the function passed into your encodeSessionEventTag (i.e. Encodable a => Word8 -> r) didn't have enough information to nontrivial constructors
20:52:11 <rotaerk> e.g. FromSession of ClientEventTag
20:52:18 <rotaerk> to implement *
20:52:20 <lyxia> right
20:53:48 <rotaerk> FromChannel will also be a non-trivial one, once I get around to implementing
20:54:37 <lyxia> this case can be added as another parameter of encodeSessionEventTag
20:54:58 <rotaerk> hmm true
20:58:22 <lyxia> It's true that it doesn't scale if your constructors vary too much.
20:58:59 <rotaerk> so far they're the exception rather than the rule; I'm not sure how it'll look once I flesh it out with more events
21:08:59 <mibaz_1> Is there a type level "tostring" of some sort? Want a string literal of a type parameter in a data constructor
21:10:07 <c_wraith> of a *type* parameter?
21:10:48 <c_wraith> > show $ typeOf ("Hello")
21:10:51 <lambdabot>  "[Char]"
21:11:15 <mibaz_1> c_wraith: Yes a type parameter
21:11:34 <mibaz_1> left of the equals in a data declaration
21:11:43 <c_wraith> it requires a Typeable constraint to get a TypeRep, but you can do it
21:12:01 <mibaz_1> c_wraith: So it's possible but I have to implement it?
21:12:18 <c_wraith> assuming you're on a recent-enough GHC, all types implement Typeable automatically
21:12:25 <c_wraith> But you need to specify the constraint to use it
21:12:39 <c_wraith> (Otherwise very bad violations of parametricity, etc)
21:12:47 <mibaz_1> Oh I see what you're saying. Sec lemme try
21:12:57 <dysfigured> without spoiling the answer for me, can i do fizzbuzz in haskell with just a list comprehension?
21:13:54 <c_wraith> dysfigured: well..  technically "no", because you need some sort of branching expression - but the whole thing could easily be crammed inside a list comprehension
21:14:54 <c_wraith> dysfigured: so I think the answer to the question you mean is "yes"
21:15:22 <dysfigured> hm. neat. will try.
21:24:29 <dysfigured> damn i'm failing at basic if else *goes back to reading*
21:26:17 <dysfigured> oh damn i thought this was haskell-beginners sorry
21:26:37 <iqubic> Feel free to ask simple questions here dysfigured.
21:27:07 <dysfigured> ok. wellp. how come up this doesn't work?
21:27:12 <dysfigured> > x = 9; if x `mod` 15 == 0 "FizzBuzz" else if x `mod` 3 == 0 "Fizz" else if x `mod` 5 == 0 "Buzz" else x
21:27:14 <lambdabot>  <hint>:1:3: error:
21:27:14 <lambdabot>      parse error on input ‘=’
21:27:14 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
21:27:28 <dysfigured> oh i need let here? i guess this isn't ghci..
21:27:30 <monochrom> where is your "then"?
21:28:11 * dysfigured slaps forehead
21:31:14 <dysfigured> adding then after the predicate still throws errors..
21:31:27 <dysfigured> >x = 9; if x `mod` 15 == 0 then "FizzBuzz" else if x `mod` 3 == 0 then "Fizz" else if x `mod` 5 == 0 then "Buzz" else x
21:31:39 <dysfigured> i missed a space didn't i..
21:31:48 <iqubic> At the very start.
21:31:53 <dysfigured> > x = 9; if x `mod` 15 == 0 then "FizzBuzz" else if x `mod` 3 == 0 then "Fizz" else if x `mod` 5 == 0 then "Buzz" else x
21:31:55 <lambdabot>  <hint>:1:3: error:
21:31:55 <lambdabot>      parse error on input ‘=’
21:31:55 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
21:32:02 <dysfigured> do i need let here?
21:32:07 <iqubic> Yes.
21:32:22 <iqubic> Let x = 9 in ...
21:32:24 <dysfigured> > let x = 9; if x `mod` 15 == 0 then "FizzBuzz" else if x `mod` 3 == 0 then "Fizz" else if x `mod` 5 == 0 then "Buzz" else x
21:32:26 <lambdabot>  <hint>:1:123: error:
21:32:26 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
21:32:35 <dysfigured> ohh
21:32:41 <iqubic> Replace semicolon with in
21:32:58 <dysfigured> > let x = 9 in if x `mod` 15 == 0 then "FizzBuzz" else if x `mod` 3 == 0 then "Fizz" else if x `mod` 5 == 0 then "Buzz" else x
21:33:01 <lambdabot>  error:
21:33:01 <lambdabot>      • No instance for (Num [Char]) arising from a use of ‘x’
21:33:01 <lambdabot>      • In the expression: x
21:33:09 <dysfigured> yeah that's what i get in ghci
21:33:57 <iqubic> Dysfigured, what is the type of this function?
21:34:22 <iqubic> For a
21:34:38 <dysfigured> i feel like you know the answer to this but you're making me question myself
21:34:59 <iqubic> Look at the then statement.
21:35:06 <iqubic> What is the type of x?
21:35:17 <dysfigured> num
21:35:28 <iqubic> Is that the same as the type being returned from the other branches?
21:35:30 <dysfigured> oh right i'm trying to mix strings with chars
21:35:43 <dysfigured> hm. can i coerce nums to strings?
21:36:34 <dsal> What do you mean by nums? 
21:36:48 <dysfigured> isn't the type of ie  1 2 3 4 5
21:37:00 <c_wraith> Those have a type more like Int or Integer
21:37:13 <c_wraith> But you can convert (not coerce) them to strings.
21:37:16 <c_wraith> > show 5
21:37:18 <lambdabot>  "5"
21:37:26 <dsal> Num is a very restricted type.  You can't do much with it other than add and negate.
21:37:46 <`Guest00000> i have remainder :: F [(N, K)]. how do i name the things with types (F [K], F ()): (remainder_, remainder__) or (remainder__, remainder_) ?
21:37:49 <dsal> If something has a Show instance, you can "show" it.  If your value is an Int or an Integer,  it has a Show instance.
21:38:03 <dysfigured> ah that helps with 'coercing'
21:38:04 <`Guest00000> the second would be consistend with something_ having "return type" ()
21:38:25 <`Guest00000> the first would be consistent with something__ having even less info than something_
21:38:42 <dsal> You can't even compare Nums for equality.  :(
21:38:43 <dysfigured> man, it's the weirdest thing to basically re-learn how to program all over again
21:39:00 <dsal> You should've learned it right the first time.  :P  :)
21:39:07 <rotaerk> that's how I felt when I learned haskell
21:39:11 <dysfigured> hahaha point taken
21:39:28 <dysfigured> i only knew of php and javascript when i first started, or i probably would've
21:40:25 <dsal> I started learning haskell 9-10 years ago, and then did something else before I actually learned anything.  Then started again a couple weeks ago.  Mostly, I'm still learning that I don't know how much stuff I don't know.
21:41:11 <dysfigured> https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/ has been super helpful
21:41:11 <rotaerk> to me, haskell is a rabbit hole, and it's up to you how deep you want to go, and how quickly
21:41:31 <rotaerk> I can't say that about other languages...
21:41:53 <dysfigured> yeah i'm quickly learning how huge (and yeah, deep) the language is
21:41:56 <dsal> Yeah, I "learned" C++ a couple years ago in the sense that I learned a little bit of it and made a program.
21:42:23 <dsal> I think about as many people know C++ as know Haskell.
21:42:25 <pacak> dysfigured: Language is not as huge as you think.
21:42:41 <dysfigured> i'm fairly proficient with javascript, i've been having a lot of fun with ramda, and so i figured i might as well just go balls deep
21:42:45 <Cale> dsal: I think nobody knows C++ and the same can't be said for Haskell.
21:43:01 <rotaerk> the core language of haskell is pretty simple, though it has a lot of extensions
21:43:18 <rotaerk> the depth of the learning is a lot of the concepts built upon it
21:43:49 <dsal> I keep finding new things about the Haskell language that I didn't know.  e.g., the thing with the partially applied infix operators today.  Seemed weird to me, but feels like the right way to do it.
21:44:04 <dsal> And all of the do/let syntax stuff that also seems a bit weird, but the right way to do it.
21:44:33 <pacak> dysfigured: Proficient in javascript? Hmm... Here are 3 expressions, what are they - true/false, and why? null > 0; null == 0; null >= 0;
21:44:35 <dsal> And that thing with the mixed guard/point free pattern matching thing which doesn't sound like the right way to do it, but a reasonable compromise.
21:44:49 <dsal> I've tried hard to know as little javascript as I could while writing stuff in it.
21:45:18 <Cale> dsal: Not sure I know what you're referring to there
21:45:48 <mibaz_1> I swear it took me 3 hours to debug a cartes product in javascript
21:46:07 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
21:46:10 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
21:46:14 <mibaz_1> So I threw a Typeable constraint on my type parameter, but how do I get a type level string out of it now?
21:46:17 <dysfigured> pacak: false true and true, because type coercing is dumb
21:46:36 <dysfigured> although the second should be fixed with ===
21:46:45 <pacak> dysfigured:  false, false and true...
21:46:55 * dysfigured opens repl
21:47:05 <dysfigured> wtf
21:47:06 <c_wraith> mibaz_1: oh.  you wanted a *type*-level string also?  Ooops.  Typeable won't do that.  You'll need a type family, and you'll probably need to create your own.
21:47:24 <mibaz_1> c_wraith: Ah, ok. I suspected we diverged there a little bit.
21:47:26 <dsal> Cale: I was a bit confused by the type of (`elem` "stuff") earlier.  There was also a thing about having a function with multiple definitions where one has params and the other doesn't.  Apparently it's complicated inside.
21:47:30 <c_wraith> mibaz_1: sorry.
21:47:53 <mibaz_1> c_wraith: no my fault
21:48:00 <c_wraith> dsal: oh, the rule where every equation needs the same number of patterns?  I think that rule is a bit silly, too.
21:48:23 <dysfigured> i mean.. this is kind of one of those 'play stupid games win stupid prizes things'.. if you know == does coercion, you should learn to avoid it
21:48:31 <mibaz_1> Honestly I think I'll probably just pass in some strings in the type constructor
21:48:40 <mibaz_1> too much work
21:48:50 <pacak> dysfigured: What about the last one? :)
21:49:17 <`Guest00000> > null == 0
21:49:20 <lambdabot>  error:
21:49:20 <lambdabot>      • No instance for (Eq ([a0] -> Bool)) arising from a use of ‘==’
21:49:20 <lambdabot>          (maybe you haven't applied a function to enough arguments?)
21:49:20 <`Guest00000> :p
21:49:23 <Cale> Here's a little puzzle for the Javascript fans: parseInt(null,n) gives NaN for n = 1 to 23, then it gives 23 for n = 24 to 30, then it gives a bunch of values from 714695 to 1112745 for n = 31 to 36
21:49:31 <dysfigured> honestly i knew that one from memory and i still don't understand it
21:49:32 <Cale> What happened?
21:50:12 <dysfigured> i'm not a "fan" of javascript per se, but i like making web pages, and so stockholm syndrome and such
21:50:16 <c_wraith> Cale: you want me to figure out how parsing floating-point numbers in arbitrary bases goes wrong?  Too many ways for me to count. :)
21:50:40 <c_wraith> nevermind the weak typing portion. :)
21:50:42 <pacak> Cale: null gets converted to string then there's some kind of mess with base and different representation.
21:50:54 <Cale> pacak: yep!
21:51:19 <Cale> The only reason it gives NaN for bases less than 24 is because n can't be parsed.
21:51:25 <pacak> dysfigured: I assume >= is defined via not and <. And null < 0 is also false
21:51:41 * pacak wants browser with haskell
21:51:53 * `Guest00000 wants it too
21:52:10 <Cale> Well, there's GHCJS, but you'll still have to deal with Javascript a *little* sometimes.
21:52:39 <Cale> But mostly these days I get to treat Javascript the same way I treat x86 assembly
21:52:59 <c_wraith> Cale: does GHCJS still basically require GHC 7.10?
21:53:06 <Cale> 8.0.2
21:53:11 <c_wraith> ah, that's better
21:53:28 <pacak> Cale: Well... One of my problems with js is "here, use this boilerplate to create hello-world application, once everything done installing it should take about  800 megabytes on your disk". ghcjs is not helping here much.
21:54:12 <dysfigured> Cale: that you don't have to write it you just compile to it?
21:54:17 <pacak> ocaml with bucklescript looks like a better approach. Generated code is readable.
21:54:24 <pacak> But ocaml.
21:54:49 <Cale> dysfigured: yes
21:55:00 <dysfigured> ocaml seems interesting. aren't they both ML languages?
21:55:12 <dysfigured> probably should've googled that first
21:55:16 <dsal> I used to do a lot of the ocaml
21:55:41 <Cale> dysfigured: The company I work for, Obsidian Systems, builds web and mobile applications in Haskell, and we compile to Javascript for the web and largely the same code to ARM for mobile
21:56:25 <dysfigured> wow that's sweet
21:56:27 <cocreature> c_wraith: luite also said he’s actively working on 8.2 support
21:57:09 <Cale> dysfigured: What's even better is the fact that the frontends and backends can share a bunch of code for data structures and serialisation, so we never have JSON encoding mismatch issues.
21:57:44 <dysfigured> damn that is really awesome
21:59:27 <Cale> It's really nice to be able to start a change on the backend, say, (or more likely in the common data types) and have the compile errors percolate through to the frontend code and tell me basically everything that needs to change.
21:59:32 <dysfigured> i've been doing a bunch of stuff with flow/ts and react+ramda+rxjs and somewhere i stopped and realized i should've just learned haskell
22:00:17 <Cale> Oh, also, our FRP system Reflex is much nicer than all the attempts I've seen at reactive stuff in JS.
22:00:25 <dysfigured> so i hear, yeah
22:00:44 <mibaz_1> I barely used reflex but even I could see how good it was
22:03:05 <Cale> pacak: hello world will probably be on the order of 8MB rather than 800 :)
22:03:21 <dysfigured> but observables have given me a pretty chill intro to monads
22:03:26 <Cale> pacak: and that's before the closure compiler :)
22:03:32 <dysfigured> i *think* i get it anyway
22:03:39 <Axman6> I haven't been convinced by reflex yet (despite havine one of it biggest proponents showing me what it can do). it looked extremely complex to me
22:03:58 <Cale> Axman6: Spider is extremely complex
22:04:01 <pacak> Cale: If you want ghcjs and let's say react - you'll get 808.
22:04:08 <cocreature> Axman6: if you don’t like reflex, you might want to look at miso which is simpler conceptually
22:04:20 <Cale> pacak: Oh, if you include the compiler's size, sure
22:04:34 <Cale> pacak: I was only counting what the compiled app comes to
22:05:00 <Axman6> luckily said person is currently wrinting some blog posts to be turned into a course on reflex, so hopefully that'll help
22:05:01 <pacak> All the crap it ends up downloading.
22:05:14 <Cale> Axman6: Anything in particular that you ran into?
22:05:40 <Cale> Axman6: I'm also quite interested in what we can do to make it easy to use and document it better
22:06:00 <Axman6> I quickly got lost in the examples I saw, and it wasn't clear to me how to build composable things. I could kinda see it, but I really need to play with it to get start to get a hang of it
22:06:08 <dysfigured> Axman6: would it possibly be this? https://blog.qfpl.io/posts/reflex/basics/introduction/
22:06:46 <Cale> Yeah, I think it is one of those things where once you know the basic ideas, it takes a bunch of playing around to really understand how to build stuff.
22:07:18 <Cale> Reflex-DOM also has some rough edges still here and there, I have to admit
22:07:21 <Axman6> dysfigured: yes
22:07:45 <dysfigured> Axman6: hah nice. i saw that on reddit today, was disappointed only in it's brevity
22:07:48 <Axman6> Cale: yeah that was my thinking too, it's not obvious
22:07:54 <Cale> (partly because the DOM is weird)
22:08:32 <c_wraith> I really like the idea of miso.  I should give it a try.
22:09:06 <Cale> Axman6: One general rule of thumb to get you started is that *often* you want reusable components to take Dynamics as arguments, telling them what data to display, and produce Events as results, explaining how the user is interacting with them
22:09:16 <Cale> But this isn't a hard and fast rule
22:09:51 <Cale> If you were to follow that rule in an absolute way, you'd end up with Elm's attempt at FRP architecture, where you have a giant blob of monolithic state at the top level of the app
22:11:22 <Cale> hold/holdDyn/foldDyn (which I'll generally refer to as holds) are the things which turn Events into Behaviors (and Dynamics) and which maintain state / remember the past
22:12:35 <Cale> You'll usually want those to move outward/upward in the application to the point where everything that depends on the given piece of state can see it, but no farther.
22:14:30 <Cale> It's also sometimes nice, in some complex situations, to have a widget which has no user interface functionality, but which just takes a bunch of Events, and produces a bunch of Dynamics (or Behaviors, but if you're using Reflex-DOM, all the stuff that would be Behaviors is instead Dynamic because the DOM API needs to be told when to change things)
22:14:33 <dysfigured> Cale: you dislike that idea of a giant monolithic state blob thing?
22:14:37 <Cale> yeah
22:14:49 <Cale> Because it's antimodular of course
22:14:50 <dysfigured> this tends to be react+redux apps as well
22:15:09 <cocreature> I somehow find it a lot easier to reason about my code if the state is stored in one place instead of being distributed over various parts
22:15:32 <cocreature> but there are definitely downsides
22:15:55 <Cale> cocreature: But taking that to a place where you're storing all kinds of unrelated junk together just because...
22:16:42 <Cale> Not every part of the application necessarily ought to be able to see the state of every other part
22:17:08 <cocreature> Cale: sure, I see your point. then again it also makes implementing things like persisting your state to local storage, logging all changes, time-travelling debuggers, … trivial while you need to work a lot harder to get this if you’re state is distributed
22:17:17 <Cale> Yeah...
22:17:37 <Cale> We have some ideas for doing that on a grand scale with Reflex, by transforming the Reflex implementation :)
22:17:54 <cocreature> it’s a trade-off and I happen to prefer the miso/elm side but I’m definitely not saying that it’s objectively the right solution for everybody
22:18:04 <Cale> In particular, I have a half-implemented version of time travel on a branch
22:19:08 <Cale> (the idea there is, when I get back to it, to be able to use it to implement lockstep synchronized networking for games in a nice way)
22:19:56 <Cale> That t parameter on all the Reflex types will then be justified :)
22:20:43 <xzhu> How do you do the following:
22:20:53 <sqooq> !!!
22:20:59 <sqooq> I had I think an amazing idea
22:21:18 <mibaz_1> Cale: is it deterministic, then?
22:21:23 <xzhu> write a function: carry :: [Int] -> [Int]
22:21:33 <Cale> mibaz_1: Reflex is, yes
22:21:43 <sqooq> Anyone know of pure data, the music language/environment?
22:21:44 <xzhu> carry [1, 2, 3, 10]  ==  [1, 2, 4, 0]
22:21:53 <mibaz_1> Cale: Awesome, I spent some time trying to find an answer to that.
22:22:01 <xzhu> carry [1, 9, 9, 10]  ==  [2, 0, 0, 0]
22:22:19 <mibaz_1> Cale: But is it cross-platform deterministic without having to tweak compilation?
22:22:21 <cocreature> xzhu: I don’t see the pattern, can you explain what this is supposed to do?
22:22:31 <Cale> xzhu: easier if you start with a reversed list
22:22:42 <Cale> cocreature: carry base 10
22:22:48 <cocreature> oh right
22:23:01 <xzhu> so basically  carry $ zipWith (+) xs ys gives you addition
22:23:28 <Cale> mibaz_1: Reflex *itself* ought to be mathematically deterministic. There might be bugs.
22:23:30 <xzhu> sure, let's assume it's reversed already
22:24:06 <Cale> mibaz_1: But it's basically computing pure functions of time / timestamped sequences of values (but more efficiently)
22:24:50 <Cale> mibaz_1: and the notion of time is actually a bit unspecified -- it could really be anything totally ordered
22:24:57 <cocreature> xzhu: you might want to look at mapAccumR
22:25:01 <sqooq> Ok I'll take it nobody knows pure data
22:25:11 <sqooq> Here's my idea: Why don't we make a graphical environment for haskell?
22:25:21 <sqooq> PD has objects that take inputs and give out outputs
22:25:22 <mibaz_1> Cale: My bad, I was referring to floating point error / machine specific things
22:25:30 <sqooq> in the haskell thing, it will always be one output
22:25:37 <mibaz_1> (My question makes less sense now than when I thought of it)
22:25:41 <sqooq> but instead of writing functions with text
22:25:49 <sqooq> you could write them by just connecting boxes together
22:26:14 <mibaz_1> So i guess I mean "does it use floating point arithmetic" which is a stupid question
22:26:25 <sqooq> Going from csound (which is mostly typing sound), to pure data (connecting cables), feels like magnitudes of difference in easibility
22:26:30 <sqooq> and really it's not just music
22:26:35 <boj> sqooq: https://github.com/viskell/viskell
22:26:35 <sqooq> it's mathematical operations and stuff
22:26:47 <sqooq> !!!!!!
22:26:49 <sqooq> !!!!!!!!!!!!!!!!!!!!!1
22:26:58 <Cale> mibaz_1: The operations on these various sorts of "time varying quantities" like Behaviors and Events are such that you never actually refer to particular times.
22:27:08 <sqooq> boj: wow
22:27:13 <sqooq> I'll check that out for sure
22:27:13 <Cale> mibaz_1: and there's no way of knowing if time is discrete or continuous
22:27:28 <Cale> mibaz_1: It could be the real numbers :)
22:27:43 <boj> sqooq: i also recall seeing this when it came up before http://www.luna-lang.org/
22:27:48 <sqooq> hmm, it's not actually haskell though ?
22:27:53 <sqooq> it's haskell based but
22:27:56 <sqooq> is it as powerful
22:27:57 <cocreature> > carry [1,2,3,10] -- xzhu
22:27:58 <sqooq> is it pure?
22:28:00 <lambdabot>  [1,2,4,0]
22:28:22 <boj> sqooq: i have no idea, never looked deeply into them
22:28:32 <mibaz_1> Cale: Wow that's interesting. So if you impolemented an integer representation of time (a game tick maybe) it would all be discrete?
22:28:39 <Cale> But in the actual implementation, there aren't presently good ways to create Behaviors which *really* change continuously -- you just can't tell that they aren't.
22:29:29 <Cale> Yeah, from the reflex host's point of view, all that matters is what happens at the discrete moments in time when Events are occurring.
22:29:46 <c_wraith> So..  there's no Behavior that integrates over another Behavior?
22:30:25 <Cale> c_wraith: Yeah, there's no way to measure the amount of time between two occurrences of an Event.
22:30:39 <c_wraith> I always thought that was cute - though rather prone to space leaks
22:30:45 <Cale> That is, in *plain* reflex
22:30:53 <c_wraith> In the FRP environments that provide it, that is
22:31:14 <mibaz_1> And Cale, you said that there aren't continuous behaviors (in implementation), correct?
22:31:23 <cocreature> xzhu: I can give you the solution, but I don’t want to spoil the fun if you want to figure it out yourself. mapAccumR should get you a long way
22:31:29 <Cale> You can layer something on top which adds stuff that treats time in a more concrete way, it's just we haven't figured out how to do that kind of thing nearly as well as we can do this.
22:31:53 <Cale> mibaz_1: Not easily with the way the Spider implementation does things
22:32:03 <xzhu> Wait, how do you speak to lambdabot secretly?
22:32:25 <cocreature> xzhu: /query lambdabot should open a window/buffer in most irc clients
22:32:37 <Cale> mibaz_1: It might be possible to add something which lets the host define new primitive behaviours which measure an external source of data at most once per frame, say.
22:32:59 <Cale> mibaz_1: That's just somewhat tricky at the moment.
22:34:00 <Cale> mibaz_1: Tying a Behavior to a real world sensor would be an easy example of something which effectively changes "continuously"
22:34:00 * hackagebot hjsonschema 1.7.0, salve 0.0.8, sized 0.2.1.1
22:34:00 * hackagebot  → https://hackage.haskell.org/packages/recent
22:34:13 <xzhu> cocreature: Gotya. I looked at mapAccumR and figured it should be easy so I didn't actually think through, but since you challenged me .. Hold me beer
22:34:17 <Cale> Instead, right now, you have to get by with stuff like:
22:34:20 <mibaz_1> Cale: Super cool. I should try again to learn it. Last time I saw the "forall"s and panicked (was a little too soon ;)
22:34:40 <Cale> geolocating :: Event t a -> Event t (Location, a)
22:34:59 <Cale> rather than  location :: Behavior t Location
22:35:21 <Cale> i.e. you simulate attach for the Behavior you would have liked to have
22:35:33 <Cale> oh, also, that won't be pure :P
22:35:54 <Cale> geolocating :: Event t a -> m (Event t (Location, a)) (for some m)
22:37:03 <boj> Cale: curious what kind of network games you were intending to target
22:37:07 <Cale> mibaz_1: Yeah, it's a little hard for beginners still, and there's maybe a bit too much polymorphism just because we're still experimenting with lots of different ways that it can be exploited
22:38:23 <Cale> boj: To begin with, I have a reflex-gloss implementation of a really old game called XBattle (an old X Windows game from before e.g. GTK was a thing)
22:38:28 <mibaz_1> Cale: Yeah I'd say that's more important than the beginners at this point
22:39:22 <sqooq> boj: It's still in development and is really ugly and tbh I don't feel too good about it.
22:39:32 <Cale> mibaz_1: There's also some potentially spooky stuff that is nonetheless completely ignorable in there -- various hacks that Ryan's done for various special purpose scenarios that are unlikely to arise again.
22:39:34 <sqooq> Man I kind of feel motivated to make something like that
22:39:46 <sqooq> but I'm just way too young in my programming journey to do something like that.
22:40:52 <sqooq> I just know that puredata feels amazing to work with compared to non-graphical music environments
22:42:22 <Cale> https://github.com/reflex-frp/reflex/blob/develop/src/Reflex/Requester/Base.hs#L126  ... my ear is bleeding... why is my ear bleeding?
22:42:26 <Cale> :)
22:42:35 <c_wraith> sorry, my music is up kind of loud
22:42:53 <c_wraith> Wow, that type is really something.
22:42:58 <Cale> hahaha
22:43:12 <Cale> The amazing thing is that it can't have been inferred by the compiler
22:43:33 <c_wraith> it's higher-rank
22:44:03 <c_wraith> wow, that's almost all type.  even the body is almost all type of a helper function
22:44:09 <kadoban> Cale: O.o
22:44:11 <Cale> But yeah, you're never going to use that -- there probably ought to be special modules or a separate package for such things.
22:44:18 <xzhu> @let carry = (uncurry (:)) $ mapAccumR (\c -> ((`div` 10) &&& (`mod` 10)) . (+c)) 0 -- cocreature
22:44:19 <lambdabot>  .L.hs:201:1: error:
22:44:19 <lambdabot>      Multiple declarations of ‘carry’
22:44:19 <lambdabot>      Declared at: .L.hs:200:1
22:44:45 <xzhu> how do I import
22:44:45 <dysfigured> @_@
22:44:53 <dysfigured> madness
22:45:05 <boj> Cale: hmm, so turn based games? i was curious if you had somehow solved time sensitive high performance FPS game networking in FRP :)
22:45:06 <cocreature> xzhu: "curry = snd . mapAccumR (\x y -> (x + y) `quotRem` 10) 0" was what I came up with
22:45:27 <Cale> boj: No, this is continuous time, but discrete space :)
22:45:30 <cocreature> eh carry not curry :)
22:45:39 <xzhu> Hah you missed the possibility of having an extra digit!
22:45:45 <cocreature> huh?
22:45:59 <cocreature> oh yeah I guess I need to prepend the accumulator
22:46:00 <xzhu> carry [9, 10] = [1, 0, 0]
22:46:06 <Cale> boj: You draw paths onto a hex grid, and "fluid"/"troops" flow along them between the cells, visualised as circles which expand and shrink
22:46:33 <xzhu> anyways mine is also incorrect as I aways add that digit
22:46:46 <mibaz_1> Cale: MY LEGG
22:47:00 <mibaz_1> Cale: it hurts
22:47:10 <cocreature> xzhu: if you don’t care about preserving leading zeroes, dropWhile (==0) should be sufficient to get rid of that
22:48:00 <xzhu> cocreature: I didn't know quotRem. Seems like almost designed for this code golf
22:48:18 <dsal> Is there a thing like forall, but forall forall.  Like ∀∀ -- because that code needs it.
22:49:19 <Cale> boj: I'm hoping to end up with networking similar to what's in code.world, but that bit doesn't exist at all yet.
22:49:33 <cocreature> dsal: can you give an example of what you are trying to do?
22:50:03 <dsal> I was just looking at https://github.com/reflex-frp/reflex/blob/develop/src/Reflex/Requester/Base.hs#L126 and ran out of ability to parse.
22:50:14 <Cale> boj: What I *do* have is a reflex where it's possible for the host to restore previous states of the entire world
22:50:29 <Cale> (well, I don't even have that finished, just a decent chunk)
22:50:57 <cocreature> dsal: I still don’t get what you mean by “forall forall” and how that is supposed to help
22:51:03 <Cale> Like, one weekend's worth of stuff :P
22:51:24 <cocreature> you can already quantify over multiple variables in a single forall
22:51:27 <dsal> cocreature: It's OK, I don't know what I mean, either.  I just see gangs of foralls and assume something higher level must exist.
22:51:45 <vaibhavsagar> maybe rank 2 types?
22:52:28 <Cale> For all quantifiers Q, Q x. P x
22:52:32 <dsal> Also:  I don't understand forall (never actually used it), so I don't know what I'm talking about.  That code just seems complicated.
22:52:53 <boj> Cale: look forward to seeing it some day :)
22:53:30 <cocreature> dsal: oh it definitely is complicated, I just don’t think simplifying it by adding some combinator that I’m not sure what it’s supposed to do is really helpful here
22:57:49 <Cale> boj: Yeah, I think reflex could be really great for games if we put some effort in that direction. I haven't had lots of extra energy to put in that direction thus far, but I'd like to at least get my multiplayer XBattle working with lockstep sync and then go from there :)
23:00:21 <Cale> Ryan and I originally worked on FRP systems in order to make an action RPG back in the day (~2010-2012 or so) -- though it never got finished, we had nice ranged and melee AIs, and multitouch controls running in our arrowized FRP system reasonably well.
23:01:43 <Cale> Reflex is sort of a resurrection of a lot of the ideas we developed about FRP back then, after Ryan went on building and discarding many other systems. But this time around we've been using it to build web applications since that's obviously an easier way to make money. :)
23:02:35 <Cale> Well, it's also very different in many ways to those systems we built, in terms of how it works, and the fact that it looks more like Conal's idea of FRP than like AFRP
23:02:40 <mibaz_1> > import Money
23:02:42 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
23:02:45 <mibaz_1> darn
23:03:18 <Cale> I should sleep... g'night!
23:03:29 <pacak> Night.
23:04:58 <Zemyla> I should probably go to bed. I laughed way too hard at a category theory joke.
23:07:15 <pacak> Tell us more!
23:07:31 <mibaz_1> When I stay up too late it's always funny to see the americans go to bed and the brits wake up
23:08:05 <rotaerk> suddenly "color" starts being spelled "colour", and such
23:08:08 <kadoban> Does it change from burrito jokes to tea jokes?
23:08:16 <pacak> Middayish here.
23:09:28 <saurabhn_> very random question: is there any monad which "tracks" ALL its side effects? eg. if I sequence 3 actions which cause side-effects to values of types A, B, & C, then the type signature of the combined monadic action results in a value of type (A, B, C)
23:09:42 <JuanDaugherty> at some point this will go away, and people will find global interconnectedness normal. netsplits idunno
23:10:04 <geekosaur> saurabhn_, I think you want to look at effects systems?
23:11:22 <saurabhn_> geekosaur: taking a look. Anything else?
23:12:21 <geekosaur> um? my understanding is that's pretty much the definition of them.
23:13:13 <saurabhn_> do the effect systems force you to return the values that may have been involved in the tracked side-effect?
23:15:25 <saurabhn_> so, in general, FP is not about eliminating state, but **tracking** state safely, right?
23:17:11 <Taneb> saurabhn_, that's one way to look at it I guess
23:20:54 * hackagebot equational-reasoning 0.5.0.0 – Proof assistant for Haskell using DataKinds & PolyKinds – https://hackage.haskell.org/package/equational-reasoning
23:22:35 <saurabhn_> and if one finds oneself resorting to ST monad, it's got nothing against FP, right?
23:22:45 <kadoban> saurabhn_: Not at all
23:23:23 <kadoban> Yes, I consider haskell less about eliminating side-effects and more about the language having a concept of the difference between pure and not.
23:27:26 <saurabhn_> in the ST monad, where are the functions that modify the 's' in `ST s a`?
23:30:01 <saurabhn_> "Meaning that they return a value of type α, and execute in "thread" s. All reference types are tagged with the thread, so that actions can only affect references in their own "thread”." -- is this 's' not the "state" that can be mutated?
23:30:02 <MarcelineVQ> dunno much about it but the top of http://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Monad-ST.html links to two other modules with ST related things
23:30:31 <kadoban> saurabhn_: No, the 's' is just kind of an implementation detail.
23:30:38 <kadoban> You never change it or mess with it, it's just there.
23:30:47 <saurabhn_> so 'a' is the real state that an end-programmer should be bothered with?
23:30:58 <saurabhn_> unfortunate naming of type-variables.
23:31:28 <kadoban> 'a' is just the result of the computation. The stuff you can do in ST is mostly to do with  STRef and various STArrays
23:31:29 <ahihi> a is the return type
23:31:47 <ahihi> ST is quite different from State
23:32:15 <kadoban> ST is like IO, in that you can have mutable memory locations (which you create with STRef/IORef) and mutable arrays and such. The difference is that IO can do like ... IO, writing to files, printing, etc. ST can't.
23:32:41 <saurabhn_> got it.
23:32:46 <kadoban> Also ST can be "wrapped up", in that runST exists. There is no runIO
23:32:57 <saurabhn_> so, if I need mutable memory I need to create an STRef and pass it around?
23:33:12 <kadoban> Yes
23:33:23 <saurabhn_> how is this different than IORef, in that case?
23:33:45 <kadoban> STRef and IORef are very similar concepts. I'm not sure I understand the exact question there though.
23:35:05 <saurabhn_> as in, STRef => make a ref and pass it around. Seems similar to IORef.
23:35:57 <kadoban> It is, very very similar. The only difference is that one makes sense in ST s and the other in IO
23:36:19 <ongy> blargh, being brickwalled in haskell dev because gcc (yes, gcc, not ghc) is too new -.-
23:41:19 <Arahael> ongy: gcc, and not clang?
23:41:27 <pacak> :t runIO
23:41:29 <lambdabot> error: Variable not in scope: runIO
23:41:45 <pacak> lambdabot: There is runIO.
23:42:12 <ongy> Arahael: https://github.com/haskell/c2hs/issues/191 (not my issue, but the same problem)
23:42:17 <pacak> kadoban: It's in template-haskell, it runs IO inside Q.
23:43:34 <Arahael> ongy: You can't use clang instead?
23:44:08 <ongy> Arahael: the problem is that c2hs tries to parse the headers and fails. I could throw out the dependency that uses c2hs, but that's more work than I feel like doing
23:44:09 <kadoban> pacak: TH is on a different level, different things make sense. There's also unsafePerformIO if you really want to go there, but its name is well earned so *shrug*.
23:45:41 <pacak> kadoban: You think unsafePerformIO is scary? :) Ever used accursedUnutterablePerformIO?
23:47:43 <kadoban> No, though I hope to some day.
23:47:57 <kadoban> And I don't really think it's scary, it's just an escape hatch that one should normally avoid.
23:48:25 <xzhu> I wonder how is "pattern matching" fundamentally different from "switch statements"?
23:48:45 <Arahael> xzhu: Classically, switches don't check that you've covered every eventuality.
23:49:03 <Arahael> xzhu: Mind you, functions are allowed to be non-total in haskell, so...
23:49:31 <Arahael> xzhu: But at least, I guess, it'll fail hard and fast in that case.
23:49:46 <kadoban> xzhu: switch statements are typically only like integer types, they're quite restricted
23:50:08 <xzhu> kadoban: I guess by switch statements I also include ifelse chains
23:50:11 <kadoban> They're more like "test all of these for equality, and that's it". Pattern matching is more powerful.
23:51:03 <kadoban> ifelse chains are less ... stuctured I guess I'd say.
23:51:17 <pacak> kadoban: When something is wrong with your IO escaping you can easily get thing like 1 + 1 = 3.
23:51:36 <Arahael> Which is literally possible in python. ;)
23:51:53 <xzhu> kadoban: I know that pattern matching is more powerful than both ifelse chains and switches, what I'm really wondering is why is it always raised as one of the quintessential features of functional programming or declarative programming
23:53:08 <speak> It's one of the important building blocks, not an end goal per se, maybe?
23:53:14 <pacak> xzhu: It makes it easier to write total functions, compiler is able to poke you if you miss something. It makes it easier to work with big and complex structures.
23:53:24 <speak> So it's important, but it's not going to make you go "Wow holy shit that's amazing!" all the time
23:53:39 <saurabhn_> hmmm... so if I readSTRef and then modifySTRef, the earlier value that has already been read, does not really change. It isn't true mutable references in that sense.
23:55:08 <xzhu> BTW is it possible to force totality in Haskell?
23:55:13 <mbrock> xzhu: if you try writing something like a red-black-tree balancing function with and without pattern matching...
23:55:53 <kadoban> xzhu: No. You could get maybe closeish if you turn on the warning for incomplete pattern matches and -Werror, with all that entails.
23:55:57 <speak> (who the hell works on red-black-tree balancing functions by hand?!)
23:56:05 <mbrock> https://www.cs.cornell.edu/courses/cs3110/2014sp/lectures/11/red-black-trees.html near the bottom is a balancing function in ML
23:57:18 <kadoban> xzhu: If guards didn't exist, haskell could always tell for sure, I think. But in the presence of guards, it's not quite possible to *always* tell if pattern matches are total.
23:57:32 <saurabhn_> has anyone worked with the RWS monad? are there any pitfalls?
23:57:53 <kadoban> speak: Students. Whoever implements them once. Whoever implements them again for various specific reasons (programming competitions which require wacky special-purpose stuff xD)
23:58:15 <xzhu> balance :: RB a -> a -> RB a -> RB a
23:58:15 <xzhu> balance (T R a x b) y (T R c z d) = T R (T B a x b) y (T B c z d)
23:58:15 <xzhu> balance (T R (T R a x b) y c) z d = T R (T B a x b) y (T B c z d)
23:58:15 <xzhu> balance (T R a x (T R b y c)) z d = T R (T B a x b) y (T B c z d)
23:58:15 <xzhu> balance a x (T R b y (T R c z d)) = T R (T B a x b) y (T B c z d)
23:58:16 <xzhu> balance a x (T R (T R b y c) z d) = T R (T B a x b) y (T B c z d)
23:58:18 <xzhu> balance a x b = T B a x b
23:58:27 <pacak> xzhu: o_O
23:58:30 <xzhu> source: https://www.cs.kent.ac.uk/people/staff/smk/redblack/Untyped.hs
23:58:49 <Arahael> That researcher had way too much time on their hands.
23:58:51 <pacak> saurabhn_: It  works.
23:59:05 <saurabhn_> pacak: any lazy/strict madness that one needs to be aware of?
23:59:44 <mbrock> xzhu: yeah, it's an extreme example, but that code is *so* much more readable than what you get if you don't have pattern matching
