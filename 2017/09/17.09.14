00:30:45 <Tehnix> Does anyone have any documentation on creating your own language extension? Pretty sure I've seen some blog post before, but can't seem to find it again :/
00:58:55 <thomastrace> Hello there !
01:10:52 <ongy> Hi
01:28:05 * mbrock wonders about a nice way to implement `Set (Maybe a) -> Set a`...
01:29:29 <mbrock> `Set.fromList . catMaybes . Set.toList` is okay but I'm curious if there's a nicer way
01:31:21 <kadoban> fromDistinctAscList or whatever it is? ;)
01:33:39 <mbrock> ah, yeah, because it'll already be sorted properly coming out of `toList`
01:33:43 <pacak> mbrock: remove Nothing
01:33:54 <pacak> then I think there was some kind of map function
01:34:16 <mbrock> oh, like `Set.map fromJust . Set.remove Nothing`
01:34:44 <pacak> mapMonotonic
01:34:54 <mbrock> ah, I see
01:37:19 <kadoban> Ah yeah, nice
01:50:50 <wob> hi. what is it Tasty does that Hspec doesn't?
01:51:38 <tdammers> unified interface for multiple test frameworks
01:51:48 <lightstep> Hello, I'm returning to haskell after a while, and here for a quick reminder. Is there a way to define all literal strings in my program to be Text? I don't need Strings or ByteStrings
01:52:17 <Iceland_jack> You can use OverloadedStrings
01:52:25 <Iceland_jack> Add {-# Language OverloadedStrings #-} to the top of your module
01:52:53 <Iceland_jack> It allows string literals to work as String but also Text
01:53:09 <lightstep> That's no good... GTK has a lot of functions with type (IsString a => a -> b), and then I need to name the type for each
01:53:20 <lightstep> or use pack for each
01:53:47 <tdammers> define a function t :: Text -> Text; t = id
01:53:55 <tdammers> then write your string literals as t"Whatever"
01:53:59 <tdammers> vOv
01:54:02 <Iceland_jack> vOv
01:54:21 <wob> tdammers, but Hspec will let me do unit tests and quickcheck. so it unifies more testing frameworks?
01:54:21 <lightstep> ok then
01:54:24 <lightstep> thanks :)
01:54:46 <Iceland_jack> visible TypeApplications is great for specifying types like this, in general
01:55:03 <Iceland_jack> t = id @Text
01:55:33 <Iceland_jack> Take it for a spin
01:56:04 <lightstep> oh wow. nice extension
01:57:23 <Iceland_jack> for example, 'sequence' looks very scary
01:57:24 <Iceland_jack> :t sequence
01:57:26 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
01:57:37 <Iceland_jack> >> :t sequence @[]
01:57:37 <Iceland_jack> sequence @[] :: Monad m => [m a] -> m [a]
01:57:44 <Iceland_jack> But this immediately looks less scary
01:57:47 <mbrock> there's also the `ExtendedDefaultRules` extension
01:57:54 <Iceland_jack> sequence @[] @Maybe :: [Maybe a] -> Maybe [a]
01:58:21 <mbrock> with which you can have a top-level declaration like `default Text` and then that will be the preferred instance for `IsString`
01:59:31 <mbrock> sorry, the syntax is `default (Text)`
01:59:49 <mbrock> I don't know if this extension is considered good
02:01:01 <lightstep> it did the trick though
02:01:38 <mbrock> yeah, I've used it too, it's somehow hard to find any information about it on google
02:02:24 <mbrock> oh, here's the manual section: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#extended-rules-around-default-declarations
02:03:52 <lightstep> how does TypeApplications decide on the order of type arguments?
02:04:32 <Iceland_jack> There are some rules, for simple functions it's basically the order the types appear in the type signature
02:04:44 <Iceland_jack> if there is no type signature, you cannot apply it to types
02:04:44 <lightstep> and does it also do phantom types?
02:04:47 <Iceland_jack> yes
02:05:08 <Iceland_jack> You can specify the order explicitly if you want, with (const :: forall b a. a -> b -> a)
02:05:26 <Iceland_jack> There are some extra rules for type class methods
02:07:51 <merijn> Incidentally, this is why I'm against using TypeApplication it's brittle since it can break if the type variables get reordered
02:09:08 <Boomerang> :t sequence @_ @Maybe
02:09:10 <lambdabot> error: parse error on input ‘@’
02:09:18 <Boomerang> >> :t sequence @_ @Maybe
02:09:23 <kadoban> When could the order change, just for phantoms?
02:09:33 <lightstep> the Text.Printf module uses String... is there a newer/more popular formatting library?
02:09:46 <Iceland_jack> It can also change just by turning on polykinds
02:09:52 <Iceland_jack> but I still use it like mad
02:10:03 <Iceland_jack> I like chaos and @_ @_ @_ @
02:10:05 <Iceland_jack> ...
02:10:27 <Iceland_jack> It's accurately represents my face using Haskell
02:12:10 <merijn> lightstep: I'm using a TH one, lemme check what it was again
02:14:17 <merijn> @hackage interpolate
02:14:17 <lambdabot> http://hackage.haskell.org/package/interpolate
02:14:31 <Boomerang> kadoban: You can change the order to be whatever you want when you use ScopedTypeVariable
02:14:51 <lightstep> i was pleasantly surprised by some simple record extensions RecordWildCards,NamedFieldPuns, records are much more comfy now
02:20:42 <lightstep> interpolate works like a charm, thanks
02:23:18 <ertes-w> Iceland_jack: when you use haskell your face looks like perl?
02:23:59 <Iceland_jack> exactly
02:37:44 <saurabhnanda> is there a standard monadic version of mconcat/<>
02:38:13 <erisco> mplus and msum
02:38:16 <AWizzArd> Where is IO defined in the ghc sources? I was having a look at http://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.IO.html and was searching for something like    „data IO …”
02:39:53 <srhb> AWizzArd: https://hackage.haskell.org/package/base-4.10.0.0/docs/System-IO.html
02:40:15 <srhb> Oh, wait, that's a re-export of course
02:40:58 <srhb> Are you looking for the RealWorld bit?
02:41:01 <AWizzArd> In that file at the top I see   import {-# SOURCE #-} GHC.IO (failIO,mplusIO)
02:41:06 <merijn> AWizzArd: Well, the first question would be "why do you want it?"
02:41:23 <erisco> think of  IO a  as  State RealWorld a
02:41:30 <merijn> No, please don't
02:41:38 <AWizzArd> I am looking for the part where IO is born, where this type is introduced.
02:41:45 <merijn> "State RealWorld a" is a terrible intuition for IO
02:41:46 <erisco> I like it that way
02:42:04 <AWizzArd> merijn: just for learning purposes. Just wanna see the code.
02:42:13 <saurabhnanda> :t mplus
02:42:15 <lambdabot> MonadPlus m => m a -> m a -> m a
02:42:15 <merijn> erisco: Right up until the part where everything goes to shit because it's getting called by C from the FFI or threading, etc.
02:42:25 <merijn> AWizzArd: There's not a lot to learn from that code, tbh
02:43:21 <AWizzArd> merijn: I believe so too. I just don’t know where to find it :-)
02:43:25 <maerwald> arguing about inuition is weird
02:43:26 <srhb> AWizzArd: You'd actually need to look at the unsafe GHC primitives to glean much. The interesting bits are in the rts, presumably.
02:43:30 <erisco> fair, I don't incorporate concurrency or parallelism into my thoughts on IO
02:43:31 <saurabhnanda> erisco: thanks. That seems to have worked.
02:43:34 <saurabhnanda> :t msum
02:43:36 <lambdabot> (MonadPlus m, Foldable t) => t (m a) -> m a
02:43:41 <srhb> Unless you want to see unIO etc :-)
02:43:47 <saurabhnanda> interesting... didn't know about mplus and msum. Thanks.
02:44:02 <AWizzArd> I tried  GHC.Base.html   and  System-IO.html   and  GHC.IO.html
02:44:06 <merijn> hmm, I wish there was a simple "default" exception I can just stuff a string in and throw
02:44:16 <merijn> AWizzArd: IO is not in base, it's in ghc-prim
02:44:56 <AWizzArd> merijn: but how can it be used in   http://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.IO.html  ?
02:45:05 <AWizzArd> There is no such import statement.
02:45:06 <erisco> it may also be problematic that there can be other mutators to the world
02:45:14 <merijn> AWizzArd: Because IO is built into GHC
02:45:30 <AWizzArd> merijn: okay, so it is just made available anywhere.
02:46:01 <srhb> I think there's some use of runRealWorld in base
02:46:09 <srhb> (Which is from GHC.Prim, I think)
02:46:20 <AWizzArd> merijn: I am interested in seeing how code is pattern-matching on IO.
02:46:26 <srhb> Maybe I'm misremembering..
02:46:48 <erisco> oversimplified, the State intuition works
02:47:13 <erisco> and if instructors are allowed to tell lies to make things simple then why can't I
02:47:33 <merijn> erisco: I would complain about instructors using this too
02:48:14 <AWizzArd> bindIO (IO m) k = IO (\ s -> case m s of (# new_s, a #) -> unIO (k a) new_s)
02:48:21 <barrucadu> I found the "it's just built-in magic" intuition fairly helpful when learning Haskell IO
02:48:26 <erisco> so we need a semantics more robust to cope with concurrency, exceptions, outside mutators…
02:48:32 <AWizzArd> They just unpack the m, do something with it and put it back into an IO.
02:48:55 <AWizzArd> Are those source files compiled with special privileges, so that it is possible?
02:49:06 <erisco> merijn, did I miss something?
02:49:06 <merijn> AWizzArd: Not really
02:49:25 <maerwald> IO is just a DSL to "talk" to the GHC RTS. In the end, you don't really know what happens
02:49:30 <merijn> erisco: Unlikely to ever get those, which is conal's usual complaint about the lack of denotational semantics for IO
02:49:52 <AWizzArd> maerwald: (-:
02:49:57 <erisco> maybe don't look for a denotational semantics
02:50:17 <merijn> erisco: Denotational semantics are great!
02:50:39 <erisco> and we don't need to say what we do to the world
02:51:03 <erisco> the actions on the world can be featureless
02:52:02 <AWizzArd> maerwald: reminds me of the classic: https://tctechcrunch2011.files.wordpress.com/2014/05/math07.gif
02:52:30 <erisco> the only feature need be that the world before is possibly not the same as the world after
02:53:29 <erisco> State is too strong with what we know about the state
02:53:58 <erisco> for example,  put x >> get = return x  with state but this sort of thinking does not work with IO
02:54:19 <erisco> if, say, this were another action like  writeToFile x >> readFromFile
02:55:09 <maerwald> I don't think one can come up with useful intuition by overthinking the details and terminology :>
02:55:25 <mstruebing> Can someone help me? I've created a new project with stack and as I add scotty as a build-dependency for my executable I get a compile error. If I remove scotty again it is compiling fine. - I'm on Arch Linux with Stack v1.5.0. The error output put can be found here: https://pastebin.com/1UrppZfD
02:56:23 <lightstep> erisco, but you don't have access to the put and get
02:56:47 <cocreature> mstruebing: try uninstalling libtinfo
02:57:53 <cocreature> mstruebing: if you need a GHC that is not 8.0.2 or 8.2.1, you’ll have to install ncurses5-compat-libs, otherwise things should just work
02:58:18 <AWizzArd> Why is there a „return” function? Is this because historically the Monad class was not always constraint to have an Applicative, which would have made pure available?
02:58:26 <opqdonut> yes
02:58:33 <ertes-w> erisco: (put x >> get = pure x)  -- that's not correct
02:58:42 <opqdonut> applicative was invented way later than monad
02:58:45 <cocreature> AWizzArd: you might be interested in https://ghc.haskell.org/trac/ghc/wiki/Proposal/MonadOfNoReturn
02:58:50 <ertes-w> erisco: (put x >> get = x <$ put x)
02:59:12 <erisco> ertes-w, thanks
02:59:21 <AWizzArd> cocreature: thx
02:59:29 <maerwald> opqdonut: invented?
02:59:56 <ertes-w> erisco: just a nitpick, tangential to your point =)
02:59:57 <erisco> I think my mistake is that  State RealWorld a  intuits the mechanism by which we can hold Haskell's hand through understanding IO but it discounts all the other careful footwork being done
03:00:24 <opqdonut> maerwald: yeah
03:00:30 <erisco> so, the extent it is related does not go as far to really tell us what IO is about
03:00:40 <erisco> you'd also have to understand the motivations for all the careful footwork
03:00:47 <maerwald> opqdonut: you mean the typeclass or the concept
03:01:04 <ertes-w> erisco: well, if you take the (State RealWorld) interpretation, then unfortunately writeFile is not the action that writes to a file…  it's the action that, along with writing a file, does a full universe simulation with everything else happening at the same time
03:01:17 <ertes-w> that's why (State RealWorld) is hard to reason about
03:02:00 <opqdonut> maerwald: the concept in a haskell context, at least. Monad seem to be from the nineties, while the Applicative paper (http://www.staff.city.ac.uk/~ross/papers/Applicative.html) is from 2008
03:02:55 <erisco> ertes-w, maybe that was the concept in the original paper(s) but I don't see why we have to think the universe is being simulated
03:03:01 <AWizzArd> And I wonder: where is `do` defined/implemented? Is it done via TemplateHaskell? If not: why not?
03:04:14 <erisco> ertes-w, I'd rather think something such as RealWorld is lazy and when we look at it we know the instant of the world at that time
03:05:23 <ertes-w> erisco: because the state of the universe affects the primary function of writeFile: the file may not be accessible due to permissions, the host may run into an I/O error due to solar flares, etc.
03:05:58 <erisco> yes, sure, but when you write a file you look at the world at the instant of writing
03:07:16 <ertes-w> erisco: and you advance its state taking everything into account…  imagine that you do writeFile twice in a row, and considering that (>>=) itself may not introduce any effects due to laws, how else would an effect *between* the two propagate to affect the second one?
03:07:51 <erisco> I am not sure of what you mean
03:08:00 <ertes-w> the first writeFile creates a file that triggers some action that triggers network activity that triggers stuff happening on the other side of the planet that triggers some more actions and triggers, and finally, the second writeFile fails because of all of this happening
03:08:24 <erisco> but what I am saying is not that important anyways… it is just an idea to be an observer of the world rather than the simulator of it
03:09:02 <erisco> then… the second writeFile fails? I don't see the issue
03:09:23 <ertes-w> erisco: but where did the intermediate effects happen?
03:09:31 <ertes-w> where did the state of the world change?
03:09:54 <ertes-w> i couldn't have been changed by (>>=)
03:09:55 <erisco> I do not understand exactly what you're getting at
03:10:14 <ertes-w> erisco: my point is that writeFile needs to simulate the universe
03:10:39 <erisco> but I wasn't particularly clear on what I meant either, partly because I don't have proper notations for it
03:11:34 <erisco> I don't think it does, and maybe the difference is that I am inclined to think of writeFile as featureless
03:12:30 <erisco> writeFile is not reaching around the world to put a file onto a disk, it is just an action whose only feature is it possibly changes the state of the world
03:13:08 <ertes-w> erisco: let's say that the universe is in a state where (writeFile fp2 s2) would succeed, but now you do (writeFile fp1 s1 >> writeFile fp2 s2)…  the first write causes a massive chain reaction across the planet, resulting in the second one failing very indirectly
03:13:34 <erisco> sure, not a problem
03:14:14 <ertes-w> where did the state of the universe change?  it must be as part of one of the writeFile actions
03:14:20 <erisco> the semantics do not have to say deterministically what happens
03:14:47 <erisco> if you wanted that then you would need to simulate the world, I suppose, but that's a bit optimistic
03:15:19 <erisco> the world was possibly changed by the first writeFile
03:15:41 <ertes-w> in the (State RealWorld) model it must have been one of the writeFile actions
03:16:12 <erisco> maybe I should restate a crucial bit of what I first said
03:16:47 <erisco> I am saying, in this version, RealWorld is lazy
03:17:03 <erisco> when we look at it we see the world as it at the time we look at it (not the time it was created)
03:17:34 <erisco> so, the first writeFile produces a new lazy RealWorld which is then scrutinied by the second writeFile
03:17:56 <erisco> when we look at the state of the world in the instant of the second writeFile, we see the erroneous state, as per your example
03:18:36 <erisco> the time between the first writeFile and the second writeFile we are blissful to, represented by the laziness of RealWorld
03:20:00 <lightstep> lazy like the oracle in the [Response] -> [Request] model?
03:20:21 <erisco> maybe so… I haven't thought about that older model in a long time
03:30:21 <saurabhnanda> is there a standard Funtor-like typeclass for something that has two type arguments, eg. data Editor new existing = CreateItem new | EditItem existing | DeleteItem existing ?
03:32:05 <cocreature> saurabhnanda: Bifunctor
03:32:12 <cocreature> it’s even in the base package
03:32:32 <saurabhnanda> or, is there a standard lens combinator that will allow me to apply a function on all "branches" of a sum-type?
03:34:06 <Iceland_jack> bimap :: (new -> new') -> (existing -> existing') -> (Editor new existing -> Editor new' existing')
03:34:40 <saurabhnanda> bifunctor might not work for me...
03:36:29 <saurabhnanda> I have a function called `validations :: (new|exisiting) -> [Error]` and I have a value of type `Editor = NewItem new | EditItem existing | DeleteItem existing`. How do I write a function that does this transformation-- `Either new existing -> validationFunction -> [Error]`
03:37:22 <saurabhnanda> the validationFunction can work on both new OR existing because it uses lenses heavily and it doesn't specialise on either `new` or `existing`. 
03:37:59 <saurabhnanda> is there a standard lens combinator that allows me to do this?
03:38:58 <cocreature> either validations validations
03:40:36 <saurabhnanda> cocreature: not clear on this... how will `either` help?
03:40:56 <cocreature> :t \v -> either v v
03:40:58 <lambdabot> (a -> c) -> Either a a -> c
03:41:05 <cocreature> that seems to be what you are trying to do
03:41:12 <mstruebing> What do I do wrong here? http://lpaste.net/4477314775411326976
03:41:33 <saurabhnanda> but my base data time is not Either. it's Editor = NewItem new | EditItem existing | DeleteItem existing 
03:41:55 <cocreature> then why did you say “how do I write a function that does this transformation `Either new existing -> …`”
03:42:58 <saurabhnanda> sorry type
03:43:00 <saurabhnanda> *typo
03:43:18 <saurabhnanda> required transformation --> Editor new existing -> validationFunction -> [Error]
03:43:35 <cocreature> either way, you are probably going to need to write something like "either" for your type
03:43:38 <saurabhnanda> where `validationFunction :: (new|existing) -> [Error]`
03:43:55 <saurabhnanda> any existing lens that allows one to do this?
03:44:13 <saurabhnanda> essentially unwrap the data constructor and apply the function. 
03:44:19 <cocreature> I don’t see what this has to do with lenses
03:45:21 <saurabhnanda> something like (validationFunction $ editorVal ^. _unwrap) or something
03:47:43 <lightstep> mstruebing, the first line should read getPort :: IO Int
03:48:16 <cocreature> saurabhnanda: I think you might be falling into the trap of trying to solve every problem using lens regardless of whether lens actually helps here
03:49:30 <mbrock> can someone come up with a simple example of a pattern synonym that uses a guard?
03:50:18 <mbrock> something like `pattern Foo n <- (n | n > 0)` except with valid syntax
03:51:11 <saurabhnanda> cocreature: :) isn't that usually the case?
03:51:29 <saurabhnanda> cocreature: lenses solve everything. Slowly they'll become sentient and start writing code themselves.
03:52:18 <ertes-w> erisco: presumably by laziness you mean something other than "evaluated lazily"?  because i think lazy evaluation would not make a semantical difference here
03:53:23 <mbrock> oh, I guess guards are not part of patterns, so it's not possible
03:53:55 <mbrock> but maybe I can use a view pattern to emulate it
03:55:03 <erisco> ertes-w, semantically they call it nonstrict, sure, but I don't have all the semantic details for you. That was just the idea.
03:55:14 <mbrock> `pattern Foo n <- ((\x -> if x > 0 then Just x else Nothing) -> Just n)`
03:55:16 <mbrock> that seems to work
03:55:24 <merijn> hmmm, I still haven't found particularly clean/nice way to do IO loops with some state
03:55:49 <merijn> Is there like an "iterateM" somewhere?
03:56:31 <erisco> are you wanting to read the state to determine if the loop should continue?
03:56:51 <merijn> erisco: Yeah
03:57:43 <ertes-w> merijn: what kind of loop?  is it a traversal?
03:58:13 <merijn> ertes-w: Network loop. Accept connection, do something that (maybe) modifies state, check whether to continue
03:58:41 <merijn> ertes-w: Loops over data structures, etc. have plenty of stuff in Traversable, etc. it's just simple ones like this that always feel awkward
03:58:43 <ertes-w> merijn: well, StateT would be an option, but other than that i would probably just write a helper function
03:58:54 <saurabhnanda> does GHC infer Rank-N types?
03:59:04 <merijn> saurabhnanda: No, because that's impossible
03:59:31 <erisco> I should think that you can do this with, say, foldlM and StateT IO
03:59:38 <ertes-w> merijn: we're missing a data structure for this kind of loop
03:59:42 <erisco> or StateT s IO
03:59:44 <merijn> (Well, it's theoretically possible, but ridiculously hard for Rank2. Arbitrary Rank is impossible)
04:00:06 <merijn> erisco: foldlM doesn't work. What's the input list for the fold?
04:00:25 <merijn> erisco: StateT works, but isn't much better than an explicit helper function loop
04:00:39 <erisco> well I don't know, because I don't know from your description what the whole situation is
04:01:12 <erisco> yes well you can write your loop function once and reuse it … speaking of which I recall a library of just looping functions
04:01:23 <ertes-w> newtype Loop a b = Loop (a -> (b, Loop a b))  -- this one has a traversal for some 'a'
04:01:25 <merijn> erisco: I just gave the entire situations. Initial state, accept connection, run an action that modifies/returns new state, check to continue
04:01:38 <ertes-w> let me experiment a bit
04:02:34 <erisco> guess I am not clever enough to understand, but maybe there is something here http://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html
04:03:11 <erisco> this looks fun http://hackage.haskell.org/package/control-monad-loop-0.1/docs/Control-Monad-Trans-Loop.html
04:03:18 <erisco> continue and exit effects, wow! :)
04:03:43 <saurabhnanda> what would be the RankN type-sig for what I'm trying to do at https://gist.github.com/saurabhnanda/de9a0a9ce7373b4f4d20736f89fa83d4 ?
04:06:59 <ertes-w> merijn: i think what you want is best captured by MealyT here: https://hackage.haskell.org/package/machines-0.6.3/docs/Data-Machine-MealyT.html
04:07:29 <merijn> ertes-w: That looks way to complicated for me to be arsed with in this case, though :)
04:07:34 <ertes-w> merijn: but it doesn't save you from having to write the recursion
04:07:45 <erisco> that last link, control-monad-loop, gives exactly a definition for while, doWhile, foreach …
04:08:02 <ertes-w> it just encapsulates this kind of stateful action in a nice, composable type
04:08:26 <ertes-w> merijn: MealyT starts to become interesting, if you have multiple components, each having local state
04:08:50 <ertes-w> the non-transformer variant also has a Fold
04:09:11 <ertes-w> though it's not predefined
04:09:28 <merijn> ertes-w: Yeah, but I really just have a simple "handle 1 request at a time" dealie :)
04:09:53 <hexagoxel> saurabhnanda: applyToEditor :: (forall t . HasName t => t -> c) -> Editor a b -> c
04:10:17 <merijn> hmmm, I wonder it what point code starts to qualify as "where-clause abuse"
04:10:29 <saurabhnanda> hexagoxel: that would constraint this to only the HasName lens. I want it to be even more general. As long as the function can be applied on `new` or `existing` it should work.
04:10:31 <hexagoxel> you have to list all common lenses in the type there.
04:11:44 <hexagoxel> ah, or abstract over the constraint.. hmm
04:12:15 <erisco> merijn, maybe by the third nested where
04:12:51 <hexagoxel> applyToEditor :: forall l . (l a, l b) => (forall t . l t => t -> c) -> Editor a b -> c
04:12:57 <merijn> erisco: How about where in a let in a lambda? :p
04:13:14 <hexagoxel> but that smells like ambiguity :(
04:13:42 <saurabhnanda> WHAT?! you can abstract of type-class constraints like that?!
04:14:01 <saurabhnanda> is that possible? that would probably solve a lot of record-related problems that I'm having!
04:14:16 <erisco> saurabhnanda, sure can, thank ConstraintKinds
04:14:48 <erisco> someone showed me we can use this to have type classes of type classes :)
04:15:41 <saurabhnanda> wow, let me try this..
04:16:41 <erisco> so now when libraries each come up with their own version of Semigroup, or whatever, we can abstract over all of them
04:17:11 <erisco> that's not really why it is useful, though ;)
04:18:45 * hexagoxel still fears that `l` above will be ambiguous. might need a Proxy, or TypeApplications.
04:19:02 <erisco> a good use for it is to let your users define their own ah-hoc polymorphic functions to use with your library
04:19:33 <erisco> ah-hoc polymorphic functions are implemented with type classes, and thanks to ConstraintKinds your library can define an interface for such type classes (which is itself a type class)
04:20:42 <erisco> if I grokked it right, this is an alternative to tagging classes
04:21:01 <erisco> a little less clunky
04:22:33 <lamdevhs> hi! i'd like to know what you all think of purescript, esp, if it is stable for the part of haskell's functionalities that it implements
04:23:00 <erisco> I suspect that's a question for the PureScript channel and not the Haskell channel
04:24:42 <lamdevhs> hm yeah i could, but i'd have liked the opinion of haskellers
04:25:12 <erisco> I am sure you will find some Haskellers in the PureScript channel
04:25:35 <erisco> it'd be a shame to have a PureScript channel and not let them have the PureScript discussions in it
04:27:04 <lamdevhs> ok
04:33:09 <merijn> So, what's the simplest way to limit how long accept blocks on a socket?
04:38:10 <erisco> … a hammer
04:42:41 <[exa]> merijn: never succumb to accept
04:43:02 <merijn> [exa]: hmm?
04:43:24 <[exa]> reasonable polling mechanism is usually required (accept(2) syscall doesn't have any kind of timeout itself, afaik)
04:43:44 <merijn> [exa]: accept is the only thing that Network.Socket exposes
04:43:51 <saurabhnanda> why is GHC complaining about duplicate instances here? Both the instances have different parent constraints -- https://gist.github.com/saurabhnanda/9743dd829d8f3dc455dacbc795c4b4ee
04:44:03 <[exa]> merijn: does it have select ?
04:44:41 <merijn> [exa]: No, because the functions use the RTS to block, so you just use blocking operations on sockets
04:45:18 <barrucadu> saurabhnanda: Constraints aren't involved when deciding which instance to select
04:45:18 <[exa]> :( 
04:45:42 <merijn> [exa]: How is a socket being ready for select handled with select? Is it marked "readable" when a connection is available?
04:45:53 <saurabhnanda> barrucadu: what's the alternative to express this?
04:46:06 <[exa]> merijn: exactly
04:46:52 <merijn> [exa]: ok, that should be doable
04:47:14 <merijn> [exa]: Can just extract the fd from the socket, block until it's readable and only then call accept
04:47:22 <merijn> Should probably make a PR to network for that
04:47:24 <[exa]> merijn: similar thing may be handy with connect(), when a non-blocking connect finishes, socket is marked writeable
04:47:33 <saurabhnanda> I need to define two separate instances -- one for records which have a pk=() and another which have pk/=()
04:47:56 <erisco> saurabhnanda, this is possible but will take some explaining… are you familiar with type families?
04:48:04 <barrucadu> I suspect you'll need to rethink the problem you're trying to solve
04:48:25 <saurabhnanda> erisco: yes, I am. 
04:48:32 <merijn> [exa]: Actually, network internally already deals with blocking before calling accept
04:48:40 <[exa]> merijn: I don't have any good idea about how haskell's networking works internally so I cannot say.
04:48:41 <merijn> [exa]: I think I can just use timeout
04:49:00 <merijn> [exa]: GHC's runtime system is just a big kqueue/epoll loop internally
04:49:04 <erisco> okay good, so I imagine you had no problem defining an instance for pk = () but am not sure how to say pk ≠ ()
04:49:07 <merijn> [exa]: You have 
04:49:13 <[exa]> oh so, lol.
04:49:26 <merijn> "threadWaitRead :: Fd -> IO ()"
04:49:31 <erisco> is that correct?
04:49:47 <merijn> [exa]: Which basically blocks the Haskell thread until kqueue says you can work non-blocking
04:50:18 <merijn> [exa]: So the network library does "threadWaitRead sock >> c_accept sock" so it only call accept when the syscall won't block
04:50:49 <merijn> [exa]: I think my question was really whether something like "timeout" already exists in the runtime, which it does :p
04:51:04 <saurabhnanda> erisco: the problem is a little complicated. it is `HasId x ()` and anything other than `HasId x ()`
04:51:59 <merijn> [exa]: So I just want "timeout myTime (accept sock)" and that returns me "Maybe Socket" depending on whether the timeout fired or not
04:52:53 <[exa]> that should work in that case :]
04:53:15 <erisco> saurabhnanda, okay, state your problem clearly so I am not trying to solve the wrong thing
04:53:46 <saurabhnanda> erisco: very hard to state... without having to explain the underlying architecture.
04:53:47 <erisco> saurabhnanda, what instances do you want? use pseudo code if necessary
04:53:58 <saurabhnanda> erisco: let me try a simpler approach. If that doesn't work, then I'll come back.
04:54:17 <erisco> your instance heads should be more or less two lines of code, for two instances, so that should be easy enough to state
04:57:21 <ertes-w> merijn: i could imagine that Network.Socket's accept is not a direct API mapping, but uses some other epoll-based mechanism under the hood…  if you're lucky, you can just use System.Timeout
04:58:02 <ertes-w> merijn: but then it's probably better to just use a different thread
04:58:29 <merijn> ertes-w: I just said it did :)
04:58:55 <ertes-w> merijn: ah, sorry, i didn't read the whole backlog =)
04:59:14 <erisco> saurabhnanda, simpler is always better, unless you're making a puzzle. If you need this complication, then look at how I defined an instance for a -> b and another for not a -> b http://hackage.haskell.org/package/control-dotdotdot-0.1.0.0/docs/src/Control-DotDotDot.html
05:00:14 <ertes-w> merijn: not sure about the side effects of timing out an 'accept' though…  you might drop almost-established connections
05:00:56 <merijn> ertes-w: Well, accept is a syscall so it can't be interrupted by timeout, afaict
05:01:19 <merijn> ertes-w: So you can only get interrupted before calling it
05:01:42 <ertes-w> merijn: sounds like the -threaded RTS would run it in its own thread and just kill the thread on timeout
05:02:06 <ertes-w> or, as i said, it might not use accept(2) at all
05:02:39 <ertes-w> (or only use it once it *knows* that there is a connection pending)
05:03:30 <merijn> ertes-w: I'm not sure if an exception thrown during syscall gets received after it returns or not
05:04:01 <merijn> because then you'd have succesfully accepted and lose the socket reference leaving it in limbo...
05:06:26 <ertes-w> merijn: works in GHCi
05:06:38 <merijn> ertes-w: I think it's a theoretical race
05:06:46 <ertes-w> yes, it's almost definitely a race
05:06:57 <merijn> ertes-w: Since, if you're extremely unlucky you get the following sequence of events
05:07:39 <ertes-w> merijn: yeah, i know what the race looks like…  that's why i wouldn't do it…  use a separate thread instead
05:07:43 <merijn> network blocks on socket to have a connection. connection arrives. network calls accept. timeout expires, throws exception during accept. accept returns after accepting connection and gets immediately interrupted
05:08:02 <merijn> ertes-w: What do you mean by "use a separate thread"?
05:08:05 <ertes-w> however, i'd like to think that accept doesn't actually suffer from this, because it should be prepared to handle ThreadKilled
05:08:08 <merijn> How would that solve my issue?
05:08:28 <merijn> ertes-w: Eh, how would it handle that?
05:08:32 <ertes-w> (how else would one terminate a server cleanly?)
05:08:43 <merijn> ertes-w: You're supposed to use accept inside a bracket
05:09:19 <merijn> ertes-w: accept doesn't do anything to handle
05:09:37 <ertes-w> merijn: i mean specifically the race condition you just mentioned
05:09:49 <merijn> ertes-w: How would accept possible deal with that?
05:09:54 <merijn> ertes-w: FYI, it doesn't
05:10:03 <ertes-w> if the thread receives an exception just before returning from 'accept', at least the client socket should be closed
05:10:36 <merijn> ertes-w: It does no such thing atm
05:10:49 <ertes-w> that's bad
05:10:50 <merijn> ertes-w: And fixing it to do that seems nearly impossible
05:10:58 <merijn> ertes-w: I wouldn't know how
05:12:25 <ertes-w> merijn: i'm not familiar with the internals of the 'network' library, but at least in principle this seems easy to fix to me, *if* it uses epoll rather than a blocking 'accept' in a separate thread
05:12:47 <merijn> ertes-w: network doesn't touch epoll, it just uses the RTS internals which deal with epoll
05:12:48 <ertes-w> because then you can do the actual 'accept' call in an uninterruptibly masked thread
05:13:31 <merijn> ertes-w: How would that help?
05:13:40 <merijn> ertes-w: https://hackage.haskell.org/package/network-2.6.3.2/docs/src/Network-Socket.html#accept
05:14:13 <merijn> ertes-w: It already uses threadWaitRead to block (using epoll, kqueue, whatever) until accept succeeds. However, that doesn't solve the race when it does decide to call accept
05:15:28 <merijn> ertes-w: The problem is that while c_accept4 runs (and right after it returns) an exception will fuck up your day and leak the connection.
05:15:37 <ertes-w> one way to solve this would be to wrap Socket such that you could attach a finaliser
05:15:44 <merijn> ertes-w: But I don't see how you can possibly extend a bracket to handle that
05:16:19 <merijn> ertes-w: because the bracket *will* end before accept does
05:16:36 <ertes-w> merijn: yes, the only way i see is to use GC
05:16:55 <ertes-w> add a finaliser, so if a connection is leaked, at least it will be picked up by GC
05:18:41 <merijn> ertes-w: That's not simple to implement, though
05:19:41 <merijn> ertes-w: https://github.com/haskell/network/issues/166
05:20:02 <merijn> In general network seems a bit undermaintained and brittle
05:20:47 <stevenxl> Hello folks. I want to add the package Data-Text to my stack project, but I don't know what to add to my project's cabal file. In general, when I want to add a package to my project, how do I know what the "name" of the package is so I can put it in the cabal file? 
05:20:59 <merijn> I don't have the windows knowledge to fix it in a portable manner, though
05:21:26 <merijn> stevenxl: Well, how do you normally find out which packages you want to add?
05:22:03 <ertes-w> merijn: well, MkSocket has an MVar field…  i know it's a hack, but you could attach a finaliser to that MVar
05:22:25 <merijn> ertes-w: Yes, but that has to be within an uninterruptible part close to the FFI call, etc.
05:22:43 <stevenxl> merijn: Someone on the github issue said to change `String` to `Text` so I went to hoogle to see where I can find a data type called `Text`. Which led me to this page (https://hackage.haskell.org/package/text-1.2.2.2/docs/Data-Text.html) so I tried to add data-text, but then I realized that the package name is after the `/package/` part of the url.
05:23:33 <merijn> stevenxl: On that page there's a "Contents" link in the top right, which takes you to the package main page which lists names, versions, etc.
05:24:38 <ertes-w> merijn: i think the only way to really solve this is to have two actions instead of one:  one to wait for a connection, and one to accept it…  then in application code wrap the accept part in a mask
05:24:46 <stevenxl> merijn: :-)
05:25:44 <merijn> stevenxl: Although I usually just look at the URL, tbh :)
05:25:45 <ertes-w> merijn: then you can use 'catch' to handle synchronous exceptions and 'onException' to reset the connection on asynchronous ones
05:26:35 <stevenxl> merijn: hah - I did the same, but glad to know that link is there. 
05:26:47 <stevenxl> when that "shortcut" doesn't work I'll know what to do
05:26:50 <tabaqui> how is made SomeException type?
05:26:59 <tabaqui> why I can catch any exception as SomeException?
05:27:22 <tabaqui> how can I write my own Exception that can/cannot be catched as SomeException?
05:27:31 <ertes-w> tabaqui: because it's handled specially by the exception API
05:27:37 <ertes-w> tabaqui: you can't
05:28:29 <tabaqui> then SomeException is some special structure, that cannot be written using pure haskell?
05:28:32 <ertes-w> SomeException covers *all* exceptions, including your custom ones
05:28:33 <merijn> stevenxl: The shortcut should always work, though, because the url is derived from the package name and I don't think hackage allows anything else that doesn't work :)
05:29:06 <merijn> tabaqui: SomeException is implemented in Haskell (although maybe not Haskell 2010, I think it uses a few extensions)
05:29:24 <ertes-w> tabaqui: no, SomeException is transparent…  it's basically just Dynamic with an extra constraint
05:29:42 <ertes-w> so it uses ExistentialQuantification
05:29:53 <merijn> tabaqui: Control.Exception links to a few good papers on how it works in the docs
05:30:16 <ertes-w> tabaqui: the special nature of SomeException is encoded in the exception *functions*
05:30:37 <ertes-w> since Exception implies Typeable they *know* that you're catching SomeException, so they will give you *all* exceptions
05:32:00 <tabaqui> oh, that is not good
05:32:11 <tabaqui> second article is not free, but third looks fine
05:32:16 <tabaqui> thanks for the answers
05:34:40 <merijn> tabaqui: Try Google Scholar, pretty good at finding free PDFs
05:34:47 <merijn> tabaqui: And else use sci-hub
05:35:49 <tabaqui> if Elbakjan has opened it for my country :)
05:35:56 <ertes-w> tabaqui: if you understand how Data.Dynamic works, you understand 99% of how Control.Exception works
05:36:20 <tabaqui> ertes-w: it is very important note
05:36:50 <tabaqui> never seen this module before
05:37:55 <ertes-w> well, that wasn't a fair statement, because haskell exceptions come with a lot of extra complexity (async exceptions, masking, etc.)
05:38:17 <ertes-w> but at least you understand 99% of how the "exception hierarchy" works and how catchers know which exceptions to catch
05:46:20 <merijn> ok, so, simplest/most efficient way to turn a bunch of ascii digits from a ByteString into an Int? Any suggestions
05:47:25 <merijn> ertes-w: btw, attaching a finaliser to the MVar wouldn't be safe either
05:47:44 <merijn> ertes-w: Since inlining/whatever might cause it to run before the socket is actually done
05:48:11 <ertes-w> merijn: yeah, to make this really safe requires wrapping all of it in an IORef or something like that
05:48:26 <tabaqui> merijn: is "read '5'" slower then "ord '5' - 48"?
05:48:49 <ertes-w> merijn: https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString-Char8.html#g:23
05:49:16 <merijn> tabaqui: no clue?
05:49:20 <ertes-w> not sure how efficient it is though
05:49:29 <merijn> ertes-w: \o/
05:49:37 <ertes-w> tabaqui: (read '5') is a type error
05:49:37 <merijn> ertes-w: Well, I don't really need it that often
05:51:23 <tabaqui> merijn: I mean, why don't you just (read . BC.unpack)?
05:51:47 <merijn> because apparently readInt exists?
05:51:59 <ertes-w> also because BC.unpack is a bad idea
05:52:18 <tabaqui> if it's too slow, you can foldl with ((- 48) . BC.ord)
05:52:36 <tabaqui> * and multiply by ten
05:53:13 <ertes-w> but…  readInt exists…
05:53:45 <tabaqui> oops, right
05:54:14 <merijn> I really hope NumDecimals goes into Haskell Prime...
05:56:21 <tabaqui> you think it will be released before Half Life 3?
05:57:43 <tabaqui> oh, 2020
05:57:46 <tabaqui> it is so soon
06:08:15 <ertes-w> as a german i think in grander time scales…  the release of half life 3 is nothing, if you need to capture the time spans necessary to talk about the fate of the universe or the launch of the berlin airport
06:18:05 <pandem> hl3 was scheduled waaay before berlin airport
06:27:55 <maerwald> any haskeller tried F#? How was the experience?
06:28:37 <erisco> maerwald, my experience was "well, if I have to"
06:28:58 <ertes-w> maerwald: mine was terrible…  it was: "well, at least it has more reasonable syntax than C#"
06:29:24 <epta> maerwald: everything is in IO, what kind of experience do you expect?
06:29:58 <maerwald> epta: how is that a problem? OCaml has the same property
06:30:05 <ertes-w> i was promised monads, but didn't get them…  i was promised functional programming, but the libraries didn't play along…  i wasn't even promised laziness or good concurrency
06:30:50 <epta> maerwald: it's hard to reason about anything, since effects are everywhere
06:30:50 <maerwald> I don't care so much about monads or laziness, just whether functional programming is practical or if it ends up being functional syntax with little functional practicalit
06:31:00 <maerwald> epta: depends
06:31:07 <[exa]> let's rename F# to IO.NET
06:31:14 <erisco> that's the primary conflict with F#… it is a language designed to work on .NET, and the rest of .NET is not functional
06:31:15 <ertes-w> if you're used to haskell, F# will not make you happy
06:31:34 <maerwald> well, F* is not complete enough :>
06:32:08 <maerwald> maybe I wait for that then
06:34:14 <ertes-w> you need to write .NET code?
06:34:41 <maerwald> nah, I'm just bored with poor rust bindings, so I am looking for some fun
06:34:44 <erisco> TypeScript is a language designed to work with JavaScript, and JavaScript is not typed
06:35:05 <erisco> you can imagine the painful dissonance
06:35:55 <maerwald> (fun as in: there is an actual ecosystem to be used)
06:38:10 <ertes-w> there was a functional language with a great type system, reasonable bindings and library availability, good performance and a more or less mature ecosystem…  what was it called again?
06:38:24 <maerwald> OCaml
06:38:59 <ertes-w> there you go
06:39:19 <merijn> Whoo! And done...dramatically improved my life with a 5x speedup in the time it takes for ghc-mod to check my code in vim :)
06:54:17 <linduxed> merijn: what did you do?
06:54:47 <merijn> linduxed: none of the vimplugins use ghc-mod's interactive/daemon mode, which means nothing gets cached
06:54:54 <linduxed> ah
06:55:05 <linduxed> not too surprising
06:55:06 <merijn> linduxed: I wrote a simple wrapper that spawns a daemon interactive process and talks to it
06:55:33 <linduxed> i would assume that deoplete suffers from the same problem?
06:55:44 <merijn> linduxed: Which functions as drop-in replacement with, for example, neomake. Should be pretty trivial to update the other plugins
06:55:53 <merijn> linduxed: No clue, I don't know/use deoplete
06:56:12 <linduxed> oh, wait, ghc-mod is not for completion
06:56:15 <linduxed> it's a linter
06:56:17 <linduxed> yeah
06:56:21 <linduxed> neomake is the one i ues
06:56:40 <merijn> linduxed: I think ghc-mod can do completion too
06:57:01 <merijn> linduxed: gimme a sec to finalise my vimrc and I'll link you the way it works
06:59:47 <merijn> linduxed: actually, I'll just copy the relevant bits
07:01:38 <merijn> linduxed: https://github.com/merijn/ghc-modid
07:01:47 <merijn> linduxed: Needs more testing before I put it on hackage
07:02:18 <merijn> linduxed: Just build that and put the ghc-modid executable in your path somewhere, then add this to your .vimrc: http://lpaste.net/1485035026205638656
07:02:59 <merijn> linduxed: The autocommands start the daemon when you open a haskell file (and stop it when every haskell file for a project is closed) and the neomake change just tells it to run ghc-modid instead which talks to the daemon
07:04:41 <merijn> linduxed: I'm playing around with a timeout that will keep the daemon alive for X minutes after closing the last one in case you reopen a haskell file in the project. It's like 150 LOC so not that hard to mess around with :)
07:04:52 <clayrat> hey guys, how can I make cabal use https when downloading from hackage?
07:05:15 <linduxed> merijn: thx, i'll definitely have a look!
07:05:50 <merijn> linduxed: If you run into any issues, lemme know because I haven't tested it beyond "works on my machine" :p
07:05:59 <orion> What component of the build process should be inspecting PKG_CONFIG_PATH?
07:22:08 <Shaunthesheep[m]> Ich mache es MORGEN
07:22:27 <Shaunthesheep[m]> ups.
07:22:51 <JazzyEagle> Immer Morgen, und dann nie immer ist fertig.
07:24:25 <wz1000> Is there a way to generate warnings for specialized types?
07:24:28 <Shaunthesheep[m]> Ich lasse den Einwand gelten. ABER: Es ist SOOOOO langweilig.
07:29:09 <JazzyEagle> Was ist?
07:30:07 <JazzyEagle> (Nur so weißt du:  Ich lerne Deutsch.  Ich bin nicht jetzt fließend.)
07:30:43 <JazzyEagle> Sie...  I kennen Sie nicht.  Ich muß Sie nutzen.
07:31:04 <Shaunthesheep[m]> There might be german rooms ...
07:31:07 * JazzyEagle thinks he needs to give up trying to speak German for the day.
07:31:18 <JazzyEagle> I'm still waking up and keep making mistakes.
07:31:54 <JazzyEagle> Yes, there are some.  I don't frequent them often, as I don't typically have a lot of time to focus on chatting.  I just saw your comment and felt like responding.  :)
07:33:24 <Shaunthesheep[m]> Was nice! thank you. I understood your message well.
07:36:55 <JazzyEagle> Awesome.  :)
07:36:59 <JazzyEagle> Dankeschön
07:46:05 <Psybur> Anybody know how to convert a Data.Fixed.Pico to an Int? By truncating the fractional part?
07:49:28 <erisco> Psybur, I am guessing you use floor
07:49:48 <Hafydd> Psybur: Data.Fixed.Pico is an instance of Real.
07:51:45 <ertes-w> Psybur: via RealFrac
07:52:02 <ertes-w> @let import Data.Fixed
07:52:04 <lambdabot>  Defined.
07:52:29 <Hafydd> Oh, yes, Real and Fractional.
07:52:40 <ertes-w> > [ceiling, floor, round, truncate] <*> [5.8 :: Pico]
07:52:42 <lambdabot>  [6,5,6,5]
07:52:50 <ertes-w> > [ceiling, floor, round, truncate] <*> [-5.8 :: Pico]
07:52:52 <lambdabot>  [-5,-6,-6,-5]
07:53:02 <Psybur> THanks, floor did it
07:53:29 <ertes-w> Psybur: note the difference between 'floor' and 'truncate'
07:54:03 <erisco> maybe you want to convert to… whatever a trillion pico is called
07:54:13 <Psybur> ertes-w, noted
07:55:31 <Psybur> Also you guys dont happen to know of an article that has LOTS of examples of when to use the different types of folds? I think Im slowly getting it. LIke foldl goes down the left rabbit hole before applying what it found to the right, and foldr takes the left side and applies it to the right rabbit hole D:
07:56:29 <Psybur> I just feel like an exhaustive list of real world examples would be immensely helpful
07:56:33 <erisco> I'm running late
07:57:05 <erisco> > foldr f z [a,b,c]
07:57:07 <lambdabot>  f a (f b (f c z))
07:57:12 <erisco> > foldl f z [a,b,c]
07:57:14 <lambdabot>  f (f (f z a) b) c
07:57:21 <erisco> these are the pictures I keep in my head
07:58:51 <Psybur> > foldr (+) 0 [1..]
07:58:58 <lambdabot>  mueval-core: Time limit exceeded
07:59:25 <Psybur> > foldl (+) 0 [1..]
07:59:31 <lambdabot>  mueval-core: Time limit exceeded
07:59:43 <Hafydd> -1/12
07:59:43 <erisco> that's wrong… it should be -1/12 I think
07:59:49 <Hafydd> Haha.
07:59:52 <erisco> :D
07:59:58 <Psybur> Hmm, thought it would give a partial list for foldr but nothing for foldl
08:00:17 <Hafydd> Psybur: you thought the return value of foldr would be a list?
08:00:23 <Hafydd> Better go back to that documentation.
08:00:25 <Psybur> Oh whoops
08:00:29 <Psybur> Yeah brain fart
08:04:21 <Psybur> > foldr (:) [] [1..]
08:04:23 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
08:04:46 <Psybur> > foldl (flip (:)) [] [1..]
08:04:53 <lambdabot>  mueval: ExitFailure 1
08:08:09 <erisco> > scanr (+) 0 [1..]
08:08:15 <lambdabot>  mueval-core: Time limit exceeded
08:08:20 <erisco> > scanl (+) 0 [1..]
08:08:22 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
08:12:00 <erisco> @define consecPairs = zip <*> drop 1
08:12:02 <lambdabot>  Defined.
08:14:10 <erisco> @define diff1 = fmap (uncurry subtract) . consecPairs
08:14:12 <lambdabot>  Defined.
08:14:19 <erisco> @define diff2 = diff1 . diff1
08:14:21 <lambdabot>  Defined.
08:14:37 <erisco> > diff1 (scanl (+) 0 [1..])
08:14:39 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
08:14:46 <erisco> > diff2 (scanl (+) 0 [1..])
08:14:48 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:14:56 <erisco> thought that'd be fun
08:15:28 <Psybur> So now with scan its flipped?! scanl works with infinite lists and scanr doesnt? :D
08:15:41 <BernhardPosselt> is there a super easy explanation how the reader monad works?
08:15:45 <BernhardPosselt> cant wrap my head around it
08:15:59 <erisco> BernhardPosselt, what examples confuse you?
08:16:24 <BernhardPosselt> the passing of the context
08:16:43 <erisco> so are you not sure how >>= works?
08:17:49 <BernhardPosselt> > (+1) >>= Just 5 
08:17:52 <lambdabot>  error:
08:17:52 <lambdabot>      • Couldn't match expected type ‘a -> a -> b’
08:17:52 <lambdabot>                    with actual type ‘Maybe Integer’
08:18:01 <BernhardPosselt> ehm, or was it reversed :D
08:18:20 <erisco> either way is a type error
08:18:22 <BernhardPosselt> but yeah, cryptic infix functions confuse me
08:18:31 <BernhardPosselt> i know flatMap from scala
08:18:33 <erisco> write it prefix then
08:18:50 <erisco> (>>=) (+1) (Just 5)
08:18:55 <BernhardPosselt> rihgt :)
08:19:17 <erisco> give it a name… flatMap = (>>=) … I don't know what flatMap is in Scala though
08:19:38 <BernhardPosselt> so what functions do i pass in?
08:19:45 <BernhardPosselt> functions that take that parameter i guess?
08:19:54 <erisco> pass in to what?
08:20:33 <BernhardPosselt> > (>>=) (+ 1) (Reader 5)
08:20:36 <lambdabot>  error:
08:20:36 <lambdabot>      • Data constructor not in scope: Reader :: Integer -> a -> a -> b
08:20:36 <lambdabot>      • Perhaps you meant one of these:
08:21:43 <BernhardPosselt> lets say my function expects an integer
08:21:48 <BernhardPosselt> the environment
08:22:16 <BernhardPosselt> how is the environment passed to my function?
08:22:21 <erisco> first, what is the type of (>>=) when m = Reader r ?
08:24:56 <BernhardPosselt> :t (>>=)
08:24:59 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:25:21 <BernhardPosselt> Reader r a -> (a -> Reader r b) -> Reader r b 
08:25:43 <erisco> so, those are the things you need to give to >>=
08:25:47 <BernhardPosselt> ah
08:26:03 <Iceland_jack> BernhardPosselt: GHCi can fill those in for you, if you use TypeApplications
08:26:14 <Iceland_jack> >>> :t (>>=) @(Reader _ _)
08:26:23 <BernhardPosselt> so basically each reader carries around the r
08:26:24 <Iceland_jack> sorry, @(Reader _)
08:26:37 <BernhardPosselt> and the ask function is just a "getter"
08:26:48 <erisco> sure
08:27:22 <erisco> you don't have to know how it is implemented, you can just use the effect ask and move on to do greater things
08:27:40 <erisco> but if you want to know how it works, you can try implementing >>= yourself
08:27:56 <BernhardPosselt> thats what i actually want to do
08:28:10 <BernhardPosselt> move it to an other language
08:28:22 <Iceland_jack> It can help without the Reader newtype
08:28:54 <erisco> the one you find in a library is probably a ReaderT anyways, which complicates the understanding
08:29:02 <Iceland_jack> Yes
08:29:03 <BernhardPosselt> MonadReader
08:29:06 <mniip> % :t (>>=) @((->) _)
08:29:06 <yahb> mniip: (>>=) @((->) _) :: (w -> a) -> (a -> w -> b) -> w -> b
08:29:13 <Iceland_jack> >> :t (>>=) @((->) _)
08:29:13 <Iceland_jack> (>>=) @((->) _) :: (t -> a) -> (a -> t -> b) -> (t -> b)
08:29:23 <erisco> suffice it to say,  newtype Reader r a = Reader { runReader :: r -> a }
08:30:08 <erisco> so we can just peel back Reader and figure out how to implement >>= for m = (->) r
08:31:07 <erisco> first thing to do is, as before, look at the type
08:32:07 <Iceland_jack> The newtype / record syntax complicates things so much... newtype Reader r a = Reader { runReader :: r -> a } ..... newtype Reader r a = Reader (r -> a) ... type Reader r a = r -> a ... type Reader = (->)
08:32:13 <Iceland_jack> obscures*
08:33:40 <dsal> Module ‘Data.Map’ does not export ‘(!?)’  -- what's that all abou?
08:33:41 <erisco> the jump from newtype to type is… treacherous
08:34:01 <Iceland_jack> "..." denotes representational equality ;)
08:34:09 <erisco> uh huh, sure ;)
08:37:50 <wz1000> is it possible to get warnings if the type signature is more specialized than the infered signature?
08:39:00 <erisco> hopefully not when the inference is ambiguous
08:39:41 <erisco> you wouldn't want  minBound :: Int  complaining, for example
08:40:44 <erisco> I could be wrong, but I don't suspect GHC infers the type if a type has been given
08:40:59 <erisco> rather it just checks that the term has the given type
08:41:51 <erisco> otherwise, there are situations where GHC thinks something is nonsense but with a bit of nudging (type annotations) it sees the reason
08:42:12 <erisco> that wouldn't be possible if it was stuck at trying to infer types
08:42:50 <ertes-w> dsal: try using one of the more specific modules like Data.Map.Strict
08:42:57 <ertes-w> in most cases Data.Map is the wrong module anyway
08:43:16 <dsal> Yeah, I'm just doing the exercism thing.  I couldn't get !? imported in any case.  Thought that was odd.
08:44:06 <orion> If I have a product-profunctor defined for: data Foo = Foo a b c { fooA :: a, fooB :: b, fooC :: c }, and I have type HaskellFoo = Foo Int Int Int; type OpaleyeFoo = Foo (Column PGInt4) (Column PGInt4) (Column PGInt4), how do I convert between the two?
08:44:53 <fizbin> Has anyone else come across a time when they needed a type that looked like (bar -> IO (IO foo)) ? I recently have, and every time I see that type it still looks wrong, but that's really what I need there.
08:45:39 <BernhardPosselt> ah i think i understood the reader monad with https://www.youtube.com/watch?v=K6BmGBzIqW0 at ~40 mins
08:46:02 <fizbin> Plus, I can't talk about that code without having the Dwarves' work song from Snow White run through my head.
08:46:45 <BernhardPosselt> you construct a reader and then run it
08:47:00 <BernhardPosselt> without running it it is not evaluated correct?
08:47:11 <BernhardPosselt> kinda like a Stream which is evaluated with collect()
08:52:49 <erisco> Haskell is nonstrict, and so things are not evaluated until needed
08:54:59 <erisco> operators such as >>= let us build up a  Reader r
08:55:31 <erisco> and what is the definition of  Reader r  ?  (->) r  so we can say we are building a function
08:56:04 <orion> Here's a more specific question: If I have a "a", "b", and "p a b" where p is a ProductProfunctor, how do I convert a -> b?
08:56:21 <erisco> if we are building a function, no, nothing particularly exciting happens until we give it an argument
08:56:24 <mbrock> fizbin: I've used `IO (IO a)` to denote a process you can start, and then wait for, in my case a potential downloading of an URL
08:57:28 <mbrock> fizbin: the implementation was in essence `v <- newMVar; forkIO (download url >>= writeMVar v); return (readMVar v)`
08:58:34 <mbrock> could have used `IO (MVar a)` but I didn't want the user to know about the MVar at all
08:58:52 <mnoonan> fizbin, closest I could find in recent code was a "MVar [IO ()] -> IO (Maybe (IO ()))" that grabs the next IO action off of a shared stack.. so you aren't totally crazy :)
08:59:08 <mniip> orion, profunctors need not necessarily be functions
08:59:15 <mniip> or anything resembling them
08:59:19 <fizbin> mbrock: Yeah, my case is dealing with threads too - in my case it's passing in a callback that will be invoked after "accept" gives a new connection, and then the returned action will get run in the thread that's forked to handle that connection.
09:00:05 <mbrock> it's a pretty nice example of what `join` means, I think
09:00:27 <Iceland_jack> At work we have a lot of: IO (A -> B -> IO C)
09:00:59 <fizbin> mbrock: except "join" squashes stuff all to the same thread.
09:01:45 <erisco> Iceland_jack, that seems odd. Why that and not  A -> B -> IO C  ?
09:02:34 <erisco> -> happens to be one of the things you can pull out of IO :)
09:03:19 <erisco> my favourite example is pulling out lists
09:03:32 <Iceland_jack> You lose information going that direction, you may want to construct the (A -> B -> IO C) but never run (IO C)
09:04:05 <mniip> (->) is distributive iirc
09:04:12 <fizbin> mbrock: I imagine in your case that you could call sequence >=> sequence on a [IO (IO a)] list to fork a whole bunch of things in parallel, then wait for them all.
09:04:13 <mniip> and can be pulled out of anything
09:04:41 <mbrock> fizbin: ah, yeah, something like that was the use case
09:05:20 <fizbin> :t sequence >=> sequence
09:05:21 <lambdabot> (Traversable t, Monad m) => t (m (m a)) -> m (t a)
09:05:25 <erisco> mniip, I dunno, if I hand you F (a -> b) and hide all the constructors I don't think you're going to find a -> F b
09:05:45 <monochrom> IO (A -> B -> IO C) gives you a reusable A -> B -> IO C that you can keep reusing with different inputs of A and B.
09:05:54 <mniip> erisco, Functor F
09:06:14 <erisco> do you think I'll be so kind?
09:06:29 <monochrom> And the outer IO means that what you obtained depends on the environment, too.
09:06:36 <mniip> :t Data.Distributive.distribute @((->) _)
09:06:38 <lambdabot> error: parse error on input ‘->’
09:06:40 <monochrom> err, I guess s/depends/depended/
09:06:45 <mniip> % :t Data.Distributive.distribute @((->) _)
09:06:45 <yahb> mniip: Data.Distributive.distribute @((->) _) :: Functor f => f (w -> a) -> w -> f a
09:07:56 <erisco> I don't see how it changes the information
09:08:25 <erisco> :t \mf a b -> mf >>= \f -> f a b
09:08:26 <lambdabot> Monad m => m (t1 -> t -> m b) -> t1 -> t -> m b
09:08:36 <erisco> :t return :: Monad m => (a -> b -> m c) -> m (a -> b -> m c)
09:08:37 <lambdabot> Monad m => (a -> b -> m c) -> m (a -> b -> m c)
09:09:01 <erisco> we can go through and prove these are inverses
09:14:25 <xdelv> Hey guys, trying to set up a VM for liquid haskell. Anyone know if there's a distro that has packages for both GHC 7 and an SMT solver?
09:14:37 <xdelv> Anything old enough to have GHC 7 doesn't seem to have z3/cvc4/mathsat
09:16:07 <erisco> I feel stuck at  \x -> return (\a b -> x >>= \f -> f a b)
09:16:30 <erisco> (\mf a b -> mf >>= \f -> f a b) . return = id  but stuck in the other direction, thinking…
09:17:55 <erisco> the other possibility is that they are *not* inverses, heh
09:17:58 <mbrock> xdelv: you can install both on any distro using Nix
09:18:07 <mbrock> xdelv: or you can use NixOS for bonus points :)
09:19:44 <erisco> and if not, this should highlight just what the difference is
09:20:28 <xdelv> mbrock: Thank you! Completely overlooked how perfect Nix is for this situation. NixOS it is, need to learn it more anyway. :D
09:23:24 <mbrock> $ nix-shell -p haskell.compiler.ghc7103 --run "ghc --version"
09:23:24 <mbrock> The Glorious Glasgow Haskell Compilation System, version 7.10.3
09:24:39 <mbrock> there's even binaries for 6.x
09:26:27 <erisco> I dunno, my puzzler is fuzzled
09:28:54 <Iceland_jack> It might help to think of: putStrLn "Initialize" $> \a b -> print (a, b)
09:29:41 <ertes-w> xdelv: if you decide to go with nix, you don't even need a VM
09:30:00 <ertes-w> you can set up closed environments for GHC
09:31:34 <erisco> okay, so a counter example like  u $> g  … I'll look at that
09:31:51 <mbrock> yeah, good point. It's still probably a nice thing to play with a NixOS VM for a while to fully drink the kool-aid ;)
09:32:11 <mbrock> (but Nix working well on other distros and even Mac is really awesome)
09:38:11 <erisco> so I get to  return (\a b -> u >>= \_ -> g a b)  with a fast and loose step on the way
09:39:03 <xdelv> ertes-w: yeah, I might go that route in the future, but right now adding a second package manager that I don't 100% know to my daily-driver laptop seems like it might be a headache lol
09:39:23 <erisco> it is not evident to me that this is not equivalent to  u $> g
09:40:16 <xdelv> actually have thought about switching to NixOS completely, just need to learn it some more first I think
09:40:34 <erisco> it in fact feels hella similar
09:40:43 <mbrock> xdelv: just fyi, you can basically get rid of Nix on non-NixOS via `rm -rf /nix`, that's part of the beauty of it being such a self-contained system :)
09:41:12 <mbrock> (you'll still have some leftover Nix conf dotfiles in your home directory, but nothing that will impact the rest of your system)
09:41:23 <xdelv> ..oh that's a little more tempting then
09:42:17 <xdelv> here I was having nightmares of pip+pacman-scale issues lol
09:42:48 <mbrock> that is the nightmare from which Nix is the awakening! ok I'm getting a bit too evangelical...
09:44:05 <ertes-w> xdelv: warning: nix has a learning curve, and it takes some time to really understand how it works and how to use it for haskell development/deployment…  but if you ask me, it's well worth the price
09:45:04 <ertes-w> and once you know that you can transfer that knowledge to other programming languages and system tasks
09:50:52 <xdelv> ertes-w: sounds right up my alley actually, similar motivation to why i want to get more into haskell
09:51:06 <vaibhavsagar> xdelv: join us in #nixos
09:51:51 <xdelv> vaibhavsagar: done! sorry if that got a little off-topic for #haskell
09:52:51 <vaibhavsagar> no worries :)
09:53:01 <erisco> it feels good that  return (\a -> x >>= \f -> f a) = x
09:55:13 <erisco> maybe need some parametricity … of which I know none
09:57:58 <monochrom> If return (\a -> x >>= \f -> f a) = x, then return (\a -> x >>= \f -> f a) >> return () = x >> return (). Do you think it really holds now?
09:58:48 <kotangent> Newbie question here. I have three packages A, B, and C. A depends on B and B depends on C. All packages are in git repos. For B, I added the details for C’s git/commit in the stack.yaml. B compiles fine. I then open A’s stack.yaml and include B’s git/commit, same as in B’s configuration. 
09:58:53 <kotangent> When I try and build A, I am getting dependency errors, “B must match -any, but the stack configuration has no specified version”. All versions are 0.1.0.0.
09:58:57 <kotangent> Any suggestions?
09:59:17 <erisco> monochrom, that doesn't look obviously wrong to me
09:59:47 <monochrom> OK, after applying monad laws, return () = x >> return ()
10:02:58 <cocreature> kotangent: you depend on cabal projects not on stack projects, in particular the stack.yaml files of your dependencies are completely irrelevant
10:03:17 <cocreature> kotangent: you thus have to add C to the stack.yaml of A as well
10:07:49 <erisco> monochrom, which law did you use?
10:08:05 <kotangent> cocreature: so I have both B and C in my stack.yaml for A, and I still get that must match -any message
10:08:10 <erisco> my thinking is railroaded real hard
10:08:12 <monochrom> return w >>= f  =  f w
10:08:44 <AWizzArd> I write a function foo in which I want to call a function f which is part of a type class T. GHC’s compiler can’t add a concrete address to which to jump when f is called, because there are many implementations for f. Is this solved with runtime-dispatch?
10:08:55 <monochrom> return w >>= \_ -> return ()  =  (\_ -> return ()) w  =  return ()
10:09:03 <AWizzArd> Or is there a secret/hidden argument in foo, and when I call it GHC also provides the correct f?
10:09:10 <cocreature> kotangent: hm, can you show us the full content of your stack.yaml and the cabal file of A?
10:09:20 <cocreature> kotangent: and the full error message
10:11:15 <monochrom> AWizzArd: The type of foo will carry a constraint like "T a =>". Also, which actual f to call is resolved statically at users of foo.
10:11:18 <kotangent> cocreature: unfortunatly, no. I'll keep reading, good opportunity learn about haskell build processes. Thanks for the help
10:11:42 <AWizzArd> monochrom: okay, so something which is a bit like my second idea.
10:11:53 <AWizzArd> As if there was a secret argument to foo, a pointer to the correct implementation of f.
10:12:29 <nshepperd_> If return (\a -> x >>= \f -> f a) = x, doesn't that mean your monad has no effects
10:13:28 <monochrom> That is why I drove a contradiction with "return () = x >> return ()"
10:13:32 <AWizzArd> monochrom: is this possibly solved with pointers, under the hood?
10:13:38 <Limeth_> Any easy way to convert `IO [T]` into `[T]`?
10:13:46 <monochrom> Yes.
10:13:52 <erisco> yes I was just talking about that :)
10:13:57 <erisco> it is interesting, I think
10:14:02 <AWizzArd> monochrom: okay good, so this will save time to lookup the function at runtime. Nice nice.
10:14:28 <monochrom> But "pointer" is astonishingly tautological. A typical compiler like GHC uses pointers for everything.
10:14:31 <mniip> Limeth_, no
10:14:34 <erisco> Limeth_, however, if you go through and figure out the answer, you'll probably find the result is unusable, because it is partial
10:14:55 <glguy> (\_ -> []) :: IO [t] -> [t]
10:15:17 <erisco> well you can be much more interesting than that
10:15:26 <monochrom> Well, \_ -> [] doesn't count as conversion.
10:15:40 <dolio> Says who?
10:15:43 <mbrock> Limeth_: that's a common desire when you start with IO in Haskell, but probably you need to re-think a bit
10:15:44 <glguy> monochrom: 
10:15:46 <monochrom> ME
10:15:59 <mniip> :t \xs -> [(!! i) <$> xs | i < [0..]]
10:16:02 <lambdabot> error:
10:16:02 <lambdabot>     • Couldn't match expected type ‘Int’ with actual type ‘Expr’
10:16:02 <lambdabot>     • In the second argument of ‘(!!)’, namely ‘i’
10:16:09 <mniip> :t \xs -> [(!! i) <$> xs | i <- [0..]]
10:16:10 <lambdabot> Functor f => f [b] -> [f b]
10:16:37 <nshepperd_> erisco: "Monad m => m (t1 -> t -> m b) -> t1 -> t -> m b" combines together the effects from outer and inner m. You can make a new outer m with return but it won't have its fair share of effects
10:16:37 <erisco> yeah I should have said it was IO [a] to [IO a]
10:16:41 <Limeth_> mbrock: Yes, I am learning haskell with the cis194 course, but didn't get to the chapter addressing IO yet.
10:16:54 <mbrock> Limeth_: in a way the very meaning of Haskell being a pure language is that you can't go from `IO a` to `a`
10:17:21 <erisco> so, the fun thing is that you can take out the list, spine, but only infinite ones!
10:17:35 <monochrom> OK so none of the exercises require IO[T]->[T], in fact most exercises don't even require IO.
10:17:49 <erisco> if you were able to do otherwise you would uncover the length, and that would leak information
10:18:29 <mniip> erisco, well,
10:18:31 <erisco> IO (Stream a) -> Stream (IO a)  can be implemented total
10:18:33 <mniip> if it has a fixed spine
10:18:38 <mniip> then it is representable
10:18:42 <mniip> and hence distributive
10:18:55 <mbrock> Limeth_: however, you can get access to the value inside the IO value, but only in order to construct a new IO value... it's kind of like safety gloves
10:19:22 <erisco> mniip, what do you mean? what I am saying is we can choose how many cells we take out of IO, but not dependent on any information within
10:19:22 <mniip> oops
10:19:24 <Limeth_> Hmm, okay
10:19:35 <erisco> so taking infinite cells is one option, taking zero is another (that is glguy's example)
10:19:40 <erisco> taking 10 is a third option
10:19:50 <mniip> erisco, no I mean if you have a datatype whose tree is always fixed
10:20:01 <mniip> such as type-indexed vectors, or Stream
10:20:10 <mniip> such data are distributive
10:20:27 <erisco> Stream is coinductive … what do you mean by fixed?
10:20:49 <mbrock> Limeth_: inside of `do` blocks is where you get access to values like that, but the final result value of the `do` block will also be tagged as `IO`
10:20:49 <erisco> tuples work too
10:20:58 <nshepperd_> Fixed, not variable
10:20:59 <dolio> It means pick any N, not just infinity.
10:21:18 <Limeth_> I guess I'll wait until I get to the chapter about IO
10:21:32 <dolio> If you assume your list has exactly that size (I.E. you're not actually dealing with lists), then you can do it.
10:21:38 <mbrock> Limeth_: yeah, it's one of the biggest things to get your head around when learning Haskell
10:21:42 <monochrom> @type (\m -> liftA3 (\xs ys zs -> xs ++ ys ++ zs) m m m)
10:21:44 <lambdabot> Applicative f => f [a] -> f [a]
10:21:57 <monochrom> Oh nevermind.
10:22:05 <mniip> erisco, if the type is...
10:22:08 <mniip> logarithmiable
10:22:18 <mniip> which is apparently just another word for representable
10:22:24 <erisco> you'll have to explain that one to me
10:23:04 <mniip> F representable <=> exists X. Fa \iso a^X, natural in a
10:23:08 <mbrock> Limeth_: but basically because of this "purity", if you have some function that doesn't return some `IO` value, like say `sqrt :: Float -> Float`, then you can know that using this `sqrt` will not cause any I/O or side effects (like, it's definitely not going to try to open a log file or something)
10:23:12 <nshepperd_> T a = (U -> a) for some U
10:23:25 <erisco> okay I give up
10:23:28 <mniip> iow
10:23:38 <nshepperd_> Streams satisfy this, with U = Natural
10:23:39 <mniip> X = ln_a Fa
10:24:04 <Limeth_> mbrock: Ah, that's pretty handy, good to know.
10:24:06 <mbrock> Limeth_: and Haskell programmers usually try to do as much as possible without using `IO`, because such code is really nice and clean and predictable
10:24:49 <crucify_me> hi is the recursion in the where clause, here in the split function?   https://ptpb.pw/2wG7
10:25:00 <nshepperd_> erisco: what's so difficult about "fixed size"?
10:25:29 <lightstep> crucify_me, yes
10:25:44 <nshepperd_> Lists have a variable size because they can be [] or [a,b] or ...
10:25:45 <lightstep> crucify_me, why?
10:26:03 <erisco> because it was said Stream has a fixed size, and I have a difficult time accepting that
10:26:12 <crucify_me> lightstep, thanks, I'm rather naive
10:26:16 <nshepperd_> Streams have a fixed size because they always contain infinite elements
10:26:32 <mbrock> Limeth_: ...which makes it so that Haskell encourages some pretty interesting program designs; one pattern is to have a "pure core" that does all your calculations and decisions, and then a relatively simple I/O layer "around" it, and this has some very nice benefits...
10:26:45 <erisco> stretching the meaning of "size"…
10:26:52 <crucify_me> lightstep, why ...
10:26:59 <Limeth_> I see
10:27:44 <mbrock> Limeth_: ...but yeah, it's probably best to hold out until the course gets to I/O. If you google around there's quite a lot of explanations of Haskell I/O that aren't actually all that helpful, so it's unfortunately easy to get confused
10:27:49 <crucify_me> why is it set up with the tuple like that? I'm not sure I see how that works
10:27:51 <nshepperd_> Steam is isomorphic to a function from the natural numbers
10:28:42 <lightstep> on the last line?
10:28:46 <nshepperd_> Fixed sized vectors are isomorphic to functions from finite sets (Z_n)
10:28:55 <crucify_me> lightstep, so does that mean for as long as the tuple is incomplete, it will recurse?
10:28:56 <Zyxoas> Hello y'all.
10:29:16 <crucify_me> yeah the last line
10:29:35 <lightstep> the recursion is triggered by the "otherwise" condition, that is y >= x
10:29:46 <Zyxoas> Inspired by this GHC proposal: https://github.com/treeowl/ghc-proposals/blob/magic-reflection/proposals/0000-magic-reflection.rst I tried to implement a reflection thingie, but based on TypeApplications and concrete instances.
10:30:03 <nshepperd_> Vec n a = (Fin n -> a)
10:30:05 <lightstep> the tuple syntax in the last line is to break down the result of "split", which is a tuple
10:30:58 <erisco> monochrom, yes that works, thanks
10:31:26 <erisco> works for some, not-so-interesting monads, and not generally
10:32:20 <crucify_me> so the last y is consed to the greater list, then the tuple has nothing to cons, so it triggers the recursion with (less, greater)  ?  is that how to think of it?
10:32:29 <crucify_me> lightstep, 
10:33:02 <erisco> so, in conclusion, if you have  f :: A -> B -> m C  then  return f  is reversible
10:33:22 <lightstep> no, the stuff under "where" runs first
10:33:40 <erisco> but if you have  mf :: m (A -> B -> m C)  a conversion to  A -> B -> m C  is not
10:33:56 <lightstep> if y >= x, it calls "split x ys", and separates the result into (less, greater), then combining it to (less, y:greater)
10:38:37 <crucify_me> right, lightstep thank you. one thing..
10:39:29 <crucify_me> (less, greater) on the last line, does that express a state (ie, incomplete tuple of 2 lists) ?
10:39:43 <lightstep> yes, exactly
10:39:45 <Zyxoas> As I was saying, I tried doing my own variation of reflection: http://lpaste.net/358450
10:40:20 <Zyxoas> But I seem to have screwed it up. Can someone please help me understand why I can't seem to fit all the pieces together? :-)
10:40:24 <crucify_me> excellent.. my coffee worked ! thanks kindly lightstep 
10:40:34 <lightstep> np :)
10:42:03 <erisco> crucify_me, I got 5 hours of sleep last night… will coffee fix that?
10:48:36 <Zyxoas> Ambiguous type variables? I'm in way over my head...
10:51:49 <Limeth_> How can I create anonymous functions (lambdas)? Doing `filter (== 2) [1, 2]` works, but something like `filter (x = x == 2) [1, 2]` doesn't.
10:52:03 <lightstep> Limeth_, it's (\x -> x == 2)
10:52:16 <glguy> Zyxoas: You're missing a bunch of extensions at the top of your file
10:52:32 <glguy> Zyxoas: If that's because you're using other-extensions in a .cabal file, this is a good example of why you shouldn't be doing that
10:52:45 <Zyxoas> Yep. I am. Sorry. glguy
10:52:52 <Zyxoas> Might they be pertinent?
10:52:53 <Limeth_> lightstep: Ah, thanks
10:53:04 <Zyxoas> let me edit the lpaste quickly...
10:53:07 <glguy> Zyxoas: What you pasted doesn't load in GHC, so yeah it matters
10:54:24 <glguy> Zyxoas: Also your instances don't make sense. 'Widget and 'Doodah don't have kinds Type, so you can't make those instances
10:59:00 <dsal> Is there a more convenient way to write / builtin variant of this:
10:59:01 <dsal> succ' :: (Bounded a, Enum a, Eq a) => a -> a
10:59:01 <dsal> succ' x
10:59:01 <dsal>   | x == maxBound = minBound
10:59:01 <dsal>   | otherwise = succ x
10:59:31 <Zyxoas> glguy those must be typos from trying my luck with writing code sans a compiler!
11:07:47 <barrucadu> dsal: You can drop the Eq constraint by using fromEnum, but it's still not great
11:08:07 <dsal> Without eq, it can't match the minbound/maxbound
11:08:12 <Zyxoas> Apologies once again, glguy. The code has been cleaned up now, and only the real problem remains: http://lpaste.net/358450
11:08:35 <barrucadu> succ' :: forall a. (Bounded a, Enuma) => a -> a; succ' x = if fromEnum x == fromEnum (maxBound :: a) then minBound else succ a
11:09:19 <dsal> Oh, I see.
11:09:30 <barrucadu> This avoids the forall: succ' x = if ((==) `on` fromEnum) x maxBound then minBound else succ a
11:09:38 <barrucadu> Whoops, "succ x"
11:10:17 <Zyxoas> In the real code I'm trying to fix, the Doodah on line 39 is actually a variable that iterates over a list of data constructors. I wanna see if I can somehow reflect only a single one -- tell GHC to ignore all other instances of Reifies x Thing except for the one I give it...
11:19:14 <dsal> OK, I can't figure out how forall works.
11:19:38 <dsal> I was trying this:
11:19:41 <dsal> > succ' :: forall a. (Bounded a, Enum a) => a -> a; succ' x = toEnum $ (succ $ fromEnum x) `mod` fromEnum (maxBound :: a)
11:19:43 <lambdabot>  <hint>:1:49: error: parse error on input ‘;’
11:20:19 <monochrom> You used "mod" there.
11:20:37 <barrucadu> forall requires ScopedTypeVariables.  I'd probably just use the '(==) `on` fromEnum' one though
11:21:02 <barrucadu> In fact I think I have used that one, when I wanted to solve this exact problem and found there was no standard function :(
11:21:23 <dsal> I was using mod so I could run off the edge and then wrap around easily.  It *almost* works, except I don't know the type name..
11:21:32 <monochrom> @type mod
11:21:34 <lambdabot> Integral a => a -> a -> a
11:22:13 <dsal> Yeah, I've fromEnum'd my enum.
11:23:33 <dsal> Though it's acting... not like what I want.
11:24:07 <dsal> I clearly don't understand forall.
11:24:23 <monochrom> @type \x -> toEnum $ (succ $ fromEnum x) `mod` fromEnum (maxBound `asTypeOf` x)
11:24:24 <lambdabot> (Bounded a1, Enum a1, Enum a) => a1 -> a
11:24:42 <monochrom> Oh I see.
11:25:32 <monochrom> @type \x -> toEnum (succ $ fromEnum x) `mod` fromEnum (maxBound `asTypeOf` x)
11:25:32 <dsal> I'm missing it -- it seems to be getting the wrong maxBound
11:25:33 <lambdabot> (Bounded a, Enum a) => a -> Int
11:26:49 <lyxia> Zyxoas: http://lpaste.net/358450#a358456 your reify was too ambiguous
11:27:28 <monochrom> > let {s :: forall a. (Bounded a, Enum a) => a -> a; s x = toEnum $ (succ $ fromEnum x) `mod` fromEnum (maxBound :: a)} in s True
11:27:32 <lambdabot>  False
11:27:36 <monochrom> Works for me.
11:27:55 <dsal> Yes, it seems to return like, 1 for maxBound
11:28:05 <dsal> My type has four values, and it goes   v1, v2, v1 ...
11:30:34 <monochrom> I have a meta-comment on methods of learning and testing.
11:31:01 <monochrom> Do you use solely this example to determine whether or not you understand forall.
11:31:14 <dsal> No.  I'm trying to make a succ' that wraps.
11:31:39 <monochrom> Or do you have a million examples and you can get forall to work in all other examples except this one.
11:31:42 <dsal> My initial implementation worked, but required Bounded, Enum, and Eq
11:31:52 <dsal> I have one example and it doesn't work.
11:31:55 <monochrom> Because if the former, that's a confirmation bias.
11:32:19 <dsal> data Bearing = North | East | South | West deriving (Bounded, Ord, Enum, Eq, Show)
11:32:28 <monochrom> And if the latter, it seems it's pretty clear what's the real culprit.
11:33:34 <dsal> λ> map succ' [minBound..maxBound] :: [Bearing]
11:33:34 <dsal> [East,South,North,East]
11:34:28 <Zyxoas> Thanks so much, lyxia! :-D
11:34:28 <monochrom> > let {s :: forall a. (Bounded a, Enum a) => a -> a; s x = toEnum $ (succ $ fromEnum x) `mod` fromEnum (maxBound :: a)} in s South
11:34:31 <lambdabot>  error: Data constructor not in scope: South
11:34:36 <erisco> that's what happens when you're standing on the West pole
11:34:37 <dminuoso> How do you folks type things like λ usually? Do you have custom input method? Do you just google for them and copy/paste?
11:34:50 <dminuoso> I have a feeling nobody is going to remember their unicode codepoints
11:34:51 <Zyxoas> Damn. I was hoping I could avoid proxies, though. Otherwise I would have no need for TypeApplication...
11:34:53 <monochrom> OK I'm going to add Bearing to lambdabot
11:35:04 <monochrom> @let data Bearing = North | East | South | West deriving (Bounded, Ord, Enum, Eq, Show)
11:35:06 <lambdabot>  Defined.
11:35:09 <monochrom> > let {s :: forall a. (Bounded a, Enum a) => a -> a; s x = toEnum $ (succ $ fromEnum x) `mod` fromEnum (maxBound :: a)} in s South
11:35:11 <lambdabot>  North
11:35:35 <monochrom> > maxBound :: Bearing
11:35:37 <lambdabot>  West
11:35:41 <erisco> dminuoso, I type <ctrl> <*> <l> and I can do this thanks to WinCompose, which is based on XCompose
11:35:46 <monochrom> > fromEnum (maxBound :: Bearing)
11:35:49 <lambdabot>  3
11:36:12 <Zyxoas> In particular, the Given class in Kmett's reflection library does not use proxies...
11:36:14 <monochrom> > fromEnum (minBound :: Bearing)
11:36:16 <lambdabot>  0
11:36:44 <monochrom> > length [minBound .. maxBound :: Bearing]
11:36:47 <lambdabot>  4
11:37:02 <erisco> > map succ [minBound..maxBound] :: [Bearing]
11:37:04 <lambdabot>  [East,South,West,*Exception: succ{Bearing}: tried to take `succ' of last tag...
11:37:15 <monochrom> I think this is enough clues.
11:37:39 <erisco> no modulo cardinals? oh well
11:37:52 <monochrom> Ah I should have also checked "s False".
11:38:43 <monochrom> P.S. You will run into a similar problem in Python.
11:44:35 <jle`> Zyxoas: given can avoid proxies because there is only one value associated with every type
11:44:56 <jle`> Zyxoas: but with Reifies, there is potentially more than one thing you can reflect from a given type
11:45:47 <jle`> er acutally,, sorry, everything i just wrote as wrong
11:45:49 <jle`> ignore me :)
11:47:06 <dsal> dminuoso: M-x insert-char RET lambda   or C-/ and then it's just \lambda
11:51:44 <lyxia> Zyxoas: reify :: a -> (forall s. Reifies s a => r) -> r   would be the true type, but AFAICT there is no way to call that function due to how type checking works.
12:00:54 <dsal> monochrom: so, off by one error?  This implementation isn't much more satisfying, though. :(
12:01:27 <monochrom> I don't know what counts as satisfying.
12:04:41 <nisstyre> cocreature: thank you!
12:06:08 <pgiarrusso> lyxia, would the runST trick apply here? or LANGUAGE Rank2types? runST has a similar type, and IIRC rank-2 generalizes that?
12:06:17 <pgiarrusso> lyxia, that's knowing nothing about what that function does, only the type you've shown
12:25:50 <just-wanna-try-h> hi! is this the right place to ask super-nooby installation questions?
12:27:00 <geekosaur> here or #haskell-beginners, the latter may be preferable when it's busy in here
12:28:06 <cocreature> doesn’t seem to be very busy atm :)
12:28:17 <just-wanna-try-h> cool thanks!
12:29:29 <just-wanna-try-h> soo i just tried installing stack and it seemed to work fine, but whenever i try running any stack command (i just want the REPL) it gives me a weird error along the lines of "503 slow down"
12:30:05 <just-wanna-try-h> which seems especially strange to me since i don't see why i should be connecting to a server just to use ghci
12:31:00 <geekosaur> if you have installed only stack, then the first time you use it it will try to download resolver information and install a ghc
12:31:02 <just-wanna-try-h> i think it's trying to connect to haddock.stackage.org/snapshots.json (i see this url in the error text)
12:31:55 <just-wanna-try-h> that makes sense. so maybe i'm just super unlucky and chose the worst time to try out haskell? -_-
12:32:47 <geekosaur> seems like it. or their provider is doing maintenance or something
12:33:40 <tomasmu> 503 sounds like an http error code, means "service unavailable"
12:33:50 <just-wanna-try-h> gotcha. well that's a bummer, but also i'm glad it's not my fault haha
12:33:54 <just-wanna-try-h> thanks for your help!
12:41:03 <bbear> hello, I would like to have a function to flatten a tree into a list of list.
12:41:08 <bbear> Do you know how I can do that ?
12:44:44 <raynold> ahh it's a wonderful day
12:48:18 <StrangeLoop> Hi, I want to define a class for heap, derived by stuff which have heap functionality. I don't understand how to define classes for data types with parameters. Specifically, if I have "class (Ord a) => Heap a", how would you write the signature for "find_min"?
12:52:51 <mnoonan> StrangeLoop: something like "find_min :: Ord a => Heap a -> Maybe a", most likely
12:53:50 <geekosaur> Heap's a class though
12:54:01 <geekosaur> and the Heap constraint would imply Ord
12:54:16 <mnoonan> oops, sorry, I read too quickly :|
12:54:54 <geekosaur> without knowing the element type somehow, this is difficult. either you need a functional dependency or an associated type family for the element type
12:55:38 <mnoonan> wait, that's a pretty weird constraint. The "Ord a" makes me think that "a" is supposed to be the element type
12:55:41 <StrangeLoop> mnoonan: I tried that, the compiler says "    Expected a type, but `Heap a' has kind `GHC.Prim.Constraint'"
12:55:46 <geekosaur> class Ord a => Heap h where type Elem h; find_min :: Heap h => Maybe (Elem h)
12:57:05 <mnoonan> geekosaur, surely "Heap h => h -> Maybe (Elem h)" ?
12:57:23 <geekosaur> probably
12:57:35 <StrangeLoop> What's Elem?
12:57:48 <geekosaur> an associated type family that holds the element type of the heap
12:58:33 <mnoonan> StrangeLoop, you have two types that are important here.. the type h of your heap (constrained by Heap h), and the type a of elements of your heap (constrained by Ord a)
12:58:34 <StrangeLoop> That's exactly what I was trying to avoid
12:58:44 <geekosaur> you cannot avoid it
12:58:52 <StrangeLoop> That was my question, I guess
12:58:59 <mnoonan> well, you could do multi-parameter typeclasses I guess
12:59:01 <geekosaur> how is it supposed to know otherwise?
12:59:28 <StrangeLoop> I thought maybe there was a way to tell it
13:00:08 <mnoonan> you could do "class Ord a => Heap h a | h -> a where find_min :: h -> Maybe a", I think
13:00:14 <geekosaur> hypothetically, with TypeApplications one could annotate every use of it
13:00:18 <geekosaur> but I do mean *every* use of it
13:03:25 <geekosaur> basically, type inference is impossible in the presence of multiple-parameter type classes, unless you use functional dependencies. so every single use, however direct or indirect, would need to be annotated with the whole type
13:04:05 <StrangeLoop> So what I should infer from all this is that my approach is wrong?
13:04:41 <mnoonan> It's fine, you just have to have an associated type family or something.
13:04:41 <geekosaur> (type families accomplish the same thing as functional dependencies, in a different way. but it still has the same limitations, it will not let you have Elem h resolving to both (say) Bool and Int)
13:05:10 <bbear>  > foldl (flip (:)) [] [1..1000]
13:05:45 <Psybur> > foldl (flip (:)) [] [1..1000]
13:05:47 <lambdabot>  [1000,999,998,997,996,995,994,993,992,991,990,989,988,987,986,985,984,983,98...
13:05:55 <StrangeLoop> Will it be possible to implement a heap without using Elem?
13:06:03 <Psybur> > foldr (:) [] [1..1000]
13:06:05 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:06:22 <bbear> I don't know if I can fold my tree for each path.
13:07:08 <bbear> :t (map ((Tree.rootLabel explorationTree):) (map flattenTreeOne (map Tree.rootLabel (Tree.subForest explorationTree)) acc-1))
13:07:11 <lambdabot> error:
13:07:11 <lambdabot>     Not in scope: ‘Tree.rootLabel’
13:07:11 <lambdabot>     No module named ‘Tree’ is imported.
13:07:18 <Psybur> > foldr (flip (:)) [] [1..1000]
13:07:19 <bbear> I do something like that right now but it's ugly.
13:07:20 <lambdabot>  error:
13:07:20 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ [a]
13:07:20 <lambdabot>        Expected type: [a] -> [a] -> [a]
13:07:38 <Psybur> ops :D
13:08:13 <geekosaur> StrangeLoop, naybe you need to explain in more detail exactly what you are trying to accomplish.
13:08:25 <StrangeLoop> Maybe
13:08:31 <geekosaur> because that question is like 'can I have a number without digits'
13:08:52 <StrangeLoop> OK, I can go with this analogy
13:08:59 <geekosaur> if you have a heap, and you need a constraint on the things it can hold, you need to know what it can hold
13:09:23 <mnoonan> StrangeLoop, here is maybe a simpler example: http://lpaste.net/358459
13:09:26 <StrangeLoop> I want to create a notion of a number, which has functions on the digits, but I don't know what the digits are, they could be any type
13:09:36 <geekosaur> then you cannot have an Ord instance
13:09:55 <StrangeLoop> OK, so not *any* type but any Ord
13:10:04 <geekosaur> then you must be able to talk about the type
13:10:10 <StrangeLoop> Yes
13:10:14 <geekosaur> you cannot be completely generic but with a condition
13:10:44 <geekosaur> er, completely polymorphic
13:11:02 <StrangeLoop> I don't want to be completely generic. I want the class heap to be implemented by types which have a type parameter which is ord
13:11:25 <StrangeLoop> Maybe class isn't the right notion though
13:11:39 <geekosaur> that is entirely possible
13:11:53 <geekosaur> if you are trying to OOP this, stop now. typeclasses are not OOP
13:12:18 <StrangeLoop> I'm not trying to OOP
13:12:31 <monochrom> Actually there is nothing OO about heaps so we are pretty safe.
13:12:43 <StrangeLoop> I'm trying to abstract a property, basically I'm trying to find the limitations of the language
13:12:44 <geekosaur> that said, I am wondering if you are confused about what the Elem associated type is 
13:12:56 <geekosaur> it is not an assertion that all possible heaps must have the same element type
13:13:00 <StrangeLoop> geekosaur: That could very well be the case
13:13:17 <geekosaur> it is a way to let each heap specify its own element type, in a way that lets you talk about it without knowing it in advance
13:13:35 <StrangeLoop> OK, so that's actually exactly what I hoped it was but thought it wasn't
13:13:36 <geekosaur> each heap instance
13:14:08 <StrangeLoop> Or more accurately, that's what I meant when I ask if whoever derives this class would have to use the name I give for this type
13:14:11 <erisco> hm, given Bounded a and Enum a, then Positional a is Integral, counting with a's in positional notation
13:14:20 <erisco> I wonder what else you can think up with that
13:14:40 <monochrom> I think you should read up on "type families" for real.
13:14:49 <geekosaur> no, whenever you make an instance, you specify what its Elem type is. (this may be polymorphic, it's up to the instance)
13:14:49 <geekosaur> and yes, you need to read up on type families
13:15:00 <erisco> Positional Bool  is base-2 numbers, for example
13:15:17 <monochrom> GHC users guide probably even have an example along your line IIRC.
13:15:19 <erisco> Positional ()  is base-1
13:15:20 <StrangeLoop> Yeah, I need to read up on type families
13:15:24 <StrangeLoop> Thanks for focusing me
13:15:55 <monochrom> Similarly, GHC users guide on functional dependency also has a container example.
13:16:38 <monochrom> Statistics show that 95% of the problems are solved in the GHC users guide.
13:16:38 <erisco> maybe interesting to think how you'd change bases
13:18:36 <monochrom> erisco: Can I use Positional Bool for type-level numbers?
13:18:58 <erisco> yes
13:19:45 <erisco> I didn't choose a representation for Positional yet, but we can have it be lists, with some convention for endianness
13:20:34 <erisco> it is a generalisation of Peano naturals, I suppose, since Positional () is represented by [()] which is iso to Nat
13:26:20 <bsima_> in pattern matching, what does the syntax '{..}' mean? It's hard to google for this...
13:27:44 <geekosaur> it's the RecordWildCards extension, and acts like you listed the name of every field in the record
13:27:53 <Tuplanolla> Does anyone use SubHask for anything? I was wondering how bothersome its compatibility with other libraries really is.
13:28:00 <bsima_> geekosaur: thanks!
13:29:08 <Tuplanolla> It has `WithPreludeOrd` to help with it, for example.
13:30:20 <`Guest00000> there is no way to conditionally either include a default method implementation using methods from another instance, if it exists, or not include a default implementation, right?
13:30:43 <`Guest00000> what is a deep reason for this?
13:31:03 <monochrom> There is no deep reason.
13:31:13 <monochrom> There is a shallow reason: Separate compilation.
13:31:45 <monochrom> Nothing is deep.
13:31:52 <pikajude> we'll have to use sonar to see how deep that reason is
13:32:10 <`Guest00000> i mean a type-theoretical one
13:32:17 <`Guest00000> or something
13:33:17 <geekosaur> I do not understand 'using methods from another instance, if it exists'
13:34:23 <geekosaur> the closest I can get to it making sense would have me point you to the DefaultSignatures extension
13:34:45 <`Guest00000> geekosaur: class B t where boo :: [t]; class C t where coo :: t; coo = head boo   -- like here
13:35:04 <`Guest00000> but head of C doesn't have constraint B so no
13:35:23 <geekosaur> maybe you do want DefaultSignatures then
13:35:31 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#default-method-signatures
13:35:56 <geekosaur> you can specify that the default implementation of a method has a constraint that is not imposed on all instances
13:36:10 <geekosaur> only on those that use the default implementation of that method
13:37:32 <`Guest00000> nice
13:37:39 <`Guest00000> ok thx
13:39:30 <monochrom> Ah but can you have two defaults?
13:44:29 <bbear> http://vpaste.net/dKDFT
13:44:35 <bbear> I don't manage to flatten my tree
13:44:40 <bbear> can you help ?
13:45:27 <monochrom> You have no type error, you're just getting wrong answer, is that right?
13:45:41 <bbear> no the answer is allright
13:45:44 <monochrom> Is "Tree" from Data.Tree?
13:45:47 <bbear> yes
13:45:57 <bbear> I don't find the correct recursion
13:46:43 <monochrom> Oh you mean you now want to generalize from flatOne and flatTwo to unlimited.
13:47:09 <monochrom> Is it OK if I asked you to write flatThree too?
13:47:19 <epta> trying to build 'bindings-gpgme', and it cannot find 'gpgme' C library and 'gpgme.h' header http://lpaste.net/2400502825697148928 . Adding '/usr/local/include' with gpgme.h inside (installed by 'brew install gpgme') probably fixed the issue with header, but library is still missing http://lpaste.net/3231347872398049280 . Any ideas how it's supposed to be built?
13:48:06 <bbear> monochrom: I tried but I failed
13:48:35 <monochrom> It is OK if flatThree calls flatTwo or flatOne to help.
13:48:56 <orzo> internal error: Invalid object in isRetainer(): 39 (BLOCKING_QUEUE) ; GHC version 8.0.2 for x86_64_unknown_linux
13:49:17 <orzo> should a retainer-profiled program crash when a BLOCKING_QUEUE object is passed to isRetainer() ?
13:49:23 <orzo> what is a BLOCKING_QUEUE
13:49:35 <orzo> i would like a work-around for thi sbug
13:50:01 <orzo> it makes retainer-profiling hard
13:52:07 <orzo> something to do with threads waiting on an evaluation
13:52:12 <orzo> that sounds like a valid retainer to me
13:52:52 <orzo> is there a channel for ghc hackers?
13:53:49 <bbear> monochrom : http://vpaste.net/NZ4yC
13:54:05 <bbear> the flatThree version is allright, but it discards empty forests.
13:54:12 <geekosaur> orzo, #ghc
13:54:13 <bbear> they are not anymore in the results
13:54:45 <geekosaur> epta, --extra-lib-dirs=...
13:55:17 <geekosaur> "..." might be /usr/local/lib since /usr/local/include was right for the header (brew sometimes installs in "casks" you have to specifically point to)
13:56:34 <bbear> okay fixed
13:56:48 <monochrom> bbear: flatOne (Node 10 [])  gives [], is this supposed to be good?
13:59:30 <epta> geekosaur: hm, it works. Btw, what are the default libs/headers folders that cabal is using? Is there a way to reinstall gpgme via brew there?
14:00:10 <geekosaur> the default is up to the C compiler it uses (both for C code and for linking)
14:00:48 <geekosaur> the default is likely to only look in /usr/bin and /usr/lib. brew is unlikely to install there and I strongly recommend not installing anything there
14:00:59 <bbear> noope
14:01:04 <geekosaur> otherwise Apple will make you very unhappy after an upgrade
14:01:05 <bbear> this is a case I must fix
14:01:27 <geekosaur> well, s/will/may/
14:02:17 <epta> geekosaur: okay. Can I at least specify these folders in cabal.project or somewhere like that? It's a bummer to add them to each cabal build (don't want to create a makefile also)
14:02:21 <geekosaur> and they will not care what breakage they cause, because those directories belong to Apple. with recent versions, it may not even *allow* you to install stuff there, not even as root, unless you disable their security stuff
14:02:34 <geekosaur> extra-include-dirs:, extra-lib-dirs:
14:02:57 <geekosaur> you can also add those to ~/.cabal/config
14:03:03 <bbear> I see the recursion now but I have some work to have it neat.
14:03:41 <Zemyla> When Linear Haskell hits, would adding a function to Ord of some kind called minMax :: (Ord a) => a -o a -o (a, a) be added?
14:04:21 <monochrom> That's a cool function to add. :)
14:05:01 <erisco> what does that mean, for those of us to don't know what -o is?
14:05:03 <dsal> Is there anything that does this?         a (a1, a2) (b1, b2) = (a1 + b1, a2 + b2)   -- I was surprised there's not an obvious thing that lets you just add a couple tuples together.
14:05:50 <knupfer> Has anyone a good implementation  of FingerTree on the type level?
14:05:59 <Tuplanolla> Several things, dsal.
14:06:10 <knupfer> I need fast consing, snocing and appending of type level lists
14:06:12 <epta> geekosaur: thank you, these 2 fields in cabal.project is perfectly fine
14:06:33 <erisco> knupfer, I took a quick look and what I am trying to grok is the motivation for the complexity of the types used
14:06:34 <Tuplanolla> It's a `Bifunctor`, a `Lens` and, with a wrapper, a `Monoid` too, dsal.
14:07:17 <erisco> knupfer, it seems to me that you could, for example, have definitions such as  html :: Head -> Body -> Html  to account for the schema of HTML
14:07:21 <dsal> Hmm...  I don't know lens and haven't gone to look into it yet.
14:07:59 <bbear> monochrome : http://vpaste.net/1zUmy
14:08:56 <Tuplanolla> > join biliftA2 (+) (42, 13) (20, 69) -- Like this, dsal.
14:08:59 <lambdabot>  (62,82)
14:09:23 <bbear> how do I write this to be recursive ?
14:09:51 <dsal> Tuplanolla: Thanks.  Every time I make a bit of progress, I feel like I've got entirely more to learn than can fit in my head.
14:10:04 <dsal> I almost kind of understand applicative a little.
14:10:05 <knupfer> erisco: That wouldn't be sufficient, because a lot of elements support a wide variaty of children
14:10:05 <Tuplanolla> > mappend (Sum 42, Sum 13) (Sum 20, Sum 69) -- Also like this, dsal.
14:10:08 <lambdabot>  (Sum {getSum = 62},Sum {getSum = 82})
14:10:26 <knupfer> writing that with a data would severely impact performance
14:10:41 <erisco> knupfer, what is such a complicated example?
14:10:51 <knupfer> besides there are a lot of elements which are possible children of various parents
14:10:59 <monochrom> Aww don't use "== []".  Use "null nodeList".
14:11:11 <knupfer> erisco: how would you type div?
14:11:41 <monochrom> OK so look at the code for flatFour.
14:11:42 <knupfer> div :: [Element] -> Div
14:11:42 <knupfer> ?
14:11:49 <monochrom> Rename flatFour to flat.
14:11:51 <knupfer> That wouldn't be efficient
14:12:08 <monochrom> Also, it calls flatThree, right? Call flat instead. (Yes, recursive call.)
14:12:11 <erisco> what part of it is not efficient?
14:12:30 <monochrom> No, Actually I am not sure of that.
14:12:50 <bbear> monochrom : http://vpaste.net/gMb52
14:13:13 <knupfer> erisco: ghc can't fully inline a data type that big, and this ominous Element data would have some ~200 children, and with this, type safety is again amiss
14:13:42 <erisco> we can define a class of types allowable in div
14:13:56 <erisco> each element has a type
14:13:59 <monochrom> I have something so much simpler than that. Do you want to see it?
14:14:31 <bbear> yes
14:14:45 <monochrom> OK it's just two lines so I'm going to just put it here.
14:14:59 <monochrom> paths (Node a ts)    | null ts = [[a]]
14:15:05 <knupfer> erisco: but still, you'd have a recursive type, the list, and therefore it won't be inlinable.
14:15:07 <erisco> if the desire is to have fully inlined a fold of the list, say, then yes, I don't think that is possible, but we can choose a different representation of lists
14:15:07 <monochrom>   | otherwise = map (a :) (concatMap paths ts)
14:15:10 <knupfer> at least not fully
14:15:28 <knupfer> (besides, just pushed a new version, compile times are now halved)
14:15:37 <knupfer> (with -O0 )
14:15:38 <lyxia> pgiarrusso: ST is a trick with scoping. Here it's a different problem, about type inference.
14:15:40 <erisco> okay, well, I guess this gets down to the nitty gritty, and I am not sure
14:16:31 <erisco> it seems strange to me that we need the document also in the type, or at least it looks like that is what you have done
14:16:40 <knupfer> erisco: If you use the signature of div from above, ghc won't know the length of the list at compile time
14:16:55 <ongy> knupfer: how long are we talking? minutes?
14:17:12 <knupfer> ongy: with -O0 about 2 seconds
14:17:20 <knupfer> ongy: for a medium sized page
14:17:29 <ongy> that's nothing
14:17:35 <knupfer> with -O2 about 1 minite
14:18:28 <ongy> less fun
14:18:39 <knupfer> erisco: What do you mean with Document? The constraint from the lib?
14:19:13 <knupfer> ongy: yeah, but deving is just fine. And you get 7 times faster html generation, which is type safe...
14:19:29 <erisco> I will toy around and see what happens
14:20:31 <knupfer> erisco: If you're talking about having for every element a proper type of kind element, that's intentional. Because of that we get 100% inlining and type safety.
14:23:48 <bbear> do you drink a lot irl ?
14:23:59 <monochrom> Water yes.
14:24:11 <bbear> okay
14:25:41 <bbear> your version is better I'd never thought of using data constructor in the function argument.
14:26:15 <bbear> have a good night
14:26:26 <bbear> (ps : could `fold` be useful in such a situation ?)
14:27:15 <monochrom> 7 litres of water a day makes you visit the washroom all day
14:27:42 <bbear> don't know if my room mates will be happy
14:28:03 <bbear> I don't have room mates actually
14:28:21 <knupfer> erisco: Perhaps one could sprinkle inlines in recurisive functions (not the pragma, the one from GHC.Magic), but not sure if it's possible to coerce ghc...
14:30:13 <knupfer> let me know if you find some other representation which allows 100% inlining, I'm genuinely curious
14:35:14 <Guest22327> I have an Aeson object - that when I print it's value is:   Object fromList [("authoritative",Object fromList [("transaction_committed",String "2017-09-14T20:35:39Z")])]
14:35:22 <Guest22327> how can i extract the property transaction_committed
14:36:00 <Guest22327> I just want the string value
14:36:46 <Guest22327> I thought I could do something to get it into a hashmap and then do a lookup, but I don't see any converter signatures like that
14:37:32 <lyxia> Guest22327: pattern match. case myvalue of Object hashmap -> {- lookup hashmap, etc. -}
14:37:33 <byorgey> Guest22327: you'll have to pattern-match on the Object constructors to get the HashMap
14:38:06 <Guest22327> cool, ok - trying
14:38:38 <lyxia> Lenses help too if you know how to use them.
14:40:09 <Guest22327> unfortunately this is an older project and adding lenses would probably require some updates
14:43:23 <Guest22327> i was trying to write something recursive that could check each type out and grab value if found, but my skills aren't that strong yet
14:50:41 <lyxia> let getString :: [Text] -> Value -> getString [] (String s) = s ; getString (key : keys) (Object h) | Just v <- HashMap.lookup key h = getString keys v in getString ["authoritative", "transaction_committed"]
15:01:28 <monochrom> Sob sob, no one wants to use decodeWith and the Parser type.
15:05:12 <monochrom> OK nevermind, decodeWith doesn't do what I think
15:05:57 <dminuoso> erisco, wincompose is brilliant :)
15:06:05 <Guest22327> sorry, Lyxia - I am a noob - trying to write that out with linebreaks and not fully clear..
15:06:30 <Guest22327> there are more linebreaks that the ; right?
15:07:48 <erisco> ghc -O -ddump-simpl -ddump-to-file test.hs  no Core file… what did I miss
15:08:31 <lyxia> Guest22327: yes ; is only for me to write unreadable one-liners on IRC
15:08:34 <monochrom> Oh "parse" is what I want.
15:09:19 <erisco> need to trigger a change in the source file… okay
15:10:25 <Unicorn_Princess> do mutable IOArrays contribute to garbage collection pause length? or rather, is there a way to allocate data without increasing GC time? does it help if the data is mutable/unboxed?
15:11:10 <Adeon> afaik unboxed data is more friendly to GC
15:11:14 <Adeon> less garbage collectable entities around
15:11:26 <Adeon> I don't know about mutable/immutable aspect though
15:12:03 <dminuoso> erisco, this is golden ∃∀∈∉
15:12:20 <erisco> dminuoso, (ノಠ益ಠ)ノ彡┻━┻
15:12:24 <dminuoso> Bit awkward to use at times with compose and shift key though
15:12:31 <dminuoso> Needs a pedal. ;-)
15:12:35 <lyxia> Unicorn_Princess: malloc/free from the Foreign interface for unmanaged memory
15:14:05 <Unicorn_Princess> lyxia: is that the only way? I heard some whispers about putting mutable arrays into compact regions or something
15:14:33 <monochrom> erisco: There is always -fforce-recomp
15:14:56 <erisco> thanks
15:16:13 <lyxia> Unicorn_Princess: that's another solution yes
15:17:01 <MarcelineVQ> erisco: -fforce-recomp
15:17:49 <Unicorn_Princess> how pleasant is working with unamanged memory in haskell?
15:17:58 <Unicorn_Princess> unmanaged*
15:18:40 <hpc> you have to treat it totally differently from normal programming, but it's possible
15:19:09 <hpc> it pretty much ends up looking like FFI code, except without any foreign imports or exports
15:19:22 <Tuplanolla> @hackage resourcet
15:19:23 <lambdabot> http://hackage.haskell.org/package/resourcet
15:19:25 <Tuplanolla> It works well with this.
15:26:39 <Unicorn_Princess> thanks. related question: suppose parts to your program required very low latency (UI, graphics, physics...), while some could get away with high latency (AI, inventory management, chat, ...) - how would you prevent the long GC times of one didn't interfere with the short GC times of the other? multiple processes and some form of interprocess communication (I know ~nothing about this)?
15:26:56 <Unicorn_Princess> s/didn't interfere/from interfering
15:27:32 <Tuplanolla> "If you need the database to be fast, we recommend not putting too much data in it."
15:27:38 <bbaren> Unicorn_Princess: If your program requires very low latency, Haskell is not currently the correct programming language for you. The GC is optimized for throughput, not latency.
15:28:30 <bbaren> See, for instance, https://making.pusher.com/latency-working-set-ghc-gc-pick-two.
15:28:45 <Unicorn_Princess> so I hear. but I also hear the GC is fast enough if the working set is small enough
15:28:57 <bbaren> That’s true.
15:29:08 <bbaren> So with that caveat, yeah, you want multiple copies of the RTS running in different address spaces.
15:33:27 <Cale> Or it's always an option to write some small portion of the application in another language, and have a Haskell thread making larger scale decisions about its operation.
15:50:21 <dmwit> glguy: Dunno if you remember, but a few months ago I asked on here about `data Exists c where Exists :: c a => a -> Exists c` and whether it existed on Hackage somewhere. We had some fun playing with variants. Anyway, today a reddit post pointed out that there is an `exists` package with that type. Yay, closure!
15:52:49 <monochrom> The time is ripe for a package "acme-doesn'texist"
16:06:21 <lightstep> Is there an extension fo modifyIORef for IO operations? That is, mutateIORef :: IORef a -> (a -> IO a) -> IO ()
16:06:45 <lightstep> implemented as mutateIORef ref f = writeIORef ref =<< f =<< readIORef ref
16:08:39 <jle`> there isn't really
16:15:43 <erisco> I made GHC's brain explode… whoops
16:53:14 <monochrom> modifyIORef comes with an atomic promise. Some locking is involved. This means it really doesn't want to perform arbitrary IO that takes unknown time that keeps the lock indefinitely and be a source of deadlocks.
16:54:50 <monochrom> You should also be skeptical of any of your own design that attempts both atomicity and generality.
16:55:55 <monochrom> Writing an explicit read-effect-write is a good way to remind the reader you are giving up atomicity in exchange for generality.
17:24:08 <ongy> then what's https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-IORef.html#v:atomicModifyIORef for?
17:34:52 <Cale> ongy: It does both the read and write atomically.
17:35:46 <ongy> monochrom claimed that modifyIORef has an atomic promis already. so I'm a bit confused
17:36:01 <monochrom> Oh!
17:36:43 <monochrom> I misremembered. modifyIORef is not atomic.
17:44:59 <exio4> TVar is atomic :) 
18:02:08 <plakband> I want to publish a package to hackage, but it was made in stack. Do I need to convert it to pure cabal first? Would I need to figure out version bounds on packages?
18:05:37 <MarcelineVQ> you can use stack sdist and stack upload to do the job  stack sdist has flag options to add bounds as well, use  stack sdist --help  to ask about them. I've not uploaded before so that's all I can say
18:06:33 <MarcelineVQ> looks like stack upload has the same options, so you may not need sdist
18:08:16 <MarcelineVQ> :( there doesn't seem to be much in the way of documenation about it beyond  stack upload --help
18:14:43 <plakband> MarcelineVQ: Thanks, I'll give it a shot!
18:15:27 <glguy> plakband: You'll need version bounds so that people depending on your package will will know what versions you support. the stack tool has some support for setting this bounds up for you when uploading
18:18:40 <plakband> glguy: Do you mean this flag? --pvp-bounds PVP-BOUNDS  How PVP version bounds should be added to .cabal
18:18:59 <glguy> Yeah, if you aren't going to keep track of the versions you support yourself yo ucan use that flag to set some
18:35:26 <mibaz_1> How fast is acid-state?
18:37:20 <MarcelineVQ> 20
18:37:33 <mibaz_1> wow
18:37:45 <MarcelineVQ> yeah
18:39:05 <mibaz_1> if acid-state is 20, how fast is mysql? ;)
18:39:31 <glguy> banana
18:40:11 <digitalkiwi> I thought it was at least purple fast
18:40:40 <boj> mibaz_1: the takeaway here is - test each for your given use case
18:41:10 <mibaz_1> where's the typechecker when you need it
18:41:31 <iqubic> Everywhere mibaz_1.
18:48:46 <mibaz_1> "AcidState is an absolute f*****g monster. The benchmarks it loses, it loses narrowly[1], but the benchmarks it wins, it wins by an 8x or larger margin." http://langnostic.blogspot.com/2013/03/haskell-benchmarking-third-impact-or.html
18:48:54 <mibaz_1> found it
18:50:11 <c_wraith> didn't hackage stop using acid-state due to performance issues?
18:51:20 <mibaz_1> who do you trust, hackage or a dude with "blogspot" in his url?
18:51:36 <mibaz_1> but if they did it would be good to know now
18:51:41 <iqubic> mibaz_1: It's the internet, so neither.
18:51:44 <c_wraith> I might be misremembering
18:51:52 <iqubic> But I trust hackage more.
18:52:47 <zq> i read this paragraph a while back about the distinction between using `error` versus returning Nothing.
18:53:09 <zq> is there anyone who might happen to have the link?
18:55:47 <mibaz_1> zq: I can help find it but do you have any more context?
19:00:28 <`Guest00000> from all these obscure type errors, i'm gonna get WET
19:01:04 <mibaz_1> "It's slow. It takes about 5 minutes for me to stop and then start the
19:01:06 <mibaz_1>   server.
19:01:19 <mibaz_1> https://mail.haskell.org/pipermail/cabal-devel/2012-September/009069.html
19:03:24 <digitalkiwi> 1G memory...oh my! Has he never used any other databases? /me regularly has postgres or mysql dbs that use 4GB+ :/ and they aren't even large dbs... mongodb would be massive methinks
19:04:25 <glguy> digitalkiwi: Before writing that message you'd want to go and find out how much data it took to hit that mark
19:05:03 <digitalkiwi> how much data was it
19:05:45 <digitalkiwi> the other reasons he didn't like it I totally agree with though
19:06:40 <mibaz_1> I wasn't sure what if his performance complaint referred to actual performance or some kind of tangential function ("restart the server")
19:06:48 <digitalkiwi> 5 minutes to start/stop makes me wonder why it takes so long though like...maybe it's so fast in that persons benchmarks because it's not actually committing or w/e
19:07:06 <mibaz_1> Yeah these mixed signals are rough
19:07:40 <iqubic> I don't use any databases, I don't understand their uses.
19:07:50 <digitalkiwi> on the other hand though I don't quite get why someone would be concerned with 5 minutes for something that is supposed to be running all of the time
19:09:28 <iqubic> Yeah. A five minute start-up time is nothing if you keep the thing running constantly.
19:09:41 <mibaz_1> "The bigger issue is the size of your dataset -- as it all needs to fit into RAM." https://groups.google.com/forum/#!topic/happs/X56dR1fstWo
19:09:58 <iqubic> Even a server that take 10 minutes to start is fine, provided you never turn it off.
19:10:06 <digitalkiwi> like my computer takes like ...10-30 seconds to boot, I've not timed it, and it's never been an issue, because 21:08  up 18 days, 18:22, 2 users, load averages: 1.34 1.45 1.50
19:10:12 <c_wraith> digitalkiwi: because you need to restart it every time you change the code - it's in-process
19:10:35 <digitalkiwi> but if it took 1 minute like in the old days of long boots and HDDs no biggie..
19:11:05 <c_wraith> digitalkiwi: and further, it's not safe for concurrent access, so you can't do any of the standard techniques for graceful restarts
19:11:20 <digitalkiwi> how often are you changing the live site code
19:11:45 <mibaz_1> Yeah I'm doing web dev so acid-state sounds like not a good idea.
19:12:36 <digitalkiwi> 5 minutes frequently does present issues, all of the other reasons he had were legit
19:13:31 <digitalkiwi> postgresql4lyfe
19:29:07 <dmj`> hackage uses acid-state, https://github.com/haskell/hackage-server/blob/master/hackage-server.cabal#L321
19:34:17 <mibaz_1> well, I know for sure that acid-state is either fast or slow or average
19:52:39 <orion> When using proc notation, what Arrow operator is implicit with each newline?
19:53:18 <orion> Is it (>>>)?
19:57:50 <geekosaur> looks like it, yes
20:00:04 <orion> Ok, well then consider this: https://github.com/tomjaguarpaw/haskell-opaleye/blob/master/Doc/Tutorial/TutorialBasic.lhs#L522
20:00:44 <orion> The first arrow gets bound to the name "birthday". The last arrow does "returnA -< bdDay birthday"
20:01:25 <iqubic> What does Proc do?
20:01:26 <orion> But no reference is made to the middle arrow.
20:02:00 <orion> iqubic: https://en.wikibooks.org/wiki/Haskell/Arrow_tutorial#Arrow_proc_notation
20:03:05 <orion> I don't fully grasp how the middle arrow affects things when no name is bound to it and no reference to it is made.
20:03:15 <orion> Maybe I don't understand opaleye's internal plumbing enough.
20:03:27 <iqubic> Yeah, I feel like arrows are a convoluted thing of the past.
20:04:41 <orion> Are they deprecated?
20:05:05 <lyxia> no
20:07:21 <iqubic> But I find that arrow plumbing is just a pain in the butt. Too many combinators.
20:11:23 <lyxia> I also never got it. It seems projects like opaleye are still living with it.
20:22:47 <dfeuer> @tell edwardk Well, if you have better ideas for names, or if you could maybe explain what this operation actually is, categorically (if anything), that would be awesome.
20:22:47 <lambdabot> Consider it noted.
20:23:26 <rotaerk> lambdabot, you're so helpful
20:29:58 <`Guest00000> how can i get most easily a lazy [Word8] of incoming bytes out of Handle?
20:31:22 <`Guest00000> which doesn't block on too few bytes
20:31:30 <pacak> Ugh.
20:32:06 <pacak> I suspect there's a better solution for your problem.
20:32:13 <`Guest00000> sure
20:32:17 <`Guest00000> a more complicates
20:32:17 <`Guest00000> d
20:33:15 <`Guest00000> haskell gave you laziness, you throw it away and make your own thing
20:33:20 <`Guest00000> more complex
20:33:39 <geekosaur> hGetSome ? laziness does not imply nonblocking
20:34:36 <`Guest00000> i meant "block" in the sense that when just a byte becomes available on Handle, it becomes available in [Word8] not too long after
20:34:38 <geekosaur> in fact lazy I/O pretty much requires blocking since there is no way to communicate 'no data now but might be later' through a list of data
20:35:46 <tippenein> how can I make persistent run a rawSql query without specifying the last parameter? rawSql "drop table whatever" _
20:35:53 <geekosaur> standard lazy I/O does that on non-block-structured streams (pipes, sockets)
20:36:07 <glguy> To communicate if something was going to block you'd need a different type from lists to do the lazy IO with. Something like: data LazyIOList a = Cons a (LazyIOList a) | End | WouldBlock (LazyIOList a)
20:36:42 <`Guest00000> hmm
20:37:08 <`Guest00000> is there any sense in exporting some constructors of a type but not others?
20:37:11 <geekosaur> you might have to disable haskell-level buffering on a pipe (hSetBuffering). sockets should already be unbuffered
20:37:47 <geekosaur> tippenein, if there's no placeholders then it should be the empty list
20:39:26 <tippenein> geekosaur: ah yiss! thanks. The type annotation was actually the thing broken :D
20:39:39 <geekosaur> when a Handle is in buffered mode, it reads blocks instead of individual bytes; this is much more efficient for large amounts of data with little I/O-blocking (i.e. disk files)
20:40:42 <geekosaur> it's also usually more efficient for pipes, but only when theyre kept reasonably full; if their behavior is more like interactive, you will want to set NoBuffering on the handle
20:59:02 <`Guest00000> what exactly does unsafeInterleaveIO do? when its return value is forced to WHNF, the computation is performed fully?
21:00:19 <mniip> `Guest00000, yes
21:01:07 <mniip> it has a left inverse: (>>= evaluate)
21:01:25 <mniip> which is a right inverse too I guess
21:36:39 <ekr> hello, why can't Data.MultiSet be imported into ghci? I'm getting "Could not find module 'Data.MultiSet'".
21:36:52 <ekr> or how do I debug this kind of issue?
21:37:27 <kadoban> ekr: Are you using a particular build system at all? stack? cabal-install ?
21:37:36 <kadoban> In short you probably don't have the package that's from available
21:37:51 <ekr> not at the moment, no, the arch linux package manager
21:38:15 <Axman6> have you installed the package which provides Data.Multiset?
21:39:12 <ekr> thanks, I thought that it was part of the base library, if there is such a thing.
21:39:45 <ekr> I'll handle it from here. thanks again.
21:40:07 <kadoban> Sure
21:47:13 <mac10688> does anyone use nginx to deploy their haskell web apps? I'm getting tired of keter. I can't get it working after making a small change
21:47:40 <mac10688> not deploy but serve, I don't know what lingo to use for it tbh
21:47:54 <Axman6> "Reverse proxy to"
21:48:21 <Axman6> I believe we do, there's nothing special about Haskell being involved, it's just a web service that nginx proxies to
21:48:45 <mac10688> yeah I guess I need to learn about nginx
21:49:02 <mac10688> I kind of don't understand how that stuff works
21:49:24 <mac10688> so I have nginx that runs my haskell.exe and it takes in requests and routes it to my app?
21:50:02 <Axman6> usually you would run the haskell app, it's not really something reverse proxies control (keter is a bit weird, but also aims to solve a slightly different problem)
21:50:52 <Axman6> you just run your app on a specific port, and use nginx to proxy requests from say port 80 (and/or 443) to your app running on whatever port it's listening on (not 80 and/or 443)
21:51:16 <Axman6> then if you have a new version of your app, you can just kill the old one and run the new one
21:51:40 <mac10688> ah ok
21:51:50 <mac10688> so I run my app on startup with systemctl thing
21:51:55 <mac10688> than nginx is also running to
21:52:04 <mac10688> that makes sense
21:52:09 <Axman6> yep
21:53:32 <Axman6> https://www.keycdn.com/support/nginx-reverse-proxy/ looks like a good basic intro
21:58:13 <mac10688> oh that looks good. I'll read it tomorrow. Thanks Axman6 
22:08:41 <orzo> there's guis for looking at .hp files and .eventlog files, anything for .prof?
22:10:48 <pacak> orzo: I saw something written in emacs lisp, but it's pretty readable as is.
22:13:35 <dmj`> mac10688: nix is really nice for deployments that use nginx
22:16:10 <mac10688> dmj`, oh nix, I hear that word a lot
22:16:30 <mac10688> is there a way to reach my webservice without needing any of this if I'm developing with spock?
22:17:00 <mac10688> I just want the simplest setup for development until I'm ready to deploy
22:17:22 <srhb> mac10688: Sure, just expose it on whatever port the reverse proxy would reach anyway.
22:17:41 <mac10688> so listen to port 80?
22:17:48 <srhb> The nginx solutions usually solve the problem of "how to have multiple things on port 80"
22:17:56 <mac10688> ah
22:17:57 <srhb> By routing based on server name or path or whatever.
22:18:22 <mac10688> ok well I guess that really is what I want
22:18:23 <srhb> If you have just the one thing, you can run it on port 80, or just visit some other port explicitly.
22:18:36 <srhb> Beware though, once you're using port 80 you're running your application as root.
22:18:47 <mac10688> oh
22:19:06 <srhb> Unless you do other linuxy magic :)
22:19:21 <mac10688> I tried installing nginx but it's complaining there's already something listening to port 80. which would be keter
22:19:27 <srhb> Yeah.
22:19:28 <mac10688> but I uninstalled keter and stopped the service
22:19:31 <iqubic> I don't understnad ports and such. Is that bad?
22:19:35 <srhb> ps -ef | grep keter ?
22:19:48 <srhb> iqubic: I don't understand ports either, never stopped me! ;-)
22:20:07 <iqubic> You're conversation is mostly technical mumbo jumbo to me.
22:20:12 <mac10688> 8312  4459  0 22:19 pts/2    00:00:00 grep --color=auto keter
22:20:18 <mac10688> that's what I got back from that
22:20:21 <mac10688> what does that mean?
22:20:22 <iqubic> s/you're/your/
22:20:22 <srhb> mac10688: That's as root?
22:20:26 <mac10688> no
22:20:30 <srhb> mac10688: Try again then.
22:20:40 <srhb> mac10688: If it's not in the list, it's not running.
22:20:48 <mac10688> ok cool
22:20:50 <mac10688> it shouldn't be
22:20:50 <srhb> mac10688: You can find out what's using port 80 with netstat -tl
22:20:57 <mac10688> oh thanks let me see
22:21:10 <srhb> Actually, -tln is probably simpler
22:21:19 <srhb> (n will show numerical ports instead of aliases)
22:21:44 <srhb> Oh, and add p too, for showing which process is holding it.
22:22:00 <mac10688> looks like nothing then
22:22:06 <ongy> I default to -tapn for netstat, makes things easy
22:22:09 <mac10688> maybe I should restart my comp
22:22:32 <ongy> do you want something to run there currently? I'm not quite sure from the backlog
22:22:43 <mac10688> well I type in sudo nginx
22:22:50 <mac10688> and it gives me a bunch of these
22:22:59 <mac10688> nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)
22:23:13 <iqubic> Is it imperative that I understand this conversation, or not?
22:23:19 <mac10688> I just want to fix that
22:23:24 <mac10688> i was running keter before
22:23:28 <mac10688> but i uninstalled keter
22:23:53 <mac10688> keter would listen on port 80 so I figured i left some residue behind but it looks like port 80 is free
22:23:54 <mac10688> just a second
22:24:44 <srhb> mac10688: If netstat (with sudo, again) is not showing any process on that port, something fishy is up
22:24:48 <mac10688> https://imgur.com/a/k5jit
22:25:06 <srhb> mac10688: Needs more sudo.
22:25:17 <ongy> it shows one listening there, you just don't get the name (Because permissions)
22:25:22 <srhb> Indeed.
22:25:32 <srhb> The second line of the netstat output is the culprit
22:25:34 <ongy> the second line for ipv4, second to last for ipv6
22:25:46 <mac10688> lol it says nginx is listening to port 80
22:25:47 <mac10688> thanks btw
22:25:57 <srhb> mac10688: It's probably running as a service. :)
22:25:59 <ongy> no figure out where that comes from :P
22:26:22 <geekosaur> no program listed, actually
22:26:32 <mibaz_1> is metaprogramming a compensation for some deficiency in a type system?
22:26:41 <ongy> that's why we told them to get more sudo, so netstat can display the program
22:27:02 <c_wraith> mibaz_1: it's compensation for a deficiency in expressiveness somewhere.  doesn't have to be a type system.
22:30:00 <mibaz_1> Ok. So, would the """perfect language"""(tm) not require metaprogramming? Or are there some things that should be expressed with it?
22:30:31 <srhb> That's really subjective..
22:30:58 <srhb> You might want to *not* clutter your language with certain possibilities as long as they are convenient via some metaprogramming solution.
22:32:00 <srhb> I also think people have a hard time agreeing upon what the perfet language should or should not be.
22:32:06 <srhb> perfect*
22:32:26 <geekosaur> one thing metaprogramming allows is coming up with new ways to do things, do you want to wait for a new version of the language/compiler or do you want to be able to implement it immediately?
22:33:15 <iqubic> You can do metaprogramming in Haskell? How?
22:33:25 <mibaz_1> geekosaur: That's a good point, hadn't thought about that.
22:33:31 <geekosaur> another thing is optimization, moving run-time operations that will always have the same result to compile time (again, without having to wait for the compiler to support that directly)
22:33:36 <pacak> iqubic: template haskell.
22:33:58 <mibaz_1> srhb: You're obviously right. If we have a definition of perfect language then the discussion gets interesting
22:34:33 <geekosaur> which is often a situational thing: for you, some particular data file that needs to be parsed and loaded might change less often and doing it once at compile time is a win, for someone else it changes often enough that they must do it at runtime
22:34:48 <iqubic> pacak: Is TH as powerful as say, lisp macros?
22:35:27 <pacak> iqubic: You can do pretty much anything in TH, it's just ugly.
22:35:39 <mibaz_1> can confirm ugly
22:35:40 <geekosaur> that's actually a somewhat difficult question since lisp is effectively typeless and so can more easily express some things than Haskell, including in its macros
22:35:52 <geekosaur> but that is expressiveness, not power
22:35:56 <pacak> With lisp there's no syntax, you only have s-expressions which are trivial to manipulate.
22:36:18 <iqubic> pacak: s-expressions have lots of syntax.
22:36:21 <geekosaur> and it too is a tradeoff, since lisp is typeless it does not give you sanity checking that types can give you
22:36:26 <pacak> iqubic: Like ( and )?
22:36:29 <pacak> Also `
22:36:31 <pacak> and '
22:36:38 <iqubic> pacak: I get your point.
22:37:15 <iqubic> geekosaur: True. Lisp forces you to do stuff like characterp all the time to check the types of things.
22:37:41 <geekosaur> when it comes down to it, that's why there are so many programming languages, there is no perfect one and there can't be because everyone has different requirements.
22:38:03 <geekosaur> and trying to fulfill them all gets you PL/I or Perl 6 (neither of which is necessarily bad, just ... large)
22:38:19 <pacak> Perfect language should allow 100% of valid programs and reject 100% of invalid ones.
22:38:38 <pacak> Comparing lisp with haskell - lisp tends to be more on permissive side, haskell - on rejection side.
22:38:38 <iqubic> Also I was in #Lisp earlier, and people kept asking, "How do I check if a certain character is nil"
22:38:41 <geekosaur> A Mr. Gödel would like to speak with you :p
22:38:48 <mibaz_1> and consist solely of behavior specification
22:39:11 <mibaz_1> at an arbitraily high level
22:39:39 <mibaz_1> And do laundry
23:03:10 <norc_> Good morning. Is there a more elegant way to write this "filterTree" function? https://gist.github.com/anonymous/ad487e319067ba112d078c92d788ca1b
23:03:26 <norc_> In particular this nested case construct is just offending me a little much.
23:04:05 <Cale> sure
23:04:46 <dmwit> norc_: `case r' of Nothing -> Nothing; Just lt -> Just lt` looks like `r'` to me.
23:05:42 <norc_> dmwit: Ah dang you are right.
23:06:36 <dmwit> norc_: Of course you can also use `case (l', r') of ...` in case nesting is your only complaint.
23:07:10 <Cale> liftM2 Branch l' r' <|> l' <|> r'
23:07:13 <dmwit> `case (l', r') of (Just lt, Just rt) -> Just (Branch lt rt); _ -> l' <|> r'`
23:07:15 <norc_> dmwit: Im open to any input that would make it more idiomatic. And I was wondering how to do multiple pattern matching in a case, never thought of a tuple
23:07:20 <norc_> Cale: :o
23:07:40 <dmwit> Oh, yeah, you can do even more `<|>`.
23:07:45 <dmwit> cool, Cale++
23:08:15 <cocreature> I wonder if GHC is sufficiently smart to optimize that to the same code you’d get by hand-written case statements
23:08:21 * cocreature starts staring at core
23:08:48 <dmwit> filterTree p (Leaf l) = guard (p l) >> return (Leaf l)
23:08:55 <Cale> yep
23:09:39 <dmwit> or `Leaf <$> ensure p l` if you import Prelude.Dmwit ;-)
23:09:51 <Cale> heh, I'm not sure it's even good, but you could use monad comprehensions  filterTree p (Leaf l) = [Leaf l | p l]
23:10:08 <dmwit> cute =)
23:10:27 <norc_> Cale: No idea how that works, but liftM2 Branch l' r' <|> l' <|> r' looks exactly like I was trying to do.
23:10:42 <norc_> Was considering Alternative, just couldn't figure out how to make it. Let me take a look
23:12:36 <norc_> Ahh I see my mistake. I started by looking at l' <|> r' and realized that this would get me in trouble if both produced Just.
23:12:38 <cocreature> nice it looks like Cale’s solution compiles to the same code as hand-written case statements do
23:13:41 <cocreature> hm, how can I suppress source locations in the output of -ddump-simpl? that seems to be a new feature in 8.2.1
23:17:21 <norc_> Cale: that last monad comprehension doesn't type check
23:17:44 <norc_> Does this require some special ghc setting?
23:19:08 <vaibhavsagar> {-# LANGUAGE MonadComprehensions #-} I think
23:24:13 <saurabhn_> yes! I caused the compiler to get stuck in an infinite loop. My ideas are so advanced, that I need an AI compiler to understand what I'm trying to express!
23:29:06 <norc_> vaibhavsagar: Ah okay.
23:33:53 <norc_> Cale: okay your code makes sense now. That is really elegant with the liftM2 :)
23:35:10 <norc_> https://gist.github.com/anonymous/3b56fe8e51cad6f08ce97f9cae12c53f :)
23:41:38 <norc_> I guess I could gold that where clause into (l' : r' : _) = fmap (filterTree p) [l, r]
23:41:54 <norc_> *golf even
23:43:12 <norc_> Not sure whether that is both smart and elegant though. 
23:43:40 <norc_> Wish I could just do (l', r') = fmap (filterTree p) (l, r)
23:48:02 <zRecursive> Long time no see. I wonder are there any practical haskell APP now except xmonad ?
