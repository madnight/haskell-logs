00:00:06 <olligobber> I'm just mad at myself for writing code like that instead of "if a then b else c"
00:00:06 <cocreature> sure :)
00:00:22 <olligobber> which is what I wanted
00:00:30 <olligobber> I guess you can't fix human error
00:01:06 <srhb> olligobber: hlint will catch it.
00:01:12 <srhb> (found if a then b else b, why not: b)
00:01:21 <olligobber> huh
00:01:26 <srhb> With a note of "increases laziness"
00:01:42 <erisco> right, because you are not strict on  a  anymore
00:01:45 <srhb> That's.. pretty solid :-)
00:02:01 <cocreature> hlint also allows you to define your own rules relatively easily, e.g., here’s the definition of that rule https://github.com/ndmitchell/hlint/blob/master/data/hlint.yaml#L262
00:02:08 <olligobber> in a purely functional program, evaluating a won't effect anything
00:02:09 <erisco> does it find  if a then b else id b   ?
00:02:24 <erisco> olligobber, effects aren't the problem… strictness is
00:02:32 <srhb> erisco: It finds "id b, why not b?"
00:02:38 <srhb> So I guess you can follow down that rabbit hole.
00:02:44 <erisco> lol, okay
00:02:46 <cocreature> olligobber: if a throws an exception or if the evaluation of a doesn’t terminate you still have a problem
00:02:55 <olligobber> fair point
00:03:13 <olligobber> I'll try hlint next time I get an error
00:03:16 <cocreature> and even if it does terminate you’re heating up the room which you might not want :)
00:03:38 <cocreature> > if undefined then () else ()
00:03:40 <olligobber> I have boinc, I'm heating the room anyway
00:03:40 <lambdabot>  *Exception: Prelude.undefined
00:05:12 <erisco> I am warm blooded… I am heating up the room anyway
00:05:15 <olligobber> ooh, hlint found a ton of redundant brackets
00:05:23 <olligobber> I clearly do not trust order of operations
00:05:51 <olligobber> also, lots of warnings saying <$> would be better
00:06:01 <olligobber> I need to revise what that does...
00:06:17 <erisco> "this would be better pointfree"
00:06:45 <erisco> "you should generalise this to profunctors"
00:06:50 <kadoban> hlint can be fairly opinionated sometimes. But since it's so configurable, that's hardly a problem IMO.
00:07:20 <olligobber> nice
00:10:13 <olligobber> when I'm writing code like fmap (fmap readPoint) $ replicateM n getLine, I think a <$> would probably be nicer
00:10:58 <kadoban> Yeah, most likely
00:11:52 <olligobber> the problem now is, my code works, so why change it...
00:12:10 <olligobber> I know the answer, but it's tempting to leave it a mess
00:12:51 <srhb> olligobber: I often end up using both fmap and <$> in that case
00:13:02 <srhb> olligobber: With the outer bit being <$>
00:13:32 <olligobber> srhb, the linter suggests fmap readPoint <$> replicateM n getLine
00:13:34 <srhb> olligobber: as in fmap readPoint <$> ...
00:13:36 <srhb> Yeah exactly.
00:13:46 <srhb> It's so beautiful. :')
00:13:50 <erisco> replicateM n (readPoint <$> getLine)
00:14:05 <olligobber> erisco, ooh I like that
00:14:44 <olligobber> I could even make Point implement Read
00:15:00 <olligobber> then it would be replicateM n (read <$> getLine)
00:15:30 <erisco> or just  replicateM n readLn
00:15:31 <olligobber> Point is defined as type Point = (Double, Double, Double), I assume I can make that implement Read
00:15:49 <olligobber> readLn is a thing? :o
00:16:11 <cocreature> tuples already have a Read instance
00:16:17 <erisco> > read "(1.0,2.0,3.0)" :: (Double,Double,Double)
00:16:19 <lambdabot>  (1.0,2.0,3.0)
00:16:19 <cocreature> you can’t make custom instances for type synonyms
00:16:24 <kadoban> olligobber: With an extension you can
00:16:34 <kadoban> Oh ... proabbly more than one extension
00:16:48 <cocreature> just make a separate type if you want a custom instance
00:16:50 <olligobber> this code has to work on a computer with only the standard haskell compiler
00:16:57 <olligobber> readPoint isn't too bad
00:17:10 <erisco> why can't you use the existing Read instance
00:17:11 <cocreature> the standard Haskell compiler is GHC and GHC implements a bunch of extensions
00:17:39 <olligobber> erisco, I'm using a type synonym, and my input format is predefined as "1.0 2.0 3.0"
00:19:15 <erisco> then probably don't use Read
00:26:02 <olligobber> my thoughts exactly
00:35:49 <olligobber> the linter doesn't pick up on unused imports it seems
00:47:42 <srhb> olligobber: I think ghc does that with -wunused-imports
00:48:21 <srhb> Er, -fwarn-unused-imports. Just stick on almost all warnings.
00:48:54 <cocreature> it’s included in -Wall
00:53:58 <olligobber> maybe I should use -Wall
00:54:11 <olligobber> I'm scared that will cause a lot of warnings
00:54:58 <olligobber> Top-level binding with no type signature: main :: IO ()
00:55:06 <olligobber> should I just declare a type for main?
00:55:10 <cocreature> yes
00:56:45 <olligobber> @djinn (a,b) -> (b,a)
00:56:46 <lambdabot> f (a, b) = (b, a)
00:57:01 <cocreature> :t swap
00:57:03 <lambdabot> (a, b) -> (b, a)
00:58:21 <olligobber> ty cocreature 
00:58:34 <cocreature> @hoogle (a,b) -> (b,a)
00:58:34 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
00:58:34 <lambdabot> Data.Tuple.HT swap :: (a, b) -> (b, a)
00:58:34 <lambdabot> Data.Tuple.Lazy swap :: (a, b) -> (b, a)
01:01:11 <olligobber> @hoogle (a,b,c) -> (c,b,a)
01:01:11 <lambdabot> Graphics.UI.Gtk.Selectors.HSV hsvToRgb :: (Double, Double, Double) -> (Double, Double, Double)
01:01:11 <lambdabot> Graphics.UI.Gtk.Selectors.HSV rgbToHsv :: (Double, Double, Double) -> (Double, Double, Double)
01:01:11 <lambdabot> Graphics.PDF.Colors hsvToRgb :: (Double, Double, Double) -> (Double, Double, Double)
01:01:34 <olligobber> I'll write that myself then!
01:02:59 <cocreature> at this point I would try to make some new types instead of using tuples for everything and come up with a meaningful name for what that transformation is supposed to do
01:04:43 <olligobber> cocreature, I probably should
01:05:20 <remexre> Is there a simple way to filter a map by keys with Maybe applied? e.g. Map k a -> (k -> Maybe k') -> Map k' a
01:06:11 <olligobber> @djinn m k a -> (k -> Maybe l) -> m l a
01:06:11 <lambdabot> -- f cannot be realized.
01:06:19 <olligobber> worth a shot
01:06:33 <remexre> Does that mean no?
01:06:43 <olligobber> it's still possible
01:06:50 <opqdonut> :t updateWithKey
01:06:52 <lambdabot> error:
01:06:52 <lambdabot>     • Variable not in scope: updateWithKey
01:06:52 <lambdabot>     • Perhaps you meant one of these:
01:06:54 <olligobber> I'm just starting to realise @djinn isn't that good
01:07:00 <opqdonut> :t Data.Map.Strict.updateWithKey
01:07:01 <lambdabot> Ord k => (k -> a -> Maybe a) -> k -> M.Map k a -> M.Map k a
01:07:11 <cocreature> that doesn’t allow you to change the key type
01:07:17 <croben> i have a function Num a => a -> a -> a -> Maybe a and i have a tuple (Maybe a, Maybe a, Maybe a)
01:07:20 <opqdonut> yeah, but that's the closest
01:07:41 <opqdonut> the thing about changing the key type is that it means the map must be rebuilt
01:07:48 <opqdonut> unless you can guarantee the k -> k' mapping is monotonic
01:07:49 <erisco> croben, liftA3 and uncurry3
01:07:55 <opqdonut> since maps are ordered
01:08:12 <remexre> okay, that's a guarantee I strongly do not have
01:08:26 <remexre> maybe this is an x/y problem thing, lemme try to state the real problem, gimme a minute
01:09:32 <opqdonut> remexre: I'd just use catMaybes, assocs and fromList
01:10:02 <remexre> I'm not actually sure that maps are the right data structure, either
01:10:17 <remexre> I'm typing up the problem I'm trying to solve in a buffer, 1 sec
01:10:23 <opqdonut> :t \m f -> Data.Map.fromList . Data.Maybe.catMaybes . map f $ Data.Map.assocs m
01:10:25 <lambdabot> Ord k => M.Map k1 a1 -> ((k1, a1) -> Maybe (k, a)) -> M.Map k a
01:11:22 <cocreature> :t \f -> Data.Map.mapKeys fromJust . Data.Map.mapMaybeWithKey (\k a -> a <$ k) . Data.Map.mapKeys f
01:11:24 <lambdabot> Ord k2 => (k1 -> Maybe k2) -> M.Map k1 a -> M.Map k2 a
01:12:10 <opqdonut> nice
01:12:17 <cocreature> the fromJust kind of sucks
01:13:04 <cocreature> and the first mapKeys should probably be a mapKeysMonotonic
01:13:44 <remexre> Wait, while typing it up, I realized I don't actually need to map keys
01:14:00 <remexre> Because the key type ends up as a tuple after going through newtypes
01:14:02 <remexre> :/
01:14:44 <remexre> The reason for a map with Maybe was as a pseudo-filter over half the data that would yield the other half
01:15:09 <olligobber> hmm... user error (Prelude.readIO: no parse)
01:15:30 <cocreature> remexre: sounds like maybe Data.Map.partition is what you’re looking for
01:15:47 <cocreature> or Data.Map.partitionWithKey
01:15:51 <olligobber> it works on my computer and not someone elses...
01:16:10 <remexre> oh, by data I meant the data in the key, not the map
01:16:37 <geekosaur> olligobber, djinn is based on a very old algorithm that doesn't even support recursive data types. you might want to play with :exf
01:16:48 <olligobber> Geekingfrog, ty
01:16:51 <remexre> I can just use lookup if I de-complicate the key type and move part of it into the value type
01:16:53 <olligobber> oops wrong person
01:16:56 <olligobber> geekosaur++
01:16:56 <geekosaur> (see https://github.com/lspitzner/exference)
01:19:09 <olligobber> any idea why Prelude.readIO would freak out on someone else's computer and not mine?
01:19:23 <geekosaur> what are you trying to read with it, in what context?
01:19:33 <olligobber> integers and doubles
01:20:00 <cocreature> tbh, my first guess would be a simple typo that causes the parse to fail
01:20:20 <croben> erisco: tuple is unimportant, i'm just wondering how to u
01:20:40 <olligobber> oh
01:20:49 <olligobber> I uploaded the wrong file
01:20:51 <geekosaur> I was wondering about locale... but it could also be one of the machines has ghc 7.6 (or maybe older, I don;t recall what version brought in ExtendedDefaultRules) and the other 7.10
01:21:05 <geekosaur> so it's defaulting to Integer on one and () on the other
01:21:12 <croben> unwrap the numbers, pass it to my function and avoid getting Just(Just Num)
01:21:31 <erisco> croben, did you look at both liftA3 and uncurry3?
01:21:37 <geekosaur> :t join `asAppliedTo` Just (Just 5))
01:21:38 <lambdabot> error: parse error on input ‘)’
01:21:51 <geekosaur> right, wrong thing
01:21:54 <olligobber> geekosaur, extra bracket at the end?
01:22:01 <croben> yeah
01:22:13 <geekosaur> that and I gave it a value in a type context and confused
01:22:29 <geekosaur> hm, no, I'm confusing mysekf
01:22:30 <geekosaur> :t join `asAppliedTo` Just (Just 5)
01:22:32 <lambdabot> Num a => Maybe (Maybe a) -> Maybe a
01:22:41 <erisco> croben, what did you try with liftA3 and uncurry3?
01:23:48 * geekosaur gives up and tries to go back to bed...
01:23:49 <olligobber> :exf Maybe a -> (a -> b) -> Maybe b
01:23:50 <exferenceBot> \ m1 f2 -> fmap f2 m1
01:24:02 <olligobber> that's alright
01:24:29 <olligobber> :exf (a -> b) -> [IO a] -> IO [b]
01:24:29 <exferenceBot> traverse . fmap
01:24:32 <olligobber> wat
01:26:01 <olligobber> good bot
01:26:04 <olligobber> exferenceBot++
01:26:37 <Taneb> @djinn Maybe a -> (a -> b) -> Maybe b
01:26:37 <lambdabot> f a b =
01:26:38 <lambdabot>     case a of
01:26:38 <lambdabot>     Nothing -> Nothing
01:26:38 <lambdabot>     Just c -> Just (b c)
01:26:56 <cocreature> olligobber: fwiw you can talk to lambdabot in private messages to avoid spamming the channel
01:26:58 <olligobber> :exf Maybe a -> (a -> b) -> Maybe b
01:26:59 <exferenceBot> \ m1 f2 -> fmap f2 m1
01:27:03 <Taneb> @djinn (a -> b) -> [IO a] -> IO [b]
01:27:03 <lambdabot> Error: Undefined type []
01:27:08 <olligobber> cocreature, good idea
01:27:20 <olligobber> :exf (a -> b) -> [IO a] -> IO [b]
01:27:21 <exferenceBot> traverse . fmap
01:27:25 <olligobber> wait I did that
01:27:34 <dminuoso> In lists, what would <* or *> be useful for exactly?
01:28:00 <dminuoso> I mean liftA2 const and liftA2 (flip const) dont seem too particularly useful at first glance
01:32:27 <croben> erisco: uncurry3 (liftA3 <func>) <tuple>
01:32:51 <croben> like i said, the tuple is not important here
01:33:14 <croben> i can just as easily have them as [x,y,z] or x y z
01:34:11 <croben> and passing them to the function is also fine, but i don't want the result double wrapped in Just
01:34:37 <erisco> croben, use join
01:35:36 <croben> oh, awesome, thanks :D
01:36:33 <erisco> they need to repurpose the liftM functions to do this
01:40:46 <croben> erisco: i'm sure i'll agree with you in the future ;)
01:52:37 <[exa]> What's the best approach for separating lexer/parser steps when working with parsec?
01:53:01 <[exa]> (let's say that the parsec's Token thing doesn't fit my purpose very much)
02:53:38 <[exa]> or maybe a better question -- is the haskell parser available somewhere for use, as a package?
02:53:50 <[exa]> oh, ghc-parser
03:02:57 <pavonia> [exa]: There's also haskell-src-exts
03:05:40 <[exa]> pavonia: that looks more reasonable, thanks
03:29:46 <cocreature> [exa]: if you want the “real” haskell parser, you need to use the "ghc" package
03:30:01 <cocreature> [exa]: you might also be interested in the "ghc-exactprint" package
05:07:47 <hexagoxel> is there an alternative to (lines, unlines) in base that is a bijection?
05:11:27 <Fendor> hexagoxel, (words, unwords)?
05:12:43 <hexagoxel> > unwords $ words "abc       def"
05:12:45 <lambdabot>  "abc def"
05:12:50 <hexagoxel> dun dun
05:13:58 <hexagoxel> (also, I do want newlines, not spaces, as delimiters)
05:14:29 <Fendor> and what is the problem with lines, unlines?
05:15:40 <Fendor> or what is the purpose? 
05:15:57 <hexagoxel> > unlines $ lines "abc\ndef"
05:15:58 <lambdabot>  "abc\ndef\n"
05:16:36 <Fendor> ah i see... 
05:16:42 <Fendor> so, the quickfix with init would not work?
05:16:54 <Fendor> > init . unlines $ lines "abc\ndef"
05:16:56 <lambdabot>  "abc\ndef"
05:17:20 <hexagoxel> > init . unlines $ lines "abc\ndef\n"
05:17:22 <lambdabot>  "abc\ndef"
05:17:50 <Fendor> ah, now i understand ^^ well, seems to be impossible without a special datastructure, since the information of the newline gets lost with lines
05:18:44 * hexagoxel will use intercalate + splitOn, and manually implement the latter to avoid another dep..
05:26:29 <Gurkenglas> If you want it to be a bijection just to scratch the itch, consider wanting f = f . f^-1 . f and f^-1 = f^-1 . f . f^-1 instead
05:29:03 <average> are you guys discussing how to best remove a character from a string?
05:29:30 <average> and you need to list the rules of function composition and inverses for that?
05:29:35 <average> jesus christ..
05:29:45 <average> what a mess that must be..
05:29:55 <hexagoxel> Fendor: to be fair, the quick fix would work if you also appended a new line initially.
05:29:58 <average> I can remove a character in any other language super-quick like *snap*
05:31:40 <hexagoxel> > init . unlines . (++"\n") $ lines "abc\ndef"
05:31:42 <lambdabot>  error:
05:31:42 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
05:31:42 <lambdabot>        Expected type: [String]
05:31:56 <hexagoxel> > init . unlines . lines . (++"\n") $ "abc\ndef"
05:31:58 <lambdabot>  "abc\ndef"
05:32:02 <hexagoxel> > init . unlines . lines . (++"\n") $ "abc\ndef\n"
05:32:03 <lambdabot>  "abc\ndef\n"
05:32:32 <Fendor> average, you can do that too in haskell, this is just background information
05:33:30 <hexagoxel> average: what i need is more than `filter`.
05:34:21 <Fendor> now i am interested on how other languages do that
05:36:30 <Fendor> it seems like python has the same problem
05:37:13 <Fendor> or feature. hard to tell if this is really a problem that (unlines, lines) are not actually inverses of each other
05:38:29 <average> Fendor: background information?
05:38:55 <average> if I have to think about function inverses and like.. that sort of thing, I would expect from myself to do something complicated involving math
05:39:14 <average> but like.. beating around the bush like that with inverses and composition.. it's just idk..
05:39:47 <Fendor> average, it is just expressed like this because it is more natural in a language like haskell. 
05:39:52 <average> if you're building some CAS or reading hard-math and solving problems yeah sure, but to remove a character from a line.. pff.. man..
05:39:55 <average> mind-numbing
05:41:08 <Fendor> if you are more used to it, it is no longer mind numbing, but actually easier to understand
05:42:04 <Hafydd> The incredibly difficult and mentally taxing notion of function inverses.
05:42:15 <Fendor> for example concatenation on Strings is a Monoid, this sounds complicated, but if you know what it means, it helps you to abstract code
05:42:40 <average> dude I'm not saying it's difficult
05:42:55 <hexagoxel> average: i just asked the question using this terminology because it was concise, not because the problem is inherently "mathy" in any way.
05:42:57 <Fendor> it's not like it is really necessary, it is just a way to abstract
05:43:27 <average> to abstract a what? removing a character from a string?
05:43:35 <average> funny
05:43:41 <average> anyways, carry on
05:44:08 <average> yesterday some dude was struggling to read a line in haskell for a few hours, so I guess this is generally the difficulties of a haskell programmer
05:44:21 <Fendor> to read a line? like getLine?
05:44:25 <hexagoxel> what makes you think i use this to "remove characters", especially when i ask for bijection?
05:44:35 <average> "how can I remove a character from a string" ; "how can i read a line" .. this should go into the FAQ, maybe with references to some heavy-math algebra books :))
05:44:46 <Hafydd> People asking for help with programming are generally the types of people who have difficulties.
05:45:00 <hexagoxel> average: you realize that the removed character you see in the examples above is exactly what i do _not_ want in this particular case?
05:45:13 <Fendor> average, and actually i have seen far more people struggling with reading something from a file in java
05:45:14 <average> haha hexagoxel 
05:45:52 <Fendor> which has loads of dedicated webpages to explain it
05:46:23 <average> why don't you just write a book like "Doing mundane s*** like regular people, with Haskell"
05:47:08 <average> and then another book "An introduction to pretending you're doing heavy math, when writing Haskell"
05:47:11 <Fendor> uhm... what language are you coding in?
05:47:36 <average> I'm 31, I've switched a million different languages by now
05:48:50 <Fendor> ok, and you dont like haskell because you think it is more complicaed, or pretentious than other languages?
05:49:09 <average> I was only commenting on your dialogue
05:49:38 <average> it seemed to be a form of "is this guy really a haskeller? hmm, let me ask this s*** in a super-convoluted way to confirm he's not a poser"
05:49:45 <average> that's what it looked like to me, i swear
05:50:18 <padre_angolano> average: that's 88 languages for each day of your life
05:50:34 <dminuoso> padre_angolano, did you take leap days into account?
05:51:12 <Fendor> but the question made absolutely sense, he/she wanted to know, if it is possible to get back to the same string after applying a function. Hence, looking for functions that are inverses of each other and moreover bijective, there's nothing pretentious, or anything to it
05:51:52 <Fendor> as i have written before, python does the same, so how would you have asked if the langauge was python?
05:51:54 <padre_angolano> dminuoso: yes, I used 31*365.25
05:52:16 <Hafydd> That doesn't take leap centuries into account.
05:52:57 <dminuoso> padre_angolano, you made the assumption that it's birthday today.
05:53:08 <erisco> I exported a type alias, but not what was being aliased, and I use this alias throughout the module
05:53:09 <dminuoso> padre_angolano, if you're going to be pedantic, at least do it right.
05:53:38 <erisco> I imported my module in ghci and asked for the type of a definition which uses this alias, and it gives me the de-aliased name
05:53:41 <erisco> why is that?
05:54:04 <padre_angolano> dminuoso: :-)
06:18:48 <knupfer> Any reason why (!!) starts counting with 0?
06:18:57 <knupfer> Seems pretty unhaskelly to me.
06:19:40 <knupfer> xs !! (length xs)   --  :(
06:19:43 <dminuoso> knupfer, so that it becomes total_
06:19:46 <dminuoso> knupfer, perhaps?
06:20:00 <dminuoso> What should xs !! 0 return?
06:20:09 <knupfer> total?
06:20:16 <knupfer> What should xs !! (-1) return?
06:20:53 <knupfer> It isn't total, most of it is actually undefined.
06:20:57 <dminuoso> Mmmm
06:21:36 <knupfer> Or what should  xs !! length xs  return? (last xs according to my wishes)
06:21:39 <Tuplanolla> The usual argument for zero-based indexing is open upper bounds, but we mostly have closed ones.
06:21:59 <Tuplanolla> > [1 .. length "string"]
06:22:01 <lambdabot>  [1,2,3,4,5,6]
06:22:22 <knupfer> > "string" !! length "string"
06:22:24 <knupfer> :(
06:22:25 <lambdabot>  *Exception: Prelude.!!: index too large
06:23:03 <mauke> peano starts at 0
06:23:18 <knupfer> I'd argue that it's inconsistent with the rest of the prelude. take, drop, length all start with 1
06:23:29 <mauke> what?
06:23:30 <ski> nope
06:23:33 <mauke> no, they don't
06:23:49 <knupfer> take 1 "a"
06:23:55 <knupfer> > take 1 "a"
06:23:57 <lambdabot>  "a"
06:24:02 <knupfer> > "a" !! 1
06:24:04 <lambdabot>  *Exception: Prelude.!!: index too large
06:24:06 <Boomerang> > take 0 "a"
06:24:07 <knupfer> in this sense
06:24:08 <lambdabot>  ""
06:24:10 <knupfer> yeah i know
06:24:14 <mauke> what sense?
06:24:55 <Tuplanolla> Counting and indexing are two different activities.
06:25:35 <knupfer> Hm.
06:26:44 <dminuoso> knupfer, another thing is if you ever needed to do math with the index, 0 based will bite you less back
06:27:31 <knupfer> yeah
06:28:08 <knupfer> I just dislike (!!) very much for beeing counterintuitive (to me) and beeing so outrageously partial
06:28:21 <Tuplanolla> Another thing to consider is how small index representations and control structures interact.
06:28:41 <ski> `ys = take n xs' (assuming `n <= length xs') gives a list `ys' such that `ys !! i' is valid for all integers `i' with `0 <= i' and `i < n'
06:29:10 <ski> (see e.g. "Why numbering should start at zero" by Edsger Wybe Dijkstra in 2008-05-02 at <https://www.cs.utexas.edu/users/EWD/ewd08xx/EWD831.PDF>,<https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html> for an argument of why use `<=' with the lower bound, but `<' with the upper bound)
06:29:39 <Tuplanolla> In C parlance, `for (unsigned char i = 0; i <= UCHAR_MAX; ++i)` doesn't work.
06:29:40 <knupfer> ski: thanks!
06:30:51 <Tuplanolla> This also suggests that `for` was not a particularly good design decision.
06:31:53 <ski> sometimes it would be nice to get access to the carry bit, in C ..
06:32:55 <ski> (er, sorry, wrong date, it should be 1982-08-11 .. read in thw wrong place, mea culpa)
06:33:26 <dminuoso> Tuplanolla, what do you mean by "it doesnt work" ?
06:34:16 <Tuplanolla> It never terminates, dminuoso.
07:21:41 <cjh`> I'm trying to implement a toy language in Haskell, I have most of the language working, just trying to add letrecs (mutually recursive let bindings). I use an Env to capture bindings (String to Value), and my Values can be a Closure (closing over an Env)
07:22:01 <cjh`> I'm used to expressing this in imperative languages using mutation and aliasing, where all of the closures reference the same environment that contains all of them
07:22:44 <cjh`> I'm having trouble expressing it in a way that I am happy with in Haskell. I can walk each of the let bindings to determine what other bindings they reference, build a DAG, and then work out the optimal order to build all of the different environments I need, but that feels gross
07:22:56 <cjh`> I could also throw the whole thing inside some larger monad (State?) to get my refs back...
07:23:09 <cjh`> but I keep thinking I am going about this the wrong way (thinking too imperatively)
07:31:50 <pta2002> I can't seem to get ghc to compile anything
07:32:12 <cocreature> pta2002: you’ll have to be a bit more specific.
07:32:14 <pta2002> https://gist.github.com/pta2002/e8c6b5ccd8e54478cd72f427fe0acc31
07:32:19 <pta2002> cocreature: linker errors
07:32:25 <pta2002> see gist
07:32:25 <cocreature> pta2002: let me guess: archlinux?
07:32:28 <pta2002> yep
07:32:29 <cjh`> pta2002: arch linux
07:32:34 <cocreature> *sigh*
07:32:35 <cjh`> I had the same problems
07:32:39 <cjh`> they screwed the pooch...
07:32:42 <ski> cjh` : sounds like you're doing an interpreter (?) i suppose if you wanted mutable references, you could use `STRef' (or `IORef') (these also have identity, which may be useful)
07:32:51 <pta2002> cjh`: somehow the first time an update broke anything
07:32:53 <pta2002> how'd you fix it?
07:32:54 <cocreature> pta2002: https://wiki.archlinux.org/index.php/haskell#Building_statically_linked_packages_with_Cabal_.28without_using_shared_libraries.29
07:32:58 <cjh`> ski: yes sorry, an interpreter, I should have specified.
07:33:12 <cjh`> pta2002: you want to use ghc-static and/or tell cabal to pass '-dynamic' to ghc.
07:33:24 <cjh`> ski: one of my options was to wrap the whole thing inside State so that I could use refs
07:33:29 <mauke> cjh`: what's the problem with having a closure referring to an env that contains the closure?
07:33:35 <ski> cjh` : i suppose it's not quite clear what the problem is. perhaps you're trying to find a way to express something. perhaps you're trying to find a better (or more efficient ?) way to express something
07:33:38 <cjh`> ski: i was worried that was just my imperative brain trying to force haskell to be more like C
07:33:39 <pta2002> I don't seem to have ghc-static
07:34:23 <cocreature> well you need to install it
07:34:32 <cjh`> mauke: I can't quite get my head around what that would do, maybe laziness allows it
07:34:44 <pta2002> hm oka
07:34:46 <pta2002> okay*
07:34:51 <cjh`> mauke: I need to form a new environment which contains all of the letrec bindings, each of which is a closure referencing that same env
07:34:54 <cjh`> mauke: so chicken and egg
07:35:01 <mauke> yeah, so?
07:35:21 <pta2002> well that worked
07:35:23 <cjh`> I tried writing that and kept getting stuck on expressing it, I will try some more there
07:35:26 <mauke> > let foo = 0 : bar; bar = 1 : foo in (take 10 foo, take 10 bar)
07:35:28 <ski> cjh` : `State' doesn't give you references, per se. with some kind of functional references (like lenses), you can use it as several smaller pieces of state, rather that just a big lump of state. but that (by itself) still doesn't allow you to allocate new state (but, if you wanted to, you could use some kind of map data structure for that)
07:35:28 <lambdabot>  ([0,1,0,1,0,1,0,1,0,1],[1,0,1,0,1,0,1,0,1,0])
07:35:29 <pta2002> still more of a workaround than a fix but w/e
07:35:57 <cjh`> mauke: oh wow
07:36:01 <cjh`> mauke: i thought that was only safe 'one way', ty
07:36:29 <cjh`> ty for all of your input, have to jump on a fight now but going to try at this again
07:36:30 <ski> cjh` : i'd try building the closures referencing the env that results from building those closures .. and then see whether that's enough for what you want to do
07:36:40 <mauke> cjh`: see also: the fix function, mfix, "tying the knot"
07:36:47 <cjh`> ski: I was thinking State and STRef (state refs), but I havne't used them before
07:37:06 <cjh`> mauke: my language already supports self-recurisve functions, which is what I thought tying the knot references
07:37:10 <ski> `State' (or `StateT') and `STRef' is not that often combined, i think
07:37:17 <mauke> good luck in your fight
07:37:23 <cjh`> if anyone has any good references on implementing letrecs and similar in pure language I would love to see it
07:37:26 <cjh`> hahaha oops, flight*
07:37:32 <cjh`> sorry to run, thanks again.
07:37:42 <cjh`> ski: that is my lack of haskell-fu showing then, ty
07:37:49 <ski> cjh` : btw, it's not clear whether your closures are mutable or not
07:37:52 <mauke> cjh`: mutual recursion can be done with tuples, like fix (\ ~(foo, bar) -> ...)
07:38:28 <mauke> > fix (\ ~(foo, bar) -> (0 : bar, 1 : foo))
07:38:31 <lambdabot>  ([0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,...
07:39:45 <ski> cjh` : in some cases, building a cyclic mutable data structure can be helped with a function like `newCyclicSTRef :: (STRef s a -> a) -> ST s (STRef s a)' (avoids having to first initialize with a dummy value). this can be built using `mfix :: (a -> STRef s a) -> STRef s a'
07:40:44 <ski> i suppose in your case, a version having a type like `Traversable t => (t (STRef s a) -> t a) -> ST s (t (STRef s a))' could be more useful, since you're doing mutable recursion
07:40:47 <cjh`> ski: sorry, no my closures are not mutable, they just close over a haskell Map
07:41:02 <ski> (but this is just a random idea. perhaps not that useful in your case)
07:41:15 <cjh`> mutual recursion, not need for mutable (toy language is pure and lazy minimal ml/haskell dialect)
07:41:25 <ski> cjh` : ok, then you can ignore what i said (and probably also ignore `mfix')
07:41:28 <cjh`> mauke: hhmmm
07:42:01 <cjh`> ski: I was only going to use state/refs because that allowed me to pretend I was back in C (roughly)
07:42:11 <cjh`> ski: but I want to try solve this 'correcty' or 'idiomatically'
07:42:13 * ski nods
07:42:51 <ski> sometimes using mutable state (possibly hidden inside a non-`ST' interface) is appropriate
07:43:38 <ski> (but to better understand when it's not needed, one needs to learn about and try other approaches, such as tying-the-knot)
07:44:19 <ski> cjh` : can the building of these closures fail in any way ?
07:44:42 <ski> (e.g. by variable-not-in-scope. or perhaps type error or similar, if you have those)
07:44:57 <ski> or have you done any required checking beforehand ?
07:52:20 <trevortknguyen[m> I'm currently using ByteString.Lazy and Text.Lazy to process a large Bzipped file. It was working pretty well until I ran into the problems that many people cite with LazyIO. So now I'm investigating Streams and Conduits, which are supposedly the better way to do things. Could anyone give me some pointers on the differences between streams and conduits or if they are supposed to be used together? Also, am I on the
07:52:21 <trevortknguyen[m> right track for intending to use them for file IO?
07:56:55 <lyxia> Yes, try conduit.
07:58:17 <lyxia> If you mean the "streams" library, it doesn't seem intended for streaming file IO.
08:17:01 <tomasmu> i need a little syntax help, can't manage to google this, and i'm out of ideas
08:17:34 <tomasmu> how do i set variable to be, say, (length xs) -1 here? [xs !! i | i <- [0..variable], i /= 3]
08:18:25 <lyxia> [x | (x, i) <- zip xs [0..], i /= 3]
08:19:07 <lyxia> You can do   [xs !! i | i <- [0 .. length xs - 1], i /= 3]   but it looks less nice.
08:19:44 <tomasmu> yeah, and i'm actually having a nested list comprehension, so it would be nice to not have length xs - 1 twice
08:20:05 <c_wraith> tomasmu: whenever you see (!!), assume that the code is wrong
08:20:21 <erisco> that sentence looks wrong
08:20:24 <lyxia> tomasmu: can't you use zips?
08:20:43 <c_wraith> erisco: you might be able to prove it's not wrong, but start by assuming it is.
08:20:45 <lyxia> then you automatically have the elements and their indices
08:21:01 <lyxia> without having to worry about bounds
08:21:08 <tomasmu> oh, !! was the only way i knew how to index stuff :P
08:21:10 <rotaerk> whenever you see (!!), assume the code is excited
08:21:31 <tomasmu> i'm only a couple of hours into haskell, trying to solve problems in hackerrank.com :)
08:21:40 <c_wraith> tomasmu: the problem is that you shouldn't be indexing into lists
08:21:56 <c_wraith> tomasmu: lists are not arrays.
08:22:19 <tomasmu> oh, right
08:22:47 <c_wraith> tomasmu: zip is a much better choice, as in lyxia's first example
08:22:49 <erisco> > (\xs -> [xs !! i | i <- [0 .. length xs - 1], i /= 3]) "hello world"
08:22:51 <lambdabot>  "helo world"
08:23:42 <tomasmu> rotaerk: haha, kinda like the null coalescing operator in C# (??) makes the code inquisitive
08:23:46 <c_wraith> erisco: I would argue that using an O(n^2) algorithm when there's a trivial O(n) alternative isn't just suboptimal, it's wrong.
08:24:02 <rotaerk> yep
08:24:25 <tomasmu> the zip thing does look neat
08:24:35 <tomasmu> thanks :)
08:25:05 <erisco> you can deleteAt a map or set but not a list, hrm
08:26:24 <rotaerk> looks like there are list implementations of deleteAt in non-standard packages
08:26:43 <rotaerk> ilist package, for instance
08:43:53 <tomasmu> m'kay
08:46:00 <tomasmu> the task was to find all the sums of an array if you ignore one element, and get the minimum/maximum sum
08:46:25 <tomasmu> so this is what i ended up with to retrieve an array with all the sums
08:46:28 <tomasmu> sumArrayMinusOne xs = map sum [[x | (x, i) <- zip xs [0..], i /= ignore] | (ignore, j) <- zip [0..] xs]
08:47:42 <tomasmu> does it look sensible? ;D
08:48:05 <tomasmu> of course, i could've just gotten the total sum and subtract each element..
08:54:01 <Draggor> cocreature: fresh install
08:54:17 <Draggor> For anyone else, how do I uninstall haskell-platform?
08:54:48 <tomasmu> sumArrayMinusOne xs = [sum xs - n | n <- xs] --slightly shorter ;D
08:56:15 <tomasmu> i might be a bit stuck in the imperative mindset
09:03:26 <tomasmu> sumArrayMinusOne xs = map (\x -> sum xs - x) xs
09:03:39 <tomasmu> this was kinda fun to tinker with
09:05:58 <rotaerk> hmm wouldn't that recompute the sum of xs for every element of xs
09:06:33 <tomasmu> but in the case of the list comprehension, it does not?
09:07:51 <lyxia> it would too
09:08:14 <ggVGc> technically it could be optimized, no?
09:09:12 <lyxia> GHC is very conservative about floating out subexpressions.
09:09:15 <ski> tomasmu : can you do that in one pass, e.g. using `foldr' ?
09:09:31 <monochrom> There is no practical difference between the list comprehension version and the map version. They are both optimized or unoptimized the same way.
09:09:45 <ggVGc> monochrom: how optimized are you?
09:10:02 <tomasmu> ski: i almost know what foldr is, i'll give it a try :)
09:10:28 <monochrom> However the best way to find out is to actually read the core code rather than asking random strangers on the Internet who don't really know more because they haven't read the core code either.
09:10:31 <ski> @quote optimized.Haskell.code
09:10:31 <lambdabot> Baughn says: remember that comments take up space in compiled Haskell programs, and furthermore they take up processing time if execution passes through them. For these reasons, keep comments to a
09:10:31 <lambdabot> minimum, and never put comments inside of optimized Haskell code. Ideally all of your comments will lie outside of the path of execution.
09:10:40 <monochrom> ggVGc: What do you mean?
09:10:58 <ggVGc> it was just a dumb  way of saying what's up
09:10:59 <ertes> tomasmu: nitpick: these are lists, not arrays
09:11:27 <erisco> lol, but that is more or less a consideration for interpreted code
09:11:54 <Eduard_Munteanu> I hate it when comments do not typecheck. :(
09:12:00 <ggVGc> actually
09:12:13 <ggVGc> it would be preatty sweet if comments were statically checked somehow
09:12:30 <erisco> yeah, like a comment system, and a comment checker
09:12:45 <ggVGc> then we could write our programs in the comments!
09:12:50 <ggVGc> and execute them
09:13:15 <ggVGc> and then we wouldn't need any actual code. And the world would be the same again except people would be writing clear and self-documenting code
09:13:19 <erisco> we can give "well-commented code" formal meaning
09:13:21 <cocreature> you can use doctests to typecheck examples in comments
09:13:22 <ertes> if you want your comments to be statically checked, all you need to do is to introduce them with "::" rather than "--"
09:13:47 <royal_screwup21> are all number initialized to 0 by default? I was looking at example to find the largest number in a list and the variable "maxtail", the answer, wasn't defined in the beginning. Am I missing something? Here's the tutorial: http://learnyouahaskell.com/recursion#hello-recursion
09:13:48 <tomasmu> ertes: ah, thanks for the terminology :)
09:15:05 <erisco> royal_screwup21, maxTail is defined in the where block
09:15:36 <royal_screwup21> erisco: but...it isn't initialized to anything at the beginning?
09:15:46 <erisco> maxTail = maximum' xs
09:15:55 <cocreature> royal_screwup21: code is not executed from top to bottom in Haskell
09:16:11 <monochrom> "clear self-documenting code" describes lawyers. (Recall that "code" also means law, e.g., criminal code). You have successfully explained why programmers suck at writing and understanding documentation: Those good at it make more money by becoming lawyers instead of programmers.
09:16:22 <royal_screwup21> cocreature: oh my god
09:16:50 <cocreature> royal_screwup21: "maxTail = …" is not a variable assignment as you might know it from other languages. it’s the defininition of "maxTail"
09:16:57 <erisco> like variable hoisting, but not
09:17:02 <mauke> royal_screwup21: there's no such thing as initialization. a variable gets bound to a value. an unbound variable is a compiler error
09:17:08 <erisco> what a strange feature that was…
09:18:33 <erisco> so, that is chapter 5… have you read the other chapters?
09:18:38 <JuanDaugherty> royal_screwup21, numbers are initialized to whatever literal values you give
09:21:46 <royal_screwup21> yeah I think I now "get" the bottom recursive approach but I'm going to have to draw it out
09:21:50 <royal_screwup21> bottom up*
09:22:11 <royal_screwup21> this is sorta like merge sort...
09:22:34 * JuanDaugherty recalls a very long time ago wanting to know what "recursive" meant. 
09:22:56 <erisco> royal_screwup21, how'd you figure out it was bottom up?
09:23:30 <JuanDaugherty> but the question you asked, about values being initialized is anathema to haskell
09:23:36 <monochrom> Soon, the distinction between top-down and bottom-up also becomes fiction.
09:23:51 <royal_screwup21> oh dear god
09:24:04 <JuanDaugherty> yeah
09:24:32 <erisco> in the cold, dead, deep space of Haskell, any sense of direction or velocity is you going mad
09:24:37 <royal_screwup21> erisco the explanation made sense and it felt very similar to how merge sort is implemented...
09:24:42 <monochrom> At the very least, expect much gray area.
09:24:55 <monochrom> Just like the "distinction" between tall and short.
09:26:01 <JuanDaugherty> royal_screwup21, you may want to look into the distinction between so-called imperative and declarative langs
09:26:13 <royal_screwup21> will do, thanks!
09:27:56 <JuanDaugherty> and also referential transparency which is where the anathema/bugaboo comes from
09:30:26 <erisco> I just found it interesting you didn't have the "going down" mentality
09:30:37 <v_g> Hello! Why I have Non-exhaustive patterns in this code http://lpaste.net/358336 ?
09:31:15 <erisco> it is kind of like… are you moving the page or the window onto the page
09:33:15 <lyxia> v_g: there is only a pattern for Object
09:34:06 <lyxia> v_g: parseJSON (Array _),  parseJSON (String _), ... are missing
09:35:06 <erisco> I wonder why they don't print the missing cases
09:36:06 * JuanDaugherty was thinking Nixon was still POTUS when he asked about "recursive" but he had resigned about 4 mo b4
09:36:56 <v_g> lyxia, thanks
09:37:42 <erisco> I learned it from the dictionary… it said "see 'recursive'", and I understood
09:37:54 <cocreature> v_g: if you only care about the object case you might be interested in "withObject"
09:38:01 <JuanDaugherty> yeah well it's in there now
09:38:48 <JuanDaugherty> delayed take on the joke
09:39:50 <JuanDaugherty> royal_screwup21, you may like Learn You a Haskell, commonly referred to as LYAH
09:40:28 <cocreature> JuanDaugherty: that’s literally where they got the code they asked about from so I’m pretty sure they’re aware of that book :)
09:40:47 <JuanDaugherty> oh
09:41:05 <hpc> LYAH is slightly out of date now, on a few of the libraries it discusses
09:41:09 <hpc> and it lacks in exercises
09:41:22 <hpc> but if you have a project of your own to do concurrently, it's a good book
09:42:55 <JuanDaugherty> and it's free and engaging for something that is pretty challenging
09:43:20 <hpc> yeah
09:43:52 <hpc> if the largest hurdle to learning haskell is that Monad is scary or FP is scary, LYAH is the ideal cure :D
09:44:28 <tomasmu> i quite like it, i bought the paper book too :)
09:46:46 <hpc> i have a free copy from BONUS
09:47:22 <hpc> it's one of three technical books i actually own
09:47:33 <hpc> the others are the K&R bible, and "the entire internet: a user's guide"
09:49:12 <tomasmu> the C programming book?
09:49:28 <hpc> yep
09:50:34 <tomasmu> haven't heard of the other though :)
09:50:44 <monochrom> Wait, there is "the entire internet: a user's guide"?!
09:50:59 <hpc> it was written shortly after dns became a thing
09:51:16 <hpc> back when there was little enough of the internet that you could at least mention all of it in one book
09:51:24 <hpc> i keep it for the lols
09:52:01 <tomasmu> :D
09:52:16 <monochrom> I only found "the internet: a user's guide" (without "entire"), and "The Whole Internet User's Guide & Catalog"
09:52:31 <hpc> lemme see which one i have
09:53:17 <monochrom> "whole" is from O'Reilly. "a" is from Prentice Hall.
09:53:34 <hpc> i have "whole"
09:53:53 <trigone> hi! i'm just starting to learn how to use git; i'd like to know what in a stack project i should commit and what i shouldn't...
09:54:45 <mmaruseacph2> trigone: stack new name-of-project tasty-travis; it has a .gitignore already set up :P
09:55:06 <mmaruseacph2> basically, don't commit .stack-work
09:55:10 <trigone> mmaruseacph2: oh ok i'll look into it then :)
09:55:19 <trigone> mmaruseacph2: ok
09:55:33 <mmaruseacph2> disclaimer, I'm biased on tasty-travis, it's a template I made some years ago
09:57:26 <rotaerk> hmm anyone used the "serialise" library?  encoding produces an Encoding type, and I'm unclear on how to get a ByteString.  am I supposed to take that Encoding and decode it to a ByteString?
09:59:04 <trigone> thx!
09:59:27 <trigone> mmaruseacph2: what are its other characteristics
09:59:30 <trigone> ?
10:00:12 <mmaruseacph2> trigone: benchmarks, doctests and tests with tasty (both Quickcheck and unit tests)
10:00:16 <glguy> rotaerk: You can use this module: http://hackage.haskell.org/package/cborg-0.1.1.0/docs/Codec-CBOR-Write.html
10:01:01 <tomasmu> ski: i give up
10:01:39 <trigone> hm ok... i'm not yet familiar with all this, i think i'll just copy your .gitignore for now
10:03:07 <rotaerk> glguy, I see; thanks
10:03:33 <trigone> dmwit: you sent me a message regarding lenses?
10:06:02 <trigone> best git hosting website (for haskell dev, if it makes a diff)?
10:06:24 <hpc> i would expect any git hosting website to make a diff
10:06:48 <trigone> hpc: is that a pun?
10:06:56 <rotaerk> glguy, hmm, why does the Builder type link to the one from the "binary" package instead of the "bytestring" package
10:07:03 <rotaerk> seems weird
10:08:21 <glguy> rotaerk: Probably so that it works with more versions of things
10:20:10 <monochrom> Haha the difference between diff and difference.
10:28:18 <Hafydd> That's a second-order difference.
10:33:52 <ski> tomasmu : one could say it's a "trick" (or technique). don't worry about it for now, then
10:34:53 <tomasmu> i'll continue to wade through LYAH and perhaps have a go at it later, if i remember :)
10:49:45 <Subeff> Hey guys, I am stuck on implementing Traversable for my List datatype. The definition is like in every example data List a = Nil | Cons a (List a). I have two patterns for traverse one is `traverse f Nil = pure $ Nil` the other I cannot think of how to put the recursion part so I am stuck at `traverse f (Cons a rest) = fmap Cons (f a)` Any idea where to plug a recursive call to traverse? :))
10:51:10 <glguy> Subeff: You'll need to make use of the 'Applicative' constraint you have when implementing Traversable
10:51:55 <mauke> :t traverse
10:51:57 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
10:51:58 <Subeff> glguy: I have Functor, isnt it enough? I did something similar for custom Maybe implementation so I thought it should be possible.
10:53:51 <mauke> I think the problem here is that you have 'f a :: f ...' and 'traverse f rest :: f ...', i.e. two f somethings
10:53:55 <mauke> and you need to combine them
10:54:00 <mauke> you don't have a recursive call with Maybe
10:56:09 <Subeff> how does applicative give me more than two fmap's
10:56:29 <Subeff> I do not see any benefit even if I implement it
10:56:50 <mauke> :t liftA2 (:)
10:56:51 <lambdabot> Applicative f => f a -> f [a] -> f [a]
10:59:39 <EvanR> oh dang https://twitter.com/raichoo/status/905828807424303104
11:01:08 <ongy> that shouldn't happen
11:03:08 <Guest60546> Hello
11:03:13 <ongy> how does that happen? There's nothing special in there o.0
11:03:40 <EvanR> no idea
11:03:41 <EvanR> try it
11:03:50 <Guest60546> I would like to seriously get into CTFs, any tips?
11:03:52 <EvanR> -- is specal right
11:04:06 <bbear> hello
11:04:19 <bbear> I have a problem in Haskell, I don't know how to solve it.
11:04:51 <bbear> It is a tree-based problem, but I use lists.
11:05:22 <bbear> Let say for each node, I have a list of possibilities.
11:05:37 <bbear> It is a path-finding problem.
11:09:58 <bbear> I want to return the shortest path while keeping track of all the possible pathes and stop as soon as I am at my target.
11:10:09 <trevortknguyen[m> @freenode_Guest60546:matrix.org: CTFs have a lot of low-level manipulation. You could start with C :/
11:10:09 <lambdabot> Unknown command, try @list
11:10:50 <ski> dijkstra ?
11:11:15 <bbear> ski: something like that
11:11:41 <ski> <https://en.wikipedia.org/wiki/Dijkstra's_algorithm>
11:11:54 <bbear> but basically my idea is the following : go on all the possible pathes from a certain point and when you are at the target, stop and return teh list of accessed nodes to get there.
11:12:54 <ski> keep a priority queue of the current path prefices ?
11:13:00 <kadoban> bbear: How familiar are you with algorithms in general? This sounds quite a bit like a BFS or possibly ya something like dijkstra's, depending on exactly what the tree looks like.
11:13:17 <ski> (a list sorted on the path lengths, perhaps)
11:13:33 <bbear> ski: the problem is that the map is potentially infinite.
11:13:46 <ski> which map ?
11:13:57 <bbear> I can't afford to compute all the possible paths, I must stop the algo when I am at the target.
11:14:09 <bbear> this means that I am doing a breadth first search actually.
11:14:20 <ski> more or less, yes
11:14:22 <bbear> And I must keep track of visited nodes also in a separate data structure.
11:14:42 <mauke> wouldn't A* still work?
11:14:44 <bbear> ski: so, how would you do that in Haskell ?
11:14:58 <bbear> mauke: sure it would work but I don't really want to use a tree.
11:15:07 <kadoban> In a tree you don't necessarily have to keep track of visited nodes, as long as you can tell what the parent of a node is.
11:15:14 <bbear> A* is more or less a variant of what I am doing.
11:15:32 <bbear> kadoban: That is why I don't want to use a tree but a Set of visited nodes.
11:15:36 <mauke> what tree?
11:15:37 <lyxia> Dijkstra works just as well with infinite graphs
11:15:57 <bbear> yes but I don't want to use a tree
11:16:03 <kadoban> bbear: I thought you were saying it was a tree conceptually, but you're representing it as lists or something.
11:16:11 <bbear> kadoban: exactly.
11:16:20 <bbear> conceptually it's a tree like structure.
11:16:38 <kadoban> So, in a conceptual tree, you don't really need a Set, as long as you can tell what the parent of a thing is. But using a set is fine I suppose, it's not going to hurt much.
11:17:12 <bbear> http://vpaste.net/EgEpH <- look at this attempt.
11:17:18 <bbear> (I know, it's not going to work)@
11:17:36 <bbear> The problem is that I have a list of list to manage until one of the recursive call returns.
11:17:41 <bbear> I wonder how I can do that.
11:17:51 <bbear> map(map
11:17:57 <bbear> or something like that I suppose.
11:20:54 <bbear> Or really I will recurse on a http://en.wikipedia.org/wiki/Special:Search?go=Go&search=Coord object
11:21:04 <bbear> > :t http://en.wikipedia.org/wiki/Special:Search?go=Go&search=1
11:21:05 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
11:21:58 <cocreature> bbear: how is getAdjacentNodes implemented? it looks like it needs to make up the neighbors out of thin air
11:22:24 <ski> bbear : that's depth-first
11:22:32 <bbear> it's here 
11:22:34 <bbear> http://vpaste.net/BmH2D
11:22:39 * ski supposes the graph is fixed
11:22:51 <bbear> ski: no the graph is not fixed
11:22:59 <bbear> If you mean « precomputed »
11:23:14 <bbear> but I am working on an alternative.
11:24:07 <bbear> oh my
11:24:15 <bbear> but yeah, it is hard to do it breadth first.
11:24:18 <ski> that (paste) sure looks like it's fixed to me
11:24:32 <bbear> yes, I don't know what you mean by « fixed »
11:24:42 <bbear> It probably is.
11:24:52 <ski> (as opposed to the data describing the graph being passed in as a parameter to the algorithm)
11:25:05 <bbear> yes exactly.
11:25:06 <ski> sorry for being unclear
11:25:18 <APic> lol
11:25:46 <ski> bbear : btw, why is `pathFinder (x,x) Set.empty' equal to `[]', rather than to `[x]' ?
11:26:33 <bbear> this is buggy 
11:26:45 <APic> *shrug*
11:26:51 <bbear> what ?
11:26:55 <ski> yea, i'm ignoring the other bugs, for the consideration of that
11:26:57 <APic> WHAT YOU SAY !!
11:27:10 * ski glances at APic
11:27:16 <APic> Glaciers?
11:27:17 <bbear> I don't know if my attempt could be considered solid ground to elaborate more.
11:27:27 <bbear> I don't think so.
11:28:00 <bbear> I think a queue should help me to do the breadth first.
11:28:05 <ski> i think your attempt makes it clear that you're currently considering depth-first (with implicit stack)
11:28:15 <bbear> ski: Yes I see that
11:28:16 * ski nods
11:28:30 <bbear> I just came on this : http://aryweb.nl/2013/10/28/haskell-tree-traversal/
11:28:43 <bbear> quote : _Breadth First is more difficult_
11:28:47 <ski> so .. perhaps first make the implicit stack explicit .. then change it to a queue ?
11:29:20 <ski> (also, your three `map's can be replaced by a single `map')
11:29:58 <bbear> yes probably
11:30:19 <ski> (one could also avoid using `zip' there. perhaps a list comprehension (or `do', if you prefer) would be more obvious to you)
11:30:21 <bbear> so short sum up.
11:31:16 <bbear> If I want to do breadth first search, I stack the nodes to visit in preorder
11:31:26 <bbear> or in postorder ? lol
11:31:28 <bbear> i'm lost
11:31:47 <bbear> Yes, I need to add all the neighbours at the end of the list (with ++ for example)
11:31:56 <ski> in the order you prefer, perhaps ?
11:32:02 <bbear> yeah :)
11:32:25 <bbear> But I don't like ++ .  Does Haskell has doubly linked list where both `head` and `last` are O(1)
11:32:26 <bbear> ?
11:32:27 <ski> getting it working, naively, may be better than not getting it working, non-naively
11:32:32 <bbear> oky
11:32:38 <bbear> I'll do that and show you the result.
11:32:52 <ski> then you can worry about improvements
11:33:09 <mauke> bbear: not a linked list, but there's Seq
11:33:34 <mauke> http://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Sequence.html
11:39:09 <EvanR> the progression in languages with arbitrary mutable data structures is: linked list -> doubly linked list -> ad hoc random access list -> ad hoc random access tree -> ad hoc random access graph -> incomprehensible
11:39:41 <EvanR> with decreasing probability of bug-freeness
11:40:22 <EvanR> probability of benchmarks to prove its worth it: 0%
11:40:44 <APic> lol
11:40:45 <mauke> where's my hash tables?
11:40:53 * APic misread that one as „hug-freeness“
11:40:54 <APic> 😉
11:41:08 <erisco> is there a typical name for the cons case in a foldr? I am inclined to call it the aggregating function
11:41:18 <EvanR> visit ?
11:41:59 <EvanR> f
11:42:02 <APic> !
11:42:08 * mauke pays respects
11:42:10 <ski> or perhaps `insert' or `inject' or something along those lines
11:42:29 <erisco> EvanR, you have a link for a theory of relations sans sets, what is it again?
11:43:08 <EvanR> SEAR set theory on nlab is a set theory built from relations, which are primitive
11:43:32 <EvanR> you could imagine a category of relations to start with
11:43:32 <erisco> https://ncatlab.org/nlab/show/SEAR
11:43:40 <erisco> I knew I had it bookmarked but I couldn't remember the name
11:44:00 <EvanR> relation composition is inner join
11:46:17 <bbear> my program works
11:46:19 * ski recalls Hermann Weyl in "The Continuum", 1918, had a notion of "multiary sets", you could write like `x,y \in R(r)'
11:46:21 <bbear> but I have a problem
11:46:51 <bbear> http://vpaste.net/kTLNf < -- see
11:46:57 <erisco> that's what keeps us all in business
11:47:26 <bbear> the return value is made of all the visited nodes. I don't know how to keep track of only the useful nodes.
11:47:29 <EvanR> x,y \in R(r) means... what
11:48:14 <ski> EvanR : think of `R' as being a morphism in `Rel' from `|R_{>= 0}' to `|R^2', say
11:48:17 <elpfen> I need to break the purity of haskell. I'm doing an algorithms assignment and I need a way to log every time an alg makes a comparison. Is there some way to shove an IO operation in a normal function?
11:48:27 <bbear> any idea ?
11:48:31 <APic> No ?
11:48:35 <bbear> elpfen: yes I think there is many way to do that.
11:48:39 <hpc> elpfen: look at Debug.Trace
11:48:39 <APic> CAPTAIN: IT'S YOU !!
11:48:56 <ski> APic : perhaps you could try to be less non-topical ?
11:49:24 <EvanR> ski: whats r
11:49:28 --- mode: ChanServ set +o mauke
11:49:34 <cjh`> mauke: I worked out where I was going wrong, tying the knot was exactly what I was looking for, thanks!
11:49:41 <ski> an element of `|R_{>= 0}'
11:49:53 <APic> Whoah
11:49:53 <cjh`> ski: this is a toy language, so no real error-handling yet
11:49:55 <monochrom> Instead of remembering visited nodes, remember predecessors of visited nodes, and use Map for that, so that "the key isn't even in the Map" means unvisited, and "the key is in the Map, and its corresponding value is..." is the predecessor. At the end, follow predecessors for the path found.
11:49:57 <cjh`> ski: thanks for your time too :)
11:49:57 <APic> You are highly annoying.
11:50:16 <bbear> yes.
11:50:18 * APic will just ignore everyone in this Channel.
11:50:19 <mauke> APic: last warnings
11:50:24 <mauke> s/s$//
11:50:27 <cjh`> ski: fetching a variable can fail (not in scope), but that is at eval time (forcing the thunk), rather than closure creation time
11:50:31 --- mode: mauke set -o mauke
11:51:00 <bbear> monochrom: I had another idea
11:51:11 <ski> cjh` : and that's how it's intended to be ?
11:51:19 <cjh`> mauke: I was having trouble conceptually with a function taking an argument that doesn't exist until way after it returns, breaking it into many smaller steps and working up manually from '1 binding', '2 binding', ....
11:51:27 <EvanR> ski: so all 2d points which are related to r
11:51:32 <bbear> but yes.
11:51:34 <EvanR> by R
11:51:46 <ski> yes
11:51:53 <cjh`> ski: in the 'real languages' I work on such things would be detected at compile time, but in toy land run-time is fine.
11:52:03 <cjh`> ski: well, s/real/less-toy/
11:52:15 <EvanR> so R is the multiary set
11:52:27 <bbear> ha no I don't see how to do it.
11:52:27 <ski> EvanR : rather than just using tuples, he allows multiple things to the left of `\in'
11:52:38 <ski> (no, `R(r)' is the multiary set)
11:52:58 <EvanR> for a fixed r ?
11:53:19 <monochrom> It is really best to use breadth-first search.
11:53:21 <bbear> monochrom: you mean to backtrack predecessor at the end of the algorithm ?
11:53:28 <monochrom> Yes.
11:53:32 * ski tends to be confused when "fixed" is mentioned in math
11:53:39 <ski> for the current `r' that is in scope
11:53:41 <bbear> mmh.
11:53:46 <bbear> I don't know how to do that.
11:54:08 <bbear> but yeah, basically a node may have only one predecessor so it is possible to backtrack from the solution.
11:54:12 <EvanR> when i see variables i am not sure if there is a particular instance in mind or "choose whatever you want"
11:54:18 <bbear> Diffucult -_-
11:54:24 <monochrom> You need a parameter for the predecessor Map (you're already half way there, a set of visited nodes). You also need a parameter for the current queue.
11:54:36 <EvanR> or if its just a variable
11:54:45 <monochrom> But learn breadth-first search properly.
11:54:55 <ski> EvanR : doesn't make a difference here. the variables are bound somewhere, by some binders. fine ?
11:54:56 <bbear> monochrom: what i am doing is not breadth-first search ?
11:55:00 <monochrom> Also, breadth-first search is none of preorder, postorder, inorder.
11:55:15 <monochrom> I don't see a queue.
11:55:26 <EvanR> why would you not say R is the multiary set
11:55:46 <bbear> monochrom: there is the firts argument of the function, the list of nodes to visit.
11:55:51 <ski> in normal parlance, `R' would be a function which when applied to `r' yields a set
11:56:12 <elpfen> hpc: that will work, thank you!!!
11:56:13 <monochrom> It keeps shrinking. It never grows.
11:56:14 <ski> i don't recall whether Weyl defined functions in terms of relations or not, there
11:56:26 <monochrom> Or did I misread it?
11:56:41 <bbear> monochrom: the first argument is made of all the nodes to visite.
11:56:50 <EvanR> i should get The Continuum 1918
11:57:02 <monochrom> Ah OK it does look like a queue now.
11:57:20 <ski> EvanR : apparently translated to english in 1987
11:57:27 <bbear> it first [start], then [neighbours of start], then tail ([neighbours of start])++ neighbours of (head neighbours of start), etc.
11:57:56 <bbear> ok monochrom
11:57:58 <monochrom> Why does the base case return [] rather than path?
11:58:16 <ski> anyway, what Weyl tries to do there (before discovering intuitionism) is trying to build analysis, predicatively, in order to try avoid vicious circles
11:58:17 <bbear> yes, you are right.
11:58:52 <bbear> so, what I want now is to backtrack my path.
11:59:53 <bbear> I wonder how to do that. Maybe in [path], store a list of tuple (node, predecessor)
12:01:51 <bbear> yes, I see your idea monochrom. Rather than a set use a Map that store k, v as (predecessor, node).
12:01:56 <bbear> That's quite smart.
12:02:00 <bbear> congratulation.
12:03:09 <bbear> rather as (node, predecessor)
12:04:33 <EvanR> ski: found a PDF
12:04:50 <sqooq> I know i've asked in here like 20 times
12:04:55 <sqooq> but if you want it in one clean place
12:04:56 <sqooq> https://stackoverflow.com/questions/46144450/how-do-i-do-gtk-mouse-interaction-correctly-with-haskell-chart-library
12:06:17 <ski> EvanR : link ?
12:06:26 <EvanR> https://quantitability.files.wordpress.com/2013/04/hermann-weyl-the-continuum-a-critical-examination.pdf
12:06:29 <ski> elpfen[m] : one way is to change from `frob :: Input -> Output' to `from :: Applicative i => i (Data -> Data -> Ordering) -> Input -> i Output', using the argument to compare. then you can use e.g. `Writer (Sum Integer)' as `i'
12:11:48 <ski> cjh` : ok, that's fine
12:12:10 <ski> cjh` : "having trouble conceptually with a function taking an argument that doesn't exist until way after it returns" -- what troubles with tying-the-knot did you have, more specifically ?
12:13:52 <ski> monochrom,bbear : what was called `newStack' is actually a queue ..
12:14:19 <monochrom> Perhaps it is the whole disbelief of tying-the-knot.
12:14:28 <ski> could well be
12:15:11 <monochrom> Recall that there was a time, just before Peter Naur implemented Algol 60, when people simply disbelieve that recursive functions were implementable.
12:16:22 <pikajude> and they were right!
12:16:35 * ski smiles
12:17:37 <monochrom> Disbelief is more powerful than knowledge.
12:17:40 <Rembane> Recursion is a lie.
12:18:18 <ski> i believe the technical term is "leaky abstraction" ?
12:18:30 <pikajude> my official job title is "abstraction plumber"
12:27:47 <raichoo> EvanR, ongy: No that should not happen. It was quite nasty.
12:30:37 <ggVGc> I still disbelieve that software is really implementable
12:30:48 <ggVGc> in a seriously useable way
12:31:01 <`Guest00000> ggVGc: that's a funny sad joke
12:31:13 <ggVGc> it's only partly a joke
12:31:21 <ggVGc> I'm not convinced we're on the right path
12:31:40 <ggVGc> maybe this is not how we should be using computers. It might be a lit different in the future
12:31:50 <`Guest00000> ggVGc: i have similar feelings
12:31:50 <ggVGc> we just don't know better yet
12:32:24 <ggVGc> maybe the whole idea of going deeper into type safety etc. to make more correct programs is just patching up a fundamentally flawed endeavour
12:33:03 <`Guest00000> ggVGc: i like languages with more elaborate type systems because they allow me to transfer my mental models into programs in those languages more directly
12:33:05 <ggVGc> it all feels very primitive to me
12:33:33 <`Guest00000> more directness = less opportunity for error
12:33:41 <ggVGc> Guest291964[m]: sure, but you're still stuck in the model of transferring your mental model through inputting commands
12:33:44 <ggVGc> by text
12:34:39 <Tuplanolla> Text is a very awkward thing.
12:34:45 <ggVGc> yes
12:34:52 <ggVGc> and we're quite bad at using it in general
12:35:07 <ggVGc> I mean, it's useful, but it's primitive
12:35:19 <Tuplanolla> Some believe otherwise, because we have put so much effort into working with it.
12:35:53 <sqooq> ggVGc: hmm you might be a revolutionary
12:35:58 <`Guest00000> ggVGc: i'm not convinced that using something else than text has some profound, fundamental advantage over using text
12:35:59 <sqooq> keep thinking about it
12:36:20 <sqooq> Well maybe it's how we're using text, not the fact that we are
12:36:29 <sqooq> maybe we need to use text in a fundamentally different way
12:36:36 <`Guest00000> ggVGc: text is just medium, a way to encode algorithms / other things
12:37:06 <`Guest00000> i think that using code visualization will give advantages, but not fundamental ones
12:37:37 <ggVGc> the thing is, in my opinion text is just another way of talking. And we're already really bad at talking and even worse at listening. So the whole interacting with a computer through an awkward language in writing doesn't seem very powerful to me
12:37:45 <ggVGc> but I mean, it's a matter of time
12:37:56 <ggVGc> I'm just saying, maybe the future will not be along this path at all
12:38:04 <cjh`> ski: well I was having trouble with tying the knot, I think I get it more now
12:38:18 <ggVGc> and the whole idea of refining languages for writing stuff for computers will be useless
12:38:23 <ggVGc> but it's still useful for now
12:38:37 <cjh`> ski: working through it from '1 binding', through '2 bindings, ... all the way to 'n bindings' helped me understand it a bit better
12:38:55 <ski> ok
12:38:59 <cjh`> ski: I was comfortable with using haskell lets, but in this interpreter I was using a list of new bindings and a function to iterate over them
12:39:07 <Tuplanolla> Diagrams would often be more useful, if only they weren't so tricky to work with.
12:39:11 <`Guest00000> ggVGc: "in my opinion text is just another way of talking" well, you could say any interaction with anything is talking
12:39:17 <cjh`> ski: and that new environment wouldn't exist until well after that function returns, which was odd and felt wrong
12:39:18 <ggVGc> I don't think anyone could argue that Haskell is a way you'd choose to communicate if you had complete freedom of choice
12:39:25 <sqooq> ggVGc: that analogy doesn't hold
12:39:41 <sqooq> pretty sure by chomsky's hierarchy
12:39:50 <sqooq> coding language =/ human language
12:39:58 <sqooq> or natural language I should say
12:40:07 <ggVGc> I think yes and no
12:40:14 <ggVGc> language wise, not at all
12:40:25 <ggVGc> but in the way we deal with it, I think yes
12:40:26 <ski> cjh` : but you pass it in as an argument, i suppose
12:40:27 <cjh`> ggVGc: we constrain programming languages on purpose, e.g. to reduce ambiguity
12:40:33 <cjh`> ski: yes
12:40:37 <ggVGc> most programmers still don't really read code, except their own
12:40:45 <ggVGc> which is the same thing as being bad at listening
12:40:54 <cjh`> ski: I also had trouble trying to think of that arguments like I do with recursion, I couldn't figure out a base case (since it doesn't exist in any form until after function returns)
12:40:59 <cjh`> ski: but that is fine, because laziness, *waves hands*
12:41:05 <sqooq> because it's hard to read code because things are reffered to in different places
12:41:14 <sqooq> everything is too abstract
12:41:21 <sqooq> if you don't know one word you're lost
12:41:24 <ski> ggVGc : i think part of the reason for that is that current programming languages tend to be hard to read and reason about
12:41:25 <aurelion> Is there any problem if I use GADT to 'store' applications of applicative pure and <*> in a data structure instead of executing them? If I understand correctly, normally one would use Free applicative for this, but I'm not sure what the advantage would be. I read some vague things about violating the applicative laws that I didn't completely understand.
12:41:26 <sqooq> but that's just like natural language
12:41:36 <cjh`> ggVGc: maybe people being antisocial is a better comparison than being bad at listening :p
12:41:37 <ggVGc> hey guys look
12:41:40 <ggVGc> a haskell question :)
12:41:41 <[exa]> hm guys I know it's totally offtopic but are there any viable explanations for U+1F574 ?
12:41:43 <ski> (key part being the "reason" word)
12:41:47 <sqooq> if you don't know 2 vocabulary words in a sentence, you may be able to guess, but you won't really know for sure
12:42:26 <ski> cjh` : an alternative can sometimes be to compute a function
12:42:43 <monochrom> cjh`: There will be a time when you look at the precise detail of lazy evaluation and what it does and what it refuses to do and it will not be handwaving any more.
12:42:44 <sqooq> ggVGc: I had a haskell question too :(
12:42:46 <sqooq> https://stackoverflow.com/questions/46144450/how-do-i-do-gtk-mouse-interaction-correctly-with-haskell-chart-library
12:42:52 <cjh`> ski: so compute a function that takes the environment whenever it is ready, and then uses it ?
12:43:06 <monochrom> But for now a key point is "data constructor".
12:43:42 <cjh`> monochrom: once I have working lazy code I can explain it, I've dealt with thunks/closures enough (from the language implementer PoV) to be able to work it out
12:44:02 <ski> sqooq : not just that. code also tends to be hard to reason about because of lack of useful (local) code equivalences
12:44:04 <cjh`> monochrom: but it takes me a lloonngg time to figure out how/if my problems maps to them, and what ways I can legally use laziness in Haskell
12:44:13 <ggVGc> sqooq: we can continue in #haskell-offtopic, but I think that abstractness is the problem. We usually want to transfer a not so complex idea. But to do that correctly we have to do it through a language, that becomes complex, because of safeguards we put in, because the communcation itself is difficult. So then the whole thing becomes difficult and erronous, even when the idea itself was simple
12:44:33 <sqooq> Haskell is so abstract too
12:44:37 <sqooq> and it's been getting on my nerves
12:44:38 <monochrom> Oh yeah the language implementer POV is way too low level.
12:44:41 <cjh`> monochrom: I guess it comes down to me having implemented laziness (usually in strict languages), but not having used laziness myself much
12:44:45 <ski> cjh` : yep
12:44:51 <sqooq> sometimes I just wish I could store a stinkin variable and access it later
12:44:55 <cjh`> monochrom: so I can understand closures and thunks, but how do those map to syntax?
12:45:03 <cjh`> monochrom: the level is a good point
12:45:07 <monochrom> Like you could use quantum mechanics to work out nor-gates but why bother.
12:45:17 <cjh`> monochrom: it is also that I primarily work in strict languages where any laziness is explicit and occasional, rather than built into every syntactical device
12:45:21 <cjh`> monochrom: hahhaha
12:45:35 <sqooq> i went offtopic ->>>
12:45:48 <ggVGc> sqooq: you can do that, kind of :) In a fold or a state monad. Or even for real in something like an IORef
12:45:52 <ggVGc> but if you should is another matter
12:46:16 <sqooq> ggVGc: I know 
12:46:18 <sqooq> I
12:46:25 <sqooq> use IORef in my code rn
12:46:48 <`Guest00000> aurelion: free applicatives allow optimizations like Thing1 <* DoNothing = Thing1; functions are opaque and can't do that. so if you build up a big applicative expression over time out of blocks like this which can be optimized away, free applicatives will help you keep memoty usage smaller 
12:47:08 <`Guest00000> memory *
12:47:56 <ggVGc> sqooq: are you sure you need IORefs? A lot of the time you can get by fine with ST or MVar
12:48:35 <sqooq> I don't even know what any of those things really are
12:48:39 <sqooq> again, i'm stuck in abstraction
12:48:51 <sqooq> you can check my code, here http://lpaste.net/358331
12:48:59 <pikajude> I thought ST was good for writing concurrency primitives
12:49:04 <pikajude> i would suggest MVar
12:49:21 <cjh`> hmm I wonder what else I can (ab)-use laziness for
12:49:26 <cjh`> thanks all for your time :)
12:49:38 <ggVGc> sqooq: IORef is the "broadest" mutable reference. But it's really only for things that are actually IO. A lot of the time if you just really need a mutable state, you can use the ST monad. An MVar is almost like IO, but a little bit less
12:49:43 <ski> `ST' is for local mutable references
12:50:09 <ggVGc> problem is once you head into IORef, you're in IO, and then you'll always be in IO
12:50:18 <ski> `MVar' has concurrency synchronization
12:50:21 * cjh` always messes up State and ST, keeps thinking they are the same thing, etc.
12:50:22 <pikajude> well isn't that the case for ST too
12:50:29 <pikajude> except :%s/\<IO\>/ST/g
12:50:32 <pikajude> same thing
12:50:35 <ggVGc> pikajude: you can evaluate ST and get out of it
12:50:39 <ski> (`ST' has no concurrency)
12:50:46 <pikajude> oh
12:50:48 <pikajude> you can?
12:50:54 <ggVGc> afaik
12:50:55 <pikajude> i've never used ST
12:51:01 <ggVGc> that's the whole point
12:51:05 <pikajude> not on purpose, anyway
12:51:08 <pikajude> well that makes a lot more sense, LOL
12:51:12 <ggVGc> "run this piece of code that uses mutable state"
12:51:16 <ggVGc> and then get a result
12:51:22 <pikajude> i thought ST was just an unnecessarily complicated way to do the same thing IO does
12:51:26 <ggVGc> now you're no longer using mutable state
12:51:36 <ggVGc> you can't escape IO
12:51:44 <ski> > runST (do ref <- newSTRef 1; replicateM_ 5 (modifySTRef ref (2 * )); readSTRef ref)
12:51:46 <lambdabot>  32
12:51:47 <pikajude> yes you can
12:51:52 <pikajude> just not morally
12:51:53 <ggVGc> how?
12:51:55 <ggVGc> haha
12:51:56 <ggVGc> yeah well
12:52:00 <average> after some time, i think i can understand at least the mindset of a haskell programmer
12:52:06 <pikajude> that makes so much more sense
12:52:13 <pikajude> I can't believe I've spent this long not knowing that you can runST
12:52:27 <ggVGc> ST wouldn't really be very useful if you couldn't
12:52:32 <pikajude> oh, you know why
12:52:34 <pikajude> it's because I thought ST was STM
12:52:36 <average> reading this channel is funny tho
12:52:38 <pikajude> oops
12:52:46 <pikajude> have still never used ST
12:53:00 <mauke> runSTM is called 'atomically' :-)
12:53:03 <ggVGc> pikajude: State on the other hand is just another syntax for a fold
12:53:05 <ggVGc> basically
12:53:09 <ski> "State Thread" vs. "Software Transactional Memory"
12:53:14 <monochrom> Ah, yes STM is good for concurrency.
12:53:26 <monochrom> The problem with acronyms
12:53:32 <sqooq> well my code is gtk stuff
12:53:36 <sqooq> so I have to use IORef no
12:53:37 <ski> also "AST" meaning two different things
12:53:38 <sqooq> ?
12:53:46 <pikajude> i use exclusively ASTM
12:53:46 <ggVGc> sqooq: depends on which part of the code
12:54:09 <ski> ggVGc : i wouldn't say that about fold ..
12:54:18 <sqooq> did you look at it?
12:54:23 <ggVGc> ski: how so?
12:54:31 <sqooq> I'm updating a chart in real time based on mouse interaction
12:54:37 <sqooq> so I store the info to build the chart
12:54:43 <sqooq> and just continuously draw it to the screen
12:54:49 <sqooq> and update that info with mouse
12:54:50 <bbear> any idea how to da recursive search in a hash map
12:54:57 <bbear> that would emulate a linked list ?
12:55:05 <ski> if anything, i'd expect people to relate `State' more to `unfoldr' ..
12:55:29 <ski> ggVGc : fold on which data structure ?
12:55:44 <`Guest00000> so
12:56:07 <ggVGc> ski: any Foldable. But I might be talking out of my ass. I just feel I can use State or fold interchangably
12:56:20 <ggVGc> in practice
12:56:21 <`Guest00000> i want a thing like IO in that you can `performIO :: IO a -> a`, but without actual real world side-effects
12:56:23 <ski> average : would you like to elaborate on this mindset, perhaps ?
12:56:38 <StrangeLoop> Hi. I'm trying to implement a deck of cards, and for this I want a data type which holds the value of a card. I want it to be restricted so I don't want just "data Value = Int", on the other hand I don't want something ugly like "data Value = C1 | C2 | C3" and so on, what would be the idiomatic way to achieve this? Is this possible to contain this constraint in the type definition?
12:57:00 <barrucadu> `Guest00000: What would that do?
12:57:04 <ski> ggVGc : `Foldable' roughly means `ToList' (not quite, but it's a good zeroth approximation ..)
12:57:09 <ggVGc> `Guest00000: well, that'd be any monad?
12:58:15 <ski> StrangeLoop : perhaps you could use an abstract data type
12:58:17 <`Guest00000> ggVGc: omg, your name is vim key sequence, right?
12:58:21 <ggVGc> yep
12:58:50 <`Guest00000> it feels quite abstract
12:59:01 <sqooq> StrangeLoop: How about Card CardSuit Int, where CardSuit is Spades | ...
12:59:21 <sqooq> then Int will only go up to what 13?
12:59:24 <sqooq> 14?
12:59:43 <`Guest00000> barrucadu: ggVGc: so, using this thing i could perform "actions" defined by me in my own monad whenever certain values would be forced; but those actions could never escape execution of runMyMonad
12:59:57 <ski> StrangeLoop : LiquidHaskell would possibly allow you to enforce the bounds on the `Int' .. but that may be a bit too much to take in, for a beginner
13:00:03 <StrangeLoop> sqooq: 13, I guess, but how do I make sure of that? I can check this holds or trust the user not to make non-existing cards, but I feel there should be a way to avoid that
13:00:13 <ggVGc> `Guest00000: isn't that literally what a monad is
13:00:13 <ski> (enforce statically, i. e.)
13:00:15 <barrucadu> `Guest00000: Well, if you define the monad, you can of course write a `runMyMonad :: M a -> a` function
13:00:16 <StrangeLoop> I'll look up abstract data type
13:00:18 <sqooq> Idk that's beyong me tbh
13:00:20 <sleblanc_> `Guest00000, yes. You implement bind and return in terms of your monad
13:00:26 <sqooq> There's probably a way to incorporate errors into it
13:01:23 <ggVGc> ski: isn't this where dependent types and agda gets brought yp?
13:01:25 <ggVGc> up*
13:02:23 <ski> StrangeLoop : you can make a "smart constructor" `makeValue' that will error out (using `Maybe' or not, as preferred) if passed a value out of range. provided that you write it correctly, and doesn't provide any other way to forge `Value's, you should then be able to rely on the range being correct
13:02:40 <ski> ggVGc : LiquidHaskell was already mentioned
13:04:49 <iqubic> What is LiquidHaskell?
13:06:24 <hpc> it's like haskell but wet
13:06:28 <hpc> oh, and it's got dependent types
13:06:56 <pikajude> just bring some paper towels when opening your editor
13:07:05 <iqubic> Oh, that's weird.
13:07:40 <hpc> needless to say, it doesn't follow the principle of DRY
13:07:50 <sleblanc_> iqubic, in an nutshell, value-dependent types are types that depend on their values. for instance, you could have a list of integers greater than 5
13:07:58 <ski> @where LiquidHaskell
13:07:58 <lambdabot> I know nothing about liquidhaskell.
13:08:03 <ski> @where+ LiquidHaskell "LiquidHaskell (LH) _refines_ Haskell's types with logical predicates that let you enforce critical properties at _compile time_." <https://ucsd-progsys.github.io/liquidhaskell-blog/>,<https://github.com/ucsd-progsys/liquidhaskell>,<http://hackage.haskell.org/package/liquidhaskell>
13:08:04 <lambdabot> Done.
13:09:56 <`Guest00000> ggVGc: sleblanc_: in monads, actions are executed by binding; in my thing, actions would be executed on forcing of given values, like unsafePerformIO
13:10:26 <ski> `Guest00000 : like .. comonads ?
13:10:46 <ski> (depending on what you mean by "execute", of course)
13:11:12 * ski idly recalls a certain paper on the `OI' comonad
13:11:25 <barrucadu> You want some effect to happen when a value is forced?
13:11:33 <`Guest00000> right
13:11:38 <barrucadu> Why?
13:11:39 <monochrom> "actions are executed by binding" sounds wrong.
13:11:52 <`Guest00000> monochrom: rephrase it
13:12:13 <monochrom> Actions are composed by binding. If "binding" refers to >>=.
13:12:46 <monochrom> (Not the direction you were thinking? Bwhahahaha...)
13:12:50 <ski> "execution" is monad-specific
13:13:02 <ski> (there can be more than one way to "execute", as well)
13:13:09 <monochrom> Yeah, the "execution" part might not even exist.
13:13:16 <`Guest00000> this is not exactly what i meant, i meant that the only way to execute actions is by using >>=
13:13:22 <erisco> guess hackagebot is sleeping… so, go nuts http://hackage.haskell.org/package/data-foldapp-0.1.0.0
13:13:31 <ski> `Guest00000 : that's still misleading
13:13:37 <sqooq> god I wish code had a clear order to it
13:13:45 <monochrom> Even when you have IO in mind, execution is by an external runtime system rather than by >>=
13:13:53 <ski> `Guest00000 : better (but useless) would be to say that the only way to execute actions is by executing them
13:14:16 <`Guest00000> ski: i don't understand this
13:14:19 <monochrom> >>='s only job is to tell the RTS "I have a compound action, and its two constituents are..."
13:14:28 <`Guest00000> well
13:14:31 <monochrom> So anyway your sentence is wrong even for IO.
13:14:37 <`Guest00000> what i want my thing to do is
13:14:39 <ski> `Guest00000 : *execution* of `ma >>= amb' causes execution of `ma'
13:15:05 <ski> `(>>=)' doesn't somehow by itself cause execution
13:15:14 <`Guest00000> break referential transparency, but only outside of "inner code" and only controllably
13:15:34 <ski> (more specifically, *evaluation* of `ma >>= amb' does not cause execution of `ma')
13:16:10 <`Guest00000> you have `parse :: String -> Parse; parse ('!':c:l) = Excl c : parse l; parse [] = []; ...`
13:16:23 <`Guest00000> you want to get `incrementalParse`
13:16:31 <`Guest00000> which accepts pieces of String
13:16:48 <monochrom> >>= cannot be a necessary condition for execution either.
13:16:57 <monochrom> "main = print ()" doesn't have >>=
13:17:18 <ertes> `Guest00000: what's your goal, and why do you think you need to break purity to achieve that goal?
13:17:20 <monochrom> "runState (get) 0" doesn't have >>=
13:17:21 <`Guest00000> but when it's not ready to return elements, it returns the code for input exausted
13:18:03 <`Guest00000> so, the goal is to create a function which will take `parse`-type functions and return `incrementalParse`-type functions
13:18:15 <ski> `Guest00000 : so return a function that expects the remaining input ?
13:18:27 <`Guest00000> and we can't edit `parse`
13:18:49 <ski> that sounds undoable
13:19:15 <ertes> `Guest00000: sounds like you're trying to fix a library by hacking it from outside
13:19:16 <ski> with enough effort, i suspect it could be proven to be undoable
13:21:29 <`Guest00000> but why is it undoable?
13:22:10 * ski idly ponders a source-to-source translation over Haskell, that inserts monadic wrappers everywhere there's potential for non-strictness
13:22:31 <`Guest00000> i think an API can be created, which neither breaks referential transparency for the analyzed code, `parse`, nor for any caller code, but breaks it only in the middle
13:22:51 <monochrom> Yes it is doable but requires access to the source code.
13:23:13 <monochrom> Haskell denies that to uphold another desirable property.
13:23:29 <ertes> i would fix 'parse' directly
13:23:38 <ertes> even if it's doable somehow, this is not going to be pretty
13:23:53 <`Guest00000> ertes: why
13:24:25 <`Guest00000> why wouldn't you want to break some purity in a controllable, limited way, where you know what you're doing?
13:24:26 <ertes> `Guest00000: because impure code is susceptible to all kinds of problems
13:25:02 <ertes> `Guest00000: don't be surprised if your code breaks between compiler versions or even just optimisation flags
13:25:02 <ski> one constant worry is that the implementation may not know what you're doing
13:25:10 <monochrom> I don't think the point is breaking purity.
13:25:48 <monochrom> The point is is there actually an algorithm for it and what does it require?
13:26:24 <`Guest00000> one problem is compiler reordering forcings, and that breaking determinism for actions result
13:27:12 <monochrom> And BTW this is what's wrong with the "I have a very simple idea but it only gets complicated when communicating it to other people via a language" delusion.
13:27:55 <monochrom> The fact is your "very simple" idea is actually full of complications and exceptions and loopholes but you just don't realize it until you tell other people and other people poke holes left right and centre.
13:28:28 <`Guest00000> solution: runtime will return action results not plainly, but in a structure that captures forcing order in a way that kills non-determinism
13:28:28 <monochrom> This is not about language. This is about following a premise to its logical conclusion. This is about the road to hell is paved with well intention.
13:28:50 <monochrom> See also the Dunning-Kruger effect.
13:29:20 <`Guest00000> monochrom: there is an algorithm, unsafePerformIO
13:29:36 <ertes> `Guest00000: to get a taste for the kinds of problems you're gonna have to deal with read the docs on unsafePerformIO
13:29:40 <monochrom> unsafePerformIO doesn't let you access source code or add breakpoints or...
13:30:04 <geekosaur> unsafePerformIO does one thing: it tells the compiler that something impure should be treated as pure.
13:30:12 <ertes> `Guest00000: honestly, just don't do it…  fix 'parse' directly by changing its source code
13:30:14 <geekosaur> the compiler will trust this, and the result is often the opposite of what you intend
13:30:18 <monochrom> Anyway you could falsify what I said by showing a demo program.
13:30:35 <hpc> another way to put it is that unsafePerformIO binds execution to evaluation
13:30:50 <hpc> if foo is evaluated, bar execution happens
13:30:51 <monochrom> This is the problem with armchair philosophy.
13:31:04 <geekosaur> because the compiler will trust that it can not call it if it already has a result from a call with the same parameters, or call it multiple times, if it so chooses --- because that is what purity allows.
13:31:09 <ertes> unsafePerformIO breaks semantics, and it's incredibly difficult to recover from that
13:31:20 <ski> monochrom : it's always someone else's problem ?
13:31:51 <monochrom> Just talking loudly "I have a great idea and I can just call this function to do it" is very cheap. Everyone can do it. At this rate, everyone should have a millionaire startup by now.
13:33:24 <ski> imho, `unsafePerformIO act' should only be used when `act' is behaviourally equivalent to `return x' for some `x' .. unless you *really* know what you're doing (and if you're unsure, you don't)
13:33:54 <`Guest00000> does Haskell have capturing continuations in IO like the following API: `data ContResult a = Finished a | Suspended HiddenType; catchCont :: IO a -> ContResult a; throwCont :: IO ()` ?
13:34:10 <`Guest00000> `contCont :: ContResult a -> IO a`
13:34:12 <monochrom> I am fine with side effects. I even suggest that a few pure functions like sortBy should use unsafePerformIO to randomize its sorting algorithm.
13:34:29 <ski> (not when some larger computation in which this `unsafePerformIO act' is located is thought to be side-effect-free)
13:34:48 <ertes> `Guest00000: the only built-in control mechanism in IO is exceptions
13:35:04 <ertes> well, and concurrency
13:35:12 <monochrom> But you are looking at the wrong hammer. To convert an end-to-end parser to an incremental parser during run time, you need reflection.
13:36:26 <ski> (fwiw, `catchCont' looks strangely typed)
13:37:20 <ertes> `Guest00000: (Free IO) is IO with breakpoints
13:39:53 <`Guest00000> ski: sorry, it should be `IO a -> IO (ContResult a)`, of course
13:40:23 <StrangeLoop> http://lpaste.net/1363400397036716032 <--- could someone help me understand this compilation error?
13:40:47 <monochrom> Yikes, Free IO may be too big.
13:41:18 <ertes> StrangeLoop: randomSplit is not an IO action
13:41:26 <ertes> StrangeLoop: you can't use getStdGen there
13:42:02 <StrangeLoop> How on earth does this anything to do with the compilation error I got? :(
13:42:19 <monochrom> getStdGen doesn't mean what you think. If anything, newStdGen.
13:42:55 <StrangeLoop> Randomness in Haskell is problematic...
13:43:07 <monochrom> Yes.
13:43:22 <ertes> StrangeLoop: explaining that particular type error will require a bit of experience
13:43:25 <monochrom> Generally, all magics are problematic in Haskell.
13:43:39 <ertes> > return 5 :: (String, Integer)
13:43:41 <lambdabot>  ("",5)
13:44:12 <ertes> StrangeLoop: for now just make sure whenever you use 'do' and/or 'return' that you're actually writing an IO action
13:44:37 <StrangeLoop> I'm not even sure what that means...
13:45:01 <geekosaur> then you need to learn that
13:45:07 <StrangeLoop> I guess I do
13:45:12 <ertes> StrangeLoop: randomSplit :: Deck -> IO (Deck, Deck)  -- this is an IO action
13:45:29 <ertes> well, let's be more precise
13:45:34 <geekosaur> StrangeLoop, http://www.vex.net/~trebla/haskell/IO.xhtml
13:45:34 <monochrom> Anyone want my IO tutorial?
13:45:36 <ertes> StrangeLoop: randomSplit :: Deck -> IO (Deck, Deck)  -- this is a function that returns an IO action
13:45:39 <geekosaur> :p
13:45:42 <monochrom> Spoiler!
13:46:01 <ertes> StrangeLoop: randomSplit :: Deck -> (Deck, Deck)  -- this is just a regular function that returns a tuple, not an action
13:46:34 <monochrom> So basically this is why when people "encouragingly" say "Haskell is easy to learn!" I have much reservation and disagreement.
13:46:46 <StrangeLoop> Is there a formal definition of "action" in this context?
13:47:03 <ertes> StrangeLoop: an action is a value of type (IO X) for some type X
13:47:14 <StrangeLoop> They told me it should be easy for me as a mathematician, nah
13:47:18 <monochrom> If your "dive-in project" is intensive in interactions, it is actually harder at the beginning.
13:47:35 <StrangeLoop> So "an action" is just a nice way of describing something wrapped in the IO monad?
13:47:56 <ertes> StrangeLoop: don't say "wrapped"
13:47:57 <monochrom> You need a data-crunching project to look easy, for example binary search tree algorithms, that's a breeze.
13:48:02 <hpc> monochrom: imo difficulty is not attached to a concept, but how you learn it
13:48:11 <monochrom> (A breeze for even beginners.)
13:48:19 <hpc> and with a smooth logical progression between concepts, haskell is easy to learn
13:48:25 <StrangeLoop> My initiation project is to shuffle cards
13:48:27 <hpc> if you find the route that works for you
13:48:31 <ertes> StrangeLoop: read the article linked a moment ago…  it explains this in detail
13:48:38 <StrangeLoop> OK, thanks
13:49:04 <StrangeLoop> Why not say "wrapped" BTW? I understand monads aren't tiny boxes, but it is wrapped in... I dunno, context?
13:49:13 <monochrom> Well I think I agree with you. What I said is "if your 'dive-in project' is a lot of I/O, well that's the wrong first project". So yeah, order.
13:49:22 <ertes> StrangeLoop: because an (IO Integer) is *not* an integer…  not even a wrapped or a "tainted" one
13:49:45 <monochrom> StrangeLoop: The "ls" command or the "dir" command doesn't wrap a secret answer.
13:49:53 <monochrom> Not even in the daily English sense.
13:50:00 <ertes> an (IO Integer) is related to an integer in much the same way a bakery is related to a loaf of bread
13:50:07 <monochrom> So just give up on wrapping. Flawed.
13:50:15 <Tuplanolla> A different perspective, StrangeLoop: wrapping implies unwrapping is easy.
13:50:26 <mauke> s/easy/possible/
13:50:34 <Tuplanolla> For most monads this is not the case.
13:50:35 <monochrom> So getLine is more analogous to ls than to "data X a = Secret a"
13:51:17 <ertes> BTW, this is a case of IO being confusing, not monads being confusing…  monads aren't even the topic here
13:51:56 <Tuplanolla> If we had a comonad, however...
13:51:57 <monochrom> Oh monads in general are going to be even worse. You don't even have a guarantee of "executed at most once".
13:52:10 <ertes> don't worry, you'll get your dose of monads being confusing…  just not right now =)
13:52:31 <StrangeLoop> OK, so these are a lot of ways in which one should not think about "IO Int". How DO you think about it? If you have a formal definition I think that would be easiest for me
13:52:53 <monochrom> That is answered by that link above.
13:52:59 <ertes> StrangeLoop: if you really want an intuition, go with reading "IO" as "ProgramThatReturns"
13:53:11 <monochrom> Part of the learning process involves solitude reading sessions.
13:53:33 <mauke> Solitude by the Window.mp3
13:53:45 <iqubic> ertes: I'm still working on the indexed traversal puzzle.
13:53:58 <StrangeLoop> I read LYAH, but I found it kinda annoying when it came to the abstract concepts, as if its trying to shield me from abstractness
13:54:08 <ertes> iqubic: great…  you're gonna figure it out!
13:54:22 <average> StrangeLoop: are you well-versed in math?
13:54:22 <iqubic> indexed traversal into the chars of a string
13:54:36 <ertes> iqubic: letters, not chars
13:54:53 <StrangeLoop> I'm in the middle of a Ph.D actually
13:54:58 <ertes> iqubic: i.e. chars that match the isAlpha predicate from Data.Char
13:55:02 <average> StrangeLoop: a phd in what
13:55:06 <StrangeLoop> Math
13:55:20 <average> Ph.D could even mean "pizza hut delivery"
13:55:24 <average> so.. yeah
13:55:36 <monochrom> Aw I don't think we're that naughty.
13:55:58 <iqubic> ertes: what do I do if given the string "1a2b3c"??
13:56:02 <StrangeLoop> My masters is in mathematical logic, my current research is in quantum computation, it involves some homological algebra so I'm pretty versed in category theory
13:56:14 <StrangeLoop> I thought that would be an advantage, that's why I chose Haskell
13:56:19 <ertes> iqubic: then your traversal should point to 'a', 'b' and 'c', leaving the digits alone
13:56:26 <average> StrangeLoop: why not Ocaml?
13:56:35 <average> anyways, the choice is not that relevant
13:56:35 <ski> StrangeLoop : more generally, an `m'-action is a value of type `m a', for some type `a', and `m' being some monad
13:56:39 <ertes> StrangeLoop: it will be, but not right now
13:56:40 <StrangeLoop> I dunno, never having heard of it might have been a factor
13:56:44 <average> i'm sure there's better books more mathy for Haskell
13:56:49 <average> but not mathy in the useless sense..
13:56:54 <sqooq> ok I've decided that I hate haskell
13:56:55 <ski> StrangeLoop : thinking of it as a recipe can be a useful analogy
13:56:59 <sqooq> I hate functional programming
13:57:03 <sqooq> I'm gonna teach myself C
13:57:05 <average> sqooq: but it's all the rage!
13:57:07 <sqooq> and redo my program in that
13:57:13 <iqubic> why sqooq?
13:57:15 <sqooq> I can't take this anymore
13:57:20 <average> hahaha, yes ! enlightenment at last!
13:57:30 <average> sqooq: use Bash bro, it's the s***
13:57:31 <pikajude> it's ok, C is a much more viable language
13:57:43 <monochrom> I'm OK with hating functional programming. But you don't have to go C. There are Pascal and Ada.
13:57:43 <StrangeLoop> Haskell is really darn beautiful as long as you're reading someone else's code
13:57:47 <sqooq> average: Idk what Bash is but it sounds stupid
13:57:59 <average> Bash is the reason you're on IRC now
13:58:03 <sqooq> monochrom: but C is what everything uses
13:58:10 <pikajude> bash is a shell
13:58:15 <sqooq> I just wanted to draw some stupid charts
13:58:16 <pikajude> remember /bin/bash? it's that
13:58:17 <monochrom> Is that important?
13:58:18 <sqooq> in a stupid gtk wnidow
13:58:19 <ertes> does modern cobol have parametric polymorphism?  perhaps use that instead of C
13:58:22 <StrangeLoop> Why C when you could just learn raw binary?
13:58:33 <sqooq> StrangeLoop: I considered that
13:58:37 <average> Bash is also indirectly the reason why you have internet, a linux kernel, and programs in general on Linux, and it's also the reason why you have web servers and websites
13:58:38 <LXX> haskell is not the first place I would go for UI work
13:58:40 <sqooq> but everyone was like "You're gonna hate it !"
13:58:43 <average> like buzzfeed, with pictures of cats and dogs
13:58:43 <mauke> average: what
13:58:48 <sqooq> "You'll regret it!!!"
13:58:52 <sqooq> Not binary though
13:58:53 <StrangeLoop> average: There are other shells, you know...
13:58:53 <average> mauke: it's in pretty much all build systems
13:58:56 <sqooq> at leas Assembly code
13:59:01 <average> StrangeLoop: there are, but bash is the most common one
13:59:09 <kadoban> average: What are you ever even talking about. Are these jokes?
13:59:12 <monochrom> Also, as far as this channel is concerned, Haskell is what everyone uses, if that's what you care about.
13:59:13 <mauke> average: if bash didn't exist, we'd just use ksh or something else
13:59:18 <jmcarthur> StrangeLoop: Suppose we were using a Haskell-like language with evaluation-driven effects the way most languages have. Now suppose we wanted to have different arrow types for pure (->) and impure (=>) functions. You could make a standard library where all impure functions have been changed to be pure functions that return an impure function from unit. For example, (A => B => C) could be (A -> B -> () => C).
13:59:20 <jmcarthur> Now let's define newtype IO a = IO (() => a). And there we go. That's something like what IO really is.
13:59:28 <average> mauke: and you'd get millions of errors, yes
13:59:40 <average> mauke: and you wouldn't have time to fix them because guess what, that costs money
13:59:50 <mauke> average: you're missing the point
13:59:51 <LXX> I sometimes explain it as IO is writing the actual code that executes as you go
13:59:55 <average> mauke: you don't have a point
13:59:57 <monochrom> Anyway I have no idea how the logic goes from "I just want to get shit done" to "therefore I'll use what everyone uses". Do you?
13:59:58 <jmcarthur> This was my first time trying this kind of explanation for IO, and it was off the cuff, so I think it came out badly.
14:00:12 <average> mauke: you don't even have a line, now sit down, thanks
14:00:18 <mauke> hmm
14:00:20 --- mode: ChanServ set +o mauke
14:00:27 <mauke> I don't like where this is going
14:01:00 <LXX> So like I don't think anyone starts at Haskell - haskell is where you land when you have to manage a lot of complexity in a program and are sick to death of c/python/etc
14:01:21 <StrangeLoop> jmcarthur: You say that IO allows us to defer the impurities?
14:01:38 <sqooq> what's a shell
14:01:42 <iqubic> StrangeLoop: Yes. Pretty much.
14:01:43 <ertes> jmcarthur: i don't like your metaphor very much
14:01:44 <StrangeLoop> LXX: Obviously, bad choice for a first language
14:01:44 <sqooq> can it do gtk
14:01:44 <jmcarthur> StrangeLoop: You could think of it that way. In the case of Haskell, we defer it all the way to main.
14:01:45 <ski> StrangeLoop : one can imagine something like `data IO a where Return :: a -> IO a; Bind :: IO a -> (a -> IO b) -> IO b; GetChar :: IO Char; PutChar :: Char -> IO (); ...'. so an `IO X' is a data-structure that the RTS traverses and interprets ("executes") as it goes
14:01:47 <mauke> LXX: some people learn haskell first
14:01:54 <jmcarthur> ertes: I would love criticism.
14:01:55 <ertes> StrangeLoop: IO is actually a pure concept
14:02:01 <monochrom> jmcarthur: That's an interesting model. I think I will think more about it.
14:02:01 <LXX> the fact you can separate pure/impure things and separate data and code makes things far nicer for complex things
14:02:12 <monochrom> You know what, that's GHC's model.
14:02:19 <LXX> mauke: really?
14:02:21 <ertes> jmcarthur: i prefer the IO-as-a-DSL metaphor, because it doesn't require language extensions or weird extra semantics
14:02:22 <sqooq> I learned haskell first
14:02:26 <sqooq> maybe that's my problem
14:02:30 <sqooq> the early days were fun af
14:02:41 <sqooq> building a parser was fun
14:02:47 <sqooq> pretty much every part of my program was fun
14:02:53 <sqooq> except this little gtk part
14:03:08 <sqooq> this part is hell
14:03:09 <StrangeLoop> DSL?
14:03:10 <jmcarthur> ertes: "Secretly," I agree with you. However, my hope was that this explanation would appeal to those who are used to imperative programming without being misleading.
14:03:10 <ski> LXX, yes
14:03:21 <sqooq> makes me want to throw my laptop into the hurrican
14:03:27 <iqubic> why?
14:03:33 <jmcarthur> ertes: That is, I find many of the "imperative friendly" explanation to be half-lies, whereas I think this one is not.
14:03:36 <ski> StrangeLoop : "Domain Specific Language"
14:03:43 <hpc> sqooq: it seems like your problem is more the other parts around programming
14:03:43 <geekosaur> graphics are a known pain point because your choices are basically (a) trying to force a procedurally oriented toolkit to work with Haskell (b) trying to force FRP on a procedurally oriented toolkit
14:03:47 <ertes> StrangeLoop: an (IO String) is a program or, as some call it, a "recipe" for coming up with a String…  all you can do in haskell is to *compose* these programs…  you can never run an IO action
14:03:51 <iqubic> sqooq: What's wrong?
14:03:57 <geekosaur> sometimes thre right thing to do is write the frontend in a different language
14:04:02 <hpc> sqooq: i suggest learning what a shell is, and starting with something simpler than gtk
14:04:14 <sqooq> nah
14:04:18 <sqooq> i'm going to C
14:04:21 <hpc> sqooq: if all you really need to do is make a graph of something, check out R maybe
14:04:21 <monochrom> To a large extent, every compiler has to eventually come to terms with that model. (Even if the compiler uses the DSL aka free-monad model as an intermediate.) Because eventually you are running on a computer that provides that model only.
14:04:24 <sqooq> and learning gtk
14:04:26 <pikajude> G! T! K! Gonkey T Kong!
14:04:33 <sqooq> hpc: make a graph and interact with it
14:04:35 <sqooq> I can make a graph
14:04:38 <sqooq> I can interact with it
14:04:42 <StrangeLoop> I also prefer standalone explanations treating Haskell as something new rather than trying to relate it to imperative programming. The point is to detach myself from the paradigm
14:04:52 <sqooq> but only by adjusting the coordinates manually for one given window size
14:05:08 <sqooq> all i wanted to do, was adjust the coords automatically based on the graph itself
14:05:09 <sqooq> but nooooo
14:05:25 <sqooq> I've been reading the library source over and over
14:05:31 <sqooq> for at least a day now
14:05:33 <sqooq> 24 hours
14:05:38 <sqooq> I give up
14:05:40 <ertes> jmcarthur: StrangeLoop noted that they are mathematically versed, so i think it's fine to just explain IO the way it is:  it's a composition framework for programs
14:05:55 <LXX> python w/QT is not bad for UI stuff, though the cult of webapp grows
14:06:21 <average> sqooq: C is a very good choice, not to mention you can actually monetize it.
14:06:34 <jmcarthur> ertes: I hadn't noticed that, but I don't object to the DSL-style explanation either.
14:06:39 <sqooq> average: ok if you're saying it i may have to reconsider
14:06:57 <hpc> my experience with python libraries has been that they have awful documentation, to the point of being even harder to use than haskell libraries
14:07:01 <ski> Haskell used to have dialogue-based I/O -- but that's not compositional, in itself (also error-prone)
14:07:02 <jmcarthur> ertes: But to be fair, IO isn't very mathematical. It has no denotation anyway.
14:07:34 <ski> after building compositional abstractions, it's not a long step to making a monad
14:07:35 <ertes> jmcarthur: that's true, but we can understand the haskell-level framework with equational reasoning to some extent
14:07:40 <StrangeLoop> My worst experience with libraries is definitely C. I had to integrate something with openSSL once and it was a livid nightmare
14:07:54 <ertes> jmcarthur: and the haskell-level composition framework is indeed very mathematical
14:07:56 <sqooq> StrangeLoop: O god are you saying it's inescapable
14:08:00 <sqooq> maybe I just hate programming
14:08:05 <average> StrangeLoop: because of the timeframe you were allowed or because you just hated it?
14:08:07 <pikajude> a living nightmare, right?
14:08:10 <pikajude> a livid nightmare would just be
14:08:13 <pikajude> kind of pale
14:08:16 <ertes> python's library landscape is way worse than C's, in my experience
14:08:26 <hpc> python's library landscape /is/ C's
14:08:33 <pikajude> and yet, somehow worse
14:08:34 <StrangeLoop> average: because the openSSL library is very poorly documented and kinda buggy (remember heartbleed?)
14:08:37 <kadoban> sqooq: Bad libraries exist in every language. And even good libraries can be hard to understand completely. So I mean, no none of this is unique to haskell.
14:08:45 <average> ertes: Python has a pretty good toolchain for bindings
14:08:50 <monochrom> Worse because you worry about both C and Python at the same time.
14:08:53 <average> ertes: so I'm not sure why you're throwin it under the bus
14:08:54 <sqooq> kadoban: then I think I quit
14:08:58 <hpc> i have lost count of the number of times i have had to dig into undocumented python source, discover it's a C wrapper, then look for C docs
14:08:58 <sqooq> I mean my code works
14:09:07 <StrangeLoop> Python is great and you're just being a hater :/
14:09:14 <sqooq> anyone wanna make microtonal music knock yourself out, you jsut won't be able to change the note velocities very easily
14:09:15 <monochrom> Ever heard of "worst of both worlds"? >:)
14:09:19 <hpc> and then finally knowing what i am looking at, roll the whole thing back up into "how do i call this from python"
14:09:21 <LXX> is anyone here smart enough to use HXT - i want to understand that one someday
14:09:22 <sqooq> https://github.com/Cypress-the-Kinaesthetician/Goulds-Mark
14:09:45 <monochrom> Anyway I thought you still have 3-4 days.
14:10:24 <ertes> StrangeLoop: i am a hater, but i can explain *why* i hate it…  not gonna do that in #haskell though =)
14:10:55 <sqooq> monochrom: me?
14:11:08 <sqooq> Hurricane hits tomorrow. Maybe I'll die, Maybe I won't
14:11:25 <sqooq> I hope I do
14:12:07 <StrangeLoop> So to recap, an m-action is a function m a -> a ?
14:12:32 <StrangeLoop> Which I ill-described as "unwrapping"
14:12:43 <mauke> StrangeLoop: er... no?
14:12:43 <ertes> StrangeLoop: an 'm'-action is a value of type (m a) for some 'a'
14:12:45 <geekosaur> m a is the m-action
14:13:02 <ski> (the value of type `m a' is the `m'-action)
14:13:17 <geekosaur> sometimes it is a container, sometimes it is a description of an action not under your control (as in IO)
14:13:21 <ski> `[0,1,2]' is a `[]'-action, aka "a list"
14:13:45 <StrangeLoop> OK, so you think of monads not as "something that holds a" but as "something which resolves to an a"
14:13:48 <jmcarthur> I am not convinced the word "action" outside of IO makes much sense.
14:13:49 <LXX> So the property of a monad is there's a way to go from m m a to m a. If you have eg putStrLn "Hi" >> putStrLn "What!" bind does this action for you on IO
14:13:54 <remexre> Is it not-wholly-inaccurate to describe a lens as being similar to a functor, but with the thing it wraps being potentially determined at runtime instead of compiletime?
14:14:00 <StrangeLoop> kinda like the way Leibniz described them :P
14:14:00 <geekosaur> anfd even the things recognizeable as "containers" may not behave simply: a list action considers all elements of the list "in parallel"
14:14:13 <ertes> StrangeLoop: no matter what combination of words you come up with, it will always miss a few monads
14:14:21 <kadoban> remexre: Sounds quite innacurate, but I'm no lens expert.
14:14:26 --- mode: mauke set -o mauke
14:14:29 <LXX> if you use >>= you can get use the thing in the IO container
14:14:30 <ertes> StrangeLoop: even 'action' is misleading, but it has become kind of a standard term
14:14:31 <StrangeLoop> Really? I thought "resolve" was meaningless enough
14:15:00 <sqooq> maybe I should just make my own graph library
14:15:13 <sqooq> that literally sounds easier rn
14:15:22 <sqooq> than figuring out how to do what I want with Chart
14:15:23 <ski> StrangeLoop : a math example, `Powerset' is a monad, and a subset of a set/type `X' is a `Powerset'-action
14:16:12 <StrangeLoop> I think "action" is a good word though, if you don't think of it as something dynamic but as something similar to "action of a group on a set"
14:16:30 <ski> it's for sure a technical term in this context
14:17:53 <jmcarthur> Okay, after thinking about it for a bit, the apparent lack of a better word for this purpose convinces me I should just make it a part of my vocabulary.
14:18:03 <Gurkenglas> remexre, a "Lens' s a" is a witness that "s" is a product of "a" and some other type
14:18:28 <monochrom> jmcarthur: That's what I did too. :)
14:18:33 <jmcarthur> Is "action" limited to monads, or does it also work for functors which are not monads?
14:18:49 <monochrom> Ah that's thorny.
14:18:59 <ski> i tend to also use it for idioms
14:19:03 <StrangeLoop> OK, apparently Suanders Maclane defines monads as monoids in End(X)
14:19:15 <monochrom> I extend it to Applicative but I haven't really done it as far as Functor.
14:19:15 <centzilius> Hi, could some please help me and tell me what is wrong with line 30 http://lpaste.net/358337 (Error: http://lpaste.net/358338)
14:19:18 <StrangeLoop> I wonder if this reflects to Haskell
14:19:21 <jmcarthur> StrangeLoop: There's a popular quote about that.
14:19:26 <ski> StrangeLoop : not really
14:19:26 <ertes> remexre: you know 'traverse'?  what if 'traverse' had a Functor constraint on it, rather than Applicative?
14:19:39 <Logio> StrangeLoop: I like that definition for haskell 
14:19:50 <monochrom> With Functor I think I secretly use "structure" or "container" but I haven't said it in public.
14:20:02 <remexre> ertes: I don't actually know traverse :P I know its existence, but not much more
14:20:06 <monochrom> In fact, I secretly think "pretend it's a list" :D
14:20:11 <c_wraith> StrangeLoop: You can express that definition in haskell, but it has nothing to do with the Monoid class.
14:20:13 <ertes> remexre: also called mapM
14:20:19 <StrangeLoop> A Haskell functor doesn't have all the structure of an actual functor
14:20:32 <ertes> remexre: 'traverse' is just 'mapM' with a more appropriate type
14:20:32 <c_wraith> StrangeLoop: it has more, actually.
14:20:35 <remexre> ertes: oh, okay
14:20:38 <ski> also, Haskell functors are strong functors
14:20:38 <StrangeLoop> So I'm guessing these are more analogies than formal definition
14:20:38 <monochrom> So for example when I learned lenses, first thing I thought was "OK so let f=[], what happens?"
14:20:40 <geekosaur> centzilius, it has no idea what "a" to use for Queue a
14:20:42 <jmcarthur> StrangeLoop: Haskell functors are only endofunctors on Hask.
14:20:58 <geekosaur> this will work in ghci because ExtendedDefaultRules is in effect there, so it will infer () as the type
14:21:02 <ertes> remexre: now imagine that instead of Monad or Applicative, it were constrained to Functor…  what would that imply?
14:21:07 <ski> (lookup "tensorial strength", iirc)
14:21:12 <StrangeLoop> Wait, what's Hask?
14:21:15 <c_wraith> StrangeLoop: haskell's Functor lacks the generality of the full idea, but it's very much completely a Functor
14:21:42 <ski> jmcarthur : i tend to distinguish between "functors" (in Haskell or not), and instances of `Functor'
14:22:21 <jmcarthur> StrangeLoop: Hask is something we pretend is a category where the objects are Haskell types or some handwavy thing related to them.
14:22:25 <remexre> ertes: no guarantee of ordering?
14:22:42 <ertes> remexre: nope…  there is a much stronger restriction
14:22:56 <centzilius> geekosaur: so I guess I have to change smth. in line 6 (please forgive me as I am not very experienced with haskell...) but I don't know how
14:23:08 <StrangeLoop> I thought of functors as ways to lift function composition, but with no guarantee of the composition rule
14:23:12 <centzilius> or more like what to change
14:23:12 <geekosaur> actually no, you just have to specify which "a" on line 30
14:23:15 <jmcarthur> ski: Yeah. I typically do that, too.
14:23:27 <c_wraith> StrangeLoop: The category is haskell types.  The objects are types.  the arrows functions.  the natural transformation on the objects is the type constructor.  the natural transformation on the arrows is the fmap function
14:23:41 <geekosaur> if you change it anywhere else, you limit what kinds of Queue you can make. here, you just need to specify which one to test.
14:23:47 <jmcarthur> ski: It's even harder for me because at work we use OCaml, where there is a *third* definition of "functor"...
14:23:52 <geekosaur> and possibly do multiple tests at different types
14:24:13 <ski> c_wraith : natural transformation ?
14:24:19 <remexre> ertes: maximum size of the output functor? I'm not sure
14:24:28 <ertes> remexre: let's turn it into a class:  class (Functor s) => Sin s where sin :: (Functor f) => (a -> f b) -> s a -> f (s b)
14:24:34 <StrangeLoop> c_wraith: I don't follow, a natural transformation is between functors
14:24:35 <ski> jmcarthur : yea, i know. and over --> there's yet another one
14:24:36 <ertes> err, wait, bad name
14:24:43 <centzilius> geekosaur: but "makequeue" is only supposed to create an empty queue
14:24:45 <ski> @where on-functors
14:24:45 <lambdabot> "On Functors" (in C++,Standard ML,Haskell,Prolog) by Peteris Krumins in 2010-05-17 at <http://www.catonmat.net/blog/on-functors/>
14:24:49 <ertes> remexre: let's turn it into a class:  class (Functor s) => Sg s where sg :: (Functor f) => (a -> f b) -> s a -> f (s b)
14:25:00 <geekosaur> yes, but it still has to have a concrete type for Haskell to accept it
14:25:10 <ertes> remexre: i suggest that ((,) a) is an instance of Sg, but [] is not
14:25:26 <geekosaur> you will find the same problem if you use a list in a compiled program: if it can't determine a type, [] will be ambiguous and throw that same error
14:25:30 <c_wraith> StrangeLoop: right.  replace "natural transformation" with "homomorphism"
14:25:52 <centzilius> geekosaur: how do I specify the type?
14:25:52 <geekosaur> ghci's ExtendedDefaultRules was created specifically so that lists would default to () in that case (so it will infer [] :: [()]
14:26:13 <geekosaur> show (makeQueue :: Queue Int)
14:26:15 <geekosaur> or similar
14:26:15 <ertes> remexre: try it for yourself in order to see *why* [] is not an instance, and why ((,) a) is
14:26:16 * ski supposes c_wraith wanted to talk about how functors relate to instances of `Functor'
14:26:28 <c_wraith> ski: that was the question I was answering, yes.
14:26:41 <remexre> ertes: yeah, I'm trying, but I think I'm gonna need to work it out with pen and paper; gimme a bit to find a working ballpoint...
14:26:51 <geekosaur> or, since when testing you may not care so much about pedanticism, you might just make the program behave like ghci:
14:26:59 <ertes> remexre: i'd work it out with a source code file and GHCi instead of pen/paper =)
14:27:03 <remexre> (I shouldn't ask deep questions when I'm away from my desk)
14:27:11 <geekosaur> put as the first line:   {-# LANGUAGE ExtendedDefaultRules #-}
14:27:18 <geekosaur> (this is a pragma)
14:27:22 <ski> c_wraith : fwiw, even with the replacement, it's not clear that the latter part of that message was about functors (rather than the category `Hask')
14:27:37 <centzilius> geekosaur: ah okay.... thanks. I'll try that
14:27:37 <StrangeLoop> So I think the conclusion from all of this is that IO is a delicate concept and I shouldn't have glossed over it :) I'll read the document you linked, sounds interesting
14:27:59 <ertes> remexre: if you don't have GHCi at your disposal, you can /query lambdabot
14:28:01 <StrangeLoop> But for now I have to go, thank you all for a fascinating discussion
14:28:12 <ertes> remexre: you can define classes and instances using @let
14:28:43 <remexre> okay
14:29:34 <ertes> @let data V2 a = V2 a a deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
14:29:36 <lambdabot>  Defined.
14:29:48 <ertes> remexre: the V2 type i just defined is another example of a functor that is not an Sg
14:29:54 <remexre> sorry this is gonna take a bit, I'm distracted by RL
14:30:00 <ertes> and once you figured out why you will know what "Sg" stands for
14:51:37 <remexre> ertes: Thanks for your help, but I'm probably gonna have to try this later... RL stuff going on. Thanks!
14:54:23 <centzilius> geekosaur: Thanks for your help... have a nice day / night / whatever
14:55:54 <ertes> remexre: i have to leave, so i'm gonna spoil it now: a Traversal relates to a Lens in the same way Traversable relates to Sg, and Sg stands for "Single"
14:57:22 <ertes> remexre: in fact the same way 'traverse' is a special Traversal 'sg' is a special Lens
14:58:56 <ertes> @let class (Functor s) => Sg s where sg :: Lens (s a) (s b) a b; instance Sg ((,) a) where sg f ~(x, y') = (y -> (x, y)) <$> f y'
14:58:57 <lambdabot>  Parse failed: Parse error: instance
14:59:05 <ertes> @let class (Functor s) => Sg s where { sg :: Lens (s a) (s b) a b }; instance Sg ((,) a) where sg f ~(x, y') = (y -> (x, y)) <$> f y'
14:59:05 <lambdabot>  Parse failed: Parse error in expression: y -> (x, y)
14:59:21 <ertes> @let class (Functor s) => Sg s where { sg :: Lens (s a) (s b) a b }; instance Sg ((,) a) where sg f ~(x, y') = (\y -> (x, y)) <$> f y'
14:59:23 <lambdabot>  Defined.
14:59:36 <ertes> > ("hello", "world") ^. sg
14:59:38 <lambdabot>  "world"
15:30:27 <epta> http://lpaste.net/raw/357949 what is the difference between "'True" and "True" there?
15:33:13 <geekosaur> those are type signatures and it's all therefore at type level, and ghc *may* automatically lift a kind-promotable data constructor
15:33:17 <geekosaur> (I don't recall)
15:33:41 <geekosaur> in any case, being type signatures, the data constructor True would normally not be valid there
15:34:17 <geekosaur> but with DataKinds on, 'True is a type of the promoted kind 'Bool
16:00:26 <phaazon> https://twitter.com/acid2/status/904071271197106181/photo/1?utm_source=fb&utm_medium=fb&utm_campaign=phaazon_&utm_content=906905419804762112
16:00:35 <phaazon> ocharles: I laughed so hard :D
16:00:49 <phaazon> though, those extensions are pretty useful
16:00:56 <ocharles> my best tweet ever
16:00:56 <phaazon> you should have put RecordWildSyntax in that list!
16:01:00 <ocharles> basically retired from twitter now
16:01:06 <phaazon> at work my colleagues over abuse it
16:01:21 <phaazon> I stopped asking for its removal in my code review, but damn, I hate it.
16:01:24 <phaazon> ocharles: :DD
16:01:30 <ocharles> <3 recordwildcards, but it should really be used for construction. named field puns for pattern matching
16:01:41 <`Guest00000> is it possible to write a combinator parser implementation that's both simple and efficient?
16:01:45 <phaazon> ocharles: I hate it
16:01:50 <phaazon> it turns a function into a value
16:01:54 <ocharles> meh
16:01:54 <phaazon> confusing everyone.
16:02:08 <ocharles> our record support is shit anyway, at least named field puns removes a bunch of baggage
16:02:19 <ocharles> and recordwildcards is good for constructing a record under an effect
16:02:30 <phaazon> ocharles: well, I disagree with that
16:02:37 <phaazon> it adds nothing interesting
16:02:41 <phaazon> if not confusion
16:02:48 <phaazon> because “wait, that’s a constructor, what the heck?!”
16:02:49 <ocharles> it's subjective, getting agreement on it is futile
16:03:35 <phaazon> ocharles: also, to build value, I’m kind of okay with it
16:03:48 <phaazon> but at my work, my two colleagues use it to destructure
16:03:51 <phaazon> and I HATE it .D
16:03:52 <phaazon> :D *
16:07:24 <phaazon> ocharles: what is the font you used?
16:07:41 <ocharles> dnno, it's just one of those meme generator sites
16:07:45 <ocharles> see bottom left
16:07:54 <phaazon> ah
16:07:57 <phaazon> I downloaded the image
16:07:57 <ocharles> impact, i would guess
16:08:09 <phaazon> and opened krita
16:08:09 <phaazon> ok
16:18:29 <eacameron> I'd like to make a Servant endpoint that serves a file *after* checking with the database. Anyone have pointers? I'm just not sure the best way to respond with a file within a servant handler.
16:18:50 <ski> phaazon : "it turns a function into a value" -- the problem is already present in the base language
16:20:21 <phaazon> ski: ?
16:20:25 <phaazon> ski: ………no?
16:20:47 <phaazon> data F = F { stringF :: String }
16:20:55 <phaazon> stringF’s kind is * -> *
16:21:07 <phaazon> with RecordWildcard, it introduces the same stringF name but with kind *
16:21:17 <phaazon> which is ultra confusing to me
16:21:19 <geekosaur> that sounds confused
16:21:22 <ski> itym, `stringF's type is `F -> String' ?
16:21:29 <geekosaur> stringF is a value, it is kind *
16:21:37 <geekosaur> it happens to be a function
16:21:47 <phaazon> yeah type*
16:21:48 <phaazon> not kind
16:22:01 <phaazon> F -> String vs String
16:22:16 <ski> in `F { stringF = ... }', `stringF' has type `String'. in `stringF myF', `stringF' has type `F -> String'
16:22:29 <ski> SML did this better
16:22:50 <phaazon> ski: I don’t like changing type of symbols on the fly like that
16:22:58 <phaazon> and it’s not consistent with the rest of Haskell
16:22:58 <ski> phaazon : neither do i
16:23:03 <phaazon> since Haskell doesn’t allow for shadowing
16:23:04 * ski nods
16:23:08 <phaazon> while, well, it is some kind of shadowing.
16:23:19 <pikajude> haskell allows shadowing
16:23:21 <pikajude> it warns you about it
16:23:30 <ski> in SML, `#foo' is the field accessor function for the field named `foo'
16:23:31 <phaazon> pikajude: then it disallows it.
16:23:35 <phaazon> I compile with --pedantic
16:23:41 <pikajude> ok
16:23:55 <ski> you can say `{ foo = ... }' and you can say `#foo myRecord'. clearly separate things
16:24:00 <phaazon> the initial motivation of RecordWildcards is, to me, way too much bazooka
16:24:07 <phaazon> ski: that’s a good idea
16:24:10 <phaazon> I think Elm has the same
16:24:16 <phaazon> you use .foo
16:24:19 <phaazon> to use a record like a function
16:24:30 <phaazon> map .foo listOfThingsThatHaveFoo
16:24:41 <ski> i don't like `RecordWildcards' because it's implicitly using (/ bringing into scope) variables that's not explicitly mentioned
16:24:52 <phaazon> yep.
16:24:55 <phaazon> for returning values, it’s okay
16:24:56 <ski> iow, in terms of macrology terminology, it's not hygienic
16:24:58 <phaazon> I do the same in Rust
16:25:02 <ocharles> that's why i advocate named field puns
16:25:13 <phaazon> with Foo { x, y, z } instead of Foo { x: x, … }
16:25:27 <ocharles> though i think {..} is useful but should warn about unused names
16:25:33 <phaazon> ocharles: my hate for that is linked to how it’s used at work by colleagues :P
16:25:34 <ski> i don't like it for constructing either, though i do agree it's somewhat better with stylized use there
16:25:36 <ocharles> that's useful for writing encoders, for example
16:25:50 <ocharles> (so you don't forgot to encode fields of a record)
16:25:55 <phaazon> ski: yes, because it’s just syntactic sugar
16:26:03 <ski> i think one ought to be able to do `MkFoo { f x = ..x.. }', &c.
16:26:29 <ocharles> ski: except that would be ambiguous
16:26:31 <phaazon> ocharles: damn, on my fix to your meme
16:26:38 <phaazon> I forgot the extension ImplicitParameters
16:26:43 <ski> ocharles : why ?
16:26:48 <phaazon> which I dislike even more than RecordWildcards
16:28:00 <ocharles> ski: hmm, maybe I don't get that `f x =` syntax
16:28:15 <phaazon> view patterns, maybe?
16:28:17 <phaazon> with f x -> …
16:28:20 <phaazon> well, f -> …
16:28:22 <ski> ocharles : i mean instead of having to write `MkFoo { f = \x -> ..x.. }'
16:28:26 <ocharles> but `MkFoo` could be a perfectly valid monad value
16:28:49 <ski> ocharles : also, i want to be able to have multiple defining equations in there (with pattern-matching)
16:29:01 <ocharles> ok, but that's very different to a monadic syntax
16:29:09 <ski> and then, it would possibly be better to use `;' rather than `,' as separator
16:29:21 <ski> who mentioned monadic syntax ?
16:29:30 <ocharles> oh, I misread your do
16:29:31 <ocharles> sorry
16:29:55 <ocharles> "i think one ought to be able to do `MkFoo { f x = ..x.. }', &c." -- I read that as `do MkFoo`
16:30:00 <ocharles> hence the ambiguous comment
16:30:03 <ski> ah, sorry. no
16:30:20 <ocharles> i definitely agree we should be able to do function binds in record syntax, someone has already proposed it once
16:30:27 <ocharles> Though I forget who and where
16:30:30 <ocharles> anyway, bed now
16:30:38 <phaazon> good night ocharles 
16:31:25 <phaazon> ski: https://ocharles.org.uk/blog/posts/2014-12-04-record-wildcards.html
16:31:34 <phaazon> the example with ToJSON Worker
16:32:03 <phaazon> I always think “why the heck people use that extension for if they only gain the effort of typing a single variable or expression?!”
16:32:13 <phaazon> introducing implicitness to such a goal sounds so crazy to me :)
16:32:36 <phaazon> and even construction, pure Worker{..}
16:32:44 <phaazon> you don’t know which values go into to the Worker
16:32:48 <phaazon> you have to look at its definition
16:32:55 <phaazon> which is… daaaah, I hate that extension. :D
16:34:13 * ski nods
16:34:48 <phaazon> I should write a blog entry about that
16:34:54 <Rembane> Do it!
16:34:55 <phaazon> so that I can convince my colleagues
16:34:59 <phaazon> especially yoeight
16:35:09 <phaazon> he’s a fervent user of that damned extension :D
16:35:45 <aplainzetakind> What exactly, in Haskell, corresponds to categories? Or is there no such rigorous correspondence but just inspired terminology? I'm trying to understand in what sense Maybe is a functor. Is it that there's just the category of all types and functors are endofunctors?
16:36:27 <pacak> phaazon: Try to convince me - I'm using it quite a lot.
16:36:35 <Rembane> aplainzetakind: Haskell is a category, it's called Hask.
16:36:44 <phaazon> pacak: I just pointed out a few issues
16:36:53 <phaazon> when you yield a value with that
16:36:55 <phaazon> like 
16:36:58 <phaazon> pure Foo{..}
16:37:05 <phaazon> you don’t know which values to into the ctor
16:37:10 <phaazon> you MUST have a look at its definition
16:37:19 <aplainzetakind> Rembane: And the objects are?
16:37:25 <pacak> "a single variable or expression"  - {..} is shorter than typing all the things that go in.
16:37:30 <ski> phaazon : fwiw, i suppose it's not surprising that you don't like implicit parameters either, since that's dynamic scoping when dynamically running the program, while lack of hygiene is dynamic scoping when statically analyzing the program
16:37:31 <phaazon> while pure (Foo x y z) or pure $ Foo { fooX = x, fooY = y, … } 
16:37:34 <phaazon> there’s no ambiguity here
16:37:36 <pacak> aplainzetakind: all the regular values + bottom.
16:37:50 <pacak> phaazon: Ever worked with records that have 100+ fields?
16:37:54 <phaazon> ski: I don’t like implicitness because it hides things
16:38:00 <phaazon> pacak: yes!
16:38:03 <phaazon> I do that at work
16:38:05 <ski> aplainzetakind : basically yes
16:38:12 <phaazon> and I just name the value with a simple name
16:38:18 <phaazon> and use my very powerful editor’s features
16:38:20 <phaazon> like, copying
16:38:22 <phaazon> and macros.
16:38:30 <ski> aplainzetakind : instances of `Functor' are endofunctors over this category. other functors may not be
16:38:37 <phaazon> I prefer explicitness and a very few boilerplate over implicitness and ambiguity
16:38:45 <aplainzetakind> Alright. Thanks.
16:38:54 <phaazon> pacak: it’s shorter, yes
16:38:56 <phaazon> it’s a point
16:38:57 <ski> phaazon : ah .. but hides which kind of things ?
16:38:59 <phaazon> but it’s dangerous.
16:39:03 <Subeff> Hi guys again, sorry for jumping in conversation, if someone has few minutes, Can you spot the issue in this Foldable implementation of List. https://github.com/subev/haskell-fun/blob/b2b8d2ca88439aa2d2fa59a51fe0530312fcf54f/chapter-21/laws/app/Main.hs#L127 I know I can implement either foldr or foldMap and I tried to see if I can manage to do both, however I have no success with the foldr. The code compiles but the tests at the bot
16:39:06 <phaazon> ski: passing values around
16:39:09 <aplainzetakind> Are those theoretical considerations to be found in the Haskell Report?
16:39:10 <phaazon> for ImplicitParam
16:39:11 <ski> (surely you agree that hiding some things are good)
16:39:17 <pacak> phaazon: ghc will look at the definition and will tell you if something is missing or something is of the wrong type.
16:39:18 <phaazon> ski: that depends.
16:39:36 <ski> aplainzetakind : not really. i think e.g. some Wadler papers mention it a bit, though
16:39:54 <phaazon> pacak: when I do a code review, I don’t compile it right away
16:39:55 <phaazon> I read the code
16:40:01 <phaazon> RecordWildcards make it very hard to read the code
16:40:11 <pacak> phaazon: But CI will compile.
16:40:15 <phaazon> yeah
16:40:25 <phaazon> so you basically rely on two things here to actually read a very simple code
16:40:33 <phaazon> the compiler and the CI
16:40:35 <phaazon> that sounds crazy
16:40:39 <phaazon> just for the economy you do
16:40:51 <ski> Subeff : cut off near ".. The code compiles but the tests at the bot"
16:41:21 <Subeff> the tests at the bottom fail
16:41:23 <phaazon> pacak: also, worse:
16:41:28 <pacak> phaazon:  It also simplifies merges and rebases.
16:41:31 <phaazon> imagine you write the code with RecordWildcards
16:41:35 <phaazon> it compiles
16:41:39 <phaazon> so no warning, no error
16:41:43 <phaazon> a newcomer comes in
16:41:52 <phaazon> how does they do to know which values go into the ctor?
16:41:54 <phaazon> ;)
16:41:56 <ski> Subeff : you've implemented `foldl', not `foldr'
16:42:00 <phaazon> they can’t know
16:42:06 <phaazon> because it’s all implicit
16:42:26 <ski> (apart from argument order of `f')
16:42:26 <phaazon> so reading such a code requires indirection
16:42:28 <Subeff> ski: I had this feeling but I cannot swap the arguments of the function
16:42:40 <phaazon> reading the type definition
16:42:45 <phaazon> to understand how values are returned from a function
16:42:47 <pacak> phaazon: We have a somewhat high requirements in our hiring so newcomers will know how to look at definitions.
16:42:51 <Subeff> ski: so I wondered how to do it rly :D
16:42:52 <MarcelineVQ> I'm also not a fan of wildcards these days, but a new comer is going to have to read the record defintion anyway to see what's what
16:42:53 <geekosaur> arguably if warnings are on then it should throw the same 'didn't initialize some fields' it would for an explicit one if there aren't appropriate names in scope for all fields
16:43:05 <phaazon> the more I talk about that, the more I’m 100% that extension sucks
16:43:07 <phaazon> pacak: haha
16:43:08 <pacak> phaazon: Did you managed to avoid any bugs  by explicitly typing all the things?
16:43:09 <phaazon> that argument
16:43:16 <phaazon> pacak: it’s not about bugs
16:43:20 <phaazon> it’s about readability
16:43:23 <geekosaur> possibky an additional warning for a name coming from outside the innermost scope
16:43:34 <pacak> phaazon: It is about bugs and time.
16:43:42 <ski> Subeff : make it not tail-recursive
16:43:55 <phaazon> pacak: so you’re telling me that extension made you gain a very huge amount of time?
16:43:58 <phaazon> are you kidding me? :D
16:44:43 <phaazon> when I write code, I want it to be readable smoothly, with the less indirections as possible
16:44:44 <mbw> I have a question about bracket and the with* style of exposing resources, since I just had another run-in with "hPutStr: illegal operation (handle is closed)". In this paste  http://lpaste.net/358340  I have a wrong version (commented out), in which I accidentally return from "withDefaultHandles" inside "acquire", while I believe the second version better - maybe even correct :) Still, this stuff is scary. 
16:44:50 <mbw> Is there a rule of thumb on how to avoid this kind of error, maybe some stylistic habit which may help or something? I don't want to add new fancy abstractions like streaming IO or ResourceT or something at this moment...
16:44:51 <phaazon> no watter what skill the other mates have
16:44:54 <phaazon> it must be readable
16:45:03 <phaazon> so the “hiring” argument you just stated…
16:45:10 * ski supposes it may be slightly complicated to estimate the number of bugs not made ..
16:45:10 <pacak> phaazon: Biggest datatype we have is 250-something fields in a single record. Having to type out every one of them will take some time.
16:45:24 <phaazon> pacak: then change your editor
16:45:25 <phaazon> it sucks
16:45:43 <phaazon> comfort over readability is a no-go to me
16:46:06 <phaazon> I have a record of 180 fields at work, and I don’t use RecordWildcards
16:46:09 <phaazon> and I don’t suffer from it
16:46:09 <pacak> phaazon: There are only two editors out there and I don't like emacs.
16:46:27 <phaazon> well, people shouldn’t suffer from that to me
16:46:59 <phaazon> discarding people’s ability to read your code because you don’t “have the time to write identifiers” seems a very bad argument, sorry :)
16:47:14 <phaazon> however, I agree you gain some characters.
16:47:18 <phaazon> but the economy’s not worth it
16:47:21 <pacak> phaazon: What editor/tools do you use?
16:47:25 <phaazon> neovim
16:47:40 <phaazon> and stack build --fast --file-watch --pedantic
16:49:21 <pacak> So how exactly would you type out all the things?
16:50:26 <phaazon> pacak: that depends, if I already have a value, I use the record syntax; if the value comes from JSON, I don’t have to; if I have to write them all, well, I use the Foo { … } syntax when constructing it
16:50:31 <phaazon> if I need to destructure
16:50:38 <phaazon> I just call the ctors / record functions
16:50:46 <phaazon> like we’ve been used to doing for decades
16:51:26 <phaazon> I just hate when identifiers are secretly and sneakly injected in my scope
16:51:39 <pacak> "I use the Foo { … } syntax when constructing it" - oh noes!!! That's evil RecordWildCards extension you are using :)
16:51:43 <phaazon> “wait, that value is a String, but its definition is a Foo -> String… wtf?!”
16:51:52 <phaazon> pacak: no, it’s not.
16:52:02 <phaazon> pure $ Foo { x = 3, y = 1 }
16:52:06 <phaazon> that’s not RecordWildcards
16:52:11 <phaazon> that’s just Haskell records.
16:52:14 <pikajude> yeah
16:52:19 <pikajude> but Foo { .. } is recordwildcards
16:52:19 <pacak> I see.
16:52:22 <pikajude> so
16:52:24 <pikajude> it is
16:52:24 <phaazon> pikajude: yes
16:52:30 <phaazon> wat?
16:52:40 <pikajude> you just said you use Foo { .. } when constructing it
16:52:44 <pikajude> that's record wild cards
16:52:49 <phaazon> pikajude: …
16:52:51 <pacak> pikajude: He said it with 3 dots, not 2.
16:52:52 <pikajude> oh ok
16:52:59 <pikajude> how could i possibly have made that mistake
16:53:05 <phaazon> trying to troll? :)
16:53:14 <pikajude> clearly
16:53:16 <phaazon> <3
16:53:19 <ski> mbw : sometimes `ContT' (or perhaps `Codensity') can be useful doing `withX' things .. but i'm not sure it would help much here
16:53:23 * phaazon hugs pikajude 
16:53:25 <pikajude> oh ok
16:53:31 <pikajude> so you would manually type out 250 fields
16:53:45 <phaazon> yep
16:53:47 <pikajude> ok
16:53:52 <pikajude> so your editor sucks
16:53:56 <pikajude> i guess that's true if it's neovim
16:54:02 <ski> sometimes one can define one or a few default records
16:54:07 <phaazon> pikajude: “manually” is “via my editor”
16:54:10 <pikajude> yeah
16:54:12 <ski> (or functions constructing them)
16:54:13 <phaazon> I’d just use its macro system
16:54:15 <pikajude> i don't know how else you'd do it
16:54:16 <phaazon> and it took me something like…
16:54:19 <phaazon> 3 seconds?
16:54:19 <pikajude> oh ok
16:54:23 <phaazon> qa
16:54:24 <phaazon> do the thing
16:54:27 <phaazon> 250@a
16:54:28 <phaazon> done.
16:54:29 <pikajude> i'd be interesting to see how to write a vim macro that types in a bunch of different field names
16:54:31 <phaazon> well
16:54:34 <pikajude> it'd*
16:54:34 <phaazon> 249@a.
16:54:45 <pikajude> i can see that working if it's 250 of the same field name
16:54:46 <phaazon> pikajude: that’s ultra simple
16:54:55 <phaazon> that’s the reason macro from vim are awesome :)
16:55:01 <phaazon> pikajude: nonono
16:55:07 <phaazon> vim’s macros register EVERYTHING
16:55:14 <phaazon> so if you copy something while recording
16:55:23 <pikajude> oh, okay
16:55:26 <phaazon> it’ll copy what comes under the cursor at the invocation
16:55:33 <pikajude> so if the snippet you want already exists in the source file
16:55:33 <phaazon> so you just move the cursor around while recording
16:55:35 <pikajude> then it's simple
16:55:36 <phaazon> like a line below
16:55:37 <pikajude> i got it
16:55:43 <phaazon> good.
16:55:46 <pikajude> what if it doesn't
16:56:02 <phaazon> then I go in my typical mood:
16:56:09 <pacak> Somehow it feels to me that 250 lines worth of "this thing does nothing" is less readable than some simple syntax extension.
16:56:18 <phaazon> “I might have two types with that many records. I’ll just do it by hand. That’s okay.”
16:56:27 <pikajude> agreed
16:56:43 <phaazon> pacak: difference of opinions :)
16:56:45 <pikajude> rarely do i want to read through 250 lines of { foo = foo, bar = bar, baz = baz, ... }
16:56:58 <phaazon> pikajude: Rust has that part good
16:57:01 <phaazon> you just write the name
16:57:05 <phaazon> Foo { x, y, z }
16:57:08 <phaazon> Haskell has it wrong
16:57:12 <phaazon> it does it implicitely for you
16:57:18 <phaazon> Foo{..}
16:57:18 <pikajude> just use namedfieldpuns instead then
16:57:25 <pikajude> don't bother with wildcards
16:57:41 <Subeff> :ski I understand what you are saying but I do not how to do it without going in depth of recursion first
16:57:57 <phaazon> pikajude: NamedFieldPuns is totally okay to me
16:57:58 <Subeff> :ski can you give some tips
16:58:00 <pikajude> ok
16:58:08 <pikajude> not an editor command: ski
16:58:13 <phaazon> :D
16:58:24 * ski is not an editor command ?
16:58:33 <ski> i suppose you learn something new, every day ..
16:58:37 <pikajude> Subeff keeps trying to use it
16:59:18 <ski> Subeff : .. i suppose you don't know how `foldr' for the usual list type works ?
16:59:36 <phaazon> bed time, off
16:59:42 <phaazon> see you around peeps
16:59:48 <pacak> phaazon: Do you use any other tools - ghc-mod, ghcid, hdevtools, etc?
16:59:53 <phaazon> pacak: no
17:00:13 <phaazon> I don’t
17:00:22 <pacak> How can you simply go to  bed if someone on the internets is WRONG?
17:00:31 <phaazon> pacak: none is wrong
17:00:46 <phaazon> if you like that extension and think it enhances your codebase
17:00:50 <phaazon> that’s all good!
17:00:54 <phaazon> at work, people use it
17:01:01 <phaazon> I cringe each time I see it
17:01:03 <phaazon> I just wait
17:01:05 <phaazon> quietly
17:01:11 <phaazon> that a newcomer comes across the problem
17:01:20 <Subeff> as far as I remember the difference was, that foldl needed to evaluated the whole list first, as in my case, but do not remember how foldr was really implemented :))
17:01:21 <phaazon> THEN I’ll be in position to point the finger at my colleagues
17:01:29 <phaazon> and tell them “I’ve told you so!”
17:01:29 <phaazon> :)
17:01:47 <pacak> We never had newcomers coming  across  this problem so far.
17:01:54 <phaazon> in the meanwhile, I just bother them a bit with their code reviews, then accept it
17:02:03 <phaazon> pacak: what company do you work for?
17:02:20 <pacak> A small high frequency trading one.
17:02:23 <phaazon> pacak: exploring and discovering a new codebase is always a huge effort
17:02:40 <phaazon> maybe they made their way through
17:02:45 <phaazon> by looking at the type definitions
17:02:54 <phaazon> but it’s not “smooth reading” to me
17:02:57 <phaazon> :)
17:03:19 <phaazon> and yeah, two buffers of x = x, y = y is a huge boilerplate
17:03:24 <phaazon> but at least, we know what’s happening
17:03:34 <phaazon> or x, y, z with the Puns stuff
17:03:39 <phaazon> (I should use that more often, it’s great)
17:04:16 <phaazon> pacak: I actually have a question for you
17:04:23 <phaazon> how many types with that many fields do you have around?
17:04:47 <phaazon> (also, have you considered splitting your types, if possible?)
17:04:58 <phaazon> it could be a proof of a design concept (or not, if it’s really required)
17:05:29 <pacak> Not much big types, maybe 3-4 huge ones, the rest is more sensible.
17:05:41 <phaazon> yeah, that’s my point
17:06:50 <pacak> Splitting might work but in this case you'll have to pass more stuff to consumers - those huge datatypes have some meaning.
17:07:39 <phaazon> yeah, I see :)
17:09:02 <phaazon> well, now, off to bed!
17:09:04 <phaazon> see you :)
17:09:35 <pacak> Night.
17:19:59 <Subeff> nn guys :) I gave up 
17:22:24 <ski> hmm .. just wondering if someone has found a use for singleton kinds
17:33:15 <StrangeLoop> Is there a way to get the instance names of a data constructor in ghci? Like, if I imported "data Foo = Bar | Zom" is there a way to get "Bar|Zom" from "Foo"?
17:33:57 <ski> use `:info Foo'
17:34:06 <StrangeLoop> Cool
17:34:08 <ski> `:i' for short
17:34:28 <ski> (also, there is no `info' command in lambdabot)
17:35:08 <ski> @info id
17:35:08 <lambdabot> id
17:35:15 <glguy> % @info id
17:35:16 <yahb> glguy: ; <interactive>:31:1: error: parse error on input `@'
17:35:21 <glguy> % :info id
17:35:22 <yahb> glguy: id :: a -> a -- Defined in `GHC.Base'
17:35:22 <StrangeLoop> Gah, what does that mean? "data StdGen = System.Random.StdGen {-# UNPACK #-}GHC.Int.Int32"?
17:35:48 <glguy> StrangeLoop: At a highlevel it means "don't worry about it, this is an implementation detail"
17:36:13 <glguy> StrangeLoop: what part of that did you have a question about?
17:36:18 <StrangeLoop> I can live with that
17:36:31 <geekosaur> UNPACK is an optimization hint, basically
17:36:52 <StrangeLoop> No part in particular. It looks intentionally nonidiomatic and I wasn't sure how to google it.
17:36:56 <geekosaur> otherwise it's just a constructor wrapping a 32-bit signed value
17:37:22 <glguy> StrangeLoop: It's quite idiomatic
17:37:32 <geekosaur> {-# #-} marks pragmas. pragma syntax is covered by the language standard although specific pragmas are compiler specific
17:37:52 <geekosaur> (they intentionally look like block comments)
17:38:36 <StrangeLoop> So the optimization is the reason they used data rather than type?
17:38:52 <glguy> No, type is something else entirely
17:39:19 <niks> I've been out of touch with the haskell community for ~3 years now, but I was wondering how the data science/machine learning ecosystem in haskell looks like? Are there any efforts going on? 
17:39:36 <glguy> data introduces a new type constructor and zero to many data constructors for that type each of which can have fields
17:39:47 <glguy> type introduces an alias for an existing type
17:40:45 <glguy> In this case StdGen has one data constructor (also named StdGen) which has two Int32 fields that happen to be strict and as an optimization are "unpacked"
17:41:16 <StrangeLoop> Strict?
17:41:30 <ski> the `!'s
17:41:33 <glguy> data StdGen = StdGen !Int32 !Int32
17:42:38 <StrangeLoop> I... don't see any !'s
17:43:08 <geekosaur> where are you looking exactly?
17:43:47 <StrangeLoop> http://lpaste.net/9120900185961005056
17:44:26 <geekosaur> hm. that might actually be a bug in ghci
17:44:55 <StrangeLoop> lol
17:45:08 <geekosaur> althoygh it might also be making the assumption that since UNPACK pragma is only valid on strict fields, it can leave off the strictness annotation
17:45:26 <StrangeLoop> What does strictness mean?
17:45:28 <ski> perhaps related to "See also the -funbox-strict-fields flag, which essentially has the effect of adding {-# UNPACK #-} to every strict constructor field." <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma>
17:45:43 <ski> (source at <https://hackage.haskell.org/package/random-1.1/docs/src/System-Random.html#StdGen>)
17:45:54 <geekosaur> it forces evaluation to the first constructor when creating the value
17:46:24 <geekosaur> there's a formal definition in the language standard, but tossing seq into the mix might be asking a bit much at this point
17:46:30 <ski> a function is strict iff applying it to bottom is equal to bottom
17:47:02 <StrangeLoop> errmm... I am guessing you are talking about the bottom of some algebraic lattice but I am not sure which?
17:47:09 <ski> `not' is strict, since `not undefined' is not defined
17:47:13 <geekosaur> for something like Int32 it basically means evaluating the number immediately when creating the StdGen, instead of letting it be lazy and evaluated at first use
17:47:23 <ski> `const False' is not strict, however
17:47:42 <ski> and neither is `(&&) b', when `b = False'
17:48:03 <geekosaur> "bottom" is the least defined value
17:48:26 <ski> "bottom" is the "value" of a computation that doesn't terminate normally
17:48:30 <geekosaur> practically, it represents some form of nontermination (infinite loop, throwing an exception, ...)
17:49:12 <ski> @where lazy
17:49:13 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
17:49:24 <ski> by monochrom could be perhaps be useful
17:49:24 <JuanDaugherty> or in some interpretations I've seen a non-set. I call it "perp".
17:49:50 <ski> "a non-set" ?
17:50:12 <StrangeLoop> This is kinda awesome
17:50:27 <JuanDaugherty> yeah, I think in this https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
17:50:53 <StrangeLoop> That's a really cute application of the lattice structure of definitions
17:50:53 <ski> StrangeLoop : <https://en.wikipedia.org/wiki/Domain_theory>
17:50:58 <JuanDaugherty> i.e. a non computation, one that doesn't resolve
17:50:59 <geekosaur> basically, any time you allow for lazines,s you allow for the possibility that the deferred computation would never complete. in strict languages, this would always occur immediately; in Haskell, it will only happen when that value is required by something. which means you can use infinite computations as long as the later uses are finite.
17:51:28 <JuanDaugherty> non set/non termination
17:51:29 <StrangeLoop> Holy shit I love order theory
17:54:41 <ski> StrangeLoop : perhaps the book "Proofs and types" by Jean-Yves Girard (translated by LaFont and Paul Taylor, i think) could be interesting. or "Topology via Logic" by Steve Vickers
17:55:02 <ski> StrangeLoop : oh, and on topology, you might at some point want to check out
17:55:06 <ski> @where impossible
17:55:06 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
17:55:09 <ski> @where topology
17:55:09 <lambdabot> "topology in Haskell" <http://www.haskell.org/pipermail/haskell/2004-June/014134.html> and "Synthetic topology of data types and classical spaces" <http://www.cs.bham.ac.uk/~mhe/papers/entcs87.(pdf|
17:55:09 <lambdabot> dvi|ps)> by Martn Escard
17:55:16 <StrangeLoop> What do you mean by topology?
17:55:25 <StrangeLoop> I'm guessing no coffee cups and tori
17:56:24 <StrangeLoop> Oh my, they actually mean point set topology
17:56:32 <StrangeLoop> This is getting exciting
17:56:37 <ski> StrangeLoop : i mean how a space being hausdorff means that it comes equipped with an apartness relation. or being compact means that it comes equipped with a universal quantifier. in both cases, Sierpinski-valued
17:57:53 <ski> `data Sierpinski = Terminated'. the two points in `Sierpinski' is `Terminated' and `_|_' (bottom / non-termination). the former is open, the latter isn't
17:58:00 <StrangeLoop> This is amazing. You know why? Because my entire M.Sc thesis is about connecting topology with logic and I've never even heard of this stuff!
17:59:41 <StrangeLoop> But how much of this theory has actual substance in Haskell? 
17:59:52 <ski> also Abstract Stone Duality <http://paultaylor.eu/ASD/> (not that much on <https://golem.ph.utexas.edu/category/2009/01/abstract_stone_duality.html>, but often there's interesting posts on things here)
18:00:40 <StrangeLoop> ski: Are you a researcher?
18:01:06 <ski> "Formal Topology" <http://www.cse.chalmers.se/~coquand/formal.html>
18:01:18 <ski> i'm a student
18:05:49 <ski> Escardó has more (imho) interesting papers. e.g. about how the intrinsic topology of the (Martin-Löf) universe is indiscrete. and stuff about the generic convergent sequence (one-point compactification of the naturals), &c.
18:06:55 <ski> StrangeLoop : have fun ?
18:28:39 <trigone> hi! i'm trying to get how to use git locally and i've got a problem: i have two stack projects/packages A and B, B depending on A. they could both potentially be modified at once, but i'd like B to always have access to the latest most stable version of A, so i don't need to constantly move the HEAD of A just so i can compile B without the unstable modifications i'd be in the process of writing for A.
18:30:21 <trigone> the ideal would be to be able to give stack a git location of some stable branch of A for B to use... is that doable?
18:30:55 <sm> yup, check the manual
18:32:29 <trigone> which one? git's or stack's?
18:32:44 <sm> stack's
18:33:05 <sm> as git has never heard of stack :)
18:34:04 <trigone> i tried the search on stack's site, didn't find a thing related to 'git'...
18:34:21 <JuanDaugherty> also it's better practice to have head be stable and unstable dev in a branch, except for new projects
18:34:38 <JuanDaugherty> and even then
18:36:10 <trigone> JuanDaugherty: head is from what i understand, just the commit that reflects the current state of your working dir. i can't develop any unstable branch without moving the HEAD pointer to it, can i?
18:36:27 <JuanDaugherty> yeah realized after I said that meant master
18:36:30 <sm> trigone: I don't know how good the search is, but the stack docs are a bit hard to navigate
18:36:31 <JuanDaugherty> but still
18:36:38 <sm> https://docs.haskellstack.org/en/stable/yaml_configuration/#complex-package-locations-location
18:38:06 * sm tries.. search is crap, of course. It's a rule
18:39:10 <trigone> sm: agreed, and thanks for the link, that bit was what i was looking for for quite some time!
18:39:58 <sm> they need a reorg and/or different presentation
18:41:01 <sm> someone good with web docs could get a lot of karma there
18:41:13 <trigone> however it implies using git repos from the network, and i heard you could create a remote-but-local repository on the same sys than your local copy of the project. i'm not sure how those would be then used together with stack...
18:41:45 <sm> I don't really understand
18:42:00 * sm rereads
18:42:36 <sm> B needs to depend on a certain version of A, but you also want to develop A somewhat independently, is that it ?
18:44:50 <sm> I assume(d) you can specify a git revision for local git repos too, but if not then I guess you just keep two local copies of A
18:45:02 <trigone> sm: yeah kinda, without having to think about always moving back A to its stable version whenever i move on to modifying B, esp if i do both "at the same time" (i have a tendency to leave programs, like my editor, open for days on end)
18:47:20 <trigone> sm: hm yeah i cud do that too
18:48:07 <trigone> why does github call merges "pushing"? it's very confusing
18:49:36 <c_wraith> it doesn't?
18:49:47 * sm won't get into git(hub) confusions.. dinner is calling :). Good luck!
18:50:04 <trigone> c_wraith: doesn't what?
18:50:19 <c_wraith> pushes don't merge.
18:50:23 <trigone> sm: thanks for the help, bon appetit
18:50:28 <c_wraith> and git is what called them that
18:51:10 <trigone> c_wraith: yeah i mixed up with pulling
18:51:14 <c_wraith> a pull can merge, but that's because pull is fetch+merge without needing to do them independently
18:51:46 <trigone> oh... so a pull request is a fetch+merge request?
18:52:16 <trigone> what is fetched where then? it's not very clear to me...
18:52:58 <c_wraith> a fetch brings in all the refs from another repository that aren't in the current one.  (Unless you pass options to limit it...)
18:53:10 <c_wraith> and now we're super-offtopic.  git isn't haskell.
18:53:32 <trigone> c_wraith: right, sorry
18:53:41 <pacak> c_wraith: unfortunately stack is.
18:54:44 <pacak> And probably trying to fit git into haskell development workflow is not too offtopic either.
18:55:27 <c_wraith> but internals of how git works (what refs are, etc) is getting pretty far afield
18:56:26 <trigone> coming back to haskell alone, is there a way to tell ghc or maybe stack that i want to build a version for another architecture (basically, 32bits instead of 64bits)?
19:05:47 <trigone> or maybe there's a way to get a pseudo-interpreted version, some sort of neutral bytecode, and i'd just need the haskell equivalent of JRE for the desired platform. is that a thing?
19:07:59 <tabemann> why would you want this? you'd have to implement a VM for each platform anyways, and a VM would be no faster than native compiled code, and would probably be slower even with JIT
19:09:06 <tabemann> well, it might be easier to port a VM - but then it couldn't be a JIT VM
19:09:54 <tabemann> a neutral bytecode is only really useful as an abstraction for compilation purposes - first compile to bytecode, then generate native code from the bytecode
19:09:57 <trigone> hm maybe i misunderstood the meaning of LLVM then?
19:10:04 <tabemann> which is what LLVM does
19:10:24 <tabemann> LLVM isn't typically executed by something like a JRE
19:10:35 <trigone> tabemann: oh, so what's the practical usage of LLVM with hs?
19:10:44 <trigone> for optimization?
19:10:47 <tabemann> rather the compiler compiles to LLVM code, and then native code is generated from the LLVM code
19:11:19 <tabemann> LLVM bytecode isn't like Java bytecode in that it typically is not executed directly
19:11:26 <trigone> is there a way to get the LLVM bytecode and compile it with LLVM (i assume) on the targetted platform?
19:11:31 <c_wraith> llvm bytecode also really isn't portable
19:11:49 <trigone> so what's its purpose?
19:12:08 <c_wraith> to interface to the llvm backend for code generation
19:12:34 <tabemann> when doing compilation with LLVM typically the user never actually directly sees LLVM bytecode
19:12:42 <tabemann> unlike Java bytecode
19:12:52 <trigone> c_wraith: hm... so it's just a way to compile the same program in a different way
19:13:12 * Axman6 likes reading LLVM bytecode (well, the human readable syntax anyway)
19:13:56 <tabemann> it's a way to write compilers that are platform-agnostic
19:14:18 <tabemann> and to divorce the compiler from the details of code-generation
19:17:44 <trigone> tabemann: i understand. for my problem though it's a no-go... so, overall, is hs cross-compiling doable? and how to define the compatibility of a haskell program? does it only depend on the architecture, or also on the CPU, on the OS, etc? like if i compile a haskell program on my computer on a 32bit sys, can i be sure it works on all 32bits?
19:19:11 <tabemann> that I really don't know
19:19:22 <trigone> actually, i just remembered the target was 64bits too, but they use xeon as CPU whereas i'm on i5, will it cause trouble?
19:21:38 <tabemann> x86-64 should be compatible with any processor that takes x86-64, as GHC certainly won't use Intel or AMD-specific instructions
19:22:09 <trigone> hm ok then it's good to know :)
19:23:12 <trigone> thanks all, gotta sleep, bye!
19:36:58 <arahael> What's the easiest, most trivial way to benchmark an http server? (I want to have a fairly simple, stupid, benchmark of a page served by scotty, vs a page served by another webserver)
19:38:57 <mmaruseacph2> arahael: see http://hackage.haskell.org/package/wrecker
19:39:28 <arahael> Neat. :)  Thaks
19:39:30 <arahael> *Thanks
19:42:50 <arahael> Any articles about using Go vs Haskell for http services?
19:42:54 <EvanR> arahael: i have used the program siege for stress testing of sorts
19:43:52 <arahael> Nifty, I think I'll just stick with wreker, once it's installed.
19:44:01 <arahael> Still another ~60 deps to download.
19:44:36 <arahael> It's *remarkable* how stable the haskell ecosystem feels now, thanks to stack. :) 
19:45:19 <marvin3> is it worth switching to stack from cabal sandboxes? i have zero experience with it
19:45:47 <arahael> marvin3: I'm still very much a novice haskell user.
19:45:50 <arahael> (So couldn't say)
19:46:02 <arahael> But, stack does seem easier for me to get into.
19:48:36 <MarcelineVQ> stack is great, as long as you read the manual  https://docs.haskellstack.org/en/stable/GUIDE/
19:49:20 <MarcelineVQ> if you understand sandboxes you're already a bit ahead of most people learning stack though
19:50:10 <arahael> Before stack, I kept getting caught up accidentally selecting incompatible packages.
19:50:46 <arahael> Cabal sandboxes would have let me keep the setup project-specific, but I wasn't at that point anyway - once I've moved to stack, though, it just became far simpler.
19:51:03 <byorgey> marvin3: cabal sandboxes are still useful if you just want to set up an environment where you can install some packages and play around.  But if you are working on a library/project, you definitely want to use stack
19:51:40 <glguy> definitely's too strong, but it can help
19:51:41 <byorgey> stack gives you reproducible builds, forever, on any machine.  cabal sandbox definitely isn't designed to do that.
19:51:54 <glguy> Without stack you get just the same with a freeze file
19:52:11 <byorgey> ah, ok, I had never used those.
19:52:20 <glguy> With stack its easy to get lax with your build depends which will just lead to trouble later
19:52:34 <glguy> especially if you're making a library
19:52:59 <arahael> glguy: How so?
19:53:29 <MarcelineVQ> I'd reccomend  cabal new-build  but there isn't a cabal new-install just yet, as far as I know, and that's pretty important for an end user. If I'm wrong about that someone please let me know
19:54:26 <arahael> As a newbie, I especially like it that stack isn't also called "cabal".
19:54:58 <glguy> Users of your library won't be using your stack configuration, configurations are local deals for your particular workspace
19:55:07 <glguy> you don't get to assume that your users configuration looks like yours
19:56:13 <arahael> glguy: Newbie, here... That doesn't tell me anything. :(
19:56:46 * arahael eyes his wrecker install: It's stuck on Progress: 162/170
19:57:07 <glguy> arahael: If you don't know what something is, just be specific so that we can help
19:57:41 <arahael> glguy: In what way would you get lax with your build depends, as a stack user?
19:58:15 <glguy> With stack you typically pick whatever the latest "resolver" is, which is a fixed set of package versions upfront, and then add extra packages to that as needed
19:58:46 <arahael> Yes, ah, but that resolver isn't part of the .cabal file?
19:58:50 <glguy> But then because the resolver fixes those packages, people get lazy about actually specifying what versions of things they depend on in the file that describes package dependencies
19:59:05 <glguy> eventually you or anyone else wants to use a different resolver, but now has no idea which versions you intended to suport
19:59:16 <arahael> That I can understand - the .cabal file lets you specify versions and all that, but indeed, as a stack user, I often end up leaving htose versions off.
19:59:17 <glguy> No, resolver is part of the stack.yaml, which isn't part of the package
19:59:28 <glguy> it's your local sandbox configuration
19:59:37 <arahael> Right.
20:00:18 <glguy> so anything you put in that local sandbox configuration won't be available to other users of your package
20:00:29 <arahael> Makes sense.
20:01:00 <mmaruseacph2> yes, but the resolver ensures that all those things build togethere
20:01:20 <glguy> mmaruseacph2: which doesn't matter because your choice of resolver isn't stored in the package for upstream users of the package
20:01:23 <arahael> mmaruseacph2: I think he means that you don't know if your users will use that same resolver, and you can't specify it anyway.
20:01:24 <mmaruseacph2> submitting your package to stackage ensures that your package is built daily and you learn quick if there's some dependency problem
20:01:25 <glguy> each package will have its own stakc.yaml
20:01:40 <glguy> each project will pick its own resolvers
20:01:52 <mmaruseacph2> glguy: yep, but once your package is in stackage it will be tested against multiple resolvers
20:01:56 <glguy> the contraints in the .cabal will help determine which ones are compatible
20:02:46 <arahael> glguy: .... And a stack user will typically end up not providing constraints. :)
20:03:06 <arahael> glguy: Why bother, as the resolver magically picks the "right" stuff.
20:03:23 <glguy> yeah, sometimes it "just works" so you don't realize what you're leaving behind
20:03:37 <mmaruseacph2> each resolver has a set of bounds internal to it anyway
20:05:39 <arahael> Woo! Just got wrecker installed, I like it (and being able to test the web api is very appealing!)  Current stats:
20:05:41 <arahael> | Successful Runs || 0.0008 | 0.0010 | 0.0316 | 0.0001 | 112934 |   0 |   0 |        0 |     0.0000 |
20:06:10 <arahael> Localhost, obviously...
20:06:35 <mmaruseacph2> neat
20:09:48 <arahael> Curiously, at --concurrenc 10000; it really goes to shit.
20:09:53 * arahael obviously has no idea.
20:12:10 <arahael> Doesn't seem to like much more than 200.  I suspect something about open file limits.
21:37:28 <steven_is_false> When writing a type family like: type family ShapeEmpty (a :: Shape) :: Constraint where { ShapeEmpty (ShapeCons n Nil) = () ; ShapeEmpty (ShapeCons n (Cons ii val t)) = Void } I want an unsatisfiable constraint Void. How do I define such a constraint?
21:38:12 <jle`> it depends on how you want to enforce unsatisfiability
21:38:25 <aarvar> Int ~ String
21:38:37 <jle`> one simple way is just to make something like `class NoInstance` and not have any instances
21:38:42 <steven_is_false> aarvar: I've been using () ~ Bool but I thought there must be a better way.
21:38:54 <geekosaur> there's also TypeError in recent ghc versions that lets you associate a useful error, isn't there?
21:39:11 <jle`> oh yeah TypeError is probably the actual thing you want in this case, from a high-level api perspective
21:39:37 <Axman6> TypeError++
21:40:06 <Axman6> (I used to do things like ("Error" ~ "You can't do that, please don't")
21:40:09 <Axman6> )
21:40:40 <aarvar> that's different than a void constraint though isn't it
21:41:18 <geekosaur> TypeError is an unsatisfiable constraint with a programmer-specified error message
21:41:32 <geekosaur> assuming void constraint means type level absurd
21:42:00 <Axman6> I think it still fails in the same way as you want, but gives you the possibility of understanding the error
21:42:13 <steven_is_false> What exports it?
21:42:17 <steven_is_false> It's not in GHC.Exts
21:42:40 <Axman6> the TypeError stuff?
21:43:22 <Axman6> https://hackage.haskell.org/package/base-4.10.0.0/docs/GHC-TypeLits.html#g:4
21:44:02 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#custom-compile-time-errors
21:44:25 <steven_is_false> Axman6: Thanks
21:44:46 <Axman6> it's a very new feature though, so backward compatibility is pretty much out of the question, if that matters to you
21:47:00 <steven_is_false> Axman6: I'm doing an experiment anyway with type level maps and creating a HeapState monad foo :: Void => ()
21:47:00 <steven_is_false> foo = undefined
21:47:00 <steven_is_false>  
21:47:07 <steven_is_false> Sorry, see https://www.reddit.com/r/haskell/comments/6z4a60/is_there_a_type_level_map_package_available/
21:47:55 <steven_is_false> The following works: https://pastebin.com/kd9VbRsk
21:49:48 <steven_is_false> I'm not concerned with backward compatibility
22:08:23 <cocreature> it was introduced in 8.0 so you can at least support the last two GHC releases
22:11:01 <systemfault> Oh wow, TIL
22:22:25 <dsal> @pl (\(n,c) -> n * (value c))
22:22:25 <lambdabot> uncurry ((. value) . (*))
22:22:36 <dsal> eh, not pretty.
22:23:05 <Axman6> @pl (\(n,c) -> (value c) * n)
22:23:05 <lambdabot> uncurry ((. value) . (*))
22:23:27 <opqdonut> it knows multiplication commutes
22:23:29 <opqdonut> cool
22:23:45 <dsal> neat
22:24:03 <dsal> I'm wondering if I can get rid of 'value' with some kind of Num instance.
22:24:09 <ahihi> @pl \(c,n) -> n * value c
22:24:10 <lambdabot> uncurry ((*) . value)
22:24:16 <opqdonut> that's also: uncurry (*) . first value
22:24:29 <opqdonut> :t uncurry (*) . first ?value
22:24:30 <lambdabot> (?value::b -> c, Num c) => (b, c) -> c
22:33:14 <nshepperd> recent ghc seems unable to compile with -prof when type checker plugins are used. there's a rather perplexing error: http://lpaste.net/358341
22:35:08 <dsal> @pl (\x -> (d,c) : x)
22:35:08 <lambdabot> ((d, c) :)
22:35:15 <dsal> I like that one.  It smiles.
22:35:43 <cocreature> nshepperd: does one of the suggested solutions help?
22:36:00 <dsal> I don't think I'll use it, though.  The smile would be super distracting.
22:37:16 <geekosaur> cocreature, I think it's confused, bytecompiled the plugin as -prof because that's it's running mode, and then trying to use it in the non-prof compiler?
22:37:37 <nshepperd> -fexternal-interpreter gives me errors about missing files. under stack it gives me an error saying 'this operation requires -fno-external-interpreter' O_O
22:37:49 <cocreature> huh that seems broken
22:38:27 <dmwit> ?pl \n c -> n * value c
22:38:27 <lambdabot> (. value) . (*)
22:38:45 <dmwit> Oh. I see.
22:39:05 <dmwit> dsal: What is `value`?
22:39:14 <jared-w> dsal: is  ( (d,c) : )  still distracting?
22:39:29 <Axman6> ( ( d , c ) : )
22:39:47 <Axman6> gotta make life easier for the lexer
22:40:18 <dsal> dmwit: It's a function that returns the numeric value of a particular type value.  This is the "make change" problem.   2P = 2, etc..
22:42:24 <nshepperd> uh, not sure how to get cabal to install the libraries to compile with -dynamic but i don't see how it would help if the issue is ghc wrongly building the plugin as -prof
22:44:13 <cocreature> nshepperd: sounds like https://ghc.haskell.org/trac/ghc/ticket/11293 might be the issue for this bug. (haven’t read the discussions to see if there’s a workaround)
22:47:29 <arahael> How do I avoid this issue: Network.Socket.accept: resource exhausted (Too many open files)
22:47:59 <opqdonut> remember to close your sockets
22:48:01 <andromeda-galaxy> arahael: are you leaking sockets somehow? forgetting to close them?
22:48:02 <arahael> (Context: Mac os x, running scotty - the default example, basically scotty's "hello world" site, and using wrecker with a high number of concurrent access)
22:48:40 <andromeda-galaxy> otherwise ulimit? not familiar with os x
22:48:45 <jared-w> "and using wrecker with a high number of concurrent access"
22:48:46 <arahael> andromeda-galaxy: I just run scotty (with the example shown at https://github.com/scotty-web/scotty) and then test it with wrecker --concurrency 4000
22:48:51 <jared-w> This seems like the cuplret :)
22:48:59 <pacak> You successfully wrecked your app.  Congrats.
22:49:03 <arahael> Yes, but surely, 4000 should be OK?
22:49:09 <pacak> Nope.
22:49:23 <arahael> Why not?
22:49:23 <steven_is_false> arahael: Isn't the limit exactly 4096?
22:49:27 <andromeda-galaxy> arahael: https://serverfault.com/questions/15564/where-are-the-default-ulimits-specified-on-os-x-10-5 says os x only lets you have 256 sockets by default
22:49:27 <nshepperd> cocreature: hm, i see, doesn't look like there is really a workaround
22:49:38 <arahael> andromeda-galaxy: Oh!  Curious.
22:49:40 <andromeda-galaxy> (sockets are a kind of file, so they're accounted under maxfiles)
22:49:58 <jared-w> Yeah OSX has a lot of weird limits like that... 
22:50:04 <arahael> Right, I've actually increased my limits.
22:50:17 <nshepperd> looks related to ghc's cross compilation issues with conflating host and target object files
22:50:36 <arahael> ulimit says "unlimited", and sysctl kern.maxfiles and kern.maxfilesperprocess have all been bumpbed to at least 10000.
22:53:06 <andromeda-galaxy> arahael: oh weird. sorry then, no idea - I don't personally use scotty or os x
22:53:42 <arahael> andromeda-galaxy: I'm suspecting it's os x that's the issue here.
22:56:42 <nshepperd> measure the exact number of connections or files that causes the error, then google that number and some keywords relating to system limits :)
22:57:01 <kahlil29> I'm trying to sort a column of my db Table using opaleye. The column is of type text. I think I need to add an instance of PGOrd for my column. Column name is 'status' Error :  Could not deduce (PGOrd Status) arising from a use of ‘asc’
22:57:13 <kahlil29> where/how do I add that? 
22:57:17 <nshepperd> or a round number near that number, since i guess there'll be a couple of unrelated open files
23:01:29 <HaskellISFUN> Hi, I have a question on http://lpaste.net/358342
23:01:59 <HaskellISFUN> I can not find any nest pattern on "SealingWax"
23:02:30 <ski> `SealingWax' is a pattern. `Person n _ SealingWax' is a pattern. the former is nested inside the latter
23:02:48 <ski> (`n' and `_' are also nested patterns here .. but perhaps less interesting)
23:04:06 <HaskellISFUN> checkFav brent vs checkFav stan, they seemd no difference
23:04:07 <geekosaur> I think the Report also considers the outer checkFav ... a pattern 
23:04:16 <arahael> nshepperd: It's between 205 and 210 connections.
23:04:17 <HaskellISFUN> what's the pattern matching rule?
23:04:21 <arahael> nshepperd: Not completely consistent.
23:04:35 <geekosaur> they aren't because starying with lowercase it's just binding the parameter without examining it
23:05:00 <geekosaur> oh, those are invocations not patterns
23:05:08 <nshepperd> then I would guess something has a limit set at 256
23:05:26 <geekosaur> youd have to show how brent and stan were defined, presumably as values of Person
23:05:47 <jared-w> nshepperd: Which is particularly odd considering OSX has a default limit around 256 but arahael has upped their limit...
23:05:50 <arahael> nshepperd: Ie, the default, despite my new limits. :/
23:05:57 <arahael> jared-w: Maybe it ignored it.
23:05:58 <ski> geekosaur : it's a `<funlhs>'
23:06:07 <arahael> jared-w: Or maybe there's /another/ limit.
23:06:37 <arahael> I'm giving up, this is something for an admin to worry about, not me.  Me, I'll continue to recommend Linux for real servers. :)
23:06:41 <ski> HaskellISFUN : not sure what you're asking. neither `brent' nor `stan' is defined in that paste
23:07:12 <geekosaur> arahael, how/where are you starting that service? depending on how you bumped the ulimit, it may only apply to interactive logins
23:07:23 <saurabhn_> does stack<>docker integration allow you to build in a docker container, but deploy to bare-metal OR does it require you to deploy within the docker container?
23:07:29 <arahael> geekosaur: Just on my command line. I'm only playing around.
23:08:31 <ski> HaskellISFUN : it's not clear whether you're asking for rule(s) for how pattern matching works. or about particular defining equations for a function (`checkFav' in this case). or perhaps something else
23:09:57 <jared-w> saurabhn_: I believe stack<>docker integration starts up the container for you and puts everything in the container so you can deploy the container to your server easily, but I could be wrong. It would make sense since a lot of the appeal of docker is "once it's working in the container, it's working on production" and deploying to bare metal would get rid of that benefit
23:10:31 <andromeda-galaxy> saurabhn_: if you are interested in deploying to bare metal but having isolated/reproducible builds, I would suggest looking into nix
23:10:43 <saurabhn_> jared-w: I'm trying to build locally in an environment that is same as production. However, I don't want yet another virualisation layer on my prod servers to deploy the binaries.
23:11:33 <cocreature> saurabhn_: stack has two kind of docker integrations that are orthogonal two each other. 1. it can build in a docker container and 2. it can create docker images that contain the resulting executables
23:11:37 <arahael> saurabhn_: As I understand it, docker isn't virtualisation.
23:11:48 <cocreature> if you don’t want to deploy in docker, you can just use the first one
23:12:08 <arahael> saurabhn_: There is a reason that docker only runs linux. (Well, generally speaking)
23:12:26 <saurabhn_> so building in docker (and deploying the binary without the docker container) VS using stack<>nix -- what is recommended and has a smoother workflow?
23:12:33 * JuanDaugherty wishes somebody would say if #moby is about the docker project (lookin at you dmj`)
23:13:02 <saurabhn_> which will allow compilation on mac osx and deploying on linux?
23:13:21 <arahael> saurabhn_: You can't run linux apps on mac os x.
23:13:35 <JuanDaugherty> not without recompilation
23:13:38 <arahael> saurabhn_: You'd need virtualisation for that, and docker has been wraped up with virtualisation on mac os x.
23:13:52 <arahael> So yeah - the other option is recompilation.
23:14:00 <arahael> On a mac.
23:14:15 <andromeda-galaxy> saurabhn_: you could also use a ghc cross compiler on mac os x if you want to avoid building on a linux box for osme reason, but that's a bit difficul to get set up right now
23:14:28 <Axman6> saurabhn_: we have used the stack --docker stuff to build linux executables on macOS
23:14:31 <saurabhn_> so, docker is my only option here, not nix?
23:14:34 <arahael> Frankly, I'd just setup a linux vm on the mac and be done with it.
23:14:45 <JuanDaugherty> hamishmack, no probs with leksah 
23:15:34 <jared-w> I'd say that stack<>nix is probably the superior workflow in your case. However, then you have to learn Nix :p
23:16:02 <jared-w> Honestly if prod and your computer are identical environments anyway, what's wrong with just making a stack build on your computer and copying the executable over manually?
23:16:45 <saurabhn_> jared-w: they aren't identical. Some devs have mac, some devs have different linux distros
23:16:53 <saurabhn_> jared-w: does nix allow me to compile a binary on mac and deploy to linux?
23:16:58 <JuanDaugherty> some have both
23:17:16 <JuanDaugherty> no nix doesn't do that
23:17:41 <JuanDaugherty> it just gives you isolation, it's redundant with stuff like docker and stack
23:17:44 <Axman6> saurabhn_: when I need to deploy to linux, I spend most of my time using stack build on macOS, and then stack --docker build and grabbing the executable (and any needed other files - finding this is trial and error mostly) and shipping that to our AWS instances
23:17:59 <andromeda-galaxy> saurabhn_: not many things /can/ allow that. In theory you could use a cross compiling ghc with nix, but I don't think anyone has set that up
23:18:16 <JuanDaugherty> though just nix (as opposed to nixos) could be used orthogonally
23:18:34 <Axman6> the results of a stack --docker build just end up in a parallel location in your .stack-work as the mac build does
23:18:38 <saurabhn_> so, that would mean it is either docker (which gives you a lightweight linux VM) OR setting up a separate linux-only build server, right?
23:18:54 <arahael> Docker isn't a VM, though. Does it even use it's own kernel?
23:19:14 <saurabhn_> Axman6: re-confirming -- docker on mac will give me a linux executable that can be deployment independent of docker. Is that correc?
23:19:15 <JuanDaugherty> moby does
23:19:17 <Axman6> it does when you use it on macOS, it's fun inside virtualbox
23:19:25 <rotaerk> one of the biggest benefits I've found with nix is the reliability of builds
23:19:31 <rotaerk> though simplicity isn't one of its perks
23:19:38 <Axman6> saurabhn_: yes* (* = probably, it's worked for us)
23:20:04 <saurabhn_> what would be a good place to get a definitive answer to this question, before we spend too much time on getting this infra setup?
23:20:13 <JuanDaugherty> last I knew it (nix) has probs with foreign ecosys(es) and other quality problems in packaging
23:20:49 <JuanDaugherty> semantic clashes with it's core concept and sloppy ports
23:20:49 <Axman6> saurabhn_: there's very little time needed, install docker, and then run stack --docker build (there might be a stack docker setup or something you need to run once, it's been a while since I needed it)
23:20:55 <JuanDaugherty> *its
23:21:07 <Axman6> saurabhn_: you're looking at hours of time for the "infrastructure", not days
23:21:21 <saurabhn_> Axman6: okay, let me try.
23:21:46 <saurabhn_> Axman6: after that it's just shipping the binary + other assets and SIGing the frontend server, right?
23:21:55 <Axman6> the stack docs for how to get started with the docker builds would be the best place to start
23:22:53 <Axman6> saurabhn_: pretty much - you will likely need to ensure that the OS has any C libraries installed you need (for us, we make sure we have libpq installed for PostgreSQL)
23:23:55 <dmj`> JuanDaugherty: re: #moby channel, unrelated to docker apparently ¯\_(ツ)_/¯
23:24:31 <JuanDaugherty> oh ty!
23:24:35 <saurabhn_> Axman6: hmmm... how do you ensure that? manually?
23:25:21 <Axman6> see what breaks
23:25:40 <Axman6> there are also tools which tell you which libraries it's liked against (otool? I can't remember what it is)
23:26:23 <JuanDaugherty> ldd
23:27:50 <Axman6> thanks
23:28:21 <arahael> otool, on the mac, I think.  Don't think ldd exists.
23:29:07 <Axman6> yeah
23:30:18 <arahael> otool -L, specifically.
23:30:31 <Axman6> ldd is what's needed here though
23:30:42 <Axman6> since we're talking about linux executables on linux
23:30:46 <arahael> Ah, yeah.
23:37:03 <saurabhn_> Axman6:  thanks
23:37:14 <saurabhn_> Axman6:  do you know what this is about -- https://docs.haskellstack.org/en/stable/docker_integration/#docker
23:37:20 <saurabhn_> that doesn't seem to be working on my mac.
23:37:46 <Axman6> what isn't working? do you have error messages? what have you tried?
23:38:08 <saurabhn_> sudo: gpasswd: command not found 
23:38:20 <saurabhn_> sudo passwd -a ${USER} docker
23:38:20 <saurabhn_> passwd: illegal option -- a
23:38:23 <Axman6> yeah you don't need that section, just run the docker app
23:38:31 <Axman6> (IIRC)
23:39:46 <Axman6> also, I wouldn't follow the advice to add the docker: enable: true bit, just use --docker when you want to compile with docker
23:41:09 <saurabhn_> Axman6: have you managed to use this successfully with hpack?
23:41:37 <Axman6> no, I don't really know what hpack is (I tried to use it once and it failed)
23:44:39 <saurabhn_> Axman6: more newbie stuff -- "Please login prior to pull" -- what's the login command? and what exactly is it asking me to login to?
23:45:48 <JuanDaugherty> github or other git repo?
23:45:58 <Axman6> I don't know what you're doing - please give context when asking questions
23:56:24 <saurabhn_> Axman6: I'm running "stack docker pull" and it throws up an error -- "Please login prior to pull. Error: Cannot perform an interactive login from a non TTY device"
23:59:02 <parsnip> saurabhn_: maybe `docker login`?
23:59:49 <saurabhn_> parsnip: hmm... what is my username/password now!
