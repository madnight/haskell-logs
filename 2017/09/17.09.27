00:05:14 <ertes-w> helo
00:05:28 <fresheyeball> ertes-w: hiya
00:05:35 <ertes-w> what happened with the apparent bytestring/IORef bug yesterday?
00:06:47 <ertes-w> (or a couple of hours ago, depending on your time zone)
00:12:00 <Axman6> > [toUpper, toLower] <*> "Hello"
00:12:03 <lambdabot>  "HELLOhello"
00:14:15 <Axman6> :t replicateM
00:14:16 <lambdabot> Applicative m => Int -> m a -> m [a]
00:17:22 <royal_screwup21> what does it mean when the type definition of a function is a -> b? Does it that mean "a" and b" are different data types? Otherwise, if they were the same type, I'd imagine the definition to be a -> a
00:18:30 <Axman6> the type a -> b says that a and be _may_ be different (but they can also be the same)
00:19:12 <cocreature> in particular the _user_ of this definition can choose what a and b are
00:19:25 <cocreature> so the implementor can’t make any assumptions
00:19:48 <Axman6> it's worth noting that the type a -> b is impossible to implement (without bottom, ie, looking forever or throwing an exception)
00:19:56 <royal_screwup21> suppose I have a function addone x = x+1. Is it okay to think that the type definition for this function is a -> b?
00:20:20 <Axman6> no, because of the type of (+), the result type here much be the same as the input type
00:20:27 <ventonegro> royal_screwup21: No, due to the type of (+)
00:20:36 <royal_screwup21> ah so it has to be a -> a?
00:20:37 <Axman6> :t (+)
00:20:37 <ventonegro> :t (+)
00:20:38 <lambdabot> Num a => a -> a -> a
00:20:39 <lambdabot> Num a => a -> a -> a
00:20:45 <Axman6> @quote stereo
00:20:45 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
00:20:58 <Axman6> so meta
00:21:10 <cocreature> royal_screwup21: just try it out, type ":t \x -> x + 1" in ghci
00:22:07 <royal_screwup21> yup, so it is  a -> a, thanks folks! :)
00:22:47 <cocreature> royal_screwup21: no it’s not the "Num a =>" part is important
00:23:29 <ventonegro> royal_screwup21: Types which were declared in a more general way usually will get more specific as type-checking is done by the compiler
00:23:38 <Axman6> yeah, the type a -> a only has one implementation, which is id. but the type Num a => a -> a has many (in fact, infinite implementations)
00:24:52 <royal_screwup21> Okay, so the "Num a" basically tells you the type of the thing being returned
00:25:15 <Axman6> it constrains a to only the types which have implemented the Num type class
00:25:21 <cocreature> royal_screwup21: "Num a" restricts the choices that a user can make for "a"
00:25:38 <Axman6> so, Integer, Double, Float, Int, Rational, plus many more
00:25:43 <fakenullie> that thing with typeclasses is in the haskell book
00:26:22 <royal_screwup21> off to do a bit of goolging around this...
00:34:19 <aphorisme> Is there a way to see which haskell libraries use which dynamic linked lib? I've a problem with `libtinfo` which seems to be missing on some Suse Linux 11, but I cannot tell which Haskell package needs it.
00:46:34 <ertes-w> aphorisme: you can use 'ldd' on shared objects
00:46:57 <aphorisme> yeh, I crawl through them atm.  : )
00:48:34 <aphorisme> oh .. battery -.-'
00:55:46 <mbrock> if anyone saw me wonder if the Brick library was failing to redraw correctly, don't worry, it was totally my fault
00:55:57 <Axman6> hooray!
00:59:37 <mbrock> having a trustworthy and declarative TTY UI library is so amazing
01:00:18 * mbrock randomly encourages everyone to make more Haskell TTY apps with Brick :)
01:00:59 <[exa]_> screenshots!
01:03:54 <Axman6> brick's pretty amazing
01:04:17 <Axman6> I wish some of the stuff in it was split out though, it'd be nice to have things like the box draeing moved to vty
01:04:54 <mbrock> the app I'm working on has a little ASCII movie at https://github.com/dapphub/hevm -- not very impressive yet, just a few panes with scrolling text
01:07:39 <mbrock> Axman6: sounds reasonable. I also dream of a really capable suite of widgets, or maybe even something like an "app framework" built on top of Brick
01:08:18 <ertes-w> i wish brick wouldn't deprecate vty-ui
01:50:05 * hackagebot texbuilder 0.1.1.1 – View your latex output while editing – https://hackage.haskell.org/package/texbuilder
01:58:42 <savask> Hello. I've made a lexer with alex which reads from a ByteString. I was really surprised to see that it runs slower than the String one :C Profiling shows that alexScanTokens.go.len takes a significant amount of time
01:58:52 <savask> My question is, what is the cause behind that?
01:59:14 <savask> Shouldn't a ByteString lexer be faster
01:59:46 <fakenullie> maybe bytstring is a real C array, so you cannot make it immutable without copying
02:02:41 <fakenullie> cons is O(n)
02:04:06 <aphorisme> Anyone any advice compiling stuff with stack/cabal/ghc on Suse? I don't even get the packages to do so.
02:04:58 <fakenullie> does it have docker?
02:07:13 <savask> fakenullie: I'm not using ByteString outside the lexer
02:07:44 <savask> And as I said before, profiling shows that computing length takes most of the time
02:07:56 <savask> I thought alex was supposed to generate efficient lexers, lol
02:09:16 <aphorisme> fakenullie: not as far as I can see.
02:22:26 <fakenullie> aphorisme: can you run this script https://get.haskellstack.org/?
02:23:00 <aphorisme> it goes through, but afterwards, running `stack --version` leads to a missing libgmp.
02:23:21 <fakenullie> libgmp should be in packages
02:24:21 * hackagebot progress-reporting 1.1.0 – Functionality for reporting function progress. – https://hackage.haskell.org/package/progress-reporting
02:56:55 <dfsafd> Hello all haskellers
02:57:44 <Ulrar> So, trying to get ganeti to compile on ghc 8, any idea what can be wrong with this ? "sigt <- [t| (Monad m) => $(conT traw) -> m $(conT tname) |]"
02:58:00 <Ulrar> Apparently "Not in scope: type variable ‘m’"
03:01:32 <dfsafd> can someone tell me how to get cabal to locally install deps given in the .cabal file?
03:04:35 <Boomerang> dfsafd: have a look at `cabal sandbox` to install the dependencies locally instead of system wide.
03:05:41 <dfsafd> Boomerang: i am already using a sandbox
03:05:48 <kakashiAL> if I have this expression:
03:05:50 <kakashiAL> square x = x * x
03:05:52 <kakashiAL> pow3 x = square x * x   <--I could use braces to make it more redable
03:05:54 <kakashiAL> my question is why does haskell does not calculate (x * x) first and then use square?
03:07:02 <brynedwards> dfsafd: You mean the command? cabal install --only-dependencies
03:07:04 <Boomerang> dfsafd: When I only use cabal (no stack or nix), I usually do: cabal sandbox init; cabal configure; cabal install --only-dependencies -j8
03:07:43 <dfsafd> thankyou
03:08:01 <lyxia> kakashiAL: uh, does it not actually do that for primitive types?
03:08:29 <dfsafd> for future reference, what is the url to the cabal documentation covering this topic?
03:09:52 <Boomerang> `man cabal` or for this particular question: cabal install --help
03:10:13 <barrucadu> kakashiAL: Function application has higher precedence than operator application
03:10:32 <kakashiAL> barrucadu: thanks you, so its always function first :)
03:11:51 <dfsafd> Boomerang: i dont have any haskell man pages installed
03:12:43 <fommil> is there a way to get the original request URI from scotty?
03:17:14 <fommil> the Request object doesn't seem to have it
03:17:42 <fommil> I guess I could reconstruct it
03:18:31 <fommil> but I don't know where the scheme / host / port is made available
03:20:42 <fommil> ah, found them
03:27:22 <John882> Hello, does someone recommend any good haskell books?
03:27:49 <brynedwards> John882: haskellbook.com
03:27:58 <dfsafd> does documentation for http://hackage.haskell.org/package/regex-pcre exist somewhere?
03:29:08 <kafka> sup people?
03:29:38 <Boomerang> dfsafd: If you click on the module names on the link you gave us you'll be redirected to the docs for that module
03:31:48 <dfsafd> Boomerang: do you mean this html page: https://hackage.haskell.org/package/regex-pcre-0.94.4/docs/Text-Regex-PCRE.html ?
03:32:08 <newbieonhaskell> hello gus
03:32:11 <newbieonhaskell> guys*
03:32:25 <newbieonhaskell> ı just wanna ask something to all of u 
03:32:42 <newbieonhaskell> ı just come from http://learnyouahaskell.com/introduction#about-this-tutorial
03:32:59 <saurabhnanda> is there a way to write the isJust function using the _Just lens/prism? I need to use the same technique for another sum-type.
03:33:15 <lyxia> is _Just
03:33:58 <saurabhnanda> lens library should be in some hall-of-fame!
03:34:22 <saurabhnanda> thanks @lyxia
03:34:42 <Boomerang> dfsafd: Yes, along with all the other modules
03:37:44 <dfsafd> Boomerang: I can't find a single usage example. Is that really the complete package documentation?
03:42:14 <merijn> dfsafd: Regular expressions aren't very commonly used in haskell, tbh. So most regex packages are rather barebones
03:43:56 <brynedwards> dfsafd: http://gabebw.com/blog/2015/10/11/regular-expressions-in-haskell
03:45:04 <dfsafd> thank you
03:45:32 <saurabhnanda> is there a version of Data.List.intersectBy which works with lists of different types?
03:46:46 <saurabhnanda> tried hoogle but couldn't find anything -- https://www.haskell.org/hoogle/?hoogle=%28a+->+b+->+Bool%29+->+%5Ba%5D+->+%5Bb%5D+->+%5Ba%5D
03:48:06 <brynedwards> saurabhnanda: There's a newer version of hoogle which lists the ListLike package http://hoogle.haskell.org/?hoogle=intersectBy
03:48:10 <barrucadu> @type \f as bs -> map fromLeft (intersectBy f (map Left as) (map Right bs)) -- not really the same, though
03:48:12 <lambdabot> (Either a b1 -> Either a b1 -> Bool) -> [a] -> [b1] -> [Either (Either a b1) b2 -> Either a b1]
03:48:19 <barrucadu> Oh, that's not what I wanted
03:48:51 <saurabhnanda> brynedwards: thank!
03:49:03 <saurabhnanda> how do you guys know all this stuff? Where is this new version of hoogle listed?
03:49:29 <John882> brynedwards: Thanks
03:50:28 <brynedwards> saurabhnanda: I'm actually not sure how I found it...I just realised it was different to haskell.org/hoogle because it says "Alpha version" at the top
03:51:46 <merijn> What are good type variables for kind "* -> *"? 'f', 'm', 'n', any others?
03:53:57 <cocreature> merijn: g
03:54:23 <dibblego> many years ago, in scala, I used *->* as a type variable name, for that
04:02:47 <saurabhnanda> brynedwards: does ListLike take **very long** to compile?
04:03:25 <merijn> ok, so I have two boilerplate functions, one that's basically mapM_ and one that's basically foldM, I'm considering eliminating the duplication I have between the two by just considering mapM_ to be a dummy foldM that returns (). Can I expect the performance difference of that to be minimal or should I keep it two separate functions?
04:03:46 <brynedwards> saurabhnanda: I don't know, I've never used it. From the dependencies it doesn't look like it should.
04:08:04 <AndreasK> merijn:Wouldn't that depend on the Monad in question? mapM_ uses >> and foldM uses >>=
04:09:40 <merijn> AndreasK: Maybe, but I was more thinking along the lines of the extra function calls and useless arguments you're juggling along
04:23:30 <merijn> Any suggestions how I could make this less god-awful looking? http://lpaste.net/358739
04:25:23 <merijn> Every refactoring I can come up with results in me having to duplicate a whole lot of code :\
04:26:20 <saurabhnanda> merijn: if you ask me, the code duplication doesn't seem like a problem. The lack of meaningful variable names is.
04:26:33 <merijn> Because outChanOut is bound in a do-block and the function to fold is bound inside the case
04:27:01 <merijn> saurabhnanda: What kinda meaningful variable names are you imagining are possible there?
04:27:29 <saurabhnanda> merijn: Left g, Right g, `go :: b -> r -> m r`
04:27:38 <saurabhnanda> is this library code or application code?
04:27:42 <merijn> saurabhnanda: Library code
04:27:49 <saurabhnanda> then, let it be...
04:28:26 <AndreasK> merijn: I checked out of interest and they both use foldr. Not sure about the interaction with >> vs >>= though so I guess best way would be just to take a look on the code.
04:29:02 <merijn> AndreasK: A look at which code?
04:29:12 <AndreasK> foldM and mapM_
04:29:50 <merijn> AndreasK: I'm not actually using those, I was just describing difference in functionality. See the paste I just made
04:30:58 <merijn> AndreasK: I could wrap the "b -> m r" into "r -> b -> m r" by just wrapping it with "const" and reusing the fold code, but I'm not sure what that'd cost
04:31:03 <dfsafd> any idea why this doesnt work? subRegex (mkRegex "\\d+") "a3b" " "
04:33:09 <saurabhnanda> dfsafd: just checking -- are two \\ required?
04:34:10 <AndreasK> Thats sadly outside of my expertise I fear. I would just write both and benchmark/look at the Core if it's performance critical code.
04:35:01 <dfsafd> saurabhnanda: yes, at least in ghci it is
04:45:26 <int-e> dfsafd: I think you should use [[:digit:]] instead of \d. 
04:47:18 <Digit> eehehehehhe.  tickles.
04:51:49 <dfsafd> int-e: that worked. i wonder why haskell doesn't support the \d syntax?
04:52:14 <merijn> dfsafd: s/haskell/this specific library
04:52:21 <merijn> You'd have to ask the library author
04:52:45 <merijn> Pretty sure \d is an extended/perl regex thingamajig
04:52:48 <int-e> dfsafd: it's not sanctioned by POSIX
04:53:21 <mlehmk> shouldn't just [0-9] work as well for a digit?
04:53:38 <merijn> mlehmk: Not in the presence of unicode
04:54:07 <mlehmk> and for unicode, you use the ecma regexp anyway, which is the perl-regexp just standardizes
04:54:40 <dfsafd> other classes like \W and \s works, weird that \d doesn't
04:54:42 <mlehmk> although even there, \d is equivalent to [0-9]
04:55:40 <mlehmk> are you sure you have IA5 digits and not any of the other unicode codepoints?
04:56:28 <dfsafd> are you saying that \d doesn't match all digits?
04:56:46 <mlehmk> I'm reading that \d is equivalent to [0-9]
04:57:20 <mlehmk> else you'd need \p{Digit}
04:57:21 <maffh> Hello, I am trying to using the cassava(https://hackage.haskell.org/package/cassava) library for reading a csv file. However, I don't know the header before parsing the file. What's the easiest way to get the header of the file?
04:57:55 <mlehmk> sorry, I mean \p{Number}
04:58:31 <mlehmk> although, that'd even match roman numericals
04:59:32 <mlehmk> maybe \p{Nd} is what you're looking for, if Haskell uses that regexp library/standard
05:00:15 <dfsafd> mlehmk: i think that's wrong, re.findall("\d", "3๓३") matches 3 times in python f.e
05:02:35 <mlehmk> seems like differen regexp implementations match differently
05:02:42 <osa1> maffh: use NamedRecord instance, it gives you a map and keys of the map will be columns of the CSV
05:03:20 <stevenxl> Does anyone have a tutorial on the applicative of functions that they can recommend. I understand the applicative of `Maybe`  - but having problem understanding the same for functions.
05:03:46 <osa1> maffh: err, sorry, I'm confused. use decodeByName function which returns the header
05:04:34 <osa1> for the type `a` you should use `NamedRecord`
05:05:02 <osa1> so `decodeByName csv_data :: Either String (Header, Vector NamedRecord)`
05:05:52 <int-e> dfsafd: the support of \s or \W just happens to be baked into your C library. POSIX allows such extensions... even \d may work on some platforms and not on others.
05:06:53 <mlehmk> > fmap ($3) [(3+),(3-),(3*)] 
05:06:55 <lambdabot>  [6,0,9]
05:06:57 <mlehmk> isn't applicative like this?
05:07:55 <int-e> dfsafd: (It took me some time to verify that regex-posix does indeed use the C library's regex engine, except on Windows. It ships C code for the latter, which definitely has no support for any of the \ classes.)
05:11:14 <byorgey> mlehmk: I don't understand your question.
05:11:38 <dfsafd> int-e: i think my c library supports \d too
05:12:24 <adjointfunctor> stevenxl, `(<*>) f g x = f x (g x)`
05:12:39 <adjointfunctor> > ((+) <*> (+1)) 1
05:12:42 <lambdabot>  3
05:14:45 <maffh> @osa1, yes I could do that, but then I don't know how to convert the value it to the correct types. I just want to use the header later in the code
05:14:46 <lambdabot> Unknown command, try @list
05:15:57 <stevenxl> adjointfunctor: thank you. 
05:16:10 <merijn> Is there a library for generating temp files?
05:16:15 <osa1> maffh: write a function `NamedRecord -> Either String YourType`, call it to convert named records to your type
05:16:34 <byorgey> merijn: http://hackage.haskell.org/package/base-4.10.0.0/docs/System-IO.html#v:openTempFile ?
05:18:28 <merijn> byorgey: I guess that works, just need to make sure I unlink it upon creation
05:18:37 <maffh> osa1, Does that not mean that I have to loop twice over the content? 
05:19:03 <osa1> maffh: it does mean that, once to parse to NamedRecords, once again to parse NamedRecords to your type
05:19:25 <maffh> osa1, Ah, oke. Thanks for your help
05:21:28 <merijn> byorgey: hmm, might actually be simpler to just FFI to tmpfile
05:22:52 <merijn> byorgey: Weird that apparently nothing has bindings for that
05:23:14 <kahlil29> is there an existing library in haskell to pretty print time in a relative manner? For e.g. given a time, it should say 10 minutes ago/1 hour ago/5 days ago etc
05:30:49 <merijn> Anyone here working on windows with like 5s to test something for me?
05:31:01 <adjointfunctor> kahlil29, that would e pretty easy to write yourself, you need to split timediff to years/months/days/hours/minutes/seconds, and print that accordingly
05:31:19 <adjointfunctor> kahlil29, sound like a couple of hours work
05:31:40 <adjointfunctor> kahlil29, do you need tht library right now?
05:32:18 <kahlil29> yeah if I don't find a library I'll probably write one and open source it
05:32:39 <mniip> merijn, does it involve having haskell installed?
05:32:46 <adjointfunctor> kahlil29, then do it, there isn't one =)
05:32:57 <kahlil29> sure right? cool :D 
05:33:34 <merijn> mniip: eh, yes
05:33:40 <adjointfunctor> kahlil29, don't forget to link your lib here =)
05:33:46 <angelingyawn> Question: How do I construct a member of the Text.JSON JSValue data type with the constructor JSString JSString? This seems to be impossible to do as the constructor is self-recursive without a base case
05:34:09 <kahlil29> yeah sure adjointfunctor
05:34:45 <opqdonut> angelingyawn: the first JSString refres to a constructor of JSValue
05:34:52 <opqdonut> angelingyawn: the second JSString refers to the type JSString
05:35:06 <angelingyawn> Herpedy derp derp
05:35:06 <angelingyawn> Thanks
05:35:07 <fommil> I have written an if condition, and the 'else' branch does 'return ()'. Is there something like a 'when' so I could just write 'when condition then foo' ?
05:35:19 <opqdonut> angelingyawn: ... which is defined as "newtype JSString   = JSONString { fromJSString :: String }
05:35:31 <opqdonut> this is a bit misleading, yes
05:35:36 <angelingyawn> Cheers dude
05:35:41 <kahlil29> adjointfunctor: any idea about the edge cases I would have to take of? any general pointers? 
05:36:02 <mniip> merijn, aw
05:36:08 <adjointfunctor> :t when
05:36:09 <lambdabot> Applicative f => Bool -> f () -> f ()
05:37:47 <fommil> oh, wait, `when` is a thing https://hackage.haskell.org/package/cond-0.4.1.1/docs/Control-Conditional.html
05:38:48 <adjointfunctor> fommil, there is `when` in Control.Monad, But it restrained by Applicative rather than Monad
05:40:55 <fommil> adjointfunctor: ah, turns out there was one on Control.Monad.Reader so it picked that up :-)
05:41:41 <fommil> I think I need to level up my signature searching foo
05:43:55 <adjointfunctor> kahlil29, your interface can look like `renderDiff :: UTCTime -> UTCTime -> String`, internally you can construct a type something like `data Diff = Years Months Days Hours Minutes Seconds`, and decide how you will handle negative diffs
05:44:41 <kahlil29> alright thanks
05:46:42 <merijn> ok, sod this...I'll just make my tests *nix only and windows people can go fix it themselves
05:49:52 <Psybur> merijn, what a relief it is when you finally take the blue pill huh
05:50:20 <barrucadu> kahlil29: Be careful with months and years being different lengths
05:50:30 <barrucadu> Even days are different lengths if you take leap seconds into account
05:51:23 <adjointfunctor> barrucadu, Data.Time handles that, he jest needs pretty time difference
05:51:37 <adjointfunctor> just*
06:01:07 <adjointfunctor> merijn, have you seen regex-applicative?
06:02:16 <merijn> adjointfunctor: Wrong person, I think?
06:04:21 <adjointfunctor> merijn, yes, sorry, i got confused by many nicks with starting `m` =)
06:04:24 <bartavelle> merijn: your nickname looks like a regexp, just saying ...
06:04:51 <merijn> bartavelle: Not nearly enough slashes for that to be true :p
06:04:59 <bartavelle> heh
06:05:51 <bartavelle> can't believe I will ever have a mental image of how to pronounce "ijn", despite looking for de Bruijn several times
06:07:02 <merijn> bartavelle: 1) De Bruijn 2) that doesn't help you, because Bruijn is archaic, so there's no ij, it's pronounced like Bruin is. Although that doesn't help either :p
06:07:58 <bartavelle> (I also was told about "De" Bruijn several times, at least once by you, seems I can't learn)
06:08:54 <merijn> I'm on a personal hopeless crusade to beat the functional and type theory world into properly capitalising it by pedantically correcting everyone one at a time! :p
06:10:04 <Psybur> You guys don't pronounce it marriagein :D?
06:10:16 <bartavelle> "marie jeanne"
06:10:54 <merijn> I used to be able to link to Google Translate text-to-speech for pronounciation, but Google fucked up their Dutch text-to-speech a year or two ago and now it's wrong
06:11:22 <btk> Isn't it more like Rijn in Rembrandt van Rijn?
06:12:01 <merijn> It isn't "like" Rijn, it's the exact same pronounciation, assuming you're pronouncing Rembrandt van Rijn right :p
06:12:05 <btk> Oh, I guess "Dutch text-to-speech" answers my question :D
06:12:13 <ventonegro> merijn: You need to record the pronounciation and upload it to Wikipedia :)
06:14:51 <merijn> A quick google tells me there's a lot of pages on how to pronounce things. And also a lot of them are clearly auto-generated from English rules, because they don't make any sort of sense
06:16:57 <btk> Is this the right way: https://www.youtube.com/watch?v=WyUOPc_EJ7g&t=1m44s ? 
06:17:10 <merijn> Yeah
06:17:41 <bartavelle> sounds like a german saying "reign"
06:17:59 <bartavelle> (although I am French and might not know how to pronounce reign)
06:18:15 <cocreature> huh I always thought it was pronunced more like “brown”
06:19:07 <merijn> cocreature: This pronounciation is not *too* awful: https://translate.google.com/#nl/en/bruin
06:19:46 <merijn> cocreature: English speakers usually pronounce it as "brown" since 1) it that translation and 2) no fucking way English speakers can manage "ui"
06:19:47 <cocreature> merijn: I guess not being able to bronounce De Bruijn is one more reason to use something else for variable bindings :P
06:22:16 <cocreature> wtf did I seriously write bronounce
06:22:34 <bartavelle> still better than bruijnounce
06:22:37 <merijn> cocreature: Whoo! *fist bump* *downs protein shake*
06:26:32 <merijn> ugh...my type signatures are way longer than the functions associated with them >.>
06:28:08 * Xion_ would render it as something like "de brooyin"
06:29:20 <tdammers> point in case, "dijkstra" isn't really any easier
06:29:46 <sphinxo> If I have `m (Either e a)` and I have some func `a -> m Either e b`, how can I apply it?
06:29:54 <maerwald> tdammers: my friend, how are you
06:30:00 <tdammers> although "dyke-strah" is close enough
06:30:00 <Xion_> "die'kstra"
06:30:01 <sphinxo> such that it short circuits when the given value is Left
06:30:09 <Xion_> Or that, yeah.
06:30:15 <cocreature> sphinxo: wrap it in ExceptT
06:31:04 <cocreature> :t \m f -> runExceptT (ExceptT m >>= ExceptT . f)
06:31:06 <lambdabot> Monad m => m (Either e a1) -> (a1 -> m (Either e a2)) -> m (Either e a2)
06:32:46 <sphinxo> awesome thanks :)
06:33:20 <eschnett> i want to define a type (with “data”), but be able to add constructors for this type in other modules. what is this called in haskell?
06:33:32 <merijn> eschnett: "impossible"
06:37:05 <mnoonan> eschnett: I think the key term is "polymorphic variants". ocaml has 'em, haskell doesn't. I don't have a good intuition for whether or not the complexity is worth it.
06:37:42 <mnoonan> and I think there are some Haskell packages to fake polymorphic variants, e.g. https://hackage.haskell.org/package/data-diverse
06:41:20 <eschnett> thanks.
06:45:30 <stevenxl> Hi folks. Quick question. I thought that `MaybeT` was a type constructor with kind (* -> *) -> * -> *. That seems to be correct. However, why is it that I can also see that `MaybeT` also has a type? Is it more than a "regular" type constructor?
06:45:51 <stevenxl> Oh wait nevermind. I'm confusign the type constructor and the data constructor
06:45:56 <stevenxl> sorry false alarm
06:46:06 <merijn> stevenxl: Crisis averted ;)
06:46:07 <ventonegro> stevenxl: There are two things named MaybeT
06:46:09 <ventonegro> exactly
06:46:22 <stevenxl> Thank you!
06:55:45 <sedeki> hi all
06:55:53 <sedeki> any recommendations on Martin-Löf type theory?
07:00:01 <jophish> What does `is unusable due to shadowed dependencies` mean? I'm getting this error when running setup.hs trying to build the hackage-security library
07:01:23 <cocreature> jophish: it’s a known bug but sadly without a fix, see https://github.com/haskell/cabal/issues/4728
07:03:25 <jophish> cocreature: yeah, I saw that issue but there's not much info there :(
07:03:31 <jophish> interestingly this builds with ghcHEAD
07:03:44 <jophish> seems to just be happening with ghc821
07:04:05 <cocreature> jophish: nuking dist-newstyle and if that doesn’t work ~/.cabal/store seems to work but is ridiculously annoying
07:04:53 <jophish> cocreature: that's very odd, all these builds take place in a sandbox without any home directory (nix)
07:05:27 <cocreature> well there is still a package db somewhere
07:06:07 <jophish> oh, so it could be some nondeterminism in that db's construction?
07:06:46 <cocreature> I don’t think there is anything nondeterministic about this bug. take a look at the example michael has provided in that bugreport
07:06:57 <cocreature> it reliably reproduces the bug using only Cabal the lib
07:08:12 <jophish> sounds reasonable 
07:09:02 <cocreature> I tried taking a look at it a few days ago but realized I know way too little about how GHC package dbs work to get anywhere within a reasonable timeframe
07:09:19 <jophish> Ah, I was just about to start looking myself
07:09:37 <cocreature> please do! I really want this to be fixed :)
07:09:59 <cocreature> jophish: you might also be able to get more info in #hackage (the cabal devs hang around there)
07:15:07 <jophish> thanks cocreature 
07:38:30 <kuwze> where is binary that cabal install produces? I also installed cabal via apt-get since I couldn't figure out how to install it via stack
07:39:00 <merijn> kuwze: On *nix cabal-install puts binaries in ~/.cabal/bin
07:39:42 <kuwze> merijn: thank you!
07:43:20 <kuwze> merijn: should I have installed cabal via apt?
07:44:18 <mnoonan> kuwze: stack generally manages installing cabal and ghc, you shouldn't need to do anything extra.
07:44:23 <kakashiAL> Either is a function, but why do they call it a datastructure?
07:45:31 <jophish> cocreature: I think I'm in a similar situation to you :| not nearly enough time to understand this problem
07:45:36 <ventonegro> kakashiAL: Data constructions are called like functions, but ones implemented by the runtime
07:46:09 <kakashiAL> ventonegro: not implemented, you mean interpreted, right?:)
07:46:10 <ventonegro> kakashiAL: Just like in C++ or Java when you call a constructor to build an object
07:46:39 <mnoonan> kakashiAL, in what sense do you think Either is a function? For one thing, functions have kind * but Either has kind * -> * -> *.
07:46:49 <cocreature> jophish: maybe we need to crowdfund someone to fix this :)
07:46:52 <ventonegro> kakashiAL: Implemented, you don't get to implement data constructors yourself
07:47:09 <kakashiAL> ventonegro: so is it also a datastructure, because it returns data?
07:47:35 <ventonegro> kakashiAL: as mnoonan said, the data constructors are Left and Right
07:47:40 <kakashiAL> ventonegro: implemented means "programmed/coded" so it makes no sense for me :/
07:47:53 <ventonegro> Either is the *type* constructor
07:48:13 <ventonegro> kakashiAL: Yes, you don't get to code the data constructors
07:48:32 <ventonegro> data Either a b = Left a | Right b
07:48:40 <kakashiAL> ventonegro: thats why "its implemented" makes no sense for me :/
07:49:09 <ventonegro> Now magically there is a function called Left that you didn't implement/write/code
07:49:44 <kakashiAL> ventonegro: I would not call it "implemented" I would say "its executed" in runtime
07:50:00 <ventonegro> kakashiAL: But who coded it then?
07:50:16 <kakashiAL> ventonegro: its already coded, you only pass stuff to it
07:50:26 <ventonegro> kakashiAL: By whom?
07:50:45 <mnoonan> this conversation seems entirely orthogonal to your original question.
07:51:20 <jophish> cocreature: the annoying thing is that I don't even know what's wrong. As far as I can tell it's some kind of ABI mismatch in the package DB
07:52:24 <kakashiAL> ventonegro: let me think/read more for a moment
07:52:41 <cocreature> jophish: yeah I have no idea what a shadowed dependency even is
07:52:58 <ventonegro> kakashiAL: http://unendli.ch/posts/2017-07-20-algebraic_data_types.html
07:54:25 <jophish> cocreature: https://github.com/ghc/ghc/blob/7446c7f68bd5addd2f2db0d8d5910fb963869c47/compiler/main/Packages.hs#L1123-L1125 https://github.com/ghc/ghc/blob/7446c7f68bd5addd2f2db0d8d5910fb963869c47/compiler/main/Packages.hs#L1214-L1226
07:54:59 <jophish> Something to do with abi mismatches, or missing packages
07:55:02 <cocreature> jophish: I got that far but I’m still not exactly sure why there should be ABI mismatches
07:55:09 <jophish> hehe, yeah, that's got me too
07:55:10 <cocreature> and then I gave up :/
07:56:10 <cocreature> my “solution” for now is to use 8.0.2
07:59:32 <c_wraith> How did I write code 3 years ago that I haven't been able to understand since, despite frequently trying?
08:00:16 <iqubic> I think my first big dive into in Haskell will be an irc bot.
08:00:35 <iqubic> I have already registered a nick for my bot.
08:00:36 <savask> c_wraith: That is the question I ask myself sometimes
08:00:59 <savask> c_wraith: Now I try leaving comments near every function I define so that I would have at least some hints
08:01:13 <c_wraith> I know what the function does, I just don't understand how.
08:01:25 <c_wraith> Other than "voodoo CPS"
08:02:03 <savask> Well
08:02:04 <shapr> I've done that, wrote something on a really good day, never did understand it again.
08:02:20 <savask> Maybe you were in a changed state of mind
08:02:27 <mnoonan> I'll humbly suggest that maybe it wasn't such a good day after all :)
08:02:54 <jophish> iqubic: let us know how it goes!
08:03:18 <c_wraith> http://lpaste.net/revision/114261  The name of the function and the type make it pretty clear what's going on. But... Every time I look at it I get more confused.
08:05:39 <jophish> c_wraith: perhaps evaluating it by hand for a few finite examples would help
08:09:46 <phaazon> hey, what is the defacto package to use for FTP client programming?
08:10:03 <phaazon> ftp-client-conduit seems pretty good
08:10:13 <phaazon> well, nevermind.
08:10:16 <phaazon> it seems awful
08:10:17 <phaazon> :D
08:10:41 <phaazon> ftp-client, maybe?
08:11:09 <bartavelle> last time I checked all ftp client libraries were bad
08:11:29 <phaazon> :/
08:11:32 <phaazon> bad in what terms?
08:11:33 <c_wraith> given the nature of FTP, I'd expect all client libraries in all languages to be bad
08:11:41 <phaazon> :D
08:11:45 <c_wraith> FTP is just too complicated
08:11:45 <bartavelle> there were unmaintained also
08:11:56 <phaazon> dele :: MonadIO m => Handle -> String -> m FTPResponse
08:11:57 <phaazon> dele
08:12:02 <phaazon> oooooookaaaayyyy
08:12:12 <cocreature> ftp-client looks reasonably well maintained at least
08:12:14 <tdammers> I would argue that FTP in its original design was rather too simple than too complicated
08:12:26 <tdammers> too many assumptions that turned out unreasonable
08:12:30 <c_wraith> tdammers: well, I was considering the current state, not the original design.
08:12:39 <tdammers> c_wraith: one begets the other
08:12:40 <bartavelle> (I needed some form of proxy support, none of the libraries supported it, can't remember the specifics)
08:16:24 <kuznero> Hi All! If I have a flag defined in my cabal file that affects which ghc-options are set, how do I pass this flag when building my project?
08:17:35 <srhb> kuznero: cabal configure -f yourflag, iirc
08:17:55 <kuznero> srhb: ah, thanks!
08:19:25 <kuznero> srhb: if I want -Werror to be false by default but only true during development phase, will this be appropriate: http://lpaste.net/2537290649242173440 ?
08:19:47 <kuznero> And then `cabal configure -f werror`...
08:20:59 <srhb> kuznero: That looks correct to me.
08:21:07 <kuznero> srhb: thanks!
08:53:01 <kuznero> Is there any way to check which options were used on `cabal configure` without re-running it with required options?
08:56:46 <c_wraith> kuznero: you can use the Cabal library for that, but it's touchy.  You need to be using the same version of the library as the cabal-install tool was built against.
08:57:45 <c_wraith> and I don't remember the details.  Just that I was upgrading Cabal and cabal-install too frequently for it to be a good solution for me.
08:58:37 <kuznero> c_wraith: that sounds like an advance level :) I am using nixos and supply `configureFlags` in my `shell.nix` file. So, when I start my dev shell with nix-shell and run `cabal build` I am simply uncertain weather the right flags were supplied.
09:01:41 <c_wraith> hmm.  I'd think the best way to test that would be making sure that the cabal configure command line was echoed somewhere.  But I don't know anything about how nix sets that up
09:02:04 <kuznero> c_wraith: thanks! will try to figure it out
09:03:17 <beaky> hello
09:03:20 <beaky> how do i turn a monad into another monad
09:04:16 <beaky> e.g. [] into Nothing. (x:xs) into Just (x:xs)
09:04:31 <eschnett> is there a name for a profunctor where lmap (the pre-composition) requires the function to be bijective?
09:05:11 <mnoonan> beaky: you've almost written the code already; just toss it into a case expression.
09:05:15 <vimalloc> I'm handling possible errors (in pure and impure functions) via MonadError. In another function I'm using a database connection which throws IOException. Trying to use both of these together feels kinda cumbersome. Would catching the IOExceptions and returning them in MonadError (so that I can universially just deal with that) be a stupid thing to do?
09:05:15 <beaky> ah thanks
09:05:29 <mnoonan> there isn't anything special about monads there
09:05:35 <beaky> i thought there was a magical applicative trick to do something 
09:06:21 <beaky> like a magical isomorphism between different monads
09:06:51 <mnoonan> there is no general function of the form "(Monad m1, Monad m2) => m1 t -> m2 t", so it'll just be specific to your particular pair of monads
09:06:59 <beaky> ah
09:07:30 <mnoonan> (also, "in before somebody mentions bottom") :)
09:07:37 <beaky> something like this https://en.wikipedia.org/wiki/Monad_transformer#The_option_monad_transformer
09:07:51 <beaky> or is that different
09:11:25 <mnoonan> that's different.. monad transformers operate on the kind level. instead of transforming from *values* of one type to another, they create new *types* out of old ones.
09:12:05 <beaky> ah
09:12:07 <mnoonan> or really, new *type constructors*
09:12:26 <beaky> so monad transformers are not what i want (since im looking at list values)
09:12:53 <mnoonan> yeah, probably not
09:15:09 <AWizzArd> Is there a generic way to introduce right-currying to Haskell? So that I start specifying the args from the right (the later args), but leave some earlier ones away?
09:15:23 <AWizzArd> Without defining rcurry2, rcurry3, rcurry4, etc.
09:17:54 <pja> judicious use of flip ?
09:18:52 <AWizzArd> If that would lead to a generic implementation I would be curious to see it.
09:20:32 <c_wraith> @pl \f a b c d -> f d c b a
09:20:32 <lambdabot> flip . ((flip . (flip .)) .) . flip . (flip .) . flip
09:20:39 <c_wraith> It'd look like a lot of that.
09:20:50 <pja> c_wraith: :)
09:21:48 <AWizzArd> Yeah, this would be for 4 args though, not for n.
09:22:35 <fvh> hi, everyone. I have middle size application that recently started to compile 4m instead of 3, having up to 4GB in linking stage with ld. Can you suggest how to track down the cause of slow down, compilation time issue?
09:23:20 <tabaqui> @pl (+)
09:23:20 <lambdabot> (+)
09:23:46 <tabaqui> pl translates the function to dotfree notation?
09:24:07 <tabaqui> @pl \x y -> x + y
09:24:07 <lambdabot> (+)
09:24:15 <tabaqui> @pl \x y z -> (x + y) * z
09:24:15 <lambdabot> ((*) .) . (+)
09:25:18 <Psybur> @pl \a b c d -> ((a + b) * c) / d
09:25:19 <lambdabot> ((((/) .) . (*)) .) . (+)
09:26:37 <ertes-w> fvh: not a direct answer, but you can reduce both compilation times and RAM usage by splitting your project up
09:29:25 <fvh> ertes-w: already split in 3 parts, one app and 2 libs,  but even if underlying part not changing (50% of code base), even smallest comment addition or line removed in app still takes around 4m
09:30:22 <tabaqui> fvh: I usually use ghc-option: -O0 while debugging and testing
09:30:32 <ertes-w> fvh: split it some more, if you can, or reorganise your module dependencies…  if you change a core module, that's going to take a long time, because everything that depends on it has to be changed as well
09:30:39 <tabaqui> and build with all optimization only release versions
09:30:55 <ertes-w> fvh: also change your development cycle to GHCi rather than compilation
09:30:59 <ertes-w> if you can
09:32:28 <fvh> I'm more interested in tracking down the root of the issue, how do you profile guys? Something like `stack build --profile` or there are other options? criterion?
09:36:11 <c_wraith> You'd need a custom profiling build of ghc, which would run even slower...
09:36:54 <c_wraith> Can you bisect your version history looking for commits that added significant time to the build?
09:45:04 <jared-w> Hmm... Lamping's Abstract Algorithm. Does anyone know anything about it?
09:48:35 <tangled_z[m]> jared-w: i know there's an implementation of it using interaction combinators. https://github.com/MaiaVictor/abstract-algorithm
09:48:46 <jared-w> oooh neat
09:49:16 <jared-w> oh yeah that's the one I was actually looking at earlier! I was wondering if there had been any research beyond Lamping's algorithm--the paper is over 20 years old, after all
09:50:53 <tangled_z[m]> would be curiosu to know about that too
09:54:25 <jared-w> I /think/ much of the reason this hasn't had much research is it only really shines in the presence of highly stratified types
09:54:33 <jared-w> s/types/terms/
09:54:50 <c_wraith> those are still different.  we don't have dependent haskell...  yet.
09:54:52 <jared-w> and even Haskell tends to be very flat (hell even Agda is pretty flat from what I've seen)
09:55:32 <jared-w> c_wraith: thanks for the correction; my fingers aren't quite awake yet apparently :p
09:56:08 <c_wraith> Eh.  I know nothing of the algorithm.  Certainly couldn't correct you on it.  Just commenting on your own correction. :)
09:57:19 <jared-w> The algorithm is an optimally efficient evaluater of lambda calculus terms; asymptotically superior to others especially in the presence of stratification (which I still don't really know what that is but it's very important apparently)
09:57:21 <c_wraith> I'm trying to sort out some really old code I wrote that looks like gibberish to me now.  I have succeeded in annotating it and simplifying it a bit without breaking it, but I'm still not sure I understand it.  (What's fun about Haskell is that you can make progress without understanding)
09:57:45 <jared-w> hah nice. I've done that before. Not in haskell, unfortunately, so it was more like decoding the rosetta stone...
09:58:16 <jared-w> brb interview real quick :) 
09:58:18 * jared-w is excited
10:01:44 <mnoonan> jared-w: this paper seems to torpedo the optimal evaluation work somewhat (or at least make it clear that the issue is fairly subtle): https://www.researchgate.net/publication/2309270_Optimality_and_Inefficiency_What_Isn't_a_Cost_Model_of_the_Lambda_Calculus
10:02:51 <c_wraith> mnoonan: don't forget that bubble sort is proven optimal.....  for the cost model of sorting records so large that only two of them fit in memory at once and are stored on a tape drive. :)
10:03:31 <mnoonan> heh
10:04:11 <c_wraith> there was a time when that was an interesting cost model to optimize for. :)
10:21:14 <monochrom> Oh! No wonder bubble sort looks so strange.
10:22:11 <shapr> monochrom: it's actually a trickle down sort?
10:24:45 <erisco> trickle down sorting has never worked!
10:26:06 <Psybur> erisco, I'll take your trickled sort if you don't want yours :D?
10:28:22 <Psybur> @pl \a b c -> a c b
10:28:22 <lambdabot> flip
10:33:49 <erisco> :t curry . (. swap) . uncurry
10:33:50 <lambdabot> (b -> a -> c) -> a -> b -> c
10:43:23 <eacameron> What's the safest type to use for storing numbers that represent monetary amounts?
10:43:51 <hydraz> Fixed?
10:44:14 <fishythefish> Integer?
10:44:46 <eacameron> hydraz: Huh I'd never seen Fixed before
10:44:51 <shapr> hackage has safe-money and currency, though I've not tried either of those.
10:45:03 <eacameron> shapr: Thanks. I'll look
10:45:03 <shapr> heh, Data.Money :-)
10:45:10 <hydraz> eacameron: it's not exactly well advertised
10:45:37 <eacameron> Scientific seems like a decent candidate
10:45:49 <fishythefish> granted, I haven't had to represent money in haskell, but people tend to overcomplicate this in pretty much any language
10:45:52 <shapr> scientific is relatively well known, yeah?
10:46:05 <fishythefish> you don't need floating point or anything like that - just store the number of cents (or whatever your smallest denomination is)
10:46:14 <c_wraith> scientific seems like a poor choice
10:46:26 <eacameron> tell me more!
10:46:41 <eacameron> fishythefish: I think it breaks down if you're working between currencies
10:47:00 <fishythefish> depends on your use case
10:47:03 <c_wraith> scientific's data representation is really only good for writing numbers in scientific notation.
10:47:12 <eacameron> c_wraith: Ah...hmm...true
10:47:22 <eacameron> I saw an example somewhere that used Scientific
10:47:52 <phadej> 1/3 :: Scientific -- is a very bad idea
10:48:10 <c_wraith> it tries to keep full decimal precision, right?
10:48:13 <geekosaur> it breaks down in a lot of use cases. for some uses you want tenths of he minimum unit so you can get rounding of conversions or tax calculations more correct
10:48:17 <phadej> c_wraith: yes
10:48:37 <fishythefish> if you want tenths of the minimum unit, that's not the minimum unit ;)
10:48:38 <c_wraith> so yeah..  dividing by anything with prime factors other than 2 and 5 is a poor choice
10:48:39 <geekosaur> keeping full precision in those cases is wrong, btw; see discussions of "banker's rounding"
10:48:56 <geekosaur> minimum currency unit
10:49:05 <fishythefish> i know what you meant :)
10:49:41 * eacameron decides to punt and use String
10:49:44 <shapr> noooo
10:49:49 <eacameron> :P
10:49:53 <c_wraith> at least newtype it. :P
10:50:07 <eacameron> LOL
10:50:11 <mnoonan> that's more like running entirely off of the field
10:51:02 <shapr> I once had to deal with 35mb of Person Hours logs, it was so much fun to decode all of "1 1/2", "1,5" and "1.5" as count of hours.
10:51:17 <eacameron> c_wraith: instance Num StrMoney where left + right = left ++ " + " ++ right
10:51:21 <tabaqui> hmm
10:51:30 <tabaqui> I have forked process
10:51:35 <tabaqui> and bracket inside child
10:51:44 <c_wraith> eacameron: might as well just use acme-php
10:51:46 <tabaqui> but it doesn't catch sigint
10:51:51 <eacameron> c_wraith: LOL
10:52:01 <c_wraith> @hackage acme-php
10:52:02 <lambdabot> http://hackage.haskell.org/package/acme-php
10:52:21 <AndreasK> Suggestions for something "better" for associationg a boolean with a value then Either a a? The intention is to represent potential negation
10:52:22 <c_wraith> The api docs don't reveal the true horror.  You need to read the instances.
10:52:24 <tabaqui> did anybody use System.Posix.Process?
10:53:03 <eacameron> c_wraith: Haha depends on acme-left-pad. Never noticed that.
10:54:22 <c_wraith> tabaqui: did you install a handler for sigint?
10:54:37 <c_wraith> tabaqui: if you didn't, it will just kill the process.
10:54:40 <eacameron> Centi from Data.Fixed seems good
10:54:42 <tabaqui> c_wraith: nope, I just use bracket
10:54:50 <tabaqui> why? it didn't kill the parent
10:55:09 <c_wraith> tabaqui: that's what unhandled signals do
10:55:36 <tabaqui> but if you just bracket your code, than sigint will be catched and final action called
10:55:45 <c_wraith> bracket doesn't install signal handlers
10:56:04 <tabaqui> bracket (return ()) (const $ print 1) (const $ getChar)
10:56:10 <tabaqui> try to interrupt this
10:56:21 <c_wraith> Oh, hmm.  the runtime does install a handler for SIGINT by default, that results in raising an exception in *some* thread
10:56:24 <tabaqui> you'll see printed 1
10:56:51 <c_wraith> I have no idea how the runtime handles forking.
10:57:09 <tabaqui> well, it have to be posix "fork"
10:57:41 <tabaqui> it's strange that the same handler is not installed in child
10:58:00 <c_wraith> I'm not sure the runtime is really intended to be forked.
10:58:13 <fakenullie> person hours logs are just wrong
10:58:30 <tabaqui> where did you read about default handler?
10:58:44 <tabaqui> I gonna install them manually
10:59:21 <nshepperd> I remember reading that places like banks and exchanges usually do things in integer counts of cents or whatever minimum unit. If a division is ever needed for some reason, you round down the result and put the remainder either in a slop account (which the bank pockets) or return it to the source
11:00:31 <c_wraith> tabaqui: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Signals is a decent start
11:00:50 <tabaqui> I'm just here :)
11:01:47 <tabaqui> hmm, I'll just throw exception to thread 0
11:04:25 <geekosaur> I thought SIGINT default handler already did that (and is possibly what you are seeing)
11:06:08 <tabaqui> geekosaur: it does only for main process, not for childs created by System.Posix.Process.forkProcess
11:07:24 <geekosaur> also, if you are mixing forkProcess and forkIO/forkOS, you are in undefined behavior territory
11:07:43 <geekosaur> ghc can't fix this because it's a consequence of the POSIX process model
11:08:20 <tabaqui> why? forkIO/forkOS spawn threads not processes
11:08:29 <geekosaur> exactly
11:08:47 <geekosaur> but forkProcess only forks the *process*. the child process has only a main thread
11:09:30 <tabaqui> okaay
11:09:57 <tabaqui> posix says that signals handles each process independently
11:10:07 <geekosaur> but the records of the threads created by the resources, and any resources (handles, mutexes, etc.) they held, are still around and effectively "unowned". this can mean locks are still considered held but nobody is actually holding them in the child
11:11:09 <tabaqui> I'm not sure what you mean, but I'm intend to install handler for each child just after creation
11:11:14 <tabaqui> inside child main process
11:11:18 <geekosaur> this is not a Haskell-specific problem; it's one reason why python doesn't try to do threads and perl does them via separate interpreters (it can just drop the non-default interpreters and free their resources after a fork)
11:12:14 <geekosaur> but in ghc this is known to lead to odd deadlocks if the I/O manager thread was doing something when you forkProcess-ed, and other odd behavior. the doucmentation for forkProcess shoudl warn you not to mix it with threads
11:13:36 <tabaqui> you want to say that child process inherits locks from parent?
11:13:55 <tabaqui> it should not do that for any resources though
11:14:35 <geekosaur> I want to say what I said
11:14:47 <geekosaur> if it did not make sense to you, then you will have to learn how this works'
11:15:00 <geekosaur> there are no quick hacks, there are no workarounds.
11:15:08 <tabaqui> I'm not native english speaker, just trying to make it clear for me
11:16:13 <tabaqui> dunno, I have similar code with mixed fork's on my server with 3 months uptime
11:16:23 <geekosaur> the core problem is: handles, mutexes, locks, etc. are process level, not thread level. They are duplicated and continue to exist after forkProcess
11:16:30 <geekosaur> threads *do not continue to exist*
11:17:02 <tabaqui> but signal handlers do not duplicated
11:17:23 <geekosaur> the best outcome of this is that things continue to work but you "leak" those things in the child process --- they still exist but are inaccessible
11:17:54 <nshepperd> my understanding is that in unix, threads + fork() = the bloodeldritch throes of the broodfester tongues
11:17:54 <tabaqui> ah, ok, I can get this
11:18:05 <geekosaur> but if something then tries to use a mutex and a thread in the parent held the mutex at the time of the forkProcess, at process level it is still held but nothing in the child can release it
11:18:07 <tabaqui> but it's not a problem for GC, right?
11:18:44 <geekosaur> this is not a GC issue, except insofar as GC also can't know that thread-related memory objects should be freed in the child
11:18:52 <tabaqui> ehm, FFI functions are not atomic?
11:19:04 <geekosaur> ?
11:19:18 <nshepperd> the best thing to do imo is forget that fork() exists and just spawn another copy of yourself that sets itself up from scratch
11:19:30 <geekosaur> at this level, mutexes are not atomic because user code has to acquire and release them
11:20:05 <geekosaur> so what happens when, after forkProcess, the thread code that was using the resource it locked with a mutex, no longer exists in the child and can't release it?
11:20:48 <geekosaur> again, mutexes are *process* level (that's the point, it needs to be visible across multiple threads) so the OS can't know to release it for you. and neither can the GHC --- or any other language --- runtime know, because it can;t know what your code is doing
11:21:10 <jackhill> rbdulgtbhnlncbtjijkkcfrgjubbhcrn
11:21:43 <ggVGc> ^ agree
11:21:53 <adjointfunctor> wise words right here 
11:22:06 <geekosaur> it cannot know that mutex A must be released because the thread(s) that managed it is gone, but mutex B will immediately be reacquired by a runtime-manager thread
11:22:19 <geekosaur> jackhill, check your yubikey :p
11:22:45 <jackhill> geekosaur: oops, thanks!
11:23:15 <jackhill> if only I had  focus-follows-intention
11:24:26 <tabaqui> well, if I didn't understand some of this, I hope it will open on debug stage :)
11:24:28 <tabaqui> thanks
11:24:37 <nshepperd> that's quite a password
11:24:55 <geekosaur> anyway, as I said earlier, this isn;t even a ghc specific problem, some other languages refuse to do threads completley because of it and still others do them in a heavyweight way because it lets them recover from this
11:26:22 <geekosaur> (for those wondering re the "password", that's a USB dongle that produces an OTP key when activated. at least one such, a yubikey model, is prone to activate any time it's bumped or brushed against)
11:26:47 <geekosaur> (I;m in a suysadmin channel and we go through rashes of people bumping their keys and spitting OTPs into the channel)
11:27:08 <c_wraith> I figured it out!  http://lpaste.net/358751
11:37:32 <nshepperd> (the fork() system call was a design mistake. too much power)
11:37:43 * ggVGc forks nshepperd 
11:38:02 <nshepperd> gasp
11:38:52 <maerwald> how is it too much power? That's exactly what you want in low-level API. You are free to build more abstraction around it
11:40:01 <nshepperd> because it overly contrains the implementation
11:42:17 <nshepperd> iirc there are all sort of quirks and problems in unices that exist just to facilitate fork(). even though almost no-one actually uses the full power of it
11:42:25 <penteract> stanion graduate scholarship
11:42:51 <ggVGc> maybe you should go the microsoft way and just introduce fork_s()
11:42:55 <ggVGc> and redefine it
11:43:06 <penteract> I need to be more careful about which window I'm typing in
11:43:08 <ggVGc> for our new haskell-based unix
11:44:20 <adjointfunctor> btw, did anyone implemented an OS in haskell? I've seen linux kernel modules in haskell, but not OS yet
11:44:37 <ggVGc> I'd guess at least 50 people have written an OS in haskell
11:44:42 <maerwald> people have written kernels in javascript too
11:44:48 <kaychaks> am trying to get values of subset of keys from a json array of objects via lens-aeson. e.g. for input [{name: "john", age: 24, weight: 88.3}, {name: "doe", age: 25, weight: 77.2}], output would be [(john, 24), (doe, 25)]. not quite able to wrap around the flow  required in lens
11:44:56 <adjointfunctor> maerwald, but why
11:45:05 <maerwald> adjointfunctor: why write one in haskell
11:45:07 <nshepperd> are you counting the RTOSes that people have written in atom/ivory
11:45:08 <maerwald> same answer
11:47:04 <adjointfunctor> maerwald, if someone tries to write a kernel in a language just as a proof of concept, then it sounds reasonable to write a kernel in JS
11:47:33 <adjointfunctor> but if you need real-world kernel, then you need better tools than that
11:47:51 <maerwald> exactly, which means: use a real systems programming language
11:48:07 <maerwald> so you can reason about performance, memory, maybe even timing behavior
11:48:53 <c_wraith> There have been at least two system kernels designed to run in a hypervisor that were written in Haskell.
11:49:10 <c_wraith> Running in a hypervisor does let you get away from the fiddliest parts of dealing with the hardware.
11:50:47 <adjointfunctor> Haskell can be fast and compact, more abstract doesn't always mean slower and bigger
11:50:49 <adjointfunctor> right?
11:51:00 <maerwald> uhm
11:51:24 <ggVGc> the best part about writing real time systems in haskell is how easy it is to determine memory usage
11:52:42 <c_wraith> someone (acowley, iirc) had a lot of success writing computer vision-based robot control systems in haskell.
11:53:26 <adjointfunctor> I heard of common game of haskellers to rewrite C programs in haskell, and if they were running faster than C, C code was not optimised enough
11:54:24 <adjointfunctor> c_wraith, can you link it here?
11:54:38 <maerwald> you can do that for trivial algorithms maybe, but there is little common knowledge about manually optimizing haskell code. For C, we have decades of experience, because the primary domain of C is not abstraction, but... performance
11:56:11 <maerwald> and, you are closer to the hardware, and the compiler is not very smart, which allows you to have a more direct connection to what will actually run
11:56:41 <c_wraith> adjointfunctor: http://programatica.cs.pdx.edu/House/ is one thing.  It hasn't been updated in quite a while, but it worked
11:56:53 <adjointfunctor> In a choice between 20-years worth of experience and type system I will choose type system, just because compilers don't have to be dumb ;)
11:57:15 <maerwald> sometimes smart is not what you want
11:57:39 <maerwald> it has impact on your ability to reason about the compiler output
11:59:12 <adjointfunctor> maerwald, are you saying that compiler does his job nondeterministically?
11:59:47 <maerwald> no
11:59:47 <adjointfunctor> I thought this was the whole purpose of pure functions, y'know
12:01:43 <hodapp> compiler *can* do its job nondeterministically and still provide correct results, depending on what sort of nondeterminism you mean.
12:02:36 <adjointfunctor> maerwald, Then how it impacts my ability to run the same program through, trace step-by-step all transformations and optimisations, and arrive to a executable code?
12:02:54 <maerwald> adjointfunctor: I was talking about the ability to reason about compiler output, not about running it
12:03:35 <maerwald> the step of C -> ASM  is very small
12:03:41 <maerwald> not so much with haskell
12:04:06 <maerwald> sometimes you care, sometimes you don't
12:04:38 <adjointfunctor> maerwald, compiler outputs programs, and different compiler can somehow  differently strip information about that program, do I understand you correctly?
12:04:59 <maerwald> no, I am talking about transformation
12:05:35 <adjointfunctor> source code to AST transformation?
12:05:50 <maerwald> what?
12:06:07 <maerwald> maerwald: the step of C -> ASM  is very small
12:07:48 <sm> sm: tell maerwald they are talking to themselves
12:08:01 <maerwald> sm: lol
12:09:24 <monochrom> monochrom: I prefer to do it the following way:
12:09:24 <adjointfunctor> maerwald, you trying to imply that more abstraction leads to worse code. Just because C is a cross-platform ASM doesn't mean than abstraction mapping to hardware is less traceable
12:09:27 <monochrom> @quote monochrom
12:09:27 <lambdabot> monochrom says: All numbers just sit there doing nothing.
12:09:37 <pikajude> note to pikajude: stop talking to self in public
12:10:05 <monochrom> But more seriously, I think the two of you could take this debate to PM.
12:10:13 <maerwald> adjointfunctor: more indirection between input language and output leads makes it harder to reason about output-properties at the input-level, yes
12:10:58 <adjointfunctor> monochrom, sorry =(
12:10:58 <maerwald> this is very obvious and therefore people use certified C compilers in safety critical applications (and only ever that version, so output properties never change)
12:15:26 <solV3d> hello !
12:15:32 <shapr> howdy solV3d 
12:15:46 <solV3d> i new to haskell and i am trying to figure out an error GHCI gives me
12:15:59 <solV3d> its says,  parse error on input `=' Perhaps you need a 'let' in a 'do' block? e.g. 'let x = 5' instead of 'x = 5'
12:16:15 <solV3d> i am not exactly sure what that means
12:16:53 <shapr> solV3d: are you trying to define a function in ghci?
12:17:01 <solV3d> i am loading from a text file
12:17:07 <solV3d> :load haskell.hs
12:17:40 <shapr> solV3d: could you put haskell.hs into lpaste.net and put the resulting url here?
12:18:41 <solV3d> sure, but wait i just changed the intention
12:18:47 <solV3d> that seems to matter :D
12:36:05 <geekosaur> indentation (if that was what you meant) matters quite a lot in Haskell, yes
12:36:51 <shapr> solV3d2: did you get it working?
12:39:28 <solV3d2> i think yes shapr, but ran into new errors :D
12:39:32 <solV3d2> its interesting though
12:40:02 <shapr> what are your new errors?
12:40:54 <solV3d2> well not errors, unexpected behaviour, my code is just wrong :D :D
12:41:00 <shapr> I know that feeling
12:42:02 <solV3d2> well not errors, unexpected behaviour, my code is just wrong :D :D
12:42:05 <solV3d2> oops
12:42:05 <solV3d2> sorry
12:44:03 <solV3d2> not very easy to debug :D
12:44:23 <Cale> Hello
12:45:41 <shapr> hi Cale 
12:45:51 <shapr> solV3d2: it gets easier!
12:46:37 <solV3d2> http://lpaste.net/358753
12:46:43 <solV3d2> here is what i am up to
12:46:50 <solV3d2> my full adder has some logic problems though
12:46:52 <erisco> how can I convert Data.ByteString.ByteString to StringBuffer.StringBuffer?
12:46:59 <solV3d2> the half adder should be fine
12:47:17 <erisco> though String, yes, but this seems roundabout
12:47:58 <monochrom> xor a b = a /= b
12:48:54 <solV3d2> thanks for that :)
12:49:39 <monochrom> (sum1, carry1) = ha a b
12:50:44 <solV3d2> cool
12:51:28 <solV3d2> http://lpaste.net/358754
12:51:35 <solV3d2> little optimized :D
12:51:43 <shapr> I get frustrated by decorators used for metaprogramming-ish purposes in Python and C#, but I guess pragmas are the same thing, yeah?
12:51:51 <solV3d2> but stioll wrong :D
12:52:35 <monochrom> "xor sum1 sum2" should be simply "sum2".
12:52:59 <solV3d2> oh yes jeez
12:53:45 <solV3d2> works :d thank you
12:53:54 <solV3d2> what a simple full adder now
12:55:36 <solV3d2> can i create my own type?
12:56:13 <solV3d2> oh yes seems straight forward
12:56:20 <solV3d2> type Tuple = (Bool, Bool)
12:56:40 <c_wraith> that must be the most misleading keyword in the language.
12:56:44 <ggVGc> haha
12:56:45 <ggVGc> yes
12:56:49 <c_wraith> type creates an alias, not a type
12:56:51 <ggVGc> c_wraith: I've thought the same thing many times
12:58:16 <c_wraith> at least it does create an entry in the type namespace?  It isn't 100% wrong.
13:02:35 <nshepperd> it creates a type that is equal to another type
13:02:56 <nshepperd> rather than
13:03:01 <nshepperd> isomorphic!
13:16:10 <ertes-w> is the concurrency bug in unordered-containers still present?
13:17:27 * ertes-w . o ( type Seven = (Bool, Bool) )
13:18:09 <iqubic> ertes-w: That's not seven. That's 2
13:18:39 <c_wraith> Um.  It's 4
13:19:01 <ertes-w> actually it's Ten
13:19:04 <callmecabman> It's 10 if you count bottoms
13:19:27 <erisco> why is there "other modules", grr
13:20:47 <callmecabman> Is there anybody who knows Haskell reasonably well and wants to tell me about _teaching_ Haskell to newbies?
13:21:12 <maerwald> inb4 the how to teach monads discussion xD
13:21:12 <c_wraith> teaching haskell is hard.  I don't know of any scalable way to go about it.
13:22:32 <c_wraith> The only way I've done it effectively is just 1-1 answering questions and proposing further directions of investigation.  And that requires a self-motivated learner.
13:23:11 <erisco> why can't I be allowed to import internal modules and shoot myself in the foot
13:23:50 <earthy> depends on how much previous exposure they've had
13:24:35 <earthy> teaching haskell to total newcomers is actually easier
13:24:59 <barrucadu> I wonder if it would be better if cabal files had "public-modules" and "internal-modules", where the PVP only applied to "public-modules", Hackage displayed the two groups separately, and there was an optional GHC flag to warn when you import an "internal-module".
13:25:37 <barrucadu> it would be better than the current situation of packages having modules called Foo.Internal with a comment at the top to the effect of "By the way, we might break this without a major version bump"
13:25:55 <maerwald> but that is still the decision of the lib maintainer
13:26:02 <maerwald> if you make it global, you expose a lot more stuff
13:28:44 <erisco> I can rip apart their code if I want to... it is just annoying now
13:30:49 <callmecabman> Thanks people. I've got a 3-man group whose background is quite diverse (total newbie, sysadmin and C# programmer). For now I'm bothered by the fact that only one of them has got a good math exposure. Not that I say it's impossible to program without math but my own experience tells me that several years of math radically change Haskell from impenetrable to really natural.
13:30:52 <iqubic> How does (Bool, Bool) = 10 or 7?
13:31:14 <erisco> I get 10
13:31:47 <callmecabman> (And not writing in C for some years helps too, lol)
13:31:48 <iqubic> How?
13:31:48 <erisco> or 4
13:31:58 <mnoonan> 3*3 + 1
13:32:00 <erisco> trying to get 7 but I'm not sure
13:32:20 <iqubic> (T, T) (T, F) (F, T) (F, F)
13:32:37 <mnoonan> {T,F,bottom}
13:32:38 <erisco> now include bottom
13:32:46 <barrucadu> (_|_, _|_), (_|_, F), (_|_, T), (F, _|_), (T, _|_), _|_
13:33:10 <barrucadu> Not sure about 7
13:33:27 <iqubic> barrucadu: Add the 4 with no bottom and you get 10
13:33:38 <barrucadu> Yeah
13:34:10 <ertes-w> callmecabman: i'm holding an annual haskell workshop, but the scale is very small, 10-15 people
13:34:54 <ertes-w> callmecabman: this may not be very helpful, but there are many approaches to teaching haskell, and you need to find one that suits you…  took me a few of those workshops to find mine
13:35:33 <ertes-w> callmecabman: my approach is to quickly get them to a point where they can write programs that do stuff (i.e. explain IO *very* early), then introduce the fancy stuff
13:36:48 <callmecabman> ertes-w: is it supposed to motivate them? I mean immediate results are worth more than theory?
13:36:58 <ertes-w> callmecabman: yes
13:37:06 <ertes-w> callmecabman: but other teachers will disagree
13:37:54 <ertes-w> my rationale is that IO alone is worth the ride, because the way haskell does traditional control structures is already very refreshing
13:38:55 <ertes-w> and it gets them to actually do stuff…  many learners get to a plateau of procrastination, where they solve PE problems, learn fancy theory, etc., but never actually do anything with it
13:39:12 <ertes-w> and that plateau is massive =)
13:40:23 <solV3d2> i am confused, i am trying to code some more adders
13:40:34 <solV3d2> a half adder is a 2 bit adder, a full adder adds three bit
13:40:52 <solV3d2> now i see a ripple carry adder containing 3 full adders
13:41:02 <solV3d2> but it says "3 bit ripple carry adder "
13:42:14 <solV3d2> oh wait, it is a 3 bit adder because it adds two three bit numbers
13:42:45 <callmecabman> ertes-w: and when's the time when you can say "stop! I solved a bunch of PE problems, learned the theory and made a couple of microprojects. Let's rock!"
13:43:07 <solV3d2> sorry, is there a general IT channel? i dont want to post that offtopic questions
13:43:39 <Tuplanolla> We have #haskell-offtopic, but it is plenty more than just that, solV3d2.
13:43:51 <solV3d2> cool :)
13:43:54 <ertes-w> callmecabman: hmm?
13:45:37 <solV3d2> but i also have some haskell questions
13:45:50 <solV3d2> i have a type Nibble (bool, bool, bool, bool)
13:46:03 <solV3d2> inside my function, how do i access the third value for example
13:46:42 <solV3d2> i guess i could do rca (a1, b1, c1, d1) (a2, b2, c2, d2)
13:46:52 <geekosaur> thirdN (_,_,a,_) = a
13:46:52 <callmecabman> ertes-w: how to stop hobbying in Haskell and start working in Haskell or something along these lines
13:47:05 <solV3d2> thanks geekosaur
13:47:07 <geekosaur> but, once you get to more than two, it's usually easier to use record syntax instead
13:47:18 <solV3d2> record syntax is what i did?
13:47:31 <iqubic> solV3d2: No, it isn't/
13:47:35 <solV3d2> ok ^
13:47:37 <geekosaur> data Nibble a = Nibble {n1 :: a; n2 :: a; n3 :: a; n4 :: a}
13:47:43 <iqubic> Record syntax is that ^^^
13:47:55 <ertes-w> callmecabman: as i said, i wouldn't make them start in the first place =)
13:47:56 <geekosaur> now n3 is a function from a Nibble to its third element
13:48:02 <solV3d2> thanks!
13:48:31 <iqubic> And then you can pattern match on that like this: (n1=x, n3=y) and get just what you care about.
13:49:08 <iqubic> Am I right in that pattern matching syntax? I forget how to do stuff with records sometimes.
13:49:17 <geekosaur> you need the constructor, and braces
13:49:19 <ertes-w> callmecabman: haskell is the kind of language, where after a long journey through a dark jungle you discover that rabbit hole that takes you to a massive wonderland
13:49:33 <mohsen_>  /quit
13:49:44 <geekosaur> with RecordFieldPuns you can compact it even more: foo (Nibble {n1, n3}) = ... stuff using n1 and n3 ...
13:49:50 <ertes-w> callmecabman: you might never find your way out of there =)
13:49:54 <iqubic> Oh, so Nibble {n1=x,n3=y}
13:51:03 <geekosaur> er, NamedFieldPuns
13:51:23 <Jimmy_> hey guys, I'm trying to use the fromRight function in Data.Either module
13:51:26 <monochrom> No, after the long dark journey you find out why you flunked highschool algebra.
13:51:39 <Jimmy_> even thought I've imported the Data.Either module
13:51:54 <Jimmy_> when I try to use fromRight or fromLeft, it says variable not in scope
13:52:07 <Jimmy_> I can use other functions in the module except those two
13:52:24 <callmecabman> ertes-w: You're kinda right. In fact I haven't find the way out for sure. But this way was neccessary because I learned a hella lot of stuff that helps in general.
13:52:26 <geekosaur> what ghc version?
13:52:29 <c_wraith> Jimmy_: I'd strongly recommend against using those anyway.  They usually are a sign you're doing something wrong
13:52:32 <geekosaur> more specifically, what version of base?
13:52:42 <geekosaur> "Since: 4.10.0.0"
13:53:06 <c_wraith> that's ghc 8.2, iirc
13:53:28 <monochrom> This is why you should read the locally installed doc that comes with GHC rather than searching on the web.
13:53:31 <Jimmy_> base-4.10.0.0
13:53:33 <callmecabman> iqubic: you can also try RecordWildCards, I personally used it a lot
13:53:39 <monochrom> Nothing says Google knows which version you're using.
13:53:54 <ertes-w> callmecabman: i found a way to travel in and out of the rabbit hole at will…  and that is influencing the way i teach =)
13:54:06 <monochrom> And even though NSA does, they aren't telling Google.
13:54:26 <c_wraith> oh, fromLeft and fromRight are equivalent to fromMaybe, not fromJust
13:54:30 <c_wraith> That's confusing
13:54:38 <c_wraith> But hey, they aren't awful to use!
13:55:24 <monochrom> Interesting, I didn't notice that.
13:56:13 <c_wraith> Jimmy_: are you 100% sure the environment you're compiling in matches the environment you're querying versions of base in?
13:56:55 <monochrom> Well the experiment outcome says 100% sure "no".
13:57:12 <monochrom> Observation trumps imagination.
13:57:49 <Jimmy_> c_wraith: I am not. I compile using stack. Then I use stack ghci to interactively try to access an Either value
13:58:25 <Jimmy_> the Either value is generated from a Servant request 
13:58:32 <monochrom> Well then if it's also LTS then you simply don't have access to 8.2.1 or 4.10.0.0
13:58:49 <monochrom> At present only the nightly resolvers have them.
13:58:58 <c_wraith> I would suggest looking very closely at what stackage release your stack.yml points to
13:59:13 <monochrom> God and Stack work in mysterious ways.
13:59:34 <c_wraith> err, what resolver it points to.  there we go.  terminology
13:59:45 <solV3d2> is there some kind of IDE for haskell
13:59:58 <monochrom> God and Stack does everything for a purpose. If they inflict an obstacle on you, it is for learning a lesson.
14:00:01 <callmecabman> of course. Try vim
14:00:01 <solV3d2> prelude just hangs with some error, i have no idea whats going on
14:00:42 <geekosaur> most people use vim or ecs with their respective haskell modes (for emacs at least there are several, form the relatively basic one included in emacs packaging to things like intero and dante)
14:00:47 <monochrom> Prelude doesn't hang. Prelude isn't even an executable.
14:00:53 <Jimmy_> c_wraith: It's pointing to lts-9.5
14:01:02 <c_wraith> Jimmy_: holy crap, that's ancient
14:01:14 <Jimmy_> c_wraith: :(
14:01:17 <c_wraith> Err.  wait, no.  I'm bad at math
14:01:20 <monochrom> Unless you're referring to an old Honda model.
14:01:20 <c_wraith> It's not ancient.
14:01:43 <geekosaur> there have been past attempts at traditional IDEs but they hagve problems keeping up, and not even necessarily with Haskell: there was a VS plugin years ago whose author gave up trying to keep up with Microsoft's constant changes to VS
14:01:56 <c_wraith> Jimmy_: https://www.stackage.org/lts-9.5
14:02:04 <c_wraith> Jimmy_: that says ghc 8.0.2
14:02:05 <solV3d2> well something is hanging
14:02:23 <geekosaur> is it hanging or is it bytecode-compiling your whole project?
14:02:23 <c_wraith> Jimmy_: and base 4.9.1.0
14:02:34 <monochrom> c_wraith: AFAIK all existing LTS's are still 8.0.2 or older
14:02:41 <solV3d2> oh i declared a variable twice
14:02:57 <geekosaur> I think you can get stack to run ghci with -v ("stack ghci -v" is not it) so you can see it loading and compiling modules, if that is what it's doing
14:03:06 <c_wraith> solV3d2: oh.  so you created a value that depends on itself, so takes forever to evaluate?
14:03:08 <geekosaur> stakc ghci tries to bring your whole project in scope, so it is likely to be doing that
14:03:23 <solV3d2> c_wraith ya^
14:03:56 <c_wraith> monochrom: sure, but I figured a link to the exact contents of the resolver would help
14:04:05 <monochrom> Yeah
14:04:27 <Jimmy_> c_wraith: so should I point to a nightly resolver?
14:04:39 <Jimmy_> like monochrom pointed out
14:05:42 <monochrom> Iff one of those nightly resolvers doesn't break something else you care.
14:07:42 <solV3d2> type Nibble (bool, bool, bool, bool)
14:07:51 <solV3d2> rca :: Nibble -> Nibble -> Nibble + One more bool
14:08:08 <callmecabman> (Nibble, Bool)?
14:08:15 <solV3d2> that was my q
14:08:19 <Jimmy_> monochrom: Any other suggestions for extracting a left or right value?
14:08:28 <monochrom> solV3d2: I have a feeling you are heading towards http://lpaste.net/355306
14:08:49 <solV3d2> noooo :
14:08:59 <solV3d2> heres mine :D  http://lpaste.net/358756
14:09:10 <solV3d2> but (Nibble, Bool) does not work as i expected, hm
14:09:16 <monochrom> Anyway, type Nibble = (Bool, Bool, Bool, Bool)
14:09:20 <solV3d2> (Bool, Bool, Bool, Bool, Bool) is ugly
14:09:41 <monochrom> In other words you forgot "=" and you goofed up capital letters.
14:10:08 <monochrom> At some point someone needs to remind you a prerequisite for programming is attention to details.
14:10:08 <solV3d2> yes
14:10:35 <solV3d2> that was just me writing it here too fast, i did not copy it from my code sorry
14:10:45 <monochrom> OK so problem solved.
14:11:11 <solV3d2> hm
14:11:30 <solV3d2> it works, but my i still find it ugly rca :: Nibble -> Nibble -> (Bool, Bool, Bool, Bool, Bool)
14:11:37 <monochrom> Shouldn't it be (s4, s3, s2, s1, ca4)?
14:11:42 <callmecabman> ^
14:12:00 <solV3d2> i dont think so
14:12:12 <solV3d2> let me double check
14:12:13 <monochrom> At any rate you seem to be pretty inconsistent in bit orders anyway.
14:12:22 <solV3d2> why?
14:12:33 <monochrom> Sometimes you put MSBs on the left, sometimes on the right.
14:12:50 <solV3d2> 0100 in variables is dcba
14:12:51 <callmecabman> Can you please elaborate on your expectations about (Nibble, Bool) and your function?
14:13:08 <monochrom> Today I happen to have had enough sleep so I can track all your intertwinning bit network in my head perfectly.
14:13:15 <monochrom> But this is disaster waiting to happen.
14:13:25 <solV3d2> i am sorry :D
14:14:28 <monochrom> Oh, it shouldn't be (s4, s3, s2, s1, ca4) either. More like ((s4, s3, s2, s1), ca4)
14:14:50 <monochrom> Yeah attention to details. ((x,y,z),t) is not (x,y,z,t).
14:15:14 <callmecabman> (shadow of an isomorphism has flied over)
14:15:50 <solV3d2> oh yes, thanks!
14:16:08 <kakashiAL> when ever I find the time, I would like to spend time with category theory, but to simplify it, is this claim true:
14:16:16 <solV3d2> but i still think its a different order but leave that to me, appreciate your help
14:16:24 <kakashiAL> "category theory is all about composition"  ?
14:16:26 <ertes-w> is there something like ansi-terminal, but for terminal *input*?
14:16:47 <jle`> like...haskeline?
14:17:10 <callmecabman> kakashiAL: kinda ;-)
14:17:16 <nshepperd> category theory is about everything
14:17:36 <monochrom> I think category theory is about commuting diagrams.
14:17:37 <jle`> kakashiAL: it is of course true except for the situations where it isn't
14:17:37 <c_wraith> categories themselves are about composition
14:17:39 <ertes-w> kakashiAL: CT is all about relationships between objects expressed in terms of composable morphisms
14:17:48 <jle`> kakashiAL: i'm not sure if it's a "useful" way to look at it
14:17:56 <ertes-w> jle`: lower level
14:17:56 <monochrom> Or their equivalent equations.
14:18:06 <callmecabman> "general theory of structures" (c) Bartosz
14:18:14 <kakashiAL> I did read that cetegory theory is more lower level than set theory
14:18:37 <isBEKaml> callmecabman: Bartosz Milewski? First time I'm seeing something from him here :-)
14:18:38 <ertes-w> jle`: i'm looking for a library like ansi-terminal, but with input sequences
14:18:47 <monochrom> "structure" is right but few people know what those mathematicians mean by "structure".
14:19:19 <monochrom> And God forbid you start imagining a dinosaur skeleton and think that's what Bartosz mean by "structure".
14:19:21 <monochrom> NO.
14:19:22 <callmecabman> kakashiAL: in math some things can be explained either way so the question of "lower" and "higher" is void here IMO
14:19:33 <kakashiAL> monochrom: and people dont like to share it or to simplify it to make to more accessable to more people :(
14:20:52 <monochrom> Mathematicians' "structure" means there are distributive properties like "f(x+y) = f(x) + f(y)" and commuting properties like "g (h x) = fmap f (k x)". So commuting diagrams or the equations they stand for.
14:21:16 <callmecabman> isBEKaml: his blog and lectures are quite impressive. Actually they're a bit below Catsters but much more intuitive for programmers.
14:21:27 <ertes-w> kakashiAL: do you understand monoids?
14:22:01 <isBEKaml> callmecabman: yeah, I should spend some time reading through his blogs. I get a weekly update on his blogs, but no time :-(
14:22:11 <kakashiAL> monochrom: a structure in math is a set of elements, operations and what you can do with the elements and the operations(functions)
14:22:36 <kakashiAL> ertes-w: I know it from group theory
14:22:49 <ertes-w> kakashiAL: do you understand monoid morphisms, too?
14:24:15 <kakashiAL> didnt spend time with it, but if its a mprphism, it mens that f(a*b) = f(a) * f(b), and that its mapping keeps the structure (inverse element maps to inverse and such)
14:24:50 <monochrom> kakashiAL: If that were all there were to it, Bartosz wouldn't be saying "general theory of structures" of category theory. He would be saying it of universal algebra instead.
14:24:53 <callmecabman> I'd say structure is a delicate topic and the oversimplifications are detrimental to proper understanding.
14:24:57 <jle`> dinosaur skeletons form a category where the objects are joint shapes and the morphisms are bones or skeletons
14:25:04 <jle`> assuming that you can synthesize an identity bone
14:25:06 <callmecabman> If you have spare time please visit https://ncatlab.org/nlab/show/stuff%2C+structure%2C+property
14:25:16 <ertes-w> kakashiAL: you only need (∀ x y, f(x ∘ y) ≡ f(x) ∘ f(y)) and (f(id) ≡ id)
14:25:18 <c_wraith> jle`: the identity is the size-0 bone
14:25:53 <jle`> ah yes of course
14:25:55 <kakashiAL> ertes-w: nice, but I dont see what we can do with it and why people say that you can make algorithms faster and such :(
14:26:04 <monochrom> In reality, if you look at math text and spot someone writing "this has/shows very interesting structure", it invariably is because "because log(a*b) = log a + log b" or some such commuting diagram/equation.
14:26:10 <ertes-w> kakashiAL: now visualise monoids as a large object and the elements of the monoid as arrows extending from that object and bending back to it
14:26:34 <kakashiAL> ertes-w:  A -----> B     done :)
14:26:52 <jle`> A --+
14:26:56 <jle`>     |
14:26:59 <jle`> ^---+
14:27:04 <jle`> aw so close
14:27:12 <ertes-w> kakashiAL: now categories are monoids on steroids: they allow multiple such objects, and functors are monoid morphisms on steroids: they are the same concept, but for categories
14:27:14 <kakashiAL> jle`: identity mapping :)
14:27:19 <ertes-w> kakashiAL: perhaps that helps you =)
14:27:20 <jle`> kakashiAL: not necessarily identity mapping
14:27:36 <jle`> kakashiAL: what ertes-w was describing was one object and multiple arrows
14:27:39 <jle`> you drew two objects and one arrow :o
14:28:03 <c_wraith> kakashiAL: monoids don't make anything faster.  They sometimes inspire people to examine alternate solutions that are faster, when they say "hey, what if I think of this as a monoid?"
14:28:03 <ertes-w> it would be easier if i had a whiteboard
14:28:13 <jle`> the monoid looks more like loose ball of yarn, with threads exiting and re-entering
14:28:17 <kakashiAL> okay, so far so good, but do you know maybe some REAL WORLD example where category theory helped us?
14:28:26 <kakashiAL> in programming or such
14:28:34 <monochrom> ertes-w: I have learned monoids from catsters. Now where can I learn steroids?  <duck>
14:29:06 <callmecabman> kakashiAL: of course. Kan extensions are used in program optimization
14:29:10 <ertes-w> kakashiAL: haskell has a large collection of such examples, but to understand the categorical foundation you need to understand the basics first
14:29:19 <ertes-w> heh
14:29:51 <fishythefish> kakashiAL says they know group theory; why don't we start with Grp or Ab as a motivating example?
14:30:31 <kakashiAL> ertes-w: I would like to have some kind of motivation, like "you have a list of one million users, and you want to filter foo, and because of cateory theory, we can do it ultra fast and this is why"
14:30:45 <ertes-w> kakashiAL: in essence CT is a formal language…  it's a framework that lets us observe similarities between different mathematical fields
14:31:13 <ertes-w> that's why it's not easy to come up with "use" cases for CT
14:31:36 <ertes-w> but of course all group theory concepts are also categorical concepts
14:31:36 <kakashiAL> ertes-w: I also did read that, and also that CT did show us connections between field that we would never see/guess that there are there
14:31:39 <ertes-w> it's a generalisation
14:31:56 <fishythefish> kakashiAL category theory on its own is just a framework for understanding math. It doesn't automatically speed stuff up. Groups are the same way.
14:32:24 <ertes-w> kakashiAL: one concept from category theory is free monads…  they are great for creating domain-specific languages
14:32:27 <nshepperd> When one knows monoids, one naturally says "why of course, an algorithm for 'scanlmap :: (Monoid m) => (a -> m) -> [a] -> [m]' in log n time with unlimited parallism is the easiest thing in the world"
14:33:04 <ertes-w> kakashiAL: but you see, we're back to *language*…  it's always about language…  rarely will you see an actual proof or algorithm come out of CT
14:33:14 <nshepperd> (err, with vectors rather than lists, of course)
14:33:26 <fishythefish> Homomorphisms on their own don't let you do anything new, but one day you might observe that you're doing a bunch of expensive operations in a group and then applying a homomorphism, but perhaps applying the morphism first instead lets you do a bunch of cheap operations in the other group.
14:33:33 <monochrom> What does "real world" mean?
14:33:44 <ertes-w> kakashiAL: the point is that CT made free monads visible to us…  they are a categorical concept we may have never found without CT
14:33:47 <fishythefish> monochrom it's the thing that lets IO work ;)
14:34:16 <callmecabman> fishythefish: hit the bull's eye. read FFT and stuff if talking practical
14:34:44 <kakashiAL> ertes-w: let me ask it this way
14:34:50 <kakashiAL> ertes-w: lets say we have this:
14:35:04 <kakashiAL> A -----> B -----> C -----> D
14:35:35 <kakashiAL> with CT it will help you to find the shortest way from A to D, can you say that?
14:35:53 <ertes-w> kakashiAL: no
14:36:21 <monochrom> I asked what "real world" means because so far you have demonstrated that your "real world" means only very basic and mundane jobs.
14:36:25 <ertes-w> kakashiAL: again: CT is not about algorithms…  sometimes it's about data structures, but in a very general setting
14:36:46 <fishythefish> again, Grp or Ab might be a good starting example
14:37:19 <monochrom> In my real world, however, the existing or soundness of recursively defined data types is of higher importance, and the most well-known proof does it in category theory.
14:37:38 <ertes-w> kakashiAL: here is a practical application: you want to understand and manipulate a theoretical concept…  if you can express that concept in terms of CT, a whole world of existing knowledge opens up for you to use
14:38:14 <ertes-w> kakashiAL: you can use CT to translate problems into other languages, solve them there, then translate back
14:38:24 <ertes-w> you can use CT to talk about expressivity and generality
14:38:26 <monochrom> If you're just going to limit yourself to basic mundane tasks, you will not find a convincing application of category theory, or pretty much any theory. You may go home now.
14:38:50 <ertes-w> kakashiAL: however, it will not help you in any way to come up with a better sorting algorithm
14:38:52 <kakashiAL> ertes-w: I know what you mean :)
14:39:00 <fishythefish> kakashiAL group theory does the same thing: it presents a single unifying theory of all sets satisfying the group axioms so that you only have to prove things once
14:39:04 <monochrom> At any rate #FirstWorldProblem
14:39:15 <fishythefish> it turns out we can similarly unify many structures with the concept of a cateogry
14:39:17 <fishythefish> category*
14:39:28 <nshepperd> category theory teaches you about free monads. now you can program all sort of great things in embedded DSLs. But then you say "my free monad is too slow to use (>>=) and fmap :(". And category theory says "have Codensity! it gives your code an asymptotic speedup!"
14:39:36 <monochrom> People in Africa struggling to get food are not going to need category theory either.
14:39:46 <nshepperd> and then you invent lenses
14:39:54 <nshepperd> and before you know it you've ascended
14:39:58 <kakashiAL> ertes-w: you mean if you find a morpthism between two fields, you can find the maximum in field A and because you have a morpthism, you automaticaly have the maximum of B
14:40:32 <ertes-w> kakashiAL: perhaps, but you will more likely find a concept that captures the essence of what "maximum" means
14:40:41 <ertes-w> and that concept becomes accessible to a lot of theories
14:40:59 <ertes-w> (in fact such concepts already exist, and you can start using them)
14:41:32 <ertes-w> kakashiAL: this is really a difficult question…  in some way haskell is a giant application of CT
14:41:51 <ertes-w> but at the same time CT only gave us ideas
14:42:01 <callmecabman> kakashiAL: CT 101. 1) Learn CT. 2) Implement all the obscure concepts. 3) ??? 4) You're Edward Kmett.
14:42:24 <monochrom> The journey is more important than the destination.
14:42:33 <monochrom> Because very likely you won't make it anyway.
14:42:59 <kakashiAL> ertes-w: do you know the simpliest haskell datastructure that you want to manipulate and that you can solve better/solve easiert because of CT, which shows the power of CT ?:)
14:43:57 <ertes-w> it's a long journey, and only when you reach infinity-groupoid city will you fully understand…  but that requires you to pass the coyonedan border, and that's the point of no return
14:44:26 <ertes-w> kakashiAL: every free monad i define is a product of CT knowledge =)
14:45:46 <kakashiAL> ertes-w: I only see map/flatmap :/
14:46:45 <monochrom> The simplest Haskell datastructure I know how to use CT on is "forall a. a -> a".
14:47:00 <monochrom> Let k :: forall a. a -> a.
14:47:28 <callmecabman> ertes-w: btw Haskell reflects some ideas back into CT. I don't think applicative functors were of much interest before.
14:48:09 <kartiksabharwal> ssh amazon
14:48:13 <kartiksabharwal> q
14:48:25 <kakashiAL> I see that and understand the functions, but for me its just something with a lable on :)
14:48:35 <monochrom> Then category theory gives the following commuting diagram: (f :: A->B) . (k :: A->A) = (k :: B->B) . (f :: A->B)
14:48:42 <edwardk> callmecabman: i still have more to implement! =)
14:48:55 <monochrom> From this I can deduce "k x = x, for all x".
14:50:09 <callmecabman> edwardk: I tremble before the prophet. Have my respect, sir.
14:50:20 <edwardk> callmecabman: andrej bauer has a nice story about how he had a big time russian set theorist show up at the university there in ljubjana... and the guy spent 2 days of lectures building up a construct laboriously in set theory.... which turned out to just be a particular applicative functor
14:52:36 <kakashiAL> ertes-w: programmers like haskell and functional programming becomes more and more important, well I would say because most of the time its very declarative and you can produce a linear data flow
14:53:24 <kakashiAL> but that cant be all, sure...having minimum of state, no mutation and such
14:54:52 <ertes-w> BTW, i'll be in ljubljana on saturday
14:55:00 <ertes-w> but i won't have time to visit sadly =/
14:57:18 <callmecabman> edwardk: No wonder... I am really sad that CT has no academical support here in Russia (at least I haven't seen in NSU). Now I do translate Bartosz' lectures for those people who can't read MacLane...
14:58:02 <kakashiAL> stupid question
14:58:13 <kakashiAL> but for what do you guys use haskell for most of the time?
14:58:31 <monochrom> CT is too easy. People aspire to do epsilon-delta management and solve the Riemann conjecture instead. Or do rocket math.
14:58:46 <monochrom> I mean just look at Terrance Tao  <duck>
14:59:25 <monochrom> For writing Haskell tutorials.
15:04:25 <nshepperd> kakashiAL: all sorts of things. it's a general purpose language
15:05:17 <kakashiAL> how does facebook using it?:/
15:05:23 <kakashiAL> for what tasks?
15:06:09 <nshepperd> I do all sorts of machine learning and statistical inference experiments. I also have a raspberry pi running a haskell program that controls my lights and lets me control it over the internet
15:06:09 <Tuplanolla> The unethical parts, kakashiAL.
15:06:09 <callmecabman> kakashiAL: their spamfilter is written in Haskell
15:07:51 <nshepperd> I also have a haskell program that runs on a server and sends me an email when some rss feeds are updated
15:11:25 <benzrf> monochrom: first of all, it's terrence
15:11:38 <benzrf> kakashiAL: i use haskell for fucking around ^_^
15:11:47 <Tuplanolla> No, it's Terence, benzrf.
15:11:54 <benzrf> Tuplanolla: fuck i self-owned
15:12:04 <boj> kakashiAL: i'm using it to write software which provisions network devices for a telecom
15:12:58 <callmecabman> boj: oh boy here we go (pun intended)! Can you please tell me more about it?
15:13:34 <kakashiAL> callmecabman: so they use haskell as a (micro)service?
15:14:20 <boj> callmecabman: what would you like to know?
15:16:38 <callmecabman> kakashiAL: I can't say for sure. They have a rule engine called Sigma. It fires on every event so probably it's a service yeah.
15:18:18 <boj> well theen
15:18:28 <callmecabman> boj: I used to work in a small telco and provision was a freaking nightmare. Swapping a Juniper EX3200 to a Cisco Nexus was painful asf
15:18:47 <boj> ah yes
15:19:16 <callmecabman> boj: so I had to research a bit and SaltStack was chosen
15:19:58 <zachk> monochrom , erisco , do you have a link to custom list type for composing list of composes that we were talking about the other day?
15:20:21 <callmecabman> boj: but the idea of declarative configuration already fired up something in my brains "hmm maybe I should invent some bicycles in Haskell so these fuckers will regret their technical debt after I leave"
15:21:34 <erisco> zachk, I don't have the link anymore but it wasn't that interesting anyways
15:22:03 <zachk> was it workable? I think I reinvented arr so far 
15:22:16 <monochrom> zachk: http://lpaste.net/browse?author=erisco  The first two look like it
15:22:20 <callmecabman> boj: what did you want when you designed it? what range of functions?
15:22:43 <erisco> oh they just have a history of me like that? lol
15:22:50 <monochrom> "The Complete Work of Erisco"  XD
15:23:49 <boj> callmecabman: sorry, i blew my desktop up. the kind of provisioning i am doing isn't what you'd use chef/salt/ansible for. it's talking to the actual network devices out in neighborhoods (adtrans for example) and turning on people's internet links
15:24:06 <monochrom> Including a "Für ertes-w" analogous to Beethoven's "Für Elise"
15:24:23 <erisco> huh.. that stuff 8 years ago may have been me but I really have no idea
15:24:47 <erisco> then there is a bunch in-between where I didn't have my username entered
15:28:16 <callmecabman> boj: anyway it's interesting (because I like both Haskell and sysadm)
15:30:59 <boj> callmecabman: haskell has been quite useful for things like parsing streaming telnet input, and being general purpose all of the other usual things (reading yaml configs, serving up an API, talking to a db)
15:39:12 <eacameron> Can you guys recommend a good resource pool library? I see resource-pool but it hasn't been released since 2014!
15:39:28 <eacameron> Maybe that's fine
15:39:54 <boj> eacameron: pool
15:40:07 <boj> oh
15:40:23 <boj> deprecated in favor of resource-pool - i had not noticed that
15:41:22 <boj> which i am apparently using even
15:41:32 <boj> eacameron: it works great :)
15:41:46 <eacameron> Yeah resource-pool seems to be *the* go-to pooling lib
15:41:47 <Zabot> If I specify a function type as function :: a -> b -> a. Can a and b be the same type. Also could a tuple be the type of b?
15:42:12 <Zabot> Whenever I change one of my parameters from x to (x,y) I get type errors
15:42:26 <barrucadu> With a polymorphic function, the caller gets to decide what the concrete type is
15:42:46 <barrucadu> So if your type variable is just 'b', you can't treat it as a tuple, because the caller might pass an Int (for example)
15:43:11 <Zabot> Its the other way around. The function treats it as a b and the caller passes a tuple
15:43:22 <Zabot> But I still get type errors
15:43:34 <eacameron> Zabot: The only possible implementation of that function (aside from throwing an error) is to toss out the second argument and return the first.
15:43:35 <barrucadu> Then that should be fine.  Could you share an example where it's going wrong?
15:43:42 <barrucadu> @where lpaste
15:43:42 <lambdabot> http://lpaste.net/
15:43:54 <Zabot> Specifically its the value to insert into a map
15:44:28 <Zabot> I have a tuple where the first element is the key and the second is the value
15:45:00 <Zabot> It works when I use a single element for the value, but if I use a tuple for the value, it complains
16:07:33 <zachk> erisco, monochrom , I got it working with GADTs (the foldr compose list thing) http://lpaste.net/358757
16:09:09 <monochrom> Yikes, I have a "eval.cabal" file of size 666.
16:09:26 <HaskellLord69> praise baelzebub
16:09:38 <monochrom> Maybe I should rename it to "evil.cabal".
16:10:23 <zachk> are GADTs more powerful then type families, or are they overlapping, or unrelated?
16:11:06 <geekosaur> orthogonal, I'd say. some classes of programs could be solved by either, others are best solved with one or the other
16:11:39 <geekosaur> and, while I don't recall if ghc currently allows this, a type family instance could potentially be a GADT
16:11:53 <iqubic> zachk: unrelated
16:26:34 <woodson> Hi everyone, I am trying to install ghcjs to toy a bit with it since this morning, but i keep getting this error message
16:26:46 <woodson> Not in scope: data constructor ‘FlagName’
16:27:24 <woodson> and thats from this file "/tmp/cabal-tmp-23693/ghcjs-0.2.0/dist/setup/setup.hs:60:6:"
16:28:17 <woodson> I am just following the guide from this github repo https://github.com/ghcjs/ghcjs
16:31:40 <zachk> any idea how to get a take function on my new functionList defined? http://lpaste.net/358757
16:41:13 <monochrom> I don't think it's doable. You've basically lost the types of the functions in the middle of the list, and now funTake suddenly needs that information.
16:42:08 <monochrom> In particular "FunCons :: (Fun b c) -> FunList a b -> FunList a c" means that the "b" there is under existential quantification.
16:42:13 <michalrus> Why doesn’t MonadIO imply MonadCatch?
16:42:30 <monochrom> Because MonadIO is too general.
16:42:36 <michalrus> WHy is it useful, if IO can always throw?
16:42:41 <michalrus> Uh, so it’s wrong?
16:42:53 <monochrom> No, that's putting words into my mouth.
16:42:58 <michalrus> :P~
16:43:17 <monochrom> I will say no more to people who jump to conclusions on the slightest pretext.
16:43:25 <michalrus> Forgive me.
16:43:27 * michalrus bows
16:44:56 <monochrom> I always throw but I certainly don't always catch. You are mixing up throwing and catching.
16:45:34 <michalrus> So it’s useful to mark “this function will not catch anything”? Hmmm.
16:45:45 <michalrus> I might want to know that sometimes, I guess… ¯\_(ツ)_/¯
16:46:40 <geekosaur> MonadIO does one thing, which is not the thing you want
16:46:54 <zachk> monochrom, do you think it would be doable with dependent types? because the return type of funTake would depend upon the value of the Integer passed to it.
16:47:17 <monochrom> I don't know.
16:47:23 <zachk> :(
16:47:27 <michalrus> OK, thank you, both!
16:47:40 <geekosaur> that one thing happens to be quite simple.
16:47:49 <monochrom> I think here is what's going to happen.
16:47:51 <geekosaur> exception handling, it turns out, is not simple
16:48:35 <monochrom> Obviously even knowing the actual integer value is not enough. I bet you will realize that you need the types of all functions in the whole list, in the correct order too.
16:48:36 <geekosaur> MonadBaseControl is one mechanism for generalized exception handling without leaking resources. It is NOT simple.
16:48:56 <michalrus> :c
16:49:07 <geekosaur> MonadCatch is eception handling without worrying about leaked resources. It is not as simple as MonadIO, but much simpler than MonadBaseControl. With actual exceptions, it can leak resources
16:49:16 <monochrom> And this is why I'm skeptical about applying dependent typing to, say, programs rich in data structures.
16:49:33 <mniip> geekosaur, leak in what sense
16:49:47 <michalrus> geekosaur: is there any article/blog post on that matter that you would recommend?
16:49:51 <monochrom> You quickly find yourself needing the type to duplicate the value. You can't even summarize. Every summary misses out something you need.
16:50:52 <geekosaur> mniip, catch an exception while setting up a web session that includes a database connection. depending on where it happens and when it is caught, you could be left with a database handle that was not closed properly and sometimes can even be lost from GC finalizing it
16:51:52 <mniip> ah that
16:52:00 <monochrom> Fans of dependent typing are mostly naïve in the following: They saw that a list type with type-level length reminder, as a simple number, is so cool because you know exactly whether "head" is safe or not.
16:52:01 <geekosaur> https://www.schoolofhaskell.com/user/commercial/content/exceptions-best-practices gets at some of this. there are others I'd have to dig up that are more specific about resource leakage and such
16:52:10 <mniip> geekosaur, you mean stuff like 'bracket'?
16:52:20 <michalrus> Thank you!
16:52:27 <monochrom> Problem is it doesn't generalize to binary tree. Or rather, it doesn't generalize the way you think.
16:52:51 <mniip> monochrom, why would you need a type-level length reminder
16:52:59 <monochrom> Using a number for the list length is misleading. It is not a number. It is a list of units that duplicates the spine of the list value.
16:53:02 <mniip> you could pi-quantify the argument
16:53:18 <geekosaur> mniip, things liek nested brackets when building a more complex thing. inner bracket is done, outer bracket catches an exception, but it doesn;t necessarily know if it has the thing from the inner bracket or not
16:53:24 <mniip> head :: pi (xs :: [a]). (xs /= []) -> a
16:53:37 <mniip> or,
16:53:46 <geekosaur> I ... am not doing great today and really need to dig this up, I think
16:53:48 <mniip> or something like tht anyway
16:53:52 <monochrom> So when you generalize to binary tree, you can't just put a tree size at the type level. You have to put the whole bloody tree shape there.
16:54:12 <mniip> monochrom, right, sounds like you're doing the wrong thing
16:54:24 <mniip> dependent types relieve you from singletons
16:54:29 <monochrom> Because the tree size doesn't even tell you shit about whether you have a left subtree at all.
16:54:38 <geekosaur> actually that page I linked to seems to link to and discuss the main points
16:54:55 <monochrom> No mniip, I am doing the right thing. I am speaking against dependent typing.
16:55:21 <geekosaur> bracket itself is not so much the problem, but I touched on it; it's when things become nonlinear so you can't clean them up simply
16:55:39 <monochrom> Or at least speaking against fandom of dependent typing.
16:56:08 <monochrom> It is not me who are thrilled at "Vec 5 Char". It is them.
16:56:12 <mniip> since when has it become a religion
16:56:31 <monochrom> Since there is Internet and there are blogs?
16:56:38 <geekosaur> anything can become a religion, sadly
16:57:02 <monochrom> Soon I will write a blog explaining why programmers religionizes everything in sight.
16:57:41 <geekosaur> it's not just programmers
16:57:56 <mniip> people, what a bunch of bastards
16:57:58 <monochrom> But basically it's an economics argument. All the good talents find better pay outside programming. So programming is basically only more competitive than religious jobs. Just look at Larry Wall.
16:58:21 <monochrom> s/competitive/attractive/
16:58:28 <geekosaur> and it's more fundamental than that. consider climate change discussions
16:59:10 <monochrom> Some for example if you're good at documentation, you get better pay by becoming a lawyer. Now we're stuck with programmers who suck at documentation.
16:59:28 <athan> Can I `unsafeCoerce` a value into a newtype, even though it's data constructor isn't imported or anything?
16:59:35 <athan> er... s/can/should
16:59:59 <monochrom> I also happen to have an IRC friend who finished his math PhD (or not) and then jumped ship to law school and is now a practicing lawyer.
17:00:09 <zachk> monochrom, what pays better then $60k-100k USD, starting?
17:00:27 <monochrom> I don't know.
17:00:47 <monochrom> Pharmaceutical?
17:00:57 <zachk> that was around 100k last I knew 
17:01:03 <monochrom> Wall Street quants?
17:01:47 <monochrom> Because pharmaceutical sucks away all the scientific talent from us, so we're left with unscientific, supertitious, refuse-to-test people.
17:02:49 <monochrom> And Wall Street sucks away all the people who can actually grok parentheses, this is why we see so many "f $ g $ x" and so few "f (g x)" or "(f . g) x".
17:05:37 <monochrom> athan: You can. You shouldn't, you should use the Coercible type class instead, I think it's best of both worlds.
17:06:56 <athan> monochrom: Ahh hm, thank you
17:10:02 <michalrus> `$` is bad style?
17:11:47 <mniip> monochrom, something something groking parentheses and $ https://bpaste.net/show/cfcb38bc860c
17:12:12 <geekosaur> michalrus, according to some, yes
17:12:31 <geekosaur> it's another of those religions imo
17:12:34 <michalrus> OK. (:
17:13:01 <needHelp> hi
17:13:12 <needHelp> are there any tutors here? i need help with a program
17:13:16 <needHelp> i mean a problem
17:13:33 <Guest74676> ?
17:13:34 <boj> throw your question out and we can try to help :)
17:13:37 <monochrom> mniip: Haha neat. I don't understand this code, but I assume the names are telling. So, continuation passing style in makefile?! Haha.
17:13:54 <Guest74676> can someone help me with a problem?
17:14:10 <boj> Guest74676: what is the problem?
17:14:13 <mniip> monochrom, no, that's not really CPS,
17:14:15 <monochrom> And in return I share with you my recent running into http://www.cs.nott.ac.uk/~pszgmh/bib.html#cutting
17:14:26 <mniip> it's just that make has no let-binding and no lambdas
17:14:45 <Guest74676> its a difficult sorting problem
17:15:38 <fishythefish> okay, but what is it?
17:15:55 <monochrom> Don't ask don't tell. :)
17:17:08 <mniip> :t ask >>= tell
17:17:10 <lambdabot> (MonadWriter w m, MonadReader w m) => m ()
17:17:51 <Guest74676> i have to use an anonymous function and sort increasing lists without an accumulator
17:20:18 <fishythefish> those sound like homework requirements, but we still don't know what the problem is
17:20:28 <fishythefish> although if your list is increasing, seems like it's already sorted
17:20:34 <monochrom> :)
17:21:41 <michalrus> But it’s good that someone is giving Haskell homeworks. ♥ My uni started doing that only 2 years ago. :(
17:27:34 <zachk> haskell homework sounds better then java homework
17:29:38 <fishythefish> Guest74676: you may want to look up "difference list"
17:30:38 <Guest74676> thanks! ill check it out
17:37:50 <Guest74676> hello?
17:38:36 <Guest74676> this is the problem: https://nikivazou.github.io/CMSC498V/homeworks/HW2.html , I'm having trouble on optimized ascending
17:40:03 <Guest74676> it's the restrictions that make it difficult for me. I can't wrap my head around how an anonymous function can solve this instead of an accumulator 
17:40:57 <solV3d2> sortA :: [] -> []
17:41:03 <solV3d2> why cant i define such a function ?
17:41:40 <boj> solV3d2: perhaps you want sortA :: [a] -> [a]
17:42:02 <peddie> solV3d2: [] is not a type, it's a type constructor -- do you want Ord a => [a] -> [a] or something?
17:42:19 <solV3d2> i want a function that takes a list of ints and returns a list of ints
17:42:36 <peddie> solV3d2: can you write down the type of a list of ints?
17:42:38 <Guest74676> u can do sortA :: [Int] -> [Int]
17:43:06 <Guest74676> if anyone can help me on my hw problem plz let me know
17:43:21 <boj> Guest74676: you need to ask directed questions
17:43:32 <solV3d2> hm
17:44:48 <peddie> Guest74676: that problem doesn't say anything about anonymous functions as far as I can see . . . ?
17:45:13 <Guest74676> it does ^ are u looking at the optimized ascending?
17:45:43 <peddie> Guest74676: my browser found no occurrences of the word "anonymous"
17:45:47 <Guest74676> I mean it says function application and abstraction (i.e., lambda),
17:46:07 <Guest74676> the second parameter is a function, but since no helper functions can be made it is a lambda 
17:47:37 <peddie> Guest74676: you don't have to define the second argument to that function; you just have to use it.  you don't know and shouldn't care whether it's defined as a lambda or an ordinary function
17:48:33 <Guest74676> well for that definition yea, but i have to figure out the input function for it to work 
17:48:47 <Guest74676> because i have to substitute that for ascending' in sequences
17:49:21 <Squarism> lol. Ive been using lts-6.4 the last 1.5 years. 
17:49:24 <peddie> so you have already defined `ascending'` ?
17:49:39 <solV3d2> sort (x:xs) = ... how can i create a new list das is in form of xs:x
17:49:41 <Guest74676> yea
17:49:42 <peddie> er, sorry, you have already defined `ascending`?
17:49:43 <Guest74676> that was easy
17:49:45 <solV3d2> i cannot just do sort (x:xs) = (xs:x)
17:50:10 <peddie> :t (:) -- solV3d2 
17:50:11 <lambdabot> a -> [a] -> [a]
17:50:29 <solV3d2> ah ok
17:50:40 <Guest74676> ascending' is already defined on that page
17:50:53 <peddie> right, I meant the optimized one, `ascending` without the apostrophe
17:51:00 <Guest74676> no im having trouble on that
17:51:38 <peddie> why not try to define that one and make sure it satisfies the given property before you worry about the argument you'll need later?  maybe it will become apparent what the argument should be once you've written the function
17:51:58 <Guest74676> initially i had a similar function to ascending' except in the recursive call where a < b i do (f (a:bs)) - i call the function on the input list but it doesnt seem to be possible.
17:53:26 <Guest74676> otherwise the first thing that came to my mind is to do a : ascending recursive call, but i get an error because it excepts a [[a]], so trying to combine the increasing list into recursive calls doesn't work
17:53:45 <peddie> Guest74676: sorry, I have to go -- I hope someone else can help you.  but you might have more success if you can ask specific questions in the form of "I tried X and expected Y, but it did Z; can someone help me understand why?"
17:54:02 <Guest74676> i see, thank you though
17:54:29 <peddie> good luck
17:57:48 <solV3d2> sort (x:xs) = if (head xs) < x then sort (xs ++ [x]) else x:(sort xs)
17:57:54 <solV3d2> Exception: Prelude.head: empty list
17:57:56 <fishythefish> Guest74676 did you happen to find info on a difference list?
17:58:00 <solV3d2> how can my list ever be empty :|
17:58:25 <fishythefish> solV3d2: because xs might be empty
17:58:25 <Guest74676> i did look it up on the wiki, but im a bit confused on how id use that
17:58:27 <Axman6> that definitely does not look like it sorts a list...
17:58:53 <Axman6> solV3d2: xs will be empty if the input list is [x]
17:59:03 <Axman6> because xs = []
17:59:10 <solV3d2> ok xs is empty on last recursion
17:59:12 <Axman6> remember that [x] is just x:[]
17:59:33 <fishythefish> Guest74676: do you understand the principle behind it?
18:00:13 <Axman6> solV3d2: in general, you should try to never use head, exactly because it can fail like this
18:00:50 <Axman6> :t partsOf
18:00:51 <lambdabot> Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]
18:01:07 <Axman6> :t partsOf template
18:01:08 <lambdabot> (Typeable a, Data t, Functor f) => LensLike f t t [a] [a]
18:01:11 <Guest74676> could u explain it to me?
18:01:19 <solV3d2> sort (x:xs) = if length xs == 0 then x:xs else if (head xs) < x then sort (xs ++ [x]) else x:(sort xs)
18:01:28 <solV3d2> that seems to be good :))
18:01:46 <solV3d2> oh no its not :D
18:02:02 <solV3d2> ok, will look into that tomorrow, thanks everyone! see ya tomorrow :D
18:02:47 <jared-w> so much if/then/else...
18:03:00 <Axman6> that looks really bad to me... using length to check that your list is [] is pretty dangerous, because xs may be infinite
18:03:07 <Axman6> > length [1..]
18:03:13 <lambdabot>  mueval-core: Time limit exceeded
18:03:22 <Axman6> > null [1..]
18:03:24 <lambdabot>  False
18:03:27 <Axman6> > null []
18:03:30 <lambdabot>  True
18:03:35 <monochrom> It also turns a quadratic-time sorting algorithm to cubic time.
18:03:50 <Axman6> yep
18:04:12 <Axman6> bleh, they're gone
18:04:27 <fishythefish> Guest74676: operations like appending to a list and reversing a list are expensive because you have to traverse to the end of the list
18:04:40 <fishythefish> however, function composition is cheap
18:05:06 <Axman6> > ("test",Just "some more", ["again","1234"]) & partsOf template %~ (reverse :: [Char] -> [Char])
18:05:09 <lambdabot>  ("4321",Just "niagaerom",[" emos","tset"])
18:05:25 <fishythefish> So if we represent each element x of a list as the function (x:) instead, then we can append to a list by just composing in the right order
18:05:51 <fishythefish> Of course, what we end up with is a function of type [a] -> [a] rather than an actual list [a], so we evaluate it on [] to get the list back out when we finally need it
18:06:06 <Axman6> :t (1:) . ([2,3,4,5]++) . (6:)
18:06:07 <lambdabot> Num a => [a] -> [a]
18:06:17 <Axman6> > (1:) . ([2,3,4,5]++) . (6:) $ 
18:06:19 <lambdabot>  <hint>:1:31: error:
18:06:20 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
18:06:22 <Axman6> > (1:) . ([2,3,4,5]++) . (6:) $ []
18:06:25 <lambdabot>  [1,2,3,4,5,6]
18:06:38 <jared-w> You know what grinds my gears slightly? My programming languages professor: His /only/ example of haskell and functional code in his lectures so far is `foldl (flip (:)) []`
18:07:30 <jared-w> It's like he's trying to indoctrinate everyone into thinking FP is "expressive yet useless gibberish" ಠ_ಠ
18:07:57 <c_wraith> at least it's one of the very few cases where foldl isn't wrong?
18:08:50 <Axman6> > ("test",Just "some more", ["again","1234"]) & partsOf template %~ (reverse :: [[Char]] -> [[Char]])
18:08:51 <Guest74676> fishythefish so are u saying 1:2:3: , since i left the colon hanging is a function? i get that 1:2:4... : [] is appending to a list
18:08:53 <lambdabot>  ("1234",Just "again",["some more","test"])
18:08:57 <athan> is `coerce` and `uncoerce` implemented as `unsafeCoerce`?
18:09:12 <hydraz> no
18:09:15 <jared-w> I mean, I guess. But I would've preferred something that really shows off how expressive (yet understandable) haskell can be rather than picking a one-liner that's almost famous for its unintelligibility
18:09:20 <Axman6> > ("test",Just "some more", ["again","1234"]) & partsOf template %~ (reverse :: [[[Char]]] -> [[[Char]]])
18:09:22 <lambdabot>  ("test",Just "some more",["again","1234"])
18:09:22 <athan> ): shoot, is that due to roles?
18:09:27 <hydraz> athan: it's a bit complicated
18:09:33 <athan> hm
18:09:51 <hydraz> yes, it does have to do with roles
18:09:59 <hydraz> lemme dig up the wiki page
18:10:02 <fishythefish> Guest74676: No, I'm saying the function (1:) . (2:) . (3:) represents the list [1, 2, 3] because that's what you get out if you evaluate it on []
18:10:31 <hydraz> athan: https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/coercible.pdf
18:10:32 <fishythefish> Guest74676 so "appending" 4 is as easy as composing (1:) . (2:) . (3:) . (4:)
18:11:55 <Guest74676> fishythefish: Whoa, that seems really neat, and helpful to me. Thanks!
18:12:25 <fishythefish> Guest74676: Note that this allows you to get rid of `reverse` sometimes
18:12:25 <fishythefish> Guest74676: Note that this allows you to get rid of `reverse` sometimes
18:12:56 <fishythefish> e.g. if you receive the values 1 then 2 then 3, you might end up building the list [3, 2, 1] because you just cons values to the accumulated list as you receive them
18:13:38 <fishythefish> however, you could instead start with an accumulator of id by default, then build up (1:) then (1:) . (2:) then (1:) . (2:) . (3:) by composing the right way
18:13:48 <fishythefish> and ultimately, evaluating the result on [] gives you [1, 2, 3]
18:13:50 <fishythefish> no reverse needed
18:14:21 <fishythefish> so if you know you'll need to reverse at the end anyway, you can instead just do this
18:15:33 <Guest74676> fishythefish: That's so much more clear now. Thank you so much! I wish you were my teacher instead haha
18:24:50 <Ojd> hello all
18:32:32 <iqubic> for those that use Emacs to edit Haskell code, what do you consider to be the best packages to use?
18:33:07 <peddie> iqubic: I like to use `containers` and `hmatrix` 
18:33:24 <jared-w> lol
18:33:28 <iqubic> Are those for Emacs?
18:33:29 <peddie> iqubic: but it really depends what you're trying to program
18:33:41 <jared-w> iqubic: I just use intero + haskell-mode with spacemacs more or less
18:38:11 <geekosaur> I just use standard haskell-mode, although I want to look at dante at some point
18:38:45 <geekosaur> ...but then I largely predate IDEs so I never really developed that habit
19:00:54 <jared-w> I was in the weird spot of definitely not predating IDEs yet I used vim for everything about as far as I can remember so I never had this strong compulsion for the IDE to do everything for me
19:01:34 <jared-w> Then I realized that I'm severely ADHD and it's utterly stupid for me to try and program productively without realtime checking of small silly errors I'm prone to constantly making :p
19:01:36 <geekosaur> that's not necessarily weird; just means you never bothered to develop it, whereas I didn't get much choice in the matter :p
19:02:19 <jared-w> So, I'm in this weird limbo where I use spacemacs and I really 'need' linting but I also... don't? Meh.
19:02:35 <geekosaur> sure. habits...
19:03:25 <geekosaur> also I kinda have the opposite problem, having a program constantly popping hints at me while I'm working is a bit disractig
19:03:58 <jared-w> Oh I hate popups. I disable literally every single popup I can get my hands on. Underlining and such is totally fine though
19:04:03 <geekosaur> so tooltips = nasty flashing things that tell me what I already know etc.
19:06:03 <jared-w> I have the amazing ability to constantly momentairly forget things I already knew, so the tooltips are quite nice. Luckily I only have them displaying exactly when I want them and no longer; it drives me nuts watching some people programming with like actual popups flying everywhere and their screen yelling at them for everything
19:26:35 <iqubic> Pop-ups are a pain in the butt.
19:27:15 <iqubic> jared-w: Why do you use spacemacs?
19:28:11 <jared-w> 1) I like vim. 2) When I started haskell, vim sucked ass for Haskell compared to what emacs had, also emacs has org-mode and way better LaTeX stuff than vim
19:28:32 <jared-w> 3) ergo, I need an emacs that behaves like vim. In comes spacemacs to save the day :p
19:28:37 <iqubic> Yeah, but why the full blown spacemacs?
19:30:20 <jared-w> Because I am exceedingly lazy and would rather not spend 3 months painstakingly recreating my vim environment in emacs when I can just get 90% of the way there for free in 5 minutes by instaling spacemacs
19:30:56 <jared-w> Plus I've grown to like a lot of the way spacemacs does things better, like its space bar thing with the pop up menu for exploring modes I don't use often enough to memorize all the commands. I also like its more mnemonic based commands of things
19:31:09 <iqubic> Oh. I like knowing how my emacs set up works.
19:31:33 <jared-w> I mean, I know how mine works as well. There's not a single line in it that I don't understand ¯\_(ツ)_/¯
19:32:47 <boj> jared-w pretty much summed up my own opinion. i use spacemacs for the same reasons
19:34:11 <jared-w> I do have to say that every now and then the inferior implementation of surround.vim pisses me off. Plus sometimes I want to do some really stupid things with :g and emacs won't let me go full neckbeard, but... other than that, no real complaints
19:34:44 <iqubic> why does :g sometimes not work?
19:35:32 <jared-w> Because :g is merely a simulation of vim's global command and doesn't give you unrestricted access to some of the blacker magic you're capable of. It's pretty good but the more esoteric stuff sometimes breaks
19:35:52 <iqubic> Ah. I see.
19:36:15 <iqubic> What parts of the Haskell layer do you find you use most often?
19:36:19 <ski> iqubic : "FOCUS THEFT SHOULD BE A FELONY" by Riastradh in 2011-05-09 at <https://mumble.net/~campbell/blag.txt>
19:36:37 <iqubic> ski: How does that relate to me?
19:36:45 <ski> <iqubic> Pop-ups are a pain in the butt.
19:36:53 <rotaerk> jared-w, I also like spacemacs
19:36:56 <iqubic> Ah, yes. 
19:37:01 <rotaerk> it's what I use
19:37:04 <iqubic> Why is there so much spacemacs love.
19:37:18 <iqubic> I think it's far better to know what your .emacs does.
19:37:23 <jared-w> ski: I greatly agree that focus theft should be a felony
19:37:33 <rotaerk> ^
19:38:03 <jared-w> iqubic: I find it amusing that spacemacs is synonomous with "is clueless about with your .emacs does" to you. I've already stated that I understand all of my .emacs and .spacemacs. Did that escape you the first time? :p
19:38:25 <iqubic> No.
19:38:38 <rotaerk> iqubic, configurability and programmability of a tool is nice, but that doesn't mean I want to do the programming/configuring of it; I just want it to already work out-of-the-box for what I intend to do, e.g. haskell development
19:38:51 <rotaerk> spacemacs lets you configure it at a higher level, with its layer system
19:39:04 <iqubic> Are you aware that spacemacs has a large amount of stuff that you may never use ever?
19:39:14 <rotaerk> so? does it hurt to have it enabled?
19:39:23 <iqubic> No.
19:39:35 <boj> iqubic: i tried carefully cultivating my own .emacs at first, but it required a collosal amount of time to tweak. i suppose if i stuck with it i'd have the perfect environment today, but spacemacs got me 90% where i wanted to be in 5 minutes and then some
19:39:48 <monochrom> We should all work together to never code up focus theft. So that the only people who use focus theft are scammers, and it's the only thing they use. So that we have perfect detection for scams with 0% false positive and 0% false negative. Isn't this a much better world?
19:39:49 <jared-w> Are you aware that the Haskell Prelude has partial functions and some of the functions in there you'll probably never ever use? How do you sleep at night knowing you're importing uselss functions?
19:40:21 <iqubic> I don't like spacemacs, because I don't like having my editor config being a large black box
19:40:21 <rotaerk> monochrom, I just think the windowing system should outright disallow focus theft
19:40:32 <boj> iqubic: understandable
19:40:39 <rotaerk> simply impossible for a program to do
19:40:41 <jared-w> Worse yet, oh god, I must confess that I can't write out the source for every single prelude function by heart... The horror
19:41:02 <MarcelineVQ> jared-w: I bet you could get pretty far if you had to
19:41:03 <iqubic> boj: Do you think that spacemacs is a giant black box?
19:41:08 <jared-w> rotaerk: the problem is that inside single windows you can have focus theft
19:41:25 <rotaerk> true if the program itself has its own windowing system
19:41:25 <iqubic> jared-w: Single window in what application?
19:41:25 <monochrom> Are you aware that God and Stack work in mysterious ways?  >:D
19:41:30 <boj> iqubic: i do. but i don't really care either, it lets me do the important part: code haskell
19:41:30 <iqubic> monochrom: I am.
19:41:35 <iqubic> I have accepted that.
19:41:49 <MarcelineVQ> @roll 1d6
19:41:49 <lambdabot> MarcelineVQ: 1
19:41:53 <iqubic> But if a program has a config file, then I want to know what it does.
19:42:03 <jared-w> iqubic: very common example is the web browser stealing your focus from one part of the window to another part of the window
19:42:10 <monochrom> Oh that's easy to satisfy.
19:42:32 <rotaerk> iqubic, I basically think of spacemacs as a separate editor, and my interface into it is the .spacemacs file; the .emacs file/directory I just ignore as implementation details of spacemacs
19:42:43 <iqubic> MarcelineVQ: Einstien invalids your philosophy: "God does not play dice with the world"
19:42:51 <iqubic> rotaerk: I can't think like that.
19:43:07 <iqubic> rotaerk: what haskell layer functions do you use the most?
19:43:11 <boj> to each their own
19:43:24 <monochrom> But God invalidates Einstein's philosophy. >:D
19:43:25 <geekosaur> iqubic, Hawkins invalidates your philosophy (via) QED :p
19:43:29 <MarcelineVQ> iqubic: I don't think he ever proved that.
19:43:32 <rotaerk> haskell-mode, dante-mode, flycheck-mode are what I currently use
19:43:41 <jared-w> I use intero's ability to yell at me when I break things, so basically same as rotaerk
19:43:43 <rotaerk> I also like which-key, which I didn't know existed until spacemacs introduced it
19:43:52 <rotaerk> I don't use intero simply because I don't use stack, but I would if I did
19:43:58 <iqubic> what is dante-mode?
19:44:02 <geekosaur> you want to look at dante then
19:44:07 <iqubic> rotaerk: what do you use instead of stack.
19:44:09 <jared-w> dante is a intero equivalent
19:44:11 <geekosaur> it's basically a fasterintero without the stack dependency
19:44:15 <rotaerk> iqubic, nix
19:44:21 <jared-w> geekosaur: oh dante is faster than intero now?
19:44:26 <iqubic> And NixOS?
19:44:29 <iqubic> Or just nix?
19:44:37 <rotaerk> I do run NixOS, yes, but that's incidental
19:44:41 <jared-w> NixOS. Oh how I wish I could use you...
19:44:52 <MarcelineVQ> jared-w: idk about faster than intero side-by-side, it's faster than running things through stack
19:45:03 <jared-w> ah, makes sense
19:45:04 <iqubic> rotaerk: Do you recommend that one switches from stack to nix?
19:45:18 <rotaerk> I'll say there are pros and cons
19:45:23 <iqubic> Or is it not worth learning nix if I am already happy with stack?
19:45:27 <boj> yeah...
19:45:33 <iqubic> How did you learn Nix?
19:45:35 <boj> nix is great, but the curve is huge
19:45:36 <jared-w> iqubic: might as well recommend that one switch from emacs to vim or vice versa
19:45:49 <iqubic> jared-w: I'm not gonna do that.
19:45:49 <geekosaur> I'd say if you are alreadyusing stack a lot then throwing everything otu and starting over with nix is probably not worth it
19:46:02 <rotaerk> I think nix is better than stack at doing what stack does, but it's also less straight-forward
19:46:09 <iqubic> geekosaur: I don't know much about the advanced stack stuff.
19:46:10 <MarcelineVQ> If I used emacs I'd be using dante, but I don't so I use ghcid, because I'm too lazy to make a caller for ghci like dante for what I do us
19:46:12 <geekosaur> also, nothing says you can't use both; stack has specific support for nix
19:46:12 <rotaerk> lots more to learn
19:46:21 <geekosaur> which could also potentially be used to migrate slowly
19:46:38 <jared-w> What pisses me off about Nix is how verbose it is, and the fact that it's untyped
19:46:39 <rotaerk> with stack, you get your haskell dependencies through stackage, and your non-haskell dependencies have to be resolved by your environment, as I understand it
19:46:43 <iqubic> rotaerk: Do you use Nix for things other than haskell.
19:46:44 <iqubic> ??
19:46:52 <jared-w> rotaerk: you understand correctly :)
19:46:54 <rotaerk> with nix, ALL dependencies can be resolved reliably, independent of environment
19:47:07 <iqubic> And is Nix only for Haskell?
19:47:07 <boj> iqubic: i spent an hour trying to do something "useful" in nix. gave up a moment ago. the docs are pretty terrible, you have to wade through the code and/or issues to figure anything out
19:47:11 <jared-w> iqubic: well rotaerk uses NixOS so their entier OS is going to be determinstically configured
19:47:13 <rotaerk> with stack + nix, the haskell dependencies are resolved through stackage, and the non-haskell dependencies are resolved through nix
19:47:45 <jared-w> The other last thing that pisses me off about NixOS is that it's an OS that celebrates determinstic configuration... and has no user-land configuration capabilities? Really? Why ;-;
19:47:45 <rotaerk> iqubic, yea, haskell and my OS configuration is about all I use it for; but that's about all I *do* that it would be applicable to
19:47:53 <equalunique[m]> Glad to see some discussion of Nix here. I think it's a Linux game-changer.
19:48:19 <iqubic> I want to learn Nix, but I never know where to start.
19:48:48 <rotaerk> iqubic, read the manuals; that's where you can start.
19:49:05 <rotaerk> and read through nixpkgs itself, and other examples
19:49:56 <rotaerk> nix makes building reliable, but doesn't simplify things IMO
19:50:28 <iqubic> Actually, this sounds like a large amount of work, and I already know stack.
19:50:34 <iqubic> I'm not going to switch
19:50:44 <rotaerk> k
19:51:55 <vaibhavsagar> iqubic: Nix begins to make more sense when your projects have to integrate with non-Haskell libraries/tools
19:52:55 <iqubic> But mine don't
19:53:25 <vaibhavsagar> fair enough
19:54:38 <vaibhavsagar> I use NixOS at work and all our servers run it
19:56:21 <equalunique[m]> I found this article helpful when struggling with compiling software on Nix: http://anderspapitto.com/posts/2015-02-28-deb-installation-nixos.html
19:58:55 <monochrom> http://www.vex.net/~trebla/haskell/so.xhtml#cabal  New section added.
20:15:01 <dmj`> iqubic: join #nixos and ask for clever, he’ll teach you a nix. 
20:15:12 <iqubic> Really?
20:15:15 <dmj`> yes
20:15:24 <rotaerk> lol, he's just always in there :P
20:16:04 <fresheyeball> humans of fp
20:16:17 <fresheyeball> how can I derive an Eq instance for an existential type?
20:16:32 <Aslan> I've got a question for anyone interested, I'm trying to write a test function for another function I wrote.  Here's the original function: http://lpaste.net/667039035595685888.  Here's a sample test function (its just testing one of many constraints it should have): http://lpaste.net/358762. 
20:16:42 <raynold> ahh it's a wonderful day
20:16:57 <fresheyeball> I have something likes this
20:17:31 <Aslan> I can't get the test function to work, although that statement does return true when typed in the interpreter
20:17:39 <fresheyeball> data Foo = forall t. (Show t, Eq t, Bar t) => Foo { _a :: Text, _b :: t }
20:17:48 <fresheyeball> can I just not derive Eq for this fellow?
20:18:20 <fresheyeball> Aslan: what do you mean by "function to work"?
20:18:49 <fresheyeball> Aslan: you just want to get past the hlint error?
20:19:05 <Aslan> Ah, well it won't compile; here's the output: Ambiguous type variable ‘a0’ arising from a use of ‘==’       prevents the constraint ‘(Eq a0)’ from being solved.       Probable fix: use a type annotation to specify what ‘a0’ should be.
20:19:18 <fresheyeball> oh
20:19:29 <fresheyeball> Aslan: just put a type annotation in there so GHC knows whats up
20:19:50 <fresheyeball> (Nothing :: Maybe YourType)
20:20:30 <Aslan> So change Nothing's type?
20:21:04 <rotaerk> Nothing's type is: Maybe a
20:21:07 <Aslan> :t Nothing gives you Nothing :: Maybe a
20:21:08 <lambdabot> error:
20:21:08 <lambdabot>     • Couldn't match expected type ‘t0 -> t1 -> Maybe a1 -> Maybe a2’
20:21:08 <lambdabot>                   with actual type ‘Maybe a0’
20:21:18 <rotaerk> you can explicitly constrain that type by filling something specific in for the a
20:21:27 <fresheyeball> Aslan: Maybe a is not enough info to know it can be Eqed
20:21:45 <fresheyeball> instance Eq a => Maybe a
20:21:52 <fresheyeball> GHC doesn't know what `a` is
20:22:02 <fresheyeball> so it doesn't know what `==` instance to use
20:22:11 <Aslan> Okay that's making more sense
20:22:17 <fresheyeball> the annotation will make it unambigious for GHC
20:22:31 <geekosaur> right
20:22:33 <fresheyeball> Nothing could always be something like
20:22:41 <geekosaur> and it works in ghci because ghci has an extra extension enabled, ExtendedDefaltRules
20:22:47 <fresheyeball> Maybe (Int -> Int) which can't be == ed
20:23:03 <geekosaur> it loosens the rules for determining such types, and adds () to the list of types a expression can default to
20:23:11 <iqubic> rotaerk: You are right. Clever was there.
20:23:23 <geekosaur> specifically so you don't have to annotate every [] in the REPL with a type
20:23:29 <fresheyeball> Aslan: listen to geekosaur , much teaching coming from that person
20:23:33 <geekosaur> (specifically empoty lists, since those can;t be inferred)
20:23:52 <fresheyeball> anyone want to help me derive Eq?
20:24:00 <geekosaur> but the assumption of () can lead to surprises, so it's not enabled for compiled code
20:24:42 <rotaerk> iqubic, I find that amusing
20:24:50 <Aslan> geekosaur: Ahh that makes a lot of sense, I was about to say that if I define that test function in ghci it gives me no issues
20:24:53 <iqubic> Why?
20:25:01 <rotaerk> that he seems to live there
20:25:01 <iqubic> rotaerk: why is that amusing?
20:25:04 <iqubic> Oh.
20:25:25 <rotaerk> he's also quite helpful
20:25:44 <fresheyeball> http://lpaste.net/4356592543324962816
20:25:59 <fresheyeball> please? I am really not understanding why this doesn't work
20:27:00 <Aslan> geekosaur: So I need to add a constraint to what "Maybe a" can be?
20:27:46 <geekosaur> Aslan, you just have to say what type [] is in the test function
20:28:02 <cdal> hey, Javascript kiddie here who's been using ramda (a library that more or less ports over Haskell functions and encourages functional programming) looking to rewrite a small server in Haskell. what is the Haskell equivalent to promises / async/await?
20:28:19 <geekosaur> (or, alternately, what type Nothing is --- sice the list element type and the type inside the Maybe have to match)
20:28:51 <fresheyeball> cdal: there isn't one
20:29:04 <fresheyeball> cdal: Haskell doesn't suffer from the problems those functions solve
20:29:07 <geekosaur> like:  getTest1 = get 0 [] == (Nothing :: Maybe Int) -- or something
20:29:35 <geekosaur> fresheyeball, that's nto entirely true, it's not all about language shortcomings. and see the async package)
20:29:45 <fresheyeball> geekosaur: I know
20:29:52 <cdal> I've briefly googled this from an outsiders perspective; interested in the community's opinion on best way to handle network calls etc (other operations ofindefinitewe execution time)
20:29:56 <rotaerk> cdal, https://hackage.haskell.org/package/async
20:30:01 <fresheyeball> geekosaur: I came from JS land to
20:30:13 <fresheyeball> and that is not going to be helpful in understanding those JS language keywords
20:30:21 <Aslan> geekosaur: Thanks for the help!
20:30:42 <geekosaur> cdal, Monads handle that; you could think of them as callback-based programming written 'backwards' so it is more natural
20:30:43 <rotaerk> does javascript async/await do the same thing as C#'s async/await?
20:31:03 <fresheyeball> cdal: the Servant library is the popular way to make a server right now 
20:31:26 <cdal> rotaerk not familiar with c# but from what I've read more or less I believe they are handled "similarly"
20:31:28 <fresheyeball> cdal: you might also look at MVar
20:31:31 <geekosaur> so when you do x <- someOperation in do notation, it's actually registering a callback that will be triggered when someAction actually happens and produces a result
20:31:41 <fresheyeball> which is a good place to start in understanding haskell concurrency
20:32:21 <fresheyeball> geekosaur: got time to look at my thing?
20:32:27 <fresheyeball> I'm sure you know the answer to this
20:32:30 <fresheyeball> http://lpaste.net/4356592543324962816
20:32:37 <iqubic> rotaerk: await/async is a monad.
20:32:43 <cdal> got it. thanks guys, following these links now
20:32:49 <benzrf> geekosaur: im not sure if "registering a callback" is the best way to put it -
20:32:57 <benzrf> futures don't actually form a Monad[m] 
20:33:04 <benzrf> er, *monad
20:33:08 <fresheyeball> cdal: if you want find me on slack chat
20:33:12 <geekosaur> benzrf, as a JS programmer it's a thing they might know about alredy though
20:33:12 <rotaerk> iqubic, eh?  async/wait in haskell, and they're not a monad
20:33:17 <fresheyeball> I have a habit of teach JS devs Haskell
20:33:31 <rotaerk> iqubic, look at the types in that async package
20:33:39 <benzrf> geekosaur: "registering a callback" implies an imperative action taken which mutates some registry of callbacks
20:33:45 <fresheyeball> I have many years of JS, I can clear up thing 
20:33:47 <geekosaur> fresheyeball, the problem is you put a forall inside the data, so there is no way from outside that any two values of SomeTaktTag can know they have the same type 't'
20:33:49 <benzrf> and that's a fairly important difference
20:34:04 <benzrf> e.g. - you can't "register a callback" independently of building the IO value
20:34:07 <cdal> fresheyeball: will do, look for a message sometime tomm. thank you! same username I'm assuming
20:34:14 <iqubic> rotaerk: I was talking about JS await/async. Which, do folow the monadic laws.
20:34:17 <fresheyeball> geekosaur: so I will just need to write the instance by hand?
20:34:22 <rotaerk> ahh
20:34:22 <benzrf> whereas, with futures you are able to register a callback without holding onto the new future you create by doing so
20:34:25 <benzrf> big difference!
20:34:25 <monochrom> OK, so don't register. But it's still a callback.
20:34:27 <geekosaur> the usual way to do this is parameterize SomeTaktTag by t, and now it knows it can compare them if they are the same t and it is a type erro if they are not
20:34:43 <fresheyeball> iqubic: can you prove that?
20:34:45 <fresheyeball> I don't buy it
20:35:00 <fresheyeball> geekosaur: I need that forall 
20:35:17 <geekosaur> then you're not going to be able to compare two values
20:35:38 <geekosaur> or otherwise relate or combine them
20:36:03 <fresheyeball> oic
20:36:11 <fresheyeball> I could have divergent SomeTaktTags
20:36:15 <geekosaur> the 't' cannot be known. the only way it could be accessed is via its typeclass constraints
20:36:39 <rotaerk> fresheyeball, are you sure you really want this to contain *just anything*?
20:36:50 <rotaerk> and not one of a set of possible types
20:36:53 <geekosaur> because it is visible that Show t, Eq t, TaktTag t --- but Eq t s not helpful here because the comparison would have to be done with the same SomeTaktTag
20:37:03 <rotaerk> like what is this a solution *for*
20:37:25 <geekosaur> if TaktTag t gives you something you could use, then you might be able to do it
20:37:42 <geekosaur> or if you are willing to compare them by using their Show instances
20:38:04 <geekosaur> (but you can;t derive Eq for either of those cases, you need to write it explicitly)
20:39:04 <rotaerk> you could, for instance do:  data SomeTaktTag = forall t. Show t => SomeTaktTag {...};  instance Eq SomeTaktTag { t1 == t2 = show t1 == show t2 }
20:39:18 <geekosaur> like: instance Eq SomeTaktT where x == y = show x == show y
20:39:19 <rotaerk> but that's kind of a loose notion of equality
20:39:27 <geekosaur> heh
20:39:35 <geekosaur> same place, different ways...
20:39:51 <fresheyeball> geekosaur: can Typeable bail me out?
20:40:42 <rotaerk> fresheyeball, you're trying hard to force the language to do something it really doesn't want to do, and probably should reconsider whether this entire approach is really ideal
20:40:53 <rotaerk> I mean, even if you can find a way to get it to work, it may have drawbacks
20:40:55 <ski> fresheyeball : you might consider putting a `Typeable' constraint on the existentially quantified tyvar
20:41:01 <fresheyeball> rotaerk: I think I can just get rid of the code that use ==
20:41:08 <geekosaur> possibly, but I echo rotaerk: is this *really* the only solution? the error is trying tot ell you something, you are doing this the wrong way (for Haskell, at least)
20:41:14 <ski> fresheyeball : if you do that, you can compare the types to each other
20:41:37 <fresheyeball> ski: right, that was my thought
20:41:41 <geekosaur> and the mismatch may come back to bite you in other, less easily worked around ways later
20:41:43 <fresheyeball> if types are not equal, then False
20:41:53 <fresheyeball> if types are equal then == like normal
20:41:58 <ski> fresheyeball : but you must put `Typeable' then
20:42:06 <geekosaur> that was whatthey asked about...
20:42:29 <ski> but also consider what rotaerk said
20:45:39 <fresheyeball> hey sebisebi[m] 
20:45:41 <fresheyeball> erp
20:45:49 <fresheyeball> sellout-: hey!
20:48:22 <sellout-> fresheyeball: Hey 😄
20:49:12 <fresheyeball> https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Type-Equality.html
20:49:18 <fresheyeball> I feel like testEquality should work
20:49:23 <fresheyeball> but what is that `f` doing in there?
20:51:03 <fresheyeball> oh wait I think I get it
21:09:55 <fresheyeball> http://lpaste.net/3113408061859954688
21:10:04 <fresheyeball> apparently I don't get how to use testEquality
21:11:34 <c_wraith> fresheyeball: error messages help a lot
21:13:04 <fresheyeball> c_wraith: http://lpaste.net/6662525897175728128
21:13:36 <fresheyeball> the TestEquality class sure is confusing me
21:13:41 <fresheyeball> it looks like it takes 1 arg
21:13:49 <fresheyeball> but its instances make it look like it takes 2 args
21:14:37 <c_wraith> What is the TaktTag class?
21:15:05 <fresheyeball> its a constraint existentailized into SomeTaktTag
21:16:47 <c_wraith> yes, but what makes you think you can use typeRep on the type t?
21:17:21 <fresheyeball> class (Show tag, Eq tag, Typeable tag) => TaktTag tag where
21:17:30 <c_wraith> There we go.  :)
21:18:00 <c_wraith> but typeRep is a function
21:18:19 <c_wraith> The compiler is complaining that you aren't passing it args
21:18:48 <fDev2179> I'm trying to run a tasty test as follows: http://lpaste.net/358763, however, I keep getting the following error: Variable not in scope: listingTests :: Ingredient.  Any ideas what I'm doing wrong?
21:18:55 <fresheyeball> https://hackage.haskell.org/package/base-4.10.0.0/docs/Type-Reflection.html#t:Typeable
21:19:07 <fresheyeball> c_wraith: it sure looks like a non-function
21:19:45 <c_wraith> Ah.  Inconvenient that that module uses the exact same names as Data.Typeable
21:20:09 <fresheyeball> c_wraith: wha?
21:20:18 <fresheyeball> but haddock made it seem like they are the thing
21:20:51 <c_wraith> fresheyeball: https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Typeable.html#v:typeRep  same name.  Not the same function.
21:21:41 <iqubic> rotaerk: How do you use nix to help with haskell development?
21:22:04 <fresheyeball> c_wraith: that helped kinda
21:22:10 <c_wraith> fresheyeball: anyway.  try typeRep :: TypeRep t  instead of typeRep :: t
21:22:11 <fresheyeball> but testEquality still not working
21:22:47 <c_wraith> or were you using the definitions from Data.Typeable after all?
21:23:00 <fresheyeball> c_wraith: that helped kinda helped
21:23:06 <fresheyeball>     case testEquality (typeRep (Proxy @t)) (typeRep (Proxy @t0)) of
21:23:16 <fresheyeball>     • Couldn't match expected type ‘f0 a0’
21:23:18 <fresheyeball>                   with actual type ‘Data.Typeable.Internal.TypeRep’
21:24:00 <c_wraith> fresheyeball: can we get a new paste with the current code and error?
21:25:00 <fresheyeball> http://lpaste.net/102919485270261760
21:26:04 <c_wraith> Ok, I'm beginning to suspect the problem is your imports.
21:26:24 <c_wraith> Are you importing Data.Typeable or Type.Reflection?
21:26:31 <fresheyeball> import           Data.Type.Equality  ((:~:) (Refl), testEquality)
21:26:33 <fresheyeball> import           Data.Typeable       (Typeable, typeRep)
21:26:47 <fresheyeball> I don't think I have Type.Reflection
21:26:53 <c_wraith> yeah, that's the wrong Typeable
21:27:09 <fresheyeball> pffft what you mean?
21:27:47 <c_wraith> The instance of TestEquality for TypeRep is for Type.Reflection.TypeRep
21:27:55 <c_wraith> that's what you were reading the docs for before
21:27:59 <c_wraith> But not what you were importing
21:28:10 <fresheyeball> grr
21:28:25 <fresheyeball> the older version of TestEquality is even more confusing
21:29:37 <iqubic> why do you need TestEquality>
21:29:56 <fresheyeball> to make my overcomplex eq instance
21:30:01 <fresheyeball> since its existentialized
21:30:05 <c_wraith> Couldn't you just use cast?
21:30:06 <fresheyeball> and the types might differ
21:30:32 <fresheyeball> what is cast?
21:30:39 <c_wraith> https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Typeable.html#v:cast
21:30:59 <c_wraith> Since you already have the two Typeable constraints
21:31:27 <fresheyeball> c
21:31:31 <fresheyeball> uh
21:31:38 <fresheyeball> but I don't want to turn one into the other
21:32:13 <monochrom> No, no one is turning one into the other.
21:32:37 <c_wraith> fresheyeball: like http://lpaste.net/102919485270261760#a358764
21:32:41 <fresheyeball> I just don't understand what cast does
21:33:04 <c_wraith> if the two types are the same, cast = Just
21:33:10 <c_wraith> Otherwise, cast = const Nothing
21:34:49 <fresheyeball> oh!
21:34:50 <fresheyeball> nice!
21:35:14 <fresheyeball> that worked!
21:35:16 <fresheyeball> Woooo!
21:35:22 <fresheyeball> non-horrible Eq!
21:37:35 <tabemann> isn't there now a safe coerce
21:38:05 <tabemann> where there is essentially a type class Coercible whose instances are auto-generated with the method coerce?
21:38:15 <c_wraith> yes, but that has nothing to do with cast
21:39:03 <c_wraith> cast never changes the type of anything.  It just proves two types are the same (though it doesn't reify that proof)
21:39:07 <fresheyeball> c_wraith: cast is not a well named function
21:39:43 <tabemann> the name "cast" implies that it should do what coerce does
21:39:54 <c_wraith> It's similar to a checked cast in java.
21:39:54 <fresheyeball> yup
21:40:06 <c_wraith> or dynamic_cast in C++
21:40:14 <fresheyeball> hmm
21:40:33 <fresheyeball> maybe I think its badly named because I don't have the Java/C++ context
21:41:52 <tabemann> the difference is that Java and C++ have subtyping
21:42:09 <tabemann> so the idea of upcasting dynamically makes sense in them
21:42:41 <c_wraith> those are actually downcasts. :P
21:42:55 <c_wraith> I mean, they can be upcasts, too, but upcasts don't fail.
21:43:07 <c_wraith> at least, not at runtime
21:43:25 <fresheyeball> so this is a side cast?
21:43:36 <c_wraith> pretty much.
21:43:50 <c_wraith> it only works if the two types are actually the same.  Fails in all other cases.
21:44:30 <ski> > cast False :: Maybe Any
21:44:33 <lambdabot>  Nothing
21:44:57 <fresheyeball> > cast False :: Bool
21:45:00 <lambdabot>  error:
21:45:01 <lambdabot>      • Couldn't match expected type ‘Bool’ with actual type ‘Maybe b0’
21:45:01 <lambdabot>      • In the expression: cast False :: Bool
21:45:06 <exio4> ski: are you trying to cheat the system? :p
21:45:14 <fresheyeball> > cast False :: Maybe Bool
21:45:16 <lambdabot>  Just False
21:45:26 <Axman6> that's amazing
21:45:27 <fresheyeball> yeah side cast
21:45:29 <fresheyeball> I get it now
21:45:33 <ski> exio4, nah, just showing iy doesn't "peek under `newtype's
21:45:38 <fresheyeball> > cast False :: Maybe String
21:45:41 <lambdabot>  Nothing
21:45:42 <ski> s/iy/it/
21:45:58 <Axman6> > cast False :: Maybe ()
21:46:00 <lambdabot>  Nothing
21:46:02 <ski> > Any False
21:46:04 <lambdabot>  Any {getAny = False}
21:46:31 <Axman6> > coerce False :: Any
21:46:33 <lambdabot>  error:
21:46:33 <lambdabot>      • Variable not in scope: coerce :: Bool -> Any
21:46:33 <lambdabot>      • Perhaps you meant ‘coerced’ (imported from Control.Lens)
21:46:54 <fresheyeball> if I use generalized newtype deriving
21:47:02 <fresheyeball> and derive Typeable on a newtype
21:47:14 <fresheyeball> is the typerep going to be the newtype, or the type it wraps?
21:47:14 <Axman6> > False ^. coerced :: Any
21:47:16 <lambdabot>  Any {getAny = False}
21:48:17 <c_wraith> fresheyeball: that depends on your version of ghc.  sufficiently new and you can't even manually derive Typeable.  It's automatic for all types.
21:48:32 <ski> @let newtype MyInt = MI Int deriving Typeable
21:48:34 <lambdabot>  Defined.
21:48:36 <ski> > typeRep ([] :: [MyInt])
21:48:38 <lambdabot>  MyInt
21:49:06 <fresheyeball> ski: how do we know generalized newtype deriving is turned on in lambdabot?
21:49:54 <c_wraith> @undefine
21:49:54 <lambdabot> Undefined.
21:50:07 <ski> hmm .. looks like it isn't actually ?
21:50:09 <c_wraith> @let newtype MyInt = MI Int deriving (Typeable, Num)
21:50:09 <ski> good point
21:50:10 <lambdabot>  .L.hs:160:35: error:
21:50:10 <lambdabot>      • Can't make a derived instance of ‘Num MyInt’:
21:50:10 <lambdabot>          ‘Num’ is not a stock derivable class (Eq, Show, etc.)
21:50:16 <c_wraith> yep, no GND
21:50:18 <MarcelineVQ> I doubt it is
21:50:22 <ski> @where L.hs
21:50:23 <lambdabot> what lambdabot has in scope is at http://silicon.int-e.eu/lambdabot/State/Pristine.hs
21:50:27 <ski> not listed there ^
21:50:29 <fresheyeball> thats a no
21:52:30 <fresheyeball> well ghci solved this one
21:52:58 <fresheyeball> :set -XGenerlized...
21:53:12 <fresheyeball> newtype Foo = Foo Int deriving (Num, Typeable)
21:53:22 <fresheyeball> typeRep (Nothing :: Maybe Foo)
21:53:27 <fresheyeball> gave back
21:53:29 <fresheyeball> "Foo"
21:53:35 <fresheyeball> it's lovely
21:53:40 <ski> fun
21:53:50 <MarcelineVQ> hmm  (cast . coerce @_ @Any) False :: Maybe Any
21:54:10 <MarcelineVQ> sure is a lot of weird and fun things in base
22:38:41 <Zyxoas> Hi, peeps.
22:38:46 <Zyxoas> Very quick question.
22:39:11 <Zyxoas> How do I define a DataKind where one of the constructors expects a Symbol as a parameter?
22:39:57 <Zyxoas> Of course, I can write a Data type where a constructor expects a String, but will that get translated into a type that takes a Symbol?
22:40:18 <Zyxoas> For example: data A = B | C String
22:40:31 <iqubic> What is a Symbol in Haskell?
22:40:47 <Axman6> a type level string
22:41:02 <Axman6> @kind Proxy "A Symbol"
22:41:04 <lambdabot> *
22:41:06 <Zyxoas> I wanna be able to have: 'C Symbol :: A
22:41:08 <Axman6> hmm
22:41:18 <Axman6> @kind "A Symbol"
22:41:19 <lambdabot> GHC.Types.Symbol
22:42:12 <piyush-k`> anyone knows why I am getting some curl error for cabal update. Error says curl: (52) empty reply from server. Is hackage down?
22:43:21 <piyush-k`> okey nuking the .cabal seemed to solve the problem. Might be some junk has accumulated there
22:43:52 <Zyxoas> In particular, if I say: j = undefined :: (Proxy 'C "dude"), then GHC complains "Expected kind 'String', but 'dude' has kind 'Symbol'"
22:44:08 <Zyxoas> Which is a bit dumb since there is no kind named "String"...
22:45:52 <Zyxoas> I have enabled TypeInType, so I have basically thrown the kitchen sink at this...
22:46:05 <iqubic> @kind "String"
22:46:06 <lambdabot> GHC.Types.Symbol
22:46:33 <Zyxoas> lol @iqubic: That's insane. I'm not sure how to use that fact, though...
22:46:58 <Zyxoas> Oh. No, I see. That's to be expected.
22:49:08 <ackpacket> Wait what
22:49:10 <Zyxoas> Ah! Nevermind! I have an answer!
22:49:17 <ackpacket> why can't I join two lists..
22:49:23 <Axman6> what's the answer?
22:49:28 <Zyxoas> GHC.TypeLits defines Symbol as a Data type.
22:49:34 <Axman6> ackpacket: huh?
22:49:40 <Zyxoas> data Symbol :: *
22:49:46 <Axman6> Zyxoas: ah, intersting!
22:50:03 <Zyxoas> Meaning I can use Symbol at the term-level, when defining my own Data type.
22:50:20 <Zyxoas> So: data A = B | S Symbol
22:50:50 <Zyxoas> And now this willl work: j = undefined :: ('S "dude")
22:51:20 <Zyxoas> Quite obvious in retrospect. I just thought that Symbol was more magical than it really is. It still is quite magical though...
22:51:48 <Axman6> > [1,2,3] ++ [4,5,6] -- ackpacket
22:51:51 <lambdabot>  [1,2,3,4,5,6]
22:52:36 <ackpacket> fml.  I knew that.  For whatever reason though googling for "join two lists" or "concat two lists" or merge... results in dozens of stack overflows answers about custom ad-hoc versions to merge a list in a specific way
22:52:39 <ackpacket> Axman6, ty
22:53:08 <ackpacket> Is there a reduce in haskell?  
22:53:11 <ackpacket> fold I suppose
22:53:17 <Zyxoas> Yep. dold
22:53:22 <Zyxoas> fold
22:53:38 <Axman6> there's many ways to reduce
22:53:54 <Axman6> (in fact, an infinite number of ways!)
22:53:56 <Zyxoas> But there is foldl, foldr. And strict versions. And it's actually a bit of a mess, really.
22:54:22 <nisstyre> there's also unfold
22:54:31 <nisstyre> and really, lots of ways to do that too
22:54:34 <boj> > [1,2,3] <> [4,5,6]
22:54:36 <lambdabot>  [1,2,3,4,5,6]
22:54:38 <nisstyre> and you can unfold with fold too
22:55:05 <Axman6> not really, foldl and foldr serve quite different purposes (despite one being a catamorphism and therefore can be used to define the others)
22:55:52 <nisstyre> yeah foldl and foldr deserve to be distinct things
22:56:22 <nisstyre> the question is which one should mconcat be? :p
22:56:42 <nisstyre> (it doesn't matter honestly)
22:57:00 <Axman6> well, it does for performance reasons, and depends on the choice of monoid
22:57:08 <Axman6> @src Monoid
22:57:08 <lambdabot> class Monoid a where
22:57:08 <lambdabot>     mempty  :: a
22:57:08 <lambdabot>     mappend :: a -> a -> a
22:57:08 <lambdabot>     mconcat :: [a] -> a
22:57:36 <Axman6> I believe that's the reason it's included in the class, so you can decide if it's a strict or lazy fold
22:58:00 <nisstyre> where is included?
23:01:46 <Axman6> ackpacket: I find your question a little bit funny, because there are plenty of people who think that "functional programming" just means using map and reduce, so of course Haskell would have that :P
23:02:51 <nisstyre> Axman6: Javascript programmers
23:03:30 <nisstyre> stuff like this doesn't help https://www.joelonsoftware.com/2006/08/01/can-your-programming-language-do-this/
23:06:17 <Axman6> "Object-oriented programming languages aren’t completely convinced that you should be allowed to do anything with functions." heh
23:07:08 <nisstyre> Axman6: or confusing a closure and a lambda
23:07:13 <nisstyre> that one annoys me
23:08:21 <pacak> Javascript. Ugh.
23:09:07 <Axman6> so, I don't have a problem with that article, because it does introduce a new concept which makes the life of a javascript programmer easier (but... mutating arrays? not so cool)
23:09:42 <Axman6> it doesn't really pretend to say "THIS is what functional programming is", but uses some concepts fit
23:09:48 <Axman6> from it*
23:10:02 <nisstyre> yeah, it's more that the choice of examples helps reinforce that idea
23:10:09 <nisstyre> only at the end does he get to the point
23:10:23 <Axman6> yeah
23:10:40 <maerwald> paradigms are hard to define properly, since they are not just about specific properties
23:12:15 <nisstyre> can't disagree with that
23:12:31 <nisstyre> I prefer to talk about specific aspects or features
23:12:52 <maerwald> someone came along and said "functional programming is about purity"
23:12:58 <nisstyre> like "this language has X" instead of "it's a X language"
23:13:05 <maerwald> then someone came along and said "hey, I did purity in imperative programming, now what?"
23:15:52 <nisstyre> I really like this explanation btw https://stackoverflow.com/a/36878651/903589
23:15:58 <nisstyre> of lambdas
23:31:55 <Axman6> anyone know of any haskell libraries for defining fault tollerent parsers? the sorts of thing you'd see in a programming text editor so you could do intellisense as someone's typing
23:33:18 <edwardk> Axman6: working on one now! =)
23:33:40 <edwardk> that was what my talk at scala world was about
23:33:41 <Axman6> edwardk: <3
23:33:47 <Axman6> got a link?
23:33:54 <edwardk> github.com/ekmett/coda
23:33:58 <edwardk> ##coda
23:34:26 <edwardk> https://drive.google.com/file/d/0ByK3AAy5ubqaZmZHc0ZTRDBWZjA/view?usp=sharing has slides from my talk
23:34:31 <edwardk> but they are designed to be talked over
23:34:35 <Axman6> fantastic
23:34:36 <edwardk> the video isn't up yet
23:34:48 <edwardk> going through a crash course on stuff for georgew on ##coda now
23:35:04 <edwardk> i can grab a text dump of the last 20 minutes or so for you
23:35:05 <Axman6> ah I think we've spoken about this before
23:35:15 <Axman6> yeah that'd be great
23:35:26 <Axman6> also georgew can help fill in the caps as we work together
23:37:37 <edwardk> he went quiet so i started looking for other things to think about and came in here, whereupon you immediately asked a leading question i care about ;)
23:39:08 <edwardk> anyways the gist of the project there is making some changes to a language so that i can get very very robust error productions so that intellisense referencing forward in the file doesn't go bad as you're typing garbage.. this is sort of pre-syntactic. as whenever anybody tells you something about syntax they usually think in terms of syntax trees. but i need to be able to deal with name capture, etc. even in the presence of garbage
23:39:08 <edwardk> at a source level.
23:39:29 <edwardk> and i'm interested in doing so at very interactive rates even over large code bases.
23:40:08 <edwardk> so i'd like this to be parseable in parallel or incrementally as you make small changes and i'd like to do so in sub-linear time for as far through the pipeline as i can
23:42:33 <ackpacket> Searched a bit for this -- anyone heard of: separateBy isOdd [1, 2, 3, 4, 5], with a result of ([1, 3, 5], [2, 4])
23:43:24 <ackpacket> Everything seems to be about choosing points to "cut" the list into sections
23:43:28 <ski> > partition odd [1,2,3,4,5]
23:43:31 <lambdabot>  ([1,3,5],[2,4])
23:43:53 <ackpacket> Nice.  Thanks ski.
23:43:57 <ski> np
23:45:41 <vaibhavsagar> hey, how do I ask for a package to be included in stackage nightly?
