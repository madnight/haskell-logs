00:04:10 <bartavelle> halogenandtoast: also, not sure if that is relevant to your use case, but if you can describe the "powers" and "effects" using a sort of DSL, you can simplify your logic a lot
00:20:48 <iqubic> How would you write a DSL for that?
00:21:19 <magthe> I'm having trouble with the CPP language extension, I need to stringify my macro, but #FOO doesn't seem to work!
00:31:07 <cocreature> magthe: you’ll have to be a bit more specific. can you show us some code sample? what exactly do you mean by “doesn’t seem to work”
00:34:46 <magthe> cocreature: well, passing "-DFOO=1.2.3" when compiling "putStrLn #FOO", results in "Variable not in scope: (#) :: (String -> IO ()) -> (a0 -> c0) -> t"
00:35:24 <magthe> which is how I think stringification works in CPP, no?
00:37:28 <cocreature> I don’t think so. afaik you can only use stringification on the arguments of function-like macros
00:37:59 <mud> Yeah I didn't think you could just throw it anywhere
00:38:05 <mud> But I'm not an expert.
00:40:50 <trigone> hi! i'm trying to describe a class instance in terms of other classes. however i can't manage to find the right syntax for it to typecheck without using undecidableinstances... can someone help me? http://lpaste.net/358131
00:40:52 <magthe> cocreature: oh, that's rather confusing... but then "#define str(s) #s" and "putStrLn str(VERSION)" doesn't work either (same error), so is it even possible to pass in a macro and turn it into string?
00:44:05 <magthe> cocreature: ah, that was solved by switching to GNU cpp
00:46:06 <ertes-w> l
00:46:37 <trigone> i'm reading some stuff related to my problem. am i right to interpret it as being that if i allowed defining a class instance in a purely polymorphic way, there would be no way to choose between that instance and a monomorphic, unconstrained instance, hence the undecidability? i'm also reading that sometimes type families work better than fundep, should i try with it?
00:47:04 <cocreature> magthe: while that should compile with GNU CPP it probably won’t behave as you intended. stringification takes place before expansion of macro arguments so that will result in "VERSION"
00:47:24 <cocreature> magthe: take a look at https://gcc.gnu.org/onlinedocs/gcc-4.9.0/cpp/Stringification.html for a workaround
00:47:58 <magthe> cocreature: yeah, I know I realised I needed another layer of expansion, like xstr->str->"foo"
00:48:28 <ertes-w> trigone: that's just an instance conflict: given instances of the shape (D a => C a), instance resolution will only be done using the (C a) part, so if you have instances (Num a => C a) and (C Int), then if you use an Int somewhere, *both* instances will match
00:48:46 <magthe> rather confusing that ghc uses gcc as its CPP and passes flags that makes stringification not work by default
00:49:00 <ertes-w> trigone: even if your first instance is (Monoid a => C a), still both instances will match, because the constraint does not matter for instance resolution
00:49:37 <trigone> ertes-w: so what do i do? wrap with a newtype like i just read? or type families?
00:49:37 <ertes-w> trigone: about fundeps vs. type families: since TypeFamilyDependencies to my knowledge they are 100% equivalent, and both have their merits
00:49:54 <trigone> ertes-w: ok i'll try with that then
00:49:56 <magthe> cocreature: thanks for helping me get that working!
00:50:39 <ertes-w> trigone: often fundeps are just nicer, because they have a more concise syntax, but associated types can be easier to read in some cases
00:50:51 <trigone> thx a lot! :) i'm surprised the resolution of instances is so... weird. it doesn't seem very logical to not choose the most monomorphic and instance, but there must be a reason...
00:51:16 <ertes-w> trigone: newtype would be the standard way
00:51:41 <ertes-w> trigone: Monoid does that a lot…  for example you have a Sum wrapper for addition monoids and the Product wrapper for multiplication monoids
00:52:05 <ertes-w> if in doubt just copy Monoid's approach…  it's clean and versatile
00:52:16 <ertes-w> see Data.Monoid for lots of examples
00:53:25 <ertes-w> trigone: haskell does not assign priorities when it comes to instances…  there are ways to do it, but you really shouldn't, because that makes the semantics of your program dependent on whether a certain instance is in scope
00:53:54 <ertes-w> in general avoid overlapping instances
00:53:58 <trigone> ertes-w: i'll think about the newtype method... it feels weird but if it's the norm
00:54:28 <trigone> ertes-w: yeah i've been warned :) thx again!
00:56:01 <ertes-w> trigone: back when Show didn't use the showList trick it was using overlapping to get the special behaviour for [Char]:  notice that 'show' on strings does not render a list of characters, but the string notation
00:57:33 <trigone> ertes-w: oh interesting
00:57:51 <ertes-w> trigone: the way Show does it is a safe way to implement such special cases, but it needs a knot in your synapses to understand =)
00:58:31 <ertes-w> it's not difficult, just a bit weird
00:59:31 * hackagebot type-combinators-singletons 0.1.0.0 – Interop between /type-combinators/ and /singletons/. – https://hackage.haskell.org/package/type-combinators-singletons
01:02:23 <trigone> ertes-w: it seems intriguing but i'll look into it later, for now i wanna go to bed but before that i want to solve my undecidable problem. i tried the newtype method, didn't work as well as i'd wished: http://lpaste.net/358131
01:03:50 <trigone> it seems despite the (WithEnv e m =>), the fundep (m -> e) is not propagated...
01:05:29 <trigone> maybe type families would be better at propagating such things?
01:05:41 <ertes-w> trigone: yes, likely
01:06:17 <ertes-w> trigone: but your Add class is suspicious to me
01:07:07 <ertes-w> it lacks a fundep, so it suggests that 'i' does not follow from 'm', but at the same time 'i' doesn't look like it plays any relevant role to the actual instance, so perhaps it shouldn't be an instance variable in the first place?
01:07:27 <ertes-w> class Add m where add :: (Num i) => i -> i -> m i; …
01:08:57 <mniip> class Over c g (g a) => Over (c :: k -> Constraint) (g :: k -> k) (a :: k) where { overDict :: Dict (c a); overDictG :: Dict (c (g a)); overDictG = overDict }
01:08:57 <ertes-w> if i really does follow from m, you should add the missing fundep, and that might resolve your issue
01:09:11 <mniip> yay UndecidableSuperclasses
01:10:14 <koz_> :t on
01:10:16 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
01:11:33 <trigone> ertes-w: oh you're right, the `i` is a mistake
01:12:47 <trigone> ertes-w: i'm not forced to put a Num constraint am i?
01:13:11 <ertes-w> trigone: if you don't, your instances can't do much with 'i' =)
01:13:32 <ertes-w> because they need to write 'add', 'sub' and 'mul' in such a way that they are fully polymorphic in 'i'
01:13:39 <trigone> ertes-w: hm true... but anyway it's just a trivial example, but you're right
01:14:43 <trigone> anyway, i tried using type families, and the type checker doesn't recognize the syntax. i write `class WithEnv m where Env m :: * ...` and it tells me (Invalid type signature: Env m :: ...     Should be of form <variable> :: <type>). i added language pragmas (actually i ad
01:15:04 <ertes-w> "type Env m"
01:15:28 <trigone> added TypeFamilies and TypeFamilyDependencies bc i didn't know which one was the right one... i'll admit i'm sort of going at it blindly
01:15:36 <trigone> ertes-w: ok thx!
01:16:26 <ertes-w> TypeFamilies is the right one…  you only need TypeFamilyDependencies, if you want to express bidirectional dependencies
01:16:38 <ertes-w> like the fundep (m -> a, a -> m)
01:18:28 <foojs> primes = filterPrime [2..]    where filterPrime (p:xs) =            p : filterPrime [x | x <- xs, x `mod` p /= 0]
01:18:44 <ertes-w> trigone: here is an example of TypeFamilyDependencies: class Lookup f where type Key f = k | k -> f; lookup :: Key f -> f a -> Maybe a
01:18:59 <ertes-w> this makes 'f' follow from the key type, so all you need for instance selection is the key
01:20:27 <trigone> ertes-w: ok i see, i think, sounds nice. is it a "dangerous" extension?
01:20:34 <trigone> btw how do i write constraints over values afterwards? like how to translate (C a b => b a -> a) when the `a` is not anymore visible?
01:20:57 <trigone> with C being a class, and it being the signature of some normal function
01:21:00 <ertes-w> trigone: no, it's safe…  all it does is to give type families the same expressivity as fundeps =)
01:21:11 <trigone> ertes-w: ok
01:21:32 <ertes-w> trigone: can you give an example?
01:22:28 <trigone> well in my paste of earlier, the function test is defined in terms of the environment value's type (since it outputs it among others) http://lpaste.net/358131
01:23:23 <ertes-w> trigone: 'a' is still visible, it's just called (Whatever m) now =)
01:23:54 <ertes-w> test :: (WithEnv m, AddEnv m, Monad m) => Whatever m -> m (Whatever m, Whatever m, Whatever m)
01:24:12 <ertes-w> s/Whatever/Env/
01:24:27 <trigone> ooh so the type function (family?) is scoped over the whole file, i thought it was internal to the typeclass, but obviously it's needed outside
01:24:37 <ertes-w> correct
01:26:25 <ertes-w> trigone: (class C a where type F a; …) is in essence just a nicer notation for: type family F a; class C a where …
01:28:52 <trigone> ertes-w: oh ok
01:33:31 <trigone> i'm a bit lost in my code... i had to create two type families (one for each class which required some fundep originally), each with a different name, and somehow both are kinda jealous of each other (but then that's family to you). if i choose the first the second complains, and vice versa... how am i supposed to handle this? http://lpaste.net/358131
01:37:18 <trigone> oh i get it, test being polymorphic it can't tell that both types would be equal... how can i tell haskell they're meant to be so? do i need more type-level wizardry?
01:37:33 <ertes-w> trigone: if B is a subclass of A, it will inherit A's families
01:38:05 <ertes-w> trigone: but if you need a common type family for multiple classes that aren't in a hierarchial structure, just create a separate family
01:38:19 <ertes-w> type family F a; class C1 a; class C2 a
01:38:36 <ertes-w> type instance F Int = …; instance C1 Int where …; instance C2 Int where …
01:39:50 <trigone> ertes-w:... ok... can't you advise me wrt my problem? cos honestly i'm not quite certain... i'd prefer my classes to not be in a hierarchy, rather, that i be able to describe *instances* in terms of other classes...
01:40:08 <koz_> I'm looking at slide 10 of this: https://dl.dropboxusercontent.com/u/4588997/Machines.pdf and am a bit confused by the Step type. What's the 'k' supposed to represent here?
01:40:15 <ertes-w> trigone: i thought i just did
01:40:40 <koz_> I know that 'o' is the value the step delivers, and r is the 'rest of what we gotta do', but the k I'm unclear on.
01:40:59 <ertes-w> koz_: k is kind of a constraint on what the input type is, not the input type itself
01:41:09 <trigone> ertes-w: but if i create a common type family, won't the classes be linked together or something? i'm not sure i understand what it entails...
01:41:16 <ertes-w> koz_: https://hackage.haskell.org/package/machines-0.6.3/docs/Data-Machine-Is.html
01:41:37 <ertes-w> koz_: you would use (k = Is a), if you want inputs of a specific type 'a'
01:41:53 <koz_> ertes-w: Ah, I see.
01:41:55 <koz_> That makes sense.
01:42:10 <ertes-w> trigone: no, the type family is not related to the classes at all
01:42:21 <ertes-w> it's basically just a type-level function
01:42:30 <trigone> to put things into context, the idea behind all this is related to EDSLs, and one main aspect of it is to be able to interpret (= write instance) a language (= class) in terms of other languages (= other classes). so far i haven't found examples in the wild so i'm trying to find how to do so...
01:42:33 <trigone> ertes-w: ok...
01:43:22 <ertes-w> trigone: wouldn't it be better to have types as languages and functions as interpreters?
01:43:34 <trigone> ertes-w: what if two instances over the same monad (the input of the type-level fun) are expected to have different Env types? mind you i'm saying that but i'm not sure it's not absurd wrt the semantics of the example
01:43:46 <trigone> ertes-w: you mean with ADTs?
01:44:05 <ertes-w> trigone: yes…  in fact i get a strong feeling that you're reinventing free monads
01:44:34 <ventonegro> "You could have invented Free Monads"
01:45:04 <trigone> ertes-w: nah i'm aware of free monads. actually i'm just trying to apply the alternative to free monads called "tagless final interpreters". cf http://okmij.org/ftp/tagless-final/course/lecture.pdf or http://yowconference.com.au/slides/yowlambdajam2016/Hopkins-StopPayingForFreeMonads.pdf
01:46:06 <trigone> i feel that if the issue of inter-language interpreting is resolved, it can be an equally competent alternative to ADTs, with a much simpler composition system, among others.
01:48:09 <ertes-w> trigone: ah, i'm not familiar with those…  i'll look at them later
01:50:41 <foojs> calm down haskell!
01:51:28 <ertes-w> trigone: ok, i think i understand the approach…  with the additional context in mind: yes, you should definitely use newtype for your overlapping problem =)
01:52:00 <trigone> ertes-w: well i tried, it didn't propagate the fundep...
01:52:09 <trigone> cf my paste
01:52:17 <trigone> second annotation i think
01:53:09 <trigone> though i didn't think of trying to put the constraint over the wrapper (but i have no idea what that'd entail)
01:53:11 <koz_> Whoever directed me to machines - they are really awesome and I wanna use them more.
01:54:03 <ertes-w> koz_: gushing over machines?  that might have been me =)
01:54:14 <koz_> ertes-w: Possibly, yeah.
01:54:30 <ertes-w> koz_: see concurrent-machines for some added joy =)
01:54:55 <koz_> Has anyone written any introductions to machines for the rest of humanity?
01:55:00 <koz_> (namely: people who aren't Edward)
01:55:37 <ertes-w> "The expression problem, like Sudoku, has gushed a fountain of various solutions and language features; see [24] for the history, the main approaches to the solution and references.  We now demonstrate the final approach."
01:55:39 <ertes-w> hahaha
01:57:21 <trigone> ertes-w: why the laughing? i must mention that "final" here means the opposite of initial, aka informally the opposite of ADTs. it doesn't imply it's the "ultimate approach"
01:57:23 <ertes-w> koz_: i don't think so, but here is an overview: you write stream processors in the PlanT language (think of it as BlueprintT), and then 'construct' (or 'repeatedly') it into a MachineT, which is the composition language
01:57:47 <ertes-w> koz_: in reality PlanT and MachineT have almost exactly the same relationship as FT and FreeT
01:58:56 <ertes-w> koz_: and then there are a few subtypes for your convenience:  in 'pipes' terms ProcessT corresponds to Pipe, and SourceT corresponds to Producer
01:59:20 <ertes-w> trigone: i know, i just loved the pun =)
01:59:22 <trigone> btw is there a way to write local bindings at the type level? something like foo :: forall m. let a = Env m in m a -> a --cos type families make things a bit verbose...
01:59:43 <trigone> ertes-w: ok ^^ yeah it's kinda funny :)
01:59:47 <merijn> trigone: Nope
02:00:03 <ertes-w> trigone: TypeFamilies enables equality constraints:  (Env a ~ t) => t -> t -> …
02:00:18 <ertes-w> trigone: but it's really more a syntactic hack than an explicit abbreviation feature =)
02:00:20 <trigone> ertes-w: hm that might do the trick
02:00:29 <trigone> ertes-w: but doesn't it work?
02:00:36 <ertes-w> it does
02:00:50 <trigone> then it's cool
02:00:55 <koz_> ertes-w: I might blog about it if I ever figure it out.
02:01:56 <ertes-w> koz_: if you don't, i might at some point…  i wanted to write about machines for a long time
02:02:02 <halogenandtoast> If I'm using Data.Graph, when building my graph do I need to make the edges bi-directional?
02:02:19 <halogenandtoast> [(1, 2)] vs [(1, 2), (2, 1)]
02:03:18 <merijn> halogenandtoast: You probably wanna use fgl rather than Data.Graph from containers
02:03:55 <halogenandtoast> merijn: I'll check out fgl
02:04:56 <halogenandtoast> the answer to my question is yes though.
02:05:04 <halogenandtoast> womp womp
02:06:15 <foojs> calm down haskell!
02:06:19 <foojs> calm down haskell!
02:08:00 <trigone> ok, my type family doesn't like me. apparently it can't take a tycon (* -> *) as parameter... Expecting one more argument to ‘m’       Expected a type, but ‘m’ has kind ‘* -> *’
02:08:18 <ertes-w> is there a library for arrays of integers with a fixed size that can be chosen dynamically on creation?
02:08:47 <halogenandtoast> merijn: what's the benefit of fgl over containers?
02:09:04 <ertes-w> trigone: for separate type families you need a kind signature on the variable
02:09:13 <ertes-w> trigone: type family F (m :: * -> *)
02:09:36 <trigone> ertes-w: ooh a type here. i thought it'd infer in from the type instance i wrote
02:09:38 <trigone> thx
02:09:38 <ertes-w> trigone: (if it's part of the class, the kind can be inferred from the other class members)
02:10:16 <merijn> halogenandtoast: FGL was written as part of a "how to make graph algorithms fast in a purely functional setting" effort. I have no clue how much containers copied from it
02:10:36 <ertes-w> trigone: no, instances are not used for inference, because inference otherwise it would depend on in which module you defined the instance
02:11:18 <halogenandtoast> merijn: Ah I don't really care about speed. The only thing I need to know is adjacency (or two steps away at most)
02:11:58 <halogenandtoast> I'll still check it out though.
02:13:06 <trigone> ertes-w: oh ok
02:16:27 <trigone> well i got a new problem: by using a newtype wrapper and a type family, i end up with the type family not recognizing Env (Wrapped m), since it only knows of Env m.
02:17:08 <trigone> is there a way to write Env (Wrapped m) = Env m?
02:17:13 <trigone> (forall m)
02:17:34 <trigone> :r
02:19:20 <trigone> hm it seems it accepted the equality, but i'm not sure bc i still have other issues, among which: i'd need to put a constraint over (Env m), specifically Num (Env m)... and ghci tells me ---> Non type-variable argument in the constraint: Num (Env m)       (Use FlexibleContexts to permit this)
02:19:24 <trigone> is it reasonable?
02:20:04 <ertes-w> trigone: type instance Env (Wrapped m) = Env m
02:20:26 <merijn> trigone: FlexibleContexts is fine
02:20:39 <merijn> trigone: THe report is very pedantic and limited in what it allows in constraints and instances
02:20:40 <ertes-w> trigone: a type synonym family acts like a type synonym
02:20:52 <ertes-w> so you can use it recursively
02:21:00 <merijn> trigone: In fact, I have high hopes for Haskell Prime enabling FlexibleContexts and FlexibleInstances by default
02:21:26 <trigone> well it doesn't like my Num (Env m) even with flexiblecontexts: --> The constraint ‘Num (Env (W m))’         is no smaller than the instance head       (Use UndecidableInstances to permit this) In the instance declaration for ‘AddEnv (W m)’
02:21:34 <trigone> merijn: ok, good to know :)
02:21:43 <trigone> ertes-w: thanks!  that's cool :)
02:22:24 <trigone> merijn: yeah but for the beginner, it's not always clear in fact what is reasonable or not :)
02:23:28 <merijn> trigone: The report basically says you can only have at most 1 type constructor (at the start) and the rest type variables in contexts. Which is rather restrictive
02:23:55 <trigone> yeah
02:25:29 <trigone> i feel i'm going in a bad direction... it shouldn't be that hard to interpret a language into another language in this version of EDSLs. i mean, it's not really worth it if you gain easy composability at the price of easy translation...
02:25:54 <koz_> I've just read up on co-and-contravariance for functors. However, I'm not quite clear why there doesn't exist some kind of functor-like thing whose only function would be something like (a -> b) -> (b -> a) -> f a -> f b. You could, for example, make an Endo instance of it. However, it doesn't seem to exist. Is there a reason why this is?
02:26:52 <opqdonut> koz_: there's bimap :: (a -> b) -> (c -> d) -> p a c -> p b d
02:27:14 <opqdonut> koz_: nah, that's the wrong way around
02:27:24 <trigone> maybe profunctors? i'm not sure
02:27:39 <opqdonut> dimap :: (a -> b) -> (c -> d) -> p b c -> p a d
02:27:40 <opqdonut> yeah
02:27:43 <koz_> opqdonut and trigone: Those both have kind * -> * -> *. I'm looking for something with kind * -> *.
02:28:13 <trigone> sorry :P
02:28:27 <koz_> s/Those/The kind of stuff we can define those on/
02:28:39 <trigone> http://hackage.haskell.org/package/invariant-0.4.3/docs/Data-Functor-Invariant.html
02:28:50 <trigone> hayoo found it for me :)
02:28:53 <opqdonut> nice
02:29:12 <koz_> And it has an Edward article called 'Rotten Bananas',.
02:29:15 <koz_> I don't even.
02:29:56 <trigone> haha rotten bananas... maybe there is a connection with the recursive schemes bananas?
02:30:08 <koz_> trigone: My first thought too.
02:31:20 <koz_> newtype Nu f  = Nu { old :: f (Nu f) } --so its not funny <-- oh ho ho
02:31:35 <koz_> (and yes, trigone, you were right)
02:32:13 <trigone> i didn't get your Nu thing
02:32:28 <trigone> unless it's the old/new thing
02:32:37 <koz_> trigone: ... It's not mine, it's Ed's.
02:32:42 <koz_> And yes, I think that was the point.
02:33:53 <trigone> koz_: no i meant your message, i know you were quoting. well at least nobody can say haskell is lacking on the bad pun department... 
02:34:13 <koz_> I groaned when it clicked.
02:34:22 <trigone> lol
02:36:00 <dminuoso> Mmm, list comprehensions seem like they're a special variant of list monads with do notation.
02:36:31 <dminuoso> Is this a right way to look at them?
02:36:42 <koz_> I'm gonna have to give Rotten Bananas a closer read.
02:36:52 <koz_> As well as some of the other papers it references, with equally absurdist names.
02:37:13 <trigone> dminuoso: well they're using alternative (aka applicative + empty, which allows the use of guard)
02:37:32 <trigone> but yeah it's just sugar
02:37:52 <dminuoso> trigone: Fair enough. I just cant wrap my head based on the initial introduction but list monads are easy.
02:38:08 <dminuoso> trigone: It's said everywhere that they are just sugar, but I cant find a concise way of doing them without that sugar.
02:40:06 <dminuoso> Ohhh! So it really is just a monad and the [ expr | ... ] is just the final return!
02:43:01 <dminuoso> Mmm, even guards seem quite "trivial" interesting.
02:43:35 <trigone> :t [x | x <- [0..], x < 4]
02:43:37 <lambdabot> (Ord t, Enum t, Num t) => [t]
02:46:04 <trigone> are list comprehensions inherently polymorphic or not?
02:46:27 <merijn> trigone: They're as polymorphic as they're inferred to be
02:46:37 <merijn> trigone: It's just that nothing in there uses any specific type
02:47:46 <trigone> merijn: hm... apparently they need monads (at least when one uses guard). can you use them with applicative only if there's no guard? and, is there a double constraint Monad and Alternative, or is it automatically transferred to MonadPlus?
02:48:38 <brynedwards> :t [x|x<-[]]
02:48:39 <merijn> trigone: What do you mean?
02:48:39 <lambdabot> [t]
02:48:43 <koz_> :t guard
02:48:44 <lambdabot> Alternative f => Bool -> f ()
02:48:55 <koz_> Your constraint is Alternative - Monad doesn't have to come into it.
02:49:32 <brynedwards> :t [x|x<-[const]]
02:49:33 <lambdabot> [a -> b -> a]
02:50:08 <trigone> merijn: are you sure they're polymorphic?
02:50:11 <trigone> :t let f :: Monad m => (Num t, Ord t) =>m t -> m t; f ma = [x | x <- ma, x < 4] in f
02:50:13 <lambdabot> error:
02:50:13 <lambdabot>     • Couldn't match type ‘m1’ with ‘[]’
02:50:13 <lambdabot>       ‘m1’ is a rigid type variable bound by
02:51:08 <koz_> Also, random question: Covariant monoidal functors are Applicatives; contravariant monoidal functors are Divisible; invariant monoidal functors are?
02:51:40 <brynedwards> :t let f :: (Monad m, Num t, Ord t) => m t -> m t; f ma = [x | x <- ma, x < 4] in f
02:51:42 <lambdabot> error:
02:51:42 <lambdabot>     • Couldn't match type ‘m1’ with ‘[]’
02:51:42 <lambdabot>       ‘m1’ is a rigid type variable bound by
02:51:52 <trigone> koz_: in theory that's true, but how do you write (do x <- xs; y <- ys; guard (x < y)) without bind? guard here is defined in function on x and y
02:52:04 <trigone> *of
02:52:05 <koz_> trigone: Are you using ApplicativeDo?
02:52:43 <trigone> koz_: ah so you need an extension?
02:52:54 <koz_> trigone: do-notation desugars into monads by default.
02:53:06 <koz_> With ApplicativeDo, it can desugar into Applicatives.
02:53:33 <koz_> (as an aside, should desugaring be renamed salting or dieting?)
02:53:45 <trigone> koz_: but how do you use empty (which is the result of guard) with a simple monad? to my knowledge not all monads are alternatives (but i could be wrong)
02:54:12 <koz_> trigone: Indeed they're not.
02:54:28 <koz_> :t empty
02:54:30 <lambdabot> Alternative f => f a
02:54:31 <trigone> haskell lite
02:54:47 <koz_> trigone: 99% sugar free.
02:55:12 <brynedwards> Is there a verb to make food savoury?
02:55:13 <trigone> koz_: the remaining sugar, i suppose, comes from the (rotten) bananas...
02:55:27 <koz_> brynedwards: Not to my knowledge.
02:55:28 <trigone> brynedwards: cook?
02:55:42 <koz_> trigone: Cakes need cooking, and quite a number are very much not savoury.
02:55:57 <koz_> I mean, 'vinegaring' could work.
02:56:10 <koz_> So we could say 'With ApplicativeDo, do-notation vinegars into applicatives.'
02:56:13 <lfairy> ensplenda
02:56:14 <brynedwards> synonyms.net says sour...
02:56:20 <trigone> koz_: well it's not a certain operation, more like cook :: Food -> Maybe SavouryFood
02:56:29 <koz_> brynedwards: 'sours into' I could get used to.
02:56:34 <lfairy> caramelize
02:56:41 <brynedwards> :D
02:58:46 <MichaelBurge> What's the easiest way to get a function pointer out of a "CDouble -> IO ()", that something expecting a C calling convention can invoke?
03:02:22 <koz_> Also, random question: Covariant monoidal functors are Applicatives; contravariant monoidal functors are Divisible; invariant monoidal functors are?
03:02:35 <trigone> there's a lot of echo in here :P
03:04:18 <koz_> trigone: I feel it helpful to re-ask questions that don't get answers periodically.
03:04:37 <trigone> koz_: i don't criticize i was just kidding
03:04:57 <trigone> wait but invariant is the link i gave you earlier. so there's no class defined in it?
03:05:21 <koz_> trigone: Correct, but I'm not asking baout the Functor equivalent. I'm asking about the Applicative equivalent based on it.
03:05:33 <koz_> Kinda like Applicative for Functor and Divisible for Contravariant.
03:05:38 <trigone> from the doc: "Every Functor is also an Invariant functor."
03:05:59 <koz_> Yes, because you can just ignore the other function.
03:06:07 <koz_> Much like every Contravariant is an Invariant functor too.
03:06:11 <trigone> ok...
03:07:45 <trigone> oh ok i hadn't read you correctly
03:08:59 <trigone> well based on the types i'd imagine something like (a ->b) -> (b -> a) -> f (a -> b) -> f b but neither hayoo nor hoogle know of it
03:10:08 <koz_> trigone: I might just wait around and see. Maybe edwardk might take notice.
03:11:54 <trigone> lol i just found out the divide/conquer thing. he really never takes a break, does he ^^
03:12:34 <koz_> trigone: Edward does a lot of magical things.
03:13:39 <trigone> koz_: i'm not sure if it helps, but i found some scala thingy that looks relevant (but i don't read scala and i barely get what you're seeking so) https://typelevel.org/cats/typeclasses/invariantmonoidal.html
03:13:56 <koz_> That appears #relevanttomyinterests.
03:14:04 <n__dles> I have a function foo :: Int -> (Int, Int) -> Bool ; How can I do 'map foo someInt [(1,1),(2,2)]' ?
03:14:33 <koz_> n__dles: map (foo someInt) [(1,1), (2,2)]
03:14:45 <trigone> "To better understand the motivations behind the InvariantMonoidal type class, we show how one could naturally arrive to it’s definition by generalizing the concept of Invariant functor. This reflection is analogous to the one presented in Free Applicative Functors by Paolo Capriotti to show how Applicative are a generalization of Functor."
03:15:17 <koz_> I dunno Scala, so this is a little harder for me to read than it would be, but it does appear relevant. Thanks trigone!
03:16:52 <n__dles> koz_: partial application,duh. haven't done any functional programming in a while. tks!
03:17:06 <koz_> n__dles: It's fine - I forget about this all the time and write useless lambdas.
03:17:53 <trigone> np... i'm a bit miffed that some scala people would have written something abstract that haskell wouldn't already have... :P it wouldn't do. esp since they have so much more merit, to code such tools in such a terribly unreadable language... ^^
03:18:48 <koz_> trigone: I'll eventually make sense of it and write a blogpost about it. :P
03:20:55 <trigone> :) well i'll probably read it (the day i know enough to understand it)
03:39:57 <edwardk> koz_: what might i notice?
03:41:05 <koz_> edwardk: I just found invariant functors and was wondering if there was an equivalent to Applicative for them.
03:41:11 <koz_> Kinda like how Divisible is for Contravariant.
03:41:13 <edwardk> koz_: yes
03:41:48 <koz_> I found something in Scala describing (what I think is) that very thing, but I can't read Scala syntax to save my life.
03:41:49 <edwardk> its not packaged
03:41:56 <edwardk> but the concept works just fine
03:42:07 <koz_> So how would it be defined?
03:42:12 <edwardk> there is a similar construction you can build with Profunctors
03:42:33 <edwardk> define it for points and pairs, then add the morphisms after
03:42:53 <edwardk> both :: f a -> f b -> f (a,b); one :: f ()
03:43:30 <koz_> That's similar to https://wiki.haskell.org/Typeclassopedia#Alternative_formulation
03:43:32 <edwardk> now you also know that f is an invariant functor, so it may be nicer to allow bothWith :: (a -> b -> c) -> (c -> (a, b)) -> f a -> f b -> f c
03:43:54 <edwardk> and one :: (a -> ()) -> (() -> a) -> f a
03:44:05 <edwardk> except the former part is trivial (a -> ()) is terminal
03:44:06 <edwardk> so
03:44:23 <koz_> (() -> a) -> f a is what we'd actually write, right?
03:44:25 <edwardk> one :: (() -> a) -> f a -- but then (() -> a) is defined by a.
03:44:29 <edwardk> one :: a -> f a
03:44:32 <koz_> So that's pure?
03:44:37 <koz_> (or rather, the equivalent of pure)
03:44:43 <edwardk> assuming that 'a' is a type with only one element
03:44:54 <edwardk> which is a contract i can't check for you in haskell
03:45:20 <edwardk> and with that you've simplified it all the way down to a usable(ish) api
03:45:43 <koz_> Why does 'a' have to be a type with only one element?
03:46:03 <edwardk> because the invariant functor assumed you were mapping with a pair of morphisms that are an isomorphism
03:46:27 <edwardk> you can define weaker assumptions
03:46:44 <edwardk> eg. that they form a section/retract pair, etc. but the category is harder to use for lots of stuff then
03:47:00 <koz_> So wait, if 'a' can only have one element, does that mean it's Proxy?
03:47:27 <edwardk> () has one element, data Foo = Foo has one element. it is isomorphic to (), so we usually just say its ()
03:47:55 <edwardk> you have some options for how to encode it, its probably best to just let one :: f () -- exist and make the user xmap or whatever it away
03:48:04 <koz_> Ah, I see.
03:48:06 <edwardk> with the 'both' thing its pretty convenient to fuse the map into the combinator
03:49:20 <edwardk> mathematicians like to talk about 'the terminal object' in a category, because they don't like to reason about object identity. its 'evil' (literally, that is the term they used to use). that way they can consider isomorphic objects equal. if you can do the same things with it it is in some sense the same. yet haskell forces you to be evil in your formulation
03:49:49 <koz_> Yeah, because we need to deal with actual equality.
03:50:14 <edwardk> the key word when i put 'the terminal object' in quotes was 'the' -- with evil reasoning you need to worry about 'a' terminal object
03:50:28 <edwardk> and we just pick one as an exemplar of the set
03:51:29 <edwardk> HoTT and the like allow a more mathematician-like way to talk about equalities. it is one of the reasons why it is so interesting.
03:52:13 <koz_> So the type class in question would have one :: f () and both :: f a -> f b -> f (a, b), correct? Just wanna make sure I understood correctly.
03:52:26 <edwardk> yeah
03:52:33 <edwardk> probably with better names
03:52:40 <edwardk> just needed something to start
03:53:28 <koz_> And the laws are similar to the ones here? https://wiki.haskell.org/Typeclassopedia#Alternative_formulation
03:53:47 <edwardk> then you can view such an invariant functor as a monoid object in the category of invariant functors, those two operations are the eta and mu of the monoid (mempty/mappend)
03:54:07 <edwardk> same laws with fmap replaced with xmap or whatever
03:54:38 <koz_> invmap I think the invariants package calls it.
03:54:46 <edwardk> if a category C is monoidal, then Core(C) is monoidal.
03:54:53 <edwardk> Core(C) is the category of isomorphisms in C.
03:55:09 <edwardk> yeah, i used xmap when i wrote my rotten bananas article way back when
03:55:23 <edwardk> http://comonad.com/reader/2008/rotten-bananas/
03:55:25 <koz_> Yeah, I just read a bit of it now. Still need time to fully graps everything in it.
03:55:36 <koz_> Well, not now, but 'in the last hour or so'.
03:55:38 <edwardk> note: that article uses a notion of a section/retract pair
03:55:40 <edwardk> not inverses
03:55:44 <edwardk> just one sided inverses
03:55:53 <koz_> Is that the 'harder thign to work with' you mentioned previously?
03:56:17 <edwardk> yeah
03:56:30 <koz_> Ah, I see.
03:56:33 <edwardk> it permits more stuff, so its harder to reason about what you can do with it
03:56:45 <edwardk> e.g. there its possible to write
03:56:53 <edwardk> a place function such that        cata f . place = id
03:57:06 <edwardk> even though place isn't ana g for some anamorphism that does the opposite of f
03:57:34 <koz_> Ah, yeah, I see, given what invariants of this kind represent.
03:57:34 <edwardk> this is the big move between the meijer-hutton catamorphism and the fegaras sheard catamorphism
03:57:37 <koz_> (isomorphisms)
03:58:03 <edwardk> well, here we just have pairs of  f and g such that f . g = id -- g . f can be whatever it wants
03:58:16 <edwardk> thats the section/retract situation thing i mentioned
03:58:29 <koz_> But normally, we'd need f . g = g . f = id?
03:59:01 <edwardk> well, each of these concepts is useful. =) f . g = id   or g . f = id  or neither or both
03:59:10 <edwardk> so there are 4 classes you want at least ;)
03:59:27 <koz_> Wait, how would the 'neither' situation work exactly?
03:59:32 <edwardk> you can get rid of 1 of the 4 by adopting a convention
03:59:44 <edwardk> the neither convention just allows whatever pairs of functions you want
04:00:00 <edwardk> they are perfectly legitimate to compose this way, there is a perfectly fine category, etc.
04:00:09 <koz_> Is it actually useful?
04:00:09 <edwardk> (a -> b) -> (b -> a) -> ....
04:00:14 <edwardk> nothing says those functions are related
04:00:26 <edwardk> its a category you can build.
04:00:32 <koz_> Yeah, I see what you mean.
04:00:37 <koz_> Which one of the four could we get rid of?
04:00:42 <koz_> (by adopting a convention)
04:00:58 <edwardk> and if you look at gibbons writeups about my lens stuff they use the profunctor stuff to morally say that the lens laws don't need to exist because nothing relates the (s -> a)  and (b -> t) functions
04:01:29 <edwardk> (which reminds me i need to write up the groupoid optics article to show what the profunctor encoding is approximating, and put this on firmer footing to show that really the functions are related)
04:01:58 <koz_> I wonder why nobody's written up invariant applicatives as a library yet...
04:02:06 <edwardk> you can pick the direciton that f . g = id              by just saying that is the direction of the relationship and the g . f = id just takes the arguments in the other order
04:02:15 <edwardk> because they are rigid enough that they suck to use
04:02:59 <edwardk> the typical scenario you want is actually the f . g = id version, not the isomorphism version. the examples like parse . pretty = id  all fit this flavor
04:03:15 <edwardk> also the fegaras-sheard catamorphism
04:03:31 <koz_> I guess I need to read your Rotten Bananas article. :P
04:03:42 <edwardk> splitting the arguments apart into two arguments gets you profunctors
04:03:49 <edwardk> then you can work with the parse side and the pretty side independently
04:03:55 <koz_> Yeah, that much I follow.
04:04:23 <edwardk> data PrettyParser a b = PrettyParser (a -> Doc) (Parser b)
04:04:31 <edwardk> is a perfectly good profunctor
04:05:24 <edwardk> and if you map over it with those section-retract pairs those operations are all well behaved.
04:06:24 * hackagebot tasty-discover 4.0.0 – Test discovery for the tasty framework. – https://hackage.haskell.org/package/tasty-discover
04:07:23 <koz_> edwardk: OK, thanks - I'll process this stuff for a while and hopefully understand it. I appreciate the run-through. :)
04:07:32 <edwardk> np
04:08:00 <edwardk> i'm currently sitting here trying to build a boatload of containers with cheap repositioning for a toy project
04:10:21 <edwardk> e.g. if i take some Delta data type for change in position. and define 'Relative' data structures as ones such that Delta acts on them: rel :: Delta -> a -> a  -- there is a lot of structure that can have. e.g. i can have relative monoids such that rel d (x <> y) = rel d x <> rel d y -- rel d might be monotone, etc.
04:10:40 <edwardk> sums of relocatable things are relocatable, products of them are
04:10:44 <edwardk> so we can do the same generic construction
04:10:53 <edwardk> we can talk about relocatable functors. 
04:11:25 <koz_> edwardk: Will this be another library some day?
04:11:28 <edwardk> we can talk about whether some delta function that measures a data type is relocatable, ifthe delta function distributes over the monoid, is ordered...
04:11:44 <edwardk> then we can talk about how to 'slow down' the relocation for maps and lists and things
04:12:24 <edwardk> data List a = Nil | Cons !Delta a (List a); uncons (Cons d a as) = Just (rel d a, rel d as); uncons Nil = Nothing
04:12:48 <edwardk> rel d (Cons d' a as) = rel (d <> d') a as; rel _ Nil = Nil
04:12:56 <edwardk> makes relocating the entire list O(1)
04:13:01 <edwardk> as the cost is moved to access
04:13:21 <edwardk> you can do the same thing for maps and hashmaps and sets with relocatable keys and values
04:13:54 <edwardk> so long as the keys are strict relocatable orders, e.g.  x < y  implies rel d x < rel d y
04:14:02 <edwardk> koz_: right now its a part of my current toy project.
04:14:18 <edwardk> i may well factor it out, but the notion of 'which delta to use' is pretty peculiar
04:14:36 <edwardk> in my case i'm choosing it to be a number of utf-16 code-units since the start of some input
04:14:58 <edwardk> so i can parse parts of the input separately, then use 'relative' syntax trees to graft everything together
04:15:10 <edwardk> such that the relocation is 'slowed' down to O(1)
04:16:27 <Axman6> edwardk: what do you mean by relocation?
04:16:29 <edwardk> the list example isn't useful for that scenario, they are too expensive to append, but you can make a list that does have cheap append using okasaki, tweak the structure with deltas that get pushed through slowly and go to town
04:17:04 <edwardk> consider a toy language such that my lexer can be restarted sanely on every line. (remove multiline comments, make some other tweaks)
04:17:15 <edwardk> now i can parse each line independently into a stream of lexemes
04:17:31 <edwardk> maybe even parse them if i can use layout or something to figure out that i can start a parser here
04:17:39 <edwardk> i'm over simplifying for discussion
04:18:02 <edwardk> now we can merge these partial parses for separate statements, but the locations reported by the second half are relative to the start of its line or whatever, not the total file
04:18:17 <edwardk> so i need to add the amount of "stuff" before it to all the positions in the token stream
04:18:27 <edwardk> i want this 'shift' to be O(1)
04:19:17 <edwardk> so say parser a is fed 4k and parser b is fed another 4k, i need to shift all the locations in the output of parser b, which doesn't know 'where' it is in absolute terms by 4k to combine the results.
04:19:37 <edwardk> in practice i'm not working fully monoidally at the character level, but rather at the line level
04:20:30 <edwardk> https://github.com/ekmett/coda/tree/master/src/Coda/Relative provides some concrete classes and data types. (the maps and stuff need to get written yet)
04:21:34 <edwardk> once i have those deltas, which aren't terribly helpful for users, i can convert them to positions i can report in something like visual studio code with something like https://github.com/ekmett/coda/blob/master/src/Coda/Syntax/Line.hs#L123
04:22:25 <edwardk> the idea is to fold the parse errors up the finger tree as relative errors, then when we're at the top we're in absolute position and can report them to the client
04:23:09 <kahlil29> best resource to understand and learn Monad Transformers? 
04:23:44 <edwardk> invariants i the grammar about the behavior of layout keywords, lambdas, definition syntax, etc. will let me deal with things like computing name capture, shadowing, etc.
04:23:48 <edwardk> Axman6: that help?
04:24:02 <edwardk> kahlil29: try writing them from scratch
04:24:34 <edwardk> newtype ReaderT e m a = ReaderT { runReaderT :: e -> m a }
04:24:51 <edwardk> writing the instance Monad m => Monad (ReaderT e m) -- is quite informative
04:24:59 <edwardk> also figuring out how to write ask and local, etc.
04:25:31 <edwardk> mutatis mutandis for StateT, WriterT, etc.
04:25:36 <koz_> kahlil29: For something that might be a bit quicker: https://wiki.haskell.org/Typeclassopedia#Monad_transformers
04:25:49 <edwardk> or that ;)
04:26:09 <koz_> Generally, 'Read the Typeclassopedia. Then read it again.' makes for good advice on doing most Haskell things. :P
04:27:04 <merijn> koz_: Other good advice: Read the Haskell Report (most never do). Skim/read the GHC manual (it's surprisingly in-depth and good). Read the STG paper for a feel about laziness
04:27:54 <edwardk> i learned my way through monad transformers by reading https://www.cs.rit.edu/~swm/cs561/All_About_Monads.pdf 
04:28:05 <edwardk> (and reading a bunch of old wadler papers on examples)
04:28:05 <koz_> Yet more good advice: Watch lots of talks  by edwardk. Even if you only understand 5% of it at first. :P
04:28:17 <brynedwards> I found this useful https://github.com/data61/fp-course
04:28:49 <merijn> kahlil29: Actually, my usual recommendation for understanding transformers is: Try and implement StateT yourself
04:29:25 <merijn> khatri: Start by implementing State, then generalise it to StateT. I wrote out the homework here: https://gist.github.com/merijn/098106abd45c940dab09
04:30:19 <kahlil29> wow thanks all of you edwardk: koz_: merijn: 
04:30:37 <koz_> kahlil29: You're welcome. #haskell is a warm, welcoming, fuzzy place.
04:30:42 <koz_> We're the capybara of chans.
04:30:48 <koz_> (that might have been a sp)
04:31:25 <edwardk> Now I'm viewing #haskell as https://www.youtube.com/watch?v=uluz4FQklY0
04:31:57 <kahlil29> hahaha
04:31:58 <koz_> edwardk: Yep, pretty much.
04:32:10 <koz_> We're all capybaras, chilling in an onsen.
04:32:47 <jakub> hi, i am pretty sure this is somehow possible but I don't know how... i have long list of constraints on some of my functions, and I would like collapse the constraint for readability, I know I could define a dummy multiparamtypeclass that requires all the constraints for all of its instances but then I would need to explicitelly declare the instances, is there any way to introduce "constraint synonyms" or 
04:32:53 <jakub> something like that?
04:33:10 <cocreature> jakub: yes, enable -XConstraintKinds and use types synonyms
04:33:42 <jakub> cocreature: thanks, i didn't notice this extension
04:34:09 <cocreature> "type Stringy a = (Read a, Show a)" is the example in the user guide iirc
04:34:36 * ertes-w just made a kinda surprising observation: python's hash tables are slower at lookups than haskell's HashMap, but faster at insert…  the latter is not that surprising, but the former certainly is
04:35:19 <cocreature> ertes-w: for what workload? I would be surprised if that holds in general
04:36:04 <ertes-w> i've implemented the baby-step-giant-step algorithm in both to compare, and haskell beats python at the search phase, but loses to it in the construction phase
04:36:23 <cocreature> heh I actually had to implement that for a cryptoclass not too long ago
04:37:02 <cocreature> I’ve ended up using the hashtables package but I think I’ve only compared unboxed vector + binary search and hashtables. I haven’t tested HashMap
04:37:10 <edwardk> jakub: two ways. type Stringy a = (Read a, Show a) -- has the downside that users have to turn on {-# language ConstraintKinds #-}
04:37:23 <edwardk> the other way puts the burden on you the library author to use more extensions
04:37:23 <ertes-w> cocreature: HashMap destroys hashtables
04:37:39 <edwardk> class (Read a, Show a) => Stringy a; instance (Read a, Show a) => Stringy a
04:37:48 <edwardk> with UndecidableInstances
04:37:54 <cocreature> ertes-w: when I did compare them for some other project that hasn’t been the case ime
04:38:16 <ertes-w> cocreature: https://gist.github.com/esoeylemez/49a275477aac21bb551b65ff7b52ded1
04:38:21 <cocreature> but that has been quite some time ago. maybe things changed
04:38:22 <edwardk> the latter has the benefit that you can talk about 'Stringy :: * -> Constraint' as its own thing whereas the type synonym can only be used fully applied
04:38:44 <ertes-w> cocreature: bsgs2 is twice as fast as bsgs1 at pretty much everything, both construction and search
04:39:22 <edwardk> cocreature: note: if you are going to use a real hash table, use a better hash function than that provided by Hashable
04:39:49 <edwardk> Hashable produces pretty lousy hashes for most applications, but since HashMap uses them nybble reversed effectively its fine.
04:39:55 <ertes-w> the hash function is fine for this particular case, because the keys are pretty much fairly random
04:40:10 <ertes-w> s/fairly//
04:40:45 <ertes-w> so hashtables can't take that as an excuse =)
04:40:52 <edwardk> np
04:40:55 <ertes-w> s/take/use/
04:41:24 <ertes-w> i sack ät inglisch tudäi
04:41:46 <edwardk> i do get some use out of fast linear probing hash tables with simple tabulation hashing, it can beat hashmaps for when you are going to not use persistence, but its a lot of infrastructure to build
04:42:46 <edwardk> but you need a good simple tabulation hash or 5-wise independent hash function to get exepected O(1) chain lengths w.h.p.
04:43:00 <edwardk> and Hashable sure ain't that
04:43:18 <ertes-w> i have tried all three implementations of hashtables, and the basic one turned out to be the best
04:43:33 <edwardk> i haven't used the package
04:43:55 <ertes-w> it's not that surprising, because BSGS benefits from fast lookups
04:43:56 <edwardk> every time i've gone to i've needed something it didn't offer
04:44:18 <edwardk> basic is their linear probing version?
04:44:43 <ertes-w> yeah
04:45:53 <edwardk> https://people.csail.mit.edu/mip/papers/charhash/charhash.pdf is a good read on why simple-tabulation-hashing is awesome
04:48:10 <edwardk> in haskell you can build a lazy list of all the hash functions involved, and just hash using serialization through a builder that gets parsed by the functions to get a result and a current entry in the lazy list  of functions at the end.
04:48:20 <edwardk> its just running down the list using the list as your state
04:49:13 <edwardk> then you can have some pretty strong guarantees about the length of your linear probing chains for hash tables using those hashes
04:49:41 <edwardk> taking lookups down to something like 10% slower than memory accesses
04:50:06 <edwardk> in exchange for a messier initial hash calculation
04:53:07 * ertes-w only has very basic knowledge about hash tables
04:55:31 <foojs> bye all
04:55:35 * foojs back to java world
05:13:20 <jakub> edwardk: thanks
05:41:18 <orion> edwardk: Hey.
05:43:11 <orion> Are you still in NYC? If so, how is that treating you?
05:46:22 <merijn> There's not version of System.Process that works with Text, right?
05:53:15 <cocreature> merijn: process-extras has some support for that but it also changes the API in other ways that I didn’t like when I last looked at it
05:57:37 <ertes-w> merijn: which part?  the parametrisation or the I/O?
05:58:13 <merijn> ertes-w: Mostly the IO, but everything would be nice
05:59:27 <Psybur> Does anybody else have a hard time with Just? Every time I see it I cannot get the meme out of my head. JUST
06:00:13 <Psybur> http://i0.kym-cdn.com/photos/images/facebook/000/966/457/29e.jpg
06:00:25 <Akii> Psybur: Maybe
06:00:53 <Akii> https://image.spreadshirtmedia.com/image-server/v1/mp/compositions/1020402791/views/1,width=300,height=300,backgroundColor=E8E8E8,version=1498225413/perhaps-cow-meme.jpg
06:01:00 <rudol> given (.) :: (b->c)->(a->b)->a->c; map :: (p->q)->[p]->[q]
06:01:01 <ertes-w> merijn: well, you could just read from the handles yourself
06:01:07 <ertes-w> for I/O
06:01:08 <rudol> to derive the type of (. map)
06:01:12 <merijn> ertes-w: But I'm lazy :(
06:01:16 <rudol> 1. note that map is in the (a->b) pos of .(.) so a is (p->q) and b is ([p]->[q])
06:01:22 <rudol> 2. now by .......... we are left with (b->c)->a->c
06:01:26 <merijn> ertes-w: And was hoping someone had already written that for me :p
06:01:28 <ertes-w> merijn: i figured =P
06:01:29 <rudol> 3. by substitution for a and b from 1 we get (([p]->[q])->c)->(p->q)->c 
06:01:48 <cocreature> ertes-w: iirc getting that right with the various possibilities for failures can be quite tricky if you want to replicate the behavior exposed by the process library
06:01:50 <rudol> what is the correct  ......... in 2
06:03:17 <rudol> in 1. s/.(.)/(.)
06:03:54 <cocreature> hm looks simpler than I remembered
06:04:56 <lyxia> rudol: you can either say that it's a custom typing rule of operator sections, or that this is sugar for \y -> y . map
06:04:58 <ertes-w> cocreature: i don't see a lot of potential for exceptional failure cases
06:05:00 <dminuoso> Mmm, I have the desire to transform a value over a few steps in an imperative fashion. Is it silly to first pack it into an empty array [a] and then use the monadic interface?
06:05:02 <edwardk> orion: i'm in boston at the moment. (been visiting off and on down to nyc, but haven't moved yet)
06:05:16 <edwardk> orion: about to hop on a plane to icfp tonight
06:05:28 <ertes-w> cocreature: perhaps there needs to be some SIGHUP override trickery to make it safe
06:05:33 <merijn> bleh
06:05:40 <merijn> naming generic worker functions is hard...
06:05:53 <cocreature> merijn: "go" :)
06:06:00 <merijn> cocreature: Doesn't quite fit here
06:06:02 <ertes-w> merijn: i have like 20 functions named "go" in every module =)
06:06:10 <cocreature> merijn: how about "go'"?
06:06:19 <barrucadu> If you have two similar ones, "go1" and "go2" can be nice
06:06:23 <barrucadu> It even scales!
06:06:30 <ertes-w> sometimes i have "begin" and "go"
06:06:47 <Akii> "commence"
06:06:49 <barrucadu> And people say Haskellers can't name things...
06:07:09 <lyxia> dminuoso: what does it mean to pack a value into an empty array
06:07:17 <Myrl-saki> barrucadu: Yeah, but go2 sounds like goto, so you use go3 instead.
06:07:29 <merijn> cocreature: My main basically exists of "bracket (connectTo "" (UnixSocket sockPath)) sClose $ sendRequest" so having a main that's just "go `catch` (f >> go)" seems a bit...unideal
06:08:14 <ertes-w> Myrl-saki: i'm gonna go6, if i go4 removing all instances like go2
06:08:17 <rudol> is it something like "by applying (.) to map, as its second argument we are left with ..."?
06:08:40 <lyxia> rudol: sounds good
06:09:24 <Myrl-saki> ertes-w: lmao
06:09:31 <merijn> Relatedly...why don't the Network docs list which exceptions can be thrown...
06:09:35 <merijn> ugh
06:09:49 <rudol> lyxia, thanks, but it seems like I got the (b->c)->a->c in 2. by chance more than a process I  could repeat
06:10:32 <rudol> my step 1 is OK, I can repeat that for other functions/args
06:10:42 <rudol> same for my step 3
06:11:07 <rudol> but step 2.  - I can get the answer but can't describe how!
06:11:23 <dminuoso> lyxia: Sorry I meant just putting a single value into a list just so I can work with do notation
06:11:25 <lyxia> rudol: I would say that (. map) = (\f -> f . map)
06:11:39 <lyxia> dminuoso: why a list in particular
06:11:50 <dminuoso> lyxia: No reason in particular
06:11:51 <rudol> yes, I tried that too, but then step 2 becomes what?
06:11:55 <ertes-w> merijn: because the exceptions are semantically meaningless anyway?  if you don't need portability, better check errno
06:12:09 <rudol> f must be (b -> c)
06:12:22 <rudol> and subs [p] -> [q] for b
06:12:28 <dminuoso> lyxia: Maybe is probably a good option too. :)
06:12:31 <merijn> ertes-w: Eh...wut?
06:12:43 <merijn> ertes-w: How the fuck are the exceptions semantically meaningless?
06:12:58 <rudol> and then what?
06:13:37 <lyxia> rudol: (.) f :: (a -> b) -> a -> c        (.) f map :: a -> c       \f -> (.) f map :: typeOf_f -> (a -> c)
06:13:48 <anikaiful> 'alo
06:13:54 <ertes-w> merijn: maybe i'm stupid, but i found it surprisingly difficult to distinguish transient errors (like timeouts) from fatal errors (like connection refused)
06:14:23 <ertes-w> merijn: (i was writing a wrapper function that would retry the operation if a transient error occurred)
06:14:27 <merijn> ertes-w: You're forgetting all file-like errors you can get from unix sockets
06:14:47 <xphobia> Hello!
06:14:54 <rudol> lyxia, ty.
06:14:56 <lyxia> dminuoso: Yes you can do that. It's not silly at all.
06:15:17 <lyxia> rudol: yw
06:15:21 <xphobia> Anyone know haskell in here?
06:15:31 <anikaiful> I know that I don't know :D
06:15:38 <ertes-w> merijn: i'm not forgetting those…  on unix-likes IOException includes errno information, and i found that to be the only reliable way to distinguish certain errors
06:16:13 <merijn> ertes-w: If I don't know which exceptions can be thrown how am I ever sure that some error condition I didn't remember doesn't take down my entire application?
06:16:42 <ertes-w> merijn: by using a catch-all handler?
06:16:49 <merijn> Haskell's unchecked exception are a crime against humanity :\ I wish we had checked IO exceptions
06:17:05 <merijn> I should really get back to designing a type system for that
06:17:21 <ertes-w> merijn: if you catch SomeException, you catch everything
06:18:11 <anikaiful> hmm, checked IO exceptions... that's pretty much dependant on stuff any given OS throws at ya...
06:18:21 <merijn> ertes-w: Yeah, but I dunno which things I want to handle specifically and which I want to give up on if I don't know what to expect
06:18:28 <merijn> anikaiful: Why?
06:18:46 <anikaiful> well, in general, I mean
06:18:55 <ertes-w> merijn: as far as i have observed all network-related errors are thrown as IOException
06:19:18 <merijn> ertes-w: Maybe? Who knows? It's certainly not in the docs
06:20:28 <xphobia> I'll be right back
06:20:40 <ertes-w> merijn: i get your point, but short of suggesting to report a documentation bug or submitting a patch i can only help you by telling you my network story =)
06:22:25 <ertes-w> BTW, if you design a type system for IO exceptions that doesn't suck, i'll be your first user =)
06:22:54 <anikaiful> I'll second that
06:23:12 <ertes-w> minimum requirement: exception inference, so i can use PartialTypeSignatures
06:23:54 <merijn> ertes-w: Yeah, basically I think you need a sort of "parallel" types that track track (potential exceptions) and let them be inferred so you can write exception polymorphic code
06:24:09 <merijn> ertes-w: I have some reasonable ideas on how to do it, but no money to actually work on a prototype :)
06:24:42 <orion> edwardk: Cool. Safe travels!
06:24:50 <ertes-w> merijn: the first thought that came to my mind was an indexed IO monad
06:25:08 <merijn> ertes-w: I don't think so
06:25:17 <merijn> ertes-w: I wrote a position paper a while back arguing against this
06:25:48 <ertes-w> merijn: you could certainly do it without, but then you need to delimit exception boundaries, which may become very ugly very quickly
06:25:54 <merijn> ertes-w: Where I basically argue that you don't want to clutter more operational behaviour into your functional types, because they become so ugy and messy
06:26:14 <merijn> ertes-w: Well, find some people to fund me and I'll get on it ;)
06:26:16 <anikaiful> @merijn \o/ kickstarter project to collect funds
06:26:16 <lambdabot> Unknown command, try @list
06:26:39 <[exa]> Hm guys. Is there an useful example of polymorphic recursion?
06:26:57 <ertes-w> merijn: not that i'm stingy, but i'd more likely just research this one myself =)
06:27:07 <Ferdirand> [exa]: finger trees maybe ?
06:27:11 <ertes-w> [exa]: Data.Data
06:27:26 <[exa]> Ferdirand: how?
06:28:07 <ertes-w> [exa]: another one is locally nameless encodings of languages
06:29:46 <Ferdirand> [exa]: not sure if I understood your question properly, but
06:29:49 <Ferdirand> http://www.staff.city.ac.uk/~ross/papers/FingerTree.html
06:30:12 <[exa]> whoa, data.data is brutal :]
06:30:58 <[exa]> Ferdirand: I meant e.g. the polymorphic recursion that forces haskell typechecker to run occur checks
06:31:40 <ertes-w> [exa]: the latter may be easier
06:31:42 <[exa]> ertes-w: 'locally nameless encoding of languages' ...related to existentials?
06:31:54 <ertes-w> [exa]: data Expr a = App (Expr a) (Expr a) | Lambda (Expr (Maybe a)) | Var a
06:32:03 <ertes-w> use nested Maybe to encode de bruijn indices
06:32:08 <anikaiful> I vote for Haskell to be renamed to Hacksell... rolls off tongue easierr.
06:33:04 <[exa]> ertes-w: that's polymorphic recursive type right?
06:33:15 <dysfun> haskell rolls off my tongue easily enough
06:33:17 <ertes-w> [exa]: no, but functions you write on this type are
06:33:20 <aarvar> [exa]: also, pretty much anything using dependent types
06:33:33 <aarvar> or faking them, in the case of haskell
06:33:35 <[exa]> I might have misspecified that, how's a function that calls (possibly infinite) variants of itself called?
06:33:59 <ertes-w> polymorphic-recursive =)
06:34:47 <[exa]> oh there's maybe in Expr there, I see. That's a good example, thanks a lot
06:35:03 <[exa]> aarvar: yeah that's expectable :]
06:36:34 <anikaiful> dysfun: hask, has an abrupt 'stop' innit whereas 'hacks' doesn't...
06:36:36 <ertes-w> [exa]: Nothing represents the innermost binder (de-bruijn 0), Just Nothing represents the level just above it, etc.
06:36:43 <ertes-w> [exa]: and 'a' is the type of free variables
06:37:25 <ertes-w> example:  Lam (App (Var Nothing) (Var (Just "x"))) :: Expr String
06:37:27 <[exa]> Any formal (say, automatic) method to make this non-polymorphic?
06:37:35 <c_wraith> monochrom: Dependent Haskell isn't dead yet! http://dl.acm.org/citation.cfm?id=3110275
06:37:50 <ertes-w> [exa]: represents: (\f -> f x)
06:38:09 <dysfun> anikaiful: hass-cull. there is a glottal stop, but it flows easily enough
06:38:26 <ertes-w> [exa]: or written with de bruijn indices:  \0 x
06:38:36 <[exa]> yeah
06:38:43 <aarvar> [exa]: e.g. `append :: Vect n a -> Vect m a -> Vect (n + m) a` needs to recurse with vectors of different lengths
06:39:12 <anikaiful> dysfun: it certain does, sure :D... but my variant still is more fluid (note: IMO)
06:39:30 <ertes-w> [exa]: well, you can translate this into a representation that has named binders =)
06:40:18 <dysfun> anikaiful: well, i refer to unclean haskell as 'hackskell', so...
06:40:26 <Ferdirand> data FingerTree a = ... | Deep (Digit a) (FingerTree (Node a)) (Digit a)
06:40:29 <Ferdirand> does that qualify ?
06:40:50 <ertes-w> [exa]: challenge: write this function: closed :: Expr a -> Maybe (Expr b)
06:40:55 <[exa]> Ferdirand: oh so, finally got it :] qualifies, thanks :]
06:41:53 <ertes-w> [exa]: such that it satisfies the law:  closed >=> closed = closed
06:42:05 <anikaiful> dysfun: isn't it all such? "Guilty until proven otherwise".
06:42:31 <[exa]> ertes-w: working on it :]
06:45:09 <merijn> With System.Process if I want stdout and stderr on the same handle I need to manually create a pipe and pass that to the subprocess, yes?
06:46:20 <codedmart> I seem to have forgotten again. I am looking for `(m a, b) -> m (a, b)`?
06:46:29 <codedmart> My hoogle fu is poor this morning.
06:46:49 <anikaiful> hoogle fu needs to win lottery
06:47:28 <Iceland_jack> :t sequence :: Monad m => (b, m a) -> m (b, a)
06:47:30 <lambdabot> Monad m => (b, m a) -> m (b, a)
06:47:45 <Ferdirand> merijn: there seems to be GHC.IO.Device.dup2 ?
06:48:01 <[exa]> ertes-w: funny thing not even show is easily derived for it
06:48:14 <Iceland_jack> codedmart: that's monadic strength
06:48:23 <c_wraith> merijn: there's everything in https://hackage.haskell.org/package/process-1.6.1.0/docs/System-Process.html#t:StdStream
06:48:33 <merijn> c_wraith: Yes, I know
06:48:34 <Iceland_jack> http://comonad.com/reader/2008/deriving-strength-from-laziness/
06:48:49 <merijn> c_wraith: My point is that I want the child process to write to 1 handle for both stdout and stderr
06:48:56 <c_wraith> merijn: so if you create the handle before opening the process, you can just specify UseHandle with the same handle to both
06:49:16 <merijn> c_wraith: Yeah, my question was whether that was the only way, since that's a hassle :)
06:49:28 <c_wraith> merijn: there are lots of *harder* ways available. :P
06:49:45 <anikaiful> it's a hassle everywhere anyway xD
06:50:54 <cmotoche> Hello everyone. Sometimes, when I use ghci to work with a Web Application the App keeps alive after I hit Ctrl + C to stop it. I think the thread keeps alive and I don't have a reference to it. Perhaps, you know a way to stop all living threads on ghci? Does that make sense?
06:50:58 <anikaiful> side note, whyever you want them both to same end?
06:51:31 <merijn> anikaiful: Because then I only have to read from 1 handle, rather than being difficult and having to monitor 2 handles
06:52:44 <anikaiful> merijn: in way, makes sense... on the other hand, not exactly (except if it doesn't matter if something was just 'noise' and not something reported/logged 'critical')
06:58:29 <merijn> hmmm, when I have a Handle I can't close one side of a socket, can I?
06:59:29 * hackagebot log-warper 1.2.0, salve 0.0.1, universum 0.6.1
06:59:29 * hackagebot  → https://hackage.haskell.org/packages/recent
07:00:07 <anikaiful> why couldn't you?
07:00:38 <anikaiful> just close it, it's up to the other end to figure out how to react, no?
07:00:48 <merijn> anikaiful: Closing would close it for reading too
07:01:11 <anikaiful> ah... just shut down writing to?
07:01:31 <anikaiful> idk haskell, but you can do that on socket level
07:01:36 <merijn> Yes, so the other side can rely on EOF to know when done
07:04:46 <anikaiful> :| I know nothing of Haskell IO, but with barebones sockets it's just a matter of shutdown(handle, SHUT_WR)
07:05:04 <ph88> hey guys i have some strings with unicode chars like check mark ✔ in my source code. but when i run my program on another computer i get: <stdout>: commitBuffer: invalid argument (invalid character)     how can i fix this ?
07:05:08 <merijn> Yeah, looks like I'll just have to use the regular socket interface
07:07:49 <ph88> how can i make haskell output the bytes to the terminal no matter which character encoding is set ?
07:08:09 <merijn> ph88: "the bytes" which bytes?
07:08:23 <merijn> You don't have bytes
07:08:26 <ph88> "bla bla  ✔ some string with unicode"
07:08:27 <merijn> You have a String
07:08:46 <merijn> You have to figure out which bytes you want before you can output them
07:08:50 <anikaiful> ph88: that quite depends. I read some answer on StackOverflow about console output and unicode funkiness on windoze...
07:08:59 <ph88> if i open my file in a hexeditor i see bytes, i want those bytes to the terminal
07:09:21 <merijn> ph88: Files don't have unicode text, they have an encoding of unicode text
07:09:34 <merijn> ph88: utf-8 encoded, utf-16, utf-32, whatever
07:09:46 <merijn> ph88: You need to know which of those you want so you can convert to that
07:10:02 <ph88> why does it convert ?
07:10:11 <merijn> ph88: GHC normally figures it out based on your environment, but apparently your environment is fucked
07:10:24 <ph88> oh
07:10:41 <merijn> ph88: https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/
07:10:53 <anikaiful> env X uses UTF8, env Y uses ASCII, env Z uses UTF32... hilarity ensues
07:11:00 <vu3rdd> ph88: perhaps you need to set the right locale on the other computer too?
07:11:40 <anikaiful> I've not tested this, but:
07:11:43 <anikaiful> import Prelude hiding (putStr) import Data.ByteString.Char8 (putStr) import Data.ByteString.UTF8 (fromString) main :: IO () main = putStr $ fromString "čušpajž日本語"
07:12:11 <vu3rdd> Is the env $LANG same on both the machines?
07:12:20 <merijn> anikaiful: ಠ_ಠ ಠ_ಠ ಠ_ಠ
07:12:34 <merijn> anikaiful: Don't ever write the string "Data.ByteString.Char8" in your code
07:12:41 <anikaiful> xD
07:12:51 <anikaiful> wasn't my code \o/
07:12:53 <merijn> https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
07:13:08 <ph88> i fixed it by settings the LC_LANG on the other machines ... but i thought the program will send bytes and the terminal will interprent them using the encoding. But that is not true because haskell programs already stops that with an error
07:13:30 <anikaiful> ah...
07:13:35 <merijn> ph88: Programs WILL send bytes and terminal DO interpret them
07:13:43 <merijn> ph88: But you program needs to know WHICH bytes to send
07:14:26 <ph88> why it doesn't just send the bytes as they are in the source file ?
07:14:34 <anikaiful> hmm, this comes to the ol' problem I had years ago - how to figure out what output format the running terminal accepts...
07:14:41 <merijn> ph88: Because you don't even know which bytes are in the source file
07:14:54 <merijn> ph88: Your haskell source might be UTF-8, might be UTF-32, who the fuck knows?
07:15:47 <anikaiful> err to the safe side, when dealing with terminal output, just crank everything into ASCII -.-
07:16:08 <ph88> merijn, E2 8B 88  those are the bytes in my source file, i looked at it with hex editor
07:16:32 <merijn> ph88: Read the Joel on Software article I linked earlier
07:19:55 <anikaiful> e28b88 ... ⋈?
07:20:02 <ph88> yes :D
07:20:16 <anikaiful> utf8
07:20:50 <merijn> Of course it's utf8, but assuming that makes everyone else's lives miserable
07:21:17 <anikaiful> yah, just pointing out that that's the source format
07:21:48 <anikaiful> ...in this case
07:21:56 <ph88> and now my program is running but i'm not getting output on the second stage of the program. The first stage wrote a file ok, the second stage is suppose to send stuff to stdout
07:23:44 <tsahyt> Is there some way in which I can directly return single fields from an esequeleto query?
07:23:58 <tsahyt> I can't figure out how this would work, they're always wrapped in Value
07:24:28 <tsahyt> which means that I also can't populate a data structure with them without an extra step of mapping over all results and unwrapping
07:24:37 <anikaiful> ph88: ... but?
07:24:48 <ph88> no output :(
07:25:17 <anikaiful> ph88: no errors? Just flat nada?
07:25:23 <ph88> it just hangs
07:25:45 <ph88> it's running
07:26:10 <ph88> but on my poor little laptop i get output within a minute, and on my core i5 machine after 5 minutes still no output
07:26:35 <anikaiful> is it actually invoking any of the output routines or is it hung up on some infinite loop?
07:26:43 <ph88> i know stdout works because when i type --help i get the help menu
07:27:05 <ph88> well the binary, input file and command line arguments are exactly the same
07:27:49 <ph88> 15% cpu load
07:28:37 <anikaiful> does it work on the other machine (you mentioned about trying on one and failing stdout on other)...?
07:29:41 <ph88> i have my laptop where i developed the program, i have my other machine where i had problems with unicode (which is fixed now)
07:29:44 <cocreature> strace can be helpful for debugging this kind of problem
07:30:12 <ph88> another peculiar discovery: when i run the program from /local it works fine .. when i run it from the network share it hangs
07:30:49 <ph88> which i don't understand because the first stage is suppose to read in the file which is fast, and the second stage is suppose to work on a Vector Unboxed Double in memory (which is slow)
07:31:48 <anikaiful> *scratches head* ... huh.
07:31:56 <anikaiful> peculiar indeed.
07:32:45 <c_wraith> ph88: is there any chance it's getting different input in the two cases?
07:32:55 <ph88> i know it moves from the first stage to the second stage because it writes a file in the middle with the intermediate results
07:33:24 <ph88> the input file is the same .. i will compare the intermediate result file to see if those are the same too .. 1 moment ^^
07:34:19 <anikaiful> what it receives, is ~exact~ match?
07:34:55 <ph88> ye i copied the file on usb disk and use it as input
07:35:29 <anikaiful> well, that throws out network errrors out of the window
07:35:37 <cocreature> it might still be decoded differently
07:35:53 <ph88> intermediate results are the same as well
07:36:00 <ph88> intermediate result file is 10 megabyte
07:36:27 <ph88> (0.0,0.1)
07:36:27 <ph88> (1.0e-3,-0.1)
07:36:27 <ph88> (2.0e-3,0.0)
07:36:27 <ph88> (1.888,7.4e-2)   <-- first 4 rows of intermediate result file
07:37:02 <anikaiful> question tho now, the data, is it just raw numbers or is there (potentially) string-interpreting going on?
07:37:17 <ph88> the parsing is already done, it's Double's now
07:37:48 <anikaiful> hmm...hmm... *boggles and fetches coffee*
07:39:36 <ph88^> https://bpaste.net/show/b2410b82eb8b intermediate file is written on line 491 (that was still uncommented when the program was compiled)
07:39:59 <c_wraith> ph88: if this is on linux, have you considered using strace to see if the hanging version is stuck in a syscall?
07:40:28 <ph88> i'll check !
07:41:55 <ph88> that intermediate file is opened and closed for every line it seems ... pretty nasty .. but not the source of my problem
07:42:11 <ph88> maybe it's because i se mapM_ with appendFile
07:42:12 <anikaiful> oh my, can't compile that paste ...
07:42:26 <c_wraith> It can be hard to tell with ghc-compiled programs, as they use a virtual timer that results in syscalls constantly no matter what's going on.  Maybe you should turn that off for this test.  Something like adding "+RTS -V0" to the command line.
07:42:30 <bxc_> you said its using 15% cpu - is that the whole time (i.e. aproximately forever?) and if so, what is your system loa average like?
07:42:37 <ph88> eh no you need another source file with algorithms and then probably also the stack project .. i will put it on github later ^^
07:42:48 <bxc_> s/loa/load/
07:43:00 <ph88> bxc_, you mean those numbers in htop ?
07:43:16 <anikaiful> tried to see if I can reproduce the error, but yea - if it depends on other files, no-go as-is
07:43:44 <ph88> c_wraith, i compiled my program with rts options disabled :P will have to recompile haha
07:44:53 <bxc_> ph88: three numbers in a row, htop probably displays - top does, as does 'uptime'
07:45:06 <bxc_> ph88: three two decimal place numbers
07:45:51 <anikaiful> I think I should reboot my linux... it's uptime is 520 days or so...
07:51:40 <ph88> how can i rewrite this so that it doesn't open and close the file for each line?   VU.mapM_ (\val -> liftIO $ appendFile vecfile (show val ++ "\n")) $ vec        vec :: Vector Unboxed Double
07:52:36 <ph88> maybe first map vec to show and then appendFile ?
07:54:40 <cocreature> don’t use appendFile at all. open a handle and then write to that handle and close it when you’re done
07:55:09 <mauke> that's what appendFile does, though
07:55:40 <cocreature> right my point is that you should open the handle outside of the loop
07:55:46 <cocreature> instead of calling appendFile in the loop
07:56:33 <mauke> I like ph88's suggestion better
07:56:40 <ph88> is it possible to do   Vector Unboxed String -> String   with concat string function ?
07:57:13 <brynedwards> ph88: I would use withFile and hPutStrLn
07:57:47 <brynedwards> Uhh my prompt didn't update, nvm
07:59:19 <ph88> i can try foldl1' maybe
08:00:20 * hackagebot serokell-util 0.5.0 – General-purpose functions by Serokell – https://hackage.haskell.org/package/serokell-util
08:00:20 * hackagebot optparse-applicative-simple 1.0.1 – Simple command line interface arguments parser – https://hackage.haskell.org/package/optparse-applicative-simple
08:03:07 <ph88> c_wraith, it's doing a lot of getrusage and rt_sigprocmask
08:03:52 <c_wraith> Is that with +RTS -V0 ?
08:03:58 <ph88> yes
08:04:13 <c_wraith> Hmm.  I would have hoped that would have got rid of the rt_sigprocmask, anyway
08:04:25 <c_wraith> Anyway, those are both kind of noise.
08:04:37 <iqubic> λ is a good letter.
08:07:48 * mekeor tried to convince his employee of haskell today
08:08:32 <mekeor> in order to replacing a ruby+rails app with haskell+servant :D
08:09:12 <Psybur> mekeor, did he get scared away with all the >>= and -<'s? :D
08:09:12 <mekeor> his doubt was that there are too few haskellers
08:09:27 <mekeor> :D
08:09:29 <anikaiful> Ruby is nice... but it sort of feels like a toy more than anything serious :|
08:10:15 <mekeor> wait. whut
08:10:29 <mekeor> s/employee/employer/
08:11:07 <Psybur> mekeor, more often than not you have to ask for forgiveness instead of permission
08:11:45 <Psybur> I worked for a company that was deadset on mapreduce. Well one day they assigned me a project that didn't explicitly say mapreduce and guess what? They got spark ;p
08:12:17 <Psybur> And nobody complained :D
08:12:37 <anikaiful> either the company accepts what you see as best or they can go suck a ... thing. XD
08:12:41 <vaibhavsagar_> hey #haskell, I'm trying to figure out this IHaskell+Nix bug: https://github.com/gibiansky/IHaskell/issues/728
08:13:01 <mekeor> what's deadset and mapreduce?
08:13:07 <mekeor> Psybur: ?
08:13:08 <anikaiful> no idea
08:13:18 <[exa]> anikaiful: ruby is not quite toy-ish, see eg. gitlab
08:13:22 <Psybur> Oh, MapReduce and Spark are Big Data frameworks
08:14:02 <Psybur> "dead set" means they really wanted to use MapReduce even though there was massive evidence that using Spark would be better. They cited lack of experience with it
08:14:03 <[exa]> Psybur: lol, "guess what"
08:14:11 <anikaiful> [exa]: yea, I've done a number of things with it. But even years after it seems more like a 'toy' or 'scripter' than something solid serious.
08:15:52 <[exa]> anikaiful: 'too easily breakable' imho. But yes, the design is a bit too simple
08:17:16 <anikaiful> I've yet to figure out how to do parallel processing with it...
08:20:10 <anikaiful> guh, anyone knowledgeable about "irssi" and how to config it to use my nick & channels right from issuing mere "irssi" to cmd?
08:20:22 <maerwald> wrong channel?
08:20:42 <ph88> mauke, when i use appendFile wouldn't it have to build up the entire string in memory first ?
08:20:45 <anikaiful> maybe, but I'm not on any other channels / serverrs
08:21:08 <maerwald> anikaiful: that doesn't change the topic of this channel ;)
08:21:24 <anikaiful> helpful sod, aren't you :P
08:21:47 <mauke> ph88: yes, unless you're using a lazy string
08:22:06 <bxc_> anikaiful: look at the sample config here https://askubuntu.com/questions/61549/how-do-i-configure-irssi
08:22:17 <anikaiful> thank you!
08:22:18 <mauke> anikaiful: have you tried reading the documentation?
08:22:26 <bxc_> mauke: irc-as-google.
08:22:51 <ph88> mauke, i have now   liftIO $ appendFile $ VU.foldl'(\a b -> a ++ (show b) ++ "\n") "" vec       how do i know if this is lazy or not ?
08:23:02 <anikaiful> mauke: what docs? I have 'irssi' as plain, flat, exe-and-nothing-else...
08:23:10 <mekeor> anikaiful: try something like "/join #irssi" maybe?
08:23:20 <[exa]> anikaiful: a bit more traditional way is to get a ssh account somewhere and run irssi from it, so you don't have to restart it
08:24:23 <anikaiful> mekeor: right now I'm using the web thingy to connect to #haskell, so ... yea xD ... duh.
08:25:17 <mauke> ph88: that looks like a normal String, which is lazy. but you're repeatedly ++'ing on the right, which is very inefficient
08:25:35 <mauke> anikaiful: https://irssi.org/documentation/
08:25:41 <ph88> mauke, i didn't know how else to put the new line ending
08:25:58 <mauke> foldr (\
08:26:00 <mauke> er
08:26:14 <ph88> with right fold i still have to concat a and b, no ?
08:26:16 <mauke> foldr (\x z -> show x ++ "\n" ++ z) "" would be better
08:27:33 <ph88> maybe it's best to open a handle and write  ?
08:28:00 <anikaiful> mauke: ugh... I so wish there was Discord instead.
08:31:14 <bxc_> anikaiful: there probably is, without the people here on it?
08:32:52 <anikaiful> bxc_: and not having them kinds of defeats the purpose...
08:36:38 <bxc_> anikaiful: but IRC is so amazing.
08:37:35 <anikaiful> bxc_: Discord ~is~ IRC, in the core.
08:38:48 <shapr> I thought discord was voice chat?
08:39:41 <bxc_> this channel should have moved to Google Wave when it had the chance.
08:40:37 <Cale> bxc_: So that it would no longer exist?
08:41:07 <ph88^> how can i use   when  and  liftIO  together ?  i tried both   liftIO $ when (doesFileExist vecfile) (removeFile vecfile)    and   when (liftIO $ doesFileExist vecfile) (liftIO $ removeFile vecfile)
08:41:31 <anikaiful> shapr: no, it's not - voice's optional. In the core it's IRC with bells and whistles.
08:41:37 <bxc_> Cale: I expect everyone would have given up in confusion well before they shut it down
08:41:42 <Tuplanolla> You just introduced a race hazard into your program, ph88.
08:41:54 <ph88> :(
08:41:57 <Cale> ph88^: Your problem isn't that liftIO and when don't work together, your problem is that doesFileExist vecfile isn't a Bool
08:42:21 <shapr> I'd be happier with IRC if it had some way to show the last 100 lines of conversation with timestamps
08:42:36 <bxc_> my irssi does that
08:42:42 <bxc_> not sure if I configured it that way
08:42:55 <AWizzArd> Hmmm, what is the `guard` implementation doing that is presented here? http://www.randomhacks.net.s3-website-us-east-1.amazonaws.com/2007/03/12/monads-in-15-minutes/
08:43:05 <Cale> ph88: You need to run it first, and pass the result to when.
08:43:06 <AWizzArd> I don’t understand how it can short-circuit the computation.
08:43:31 <brynedwards> Yeah I just have irssi always connected and use alt-p and alt-n for history
08:43:34 <anikaiful> by default it does that, but the heck of my life I can't figure out how to install "irssi" alone and not the whole cygwin shebang on windoze XD... and their docs are NOT helpful in that.
08:43:42 <Cale> AWizzArd: Well, which monad are we talking about? Lists?
08:44:10 <Cale> AWizzArd: If you want to choose an element of [] in order to proceed with the computation, you're done -- you can't choose one.
08:44:14 <AWizzArd> Cale: sorry that article is a bit lengthy, and I don’t really expect anyone to read 5 minutes to answer my question.
08:44:20 <ph88> is there a function to catch an exception but do nothing when catched ?
08:44:38 <Cale> AWizzArd: ah, yeah, type Choice a = [a]
08:44:51 <AWizzArd> But one thing I find strange. We have   type Choice a = [a]   and     guard :: Bool -> Choice ()
08:45:10 <Cale> Or, more straightforwardly, guard :: Bool -> [()]
08:45:46 <Cale> > guard (0 == 1) :: [()]
08:45:49 <lambdabot>  []
08:45:55 <AWizzArd> Cale: could you possibly show the  `solveConstraint` implementation without do? But using bind?
08:46:02 <Cale> > guard (5 * 12 == 3 * 20) :: [()]
08:46:05 <lambdabot>  [()]
08:46:14 <ph88> :t void . catch
08:46:16 <lambdabot> Exception e => IO a -> (e -> IO a) -> ()
08:46:43 <Cale> AWizzArd: choose [1,2,3] >>= \x -> choose [4,5,6] >>= \y -> guard (x*y == 8) >> return (x,y)
08:46:43 <ph88> :t void . try
08:46:45 <lambdabot> error:
08:46:45 <lambdabot>     • Ambiguous type variable ‘e0’ arising from a use of ‘try’
08:46:45 <lambdabot>       prevents the constraint ‘(Exception e0)’ from being solved.
08:47:10 <Cale> AWizzArd: Note that [] >> x = []
08:47:41 <Cale> AWizzArd: So if x*y is not 8, we know that guard (x*y == 8) >> return (x,y) = []
08:47:54 <AWizzArd> Ah okay. I think now it makes sense!
08:50:06 <lavalike> anikaiful: not sure what you mean by "~is~" but their infrastructure has very little to do with the IRC protocol itself. It's erlang processes doing fanout of messages in and out of websockets. They do implement an irc-like chat experience on top of that, of course. https://blog.discordapp.com/scaling-elixir-f9b8e1e7c29b
08:51:40 <AWizzArd> Cale: so the trick here is that in the case of  `guard False` we return the empty list. And then calling  (map f []) will simply not call f, which is on the right-hand side of bind.
08:51:46 <AWizzArd> Good good. Now it’s clear, thx.
08:56:32 <jfiewor> why does Data.Time use String instead of Text for parseTime
08:56:34 <jfiewor> ?
08:58:14 <Cale> jfiewor: Because it's been around longer than Text, for one
08:58:47 <jfiewor> I think it should be fixed..
08:59:04 <jfiewor> or is there any alternative?
09:00:07 <Anikaiful> ...fixed, how? Text is more or less arbitrary and can break across systems... String not quite so.
09:00:27 <geekosaur> thre is no such thing a shistory, there is no such thing s existing codebase, all of its existence is collapsed intot he instant before they discovered it, therefore there can be no barriers to changes
09:01:49 <glguy> jfiewor: The text package provides 'unpack :: Text -> String'
09:02:19 <jfiewor> But the performance penalty could be greater if it's not changed to Text
09:02:57 <AWizzArd> Cale: one more question. Why does `solveConstraint` work? It’s using the do syntax. The import was hinding (>>=) and return.   How could this possibly work? The `do` call there could not have known to use his (>>=) implementation.
09:03:05 <jfiewor> unpack doesn't help a lot if I have to use String functions to transform the data
09:03:42 <glguy> jfiewor: If you're doing something where you're processing significant amounts of dates as strings you should probably write a custom parser instead of the configurable one in time
09:03:43 <Anikaiful> jfiewor: performance isn't the issue, but systems (OS, etc)
09:03:56 <glguy> if you're not doing something that intensive then it's not going to matter
09:04:21 <glguy> Anikaiful: Which issue with the text package are you thinking of?
09:04:47 <Anikaiful> glguy: systems which do not conform with any sort of UTF at all.
09:05:15 <Tuplanolla> I don't follow, Anikaiful.
09:05:16 <glguy> Anikaiful: Both Text and String manage their own representations; there isn't an OS dependency
09:05:56 <Anikaiful> hmm...
09:06:03 <glguy> and both are structured around sequences of unicode codepoints
09:07:10 <jfiewor> Can a List of String be converted to Mutable Unboxed Vector? 
09:07:22 <Anikaiful> yea, tho there is no guarantee that any given codepoint would be understood by the underlying system. Just that the data presentation is exact.
09:07:49 <Tuplanolla> What understanding is there to do, Anikaiful?
09:08:13 <glguy> Anikaiful: What ever guarantee you're thinking of, it's not relevant to the question of String and Text
09:09:03 <Anikaiful> Tuplanolla: idk, the usual, utf8 -> ascii, utf8 -> utf32, the iffy hurdle which most systems nowadays figure out on their own but some ancient stuff doesn't.
09:09:40 <Anikaiful> but yea, probaly not relevant.
09:10:49 * Anikaiful is an archaic relic from times long gone.
09:11:48 <jfiewor> I need to learn how to do Concurrent Haskell.. Single threaded Haskell operation on Text took longer than Excel using 100% CPU
09:12:17 <jfiewor> (4 threads)
09:13:06 <vaibhavsagar_> when does GHC build a .dyn_o vs a .o?
09:13:29 <vaibhavsagar_> and when does GHC expect a .dyn_o vs a .o?
09:13:37 <jfiewor> This weekend my learning task: Unboxed Mutable Vector + Concurrent Haskell
09:14:04 <brynedwards> vaibhavsagar: dynamic linking?
09:14:35 <Anikaiful> jfiewor: I'd see that more like as a task to first try single-thread, parallel later.
09:16:56 <vaibhavsagar_> brynedwards: I'm trying to get to the bottom of this IHaskell+Nix issue: https://github.com/gibiansky/IHaskell/issues/728
09:17:23 <Anikaiful> that being, I'm archaic, using for most tests a system with single core that doesn't have hyperthreading or other such fads.
09:17:48 <norc_> Hi. Given this readsTree implementation, how does something like `readsTree ""` even typecheck?
09:18:16 <brynedwards> vaibhavsagar_: Oh, I don't use nix, sorry
09:18:21 <geekosaur> vaibhavsagar_, I suspect you need to dig into what nix itself is doing
09:18:35 <geekosaur> stack --nix won't be doing the same thing necessarily
09:18:40 <bxc_> norc_: which implementation?
09:18:50 <norc_> bxc_: Sorry:
09:18:51 <norc_> https://gist.github.com/anonymous/9cc5aa20018e1004f0fd60cd486b1691
09:19:08 <vaibhavsagar_> geekosaur: yes, stack --nix works without issues
09:20:06 <cocreature> afaik, ghci defaults to -dynamic so ihaskell trying to use that doesn’t seem unreasonable
09:20:13 <norc_> I mean `readsTree "1" :: [(Tree Integer, String)]` works great, but I would have suspecting it to choke horribly on types if I didnt tell it what kind of Tree it was
09:20:30 <geekosaur> norc_, did you try it in compiled code or only in ghci?>
09:20:34 <norc_> geekosaur: ghci
09:20:40 <geekosaur> because I suspect this is ExtendedDefaultRules
09:20:44 <cocreature> in fact I’m not even sure if interpreted mode works without dyn_o files
09:20:55 <geekosaur> which means ghci will, as a final fallback, infer () as the type
09:21:35 <cocreature> vaibhavsagar_: what I’m trying to say is that instead of trying to make ihaskell not use -dynamic, the right solution might be to figure out why the dyn_o files are not built
09:21:45 <bxc_> norc_: what type is readsTree "" in ghci?
09:22:04 <norc_> bxc_: readsTree "" :: Read a => [(Tree a, String)]
09:22:27 <vaibhavsagar_> cocreature: no .dyn_o files are built when I'm not using Nix and that seems to work fine
09:22:40 <bxc_> norc_: that seems ok?
09:22:42 <geekosaur> right, that won''t be helpful because :t will keep it polymorphic, it's only when using the value that you get a concrete type forced on you
09:23:01 <lavalike> `Read a =>` coming from `reads s :: Read a => [(Tree a, String)]`
09:23:12 <bxc_> norc_: are you complaining that it can be evaluated too?
09:23:23 <cocreature> vaibhavsagar_: right but they are not built when you’re using nix. that seems to suggest that -dynamic is _missing_ somewhere not that it’s being passed where it shouldn’t be
09:23:37 <norc_> geekosaur: A-ha! Both my linter and the compiler actually choke on it, thanks. :)
09:23:40 <norc_> Now Im happy.
09:23:50 <Anikaiful> heh :D
09:23:59 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#extended-default-rules
09:24:47 <geekosaur> if you enable -XExtendedDefaultRules (option or LANGUAGE pragma) then the compiled one will behave the same as ghci. or ghci will behave the same as compiled with: :seti -XNoExtendedDefaultRules
09:26:13 <norc_> geekosaur: Very well. Seems like I might want to disable it for now, because for now I want a predictable GHCi - it's a bit annoying to have code pass typecheck in one place but not the other.
09:26:58 <geekosaur> yes, that's exactly why it is available as a pragma (and why ghci has :seti and :showi language)
09:27:46 <geekosaur> if you are looking for exact behavior matching you probably also want :seti -XMonomorphismRestriction
09:27:55 <geekosaur> since ghci turns that off by default
09:28:11 <bxc_> another day, another London functional programming meetup: https://www.meetup.com/MonadicAperitives/
09:28:11 <cocreature> vaibhavsagar_: apparently if you use TH, then you can run into this problem if you don’t use --dynamic-too. not sure if that’s relevant in your case
09:28:37 <geekosaur> basically start a new ghci and ":showi language" to see the default environment, and compare that to ":show language"
09:28:43 <vaibhavsagar_> cocreature: where would I pass --dynamic-too?
09:28:50 <vaibhavsagar_> I tried something like this earlier
09:29:01 <geekosaur> (ghci uses the -i versions for code at the prompt and the other for code loaded from a file that it compiles to bytecode)
09:29:06 <vaibhavsagar_> but I'm not sure I did it right
09:30:34 <norc_> geekosaur: Thank you for the tips, they are (for now) permanently disabled.
09:30:42 <geekosaur> also worth remembering is you can have a .ghci (or ghci.ini) file in a project to get different ghci behavior in different contexts
09:30:59 <cocreature> vaibhavsagar_: sorry not sure. I have no idea how ihaskell calls ghc
09:31:14 <norc_> geekosaur: Ah yeah. Yeah I set it userwide I think, its set in my ~/.ghci
09:31:33 <vaibhavsagar_> cocreature: it uses the GHC API
09:32:02 <cocreature> sure but to modify the arguments you pass to it, you need to know a bit more about the internals :)
09:34:07 <cocreature> geekosaur: that reminds me, I would still very much appreciate that article on dynamic linking :) *nudge*
09:38:30 <vaibhavsagar_> okay, trying something different
09:39:39 <vaibhavsagar_> I think it might be this line: https://github.com/gibiansky/IHaskell/blob/82208921c7a7ff591507483b09fce32d730004ce/src/IHaskell/Eval/Evaluate.hs#L1050https://github.com/gibiansky/IHaskell/blob/82208921c7a7ff591507483b09fce32d730004ce/src/IHaskell/Eval/Evaluate.hs#L1050
09:39:47 <vaibhavsagar_> oops, https://github.com/gibiansky/IHaskell/blob/82208921c7a7ff591507483b09fce32d730004ce/src/IHaskell/Eval/Evaluate.hs#L1050
09:40:39 <vaibhavsagar_> based on a quick skim of https://gist.github.com/worldsayshi/8853946#file-dynload-hs-L39-L40
09:42:10 <vaibhavsagar_> wow, I think that worked!
10:02:16 <et09> anyone know if there's been some kind of fix to those billion library linking errors on archlinux?  
10:02:48 <vaibhavsagar_> et09: docker containers
10:03:03 <et09> what?
10:03:03 <vaibhavsagar_> or you could use a VM, or a different distro
10:03:37 <[exa]> et09: tiny one-purpose debian in LXC?
10:03:57 <norc_> Debugging a program in GHCi currently, what do those numbers mean in: [Tree.hs:(26,17)-(32,60)] *Tree> ?
10:04:14 <norc_> I mean, if it was just a single pair Id think it was the current position, but the range is confusing me
10:05:15 <c_wraith> norc_: start and end of the whole expression it's having trouble with
10:10:42 <monochrom> et09: Or don't use archlinux's GHC. Use the official one from www.haskell.org/ghc or from Haskell Platform or from Stack
10:10:58 <et09> which one is best?
10:11:01 <et09> to use
10:11:27 <monochrom> All of them are the best, depending on who you ask.
10:11:32 <c_wraith> 8.2 is best if you need its features.  Older are better if you need compatibility with specific versions.
10:11:42 <monochrom> Does it have to be the best? Does it have to be perfect?
10:11:55 <et09> these are very profound questions
10:13:36 <nshepperd_> et09: follow these instructions https://wiki.archlinux.org/index.php/Haskell#Building_statically_linked_packages_with_Cabal_.28without_using_shared_libraries.29
10:13:49 <Anikaiful> isn't... "perfect == best"?
10:14:02 <monochrom> Yes I think so.
10:14:08 <Cale> perfect -> best
10:14:28 <nshepperd_> You need to install ghc-static then remove all haskell library packages
10:14:41 <et09> what is the nature of this problem anyway
10:14:41 <Cale> (because False implies anything)
10:15:00 <et09> (i have no haskell packages from arch repos besides ghc/cabal)
10:16:20 <monochrom> The nature of this problem: archlinux ideologist religion hates static linking, so they change GHC to default to dynamic linking. But they goofed up, they missed one thing.
10:16:25 <nshepperd_> Arch maintainer of haskell decided to make things dynamic linking only
10:16:48 <et09> yikes
10:17:25 <et09> what thing did he miss
10:17:43 <monochrom> I forgot.
10:17:49 <nshepperd_> If you check, you'll notice that cabal now pulls in a bunch of haskell libraries due to be dynamically linked
10:18:15 <et09> and it sounds like i'd be safe just installing ghc/cabal from scratch?
10:18:22 <monochrom> YES!
10:18:23 <et09> maintaining haskell separate from arch ecosystem?
10:18:26 <nshepperd_> Et
10:18:39 <et09> works for me
10:18:44 <monochrom> It has always been safer to reject your linux distro's Haskell packages.
10:19:10 <Anikaiful> no idea, but I've seen some bug issues where dyn stuff isn't created if one or other build step fails *shrug* --- resulting in that you need to do full (re)compilation of the whole thing to get things working.
10:19:12 <nshepperd_> Install ghc and ghc-static from Arch repo, if you want. That's fine. Everything else you should build yourself
10:19:43 <et09> this is unusually stupid for arch
10:19:50 <et09> usually i'm very happy
10:20:24 <jared-w> I was also very displeased by Arch's decision on this. It's indeed particularly stupid on their end and they don't seem to be realizing just how stupid the decision was
10:21:15 <et09> yaourt is unhappy about uninstalling ghc... not sure why
10:21:24 <et09> aka not sure what the root dependency is..maybe pandoc
10:22:17 <et09> or alex/happy..hmm...
10:22:37 <dolio> Probably all of those.
10:22:44 <nshepperd_> Delete them all
10:22:57 <Anikaiful> "don't worry, be Happy"?
10:24:40 <et09> http://i.imgur.com/afvL0P7.png
10:24:56 <et09> oh wow, this is a disaster
10:26:01 <Anikaiful> that's... a bunch.
10:26:50 <Anikaiful> wait what, that whole thing is result of trying to uninstall alex?
10:27:07 <et09> no i did yaourt -Rd alex happy ghc [every package starting with haskell-]
10:27:14 <et09> basically
10:27:15 <Anikaiful> o...
10:30:51 <dolio> pandoc uses a lot of libraries.
10:31:46 <Anikaiful> I've yet to see a package manager (even more so, package creator (= person)) who'd be smart.
10:37:44 <et09> sigh... now i'm at  hashable-1.2.6.1-14fEJP30YhAG9w115PODz0 is unusable due to shadowed dependencies:
10:37:47 <et09>       text-1.2.2.2-EGUst8sqNAZCw1xLPcmcMH
10:39:43 <geekosaur> this is all partof why the arch change was so stupid
10:40:04 <et09> i installed haskell-platform and started from scratch
10:40:14 <et09> should i wipe my .cabal folder or something
10:40:37 <geekosaur> if it's the same ghc version then yes
10:40:41 <geekosaur> also ~/.ghc
10:41:15 <geekosaur> (~/.cabal would leave the p[ackage registrations in place ad they will still conflict and also refuse to actually work)
10:41:27 <et09> that would do it 
10:42:45 <et09> i get the same error...
10:47:26 <dolio> What is the 'haskell-platform' that you installed?
10:48:24 <et09> https://www.haskell.org/platform/#linux-generic
10:48:30 <et09> full/64 bit
10:58:43 <fresheyeball> hey folks
10:58:57 <fresheyeball> how can I have a tuple of things other than kind *?
10:58:59 <fresheyeball> as in
10:59:09 <fresheyeball> Proxy (x :: Nat, y :: Nat)
10:59:12 <fresheyeball> ?
10:59:22 <fresheyeball> is it possible?
10:59:28 <lyxia> Proxy '(x, y)
10:59:44 <fresheyeball> lyxia: that did it!
10:59:46 <fresheyeball> how simple!
10:59:47 <lyxia> (x,y) is the type of tuples of types x and y
11:00:00 <lyxia> '(x,y) is the tuple of x, y, whatever their types are.
11:00:54 <fresheyeball> lyxia: so Proxy is a Functor
11:01:01 <fresheyeball> and the promotion did work
11:01:04 <fresheyeball> but now I can't
11:01:15 <fresheyeball> fst <$> p :: Proxy (x :: Nat)
11:01:32 <Psybur> So I can't have a tuple of functions?
11:01:33 <fresheyeball> is there a way to do that?
11:01:37 <Psybur> > ((+1),(+2))
11:01:40 <lambdabot>  (<Integer -> Integer>,<Integer -> Integer>)
11:01:51 <lyxia> fresheyeball: that's not something a Functor does
11:01:53 <fresheyeball> Paybur of course you can
11:02:01 <lyxia> fresheyeball: you just want (\Proxy -> Proxy)
11:02:04 <Psybur> Oh nvm, my ghci was complaining abotu show
11:02:04 <jle`> ((+1),(+2)) is a tuple of things of kind *
11:02:11 <jle`> (,) :: * -> * -> *
11:02:21 <jle`> and (+1)'s type is kind *
11:02:27 <fresheyeball> Psybur: it's some kind of Functor
11:02:34 <jle`> *tuple of things whose types have kind *
11:02:38 <fresheyeball> fmap :: (a -> b) -> f a -> f b
11:02:42 <Tuplanolla> It's the least interesting kind of functor, fresheyeball.
11:02:49 <fresheyeball> can't that specialize to
11:02:53 <Tuplanolla> > fmap undefined Proxy
11:02:53 <Psybur> nvm guys I just misinterpreted my ghci output :D
11:02:55 <lambdabot>  Proxy
11:03:27 <fresheyeball> fmap :: ((a, b) -> a) -> Proxy (a, b) -> Proxy a
11:03:30 <fresheyeball> ?
11:03:52 <jle`> :t fmap fst
11:03:54 <lambdabot> Functor f => f (b1, b) -> f b1
11:04:07 <jle`> note that (a,b) is different from '(a, b), so that's a little confusing
11:04:25 <jle`> if you're starting out, you probably want (a,b)
11:09:28 <foojs> i'm thinking of converting to haskell :) soon!
11:09:32 <foojs> lively channel
11:12:00 <Psybur> Tuple has a monad instance right? I cant seem to find it in the docs tho
11:12:50 <cocreature> Psybur: at least the tuples up to a reasonable length have one
11:13:14 <cocreature> Psybur: https://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#line-344
11:15:11 <lyxia> "a reasonable length" is 2?
11:15:46 <cocreature> huh I thought we had instances for larger tuples but it looks like you’re right
11:16:13 <ongy> I think Ord and Eq exist up to 15
11:17:06 <cocreature> I can’t recall the last time I’ve used the Monad instance of tuples
11:17:08 <monochrom> A reasonable length is 2 because 2-dimensional matching is polynomial-time but 3-dimensional matching is NP-complete. >:)
11:17:37 <cocreature> monochrom: and 2sat is also polynomial time while 3sat is not :)
11:17:43 <monochrom> \∩/
11:19:26 <Psybur> Anybody have an idea of what's going on here?
11:19:28 <Psybur> > ((+1),(+2)) >>= \x -> (x 1, x 2)
11:19:30 <lambdabot>  error:
11:19:30 <lambdabot>      • No instance for (Typeable a0)
11:19:30 <lambdabot>          arising from a use of ‘show_M43226475967337134272616’
11:20:13 <lavalike> maybe try show_M43226475967337134272617 next time
11:20:20 <monochrom> @type ((+1),(+2)) >>= \x -> (x 1, x 2)
11:20:21 <lambdabot> (Num (a -> a), Num a, Monoid a) => (a -> a, a -> a)
11:20:23 <Tuplanolla> :t ((+ 1), (+ 2)) >>= \ f -> (f 1, f 2) -- Do you see it, Psybur?
11:20:25 <lambdabot> (Num (a -> a), Num a, Monoid a) => (a -> a, a -> a)
11:20:54 <monochrom> I have no idea what's going on there, judging from the inferred type.
11:21:43 <Tuplanolla> Is it dubious to pose laws such as `forall x. op x (invr x) == iden` for a class that doesn't have `Eq` in its constraints?
11:21:44 <Psybur> Can anybody come up with something that would work with ((+1),(+2)) >>= ???
11:21:59 <lyxia> define "work"
11:22:02 <cocreature> Psybur: there is no monoid for (+1)
11:22:08 <cocreature> at least for the usual candidates of Num
11:22:13 <monochrom> Is the "Monoid a" caused by the Monad instance of 2-tuple which says it is doing the Writer monad thing?
11:22:15 <Psybur> Ah ok it has to be a monoid
11:22:18 <dolio> monochrom, cocreature: You don't know those aren't polynomial time. :)
11:22:36 <MarcelineVQ> > ((+1),(+2)) >>= _
11:22:38 <lambdabot>  error:
11:22:38 <lambdabot>      • Found hole: _ :: (Integer -> Integer) -> (a -> a, b)
11:22:38 <lambdabot>        Where: ‘a’ is a rigid type variable bound by
11:22:41 <cocreature> monochrom: yep
11:22:54 <cocreature> dolio: fair enough :)
11:23:16 <Tuplanolla> > ((+ 1), (+ 2)) >>= pure
11:23:17 <lambdabot>  error:
11:23:18 <lambdabot>      • No instance for (Typeable a0)
11:23:18 <lambdabot>          arising from a use of ‘show_M18700677248845048772759’
11:23:28 <lyxia> Tuplanolla: just write "=" and let the interpretation of equality up to users.
11:23:30 <Tuplanolla> That ought to work. Let me pass in some arguments.
11:23:39 <lyxia> it doesn't have to be structural nor decidable.
11:23:59 <Tuplanolla> That's disgusting, because some laws also need `<=`, lyxia.
11:24:18 <MarcelineVQ> :t ((+1),(+2)) >>= \x -> (x, x 2)
11:24:20 <lambdabot> (Num b, Monoid b) => (b -> b, b)
11:24:32 <monochrom> Tuplanolla: We pose Monoid laws like "mempty <> x = x" all the time even when for example Endo a does not have Eq. So yeah, do it!
11:24:34 <Tuplanolla> I'd have to mix `x = y` and `(x <= y) = True`, lyxia.
11:24:44 <tdammers> (Integer -> Integer) -> (a -> a, b) is absurd
11:25:03 <dolio> Why, you shouldn't be talking about decision procedures anyway, presumably.
11:25:22 <tdammers> given only a function from Integer to Integer, you cannot produce a value that inhabits all types b (except bottom)
11:25:22 <ski> Tuplanolla : for this reason, i use the symbol `=', not `==', when doing equational reasoning
11:25:41 <cocreature> Tuplanolla: unicode ≤ :)
11:25:45 <tdammers> you can produce a value a -> a though (namely, the identity function)
11:26:02 <monochrom> Yeah, use mathematical equality for laws.
11:26:03 <lyxia> Tuplanolla: I mean, the distinction between == and = I'm making can also be made between Ord's <= and some more abstract notion of order.
11:27:13 <Tuplanolla> Is that useful at all, lyxia?
11:27:40 <ski> i expect `(==)' to satisfy `forall x y. x == y = True => x = y' and `forall x y. x == y = False => x =/= y'. similar things could be said about `Ord'
11:27:53 <monochrom> It is because although Haskell doesn't know mathematical equality and comparison, theorem provers do.
11:27:54 <Anikaiful> cocreature: however you even type those?
11:28:11 <cocreature> Anikaiful: weird keyboard layouts :)
11:28:16 <cocreature> and compose keys
11:28:22 <Tuplanolla> I mean, there's a difference between `=` and `==`, but I can use `<=` and analyze the resulting `Bool` with `=`.
11:28:47 <Anikaiful> cocreature: ... yay :|
11:28:56 <monochrom> Do you really have a law that says "(x <= y) == True"?
11:29:19 <monochrom> What are your laws? It may be time to show it all.
11:29:40 <lyxia> Tuplanolla: When I see "=" in a law I also imagine it to be different from the "=" in Haskell's declaration syntax.
11:29:50 <ski> lyxia : i don't
11:29:53 <Tuplanolla> Rather `forall x y z. eq x y && eq y z ==> eq x z = True`, monochrom.
11:30:11 <ski> lyxia : .. but of course, you can only use it in more resticted cases, in the latter
11:30:47 <lyxia> ski: containers and QuickCheck rely on this looseness though.
11:31:12 <monochrom> Is eq a Haskell function?
11:31:23 <ski> lyxia : elaborate on what you mean ?
11:31:24 <Tuplanolla> Yes, monochrom.
11:31:43 <monochrom> OK, you can even use == there, because Bool supports Eq.
11:32:15 * ski wants an additional `= True' in Tuplanolla's law
11:32:16 <Anikaiful> hmm, eq, a function?
11:32:31 <Tuplanolla> Yes, but then the law would have type `Bool` instead of whatever type the proposition `_ = _` has, monochrom.
11:33:13 <Anikaiful> mah haskell no comprende eq. Or, more like, wtf's eq?
11:33:51 <monochrom> Ah I see, OK, keep the "= True" there, it's fine.
11:34:12 <monochrom> Anikaiful, read the context.
11:34:20 <ski> @let eq :: Eq a => a -> a -> Bool; eq x y = (x == y) == True
11:34:22 <lambdabot>  Defined.
11:34:24 <ski> there you go ..
11:34:29 <lyxia> ski: These are examples of cases where Haskell's structural equality is too fine compared to the notion of equality that users will actually care about.
11:34:42 <Anikaiful> *facepalm*
11:35:26 <ski> lyxia : yes. i consider this a deficiency of Haskell's approach to (computable) equality and abstract data types (specifically quotient types). an understandable deficiency, but nevertheless
11:35:41 <Tuplanolla> @let class EqLike a where eq :: a -> a -> Bool -- I had this in mind, Anikaiful.
11:35:43 <lambdabot>  Defined.
11:36:11 <Anikaiful> Tuplanolla: makes sense
11:36:17 * ski imagines Tuplanolla wants at least an equivalence relation (or PER) ?
11:38:14 <Anikaiful> :D ... oh ya, just so that you ppl are aware: I know nothing about Haskell beyond a few shoddy babysteps. I'm more at home with metal banging assembly.
11:39:00 <monochrom> Use -ddump-asm to see metal banging assembly.
11:39:18 <Tuplanolla> Anikaiful: https://haskell.godbolt.org/
11:39:25 <Anikaiful> ah :)
11:39:26 <monochrom> That too.
11:39:42 <monochrom> It uses -ddump-asm for you. >:)
11:39:55 <Tuplanolla> You're in luck, because GHC produces lots of it, Anikaiful!
11:40:00 <Anikaiful> \o/
11:40:30 <monochrom> I am just still puzzling on how it knows which asm chunk corresponds to which Haskell chunk.
11:40:43 <Anikaiful> kinds of trying to learn Haskell tho for more "what I want" instead of "how to get it" view.
11:42:23 <lyxia> ski: when you write x == y = True => x = y, what do you mean by (=) here?
11:43:04 <Tuplanolla> Is that `((x == y) = True) => (x = y)`, lyxia?
11:43:11 <lyxia> yes
11:43:29 <ski> lyxia : "semantically equal"
11:43:40 <Tuplanolla> Both `=` and `=>` would work on the prop level, lyxia.
11:43:45 <lyxia> under what semantics
11:44:24 <ski> (or "denotationally", if you prefer. and probably not distinguishing much more values than have to, wrt what can be observed)
11:44:48 <Anikaiful> confuzzled me. I don't know how to interpret that.
11:46:25 <monochrom> Anikaiful: https://github.com/takenobu-hs/haskell-ghc-illustrated
11:47:38 <Anikaiful> monochrom: yea, but with a glance the statement made no sense to me.
11:47:53 <monochrom> lyxia: I'm usually lax and consider "mathematical equal" to be sufficient. But if you insist, "x = y" means [|x|] mathematical-equal [|y|]
11:48:09 <monochrom> Which statement?
11:48:23 <Anikaiful> x==t = true => and so on
11:48:30 <Anikaiful> t/y
11:48:50 <monochrom> OK that's a more theoretical and technical discussion.
11:48:51 <ski> Anikaiful : oh. we're arguing semantics
11:49:04 <Tuplanolla> Skim this, Anikaiful: https://ncatlab.org/nlab/show/equality
11:49:31 <Anikaiful> y dem math peeps dun make stuff comprehensible?! xD lol
11:50:11 <monochrom> No, there is no point making everything comprehensible to everyone in the world.
11:50:35 <Anikaiful> yea, true that, what'd we argue upon otherwise
11:50:38 <monochrom> Comprehensibility is on a need-to-know basis.
11:51:46 <monochrom> Also, you are not banging on bare metal. You are banging on doped semiconductor.
11:51:57 <Anikaiful> math equations are something what go far above my scalp, until presented in code format - then they're all clearr.
11:52:07 <ski> Anikaiful : when i wrote "i expect `(==)' to satisfy `forall x y. x == y = True => x = y' and `forall x y. x == y = False => x =/= y'", i mean that for any two Haskell values `x' and `y' (having the same type, being an instance of `Eq', otherwise the following doesn't make any sense), if you pass them to the equality comparision function `(==)', and the result is equal to the value `True', then they'd better actually be equal values ..
11:52:40 <ski> Anikaiful : .. and something similar for when we get a value that's equal to `False' back (then they'd better be unequal)
11:53:26 <ski> Anikaiful : note that just because `x' and `y' are equal, we can't expect the call `x == y' to terminate with result `True' (`x' and `y' might be equal, but infinite, so that *checking* equality never terminates)
11:53:32 <Anikaiful> well, that much was clear, what threw me off tangent was "x == y = true" part
11:53:58 <Anikaiful> as in assigning 'true' to something what x == y produced...
11:54:15 <geekosaur> therer is no assignment in haskell
11:54:18 <ski> there is no assignment of variables in Haskell
11:54:54 <Anikaiful> yea, duly noted, but my mind still veers to thinking along such lines
11:55:12 <monochrom> Can we negotiate a compromise? Is "there is single assignment in Haskell" OK with you? >:D
11:55:28 <ski> when we write `=', we mean it in the mathematical sense, not in the "please make the mutable box named to the left from now on (until further notice) contain the current value of the expression on the right" (aka assignment)
11:55:58 <tdammers> .oO( writeIORef )
11:56:07 <Anikaiful> monochrom: I'm not arguing, even tho I may seem like so - I'm just trying to clarify it all in my head :D
11:56:21 <monochrom> Because there is a way the Haskell code "f x = f (x - 1)" is not asserting mathematical equal.
11:56:42 <ski> (and a way it which it does)
11:56:57 <monochrom> Yeah. It's complicated.
11:56:58 <dolio> monochrom: But it is. :)
11:57:12 <tdammers> yeah; it's just that the assertion doesn't hold
11:57:34 <Anikaiful> hmm, doesn't it?
11:57:43 <monochrom> Well I'm going to identity "assertion doesn't hold" with "does not assert".
11:58:06 <tdammers> f x = f (x - 1) -- means: "I define that the value of f x shall be the value of f (x - 1)"
11:58:36 <tdammers> it may actually hold, but there is no way to verify this in finite time without going meta
11:58:47 <lavalike> monochrom: apparently if you compile with -S -g you get '.loc num startline endline' entries in the output .s file
11:58:48 <ski> if `f x = f (x - 1)' is the Haskell definition of `f', then the value of both `f x' and `f (x - 1)' is "nontermination" (aka bottom). and so they have the same value
11:59:07 <monochrom> lavalike: Thanks! Neat, maybe that's how.
11:59:09 <tdammers> depending how you interpret bottom
11:59:14 <Anikaiful> tdammers: yea, with ∞ time anything's possible.
11:59:16 <ski> going meta is the whole point of using `=' (in a Haskell context), outside of definitions
11:59:51 <tdammers> ski: that's not the kind of meta I meant
12:00:10 <ski> tdammers : ok. then what did you mean ?
12:00:32 <Anikaiful> was chuckling at this  ∞ issue a moment ago with last [1..] and reverse [1..] ...
12:01:32 * hackagebot text-render 0.1.0.3 – A type class for rendering objects as text, pretty-printing, etc. – https://hackage.haskell.org/package/text-render
12:02:06 <erisco> but when reverse [1..] completes you will witness the face of infinity
12:02:21 <tdammers> ski: I meant that in order to find the value of f x for any given x, a mechanical interpreter will just blindly keep recursing and never terminate
12:02:33 <Anikaiful> or split infinite distances with my bosons 
12:02:39 <mniip> > reverse [1..] :: [Word8]
12:02:40 <erisco> legends says such bold explorers have gone mad
12:02:41 <lambdabot>  [255,254,253,252,251,250,249,248,247,246,245,244,243,242,241,240,239,238,237...
12:02:50 <mniip> please be more specific!
12:03:03 <tdammers> ski: but we can go meta and *prove* that, given the definition of f, evaluation does not halt, which means that we can decide, in finite time, what the value of f x should be
12:03:08 * erisco froths at the mouth
12:03:22 <Psybur> > reverse [1..]
12:03:28 <lambdabot>  mueval-core: Time limit exceeded
12:03:40 <Anikaiful> erisco: can one go mad if one has been mad before even born?
12:03:45 <tdammers> Psybur: you just asked what the largest natural number in the universe is :D
12:03:55 <Psybur> Yes
12:03:59 <mniip> tdammers, it's pretty small
12:04:19 <tdammers> mniip: you mean compared to the largest real number?
12:04:20 <mniip> tdammers, about 2^(2^64+64)
12:04:26 <dmwit> Anikaiful: Actually, somebody cooked up a spine-lazy reverse on here some time ago, for which `reverse [1..]` can be observed (in certain limited ways) without causing nontermination...
12:04:57 <tdammers> mniip: depends on the implementation... with idealized bignums, ...
12:06:00 <Anikaiful> dmwit: nothing unusual in that, just that there's no safeguard (implied, explicit, or otherwise) against rolling bits until infinity ceases to be was momentarily chuckle causing baffle.
12:07:31 <mniip> @let reverse_ = go [] where go ys (x:xs) = let ~(x':xs') = go (x:ys) xs in x':xs'; go ys [] = ys
12:07:33 <lambdabot>  Defined.
12:07:41 <Anikaiful> my implementation of realz can't figure out sqrt 1 ... them digits just keep going on and going on and ...
12:08:06 <Anikaiful> or was it some other number, hmm, yes. Anyway.
12:08:31 <mniip> > null $ reverse_ (1:2:undefined)
12:08:33 <lambdabot>  False
12:08:38 <mniip> > null $ tail $ reverse_ (1:2:undefined)
12:08:40 <lambdabot>  *Exception: Prelude.undefined
12:08:45 <mniip> hmm, too soon
12:08:59 <Anikaiful> > last [1..]
12:09:05 <lambdabot>  mueval-core: Time limit exceeded
12:09:11 <Anikaiful> ditto
12:09:51 <Psybur> > [undefined..]
12:09:53 <lambdabot>  *Exception: Prelude.undefined
12:10:25 <erisco> we can go symbolic
12:10:35 <ski> Anikaiful : .. i thought it was pi that was infinite, hm. better go check Bishop's Constructive analysis to make sure
12:10:45 <Anikaiful> :| Haskell is not future-proof, it doesn't know who's the last one to switch off the lights when the universe goes poof.
12:10:50 <erisco> where reverse . reverse = id
12:11:06 <erisco> and last [1..] is the biggest number
12:11:19 <erisco> what insanity could we cook up then
12:11:36 <Psybur> > [(),()..]
12:11:36 <Anikaiful> in-sanity, in other words, completely sane.
12:11:38 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
12:11:59 <ski> erisco : perhaps we could make a language where the default list type is a type of *converging* lists
12:12:02 <Anikaiful> in, viz "within".
12:12:13 <Psybur> > [()..]
12:12:14 <lambdabot>  [()]
12:12:18 <ski> erisco : then `last' of that list ought to give what it converges to
12:12:55 <erisco> I like it
12:13:55 <Anikaiful> doesn't that imply, last of infinity rebounds in ye face and ye go cry?
12:14:51 <mniip> erisco, lem doesn't hold also
12:15:01 <erisco> now how we constructively define converging sequences
12:15:01 <mniip> and all statements are true
12:15:39 <erisco> A prop infers A true, your wish is my command
12:15:42 <ski> a converging infinite list is iso to a function from the "generic convergent sequence", ⌜ℕ_∞⌝
12:15:47 <mniip> russell's paradox:
12:15:48 <mniip> fix not
12:16:05 <ski> erisco ^
12:16:31 <orion> > fix not
12:16:33 <Anikaiful> erisco: huh?
12:16:37 <lambdabot>  mueval-core: Time limit exceeded
12:16:40 <ski> (which is the one-point compactification of the naturals. it can be constructed a the type of increasing sequences of bits)
12:17:26 <erisco> ski, what is that sequence?
12:17:29 <Anikaiful> like the best compressor ever, 0 byte equals anything you can imagine, and then some.
12:17:50 <ski> erisco : ⌜[0,1,2,3,4,⋯,∞]⌝
12:18:15 <ski> erisco : or did you mean "increasing sequences of bits" ?
12:18:36 <Anikaiful> how you order that sequence tho?
12:18:37 <erisco> ski, I must have misunderstood you at "convergent"
12:18:41 <dolio> ski: Is it isomorphic to that?
12:19:14 <mniip> the function needs to be smooth, perhaps
12:19:42 <mniip> [0,1,2,3,4,⋯,∞] is an interesting topology
12:19:46 <erisco> things which tend to infinity are not convergent by my understanding
12:19:54 <erisco> but numbers confuse me
12:20:15 <Tuplanolla> Ramanujan taught us that convergence is malleable.
12:20:24 <dolio> The type that ski mentioned has an added point that allows the increasing sequence of naturals to converge.
12:20:55 <lavalike> (as well as a whole lot of open sets :D)
12:21:16 <Anikaiful> I'm not sure if I follow, but is that anything like branching out?
12:21:27 <erisco> dolio, which point? ∞?
12:21:32 <dolio> Yes.
12:21:33 <ski> erisco : ⌜{b : 𝟚^ℕ | increasing b}⌝ is the type. it contains sequences like ⌜[0,0,0,1,1,1,1,1,1,⋯]⌝ (which encodes the number three)
12:22:35 <ski> dolio : is what isomorphic to what ?
12:22:46 <haskell> o snap its registered lel
12:22:59 * ski smiles
12:23:12 * Anikaiful thinks she just snapped a vein in the last gray cell in her brain.
12:23:18 <HallaSurvivor> ski: what is this set? 2^N
12:23:22 <HallaSurvivor> why are we talking about it, rather
12:23:24 <erisco> I don't know much about infinity… you'll have to carry the torch without me
12:23:36 <ski> HallaSurvivor : infinite sequence of booleans
12:23:43 <HallaSurvivor> I agree
12:23:48 <dolio> ski: You said that convergent lists are isomorphic to functions from the "generic convergent sequence." It's not clear to me what that's supposed to mean, and therefore whether I agree.
12:23:52 <Anikaiful> hey, infinity's cool ... especially after heat death of universe ... real ... cool.
12:24:21 <HallaSurvivor> what's it isomorphic to?
12:24:30 <dolio> Does it mean `ℕ_∞ -> A`?
12:24:38 <ski> dolio : *infinite* convergent lists. if they converge, then the domain can be extended to the "generic convergent sequence"
12:24:49 <lavalike> ski: what are you denoting with ⌜·⌝?
12:24:58 <HallaSurvivor> seconded^
12:24:58 <ski> that would be one side of the iso, yes
12:25:07 <ski> lavalike : quotation
12:25:15 <dolio> Okay.
12:25:37 <Anikaiful> -.- ... I need better font: I see lavalike's message contain a "box" with 123C
12:26:05 <erisco> how does it work with pedestrian operations? ∞ + x = ∞, ∞ * x = ∞ if x ≠ 0, x ≥ ∞
12:26:24 <Anikaiful> (fontwise? fine)
12:26:31 <dolio> ski: I thought maybe you meant sequences of values of ℕ_∞, and the sequence in question was the one that starts at 0.
12:26:35 <dolio> Which doesn't sound right.
12:26:37 <erisco> ∞ ≥ x  just seeing if you're paying attention
12:26:50 * ski was going to remark on that
12:27:02 <Anikaiful> x can rightly so be > infinity
12:27:41 <ski> in this type, ⌜∞ ≥ x⌝ holds for any ⌜x⌝
12:28:45 <erisco> so what is ∞/∞ … we're asking for a k such that k*∞ = ∞
12:29:02 * Anikaiful yays for Deja fonts - now she can see all them wonky 0000 and 123C as actual characters instead.
12:29:03 <erisco> which, by our axiom for multiplication, is any k ≠ 0
12:29:27 <byorgey> erisco: presumably this is only a ring, so there is no / operation
12:30:07 <Anikaiful> erisco: +/-∞
12:31:50 <erisco> speaking of negative infinity, ∞ * (-1) = ∞ = -∞
12:31:59 <cocreature> Anikaiful: here, have some unicode characters: Ψℕ∀ℝ∂ΔΞ√ΦΓΨΞ√ΨΓΦℚℂ⇐Π⇒∩↦ℝ∂εℕℝ∂Δℚ›³²¹¢¥›³›‹¢⋃⌋⊷⌉≪∩≫⊃⊶⊂≤∪≥
12:32:10 <erisco> so maybe I should fix the multiplication axiom…
12:32:13 <lavalike> in my limited experience in issues purely regarding topology, like compactification, you'll find results don't care about other aspects (like algebraic structure) most of the time
12:32:39 <Anikaiful> cocreature: \o/ thanks! Proved my font now works, can see them all as-is instead of funky boxes with numbers within.
12:33:10 <fizbin> Hey, I think I must be suffering from sleep deprivation or something and seem to have lost the ability to interpret type signatures with "forall." in them. Anyone want to explain to me how "wrapAction" at the bottom of https://hackage.haskell.org/package/snap-server-1.0.3.0/docs/src/Snap-Internal-Http-Server-Thread.html compiles?
12:33:28 <fizbin> Specifically, how does "action restore" typecheck?
12:33:46 <fizbin> Isn't "restore" not the right type to be fed as the first argument to "action"?
12:35:03 <Anikaiful> <-- blatantly naive. Aren't type's Capital. And vars/funcs lowcap?
12:35:09 <dolio> There's no -1 in the extended natural numbers.
12:35:12 <ski> see e.g. "The intrinsic topology of a Martin-Löf universe" by Martín Hötzel Escardó in 2012-03
12:35:22 <fizbin> Actually... hrm. Maybe I do see how this compiles after all.
12:35:29 <fizbin> The parens screwed me up.
12:35:37 <ski> (you can get it from <http://web.student.chalmers.se/%7Emd9slj/tmp/universe-indiscrete-and-rice.pdf>. it's an earlier version of a somewhat reworked paper)
12:35:56 <byorgey> Anikaiful: constructors are Capital (both type constructors and data constructors)
12:36:06 <byorgey> and variables are lowercase, yes
12:36:07 <monochrom> fizbin: Yes, hehe.
12:36:31 <Anikaiful> byorgey: well yea, I just lumped the 'definitions' under one hood.
12:36:35 <c_wraith> byorgey: sadly, there isn't a third option for type families
12:37:02 <monochrom> Law of Excluded Middlecase
12:37:17 <Anikaiful> Midriffs and Midgets beware.
12:37:33 <ski> perhaps we could use cyrillic ?
12:38:08 <erisco> it doesn't feel right for infinity to suddenly become incoherent just because we start using integers instead of naturals
12:38:19 <erisco> same for rationals and so forth
12:38:41 * ski . o O ( "Language of the Included Miracle" )
12:38:54 <Anikaiful> ski: might work, math's full of greek, so why not cyrillic
12:39:02 <erisco> anyways, what is the hotness in rewriting right now?
12:39:14 <dolio> Well, you can do the one-point compactification of the integers, too.
12:39:19 <fizbin> Okay, so, different question: does anyone know how, in Haskell, one can detect that a network socket has closed? Ideally, I'd like a pre-made solution for detecting that the client has gone away from inside snap-server, but I'm reasonably certain that doesn't exist, so I'm looking at how to build it up using lower level stuff on io-streams and messing with snap-server's guts.
12:39:20 <erisco> I am seeing port graph rewriting, but I am not sure if graphs is that interesting to me
12:39:22 <monochrom> I am OK with Cyrillic. Much better than Gothic anyway.
12:39:46 <ski> @quote top.enterprise
12:39:46 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment.
12:39:46 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
12:39:54 <Anikaiful> fizbin: I don't know Haskell, but doesn't that toss IOException?
12:40:10 <c_wraith> fizbin: the network library is a pretty low-level wrapper around unix sockets.
12:40:24 <dolio> Defining it nicely as a type might be harder.
12:40:52 <dolio> Putting an infinity on both ends would probably be easier.
12:40:52 <c_wraith> fizbin: so figure out how you'd do it with unix sockets, then see how that translates into what network does
12:41:25 <monochrom> Go projective plane! Have a whole line/circle of infinities!
12:41:31 <fizbin> c_wraith: At the C level the advice usually starts with details about how one should use "select" or "epoll". It appears that Haskell calls those insid IOManager.
12:41:47 <ski> dolio : i suppose a sequence that goes both directions
12:42:19 <dolio> monochrom: That'd be a little weird when your non-infinite points don't form a plane.
12:42:24 * ski idly wonders whether there's such a thing as linear relations
12:42:45 <dolio> You wondered that yesterday. :)
12:42:50 <ski> i did
12:43:15 <geekosaur> the short version is: you cannot determine the remote closed except by attempting to read and getting EOF or a connection error (e.g. ECVONNRESET)
12:43:50 <geekosaur> select()/poll()/etc. will return a socket with such pending condition as readable.
12:44:13 <Anikaiful> fizbin: don't know much C, less Haskell, but on ground level there's somewhere a flag that contains the bits and bobs about what went wrong (or just statement, on line, 'client decided to go AWOL')
12:44:32 <dolio> ski: Maybe it's a span in a category where arrows are linear maps.
12:44:47 <dolio> Or a cospan.
12:44:57 <ski> is "span" the same as "jointly monic" ?
12:45:04 <fizbin> geekosaur: Do you know the Haskell equivalent of select/poll/etc? Because I've been looking and haven't found anything.
12:45:05 * Anikaiful isn't sure if her statement made anything any clearer.
12:45:29 <geekosaur> fizbin, it's doen via the I/O manager, specifically threadWaitRead
12:45:30 <fizbin> geekosaur: It all seems to be "that's internal GHC implementation stuff, don't worry about it"
12:45:31 <dolio> A span between two objects is just two arrows from a common third object.
12:45:44 <geekosaur> (or resp. threadWaitWrite)
12:45:53 <dolio> They compose by pullback.
12:46:39 <Anikaiful> fizbin: there's this https://www.reddit.com/r/haskell/comments/4vz3gs/polling_on_sockets/ ... but idk if it answers anything relevant.
12:46:41 <geekosaur> you do not want to invoke select/poll/whatever yourself. you will break threading.
12:46:51 <geekosaur> go through the I/O manager.
12:47:08 <ski> dolio : say `f : S >---> A' and `g : S >---> B', together with the condition that for any `T' and any `x,y : T >---> S', if `f . x = f . y' and `g . x = g . y', then `x = y' (that's "jointly monic")
12:48:34 <dolio> ski: Requiring the maps to be monic is going to limit the relations you can describe, I think.
12:48:54 <dolio> Unless `>--->` doesn't mean the maps are individually monic.
12:49:04 <ski> it just means morphism arrow
12:49:07 <dolio> Oh.
12:49:11 * ski is weird like that
12:49:30 <dolio> Usually putting the tail on means monic in category theory.
12:49:32 <byorgey> Anikaiful: trying to answer questions you know nothing about is probably not very helpful.  It mostly just creates noise.
12:49:38 <dolio> And -->> means epic.
12:49:51 <ski> (i write monic morphism as `>>--->' and epic as `>--->>')
12:50:04 * ski knows
12:50:14 <Anikaiful> byorgey: probably/likely, on off chance might give insight.
12:51:18 <dolio> ski: Does this just prevent you from having redundancy?
12:51:33 <ski> i find it more symmetric
12:51:45 <dolio> There is at most one element of S that relates two items in A and B, basically?
12:52:04 <ski> oh. yes, i think so
12:52:23 <dolio> So, I don't think people usually care about that with spans. But that'd make it more relation-like.
12:52:41 <dolio> I don't know if it's preserved by pullback, either, which could be a problem.
12:52:43 <ski> this is how Colin McLarty does it in "Elementary Categories, Elementary Toposes"
12:52:46 <dolio> Maybe it is, though.
12:53:10 <ski> perhaps without the jointly monic condition it's in some cases more convenient (or less ?). i dunno
12:53:27 <dolio> Monic is preserved by pullback, I think.
12:53:46 <ski> i vaguely remember pullbacks being used for composition, yes
12:53:46 <dolio> So I guess there's a good chance that jointly monic is.
12:54:29 <Anikaiful> byorgey: I could've given a direct answer on next-to-hardware level, but that'd not scraped the issue at hand from asker's pov at all.
12:54:47 <ski> so, this is basically a generalization of subobjects
12:56:10 <ski> dolio : so .. i suppose i'm more interested in finding out whether folks have had any use for this concept (linear relation), rather than trying to figure out the theory and uses all by myself ..
12:56:16 <dolio> I mean, that makes sense, in that relations are generalizations of predicates.
12:57:00 <dolio> In some ways.
12:57:14 <ski> dolio : e.g., could derivatives be made to give a linear relation (e.g. in the implicit function theorem)
12:57:17 <ski> ?
12:59:10 <Anikaiful> <- math deficient, "implicit function theorem"?
12:59:17 <dolio> No idea.
12:59:24 <ski> (in the present context, i was thinking of the linear endorelations on the reals as a circle, because monochrom mentioned projective geometry)
13:00:21 <Anikaiful> I think my IQ just collapsed below 10, but on the other hand, I think I 'see' what you mean.
13:00:35 <ski> Anikaiful : when you can't write the equation for your curve as `y = ..x..', but only `..x..y.. = 0'. instead of expressing `y' "explicitly" in terms of `x', you express it "implicitly"
13:00:59 <dolio> https://ncatlab.org/nlab/show/connected+relation
13:01:11 <ski> Anikaiful : e.g. the equation `x^2 + y^2 - 1 = 0' for the unit circle
13:01:21 <Anikaiful> ah!
13:01:25 <dolio> Probably not what you're looking for. :)
13:01:45 <ski> Anikaiful : then, you can still work out the derivative (slope) of a point on the curve, using the "implicit function theorem" in analysis (multivariable calculus)
13:01:53 <ompaul> eh please use ' on both ends or ` on both ends of your equation ;-
13:01:55 <ompaul> ) 
13:02:19 <ski> ompaul : it's ingrained
13:02:47 <jle`> it's the LaTeX way
13:02:47 <Anikaiful> hm, this faintly sounds "roughtly similar(ish)" to light reflection math...
13:03:09 <jle`> LaTeX \texttrademark
13:03:16 <deech> sorry for the xpost from #haskell-stack: is the documentation on downloading dependencies from Github still current (https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md see 'Git and Mercurial repos'). When I try it I get 'Aeson exception: Error in $['extra-deps'][0]: failed to parse field 'extra-deps': expected PackageIdentifier, encountered Object'.
13:03:17 <Tuplanolla> The LaTeX way would be $this$ or \lstinline{that}, jle`.
13:03:38 <jle`> referring to ``hello''
13:03:54 <jle`> but yes indeed
13:03:58 <jle`> :)
13:04:01 <ski> Anikaiful : in this case, the derivative doesn't exist at points `(x,y) = (-1,0)' resp. `(x,y) = (1,0)'. but with a linear relation, we could say that the slope is "infinity", more precisely the linear relation that relates zero to everything, and relates anything non-zero to nothing at all
13:04:05 <monochrom> Aw, please don't write $this$. Please write $\mathit{this}$.
13:04:44 <monochrom> Or even better, please don't even use LaTeX.
13:05:44 * hackagebot merkle-patricia-db 0.1.0 – A modified Merkle Patricia DB – https://hackage.haskell.org/package/merkle-patricia-db
13:05:44 * hackagebot diversity 0.8.1.0 – Quantify the diversity of a population – https://hackage.haskell.org/package/diversity
13:06:01 <ski> (picturially, the graph of that linear relation looks like a vertical line crossing the origin)
13:06:14 <Anikaiful> ski: wholly unrelated, or totally bullseye... but man, that's like trying to figure the electron's "vector"... will take a "while" for me to figure out what you just said.
13:06:25 <geekosaur> math italic is not italic. it looks horrid for text
13:06:42 <jared-w> Not just LaTeX, using `` '' is standard in a lot of old unix stuff like troff as well. It was common to use that for typography quotes since it looked closer to the real quotes used in newspapers and such
13:06:50 <geekosaur> its metrics are designed for equations
13:07:24 <Anikaiful> troff == troll ...
13:07:28 * ski smiles
13:07:53 <monochrom> Oh, \textit{this} is of course the right thing to do if it's text rather than a math variable.
13:08:33 <monochrom> (Is it \textit? Or is it \itfamily?)
13:08:52 <ski> Anikaiful : i don't know whether you know anything about multi-variable calculus
13:09:05 <jared-w> It's both depending on phase of the moon, document practices, and which stack overflow answer you're reading
13:10:04 <Anikaiful> ski: yes/no, depends. Funky functions with greek "E"'s and whatnot weirdo non-ascii stuff is hard to come by with a glance.
13:10:13 <ski> Anikaiful : usually, the derivative of a function (from the reals to the reals, say) at a point (by which i mean : at a real number) is considered to be a (real) number
13:10:40 <jared-w> lol
13:11:11 <ski> Anikaiful : but when you want derivatives of functions between multi-dimensional spaces (like the plane, three-dimensional space, &c.), this simple picture doesn't hold anymore
13:11:36 <Tuplanolla> This would be the perfect time to plug geometric algebra.
13:12:02 <Anikaiful> ski: well, from my non-math background, negatives are equally natural than 0+s.
13:12:22 <jared-w> "ever wanted to learn how to divide by a triangle? Multiply by a dodecahedron? Integrate using the batman function? Take geometric algebra!"
13:13:19 <monochrom> "Ever wanted to compare a temperature with a boolean list? Learn Python!"
13:13:39 <Anikaiful> ski: but you meant just shift to multiple "dimensions" (in terms of [1], [1,1], [1,[1,1],[1,[1,1,[1,1,1]]] ?
13:14:05 <ski> Anikaiful : given a (differentiable) function from `n'-dimensional (euclidean) space (points are `n'-tuples of real numbers) to `m'-dimensional spaces, its derivative, at a point in `n'-space, is an `m'-by-`n' matrix (containing partial derivatives), or, which is the same thing here, is a linear transformation/function from `n'-space to `m'-space
13:14:48 <Anikaiful> ski: that makes more sense now.
13:14:52 <mnoonan> monochrom: as if a list would ever hold homogeneous-typed data :)
13:15:55 <Anikaiful> ski: (not that I know euclidean or his pals w/o google)
13:16:14 <ski> Anikaiful : e.g., if we have a function from the plane, to the line (visualized as a "landscape"), the derivative is "basically" a vector that gives the steepest direction at each point
13:17:35 <Anikaiful> ski: *ponders* I redact my statement about light reflection math, this goes tad lot beyond.
13:17:51 <jared-w> ooooh
13:17:52 <ski> Anikaiful : now, for a plain function from the reals to the reals, the derivative (at a point) would then be a `1'-by-`1' matrix, or equivalently a linear function from the line to the line -- but such a function is fully specified by a scaling factor. hence why we usually simplify here and say that the derivative is a number
13:18:02 <jared-w> So /that/s what gradients are. Duh... Never really made that connection before
13:18:10 <ski> (but if we're doing science, with units, then the units differ)
13:18:47 <ski> Anikaiful : makes any sense at all ?
13:19:08 <ski> (i realize that more experience with calculus is probably needed to appreciate this better)
13:19:13 <jakub> hi, how do functional dependencies interact with constraints? I have this little example http://tinyurl.com/yczpjkb6 which produces an error with ghc 8.0.2, I would expect ghc to be smarter in this case (what am I missing?)
13:19:17 <Anikaiful> ski: frankly? No, but I try to digest that a bite by bite.
13:20:20 <Anikaiful> ski: in essence most of that went way beyond my comprehension, until you mentioned matrixes.
13:20:24 <ski> jared-w : technically, in that place-to-line example, the derivative is actually a "covector". this makes a difference when you're changing basis
13:21:10 <ski> Anikaiful : matrices are a way to represent linear transformations/functions (between *finite*-dimensional spaces) more "concretely"
13:21:27 <Anikaiful> ski: matrixes I know and am comfortable with, but most other math-related "jargon" takes a while to chew.
13:21:56 <mnoonan> df
13:21:59 <mnoonan> argh
13:22:19 <ski> (and matrices are not just "two-dimensional arrays". matrices comes with the expectation that they describe phenomena that can be phrased in terms of linear algebra. not just any random table of stuff)
13:22:21 <jared-w> ski: ahh that makes sense
13:23:09 <Anikaiful> ski: aye, matrices are n-dimensional, you just use whichever depth is required.
13:23:54 <lyxia> jakub: there are no functional dependencies for T
13:24:11 <dmwit> jakub: Actually, that error looks pretty sensible to me.
13:24:34 <dmwit> jakub: Just because `T And ()` implies `T Or ()` doesn't mean that `T And Bool` implies `T Or Bool`, say.
13:24:42 <Anikaiful> ski: is that the core of the question about multi-....word ... variables?
13:25:02 <lysergia> I've got Persistent models like a Product & ProductVariant(w/ ProductId & Price fields). Is it possible to return products ordered by ProductVariantPrice w/ Persistent or Esqueleto? I've done it in haskell but its inefficient: http://sleepanarchy.com/p/kGxkC5
13:25:06 <Anikaiful> ski: (my Engrish fails here)
13:25:57 <dmwit> jakub: Okay, I take it back. After staring more I agree the error is not sensible. =P
13:26:57 <dmwit> jakub: Interestingly, if you just define `dual1` as a function (with the given type signature and implementation) there's no error.
13:27:15 <Anikaiful> dmwit: T And () .. T Or () .. aren't those both false, even if () == () ?
13:27:20 <dolio> What's the error?
13:27:47 <ski> Anikaiful : i suppose an example wouldn't hurt. say we have `F : |R^2 >---> |R^3' (a surface in space), which can be specified by its three "components" `f,g,h : |R^2 >---> |R' (namely `F(x,y) = (f(x,y),g(x,y),h(x,y))'). then `D F (x,y) : |R^2 >---> |R^3' (the derivative of `F' at `(x,y)') is a `3'-by-`2' matrix :
13:27:54 <dmwit> dolio: "Could not deduce (T Or h) arising from a use of ‘t’ from the context: (Dual And g, T And h, T g h)"
13:27:54 <ski>   [ d f(x,y) / d x , d f(x,y) / d y
13:27:58 <ski>   ; d g(x,y) / d x , d g(x,y) / d y
13:28:08 <ski>   ; d h(x,y) / d x , d h(x,y) / d y
13:28:08 <ski>   ]
13:28:13 <dolio> Oh.
13:28:28 <dmwit> dolio: Whereas I think `Dual And g` should be enough to know `g ~ Or`, so `T g h` would be `T Or h` as needed.
13:29:00 <ski> Anikaiful : searching for multivariate, or multi-variable ?
13:29:05 <dolio> Okay, well, if your expectation is that fundeps cause GHC to figure out type equality constraints, your expectations are broken.
13:29:09 <jakub> dmwit: exactly
13:29:14 <jakub> dmwit: but it isn't
13:29:29 <dmwit> dolio: No, that's not my expectation. But I do expect `(Dual And g, T g h)` to imply `T Or h`.
13:29:36 <Anikaiful> ski: aside for a concrete picture, aye.
13:30:05 <geekosaur> jakub, can you try this with 8.2.1?
13:30:07 <Anikaiful> ski: (not that you could draw a pic with more dims anyway)
13:30:08 <dolio> Yeah, I dont' think that happens.
13:30:13 <ski> (Anikaiful : those are partial derivatives .. not that i agree fully with distinguishing them that clearly from total derivatives)
13:30:14 <geekosaur> it sounds a bit familiar
13:30:15 <dolio> Fundeps are really dumb.
13:30:16 <dmwit> dolio: (And indeed it does seem to be suitable *outside* a class instance!)
13:30:56 <Anikaiful> ski: why not agree?
13:31:09 <ski> it's not a dichotomy, either-or
13:31:10 <dmwit> dolio: Can you explain why `dual1' :: (Dual f g, T f h, T g h) => f -> h; dual1' = t. dual` (in other words, the exact same source, but with no extra `class`) does not give the same error?
13:31:11 <geekosaur> and also faiiar is a recent bug report to theabove extent (that fundeps are more limited than you expect)
13:31:20 <ski> and in many situations, there is no difference at all
13:31:24 <Anikaiful> ski: ah
13:31:36 <geekosaur> gah. another new keyboard, typing much worse than usual
13:31:48 <geekosaur> (damaged usb connector on old one)
13:32:08 <Anikaiful> just faceroll the keys, the meaning is eventually correct
13:32:21 <ski> Anikaiful : when it matters is when you have "dependent" variables in the mix (as i believe is often common in physics, and probably also technical applications)
13:32:46 <dmwit> dolio: Or, to say it another way: why would *adding* constraints (namely, `f ~ And`) cause a compiling thing not to compile?
13:32:53 <dolio> dmwit: Let me think about it. I have to remember the weird way that fundeps work.
13:33:08 <Anikaiful> ski: idk about physics, but in tech pretty much everything depends on something else
13:33:57 <dolio> dmwit: So, I think this is what it's doing.
13:33:58 <Anikaiful> ski: as in, something be it something measured.
13:34:10 <dmwit> dolio: For what it's worth, when I try adding `f ~ And` to the context for `dual1'` (my modified extra-class-free version above), the error becomes an ambiguity check error, which seems like it might be a clue.
13:34:16 <dolio> It uses the fundep to figure out that dual :: And -> Or.
13:34:31 <Anikaiful> ski: hard to build anything based on abstracts...
13:34:42 <ski> Anikaiful : let's say that we have `x = f(t)' and `y = g(t)', and we're asking about `d h(x,y,t) / d t'. interpreting this as a partial derivative, we basically ignore the definitions/constraints of `x' and `y' on `t', while figuring out the drivative. interpreting it as a total derivative, we take those dependencies into account
13:34:44 <dolio> But it _won't_ use the fundep to figure out that g = Or.
13:35:29 <geekosaur> https://mail.haskell.org/pipermail/glasgow-haskell-users/2017-July/026557.html
13:35:34 <geekosaur> is this relevant?
13:35:40 <dolio> So you're left with T g (), but you need T Or () for t to work.
13:36:04 <dolio> And it works in the abstract case because the fundeps can't actually kick in, it's just matching variables up.
13:36:05 <monochrom> Anikaiful: I'm pretty sure you're reading "dependent" wrong. Because "dependent variables" exists because "independent variables" also exist.
13:36:19 <ski> Anikaiful : well, we might have a landscape, with a railroad track. and `h' measures the height, while `f' and `g' give the position of the train
13:36:33 <Anikaiful> ski: um, rolling back a bit, to more "ground level", how do you derive 't' if you don't take x and y in account there?
13:36:48 <Anikaiful> ski: oh! oh, ok
13:37:20 <Anikaiful> ski: clear now
13:37:22 <ski> (that's not quite a good candidate interpretation of what i wrote, but it may suffice to give a general idea of the kind of situation)
13:37:51 <dolio> dmwit: Basically, fundeps do not participate in constraint solving properly. It's more like they cause some defaulting/concretization as a post-process.
13:38:33 <ski> Anikaiful : it's as if, when figuring out the derivative here, we're very slightly (infinitesimally) modifying `t', and see how that modifies `h(x,y,t)'. in one case (partial), we're ignoring how modifying `t' would modify `x' and `y'. in the other case (total), we don't
13:38:39 <Anikaiful> ski: tho, on that we expand on, train(vector, x, y, z)
13:38:45 <dolio> dmwit: This is a good exmaple of how terrible they are, though. :)
13:39:17 <Anikaiful> ski: or did I go totally off track?
13:39:30 <jared-w> dolio: it'd be great if we had true constraint solving participation with fundeps... 
13:40:00 <ski> Anikaiful : another way to express it is that in the partial case, we're computing `let x = f(t); y = g(t) in d h(x,y,t) / d t', while in the total case, we're computing `d (let x = f(t); y = g(t) in h(x,y,t)) / d t' (taking the deps into account, for the derivative)
13:40:40 <ski> (so the difference is where we apply the `let', outside or inside)
13:41:04 <dolio> Yeah. I mean, it could be done. It just isn't done, because the implementation of fundeps is really old, and doesn't work in the nice way that all the other stuff does.
13:41:15 <ski> now, of course you could leave some deps outside, and bring others inside the derivative -- which is why i'm saying this isn't an either-or
13:41:39 <Anikaiful> ski: x <- f(t), y <- g(t) == d h(x,y,t)...?
13:41:59 <ski> i don't know that notation
13:42:01 <Anikaiful> ski: + the stuff d t'
13:42:37 <dmwit> dolio, geekosaur: Thanks for the discussion!
13:43:23 <Anikaiful> ski: wasn't really notation, just trying to make the relations clear in my head, x = return of f(t); y = return of g(t) in bounds of "d h(....) / ..."
13:43:55 <dolio> I guess those should be `T g h` and `T Or h` in my explanation.
13:44:08 <dolio> If it were `T Or ()` it would work.
13:44:11 <ski> Anikaiful : do you know what "dynamic scoping" is, in programming ?
13:44:29 <Anikaiful> ski: to some slim extent
13:44:41 <ski> Anikaiful : "dependent variables" in math is basically the same thing
13:46:08 <Anikaiful> ski: hmm, not sure about my dynamite scoping, but that's like saying me ... not a whole lot. I fell off the track on that.
13:46:15 <ski> Anikaiful : "ordinarily" (not really) in math, if we say `y' is defined by `..x..' (some expression mentioning `x'), then we (ought to) mean that `y' is defined as a fixed value, computed from the fixed value of `x' that's currently in scope
13:46:32 <jakub> geekosaur: i might try but it will take time
13:46:52 <ski> Anikaiful : e.g. is `x' is known to be `5' at this point in the text, and the expression was `x^2 + 1', then `y' is definitely defined to be `26'
13:47:03 <Anikaiful> x = zyz if d happens to be o >= a, otherwise it's klingons?
13:47:39 <ski> Anikaiful : however, in practice, when people say `y' is defined by `..x..', they *usually* mean that `y' is a "dependent variable", depending on the (independent) variable `x'
13:47:57 <geekosaur> jakub, re the discusion I don't think it wil help now. you want to red the mailing list message I linked to instead
13:48:16 <geekosaur> or read the discussion between dmwit and dolio in backscroll
13:48:17 <ski> Anikaiful : by which we mean that whenever we later use `y', we're to use the *then* current value of `x' to determine the corresponding value of `y', using the given formula
13:48:36 <Anikaiful> ski: y = (void*)X(input) ... or y = (dynamic)yerFunction("thing")?
13:49:15 <dolio> jakub, geekosaur: Yeah, I don't think it's a new bug. It's an old, fundamental design issue.
13:49:20 <ski> Anikaiful : Emacs Lisp is one of the most well-known programming languages having dynamic scoping (as default)
13:49:47 <Anikaiful> ski: lisp gave me a headache, and that was 20 years ago, it's still ongoing.
13:49:56 <ski> Anikaiful : if we imagine C had dynamic scoping, then `int y() {return x*x + 1;}' would use whatever `x' was in scope at the place where `y' was called
13:51:16 <sssilver_> I loathe whoever came up with this "look a monad is just a monoid blablabla" crap
13:51:19 <sssilver_> yeah it sounds smart
13:51:27 <ski> sssilver_ : it's a joke
13:51:34 <sssilver_> it also alienates a whole bunch of people and makes them never want to even consider the language
13:51:36 <sssilver_> I know
13:51:38 <sssilver_> it's hilarious
13:51:45 <sssilver_> I've laughed at it multiple times
13:51:53 <dolio> It's not hilarious.
13:51:56 <sssilver_> I also have no clue what an endofunctor is
13:52:03 <sssilver_> yet I successfully use both Haskell and monads all the time
13:52:11 <Anikaiful> ski: ah, so, it's more like "x = (void*) y (void* data) { return (void*)((YourType)data * (YourType)data + (YourType)+1); }
13:52:39 <monochrom> No, instead, I loathe people who just read stuff off the Internet out of context.
13:52:57 <Anikaiful> ski: that's one convoluted garbage I typed, but it cleared the intention, for me.
13:52:59 <dolio> It's bad programmer meme humor.
13:53:46 <dolio> The problem is the people who repeat the memes, though, not the person who came up with the joke.
13:53:52 <Tuplanolla> If things with M × M → M are called magmas, surely things with M → M also have a silly name.
13:53:59 <mbrock> it's interesting that we consider Emacs Lisp archaic for not having lexical scoping (it does, now, optionally) but we don't consider other languages impaired for lacking dynamic scoping :)
13:54:15 <ski> Anikaiful : i suppose you could think of it as implicitly passing along `x' (or whatever) to any function that might want to depend on it, dynamically
13:54:25 <ski> (Anikaiful : which is how it's implemented in GHC)
13:54:32 <dolio> That's because not having dynamic scoping isn't a "lack". :)
13:54:43 <monochrom> Dynamic scoping is too hard to use. I don't miss it. Along with self-modifying programs.
13:54:50 <monochrom> Good riddance
13:55:10 <Anikaiful> self-modifying progs are king
13:55:29 <mbrock> lexical scope by default with optional dynamic scope seems pretty reasonable
13:55:29 * ski idly recalls writing code that modified code that modified code that modified code
13:56:04 <Anikaiful> ski: recall some C64 games, Sentinel?
13:56:09 <mbrock> I think of a computer as a self-modifying program, from the software perspective
13:56:16 <Anikaiful> self-mod to extreme
13:56:29 <mbrock> That's like what it means to have a general purpose computer
13:56:38 <koz_> ski: A 'Sup dawg' joke seems appropriate here. :P
13:56:39 <jle`> mbrock: for a Von Neumann architecture computer, that's not too far from the truth
13:56:44 <ski> Anikaiful : i don't recall seing that particular one
13:57:08 <ski> btw, `RebindableSyntax' uses dynamic scoping, at the syntax level
13:57:13 <ystael> Anikaiful: there's always Starflight, which as I recall had "update some values in the primary program binary on the floppy" as its save game mechanic
13:57:14 <jle`> mbrock: but not all general purpose computers necessarily mix program and memory in the same place
13:57:30 <Anikaiful> ski: a genius game, crap gameplay, but the idea and how it was implemented under the hood.
13:58:38 <Anikaiful> human == mediocre example of self-modifying code.
13:58:49 <ski> Anikaiful : <http://www.zzap64.co.uk/zzap20/senti.html> ?
13:59:00 <Anikaiful> just on cellular/molecular level...
13:59:05 <mbrock> jle`: yeah, like "establishing boundaries" is a basic part of architecture, e.g separating code from data
13:59:14 <Anikaiful> ski: yea, that one
13:59:46 <mbrock> Lisp and Smalltalk and other reflexively dynamic systems blur the code/data distinction
13:59:46 <ski> ystael : sounds like great fun
14:00:22 <monochrom> Dynamic scoping and self-modification stand in the way of separating concerns, of modularity, of the ability to combine two smaller programs into a bigger one and still predict what the combination does.
14:00:41 <ski> jle` : .. perhaps they ought to
14:00:46 <Anikaiful> I want a language, that lets me go make coffee while it comes up with a paradigm shift producing genius piece of art.
14:01:21 <jle`> mixing program and memory was a pretty big deal(tm) at the time
14:01:30 <ski> (recall that for a sufficiently advanced data type, a catamorphism from it can be considered an interpreter for a custom language. so data is code)
14:01:44 <dmwit> Tuplanolla: endofunctions ;-)
14:01:50 <erisco> well I think you can set that up as a constraint problem for Z3 and it'll get back to you on that, Anikaiful
14:01:59 <ski> (also, for RTCG, you want to be able to execute stuff you've just written)
14:02:03 <Anikaiful> data == code, or the other way round. Depends on context...
14:02:04 <Tuplanolla> That doesn't describe the underlying set, dmwit.
14:02:30 <zv> sat solving language design
14:02:34 <zv> next level shit
14:02:37 <dmwit> Tuplanolla: It describes the underlying set in the same sense a magma does.
14:02:57 <Anikaiful> in immutable languages some optimization might come from data == code <-> code == data
14:03:01 <monochrom> Empirically, in this real world, even now javascript's eval has become a liability not an asset.
14:03:05 <ski> mbrock : i'm actually not sure in which way they blur it, apart from the obvious ones : syntax, and DSLs
14:03:19 <Anikaiful> eval = bad.
14:03:47 <erisco> a spin off of Hitchhiker's Guide… what is the ultimate program? we'll need to first compute the ultimate programming language…
14:03:54 <Anikaiful> 42
14:03:58 <monochrom> So much for "w00t it's so powerful!" and/or "w00t it's invented by my favourite genius!"
14:04:58 * hackagebot unordered-intmap 0.1.0.0 – A specialization of `HashMap Int v` – https://hackage.haskell.org/package/unordered-intmap
14:04:58 * hackagebot fltkhs 0.5.4.0 – FLTK bindings – https://hackage.haskell.org/package/fltkhs
14:04:59 * ski . o O ( you should not use `eval', unless you know why you shouldn't use it )
14:05:00 <Anikaiful> 42 is the answer, 42 is the program. You're 42! 42 is you. Periods and commas and bosons and leptons included, 42.
14:07:34 <mbrock> One way I see it is, like, Lisp and Smalltalk are both reflexive enough that you can easily see them as self-sufficient computing environments capable of live self-modification
14:08:00 <Anikaiful> monochrom: eval was okay, back when it was required for fixing deficiencies. After that, it should be ditched.
14:08:29 * ski idly recalls having to use `eval' in Matlab, before they discovered lambdas
14:09:02 <dolio> I don't remember matlab having lambdas, and it being very inconvenient.
14:09:02 <erisco> didn't we collectively decide that self-modification was a pointless complication?
14:09:21 <monochrom> Yes but some fancy people don't want to be collected.
14:09:22 <Anikaiful> self-modification is never pointless.
14:09:24 <mbrock> I would be really really interested in what it would mean to have a "Haskell machine" in the way that you can obviously have a Lisp machine or Smalltalk machine
14:09:38 <koz_> mbrock: Something like SKIM maybe?
14:09:45 <dolio> Well, someone built one of those already, I think.
14:09:52 <Anikaiful> I for one have a lot of things I'd like to modify on myself.
14:09:52 <dolio> The reduceron.
14:09:59 <jakub> dolio, dmwit, geekosaur: thanks for the discussion, I went throught the mailing list thread. Seems I am out of luck :)
14:10:30 <dolio> It's not exactly Haskell running on it, I guess.
14:10:36 * ski idly imagines a combination of computing and the alchemy quest
14:11:02 <monochrom> The GHC API is a Haskell machine.
14:11:28 <Anikaiful> ski: science is alchemy, until it becomes ~exact~ beyond belief.
14:11:51 <erisco> then chaos theory happened
14:12:09 <dolio> I mean, there's the STG machine, too, as an abstract machine.
14:12:14 <monochrom> then machine learning also happened :)
14:12:18 <dolio> I don't know enough about lisp machines to know how comparable that is.
14:12:29 <Anikaiful> chaos theory? Nah, rumors. The only RNG you got was Big Bang, after that it's all pseudo-random.
14:13:24 <mbrock> I consider Emacs to be a kind of Lisp machine :)
14:14:00 <erisco> it isn't about randomness, it is about no amount of approximation being adequate to predict sufficiently future events
14:14:41 <Anikaiful> machine learning happened a long, long time ago - we're machines afterall, just not made-of-metals-only.
14:14:50 <erisco> because in chaotic systems the smallest variations lead to the biggest differences
14:15:04 <monochrom> Ironically, the whole point of chaos theory is to agree with pseudo-randomness.
14:15:14 <erisco> careful where you breathe
14:15:36 <Anikaiful> monochrom: if it didn't, it'd be wrong.
14:15:59 <iqubic> How does lambda notation work again?
14:16:11 <monochrom> (\x -> x+5)
14:16:18 <Anikaiful> (_x -> ...
14:16:19 <iqubic> right.
14:16:19 <Anikaiful> oh
14:16:24 <iqubic> I feel stupid
14:16:34 <Anikaiful> and I noted myself typoing
14:16:46 <monochrom> It's OK. It happens when you have to use 10 different languages on the same day.
14:17:13 <Anikaiful> monochrom: you just fixed a bug in a lil app I was messing with: \ vs _
14:17:19 <iqubic> > (\x -> x 5) (\x -> 5 + x)
14:17:21 <lambdabot>  10
14:17:24 <monochrom> I write "public class ThisIsAJavaClass where" and "class ThisIsAHaskellClass a {" all the time.
14:17:49 <iqubic> monochrom: Why does my example work?
14:17:57 <iqubic> That shouldn't work like that.
14:18:03 <ReinH> Why not?
14:18:08 <monochrom> Why it shouldn't work?
14:18:14 <Anikaiful> what's wrong with it?
14:18:26 <glguy> Yeah, why not??
14:18:37 <monochrom> First use renaming to deconfuse yourself. (\x -> x 5) (\t -> 5 + t)
14:18:40 <erisco> guys, I am getting seriously upset about this "it is wrong" idea
14:19:05 <iqubic> wait, it just takes the second function and applies it with the value 5
14:19:12 * ski . o O ( ZMacs )
14:19:15 <boj> iqubic: exactly
14:19:19 <Anikaiful> erisco: stop being upset, endorse it, hug it, embrace it, make it yours.
14:19:22 <iqubic> because that's what the first lambda says to do.
14:19:38 <ReinH> Just lambda things.
14:19:53 <jle`> there's that new isomorf thing that lets you program in wahtever syntax you want
14:19:59 <jle`> i have heard claimed
14:20:04 <monochrom> Sorry I was not evil enough.
14:20:06 <iqubic> what!?!!
14:20:19 <monochrom> (\x -> x 5) (\f -> 5 + f)  now it's better bwhahahaha
14:20:27 <jle`> https://isomorf.io/#!/tour but i haven't done it yet
14:20:35 <iqubic> monochrom: That's the same thing.
14:20:39 <Anikaiful> iqubic: you could've had a function called xyzzy: xyzzy (\f -> 5 + f) ...
14:21:17 <erisco> now find a correct typing for (\x -> x x)
14:21:18 <monochrom> jle`: Does it have a COBOL-inspired option? >:)
14:21:27 <Anikaiful> whereas within xyzzy you did (x 5)
14:21:50 <Anikaiful> isn't cobol why dinosaurs died?
14:22:04 <iqubic> erisco: can (\x -> x x) be a real thing?
14:22:24 <erisco> yes, but I wasn't posing it as a beginners question
14:22:29 <monochrom> Oh good I can design my own syntax, at least in principle.
14:22:29 <iqubic> :t (\x -> x x)
14:22:31 <lambdabot> error:
14:22:31 <lambdabot>     • Occurs check: cannot construct the infinite type: t ~ t -> t1
14:22:31 <erisco> it came up a few days ago and I was surprised by it
14:22:31 <lambdabot>     • In the first argument of ‘x’, namely ‘x’
14:22:34 <jj15> You guys make haskell look like a super complex math language. I’m lost lmao.
14:22:37 <iqubic> :t (\x -> x x)
14:22:38 <lambdabot> error:
14:22:39 <lambdabot>     • Occurs check: cannot construct the infinite type: t ~ t -> t1
14:22:39 <lambdabot>     • In the first argument of ‘x’, namely ‘x’
14:22:40 <jj15> still the newb
14:22:58 <iqubic> what is lambdabot trying to do there?
14:23:12 <erisco> it is trying to infer the type of \x -> x x which it can't do
14:23:23 <iqubic> Is there a real type for that?
14:23:25 <erisco> if it were *that* easy to find the type I wouldn't have asked :P
14:23:35 <erisco> yes
14:23:42 <iqubic> erisco: Can you use it in a valid statement?
14:23:43 <Anikaiful> ... (\x -> x x) ... Occurs check: cannot construct the infinite type: t ~ t -> t1
14:23:52 <erisco> what is a valid statement?
14:24:00 <boj> iqubic: sure, much like your prior example just consider 'x' a function, and just applies itself, infinitely
14:24:12 <erisco> anyways, as I said, I didn't mean it as a beginners question
14:24:18 <iqubic> :t fix
14:24:20 <lambdabot> (a -> a) -> a
14:24:26 <iqubic> Is it not just fix?
14:24:28 <monochrom> jj15: We didn't make it. Some Haskell committee did. We just didn't mind it.
14:24:40 <erisco> but as a beginner studying untyped LC you can certainly consider (and should) the ramifications of \x -> x x
14:24:51 <ReinH> > ($ 5) (+ 5)
14:24:53 <lambdabot>  10
14:25:01 <erisco> iqubic, well, you give me the definition of fix and tell me
14:25:21 <monochrom> OK I'm going to adopt isomorph next time I inflict programming assignments on my students!
14:25:33 <iqubic> let x = f x in x
14:25:36 <koz_> monochrom: Interesting idea.
14:25:41 <monochrom> "Types in isomorƒ are algebraic data types (ADTs)"  Sold!
14:25:42 <iqubic> @src fix
14:25:42 <lambdabot> fix f = let x = f x in x
14:25:48 <ski> jj15 : hang on in here, it's worth the trouble (if you're interested)
14:25:54 <iqubic> Hey I got that mostly right.
14:26:03 <erisco> does that look like  \x -> x x  ?
14:26:08 <iqubic> No.
14:26:44 <Anikaiful> monochrom: if they can solve x in x > ∞
14:26:45 <monochrom> (Previous years I have chosen Java but to be sure I really resent the lack of ADTs for example Maybe. The alternative in the context of my department would be Python.)
14:27:05 <Anikaiful> what's ADT?
14:27:13 <monochrom> Sorry Anikaiful, what are you talking about?
14:27:16 <iqubic> Algebreic data type
14:27:23 <ski> monochrom : what's that ?
14:27:35 <monochrom> What?
14:27:48 <ski> "isomorph"
14:27:53 <erisco> to figure out the answer you first have to find an expression that looks like x x and is well-typed
14:27:54 <Anikaiful> monochrom: them students F if they can't solve that.
14:28:10 <monochrom> jle` brought it up. Saw the link?
14:28:26 <ski> oh, up there. ty
14:28:30 <iqubic> erisco: I can't
14:28:35 <iqubic> I am not good enough
14:28:37 <erisco> … not a beginner question :P
14:28:48 <iqubic> I am still a beginner
14:28:59 <Anikaiful> what consitutes as "beginner question"?
14:29:09 <erisco> I was trying to grab some guesses from others listening in
14:29:28 <erisco> but as I said, if you are studying untyped lambda calculus, λx.xx is still interesting
14:29:29 <monochrom> Anikaiful: Is that important?
14:29:43 <iqubic> :t apply
14:29:44 <lambdabot> error: Variable not in scope: apply
14:30:04 <Anikaiful> In Haskell terms I'm a total newb, and learn step-by-step, whereas on some other level I'm an established engineer.
14:30:33 <Tuplanolla> What's that level, Anikaiful?
14:30:45 <jj15> anikaiful: Same as me too. It feels like I’m learning programming from the very beginning.
14:30:59 <Anikaiful> Tuplanolla: depends on POV. Income or experience.
14:30:59 <iqubic> erisco: I think I have something.
14:31:10 <erisco> Anikaiful, well, if you can answer the question and you consider yourself a beginner I'll change my classification
14:31:22 <boj> Anikaiful jj15 that feeling goes away, and you start seeing where your engineering experience kicks back in
14:31:50 <erisco> you need GHC, not just Haskell, I'll say that much
14:31:51 <jj15> I can’t wait. So far I’m really enjoying Haskell.
14:31:52 <Tuplanolla> What does income have to do with engineering, Anikaiful?
14:31:57 <Anikaiful> I'm not so confident about my 1+1 kicking back in, bbut shall see.
14:32:09 <Anikaiful> Tuplanolla: a lot.
14:32:43 <Anikaiful> Tuplanolla: in ways it's like politics.
14:33:30 <iqubic> Let's try starting with this: (\x -> x x) (\t -> t t).
14:33:33 <jj15> haskell reminds me a bit like python. Especially list comprehensions.
14:33:34 <monochrom> Tuplanolla: Would you be happier and raise fewer debates if s/level/proxy/ ?
14:33:49 <iqubic> Run that once and you get the same thing. It's an endless loop
14:34:15 <Tuplanolla> I can't make sense of this, so I'm going to take a nap now, monochrom.
14:34:19 <iqubic> Plugging in the second lambda into both slots of the first gives you exactly what you started with.
14:34:23 <ski> jj15 : because that's where Python got them ?
14:34:29 <iqubic> Am I getting somewhere?
14:34:33 <monochrom> Yeah, people on IRC do not have to make sense.
14:34:45 <jj15> ski: Ooooh.
14:35:01 <iqubic> :t (\x -> x x) (\t -> t t)
14:35:03 <lambdabot> error:
14:35:03 <lambdabot>     • Occurs check: cannot construct the infinite type: t0 ~ t0 -> t
14:35:03 <lambdabot>       Expected type: t0 -> t
14:35:15 <monochrom> Yes iqubic, (\x -> x x) (\t -> t t) is famous.
14:35:18 <iqubic> Well, that's also infinite.
14:35:30 <iqubic> monochrom: I just came up with that on my own
14:35:32 <Anikaiful> > reverse [1..]
14:35:36 <jj15> “Python's list comprehension syntax is taken (with trivial keyword/symbol modifications) directly from Haskell. The idea was just too good to pass up."
14:35:38 <jj15> TIL
14:35:38 <lambdabot>  mueval-core: Time limit exceeded
14:35:54 <iqubic> not sure if that's erisco wanted me to come up with.
14:35:54 <ReinH> monochrom: well, I am performing a Turing test as we speak...
14:36:08 <iqubic> ReinH: Am I man or machine?
14:36:20 <Anikaiful> I'm not Turing Complete. I don't agree with him.
14:36:35 <erisco> iqubic, my question is to find a correct type for \x -> x x
14:37:00 <erisco> iqubic, I say it is not a beginners question because it requires type features beginners shouldn't have to know
14:37:13 <erisco> you could teach this to beginners but I am not sure what need there is
14:37:33 <monochrom> If the question allows "can't be typed in Haskell" then it's still a beginner question.
14:37:52 <erisco> it *can* be typed in Haskell, that is why I was surprised by it
14:38:06 <iqubic> erisco: what does it require?
14:38:10 <erisco> came up a few days ago when someone showed me… was a special case of something else they do like this
14:38:13 <monochrom> Not as "(\x -> x x)" verbatim.
14:38:21 <Anikaiful> showing errors, even if trivial seeming by experienced people...
14:38:26 <erisco> I clarified that you need GHC and not just Haskell
14:38:32 <Anikaiful> it can make one understand things bbetter
14:38:51 <jj15> related? https://github.com/kputnam/hee/issues/3
14:38:57 <boj> erisco: maybe not an important distinction to a beginner
14:39:05 <monochrom> OK maybe the question author does not know that feature either, like me, so the question author is expecting "the answer is no"?
14:39:45 <Anikaiful> no one knows everything about everything anyway
14:39:57 <erisco> monochrom, well *I* am asking the question, and I expect it to be obvious that \x -> x x shouldn't have a type
14:40:14 <Anikaiful> how is that obvious?
14:40:42 <Anikaiful> you can reflect now, for I *am* a total newb.
14:40:52 <iqubic> \f -> (\x -> f (x x)) (\t -> f (t t))
14:41:14 <ski> `ocaml -rectypes' accepts `fun t -> t t'
14:41:25 <ski> (equi-recursive types)
14:41:38 <iqubic> λ.f(λx.f(x x)) (λt.f(x x ))
14:41:40 <erisco> well, try to give a type for x, and you should find this type becomes infinitely large
14:42:05 <iqubic> erisco, I believe the second thing I just listed is the y-combinator.
14:42:12 <Anikaiful> erisco: was lambda defined before? If not, then ...
14:42:54 <iqubic> Anikaiful: What I typed was using lambda calulus notation.
14:42:56 <erisco> the result that self-application cannot be typed in STLC is also important
14:43:10 <monochrom> Yes iqubic, it's the Y combinator.
14:43:26 <Anikaiful> iqubic: yea, I know, but to erisco's notion about beginnerrs....
14:43:27 <iqubic> Cool. It's similar to fix in a way.
14:43:45 <iqubic> Anikaiful: I have knowledge of weird parts of haskell
14:44:10 <ski> iqubic : it's the Curry version
14:44:53 <iqubic> I don't call lenses a begginer topic, but I know a lot about them
14:44:58 <erisco> what is the type of \f g x -> f x (g x)
14:45:00 <Anikaiful> iqubic: I have knowledge of scary parts of hardware that can make your coffee maker brew cookies, but still - wasn't meant at you, but at the notion of his about what's appropriate for beginner level.
14:45:42 <iqubic> erisco: I think you and me have a different definition of "type"
14:46:02 <Anikaiful> I for one found lambdas, interesting. Not difficult, but - interresting.
14:46:10 <erisco> maybe… there is more than one… but you can type \f g x -> f x (g x) in Haskell
14:46:27 <iqubic> I have a challenge: write the factorial function using fix.
14:46:41 <Anikaiful> um...
14:46:57 <Anikaiful> <interactive>:1:2: error: Variable not in scope: fix
14:47:03 <ski> @index fix
14:47:04 <lambdabot> Data.Function, Control.Monad.Fix
14:47:10 <iqubic> @src fix
14:47:10 <lambdabot> fix f = let x = f x in x
14:47:12 <erisco> since I asked a hard question and got the wrong attention I am switching to easier questions that are productive :P
14:47:39 <iqubic> :t (\f g x -> f x (g x)
14:47:40 <lambdabot> error:
14:47:40 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
14:47:44 <iqubic> :t (\f g x -> f x (g x))
14:47:46 <lambdabot> (t2 -> t1 -> t) -> (t2 -> t1) -> t2 -> t
14:47:57 <iqubic> Did I spoil the answer?
14:48:06 <Anikaiful> erisco: I like questions, but frankly, I like questions to which I have even a fraction of a chance to figure out right outcome :D
14:48:07 <erisco> to yourself, yes
14:48:29 <iqubic> Now, what about using fix to write a factorial function?
14:48:44 <erisco> what is the type of \x y -> x
14:48:53 <iqubic> that's const
14:48:59 <Anikaiful> um...
14:49:03 <erisco> const is not a type :P
14:49:12 <iqubic> a -> b -> a
14:49:26 <iqubic> no, but const has a type
14:49:30 <iqubic> which I gave
14:49:40 <Anikaiful> erisco: I don't know.
14:49:42 <erisco> now call the first function I gave "s" and the second function "k" and implement for me the identity function \x -> x
14:49:53 <erisco> using s and k only
14:49:56 <monochrom> iqubic: As it happens I have a solution on my http://www.vex.net/~trebla/haskell/fix.xhtml
14:50:06 <erisco> you get s, k, application, and parentheses
14:50:07 * Anikaiful gives up.
14:50:16 <iqubic> erisco, what are s and k again?
14:50:28 <erisco> s = \f g x -> f x (g x); k = \x y -> x
14:50:31 <iqubic> s = \f x g -> f x (g x)
14:50:39 <iqubic> Ah.
14:50:59 <iqubic> Let me think on that a bit.
14:51:05 <iqubic> I like this type of question
14:51:17 <Anikaiful> for newb, whatever does -> mean?
14:51:34 <monochrom> Function types.
14:51:38 <erisco> in terms it just separates the parameter list from the function body (in lambdas)
14:51:42 <monochrom> Err, no, wrong ->
14:51:45 <Anikaiful> in saying data S :: Derp -> Int
14:51:49 <Anikaiful> it's clear, but
14:52:09 <iqubic> that say that S takes a Derp and returns an Int
14:52:33 <Anikaiful> yea, but in lambdas, where S isn't explicit typed?
14:53:41 <Anikaiful> (I'm still reading this book ...) ... what does "->" do in middle of a lambda?
14:54:10 <boj> erisco's answer explained it
14:54:36 <Anikaiful> ... it humanly comprehensible way?
14:54:40 <erisco> if x :: A in m, and m :: B, then λx.m :: A -> B. That's how you get ->'s. Then if f :: A -> B and x :: A, f x :: B. That's how you get rid of ->'s
14:54:55 <ski> it's supposed to approximate ⌜λ x ↦ ⋯x⋯⌝. aka ⌜λ x. ⋯x⋯⌝
14:55:10 <ski> ⌜↦⌝ is the "maps to" arrow in math
14:55:17 <Anikaiful> x_x
14:55:18 <boj> a "term" is your definition. "\f g x" is the parameter list, "->" the separator, and "f x (g x)" the body
14:55:36 <iqubic> erisco, using s and k I need to get \x -> x ?
14:55:43 <erisco> iqubic, yes sir
14:55:50 <monochrom> Please don't speak like Haskell was not invented by humans.
14:56:07 <ski> ⌜\x -> x^2 + 1⌝ is "the function that, given an argument (call it `x'), returns `x' squared, plus one"
14:56:09 <Anikaiful> I think I'll just find out by experimentingg...
14:56:25 <boj> Anikaiful: if what i said didn't make sense happy to clarify
14:56:35 <ski> the definition `f = \x -> x^2 + 1' is equivalent to `f x = x^2 + 1'
14:56:45 <iqubic> Well, I now have an secondary problem. Map s and k to a function of type (a -> b)
14:57:12 <iqubic> and then I'll have the puzzle solved
14:57:23 <Anikaiful> boj: I'd be happy to clarify, if I had a faintest grasp to try clarify...
14:58:12 <boj> Anikaiful: the "->" in a lambda is like the ":" in a python function definition. just visual designators
14:58:20 <iqubic> Well, and I need to map s and k to a thing of type a
14:58:42 <Anikaiful> but \x -> x²+1 == returns x^2 + 1 explained
14:58:44 <iqubic> See mapping s and k to \x -> x is hard
14:59:54 <iqubic> Why is it so hard.
15:00:00 <Anikaiful> boj: to some extent, altho in python I usually associate : to splits
15:00:19 <boj> Anikaiful: i'm not a python user, but "def foo:" popped into my head here
15:00:35 <mac10688> can you post what all you have in lpaste iqubic ?
15:00:45 <iqubic> Sure.
15:01:15 <Anikaiful> boj: e[x:] = more or less same as haskell tail x
15:01:31 <Anikaiful> or was it last... *ponders*
15:01:37 <erisco> iqubic, well, if you start with  k  then you have  \x y -> x  does it look like there is an easy way to turn this into  \x -> x  ?
15:01:47 <Anikaiful> ah no, drop
15:02:20 <boj> Anikaiful: i was trying to find a recognizable analogy to explain the "->" in a lambda. def f(x): x + 1 = \x -> x + 1
15:02:47 <Anikaiful> boj: now THAT makes perfect sense.
15:03:06 <Anikaiful> ...at least to me.
15:03:07 <zachk> \ argument(s) here -> function body 
15:03:18 <boj> Anikaiful: cool, that was the intent :)
15:03:31 <erisco> "separates the parameter list from the function body" was cryptic? hm
15:04:15 <Anikaiful> boj: I'm not sure how to express that to someone with ~complete~ lack of any sort of programming tho.
15:04:36 <boj> Anikaiful: well, we were all there once
15:04:44 <iqubic> http://lpaste.net/358147
15:04:49 <zachk> I wouldn't start with anonymous functions if they don't know about basic named functions yet
15:04:52 <iqubic> h1 and h2 are holes.
15:04:59 <Anikaiful> boj: but then C64 and BASIC happened.
15:05:19 <iqubic> I'm not sure I'm doing that right though.
15:05:23 <boj> Anikaiful: my first programming experience was Pascal in university. i had absolutely no idea what was going on
15:05:28 <hasknix> Does anyone know of an example c2hs library that works with stack ghci? To get an interactive feel for how the FFI bindings are working?
15:05:32 <zachk> Anikaiful, try a monochrome monitor and TI-Basic :D
15:05:54 <erisco> iqubic, you might use types to direct your thinking but I think just looking at the terms will work
15:06:17 <Anikaiful> boj: my experience was C64, and it crashed. On/Off - fixed! They typed again, ok, blank screen... On/Off...
15:06:17 <iqubic> erisco: How would you tackle this puzzle?
15:06:21 <monochrom> erisco: The average person needs to be told 3 times before they understand.
15:06:40 <monochrom> Because the 1st time they aren't even reading. And the 2nd time they're still refusing to believe.
15:06:47 <maerwald> except they are as smart as you :>
15:06:59 <erisco> monochrom, gee, that sounds like my method of learning
15:07:12 <Anikaiful> most people > smarter than you expect.
15:07:14 <boj> Anikaiful: i guess my point is, we all have to start somewhere. Haskell is no different (unless you mar your thought process with existing experience)
15:07:51 <erisco> I think less cynically it may be rather explained as an uncertainty of what is technical and what is not
15:08:00 <maerwald> Anikaiful: well, some people think they are special
15:08:07 <erisco> do I just skip over this term or intuit it or do I ask for clarification?
15:08:15 <Anikaiful> boj: about mar'ing experience. Haskell so far has made me to refactor my THINKING.
15:08:17 <boj> monochrom: that seems to be the case
15:08:18 <iqubic> erisco: How would you go about turning s and k into id?
15:08:55 <erisco> iqubic, well, I would look at the terms. This is an exercise for untyped lambda calculus, though you can type it if you wanted
15:08:57 <Anikaiful> boj: ...and that'
15:08:57 <boj> Anikaiful: that's good. it's completely reshaped mine. i wish i had learned it first, the paradigm makes way more sense to me than other languages :)
15:09:06 <mac10688> iqubic, in your lpaste it looks like you have two s. is that intentional?
15:09:29 <erisco> iqubic, so I know I have  \x y -> x  and  \f g x -> f x (g x)  to play with and I want to end up with  \x -> x
15:09:48 <erisco> iqubic, so, I start thinking  \x y -> x  looks close to  \x -> x  so is there a way to get there from k?
15:09:48 <Anikaiful> boj: yea, was about to say - it so far has got me stuck in so many corners that I have no numbers for, but it has made me to think about goals in a different, very different way
15:10:12 <erisco> iqubic, and if I can't figure it out that way then I'll start looking at s
15:11:12 * hackagebot hexpress 0.1.0.0 – An express-like http framework – https://hackage.haskell.org/package/hexpress
15:11:31 <erisco> if you want to do it with types, then s :: (a -> b -> c) -> (a -> b) -> a -> c; k :: a -> b -> a  and we want  i :: a -> a
15:11:48 <erisco> so I'll look at  k :: a -> b -> a  because this seems close to  i :: a -> a
15:12:07 <erisco> and if that doesn't work I'll look at  s :: (a -> b -> c) -> (a -> b) -> a -> c
15:12:31 <Anikaiful> BUT!
15:12:38 <Anikaiful> if none of them do?
15:12:50 <erisco> I didn't ask such a cruel question :P
15:13:01 <Anikaiful> I did :P
15:13:33 <erisco> if none of them do then I expect some proof of that, by induction or contradiction or something
15:14:19 <Anikaiful> it's sorta things I deal with in every-day basis. X ~= X, but not quite. Why? Fix!
15:15:31 <erisco> try homotopy
15:16:05 <Anikaiful> eh, oughta typed likely more like "((X==X) == True) .. yargon and some klingon)"
15:16:20 <erisco> to the earlier question, first you need to find some well-typed term that looks like x x
15:16:27 <erisco> there are many examples, but an easy one is id id
15:16:40 <erisco> now, we abstract id, so (\x -> x x) id
15:17:07 <Anikaiful> um...
15:17:25 <Anikaiful> x x there is infinite loopz?
15:17:33 <erisco> no
15:17:39 <erisco> > id id "hello world"
15:17:39 <ski> not yet
15:17:41 <lambdabot>  "hello world"
15:17:52 <mekeor> > fix id
15:17:58 <lambdabot>  mueval-core: Time limit exceeded
15:18:04 <monochrom> This is what's wrong with imprecise, intuitive thinking.
15:18:04 <erisco> (\x -> x x) id  is not fix id, it is precisely  id id
15:18:07 <Anikaiful> oh! it's predicate to id ...
15:18:19 <ski> @let twice f = f . f
15:18:21 <lambdabot>  Defined.
15:18:32 <Anikaiful> or prefix or whatever the engrish word
15:18:35 <erisco> I said start with  id id  then abstract id, so that means  (\x -> x x) id
15:18:41 <ski> > twice twice twice ('.':) ""
15:18:43 <lambdabot>  "................"
15:18:45 <erisco> from here we can figure out a possible type for  \x -> x x
15:18:46 <iqubic> Erisco: if I have \x y -> x then all I need to do is give a y. Literally any y will work
15:18:52 <ski> > length (twice twice twice twice ('.':) "")
15:18:54 <lambdabot>  65536
15:19:04 <erisco> iqubic, mhm
15:19:31 <iqubic> Now, I can't just give k can I?
15:19:35 <mekeor> s/twice/square/
15:19:47 <mekeor> s/twice/square/g
15:19:53 <erisco> iqubic, k = \x y -> x  not  \x -> x  and so no
15:20:02 <alexashka> hi folks, a rather basic question re Aeson encoding/decoding. I feel like I'm missing something very obvious here: http://lpaste.net/358148
15:20:03 <Anikaiful> if mathematically representable and correct, but ...
15:20:23 <iqubic> Right but can I give the function s as my y or do I need a single value?
15:20:29 <ski> natural numbers are the ways to repeat an endofunction on an arbitrary set/type
15:20:45 <erisco> iqubic, you can use function application, parentheses, s, and k
15:21:04 <Anikaiful> you ofc can toss the function at whatever, but the result is ...
15:21:28 <erisco> :t (\x -> x x) :: (forall a. a -> a) -> a -> a
15:21:30 <lambdabot> (forall a1. a1 -> a1) -> a -> a
15:21:57 <iqubic> Alright then. Time to take \f g x -> f x (g x( and collapse it to a single value
15:22:40 <erisco> :t (\x -> x x) :: (forall a b. a -> b -> a) -> a -> b -> c -> b
15:22:41 <lambdabot> (forall a1 b1. a1 -> b1 -> a1) -> a -> b -> c -> b
15:22:56 <iqubic> erisco: stop messing with me.
15:23:04 <erisco> huh, why does it change my variable names... guess it doesn't know about the scopes
15:23:13 <iqubic> Can you just give me the answer to the s and k problem?
15:23:18 <mniip> ski, enthusiastically yell $ very swedish greeting
15:23:28 <iqubic> mniip: LOL
15:23:31 <erisco> iqubic, no, but I can give you hints
15:23:45 * ski disapproves of `$'
15:23:52 <erisco> iqubic, begin with s, i.e. \f g x -> f x (g x)
15:23:55 <iqubic> So what I need is a y. Any y at all
15:24:19 <iqubic> Because if I get a y then I can give that to \x y -> x and get my \x -> x
15:24:32 <iqubic> erisco: How will starting with s help me?
15:24:49 <iqubic> I need a way to apply functions to get that to a single value.
15:25:00 <erisco> I said you can use function application
15:25:09 <erisco> there is one way to apply functions, and you can use it
15:25:24 <iqubic> I only have two functions here.
15:25:41 <erisco> yes, that is all you need :) you can use as many instances of each as you want
15:25:53 <iqubic> I know. That's not really helpping though.
15:26:13 <iqubic> g is a function and f is a fuction.
15:26:31 <boj> iqubic: do you understand how partial application works?
15:26:32 <iqubic> wait. f should be \x y -> x
15:26:37 <erisco> okay, the challenge with  \x y -> x  is we have to get rid of y, so you're right that we need to apply k to something, but the y is the *second* argument
15:26:39 <iqubic> boj: I do.
15:26:57 <iqubic> But not very well.
15:27:11 <erisco> so if we do  k z  then we're left with  \y -> z
15:27:24 <iqubic> we are?
15:27:26 <Anikaiful> partial application was one of the biggest hurdles I was faced with...
15:27:37 <iqubic> Ah, yes, so we are. I see that now.
15:28:04 <erisco> so, to get  \y -> z  looking like  \x -> x  we need exactly  z ≡ y
15:28:14 <erisco> is that going to be possible?
15:28:22 <iqubic> I'm not sure.
15:28:38 <iqubic> Why do we need z and y to be the same?
15:28:47 <iqubic> where did z come from?
15:28:47 <ski> "is that going to be possible?" -- no
15:28:51 <erisco> well, we have  \y -> z  and we want  \x -> x
15:29:01 <erisco> z is just something I made up, we don't know what it is yet
15:29:05 <iqubic> Ah.
15:29:20 <erisco> so, we can rename variables if we keep scopes in mind, so  \x -> x  is  \y -> y
15:29:29 <erisco> now we want  \y -> z  to be the same as  \y -> y
15:29:41 <erisco> thus, it has to be that z is equivalent to y, and what z could that be?
15:29:44 <iqubic> How did we get rid of the x from the (\x y -> x)?
15:30:06 <erisco> k z ≡ (\x y -> x) z ≡ \y -> z
15:30:07 <Anikaiful> equivalence relation's pretty ...
15:30:22 <iqubic> right.
15:31:00 <iqubic> so we need some y such that y is equivalent to z?
15:31:10 <erisco> no, the other way around... we are solving for z
15:31:17 <iqubic> right.
15:31:25 <iqubic> So what is y in this case?
15:31:35 <iqubic> Or do we not know yet?
15:31:54 <erisco> it is a variable captured by the lambda
15:32:00 <iqubic> Right.
15:32:09 <iqubic> It's the input s to speak.
15:32:29 <mac10688> hi all, can someone help me come up with a strategy to pull information from the query function?
15:32:29 <mac10688> https://hackage.haskell.org/package/mysql-haskell-0.8.1.0/docs/Database-MySQL-Base.html#v:query_
15:32:30 <alexashka> figured it out, *facepalm*
15:32:49 <iqubic> How do I use the gnarly function \f g x -> f x (g x) to help us find z?
15:32:55 <ski> alexashka : good. i don't know Aeson ..
15:33:08 <erisco> iqubic, z is impossible, I am just trying to let you see that
15:33:11 <ski> alexashka : for posterity, what was the problem ?
15:33:34 <alexashka> ski: I needed to convert Text to a Bytestring first, that solved it
15:33:37 <iqubic> Oh, so what do we need? A moment ago yu said we needed to solve for z.
15:34:19 <erisco> iqubic, we began with the idea that we could make i (that is \x -> x) with k
15:34:34 <erisco> iqubic, we know  k = \x y -> x  and so this isn't i
15:34:47 <iqubic> And you can. Just so long as you have a y
15:34:52 <erisco> iqubic, now we figure the next thing to try with k is to apply it to something, but we're not sure what so I just called it z
15:35:09 <alexashka> ski: I had the same json string as a Text and as a Bytestring, I had assumed the Aeson function encode, will do the job, not so much, encodeUtf8 from the Text library did it
15:35:35 <erisco> iqubic, so now we have  k z  which reduces to  \y -> z
15:35:39 <ski> alexashka, ok
15:35:44 <iqubic> And can we figure out the type of z?
15:35:55 <alexashka> ski: I continue to be flabbergasted by the documentation for the most popular packages around
15:36:00 <erisco> iqubic, \x y -> x  would become  \x -> x  if we could apply k's second argument, but we can't do this with function application
15:36:07 <erisco> iqubic, function application just applies the first argument
15:36:26 <iqubic> So we need a function which applies the second argument?
15:36:40 <erisco> that would work, so then our challenge is to find that function
15:36:47 <iqubic> But we dn't have one of those.
15:37:05 <erisco> well, first, do you see why z is impossible?
15:37:15 <iqubic> Yes. I do
15:37:30 <erisco> are you just saying that or can you explain? ;)
15:37:33 <mac10688> does that function name start with the letter f erisco iqubic ?
15:37:49 <erisco> mac10688, we're not allowed to use flip, only s and k
15:38:03 <iqubic> Because we can't apply the second argument directly. We need a function to apply the second argument for us.
15:38:06 <erisco> but if we can make flip with s and k then sure, we can use that :)
15:38:10 <mac10688> geewiz
15:38:39 <erisco> iqubic, no, z is unrelated to that problem
15:38:59 <iqubic> Did I claim that it was related?
15:39:18 <erisco> well I was asking for the explanation of why z is impossible, and I thought that was your reponse
15:39:35 <iqubic> I don't know why z is impossible.
15:40:07 <erisco> okay, well we know we're trying to find a z such that z ≡ y in \y -> z
15:40:23 <erisco> but where did z come from? it came from outside this abstraction, it came from k z
15:40:28 <erisco> so z must be free of y
15:40:31 <mniip> erisco, I'm curious what's going on
15:40:36 <erisco> and hence there is no z which is equivalent to y
15:40:48 <iqubic> So z is impossiblw
15:40:49 <marvin2> is it possible to get all the field names as a list of strings?
15:41:00 <erisco> mniip, we're making i with s and k
15:41:13 <mniip> ah
15:41:27 <iqubic> Are s and k cοmmon functions?
15:41:32 <erisco> iqubic, so we ruled out k, we ruled out k z for all z's
15:41:39 <marvin2> and since all the fields have the type of double, ideally can I get [(String, Double)] (list of string names and values)?
15:41:40 <mniip> iqubic, s and k are the reader applicative
15:41:41 <erisco> iqubic, should we try k a b then? makes sense to
15:41:51 <iqubic> We should try that next.
15:41:53 <mniip> you can use <*> and pure in haskell code
15:42:05 <ski> or `ap' and `return'
15:42:10 <iqubic> But why are we starting with k and not s?
15:42:28 <erisco> it looked close, didn't it? seemed like a reasonable start, but no reason otherwise
15:42:37 <erisco> iqubic, see if there is an 'a' and 'b' such that k a b is i
15:42:40 <iqubic> Yeh, it did look close.
15:42:50 <alexashka> marvin2: have a look here: https://stackoverflow.com/questions/27815489/is-it-possible-to-list-the-names-and-types-of-fields-in-a-record-data-type-that
15:43:01 <marvin2> alexashka thanks!
15:44:33 <alexashka> marvin2: for the record, I'd say don't do it :) the messier version might be to generate json, then decode it back into tuples
15:44:39 <iqubic> erisco: I know that there should be an a and b that turn k a b into i. But I'm not sure what the a and the b are.
15:44:50 <alexashka> marvin2: that's a two liner I'd imagine, using aeson
15:45:00 <erisco> iqubic, well that is what you're trying to solve, so lets work similarly as we did for k z
15:45:09 <erisco> iqubic, (\x y -> x) a b  what does this reduce to?
15:45:13 <mniip> iqubic, the only way to turn 'k a b' into i, is if b=i
15:45:23 <mniip> and you're back to square one
15:45:32 <iqubic> Is that true?
15:45:52 <ski> s/b=/a=/
15:45:54 <erisco> go through the reductions
15:46:01 <iqubic> erisco: I don't know what (\x y -> x) a b reduces to.
15:46:12 <iqubic> a = x, b - y
15:46:15 <iqubic> a = x, b = y
15:46:28 <iqubic> a b -> x
15:46:34 <iqubic> That's what we get.
15:46:38 <iqubic> I think.
15:46:42 <erisco> okay, so we need to learn beta reduction
15:46:56 <iqubic> Yeah, I think I do.
15:47:00 <alexashka> isn't (\x y -> x) a b simply a?
15:47:20 <iqubic> Yes. It is.
15:47:27 <iqubic> It really is.
15:47:51 <erisco> so I don't have to explain the complications of variable capture, we're going to assume all variables have distinct names
15:48:17 <erisco> and we can get this by alpha conversions, i.e. we're allowed to rename x to y so long as y is not already used
15:48:49 <erisco> then  (\x -> m) a  reduces by replacing all 'x' in 'm' with 'a'
15:48:51 <Anikaiful> dem namez should be immutable too...
15:49:07 <iqubic> erisco: I just read the 4 pages under lambda calculus here: https://wiki.haskell.org/Lambda_calculus
15:49:22 <iqubic> I know how alpha cnversion works
15:49:34 <erisco> so,  (\x y -> x) a b  is  (\y -> a) b  by replacing all x's with a's
15:49:38 <alexashka> what's the puzzle you guy sare trying to solve?
15:49:41 <erisco> now reduce again
15:49:51 <erisco> alexashka, we're making i with s and k
15:50:17 <iqubic> erisco: If you reduce again you get 'a'
15:50:23 <marvin2> > printf "%*s" 17 "hi"
15:50:24 <iqubic> Nothing more and nothing less.
15:50:27 <lambdabot>  error:
15:50:27 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M131054877982...
15:50:27 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
15:50:39 <erisco> iqubic, yes sir, and so what is the 'a' and 'b' such that 'k a b' is equivalent to 'i' ?
15:50:39 <marvin2> > printf "%*s" 17 "hi" :: String   - cool, didn't know haskell's printf supports this
15:50:41 <lambdabot>  <hint>:1:40: error: parse error on input ‘,’
15:50:41 <iqubic> there is no y on the right hand side to reduce.
15:50:48 <Anikaiful> :erisco what happened to the (\x ...) ?
15:50:59 <alexashka> erisco: sounds esoteric - the clever bit is we're getting a new type from 2 types?
15:51:03 <erisco> Anikaiful, which step are you referring to?
15:51:03 <iqubic> Anikaiful: That got reduced out.
15:51:13 <Anikaiful> oo...
15:51:18 <erisco> alexashka, we're just playing with terms actually
15:51:25 <iqubic> Anikaiful: <erisco>> (\x y -> x) a b  is  (\y -> a) b  by replacing all x's with a's
15:51:31 <iqubic> erisco: said that.
15:52:16 <Anikaiful> well, yea, but if I read that ~as-is~, the it becomes (\a y -> a) a b ...
15:52:32 <alexashka> erisco: s = a -> b, k = a, i = b? does that work?
15:52:43 <Anikaiful> ...oh, I think I'm missing something fundamental now...
15:52:48 <iqubic> So if we take (\x y -> x) a b and fully reduce I get a single 'a'
15:53:08 <iqubic> alexashka: How do you get i? That's what we're trying to solve for.
15:53:24 <alexashka> iqubic: function application of s and k?
15:53:41 <marvin2> > printf "%*s" 17 "hi" :: String
15:53:43 <lambdabot>  "               hi"
15:54:00 <iqubic> erisco: Am I right in my β reduction there?
15:54:00 <erisco> Anikaiful, we lose the abstraction too, yes, so  (\x -> m) a ≡ [x/a]m  provided the conditions about variables I gave
15:54:05 <Anikaiful> ah... so that's what the english word 'reduction' is... "slice out the garbage"
15:54:24 <alexashka> Anikaiful: it's substitution really
15:54:41 <erisco> yes, it is variable substitution
15:54:45 <monochrom> I don't think anyone is slicing out any garbage.
15:54:48 <erisco> if you're a programmer you're familiar with it :)
15:55:04 <Anikaiful> alexashka: see it now, just that I had to hop-skip thro dictionary for couple words.
15:55:25 <iqubic> so erisco, now that I have reduced k a b, what next?
15:55:28 <alexashka> Anikaiful: ya, it's just clever vocabulary for what every programmer already knows :)
15:55:40 <iqubic> k a b == a
15:55:42 <monochrom> In fact, when describing wars, "country X reduced country Y's city" means slicing out all the good stuff, letting only garbage remain.
15:55:47 <erisco> iqubic, well our original question was what is the 'a' and 'b' such that 'k a b ≡ i'
15:56:00 <iqubic> And I don't really know.
15:56:08 <erisco> iqubic, and now we determined 'k a b ≡ a', thus 'a ≡ i'
15:56:12 <erisco> iqubic, so what does this mean?
15:56:15 <Anikaiful> alexashka: pretty much basics, but I be damned if english didn't throw me on a loop every now and then xD
15:56:54 <iqubic> it mean that it doesn't matter what b we chose?
15:56:55 <alexashka> Anikaiful: hehe, it's a matter of bridging math and computer science, so they introduce new words in lambda calculus
15:57:02 * ski . o O ( non-garbage-collection )
15:57:04 <erisco> iqubic, this means our question became "what is the 'a' that is equivalent to 'i'?"
15:57:15 <erisco> iqubic, and yes, it doesn't matter what 'b' is chosen
15:57:35 <erisco> iqubic, so the problem with the state we're in now is that we're "back to square one" as mniip said
15:57:51 <iqubic> Right. And we just go in an endless loop
15:57:57 <iqubic> How do we resolve this?
15:58:03 <erisco> iqubic, but we did learn that if we find some 'a' such that 'a ≡ i' then 'k a b ≡ i' as well!
15:58:13 <erisco> iqubic, forall the b's
15:58:19 <Anikaiful> alexashka: I don't mind new words at all, if their definition makes some sort of "sense"...
15:58:21 <iqubic> right. That is treu
15:58:41 <iqubic> s/treu/true/
15:58:52 <erisco> iqubic, so we ruled out k, we ruled out k z, we ruled out k a b, there doesn't seem to be any point trying more stuff that begins with k
15:59:02 <erisco> iqubic, hence we look at s now
15:59:08 <iqubic> Okay.
15:59:23 <ski> Anikaiful : depending, it's sometimes better if new terms make no sense, in terms of previous knowledge ..
15:59:25 <iqubic> s ≠ i
15:59:35 <erisco> good start :)
15:59:40 <iqubic> so let's look at "s a"
15:59:41 <alexashka> erisco: how'd you guys jump from s, k and i to having a and b in there? I'm so lost :)
16:00:03 <Anikaiful> ski: to some extent, yea, but if they're TOTALLY out of any kind of comprehensible scope, then that's bad.
16:00:04 <ski> alexashka : `a' and `b' are meta-vars, here. template holes
16:00:13 <erisco> alexashka, the question we had is "is there any 'a' and 'b' such that 'k a b' is equivalent to 'i'?"
16:00:31 <iqubic> (\f g x -> f x (g x)) a
16:00:54 <ski> Anikaiful : a totally unfamiliar term is better than one that *appears* to make sense according to previous expectations, but which actually doesn't
16:00:56 <iqubic> that reduces to \g x -> a x (g x)
16:01:10 <iqubic> That's not i
16:01:17 <iqubic> time to try s a b
16:01:34 <alexashka> erisco: what is the relation of that question to your initial how do we get i from s and k?
16:01:44 <Anikaiful> ski: that holds true to some extent, something alien rouses interest.
16:01:47 <alexashka> erisco: just playing with all the possible options?
16:01:53 <iqubic> I don't even think we can find an a that makes \g x -> a x (g x) into i
16:02:05 <iqubic> Can we?
16:02:18 <erisco> alexashka, we proved that k does not work, k z does not work (for all z), k a b is unhelpful (for all a and b)
16:02:32 <ski> Anikaiful : of course, it can get a bit ridiculous here .. like talking about "pre-mice" (set theory)
16:02:52 <iqubic> erisco: can we find an 'a' that makes \g x -> a x (g x) into i?
16:03:16 <erisco> alexashka, so we've ruled out everything interesting that begins with 'k', which is a big step to finding the right answer
16:03:25 <erisco> alexashka, because now we know the right answer must begin with 's'
16:03:31 <Anikaiful> ski: I frankly don't get that pun as pre-mice is joy-stick.
16:03:42 <iqubic> And I started with s ≠ i.
16:03:47 * ski notes erisco and iqubic is well on their way enumerating all combinatory logic expressions
16:03:53 <erisco> lol
16:03:55 <iqubic> I'm not trying "s a"
16:04:00 <ski> Anikaiful : haha :)
16:04:03 <iqubic> s/not/now/
16:04:09 <iqubic> erisco: can we find an 'a' that makes \g x -> a x (g x) into i?
16:04:30 <iqubic> I want to know if there is some a that turns s a into i
16:04:32 <erisco> iqubic, look at the abstractions
16:04:38 <Anikaiful> ski: xD
16:04:42 <iqubic> What abstractions?
16:04:53 <alexashka> erisco: what is wrong with my initial solution of s being a - > b, k being a and i being b? s k -> i
16:04:56 <erisco> iqubic, "the lambdas"
16:05:01 <ski> Anikaiful : <https://en.wikipedia.org/wiki/Mouse_(Set_Theory)>
16:05:42 <Anikaiful> ski: ay, for the humorless.
16:05:44 <erisco> alexashka, s = \f g x -> f x (g x); k = \x y -> x
16:05:59 <iqubic> erisco: I don't think there is any a that will work.
16:06:18 <erisco> iqubic, so if we look,  \x -> x  has one abstraction and  \g x -> a x (g x)  has two
16:06:28 <iqubic> Right.
16:06:33 <erisco> so we have to get rid of one if it is to work
16:06:37 <iqubic> So let's try "s a b"
16:06:50 <iqubic> \x -> a x (b x)
16:07:00 <Anikaiful> ski: but biologically it's "premise is joy-stick"...
16:07:03 <iqubic> that has one abstraction.
16:07:26 <iqubic> Is there an 'a' and 'b' that will work for that?
16:07:31 <erisco> iqubic, indeed, looks promising, and you get to choose what 'a' and 'b' you want
16:07:45 * ski grins
16:07:50 <erisco> iqubic, so we can see there are two x's in  a x (b x)  and  i  just has one
16:08:01 <iqubic> let's start by trying a is k
16:08:01 <erisco> iqubic, is there a way to get rid of one of the x's ?
16:08:22 <iqubic> k gets rid of an x I believe.
16:08:27 <steven_is_false> How do I make a function reflect :: forall (a :: Nat) . Integer ?
16:08:34 <erisco> iqubic, k for what? a or b?
16:08:37 <Anikaiful> ski: not sure how to equate that with the wiki statement.
16:08:38 <iqubic> I'm going to try a is k
16:08:44 <erisco> iqubic, go for it
16:08:51 <Welkin> S (K K) (K K) is I
16:08:52 <Welkin> I think
16:09:20 <Welkin> I was playing with S and K in javascript a couple weeks ago
16:09:50 <Anikaiful> and there result was SI+CK=DA/MN?
16:09:58 <alexashka> erisco: I don't get the significance of that reply :P
16:10:07 <erisco> ski, I am glad we're not going to figure out if there is an 'a' that can eta-reduce an abstraction, lol
16:10:26 <iqubic> \x -> a x (b x) and a = \x y -> x reduces to ...
16:10:33 <iqubic> I'm not sure how to d that reduction.
16:10:40 <iqubic> s/d/do/
16:10:52 <erisco> alexashka, well I am telling you what s and k are defined as, so those are the definitions you must work with
16:11:03 <Anikaiful> you probably can't 'd' it
16:11:15 <iqubic> Anikaiful: I meant do.
16:11:31 <Anikaiful> iqubic: grin :D... I know.
16:11:34 <erisco> iqubic, okay, well, we can go through the rigor of renaming variables and doing substitution, or we can intuit it
16:11:42 <erisco> iqubic, what does k do? it is const, as you said, remember?
16:11:57 <erisco> so what is  \x -> k x (b x)
16:12:11 <c_wraith> :t (<*>) const const -- Welkin, are you sure?
16:12:13 <lambdabot> b -> b
16:13:04 <iqubic> erisco: \x -> k x (b x) is x forall (b x)
16:13:36 <erisco> iqubic, well close, don't forget the abstraction
16:14:15 <iqubic> so \x -> k x (b x) is \x -> x forall (b x)
16:14:42 <Anikaiful> hmmhmm, I'm likely totally off course, but wasn't that 'i' or something in the picture?
16:14:49 <iqubic> Right now we're trying "s a b" where a is k
16:14:58 <Welkin> s t a b
16:14:58 <Welkin> :D
16:15:11 <iqubic> And I nearly have it.
16:15:17 * ski gently stabs a lens
16:15:43 <Anikaiful> now *I* am confused xD
16:15:53 <erisco> iqubic, indeed, so back to the top, we're looking at 's a b' and we need to find the 'a' and 'b' such that 's a b' is equivalent to 'i'
16:15:56 <steven_is_false> What's that one extension that lets you write (foo :: MyExplicitType) in expressions?
16:16:10 <erisco> iqubic, you choose 'a = k' and so what do you choose 'b' to be?
16:16:29 <iqubic> Well it can be anything right?
16:16:38 <erisco> steven_is_false, you can just do that without an extension, but maybe you're thinking of ScopedTypeVariables
16:16:40 <iqubic> I said that it works forall (b x)
16:16:53 <erisco> iqubic, but we have to pick one
16:17:08 <iqubic> What should  we pick?
16:17:12 <Anikaiful> b_ill_gates == True is ok also
16:17:14 <erisco> I'll let you be creative
16:17:15 <marvin2> would I be abusing Num if I defined Num instance for Nutritional food facts, so that I can add them together to get a total calories, fat, etc?
16:17:38 <iqubic> We need something with a single abstraction.
16:18:07 <erisco> iqubic, why do you say that?
16:18:08 <Anikaiful> data Type = MicrosoftSucks derives(HellYes)
16:18:31 <iqubic> erisco: because we are applying b to a single value in (b x)
16:18:45 <ski> @type failover
16:18:45 <erisco> iqubic, so, maybe *at least* one abstraction
16:18:46 <lambdabot> Alternative m => LensLike ((,) Any) s t a b -> (a -> b) -> s -> m t
16:19:17 <iqubic> erisco: What would you pick for b?
16:19:17 <erisco> iqubic, in the untyped world this is unnecessary, but if we want a Haskell expression then yes, we need 'b' to be a function
16:19:18 <marvin2> since only + would be useful I'd obviously be abusing it.. but i am tempted by this syntax:  cheeseburger + fries + coke (and then show instance showing nutritional facts for all the food combined)
16:19:23 <steven_is_false> erisco: Oh I made a syntax error
16:19:27 <erisco> iqubic, well, what functions do you have?
16:19:33 <iqubic> s and k
16:19:35 <Anikaiful> LOL... "stab at b ... smthin'..."
16:19:44 <ski> marvin2 : what is multiplication ?
16:19:47 <erisco> iqubic, which one of those seems good?
16:19:48 <marvin2> (which, I guess, would be abusing Show instance as well. =) )
16:19:55 <iqubic> k is simpler.
16:20:01 <iqubic> Let's try that firsk
16:20:08 <iqubic> s/firsk/first
16:20:15 <marvin2> ski I could multiply all the fields, but I can't see when that would be useful
16:20:25 <alexashka> erisco: ok, so s reduces to s = (a->b->c) -> (a->b) -> a -> c
16:20:35 <ski> marvin2 : perhaps making a `Monoid' instance would be enough, then ?
16:20:45 <erisco> alexashka, you're answering "has type" rather than "reduces to"
16:20:50 <alexashka> erisco: are we looking to see where we can throw k in here to produce different i's?
16:20:50 <marvin2> ski, hmm, actually I guess it would be useful in here:  fries * 2
16:21:13 <Anikaiful> marvin2: for that combo, it'd equal with False - no nutriotion at all.
16:21:14 <ski> marvin2 : `2' having which type ?
16:21:34 <iqubic> erisco: what would you like me to try.
16:21:35 <marvin2> ski Nutrition, where all the fields are 2
16:22:03 <erisco> iqubic, you wanted to try k for b, so try it
16:22:47 <steven_is_false> Couldn't match type `forall (a :: Nat). a :=: 0' with `0 :=: 0' ? I thought forall would automatically collapse to that.
16:22:54 <alexashka> erisco: hm, can I have a simple example of a reduction you'd do?
16:22:57 <iqubic> So far I have s k b which is \x -> k x (b x)
16:23:21 <ski> marvin2 : "show instance showing nutritional facts for all the food combined" would be disrecommended, if you mean showing something else than valid Haskell syntax
16:23:26 <erisco> alexashka, there are just two. There is beta-reduction (i.e. function application i.e. substitution) and there is eta-reduction which is \x -> f x reduces to f
16:23:46 <iqubic> And that further reduces to \x -> x forall (b x)
16:23:55 <iqubic> let's try b is k
16:23:59 <Anikaiful> ski: and it'd zero out if there was McDonalds in any shape or form.
16:24:17 <marvin2> ski I know "which, I guess, would be abusing Show instance as well. =)"
16:24:26 <iqubic> \x -> k x (b x) and b is \x y -> x
16:24:37 <iqubic> I'm not sure how to work with that though.
16:24:37 * ski missed that, sorry
16:24:40 <marvin2> I guess I have to decide if I'm writing a useful library, or just something with cute syntax to be used in ghci
16:24:50 <alexashka> erisco: right, I'm saying we can apply s as any of k's arguments, or vice versa. is this supposed to narrow down to a single possible answer?
16:25:00 <iqubic> alexashka: yes.
16:25:03 <erisco> iqubic, b is k, so  \x -> k x (b x)  is  \x -> k x (k x)
16:25:20 <iqubic> hey, that looks good.
16:25:28 <Anikaiful> marvin2: do both. Or more like, whatever fancies YOUR eye.
16:25:33 <erisco> iqubic, knowing what we know about k, what does  k x (k x)  reduce to?
16:25:54 <iqubic> it reduce to x forall (k x)
16:26:22 <iqubic> Is that the answer?
16:26:22 <erisco> alexashka, there are countably infinite answers
16:26:43 <mniip> erisco, what about irreducible answers
16:26:53 <mniip> that's just one, right
16:26:55 <alexashka> erisco: right, so then what is the point of these reductions?
16:27:04 <Anikaiful> uuuh... countably infinite? That's math I smell -.-
16:27:07 <iqubic> i is (\x -> s k (k x))
16:27:11 <erisco> mniip, from some normalisation property, yeah, though I forget which one is which
16:27:31 <mniip> iqubic, that sounds wrong
16:27:45 <iqubic> so k x (k x) reduces down to x forall (k x)
16:27:51 <alexashka> my pragmatic mind does not compute :)
16:27:55 <erisco> iqubic, we're not allowed to use abstractions in our answer
16:28:00 <iqubic> how the hell does that help us?
16:28:04 <iqubic> so k x (k x) reduces down to x forall (k x)
16:28:07 <erisco> iqubic, otherwise you could just say i is \x -> x and it'd be a boring question ;)
16:28:15 <iqubic> Right. I see
16:28:32 <erisco> iqubic, \x -> k x (k x) ≡ \x -> x
16:28:46 <Anikaiful> alexashka: my mind forgo computing long ago, until they come up with something binary-expressible.
16:28:55 <iqubic> right. Which I got from s k k
16:29:17 <erisco> iqubic, well then why don't you answer  s k k  ? :P
16:29:18 <iqubic> I started with s a b and then said that I'd like a and b to both be k
16:29:41 <iqubic> erisco: I believe that i is s k k
16:29:46 <iqubic> is that correct?
16:29:57 <erisco> believe? what kind of institution is this? :P
16:30:06 <Anikaiful> I's... KK? That's so h4x.
16:30:24 <iqubic> I have just proven that i is s k k.
16:30:28 <erisco> iqubic, take  s k k  and reduce it to  \x -> x  and if you can do that then you win
16:30:46 <ggVGc> is eta reduction the same thing as going fast so you reduce the time until you arrive?
16:31:09 <mniip> hmm
16:31:16 <iqubic> Well, s is \f g x -> f x (g x)
16:31:16 <Anikaiful> hmm, depends
16:31:22 <iqubic> let's let g and x be k
16:31:26 <mniip> I wonder if iterating through all ski terms can be expressed short enough to fit in an irc message
16:31:56 <erisco> yes, actually, heh
16:32:00 <iqubic> then you get \f g -> f x (k x)
16:32:01 <Anikaiful> mniip: if given infinite IRC buffer, sure.
16:32:11 <iqubic> erisco: I can't win.
16:32:11 <ggVGc> if only IRC was lazy
16:32:24 <iqubic> I can't apply k to a single argument.
16:32:25 <mniip> Anikaiful, an IRC buffer is finite and has known size
16:32:32 <erisco> mniip, it is as short as a parser written with parser combinators
16:32:48 <iqubic> and you also get \f -> k x (k x)
16:32:49 <mniip> erisco, why would you need a parser to *express* i
16:32:50 <mniip> t
16:32:51 * ski doesn't know that many terms
16:32:56 <iqubic> letting g be k
16:32:59 <erisco> mniip, a parser can be viewed as a tree search, i.e. looking for the correct parse tree
16:33:03 <Anikaiful> mniip: that's lies. It dwells in the Underworld, tended by the Dwarfs.
16:33:12 <erisco> mniip, you can just remove the search part and keep the tree generation part
16:33:13 <iqubic> Now, k is \x y -> x
16:33:45 <mniip> hmm
16:33:51 <mniip> does lambdabot have Omega
16:34:23 <iqubic> erisco: I don't think I can reduce s k k further than to \f -> k x (k x)
16:34:39 <erisco> mniip, I can send you to my little undergrad paper if you want a reference implementation
16:34:45 <erisco> mniip, and then you can yocto it
16:34:51 <Anikaiful> excuse my logic fail here, but for straight \x -> x ... is there any other answer than "whatever"?
16:34:55 <mniip> erisco, meh
16:35:12 <mniip> erisco, I'm really looking for a compact way to express either extensional equality or types
16:35:28 <erisco> mniip, how are those related?
16:35:28 <iqubic> Can I reduce s k k further than to \f -> k x (k x)
16:35:41 <erisco> iqubic, where did you get f from?
16:35:43 <mniip> erisco, so that I can "filter" terms with type a->a from "all terms"
16:35:59 <mniip> erisco, that, or terms for which extensional equality 'f x == x' holds
16:36:38 <mniip> the latter sounds simpler
16:36:48 <Anikaiful> f x == x ... is a whole lot of cases...
16:37:39 <mniip> Anikaiful, obviusly it has to be established symbolically
16:37:43 <Anikaiful> (I totally ignored the extensional, etc)
16:37:59 <erisco> mniip, I am not sure exactly how to distinguish extensional and intentional equality and particularly with ==
16:38:05 <iqubic> erisco: s is \f g x -> f x (g x)
16:38:06 <erisco> intensional*
16:38:17 <iqubic> and I'm trying t reduce "s k k"
16:38:34 <erisco> iqubic, so, start with  (\f g x -> f x (g x)) k k
16:38:51 <c_wraith> erisco: haskell's Eq is extensional.  [2,4..10] == map (*2) [1..5]
16:38:57 <Anikaiful> mniip well, yea, but depending on 'f', x == x is true in 'y' number of cases, if 'f' == nothing, then infinite...
16:39:12 <erisco> c_wraith, and what would an intensional equality look like?
16:39:20 <c_wraith> erisco: it would compare definitions
16:39:23 <hpc> erisco: pointer equality or something like that
16:39:31 <iqubic> erisco: And then It reduces to (\g x -> f x (k x)) k
16:39:49 <erisco> the way I read them suggested that intensional equality said how to compare two objects by some properties thereof
16:39:52 <iqubic> erisco: and further to \x -> k x (k x)
16:40:00 <erisco> whereas extensional equality was a list of what is equal to what
16:40:08 <Anikaiful> mniip: I think I'm missing some logic here.
16:40:09 <erisco> though I presume you could define such a list inductively
16:40:48 <erisco> so I get why == may be called extensional but I am not sure how to contrast it to intensional in a meaningful way
16:40:55 <erisco> so I probably have them both wrong
16:41:22 <erisco> iqubic, good, and now what
16:41:33 <iqubic> Now I am stuck.
16:41:42 <c_wraith> iqubic: expand k
16:41:52 <erisco> what is  k a b  equivalent to? we did that earlier
16:42:04 <Anikaiful> kebab!
16:42:17 <iqubic> k a b = a forall b
16:42:46 <Anikaiful> \o/ yay. I was right, in a sense.
16:42:49 <erisco> forall a's and b's, and so can we use that fact here for  k x (k x)  ?
16:43:02 <erisco> that is to say, can we choose an 'a' and a 'b' such that it looks like something in  k x (k x)  ?
16:43:22 <iqubic> such that what does?
16:43:34 <erisco> such that  k a b  does
16:43:48 <erisco> we know for all a's and b's,  k a b  reduces to  a
16:44:04 <iqubic> sure, so what's the issue?
16:44:22 <erisco> so, if we picked some 'a' and some 'b' such that  k a b  looked like something in  k x (k x)  we could reduce it
16:44:46 <iqubic> Sure, but what are a and b?
16:45:01 <iqubic> b is clearly k x
16:45:13 <erisco> we're choosing them so  k a b   looks like   k x (k x)  or some subexpression of that
16:45:26 <iqubic> I don't know how to do that.
16:45:45 <erisco> why is  b  clearly  k x  ? it seems like you know exactly what to choose
16:46:06 <Anikaiful> someone needs to draw a diagram of this, I fell off track, then lost the track, and flew to different planet...
16:46:21 <iqubic> k a b is k x (k x) if a is x and b is (k x)
16:46:30 <iqubic> Bam What!!!
16:46:35 <erisco> correct, and therefore what does  k x (k x)  reduce to?
16:46:42 <erisco> since we know  k a b  reduces to  a
16:46:52 <iqubic> it reduces to x
16:46:57 <erisco> yes sir
16:47:03 <erisco> so what does  \x -> k x (k x)  reduce to
16:47:10 <iqubic> \x -> x
16:47:18 <erisco> yes, which is the definition of i
16:47:21 <erisco> and thus  s k k ≡ i
16:47:26 * ski = i
16:47:26 <iqubic> so s k k is i
16:47:28 <Anikaiful> and as I said, is "whatever" ...
16:47:29 <erisco> ■
16:47:29 <iqubic> done.
16:47:39 <boj>  /me claps
16:47:40 <iqubic> Q.E.D.
16:47:49 * boj claps
16:47:52 <Welkin> Quantum Electro Dynamics
16:47:59 <ski> Q. E. F.
16:48:20 <iqubic> @define k = (\x y -> x)
16:48:21 <hpc> i would fit that proof into a margin
16:48:22 <lambdabot>  Defined.
16:48:34 <erisco> and as was pointed out earlier,  s = (<*>)  and  k = pure = const  in Haskell
16:48:43 <ski> aka `ap' and `return'
16:48:46 <iqubic> @define s = (\f g x -> f x (g x))
16:48:48 <lambdabot>  Defined.
16:48:52 <erisco> yeah
16:48:53 <iqubic> :t s k k
16:48:55 <lambdabot> error:
16:48:55 <lambdabot>     Ambiguous occurrence ‘s’
16:48:55 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.s’,
16:49:01 <ski> @slap lambdabot
16:49:01 <lambdabot> stop telling me what to do
16:49:06 * ski smiles
16:49:07 <erisco> lol
16:49:08 <iqubic> @define si = (\f g x -> f x (g x))
16:49:09 <lambdabot>  Defined.
16:49:17 <iqubic> :t si k k
16:49:18 <lambdabot> error:
16:49:18 <lambdabot>     Ambiguous occurrence ‘k’
16:49:19 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.k’,
16:49:28 <iqubic> @define ki = (\x y -> x)
16:49:29 <lambdabot>  Defined.
16:49:36 <iqubic> :t si ki ki
16:49:37 <lambdabot> t1 -> t1
16:49:42 <iqubic> there we go.
16:49:42 <Anikaiful> not sure what I learned from that all, except that "lots of fancy math equals with nothing useful".
16:49:49 <iqubic> And my work is checked.
16:49:52 <erisco> > si ki ki "hello sailor!"
16:49:53 <lambdabot>  "hello sailor!"
16:49:56 <ski> Anikaiful : mental gymnastics
16:50:09 <iqubic> :t <*>
16:50:10 <lambdabot> error: parse error on input ‘<*>’
16:50:18 <iqubic> :t (<*>)
16:50:20 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
16:50:29 <Anikaiful> ski: yea, well, could use brain for better... but there's that.
16:50:33 <erisco> the next hour lesson is why functions are Applicatives
16:50:38 <iqubic> How is that f?
16:50:56 <iqubic> How is <*> the same as s?
16:50:57 <ski> iqubic : set `f = (rho ->)'
16:51:04 <Welkin> iqubic: ;P
16:51:10 <Welkin> :t (<*>)
16:51:12 <Anikaiful> rho?
16:51:12 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
16:51:21 <Anikaiful> :t (rho)
16:51:23 <lambdabot> error: Variable not in scope: rho
16:51:26 <Welkin> if `f` is `c ->`
16:51:27 <Anikaiful> hmm
16:51:31 <ski> just a random type variable name
16:51:34 <erisco> ski, how did you choose rho? is that customary?
16:51:41 <dmwit> > (f <*> g) x :: Expr
16:51:44 <lambdabot>  error:
16:51:44 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘f’
16:51:44 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
16:51:44 <ski> erisco : in some papers, yes
16:51:48 <Welkin> (c -> a -> b) -> (c -> a) -> (c -> b)
16:51:48 <ski> (Wadler, iirc)
16:51:51 <Welkin> you can work out the rest
16:51:52 <iqubic> Oh, I see hw that works now.
16:51:57 <Anikaiful> oh, I thought it was one of the fancy things like phi and pi
16:52:03 <erisco> ski, for vaguely like "p" in "parameter" perhaps?
16:52:16 <ski> Anikaiful : more like "why do we use `x' in equations ?"
16:52:23 <iqubic> :t (
16:52:25 <lambdabot> error:
16:52:25 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
16:52:34 <hpc> ski: that one actually has a neat answer
16:52:43 <Anikaiful> answer -- "Because(TM)"
16:52:47 <iqubic> :t \f g x -> f x (g x)
16:52:49 <lambdabot> (t2 -> t1 -> t) -> (t2 -> t1) -> t2 -> t
16:53:10 <iqubic> How can f be (c ->)
16:53:15 <iqubic> Why does that work?
16:53:21 <Anikaiful> if x wasn't used, it would be sexist.
16:53:26 <hpc> oh, i guess not that interesting
16:53:27 <hpc> https://english.stackexchange.com/questions/151515/why-is-the-letter-x-given-importance-in-mathematics#151517
16:53:37 <Welkin> because (->) is a constructor
16:53:40 <mniip> hmm
16:53:40 <erisco> iqubic, because it just does? :)
16:54:04 <mniip> now all that's left is to generate all expressions
16:54:11 <Welkin> `(->) c` can be a functor
16:54:19 <Welkin> it still neds an `a`
16:54:20 <iqubic> (->) is a constructor???
16:54:27 <Welkin> type constructor
16:54:31 <iqubic> Ah.
16:54:35 <erisco> mniip, that really is easy to do, just make a BNF grammar for SK expressions
16:54:44 <Anikaiful> I don't know about stackexchange and their up-their-own-noses-sniffing-snobs, but X's simply simple to scratch - two swipes, done.
16:54:45 <iqubic> Like Maybe or Either Int
16:54:48 <Welkin> `(->) c a` is `c -> a`
16:55:00 <Welkin> you can just call `(->) c` f
16:55:01 <monochrom> Anikaiful: Are you done making noise?
16:55:03 <mniip> erisco, need an omega monad
16:55:07 <mniip> which lambdabot doesn't have
16:55:15 <erisco> are you yoctoing it?
16:55:17 <Anikaiful> monochrom: nope
16:55:20 <mniip> erisco, no
16:55:22 <mniip> no parsers
16:55:24 <iqubic> So how does this relate to the reader applicative stuff?
16:55:28 --- mode: ChanServ set +o monochrom
16:55:31 <erisco> mniip, I mean "making it small"
16:55:34 <mniip> ah
16:55:55 <erisco> mniip, I figured we'd be allowed an implementation for generating languages before giving our short IRC answer
16:55:57 <mniip> erisco, not quite as quoctoey
16:56:01 <mniip> I have 1 data definition
16:56:17 <mniip> yoctoey, even
16:56:32 <mniip> hmm
16:56:35 <erisco> mniip, but if not then I think it still possible
16:57:02 <erisco> what was your concise version of product?
16:57:12 <mniip> product?
16:57:25 <erisco> we had this discussion last time about your parser
16:57:36 <erisco> there are two operations you need to define
16:57:41 <mniip> ah
16:57:42 <mniip> right
16:57:46 <mniip> I ended up not writing it
16:57:57 <erisco> I am bringing up parsers because generating a language is remarkably similar to a parser
16:58:00 <mniip> it was 1) not conscise 2) had bad constraints
16:58:16 <mniip> and those bad constraints can be traced back to Applicative StateT
16:58:17 <erisco> as I said, the parser just adds on a search algorithm to a tree generator
16:58:47 <erisco> or at least that is a possible conceptualisation
16:58:56 <mniip> hmm, does base have a Pair type
16:59:00 <erisco> and in implementation they can also be quite close
16:59:06 <mniip> Bool -> I guess
16:59:24 <erisco> our choice operator can be succinctly given by interleave
16:59:52 <mniip> :k Fix (Compose (Either (Either Bool Int)) ((->) Bool))
16:59:53 <lambdabot> error:
16:59:53 <lambdabot>     Not in scope: type constructor or class ‘Fix’
16:59:53 <lambdabot> error:
17:00:00 <erisco> I am not sure if there is anything in base/Haskell other than the explicit recursive definition, but it is short
17:01:09 * hackagebot ghc-heap-view 0.5.10 – Extract the heap representation of Haskell values and thunks – https://hackage.haskell.org/package/ghc-heap-view
17:01:09 * hackagebot bordacount 0.1.0.0 – Implementation of the Borda count election method. – https://hackage.haskell.org/package/bordacount
17:01:15 --- mode: monochrom set -o monochrom
17:01:16 <iqubic> So, I have all this theoretical knowledge in my brain. What should I do with it all?
17:01:40 <Welkin> iqubic: some day, it will help you understand something very important
17:01:45 <erisco> @define interleave (x:xs) (y:ys) = x : y : interleave xs ys; interleave xxs yys = xxs ++ yys
17:01:47 <lambdabot>  Defined.
17:01:51 <Welkin> and allow you to do something that you otherwise would not be able to do
17:01:53 <erisco> and you can golf that down obviously
17:02:06 <erisco> > interleave [1..10] (reverse [1..10])
17:02:09 <lambdabot>  [1,10,2,9,3,8,4,7,5,6,6,5,7,4,8,3,9,2,10,1]
17:02:13 <ignamv> what's the quickest way to find how a type instances a typeclass?
17:02:43 <iqubic> Welkin: What is the something important?
17:02:47 <erisco> iqubic, impress your friends at parties
17:03:01 <Welkin> iqubic: you have yet to discover it
17:03:02 <monochrom> ignamv: First use :info to find which file has the code. Then try to find that file.
17:03:09 <ignamv> thanks
17:03:15 <erisco> iqubic, but more seriously you should use it to learn even more
17:03:22 <ignamv> would be nice to have that in hoogle
17:03:43 <iqubic> erisco: What more can I learn?
17:04:00 <erisco> iqubic, keep studying lambda calculus, if you want
17:04:11 <Welkin> all kinds of random things I have learned over the years has become useful in learning some new library that I end up using for a specific purpose that I otherwise would have a lot of trouble understanding, or would have never considered
17:04:31 <Anikaiful> monochrom: chat, a moment?
17:04:36 <Welkin> or solving a problem in a certain way that no one would have considered around me
17:05:17 <erisco> actually I have a short algorithm for product too… give me a few minutes
17:06:27 <erisco> my code has  (flip f $ y)  in it, how embarrassing
17:06:52 <ignamv> erisco: (y `f`) ?
17:07:12 <iqubic> :t \f y -> flip f $ y
17:07:13 <lambdabot> (a -> b -> c) -> b -> a -> c
17:07:24 <erisco> ignamv, how about just (flip f y)
17:07:30 <iqubic> I dn't understnad that?
17:07:57 <ignamv> erisco: this way I don't worry about precedence :)
17:08:12 <erisco> precedence of what?
17:08:28 <iqubic> :t \f y -> flip f y
17:08:29 <ignamv> maybe that's not the right term, I'm always unsure how an expression will group
17:08:30 <lambdabot> (a -> b -> c) -> b -> a -> c
17:08:53 <monochrom> To avoid worrying about precedence, worry about the precedence of $. :)
17:09:16 <ignamv> I thought $ was like the god of operators (parentheses excluded)
17:09:27 <ignamv> like just, BLAM all the way to the right
17:09:33 * ski disapproves of `$'
17:09:39 <mniip> ok
17:09:42 <mniip> :t (>>/)
17:09:43 <lambdabot> [a] -> (a -> [b]) -> [b]
17:09:44 <mniip> this looks good
17:09:45 <monochrom> Yeah that's the kind of imprecise, intuitive thinking that will get you into trouble.
17:09:47 <c_wraith> ignamv: not at all.  :)
17:10:11 <ignamv> definitely gotta stop winging it and learn how operator precedence works
17:10:22 <c_wraith> > (+1 . (*2) $ 3 + 4 -- ignamv:  binary operators on both sides of $ 
17:10:25 <lambdabot>  <hint>:1:68: error:
17:10:26 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
17:10:29 <c_wraith> err, and a parse error
17:10:29 <erisco> > [1..] >>/ (\x -> [1..] >>/ \y -> [(x, y)])
17:10:31 <lambdabot>  [(1,1),(2,1),(1,2),(3,1),(2,2),(1,3),(4,1),(3,2),(2,3),(1,4),(5,1),(4,2),(3,...
17:10:37 <c_wraith> > (+1 ) . (*2) $ 3 + 4 -- ignamv:  binary operators on both sides of $ 
17:10:39 <lambdabot>  15
17:10:41 <ski> ignamv : higher precedence level means binds more tightly
17:10:42 <Anikaiful> hmm, aside saving couple ('s and )'s, what's the point of $?
17:10:51 <erisco> mniip, you hid the implementation, what is it
17:10:57 <c_wraith> Anikaiful: sometimes it can save you a lambda!
17:11:00 <mniip> infixl 1 >>/; (>>/) :: [a] -> (a -> [b]) -> [b]; (>>/) = go [] where go [] [] f = []; go rs [] f = (\(hs, ts) -> hs ++ go ts [] f) $ unzip $ mapMaybe uncons rs; go rs (x:xs) f = (\(hs, ts) -> hs ++ go (f x:ts) xs f) $ unzip $ mapMaybe uncons rs
17:11:02 <ski> Anikaiful : commonly, no point at all
17:11:20 <c_wraith> > map ($ 5) [negate, (*3), subtract 5] -- Anikaiful 
17:11:21 <lambdabot>  [-5,15,0]
17:11:29 <erisco> mniip, I think I can do better
17:11:36 <ski> what c_wraith just said is one of the few valid uses of `$'
17:11:45 <mniip> erisco, I don't doubt
17:11:58 <Welkin> I use $ all the time
17:12:10 <erisco> mniip, I already have my operators... I am just coming up with the grammar now lol
17:12:14 <ski> (where by "valid" i mean "valid, according to my taste")
17:12:16 <Welkin> away with the parentheses
17:12:45 <boj> ski: what do you prefer over f . g . h $ x? (f . g . h) x?
17:12:52 <ski> the latter, usually
17:13:01 <c_wraith> you prefer non-local paren matching?  eww
17:13:01 <Anikaiful> ok, that's one new thing to figure out,... ($ something), within ()...
17:13:08 <boj> hmm, so just a taste thing
17:13:32 <c_wraith> Anikaiful: It's a section, just like (+ 5)
17:14:08 <erisco> mniip, I have to get smarter than  C ::= "S" | "K"; T ::= C | C C | "(" T ")"
17:14:10 <hpc> ($ x) is the gateway drug to Cont
17:14:48 <ski> erisco : `T C' ?
17:14:50 <erisco> mniip, well actually maybe not, since I am just generating... lets try
17:15:02 <erisco> ski, thanks I mean T T
17:15:11 <ski> oh. ambiguous grammar ?
17:15:16 <Anikaiful> hmm... k...
17:15:18 <c_wraith> ski: where do your tastes fall on forM_ [1..n] $ \i -> do
17:15:48 <erisco> ski, I need more work to make it not ambiguous, and it doesn't actually matter as per the problem requirements
17:15:50 <ski> c_wraith : i'd prefer it if `$' wasn't required before `\',`do',`if',`let',`case', in such situations
17:16:01 <erisco> but I guess I'll try for nonambiguous
17:16:06 <c_wraith> ski: I'd also prefer if it wasn't required, but that's a different question. :)
17:16:27 <ski> c_wraith : i tolerate it there
17:16:36 <ski> (.. for now :)
17:17:47 <erisco> T0 ::= T1 T0 | T1;  T1 ::= "S" | "K" | "(" T0 ")"   yeah?
17:17:47 <iqubic> I haven't written a line of actual haskell in about a month
17:18:17 <mniip> okidoki
17:18:17 <mniip> > allSK
17:18:19 <lambdabot>  [S,K,S :$ S,(S :$ S) :$ S,K :$ S,(S :$ K) :$ S,S :$ K,(S :$ S) :$ K,K :$ K,(...
17:18:24 <marvin2> IIRC there was some talk that $ may not be required there in the future. is that still being considered?
17:18:44 <Anikaiful> ah well, guess that's 'nuff Haskell for me - monochrom and his tight pants don't agree that this'd be a good place for newbs to ask anything.
17:18:59 <mniip> > filter (\x -> reduceSK x == (Lit 0, 1)) allSK
17:19:01 <lambdabot>  error:
17:19:02 <lambdabot>      • Couldn't match expected type ‘SK a’
17:19:02 <lambdabot>                    with actual type ‘(SK Integer, Integer)’
17:19:08 <mniip> hmm
17:19:10 <mniip> wrong one
17:19:17 <mniip> > filter (\x -> saturateSK x == (Lit 0, 1)) allSK
17:19:19 <lambdabot>  [(S :$ K) :$ S,(S :$ K) :$ K,(S :$ K) :$ (S :$ S),(S :$ K) :$ ((S :$ S) :$ S...
17:19:23 <boj> Anikaiful: talking about haskell is fine. making random nonsense comments isn't
17:19:30 <iqubic> :t (<*>) const const
17:19:32 <lambdabot> b -> b
17:19:34 * ski is not quite sure what erisco is trying to achieve
17:19:48 <erisco> ski, mniip and I are generating all the SK terms
17:19:53 <Anikaiful> boj: ditto.
17:19:56 <erisco> ski, within an IRC message
17:20:16 <ski> ok
17:20:23 <mniip> @let allSK :: [SK a]; allSK = S : K : (((S :$) <$> allSK) </> ((K :$) <$> allSK) </> (allSK >>/ (\x -> ((S :$ x) :$) <$> allSK))) where xs </> ys = [False, True] >>/ bool xs ys
17:20:25 <mniip> er
17:20:25 <lambdabot>  .L.hs:198:1: error:
17:20:25 <lambdabot>      Duplicate type signatures for ‘allSK’
17:20:25 <lambdabot>      at .L.hs:190:1-5
17:20:28 <mniip> not meant to be an @
17:20:31 <Anikaiful> anyway, bye, good life, whatever.
17:20:36 <mniip> just wnated to show the definition
17:20:59 <ski>   (>>/) = (>>=)  -- ?
17:21:00 <mniip> it's slightly biased because </> does not associate, but iterates every term nevertheless
17:21:08 <mniip> ski, >>/ is Omega's >>=
17:21:11 <mniip> diagonal iteration
17:21:16 <ski> oh, breadth-first ?
17:21:22 <mniip> sort-of
17:21:24 <ski> ok
17:21:45 <ski> there was an `(>>-)' is scope, earlier
17:21:52 <ski> (`LogicT' or something)
17:22:37 <mniip> > [1..] >>/ (\x -> [1..] >>/ (\y -> map ((,,) x y) [1..]))
17:22:39 <lambdabot>  [(1,1,1),(2,1,1),(1,2,1),(3,1,1),(2,2,1),(1,1,2),(4,1,1),(3,2,1),(2,1,2),(1,...
17:22:53 <mniip> not exactly breadth first but close enough
17:23:05 <ski> fair, anyway
17:28:42 <erisco> fixing a strictness problem...
17:35:53 <erisco> do empty parens count? :P
17:36:14 <erisco> stupid grammars
17:39:15 <erisco> and now what about redundant parens, yeesh
17:43:39 <marvin2> is there a rounding function that rounds 1.5 and 2.5 to 2 and 3 respectively?
17:44:49 <marvin2> > (round 1.5, round 2.5)
17:44:51 <lambdabot>  (2,2)
17:45:03 <geekosaur> > (ceil 1.5, ceil 2.5)
17:45:05 <lambdabot>  error:
17:45:05 <lambdabot>      Variable not in scope: ceil :: Double -> t1error:
17:45:05 <lambdabot>      Variable not in scope: ceil :: Double -> t
17:45:08 <MarcelineVQ> the RealFrac class has a few options for dealing with various cases of rounding
17:45:11 <geekosaur> whoops
17:45:15 <boj> > ceiling 1.5
17:45:16 <MarcelineVQ> geekosaur: it's called ceiling for some reason
17:45:17 <lambdabot>  2
17:45:21 <geekosaur> yeh
17:45:27 <MarcelineVQ> by some reason I mean, for some reason it's not ceil
17:45:28 <marvin2> ceiling rounds everything to upper value
17:45:36 <marvin2> > ceiling 1.1
17:45:38 <lambdabot>  2
17:45:46 <boj> ah, closest value?
17:45:58 <boj> is what you want?
17:46:20 <marvin2> yes. with .5 always being rounded to greater value
17:46:38 <boj> > round 2.4
17:46:40 <lambdabot>  2
17:46:47 <mniip> > (ceiling (-2.5))
17:46:49 <lambdabot>  -2
17:47:11 <mekeor> Q:  if i don't create a new environment with an empty state each time, haxl doesn't seem to fetch the data again but it just returns me what it fetched before (– ie. what is has cached).  am i really supposed to create a new Env each time?
17:47:11 <mekeor> @hackage haxl
17:47:11 <lambdabot> http://hackage.haskell.org/package/haxl
17:47:19 <boj> > round 2.6
17:47:21 <lambdabot>  3
17:47:24 <boj> hmm
17:47:56 <marvin2> boj see above, (round 1.5, round 2.5) => (2,2). I understand why it is doing that, but that is not the behavior I want. I guess I have to define my own rounding function
17:48:40 <boj> marvin2: i was experimenting to check the behavior, but yeah, sounds like you need to define your own
17:51:32 <erisco> okay finally, geez
17:52:17 <erisco> what is the IRC message length limit?
17:52:41 <Welkin> erisco: check the spec
17:52:46 <Welkin> it's not very long
17:53:56 <MarcelineVQ> iirc it depends on what else has to go with the PRIVMSG, like channel name length and hostname and blah blah blah blah
17:54:04 <iqubic> > (round 1.5, round 2.5)
17:54:06 <lambdabot>  (2,2)
17:54:19 <iqubic> Why the heck does that work?
17:55:05 <erisco> > let c(x:xs)yys=x:case yys of {(y:ys)->y:c xs ys;[]->xs;};c[]yys=yys;t xss=foldr c [].fmap(\y->fmap(flip(++)y)xss);t0=["S","K"]`c`t1;t1=(["S","K"]`t`t0)`c`(["("]`t`t1`t`[")"]`t`t0)in t0
17:55:07 <lambdabot>  ["S","SS","K","(SS)S","SSS","(SS)SS","KS","((SS)S)S","SK","(SS)K","KSS","(SS...
17:55:45 <erisco> can keep golfing but I think that fits just fine
17:56:21 <erisco> so the grammar I came up with is  T1 ::= T2 | "S" | "K"; T2 ::= "S" T1 | "K" T1 | "(" T2 ")" T1
17:57:02 <mniip> erisco, dear god
17:57:47 <mniip> erisco, wait, what's (SS)S and SSS
17:57:56 <lyxia> iqubic: https://en.wikipedia.org/wiki/Rounding#Round_half_to_even
17:57:58 <marvin2> iqubic half up half down, idea being that rounding errors cancel eachother out. most languages seem to do that, and IEEE standard may even require it
17:58:01 <mniip> is SSS S(SS)
17:58:04 <boj> > round 1.5
17:58:06 <lambdabot>  2
17:58:13 <boj> weird
17:58:26 <erisco> mniip, the grammar may still have redundant parens in it, I dunno, I am getting too tired to massage it
17:58:37 <iqubic> >round 2.5
17:58:44 <MarcelineVQ> erisco: fwiw I think you can get about 444 characters given your hostname sending to #haskell
17:58:44 <erisco> if you can figure out a better grammar it is easy to stick in
17:58:51 <iqubic> > round 2.5
17:58:53 <lambdabot>  2
17:59:05 <iqubic> @src round
17:59:05 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:59:11 <marvin2> but I think roundTheWayWeWereTaughtInMath should be provided as well
17:59:16 <erisco> well this solution is 184 characters
18:00:16 <erisco> mniip, this comes naturally out of the work I did with parsers, since my parsing was dependent on generating trees which was dependent on generating sentences
18:00:23 <mniip> % :info round
18:00:23 <yahb> mniip: class (Real a, Fractional a) => RealFrac a where; ...; round :: Integral b => a -> b; ...; -- Defined in `GHC.Real'
18:00:31 <erisco> well, "dependent" may be the wrong word, but there is an obvious progression through them
18:00:51 <mniip> erisco, can you link me to the paper
18:01:06 <erisco> so, thanks to short definitions for a suitable choice and then operators, all that you need is the grammar
18:01:16 <erisco> which is also short for just this SK stuff
18:02:16 * hackagebot uri-templater 0.3.0.0 – Parsing & Quasiquoting for RFC 6570 URI Templates – https://hackage.haskell.org/package/uri-templater
18:03:41 <erisco> mniip, https://github.com/erisco/acrid-parser/blob/master/doc/paper.pdf
18:04:33 <erisco> mniip, that undergrad paper was the product of learning Haskell for the first time… amazing to me that it is just 4 years ago… feels like a lot longer
18:05:38 <erisco> mniip, with your generality of yocto you might find a way to have sentence and tree generators just by choice of types
18:07:50 <erisco> @let inf ~(x:xs) = x : inf x
18:07:52 <lambdabot>  .L.hs:199:1: error:
18:07:52 <lambdabot>      • Occurs check: cannot construct the infinite type: t ~ [t]
18:07:52 <lambdabot>        Expected type: t -> [t]
18:08:21 <erisco> huh
18:08:49 <erisco> someone did something
18:09:20 <erisco> that was one of my favourite toys
18:09:29 <mniip> erisco, that looks like a simple paper
18:09:55 <erisco> mniip, yeah, well, it is just my undergrad work
18:10:07 <mniip> well, I'm an undergrad atm
18:10:20 <erisco> today I could at least use fancier words :P
18:10:26 <erisco> maybe some more symbols
18:10:46 <mniip> I wonder if yoctoparsec is worth writing a paper about
18:11:26 <erisco> mniip, the purpose of an undergrad paper (at my uni) is not for publication but to merely practice independent research
18:11:32 <mniip> right
18:11:36 <mniip> that's the practice
18:12:17 <mniip> thinking about it, I think I can extend yoctoparsec to emit trees as well
18:12:19 <erisco> honestly the paper I was referred to wasn't that great either, so the bar was fairly low ;)
18:12:34 <mniip> consider e.g
18:12:40 <erisco> if you can whiz through this stuff as an undergrad then that's great
18:12:50 <mniip> Free (Writer [t])
18:13:00 <mniip> with
18:13:14 <mniip> token = some simple thing
18:13:16 <erisco> I didn't have a reason to get into Haskell until 2013 and before then there was really no role model or example to follow
18:13:28 <mniip> I forget the constructor names now but it's pretty simple
18:13:44 <mniip> ah, right, you can't have token :: Parser b t t
18:13:48 <erisco> I was the only programmer where I grew up and went to school, before uni, lol
18:13:52 <mniip> but rather token :: t -> Parser b t t
18:14:34 <mniip> basically you replace a multifunction with its cartesian product representation
18:14:51 <mniip> hmm, not strictly Free (Writer [t]) then
18:15:40 <mniip> s/Free/FreeT/
18:15:43 <mniip> otherwise seems correct
18:16:02 <mniip> @let import Control.Monad.Trans.Free
18:16:03 <lambdabot>  Defined.
18:16:18 <erisco> I have tried to recreate the excitement of the summer I worked on that paper but haven't found it
18:17:03 <mniip> :t \x -> FreeT $ pure $ Free ([x], FreeT $ pure $ Pure x)
18:17:05 <lambdabot> Applicative m => a -> FreeT ((,) [a]) m a
18:17:21 <erisco> I guess I have developed too much of a comparing mind… hard to get excited about work when you either know it is redundant or you're not sure
18:18:02 <erisco> there's so much to read and understand on every topic it seems an effort to contribute a drop to the ocean
18:18:46 <erisco> I was so excited to make that presentation that I was unusually worried about being hit by a car beforehand
18:19:14 <erisco> it felt that important to culminate my work
18:19:30 <mniip> :t iterTM (\(xs, r) -> tell xs >> return r)
18:19:31 <lambdabot> error:
18:19:31 <lambdabot>     • Occurs check: cannot construct the infinite type: a ~ t m a
18:19:31 <lambdabot>       Expected type: t m a
18:19:38 <mniip> :t iterTM (\(xs, r) -> tell xs >> r)
18:19:39 <lambdabot> (MonadWriter w (t m), Monad m, MonadTrans t) => FreeT ((,) w) m b -> t m b
18:19:56 <mniip> :t runWriterT . iterTM (\(xs, r) -> tell xs >> r)
18:19:58 <lambdabot> (Monoid w, Monad m) => FreeT ((,) w) m a -> m (a, w)
18:20:09 <mniip> @let tok = \x -> FreeT $ pure $ Free ([x], FreeT $ pure $ Pure x)
18:20:11 <lambdabot>  Defined.
18:20:23 <mniip> @let enumerate = runWriterT . iterTM (\(xs, r) -> tell xs >> r)
18:20:26 <lambdabot>  Defined.
18:20:49 <mniip> > enumerate $ (traverse tok "hello" <|> traverse tok "world")
18:20:51 <lambdabot>  error:
18:20:51 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M721292366774...
18:20:51 <lambdabot>        prevents the constraint ‘(Show
18:21:13 <mniip> > enumerate $ (traverse tok "hello" <|> traverse tok "world" :: FreeT ((,) String) [] String)
18:21:15 <lambdabot>  [("hello","hello"),("world","world")]
18:21:29 <erisco> mniip, it is worth writing a paper on it if you can give significance to the generalisations
18:22:11 <mniip> hold on
18:22:21 <erisco> if you can show the interest of various instances, and also use the generalisations to connect parsing to seemingly unrelated tasks, that'd be worth reading
18:22:58 <erisco> "oh I never looked at parsing this way" or "oh I never realised X was like parsing" could be realisations for your reader
18:24:18 <mniip> @let class Mode f where tkn :: (Alternative b, Eq t) => f t (b t)
18:24:19 <lambdabot>  Defined.
18:24:35 <mniip> ugh
18:24:48 <mniip> ((->) t) and ((,) [t]) are so close
18:24:50 <mniip> but not exactly
18:25:04 <mniip> hmm, does it need to be a monad
18:25:09 <mniip> no!
18:25:25 <mniip> @undefine
18:25:25 <lambdabot> Undefined.
18:25:31 <mniip> @let class Mode f where tkn :: (Alternative b, Eq t) => t -> f t (b t)
18:25:32 <lambdabot>  Defined.
18:26:04 <mniip> @let instance Mode (->) where tkn x = \y -> if x == y then pure y else empty
18:26:05 <lambdabot>  .L.hs:162:10: error:
18:26:05 <lambdabot>      Ambiguous occurrence ‘Mode’
18:26:05 <lambdabot>      It could refer to either ‘Text.PrettyPrint.HughesPJ.Mode’,
18:26:08 <mniip> dammit
18:26:15 <mniip> ok, I'll switch to a text editor locally
18:31:00 <mniip> hmm
18:31:05 <mniip> Functor1 is a thing, right?
18:35:53 <erisco> mniip, like  fmap1 :: (a -> b) -> f a z -> f b z  ?
18:36:03 <mniip> the other way around
18:36:07 <mniip> f z a -> f z b
18:36:24 <erisco> can you constrain  Functor (f a)  ?
18:36:32 <mniip> I want to have YMode f imply forall a. Functor (f a)
18:36:44 <erisco> ah, well that is not a GHC feature yet, but there is a paper on it
18:36:51 <erisco> I wanted that too recently
18:37:19 <mniip> funny
18:37:27 <mniip> never realized before today
18:37:32 <mniip> if you have a char combinator
18:37:39 <mniip> then word becomes traverse char
18:43:08 <erisco> mniip, what is a char combinator?
18:43:26 <mniip> you know, a parser combinator for a temrinal
18:43:49 <erisco> oh, I don't consider those combinators, but I know what you mean now
18:44:16 <mniip> ok
18:44:17 <mniip> here goes
18:45:08 <erisco> my idea of combinator looks like  f ... -> f... -> f ...
18:45:15 <mniip> @letlpaste http://lpaste.net/358149
18:45:15 <lambdabot>  Invalid paste ID.
18:45:20 <mniip> @letlpaste 358149
18:45:21 <lambdabot>  .L.hs:166:9: error:
18:45:21 <lambdabot>      Multiple declarations of ‘tkn’
18:45:21 <lambdabot>      Declared at: .L.hs:163:9
18:45:30 <erisco> like addition, the word8 combinator :P
18:45:39 <mniip> @letlpaste 358149
18:45:41 <lambdabot>  .L.hs:180:51: error:
18:45:41 <lambdabot>      Ambiguous occurrence ‘tell’
18:45:41 <lambdabot>      It could refer to either ‘Control.Monad.Writer.tell’,
18:45:53 <mniip> is there another tell?
18:47:04 <mniip> @letlpaste 358149
18:47:06 <lambdabot>  Defined.
18:47:07 <mniip> better
18:47:52 <mniip> this still suffers from the issue of a left-biased <|> or <*>
18:48:07 <mniip> but!
18:48:10 <mniip> not if b is Omega!
18:48:35 <erisco> biased in what way?
18:49:26 <mniip> > enumerate $ asum $ map token [1..]
18:49:28 <lambdabot>  error:
18:49:28 <lambdabot>      • Ambiguous type variables ‘b0’, ‘a0’ arising from a use of ‘show_M59743...
18:49:29 <lambdabot>        prevents the constraint ‘(Show (b0 (a0, [a0])))’ from being solved.
18:49:55 <mniip> > enumerate $ (asum $ map token [1..] :: Yocto (,) Int [] Int)
18:49:57 <lambdabot>  error:
18:49:57 <lambdabot>      • Expected kind ‘* -> *’, but ‘Int’ has kind ‘*’
18:49:57 <lambdabot>      • In the second argument of ‘Yocto’, namely ‘Int’
18:50:02 <mniip> oops
18:50:07 <mniip> > enumerate $ (asum $ map token [1..] :: Yocto (,) [] Int Int)
18:50:09 <lambdabot>  [(1,[1]),(2,[2]),(3,[3]),(4,[4]),(5,[5]),(6,[6]),(7,[7]),(8,[8]),(9,[9]),(10...
18:50:21 <mniip> > enumerate $ ((asum $ map token [1..]) <|> pure 0 :: Yocto (,) [] Int Int)
18:50:24 <lambdabot>  [(1,[1]),(2,[2]),(3,[3]),(4,[4]),(5,[5]),(6,[6]),(7,[7]),(8,[8]),(9,[9]),(10...
18:50:28 <mniip> you're never seeing that 0
18:51:02 <mniip> sadly, lamdabot doesn't feature an Omega
18:52:13 <mniip> that's easy to fix
18:52:27 <mniip> > enumerate $ ((asum $ map token [1..]) <|> pure 0 :: Yocto (,) Omega Int Int)
18:52:30 <lambdabot>  error:
18:52:30 <lambdabot>      • No instance for (Show (Omega (Int, [Int])))
18:52:30 <lambdabot>          arising from a use of ‘show_M807686245541239701713783’
18:52:41 <mniip> > runOmega $ enumerate $ ((asum $ map token [1..]) <|> pure 0 :: Yocto (,) Omega Int Int)
18:52:43 <lambdabot>  [(1,[1]),(2,[2]),(0,[]),(3,[3]),(4,[4]),(5,[5]),(6,[6]),(7,[7]),(8,[8]),(9,[...
18:52:51 <mniip> do I need the annotation still
18:52:58 <mniip> no
18:53:38 <mniip> > runOmega $ enumerate $ (replicateM 3 (asum $ map token [1..]))
18:53:40 <lambdabot>  [([1,1,1],[1,1,1]),([1,1,2],[1,1,2]),([2,1,1],[2,1,1]),([1,2,1],[1,2,1]),([2...
18:53:45 <mniip> yay
18:56:47 <mniip> @let digit = asum $ map (\x -> x <$ token (intToDigit x)) [0..9]
18:56:49 <lambdabot>  Defined.
18:57:26 <mniip> @let int = (foldl (\x y -> x * 10 + y) 0) <$> many digit
18:57:28 <lambdabot>  Defined.
18:57:33 <mniip> > runOmega $ enumerate int
18:57:35 <lambdabot>  error:
18:57:35 <lambdabot>      Ambiguous occurrence ‘int’
18:57:35 <lambdabot>      It could refer to either ‘Text.PrettyPrint.HughesPJ.int’,
18:57:38 <mniip> > runOmega $ enumerate L.int
18:57:45 <lambdabot>  mueval-core: Time limit exceeded
18:57:47 <mniip> shame
18:57:51 <mniip> I think many is broken here
18:58:56 <erisco> the strictness can be subtle
18:59:14 <erisco> not all functions are given in their least strict form
19:01:16 <mniip> ah
19:01:19 <mniip> it's left-recursive
19:01:20 <mniip>  duh
19:02:20 * hackagebot hw-json 0.6.0.0 – Memory efficient JSON parser – https://hackage.haskell.org/package/hw-json
19:03:46 <mniip> there
19:03:48 <mniip> > runOmega $ enumerate int'''
19:03:50 <lambdabot>  [([0],"0"),([1],"1"),([0,0],"00"),([0,1],"01"),([2],"2"),([0,0,0],"000"),([1...
19:03:59 <mniip> > runOmega $ parse int''' "123"
19:04:01 <lambdabot>  [([1],"23"),([1,2],"3"),([1,2,3],"")]
19:04:05 <mniip> oops, I meant
19:04:09 <mniip> > runOmega $ enumerate int''
19:04:11 <lambdabot>  [(0,"0"),(1,"1"),(0,"00"),(1,"01"),(2,"2"),(0,"000"),(10,"10"),(1,"001"),(11...
19:04:16 <mniip> > runOmega $ parse int'' "123"
19:04:18 <lambdabot>  [(1,"23"),(12,"3"),(123,"")]
19:04:29 <mniip> :t int''
19:04:31 <lambdabot> (Functor (f Char), YMode f, MonadPlus b) => FreeT (f Char) b Int
19:04:56 <mniip> how's that huh
19:06:05 <mniip> funny that f ~ Writer yields an enumerator
19:06:11 <mniip> and f ~ Reader yields a parser
19:06:25 <mniip> coincidence
19:06:26 <mniip> ?
19:09:49 <MichaelBurge> unsafeCoerce :: FunPtr -> Word64 seems to work as expected. Is it safe to rely on that?
19:11:14 <mniip> MichaelBurge, I'd use castFunPtr and minusPtr
19:11:51 <mniip> :t \x -> Foreign.Ptr.minusPtr (Foreign.Ptr.castFunPtrToPtr x) Foreign.Ptr.nullPtr
19:11:53 <lambdabot> GHC.Ptr.FunPtr a -> Int
19:12:11 <mniip> though Int can mean different things...
19:12:36 <mniip> :t \x -> Foreign.Ptr.ptrToIntPtr (Foreign.Ptr.castFunPtrToPtr x)
19:12:37 <lambdabot> GHC.Ptr.FunPtr a -> Foreign.Ptr.IntPtr
19:14:43 <MichaelBurge> mniip: Seems as good a choice as any. Thanks!
19:14:46 <mniip> since when is liftA2 part of Applicative
19:14:47 <mniip> :o
19:15:38 <iqubic> erisco: Is it possible to use fix to encode (\x -> x x)
19:16:00 <iqubic> I mean encode in the lambda calculus sense.
19:16:22 <trigone> what is the haskell mailing list which is not for beginners question? haskell or haskell-cafe?
19:17:37 <trigone> mniip: what do you mean liftA2 part of applicative? as class member?
19:17:50 <mniip> iqubic, join id
19:17:54 <mniip> no fix needed
19:18:01 <mniip> trigone, yes
19:18:09 <mniip> it used to be a function defined in terms of <*>
19:18:25 <mniip> now it's in-class. Haven't seen the source but I expect they're defined in terms of each other now
19:18:37 <iqubic> mniip: How the heck does that work?
19:18:42 <iqubic> :t join
19:18:44 <lambdabot> Monad m => m (m a) -> m a
19:18:54 <mniip> join :: (a -> a -> b) -> a -> b
19:19:07 <iqubic> Where's the monad in id? ((->) x)?
19:19:11 <mniip> yes
19:19:28 <erisco> iqubic, define it in terms of s, k, and our new function i
19:19:33 <mniip> > join id :: (forall a. a -> a) -> b -> b
19:19:35 <lambdabot>  error:
19:19:35 <lambdabot>      • Cannot instantiate unification variable ‘m0’
19:19:35 <lambdabot>        with a type involving foralls: (->) (forall a. a -> a)
19:19:37 <iqubic> define what?
19:19:38 <mniip> dammit
19:19:43 <erisco> iqubic, \x -> x x
19:19:44 <trigone> mniip: it's a bit sad the semantics of classes are lost just because it's the only way to permit specialization of polymorphic functions for perf reasons (at least i assume it's the reason).
19:20:03 <iqubic> define \x -> x x with s k and i?
19:20:08 <mniip> trigone, are they?
19:20:12 <erisco> iqubic, yes
19:20:15 <mniip> liftA2 is as good as <*>
19:20:18 <trigone> mniip: what do you mean are they?
19:20:20 <mniip> and there was another one, **
19:20:26 <mniip> are the semantics lost?
19:20:30 <iqubic> I'm going to try that on my own, and just pop in when I need help.
19:20:40 <iqubic> I learned a lot from earlier.
19:21:02 <trigone> mniip: i mean the mathematical semantics. it's not a minimal definition, there's no purpose in putting it in there, it's redundant
19:21:05 <mniip> x x = I x (I x)
19:21:23 <erisco> mniip, it is a learning exercise
19:21:23 <mniip> not really
19:21:30 <iqubic> For me it is
19:21:32 <mniip> trigone, in many cases I'd rather implement liftA2
19:21:40 <mniip> sorry, I was replying to trigone
19:21:52 <iqubic> I spent so long trying to turn s and k into i
19:22:00 <iqubic> And then I got that.
19:22:48 <centril> iqubic: https://ro-che.info/ccc/8
19:22:51 <mniip> erisco, I was trying to give a hint, is too bold
19:23:35 <trigone> mniip: hm maybe... i guess it doesn't really matter
19:23:46 <centril> https://en.wikipedia.org/wiki/Iota_and_Jot
19:24:07 <centril> who needs SKI when you only need Iota
19:24:16 <trigone> regarding the mailing lists? haskell or haskell-cafe?
19:25:26 <mniip> centril, good luck typechecking iota in stlc
19:25:51 <mniip> the thing with SK is that they encode every stlc term as well
19:26:01 <iqubic> erisco: What's the formal definition of i? is it \x -> x?
19:26:01 <mniip> having only a rank-1 type themselves
19:26:29 <erisco> iqubic, feel free to use that
19:26:49 <iqubic> is that not what you want me to use?
19:27:26 <erisco> iqubic, we might also define it as  i = s k k
19:27:46 <iqubic> Currently I'm working with s = \f g x -> f x (g x); k = \x y -> x ; i = s k k or i = \x -> x
19:27:54 <erisco> but it doesn't much matter, it is fine to use \x -> x for i, whether we say it is a definitional equality or equivalence
19:28:27 <iqubic> Which is better for i, \x -> x or s k k?
19:28:33 <mniip> I
19:28:40 <erisco> we'd say  i = s k k  particularly if we were restricting ourselves to combinators
19:28:51 <iqubic> is i not a combinator?
19:29:39 <erisco> mniip, the idea is we can use Haskell code, though admittedly we're going to have problems typing the sk version of μ
19:30:56 <erisco> iqubic, the idea is we choose some base set of combinators and then all else is defined using them
19:31:13 <iqubic> Ah, I see.
19:31:25 <iqubic> Is there a name for \x -> x x?
19:31:29 <mniip> omega
19:31:38 <iqubic> that's omega?
19:31:47 <erisco> ω I should have said then, not μ
19:31:53 <erisco> I thought it was μ
19:32:39 <iqubic> Is it omega or wau, or what
19:32:46 <erisco> maybe the sources are inconsistent
19:34:06 <erisco> I dunno, I'd have to drag out my LC book to see what symbols they've chosen
19:34:22 <erisco> doesn't much matter unless you're trying to carry on a conversation :)
19:34:26 <iqubic> I don't have a LC bk.
19:34:33 <iqubic> s/bk/book
19:35:33 <iqubic> trying to get \x -> x x is a bit hard.
19:35:46 <iqubic> So, does I take any inputs?
19:36:26 <iqubic> Yes, it must, because we only gave s two of the three inputs it needed.
19:37:59 <erisco> pretty sure I saw it called H somewhere
19:38:16 <erisco> I did a skim through my LC book but didn't see it in the combinators section
19:38:38 <erisco> you can just call it "self-application"
19:38:46 <iqubic> I will.
19:39:03 <iqubic> Well, I've made a good start already.
19:39:36 <erisco> the nice thing about combinators, btw, is there are no variables
19:39:45 <erisco> they're wretched things
19:40:18 <iqubic> no varibles? why do you say that?
19:41:03 <erisco> because there just aren't… when we're working with combinators all we have are the combinators
19:41:12 <erisco> so, if we choose s and k, all we have are s and k
19:41:12 <centril> how's dependent haskell going? any news?
19:41:36 <erisco> we get those plus function application (and parentheses as necessary to denote our AST)
19:42:22 <iqubic> I have made a start erisco.
19:42:24 <iqubic> http://lpaste.net/358151
19:42:50 <iqubic> I ruled out that k is not the function we apply to get \x -> x x
19:43:03 <erisco> good, well done
19:43:18 <iqubic> Do you see the logic I used there.
19:43:23 <iqubic> I think that's all correct.
19:43:24 <erisco> yes
19:44:03 <iqubic> I wish we had flip
19:44:14 <iqubic> is flip possible to write with ski?
19:44:14 <mniip> you can define flip with s and k
19:44:20 <iqubic> You can?
19:44:24 <mniip> yes
19:44:26 <erisco> well, line 21 is not right
19:44:27 <iqubic> It's possible?
19:44:32 <mniip> it's longer than omega I fear
19:44:49 <iqubic> How is it wrong?
19:44:54 <erisco> we are trying to see if there exists an 'a' which is equivalent to \x -> x x
19:45:04 <iqubic> And is there?
19:45:19 <erisco> but our 'a' can only range over s k i terms
19:45:41 <iqubic> Right, but that would take me back to the start.
19:46:01 <erisco> so the conclusion is that we've ended up with a question more general than we started with, so it didn't help much
19:46:17 <iqubic> Yeah.
19:46:27 <erisco> but we do know that if we find an 'a' equivalent to \x -> x x that k a b will also be equivalent to \x -> x x for all b's
19:47:03 <iqubic> Which is what we knew in the first place.
19:47:07 <iqubic> Unhelpful.
19:47:32 <iqubic> At first I was trying to find an a that was \x -> x x. And now I still am.
19:47:46 <erisco> that's right
19:49:24 <erisco> so what we do is apply the coinductive hypothesis and conclude  k (k (k ...) b2) b1  is equivalent to  \x -> x x
19:59:04 <erisco> that was a joke, by the way
20:00:26 <iqubic> here's a simple function \x y -> y
20:00:44 <iqubic> k k = \x y -> y
20:01:05 <iqubic> Is that correct?
20:01:10 <iqubic> :t const const
20:01:12 <lambdabot> b1 -> a -> b -> a
20:01:16 <iqubic> No.
20:01:20 <iqubic> No it is not
20:01:51 <erisco> (\x y -> x) (\a b -> a)   do the reduction
20:02:07 <iqubic> I'm not sure how.
20:02:27 <erisco> substitute (\a b -> a) for x in \y -> x
20:04:04 <iqubic> \y -> (\a b -> a)
20:04:16 <erisco> there you go
20:04:41 <iqubic> Now, how does Omega work?
20:04:59 <erisco> now if you haven't seen it yet,  \x y -> m ≡ \x -> \y -> m ≡ \x -> (\y -> m)
20:05:10 <iqubic> http://dkeenan.com/Lambda/
20:05:41 <iqubic> how does that help me reduce \y -> \a b -> a?
20:06:07 <erisco> it doesn't, it just gives you another way to write it
20:06:21 <iqubic> Ah
20:06:37 <iqubic> So what is omega?
20:06:44 <erisco> \x -> x x
20:06:54 <erisco> according to mniip
20:07:20 <iqubic> Yes, but how do I write it with s k i combinators?
20:07:22 <erisco> his other Omega is a list but with a different Monad instance
20:07:52 <erisco> you showed that it can't start with k
20:07:59 <erisco> so, try i
20:08:03 <iqubic> how do I write \x -> x x with s k and i
20:08:07 <iqubic> Why i?
20:08:12 <erisco> I dunno, try s then
20:08:33 <erisco> if we go through our combinators there is one which looks most similar to \x -> x x
20:08:35 <iqubic> do you know the correct answer?
20:08:39 <erisco> yes
20:08:44 <iqubic> Yes.
20:08:55 <iqubic> i looks a lot like \x -> x x
20:08:57 <erisco> it particularly has the feature of two x's on the right
20:09:04 <erisco> if we say \LHS -> RHS
20:09:09 <iqubic> Oh, so I should try s?
20:09:22 <erisco> seems like a good idea to me
20:09:35 <iqubic> s is \f g x -> f x (g x)
20:10:19 <iqubic> I'll try this on my own for now.
20:15:14 <iqubic> http://lpaste.net/358152
20:15:17 <iqubic> So close now.
20:15:23 <iqubic> I can almost taste it.
20:15:45 <erisco> yup, good work
20:16:04 <iqubic> I just need to find an a such that \x -> a x x is \x -> x x 
20:16:14 <iqubic> What a will work?
20:16:45 <erisco> you're in the right place, but going back to the 's a' attempt, we don't so easily know that we cannot remove an abstraction
20:17:13 <erisco> because there is another method of reduction called eta-reduction which reduces  \x -> f x  to  f
20:17:19 <iqubic> Is it possible to remove an abstration?
20:17:40 <erisco> so it is conceivable we could have an 'a' which enables this reduction, and thus we can't rule out this form of solution so easily
20:18:04 <iqubic> but, if I do that on \x -> a x x I get a x
20:18:06 <erisco> but, it is alright to say "this looks too complicated" and try something else first
20:18:31 <iqubic> if I eta-reduce \x -> a x x I get a x
20:18:49 <erisco> no, that is invalid, I didn't say it fully
20:18:57 <erisco> x has to be free in f
20:19:38 <iqubic> And x isn't free in \x -> a x x?
20:19:49 <erisco> so  \x -> a x x ≡ \x -> (a x) x
20:20:00 <erisco> thus our  f  would be  (a x)  and this is not free of x
20:20:07 <iqubic> Ah, right.
20:20:21 <erisco> I was referring back to lines 12-15 though
20:20:30 <erisco> when you said "two abstractions here, we need one, not right"
20:20:51 <iqubic> So is s a the right form to use?
20:21:11 <erisco> yes, you do need to get rid of an abstraction, but may be possible, so it isn't ruling out 's a' yet
20:21:24 <erisco> I am just mentioning that so you don't accidentally overlook this in the future
20:21:43 <iqubic> How d I remove an abstraction from \g x -> a x (g x)?
20:21:59 <iqubic> s/d/do/
20:23:38 <erisco> I wouldn't go down that path, I'd go back to 's a b' because you have that really close to solved
20:24:40 <iqubic> Alright
20:24:52 <erisco> but say you choose  a = \x y -> y  then  \g x -> (\x y -> y) x (g x) ≡ \g x -> g x ≡ \g -> g
20:25:00 <erisco> that's an eta-reduction taking place at the end
20:25:21 <iqubic> Wait, what???
20:25:44 <iqubic> I don't have an \x y -> y
20:25:58 <iqubic> And I don't want  \g -> g
20:26:13 <erisco> you were asking how you could remove an abstraction, and I showed an example of how
20:26:33 <erisco> the fact it is possible means we cannot rule out the 's a' solutions conclusively based on there being two abstractions
20:26:37 <erisco> that is the only point I am making
20:27:09 <iqubic> But I don't want to work with s a
20:27:15 <iqubic> I want to work with s a i
20:27:21 <erisco> good, do that :)
20:27:29 <iqubic> s a i = \x -> a x x 
20:27:36 <iqubic> I don't know where to go from there.
20:27:48 <erisco> \x -> a x x ≡ \x -> (a x) x
20:27:51 <erisco> how about now?
20:28:03 <iqubic> Right. I see what to do.
20:28:20 <iqubic> \x -> (a x) x === a x
20:28:32 <iqubic> s x i = \x -> x x
20:28:44 <erisco> what is x?
20:29:05 <iqubic> x is the input to the lambda
20:29:24 <erisco> if you say the answer is 's x i' I know what s is, and I know what i is, but what is x?
20:29:36 <iqubic> I don't know.
20:29:56 <iqubic> \x -> (a x) x === a x
20:30:00 <iqubic> Is that correct?
20:30:03 <erisco> what does === mean?
20:30:12 <iqubic> I don't know.
20:30:36 <erisco> if you are saying  (\x -> (a x) x) ≡ a x  then no, that is incorrect
20:30:42 <iqubic> Point is I can eta-reduce over \x -> (a x) x and get a x
20:31:14 <erisco> remember for eta-reduction i.e.  \x -> f x ≡ f  that x cannot occur in f
20:31:16 <iqubic> s i i = \x -> x x
20:31:56 <erisco> derp, I realised I said it precisely backwards earlier
20:31:59 <erisco> I said "x has to be free in f"
20:32:07 <erisco> no no, x *cannot* be free in f
20:32:24 <erisco> in my head I get "f is free of x" and "x is free in f" confuddled
20:32:34 <iqubic> (\f g x -> f x (g x)) (s k k) (s k k)
20:32:59 <iqubic> (\g x -> f x (g x)) (s k k)
20:33:10 <iqubic> (\g x -> f x (s k k x)) (s k k)
20:33:44 <iqubic> \x -> s k k x (s k k x)
20:34:00 <iqubic> \x -> (s k k x) (s k k x)
20:34:08 <iqubic> s k k x = x
20:34:12 <iqubic> \x -> x x
20:34:14 <erisco> your substitutions did not happen correctly but you ended up in the right place
20:34:14 <iqubic> done
20:34:23 <iqubic> yeah, sorry.
20:34:35 <iqubic> I miss typed one of them.
20:34:42 <iqubic> s i i is \x -> x x
20:34:48 <erisco> yes, that is the answer, s i i
20:34:56 <iqubic> That's cook
20:35:02 <iqubic> s/cool/cook
20:35:07 <erisco> is that what the cool kids say now?
20:35:20 <iqubic> It's late and I'm tired. I meant to type cool.
20:35:46 <iqubic> funny how \x -> x and \x -> x x look similar.
20:35:53 <iqubic> So do the s k i versions
20:36:13 <iqubic> \x -> x is s k k and \x -> x x is s i i
20:36:44 <erisco> it is funny how CO2 looks similar to CO
20:37:33 <iqubic> LOL
20:38:39 <iqubic> S K I can get a person far.
20:39:06 <erisco> you can actually convert any lambda term to an SK term
20:39:24 <iqubic> How was that proven?
20:40:04 <iqubic> And that means that \f x y -> f y x can be written in SK terms?
20:40:12 <erisco> well, you could do it by defining a function from lambda terms to SK terms and proving it is total
20:40:22 <iqubic> That sounds hard
20:40:44 <erisco> I am not sure what the typical proof of this is, but you can find it in any text on combinators
20:40:57 <iqubic> I don't need to see the proof.
20:41:20 <iqubic> Where did you get the excercises you showed me today?
20:41:52 <erisco> I don't know exactly since you find them in just about any introductory text on untyped lambda calculus
20:42:26 <erisco> which also covers combinators
20:43:20 <erisco> I guess you'd also have to prove the lambda term and sk terms were functionally equivalent, heh, that'd be important
20:43:42 <erisco> it is probably something based on structural induction
20:43:48 <iqubic> See the only lambda notation I know is Haskell's lambda notation.
20:44:28 <erisco> replace \ with λ and -> with . and you're now a pro
20:44:39 <iqubic> Is that really all there is?
20:44:50 <erisco> oh, and only use single letter names and remove all spaces
20:45:01 <erisco> so, instead of  \x -> x x  you'd write  λx.xx
20:45:07 <iqubic> I see.
20:45:14 <erisco> not strictly necessary to remove spaces but you often see that
20:45:44 <iqubic> Can you encode true and false in lambda caluculus?
20:45:49 <erisco> yes
20:46:02 <iqubic> Seems hard to do in a language that is only functions.
20:46:03 <erisco> these are called Church encodings
20:46:19 <iqubic> See I found this online: https://www21.in.tum.de/~eberlm//lambda_paper.pdf
20:46:45 <erisco> let true = \x y -> x; let false = \x y -> y
20:46:54 <iqubic> Right and then what is not?
20:46:59 <boj> wow, you two are still going at it ^_^
20:47:13 <iqubic> boj: We took a break earlier.
20:47:13 <erisco> @remember boj wow, you two are still going at it ^_^
20:47:13 <lambdabot> It is forever etched in my memory.
20:47:43 <iqubic> You must not take that out of context now.
20:47:45 <boj> i was following a little bit earlier, been fun to watch
20:47:50 <erisco> iqubic, can you figure it out?
20:49:50 <iqubic> I think I just figured it out.
20:50:18 <iqubic> \p -> p false true
20:50:25 <erisco> yes
20:50:30 <iqubic> where p is a predicate defined earlier.
20:50:43 <erisco> why defined earlier? it is captured
20:51:08 <iqubic> captured? How so?
20:51:16 <erisco> \p captures p
20:51:35 <iqubic> Ah. I see.
20:51:58 <erisco> now define if/then/else
20:52:19 <iqubic> That's easy
20:52:29 <iqubic> \p a b -> p a b
20:52:47 <iqubic> true returns the a. false returns the b
20:53:05 <erisco> now reduce it
20:53:17 <iqubic> How? 
20:53:22 <iqubic> Where do I start?
20:53:24 <erisco> use eta reductions
20:53:51 <iqubic> I'm not sure I can.
20:54:07 <erisco> \p a b -> p a b ≡ \p -> \a -> \b -> (p a) b
20:54:28 <iqubic> I don't get eta-reductions
20:54:58 <erisco> \x -> f x  eta-reduces to  f  if x is *not* free in f
20:55:09 <bigdaddytank> whoa
20:55:12 <bigdaddytank> that's cool
20:55:36 <iqubic> So how can I reduce \p a b -> p a b?
20:55:59 <erisco> well, you get to pick what f is, and you can alpha convert the x
20:56:14 <erisco> so find something that fits a subterm of  \p -> \a -> \b -> (p a) b
20:56:56 <iqubic> Like what?
20:57:08 <erisco> try f = p a
20:57:20 <iqubic> alright.
20:57:37 <iqubic> and b = x
20:57:44 <iqubic> or rather x = b
20:57:52 <erisco> right
20:58:49 <iqubic> It reduces to \p -> \a -> p a
20:58:58 <iqubic> and then to \p -> p
20:59:06 <erisco> correct
20:59:07 <iqubic> and then to just p
20:59:11 <erisco> no
20:59:23 <iqubic> No, just to \p -> p
20:59:35 <erisco> what rule did you use to get just p?
20:59:49 <iqubic> I can't use any rule to get there.
21:00:52 <iqubic> Well, I suppose that this stuff has no useful applications at all.
21:00:59 <erisco> oh, it absolutely does
21:01:11 <iqubic> I does?
21:01:15 <boj> turns out to be very useful
21:01:19 <erisco> the reductions work the same in Haskell, mostly
21:01:29 <erisco> and Church encodings are important
21:01:56 <iqubic> They are? How are Church encodings helpful?
21:01:59 <erisco> you will see them again in functions such as foldr
21:02:05 <erisco> and every Haskeller loves their foldr
21:02:29 <erisco> Church encodings let us convert between functions and data types
21:02:46 <iqubic> Really? How so?
21:02:57 <iqubic> erisco: I don't like foldr
21:03:01 <iqubic> :t foldr
21:03:02 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
21:03:12 <ski> @type GHC.Exts.build
21:03:13 <lambdabot> (forall b. (a -> b -> b) -> b -> b) -> [a]
21:03:39 <boj> oh my, blasphemy
21:03:43 <iqubic> > foldr (+) 0 [1,2,3...]
21:03:46 <lambdabot>  error:
21:03:46 <lambdabot>      A section must be enclosed in parentheses thus: (3 ...)
21:03:54 <iqubic> > foldr (+) 0 [1,2...]
21:03:56 <lambdabot>  error:
21:03:57 <lambdabot>      A section must be enclosed in parentheses thus: (2 ...)
21:03:59 <erisco> iqubic, how so? well it is actually fairly straight-forward but I don't know if I want to explain it all right now :P
21:04:00 <iqubic> > foldr (+) 0 [1,2..]
21:04:07 <lambdabot>  mueval-core: Time limit exceeded
21:04:15 <iqubic> That is why I hate foldr
21:04:18 <erisco> > foldr (:) [] [1,2..]
21:04:21 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
21:04:24 <erisco> that is the compelling example for you
21:04:35 <bigdaddytank> some of this is (not foldr) slighty too advanced for me xD, I still gotta get Haskell and Idris down
21:04:43 <iqubic> What the bloody hell did you just do??
21:04:48 <erisco> muahaha
21:05:16 <iqubic> Why not just write [1,2..] to start with?
21:05:28 <iqubic> :t (:)
21:05:30 <lambdabot> a -> [a] -> [a]
21:05:35 <erisco> iqubic, that is showing you the relationship between the Church encoding and the data type
21:05:43 <ski> summing an infinite number of things doesn't work. ask Zenon
21:05:51 <erisco> iqubic, that is, if we put the data constructors into the Church encoding, we get the data
21:05:57 <bigdaddytank> erisco: (:) is an infix, right?
21:06:09 <iqubic> What is that Church encoding doing there?
21:06:15 <erisco> iqubic, I should also point out that foldr does the work of converting the data (our [1,2..] list) into the Church encoding
21:06:31 <iqubic> I see.
21:06:31 <erisco> iqubic, this is made a little obscure because foldr takes the list last, but that is what is happening
21:07:03 <iqubic> But the Church encoding of [1,2..] is [1,2..]
21:07:04 <erisco> > maybe Nothing Just (Just "hello sailor!")
21:07:07 <lambdabot>  Just "hello sailor!"
21:07:08 <ski> no
21:07:24 <iqubic> Why do you like "hello sailor!"?
21:07:26 <ski> it is `\cons nil -> cons 1 (cons 2 (...))'
21:07:36 <erisco> iqubic, it is something I picked up from a games programmer...
21:08:18 <erisco> the type of the Church encoding is  (a -> b -> b) -> b -> b
21:08:18 <iqubic> erisco: where did the nothing go in that last example?
21:08:31 <iqubic> :t foldr
21:08:32 <ski> the `forall' is crucial
21:08:33 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
21:08:36 <erisco> > maybe Nothing Just Nothing
21:08:39 <lambdabot>  Nothing
21:08:45 <iqubic> :t maybe
21:08:47 <lambdabot> b -> (a -> b) -> Maybe a -> b
21:08:50 <ski> the type chould be `forall b. (a -> b -> b) -> b -> b'
21:09:11 <iqubic> Why forall b.
21:09:22 <iqubic> I don't understand the keyword forall at all.
21:09:33 <ski> it indicates polymorphism
21:09:41 <erisco> > either Left Right (Right "hello sailor!")
21:09:44 <lambdabot>  Right "hello sailor!"
21:09:58 <iqubic> stop messing with me.
21:09:58 <erisco> anyways, those are all examples of Church encoding, though I am just using it as id
21:09:59 * ski notes erisco likes implementing `id'
21:10:13 <iqubic> Why do you like id so much?
21:10:26 <erisco> lol, well it is just the easy way to show the relationship
21:10:38 <erisco> maybe it isn't so intuitive but I wasn't trying to explain how it works
21:10:41 <ski> the type of e.g. `length' is not `[a] -> Int'. it is `forall a. [a] -> Int'
21:10:52 <iqubic> Right.
21:10:55 <iqubic> I see why that works
21:11:07 <ski> the `forall' there tells us that `length' is polymorphic. works for all types `a'
21:11:13 <ski> now, consider
21:11:20 <iqubic> Can you use Church encoding for things other than id?
21:11:33 <ski> yes
21:11:33 <erisco> absolutely
21:11:34 <iqubic> But first let's consider ski's thing
21:11:44 <ski>   foldr :: (a -> o -> o) -> o -> [a] -> o
21:11:50 <erisco> > foldr (+) 0 [1,2,3] -- like your example earlier
21:11:51 <ski> which is an abbreviation for
21:11:52 <lambdabot>  6
21:11:59 <ski>   foldr :: forall a o. (a -> o -> o) -> o -> [a] -> o
21:12:16 <ski> if we rearrange the parameters, we get
21:12:21 <iqubic> Right. I see how that works.
21:12:34 <ski>   \as cons nil -> foldr cons nil :: forall a o. [a] -> (a -> o -> o) -> o -> o
21:12:53 <ski> the `forall' with two tyvars is short for
21:12:59 <ski>   \as cons nil -> foldr cons nil :: forall a. forall o. [a] -> (a -> o -> o) -> o -> o
21:13:07 <ski> and now we can rearrange this as
21:13:08 <iqubic> erisco: what is that foldr doing? can't you do foldl there?
21:13:23 <ski>   \as cons nil -> foldr cons nil :: forall a. [a] -> forall o. (a -> o -> o) -> o -> o
21:13:25 <erisco> sure you can
21:13:31 <iqubic> > foldl (+) 0 [1,2,3]
21:13:33 <lambdabot>  6
21:13:41 <iqubic> Then why is foldr special?
21:13:42 <erisco> ski, you're forgetting to apply 'as'
21:13:56 <ski> oh, you're right, i do
21:14:01 <ski>   \as cons nil -> foldr cons nil as :: forall a. [a] -> forall o. (a -> o -> o) -> o -> o
21:14:12 <iqubic> ski: I get the point there.
21:14:35 <ski> for any `a', `foldr' basically converts from `[a]' to `forall o. (a -> o -> o) -> o -> o'
21:14:40 <iqubic> So why is foldr special? Why not use foldl?
21:14:44 <ski> and `build' converts in the opposite direction
21:14:54 <iqubic> Build???
21:14:56 <ski> `foldr' is the catamorphism for lists
21:15:03 <ski> @type GHC.Exts.build
21:15:04 <erisco> iqubic, foldl can be defined with foldr
21:15:04 <lambdabot> (forall b. (a -> b -> b) -> b -> b) -> [a]
21:15:17 <ski>   build folder = folder (:) []
21:15:18 <iqubic> I don't know what a catamorphism is.
21:15:42 <ski> it means that we replace the data constructors (recursively) with custom functions
21:15:46 <iqubic> I see.
21:15:54 <iqubic> Why the hell is that useful???
21:15:55 <erisco> think about it… maybe… like reinterpreting a data structure
21:16:03 <erisco> > foldr f z [a,b,c]
21:16:05 <lambdabot>  f a (f b (f c z))
21:16:16 <iqubic> Oh, I see.
21:16:25 <ski> iqubic : you can express any list consumption in terms of `foldr'
21:16:29 <erisco> a : b : c : []  turned into  a `f` (b `f` (c `f` z))
21:16:30 <ski> not so for `foldl'
21:16:46 <iqubic> So I suppose it did.
21:17:09 <noob> Say I have a list of funcs, e.g  > let myList = map (*) [0..] Then how can I apply a parameter to this list. I want to of something like: > map (5) myList But this a syntax error
21:17:18 <iqubic> > foldl f z [a,b,c] -- foldl reverses the list here
21:17:21 <lambdabot>  f (f (f z a) b) c
21:17:24 <ski> noob : `map ($ 5) ...'
21:17:56 <erisco> iqubic, if we used flip (:) and [], yes, it would
21:17:59 <noob> awesome@
21:18:03 <iqubic> a : b : c : []  turned into  z `f` (a `f` (b `f` c))
21:18:17 <iqubic> Or not really.
21:18:38 <ski> > foldr (flip f) z [a,b,c]
21:18:40 <lambdabot>  f (f (f z c) b) a
21:19:00 <iqubic> so how do the other Church encodings work? like the one built with maybe
21:19:06 <ski> > foldl (flip f) z [a,b,c]
21:19:08 <lambdabot>  f c (f b (f a z))
21:19:24 <ski> `Maybe a' is turned into `forall o. o -> (a -> o) -> o'
21:19:24 <iqubic> > maybe Nothing Just (Just "hello sailor!")
21:19:26 <lambdabot>  Just "hello sailor!"
21:19:40 <ski> `Either a b' is turned into `forall o. (a -> o) -> (b -> o) -> o'
21:19:45 <boj> > foldl f z [a,b,c]
21:19:48 <lambdabot>  f (f (f z a) b) c
21:19:55 <erisco> why not you have ski explain it to you :)
21:20:11 <iqubic> So those are functions that take data types, and turn them into something else?
21:20:19 <vimalloc> At a glance, I see lots of web frameworks in haskell. Does anyone have a recomendataion for what would be a good framework to use for a simple REST api?
21:20:22 <ski> @type maybe
21:20:24 <ski> @type either
21:20:25 <lambdabot> b -> (a -> b) -> Maybe a -> b
21:20:27 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
21:20:51 <boj> vimalloc: depends on how simple you want. you can get going quickly with Scotty, but if you want to get deep look at Servant
21:21:14 <iqubic> I understand what the functions do. 
21:21:34 <iqubic> I don't get why they work in these Church Encodings.
21:21:50 <erisco> so, we start with a data definition, such as  data Maybe a = Nothing | Just a
21:21:56 <vimalloc> boj: Basically using it for a wrapper around database stuff. I'll check those out, thanks! 
21:22:02 <iqubic> Alright. Sounds good
21:22:09 <slack1256> @type Just
21:22:10 <erisco> then we look at the total case analysis for this type
21:22:11 <lambdabot> a -> Maybe a
21:22:38 <iqubic> go ahead and do that erisco
21:22:39 <erisco> \m n j -> \case m of Nothing -> n; Just x -> j x
21:22:45 <erisco> er, not \case, just case
21:22:50 <erisco> too much LambdaCase
21:23:13 <erisco> so, what does this case analysis look like
21:23:14 <iqubic> that's the function maybe
21:23:21 <erisco> well, it is total, so we have to consider all cases
21:23:36 <erisco> and we are going to pass along any variables we uncover
21:23:42 <iqubic> it is the fuction maube though.
21:23:51 <iqubic> *maybe
21:24:04 <erisco> I reordered the parameters, but yes, it is the same function
21:24:44 <erisco> now, do the same for Either, to see if you understand the pattern thus far
21:26:07 <iqubic> \e x y -> case e of Left a -> x a; Right b -> y b
21:26:17 <iqubic> There you have it
21:26:18 <erisco> I should also connect this better to lambda calculus by pointing out how we can define Just and Nothing without data constructors, i.e. as functions instead
21:26:31 <iqubic> You can?
21:26:38 <erisco> yes
21:26:53 <erisco> that's what we're doing by Church encoding
21:26:55 <iqubic> did I get my either right?
21:27:08 <erisco> I'm showing you how to convert from data to Church
21:27:12 <iqubic> Ah.
21:27:32 <erisco> yes you got it
21:27:39 <iqubic> So I get the pattern
21:28:00 <erisco> nothing = \n j -> j   just x = \n j -> j x
21:28:07 <erisco> i.e. just = \x n j -> j x
21:28:16 <iqubic> I see.
21:28:19 <erisco> do you see how that relates to the case analysis?
21:29:08 <iqubic> left = \n a b -> n a   right = \n a b -> n b
21:29:18 <erisco> let maybe = \m n j -> case m of Nothing -> n; Just x -> j x;  then  maybe Nothing ≡ \n j -> n
21:29:21 <iqubic> and yes I see the relationship
21:29:30 <erisco> maybe (Just x) ≡ \n j -> j x
21:29:41 <erisco> note that my version of maybe has the parameters reordered
21:29:57 <erisco> Haskell's version is ordered differently because it is usually more convenient that way
21:30:21 <iqubic> I see.
21:30:35 <erisco> okay, so now I throw you a curve ball and give you   data [a] = [] | a : [a]
21:30:43 <iqubic> that's a list.
21:31:01 <erisco> it is. see if you can use what you've learned on lists
21:31:55 <iqubic> I'm not sure I can
21:32:21 <erisco> what happened?
21:32:43 <iqubic> Well, you can't do anything with the empty list.
21:32:55 <erisco> really? what did we do for Nothing?
21:33:11 <iqubic> returned the intial value
21:33:39 <iqubic> the thing is: you need recursion to work with lists.
21:33:58 <erisco> ah, yes we do, because lists are defined inductively, i.e. they refer to themselves
21:34:09 <erisco> so, how might that look
21:34:20 <iqubic> And I don't think you can do recursion with a nameless function.
21:34:46 <erisco> list xxs n c = case xxs of [] -> n; x:xs -> c x xs
21:34:52 <erisco> what happens if we just try this?
21:35:11 <iqubic> It works
21:35:31 <erisco> :t \xxs n c = case xxs of [] -> n; x:xs -> c x x
21:35:33 <lambdabot> error:
21:35:33 <lambdabot>     parse error on input ‘=’
21:35:33 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
21:35:39 <erisco> :t \xxs n c -> case xxs of [] -> n; x:xs -> c x x
21:35:40 <lambdabot> [t1] -> t -> (t1 -> t1 -> t) -> t
21:35:54 <erisco> good job copying and pasting...
21:35:55 <iqubic> that's a church encoding
21:35:57 <erisco> :t \xxs n c -> case xxs of [] -> n; x:xs -> c x xs
21:35:59 <lambdabot> [t1] -> t -> (t1 -> [t1] -> t) -> t
21:36:14 <erisco> I think this is called a Scott encoding, but don't quote me
21:36:27 <iqubic> I won't
21:36:32 <iqubic> :t foldr
21:36:33 <erisco> ski might know
21:36:34 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
21:36:43 <iqubic> Wait, that's not the same
21:36:51 <erisco> we have a bit of a blip here because we didn't get rid of the list type
21:37:12 <erisco> and our objective is to convert the list type to some function type
21:37:25 <erisco> we're trying to get rid of data constructors and replace them with functions, after all
21:37:32 <iqubic> Yeah. I'm not sure how to do that.
21:37:41 <erisco> so, where is the remaining list at? what variable is it?
21:37:57 <iqubic> it's the xs
21:38:20 <iqubic> we need to do the same exact case thing with the xs
21:38:37 <erisco> yes, and so what function can we use for that?
21:38:45 <iqubic> is it fix?
21:38:52 <erisco> no
21:39:00 <iqubic> \x -> x x
21:39:08 <iqubic> I'm mostly just guessing here.
21:39:10 <erisco> we want a function that converts a list to the Church encoding
21:39:28 <erisco> what are we currently defining?
21:39:38 <iqubic> We just wrote one. We just need to apply it recursively to itself.
21:39:53 <erisco> yes, so how should that look?
21:40:30 <iqubic> \xxs n c -> case xxs of [] -> n; x:xs -> c x (\xxs n c -> case xxs of [] -> n; x:xs -> c x (\xxs n c -> ...
21:40:51 <iqubic> until we get to something that terminates.
21:41:06 <iqubic> If it doesn't terminate then we have an infinite list
21:41:51 <erisco> we can't just type out an infinite expression, and Haskell doesn't know what "..." means, so what else can we do
21:42:08 <erisco> remember I started with  list xxs n c = case xxs of [] -> n; x:xs -> c x xs
21:42:45 <iqubic> We either need to name the function, or use some other clever form of recursion.
21:42:57 <erisco> I named it "list", see
21:43:07 <iqubic> Oh. I see.
21:43:22 <erisco> named like "maybe", "bool", "either", and so forth
21:43:28 <iqubic> list xxs n c = case xxs of [] -> n; x:xs -> c x (list xs)
21:43:53 <erisco> but  list xs  doesn't have the right type
21:44:08 <iqubic> list xxs n c = case xxs of [] -> n; x:xs -> c x (list xs n c)
21:44:19 <erisco> there we go
21:44:26 <iqubic> just keep using the same n and c from before.
21:44:30 <erisco> :t let list xxs n c = case xxs of [] -> n; x:xs -> c x (list xs n c) in list
21:44:32 <lambdabot> [t1] -> t -> (t1 -> t -> t) -> t
21:44:51 <iqubic> And that's like foldr, but with the parameter order changed
21:44:58 <erisco> @src foldr
21:44:58 <lambdabot> foldr f z []     = z
21:44:58 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:45:06 <erisco> indeed, it is
21:45:15 <monochrom> @type maybe
21:45:17 <lambdabot> b -> (a -> b) -> Maybe a -> b
21:46:29 <iqubic> erisco: that's exactly what we derived
21:46:34 <erisco> yes
21:46:47 <erisco> so, now you can play this game for other ADTs
21:46:56 <iqubic> Like what?
21:47:03 <erisco> binary trees, say
21:47:16 <iqubic> I don't know how binary trees work
21:47:23 <iqubic> Just give me the data declaration.
21:47:47 <erisco> data BinTree a = Leaf | Branch a (BinTree a) (BinTree a)
21:47:55 <erisco> not the only conceivable binary tree but that'll do
21:52:34 <iqubic> tree t f z = case t of Leaf -> z; case (Branch x left right) -> f (f x (tree left f z)) tree right f z
21:52:38 <iqubic> There we go.
21:53:18 <erisco> I don't think that is going to type check
21:53:31 <iqubic> you don't???
21:53:49 <erisco> well, it is wrong either way, try again :)
21:53:58 <iqubic> This is hard.
21:54:12 <iqubic> tree t f z = case t of Leaf -> z; case (Branch x left right) -> _
21:54:21 <iqubic> I have a start at least
21:54:36 <erisco> so, start with   tree t f z = case t of Leaf -> z; case (Branch x l r) = f x l r
21:54:47 <erisco> this is similar to what we did with lists
21:55:04 <erisco> now we have both l and r which are trees, so what do we need to do
21:55:19 <iqubic> erisco: we need to call tree on them both
21:55:30 <erisco> right, so what does that look like
21:56:02 <iqubic> tree t f z = case t of Leaf -> z; case (Branch x l r) = f x (tree l f z) (tree r f z)
21:56:32 <erisco> looks good
21:56:57 <iqubic> That will type check, but I thought we only wanted to call our function on 1 argument
21:57:11 <erisco> what made you think that? hm
21:57:16 <iqubic> I thought we wanted a function f :: a -> a
21:57:21 <erisco> data Pair a = Pair a a    do it for this
21:57:38 <iqubic> wait, is that the right for tree though?
21:57:45 <erisco> yes, it is
21:57:56 <erisco> I am not sure why you expected some  f :: a -> a  though
21:58:03 <iqubic> I'm not either.
21:58:07 <erisco> :t foldr
21:58:08 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
21:58:14 <erisco> we didn't expect that here
21:58:21 <iqubic> No, I guess not.
21:58:41 <erisco> when we pattern match the constructor we take all the fields out
21:58:51 <erisco> so if there are N fields then we end up with N variables, all of which we pass along
21:58:54 <iqubic> So, time to work on a pair.
21:59:07 <erisco> for [] and Nothing there are no fields, so no variables, so nothing to pass along
21:59:15 <erisco> for (:) there are two fields, so two variables, which we pass along
21:59:19 <erisco> for Branch it is 3
21:59:37 <iqubic> pair has two varibles. fst and snd.
21:59:53 <erisco> sure, if you want to call them that
21:59:58 <iqubic> the two 'a's in Pair a a
22:00:40 <iqubic> pair (Pair a b) f = f a b
22:00:42 <iqubic> done.
22:00:56 <iqubic> That was simple. One constructor, no recursion.
22:01:14 <erisco> right
22:01:33 <erisco> :t uncurry
22:01:35 <lambdabot> (a -> b -> c) -> (a, b) -> c
22:02:05 <erisco> you may not have thought it, but uncurry makes the Church encoding for 2-tuples
22:02:23 <iqubic> I just now realize that yeah.
22:03:25 * hackagebot pseudo-boolean 0.1.6.0 – Reading/Writing OPB/WBO files used in pseudo boolean competition – https://hackage.haskell.org/package/pseudo-boolean
22:04:15 <erisco> so, lambda calculus is not just a pastime
22:05:00 <iqubic> Why is Church encoding helpful?
22:05:19 <erisco> because we get functions like maybe, either, bool, foldr, and more
22:05:41 <iqubic> I see
22:05:53 <iqubic> What does curry do?
22:05:55 <erisco> it lets us reinterpret the data constructors of some construction, I think I said it as earlier
22:05:58 <iqubic> :t curry?
22:06:00 <iqubic> :t curry
22:06:00 <lambdabot> error:
22:06:00 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
22:06:01 <lambdabot> ((a, b) -> c) -> a -> b -> c
22:06:45 <erisco> so if you build up any data type you can imagine swapping all the constructors for some other function of our choosing
22:07:05 <erisco> and this is something the Church encoding lets us do
22:07:26 <iqubic> I see now. How enlightening
22:10:47 <erisco> it is common to have a fold defined for any new data type
22:11:15 <iqubic> And Church encoding gets us that fold function?
22:11:16 <erisco> "fold" referring to the kind of functions we've been deriving
22:11:19 <erisco> also called catamorphisms
22:11:24 <erisco> that's right
22:11:35 <iqubic> Why are they called catamorphisms?
22:11:44 <erisco> because category theorists are funny
22:11:53 <trigone> hi, is there a time limit over lpastes?
22:12:13 <erisco> trigone, lpaste is sometimes slow and times out, if that is what you mean
22:13:05 <erisco> iqubic, also you have anamorphisms and paramorphisms and apomorphisms and zygomorphisms and histomorphisms and and and...
22:13:17 <iqubic> erisco: If I were to put up a paste today, how long would it be until it is removed from the lpaste servers?
22:13:22 <erisco> futumorphisms
22:13:28 <erisco> is zygomorphism in recursion schemes? I have no idea
22:13:32 <iqubic> That is what trigone wants t to?
22:13:45 <erisco> oh, I have no idea
22:13:53 <iqubic> Do you know all about the morphisms?
22:13:55 <erisco> someone said to me they thought they lasted forever and that is all I've heard on the subject
22:14:04 <mniip> erisco, of course it is
22:14:11 <erisco> iqubic, no, not much, but there are avid category theorists in channel
22:14:13 <iqubic> I know about isomorphisms.
22:14:18 <mniip> all components of the zygohistomorphic prepromorphism are
22:14:36 <erisco> it is on my TODO list so I have a clue what these maniacs are talking about
22:15:06 <mniip> iqubic, I know some things about morphisms but not much about f-(co)algebras so sadly my knowledge of ana/catamorphisms is lacking
22:15:16 <erisco> iqubic, anyways there is an intro here which you should be able to follow if you know some Haskell http://blog.sumtypeofway.com/an-introduction-to-recursion-schemes/
22:15:17 <mniip> erisco, haha yes, likewise
22:15:48 <iqubic> catamorphisms aren't recursion though right?
22:15:52 <erisco> the CT book is on my shelf but I have been reading other stuff
22:16:09 <erisco> iqubic, they involve recursion if necessary, yes
22:16:25 <erisco> iqubic, we used it for foldr, remember
22:16:27 <iqubic> erisco: I know lots of haskell.
22:16:36 <iqubic> and the tree example
22:16:52 <erisco> it isn't general recursion like fix is, it is specialised
22:17:04 <erisco> "recursion schemes" are various ways to be recursive :)
22:17:18 <trigone> yes iqubic that was what i meant :) forever, we'll have to test that :P
22:17:30 <erisco> the idea is to capture all the various patterns of writing recursion functions
22:17:45 <erisco> or at least enough of them that we cover the majority of common cases
22:17:55 <iqubic> I think that fix and stuff are included, right?
22:18:17 <erisco> included in what? I don't know what fix is in terms of categories
22:18:37 <iqubic> fix is a function.
22:18:41 <iqubic> @src fix
22:18:41 <lambdabot> fix f = let x = f x in x
22:18:45 <trigone> erisco: the fixed point of a functor? mind you i don't know what that means mathematically
22:18:54 <erisco> dod 
22:19:01 <erisco> did "in terms of categories" get lost in transmission?
22:19:07 <mniip> oh look a typo
22:19:30 <erisco> I was just signaling the department of defense.
22:20:04 <mniip> no, not yours
22:20:07 <mniip> the article you linked
22:20:28 <erisco> I have a knack for landing straight on the first typo when I begin reading something
22:20:36 <erisco> according to my confirmation bias I am unnaturally gifted in this
22:21:20 <mniip> trigone, fixpoint of an endofunctor F is an object X that is isomoprhic to F X
22:22:02 <trigone> mniip: hm ok
22:22:06 <mniip> kinda obvious copy-paste from the mathematical definition of a function fixpoint
22:22:36 <erisco> yeah but it is about how we set this up in a more complete categorical framework
22:22:38 <mniip> hmm
22:22:43 <erisco> what are the significant things we can say about it, etc
22:22:50 <mniip> I should continue reading mac lane
22:23:00 <mniip> but procrastination sounds much more enjoyable
22:23:05 <iqubic> I know next to nothing about catagory theory
22:23:17 <trigone> anyone around knows how to use tagless final interpreters?
22:23:18 <mniip> iqubic, you need not know a lot to do haskell
22:23:50 <erisco> you don't need to know any category theory to read those articles on recursion schemes
22:23:55 <mniip> yes
22:24:06 <iqubic> I know a fair bit of haskell
22:24:18 <mniip> I'm interested in mathematical CT at this point
22:24:28 <mniip> not "childish" CT you find in haskell blog posts :p
22:24:45 <erisco> it is just becoming annoying because it comes up just about every day
22:24:58 <mniip> erisco, what is
22:24:58 <erisco> it is talked about 90% of the time and also claimed to be 90% irrelevant
22:25:10 <erisco> CT in relation to Haskell
22:25:11 <iqubic> What comes up every day?
22:25:47 <iqubic> CT and haskell are largely different.
22:26:05 <erisco> no doubt but all the cool kids are into it
22:26:20 <erisco> else it wouldn't keep coming up for being as supposedly irrelevant as it is
22:26:38 <iqubic> CT is irrelevant?
22:27:08 <erisco> "do I need to know CT to do this thing in Haskell?" "no"
22:27:26 <erisco> that should be on the FAQ
22:27:46 <erisco> in fact it is like a running in-joke
22:28:06 <mniip> aha!
22:28:19 <iqubic> does knowing CT help with Haskell?
22:28:35 <nisstyre> no
22:28:43 <erisco> well that's weak enough you could answer "yes"
22:28:46 <nisstyre> unless you want to use libraries that make heavy use of those ideas
22:29:15 <erisco> but I have to imagine lots of things other than CT could satisfy that
22:29:24 <nisstyre> knowing a bit of logic helps though
22:29:43 <mniip> a full (faithful) functor is one that is surjective/injective as a mapping from any specific hom-set in the domain
22:29:54 <mniip> that's a conscise definition
22:30:03 <iqubic> mniip: Stop using big fat words
22:30:30 <erisco> surjective and injective? I know what that means
22:30:37 <nisstyre> knowing a bunch of category theory stuff isn't going to be the deciding factor for whether or not you can write high quality Haskell code and ship stuff
22:30:42 <mniip> that's from basic calculus
22:30:48 <erisco> b-b-b-b-b-bijection!
22:30:50 <nisstyre> if you're an academic it might be different though because you can take 5 years to write it
22:31:19 <mniip> nisstyre, took me a couple years to write 5-ish lines of code!
22:31:25 <iqubic> I'm taking pre-calc in the next academic year
22:31:26 <nisstyre> and only like 5 other people have to understand it
22:31:42 <nisstyre> (the people reviewing your paper)
22:31:49 <nisstyre> and maybe they don't even need to
22:31:53 <trigone> lol
22:32:09 <mniip> nisstyre, I want to understand edwardk :(
22:32:09 <trigone> so, nobody knows about tagless final interpreters?
22:32:21 <nisstyre> mniip: he seems like a pretty cool guy
22:32:23 <mniip> trigone, might wanna expand on that
22:32:34 <nisstyre> can't understand half of what he says but that's fine
22:32:41 <mniip> well
22:32:56 <mniip> it's essential to want to understand more of it
22:33:05 <erisco> mniip, that is provably impossible
22:33:13 <mniip> increase the volume of potential information you can receive
22:33:24 <mniip> erisco, approachable still
22:33:34 <nisstyre> mniip: how much of this site can you understand? http://okmij.org/ftp/
22:33:54 <nisstyre> I could never really get my head around delimited continuations
22:33:55 <mniip> nisstyre, well that's an index
22:34:45 <nisstyre> I'm looking for someone who can tell me what delimited continuations are good for in real code
22:34:59 <mniip> oh right
22:35:01 <mniip> Cont
22:35:06 <mniip> see ya later!
22:35:20 <erisco> mniip, you run into a sort of Russell paradox because he has the set of all knowledge
22:35:35 <mniip> erisco, but he communicates only a finite amount
22:35:51 <mniip> surely the kolmogorov complexity of all knowledge is infinite
22:35:59 <erisco> well, I suppose we can comprehend his inquiry as to where the bathrooms are
22:36:09 <nisstyre> erisco: are sets knowledge?
22:36:13 <trigone> mniip: expand?
22:36:33 <trigone> mniip: maybe he communicates infinitely but it's just not perceptible
22:36:38 <mniip> trigone, explain in more detail what you'd like to know about
22:37:18 <nisstyre> erisco: you should read some early Russell (1900s - 1930s) it's actually awesome stuff
22:37:26 <mniip> trigone, I suppose you could claim there are infinite wavelengths of sound or something but that doesn't uphold up to quantum level
22:37:49 <trigone> mniip: well i don't really want to bother if nobody knows a thing about the topic you see :P can i assume you do know about it? (cos the last time someone forced me to describe my problem, they didn't help me at all)
22:38:07 <mniip> well
22:38:30 <mniip> I have a rough guess at what tagless refers to there but otherwise no idea what the phrase even means
22:38:38 <nisstyre> I wish I could resurrect Bertrand Russell and teach him Haskell
22:39:10 <trigone> mniip: that's not taking into account rotten bananas, you know... it's funny how such names lend weight to the idea that haskell is sorcery, writing weird potion recipes out of disgusting thing :P
22:39:20 <mauke> it's an oleg paper
22:39:31 <trigone> mniip: well if you're interested http://okmij.org/ftp/tagless-final/course/lecture.pdf
22:39:49 <nisstyre> trigone: scheme has things like metacircular evaluators and books with wizards casting spells on them
22:40:20 <nisstyre> I think that's where the whole "FP is magic" meme came from
22:40:58 <trigone> but then i guess you can't help me... i'm trying to know how you define a DSL in function of another with this method (every example i've found does not make mention of chains of interpreters)
22:41:10 <trigone> nisstyre: couldn't tell,  i don't know scheme
22:41:48 <nisstyre> trigone: the cover of SICP has a wizard on it
22:41:58 <mniip> argh
22:41:59 <nisstyre> https://upload.wikimedia.org/wikipedia/commons/9/9d/SICP_cover.jpg
22:42:16 <mniip> group theory
22:42:17 <trigone> yeah, and we have a dungbeetle --yay :P
22:43:04 <nisstyre> trigone: and no funny names like Alyass P. Hacker
22:43:10 <trigone> that's a wizard? i'd have thought he were some old-time cosmologist or something
22:43:11 <nisstyre> *Alyssa
22:43:22 <nisstyre> trigone: hmm well maybe
22:43:29 <trigone> nisstyre: who's that?
22:43:38 <nisstyre> trigone: a fake name used in the book
22:43:58 <nisstyre> also "Eva Lu Ator"
22:44:11 <nisstyre> https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs#Characters
22:44:21 <monochrom> haha Evaluator
22:44:33 <trigone> nisstyre: the author must be edwardk's sibling
22:44:48 <trigone> but i didn't get the Alyssa P. Hacker one
22:44:57 <nisstyre> Lisp Hacker
22:45:04 <nisstyre> A Lisp Hacker
22:45:06 <trigone> oooh
22:45:15 <monochrom> haha neat
22:45:22 <trigone> that's not strictly equivalent phonetically :P
22:45:28 <nisstyre> almost
22:45:41 <trigone> wouldn't it be Alice P. Hacker instead?
22:45:56 <trigone> mauke: if you know the paper, do you know how to write an interpreter in terms of another?
22:46:03 <trigone> (another language/class)
22:46:52 <mauke> trigone: no, and I don't know what you mean
22:48:35 <trigone> oh well then nevermind... in the tagless final style, languages are classes, interpreters are instances + a monomorphic identity function to select the type. basically i'm trying to define an instance of a class in terms of another class, without losing any polymorphism.
22:50:08 <trigone> it's not very simple, i have had to switch to type families because fundep was lagging, and then i'm still stuck with the "too small head" problem with ghci trying to make me enable undecidableinstances (i assume the purpose is so it can take over the world and write the Matrix)
22:52:06 <trigone> in theory my problem is only about haskell's type system, but in practice i'm a bit surprised to hit so hard a wall trying to apply this method of DSL embedding...
22:52:44 <trigone> in case anyone wants a try at my problem of class instanciation: http://lpaste.net/2650337298029215744
22:56:50 <mniip> where the hell does the "functions onto" notation come from
22:56:53 <glguy> trigone: The thing you're trying to do just isn't going to work
22:56:58 <mniip> is it a US thing?
22:57:25 <glguy> trigone: You write instances for particular types
22:57:53 <Ferdin> hailstoneSeq :: Integer -> [Integer] hailstoneSeq 1 = [1] hailstoneSeq n = n : hailstoneSeq (hailstone n)  I don't know hailstone come from where
22:58:01 <Ferdin> it can't compile
22:58:37 <glguy> You can have,  envAddWithEnv :: Op e => Env e m => e -> m e; envAddWithEnv = ask >>= pure . add n
22:58:47 <mniip> Ferdin, where'd you get that code from
22:58:55 <glguy> and then you can use that as the implementation for any instance that you want to be based on those classes
22:59:36 <glguy> Ferdin: If you have questions about specific code, put that code on a pastebin like http://lpaste.net . If you have specific errors, include them in the paste
23:00:01 <Ferdin> mniip, url:http://www.cis.upenn.edu/~cis194/spring13/lectures/01-intro.html
23:00:13 <Ferdin> ok thanks
23:00:40 <mniip> Ferdin, from 2 paragraphs above
23:00:42 <Ferdin> I'm new to here :) sorry for boring you...
23:01:33 <trigone> mniip: function onto?
23:01:37 <mniip> Ferdin, might wanna check out #haskell-beginners for a more beginner-friendly experience
23:01:38 <mauke> trigone: 「>>= pure .」 is fmap
23:01:40 <mniip> trigone, yes
23:01:48 <mniip> frankly I've never understood what that means
23:02:24 <mniip> I know my surjections and epimorphisms
23:02:34 <mac10688> https://stackoverflow.com/questions/46010959/get-mysqlvalue-by-column-name-using-mysql-haskell
23:02:42 <mac10688> if anyone can help me with this, I would appreciate it
23:02:49 <trigone> mauke: lol yes i hadn't noticed, it's bc i changed the code, originally add was a kleisli arrow
23:02:57 <Ferdin> thanks mniip, I will go there.
23:03:29 <glguy> Ferdin: Beginner questions are quite welcome here, and more likely to be seen as this channel is more active
23:04:18 <glguy> Ferdin: The definition of hailstone can be found further up on that page
23:05:18 <trigone> glguy: yes, you mean use simple functions instead of typeclasses... that's actually a good idea, i hadn't thought of it. in that way however, there's no way to write an expression simply in function of the first language regardless of its translation... esp i can't forbid an expression with mix between those functions and the remaining Op/Env classes, can i?
23:06:18 * hackagebot uri-templater 0.3.1.0 – Parsing & Quasiquoting for RFC 6570 URI Templates – https://hackage.haskell.org/package/uri-templater
23:06:23 <trigone> mniip: in what context did you read "function onto"? function onto numbers?
23:06:38 <trigone> (for example)
23:07:42 <mniip> trigone, http://tcpst.net/6het.png
23:09:02 <mauke> er, huh? it says what it means
23:09:49 <mauke> a function "onto" a set S covers all of it; it is surjective
23:10:26 <mauke> whereas a function "(in)to" doesn't necessarily
23:10:31 <erisco> monic in C... lol
23:10:50 <trigone> mauke: oh didn't know, good to know
23:11:10 <erisco> so how long until a researcher invents moronic functions
23:12:02 <mauke> de-monic arrows
23:12:08 <mniip> mauke, that's a weird piece of terminology
23:12:12 <mniip> I mean
23:12:25 <mniip> how does that even work linguistically
23:12:35 <mniip> you can't just leave a preposition hanging
23:13:17 <mauke> note that I said "onto a set S" :-)
23:13:40 <mniip> yes but mac lane used "the functions onto."
23:14:06 <mac10688> someone say my name?
23:14:08 <mauke> that's a shorthand
23:14:33 * mauke tries to find another example
23:15:28 <mniip> "one-one into" weirds me out as well
23:16:28 <trigone> mniip: regarding dangling prepositions, i don't see the problem which you're talking *about*.
23:16:54 <mniip> 'about' refers to 'the problem' here
23:17:13 <trigone> yeah i was kidding, i know it's not the same thing.
23:17:23 <mauke> that's just weird word order
23:17:47 <mniip> mauke, that's the thing, I don't know any single example where a preposition has no subordinate
23:17:55 <mniip> except for occasionally seeing "one-one into" and "onto"
23:18:05 <mauke> here we have "the functions onto S (for some set S)" shortened to "the functions onto"
23:18:30 <trigone> mind you, when you read that maitre d' was a proper english expression...
23:18:39 <trigone> *is
23:18:46 <mniip> mauke, yet that's not common practice in english
23:19:09 <mniip> you always put 'some thing' if that's what you want to express
23:19:20 <mauke> I think it is common practice
23:19:25 <trigone> mniip: if it follows the story of the word takeover, we'll soon read of functionontoes
23:20:00 <mniip> mauke, where are the examples?
23:20:25 <mauke> "functions onto" is a fixed part, "S" is variable
23:20:41 <insitu> hello, how can I run mutually dependent effects (from freer package) ? The best I could do is http://lpaste.net/358155 and this is cheating
23:20:42 <mauke> so "functions onto" becomes a thing of itself
23:21:48 <mniip> mauke, I can come up with a lot more examples where the opposite happens
23:24:11 <mauke> we can hold a vote
23:24:14 <mauke> the people against can leave
23:24:35 <mniip> what does it mean to be isomorphic under something
23:25:55 <trigone> glguy: your solution to my problem doesn't allow preventing a mix between languages, does it? just to check
23:27:32 <trigone> two function-ontoes enter a bar...
23:28:39 <mniip> sounds epic
23:35:23 <mniip> I don't even http://tcpst.net/vgc1.png
23:37:27 <erisco> permutation h, eh… I wonder if a researcher has ever called a preposition h before
23:39:07 <trigone> it's funny how the hint is in parentheses and takes up 5/6 of the section
23:39:41 <mniip> it's funny how I have still no idea what is going on there
23:41:48 <xzhu> I'm thinking of switching to https://www.stackage.org/lts-9.2/package/foundation-0.0.13
23:41:51 <xzhu> looks much cleaner
23:42:10 <xzhu> one questions how am I supposed to use packages like containers?
23:42:53 <xzhu> I noticed that there's a "Collection" class https://www.stackage.org/haddock/lts-9.2/foundation-0.0.13/Foundation.html#t:Collection
23:42:54 <cocreature> using a custom prelude doesn’t prevent you from using some other package like containers
23:42:57 <cocreature> just depend on it and import it
23:43:38 <xzhu> I got that. I guess my question is how to fit containers into Foundation's scheme
23:44:09 <trigone> is there a class for boolean operations?
23:44:26 <erisco> trigone, which ones?
23:44:27 <xzhu> It seems that it has a "Collection" class, which seems to be designed for things like Map or Set
23:44:50 <trigone> erisco: && || ... the usual
23:45:03 <cocreature> xzhu: Collection might be for Set but I don’t see how Map fits into that.
23:45:12 <cocreature> xzhu: there is a KeyedCollection class for things like Map
23:45:15 <trigone> maybe xor for rainy days
23:45:37 <erisco> trigone, && and || both form Monoids
23:46:05 <mniip> xor is a monoid too
23:46:10 * jared-w was about to ask 'over what' until his brain kicked in and replied 'booleans, dumbass'
23:46:17 <trigone> yay good for them, but that's really not what i asked
23:46:40 <mniip> you want a Num-like class for boolean algebra?
23:46:59 <trigone> well yeah, a class defining polymorphically the usual boolean operations
23:47:07 <mniip> sadly none that I know of
23:47:08 <jared-w> How would that even work? "This list is a boolean if you squint at it hard enough" ?
23:47:17 <mniip> had to define one once for symbolic booleans
23:47:17 <xzhu> cocreature: Should I write a instance of KeyedCollection for Map in order to use it in Foundation?
23:47:42 <cocreature> xzhu: if you insists on using that typeclass sure, personally I would just use the API provided by containers
23:47:44 <xzhu> cocreature: I guess I meant "to use it as the author meant"
23:47:44 <erisco> trigone, but that is just it, you can use an algebraic structure which agrees with the boolean operations you're interested in
23:48:00 <cocreature> but then again I’m also not a big fan of foundation so I’m probably not the right person to answer this question :)
23:48:12 <erisco> trigone, Monoid is a type class, you know, as are other algebraic structures such as Group
23:48:14 <trigone> jared-w: so we eject the num class because lists can't be squinted into being numbers?
23:48:54 <trigone> erisco: i want to be able to define custom booleans and use && and || over them. i don't see the connection with monoids
23:49:09 <erisco> trigone,  true, ||, and not  form a  Group
23:49:28 <trigone> mniip: symbolic booleans?
23:49:29 <erisco> whoops, that's not right
23:49:59 <trigone> erisco: good for true and ||, but i couldn't care less
23:50:01 <erisco> trigone, yes, that is exactly what you can do with an algebraic structure
23:50:08 <erisco> trigone, you're asking for something exactly analogous to this
23:50:12 <mniip> trigone, yeah
23:50:16 <mniip> symbolic boolean algebra
23:50:17 <xzhu> cocreature: ok  ... I kind of hate duplicated function names, they look very ugly and redundant
23:50:41 <trigone> erisco: still, i can't use && and ||
23:50:43 <xzhu> cocreature: here is an example: a program I wrote yesterday for a Exercism problem
23:50:47 <xzhu> http://lpaste.net/358156
23:51:04 <trigone> just because i write a group or monoid instance for a custom type, haskell won't recognize it as valid boolean-like thing
23:51:07 <xzhu> I hate I have to prefix everything by T.
23:51:15 <erisco> trigone, are you saying you want to use those particular names?
23:51:55 <mniip> xzhu, that's how everyone does it buddy
23:52:01 <trigone> erisco: well yeah... might as well since they exist. if they were class methods that is (which was my original question)
23:52:18 <erisco> trigone, && and || in Prelude are just defined on Bool, so you cannot generalise those, but it is trivial to just not import these
23:52:21 <mniip> xzhu, especially after you have Map, Set, List, Text, ByteString all in scope simultaneously
23:52:36 <mniip> there's like 10 'singleton's throughout the basic packages
23:52:52 <erisco> trigone, and the way to define a type class for && and || and so on is as an algebraic structure
23:53:05 <erisco> though I do not know which Bool falls into off hand
23:53:18 <xzhu> mniip: Which is exactly why the author of Foundation sought to solve this non-sense
23:53:43 <mniip> exactly how many type families are we talking about
23:53:51 <trigone> erisco: well i thought it was called a boolean algebra...
23:54:28 <erisco> trigone, the algebraic structures are abstract. I don't know the abstract structure of booleans off hand
23:54:49 <xzhu> mniip: If two data-structures share the same APIs, there should be a type class ... that what type classes are for isn't it
23:55:02 <trigone> erisco: oh you mean like a group, ring, etc
23:55:18 <mniip> xzhu, but they're different apis
23:55:22 <erisco> "In abstract algebra, a Boolean algebra or Boolean lattice is a complemented distributive lattice." https://en.wikipedia.org/wiki/Boolean_algebra_%28structure%29
23:55:39 <trigone> oh well good to know
23:55:53 <erisco> well I know a bit about lattices but not complemented distributive ones particularly
23:56:00 <mniip> xzhu, the quantification on BS.singleton is different from that on M.singleton
23:56:15 <trigone> mind you if i write my own boolean class i probably won't bother with calling it ComplementedDistributiveLattice
23:56:22 <mniip> hence my question about type families
23:56:32 <erisco> https://en.wikipedia.org/wiki/Boolean_ring
23:56:48 <mniip> trigone, BidistributiveRing
23:57:13 <erisco> ring gives you what… ||, &&, not
23:57:31 <trigone> there's a ring class?
23:58:26 <mniip> erisco, it wouldn't be a ring with both
23:58:34 <mniip> you either take &&,xor or ||,xor
23:58:52 <erisco> mniip, why not?
23:59:14 <erisco> I didn't go through all the laws
23:59:37 <erisco> "Every Boolean ring gives rise to a Boolean algebra, with ring multiplication corresponding to conjunction or meet ∧, and ring addition to exclusive disjunction or symmetric difference (not disjunction ∨, which would constitute a semiring)." https://en.wikipedia.org/wiki/Boolean_ring
23:59:47 <erisco> well that's annoying
