00:01:15 <[exa]> (it seems to me that the output forest actually is ordered topologically, but there's no such thing in docs
00:01:36 <digitalkiwi> is there a good curses or similar lib ?
00:02:41 <[exa]> digitalkiwi: there's ncurses binding, but there's also something lot better (lemme find it)
00:03:32 <peddie> @hackage brick  -- [exa], this one?
00:03:33 <lambdabot> http://hackage.haskell.org/package/brick  -- [exa], this one?
00:05:02 <[exa]> yeah exactly that
00:06:13 <[exa]> the name is a curse, I was searching for "block" and "slab"
00:07:51 <digitalkiwi> thank you
00:08:52 * hackagebot colorless 0.0.1 – Colorless – https://hackage.haskell.org/package/colorless
00:37:28 <drdo> Hmm, I'm getting some unknown assembler pseudo-op error message during a sanity check when running "stack setup"
00:51:49 * hackagebot accelerate-fft 1.1.0.0 – FFT using the Accelerate library – https://hackage.haskell.org/package/accelerate-fft
01:09:13 <ertes-w> ello
01:22:00 <Athas> Nice, new Accelerate packages.
02:00:36 <norc_> instance [safe] Monad m => Monad (StateT s m)  -- does this mean that StateT gives me exactly then a monad, if m is a monad?
02:01:09 <norc_> Or rather *iff I guess
02:01:44 <cocreature> norc_: yes
02:02:41 <norc_> cocreature: Great thanks.
02:44:13 <jd823592> fg
02:47:11 * hackagebot accelerate-blas 0.1.0.0 – Numeric Linear Algebra in Accelerate – https://hackage.haskell.org/package/accelerate-blas
03:24:18 <Sornaensis> bleep bloop
03:38:48 * hackagebot accelerate-examples 1.1.0.0 – Examples using the Accelerate library – https://hackage.haskell.org/package/accelerate-examples
03:51:23 <maerwald> is there a deduplication class?
03:51:41 <maerwald> if that even makes sense lol
03:51:57 <maerwald> like a Monoid without duplicates
03:53:17 <pacak> Set?
03:54:59 <maerwald> that's a data type
03:57:01 <pacak> Typeclass would be Ord in this case, set is a way of constructing Monoid.
03:58:03 <maerwald> I don't see how Ord is required here
03:58:16 <maerwald> I guess I can just make my Monoid instance duplicate-free, shouldn't violate any laws
04:04:23 <sjsyrek> I made a repo to help people start their own Haskell study group: https://github.com/sjsyrek/haskell-study-startup
04:05:40 <fakenullie> Why is it a good idea to learn haskell?
04:06:39 <maerwald> no idea
04:07:39 * hackagebot fswatch 0.1.0.2 – File System watching tool with cli and slave functionalities. – https://hackage.haskell.org/package/fswatch
04:08:20 <fakenullie> https://www.quora.com/Should-I-learn-Haskell
04:08:40 <maerwald> that's a weird question
04:09:06 <maerwald> you could literally ask "should I learn <x>" and you will always get people saying "Yes"
04:09:38 <fakenullie> well, they have some arguments there
04:10:03 <maerwald> well, it's Quora, mostly bad question
04:11:10 <maerwald> if you want to learn cooking and someone told you to learn haskell first, then the answer is "No"
04:11:47 <maerwald> you should say something about your goals or expectations, otherwise you will just get advertisement answers
04:18:13 <sjsyrek> Because Haskell is an awesome programming language?
04:18:21 <maerwald> cooking is also awesome
04:18:29 <sjsyrek> You should learn cooking AND Haskell
04:18:37 <ongy> food is awesome, cooking is mostly boring if done alone
04:18:38 <maerwald> that's assuming he has the time for both
04:18:49 <maerwald> which is why these questions are so pointless
04:18:57 <sjsyrek> Cooking while listening to podcasts is awesome
04:19:00 <maerwald> if he has time for everything, he should just learn everything
04:19:06 <ongy> buy some microcontrollers and teach them cooking with haskell
04:19:28 <sjsyrek> I think the question was meant to troll me because my repo's README starts off with "Learning Haskell is a good idea."
04:20:00 <maerwald> learning haskell is a rather huge commitment, he might as well read Kafka instead and I wouldn't want to say what is a better way to spend his time
04:20:11 <sjsyrek> What he should have asked me is why I start my sentence with a dangling participle
04:20:40 <sjsyrek> I could change it to "So you've decided to learn Haskell. Good for you."
04:21:24 <fakenullie> I expected some explanation of why is it a good idea
04:21:52 <sjsyrek> I'm not here to convince you. That repo is for people who are already convinced.
04:21:59 <fakenullie> not to troll, I'm still not sure why I'm learning it
04:22:36 <sjsyrek> You must find your own path to enlightenment in that case
04:22:41 <fakenullie> heh
04:22:48 <sjsyrek> I have nothing original to say on the subject
04:23:04 <maerwald> do whatever you want, don't have other people tell you what to do with your time :P
04:23:49 <maerwald> I would still go with cooking though
04:24:15 <codrinb_> \q
04:30:07 <[exa]> any convenient function to unzip triples?
04:30:35 <[exa]> ....unzip3. Strange how asking on IRC causes google to suddenly start returning relevant stuff
04:30:45 <fakenullie> rubber duck debugging
04:36:24 * hackagebot panhandle 0.3.0.0 – Pandoc filter to unwrap nested blocks – https://hackage.haskell.org/package/panhandle
04:46:40 <JazzyEagle> Wondering if someone can help.  Unable to link my Haskell program any longer after a system upgrade where I had change from gcc-multilib to gcc:  http://lpaste.net/9092109577066905600
04:46:58 <JazzyEagle> I reinstalled gcc-multilib this morning, hoping it would get rid of the error, and no dice.
04:49:09 <JazzyEagle> Hrm...  Google searches seem to yield it might be a security right thing on my /tmp directory...
04:50:19 <JazzyEagle>  My /tmp directory is drwxrwxrwt   Shouldn't that be enough?
04:52:59 <fakenullie> JazzyEagle: what's in the /share/programs/ccradio/.stack-work/logs/network-2.6.3.2.log ?
04:54:24 <JazzyEagle> fakenullie: Lines #16 - 30 of the lpaste are what's in the network-2.6.3.2.log file.  It doesn't provide any further information.
04:54:42 <cocreature> maybe try "stack setup --reinstall"
04:54:46 <JazzyEagle> old-time's log reflects lines #37 - 48
04:55:16 <JazzyEagle> Trying that now, cocreature.
04:57:38 <JazzyEagle> cocreature: No good.  I did stack setup --reinstall, stack clean, and then stack build
04:57:58 <JazzyEagle> Same errors.
05:00:26 <fakenullie> JazzyEagle: can find config.log mentioned there?
05:03:14 <JazzyEagle> akemot: I'm looking for it, but I'm not finding it anywhere.  Not in .stack-work/, not in /tmp, not hidden in my program directory...
05:03:49 <fakenullie> JazzyEagle: does /tmp/stack14894/network-2.6.3.2 exist after build?
05:03:55 <JazzyEagle> No.
05:05:38 <JazzyEagle> I just remembered...  -verbose.  Let's see what stack build says now...
05:10:02 <JazzyEagle> Nothing helpful.
05:11:38 <JazzyEagle> I just remembered..  I also bumped my lts version yesterday.  I wonder if I bump it back to what it was (from 9.5 to 8.21)
05:13:06 <nvd> Is there a "proper" way to run an IO action every n seconds? I'd like something like NominalDiffTime -> IO () -> IO ()
05:13:38 <hpc> nvd: you could probably write something simple with threadDelay and forever
05:14:09 <hpc> nvd: it depends on how long the action is and how much time you want between them, and how precise it needs to be
05:14:15 <nvd> hpc: threadDelay isn't guaranteed to run promptly
05:14:32 <hpc> nothing ever is ;)
05:14:33 <nvd> I've been using that, and it seems to be experiencing occasional pauses that are frustrating
05:14:39 <hpc> ah
05:14:45 <hpc> not sure then
05:16:05 <lyxia> gc pauses perhaps?
05:16:29 <nvd> lyxia: it's concievable
05:16:43 <nvd> I haven't managed to profile this - the way it's running that would be a little awkward
05:16:57 <hpc> depending on how real-time you need it to be, it's possible that haskell isn't the right language for it either
05:17:08 <hpc> you're never able to completely eliminate the unpredictability of gc
05:18:26 <boj> Cale: ping
05:18:27 <lyxia> I'm not sure it's significant if you are looking for latency on the order of seconds
05:18:33 <nvd> We're pretty tied into using Haskell for this, sadly, it'd be tricky to switch
05:18:51 <nvd> lyxia: I'm trying to go at 17 Hertz
05:19:03 <hpc> how long does the action take?
05:19:22 <hpc> hmm
05:19:23 <nvd> hpc: a lot less than 1/17 of a second
05:20:23 <hpc> i wonder if you could have a spawning thread on a tight loop that runs 17 times a second
05:20:32 <hpc> and all it does is spawn one-off threads for those actions
05:21:35 <nvd> Hmm
05:21:52 <nvd> hpc: I'm not sure how viable that'd be, we'd like to keep these actions in order
05:22:24 <cocreature> nvd: do you have any idea how much your stressing GC? i.e. are large GC pauses a possibility here?
05:23:13 <nvd> cocreature: they definitely are, sadly
05:23:36 <nvd> I'd use ¬Haskell, but Haskell is perfect for damn near everything else in this program
05:23:36 <boj> nvd: mild curiosity, but what are you writing? i had a real-time game server running at 60hz with no pauses, although i did do a lot of profiling and tuning to get it there
05:24:11 <cocreature> nvd: what kind of actions are we talking about here? can you maybe move only that part to a separate non-haskell process?
05:24:12 <nvd> boj: program reads an image file from disk, does some processing, shoves it down a websocket, 17 times a second
05:24:19 <hexagoxel> nvd: what exactly is your concern? drift over longer periods or jitter?
05:24:27 <cocreature> there are also various options to tune GC
05:24:28 <nvd> hexagoxel: jitter
05:24:31 <boj> nvd: ok, that sounds expensive
05:24:50 <boj> time to break out the profiler :)
05:24:59 <nvd> boj: the images aren't very large, thankfully
05:33:57 <boj> anyone familiar with writing reflex native apps? does one typically write 100% of the logic in reflex-dom? or make (ws? api?) calls to the native backend for heavy logic?
05:41:52 * boj heads for bed
05:42:01 <saurabhnanda> are there any known solutions of nested records using zippers?
05:43:39 <maerwald> can a cabal dependency depend on multiple flags?
05:43:44 <sphinxo> say I have some data A = A Int and I want Ord to be implemented for it
05:44:27 <sphinxo> I want to use the normal derive Ord, except apply a function to it before comparing
05:45:01 <sphinxo> I can't exactly do a `compare` b = (normalize a) `compare` (normalize b)
05:45:49 <hexagoxel> saurabhnanda: "scrap your zippers"
05:45:50 <sphinxo> And as my A is a record with many fields
05:46:04 <sphinxo> I don't want to deconstruct it and apply compare to each one
05:47:19 <saurabhnanda> sphinxo: I *think* you should be able to derive Generic and use gOrd to do what you want to do.
05:48:06 <sphinxo> where's gOrd from?
05:48:08 <fakenullie> nvd: can you force garbage collection after handling after performing an action?
05:48:29 <saurabhnanda> sphinxo: sorry. there is a gEq, but not gOrd at https://hackage.haskell.org/package/generic-deriving-1.11.2/docs/doc-index-All.html
05:49:17 <phadej> there is makeCompare in http://hackage.haskell.org/package/deriving-compat-0.3.6/docs/Data-Ord-Deriving.html
05:49:44 <phadej> so you can do `compare = $(makeCompare ''A) `on` normalise
05:50:27 <sphinxo> ah thanks
06:08:00 <merijn> Any tips on tests including speedup? I wanna test that operation A has the same result as operation B in *roughly* fraction 1/n of the time. But I'm not sure how much slack to give for not completely accurate timings
06:16:48 <Itkovian> criterion?
06:17:30 <Itkovian> typically, for comparing speedups, you need to have a bunch of datapoints for both cases and then use the following formula, sec.
06:19:38 <merijn> Itkovian: Naah, criterion is way to be slow due to trying to be accurate
06:19:53 <Itkovian> merijn http://tomcat.elis.ugent.be/static/elisall/publ/doc.php?file=D108_163.pdf see p 124 :)
06:20:18 <Itkovian> how fast is op A?
06:20:54 <merijn> Itkovian: Seconds
06:21:11 <merijn> Itkovian: I'm just trying to hack a simple test to catch obvious future regressions
06:21:20 <Itkovian> you'll need a bunch of measurements regardless :)
06:21:21 <merijn> Not anything that pretends to be accurate
06:21:40 <merijn> Naah, I really don't
06:22:02 <Itkovian> at least one, right?
06:23:04 <lyxia> sphinxo: why can't you do   a `compare` b = (normalize a) `compare` (normalize b)
06:23:38 <merijn> Itkovian: I'm running A and B once at the moment and I know that B should *roughly* be 1/n * A, I'm just trying to guesstimate what percentage of total runtime would be a realistic amount of slack to include in that comparison
06:23:43 <lyxia> ah, normalize :: A -> A ?
06:24:15 <Itkovian> hmm
06:25:15 * hackagebot forest-fire 0.1.0.0 – Recursively delete CloudFormation stacks and their dependants – https://hackage.haskell.org/package/forest-fire
06:25:54 <merijn> Unrelatedly, is there a tool that warns me about missing/redundant Other-Extensions in my cabal file?
06:27:07 <ertes-w> merijn: grep + `sort -u` + comm
06:27:42 <ertes-w> well, probably need a bit more than 'grep' to extract the extensions
06:36:22 <AWizzArd> Is there some kind of remote repl available? I would like to edit Haskell code via Emacs on my Android phone, but have the actual stack/ghc/ghci running on a remote server.
06:36:58 <merijn> AWizzArd: Sure. It's called SSH ;)
06:37:02 <mnoonan> you could do IHaskell + ein-mode
06:37:35 <ertes-w> AWizzArd: emacs lets you edit via SSH: use the following path syntax:  /[USER@]HOST:/path/to/file
06:37:48 <ertes-w> as for the remote REPL: SSH
06:38:12 <ertes-w> kinda curious how you got GHCi working on android though =)
06:39:12 * hackagebot forest-fire 0.1.0.1 – Recursively delete CloudFormation stacks and their dependants – https://hackage.haskell.org/package/forest-fire
06:40:09 <fakenullie> heh
06:40:44 <AWizzArd> ertes-w: I don’t have ghc/ghci on Android. I want to use Android via a docking station (2 FullHD screens, keyboard, 6 GB RAM, Octacore) just for editing. I want to make it look mostly as if I was running ghc/ghci locally.
06:41:09 <tdammers> still think ssh is your best bet there
06:41:23 <AWizzArd> ssh/mosh I have.
06:42:09 <ertes-w> you'll need a wrapper script, if you want to integrate GHCi into your emacs
06:42:17 <ertes-w> e.g. via haskell-mode
06:42:35 <ertes-w> i can't imagine that to be a smooth development experience though
06:42:53 <texasmynsted> How do I assign a type to Nothing.  Like I want a Nothing of type Maybe Int
06:43:30 <ertes-w> texasmynsted: (Nothing :: Maybe Int)
06:44:54 <texasmynsted> hmme Non type-variable argument in the constraint: Num (Int -> b)
06:45:13 <texasmynsted> want to see the result of 
06:45:15 <texasmynsted> (+) <$> Just 2 <*> Just 3 <*> (Nothing :: Maybe Int)
06:45:38 <mnoonan> (+) only takes 2 arguments, but you're giving 3
06:45:45 * texasmynsted facepalm
06:46:47 <byorgey> > let add3 x y z = x + y + z  in   add3 <$> Just 2 <*> Just 3 <*> Nothing    -- the type signature on Nothing is actually not needed
06:46:49 <lambdabot>  Nothing
06:47:26 <texasmynsted> ghci would not let me do that
06:47:39 <texasmynsted> So here is the question.
06:48:23 <texasmynsted> I would like to take [(Just 2), (Just 3), (Nothing)] and get a result of Just 5
06:48:49 <texasmynsted> There has to be an idiom for this
06:48:52 <nvd> :t catMaybes
06:48:53 <lambdabot> [Maybe a] -> [a]
06:48:56 <byorgey> sum . catMaybes
06:49:06 <ongy> > foldr (liftA2 (+)) 0 . catMaybes $ [(Just 2), (Just 3), (Nothing)]
06:49:07 <nvd> > sum . catMaybes $ [Just 2, Just 3, Nothing]
06:49:08 <lambdabot>  error:
06:49:08 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M651407211142...
06:49:08 <lambdabot>        prevents the constraint ‘(Show (f0 Integer))’ from being solved.
06:49:09 <lambdabot>  5
06:49:11 <texasmynsted> catMaybes?
06:49:18 <nvd> texasmynsted: it's in Data.Maybe
06:49:38 <byorgey> ongy: after catMaybes, they aren't Maybes anymore
06:49:41 <texasmynsted> I guess I need to learn to find things in the docs better
06:49:49 <nvd> nvd: its type is [Maybe a] -> [a], so catMaybes [Just 2, Just 3, Nothing] == [2, 3]
06:49:49 <byorgey> so you don't need to liftA2 (+), you can just sum
06:49:55 <ongy> ohh, right
06:50:05 <nvd> texasmynsted: ^^^
06:50:21 <texasmynsted> :t liftA2
06:50:22 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
06:50:38 <byorgey> texasmynsted: liftA2 f x y == f <$> x <*> y
06:50:49 <ertes-w> > sumOf (traverse . _Just) [Just 3, Just 4, Nothing]
06:50:51 <lambdabot>  7
06:51:05 <ertes-w> > sumOf (traverse . traverse) [Just 3, Just 4, Nothing]
06:51:07 <lambdabot>  7
06:51:08 <texasmynsted> :t _Just
06:51:10 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Maybe a) (f (Maybe b))
06:51:29 <ongy> :t sumOf
06:51:29 <ertes-w> texasmynsted: ignore me, unless you want to enter a deeeeeeep rabbit hole
06:51:30 <lambdabot> Num a => Getting (Endo (Endo a)) s a -> s -> a
06:51:38 <nvd> texasmynsted: ertes-w is using the sledgehammer that is lens to solve this pretty simple problem
06:51:42 <ongy> I don't even want to know
06:51:54 <texasmynsted> ah
06:52:02 <nvd> > sumOf (folded.folded) [Just 3, Just 4, Nothing]
06:52:04 <lambdabot>  7
06:52:05 <texasmynsted> Use lenses in scala.
06:52:09 <texasmynsted> like them
06:52:38 <nvd> I don't know what they're like in Scala, but there's been a lot of work with them in Haskell
06:53:59 <texasmynsted> why is there traverse composed with traverse?
06:54:11 <mnoonan> one traverses the lists, the other traverses the Justs
06:54:24 <ertes-w> does scala have type classes?
06:54:25 <texasmynsted> :-)
06:54:41 <texasmynsted> ertes-w: not exactly
06:54:43 <ertes-w> kinda surprised that they have van laarhoven lenses, too…  or do they?
06:55:07 <ongy> :t traverse
06:55:09 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
06:55:16 <texasmynsted> Like everything in scala it is part illusion/magic and part reality 
06:55:48 <ertes-w> van laarhoven lenses as those from the 'lens' library build on some type-level machinery to be as flexible as they are
06:55:49 <texasmynsted> http://julien-truffaut.github.io/Monocle/
06:55:57 <ertes-w> yeah, i found that one
06:56:17 <ertes-w> *looks* like they're trying to do full van laarhoven lenses
06:56:39 <texasmynsted> It is pretty nice
06:57:00 <texasmynsted> :sumOf
06:57:05 <texasmynsted> :t sumOf
06:57:06 <lambdabot> Num a => Getting (Endo (Endo a)) s a -> s -> a
07:02:51 <texasmynsted> hmm so all this was to get to what I really want to do which is 
07:03:26 <texasmynsted> [Just "abc", Just "def", Nothing] to Just "abcdef"
07:03:47 <merijn> That's way easier
07:03:57 <merijn> > mconcat [Just "abc", Just "def", Nothing]
07:03:57 <texasmynsted> :i sumOf
07:03:59 <lambdabot>  Just "abcdef"
07:04:08 <merijn> @quote beaky monoids
07:04:08 <lambdabot> beaky says: i love monoids / they are so easy
07:04:13 <texasmynsted> :t mconcat
07:04:15 <lambdabot> Monoid a => [a] -> a
07:04:19 <merijn> Screw all that lens nonsense
07:04:30 <beaky> yes i still love monoids
07:05:07 <texasmynsted> very nice
07:05:22 <merijn> texasmynsted: mconcat just mappends everything in a list. "instance Monoid a => Monoid (Maybe a)" just mappends the contents of Maybe and ignores Nothing, and mappend of string concats them
07:05:51 <Psybur> > mconcat [Nothing, Just "bruh"]
07:05:53 <lambdabot>  Just "bruh"
07:06:14 <merijn> Psybur: Basically it treats Nothing as identical to "Just mempty"
07:07:38 <texasmynsted> ohhh. 
07:07:42 <texasmynsted> so foldr mappend mempty
07:08:05 <merijn> texasmynsted: yeah
07:08:14 <texasmynsted> :-)
07:08:29 <codedmart> I am trying to install stack in a fresh ubuntu 16.04 and when I run the curl cmd I see this? `curl: (77) Problem with the SSL CA cert (path? access rights?)`
07:08:42 <merijn> mconcat gets even cooler when you realise you can use the monoid on functions to use it to turn lists of functions into a single one :)
07:08:56 <texasmynsted> codedmart: looks like the ssl cert for the site is expired or you do not have the CA
07:09:37 <texasmynsted> merijn: wow
07:09:45 <texasmynsted> I would like to see an example of that
07:09:47 <texasmynsted> hehe
07:09:53 <Alovenom> Manjaro dropped me again...
07:10:03 <Alovenom> I am going to change distros
07:10:17 <Alovenom> Do you guys have recommendations ?
07:10:33 <codedmart> texasmynsted: How can I work around that?
07:10:33 <merijn> texasmynsted: Right, so we have "Monoid m => Monoid (a -> m)", that is, any function that returns a monoid is itself a monoid
07:11:09 <merijn> texasmynsted: With "mappend f g = \x -> mappend (f x) (g x)", yes?
07:11:54 <texasmynsted> codedmart: how are you installing stack?  Like are you executing curl yourself or some other way?
07:12:25 <codedmart> texasmynsted: The script cmd from the site `curl -sSL https://get.haskellstack.org/ | sh`
07:12:50 <merijn> texasmynsted: Now, recall how "a -> b -> c" is basically "a -> (b -> c)". So if 'c' is a Monoid, then according to our function instance for monoid, so is "b -> c". But if "b -> c" is a monoid, then our monoid instance says that "a -> (b -> c)" is also a monoid!
07:12:56 <codedmart> I guess I could just install from apt and upgrade.
07:13:13 <sphinxo> With some monad transformer stack, any general recomendations on nesting/stacking order? 
07:13:50 <sphinxo> eg ReaderT (ExceptT) 
07:14:01 <IS_DAT_BOI_BOBBY> >
07:14:19 <IS_DAT_BOI_BOBBY> >grep
07:15:01 <merijn> texasmynsted: So, suppose we have "[a -> b -> Any]" (Any being a newtype for Bool that implements the monoid that performs (||)), we can use mconcat on it and we'll get "mconcat :: [a -> b -> Any] -> (a -> b -> Any)" which will pass 'a' and 'b' to each function in the list and OR the results together
07:15:25 <merijn> texasmynsted: Another common example would be using the Monoid on Ordering to implement multi-level ordering
07:15:33 <texasmynsted> codemart, manually download the script open it in an editor and make sure it is safe then execute it manually or point curl to the CA or disable cert checking
07:16:32 <texasmynsted> wow merijn 
07:16:50 <merijn> texasmynsted: It's one of the coolest and most underrated monoids, IMO :)
07:16:52 <texasmynsted> This is why I like haskell
07:17:10 <merijn> and it works for functions of any arity since the function instance is recursive :)
07:17:29 <ertes-w> > (partsOf (traverse . filtered isUpper) %~ reverse) "Junkeh Kried Fitteh Funkeh"
07:17:32 <lambdabot>  "Funkeh Fried Kitteh Junkeh"
07:18:46 <sternmull> Alovenom: I use Arch for at least half a decade and am totally happy with it. I can absolutely recommend for desktop users that want the latest shit and don't fear the commandline.
07:18:49 <ertes-w> or the incomparable classic
07:18:53 <ertes-w> > (partsOf (traverse . filtered isUpper) %~ reverse) "Sony Playstation"
07:18:56 <lambdabot>  "Pony Slaystation"
07:20:24 <merijn> There's no way to have like a "test library" that your tests can reuse in cabal, right?
07:20:54 <ertes-w> merijn: no, but you can share a directory between test suites, so you can at least reuse modules
07:20:54 <Athas> What's the readline comparable for Haskell called again?
07:20:56 <merijn> So if I have shared helpers I just dump them in a single file and that file to the Other-Modules of each test?
07:21:03 <merijn> Athas: Haskeline?
07:21:04 <ertes-w> Athas: haskeline
07:21:15 <merijn> ertes-w: Yeah, that's what I was doing already
07:21:27 <Athas> Thanks!
07:21:36 <Alovenom> sternmull : thanks
07:21:43 <[exa]> oh lord what is %~ ?
07:21:46 <ertes-w> merijn: the only other way i can think of is to mark some modules as "internal"
07:21:54 <ertes-w> [exa]: 'over'
07:22:04 <ertes-w> > over _1 succ (10, 20)
07:22:06 <lambdabot>  (11,20)
07:22:10 <merijn> ertes-w: Naah, then my library would have to start depending on things like HUnit
07:22:12 <[exa]> oh so
07:22:15 <[exa]> ertes-w: thanks
07:22:49 <hexagoxel> merijn: "convenience libraries" in cabal-2
07:24:24 <Alovenom> %~ is awesome
07:25:40 <texasmynsted> :t %~
07:25:41 <lambdabot> error: parse error on input ‘%~’
07:26:52 <texasmynsted> where does partsOf and filtered come from?
07:26:58 <ertes-w> texasmynsted: lens
07:27:04 <texasmynsted> ah nod
07:27:06 <texasmynsted> ok
07:27:56 <IS_DAT_BOI_BOBBY> guys is the @ in front of @chanserv indication that he's a mod or something?
07:28:27 <MarcelineVQ> yeboi
07:28:39 <[exa]> IS_DAT_BOI_BOBBY: mod bot.
07:28:41 <MarcelineVQ> that's a robot though
07:28:54 <IS_DAT_BOI_BOBBY> ahh cool
07:28:56 <IS_DAT_BOI_BOBBY> thanks
07:28:58 <[exa]> IS_DAT_BOI_BOBBY: http://www.ircbeginner.com/opvinfo/opvinfo.html
07:32:57 <shapr> IS_DAT_BOI_BOBBY: are you learning Haskell?
07:39:07 <mekeor> talking about IRC, also check out this talk: https://camp.hsbp.org/2016/pp7e0/fahrplan/events/20.html
07:44:32 * hackagebot forest-fire 0.1.0.2 – Recursively delete CloudFormation stacks and their dependants – https://hackage.haskell.org/package/forest-fire
07:48:11 <shapr> mekeor: oh that looks interesting, does the author question whether slack is eating the oss community?
07:52:43 <mekeor> shapr: not sure if he does so explicitely ;)
08:00:58 <erisco> ChanServ is one of the Freenode deities
08:03:00 <saurabhnanda> in a ghci, what (internal) command can I run to force a GC? The memory usage of GHCi is constantly growing and has crossed 5gigs now!
08:03:01 --- mode: ChanServ set +o erisco
08:03:27 <merijn> Wow...
08:03:40 <erisco> I have ascended
08:03:46 <merijn> Sometimes I question my basic reasoning ability...
08:04:11 --- mode: erisco set -o erisco
08:04:29 <merijn> Spend hours debugging why my semaphore isn't blocking my program from exiting...accidentally initialised it with non-zero value...
08:05:13 <jonge> Hey there, i need something like this: `f :: Maybe a -> Maybe b -> Maybe (a, b)`. But i can't figure out how to do it. any idea?
08:05:25 <merijn> :t liftA2 (,)
08:05:27 <lambdabot> Applicative f => f a -> f b -> f (a, b)
08:05:33 <jonge> wow that was fast.
08:05:43 <merijn> jonge: I'm just that good ;)
08:06:27 <jonge> perfect. thanks merijn
08:06:42 <erisco> would be neat if Hoogle or Hayoo could be strengthened to find liftA2 from that search
08:07:02 <saurabhnanda> is it possible to get GHC stuck in an infinite loop, with the memory constantly growing?
08:07:34 <ventonegro> saurabhnanda: Just keep consing without bounds
08:07:52 <saurabhnanda> ventonegro: no the runtime. The compiler!
08:08:23 <ventonegro> saurabhnanda: Ah, then I'd call it a bug ;)
08:10:00 <shapr> Has anyone tried to parse guitar tabs in Haskell?
08:10:07 <saurabhnanda> how do I know if the compiler is stuck in an infinite loop?
08:10:39 <shapr> sometimes it tells you
08:10:47 <erisco> it will take a long time… I have had this happen with certain extension combinations
08:11:54 <saurabhnanda> is there any way to run the ghc/ghci in a verbose/debug mode?
08:12:03 <erisco> try -v
08:13:16 <Athas> How can Haskeline be used with MTL monad transformers?
08:13:26 <[exa]> shapr: image-recognition way or the text tabs that are made of 99% ----------   ?
08:13:48 <Athas> MonadException is apparently not defined for the mtl transformers.
08:28:21 <mekeor> :t \x y -> pure (,) <$> x <*> y
08:28:23 <lambdabot> Applicative f => f a1 -> f a2 -> f (b -> (a2, b))
08:29:14 <ventonegro> :t \x y -> (,) <$> x <*> y
08:29:16 <lambdabot> Applicative f => f a1 -> f a2 -> f (a1, a2)
08:29:26 <mekeor> ah, oops ^_^"
08:29:41 <ertes-w> :t \x y -> pure (,) <*> x <*> y
08:29:42 <lambdabot> Applicative f => f a1 -> f a2 -> f (a1, a2)
08:30:28 <mekeor> jonge: this is for you ^
08:31:11 <jonge> mekeor: my naive first try was something like (,) <$> a <*> b but then i was not smart enough to get to the right step
08:33:32 <jonge> mekeor: thx this is useful, this way i don't need to include Control.Applicative
08:35:56 <lyxia> Athas: it is defined for the common transformers actually
08:42:05 <pussyslayer> yo
08:47:15 <sphinxo> Why can't I have Config.hs at the top level and Console/Config.hs? (  module ‘main@main:Console.Config’ is defined in multiple files:  )
08:47:38 <sphinxo> I have `module Config where` and `module Console.Config where`
08:52:11 <fakenullie> how can I construct Word32
08:52:23 <fakenullie> from [Word8]
08:52:30 <fakenullie> or ByteString
08:54:32 <ertes-w> fakenullie: the easiest way is to use a library like 'binary'
08:54:39 <fakenullie> okay
08:54:49 <ertes-w> fakenullie: https://hackage.haskell.org/package/binary-0.8.5.1/docs/Data-Binary-Get.html#g:7
08:56:58 <cocreature> sphinxo: can you be a bit more specific? what exactly is your directory structure, what are the headers in the relevant files and what is the full error message?
09:02:18 <sphinxo> hmm, running stack build seems to fix it
09:02:26 <sphinxo> it was when I was running stack ghci
09:30:02 <Jane18> Hello
09:30:09 <Jane18> Hi
09:30:31 <Jane18> Anybody whant to talk?
09:31:16 <kadoban> About haskell?
09:31:27 <ski> this channel is about the Haskell programming language. do you have a Haskell-related question or comment ?
09:32:00 <ski> (if you're looking to talk about something different, then perhaps a different channel may be more suited to that)
09:38:13 <hodapp> whaaa...
10:19:20 <jonge> did anyone ever build a haskell app on an intel system, but with the resulting binary being executable on armv7 (i have raspberry pi in mind) ?
10:19:34 <tinytusk> Hello. I wish to have a polymorphic TChan restricted to ToJSON. I've created a GADT "data FooChan where FooChan :: ToJSON a => TChan a -> FooChan" but I am having difficulty using writeTChan.
10:20:12 <tinytusk> Specifically, I am getting rigid type errors.
10:21:03 <lyxia> tinytusk: isn't that TChan Value
10:21:16 <tinytusk> Holy crap.
10:21:21 <tinytusk> I think you just blew my mind.
10:21:41 <lyxia> Did I?
10:21:48 <c_wraith> whenever you think you need a constrained existential, you probably don't. :)
10:21:48 <tinytusk> Yes. I never even thought of that.
10:21:54 <erisco> @tell knupfer I was just thinking that maybe variadic functions could be a useful addition to your type-of-html API, particularly for lists of children… let me know
10:21:54 <lambdabot> Consider it noted.
10:24:01 <tinytusk> To be fair, this is a special case.
10:25:10 <c_wraith> tinytusk, if you want to keep the existential around for some reason, you would need to wrap the values in the TChan, not the TChan itself.
10:25:37 <c_wraith> tinytusk, that's the only way to allow them to choose their own type independently
10:25:58 <tinytusk> What knowledge do you have about TChan that leads you to that conclusion?
10:26:33 <tinytusk> (that conclusion = that what you said is the *only* way)
10:26:36 <c_wraith> none. the knowledge is of how existential types work.
10:26:57 <tinytusk> Ah, ok.
10:27:56 <c_wraith> the challenge is in, umm... writeTChan? is that the name of it?
10:28:05 <erisco> correct me if this is misleading, but a constrained existential is essentially just storing a dict of what the constraint gives you
10:28:34 <c_wraith> you need to provide a value of the same type that the TChan stores.
10:28:54 <erisco> so a question is whether you really need the dict, or maybe you can just call some functions beforehand and store the result you really want
10:29:20 <c_wraith> but if you can't know what that type is (because it's existential), then you can't ever prove the value you are providing matches that type.
10:29:39 <erisco> for example,  X :: forall a. Show a => a -> Y   may be nothing more than   X :: String -> Y
10:30:08 <c_wraith> erisco, yes, that's already been covered. I'm talking about the broader theory of existential types.
10:31:08 <erisco> okay
10:32:06 <c_wraith> tinytusk, of course, when the existential is constrained, sometimes you can create value of an unknown type. but it's going to require using a function with a polymorphic result type that matches the existential.
10:32:13 <tinytusk> c_wraith: "know what that type is" -- the type of the TChan?
10:32:33 <c_wraith> tinytusk, the type argument of TChan
10:32:37 <tinytusk> right
10:35:03 <c_wraith> tinytusk, the ToJSON constraint doesn't provide a way to produce a polymorphic result. so it can't be used to create a value
10:35:07 <tinytusk> c_wraith: Is a "skolem" type relevant to this discussion?
10:35:40 <shapr> [exa]: text tabs
10:35:50 <c_wraith> sort of. A skolem type is one that cannot unify with any monomorphic type.
10:36:08 <tinytusk> I see.
10:36:09 <c_wraith> but that's sort of an implementation detail of the algorithm.
10:36:44 <c_wraith> I think the only reason it makes it into error messages is because it sounds like a golem is escaping.
10:37:39 <shapr> [exa]: have you parsed text tabs before?
10:39:34 <c_wraith> tinytusk, to continue my rambling for a moment.. "data Foo where Num a => TChan a" is actually usable. that's because Num has fromInteger, which had a polymorphic return type.
10:39:46 <c_wraith> *has
10:40:23 <c_wraith> tinytusk, so no matter what type a is, you can use fromInteger to create a value of that type to write to the TChan
10:41:33 <c_wraith> existentials get weird. you're best off avoiding them whenever you can. it just makes things nicer.
10:42:51 <erisco> newtype p |- q = Entails (p => q)  is fun, though, and instructive
10:44:30 <srpx> Is there any example of simple haskell programs around, just doing simple things with simple ADTs, so I can show to a friend?
10:44:46 <sm> nah, we don't allow those
10:44:50 <c_wraith> lots of edwardk libraries involve existentials. they're not fundamentally broken. they're just harder to use than monomorphic or universally quantified types.
10:45:40 <mnoonan> c_wraith: I've been idly thinking about that lately. What kind of changes do you think would help make existentials easier to work with?
10:46:27 <erisco> srpx, you can write a calculator… *shrug*
10:46:29 <c_wraith> srpx, http://lpaste.net/355742
10:46:38 <c_wraith> amusingly, that involves an existential
10:47:48 <cocreature> existentials are not broken, they just don’t do what most people try to use them for
10:47:50 <c_wraith> mnoonan, I'm not sure much can be done - they are just more restrictive than one might be inclined to believe, initially.
10:48:37 <srpx> erisco: in real time? aha
10:48:45 <erisco> sure
10:48:48 <srpx> c_wraith: lol I said ADTs not GADTs
10:48:55 <c_wraith> Oh, my bad.
10:50:21 <mnoonan> I at least wish we could write "exists x. f x" directly and perhaps had some $-like operator $$ :: ((forall x. f x -> t) -> t) -> exists x. f x -> t
10:50:49 <vck> Hello Guys, I was wondering how good one has to be at Haskell to get in somewhere like Galois?
10:50:52 <ongy> exists exists in Haskell?
10:51:01 <vck>  I know you have to be *extremely* good
10:51:10 <c_wraith> vck, I know several people who got jobs there.
10:51:11 <vck> Can anyone conceptualize that?
10:51:29 <c_wraith> vck, and I've worked with a couple people after they quit from there.
10:52:40 <vck> c_wraith: How does one prove their Haskell if they haven't worked with Haskell in a commercial setting?
10:52:49 <vck> c_wraith: Github hobby projects?
10:52:56 <ongy> fix some of their code they have on github
10:53:11 <c_wraith> vck, given what I heard of their interview process, I'm not sure that even matters.
10:53:24 <erisco> mnoonan, I see a bright future for you in extension development!
10:53:44 <vck> c_wraith: So they just examine whether you are a generally *smart* person?
10:54:00 <c_wraith> they care more about your general understanding of computers and your ability to get things done.
10:54:06 <erisco> yeah, like if you use parentheses instead of $, and stuff like that
10:54:25 <mnoonan> erisco: it is tempting!
10:54:48 <mnoonan> i'm more afraid of figuring out ghc's build system than figuring out ghc's guts, honestly..
10:56:21 <vck> c_wraith: You said people quit. What do they speak about the experience working there? Was it enjoyable?
10:56:57 <c_wraith> vck, like, their interview process at one point asked you to explain the purpose of a standard OS component, asked how you would write one from scratch, and then spent several hours coding up your approach. knowing everything ahead of time wasn't nearly as important as being able to explain your reasoning and make progress towards the goal.
10:58:15 <c_wraith> hmm. the one universal I got was that working for a contractor is very different from working for a startup or the like.
10:58:26 <ongy> c_wraith: that sounds cool. did they want them to work on HALVM or do they just like to interview people like that?
10:58:56 <c_wraith> ongy, it was mostly just "if they can do this, they can work on anything"
11:00:12 <c_wraith> working for a contractor, your time has to be trackable to one contract or another. it's a more rigid structure. you get to work on some really cool stuff, but only when someone is paying you for it.
11:00:40 <c_wraith> the main reason people left was wanting to have a bit more control over what they worked on.
11:01:07 <c_wraith> which isn't a criticism of Galois in any way. it's just the nature of the work they do.
11:01:52 <c_wraith> it's still better than working for a contractor that never gets to do cool stuff.
11:02:22 <c_wraith> and often it's better than working in-house someplace that never gets to do cool stuff.
11:02:40 <vck> c_wraith: But what I heard from some contracting jobs is that a lot of time your are asked to work with horrendous legacy code ...
11:03:09 <erisco> the world is a broken place
11:03:52 <maerwald> erisco: what? xD
11:03:56 <c_wraith> maybe that happens sometimes. but Galois has the advantage that people tend to go to them for more interesting things. they don't do "my web pages all need to be redesigned" contracts. :)
11:04:20 <mnoonan> probably any company that has been around for a while will have a stash of legacy horrors
11:04:59 <vck> Who are their main clients? CIA? NASA?
11:05:21 <c_wraith> that isn't something I ever asked about, actually.
11:06:02 <tinytusk> I was a contractor for a time. I was poor because I finished my work too quickly.
11:06:08 <tinytusk> And I got paid a lot per hour.
11:06:32 <erisco> you never tell the captain how long it actually takes!
11:06:46 <c_wraith> vck, are you a PSU student?
11:07:33 <c_wraith> (they're the main funnel towards Galois in the area)
11:08:12 <vck> c_wraith: No. But are you saying they strongly prefer local students?
11:08:56 <c_wraith> no. one of the guys I know who worked there went to.. Kansas or Kansas state. Uh. whichever did the work on Kansas Lava.
11:09:13 <tinytusk> c_wraith: How do you meet all these people?
11:09:22 <c_wraith> it's just that most interest they get is from locals.
11:09:36 <mnoonan> Kansas (KU)
11:09:46 <mnoonan> iirc
11:09:56 <c_wraith> tinytusk, worked at a different company that (at the time) used Haskell and was located 3 blocks away.
11:11:06 <tinytusk> I see.
11:11:32 <tinytusk> bgamari lives near me it would be cool to meet him.
11:11:36 <c_wraith> it was amusing to run into people like BOS on the street when everyone was out to get lunch.
11:11:55 <c_wraith> (it's been a long time since he worked at Galois, now)
11:12:01 <bgamari> tinytusk, where do you live?
11:12:11 <bgamari> we should meet up some time
11:12:16 <tinytusk> bgamari: Manchester, NH.
11:12:25 <bgamari> ahh
11:12:26 <bgamari> indeed
11:14:12 <AndreasK> I wish container functions would agree universally about order of container, index and eventual arguments
11:19:14 <t7> don't galois do military contracts?
11:19:19 <t7> (if they do, shame on them)
11:19:26 <ongy> reminds me, I need to keep up to date if there are any meetups around here...
11:20:17 <tempay> hi folks - does anyone know what happens when someone runs 'stack build' with a stack.yaml with nix: enable: true, but they don't have nix installed?
11:20:51 <mud> I think it installs it, or tries?
11:21:36 <tempay> oh wow, really?
11:22:20 <mud> I essentially never use nix, so take that with a grain of salt, but I think so.
11:23:29 <johnw> I would be awfully surprised if it did that
11:26:58 <mud> Ya, kind of seems like I'm wrong, I must have been thinking about some other tool.
11:27:16 <fizzgig> hi, does anyone know how to get c2hs to generate just the foreign import declaration from a {#call functionname #}, without pasting that name in by itself on another line?
11:28:47 <fizzgig> like I just want the function available in the module, without specifying marshalling or anything
11:45:54 <erisco> the definition is in another module
11:50:48 <fizzgig> erisco: I don't understand
11:52:51 <erisco> I am snowcloning
11:53:32 <cocreature> fizzgig: I’m not sure, I’m following. how does "call" force you to paste the name on another line?
11:53:47 <fizzgig> i thought that might be the case :)
11:54:18 <erisco> reading Hackage sources…
11:56:27 <fizzgig> cocreature: so, just putting {#call x #} by itself in the chs file results in it being replaced with "x", then lower down "foreign import ccall "header.h x"
11:57:03 <fizzgig> but x by itself generates a naked expression error
11:58:10 <fizzgig> i thought there might be a convenient way to have just the foreign import, without the "x"
11:58:46 <fizzgig> i could just use the ffi directly but I like the autogenerated type signatures
11:59:02 <cocreature> fizzgig: sounds like you really want {# fun … #} and not {#call …#} but you want it to infer the type signature?
11:59:17 <fizzgig> yep
11:59:49 <cocreature> afaik that’s not possible
12:00:00 <cocreature> but it seems like a reasonable feature request
12:00:31 <cocreature> although it seems kind of confusing to autogenerate functions based on the content of some other file and not even specify type signatures
12:02:34 <fizzgig> well if c types map directly to counterparts in Foreign.C.Types nothing unexpected should happen?
12:03:46 <cocreature> oh sure, it’s not problematic on a technical level. my point is, that it forces users to read a C header and mentally translate types to Haskell types to figure out the type of a Haskell identifier
12:03:53 <cocreature> which is kind of confusing
12:07:41 <sphinxo> Is it possible with parsec to make it so I can write `Colour <$> number <$> number <$> number` and it accepts  `1 2 3`
12:08:05 <fizzgig> sure, yeah this was just for the sake of prototyping. I guess it makes sense anyway to go straight to {#fun, I was just hesitant about the upfront cost
12:08:27 <cocreature> fizzgig: you might also be interested in the inline-c package
12:08:36 <fizzgig> given I've got the C API in front of me
12:09:44 <mnoonan> inline-c is pretty rad
12:10:18 <cocreature> sphinxo: 1. that won’t typecheck, you need "Colour <$> number <*> number <*> number". 2. getting that exact behavior is going to be tricky but you might find a way to define `number` appropriately. e.g. if it’s single digits you could make number parse a single digit followed by 0 or 1 spaces or something like that
12:10:29 <fizzgig> that looks pretty good actually, thanks
12:10:32 <cocreature> sphinxo: but I wouldn’t recommend doing that unless you have a good reason for doing so
12:10:42 <sphinxo> cocreature: ok thanks
12:12:49 <tdammers> something like: number = fmap strToNumber (many digit <* whitespace)
12:13:58 <maerwald> tdammers: I don't believe numbers
12:14:49 <paolino> johnw, thank you for the hint on studying Free, it's beautiful stuff
12:15:17 <johnw> paolino: indeed! one of my favorite tools, even
12:15:47 <paolino> tempting to refactor everything :)
12:16:57 <maerwald> tdammers: especially since you are a consulter now, you'd probably sell me any number, wouldn't you?
12:19:41 <user____3> Hi Team,
12:23:18 <cocreature> hey Ero 
12:24:23 <Ero> Hi cocreature, ive seen you in here everyday so far, are you a long time user? 
12:25:20 <ongy> cocreature has been using Haskell for a long time. The addiction is strong and slowly gnawing on mind and body
12:27:55 <maerwald> ongy: you need help
12:29:27 <Ero> tbh
12:29:29 <alexknvl> Is there a name for type constructors (or functors) f :: * -> * that have empty :: f Void? Is there a name for type constructors that do not have such empty?
12:30:04 <cocreature> Ero: I became addicted a few years ago :)
12:30:25 <erisco> alexbiehl, what are the properties of this empty?
12:30:33 <Ero> i spent years being disatisfied with various languages (not that i ever became proficient in them) and then lisp caught my attention but led me to haskell. Haskell rocks 
12:30:52 <maerwald> and have been golfing since, writing pointfree code and creating abstractions I don't even know what they do anymore
12:31:05 <alexknvl> erisco: It's unique and canonical? I am mostly interested in the latter case to be honest
12:31:19 <alexknvl> erisco: where it *does not* exist
12:31:43 <Ero> i think im an addict too erisco 
12:32:29 <Ero> [#haskell] I have a recursive data structure that forall Ints will eventually be complete.
12:32:43 <alexknvl> I arrived at it while thinking about data Foo f g a = Foo (f (a, g (Foo f g a)))
12:32:58 <erisco> alexbiehl, so, merely that empty inhabits F Void
12:33:21 <alexknvl> if both f and g can't be empty, then the entire structure must be infinite
12:33:22 <Ero> whats the best way to include a conversion for the whole data structure from  one type to another (imcomplete tree t ocomplete tree) from within the definition of the function which creates the tree?
12:33:24 <mnoonan> hmm, isn't Void -> a inhabited?
12:33:48 <alexknvl> It is inhabited by identity function
12:34:02 <mnoonan> sorry, I should have said "for all a" :)
12:35:06 <alexknvl> forall a. Void -> a is still inhabited
12:35:50 <mud> Sounds like it should be. Definition should be ... there exists a function definition such that for any possible input, there is an output, something like that I guess?
12:35:55 <erisco> alexbiehl, are you using this to qualify F as having a base case? that doesn't sound right
12:36:19 <erisco> alexbiehl,  data X a = X (X a)  for example
12:36:49 <erisco> empty = X empty
12:36:56 <mnoonan> what i'm trying to say is that from curry-howard, I'd expect any type to be inhabitable given an inhabitant of Void, so for all t, Void -> t would be inhabited. (note: not "(for all t, Void -> t) is inhabited")
12:38:09 <erisco> :t \case{} :: Void -> a -- mnoonan
12:38:10 <lambdabot> Void -> a
12:38:28 <mnoonan> erisco, empty case! I knew I was forgetting something :)
12:38:52 <alexknvl> consider Maybe or Const a, they both have empty :: f a, while Identity or (->) Int don't
12:39:20 <mnoonan> right, so fmap (\case {}) (empty :: f Void) gives you a point in every f t, which is kind of odd
12:39:42 <erisco> alexknvl, sorry that above was for you… too many alex
12:40:55 <alexknvl> why is it odd? empty :: Maybe a, empty = Nothing
12:41:09 <erisco> Nothing = 1, Just a = a, Nothing | Just a = Nothing + Just a
12:41:26 <erisco> Void = 0, so  Nothing + Just Void = 1 + 0 = 1
12:41:40 <mnoonan> maybe "odd" is the wrong word. I think it means you must have a nullary constructor "N :: forall a . f a" though
12:41:52 <alexknvl> yes
12:41:59 <alexknvl> that's what I am looking for
12:42:13 <alexknvl> a word to describe all types that have a nullary constructor / don't
12:42:17 <alexknvl> or better, all functors
12:42:29 <mnoonan> "pointed", maybe
12:42:32 <alexknvl> categorical taxonomy
12:42:34 <alexknvl> :)
12:42:49 <alexknvl> that's point :: a -> f a
12:42:55 <erisco> alexknvl, did you see my earlier comments I accidentally sent to alexbiehl?
12:43:20 <mnoonan> alexknvl: oops, right
12:43:52 <alexknvl> erisco: you mean data X a = X (X a) ?
12:43:59 <erisco> alexknvl, correct
12:44:48 <alexknvl> right, I would classify it as a type with nullary constructor
12:45:22 <erisco> you were talking about infinite structures, and I am showing that even though X Void is inhabited, it is not finite
12:46:34 <alexknvl> my language of choice is strict by default :)
12:46:39 <maerwald> infinite structures?
12:47:26 <maerwald> or did you mean infinite elements in a structure?
12:47:38 <erisco> alexknvl, okay.
12:48:08 <maerwald> infinite structures would probably blow up GHC thunk allocator
12:48:23 <alexknvl> nope, they are lazily constructed
12:48:26 <maerwald> no
12:48:43 <maerwald> values yes, not structure
12:49:16 <alexknvl> what does structure mean in this context?
12:49:39 <maerwald> e.g. an ADT with 1 million accessor functions
12:50:27 <alexknvl> lol
12:50:29 <maerwald> when you talk about _structure_ you mean structure
12:50:32 <maerwald> not values
12:50:58 <maerwald> infinite structure requires infinite thunks
12:51:00 <maerwald> so not possible
12:51:38 <erisco> alexknvl, that is interesting but I don't know what that connection is
12:53:08 * hackagebot mallard 0.5.0.0 – Database migration and testing as a library. – https://hackage.haskell.org/package/mallard
12:54:04 <erisco> if we were counting again, then  forall a, 1 ≤ |F a|
12:55:00 <alexknvl> why?
12:55:23 <erisco> because that might give you an angle to look at it where a name becomes obvious
12:55:43 <alexknvl> no, I mean why is |F a| >= 1?
12:56:20 <alexknvl> is it a Haskell-specific statement?
12:56:31 <erisco> no, I am just counting the inhabitants of the type
12:56:32 <alexknvl> newtype F a = Void
12:56:58 <alexknvl> this would be uninhabited in a total language
12:57:11 <alexknvl> or a language with strict evaluation
12:57:45 <erisco> why? you defined Void :: F a, so Void inhabits F a forall a
12:58:08 <erisco> anyways, for what I am doing by counting: https://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
12:58:11 <alexknvl> but Void has no inhabitants
12:58:21 <erisco> alexknvl, maybe you misunderstand what a newtype is
12:58:22 <alexknvl> other than bottom
12:58:52 <erisco> actually what you wrote is an invalid program
12:59:00 <alexknvl> ah
12:59:41 <alexknvl> type F a = Void
12:59:53 <erisco> well, F is not a type here, so, *shrug*
13:00:17 <erisco> don't believe the lies of ghci
13:00:30 <alexknvl> and if it was newtype F a = F Void?
13:01:04 <erisco> then it is uninhabited
13:01:18 <alexknvl> in Haskell
13:01:22 <alexknvl> it lies
13:01:42 <alexknvl> the point of Void is that it ought to be uninhabited
13:01:44 <erisco> I don't know what you mean… I am discounting bottoms
13:01:48 <maerwald> frustrating, isn't it
13:01:59 <maerwald> you cannot trust anyone these days
13:02:01 <alexknvl> but then there are no 0 types?
13:02:09 <Maxdamantus> GHCi tells the truth! Look!
13:02:20 <Maxdamantus> > let x :: Maybe; x = x in x
13:02:22 <maerwald> Maxdamantus: I will uninstall all of them!
13:02:22 <lambdabot>  error:
13:02:22 <lambdabot>      • Expecting one more argument to ‘Maybe’
13:02:22 <lambdabot>        Expected a type, but ‘Maybe’ has kind ‘* -> *’
13:02:23 <alexknvl> okay, what about
13:02:24 <erisco> not that I know of
13:02:30 <alexknvl> data F a
13:02:34 <alexknvl> without any type constructors
13:02:41 <erisco> @define data F a
13:02:42 <lambdabot>  Defined.
13:02:46 <erisco> :t undefined :: F a
13:02:47 <lambdabot> forall k (a :: k). F a
13:02:47 <alexknvl> data constructors*
13:02:48 <Maxdamantus> It claims `Maybe` is not a "type" there.
13:02:53 <Maxdamantus> which is correct.
13:03:02 <Maxdamantus> Same would apply for that `F`
13:03:15 <erisco> alexknvl, it doesn't matter what constructors we explicitly define, because semantically it always gains the bottom constructor
13:04:26 <erisco> Maxdamantus, I will illustrate the lie to you then, or try to, with lambdabot, which does not use ghci afaik
13:04:34 <erisco> @define type G a = Void
13:04:35 <lambdabot>  Defined.
13:04:39 <erisco> :k G
13:04:40 <lambdabot> k -> *
13:04:48 <erisco> that is just nonsense, because G isn't anything
13:05:13 <alexknvl> but then all of that counting stuff breaks down
13:05:16 <alexknvl> Nothing = 2
13:05:17 <Maxdamantus> "isn't anything"?
13:05:23 <alexknvl> Just a = a + 1
13:05:25 <erisco> yes, that is right, G is nonsense
13:05:33 <erisco> and nonsense doesn't have a type
13:05:35 <Maxdamantus> Well, G is a function, as it says there.
13:05:40 <maerwald> is this a philosophical thing?
13:05:42 <Maxdamantus> A function that returns a type.
13:05:42 <erisco> that is a lie… it isn't :P
13:05:44 <alexknvl> Maybe a = 2 + a + 1 = a + 3
13:06:05 <Maxdamantus> eg, you can write `Void :: G IO` or `Void :: G Int`
13:06:18 <Maxdamantus> Because `G IO` and `G Int` are types.
13:06:23 <fishythefish> Void isn't a value
13:06:24 <alexknvl> @define type G (a :: *) = Void
13:06:25 <lambdabot>  .L.hs:163:1: error:
13:06:25 <lambdabot>      Multiple declarations of ‘G’
13:06:25 <lambdabot>      Declared at: .L.hs:161:1
13:06:40 <eacameron> When defining an Aeson instance of FromJSON for some type, is it possible to communicate that the type should be omittable, like Maybe?
13:06:44 <Maxdamantus> Void is a bunch of values, with different types.
13:06:47 <alexknvl> @redefine type G (a :: *) = Void
13:06:47 <lambdabot> Maybe you meant: undefine define
13:06:58 <alexknvl> @undefine G
13:06:59 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
13:07:04 <erisco> Maxdamantus, I'll cut to the chase, then… functions are first order at the type level, so G by itself is nonsense
13:07:11 <alexknvl> @redefine type H (a :: *) = Void
13:07:11 <lambdabot> Maybe you meant: undefine define
13:07:14 <alexknvl> @define type H (a :: *) = Void
13:07:16 <lambdabot>  Defined.
13:07:18 <Maxdamantus> > let a = (Void :: G IO, Void :: G Int) in 42
13:07:18 <alexknvl> sorry for spam :)
13:07:20 <lambdabot>  error:
13:07:20 <lambdabot>      • Data constructor not in scope: Void :: G IO
13:07:20 <lambdabot>      • Perhaps you meant one of these:
13:07:36 <fishythefish> Maxdamantus, the Void type doesn't have a constructor named Void
13:07:38 <fishythefish> that's not a value
13:07:44 <erisco> Maxdamantus, if you try to use just G, by using it where something expects a  k -> *  value, then you will be told your program is invalid
13:07:51 <erisco> so this flies in the face of saying G :: k -> *
13:08:02 <Maxdamantus> fishythefish: Void isn't a type. It's a value constructor.
13:08:20 <fishythefish> defend?
13:09:15 <Maxdamantus> Oh oops, I thought it said `data G a = Void`
13:09:54 <erisco> same thing happens with type families
13:10:47 <alexknvl> erisco: https://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/ doesn't really apply to Haskell :P
13:10:58 <erisco> alexknvl, and why not?
13:11:11 <alexknvl> because you said that Void = 1, then Bool = 3, etc
13:11:21 <Maxdamantus> When I use that type definition in my ghci it just makes it a `* -> *`
13:11:21 <alexknvl> Well, the principle applies
13:11:31 <alexknvl> but all values are off by at least 1
13:11:32 <erisco> if you want to include bottom, then do that… same algebra applies
13:11:33 <fishythefish> that algebra generally ignores bottoms
13:11:51 <fishythefish> the reasoning is being conducted in a total subset of the language
13:12:36 <fishythefish> you can, of course, work out what the rules should be in the presence of bottoms :)
13:12:56 <alexknvl> it's still an algebra if you include bottoms but not a very pretty one :)
13:13:40 <fishythefish> eh, some people find CPOs pretty
13:14:40 * hackagebot mallard 0.5.0.1 – Database migration and testing as a library. – https://hackage.haskell.org/package/mallard
13:15:53 <[exa]> shapr: sorry, I went AFK. I've attempted parsing them before (using prolog), but most of it is problematic (most frustrating stuff from ultimate-guitar: handwritten notes that can mean anything, impossible-to-determine note lengths)
13:18:02 <[exa]> shapr: anyway the algorithm was, you find lines that contain long word with many ---, split them, group stuff by offsets and "|". If I find It I'll send you
13:27:35 * hackagebot miso 0.7.7.0 – A tasty Haskell front-end framework – https://hackage.haskell.org/package/miso
13:29:31 <erisco> but can I eat it?
13:32:01 <dmj`> erisco :D
13:37:47 <shapr> [exa]: yeah, I'd like to see the code if you can find it
13:42:27 <alexknvl> data P f = P ((forall a. a -> f a) -> Void)
13:43:32 <alexknvl> assuming that we are in CCC and not CPO, this is inhabited only if f a doesn't contain any values of type a
13:43:46 <alexknvl> iff*
13:43:52 <alexknvl> I think
13:48:51 <nshepperd_> It's inhabited for data T a where (T :: Int -> T Int)
13:51:27 <fishythefish> it's inhabited iff (forall a. a -> f a) is uninhabited, no?
13:53:12 <fishythefish> the T constructor doesn't satisfy the forall a part of that, right?
13:53:29 <alexknvl> nshepperd_: ohh, that's evil
13:54:23 <nshepperd_> Maybe turn the arrow around. (forall a. f a -> a) -> Void
13:54:44 <alexknvl> but that satisfied even by Maybe
13:54:49 <alexknvl> is*
13:55:11 <alexknvl> hm
13:55:12 <alexknvl> or not
13:55:39 <alexknvl> nvm, yes, it is satisfied by Maybe
13:56:39 * hackagebot comark 0.1.0, comark-html 0.1.0, comark-parser 0.1.0, comark-syntax 0.1.0
13:56:39 * hackagebot  → https://hackage.haskell.org/packages/recent
14:04:02 * hackagebot pointfree-fancy 1.1.1.4 – Tool for refactoring expressions into pointfree form – https://hackage.haskell.org/package/pointfree-fancy
14:12:28 <dolio> DCPO is a CCC.
14:14:13 <n_blownapart> hi someone explain the last function here, f , to me? It is preceded by a similar example that I understand well.
14:14:15 <n_blownapart> https://ptpb.pw/X3ae
14:14:25 <n_blownapart> could*
14:15:15 <fishythefish> f n = concatMap r (r n)
14:15:23 <fishythefish> r n just gives the list [1..n]
14:15:50 <fishythefish> so we have concatMap r [1..n], which first maps r over that list, then concats the result
14:16:26 <n_blownapart> fishythefish: thanks, one sec
14:17:45 <n_blownapart> fishythefish: so technically its not using recursion
14:17:58 <fishythefish> no, not at all
14:18:14 <fishythefish> unless you count the definition of concatMap as well
14:18:26 <shloub> does that start with 1, 1, 2, 1, 2, 3?
14:19:36 <fishythefish> > let f = concatMap r . r where r n = [1..n] in f 5
14:19:38 <lambdabot>  [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5]
14:19:51 <shloub> ty
14:19:55 <n_blownapart> shloub: yeah ..  I'm a little foggy on how f works. I understand seriesUp above to be tail recursion 
14:20:46 <fishythefish> > let f = concat . map r . r where r n = [1..n] in f 5
14:20:48 <lambdabot>  [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5]
14:20:51 <fishythefish> n_blownapart: is that clearer?
14:21:49 <lyxia> shloub: <3
14:22:01 <n_blownapart> yes I think with that I can hash it out thank you fishythefish . one thing...
14:22:36 <n_blownapart> seriesUp in both cases is an instance of tail recursion, right? 
14:23:11 <fishythefish> which one are you referring to?
14:23:29 <n_blownapart> or does ++ make that work as linear recursion? I'm referring to either
14:23:51 <fishythefish> well, let's talk about seriesUp', since that's the one actually doing the recursion
14:24:15 <n_blownapart> yeah I meant the two programs as a whole
14:24:30 <fishythefish> right, the ++ prevents this from being tail recursion
14:25:23 <shloub> lyxia, D:
14:26:23 * hackagebot swagger2 2.1.6 – Swagger 2.0 data model – https://hackage.haskell.org/package/swagger2
14:26:34 <n_blownapart> yes, there is no updating of seriesUp' "in place"  (the way they talk about it in scheme.
14:26:40 <n_blownapart> )
14:28:30 <n_blownapart> thanks fishythefish appreciate it
14:31:46 <Maxdamantus> [5~/scroll end
14:32:18 <isBEKaml> Maxdamantus: screen/tmux?
14:33:30 <n_blownapart> so often (or always?) whenever you have an operator left of the recursive call, in this case ' ++ seriesUp' (i + 1) n '     ..     that indicates that it is linear recursion, which builds to the left of the operator (or infix function in this case) is that correct?
14:35:01 <fishythefish> no, you're thinking in terms of prefix notation
14:35:18 <fishythefish> it's not about stuff being to the left or right, it's about more "work" being done after the recursive call
14:36:01 <fishythefish> in this case, after the recursive call to seriesUp', the (++) operator still has to be called to finish evaluating the function
14:37:09 <n_blownapart> ok, so somewhere there is a stack occuring, with ie [1], [1,2], [1,2,3] ..
14:38:26 <n_blownapart> or does it look like this? : [1] ++ [1,2] ++ [1,2,3]
14:38:28 <fishythefish> well, we can discuss tail calls in the context of any language, including haskell
14:38:48 <fishythefish> if you want to talk about the call stack, that's an implementation detail which may not be valid for the given language/compiler/architecture
14:39:14 <n_blownapart> in scheme I learned a nice way to write it out. 
14:39:30 <n_blownapart> but I'm worried it doesn't look precisely the same
14:39:48 <fishythefish> we can expand each of the calls, though
14:40:07 <n_blownapart> actually, I would like to see how the 'f ' works visually if possible.
14:40:41 <n_blownapart> fishythefish: also yes if you have time I'd like to see how you would write out seriesUp'
14:41:41 <fishythefish> seriesUp 3 = seriesUp' 0 3 = [] ++ seriesUp' 1 3 = [] ++ ([1] ++ seriesUp' 2 3) = [] ++ ([1] ++ ([1, 2] ++ seriesUp' 3 3)) = [] ++ ([1] ++ ([1, 2] ++ ([1, 2, 3] ++ seriesUp' 4 3))) = [] ++ ([1] ++ ([1, 2] ++ ([1, 2, 3] ++ [])))
14:44:23 <fishythefish> n_blownapart: for f, if I define f as f n = concat (map r (r n)), do you understand why that is?
14:44:39 <n_blownapart> fishythefish: that's interesting so it actually begins and ends with an empty list. (in seriesUp)
14:45:20 <saylu> Hey folks! I’m about to be spending a lot of time doing document conversion, specifically Markdown -> PDF or Markdown -> HTML. I’ve got to be able to control the output and so I’m expecting to spend quite a bit of time learning Pandoc.
14:45:20 <saylu> Anyone have favorite resources for learning Pandoc? Has anyone got an example repo creating a custom PDF output? Love to see them if so!
14:45:24 <fishythefish> n_blownapart it doesn't have to begin with one; you can start at seriesUp' 1 instead of seriesUp' 0
14:45:25 <n_blownapart> yes, you are just separating the function into higher order functions
14:45:47 <fishythefish> @define rr n = [1..n]
14:45:48 <lambdabot>  .L.hs:168:1: warning: [-Woverlapping-patterns]
14:45:48 <lambdabot>      Pattern match is redundant
14:45:48 <lambdabot>      In an equation for ‘rr’: rr n = ...
14:45:59 <fishythefish> @undefine
14:45:59 <lambdabot> Undefined.
14:46:01 <fishythefish> @define rr n = [1..n]
14:46:03 <lambdabot>  Defined.
14:46:11 <fishythefish> > rr 5
14:46:14 <lambdabot>  [1,2,3,4,5]
14:46:19 <fishythefish> >map rr (rr 5)
14:46:31 <fishythefish> > map rr (rr 5)
14:46:34 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
14:46:40 <fishythefish> > concat (map rr (rr 5))
14:46:42 <lambdabot>  [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5]
14:46:50 <fishythefish> n_blownapart: does that help? ^
14:49:07 <n_blownapart> excellent yeah I can run with that. thanks .. you changed it to 'rr' fishythefish ? why was that originally called r just no reason?
14:49:22 <n_blownapart> fishythefish: ^
14:49:51 <n_blownapart> what's up with the chatroom?
14:50:01 <fishythefish> n_blownapart: changed it to avoid a naming conflict, but the name is irrelevant to the behavior
14:50:15 <shloub> r might stand for range
14:50:19 <n_blownapart> thanks kindly fishythefish
14:50:34 <n_blownapart> shloub: cool thanks
14:50:40 <geekosaur> looks like freenode is having a 'slow' netsplit, so it's not detected as such
14:50:44 <geekosaur> it happens sometimes
14:51:04 <n_blownapart> motion sickness !
14:53:44 <fishythefish> @undefine
14:53:45 <lambdabot> Undefined.
14:58:22 <dmwit> > (enumFromTo 1 >=> enumFromTo 1) 5
14:58:25 <lambdabot>  [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5]
14:58:36 <jkoppel> Anyone have a good way to benchmark build times?
15:00:23 <n_blownapart> dmwit: thanks I saw that one on the same blog.
15:00:32 <erisco> sometimes a calendar will do fine
15:12:44 <epta> (trifecta/parsers)-based parser for recursive data structure takes ~13 secs to parse 6MB file. ~30Gbytes allocated in the heap, 1635 MB total memory in use. Is it ok when you have to deal with lookahead, or I'm missing something?
15:13:49 <mud> Sounds like quite a lot. Hard to say without a bit more details though.
15:13:52 <epta> in prof at the top there is 'grabRest    Text.Trifecta.Rope   src/Text/Trifecta/Rope.hs:(67,1)-(73,65)   69.4 (%time)   66.7(%alloc)'
15:19:39 <epta> mud: http://lpaste.net/6119591676764749824
15:29:15 <johnw> epta: that's too much
15:29:40 <mud> epta: Not seeing anything obvious, sorry.
15:29:42 <johnw> epta: I'd build with profiling next, and find out where the hot spots seems to be
15:31:39 <johnw> since you're not even using the final value, the memory use for a parser like this should be almost flat, just enough to manage the token stack.  Which could mean that you're building up structures on the heap during the parse, as a first guess
15:32:05 <johnw> the profiler should make it pretty clear where to start; be sure to compile the modules in your own code with -fprof-auto
15:33:08 <johnw> also, why use Text.pack?  Why next use a Text-based parser?
15:33:12 <johnw> s/next/not
15:42:55 <epta> johnw: you mean 'takeTill :: (Char -> Bool) -> Parser Text' instead of 'manyTill'?
15:47:05 <epta> at the same time, still can't figure out what is wrong with grabRest here http://lpaste.net/raw/1075722740226326528
16:01:53 <erisco> I want to call some C functions from Haskell, and I need to marshall pointers to structs… was looking at ways to do that… entirely confused by c2hs
16:02:56 <erisco> is there a different library or am I best putting this together by hand, referencing https://wiki.haskell.org/Foreign_Function_Interface , or what advice can I get here?
16:06:17 <c_wraith> I've found hsc2hs to be the least work to learn, though it has some definite boilerplate 
16:06:38 <erisco> the description of c2hs made it sound like it would read a .h file and give me the bindings, but as I read into the docs it doesn't look like it does that at all
16:07:26 <dmj`> @package inline-c
16:07:26 <lambdabot> http://hackage.haskell.org/package/inline-c
16:07:31 <dmj`> heard good things
16:09:00 <erisco> that looks interesting but I need FFI
16:09:02 <c_wraith> that's a lot newer than my ffi work. it could also be really good
16:09:13 <c_wraith> erisco, what part of that prevents ffi?
16:09:56 <erisco> what part enables it?
16:10:15 <c_wraith> the part where it constructs expressions that call c code.
16:14:04 <erisco> why did I become a computer programmer
16:15:50 <erisco> thanks for the link, dmj`
16:16:02 <Tuplanolla> Because you had no social life, so you took solace in solitary activities and accidentally became quite good at one of them? Is this trivia night?
16:16:38 <erisco> apparently it is psychoanalysis night
16:17:19 <Tuplanolla> What I'd like to know is how `inline-c` does linking.
16:21:33 <dmj`>  erisco: np
16:34:57 <Welkin> erisco: you could have been a *computer* several decades ago
16:35:08 <Welkin> no silicon required
16:39:18 <erisco> Welkin, and in another several decades there will just be computer programmer technicians
16:43:16 <erisco> back in my day computers couldn't understand you, so we made special languages that computers could understand that took years for humans to learn
16:44:03 <Welkin> back in my day, computers were people!
16:44:17 <erisco> and, retrospectively, I am not sure if that means computers were stupid or we were stupid
16:44:34 <mniip> years?
16:44:50 <mniip> at where I am I can't imagine even machine code taking more than multiple weeks to learn
16:45:30 <erisco> mniip, think bigger than syntax :)
16:45:45 <mniip> ?
16:50:41 <zenspider> inline-c! neat! I did inline for ruby. I love that idiom
17:07:46 <erisco> well, don't load a c-inline file into ghci
17:08:45 <erisco> oh, actually it crashes ghc too… well that must be a Windows thing
17:11:17 <dmwit> mniip: I dunno, I feel as though I still occasionally learn things about Haskell and I've definitely been using it for years.
17:12:03 <dmwit> mniip: Learning how to write idiomatic code that uses appropriate libraries fluently does seem like something that takes a bit more than a few weeks.
17:12:44 <mniip> dmwit, in the context of the question..
17:12:50 <mniip> it refers to early programming languges
17:12:57 <dmwit> mniip: (Remember to take into account not just how long it takes you *now* to learn a new language, but how much effort you had to put in to get to where you are. Your first programming language probably took quite a long time indeed to get into.)
17:13:28 <dmwit> What question? I thought this was in reference to "we made special languages that computers could understand that took years for humans to learn".
17:13:33 <mniip> yes
17:13:35 <erisco> I guess I needed more work on my technician joke…
17:13:49 <dmwit> That doesn't appear to refer to early programming languages.
17:13:55 <dmwit> But I'm not sure whether it matters if it does or not.
17:14:28 <erisco> is it a writer's job to cause confusion and debate amongst their readers?
17:14:33 <dmwit> Or, to put it another way: I don't know what you mean by "early".
17:14:47 <dmwit> Is Haskell an early programming language? Why not?
17:15:21 <hpc> haskell is never late, nor is it early
17:15:21 <dmwit> s/Why not?/Why (not)?/
17:15:28 <hpc> haskell arrives precisely when it means to :P
17:16:25 <erisco> look to Haskell's coming on the first light of the fifth day
17:16:49 <hpc> :D :D :D
17:19:13 <erisco> they are teaching the Hobbits some Haskell code, Haskell code, Haskell code
17:20:00 <erisco> curry, you fools!
17:21:13 <hpc> one abelian group to rule them ail
17:21:15 <hpc> all
17:21:33 <JuanDaugherty> haskell is late, about 20 y, fortan and lisp are both about 60
17:21:48 <hpc> it's older than that, it's 2017
17:22:10 <hpc> haskell 98 is 20 years old, but it's been around for a while longer
17:22:19 <JuanDaugherty> if you mean really was a thing, then more like 15 or 10
17:22:27 <JuanDaugherty> a useful thing
17:23:13 <JuanDaugherty> at some point it graduated out of the science experiment stage
17:23:40 <JuanDaugherty> *fortran
17:24:01 <JuanDaugherty> which is more than 60 yo i think
17:24:16 <dmwit> Is late mutually exclusive with early?
17:24:52 <zachk> can you be both late and early for say Bilbo's birthday party?
17:24:53 <JuanDaugherty> the earliest langs would be machine specific; in a spectrum or other unity, yes
17:24:56 <dmwit> "The late Mr. Edwards arrived early to the funeral in his casket."
17:25:13 <zachk> dmwit, nice once ;-)
17:25:52 <dmwit> JuanDaugherty: In the context of the joke being I made, I suspect Haskell qualifies as an early language. The joke was from the perspective of a far-future CS historian explaining to the kiddos what terrible things we had to go through back then (a.k.a. now), like speaking the machine's language instead of having the machine speak our language.
17:26:20 <JuanDaugherty> yeah it's coming
17:26:28 <dmwit> This has kind of been my point all along. But making the point so explicit ruined the joke and so I tried to avoid it. =P
17:27:04 <JuanDaugherty> the best hs thing for that i know of right now is ACE in GF
17:40:34 <theotherben> Hey friends; I'm going thru learning haskell by implementing varying typeclasses myself
17:41:10 <theotherben> I'm trying to implement Functor Either e, but I'm getting an error because instance Functor Either e is (unsurprisingly) already defined
17:41:44 <theotherben> What's the right way to let myself reimplenment some typeclasses?
17:42:16 <boj> theotherben: you could use the NoImplicitPrelude pgragma to hide the Prelude
17:42:33 <boj> then you are free to define things as you wish with no conflicts
17:42:59 <theotherben> Gotha
17:43:04 <theotherben> Thanks!
17:43:05 <pacak> You can create your own typeclass as well.
17:43:10 <pacak> Functor'
17:43:24 <pacak> Also
17:43:30 <pacak> import Prelude hiding (Functor)
17:44:51 <theotherben> Ah, defining my own typeclass probably makes the most sense
17:44:59 <theotherben> otherwise I'd have to redefine my own data types every time
17:45:10 <theotherben> Assuming that instance Functor Either is in the Data.Either package
17:45:39 <rotaerk> note that it's Functor (Either e)
18:03:35 <erisco> oooh shiny new error messages in 8.2
18:04:01 <Axman6> so pretty
18:04:27 <erisco> I'm going to make more mistakes just because it looks purdy
18:06:27 <erisco> I have to hope it fixes this compiler crash… I just have to rebuild Hackage…
18:07:18 <elvishjerricco> What's the name of that thing that lets your persist variables across `:reload` in a GHCi session?
18:07:48 <MarcelineVQ> rapid
18:08:14 <MarcelineVQ> think there's another one but I can't remember it
18:09:13 <erisco> woo-hoo, no crash
18:10:36 <elvishjerricco> MarcelineVQ: Thanks!
18:18:45 <erisco> quantum-style I ran this [C.block| int { return 5 * 3; } |] >>= print
18:21:56 <wvansteen> Could anyone help with what I imagine is a stupid build issue?
18:23:00 <wvansteen> I added mockery as a dependency, but I get a compile error saying that it is part of a hidden package and it should be added to my cabal file, but when I add it to my cabal file and rerun `stack test` it is removed as a dependency.
18:25:33 <theotherben> Is the standard way to download packages to add them to my cabal file? Or is there a stack command to manage this?
18:26:34 <dmwit> I generally get new packages by adding them to an appropriate cabal file.
18:26:50 <dmwit> There is one exception, which is a sandbox I have for quick tests, where I use `cabal install` instead.
18:27:11 <dmwit> Probably stack has something analogous.
18:28:11 * hackagebot aeson-diff 1.1.0.4 – Extract and apply patches to JSON documents. – https://hackage.haskell.org/package/aeson-diff
18:38:34 <Arahael> So, if I want to basically do some haskell "scripts", which mainly end up calling external processes and interpreting the results...  I should use something like process-1.0.1.1 ?
18:39:36 * hackagebot mallard 0.6.0.0 – Database migration and testing as a library. – https://hackage.haskell.org/package/mallard
18:44:11 <geekosaur> you might look at shelly and / or turtle
18:44:27 <geekosaur> depending on how much external process stuff you are doing
18:45:07 <pacak> bash is a bit better (but uglier and more unsafe) at shell scripts.
18:46:52 <Arahael> So, if I want to basically do some haskell "scripts", which mainly end up calling external processes and interpreting the results...  I should use something like process-1.0.1.1 ?
18:50:10 <theotherben> my code was throwing an error when I had something like deriving (Monad); it got better when I added deriving (Functor, Applicative, Monad)
18:50:14 <theotherben> Is that always required now?
18:50:27 <slack1256> Arahael: yep, although for shell-script-ing there is always the turtle library
18:50:31 <theotherben> Or is there a way to have it so that deriving (Monad) automatically derives the superclasses as well?
18:51:18 <Arahael> slack1256: Would you recommend I use turtle instead?
18:51:25 <geekosaur> theotherben, it's always required now
18:51:39 <theotherben> got it, thanks geekosaur
18:51:58 <slack1256> theotherben: Yet, thereis now the hierarchy Functor ->> Applicative -> Monad . Even if you could make Monad derive Applicative and Functor automagically for clarity I would still put the 3 of them
18:52:25 <theotherben> The hierarchy makes sense to me; just had a conflict with a tutorial i was reading :)
18:52:42 <theotherben> specifically http://dev.stephendiehl.com/fun/001_basics.html, in the Monad Transformers section
18:52:46 <slack1256> Arahael: turtle uses process under the rug. It just gives you better function for calling external processes. Also gives you analogs of unix commands linux mv, rm etc
18:53:57 <Arahael> slack1256: It sounds like I might as well use turtle.
18:56:04 <slack1256> Arahael: https://hackage.haskell.org/package/turtle-1.4.3/docs/Turtle-Prelude.html#v:proc on turtle vs https://hackage.haskell.org/package/process-1.6.1.0/docs/System-Process.html#v:shell on process
18:56:26 <slack1256> the turtle version can deal with an stdin generated from haskell, which is useful.
18:58:33 <slack1256> As a general idea on how to use the library, the tutorial didn't help me much. Basically treat everything as working on pure IO (mv rm proc etc), if you need streaming from shell command pipes then you use the Shell and composition can be simply ($) . 
18:59:25 <Arahael> slack1256: Nice - thanks.  I'm hoping I can call it from within snap.
18:59:34 <slack1256> as many haskell libraries, they are *no* framework, so for safe concurrency you can use the async library. There is also a fork command on turtle I don't like much
19:00:34 <Arahael> slack1256: async sounds good.
19:02:08 <Arahael> slack1256: async sounds *very* good, just read: https://haskell-lang.org/library/async
19:03:08 * hackagebot mallard 0.6.0.2 – Database migration and testing as a library. – https://hackage.haskell.org/package/mallard
19:03:08 * hackagebot mallard 0.6.0.1 – Database migration and testing as a library. – https://hackage.haskell.org/package/mallard
19:06:33 <slack1256> those are nice docs for async. More package should have "sale pitch" tutorials on their front page :-)
19:38:46 <Arahael> slack1256: Indeed. :)
19:46:28 * hackagebot apecs 0.2.1.0 – A fast ECS for game engine programming – https://hackage.haskell.org/package/apecs
19:46:48 <dave_> @type "foo"
19:46:49 <lambdabot> [Char]
19:47:39 <dave_> @type ()
19:47:40 <lambdabot> ()
19:48:22 <dave_> @type "foo" -> ()
19:48:23 <lambdabot> error: parse error on input ‘->’
20:08:07 <whoisxy> :t (<)
20:08:09 <lambdabot> Ord a => a -> a -> Bool
20:08:38 <whoisxy> hmm I'm getting (<) :: (Eq a, Num a) => t -> a -> [Char]
20:09:05 <whoisxy> must have broke something all
20:09:33 <whoisxy> fixed on restart
20:10:48 * hackagebot multi-instance 0.0.0.1 – Typeclasses augmented with a phantom type parameter – https://hackage.haskell.org/package/multi-instance
20:10:48 * hackagebot werewolf 1.5.2.0 – A game engine for playing werewolf within an arbitrary chat client – https://hackage.haskell.org/package/werewolf
20:11:26 <lyxia> whoisxy: :info (<)   tells you where it is defined
20:13:21 * geekosaur suspects an expression got read as a definition. maybe making let optional in ghci was not the best idea after all?
20:18:54 * hackagebot forest-fire 0.1.1.0 – Recursively delete CloudFormation stacks and their dependants – https://hackage.haskell.org/package/forest-fire
20:45:15 * hackagebot foldl 1.3.2 – Composable, streaming, and efficient left folds – https://hackage.haskell.org/package/foldl
21:02:20 <antalsz> Is there a good way to get `stack` to reinstall every package it’s installed?
21:04:29 <MichaelBurge> Is there a way to pass a C struct on the stack with the FFI? The examples all seem to use pointers
21:04:32 <byorgey> antalsz: I very much doubt it.  Does stack even know what packages it has installed?
21:05:01 <antalsz> byorgey: I’d settle for “`rm -rf` and reinstall”, I just don’t know what to remove
21:05:39 <pacak> MichaelBurge: "on the stack" as in "in memory"? What will happen if gc decides to move it?
21:06:07 <byorgey> antalsz: ah, in that case, try removing ~/.stack/snapshots/ and any local .stack-work/ directories
21:06:30 <pacak> MichaelBurge: You need pinned memory for that. And a pointer.
21:06:54 <whoisxy> lyxia: thanks
21:07:21 <byorgey> antalsz: that's an educated guess, if it doesn't work you'll have to ask someone who actually knows more about stack
21:07:23 <MichaelBurge> pacak: Suppose a C file exports a "pure" function "my_struct toggle_counter(my_struct x);". "my_struct" might be 100 bytes, but there's a defined ABI for passing it on the stack
21:08:43 <MichaelBurge> pacak: I'd expect the FFI to be able to define a pure function "toggle_counter :: MyStruct -> MyStruct" using it, with MyStruct being an opaque type known to be 100 bytes
21:09:15 <pacak> I suspect you'll need to pass it as a pointer to a helper  function
21:09:19 <pacak> in C
21:09:32 <pacak> And then copy it so it looks like it's on the stack...
21:09:42 <geekosaur> MichaelBurge, passing structs on the stack is such a nasty edge case in C that no FFI I'm aware of tries to handle it
21:10:03 <antalsz> byorgey: Thanks – ideally I’d like something more targeted, but that will work
21:10:04 * mbrock wonders how good GHC is at knowing when to specialize functions...
21:10:35 <antalsz> (I updated XCode or something recently and now every linking step spits out “ld: warning: object file (…) was built for newer OSX version (10.11) than being linked (10.10)”
21:10:37 <antalsz> )
21:10:40 <mbrock> maintaining a bunch of specialize annotations is kind of horrible, but I also don't want to feel like I could randomly hit performance regressions
21:11:10 <geekosaur> essentially only the C compiler itself gets it right. best bet for FFI of functions like that is C wrapper functions which take pointers so you can FFI to them sanely
21:11:28 <mbrock> I basically wish I could say "for all functions of type `T a => ...`, please specialize to `a ~ T1` and `a ~ T2`"
21:11:29 <pacak> mbrock: That's why you have tests :)
21:11:40 <mbrock> yeah, good point
21:11:49 <pacak> mbrock: Depending on function you can simply mark it as INLINEABLE
21:12:07 <mbrock> hmm...
21:14:14 <MichaelBurge> geekosaur: I suppose a 10-element struct can't simply be passed as if the function took 10 arguments, because that would split part of it into registers, making indexing into it difficult
21:14:57 <geekosaur> that and other things. someone tried to decipher this a couple months ago elsewhere and discovered that where stuff gets put on the stack changes oddly based on precise details of the struct
21:15:17 <geekosaur> and sometimes also includes a pointer to the stack-stored struct and sometimes not (!)
21:15:25 <geekosaur> it's just Bad.
21:37:09 <Axman6> C is hard
21:37:15 <Axman6> let's go shopping
21:54:21 <jle`> oh man new aeson version makes Option an abstract data type
21:55:27 <grunt_> What do you guys think about ACM questions, how good are they as a measurement of a programmer's skills?
21:55:43 <grunt_> Lately I've been looking through some of them and got really frustrated
21:57:27 <pikajude> jle`: which version?
21:57:52 <jle`> pikajude: 1.2.2.0, came out yesterday
21:59:20 <jle`> it looks like that's the only major API change
22:00:16 <pikajude> oh
22:00:39 <pikajude> not familiar with Option
22:00:51 <pikajude> and i can't find it in the index
22:00:55 <jle`> Options, sorry
22:00:57 <pikajude> but, that sounds neat
22:00:57 <pikajude> oh
22:01:07 <jle`> it's just how you configure the json encoding for your generic type
22:01:14 <jle`> usually you'd use record syntax to set the options
22:01:31 <jle`> but now you have to work with helper functions instead of directly using record setters
22:12:26 * hackagebot snap-server 1.0.3.2 – A web server for the Snap Framework – https://hackage.haskell.org/package/snap-server
22:30:41 * hackagebot snap-server 1.0.3.3 – A web server for the Snap Framework – https://hackage.haskell.org/package/snap-server
23:20:26 <ongy> what could be the reason for cabal to fail to build without any error message? I get 'building double-conversion' and then it exits with status 1, without any error message
23:20:41 <ongy> (with new-build)
23:21:36 <cocreature> ongy: which version of cabal?
23:21:51 <ongy> cabal-install version 1.24.0.1
23:22:24 <cocreature> I’ve seen similar behavior with 1.24 quite a few times but I don’t know the cause. if you want to use new-build I highly recommend to use 2.0 or even HEAD
23:22:33 <ongy> trying to install double-conversion directly, and not pulling it by the dependency tree, revealed gcc is throwing an error because 'cc1plus' can't be executed. is that something that should be reported to package maintainers?
23:23:31 <ongy> ah, installing g++ fixes it.
23:24:05 <ongy> cocreature: I'm having some fun with lxc right now, and am too lazy to figure out how to install latest cabal+ghc on debian. It ships 8.0.2 ghc (stretch), which is fine at the moment
23:25:02 <cocreature> ongy: fair enough but then I would recommend to not use new-build. there are way too many problems with new-build in 1.24 to use it for anything serious.
23:25:11 <cocreature> ongy: also you should be able to upgrade cabal-install without upgrading ghc
23:32:35 <ongy> what's the easiest way? I had my PKGBUILD, but on debian?
23:34:01 <cocreature> just use your cabal 1.24 to install cabal-2.0
23:34:13 <cocreature> and copy the resulting binary somewhere in PATH
23:45:34 * hackagebot fresco-binding 0.3.0 – Fresco binding for Haskell – https://hackage.haskell.org/package/fresco-binding
23:45:34 * hackagebot HGamer3D 0.9.0 – Toolset for the Haskell Game Programmer – https://hackage.haskell.org/package/HGamer3D
23:55:04 <CindyLinz> hgamer... hum....
