00:01:12 <ski> mniip : the latter of is translated by translating the subterm-in-context `(f,x),y |-> f (x,y)', which requires translating the subterm-in-context `(f,x),y |-> (x,y)', which finally requires translating `(f,x),y |-> x' and `(f,x),y |-> y'
00:02:37 <ski> mniip : a variant is to not use binary products for the translation of the context itself, but instead use "indexed products" (record types). then the translation of each variable will be just a single projection, not a sequence of projections
00:04:08 <ski> mniip : in a topos, we also have a "subobject classifier" object, aka a "truth-value object", which we can think of roughly as `Bool' (though it need not be boolean/two-valued) or `Prop' (the type or kind of propositions)
00:06:22 <ski> mniip : if we write this object as `Omega' (traditional) we have `and,or,implies : Omega * Omega >---> Omega',`not : Omega >---> Omega' (`not' needn't be its own inverse, in general). for an object `X', we have quantifiers `forall_X,exists_X : (X -> Omega) >---> Omega'
00:07:16 <ski> mniip : a morphism from `A' to `Omega' is a property/predicate on `A'. a morphism from `A * B * ... * Z' to `Omega' is a relation between `A',`B',...,`Z'
00:08:41 <ski> mniip : an inhabitant of `A -> Omega' describes a "subset" of `A'. the elementhood relation `in : (A -> Omega) * A >---> Omega' is simply `apply'
00:09:48 <ski> mniip : `{x : A | ..x..}' a term of type `A -> Omega', iow a subset of A', is simply syntactic sugar for `\x |-> ..x..'
00:11:00 <ski> mniip : using this, one can express (intuitionistic !) logic, and set theory, inside any topos
00:16:36 <ski> mniip : e.g., in the category of (directed, loop-allowing, multi-)graphs, `Omega' is a graph with two nodes, say `True' and `False', and five edges, `true : True >---> True',`false : False >---> False',`ends : True >---> True' are loops on the nodes, and then there's also `source : True >---> False',`target : False >---> True' edges between the two nodes
00:18:40 <ski> mniip : this is used to describe the "truth-value" of a node or an edge being included in a subgraph of a graph `G'. the predicate `in_my_subgraph : G >---> Omega' will map nodes in `G' to `True' when they're in the subgraph, and to `False' when they're not
00:20:09 <ski> mniip : it'll map edges that are in the subgraph to `true', while if an edge is not in, but both its source and target ends are, it'll be mapped to `ends'. if only the source of it is in, then it's mapped to `source'. if only the target, then `target'
00:21:59 <ski> mniip : another example is the category of (discrete) dynamical systems. an object is a pair of a set `A' and an endofunction `f : A >---> A' (thought of as "taking a step of time"), morphisms are functions between sets, such that stepping time in the domain, and then converting to the codomain is the same as first converting to the codomain, and then stepping time
00:23:47 <ski> mniip : here, the subobject classifier `Omega' looks like `0 |---> 1 |---> 2 |---> ...     infinity |-> infinity', `0' is "true", `infinity' is "false"
00:24:49 <ski> mniip : a predicate of type `D >---> Omega' describes a sub-(dynamical system) of `D', mapping points in `D' that are in to `0'/true; points that are outside, but will come inside in one step, to `1'; points that will come inside in two steps to `2'; ...; points that will never arrive inside to `infinity'
00:26:26 <ski> (once inside, you can never leave. this follows from the predicate being a morphism of dynamical systems, from `D' to `Omega'. it is also possible to describe another object `chaotic_Omega', so that morphisms to it correspond to arbitrary subsets, not just sub-(dynamical systems))
00:27:05 <ski> mniip : if you feel like, you could try figuring out how the categorical product, and the exponential object, looks like in these two categories
00:28:45 <ski> (also note that in both cases, `not' is not an involution (aka self-inverse), in the first case `not . not' maps `ends' to `true'. in the second case any positive (finite) integer is mapped to `0' (btw, what is `and' and `or' here ?))
00:32:31 <nhooyr> how does haskell compare to elixir for the web? in terms of concurrency and whatnot.
00:35:04 <cocreature> is the way ghc _implements_ exceptions described somewhere? I’m somewhat familiar with the way this is done in C++ compilers, but I’d imagine GHC does things differently
00:39:03 <tsahyt> I have a foldr that I'd like to make strict for testing purposes (profiling shows that a lot of allocations and time are spent there). is there any reason to use foldl' here instead of simply going with foldr'?
00:40:06 <cocreature> tsahyt: making foldr strict usually has no effect. e.g. if you use foldr (+) 0 to calculate the sum, you’d still end up with x + (y + (…)) and while you are walking through the list no evaluation can take place
00:40:21 <tsahyt> right, foldl' it is then
00:40:32 <tsahyt> I'm doing a bunch of inserts into a HashPSQ
00:40:37 <cocreature> tsahyt: for foldl on the other hand you end up with ((x + y) + z) + … so strictness forces GHC to do the sums immediately
00:40:55 <tsahyt> what is foldr' good for then?
00:41:23 <cocreature> I’ve never seen a good use for it :) (but ofc that doesn’t mean that one doesn’t exist)
00:41:37 <ski> tsahyt : `foldr' should typically be used when your list could be infinite ior you're computing a larger (incremental) structure as result, not just a small summary of the elements
00:42:22 <cocreature> ski: but when do you use foldr' over foldr?
00:42:34 <ski> i have never used  foldr'
00:42:42 <cocreature> yeah me neither
00:42:59 <cocreature> I was surprised that this is even in "base" but apparently it is
00:42:59 <opqdonut> is there a foldr'?
00:43:00 * ski isn't even sure how it's defined
00:43:04 <tsahyt> opqdonut: yes in Data.Foldable
00:43:05 <cocreature> it’s in Data.foldable
00:43:11 <opqdonut> let's see
00:43:19 <ski> perhaps someone thought it should be added "for symmetry"
00:43:27 <cocreature> foldr' is implemented in terms of foldl …
00:43:49 <opqdonut> oh right it's in the Foldable class
00:43:59 <opqdonut> so a two-ended collection can implement an efficient fold
00:44:17 <opqdonut> that makes sense
00:44:24 <opqdonut> doesn't make any sense for lists though
00:44:26 <ski> i see
00:44:43 <cocreature> ah yeah for nonlists it makes sense
00:48:32 <tsahyt> hmm, using foldl' over foldr didn't help at all. so strictness is probably not the issue then I suppose
00:49:35 <cocreature> tsahyt: decreasing the stack size is a pretty good way to check if you have a spaceleak caused by insufficient strictness
00:49:45 <cocreature> there are some false positives but they are usually easy to spot
00:50:31 <nhooyr> what are the best resources for learning haskell? https://www.haskell.org/documentation has many and I'm not sure which to choose
00:50:58 <tsahyt> I'm using the entire result right afterwards. Besides I've done some memory profiling already and it looked reasonably alright
00:52:46 <tsahyt> cocreature: what would be a low enough value to check? it runs fine with -K1M
00:53:10 <cocreature> tsahyt: I usually run with -K1K
00:53:22 <cocreature> I stole that from neil mitchell
00:53:59 <ski> nhooyr : i learned from "Haskell: The Craft of Functional Programming", by Simon Thompson
00:54:01 <tsahyt> that does not run, but I don't even get to the critical part of the program with it
00:54:19 <nhooyr> ski: thanks
00:54:26 <cocreature> tsahyt: I then use -xc to figure out where it’s failing
00:54:48 <cocreature> tsahyt: but if your memory usage is not unreasonably high it’s probably not worth the effort
00:54:56 <ski> @where CIS194
00:54:57 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
00:55:17 <ski> nhooyr : ^ also seems to be often suggested, nowadays
00:55:27 <ski> and then
00:55:28 <ski> @where NICTA
00:55:29 <lambdabot> https://github.com/nicta/course
00:55:34 <tsahyt> cocreature: usually it isn't. but in general this is some very very expensive stuff I'm doing here, so it might become an issue on large instances.
00:55:38 <tsahyt> I think it's worth checking it out anyhow
00:55:43 <ski> nhooyr : you could possible also try
00:55:47 <ski> @where HaskellBook
00:55:47 <lambdabot> http://haskellbook.com
00:56:02 <cocreature> tsahyt: the most important false positive is mapM/sequence.
00:56:23 <ski> nhooyr : and #haskell-beginners, which goes together with that book. though note that beginner/newbie questions are also welcome in this channel
00:56:23 <cocreature> (mapM_ is not affected)
00:56:27 <tsahyt> false positive in what sense?
00:56:39 <nhooyr> ski: thanks for all the help!
00:56:43 <ski> nhooyr : if you like pretty pictures
00:56:46 <ski> @where LYAH
00:56:46 <lambdabot> http://www.learnyouahaskell.com/
00:56:58 <cocreature> tsahyt: in the sense that insufficient strictness is not the reason why it’s using more stack space
00:56:58 <nhooyr> and it's free online :D
00:57:08 <ski> nhooyr : but i've heard people saying that it doesn't really explain things that well. you could try it a little, i guess
00:57:27 <tsahyt> alright. so far any strictness annotations have only made it worse.
00:57:51 <tsahyt> I'm mostly looking at time here rather than space.
00:58:40 <tsahyt> hmm, no this benchmark reports 39MB total memory. space is alright I guess.
00:59:48 <cocreature> tsahyt: so is it just being slower than you would like/expect it to be?
00:59:53 <tsahyt> yes, much slower
01:00:48 <tsahyt> and profiling suggests that most of the time goes into things other than the main chunk of the work, which I've paid very close attention to while implementing
01:00:49 <cocreature> tsahyt: running with "+RTS -s" gives you a productivity value that can sometimes be helpful to make sure that it’s your program being slow and not your program being slowed down by the GC
01:01:02 <tsahyt> 91.5% productivity. not ideal.
01:01:11 <cocreature> not that bad either
01:01:30 <tsahyt> could be worse, yeah. profiling suggests that most of the time is spent updating this priority queue
01:01:47 <tsahyt> well, it's the cost center for the new queue to be precise
01:02:50 <tsahyt> hmm, when inlining happens, can that "merge" cost centers?
01:03:10 <cocreature> I think so
01:03:45 <tsahyt> right, that opens up some more possibilities then. The fold can't possibly be the problem I think.
01:03:51 <tsahyt> especially not when it behaves the same with a strict fold
01:04:34 <tsahyt> worst case, it's just slow because it happens *a lot*, several hundred of million times throughout the benchmark
01:04:43 <tsahyt> but it's worth investigating I think
01:05:52 <tsahyt> cocreature: btw, thanks for the lrucaching package again, it's helping a lot in making this fast
01:06:17 <cocreature> tsahyt: I’m happy you find it useful. if you have any suggestions for improvements I’m all ears :)
01:08:33 <mbuf> ski, does the Haskell Book also have answers to exercises?
01:08:56 <ski> mbuf : i don't know, ask in #haskell-beginners
01:09:37 <mbuf> ski, okay
01:11:00 <ski> nhooyr : perhaps also see <http://dev.stephendiehl.com/hask/>,<http://reinh.com/notes/posts/2014-07-25-recommended-reading-material.html>. by the author of HaskellBook, <http://bitemyapp.com/posts/2014-04-29-meditations-on-learning-haskell.html>,<http://bitemyapp.com/posts/2014-12-31-functional-education.html>,<https://github.com/bitemyapp/learnhaskell> might be interesting
01:12:01 <ski> nhooyr : also make sure to ask questions here (or #haskell-beginners or both), or on the mailing list. we generally try to be a helpful bunch
01:12:23 <ski> (s/the author/one of the authors/)
01:13:37 <tsahyt> cocreature: the only "issue" I had related to it was that it would build up more memory than I thought was necessary at first. my keys are HashSets, and it of course needs to hold on to the entire thing rather than just the hash in case of collisions, so I think there's not much you can do there.
01:14:05 <tsahyt> but the memory usage tapers off after a while of course, and it's not preposterous. it's just the normal space/time tradeoff you make when employing a cache to begin with.
01:14:39 <cocreature> yeah I don’t think I can do anything about that
01:15:02 <nhooyr> ski: will do thanks
01:15:14 <tsahyt> it's not a problem, it was just a bit confusing when I started profiling and the heap profile reported a buildup from the function building those hash sets
01:16:32 <ski> (<https://web.archive.org/web/20160304014155/https://superginbaby.wordpress.com/2014/11/18/learning-haskell-as-a-nonprogrammer/>,<https://web.archive.org/web/20161220155503/https://superginbaby.wordpress.com/2014/12/31/teaching-how-to-learn/> by the other author might also be interesting)
01:17:37 <Tspoon> nhooyr: as a complete haskell newbie, I have found LYAH a beginner friendly introduction to the language. it might cut some corners, but at least it is usually made clear when that happens
01:25:36 <nhooyr> ok thanks
01:29:46 <kmelva> if I have in a do block `foo <- doFoo`, how can I add a type annotaion what should foo be?
01:30:00 <kmelva> just doing `foo :: BlahBlah <- doFoo` trows errors... 
01:30:37 <mutsig> Type annotations should come after the expression
01:32:38 <tsahyt> Tspoon: I think that's alright. Just like you learn how to do arithmetic so you can do useful things long before you learn about how numbers have group structure etc. Learning is a kind of iterative deepening process imo.
01:33:15 <kmelva> mutsig: but then... it sets the type for the expression right of the `<-`
01:33:37 <kmelva> I want to annotate foo, which is no longer IO a, but just a
01:33:48 <kmelva> I don't know if I'm making myself clear :)
01:38:12 <roxxik> kmelva: you can't have that ;)
01:38:24 <roxxik> (at least the last time i tried)
01:38:50 <kmelva> roxxik: aaaaaawh, too bad... well, not that big of  deal to stick IO in front... thanks you guys :)
01:39:31 <tsahyt> yes you can
01:39:44 <tsahyt> you'll need ScopedTypeVariables though
01:41:40 <kmelva> ah well, still not worth it... I still have fear of extensions :)
01:42:12 <tsahyt> kmelva: scoped type variables is nothing scary, and doesn't break anything to the best of my knowledge.
01:44:56 <mutsig> imo, avoiding extensions is a good thing if you don't really need them.
01:45:06 <roxxik> kmelva: i'm really not sure right now if it broke for me because of ScopedTypeVariables or other stuff, but you can try using a concrete type, if it works, then `a` not working is really a ScopedTypeVariable thing
01:51:33 <tsahyt> relevant stackoverflow post http://stackoverflow.com/questions/29395265/haskell-scopedtypevariables-needed-in-pattern-matching-type-annotations
01:55:38 <ski> @type do x :: Int <- readLn; return (x+1)
01:55:40 <lambdabot> IO Int
01:55:40 <ski> kmelva ^
01:56:33 <ski> you need to enable either `PatternSignatures' or `ScopedTypeVariables', though
01:56:46 <ski> (oh, tsahyt said)
01:57:07 <tsahyt> TIL about pattern signatures
01:57:32 <ski> unfortunately they're being obsoleted :(
01:57:48 <ski> (or deprecated, at least)
01:58:04 <raichoo> oh?
01:58:19 <tsahyt> hmm, on 8.0.1 I don't see them at all
02:02:41 <ski> (imho, the syntax for `ScopedTypeVariables' is confusing/backwards. i preferred `PatternSignatures' to it)
02:02:55 <HugoDaniel> has anyone here used this: https://downloads.haskell.org/~ghc/7.0.1/docs/html/users_guide/rewrite-rules.html ?
02:09:14 <tsahyt> ski: what was the syntax with PatternSignatures?
02:20:27 <ski> tsahyt : you just put a type ascription on your pattern (either argument (or lambda or `case') pattern, or as a result signature on the definiendum (left-hand side in a definition, what is to be defined), as in `foo x y :: [a] = ..x..y..a..')
02:21:51 <ski> (the former case would be `foo (x :: [[a]]) y = ..x..y..a..' or `\(x :: [[a]]) -> ..x..a..' or `case ... of x :: [[a]] -> ..x..a..', also `do x :: [[a]] <- ...; ..x..a..', and presumably also in list comprehensions)
02:24:24 <ski> @type \xss -> [f x | xs :: [a] <- xss,let {f :: a -> [a]; f y = xs ++ y : xs},x <- xs]  -- yes
02:24:26 <lambdabot> [[a]] -> [[a]]
02:24:39 <ski> @type \xss -> [f x | xs :: [a] <- xss,let {f :: b -> [b]; f y = xs ++ y : xs},x <- xs]
02:24:41 <lambdabot> error:
02:24:41 <lambdabot>     • Couldn't match type ‘a’ with ‘b’
02:24:41 <lambdabot>         because type variable ‘b’ would escape its scope
02:28:29 <tsahyt> ski: but that also works with scoped type variables, e.g. do (x :: Int) <- readLn
02:32:07 <ski> tsahyt : yes, they added an exception to the scoping rules to allow this (specifically the existential case, which would be clunky otherwise)
02:35:02 <ski> (well, specifically needed for the existential case, i mean. but it applies also to the other cases .. but not to pattern bindings, which `PatternSignatures' doesn't cover, either)
02:35:07 <ski> @type \xs0 -> let xs :: [a] = xs in let f :: a -> [a]; f y = xs ++ y : xs in map f xs0
02:35:08 <lambdabot> error:
02:35:08 <lambdabot>     • You cannot bind scoped type variable ‘a’
02:35:08 <lambdabot>         in a pattern binding signature
02:37:49 <tsahyt> so here you'd need a type signature with a forall a?
02:39:55 <ski> you could use `\(xs0 :: [a]) -> let xs :: [a] = xs0 in ..xs0..a..xs..'
02:40:52 <ski> or `let foo :: forall a. [a] -> [[a]]; foo xs0 = let xs :: [a] = xs0 in ..a..xs0..xs.. in foo', yes
02:50:32 <reactormonk> Starting from https://hackage.haskell.org/package/uri-bytestring-0.2.2.1/docs/URI-ByteString.html#v:authorityL how do I construct a `Lens' (URIRef a) (Maybe ByteString)` with `authorityL`, `AuthorityHostL`, `hostBSL`?
02:50:39 <reactormonk> Not sure how to deal with the Maybe in there.
03:00:34 <reactormonk> Ah, I'm looking for (a -> b) -> Maybe a -> Maybe b
03:02:03 <fractalsea> reactormonk, that's fmap
03:02:47 <reactormonk> ohh.
03:03:53 <Iceland_jack> fmap @Maybe
03:05:12 <Iceland_jack> I see lambdabot still hasn't enabled TypeApplications
03:09:21 <reactormonk> Hmm, nope, doesn't seem to work out as expected when combining lenses.
03:10:43 <ttoe> if hlint tells me about eta reduce and i follow it's suggestion, is the code compiled exactly the same as if i did not?
03:11:48 <opqdonut> ttoe: the way to be sure is to check whether the core output changes
03:12:54 <ttoe> okay, thanks
03:14:06 <opqdonut> ttoe: so compile with -ddump-simpl for instance
03:14:39 <quchen> ttoe: Eta reduction is generally not a valid transformation in neither GHC nor Haskell, cf. https://github.com/quchen/articles/blob/master/fbut.md#f-x---is-not-f--x---
03:15:56 <opqdonut> that's for toplevel stuff though
03:16:06 <opqdonut> how about the expression (\x -> f x) vs the expression f
03:17:26 <opqdonut> s/toplevel/defining a function/
03:17:55 <quchen> In that case you still have GHC’s inlining behaviour
03:18:21 <quchen> And that’s not even taking into account strictness
03:18:33 <quchen> > error "broken" `seq` ()
03:18:36 <lambdabot>  *Exception: broken
03:18:50 <quchen> > (\x -> error "not broken" x) `seq` ()
03:18:53 <lambdabot>  ()
03:19:38 <quchen> In other words, (\x -> f x) is never ⊥, even when (f) is
03:20:49 <ttoe> quchen: thanks, will read
03:22:34 <quchen> ttoe: The good news is that this rarely matters, so for the most part you can just choose whatever is nicer to read.
03:28:28 <quchen> ttoe: Concerning HLint, I disable that warning because eta-reducing everything is bad style in my opinion.
03:29:48 <quchen> -> HLint.hs   https://github.com/quchen/stgi/blob/master/HLint.hs
03:34:05 <nhooyr> was there ever a solution to https://www.reddit.com/r/haskell/comments/1xvsqg/update_the_problem_with_hot_code_reloading_in/ ?
03:42:35 <jophish> tdammers: Would it be easy to add "space case" to casing. where the words are distinguished by spaces?
03:42:49 <jophish> I'd like to convert from "some string" to "some-string"
03:43:48 <noan> map the space char to - in the input string?
03:44:45 <jophish> noan: that's always an option, I think it would fit quite well in the casing package though
03:45:34 <demoninajar> not sure if this is off-topic but any ideas on writing a composition operator such that that f <$$> g1 <$$> g2 <$$> .. <$$> gn = \x1 x2 .. xn -> f (g1 x1) (g2 x2) .. (gn xn) ?
03:49:06 <maffh> Hello, I am trying to install wxhaskell on Windows 10 using this wiki https://wiki.haskell.org/WxHaskell/Windows. Unfortunately, I don't think I can use the easy way installation. So I tried installing wxWidget using the section "1.2 Installing the hard way". This seemed like it worked because I did not receive any errors.  However, when I tried running this command: "cabal install wx" this resulted in the following error:"This version of wxc requi
03:49:06 <maffh> res one of the following wxWidgets versions to be available: ["3.0","2.9"]". I am not sure what I did wrong. Does somebody maybe have some tips on how to possibly solve it?
03:52:38 <tdammers> jophish: I think that should be perfectly possible
03:53:47 <opqdonut> demoninajar: That's "f <$> g1 <*> g2 <*> g3" in the (e->) applicative
03:54:30 <Sindriava> Could someone help me install Hakyll?
03:54:38 <opqdonut> > let f x y z = x+y+z in f <$> succ <*> pred <*> (*2) $ 2   -- demoninajar 
03:54:41 <lambdabot>  8
03:54:52 <Sindriava> `stack install hakyll` fails on "Error: While constructing the build plan"
03:59:41 <Sindriava> I guess I need to change the resolver somehow, to allow me to install hakyll? Gotta say, stack doesn't do a very good job of explaining what I should be doing :/
04:01:39 <tabaqui1> If I have "recursiveIO = forever $ some_action >> recursiveIO" will I get memory leaks?
04:02:04 <ski> opqdonut : no it's not
04:02:26 <tabaqui1> I've already asked about some recursive IO, but it's still somewhat wild for me
04:02:47 <tabaqui1> *recursiveIO :: IO ()
04:03:07 <tdammers> tabaqui1: there won't be memory leaks, the `forever` is just redundant
04:03:29 <demoninajar> @opqdonut that turns f to a function taking a single argument
04:03:29 <lambdabot> Unknown command, try @list
04:03:30 <tdammers> unless some_action itself is leaky, of course
04:04:03 <tabaqui1> tdammers: not in my case, there is if/then/else inside
04:04:04 <opqdonut> ski: demoninajar: oh right
04:04:35 <tdammers> tabaqui1: then no problem
04:04:58 <merijn> I think not, but you can always benchmark :)
04:05:07 <merijn> If you do it's not that hard to fix
04:05:27 <tabaqui1> tdammers: ok, thanks
04:05:34 <tdammers> tabaqui1: mentally stepping through the evaluation/execution helps a ton
04:05:35 <merijn> 'fix $ \loop -> myAction >> loop' <- fixed
04:05:49 <tabaqui1> merijn: I'm not sure about ghc optimizations
04:05:52 <tdammers> tabaqui1: as long as you remember that evaluation is non-strict
04:06:02 <demoninajar> I /think/ this should require quite a few language extensions  and some typeclass abuse but hopefully I am wrong
04:06:04 <tabaqui1> it's pretty hard for me to catch leaks in lazy runtime
04:06:29 <tdammers> someAction >> recursiveIO -- when the runtime sees this, it figures out that in order to run it, it needs to evaluate someAction, so it does that
04:06:54 <tdammers> but it doesn't fully evaluate the >> expression yet, just the first operand
04:07:01 <tdammers> that's enough to start running it
04:07:02 <merijn> tdammers: Depending on your monad instance and inlining, the >>= might end up allocating repeatedly
04:07:31 <merijn> tabaqui1: But eh, isn't the forever redundant in that example?
04:07:58 <tabaqui1> merijn: I have something like
04:08:30 <tabaqui1> forever $ action >>= (\err -> when err then recursiveIO)
04:08:40 <tabaqui1> so I need forever here
04:08:48 <tabaqui1> *when err recursiveIO
04:09:42 <tdammers> @src forever
04:09:43 <lambdabot> forever a = let a' = a >> a' in a'
04:09:48 <tdammers> tabaqui1: ^
04:10:35 <tdammers> it's going to recurse either way, either through forever, or explicitly
04:10:39 <tabaqui1> tdammers: yeah, right
04:10:51 <merijn> tdammers: Forever is more efficient, though
04:10:56 <merijn> That's why it's defined like that
04:10:57 <tabaqui1> but where will go memory allocated for err, for example?
04:11:06 <merijn> tabaqui1: GC
04:11:24 <tdammers> merijn: true, although I believe the gain is tiny when it comes to IO
04:11:40 <tabaqui1> gc, gc
04:11:46 <tdammers> garbage collection
04:11:48 <tabaqui1> everybody tells gc
04:11:53 <tabaqui1> it's so easy in C)
04:12:35 <tabaqui1> maybe I should trust another developers
04:14:04 <tabaqui1> hackage has broken link to "data IO" source
04:14:25 <merijn> tabaqui1: link?
04:14:28 <tsahyt> nice
04:14:33 <tsahyt> oh, wrong buffer, sorry
04:14:50 <tabaqui1> https://hackage.haskell.org/packages/archive/%01/%02/doc/html/src/GHC-Types.html#IO
04:15:07 <tabaqui1> %01, %02 in url?
04:16:34 <merijn> It doesn't have a source link (as it should), but Haddock is rendering it wrong
04:16:40 <merijn> Notice the absence of "source"
04:16:54 <merijn> Where'd you get that links from?
04:17:00 <ph88> hi guys, i made this code that works with GHC.Generics and it works. Could anyone have a look at my code and see if there are some things left that still can be improved?  https://paste.fedoraproject.org/542869/37744148/
04:17:04 <tabaqui1> https://hackage.haskell.org/package/base-4.6.0.0/docs/System-IO.html
04:17:12 <tabaqui1> reference to "data IO a"
04:17:52 <merijn> tabaqui1: Note that has no "source", unlike all the others
04:18:13 <merijn> oh, that one does
04:18:23 <merijn> tabaqui1: That's a way old version, though
04:18:41 <merijn> tabaqui1: https://hackage.haskell.org/package/base-4.9.1.0/docs/System-IO.html
04:19:31 <tabaqui1> ok, thx
04:20:36 <merijn> tabaqui1: Are you using Chrome?
04:21:26 <tabaqui1> nope, firefox
04:21:29 <tabaqui1> why?
04:21:36 <merijn> Ah, not sure if it exists for Firefox
04:21:52 <merijn> tabaqui1: There's a Hackage-Fu extension for Chrome that adds a warning if your browsing old docs + link to latest
04:21:55 <merijn> https://chrome.google.com/webstore/detail/hackage-fu/dnpldbohleinhdgfnhlkofpgkdcfcfmf
04:22:53 <merijn> There seems to be a basic firefox port, but it probably needs work
04:22:57 <merijn> https://github.com/statusfailed/hackage-fu
04:25:51 <tabaqui1> there is plugin with which it can use google extensions if FF
04:26:12 <tabaqui1> dunno, I don't have problems with docs usually
04:36:01 <tdammers> jophish: http://hackage.haskell.org/package/casing-0.1.1.0/docs/Text-Casing.html#toWords
04:56:02 <reactormonk> I've got a record Request { host :: ByteString }, and a Maybe ByteString. How do I maybe update the record?
04:57:03 <hpc> decide what you want out of the Just case, and then decide what you want out of the Nothing case
04:57:33 <hpc> and then see if that lines up with anything that already exists, or write your own thing
05:01:35 <piyush-kurur> request for help from anyone with openbsd+haskell.
05:01:37 <reactormonk> I'd guess there something I could do with lenses?
05:03:13 <piyush-kurur> i would like someone to confirm that raaz compiles with openbsd (http://github.com/raaz-crypto/raaz)
05:04:12 <piyush-kurur> essentially I have used arc4random for entropy on openbsd which needs to be tested
05:07:09 <piyush-kurur> https://github.com/raaz-crypto/raaz/issues/298
05:29:26 <jophish> tdammers: amazing, thanks!
05:30:27 <ocharles> reactormonk: fmap (\a -> r { host = a}) maybeBytestring  is one option
05:30:39 <ocharles> err
05:30:50 <ocharles> well, it certainly is one option, but it's probably not what you want :p
05:31:10 <reactormonk> ocharles, I have about 6 updates, about 3 with Maybe
05:31:12 <ocharles> perhaps   fromMaybe r (fmap (\a -> r { host = a}) maybeBytestring)    is better
05:31:38 <ocharles> reactormonk: lift the non-maybes into maybe with Just, then compose the whole thing with applicative. But there's not enough information in your question to provide a good answer
05:31:41 <ocharles> there are multiple strategies
05:31:58 <ocharles> Should the update happen if *all* Maybe's are Just? Or should we just filter the "Just"s out and ignore the Nothings?
05:32:08 <reactormonk> https://gist.github.com/d3d1248d5e1b88cf2ad2cfcf2c96aa50
05:32:34 <reactormonk> Don't set the Just, update everything else.
05:37:19 <mbrock> interesting how the Turtle library doesn't seem to provide a function of type Shell Line -> IO Text
05:37:51 <merijn> Man...sometimes I really wish we had first-class patterns...
05:38:31 <mbrock> (...and interesting in general how hard most programming languages make it to run another program and get the content of stdout...)
05:44:07 <merijn> There's no way to match an (unknown) constructor which must have one field, is there?
05:47:09 <bwe> Is there a Haskell Q&A tool similar to stackexchange?
05:49:44 <quchen> bwe: In order of increasing longevity of the question/answer: IRC, Reddit, Stackoverflow.
05:49:56 <merijn> bwe: There are a LOT of high profile haskellers on stackoverflow
05:50:16 <quchen> merijn: »case Just x of _ y -> y«? Nope
05:50:25 <merijn> quchen: Sadly not :\
05:51:06 <bennofs> merijn: can probably do that with ghc generics
05:51:20 <merijn> quchen: I'm extracting a bunch of boilerplate into a function, but that requires me to both construct and pattern match on some values, but I have no way to write that easily
05:52:01 <bwe> quchen, merijn: I rather mean a tool written in Haskell providing a web interface for Q&A like Stackoverflow. Not a platform for asking questions related to Haskell.
05:52:03 <quchen> merijn: I’m sure you can unsafeCoerce something together though :>
05:52:15 <bwe> Sorry for the misunderstanding raised.
05:52:24 <merijn> quchen: Not newtypes, I think :\
05:52:34 <merijn> quchen: The datatypes themselves are from persistent
05:52:55 <merijn> bwe: Not that I know, but I'm not that knowledgable about stuff like that :p
05:52:55 <bennofs> merijn: do they have Generic instances?
05:53:42 <quchen> merijn: isUnary = (case unsafeCoerce x of Just{} -> True; _ = False) `catch` (\Segfault -> Nopenopenope)
05:54:18 <merijn> quchen: No, I need access to the field
05:54:24 <merijn> bennofs: No clue, looking it up now
05:54:43 <roxxik> mbrock: inshell?
05:55:47 <merijn> bennofs: hmmm, I don't know how to find out, tbh :p
05:58:01 <merijn> Pretty sure persistent lets you do what I want, but I'll be damned if I understand how :p
05:59:50 <mbrock> I'm having problems using temporary files and `readProcess`: http://lpaste.net/351972
06:00:40 <mbrock> oops, the problem is already with writing to the temporary file, readProcess is irrelevant
06:01:48 <mbrock> ohh, I have to close the handle if I want to use the file path.
06:03:05 <mbrock> roxxik: running programs within the turtle monad is fine, but I found it curiously hard to extract the result to an IO Text action or similar
06:03:19 <mbrock> roxxik: probably I should figure out how to use the Fold stuff but I'm too lazy
06:03:45 <roxxik> Shell Line -> IO Text?
06:03:46 <roxxik> sek
06:05:05 <roxxik> yah you need folds there
06:05:35 <roxxik> list :: Fold a [a] 
06:07:15 <roxxik> \s -> fold list :: Shell a -> [a]
06:07:21 <roxxik> \s -> fold s list :: Shell a -> [a]
06:07:32 <mbrock> thanks!
06:07:43 <roxxik> and then maybe linesToText :: [Line] -> Text
06:08:32 <roxxik> i have to correct: 
06:08:36 <roxxik> \s -> fold s list :: Shell a -> IO [a]
06:10:10 <roxxik> you can compose shells and then print it via view, but accessing the output as a text is not a builtin combinator
06:11:04 <roxxik> \s -> linesToText <$> fold s list :: Shell Line -> IO Text -- final version
06:12:09 <roxxik> wait, Fold has a Functor instance ;)
06:13:00 <roxxik> \s -> fold s (linesToText <$> list) :: Shell Line -> IO Text -- really final version, maybe this is better at fusing... jut guessing here
06:46:45 <ph88^> i made this code that works with GHC.Generics and it works. Could anyone have a look at my code and see if there are some things left that still can be improved?  https://paste.fedoraproject.org/542869/37744148/
07:01:04 <merijn> Any people with persistent experience? I have a bunch of boilerplate and I'd be curious if there's a better way to deal with it...
07:05:07 <jophish> Are there any type systems which track entropy?
07:08:43 <lyxia> ph88^: do you ever use n
07:09:48 <sdx23> jophish: what is "entropy" in this context?
07:10:13 <jophish> sdx23: I'm just trying to think if this is an interesting question or not 
07:10:25 <jophish> I was thinking about ways to help program which deal with cryptography
07:10:40 <jophish> for example affine types can make sure that an IV is never used more than once
07:12:53 <ph88^> lyxia, no, wouldn't know what to use it for
07:14:00 <Benzi-Junior> hey is there a way to have stack dump out the core ?
07:14:08 <lyxia> ph88^: that's something you can simplify
07:14:25 <ph88^> alright
07:14:31 <ph88^> any other tips ?
07:14:49 <lyxia> ph88^: it look alright otherwise.
07:14:57 <ph88^> ok thank you :)
07:22:10 <fuzzyhorns> im in a bit over my head in https://github.com/haskell-servant/servant/blob/master/servant-docs/src/Servant/Docs/Internal.hs#L678 how does a function like docsFor actually execute? i cant seem to get a mental model
07:23:14 <stephaner> I feel a bit embarrassed, I cannot find the problem in this warning: Pattern match(es) are overlapped In an equation for `reducer': reducer c [] = ...    reducer c' (x : xs) = ...      I thought (x:xs) could not be mistaken with []
07:23:15 <fuzzyhorns> i dont really follow how it takes like an api, http://haskell-servant.readthedocs.io/en/stable/tutorial/ApiType.html
07:23:32 <stephaner> could you indicate me what's wrong ?
07:23:59 <merijn> stephaner: Can you lpaste the exact code?
07:24:03 <stephaner> ok
07:26:19 <stephaner> http://lpaste.net/351975    the goal is to make a tokenizer to be used with foldr
07:26:38 <merijn> stephaner: 6 and 9 overlap
07:26:50 <merijn> As do 4 and 5
07:27:06 <merijn> stephaner: sep is a variable
07:27:15 <merijn> you're simply shadowing the existing 'sep' variable
07:27:22 <stephaner> it doesn't take into account the global sep varaible ?
07:27:25 <stephaner> ok
07:27:31 <merijn> stephaner: No, you can only match on literals
07:27:42 <Tuplanolla> It defines another `sep` that shadows the global one, stephaner.
07:27:44 <merijn> Everything else just introduces a new variable that shadows the existing one
07:27:56 <merijn> FYI, -Wall should warn about that
07:27:58 <stephaner> it explains the problem :-)
07:28:20 <merijn> I would generally recommend using -Wall and selectively disabling warnings you don't like
07:29:08 <Tuplanolla> That's not even bad. I've seen `otherwise` get shadowed accidentally. That was a fun one to explain.
07:29:26 <merijn> :D
07:29:28 <stephaner> let's try with Wall
07:30:06 <merijn> On the one hand I get occasionally annoyed about shadowing warnings, otoh, it's really nice to catch mistakes like this :)
07:31:19 <tsahyt> Is there a criterion template for stack somewhere? I need this rather often lately. Just asking before I write my own.
07:31:50 <stephaner> yep, having read this:  This binding for ‘sep’ shadows the existing binding    would have rung a bell :-)
07:31:52 <stephaner> many thx
07:32:54 <merijn> stephaner: Incidentally, if the goal of 'sep' was to factor stuff out you could accomplish something similar using guards
07:33:52 <stephaner> merijn good idea
07:34:53 <lpaste> merijn revised “No title”: “No title” at http://lpaste.net/351975
07:39:56 <nitrix> Now that I think about it, normally universal and existantial quantifiers are used in expressions to make them into propositions.
07:40:05 <nitrix> Does that means type annotations in Haskell are propositions?
07:40:40 <merijn> nitrix: In an unsound logic, yes
07:40:50 <merijn> nitrix: See Curry-Howard
07:40:53 <nitrix> Does that means the programs are inherently proofs?
07:41:06 <nitrix> That seems so backwards to me :P
07:41:11 <nitrix> merijn: Checking.
07:41:18 <ertes> helo
07:41:21 <ertes> nitrix: yes
07:41:21 <exio4> nitrix: the curry-howard correspondence is.. that
07:41:37 <exio4> nitrix: "types are propositions, programs of that type are proofs"
07:42:12 <ertes> nitrix: claim: the statement 'a' implies 'a' for all statements 'a'
07:42:18 <nitrix> I've heard of curry howard being mentioned but I never paid too much attention to the implications and just now, with my newly aquired knowledge, did it click.
07:42:18 <ertes> type version:  forall a. a -> a
07:42:26 <ertes> proof:  id x = x
07:42:44 <merijn> nitrix: Inhabitation of the type 'a' is a proof of proposition 'a'
07:42:56 <nitrix> merijn: ertes Very cool.
07:43:01 <merijn> nitrix: Unfortunately, Haskell is Turing complete and thus all types are inhabited, rendering the logic unsound ;)
07:43:22 <ertes> nitrix: claim: for all statements 'a' and 'b', 'a' implies 'b'
07:43:24 <exio4> @djinn (a -> b) -> (b -> c) -> (a -> c)
07:43:24 <lambdabot> f a b c = b (a c)
07:43:27 <merijn> nitrix: See also this excellent talk by Wadler: https://www.youtube.com/watch?v=IOiZatlZtGU
07:43:40 <merijn> nitrix: I strongly recommend it, very accessible
07:43:48 <ertes> nitrix: nonsense :: forall a b. a -> b  -- can't be proved in a sound logic, but haskell is unsound
07:43:49 <nitrix> merijn: Will do, appreciated.
07:44:14 <Tuplanolla> Follow-up question, nitrix: what does `42 :: Int` prove?
07:44:15 <tsahyt> so I've spun up a quite criterion benchmark for foldr (+) 0 over lists, vectors, and hashsets. These are the results http://sprunge.us/Zeih and they are very unexpected for me. How can a HashSet be that much faster than vectors? The elements are of course all disjoint, so all structures have the same number of elements.
07:45:45 <ertes> tsahyt: a + (b + (c + d))  -- c and d are quickly accessible in a HashSet, because it's constructed that way
07:46:08 <ertes> with lists the full list needs to be traversed first
07:46:30 <tsahyt> oh, let me try a left fold
07:46:38 <ertes> tsahyt: should give the same result
07:48:17 <tsahyt> with strict left folds, vectors are by far the fastest
07:48:35 <ertes> tsahyt: properly constructed lists should be just as fast, if not faster
07:49:03 <tsahyt> ertes: http://sprunge.us/cgEg
07:49:24 <tsahyt> foldl/list comes out at 593.7µs, and for vectors it's 266.4µs
07:49:30 <tsahyt> definitely a significant difference there
07:50:21 <tsahyt> maybe I just screwed something up in the benchmark construction
07:50:58 <ertes> tsahyt: try this:  whhf (foldl' (+) 0 . enumFromTo 1) 100000
07:51:02 <ertes> *whnf
07:51:22 <ertes> tsahyt: try this:  whnf (foldl' (+) 0 . enumFromTo 1) (100000 :: Int)
07:51:27 <tsahyt> hmm so this way it would exploit fusion I suppose?
07:51:39 <sdx23> http://termbin.com/s06q what could cause stack to use two different versions of cabal?
07:51:42 <ertes> tsahyt: that, too, but most notably it wouldn't build a list in memory
07:51:49 <nitrix> Tuplanolla: With my limited (and very recent) knowledge of proofs and whatnot, I'd say that possibly it proves that 42 is an inhabitant of the type Int?
07:52:02 <ertes> tsahyt: your 'l' is shared, which ruins everything
07:52:19 <tsahyt> ertes: in my actual use case, I already have data in memory. Right now I'm just trying to eyeball what representation I should go for
07:52:24 <sdx23> nb: I installed gtk2hs-buildtools by stack install ..., because it was not detected as a dependency automatically.
07:52:26 <ertes> it means that your list fold is traversing an actual linked list in memory
07:52:36 <Tuplanolla> It's kind of nice that it proves its own existence, nitrix.
07:52:44 <tsahyt> obviously the folding operation is not a simple (+) either, but I thought I'll use something that is predictable to get a hold of how the actual folding compares
07:53:22 <ertes> tsahyt: whether your data structure is in memory or not is an important piece of information…  if you try the benchmark i gave you, i would expect it to outperform all the others
07:53:26 <ertes> including the vector one
07:53:34 <nitrix> Tuplanolla: Yeah it's a little funny looking but I think I get the point.
07:53:58 <nitrix> Tuplanolla: Seems like a nice foundation to begin the reasoning.
07:54:19 <merijn> hmmm, my traceM doesn't seem to get evaluated each time th code runs
07:54:52 <tsahyt> ertes: correct, it's a lot faster.
07:54:56 <tsahyt> about 10x
07:55:39 <tsahyt> right now I'm storing a HashSet because that was just easy to construct, and for reasons that I forgot about I then end up toList-ing that, and foldr over this. That's hardly ideal, but it gets worse because this code is called many million times over the lifetime of the program
07:56:03 <tsahyt> so that's an obvious inefficiency right there. I think I'll use a vector instead, as that performs best with an already in-memory foldl' it seems
07:56:25 <ertes> tsahyt: toList-ing is fine, as long as you use proper traversals…  for example you would sum with foldl'
07:56:52 <ertes> tsahyt: i would expect (foldl' (+) 0 . Sh.toList) to be just as fast as (Sh.foldl' (+) 0)
07:56:57 <ertes> where Sh is Data.HashSet
07:57:18 <reactormonk> I've got a lens for a Maybe and a record to write data into - how do I maybe update that field?
07:57:36 <ertes> reactormonk: a lens for a Maybe?
07:57:52 <ertes> that sounds not quite right, unless the lens is 'id'
07:57:57 <reactormonk> ertes, the data comes from a lens via _Just
07:58:12 <M0000> is there any chance that combining InterpreterT and InputT is what is causing my segmentation fault?
07:58:19 <ertes> reactormonk: ah, that's a prism, not a lens, but it works as a setter
07:58:25 <nitrix> I thought _Just was a prism.
07:58:39 <reactormonk> ertes, oops. So I have a prism to get data from, and a record to maybe update.
07:58:43 <ertes> reactormonk: _Just . myField %~ f
07:58:50 <ertes> like this?
07:59:47 <ertes> composing a prism with a lens yields a traversal, so you can use it as a setter and *sometimes* as a getter
07:59:57 <jophish> joeyh: Where's a good place to raise an issue about concurrent-output?
08:00:04 <jophish> (nothing major, just documentation)
08:00:05 <tsahyt> ertes: maybe it's my benchmark again, but it turns out not to be in this case.
08:00:19 <reactormonk> Yeah, sometimes. Somehow (authorityL .> _Just .> authorityPortL .> _Just .> portNumberL) bugs. (via https://hackage.haskell.org/package/uri-bytestring-0.2.2.1/docs/URI-ByteString.html#g:7 )
08:00:24 <tsahyt> ertes: using whnf (L.foldl' (+) 0 . S.toList) s
08:01:19 <tsahyt> it ends up taking the toList time + the foldl' over the list. I happened to have those benchmarked separately too.
08:01:29 <reactormonk> bugs as in, the view complains about "Could not decuce (Monoid Int) arising from a use of "Just""
08:01:34 <ertes> tsahyt: it may be traversing a highly volatile list, which does add some constant cost
08:01:34 <reactormonk> Eh, _Just
08:01:54 <tsahyt> ertes: highly volatile?
08:01:55 <M0000> I’m getting a seg fault, and I’m wondering if it’s some combination of the things that I’m less experienced with. The main loop is in InputT, and it calls runInterpret (from the Hint module), and also forks threads
08:02:07 <ertes> tsahyt: you only ever see a single cons in memory
08:02:19 <ertes> no actual in-memory linked list
08:02:31 <tsahyt> hmm interesting.
08:02:37 <M0000> doing an experiment right now to reduce the complexity… I got rid of InputT and so far it’s not seg faulting but haven’t built up enough functionality yet to really test
08:03:00 <ertes> tsahyt: basically what would happen with something like (foldl' g z (unfoldr f x0)), if they weren't fused
08:03:18 <ertes> it would still run in constant memory, but there would be some extra cost for constructing and then immediately garbage-collecting cons cells
08:03:51 <tsahyt> hmm okay. so this comes down to fusion not triggering then?
08:05:18 <ertes> tsahyt: yeah, most likely
08:05:43 <ertes> tsahyt: i would expect it to trigger, if used like this:  foldl' (+) 0 (Sh.toList xs)
08:06:46 <ertes> tsahyt: maybe try this, just to help the fusion rules a bit:  whnf (\x -> foldl' (+) 0 (Sh.toList x))
08:06:55 <ertes> i can't imagine that to make a difference, but who knows =)
08:07:38 <tsahyt> hm that still doesn't work.
08:07:57 <tsahyt> In any case, it looks like going for vectors might be the best thing to do
08:08:17 <ertes> depends
08:08:28 <tsahyt> I can still use the HashSet for construction, and build the vector from there. this structure persists through the entire program and never gets changed.
08:08:59 <tsahyt> the more I do this optimization stuff, the more I see why people say that haskell performance can be tricky to reason about
08:09:03 <ertes> indexing and traversal are super-fast for vectors, especially with primitive/storable/unboxed ones, but pretty much everything else is slow
08:09:21 <tsahyt> I only do traversal with this
08:09:44 <tsahyt> thanks for reminding me of unboxed/storable ones though. since I'm basically just storing fancy ints in there, this would be easy to exploit
08:10:17 <ertes> well, since other languages don't give you lazy traversals, there simply is nothing to reason about…  it's like saying: "chainsaws are complicated to use…  kitchen knifes are way simpler!" =)
08:10:21 <merijn> tsahyt: tbh, performance is tricky in many languages if you want to be really fast :)
08:11:08 <tsahyt> agreed
08:11:38 <ertes> tsahyt: let me point your attention to what is probably my favourite sequence/set data structure:  FingerTree v (Vector a)
08:12:01 <ertes> using the 'fingertree' package
08:12:24 <tsahyt> It's been a long time since I last looked at the FingerTree type, but is that roughly a sequence built up from vector chunks?
08:12:33 <ertes> this gives you chunked vectors, so it allows efficient appending, updating, etc.
08:12:41 <ertes> yeah, exactly
08:12:46 <tsahyt> nice. How does this compare to Data.Sequence?
08:12:56 <michaelt> tsahyt: if you are actually using Int, you could substitute Data.Vector.Unboxed 
08:13:14 <michaelt> tsahyt: which is 78.45 μs against 280.2 μs for 'regular' vector
08:13:34 <ertes> tsahyt: well, (FingerTree v a) *is* Data.Sequence, if you choose v to measure every individual element as 1
08:13:39 <aweinstock> why doesn't Bool instantiate Data.Bits.Bits?
08:13:45 <tsahyt> 78.45? I'm getting 212 here. wait let me check if I messed up somewhere
08:14:07 <tsahyt> hmm, no seems okay
08:14:22 <nitrix> aweinstock: Because packing and unpacking a bit from a data structure would result in more cycles from the CPU.
08:14:35 <michaelt> tsahyt: i'm using this http://sprunge.us/ghJi 
08:14:41 <michaelt> tsahyt: oh you tried it.
08:14:44 <nitrix> aweinstock: Almost every languages represents booleans as a Char or an Int.
08:15:01 <tsahyt> michaelt: that is very interesting. I'm doing exactly the same thing.
08:15:04 <michaelt> tsahyt: just making sure you knew U.Vector is better if you happen to have an unbox type
08:15:21 <ertes> aweinstock: the real answer is: because.
08:15:27 <tsahyt> michaelt: how does unboxed and storable compare there?
08:15:31 <ertes> aweinstock: there is no technical reason why Bool is not a Bits
08:15:31 <aweinstock> nitrix: I think that's orthogonal to what I'm asking (about the typeclass Data.Bits.Bits, not representing Bool as an individual bit)
08:15:48 <ertes> aweinstock: "because Bool shouldn't be computed with", i guess
08:15:51 <michaelt> tsahyt: storable is less usable I'm not that familiar really
08:15:59 <mbrock> aweinstock: doesn't it though?
08:16:01 <nitrix> aweinstock: I'm not sure I understand.
08:16:09 <nitrix> aweinstock: There's an instance Bits Bool
08:16:09 <mbrock> aweinstock: https://hackage.haskell.org/package/base-4.9.1.0/docs/src/Data.Bits.html#line-401
08:16:10 <aweinstock> I'd just be convenient to have (xor :: Bool -> Bool -> Bool) in the stdlib for what I'm currently doing
08:16:12 <tsahyt> michaelt: really all I need from it is traverse this set/list/array of ints
08:16:19 <ertes> aweinstock: xor is (==)
08:16:25 <ertes> uhm
08:16:27 <ertes> (/=)
08:16:31 <tsahyt> the accumulator of the fold is where the magic happens, I just need the indices to work on from the vector
08:16:52 <aweinstock> mbrock: thanks (looks like I'm on 7.6.3, so it's a debian stable problem)
08:16:58 <michaelt> tsahyt: unboxed vector is kind of go-to for that in my view, but there may be considerations I didn't hear
08:16:59 <aweinstock> ertes: thanks for the workaround
08:17:20 <nitrix> aweinstock: It exists.
08:17:35 <nitrix> aweinstock: xor :: Bits a => a -> a -> a
08:17:54 <nitrix> aweinstock: Specialize the type variable `a` as Bool (because there is such instance Bits Bool) and off you go.
08:17:55 <ertes> aweinstock: GHC 7.6.3?  that's ancient…
08:17:59 <tsahyt> michaelt: did you get the 78µs on foldr or foldl?
08:18:07 <michaelt> tsahyt: foldl'
08:18:19 <michaelt> foldr seemed suprisingly slow
08:18:32 <aweinstock> ertes: maybe I'll learn how to pin newer packages in apt someday, but for now (/=) works
08:18:50 <tsahyt> michaelt: compiler options?
08:18:53 <michaelt> foldl is the natural way of folding the underlying stream type, I think.
08:19:04 <michaelt> tsahyt: -O2
08:19:09 <tsahyt> oh that may make the difference then
08:19:15 <aweinstock> nitrix: I know how typeclass specialization works, it's just that the instance isn't in my (old) version of GHC
08:19:42 <michaelt> tsahyt: I'm a little surprised by the slowness of unboxed foldr not sure what's up
08:19:42 <tsahyt> yes, that's it
08:19:43 <nitrix> > xor <$> [True, False] <*> [True, False] -- aweinstock, here its truth table.
08:19:46 <lambdabot>  [False,True,True,False]
08:20:02 <tsahyt> 208µs for vector, 55.06µs for unboxed, 45.18µs for storable
08:20:06 <tsahyt> that's quite a speedup
08:20:06 <ertes> michaelt: you would use Storable for communicating with foreign libraries
08:20:10 <michaelt> tsahyt: -O2 is what I always use but I have no good arg for it
08:20:27 <ertes> for example storable vectors are very useful with CUDA, OpenCL, OpenGL, matrix libraries, etc.
08:20:29 <michaelt> ertes: right, which is why as I said I don't have much experience...
08:20:53 <tsahyt> hmm apparently this really *needs* -O2. -O1 doesn't yield the same result either
08:21:01 <tsahyt> fair enough, I can compile my stuff with -O2
08:21:03 <merijn> ertes: Know any companies doing CUDA from Haskell? :p
08:21:24 <nitrix> aweinstock: Using base < 4.7 seems like asking for trouble.
08:21:26 <ertes> merijn: companies?  no =)
08:21:39 <merijn> I wouldn't mind getting paid to write some less awful CUDA bindings for Haskell :p
08:21:56 <ertes> merijn: they'd probably just use nvidia's C++ dialect =)
08:22:10 <merijn> ertes: For the kernels, sure
08:22:23 <merijn> ertes: But writing the host code in C++ is annoying
08:22:31 <nitrix> aweinstock: It's two years old ._.
08:22:32 <aweinstock> nitrix: any outright bugs, or just bunches of inconveniences like missing instances?
08:22:40 <ertes> merijn: looks like we need better marketing =)
08:23:33 <merijn> ertes: Well, writing the host code in haskell would require nicer haskell bindings first, but I can't justify the time to develop them atm :p
08:26:04 <nitrix> aweinstock: To me, the question should be presented the other way around. You should be trying your hardest to integrate the updates in your dependencies; especially if you find yourself needing something that got added 2 years ago, it seems like a huge cue.
08:26:58 <nitrix> aweinstock: You remind me of an old coworker that was doing just the strict minimum and didn't want to use Git and he had to use this bridge to connect his SVN repo to our Git repo.
08:27:44 <merijn> nitrix: To be fair, I fully support not using git :)
08:27:52 <merijn> It's using SVN instead that I can't support :p
08:28:40 <tsahyt> I wonder why unboxed/storable vectors require -O2 for the speedup
08:28:50 <isBEKaml> merijn: so what would you use? darcs?
08:28:56 <merijn> isBEKaml: Mercurial
08:29:09 <isBEKaml> merijn: Ah, why not darcs?
08:29:38 <merijn> Because I learned Mercurial first and because it has bidirectional support for git, so I can remain blissfully ignorant while colleagues use git :p
08:30:01 <isBEKaml> merijn: You are the perfect colleague for nitrix :P
08:30:21 <michaelt> tsahyt: dunno which of the extra optimizitions is being used, i see in the cabal file for `vector` that it demands "ghc-options -O2 -Wall" itself 
08:30:23 <nitrix> I'd actually enjoy working with merijn.
08:30:39 <nitrix> I'd suck all his knowledge like a sponge c:
08:31:44 <michaelt> tsahyt: cabal defaults to -O1 I think, since -O2 takes longer frequently with no result
08:31:46 <merijn> Most of my knowledge consists of awful abuse of recursive make and bash :p
08:31:56 <merijn> michaelt: Cabal defaults to whatever you configure it to :p
08:32:12 <tsahyt> in any case even without optimizations it's faster than HashSet, so I'll take it
08:32:12 <aweinstock> nitrix: I'm trying to fuzz my crypto protocol before meeting with my advisor today; I'll update ghc this evening
08:32:14 <merijn> michaelt: You can change it in your config file :)
08:32:14 <michaelt> merijn: but i don't configure it
08:32:25 <michaelt> merijn: yes I know that
08:32:46 <Tuplanolla> I recall SPJ talking about improving compiler performance last year. Where are we on that right now?
08:32:50 <dcoutts> merijn, michaelt: yes, but the default default is -O (which means -O1)
08:33:09 <michaelt> dcoutts: yes tats what i said
08:33:12 <dcoutts> Tuplanolla: people are working on it. If you want details lurk in #ghc
08:33:17 <dcoutts> michaelt: yep
08:33:50 <Tuplanolla> I'm already at my lurk quota.
08:33:52 <michaelt> dcoutts: tsahyt was wondering why `vector` programs respond so well to -O2
08:34:43 <tsahyt> dcoutts: talking about cabal, is the foreign libraries support ready?
08:34:55 <joeyh> jophish: can just /msg me 
08:35:24 <dcoutts> tsahyt: vector relies on stream fusion for lots of things, and that needs the extra effort of O2
08:35:36 <dcoutts> tsahyt: it's in cabal head
08:36:03 <tsahyt> nice! I've been meaning to play around with FRP to build LV2 audio plugins
08:36:41 <tsahyt> the other usecase I had for it disappeared when I switched to a different solver for my thesis, but it's still a feature I'm looking forward to
08:37:38 <dcoutts> tsahyt: if you can try it out now to make sure it works for you, you it'll be easier to get fixes in :-)
08:38:26 <tsahyt> I'll look into it. Unfortunately this thesis is taking up way too much of my time and I hardly get around to personal projects anymore.
08:43:06 <k0001> Has anyone seen this issue in xmonad? In the initial workspace I'm in when xmonad starts, windows occupy the entire screen even if I don't ask for it (going over xmobar and such). In the rest of the workspaces maximized windows don't cover xmobar and such. 
08:48:09 <ongy> k0001: there's #xmonad :) Also that's the strut bug in 0.12, let me search for the comment about it
08:48:44 <ongy> https://wiki.haskell.org/Xmonad/Notable_changes_since_0.11#ManageDocks_changes this one
08:48:47 <k0001> ongy: oh, nice! Thank you :)
08:54:29 <ski> jophish,sdx23 : .. i recall seeing it mentioned that one define a notion of entropy on partitions / equivalence relations on a given set
08:55:18 <z0ltan> Hello, folks. I needed a quick help with Haskell mode on emacs... how to force format of pasted code? It doesn't appear to be happening by default :(
08:55:34 <sdx23> ski: there quite some - coming from a physics background I was just wondering what the notion meant in regard of type systems.
09:01:29 <ski> sdx23 : "The Logic of Partitions: Introduction to the Dual of the Logic of Subsets" by David P. Ellerman in 2010-06 at <http://www.ellerman.org/the-logic-of-partitions/> was where i saw it .. do you have any handy link for a discussion/exposition of some of the ones you had in mind ?
09:04:27 <infandum> Using lens only (no map), how can I get the first two elements of a list in a tuple? Like: f [(1,56,53), (3,4,8), (0,3,1)] == [(1,56), (3, 4), (0, 3)]
09:04:45 <infandum> I should mention that list is a Value
09:04:46 <tsahyt> does it ever make sense to put inline pragmas on where bindings?
09:05:20 <infandum> so it would be something like toListOf (_Array . traverse . _1) or something, except that would only get the first one
09:08:44 <nitrix> infandum: You can use _1 and _2 to obtain the respective tuple elements.
09:08:59 <infandum> nitrix: But how to do it on ONE traversal?
09:09:04 <infandum> Not doing it twice and zipping
09:09:18 <nitrix> Oh, you might want (.:) or something similar.
09:09:24 <infandum> oooo what's that
09:09:33 <infandum> oh, for aeson?
09:09:36 <nitrix> Well that one would do it twice. Let me think.
09:11:39 <infandum> nitrix: I guess I'm thinking like an arrow or something
09:11:46 <infandum> or that bimap
09:11:53 <infandum> the lens equivalent of that
09:13:25 <nitrix> Curiously, is  `traverse (\e -> pure (e ^. _1, e ^. _2))` not good enough?
09:13:51 <nitrix> > traverse (\e -> pure (e ^. _1, e ^. _2)) [(1,56,53),(3,4,8), (0,3,1)]
09:13:54 <lambdabot>  error:
09:13:54 <lambdabot>      • Ambiguous type variables ‘f0’, ‘t0’, ‘t1’ arising from a use of ‘show_...
09:13:54 <lambdabot>        prevents the constraint ‘(Show (f0 [(t0, t1)]))’ from being solved.
09:14:52 <nitrix> It's a tiny repetitive, but you can change that with ehm...
09:15:04 <infandum> nitrix: It's in a Value though
09:15:09 <infandum> from json
09:15:25 <infandum> so I'm using lenses to get the info
09:20:07 <nitrix> Maybe having a proper example would help because I'm really tempted to not use lenses for this.
09:20:19 <glguy> > let notMap = over mapped in notMap (\(x,y,_) -> (x,y)) [(1,56,53), (3,4,8), (0,3,1)] == [(1,56), (3, 4), (0, 3)]
09:20:22 <lambdabot>  True
09:20:33 <nitrix> Seriously, map (\(x,y,_) -> (x,y)) ...
09:20:44 <nitrix> glguy: Yup.
09:20:58 <jophish> jle`: Hi, I'm expipiplus1 on github. If you let me know your hackage username I can add you as a maintainer for vector-sized
09:21:59 <jle`> jophish: it's 'jle' !
09:22:04 <jle`> http://hackage.haskell.org/user/jle
09:22:06 <jle`> :)
09:24:36 <jophish> jle`: ok, I've added you, might take a moment to trickle through. 
09:24:42 <jophish> Thanks for your contributions!
09:28:41 <Clarinerd> Can I ask a question?
09:28:59 <Clarinerd> Kinda new, so not quite sure how the channel works
09:29:08 <jophish> Clarinerd: usually best just to ask :)
09:29:44 <ski> Clarinerd : you already did ..
09:31:09 <Clarinerd> Fair enough. I'm learning Haskell to join a research group, and one of the advisors for the group tasked me with building a basic data structure for representing Polynomials
09:31:50 <ski> polynomials in one variable ?
09:31:51 <Clarinerd> The trick is that it has to share its substructure, such that having two versions of (x+4) would only take up one space in memory.
09:31:55 <Clarinerd> Many.
09:32:11 <Clarinerd> Sorry, no
09:32:23 <Clarinerd> one variable, n-degree
09:32:42 <ski> not quite sure what you mean by "two versions of (x+4)"
09:33:15 <ski> do you mean having two factors `x + 4', or do you mean two separate polynomials both being `x + 4' ?
09:33:52 <Clarinerd> Both, in fact.
09:34:10 <Clarinerd> At least according to the problem description I was given.
09:34:26 <Clarinerd> It is still possible that it was worded incorrectly and/or poorly
09:34:48 <Cale> I don't believe it makes a whole lot of sense to attempt that in general.
09:35:27 <MarcelineVQ> might be good to make a paste of the problem posed, in case there's a translation error
09:35:51 <ski> the obvious way to represent a polynomial in one variable is as a list of the coefficient, presumably simplest to order them from coefficients corresponding to lower powers of the variable before ones corresponding to higher powers
09:36:07 <Clarinerd> Good point. I'll copy it over. Just a sec
09:36:49 <ski> maybe you want to try to factor your polynomial when you can ? or perhaps just keep the expression structure (possibly reshaping it a bit) ?
09:36:51 <sssilver> hey guys, interesting q came up during discussion with a colleague
09:37:12 <Cale> Even after it completely ruins the maintainability of your program, the amount of bookkeeping you'll need in order to keep track of already-constructed polynomials will eat into any cost savings you might have expected to obtain.
09:37:14 <sssilver> suppose you have a long call chain, e.g. a calls b which calls c, then d, e, and at the end it's z
09:37:29 <sssilver> a takes an argument from the user, which is only used in z
09:37:45 <sssilver> now all your b, c, d, e, f, etc signatures are polluted because they need to pass that argument down
09:37:52 <sssilver> is there a pattern that solves this problem?
09:37:56 <sssilver> provided everything's happening in a single thread
09:38:06 <Cale> Though I don't know, maybe you have a very large number of occurrences of the exact same small polynomials or something.
09:38:25 <ski> sssilver : one alternative is to pass along a context argument, and to augment it with another field for your extra argument
09:38:34 <Clarinerd> Create data structure that can represent sets of polynomials using shared substructure
09:38:36 <Clarinerd> Be able to print everything it represents as an instance of Show
09:38:52 <sssilver> ski that's basically the idea of "thread-local variables" 
09:38:57 <Clarinerd> That's all that I have in writing.
09:39:16 <_sras_> Why does this fails type check, http://lpaste.net/351988 ?
09:39:18 <Cale> Well, *maybe* that refers to the ability to share tails of lists or something.
09:39:21 <sssilver> ski any other tips? also, could passing that context be made a bit more implicit to contain verbosity?
09:40:11 <ski> sssilver : it's not clear whether by "thread" you mean a multi-processing mechanism, or just sub computations that are grouped together by the same argument role being passed to them (and perhaps also out of them)
09:40:14 <Clarinerd> Cale: I agree with your earlier premise about it not making sense. But, in the off chance that they're just talking about sharing portions of the lists as you mentioned, how would I go about that?
09:40:47 <sssilver> ski I mean these functions are being called in a single thread, so sync isn't a problem
09:41:04 <Cale> sssilver: I would recommend just passing the argument along without thinking of it as "pollution", because it's conceptually really not. If the result of z is used to determine the result of a in some way, then the outcome of applying a really does depend on it.
09:41:23 <ski> sssilver : there's `Reader',`ReaderT', but in simple cases, simply passing it explicitly may be preferable. if the actual passing (not the type signatures, assuming you have them) is tiresome, you could try implicit parameters
09:41:32 <_sras_> nevermind. It is using lift from another module...
09:41:38 <Cale> sssilver: So making that dependency obvious can be helpful. If your problem is a proliferation of such parameters, the solution is to design data types better to organise them in a coherent way.
09:41:41 <ski> sssilver : and what Cale said
09:42:24 <Cale> Clarinerd: Well, perhaps just start by taking a polynomial to be a list of coefficients.
09:42:28 <sssilver> Cale but even if you (properly) aggregate them all into one type, you're still passing that along, and in some ways that doesn't feel elegant
09:42:52 <sssilver> ski what are "implicit parameters"?
09:42:52 <Cale> Clarinerd: So, perhaps just start with something like newtype Poly a = P [a]
09:43:11 <ski> Clarinerd : not directly related, but i'd hope that they don't expect your `Show' instance to generate a string that's not a valid Haskell representation of code which evaluated in an appropriate environment yields a value equal to the original value ..
09:43:19 <Cale> Clarinerd: and then we can define addition like  add (P xs) (P ys) = P (zipWith (+) xs ys)
09:44:01 <ski> sssilver : <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#implicit-parameters>
09:44:33 <Cale> Clarinerd: and basic stuff like  x = P [0,1]
09:45:00 <Clarinerd> ski: not exactly sure what you mean, but I feel like if I can get my mind around a representation, Show won't be too bad
09:45:39 <ski> sssilver : a language extension. basically a form of "dynamic scope", if you're familiar with that (e.g. default in Emacs Lisp. usually present (though not default) in other Lisps (Scheme,Common Lisp)). exceptions are treated in the same dynamic way, as are other dynamic context setup and teardown stuff
09:45:55 <Cale> and, well, actually, you may want to define multiplication by a constant and multiplication by x before you try to define multiplication generally
09:46:21 <Cale> (Just because those are both easy and will help you to define the full polynomial multiplication)
09:47:02 * ski . o O ( convolution )
09:47:44 <Cale> sssilver: It might not feel elegant at first, but when you go to test your program, or when you're reading the code later, it will be helpful that it's obvious which things depend on that parameter.
09:48:14 <Clarinerd> Cale:I figured as much. And I know that way back in discrete math we came up with formulas for something similar, so worst case I can use that as a springboard, in addition to what you mentioned
09:53:44 <Cale> sssilver: Basically, in my experience, I have never regretted just passing stuff as a parameter. It can become a little annoying if you end up with a function with a dozen parameters or something, but you just look at where those parameters are going and package them up into a smaller number of records. You can use ReaderT if it eventually becomes apparent that nearly everything needs the same parameter, and you're already using a 
09:53:44 <Cale> custom monad for some other reason, so the additional transformer isn't a big deal -- but I would advise against doing that straight away.
09:55:13 <infandum> How do I remove old stackage repositories? Like lts-7.8 or whatnot
09:55:31 <infandum> from my computer, all of the packages build with those
09:55:44 <infandum> and those ghcs (I can always download them some other time)
10:00:10 <sm> infandum: you can manually delete all the lts-X 
10:00:39 <sm> unfortunately you can't just remove a few and expect stack to keep working
10:00:41 <infandum> sm: Aren't they scattered about in .stack?
10:01:43 <sm> they're under there somewhere, yes, but easy enough to find with du -sh *
10:03:15 <sm> what I meant is that if you're on lts-7 and don't care about older lts, you can safely remove lts-[56]*, but you should keep all the lts-7* (or delete them all and let stack recreate just one)
10:04:03 <sm> likewise if you don't care about nightlies, you could delete all of those without harming your lts
10:05:03 <sm> there's on open issue for a cleanup feature, somewhere
10:05:40 <Clarinerd> Thank you everyone for your help.
10:07:52 <infandum> because right now it's taking up 13 gigs
10:08:34 <sm> sure.. the big stuff is under ~/.stack/snapshots/ARCH/
10:08:50 <kadoban> infandum: If you're okay with a little rebuilding, you can just nuke it all. Just save your configs, I think they're ~/.stack/config.yaml and ~/.stack/globla-project/stack.yaml
10:09:18 <infandum> I mean I have it all the way back to lts-3
10:09:20 <infandum> haha
10:09:35 <infandum> nightlies from 2015
10:09:36 <infandum> phew
10:09:44 <sm> 12G here.. time to clear some nightlies
10:11:02 <infandum> it grows on ya
10:13:55 <sm> doh.. busted my db 
10:14:02 <sm> drat you infandum :)
10:14:06 <infandum> EXACTLY! That's what worried me
10:14:06 <infandum> haha
10:14:11 <infandum> time for a restart
10:14:45 <sm> I removed all nightlies and lts-[2-5]
10:15:00 <sm> I read that lts versions are independent. Maybe not ?
10:16:31 <infandum> I thought they were
10:16:36 <infandum> unless they share the same ghc?
10:16:56 <sm> maybe that's it
10:17:32 <kadoban> It's confusing and difficult to remove only some without breaking existing packages. You're better off either just leaving them all or nuking the whole thing.
10:33:39 <sm> sigh
10:42:11 <fragamus> does frege offer hindley-milner
10:43:25 <AWizzArd> fragamus: hi
10:43:31 <AWizzArd> I think yes.
10:43:41 <fragamus> bueno
10:43:45 <fragamus> thank you
10:43:47 <AWizzArd> It should be very similar to Haskell 2010.
10:44:06 <AWizzArd> I also just discovered it recently.
10:44:20 <fragamus> tail recursion optimization in frege?
10:44:38 <AWizzArd> I don’t know, but I think yes.
10:44:45 <AWizzArd> I did not really try it out yet. 
10:47:17 <volhovm> How is megaparsec better than attoparsec? I heard it _should_ support text better, but in fact all combinators are based on Char. And I can't any convenient combinators to retrieve Text using satisfyMany etc.
10:47:45 <jaspervdj> rule of thumb is that attoparsec is fast, and megaparsec gives better error messages
10:47:51 <nitrix> Ah! I managed to compile gtk on windows!
10:48:04 <volhovm> jaspervdj: oh, alright, that works for me :)
10:48:05 * nitrix jubilates.
10:48:45 <volhovm> both should work w/o problems with unicode, right?
10:49:21 <volhovm> So i won't be stuck with converting [Word8] into Char manually lol
10:51:16 <jaspervdj> volhovm: I would start of with a `Text` value, and then use that with `Data.Attoparsec.Text` (or megaparsec).  That'll do unicode fine
10:51:31 <volhovm> Great, thank you
11:05:00 <sm> half an hour to reinstall 224 packages.. but 12G -> 1.5G
11:20:33 <tapirus> Hi, fairly noob question, I have two lists, a = [1,2,3] and b = [1,2,3,4]
11:20:35 <infinity0> is there a function to convert a StateT s into a StateT t given a Lens s t ?
11:21:13 <tapirus> I'm trying to construct a function f such that f a b gives [2,3,4,5,3,4,5,6,4,5,6,7], i.e. adds each element of a to each element of b and flattens the list
11:21:46 <tapirus> I assume it'll be concatMap ( *something* a) b, but I can't get further than that
11:21:49 <drninjabatman> hello, having a `class C a b c | a -> b` I want to define `instance C a b c => C a b (T c)` but ghc complains that "type ‘a’ does not determine rhs type ‘b’".
11:22:08 <lyxia> infinity0: zoom
11:22:15 <drninjabatman> Can't ghc determine the functional relationship from the constraint?
11:22:21 <infinity0> lyxia: great, thanks!
11:22:39 <glguy> drninjabatman: The error message mentions the extension you can enable to proceed
11:22:56 <drninjabatman> glguy: oh of course! thnx!
11:23:58 <Ferdirand> tapirus: do you know Applicative ?
11:25:02 <tapirus> nope
11:25:28 <Ferdirand> > (+) <$> [1,2,3] <*> [1,2,3,4]
11:25:31 <lambdabot>  [2,3,4,5,3,4,5,6,4,5,6,7]
11:25:41 <Ferdirand> alternatively
11:25:45 <Boomerang> > liftA2 (+) [1,2,3] [1,2,3,4]
11:25:47 <lambdabot>  [2,3,4,5,3,4,5,6,4,5,6,7]
11:26:13 <Ferdirand> right, that
11:27:21 <kadoban> > do {x <- [1..3]; y <- [1..4]; return $ x + y}
11:27:23 <lambdabot>  [2,3,4,5,3,4,5,6,4,5,6,7]
11:28:41 <tapirus> cheers, thanks guys :) reading about Applicative also
11:30:24 <Ferdirand> you can make it work with concatMap too
11:30:48 <Ferdirand> in fact concatMap is (=<<) in the List monad
11:31:13 <Ferdirand> which is why kadoban's version makes sense
11:37:05 <recursion-ninja> When I try and call a C function from Haskell I get a segfault. I put a prinf() statement and a fflush(stdout) as the first instructions of the C function. The printf() output is never rendered to the terminal. I placed a trace statement in the Haskell code right before the FFI call. That trace output is rendered to the terminal. I suspect that there's an error with handing an array from Haskell to C. how do I go abount deb
11:38:32 <tsahyt> recursion-ninja: usually using withArray or a related function
11:39:54 <recursion-ninja> tsahyt: I am using `withArray` to "malloc the arry in Haskell. That's occuring fine as I put more trace statements before and after that call and added strictness annotations to all the IO actions in the `do` block.
11:40:05 <tsahyt> can you post the code somewhere?
11:40:10 <tsahyt> e.g. lpaste
11:40:16 <tsahyt> lpaste.net that is
11:40:28 <geekosaur> possibly gist since the C side likely matters as well, so at least 2 files
11:42:05 <lpaste> recursion-ninja pasted “segfaults all the time” at http://lpaste.net/351998
11:42:56 <recursion-ninja> tsahyt: I posted the Haskell function that calls the FFI binding. It compile's and segfaults so all the types match on the Haskell side of things.
11:43:30 <Tuplanolla> Types don't help much where you're headed, recursion-ninja.
11:43:49 <recursion-ninja> Tuplanolla: Well it's the first step ;)
11:44:50 <geekosaur> is it just me, or is unsafePerformIO + malloc bad juju?
11:45:27 <ertes> recursion-ninja: side note: i'm sure you don't need to force result of 'pure' for 'trace' to work
11:45:46 <Tuplanolla> At least one of the problems is that you call `printf` on the C side while going through `unsafePerformIO`, recursion-ninja.
11:45:56 <Tuplanolla> That's not necessarily going to work.
11:46:44 <recursion-ninja> Tuplanolla: I can remove the printf(0 from C and it still segfaults though.
11:47:08 <ertes> recursion-ninja: it would be helpful to show the 'foreign' declaration as well
11:47:14 <recursion-ninja> Tuplanolla: The hope was just to "see" if it was making it to the C code executing.
11:47:14 <ertes> and the C code
11:47:24 <ertes> at least the prototype
11:47:51 <recursion-ninja> ertes: It's a gaint nightmare, do you want me to post all of that?
11:48:00 <sssilver_> Cale do you mean advise against implicit arguments?
11:48:02 <ertes> recursion-ninja: just the prototype should be enough
11:48:30 <sssilver_> Cale or against ReaderT
11:48:36 <sssilver_> I don't really know much about ReaderT
11:48:37 <sssilver_> so I'm confused
11:49:18 <lpaste> recursion-ninja revised “segfaults all the time”: “segfaults all the time” at http://lpaste.net/351998
11:49:57 <recursion-ninja> ertes: I modified the lpaste to include the foreign declaration and the struct
11:51:33 <lpaste> recursion-ninja pasted “Segfaulting C code without the plethora of transitively dependant functions” at http://lpaste.net/352000
11:52:08 <ertes> recursion-ninja: as far as i see only size and alignment are used from the Storable instance, right?  you're not actually reading/writing any struct members on the haskell side?
11:52:26 <ertes> recursion-ninja: and have you tested that the Storable instance actually works?  because it looks highly suspicious
11:52:54 <recursion-ninja> ertes: Probably, I didn't write a lot of the FFI binding myself.
11:53:10 <ertes> recursion-ninja: ah, no, i'm wrong…  Storable is used on line 6
11:53:27 <recursion-ninja> ertes: I have no idea if the Storable instance works or how to test it. Any suggestions on that front?
11:53:30 <ertes> recursion-ninja: you should test the crap out of that Storable instance
11:53:46 <ertes> recursion-ninja: yes, create an array and see if you can peek/poke it properly
11:54:28 <recursion-ninja> geekosaur: The `malloc` and `unsafePerformIO` might be bad juju. The idea is to offload some memoization work to C.
11:55:25 <recursion-ninja> ertes: Thanks for the idea. I'll see if I can get that to work in a GHCI session.
11:57:08 <recursion-ninja> GHCI says: ghc: panic! (the 'impossible' happened) when I tried to load the mosules with `stack ghci`
12:06:07 <ertes> recursion-ninja: check if the FFI call is even the culprit…  see if this code still segfaults without it
12:08:23 <tsahyt> recursion-ninja: about all these bangs, you don't need them
12:08:47 <flxw> Hi. Conal Elliot mentions in some of his talks, that none of the existing FRP implementations are truely implementing his theory. Which of the haskell FRP implementations would come closest to his denotational semantics? (... well, I should probably ask him)
12:09:00 <tsahyt> you're in IO after all, so unless you have unsafeInterleaveIO somewhere in there, you don't need to force strictness
12:09:11 <tsahyt> flxw: his own implementation I think
12:09:26 <tsahyt> but that was last updated in 2011
12:09:29 <tsahyt> http://hackage.haskell.org/package/reactive
12:10:32 <flxw> tsahyt: ah, thank you.
12:12:01 <ertes> flxw: reflex and reactive-banana implement a subset
12:12:19 <tsahyt> ertes: how does wires compare?
12:12:27 <recursion-ninja> ertes: That's a wonderful idea, checking if the call is actually causing the segfault. I'm going to try it. Can't beleive I didn't think of that!
12:12:33 <ertes> tsahyt: it doesn't…  it's AFRP
12:13:09 <tsahyt> ah, I didn't realize that being arrowized already removes it that far
12:13:22 <tsahyt> semantically that is
12:14:01 <sm> recursion-ninja: I call this the "debug by stupid text reduction" technique, it's great :)
12:14:23 <ertes> tsahyt: wires tries to stay as close to FRP semantics as possible, but as an AFRP implementation takes a few compromises
12:14:27 <recursion-ninja> sm: If it was less effective, we'd do something else ;)
12:14:44 <ertes> tsahyt: in a list of true FRP systems (if even just a subset), i wouldn't even mention it
12:15:00 <ertes> neither its predecessor netwire or any of the other AFRP systems available, most notably Yampa
12:15:19 <tsahyt> interesting. I should probably make something with reactive-banana then, because wires is really all I ever used. just to see what the differences are.
12:15:27 <tsahyt> other than the obvious difference of an arrow interface I mean
12:15:45 <osa1> does swapTMVar ever block?
12:15:59 <osa1> what happens if var is empty?
12:15:59 <ertes> tsahyt: yeah, reactive-banana is a great library…  also look at reflex, which is maybe a bit more practical in scenarios where you're under control of the main loop
12:16:22 <tsahyt> I've only ever heard reflex mentioned in the context of ghcjs and web things
12:16:49 <ertes> tsahyt: yeah, its most common use case is reflex-dom, but the reflex library is completely agnostic
12:17:37 <ertes> tsahyt: it's also pretty simple, if you can wrap your head around DSum =)
12:17:50 <tsahyt> what would be the criteria to choose an AFRP library over say reactive-banana and vice versa?
12:18:07 <ertes> tsahyt: right now?  real-time stuff:  simulations, real-time games
12:18:09 <ertes> animations
12:18:11 <ertes> etc.
12:18:32 <tsahyt> as opposed to things like GUIs I suppose?
12:19:03 <ertes> tsahyt: as opposed to things that really take advantage of event push and, well, not being real-time
12:19:48 <ertes> anything that requires predictable performance, lots of random numbers and large dynamic collections currently benefits from AFRP
12:20:02 <tsahyt> why "currently"?
12:20:28 <ertes> tsahyt: because i'm working on something that may eventually become a new reflex host to fix all of these =)
12:21:08 <ertes> the goal is to make AFRP obsolete…  and make conal happy be bringing back continuous behaviours and integration =)
12:21:17 <ertes> s/ be / by /
12:22:15 <tsahyt> that sounds interesting
12:22:19 <tsahyt> what will happen to wires then?
12:22:56 <tsahyt> also about "making AFRP obsolete", with my very limited experience I actually found arrows to be a rather adequate interface
12:22:57 <ertes> a note in the README: "AFRP is obsolete now…  use this new thing instead: [link]" =)
12:23:27 <ertes> arrows are a terrible interface…  what is great is the underlying automaton-based implementation, because it's so delightfully cheap
12:24:06 <ertes> i've tried for years to retain the automaton approach while getting rid of the A, but never succeeded
12:29:46 <fuzzyhorns> dumb question im sure but, i am using trace in a program im running through stack test, but i dont see any output
12:30:03 <fuzzyhorns> i thought id get stderr out without needing to do anything, but i guess not?
12:30:56 <tsahyt> ertes: how are arrows a terrible interface? as I said I don't have much experience with AFRP or FRP overall actually.
12:33:05 <ertes> tsahyt: with all inputs forcefully explicit and the inability to use regular function arguments you need awkward special syntax for a lot of things from basics (passing stuff around) to more complicated cases like rewrapping the inputs of a combinator (notably the scary (| banana bracket |) syntax and its complicated semantics), and everything becomes slower, because you need to create tuple-based side channels all the time
12:33:13 <sm> I think stack test hides some output by default - check for a verbose/debug flag, or run the test executable it builds directly
12:34:11 <tsahyt> TIL about banana brackets
12:34:35 <tsahyt> as I was going over my asteroids clone again, I did notice that I use tuples an awful lot though, so I guess you have a good point there
12:35:32 <ertes> tsahyt: the Monad interface is better in every way i can think of
12:36:07 <tsahyt> I thought allowing a Monad interface opens the door to all kinds of performance problems though?
12:36:29 <ertes> tsahyt: Monad is just an interface…  if you have a monad, you should use it
12:37:31 <ertes> tsahyt: now if you take a pure automaton type (non-monadic), then it is actually also a monad, but unfortunately its (>>=) is linear in the number of frames computed so far
12:37:49 <ertes> in other words: the cost of each next frame will be one step more than the current frame
12:38:06 <ertes> that's why Arrow (or Applicative+Category) is necessary for automata
12:38:31 <tsahyt> I see, so that's why AFRP came to be
12:39:05 <ertes> if the automaton type supports effects (as e.g. Wire does), then it's no longer a proper monad at all
12:39:57 <ertes> Yampa could *in principle* provide a monadic interface, but it would be useless for the reason above
12:41:43 <wayne> hi
12:41:49 <wayne> i have `data Direction = North | East | South | West`
12:42:05 <wayne> how can i do something like `incr North` to get East?
12:42:23 <ertes> wayne: add: deriving (Enum)
12:42:31 <ertes> then 'incr' is 'succ'
12:42:41 <wayne> ah, that was it!
12:42:42 <ertes> however, succ West = undefined
12:42:44 <wayne> thanks i forgot about succ
12:42:49 <wayne> what could getting West back to North?
12:42:52 <tsahyt> ertes: from what I've seen reactive-banana does use a monadic interface though. At least it has this MomentMonad or so. I suppose that only works because of a different model underneath then?
12:42:54 <wayne> s/could/about/
12:43:27 <wayne> i hope i don't have to figure out CircularEnum
12:43:28 <ertes> wayne: here is a horrible idea:  \x -> toEnum (mod (fromEnum x + 1) 4)
12:43:39 <wayne> yeah...thanks for the inspiration though
12:43:46 <kadoban> wayne: You'd probably want to implement your own function really, not use succ  Yeah, that ^
12:43:47 <mizu_no_oto_work> http://stackoverflow.com/questions/5684049/is-there-some-way-to-define-an-enum-in-haskell-that-wraps-around
12:44:01 <wayne> oh amazing googlefu mizu_no_oto_work 
12:44:07 <wayne> thanks
12:44:09 <mizu_no_oto_work> np
12:44:15 <ertes> tsahyt: all of them use a monadic interface, because they don't use the automaton approach
12:44:28 <tsahyt> ertes: where can I read more about this automaton approach?
12:44:55 <ertes> tsahyt: one option is the original AFRP paper…  see the Yampa docs, they should have a link
12:44:58 <wayne> okay. another question...what's the best way to take [a -> b] and apply the function in order?
12:45:03 <wayne> functions in the list, that is
12:45:13 <ertes> tsahyt: another option is to implement it yourself:  newtype Auto a b = Auto { stepAuto :: a -> (b, Auto a b) }
12:45:22 <wayne> [f1, f2, f3] to f3(f2(f1(v)))
12:45:36 <wayne> flip and fold with $?
12:45:48 <wayne> is there a lazier way?
12:46:03 <ertes> :t foldl (.) id
12:46:05 <lambdabot> Foldable t => t (c -> c) -> c -> c
12:46:34 <wayne> wouldn't that evaluate the last function first though?
12:46:45 <wayne> i want the first function to be evaluated first
12:46:58 <wayne> and maybe we'll have many many functions
12:47:00 <ertes> :t foldr (flip (.)) id
12:47:02 <lambdabot> Foldable t => t (c -> c) -> c -> c
12:47:24 <tsahyt> ertes: what's the title of this paper?
12:47:53 <ertes> > foldr (flip (.)) id (const 'y' : repeat id) 'x'
12:48:01 <wayne> oh you're right. that's exactly what foldr is for
12:48:04 <lambdabot>  mueval: ExitFailure 1
12:48:10 <wayne> gosh i don't really use that one too much
12:48:32 <geekosaur> > foldr (.) id [f, g, h] a :: Expr
12:48:35 <lambdabot>  f (g (h a))
12:48:42 <ertes> ah, of course
12:49:13 <wayne> yeah i think i still may have to flip the list before
12:49:17 <wayne> reverse, that is
12:49:25 <wayne> but i wonder if there's a lazier way
12:49:38 <geekosaur> > foldr (flip (.)) id [f, g, h] a :: Expr
12:49:41 <lambdabot>  h (g (f a))
12:49:52 <ertes> > foldr (.) id (const 'y' : repeat id) 'x'
12:49:55 <lambdabot>  'y'
12:50:21 <ertes> wayne: you should first specify how you want to apply the functions
12:50:51 <jarlg> How do I debug the linker failing when building with cabal? I'm getting a lot of undefined references.
12:53:11 <geekosaur> jarlg, it requires some experience with decoding ghc-generated symbols, and generally recognizing where stuff comes from
12:54:04 <ertes> wayne: apply [f,g,h] x = _fillThisIn
12:54:10 <geekosaur> a common error is forgetting to list a module in a library, or forgetting to add that module to other-modules: if it's not exposed
12:54:34 <erisco> is there any tool to help find source for class instances?
12:55:25 <wayne> ertes: thanks, that's a helpful tip that would've made it easier to come up with the solution
12:55:38 <wayne> i imagine that approach comes in handy with a lot of other high order functions
12:56:01 <ertes> tsahyt: i forgot, sorry
12:56:20 <ertes> tsahyt: but it's probably one of the links in the introduction here: https://wiki.haskell.org/Yampa
12:56:30 <erisco> I really want to know how Sing Nat implements TestEquality
12:56:46 <recursion-ninja> ertes: It seems that the FFI call is in fact causing the segfault.  When I comment out the call, there is no segfault. When I uncomment the FFI call, it segfaults. I had to add some NFData instances to make sure things were being forced appropriately but now I'm condfident that the FFI call is causing the segfault.
12:56:51 <erisco> I have looked through the sources and just cannot find it
12:56:56 <ertes> erisco: :i in GHCi tells you where the instance came from
12:57:36 <tsahyt> ertes: I'll go look for it. thanks!
12:57:39 <jarlg> geekosaur: Thanks, I wasn't exposing all my modules. One could imagine cabal suggesting those common errors -- do you know if people are working on such improvements? Maybe an opportunity to dive in myself.
12:58:29 <erisco> ertes, what is the syntax?
12:58:45 <geekosaur> the problem is that one is hard to diagnose, since it has no way to tell the difference between a module that is used solely during build and one that needs to be available later when the library is linked, without figuring out some way to actually use the library
12:58:47 <erisco> :i testEquality :: Sing Nat -> Sing Nat -> Maybe (Nat :~: Nat)  fails parse at :: so it doesn't seem to accept expressions
12:59:07 <ertes> :i Maybe
12:59:11 <ertes> instance Monad Maybe -- Defined in ‘GHC.Base’
12:59:42 <erisco> oh it dumps them all, okay
12:59:46 <geekosaur> and there are things that could be done on windows, or things that could be done on linux, or things that could be done on os x --- none of which would reliably work on the others (linkers are hard)
13:00:17 <ertes> erisco: if you use it in haskell-mode's embedded GHCi you can at least search =)
13:00:23 <erisco> instance forall k (k1 :: k) k2. Data.Singletons.Decide.SDecide k2 => TestEquality Sing -- Defined in `Data.Singletons.Decide'
13:00:47 <erisco> thank-you, this is a big help
13:01:24 <jarlg> geekosaur: Alright, I appreciate the insight. Have a good <appropriate time of day>!
13:02:33 <ertes> tsahyt: FWIW i learned it by implementing it myself (which eventually became the first version of netwire)
13:09:17 <erisco> ah, so singletons has a type called Decision which is similar to TestEquality
13:09:35 <erisco> I mean similar to :~:
13:09:52 <erisco> the instance just maps one to the other
13:10:11 <erisco> so I suppose I can just simplify and stay within singletons... were you aware of this glguy?
13:11:38 <glguy> no, I don't know much about the singletons package beyond cracking it open to help #haskell questions :) I'll look up Decision
13:16:44 <erisco> https://hackage.haskell.org/package/singletons-2.2/docs/Data-Singletons-Decide.html#t:Decision
13:25:18 <glguy> erisco: Cool, and you even get the proof of False, so it's nicer than the Maybe (a :~: b) from yesterday
13:33:06 <handicraftsman> #IsAwesome
13:38:14 <sharon_so> Hi, I developed an app and i'd like to test its stability, from the OS, so i am thinking of tests like 'sigterm', process restart...etc, any suggestions on where i can get a list of test cases that would cover these 'stability' kind of tests ?
13:45:05 <ph88> hi
13:46:05 <ph88> i put this TH code in a separate file so it would work properly https://paste.fedoraproject.org/543230/71873148/ now i want to use a class in this file but also in the Main.hs file, should i put the class in the Main.hs file and then import main module or what would be the best approach here ?
13:46:48 <glguy> ph88: You can put the class in a third file that both Main and MarkArb import
13:46:55 <glguy> It's files all the way down
13:47:00 <ertes> is there a way to map over the value of a Weak?  it's fine if IO is required for that
13:47:37 <taktoa> anyone know if there's a canonical typeclass that's like Alternative but doesn't have `empty`? Semigroup : Monoid :: ? : Alternative
13:47:52 <ertes> taktoa: the Alt type class from the semigroupoids package
13:48:07 <ertes> taktoa: but it also doesn't depend on Applicative
13:48:21 <glguy> ertes: You could make a new Weak with the mapped value
13:48:46 <glguy> ertes: suppose you were using 'mkWeakPair' you could dereference the weak pair, map over the "value" and make a new Weak pair
13:48:47 <taktoa> ertes: thanks, I had a feeling it would be in semigroupoids
13:49:14 <ertes> glguy: doesn't that lose the reference to the original key?
13:49:17 <glguy> ertes: The pairness comes in so that you have access to the key again
13:49:26 <glguy> mkWeakPair :: k -> v -> Maybe (IO ()) -> IO (Weak (k, v))
13:49:54 <ertes> glguy: actual problem:  i need a Weak that refers to an IORef, but has a different value from the IORef itself
13:50:26 <ertes> mkWeakIORef only gives me a Weak (IORef a)
13:50:58 <ertes> glguy: in other words i never get hold of the key itself…  it's the underlying MutVar# of the IORef
13:51:09 <glguy> ertes: I think you're just going to have to inline mkWeakIORef and modify it to have the behavior you want
13:51:35 <ertes> yeah, sounds like the only option…  thanks
13:51:38 <glguy> I don't remember that existing
14:06:00 <Tuplanolla> Is there some sort of a guideline for abbreviating constructors or accessors?
14:06:24 <iostream> Hello. I got into an argument earlier today, and I just wanted to clear up my understanding. The question should not be understood specifically to haskell, but in a broader sense of pure functional languages: To what extend does the type of List guarantee/imply that (a) it is a finite structure and  (b) it is non-circular?
14:06:35 <zomg> Tuplanolla: I seem to recall seeing Ctor as one for constructor
14:06:36 <Tuplanolla> I really don't feel like writing `GeometricAutomorphismGroup` and the other extreme `GAG` isn't much better.
14:06:48 <zomg> ohh that's what you meant :P
14:10:23 <geekosaur> iostream, it doesn't guarantee either one
14:12:01 <iostream> geekosaur: Could you comment a bit on your line of reasoning?
14:13:07 <Tuplanolla> > let xs = 'H' : 'A' : xs in xs -- Here's an infinite circular list for you, iostream.
14:13:09 <lambdabot>  "HAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAH...
14:13:38 <Quintasan> Someone beat me to it :(
14:13:50 <hsk3> Is it possible to add functions to existing typeclasses? (Analogous to extending a protocol in Swift)
14:14:20 <glguy> hsk3: No
14:14:29 <hsk3> Thanks good to know.
14:14:43 <Jinixt> what's the best parser-combinator lib if I want good error messages?
14:14:46 <Jinixt> performance is less important
14:15:00 <Jinixt> errors in the parsing, that is
14:15:14 <glguy> hsk3: You can construct a definition in terms of the methods of a class, and that definition will work for all the same types that have instances, however
14:15:22 <glguy> hsk3: No need to attach it to the typeclass itself
14:15:43 <glguy> hsk3: Of course it wouldn't make sense to add new methods to an existing typeclass. All the existing instances would become incomplete
14:15:50 <geekosaur> Jinixt, probably trifecta or megaparsec
14:16:29 <iostream> Okay, I see that. Then, how am I supposed to write .. say a function that computes the length of a (finite, non-circular) list and is guaranteed to terminate?
14:16:37 <hsk3> yeah
14:16:51 <Jinixt> any philosophical differences between the two?
14:19:22 <jophish> Jinixt: might want to investigate the earley parser too
14:21:20 <geekosaur> I'd say they're both conceptually similar (enough so that the parsers package can wrap both)
14:24:04 <jophish> Jinixt: https://github.com/purescript/purescript/issues/1488#issuecomment-200873139
14:27:08 <ertes> iostream: you can't…  a length function for lists is inherently non-total
14:28:15 <erisco> such is the topic of recursive data
14:28:28 <ertes> iostream: (in haskell)
14:29:11 * geekosaur wonders if this is reaching for some variety of lists with length encoded at type level (i.e. not standard lists)
14:29:22 <erisco> like, Vector
14:29:31 <ertes> iostream: languages with explicit support for the data/codata distinction and total functions will either require your list type to be data or reject any attempt to write a length function for it
14:30:09 <ertes> so you can only have infinite lists *or* a length function, but never both
14:30:46 <hodapp> what languages explicitly distinguish data and codata?
14:30:48 <erisco> and what is life without infinite lists
14:30:57 <ertes> hodapp: agda
14:31:19 <iostream> What about languages such as ML?
14:31:32 <ertes> MLs are strict, aren't they?
14:31:51 <iostream> So, would you say that in strict languages these properties can be assumed?
14:32:04 <ertes> well, you can't have infinite lists in those
14:32:24 <iostream> Yes, but why exactly?
14:32:25 <ertes> so 'length' is total, but you can still pass it a ⊥
14:32:45 <Jinixt> jophish: geekosaur: thanks
14:32:58 <iostream> Is it a property of the type system, of the semantics (eagerness), or both? Where exactly do you derive the property from
14:33:31 <erisco> there are kind classes?
14:33:38 <erisco> I've been left in the dust
14:33:40 <ertes> if you allow codata, it's a type system and semantics property…  a total language has no semantics for general recursion, so it must reject it
14:33:49 <ertes> erisco: -XTypeInType
14:35:20 <iostream> ertes: What is codata, and what is its relevance here?
14:35:48 <jophish> np Jinixt, do let us know what you end up with!
14:36:51 <EvanR> iostream: codata is potentially infinite data, codata structures are defined by a program to generate more of the structure, which is guaranteed to progress
14:36:58 <ertes> iostream: codata is just data, unless you also have a termination checker:  data cannot be infinite and recursion must use structurally smaller arguments…  codata can be infinite, but recursion must always be productive
14:37:25 <ertes> 'repeat' is a proper codata producer, while 'filter' is not
14:38:11 <iostream> Okay; that makes sense. So in this context, the question boils down to whether you have codata and a termination checker/totality?
14:38:23 <iostream> And lack of mutability ...
14:38:58 <iostream> So, in a strict, pure, total functional language you can write a length function that terminates
14:39:05 <EvanR> inductive data and coinductive codata are still things you can pretend about in your head, in haskell
14:39:09 <ertes> in fact you can't use recursion on codata, even if recursive arguments are structurally smaller…  most notably you can't have foldr for a colist
14:39:12 <Cale> Well, mutability is an independent thing, but it's hard to do any termination checking in its presence.
14:39:14 <ertes> and you can't have unfoldr for a list
14:40:48 <Cale> Note that while termination checking will guarantee that eager evaluation of data will terminate, that doesn't always mean it's always a good idea to use eager evaluation on data in that case.
14:40:50 <ertes> more generally:  you can only have catamorphisms for structures and anamorphisms for costructures, unless the structure/costructure is flat
14:41:13 <Cale> Lazy evaluation can still be critically advantageous, even in a setting where everything is guaranteed to finish.
14:41:48 <dolio> You can write a length function that terminates in Haskell if you use `data L a = N | C a !(L a)`.
14:42:07 <dolio> Terminates except on already non-terminating inputs.
14:42:21 <Cale> This is primarily because large finite values are a reasonably decent approximation to infinity -- it's easy to produce provably finite lists which are actually quite useful if evaluated lazily, and which which nevertheless you'll never be able to finish computing.
14:43:09 <Cale> s/which which/which/
14:43:10 <Cale> lol
14:43:26 <ertes> s//which/  -- i see a monad there =P
14:43:40 <Cale> haha
14:43:42 <EvanR> /usr/bin/which
14:44:02 <Cale> which: shell built-in command
14:44:16 <EvanR> black magic
14:45:33 <ertes> evil!  you can't reason about unix in terms of fixed points!
14:45:45 <dolio> People always forget that Haskell has all the finitary types that e.g. ML does (and ML has the infinitary ones). They're just written down slightly differently.
14:46:08 <dolio> And people tend not to use the finitary definitions.
14:46:29 <EvanR> your finitary list causes the whole thing to be evaluated early
14:46:43 <EvanR> as a "side effect"
14:46:43 <dolio> So does ML.
14:46:53 <EvanR> finite and lazy would be better
14:46:55 <erisco> how can I find what package a module comes from in ghci?
14:47:16 <glguy> erisco: From outside of ghci you can use: ghc-pkg find-module
14:47:16 <erisco> tracking down these sources has been a royal PITA -.-
14:47:25 <erisco> thanks
14:48:12 <erisco> how do I remember little commands like that
14:48:29 <ertes> dolio: i do use them, but i rarely think of them as "finitary!" or "data!", but rather as "faster!"
14:48:53 <glguy> erisco: I don't think that science fully understands memory yet
14:49:46 <erisco> still waiting for the cranial micro SD slot
14:49:53 <EvanR> why dont we remember the future
14:50:11 <EvanR> and what makes memory of the past legitimate
14:50:29 <erisco> because it hasn't happened yet EvanR, and that's all you need to worry your pretty little head about :P
14:51:12 <erisco> there isn't enough space here to unravel the timey wimey ball of this issue
14:51:22 <Cale> I can remember the future. Thanks, sandworms. Thandworms.
14:53:41 <erisco> the thyme must flow
14:55:18 <dogweather> Anyone use encodePretty' from aeson-pretty?
14:55:43 <glguy> Cale: Look around you; how many people do you suppose know that reference? :)
14:56:38 <dogweather> I can't get a working import for Config. Anyone have an example invocation of encodePretty'?
14:56:49 <glguy> (it's a funny set of videos if anyone hasn't seen them already)
14:57:15 <erisco> was I wrong? a coincidence if I was
14:59:13 <erisco> the interaction of documentation and TH is an unpleasant one
14:59:38 <erisco> it is like you've documented the assembly instead of the source
15:07:04 <reactormonk> How can I generate a lens for a record that I don't have control over?
15:07:16 <erisco> the problem is that SDecide Nat poops out of this https://github.com/konn/type-natural/blob/master/Data/Type/Natural/Definitions.hs
15:07:27 <erisco> not sure how to figure out what the actual instance is
15:08:01 <erisco> download the source and use some compile flag to generate TH only?
15:08:19 <glguy> reactormonk: The same way you'd do it for one you did have control over
15:08:30 <reactormonk> glguy, with Generics?
15:08:44 <glguy> No, we usually don't use Generics for generating lens
15:08:48 <glguy> lenses
15:09:00 <reactormonk> Why not?
15:10:06 <glguy> It's too tricky to get them to come out efficiently, and Generics are awkward to use when you're trying to do something like constructing one top-level definition for every field of a record
15:10:22 <reactormonk> oke
15:10:36 <glguy> I have examples of how to do it but it relies on extra flags to encourage GHC to optimize it correctly, and it's harder to explain how to use
15:10:55 <glguy> So it's more common to use Template Haskell or to write them out by hand
15:10:58 <erisco> anyone know what the instance likely is?
15:11:22 <erisco> I wager it isn't complicated but I haven't any experience with this stuff to guess myself
15:12:25 <erisco> ultimately I want a type like a :~: b but for comparisons, so it constructs as LT, EQ, or GT, rather than EQ or NEQ
15:12:56 <erisco> because I really need the proof of a ~ b in scope in the EQ case
15:13:06 <erisco> otherwise I'd just use SOrd
15:13:37 <kmelva> given finite list of integers, lets say `foo = [1, 2, 5, 10, 15]`, could you check that the list is monotonic using `fold`?
15:14:01 <erisco> so I want to look at how SDecide Nat was done so I know how to write my own
15:14:59 <erisco> kmelva, yup
15:15:25 <kmelva> erisco: dammit, I sill don't see how... are you sure you can? :D
15:15:31 <kmelva> erisco: if so, don't tell me how :)
15:15:57 <erisco> well I am frustrated with searching for code at the moment so sure, I'll write it
15:16:09 <glguy> kmelva: You want to do it with Data.Foldable.fold ?
15:16:42 <kmelva> glguy: yup
15:17:51 <erisco> well you can easily get all the other folds from that
15:19:47 <erisco> can we, say, map the integers to some Monoid whose mempty and mappend does what we want? I don't think so
15:19:59 <glguy> we can
15:20:02 <erisco> I don't know what mempty is
15:22:15 <glguy> as long as we're allowed to use foldMap or map, at least
15:22:18 <erisco> you're saying there is an easy f in foldMap f that solves this?
15:23:43 <noan_> does one need to update their hoogle data as they add dependencies to a project? I can get more info from ghc-mod than hoogle right now
15:23:43 <kmelva> erisco: I give up... :(
15:25:56 <erisco> maybe I can think of a rather ugly Monoid we can define
15:26:00 <lpaste> glguy pasted “foldMap implementation of isMonotonic for kmelva” at http://lpaste.net/352013
15:27:48 <erisco> :i Option
15:27:57 <kmelva> glguy: thanks! looks much more complicated than I thought it would :/...
15:28:05 <kmelva> Option is new for me...
15:28:09 <erisco> what is Option
15:28:17 <glguy> It's Maybe, but with a nicer Monoid instance
15:28:28 <glguy> instance Semigroup a => Monoid (Option a)
15:28:43 <erisco> I see
15:28:50 <glguy> compare to: instance Monoid a => Monoid (Maybe a) -- Defined in ‘GHC.Base’
15:29:02 <glguy> You don't have to use Option of course, it just makes it easier.
15:29:20 <glguy> (assuming you already know what it is)
15:29:34 <kmelva> it says in the docs "Ideally, this type would not exist at all and we would just fix the Monoid instance of Maybe"
15:29:39 <kmelva> what are they referring to?
15:30:01 <erisco> Monoid demands an identity, Semigroup does not, and the Maybe instance for Monoid does not use the identity
15:30:03 <glguy> Instead of requiring a Monoid a instance, it requires a Semigroup a instance as seen in what I pasted above
15:30:10 <erisco> so it is over-constrained
15:30:58 <kmelva> allrighty... I'll have something to read in the morning :)
15:31:02 <kmelva> thanks folks, 'night...
15:31:04 <reactormonk> glguy, got a TH sample off hand?
15:31:18 <glguy> reactormonk: sample of it doing what?
15:31:30 <reactormonk> lenses
15:31:48 <glguy> Yeah, there are samples in the lens documentation in the Control.Lens.TH module
15:33:24 <recursion-ninja> Hey guys I have a haskell frogram that segfaults when I call a C FII function. I ran valgrind on the Haskell executable and it looks like a null pointer is being passed as a parameter to the C function despise have non-null pointers being passed on the Haskell side. Do you guys have any ideas on how to debug this?
15:33:48 <erisco> glguy, that is an excellent answer. I've bookmarked it :)
15:33:59 <reactormonk> glguy, kk, thanks
15:34:23 <glguy> recursion-ninja: I'd check that you've imported the C function with the correct Haskell type.
15:35:20 <systadmin> > map odd [1, 3, 5]
15:35:22 <lambdabot>  [True,True,True]
15:35:50 <recursion-ninja> glguy: I think I've generated the pointer to the C struct correctly, but hsc2hs seems like there's a lot of "black magic" occuring and I fear I've made a mistake somewhere with hsc2hs and the source of the error is obscured.
15:35:56 <M0000> I’m getting a seg fault… is it wrong to run an InterpreterT computation (enter it and exit it) twice in the same program?
15:36:21 <erisco> glguy, I was thinking similarly but was stuck with NotMonotonic not being an identity, but wrapping it in Option works
15:36:32 <M0000> also any advice for debugging a seg fault would be helpful
15:36:47 <Tuplanolla> Why is everyone getting segmentation faults today?
15:36:47 <recursion-ninja> M0000: Same boat as me, huh?
15:37:05 <erisco> glguy, then also I was thinking to store just a number rather than a range which should work but becomes dependent on the fold association
15:37:12 <recursion-ninja> Tuplanolla: Clearly, it's national segfault day in Haskellandia!
15:37:13 <M0000> recursion-ninJa: I wasn’t following the conv, you have a seg fault?
15:37:24 <erisco> glguy, so I suppose that is either a feature or a defect
15:37:35 <recursion-ninja> M0000: Yeah, with hsc2hs and a C FFI binding.
15:37:58 <dmwit> > appEndo (foldMap (\x -> Endo (\(isMonotonic, min) -> (maybe isMonotonic (\m -> x <= m && isMonotonic) min, Just x))) [1,2,3,4]) (True, Nothing)
15:38:00 <lambdabot>  (True,Just 1)
15:38:08 <dmwit> > appEndo (foldMap (\x -> Endo (\(isMonotonic, min) -> (maybe isMonotonic (\m -> x <= m && isMonotonic) min, Just x))) [1,2,4,3]) (True, Nothing)
15:38:11 <lambdabot>  (False,Just 1)
15:39:26 <erisco> dmwit, oh the ranges are dependent on association too, of course
15:39:29 <erisco> why a range then
15:39:53 <M0000> recursion-ninja: if someone else comes here with a segfault then I think clearly Satan is at work
15:40:04 <dmwit> erisco: I'm not sure I understood your statement or your question.
15:40:23 <erisco> dmwit, that is because I am replying to the wrong person :P got confused
15:40:57 <dmwit> erisco: FWIW, my solution stores just a number and not a range. =)
15:42:51 <glguy> erisco: No, the ranges aren't impacted by reassociation
15:46:10 <erisco> sorry for some reason commutativity was popping into my head
15:46:54 <erisco> neither the ranges nor points vary by assocation
15:47:06 <erisco> what was the thought with ranges?
15:47:24 <recursion-ninja> M0000, glguy, ertes: I solved my segfault issue. The artiy of the C function was 4 but I incorrectly defined the type signature of the C function in Haskell with an arity of 5. Thanks for suggesting I check the type signatures again! If only this could have been a compile time error somehow...
15:48:23 <ph88> i have this command that runs a quickcheck test    main = qcrp (get :: Parser AddingOperator) Nothing    if i change the thing after Parser then i can test a get function from another type. I would like to give it a list of all types to test in a specific order, is that possible ?
15:48:44 <erisco> oh, the points are wrong, heh
15:49:06 <erisco> and changed by association... the heck is wrong with me
15:50:14 <erisco> so you either have a policy of keeping the min or the max
15:50:25 <ertes> recursion-ninja: hmm?  passing extra arguments to C functions shouldn't be a problem
15:50:33 <ertes> the calling convention supports it
15:50:41 <erisco> say we keep maxes, then  2 <> (1 <> 3) is 2 <> 3 is 3 is monotonic (not!)
15:51:04 <erisco> (2 <> 1) <> 3 is NotMonotonic <> 3 is NotMonotonic
15:51:45 <erisco> if you keep maxes you have to be left-associated
15:51:50 <erisco> if you keep mins then right-associated
15:52:00 <erisco> assuming we're doing <
15:52:13 <glguy> dmwit: Now adapt yours so that it can handle the input (2 : repeat 1)
15:52:16 <erisco> by keeping the range we're agnostic
15:52:29 <glguy> dmwit: (Mine already doesn't, I had to modify it to)
15:52:59 <erisco> I don't know but I suspect there is no particular way to reason about this with fold or foldMap so only ranges can be correct here
15:57:45 <erisco> glguy, so you have to add some zero, yes?
15:59:13 <erisco> then this becomes a... what is it...
16:01:06 <recursion-ninja> ertes: Maybe a warning to suggest that you might have made an arity mistake. I think the caseof mistakes greatly out weighs the cases of intentional usage.
16:02:34 <erisco> whatever a monoid + zero is
16:02:48 <erisco> welcome to the algebra zoo
16:05:52 <dmwit> glguy: Hm. =)
16:07:58 <glguy> dmwit: It's a really simple fix, so don't change much!
16:08:59 <erisco> I changed a lot, darn it :P
16:09:50 <glguy> OK, you can add any one character you want
16:10:04 <erisco> is it ~
16:11:04 <erisco> I am actually confused right now as to what I have done wrong, hrm
16:11:17 <dmwit> > appEndo (foldMap (\x -> Endo (\ ~(isMonotonic, min) -> (maybe True (x<=) min && isMonotonic, Just x))) (2 : repeat 1)) (True, Nothing)
16:11:20 <lambdabot>  (False,Just 2)
16:12:16 <glguy> and... as many spaces as you need for it to parse afterward :)
16:12:28 <dmwit> right =)
16:13:18 <dmwit> I also lifted the (&&) out because it is prettier that way. ;-)
16:18:03 <erisco> aren't you depending on the associativity though
16:18:12 <dmwit> :t \f -> appEndo . foldMap (\x -> Endo (\old -> f x old <> old))
16:18:13 <erisco> be it left or right
16:18:14 <lambdabot> (Monoid a, Foldable t) => (t1 -> a -> a) -> t t1 -> a -> a
16:18:27 <erisco> of course for it to terminate we're hoping it is right-associative
16:18:34 <erisco> but nonetheless an assumption
16:21:05 <taktoa> I just realized something pretty funny: I've been writing Haskell for nearly 6 years now and the syntax highlighting for Haskell on the HaskellWiki has been broken the entire time (`'a'` is incorrectly matched by `['].*[']` rather than `['](.|[\]['abenr...])[']` or something)
16:22:28 <taktoa> (the consequence is that identifiers containing `'` are highlighted like strings)
16:23:50 <erisco> I am not sure how your solution works dmwit, hm
16:24:04 <erisco> how does it reveal the min without forcing the entire list
16:25:27 <erisco> oh I see, it passes it forward
16:25:52 <erisco> that is the funky interaction of folds and functions that I have a hard time seeing
16:26:18 <erisco> usually you're thinking about accumulating something from the tail
16:26:23 <erisco> but this way it is just the opposite
16:29:43 <dmwit> erisco: Trick question, it doesn't reveal the min.
16:30:06 <dmwit> It reveals the head. The name `min` is a psychological trick.
16:31:23 <erisco> yet I am still confused... lets go through this for [2,1]
16:32:40 <dmwit> this becomes [\(i,m) -> (maybe True (2<=) m && i, Just 2), \(i,m) -> (maybe True (1<=) m && i, Just 1)] from the map
16:32:47 <erisco> [\(isMono, min) -> (maybe True (2<=) min && isMono, Just 2), ...
16:32:59 <dmwit> Okay, you type. =)
16:33:39 <erisco> so that is applied to (True, Nothing) and we get  [maybe True (2<=) Nothing && True, Just 2), ...  which is  [(True, Just 2), ...
16:33:43 <erisco> good so far?
16:34:00 <dmwit> no no
16:34:10 <dmwit> first the fold, *then* the application
16:34:48 <erisco> yes I know it is stuck together with composition, I am just reducing the first part
16:34:55 <dmwit> (\(i,m) -> ...2...) . (\(i,m) -> ...1...) $ (True, Nothing)
16:36:09 <erisco> oh, the composition is in the other order?
16:36:38 <dmwit> Specifically: `(\(i,m) -> (maybe True (2<=) m && i, ...)) . (\(i,m) -> (..., Just 1)) $ ...`
16:37:04 <erisco> that doesn't seem possible
16:37:22 <erisco> if that were the order, how does this ever terminate for infinite lists?
16:37:46 <dmwit> Because you don't need to see the `...`s in the above expression to make progress...
16:38:00 <erisco> I am just talking about the composition
16:38:10 <dmwit> So am I, I think.
16:38:28 <erisco> if we have f . g $ x  we have to know g to apply to x, yes?
16:38:31 <dmwit> In an infinite list, the last `...` will be an infinitely long chain of compositions. But it doesn't matter because you don't need to see it to make progress.
16:38:39 <dmwit> erisco: no =)
16:38:57 <erisco> oh right, just f, derp
16:39:11 <erisco> the f guards the g... no wonder I get so confused
16:39:13 <dmwit> > const 3 . undefined $ undefined
16:39:15 <lambdabot>  3
16:39:47 <erisco> I'm just stupidly thinking composition is right-to-left
16:40:02 <erisco> which doesn't actually reflect the order of evaluation
16:40:06 <erisco> which is left-to-right :P
16:41:37 <ph88> is that normal to get 54MB binaries from 4K LOC ?
16:42:08 <dmwit> I bet I can hit that with fewer than 4K. =)
16:42:26 * dmwit imports Acme.AllOfHackage
16:42:56 <ph88> no dead code elimination ?
16:43:21 <dmwit> I'm not sure. But even if it's done, the default is for everything to be statically linked.
16:43:29 <dmwit> So big libraries -> big executables.
16:45:24 <mniip> dmwit, acme-everything it's called
16:45:32 <mniip> it's the initial object in the hackage category
16:45:48 <Koterpillar> is Prelude final then?
16:46:17 <c_wraith> base depends on things like ghc-prim
16:47:24 <dmwit> I wonder if there's any package on Hackage that neither depends on base nor is depended on by base.
16:48:04 <c_wraith> there is at least one package that consists only of macros for use with hsc
16:48:28 <c_wraith> no haskell code in that package! 
16:48:58 <dmwit> hah! what cheaters
16:49:20 <ph88> when i load code in ghci it's near instantanious compilation (lets say 30 seconds) now with a ton of optimizations turned on its taking already 25 minutes .. this is also normal ?
16:51:24 <dmwit> 25 minutes is a very long compilation time.
16:51:51 <ph88> you think there might be a problem and ghc got stuck ?
16:52:08 <erisco> just enough time for a sword fight
16:54:01 <geekosaur> with the amount of information you've provided (none) all you're likely to get is wild guesses
16:54:19 <erisco> dmwit, min of the tail
16:54:33 <erisco> dmwit, I'll have to review this several times so I can intuit the pattern next time
16:54:53 <erisco> many surprises packed in there!
16:58:01 <dmwit> It's not the min of the tail either.
16:58:30 <dmwit> I mean, it's not actually the minimal value in the tail.
16:58:52 <erisco> well, yes, I suppose I meant the head of the tail
16:59:04 <erisco> if it were monotonic then it would be the minimal
16:59:15 <dmwit> right
16:59:42 <erisco> there are wonderful subtle parts like the operand ordering over &&
17:00:15 <dmwit> I admit that was a bit more tricky than I would like in production code. =)
17:01:08 <erisco> not that you would write such a thing in production code
17:01:17 <erisco> a function which only terminates on False? I don't think so :P
17:10:16 <halogenandtoast> I wrote some code that I'd love to make better, but I think I need some help. If anyone is feeling generous today, I have two small functions (in a yesod app) that I'd like to make better: https://github.com/halogenandtoast/nhk-reader-haskell/blob/master/Handler/Story.hs and https://github.com/halogenandtoast/nhk-reader-haskell/blob/master/Util/Nhk.hs
17:24:05 <ertes> halogenandtoast: (case b of True -> x; False -> y) = (if b then x else y)
17:24:32 <ertes> for the most part i also prefer 'maybe' over explicit pattern-matching
17:24:34 <ertes> :t maybe
17:24:35 <lambdabot> b -> (a -> b) -> Maybe a -> b
17:25:37 <halogenandtoast> ertes: Good call on the `if`
17:25:54 <mniip> ski, you around?
17:26:39 <ertes> halogenandtoast: i'm not entirely sure, because i don't know the business logic going on, but it could also be that your code is currently boolean-blind
17:27:27 <halogenandtoast> ertes: Googling this term
17:27:46 <ertes> halogenandtoast: here is the theory: https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
17:28:06 <ertes> halogenandtoast: here is a more practical example-based explanation: http://ertes.eu/tutorial/foldr.html#heads-tails-and-a-digression
17:29:32 <halogenandtoast> ertes: thanks will read
17:35:47 <halogenandtoast> ertes: I tried something like this with `maybe` but it doesn't work out, it it obvious what I'm doing wrong `maybe (return story) (\a -> updateGet storyId [NewsStoryBody =. a, NewsStoryFetched =. True]) fetched` the compiler is telling me `Couldn't match type ‘Text’ with ‘Maybe Text’`
17:36:31 <halogenandtoast> and fetched shoud be a Maybe Text
17:37:10 <halogenandtoast> nevermind I figured it out
17:37:32 <halogenandtoast> I changed `NewsStoryBody` to a Maybe type so I need to rewrap it
17:51:47 <systadmin> Haskell doesn't have loops built in? 
17:52:30 <Sonolin> you mean recursion? Yes
17:53:33 <systadmin> Like `while` and `for` loops?
17:54:21 <markasoftware> systadmin: there's some weird monad replicateM and forM things
17:54:25 <markasoftware> but they're usually used sparingly
17:54:27 <markasoftware> usually just recursion
17:54:28 <Sonolin> no, haskell is a functional language and isn't going to have a similar thing 
17:54:42 <markasoftware> they're for special purposes (mainly I/O related i think)
17:55:02 <halogenandtoast> The recursion in Haskell though it so beautiful, that it took me a long time to realize it didn't have oop style loops.
17:55:10 <halogenandtoast> s/it so/is so/
17:56:04 <markasoftware> it's still a bit confusing sometimes to me, to get my head around how to do a more complex problem without a loop
17:57:18 <yushyin> we have a monadic while \o/ https://hackage.haskell.org/package/loop-while-1.0.0/docs/Control-Monad-LoopWhile.html
18:00:19 <ertes> systadmin: loops don't make sense in haskell
18:00:47 <ertes> systadmin: programs are first-class values, and the way you would write imperative loops is by constructing programs that do stuff repeatedly
18:00:58 <ertes> easy example: 'forever'
18:01:36 <ertes> forever action = action >> forever action  -- (forever action) is the action that first runs 'action' and then (forever action)
18:02:19 <ertes> in other words: loop constructs are really just regular haskell functions
18:05:36 <markasoftware> not sure if they're listening anymore...
18:13:24 <stew> I need help understanding some syntax I'm not familiar with. I'm trying to duplicate this example: https://hackage.haskell.org/package/console-program-0.4.2.0/src/Examples/Full.hs ; the "countUp" function here, appears to call a "command" funciton, which is the first function here: https://hackage.haskell.org/package/console-program-0.4.2.0/src/src/System/Console/Command.hs ; but I don't understand what is b
18:13:30 <stew> eing passed to this function: { name = "down",,, }
18:15:41 <geekosaur> that's record update syntax
18:15:46 <erisco> am I speaking any sort of sense here? http://lpaste.net/352019
18:16:10 <Welkin> erisco: you are always trying to do something weird
18:16:12 <geekosaur> `command` is a record, or something which produces a record; foo {...} is the record produced by foo with various fields replaced as specified in the {...}
18:16:23 <Welkin> you mean Command 
18:16:23 <Welkin> :P
18:16:39 <Welkin> `command` is a kind of "smart constructor"
18:17:04 <stew> geekosaur: I don't understand. the type signature of command is "command :: String -> String -> Action m -> Command m"
18:17:34 <Welkin> yes, it takes a name, description and action
18:17:38 <stew> geekosaur: and the function application is command { name = "foo", description = "bar", ...}
18:17:38 <Welkin> and constructs a new Command
18:17:52 <Welkin> Command is a type constructor
18:18:02 <stew> geekosaur: are these things like name pulled out of this record positionally?
18:18:12 <stew> and why doesn't my compiler like it when I try to do the same thing?
18:18:14 <Welkin> the { name = n, ...} is record update syntax, which changes the values of the record
18:18:16 <erisco> I am not completely sure what to do with the disproofs
18:18:32 <erisco> we can do disproofs constructively but I don't see how with this setup
18:18:44 <stew> Welkin: changes to *which* record?
18:18:49 <Welkin> stew: Command
18:18:58 <stew> where does Command come from?
18:19:06 <stew> this is applying to a function command, not Command
18:19:16 <erisco> :<: can't contain both proofs and disproofs
18:19:33 <stew> is "command { name = "foo" }" doing something other than applying a single argument to a function?
18:19:36 <Welkin> https://hackage.haskell.org/package/console-program-0.4.2.0/src/src/System/Console/Internal.hs
18:19:44 <Welkin> you are typing that wrong stew
18:19:49 <stew> Welkin: how so?
18:19:50 <Welkin> it is not `command`
18:19:54 <Welkin> it is `Command`
18:19:58 <Welkin> they are not the same thing
18:19:58 <stew> no, its command
18:20:20 <Welkin> Command is defined in the file I linked
18:20:21 <stew> Welkin: see the definition of "countUp" here: https://hackage.haskell.org/package/console-program-0.4.2.0/src/Examples/Full.hs
18:20:26 <Welkin> command is just a function
18:20:30 <stew> exactly
18:21:19 <Welkin> what is your question?
18:21:31 <stew> how this works?
18:21:36 <stew> the example?
18:21:46 <stew> command { name = "foo", description = "bar" }
18:21:53 <geekosaur> Welkin, did you by any chance look at the referenced file? (definition of countUp)
18:21:55 <Welkin> maybe it doesn't
18:21:57 <geekosaur> which very definitely has a lowercase c
18:21:57 <Welkin> who knows
18:21:59 <Welkin> have you run it?
18:22:22 <stew> I tried to duplicate this in my project and can't get it to compile
18:22:29 <Welkin> I told you why
18:22:34 <erisco> I know there is %:< but I am just trying to see if I am grasping the concepts
18:22:38 <geekosaur> what I suspect is the example is out of date
18:22:39 <Welkin> don't blindly copy examples that may in fact be broken
18:22:40 <stew> Welkin: so the example is wrong?
18:22:42 <erisco> hard to see because they have it all hidden in TH
18:22:58 <erisco> I think I am on the money though
18:23:14 <stew> Welkin: what do you mean by blindly?
18:23:26 <Welkin> stew: the example may very well be wrong
18:23:31 <stew> right
18:23:35 <geekosaur> Welkin seems to think you are doing something other than asking why an example doesn't make sense
18:23:38 <Welkin> in this case, it must be
18:23:47 <stew> ok so shoudl I report this?
18:23:53 <Welkin> well, you didn't ask why the example makes no sense
18:24:04 <Welkin> you asked why your code (which you said you copied from that file) doesn't work
18:24:19 <stew> I don't understand the differencd I'm sorry I don't udnerstand what I'm doing wrong
18:24:22 <stew> just trying to learn
18:24:35 <Welkin> forget about the example
18:24:38 <stew> why?
18:24:49 <Welkin> because it's wrong/out of date/etc or something
18:24:52 <stew> if the example is wrong it should be fixed right?
18:25:01 <Welkin> sure, but that is not your goal, is it?
18:25:12 <Welkin> if so, you can make a pull request to the relevant repo
18:25:26 <stew> is that something I do through hub.darcs.net?
18:26:02 <Welkin> no idea
18:26:05 <Welkin> I don't use darcs
18:26:17 <stew> oh, how would you make a pull request then?
18:26:18 <Welkin> and this library is not just some random one to me
18:26:30 <Welkin> it's not part of base, so I don't think it's relevant to report bugs about it here
18:26:31 <erisco> problem with this is there are probably just a handful of people who understand it
18:26:41 <Welkin> is just some random one*
18:27:11 <stew> Welkin: where do I report bugs about it, I'm happy to do it wherever, this was the first place I thought to ask, sorry
18:27:17 <Welkin> if your goal is to have a working program, re-read my expalanation of Command vs command above
18:27:25 <stew> yeah, I get that
18:27:30 <stew> my goal now is to get the example fixed
18:27:32 <Welkin> stew: I don't know, since it's not my project
18:28:10 <stew> hmm
18:28:35 <Benzi-Junior> ok where does stack actually dump core when you add --ddump-simpl to the .cabal file ?
18:28:49 <Welkin> I don't see anywhere on the darcs page to report bugs or anything
18:28:55 <Welkin> maybe you need to be registered and signed in?
18:29:01 <stew> I just did, still don't see that
18:29:10 <Welkin> typically I do this through github
18:29:25 <Welkin> there is no contact information listed either
18:29:40 <Welkin> it looks like you are out of luck on that for now
18:29:41 <geekosaur> Benzi-Junior, somewhere under ~/.stack-work
18:29:43 <stew> i swear I've run into fundamental problems like this with the majority of the packages I try to use
18:29:53 <geekosaur> because stack itself is using some -d options with -ddump-to-file
18:29:55 <Welkin> sometimes packages just get abandoned too
18:30:10 <stew> so lets say this package was in fact abondoned. How would a fix get uploaded?
18:30:27 <Welkin> stew: it wouldn't
18:30:32 <Welkin> you would fork it and start a new one
18:30:42 <stew> it will never ever get fixed?
18:30:45 <erisco> damn now I have to think of how I determine if two things are the same type but not necessarily equal terms
18:30:46 <Welkin> or rewrite it yourself and start a new package
18:30:46 <stew> a new one with a new name?
18:31:07 <stew> that seems extreme
18:31:08 <Welkin> stew: yes
18:31:15 <Welkin> it has happened many times before with parsing libraries
18:31:42 <Welkin> usually for popular packages, it's not an issue
18:32:12 <stew> and how does one know if a package is popular? :)
18:32:13 <erisco> nvrmind
18:32:31 <Welkin> oh, I found an email in the .cabal
18:32:32 <Welkin> http://hub.darcs.net/AriePeterson/console-program/browse/console-program.cabal
18:32:38 <Welkin> ariep@xs4all.nl
18:33:25 <stew> so far I'm 0/4 on getting any kind of response from emailing package maintainers like this
18:35:21 <Benzi-Junior> geekosaur: any idea how to find out where
18:35:50 <Welkin> Benzi-Junior: any relation to benzrf?
18:36:07 <Welkin> stew: number of downloads
18:36:14 <Welkin> or it is part of base
18:36:32 <Benzi-Junior> Welkin: not that I'm aware of
18:37:08 <Welkin> Benzi-Junior: are you in israel?
18:37:16 <Benzi-Junior> no I am not
18:38:14 <geekosaur> Benzi-Junior, I'd use find to figure it out (you are looking for a file <modulefilename>.dump-simpl)
18:38:57 <stew> well, I emailed the maintainer, I look forward to his reply....
18:40:31 <erisco> I think what I'd like to see is  data Ordering (a :: k) (b :: k) where LT :: a :<: b -> Ordering a b; GT :: a :>: b -> Ordering a b; EQ :: a :~: a -> Ordering a a
18:41:03 <Axman6> an ordering on types?
18:41:11 <Axman6> or does that define an ordering on types?
18:41:23 <erisco> so it collects the various comparison proofs together... not sure if this works in practice with promotion and so on
18:42:15 <erisco> it doesn't define an ordering on types, it merely creates a sum kind of types, where the types are serving as propositions
18:42:35 <erisco> so it is the sum of the proposition a < b, a > b, and a = b
18:43:37 <erisco> I'd have to think if a GADT is what is appropriate here but that is roughly what I am thinking
18:44:06 <erisco> because as it stands it seems the best I can use is sCompare which gives me Sing Ordering and that contains no proofs
18:44:21 <erisco> so I can pattern match on it but discover nothing about the types
18:44:33 <erisco> then there is %~ where I can pattern match to discover equality
18:44:59 <erisco> so my code has to mix sCompare with %~
18:45:17 <erisco> sCompare to find EQ and then an essentially redundant %~ to get the equality proof out
18:46:05 <erisco> I know their SOrd class is designed specifically to mimic Ord so they can lift functions with their TH jazz
18:46:41 <erisco> but there is seemingly no alternative
18:47:18 <erisco> I am not sure how :~: succeeds with being just a data type... I have to look more closely at that
18:47:32 <erisco> because the only obvious way to do :>: and :<: is as data families
18:51:14 <erisco> my suspicion is that deciding the equality is the exact same as deciding the type equality, and Haskell is already capable of that
18:51:42 <erisco> they are singletons and so if Haskell can solve the type equality for you then there is no reason to write the term equality
18:52:31 <Lokathor> you can't force the main thread to exit from a side thread while the main thread is running a foreign call
18:52:39 <Lokathor> i've written myself into a corner
18:57:18 <erisco> just keep finding more corners and you'll eventually round it out
19:00:06 <joneshf-laptop> I've got a "canonical" structure and a "view" of that structure with less info, e.g. `canon :: [(Tag, Text)]` vs `view :: Text` where `view = unwords $ snd <$> canon`. Is there a pattern or general approach that allows editing of the "view" and the changes reflected in the "canonical" structure?
19:00:36 <joneshf-laptop> It feels very optical, but I don't know how it might actually work.
19:02:37 <erisco> not quite as how you have it, but consider if you have  editView :: (Text -> Text) -> [(Tag, Text)] -> [(Tag, Text)]
19:03:10 <joneshf-laptop> Oh, right. I'm totally up to change any of it.
19:03:14 <erisco> generally speaking you're getting into lenses which isn't in my expertise
19:03:27 <erisco> but there are advocates here happy to sell you on it
19:03:48 <joneshf-laptop> So how would `editView` work in this case?
19:04:44 <erisco> editView = fmap . fmap
19:05:58 <joneshf-laptop> I mean, what would you be passing to `editView`.
19:05:58 <erisco> you apply your editing function to every Text
19:06:11 <erisco> the editing function and then your source
19:06:23 <joneshf-laptop> What is the editing function?
19:06:40 <erisco> that is up to you. What do you want to do to your Text? anything that has type Text -> Text
19:07:30 <joneshf-laptop> I think I was a bit unclear with the example I gave :).
19:08:27 <Lokathor> erisco, the sensible answer is "stop using a blocking FFI call" :3
19:08:57 <erisco> Lokathor, will that work with GC?
19:09:28 <joneshf-laptop> erisco, So, let's say the "canonical" structure loos like: `[(Good, "Hello"), (Indifferent, "there"), (Indifferent, "you")]`. Then the "view" would look like `"Hello  there you"`.
19:09:40 <joneshf-laptop> looks like*
19:09:44 <mniip> ohhhhhh
19:10:11 <mniip> &&& is just a mediating morphism for the binary product
19:10:12 <erisco> I see
19:11:02 <erisco> well, you first have to choose a different type for your view, because there is no way to reverse it
19:11:05 <Lokathor> erisco, I have no idea if it works with GC actually
19:11:19 <erisco> given a string of characters you cannot determine which substrings go where
19:11:55 <mniip> now where's the comediating morphism for the binary coproduct?
19:12:25 <mniip> Arrow a => a x z -> a y z -> a (Either x y) z
19:12:37 <erisco> so one representation is [Text]
19:12:50 <erisco> i.e. ["Hello", "there", "you"]
19:12:55 <mniip> huh that's ArrowChoice
19:13:06 <mniip> how did it happen that these are two different typeclasses
19:13:32 <mniip> more importantly, how did it happen that Arrow is a superclass of ArrowChoice
19:13:51 <erisco> but this gets a bit janky because if we map [Text] -> [Text] we're not sure the length is invariant
19:14:09 <erisco> and so we're not sure if we have a Text to give to every 2-tuple
19:14:19 <erisco> we might choose a policy for what happens with extra or missing Texts
19:14:20 <Koterpillar> erisco: that's why two fmaps
19:14:55 <erisco> well that will not work if you need to consider many of the elements at once, which I presume is the case
19:15:03 <erisco> otherwise we'd just look at them individually with fmap . fmap
19:16:09 <erisco> we can use lists with typed lengths but trust me that that isn't your desired first choice
19:16:22 <joneshf-laptop> Well, I guess what I'm wondering is less in the case of this specific example and more in the general case.
19:16:39 <joneshf-laptop> FWIW, my actual problem is almost exactly like the example I gave.
19:17:20 <erisco> if you only need to consider one Text at a time then fmap . fmap is the general solution
19:17:37 <erisco> for a more sophisticated and broader solution look to lenses
19:19:44 <erisco> if you have to consider multiple elements then I am not sure. It depends on the need
19:19:52 <erisco> you might use a left or right fold, for example
19:20:24 <erisco> you might use lists with typed length
19:22:07 <erisco> or lists without typed length if you want to cowboy it ;)
19:25:01 <joneshf-laptop> erisco, I don't think I'm explaining my thoughts well right now, but thanks for your insights!
19:25:39 <erisco> you might also succeed with both aggregating the Texts and using fmap . fmap
19:26:04 <erisco> so you can look at both all elements and the particular element at hand
19:26:37 <erisco> maybe the current element is indicated by an index into the aggregate
19:27:50 <erisco> joneshf-laptop, well we can go over your specific case and maybe extrapolate from that
19:35:05 <erisco> joneshf-laptop, you certainly cannot edit in the sense of mutate, that isn't part of Haskell
19:39:03 <joneshf-laptop> erisco, nah, I think tonight is not a good night for me to ask this question :). But, I thank you for your help.
19:39:16 <erisco> well here is another crazy idea
19:39:25 <joneshf-laptop> And for offering to go further.
19:39:39 <Ptival> given a multi-param-typeclass (Coerce a b), is is possible to create an alias (CoerceTo b a) such that one can use the family (CoerceTo TargetType)?
19:39:55 <Ptival> it seems Haskell insists on the alias being always fully-applied
19:40:01 <erisco> lets say we have Text -> Instr
19:40:37 <erisco> so we gather together the Texts to get our "Hello there you" and pass this to the editing function
19:41:04 <erisco> but the editing function does not return a new Text, it instead returns an instruction, or sequence of instructions, on how to manipulate the Text
19:41:49 <erisco> this is relevant because if the editing function just gave us a Text we do not necessarily know how to map back to canonical form
19:41:59 <erisco> but maybe with a particular instruction set we would
19:44:02 <erisco> then what you have is an eDSL
19:44:10 <erisco> the sledgehammer to all problems
19:45:44 <erisco> Ptival, that is correct, aliases must always be fully applied
19:46:00 <erisco> had a long discussion about that and I unfortunately forget the conclusions :P
19:46:17 <erisco> I think the problems came out with polymorphic recursion and one other spot
19:47:21 <erisco> it seems that most of us have just taken the fact for granted
19:48:18 <Ptival> erisco: yeah, from what I see, it's just disallowed to avoid higher-order-unification issues
19:48:27 <Ptival> wondering whether there is a known trick for this
19:48:40 <erisco> well you can use a newtype... that is the standard thing
19:48:42 <Ptival> I guess I can make two type ConvertFromTo a b and ConvertToFrom b a
19:49:16 <erisco> there is likely a Flip :: (* -> * -> *) -> * -> * -> * defined somewhere
19:50:02 <erisco> or I guess we can polykind it up
19:50:20 <mniip> that would need to be either a newtype or a fully applied tysyn
19:50:23 <Ptival> looks like in Bifunctors
19:51:01 <Lokathor> erisco, i fixed it!
19:52:35 <erisco> Lokathor, now you can relax and make a cup of coffee :)
19:53:40 <erisco> sometimes the solution to a bug is so bad you can only recover by spending time in the fetal position
19:55:41 <Lokathor> it's not a bug exactly
19:55:47 <Lokathor> i mean GHC was doing exactly what it said it would do
19:55:55 <Lokathor> i was jsut asking the wrong thing of it
20:03:43 <erisco> given a singleton type how do you get its term?
20:03:50 <erisco> obviously there should be a type class for this
20:04:47 <erisco> I think it is called sing :D
20:06:49 <Lokathor> sing :: Aria
20:07:02 <Lokathor> sing :: Ska
20:14:56 <erisco> thank-you unwords for making Show instances a little easier to write
20:19:28 <halogenandtoast> ertes: I read up on Boolean blindness, I think different people think it's different things. I thought this was an interesting article about it: https://cs-syd.eu/posts/2016-07-24-overcoming-boolean-blindness-evidence.html
20:19:42 <halogenandtoast> and I think this kind of thing was what you were alluding to.
20:22:34 <ertes> halogenandtoast: partially…  i disagree with renaming Bool
20:24:30 <ertes> whether you call it "Bool" or "Cheeseburger" doesn't really matter…  in fact Cheeseburger is really just a less convenient version of Bool, because you need to write an entirely new API around it
20:26:00 <halogenandtoast> ertes: sure but I assumed that maybe you meant I needed to provide more information about a story
20:26:11 <halogenandtoast> being fetched or unfetched
20:26:25 <halogenandtoast> rather than asking it if it was fetched or not
20:26:49 <ertes> halogenandtoast: remember that i don't know whether your code really suffers from it at all
20:27:17 <halogenandtoast> Sure, but I was trying to understand the impetus for you mentioning it at all.
20:27:27 <halogenandtoast> You pretty much saw all of the code in my application
20:32:19 <ertes> halogenandtoast: style note:  _c >>= maybe _n _j
20:33:06 <halogenandtoast> ertes: oh nice
20:33:17 <halogenandtoast> I like that better as well, but not sure why
20:33:25 <halogenandtoast> what is the "theme" that drives that
20:33:48 <ertes> it avoids a short-lived name and exposes the data flow directly…  that's why you like it =)
20:34:26 <erisco> WHAT WAS THE ORIGINAL?
20:36:17 <ertes> revisiting your code my issue, as far as i understand your code, may be that a 'story' is not necessarily a "story"
20:37:16 <ertes> in my idea of well-designed code there is never any doubt as to what a piece of data is, whenever its type is fully known
20:37:41 <ertes> in other words a Story is a story, period…  there is no such thing as a "story that still needs to be fetched"…  that thing should have a different type
20:43:56 <erisco> I like to say what data is by the functions I define on it
20:44:16 <erisco> rather than saying data ought to be this or that
20:48:28 <jmnoz> is there a simple way to see how many dependencies each of my package dependencies (in .cabal) require?
20:52:59 <jmnoz> would be pretty nice if the number of direct and indirect dependencies for packages was.. a more highlighted number
21:04:31 <halogenandtoast> ertes: is that possible with having to define a model in Yesod
21:04:37 <halogenandtoast> sorry for the delay, had a meeting.
21:06:14 <Axman6> jmnoz: stack gives you a few options for that I think, including dot output for graphviz
21:11:38 <MarcelineVQ> stack list-dependencies | wc -l  would give a barebones count
21:13:00 <ertes> halogenandtoast: it's probably more of a 'persistent' question than a yesod question, and one thing i don't like about 'persistent' is that it insists on your data types to directly correspond to database tables
22:02:17 <Siegfried> May not be a good place to ask :) but anyone have thoughts on ocaml or haskell as a first functional language?  I've heard different viewpoints
22:05:02 <wz1000> Is it possible to express the law of the excluded middle in the type system
22:05:30 <wz1000> i.e construct a value of the type forall a. Either a (a -> Void)
22:07:25 <liste> :t Right absurd
22:07:27 <lambdabot> Either a (Void -> a1)
22:07:32 <liste> oh wait
22:07:43 <liste> that's the other way round
22:18:49 <halogenandtoast> ertes: true, it is a persistant problem (not yesod).
22:19:08 <halogenandtoast> ertes: Is there a better database interface (not that yesod really gives me a choice)
22:19:13 <halogenandtoast> but let's say I was using snap
22:27:18 <jle`> wz1000: that looks like a good shot
22:29:53 <jle`> wz1000: you can also get something equivalent through Peirce's law
22:31:08 <jle`> wz1000: forall a b. ((a -> b) -> a) -> a
22:32:57 <jle`> wz1000: https://gist.github.com/ion1/058ee03fd82a7b453933
22:33:15 <jle`> oh wait that gist just has the exercise, not the solution haha
22:43:57 <quack_> I need help  with writing a Haskell function
22:44:47 <quack_> I want to write a function called waterGate, and if the function is 3 + 4x, then the function selects 1, and if it is 7+4x, the functions selects 3
22:45:05 <quack_> NVM
22:50:45 <jle`> interesting name for such a function
22:53:09 <ertes> halogenandtoast: i generally model the application instead, so i use database libraries like postgresql-simple directly
22:55:02 <ertes> halogenandtoast: class AppData dh where data family Key dh a; createUser :: dh -> User -> IO (Key dh User); …
23:27:03 <halogenandtoast> ertes: your knowledge is outside my understanding at the moment, but I'll keep it in mind
23:49:05 <lyxia> wz1000: if a = Void, you will want Right id, but if a is inhabited you will want Left someInhabitant, and this violates parametricity or something.
