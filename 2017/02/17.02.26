00:07:23 <pikajude> I don't think you can define Applicative (Map k)
00:09:02 <EvanR> why the heck not
00:11:51 <c_wraith> What does pure do?
00:24:52 <cocreature> Frankablu: Alternative requires Applicative which requires Functor which requires fmap, but Data.Map.map has an Ord constraint so you can’t use it as fmap and you also won’t be able to write an fmap without an Ord constraint
00:25:55 <cocreature> eh sry, that was directed at fresheyeball 
00:29:51 <EvanR> Map is Functor 
00:30:16 <EvanR> map has no Ord constraint
00:30:34 <EvanR> but yeah pure wont work
00:31:03 <pikajude> you can fmap a Map
00:31:06 <pikajude> it's the keys that need Ord, not the values
00:31:23 <pikajude> but I don't think you can define Applicative (Map k) in a sane way
00:31:32 <EvanR> you cant at all
00:31:34 <cocreature> oh right, I shouldn’t try to answer questions before I’ve finished breakfast
00:31:54 <pikajude> what's Map.empty <*> Map.fromList [(1,'a')]
00:31:58 <EvanR> for pure you need to produce a value of type k out of thin air, which would not work very well with the key type Void
00:32:15 <pikajude> heh
00:32:35 <pikajude> I'm not sure why you'd want Alternative Map anyway
00:33:58 <nshepperd> pure _ = Map.empty :: Map Void a
00:34:20 <pikajude> pure _ = Map.empty :: Map a b
00:34:23 <pikajude> we've solved it!
00:34:49 <nshepperd> you could do (Enum k, Bounded k, Ord k) => Applicative (Map k)
00:34:58 <pikajude> how to define pure
00:35:05 <nshepperd> but it would be horribly slow and fill you with regret
00:35:56 <nshepperd> pure x = Map.fromList [(k, x) | k <- [minBound..maxBound]]
00:42:44 <ongy> do that with Data.Map.Strict for extra fun
00:49:12 <ongy> does that even need to be Strict? The lazy list is strict in it's keys right? Does that one build the structure in an eager way?
00:49:38 <nshepperd> Lazy vs Strict Map only affects the values
00:50:11 <nshepperd> keys are always evaluated
00:50:23 <nshepperd> I think there might be some laziness in the tree itself, not sure
00:58:36 <nshepperd> data AlternativeMap k v = Small (Map k v) | Big v (Map k (Maybe v)) -- something like this would let you do Applicative & Alternative with a little bit hairy instances...
01:00:10 <nshepperd> basically adjoining "constant Maps" and the closure thereof under insertion / deletion
01:09:00 <`Guest00000> рудз
01:09:02 <`Guest00000> help  *
01:09:50 <`Guest00000> i have a line like " let f s{..} = g sField1 + sField2"
01:09:58 <`Guest00000> it's in a do block
01:10:14 <`Guest00000> i have {-# LANGUAGE RecordWildCards #-}
01:10:37 <`Guest00000> GHC says "You cannot use `..' in a record update"
01:10:46 <ongy> `Guest00000: what exactly do you need help here with?
01:11:21 <`Guest00000> i don't understand why it's an update, or why GHC thinks it is, and i need to get this line to compile
01:11:31 <ongy> the syntax is a bit wierd, so s is of a Record Type (I think it should be the constructor there, so it should be S) and then sField1 and sField2 are the values from the constructor
01:11:44 <`Guest00000> ah
01:11:45 <ongy> so this could be 'let f s = g (sField1 s) + (sField2 s)'
01:11:49 <`Guest00000> constructor...
01:11:52 <`Guest00000> thanks
01:12:37 <`Guest00000> it seems to work
01:12:55 <`Guest00000> after i added the constructor instead of s.
01:15:07 <ongy> @src Alternative
01:15:07 <lambdabot> class Applicative f => Alternative f where
01:15:07 <lambdabot>     empty :: f a
01:15:07 <lambdabot>     (<|>) :: f a -> f a -> f a
01:17:46 <ongy> why is Applicative a superclass of this? are there laws attatched I don't see? For a Map it makes sense to me to (non-overwriting) update the first list with all elements from the 2nd
01:18:57 <Cale> Just use <> for that.
01:19:46 <ongy> I just wanted to ask, is <|> the same as <> if it's also Monoid?
01:20:26 <Star_> jesus there is a lot of people on this IRC
01:21:00 <ongy> there are. The haskell commmunity is one of the largest on freenode
01:21:20 <Cale> ongy: Not always, but often -- Alternative is for functors which produce monoids.
01:21:38 <ongy> Do you have an example when it isn't?
01:22:07 <Star_> ah. I'm new to haskell and really terrible at it atm
01:22:15 <Star_> so XD
01:27:24 <Starfflame> In a class that requires you learn it and I'm still at the bang-your-head-against-the-wall stage
01:27:52 <Starfflame> of learning the language
01:28:21 <ongy> I've been there before. It gets better
01:29:25 <Starfflame> honestly it's quite terrible and programming in haskell makes me pretty miserable if I'm being honest w/ ya
01:29:44 <Starfflame> compared to imperative
01:30:15 <Cale> Starfflame: That... changes :)
01:30:15 <ongy> once you embrace the haskell world, imperative languages will make you feel terrible :)
01:30:42 <Starfflame> i sure hope it does lol
01:30:56 <ongy> going from thinking "Ha I'm fluent in C,java,C++ I can learn other langauges in a day" to "what even is this?" is quite the shock
01:31:13 <Cale> Back in 2001 or so when I was first learning Haskell, it took me about 2 months to get to the point where I felt like I could do useful things, and about a year to feel comfortable.
01:31:59 <Starfflame> I've been in a class using it since january, still struggling to make simple functions :p
01:32:15 <Starfflame> and i'm a freshman in college XD
01:32:32 <ongy> depends on your class. I had one that lasted ~4months, and after that I wasn't able to make a complete application without help
01:32:42 <ongy> but when I started my own project it got better pretty quickly
01:33:37 <Starfflame> I probably should not mention specifics of what i am doing
01:33:48 <Cale> But I'm so much more productive in Haskell now than I *could be* with any popular imperative language. It's so nice when you realise that you can make refactors to codebases that involve hundreds of changes across dozens of files and when the compiler stops telling you what to change next, it all works.
01:34:47 <Starfflame> i feel there is a chance my professor could be on here and theres only a handful of people in the class so XD
01:35:30 <ongy> I think there's public logs of this channel, so don't slander to much
01:35:44 <Starfflame> i don't slander
01:37:09 <ongy> debugging in haskell: Run the compiler
01:37:41 <Starfflame> my haskell prof is actually really fucking awesome, it's just haskell i dont like, lol
01:38:24 <tsahyt> is there a vim syntax file that doesn't choke on OverloadedLabels?
01:39:03 <Cale> Where I work, for one of our clients we've been building an application which is aimed at being a competitor to Slack, with a bunch of extra features (email can be sent and received by a chat channel, there are a bunch of organisational and task management features, surveys, and various other stuff) -- it took my coworker and I just three days of pair programming to convert it to a multi-tenant architecture, since we basically changed 
01:39:03 <Cale> the type of our authentication tokens and had the compiler tell us everywhere that we needed to adjust things.
01:39:27 <Cale> Usually you'd expect that kind of a refactor to take weeks -- if you were going to attempt it at all rather than just starting over :)
01:39:53 <Starfflame> hm
01:40:18 <Cale> Haskell's type system has consistently been a huge help
01:40:19 <sbrg> Cale: sweet :)
01:40:44 <Starfflame> Haskell's type system just gives me a middle finger all the time XD
01:40:58 <ongy> imo the type system is *the* reason to use haskell
01:41:06 <sbrg> It starts making sense after a while. Then it's the only thing that makes sense
01:41:15 <Cale> Starfflame: Right, because it knows you don't know what you're doing yet :)
01:41:37 <Cale> Once you *do*, it will catch all your slip ups and mistakes and you'll love it
01:42:02 <ongy> also ghc error messages are somewhat sane. Compared to other type errors you may get
01:42:14 <Starfflame> My biggest problem is converting what I want into a function
01:42:23 <tsahyt> ongy: sane yes, but confusing for someone not used to them
01:42:28 <ongy> from a syntax perspective? or what makes most problems for you?
01:42:40 <Starfflame> just laying it out
01:42:44 <Cale> Yeah, it also takes a while just to think in terms of what you have and what you want to produce
01:43:02 <Starfflame> i'm used to saying do this loop, change this variable etc
01:43:02 <sm> Starfflame, I found this helpful: set up a rapid feedback loop, I recommend ghcid for this. Start with a compiling program, then make very small changes at a time. Literally one character at a time if necessary
01:43:03 <ongy> that certainly. When I started out and got cpp sized errors I didn't get anything either.
01:43:19 <sbrg> Starfflame: yep, adjusting to the new paradigm can be difficult
01:43:24 <sbrg> but at some point it will just 'click' 
01:43:49 <Starfflame> yeah it's pretty hard on me atm
01:44:01 <ongy> Starfflame: when I started out, every loop ever just became an explicit recursive function. That's what worked for me, then later I thought about making it pretty
01:44:19 <Starfflame> i would do that tooo, but
01:44:40 <Starfflame> my prof wants us to use folds a lot so i'm working with that atm
01:44:50 <Cale> Starfflame: One thing that might help starting out is that the only way that variables vary is by being bound again. So if you want variables to change, making them arguments to a function, and having that function be applied to different arguments is the fundamental way to do that.
01:45:33 <Starfflame> I did discover that thankfully
01:45:52 <Cale> (which gets you recursion and is a lot less pretty than actually understanding what you're doing enough to write something as a fold or in terms of other higher order functions, but hey, it's a start)
01:46:00 <sbrg> Starfflame: have you tried writing foldl/foldr on your own?
01:46:03 <sbrg> it helps
01:46:26 <Starfflame> our professor showed us foldl in terms of foldr
01:46:32 <Cale> Getting really good with list operations in general is helpful -- lists are like loops that are frozen in time
01:46:47 <Starfflame> and my brain proceeded to die
01:47:17 <Cale> Just as a loop either has no iterations (e.g. because its precondition isn't met), or consists of a single iteration followed by another loop
01:47:17 <Cale> a list is either empty, or consists of a single element followed by another list
01:48:05 <Starfflame> I get how both folds work but it's just a bit of a pain using them especially when I have to come up with a tuple that stores the right numbers i need to do task Y
01:48:24 <sbrg> Well, it doesn't have to be a tuple. it can be anything.
01:48:48 <Starfflame> could be anything, yeah
01:49:05 <Starfflame> just that a tuple makes sense for the machine problems I'm working with
01:49:36 <piyush-kurur> Starfflame: when folding think of the function that you fold with as an operator. It might help visualise what it is doing
01:49:48 <sbrg> Sure, it's a common pattern for, say, maintaining some state while doing a fold 
01:50:37 <Starfflame> yeah my problem isn't seeing what the function does in a fold
01:50:39 <sbrg> Starfflame: has your lecturer shown you Typed Holes? 
01:50:50 <Starfflame> my problem is making the function
01:50:53 <Starfflame> no sbrg
01:51:01 <sbrg> Typed Holes can help with that. 
01:51:12 <Starfflame> he is using LYH to base our class off
01:51:19 <sbrg> not sure how lambdabot interacts with typed holes
01:51:19 <Starfflame> and we are on chapter 8
01:51:57 <Starfflame> which means that theoretically we're learning typeclasses
01:52:11 <sbrg> > let foo = [1,2,3] :: [Int] in foldl _ 0 foo
01:52:14 <lambdabot>  error:
01:52:14 <lambdabot>      • Found hole: _ :: b -> Int -> b
01:52:15 <lambdabot>        Where: ‘b’ is a rigid type variable bound by
01:52:28 <sbrg> > let foo = [1,2,3] :: [Int] in foldl _ (0 :: Int) foo
01:52:31 <lambdabot>  error:
01:52:31 <lambdabot>      • Found hole: _ :: Int -> Int -> Int
01:52:31 <lambdabot>      • In the first argument of ‘foldl’, namely ‘_’
01:52:42 <Starfflame> > Maybe (5+2)
01:52:44 <lambdabot>  error:
01:52:44 <lambdabot>      • Data constructor not in scope: Maybe :: Integer -> t
01:52:44 <lambdabot>      • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
01:52:53 <Starfflame> why does that not work?
01:53:10 <sbrg> Maybe is a type constructor
01:53:28 <sternmull> Just and Nothing are its data constructors.
01:53:30 <sbrg> If you want to construct a value of type (Maybe a) (where 'a' can be anything) you want Maybe's value constructors
01:53:31 <sbrg> ^
01:53:42 <sbrg> > Just (5 + 2)
01:53:45 <lambdabot>  Just 7
01:53:57 <sbrg> > Just (5 + 2) :: Maybe Int
01:54:00 <lambdabot>  Just 7
01:54:01 <Starfflame> i see
01:54:04 <sbrg> > Nothing :: Maybe Int
01:54:07 <lambdabot>  Nothing
01:54:51 <sbrg> > let foo = [1,2,3] :: [Int] in foldl _ (0 :: Int) foo -- Starfflame
01:54:54 <lambdabot>  error:
01:54:54 <lambdabot>      • Found hole: _ :: Int -> Int -> Int
01:54:54 <lambdabot>      • In the first argument of ‘foldl’, namely ‘_’
01:55:12 <Starfflame> the amount of people in my class that look confused at haskell is pretty astounding
01:55:30 <sbrg> I have a list 'foo' of integers and want to accumulate over this list and return an integer. Using typed holes(the underscore in place of the accumulator function argument) makes the compiler tell me the type of the function I have to write
01:55:58 <ongy> Starfflame: did you have a cours with an imperative language before? I think it's pretty common that haskell confuses people that are used to imperative programming
01:56:12 <Starfflame> yea ongy
01:56:23 <ongy> if you think back to the time you first learned that (or any OOP) you will see, that it's not that different
01:56:52 <Starfflame> my intro to OOP was very gentle
01:57:01 <ongy> I remember the way my classmates (back in high school) looked at arrays. Where I asked the teacher why I can't name my variables var1 to var5 and just access them with 'var + i' as a name
01:57:04 <Starfflame> I had two years to slowly get into OOP
01:57:36 <Starfflame> my intro to haskell is like climbing a cliff in comparison
01:57:43 <Starfflame> er functional*
01:58:15 <Starfflame> I took some high school class that used visual basic (yeah i know) then i took APCS
01:58:29 <sbrg> Starfflame: I understand your frustration, and believe me, I have been there. 
01:58:37 <sbrg> I was in this channel many years ago saying the same things
01:59:28 <Starfflame> My concern is that i think this class is wanting to be made a required course
01:59:38 <Starfflame> and i think that would be bad
01:59:43 <sbrg> so believe me: It clicks. I can't guarantee that it will do so before your course is over, but it will at some point, regardless. It's just a different way to program. It's like learning another (spoken) language which is completely different from your native tongue. englishman learning chinese, or what have you
02:00:01 <sbrg> Starfflame: how so?
02:00:09 * sm looks Very Concerned
02:00:39 <Cale> It might be that they're throwing you off the deep end with the course, but don't worry all that much. If you give yourself the same amount of time, it should be fine.
02:00:52 <Starfflame> because learning haskell in a classroom environment is incredibly stressful
02:01:12 <sm> why not learn some here, then class will be much more fun
02:01:21 <sbrg> ^
02:01:37 <sbrg> don't you wanna be the very best? 
02:01:40 <sbrg> like no one ever was?
02:01:56 <Starfflame> like I have a set of machine problems that are due later today/tomorrow and I have no idea how I'm going to do them for example
02:02:15 <athan> Starfflame: what are they like? State machines?
02:02:21 <Starfflame> it would probably crap on a lot of people's GPAs is all I'm saying
02:02:22 <Cale> Well, it really depends on what the course demands -- a course in any subject can be stressful if it covers a lot of ground in a hurry or has difficult exercises :)
02:02:26 <sm> take the first one, identify the stumbling block, ask for help
02:03:04 <athan> McState McHines [tm]
02:03:40 <Starfflame> I barely know about state machines athan
02:03:43 <sbrg> Starfflame: I honestly think you're overestimating. I taught ~50 students haskell last semester, and did the same the 2 years before that. People find it difficult and mind-boggling in the beginning, but anything can be understood given enough time :)
02:04:04 <athan> Starfflame: I've never been to college, haskell isn't that hard
02:04:05 <Cale> Yeah, it might be more productive to actually ask about the particular things you're stuck on.
02:04:29 <Cale> athan: But then again, maybe it would have been harder if you took a course :)
02:04:35 <Starfflame> i'm a freshie, freshies dont know shit, lol
02:04:42 <sbrg> Starfflame: like sm said, you can ask for help. we won't solve your exercises for you, don't worry :)
02:04:58 <athan> Starfflame: straight outta high school?
02:05:05 <Cale> Starfflame: Instilling that in you is probably one of the purposes of the course too ;)
02:05:05 <athan> If so then I understand :\
02:05:06 <sbrg> compton?
02:05:18 <Starfflame> yup
02:05:27 <athan> straight outta sunnyvale
02:05:48 <Starfflame> i knew high school was a joke
02:06:06 <athan> high school is a communist agenda to rob people of their free thought :x
02:06:11 <Cale> There will typically be a bunch of students who come in thinking they already know how to program, and it can be good to level everyone out by starting off with something completely foreign :)
02:06:14 * athan ducks
02:07:12 <ongy> we did Java in the first semester and Haskell (I think the other prof that does the cours from time to time uses OCaml) in the 3rd. And I think it was really good
02:07:39 <Starfflame> right now I'm learning like... 5 languages?
02:07:41 <Starfflame> ish?
02:07:59 <Starfflame> haskell is obviously the hardest one
02:08:17 <sbrg> Starfflame: you play overwatch?
02:08:19 <Cale> Yeah, that's a bit much all at the same time
02:08:28 <athan> it's only difficult because it's clean lol
02:08:34 <sbrg> just a random shot in the dark
02:08:35 <athan> (well, Clean++)
02:08:45 <sbrg> (Zenyatta became who he is because he learned Haskell)
02:08:53 <sbrg> When you get it, it's the only thing that makes sense
02:08:55 <Starfflame> No, sbrg
02:08:56 <Cale> lol, what?
02:09:00 <ongy> learning 5 languages? I think  that's a mistake. I could barely deal with 2 natural languages without mixing things up.
02:09:01 * sbrg tones down the zealotry
02:09:10 <Starfflame> idk if it's 5
02:09:52 <Starfflame> 4 if you include SQL
02:09:59 <Starfflame> 3 programming languages
02:10:02 <ongy> I'm comfortable with 2 (or 4 depending on which level required) programming languages. And I can use 2 or 3 more without major troubles. That's what I did over years
02:11:04 <Starfflame> C, Python are both pretty easy
02:11:16 <athan> Starfflame: It's the price you pay for owning the responsability over others' software :)
02:11:44 <Starfflame> so is SQL honestly i dont know why i took a college course on it
02:12:18 <Starfflame> SQL is something you could probably pick up in a weekend or something
02:12:20 <sbrg> sql may be easy for simple things, but utilizing the full power of SQL is a different story, IMO. 
02:12:26 <athan> I think you can make it turing complete with stored procedures or something, but it's basically a "seive description language" or something
02:12:32 <ongy> SQL feels more like a dsl than general purpose so simple things are really simple
02:13:13 <sbrg> there are subtle things like doing things in the optimal order. in some cases that can affect the execution time of the query by orders of magnitude
02:13:23 * sbrg never got very good at sql
02:13:28 <Starfflame> yeah
02:14:01 <Starfflame> as a college freshman it seems almost impossible to find someone willing to take a freshman as an intern
02:14:12 <Starfflame> i dont really blame companies tbh but it really sucks
02:16:29 <athan> Does GHC automatically turn linear data types into newtypes?
02:16:42 <Cale> athan: no
02:16:46 <athan> like `data Foo = Foo ...` => `newtype Foo = Foo ...`
02:16:48 <Starfflame> Also, in terms of asking questions about haskell: I would if I knew what to ask
02:16:48 <Cale> (and it can't, the semantics are different)
02:16:54 <athan> :( why not, I feel like that would be simple
02:17:03 <athan> if you count the sum and product types to be == 1
02:17:15 <Cale> @let data D = D Integer
02:17:17 <lambdabot>  Defined.
02:17:34 <Cale> @let newtype N = N Integer
02:17:36 <lambdabot>  Defined.
02:17:43 <Cale> > case undefined of N x -> 5
02:17:46 <lambdabot>  5
02:17:49 <Cale> > case undefined of D x -> 5
02:17:52 <lambdabot>  *Exception: Prelude.undefined
02:17:59 <Cale> ^^ different
02:18:03 <athan> oh my goodness
02:18:07 <athan> thank you Cale 
02:18:11 <Starfflame> > foldr (:) [] [1,4..30]
02:18:14 <lambdabot>  [1,4,7,10,13,16,19,22,25,28]
02:18:35 <athan> so data constructors induce immediate surrounding strictness?
02:18:37 <sbrg> > foldr (:) [] [1,4..30] :: Expr
02:18:40 <bollu> Cale: newtype is strict because it desugars to the same code right?
02:18:41 <lambdabot>  error:
02:18:41 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘[Integer]’
02:18:41 <lambdabot>      • In the expression: foldr (:) [] [1, 4 .. 30] :: Expr
02:18:52 <athan> that's the only way I could conceive that `undefined` eval :s
02:19:12 <Cale> athan: Pattern matching against data constructors of types defined using 'data' involves evaluating the scrutinee
02:19:24 <Cale> athan: With newtypes, the scrutinee doesn't need to be evaluated, because the newtype's data constructor has no runtime representation.
02:19:41 <athan> holy flip, that is awesome
02:19:43 <athan> thank you Cale
02:20:01 <bollu> Cale: newtype has no Core overhead right?
02:20:08 <bollu> Cale: like, it generates the same code in Core?
02:20:53 <Cale> newtypes are still around in core iirc.
02:20:57 <Aku> bollu?
02:21:00 <Cale> They get boiled away after that point
02:21:03 <Aku> up there?
02:21:05 <Cale> (Core is still typed)
02:21:07 <athan> can lambdabot spit out Core or STG?
02:21:12 <Cale> nope
02:21:15 <Cale> It would be too spammy
02:21:26 <athan> hmm...
02:21:28 <bollu> Aku: yes
02:21:30 <Starfflame> One of the big things about haskell that is discouraging me i guess is that I'm kinda forced into spending hours at a time hacking away at functions so I can turn a machine problem in on time
02:21:36 <bollu> Cale: oh, interesting
02:21:48 <bollu> Cale: I always assumed that core was "minimal subset" hence would not have newtype
02:21:52 <bollu> Cale: I shall go spelunk :)
02:21:55 <athan> Starfflame: that shouldn't be your goal :)
02:22:11 <bollu> Aku: I'm a little busy right now though. if you have a targetted question I can answer
02:22:12 <athan> bollu: Don't forget to bring sun screen!
02:22:14 <Aku> I am trying to figure out the type of a Parser pDefn
02:22:26 <Starfflame> even though my professor understands the struggle i need to get my work for haskell done otherwise it'll overlap with everything else i need to do
02:22:29 <bollu> Aku: lpaste?
02:22:39 <Aku> Are u free?
02:22:42 <bollu> athan: :)
02:22:49 <Aku> Looks like it would take some time
02:22:56 <bollu> Aku: I could probably just run you through it, not a detailed explanation
02:22:58 <bollu> even so, post the code
02:23:04 <bollu> and there's everyone on IRC who would help
02:23:20 <Starfflame> athan shouldn't be my goal but unfortunately it is
02:23:24 <Cale> Starfflame: btw, the fact that foldr (:) [] is the identity function is a clue to a really good way to think about what foldr is doing
02:23:37 <bollu> context for the others: he's implementing a parser in the style of "failure to list of successes", so he's going through parser combinators the first time :)
02:23:45 <Aku> okay
02:23:53 <Cale> foldr f z xs will replace each occurrence of (:) in the construction of the list xs with f, and the [] at the end (if any) with z
02:23:53 <Aku> i will put it on lpaste
02:24:31 <Cale> http://cale.hn.org/share/Folds.svg -- here are some diagrams, foldr is the one in the top left :)
02:24:35 <Starfflame> that's a good way of looking at it
02:24:36 <athan> Starfflame: haskell is like math done right, structurally and with proper symbols
02:24:50 * athan spews propoganda
02:25:06 <Cale> athan: Not sure I agree
02:25:06 <Cale> Maybe if "like" is weak enough there
02:25:26 <Cale> Haskell isn't suitable for actually proving theorems, because as a logic, it's inconsistent.
02:25:48 <bollu> Cale: HoTT question: I'm reading about Eckmann–Hilton in the HoTT book, and I'm finding the proof a little hard to follow
02:25:57 <bollu> Cale: is there an algebraic topology equivalent?
02:26:02 <Cale> bollu: yes
02:26:28 <bollu> Cale: could you point me to a reference?
02:26:34 <athan> Cale: >:D
02:26:39 <Cale> The Eckmann-Hilton argument is a classic thing from homotopy theory. The Catsters also have a video or two up that might help.
02:26:44 <bollu> Cale: also, like, isn't it so weird that it turns out to be abelian?
02:26:50 * athan this is secretly a smear campaign against mathematicians
02:27:08 <bollu> Cale: I can't visualise it
02:27:14 <bollu> Cale: (like, why it is abelian)
02:27:18 <Cale> https://www.youtube.com/watch?v=Rjdo-RWQVIY
02:27:27 <bollu> Cale: thank you :D
02:27:41 <Cale> bollu: It's because you get enough room to rotate things around :)
02:28:13 <bollu> Cale: well, I've only seen pi_1 in action (after which I moved to homology), but from what I understand, pi_2 uses "spheres" rather than "loops" in space right?
02:28:24 <bollu> upto homotopy and all that?
02:28:25 <Starfflame> Just constructing functions instead of declaring what the program does directly is a bit of a shock
02:28:25 <Cale> yeah
02:28:40 <bollu> Cale: hm, so you can "see it in your head" ? :)
02:28:43 <Starfflame> I almost feel like I'm dancing around with haskell?
02:28:50 <Starfflame> if that makes sense
02:29:12 <bollu> Cale: wait what, the category theory proof is crazy general
02:29:19 <bollu> Cale: I was hoping for a more geometric viewpoint
02:29:24 <Cale> Starfflame: It should feel like you're getting more to the point -- you're talking about the relationships between the things you care about (values)
02:29:41 <Cale> bollu: Yeah, the geometric viewpoint is not very different from the category theory viewpoint
02:29:50 <bollu> Cale: hm, OK
02:29:59 <Starfflame> I can see that too Cale
02:30:19 <Cale> bollu: They have "horizontal" and "vertical" composition there, and those just become more literally horizontal and vertical
02:30:20 <Starfflame> I just find referencing memory values directly a bit more intuitive
02:30:34 <Starfflame> not directly but you know what i mean
02:31:07 <bollu> Cale: so, like, for pi_1, we pick a base point, and we first define the set of all loops (which are continuous functions of the form f : [0, 1] -> T such that f(0) = f(1)). Then we quotient this by ~ where f ~ g iff f is homotopic to g. This is how we construct pi_1 right? (then the group operator becomes loop composition) 
02:31:15 <bollu> Cale: similarly, how is pi_2 constructed?
02:31:41 <Starfflame> Also how are you supposed to analyze algorithmic complexity in haskell?
02:32:24 <Cale> Starfflame: Well, much the same way as you'd do it anywhere else, for the most part. But lazy evaluation makes things a bit more tricky to think about.
02:32:43 <Starfflame> in python for example if i have a for loop going from 1 to N it's super easy to say that will take O(N)
02:33:10 <lpaste_> Aku revised “No title”: “figuring out type?” at http://lpaste.net/7251168297717071872
02:33:32 <Aku> bollu I have put it!
02:33:38 <Aku> if time plz help!
02:34:03 <Cale> Starfflame: Well, usually your loop from 1 to n is going to be replaced by some sort of processing of a list [1..n]
02:34:17 <Aku> I have written in comments what the problem is!
02:34:18 <Starfflame> hm
02:34:22 <Starfflame> i see
02:34:37 <Starfflame> i miss my for loops XD
02:34:53 <bollu> Cale: ohh, so pi_n will have f: S^n -> T?
02:35:07 <Cale> bollu: Yeah
02:35:13 <bollu> Starfflame: you find that the haskell way of doing it is "nicer" since it carries intent better
02:35:32 <lpaste_> Aku revised “figuring out type?”: “figuring out type?” at http://lpaste.net/7251168297717071872
02:35:37 <bollu> Starfflame: when you see for (..) {..}, you don't really know what the general "shape" of the processing is
02:36:04 <bollu> Starfflame: but in haskell, that is conveyed by the higher order function you use: map v/s filter v/s fold v/s for v/s traverse ...
02:36:28 <bollu> Aku: what is pDefn supposed to do?
02:36:46 <bollu> Aku: oh okay, just (Var, Expr)
02:36:52 <Aku> It is supposed to parser Defns
02:36:54 <Aku> Ya
02:37:05 <Starfflame> hm
02:37:10 <Starfflame> well
02:37:24 <Starfflame> i'll worry about it then if i get that far
02:37:42 <bollu> Aku: you can use then3, since you have 3 things to "parse" as blocks: the "variable", the "=", and then the actual "expr", which you can then combine
02:37:53 <Cale> bollu: Well, for this it might help to take a different approach to discussing the sphere than usual. You might want to consider maps [0,1] x [0,1] -> T which send the entire outside square to the basepoint.
02:38:13 <bollu> Aku: and it is perfectly OK for expressions to use Alt and for Alt to use expression
02:38:26 <bollu> Aku: I don't think you've actually seen a formal methods class?
02:38:48 <bollu> Cale: how is that the same as S^2? 
02:38:49 <Aku> The type they return are confusing
02:38:58 <Aku> No I haven't
02:39:04 <bollu> Aku: also, pExpr should be "Parser CoreExpr"
02:39:08 <Aku> ya
02:39:16 <Cale> bollu: think about what happens when you take a disc and identify all the points on its boundary
02:39:25 <Aku> I corrected it 
02:39:30 <Aku> In the revised version
02:39:41 <Cale> bollu: (the square being a perfectly good disc for this purpose ;)
02:40:05 <Aku> I am loop
02:40:07 <Cale> bollu: You get a sphere, right?
02:40:11 <bollu> yes
02:40:12 <bollu> you do
02:40:17 <Aku> I feel unless I define pDefn
02:40:23 <Aku> I cannot define pExpr
02:40:26 <Aku> and vice cersa
02:40:30 <Aku> *versa
02:40:31 <bollu> Aku: untrue
02:40:45 <bollu> Aku: think of it as defining two functions in terms of each other
02:40:55 <bollu> Aku:  for example, I can define odd and even in terms of each other
02:41:02 <Aku> Ya
02:41:03 <Cale> bollu: Just like how for the pi_1 case, we took [0,1] and insisted that the boundary go to the base point, and that was the same as talking about maps from S^1
02:41:10 <bollu> Cale: ahh
02:41:16 <bollu> Cale: oh, I get what you're saying
02:41:47 <bollu> Cale: so, f: [0, 1] x [0, 1] -> T such that f((0, y)) = f((1, y)) = f((x, 0) = f((x, 1))
02:42:01 <bollu> 0 <= y <= 1, 0 <= x <= 1
02:42:02 <bollu> right?
02:42:08 <bollu> Aku: so this is the same
02:42:18 <bollu> Aku: you're just defining two parsers in terms of each other
02:42:27 <bollu> Aku: remember that the parser is "just" a function at the end of the day
02:42:40 <Cale> bollu: yeah -- well, have to be careful about quantification there, but yes.
02:42:46 <bollu> yeah
02:42:52 <Aku> what should be the type of pDefn?
02:42:57 <bollu> Parser Defn
02:43:01 <Cale> bollu: the entire boundary of the square is going to the same point
02:43:03 <bollu> or Parser (String, Expr a)
02:43:09 <bollu> Cale: yes, understood
02:43:15 <bollu> Cale: which is a sphere yeah
02:43:30 <bollu> Cale: uh, intuitively yes, mathematically? :3
02:44:03 <bollu> Cale: mathematically, how do I show that the square with boundary identified is homeomorphic to the sphere?
02:44:32 <Aku> okay..I will try..
02:44:44 <bollu> Aku: also, I don't think you need to write the parser for case right now
02:44:51 <bollu> Aku: since it is not used in the second chapte
02:44:52 <bollu> chapteR*
02:45:08 <Cale> bollu: So if we have two such maps f,g: [0,1] x [0,1] -> T, we can glue them together in at least two obvious ways. "Horizontally": (f * g)(s,t) = { f(2s,t) when 0 <= s <= 1/2, and g(2s-1,t) when 1/2 <= s <= 1
02:45:09 <Aku> Ohh..is it
02:45:10 <Aku> ?
02:45:27 <Aku> I haven't gone through chapter two yet
02:45:33 <bollu> Aku: yeah
02:45:36 <Cale> and "Vertically": (f # g)(s,t) = { f(s,2t) when 0 <= t <= 1/2, and g(s,2t-1) when 1/2 <= t <= 1
02:45:42 <Cale> bollu: right?
02:45:48 <bollu> Cale: yes
02:46:51 <Cale> bollu: So, now those (up to homotopy equivalence) become the horizontal and vertical composition from the abstract version of the Eckmann Hilton argument you might've seen
02:47:05 <bollu> Cale: ahh
02:47:07 <bollu> Cale: interesting
02:47:47 <Cale> and basically, the commutativity will amount to the fact that you can ultimately just rotate your sphere
02:48:06 <bollu> to realign things I'm guessing?
02:48:58 <Cale> Well, it's not quite the same as just rotating, because that would result in the two halves being "backward"
02:49:04 <bollu> OK
02:49:06 <Cale> But basically
02:50:28 <bollu> Cale: also, like, the HoTT induction principle of loops is just.. weird. I understand that "if it works on the diagonal of x = y, since you can't access anything other than the diagonal, we can pretend that it can be extended. But it's such a weird argument?
02:50:35 <Cale> (you can also see that you can flip each map around first without changing things by rotating each by a half turn, and then when you rotate the pasted together map you obtain the pasted together version of their rotated versions)
02:51:03 <Cale> I'm not sure which thing you're referring to there
02:51:16 <bollu> Cale: path induction
02:51:35 <Cale> circle induction?
02:51:55 <Cale> Or the induction for the identity type/
02:52:31 <bollu> Cale: identity type
02:52:38 <bollu> Cale: oh, I haven't seen circle induction yet
02:55:31 <bollu> Cale: if you are still around
02:56:32 <bollu> Cale: could you explain a little about "type families are fibrations"? I understand the statement. If given p : x =A y and a type family T: A -> U, then we get the relationship that there is a function f : T(x) -> T(y)
02:56:46 <bollu> Cale: however, how is this a fibration?
02:57:19 <Cale> The total space of the fibration is Sigma (x:A), T x
02:57:28 <Cale> the base space is A
02:57:42 <Cale> and the fibration map is the first projection
02:58:17 <bollu> hm, I do not know fibrations from topology very well
02:58:19 <Cale> Pi (x:A), T x is the space of sections
02:58:22 <bollu> I suppose I'll have to go and study that first
02:58:47 <Cale> ah, I assumed you did, because of the way you asked the question :)
02:58:55 <bollu> Cale:  no :)
02:59:21 <bollu> Cale: eh, I know very little algebraic topology (I've seen some homotopy and some simplicial homology), will that be enough?
02:59:25 <bollu> or do I just "move on"?
02:59:38 <Cale> Should be
02:59:47 <bollu> Cale: OK, cool
02:59:56 <bollu> Cale: thanks!
03:01:27 <Cale> If you've never come across the homotopy lifting property before, and you want to understand that in detail, that'll take a little bit of work, but it doesn't have much in the way of dependencies.
03:01:45 <bollu> Cale: I see, OK
03:01:51 <bollu> Cale: is it in any way related to path lifting?
03:01:56 <bollu> Cale: over the universal cover?
03:03:33 <Aku> bollu : Can you just take a look!
03:03:34 <Cale> Yeah, the universal cover is a special example of a fibration.
03:03:37 <Aku> I have written
03:03:39 <Aku> it
03:03:59 <bollu> Aku: yep, I told you the types that it should have
03:04:04 <bollu> Aku: what else is confusing :)
03:04:07 <Aku> but I had to write pDefn :: Parser(String,Expr Name)
03:04:17 <Aku> instead of Parser(String,Expr a)'
03:04:27 <Aku> I will paste it!
03:04:45 <lpaste_> Aku revised “figuring out type?”: “figuring out type?” at http://lpaste.net/7251168297717071872
03:05:22 <bollu> Aku: also note that Expr a == CoreExpr
03:05:30 <Aku> Nopes
03:05:37 <Aku> CoreExpr == Expr Name
03:05:40 <Aku> Name::String
03:06:22 <bollu> Aku: oh yes, I meant Expr Name* sorry :)
03:06:25 <bollu> yeah so
03:06:26 <bollu> first of all
03:06:42 <Aku> yes?
03:06:50 <bollu> yeah, you know what pDefn has to be right
03:06:57 <bollu> you know what information you want to keep from the definition syntax
03:07:04 <bollu> the "=" is pointless
03:07:14 <Aku> Ya right
03:07:18 <bollu> you just care about the LHS name and the RHS expression
03:07:20 <bollu> so I would suggest
03:07:23 <bollu> perhaps make a data type
03:07:25 <Aku> That's how I defined foo3
03:07:39 <bollu> data Defn = Defn { name :: String, value :: CoreExpr} or something
03:07:45 <Aku> I ignore "="
03:07:45 <bollu> that then have pDefn :: Parser Defn
03:07:48 <bollu> yeah
03:07:53 <bollu> because you don't need it
03:08:03 <bollu> and then figure out how to write pDefn
03:08:06 <bollu> so try that
03:08:10 <bollu> and ping me when you get stuck
03:08:11 <Aku> Okay
03:08:16 <Aku> Yep
03:10:18 <Cale> bollu: btw, don't forget to watch https://www.youtube.com/watch?v=Rjdo-RWQVIY
03:11:02 <bollu> Cale: oh yes, thanks
03:11:58 <Cale> (this is all much better with a diagram or two)
03:12:59 <bollu> xD yeah
03:14:31 <Aku> bollu: Its working fine
03:14:37 <Aku> Just one thing
03:14:55 <bollu> Aku: yes?
03:15:05 <Aku> After it parses, it reaches "in" and then parses (pExpr)
03:15:18 <Aku> but it retains whatever is parsed
03:15:22 <Aku> as unparsed tokens
03:15:54 <Aku> Where is it going wrong?
03:16:12 <Aku> I think my pExpr is incomplete!
03:16:18 <bollu> Aku: what do you mean?
03:16:27 <bollu> Aku: remember that it returns the list of all _possible_ parses
03:16:46 <Aku> Ya right
03:17:02 <Aku> Suppose I write let x = 3 in y
03:17:04 <bollu> yes
03:17:13 <Aku> It gives me y as unparsed token
03:17:18 <Aku> That's it
03:17:41 <Aku> As the first parse
03:18:32 <`Guest00000> why isn't Data.Binary.Get lazy
03:19:11 <bollu> Aku: hm
03:19:14 <bollu> Aku: that is strange
03:19:36 <Aku> but y is as well there in parsed token
03:23:29 <Aku> [(ELet False [("x",ENum 3)] (EVar "x"),["x","hello","james","!",";","hello","goodbye","joe","!",";","Hey","!"])]
03:24:01 <Aku> this is the result for let x = 3 in x .....followed by some random stuff
03:24:37 <Aku> bollu ^
03:24:53 <athan> Aku: I needed state in my parser :x
03:24:53 <bollu> yeah I just tried it
03:24:56 <bollu> OK that's weird
03:25:00 <athan> just for app/abs I mean
03:25:10 <bollu> so, it's parsing the string but t's still in the list of unparsed tokens
03:25:20 <athan> abs can be done recursively, while app needed some kind of continuation into the "last parsed expression"
03:25:50 <Aku> It's not clear yet
03:26:21 <bollu> Aku: your defintion of then4 was wrong :)
03:26:32 <bollu> Aku: read the definition and tell me if you figure it out
03:26:33 <Aku> ohh is it?
03:27:16 <bollu> Aku: yes
03:27:19 <Aku> My bad..
03:27:22 <Aku> srry!
03:27:27 <Aku> Got it...
03:27:33 <bollu> Aku: also, notice that you can define then4 using then3
03:27:35 <bollu> and then3 using then2
03:27:45 <Aku> Ohh...yeah
03:27:50 <Aku> Correct
03:27:55 <Aku> Didn't notice
03:28:00 <bollu> Aku: can you generalise this to "thenN" ?
03:28:25 <Aku> for that we have pOneOrMore
03:28:26 <bollu> Aku: (don't seriously consider it, but think about it)
03:28:31 <bollu> no
03:28:35 <bollu> pOneOrMore is the _same_ parser
03:28:43 <bollu> thenN will take "n" parsers and call them one by one
03:28:44 <Aku> Ya but the parsers are different
03:28:50 <Aku> yeah
03:29:00 <Aku> Okay..I will ponder on it
03:30:54 <Aku> bollu: Is pretty printing must or can I keep it for last?
03:31:07 <bollu> Aku: no you don't need it
03:31:17 <Aku> So that I can move on Chapter 2 asap
03:31:20 <bollu> yes
03:31:27 <Aku> okkhay
03:31:30 <Aku> Thanks
03:31:37 <bollu> Aku: I would also encourage you do understand monads, applicative and functor sometime along the way
03:31:50 <bollu> then you can cleanup your code by noticing that "Parser" actually obeys "Monad" ;)
03:32:01 <Aku> Ya I want to......surely I would as soon as time permits!
03:36:15 <Aku> Ohh..it's monadic, is it, I will study it quite soon
03:50:07 <insitu> is it possible to configure intero to work with several packages?
04:19:19 <Aku> bollu: Just tell me whether I can pass pOneOrMore to pThen4?
04:19:59 <Aku> http://lpaste.net/7251168297717071872
04:21:25 <ikang007> hi，who can tell me how to execute haskell or perl code on my blackberry phone，i only know that can execute python and shell by BGshell 
04:22:08 <Aku> bollu: up There?
04:22:14 <Aku> busy...?
04:33:28 <Cale> ikang007: Does it run Android, or is it older? If it runs Blackberry OS, you're probably out of luck unless you're willing to do a lot of thankless work to port GHC to target a dead platform. If it runs Android, then there's more hope -- some people have managed to get things working
04:33:32 <Cale> https://github.com/wavewave/nix-build-ghc-android
04:51:18 <ongy> is there a standard data structure that's a bidirectional map? so both keys and values are unique and I can search in both directions (I could also set up 2 maps, but I would like one)
04:52:24 <hacker007> Cale:：
04:53:14 <hacker007> Cale：The first use of IRC, thank you for answering my question, I just want to learn and perform Haskell code on the BlackBerry, thank you for the GitHub link
04:53:32 <LordBrain> ongy, there's a package on hackage called bimap
04:53:54 <LordBrain> see if it meets your needs
04:55:14 <LordBrain> https://hackage.haskell.org/package/bimap-0.3.2/docs/Data-Bimap.html
04:55:50 <ongy> looks reasonable
05:07:58 <srhb> What's the PVP upper bound way to bump a dep (that works.) Increment B in A.B by one more than the current version?
05:09:13 <srhb> Ie if my package works with foo: 2.2, should the upper bound be foo: 2.3?
05:13:58 <lyxia> yeah
05:16:44 <srhb> lyxia: Thank you. :)
06:04:43 <kgadek> hi. is there any good alternative to pandoc? I'd be happy with RST/Markdown --> HTML for now
06:05:52 <pavonia> What do you find unsatisfactory about pandoc?
06:18:47 <kadoban> kgadek: If it's just those two, you could just use individual converters, which is a bit easier. HTML is their usual output anyway, AFAIK.
06:47:20 <gakusei> hey
06:47:39 <gakusei> just starting out with haskell, trying to implement fibbonacci 
06:47:51 <gakusei> can anyone point out what's wrong with this code:
06:48:25 <gakusei> fibb :: (Num n) => n -> n
06:48:25 <gakusei> fibb n = fibb1 n n
06:48:25 <gakusei>        where
06:48:25 <gakusei>          fibb1 :: (Num x) => x -> x -> x
06:48:25 <gakusei>          fibb1 x 0 = x 
06:48:27 <gakusei>          fibb1 x _ = fibb1 ((fibb1 (x - 1)) + (fibb1 (x - 2))) (x - 1)
06:50:43 <lavalike> gakusei: you're passing only 1 argument to the recursive fibb1 calls inside the parentheses
07:10:11 <Rub_ixCube> Hello. I Recently install haskell on my R-Pi3 and I don't seem to have ghci. How would I Be able to install it?
07:12:29 <prohobo> NEVER
07:12:59 <hodapp> Rub_ixCube: what distro on the Pi 3?
07:13:19 <hodapp> some distros insisted on older versions of things, and GHCi years ago had some issues on ARM, IIRC
07:14:17 <Rub_ixCube> Rasbian Jesse
07:14:21 <Rub_ixCube> *Jessie
07:15:19 <dunx> jessie is weird
07:15:30 <dunx> it segfaults on Lynx browser
07:15:43 <Rub_ixCube> dunx: ?
07:16:04 <dunx> don't rely on rasbian to have all the packages working is what i'm saying
07:16:11 <jberges> @help
07:16:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:16:20 <dunx> you might be worth compiling from source
07:16:46 <Rub_ixCube> yay, I like waitng 10 years for things to compile :P
07:17:56 <dunx> faster sd card would help :D
07:18:21 <dunx> the stopgap with compilation is generally cpu
07:18:44 <dunx> those pi3s are reasonably speedy, so it shouldn;t take more than 1 hr or something
07:19:36 <Rub_ixCube> ok
07:19:40 <Rub_ixCube> ill do it later
07:19:44 <Rub_ixCube> thanks :)
07:20:42 <dunx> chow
07:49:21 <athan> dunx: I've had to wait... days, for something to compile on a pi3 v_v
07:49:32 <athan> I haven't tried the experimental 64bit OS though
07:49:33 <dunx> :0
07:49:41 <dunx> i don't own one, so...
07:49:59 <athan> they're pretty cool, but probably better suited for something like rust
07:50:16 <athan> idk I'd like to cross compile distributions from my x86_64, I just don't know how
08:06:13 <mettekou> How common is the Data Types à la Carte coproducts of functors approach in real-life Haskell codebases?
08:16:17 <kgadek> pavonia: (re my queston about pandoc) I like pandoc but GPL prevents me from usint it
08:17:33 <Tuplanolla> Do they offer the option to pay for double licensing, kgadek?
08:18:29 <kgadek> no, at least I'm not aware of it
08:18:42 <Tuplanolla> Too bad.
08:18:46 <kgadek> yeah
08:19:21 <variable> kgadek ++ wish there was a freely licensed version of pandoc
08:19:24 <variable> :/
08:21:19 <kgadek> the worst thing is that licensing is hard, and therefore few people (if any) understand those well
08:21:29 <kgadek> certainly, I'm not the one of them
08:22:20 <kgadek> but I do know, that e.g. if your library got any contribution, then to change license you have to ask that contributor to get permission
08:23:03 <kgadek> that's why bigger projects have CLAs
08:23:08 <kgadek> ehh
08:23:08 <kgadek> </mini-rant>
08:28:47 <Ageoffire> Iiii
08:32:19 <EvanR> Ageoffire: no cats allowed
08:32:33 <Ageoffire> :)
08:33:11 <Ageoffire> What work not in ? International?
08:33:45 <Ageoffire> Factory?
08:34:30 <sm> pavonia: for markdown rendering, yes there are one or two good alternatives on hackage
08:35:19 <Ageoffire> Hackage?
08:35:46 <sm> sorry, I meant kgadek:
08:36:16 <Ageoffire> I used progmmer sub7
08:36:33 <Ageoffire> :)
08:42:06 <kgadek> sm: by any chance you remember their names?
08:42:24 <heartbreakers> ??
08:42:38 <heartbreakers> Dinasour??
08:43:19 <glguy> did you have a Haskell question, heartbreakers ?
08:43:38 <heartbreakers> Ok!
08:46:19 <Tuplanolla> Is it a better idea to use `type` or `newtype` for monad stacks? Is this discussed somewhere?
08:47:17 <monochrom> It is discussed all the time here. Go with newtype in the long run.
08:47:22 <glguy> I prefer newtype
08:47:39 <Welkin> type is only useful for simple types that you want to alias for easier reading
08:47:41 <EvanR> when you are implementing some API with a transformer stack, it clearly needs to be a newtype
08:47:50 <Welkin> like `type Deck = [Card]`
08:47:52 <sm> kgadek: markdown, sundown, commonmark maybe
08:47:52 <Tuplanolla> Okay. How do they interact with mtl style?
08:48:14 <kgadek> sm: thanks!
08:48:16 <glguy> you can use the mtl classes to help you implement your actual operations
08:48:27 <sm> cmark, not commonmark. A search for markdown will tell you
08:48:41 <bollu> newtype IOEnv env a = IOEnv (env -> IO a)
08:48:46 <bollu> type TcRnIf a b = IOEnv (Env a b)
08:48:50 <Tuplanolla> Very well.
08:48:50 <bollu> how does that typecheck?
08:48:55 <bollu> doesn't IOEnv need two parameters?
08:49:02 <monochrom> "type" is more convenient for the author. "newtype" is a bit more work for the author. However, "type"'s convenience for the author tends to become leaky abstraction. You won't want leaky abstraction for serious code.
08:49:20 <jberges> @pl \ps -> (map (\(a:b:c:[]) -> a + b + c) [ drop (i - 3) $ take i ps | i<-[3..length ps]])
08:49:20 <lambdabot> (line 1, column 22):
08:49:20 <lambdabot> unexpected "["
08:49:20 <lambdabot> expecting "()", natural, identifier, "_" or "("
08:49:31 <maerwald> newtype is also (useless) work for API users sometimes
08:49:52 <heartbreakers> :)
08:51:00 <EvanR> the api users arent supposed to know how you implemented it
08:51:03 <bollu> newtype IOEnv env a = IOEnv (env -> IO a); type TcRnIf a b = IOEnv (Env a b); how is the TcRnlf declaration correct? doesn't IOEnv need two types "a" and "b"?
08:52:22 <monochrom> Yes, but they are sometimes called "env" and "a".
08:53:00 <monochrom> Ah so this means "TcRIf X Y" still has kind * -> *
08:53:15 <heartbreakers> A for administration
08:53:55 <bollu> monochrom: yeah, looks like it's curried. I didn't know you could curry newtypes :)
08:54:49 <Welkin> everything is curried
08:55:25 <EvanR> type synonyms have to be fully applied
08:56:23 <EvanR> which is what stops type synonyms from being a turing complete language at the type level
09:13:18 <Rub_ixCube> for some reason I cannot install haskell from source
09:15:51 <monochrom> Don't install from source. It's chicken and egg.
09:16:05 <monochrom> Do settle with binaries.
09:26:01 <Rub_ixCube> monochrom: I use raspbian and I want to have ghci :)
09:26:07 <Rub_ixCube> so I have to
09:27:23 <Welkin> reminds me too much of lesbian
09:28:09 <Rub_ixCube> Welkin: wut?
09:28:17 <maerwald> ...
09:28:28 <Welkin> the name raspbian
09:28:41 <maerwald> Welkin: you confused this channel with -offtopic? :P
09:28:52 <EvanR> or -blah
09:29:05 <Welkin> no one goes in -blah anymore
09:29:11 <Welkin> that place died long ago
09:29:37 <Rub_ixCube> Welkin: you have a problem with the LGBTQ+?
09:29:38 <glguy> Rub_ixCube: No, there are binaries for the raspberry pi
09:29:53 <Rub_ixCube> glguy: where are they
09:29:56 <Welkin> Rub_ixCube: nope
09:30:08 <Welkin> what is the plus?
09:30:16 <glguy> It's offtopic
09:30:46 <glguy> Rub_ixCube: http://downloads.haskell.org/~ghc/8.0.2/
09:30:57 <Rub_ixCube> thz
09:31:00 <Rub_ixCube> *thx
09:31:31 <glguy> Rub_ixCube: You'll need this https://www.reddit.com/r/haskell/comments/5j0u36/getting_haskell_and_stack_on_a_rapsberry_pi_3/dbcfg3d/
09:32:25 <Rub_ixCube> thx again :)
09:32:35 <Krissman> any sexy girls here, that would like to chat with a lovely 33 years old estonian male? my webpage: web.zone.ee/kristjanrobam
09:32:44 <Welkin> lol haha
09:33:03 <Welkin> the spammers are out today
09:33:51 <lassulus> I'm confused by the target group of this spam approach
09:34:21 <sternmull> i want to update a bunch of fields conditionally. For each field i have a predicate and a value that should be applied when the predicate is True. What is a nice way to do that?
09:34:46 <Welkin> sternmull: you could put that all inside of a function
09:34:51 <Welkin> or perhaps there is something in lens for that
09:36:40 <sternmull> Welkin: Of course i do that inside of a function... but i am not sure how. Nested ifs and old value as default is the best i can imagine... but i am sure there is a better way.
09:37:05 <Welkin> no ifs
09:37:18 <Welkin> define each no value in a let or where clause
09:37:45 <Welkin> then have th function return those new values (which could have been set to the old values) as the return value of the function using record update syntax
09:37:51 <Welkin> each new value*
10:17:21 <Starfflame> heyo
10:27:05 <flxw> Hello all. I've got a list of interesting things, interspersed with uninteresting stuff. And two predicates for testing where an "interesting" interval starts and ends.
10:27:05 <flxw> Let's say the list type is [Int], and even and odd are the predicates. I use span and explicit recursion to get from e.g. [1,2,4,3,6] to [[2,4], [6]].
10:27:06 <flxw> My question: Right now the list is small, so I don't mind going over it two or three times with diffeerent pairs of predicates (to find intervals accordingto different criteria).
10:27:06 <flxw> But how could an approach look like where I'd need only a single run over the list, whilst testing for various interval bounds in parallel? I could imagine brute forcing it using State, but would there be a more functional approach, too? ;)
10:29:44 <lyxia> flxw: http://hackage.haskell.org/package/foldl might be of interest
10:32:05 <benzrf> flxw: ooh, that's an interesting problem :)
10:32:10 <pavonia> There also is a function to partition a list according to a specified predicate, but I can't recall the name
10:33:10 <pavonia> @hoogle Ord b => (a -> b) -> [a] -> [[a]]
10:33:13 <lambdabot> GHC.Exts groupWith :: Ord b => (a -> b) -> [a] -> [[a]]
10:33:13 <lambdabot> Data.List.Extra groupSortOn :: Ord b => (a -> b) -> [a] -> [[a]]
10:33:13 <lambdabot> Extra groupSortOn :: Ord b => (a -> b) -> [a] -> [[a]]
10:34:11 <benzrf> flxw: actually, im not sure you'd save much time that way
10:35:13 <benzrf> flxw: my first thought would be that the complexity of going thru the list once, doing each predicate per item, is "listLength * numPreds" - and doing each predicate, going thru the list for each, is "numPreds * listLength"
10:35:16 <benzrf> am i wrong?
10:35:40 <flxw> lyxia: This looks interesting. Thank you. It'll take me a bit to understand how to use it, but I can see already that it will be a great investment generally.
10:36:39 <flxw> wait, I'll try to paste my current code.
10:38:36 <Rub_ixCube> umm, I followed the instructions but the installation isn't global...
10:38:40 <Tuplanolla> If I want a single error handler for two threads, does using an extra waiting thread just for that seem wasteful?
10:39:32 <flxw> benzrf: http://lpaste.net/5434339802285604864
10:40:27 <flxw> it's not compilable that way but I hope the type names are suggestive.  
10:41:30 <benzrf> flxw: jsyk PascalCase is conventional for types, not Upper_snake_case :)
10:41:33 <benzrf> ok, reading
10:42:22 <benzrf> flxw: yeah, that looks about right!
10:43:11 <flxw> yes, I hope you'll bear with me for the odd naming convention. For technical reasons I've got a really hard time reading camel cse. 
10:43:20 <benzrf> oh, ok
10:43:22 <flxw> *case
10:43:31 <Rub_ixCube> how do I make stack install GHC globally?
10:44:39 <flxw> Rub_ixCube: Could you not install ghc globally by hand and then set stack to use the gobal ghc?
10:44:59 <Rub_ixCube> sorry?
10:45:21 <Rub_ixCube> oh
10:45:24 <Rub_ixCube> :P
10:45:38 <flxw> it is system-ghc: true
10:46:15 <flxw> this is how I make stack use ghc's HEAD sometimes.
10:48:11 <Welkin> why would you want to do that though?
10:48:14 <Welkin> there is no point
10:48:48 <Welkin> if you want to use ghci, just create a new stack project, install any of the libraries you want, and use stack ghci
10:50:27 <flxw> sorry, typo. What I meant was to use a stable ghc branch, and cherry picking a few commits I wanted to test.
10:52:28 <flxw> I mentioned it just to underline that stack can be used with globally installed ghc just fine.
10:59:26 <flxw> lyxia: Doesn't look so difficult after all. Now I regret not having implemented the recursion using fold right from the start ...
11:02:25 <sternmull> i have a data type where all fields are instances of Data.Default. Is there a way to automatically make the data type an instance of Default so i can initialize it with "def"?
11:02:59 <lyxia> sternmull: yes, derive Generic and leave the instance empty
11:03:12 <EvanR> Default :(
11:04:10 <lyxia> sternmull: it's not automatic to the extent that you still need to write the word "instance"
11:04:52 <lyxia> Some day the compiler will just read our minds and generate the code we want.
11:05:07 <sternmull> lyxia: that sounds good... what is the syntax for that? "deriving Generic" at the end of data and then an empty instance?
11:05:53 <hexagoxel> lyxia: nah it will read our mind and tell you that it contains type errors.
11:06:03 <lyxia> sternmull: yeah. don't forget the extension DeriveGeneric and an import GHC.Generics
11:07:00 <quchen> ∀ P. ¬ (¬LEM(P)) ⇒ LEM(P)   <--- Correct?
11:07:17 <quchen> In other words, for propositions that satisfy doubly negated LEM, they satisfy LEM as well?
11:07:44 <hpc> if that existed, you would be able to convert between classical and constructive logic at will
11:10:01 <hpc> in constructive logic, the classical type (which is a monad, fun fact) is represented by double-negation
11:10:36 <hpc> basically something is classically true if there does not exist a constructive contradiction
11:11:00 <hpc> LEM is true in classical logic
11:11:15 <hpc> and the proposition encoded in that type is "if LEM is true in classical logic, LEM is true in constructive logic"
11:11:27 <lyxia> it's not
11:11:52 <sternmull> lyxia: It seems to work for Default. If i also want to automatically derive Monoid i have to use this https://hackage.haskell.org/package/generic-deriving-1.11.1/docs/Generics-Deriving-Monoid.html right?
11:11:54 <lyxia> I mean, the quantification on P makes it different from what you said
11:12:12 <lyxia> doesn't it?
11:12:19 <quchen> I thought it would, at least
11:12:34 <hpc> not really
11:12:52 <quchen> But you’re right, not-not-LEM holds for any P on its own even in constructive mathematics, so the theorem is wrong
11:12:53 <hpc> forall p. LEM(p) is the same as what's usually called just LEM
11:13:33 <hpc> it would be interesting to see what sort of additional constraints on P are able to satisfy that type though
11:14:00 <hpc> but since LEM -> ¬¬LEM, it actually probably wouldn't be /that/ interesting
11:15:44 <lyxia> sternmull: you can but make sure that's the instance you want
11:15:57 <quchen> I thought there was a proof equivalent to (¬¬¬P ⇒ ¬P) for the LEM as well
11:16:28 <hpc> i think that does exist
11:16:35 <quchen> ∀ P. LEM(¬¬P) maybe?
11:17:51 <sternmull> lyxia: Thank you, i got it working for Default and Monoid and got rid of a bunch of repetitive lines of code. What do you mean by "the instance you want"? Is there a chance i got the wrong turn?
11:18:00 <hpc> that one i don't think is true
11:18:34 <hpc> even though you're using ¬¬P, you still have to have in all cases a constructive proof of either the term or the negation of the term
11:18:44 <johnw> forall P : Prop, not (not (not P)) -> not P is trivially true
11:18:53 <johnw> "intuition" solves it
11:19:22 <johnw> what's the form of the LEM proof?
11:20:06 <hpc> data LEM P = True P | False ¬P
11:20:09 <hpc> more or less
11:20:24 <johnw> ahh
11:22:06 <johnw> yes, LEM (¬¬P) is a no go
11:24:20 <stevenxl> Hi folks. Quick question, when I write something such as data Pair a b = Pair a b, is it proper to use the term keyword to describe data?
11:24:36 <johnw> yes, it is a syntactic keyword
11:24:51 <Starfflame> You can have different datatypes in a tuple right?
11:24:55 <johnw> yes
11:25:05 <hpc> :t (False, "bacon")
11:25:07 <lambdabot> (Bool, [Char])
11:25:14 <lyxia> stevenxl: I mean that there is generally more than one monoid for a given type
11:25:19 <lyxia> sternmull: 
11:25:38 <kadoban> hpc: False bacon sounds like a pretty bad trick :-/
11:26:00 <stevenxl> johnw: thank you. I'm trying to learn the terminology the right way, since it seems to make it easier for me to learn concepts later on. 
11:26:40 <stevenxl> Is there a list of the grammar in Haskell. Here are the keywords, etc. 
11:26:59 <Starfflame> > Just snd ("pi",5)
11:27:02 <lambdabot>  error:
11:27:03 <lambdabot>      • Couldn't match expected type ‘([Char], Integer) -> t’
11:27:03 <lambdabot>                    with actual type ‘Maybe ((a0, b0) -> b0)’
11:27:10 <Starfflame> god damnit
11:27:16 <sternmull> lyxia: ah, ok. All my fields are Monoids themselves and they behave just as i expected... so it looks like i got the right one :)
11:27:32 <Starfflame> > Just (snd ("pi",5))
11:27:36 <lambdabot>  Just 5
11:27:45 <Welkin> > Just $ snd ("pi", 5)
11:27:48 <lambdabot>  Just 5
11:27:49 <monochrom> stevenxl: http://www.hck.sk/users/peter/HaskellEx.htm may help
11:28:00 <Welkin> > Just . snd ("pi", 5)
11:28:02 <lambdabot>  error:
11:28:02 <lambdabot>      • No instance for (Typeable a0)
11:28:02 <lambdabot>          arising from a use of ‘show_M417355563296030796118659’
11:28:05 <Welkin> > Just . snd $ ("pi", 5)
11:28:08 <Welkin> :D
11:28:08 <lambdabot>  Just 5
11:28:15 <lyxia> sternmull: Okay. I guess the product monoid is the most sensible one to implement generically.
11:28:42 <stevenxl> monochrom: thanks i'll take a look at that
11:29:17 <Starfflame> > (True == True) && True
11:29:20 <lambdabot>  True
11:32:12 <quchen> Eh, sorry, got kicked earlier after johnw’s comments
11:32:38 <quchen> And now I’m boarding my plane, so we can’t continue either. Has anything been said to me in the meantime?
11:33:01 <Starfflame> why do haskell programmers never use any verbosity when declaring variables?
11:33:02 <monochrom> No.
11:33:10 <Starfflame> it's always xs or as or bs
11:33:24 <monochrom> You haven't seen enough. "Never" is false.
11:34:04 <Starfflame> > !True
11:34:08 <lambdabot>  <hint>:1:6: error:
11:34:08 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
11:34:12 <Starfflame> :V
11:34:25 <monochrom> > not True
11:34:26 <Starfflame> > ! True
11:34:27 <lambdabot>  False
11:34:28 <lambdabot>  <hint>:1:7: error:
11:34:29 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
11:34:37 <monochrom> See? We use more verbose names than "!"
11:35:47 <epsilonhalbe> Starfflame: http://degoes.net/articles/insufficiently-polymorphic
11:36:28 <epsilonhalbe> this is a post where j a degoes - makes some valid points about short naming
11:37:06 <Starfflame> > let x = 2
11:37:09 <lambdabot>  <no location info>: error: not an expression: ‘let x = 2’
11:37:18 <Starfflame> > x = 2
11:37:21 <lambdabot>  <hint>:1:3: error:
11:37:21 <lambdabot>      parse error on input ‘=’
11:37:21 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
11:37:59 <Starfflame> > let x = 2 in (x > 0 && not False)
11:38:04 <lambdabot>  True
11:40:37 <plantedseed> Has any big apps been written in Haskell yet? I learned Haskell in 2009, loved it but has since programmed in other languages. I am disappointed if nothing has happened.
11:41:24 <epsilonhalbe> what do you mean by "big apps" - like webapps or mobile phone apps?
11:41:24 <plantedseed> Cale: I see you meant to post something to me some week ago?
11:41:38 <plantedseed> epsilonhalbe: anything really. just a successful app.
11:41:43 <plantedseed> app/program
11:41:50 <monochrom> How big is big?
11:41:54 <Starfflame> damnit
11:41:59 <Starfflame> i wish you could nest guards
11:42:21 <kadoban> Starfflame: You can use "where" to factor out the common elements at least
11:42:39 <kadoban> | a && other stuff     | a && other stuff    etc.
11:43:30 <epsilonhalbe> plantedseed: the tickting of the austrian railway system was partly done in haskell, a bunch of banks use haskell internally - I am part of a startup writing a baby monitor in haskell (gonimo.com)
11:43:39 <kadoban> I guess if you really wanted to you could do a case just to be able to nest guards on that.
11:43:45 <srhb> plantedseed: The question itself makes me be wary of your criteria. Facebook is pretty big, and they use/developed Haxl for this purpose...
11:43:59 <srhb> their*
11:44:03 <epsilonhalbe> ah facebook of course - i forgot
11:44:41 <epsilonhalbe> and what you consider big - haskell code often turns out to be way less then expected!
11:44:47 <stevenxl> Hi folks. Are data constructors fist-class citizens? As far as I can tell, they seem to behave exactly like regular functions. 
11:44:51 <maerwald> epsilonhalbe: haskell in railway systems? ugh, that sounds dangerous
11:45:05 <Rembane> stevenxl: Yes!
11:45:19 <maerwald> usually, they are super strict and verify compilers, generated code and whatnot
11:45:42 <maerwald> which is "easy" in C, not so much in GHC
11:45:44 <epsilonhalbe> maerwald: the ticketing calculations
11:45:48 <kadoban> Ticketing systems don't usually kill people much.
11:45:52 <stevenxl> Rembane: cool! But now my next question is, how is that consistent with the fact that only types should start with capital letters?
11:46:00 <maerwald> epsilonhalbe: ah
11:46:16 <Rembane> stevenxl: Types and constructors should start with capital letters.
11:46:25 <epsilonhalbe> kadoban: except the prices sometimes do ;-)
11:46:30 <kadoban> Heh, indeed
11:46:42 <stevenxl> Rembane: ah - thank you. I thought it was only types, but that's obviously not the case. OK great. 
11:47:07 <srhb> stevenxl: Classes and modules too.
11:47:14 <srhb> stevenxl: Probably others I've forgotten.
11:47:30 <stevenxl> srhb: OK. Then I need to revisit the rules, because I'm obviously very wrong here. heheh
11:47:33 <stevenxl> thank you both
11:48:33 <Rembane> stevenxl: No worries, good luck!
11:48:57 <stevenxl> Rembane: thank you. this is my 2nd (or 1.5?) time trying to learn Haskell. ;-)
11:49:16 <Rembane> stevenxl: Good stuff! :D
11:49:20 <monochrom> Ticketing can kill people if the ticket machine shoots out a tough sharp ticket at high speed at people :)
11:50:09 <epsilonhalbe> monochrom: that sounds like the next transformers movie
11:50:16 <epsilonhalbe> (or ghostbusters)
11:55:45 <Starfflame> mfw I get my function to compile but it produces a bad output :V
11:55:57 <epsilonhalbe> does anybody know - can I somehow get case insensitive routes in servant, i had a look at GHC.TypeLits - which has no CaseInsensitive symbols, and I didn't find anything useful in servant-server 
11:58:56 <schell> hi all o/
11:59:45 <kubunto> jw is there a datatype in haskell that has the ability to be either[T1, T2]
12:00:07 <schell> i’m encountering a <<loop>> exception when running a compiled program, but not when i run the same with ghci
12:00:20 <schell> anyone ever run into this?
12:00:24 <hpc> compile it with -threaded
12:01:04 <schell> hmm, it should be
12:01:16 <bennofs1> schell: <<loop>> exceptions are not guarranteed, they might happen or not so you cannot rely on them
12:01:33 <epsilonhalbe> kubunto: my first guess would be something buffering related (maybe)
12:02:09 <schell> hpc: i’m compiling with -threaded in my cabal file, though i’m using stack, maybe it’s not respecting it?
12:02:10 <kubunto> epsilonhalbe: is there logical disjunction in haskell
12:02:22 <schell> bennofs1: bummer! this has been really hard to debug
12:02:37 <nshepperd_> kubunto: Either
12:02:52 <hpc> basically what happens is when a thunk is being evaluated, it gets mutated to a black hole
12:03:01 <hpc> which is a thunk that points to code that prints <<loop>> and exits
12:03:15 <hpc> then when it's done the thunk is written back
12:03:17 <bennofs1> schell: there's definitely some non-terminating programs that don't causew <<loop>>. If the program does terminate or make progress in GHCi, then that's a different story
12:03:29 <epsilonhalbe> my comment was => schell - sorry confused
12:03:29 <hpc> if a thunk's evaluation loops back into itself, it hits that code
12:03:41 <hpc> in the threaded runtime, the black hole is instead a grey hole
12:03:41 <kubunto> nshepperd_: how do you make one
12:03:55 <hpc> the code it is rewritten to is a wait for the previous evaluation to finish
12:04:16 <nshepperd_> kubunto: data Either a b = Left a | Right b
12:04:57 <hpc> so yeah, something is somehow not respecting that it should be built with the threaded rts
12:05:14 <kubunto> nshepperd_: what do i do after that
12:05:48 <nshepperd_> kubunto: this type is already in prelude. The constructors are Left and Right
12:05:57 <schell> hpc: well - i am using async, but oddly enough, that’s not the code that causes the loop
12:06:02 <nshepperd_> :t Left "a string"
12:06:05 <lambdabot> Either [Char] b
12:08:20 <schell> to make matters a bit more complicated i have a fairly intricate main loop that includes Eff (freer) using multiple coroutines
12:08:27 <kubunto> i am probably not the first to say this but the similarities between haskell and scala are imense
12:11:16 <Welkin> scala is java in shabby ML clothing
12:11:19 <schell> hpc, epsilonhalbe, bennofs1: https://github.com/schell/odin/blob/engine-loop/app/MapMaker.hs#L180 is the line i’ve tracked it down to, though that doesn’t make sense to me since the computation `slotColorPicture` is used in other spots successfully, and `tilesetOutlinePic` simple runs `return ()`
12:11:46 <Welkin> kubunto: look beyond the syntactic similarities, and they are nothing alike at all
12:12:12 <Starfflame> I have a love-hate relationship with haskell
12:12:22 <Starfflame> I hate it when I can't figure out how to make a function but once I do I love it
12:12:26 <Welkin> Starfflame: you just started using it o.o
12:12:31 <Welkin> it takes time
12:12:38 <Welkin> a couple months at least
12:12:43 <kubunto> Welkin: the thinking behind writing it is not that different to me
12:12:49 <schell> my next thought is that it has something to do with the way `freer`’s effect handlers are unwrapping the main computation and that it somehow can’t find a handler
12:13:09 <schell> but i’m going to try a big clean and force recomp to make sure it’s not the -threaded issue
12:14:33 <Starfflame> i feel kind of bad for writing this function this way though
12:14:38 <Starfflame> it looks really imperative
12:16:11 <kubunto> Welkin: i also recognize that the languages have different aims, scala isnt trying to be as monadic as haskell is
12:17:02 <schell> bennofs1: btw, my program runs as expected with ghci, as well as with halive, which is a bit like ghci + live recompiling
12:19:12 <stevenxl> hmmm..... it's just dawning on me how similar types in Haskell are to Structs in Elixir. (With the huge, huge caveat that Elixir doesn't enforce consistency through static typing). They are both boxes (structured data) and we can pattern match on their label - i.e., the data construct in Haskell or the struct's name in Elixir. 
12:20:24 <stevenxl> err, by type i meant data constructor. 
12:20:57 <Welkin> you are simply describing the fact that it has a type system
12:21:09 <Welkin> C structs are similar in that way to haskell data types
12:21:14 <stevenxl> Yea. 
12:21:35 <stevenxl> That is right. (Well, not familiar with C, but the previous comment yes.
12:22:40 <mettekou> Is there any evidence of a backdoor in the RDRAND instruction? I'm asking to see if I should disable the flag which enables it when building cryptonite.
12:23:09 <kubunto> Welkin: is it the type system that allows haskell to be so functional?
12:24:08 <mettekou> kubunto: Not really, you could do everything within IO and the type system would let you get away with it.
12:26:24 <Welkin> there is no real definition of "functional"
12:26:34 <schell> yeah, it’s a pretty loose term
12:27:00 <mettekou> Welkin schell: Sure there is, referential transparency.
12:27:02 <kubunto> Welkin: then the ability to have functions so easily manipulated
12:27:16 <Welkin> what haskell does give you is: referential transparanency, and immutable data by default, (and lazy evaluation by default)
12:27:26 <Welkin> transparency*
12:27:37 <mauke> lambda calculus has no type system
12:27:57 <Welkin> and everything is automatically curried
12:28:23 <mettekou> mauke: Depends on which lambda calculus you consider. It was originally untyped, but now it's equipped with a type system most of the time.
12:30:23 <schell> i’m not arguing with that, but “functional” is loose enough that we require extra qualifiers to distinguish different kinds of “functional” - “purely functional”, “statically typed, functional” 
12:31:07 <schell> lisp, javascript, and smalltalk even, can be “functional” if you relegate yourself to certain patterns
12:31:18 <MarcelineVQ> 'functions are guranteed citizenship'
12:31:26 <schell> they’re not referentially transparent, though
12:32:20 <nshepperd> haskell also has syntax and a type system that lets you do things functionally without breaking down in tears :)
12:32:26 <schell> they’re ^ meaning those other langs
12:32:44 <mauke> did someone say template metaprogramming?
12:32:57 <schell> yes - you can force a shoe on your head but that does’nt make it a great hat
12:33:19 <schell> good entertainment though, that’s for sure
12:33:40 * nshepperd . o O (vermin supreme)
12:37:03 <Welkin> schell: but germans already use handshoes!
12:40:52 <ongy> that's cause German words make sense. gloves are clearly 'type Glove = Shoe Hand'
12:44:18 <Starfflame> lol
12:44:33 <Starfflame> i love the german language
12:44:43 <AWizzArd> Why?
12:45:01 <Starfflame> because it's relatively pure
12:45:07 <Starfflame> and uses compound words which I like
12:45:17 <AWizzArd> Isn’t english roughly 50% a germanic language itself?
12:45:29 <mounty> Starfflame:  if you want a pure language from that group:  Icelandic.
12:45:52 <Starfflame> English is a clusterfuck
12:46:06 <mounty> ... if by pure you mean unchanged over time.
12:46:12 <hpc> 90% of english if germanic and the other 90% is everything else
12:46:15 <Starfflame> It's so damn hard to learn that not even its native speakers can use it properly
12:46:21 <mounty> Wie heisst 'clusterfuck' auf Deutsche?
12:47:32 <mounty> Starfflame:  the problem with its native speakers is that English, unlike German, is not taught formally in schools.
12:47:52 <Starfflame> It's not?
12:48:05 <Starfflame> The fuck did I do for 6 years in elementary school english classes then?
12:49:21 <hpc> you learned spelling
12:49:51 <ongy> mounty: I'd probably say that it's "zusammengewürfelt" but that's an adjective, not noun (also are natural language on topic for #haskell?)
12:49:55 <Koterpillar> in English-speaking countries schools, presumably?
12:50:10 <monochrom> Wait, why are you arguing this in #haskell?
12:50:40 <Starfflame> cuz someone compared german to haskell
12:50:46 <JoshTriplett> A normal Monad has (>>=) :: m a -> (a -> m b) -> m b . What's the name of the thing with the combining operation of type SomeTypeFunction t1 t2 t3 => m t1 a -> (a -> m t2 b) -> m t3 b where SomeTypeFunction can combine the types arbitrarily?
12:50:58 <JoshTriplett> Effectively, a Monad where the type can change after each operation.
12:51:33 <Koterpillar> Types already change, m a is different from m b
12:51:58 <JoshTriplett> Koterpillar: True, but a and b are the types of the value contained by the monad.
12:52:15 <JoshTriplett> Koterpillar: I'm looking for something where the type can change in another way from step to step.
12:52:28 <monochrom> Does such a thing exist?
12:52:29 <Koterpillar> I get what you mean, but I'm not sure what instances would you write for this. Perhaps you have one in mind?
12:52:47 <JoshTriplett> monochrom: I remember seeing it a long time ago, I just can't remember what it's called.
12:55:10 <JoshTriplett> Koterpillar: Something tracking type-level metadata about what functions have been called.  For instance, say you have functions f1 through f9, and you want f1 :: a -> Functions [1] b , f2 :: a -> Functions [2] b , and so on.  The type of an operation that calls both f2 and f7 would be Functions [2,7] x .
12:56:23 <JoshTriplett> (Using a type-level list.)
12:56:26 <Koterpillar> Ah, I see. I can only recall constrained monads, but that's a different thing.
12:58:40 <monochrom> maybe "indexed monad" is or is not relevant
12:59:37 <Koterpillar> ibind :: (a -> m j k b) -> m i j a -> m i k b
13:12:51 <JoshTriplett> monochrom, Koterpillar: indexed monads do indeed look like what I was thinking of, thanks!
13:19:45 <dolio> There are two sorts of indexed monads, too.
13:24:25 <Starfflame> http://puu.sh/ulaLT/1e4947696e.PNG
13:24:41 <Starfflame> compiler felt like giving me an extra big middle finger today
13:30:46 <EvanR> extra big _|_
13:32:11 <mauke> Starfflame: " " is for strings, ' ' is for chars
13:32:27 <Starfflame> ah, piss
13:32:31 <Starfflame> that probably makes a difference
13:33:01 <mauke> that code looks confused
13:33:23 <mauke> (base, x) can't have the same type as base
13:34:07 <mauke> and x can't be Char, String, Int simultaneously
13:34:42 <Starfflame> that is not what i intended
13:35:12 <EvanR> you can put something like (base, x :: Int) to try and tell ghc what you intended
13:35:30 <EvanR> it might help the error message more directly explain how youre wrong
13:35:42 <monochrom> That still doesn't explain base vs (base, x)
13:36:09 <EvanR> you can put base :: (WhatIIntendedHere, Int)
13:36:49 <Starfflame> yeah i forgot to call fst on base in (base, x)
13:36:51 <EvanR> thinking of it like this, you might not even need the compiler to realize how little sense youre making
13:37:10 <EvanR> which help when you go back to work and youre writing not haskell
13:37:46 <monochrom> Oh, (fst base, x)?
13:38:25 <Starfflame> yeah
13:38:29 <Starfflame> fst base is supposed to hold a number
13:39:08 <Koterpillar> perhaps define ad-hoc types for all those instead of fst fst snd snd?
13:39:24 <monochrom> heh
13:39:26 <mauke> use pattern matching
13:39:40 <mauke> processEval (foo, bar) x
13:39:40 <Koterpillar> actually, can you define a type [synonym] inside a function?
13:39:46 <monochrom> To me the hardest part of defining my own types is coming up with good names.
13:39:51 <dolio> Koterpillar: No.
13:39:59 <Starfflame> i don't really know how to define types yet
13:40:12 <monochrom> I think pattern matching is a good idea.
13:40:32 <monochrom> And even when you define your own types, you will still want to stick to pattern matching when you use them.
13:41:00 <Starfflame> damn that pattern match actually is a good idea mauke
13:41:09 <Starfflame> i wouldn't have thought to use that here
13:41:11 <monochrom> mauke++
13:42:09 <dolio> Do note that pattern matching will be slightly different than the fst/snd stuff you were using.
13:42:13 <dolio> But it probably won't matter.
13:43:06 <dolio> In this case, that is.
13:43:20 <Starfflame> http://pastebin.com/RJkjS2cP
13:43:24 <Starfflame> can anyone translate this for me?
13:43:48 <Starfflame> i tried interpreting what it's telling me and i have no idea what it's complaining about
13:43:49 <monochrom> It is an Int and it is a Char.
13:44:07 <Starfflame> yeah, i see that, but what is it pointing to?
13:44:17 <Starfflame> i see a big function
13:44:20 <monochrom> In the expression: fst (foldl processEval (0, ' ') xs)
13:44:31 <monochrom> That whole expression needs to be both Int and Char.
13:44:34 <mauke> Starfflame: total + x
13:44:49 <mauke> that's the source of the problems
13:45:05 <Starfflame> oh shit
13:45:07 <Starfflame> thanks
13:45:39 <Starfflame> the function assumes that in the list if there's not a + or a - it's a number
13:46:08 <Koterpillar> Starfflame: give all your bindings type declarations, this helps localize errors
14:08:36 <buttons840> I have a function that takes a "proxy entity"; what is this?
14:09:06 <Koterpillar> buttons840: it's a value that doesn't carry any information at runtime, but helps the type checker pick the correct type.
14:09:40 <buttons840> Koterpillar: satisfy that argument?
14:09:55 <buttons840> Koterpillar: how do I satisfy that argument?
14:10:12 <Koterpillar> buttons840: (Proxy :: Proxy YourType)
14:10:45 <Koterpillar> https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Proxy.html
14:12:08 <glguy> buttons840: if it takes a "proxy entity" you can use a [Entity], Maybe Entity, Proxy Entity, etc
14:13:56 <buttons840> the function is `mkName` from the github [api] package, the type is `mkName :: proxy entity -> Text -> Name entity`
14:14:17 <Koterpillar> lowercase proxy?
14:14:24 <c_wraith> Koterpillar: yes, that's the standard
14:14:50 <Koterpillar> where can I read about this (presumably) special syntax?
14:14:57 <c_wraith> It's not special syntax
14:14:58 <Tuplanolla> It's just a variable, Koterpillar.
14:15:01 <c_wraith> It's just a type variable
14:15:02 <buttons840> so to call it I would do something like `mkName (Proxy Name) someText` so that mkName knows it needs to return a Name?
14:15:15 <c_wraith> buttons840: Proxy doesn't take an argument
14:15:29 <c_wraith> buttons840: and it already knows it needs to return a Name
14:15:41 <Koterpillar> where is that type variable defined?
14:15:47 <c_wraith> Koterpillar: right there.
14:15:57 <mauke> Koterpillar: length :: [a] -> Int; where is 'a' defined?
14:15:57 <S11001001> buttons840: check Koterpillar's example again
14:16:36 <Koterpillar> ooooooh
14:16:47 <Koterpillar> I see.
14:17:06 <buttons840> S11001001: mkName (Proxy :: Proxy Name) myText  ?
14:17:22 <mauke> that makes no sense
14:17:24 <S11001001> buttons840: you got it
14:17:31 <c_wraith> buttons840: Why do you keep putting Name there?
14:17:34 <mauke> Name :: * -> * according to you
14:17:34 <Koterpillar> buttons840: what's the kind of Name?
14:17:50 <Koterpillar> buttons840: what entity do you want a name for?
14:17:51 <c_wraith> buttons840: you need to put the entity type there.  the entity type isn't Name
14:18:07 <S11001001> buttons840: er, like c_wraith says
14:18:16 <buttons840> from the source: newtype Name entity = N Text
14:18:40 <Koterpillar> buttons840: why do you want to use this function?
14:18:50 <c_wraith> buttons840: yes, so you can have entity be any type you like.  Pick the type you need.
14:19:19 <buttons840> I am trying to call the `contentsFor` function from the github [api] package, and I need to convert a Text into a Name, which is what `contentsFor` requires
14:19:43 <c_wraith> buttons840: Name isn't a complete type by itself.  what does contentsFor do with the entity variable?
14:19:50 <S11001001> buttons840: contentsFor requires a Name ... what?
14:20:06 <dmwit_> buttons840: :t contentsFor -- ?
14:20:07 <tempeh> anyone know how to change the stack path for intero? can't get it to work on nixos
14:21:06 <buttons840> https://hackage.haskell.org/package/github-0.15.0/docs/GitHub-Endpoints-Repos.html#v:contentsFor -- ah, I see now, Name is a `* -> *` like you said, so I need to use my proxy to specify whether I want a Name Owner or a Name Repo, etc
14:21:14 <bennofs> tempeh: doesn't it just use whatever is in PATH
14:21:22 <c_wraith> buttons840: there you go.  That's the full chain of reasoning. :)
14:22:28 <tempeh> bennofs: doesn't seem like it, stack is in my path but it's looking in ~/.local/bin/stack
14:23:05 <tempeh> bennofs: it's actually in /run/current-system/sw/bin/stack
14:23:33 <bennofs> tempeh: have you tried symlinking that to ~/.local/bin ? :)
14:24:06 <tempeh> bennofs: but i just showered :(
14:34:20 <tempeh> PSA: spacemacs + intero + stack + nix is a dream
14:41:19 <schell> tempeh: i’m interested - care to write up a quick blog or something explaining how you have everything set up?
14:47:48 <tempeh> schell: oh man - i might try at some point, but it'll be a while before i'm sure i know what's going on
14:47:59 <schell> :)
14:50:13 <ertes> schell: meanwhile you can get haskell-interactive-mode working, and once you have that, you can integrate 'rapid' for an especially smooth development experience =)
14:50:35 <schell> ertes: i’ve been meaning to check out rapid
14:50:41 <schell> i’m still on luke’s halive
14:53:31 <ertes> schell: it's actually pretty easy to integrate…  you can do your first steps without any integration at all to get a feeling for how it works and whether it will benefit you
14:53:53 <ertes> and if it does, it's a matter of combining "reload and run this particular IO action" in a single hotkey
14:54:14 <ertes> haskell-mode has a predefined function for that particular process, so it's a matter of binding a key
14:59:06 <wayne> hi
14:59:52 <wayne> working through exercise 6 here: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
15:00:21 <wayne> i'm a little stuck, at: concat (map unit f) = concat (map f unit) = f
15:00:25 <wayne> any hints?
15:02:29 <dolio> I think one of those has to be ill typed.
15:05:11 <wayne> dolio: yeah that's what it seems to me too :/
15:06:58 <Koterpillar> you have to add x on them
15:08:16 <Koterpillar> so the right side is "f x"
15:08:24 <wayne> ah thanks
15:10:09 <wayne> hmm, not sure that's the case
15:10:21 <wayne> are you saying what's written in the post is wrong?
15:10:31 <Koterpillar> no
15:10:39 <Koterpillar> how do you prove function equality?
15:11:04 <Koterpillar> f = g iff f x = g x for all x
15:11:33 <wayne> ah you're saying we need the same domain for the proof
15:12:06 <Koterpillar> yes, you can't apply the equation for bind without the value
15:34:12 <tommd> j
15:48:41 <kgadek> anyone here knows anything about licenses? Need opinion (blahblah I don't expect a lawyer nor legal advice blahblah just opinion blahblah IANAL blahblah)
15:48:53 <kgadek> (moving my q. from #haskell-offtop)
15:49:00 <kgadek> let's say there is library X under GPL-2
15:49:03 <Axman6> kgadek: what do you weant to know?
15:49:04 <kgadek> I write library Y that is under BSD-3 (or MIT or whatever)
15:49:11 <kgadek> Q1: what is the actual licence of Y?
15:49:11 <kgadek> 1.a) it's GPL-2, because API is also under copyri^W copyleft (related: Google v Oracle)
15:49:11 <kgadek> 1.b) it's BSD-3, but whoever uses Y, will get GPL-2'd artefact
15:49:11 <kgadek> another thing
15:49:21 <kgadek> Q2: what's the licence of Main.hs that requires Y?
15:49:21 <kgadek> 2.a) same as in 1.a, Z sources and any binaries are just GPL-2
15:49:21 <kgadek> 2.b) source is BSD-3, binaries are GPL-2'd
15:49:21 <kgadek> Q3: if it's 2.b, then is .hi file GPL-2'd? .o file? only executable?
15:51:00 <dmwit> wayne: The actual assignment is to prove `f * unit = unit * f = f`. Since `f * g = bind f . g`, this makes the equation `bind f . unit = bind unit . f = f`.
15:51:35 <Axman6> kgadek: welcome to the cancer that is GPL -_-
15:51:41 <dmwit> wayne: With the definition `bind f x = concat (map f x)`, this becomes `(\x -> concat (map f x)) . unit = bind unit . (\x -> concat (map f x)) = f`. Not quite the equation you set out to prove. =P
15:51:57 <Clint> Axman6: :P
15:52:02 <kgadek> Axman6: didn't want to state it like that ;D
15:52:23 <dmwit> erp
15:52:31 <dmwit> wayne: And even I got the equation wrong. Math is hard.
15:52:44 <Axman6> if it quacks like a duck...
15:52:57 <kgadek> Axman6: my opinion is that FSF was greatly influential and we shall be grateful (blahblah) but I don't like GPL too much
15:52:59 <dmwit> wayne: `(\x -> concat (map f x)) . unit = (\x -> concat (map unit x)) . f`
15:53:12 <kgadek> but the question remains
15:53:18 <kgadek> how viral is the GPL ? :)
15:53:51 <Axman6> well, that is _the_ question, and I'm not sure the answer is completely clear. 
15:54:09 <kadoban> kgadek: The start doesn't seem to make sense. You write a library Y that's under BSD3, why would it be under something other than BSD3?
15:54:26 <Clint> kadoban: he's talking about the derived work created by linking with copyleft software
15:54:54 <kgadek> kadoban: what Clint said essentially. it's really non-trivial for me that I'm allowed to give it BSD-3 at all
15:55:11 <kgadek> c.f. https://en.wikipedia.org/wiki/GNU_General_Public_License#Linking_and_derived_works 
15:55:32 <dolio> Your original question has no connection between library X and library Y.
15:55:33 <kgadek> FSF holds that dynamic linking implies derived work implies "it's GPL!"
15:55:39 <dolio> So why would the license of X affect Y?
15:55:41 <Axman6> kgadek: because use of GPL'd code infects other code
15:55:42 <kadoban> If it's a derived work, then you have to follow the license of the thing you're deriving from. aka, it's GPL
15:55:45 <kgadek> ohhh sorry
15:55:50 <kgadek> I meant that Y uses X
15:55:51 <Clint> "infects"
15:56:03 <kgadek> kadoban: bingo.
15:56:09 <kgadek> so the rephrase of my question is:
15:56:15 <kgadek> what is derived work here
15:56:21 <kadoban> So tired of even talking about licenses anymore ... people just cannot seem to manage without "infects" and "viral" and "cancer" apparently.
15:56:30 <Clint> in effect people are feeling oppressed because they want to use X without reciprocating
15:56:33 <Clint> which is also tiresome
15:56:34 <Tuplanolla> Any form of linking or alteration, kgadek.
15:56:38 <kadoban> Never heard so much hyperbolic bullshit around "this person will let me use their code for free"
15:57:17 <kgadek> kadoban: hmm, I'm not a good person to discuss the language around the discussion
15:57:20 <kgadek> (so meta)
15:58:28 <kgadek> kadoban: if you're not too tired of that and have an opinion you want to share, I'll double-check myself not to attack GPL
15:58:55 <kadoban> I didn't really understand tha last request
15:58:58 <kgadek> ok, so
15:59:09 <kadoban> that* wow I'm bad at typing today.
15:59:27 <kgadek> I have library Y, it depends on X
15:59:37 <kgadek> is the source code of Y a derived work of X?
15:59:53 <kgadek> <=> is the Y *source* necessarily under GPL?
15:59:54 <kadoban> It depends, AFAIK :-/ Which is an unfortunate answer.
16:00:12 <Tuplanolla> Basically GPL means that you reciprocate by (1) sharing derived works with the community under the same license, (2) paying the authors for a double licensing scheme or (3) building your own replacement from ground up.
16:00:30 <kadoban> Is the library actually GPL, or is it perhaps LGPL?
16:00:38 <dolio> The answer is probably "yes," and has nothing to do with Google vs. Oracle, I think.
16:00:58 <Clint> kgadek: i am not a lawyer, no, the source is what you said it is
16:01:14 <Clint> (unless it's a derivative work)
16:01:21 <kgadek> kadoban: GPL-2, not LGPL
16:01:57 <kgadek> dolio: yes as in…? sorry, lost track
16:02:14 <dolio> As in it is a derivative work. Certainly that is the safest answer.
16:02:25 <Tuplanolla> Which option are you picking, kgadek?
16:02:39 <kgadek> to bang my head against the desk :D
16:02:45 <kadoban> kgadek: If it's a derived work or not depends how linked they are, I believe. http://www.gnu.org/licenses/gpl-faq.html#MereAggregation has a little info. The safer bet is to assume that it's a derived work I suppose, but ...
16:02:55 <Clint> kgadek: what is your actual goal
16:03:35 <kgadek> well, there is this "little" library
16:03:36 <kgadek> called pandoc
16:04:00 <kgadek> it's a requirement of this "little" library & tools
16:04:02 <kgadek> called hakyll
16:04:09 <kgadek> and there's this little project of mine
16:04:13 <kgadek> called "let's make a blog"
16:04:48 <kgadek> and now the thing is that I really want to give away codes to whoever wants them, BSD style
16:04:57 <kgadek> I don't care. Let it be useful
16:05:04 <kgadek> but now there is this nasty path
16:05:14 <kgadek> that I'm quite afraid of 
16:05:18 <Tuplanolla> The code of your website or what you share on it, kgadek?
16:05:30 <kgadek> Tuplanolla: both!
16:05:47 <Clint> kgadek: what are you afraid of?
16:05:53 <Tuplanolla> The former will have to be under the GPL, but the latter is unconstrained, kgadek.
16:06:07 <kgadek> I don't want my content to be on GPL. I want something "freer" :)
16:06:21 <Tuplanolla> Documents generated by Pandoc or programs compiled by GCC don't get their licenses.
16:06:22 <kgadek> Tuplanolla: well, that's not so obvious unfortunately. Gimme sec
16:06:41 <Clint> it sounds like you are creating a problem that doesn't exist
16:06:57 <kgadek> https://www.gnu.org/licenses/gpl-faq.html#IfInterpreterIsGPL
16:07:41 <Sornaensis> is it normal to have one datatype with dozens of constructors for a compiler AST
16:07:42 <kgadek> the thing is: GCC has *explicit* rule that allows it to compile to non-GPL binaries
16:07:52 <Sornaensis> or should the AST be broken into sections
16:08:04 <Clint> kgadek: are you distributing haskell binaries?
16:08:25 <kgadek> Clint: no, but the binary is used by me to produce html that I'll distribute
16:08:31 <Clint> this is completely irrelevant
16:08:32 <Clint> you are fine
16:08:39 <Tuplanolla> It's usually one type, although different stages may have different types, Sornaensis.
16:09:09 <Clint> kgadek: unless somehow pandoc is injecting gpl code into your html
16:09:21 <dmwit> Sornaensis: Pretty normal.
16:09:22 <kgadek> Clint: ok, so my hakyll-based sources are fine to be BSD-3?
16:09:27 <Clint> kgadek: yup
16:09:39 <kgadek> Clint: hmmmmmmmmmm that's a… hard question
16:10:00 <kgadek> templates built-in into pandoc are GPL'd?
16:10:19 <Tuplanolla> Nobody cares enough to come after your templates, kgadek.
16:11:09 <kgadek> Tuplanolla: well, that's true. Nobody will care. Maybe
16:11:12 <Clint> kgadek: i have hakyll-generated content on a website and i guarantee no one is going to sue me for the markdown source
16:11:17 <wayne> dmwit: oh i see where i went astray with that expansion. thanks much for going through the effort of spelling it out
16:11:40 <dmwit> I will go even farther: GPL all your stuff, and add a note that says "contact me if you want a more relaxed license". Then worry about the problem lazily.
16:11:52 <kgadek> dmwit: hahah :D
16:12:06 <Tuplanolla> It's not a bad idea.
16:12:07 <kgadek> Clint: markdown source — okay. HTML though?
16:12:26 <dmwit> 99.9% chance of never forcing that thunk.
16:12:53 <kgadek> dmwit: BTW, you made my day :D this is a golden example of a proper laziness :D
16:13:02 <Starfflame> there a way to check for a null character?
16:13:10 <Clint> kgadek: someone is going to sue me to get the generated html i'm already distributing?
16:13:11 <Starfflame> err
16:13:20 <dmwit> Starfflame: ('\0'==)?
16:13:25 <Sornaensis> Tuplanolla: alright that's what I thought. I am trying to use catamorphisms to simplify operations on the AST
16:13:43 <dmwit> Starfflame: Or spell it '\NUL' if you want to emphasize that it's the null-ness you care about.
16:13:53 <Starfflame> like if I'm doing a fold and I want something to happen if I come to the end of the fold
16:14:01 <dmwit> As opposed to the codepoint-0-ness.
16:14:02 <Starfflame> on a string of characters
16:14:09 <Sornaensis> right now I have a half a dozen functions spread across a several types
16:14:19 <dmwit> Starfflame: The folding function itself will offer that.
16:14:20 <dmwit> e.g.
16:14:21 <dmwit> :t foldr
16:14:24 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
16:14:38 <Tuplanolla> :t cata
16:14:39 <dmwit> The `b` argument gives the value it will use for empty lists.
16:14:40 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
16:15:00 <Clint> kgadek: jgm would have to sue me based on the idea that the html i'm publishing is a derivative work of pandoc and that i'm not distributing/offering source of this pandoc derivative
16:15:05 <dmwit> Starfflame: Or: perhaps you would like to tell us what you're really doing, and where it went wrong.
16:15:09 <kgadek> Clint: hmm, in theory, someone could sue you for breaking the GPL license if you state on the blog "whatever is here is under not-a-GPL license"
16:15:43 <Starfflame> sure
16:16:10 <Clint> kgadek: doesn't matter what license i claim it's under for the purposes of this imaginary lawsuit
16:16:11 <wayne> GPL would make for a decent monad @_@
16:16:26 <Clint> it only matters that i'm violating the copyright license
16:16:28 <Sornaensis> lol
16:16:29 <Clint> which i would argue i am not
16:16:51 <kgadek> wayne: unsafePerformGPL? :D
16:16:59 <Starfflame> http://pastebin.com/hfvT7NUR
16:17:09 <Starfflame> so I'm going through a list such as "1+2+3-4"
16:17:14 <Starfflame> er wait
16:17:16 <Starfflame> fuck wrong function
16:17:52 <Starfflame> http://pastebin.com/w5azHzcT
16:18:07 <dmwit> Please try not to swear.
16:18:07 <Cale> Starfflame: btw, lpaste.net is much better
16:18:27 <kgadek> Clint: anyway, what you say makes a lot of sense. I'll probably go the same route
16:18:40 <Starfflame> so I'm taking an input of a string of words, and I'm killing all the spaces
16:18:43 <kgadek> thanks to all discussing!
16:19:05 <Tuplanolla> Are you avoiding parser combinators on purpose, Starfflame?
16:19:51 <Cale> Well, parser combinators might be overkill for this, but takeWhile/dropWhile or span/break would probably be a good idea
16:19:54 <Cale> > break isSpace "hello there"
16:19:57 <lambdabot>  ("hello"," there")
16:20:16 <Cale> Or is the goal to use foldr specifically?
16:20:29 <Starfflame> yeah, the goal is to use foldr
16:21:04 <Cale> x == '' doesn't make sense, '' is not a valid character
16:21:13 <Cale> Did you mean '\n' or something?
16:21:18 <dmwit> Starfflame: So, it works for me if I remove the `== ''` condition; make the base case `[]` instead of `[""]`, and modify `fst` to a function that sticks the second part of the tuple on the list in the first part.
16:21:26 <Cale> There's a function isSpace which will tell you if a character is whitespace
16:21:47 <dmwit> Starfflame: e.g. `\(words, newWord) -> newWord:words` instead of `fst`.
16:22:00 <Sornaensis> > filter (not isSpace)  " dingkins blorps\n\t\b"
16:22:02 <lambdabot>  error:
16:22:03 <lambdabot>      • Couldn't match expected type ‘Char -> Bool’
16:22:03 <lambdabot>                    with actual type ‘Bool’
16:22:14 <Cale> (not . isSpace)
16:22:22 <Sornaensis> > filter (not . isSpace)  " dingkins blorps\n\t\b"
16:22:25 <lambdabot>  "dingkinsblorps\b"
16:23:36 <Cale> I guess backspace doesn't count as whitespace
16:24:49 <kgadek> Clint: sorry to disturb again, just wanted to clarify your point. You believe then that the source code of Z (i.e. my blog) that uses Y (i.e. hakyll) that uses X (i.e. pandoc) can be BSD-3'd?
16:25:08 <kgadek> and the binaries probably will be GPL'd, but I don't need to distribute them anyway, right?
16:25:19 <Clint> kgadek: yes, exactly
16:25:26 <kgadek> ok, thanks :)
16:25:40 <Cale> kgadek: For the stuff that you produced, you can put whatever license you want on it. It might be the case that you will end up granting other rights due to the GPL.
16:26:35 <kgadek> Cale: well, yes and no. "No" if what I produce is a derivative work
16:26:50 <kgadek> and that's what I was researching
16:27:12 <Clint> s/produce/& and distribute/
16:29:02 <jrm> Hi.  I'm just staring out learning haskell and am on the 3rd question of Ninety-Nine Haskell Problems.  Is there a straightforward way to print non-string variables in the error function?  Something like http://ftfl.ca/paste/haskell-99-questions-3.html ?
16:29:13 <Cale> kgadek: Well, okay, the GPL says "You must cause any work that your distribute or publish, that in whole or in part contains or is derived from the Program or any part thereof, to be licensed as a whole at no charge to all third parties under the terms of this License" -- which means that if you additionally offer a GPLv2 license for your work, you'll be okay, regardless of whether you also put it under BSD
16:30:20 <monochrom> jrm: "show" works for Int. You also need parentheses.  error ("aaa " ++ show y ++ " bbb")
16:30:40 <kgadek> Cale: hmm, I'm quite sure that BSD+GPL=GPL, not a double-license work
16:31:04 <kgadek> they have this lengthy list of compatible licenses that serves this purpose
16:31:12 <kgadek> i.e. can you have both BSD and GPL
16:31:21 <kgadek> (actually it's not  BSD+GPL=GPL, it
16:31:22 <jrm> monochrom: Ah ha.  Thanks.
16:31:37 <kgadek> it's more  BSD+GPL=BSD+GPL — you still need to satisfy both
16:32:13 <kgadek> in double-license, you — the end user — can select which license suits you
16:33:33 <Cale> kgadek: Well, you're the copyright holder on the stuff that you produce, but you only have rights to the GPLed libraries you're relying on if you satisfy the terms of those licenses. You can offer other people arbitrary terms for your work, but in order to have rights to the GPLed stuff, the GPL says you must offer the GPL license on your work.
16:34:11 <Cale> It probably amounts to about the same thing as putting the thing under GPL
16:34:27 <kgadek> Cale: yes, that's what I believe is true
16:34:37 <Cale> Because in order to distribute yet further things, other people will need to do the same
16:34:58 <Cale> (because otherwise *they* won't have rights to the GPLed parts)
16:35:45 <Cale> However, I don't think there's any harm in just sticking all the licenses on stuff.
16:35:47 <kgadek> however, the thing here is that: if I add a GPL'd library to `depends` in .cabal, and import that library, and use the methods there
16:35:57 <kgadek> is the source I've written a derived work?
16:36:07 <Cale> That's for the courts to decide
16:36:13 <kgadek> yeah :(
16:36:46 <Cale> I would tend to say "no", but people are idiots.
16:37:22 <kgadek> well, FSF insists that dynamically linking of libraries means you need GPL for your thing
16:37:40 <Cale> They can insist that, but that doesn't necessarily make it so
16:38:00 <kgadek> that's true
16:43:19 <jomg> isn't this problem the reason why the LGPL exists in the first place? that technically, any program using a library counts as a derived work of that library?
16:43:23 <Cale> kgadek: I would tend to take the view that if you're not modifying, copying, translating, or otherwise changing the thing, then whatever it is you have can't be a derivative work of it.
16:44:25 <kgadek> Cale: well, I *personally* agree. But IANAL so wanted YANAL and some HINAL to confirm :)
16:44:30 <Cale> If I produce a transparency which is intended to be layered on top of someone else's book, even if the thing I'm distributing is useless without that other work, I don't believe it would be a "derivative work".
16:45:08 <Cale> (so long as it doesn't duplicate any of the content of that other work)
16:46:44 <jomg> i agree that that sounds sensible, but afaik, the FSF interprets the matter differently
16:47:08 <Cale> Yes, they do.
16:49:04 <Cale> Also: you have the right to distribute your work however you see fit, if you're not distributing the other library, you don't require the GPL to apply.
16:49:55 <Cale> The GPL grants you the right to distribute that other library, under its terms.
16:50:07 <Cale> But if you're not distributing the thing, you don't need those terms to apply.
16:50:14 <jomg> hmm, i guess that makes sense
16:50:19 <Cale> (you don't need those rights at all)
16:51:00 <Cale> You can dynamically link to proprietary software and BSD license your stuff.
16:51:00 <Cale> (and this is done all the time)
16:51:03 <Koterpillar> what did the VMWare vs. Linux case come up to?
16:51:04 <jomg> you'd only need to honor the terms of the GPL if you distribute e.g. a binary that links to the GPL'd library
16:51:14 <Cale> You just can't distribute the proprietary software because you don't have that right.
16:51:21 <jomg> but not if you only distribute the source
16:51:57 <Clint> and the BSD part gets violated all the time too
16:51:59 <Cale> Right, if you distribute the code of the GPL-licensed thing, then you need to honor the terms of the license in order to have the rights that are granted to you by it.
16:52:44 <Cale> But if you don't distribute that code, it's simple, the GPLed thing might as well be proprietary, you don't need to accept its limitations because you don't need the rights it will grant you.
16:54:12 <jomg> i guess "that code", in this instance, means "that code, be it in source or in compiled/object/whatever form"?
16:54:17 <Cale> yes
16:54:30 <Cale> Doesn't matter what form
16:56:03 <jomg> okay, i think that cleared it up for me
16:56:10 <jomg> thanks a lot :)
16:56:14 <Cale> It's perhaps worth pointing out that copyright law (at least in most places -- in the US, it's getting a little more complicated because of weird new laws), generally only applies to things which are in some way distributed or performed.
16:58:06 <Cale> In the US also it's possible that one might interpret the right to "prepare derivative works" in a funny way which would allow for people to be in violation of copyright law even in cases where they have no intention of ever distributing anything.
16:58:45 <Koterpillar> and don't forget patents
16:59:19 <dustmote> s%/funny\|weird/authoritarian/g
16:59:30 <Cale> But I don't know if there's any precedent whatsoever for that kind of thing -- I think most cases would be covered by fair use.
16:59:54 <Cale> (Am I preparing a derivative work when I hear and memorise a song?)
17:01:00 <osfameron> in some way you *are*
17:01:32 <Cale> I think some band should step up and try to sue their audience just as a stunt
17:01:39 <osfameron> there's the story of Nasreddin Effendi and the Smell of Food vs the Sound of Money
17:01:46 <osfameron> which I sometimes think of in relation to copyright
17:02:21 <osfameron> http://www.pitt.edu/~dash/hodja.html#foodsmell
17:03:31 <Cale> Haha, nice! I'd heard that story before, but I'd forgotten about it.
17:05:08 <osfameron> I often think *some* categories of copyright "infringement" are like that.  If I draw a picture of Mickey Mouse, or write some (terrible) Doctor Who fan fiction, is it my fault that those are cultural events that have taken up lodging in my brain? ;-)
17:08:36 <dmwit> Cale: I wonder if you could defend your memorized version as a parody.
17:08:44 <dmwit> Obviously a more terrible version of the original in every way.
17:09:59 <mac10688> http://stackoverflow.com/questions/42476296/how-to-free-address-in-yesod
17:10:07 <mac10688> if anyone knows the answer I would appreciate it
17:10:31 <Koterpillar> mac10688: stop that first one
17:10:36 <Koterpillar> mac10688: or change the port
17:14:55 <solrize> whoa, apt-get install haskell-mode has a dependency on ghc, so since i have ghc installed under stack, apt doesn't know about it and the haskell-mode install tried to bring down the ghc package, can't be good.  
17:15:38 <juhp> use the emacs package manager :)
17:15:47 <juhp> solrize: ^ :)
17:15:56 <solrize> yeah i did that
17:16:06 <solrize> once i saw what apt-get was going to do :)
17:16:09 <solrize> thanks
17:16:44 <juhp> sure
17:16:48 <solrize> oh wow, this is different than the old haskell-mode that i'm used to
17:18:04 <solrize> prompt is "\03BB" which i'm guessing is a lambda
17:18:16 <solrize> gotta figure out how to get emacs to show that
17:30:46 <turbulent3ddy> Hello.
17:31:32 <dustmote> osafameron, thank you for the story
17:47:26 <mac10688> Koterpillar, my apologies if this is too simple of a question. But what's the best way to stop the first program?
17:52:32 <Starfflame>  how do I specify an empty tuple?
17:52:50 <Starfflame> i.e. ( , ) except syntactically correct
17:53:10 <jle`> Starfflame: ()
17:53:13 <c_wraith> What does "empty tuple" mean?
17:53:54 <Starfflame> a tuple analagous to an empty list
17:54:08 <Starfflame> analogous*
17:54:18 <c_wraith> There really isn't an analogy to be made.  tuples are fixed-length, lists are arbitrary-length
17:54:28 <c_wraith> What is the type of the value you want?
17:54:56 <c_wraith> lists of any length are all the same type.  Tuples of any length are different types from tuples of any other length.
17:57:58 <Starfflame> never mind
17:58:03 <Starfflame> i came up with a better base case
17:58:23 <Axman6> the closest to an empty tutple is unit: ()
17:58:27 <Axman6> tuple*
17:58:34 <Cale> ()
17:58:36 <c_wraith> But it really has nothing in common with an empty list.
17:58:37 <Cale> Yeah, there's no 1-tuple, but there is ()
17:58:47 <Cale> which is as good as a 0-tuple :)
17:58:58 <Axman6> Cale: that doen't top there being a Onetuple package though =)
17:59:12 <Starfflame> Basically what I wanted to do was  have a tuple that when put into a list, did something similar as []
17:59:13 <Axman6> :t (1)
17:59:16 <lambdabot> Num t => t
17:59:19 <Starfflame> but i came up with something that didn't suck
17:59:32 <Axman6> Starfflame: I don't understand what that means
17:59:38 <Starfflame> neither do I
17:59:48 <Axman6> but anyway, tuples aren't an inductive type like lists
18:00:38 <Cale> Yeah, really triples have nothing to do with pairs -- they're completely separate types.
18:00:44 <Cale> (and so on)
18:09:16 <slack1256> what is the actual defintion of a leftover on pipes-parse?
18:11:24 <Koterpillar> mac10688: Ctrl-C
18:12:10 <mac10688> oh ok thank Koterpillar , I was using ctrl-z and I guess I was stopping it, instead of killing it
18:13:27 <lyxia> slack1256: http://hackage.haskell.org/package/pipes-parse-3.0.8/docs/Pipes-Parse.html seems pretty illustrative
18:17:19 <EvanR> Since monads or principles of substantial unity are everywhere in matter, it follows from this that there is also an actual infinity, since there is no part, or part of a part, which does not contain monads.
18:17:34 <EvanR> leibniz could have invented monads
18:19:57 <c_wraith> he was talking about something else, of cours.e
18:20:00 <c_wraith> *course.
18:20:13 <slack1256> lyxia: now I am confused on why not just use `Pipes.next` instead of Pipes.Parse.draw`
18:20:22 <slack1256> What do we gain with the StateT?
18:20:35 <EvanR> its funny if you read it anachronistically and pretend leibniz was inventing haskell
18:22:12 <Costar> Hey all
18:24:27 <lyxia> slack1256: you gain that the state is handled implicitly
18:27:41 <wizard1337> so if i'm writing a small application which needs database-like functionality,
18:27:58 <wizard1337> but i don't want to use SQL/a SQL database, etc
18:28:05 <wizard1337> because i want to store types which i define in haskell
18:28:10 <slack1256> acid-state
18:28:12 <wizard1337> but still be able to issue queries over them
18:28:29 <slack1256> @where acid-state
18:28:29 <lambdabot> I know nothing about acid-state.
18:29:00 <EvanR> acid-state is for saving the data reliably
18:29:10 <EvanR> you still need something like indexed sets to do the lookups
18:29:14 <EvanR> like ixset
18:29:19 <wizard1337> am i askng for too much?
18:29:42 <EvanR> a database does necessarily require saving to disk, and restoring across program runs
18:29:45 <EvanR> doesn*
18:29:49 <EvanR> doesnt*
18:30:06 <Cale> wizard1337: Well, what do you mean by "database-like"?
18:30:31 <Cale> wizard1337: Let's start on the lightweight end -- are you aware of Data.Map?
18:31:03 <Cale> (from https://hackage.haskell.org/package/containers)
18:31:39 <wizard1337> ok, a key value store
18:32:01 <wizard1337> i'm a super noob
18:32:05 <Cale> https://hackage.haskell.org/package/containers-0.5.10.1/docs/Data-Map-Lazy.html -- it provides a data structure for storing key/value pairs in which you can look elements up by key efficiently, and do useful things like intersection and union.
18:33:16 <jle`> @let myMap = M.fromList [('a', 123),('b',234),('c',1049)]
18:33:19 <lambdabot>  Defined.
18:33:23 <jle`> > myMap M.! 'a'
18:33:25 <EvanR> yes ixset is just a pile of such Data.Maps
18:33:26 <lambdabot>  123
18:33:27 <jle`> > myMap M.! 'b'
18:33:30 <lambdabot>  234
18:33:47 <Cale> > M.lookup 'a' myMap
18:33:49 <lambdabot>  Just 123
18:33:52 <Cale> > M.lookup 'x' myMap
18:33:54 <lambdabot>  Nothing
18:34:14 <EvanR> you can also split a Data.Map at some key, into the value there (if any), and two submaps of everything with key less and key greater
18:34:33 <EvanR> thus getting less than and greater than queries
18:34:52 <wizard1337> but i would need to implement that
18:35:00 <Cale> Implement what? :)
18:35:02 <seafood> Why does this work? do { Just x <- [ Just 2, Nothing, Just 3]; return x } =====> [2,3]
18:35:06 <wizard1337> lol
18:35:20 <wizard1337> that's called the viagra operator
18:35:54 <Cale> seafood: Because fail x = [] for the list monad.
18:36:08 <Cale> (and pattern match failures employ fail)
18:36:39 <seafood> Cale: Thought it might have something to do with that. Wow, that's pretty convenient!
18:37:05 <Cale> You can also write it as a list comprehension
18:37:17 <Cale> > [x | Just x <- [Just 2, Nothing, Just 3]]
18:37:20 <lambdabot>  [2,3]
18:37:55 <Cale> > [(x,y) | (x:xs) <- tails [1..4], y <- xs]
18:37:58 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
18:38:07 <seafood> Cale: I'm not sure how I feel about pattern match failures employing fail. Whose idea was that?
18:38:21 <Cale> Well, before fail, it was mzero
18:38:25 <Cale> It was the Haskell 98 committee who did that
18:38:34 <Cale> (who changed it from mzero to fail)
18:39:18 <seafood> Wow, it was always mzero? even back as far as Haskell98? Interesting!
18:39:33 <Cale> *Prior* to Haskell 98, it was mzero
18:39:56 <Cale> fail was introduces in Haskell 98 for the purpose of handling that case, when MonadZero got merged into MonadPlus
18:40:09 <Cale> (for some silly reason which I still can't entirely fathom)
18:40:36 <lyxia> And soon we're going to get MonadFail
18:40:57 <lyxia> this is a bit of a mess
18:41:34 <Cale> Well, part of the reason was that monad comprehensions in the style of list comprehensions had just been removed and someone was like "hey, these two classes have all the same instances anyway, and we only needed MonadZero to be separate for the monad comprehensions, let's unify them" -- and of course they were wrong, it was also needed for do-notation.
18:42:33 <Cale> Interestingly, GHC still pretty much translates the do-notation using the Haskell 1.4 rules, except with fail in the place of mzero.
18:43:09 <seafood> Hmm, are you sure this semantics was in Haskell 98? Can you refer me to the correct spot in the document? I just did some reading and could only find talk of failed pattern matches evaluating to _|_ (bottom)
18:43:21 <Cale> Patterns which aren't failable in the sense of Haskell 1.4, that is patterns which only involve variables and irrefutable matches and matches against constructors of data types with only a single constructor, won't result in usage of fail.
18:43:53 <Cale> In Haskell 98, the translation given will always involve fail in a branch that will just sometimes be dead code.
18:44:10 <Cale> Yeah, sure
18:45:12 <Cale> https://www.haskell.org/onlinereport/exps.html#sect3.14
18:45:26 <Cale> See the box labelled "Translation"
18:46:00 <Cale> do { p <- e ; stmts } = let { ok p = do { stmts }; ok _ = fail "..." } in e >>= ok
18:46:25 <seafood> Cale: That's perfect! Thanks
18:47:05 <Cale> If you go back and look at the Haskell 1.4 report, it's more nuanced and discusses failable patterns
18:47:20 <Cale> (and actually describes GHC better, ironically)
18:48:31 <Cale> wtf Haskell.org, I need you for *one* thing, which is accessing old versions of the Haskell report, and you're failing me
18:48:32 <Cale> lol
18:48:49 <EvanR> time to set up a mirror
18:49:03 <Cale> ah, here we go: https://wiki.haskell.org/Language_and_library_specification
18:50:04 <Cale> Yeah, if you get the gzipped postscript, it's on page 21
18:50:16 <SegFaultAX> What are peoples thoughts on Purescript's delimited Eff effects using row types? Would such a thing be desirable in Haskell? Reading through the Hair Shirt slides, it looks like SPJ talked about a similar concept as far back as '93.
18:50:25 <Cale> do { p <- e ; stmts } = e >>= \p -> do { stmts } where p is failure-free
18:50:28 <Cale> and
18:51:01 <Cale> do { p <- e ; stmts } = let { ok p = do { stmts }; ok _ = zero } in e >>= ok  where p is not failure-free
18:52:13 <Cale> All irrefutable patterns are failure-free, and if C is the only constructor in its type, then C p_1 ... p_n is failure-free when each of the p_i are failure-free, and if the pattern p is failure-free, then so is v@p.
18:53:21 <Cale> SegFaultAX: People have done similar things in Haskell too.
18:55:14 <Cale> SegFaultAX: It's possibly a bit nicer when you have some kind of type-level stand in for sets and don't have to simulate that so much.
18:56:26 <EvanR> idris effects makes use of a auto-proven SubList predicate
18:57:16 <Cale> But in Haskell, it's usually just easier to use polymorphism to abstract over the implementation of the monad you're dealing with, at which point, the fact that constraints can be combined together lets you discuss which operations or effects you have.
18:57:59 <SegFaultAX> Cale: I've found that an issue (for me, at least) with IO is that it opaquely encompasses all manner of effects. Once I tasted the benefits of being able to explicitly enumerate which effects are actually needed it's hard to go back to the opaque form.
18:58:25 <Cale> Well, we *could* do that with type classes in Haskell.
18:58:53 <Cale> Like, there could be a MonadNetworkIO and MonadFileIO and so on.
18:59:25 <SegFaultAX> Ah, well that quickly becomes very cumbersome if you need multiple kinds of effects. :)
18:59:35 <EvanR> the question is whether we are gaining something or doing bondage and discipline
18:59:53 <EvanR> like the C++ singleton pattern so stop you from making more than one object
18:59:59 <Cale> Well, so does writing out the row types you'll be supplying to Eff
19:01:30 <mmachenry1> When I run "stack test —coverage" on my project I completely bizarre results. This might be a bug but I'd love a second pair of hopefully more well informed eyes before submitting it.
19:01:31 <Cale> You might gain something some of the time in terms of being able to provide fake implementations. It would hurt performance a bunch unless the compiler got a good deal better though.
19:02:09 <SegFaultAX> Cale: It's a bit easier in PS because row pattern allow for a wildcard so you don't have to name *all* effects all the time.
19:03:01 <EvanR> to summarize a bunch of rows as something thats a matter of type synonyms
19:03:04 <mmachenry> https://github.com/mmachenry/tapl  When running "stack test —coverage" I get HTML that reports completely meaningless lines of code cover and subsections of code that highlights things that break up identifiers. 
19:03:16 <EvanR> if its a often reused parameterized list, a parameterized type synonym
19:03:24 <mmachenry> Meaning the covered part of the code is half of an identifier, which is not possible.
19:03:25 <SegFaultAX> EvanR: One of the benefits is increased local reasoning. I can know much more about the kinds of effects a piece of code will have just by looking at the types
19:03:46 <mmachenry> I think the coverage is reporting data about a different file but overlaying it with the one I ran.
19:04:04 <EvanR> you get more but not necessarily as much as possilbe
19:04:16 <dolio> Cale, SegFaultAX: It's called the MTL. :P
19:04:16 <EvanR> i think checked exceptions has the same sort of trade off
19:04:28 <mmachenry> Also when I run "stack test arith —coverage" the report's code that is displayed is from the untyped package, not arith, even though it's called arith in the HTML overview page.
19:04:47 <Cale> dolio: Well, I'm thinking of more than the MTL really provides, but it's sort of a template for further expansion which could be done.
19:05:25 <SegFaultAX> EvanR: I suppose it's similar in a sense, but no an utter pain to use.
19:05:26 <dolio> mtl doesn't divide IO into dozens of things, it's true.
19:05:33 <Cale> In fact, I really dislike the MTL classes, and generally strive to remove any of them from constraints in our projects, in favour of more descriptive classes.
19:05:40 <SegFaultAX> EvanR: But insofar as it helps you reason about the kinds of exceptions some code is likely to raise, yes.
19:05:44 <Cale> *Especially* MonadReader
19:06:07 <dolio> mtl's classes also aren't algebraic.
19:06:16 <Cale> In current versions of GHC, if you have type errors in some large definition constrained by MonadReader, god help you.
19:07:08 <Cale> The instance of MonadReader for (->) e means that GHC will be confused by extra or missing parameters, and will generally report an error at the top level of the definition, regardless of where the missing or extra parameter actually occurs.
19:07:28 <Cale> So they're productivity killers
19:08:17 <dolio> I suppose. Reader is probably the most pointless effect.
19:08:20 <Cale> If you need a MonadReader constraint, define a new type class with operations for accessing your particular environment
19:08:44 <dolio> Do they even include it in these hot new effect libraries?
19:08:48 <EvanR> SegFaultAX: right, with idris you can make the effect list a defined variable, its first class
19:08:54 <EvanR> or parameterize it
19:09:34 <EvanR> but generally everythings a pain in the ass in one way or another, so far with idris
19:09:38 <SegFaultAX> EvanR: Oh that's very cool. I don't know anything about Idris other than what I've gleaned from wikipedia and stray talks here and there. :)
19:09:57 <Cale> It seems really common though -- a lot of our constraints are glorified MonadReader constraints.
19:10:04 <Cale> (only not by that name)
19:10:07 <EvanR> since types are first class, a lot of haskell complexity goes away
19:10:35 <Cale> Just like "hey, we have a way to access this piece of configuration which is hanging around somewhere"
19:11:13 <SegFaultAX> EvanR: When you say that types are first class, do you mean that types are values in the normal sense? Are they values only during compilation or also at runtime?
19:11:31 <dolio> Cale: I don't think it's a useful effect in the extensible effects sense. It's better in the approach I think you usually take, of defining some monad that you're working in for some activity.
19:11:42 <Cale> SegFaultAX: "Yes" and "also at runtime"
19:12:51 <Cale> dolio: Yeah, and actually, if I can have things that way and get by with monomorphic definitions that just use a particular monad, I usually prefer it.
19:13:25 <Cale> I have to admit that sometimes the approach via polymorphism and type classes is pretty good when you don't understand what you're going to need very well ahead of time though.
19:14:29 <Cale> Well, or where you have a bunch of related monads, obviously.
19:16:19 <slack1256> :q
19:16:22 <slack1256> ops
19:16:37 <Welkin> nops
19:18:59 <Cale> Probably the most interesting nontrivial example of a type class to constrain a monad which I defined lately was one for various operations based on postgres' large object support.
19:19:06 <lpaste_> Cale pasted “PostgresLargeObject” at http://lpaste.net/353014
19:19:30 <Cale> Not the prettiest abstraction, but meh
19:20:25 <Cale> Just a way to have a bunch of operations which are definable in terms of DbPersist stuff and then get auto-lifted through various transformers.
19:21:24 <Cale> I could have stuck more closely to postgres' actual interface to this stuff, but instead I opted to provide the operations we actually used.
19:23:38 <Cale> (and with that, we can stream video out of our database, yay)
19:24:30 <dolio> Cale: Anyhow, I just try to point out that using mtl-like classes is equivalent to the new effects stuff that people are so enamored with.
19:24:35 <dolio> To counter some of the hype.
19:33:47 <Starfflame> > ord . toUpper . 'a'
19:33:50 <lambdabot>  error:
19:33:51 <lambdabot>      • Couldn't match expected type ‘a -> Char’ with actual type ‘Char’
19:33:51 <lambdabot>      • In the second argument of ‘(.)’, namely ‘'a'’
19:34:14 <Starfflame> > ord $ toUpper 'a'
19:34:17 <lambdabot>  65
19:34:26 <Starfflame> ord.toUpper 'a'
19:34:34 <Starfflame> > ord . toUpper 'a'
19:34:38 <lambdabot>  error:
19:34:38 <lambdabot>      • Couldn't match expected type ‘a -> Char’ with actual type ‘Char’
19:34:38 <lambdabot>      • Possible cause: ‘toUpper’ is applied to too many arguments
19:35:27 <barrucadu> You can also query lambdabot
19:35:41 <Cale> dolio: Yeah, the difference is really not so big
19:36:01 <Cale> dolio: also, the free monad is massively overhyped
19:36:58 <Cale> (of course still worth knowing about, but it gets a little absurd sometimes)
19:37:08 <barrucadu> Starfflame: But to understand why it's not working, think of the definition of (.): `f . g x` == `f (g x)`, so `ord . toUpper 'a'` == `\x -> ord (toUpper 'a' x)`. `toUpper` doesn't take two arguments.
19:37:28 <Cale> barrucadu: careful, that should be (f . g) x = f (g x)
19:37:33 <jle`> the fact that an ST monad transformer is possible is kind of ridiculous
19:37:35 <barrucadu> Cale: Whoops
19:37:38 <jle`> i don't know if i should use it for not
19:37:39 <Cale> f . g x means f . (g x)
19:37:39 <jle`> *or
19:37:51 <barrucadu> I should have just written it prefix
19:38:21 <Cale> jle`: Usually not...
19:38:22 <barrucadu> jle`: ST monad transformer?
19:38:52 <jle`> apparently it works by hacking GHC's unsafe state token
19:39:05 <jle`> but at this point i don't know if there's any way of doing what i want without it
19:39:37 <barrucadu> What do you want to do?
19:39:53 <Cale> ah, I don't know if that implementation will actually always work as a transformer
19:40:05 <jle`> it only works in the case w/o 'branching'
19:40:21 <dolio> Yeah, it's only safe for some monads.
19:40:37 <dolio> So it's worse than the old ListT, really.
19:40:44 <Cale> You could do one which was lawful using a vault
19:40:46 <Cale> ... I think
19:40:50 <jle`> cause the state token is just a reference to an actual mutable cell in memory
19:41:18 <jle`> if you wanted it to work with branching monads then you probably have to be able to duplicate it somehow
19:41:22 <dolio> Actually, maybe it's not worse, I don't know.
19:42:19 <notjack-rkt> hello!
19:42:20 <Cale> jle`: The RealWorld token isn't actually a reference to anything. It's just a 0-bit wide bit of trickery used to ensure that the dependency analysis keeps things organised in the right order when you go to evaluate these effectful functions.
19:42:42 <Cale> notjack-rkt: hello!
19:42:50 <jle`> hm
19:43:05 <notjack-rkt> I'm working on porting some lens stuff to Racket, and was looking for help with some questions on lens+prisms+traversals
19:43:06 <dolio> I wouldn't be surprised if it broke inlining/factoring, though.
19:43:32 <dolio> Depends on how lazy it is.
19:43:38 <Cale> notjack-rkt: sure
19:43:44 <jle`> i acutlaly don't even know if an ST transformer can help my problem
19:43:50 <Cale> notjack-rkt: That's going to be a little tricky without typeclasses...
19:44:32 <notjack-rkt> Cale: It certainly introduces a new set of problems :)
19:45:09 <notjack-rkt> Cale: I'm trying to work with a nested data structure that involves a hash and a key in that hash that may not be present
19:45:51 <notjack-rkt> Cale: I can use lenses to view the hash key-value as a Maybe, with Nothing indicating that the value is present
19:46:06 <notjack-rkt> Cale: But to go inside the Maybe I need prisms, which makes sense to me
19:46:35 <glguy> To "go inside" a Maybe, you need a Traversal
19:46:40 <notjack-rkt> Cale: What I don't get is why once I put prisms and lenses together, I get a traversal whose types indicate it could view zero, one, or many things. Why not something that views zero or one things?
19:46:54 <glguy> You need the full prism if you want to be able to construct a Maybe a from an a
19:47:15 <notjack-rkt> Why does working with lenses and prisms together end up introducing more than one view?
19:48:09 <glguy> Because a concept of "affine traversal" was experiemented with and didn't work out to be useful
19:48:53 <notjack-rkt> glguy: Could you elaborate?
19:50:06 <glguy> The typeclass you have to introduce into the mix to handle this zero/one case doesn't have the wide set of instances that Applicative does
19:50:21 <glguy> so it makes the resulting traversals less generally useful
19:50:38 <notjack-rkt> What about in an untyped context? I'm trying to figure out whether this could be useful in the Racket port of lenses, not in haskell-land
19:51:00 <Cale> notjack-rkt: Are you just passing dictionaries around by hand everywhere?
19:51:06 <glguy> Sure, in that context the whole system will be less useful
19:51:39 <glguy> So you might not be missing out on the same set of functionality that ubiquitous applicative instances offers
19:52:16 <notjack-rkt> Cale: At the moment the racket port only provides lenses and only handles very simple applications of lenses, there's not much need for dictionary passing
19:52:28 <Cale> But how do you represent the lenses?
19:52:32 <_sras_> How can I see the template haskell splices that are spliced into a external module?
19:52:49 <Cale> Are you using the van-Laarhoven encoding, or just a record of view/set
19:52:50 <Cale> ?
19:53:20 <notjack-rkt> They're opaque objects in a generic interface, so the encoding isn't visible to users. In that sense yes the lenses are basically a dictionary being passed around. Internally it's a view/set representation.
19:53:54 <Cale> The modern lens library has:  type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
19:54:01 <Cale> type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t
19:58:19 <notjack-rkt> Sure but racket lenses aren't exposed as functions in the van Laarhoven encoding, you just pass the lens to a `lens-view` function or a `lens-set` function.
19:58:36 <notjack-rkt> So the typeclassery and van Laarhoven encodings aren't super relevant to racket-land.
19:59:25 <Cale> It's harder to say what the abstract interface to Traversals would look like, in the sense that you have view and set for lenses.
20:00:36 <notjack-rkt> right that's something I'd like to figure out with this conversation
20:00:50 <notjack-rkt> prisms it's a bit clearer, it's just preview and review
20:01:01 <Cale> You have stuff like:
20:01:23 <Cale> :t \f (x,y) -> liftA2 (,) (f x) (f y)
20:01:25 <lambdabot> Applicative f => (t -> f b) -> (t, t) -> f (b, b)
20:01:53 <Cale> Which is a traversal which operates over both parts of a pair
20:03:27 <notjack-rkt> Cale: right that I understand
20:03:48 <Cale> and
20:03:49 <Cale> :t \f v -> pure v
20:03:51 <lambdabot> Applicative f => t -> a -> f a
20:04:10 <Cale> which is an empty traversal
20:06:29 <Cale> So I suppose if we had a class for pointed functors (i.e. functors f which had an operation a -> f a), we'd end up with something a little closer to traversals over 0 or 1 things in that way
20:06:30 <notjack-rkt> view seems easy enough to generalize into the abstract interface of traversal, but I'm not sure what `set` would look like - set each viewed item of the traversal all to the same value?
20:07:36 <Cale> Well, to set, we use the identity functor
20:07:53 <notjack-rkt> with the point in the pointed functor being used for the zero-items case?
20:07:56 <Cale> and if we're ignoring the values which were already there, we provide a constant function
20:08:22 <dolio> You don't view and set one thing with a traversal.
20:08:31 <Cale> @let myBoth f (x,y) = liftA2 (,) (f x) (f y)
20:08:34 <lambdabot>  Defined.
20:08:39 <dolio> You view n things and set n of them, where n is determined by the exact structure of the thing you're viewing/setting.
20:09:22 <notjack-rkt> dolio: which can't be changed I presume? as in setting n-1 or n+1 things would break
20:09:39 <Cale> > set myBoth 5 (1,2)
20:09:43 <lambdabot>  (5,5)
20:09:44 <dolio> Right. You have to set as many things as you view.
20:10:09 <notjack-rkt> dolio: How would that be different from a lens that views a list?
20:10:10 <dolio> Luckily in your case you don't have to worry about infinities. :)
20:10:15 <Cale> > myBoth (const (Identity 5)) (1,2)
20:10:18 <lambdabot>  Identity (5,5)
20:10:23 <Cale> > runIdentity (myBoth (const (Identity 5)) (1,2))
20:10:27 <lambdabot>  (5,5)
20:10:45 <dolio> A lens that views a list could change the size of the list, presumably.
20:10:57 <Cale> > myBoth (\x -> Identity (10*x)) (1,2)
20:10:59 <jle`> it's also...a different type
20:10:59 <lambdabot>  Identity (10,20)
20:11:13 <Cale> ^^ so you can map over the targets of a traversal in that way
20:11:18 <erisco> that never stopped a dynamic programmer
20:11:27 <Cale> (and that's what ultimately lets you set them)
20:12:08 <dolio> Lens is: s -> (a, a -> s) ; traversal is: s -> ∃n. (Vector n a, Vector n a -> s)
20:12:27 <notjack-rkt> dolio: In racket land there's no types so you'd enforce the size of the list dynamically
20:12:29 <dolio> For a type of statically sized vectors.
20:13:19 <dolio> Well, in that case, I suppose there's not much difference.
20:13:23 <Cale> notjack-rkt: Now what you could do is just give someone pure and (<*>) as arguments, and say "hey, do whatever"
20:13:28 <Cale> i.e. dictionary passing
20:13:59 <Cale> That might be preferable to having to produce a vector of them and be careful about the sizes
20:14:35 <notjack-rkt> Cale: I want something that spiritually matches the lens interface, which is basically just "construct a lens from this getter and this setter"
20:15:01 <dolio> notjack-rkt: There's also a funky nested type you can use. If you used something like that in Racket it might be closer. I'd have to think about what it is, though.
20:16:02 <tempeh> anyone happen to know the behavior of nix options in stack.yaml on machines without nix installed? just ignored, or error?
20:16:45 <notjack-rkt> If you throw the types out the window, what, conceptually, is the difference between a lens that views a maybe and a traversal that views zero or one elements?
20:16:53 <notjack-rkt> What can I do with one that I can't without the other?
20:17:25 <Cale> dolio, notjack-rkt: Right, either you're done and there are no more targets to replace, or you have another target, and you have a way to replace it which will give you another partially-completed traversal
20:18:29 <notjack-rkt> Cale: do you mean there isn't a difference in functionality between those two things?
20:18:39 <dolio> A lens that views a maybe can change a nothing to a just or vice versa. A traversal can't.
20:18:49 <notjack-rkt> ahhh, now I see
20:19:09 <notjack-rkt> So a traversal doesn't allow changing the number of elements while a lens viewing multiple things would
20:19:13 <Cale> wait
20:19:23 <Cale> Every lens is also a traversal
20:19:33 <dolio> notjack-rkt: Like, when I said that there 'wouldn't be a difference,' it'd be because you're blowing up if I give you the wrong number of elements.
20:20:03 <Cale> But you mean the traversal which actually digs in and gets you the argument to the Just, which wouldn't be a lens
20:20:17 <notjack-rkt> Cale: Yes
20:20:32 <notjack-rkt> I don't mean the traversal you get from a lens, I mean a traversal that is *necessarily* a lens because it digs into a maybe
20:20:52 <Cale> That necessarily fails to be a lens?
20:21:29 <notjack-rkt> Yes but I'm trying to work out how I'd use it in the nested-thing-in-hash-in-thing problem
20:21:39 <Cale> Here:  data PartialTraversal s a = Done s | More s (a -> PartialTraversal s a)
20:21:55 <Cale> So then a traversal will be a function   s -> PartialTraversal s a
20:22:17 <Cale> oops
20:22:17 <Cale> Here:  data PartialTraversal s a = Done s | More a (a -> PartialTraversal s a)
20:22:21 <Cale> (typo)
20:23:06 <Cale> So when you hit something of type s with this traversal, you're either going to get Done with some value of type s (there were no targets to traverse over)
20:23:43 <Cale> or you're going to get the first target, together with a function which will take the replacement and give you another partial traversal
20:24:33 <notjack-rkt> and in order to be total, you must assume you don't know how many targets you'll get
20:24:39 <Cale> yeah
20:24:56 <notjack-rkt> which is why you can set everything or map everything but not set a fixed N values
20:25:33 <Cale> Yeah -- well, you can be a bit "stateful" as you go
20:25:48 <notjack-rkt> right, but I can't assume count without becoming partial
20:26:00 <dolio> I'm not sure that type gives you all the power you'd have in a real traversal.
20:26:10 <Cale> It doesn't handle the type changing thing
20:26:26 <dolio> No, I mean, you have to feed in a value to see the rest of the traversal.
20:26:33 <Cale> hmm, that's fair
20:26:39 <dolio> It's really complicated to look ahead, at best.
20:26:42 <Cale> But wait
20:26:50 <Cale> Do you actually get to see that with a real traversal?
20:27:13 <notjack-rkt> keep in mind I don't need to handle type changing since, y'know, no types
20:27:24 <dolio> Yes, at least a finite one, I think.
20:27:43 <Cale> notjack-rkt: that's fair, but it still can matter ;)
20:27:43 <Cale> notjack-rkt: Your compiler doesn't have to care about types, but you do ;)
20:28:13 <notjack-rkt> Yes but I don't need to explain my reasoning to a `data` declaration :)
20:28:34 <Cale> dolio: I mean, you're going to see each of the targets via the function (a -> f b) you supply, and each one is obtained sort of in isolation, no?
20:29:46 <Cale> Only the Applicative machinery and the traversal itself gets to know the big picture
20:30:37 <Cale> We can of course count the number of targets or construct a list of them
20:30:38 <dolio> Cale: I think, consider that: /\b -> ∃n. a^n * (a^n -> b) is applicative.
20:30:47 <notjack-rkt> Right
20:30:56 <dolio> Where pure uses n = 0, and pair adds the ns.
20:31:20 <dolio> Dividing them between the two pieces.
20:32:20 <dolio> Then if you traverse with that applicative, you get a thing that lets you see all the as at once.
20:33:02 <Cale> hmmm
20:33:39 <Cale> Whereas the Applicative you need to use in my case is probably some horrifying Cont monstrosity ;)
20:34:33 <dolio> That type might not be exactly correct, but probably something along those lines works.
20:35:56 <Cale> (You could probably use recursion to determine the values to replace stuff with later, with some tying-the-knot style trickery)
20:36:15 <dolio> Yeah, maybe. I don't know if that works in Racket, though.
20:36:16 <Cale> But yeah
20:36:25 <Cale> Yeah, I don't know either :)
20:37:58 <Cale> oh, but what we *could* do is what you were perhaps hinting at earlier, and use type-changing recursion (which will probably be much harder to get right as a programmer in racket, but whatever)
20:38:28 <Cale> data PartialTraversal s a = Done s | More a (PartialTraversal (a -> s) a)
20:38:58 <Cale> Now you get the targets one at a time, and at the end, you get a function which takes all the replacements
20:39:06 <dolio> Yeah.
20:39:16 <dolio> That's probably the type I was thinking of.
20:39:55 <notjack-rkt_> Now that looks tricky :)
20:40:18 <dolio> Now I think that's wrong in Haskell, because it doesn't let you do the right thing for infinite cases.
20:40:31 <dolio> Infinite cases that would actually work.
20:40:43 <Cale> Yeah
20:40:47 <dolio> But it's good enough for what you'd expect to work in Racket.
20:41:18 <notjack-rkt_> So just to check that I understand right, that type essentially gives you a bunch of values incrementally with the last value being a function that constructs a new container given replacements for all the values seen so far, right?
20:41:26 <Cale> yeah
20:41:32 <Cale> in reverse order, as it happens ;)
20:41:41 <notjack-rkt_> Oh dear
20:41:51 <Cale> Well, not necessarily, but it makes the most sense like that
20:42:21 <Cale> (it'll be much easier to actually write things if stuff is curried that way)
20:42:22 <dolio> In racket you'd probably just use lists and say, "make sure the lengths match."
20:43:17 <Cale> yeah, to be fair, everything is already going to be unsafe no matter how we slice it
20:43:57 <Cale> Getting the lengths to match is not going to be any different in terms of difficulty (and may be a good deal easier) than lining things up with any of these other types
20:44:19 <notjack-rkt_> and the difference between that and a lens that views a list is that with the lens, you'd either have to _always_ view exactly N elements and enforce setting N elements, or allow the setter to change the number of elements, but a traversal lets you view N and set N where N could depend on what the traversal is used on
20:44:47 <Cale> yeah, that's pretty much it
20:45:18 <dolio> A lens that views a list would be expeted to make sense of things if you give back a list of a different length.
20:45:31 <notjack-rkt_> Right
20:45:56 <notjack-rkt_> whereas a lens that views an N-tuple would always view the same number of elements regardless of what target you give it
20:46:19 <Cale> yeah
20:47:17 <Cale> notjack-rkt_: It's almost a separate axis of multiplicity -- it's mildly confusing to compare it that way
20:47:26 <dolio> I guess if everything is untyped, it doesn't make a lot of sense to say that a traversal can give you a different size n-tuple for each value of the type, where a lens cannot.
20:47:43 <dolio> But that's another way of viewing the difference.
20:48:13 <Cale> > myBoth (\x -> [x,10*x]) (1,2)
20:48:16 <lambdabot>  [(1,2),(1,20),(10,2),(10,20)]
20:48:19 <dolio> Well, give and only-accept.
20:48:31 <notjack-rkt_> I'll be using contracts instead of types, so it does make a little sense
20:48:48 <dolio> Okay.
20:50:18 <Cale> > both (\x -> x <$ guard even) (1,2) :: Maybe (Int, Int)
20:50:20 <lambdabot>  error:
20:50:21 <lambdabot>      • Couldn't match expected type ‘Bool’
20:50:21 <lambdabot>                    with actual type ‘Integer -> Bool’
20:50:25 <Cale> err
20:50:37 <Cale> > both (\x -> x <$ guard (even x)) (1,2) :: Maybe (Int, Int)
20:50:39 <lambdabot>  Nothing
20:50:43 <Cale> > both (\x -> x <$ guard (even x)) (4,2) :: Maybe (Int, Int)
20:50:46 <lambdabot>  Just (4,2)
21:50:05 <jle`> i build up an intricate graph using STRefs, is there any way i can freeze and duplicate this and resume an ST computation on it ;_;
22:11:46 <glguy> You can switch to IORefs
22:12:06 <glguy> or without switching you can use stToIO
22:13:05 <glguy> or depending on what it means to freeze and resume, you can make a newtype SomeST a = SomeST (forall s. ST s a) and stash that somewhere
22:13:21 <glguy> delaying the eventual "runST"
22:17:32 <wizard1337> you guys are awesome
22:25:45 <wizard1337> so is it possible to engineer CPUs so that they are more friendly to executing languages closer to haskell
22:26:36 <centril> wizard1337: I think the fundamental problem is the heap - iirc, everything in haskell lives on the heap
22:26:39 <centril> the heap is slow
22:26:55 <johnw> well, you could burn chips that run the GC algorithm
22:27:38 <wizard1337> i am actually interested here in the non-GC aspects of execution
22:28:04 <centril> Well... the GC aspects are mostly what is important...
22:28:38 <wizard1337> but not specific to haskell
22:28:52 <centril> the fact that haskell uses thunks and currying means functions and arguments or the thunks must be put on the heap
22:29:10 <centril> the indirection makes things slow
22:31:30 <wizard1337> so lazy eval, also?
22:31:49 <jle`> glguy: the graph is 'built' in ST, so something like SomeST would bascically require the graph to be built from scratch every time it is resumed
22:32:19 <glguy> yes
22:32:34 <glguy> you wouldn't resume it more than once
22:34:37 <nshepperd> maybe you could make chips with a caching model better suited to 'tons of pointers on the heap'
22:34:45 <nshepperd> although I can't really imagine how
22:39:08 <wizard1337> Jamie Zawinski, an author of Mozilla: "In a large application, a good garbage collector is more efficient than malloc/free."
22:39:09 <wizard1337> heh
22:45:03 <Cale> wizard1337: Have you seen the Reduceron?
22:45:30 <Cale> https://www.cs.york.ac.uk/fp/reduceron/
22:45:40 <Cale> https://vimeo.com/15832032
22:52:06 <wizard1337> heh
22:53:07 <piyush-kurur> raaz-version 0.1.0 uploaded to hackage thanks
22:53:45 <piyush-kurur> feedbacks, pull requests always welcome
23:21:13 <bollu> does anyone here have experience with Coq? I was wondering what the "correct" way to encode a theory is
23:21:19 <bollu> should I create a typeclass for it?
23:21:24 <johnw> bollu: what's the theory?
23:21:25 <bollu> or is there a notion of a theory in Coq?
23:21:53 <johnw> modules are also an option
23:22:02 <bollu> johnw: right now, S5 (modal logic)
23:22:09 <johnw> better to ask in #coq
23:22:10 <bollu> johnw: I plan on encoding a game theory logic called SDGL
23:22:11 <bollu> I see
23:22:29 <bollu> johnw: I have tried #coq before, but I've found that #haskell is always more active ;)
23:22:40 <johnw> yes, but it's also not a Haskell question
23:22:57 <bollu> fair point
23:47:55 <warrshrike> hey guys
23:48:11 <warrshrike> so im trying to use a haskell based package but having trouble :/
23:48:19 <warrshrike> here are the instructions https://github.com/travitch/llvm-tools
23:48:28 <warrshrike> but cabal just errors out like this
23:49:07 <warrshrike> http://lpaste.net/353018
23:49:42 <warrshrike> last line for those too lazy (no pun intended) to open link Backjump limit reached (change with --max-backjumps).
23:49:55 <warrshrike> any idea?
23:55:23 <`Guest00000> hello
23:55:30 <`Guest00000> what is the state of float consistency?
23:55:37 <warrshrike> Anyone?
23:56:37 <liste> warrshrike: what ghc do you have?
23:57:21 <warrshrike> liste: The Glorious Glasgow Haskell Compilation System, version 7.10.3
23:58:07 <liste> warrshrike: did you install anything else with cabal before that?
23:58:49 <liste> warrshrike: I guess you should open a github issue
23:59:44 <warrshrike> liste: I did not..
