00:00:01 <warrshrike> no simple thing im missing?
00:00:08 <warrshrike> i may have installed stack before
00:00:16 <liste> warrshrike: the transitive versions of the dependencies have probably changed since the instructions in that README were published, could be that the project doesn't build anymore
00:00:17 <warrshrike> yeah i still have stack
00:01:09 <warrshrike> hmm
00:01:14 <warrshrike> ~_~
00:01:18 <liste> warrshrike: the project's dependencies are installed with "git clone" without a specific version number, that's bound to be out of sync at some point
00:01:54 <liste> warrshrike: the correct fix would be for the author to pin the dependencies to specific version bounds
00:02:40 <warrshrike> liste: true. but all the repos belong to the same author. i guess il try to individually install them one by one. would that help?
00:03:21 <liste> warrshrike: no
00:03:36 <warrshrike> liste: damn. why not?
00:04:45 <liste> warrshrike: because that doesn't solve the version conflict between dependencies
00:06:51 <warrshrike> liste: got it. I emailed the dude lets see i guess
01:11:11 <bollu> offtopic: if someone could show me how to write this more idiomatically, it would help a lot :) It's an encoding of some simple group theory theorems in Coq (http://lpaste.net/353019)
01:13:37 <JOCG> hi
01:15:28 <eklavya> hi, I need marketing stuff to sell Haskell to management, any pointers, please?
01:18:46 <liste> eklavya: what kind of company/team?
01:19:36 <liste> eklavya: higher-ups love references, you should tell them where it's used
01:19:54 <liste> eklavya: so eg http://industry.haskell.org/partners and https://wiki.haskell.org/Haskell_in_industry
01:19:57 <eklavya> they are asking me that if a client comes up, what should they tell them for "why use haskell?", or which clients to pursue
01:20:09 <liste> success stories
01:20:28 <liste> also, if they're competent managers, data
01:20:44 <liste> but I think many are more interested in stories nowadays
01:21:02 <eklavya> I don't even know how serious they are
01:21:16 <eklavya> but there is no harm in trying, right? :)
01:21:40 <liste> marketing has little to do with the subject matter anyway
01:22:13 <eklavya> when they asked me, I was like, "well it's a programming language, so you can make anything you want with it"
01:22:16 <eklavya> and it's good
01:22:21 <eklavya> but
01:22:22 <eklavya> :D
01:22:33 <liste> clients usually don't care, unless they have an existing system
01:22:42 <liste> or other suppliers
01:22:44 <eklavya> yeah
01:23:03 <liste> and if you use Haskell, you lock them in to non-shitty vendors :D
01:23:12 <eklavya> :D
01:24:05 <eklavya> "Haskell has a diverse range of use commercially, from aerospace and defense, to finance, to web startups, hardware design firms and a lawnmower manufacturer."
01:24:05 <liste> with PHP, if the client wants changes to the software, they can get more or less (usually less) what they want from some sweat shop in India
01:24:23 <eklavya> I think the author shares my wtf response
01:24:46 <eklavya> uhhhmm I am from India
01:24:54 <liste> eklavya: but you're not in a sweat shop?
01:25:24 <eklavya> are you amazed/asking/..? :D
01:25:39 <liste> eklavya: no, I'm assuming (because you're in #haskell)
01:26:07 <eklavya> nope so many Indian engineers don't work in sweat shops
01:26:28 <liste> and that's good
01:30:50 <tdammers> php and haskell are extreme ends
01:30:51 <liste> but there's a certain "race to the bottom" culture in some areas of software development
01:31:07 <tdammers> php locks you into the lower part of the quality spectrum, haskell into the upper
01:31:42 <eklavya> wow, we are a modest bunch :D
01:31:52 <rrrrrrrr025> hi all! can anyone help me with stack? 
01:32:33 <sm> from the point of view of users, php devs have produced a lot more high quality sw than haskellers :)
01:32:40 <tdammers> eklavya: I didn't mean this as "we write better code"; I meant it as "PHP optimizes for the mass market, Haskell sacrifices mass marketability for higher quality"
01:32:58 <tdammers> sm: most users haven't seen high quality software ever
01:33:00 <rrrrrrrr025> I'm trying to have different versions of ghc via stack on ubuntu 16.04.1. So I installed stack via apt and created the project via "stack new simple"
01:33:08 <sm> I think that's pretty arrogant
01:33:15 <tdammers> not at all
01:33:20 <dtornabene> bollu: what group thereoms were you trying to encode?
01:33:43 <rrrrrrrr025> and now every time I write "stack build", I'm getting an error "Invalid package ID: "array-0.5.1.1 base-4.9.1.0 binary-0.8.3.0 bytestring-0.10.8.1""
01:33:43 <tdammers> it's just that given the current state of the software market, high quality software is not generally feasible, because it's not profitable enough
01:34:01 <liste> eklavya: there's much higher barrier of entry for Haskell, which means that using Haskell requires more work, so people who want to get stuff done with the least amount of work probably won't use it
01:34:21 <liste> eklavya: so it's not about skill or intelligence, just motivation
01:34:21 <bollu> dtornabene: for now? just the simple stuff: left and right cancellation, uniqueness of inverse
01:34:36 <bollu> dtornabene: I will maybe get to subgroups, quotient groups
01:34:41 <eklavya> liste: I don't agree, I use haskell exactly because I want least effort for maximum returns
01:34:46 <bollu> (showing that the quotient group is actually a group)
01:34:50 <tdammers> I'd say haskell is heavily optimized for experienced programmers and people willing to invest a lot upfront
01:34:51 <bollu> dtornabene: but my current frustration
01:34:55 <bollu> is that it feels artifical
01:35:06 <tdammers> (on an overall career scope, that is)
01:35:09 <bollu> dtornabene: it feels like I am arguing "backwards" so to speak
01:35:11 <liste> eklavya: but you had to learn Haskell properly before doing that?
01:35:12 <dtornabene> bollu: don't want to lead you on, I can't help you (don't know Coq, my g-theory is....weak) but I was curious
01:35:16 <bollu> ah, OK :)
01:35:37 <bollu> tdammers: I somhow disagree, I was a teenager when I decided to pick up haskell with no career to speak of in the first place :P
01:35:41 <dtornabene> funny enough I was able to parse bits and pieces from that code, should make you feel better :)
01:35:46 <bollu> tdammers: I'd say mathematical inclination
01:35:49 <bollu> dtornabene: heh, yes it does :)
01:35:56 <tdammers> bollu: yeah, that works too
01:36:25 <tdammers> bollu: speaking for myself, however, if you had showed me Haskell at age 12, I would have gone "wut? why do I need this, C works perfectly fine"
01:36:27 <dtornabene> bollu: whats the application (or is there one) if you don't mind my asking?
01:36:50 <tdammers> right now however, I consider Haskell the easiest of all the programming languages I know
01:36:59 <liste> eklavya: I'm talking about people with weeks or months of training
01:37:05 <dtornabene> bollu: meaning, what are you trying to do with this group theory in Coq
01:37:41 <bollu> dtornabene: oh, I am trying to encode a particular kind of logic (SDGL) which is used for modelling games 
01:37:46 <sm> tdammers: I know what you mean, but that's quality from a software developer/computer scientists's point of view. Software Users have a different measure of quality and to them the picture looks very different
01:37:50 <bollu> like, turn based n player games 
01:37:53 <bollu> but to do this
01:38:02 <bollu> I'm trying to understand how to encode theories in Coq in the first palce
01:38:04 <bollu> place(
01:38:06 <bollu> place**
01:38:07 <dtornabene> bollu: interesting! 
01:38:10 <bollu> yeah :D
01:39:18 <eklavya> tdammers: I would agree
01:39:24 <dtornabene> bollu: trying to google that acronym, not finding anything, what does SDGL stand for?
01:39:54 <bollu> dtornabene: look for the paper: Strategies made explicit in Dynamic Game Logic 
01:40:06 <eklavya> liste: picking up haskell was easy but I am starting to believe that I would never (or for a long long long time) be an expert in it
01:40:31 <eklavya> liste: but I can already do whatever I want without much trouble so maybe that is not necessary?
01:41:04 <bollu> tdammers: yeah, I think I saw haskell when I was.. 17. So I guess that helps
01:42:11 <bollu> eklavya: which Haskell company are you from in India?
01:42:21 <bollu> eklavya: I think I know of 3 in all of india :P
01:42:44 <eklavya> bollu: it's not an haskell company, I am an odd one out :D
01:42:49 <bollu> eklavya: ah, OK
01:42:57 <eklavya> they are good enough to let me play though :P
01:43:02 <bollu> eklavya: that's quite nice
01:43:16 <bollu> eklavya: hm, I'm an undergrad, and I would hate to have to go out and write non FP code
01:43:44 <eklavya> oh that is not a problem for me, I would just write Scala instead of Haskell
01:44:10 <eklavya> although in Scala I don't do proper Monadic stuff becasue it doesn't feel natural 
01:44:35 <eklavya> but it's expressive and FP enough
01:45:08 <eklavya> bollu: by the way, which 3 companies use Haskell in India?
01:45:49 <bollu> eklavya: Hasura, the company that writes Eta (Typelead IIRC) and a company called VacationLabs	
01:45:55 <tdammers> sm: I'm talking about quality in the sense of "it does what it is supposed to do, it doesn't do what it's not supposed to do, and usability and performance are good"
01:46:12 <eklavya> bollu: thanks :)
01:46:15 <bollu> eklavya: np :)
01:46:20 <bollu> eklavya: there maybe other places using Haskell
01:46:38 <bollu> eklavya: but I am unaware of them
01:47:18 <bollu> eklavya: where do you work, if you don't mind me asking
01:47:25 <eklavya> I wonder if Hasura is "Haskell" + "Asura"
01:47:46 <bollu> eklavya: I think so yeah
01:47:50 <eklavya> bollu: Pramati
01:48:12 <liste> eklavya: yeah, sounds like it's not necessary, there's so much capabilities in Haskell that at some point in skill it's like you'd be using some other language, but the difference is that in that other language you'd have no more ways to make the code better but in Haskell there is
01:48:28 <bollu> eklavya: oh, you're at hyderabad, neat! I'm at IIIT-H :)
01:49:22 <eklavya> nope, pming you (don't want to hijack)
01:51:30 <eklavya> liste: yeah, with haskell so so many
01:52:09 <eklavya> although I only bother when benefit/weight is worth it
02:39:20 <flxw> Hi, it's the second time I stepped into the trap of working with old code loaded into interactive-haskell-mode. ghc just wouldn't update the implementation of a function (interfaces was unchanged), even though I saved the file with C-x C-s and then reloaded it with C-c C-l into the interactive ghc prompt. The only thing that helped was to restart the ghc process. Am I doing something wrong, or missunderstanding how haskell-mode w
02:40:44 <runeks> Is there a way to get GHC to print out the location of a <<loop>>, without having to enable profiling? 
02:40:58 <runeks> When I enable profiling, the <<loop>> exception turns into an infinite loop that doesn't respond to Ctrl-C.
03:15:37 <quchen> runeks: Did you try hitting ^C lots of times?
03:15:42 <quchen> It’s my usual solution.
03:16:06 <quchen> I think newer GHC versions give you a stack trace instead of <<loop>>, no?
03:17:24 <quchen> Hm, nevermind, it does not.
03:18:14 <merijn> quchen: Sounds like something that'd make a good feature request?
03:18:54 <runeks> quchen: I just got lucky, while having +RTS -xc turned on. You pinged me at exactly the right time, I think.
03:19:05 <runeks> I spit out a backtrace and I think I found the issue
03:19:16 <runeks> *It spit out
03:19:22 <quchen> Ahaaa!
03:19:27 <runeks> :)
03:19:45 <quchen> Thanks for asking and then answering it. I’m sure this will help me in the future :-)
03:20:36 <runeks> I think the key, perhaps, is to press Ctrl-C with profiling enabled, and +RTS -xc, but before it becomes unresponsive, which seemingly takes a little while.
03:21:46 <quchen> Do <<loop>>s ever allocate?
03:22:09 <quchen> At least »main = main« never allocates
03:22:19 <quchen> And I don’t think other loops might
04:17:51 <_sras_> What is the stack configuration to make the -ddump-splices to write to a file instead of to the ghci?
04:20:35 <MarcelineVQ> hmm in my experience, stack dumps to file by default, I wish you could tell it otherwise in fact. are you sure they're not just someplace weird? where do you pass that option?
04:21:13 <oisdk> Is there any way to define the liftAn family of functions on restricted monads without using (>>=)? (restricted as in https://hackage.haskell.org/package/rmonad)
04:22:55 <_sras_> MarcelineVQ: I just set the -ddump-splices option from ghci
04:23:59 <oisdk> I've got a restricted monad which has a more efficient liftA2, liftA3, etc than the bind counterparts, but it can't use (<*>) because it can't store function types. I'm wondering if there's a way to use applicativedo notation somehow.
04:24:08 <_sras_> MarcelineVQ: Got it!
04:24:08 <cocreature> _sras_: there is -ddump-to-file but I’m not sure if that works from inside ghci
04:24:49 <MarcelineVQ> I'm also not sure when ddump-to-file applies for splices, souinds like _sras_ got it though
04:24:51 <_sras_> Yes. I found it. I was looking to a file with .th extension. But the file generated are with a .splice extension
04:25:05 <MarcelineVQ> nice
04:25:42 <MarcelineVQ> one thing to watch out for is that with dumping and using ghci at the same time it might shove everything into your source directories, it did for me anyway :>
04:26:21 <MarcelineVQ> it can get a little messy, not usually an issue but something to watch for
04:26:42 <_sras_> MarcelineVQ: It dumps everything to a path under .stack-work.
04:27:17 <MarcelineVQ> that's good then
04:27:47 <MarcelineVQ> I think I had -ddump-to-file set in my .cabal file and when I ran ghci it made a bit of a spew into my src/ dir
04:28:15 <MarcelineVQ> Could be a solved thing by now.
04:34:55 <lyxia> oisdk: I think you can redefine <*> adequately with some typeclass shenanigans
04:35:03 <lyxia> oisdk: what does your type and liftAn look like
04:35:26 <lyxia> Must liftAn be individually defined by hand
04:37:59 <fendor> is there a way to cleanly uninstall all packages from cabal and start over with a fresh installation?
04:38:21 <merijn> fendor: Which OS?
04:38:27 <fendor> solus 
04:38:30 <dcoutts> fendor:  rm -fr ~/.ghc ~/.cabal
04:38:34 <merijn> ^^
04:38:37 <oisdk> Yeah, each liftAn has to be written by hand currently. I can write a function which works on heterogeneous lists (https://gist.github.com/oisdk/a29fbbc0f5e94720d062f57389ff8c30) and define all of the applicative operations from that, but I'm wondering if there'a a better way
04:38:38 <fendor> ok, did that, did not work
04:39:09 <fendor> i mean, installing stack by cabal install stack did not work in Solus, but this seems to be a problem with the OS 
04:39:10 <dcoutts> fendor: then you'll have to be more specific, since that does remove all the state
04:39:30 <cocreature> there can be packages in /usr/lib/ghc-$version
04:39:30 <fendor> some c - librarys seem to be faulty
04:39:33 <dcoutts> ok, so you're talking about stack rather than cabal
04:39:56 <fendor> well, maybe, i'm not sure, i'm trying to install stack via cabal
04:40:15 <cocreature> fendor: what is the problem you’re seeing that makes you think that the problem is a non-clean package database?
04:41:26 <fendor> i can't show the output right now, wrong device, but the installation fails, sometimes with the hint, that a library is missing, for example #include <limits.h> cant be found 
04:41:47 <cocreature> limits.h is a c header, that has nothing to do with cabal
04:41:49 <lyxia> oisdk: I think you can redefine <*> to wrap your arguments in a sort of free applicative, and then apply the right version of liftAn at the end.
04:42:36 <fendor> and such libraries 
04:43:28 <cocreature> fendor: I think you really need to show us the exact output for us to be able to help you
04:43:35 <fendor> ok, gimme a sec
04:44:06 <cocreature> (please use something like http://lpaste.net/ and don’t start pasting a wall of text here)
04:45:49 <fendoer> https://hastebin.com/exanucasez.sql
04:46:15 <fendor> posted it from another device
04:46:35 <cocreature> alright, that does look like a cabal problem. are you sure that you have cleaned up ~/.ghc?
04:46:56 <cocreature> if so, what ghc & cabal version are you using?
04:48:27 <fendor> GHC: 8.0.1 
04:48:35 <fendor> cabal-install 1.24
04:48:43 <dcoutts> fendoer: are you quite sure you removed ~/.ghc ?
04:48:56 <fendor> yes, i am, but i can redo it, to be sure
04:49:10 <dcoutts> after that, does ghc-pkg list show any packages marked as broken?
04:49:32 <oisdk> lyxia Looks like this might work. Thanks!
04:50:00 <fendor> well, ghc is marked blue, the rest is white, and no packages claims to be broken
04:50:10 <dcoutts> that's ok then
04:51:08 <dcoutts> fendor: and just to check, that list does not include 'text' right?
04:51:38 <fendor> it does, text-1.2.2.1
04:51:55 <fendor> this might be from the package manager of solus
04:52:07 <cocreature> fendor: what directory does ghc-pkg list for text?
04:52:12 <dcoutts> ok, well that's the one your build log is complaining about
04:52:16 <mohsen_> -/quit
04:52:34 <fendor> ok, so, maybe cabal is biting itself because of the OS package manager?
04:52:53 <dcoutts> fendor: certainly it will try to use the one your OS package manger installed
04:53:02 <dcoutts> and if that one is busted then...
04:53:45 <suppi> can i suggest downloading a stack binary instead?
04:54:22 * dcoutts increasingly thinks that cabal ought to take the approach of not using any Hs libs installed by OS package managers
04:55:20 <fendor> well, if it worked out correctly, the would be incredible easy to install packages and not having any struggles with cabal
04:55:46 <cocreature> dcoutts: yes please!
04:55:54 <fendor> a stack binary would probably do fine, but it just bugs me, that it does not work
04:56:02 <suppi> fendor: why not download a stack binary? why install via cabal?
04:56:10 <suppi> oh
04:56:40 <dcoutts> stack will have the same problem if you have stack using your system ghc of course
04:56:55 <suppi> then don't :)
04:57:18 <fendor> so, solution: dont use the package manager?
04:57:44 <dcoutts> there are often good reasons to use the system package manager
04:57:47 <suppi> the os one for installing stack?
04:57:59 <cocreature> fendor: what exactly have you installed via your package manager? maybe it provides a package that contains just ghc and not additional packages like "text"
04:58:21 <suppi> it's probably not a problem. i uses the os one to install stack
04:59:04 <fendor> the os does not provide a package for stack, i submitted the suggestion to do so, but currently i cant install it via the package manager
04:59:40 <fendor> cocreature: i actively installed packages like text via the package manager, so it seems to be the problem
04:59:41 <suppi> so yeah, don't use it if you can't...
04:59:55 <cocreature> fendor: in that case, just uninstall them :)
05:00:15 <cocreature> installing ghc via the package manager is fine, installing other haskell packages via the package manager is usually not worth the trouble
05:05:02 <fendor> yeah, i see
05:05:07 <fendor> doing that right now 
05:05:27 <fendor> *sigh* why does this not work?
05:05:39 <cocreature> uninstalling does(’t work?
05:06:16 <fendor> no, packages via the package manager? i removed everything except for the cabal package of Solus, and it is building right now, seems to work, but dont know yet
05:07:50 <cocreature> the problem is that you can easily get into a situation where you need a different version of a package than the one provided by your package manager. however if a package is installed into the global package database (as done by the package manager) that package is always available so you can’t just install a different version since they would conflict. In your particular case the packages provided by
05:07:52 <cocreature> your package manager also seem to be broken which might be the fault of the distribution
05:08:09 <suppi> no one writing a library wants to write and maintain a package for every package manager out there
05:08:53 <fendor> so it is indeed a bad idea to use a package manager for the packages used by a language, in this case haskell?
05:09:06 <hpc> sometimes
05:09:13 <suppi> imo, definitely
05:09:22 <hpc> if you know ahead of time that you are never going to need anything the OS doesn't provide, it's safe to use just packages
05:09:32 <hpc> mixing is what causes trouble
05:09:50 <hpc> so for instance, if you didn't intend to do any haskell development at all and just wanted pandoc
05:09:56 <fendor> so, either the packages manager needs to be more exhaustive or dont use it at all? what a pity...
05:09:57 <Clint> fendor: i use packages exclusively
05:10:00 <hpc> that's fine to get from the package manager instead of building it yourself with cabal
05:10:18 <hpc> but you get a sudden urge to write some code and now you need to cabal install lens or something
05:10:18 <cocreature> fendor: I usually tend to use the packages provided by the package manager if I want to use a package written in a language but not hack on one myself. in the latter case I ignore the system package manager
05:10:53 <hpc> and now you're screwed, because cabal isn't able to control how the pre-packaged packages are built
05:11:23 <fendor> so in short if i want to develop with haskell, i cant use the os package manager?
05:11:28 <hpc> stack solves the problem by working around it entirely, and managing its own everything
05:11:33 <fendor> just if i want to execute some code?
05:11:43 <suppi> just use stack with haskell
05:11:49 <dcoutts> fendor: I think typical practice is to install ghc via system package manager, but nothing else
05:11:59 <hpc> fendor: you can, but it leads to trouble when you try to do certain things
05:12:02 <hpc> and it's not worth the trouble
05:12:26 <dcoutts> fendor: because then by using cabal or stack you can control exactly what versions of haskell packages are used for everything else, including choosing different versions for different projects
05:12:27 <hpc> install ghc and cabal from the package manager and use those to install the rest
05:12:41 <dcoutts> right, ghc + cabal
05:12:43 <hpc> or install stack and use that to manage everything separately
05:12:44 <Clint> fendor: you'll be fine mixing if the cabal-installed stuff are leaf nodes, otherwise you will encounter dependency hell
05:13:07 <hpc> or use OS-packaged packages and be totally out of options when you need something that's not already packaged
05:13:11 <suppi> or stack and let it install and manage everything else you need
05:13:25 <suppi> including ghc
05:13:29 <hpc> stack is a good default choice
05:13:56 <hpc> in addition to just avoiding this problem outright, you get reproducible builds, which are pretty handy
05:14:21 <fendor> ok, so, it might be a reasonable choice, the remove the haskell packages completely from the software manager?
05:14:36 <hpc> stack also lets you use multiple versions of ghc at the same time
05:14:47 <fendor> yeah, i know, i tried to install stack, thats where i encountered the problem :D 
05:14:49 <recur22> dose anyone know if there is c to haskell translator?
05:14:55 <hpc> you don't even have to remove your OS-level packages either, is another nice thing
05:15:07 <hpc> stack tracks its stuff separately
05:15:27 <hpc> recur22: what you probably want instead is the FFI?
05:15:57 <fendor> yeah, i know, i use stack with my haskell development, i tried a new Os (Solus) and now i'm trying to get it to work 
05:16:07 <recur22> similer maybe to `corrode` c to rust  
05:16:20 <hpc> that would be a question for another channel
05:17:33 <fendor> well, stack seems to work for now, thx guys, i'm a little disappointed in the package manager now, but whatever, thanks guys!
05:19:26 <recur22> hpc: no ffi, i'm looking for translation from code to code
05:20:31 <cocreature> recur22: I don’t think a C to haskell translator makes a lot of sense. rust is a lot closer to C so you can actually get to somewhat reasonable rust code but turning C code into somewhat decent Haskell code is a nontrivial translation
05:20:44 <recur22> i tried ffi, I'd rather rewrite 
05:27:11 <recur22> i have large code base in c, dose anyone tried to hire for rewrite?
05:29:08 <recur22> it would better if it was written in haskell
05:40:58 <recur22> has anyone interested in porting open source c  to haskell
05:41:52 <ski> perhaps you'd have more luck if you were more specific about the project
05:41:56 <ski> (or perhaps not)
05:42:41 <merijn> It also, presumably depends on how much you're paying :p
05:43:47 <recur22> i would love  to pay my contribution to open source
05:47:21 <recur22>  there are some good c library that I'm intersted and i like to see them in haskell code
05:47:23 <piyush-kurur> eklavya bollu: https://indian-curry.github.in and drop in ##indian-curry if you are interested
05:47:26 <Tuplanolla> We could do with "SymPy but better", recur22.
05:49:12 <recur22> Tuplanoll: didnt get it!
05:50:17 <Tuplanolla> Symbolic algebra without the woes of an imperative language, recur22.
05:53:23 <cocreature> recur22: is there any specific C library you have in mind?
05:53:43 <Athas> glibc!
05:53:51 <recur22> yes
05:53:58 <juri_> libc5. :)
05:54:30 <juri_> parts of VLC would be neat to see.
05:54:58 <recur22> is it big yes, will you be intersted in i doubt it
05:55:19 <cocreature> it’s hard to say whether you’re interested in something you don’t know
06:17:16 <bpa2> If I do a simple input/output programme: main :: IO () main = do putStr "Enter a string: " xs <- getLine putStr "The string has " putStr (show(length xs)) putStrLn " characters". Then the request for input does not appear, but if I enter the string then the request for input appears afterwards. I expect the solution is simple but this newbie does not know it.
06:18:16 <Hafydd> bpa2: I imagine that is because the output is line-buffered.
06:19:10 <Hafydd> bpa2: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.9.0.0/System-IO.html#g:12
06:21:18 <Hafydd> So the solution could be to either change the underlying file, to use "hFlush stdout", or to use hSetBuffering
06:21:37 <Hafydd> or to use "hSetBuffering stdout NoBuffering".
06:40:34 <kubunto> are eithers biased in haskell
06:41:12 <locallycompact> what does that mean?
06:41:24 <kubunto> locallycompact: left is wrong, right is right
06:41:50 <kubunto> or left is fail, right is success
06:42:39 <locallycompact> Either a b is just a type, but the default Functor implementation chains via the right hand type, if that's what you mean
06:42:45 <bpa2> Thank you Hafyddh SetBuffering stdout NoBuffering did the trick.
06:43:12 <mniip> performance wise they are unbiased
06:43:20 <locallycompact> so you can have a functor instance for Either String a
06:43:39 <mniip> locallycompact, nit: without the a
06:43:59 * locallycompact shames
06:45:28 <kubunto> locallycompact: functor?
06:45:37 <kubunto> still wrapping my head around the term
06:45:45 <kubunto> for sake of argument say i have Right(8)
06:46:22 <locallycompact> so you can do
06:46:24 <locallycompact> let x = Right 8
06:46:36 <locallycompact> show <$> x
06:46:41 <locallycompact> becomes Right "8"
06:46:52 <locallycompact> which is equivalent to `fmap show x`
06:47:39 <locallycompact> getting the intuition for Functor is crucial
06:47:54 <kubunto> fmap is to monads as map is to collections?
06:48:03 <locallycompact> no monads here
06:48:07 <fendoer> fmap is to functors
06:48:24 <locallycompact> right, map is a special case of fmap that only applies to lists
06:48:33 <locallycompact> the implementation is literally
06:48:36 <locallycompact> instance Functor [] where
06:48:38 <locallycompact>   fmap = map
06:49:04 <locallycompact> so say you have a type representing a Graph that carries a type 'a' for its nodes
06:49:09 <locallycompact> and you know it's a functor
06:49:24 <locallycompact> you can just turn all the 'a's into 'b's with fmap without changing the structure of the graph
06:49:47 <locallycompact> one example I like is
06:50:07 <locallycompact> {-# LANGUAGE DeriveFunctor #-}
06:50:14 <locallycompact> data Vec3 a = Vec 3 a a a deriving (Show, Functor)
06:50:18 <locallycompact> sorry
06:50:21 <locallycompact> data Vec3 a = Vec3 a a a deriving (Show, Functor)
06:50:29 <locallycompact> then you can do
06:50:33 <locallycompact> let x = Vec3 1 2 3
06:50:40 <locallycompact> fmap (+1) x
06:50:47 <locallycompact> -- Vec3 2 3 4
06:51:13 <locallycompact> fmap show x
06:51:15 <kubunto> i just tried to put data Vec3 a = Vec3 a a a deriving (Show, Functor) into ghci and it didnt like it
06:51:40 <locallycompact> you have to
06:51:41 <locallycompact> :set -XDeriveFunctor
06:52:29 <kubunto> sry for interupting
06:52:42 <locallycompact> did it work?
06:52:49 <kubunto> yes
06:53:14 <locallycompact> so the type signature for fmap in that instance is
06:53:25 <locallycompact> fmap :: (a -> b) -> Vec3 a -> Vec3 b
06:53:32 <locallycompact> just runs the a -> b on every element on the Vec3
06:53:47 <locallycompact> and the compiler is clever so it can derive it
06:54:13 <locallycompact> so you know that whenever you have a functor you can change the carrying type without changing the ambient data structure
06:54:30 <locallycompact> [a], Maybe a, Vec3 a, Graph a, IO a
06:54:57 <locallycompact> so
06:55:10 <locallycompact> in the case of Either
06:55:19 <locallycompact> Either takes two types which is no good for functor
06:55:25 <locallycompact> Either a b = Left a | Right b
06:55:39 <locallycompact> so you make an instance which prespecifies the Left type
06:56:04 <locallycompact> so for example `Either String` is a valid functor that leaves one type variable open to modify
06:56:10 <locallycompact> let x = Right 8
06:56:16 <locallycompact> fmap (+1) x
06:56:17 <locallycompact> -- Right 9
06:56:31 <locallycompact> let y = Left "foo"
06:56:34 <locallycompact> fmap (+1) y
06:56:36 <locallycompact> -- Left "foo"
06:56:53 <lep-delete> > let x = Right 8 in fmap (+1) x
06:56:56 <lambdabot>  Right 9
06:57:17 <locallycompact> oh handy
06:57:20 <locallycompact> does it do derive functor
06:57:29 <locallycompact> > data Vec3 a = Vec3 a a a deriving (Show, Functor)
06:57:32 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
06:58:29 <kubunto> locallycompact: so how would i get anything out of the Vec3?
06:59:01 <fendoer> foo (Vec3 a b c) = a * b * c
06:59:06 <fendoer> if there is a function namend foo
06:59:44 <locallycompact> kubunto, in that case you could deconstruct it when pattern matching, or you could give the variables names like:
07:00:02 <locallycompact> data Vec3 = Vec3 { x :: a, y :: b, z :: c } deriving (Show, Functor)
07:00:06 <locallycompact> sorry idiot
07:00:11 <locallycompact> data Vec3 = Vec3 { x :: a, y :: a, z :: a } deriving (Show, Functor)
07:00:13 <locallycompact> that
07:00:19 <locallycompact> still idiot
07:00:23 <locallycompact> data Vec3 a = Vec3 { x :: a, y :: a, z :: a } deriving (Show, Functor)
07:00:27 <locallycompact> that
07:00:45 <winsoff> I mentioned this in ##programming, but I had an idea: What if pure functions in languages (meaning almost all functions in Haskell, right?) were named as a verb + a preposition, so that, instead of add(x,y), we have sumof(x,y)?
07:00:51 <kubunto> the ":: a" makes it generic right?
07:00:58 <winsoff> In that case, it might actually be a noun and a preposition, but you get the point.
07:01:06 <kubunto> and since all are :: a it means all same type?
07:01:11 <locallycompact> right
07:01:23 <locallycompact> all three components the same type, but you can pick which type
07:01:36 <oherrala> winsoff: lots of "of" words everywhere
07:01:40 <Tuplanolla> How would that work with higher-order functions, winsoff?
07:01:45 <cocreature> winsoff: then you’d have a different naming convention. so now what? :)
07:01:47 <locallycompact> and because you have fmap you can change them via a function to a different type
07:01:53 <Tuplanolla> Say, `sortBy lengthOf`.
07:02:24 <winsoff> oherrala, certainly, but it seems to be more linguistically sound.
07:02:26 <Tuplanolla> Suddenly you have a dangling preposition.
07:02:36 <winsoff> Tuplanolla, sumof(sumof(dad,mom))
07:02:49 <winsoff> And yeah, that makes sense to me: Sort By Length Of Parameters.
07:03:00 <winsoff> Only for purely functional, of course, so you might even just say
07:03:17 <kubunto> locallycompact: how would i go about binding?
07:03:30 <locallycompact> binding what?
07:03:40 <kubunto> i am trying  foo (Vec3 a b c) = a * b * c
07:03:51 <kubunto> not liking the attempt
07:04:31 <winsoff> Oh, i see what you're saying: sortBy(lengthOf()) seems to have side effects
07:04:31 <Tuplanolla> You're not sorting by the length of the next argument however, winsoff.
07:04:32 <locallycompact> mm what's wrong exactly?
07:04:47 <locallycompact> foo (Vec3 a b c) = a * b * c
07:04:52 <locallycompact> let x = Vec3 1 2 3
07:04:58 <locallycompact> foo x
07:05:00 <locallycompact> -- 6
07:05:04 <kubunto> locallycompact: parse error on the =
07:05:46 <winsoff> Tuplanolla, I think I get what you mean.  What does sortBy accept? I'm pretty certain you can linguistically rephrase it into a more technical phrasing, regardless.
07:05:47 <locallycompact> I do not see why that should happen
07:06:01 <locallycompact> that's just a function declaration
07:06:42 <Tuplanolla> > sortBy lengthOf ["somewhat long", "short", "extremely long"]
07:06:44 <lambdabot>  error:
07:06:44 <lambdabot>      Ambiguous occurrence ‘lengthOf’
07:06:44 <lambdabot>      It could refer to either ‘Lens.lengthOf’,
07:07:03 <Tuplanolla> > sortBy L.lengthOf ["somewhat long", "short", "extremely long"]
07:07:05 <hexagoxel> Lens has ~of :D
07:07:06 <lambdabot>  error:
07:07:06 <lambdabot>      • Couldn't match type ‘Int’ with ‘[Char] -> Ordering’
07:07:06 <lambdabot>        Expected type: [Char] -> [Char] -> Ordering
07:07:15 <lep-delete> :t sortBy
07:07:17 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
07:07:17 <lep-delete> :t sortOn
07:07:19 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
07:07:28 <Tuplanolla> I always mix these two.
07:07:31 <kubunto> locallycompact: yea cant even do f a b = a + b
07:07:46 <locallycompact> strange
07:07:53 <Tuplanolla> > sortOn L.lengthOf ["somewhat long", "short", "extremely long"]
07:07:56 <lambdabot>  ["short","somewhat long","extremely long"]
07:08:18 <locallycompact> oh
07:08:33 <locallycompact> looks like a difference between ghc 7 and 8
07:08:41 <locallycompact> let f x = x * 2
07:08:47 <locallycompact> should work
07:10:14 <kubunto> womp womp womp
07:10:17 <kubunto> it does
07:10:21 <locallycompact> nice
07:10:43 <locallycompact> you can do
07:10:45 <locallycompact> :info Functor
07:10:54 <locallycompact> to see the base instances of functor
07:11:14 <locallycompact> in the case where the type takes two type parameters one of them is filled out, i.e Either, (,) and (->)
07:11:40 <locallycompact> so for pair it's similar to either
07:11:48 <locallycompact> let x = ("foo", 12)
07:11:54 <locallycompact> fmap (+1) x
07:11:58 <locallycompact> -- ("foo", 13)
07:12:17 <locallycompact> so fmap only affects the right hand value for both (,) and Either
07:12:32 <locallycompact> and trying to do anything else is a type error
07:14:55 <winsoff> Tuplanolla, built-ins are unfortunately rife with the opposing discipline
07:15:10 <nitrix_> To be a little more precise, trying to do anything else is a _kind_ error.
07:15:36 <winsoff> I understand your counterpoint because even in python, add(x,y) does not actually create a side effect, despite the common connotation we were all raised with
07:15:41 <nitrix_> It should still possible to implement the Functor to work on fst instead of snd.
07:15:55 <nitrix_> (With a bit of type juggling)
07:15:55 <locallycompact> yup
07:16:23 <merijn> nitrix: How would you accomplish that without a newtype?
07:16:45 <nitrix> merijn: Hence the type juggling :P
07:16:51 <Logio> winsoff: I would actually prefer nouns over verbs for pure functions
07:17:01 <merijn> nitrix: You can't juggle the types that way in Haskell, though
07:17:13 <winsoff> Logio, technically, a verb/noun+preposition becomes a noun
07:17:18 <winsoff> So I agree
07:17:53 <nitrix> merijn: Oh I know. You have to use a newtype for sure, but that's what the wrapper type will give you, an inverse.
07:18:31 <nitrix> merijn: newtype EitherR e a = EitherR { swapped :: Either a e } ?
07:19:38 <nitrix> The semantic changes here though.
07:20:07 <nitrix> Tuples were nicer for that example.
07:20:18 <winsoff> nitrix, are you from rohitab?
07:20:45 <nitrix> winsoff: You might be confusing me with nitrixgen.
07:20:53 <nitrix> * nitrxgen.
07:21:04 <winsoff> Ha.
07:21:08 <winsoff> How would you know? ;D
07:21:16 <nitrix> I know him :P
07:21:41 <merijn> nitrix: honestly you'd be better off just using Bifunctor, I think?
07:22:42 <crobbins_> has anyone already put together a haskell library to, in memory, resolve geocodes/geohashes to IANA time zones?
07:22:53 <winsoff> nitrix, what's he up to these days?
07:23:37 <nitrix> I have no clue :] It's not like we know each others very well, just fellow freenodians.
07:24:15 <winsoff> He's even on freenode? effin a
07:24:40 <winsoff> freenode's like a conglomeration of newfolk and literally-borderline-wanted-by-the-statefolk
07:25:19 <nitrix> winsoff: See #DataHoarder
07:26:18 <Guest86134> hi, a question on Control.Unification; let's say I have a `Term a = Lit String | Couple Term Term`; then I can generate some UTerm Term IntVar, so I can unify stuff of the form `Couple (Couple Var (Lit "foo") Var`
07:26:35 <winsoff> Oh hell yes; thanks for the recommendation, nitrix
07:26:38 <winsoff> I'll stop scrolling chat now
07:26:57 <Guest86134> what if I want only to be able to talk of `Couple`s with a single level of nesting, and unify only those?
07:29:21 <Guest86134> pinging wrengr 
07:30:30 <Guest86134> s/Couple Term Term/Couple a a/ in the definition
07:31:11 <dram_phone> That's not like how it's supposed to work, really
07:31:55 <kubunto> what would the data structure for a tree node look like?
07:32:12 <kubunto> with a data slot and 2 child slots
07:32:16 <dram_phone> Guest86134: I think you're meant to provide data Term a = Lit String | Couple a a
07:32:46 <dram_phone> kubunto: data Tree a = Leaf | Branch a (Tree a) (Tree a)
07:33:00 <Guest86134> yes, dram_phone, I made a mistake earlier in writing; your `Term` is the correct one
07:33:26 <dram_phone> uh...sorry i don't really know the answer
07:34:18 <kubunto> dram_phone: how would i make a leaf node?
07:34:29 <dram_phone> Leaf
07:34:56 <dram_phone> Hmm... I wonder what you are doing
07:35:33 <kubunto> dram_phone: let y = Leaf "t"?
07:35:39 <drostie> No, just Leaf.
07:35:42 <dram_phone> ?
07:35:52 <dram_phone> You mean one with data but no children?
07:36:01 <kubunto> yes
07:36:06 <drostie> The data declaration is `data Tree x = Leaf | Branch x (Tree x) (Tree x)`, that means it has two constructors.
07:36:13 <dram_phone> Branch "t" Leaf Leaf
07:36:25 <dram_phone> you should rename those constructors as you see fit
07:36:27 <drostie> `Leaf :: Tree x` is one of them, `Branch :: x -> Tree x -> Tree x -> Tree x` is the other.
07:36:54 <Guest86134> dram_phone: so, I started from the unification-fd tutorial, which implemented a single prolog; the problem is that in prolog clauses can be nested, so you can have foo(bar(X,Y), Z), while I'm only interested in modeling "flat" queries, like foo(X,Y,bar)
07:37:00 <locallycompact> that data type makes no sense to me
07:37:04 <drostie> You use these like normal functions in Haskell, so `Leaf` takes no arguments and produces a Tree value; `Branch` takes three arguments and produces a tree value.
07:37:11 <locallycompact> what is the point in Leaf
07:37:23 <drostie> locallycompact: Do you want to have an empty tree?
07:37:54 <locallycompact> hmm
07:38:01 <locallycompact> yeah ok
07:38:10 <dram_phone> Guest86134: something like Term IntVar perhaps?
07:38:15 <dmiles> why would someone want to cripple a system from dealing with data they are not neededin to use today?
07:38:41 <dmiles> (is it in hopes of making the system run faster?)
07:39:01 <dram_phone> dmiles: replying to something?
07:39:52 <dmiles> i guess i do not understand Guest36413's goal
07:40:04 <Guest86134> dmiles: it's the fact that in my domain a "nested" query would be semantically incorrect, and I hoped to exclude them at compile time; I could take workarounds, but I'm interested in knowing if there is a proper solution
07:40:32 <dram_phone> Guest86134: Term IntVar
07:40:44 <dram_phone> or make that generic in var
07:41:02 <Guest86134> so, data Term a = Term IntVar? Let me think about it
07:41:36 <dram_phone> nope
07:41:50 <kubunto> dram_phone: how would i traverse said tree?
07:41:53 <dram_phone> just the Term you gave
07:42:14 <dram_phone> kubunto: by defining functions on them
07:42:15 <dmiles> hrrm OK.. i almost see why.. i had seen many want this for implmenting semweb stuff but hadnt considered what you'd said
07:42:48 <dram_phone> kbunto: What are you doing? Are you like comparing programming languages?
07:43:27 <locallycompact> :set -XDeriveFoldable
07:43:29 <locallycompact> :set -XDeriveTraversable
07:43:36 <kubunto> dram_phone: playing around with haskell
07:43:45 <locallycompact> data blah blah deriving (Foldable, Functor, Traversable)
07:43:48 <dram_phone> huh
07:44:18 <dram_phone> kbunto: That's not going to be fun if you don't already know Haskell....
07:44:33 <drostie> kubunto: `instance Traversable Tree where traverse f tree = case tree of Leaf -> pure Leaf;  Branch x left right -> Branch <$> f x <*> traverse f left <*> traverse f right` should do it.
07:44:57 <dram_phone> Do you remember the first time you 'played around' with a programming language?
07:45:13 <kubunto> dram_phone: yes, happened to be Scala
07:45:24 <kubunto> als oentertaining php python and javascrit
07:45:36 <dram_phone> That's interesting
07:46:04 <shapr> kubunto: for some purpose?
07:46:21 <kubunto> shapr: gain a better understanding of computer science
07:46:25 <shapr> I did a hackathon this past weekend, we used Python, but I really wish we'd used Haskell.
07:46:38 <shapr> I can produce working code in far less time with Haskell than with Python.
07:46:42 <dmiles> Guest36413: eventually in their domain they decided to use terms    my_triple(bnode(skos,foo1),uri(rdfs,type),uri(rdfs,class))). 
07:47:01 <merijn> shapr: Every time I use python I wish I'd used haskell :p
07:47:03 <dram_phone> kubunto: got your Haskell tutorial?
07:47:35 <shapr> merijn: yeah, me too. In this case, I was the only person on the team who knew Haskell, but for what I did, I should have used Haskell anyway.
07:47:36 <kubunto> no, i didnt get too far into that yet
07:47:50 <dram_phone> huh
07:47:53 <kubunto> mostly because it took some time to get ghci to work
07:47:55 <shapr> I ended up converting 20gig of csv into json, and no one else worked with that code.
07:48:10 <dram_phone> kubunto: You should get one
07:48:24 <merijn> shapr: I'm working solo, but chart was missing some functionality compared to matplotlib and I couldn't find a haskell library for decision trees. I'm now sorely regretting not patching chart and writing my own decision tree library >.<
07:48:28 <dram_phone> Should be good if you're good at Scala: https://www.haskell.org/tutorial/intro.html
07:48:53 <shapr> kubunto: install stack and then run "stack ghci" ?
07:48:55 <drostie> kubunto: ah. Well hi! Welcome to Haskell. You'll find that there are a couple of strange things about this wonderful new language.
07:49:02 <shapr> just one or two
07:49:43 <kubunto> shapr: i tried to install on a pi and a windows laptop, failed both places
07:49:49 <drostie> The first is that things are lazily evaluated by default, which means that [0..] is the infinite list of numbers starting from 0, you can have it in a variable with no problems.
07:49:57 <kubunto> got it ot work onmy rented aws server
07:50:08 <drostie> kubunto: Just don't try to, like, print the whole thing or whatever.
07:50:11 <shapr> huh, I've used ghc on a Pi
07:50:20 <kubunto> shapr: ghc yes, ghci no
07:50:22 <shapr> Haven't tried on a windows machine.
07:50:28 <shapr> kubunto: oh right, no ghci on ARM
07:50:51 <kubunto> some time thing is off in windows that doesnt allow either ghc or ghci to work
07:51:06 <drostie> Similarly the fibonaccis are `fibs = 0 : 1 : zipWith (+) fibs (tail fibs)`, you can refer to a sequence that you're defining inside the definition and it will often work out all right.
07:51:22 <dram_phone> drostie: that's too far ahead
07:51:32 <kubunto> drostie: ive played around with maps filters and the whole bit with functions as variables
07:51:52 <dram_phone> You comfortable with that?
07:51:53 <kubunto> o and attern matching
07:52:04 <dram_phone> if so you should be good
07:52:08 <kubunto> for the most part collection manipulation is good
07:52:25 <dram_phone> you really need a tutorial
07:52:37 * kubunto goes and does that
07:52:42 <dram_phone> https://www.haskell.org/tutorial/intro.html
07:53:19 <Guest86134> dram_phone: with data `Term a = Lit String | Couple a a` I cannot generate a `Couple (Lit "foo") (IntVar 0) :: Term IntVar`, and moreover, if I want to use the `unify` function, I should be able to construct a flat UTerm, which doesn't seem possible to me (I hope I'm missing something)
07:53:27 <drostie> Right, I'm more talking about the fact that things are lazily evaluated. In JS you would not be able to write `function fibs() { var f = fibs(); return [0, 1].concat(f.map((x, i) => x + f[i + 1])); }` that same way because it would loop forever on that first recursive call.
07:53:32 <drostie> kubunto: ^
07:53:34 <fendoer> :t sortOn
07:53:36 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
07:53:42 <fendoer> :info sortOn
07:54:17 <Guest86134> dmiles: yes, that has some similarity with my domain, so the example fits very well
07:54:26 <fendoer> from which package is sortOn?
07:54:41 <drostie> kubunto: instead you need a data type in JS which looks like `Cell<value> = {first: <value>, rest: () => Cell<value> }` for thse sorts of infinite streams.
07:56:13 <dram_phone> Guest86134: On a second thought, that doesn't seem right to me
07:56:46 <dram_phone> if you have h(A) and unify A with h(B) how are you going to prevent h(h(B))...
07:57:02 <dram_phone> I think I should stop messing up your thoughts. Sorry
07:57:40 <drostie> kubunto: then in JS you can write `function zipWith(fn, a, b) { return {first: fn(a.first, b.first), rest: () => zipWith(fn, a.rest(), b.rest())} }` and then finally you can write `var fibs = {first: 0, rest: () => {first: 1, rest: () => zipWith((x, y) => x + y, fibs, fibs.rest())}}` and it will make sense.
07:57:44 <kubunto> drostie: i am workign thru learn you a haskell tutorial
07:58:02 <Guest86134> dram_phone: np, thanks for the help so far! :) (I will never want to unify A with h(B), only flat structures)
07:58:37 <drostie> kubunto: LYAH is ok if you have a very playful mind, but not necessarily the best if you want to get quickly up to speed with hard pragmatics.
07:58:48 <dram_phone> hmm, then why are you even doing that difficult unification business
07:59:18 <drostie> kubunto: I wanted to say that the second way that Haskell is Different is that we have a data type for programs which interact with the world. In most other languages interacting with the world is done with side-effects.
07:59:24 <dram_phone> Just get a union-find sets of variables
08:00:02 <drostie> kubunto: so you call `Math.random()` in JavaScript and as a side-effect it stores some new seed in memory so that future calls to `Math.random()` generate different results.
08:00:47 <dram_phone> drostie: I appreciate your effort, but I don't think kubunto needs this for now
08:01:46 <drostie> kubunto: In Haskell things like `Date.now()` and `Math.random()` and `console.log()` are instead going to be values of the program type. So they won't do anything by default. Instead the goal of your Haskell program is to create a program which returns `()` called `main`, and this will be spat out as an executable for you to run later.
08:02:33 <drostie> kubunto: in that respect your approach of starting with GHCi is going to confuse you a little bit.
08:02:34 <kubunto> what dram_phone said
08:02:44 <dram_phone> And speaking of Python, TBH when I choose Python over Haskell it's almost always because ready-made bindings
08:03:20 <dram_phone> are better than ad-hoc bindings by me...
08:03:24 <drostie> Because GHCi has the semantics of "if you type in a program, I'm going to run the program and print whatever it produces; if you type in a value I'm going to print the value" and you don't necessarily get this language-crucial feedback of "oh, crap, that was a program."
08:03:46 <dram_phone> That's a good point there
08:04:04 <drostie> kubunto: ok, ymmv. It's just that those two things were the important ones I wish someone had told me when I was starting Haskell by playing around with GHCi.
08:04:35 <drostie> kubunto: helps to, right before you run anything with GHCI, first ask GHCI what its type is.
08:04:45 <kubunto> :t
08:04:49 <drostie> yep.
08:05:54 <Cale> It's worth noting that these things (IO actions) that drostie is referring to as "programs" are themselves also values.
08:05:58 <drostie> then it will tell you, in response to `:t getLine >>= putStrLn` that this is of type `getLine >>= putStrLn :: IO ()`, it is a program which produces a `()` [the unit type, you can think of it as a "null" if you want.]
08:06:26 <Cale> GHCi just has a bunch of special cases for what to do based on the type of the expression you enter.
08:08:32 <Tuplanolla> Are there any remedies to making multithreaded resource management less hard? I keep finding problems where threads die while holding `MVar`s or cause races when passing messages.
08:09:09 <Cale> Well, with respect to the races, STM can help somewhat
08:09:31 <Cale> (by letting you build up transactions which either happen as if they occurred all at once, or not at all)
08:10:19 <Cale> Use withMVar rather than takeMVar and putMVar whenever possible
08:10:19 <Cale> It handles exceptions better.
08:10:49 <Tuplanolla> Sockets and temporary files are my main gripe today.
08:11:09 <cocreature> basically never allocate resources without “bracket” or some other abstraction that accomplishes something similar
08:11:27 <cocreature> e.g. don’t just open a socket. use something like bracket openSocket closeSocket …
08:11:31 <Cale> ^^ yes
08:12:02 <Tuplanolla> Right now I use `ResourceT` for that, but it all breaks down when allocations have dependencies.
08:12:52 <Cale> If you have a bunch of resources which all need to be allocated at once, sometimes Cont can be helpful for that.
08:13:02 <Cale> :t runCont . sequence . map cont
08:13:05 <lambdabot> [(a -> r) -> r] -> ([a] -> r) -> r
08:13:38 <cocreature> just nesting bracket can also help at least if you don’t have complex dependency structures
08:13:39 <Tuplanolla> As an example the connections accepted by an ipc socket thread may outlive the thread itself in which case there's nobody left to clean up the file descriptor.
08:14:34 <dram_phone> but why didn't the thread close the ipc socket?
08:15:40 <dram_phone> I create one thread per that kind of resource. Weird? A bit. Works? Pretty much.
08:16:30 <Tuplanolla> The more threads you add the more unexpected thread death conditions you have to handle though.
08:17:03 <Cale> hm?
08:17:21 <Cale> The idea is to usually leave the cleanup to bracket
08:17:53 <Eduard_Munteanu> I'm trying to implement a navigation menu in Hakyll that highlights the current page. This seems incredibly clunky to implement with Context. Any ideas?
08:18:07 <Cale> The way bracket works is that if an exception occurs, the finalizer you gave will run to clean things up.
08:18:14 <dram_phone> This helps me ensures that, say, the socket never outlives the thread
08:18:48 <danilo2> Hello guys! :) I've got a huge Bytestring written to disk. Can I somehow efficiently read a part of it having a range of bytes I'm interested in ?
08:18:50 <Cale> So generally anything that would have caused the thread to die, will also cause the cleanup to occur
08:19:03 <dram_phone> It's all 'MVar's and 'TVar's between threads. Like actors
08:19:09 <Cale> danilo2: It might be best to use hSeek
08:19:50 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.9.0.0/System-IO.html#v:hSeek
08:20:02 <Tuplanolla> I know all these details. It's just difficult to bring it all together and be certain everything works.
08:20:28 <danilo2> Cale: thanks, I guess it is what I was looking for! I understand that using hseek will just read from disk only the needed part without any "havy" computations how to skip the unneeded parts?
08:20:40 <geekosaur> danilo2, if it's raw you can seek and use one of the hGet* functions. if it's serialized then it's up to how you serialized it
08:21:03 <danilo2> geekosaur: Of course, I need raw bytes here
08:21:20 <geekosaur> but are they raw on disk, or is there a header or etc.?
08:21:33 <Cale> Yeah, I'm assuming that the bytestring was written directly, and yes, it will skip forward to the position you specify without needing to read in the whole file up to that point
08:22:01 <danilo2> geekosaur: in fact they dont exist yet. I want to be able to store some big bytestring on disk and have access to some bytes form given range
08:22:22 <danilo2> geekosaur, Cale: cool , thank you for your help! :)
08:22:54 <Guest82102> does anyone in here use spacemacs?
08:23:05 <bennofs> yes
08:23:06 <geekosaur> right, in tht case iyt' just a seek. although it may still read the file up to that point if it's small enough to not be worth it... but that's largely for the OS to decide
08:23:47 <Guest82102> bennofs, with stack?
08:25:39 <kubunto> ill be back if i has more questions
08:25:56 <bennofs> Guest82102: yes
08:26:03 <kadoban> Anyone know offhand if there's anything particularly clever done by readInteger for converting large integers from ByteString? Apparently this wasn't supposed to be possible with bigints https://www.hackerrank.com/contests/w29/challenges/big-sorting , and I've been told that in other languages it fails spectacularly, but it just works in haskell
08:26:33 <Guest82102> bennofs, do you know how i can pass ghci-options to the intero repl? somewhere in .spacemacs?
08:26:49 <bennofs> Guest82102: uh, no idea, sorry
08:27:25 <cocreature> kadoban: if you can only parse small integers and then have to convert them to a big integer it might get a bit more complicated
08:29:24 <kadoban> Well, like it says that python takes "tens of seconds" to do this for the worst-case sizes of inputs. I wonder if python is just doing it spectacularly badly, or if haskell is spectacularly clever somehow.
08:30:37 <Eduard_Munteanu> Bleh, I think I should use another templating language, maybe hamlet.
08:30:38 <locallycompact> anything that is heaps faster in haskell is usually taking advantage of laziness
08:30:40 <kadoban> It also mentions java/clojure as not working well. Hmm
08:31:36 <kadoban> Ya, maybe laziness is it, though I thought it was strict. I gotta read the implementation more ... if I'll even be understand it enough.
08:31:39 <Cale> kadoban: I'm pretty sure readInteger was written specifically to win language shootouts
08:32:00 <kadoban> Cale: Hehe, really or somewhat joking?
08:32:43 <Cale> Really. Don Stewart did a lot of that sort of thing back when he wasn't having the entirety of his life consumed by work
08:32:53 <Cale> (and he's responsible for ByteString)
08:32:56 <kadoban> Ahh, interesting.
08:33:43 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/bytestring-0.10.8.1/src/Data-ByteString-Char8.html#readInteger -- yeah, this looks like dons' work :)
08:34:24 <kadoban> Trying to determine if one possible thing it'd be doing is only converting the first few characters until more are needed for a comparison? I can't tell yet.
08:34:42 <Cale> (might not be, I'm not sure, but it looks like the sort of things he was putting into language shootout code and then pulling up into ByteString so that the shootout code would also win on code length)
08:34:49 <Rub_ixCube> Hello Again, It seems like my life is full of errors. When I try to install a package with cabal I get this `cabal: failed to parse output of 'ghc-pkg dump'`
08:34:59 <kadoban> I could probably test hypothesis actually ..
08:35:12 <Rub_ixCube> nothing seems to work
08:35:25 <Cale> kadoban: If you're doing basically anything with the resulting Integers, it must already have read the whole thing
08:35:55 <bennofs> Rub_ixCube: what's your cabal and GHC version?
08:36:35 <kadoban> Yeah, that was my assumption, glad to have it confirmed.
08:36:39 <Rub_ixCube> bennofs, Cabal-Install is 1.20.0.3 and GHC is 8.0.2
08:37:17 <bennofs> Rub_ixCube: try upgrading cabal-install in this case, not sure if 1.20 is recent enough to support 8.0.2?
08:37:17 <Cale> That cabal-install seems old
08:37:28 <Rub_ixCube> how would I update?
08:37:29 <glguy> 1.20 isn't new enough for GHC 8
08:38:14 <Cale> Well, normally you would do cabal install cabal-install, but since things are broken, just grab the tarball off of hackage
08:38:27 <Cale> https://hackage.haskell.org/package/cabal-install-1.24.0.2/cabal-install-1.24.0.2.tar.gz
08:38:34 <glguy> Is this for the Raspberry Pi 3 , still?
08:38:39 <Rub_ixCube> yep
08:38:41 <Rub_ixCube> :P
08:38:59 <glguy> It's possible that the rpi doesn't have enough ram to compile a new cabal-install starting with GHC 8.0.2
08:39:09 <Rub_ixCube> 1GB is enough
08:39:18 <glguy> I was able to do it with 8.0.1 and I seem to remember OOM on 8.0.2
08:39:33 <glguy> Why do you believe that 1GB is enough?
08:39:41 <Rub_ixCube> Chrome runs well :)
08:39:48 <glguy> That's not how numbers work
08:40:04 <kadoban> Heh
08:40:10 <bennofs> Haskell blows your expectations. Regarding memory usage
08:40:10 <Cale> I have 16GB in my laptop and it's barely enough for my work setup
08:40:33 <bennofs> (I should say "GHC")
08:40:34 <Rub_ixCube> ?
08:40:39 <Rub_ixCube> oh ye
08:40:50 <kadoban> Yeah, GHC/haskell is unfortunately quite memory heavy. I used to run into trouble on my old machine with 2GB, and even on my current one with 4GB I sometimes wish I had more.
08:40:54 <Cale> (which involves a couple ghcids, a ghci backend, and ghcjs building the frontend)
08:41:43 <bennofs> Cale: probably most of the memory is needed for GHC?
08:41:43 <bennofs> Cale: GHCJS i meant
08:41:47 <Cale> I usually just ssh to my desktop which has 64 GB
08:42:01 <massprog> where haskell should be used?
08:42:01 <Cale> Well, the ghcids each take quite a bit.
08:42:20 <juri_> I just built a new one with 256GB of ram. runs out after 8 hours.
08:43:19 <orion> Cale: What are the other specifications of your desktop?
08:44:16 <Cale> I have an Intel Core i7-6900K CPU @ 3.20GHz with water cooling
08:44:27 <glguy> Rub_ixCube: If you want you can use the executable I compiled for rpi3 with GHC 8.0.1: http://www.galois.com/~emertens/cabal-rpi3
08:44:30 <Cale> er, that's incorrect, it's overclocked to 4.3 atm
08:44:43 <glguy> Rub_ixCube: if you don't find something else
08:44:50 <Rub_ixCube> at this point I don't understand how 256 Giga FUCKING Bytes runs up dry with haskell
08:44:57 <Cale> (could probably push it harder, but haven't taken the time)
08:45:01 <glguy> Rub_ixCube: It doesn't
08:45:05 <Tuplanolla> Isn't it steam cooling at temperatures like 6900 K?
08:45:10 <Cale> haha
08:46:30 <Cale> I also have an NVidia GTX 1070
08:51:03 <Cale> Rub_ixCube: Yeah, I don't know what juri_ was referring to. 64 GB is certainly very comfortable for everything I do, and I rarely need more than 16 GB to be honest -- it's just that if I'm running lots of Chrome tabs while also trying to work, it gets a bit dangerous with only 16 GB.
08:56:23 <Guest82102> bennofs, i run SPC m s b and spacemacs locks up
08:56:38 <Guest82102> (this is after figuring out how to pass intero repl the right flags)
08:57:02 <Guest82102> any idea?
08:57:28 <bennofs> Guest82102: hmm I'm not using that command often
08:58:09 <bennofs> Guest82102: well it works here...
08:58:33 <Guest82102> bennofs, do you know how i can start emacs in debug mode? so that it gives me some idea about why it's locking up?
08:59:36 <bennofs> Guest82102: not an emacs expert. perhaps http://emacs.stackexchange.com/a/507 ?
09:00:29 <Guest82102> ah it locks on collecting type info
09:00:32 <Cale> So yeah, just checked, and my backend ghcid for this project is 2.1 GB, frontend one is 1.2 GB.
09:00:35 <Guest82102> thanks
09:00:51 <Guest82102> is 302 modules a lot?
09:00:55 <Cale> sorry, 1.6 rather than 1.2, it hadn't finished loading
09:01:13 <Cale> Guest82102: That's a fair number :)
09:02:10 <Cale> Certainly more than you'd usually see in a single package, aside from bindings to big libraries like OpenGL or something.
09:02:46 <Guest82102> well ain't that wonderful
09:04:27 <Guest82102> bennofs, do you use hasktags?
09:04:47 <bennofs> Guest82102: no
09:05:08 <Guest82102> what do you use for tags?
09:05:15 <Cale> I've used hasktags
09:05:24 <Cale> It works well
09:05:37 <bennofs> Guest82102: intero can jump-to-definition as well, just SPC m g g
09:05:55 <bennofs> Guest82102: or is that using hasktags?
09:06:06 <Guest82102> interesting
09:06:24 <bennofs> that's what I use at least ;)
09:06:25 <Guest82102> tags are faster though
09:06:45 <bennofs> well I don't have such big projects, just a hobby haskeller
09:08:27 <flxw> speaks anything against fast-tags? that is what I am using.
09:08:34 <bollu> did haskell not apply as an organisation this time for GSoC?
09:11:39 <Guest82102> anyone recognize this in ghci with stack? gcc: error: /tmp/ghc26073_0/ghc_331.o: No such file or directory
09:11:55 <Guest82102> project builds successfully
09:12:00 <Guest82102> this is on :trace main
09:12:29 <cla`> someone has an example of usage for the bits package https://hackage.haskell.org/package/bits ?
09:24:51 <Guest82102> how can i debug linker errors?
09:32:58 <paiv> sup guys
09:33:27 <nitrix> Guest82102: Maybe publish/extract what you're working on and open a GHC ticket by providing them your test case.
09:34:18 <Guest82102> nitrix, that's a method of debugging? lol
09:34:18 <nitrix> Guest82102: If it's a linker error, chances are that other people stumbled on it too, so you might be able to find an existing ticket as well.
09:36:37 <Guest82102> that's not a debugging method - i'm asking how to get meaningful debug information from ghci other than linker error -1
09:37:29 <nitrix> Even the verbose mode of GHCi wont get you far.
09:37:29 <Cale> Guest82102: How are you causing that error to occur?
09:37:41 <Guest82102> loading my package into ghci
09:37:48 <Guest82102> then running main
09:37:57 <Cale> hmm
09:38:01 <Guest82102> the package builds successfully
09:38:24 <Cale> If you compile it to an executable and run it, that works okay?
09:38:40 <Guest82102> it croaks for a different reason (the one i'm trying to debug in ghci)
09:38:44 <Guest82102> so i don't know
09:39:08 <AndreasK> bollu: Probably didn't get accepted
09:39:12 <nitrix> Assuming it's really a linker error (which is the only information you provided to me), then my only recommendation is to let the people that knows best about the linker to solve it. These things have plenty of interractions and it's not something we can trivially solve over IRC.
09:39:40 <Cale> I've never seen a linker error which looked like "linker error -1"
09:40:13 <nitrix> Cale: The information so far: gcc: error: /tmp/ghc26073_0/ghc_331.o: No such file or directory
09:40:37 <Guest82102> $- :main
09:40:37 <Guest82102> gcc: error: /tmp/ghc26890_0/ghc_331.o: No such file or directory
09:40:37 <Guest82102> phase `Linker' failed (exitcode = 1)
09:41:01 <bollu> AndreasK: ouch, that's a little sad
09:41:55 <Cale> What is your module's filename?
09:42:22 <Guest82102> Cale, Main
09:42:46 <Cale> "Main.hs"?
09:43:06 <Guest82102> yes main is Main.hs
09:43:10 <Cale> okay
09:43:11 <Guest82102> *is in
09:43:48 <nitrix> Guest82102: Have you tried compiling other executables and/or eliminating features of your test case?
09:44:03 <Guest82102> what i did try was loading another module
09:44:13 <Guest82102> and then loading Main and running main again
09:44:14 <Guest82102> which worked
09:44:27 <AndreasK> bollu: At least year they didn't get accepted
09:44:34 <AndreasK> bollu* last year
09:44:35 <bollu> AndreasK: yeah, I know that :)
09:44:45 <bollu> AndreasK: will the whole "summer of Haskell: that happened last year happen again?
09:45:08 <Cale> This sounds like it's probably a GHC bug
09:45:52 <Guest82102> lol
09:46:09 <Cale> I would copy the whole project to another directory, and then just start removing stuff from it and seeing how much I could delete while still having the linker error occur.
09:46:54 <Cale> and then hopefully whatever's left at the end will indicate something about what the problem is
09:47:09 <Guest82102> i can't even imagine what you mean. removing modules?
09:47:30 <nitrix> Removing modules, remove extensions, remove definitions, etc.
09:47:35 <Guest82102> haha
09:47:43 <Cale> Yeah, just start deleting stuff.
09:47:54 <Cale> and rechecking to see if the problem is still there
09:47:59 <Guest82102> i don't know who here frequents /r/haskell
09:48:10 <Guest82102> but i'm the author of the "how do you guys get anything done" post from yesterday
09:48:24 <Guest82102> and i should just post this conversation in a follow up
09:48:32 <Cale> Well, I don't know, you sound like you've been having a harder time than most
09:48:39 <Cale> I've never seen anything which looked like the issue you're seeing
09:49:02 <Cale> (and I've been programming in Haskell for about 16 years)
09:49:11 <monochrom> I agree with using the subtraction method.
09:49:39 <Cale> Guest82102: Oh, I should have asked: what's the complete path to Main.hs?
09:49:39 <Guest82102> the subtraction method isn't even bisection
09:49:49 <Cale> Are there non-ascii unicode characters in it?
09:49:53 <Guest82102> no
09:49:58 <monochrom> If you have 1K lines of Haskell and 100 lines in your *.cabal file and 200 lines in your stack.yaml file etc etc, there are simply too many moving parts.
09:50:26 <nitrix> Am I the only one hoping you'd just link us to your file instead of guessing?
09:50:38 <Guest82102> link to what file exactly?
09:50:39 <Cale> yeah, it would be a lot easier if I could just try this myself
09:50:46 <Cale> The project
09:51:05 <Cale> Is it on github?
09:51:14 <Guest82102> you will have to install a ton of dependencies 
09:51:16 <Cale> (or anywhere that I can download it and try building it myself)
09:51:21 <monochrom> Oh, bisection could be done if you had kept a complete history of changes to your files.
09:51:43 <Guest82102> https://github.com/databrary/databrary/tree/build_system
09:51:45 <Guest82102> have at it
09:51:58 <Cale> Yeah, the other approach is to use git bisection to try to figure out which commit caused that to start happening
09:51:59 <Guest82102> in Docker there's a script called docker_build
09:52:11 <Guest82102> comment out the last two lines
09:52:47 <Guest82102> this
09:52:48 <Guest82102> https://github.com/databrary/databrary/blob/build_system/Docker/databrary/databrary_config/databrary_build.conf#L27
09:52:49 <Guest82102> should be your ip
09:53:01 <Guest82102> build the postgres instance then compile the application using stack build
09:53:05 <nitrix> We don't have to go this far.
09:53:11 <nitrix> Building it is all that's needed.
09:53:19 <Guest82102> you can't build it without postgres
09:53:43 <Guest82102> the C dependencies are here https://github.com/databrary/databrary/blob/build_system/Docker/databrary/Dockerfile_base
09:53:45 <Guest82102> like i said
09:53:48 <Guest82102> have at it
09:54:16 <nitrix> Guest82102: Are you using GHC 7.10 ?
09:54:19 <Guest82102> yes
09:54:30 <Cale> wait, what?
09:54:35 <Guest82102> i got a lot of people yesterday telling me that i'm just a novice and that it gets better 
09:54:43 <Guest82102> this is an insane workflow
09:54:57 <Cale> Stack said you're using 8.0.2 ;)
09:55:05 <Guest82102> no it didn't
09:55:14 <Guest82102> wait what
09:55:18 <monochrom> It won't get better.
09:55:27 <Guest82102> where does it say i'm using 8.0.2?
09:55:32 <Cale> oh, I see, that's just my global stack config, since the project doesn't specify
09:55:39 <Guest82102> the project specifies and lts
09:55:42 <Guest82102> lts-6.30
09:55:46 <Guest82102> which is 7.10.3
09:56:04 <Cale> hmm, did I pull the right branch of this?
09:56:12 <Guest82102> build_system
09:56:16 <Guest82102> i thought i linked directly to it
09:56:30 <nitrix> You did.
09:56:49 <Cale> ah, right
09:56:49 <Guest82102> right but you can't clone a branch
09:56:50 <Guest82102> my mistake
09:56:51 <Guest82102> sorry
09:56:53 <Cale> I was just on master
09:58:24 <Cale> This project is quite large for someone who is new to Haskell.
09:58:46 <Cale> I guess you're off the deep end :)
09:58:51 <Guest82102> i'm fine
09:58:55 <Guest82102> i would be fine
09:58:59 <Guest82102> if things like linker errors
09:59:09 <Guest82102> didn't take having someone else look at the assembly 
09:59:29 <Cale> Well, that error you're seeing isn't normal
09:59:38 <Guest82102> okay but programming is all about edge cases
09:59:51 <Guest82102> thats
09:59:55 <Guest82102> why we have exceptions
10:00:01 <Cale> It's probably a bug in GHC of some sort
10:00:04 <Cale> Not sure what yet.
10:00:19 <monochrom> How about file system corruption?
10:00:24 <Guest82102> no way
10:00:31 <Guest82102> that's like saying solar flairs
10:00:54 <Cale> Well, I'm doing stack ghci to see what I see
10:01:01 <Cale> It's at 156/174, I'll let you know
10:01:08 <nitrix> Same, 84/174
10:01:24 <Guest82102> if you don't have postgres up it will fail
10:01:34 <Guest82102> on build
10:01:44 <Cale> That's... interesting
10:01:44 <Guest82102> it uses postgres-typed
10:02:13 <Cale> Well, I'll let it run into that.
10:02:51 <Guest82102> and my question after all is what in the world is the point
10:03:32 <nitrix> I'm don't think I'm the right person to solve your existantial programmer crisis :P
10:03:40 <nitrix> But I can look at the GHC problem to improve it.
10:04:01 <Guest82102> i'm sorry i'm just waxing poetical after the argument i had with all of those people on r/haskell yesterday
10:04:36 <monochrom> This is why I stay away from reddit
10:04:36 <kgadek> Guest36413: oh, was that your topic there?
10:04:50 <kgadek> Sorry to hear you're disappointed 
10:04:56 <kgadek> Or angry
10:05:17 <mnoonan> Guest82102: I have to admit, some of the things mentioned in your post sound like you might just have a borderline-insane codebase that you inherited.
10:05:27 <Guest82102> i'm not angry
10:05:33 <Guest82102> like i said i wanted to love haskell
10:05:40 <Guest82102> i'm annoyed
10:06:08 <kgadek> Ye, Haskell can do that. Especially at the beginning and then even for some time more
10:06:16 <nitrix> Keep in mind the issue you're having is with GHC. Haskell isn't responsible for this.
10:06:28 <Guest82102> programming languages are an ecosystem 
10:06:44 <kgadek> nitrix: I don't agree. GHC is the de facto compiler of Haskell
10:06:47 <Guest82102> some of my complaints were about cabal/stack 
10:06:57 <cobreadmonster> No Haskell at GSoC this year? :(
10:07:32 <Guest82102> how do i paste into emacs with evil mode?
10:07:53 <nitrix> kgadek: It shouldn't affect one's view of the language. If the compiler isn't on par with the expectations, we fix it and that's all.
10:08:19 <nitrix> You obviously shouldn't have to worry about GHC linker problems while working with Haskell.
10:08:28 <Cale> Guest82102: This project should definitely be using nix... the dependencies and the fact that it requires a particular system state in particular make this annoying
10:08:31 <kgadek> Guest82102: since stack my problems with cabal-hell are non-existent. But I remember the pain. "Cabal is hell" / "Cabal. Cabal never changes"
10:09:39 <nitrix> I see. It is trying to create a postgres DB at compile-time.
10:09:42 <nitrix> That's naughty.
10:10:06 <kgadek> nitrix: why as a user should I care? GHC's problems are Haskell problems. Nobody actually cares about details. YES, GNU/Linux and not Linux. I don't care
10:10:10 <Guest82102> how do i paste into emacs with evil mode?
10:10:30 <mnoonan> It's kind of hilarious to have shenanigans like that in your build, when your language is so principled about side-effects
10:10:48 <Guest82102> mnoonan, yes!
10:11:03 <kgadek> Agree on shenanigans
10:11:11 <Cale> nitrix: Yeah, that's really stupid imo, but I'm not going to question it for now ;)
10:11:41 <mnoonan> maybe the theory is to move all side-effects into the build, for ultimate run-time purity :)
10:11:46 <Guest82102> haha
10:12:25 <nitrix> kgadek: I cannot have this discussion right now, but I'll still say that you're missing the point. There are plenty of great and bad languages depending on different design decisions. Each affects the final product. Same with compiler development. Thing is, you're able to able amazing languages and bad compilers, or great compilers and shitty languages.
10:13:04 <nitrix> kgadek: Bundling the two is just disrespectful for the parties involved. Again, if GHC is what prevents someone from adopting Haskell, GHC gets improved and that's all.
10:13:27 <Cale> I suspect the problem here lies not even with GHC, but with this insane project's build setup
10:13:42 <kgadek> nitrix: ok, let's skip this discussion. But Haskell is not C++, we don't have 3 big compilers. We have one
10:13:42 <Guest82102> nitrix, but you're missing my point
10:13:54 <Guest82102> a language isn't a grammar
10:13:56 <Guest82102> and a syntax
10:14:02 <Guest82102> not in real life at least
10:14:08 <Guest82102> it's an ecosystem
10:14:19 <Guest82102> that includes compiler, build system, libraries, docs
10:14:21 <Guest82102> everything
10:14:33 <Guest82102> i don't care if the language is formally beautiful if there's no compiler
10:14:37 <Guest82102> hence compiler matters
10:14:45 <Guest82102> at least vacuously 
10:15:46 <kgadek> I have full respect for committee behind Haskell. I have full admiration for guys behind GHC. But those are now so tangled that for users... why should they care? I'm with Guest82102 
10:16:09 <drostie> lol what have I walked into.
10:16:58 <kgadek> drostie: Cale is debugging a build system that requires Postgres running
10:17:08 <kgadek> (for build!)
10:17:30 <nitrix> Personally, the passive-aggressiveness is starting to turn me off.
10:17:37 <Guest82102> i'm sorry
10:17:37 <nitrix> I'll say you're on your own with this one :)
10:17:43 <nitrix> Going for lunch :P
10:18:01 <drostie> ouch, that sucks.
10:18:29 <Cale> Yeah, this might be too fucked up to bother with right now -- I'm not sure what state I need postgres in to get this to build.
10:18:37 <Cale> (It's installed)
10:18:47 <Guest82102> there's an app that creates the schema
10:18:52 <Guest82102> don't worry about it
10:20:26 <Squarism_> anyone worked with Aeson and time? I wonder if theres some trick to generate json, taking client timezone into account? To avoid doing time logic on a client
10:20:28 <Cale> Guest82102: anyway, this is unusually complicated -- did you write all this, or just inherit it from someone else?
10:20:36 <Guest82102> i didn't write any of it
10:20:59 <Guest82102> the question now is whether to rewrite it
10:21:00 <sjakobi> Guest82102: If you'd like to make it easier for others to replicate your build, you might want to look into stack's Docker integration
10:21:17 <Guest82102> sjakobi, it won't help. you need a postgres instance up and running
10:21:39 <shapr> Guest82102: I think you need to apply parking lot therapy to whoever designed this codebase
10:22:00 <byorgey> it seems vacuously true that if you inherit an overly complicated codebase in language X which you didn't know before, you are going to be annoyed for all X.
10:22:09 <Guest82102> i don't think that's true
10:22:18 <Guest82102> i've inherited other terrible codebases before
10:22:25 <byorgey> in languages you didn't already know?
10:22:29 <Guest82102> when the tools are mature it's easier. it's not pleasant but it's easier
10:22:31 <Guest82102> yes
10:22:39 <byorgey> ok, fair enough.
10:23:03 <Cale> Well, this isn't about tool maturity, this is about "we're using metaprogramming to do weird shit at build time"
10:23:17 <Guest82102> my only tool is a commandline debugger and emacs
10:23:20 <Guest82102> *my only tools
10:23:29 <Cale> I suspect even the most mature tools would be thrown off by that :P
10:23:52 <Guest82102> suppose you didn't know imperative programming and i gave you a python codebase and pycharm
10:23:55 <Guest82102> you think you could figure it out?
10:23:58 <sjakobi> Guest82102: I'm not really familiar with Docker but I thought that things like the DB setup should be configurable in the Docker image.
10:24:10 <Cale> I don't know what pycharm is
10:24:20 <Guest82102> it's a wonderful beautiful mature ide
10:24:41 <Guest82102> with a graphical debugger and completion and jump to declaration and global indexing
10:24:45 <shapr> Why are you using emacs if it's new to you?
10:25:19 <Cale> Guest82102: But if the python codebase wouldn't load in pycharm because it triggered some bug in CPython while doing some crazy load-time side effects baked into the project config, maybe I couldn't figure it out.
10:25:33 <Guest82102> fair enough
10:26:22 <shapr> Guest82102: I will say your reddit post appears to be primarily composed of frustration rather than "I have this problem, how can I fix it?"
10:26:50 <kgadek> Guest82102: pycharm is wonderful but once I left a (nice) project for 1mo and found out it got into really unmaintainable mess in some places. 
10:27:03 <Guest82102> shapr, of course. it's not practical to post a question every time i have a problem
10:27:10 <Guest82102> so i posted reflections on 3 weeks of problems
10:27:39 <Cale> What does this project actually do?
10:27:46 <Guest82102> it's a CMS basically
10:27:55 <kgadek> Guest82102: Because Python is wonderful (my second fav after Haskell), but <here spiderman rule>
10:28:04 <shapr> spiderman rule?
10:28:15 <mnoonan> fwiw, I've found that wrapping my head around a new codebase enough to refactor / update / add new features is easier in Haskell than in other languages I commonly use (C++, Python, Lisp)
10:28:24 <kgadek> shapr: with great power comes great responsibility 
10:28:31 <mnoonan> and I'm generally more confident that my changes haven't screwed up existing functionality, too
10:28:35 <shapr> oh, ha
10:28:48 <kgadek> mnoonan: yes. Haskell is a wonder to maintain
10:28:51 <shapr> Guest82102: can you bribe a nearby Haskeller to pair with you?
10:28:51 <mnoonan> but your situation seems pretty extreme
10:30:40 <kgadek> Usual newbie comes here to ask for help with some question about type system, not with effectfull, stateful, broken, legacy Haskell app that predates stack 
10:30:51 <kgadek> So yeah, pretty extreme
10:31:20 <shapr> Guest82102: you have the worst legacy Haskell codebase I've ever heard of
10:31:35 <Guest82102> haha
10:31:53 <Guest82102> i should print that out and post it somewhere
10:32:01 <Guest82102> my problem is i would like to keep writing haskell
10:32:03 <Guest82102> that's why i took this job
10:32:26 <Guest82102> but i can't (for psychological and administrative reasons) be mired in nonsense for the next 3 months
10:32:40 <shapr> Guest82102: there are other Haskell jobs?
10:32:53 <Guest82102> no i mean i want to keep writing haskell at this job
10:32:57 <shapr> oh
10:33:03 <hexagoxel> somebody remind how GHC manages its compilation process :) if you do complex stuff that does not intuitively work on a second machine, stack vs cabal does not matter.
10:33:03 <shapr> There are still other Haskell jobs?
10:33:12 <Guest82102> oh
10:33:19 <Guest82102> well sure but i'm in this one now
10:33:25 <Guest82102> wouldn't make sense to leave after 1 month
10:33:28 <shapr> Guest82102: SAVE YOURSELF
10:33:31 <Guest82102> haha
10:33:34 <Guest82102> :)
10:34:14 <kgadek> Cale: can't hop to computer right now. What did you see in his codebase?
10:34:20 <suppi> Guest82102: may i ask how many people are working on this team right now?
10:34:24 <Guest82102> 1
10:34:25 <Guest82102> me
10:34:28 <Guest82102> :)
10:34:48 <shapr> Guest82102: I would strongly recommend bribing a nearby Haskeller to pair with you
10:34:55 <Cale> kgadek: Well, I dunno, I can't get this thing building because it requires you to have postgres globally configured a particular way
10:35:02 <Cale> just in order to compile
10:35:19 <kgadek> It's in Setup.hs or TH?
10:35:20 <shapr> At that point I'd start swearing in Swedish and find the previous author's home address so I could send glitter bombs.
10:35:29 <suppi> so someone hired a single programmer which is a newbie to the tech to attend to a very big and weird codebase without any guidance?
10:35:38 <shapr> sounds like it
10:35:46 <Cale> kgadek: Template haskell
10:35:49 <shapr> I learned some really good Swedish swearwords when I lived there.
10:35:57 <shapr> insanity
10:36:16 <kgadek> Perkele? :)
10:36:28 <shapr> Nah, that's finnish, but it's good too
10:36:28 <Guest82102> riddle me this type masters: why does this function have two args but its signature only 1
10:36:29 <Guest82102> webLinkDataFile
10:36:32 <Guest82102> https://github.com/databrary/databrary/blob/1e2a94ac93aa6548db418d9dea5edf2b088a9609/Databrary/Web/Generate.hs#L66
10:36:37 <Cale> Guest82102: Perhaps someone from my company can come out and help you, you're in NYC, right?
10:36:54 <suppi> did you know this before taking the job? :(
10:37:02 <Cale> (well, the company I work for, it's not literally mine ;)
10:37:16 <kgadek> Cale: FPcomplete? Galois? 
10:37:16 <suppi> because WebGenerator is probably a function
10:37:30 <Guest82102> it's a monad actually
10:37:33 <Cale> Guest82102: Because some wise guy defined WebGenerator as a type synonym for a function type
10:37:35 <Guest82102> or something
10:37:42 <Guest82102> ah
10:37:44 <suppi> bingo https://github.com/databrary/databrary/blob/1e2a94ac93aa6548db418d9dea5edf2b088a9609/Databrary/Web/Types.hs#L39
10:37:45 <Guest82102> lol
10:38:02 <Guest82102> see so who do we blame this on? the compiler?
10:38:07 <Cale> Type synonyms are dumb
10:38:07 <Guest82102> or the language that that's possible
10:38:07 <suppi> C-c C-t in emacs would give that away
10:38:18 <suppi> or C-c C-i
10:38:21 <shapr> Guest82102: the previous author
10:38:24 <glguy> the user that didn't know that that could happen?
10:38:31 <shapr> ooh
10:38:36 * shapr snaps
10:38:38 <Cale> Usually anyway, they're a terrible idea, because they usually make code harder to work with without any of the benefits of abstraction
10:38:38 <suppi> I think it's fine. you see this once and that's it?
10:39:07 <Cale> Guest82102: You blame it on the programmer who defined that type synonym.
10:39:21 <Cale> Type synonyms *do* have sensible uses
10:39:39 <Cale> But they should be used sparingly.
10:40:03 <suppi> I don't see the problem, honestly.
10:40:08 <Cale> I would have make WebGeneratorM a newtype rather than a type synonym
10:40:35 <Cale> I would have defined a proper data type instead of the pair that WebGenerator has as its argument type
10:40:53 <Cale> and then I wouldn't have bothered with the synonym for WebGenerator
10:41:10 <kgadek> Yes, newtype with generalised deriving
10:41:19 <kgadek> That would be much nicer
10:41:25 * shapr changes his name to Captain Deriving
10:41:52 <suppi> i don't feel like this matters much but oh well
10:42:12 <Cale> Guest82102: But seriously, if you'd like, we could have someone come visit and see if our company can help you in some way
10:42:38 <Guest82102> it's a nice thought but it's as practical as you compiling my package from scratch
10:42:40 <Cale> (We're Obsidian Systems)
10:42:58 <Guest82102> i got push back on rewriting it in Go yesteday
10:43:00 <Cale> (We do web applications entirely in Haskell for various people)
10:43:01 <shapr> Guest82102: just sayin that might save you weeks of frustration
10:43:07 <sm> Guest82102: can't you contact the previous developer ?
10:43:15 <Guest82102> both things are impractical
10:44:17 <Cale> At the very least, someone with knowledge of nix could go through and sanitize the build -- and if there really is a GHC bug it's not impossible to go tracking those down.
10:44:29 <sm> Guest82102: I liked your rant, even if not entirely fair or comprehensible
10:44:35 <Guest82102> lol
10:44:36 <Guest82102> thanks sm
10:44:49 <Guest82102> Cale, what do you suggest? soldier on with this codebase or rewrite?
10:45:08 <Cale> Well, I don't know everything that this does.
10:45:13 <Guest82102> it's a CMS
10:45:16 <Guest82102> video sharing and such
10:45:22 <Cale> It looks like it has a lot of custom features
10:45:24 <Guest82102> for researchers doing work in developmental psych 
10:45:25 <pikajude> oh boy, is the CMS build project still going on?
10:45:33 <pikajude> did you get it to configure?
10:45:39 <Guest82102> haha!
10:45:44 <Guest82102> yes
10:45:45 <sm> it helps push Haskell towarrds real-world practicality. The bit about IDEs was totally fair I think
10:45:47 <shapr> Did you try updating it to use stack and GHC 8 ?
10:45:55 <Guest82102> shapr, are you kidding
10:46:03 <pikajude> LOL
10:46:08 <Cale> Guest82102: From where *I'm* sitting, I might rewrite it, but the rewrite would be in Haskell again, and would use all the shiny stuff that we've got at Obsidian. ;)
10:46:29 <mnoonan> It's almost certainly cheapest for your company to do what Cale suggested: hire somebody short-term to unfuck the build process and maybe do some other refactoring, then you take it onward from there..
10:47:33 <shapr> Guest82102: if you can get it to build, the first thing I'd do is make everything explicit imports so you know where to find things.
10:47:40 <sm> or, continue what Guest82102 is already doing, and get free help from concerned haskellers :)
10:47:43 <shapr> The second thing I'd do is cut it into smaller pieces if that's possible
10:47:47 <shapr> yeah, what sm said
10:48:07 <Cale> also, wtf, whoever wrote this was insane about writing new modules
10:48:10 <kgadek> I could try to help but much later
10:48:20 <kgadek> (If I find time :( )
10:48:21 <pikajude> i want to try too
10:48:24 <Cale> the last 10 modules I clicked on only defined a single thing
10:48:25 <pikajude> can someone link me to the repo again
10:48:30 <pikajude> i've got some free time at work
10:48:56 <shapr> Guest82102: is this it? https://github.com/databrary/databrary/
10:49:00 <Guest82102> yes
10:49:03 <Guest82102> no hires
10:49:09 <Guest82102> it's an academic research group
10:49:36 <Guest82102> i would lke to unfuck it
10:49:45 <Guest82102> i've already started
10:50:19 <kgadek> Guest82102: probably it's a good time to create a proper nick on IRC
10:50:23 <shapr> I agree
10:50:26 <Guest82102> i have one
10:50:41 <bollu> Cale: shiny stuff at obsidian such as ghcjs? :)
10:50:46 <max3> here i am
10:51:26 <kgadek> Cool. If I find free time today I'll ping you about this project. You're NY timezone?
10:52:18 <Cale> bollu: Well, yes, but I was also thinking about our build and deployment stuff which isn't quite as open source (it's largely open source, it uses nix)
10:52:41 <bollu> Cale: I see, that is quite cool :)
10:53:07 <Cale> reflex-platform is a miniature version of it
10:53:11 <davean> sm: I think the bit about IDEs was the typical thing about IDEs - people who like IDEs like IDEs, no one else knows why you'd want to use an IDE.
10:53:20 <davean> Unless you get enough people who actually want an IDE, they don't exist for something
10:53:23 <bollu> Cale: ahh. reflex-platform was ultra pleasant to get up and running
10:53:32 <bollu> Cale: it's a shame I don't have much time to play around with it
10:53:51 <sm> davean: I mean the list of IDEs tried that didn't just work. I think that's pretty accurate unless you get lucky
10:54:26 <davean> sm: Yah, but I think all that means is that there isn't really demand
10:54:44 <davean> Some people start an IDE project, but no one helps them because they don't want an IDE, and it never finishes
10:54:47 <suppi> Cale: can you link it please? (the parts that are public for the build system)? I'm interested :)
10:54:57 <max3> kgadek, yes i'm in NYC
10:55:19 <Cale> suppi: https://github.com/reflex-frp/reflex-platform
10:55:24 <sm> not enough demand with deep pockets, at least
10:55:33 <suppi> Cale: oh, alright :)
10:55:40 <suppi> thank you
10:55:48 <davean> sm: just time
10:56:09 <flxw> max3: in case you still got your emacs pasting issue. From where to where do you wantto paste?
10:56:24 <davean> sm: IDEs are hardly complicated, they're just large
10:56:36 <max3> flxw system clipboard
10:56:38 <Cale> suppi: apart from that, we have some stuff that uses nix-copy-closure to deploy to an AWS machine and a bunch more random overrides and stuff
10:56:42 <suppi> davean: even without ides, haskell editors can definitely have a better story :)
10:56:53 <MarcelineVQ> getting reflex to play with stack has been a trial lately, I'm gonna be a happy camper when this baby drops https://github.com/haskell/cabal/pull/4289
10:56:56 <davean> suppi: I think not having an IDE is the better story :-p
10:57:02 <suppi> Cale: thank you i'll take a look :)
10:57:11 <davean> suppi: IME the reason for an IDE is one once programmed Java
10:57:17 <suppi> davean: you don't have type errors on your editor? no go to definition?
10:57:28 <davean> suppi: never bothered
10:57:31 <suppi> to type at line?
10:57:33 <davean> suppi: I use emacs, so it exists
10:57:35 <suppi> no*
10:57:46 <davean> suppi: But theres no reason for having it
10:57:47 <suppi> under cursor i mean
10:58:01 <davean> suppi: I had it once upon a time briefly, it just annoyed me
10:58:04 <Cale> suppi: I have to admit that I *hate* actually having to work on any of the .nix files, but so long as I'm not the one who needs to change things, nix is really very nice to use. ;)
10:58:12 <ski> "type at line" ?
10:58:26 <suppi> ski, i meant type under cursor, sorry :)
10:58:37 <flxw> max3: oh, sorry. No system clipboard here. I had suggested screen and / or :r. :)
10:58:47 <Cale> Nix's language very badly needs to be Haskell instead.
10:58:51 <ski> oh, the other "type"
10:59:09 <davean> suppi: but that fully exists, if one did want it
10:59:28 <Cale> It's impossible to discover how anything works because there's essentially no type system, so you're forced to just read code and documentation.
10:59:29 <suppi> davean: i work with someone like that, they get around well because they know the system very well, but they also suffers from long compilation types and such. I need these things to be productive as them
10:59:46 <Cale> and most stuff is just cargo culted, copy and paste style
10:59:47 <davean> suppi: "productive as them"?
10:59:54 <davean> suppi: also, I spent most of my time in other people's code
11:00:14 <suppi> davean: as my coworkers who work without these features
11:00:31 <Cale> But, in the end, if you have a build which is working, it's very reproducible.
11:00:34 <suppi> davean: somewhat. haskell-mode and intero both are ok but not always
11:00:35 <davean> "long compilation types"  means time?
11:00:41 <suppi> time, sorry
11:00:53 <davean> sorry, it was very confusing, are you on a phone keyboard?
11:01:11 <suppi> i'm sorry, i'm on a keyboard, i'll try to be clearer
11:01:23 <davean> Its ok, I might just missunderstand you
11:01:54 <suppi> when a coworker of mine work on their code, they have to wait for compilation to end in order to know if their code compiles or not
11:02:02 <suppi> i can know in an instant
11:03:04 <suppi> haskell-mode and intero don't work well when your code does not compile. for example if you just opened something broken, you don't really get anything
11:03:21 <davean> suppi: a few things, first if that as important you should be more productive then them, second that is true but not strictly important you can assume with high probability it will compile and move on also
11:03:27 <suppi> brb
11:08:52 <flxw> suppi: In how far can haskell types influence the build time? (if I understood your comment correctly) 
11:08:56 <suppi> davean: i don't mind that you have a method to work without these features, if it works for you that's great! I just know for certain that i'm more productive when i do use them, and i can tell you that these features can become a lot more stable than they are currently are
11:09:13 <davean> suppi: I stopped using them *to become more productive* actually
11:09:37 <davean> suppi: Those features deminish my ability to be productive
11:10:22 <suppi> flxw: you can compile a project to get errors or you can let the editor tell you immediately
11:10:32 <sm> Cale: how far off "nix in haskell" is propellor ?
11:10:33 <suppi> davean: that's great, but i'm not you.
11:10:40 <sm> quite far I guess
11:11:12 <davean> sm: unrelated
11:11:14 <suppi> if this works for you for the better, great. it's not like i have a problem with that or anything :)
11:11:29 <flxw> suppi: ah, you're talkingabout incremental compilation like for some flychecks? 
11:11:46 <davean> suppi: Of course, I would suggest you wouldn't really know without more deeply examaning and testing your developement though 
11:11:54 <suppi> flxw: i'm just talking about programming with flychecks or without
11:12:31 <suppi> davean: i have done (and doing) both so i can compare
11:12:43 <davean> suppi: for long enoguh to adapt?
11:13:36 <davean> I just find people don't usually actually try it
11:13:44 <davean> they do it, and then they assume its like it feels
11:13:55 <davean> Which is how people try most new things
11:13:56 <suppi> sigh, can you please not analyze me? i don't see the point
11:14:17 <davean> whatever
11:14:21 <suppi> thank you
11:15:37 <flxw> usually, people without IDE think of people with IDE as strange creatures. ;))
11:16:55 <kubunto> how do i make an element optional in a data constructor?
11:16:56 <ertes> sm: i don't think they can be compared as easily as gabriel would like
11:17:16 <ertes> kubunto: if the element is of type A, make it of type (Maybe A) instead
11:17:40 <ertes> kubunto: alternatively add an additional constructor without that element
11:18:11 <ertes> data MyType = Ctor1 (Maybe A) B | Ctor2 C D
11:18:23 <ertes> data MyType = Ctor1 A B | Ctor1WithoutA B | Ctor2 C D
11:19:54 <whiteline> using maybe is a lot more semantically consistent and sense-making in general though
11:20:15 <flxw> Do I understand the attoparsec documentation right, that when I feed a parser a few hundred MB, that it will hold onto them until the parse finishes, even if I feed them incrementally?
11:20:35 <ertes> whiteline: no, they are the same thing (up to bottoms)
11:21:25 <davean> flxw: Depends on your parser
11:21:32 <ertes> whiteline: (Maybe A)*B + C*D ≃ (1 + A)*B + C*D ≃ B + A*B + C*D
11:22:20 <flxw> *MBs of Text, but it guess that is not important.
11:22:57 <ertes> flxw: make sure your (<|>)s are sufficiently local
11:23:09 <ertes> or use trifecta
11:23:22 <ertes> which gives you control over backtracking the way parsec/megaparsec do (using 'try')
11:23:23 <davean> flxw: see https://hackage.haskell.org/package/attoparsec-0.13.1.0/docs/src/Data-Attoparsec-Internal-Types.html#Parser
11:23:49 <glguy> If the result of your parse contains most of that few hundred MB of text, then it will certainly stick around
11:23:59 <davean> which is to ertes' point, you see how it handles backtracking there?
11:24:14 <davean> and you need appropriate strictness also
11:24:27 <flxw> wait, I read slowly. :)
11:26:12 <flxw> aha, I beleive I see. Okay, I don't have any <|> in my parser, which might help.
11:26:18 <kubunto> ertes: how would i pattern match on a maybe?
11:26:27 <ertes> another thing to keep in mind is that ByteString uses shared slices of memory…  if you need to keep some of the input around as the result of your parse, you might want to 'copy' it
11:26:36 <ertes> kubunto: pattern-matches can be nested
11:26:47 <ertes> case x of Ctor1 (Just x) y -> …
11:27:09 <ski> @src Maybe
11:27:09 <lambdabot> data Maybe a = Nothing | Just a
11:27:09 <ertes> flxw: note that (<|>) may be implicit, if you use stuff like 'optional' or 'many'
11:27:20 <davean> flxw: or any other choice operations?
11:27:33 <ertes> flxw: basically: make sure choice is local
11:27:47 <flxw> glguy: No, it shouldn't. I'm sumarising the parse heavily.
11:28:10 <glguy> flxw: OK. Make sure those summary values are being forced, too
11:28:43 <davean> flxw: You may want to apply strictness to your datastructure as you parse it, in theory it sometimes can be a thunk to the bytestring, but thats not often an issue
11:29:14 <davean> flxw: you likely won't have any issues though
11:29:23 <davean> flxw: and from what you say, any issue you do run into should be easily fixed
11:29:42 <ertes> i really wonder if attoparsec is actually faster than trifecta…  i wouldn't be surprised if it's actually slower
11:29:50 <davean> flxw: Making your datastructure strict would be likely good in this case
11:29:56 <davean> ertes: test it!
11:30:07 <davean> ertes: Can you explain your theory?
11:30:28 <flxw> okay, so much to keep in mind, I'll make a list and proof-read the code for each single of them. :)
11:30:55 <ertes> davean: if you look at the implementations, trifecta uses full church encoding
11:31:06 <davean> yes, I've read it
11:31:36 <ertes> that alone is an advantage…  other than that it doesn't do much differently, except that it has error reporting
11:31:55 <flxw> From what I collected from experienced haskellers, "be strict in the leaves and lazy in the spine", yes?
11:32:01 <davean> ertes: I don't know that its much of an advantage here, and it carries around a lot more data
11:32:19 <davean> ertes: in far more complicated data structures
11:32:30 <ertes> davean: it is, because it makes sure that stuff like 'many' is still right-associated
11:33:16 <davean> ertes: well, I think we have to seperate out theoretical worst cases and practice here at that point
11:33:32 <kubunto> ertes: tyvm
11:33:55 <ertes> davean: of course…  it's just a theory
11:34:00 <flxw> I chose attoparsec because the interface looked simpler than trifecta (^^), and I'm mainly reading lots of machine generated data.
11:34:49 <davean> ertes: Hum, it would be interesting to have a json parser in trifecta to compare ...
11:34:54 <davean> ertes: one often does want the error reporting there
11:35:38 <ertes> davean: actually i think the error reporting may be almost for free (you still pay GC), if you don't actually use the resulting error data
11:36:03 <ertes> and yeah, may be worth benchmarking
11:36:16 <davean> ertes: "almost" when talking about tight loop parsers makes all the difference
11:36:38 <davean> ertes: No one could claim that aeson wasn't tuned to its parser
11:37:08 <ertes> while we're at it, we could replace aeson by something that supports comments =)
11:37:40 <kubunto> pattern matching is fun
11:37:41 <davean> ertes: Uh, how?
11:37:44 <Cale> flxw: If you want to stream stuff, that sounds good. Sometimes you might want a datastructure to work the other way, for example, Data.Map(.Lazy) will tend to have operations on the spine of the structure all be strict (especially as they need to make comparisons), but you can store values in the Map which aren't yet evaluated, and sometimes that's actually helpful.
11:37:52 <davean> ertes: supporting comments would mean it wasn't JSON
11:38:01 <qmm> if i have a list like this, how can i execute it :) [print "foo", print "bar", print "baz"]
11:38:10 <Cale> qmm: sequence_
11:38:17 <ertes> davean: yeah, you might be right
11:38:29 <qmm> thanks Cale 
11:38:34 <ski> @src mapM_
11:38:35 <lambdabot> mapM_ f as = sequence_ (map f as)
11:38:36 <ski> qmm ^
11:38:44 <Cale> (the _ at the end is a convention which means "please discard the results, I don't care about them")
11:38:48 <davean> ertes: You could replace it with something that, optionally, allowed a comment format
11:38:51 <ski> @src forM_
11:38:51 <lambdabot> forM_ = flip mapM_
11:38:56 <Cale> Yeah, you probably actually want mapM_ or forM_
11:38:56 <davean> ertes: but almost no JSON parser would accept that json
11:39:29 <Cale> mapM_ print ["foo", "bar", "baz"]
11:39:49 <ertes> davean: regarding the benchmark…  JSON might be too simple, because all choices can be based on single characters…  something like IRC might be a better option
11:39:57 <Cale> forM_ ["foo", "bar", "baz"] $ \x -> print x
11:40:13 <ski> (often with a `do' after the `->')
11:40:31 <davean> ertes: Given what most machine-encoded data looks like, that is what one would expect from any format that is the target of attoparsec?
11:40:36 <ertes> although IRC is pretty simple, too…  perhaps a minimal imperative programming language
11:40:58 <ertes> davean: attoparsec is often used for text protocols, too
11:41:15 <davean> ertes: JSON is a text protocol
11:41:33 <ertes> davean: the point is to get a few string matches in there as well
11:41:44 <davean> machine-readable text protocols tend to be straight through
11:41:55 <davean> fixed-lookahead at most
11:42:00 <davean> take for example HTTP
11:42:22 <davean> Thats about the most difficult to parse machine protocol I can think of off the top of my head
11:42:44 <Tuplanolla> Think printer communications, davean.
11:43:00 <davean> Tuplanolla: PostScript?
11:43:05 <flxw> xml?
11:43:25 <ertes> yeah, unfortunately some people thought XML would be a sensible protocol and made XMPP
11:43:26 <davean> flxw: xml is no harder to parse then HTTP in any way I can think of
11:43:36 <ertes> and unfortunately, like most terrible choices, it became popular
11:44:01 <flxw> ertes: sigh.
11:44:02 <davean> flxw: again, fixed lookahead
11:44:19 <davean> I guess it needs a stack
11:44:24 <ertes> XML is fixed look-ahead, if you do semantics after the parse
11:44:27 <davean> if you do DOM style
11:44:43 <ertes> <x:y xmlns:x="…"> …
11:45:15 <ertes> if you do it right away, it actually becomes undecidable, as far as i can tell
11:45:59 <ertes> > "<x:y" ++ repeat ' '
11:46:01 <lambdabot>  "<x:y                                                                       ...
11:46:07 <ertes> you will never know what this means =)
11:46:55 <davean> ertes: you'll reach the end of the input and it'll be invalid?
11:48:10 <ertes> davean: where is the end?  you have a network protocol and a streaming parser…  your parser cannot decide the branch until you have received the namespace information
11:48:22 <kubunto> how do i compile something that has derive directives?
11:48:29 <davean> ertes: as soon as the input ends, you know its invalid
11:48:53 <ertes> kubunto: the same way you compile something without them
11:49:01 <davean> ertes: you can't finish validating XML untill end-of-document anyway
11:49:15 <ertes> davean: i'm talking about XMPP
11:49:22 <kubunto> ertes: it doesnt work
11:49:23 <davean> ertes: Oh
11:49:37 <davean> kubunto: then something is wrong with the code?
11:49:45 <davean> kubunto: can you expound on "it doesn't work"?
11:49:50 <ertes> kubunto: feel free to paste your source code at lpaste.net…  be sure to include the error message as well
11:49:56 <kubunto> not in scope
11:50:25 <davean> ... whats not in scope?
11:50:34 <Tuplanolla> @paste
11:50:35 <lambdabot> Haskell pastebin: http://lpaste.net/
11:50:37 <Tuplanolla> Now in scope.
11:51:29 <kubunto> davean: line 1, foldable and traversable not in scope http://lpaste.net/353030
11:51:49 <davean> kubunto: well, import them
11:52:03 <kubunto> davean: ?
11:52:07 <davean> You can't derive what you haven't defined
11:52:20 <davean> You have no definition for Traversable or Foldable
11:52:28 <kubunto> how do i import
11:52:33 <ertes> kubunto: by standard those classes are not derivable anyway…  you will need to add the following line at the top of your file:  {-# LANGUAGE DeriveFoldable, DeriveTraversable #-}
11:52:34 <davean> https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Traversable.html
11:52:38 <davean> import Data.Traversable
11:52:55 <davean> https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Foldable.html
11:53:11 <ertes> kubunto: also you may want to upgrade your GHC
11:53:26 <ertes> which version are you using?  ghc --version
11:54:10 <kubunto> ertes: 7.6.3
11:54:26 <davean> Oh my thats ancient
11:54:31 <ertes> kubunto: that is ancient…  i strongly recommend that you upgrade at least to 7.10, even better 8.0.1
11:54:42 <davean> 8.0.2
11:54:46 <kubunto> ok, how do i do that
11:54:53 <ertes> kubunto: which OS?
11:54:59 <kubunto> raspbian
11:55:04 <davean> kubunto: your compiler is from 21 April 2013
11:55:47 <ertes> kubunto: does raspbian offer newer versions?
11:55:55 <kubunto> not a clue
11:56:08 <davean> Isn't that a Debian?
11:56:09 <ertes> kubunto: a distribution upgrade might already come with a newer GHC
11:56:19 <davean> Debian packages newer
11:56:28 <ertes> hehe yeah
11:56:32 <kubunto> ertes: dont think raspberry pi people usually venture into haskell
11:56:47 <ertes> but i can't promise, because debian is known to distribute ridiculously outdated stuff =)
11:56:48 <davean> if that *is* debian, you can use the Debian arm repo to get a newer GHC
11:57:05 <kubunto> davean: it is derivative made for the pi yes
11:57:07 <davean> ertes: I can promise, I've been dealing with GHC builder stuff all week :)
11:57:24 <davean> ertes: I'm slightly more familiar with which distros package what then I'd like
11:58:03 <ertes> i'm glad that i don't have to care most of the time =)
11:58:19 <davean> Infact, I've recently compiled a fresh version of GHC for the Pi, but its a pre-8.2 and I didn't save the artifact as it was part of a build system test
11:58:27 <sjakobi> kubunto: It seems that stack offers a GHC-8.0.2 that might be compatible: https://raw.githubusercontent.com/fpco/stackage-content/master/stack/stack-setup-2.yaml
11:59:03 <sjakobi> Is your architecture armv7?
11:59:10 <davean> sjakobi: yah, it would be
11:59:20 <kubunto> davean: you dont know that silly
11:59:27 <kubunto> but you just happen to guess right
11:59:29 <davean> kubunto: Uh, yes I do :-p
11:59:42 <kubunto> davean: what is the arm on rpi 2?
11:59:50 <davean> armv7l
12:00:00 <davean> specificly 1
12:00:03 <davean> er, specificly l
12:00:08 <davean> if you want to get technical
12:00:26 <sjakobi> kubunto: Try https://haskell-lang.org/get-started
12:00:50 <sjakobi> Then  execute: stack setup --resolver lts-8
12:01:15 <kubunto> sjakobi: ill look into it once i clean up all these shows
12:02:06 <davean> kubunto: or https://packages.debian.org/search?keywords=GHC&searchon=names&suite=all&section=all
12:02:28 <davean> 7.10.3 is in backports for your arch, and 8.0.1 is available
12:02:51 <kubunto> well my pi feels like being a little pain in the ass atm
12:03:12 <davean> kubunto: also, if you're curious, its a hardfloat variant
12:03:24 <kubunto> im not :P
12:03:42 <davean> (I'm mildly confused about why you'd think I couldn't know what CPU a rpi had)
12:04:00 <davean> (Its not like there were options for its ISA)
12:04:09 <davean> (Its not armv8/aarch64)
12:04:12 <kubunto> davean: because there is a difference between the pis in terms of cpu power
12:04:17 <davean> kubunto: meaningless
12:04:22 <davean> I didn't say I knew its speed
12:04:31 <ertes> davean: they might have etched the CPU out and soldered a new one onto it
12:04:50 <kubunto> or they may have also changed the arch to help improve things
12:04:52 <davean> ertes: all pin compatible CPUs are armv7 at least
12:05:02 <davean> kubunto: nope, they can't do that
12:05:09 <davean> kubunto: tehy can't change the arch
12:05:13 <davean> thats not really an optoin
12:05:31 <ertes> they might have rewired the CPU before soldering
12:05:44 <davean> ertes: That would be rather a project ;)
12:05:46 <kubunto> davean: why not?
12:05:55 <davean> kubunto: because of how CPUs work
12:06:02 <ertes> sure, but you know those hackers =)
12:06:33 <kubunto> davean: compatibility would be broken between pis but so what
12:06:39 <ertes> don't underestimate a curious mind =)
12:06:43 <davean> kubunto: its worse then that
12:07:07 <davean> kubunto: consider which ISAs are available for ARMs
12:07:17 <kubunto> davean: ISA?
12:07:19 <davean> theres really only two, armv7 and armv8
12:07:25 <davean> kubunto: instruction set archnitecture
12:07:36 <davean> kubunto: There exist other arm ISAs but they're obsolute
12:07:48 <kubunto> like sub and str?
12:07:51 <davean> armv7 and armv8 are radically different
12:08:10 <flxw> After having backtracking out of the way, my other thought was to feed the attoparsec based parser incrementally. But since it is a simple project, I'd rather not use a serious solution like Conduit or Pipes. (attoparsec uses strict Text). My idea was to run the parser using parseWith together with something simple,  based on e.g. take 32K lazy_lazy_Text_input. Does this sound like a very bad idea, or just bad?
12:09:04 <flxw> s/lazy_//
12:09:19 <davean> flxw: feeding chunks with parseWith is basicly what pipes or conduit, or machines would do
12:09:35 <davean> You're just doing it manually
12:09:45 <davean> (I'm not entirely clear on why, but if it works well for your code, do it?)
12:10:09 <davean> kubunto: sub and str?
12:10:14 <davean> kubunto: what are you talking about?
12:10:21 <flxw> oh, it just, I haven't used Pipes yet, and the types frighten me a little.
12:10:34 <ertes> flxw: https://hackage.haskell.org/package/attoparsec-0.13.1.0/docs/Data-Attoparsec-ByteString.html#g:2
12:10:36 <davean> flxw: they shouldn't, and thats fine, don't use them
12:10:59 <davean> kubunto: do you mean the assembly instructions?
12:11:16 <kubunto> yea
12:11:24 <kubunto> or are they different things
12:11:34 <davean> ertes: so I've spent a bit thinking about what one would have to do to wire an aarch64 into an rpi, and its kinda amazing how difficult that might be
12:11:59 <davean> kubunto: those are the names of instructions, at the assembly level, but the semantics and how they're actually encoded on the machine are different
12:12:20 <davean> kubunto: both ISAs will have those instructions, though not all the same instructions, and armv8's are 64 bits not 32bits
12:12:26 <ertes> davean: of course…  i was just joking =)
12:12:29 <davean> kubunto: but such instructions do for a *small* part of the ISA
12:12:39 <davean> ertes: I understand, but I considered it seriously
12:12:43 <davean> ertes: its doable of course ...
12:12:56 <davean> well, I say of course, I'm a touch worried about the timing issues
12:12:57 <flxw> thank you all for the nice input. I'll log off.
12:13:24 <ertes> although i'm pretty sure someone from the folks who visit conventions like defcon or chaos communication congress has figured it out already
12:15:08 <davean> kubunto: anyway, the only archs of arm one really can get their hands on these days are armv7 or armv8, there are a few armv7 variants - hard and soft float, which endian it is running in
12:15:38 <davean> so I can tell you your endian because you're running linux on it
12:15:57 <kubunto> davean: yea i am not that deep into the hardware
12:16:06 <ertes> linux can't run on big endian?
12:16:11 <davean> I can tell you which version you are because none of the armv8 options would remotely fit that board - they're primarily server chips ATM
12:16:28 <davean> ertes: linux can, but the ports for it to big endian are limited
12:16:37 <ertes> ah
12:16:41 <davean> ertes: and arm isn't among them
12:16:46 <davean> and I know its an arm CPU
12:17:12 <davean> I think x390x is a big-endian port?
12:17:14 <ertes> why do they even bother making big endian hardware anyway?
12:17:15 <davean> *s390x
12:17:26 <davean> ertes: why do they bother making little endian?
12:17:47 <kubunto> pattern matching is epic
12:18:14 <MarcelineVQ> kubunto: :>
12:18:19 <ertes> little endian is far more widespread, and intuitively it also makes more sense to me, because it's not sensitive to word widths
12:18:21 <davean> ertes: I mean, to some degree the answer is "big endian is what everone used, and its more linear so the network layer got defined in it"
12:18:31 <ertes> need a longer word?  just append a bunch of zeroes
12:19:06 <davean> ertes: you think little endian is more widespread? Hum, thats an interesting question
12:19:16 <davean> I mean, clearly biendian is the most widespread
12:19:29 <ertes> well, to be fair, i don't know much about embedded hardware…  i might be wrong
12:19:34 <davean> the only non-biendian CPU of any scale (leaving asside AVR and the like) I can think of is x86 based
12:19:47 <davean> POWER, arm, mips, all biendian
12:20:01 <davean> I'm not sure which mode most MIPS are run in
12:20:38 <davean> arm varies by application of course
12:20:51 <davean> Really, the only little-endian systems are x86/amd64
12:21:27 <davean> ertes: I mean, everything starts big endian?
12:21:38 <davean> ertes: so you end up little endian if you grow but don't change
12:21:50 <davean> big endian is what you get if you design for what you end up
12:22:11 <ertes> not sure what you mean
12:22:22 <monochrom> I know the answer.
12:22:45 <monochrom> Big endian is designed by left-to-right language users. Small endian is designed by right-to-left language users.
12:22:45 <davean> ertes: I'm not saying something inherantly true
12:23:06 <davean> ertes:but, look at it as bit patterns instead of byte patterns
12:23:32 <monochrom> You should write your bits in small endian order, too :)
12:23:48 <monochrom> Fourteen is 0111 :)
12:23:50 <davean> monochrom: as I said, what I said wasn't inherantly true
12:24:06 <davean> it just happens to be true of everyone who's designed a notable CPU
12:24:18 <ertes> the reason i think little endian is genuinely superior is that digits retain their relative positions in the word, regardless of word size, so conversion can be cheap or even free
12:24:22 <monochrom> I understand.
12:24:22 <ertes> with big endian it's never free
12:24:29 <davean> ertes: Not really!
12:24:44 <davean> ertes: the BYTES retain their possition
12:24:47 <davean> ertes: the bits don't
12:25:48 <dolio> Relative positions don't change either way, no? It's just a question of where the padding goes.
12:25:56 <ertes> yeah, exactly
12:26:07 <ertes> the bit positions are only relative to the byte
12:26:18 <davean> dolio: no, the bits in a byte are the oposite order usually
12:26:27 <davean> ertes: They're relivent though because of things like carry operations
12:26:34 <ertes> davean: that's an implementation detail
12:26:47 <davean> ertes: its litterly the part that matters
12:27:10 <dolio> davean: But if you promote to a larger integer type, you don't need to shuffle the bits around. Or reorder the bytes.
12:27:11 <ertes> the way bits are ordered within a byte shouldn't even be visible to the user, unless there are special instructions that are order-sensitive
12:27:22 <davean> dolio: shift vs. shuffle
12:28:02 <ertes> memory is byte-addressed after all, and you can only ever fetch/write a whole byte
12:28:41 <davean> Your memory is byte addressed :)
12:28:58 <monochrom> How do I use software to observe bit order?
12:29:24 <ertes> davean: let's assume that bit order matters…  then in a LS-ordered arch the LSB should be the one with index 0…  then again conversion can be free
12:29:41 <ertes> with MSB ordering it's never free
12:29:48 <ertes> you always need at least a shift
12:30:02 <davean> Not if you're a L/S arch
12:30:10 <davean> then its always a store and you just pick where you store
12:30:15 <davean> (most arch are load/store)
12:32:03 * ski thought memory was accessed in words ..
12:32:30 <davean> ski: I don't know of any modern archs that do that
12:32:40 <davean> I think I only know of a single arch that ever did it at all
12:32:55 <dolio> It's accessed in cache lines.
12:33:06 <max3> does http work in ghci? meaning if i have an app that exposes an http server will that work if i interpret in ghci?
12:33:20 <ertes> max3: yes
12:33:21 <davean> max3: yes but ...
12:33:25 <max3> but what?
12:33:28 <davean> max3: you might want to fork it
12:33:32 <monochrom> Depends on who wrote the http server.
12:33:55 <ertes> max3: if it doesn't work, the implementation is crap and you should use a different one =)
12:34:02 <max3> indeed it doesn't work
12:34:09 <max3> i get no exceptions but i can't hit localhost:port
12:34:16 <ongy> monochrom: bit order can be relevant when implementing network protocols. There's some fancy #ifdefs in linux code for this.
12:34:24 <davean> max3: are you sure it bound localhost?
12:34:37 <ertes> max3: which HTTP server/web framework?
12:34:37 <max3> pretty sure?
12:34:40 <max3> warp
12:34:49 <davean> warp definately works in ghci
12:34:51 <ertes> warp works in GHCi
12:34:56 <lispy> I can't tell if this is satire: https://hackage.haskell.org/package/bizzlelude
12:35:11 <max3> another haskell mystery!
12:35:22 <monochrom> long time no see lispy!
12:35:37 * lispy goes back into witness protection
12:35:45 <ertes> lispy: either that or the product of a misguided soul =)
12:35:50 <qwerasdf> hello?
12:35:58 <ertes> qwerasdf: hello!
12:36:04 <monochrom> I don't like (|>)
12:36:06 <lispy> monochrom: er, I mean hello :)
12:36:22 <vlnts> I am learning haskell and want some good integration with vim - what are people using ? 
12:36:30 <max3> haskell-vim-now
12:37:00 <ertes> vlnts: if you want good vim integration, use emacs + evil-mode + haskell-mode =)
12:37:05 <ertes> vlnts: just joking, SCNR
12:37:14 <max3> what's scnr?
12:37:24 <ertes> Sorry, Could Not Resist
12:37:31 <ongy> I started with haskell-vim-now and then built my own from that. But to be honest, some things are a bit buggy with my setup and I don't care enough to fix them...
12:38:17 <lispy> vlnts: I use a very simple haskell mode in my vim and then I stick the vim inside a tmux and have another panel open to the command line. I do all the IDE sorts of things with the command line instead of vim. YMMV.
12:38:38 <riddle_> hey everyone, my first time using IRC, ! :)_
12:38:48 <lispy> riddle_: congrats and welcome to #haskell
12:39:00 <riddle_> @lispy, thanks :)
12:39:00 <lambdabot> Unknown command, try @list
12:39:04 <max3> speaking of which: are there any haskell stack channels?
12:39:10 <Tuplanolla> I have this lazy Vim binding for small things.
12:39:31 <Tuplanolla> `:noremap <F12> :wall \| !ghci +RTS -M512M -RTS -Wall -v0 %<CR><CR>`
12:39:33 <vlnts> I have a pretty big vimrc already - do you suggest I keep a seperate config for haskell ?
12:39:34 <riddle_> gonna try XMonad. Sorry for dumb question. Is it a given that haskell-fan uses it, or not :D
12:39:52 <max3> try quicktile instead
12:39:54 <riddle_> Not trying to stereotype or favorite any distro
12:40:04 <ongy> not really. the percentage may be higher, but it's still low-ish
12:40:05 <ski> riddle_ : fyi, there is #xmonad, if you have questions about it
12:40:11 <riddle_> *window manager, not distro I mean
12:40:17 <ertes> riddle_: it's not a given, and the user base of xmonad is quite varied these days
12:41:06 <vlnts> lispy: I am also in tmux and in awesome wm.
12:41:51 <ski> max3 : presumably #haskell-stack ?
12:41:54 <riddle_> okey, got it, thanks :)
12:42:00 <ertes> of course if you're a haskell programmer, you can benefit a lot from using xmonad
12:42:00 <max3> if i'm stopped at an exception in ghci how do i see what the exception message is?
12:42:15 <max3> whoops i meant slack
12:42:16 <max3> not stack
12:42:21 <monochrom> I don't use xmonad. I am not sold on tiling.
12:42:28 <Sornaensis> tiling is great
12:42:30 <Sornaensis> xmonad is not
12:42:37 <Clint> they are both pretty great
12:42:40 <monochrom> Actually I am not sold on being less lazy than I am.
12:42:42 <Sornaensis> auto tiling kind of defeats the strength of tiling
12:42:46 <Sornaensis> imo
12:42:51 <ertes> monochrom: xmonad actually does support overlapping, if that's what you prefer, but it's underdeveloped
12:42:51 * ski seldom tiles within GNU Screen
12:42:59 <max3> monochrom, try quicktile
12:43:25 <monochrom> No, ubuntu defaults work fine for me, I am not less lazy than I am.
12:43:46 <Tuplanolla> I tried Xmonad once and it was not a good experience.
12:43:48 <max3> it's not a window maanger
12:43:49 <Sornaensis> i3 imo is excellent for general purpose workstation needs
12:43:55 <monochrom> Yes yes I know that ubuntu works me alone, it breaks for all of you.
12:44:19 <ertes> i don't like xmonad, but i use it mainly because i'm too lazy to see which of the other WMs support my workflows
12:44:27 <Tuplanolla> http://tuplanolla.no-ip.org/tmp/hello-xmonad.png
12:44:30 <vlnts> I love tiling(awesome) but uses tmux over multiple terminals. Can't get my head around the idea of terminal inside neovim
12:44:40 <monochrom> OTOH I am not lazy enough to "apt-get install ghc". I go over to Haskell Platform.
12:45:00 <Tuplanolla> It also flickered, but you can't see that in the image.
12:45:20 <Sornaensis> vim is not supposed to be emacs :p
12:45:56 <monochrom> Some people use C-x C-2 for window manager :)
12:46:01 <max3> i swear i'm going to shoot myself over this Paths_ nonsense
12:46:15 <ertes> monochrom: C-x 2
12:46:22 <monochrom> Oh oops :)
12:46:35 <ski> Tuplanolla : Luvely Jubly
12:46:44 <riddle_> not trying to divert the topic from haskell, but talking about WMs, is there any good non-tiling (stacking I think) ligthweight WM? Been using Openbox for a year, but thinking trying something different 
12:47:07 <lispy> max3: what is your Paths_ problem?
12:47:16 <monochrom> Knuth uses fvwm.
12:47:24 <Sornaensis> riddle_: enlightenment is alright and fairly lightweight
12:47:33 <ski> lispy : long story in backlog
12:47:41 <riddle_> I mean I know there is, but just haven't talked to anyone about it since mostly people around me stick to Ubuntu
12:47:46 <riddle_> and its defaults
12:48:08 <monochrom> lispy: Also old nickname was Guest82102
12:48:15 <ertes> if it wasn't for xmonad i would still be using compiz
12:48:27 * ski added focus-follows-mouse-no-really
12:49:28 <lispy> when I use a wm in linux these days, I tend to just use xfce beacuse it's easy and I'm going to use a fullscreen terminal with tmux and like a browser and that's probably it.
12:50:04 * ski . o O ( "FOCUS THEFT SHOULD BE A FELONY", Riastradh, 2011-05-09, <https://mumble.net/~campbell/blag.txt> )
12:57:14 <lispy> Has anyone here worked through Harrison's Handbook of Practical Logic in Haskell or otherwise?
12:58:31 <lispy> I've just read the first chapter and skimmed the later ones to see what topics they cover. It seems like a really good introduction to applied logics.
12:58:51 <riddle_> (BTW) thanks for responses guys!
13:02:27 <monochrom> lispy: I did not, but I googled and found https://github.com/andre-artus/handbook-of-practical-logic-and-automated-reasoning-haskell
13:03:11 <Guest34608> dumb question - when asked to express `foldl` using `foldr` why not just do something like `foldl f e = foldr (flip f) e . reverse`?
13:04:38 <monochrom> Can you make it work for infinite lists too?
13:04:49 <johnw> > foldr (+) z [a, b, c]
13:04:52 <lambdabot>  a + (b + (c + z))
13:04:53 <johnw> > foldr (flip (+)) z (reverse [a, b, c])
13:04:55 <lambdabot>  z + a + b + c
13:05:10 <lyxia> foldl doesn't work for infinite lists anyway
13:05:13 <monochrom> Ah, that's better.
13:05:18 <lispy> monochrom: nice. I was mostly curious what others thought of the book. I've been enjoying it. My following-along-implementation is in Rust instead of Haskell, but that's more because I'm trying to branch out and learn Rust.
13:05:57 <Guest34608> > foldl (+) z [a, b, c]
13:05:59 <lambdabot>  z + a + b + c
13:06:27 <lispy> lyxia: you can make a foldr in terms of foldl that works on infinite lists (assuming you only take a finite prefix and all that)
13:07:08 <lispy> I no longer recall how to do it, but I'm pretty sure I've seen the solution.
13:07:10 <ski> lispy : i don't see how that could possibly work ..
13:08:03 <Guest34608> yeah makes sense -- I assumed the lazy behavior was the difference but didn't spend enough time on it
13:12:44 <ertes> lispy: i'm pretty sure that's impossible
13:13:25 <johnw> I also have a feeling that that definition of foldl would make fusion very hard
13:14:33 <lispy> Well, if you can make it work the trick will be to give the passed in function control before the recursive call to foldl
13:14:45 <ertes> lispy: you can write foldl and foldl' in terms of foldr though…  perhaps you thought of that?
13:15:19 <ski> that's what Guest34608 was asking about
13:17:38 <vlnts> I am not really convinced haskell-vim-now is what I want. It blasts my current vimrc and replaces it with a new one under a different git repo than my current dot-files ?
13:19:44 <maerwald> yeah, it's crap... just take a look at the plugins it installs and do things properly
13:22:47 <lyxia> Say I have a profunctor P, which is also an applicative (meaning there is an instance Applicative (P x)), obeys the law and all. Does parametricity give us: lmap f (a <*> b) = lmap f a <*> lmap f b?
13:24:32 <lyxia> I realize I actually don't know what parametricity results exist in the presence of consstraints like applicative/monad laws...
13:25:02 <lyxia> But maybe you guys have counterexamples?
13:26:17 <merijn> Two, related questions: 1) Anyone have any handy wrappers for using criterion to benchmark concurrent code/primitives? 2) What's the best way to get a set of threads to wait for a "go" signal? Just have everything blocking on readMVar?
13:26:50 <dolio> lyxia: I think it does, yes.
13:27:00 <lispy> ski, ertes: alright. I guess I misremembered that case. I thought you could do it with a clever choice of a wrapper around f in the call to foldl, but it seems I was mistaken.
13:31:26 <ertes> merijn: or a TVar Bool, but an MVar is probably much faster
13:31:31 <lyxia> dolio: Great thanks! Now I'm thinking maybe it doesn't matter that I have an Applicative, and parametricity of (<*>) is sufficient.
13:31:58 <kyclark> I have two questions re: stack.  How can I change the build directory from my $HOME?  How can I change stack to use 8.0.2 by default when I do “stack ghci”?  Sorry, but I can’t find the answers online.
13:32:19 <merijn> And I don't suppose in the past weeks where I didn't look someone patched criterion to allow per-benchmark setup/cleanup?
13:32:32 <sm> kyclark: for the second, set resolver: lts-8.2 in ~/.stack/global/stack.yaml
13:32:47 <sm> or 8.3, even
13:33:06 <sm> for the first, what do you mean ?
13:33:14 <dolio> lyxia: Yeah, it has nothing to do with Applicative.
13:33:35 <ertes> merijn: you mean per-iteration?
13:33:41 <merijn> ertes: Yeah
13:33:50 <ertes> i don't think that's possible with criterion
13:34:02 <merijn> ertes: Well, not yet :p
13:34:11 <kyclark> On an HPC machine, I’m running out of disk in my $HOME when I try to build the latest GHC, so I want to tell stack to build out of the /scratch dir.
13:34:16 <merijn> It didn't look particularly complex to write, but I was hoping to not have too xD
13:34:47 <ertes> merijn: if it literally uses linear regression on time, then it might be a bit more complicated than it sounds =)
13:35:44 <merijn> ertes: I looked at the implementation and the main reason it's not there appears to be "we didn't need it and wanted to avoid the potential overhead"
13:39:53 <merijn> ertes: hmmm, actually, you might be right
13:39:55 <merijn> rats...
13:42:14 <merijn> That's kinda annoying...
13:42:27 <merijn> So, any alternatives to criterion for benchmarking?
13:43:22 <ertes> merijn: you could add virtual time to criterion
13:43:40 <merijn> virtual time?
13:43:40 <ertes> it doesn't seem to insist on a particular notion of time
13:43:52 <ertes> yeah, like real time, but with initialisation time subtracted
13:44:43 <merijn> that's rather messy, because then I need to intersperse timings within that total timer and somehow track them
13:44:56 <dolio> lyxia: The way you can tell is...
13:45:03 <dolio> @free ap :: F x -> F x -> F x
13:45:03 <lambdabot> $map_F f . ap x = ap ($map_F f x) . $map_F f
13:45:06 <ertes> that would also let you performGC between iterations without counting the overhead (performGC is pretty expensive)
13:46:22 <merijn> ertes: Baically, I wanna benchmark Chan/TChan, etc. performance, but I'm not happy with the existing benchmarks of, e.g. unagi-chan. They're rather simplistic...
13:47:07 <ertes> merijn: well, criterion's main contribution is the statistical stuff (and some care not to optimise the benchmark away)
13:47:23 <ertes> on IO you don't have to be that careful, and the statistical stuff you could do yourself using the 'statistics' package
13:47:34 <merijn> but there's two problems with criterion: 1) how do I prevent chan contents from being prematurely GCed (which a cleanup would handle), and how do I allocate a new Chan for every test (avoiding build up and heap expansion)
13:48:01 <merijn> ertes: I like the pretty html criterion generates, though!
13:48:20 <ertes> is building a Chan that expensive?  i would expect it to be on the order of a newTVar
13:48:42 <merijn> ertes: No, but you need to do other setup, i.e. pre-launching threads for concurrent reader/writer tests
13:48:42 <ertes> so it should barely make a difference, if your actual benchmark is complex enough
13:49:10 <merijn> ertes: My benchmark is just, concurrent reads, writes, reads+writes for different numbers of readers and writers
13:49:31 <ertes> merijn: you could use a TVar (Chan …)
13:49:54 <ertes> then you can create the threads outside of defaultMain and just change the channel
13:49:58 <merijn> because e.g., unagi-chan is only benchmarking equal numbers of readers and writers and directly reading and writing in the same thread
13:50:19 <merijn> ertes: If you don't empty the Chan in between benchmarks your heap explodes and so does your GC time
13:50:33 <merijn> ertes: Which means later benchmarks become increasingly unreliable
13:50:56 <ertes> merijn: i mean: create a new TChan, then update the TVar to let the pre-existing threads use the new TChan
13:51:15 <ertes> but yeah, GC might be noticable
13:51:19 <lyxia> dolio: is it fine that F is contravariant?
13:51:53 <dolio> Yes, it would just be contravariant map. @free assumes everything is covariant.
13:52:22 <dolio> And adding the second parameter would just add more things you can do to it that you don't care about.
13:52:30 <dolio> (And @free doesn't support two parameters.)
13:52:43 <merijn> ertes: that introduces STM overhead even for the non-STM stuff too
13:53:00 <ertes> merijn: you can use an IORef instead of a TVar =)
13:53:06 <ski> @free mirror :: Either a b -> Either b a
13:53:07 <lambdabot> $map_Either g f . mirror = mirror . $map_Either f g
13:53:23 <ertes> merijn: it's the best solution i can think of without patching criterion
13:53:30 <dolio> Oh, I guess it supports some two parameter stuff.
13:53:48 <ertes> merijn: what you could do is to do the benchmarking code yourself, but then generate a criterion report and use its reporting functions
13:54:06 <ski> @free sigma :: F a b -> F b a
13:54:06 <lambdabot> Plugin `free' failed with: Sorry, this type is too difficult for me.
13:54:09 <ski> oh
13:54:13 <dolio> Yeah.
13:54:26 <merijn> ertes: I'm ok with patching criterion and submitting that upstream, I just want to do it with minimal work ;)
13:54:51 <ski> @free inverse :: (a -> b) -> (b -> a)
13:54:52 <lambdabot> g . h = k . f => f . inverse h = inverse k . g
13:55:14 <ertes> merijn: i think nobody would object to virtual time…  it should be easy enough to do, too =)
13:55:31 <ertes> do linear regression on the time that was actually spent in the benchmark
13:55:38 <ertes> you can do the same with cpuTime
13:56:39 <merijn> ertes: I think it might be trickier than you think
13:56:47 <ertes> all you need is to wrap the benchmark in a with* sort of function that starts the timer, and at the end updates an IORef that accumulates the total
13:57:15 <merijn> ertes: Currently it runs a benchmark N iterations, and takes the total time of that. But now you need to also track N cleanup/setup times within that and store those
13:57:37 <ertes> no, the idea is precisely *not* to track those
13:58:15 <merijn> ertes: Wouldn't the IORef update introduce too much overhead for some of the small benchmarks people use it for?
13:58:33 <ertes> merijn: the IORef update isn't itself timed
13:59:14 <ertes> right now criterion needs to ask the clock once after each iteration
13:59:21 <ertes> with this idea implemented it needs to ask twice per iteration
13:59:31 <ertes> one of those should be untimed
13:59:32 <dolio> I don't think criterion does that.
13:59:46 <ertes> dolio: then how does it detect outliers?
14:00:15 <dolio> Hmm.
14:00:17 <ertes> how does it even calculate the standard deviation?
14:00:28 <ertes> it has to ask the clock between iterations
14:01:05 <merijn> ertes: No
14:01:15 <merijn> ertes: criterion does not request a clock after each iteration
14:01:50 <dolio> I'm skeptical that it can do that, because the clocks wouldn't be precise enough to time things.
14:01:59 <merijn> oh, wait, it does, I think?
14:02:05 <ertes> it has to
14:02:09 <merijn> dolio: Not true
14:02:14 <ertes> regression needs time samples
14:02:16 <merijn> dolio: It's using FFI to use rdtsc
14:02:23 <dolio> Oh.
14:02:26 <merijn> dolio: Which is super cheap
14:03:06 <merijn> ertes: Actually, both right
14:03:15 <dolio> That makes some of its design even more annoying.
14:03:16 <merijn> ertes: So it runs N batches of M samples
14:03:38 <merijn> And only times the M samples in aggregate
14:03:47 <ertes> yeah, that sounds reasonable…  but if you want to subtract initialisation/cleanup, then you need to do it for each iteration
14:04:12 <ertes> in fact you need to ask the clock multiple times
14:04:31 <ertes> but only one of those should affect the time on average
14:05:15 <merijn> Actually, this is workable for me
14:05:34 <merijn> oh, wait...no, only for the simple case
14:09:20 <merijn> Can't I sucker someone into writing this for me so I don't have to bother? xD
14:11:09 <ertes> merijn: i'm happy to write the timing code for you, but i'll leave the criterion integration to you =)
14:12:37 <merijn> oh well, looks like more work than I'll get done this night with a cat sabotaging me...
14:19:14 <ertes> merijn: there, have fun: https://gist.github.com/esoeylemez/5ea02bc944af4b9fb9f963f06c9ed374
14:19:14 <ertes> =)
14:19:56 <ertes> System.Clock is from the 'clock' package, which is probably more expensive than criterion's clock
14:20:38 <merijn> ertes: Yeah, I got that much of your explanation. Fitting it into criterion is the hard part ;)
14:28:09 <lyxia> dolio: thanks for the help!
14:36:04 <Carollshelby_> jezuz
14:36:08 <Carollshelby_> look at all dem ppl
14:36:11 <wizard1337> given how important software is to the economy, why is there not an insane level of investment in programming language development
14:36:19 <wizard1337> ?
14:36:34 <merijn> wizard1337: Same reason we're stuck with crappy OSes
14:36:52 <merijn> wizard1337: Business cares too much about backwards compatibility (of both code and their current employees)
14:37:11 <wizard1337> we have vms
14:37:11 <merijn> wizard1337: Also, long term investment in systems design has an unclear pay off/ROI, so they don't do it
14:37:17 <wizard1337> so thats solved
14:37:31 <wizard1337> you can always run windows xp in a vm ;)
14:37:48 <wizard1337> look at semtech,
14:38:03 <wizard1337> where semiconductor firms partnered to make a research org
14:38:12 <wizard1337> or we can do federal investment...
14:39:25 <merijn> Yeah...in theory
14:39:44 <merijn> In practice it's hard to get funding for systems research/engineering
14:39:44 <Tuplanolla> Every now and then some essential infrastructure breaks and only then do people realize it was all maintained by a single hobbyist from central Europe.
14:40:02 <ertes> also when people actually do invest in programming language development, you get stuff like go
14:40:28 <merijn> ertes: That's a bit disingenous
14:40:29 <Tuplanolla> The existence of programming languages is one of those things that most people take for granted.
14:40:34 <merijn> ertes: You also get Rust and Swift...
14:40:39 <wizard1337> lol central europe hobbyist
14:41:04 <wizard1337> C++ is such a joke
14:41:27 <merijn> wizard1337: You laugh, but wasn't it like GNU Octave that this month went like "welp, I can't pay my bills working on this, I need people to pay me", despite it being used by loads of companies to make big bucks...
14:41:44 <wizard1337> yeah but octave sucks
14:41:52 <wizard1337> and julia is replacing it
14:41:55 <merijn> Irrelevant
14:42:23 <ertes> merijn: both of those i could complain about, although rust at least seem to go into the right direction
14:42:25 <merijn> It's a language that's probably allowing millions of dollars of business to run and it's maintained by one guy who can't even live off it
14:42:29 <ertes> *seems
14:42:41 <merijn> ertes: Swift is a lot more in the right direction than Go or C# :p
14:42:53 <merijn> ertes: Apple could've made Objective-C# instead...
14:43:56 <wizard1337> visual objective C#++-- omega
14:44:22 <wizard1337> that will be my pl, anyone want to join, lol
14:45:41 <ertes> the thing that confuses me is that even today most *new* languages lack useful type systems…  i'm not asking for haskell, but if rust is so great, why can't i abstract over types of kind * -> *?  it seriously limits your abstraction capabilities
14:46:27 <monochrom> A language is limited by the lack of imagination of its designer.
14:46:34 <merijn> ertes: AFAIK there's plans (both for Rust and Swift) to add HKT
14:46:55 <ertes> go's type system is a joke, rust's developers seem to pays so much attention on memory safety while completely ignoring abstraction
14:47:08 <ertes> *pay
14:50:03 <wizard1337> so like when i use my bank to pay for stuff
14:50:21 <wizard1337> what languages are being used
14:50:32 <monochrom> * -> * was a really new and recent invention. Recall that even the MLs don't have it.
14:50:40 <ertes> wizard1337: javascript =)
14:50:45 <wizard1337> lol
14:50:52 <monochrom> I guess s/new and/
14:51:00 <Koterpillar> wizard1337: my bank has some fields validated _client-side only_
14:51:26 <Rembane> monochrom: What is * -> *? Can you give an example of * -> * ?
14:51:35 <merijn> wizard1337: Binaries compiled from COBOL where they lost both the original source AND the compiler
14:51:42 <monochrom> I think the general public are still recovering from the shock of kind * parameteric polymorphism (known as Java generics).
14:52:03 <monochrom> Rembane: the kind of the type variable m in "m Int".
14:52:03 <ertes> Rembane: Maybe :: * -> *
14:52:09 <merijn> wizard1337: If you think I'm joking, one of my colleagues was once paid to decompile/reverse engineer OS360 assembly to COBOL for exactly that reason
14:52:22 <Rembane> monochrom, ertes: Nice! Thank you!
14:52:37 <ksj> wait why'd you reverse engineer it to COBOL if you only have the assembly anyway?
14:52:40 <ertes> Rembane: a type of kind * is a concrete type like Int, a type of kind * -> * takes a concrete type as its argument
14:52:53 <ertes> Maybe Int  -- Maybe (of kind * -> *) applied to Int (of kind *)
14:53:03 <merijn> ksj: Because they still had OTHER cobol source and they figured keeping it in the same format would be good.
14:53:15 <ksj> merijn: oh ok, just thought it was all of it
14:53:21 <ksj> poor guy
14:53:23 <merijn> ksj: Incidentally, he was also part of a project to turn COBOL asm into Java, iirc
14:53:23 <Rembane> ertes: So Maybe Int is * -> * and (m Int) is also * -> * ?
14:53:30 <monochrom> I would recommend decompiling to Algol, but meh.
14:53:47 <ertes> Rembane: no, (Maybe :: * -> *), (Int :: *), (Maybe Int :: *)
14:53:52 <merijn> Rembane: No, 'Maybe :: * -> *' and 'Int :: *', thus 'Maybe Int :: *'
14:54:01 <ertes> Rembane: just like (sin :: Double -> Double), (5 :: Double), (sin 5 :: Double)
14:54:02 <Koterpillar> So (m Int) would be (* -> *) -> *
14:54:17 <Tuplanolla> Talking to yourself again, mertes?
14:54:30 <Rembane> Aha! Thank you!
14:56:11 <ertes> Tuplanolla: no, we're not
14:57:07 <merijn> I'm talking to the cat :p
14:57:21 <ertes> we never talk to ourselves, right?
14:57:22 <ertes> right!
14:57:38 <Sornaensis> I never talk to myself, I talk to the voices
14:57:43 <Sornaensis> that would be crazy
14:57:50 <monochrom> I talk to myself all the time. It adds sparks to my conversations.
14:57:59 <Rembane> The first law of talking to ourselves is that we don't talk to ourselves.
14:58:11 <merijn> I'm more of an "incoherent angry rant" kinda guy :p
14:58:25 <Sornaensis> it's crazy how much insight you can gain from explaining a piece of code to a cat or a rock
14:58:38 <ertes> or to yourself =)
14:58:39 <Rembane> Rocks don't walk away
14:58:53 <merijn> Rembane: Neither does my cat, she's a lazy fuck :p
14:59:10 <merijn> Rembane: And my computer has a case fan blowing hot air out the top
14:59:15 <Jacoby6000_> I'm starting to consider using haskell for a side project.  Any recommendations on a good http lib?
14:59:24 <ertes> and after you've explained your monad transformer to her, she looks back at you like a lambdacat
14:59:32 <merijn> Jacoby6000_: For what? Fetching stuff?
14:59:38 <Jacoby6000_> http server*
14:59:41 <Jacoby6000_> my bad
14:59:47 <Rembane> merijn: Oooooh. A cat trap. 
15:00:00 <Jacoby6000_> I've heard of servant, and it sounds interesting
15:00:02 <merijn> Jacoby6000_: Ah, then I don't have opinions :)
15:00:04 <Jacoby6000_> wondering what else there is
15:00:04 <ertes> Jacoby6000_: we have a few of those…  happstack-server, snap-server and warp come to mind
15:00:09 <Sornaensis> I like warp
15:00:22 <merijn> ertes: Fun fact, I registered lambdacats.org to avoid having to remember the awkward url ;)
15:00:36 <merijn> http://lambdacats.org
15:00:45 <monochrom> oh haha
15:01:00 <koala_man> haha
15:01:00 <ertes> haha
15:01:28 <merijn> Actually, now that I have a VPS I could probably mirror it and avoid the risk of it ever going down
15:07:21 <ertes> you could also get rid of the stupid JS dependency along the way =)
15:07:49 <ertes> a flat HTML with inline images is a much smoother user experience that this shit
15:10:38 <monochrom> Programmers care more about justifying their purpose of existence than user experience.
15:11:07 <dunx> well of coure
15:11:10 <dunx> course
15:11:20 <dunx> we don't want our wages cut, do we
15:11:34 <ertes> i believe we can have both
15:11:45 <ertes> fancy visuals *and* a great UX
15:14:12 <Squarism> anyone know how to get the locale (TimeLocale) for a certain country/language combination?
15:14:40 <Squarism> ie the type used in Data.Time
15:15:31 <merijn> ok, bedtime!
15:15:43 <monochrom> Does "getCurrentTimeZone" help?
15:18:00 <monochrom> Ah, TimeLocale is much more than TimeZone.
15:21:32 <monochrom> Oh, this is sad, parseTime (which uses Maybe) is deprecated in favour of parseTimeM (which uses Monad fail).
15:21:41 <monochrom> This is so reactionary!
15:25:52 <lyxia> I wonder what results a poll about this question would give. Maybe a vs MonadFail m => m a or something similarly overengineered
15:26:51 <glguy> 'Either String a' would have been fine type
15:27:06 <glguy> or even something more structured than String
15:27:23 <glguy> IIRC there were only two error messages that could have occurred
15:27:59 <monochrom> I would be OK with MonadFail
15:29:32 <glguy> The only instance of MonadFail (in base) that makes the error message available is the one for IO
15:53:12 <adelbertc> anyone here used `hint` before? Trying to do `runInterpreter $ interpret "5" (as :: Int)` but am getting `Left(WontCompile [GhcError {errMsg = "<interactive:3:37: error:\n Not in scope: type constructor or class \8216Int\8217"}])`
15:53:53 <c_wraith> adelbertc, you need to set imports. yes, even for the Prelude 
15:54:12 <adelbertc> c_wraith: ah, trying
15:56:27 <ludat> hi everyone, is there some standard lib for writing CLI apps?
15:57:08 <c_wraith> adelbertc, the reason Int is present in the string being interpreted is the way hint handles making sure the interpreter is well-typed. it more or less rewrites the String to "(5)::Int", and then Int isn't in scope because the Prelude isn't automatically in scope. 
15:57:24 <adelbertc> ludat: like a cmd line parser? i like optparse-applicative
15:58:14 <ludat> adelbertc, no, I mean like interactive cli apps, like bash or pgcli
15:58:19 <adelbertc> c_wraith: hm should it just be `loadModules ["Prelude"]` ?
15:59:30 <_Adluc_> ludat: try repline
15:59:39 <_Adluc_> ludat: https://hackage.haskell.org/package/repline
16:00:09 <c_wraith> adelbertc, no, loadModules is for adding files to interpret into scope. 
16:00:23 <c_wraith> adelbertc, you want setImports
16:00:28 <adelbertc> oh right
16:01:29 <adelbertc> c_wraith: sweet that worked
16:01:30 <adelbertc> thanks!
16:02:02 <c_wraith> you're welcome. :) 
16:02:15 <ludat> _Adluc_, that should work, thanks!
16:06:04 <typedeph> how does one initialize an immutable array? the array function example has a typo and its correct version fails for me with an ambiguity error
16:06:26 <typedeph> by immutable array I mean Data.Array.IArray
16:07:45 <c_wraith> fix the ambiguity. specify the type variables it's telling you are ambiguous. 
16:07:58 <ludat> IArray isn't an interface?
16:08:41 <c_wraith> this isn't C#
16:09:11 <c_wraith> though it actually is a class. it just stands for Immutable array 
16:09:31 <c_wraith> in contrast to MArray
16:09:56 <typedeph> and how exactly would I do that for the most trivial example, the typeclass reads cycliclly: :: (Ix i, IArray a e) => (i, i) -> [(i, e)] -> a i e
16:10:01 <lispy> and class here means typeclass not an OOP class
16:10:10 <typedeph> e depends on an IArray but I want to construct an IArray
16:11:10 <c_wraith> typedeph, IArray isn't a type. you'll need to pick which type you actually want. 
16:12:10 <kadoban> typedeph: You pick either Array Something SomethingElse, like Array Int Int would be common. Or UArray Int Int
16:22:50 <jle`> Typedeph_: do you know about typeclasses?
16:27:49 <monochrom> The IArray class is pretty much locked (you can't implement your own instance). You can only pick existing instances, and the choice is limited.
16:28:41 <monochrom> This class is invented mainly to give uniform function names over Array and UArray. That's all.
16:29:42 <monochrom> If you don't already know "class", it's just for giving uniform function names such as "+" that works for Int, Double, and Word.
16:53:21 <blackhole1> 3
16:53:42 <blackhole1> quit
17:16:38 <spaceghost> Hello clint.
17:18:42 * edwardk looks and sees no haskell.org on the gsoc site. =(
17:20:48 <robertkennedy> > (fail "test" :: Monad m => m Int) :: Either String Int
17:20:50 <lambdabot>  *Exception: test
17:21:01 <robertkennedy> What is that?!?!
17:21:59 <tommd> spaceships: Ping
17:22:31 <glguy> robertkennedy: What else would you expect it to be?
17:23:48 <jle`> robertkennedy: look at the Monad instance for Either
17:25:21 <jle`> (spoilers: it just leaves the defailt implementation of fail = errorWithoutStackTrace
17:25:55 <glguy> Without looking in the code you can see the output of :i Monad
17:25:56 <glguy> instance Monad (Either e)
17:26:19 <robertkennedy> Sure, I get that the general `instance Monad (Either a)` can't have fail go to `Left`
17:26:21 <glguy> The instance works for all 'e' equally
17:26:39 <jle`> robertkennedy: so, you understand what's going on
17:26:58 <glguy> so it would be upsetting if fail at the type Either String Int  did anything other than what it did
17:27:36 <jle`> parametric polymorphism at its finest
17:27:49 <glguy> I suppose you could do: fail = Left . error
17:28:00 <glguy> but I don't think that would be an improvement
17:28:03 <jle`> lol
17:28:16 <jle`> isLeft would work i suppose
17:28:46 <spaceghost> Pong tommd.
17:29:55 <tommd> Ohh, free pong.
17:30:09 <tommd> (I was actually looking for space-ships)
17:30:18 <robertkennedy> Of course I knew why when I debugged it. But I don't know Whyyyyy
17:32:41 <robertkennedy> Like if you had `instance FromString a -> Monad (Left a)`, imagine the utility
17:33:07 <glguy> The utility of only being able to use it with types that were instances of FromString?
17:33:25 <glguy> That'd break most of the times that I use it
17:33:28 <robertkennedy> (until the MonadFail proposal)
17:33:31 <glguy> but if you want that, it exists
17:33:51 <glguy> http://hackage.haskell.org/package/transformers-0.5.4.0/docs/Control-Monad-Trans-Error.html
17:33:55 <glguy> It's just usually not what people want
17:36:57 <Squarism> glguy, Just got to thank you again. Separating lib/executables/tests into different source roots relieved me from restating lib dependencies (like 30) for 4 artifacts + "other-modules" repetition. Starting to like cabal almost
17:37:13 <Squarism> + made my build 4 times faster
17:37:18 <glguy> yay ^_^
17:37:36 <Squarism> =D
17:42:28 <robertkennedy> You're right that the FromString constraint is silly - ie parsers
17:45:35 <robertkennedy> It's just that I have two versions of every function, IE `fMaybe :: A -> Maybe B` and `fEither :: A -> Either String B`, and I'd thought to unify them through fails in lieu of Nothing and returns instead of Rights
17:46:21 <Squarism> So does this cabal file look legit? http://lpaste.net/353043
17:48:01 <glguy> Squarism: I wouldn't have expected you to need the -main-is flags in ghc-options in general, maybe something's going on there. And you're missing most of your package version bounds. The directory structure seems fine
17:48:42 <Squarism> glguy, ok. Ill look into that
17:50:26 <robertkennedy> glguy: do you encounter that idiom a lot, and does using an mtl really not add too much overhead?
18:06:21 <robertkennedy> Got it. The library uses the fail return, and I just instantiate a type downstream to accept the function
18:35:04 <hboats> is it reasonable to use STM with parallel strategies? Or is STM really for concurrency?
18:35:50 <peddie> hboats: the point of parallel strategies is you don't need to use STM to evaluate things simultaneously, isn't it?
18:36:01 <peddie> or really, explicit threads at all
18:39:11 <hboats_> weird disconnection =/ In any case I was hoping that I could use STM to control writes to an array. I have a number of things that would write to the same array. Technically the issue is that the program is asynchronous, but I'm trying to implement some amount of multiprocessing in it
18:40:15 <peddie> hboats_: if you just want to calculate a bunch of array members in parallel, you can probably use parallel strategies.  if you want to do some concurrent I/O or whatnot, you might need something else
18:43:46 <fryguybob> hboats_: STM doesn't really support transactional reads and writes to mutable arrays right now.
18:44:41 <hboats_> Yeah, I was hoping there might be some simple solution I missed. I'm trying to gain some parallelism on an asynchronous cellular automata, and have seen very little success
18:44:52 <Sornaensis> is STM lock-free
18:45:16 <Sornaensis> I'm playing around with implementing a synchronous queue in haskell for a parallel computing course
18:47:44 <hboats_> Sornaensis: I was messing around with something similar with a priority queue, there were a few papers on it, but they required a sort of global time clock. I think Aivika had something similar for one of its queues
18:48:09 <Sornaensis> I'm just doing a naive implementation with TMVars
18:48:23 <Sornaensis> based on the paper behind Java's SynchronousQueue class
18:50:33 <fryguybob> Sornaensis: Haskell STM is close to lock-free, but there is a narrow window that allows for live-locking in some situations.  I could be fixed though :D.
18:51:47 <Sornaensis> fryguybob: like where transactions keep getting reordered?
18:53:51 <fryguybob> Sornaensis: Two transactions (in the right circumstances) can cause each other to fail to commit and the *both* start again.
18:54:12 <Sornaensis> hmm
18:54:20 <Sornaensis> what are the right circumstances
18:54:22 <fryguybob> Sornaensis: If the conflict allowed one of the transactions to continue then it would be lock-free.
18:55:05 <Sornaensis> could livelock occur with the usual usage of a TQueue
18:55:09 <fryguybob> Sornaensis: A simple example would be t0: read x write y  and  t1: read y write x
18:55:09 <Sornaensis> ?
18:55:18 <Sornaensis> ah
18:55:38 <Sornaensis> fryguybob: are there any online resources that discuss the gotchas of STM
18:55:54 <fryguybob> Sornaensis: But they both have to hit their commit at the right time for this "both die" outcome.
18:58:03 <peddie> fryguybob: why in particular do those two conflict?  what's a similar example that can't have this livelock issue?
18:58:12 <fryguybob> Sornaensis: There are some details in the commentary, but I can't think of a high-level resource that talks about much.  I'm not sure I would call this a gotcha...
18:58:37 <fryguybob> Oh, sorry that was answering peddie 
18:59:01 <fryguybob> No, my mistacke again :D
18:59:28 <Sornaensis> hmmm
18:59:39 <Sornaensis> fryguybob: can this occur with general use of a TQueue
18:59:44 <fryguybob> peddie: If you search for "live-lock" in the commentary: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/STM
18:59:48 <peddie> thanks fryguybob 
18:59:52 <Sornaensis> just putting items on and taking them off of a TQueue
19:00:01 <fryguybob> There is a table that shows this particular example worked out.
19:00:50 <raza> hey haskell folks, how to export code+result for all source code blocks? I know I can use "export" option on a per source code block basis, but I want a global knob to switch.
19:00:51 <fryguybob> Sornaensis: I'll have to think about it.
19:01:03 <raza> this is for org-mode
19:01:12 <raza> let me know if it's the wrong forum
19:01:33 <fryguybob> Sornaensis: The bigest gotcha of STM is that there isn't fairness in GHC's implementation.
19:02:37 <fryguybob> So long running or large transactions can have difficultly commiting as short fast transactions are allowed to commit if they can.
19:03:10 <Sornaensis> neat
19:03:50 <fryguybob> Sornaensis: But fairness can slow things down quite a lot...
19:07:18 <fryguybob> Sornaensis: I don't think you can trigger live-locking with a single TQueue.
19:07:53 <Sornaensis> fryguybob: ah ok
19:14:14 <raza> have you guys used org-mode?
19:15:04 <peddie> raza: sounds like a question for #emacs
20:09:21 <Forkk> Is it possible to debug C code called from the FFI using gdb?
20:10:42 <ezyang> yes 
20:10:48 <ezyang> just breakpoint on it the usual way 
20:10:54 <peddie> Forkk: your call stack may not make sense before you cross the FFI, but the C code should show up like normal
20:11:16 <Forkk> really, because I ran it through gdb and when it segfaulted the backtrace was mostly empty
20:11:26 <Forkk> there was certainly nothing recognizable in it
20:12:40 <Forkk> only thing on the stack is Machine_zdwa_info
20:13:55 <Forkk> maybe it's because I'm running gdb on the test executable?
20:14:07 <Forkk> weirdly it also hides the cursor in my terminal when I run it
20:19:27 <Henson> good evening, everyone.  What's a good way to use Haskell to move a file.  I can only find "rename" in System.Posix.Files, but it doesn't seem to be able to move the file from one filesystem to another.  Is there something that can do that, or do you have to manually copy and delete the file for cross-filesystem moves?
20:20:43 <ezyang> does renameFile in directory's System.Directory really not work? 
20:23:29 <Forkk> yeah everytime there's a segfault the only thing on the stack is Machine_zdwa_info
20:23:34 <Forkk> I don't even know what that is
20:23:50 <dmwit> ?zdec Machine_zdwa_info
20:23:51 <lambdabot> Unknown command, try @list
20:24:53 <Henson> ezyang: nope: "rename: unsupported operation (Invalid cross-device link)"
20:25:03 <dmwit> Are underscores even allowed in z-encoded names?
20:25:15 <pikajude> i think it's Machine_$wa_info
20:25:19 <ezyang> I guess you have to copy 
20:25:43 <ezyang> dmwit: well, if they're not, they must be encoded as zu :) 
20:25:52 <Forkk> pikajude: but what is that?
20:25:56 <pikajude> that i don't know
20:25:58 <Forkk> it's not in the C code I'm calling
20:27:36 <Forkk> well the module is called Machine
20:27:51 <Forkk> idk what wa_info is
20:29:40 <Forkk> ezyang: I can't set breakpoints either
20:29:44 <pikajude> i googled $wa_info and got this https://mail.haskell.org/pipermail/ghc-tickets/2014-March/010699.html
20:29:46 <Forkk> gdb says no symbol table is loaded
20:30:03 <ezyang> is the foreign library dynamically loaded? 
20:30:22 <Forkk> no
20:30:33 <Forkk> it's a small bit of C code I wrote
20:30:42 <Forkk> just to speed up part of my program
20:30:52 <ezyang> compile it with debug symbols? 
20:30:59 <Forkk> I added -d to cc-options
20:31:08 <Fylwind> is there a proper name for   newtype L m a = L (m (Maybe (a, L m a)))
20:31:19 <Forkk> wait it's -g isn't it
20:31:51 <Fylwind> it's like a list, but with a monadic action interleaved between each element
20:31:53 <ski> Fylwind : i've called it `List' ..
20:32:01 <Fylwind> ski: creative :P
20:32:09 <ski> `m' could be `IORef' or something else, doesn't have to be a monad
20:32:35 <ski>   newtype List ref a = MkList (ref (ListCell ref a))
20:32:44 <ski>   data ListCell ref a = Nil
20:32:54 <ski>                       | Cons a (List ref a)
20:32:56 <dmwit> Fylwind: http://hackage.haskell.org/package/list-t-1/docs/ListT.html
20:33:38 <dmwit> I agree with ski: reusing `Maybe` and `(,)` was a mistake.
20:33:42 <ski> then you could have `freeze :: ListCell IORef a -> IO (ListCell Identity a)'
20:33:57 <ski> er, s/ListCell/List/, there
20:34:11 * ski is only half awake
20:34:19 <Forkk> pikajude: that all looks way over my head
20:34:27 <pikajude> Forkk: yeah, i don't know if it's relevant
20:34:33 <Fylwind> ski, dmwit: ah, ListT, thanks!
20:34:33 <pikajude> $wa might even be randomly generated
20:34:41 <Forkk> :|
20:34:48 <Forkk> I've got breakpoints working
20:34:54 <Forkk> just gonna step through uit
20:37:53 <Forkk> well it's happening after the call to the main C function
20:40:10 <Forkk> yeah the segfault is in haskell code.. I'm not sure how to debug this
20:40:54 <davean> Forkk: you have a segv in haskell code?
20:41:00 <davean> Forkk: is it a Storage instance or something?
20:41:15 <Forkk> it's in a haskell function with a bunch of c2hs stuff in it
20:41:27 <Forkk> for converting from a c struct to a haskell struct
20:41:33 <Forkk> not a storage instance though
20:41:55 <ezyang> Say you have a function that has a number of fiddly parameter knobs. Do you prefer: (1) having an opaque "config" object, with setters to set parameters, or (2) having some monoid-y thing 
20:43:04 <Forkk> I've isolated it to this line:   ty <- toEnum <$> fromIntegral <$> {#get value->ty#} cv
20:43:19 <Forkk> with everything else commented out but that, it still crashes
20:43:29 <davean> ezyang: situational
20:43:43 <davean> I generally lean towards the monoid, but situational
20:44:23 <Forkk> where pv is one of these: https://gist.github.com/Forkk/edc651092c8a5e30036f810273c11d4e
20:44:24 <ezyang> context: I'm redesigning the API for the "compact normal forms" library (gives you a thing you can put data in, and then we no longer GC it) 
20:44:30 <ezyang> and there are some parameters which people might want to tune for perf 
20:45:54 <davean> ezyang: well, for example, if theres something that can be filtered, I prefer the monoid so I don't have to fiddle with all the composition by hand.
20:46:15 <ezyang> filtered? 
20:46:25 <davean> like rules applied to matching things
20:46:48 <ezyang> oh, so like, HAdrian style https://www.microsoft.com/en-us/research/wp-content/uploads/2016/03/hadrian.pdf 
20:46:49 <davean> if the config is just a few integers, I prefer just getting it over and done with
20:46:59 <davean> ezyang: yah
20:47:10 <davean> Thats the sort of time I clearly prefer a monoid
20:47:23 <davean> When its small and simple though thats just extra work for me
20:48:59 <Forkk> I don't understand why this is crashing
20:49:12 <Forkk> it's literally just `C2HSImp.peekByteOff ptr 0`
20:49:28 <Cale> Well, what's ptr pointing at?
20:49:33 <Cale> Is it a valid memory location?
20:49:47 <Forkk> actually I guess it's not a pointer
20:49:57 <Cale> hm?
20:50:05 <Forkk> it's whatever {# type value #} expands to in c2hs
20:50:08 <Forkk> hang on
20:50:18 <Cale> Well, it's got to be a Ptr a for some type a
20:50:22 <Forkk> which is ((C2HSImp.Ptr ()))
20:50:49 <Forkk> the value comes from a call to `value do_eval(instr* code, size_t len)`
20:50:59 <Cale> It has the type of being a pointer, but depending on how you obtained it, it might not be a reasonable one.
20:51:08 <Cale> What's value?
20:51:17 <Forkk> this struct: https://gist.github.com/Forkk/edc651092c8a5e30036f810273c11d4e
20:51:24 <buttons840> I am using trifecta to parse some input in a web app, and I want to display the trifecta errors in the web app if parsing fails, but I'm having some issues because trifecta errors contain color codes which don't play nice in browsers -- any suggestions?
20:51:30 <Cale> Doesn't seem like it should be a pointer
20:51:45 <Forkk> c2hs makes it a pointer
20:51:58 <Forkk> at least as far as haskell is concerned
20:52:05 <Forkk> which it maybe shouldn't
20:52:31 <Forkk> so what do I have to malloc this tiny struct or something
20:53:19 <buttons840> nevermind, I found that Text.PrettyPrint.ANSI.Leijen has some utility functions I can use
20:55:01 <Forkk> Cale: I made the eval function return a value* and that didn't fix it
20:58:04 <Forkk> actually now it's crashing in caS7_info :|
20:58:23 <robertkennedy> When the MonadFail proposal goes through, will `(fail "test" :: Either String Int) == Left "test"`?
21:00:44 <Cale> robertkennedy: I wouldn't imagine so
21:01:01 <Cale> Well, maybe
21:01:32 <Cale> You'd need for the instance to be  instance MonadFail (Either String)
21:01:54 <Cale> and then Either e for generic e couldn't be made an instance of MonadFail
21:03:48 <robertkennedy> The first part I meant; what do you mean by the second part?
21:05:35 <Cale> Well, I suppose it will come down to how much code will break when it uses do-notation for Either e, for types e that are not String.
21:06:06 <Cale> I suppose maybe it'd be a good thing to point out that you have code there which throws exceptions
21:06:07 <robertkennedy> But wouldn't that code already break with MonadFail?
21:06:18 <Cale> Not necessarily
21:06:26 <Cale> We might just copy the existing functionality
21:06:30 <Cale> which is to say
21:06:44 <Cale> instance MonadFail (Either e) where fail x = error x
21:06:58 <Cale> But I don't know what the plan is
21:07:47 <dolio> Definitely wouldn't error.
21:07:53 <dolio> That'd be stupid.
21:08:06 <dolio> And we're not that stupid.
21:08:23 <buttons840> How would you remove a substring from a Text string? Or more broadly, how would you do a search an replace on a Text string?
21:10:40 <davean> buttons840: https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text.html#v:replace
21:10:41 <buttons840> perhaps I should use replace in Data.Text? :)
21:10:46 <davean> Yes
21:11:47 <buttons840> lmgtfm -- let me google that for myself
21:13:02 <davean> Well, I'm glad you said it, because I'd had a very hard time resisting saying it :-p
21:13:42 <robertkennedy> For the first you can use break, for the second I use something like `fmap mconcat $ ("stringToKill" *> return "replace") <|> fmap singleton anyChar` (attoparsec), which extends easily to lists of find/replace pairs 
21:13:51 <Forkk> even if I call malloc and return the pointer, I still get segfaults when I try to peek the pointer
21:14:13 <Forkk> but the C code can use the pointer just fine
21:14:31 <ezyang> explicit type application is SO EXCELLENT 
21:14:33 <davean> Forkk: Have you checked the actual value of the pointer on both sides?
21:14:52 <Forkk> oh I think I just solved it
21:15:07 <Forkk> but now it's returning 1178791064 as the enum value
21:15:28 <robertkennedy> I forgot a many after mconcat. 
21:16:27 <Forkk> davean: trying to do that, but printf isn't printing anything
21:17:15 <buttons840> robertkennedy: i think i mostly follow that, but i'm going to use `replace` in this case
21:18:35 <robertkennedy> I'd guess that's a better choice ;-)
21:19:04 <buttons840> robertkennedy: i've been using trifecta, it's nice to see that autoparsec is quite similar
21:24:58 <robertkennedy> Since it isn't (Either String), what is the smallest MonadFail that recovers the message?
21:39:22 <fragamus> ruby -e is handy for running short ruby expressions from command line --- is there something similar for ghci
21:39:56 <jle`> fragamus: there's ghc -e
21:40:48 <fragamus> I would not have expected that
21:40:53 <fragamus> but it works
21:41:04 <fragamus> ghc -e "putStrLn \"hello\""
21:41:21 <jle`> might be less useful in the ruby version because there's less "imported by default" in haskell/Prelude
21:41:39 <fragamus> takes a while to load up
21:42:10 <davean> yah, GHC is built for many things, small and fast isn't two of them
21:42:17 <jle`> i think it actually compiles it to a temporary file and runs it
21:42:21 <fragamus> seems like the stack ghci crowd would want this to be facile
21:42:39 <jle`> this isn't really a common workflow/usage of ghc tho
21:43:02 <fragamus> yeah but like turtle
21:44:02 <fragamus> I just realized that turtle can do what I want
21:45:59 <fragamus> @davean thats funny
21:45:59 <lambdabot> Unknown command, try @list
22:41:37 <ezyang> How do I make a Hackage package show the README 
22:46:24 <MarcelineVQ> it's not automatic for README's that end in .md or .markdown and are present in the extra-source-files field?
22:46:46 <ezyang> hmm, maybe I messed up 
22:46:48 <ezyang> Oh yes I did 
22:55:35 <fragamus> hey ghc -e is a little funky
22:56:21 <fragamus> stack ghc -- -e "putStrLn \"hello\""
22:56:32 <fragamus> that works but
22:56:58 <fragamus> stack ghc -- -e "import Turtle;putStrLn \"hello\""
22:57:03 <fragamus> no workie
22:59:39 <fragamus> nothing multi-line seems to work
23:00:14 <fragamus> I tried a compiler directive followed by a ; and then my putStrLn
23:00:28 <fragamus> anyhow... is there a place to read up on this
23:00:33 <MarcelineVQ> import is a declaration but -e evaluates expressions
23:00:41 <fragamus> ah
23:00:48 <MarcelineVQ> e.g.   ghc -e "do putStrLn \"hello\";putStrLn \"foo\""
23:01:38 <fragamus> so it is not going to let me do anything really useful like import a library and THEN evaluate an expression
23:01:55 <fragamus> back to ruby -e
23:03:00 <MarcelineVQ> doesn't seem like it, unless you use a source file in which case   ghc -e sourcefile.hs  treats it like ghci does
23:03:04 <MarcelineVQ> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using.html#eval-mode
23:04:24 <fragamus> well thank you for this I would have tried in vain
23:06:45 <ezyang> Straw poll: if you see "Could not match somepkg-0.1.0.0:helper:H with ...", what do you think somepkg-0.1.0.0:helper:H refers to? 
23:07:08 <ezyang> And is it any clearer if instead it's somepkg:helper-0.1.0.0:H? 
23:09:17 <MarcelineVQ> hmm... a stanza named helper in the .cabal file of somepkg that exposes a module called H?
23:09:49 <ezyang> dading! 
23:10:06 <pavonia> What is a stanza?
23:10:08 <ezyang> which do you prefer 
23:10:15 <ezyang> stuff like test-suite/library/executable 
23:10:29 <MarcelineVQ> if that's the case I prefer the first version, to me the relevant info reads more naturally
23:10:39 <ezyang> ok great, that's what I implemented :) 
23:12:16 <pavonia> Yeah, the second one then looks confusing, as if different stanzas could have different versions
23:24:16 <yezariaely> Hi there, I try to parse a file that consists of a textual part (ASCII) followed by a binary part.
23:24:50 <yezariaely> I tried parsing it with parsec where I can sucessfully parse the header part (textual). But now I don't know how to proceed with the binary part. Any suggestions?
23:26:21 <Cale> Maybe use Data.Binary.Get?
23:27:39 <yezariaely> ah yeah, that is a good idea. I can read the file using Data.Binary.Get and then extract the header and parse if afterwards. Thanks!
23:30:08 <Ptival> hey #haskell, I wrote this up, let me know what you think! :) https://ptival.github.io/2017/02/25/modular-parser-combinators/
23:41:26 <riddle00> .
23:46:56 <ushakovo> Are beginner type questions allowed here?
23:47:03 <liste> ushakovo: yes
23:47:08 <cocreature> absolutely!
23:48:01 <ushakovo> awesome! I am working on a project and I am receiving the error message "Segmentation fault/access violation in generated code"
23:48:18 <ushakovo> I think haskell is a pretty "safe" language so I was surprised to receive that message
23:48:23 <Cale> Does your project do FFI?
23:48:39 <ushakovo> everything I have found has been users reporting various ghc errors 
23:49:06 <ushakovo> yes it does
23:49:14 <Cale> That's either a GHC bug, or something is using a low level pointer operation (usually for the purposes of interacting with a C library)
23:49:36 <Cale> or the C library itself is causing the segfault
23:49:53 <ushakovo> I see. Unfortunately the code that would be calling a C pointer is in a library I am using 
23:50:18 <Cale> What seems to be causing it?
23:50:30 <Cale> Ptival: Interesting approach :)
23:50:59 <cocreature> Ptival: I need to read it more closely later but it looks pretty cool!
23:51:26 <cocreature> now someone only needs to come up with a way to remove the need to left factor your parser combinators and I’m happy
23:51:41 <ushakovo> I am using a library to play music. The library uses the Rational type to represent note durations
23:51:57 <cocreature> ushakovo: I think your best bet is to try to isolate the code that is causing the error
23:53:45 <ushakovo> cocreature: I think I've isolated it but I'm not sure how to fix it. I'll keep working at it though
23:54:06 <ushakovo> I was more curious what the error message meant, so thanks for the help!
23:55:02 <liste> ushakovo: segmentation fault means that some C/FFI code is trying to access memory not allocated the program
23:55:16 <ongy> or someone used unsafe where it wasn't safe
23:56:19 <ushakovo> I think the error may not lie in my code then
23:56:52 <ushakovo> or I need to use the code given in a different way
23:57:10 <ongy> probably not. The library *may* be exposing something that can be prevented by the user. But I think that's bad design from the library (to then segfault)
