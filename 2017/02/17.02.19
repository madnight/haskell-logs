00:04:42 <dynamical_system> she's back on!
00:05:46 <Axman6> > iterate (shiftL 1) 2
00:05:57 <lambdabot>  [2,4,16,65536,0,1,2,4,16,65536,0,1,2,4,16,65536,0,1,2,4,16,65536,0,1,2,4,16,...
00:06:07 <dynamical_system> neat
00:06:08 <Axman6> > iterate (shiftL 1) 2 :: [Integer]
00:06:17 <lambdabot>  error:
00:06:23 <lambdabot>      • Couldn't match type ‘Int’ with ‘Integer’
00:06:40 <Axman6> > iterate (shiftL 1 . fromInteger) 2
00:06:51 <lambdabot>  [2,4,16,65536,20035299304068464649790723515602557504478254755697514192650169...
00:13:16 <tsahyt> Hello! Is there a library that I can quickly use to plot functions, given as Floating a => a -> a? It'd be nice to use as a quick sanity check for some of the things I'm working on at the moment
00:14:21 <tsahyt> ideally something as simple as plot :: Floating a => (a -> a) -> IO ()
00:14:24 <Axman6> charts isn't quite that simple, but has excellent examples so you should be able to get it going pretty quickly
00:16:21 <lispy> tsahyt: yeah, that would be nice, but we don't have anything simple/fast like matlab and the likes. I think we just need someone to sit down and make a library like that.
00:16:40 <lispy> I've started on it before and then always just ended up using other stuff and moved on.
00:18:42 <cocreature> a more recent attempt at a plotting library is https://github.com/cchalmers/plots but I haven’t used that or Charts so I can’t comment on how they compare
00:23:08 <tsahyt> plots does look simple enough to be used on the fly I think
00:23:22 <tsahyt> all the charts examples render to files from what I can see
00:33:30 <sternmull> tsahyt: I think IHasekll could do interactive plotting and more.
00:34:18 <sternmull> s/IHasekll/IHaskell/
00:40:56 <tsahyt> QuickPlot looks rather nice but is no longer maintained :/
00:41:05 <tsahyt> and doesn't install on lts-8.0 anymore
00:42:28 <MarcelineVQ> https://www.stackage.org/haddock/lts-8.1/Chart-1.8.2/Graphics-Rendering-Chart-Easy.html is on lts 8, dunno anything about it
00:43:32 <MarcelineVQ> does look pretty straightforwards though to get started with it
00:46:16 <tsahyt> MarcelineVQ: I've only skimmed the docs for the backends but it seems that none of them render to a window
00:46:29 <tsahyt> although I'm pretty sure something could be written for the cairo backend
00:46:44 <tsahyt> but that's more trouble than it's worth for me at the moment
01:08:34 <Squarism> what power operator should one use to do (^) with a decimal exponent?
01:09:05 <pavonia> (**)
01:09:06 <jle`> Squarism: you can do (**)
01:09:16 <jle`> if your base is a Floating instance
01:09:27 <jle`> s/is/has
01:09:36 <Squarism> that worked
01:09:40 <Squarism> thanks
01:38:23 <ongy> can I put some instances on a associated type in a type family? (I want to force Show, so I can derive Show in types that use it)
01:38:27 <systadmin> heyo
01:40:31 <Squarism> does implicit params work in ghc 7.10?
01:40:42 <lyxia> Squarism: it does
01:41:00 <Squarism> i get " Parse error in pattern: ?epsilon"
01:41:27 <Squarism> ..ok bad context info there
01:41:33 <Axman6> might need an extension now?
01:42:10 <lyxia> ongy: can you give an example
01:44:13 <lyxia> ongy: with sufficiently many extensions you can write   class (Show (T a)) => C a where type T a
01:44:16 <Axman6> you can do things like class (Show (Assoc a)) => FooClass a where type Assoc a :: *
01:44:30 <lyxia> :P
01:44:40 <Axman6> @stereo
01:44:40 <lambdabot> Unknown command, try @list
01:44:51 <Axman6> @where stereo
01:44:52 <lambdabot> I know nothing about stereo.
01:45:03 <Axman6> bleh
01:45:55 <Squarism> ok.. better description : http://lpaste.net/352706
01:48:50 <ongy> I can write that thing, but it doesn't allow me to derive
01:49:41 <lpaste_> ongy pasted “derive with TypeFamilies” at http://lpaste.net/352707
01:50:00 <ongy> (I just noticed I don't need it for what I'm doing now, but I'm still interested in it)
01:50:36 <Squarism> ok.. worked it out. Seems the implicit param needs to be defined in a let-in before the expression using it
01:50:42 <lyxia> Indeed
01:50:52 <systadmin> Is there a way to loop the `succ` and `pred` functions for a given number of times?
01:51:56 <lyxia> ongy: You must use standalone deriving.
01:52:16 <ongy> then I don't have to put anything on the class either way, do I?
01:52:22 <Axman6> systadmin: well, you can use iterate succ x !! n, and deoending on the type, that may just be x + n
01:53:05 <lyxia> ongy: right
01:54:09 <lyxia> There's no way to say that all types defined by the type family must be Show-able.
01:54:35 <ongy> "The constraint ‘Show (Type a)’ is no smaller than the instance head." so I need UndecidableInstances, fun :)
01:54:53 <lyxia> Indeed
01:55:23 <ongy> ok, thanks
01:59:02 <tsahyt> I need a list of successive Words for folding purposes which centers around one given word, extending k elements in both directions. [x - w .. x + w] doesn't work for w > x. For that edge case I'd like to just omit those elements, so for x = 0 and w = 4 I'd like to have [0,1,2,3,4]. What's the best way to express this?
01:59:41 <lyxia> max (x - w) 0 ?
02:00:11 <tsahyt> oh
02:01:04 <tsahyt> well yep that does work
02:03:04 <lyxia> \o/
02:03:12 <tsahyt> actually it doesn't work for Words
02:03:31 <tsahyt> because they wrap around, so x - w > 0 in that case
02:04:00 <lyxia> oops
02:04:03 <tsahyt> [max (0 - 4) 0 .. 0 + 4] :: [Word8]
02:04:07 <tsahyt> > [max (0 - 4) 0 .. 0 + 4] :: [Word8]
02:04:10 <lambdabot>  []
02:04:50 <tsahyt> there ought to be saturating arithmetic on words...
02:05:06 <lyxia> x - min x w
02:05:15 <lyxia> there ought to be
02:05:20 <tsahyt> > [0 - min 0 4 .. 0 + 4] :: [Word8]
02:05:24 <lambdabot>  [0,1,2,3,4]
02:05:35 <tsahyt> I see
02:06:19 <tsahyt> it does fail on the other end still, but there should be something similar for that I think
02:09:20 <lyxia> > let x = 255 :: Word8 ; w = 42 in x + min (-x - 1) w
02:09:23 <lambdabot>  255
02:10:17 <tsahyt> > let f x w = [x - min x w .. x + min w (maxBound - x)] :: [Word8] in [f 2 4, f 150 4, f 253 4]
02:10:20 <lambdabot>  [[0,1,2,3,4,5,6],[146,147,148,149,150,151,152,153,154],[249,250,251,252,253,...
02:10:30 <tsahyt> > let f x w = [x - min x w .. x + min w (maxBound - x)] :: [Word8] in f 253 4
02:10:32 <lambdabot>  [249,250,251,252,253,254,255]
02:21:22 <Phillemann> I'm trying to understand John De Goes' article about free monads. Say I have a HttpF functor defined as "data HttpF a = Http Request (Response -> a)", and I have a "data LoggingF = Log Text a" defined. Can I now log a request and the corresponding response?
02:22:00 <Phillemann> From what I gather, I'd need a function "HttpF a -> Free LoggingF ()", but in there, I can only log the request...I think.
02:32:12 <ertes> Phillemann: an action of the free monad over HttpF is not so much an action that makes requests and write logs, but more like a scripting language you write an interpreter for
02:33:05 <ertes> Phillemann: if you use the 'free' library, you can use 'wrap' and/or 'liftF' to construct the primitive actions for your HttpF-based language
02:33:37 <Phillemann> Okay, and the logging interpreter just logs instead of...doing stuff, so it doesn't have access to the HTTP result.
02:34:13 <ertes> personally i prefer to put the continuations first, because it makes working with them a lot easier:  data HttpF x = Request (Response -> x) Request | Log x Text
02:34:44 <ertes> you have an HttpF interpreter, which could very well keep track of the responses generated so far
02:34:55 <ertes> there is no isolated logging interpreter
02:36:20 <ertes> all that said free monads are only useful, if you get some value out of the possibility to have suspendable actions together with a coroutine that handles suspensions
02:36:49 <Phillemann> My plan was to create a functor for the API I'm implementing, then transforming this functor to a HTTP functor and then "map" this functor to "log and actually do the requests"
02:37:03 <ertes> for example if you have multiple interpreters, or if you want to analyse the structure of the actions in your monadic language
02:37:38 <ertes> Phillemann: can you make sense of the (Free IO) monad?
02:37:51 <Phillemann> Well, for example, I'd like to write tests which don't actually do HTTP requests (but which may log stuff).
02:39:29 <Phillemann> I could simply write my API functions as "ApiInput -> IO ApiOutput", but a) this is boring, b) this prevents testing that stuff.
02:40:20 <Phillemann> I don't know if I understand Free very well, maybe I should read much more than John's article. :/
02:43:00 <ertes> Phillemann: don't read articles
02:43:02 <ertes> read the type!
02:43:24 <ertes> data Free f a = Pure a | Free (f (Free f a))
02:43:32 <ertes> now instantiate f = IO
02:47:44 <marrenarre> I'm having the same problem with GHC using old code that's not in the file anymore again. GHC says: "`Association operation (Left number)'" Vim shows me: "pairUp (GroupedOperation operation _:GroupedNumber number _:others) = fmap (Association operation (AssociatedNumber number):) $ pairUp others"
02:48:30 <marrenarre> Notice how the code after "= fmap" differs. It was originally the same, but I modified the file.
02:49:52 <lyxia> marrenarre: can you give more context
02:53:58 <MarcelineVQ> such as the rest of your code and the full ghc error in a paste, and what you're doing to get the error, such as saving and manually compiling, or some automated feature
02:59:28 <Bish> hi, i am making my first real haskell steps, i always start with tcpip servers when doing that
02:59:38 <Bish> so, can you tell me, why i cant import the network package?
02:59:42 <Bish> do i have to install it first?
03:00:24 <lyxia> yes
03:00:39 <Bish> with.. cabal?
03:01:01 <lyxia> That's it
03:01:05 <Bish> woo~
03:01:08 <ertes> Bish: depends on your toolchain…  cabal-install?  nix?  stack?
03:01:08 <ertes> Bish: or none of those?
03:01:25 <Bish> i just noticed gentoo has it in it's package manager
03:01:33 <Bish> but usually cabal would be the way to go i guess
03:01:44 <ertes> Bish: then i suggest that you familiarise yourself with cabal sandboxes
03:02:03 <ertes> go into a directory and type:  cabal sandbox init
03:02:21 <Bish> > test.hs:7:1: Warning: Tab character really!?
03:02:24 <lambdabot>  <hint>:1:45: error:
03:02:24 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
03:02:41 <Bish> i am not allowed to use tabs in haskell?
03:02:43 <lyxia> We don't like tabs.
03:02:48 <MarcelineVQ> you're allowed but tabs will cause you all kinds of greif with haskell
03:02:51 <ertes> yes, really…  avoid tabs in haskell…  they are peaceful until you turn around
03:02:52 <lyxia> Because Haskell is indentation sensitive
03:03:03 <Bish> hm
03:03:12 <marrenarre> MarcelineVQ: Yeah hold on maybe soon.
03:03:23 <lyxia> alignment would depend on a certain fixed tabwidth
03:03:46 <Bish> oh wow, the tcp server just worked instantly
03:03:47 <ertes> also indentation in haskell tends to be highly non-uniform
03:03:49 <Bish> im surprised
03:04:02 <ertes> but of course that's a style choice
03:04:15 <Bish> how can i see assembly created?
03:04:20 <Bish> or even the IR stuff of llvm?
03:06:06 <ertes> Bish: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#which-phases-to-run
03:06:43 <Bish> ertes: yeah found that in ghc --help already
03:06:43 <osa1> what is the non-operator version of lens's (%~) ?
03:06:50 <Bish> but i thought it uses llvm
03:07:07 <Gurkenglas> osa1, over
03:07:27 <osa1> oh, right. thanks Gurkenglas
03:07:30 <MarcelineVQ> osa1: what Gurkenglas said :> note also the docs for lens should mention this for them
03:07:31 <ertes> osa1: alternatively (%~) =)
03:07:51 <ertes> Bish: you can make it use LLVM via -fllvm
03:07:57 <ertes> Bish: it's not the default though
03:08:16 <ertes> LLVM sometimes produces better code, especially when large array operations are involved
03:08:17 <Bish> hm, guess thats something my package management does not support :
03:10:35 <Bish> oh you're not talking about the building process of ghc, i get it
03:11:06 <Bish> why isn't llvm default then? too many problems?
03:11:08 <ertes> oh, no =)
03:11:21 <Bish> since i just had one
03:11:23 <ertes> i don't know why…  the LLVM backend is rock-solid as far as i can tell
03:11:29 <ertes> but it doesn't always produce better code
03:11:32 <Bish> You are using a new version of LLVM that hasn't been tested yet!
03:11:42 <ertes> most of the time it will just be an extra dependency in your toolchain
03:11:42 <Bish> opt: /tmp/ghc1438_0/ghc_2.ll:7:6: error: unexpected type in metadata definition
03:11:54 <cocreature> until llvm is bundled with ghc it can’t be the default backend
03:12:28 <ertes> and there is actually no way to properly depend on LLVM until then
03:12:31 <Bish> would it be always do better if ghc produced better IR with llvmß
03:12:52 <Bish> s/be//g
03:13:26 <Bish> so much overhead in ghc, but guess it has to be this way because GC and all
03:13:45 <osa1> anyone know a library that provides something like this: https://gist.github.com/osa1/f7d240a38213b18efc92b635f9e119e9
03:13:47 <ertes> what kind of overhead are you referring to?
03:13:55 <Bish> size of assembly
03:14:30 <ertes> osa1: if you separate the read end from the write end, then it's just Coyoneda IORef from kan-extensions
03:15:07 <osa1> ertes: you mean if I have two separate types, one only allowign reads and another one for writes?
03:15:41 <ertes> Bish: not sure if it has to be that way, but yes, GHC tends to produce larger code, partly because of aggressive inlining
03:15:59 <ertes> osa1: yeah
03:16:14 <ertes> osa1: it's basically what you have, except not a lens, but only a getter function
03:16:19 <osa1> well the read-only type could be made Functor
03:16:28 <ertes> exactly
03:16:41 <ertes> and it's a functor for free, if you use kan-extensions =)
03:16:47 <osa1> I guess for the write-only part I could use something less general than lens because I only need setter
03:17:07 <ertes> for the write-only part you could just use an IORef
03:17:59 <osa1> but how do I write `Setter a b -> WriteOnlyIORef a -> WriteOnlyIORef b` if I just use an IORef ?
03:18:35 <ertes> well, if you want that, you can't use plain IORef =)
03:18:58 <osa1> OK
03:19:29 <ertes> but i'm pretty sure there is a contravariant functor somewhere that does exactly what you need
03:20:11 <osa1> so write-only type would be contravariant, read-only part would be functor
03:20:11 <ertes> yeah, in fact there is a contravariant version of Coyoneda, which you can use for the write end, as far as i see
03:20:16 <ertes> yeah
03:20:26 <ertes> https://hackage.haskell.org/package/kan-extensions-5.0.1/docs/Data-Functor-Contravariant-Coyoneda.html
03:20:34 <osa1> but is there anything that combines these two? like in the example I just showed
03:22:34 <osa1> ertes: can I just use Data.Functor.Contravariant for the write-only part?
03:22:47 <osa1> (from contravariant package)
03:23:05 <ertes> osa1: that's how i'd imagine it
03:23:20 <ertes> i haven't thought this through though
03:38:33 <Bish> in network.socket why is it called iNADDR_ANY
03:38:36 <Bish> that really bugs me
03:38:39 <Bish> why is the first letter small
03:40:13 <MarcelineVQ> things starting with a capital letter are Types or Constructors rather than values, I agree that that's a weird way to write that though
03:43:57 <pavonia> Bindings that want to stick to the original naming scheme usually do it this way
03:48:08 <megaTherion> Im looking for some doc/instruction how to cross-compile with ghc, anyone knowing this?
03:53:38 <Bish> haskell seems to be a great language
03:53:57 <Bish> but it does stupid things here and there which would've been easily avoided
03:55:00 <pavonia> Bish: For example?
04:01:17 <maybefbi> any body here who was interviewed by Standard Chartered? How hard was it? Was it as hard as an informatics olympiad? On leetcode would you classify it as Easy, Medium or Hard?
04:14:28 <osa1> ertes: a write-only type with contravariant instance is not as useful IMO, because it can't provide a `modify` function
04:19:26 <osa1> actually I think it's completely useless
04:36:11 <Bish> pavonia: having to write iNADDR_ANY?
04:36:37 <Bish> that is like superannoying.. there are 1001293123 different ways of writing names
04:36:40 <Bish> camecase, snake case
04:36:46 <Bish> and.. haskellcase, as it seems?
04:36:48 <Bish> geez
04:38:11 <suppi> variables start with lowercase letters, concrete types and constructors with uppercase
04:38:15 <suppi> pretty simple
04:38:59 <Bish> except that you need constants from ohter languages, that are well known with their caps presenetation
04:40:27 <suppi> so you either prefix them with something or use lowercase
04:40:51 <pavonia> Bish: It's the programmers decision to name it like that. What has that to do with the language?
04:41:20 <Bish> pavonia: yeah you might be right with that.. but i would've liked another operator for that
04:41:30 <Bish> instead of having such a strict naming conventation
04:41:45 <Bish> i mean iNADDR.. jesus, who does that.. sorry but that really hurts me
04:42:18 <suppi> the strict naming convention becomes incredibly natural, consistent and predictable after a day or two :)
04:43:08 <pavonia> Also, you can of course define mySuperFancyName = iNADDR_ANY
04:45:21 <lyxia> now there are pattern synonyms.
04:45:49 <lyxia> pattern INADDR_ANY <- ((== iNADDR_ANY) -> True) where INADDR_ANY = iNADDR_ANY
04:47:16 <delYsid> What CLI argument parsing library can you suggest?
04:47:23 <Bish> is that kinda like a macro?
04:47:31 <Bish> on what level that will be done?
04:47:34 <lyxia> delYsid: I highly recommend optparse-applicative
04:47:58 <suppi> ^
04:48:44 <osa1> optparse-applicative
04:49:51 <lyxia> Bish: it's a construct within the language to name patterns like we name expressions with let.
04:50:16 <lyxia> it's only toplevel though
04:55:47 <delYsid> lyxia: looks nice, thanks
05:15:49 <screggs> retu.348
05:41:23 <bollu> if I have a sum type S = A | B | C, is there a way to "or" two prisms? (_A <||> _B) or something
05:42:39 <chrisIrcTheFirst> Hello! :) is there a way to surround code on here? `let x = "test"` or something?
05:42:45 <lyxia> bollu: failing does something along those lines
05:42:51 <bollu> chrisdotcode: what do you mean by surround?
05:42:59 <bollu> > let x = "test" in x ++ x
05:43:02 <lambdabot>  "testtest"
05:43:06 <bollu> chrisIrcTheFirst: ^ 
05:43:23 <bollu> lyxia: thanks, I shall take a look
05:43:29 <bollu> lyxia: lens is huge :(
05:43:37 <bollu> lyxia: I need a way to know where to find what I need
05:43:57 <lyxia> yeah I'm not sure what's a good way...
05:44:18 <chrisIrcTheFirst> > respondHtml :: ConvertibleStrings a Data.Text.Internal.Lazy.Text => a -> ActionM ()
05:44:18 <chrisIrcTheFirst> respondHtml = html . convertString
05:44:21 <lambdabot>  error:
05:44:21 <lambdabot>      Not in scope: type constructor or class ‘ConvertibleStrings’error:
05:44:21 <lambdabot>      Not in scope:
05:44:33 <lyxia> I'm just starting to remember things from having gone through the whole library tens of times to answer this kind of question
05:44:53 <osa1> anyone know how to fix the overlapping instance problem here http://lpaste.net/352712 I can't enable the last line, GHC complains, saying that two instance declarations overlap
05:44:58 <chrisIrcTheFirst> Haha, well anyway I've got that function and it's giving me an error of: Non type-variable argument
05:44:58 <chrisIrcTheFirst>         in the constraint: ConvertibleStrings
05:44:58 <chrisIrcTheFirst>                              a Data.Text.Internal.Lazy.Text
05:45:27 <bollu> lyxia: in terms of "real life use" going through lens?
05:45:31 <bollu> or skimming the docs?
05:45:38 <chrisIrcTheFirst> I don't agree with the error message, could anyone explain why I'm getting that error message?
05:45:44 <lyxia> bollu: skimming the docs
05:45:45 <bollu> chrisIrcTheFirst: can you post the code on lpaste.net
05:45:45 <bollu> ?
05:45:49 <bollu> lyxia: I see
05:46:09 <bollu> lyxia: I don't understand the type magic in lens very well (how prisms can "correctly" decay to traversals, etc)
05:46:16 <bollu> lyxia: I'm hoping it will make sense with repeated use
05:46:45 <chrisIrcTheFirst> http://lpaste.net/352713 - can anyone help me understand this error message?
05:47:18 <chrisIrcTheFirst> As far as I can understand both `a` and `Data.Text.Internal.Lazy.Text` are type variables? 
05:47:30 <lyxia> chrisIrcTheFirst: a is a type variable (starts with a lowercase)
05:47:37 <lyxia> chrisIrcTheFirst: Text is a type constructor
05:47:41 <dramforever> Data.Text.Internal.Lazy.Text is a concrete type
05:48:05 <dramforever> (ConvertibleStrings a Data.Text.Internal.Lazy.Text) as a constraint is not normally allowed in Haskell. 'Use FlexibleContexts to permit this'
05:48:22 <dramforever> To do this, put {-# LANGUAGE FlexibleContexts #-} at the top of your file
05:48:49 <chrisIrcTheFirst> a is a concrete type too though? Isn't it?
05:49:13 <geekosaur> no, it's a variable
05:50:30 <dramforever> chrisIrcTheFirst: You can substitute some concrete type in for a
05:50:34 <geekosaur> "a" is a marker for a type that must be inferred from use (or specified explicitly with a type ascription (e.g. `(value :: Int)`)
05:50:36 <dramforever> but you cannot do so for Text
05:50:55 <geekosaur> Text is a concrete type; it can't be inferred, it is explicit, uses can't alter it
05:51:58 <lpaste_> lyxia annotated “No title” with “to osa1 (annotation)” at http://lpaste.net/352712#a352714
05:52:08 <lyxia> osa1: I changed just the instances
05:52:49 <osa1> lyxia: it doesn't fix the problem though
05:52:49 <chrisIrcTheFirst> geekosaur, dramforever - Thank you. Guess I have some reading to do!
05:53:29 <lyxia> osa1: what is the problem?
05:53:41 <osa1> lyxia: overlapping instances when last line is enabled
05:53:53 <osa1> this only depends on base try it
05:54:04 <lyxia> osa1: that's what I meant to fix, and it compiles fine.
05:54:09 <osa1> huh
05:54:29 <osa1> oh sorry, one sec
05:55:15 <osa1> thanks lyxia
05:55:23 <lyxia> yw
05:55:42 <bollu> what are the collection of things that can be "review"wed?
05:55:48 <bollu> only Prisms?
05:56:35 <dramforever> How would you convince one that the benefits of non-strict semantics outweigh the performance uncertainty and penalty?
05:56:43 <lyxia> bollu: "Review"
05:56:57 <bollu> lyxia: yes, so, like, what all can Review "match" with"
05:57:02 <bollu> lyxia: the types are somewhat.. dense
05:59:18 <lyxia> The docs mention Iso and Prism, and I guess the list is exhaustive for the "standard" optics.
05:59:28 <bollu> I see, thank you
05:59:34 <bollu> lyxia: Iso captures isomorphism?
05:59:55 <lyxia> yeah
06:03:41 <bollu> is there an idiomatic lensy way to write    f (o ^. lens1 . lens 2 . lens3)    ?
06:03:57 <bollu> some way to avoid the awkward "f" that is "outside"?
06:04:12 <bollu> o ^. lens1 . lens 2 . lens3 & f     would work?
06:04:45 <lyxia> :t ?f (o ^. ?l)
06:04:48 <lambdabot> (?l::Getting t Expr t, ?f::t -> t1) => t1
06:04:56 <dramforever> 'to' converts a function into a getter
06:04:58 <lyxia> :t (o ^. to ?f . ?l)
06:05:01 <lambdabot> (?l::(a -> Const a a) -> a1 -> Const a a1, ?f::Expr -> a1) => a
06:05:20 <bollu> lyxia: is the order not wrong?
06:05:25 <lyxia> I may have gotten it wrong
06:05:30 <lyxia> :t (o ^. ?l . to ?f)
06:05:32 <lambdabot> (?l::(s -> Const a s) -> Expr -> Const a Expr, ?f::s -> a) => a
06:05:49 <bollu> yeah
06:05:51 <bollu> hm
06:05:59 <lyxia> is this implicit param thing readable?
06:06:05 <bollu> :t to
06:06:08 <lambdabot> (Contravariant f, Profunctor p) => (s -> a) -> Optic' p f s a
06:06:09 <lyxia> :t \ f l -> (o ^. l . to f)
06:06:12 <lambdabot> (s -> a) -> ((s -> Const a s) -> Expr -> Const a Expr) -> a
06:07:24 <bollu> what is Optic' ?
06:07:53 <delYsid> Heh, I just used Haskell @ work for the first time ever, and it has turned out quite well.  Just 200 lines of a Web API client.  But it feels a lot more save then the previous  Python version.
06:08:41 <delYsid> Thanks wreq and trifecta!
06:09:23 <bollu> > "woo" ^. (to (++ "hello"))
06:09:27 <lambdabot>  "woohello"
06:09:30 <bollu> I'm sorry but that really hurts my brain
06:09:50 <bollu> so, like, a lens (an accessor) now provides you an "augmented" view of the original object?
06:09:57 <bollu> in a sense, I can create "fake" lenses?
06:09:59 <bollu> well
06:10:01 <bollu> not "fake"
06:10:08 <lyxia> bollu: types in lens have this shape: (a -> f b) -> s -> f t, Optic is the type synonym for this shape.
06:10:08 <bollu> but, like, "alternate reality lenses"?
06:10:12 <delYsid> (BTW, wreq is not in stackage it seems.  What determines if a package needs to be put in extra-deps? wreq seems quite nice, so i wonder why it isn't there.)
06:10:19 <bollu> lyxia: but there is an extra p in the optic
06:10:27 <lyxia> bollu: yeah it generalizes a bit further
06:10:32 <lyxia> for prisms and isos
06:10:43 <bollu> > 1 ^. (to (\x -> if x > 10 then 10 else x))
06:10:48 <lambdabot>  1
06:10:57 <bollu> > 20 ^. (to (\x -> if x > 10 then 10 else x))
06:11:00 <lambdabot>  10
06:11:06 <bollu> oh my god that is _so cool_
06:11:14 <lyxia> then the whole library is about what happens when you make various constraints about f and p.
06:11:32 <bollu> I see
06:11:37 <bollu> lyxia: lens is so cool :D
06:11:45 <bollu> lyxia: how do I map with a lens?
06:11:58 <bollu> map (^. (to (\x -> if x > 10 then 10 else x))) [8…12]
06:12:04 <bollu> > map (^. (to (\x -> if x > 10 then 10 else x))) [8…12]
06:12:07 <lambdabot>  error:
06:12:07 <lambdabot>      Variable not in scope: … :: Integer -> Integer -> s
06:12:10 <bollu> thereuhh
06:12:12 <bollu> uh
06:12:37 <bollu> > map (^. (to (\x -> if x > 10 then 10 else x))) [8..12]
06:12:40 <lambdabot>  [8,9,10,10,10]
06:12:46 <bollu> there is a more elegant way to write that I think? ^
06:12:51 <lyxia> > [8 .. 12] ^. traverse . to (+1)
06:12:54 <lambdabot>  error:
06:12:55 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M178707174857...
06:12:55 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
06:13:00 <lyxia> -_-
06:13:06 <bollu> > [8 .. 12] ^. traverse . to (+1) :: [Int]
06:13:07 <bollu> :)
06:13:09 <lambdabot>  error:
06:13:09 <lambdabot>      • No instance for (Enum [Int])
06:13:09 <lambdabot>          arising from the arithmetic sequence ‘8 .. 12’
06:13:23 <bollu> > ([8 .. 12] ^. traverse . to (+1)) :: [Int]
06:13:27 <lambdabot>  error:
06:13:27 <lambdabot>      • No instance for (Enum [Int])
06:13:27 <lambdabot>          arising from the arithmetic sequence ‘8 .. 12’
06:13:29 <bollu> no?
06:14:42 <dramforever> delYsid: May I ask you a question? Where did you learn about trifecta?
06:15:59 <Tuplanolla> > [8 .. 12] ^.. traverse . to (+ 1) -- One strategically placed dot, bollu.
06:16:02 <lambdabot>  [9,10,11,12,13]
06:17:32 <bollu> Tuplanolla: ah
06:25:52 <padre_angolano> I used to run ghc7 in haskell98 compat mode using ghci --hide-package base --package haskell98, but ghc8 says there is no option --hide-package anymore. What's to be used instead? 
06:29:52 <lyxia> padre_angolano: doesn't your ghc suggest -hide-package
06:37:24 <nitrix> SpaceX CRS-10, T minus 2 minutes. (https://www.youtube.com/watch?v=giNhaEzv_PI)
06:38:44 <bollu> :t (^..)
06:38:46 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
06:42:22 <bollu> why does it need the endomorphisms on [a]? o_O
06:42:28 <bollu> wait, what is the type of Getting?
06:42:33 <bollu> :t Getting
06:42:35 <lambdabot> error:
06:42:35 <lambdabot>     • Data constructor not in scope: Getting
06:42:36 <lambdabot>     • Perhaps you meant one of these:
06:42:43 <bollu> yeah, that won't be around as it is a type alias
06:42:52 <bollu> Tuplanolla, lyxia: could you explain Getting to me?
06:44:23 <lyxia> bollu: type Getting r s a = (a -> Const r a) -> s -> Const r s, and Const r s is isomorphic to r. So Getting r s a = (a -> r) -> (s -> r)
06:45:09 <bollu> lyxia: and (^..) becomes (a -> Endo [a]) -> (s -> Endo [a])
06:45:33 <bollu> lyxia: Endo [a] is mysterious
06:47:05 <padre_angolano> lyxia: no, -hide-package doesn't work either
06:47:59 <lyxia> padre_angolano: can you paste your error message
06:48:39 <padre_angolano> grg@dell.1:~$ stack ghc -hide-package base
06:48:40 <padre_angolano> Invalid option `-hide-package'
06:48:44 <padre_angolano> grg@dell.1:~$ stack ghc --hide-package base
06:48:44 <padre_angolano> Invalid option `--hide-package'
06:49:21 <Tuplanolla> Not `stack ghc -- --hide-package base`, padre_angolano?
06:49:32 <mroman> Couldn't one write a safer version of Chan using Locks?
06:49:41 <mroman> and by safer I mean in regards to isEmptyChan 
06:50:06 <Tuplanolla> You mean `TChan`, mroman?
06:50:14 <mroman> or is there some laziness problem involved there.
06:50:45 <mroman> i.e. if I put something into an MVar/IORef but it's not actually fully reduced to a value.
06:51:00 <padre_angolano> Tuplanolla: works this way, thanks!
06:51:28 <padre_angolano> Tuplanolla: hmm, it works for ghc, but not for ghci
06:51:34 <mroman> I read that TChan has some disadvantages over Chan.
06:51:37 <dramforever> mroman: 'I can't see a way to fix this in the implementation of Chan while retaining the properties and the other operations it has.'
06:51:55 <dramforever> Quoting simonmar https://ghc.haskell.org/trac/ghc/ticket/4154#comment:1
06:52:22 <Tuplanolla> Simon says, so you better believe.
06:52:30 <mroman> I don't trust that guy.
06:52:31 <mroman> :D
06:52:35 <mroman> and it's 7 years old
06:55:59 <mroman> locks are single wake-up too if I read this correctly.
06:59:28 <lyxia> bollu: a Getting is a kind of traversal. You give it a function converting values a to elements of a monoid r, and the traversal combines these elements together.
06:59:49 <bollu> ah
07:00:05 <lyxia> bollu: (^..) gives the function (:)
07:00:14 <bollu> I see
07:00:30 <bollu> quick question, why is there no for_?
07:00:47 <lyxia> what for?
07:01:01 <dramforever> :t for_
07:01:04 <lambdabot> (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
07:01:13 <dramforever> bollu: What are you talking about :P
07:02:22 <dramforever> bollu: It's found in Data.Foldable. Tip: keep this as a bookmark: http://hackage.haskell.org/package/base-4.9.1.0/docs/doc-index-All.html
07:02:56 <bollu> ahh x
07:02:59 <bollu> ah thanks
07:03:12 <bollu> dramforever: I was looking in Data.Traversable xD
07:06:43 <Welkin> or you could use local hoogle, or search hayoo like I do
07:17:26 <Eduard_Munteanu> Somewhat offtopic: if A :> B and A :> C(A), are there any sound type systems which allow you to get a C(B) <: B for free?
07:17:45 <Eduard_Munteanu> (<: denotes subtyping)
07:19:16 <Eduard_Munteanu> (It's one of the things that bugs me about Java et. al)
07:19:17 <NickHu> Eduard_Munteanu: Is that not just covariance?
07:19:33 <NickHu> Oh, sorry, contravariance, didn't see the second was flipped
07:20:22 <Eduard_Munteanu> I mean it should be possible to rebase a class definition from one class to another, provided the latter is a subtype of the former.
07:22:41 <Welkin> there is no subtyping in haskell
07:23:04 <Welkin> which I see as a good thing
07:23:38 <NickHu> It's basically what fmap is for, no?
07:23:42 <Welkin> no convoluted inheritance trees to trace through
07:30:02 <thatguy> how do I make a data type for vectors of dimension n? I want to have some data type which takes some integer n and only lists of length n of the type a, but I don't know how to do that with lists
07:30:35 <Welkin> thatguy: you can't without dependent types
07:30:45 <Rembane> thatguy: Repa has something like that.
07:30:59 <thatguy> I want to do it on my own to undertand how I would do stuff like that
07:31:02 <Welkin> you might be able if you make your own list datatype that includes the length
07:31:30 <thatguy> in a big scope I want to implement some numeric procedure and for that I need vectors since it is about functions from R^n -> R^n
07:31:34 <thatguy> but somehow I don't know where to start
07:32:18 <Tuplanolla> Repa has static shapes, not static sizes, Rembane.
07:34:05 <thatguy> Welkin, yeah maybe I'll do that
07:34:12 <thatguy> thanks
07:40:03 <Rembane> Tuplanolla: Oh, good point. Thank you.
07:43:49 <reactormonk> What are my options for making ghci output more readable?
07:43:50 <thatguy> could I use something like array (1, n) for my problem?
07:45:46 <Tuplanolla> @hackage vector
07:45:47 <lambdabot> http://hackage.haskell.org/package/vector
07:45:56 <Tuplanolla> Try that one, thatguy.
07:48:13 <thatguy> Tuplanolla, thanks
07:50:38 <Tuplanolla> I wonder how one should go about adding dependent resources to `ResourceT`.
07:51:18 <thatguy> but how would I define safe addition between to vectors?
07:51:30 <thatguy> if I cannot fix their size
07:51:42 <Tuplanolla> You can't, as Welkin said, thatguy.
07:52:08 <Welkin> there is liquid haskell for dependent types
07:52:11 <Welkin> I've never used it though
07:52:56 <Welkin> https://github.com/ucsd-progsys/liquidhaskell/
07:53:26 <thatguy> so no one of you ever did such stuff? I mean everything I want to do is implement newtons method or gradient descent in R^n for some abstract function class with a gradient property
07:53:46 <thatguy> Am I doing something wrong or is this just way easier in imperative languages than in haskell?
07:55:13 <sternmull> thatguy: I think this is a problem with haskells type system. In C++ you can use integers as type parameters. This allows to describe NxM matrixes and the possible operations on them. As far as i know there is no way to do such thing in haskell.
07:55:17 <ertes> thatguy: the 'linear' package has such a type built-in
07:55:45 <Tuplanolla> It's not clear what you want to be fixed, thatguy.
07:57:06 <sternmull> I think he wants to define stuff like matrix vector products.
07:57:16 <thatguy> sternmull, yes integers as type parameters describes what I need I think
07:57:33 <Tuplanolla> There's a big difference between "user supplies size; program carries witness" and "programmer supplies size; template system creates specializations".
07:58:02 <Tuplanolla> The former can't be easily done in Haskell, but the latter is manageable with TH.
07:59:50 <thatguy> Tuplanolla, I want to have something like an abstract data type function which has some fixed dimension so that I have an evaluation, gradient and hesse matrix for that adt. and these gradient and hesse matrix will all depend of the dimension where the function operates in
07:59:59 <thatguy> but it could be that I am thinking this through very wrong
08:00:21 <thatguy> and this is done very differently in haskell
08:01:10 <lpaste_> bollu pasted “observer-pattern-encoding” at http://lpaste.net/352715
08:01:14 <lpaste_> bollu pasted “observer-pattern-encoding” at http://lpaste.net/352716
08:01:23 <bollu> is anyone familiar with the encoding of the observer pattern I am using?
08:01:36 <bollu> I think I can show that it is the same as a DFA with, like, "effectful" edges
08:01:54 <bollu> but I would love to hear everyone's thoughts
08:09:42 <t4nk312> Hello, friends! How do I declare mutiple constants in a single line in ghci? Like let x = 2 y = 5 in x*y
08:10:08 <lyxia> x = 2 ; y = 5
08:10:24 <t4nk312> Thank you! 
08:10:28 <hpc> > let x = 2; y = 5 in x*y
08:10:31 <lambdabot>  10
08:10:50 <hpc> > let {x = 2; y = 5} in x*y -- sometimes if you are getting parse errors this helps too
08:10:53 <lambdabot>  10
08:16:47 <ertes> bollu: i suppose the existential 's' is a type for internal state?
08:16:59 <bollu> ertes: yep
08:17:07 <bollu> ertes: so that different observers can maintain custom state
08:19:11 <ertes> bollu: is the user of the observer supposed to use the updated observer in the next frame?
08:20:44 <bollu> ertes: no, I was thinking of it like "spawning a new actor on an event recieve"
08:20:51 <bollu> ertes: so, if you want, you can create a new observer
08:20:58 <thatguy> data Params a :: * can someone explain me what this means?
08:21:13 <bollu> which is what I do in the "mk_number_observer"
08:21:14 <thatguy> either I forgot or I have not seen such a declaration anywhere in the cis 194 tutorial
08:21:21 <ertes> bollu: how is the state supposed to change?
08:21:42 <bollu> ertes: ah, right, It's not. I'm just using it as Reader now
08:21:56 <bollu> ertes: hm, so I can the "s", right?
08:22:06 <ertes> bollu: i see…  reason i ask is that there is a slightly different encoding of the same thing
08:22:11 <bollu> ertes: do tell
08:22:12 <ertes> bollu: *if* it were state
08:22:23 <ertes> if it's just reader, it doesn't matter
08:22:27 <bollu> ertes: I wanted to model the ability to create a new state 
08:22:34 <bollu> to create a new observer*
08:22:47 <ertes> bollu: are you familiar with the automaton arrow?
08:23:40 <bollu> ertes: no
08:23:43 <bollu> ertes: that sounds interesting
08:24:09 <ertes> bollu: there are at least two ways to encode it…  the following may look familiar to you:
08:24:30 <ertes> data Auto a b = forall s. Auto ((s, a) -> (s, b)) s
08:24:39 <ertes> a state transition function together with the current state
08:25:08 <bollu> ah, okay
08:25:09 <ertes> this is similar to your Observer, except that you're transforming into a monad, and that your state is not actually state
08:25:12 <bollu> yes
08:25:25 <ertes> data Auto m a b = forall s. Auto ((s, a) -> m (s, b)) s
08:25:27 <bollu> ertes: also, I'm transitioning into a new "Observer" as well
08:25:41 <ertes> yeah, now there is a different way to encode the same thing
08:25:46 <bollu> do tell
08:26:02 <ertes> newtype Auto m a b = Auto { stepAuto :: a -> m (b, Auto m a b) }
08:26:37 <bollu> hm, I see
08:26:55 <bollu> my type is just this with the extra (e -> Maybe a) thing
08:26:57 <ertes> the state value is no longer necessary, because the transition itself can carry state
08:27:05 <bollu> yeah
08:27:16 <ertes> like:  countFrom x = Auto (\_ -> pure (x, countFrom (x + 1)))
08:27:23 <ertes> yeah, you have a filter
08:27:27 <bollu> yes, understood
08:27:43 <bollu> ertes: so the idea not new? :)
08:28:13 <ertes> well, consider this: Auto is a category (a Category in fact)
08:28:41 <ertes> if you could make filtering just another link in the automaton chain, then you no longer have to hardcode it into your type
08:28:49 <ertes> however, Auto is not quite powerful enough for that
08:29:02 <bollu> ertes: OK
08:29:05 <ertes> if you add the missing piece you essentially end up with Pipe from pipes =)
08:29:08 <bollu> ertes: so how do you add the extra power?
08:29:10 <bollu> oh xD
08:29:17 <bollu> so, wait, my type is isomorphic to Pipe?
08:29:25 <bollu> interesting :P
08:29:35 <ertes> nope, yours is similar to Consumer
08:29:46 <ertes> not sure if isomorphic, but very similar
08:29:53 <bollu> I see
08:30:04 <bollu> what does Pipe have that is "extrea"?
08:30:08 <bollu> extra*
08:31:48 <ertes> the way Auto is defined each output value corresponds to exactly one input value
08:34:03 <ertes> Pipe splits that up (here is what it might look like, if it were defined directly):  newtype Pipe a b m r = Pipe (m (Step a b m r));  data Step a b m r = Done r | Get (a -> Pipe a b m r) | Put b (Pipe a b m r)
08:34:26 <ertes> it can consume without producing and vice versa
08:35:56 <bollu> ertes: hm
08:36:23 <bollu> ertes: I see
08:37:43 <clmg> I have two data constructores: Split and Window. Each window needs to link a parent Split and each split needs to link to two child Windows. How do I accomplish this?
08:43:32 <lpaste_> bollu pasted “free-monad-gadt” at http://lpaste.net/352718
08:43:42 <bollu> why do people not encode the free monad this way?
08:43:57 <bollu> oh, wait, this is Free (Identity) a
08:44:01 <leshow> if I have a type like data Thing f a = Thing (f a). I expected the type to be * -> * -> *, because we have to apply an f and an a to the left side to get a concrete type. instead the kind is (* -> *) -> * -> * , why?
08:44:05 <bollu> give me 10
08:44:17 <leshow> kind sorry, not type
08:44:33 <ertes> bollu: perhaps because that's not free monads =)
08:44:37 <bollu> ertes: yeah xD
08:44:41 <bollu> ertes: let me modify it
08:44:47 <bollu> ertes: what I have is Free Identity a :P
08:48:21 <DemiMarie> So apparently my problems with cabal-install on yesod and pandoc were due to an old version of Cabal and cabal-install
08:50:55 <bollu> ertes: is there a way to derive "free applicative"?
08:51:59 <dolio> Yes.
08:51:59 <ertes> bollu: the 'free' package has a lot of free stuff, including free applicatives
08:52:13 <dolio> There is a systematic way to construct free anything.
08:52:49 <ertes> and a systematic way to nstruct cofree anything
08:52:55 <dolio> Yes.
08:53:05 <bollu> dolio: do tell :)
08:53:07 <ertes> (yes, that's a thing)
08:53:22 <bollu> ertes: yeah, I know
08:53:26 <bollu> ertes: (well, I can imagine)
08:53:35 <bollu> ertes: (co)nstruct is clever :P
08:53:51 <dolio> Well, "free" means it comes from a functor that is left adjoint to a forgetful functor.
08:54:01 <dolio> F ⊣ U
08:54:08 <JonReed> Hi, does anybody know why conduits don't print live output from shell, until the program exits. Here is a small example in 6 lines of relevant code: http://lpaste.net/352719
08:54:18 <bollu> how come there is no "cofree coapplicative" ?
08:54:27 <bollu> dolio: yes, but that is hardly "constructive"?
08:54:57 <suppi> clmg: split them to different types?
08:55:11 <dolio> And if you go read about Kan extensions, you'll find this fact: Ran G G ⊣ G iff G has a left adjoint.
08:55:12 <JonReed> That example will not output anything, but out.txt will get populated indicating that the shell streams normally
08:55:18 <dolio> Er, sorry.
08:55:22 <dolio> Ran G Id ⊣ G
08:55:35 <bollu> dolio: how is the fact that it is left adjoint to a forgetful functor useful in _constructing_ the free functor?
08:56:06 <locallycompact> what's the point in free anything
08:56:11 <dolio> And when you're dealing with Haskell, at least, there are formulas for writing down Kan extensions.
08:56:14 <locallycompact> I have no intuition for this
08:56:18 <bollu> dolio: isn' the right kan extensino also defined by a universal property?
08:56:56 <bollu> locallycompact: roughtly, a "free X from Y" is a formula to start with Y, and all minimal structure to make it X
08:57:03 <bollu> s/all/add
08:57:09 <bollu> dolio: oh, interesting
08:57:11 <locallycompact> right
08:57:16 <bollu> dolio: what is the process to construct the Kan extensin?
08:57:18 <bollu> extension*
08:57:43 <locallycompact> so when someone says free monad what's the idea?
08:58:25 <bollu> locallycompact: it means that given a functor f, you can create a new object FreeMonad(f), which uses f (functorially) to create a structure that obeys the monad laws
08:58:41 <bollu> locallycompact: Free monads are interesting as you can think of them as constructing a DSL "over" f in some sense
08:58:52 <Squarism> I have a habit of constructing maps using : M.fromList $ fmap (\e -> (,) (createKey e) e) listOfLeems ... which gets a bit bulky. So i wondered if there could be something like : (\a -> k) -> [a] -> Map k a ... available in the standard apis?
08:58:59 <dolio> So, the coend formula for Ran is: Ran p f d = end c. power(D(d, p c), f(c))
08:59:06 <locallycompact> bollu, got an example?
08:59:12 <bollu> dolio: dang, you just hit the wall of my category theory knowledge
08:59:37 <bollu> locallycompact: explained much better: http://dlaing.org/cofun/posts/free_and_cofree.html
08:59:38 <dolio> But, D being the hom-set of the category D.
08:59:47 <locallycompact> nice cheers
08:59:59 <dolio> Anyhow, power and D are both going to look like some sort of function space in Haskell.
09:00:08 <dolio> And ends are 'forall'.
09:00:13 <bollu> dolio: I don't understand Kan extensions very well either
09:00:32 <dolio> And the only thing left to fix up is the number of arguments.
09:00:51 <dolio> Which you do by adding arguments to Ran, and passing them to 'f'.
09:01:37 <bollu> hm
09:01:43 <bollu> dolio: time to amass more category theory
09:01:57 <bollu> dolio: where did you study category theory from?
09:02:03 <dolio> The internet.
09:02:57 <bollu> also, quick question: free monads are worse for performance because they build up "layers" of Free?
09:03:12 <dolio> Worse than what?
09:03:22 <bollu> algebraic effects AFAIK?
09:03:31 <bollu> extensible effects*
09:03:34 <dolio> Algebraic effects are free monads.
09:04:15 <bollu> dolio: but, there is the whole "MTL versus Free"?
09:05:58 <Welkin> I haven't heard of any performance arguments
09:06:13 <Welkin> only granularity of control over effects
09:06:22 <Welkin> using extensible effects vs monad transformers
09:06:27 <dolio> If you ask me, they're all minor variations on the same thing.
09:15:37 <ertes> bollu: free monads don't have any inherent cost
09:15:48 <bollu> ertes: hm, I see
09:16:06 <ertes> you can only ask this question in the context of a particular application
09:17:51 <ertes> example: if you ever need "IO with breakpoints", Free IO is pretty much the cheapest option
09:19:39 <maksim__> does anyone know how to change the default dist dir for stack? 
09:21:00 <Welkin> there should be an option in your stack config
09:21:02 <Welkin> check the docs
09:21:33 <Welkin> maksim__: https://docs.haskellstack.org/en/stable/yaml_configuration/
09:21:39 <lyxia> --work-dir WORK-DIR      Override work directory (default: .stack-work)
09:21:47 <maksim__> that changes the entire work dir
09:22:03 <maksim__> i want to change just where things get built to
09:22:12 <Welkin> what do you mean?
09:22:26 <Welkin> you want the binaries copied to somewhere else?
09:22:36 <maksim__> the binaries and the autogen
09:22:37 <Welkin> https://docs.haskellstack.org/en/stable/yaml_configuration/#local-bin-path
09:23:04 <Welkin> `stack install` already copies the binaries to ~/.local/bin
09:23:10 <maksim__> yes i'm not talking about that
09:23:18 <Welkin> you can change that though
09:23:29 <maksim__> i'm talking about the entire build dir
09:23:34 <Welkin> why?
09:23:44 <maksim__> because i have assets that are generated by setup
09:24:18 <Welkin> in the worst case, you can write a shell script to do this for you
09:24:31 <maksim__> yes but i would like to not do that because it just adds more complexity 
09:24:32 <Welkin> you don't need this to be a stack feature
09:24:54 <Welkin> take a look through the stack docs I posted
09:24:59 <maksim__> i have
09:25:02 <Welkin> I don't know anymore about it than you at this point
09:25:37 <maksim__> okay. related question: how is it possible that for a clean cabal sandbox i still have dependencies conflicts?
09:26:19 <Akii> given a function `a -> c -> a` and `a -> b` can I write a function `b -> c -> b`?
09:26:48 <lyxia> Akii: nope
09:27:07 <Akii> thanks
09:27:11 <lyxia> Assuming you mean not "const".
09:27:29 <Akii> I just want a monad without it being a functor
09:28:05 <lyxia> That's pretty hard to do.
09:28:17 <lyxia> Every monad is in fact a functor.
09:28:26 <Welkin> maksim__: don't use a cabal sandbox; instead use stack (or nix)
09:28:44 <Welkin> it's possible you have global packages installed too that are conflicting
09:28:46 <maksim__> well i would love to but it scatters all of my compiled artifacts to the winds
09:29:31 <Welkin> maksim__: or you are not using stackage
09:29:44 <Welkin> cabal sandboxes can still run into problems with incompatible packages
09:32:14 <ertes> maksim__: conflicts have nothing to do with the tool you're using or whether you're using a clean environment…  if the set of packages you use is inconsistent, then there is only one option: use a different set
09:32:23 <ertes> (not necessarily different packages, but different versions)
09:32:36 <ertes> the goal of something like stackage is to have a supervised package set
09:32:46 <Welkin> stack uses stackage by default
09:32:52 <ertes> where maintainers actually have to make sure that dependencies don't break
09:33:14 <maksim__> yes i understand that
09:33:19 <ertes> in other words: you've become a victim of hackage freedom =)
09:34:02 <maksim__> is there a way to use a stack.yaml to generate a consistent .cabal?
09:34:02 <ertes> if you don't want to downgrade anything, your most practical option is to patch the packages that conflict
09:49:53 <Akii> lyxia: this is a mind game
09:50:12 <Akii> if that's not a functor, can I come up with a way such that you'd never come up with a functor for it
09:51:17 <Akii> this is the data type I'm trying to do something with http://lpaste.net/352722
09:51:53 <johnw> Akii: every lawful implementation of Monad provides the functionality needed to implement Functor: fmap f x = x >>= return . f
09:51:57 <Akii> this is basically a state monad but with a custom way of combining
09:52:30 <Cale> Akii: That won't be a functor because of the type of aggApply
09:52:56 <monochrom> "a -> ev -> m a" This part may prevent you from having a functor.
09:53:00 <Akii> aggApply is actually the "bind"
09:53:05 <Akii> hard to explain
09:53:08 <c_wraith> heh.  Cale and monochrome beat me to it
09:53:14 <Akii> this is what needs to happen during bind
09:53:15 <c_wraith> But yeah, that can't be a Functor
09:53:40 <c_wraith> *monochrom.  Sorry, I am typing-challenged this morning
09:54:06 <monochrom> Don't worry, I dropped the e for EFNet's 9-letter restriction anyway :)
09:54:29 <c_wraith> Akii: aggApply has the a type variable in both positive and negative positions.  That prevents it from being a Functor.
09:54:55 <Tuplanolla> Shouldn't `(a -> ev) -> m a` work though?
09:55:26 <Tuplanolla> I was wondering if `DeriveFunctor` could handle that.
09:55:29 <Akii> that would not make sense
09:55:58 <Akii> I've to go back and think about it some more
09:56:03 <Cale> Tuplanolla: Yeah, that'd be okay
09:56:35 <Akii> so the background is following: in event sourcing you "emit" events and that mutates some state
09:56:45 <Akii> and I already have a way of doing that, the state monad
09:56:52 <Akii> what I lose though, is composition
09:57:27 <Akii> so I cannot combine 2 emit things because I need to change the state as the events are emitted
09:58:03 <Cale> Akii: Not sure I understand that
09:58:18 <Akii> need to come up with an example
09:58:18 <Cale> Akii: Why isn't that just running one emit after the other?
10:03:01 <Akii> Cale: http://lpaste.net/352723
10:03:05 <Akii> I hope this is enough
10:03:28 <Akii> this is what I have
10:03:31 <Akii> it works
10:03:47 <Akii> unless you start to compose them (doStuff, doOtherStuff)
10:03:55 <Akii> that is because the state (Server) is not updated on the fly
10:04:07 <Akii> updating should be done by raising events
10:04:50 <Akii> right now it's already working; I could run this separately, get out the state and do the apply elsewhere
10:05:04 <Akii> but it really feels like something bind could do for me
10:05:43 <johnw> you could rewrite that transformer stack, to: ReaderT d (StateT [ev] (ExceptT err IO)) a
10:07:20 <Akii> (amended it to actually throw an error)
10:09:57 <Akii> I've to think about this more; pretty sure it's the right direction though
10:12:27 <siddhu_> I'm trying to write a type that could be either Word8 or Word16. I won't know for sure until runtime, but it will only be one of the two.
10:12:34 <siddhu_> What's the best way to encode such a type?
10:14:10 <lyxia> Either Word8 Word16
10:14:37 <siddhu_> And if I also need Word32?
10:15:21 <johnw> siddhu_: you'll need to use a typeclass, probably the SPECIALIZE keyword, and then start your program with an if-test series that calls the typeclass method with the proper type
10:15:39 <johnw> this will compile into your program the same code xN, where N is the number of Word types you expect to support
10:15:48 <johnw> but it has the advantage that you can get optimized code for each type
10:16:00 <johnw> and you only have to write the code itself once
10:16:11 <johnw> this is called "partial evaluation"
10:17:01 <siddhu_> johnw: cool! Wasn't aware we could do partial evaluation in Haskell. Will take a look.
10:17:16 <johnw> you can do some partial evaluation with type classes, since it specializes the code at compilation time
10:17:29 <siddhu_> And this also allows me to derive Num instances for the Word types, correct?
10:17:30 <johnw> you still can't partially evaluate on values, though, just types
10:17:41 <johnw> Word type should already have Num instances
10:17:46 <johnw> from Data.Word
10:19:11 <siddhu_> got it. Will try it out. Thanks!
10:23:23 <srbaker> Heya folks. 
10:24:35 <prohobo> no u
10:25:00 <srbaker> I am curious about "runtime dispatch". I want to have a map of regular expressions to functions, and call a function based on matching that Regex. 
10:25:18 <srbaker> Is there something like multi-dispatch that supports regex as the matcher?
10:25:23 <srbaker> Am I completely nuts?
10:26:29 <srbaker> Sorry, I think I just answered my own question when writing it here.
10:27:02 <monochrom> I would translate the regexes into automata, and have their final states indicate which function to call.
10:27:15 <srbaker> Interesting.
10:29:10 <monochrom> I go the automaton way because there is a way you can combine these automata into one giant automaton, so you are matching against multiple regexes in one go.
10:29:58 <srbaker> Thanks, I will read up on that.
10:33:31 <t4nk195> Hello, friends! Why this doesn't work as a fibonacci sequence? It seems I don't understand pattern mathing like I though I did 
10:33:33 <t4nk195> let {listGen t@(_:x@(_:_)) = (sum x):listGen t} in take 10 $ listGen [1,2]
10:37:43 <monochrom> OK, so you're saying listGen (1:2:[]) = sum (2:[]) : listGen (1:2:[])
10:39:41 <t4nk195> Hmm, but i'm telling to take last two elements in list and sum them, why sum(2:[]) ?
10:39:58 <t4nk195> I see that it's what haskell evaluates, but why?
10:40:17 <t4nk195> i'm pattern matching last two numbers, ain't I?
10:40:23 <monochrom> No.
10:40:45 <Cale> x is the tail of whatever list you're passing in
10:40:51 <Cale> and t is the whole list
10:41:03 <monochrom> match 1:(2:[]) against t@(_:x@(_:_))
10:41:06 <Cale> So if you give [1,2], then t = [1,2] and x = [2]
10:42:17 <monochrom> Another exercise: Match a:(b:(c:(d:[]))) against  t@(_:x@(_:_))
10:43:15 <t4nk195> Hmm
10:43:27 <bollu> Cale, monochrom: what are some "nice" Kan extensions? examples that I can think of are things like extending a function defined on a basis to the larger space, but I'm not sure if this is a "legit" Kan extension
10:43:40 <t4nk195> I think I'm beginning to understand...
10:45:32 <Cale> bollu: limits, colimits, and adjunctions?
10:53:56 <johnw> bollu1: the function maybeToList can be used to create a right Kan extension that turns any a -> Maybe b into an a -> [b].  It's a simplistic example, but maybe that helps you generalize.
10:59:37 <johnw> here we're trivially extending the arrow's Maybe domain into the list domain; but there can be more interesting extensions: ones that are not just strict embeddings, but may involve computation to map across the functors
11:04:46 <bollu1> johnw: I see
11:05:07 <bollu1> johnw: how do we know that it is universal?
11:05:26 <johnw> universal in what sense?
11:06:51 <bollu1> johnw: in terms of the universal property?
11:06:55 <bollu1> the existence of the natural transformation?
11:07:00 <johnw> you mean, that there exists an arrow: Functor k => (forall a. k (Maybe a) -> [a]) -> k b
11:07:03 <johnw> ?
11:07:20 <bollu1> yes
11:07:29 <bollu1> uh, I think so 
11:07:31 <johnw> let me see
11:07:57 <bollu1> https://en.wikipedia.org/wiki/File:Right_Kan_extension_universal_property_diagram.PNG <- the delta_F
11:09:21 <taktoa> anyone know a good way to describe a smooth map / smooth manifold / lie group constructively? ideally, with laws, since I'm writing idris
11:10:42 <bollu> johnw: how do you encode natural transformations between Functor?
11:10:47 <bollu> (Hask -> Hask)
11:10:52 <johnw> (forall r. f r -> g r)
11:11:03 <taktoa> (I want to write a lie group integrator based on https://t.co/NCglhx9mNY)
11:11:23 <bollu> johnw: but that does not capture the commuting diagram condition. Oh, you would need dependent typing for that I assume?
11:11:31 <johnw> no dependent typnig
11:11:34 <johnw> parametricity is enough
11:11:41 <bollu> ?
11:11:47 <bollu> could you elaborate on that please?
11:11:49 <johnw> newtype Nat f g = Nat { runNat :: forall r. f r -> g r }
11:12:02 <taktoa> bollu: I think he's saying it's a free theorem
11:12:09 <bollu> ah
11:12:22 <bollu> johnw: really? how is it "for free" ?
11:12:29 <bollu> johnw: proof, please :)
11:12:53 <johnw> the only thing such an arrow can do is map f to g
11:13:14 <johnw> it can't be affected by the "contents"
11:13:26 <bollu> hm
11:14:21 <roconnor> @free runNat :: forall r. f r -> g r
11:14:21 <lambdabot> Extra stuff at end of line
11:14:37 <johnw> bollu: https://gist.github.com/80fc71f33a4c4114578ffe9ee7d91bed
11:14:44 <roconnor> @free runNat :: F r -> G r
11:14:44 <lambdabot> $map_G f . runNat = runNat . $map_F f
11:15:23 <bollu> roconnor: wait, what does @free do? and that is commuting condition :O
11:15:48 <bollu> johnw: thank you for the gist
11:15:49 <sternmull> i want to use the Reader monad. When i try to import Control.Monad.Reader GHC says "It is a member of the hidden package 'mtl-...'". What am i doing wrong? Is mtl deprecated or something like that?
11:15:50 <roconnor> it write out the free theorem implied for parametric functions
11:16:06 <roconnor> @free sortBy
11:16:09 <lambdabot> (forall x. g x = h (f x) . f) => $map f . sortBy g = sortBy h . $map f
11:16:19 <bollu> johnw: what is the difference between Ran and Lan? (intuitively) I understand what happens to the diagrams
11:16:36 <johnw> bollu: the direction that the functor is "pulled"
11:17:33 <roconnor> (forall x y. g x y = h (f x) (f y)) => $map f . sortBy g = sortBy h . $map f  is the ususal way to write that.
11:20:22 <maksim__> is there a way in ghci to define a colon command that does step and then list
11:20:57 <roconnor> sternmull: definitely not depricated.
11:21:22 <sternmull> roconnor: But what package to i need to import Control.Monad.Reader?
11:22:05 <roconnor> for the monad itself you need transformers. for the class you need mtl, which depends on transformers
11:23:35 <johnw> bollu: try https://www.quora.com/What-is-a-laymans-explanation-of-Kan-extensions
11:23:38 <sternmull> when i have mtl and transformers it works. How do i find out what i need on my own?
11:24:04 <johnw> I like Rúnar's analogy
11:24:14 <bollu> 	johnwty
11:24:16 <bollu> johnw: ty
11:25:51 <johnw> bollu: also note how my pastie involves the "limit" of the list functor, []
11:26:11 <johnw> without that limit, I couldn't have written the function
11:26:41 <johnw> more on this at: http://comonad.com/reader/2008/kan-extensions/
11:26:50 <bollu> johnw: thanks
11:27:01 <bollu> johnw: "limit" with respect to what diagram?
11:27:20 <johnw> i wasn't thinking of any diagram
11:27:27 <johnw> just the limit of the functor []
11:27:52 <bollu> johnw: OK, limit of [] as a functor from a -> [a] ?
11:27:58 <johnw> yes
11:28:10 <maksim__> what am i doing wrong? *Main> :show modules
11:28:10 <maksim__> Databrary.Setup.Git ( Databrary/Setup/Git.hs, interpreted )
11:28:10 <maksim__> Databrary.Setup.Node ( Databrary/Setup/Node.hs, interpreted )
11:28:10 <maksim__> Main             ( Setup.hs, interpreted )
11:28:10 <maksim__> *Main> :break Main
11:28:11 <maksim__> <interactive>:1:1: Not in scope: ‘Main’
11:28:17 <johnw> or as edwardk once asked me, what value has the type forall a. [a]
11:28:22 <maksim__> whoops
11:28:32 <bollu> johnw: okay, the way I know to think of a limit is as the final object in the category of cones of [], right?
11:28:39 <maksim__> i would like to break on some line of Main or Setup.hs
11:28:41 <bollu> johnw: but, like, how do I visualise "cones of []"?
11:28:47 <johnw> bollu: i don't know, I'm unfamiliar with cones
11:28:51 <bollu> johnw: OK
11:28:59 <bollu> johnw: what is your intuition of limit?
11:29:10 <bollu> johnw: mine is that, if you have a limit of a functor F: J -> C
11:29:20 <bollu> you will get the "most general image" of F in C
11:29:26 <bollu> of J in C* wrt F
11:29:40 <bollu> in the sense that, any other image of the functor will have a unique mapping onto the limit
11:29:41 <bollu> right?
11:29:54 <johnw> I don't follow, sorry
11:30:18 <bollu> johnw: OK, can you explain to me your intuition of a limit? I could be wrong :)
11:31:42 <johnw> now that you ask, I do not know; thanks for adding to my reading list :)
11:31:56 <johnw> https://bartoszmilewski.com/2014/05/08/understanding-limits-2/
11:32:47 <johnw> my "coding" intuition is that the limit of f is a value that solves forall a. f a
11:32:50 <bollu> johnw: :)
11:32:56 <bollu> johnw: oh, that is interesting
11:33:21 <johnw> so the limit of Maybe is Nothing, the limit of Const a is any a, etc.
11:33:26 <bollu> ahh
11:33:58 <orion_> https://www.youtube.com/watch?v=sUIcCyPOA30
11:34:03 <orion_> The Elite are all about transcendence and living forever and the secrets of the universe and they want to know all this; some are good, some are bad, some are mixed. But, the good ones don’t ever want to organise, the bad instead are the ones that organise, because they lust after power. Powerful consciousnesses don’t want to dominate other people, they want to empower them, so they don’t tend to 
11:34:09 <orion_> get together until things are really late in the game, then they come together. Evil is always defeated, because good is so much stronger. And, we’re on this planet and Einstein’s physics showed it, Maxwell’s physics showed it, all of it, that there is at least twelve dimensions, and now that’s why all the top scientist and billionaires are coming out saying it’s a false hologram, it is 
11:34:14 --- mode: ChanServ set +o monochrom
11:34:15 <orion_> artificial. The computers are scanning it and finding tensions points where it is artificially projected and gravity is bleeding in to this universe, that’s what they call dark matter. So, we’re like a thought or a dream that’s like a wisp in some computer program, some god’s mind, whatever. They’re proving it all, it’s all coming out.
11:34:21 <johnw> orion_: ok, why shouldn't I ban you :)
11:34:47 --- mode: monochrom set -o monochrom
11:35:24 <Akii> johnw: good soundtrack on the video
11:35:38 <Akii> sad that some guy is talking over it though
11:36:29 <Zyxoas> Hey, y'all.
11:36:39 <Zyxoas> I have a very quick lens question...
11:36:47 <Zyxoas> Or rather, aeson-lens...
11:36:51 <johnw> Zyxoas: you have 1 second to ask
11:37:08 <Zyxoas> Haha @ johnw
11:37:14 <Akii> too late, next
11:37:19 <Akii> :D
11:37:40 <bollu> johnw: where did you get your idea of limit from?
11:37:46 <johnw> bollu: edwardk
11:38:12 <johnw> if he weren't recuperating from surgery still, he'd be here to tell you himself
11:38:20 <bollu> johnw: I see
11:38:25 <Zyxoas> Basically, the JSON looks something like this "{ dudes: [ {name : foo, surname : meister}, {name : bar, surname : ness} ]}"
11:38:57 <Zyxoas> I need to write an aeson lens which gives me a list [(foo, meister), (bar, ness)]
11:39:34 <Zyxoas> I can do ^? dudes, to get an Aeson Array, but then I get stuck a little...
11:39:53 <Zyxoas> I mean ^? key "dudes"
11:40:46 <Zyxoas> So, I just wanna extract a list of properties from a deeply embeded list of objects, and hopefully extract both properties at the same time...
11:42:21 <Zyxoas> That is, how do I compose ^.. with ^. (or, better yet, ^.. with ^?)??
11:43:26 <Zyxoas> And then, combine two lenses with the (,) function...
11:51:52 <Zyxoas> Okay, stop the presses! I honestly have no idea how this works, since I cooked it up by mixing functions randomly: ^. key "dudes" . _Array . traverse . key "name"
11:52:12 <Tuplanolla> The usual lens experience.
11:52:16 <Rembane> +1
11:52:32 <dolio> bollu: The analogy (although I'm against analogies) that I think is most helpful coming from functional programming to Kan extensions is that Kan extensions are a very general, category theory version of Church encoding.
11:52:50 <Zyxoas> I don't know whta _Array and traverse do, but this does the trick. Now to figure out how to combine two of theses with (,), instead of using zip...
11:52:53 <dolio> (And a dual of church encoding.)
11:53:49 <johnw> that's not the lens he asked for
11:54:01 <johnw> he said he wanted [(foo, meister), (bar, ness)], not [foo, bar]
11:54:21 <dolio> All Church encoding is an example of the Ran U Id ⊣ U principle I originally brought them up.
11:55:26 <Tuplanolla> Actually that might even be the usual Haskell experience.
11:55:42 <Tuplanolla> You have to make peace with not understanding everything completely.
11:56:29 <Gurkenglas_> Zyxoas, _Array . traverse is values
11:56:48 <Tuplanolla> He left, Gurkenglas_.
11:57:46 <lpaste_> pv2b pasted “An attempt at a naive prime number generator” at http://lpaste.net/352727
11:57:57 <Gurkenglas> Ah. Is there a better answer to his question than '^.. key "dudes" . values . to (view name &&& view surname)'?
11:58:49 <Gurkenglas> pv2b, genDivisors is takeWhile (<= n*n)
11:58:50 <pv2b> ghc throws a parse error at the | in the guards after the genDevisors helper function in the where clause of isPrime. I'm clearly doing something wrong, but I can't figure out what?
11:59:15 <pv2b> Gurkenglas: ah, thanks, that would probably be more ideomatic haskell, still, my original question stands :)
11:59:45 <kadoban> pv2b: Are you sure it's not on line 10? That looks like you used parens instead of [ ]
12:00:44 <pv2b> kadoban: Of course it is, that'll teach me to look at closer at the line numbers. Thank you!
12:01:00 <kadoban> Anytime
12:11:21 <johnw> I'm not sure of a better way of dealing with inner tuples like this:
12:11:23 <johnw> > "{ \"dudes\": [ {\"name\" : \"foo\", \"surname\" : \"meister\"}, {\"name\" : \"bar\", \"surname\" : \"ness\"} ]}" ^.. key "dudes".values.to (\x -> (x ^. key "name"._String, x ^. key "surname"._String))
12:11:29 <lambdabot>  error:
12:11:30 <lambdabot>      • Variable not in scope:
12:11:30 <lambdabot>          key :: [Char] -> b0 -> [Char] -> Const (Endo [(t, t1)]) [Char]
12:11:35 <johnw> => [("foo","meister"),("bar","ness")]
12:16:24 <confused_functor> Hi! Is there a way to get this function to typecheck; let f 1 = (0 :: Int8) ; f 2 = (0 :: Int16)
12:16:39 <pv2b> Okay, I've made some progress now, it works (or seems to at least) from a cursory glance. However, it only works if i leave off the type annotation of isPrime. I can't make head or tails of the error. I think it has something to do with trying to compare an Integral with an Integer, but shouldn't that "work"?
12:16:48 <pv2b> Here's the code https://www.irccloud.com/pastebin/sBKbHtn7/
12:16:53 <johnw> confused_functor: no
12:17:06 <pv2b> And the error https://www.irccloud.com/pastebin/J5KVdPAJ/
12:17:11 <johnw> confused_functor: unless you use a general type like: f :: Num a => a
12:17:28 <kadoban> confused_functor: Not really, no. There's some related things that are possible, depending on the goal.
12:18:09 <johnw> no, even then it's not possible
12:18:31 <ReinH> let f 1 = Left (0 :: Int8); let f 2 = Right (0 :: Int16)
12:18:31 <confused_functor> I'm trying to read a binary file. There's a byte in the file, which can be 1, 2, or so on. If the byte is 1, the remaining bytes are 8bits. If its 2, the remaining bytes are 16bits.
12:18:37 <kadoban> let f 1 = Left (0 :: Int8); f 2 = Right (0 :: Int16)    would be a possibility, but it's pretty funky. You can let the caller of the function choose the instance of Num if you want instead ... not really clear the goal though.
12:19:40 <confused_functor> I did write a custom data type earlier, that covered all possible values. But it gets messy. And then I have to write the Num instance for each manually. Was wondering if there's a better way
12:19:43 <ReinH> confused_functor: You'll need to use a sum type or, if it suits your domain, choose a single type that accommodates both values (like Int16).
12:20:20 <ReinH> i.e., if you need to know whether to *read* 8 bits or 16 bits, but you don't care which type you store the result as.
12:21:57 <confused_functor> ReinH: makes sense. Is there a way to derive the Num instance in the sum type? data I = I1 Int8 | I2 Int16 deriving Num throws an error
12:22:10 <ReinH> No
12:22:25 <ReinH> It isn't derivable even in theory
12:22:40 <ReinH> the compiler doesn't know whether to choose I1 or I2
12:22:51 <confused_functor> But, here's the thing. At runtime, I only have I1 or I2, definitely not both.
12:23:06 <ReinH> Yes, but what should fromIntegral 1 :: I do?
12:23:34 <ReinH> Anyway, Num isn't derivable
12:24:19 <ReinH> and what should I1 1 + I2 1 be?
12:24:35 <ReinH> so there are both theoretic and practical problems
12:24:41 <ReinH> *theoretical
12:25:54 <confused_functor> makes sense. I can write the Num instance manually then.
12:27:52 <ReinH> Well, what should I1 + I2 be?
12:27:59 <ReinH> er, I1 1 + I2 1
12:28:36 <confused_functor> I1 and I2 cannot occur simultaneously at runtime. I can leave that as undefined. It's a property I know, but not sure how to tell the compiler that.
12:30:25 <confused_functor> that property is guaranteed by the file format standard. So should be safe to just say I1 n + I2 n = undefined
12:36:55 <jmcarthur> You can tell the compiler that by keeping them different types.
12:37:34 <sternmull> can i define a class method parameter type with a constraint instead of a concrete type? I want to have something like "length :: a -> Num" instead of "length :: a -> Int".
12:38:03 <pikajude> sternmull: why do you want to do that
12:38:26 <jmcarthur> How about   length :: Num b => a -> b   ?
12:38:38 <pikajude> a -> Integer and forall b. Num b => a -> b are identical
12:38:47 <pikajude> except that the compiler doesn't like the second one very much
12:39:00 <jmcarthur> pikajude: What do you mean they are identical?
12:39:02 <sternmull> because one instance will have a Int and another an Int64 as result of length. It would be nice to keep that instead of reducing it to Int in both cases.
12:39:07 <reactormonk> Is there a way to override non-export from within ghci?
12:39:16 <reactormonk> To basically force-export a function.
12:39:18 <pikajude> jmcarthur: forall a. Num a and Integer are the same because you can call fromInteger on the second to get the first
12:39:25 <reactormonk> Debugging purposes.
12:39:38 <pikajude> jmcarthur: as far as return values are concerned.
12:39:48 <pikajude> which in this case is what's going on
12:39:58 <jmcarthur> pikajude: That just means that Integer is a subtype of (Num a => a), but it doesn't mean that every (Num a => a) might as well just be an Integer.
12:40:13 <pikajude> well, i mean in this case specifically
12:40:35 <sternmull> "length :: Num b => a -> b" look good. Thanks!
12:40:53 <jmcarthur> I also disagree with that. Perhaps you might want to have a different evaluation strategy than Integer would permit, for example.
12:41:08 <pikajude> ok
12:42:37 <sternmull> the reason i want to do this is to have a type class that lazy and strict ByteStrings are instances of. So that i can write generic functions that work for both without having me to explicitly call the functions for the exact type.
12:43:09 <ReinH> You can, e.g., lazily calculate the length such that you can determine that an infinite list has more than 65 elements, but not with Integer.
12:46:48 <sgript> Is someone able to help me with a list comprehension? 
12:49:41 <siddhu> sgript: I could try
12:50:11 <sgript> cool, can I explain to you in dm to keep this clean?
12:50:24 <siddhu> sure
12:51:48 <Welkin> lol, since when was it called a "dm"
12:51:51 <Welkin> since twitter?
12:51:58 <Welkin> I've always heard it called a "pm"
12:53:19 <pikajude> well, you can't slide into PMs
12:53:27 <maksim__> this probably isn't the place to whine but i'm losing my mind. at every turn something else fails http://pastebin.com/6eZ4CDAm
12:54:07 <pikajude> isn't the correct way to do it `stack exec ghci`
12:54:42 <maksim__> it doesn't matter since ghci doesn't respect ghc_package_ath
12:54:45 <maksim__> it doesn't matter since ghci doesn't respect ghc_package_path
12:55:06 <ddddrelease> hi  room
12:55:58 <AndreasK> maksim__: Why are you trying to use a custom package path with stack though?
12:56:29 <maksim__> because GHC_PACKAGE_PATH isn't respected 
12:56:38 <ddddrelease> hi AndreasK
12:56:50 <Welkin> maksim__: did you already nuke from orbit?
12:57:01 <AndreasK> stack ghci should find all packages installed by stack afaik
12:57:07 <maksim__> try it
12:57:13 <AndreasK> Will do later
12:57:14 <Welkin> before installing with stack, did you completely remove your ~/.cabal and ~/.ghc ?
12:57:18 <maksim__> no
12:57:21 <Rembane> No
12:57:37 <Welkin> maksim__: try it
12:58:01 <Welkin> also, use the --install-ghc options when using stack install
12:58:10 <maksim__> i always do
12:58:56 <maksim__> Welkin, post nuke same thing
12:59:13 <maksim__> it's not doing anything with -package-db
12:59:53 <Welkin> what are you trying to do?
12:59:57 <Welkin> just run ghci?
13:00:03 <maksim__> i'm trying debug a Setup.hs
13:00:34 <maksim__> it gets to the confgure hook and croaks because it thinks i have no dependencies installed but i clearly do
13:01:03 <Welkin> I have never touched Setup.hs in my life
13:01:04 <maksim__> this is literally the most painful dev experience i've ever had and i haven't even written a line of haskell yet
13:01:08 <Welkin> I just use the autogenerated one
13:01:17 <maksim__> i inherited this one
13:01:29 <Welkin> what do you mean?
13:01:45 <maksim__> meaning i inherited a project someone else wrote that didn't use stack
13:01:52 <Welkin> oh
13:01:55 <maksim__> my first goal was to incorporate stack
13:02:12 <Welkin> I've switched to stack before and it was super easy
13:02:12 <maksim__> i think my second goal will be to rewrite the entire app in Go
13:02:22 <Welkin> what is in the Setup.hs?
13:02:22 <maksim__> will probably be easier
13:02:28 <Welkin> mine are usually 2 lines
13:02:32 <maksim__> https://github.com/databrary/databrary/blob/master/Setup.hs
13:02:47 <maksim__> why isn't -package-db working
13:02:54 <maksim__> what magic thing am i missing
13:03:14 <Welkin> lol
13:03:16 <Welkin> mine look like this
13:03:17 <Welkin> import Distribution.Simple
13:03:18 <Welkin> main = defaultMain
13:03:24 <maksim__> that's great but mine doesn't
13:03:27 * hpc has never seen a Setup.hs that actually did something before
13:03:37 <maksim__> and in order to simplify this one i need to be able to debug it
13:04:10 <tom7942> anyone familiar with nanoparsec? http://dev.stephendiehl.com/fun/002_parsers.html
13:04:10 <Welkin> probably an environment issue then
13:04:15 <pikajude> maksim__: i'll try it
13:04:20 <Welkin> because Setup.hs looks like it is accessing the os
13:04:29 <maksim__> pikajude, you won't get far. you need to have an instance of postgres and solr running
13:04:45 <pikajude> i can't tell offhand, but it looks like this Setup.hs does run ghc
13:04:51 <tom7942> why is the the result of parse [(a,String)] ? is there ever more than one element in the list?
13:05:07 <Welkin> set your environment variables when it runs
13:05:12 <Welkin> pass in your env vars to stack
13:05:14 <hpc> tom7942: ambiguous parses
13:05:31 <maksim__> pikajude, where do you see that?
13:05:32 <pikajude> maksim__: i need to have postgres and solr running to configure the project?
13:05:33 <tom7942> hpc for backtracking?
13:05:39 <maksim__> pikajude, that's correct. don't as kme
13:05:47 <pikajude> sounds legit
13:05:48 <Welkin> maksim__: who wrote this thing and what is it?
13:05:55 <maksim__> pikajude, it uses postgres-typed
13:05:59 <maksim__> to create enums in the db
13:06:04 <maksim__> databrary.org
13:06:10 <maksim__> it's a CMS app
13:06:13 <pikajude> ok, i'm stack init'ing it at the moment
13:06:14 <Welkin> oh god...
13:06:18 <hpc> tom7942: the list contains all valid parses
13:06:18 <pikajude> this is going to take awhile
13:06:30 <Welkin> maksim__: why would you inherit this instead of writing your own?
13:06:31 <pikajude> gotta download the hashes on cafe internet
13:06:35 <hpc> which you could get with backtracking, or (<*>) on [], or whatever
13:06:35 <maksim__> pikajude, really you're just going to frustrate yourself
13:06:47 <maksim__> Welkin, like i said i think my second goal is to rewrite it in Go
13:06:47 <pikajude> maksim__: it's ok, that's healthy
13:06:58 <maksim__> pikajude, what makes you think the Setup runs ghc?
13:07:05 <pikajude> i just glanced at it
13:07:10 <pikajude> but on a closer look i don't think it does
13:07:35 <maksim__> that would be some inception level configuration if a compiled setup script ran the compiler
13:07:48 <pikajude> well it already does plenty
13:07:55 <maksim__> yes
13:08:08 <pikajude> but it probably doesn't run ghc
13:08:41 <abysslurker> Does anyone here have some tips with error recovery in Parsec? Something like 'withRecovery' in megaparsec which actually works with try.
13:08:48 <maksim__> the absurd thing is that ghc does respected -package-db
13:08:56 <maksim__> i can compile Setup.hs no problem
13:09:21 <maksim__> bananas
13:09:25 <maksim__> seriously bananas
13:09:32 <Welkin> maksim__: likely a problem with the Setup.hs and environment variables not being set
13:09:33 <pikajude> 🍌
13:09:46 <Welkin> or passed through
13:10:06 <maksim__> passed through what to what
13:10:08 <Welkin> beause whoever wrote it did't know or care as long as it "works on my system"
13:11:13 <maksim__> oh man
13:12:12 <maksim__> i figured it out
13:12:21 <maksim__> you need to pass --package-db to Setup configure
13:12:23 <maksim__> jesus christ
13:12:36 <maksim__> serious magic
13:12:57 <pikajude> perfect timing, i just finished downloading the package index
13:12:59 <Welkin> maksim__: not sure why you would ever write anything in go
13:13:00 <Welkin> lol
13:13:08 <pikajude> only a few minutes left @_@
13:13:12 <Welkin> that would be more painful than debuggin this x100000000
13:13:26 <maksim__> at least there's a sane build system
13:13:37 <Welkin> cabal is fine
13:13:46 <maksim__> yea right
13:13:57 <pikajude> ok, maybe you were right
13:14:02 <pikajude> stack couldn't figure out a resolver to use
13:14:06 <pikajude> alas
13:14:11 <maksim__> it's taken me 2 weeks to get to a place where i can compile
13:14:16 <maksim__> not to say that it works
13:14:18 <maksim__> just compile
13:14:27 <Welkin> maksim__: I think this is a problem with your project, not cabal or stack
13:14:28 <pikajude> which build plan did you use maksim__ 
13:14:30 <maksim__> because of all of the magic things that happen (like Paths_* module)
13:14:47 <maksim__> check out the build_system branch
13:14:50 <pikajude> the Paths module is magic indeed
13:14:52 <maksim__> stack.yaml is o nthere
13:15:12 <pikajude> now I have to install GHC 7.10.3 :'(
13:15:34 <maksim__> lol what the hell is Stopped at Setup.hs:(45,39)-(47,52)
13:15:38 <maksim__> ah
13:15:43 <maksim__> sweet sweet debug context
13:15:57 <maksim__> brb
13:16:01 <maksim__> pikajude, don't work too hard
13:16:05 <maksim__> at least i'm getting paid
13:16:36 <pikajude> well i'm staving off existential horror for another half hour or so
13:16:45 <pikajude> some things you just can't pay for
13:20:01 <johnw> pikajude: as in, the horror of ExistentialQuantification?
13:20:05 <pikajude> i wish
13:20:24 <pikajude> ok, i've gotten to the point where stack is installing the dependencies
13:20:26 <pikajude> I think that's progress
13:21:20 <pikajude> indeed, there's a line at the bottom of the terminal that says "Progress:"
13:21:44 <johnw> ah, I was wondering if anyone had ever tried using Z3 to solve Cabal constraints: https://gist.github.com/NathanHowell/5688647
13:21:54 <pikajude> is that Enigmagic's gist
13:22:13 <johnw> dunno
13:22:40 <johnw> too bad an SMT solution doesn't actually tell you  if it built
13:22:46 <johnw> we need Z3 paired with Jenkins or something
13:22:49 <pikajude> heh
13:22:54 <pikajude> Z3nkins
13:22:54 <johnw> to narrow the search space, and then find the witnesses
13:23:08 <abysslurker> SMT solvers are great until you hit that one case which requires exponential time.
13:23:16 <johnw> and then again, sometimes there are solutions outside the search space too
13:23:26 <johnw> as evidence by how often just "jailbreaking" with Nix fixes my problems
13:23:39 <pikajude> "nearly always"
13:23:59 <pikajude> i do like nix better than this
13:24:03 <pikajude> but stack seems like a pretty nice solution
13:24:08 <Welkin> nix is nice
13:24:13 <Welkin> you can use stck with nix
13:24:16 <Welkin> stack*
13:24:17 <pikajude> can you
13:24:19 <pikajude> I've never tried
13:24:24 <johnw> we could create a server that does nothing but build every possible combination, all day long, and then creates a list of "known good constraints"
13:24:25 <Welkin> you can do anything you want inside nix
13:24:27 <pikajude> well, I tried once but I couldn't figure out how to do it
13:24:33 <pikajude> doesn't stack try to install its own packages and GHC
13:26:05 <maksim__> Welkin, are we talking about nixos?
13:26:55 <Welkin> no, nix package manager
13:27:08 <pikajude> although you could say they're related
13:27:50 <maksim__> is this better than stack?
13:27:59 <pikajude> it depends on what you want
13:28:12 <maksim__> i want an easy build
13:28:17 <maksim__> that's it
13:28:18 <pikajude> although, for example, i just entered a nix-shell containing stack and am using stack to build the projcet
13:28:32 <pikajude> that part is pretty convenient
13:28:51 <pikajude> "hmm, I need $utility. I can `nix-shell -p $utility` and it'll be removed later if I run the garbage collector"
13:29:00 <maksim__> that's like 4 levels of abstraction removed from what i'm really interested in - compiling one executable
13:29:11 <johnw> pikajude: yeah, that happens
13:29:14 <pikajude> certainly shouldn't need nix for this
13:29:20 <pikajude> in the same way that you technically don't need stack either
13:29:24 <johnw> pikajude: I create a nix env containing every package I want to "keep around"
13:29:32 <pikajude> stack makes it easier, i'd say in this case nix is too many cooks
13:29:32 <johnw> so that I can always jump into a nix-shell on the plane
13:29:38 <pikajude> unless you already have nix handy
13:29:39 <sternmull> is there a package that provides a typeclasses and instances for all the lazy/strict variants that are out there for all the datatypes?
13:29:51 <maksim__> pikajude, that's correct but i get cabal hell just doing cabal install
13:30:06 <pikajude> maksim__: yes, i'd say stack is far above the point of diminishing returns
13:30:17 <johnw> pikajude: I can't use cabal sandboxing entirely, though, because when there are packages that depend on system dependencies (like libz), it doesn't find them
13:30:22 <pikajude> oh
13:30:52 <johnw> so I prefer having nix "drive" as much as possible
13:31:22 <maksim__> bbl
13:31:59 <pikajude> being able to define overrides for a specific package in config.nix is also nice
13:32:06 <pikajude> like when I disable tests for lens
13:32:15 <johnw> yeah, or disabling haddock, or jailbreaking
13:32:19 <johnw> or picking custom versions
13:32:23 <johnw> etc.
13:34:15 <pikajude> ok, well, i can't configure this project
13:34:24 <pikajude> i'll try installing ffmpeg
13:35:56 <pikajude> yikes, so many dependencies
13:37:45 <Welkin> maksim__: this is for your job?
13:37:47 <pikajude> oh wow, it runs npm update during configure
13:37:52 <Welkin> pikajude: LOL
13:38:07 <maksim__> Welkin, i'm backend dev for this project yes
13:38:07 <pikajude> maksim__, i understand your frustration and i urge you not to judge haskell's build system poorly based on this project
13:38:12 <pikajude> this is a travesty
13:38:28 <Welkin> sounds like a crappy, thrown-together-at-lowest-cost chop job
13:38:38 <maksim__> well
13:38:40 <pikajude> maksim__: i missed the part about why you need to use a custom package db
13:38:40 <maksim__> it's not
13:38:55 <Welkin> maksim__: I meant the project you inherited
13:39:02 <Welkin> not your job
13:39:05 <maksim__> it's not thrown together
13:39:13 <maksim__> the guy who wrote it is just
13:39:18 <maksim__> different
13:39:21 <maksim__> https://github.com/dylex
13:39:26 <maksim__> he's certainly competent 
13:40:46 <pikajude> maksim__: i got to the point where it tries to run schemabrary
13:40:49 <pikajude> when does it fail for you
13:40:58 <maksim__> run schemabrary?
13:41:00 <maksim__> you mean build?
13:41:11 <pikajude> wait
13:41:16 <pikajude> well it's certainly one of the two
13:41:22 <pikajude> 'schemabrary: connect: does not exist (No such file or directory)'
13:41:31 <pikajude> i think it's trying to run it
13:41:43 <pikajude> ordinarily it's $exename: $error in error messages IIRC
13:42:03 <maksim__> that's the part where you need postgres
13:42:52 <pikajude> oh
13:43:01 <pikajude> so you do need postgres running to configure this project
13:44:34 <maksim__> correct
13:44:52 <maksim__> it creates the db and tables
13:44:53 <maksim__> and etc
13:45:02 <pikajude> not sure why that didn't click the first time
13:47:54 <maksim__> i'll give you guys this
13:47:58 <maksim__> ghci is very powerful
13:54:08 <pikajude> maksim__: ok, i've got it building with stack
13:54:14 <pikajude> the project proper, not the Setup.hs
13:54:22 <pikajude> assuming the main difference is that i'm not using a custom package-db
13:54:57 <pikajude> although macOS Sierra has the naughty linker that can't understand GHC's load commands, so now I'm stuck
13:54:59 <pikajude> still curious though
13:56:37 <Gedos> Hi guys, trying to learn Haskell atm, but I got a problem with type signatures, anyone feel like helping out a newbie?
13:56:58 <pikajude> i gotta head home actually so i'll be back online in a bit
13:57:22 <Cale> Gedos: You should generally just ask your question on IRC
13:59:06 <lpaste_> Gedos pasted “error message type sig” at http://lpaste.net/352730
13:59:49 <Gedos> With the following function
13:59:50 <Gedos> maxOppGeofigFromList :: [Geofig] -> [Geofig] maxOppGeofigFromList geofigs = filter (oppervlakte == maximum (map oppervlakte geofigs)) geofigs
14:00:22 <Koterpillar> :t filter -- Gedos
14:00:24 <Gedos> oppervlakte is a function with the signature Geofig -> Float
14:00:30 <lambdabot> (a -> Bool) -> [a] -> [a]
14:00:38 <siddhu> filter (\x -> oppervlakte x == maximum (map oppervlakte geofigs)) geofigs
14:00:41 <siddhu> does that work?
14:01:49 <Gedos> yes it worked @siddhu :D
14:02:04 <Gedos> I don't understand why this works though siddhu
14:04:09 <siddhu> when you do `filter null xs` its just secretly `filter (\x -> null x) xs`
14:04:36 <Gedos> Should i try to always use lambda expressions when using filter?
14:05:09 <siddhu> when starting out, might be good to start with a lambda expression, then see if you can remove it
14:05:48 <Gedos> alright got it, thanks a lot siddhu!
14:06:31 <bitf> hey everyone. i am an 'intermediate' beginner. confused. question:
14:08:37 <bitf> in a function like group, from Data.List...how come 'group []' returns [] instead of [[]]. isn't this type invalid? since the type for group is group :: Eq a => [a] -> [[a]]
14:09:37 <Koterpillar> :t [] -- bitf
14:09:40 <lambdabot> [t]
14:09:46 <Koterpillar> that's an empty list of anything
14:09:51 <siddhu> bitf: [] is an empty list of lists
14:09:51 <Koterpillar> including an empty list of lists
14:09:53 <kadoban> bitf: [] is an empty list of any type. Including the type of lists where the elements are other lists.
14:10:27 <Koterpillar> I think the promise of group is that all the elements of the returned list are non-empty, by the way
14:10:56 <kadoban> It in fact couldn't return [[]], because of the type of 'group'.
14:11:00 <kadoban> :t group
14:11:02 <lambdabot> Eq a => [a] -> [[a]]
14:11:30 <kadoban> All it knows is that the list elements are any type. It can't know that it can create an element with [] in this case, because the function is generic.
14:11:38 <bitf> ":t [[]]" = [[]] :: [[t]]
14:11:49 <Koterpillar> kadoban: it can
14:11:53 <bitf> [] :: [t]
14:12:03 <Koterpillar> kadoban: :t [[]]
14:12:11 <Koterpillar> :t [[]] -- kadoban
14:12:13 <lambdabot> [[t]]
14:13:13 <SrPx> Is there any market to work with Haskell and ASICs nowadays? I'm really appreciating any link, reference you can give. This is for a friend which is quite depressed with his career choices ):
14:14:00 <kadoban> Hmm, ya you're right, that wasn't a well thought out thing.
14:15:12 <siddhu> SrPx: http://www.clash-lang.org/ ?
14:17:21 <SrPx> siddhu: thanks!!
14:18:23 <bitf> i've looked at the source code for group - and if i change the line groupBy _  [] =  [] to groupBy _  []  =  [[]] it doesn't make any difference
14:18:40 <SrPx> Completely unrelated note, I spent the last week writing a small project 100% in JavaScript, but pretty much following a Haskell style in a very extreme sense. I wanted it in JavaScript because I really, really wanted it to run on the browser and be fast/small
14:18:40 <bitf> but if it's changed to [[[]]] then there's a problem
14:19:42 <Koterpillar> SrPx: did you read http://mutanatum.com/posts/2017-01-12-Browser-FP-Head-to-Head.html by any chance?
14:19:52 <SrPx> A snippet, for your amazement: http://i.imgur.com/bHq1Pws.png
14:20:02 <Koterpillar> bitf: that's expected
14:20:08 <SrPx> So, after 1 week at this really weird experiment, twisting myself to tolerate functional javascript
14:20:15 <SrPx> I figure out that I need something that isn't available on the browser
14:20:25 <SrPx> so... it is all in node.js for no good reason
14:20:26 <SrPx> #fml
14:20:38 <Koterpillar> SrPx: this looks very much like code that PureScript/Elm would compile to
14:21:24 <SrPx> Yep but I specifically avoid PureScript which is really really awesome but I absolutely hate having an additional build step. I don't know, something about it just destroys my productivity. I'm not sure what, why
14:21:32 <SrPx> I've made some cool things in PureScript though
14:21:59 <SrPx> And Elm specifically, I avoid it because the type system had some weird bugs last time I used and was too unexpressive in general
14:22:04 <Koterpillar> and yet you're in a room for a compiled language
14:22:30 <SrPx> What room? I'll read your article now, brb
14:22:39 <Tuplanolla> I recently did the same thing with Octave, SrPx.
14:22:40 <SrPx> (oh)
14:22:44 <dolio> The room you're speaking in.
14:23:02 <Koterpillar> SrPx: the article isn't mine
14:23:25 <SrPx> "This is about purely functional programming, which means I’m not even going to consider a system valid without referential transparency and IO managed in some way. So yes, all flavors of Lisp are off the table as well."
14:23:30 <SrPx> so extremist 
14:23:35 <SrPx> looking good
14:23:55 <SrPx> Koterpillar: the article you linked* 
14:24:43 <Gedos> when using the map function, how do I refer to the element within the list to use as an argument for the function map will use?
14:25:16 <Koterpillar> > map (\x -> x + 1) [1,2,3] -- Gedos
14:25:19 <lambdabot>  [2,3,4]
14:25:51 <Gedos> Thanks
14:26:13 <Koterpillar> > let thatThing x = x + 1 in map thatThing [1,2,3]
14:26:16 <lambdabot>  [2,3,4]
14:58:58 <clmg> Anyone know how to write a string on top of a border in brick?
14:59:15 <Koterpillar> what is brick?
14:59:21 <Tuplanolla> @hackage brick
14:59:21 <lambdabot> http://hackage.haskell.org/package/brick
14:59:37 <geekosaur> successor to vty-ui
14:59:48 <Koterpillar> oh, ignore me
14:59:50 <Tuplanolla> Does `hBorderWithLabel` qualify, clmg?
15:00:19 <clmg> Tuplanolla: yup, wow, thanks
15:01:56 <clmg> Tuplanolla: can I position it?
15:02:07 <Tuplanolla> Probably not, clmg. Read the source.
15:02:36 <clmg> Tuplanolla: damn. should I just use translateBy with a string?
15:03:00 <Tuplanolla> Would that really work?
15:03:12 <clmg> idk
15:11:19 <Enigmagic> pikajude: yeah that's mine
15:15:45 <maksim__> what does a trivial Setup.hs look like?
15:16:09 <maksim__> nm
15:16:32 <hpc> import Distribution.Simple
15:16:34 <hpc> main = defaultMain
15:43:09 <maksim__> pikajude, i torched that entire Setup.hs :)
15:43:21 <pikajude> can't say i dasgree
15:43:23 <pikajude> disagree
15:43:27 <pikajude> can't say i spell
15:49:15 <maksim__> some really unnecessary stuff in there
15:49:32 <maksim__> "when your only tool is haskell everything looks like a monad" should probably be an expression
15:57:43 <pikajude> when your only tool is haskell tutorials*
15:58:59 <MP2E> when your only tool is monads, everything looks like a burrito :p
16:02:40 <MarcelineVQ> Squarism: specifically, regarding your implicits problem earlier, bindind sites of implicit parameters can define bindings only for implicit parameters, you can't mix, re the bullet points here: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#implicit-parameter-bindings
16:07:05 <MarcelineVQ> basically the vague parse error you were getting was due to the next thing in the let not starting with ? as it expected  :>
16:52:24 <nanocoder> Hi, could anyone please help me with installing haskell stack on nixos? I'm trying that for some days without success
16:53:26 <nanocoder> Clarifying, stack install ok, but you can't install ghc or anything else with it...
16:53:35 <MarcelineVQ> did you ask in #nixos? I only ask because they seem to be super helpful in there so it's worth a try if you haven't yet
16:54:50 <hpc> nanocoder: i was having the same issue, it seemed like it was trying to write to stack's nix store
16:54:53 <nanocoder> I didn't think doing that there, it make more sense :) tks, i will try there
16:55:00 <Cale> My friend, re: nanocoder's situation "hoo boy, he might want to sit down for this one"
16:55:26 <hpc> haha
16:55:41 <hpc> yeah, i switched back to fedora yesterday because of this
16:56:07 <Cale> I think if you're using nixos, probably your best bet is just to use nix's haskell stuff rather than stack
16:56:24 <hpc> nix packages stack though, is the odd thing
16:56:33 <nanocoder> I *really* liked nixOS, but apparently both nix and stack are making assumptions about the underlying system without talking to each other :)
16:57:17 <hpc> i think i blame stack in this case, but nix in general
16:57:27 <Cale> I haven't yet been able to stand using nixos itself, but we use nix for all our projects where I work.
16:57:42 <Cale> (I just have the package manager installed for that)
16:57:46 <hpc> if they move more configuration into the package expressions and expose damn near everything in the language, then it could be something great
16:58:07 <hpc> like some sort of pure functional puppet or something
16:58:48 <nanocoder> I have done thing in *seconds* with nixos that for doing elsewhere will take very long time, but when you dong get something is a real pain to discover what get wrong 
16:58:51 <Cale> Yeah, what Ryan wants to do is to add something to cabal/GHC to emit build plans in a machine readable format, from which nix derivations can be constructed.
16:59:13 <Cale> (at least at the module-by-module level)
17:03:23 <Cale> but yeah, the actual nix expression language is kind of awful -- it badly needs a type system so that you can learn anything without having to read the source code of everything.
17:03:50 <hpc> even just enough to know where the effects are coming from would help
17:04:03 <hpc> or how files map from the nix store to what you see in userspace
17:04:26 <Koterpillar> Did you try Propellor instead?
17:05:34 <hpc> or how to know which version of vim_configurable is the right one
17:05:47 <hpc> er, vim-configurable
17:05:58 <Cale> Well, I could be mistaken, but I don't think Propellor is really aimed at being a hashed build system.
17:06:10 <Cale> Maybe it could be extended in that direction.
17:06:28 <hpc> ... did vim-configurable disappear?
17:22:19 <pikajude> i think it's an underline isn't it
17:59:15 <Wizek_> Is there an online haskell code formatter/beautifier?
18:00:14 <Koterpillar> hindent is an installable one
18:02:48 <Wizek_> looking into it
18:10:20 <stevenxl> Hi folks. A lot of definitions of a pure function state that a pure function an’t depend on reading any hidden value outside of the function scope. Of course, if that's the bar for a pure function, even something like myFunc a b = a + b is not a pure function, since it relies on a value (+) that is not defined in that function's scope. 
18:11:01 <stevenxl> I ran into another definition that modifies the "no reading any hidden value..." to say, instead relies on "no external mutable state". 
18:11:20 <monochrom> I'm pretty sure "hidden" is wrong. "mutable state variable" is right.
18:11:28 <stevenxl> Under that definition, myFunc a b = a + b is a pure function.
18:11:36 <stevenxl> monochrom: that's what I'm thinking too.
18:12:15 <monochrom> "external" is also wrong. In C "int f(void) { static int i = 0; return i++ }" reads an internal mutable state variable and is clearly impure.
18:13:05 <barrucadu> A nice simple definition is: a pure function always gives the same result for the same argument values.
18:13:10 <monochrom> Actually I think it's all wrong to look at what it does and doesn't read.
18:13:17 <stevenxl> Right.
18:13:22 <monochrom> What barrucadu just said.
18:13:29 <stevenxl> I agree with both of you (monochrom, barrucadu).
18:13:31 <hpc> stevenxl: there's a similar but orthogonal concept of free and bound variables which is what you are thinking of
18:13:39 <hpc> a and b are bound in \a b -> a + b
18:13:47 <hpc> specifically they are bound by the lambda
18:13:52 <hpc> but (+) is free
18:13:56 <stevenxl> The thing is that this definition seems to be pretty pervasive. I found it here: http://scalafp.com/book/definition-of-pure-functions.html
18:14:06 <stevenxl> And on wikipedia 
18:14:06 <stevenxl> https://en.wikipedia.org/wiki/Pure_function
18:14:22 <hpc> and a combinator is (iirc) a definition that does not contain any free variables
18:14:34 <monochrom> Pretty sure this is an instance of "misconception is pervasive".
18:14:43 <stevenxl> ok cool.
18:14:51 <stevenxl> This was not letting me rest. 
18:15:34 <stevenxl> Because I started thinking about closures, and by that definition, they'd be impure too, even if the closure always returned the same value given the same arguments.
18:16:07 <barrucadu> stevenxl: I think your problem might be a slightly different reading of "hidden value" to what the authors meant. That definition on scalafp.com also says "A pure function depends only on [...] its algorithm to produce its result."
18:16:21 <barrucadu> I would consider the functions that make up another function to be the definition of its algorithm
18:16:49 <barrucadu> And the examples of hidden values that could be read are all state: "Its result can’t depend on reading any hidden value outside of the function scope, such as another field in the same class or global variables."
18:17:26 <stevenxl> barrucadu: I see your point yes.
18:18:15 <stevenxl> but I like your definition much better - pure function always returns the same value given the same arguments (plus no side effects)
18:18:17 <stevenxl> :-)
18:26:02 <clmg> How do I get a pure value from an fclabel?
18:26:54 <clmg> nvm
18:27:59 <hyperthunk_> is this the right place to ask a question about GHC 8.* handling type classes a bit… differently to previous versions!?
18:40:06 <roconnor> I wouldn't say that (+) is free in \a b -> a + b 
18:40:13 <roconnor> (+) is a defined constant.
18:41:16 <pyon> QuickCheck question: Is there some way to automatically derive Arbitrary instances?
18:42:26 <Koterpillar> pyon: there are options with TH
18:42:43 <Koterpillar> pyon: https://hackage.haskell.org/package/derive-2.5.26/docs/Data-Derive-Arbitrary.html
18:42:52 <pyon> Koterpillar: Ah, thanks! :-)
18:43:38 <Koterpillar> pyon: also https://hackage.haskell.org/package/generic-random-0.4.0.0/docs/Generic-Random-Generic.html
18:44:28 <pyon> Checking.
18:44:34 <Koterpillar> pyon: https://github.com/nick8325/quickcheck/pull/112
18:48:25 <ReinH> roconnor: fwiw, the report uses that wording
18:48:55 <pyon> roconnor: (+) is a defined constant... in a(n admittedly very common) context. Without that context, it seems to me that it's fair to say it appears free in the expression you gave.
18:50:33 <ReinH> roconnor: e.g., in Chapter 3 they write, "Free variables and constructors used in these translations always refer to entities defined by the Prelude."
18:50:33 <ReinH> (https://www.haskell.org/onlinereport/haskell2010/haskellch3.html)
18:53:57 <roconnor> pyon: yes.
18:56:08 <pyon> Could anyone please tell me why I get a stack overflow when running this code? https://gist.github.com/eduardoleon/89937fc083e69f50e70e76b1fd8718b3 (Ignore the SML version, it's just the same program, minus the QuickCheck test.)
18:58:55 <pyon> Alternatively, how can I get QuickCheck to produce a sample of values from a type, and just return that sample, without testing anything on it?
18:59:44 <hpc> for the second question, look at the operations on Gen
18:59:44 <Koterpillar> pyon: http://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Gen.html#v:generate ?
19:00:00 <pyon> Ah, thanks!
19:02:31 <pyon> Ah, the problem is with my generator, not with the code being tested.
19:02:53 <pyon> Perhaps I shouldn't use generics as a replacement for thinking. :-|
19:07:27 <xcmw> Is it bad to use & and <&> instead of $ and <$>? I never see any programs wirtten with & and <&> but that style is easier to read for me.
19:08:18 <kadoban> xcmw: It's ... unusual.
19:08:39 <kadoban> You should get used to reading the other way for sure. Which one you actually use probably depends, I'd probably default to what everyone else does though.
19:09:03 <peddie> xcmw: if you consider that an important aspect of programs is having people read them, it might make sense to go with the flow
19:09:27 <kadoban> I use a flipped version of (.) and (&) in some coding contexts, but I'd never do it for like a library I'm publishing.
19:10:31 <kadoban> Or code I'm asking questions on or anything I hoped someone would read.
19:11:22 <xcmw> I find   [1,2,3] <&> (+3) & filter (>4)   easier to read than   filter (>4) . map (+3) $ [1,2,3]
19:11:44 <kadoban> Keep using the common way until you can read either.
19:13:18 <kadoban> I don't really see how it could be that much harder to read though, you just start at the right instead of the left. Otherwise really no different. Only reason I use flipped (.) sometimes is ease of typing quickly, don't have to type backwards when I'm thinking forwards from the input.
19:16:32 <xcmw> kadoban: I have to mentally reorder it to read it
19:19:47 <xcmw> Is there a program that can automatically switch between styles?
19:20:00 <kadoban> If you keep practicing at it, it'll become natural.
19:20:11 <Koterpillar> xcmw: you can hack something out of hlint, I suppose
19:20:26 <kadoban> Can hlint automatically change code?
19:20:47 <kadoban> Oh it can, huh. How did I never know that.
19:20:58 <monochrom> Yikes
19:21:11 <kadoban> That sounds a bit scary though.
19:21:30 * enthropy remembers it being a feature that hlint didn't
19:21:49 <kadoban> Looks like --refactor, unless I'm misunderstanding what that does.
19:23:32 <enthropy> I have a groupish function http://lpaste.net/352742 . Is there some way to write it in terms of sort/sortBy?
19:23:56 <xcmw> kadoban: "when I'm thinking forwards from the input" When do you think backwards from the input?
19:24:09 <kadoban> xcmw: The alternative would be backwards from the output.
19:24:27 <xcmw> kadoban: That is what I meant
19:24:47 <kadoban> Pretty rarely, but it happens. Can't say I can think of an example.
19:24:55 <monochrom> English is backwards from the input. The square root of the sine of x.
19:26:10 <Koterpillar> enthropy: I have a feeling you need to zip the 2nd and 3rd arguments first, then apply groups
19:27:49 <xcmw> monochrom: English is both
19:30:13 <enthropy> Koterpillar, by groups you mean Data.List.group?
19:31:01 <Koterpillar> yes
19:31:19 <Koterpillar> can you show some examples with groupish id?
19:31:40 <Koterpillar> i.e. is groupish id x y === x?
19:32:30 <enthropy> no, == y
19:33:26 <Koterpillar> that does not typecheck
19:33:41 <Koterpillar> because groupish id :: [a] -> [b] -> [a]
19:34:10 <enthropy> works in my ghci
19:34:23 <kadoban> Oh, I see what that function does. That was very confusing initially.
19:35:14 <Koterpillar> oh, sorry
19:35:21 <Koterpillar> groupish id :: [a] -> [a] -> [a]
19:37:48 <Koterpillar> I very much suspect that groupish f x y = map (map fst) $ group (\(x, y) -> f x == y) x y
19:38:10 <Koterpillar> but I haven't read the definition, only the type and examples
19:38:15 <enthropy> I might describe it as "groupish getB as bs" reorders `as` such that "map getB as == bs", and keep the ordering from `as`"
19:38:28 <Koterpillar> ooh
19:38:44 <Koterpillar> enthropy: groupish id [1, 1, 1] [2, 2, 2]
19:41:58 <enthropy> that's an error right now, but I think some idea of parametricity suggests it might be allowed to be [1,1,1]
19:43:01 <enthropy> I mean it would be a type error to put any 2 from the `bs` argument in the output
19:43:32 <Koterpillar> then it's a stable sort
19:43:51 <Koterpillar> by (index in bs . getB)
19:44:01 <Koterpillar> :t indexOf
19:44:03 <lambdabot> error:
19:44:04 <lambdabot>     • Variable not in scope: indexOf
19:44:04 <lambdabot>     • Perhaps you meant one of these:
19:44:05 <Koterpillar> :t index
19:44:07 <lambdabot> Ix a => (a, a) -> a -> Int
19:44:15 <enthropy> :t elemIndex
19:44:18 <lambdabot> Eq a => a -> [a] -> Maybe Int
19:46:04 <Koterpillar> > let groupish f x y = sortBy (flip elemIndex y . f) x y in groupish (\x -> x `mod` 10) [1..100] [1..10]
19:46:08 <lambdabot>  error:
19:46:08 <lambdabot>      • Couldn't match expected type ‘[a1] -> t1’ with actual type ‘[a]’
19:46:08 <lambdabot>      • The function ‘sortBy’ is applied to three arguments,
19:46:23 <Koterpillar> > let groupish f x y = sortBy (flip elemIndex y . f) x in groupish (\x -> x `mod` 10) [1..100] [1..10]
19:46:26 <lambdabot>  error:
19:46:26 <lambdabot>      • Couldn't match type ‘Maybe Int’ with ‘a1 -> Ordering’
19:46:26 <lambdabot>        Expected type: a1 -> a1 -> Ordering
19:46:57 <kadoban> Koterpillar: How could elemIndex be correct though? Doesn't that just give you the first element that matches?
19:47:21 <Koterpillar> > let groupish f x y = sortBy (compare `on` (flip elemIndex y . f)) x in groupish (\x -> x `mod` 10) [1..100] [1..10]
19:47:22 <enthropy> probably sortOn would typecheck
19:47:24 <lambdabot>  [10,20,30,40,50,60,70,80,90,100,1,11,21,31,41,51,61,71,81,91,2,12,22,32,42,5...
19:47:40 <Koterpillar> kadoban: you're right
19:48:57 <romanandreg> Hey, do you know if there is a way to have a .ghci file per project?
19:49:00 <kadoban> enthropy: IMO your basic idea seems right. It's possible you can do this via group or sort or something, but ... I'm not seeing it.
19:49:12 <Axman6> romanandreg: yes, just put it in the root of the project
19:49:16 <romanandreg> I'm just trying a .ghci file that defines some :cmd in the top of a project dir with no luck
19:49:34 <Axman6> is it in the directory you're executing ghci from?
19:49:43 <romanandreg> s/:cmd/:def/
19:49:55 <romanandreg> I'm using Stack
19:50:01 <romanandreg> from intero's mode
19:50:08 <romanandreg> so, not sure if that would skew it up
19:51:00 <romanandreg> yeah, it is likely, GHCi is not running at the top of the project when running inside emacs
19:51:18 <Koterpillar> is it even GHCi running?
19:52:50 <romanandreg> I think so
19:53:17 <romanandreg> this gives me the impression intero ignores .ghci file on purpose => https://github.com/commercialhaskell/intero/blob/adb30bfcd4b280005dc6bf505cb9ff0326f7fbc5/src/test/Main.hs#L503
19:53:27 <romanandreg> :(
19:54:10 <Koterpillar> this is a test file
19:54:22 <Koterpillar> https://github.com/commercialhaskell/intero/commit/80707d2db2ee8e73c5aaaa62ecde9c6959f4c320
19:56:14 <Koterpillar> but see https://github.com/commercialhaskell/intero/issues/355
19:57:13 <geekosaur> romanandreg, arguments can be made in both directions, personally I suspect it'd be better to have a project specific file and let .ghci be solely for interactive use
19:57:47 <geekosaur> (or possibly a stanza in cabal file / stack.yaml as appropriate)
19:58:55 <enthropy> thanks Koterpillar and kadoban
20:08:57 <romanandreg> geekosaur: what you mean with a stanza?
20:09:45 <geekosaur> I mean whatever the appropriate syntax is for each one
20:10:26 <geekosaur> like a ghci-options: (or intero-ghci-options: or whatever) in the cabal file, or the equivalent YAML
20:21:34 <romanandreg> Oh, the reason why it was not working is because of the file mod of the project directory
20:21:47 <romanandreg> if it can be read by others, GHCi won't load the .ghci file
20:41:40 <lpaste_> threshold pasted “Requesting help with Servant” at http://lpaste.net/352744
20:42:48 <Koterpillar> threshold: liftIO?
20:45:02 <Axman6> pretty sure you do not want to be running getArgs for every request...
20:45:53 <Koterpillar> pretty sure it's some experimental code anyway...
20:46:24 <Axman6> liftIO is the answer though
20:46:29 <halogenandtoast> Hmm for some reason I thought the whole OverloadedRecordFields thing was solved in ghc 8, but that doesn't seem to be the case. It's mostly become DuplicateRecordFields and it's still ambiguous when accessing internal data
20:47:11 <lpaste_> halogenandtoast pasted “DuplicateRecordFields.hs” at http://lpaste.net/352745
20:47:24 <threshold> Koterpillar: Hi, thanks for responding. If the last line of postUser is "liftIO (return (u ++ " on server " ++ (head args)))", the error then changes, but is similar: Expected type: Server Routes Actual type: [Char] -> IO b0
20:47:27 <halogenandtoast> So that paste for instance errors with name being ambiguous
20:47:46 <Koterpillar> threshold: liftIO getArgs
20:48:28 <threshold> Koterpillar: This? args <- liftIO getArgs
20:48:55 <geekosaur> halogenandtoast, it's only started, not completed
20:49:06 <geekosaur> another chunk, but still not the whole thing iirc, is slated for 8.2.1
20:49:39 <Koterpillar> threshold: correct
20:50:15 <halogenandtoast> geekosaur: yeah I'm just surprised. I guess it's far more difficult than I could imagine.
20:50:40 <halogenandtoast> Or perhaps it's not difficult, but it's difficult to make safe, fast, and easy.
20:51:06 <geekosaur> my impression is that it looks easy but has edge cases all over the place
20:51:07 <threshold> Koterpillar: That did cause it do something different: Expected type: Server Routes Actual type: [Char] -> Control.Monad.Trans.Except.ExceptT ServantErr IO [Char]
20:51:18 <geekosaur> but that's just my impression, I do not know details
20:51:25 <halogenandtoast> geekosaur: thanks
20:51:27 <Koterpillar> threshold: repaste?
20:53:07 <lpaste_> threshold pasted “Repaste” at http://lpaste.net/352746
20:54:07 <Koterpillar> ok, well, now the problem is you're adding User and String
20:54:23 <Axman6> probably need show u
20:54:34 <threshold> Koterpillar: Thanks. I'll try T.pack
20:54:35 <Koterpillar> no, the return type is still User
20:54:51 <Koterpillar> so you need to somehow add User and String and get back a User
20:55:19 <Koterpillar> what are you actually trying to do? This sounds like an abomination in using Servant
20:55:20 <Axman6> oh right, yes you need to return a User
20:56:07 <threshold> Koterpillar: How did you know that I need to return a User? That would help me quite a bit. My primary confusion is in what exactly is the expected return type.
20:56:20 <Koterpillar> Post '[JSON] User
20:56:24 <Axman6> because of the type Routes
20:56:40 <Koterpillar> this part says you return a User, encoded in JSON
20:56:52 <Axman6> `Server Routes` translates into User -> Handler User
20:56:56 <Koterpillar> this is your input: ReqBody '[JSON] User
20:59:54 <threshold> Koterpillar and Axman6, that helps. It's strange that the return type is a Post
21:00:16 <Axman6> threshold: if you run :kind! Server oputes in GHCi, you'll see what type you need
21:00:19 <Koterpillar> I agree, that bit is actually part of the input
21:00:55 <angerman> how do I selectively enable an Executable in the cabal file based on a flag?
21:01:11 <angerman> e.g. do not build this executable unless -xyz is specificed.
21:05:03 <MarcelineVQ> good question, if's aren't allowed between stanza's appearantly, hmm...
21:05:29 <threshold> :kind! Server results in Server :: k -> * = Server while :kind! Routes.Routes results in Routes.Routes :: * = Routes
21:06:25 <Koterpillar> did you mean :kind (or :type?) Server Routes?
21:06:28 <MarcelineVQ> angerman: and moving to Custom build feels like a step too far
21:07:30 <threshold> Koterpillar: Thanks again. That results in Server Routes :: *
21:08:13 <Koterpillar> no luck
21:08:25 <threshold> I need to understand how to transform * -> * to * probably.
21:08:40 <Koterpillar> well, Server has an associated data type
21:08:42 <Koterpillar> *is
21:08:57 <Koterpillar> every Route has one, and when they are combined, the type changes
21:11:53 <threshold> Koterpillar: This is confusing. Maybe I should start out with something simpler such as a simple WAI app
21:12:00 <threshold> I do like the idea of not having to serialize JSON
21:12:41 <threshold> Koterpillar: Do you have experience with this. Is it that difficult to handle JSON?
21:13:10 <lpaste_> MarcelineVQ pasted “angerman” at http://lpaste.net/9168932458794582016
21:13:44 <Koterpillar> threshold: you'll get combinators to serve it in every framework
21:14:22 <MarcelineVQ> angerman: relevant http://cabal.readthedocs.io/en/latest/developing-packages.html#conditional-blocks
21:14:57 <angerman> MarcelineVQ: thanks. And now I'm handicaped by ghc-cabal. AHH!!
21:15:46 <Koterpillar> threshold: but I do think you need to try some other framework before servant, just to get a feel
21:24:28 <MarcelineVQ> angerman: is it much different?
21:24:51 <angerman> MarcelineVQ: supports only a single stanza it seems :-/
21:25:19 <angerman> MarcelineVQ: so maybe it would work, maybe not... but I don't want to go down that rabbit hole now.
21:31:18 <piyush-kurur> is there a reason why unboxed vector from the vector library does not have a foldable instance ?
21:31:40 <piyush-kurur> or is it that the author missed it?
21:34:45 <erlandsona> What's a function with the signature [(a,b)] -> [(a,c)] ? It's definitely a map over a list of pairs... is there a nice way to do this?
21:35:08 <Koterpillar> :t second -- erlandsona
21:35:11 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
21:35:28 <Koterpillar> map (second negate) [(1, 2), (3, 4)]
21:35:36 <Koterpillar> > map (second negate) [(1, 2), (3, 4)]
21:35:42 <lambdabot>  [(1,-2),(3,-4)]
21:35:53 <threshold> Koterpillar: What is the most straightforward framework?
21:36:01 <erlandsona> second! Yes! I love irc! and you too Koterpillar thanks so much!
21:36:32 <Koterpillar> threshold: scotty?
21:40:31 <threshold> Koterpillar: I'll try it out. Thanks again
21:52:21 <jvliwanag> guys, is there a generic way of flattening out a tuple with arbitrary lengths? meaning: (((a, b), c), d) -> (a, b, c, d) and the other way around 
21:59:42 <jchia> jvliwanag: The only way I can think of is TH.
22:00:43 <jchia> jvliwanag: Or maybe type classes can help let me se
22:02:23 <jchia> jvliwanag: (((a, a), a), a) -> [a] maybe be doable without TH but I don't know about your original question.
22:15:17 <pacak> jvliwanag: You can try ghc generics
22:16:08 <maybefbi> how hard is the standard chartered interview?
22:20:56 <jvliwanag> yeah jchia, I'd need the original types. pacak - any useful resources for ghc generics? been looking at the hlist stuff as well
22:23:02 <osa1> I wish we had a search bar in Haddock pages for searching for a definition in a library
22:23:43 <osa1> currently the closest thing is to go to the index page, list "all", and C-f
22:23:58 <pacak> jvliwanag: I don't think there are any good tutorials that are up to date, but the idea is to represent datatypes as sums and products of size 2 and all you need is to write a function that operates on those sums and products
22:25:04 <pacak> It also provides typeclasses that allow you to extract things like constructor names or field accessors 
22:25:29 <pacak> On small datatypes ghc can generate nice code
22:25:59 <pacak> But compilation cost is quadratic or more
22:26:54 <erlandsona> quit
22:29:34 <jvliwanag> pacak: nice. i've been using shapeless as well on scala which drew inspiration form syb i believe. I hope ghc generics will be similar
22:30:00 <jvliwanag> i've seen generics-sop as well though. i wonder how that compares
23:42:29 <clmg> How do I use `lookupExtent` in Brick? It's basic monadic stuff but the example gives me errors: https://github.com/jtdaugherty/brick/blob/7d2fc92405a74816d4c3f8b9e2d4a00f42704bf0/docs/guide.rst#extents
23:43:56 <clmg> using a <- will make my entire do block "into" that monad. How do I work with this?
23:44:45 <c_wraith> oh, hey.  I used to work with brick's author
23:45:01 <clmg> c_wraith: hi
23:45:22 <clmg> brick is pretty cool. if only I could figure out how to use it!
23:46:15 <kosmikus> jvliwanag: do you have questions about generics-sop?
23:48:01 <c_wraith> clmg: it looks like you should be using lookupExtent in appStartEvent and/or appHandleEvent
23:48:19 <c_wraith> clmg: since those are required to be in EventM anyway
23:48:34 <clmg> c_wraith: ah I see. thanks.
23:49:04 <c_wraith> clmg: if you need the extent data elsewhere, I guess you need to throw it into your state value.
23:49:27 <clmg> c_wraith: I think that's whats going to have to happen :-(
23:53:19 <lpaste_> threshold pasted “example” at http://lpaste.net/352752
23:53:57 <threshold> Ignore ^
23:59:33 <Cooler> i have been following this https://youtu.be/RDalzi7mhdY?t=2699 video on parser combinators
