00:16:38 <dmj`> #haskell-conspiracy
00:46:48 <halogenandtoast> Does anyone have experience (or suggestions) for using regex-compat with japanese text?
00:47:08 <halogenandtoast> `*** Exception: user error (Text.Regex.Posix.String died: (ReturnCode 17,"illegal byte sequence"))` is what I'm currently dealing with.
00:47:54 <halogenandtoast> the call being `matchRegexAll (mkRegex "doesn't matter") "宮城県　津波で壊れた小学校の新しい建物ができる"`
00:51:09 <Axman6> are you ure things are in the right encodings?
00:57:32 <Xnuk> halogenandtoast: I cannot reproduce the error; it just returns `Nothing` at regex-compat-0.95.1 & regex-posix-0.95.2
01:00:05 <halogenandtoast> Xnuk: hmm not sure how to check my versions one sec.
01:01:05 <halogenandtoast> regex-compat 0.95.1 and regex-posix 0.95.2 is the same that I have
01:01:15 <halogenandtoast> Axman6: I'm never quite sure
01:02:47 <halogenandtoast> Is the encoding automatically applied / chosen for me when I create a string
01:02:53 <halogenandtoast> in my repl I'm just doing `let x = matchRegexAll (mkRegex "doesn't matter") "宮"`
01:03:14 <halogenandtoast> and when I try to check the value of x it fails with illegal byte sequence
01:03:42 <Xnuk> `String` is just list of unicode chars
01:04:03 <halogenandtoast> Sure and unicode should cover the characters I need (I think)
01:04:57 <halogenandtoast> Hmm when I type alternate Kanji, it works fine
01:05:09 <halogenandtoast> there might be an unprintable character I've copied and pasted
01:06:25 <Xnuk> Is your terminal's encoding set properly?
01:07:18 <halogenandtoast> not sure, a kanji I'm having trouble with seems to have the encoding "\23470"
01:07:33 <halogenandtoast> so `let x = matchRegexAll (mkRegex "doesn't matter") "\23470"`
01:07:35 <halogenandtoast> fails for me
01:07:45 <ongy> > text "\23470"
01:07:48 <lambdabot>  宮
01:08:23 <Xnuk> hm that's awkward
01:08:32 <halogenandtoast> What is?
01:09:51 <Xnuk> I still get no errors
01:10:19 <halogenandtoast> *sigh*
01:10:31 <geekosaur> what's your current locale?
01:11:06 <Xnuk> en_US.UTF-8
01:11:14 <halogenandtoast> geekosaur: is there an easy way to check? LC_ALL is currently empty
01:11:22 <geekosaur> (also you may have to load full locale information instead of restricted ones, fi you;re using e.g. docket)
01:11:28 <Xnuk> $ locale
01:11:30 <geekosaur> halogenandtoast, the locale command
01:11:48 <geekosaur> but, $LC_ALL is dominated by $LANG
01:11:57 <halogenandtoast> LANG and LC_ALL are empty
01:12:02 <geekosaur> $LANG, $LC_ALL, $LC_category
01:12:16 <geekosaur> then your locale is probably C and those won't work
01:12:26 <halogenandtoast> LC_CTYPE="UTF-8" and the rest are "C"
01:12:56 <geekosaur> hm, typoed earlier. "docker"
01:13:31 <halogenandtoast> This is just on my locale machine currently, setting my locale <should> fix this?
01:13:33 <geekosaur> so, exit ghci and rerun it as: LANG=en_US.UTF-8 ghci
01:13:46 <geekosaur> (or some other UTF8 locale if appropriate)
01:15:39 <geekosaur> hm, I don't think I have ja_JP locale foo installed on here :/
01:15:52 <halogenandtoast> I still get the same error.
01:16:35 <halogenandtoast> Is there a way to see which locale haskell thinks is the current one?
01:16:38 <cocreature> maybe you need to generate the locale for this to work?
01:16:45 <cocreature> try "locale -a" to see the ones you have installed
01:16:46 <geekosaur> yeh, might need to install locale files
01:17:21 <geekosaur> as I just noted I don;t seem to have any Japanese locales on here (was hoping to verify what locale would be suitable for a .jp address :)
01:17:40 <geekosaur> I should probably correct that
01:17:52 <halogenandtoast> geekosaur: what like `ja_JP.UTF-8`
01:18:13 <geekosaur> if that exists, yes
01:18:32 <halogenandtoast> yeah that doesn't seem to work, I seem to have a lot of locales available
01:18:37 <halogenandtoast> via `locale -a`
01:18:54 <Xnuk> https://wiki.archlinuxjp.org/index.php/%E3%83%AD%E3%82%B1%E3%83%BC%E3%83%AB
01:18:57 <halogenandtoast> including the `en_US.UTF-8` I'm currently trying
01:19:08 <magthe> Can I use PatternGuards in a case statement, or is it only for function defs?
01:19:10 <geekosaur> you need to user a utf8 locale from that list
01:19:48 <geekosaur> magthe, function defs turn into case statements, I would expect it to work
01:20:11 <halogenandtoast> my list shows en_US.UTF-8 I've set LC_ALL to that (and trying setting it when running ghc)
01:20:39 <geekosaur> and the manual just says "guards" which implies both case and function definitions
01:21:18 <quchen> magthe: Function definitions desugar to case blocks
01:21:50 <arne_> hi it's me, asking the obvious troll questions: why isn't it better to use a non-functional language language, and try to use it's lambda stuff as much as we can?
01:22:34 <quchen> »has map and filter« does not mean »supports functional style«, it means »hey, me too«.
01:22:43 <magthe> then I'm missing something in syntax since I get parse errors
01:23:03 <halogenandtoast> arne_: troll answer: better is subjective.
01:23:10 <arne_> halogenandtoast: eh, eh
01:23:40 <geekosaur> magthe, perhaps lpaste your code
01:23:40 <arne_> no i mean seriously, if you use lambda expressions as they're supposed to, you're not losing anything right? except type-safety, and that maybe can be patched in in some most languages?
01:23:42 <geekosaur> @paste
01:23:42 <lambdabot> Haskell pastebin: http://lpaste.net/
01:23:48 <magthe> geekosaur, quchen: then I'm missing something in syntax since I get parse errors... all examples I see are of function defs :(
01:23:52 <quchen> > case Just 1 of y | Just x <- y -> x -- magthe 
01:23:54 <lambdabot>  1
01:25:03 <magthe> quchen: ah, it was that vertical bar that was missing! thanks!
01:25:26 <halogenandtoast> arne_: the way oop, functional, and other paradigm languages are written is all different. Sure you can use lambdas in non functional languages but that will only get you so far and at the end of the day if that's how you want to write you programs you're missing out on a language the fully supports that style
01:25:32 <halogenandtoast> anyways back to my encoding problem!
01:25:37 <halogenandtoast> I must figure this out
01:25:45 <halogenandtoast> I just want to replace some stupid text in my string
01:25:50 <quchen> arne_: I know of no language with a »patched in« type system that works. C++ templates are completely broken, Java Generics are completely broken.
01:26:04 <reactormonk> Do I violate the lens laws if I have a prism that lenses to a left/right depending on the input on a set?
01:26:44 <reactormonk> ... yes, put put.
01:28:32 <quchen> magthe: Pattern *guards* :-)
01:28:43 <cocreature> halogenandtoast: do the japanese characters appear correctly in GHCi? when I set LANG=C I just get question marks whereas they appear correctly with LANG=en_US.UTF-8
01:29:15 <halogenandtoast> putStrLn "\23470"
01:29:16 <halogenandtoast> 宮
01:29:23 <halogenandtoast> that's my output
01:29:27 <halogenandtoast> they seem to appear correctly
01:29:37 <Xnuk> 궁
01:29:57 <geekosaur> so maybe it's your system's regcomp etc. that don't properly support utf8
01:30:36 <geekosaur> you may need to install a UTF8 aware PCRE and use pcre-light or the Text.Regex PCRE module
01:30:43 <halogenandtoast> I don't know what regcomp is but I'd be surprised if OSX messed this up.
01:31:09 <ongy> doesn't osx use a 16bit encoding?
01:31:14 <geekosaur> it's the POSIX regular expression compiler function (goes along with regexec which actually does matching, etc.)
01:31:19 <halogenandtoast> ongy: probably
01:31:42 <halogenandtoast> I have no knowledge providing me with a way to determine that
01:31:44 <geekosaur> and, OS X is not guaranteed to get them right *for the BSD API*, only for Aqua / CoreFoundation and friends
01:33:46 <magthe> quchen: true, but I don't think I've even seen a 'case' that does more than pattern match and therefore leaves out the '|'
01:36:33 <quchen> magthe: A hack that one can use instead of -XMultiWayIf is »case () of _ | p1 -> … | p2 -> …«
01:37:00 <quchen> A bit noisy, but does the trick
01:38:45 <geekosaur> halogenandtoast, another alternative if the POSIX regex functions are broken is to use Text.Regex.TDFA
01:38:56 <geekosaur> it's slower but pure haskell and guaranteed to handle utf8 properly
01:39:11 <geekosaur> (provided locale is correct for feeding data into / out of your program)
01:39:56 <geekosaur> (regex-tdfa package if needed)
01:41:11 <halogenandtoast> okay I'll try that.
01:45:22 <magthe> quchen: ah, nice!
01:48:25 <sm> regex-tdfa++
01:48:27 <halogenandtoast> geekosaur: is it possible to do search and replace with Text.Regex.TDFA?
01:48:38 <halogenandtoast> I was using `subRegex` from Text.Regex
01:48:55 <halogenandtoast> I seems like Text.Regex.TDFA just supplies me with `=~`
01:49:08 <halogenandtoast> s/^I/It/
01:49:17 <sm> replace helpers here: http://hackage.haskell.org/package/hledger-lib-1.1/docs/Hledger-Utils-Regex.html
01:52:29 <halogenandtoast> sm: I'll take a look at that
01:53:02 <halogenandtoast> sm: It works!
01:54:47 <sm> \o/
02:02:38 <halogenandtoast> sm: Thanks again, that was a big help
02:03:55 <halogenandtoast> Excitedly enough, I've almost finished my first actual Yesod project (I pretty much just have to figure out how to deploy it now)
02:04:39 <halogenandtoast> Anyone have recommendations for deploying a haskell app?
02:04:56 <halogenandtoast> thinking of trying: https://haskellonheroku.com/
02:07:01 <sm> nice halogenandtoast 
02:07:21 <sm> I use a vps
02:13:32 <liste> halogenandtoast: halcyon helps with deployment, that's what haskellonheroku uses
02:16:38 <halogenandtoast> liste: thanks, seems to have failed me.
02:18:14 <halogenandtoast> or I guess I have no idea how to use it
02:24:36 <sm> it is not much used, I would have been surprised
02:27:20 <sm> maybe #yesod has some more deployment options
02:30:27 <reactormonk> Could someone help me with the syntax error on `in` here? https://gist.github.com/fe1c5a26945d42fccb4754736bcaaaee
02:32:26 <jophish> joeyh: If I wrote some modifications to concurrent-output, where can I send them?
02:33:38 <liste> halogenandtoast: nixos+nixops is also an interesting option
02:33:53 <liste> halogenandtoast: it's a lot to learn though
02:34:23 <lyxia> reactormonk: let is not correctly aligned
02:35:05 <halogenandtoast> liste: well you've already scared me away
02:35:27 <cocreature> alignment is a scary topic
02:35:54 <reactormonk> lyxia, ah, thanks
02:36:10 <lyxia> reactormonk: there are 2 spaces in front of line 3, but 4 in front of line 7. Also do blocks use "let" without "in".
02:37:18 <reactormonk> lyxia, what do you mean with the "let" without "in"?
02:37:51 <cocreature> reactormonk: you can put "let var = val" on any line of a do block
02:38:06 <cocreature> and after that line "var" will be bound to "val"
02:39:52 <reactormonk> cocreature, do I have to repeat "let"?
02:39:54 <lyxia> actually, you can use "let ... in", but it will count as a single statement.
02:41:00 <cocreature> reactormonk: no http://lpaste.net/352130 works too
02:41:38 <merijn> lyxia: I don't like the use of statement as haskell, as a language, doesn't have statements
02:41:46 <reactormonk> cocreature, cool, thanks
02:41:51 <jophish> Is there a function in text which gives me the ByteString which hPutStr would write to the handle?
02:42:03 <c_wraith> merijn: there is that construct that the grammar calls a statement....
02:42:37 <merijn> c_wraith: I'll take this as my incentive to complain to the Haskell Prime committee :)
02:42:39 <cocreature> jophish: if you just want to write to a handle, there is an "hPutStr" function in Data.Text.IO
02:42:58 <jophish> cocreature: I'd like to get the bytestring which would be written to that handle
02:43:02 <jophish> and save it for later
02:43:14 <jophish> This function would look like: Text -> IO ByteString
02:43:30 <jophish> ah, encodeLocale
02:43:38 <c_wraith> merijn: https://www.haskell.org/onlinereport/haskell2010/haskellch10.html#dx17-180060
02:44:09 <lyxia> merijn: how would you call the elements of a do block?
02:44:26 <c_wraith> I didn't realize there was an empty statement in the grammar.  Hmm.
02:45:13 <merijn> lyxia: I would call them expressions all the way down
02:45:53 <c_wraith> a bind really isn't an expression, though.
02:45:53 <cocreature> merijn: calling "x <- y" an expression seems weird
02:45:55 <lyxia> but then it gets confusing because "expression" means a lot of things
02:46:12 <cocreature> sure you can call everything an expression but then you lose a useful distinction
02:46:47 <dramforever> it's officially called a 'statement'
02:47:34 <merijn> dramforever: You appear to have a 5 minute lag ;)
02:47:56 <dramforever> Uh, maybe
02:48:00 <merijn> I don't like distinguishing do notation to begin with
02:48:30 <cocreature> that’s fine but there _is_ a distinction in the expressions allowed in do notation and the expressions allowed elsewhere
02:48:46 <merijn> cocreature: In what sense?
02:49:07 <cocreature> merijn: "let x = y" is not a valid expression outside of do notation, "x <- y" is not a valid expression outside of do notation
02:49:37 <dibblego> x <- y works in a list comprehension
02:49:54 <geekosaur> so does the truncated let iirc
02:50:03 <geekosaur> but then a list comp is really just a condensed do
02:50:27 <dramforever> I would appreciate it if you would call it a 'statement', or maybe just recognize that there are valid syntactic constructs that don't really have values
02:50:31 <dramforever> How's my lag?
02:50:56 <cocreature> merijn: you can ofc come up with a different name for the things allowed in do notation but I don’t think "statement" is that bad
02:51:16 <merijn> dramforever: But you can't have valid syntactic constructs that don't have values, as, for example a do block consisting of "x <- y" is a syntax error
02:51:55 <dramforever> Why
02:52:09 <lyxia> well it's valid as a statement
02:52:13 <dramforever> 'x <- y' is a valid statement (as in do-notation)
02:52:49 <dramforever> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
02:52:53 <merijn> dramforever: It's only valid syntatically if followed by something else
02:53:23 <merijn> Anyway, we are now drifting into a more pedantic discussion then I intended :)
02:54:10 <dramforever> I suppose we are not thinking in the same direction
02:54:44 <lyxia> dramforever: each is pretty nice!
02:54:50 <dramforever> You know, we can't talk about words that don't make complete sentences and still make some sense
02:55:07 <dramforever> lyxia: Oh, that's... actually what I was going to ask you guys about
02:55:18 <dramforever> lyxia: Thank you
02:55:31 <dramforever> But I'm sort of... stuck now
02:56:04 <lyxia> oh?
02:56:09 * novadev
02:56:21 * novadev
02:56:23 <dramforever> Because as you can see it supports only a few syntactic constructs
02:56:52 <dramforever> Literally just one useful thing called 'function application'
02:57:12 <dramforever> And I'm so far unable to figure out how to extend it to case, let, lambda, etc.
02:57:53 <dramforever> And that is what I wanted advice on.
02:58:05 <dramforever> But did you just say it's 'pretty nice'?
02:58:22 <dramforever> lyxia: ^
02:59:02 <dramforever> hmm my lag seems fine :)
02:59:21 <lyxia> I did
02:59:31 <dramforever> How's your experience?
02:59:41 <dramforever> did you try to use it somewhere?
02:59:44 <dramforever> how it went
03:00:37 <lyxia> Unfortunately I haven't had the opportunity to use it. I just meant that it's a cool idea.
03:02:06 <dramforever> You did see it lacks support of many constucts right
03:03:26 <lyxia> Not before you just mentionned it.
03:05:26 <dramforever> :(
03:15:29 <lyxia> I think using >>= rather than join would make it easier to scale to other constructs.
03:16:43 <lyxia> (case (~! x) of ...) becomes (join (fmap (\x' -> case x' of ...) x)), i.e., (x >>= \x' -> case x' of ...)
03:19:02 <lyxia> dramforever: would that not work?
03:25:25 <thatguy> can anyone tell me some class for which one can instanciate a functor but not a applicative?
03:25:55 <thatguy> I find it hard to imagine since all the stuff I did functors for in the tutorials I can imagine easily how I would to an applicative
03:26:07 <phadej> thatguy: http://hackage.haskell.org/package/pointed-5/docs/Data-Pointed.html
03:26:29 <phadej> the lot discussed class
03:26:57 <dramforever> lyxia: Are you still there?
03:27:02 <lyxia> yeah
03:27:03 <dramforever> Sorry I was away
03:27:14 <lyxia> np
03:27:28 <dramforever> Because I would really like it if I could use fmap or <*>
03:27:57 <dramforever> like, say I have: case (~! getLine) of "randompassword123" -> Pass; _ -> NoPass
03:28:10 <dramforever> I don't want to use >>= here, because a fmap will do
03:28:25 <lyxia> Oh I see.
03:28:28 <dramforever> I think I really need some more 'indirect' techniques here
03:28:47 <dramforever> like converting to ANF or something, I don't know, I've never taken a compiler course
03:29:26 <lyxia> That makes sense. So in a case statement you need to look inside each alternative to see whether one is impure.
03:30:04 <dramforever> Yeah, like that
03:30:36 <mniip> 1486380303 [14:25:03] <thatguy> can anyone tell me some class for which one can instanciate a functor but not a applicative?
03:30:44 <dramforever> but code has to be principled, it takes steps from examples to code
03:30:44 <mniip> (e, )
03:30:46 <mniip> for arbitrary e
03:31:17 <thatguy> phadej, thanks
03:31:21 <mniip> Const e, for arbitrary e, for the same reason
03:31:37 <mniip> Pair
03:33:17 <thatguy> mniip, thank you too
03:34:35 <Taneb> mniip, Pair can be an applicative, with similar semantics to ((->) Bool)
03:34:44 <mniip> hmm
03:34:47 <mniip> yeah perhaps
03:34:50 <c_wraith> Or a 2-element ziplist
03:35:04 <mniip> StateT s ZipList
03:35:06 <Taneb> pure x = Pair x x; Pair f g <*> Pair x y = Pair (f x) (g y)
03:35:16 <mniip> for a more contrived example
03:35:17 <Taneb> Pair can even be a Monad
03:35:20 <c_wraith> For an example of something that doesn't work as an applicative for different reasons, there's Coyoneda
03:35:24 <thatguy> in the CIS 194 tutorial it says you should implement: replicateA :: Applicative f => Int -> (f a) -> (f [a]) ... isn't Functor f enough here?
03:35:41 <thatguy> I would implement it as replicateA n fa = replicate n <$> fa and that is ok for functors
03:35:55 <mniip> thatguy, it is indeed
03:35:56 <Taneb> A variant of Void that takes a type paramater, ie. data VoidF a
03:36:24 <c_wraith> thatguy: that's a different operation
03:36:54 <c_wraith> thatguy: consider replicateA 4 (putStrLn "hello")
03:36:55 <dramforever> lyxia: You know what, I think I'm droppng that wish
03:37:04 <mniip> StateT s ZipList is a sad observation though
03:37:33 <c_wraith> thatguy: it should result in an action that outputs hello 4 times
03:37:42 <c_wraith> thatguy: your example would only output it once.
03:38:20 <dramforever> thatguy: the type is okay, but the behaviour is wrong
03:38:35 <c_wraith> thatguy: getting the correct behavior does require Applicative
03:38:39 <thatguy> c_wraith, can you give me an example of a functor where mine works wrong without IO?
03:38:51 <thatguy> I have to admit I didn't wrap my head around IO yet
03:38:59 <c_wraith> thatguy: sure.  replicateA 4 (modify (+1))
03:39:27 <thatguy> ok thanks everyone I will take another look now
03:39:34 <mniip> replicateA 4 [False, True]
03:39:58 <dramforever> thatguy: 'replicateA n f' means 'do f, n times, gather the results'
03:41:35 <mniip> :t (sequenceA .) . replicate
03:41:37 <lambdabot> Applicative f => Int -> f a -> f [a]
03:41:57 <lyxia> dramforever: the wish of having principled code?
03:42:06 <mniip> :t ((sequenceA .) . replicate) 3 [False, True]
03:42:08 <lambdabot> [[Bool]]
03:42:14 <mniip> > (sequenceA .) . replicate
03:42:16 <lambdabot>  error:
03:42:16 <lambdabot>      • No instance for (Typeable f0)
03:42:16 <lambdabot>          arising from a use of ‘show_M543442908694248727111950’
03:42:17 <mniip> ugh
03:42:27 <mniip> messed up :s
03:42:36 <mniip> > ((sequenceA .) . replicate) 3 [False, True]
03:42:38 <lambdabot>  [[False,False,False],[False,False,True],[False,True,False],[False,True,True]...
03:42:51 <mniip> compared with your solution,
03:42:58 <mniip> > (fmap . replicate) 3 [False, True]
03:43:00 <lambdabot>  [[False,False,False],[True,True,True]]
03:44:04 <dramforever> lyxia: no, I mean the applicative/functor part
03:44:17 <dramforever> the functior part, just throw it away
03:44:26 <dramforever> and I'll do this for applicative https://ghc.haskell.org/trac/ghc/wiki/ApplicativeDo
03:44:37 <dramforever> s/functior/functor
03:44:58 <dramforever> I'll just emit do-notation and let the mighty GHC devs handle it
03:45:10 <dramforever> no point wasting my life on that
03:45:45 <lyxia> Isn't applicative do also compatible with functors
03:46:16 <dramforever> They do?
03:46:19 <lyxia> do { x <- y ; return (f y) } gets desugared to fmap f y
03:47:10 <dramforever> ok
03:47:27 <dramforever> that's pretty awesome
03:49:19 <dramforever> All heil GHC!!
03:59:02 <Darwin226> Hey guys. How do I write instances for custom kinds? Say I have a datatype `data K = A | B`. How do I write an instance for the `K` KIND, not the type? `instance C 'K` doesn't work saying K is not a data constructor, but `instance C K`
03:59:08 <Darwin226> doesn't mean the same thing
04:00:12 <Darwin226> Hmmm, or does it?
04:00:41 <lyxia> DataKinds makes the type K also a kind.
04:01:18 <lyxia> So, it's the same.
04:01:41 <merijn> Darwin226: You can use a tick to incidate you mean the lifted type
04:01:49 <merijn> Darwin226: 'Foo for the DataKinds version
04:02:33 <Darwin226> merijn: Ok, so does the distinction not make sense for the higher levels?
04:02:57 <merijn> Darwin226: Can you lpaste a minimal example?
04:03:13 <Darwin226> Sure
04:06:34 <Darwin226> merijn: http://lpaste.net/352132
04:08:19 <reactormonk> How strong is the gitter movement in haskell? In scala, everyone's over there.
04:09:09 <merijn> I don't even know what gitter is, but since it has 'git' in the name, I already don't like it :)
04:10:01 <merijn> Darwin226: What's the error? If any?
04:10:14 <Darwin226> There is none. This is probably what bothers me
04:10:34 <Darwin226> It seems like "it worked out" when it probably shouldn't have
04:10:39 <merijn> Darwin226: Oh, actually I see the problem
04:10:58 <merijn> Darwin226: Now that I think about it, the entire premiss doesn't really make sense
04:11:07 <merijn> Darwin226: It's just using 'K' the type
04:11:16 <merijn> You can't instantiate classes for kinds
04:11:23 <merijn> Because classes are already kind level in GHC
04:11:31 <Darwin226> I don't think that's true anymore with TypeInType
04:11:47 <Darwin226> and indeed without the second instance the first one doesn't compile
04:11:57 <Darwin226> saying there's a missing KindConstraint instance for K
04:11:58 <merijn> oh...I'm not touching a mix of TypeInType + DataKinds if things are confusing :)
04:13:35 <Darwin226> I think I'll just hope that this works
04:17:17 <ongy> most people here use haskell rather to not have to hope
04:21:47 <BernhardPosselt> in java you usually do layered design where you pass in the lower layers through the constructor
04:21:52 <BernhardPosselt> how does this translate to haskell?
04:22:14 <BernhardPosselt> are my layers functions and DI partial application?
04:24:10 <BernhardPosselt> e.g. you've got a function that returns a customer from a database, e.g. getCustomerById connection id = …
04:24:34 <BernhardPosselt> then i'd partially apply the function so it matches getCustomerById id = …
04:25:04 <merijn> BernhardPosselt: tbh, I've looked up what dependency injection like 10 times by now, and every time I do it always seems rather trivial and then I end up forgetting what the entire point was
04:25:40 <BernhardPosselt> merijn: its basically: pass in stuff that you need instead of using a global/singleton
04:25:46 <merijn> BernhardPosselt: As for the partial application thing, that sounds a rather common approach, yes
04:25:48 <dramforever> BernhardPosselt: That's good enough I think
04:26:39 <hpc> so... taking something as a parameter is considered rare and noteworthy enough in java that it got the name "dependency injection"?
04:26:49 <merijn> hpc: Basically
04:26:56 <BernhardPosselt> hpc: not only limited to java
04:27:14 <cocreature> hpc: “adding a parameter” doesn’t sound so clever
04:27:19 <Darwin226> BernhardPosselt: Haskell lets you have constraints on the actual context in which your function is running so you can actually avoid the whole parameter passing thing and let it happen automatically
04:27:25 <BernhardPosselt> hpc: the global/static/singleton cancer is everywhere
04:27:26 <dramforever> parameters are very underappreciated
04:27:35 <dramforever> in imperative languages, that is
04:27:51 <merijn> BernhardPosselt: There's a couple of different ways to deal with this sorta thing, but generally 80% of them tend to be solved by "parameter to a function", which after a while makes it seems so needlessly complex in other languages
04:28:28 <merijn> BernhardPosselt: The bonus of (most) things being immutable by default, the entire point of global/static/singleton mostly disappears :p
04:28:40 <BernhardPosselt> merijn: right
04:28:47 <dramforever> global constants are not like they matter
04:29:03 <dramforever> *That's* something I really like about immutability
04:29:58 <BernhardPosselt> so typeclasses kinda seem similar to interfaces
04:30:18 <merijn> Yes and no
04:30:28 <BernhardPosselt> instead of creating a getCustomerById function, would i create a CustomerRepository typeclass which defines the single functions?
04:30:32 <merijn> There are some things interfaces can't express
04:31:03 <merijn> BernhardPosselt: Generally not, I would usually just stick to a function that takes an extra argument
04:31:22 <liste> BernhardPosselt: interfaces specify objects, type classes specify types
04:31:40 <liste> BernhardPosselt: that's the big difference
04:31:56 <hpc> type classes are largely more like operator overloading
04:32:09 <hpc> and you don't get the polymorphism you might expect out of them
04:32:12 <liste> ^ that, both are ad-hoc polymorphism
04:32:21 <liste> operator overloading and type classes
04:32:28 <merijn> Some things interfaces generally can't do is: Enforce "sameness" on multiple arguments, consider "(==) :: Eq a => a -> a -> Bool" <- this requires both arguments to == to be the same type
04:32:31 <hpc> for instance in java, you could have an array of type SomeInterface[]
04:32:37 <hpc> and a bunch of things that implement that interface
04:32:44 <hpc> now you have a relatively heterogenous array
04:32:57 <hpc> in haskell, SomeTypeClass a => [a] is a homogenous linked list
04:33:00 <merijn> Whereass if you'd have like a Comparable interfaces in Java with "bool compare(Comparable c1, Comparable c2);" you have no way to guarantee c1 and c2 are the same type
04:33:31 <Darwin226> I don't know how familiar people here actually are with modern OOP but these days all of these things are perfectly expressable with interfaces
04:33:53 <merijn> Darwin226: You could do a reasonable Comparable with a generic based interface, I suppose
04:33:59 <dramforever> You mean generics?
04:34:07 <Darwin226> yes, and it's exactly how it's done
04:34:15 <hpc> fun fact, java generics were designed by one of the original haskell designers
04:34:27 <merijn> Darwin226: Generics can't do all of the things typeclasses can, though
04:34:34 <Darwin226> what you can't do is define instances/implementations on existing types that you can't change
04:34:42 <Darwin226> and you can't do higher-kinded stuff in most OOP languages
04:35:20 <Darwin226> Oh, and you can't do conditional implementation that depends on some other implementation existing
04:35:26 <hpc> you also still don't get type safety for your compare method
04:35:32 <Darwin226> You do
04:35:40 <hpc> bool compare(Comparable<T> c1, Comparable<T> c2)
04:36:07 <hpc> but if you do compare((Object)(new Foo()), (Object)(new Bar())), how does it compare them?
04:36:09 <dramforever> something like <T extends Comparable> compare (T c1, T c2)
04:36:23 <dramforever> I think Java can do this
04:36:25 <hpc> they're the same type, with T = Object
04:36:27 <dramforever> now
04:36:29 <Darwin226> the type T implements Comparable<T> interface
04:36:38 <hpc> but they still have different method implementations
04:36:41 <Darwin226> which specifies something like bool Compare<T>(T other)
04:36:59 <Darwin226> it's completely typesafe
04:37:04 <dramforever> I think we're already off the track here
04:37:07 <Ford_Prefect> Hi folks. I'm trying to use Persistent here, and I've got insert working fine. I can't figure out what to do with selectList, though -- do something to explicitly go from [Entity record] to [MyDataStructure]?
04:37:31 <Ford_Prefect> Or am I thinking about this all wrong? :)
04:37:51 <Darwin226> Also this attitude with saying DI is a "fancy name for extra parameters" is really not healthy
04:37:57 <merijn> Ford_Prefect: Entity is just a tuple of the ID of your record and the actual record
04:38:16 <BernhardPosselt> so tl;dr you dont use type classes to create a collection of functions but to make stuff fit into a generic function
04:38:31 <Darwin226> DI is a way of structuring code. Extra parameters are just the most approachable way of doing it
04:38:49 <merijn> Ford_Prefect: See: http://www.yesodweb.com/book/persistent#persistent_fetching_by_unique_constraint
04:38:50 <Darwin226> not to mention it's probably one of the OO patterns that works out the best in Haskell
04:39:53 <dramforever> BernhardPosselt: Yes, TCs are for types, as the name says
04:40:11 <dramforever> TIL DC is that easy
04:40:26 <dramforever> I meant DI
04:40:53 <Ford_Prefect> merijn: awesome, thanks!
04:40:59 <hpc> BernhardPosselt: a lot of type classes come with laws that all instances need to follow, too
04:41:03 <opqdonut> Darwin226: how does DI work in haskell?
04:41:14 <dramforever> by passing parameters
04:41:33 <dramforever> ' DI is a way of structuring code. *Extra parameters* are just the most approachable way of doing it' (emphasis added)
04:41:49 <opqdonut> right, pureness enforces DI in that sense?
04:41:54 <hpc> BernhardPosselt: Monoid has mempty and mappend, with the laws that (mempty `mappend` x) = x = (x `mappend` mempty), and (x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)
04:42:13 <hpc> (or in other words, mappend is associative and mempty is both a right and left identity of mappend)
04:42:29 <hpc> and that's something that shows up in a lot of places that we would like to be able to think about in a common way
04:42:49 <Darwin226> opqdonut: My favorite way is MTL classes or effects. You declare what your function wants to do and the caller decides how it's done.
04:42:52 <hpc> but so many things have those properties and we don't want to miss any, that we make it a type class so it's "open"
04:43:13 <Darwin226> opqdonut: passing parameters is the trivial case of MTL classes where the classes is MonadReader
04:43:25 <liste> BernhardPosselt: a record of functions is more analogous to Java's interface
04:43:26 <dramforever> Actually, dare I say, typeclasses are generally suitable for the more 'mathematical' structures
04:43:30 <merijn> Darwin226: Until you need multiple of those ;)
04:43:40 <dramforever> if a structure isn't general enough it's probably not worth a typeclass
04:43:43 <hpc> so to some extent it's a way to automatically build an interface from a few primitives
04:43:55 <hpc> (an interface as in "API", not as in some language keyword)
04:44:01 <dramforever> For example, Applicative is totally amazing 
04:44:24 <opqdonut> Darwin226: hmm right, I haven't thought of that as DI but I guess it is
04:44:27 <BernhardPosselt> liste: good point
04:44:31 <BernhardPosselt> havent thought of that :)
04:44:54 <hpc> when you write a new instance of Num, you get the operations you defined like (+) and fromInteger
04:45:00 <hpc> but also sum, which you didn't write
04:45:09 <hpc> and you get the Sum and Product newtypes which both have Monoid instances
04:45:27 <liste> BernhardPosselt: eg. data Drawable = MkDrawable { draw :: DC -> IO (); bounds :: (Int, Int, Int, Int) }
04:45:30 <hpc> > let xs = map Sum [1, 2, 3, 4, 5] in mconcat xs
04:45:33 <lambdabot>  Sum {getSum = 15}
04:45:37 <hpc> > let xs = map Product [1, 2, 3, 4, 5] in mconcat xs
04:45:43 <lambdabot>  Product {getProduct = 120}
04:46:20 <merijn> > getProduct . mconcat . coerce $ [1..10]
04:46:23 <lambdabot>  error:
04:46:23 <lambdabot>      Variable not in scope: coerce :: [Integer] -> [Product c]
04:46:26 <merijn> awww
04:46:31 <hpc> map coerce
04:46:35 <merijn> no Data.Coerce ? :(
04:46:37 <merijn> hpc: No
04:46:45 <hpc> oh dang, didn't read the error
04:46:49 <merijn> hpc: That's the entire point of coerce, to avoid the map
04:47:05 <hpc> fair point
04:49:03 <dramforever>  > getProduct . mconcat . Data.Coerce.coerce $ [1..10]
04:49:06 <dramforever> > getProduct . mconcat . Data.Coerce.coerce $ [1..10]
04:49:09 <lambdabot>  error:
04:49:09 <lambdabot>      Not in scope: ‘Data.Coerce.coerce’
04:49:09 <lambdabot>      No module named ‘Data.Coerce’ is imported.
04:49:20 <hpc> @let import Data.Coerce
04:49:22 <dramforever> no Data.Coerce . :(
04:49:23 <lambdabot>  .L.hs:80:1: error:
04:49:23 <lambdabot>      Data.Coerce: Can't be safely imported!
04:49:23 <lambdabot>      The module itself isn't safe.
04:49:26 <hpc> and there you go
04:49:49 <dramforever> Production usage of Safe Haskell :)
04:50:05 <hpc> yeah, i can't wait for {-# Safe #-} to become the default
04:52:19 <Edith> Can anyone recommend me a good library for interfacing with SDL? Only 2D drawing is necessary
04:52:38 <hpc> gloss maybe
04:53:23 <hpc> (technically it builds the window with GLUT, but both still do drawing via opengl)
04:53:27 <BernhardPosselt> regarding lifting: lifting is basically taking a function and making it work on another type, correct?
04:53:39 <BernhardPosselt> which often can be implemented in a generic fashion
04:54:27 <dramforever> Which is often more general than one would expect
04:54:55 <BernhardPosselt> e.g. liftM makes function work on monads
04:55:01 <hpc> it doesn't always have to be a function
04:55:02 <hpc> :t lift
04:55:04 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
04:55:27 <hpc> but yes, it's a type of transformation that on some level keeps something "the same"
04:55:45 <dramforever> those things would normally be functions/methods in other languages...
04:57:00 <Darwin226> Edith: https://hackage.haskell.org/package/sdl2 is really nice in my experience
04:57:17 <Edith> Thanks
04:57:40 <BernhardPosselt> i wish things like that were explained a bit more practical, e.g.  "this is a problem we run into, so we refactor it and make it generic like this"
04:57:56 <BernhardPosselt> rather than giving you the type signature and laws :D
04:59:00 <hpc> to teach some concepts like that, you'd be listing problems for days
04:59:28 <BernhardPosselt> you dont have to cover each use case :)
04:59:35 <BernhardPosselt> one or two are enough
05:01:33 <BernhardPosselt> as in: when explaining summation you only need to explain it with ints and floats maybe, complex numbers/quaternials/matrices are nice but dont really add that much anymore to your understanding
05:02:09 <dramforever> There's a thing called 'paper' for that, I suppose
05:04:12 <dramforever> BernhardPosselt: Does this qualify as 'explained more practical'? http://www.staff.city.ac.uk/~ross/papers/Applicative.html
05:04:24 <dramforever> Actually this PDF http://www.staff.city.ac.uk/~ross/papers/Applicative.pdf
05:05:34 <BernhardPosselt> dramforever: thanks!
05:05:54 <BernhardPosselt> sounds good
05:06:06 <BernhardPosselt> however i think good papers are a bit rare
05:06:51 <dramforever> And yes, DI with Reader is apparently a thing: https://medium.com/@johnmcclean/dependency-injection-using-the-reader-monad-in-java8-9056d9501c75#.bkju7szbr
05:08:13 <johan1> ++
05:18:28 <Xnuk> <>
05:31:26 <merijn> argh
05:32:51 <dramforever> lyxia: It's so nice I can't believe my eyes: http://lpaste.net/352136
05:33:09 <merijn> How can I get GHC to dump out the result of TH splices?
05:33:28 <dramforever> -ddump-splices
05:34:04 <dramforever> merijn: ^
05:34:14 <merijn> dramforever: thanks
05:37:13 <dramforever> You can probably also just (error (pprint blah)) in the middle of nowhere if you want
05:37:34 <dramforever> I've used this a few times
05:37:57 <ongy> afaik you can printLn in TH. but ddump-slices is pretty nice
05:38:15 <dramforever> yes you can
05:38:37 <dramforever> but 'error' can be used anywhere, so I just 'error' the input when I feel stuck
05:38:54 <dramforever> And get an example input back
05:38:58 <merijn> ongy: It's not my TH code
05:39:04 <dramforever> oh
05:39:06 <ongy> ah, that makes it harder
05:39:17 <dramforever> merijn: you can call other people's code in Q
05:39:40 <merijn> dramforever: no, I mean, I'm just calling some TH code in my module and want to know wtf it was generating
05:40:04 <dramforever> ok fair enough
05:40:20 <dramforever> I guess the fact that I'm writing TH drove me into the wrong direction
05:41:16 <merijn> dramforever: I'm using persistent and I'm pretty sure there's a simple way to do what I want, but I can't tell from the docs, so the sane solution is to look at wtf it's generating
05:41:26 <dramforever> :)
05:41:33 <merijn> ...
05:41:36 <merijn> Or maybe not...
05:41:47 <merijn> Can I somehow redirect the output of dumpsplices to a file?
05:42:25 <merijn> Because it's more than my scrollback can store >.>
05:43:39 <dramforever> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/debugging.html#ghc-flag--ddump-to-file
05:44:29 <dramforever> merijn: do you happen to use gnome-terminal?
05:45:17 <dramforever> Anyway, there could be a way to get infinite scrollback because that's hardly a problem for modern computers running graphical terminal emulators
05:45:40 <merijn> dramforever: No, tmux inside Terminal.app
05:45:51 <dramforever> Uh, whatever
05:45:55 <merijn> dramforever: I think tmux by default keeps like 5k lines of scrollback
05:46:01 <merijn> I rarely need more
05:46:14 <dramforever> And now you need more. WTF.
05:46:51 <dramforever> 'Or maybe not...', exactly
05:47:15 <merijn> tbh, I don't wanna deal with >5k lines of source code in terminal scrollback anyway :p
05:47:21 <ertes> scrollback isn't exactly the most convenient thing in the world anyway
05:47:48 <ertes> most terminal emulators can't even get searching right
05:49:36 <merijn> There's no "both" in Data.Bifunctor?
05:49:37 <Ford_Prefect> Hi again
05:49:46 <Ford_Prefect> I'm using Aeson and genericParseJSON
05:50:02 <Ford_Prefect> And was wondering if extraneous keys should be an error (they seem to not be)
05:50:12 <Ford_Prefect> Or if there's a way to make them be an error
05:50:17 <ertes> :t join bimap
05:50:19 <lambdabot> Bifunctor p => (c -> d) -> p c c -> p d d
05:54:30 <dramforever> :t both
05:54:32 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => (a -> f b) -> r a a -> f (r b b)
05:54:42 <merijn> dramforever: That one's from lens, afaik
05:54:46 <Tuplanolla> :t over both -- It's actually this.
05:54:48 <dramforever> no, screw it...
05:54:48 <lambdabot> Data.Bitraversable.Bitraversable r => (a -> b) -> r a a -> r b b
05:55:10 <dramforever> 'Bitraversable' no, no
05:55:58 <Tuplanolla> Yes, yes. It requires `Bifunctor`.
06:03:38 <mahmoudgebril> 9 11 attacks, Did USA do it itself or it just let it happen?
06:03:38 <mahmoudgebril> Did USA administration murder 3000 American citizen in 9 11 attacks to justify starting a war against iraq?
06:03:38 <mahmoudgebril> If al-qaeda did it, why go to kill 2 million Iraqi?
06:03:38 <mahmoudgebril> http://creatvchaos.blogspot.com.eg/    https://creatvchaos.wordpress.com/
06:03:38 <mahmoudgebril> Some of the benefits Americans say they achieved after 9 11 attacks include:
06:03:38 <mahmoudgebril> *constant flow of oil, which price is in continuous decline. Trump said he will simply take the Iraqi oil, and when he was told that Iraqi oil belongs to iraq he said there is no iraq(after usa destroyed it ).
06:03:39 <mahmoudgebril> *Invasion of afghanstan with construction of not less than 14 american military base which give a close eye on china.
06:03:39 <mahmoudgebril> *Removal of potential threat to isreal represented in iraq which throw isreal with more than 30 rocket after American assault on iraq during 2nd gulf war.
06:07:11 <merijn> @where ops
06:07:11 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
06:07:38 --- mode: ChanServ set +o shapr
06:07:59 <shapr> too late
06:08:09 --- mode: shapr set -o shapr
06:11:11 <tfc> i am trying to do a http POST request with Network.Curl. And i need the html body response string from that. i am currently looking at the Network.Curl documentation, but it is confusing, and i do not see how to do it. anyone who did this before?
06:11:58 <shapr> tfc: perhaps wreq has better documentation?
06:12:28 <opqdonut> tfc: you get a CurlResponse_ object with curlGetResponse_, then you get the body from that with respBody
06:12:53 <tfc> shapr: does wreq allow me to do what curl can do with "--anyauth -u user:pass" ? 
06:13:08 <tfc> opqdonut: yeah that's what i am currently looking for, but with POST...
06:13:45 <opqdonut> tfc: it looks like you should use perform_with_response_ if you want to POST with results
06:14:14 <tfc> opqdonut: ok, i will try to get it to work. thx for the pointer.
06:14:36 <opqdonut> or perhaps do_curl_ is a bit easier
06:17:37 <tfc> opqdonut: for both, the first parameter is a "Curl" typed value. the documentation off that type is just empty, so i do not even see how to construct any Curl value. that is confusing again.
06:20:13 <tfc> opqdonut: in the source code of that package i see mkCurl :: CurlH -> IO Curl. So that would help me constructing that Curl value, but i don't get the "data CurlH = Ptr Curl_" type which that one needs as parameter. still too new to haskell
06:21:49 <tfc> opqdonut: ok nvm found the "initialize :: IO Curl" function.
06:29:05 <BernhardPosselt> lets say ive got a binary tree like this: data Tree a = Nil | Node (Tree a) a (Tree a)   
06:29:15 <BernhardPosselt> how do i get the left element of a node?
06:29:32 <BernhardPosselt> leftNode Nil = Nil
06:29:32 <BernhardPosselt> leftNode Node (Tree a) a (Tree a) = 
06:29:37 <BernhardPosselt> im a bit stuck at pattern matching :D
06:29:48 <BernhardPosselt> can i assign a variable to the Tree a?
06:29:52 <Atlantic778> Hi! Is there a standard type for BitVectors? So, I need ~O(1) access by key (index) and "bit packing" for Booleans. I was reading about sequences, arrays, lists and Data.Vector but I'm not really sure what would be the right choice.
06:30:37 <tdammers> BernhardPosselt: you can pattern match on Node left item right
06:30:46 <tdammers> leftNode (Node left item right) = left
06:30:52 <tdammers> leftNode Nil = Nil
06:31:14 <tdammers> for the first line, it's considered good style to use _ for the parts of the pattern that you don't use
06:31:16 <tdammers> sp
06:31:18 <tdammers> so
06:31:24 <tdammers> leftNode (Node left _ _) = left
06:31:35 <shapr> Atlantic778: Data.BitVector?
06:33:41 <tdammers> BernhardPosselt: the line you wrote there, leftNode Node (Tree a) a (Tree a), does not work, firstly because of precedence issues, but secondly because Tree is a type constructor, not a value constructor
06:34:41 <BernhardPosselt> ok
06:35:45 <BernhardPosselt> so can i restrict it to types
06:36:26 <BernhardPosselt> i mean what if i had something like data Tree a = Nil | Node (Tree a) a (Tree a)  | Node Nil a Nil
06:37:19 <BernhardPosselt> then leftNode (Node left _ _) = left would be ambiguous right?
06:37:27 <Atlantic778> shapr: yes, something like that. Does it do the bit packing? I can't find that info in the docs. And, if I understand it correctly, I can obtain Data.BitVector by installing the bv package?
06:37:34 <tdammers> you can't have the same constructor name in your type twice
06:37:48 <shapr> Atlantic778: yes, it's in the bv package
06:37:53 <merijn> Anyway know if I can either get persistent to generate newtypes or somehow get something that can both construct/inspect a datatype? I have like 5 datatype which are essentially newtypes around Text, but I can't write "generic" code that works for all of them, sadly :\
06:37:57 <BernhardPosselt> ok, so I'd need to use something other than Node, correct?
06:37:58 <tdammers> also Nil is not a type constructor, so you can't have Node Nil a Nil as a constructor definition
06:38:04 <BernhardPosselt> like
06:38:27 <BernhardPosselt> data Tree a = Nil | Node (Tree a) a (Tree a) | SomethingElse (Tree a) a (Tree a)
06:38:27 <tdammers> Node Nil "Hello" Nil :: Tree String -- would be valid though
06:38:38 <tdammers> yes, you could have that
06:38:54 <Atlantic778> shapr: thanks! Also, do you know maybe what's the closest thing to this in the "standard haskell distribution"? (ghci?)
06:39:26 <shapr> Atlantic778: closest thing to what?
06:42:19 <Atlantic778> shapr: closest thing to bit vectors. Constant access time (as contstant it can get, of course), at least. Sequences?
06:43:08 <merijn> record accessors aren't first class either, are they? :\
06:43:09 <shapr> Atlantic778: I'd suggest Vector for that
06:43:42 <Atlantic778> shapr: but that's also an external package, isn't it? I'm sorry, I'm sometimes restricted to use external packages.
06:44:04 <Atlantic778> restricted to not use, I can't use them*
06:44:38 <shapr> Yes, it is an external library.
06:48:38 <jameseb> Atlantic778: why can't you use external libraries?
06:50:12 <Atlantic778> jameseb: I'm learning haskell by solving examples from programming competitions. You upload code and "online judge" (automated tests) will tell if your solution is good enough. Code gets compiled online and I can't use any external dependencies.
06:50:48 <shapr> Atlantic778: which online competition(s) uses Haskell?
06:51:35 <Atlantic778> shapr: SPOJ (sphere online judge) backend has support for haskell, to. For example, you can solve tasks on the codechef site in haskell.
06:51:42 <jstolarek> from Control.Arrow:
06:51:44 <jstolarek> first :: a b c -> a (b, d) (c, d) 
06:51:52 <jstolarek> is there a monadic equivalent?
06:51:56 <jstolarek> rougly:
06:52:47 <kadoban> hackerrank and codeforces allow haskell as well. I like those places
06:53:04 <jstolarek> a b (m c) -> a (b, d) (m (c, d))
06:53:06 <jameseb> Atlantic778: okay, so does the competition say what do you have access to?
06:53:50 <kadoban> jre2: \f -> sequence . first f    probably?
06:53:52 <Atlantic778> jameseb: as far as I know, it's says only ghc-7.6.3.
06:54:35 <Tuplanolla> @let import Data.Bitraversable
06:54:36 <Atlantic778> it says*
06:54:37 <lambdabot>  Defined.
06:54:53 <Tuplanolla> > bisequenceA (bimap (Just . negate) pure (42, 13)) -- This, jstolarek?
06:54:56 <lambdabot>  Just (-42,13)
06:54:58 <kadoban> hackerrank has GHC 7.8.4, I think codeforces is 7.8.3 for some reason
06:55:19 <jameseb> Atlantic778: okay, then I assume you only have access to GHC base
06:56:55 <kadoban> Usually there's a bit more allowed beyond base, though it can be a tad annoying figuring out what
07:04:21 <jameseb> kadoban: these may be the modules you can use https://downloads.haskell.org/~ghc/7.6.3/docs/html/libraries/index.html
07:04:36 <merijn> I need something like a queue, but where duplicates are only read once. i.e. if I input "1,3,5,19,1,3,1,17" I expect to get '1,3,5,19,17' as output
07:05:46 <kadoban> jameseb: My question wasn't the original. But in my experience that won't be all. For example, hackerrank allows using stuff from parsec and a few others.
07:06:06 <Quintasan> merijn: Data.Set?
07:06:16 <kadoban> And codeforces disallows using some of that, I think the non-safe parts of base.
07:06:20 <merijn> Quintasan: How would I extract which elements have already been read?
07:06:57 <kadoban> merijn: A set + a queue, you check if something has been seen yet (check the set) before you add it to the queue, then you add it to both.
07:07:08 <merijn> I suppose I could use an MVar and limit access to the Chan with a check on the MVar
07:12:59 <Benzi-Junior> hey I have a type A = (B,C) , is it possible to force strictness onto B and C like you could with a data declaration ?
07:13:37 <quchen> No, type synonyms are just new lables for existing things.
07:14:52 <quchen> You could however use a smart constructor like »myTuple :: a -> b -> (a,b); myTuple !a b = (a,b)« if you want to make the first element of your tuple strict.
07:14:53 <jaspervdj> merijn: psqueues should be able to do what you need
07:15:22 <quchen> The better choice would probably be defining your own data type, since GHC knows that *all* use sites of your tuple have a strict »a«, possibly enabling more optimizations.
07:18:40 <merijn> jaspervdj: Ah, but those aren't concurrent, are they?
07:21:00 <dramforever> Is the haddock-building status of hackage publicly available somewhere?
07:21:40 <jaspervdj> merijn: Ah, no, I missed part of the question.
07:22:57 <merijn> jaspervdj: Basically, I'm writing a concurrent webscraper and have no clean way of getting ids and want to avoid rescraping ids I already encountered. But I guess just storing a Set in an MVar is the best way to go
07:23:57 <dramforever> merijn: I would keep both a Set and a Chan
07:23:58 <quchen> dramforever: Yes. I even knew where at some point.
07:24:25 <dramforever> because you don't want ids to go away after from the Set even after they leave the Chan
07:24:51 <dramforever> quchen: even for PENDING haddocks?
07:24:57 <quchen> dramforever: Example: https://hackage.haskell.org/package/pipes-4.3.2/reports/
07:24:59 <quchen> Hmmmmm
07:25:00 <quchen> Not sure
07:25:16 <merijn> I don't suppose Set has an operation that computes both union and difference
07:25:31 <tsahyt> hello. I'm implementing a way to record some statistics about an effectful calculation that's already running on an IO based transformer stack. My current approach is to have an IORef StatsRecord wrapped up in a newtype and exposing a function modifyStats :: MonadIO m => Statistics -> (StatsRecord -> StatsRecord) -> m (). I have two questions about this. first, is this a code smell? IORefs always seem a bit
07:25:33 <tsahyt> dirty to me. second, to implement functions StatsRecord -> StatsRecord I'll probably end up reinventing lenses. Does it make sense to pull in the entire thing with all its dependencies just for this one use case?
07:25:34 <quchen> dramforever: The API has lots of functions available, maybe there’s something in it for you! https://hackage.haskell.org/api
07:26:00 <quchen> dramforever: I suggest starting to read at »The reports-core feature«
07:26:05 <dramforever> I'm hoping for something that looks like https://travis-ci.org/ the webpage
07:26:14 <dramforever> just a bit anxious :(
07:27:12 <dramforever> quchen: hardly anything more than the link you gave :(
07:27:36 <dramforever> I guess I should wait by sleeping (midnight here)
07:27:38 <quchen> That was all I got :-/
07:36:35 <doubleleft_> I have two functions : lexer1 and lexer of type [a]->String->[a], and lexer a st = reverse $ lexer1 a st. How can I simplify this ?
07:40:01 <jophish> doubleleft_: one simple thing you can do: lexer a = reverse . lexer1 a
07:40:19 <jophish> not sure what kind of simplifications you're looking for though
07:40:35 <jophish> you could even do: lexer = reverse .: lexer1
07:40:45 <jophish> although that could be a little cryptic
07:44:09 <doubleleft_> jophish: (.:) ? I never met it.
07:44:53 <doubleleft_> jophish: An operator like (.) ?
07:48:37 <quchen> f .: g = \x y -> f (g x y)
07:48:41 <quchen> Mostly used to confuse people.
07:48:51 <tsahyt> where is .: defined?
07:48:57 <tfc> opqdonut: are you still there?
07:49:11 <maksim_> what is the current story for dev ops? is it haskell stack? hsenv? cabal sandboxes?
07:49:19 <kadoban> I don't think it's in base anywhere. It's probably in some libraries here and there. It should really be better known ... it's quite a useful little family of things.
07:49:30 <kadoban> maksim_: The first or the last
07:49:37 <kadoban> Never heard of hsenv
07:49:49 <athan> tsahyt: Composition.Extra :)
07:49:57 <byorgey> I don't think hsenv is maintained anymore
07:50:08 <athan> nor is mine >.>
07:50:17 <maksim_> can i have distinct ghcs per project using haskell stack?
07:50:23 <byorgey> maksim_: yes.
07:50:25 <athan> @hackage composition-extra
07:50:26 <lambdabot> http://hackage.haskell.org/package/composition-extra
07:50:55 <byorgey> maksim_: if you want that then you definitely want to use stack, not cabal sandboxes
07:51:02 <athan> (there should be way more combinators... combinatorically :|)\
07:51:26 <maksim_> byorgey, thank you
07:51:37 <jophish> doubleleft_: I probably wouldn't use (.:)
08:07:21 <AMDmi3> hey; is there a complete hackage index available somewhere?
08:07:35 <AMDmi3> like http://hackage.haskell.org/packages/names but with versions and preferrably in machine-readable format
08:12:01 <tdammers> AMDmi3: https://github.com/commercialhaskell/all-cabal-hashes
08:12:02 <quchen> AMDmi3: https://hackage.haskell.org/api#core says the result is available as JSON somehow
08:12:15 <quchen> At the /packages/ resource
08:13:20 <AMDmi3> :q
08:15:49 <AMDmi3> umm, looks as something close; how do I request json from /packages/?
08:17:00 <AndriusBartulis> Hiding the join/leave messages on irc client was one of the best decisions today.
08:19:46 <AMDmi3> oh, Accept header works
08:22:41 <quchen> AMDmi3: Had to read some hackage-server source, but found it! curl -G 'https://hackage.haskell.org/packages/.json'
08:24:39 <AMDmi3> unfortunately this only returns package names; I need basically all the date available on package page: https://hackage.haskell.org/package/zlib
08:27:54 <AMDmi3> I think I can heg index.tar.gz, as .cabal files contain this info. just not sure if I can parse them easily
08:28:20 <dcoutts> AMDmi3: the Cabal lib has the stuff you need to parse them
08:28:46 <AMDmi3> I'd prefer not to use any depends, so I need to parse them by hand
08:31:56 <MarcelineVQ> between the Cabal lib and http://hackage.haskell.org/package/hackage-db you're quite set for working with full package info
08:32:27 <AMDmi3> I don't use haskell at all
08:33:48 <thatguy> do I see it right that *> just chooses the right one of two functors?
08:34:06 <quchen> There is only one functor involved when using *>
08:34:30 <quchen> It discards the value computed by its left arugment, yes
08:34:37 <quchen> FWIW *> is the same as the monadic >>
08:34:47 <thatguy> I didnt do monads yet
08:34:54 <quchen> Nevermind then
08:34:55 <thatguy> so is *> fa fb = fb ?
08:35:12 <quchen> No, it’s not
08:35:16 <quchen> That would be (flip const)
08:35:30 <quchen> > Nothing *> Just 3
08:35:33 <lambdabot>  Nothing
08:36:09 <quchen> thatguy: Do you understand <*> yet?
08:36:15 <thatguy> hmm I want to implement the function for a tutorial but I don't get which kind of behavior is expected
08:36:19 <thatguy> yes I understood that
08:36:32 <quchen> *> can easily be defined in terms of *> :-)
08:36:39 <quchen> <*>, I mean
08:37:09 <quchen> :t (<*>)
08:37:11 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:37:12 <quchen> :t (*>)
08:37:14 <lambdabot> Applicative f => f a -> f b -> f b
08:37:38 <thatguy> But I don't really understand which kind of behavior is expected.  f g <*> f a applies the function g to a inside of f, I used that alrady a lot
08:37:58 <thatguy> I am somehow missing a definition of what *> should do
08:38:01 <quchen> thatguy: Yup! Now leave away the part that applies f to something :-)
08:38:50 <quchen> This is a standard way of using <*>:    (\x y -> f x y) <*> X <*> Y
08:38:58 <quchen> It’s equivalent to f <*> X <*> Y.
08:39:09 <thatguy> hmm sorry I have a hard time grasping this. is there some simple definition of what *> should do?
08:39:13 <thatguy> sorry for the inconvinience
08:39:32 <tdammers> the definition follows from the type
08:39:34 <thatguy> quchen: yes I used <*> that way a lot on the last exercise sheet
08:39:40 <thatguy> I thing I understood <*>
08:39:42 <thatguy> think*
08:39:44 <quchen> thatguy: It’s just a shorthand for a use case that arises a lot, namely when f ignores the »x« and returns simply the »y«
08:40:01 <tdammers> the intuition is that the angle bracket points to the thing you're interested in, while the other end is the part that you only have there for its effects
08:40:14 <quchen> thatguy: What’s the function that discards its first argument and returns the second? :-)
08:40:32 <quchen> Well, it’s f x y = x.
08:40:49 <quchen> And if you use that as the first argument to <*>, you get *>
08:40:56 <thatguy> yes, but as you said  fa *> fb = fb is not what is expected here
08:41:02 <c_wraith> quchen: uh, check that definition. :)
08:41:20 <quchen> c_wraith: Woops. »up to isormorphism« lalalalaala
08:41:39 <thatguy> c_wraith: you can explain with mathematical terms if you need to, I do maths
08:41:46 <quchen> (\x y -> y) <*> A <*> B
08:41:51 <quchen> That one
08:42:02 <quchen> It still evaluates A and B, but discards the »x« result
08:42:13 <quchen> That’s what *> does
08:42:14 <c_wraith> that first <*> should be a <$>
08:42:19 <quchen> Eh right.
08:42:19 <c_wraith> you're having an off day. :)
08:42:33 <quchen> c_wraith: You go ahead, I’m talking nonsense ;-(
08:42:41 <tdammers> also worth noting, maybe:
08:42:45 <tdammers> :t (*>)
08:42:47 <tdammers> :t (>>)
08:42:47 <lambdabot> Applicative f => f a -> f b -> f b
08:42:51 <lambdabot> Monad m => m a -> m b -> m b
08:43:07 <thatguy> so this is about side effects?
08:43:21 <c_wraith> thatguy: it's about effects.
08:43:41 <thatguy> ok I think I have to play around a bit with this
08:44:08 <c_wraith> > [1,2,3] *> "hello"
08:44:10 <lambdabot>  "hellohellohello"
08:44:36 <thatguy> there is obviously something I dont understand since I am not getting the difference between flip const and (\x y -> y) <$> A <*> B
08:44:53 <quchen> \x y -> y   *is*   flip const
08:45:05 <thatguy> ah yes
08:45:10 <quchen> flip const   *is not*   something <$> A <*> b
08:45:35 <quchen> (\x y -> y)    vs   (\x y -> y) <$> A <*> B
08:45:42 <thatguy> ahhh A could have some other effects on my input and then evaluating A first is different then just evaluating B
08:45:48 <quchen> Right!
08:45:51 <thatguy> ah ok I think I am starting to get it
08:46:02 <thatguy> well that was harder than it should have been
08:46:07 <thatguy> I'll go play around a bit
08:46:12 <thatguy> thanks everyone for the kind help
08:46:16 <quchen> thatguy: If you know about IO, then try »putStrLn "hello" *> putStrLn "world"«.
08:46:30 <quchen> thatguy: If you ignored the left argument, that would only print »world«.
08:46:45 <quchen> But we only ignore its resulting value of type (), but still have its effects executed.
08:48:45 <thatguy> yes I understood it when I thought about the Parser I wrote on the last tutorial chapter
08:49:08 <thatguy> I actually even already implemented that function without knowing it was *>
08:51:31 <lpaste> qmm pasted “suggestions on how to keep this running? it exits immediately” at http://lpaste.net/352142
08:54:02 <glguy> qmm: You're forking a process and then your main thread is done, has nothing to do, and exits. What were you hoping it would do?
08:56:00 <glguy> qmm: Also note that returning a result from main doesn't do anything. The result is always necessarily ignored.
08:59:08 <glguy> qmm: Have you looked at the documentation for forkProcess yet? I'm guessing you want to use something else: https://hackage.haskell.org/package/distributed-process-0.6.6/docs/Control-Distributed-Process-Node.html#v:forkProcess
09:02:24 <qmm> glguy: i'm hoping that the process stays alive
09:03:28 <qmm> maybe i'm looking for https://hackage.haskell.org/package/distributed-process-simplelocalnet-0.2.3.3/docs/Control-Distributed-Process-Backend-SimpleLocalnet.html#v:startMaster
09:03:51 <qmm> yeah, i think that's the answer
09:04:24 <glguy> I'd have guessed runProcess, which was just below forkProcess in the documentation.
09:06:25 <qmm> glguy: ah
09:06:30 <qmm> glguy: that did it
09:09:38 <qmm> sorry for so many questions. how does this result in a process that doesn't stop? done <- newEmptyMVar ; void $ forkProcess node $ try proc >>= liftIO . putMVar done ; takeMVar done >>= either (throwIO :: SomeException -> IO a) return
09:29:55 <thatguy> I have a function f :: a -> b -> c and some h :: d -> a is there a shorthand for composing h in the first argument, getting g :: d -> b -> c ?
09:32:39 <ongy> :t (undefined :: a -> b -> c) . (undefined :: d -> a)
09:32:41 <lambdabot> d -> b -> c
09:34:04 <thatguy> oh thats easy
09:34:07 <thatguy> ongy: thanks
09:52:14 <thatguy> could anyone tell me if this is a sensible implementation of "mapA :: Applicative f => (a -> f b) -> [a] -> f [b]" http://lpaste.net/352143 ?
09:57:36 <monochrom> thatguy: Who is cons?
09:58:37 <thatguy> monochrom: it does a -> [a] -> [a], it appends an element to a list
09:58:55 <thatguy> I just searched for a -> [a] -> [a] on hoogle and cons is what I found
10:00:19 <pavonia> @hoogle a -> [a] -> [a]
10:00:22 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
10:00:23 <lambdabot> GHC.OldList intersperse :: a -> [a] -> [a]
10:00:23 <lambdabot> Data.Text.Internal.Functions intersperse :: a -> [a] -> [a]
10:00:59 <pavonia> thatguy: You are looking fo (:)
10:01:03 <pavonia> for
10:01:03 <chef_excellence[> or simply use (:)
10:01:33 <monochrom> @type \fun list -> foldr (liftA2 (:).fun) (pure []) list
10:01:35 <lambdabot> (Foldable t, Applicative f) => (a -> f a1) -> t a -> f [a1]
10:02:16 <monochrom> OK it looks OK.
10:03:07 <thatguy> pavonia: ah thanks
10:03:17 <chef_excellence[> dropping the list would be nicer though
10:03:43 <thatguy> chef_excellence[: ah yes it is not needed
10:03:49 <chef_excellence[> mapA f = foldr (liftA2 (:).f) (pure [])
10:04:04 <tfc> i am looking for the nicest possible way to express something like in python, but in haskell: >>> "foo={}, bar={}".format("param1", "param2") <<<
10:04:08 <tfc> anyone a nice idea?
10:04:37 <ongy> formatting is pretty nice for such things
10:04:42 <ongy> package on hackage
10:05:09 <chef_excellence[> @thatguy well in this case you also can replace the brackets with $
10:05:09 <lambdabot> Unknown command, try @list
10:05:19 <tfc> the thing is that i will use this on one very long, very simple string and i hoped to not need another library
10:05:35 <chef_excellence[> foldr (liftA2 (:).f) $ pure []
10:08:56 <thatguy> chef_excellence[: is it considered to be nicer style to have $ instead of brackets?
10:09:25 <Jinixt> that's a heavily opinionated area
10:11:37 <chef_excellence[> okay :D so do as you like @thatguy
10:15:07 <thatguy> chef_excellence[: thanks for helping!
10:16:01 <chef_excellence[> @thatguy you're welcome :)
10:16:01 <lambdabot> Unknown command, try @list
10:16:20 <ongy> tfc: if the arguments are strings aswell, you can use concat
10:20:28 <tfc> ongy: that's similar to "unwords". the thing is that i'd like to store the string separated from arguments and then combine in a handy way without an external library for that little task
10:24:57 <ongy> tfc: do you know the string compile time? you could make it something like \arg1 arg2 -> concat ["This is my ", arg1, " string I want to format: ", arg2]
10:27:00 <mizu_no_oto_work> or even \arg1 arg2 -> "This is my " <> arg1 <> "  string I want to format: " <> arg2
10:29:43 <tfc> ongy yes, this is what i am doing now, but i don't like it and i wondered if there is any haskell magic for that. :)
10:31:13 <ongy> not that I know of at least
10:34:37 <tfc> ongy just learned how to build fancy applicative parsers on the fly. i am still new to this, but now on every corner i see optimization potential (in sight of code expression length) in my code. :D
11:02:04 <tikhon> Does anyone here have experience with Haskell Kafka clients? I found a couple of options (haskakafka and milena), and I'd love to hear about how these libraries play out in practice.
11:08:28 <ThomasLocke> What exactly does -threaded do when added to ghc-options in my cabal file?
11:08:44 <ongy> compile the application with the threaded rts
11:09:06 <ThomasLocke> Right now I have this: -Wall -threaded -rtsopts -with-rtsopts=-N but I'm not sure exactly what -threaded and rtpsopts do
11:09:20 <ph88> hello
11:09:54 <ThomasLocke> ongy, OK, so does that mean that the runtime then automatically figures out how many cores are on the system where the program runs?
11:10:23 <ph88> how can i use if-then in a do-block?  https://paste.fedoraproject.org/550018/64081471/
11:12:03 <ongy> I'm not quite sure about the -N flag and what it does without a number
11:12:05 <dmwit> ThomasLocke: -with-rtsopts=-N does that part
11:12:14 <ThomasLocke> I think I just found the answer... -N apparently lets the runtime decide for itself.
11:12:28 <ThomasLocke> dmwit, Yes.
11:12:50 <ThomasLocke> So -threaded and -N sorta/kinda goes hand in hand, yes? Or am I missing something?
11:12:57 <dedgrant> ph88 See Control.Monad.when  (https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Monad.html#v:when)
11:13:05 <dmwit> ThomasLocke: They are useful together, yes.
11:13:19 <ph88> thank you dedgrant :)
11:13:22 <ThomasLocke> -threaded is about concurrency and -N about parallelism
11:13:42 <ThomasLocke> Does that sound about right?
11:14:03 <dmwit> I don't think so. -threaded is about whether parallelism is available at all. (Concurrency is always available.)
11:14:17 <ThomasLocke> dmwit, I see. 
11:15:22 <dmwit> -N is about how many OS threads the runtime system starts with to implement concurrency and parallelism with.
11:15:24 <ThomasLocke> So projects that set neither -threaded nor -N in the cabal file, might be doing something in the source itself with GHC.Conc.setNumCapabilities and similar?
11:15:45 <dmwit> I don't think setNumCapabilities does anything in the non-threaded runtime.
11:15:54 <dmwit> (i.e. when the program is compiled without -threaded)
11:16:25 <dmwit> ThomasLocke: You might like http://dmwit.com/gtk2hs (ignoring the gtk-specific bits).
11:17:03 <dmwit> Skip "Best Practice" and "The Guts", I guess. The rest is going to be right up your alley.
11:18:50 <ThomasLocke> dmwit, Thanks. I'll take a look.  :o)
11:19:18 <Tuplanolla> Why does `Network.Socket` have a huge swathe of address families in `Family`, but `SockAddr` has only four constructors?
11:20:27 <Tuplanolla> They seem to only cover `AF_UNIX`, `AF_INET`, `AF_INET6` and, for some reason, `AF_CAN`.
11:21:23 <dmwit> This comes up often enough that I should really split this out into two posts, one about Haskell's threading model and one about gtk2hs.
11:28:58 <ph88> dedgrant, could you tell me what i'm doing wrong here with using when? https://paste.fedoraproject.org/550027/40931214/
11:30:23 <ph88> ups, i put the import in the wrong file -___-
11:31:03 <newbie__> hello, folks! I have a question about control characters in Haskell
11:31:31 <newbie__> Currently working through Professor Hutton's Programming in Haskell, and there are examples where control characters like \DEL etc are used
11:31:56 <newbie__> but they don't seem to be working for me :(  ... I am using getChar to read in the character... any idea what could be wrong?
11:32:45 <ph88> is there a shortcut function to do   return ()  ?    https://paste.fedoraproject.org/550030/14864095/
11:33:39 <ph88> newbie__, maybe you can use the ord function and see which code your character has
11:34:05 <newbie__> ph88 let me try that and get back!
11:34:20 <ph88> https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Char.html#v:ord
11:36:41 <newbie__> ph88 I can't seem to be able to print it out (I'm doing:                    c <- getChar                    putStrLn ("code = " ++ (show (ord c))) inside a do block
11:36:44 <newbie__> is that correct?
11:37:03 <newbie__> I instead get the ASCII code for return since it looks like getChar is waiting for the enter key for me
11:37:30 <Tuplanolla> Hint, newbie__: `hSetBuffering stdin NoBuffering`.
11:39:09 <newbie__> Tuplanolla That gives me code 27 when I use runghc ... okay, some progress! :D
11:39:24 <Tuplanolla> > chr 27
11:39:28 <lambdabot>  '\ESC'
11:39:53 <newbie__> okay, it works in ghci as well as using runghc!
11:40:23 <newbie__> I'm on a macOS box... is that causing that ASCII code?
11:40:23 <ph88> Tuplanolla, could you take a look at my code please ?
11:40:49 <ph88> what you mean causing the ascii code ?
11:41:06 <newbie__> I'm new to mac.. is \ESC the same as the DEL key?
11:41:09 <Tuplanolla> Okay. What's the issue, ph88?
11:41:39 <newbie__> I'm using a third party keyboard with my mac... maybe the bindings are wrong? I'll check using the laptop keyboard and see
11:41:42 <ph88> newbie__, hhmm ye interesting question .. i'm not sure if all the keys get mapped to ascii actually .. but for sure they have _some_ code
11:41:54 <ph88> Tuplanolla, https://paste.fedoraproject.org/550030/14864095/
11:42:07 <Tuplanolla> I'm already looking at it, ph88.
11:42:27 <ph88> eh it's a bit outdated paste, line 8 is already solved
11:42:55 <newbie__> ph88 yup... using my laptop keyboard, I get code 127 which appears to be the code for delete
11:42:57 <newbie__> :-)
11:43:04 <newbie__> Thanks, ph88, Tuplanolla!
11:43:06 <ph88> nice
11:43:29 <Tuplanolla> I guess you want `void $ M.lookAhead $ c [e delimitersNl]`, ph88.
11:44:39 <ph88> Tuplanolla, when i use void can  M.lookAhead $ c [e delimitersNl]  still fail and terminate the do-block ?
11:45:04 <Tuplanolla> Yes.
11:45:19 <Tuplanolla> @src void
11:45:19 <lambdabot> void = fmap (const ())
11:46:30 <sternmull> just out of curiosity: Is there a way to ask ghci or something else for the type of local bindings in a function?
11:46:34 <ph88> Tuplanolla, i made this out of it  M.lookAhead $ c [void $ e delimitersNl, M.eof]  because i noticed that eof was already returning ()  so i couldn't it together with e delimitersNl !
11:46:40 <ertes> (hint: (() <$) works without imports)
11:46:50 <ertes> :t (() <$)
11:46:52 <lambdabot> Functor f => f b -> f ()
11:47:21 <ph88> sternmull, what i know is that you can put the function to top-level and also put in a function signature with a type hole    sternmull :: _
11:47:56 <ertes> sternmull: use a hole
11:47:57 <ph88> ertes, lol .. i was using  () $>  myself but then i got a ton more errors .. but i didn't know i was that close !
11:48:03 <monochrom> that also works in local bindings
11:48:25 <monochrom> > let {f = 1; f :: _} in f + length []
11:48:29 <lambdabot>  error:
11:48:29 <lambdabot>      • Found type wildcard ‘_’ standing for ‘Int’
11:48:29 <lambdabot>        To use the inferred type, enable PartialTypeSignatures
11:48:33 <sternmull> ph88, ertes: Thanks. Will check that out.
11:48:50 <ertes> (note: partial type signature ≠ typed hole)
11:48:54 <ertes> and both work
11:49:56 <monochrom> Evidently, I am abusing PartialTypeSignatures without turning on PartialTypeSignatures to trick the compiler into teaching me type inference. It's a side effect. :)
11:50:15 <ertes> a useful one, too =)
11:50:43 <monochrom> Use "_ :: _" to trick the compiler into teaching you Haskell programming!
11:51:05 <koala_man> hahaha
11:51:40 <takle> Question: Why would one write a `case` as in the last example here https://lotz84.github.io/haskellbyexample/ex/switch
11:52:09 <EvanR> got a reference to a book which arrived today, huzzah: http://i.imgur.com/OwULUsA.jpg (From Frege to Godel: A sourcebook in mathematical logic)
11:52:36 <EvanR> the cover is quite ominous
11:56:05 <jarlg> Anyone got a good reference on (Lazy) ByteStrings?
11:58:53 <jarlg> Or, is there any required reading for understanding their implementation?
12:01:28 <EvanR> lazy ByteStrings are just lazy lists of strict bytestring chunks
12:01:45 <EvanR> internally
12:02:08 <EvanR> they are conceptually processed exactly as lazy lists would be
12:02:24 <EvanR> in haskell "list" is synonymous with lazy list
12:02:46 <EvanR> so perhaps read up on that topic?
12:03:59 <jarlg> EvanR: First I want to understand the difference between ByteString and [Word8], and then understanding lazyness/chunking I'll get lazy ByteStrings as well, right?
12:04:27 <EvanR> [Word8] is the type of lazy lists of Word8s, single bytes
12:04:32 <ertes> jarlg: the difference is the existence of toChunks and fromChunks
12:04:45 <EvanR> they take up more space and are slower than ByteStrings which are packed vectors of bytes
12:04:54 <ertes> other than that lazy ByteString and [Word8] are pretty much equivalent
12:05:18 <ertes> in terms of semantics…  efficiency is of course an entirely different story
12:06:02 <ertes> in terms of efficiency it's best to think of lazy ByteString as [Data.ByteString.ByteString], which is reflected by fromChunks and toChunks
12:06:13 <EvanR> theyre not equivalent in terms of efficiency or semantics
12:06:21 <EvanR> list of bytes vs list of bytevectors
12:06:48 <jarlg> What's a "packed vector" and a "bytevector"?
12:06:53 <EvanR> fromChunks and toChunks converts between the two kinds of ByteStrings, does not involve [Word8]
12:07:04 <ertes> jarlg: ByteString
12:07:13 <ertes> the strict one that is
12:07:18 <EvanR> jarlg: behind the scenes its an array of raw bytes in memory, more efficient space-wise
12:07:22 <jarlg> ertes: I'm trying to understand ByteString ;)
12:07:35 <EvanR> in haskell you just know its an abstract data type
12:07:43 <ertes> jarlg: a strict ByteString is an array of Word8
12:07:50 <EvanR> you arent given the constructor for ByteString 
12:08:00 <ertes> jarlg: "array" as in a continuous region in memory
12:08:34 <ertes> jarlg: in haskell we also say "vector" to talk about arrays, mainly because of the 'vector' library, which uses that terminology
12:08:43 <ertes> but it's unrelated to ByteString
12:09:01 <EvanR> the word "vector" is common when talking about arrays in lisp
12:09:20 <EvanR> for some reason
12:09:57 <reactormonk> Not sure if I can do the req/req2/req3 in a nicer way - http://lpaste.net/352148
12:11:37 <ertes> reactormonk: you could give (maybeModify hostL hostLens uri) a name, but i wouldn't…  at some point extra names only introduce extra indirection, which makes code more difficult to read
12:12:16 <ertes> reactormonk: in fact i'd even question the utility of maybeModify (which you can write more nicely), but it's not too bad
12:12:18 <jarlg> EvanR, ertes: Thanks! I guess reading up on laziness is a good start to understanding it all better.
12:12:44 <k0ral> Hello guys
12:15:53 <reactormonk> ertes, more nicely? How?
12:24:40 <EvanR> jarlg: yeah, its kind of a brain explosion at first. but eventually it will make way more sense than eager-everything
12:31:24 <BernhardPosselt> just trying to dive a bit into haskell by implementing show for a custom type structure, but this wont compile http://dpaste.com/00NTN80
12:31:57 <BernhardPosselt> thats the error https://dpaste.de/H3EB
12:32:20 <BernhardPosselt> do i need to tell the compiler that a can be shown?
12:33:44 <EvanR> instance show (Tree a) where
12:33:49 <EvanR> i would guess is the issue
12:33:56 <chef_excellence[> you call show for values of type a
12:34:09 <chef_excellence[> you can fix this by adding Show a =>
12:34:28 <EvanR> instance Show a => Show (Tree a) where
12:34:34 <chef_excellence[> instance Show a => Show Tree where ...
12:34:39 <BernhardPosselt> right that was the issue
12:34:45 <chef_excellence[> * Tree a
12:34:51 <BernhardPosselt> when do i need to use ()?
12:35:24 <EvanR> Show Tree a is parsed as (Show Tree) a
12:35:31 <EvanR> but Show takes only one argument
12:35:35 <ertes> reactormonk: (f = \x y -> …) can be written as (f x y = …)
12:35:36 <BernhardPosselt> i see
12:35:48 <EvanR> some classes take more than one argument
12:35:58 <EvanR> like Convertible a b
12:36:22 <sternmull> i think its the same paring rule as for calling functions
12:36:38 <sternmull> s/paring/parsing/
12:36:59 <ertes> reactormonk: there is only one (very unfortunate) exception to that rule:  you can't use that syntax in fields:  A { field1 x = … }  -- not allowed
12:37:14 <ertes> reactormonk: but in 'let' and 'where' it's generally allowed
12:40:14 <BernhardPosselt> do also have to take care of that when pattern matching?
12:40:16 <BernhardPosselt> e.g.
12:40:21 <BernhardPosselt> show (Node left value right)
12:40:27 <BernhardPosselt> instead of show Node left value right
12:42:01 <chef_excellence[> jup
12:47:16 <BernhardPosselt> ok, a bit further :) http://dpaste.com/1P3Z4SW
12:47:23 <BernhardPosselt> Ambiguous type variable ‘a0’ arising from a use of ‘show’  prevents the constraint ‘(Show a0)’ from being solved.
12:47:31 <BernhardPosselt> why does this happen?
12:48:08 <BernhardPosselt> isnt a a type that is required to implement Show when looking at the constraint?
12:48:45 <hexagoxel> BernhardPosselt: compiler does not know which dictionary not to use there :)
12:49:31 <BernhardPosselt> dictionary?
12:49:42 <EvanR> BernhardPosselt: when you see ambiguous type error, it means inference cant know which type you want, and it matters which one you pick
12:49:54 <EvanR> > read "()" :: ()
12:49:57 <lambdabot>  ()
12:50:03 <EvanR> > read "5" :: Int
12:50:06 <lambdabot>  5
12:50:11 <EvanR> > read "()" :: Int
12:50:13 <lambdabot>  *Exception: Prelude.read: no parse
12:50:45 <BernhardPosselt> is it because i only use Nil?
12:50:52 <Xnuk> > readMay "()" :: Maybe ()
12:50:55 <lambdabot>  error:
12:50:55 <lambdabot>      Variable not in scope: readMay :: [Char] -> Maybe ()
12:50:59 <BernhardPosselt> so the compiler can not deduce the type for the second show clause?
12:51:06 <BernhardPosselt> deduct*
12:52:08 <BernhardPosselt> putStrLn $ show (Node Nil 5 Nil) 
12:52:09 <BernhardPosselt> works
12:52:20 <BernhardPosselt> so i guess thats the issue
12:52:42 <EvanR> BernhardPosselt: putStrLn . show = print
12:52:46 <hexagoxel> BernhardPosselt: yeah, pretty much. It could be any a, so it does not know which (Show a) dictionary to use.
12:53:28 <hexagoxel> and the second show clause is even relevant, the (Show a) => .. part is.
12:54:10 <reactormonk> ertes, neat, good to know, thanks.
12:54:17 <hexagoxel> although only the second class that does use the dictionary, of course. but if it did not, and you still had the Show a, you'd still have the same problem.
12:54:19 <dolio> It won't choose one for you for `Show a`. The reason why putting the 5 in work is that it will choose something for `Num a`.
12:54:20 <sternmull> BernhardPosselt: When you give the compiler a "Nil" then you use a constructor where the typ "a" is not bound to anything. So he can not know what kind of Tree that should exactly be. And it needs that information to know what to do for the second show implementation.
12:54:39 <BernhardPosselt> what happens if you want to write a library?
12:54:58 <BernhardPosselt> do you need to add generic type signatures?
13:02:03 <BernhardPosselt> ok got it :)
13:02:08 <BernhardPosselt> works just fine without usage
13:02:11 <BernhardPosselt> putStrLn $ show (Nil :: Tree String)
13:03:27 <hexagoxel> > show []
13:03:30 <lambdabot>  "[]"
13:05:37 <barrucadu> How come that works? Defaulting rules?
13:05:48 <hexagoxel> this works due to defaulting. i think you could add a defaulting declaration for Tree (), but i don't think it is common to do that.
13:05:59 <EvanR> > read "[()]"
13:06:02 <lambdabot>  *Exception: Prelude.read: no parse
13:06:29 <EvanR> doh
13:06:55 <EvanR> hexagoxel: defaulting of what class?
13:07:16 <hexagoxel> > map id (read "[()]")
13:07:18 <lambdabot>  [()]
13:08:07 <hexagoxel> needs to know that it is [_] at least :)
13:08:36 <BernhardPosselt> regarding the deriving stuff: does this work similar like Rust's derive attribute/macro? e.g. #[derive(Debug)]
13:09:02 <BernhardPosselt> #[derive(Show)]
13:09:08 <BernhardPosselt> its even the same name :D
13:09:26 <EvanR> having to derive Show is really annoying, its often the only thing i derive
13:09:33 <EvanR> i wish it was automagic
13:09:45 <EvanR> at least for types that make sense
13:09:47 <BernhardPosselt> does it use macros internally?
13:09:52 <EvanR> but possibly for types that dont make sense
13:09:53 <BernhardPosselt> to generate code?
13:10:06 <EvanR> no, its built into the language
13:10:39 <EvanR> there are no macros, but there is template haskell
13:17:00 <hexagoxel> ah, the reason show [] works is because of ExtendedDefaultRules, not because of anything []-specific.
13:17:13 <hexagoxel> and show Nil would work with Extended~.
13:17:19 <hexagoxel> (right?)
13:17:27 <dolio> Yes.
13:20:52 <urban24> Hi, getting the wronh sha when donloading
13:21:02 <urban24> 0124399b1bbad2e5f615dbccc49df69db02fbe37d9e500378b59101c244b41e1  haskell-platform-8.0.2-unknown-posix--full-x86_64.tar.gz
13:21:25 <urban24> from https://www.haskell.org/platform/#linux-generic
13:22:38 <ph88> hey guys, i'm making a parser and i have a rule for  Identifier  this should be followed by whitespace depending on the context where Identifier is used. Should i store the whitespace in the context? I think if i put the whitespace with the Identifier that it will cause problems when i start moving Identifier's around and place them in new contexes
13:22:50 <urban24> web page say:   c68a6f278a192d5000e8feefb0e63cef1bd441d02b84602984
13:23:14 <dolio> urban24: Your hash looks longer.
13:23:29 <ph88> before i was storing all the whitespace after a token in the type of that token itself .. now i'm breaking this pattern and it feels a bit strange
13:23:29 <dolio> Maybe it's a different hash?
13:24:05 <urban24> it should be a sha256
13:24:08 <hexagoxel> website says c68a6f278a192d5000e8feefb0e63cef1bd441d02b846029840b98a5fa3ee31a; it does some bad linebreak.
13:24:52 <urban24> ahh, missed the page brake, sorry
13:25:18 <urban24> but it's still not the same :-(
13:25:39 <qmm> where would hoogle be installed if i ran `cabal install hoogle`?
13:25:51 <qmm> i've ran this, but i don't see a ~/.cabal/bin dir
13:25:58 <hexagoxel> urban24: i see the same hash as you. maybe ask in #haskell-infrastructure too.
13:26:11 <urban24> ok, thanks
13:28:03 <geekosaur> qmm, did you install it in a sandbox? if so, it's in the sandbox bin directory (.cabal-sandbox/bin iirc)
13:28:27 <qmm> geekosaur: i wish i did
13:28:34 <qmm> there isn't a .cabal-sandbox/bin
13:29:10 <qmm> nor a .cabal-sandbox
13:29:13 <BernhardPosselt> when pattern matching in haskell, is there a way to refer to a container? e.g. show (Node left value right) basically extracts left, value and right, but how do i get the whole thing inside the parenthesis?
13:29:32 <geekosaur> BernhardPosselt, somename@(...)
13:29:40 <geekosaur> "as-pattern"
13:29:42 <BernhardPosselt> ty
13:39:59 <BernhardPosselt> is there a built in way to find the first Just a in a list of Maybe a?
13:40:20 <BernhardPosselt> or Nothing if everything in the list is Nothing
13:40:46 <BernhardPosselt> i've found find but i dont really know how to define the predicate
13:40:57 <kadoban> I think that's   listToMaybe . catMaybes
13:41:00 <nil_> I think you can do it using Alternative
13:41:46 <jle`> BernhardPosselt: there's asum
13:41:48 <dmwit> :t find
13:41:49 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
13:42:00 <jle`> > asum [Nothing, Nothing, Just 10, Nothing, Just 20]
13:42:03 <lambdabot>  Just 10
13:42:10 <BernhardPosselt> ty
13:42:15 <jle`> also `foldMap First` i suppose
13:42:26 <jle`> > foldMap First [Nothing, Nothing, Just 10, Nothing, Just 20]
13:42:29 <lambdabot>  First {getFirst = Just 10}
13:42:29 <dmwit> jle`++
13:42:54 <jle`> BernhardPosselt: no problem!
13:43:09 <BernhardPosselt> asum as in alternative sum?
13:43:21 <pikajude> :t asum
13:43:23 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
13:43:39 <nil_> jle`: nice!
13:43:41 <jle`> BernhardPosselt: yeah, sum [x,y,z] = x <|> y <|> z <|> empty
13:43:44 <pikajude> incidentally, i use Dash the osx documentation browser for searching haddocks on mac, but i've found no comparable solution on linux
13:43:50 <pikajude> does anyone have a recommendation?
13:43:54 <jle`> so it's like mconcat, but wiht <|> instead of <>
13:44:38 <jle`> a lot of people believe that Maybe's Monoid instance should really be <|>/Firsty ... if that was teh case you could have just done 'mconcat'
13:45:17 <pikajude> does that fulfill the laws?
13:45:28 <jle`> yup, there's actually a newtype wrapper that providesthat instance, First
13:45:37 <dmwit> :t getAlt . foldMap Alt
13:45:40 <lambdabot> forall k (f :: k -> *) (a :: k) (t :: * -> *). (Monoid (Alt f a), Foldable t) => t (f a) -> f a
13:46:07 <dmwit> the uglier spelling of asum =P
13:46:31 <jle`> haha
13:46:54 <jle`> :t ala Alt foldMap
13:46:56 <lambdabot> forall k (t :: * -> *) (g :: k -> *) (b :: k). (Monoid (Alt g b), Foldable t) => t (g b) -> g b
13:54:30 <AWizzArd> What is the style in which Haskell apps for production are typically written? I am coming from Clojure/Lisp, and there development mostly takes place in the repl. Patches are for some applications applied while it is running.  Is Haskell mostly edit/compile/run?
13:55:03 <BernhardPosselt> AWizzArd: i suppose people use some form of tdd
13:57:38 <dmwit> I use the REPL for a lot of stuff. I use compile/run for a lot of stuff, too.
13:58:36 <AWizzArd> dmwit: I imagine that if the program gets bigger that compile times increase.
13:58:56 <dmwit> Usually not much. GHC is pretty good about only recompiling files that changed.
13:59:01 <ongy> they do, but ghc is pretty good with incremental builds
13:59:09 <AWizzArd> Ah okay, good, that makes sense.
13:59:20 <dmwit> And most development time is spent at the leaves of the project, not the core files that force everything to get rebuilt.
14:02:57 <jle`> i usually edit with a repl open to test my changes immediately
14:06:09 <monochrom> I can understand why and how one would write millions of lines of Lisp code at a REPL prompt. Because most Lisp REPLs come with a "save heap as exe" command. (In fact likely the only way to obtain an exe.)
14:06:33 <monochrom> Such messy magic is not replicated in the Haskell world. Nor even the Python world.
14:06:38 <HaskellLord69> is there a way to see the type of a variable by hovering over it with the mouse in emacs/spacemacs?
14:07:10 <mahmoudgebril> 9 11 attacks, Did USA do it itself or it just let it happen?
14:07:10 <mahmoudgebril> Did USA administration murder 3000 American citizen in 9 11 attacks to justify starting a war against iraq?
14:07:10 <mahmoudgebril> If al-qaeda did it, why go to kill 2 million Iraqi?
14:07:10 <mahmoudgebril> http://creatvchaos.blogspot.com.eg/   
14:07:10 <mahmoudgebril> https://creatvchaos.wordpress.com/
14:07:10 <mahmoudgebril> Some of the benefits Americans say they achieved after 9 11 attacks include:
14:07:10 <mahmoudgebril> *constant flow of oil, which price is in continuous decline. Trump said he will simply take the Iraqi oil, and when he was told that Iraqi oil belongs to iraq he said there is no iraq(after usa destroyed it ).
14:07:11 <mahmoudgebril> *Invasion of afghanstan with construction of not less than 14 american military base which give a close eye on china.
14:07:11 <mahmoudgebril> *Removal of potential threat to isreal represented in iraq which throw isreal with more than 30 rocket after American assault on iraq during 2nd gulf war.
14:07:39 <EvanR> linking times are still kind of a 
14:08:14 <Tuplanolla> Usually it's edit-compile-edit-compile-edit-compile-run instead of edit-compile-run though, AWizzArd.
14:08:42 <ongy> Tuplanolla: you mean, edit, typeerror, edit typeerror, edit typeerror, edit compile run?
14:08:52 <Tuplanolla> Yes.
14:09:34 <monochrom> But even the 2nd most advanced Lisp REPL would fail on the question "now how do I edit code I wrote 5 power cycles ago?"
14:09:43 <Tuplanolla> Many people like to offload compilation to a daemon like `ghcid` too, so for you it's mostly edit-edit-edit-run.
14:10:02 <monochrom> (The 1st most advanced one addressed this by being a full-fledged editor itself --- emacs.)
14:10:13 <xcmw> Is it possible to use stack with ghc head (8.1)?
14:10:44 <monochrom> So basically REPL programming doesn't scale and is a dead end. You need to grow out of it.
14:12:09 <AWizzArd> monochrom: it may depend on the situation. We have a server app that has a long startup time. Several times a day I make small fixes/additions and just load the updated file.
14:13:43 <mizu_no_oto_work> monochrome: repl-driven-development in Haskell typically uses ':r' in ghci a lot. 
14:14:17 <monochrom> Sure. By my "REPL programming" doesn't mean that.
14:14:21 <mizu_no_oto_work> monochrom: i.e. edit/reload in repl/interact
14:14:42 <monochrom> s/By/But/
14:16:20 <mizu_no_oto_work> AWizzArd: when you say "development mostly happens in the REPL", do you mean that you write code in a file, reload it in the repl, test it by hand, and upload it to a running app?
14:16:43 <hexagoxel> what kind of equality is used in type class laws?
14:16:53 <monochrom> mathematical equality
14:17:30 <monochrom> most often it comes down to "are the same under the usual denotational semantics" if you want more detail.
14:17:53 <dolio> Or whatever semantics you care about.
14:17:58 <Tuplanolla> This is sometimes called judgmental equality, no?
14:18:00 <AWizzArd> mizu_no_oto_work: typically when writing new functions I start doing this in the repl. Or I write them in a file and load them. This is what I do in Lisp/Clojure, but also with my tiny Haskell programs that I’m developing.
14:18:37 <NemesisD> hi yall. I have what's essentially an Acquire (IO (Maybe a)) that i'm trying to rig up to a conduit so that it yields every a. The problem is that Acquire requires you to either have MonadMask or MonadBaseControl which aren't available for conduit
14:18:39 <mizu_no_oto_work> AWizzArd: after you write and test a bit, thought, you copy/paste it to the file?
14:18:56 <AWizzArd> mizu_no_oto_work: about a running app: hundreds of files are loaded. I change one function locally on my dev system, and call the updated fn to see that it works. I then push the patch and pull it on the server. There I reload the file. This overwrites the old function definition with the new one.
14:19:14 <NemesisD> is there any sort of ContT or some other trick i can do to in IO get each element and then pass it to conduit's yield? Right now I use a TBMQueue and a separate thread which seems pretty horrible
14:19:38 <AWizzArd> mizu_no_oto_work: yes. In the repl I not necessarily write the function, but call it a few times, to see how it behaves. This is also what I do in Haskell. I write it in Emacs and call it in the ghci repl.
14:19:50 <dolio> Judgmental equality has to do with the formalism of type theory, and may not correspond to what people care about in type classes.
14:20:02 <jophish> is Gabriel on IRC?
14:20:22 <NemesisD> to use Acquire i have to use with :: MonadBaseControl IO m => Acquire a -> (a -> m b) -> m b. M is IO so I can't see how to use that and call yield within the continuation since m is IO
14:20:25 <monochrom> This sounds like two separable concerns. How to create a file, and how to tell the server to hot-swap a file.
14:20:30 <AWizzArd> mizu_no_oto_work: and in the Lisp app: all data is untouched. Just the old function is replaced by the new one, the server continues to work, and users don’t notice that anything got updated. They only see that there is new functionality.
14:21:06 <dolio> For instance, the formalism of something like Haskell wouldn't ever need to make reference to term equality.
14:21:26 <mizu_no_oto_work> AWizzArd: Yeah, I think that's a really common development workflow in Haskell.  Hot swapping code isn't related to the REPL in Haskell, though.
14:21:54 <dolio> Although it might define some compute rules which give rise to 'equal' terms, but even then that might not be the equality you care about.
14:22:08 <EvanR> is judgmental equality the same as term equality is the same as definitional equality is the same as computational equality
14:22:29 <AWizzArd> mizu_no_oto_work: I will have to get used to implement the program in such a way that the current app state can be reconstructed quickly when the app is restarted. Also will have to think about how to restart without downtimes.
14:22:46 <AWizzArd> But till I can do this I will continue my basic Haskell studies (:
14:22:55 <Tuplanolla> Throw propositional equality to the mix too, EvanR.
14:23:11 <dolio> Judgmental equality is the stuff that look like `Gamma |- X = Y` in your type theory.
14:23:27 <dolio> Or `Gamma |- X = Y : T` possibly.
14:23:53 <dolio> The judgments that two things are equal according to the theory.
14:23:56 <hexagoxel> i wonder if i am supposed to have any idea what "mathematical equality" means.
14:24:54 <monochrom> It is natural to not know. Because the mathematicians never spelt it out, but apparently they still manage to have an impressive consensus.
14:25:51 <monochrom> This is why I then had to augment with "use a denotational semantics".
14:27:09 <hexagoxel> "mathematical equality" sounds to me like it does not care what stuff is exposed by my modules. but denotation semantics would care about what constructs you expose, wouldn't it?
14:27:19 <mizu_no_oto_work> AWizzArd: In Haskell apps, state would usually be stored externally to the code.
14:27:26 <hsk3> Honest question. We have Stack scripts, https://haskell-lang.org/tutorial/stack-script
14:27:26 <hsk3> So why would I ever again want to write Bash scripts?
14:28:05 <mizu_no_oto_work> AWizzArd: e.g. in a database or something
14:28:37 <monochrom> No, it sounds like both are about what you expose.
14:28:52 <sm> hsk3: for situations when installing/using stack & haskell is considered a burden
14:28:55 <AWizzArd> mizu_no_oto_work: of course, in Lisps this is the same. But when the app starts it will fetch hundreds of megabytes of data in order to not have to contact the db for future requests.
14:29:10 <monochrom> Take for example Data.Ratio. What does it mean for 2%3 and 4%6 to be "equal"?
14:29:13 <hsk3> sm, yes that's the only situation i can imagine :)
14:29:20 <sm> I'm loving them too
14:29:42 <AWizzArd> mizu_no_oto_work: if you need 20 mins time to fill the cache you don’t want to restart your app often.
14:30:02 <mizu_no_oto_work> That's what something like redis is for.
14:30:48 <sm> hsk3: also, when haskell is just too verbose. They do tend to have relatively high boilerplate for small scripts
14:30:58 <hsk3> true
14:31:06 <hexagoxel> monochrom: ok, that makes sense, thanks.
14:31:12 <monochrom> I deplore stack scripts. Why should I download GHC one more time just to print "hello world".
14:31:23 <AWizzArd> mizu_no_oto_work: sure, but it didn’t exist in 2004.
14:31:33 <monochrom> (And yes stack always downloads GHC one more time than I like.)
14:31:44 <sm> which is unfortunate. We could reduce that boilerplate a bit
14:33:35 <barrucadu> hsk3: My main use of shell scripting is for things which are mostly a sequence of invocations of other programs. Pretty much every language is significantly more verbose than the shell for that.
14:33:35 <AWizzArd> mizu_no_oto_work: also, our system requires tens of thousands of templates to be in memory, to check if we match against them. It’s by far too slow to have something like Redis in between.
14:33:53 <hsk3> barrucadu good point
14:34:16 <hsk3> so i guess i have to learn bash scripting after all lol
14:34:29 <barrucadu> Which makes sense. The shell, despite all its problems, is a pretty good DSL for chaining other programs together.
14:34:48 <maksim_> can someone help me with this http://pastebin.com/vM6yk5HZ
14:35:07 <maksim_> this is cabal.config https://github.com/databrary/databrary/blob/master/cabal.config
14:35:15 <maksim_> and my cabal file https://github.com/databrary/databrary/blob/master/databrary.cabal
14:35:28 <sm> monochrom: I think that was rhetorical, but your hello world script will of course in time grow into a bug-ridden monster requiring expensive specialist bash knowledge your team does not have in house  :)
14:36:32 <barrucadu> sm: I like to avoid the "in time" and jump straight to writing scripts requiring specialise zsh knowledge.
14:37:16 <monochrom> No, runghc scripts and runhugs scripts would do fine when that happens.
14:37:23 <maksim_> i don't understand why file-embed 0.0.9.1 doesn't satisfy the constraints
14:37:47 <sm> a stack script just adds the ability to depend on packages besides base
14:38:25 <sm> which is quite a big deal actually
14:38:56 <kadoban> And removes the requirement that users always have the correct version of GHC themselves and etc. Though I'm not sure I'd really deploy a script like that to most users.
14:42:14 <sm> stack scripts don't have to install GHC, of course. It's configurable.
14:43:21 <AWizzArd> The Learn You A Haskell book says “Therefore, doing fmap (*) (Just 3) results in Just ((*) 3), which can also be written as Just (* 3) if we use sections.”   – shouldn’t it be   Just (3 *)   instead?
14:43:43 <Tuplanolla> Yes, AWizzArd.
14:44:09 <AWizzArd> k
14:44:53 <Tuplanolla> Generally though people assume `*` to be symmetric.
14:46:18 <AWizzArd> Tuplanolla: Yes. If  /  were used though…
14:47:30 <geekosaur> maksim_, it's badly phrased (but that's likely impossible to handle in any sane way) but I suspect some dependency in cabal.config requires file-embed-0.0.10 and that's being shown as if you had that in cabal.config directly
14:48:21 <ertes> what's a good name for an immutable reference?  like a read-only IORef (its value can change, but only through external means)
14:49:11 <ertes> not really "immutable", but "read-only"
14:50:37 <dolio> CoYoneda IORef
14:51:44 <Tuplanolla> Just `Ref`?
14:52:01 <jle`> ROIORef
14:52:04 <ertes> dolio: close =)
14:52:33 <ertes> Tuplanolla: yeah, but unfortunately there is already a 'ref' library =)
14:52:37 <ertes> and yes, 'var' is taken, too =)
14:52:44 <Tuplanolla> Then `PureRef`?
14:53:32 <jle`> Source?
14:53:42 <codedmart> I am trying to understand how `pool` works. I am using it now, but what I am wondering is the difference between `withResource` and `takeResource`. My issue is that I have a long waiting blocking process that I run with my db, but the thread seems to die after one thing happens with the db.
14:53:51 <sjpet> Hello. If I have declared 'data Fluff = Foo String Int | Bar String Char', is there a one-liner (i.e. without pattern matching either constructor specifically) way of writing a function 'fluffLength :: Fluff -> Int' returning the length of the string?
14:53:56 <jle`> a read-only IORef could be a Source and a write-only IORef could be a Sink
14:54:15 <sjpet> it would seem _ does not work for data constructors
14:54:24 <ertes> hmm
14:54:27 <ertes> i'm inclined to call it Behaviour
14:54:28 <jle`> sjpet: there isn't quite a way that's built into the language
14:54:48 <jle`> well
14:54:57 <jle`> you could use record fields, but that's probably not ideal here
14:55:13 <jle`> might as well use something like getFluffString :: Fluff -> String
14:55:23 <jle`> and then use that for your fluffLength function
14:55:38 <sjpet> but then I'd have the same problem with getFluffString
14:55:42 <jle`> there are some libraries (like lens) that could use metaprogramming to generate getFluffString for you automatically
14:55:47 <jle`> sjpet: yeah, but at least you isolate the problem
14:55:53 <sjpet> yeah, it's something
14:56:07 <jle`> and you only would have to write it once
14:56:59 <sjpet> but perhaps there is a better way of classifying about a dozen different types of strings then..
14:57:04 <Tuplanolla> You can `declareLenses` and then `length . view str`, sjpet.
14:57:24 <jle`> yeah, if lens is already in your project, you might as well leverage it to auto-generate your accessors there
14:57:42 <jle`> alternatively, you can be evil
14:57:53 <jle`> fluffLength (unsafeCoerce->(Foo s _)) = length s
14:57:58 <jle`> (don't do that)
14:58:14 <jle`> er wait
14:58:20 <jle`> that doesn't work, sorry
14:58:23 <Jinixt> you can't just hand out a chainsaw and then say "don't use it"
14:58:36 <Jinixt> someone's bound to lose a leg
15:00:35 <litho> does anyone know of a good example of an MTL style rest api package on hackage?
15:01:04 <sjpet> I'll have a look at lens. It's not in my project currently but it might be of use later. Thanks.
15:01:20 <Tuplanolla> Consider `microlens` if it's too much, sjpet.
15:02:48 <slack1256> TIL: you don't have to import a module in ghci if you are gonna use just a single function. Just qualiafy completely ie: Data.Foldable.foldmap works otb
15:03:34 <Koterpillar> slack1256: it still has to be loaded, in your case perhaps it was through another module in your project
15:04:08 <slack1256> damn right. the Turtle library did it :-S
15:16:30 <litho> what's the best approach for making a typeclass that associates 'constant' data for each type?
15:16:57 <Koterpillar> litho: like Data.Default?
15:17:35 <litho> sort of 
15:17:42 <litho> except that the 'default' value isnt polymorphic
15:18:11 <monochrom> If Data.Default doesn't solve your problem, you will have to explain your problem, because I certainly don't understand it otherwise.
15:18:11 <litho> right now I have a class with a function `class Resource a where prefix :: proxy a -> String`
15:18:49 <litho> this is for the purpose of an api client, end users need to give the client information on how to build the correct paths for their types in the API
15:19:18 <monochrom> I think I see. Better to make your own class.
15:19:24 <litho> I've done that
15:19:25 <maksim_> geekosaur, why doesn't it tell me exactly which
15:19:38 <litho> however it causes issues when I try to write the actual api functions in a polymorphic manner
15:19:50 <litho> since I can't build proxies out of scratch :P
15:20:10 <monochrom> You can use Data.Proxy (comes with GHC).
15:20:35 <litho> http://lpaste.net/352156
15:20:39 <monochrom> I would for example call your method in a way like "prefix (Proxy :: Proxy Int)"
15:21:17 <monochrom> But even Data.Proxy is not compulsory. You can define your own "data Me a = Me" and now you get to say "prefix (Me :: Me Int)" too. Same difference.
15:21:27 <litho> I posted an example lpaste with my issue
15:22:12 <monochrom> You need ScopedTypeVariables.
15:22:17 <litho> the issue is that I'd like to make polymorphic accessor functions like `getAllResources` which would return an `m a`
15:22:26 <litho> hmm I have it turned on but it didn't seem to do the trick
15:22:57 <lpaste> monochrom annotated “example problem ” with “example problem  (annotation)” at http://lpaste.net/352156#a352157
15:23:01 <monochrom> Like that.
15:23:17 <litho> ah i actually need to quantify a and m explicitly
15:23:18 <monochrom> You need to add some "forall"s.
15:24:00 <litho> wow thanks, I thought scoped type variables was the answer but never understood how it worked
15:24:12 <litho> didn't realize i needed explicit forall
15:26:36 <dmwit> litho: 
15:26:38 <dmwit> ?hackage tagged
15:26:38 <lambdabot> http://hackage.haskell.org/package/tagged
15:27:24 <litho> not exactly what I need but monochrom already helped me out
15:27:50 <dmwit> litho: ...as in `class Resource a where res :: Tagged a String`.
15:28:32 <litho> oh i get what you mean, yea that could simplify things further! thanks
15:29:44 <geekosaur> maksim_, I *think* this is because of shortcomings in the solver where it can't track the transitive deps properly for the purposes of error reporting. if your cabal is new enough, you could try cabal new-build (but that has its own bugs in released versions, you may need to install cabal-install from latest git)
15:32:56 <geekosaur> (if I understand (and remember) correctly, the old solver remembers the deps it needs, but for speed and simplicity doesn't track enough information to get back to exactly where each dep came from, it only knows where it started)
15:33:17 <maksim_> geekosaur, i'm doing this with stack
15:34:07 <geekosaur> oh, so Cabal library is losing here. although I think in that case you need more information; Cabal-the-library *will* get confused if stack feeds it conflicting information
15:34:26 <geekosaur> and your dependency may come from a stack resolver in that case
15:34:40 <geekosaur> (why do you have a cabal frozen deps file if you are using stack?) 
15:36:10 <maksim_> geekosaur, right you are that snapshot has file-embed-0.0.1.0
15:37:08 <tapirus> suppose I have a string input that is either "a_string 100" or "100 a_string", what's the proper way to parse that and store it as (100, "a_string") ?
15:40:10 <maksim_> geekosaur, but for some reason stack init --force --solver --omit-packages doesn't work either
15:42:11 <geekosaur> maksim_, I'm not a stack expert, someone else will have to help you from this point on. but I think if you need a specific version of something instead of getting it from the resolver, you need to specify that in stack.yaml
15:43:15 <geekosaur> maksim_, https://docs.haskellstack.org/en/stable/yaml_configuration/#extra-deps
15:47:49 <maksim_> geekosaur, yea i was thinking along those lines and those flags should generate a stack.yaml that omits the conflict but it's not working
15:47:51 <maksim_> but thanks
16:42:47 <erisco> why is "complement" so difficult to abbreviate
16:44:05 <hpc> ¬
16:44:15 <erisco> in an identifier
16:44:32 <erisco> that isn't unicode, I guess :P
16:44:40 <hpc> ;)
16:45:08 <erisco> a < b if and only if not b ≤ a (i.e., < is the inverse of the complement of ≤)
16:45:10 <hpc> i think sometimes ' can be used for complement
16:45:23 <hpc> like, the complement of foo is foo'
16:45:27 <erisco> yeah but inverse is in there as well :P I went with ltIsLeq''
16:45:34 <hpc> ah
16:45:38 <monochrom> perhaps "neg"
16:45:38 <erisco> trying to give little names to this zoo of axioms and theorems
16:51:03 <Ptival> is there any parsing solution that lets the parser be extended with notations at run-time? (something like notations in Coq/Agda/Idris?)
17:05:12 <ertes> Ptival: csvHeadLine :: Parser (Parser Row)  -- parse the head row and return a parser that parses future rows
17:05:24 <ertes> csvHeadLine >>= many
17:05:28 <ertes> something like that?
17:06:58 <Koterpillar> seems right; also, try and find out :P
17:27:57 <Ptival> well, I guess it could look like that, I was more thinking of an iterative process, where   addNotation :: Parser Thing -> Notation -> Parser Thing
17:28:14 <Ptival> but with heavy machinery :\
17:28:42 <ertes> StateT (F (Parser Thing)) Parser
17:28:46 <ertes> with a suitable F
17:30:04 <ertes> any monadic parser combinator library can treat parsers as first-class, so parsers can result in parsers, and those resulting parsers can be integrated for the remainder of the grammar
17:30:27 <Ptival> I mean, I'm sure I can write one, I was more interested in knowing if this whole business of adding notations with different precedences/associativity, and generating a parser/printer from the existing known notations, was somewhere to be found
17:30:53 <Ptival> but it seems everyone just writes their own
17:31:22 <ertes> megaparsec and trifecta have ready-made infix expression parsers
17:31:24 <Ptival> I was testing Boomerang, but it hangs on nothing but basic input
17:31:39 <ertes> boomerang can't do it
17:31:47 <ertes> you need a monadic parser library
17:32:31 <ertes> boomerang sacrifices the flexibility of Monad to support constructing printers at the same time…  that's something a monadic parser type can't do
17:32:45 <Ptival> yeah I noticed that, it's all Monoids
17:32:52 <Welkin> it's monoids all the way down
17:32:54 <Ptival> I guess I'll write the printers
17:33:21 <Welkin> but but
17:33:27 <Welkin> monads are monoids!
17:33:44 <Welkin> I suppose not in haskell though
17:34:32 <Welkin> I'm curious why there are so many parser libraries since I last looked
17:34:45 <Welkin> I remember megaparsec is a fork of parsec
17:34:49 <Welkin> never heard of boomerang
17:34:56 <Welkin> why did edwardk write trifecta?
17:40:47 <jle`> is there a newtype wrapper that gives the backwards Traversable instace?
17:41:52 <jle`> oh there's Backwards
17:45:01 <erisco> jle`, I am not sure a -> Void is going to work for negation always... it certainly seems wrong for this
17:45:17 <erisco> a :< b -> Not (a := b)  where Not a = a -> Void
17:45:37 <erisco> this is what I meant yesterday by my inability to construct an a -> Void
17:46:02 <erisco> given some A -> Void I can, like your example demonstrated, but otherwise I'm stuck
17:46:49 <erisco> I can construct the relation of unequal naturals...
17:48:18 <erisco> it seems like a -> Void is good for a :: * but not for other kinds
17:48:36 <erisco> so perhaps I need to classify the notation of negation
17:48:41 <jle`> er, a := b :: *, there
17:48:43 <erisco> the notion*
17:48:50 <erisco> yes that is correct
17:49:06 <jle`> (a :< b) -> Not (a := b) makes sense as a thing
17:49:26 <jle`> but giving it comes from the nature of the structure of your (a :< b) proof
17:49:54 <jle`> what witness you have for (a :< b)
17:50:09 <erisco> LtZ and LtS
17:51:28 <jle`> say, data (:<) :: N -> N -> * where LtZ :: n :< S m; LtS :: n :< m -> S n :< S m   ... ?
17:51:49 <jle`> * LtZ :: Z :< S m
17:52:50 <erisco> well I chose  LtZ :: Sing m -> Z :< S m  but I suppose either works
17:53:25 <erisco> could use that or SingI m context
17:55:58 <erisco> in the example that had form (A -> Void) -> (B -> Void) I understood because we can map A to B with B -> A
17:56:12 <jle`> in that case your first branch could be foo = \case LtZ s -> case s of SS s -> \case {}
17:56:19 <erisco> we're not concerned whether an A -> Void actually exists, it is given to us
17:56:37 <erisco> but in this scenario we have to just give an a := b -> Void
17:56:39 <jle`> er wait hm, let me think through the syntax of the second half
17:56:40 <erisco> how is that ever possible
17:56:55 <jle`> you can give an (a := Void) with empty patterns
17:57:04 <jle`> er, empty case statements
17:57:37 <jle`> foo = \case LtZ s -> case s of S _ -> \case {}
17:57:49 <erisco> but what inhabitant of a := b -> Void is that? aren't we just writing undefined?
17:58:05 <jle`>     `\case {}` handles every possible input case
17:58:11 <jle`> because there are no possible inputs
17:58:28 <jle`> voidId :: Void -> Int; voidId = \case {}, for example
17:58:31 <erisco> ah ha, got ya
17:58:39 <jle`> so \case {}, or \x -> case x of {}
17:58:59 <jle`> um, in explicit mode, it'd be case s of S _ -> \noSuchRefl -> case noSuchRefl of {}
17:59:00 <erisco> this is an aspect of A -> Void I did not consider!
17:59:03 <erisco> what if there are no A's!
17:59:07 <jle`> because there isn't any possible consturctor
17:59:14 <jle`> so you don't have to handle any cases
17:59:16 <jle`> mhm
17:59:20 <erisco> right right, okay thanks
17:59:29 <erisco> can't believe I didn't see that. thanks!
17:59:31 <jle`> unfortunately right now GHC doesn't warn you if you do \case {} and there actually 'are' constructors
17:59:35 <jle`> no problem, it's not obvious!
17:59:47 <jle`> ideally \case {} should give incomplete pattern match warning
17:59:49 <erisco> it doesn't? darn... so it sounds more like undefined then
18:00:06 <jle`> well, it's actually the other problem
18:00:20 <jle`> if you try to put in any pattern, GHC will complain.  so that's good
18:00:34 <jle`> like, if you accidentally did \case Refl -> ..., GHC will complain that Refl isn't a possible constructor
18:00:40 <jle`> so it's better than undefined in that sense
18:01:01 <erisco> so it knows which constructors are excluded but not that they are all excluded
18:01:08 <Ptival> would you write "return Nothing <$> p" or "p *> Nothing" or something else?
18:01:09 <erisco> sounds like that could be improved in a patch later on
18:01:32 <jle`> yeah i don't think this is any fundamental property of the type system/ghc...probably just some switch in ghc turned off
18:01:53 <Ptival> sorry, would you write "return Nothing <$> p" or "p *> return Nothing" or something else where "return" does not need to appear?
18:01:55 <jle`> Ptival: 'Nothing <$ p', maybe?
18:02:14 <jle`> it's also kind of silly to use return there....what you write is basically 'const Nothing <$> p'
18:02:19 <jle`> because 'return' is the (->) instance
18:02:31 <jle`> you meant (\_ -> Nothing) <$> p, right?
18:02:37 <jle`> in that case, you can do Nothing <$ p
18:03:18 <jle`> return Nothing <$> p is the same as p *> return Nothing, but the return's are different :)  kind of a coincidence there
18:06:03 <Welkin> const Nothing <$> p
18:06:08 <Welkin> so many ways to write it!
18:06:50 <erisco> EmptyCase on but (\case {}) is a parse error on case... hrm
18:07:21 <erisco> oh that is LambdaCase isn't it
18:07:33 <jle`> yeah
18:07:34 <Welkin> lol
18:16:11 <erisco> does ¬Q ⇒ ¬P have a name? I thought it did
18:18:35 <jle`> just sounds like a normal implication
18:18:44 <jle`> is there some relationship between P and Q that you aren't mentioning
18:18:52 <jle`> if P => Q, then what you said is the contrapositive
18:26:36 <alexashka> good day - I'm wanting to run my haskell code on an ubuntu server, and I do my development on a mac. So I transferred the binary over, of course it won't run. Googling says it's the incompatible architectures. What gives? How do I compile my haskell goodies to run on ubuntu?
18:27:12 <alexashka> I imagine this isn't an exotic question, yet googling around isn't being very fruitful :(
18:27:39 <ertes> alexashka: the simple option is to compile on ubuntu
18:27:58 <ertes> alexashka: if you really want to compile on mac, you need to set up GHC as a cross-compiler
18:28:19 <alexashka> ertes: I decided to try that - running stack build halts on populating index cache
18:29:02 <alexashka> by halts I mean the process gets killed, I get 'Populating index cache ...Killed' - google says stack build takes up a lot of memory, and my digitalocean droplet only has so much
18:29:40 <suzu> alexashka do you have some free disk space?
18:29:51 <suzu> you can use some disk space as swap and dodge the ram requirement that way
18:29:51 <alexashka> suzu: yessir
18:30:07 <alexashka> that's a good idea - how's that done?
18:30:21 <suzu> so first make a big file
18:30:38 <suzu> sudo dd if=/dev/zero of=swapfile bs=1K count=4M
18:30:41 <ertes> another option is to use nix…  building for darwin works here without any setup, as far as i can tell
18:30:44 <suzu> that'll make you a 4 gigabyte file of zeroes
18:30:45 <ertes> of course i can't test the result
18:30:51 <ertes> because i don't have a mac
18:30:53 <suzu> called 'swapfile'
18:31:02 <suzu> then you can turn it on
18:31:07 <suzu> mkswap swapfile
18:31:10 <suzu> swapon swapfile
18:31:14 <suzu> those two commands ^
18:31:16 <suzu> then try building
18:31:31 <suzu> when you're done, do `swapoff swapfile` and then destroy swapfile if you wish
18:31:43 <alexashka> suzu: very intereting, let me give that a try
18:32:11 <alexashka> ertes: you mean run a virutal machine, compile on there, and transfer that file over? so that the architectures match?
18:32:32 <ertes> alexashka: that would be the "just compile on ubuntu" option
18:32:57 <ertes> the second option is to cross-compile…  it's painful to set up, but once done it's convenient
18:33:02 <ertes> the third option is to try nix
18:33:12 <alexashka> ertes: ya, I am leaning towards that - doing this swapon/off every time I need to build seems really o-O
18:33:19 <alexashka> I'm not sure what nix is, can you elaborate?
18:33:31 <suzu> you could just leave the swap on all the time
18:34:01 <suzu> it basically adds more memory to your system at the expense of speed.
18:34:05 <ertes> nix is a package/deployment manager which has cross-compilation built in by concept
18:34:50 <alexashka> hehe nix - Poor OS X support for stable releases
18:35:08 <ertes> well, use the unstable one =)
18:35:46 <LeCamarade> 1
18:36:04 <alexashka> I'm going to give this swapping idea a try - I appreciate your ideas as well, thank you
18:36:37 <ertes> adding swap might turn an impossible task into an unbearably painful one…  consider RAM compression first, if your OS supports it
18:48:08 <chocopuff> Do any of you use vim? the default syntax coloring seems to suck
18:49:26 <Welkin> chocopuff: use emacs with evil-mode
18:49:54 <Welkin> the syntax coloring depends on your color theme, too
18:50:09 <Welkin> I use solarized-dark and it looks great
18:55:16 <chocopuff> Welkin: I mean, like what syntax is highlighted
18:55:46 <erisco> jle`, thanks
18:56:29 <Welkin> I don't know what vim's haskell mode looks like
18:56:36 <Welkin> the emacs haskell-mode is good though
19:12:50 <jle`> erisco: no problem!
19:15:59 <alexashka> suzu: swapfile worked :) thank you 
19:58:57 <gfixler> I come bearing CT questions
19:59:16 <gfixler> objects can have multiple arrows between them?
19:59:31 <gfixler> i.e. A -f-> B, A -g-> B, etc.
19:59:48 <erisco> yes
19:59:54 <erisco> but don't make the questions too much harder for me :P
19:59:59 <gfixler> hehe
20:00:18 <gfixler> I'm wondering if Hask can have multiple such arrows
20:00:45 <gfixler> I have learned that a category of relations can't have multiple arrows of the same direction between any 2 objects
20:01:00 <gfixler> though you could have A -> B and B -> A
20:01:41 <gfixler> I'm not sure what that means, though
20:01:56 <gfixler> I would presume A >= B the other way becomes B <= A
20:02:44 <Koterpillar> gfixler: if A and B are types, of course there can be multiple functions of type A -> B
20:03:06 <gfixler> Koterpillar: okay, so the morphisms are functions
20:03:17 <gfixler> I seem to always mix up which level of reasoning I'm in with CT
20:03:43 <gfixler> Koterpillar: another question: Not every object pair must have an arrow, right?
20:03:46 <Koterpillar> I'm going by https://wiki.haskell.org/Hask
20:03:51 <erisco> correct
20:03:51 <Koterpillar> gfixler: correct
20:04:01 <gfixler> good, this is clicking
20:04:20 <erisco> you're just obligated to have composition and identity
20:04:30 <gfixler> right
20:05:13 <erisco> then often additional properties are added, but that is the minimum
20:05:41 <gfixler> the property of totally rocking
20:05:58 <erisco> you could add that if f : A -> B and g : A -> B then f = g
20:06:27 <gfixler> that's not just a given?
20:06:42 <gfixler> so in Hask, I suppose it wouldn't be
20:07:03 <erisco> no it isn't a given
20:07:03 <gfixler> f could be `length` and g could be `number of vowels`
20:07:17 <erisco> so you can say you want to talk about categories with that property and then derive theorems
20:07:25 <gfixler> cool
20:07:26 <erisco> then you can later prove that particular instances have that property
20:07:34 <erisco> then you know the theorems must also hold
20:07:35 <gfixler> just that alone makes my mind explode
20:07:44 <gfixler> a whole text book appeared in my head of new things
20:08:07 <erisco> well that is just mathematics generally, not only CT
20:08:11 <gfixler> right
20:08:22 <gfixler> I'm new to these more interesting maths
20:08:29 <erisco> same if you start with a magma and add an identity
20:08:30 <gfixler> so I keep finding such properties impressive
20:08:33 <gfixler> yep
20:09:17 <gfixler> hey, that property you just mentioned seems to define thin categories
20:09:25 <gfixler> https://ncatlab.org/nlab/show/thin+category
20:09:33 <gfixler> I had just opened that on the other screen a moment ago
20:09:43 <erisco> seems so, I didn't know that :)
20:39:01 <wolphin> I have GUI that is just nice interface for a config file. When user changes something I can just print what have been changed to stdout (using signals from GUI), then parse that data with second program and make changes to the config. Looks like I need something similar to global state to do that job inside one program?
21:32:19 <jchia> I have a ReaderT do block that I want to runReaderT on, but because of the argument order, I can't just do runReaderT r $ do ..., and runReaderT (do ...) r is ugly. How can I do better?
21:32:39 <jle`> jchia: a common pattern is flip runReader r $ do ...
21:33:52 <jchia> jle`: Thanks
21:34:24 <jle`> no problem!
21:34:40 <jle`> the flipped version is useful much more often than the unflipped one
22:30:16 <slack1256> the RSS reported of a program on haskell is actually the double of what is really using because the copying strat that the gc uses. Right?
22:36:09 <mniip> slack1256, "double" how much are we talking
22:38:30 <slack1256> let say a program where all they live value are long lived (and thus are in gen1, which uses copying)
22:41:28 <mniip> it's a bit more complicated than just double,
22:41:48 <mniip> but well, can't say I'm experienced enough in the gc stuff
22:48:54 <mniip> oh wow
22:49:22 <mniip> Nat(f, g) = forall c. Hom(f c, g c)
22:49:32 <mniip> apparently that's a lemma
22:49:38 <mniip> and I've always taken it for granted
23:02:19 <Xnuk> Is there any JSON5 parser?
23:03:44 <Lokathor> "Be aware that the Functor, Traversable and Data instances are the same as for the Data.Map.Lazy module, so if they are used on strict maps, the resulting maps will be lazy."
23:03:44 <opqdonut> oh, that sounds nice
23:03:49 <Lokathor> what a sad sentence to find in the docs
23:03:51 <opqdonut> json5 I mean
23:04:55 * LeCamarade just learnt about JSON5 now …
23:05:16 <Xnuk> I need "unquoted object key" feature, but seems Haskell doesn't have package which supports this.
23:06:25 <Xnuk> If no package exists, I need to play with JS AST once again...
23:06:31 <slack1256> mniip: is that a lemma? doesn't it follow from the definition of naturality?
23:06:52 <slack1256> Mmmm => is trivial, maybe <= is the one more involved
23:07:14 <quchen> There is no strict Map type, there is only an alternative API that forces all values going into a lazy Map.
23:07:18 <mniip> slack1256, I'm denoting a end by forall
23:07:26 <mniip> like, a categorical end
23:07:40 <quchen> This is great for compatibility and dropping in the lazy/strict variant.
23:07:52 <quchen> This is not great if you expect a strict Map type.
23:08:10 <Lokathor> quchen, :S
23:08:23 <quchen> Note that Map is strict in the keys already. Just not necessarily in the values.
23:08:41 <Lokathor> oh well, in my current case it doesn't matter
23:09:10 <slack1256> TIL: about end functors
23:10:19 <mniip> slack1256, even then
23:10:23 <mniip> it's nontrivial
23:10:43 <mniip> naturality guarantees that, precisely, f . eta_X = eta Y . fmap f
23:11:10 <Lokathor> oh cripe
23:11:11 <mniip> it doesn't require eta to be continuous
23:11:24 <Lokathor> stackage, even nightly stackage, is several versions behind on Containers
23:27:29 <Alxandr> Hi. I have a (a -> IO b) and a (b -> c) function, and need to combine them into (a -> IO c), what's the best way to do that?
23:27:45 <erisco> (fmap . fmap)
23:28:14 <mniip> fmap f . g
23:28:31 <jchia> How can i 'lift' System.IO.withFile so that the signature is changed to have MonadIO instead of IO? Or, is there an alternative function I can use with MonadIO accomplishing the same effect?
23:28:46 <Alxandr> Isn't that the same as <$>
23:28:57 <magthe> Alxandr: yupp
23:28:59 <magthe> it is
23:28:59 <mniip> it is, but fmap is partially applied here
23:29:00 <liste> :t liftIO -- jchia
23:29:02 <lambdabot> MonadIO m => IO a -> m a
23:29:09 <erisco> you need two <$>'s
23:29:11 <Alxandr> I'll try
23:29:17 <jchia> liste: I can't just liste the withFile, can I?
23:29:34 <jchia> liste: s/liste/liftIO/
23:29:41 <mniip> jchia, I don't think the abstraction of withFile is going to work with an arbitrary MonadIO
23:30:29 <jchia> mniip: Can't I transform withFile into a MonadIO m => FilePath -> IOMode (Handle -> m r) -> m r ?
23:30:58 <Lokathor> YEAH
23:31:09 <Lokathor> guys i got the start of a text adventure going
23:31:10 <Alxandr> Wey, that worked :)
23:31:25 <Lokathor> and it only uses three threads :P
23:31:26 <Alxandr> I've been trying just about any combination of <$> and >=> :P
23:31:27 <mniip> jchia, you can, but the function that is being with'd can break the abstraction
23:31:40 <mniip> if m, for example, includes ListT
23:31:53 <mniip> you can end up closing the handle on the first result
23:32:01 <mniip> and then the second result will work with an invalid handle
23:32:33 <mniip> and
23:32:47 <mniip> I don't know if there's a monad-generic way to close the handle upon exit from the function
23:33:00 <tfc> Lokathor: is its source code online anywhere?
23:33:07 <Lokathor> tfc one moment
23:33:07 <mniip> EitherT e IO is going to skip the close if the inner function throws
23:33:08 <Alxandr> <* closeHandle?
23:34:17 <Lokathor> tfc https://github.com/Lokathor/galaxy-break sadly it's windows only at the moment
23:34:37 <tfc> Lokathor:  what are the dependencies that make it windows only?
23:34:38 <Lokathor> because i haven't fixed the linux "front end" since I changed how the dirver works
23:34:46 <mniip> the second you say 'liftIO x' you sign up for not knowing where and when your IO actin gets executed
23:34:47 <jchia> mniip: Concretely, I have a [ReaderT r IO ()] that I'm trying to download and write multiple files, using the same environment. Any suggestions what I can use instead of withFile?
23:35:04 <mniip> jchia, well in that case withFile will work
23:35:40 <Lokathor> tfc, right now the windows version polls very rapidly for inputs as it reads in data, and the linux version is just not that fancy, so... well it might kinda work if i fiddle with it a bit
23:35:52 <tfc> Lokathor: i see
23:36:00 <tfc> Lokathor: don't have any windows here.
23:36:13 <Lokathor> tfc, well the game is not exciting anyway at the moment
23:36:17 <Lokathor> but you can check the code
23:36:27 <Lokathor> i'll see if i can fix the linux version
23:36:58 <tfc> Lokathor: hehe, no problem, i do not have any exaggerated expectations. it's just that i am learning haskell at the time and it often helps to read foreign code (if it's not too complex yet)
23:36:58 <mniip> :t \path mode f -> do x <- ask; System.IO.withFile path mode (runReaderT x)
23:37:00 <lambdabot> MonadReader (ReaderT GHC.IO.Handle.Types.Handle IO b) IO => FilePath -> GHC.IO.IOMode.IOMode -> t -> IO b
23:37:14 <mniip> :t \path mode f -> do x <- ask; System.IO.withFile path mode (runReaderT f x)
23:37:16 <lambdabot> MonadReader r IO => FilePath -> GHC.IO.IOMode.IOMode -> ReaderT r ((->) GHC.IO.Handle.Types.Handle) (IO b) -> IO b
23:37:27 <mniip> bleh
23:37:37 <mniip> :t \path mode f -> do x <- ask; System.IO.withFile path mode (\handle runReaderT (f handle) x)
23:37:39 <lambdabot> error: Parse error in pattern: f
23:37:46 <mniip> :t \path mode f -> do x <- ask; System.IO.withFile path mode (\handle -> runReaderT (f handle) x)
23:37:47 <lambdabot> MonadReader r IO => FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> ReaderT r IO b) -> IO b
23:37:50 <mniip> there we go
23:38:07 <mniip> hm
23:38:10 <Lokathor> tfc, well the reason that the linux version is messed is that i intend for it to be very concurrent later on... but at the moment
23:38:13 <mniip> needs more liftIO but you get the idea
23:40:47 <Alxandr> How about this then: I have (getArgs :: IO [String]), (f :: [String] -> a) and (toJSONFilter :: a -> ByteString -> IO ByteString) and I need a (ByteString -> IO ByteString)
23:41:00 <Lokathor> tfc, okay try pulling the repo and building now
23:41:16 <tfc> lokathor one moment
23:41:18 <Lokathor> i think it'll work on linux/mac, but just kinda less good than i'd want in a final product
23:41:23 <tfc> Lokathor: will report back in 10 minutes
23:41:29 <Lokathor> cool
23:50:08 <Alxandr> How about this then: I have (getArgs :: IO [String]), (f :: [String] -> a) and (toJSONFilter :: a -> ByteString -> IO ByteString) and I need a (ByteString -> IO ByteString)
23:50:16 <Alxandr> Ah, sorry, didn't mean to re-type
23:50:29 <Alxandr> Thought focus was in console
23:50:38 <jchia> mniip: thanks
23:51:21 <Alxandr> Anyways, I have the following working: toJSONFilter f = \str -> getArgs >>= \args -> toJSONFilter (f args) str
23:51:33 <Alxandr> And would like if possible to remove str from the equation
23:51:44 <Alxandr> So I could have toJSONFilter f = <something>
