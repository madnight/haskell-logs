01:18:46 <spatial> haskell-mode in spacemacs not recognizing cabal installed packages
01:19:19 <spatial> (spacemacs/set-leader-keys-for-major-mode haskell-mode "cx"inferior-haskell- load-and-run )
01:19:59 <spatial> But ghci from prompt is able to import. Same version.
01:26:05 <spatial> I am missing something because it is a simple workflow.
01:35:09 <eklavya> I am following https://haskell-lang.org/library/vector
01:35:36 <eklavya> but I am getting PrimState m0 doesn't match with PrimState m error
01:35:39 <eklavya> pasting 
01:36:33 <eklavya> http://lpaste.net/352901
01:36:41 <eklavya> what am I doing wrong?
01:37:19 <eklavya> also I don't understand what's (MVector MVector a)
01:58:58 <eklavya> please help?
02:05:23 <int-e> eklavya: please paste complete error messages with such questions, they contain important information. For example, "In the first argument of ‘(>)’, namely ‘(M.read v l)’" <-- this indicates that you are using a monadic action as an argument to a comparison. Indeed, (M.read v l) > (M.read v i) cannot work, you need to do those reads as part of the monadic code (in the do block), and then...
02:05:30 <int-e> ...compare the results.
02:07:17 <eklavya> oh
02:07:18 <eklavya> yes
02:07:27 <eklavya> int-e: let me do that
02:08:04 <Cooler> how do you declare an inner helper function?
02:08:54 <liste> Cooler: using with or let
02:08:58 <liste> where or let*
02:08:59 <liste> not with
02:09:26 <liste> > let innerHelperFunction x = x + 1 in (innerHelperFunction 5) * (innerHelperFunction 6)
02:09:29 <lambdabot>  42
02:09:31 <eklavya> int-e: thank you so much :D
02:09:32 <eklavya> that was it
02:09:58 <Cooler> thanks
02:10:12 <eklavya> very hard to figure that out from the error message though and I should have noticed it that it was indeed a monadic action :P
02:10:29 <liste> @let outerFunction x = (innerHelperFunction x) * (innerHelperFunction x) where innerHelperFunction x = x + 1 -- Cooler
02:10:32 <lambdabot>  Defined.
02:10:41 <liste> > outerFunction 7
02:10:44 <lambdabot>  64
02:11:41 <liste> (note that I shadowed `x', which isn't usually a good practice)
02:53:17 <`Guest01> can module name start with a digit?
02:55:19 <merijn> no
03:34:21 <marekw2143> https://bitbucket.org/chessRepo/c7/src/d69537aa3de3e7d4842de424cbad4f6d26d53c5c/main.hs?at=maybeList&fileviewer=file-view-default#main.hs-43 - why I'm getting  Cannot parse data constructor in a data/newtype declaration: {from :: FieldCoordinates,
03:34:22 <marekw2143>                                                                   to :: FieldCoordinates,
03:34:22 <marekw2143>                                                                   after_tr_board_state :: BoardState} ? 
03:36:03 <AndreasK> marekw2143: You miss a constructor name
03:36:09 <marekw2143> oh
03:36:11 <marekw2143> true
03:36:49 <marekw2143> thanks
03:49:23 <fProgrammer> quick question: I've two variables (say p, q) which are of type (Maybe A) and (Maybe B). I want to write a function which does something only when both p,q are not Nothing. I know I can use (isNothing) etc How do I write it concisely?
03:49:50 <Axman6> f <$> p <*> q
03:49:57 <Axman6> or liftA2 f p q
03:50:21 <fProgrammer> Axman6: umm lemme try, thanks!
03:50:23 <Axman6> (you will end up with a Maybe C assuming f :: A -> B -> C)
03:50:31 <Axman6> :t liftA2
03:50:34 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
03:52:02 <Axman6> fProgrammer:you could also pattern match, that's pretty much always a better idea than uing something like isNothing, because it also gives a name to the value contained in the Just constructor if it exists. Applicative just abstracts this concept for you
03:53:36 <ertes> fProgrammer: you're only interested in whether they're Just, not the actual values?
03:53:57 <fProgrammer> ertes: interested in actual values only if they are Just
03:54:10 <fProgrammer> Axman6: how do I pattern match for two variables? 
03:54:48 <ertes> fProgrammer: then what Axman6 said
03:54:50 <Axman6> case mA of Nothing -> Notjing; Just a -> case mB of Nothing -> Nothing; Just b -> Just (f a b)
03:55:06 <Axman6> but this is exactly what liftA2 does (and the applicative style version too)
03:55:23 <fProgrammer> Axman6: yes, Applicative seems nicer. Thanks anyway!
03:55:27 <ertes> > liftA2 (+) (Just 3) (Just 5)
03:55:34 <lambdabot>  mueval-core: Time limit exceeded
03:55:37 <Axman6> lambdabot!
03:55:40 <ertes> lambdabot: you serious?
03:55:43 <Axman6> Y U NO
03:55:46 <ertes> > liftA2 (+) (Just 3) (Just 5)
03:55:50 <lambdabot>  Just 8
03:56:26 <ertes> > liftA2 replicate (Just 4) (Just 'a')
03:56:30 <lambdabot>  Just "aaaa"
03:56:52 <ertes> fProgrammer: then you can pattern-match on the result:  case liftA2 f mx my of …
03:56:59 <ertes> or you can use 'maybe', which i usually prefer
03:57:12 <fProgrammer> ertes: understood!
03:57:12 <ertes> > maybe "d'oh!" show (Just 7)
03:57:17 <lambdabot>  "7"
03:57:19 <Cooler> what is line 8 doing? http://lpaste.net/352903
03:57:19 <ertes> > maybe "d'oh!" show Nothing
03:57:23 <lambdabot>  "d'oh!"
03:58:18 <Axman6> Cooler: that parsed exactly the string ": " and nothing else
03:58:23 <Axman6> parses*
03:58:37 <Cooler> what is string?
03:58:43 <Axman6> Cooler: also that code isn't correctly indented
03:59:00 <Axman6> string is a parser which you give a string and it succeeds if it parses exactly that string only
03:59:00 <Cooler> is that a function that creates a parser for a string?
03:59:05 <Axman6> yes
03:59:31 <Cooler> is that code from Aeson?
03:59:36 <Axman6> so string "XXX" will only succedd if it finds the string XXX in the input
03:59:47 <Axman6> I don't think anything there is from Aeson
04:25:08 <mekeor> is haskell growing or is it dying? what's your impression? my personal impression is that at least the activity of this irc channel has been decreasing.
04:25:52 <marekw2143> how can I install GHC.Exts ? 
04:26:14 <liste> mekeor: it's growing, the IRC channel represents a minorish part of the community
04:26:33 <M2tias> mekeor: maybe irc is just dying. haskell was #1 programming language for sunday programmers according to stackoverflow
04:27:42 <mekeor> i see. bummer. irc is nice :(
04:28:06 <lyxia> marekw2143: it's part of base, you don't need to install it
04:31:11 <mekeor> mekeor: for the record, see https://stackoverflow.blog/2017/02/What-Programming-Languages-Weekends/
04:37:00 <patrick_1> morning everyone 
04:37:19 <mekeor> hello patrick_1 :)
04:38:24 <ertes> we should take the opportunity to create a replacement for IRC that isn't brain-damaged
04:38:35 <liste> ertes: IRCv3 ?
04:39:10 <hpc> usenet?
04:39:58 <mekeor> ertes: http://about.psyc.eu/ -- it's good!
04:40:08 <Ferdirand> or silc ? xmpp ? signal ? tox ?
04:40:12 <mekeor> let's write a client for that protocoll
04:41:46 <Tuplanolla> Which one supports code and equation rendering?
04:42:24 <lyxia> Let's communicate in LaTeX over email.
04:43:01 <mekeor> "PSYC is, as benchmarks show, the fastest yet extensible text-based protocol we are aware of, providing a messaging infrastructure for human conversation and social exchange of possibly binary data"
04:43:49 <mekeor> let's communicate over letters. would you like to give me your address?
04:43:57 <ertes> mekeor: sounds promising actually…  IRC is crap for many reasons, XMPP is crap for all the other reasons, etc.
04:46:15 <trkpa> Wa
04:46:24 <kgadek> #haskell-offtopic ? :) also: there is this Slack that I even like but is proprietary and it consumes history and A LOT of ram. There's also mattermost, FLOSS competitor.
04:47:06 <kgadek> And if you want LaTeX rendering then probably MathJaX is the way to go. So browser-based client
04:47:12 <trkpa> What is the best practice in haskell when it comes to program error state? I remember seeing somewhere on reddit that people were "annoyed" by coding passing exceptions
04:47:52 <barrucadu> And gitter, and discord... there's one thing IRC has over all these newer alternatives: an established community.
04:47:54 <Tuplanolla> I'm unhappy as long as these systems neglect equations and diagrams or treat them as "possibly binary data". Everything remains broken, just like the web.
04:48:14 <yushyin> barrucadu: and xmpp with the MAM and MIX xep, and matrix.org
04:48:15 <yushyin> :D
04:50:42 <liste> trkpa: depends on what you mean by error state, but usually Either or ErrorT -- http://www.randomhacks.net/2007/03/10/haskell-8-ways-to-report-errors/
04:51:26 <trkpa> @liste Thank you! That link is very helpful 
04:51:26 <lambdabot> No module "Thank you! That link is very helpful " loaded
04:58:58 <stevenxl> Hello. I'd like to create a function that takes an Integer and subtracts 3 from that Integer. I'm trying to use (- 3). But that leads to a type mismatch. If I convert the - operator to a function (-), there's no way for me to apply the "second" argument first. Unless I use reverse.
04:59:07 <stevenxl> Am I missing something obvious?
04:59:17 <lyxia> subtract 3
04:59:25 <lyxia> \x -> x - 3
04:59:35 <lyxia> (- 3) is parsed as the integer -3
04:59:40 <hpc> the "-" operator is a bit of a special case in the parser
04:59:46 <mekeor> or:   flip (-) 3
04:59:54 <stevenxl> lyxia: thank you very much!
05:00:40 <stevenxl> OK. In general, when I'm creating sections - which I understand to be partially applied infix operators - it is possible to apply the first or the second argument, yes? 
05:02:17 <hpc> yeah, in general what you tried will work
05:04:08 <stevenxl> :-)
05:04:13 <stevenxl> thank you
05:05:57 <marekw2143> https://bitbucket.org/chessRepo/c7/src/91d975663eeb8116dbfae437fe4ff297a586695b/main.hs?at=maybeList&fileviewer=file-view-default#main.hs-64
05:06:15 <marekw2143> I've got error:  Couldn't match expected type ‘ReaderT
05:06:16 <marekw2143>                                     GameState Data.Functor.Identity.Identity t0’
05:06:16 <marekw2143>                 with actual type ‘GameState -> Team’
05:06:16 <marekw2143>     Probable cause: ‘whoMoves’ is applied to too few arguments
05:06:49 <marekw2143> as calculateNextMoves is a Reader type, then I guess "whoMoves" will get "GameState" instance as argument 
05:07:51 <qiange> test!
05:15:25 <robertkennedy> :t liftA3
05:15:29 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
05:16:14 <robertkennedy> I often use an idiom like 
05:16:52 <robertkennedy> (,) <$> f <*> g
05:17:03 <robertkennedy> I also often use
05:17:12 <mniip> "liftA2 (,) f g" is the same yes
05:17:25 <hpc> liftA3 f x y z = f <$> x <*> y <*> z
05:18:11 <robertkennedy> joinTuple ma mb = (,) <$> ma <*> mb
05:18:34 <liste> marekw2143: try whoMoves <$> ask
05:18:42 <liste> instead of whoMoves
05:18:47 <mniip> there actually is an alternative definition of applicative
05:18:54 <mniip> where joinTuple is a fundamental operation
05:19:27 <robertkennedy> How could I unify these for when `f :: a -> Maybe b`
05:19:35 <robertkennedy> Oh that would work too
05:20:01 <liste> marekw2143: "player <- whoMoves <$> ask" or "player <- fmap whoMoves ask"
05:20:31 <marekw2143> liste, thanks
05:20:42 <marekw2143> I've just wrapped "whoMoves" into reader monad
05:22:58 <marekw2143> liste, how can I know how fmap works for Reader? 
05:24:12 <liste> marekw2143: Reader is instance of Monad, Functor is a superclass of Monad
05:24:37 <liste> marekw2143: and for "how", either reading the source or reasoning with the laws
05:25:25 <robertkennedy> But it does seem you should be able to find a nice way to build `uncurry joinTuple . ((,) <$> f <*> g)`
05:30:12 <halogenandtoast> If I have a function that returns a record (i.e. initialRecord) and I want 9 different records in an array how can I do this? I tried `replicate 9 initialRecord` but all 9 elements in the resulting List share memory.
05:30:22 <halogenandtoast> s/array/List/
05:30:56 <liste> halogenandtoast: why does it matter?
05:31:19 <liste> you can't mutate them anyway
05:31:43 <halogenandtoast> You are right, I'm doing something wrong somewhere else
05:31:49 <halogenandtoast> and my OOP self cried wolf
05:32:37 <halogenandtoast> Yup I see my problem, I'm trying to replace a single record in an array and I mapped using equality
05:32:45 <halogenandtoast> and of course they're all equal
05:32:56 <halogenandtoast> `let flags = map (\x -> if (x == f) then f' else x) (gameFlags g) `
05:33:46 <halogenandtoast> so I either have to use the index (which I'm not thrilled about since that feels like an unsafe operation) or I can gives the flags some attribute to make them unique
05:34:19 <halogenandtoast> or lenses..., are there any other options, or is one of those options typically the "best"
05:38:57 <Tuplanolla> Why do you need "copies" of the same record?
05:42:36 <halogenandtoast> I want different records, they all start with the same state
05:43:13 <halogenandtoast> I'm emulating a boardgame, there are nine flags, which can contain cards played by one of two players on respective sides and potentially one player who owns the flag.
05:43:52 <halogenandtoast> so I'm trying to implement `updateGame` which takes the game, which player, which card they'll play, and which flag they'll play it to
05:45:28 <halogenandtoast> I assume I've architected my solution wrong and I'm just too daft to understand how to architect it better.
05:47:03 <lpaste_> halogenandtoast pasted “Game.hs” at http://lpaste.net/352904
05:47:10 <trkpa> Any insight into the usefulness of id and const? I'm new to haskell so I haven't had a reason to use them yet
05:47:33 <halogenandtoast> trkpa: I use them all the time...
05:47:54 <halogenandtoast> one sec I'll get an example
05:48:30 <halogenandtoast> let's say I have a variable request of type Either HttpException B.ByteString
05:48:42 <halogenandtoast> if the request fails I want to return Nothing
05:48:44 <barrucadu> halogenandtoast: Is the number of flags fixed? If so, why not just have gameFlag1, gameFlag2, etc inside GameState, rather than a list?
05:48:51 <halogenandtoast> `either (const Nothing) (Just . toStrict . decodeUtf8 . B64.encode) request`
05:49:55 <halogenandtoast> barrucadu: it is, nice observation! Having them in a list does make it convenient for priting, but they have no other dependencies on being in a list. They're still difficult to update though
05:49:57 <trkpa> halogenandtoast: Why wouldn't just Nothing work there?
05:50:09 <halogenandtoast> :t either
05:50:11 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
05:50:32 <halogenandtoast> Just Nothing is not an (a -> c)
05:50:37 <halogenandtoast> :t Just Nothing
05:50:39 <lambdabot> Maybe (Maybe a)
05:50:49 <trkpa> ahhhh
05:50:51 <trkpa> ok
05:50:53 <halogenandtoast> or sorry you mean Nothing not Just Nothing lol
05:50:55 <trkpa> perfect example
05:51:11 <barrucadu> I occasionally use `id` with `maybe`
05:51:17 <barrucadu> :t maybe id
05:51:18 <halogenandtoast> same
05:51:18 <lambdabot> (a -> a1 -> a1) -> Maybe a -> a1 -> a1
05:51:24 <barrucadu> For example:
05:51:35 <barrucadu> > maybe id (:) (Just 5) [4,3,2,1]
05:51:37 <lambdabot>  [5,4,3,2,1]
05:51:44 <barrucadu> > maybe id (:) Nothing [4,3,2,1]
05:51:47 <lambdabot>  [4,3,2,1]
05:52:00 <halogenandtoast> trkpa: another example with const
05:52:02 <halogenandtoast> `importNhkArticle article = maybe (insert_ story) (const (return ())) =<< getBy (UniqueNewsId nid)`
05:52:44 <barrucadu> `id` and `const` typically aren't things you use by themselves, because they can be reduced very simply. They're useful when used with other higher-order functions.
05:53:41 <trkpa> Gotcha.
05:54:40 <halogenandtoast> barrucadu: well I sometime use const to stub functions
05:54:51 <trkpa> I was trying to understand its use in the class def of Functor. (<$)  = fmap . const
05:54:55 <halogenandtoast> for example gameOver :: GameState -> Bool          gameOver = const True
05:55:18 <halogenandtoast> there I'm using it by itself sorta
05:55:56 <barrucadu> Yeah, I usually use _ in that case, unless there are other cases in the function which force me to a specific number of patterns
05:56:11 <halogenandtoast> trkpa: Wait until you get to the Const type
05:56:18 <halogenandtoast> that's even more magical!
05:56:30 <halogenandtoast> newtype Const a b = Const { getConst :: a }
05:56:39 <Rembane> :t fmap . ($)
05:56:42 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:56:50 <Rembane> Hm... no.
05:57:00 <Rembane> :t fmap . const
05:57:03 <lambdabot> Functor f => b -> f b1 -> f b
05:57:11 <Rembane> Ah. Yes.
05:57:42 <halogenandtoast> Yeah the type of ($) is the best, because no one I teach it to gets it by looking at the type
05:57:47 <halogenandtoast> :t ($)
05:57:49 <lambdabot> (a -> b) -> a -> b
06:00:59 <halogenandtoast> :t flip id
06:01:01 <lambdabot> b -> (b -> c) -> c
06:01:02 <halogenandtoast> is also a good one
06:01:59 <halogenandtoast> although I'd love to see where that is actually useful...
06:04:50 <barrucadu> All this talk of types has reminded me I need to try to reduce some code to a minimal example. I've found a case where turning on TypeFamilies breaks some code unless I add an explicit type signature, and I suspect that GHC is wrong to compile it without the type signature because of the monomorphism restriction.
06:09:32 <trkpa> Any opinion on this book? https://www.amazon.com/Programming-Haskell-Graham-Hutton/dp/1316626229/ref=sr_1_2?ie=UTF8&qid=1487858925&sr=8-2&keywords=haskell
06:30:25 <halogenandtoast> trkpa: I have "heard" good things, but I haven't read it
06:30:34 <halogenandtoast> I hate books though
06:30:59 <halogenandtoast> I'm currently trying to read https://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0199237182 though
06:53:12 <robertkennedy> Is there a library for lambdabot? Or other tools to run code from databases?
06:54:02 <robertkennedy> I can get people to write lambda terms 
06:54:18 <sm> trkpa: it's good
06:56:07 <robertkennedy> Also, does anyone know a combinator <||> that can evaluate `loop <||> (+1) $ 3` ?
06:56:36 <robertkennedy> (evaluates it to 4)
06:57:11 <robertkennedy> Or `pure 4`, if it needs that
06:57:41 <robertkennedy> I tried with STM but couldn't manage it
07:03:20 <lyxia> (<||>) = const id
07:04:05 <athan> robertkennedy: what is `loop`?
07:04:49 <athan> are you looking for compositional concurrency or something?
07:12:43 <fryguybob> robertkennedy: race?
07:12:54 <fryguybob> @hoogle race
07:12:55 <lambdabot> Control.Concurrent.Async race :: IO a -> IO b -> IO (Either a b)
07:12:55 <lambdabot> Control.Concurrent.Async.Lifted race :: MonadBaseControl IO m => m a -> m b -> m (Either a b)
07:12:55 <lambdabot> Control.Concurrent.Async.Lifted.Safe race :: (MonadBaseControl IO m, Forall (Pure m)) => m a -> m b -> m (Either a b)
07:13:48 <fryguybob> robertkennedy: Or perhaps unamb?
07:14:33 <fryguybob> (or amb) from the unamb package.
07:24:38 <robertkennedy> I tried with race. Can post an example. The short motivation would be like `isPos n = n - 1 == 0 || isPos (n-1); isNeg = isPos . (-1*); isPositive n = isPos n <||> not (isNeg n)
07:25:16 <robertkennedy> (with something for zero ofc)
07:25:41 <robertkennedy> I'll look at amb
07:26:04 <max3> does compiling with  -prof -fprof-auto -fprof-cafs significantly slow down an executable?
07:29:23 <lyxia> yes it does
07:31:38 <max3> how much is significant? single digit or double digit?
07:34:05 <praveen> exit
07:43:36 <c_wraith> max3: in some cases, asymptotic.  It disables most optimizations.
09:12:08 <Sornaensis> does anyone here have experience with persistent-postgres
09:12:28 <Sornaensis> getBy does not seem to work as shown in the documentation I've read
09:12:37 <Sornaensis> I am getting type mismatch errors
09:17:24 <geekosaur> make sure the documentation version matches the package version
09:18:06 <geekosaur> haskell apis are prone to alter types, specifically because the compiler will catch it reliably
09:18:08 <Sornaensis> nevermind I figured out the issue
09:18:22 <Sornaensis> wasn't exporting a constructor that was magically generated by TH :'D
09:49:47 <Cooler> ?src foldMap
09:49:47 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:50:33 <Cooler> "Thinking cap time. Write a filter function for Foldable types using foldMap."
09:50:39 <Cooler> how does this work?
09:51:49 <Cooler> filterF :: (Applicative f, Foldable f, Monoid (f a)) =>(a -> Bool) -> f a -> f a
09:52:24 <pikajude> is it supposed to be filter f . toList?
09:52:26 <pikajude> I don't understand
09:53:44 <Cooler> its supposed to act like filter i think
09:54:06 <pikajude> but you can't "filter" a binary tree
09:54:13 <pikajude> without rebuilding it
09:54:15 <lyxia> that's why there's a monoid
09:55:06 <Cooler> i am not sure how foldMap fits into this
09:56:10 <pikajude> but say you try to filter a Data.Tree.Tree
09:56:18 <pikajude> what do you return from foldMap
09:56:29 <lyxia> The type of trees is not (a priori) a monoid
09:56:43 <pikajude> well yeah, but it's a Foldable
09:56:53 <pikajude> so what's the correct behaviro
09:56:56 <pikajude> behavior
09:57:30 <Cooler> what does foldMap have to do with filter?
09:57:47 <lambdafan> I'm looking for this function isAlphaNum :: Text -> Bool
09:57:47 <pikajude> only the bit where it said "Use foldMap to implement a filter function"
09:57:50 <pikajude> heh
09:57:57 <lambdafan> but hoogle can't help me find it
09:58:07 <pikajude> lambdafan: Data.Char
09:58:10 <monochrom> @type filter
09:58:12 <lambdabot> (a -> Bool) -> [a] -> [a]
09:58:25 <monochrom> Is filter in Foldable?
09:58:30 <lambdafan> I thought Data.Char was for String only
09:58:59 <pikajude> lambdafan: sorry, i didn't see the signature
09:59:01 <pikajude> i just saw the name
09:59:20 <pikajude> what is that function supposed to do? test an entire Text to see if it's alphanumeric?
09:59:26 <monochrom> No, filter isn't concerned with Foldable. What is the type of your filter?
09:59:42 <Cooler> filterF :: (Applicative f, Foldable f, Monoid (f a)) =>(a -> Bool) -> f a -> f a
10:00:17 <Cooler> lyxia, do you know how?
10:00:22 <pikajude> so again, how do you implement this for Tree
10:00:35 <monochrom> I suspect "can't be done".
10:00:40 <lambdafan> pikajude: the Text will be a single character, I want to identify it as alphaNumeric (or not)
10:00:46 <Cooler> i thought he said trees aren't monoids
10:00:54 <lyxia> I suspect it can
10:00:59 <pikajude> lambdafan: why is it a Text if it's a single character?
10:01:15 <pikajude> Cooler: sorry about that, I didn't see the Monoid constraint
10:01:22 <lambdafan> pikaJude: because I need a way to encode unicode
10:01:30 <pikajude> lambdafan: text supports unicode already
10:01:39 <pikajude> you should be testing a Char if it's alphanumeric, not a Text
10:01:48 <pikajude> if you want to test a Text, you can use Data.Text.all isAlphaNum iirc
10:02:18 <lambdafan> I'm testing a single character at a time
10:02:39 <pikajude> ok, but given a Text, you should be able to operate on a single character at a time using the functions in Data.Text
10:02:42 <pikajude> can you paste code?
10:02:58 <lyxia> Cooler: the idea is that you can map elements to a singleton or empty container depending on the predicate, and mappend them together.
10:03:05 <lambdafan> pikajude sure
10:03:51 <Cooler> how?
10:04:21 <pikajude> foldMap (\ x -> if myPredicate x then ??? x else mempty)
10:04:42 <Cooler> filterF f xs = pure f <*> xs ......
10:05:35 <Cooler> i don't think foldMap takes a function
10:05:47 <pikajude> foldMap :: Monoid m => (a -> m) -> t a -> m
10:06:00 <pikajude> for pure, you need Applicative
10:06:09 <lpaste_> lambdafan pasted “tokenizer” at http://lpaste.net/352915
10:06:29 <Cooler> pikajude, yeah look at the constraints
10:06:37 <pikajude> indeed
10:06:43 <pikajude> ok, that makes this much easier
10:06:57 <pikajude> it'd be foldMap (\ x -> if myPredicate x then pure x else mempty)
10:07:18 <lambdafan> pikajude: was that directed to me?
10:07:22 <pikajude> no
10:07:24 <pikajude> i'm reading your code
10:07:59 <pikajude> lambdafan: if you're operating on tokens, you can use `Data.Text.all isAlphaNum` as said before
10:09:18 <pikajude> lambdafan: although, those all look like single characters
10:09:56 <Cooler> pikajude, what does folding have to do with filtering?
10:10:15 <pikajude> Cooler: "Thinking cap time. Write a filter function for Foldable types using foldMap."
10:10:38 <lambdafan> pikajude: yes, I am operating on a single character at a time
10:10:44 <Cooler> pikajude, what does folding have to do with filtering?
10:10:54 <pikajude> no idea
10:11:37 <Cooler> i don't understand this it'd be foldMap (\ x -> if myPredicate x then pure x else mempty)
10:12:28 <pikajude> that expression has type (Applicative f, Monoid (f a), Foldable t) => t a -> f a
10:13:06 <Cooler> :t foldMap
10:13:08 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
10:13:20 <Cooler> where did you get applicative from?
10:13:25 <pikajude> from pure
10:13:46 <Cooler> wat
10:14:00 <pikajude> pure :: Applicative f => a -> f a
10:14:17 <Cooler> theres no applicative constraint so how are you using pure?
10:14:52 <lyxia> Cooler: there is in the type of filterF
10:15:18 <pikajude> yeah, I don't think you can write it without using Applicative (or Pointed)
10:15:28 <Cooler> yeah but thats applying to f in f a
10:15:30 <pikajude> because neither Foldable nor Monoid gives you a -> f a
10:16:12 <lyxia> Cooler: t a -> f a is more general than t a -> t a
10:16:18 <EvanR> by filter you mean, take a foldable and output a list?
10:16:29 <Cooler> yes
10:16:30 <pikajude> EvanR, if i understand correctly, it's take a foldable and return the same foldable
10:16:32 <Cooler> no
10:16:36 <Cooler> not a list
10:16:39 <EvanR> foldable doesnt let you put the thing back together in any way
10:16:42 <pikajude> right
10:17:02 <Cooler> EvanR, exactly so what does foldMap have to do with this
10:17:05 <Cooler> ?
10:17:05 <pikajude> so the best you can do is require that the input is also a Monoid and additionally provide some way to `wrap` a single value
10:17:22 <pikajude> foldMap just maps a function a -> m over every element of the Foldable and concatenates them
10:17:43 <EvanR> there is a typeclass based on traversible which has some attempt at laws that filter should follow
10:17:48 <pikajude> and the reason it's relevant here is because it's the only method of Foldable that lets you return a maybe-nothing result for an item
10:18:01 <pikajude> i.e. mempty
10:18:07 <EvanR> without that, its not clear what a filter should do with a non-list
10:18:16 <pikajude> right
10:19:35 <EvanR> singleton plus monoiding together doesnt sound like its any better than returning a list
10:19:53 <pikajude> fairly slow too
10:20:36 <EvanR> thats sort of the mentality behind "a type class for a generic container, you can get stuff out of it, and put stuff in it"
10:20:37 <Cooler> so whats the specialized type for foldMap here?
10:21:03 <pikajude> it depends on what kind of Foldable you're operating on
10:21:06 <EvanR> it sounds good in the board room but mathematically its not clear what its supposed to do
10:21:14 <pikajude> board room, lol
10:21:16 <Cooler> (a -> f a) -> f a -> f a?
10:21:47 <EvanR> it canna be done with foldable
10:21:54 <pikajude> EvanR: we're adding monoid and applicative
10:21:55 <Cooler> foldMap :: (Applicative f, Foldable f, Monoid (f a)) => (a -> f a) -> f a -> f a?
10:22:02 <EvanR> ._.
10:22:05 <pikajude> Cooler: i think so
10:22:19 <EvanR> this is a different kind of foldMap ?
10:22:26 <EvanR> thats not a specialization
10:22:37 <pikajude> EvanR: no, we're specializing m to f a
10:22:37 <johnw> :t foldMap
10:22:41 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
10:22:44 <pikajude> in the type of foldMap
10:22:48 <pikajude> or rather, `t a` in that case
10:23:27 <ertes> Recursive and Corecursive from recursion-schemes are the most generic container classes i know
10:23:28 <EvanR> so were answering a different question
10:23:45 <ertes> anything that is a fixed point could be an instance
10:24:14 <EvanR> ertes: i was just thinking, "someone will arrive at the conclusion that everything is a recursive algebraic type"
10:24:37 <EvanR> and go from there what container means
10:24:40 <ertes> EvanR: put my remark into the "acme" category =)
10:25:15 <ertes> amusing side note: that rules out Vector =)
10:25:22 <EvanR> it does get stuff done when you settle on "everything is X", but thats not necessarily generic
10:25:50 <EvanR> like when everything is one of the js types, and its dynamically typed. but its not generic
10:26:57 <ertes> or the classic: "everything is an object"
10:27:04 <ertes> whatever that actually means
10:27:17 <EvanR> Object the top class in java
10:29:28 <bennofs1> EvanR: and then there is 'int' and 'int[]' :)
10:30:23 <dolio> ertes: Vector is isomorphic to a recursive algebraic type.
10:30:49 <nitrix> It's worse when your language has theorically only a single type like PHP's Any and does dynamic classification to pretend it has a type system.
10:33:06 <EvanR> infinite vectors?
10:34:06 <EvanR> guess we can pretend its eager, inductive 
10:34:21 <pheaver_> I'm trying to get code coverage results from my application (I am using stack). I build with the ghc option -fhpc, and when I stack exec my application, it produces .mix files in a random dir under ./.hpc, but no .tix files.
10:35:38 <pheaver_> It's not clear to me from the documentation or running the hpc program if a .tix file should be generated by my program or via some hpc command.
10:36:22 <mbw> Hello everyone. Are there any "fusion laws" regarding zipWith operations, i.e. something similar to fusing folds and maps, or two successive folds over the same data structure (banana split theorem)?
10:36:59 <mbw> For instance if I have scalarProd xs ys = sum . zipWith (*) xs $ ys.
10:37:03 <chreekat> pheaver_: have you looked at https://docs.haskellstack.org/en/stable/coverage/ ?
10:37:24 <pheaver_> yes, i wasn't sure if it was applicable to me
10:37:36 <pheaver_> my tests are blackbox tests in a separate standalone application
10:37:38 <lyxia> mbw: zipWith f (map g x) (map f y) = zipWith (\a b -> f (g a) (h b)) x y ?
10:37:45 <pheaver_> i want code coverage in the application when i run my tests against it.
10:37:55 <pheaver_> i tried the --coverage flag but didn't get any .hpc files
10:37:57 <lyxia> mbw: oops I meant to write map h y rather than map f y
10:38:23 <lyxia> mbw: map f (zipWith g x y) = zipWith (\a b -> f (g a b)) x y ?
10:38:45 <lyxia> mbw: is that the kind of thing you're looking for
10:39:31 <chreekat> pheaver_: ah, dunno, unless that 2nd bullet point in the doc applies to you
10:39:40 <digitalmentat> is there a better channel to ask questions about speeding up compilation of a custom GHC compiler?
10:39:59 <mbw> lyxia: Yes, something along those lines. While I don't have a specific optimization problem right now, I find the known "laws" quite helpful in understanding algorithms and converting from a quick and dirty haskell prototype to an imperative one for example. Is there any literature regarding zips?
10:40:25 <pheaver_> yeah that bullet does not apply to me (and many others, i'm sure)
10:41:28 <pheaver_> oh, a .mix file is generated when *compiling*
10:42:59 <lyxia> mbw: unfortunately I have no idea
10:43:54 <lyxia> mbw: the things I wrote are probably instances of the free theorem of the type of zipWith
10:44:14 <lyxia> mbw: Theorems for free! by Phil Wadler explains these.
10:44:43 <mbw> I think I looked into this paper and found it quite dense.
10:44:48 <lyxia> It is.
10:44:51 <mbw> :(
10:45:46 <dolio> @free zw :: (a -> b -> c) -> F a -> F b -> F c
10:45:46 <lambdabot> (forall x. h . k x = p (f x) . g) => $map_F h . zw k y = zw p ($map_F f y) . $map_F g
10:46:35 <lyxia> TIL @free
10:47:05 <mbw> @free fmap :: (a -> b) -> F a -> F b
10:47:05 <lambdabot> g . h = k . f => $map_F g . fmap h = fmap k . $map_F f
10:47:46 <mbw> Is map_F the fmap instance of F?
10:48:02 <dolio> Yes, it assumes F is a functor, and $map_F is its mapping operation.
10:48:16 <mbw> This is some cool stuff.
10:50:13 <mbw> Alright, thanks lyxia & dolio. I shall meditate on what I have learned.
10:55:48 <thatguy> I want to work with graphs, is it good practice to define a graph class and define some basic properties it should have (list of nodes, are-these-adjacent-function, ..) and define a lot of standard implementations for functions like number of nodes?
10:57:45 <lyxia> If you want to try out many representations that seems alright.
10:57:52 <lyxia> thatguy: have you looked at fgl
10:58:14 <thatguy> is that a graph library?
10:58:26 <lyxia> yup, it does more or less what you said
10:58:33 <thatguy> I somehow have the feeling I should start off with implementing the stuff myself to get a real feeling how to work with haskell
10:58:42 <thatguy> lyxia, ah ok I will have a look at it
10:58:45 <thatguy> thanks for the help
11:06:13 <old1101> hello, lists concatenations are O(n) correct? Why this single-linked list can't save a pointer to the last element? So it can be O(1)
11:06:52 <pikajude> if you want O(1) append you can use DList
11:07:24 <monochrom> Our lists are immutable. This means concatenation creates a new list, not butcher the old list.
11:07:35 <pikajude> or you can use Seq i think
11:07:44 <pikajude> which is a finger tree that retains "pointers" to both ends
11:08:31 <monochrom> Pointer-to-last could be useful for read-only operations such as "what is the last guy" but I wouldn't want it for concatenation.
11:10:20 <old1101> pikajude: I'll have a read on finger trees
11:10:57 <old1101> monochrom: concat creates a new list? It doesn't goes all the way (O(n) to the end and append a new item?
11:11:13 <shapr> finger trees are awesome
11:11:21 <monochrom> Creates a new list.
11:11:43 <monochrom> You can easily test this.
11:11:50 <monochrom> Define x = [1,2,3].
11:11:57 <monochrom> Now ask about x ++ [4,5,6].
11:12:09 <monochrom> Now ask about x again. Has it changed?
11:12:58 <madknight> are all functors in haskell are endofunctors?
11:13:16 <Tuplanolla> Concatenation doesn't have to touch the tail of the second list, old1101. You can't really talk about "a new list" since there's sharing involved.
11:13:46 <monochrom> But it is the prefix in question, Tuplanolla.
11:13:51 <old1101> monochrom: I can't see the differente between x ++ [1] and 1 : x both seems to be concats
11:14:03 <pikajude> one adds 1 to the end, the other adds it to the beginning
11:14:06 <monochrom> I can.
11:14:12 <digitalmentat> is Austin Siep in this channel? or any other GHC maintainer?
11:14:15 <byorgey> madknight: instance of Functor can be thought of as endofunctors on the category of Haskell types and functions between them, yes
11:14:15 <monochrom> > [4,5,6] ++ [1]
11:14:18 <lambdabot>  [4,5,6,1]
11:14:19 <old1101> pikajude: yes, but one takes (1) and another (n)
11:14:22 <monochrom> > 1 : [4,5,6]
11:14:24 <lambdabot>  [1,4,5,6]
11:14:27 <pikajude> old1101: sorry?
11:14:29 <monochrom> Not equal.
11:14:35 <roundhouse> Hi, I'm trying to upload the documentation generated by stack via haddock to github-pages. I use "stack path" to get the local-doc-root string to locate the docs. It works on my computer, but on travis-ci it spits out "`/home/travis/.stack/global-project/.stack-work/install/x86_64-linux/lts-8.2/8.0.2/doc/*'" (a global doc folder). Anyone know how to do this properly?
11:14:53 <byorgey> madknight: modulo the fact that due to issues with laziness/strictness this is not quite a well-defined category.  But close enough.
11:15:04 <old1101> "The list type is a single-linked list. As such, prepend, head and tail are all O(1). However, ++ is O(n) in the size of the left-hand list."
11:15:04 <monochrom> It is as though someone is saying, "addition is faster than multiplication!"
11:15:15 <pikajude> > [1] ++ [4,5,6] == 1 : [4,5,6]
11:15:18 <lambdabot>  True
11:15:23 <madknight> byorgey: thx
11:16:43 <old1101> pikajude: the results are the same, ok. But I've read that prepend is O(1) and append is O(n)
11:16:59 <pikajude> @src (++)
11:16:59 <lambdabot> []     ++ ys = ys
11:17:00 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
11:17:00 <lambdabot> -- OR
11:17:00 <lambdabot> xs ++ ys = foldr (:) ys xs
11:17:09 <pikajude> ^ why (++) is O(n)
11:17:20 <byorgey> pikajude: it is O(n) in the size of the first argument.
11:17:24 <pikajude> right
11:17:41 <monochrom> [1] ++ [4,5,6] is going to be O(n = 1).
11:17:57 <old1101> true
11:18:26 <old1101> so, you always have the head pointer, why it cannot have the tail pointer?
11:18:44 <madknight> @src (<$>)
11:18:45 <lambdabot> f <$> a = fmap f a
11:18:46 <byorgey> digitalmentat: Austin goes by the nick thoughtpolice 
11:18:58 <digitalmentat> byorgey, thanks :)
11:19:01 <monochrom> It is almost useless for immutable lists.
11:19:06 <digitalmentat> (I also just found #ghc, so asking in there)
11:19:22 <pikajude> old1101: a singly linked list is structured `Cons element1 (Cons element2 (Cons element ... Nil))`
11:19:46 <pikajude> how would you get ahold of a tail pointer?
11:20:12 <byorgey> digitalmentat: yep, #ghc is a good place to ask about GHC-specific questions.  Just be patient, someone might not see your question immediately but it you will probably get a repsonse eventually
11:20:37 <byorgey> oh, I see you already got a response, excellent =)
11:21:17 <monochrom> It is also important to distinguish the C++ and Java kind of "list object" from the Haskell kind of "list (no object)".
11:21:28 <monochrom> (Even after ignoring mutable vs immutable)
11:22:02 <monochrom> In Java for example, you begin with an object of two fields, head and tail. Then head points to a chain of nodes, and tail points to the last node.
11:22:19 <monochrom> In Haskell we don't have that object part. We just have that chain of nodes.
11:22:51 <monochrom> Note that in Java again, the chain has no pointer-to-last. Only the wrapper object does.
11:22:58 <old1101>  pikajude: you wouldn't hahah, I get it now. thanks
11:24:13 <monochrom> It is possible to say, in Haskell, why doesn't every node has a pointer-to-last? Especially with immutability, this extra field needs only be set once at initialization, and never needs update.
11:24:56 <monochrom> But now you have a 133% blow up of space footprint and pointer-to-last isn't all that useful.
11:26:47 <old1101> monochrom: makes a lot of sense. thank you
11:27:58 <Tuplanolla> Note that you can still have your mutable pointer tricks, but you have to isolate that stuff to `ST` or `IO`, old1101.
11:28:01 <pikajude> fun fact: [] is the pointer-to-last of *every* list
11:28:36 <monochrom> Naw, we don't mean that by pointer-to-last.
11:28:43 <pikajude> ok, fair
11:28:48 <monochrom> "The answer is nil" is too easy!
11:28:58 <pikajude> no easy answers here!
11:29:26 <old1101> Tuplanolla: oh, I'll see this
11:29:56 <old1101> thank you guys, I need to go bye :))
11:34:24 <johnw> I finally have a definite and legitimate need for Data.Reflection!  achievement gained
11:36:53 <dolio> Nah, there are no legitimate uses. :P
11:36:56 <mlev> Can anyone help me with http://stackoverflow.com/questions/42424530/haskell-applicative-functor-instance-error-cannot-construct-the-infinite-ty
11:37:09 <johnw> dolio: I've been waiting years for this, don't take it away now!
11:37:39 <pikajude> johnw: you used it to implement a REST interface, didn't you
11:38:01 <johnw> no, I'm using it to feed auxiliary data to a suite of Arbitrary instances, to influence how data is generated
11:38:14 <pikajude> pshh
11:39:00 <monochrom> That is a gray area.
11:42:42 <hexagoxel> mlev: i think `r` has a higher-ranked type and you need to add a type signature for it.
11:44:04 <hexagoxel> because `g` is used twice, with different specializations
11:45:17 <Phillemann> Using "deriving(Generic)" together with "instance ToJSON" is very handy, but I have two structures, both having a member "url". Can I have them both without explicitly defining the ToJSON instance?
11:46:57 <mlev> hexagonal:  What would a simple instantiation of <*> be for Foo in that case?  I.e. f <*> a = ...
11:47:17 <mlev> Sorry, meant hexagoxel*
11:47:52 <hexagoxel> mlev: just inline `r` even if you need to write `field*` twice that way.
11:49:27 <mlev> hexagoxel:  I'm a bit of a newbie, what would that line of code look like with inlining r?
11:50:08 <hexagoxel> Foo (field1 f $ field1 a) (field2 f $ field2 a)
11:52:59 <mlev> hexagoxel:  Great, thank you very much!
11:55:28 <marekw2143> hi, here: https://bitbucket.org/chessRepo/c7/src/bc2e6456b98520afc7b7122398b75c93de770403/main.hs?at=master&fileviewer=file-view-default#main.hs-81
11:55:43 <marekw2143> I'm getting following error: main.hs:81:11: parse error on input ‘=’
11:55:51 <marekw2143> could somebody tell me what's wrong ? 
11:56:29 <hexagoxel> :t (/=)
11:56:36 <lambdabot> Eq a => a -> a -> Bool
11:56:43 <hexagoxel> :t (!=)
11:56:44 <kadoban> marekw2143: == ?
11:56:46 <lambdabot> error:
11:56:46 <lambdabot>     • Variable not in scope: !=
11:56:46 <lambdabot>     • Perhaps you meant one of these:
11:56:52 <marekw2143> oh, ok 
11:56:57 <marekw2143> kadoban, thanks
11:57:37 <kadoban> Anytime. By the way you can use a 'case' there, not that it really matters.
12:00:52 <marekw2143> it seems that monads are not the strongest "value" of the Haskell language
12:00:57 <marekw2143> but the type system 
12:02:01 <geekosaur> define "strongest"
12:02:07 <mnoonan> I can't speak for everybody, but the type system and immutability together keep me more honest.
12:02:40 <geekosaur> personally I'd say Cont is the one that really shows its strength... name another language in which call/cc doesn't need runtime hooks
12:03:01 <geekosaur> or other language suport
12:03:49 <marekw2143> geekosaur, well, feature which has greater impact of writing maintenable code 
12:03:56 <marekw2143> *greatest
12:04:12 <geekosaur> that certainly rules Cont out :p
12:04:29 <marekw2143> Cont ? 
12:04:52 <kadoban> It's a specific Monad that's quite ... powerful and a bit crazy.
12:05:16 <marekw2143> it's related to "reactive programming " ? 
12:06:55 <kadoban> Not really. I don't know it well enough to summarize it well I bet, never quite used it for anything practical.
12:07:28 <Tuplanolla> "Functional go-to".
12:08:47 <geekosaur> a great way to confuse people
12:09:12 <lloydy> Hi. Can anyone offer help with an issue I have installing Haskell Platform please?
12:13:14 <Akii> lloydy: just ask ^^
12:15:21 <lloydy> I have installed Haskell Platform on Win 10 and when I try to run WinGHCi I get an error saying There is no disk in drive D. It cannot be cancelled or continued other than through Task Manager. I've tried un/reinstalling in several different ways; same thing. Google says others have had same issue and some have got round it by installing through PowerShell. I know nothing about this. Would be 
12:15:22 <lloydy> grateful for guidance with PowerShell or other suggestions for getting Haskell to work on Windows.
12:35:27 <kuribas> When linking, does ghc include all the functions in a module, or just the ones that are used?
12:35:41 <monochrom> Usually all of a module.
12:35:50 <kuribas> Wouldn't that lead to bloat?
12:36:22 <monochrom> -split-objs can help
12:38:29 <kuribas> For example, if I specialize to several usefull types (for example Double and Float), it would always include those.
12:38:42 <monochrom> Yes.
12:38:47 <jpl> Cabal question: Is there any way to compile just a single file in a project?
12:39:01 <kuribas> monochrom: ok, I'll look at -split-objs
12:40:00 <kuribas> monochrom: well, about compilation time, I could do this only for production binaries.
12:42:03 <monochrom> -split-objs has to be applied early. That is, suppose I am writing an exe and I want to use your library. Then I have to have compiled your library with -split-objs in the first place. It is not for compiling or linking my exe.
12:43:14 <monochrom> IIRC libraries that come with GHC were already built with -split-objs. But it is not a cabal default.
12:44:20 <johnw> dolio: http://newartisans.com/2017/02/a-case-of-reflection/
12:44:56 <kuribas> monochrom: or I could use INLINABLE ...
12:47:30 <kuribas> monochrom: the disadvantage would be that a user will be required to write a SPECIALIZE pragma if he wants the optimizations.
12:48:29 <kuribas> I am also experimenting with SSE, but it seems SSE support is very limited in ghc.
12:48:56 <kuribas> The easiest is to use the FFI to write SSE code in C.
12:49:37 <kuribas> Ghc doesn't support all SSE instructions, and it only works with a particular version of LLVM.
12:57:04 <kuribas> SSE with rewrite rules and specialize pragmas would be quite powerfull.
12:57:24 <kuribas> It seems most haskell users aren't really concerned with raw speed.
13:05:30 <Tuplanolla> That's because laziness is such a hassle, kuribas.
13:05:56 <Tuplanolla> If I'm already working on a problem I hardly understand, having to reason about thunks is too much.
13:06:28 <kuribas> Tuplanolla: yeah, the first thing when you need performance is to eliminate lazyness...
13:06:54 <geekosaur> not always
13:06:55 <kuribas> Tuplanolla: core can show when ghc makes a function strict.
13:06:56 <Tuplanolla> Not even everywhere, but in strategic places.
13:07:10 <geekosaur> that's the real problem; elimiate laziness in the wrong place and perf can easily get worse
13:07:19 <Zemyla> Okay, so WTF.
13:07:40 <geekosaur> but people always want something where a simpleminded rule like "eliminate laziness" will fix everything
13:08:38 <shapr> geekosaur: that usually does work, stop being lazy and learn more stuff!
13:08:39 <davean> laziness makes a lot of performance a lot easier, like not having to rewrite your algs to have them work together efficiently
13:08:55 <kuribas> For things like numeric code, matrix computations, etc... a sequential style will give better performance
13:09:26 <Tuplanolla> Suddenly CUDA.
13:09:44 <maerwald> davean: ? it's mostly just incredibly hard to reason about in a larger context
13:10:01 <kuribas> Tuplanolla: but you have to be carefull with latency etc...
13:10:12 <davean> maerwald: it allows composittion
13:10:22 <maerwald> I don't need laziness for composition
13:10:22 <Tuplanolla> Fortunately that's not my job.
13:10:26 <lpaste_> Zemyla pasted “Can't configure containers GitHub fork for tests and benchmarks” at http://lpaste.net/352920
13:10:58 <davean> maerwald: I'd like to see you get alg composition without it or rewriting each alg into one every time! that would be a neat trick
13:11:05 <Zemyla> cabal says they're all there, but that they're missing D:
13:11:59 <kuribas> lazyness is great from a higher-level point of view, but for low level number crunching, sequential is easier...
13:12:14 <kuribas> The extra indirection from lazyness comes with a cost.
13:12:48 <SLi> More than CPU performance, I've always had problems with space. When the input to my program is even somewhat large (example: parsing a few megabytes worth of lispish structure and outputting the same in a different format), I always seem to run into the resulting program eating hundreds of megabytes or gigabytes, and the reason is always hard to find (with the heap profiling tools I'm aware of).
13:13:08 <SLi> I wonder if using -XStrict and using laziness where I want it would help.
13:13:34 <Zemyla> ezyang: Do you know what the problem might be, why it can't find these things I've explicitly installed?
13:13:36 <shapr> SLi: in my experience, strictifying the data in records is the easy fix
13:14:02 <kuribas> SLi: you aren't using String, or lazy IO are you?
13:14:10 <SLi> shapr: That's what I usually do after getting frustrated with profiling, sprinkle ! and deepseq around in the hope that it helps :D
13:15:56 <shapr> SLi: yeah, that's the shotgun debugging fix for me
13:15:59 <SLi> kuribas: Hmm, I think I have been using lazy IO. And in some cases String when I've been too lazy to switch to ByteString. Would that explain? Why does it cause such a huge effect? :) I've thought of String as something that is mostly very slow, but not inherently memory hungry.
13:17:04 <SLi> shapr: But then there's so many possible places for ! and deepseq that it's frustrating... which makes me think I should try -XStrict and explicit laziness annotations.
13:17:47 <kuribas> SLi: I'd try that first in any case.  Lazy IO is known to be not very efficient.
13:18:00 <shapr> yeah, but that gets fixed by pipes and that sort of thing, yeah?
13:20:53 <thatguy> is there a way to write the elem function so that it works on infinite lists?
13:21:26 <Tuplanolla> > 42 `elem` [1 ..]
13:21:30 <lambdabot>  True
13:21:46 <Tuplanolla> Apparently, thatguy.
13:22:06 <thatguy> > -1 `elem` [1..]
13:22:13 <lambdabot>  mueval-core: Time limit exceeded
13:22:34 <kuribas> > isJust $ find (==42) [1..]
13:22:36 <lambdabot>  True
13:22:37 <glguy> thatguy: You can decide how much you're willing to search and 'take' that much of the list
13:23:19 <thatguy> What is the best practice way? I think my haskell tutorial said that you should try to avoid functions which can work infinitely long
13:23:26 <thatguy> or is there sometimes just no way around it?
13:23:48 <glguy> thatguy: You can avoid making infinite lists
13:24:03 <thatguy> glguy, are infinite lists considered bad style?
13:24:05 <thatguy> just out of interest
13:24:16 <Tuplanolla> You can't however will undecidable or semidecidable problems out out existence, thatguy.
13:24:20 <monochrom> No, it is good style.
13:24:35 <glguy> thatguy: You can use them, but it's important to know when you are
13:24:40 <monochrom> I disagree with "avoid functions which can work infinitely long".
13:25:08 <thatguy> I think the cis 194 lecture says it right at the beginning but maybe I am remembering wrong
13:25:41 <monochrom> "[1..]" can work infinitely long, yet we use "zip xxx [1..]" all the time.
13:26:32 <monochrom> And infinite lists (and also some functions that "can" work infinitely long) are indispensible for "piecemeal programming" which cis194 advocates.
13:26:54 <thatguy> ok so but it is not bad practice to write functions that cannot work with infinite lists (or would eventually take infinitely long) if I am sure I won't use infinite lists?
13:27:11 <thatguy> shouldn't then the data type somehow declare that this function is thought to be applied only to finite lists?
13:27:45 <glguy> No, Haskell's type system doesn't help you with that question
13:28:30 <glguy> Given even an Int, there's no guarantee that evaluation of it will finish
13:28:33 <monochrom> It is bad practice to cargo-cult, is all I'll say.
13:29:28 <thatguy> glguy, ok thanks
13:29:41 <thatguy> monochrom, I think the only term I've read is wholemeal programming :D
13:29:47 <thatguy> maybe I read it the wrong way
13:29:52 <thatguy> what is cargo-cult?
13:30:52 <monochrom> rules of thumbs.
13:31:06 <thatguy> ah and I also have a another question: a lot of functions just work for positive integers, not you could just let them return a Maybe X which is done in the tutorial, but why not make a new (declerative) type for positive integers
13:31:39 <lyxia> there is already one
13:31:49 <lyxia> nobody uses it
13:32:02 <thatguy> is there a reason?
13:32:04 <monochrom> oh, so it's called "wholemeal" not "piecemeal".
13:32:44 <thatguy> I thought the function types should be as declerative as possible
13:33:28 <thatguy> monochrom, I just mentioned it because I found it funny that it sounds like the exact opposite ;) didn't mean to be rude
13:33:28 <lyxia> It's not well known, and maybe just not worth the effort.
13:34:13 <monochrom> Don't worry, I just had to checked cis194 again.
13:34:53 <lyxia> thatguy: often the context is enough to tell whether it makes sense to call a function with negative numbers.
13:34:54 <monochrom> Do you also want a type for non-negative integers?
13:35:43 <xcmw> Which is better? binary, cereal, or store?
13:35:55 <mbrock> thatguy: such a number type can't implement the subtraction operator, because one positive integer minus another positive integer may not be a positive integer... it's a similar problem to trying to have a type for finite lists -- basically I think you end up needing to do some kind of theorem proving and everything becomes more complicated
13:36:34 <thatguy> I just thought that it somehow fits better into this haskell mindsetting. this "allowing some more inputs and then first checking them if they are ok" is what we are trying to avoid I thought
13:36:41 <mbrock> thatguy: but at some point you will probably look at dependently typed languages like Agda and Idris which allow you to formulate types that have all kinds of interesting membership criteria
13:36:51 <Clint> xcmw: i assume store because i've never tried it
13:37:37 <glguy> In Agda you'll still pay a steep price for trying to encode too much in your types
13:37:40 <thatguy> mbrcknl, I am just starting out in haskell :D I hope I can get into this language first
13:37:45 <glguy> it just gives you the rope to do that
13:38:04 <thatguy> allthough last time when I asked about n-dimensional fields also someone said that I need dependently typed languages I think
13:38:34 <mbrock> Haskell is kind of slowly and carefully adopting features from the dependently typed world
13:39:28 <mbrock> it's pretty interesting what kind of tradeoffs are involved in Haskell language design and evolution
13:40:22 <Tuplanolla> Does reasoning about type erasure become a problem in dependently-typed languages?
13:41:04 <thatguy> mbrock, I hope I stick to haskell long enough s.t. I start reading about the language design and trade offs
13:41:18 <thatguy> but first step is to get productive before I lose motivation and forget everything I learnt
13:41:21 <thatguy> which is my fear
13:41:28 <thatguy> thanks everyone for helping once again
13:45:11 <mbrock> sometimes I wish I could just load my Haskell code into Agda and do some proofs
13:45:11 <mbrock> (that's my digression, not really relevant to your questions thatguy)
13:45:11 <thatguy> mbrock, are you doing automatic theorem proving?
13:45:22 <mbrock> at the moment no, but I'm starting to really want to
13:46:14 <mbrock> or, well, even manual formal proving (Agda checks proofs automatically but writing them isn't very automatic)
13:46:25 <thatguy> is is actually of practical use at the moment for proving new unknown stuff or is it a theoretical field?
13:46:41 <thatguy> I know the logicians at my university are doing that kind of stuff but I myself have no experience
13:47:25 <mbrock> automated logic for verifying systems in a broad sense is very practical, for example chip manufacturers do it on huge scales to verify the correctness of CPUs and stuff (I have no experience with this)
13:48:28 <mbrock> but that's mostly not with dependent type languages and stuff, it's different formalisms more based on simple logic
13:49:08 <thatguy> ah I can imagine that
13:50:40 <cocreature> thatguy: http://www.nature.com/news/two-hundred-terabyte-maths-proof-is-largest-ever-1.19990 is one example of fully automated proofs
13:51:51 <thatguy> cocreature, thanks! I'll read it after my haskell practice session
13:52:08 <mbrock> at the moment I have a somewhat simple program that still ends up having many possible states. There are important properties of this program that I want to be sure of (and that I want others to be able to be sure of), and I can actually verify many such properties in quite a nice way using QuickCheck
13:52:59 <mbrock> QuickCheck is like proofs for lazy people: you give a theorem that you hope holds, and the tool just checks it for N random inputs
13:53:06 <thoughtpolice> This is a very good book on automated theorem proving: http://www.cl.cam.ac.uk/~jrh13/atp/. The author works at Intel on FPU verification. ATP is very popular in those areas, yes.
13:53:43 <thoughtpolice> And yes, it's often vastly easier. If you just want to "Upgrade" your QuickCheck properties to real proofs, I suggest something like Liquid Haskell. It's highly automated.
13:54:21 <monochrom> I love John Harrison.
13:54:39 <dmwit> Tuplanolla: Yes. Generally the reasoning is `const NotErased`, which really sucks, but there's plenty of research papers looking into how to do a good job of it.
13:54:52 <mbrock> but when the input starts to have lots of structure, it becomes harder to make sure that your arbitrary input generator generates relevant test cases, so you start to feel that even though 1000 test cases passed, maybe they just didn't trigger the relevant code paths
13:55:00 <monochrom> He actually theorem-prover'ed floating-point algorithms for sqrt sine etc for his PhD
13:55:08 <thoughtpolice> monochrom: It's a fantastic book. I wish he would write another.
13:55:11 <mbrock> so that's happening to me and it's making me want to just explicitly prove some of these properties
13:55:15 <Tuplanolla> That's interesting, dmwit. I've only written proofs with dt, so I haven't encountered these problems.
13:56:00 <mbrock> thoughtpolice: thanks for the recommendation, I will definitely see what Liquid Haskell can do in my case. It basically checks properties with an SMT solver, right?
13:56:35 <monochrom> He still maintains HOL-Light. And what he put into HOL-Light inspired improvements to HOL4.
13:56:52 <thoughtpolice> mbrock: Correct. The trick is being able to phrase things correctly in such a way the solver can reasonably find a solution. Sometimes this is tricky but for a lot of things, it's not bad.
13:57:03 <monochrom> I.e. the HOL4 people learned much about ease-of-use from him.
13:58:02 <shapr> Is there something like gopacket / scapy /etc for Haskell?
13:58:04 <thoughtpolice> Liquid Haskell also now allows explicit theorem proving, so you can use it as the hard-mode escape hatch, for lemmas or proofs of things that are not easily automated.
13:59:28 <thoughtpolice> monochrom: I haven't used HOL4, but I largely followed the code in his book and used HOL-Light. I've wanted to write a Haskell port of it for a while, now.
14:00:02 <thoughtpolice> HOL-Light proofs are often surprisingly nice to read IMO. The backtick quasiquoting works well for low 'overhead'.
14:00:32 <mbrock> oh, interesting. I experimented a tiny bit with the z3 SMT solver (using sbv), but I got scared when I realized that one of my core functions involves taking an arbitrary fixed point number to an arbitrary integer power (often large), which seems like quite a degenerate case of nonlinear arithmetic
14:01:28 <mbrock> which makes me think I will need to put in some lemmas...
14:01:53 <mbrock> (I'm super new to all this stuff)
14:02:00 <dmwit> mbrock: sbv may be able to do that for bounded exponents, but yeah I don't think it will be able to touch that on unbounded exponents.
14:02:05 <thoughtpolice> mbrock: Well, in that case, it's going to be difficult. You really are trying to quantify over arbitrary exponents, so yes, that's hard. I had similar kinds of issues but in my case I was able to relatively easily rephrase them.
14:02:17 <thoughtpolice> Z3 can do certain forms of nonlinear arithmetic, it's awesome like that. But yes that's a tricky one.
14:02:47 <mbrock> I could probably just limit it to 1000 or whatever
14:02:48 <monochrom> thoughtpolice: The backtick quasiquoting is an important feature of ML that is missing in Haskell. You will have an uphill battle because of this.
14:03:00 <dmwit> mbrock: http://hackage.haskell.org/package/sbv-5.15/docs/Data-SBV.html#g:20
14:03:17 <thoughtpolice> IIRC in my case I wanted to quantify over some inequality over 'any given sized bit integer' which was tricky. Instead I rephrased it as a property about an integer which is a simple numeric property that can later be constraint solved. This is a lot simpler.
14:05:51 <mbrock> dmwit: yeah, I'm gonna have to give that thing a try again :)
14:06:19 <thoughtpolice> monochrom: Yes, phrasing the UI is what is tricky. You either implement a full on parser and quasiquote whole blocks, or you quasiquote almost every other expression. Or you can do an eDSL directly, which comes with all its own problems.
14:09:28 <monochrom> thoughtpolice: http://www.mail-archive.com/haskell-cafe@haskell.org/msg09203.html :)
14:14:00 <mbrock> I wonder if I will run into trouble using LiquidHaskell on a program that's full of TH-generated record field lenses and whatnot
14:14:50 <mbrock> or probably because it works on Core it will be fine
14:15:14 <pikajude> Why does stack install a GHC when the correct version is already in scope?
14:15:58 <pikajude> hmm
14:16:01 <pikajude> maybe my assumption is incorrect
14:16:29 <Koterpillar> pikajude: you have to allow system GHC explicitly
14:16:34 <pikajude> how do I do that?
14:17:53 <Koterpillar> system-ghc: true
14:17:58 <Cale> mbrock: Is LiquidHaskell actually practical to run on anything which is of nontrivial length now?
14:17:59 <Koterpillar> in ~/.stack/config.yaml
14:18:09 <Koterpillar> pikajude: also see compiler-check
14:18:38 <pikajude> ok
14:18:41 <pikajude> thanks
14:19:14 <shapr> I wonder if a bunch of neat lenses on top of network-house would give me a friendly packet editing framework in Haskell?
14:19:20 * shapr considers
14:23:57 <mbrock> Cale: ah, I have no idea. My program isn't huge, but kind of just past non-trivial
14:34:48 * mbrock ponders "MIT Press eBooks aren’t supported on the Linux operating system."
14:35:33 <kadoban> mbrock: Probably some DRM thing?
14:35:39 <mbrock> yep
14:59:37 <adelbertc> are there any "advanced haskell" books folks would recommend? im pretty comfortable with FP, mostly concerned with familiarizng myself with haskell-specific stuff atm
15:02:06 <peddie> adelbertc: have you read Parallel and Concurrent Programming in Haskell?
15:02:16 <adelbertc> peddie: yep thats on my list
15:02:26 <adelbertc> was the only non-intro-to-haskell book i could find
15:03:10 <peddie> adelbertc: there are an awful lot of academic papers if you're interested
15:04:32 <adelbertc> peddie: yep :-) i've mostly been transliterating those into Scala, been trying to do more haskell recently. sounds like the parallel/concurrency book is mostly it
15:04:43 <adelbertc> thanks for your suggestion!
15:04:54 <peddie> adelbertc: or have a look through oleg's website http://okmij.org/ftp/Haskell/ 
15:05:00 <peddie> you're welcome, have fun :)
15:08:02 <doomrobo> Hi, I'm getting a GHC stage restriction error on this TH code but I don't understand why. It's very simple http://lpaste.net/352922
15:34:07 <c_wraith> doomrobo, welcome to TH. first major restriction: you can't use a splice defined in the same file. 
15:34:28 <doomrobo> c_wraith, haha yup I realized that. It worked when I made a new file
15:34:40 <doomrobo> but now I'm dealing with making the splice do the function definition part as well
15:35:16 <doomrobo> c_wraith, aaand that works now. But there's no type declaration. What gives?
15:36:00 <c_wraith> does the splice generate one? 
15:36:29 <doomrobo> nope. just generates a Q [Dec] via a FunD
15:37:08 <c_wraith> well... that would seem to explain it. 
15:37:23 <doomrobo> I thought top-level defs have to have type signatures
15:37:46 <c_wraith> no. - Wall warns if they don't, but it's not required. 
15:37:54 <c_wraith> err, -Wall
15:37:58 <doomrobo> ah, cool
15:39:36 <c_wraith> a common pattern in splices that generate functions at the top level is to intentionally leave out the type declaration. that gives you the chance to put in the type declaration explicitly, and put some haddock docs with it. 
16:09:08 <miscyb> i'm trying to use http-client, but my code stops executing when i reach an httpLbs call
16:09:37 <miscyb> it's working in an async thread, i have a bunch of print statements leading up to it but it just stops there
16:09:51 <miscyb> polling the async returns nothing so it's not done yet
16:09:57 <miscyb> anyone know how to debug this?
16:11:06 <miscyb> however if i wait on the async it runs correctly
16:33:24 <c_wraith> I'm very suspicious of the interaction between LBS and async 
16:40:46 <miscyb> c_wraith: i've tried a few different things here, polling in a forever, and just doing a "threadDelay 1000000" both work fine
16:41:05 <miscyb> to be more accurate i'm doing all of this inside MomentIO from reacive banana
16:41:13 <miscyb> but i don't think that should matter
16:42:40 <c_wraith> I don't know what is going on - I don't know either library well enough. what I do know is that LBS has very weird implicit concurrency properties that might interfere with what async is doing. 
17:08:38 <robertkennedy> Is there a way to have newtypes derive every class which is not a subclass of something? IE `newtype A typ = A typ hiding (Show)`
17:10:29 <Cale> No, any classes you want to derive have to be explicitly listed
17:13:19 <Welkin> EXPLICIT
17:13:32 <MarcelineVQ> gone wrong!
17:19:14 <robertkennedy> Is there a reason for that, or has it not been implemented?
17:25:47 <c_wraith> robertkennedy, a common reason for creating a newtype is to use *different* instances. 
17:28:11 <monochrom> Semantics tends to go wrong when you add features of "'everything' except what I list"
17:28:17 <robertkennedy> Right, but if you only wanted different instances for certain classes, you (or, I) currently use GeneralizedNewTypeDeriving, and it's not clear why that is limited by my foresight
17:28:51 <c_wraith> with StandaloneDeriving, it's not limited by your foresight. :) 
17:29:53 <robertkennedy> How so? Something like `deriving instance c a => c (A a)`?
17:30:17 <monochrom> The underlying phenomenon being: closed-world assumptions tend to break in an open world.
17:30:43 <c_wraith> no. I just mean you can notice an instance you'd like to GND is missing and add it with a single line. 
17:32:41 <robertkennedy> Well you can add `C` by adding it to your deriving instance. But that leads to classes having like `newtype A a = A a deriving (Ord, IsString, Num, Integral)`
17:33:48 <robertkennedy> (where A's goal is to modify `ToJSON`, say)
17:34:47 <robertkennedy> And then in a week you add RealFrac, and in a month you think to add ToSwagger, but decide you don't want your module to depend on swagger
17:36:30 <lordcirth> Anyone seen http://www.lamdu.org/ ?
17:43:44 <Zemyla> Oh, fuck. I think I know why the setup isn't working.
17:44:44 <Zemyla> The configure script is fucking running ghc-pkg dump -global, but it requires dump --global (note the double dashes).
17:52:36 <lordcirth> lol
17:55:26 <Zemyla> So what the hell do I do to fix this?
17:55:46 <lordcirth> Zemyla, well for now you could edit the configure script?
17:58:10 <Zemyla> lordcirth: No, because it's being launched from Distribution.Simple, which is an already-compiled package.
17:59:13 <dmwit> Fix whichever tool is calling it wrong.
17:59:21 <lordcirth> Zemyla, is it a bash configure script, in the sense of ./configure; make; make install?
18:00:27 <dmwit> But I, too, am a bit confused about the juxtaposition of "the configure script is running ghc-pkg dump -global" and "it's being launched from Distribution.Simple", which appear contradictory.
18:01:01 <Zemyla> lordcirth: No, it's a Setup.hs.
18:01:38 <Zemyla> Its script is basically "import Distribution.Simple; main = defaultMain"
18:01:45 <lordcirth> Zemyla, and this Setup.hs does not contain the actual string, "ghc-pkg dump -global"?  Where is this string being set?
18:02:29 <lordcirth> Use my fav debugging tool, grep -r :)
18:03:53 <Zemyla> lordcirth: https://www.haskell.org/cabal/release/latest/doc/API/Cabal/Distribution-Simple.html
18:04:53 <lordcirth> Zemyla, I don't see any reference to ghc-pkg
18:06:15 <Zemyla> It's somewhere in the source code.
18:08:47 <Zemyla> And then it turns out that was a red herring and all I had to do was add --user to it.
18:11:07 <sssilver> People still use the so-called Haskell in a world that already has Javascript. SAD!
18:13:25 <Welkin> ?
18:14:46 <hpc> heh
18:19:10 <halogenandtoast> I keep realizing that I probably misunderstand the Reader, Writer, and State monads. Are there any good practice problems I could try that would benefit from the usage of any of these so I can see it in the wild and in context?
18:19:22 <Welkin> Writer can be used for logging
18:19:28 <Welkin> Reader is used for "global state"
18:19:30 <Welkin> er
18:19:33 <Welkin> global constants
18:19:43 <Welkin> and state is for, well, state
18:19:57 <Welkin> I have never actually use writer for anything
18:20:14 <Welkin> I only used state as part of an exercise in making a toy example of a game
18:20:18 <Welkin> Reader is used a TON
18:20:22 <Welkin> in everything
18:20:26 <Welkin> every web app uses Reader
18:20:31 <Welkin> to store configuration
18:20:38 <Rotaerk> Reader can be used to accomplish something akin to what dependency injection frameworks do, but better
18:20:51 <Welkin> Rotaerk: no idea what dependency injection is
18:21:07 <Welkin> but I know it an Big Enterprise Bullshit term for Java
18:21:16 <Rotaerk> oh, some shitty bandwagon OO language users are riding
18:22:12 <sshine> Welkin, dependency injection is a neat concept, I think. not OO-specific.
18:24:54 <byorgey> Reader is not just for global configuration.  Given the 'local' function, it can be used for tracking a statically-scoped environment.  E.g. a value that changes or is extended when you recurse, but then is automatically restored to its previous value when the recursive call returns
18:25:08 <byorgey> so it shows up a lot when implementing things like e.g. typecheckers
18:27:03 <halogenandtoast> Hmm I'm trying to write a bunch of board games in Haskell, they of course have state, could benefit from logging, etc.
18:27:23 <sshine> halogenandtoast, ermagerd monerds!
18:27:27 <halogenandtoast> I keep wondering if I should try to force these monads in somehow, but I can't ever figure out how so I assume I misunderstand them
18:27:36 <halogenandtoast> dem monadz
18:28:09 <sshine> halogenandtoast, do without them first. write a bunch of functions with excessive parameters. then identify those parameters as certain monadic patterns.
18:29:56 <halogenandtoast> Right, I just don't know what those patterns are yet... I guess I want a tiny bit of hand-holding to say (You are doing x, try doing it with this Monad) to that end I'll paste some code and if someone wants to point me towards a reasonable monad I would be grateful
18:30:34 <Welkin> what is haogen and toast?
18:30:37 <Welkin> halogen
18:30:50 <halogenandtoast> https://gist.github.com/halogenandtoast/b92a1a12e981fa1e5e624d40f8c321e7
18:31:28 <halogenandtoast> A juxtaposition between something seemingly complex and something seemingly simple
18:31:41 <Welkin> halogenandtoast: oh, you live in tokyo?
18:31:49 <halogenandtoast> Welkin: yes
18:31:58 <Welkin> are you a contractor, do you run your own business, or are you a salaryman?
18:32:05 <halogenandtoast> I work for Cookpad
18:32:15 <halogenandtoast> So no, no, and not really.
18:32:39 <halogenandtoast> I work for the international team, so I don't have to follow any of the Japanese rules.
18:33:02 <halogenandtoast> I come to work in a t-shirt and jeans and go home well before 10pm.
18:34:00 <Welkin> no izakaya for you?
18:34:22 <halogenandtoast> Nope, haven't been to one yet.
18:34:29 <halogenandtoast> I mean not for work at least.
18:34:53 <Welkin> cool, I'd like to visit soon; I've wanted to go for years
18:35:02 <sshine> halogenandtoast, you might have a datatype GameState { hand :: [Card], deck :: [Card] } and a function housePlays :: GameState -> (GameState, Bool), and you might think such functions will become so common you'll make an alias for them: State GameState Bool.
18:36:12 <halogenandtoast> sshine: I don't understand housePlays (is this implying an AI, currently there isn't and won't be an AI)
18:36:42 <halogenandtoast> Welkin: I'd suggest visiting, especially if you like rice, noodles, and fish.
18:37:12 <Welkin> halogenandtoast: my number one place to visit is kyoto
18:37:18 <halogenandtoast> sshine: I also don't understand the Bool.
18:37:39 <ezyang> y'all missed ICFP last year! ;) 
18:37:49 <sshine> halogenandtoast, I was thinking of black-jack. the Bool is whether the house wins or loses. in black-jack the house plays quite deterministically. you could make some similar actions for a human player.
18:37:54 <Welkin> ezyang: it was in japan?
18:38:06 <ezyang> yeah, Nara 
18:38:19 <Welkin> oh cool http://conf.researchr.org/home/icfp-2016
18:38:38 <halogenandtoast> I missed ICFP as well :(
18:39:36 <halogenandtoast> Welkin: Kyoto is nice. I get bored with it quickly though, but I definitely suggest checking it out.
18:39:56 <halogenandtoast> It's also a day trip to Nara and the Inari Shrine
18:40:42 <Welkin> I just love all the architecture, historical clothing, bridges, gardens
18:40:48 <halogenandtoast> sshine: Ah yeah I see, would you use [Card] instead of type Deck = [Card]
18:41:10 <sshine> halogenandtoast, sure, I like type aliases.
18:42:01 <sshine> halogenandtoast, I mean, I'd go with Deck if I had to use it often and/or had to export it. :) makes replacing its implementation slightly easier.
18:42:21 <halogenandtoast> True, afk for lunch
19:09:02 <romanandreg> Has anyone tried out stack script functionality? https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md#script-interpreter
19:09:17 <robertkennedy> :t \f x y-> [f x, f y]
19:09:19 <lambdabot> (t1 -> t) -> t1 -> t1 -> [t]
19:09:19 <romanandreg> for some reason, my installed version (stack 1.3.2) doesn't have that sub-command
19:09:35 <romanandreg> does anyone have any insight around why?
19:09:42 <Koterpillar> romanandreg: I have, it works, show your script
19:10:29 <robertkennedy> :t (\f x y -> [f x, f y])
19:10:31 <lambdabot> (t1 -> t) -> t1 -> t1 -> [t]
19:11:06 <romanandreg> Koterpillar: I'm doing the example that downloads the turtle package
19:11:21 <romanandreg> and I'm getting this on the terminal: Invalid argument `script'
19:11:26 <romanandreg> Error executing interpreter command: stack script --package turtle -- +RTS -s -RTS ./script.hs
19:12:19 <romanandreg> this is the stack version: Version 1.3.2, Git revision 3f675146590da4f3edf768b89355f798229da2a5 (4395 commits) x86_64 hpack-0.15.0
19:12:27 <Koterpillar> https://docs.haskellstack.org/en/stable/GUIDE/#script-interpreter
19:12:53 <Koterpillar> see the command there
19:13:21 <romanandreg> ahh
19:13:28 <romanandreg> this is different from the documentation on github 
19:13:30 <romanandreg> that makes sense
19:13:58 <Koterpillar> this is the actual documentation site
19:14:03 <romanandreg> ok
19:14:13 <romanandreg> thanks for the heads up
19:14:23 <romanandreg> Hopefully they make the script sub-command
19:14:30 <romanandreg> it looks like it does a lot of stuff by default
19:14:52 <MarcelineVQ> script subcommand?
19:15:35 <romanandreg> MarcelineVQ: https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md#stack-configuration-for-scripts
19:16:49 <Koterpillar> I think it was removed in favor of explicit options
19:17:53 <robertkennedy> :t (\f x y -> [f x , f y] :: forall c x y b. ((c x, c y) => (forall a. c a => a -> b) -> x -> y -> [b]))
19:17:55 <lambdabot> error:
19:17:55 <lambdabot>     • Could not deduce: (c0 x, c0 y)
19:17:56 <lambdabot>       from the context: (c x, c y)
19:19:11 <sshine> @pl \f x y -> (f x, f y)
19:19:11 <lambdabot> flip =<< (((.) . (,)) .)
19:19:56 <sshine> meh.
19:20:58 <robertkennedy> Hmmm.. but I want to end up with `f x ~ f y`
19:24:07 <MarcelineVQ> isn't  f x ~ f y  already neccesarily true to typecheck [b]
19:24:30 <robertkennedy> Yes, and lambdabot failed to typecheck it
19:29:11 <glguy> robertkennedy: You have the type signature inside the lambda itself (among other issues)
19:30:55 <robertkennedy> glguy: are you saying that wrapping it will solve things?
19:31:06 <glguy> It's saying it *definitely* won't work if you don't :)
19:34:04 <robertkennedy> :t let g f x y = [f x, f y] in g :: forall c x y b. ((c x, c y) => (forall a. c a => a -> b) -> x -> y -> [b])
19:34:06 <lambdabot> error:
19:34:06 <lambdabot>     • Could not deduce: (c0 x, c0 y)
19:34:06 <lambdabot>       from the context: (c x, c y)
19:34:40 <romanandreg> Koterpillar: do you know how to load the script into ghci using stack?
19:34:41 <lpaste_> glguy pasted “for robertkennedy” at http://lpaste.net/352927
19:34:48 <glguy> robertkennedy: No, you can't add a rank2 type after the fact
19:34:54 <romanandreg> Koterpillar: the script that is shebanged
19:34:56 <glguy> You have to add that to the definition of 'g' directly
19:35:13 <Koterpillar> romanandreg: stack repl <file>
19:35:37 <romanandreg> magic!
19:35:41 <romanandreg> Koterpillar: thanks
19:35:41 <glguy> robertkennedy: and the type of 'g' is going to be ambiguous when you try to use it, so you have to add the AllowAmbiguousTypes extension
19:37:04 <maybefbi> what does the haskell runtime do?
19:37:04 <robertkennedy> tyvm will try this
19:41:33 <halogenandtoast> back
19:43:23 <robertkennedy> Do you feel like undecidable* and ambiguous* indicate bad practice?
19:56:34 <halogenandtoast> robertkennedy: I have no context but's I'd say llama triceratops.
19:56:34 <glguy> ?tell tommd How about this? F3 activates the status bar which only overflows to other lines when necessary, so for small situations it looks like the old UI
19:56:34 <lambdabot> Consider it noted.
19:56:47 <glguy> ?tell tommd http://imgur.com/a/TuVW3 (forgot the URL)
19:56:47 <lambdabot> Consider it noted.
20:00:53 <robertkennedy> @halogenandtoast http://lpaste.net/352927
20:00:53 <lambdabot> Unknown command, try @list
20:02:04 <halogenandtoast> robertkennedy: I can never read these kinds of things. Also for some reason I don't get notified if you prefix my name with an @
20:02:09 <halogenandtoast> I guess it isn't the IRC way
20:02:21 <glguy> The @ is for bot commands
20:05:10 <robertkennedy> Here you imagine some command like `example show 3 True == ["3","True"]`
20:05:42 <halogenandtoast> robertkennedy: I'm no expert so take what I say with a grain of salt (or several)
20:06:05 <halogenandtoast> but that seems convoluted to me, and the type signature doesn't give me the warm and fuzzies
20:06:43 <halogenandtoast> but I'm not a big fan of the forall stuff in the first place.
20:08:52 <lpaste_> glguy revised “for robertkennedy”: “fewer foralls” at http://lpaste.net/352927
20:09:58 <robertkennedy> ScopedTypedVariables is how I know to use type level data. Sorry for tbat
20:14:45 <jle`> huh _Just in microlens is a traversal and not a prism
20:14:47 <jle`> neat
20:15:24 <jle`> not neat as in useful but neat as in interesting interpretation
20:15:58 <jle`> but why not offer an actual prism.  is profunctors really that bad of a dependency
20:16:12 <jle`> i guess the whole point is to prevent dependency creep
20:43:14 <michbad> Sorry if this is off-topic, but I was wondering if anyone here applied for a Galois internship and heard anything back?
20:45:14 <glguy> I know that there's a team of people working through the resumes. I don't know if they sent out any announcements yet. They waited for the deadline to wrap up before making any decisions and there were quite a few applicants to sort through
20:47:32 <michbad> Thanks glguy.
20:49:58 <Welkin> what's the point of interns?
20:50:07 <Welkin> seems like cheap (and low quality) labor to me
20:50:16 <Welkin> exploitation
20:50:26 <glguy> Nope, not that
20:51:08 <glguy> It's common that someone is in school and wants a short-term bit of of experience working in a field they're interested in. For example over a summer break from school
20:51:27 <Welkin> I never was able to find an internship like that
20:51:39 <Welkin> I didn't know wtf they were looking for
20:51:42 <Welkin> it wasn't obvious
20:51:42 <glguy> internships offer a way for people in that situation to make some money and get some experience relevant to the field they want to work in
20:51:49 <Welkin> seemed like they wanted cheap labor
20:52:27 <Welkin> I worked in a high tech research lab for a little more than minimum wage one summer
21:03:05 <nshepperd> huh, the prisms in lens are all made using 'prism' combinator
21:03:40 <glguy> nshepperd: What did you have in mind?
21:04:16 <nshepperd> I was wondering if there was some 'direct' way like with Lenses '_1 f (a,b) = (,b) <$> f a'
21:04:23 <jle`> there is a way
21:04:32 <jle`> you can just inline prism's definition, heh
21:04:53 <jle`> (that's what i do fwiw)
21:04:53 <glguy> nshepperd: I see. Also note that that's not the definition for _1 but rather for _1' !
21:05:12 <jle`> it's actually not too tricky if you follow the types
21:05:14 <glguy> GHC is pretty good at inlining prism's definition
21:07:10 <nshepperd> hmm, lemme try expanding out prism's definition and see if the result is at all nice
21:11:56 <nshepperd> I guess that's not much different, I still end up writing a getter and a setter
21:15:03 <buttons840> I'm having trouble finding documentation for the Spock function `text`, it is exported from Web.Spock, yet it is not listed in that modules hadock documentation anywhere -- when I got some information from GHCI, it says "Defined in ‘Spock-core-0.12.0.0:Web.Spock.Internal.CoreAction’", but CoreAction is not listed on hackage or stackage -- any suggestions?
21:17:29 <buttons840> or maybe I need to step back and ask what web frameworks people recommend using?
21:17:31 <MarcelineVQ> the Spock-core part is referencing another pacakge
21:17:45 <MarcelineVQ> it's a dependency of Spock http://hackage.haskell.org/package/Spock-core
21:18:11 <buttons840> MarcelineVQ: https://hackage.haskell.org/package/Spock-core-0.12.0.0 -- yeah, I couldn't find the CoreAction module though
21:19:00 <buttons840> like, the word "CoreAction" does not appear on that page you linked
21:19:35 <MarcelineVQ> it's not exposed but it exists, http://hackage.haskell.org/package/Spock-core-0.12.0.0/src/
21:20:26 <nshepperd> buttons840: https://github.com/agrafix/Spock/blob/master/Spock-core/src/Web/Spock/Internal/CoreAction.hs#L275
21:20:47 <nshepperd> it's exported by Web.Spock.Action
21:21:29 <dijonmustard> Is every Foldable a Monoid?
21:21:29 <nshepperd> ehm, here http://hackage.haskell.org/package/Spock-core-0.12.0.0/docs/Web-Spock-Action.html#v:text
21:21:48 <dolio> No.
21:22:03 <Sornaensis> :info Foldable
21:22:09 <Sornaensis> @src Foldable
21:22:10 <lambdabot> Source not found. :(
21:22:27 <Sornaensis> @hoogle Foldable
21:22:30 <lambdabot> Prelude class Foldable t
21:22:30 <lambdabot> module Data.Foldable
21:22:30 <lambdabot> Data.Foldable class Foldable t
21:22:53 <dijonmustard> Ok. I was reading the hackage page and they have foldMap f Empty = mempty for a Tree
21:23:51 <buttons840> MarcelineVQ: what do you mean by not exposed? as a Spock user I can use the text function, and it seems like an important part of the library?
21:24:25 <MarcelineVQ> I just meant that module isn't directly exposedfor import
21:26:13 <buttons840> ok
21:26:30 <dijonmustard> Oh, so you can either define foldMap or foldr, and foldMap requires the type to be a Monoid but foldr doesn't
21:26:43 <nshepperd> dijonmustard: foldMap :: (Foldable f, Monoid m) => (a -> m) -> f a -> m'
21:26:50 <buttons840> if I do "import X" in a haskell library, are all the functions defined in X automatically re-exported from my module?
21:26:55 <ezyang> no 
21:27:07 <Koterpillar> buttons840: you have to list X in your 'module' statement
21:28:29 <nshepperd> dijonmustard: foldMap produces some output for you, from the "contents" of the foldable value. the output can be anything you like, as long as it's a monoid
21:28:49 <nshepperd> because the monoid tells foldmap how to combine the contents together
21:29:34 <dijonmustard> Ok I get it now. Thanks!
21:29:59 <nshepperd> the alternative is to use something like foldr which uses a combining function and a 'zero value' instead
21:30:32 <nshepperd> which serves basically the same purpose as the monoid
21:57:12 <piyush-kurur> sha1 collided https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html
21:57:35 <piyush-kurur> if you have not yet heard that is.
21:58:03 * geekosaur had heard but was a little more worried about the cloudflare thing, esp. given haskell.org etc. use it
21:58:10 <geekosaur> (asked in -infra, but no response yet)
21:59:36 <piyush-kurur> geekosaur: Linus has been adamant about changing sha1 in git
21:59:55 <geekosaur> gt has a specific problem there
22:00:05 <geekosaur> sha1 hashes are what tie the whole thing together
22:00:06 <piyush-kurur> although it is still "safe" the way it is used in git, I think it is a problem
22:00:52 <geekosaur> fixing existing repos will more or less require export/reimport, and *every remote checkout will break*
22:01:29 <piyush-kurur> what are folks planning to do about github repositories ?
22:01:33 <geekosaur> basically, there is no "quick fix" for git; it's going to have to be very carefully planned and executed
22:02:45 <piyush-kurur> I hate this
22:03:37 <geekosaur> and a repo will pretty much have to be migrated along with all clones everywhere all at once, because the way patches get identified is the sha1 hash --- if you migrate some clones, others won't be able to commit or pull or ... until they also migrate
22:04:12 <geekosaur> (well, comit but the commit won't be able to go upstream and potentially might need to be undone and redone with new hash before it can)
22:04:27 <geekosaur> really, this is a major mess for git
22:04:31 <MarcelineVQ> sha1 for commits is a fingerprint rather than a security measure, will it matter?
22:04:50 <geekosaur> that's why linus is sitting tight for now
22:05:09 <piyush-kurur> MarcelineVQ: not so much but still problem in settings like commit signing
22:05:16 <geekosaur> no security implications (where security is involved they use gpg signing, iirc)
22:05:28 <geekosaur> but the fingerprint is what identifies a commit *everywhere*
22:05:42 <geekosaur> you can;t change it and it's not designed for upgrading
22:06:02 <piyush-kurur> time for a haskell clone of git I guess
22:06:21 <MarcelineVQ> we could call it something cool, like darcs
22:06:27 <geekosaur> heh
22:07:07 <jle`> attack is called 'shattered'. cute
22:09:23 <piyush-kurur> MarcelineVQ: I still have lots of love for darcs but you know the network effect.
22:09:45 <piyush-kurur> darcs will have its day I am sure of that
22:10:08 <piyush-kurur> like the way Haskell now has become almost mainstream
22:13:10 <nshepperd_> Hm, migrating git repositories will break existing signed commits
22:13:22 <nshepperd_> That's a bit sad
22:19:35 <nshepperd_> Oh, i suppose not if they do it in such a way that the old sha1 based objects can be mechanically recovered.
22:20:46 <geekosaur> I *think* they're literally just hashes of the commit + author etc. info, so it should be recoverable, yes
22:20:53 <geekosaur> it'll be really slow though
22:21:23 <geekosaur> like darcs2 on a darcs1/old hash repo, before they removed old hash support (pretty much the same situation except they also changed what they hashed iirc?)
22:23:37 <geekosaur> and ... github's going to be screwed regardless, I suspect, but especially if they handle migration by on the fly rehashing
22:23:44 <geekosaur> their load'll go through the root
22:23:46 <geekosaur> *roof
22:25:38 <geekosaur> in any case, there's no quick patch answer because sha1 hashes are so central to the whole git model and pretty much eveyr option sucks horribly one way or another
22:26:34 <geekosaur> (also it has occurred to me that this *does* have security implications, but I think it best to hold that one close for now)
22:27:16 <nshepperd_> The commit contains hashes of parent commits and blobs etc. It's one giant merkle tree
22:27:30 <geekosaur> yep
22:27:50 <pikhq> Mercifully, that does also make attacks rather harder to achieve.
22:28:06 <nshepperd_> Oh, you could keep the old sha1 hashes around actually, then it would no slower than now
22:28:22 <pikhq> Still, pretty imperative to move away from SHA-1 *before* the attack gets extended enough to make git break.
22:28:52 <geekosaur> mm, looks like reddit's already on the case anyway
22:40:48 <athan> @ask ski Have you looked into Curry?
22:40:48 <lambdabot> Consider it noted.
22:40:51 <athan> :v!!
22:41:13 <JuanDaugherty> he undoubtedly has
22:43:22 <athan> JuanDaugherty: Have you? He mentioned Oz to me recently, but I feel like it's a bit out of my league
22:44:40 <JuanDaugherty> yes, they (Curry) have a channel here (assume that's what you meant by have I). Oz is new to me or have forgotten
22:45:14 <JuanDaugherty> i.e., they the main implementation in de
22:45:53 <JuanDaugherty> PAKCS igess
22:47:53 <JuanDaugherty> ('undoubtedly' by virtue of his connection with prolog)
22:49:40 <athan> oh hm, I was hoping the haskell implementation was up to date, but it still seems very cool
22:50:20 <athan> hopefully I'll have more constructive questions soon :) and it appears the freenode #curry channel is a bit unused :\
22:51:12 <athan> thank you for all of your advice JuanDaugherty
22:51:16 <JuanDaugherty> np
22:55:12 <halogenandtoast> athan: By Oz do you mean the programming language?
22:55:16 <athan> Do you use Curry often JuanDaugherty? Sorry if this is annoying :) I'm just interested in how it manages its method to computation
22:55:25 <athan> halogenandtoast: Yep, and the mozart implementation
22:55:31 <halogenandtoast> Oh man I used that in college.
22:55:43 <athan> :O shoot, I need to catch up
22:55:49 <halogenandtoast> I was actually just talking about it today with someone.
22:55:54 <athan> it seems interesting, but I'm too spoiled with Haskell :\
22:56:06 <athan> halogenandtoast: what were you talking about? :)
22:56:25 <halogenandtoast> athan: Emacs
22:56:35 <halogenandtoast> How I was first introduced to emacs through Mozart
22:56:43 <athan> o_o wow!
22:56:44 <JuanDaugherty> athan, no and no I'm not annoyed. It's not a practical general purpose lang in the sense hs is, but it is interesting to me for work in the prolog/hs intersection
22:56:45 <halogenandtoast> Although I'm a vim user now.
22:57:17 <athan> JuanDaugherty: That's how I feel too - the simple idea that `foo (bar x) = x` simply "works" in amazing to me
22:57:32 <athan> in the same light that idris' dependent types are cool
22:57:54 <athan> halogenandtoast: heh, have you tried spacemacs? It's been... a bit bloated, but convenient for me
22:58:15 <halogenandtoast> athan: I did, decided I didn't like it, and took the time to configure my emacs by hand.
22:58:30 <halogenandtoast> Got rid of the bloat
22:59:29 <halogenandtoast> athan: my config if you care: https://gist.github.com/halogenandtoast/e512470e0f77e925b60ad3b4ae92ca36
23:00:51 <athan> halogenandtoast: I still can't appreciate elisp, but thank you :) I'll keep it in my stash
23:01:28 <halogenandtoast> athan: Oh I love lisp, in the same way Haskell's functional purity is a thing of beauty, so is lisps's syntax to me.
23:01:40 <halogenandtoast> All you get is the s-exp
23:01:57 <halogenandtoast> well that and macros, but macros are godly
23:02:10 <athan> halogenandtoast: would you be willing to discuss this with me in #lisp? I am a noob ._.
23:03:10 <halogenandtoast> I have migrated there
23:03:15 * athan just doesn't want to pollute this channel with UNCLEAN :P
23:32:38 <halogenandtoast> I've decided I'd rather be in the haskell channel than the lisp channel :(
23:34:41 <halogenandtoast> At least here I know what I don't know (which is everything).
23:51:32 <piyush-kurur> raaz now hides SHA1 as much as possible (good that collision happened before release date).
23:52:03 <piyush-kurur> https://github.com/raaz-crypto/raaz/commit/3e3c4847fcd6b7457027aa00feb49c5c04e0a6c4
23:53:23 <halogenandtoast> Good on them.
23:56:38 <athan> yuno sha-3 p_p
