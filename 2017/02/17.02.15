00:00:12 <Cooler> Test2 is a data constructor that takes an array of Test?
00:00:29 <pavonia> Cooler: The right-hand side is a list of data constructors with possible parameters ... yes
00:00:36 <opqdonut> SwiftsNamesake: there's #haskell-stack
00:00:51 <SwiftsNamesake> alright thx
00:00:52 <pavonia> Cooler: Note that [...] is a *list* not an array
00:00:56 <SwiftsNamesake> I'll be off then
00:01:14 <Cooler> pavonia, whats the difference
00:01:28 <mroman> The data/type constructor.
00:01:40 <pavonia> Lists are singly-linked, arrays are random access
00:02:37 <pavonia> i.e. accessing a random element of a list is O(n) in Haskell
00:05:43 <Cooler> is this ok for JSON datatype?
00:05:44 <Cooler> data JValue = String | Num | JObject | JArray [JValue] | True | False | Null
00:05:45 <Cooler> type JObject = [(String, JValue)]
00:06:07 <cocreature> Cooler: Map String JValue would be more appropriate for JObject
00:06:13 <cocreature> Cooler: otherwise you can have duplicate keys
00:06:21 <pavonia> True and False are already of type Bool
00:06:23 <Cooler> oh its a set?
00:06:39 <cocreature> what is a set?
00:06:56 <cocreature> json specifies that keys have to be unique iirc
00:07:42 <cocreature> Cooler: you can also take a look at the type aeson uses https://hackage.haskell.org/package/aeson-1.1.0.0/docs/Data-Aeson.html#t:Value
00:08:12 <Cooler> what about the True and False thing?
00:08:49 <Cooler> data JValue = String | Num | JObject | JArray [JValue] | Bool | Null
00:09:02 <liste> Cooler: that'd define a value named Bool
00:09:14 <liste> so you can do "myValue = Bool"
00:09:35 <Cooler> ok so how do you incorporate the existing Bool?
00:09:42 <cocreature> Cooler: you probably want something like "data JValue = JString String | JNum Double | JObject JObject | JArray [JValue] | JBool Bool | Null"
00:10:37 <Cooler> JObject Jobject really?
00:11:17 <cocreature> Cooler: the first JObject is the constructor name, the second is the type of the value associated with that constructor
00:11:24 <cocreature> it’s like JArray [JValue]
00:11:43 <Cooler> this all seems very verbose
00:11:43 <cocreature> you can reuse the name JObject because constructors and types life in different namespaces
00:12:39 <Cooler> so if you want to make a sum type of existing types you need to create new data constructors
00:12:40 <Cooler> ?
00:12:45 <cocreature> yep
00:13:27 <cocreature> Cooler: imagine if you had something like "data X = A Int | B Int" the constructor names are absolutely necessary here because both branches have the same type associated with them
00:14:10 <Cooler> right
00:18:15 <SwiftsNamesake> I'm not having any luck on the haskell-stack channel
00:50:02 <BernhardPosselt> suppose you had to explain higher kinded types to a bunch of java programmers, how would you do it?
00:50:37 <SwiftsNamesake> Use generics?
00:50:58 <SwiftsNamesake> with multiple type arguments
00:52:39 <BernhardPosselt> i cant come up with anything useful that they would like to use but cant because generics do not support higher kinds 
00:52:40 <exio4> BernhardPosselt: my method tends to be "using what they know to show that is limited and how this comes here to solve it"
00:53:39 <BernhardPosselt> only thing ive found so far which seems pretty simple is 
00:53:41 <BernhardPosselt> public class Foo<T> {
00:53:41 <BernhardPosselt>     public T<String> bar() { return null; }
00:53:41 <BernhardPosselt> }
00:54:02 <BernhardPosselt> but I'm unsure if this looks like a useful idea :)
00:55:34 <exio4> BernhardPosselt: there is going to be a point where they can't do it directly in Java though
00:55:40 <exio4> and that's where things get messy
00:56:54 <liste> BernhardPosselt: maybe talk about things you can express with HKTs?
00:57:50 <liste> ie. abstracting over both Optional and List
00:58:10 <BernhardPosselt> without having to supply concrete type parameters?
00:58:15 <liste> yes
00:58:19 <BernhardPosselt> i see
00:58:31 <BernhardPosselt> so basically using raw types safely
00:59:14 <BernhardPosselt> raw type = List instead of List<String>
01:17:59 <BernhardPosselt> ok, i'll probably let them implement Monad as an interface
01:18:05 <BernhardPosselt> because i give up xD
01:19:16 <reactormonk> cocreature, it always complained.
01:19:36 <reactormonk> ... about having multiple records in the sum type with the same record name.
01:36:24 <ongy> https://hackage.haskell.org/package/transformers-0.4.2.0/docs/Control-Monad-IO-Class.html is this what I want to include to support MonadIO?
01:37:09 <ongy> The path looks a bit weird and it's not linked in the newest version of transformers
01:39:39 <Faucelme> :ongy Control.Monad.IO.Class is included in the latest versions of "base", no more need for "transformers" to get it.
01:40:13 <Faucelme> https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Monad-IO-Class.html
01:44:16 <gameer> hey. I have a short question. I have a BinTree data structure. ( "data BinTree a = Empty | Fork a (BinTree a) (BinTree a)"  ) I have to checker whether a given BinTree is a search Tree ( left child smaller than node and right child bigger than node) 
01:44:34 <gameer> How can I compare my node with a child?
01:45:36 <gameer> My idea was to check and if left child is bigger I can return False and if it is smaller I recall the function with the left child (same with right side biger/smaller than the node)
01:56:44 <pavonia> gameer: What does it mean to compare a node with its child? Is the minimum/maximum child value important, or the immediate children's nodes?
01:57:33 <gameer> I would say the immediate children's node
01:58:40 <gameer> I thought it like: 
01:58:53 <gameer> isTreeSearchTree = 
01:59:15 <gameer> hm I do it on a code- site
02:00:41 <gameer> Oh, I have an idea, I will try it myself at first
02:01:33 <sjpet> Hello. Anyone in here on friendly terms with Text.Regex, specifically the proper use of RegexContext?
02:05:09 <pavonia> sjpet: Do you have a more specific question?
02:06:12 <sjpet> pavonia: I'm trying to define a function like this:
02:06:26 <sjpet> matchCompiledRe :: String -> ByteString -> ByteString
02:06:46 <sjpet> matchCompiledRe re = match (makeRegex re)
02:07:04 <sjpet> but that results in ambiguous type variables
02:07:55 <Fredrik_> Hi! I'm experimenting with c2hs from cabal. But get the following error after the c2hs build step: File name does not match module name: Saw: `Main` Expected: `NSO.FFI`. 
02:08:12 <Fredrik_> But when looking at the generated .hs file, the module looks ok
02:08:50 <sjpet> I have previously used just "makeRegex re" to pre-compile my regexes and then "match compiledRe s" when matching them, and that worked just fine
02:09:13 <pavonia> sjpet: What the type of \re -> match (makeRegex re)?
02:09:22 <pavonia> *What's
02:10:20 <pavonia> Fredrik_: The module name in the .hs file is NSO.FFI?
02:11:06 <Fredrik_> yes, I have NSO/FFI.chs
02:11:09 <sjpet> pavonia: \re -> match (makeRegex re)
02:11:20 <Fredrik_> and the output is in .stack-work/dist/x86_64-osx/Cabal-1.24.2.0/build/NSO/FFI.hs
02:11:36 <sjpet> :: (RegexContext regex source target, RegexMaker regex compOpt execOpt source1) =>
02:11:42 <sjpet> source1 -> source -> target
02:11:48 <pavonia> Fredrik_: No, what's the name in the file "module ... where"?
02:12:13 <Fredrik_>  module NSO.FFI where
02:12:24 <pavonia> Okay, that's weird
02:12:32 <Fredrik_> yea, that is what I think as well :)
02:13:03 <Fredrik_> I'll see if I can do the steps manually and see if there is anything else I goofed
02:13:32 <pavonia> sjpet: Could you paste your code at lpaste.net with the full error?
02:14:53 <Fredrik_> Sure!
02:15:55 <Fredrik_> the chs: http://lpaste.net/352541
02:18:22 <pavonia> Fredrik_: Err sorry, this was for sjpet. I don't know what the problem could be in your case
02:18:49 <Fredrik_> aha, sorry :)
02:22:38 <sjpet> pavonia: http://lpaste.net/352542
02:26:55 <pavonia> sjpet: I think you have to give a type annotation for "makeRegex re"
02:28:31 <sjpet> pavonia: That was indeed it! the type was implied the way I did it before, but not in this one. Thank you!
02:28:50 <pavonia> No problem
02:49:02 <UnoDos> Hello
02:49:20 <chenyu> Hello UnoDos 
02:50:29 <UnoDos> is this channel only for Haskell? Because it seems to be the most populated channel on FreeNode.
02:53:58 <opqdonut> UnoDos: yes
02:54:23 <ahihi2> there are multiple larger channels though
02:55:59 <UnoDos> Ok thank you very much.Goodluck with your programming and have a great day further.
02:56:31 <opqdonut> :D
02:56:33 <opqdonut> lovely
03:19:19 <janos> :D
03:24:49 <Cooler> what does ! mean?
03:25:09 <Ke> nonlazy evaluation
03:25:33 <kwak_> I'm watching Bartosz Milewski's lectures on category theory, but in a category in which objects are types,I don't understand why morphisms would be functions. Function in Haskell map values right ?
03:25:34 <merijn> It means it gets evaluated to weak head normal form (WHNF)
03:26:00 <merijn> kwak_: In Hask (the category of Haskell types) objects are types and functions map types to other types
03:26:20 <merijn> kwak_: So we have a Bool object and an Int object and "Bool -> Int" is a morphism from Bool to Int
03:27:20 <merijn> kwak_: Note that Haskell values aren't relevant in the Hask category
03:27:26 <kwak_> so if there exist multiple functions with type Bool -> Int, then there would be multiple arrows from Bool to Int ?
03:27:31 <merijn> kwak_: Yes
03:28:02 <kwak_> Ok I thought that was impossible, I guess I missed something in the explanation
03:28:14 <quchen> Morphisms are the Haskell values
03:28:32 <kwak_> quchen: what do you mean ?
03:28:39 <CoolerZ> what does ! mean here? https://hackage.haskell.org/package/aeson-1.1.0.0/docs/src/Data-Aeson-Types-Internal.html#Value
03:28:48 <quchen> … up to isomorphism, so »1« would be the morphism »\() -> 1«
03:29:36 <kwak_> oh ok
03:30:11 <kwak_> CoolerZ: It means that the Object value in the Object constructor is evaluated to WHNF at the construction
03:30:24 <quchen> kwak_: Well, morphisms are the values of Haskell, and morphisms are mappings between the objects of Hask. This means that all values must be mappings, but »1« isn’t a mapping, but fortunately we can cheat by saying »\_ -> 1« is the same as »1«.
03:30:45 <quchen> So we can assign a function (morphism) to all values.
03:30:55 <orion> quchen: So any haskell value which isn't a function is a morphism from unit to the type of said value?
03:30:58 <kwak_> CoolerZ: So when `Object someLongExpressionWithTypeObject` is evaluated, `someLongExpressionWithTypeObject` is evaluated to WHNF directly
03:31:02 <BernhardPosselt> could i create a typeclass that works on Maybe and not Maybe a?
03:31:45 <BernhardPosselt> or asked differently: could i create a list of Maybe without having to specifiy Maybe's type parameter=
03:31:46 <tsahyt> merijn: yesterday you were mentioning that <|> always introduces possible backtracking in attoparsec. in what I'm parsing I'm currently using choice a lot, but I could in theory decide on the current byte which sub parser to use. So, how bad is <|> really?
03:31:46 <BernhardPosselt> e.g.
03:31:49 <quchen> orion: Not necessarily unit. The »Int« object has lots of arrows going into it.
03:31:54 <BernhardPosselt> [Maybe]
03:31:59 <tsahyt> merijn: for now I opted for it because it makes writing the parser very easy
03:32:08 <quchen> orion: \Nothing -> 1   ← also a morphism equivalent to 1
03:32:17 <tsahyt> but my memory usage on even just a 3MB input is awful
03:32:28 <BernhardPosselt> or do i always have to specify the type parameter?
03:32:43 <BernhardPosselt> e.g. [Maybe a]
03:32:59 <orion> quchen: So the morphism for all non-function values is: a -> Whatever ?
03:33:20 <quchen> Yup
03:34:03 <quchen> orion: Well, not all non-function values, all values.
03:35:16 <quchen> There is an object »Int -> Bool« in Hask. »const True« is a value of that type, and one morphism going to our object is »\(x :: Char) -> const True«.
03:36:20 <quchen> BernhardPosselt: Lists can only contain values of types of kind *. Maybe has kind * -> *. In other words: no.
03:36:59 <orion> quchen: I see, thanks.
03:37:24 <orion> Has anyone tried to build store-0.3 with GHC 8.0.2?
03:37:36 <BernhardPosselt> quchen: ty
03:37:37 <quchen> orion: There is no shortage of arrows in Hask ;-)
03:38:11 <BernhardPosselt> so basically function signatures also require the kinds to line up
03:38:20 <BernhardPosselt> apart from the type
03:38:32 <quchen> Yup, values have to typecheck, and types have to kindcheck.
03:39:15 <quchen> And kinds always kindcheck because everything we have is of sort BOX. And since we ran out of synonyms for »type« we couldn’t name the type-of-sorts, so we stopped here, and declared that »three levels are enough«.
03:41:17 <BernhardPosselt> so phrased differently: HKT allow you to type check kinds and therefore use them safely
03:41:51 <BernhardPosselt> which i suppose allows you to add more constraints than without HKT
03:42:36 <mpiechotka> Hi. Is there a way to simplify in lenses: over (a . b) f . over a g?
03:42:41 <merijn> tsahyt: You can't always afford <|> if your protocol has choices
03:42:51 <merijn> tsahyt: eh, s/afford/avoid
03:43:17 <CoolerZ> can someone explain what Object !Object means here? https://hackage.haskell.org/package/aeson-1.1.0.0/docs/src/Data-Aeson-Types-Internal.html#Value
03:43:19 <merijn> tsahyt: Define "memory usage is awful"?
03:43:25 <BernhardPosselt> e.g. for Functor allow you to enforce that the same functor kind? that is supplied is being returned
03:43:35 <tsahyt> merijn: goes up to about 500MB according to +s
03:43:40 <quchen> BernhardPosselt: Higher-kinded types just mean that we have them, not that we can use them safely I guess. But in Haskell, we both have them, and they are safe.
03:43:56 <merijn> tsahyt: Can you lpaste the result of "+RTS -sstderr"?
03:43:56 <tsahyt> reading in a strict bytestring, parsing it, serializing it using byte string builders, writing back a lazy bytestring to another file
03:44:09 <quchen> BernhardPosselt: If we just left the kindchecker away then who knows what would be possible. Statically typed, dynamically kinded programming languages maybe? ;-)
03:44:22 <BernhardPosselt> for instance Functor f => (a -> b) -> f a -> f b
03:44:23 <alexbiehl> tsahyt: can you show code?
03:44:37 <BernhardPosselt> it would be hard to enforche f a -> f b without HKT
03:44:44 <tsahyt> alexbiehl: sure, it's on github. here's the parser https://github.com/tsahyt/midi-simple/blob/master/src/Sound/MIDI/Parser.hs
03:44:52 <BernhardPosselt> as in that f is the same Functor instance
03:45:05 <mpiechotka> (Sorry - over a g . over (a . b) f)
03:45:26 <mbrock> I've got a big record for a state, and each field has a `HasX` typeclass (thanks to lens).  I use those typeclasses with parametricity to write monadic actions whose state access is limited to specific fields.  But I find myself also wanting to limit actions to reading instead of writing certain fields.  I imagine I could somehow shuffle the values between
03:45:26 <mbrock> the State and a Reader environment, and I wonder if this is a known pattern
03:45:57 <tsahyt> merijn: the test data I have here now is a bit smaller, just 2.1M. here's the output of -s http://sprunge.us/DCSX
03:46:14 <tsahyt> merijn: what's -sstderr?
03:46:21 <tsahyt> isn't that just -s on a different stream?
03:46:28 <merijn> tsahyt: Maybe, probably :p
03:46:46 <merijn> tsahyt: Ah, you're looking at the wrong thing
03:46:56 <tsahyt> looks like it, yeah
03:47:05 <merijn> tsahyt: 500 MB is the "data copied during GC"
03:47:15 <tsahyt> merijn: no, on the bigger file it was total memory in use
03:47:20 <merijn> The actual usage is "max residency", which is 98MB (admittedly still high)
03:47:47 <tsahyt> but I had that in /tmp and so its gone after the last reboot and I just generated some new data with a midi keyboard
03:47:52 <CoolerZ> can someone explain what Object !Object means here? https://hackage.haskell.org/package/aeson-1.1.0.0/docs/src/Data-Aeson-Types-Internal.html#Value
03:48:10 <tsahyt> merijn: in any case, 98M of max residency is still way too much for a 2M file
03:48:17 <merijn> tsahyt: Agreed :)
03:48:35 <CoolerZ> what does ! mean?
03:48:47 <merijn> tsahyt: Also 48% GC time is worrying
03:49:08 <merijn> tsahyt: Can you get a heap profile and paste that + code?
03:49:32 <tsahyt> merijn: https://github.com/tsahyt/midi-simple/blob/master/src/Sound/MIDI/Parser.hs
03:49:40 <tsahyt> I've had a heap profile this morning, hold on
03:49:51 <tsahyt> or I'll just do a new one to make sure that it's actually on the same data
03:50:25 <tsahyt> is the svg output from hp2pretty okay or do you want the .hp file?
03:50:30 <Logio> CoolerZ: ! makes the field strict instead of lazy
03:50:36 <merijn> tsahyt: Let's satart with the SVG
03:50:45 <merijn> tsahyt: Also style note
03:50:46 <CoolerZ> Logio, something about weak head normal form?
03:50:51 <Logio> yeah
03:50:56 <CoolerZ> what is it?
03:51:01 <tsahyt> style note?
03:51:01 <quchen> CoolerZ: Consider »data Foo = Foo ()«. This gives you a data constructor »MkFoo :: () -> Foo; MkFoo = \x -> Foo x«. The »!«makes the definition of MkFoo strict in its argument, equivalent to writing »MKfOO = \x -> x `seq` Foo x«.
03:51:06 <merijn> You can replace "word8 0xF8 *> pure TimingClock" with "TimingClock <$ word8 0xF8"
03:51:16 <merijn> :t (<$)
03:51:18 <lambdabot> Functor f => a -> f b -> f a
03:51:21 <tsahyt> oh yeah, I missed that
03:52:06 <tsahyt> merijn: the heap profile: https://u.teknik.io/c6flf.svg
03:52:57 <quchen> CoolerZ: Haskell Report on the matter: https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-710004.2.1
03:53:28 <CoolerZ> so in data Foo x = Foo !x    ! makes sure x gets evaluated before constructing Foo?
03:54:18 <Logio> up to WHNF, yes
03:55:25 <merijn> tsahyt: That looks...suspicious, but I need to run for lunch now
03:55:51 <tsahyt> okay, I'll do the same
03:55:55 <merijn> I think there's another text profile that'd be useful with cost centers, but I don't recall the exact arguments
03:58:23 <CoolerZ> what do you mean upto WHNF?
04:00:05 <quchen> WHNF is »evaluated enough so you can case-match on it«.
04:00:57 <quchen> The WHNF of a »Maybe a« value is evaluating it enough to decide whether it’s a Just or a Nothing, but not what’s in the Just.
04:01:21 <quchen> So »Just (1+1)« is in WHNF.
04:01:55 <quchen> »if True then Just 1 else Just 1« is not in WHNF, because it requires evaluation to case-match on it.
04:04:57 <CoolerZ> quchen, ok so why do you think they used ! here? https://hackage.haskell.org/package/aeson-1.1.0.0/docs/src/Data-Aeson-Types-Internal.html#Value
04:06:34 <quchen> CoolerZ: So that values of type Value are always forced in memory (not thunks, not infinite and so on).
04:06:50 <quchen> In other words, performance considerations.
04:08:48 <CoolerZ> if i want a list of key value pairs like json objects
04:08:55 <CoolerZ> do i use HashMap
04:09:04 <CoolerZ> or Data.Map?
04:09:09 <CoolerZ> or something else/
04:09:11 <CoolerZ> ?
04:10:59 <quchen> Both are good defaults.
04:11:15 <quchen> Depends on how many you have, how expensive your hash is and so on.
04:11:37 <quchen> But in general both should be sufficiently fast, and fairly easily switched out if you need the other.
04:15:51 <CoolerZ> Deprecated: HashMap is deprecated. Please use Map instead.
04:15:55 <CoolerZ> https://hackage.haskell.org/package/hashmap-1.3.2/docs/Data-HashMap.html
04:16:42 <sbrg> @package unordered-containers
04:16:42 <lambdabot> http://hackage.haskell.org/package/unordered-containers
04:17:02 <sbrg> CoolerZ: ^
04:37:44 <mpiechotka> \quit
05:11:55 <orion> If you had to pick an ec2 instance to build GHC as quickly as possible, would you choose compute optimized or memory optimized?
05:12:28 <drdo> Test both
05:21:43 <quchen> How fast do you need to build GHC? It doesn’t take that long even on my laptop
05:23:55 <orion> I am building GHC in an emulated ARM environment, and my Core i7 with 16GB of memory takes over 24 hours.
05:24:21 <orion> (Using qemu-arm-static)
05:26:14 <ertes> orion: emulating ARM on non-ARM is bound to be horribly slow
05:26:39 <orion> ertes: Right, that's why I want to buy an EC2 instance to speed up the build.
05:27:56 <ertes> orion: any real ARM machine will be an improvement…  a cheap option would be to buy a *pi
05:28:20 <orion> ertes: No pi can build GHC.
05:28:24 <orion> There's not enough memory.
05:28:54 <ertes> isn't it possible to add memory?
05:29:03 <orion> No.
05:29:17 <ertes> have you tried cross-compilation?
05:29:28 <quchen> The Raspi isn’t large enough to fit a RAM module ;-)
05:29:34 <cocreature> there are hosters where you can rent ARM servers
05:29:47 <eklavya> in parsec when using choice is it correct that choice stages keep on consuming input and that is not available to the subsequent choice stages?
05:30:57 <orion> ertes: Cross-compilation isn't helpful. I need Template Haskell to do anything useful.
05:32:25 <cocreature> orion: scaleway has 4 core arm servers. they only have 2gb ram but a 50gb ssd so with swap it might not be too bad
05:33:34 <orion> I've heard of packages on hackage requiring over 5 GB of memory.
05:33:43 <cocreature> that’s why you need swap :)
05:33:47 <orion> eww
05:34:06 <orion> So slow.
05:34:30 <cocreature> I would expect it to still be faster than emulating arm on top of x86
05:34:39 <EckT> i used stack to install ghc on my rpi
05:34:39 <ertes> orion: no, i mean cross-compile GHC itself
05:34:41 <EckT> it worked
05:34:52 <EckT> you need an external hdd as swap tho
05:35:42 <ertes> orion: i would probably try to make it work with nix…  currently it doesn't support GHC on any supported ARM
05:36:41 <orion> ertes: Cross-compiling with host=x86_64 and target=arm will leave me with a neutered GHC incapable of compiling any packages that require TH.
05:37:24 <ertes> orion: IIRC GHC has three architecture settings:  build host, host and target
05:37:32 <ertes> host and target would be ARM in your case
05:38:33 <orion_> The darkness of humanity seeps from this bottomless pitch-back hole, the gap filled by the accumulation of the curse.
05:38:36 <orion_> The darkness of humanity seeps from this bottomless pitch-back hole, the gap filled by the accumulation of the curse.
05:38:39 <orion_> The darkness of humanity seeps from this bottomless pitch-back hole, the gap filled by the accumulation of the curse.
05:38:42 <orion_> The darkness of humanity seeps from this bottomless pitch-back hole, the gap filled by the accumulation of the curse.
05:38:59 <ongy> erm orion was that orion_ you?
05:39:03 <orion> No.
05:40:20 <orion> ertes: If the host and target are the same, are you actually cross-compiling?
05:40:35 <ertes> orion: only GHC
05:40:47 <ertes> your actual projects aren't cross-compiled
05:41:35 <ertes> orion: for example if i do the following i get a GHC that itself runs on darwin and builds for darwin, while i'm on linux…  that makes linux the build host, and darwin the host and target:  nix-build "<nixpkgs>" --argstr system x86_64-darwin -A ghc
05:41:48 <orion> ertes: But I can't build GHC with host=ARM unless I'm already on ARM.
05:41:51 <ertes> (not sure if "build host" is the right term)
05:42:06 <eklavya> I find it counter intuitive that <|> would let each stage consume input, shouldn't it be retrying with the whole input for each parser? I found try which solves this but still
05:43:33 <orion> ertes: Could you paste the contents of <libdir>/ghc-x.y.z/settings for your cross-compiled GHC?
05:43:40 <ertes> orion: https://ghc.haskell.org/trac/ghc/wiki/CrossCompilation
05:43:51 <ertes> orion: sure, gimme a moment
05:44:21 <ertes> orion: (if it's in the build output)
05:45:31 <ertes> eklavya: http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
05:47:36 <eklavya> wow “No wonder Parsec gets such a bad rep about its error handling.”, I chose parsec over attoparsec because a 99 upvotes answer on stackoverflow said choose parsec if you need good error messages :D
05:48:42 <lpaste_> ertes pasted “GHC build settings” at http://lpaste.net/352547
05:48:51 <ertes> orion: ^
05:49:35 <orion> Thanks,.
05:50:34 <ertes> orion: my build came out of the cache, so i don't know whether actual GHC cross-compilation was going on when hydra built it, but i'm pretty sure that hydra runs on linux
05:51:03 <ertes> let me see if actual building also works
05:51:47 <eklavya> ertes: thanks :) good to know I wasn't the only one bitten by "no backtracking" :P
05:56:03 <ertes> eklavya: if you want even better error reporting use megaparsec
05:56:13 <ertes> eklavya: if you want amazing error reporting use trifecta =)
05:57:07 <eklavya> never heard of those two (maybe megaparsec), thanks ertes :)
05:58:43 <ertes> trifecta is the best parser library i know from a technical standpoint, but unfortunately it's the worst library when it comes to documentation
05:59:08 <ertes> but it's easy enough to get into it, if you're already familiar with attoparsec/megaparsec/parsec, because the API is almost the same
05:59:40 <kadoban> Huh, apparently I should look into trifecta for my next usage. I always figured they were mostly the same.
06:00:51 <CoolerZ> if you have 2 functions that return a tuple (Maybe String, String) and you want to combine them
06:01:09 <CoolerZ> how do you do that
06:01:21 <kadoban> Combine them how?
06:01:52 <CoolerZ> well f1 :: String -> (Maybe String, String) and so is f2
06:02:26 <CoolerZ> combine f1 f2 s = let (a, rest) = f1 s in
06:03:00 <ertes> CoolerZ: sounds like you're reinventing state monads
06:03:17 <CoolerZ> need to apply f1 to the String, check if the return value is Nothing or Just String
06:03:21 <ertes> particularly:  StateT String Maybe
06:03:44 <orion> ertes: Ah, I see what you did now. I can't run GHC on the Pi because it uses too much memory to compile anything on Hackage.
06:03:56 <CoolerZ> if its Nothing need to return (Nothing, restofinput)
06:04:20 <orion> So, even if I built GHC with build=x86_64, host=arm, target=arm, I'd still be out of luck.
06:04:22 <CoolerZ> otherwise need to return the value of f2 restofinput
06:04:31 <ertes> orion: looks like i can't actually build GHC myself here, but GHC itself does support cross-host-compilation
06:04:49 <CoolerZ> ertes, actually i am trying to implement parser combinators
06:05:00 <ertes> CoolerZ: yeah, i thought so
06:05:47 <ertes> CoolerZ: (StateT String Maybe) is parser combinators in a nutshell
06:06:15 <orion> ertes: You're probably correct that GHC supports it, but running GHC on the Pi is a no-go.
06:06:58 <tsahyt> orion: couldn't you build it with host=x86_64 target=arm?
06:07:12 <tsahyt> (I didn't follow the earlier parts of this conversation)
06:07:22 <orion> tsahyt: No. I need TH support.
06:07:46 <tsahyt> I did not know that TH wouldn't work with this
06:09:07 <CoolerZ> ertes, so how do i check what value is returned?
06:10:40 <ertes> @let satisfy p = StateT $ \xs' -> case xs' of x:xs | p x -> Just (x, xs); _ -> Nothing
06:10:44 <lambdabot>  Defined.
06:10:46 <ertes> :t satisfy
06:10:49 <lambdabot> (a -> Bool) -> StateT [a] Maybe a
06:11:01 <ertes> CoolerZ: ^
06:11:15 <ertes> in fact you can easily generalise this to MonadState and Alternative
06:12:03 <ertes> @let satisfy p = do xs' <- get; case xs' of { x:xs | p x -> put xs >> pure x; _ -> empty }
06:12:06 <lambdabot>  .L.hs:197:1: warning: [-Woverlapping-patterns]
06:12:06 <lambdabot>      Pattern match is redundant
06:12:06 <lambdabot>      In an equation for ‘satisfy’: satisfy p = ...
06:12:06 <ertes> @undef
06:12:07 <lambdabot> Undefined.
06:12:09 <ertes> @let satisfy p = do xs' <- get; case xs' of { x:xs | p x -> put xs >> pure x; _ -> empty }
06:12:11 <lambdabot>  Defined.
06:12:14 <ertes> :t satisfy
06:12:16 <lambdabot> (MonadState [b] m, Alternative m) => (b -> Bool) -> m b
06:12:23 <ertes> CoolerZ: ^
06:13:29 <ertes> this one has the advantage that it works for (MaybeT (State String) a ≃ String -> (Maybe a, String)) as well
06:13:43 <ertes> while StateT String Maybe a ≃ String -> Maybe (a, String)
06:14:00 <ertes> the difference between the two is that the former gives you control over backtracking, while the latter enforces it
06:14:33 <CoolerZ> most of that went over my head
06:14:59 <ertes> do you see how (StateT String Maybe a ≃ String -> Maybe (a, String))?
06:15:39 <ertes> where "≃" means "is isomorphic to", which means "basically the same as"
06:15:53 <CoolerZ> i was thinking something like  combine p1 p2 input = let (a, rest) = p1 input in if a == Just a then
06:15:58 <CoolerZ> but that doesn't work
06:16:13 <ertes> what type do you expect your 'combine' to have?
06:16:28 <CoolerZ> combine :: Parser -> Parser -> Parser
06:16:48 <ertes> what happens with the result of the first parser?
06:16:54 <CoolerZ> type Parser = String -> (Maybe String, String)
06:17:22 <nitrix> runStateT :: s -> m (a, s)
06:17:32 <CoolerZ> the result of the first parser gets concatenated with the result of the second if both are Just Strings
06:18:02 <CoolerZ> if either of them fails, you return immediately with (Nothing, restofinput)
06:18:11 <ertes> CoolerZ: start like this: combine f1 f2 input0 = case f1 input0 of 
06:19:05 <nitrix> newtype StateT s m a = StateT { runStateT :: String -> Maybe (a, String) }   -- when s ~ String and m ~ Maybe.
06:19:47 <ertes> nitrix: already suggested…  i think CoolerZ is not quite there yet =)
06:19:48 <nitrix> I could go down the substitution, but the isomorphism seems clear to me :P
06:20:07 <shapr> GOOD MORNING #haskell!
06:20:10 <shapr> It's a beautiful day for code!
06:20:22 <ertes> HELO shapr!
06:20:29 <nitrix> His parser almost has the same form the StateT constructor expects.
06:20:42 <orion> EHLO shapr
06:21:40 * shapr hops cheerfully
06:21:46 <nitrix> WELCOME /shapr HTTP/2.0
06:23:36 <CoolerZ> this is what i have so far http://lpaste.net/352548
06:23:36 <sshine> PING :1487168654
06:23:50 <CoolerZ> ertes, ^
06:24:27 <ertes> CoolerZ: continue…  but remember what the result of (p1 s) is
06:24:44 <ertes> CoolerZ: its type is (Maybe String, String), so your pattern is not quite correct
06:25:31 <CoolerZ> yeah so is it    (Just xs, rest) ?
06:27:53 <shapr> nitrix: how's code? anything exciting?
06:30:32 <CoolerZ> ertes, this seems wrong http://lpaste.net/352548
06:33:12 <fizbin> Is there some fundamental reason that Haskell doesn't allow type aliases to be defined inside a toplevel function's where clause? (and then limited in scope to inside that function)
06:33:37 <quchen> No.
06:33:37 <fizbin> I.e. should I take it as a sign that I'm organizing my code incorrectly if it seems that such a thing would be useful?
06:33:58 <quchen> Likewise for local data definitions.
06:34:35 <fizbin> And unlike other conveniences (e.g. TupleSections), there's no pragma to allow such things, is there?
06:36:09 <lyxia> If you need this it may mean your where clause is too big.
06:36:46 <quchen> fizbin: Yes, that is, no.
06:37:17 <quchen> lyxia: In other places, it may not mean that.
06:37:23 <quchen> Naming things is useful.
06:38:03 <quchen> I’ve often needed local data definitions in 5-liners, but then put them above the whole definition at the top level in an awkward position.
06:38:18 <quchen> Still, better than having a random Bool value in the definition.
06:38:23 <lyxia> Okay, I see your point.
06:38:39 <quchen> (Especially when there are multiple Bool parameters around and confusion means buggy code)
06:39:08 <fizbin> In my case, it's mainly because I have a local use of a StateT monad that has a state that takes three lines to write out. When I have three functions in the topl-level where clause with that monad in their type...
06:40:48 <quchen> Maybe I can find an example
06:42:07 <quchen> Nope.
06:42:26 <tsahyt> when I have an attoparsec parser that does a choice, and wrap that in a many, the backtracking points created by <|> still exist after each element of the many is parsed, right?
06:42:38 <tsahyt> i.e. it could backtrack back to the last element
06:42:41 <zebr> hi all. if i have `newtype Foo a = Foo { getFoo :: a }' and i do `map Foo' or `map getFoo', will these be optimised out? i.e. if it were a type rather than a newtype then these would be `map id'
06:43:06 <quchen> lyxia: It’s pretty much the same as a local definition in a »where« that the compiler can float to the top level. It might semantically belong inside the »where«, and can help readability to have it there.
06:44:00 <quchen> zebr: »Probably«. Look at the Core to be sure.
06:44:22 <quchen> Two adjacent maps are definitely fused, and I’d be surprised if unNewtype.Newtype was not.
06:44:33 <fizbin> tsahyt: I believe so, yes.
06:44:39 <quchen> And »map id« probably also has a rule.
06:44:57 <fizbin> tsahyt: If that were not the case, it would break many common grammar examples.
06:45:34 <fizbin> Oh, wait, you said attoparsec, not parsec.
06:46:06 <fizbin> attoparsec is deliberately more minimal. I *think* it still is true, but I'm less certain.
06:46:40 <barrucadu> zebr: I believe you can use Data.Coerce.coerce for that sort of thing: `coerce [list of newtypes] :: OtherType`. it's safe because the compiler will tell you off if the two types cannot be coerced.
06:48:16 <tsahyt> fizbin: yesterday it was mentioned here that attoparsec always introduces the equivalent of parsec's try combinator on each <|>
06:48:41 <fizbin> Okay, should still be true then
06:48:44 <tsahyt> it also says so in the docs for the MonadPlus and alternative instance.
06:49:03 <tsahyt> so for big amounts of data, liberal use of <|> is probably to be avoided
06:49:16 <tsahyt> I wonder though why it doesn't just have try like parsec to let you control this
06:49:45 <tsahyt> oh wait it has
06:49:55 <tsahyt> "This combinator is provided for compatibility with Parsec. attoparsec parsers always backtrack on failure."
06:53:02 <lyxia> it's like it has it, but uses it everywhere implicitly
06:53:25 <tsahyt> I suppose there's no way to disable that behavior with attoparsec?
06:53:52 <tsahyt> other than avoiding <|> of course
06:54:07 <lyxia> Right.
06:54:18 <tsahyt> well in my case that's doable, so there's that.
06:54:33 <tsahyt> shouldn't be too hard either. the language is regular after all
06:55:16 <tsahyt> and I suppose there's also nothing like a cut operator to forget about backtracking after a certain point?
06:55:37 <lyxia> I assume this decision was made out of concern for performance but I can't see how it helps.
06:55:52 <tsahyt> the problem gets really bad when parsing many messages, say a million or so, with a top level many. but I could just forget about everything before the current message
06:55:54 <zebr> barrucadu: interesting, thanks. weirdly, it failed to infer the type of (coerce . transpose . coerce) :: [RowVec a] -> [ColVec a], so i had to help it along with ((coerce :: [[a]] -> [ColVec a]) . transpose . coerce)
06:56:34 <zebr> well, failed to typecheck, even
06:56:37 <lyxia> zebr: you can coerce transpoe directly here :)
06:58:09 <zebr> lyxia: do you mean (coerce transpose)? that seems to fail to typecheck too though, and i'm not sure i can help it along the same way
06:59:48 <lyxia> right you need to annotate the type of transpose
07:00:04 <lyxia> and possibly the whole result if it can't be inferred as well
07:11:00 <ertes> CoolerZ: why do you think it's wrong?
07:11:25 <CoolerZ> ertes, did you see it? http://lpaste.net/352548
07:11:43 <CoolerZ> it has nested case of expressions
07:11:56 <ertes> CoolerZ: yes, that's expected
07:12:03 <CoolerZ> is there a simpler way
07:12:07 <ertes> CoolerZ: yes
07:12:16 <ertes> CoolerZ: are you familiar with the monadic pattern?
07:12:27 <CoolerZ> i keep forgetting what that is
07:12:36 <ertes> i.e. "monads"
07:13:39 <CoolerZ> something about unwrapping a type like Maybe Int so a function of type Int -> Maybe Int can use it
07:13:46 <ertes> CoolerZ: one simple non-monadic way to improve this is to perform both pattern-matches at once
07:14:00 <ertes> case (p1 s, p2 s) of (…, …) -> …
07:14:39 <ertes> to actually combine the results you could use the Applicative interface to Maybe
07:14:50 <ertes> > liftA2 (<>) (Just "abc") (Just "def")
07:14:53 <lambdabot>  Just "abcdef"
07:14:56 <ertes> > liftA2 (<>) (Just "abc") Nothing
07:14:58 <lambdabot>  Nothing
07:15:00 <CoolerZ> but that evaluates p2 s doesn't it? even if p1 s fails?
07:15:16 <ertes> no, it depends on how you pattern-match
07:15:35 <CoolerZ> ertes, actually i am not doing p2 s in the pastebin
07:15:50 <ertes> oh, wait, nevermind…  you can't use a combined pattern-match
07:15:51 <CoolerZ> p1 s returns (... , restofinput)
07:15:57 <CoolerZ> then i run p2 restofinput
07:16:00 <ertes> yeah, sorry
07:17:09 <ertes> the usual way to improve this is to do it in steps:  write a state monad:  newtype Parser a = Parser { runParser :: String -> (a, String) }
07:17:12 <ertes> notice the lack of Maybe
07:17:33 <ertes> then use MaybeT on Parser
07:18:01 <ertes> the state monad by itself is really simple and concentrates on state-passing without concerning itself with potential failure
07:18:36 <ertes> MaybeT is also really simple and focusses on failure without concerning itself with state passing (it doesn't know that state even exists)
07:19:49 <ertes> after that: andThen = liftA2 (<>)
07:20:00 <ertes> andThen :: Parser String -> Parser String -> Parser String
07:20:11 <ertes> whoops
07:20:20 <ertes> andThen :: MaybeT Parser String -> MaybeT Parser String -> MaybeT Parser String
07:21:20 <CoolerZ> MaybeT is the maybe transformer?
07:21:25 <ertes> yeah
07:21:39 <ertes> newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
07:22:02 <ertes> if you substitute Parser for m you get:  String -> (Maybe a, String)
07:53:33 <tsahyt> is there some way to do a lookahead of two bytes in attoparsec?
07:57:06 <kqr> does anyone have any clue how to interpret the following? http://lpaste.net/618383966734385152
07:58:15 <kqr> i mean sure I understand what the error message means, but not why it is thrown
07:58:18 <kqr> or even from where
07:58:41 <kqr> the location it points out is just the location of the deriving clause for the enum instance on the DeviceClassType type
07:59:37 <sm> perhaps your X lib is out of date with latest X device types ?
07:59:43 <sm> haskell X lib
07:59:48 <kqr> possibly
07:59:59 <kqr> so I'd likely have to update the x11-xinput package before going on?
08:00:08 <kqr> (or somehow request less functionality of my xorg server?)
08:00:12 <sm> probably the first thing I'd try
08:00:28 <sm> after googling the error of course
08:05:22 <MrJazz_>  
08:17:16 <sbrg> when ghci executes haskell code, is it being compiled and executed on the fly(I guess this would be JIT compilation, which I don't think is the case?), or is it being compiled to an executable and ran, or is some intermediate language being interpreted?
08:34:05 <eacameron> Haskell's indentation rules for let are really annoying. I end up doing x <- pure y a lot :(
08:34:43 <tsahyt> you can always use explicit braces and semicolons if you don't like the layouting rules I guess
08:35:01 <eacameron> tsahyt: Hah...not sure that's an improvement.
08:35:17 <tsahyt> I'm actually rather fond of the indentation rules, I suppose it's a matter of personal preference
08:35:46 <eacameron> tsahyt: Oh? I just like to have large do blocks and i don't like having to indent them so far.
08:35:57 <eacameron> "large" within reason
08:37:14 <tsahyt> I dislike having large blocks of anything to begin with, and as far as indentation goes I like this quote from the linux kernel coding standard: " you need more than 3 levels of indentation, you’re screwed anyway, and should fix your program."
08:37:42 <tsahyt> to be fair, that's for C, but I still regard excessive need for indentation as a bit of a code smell
08:37:46 <tsahyt> nothing horrible, but better to be avoided
08:38:16 <eacameron> tsahyt: Heh it's true. Maybe it'll grow on me over time.
08:38:32 <eacameron> I *do* like how let signals purity though
08:38:45 <eacameron> I don't want to lose that visual queue
08:38:47 <eacameron> que
08:39:00 <nshepperd> but 'let x = y' is less characters than 'x <- pure y'
08:39:09 <tsahyt> yep. and by the monad laws you always have an easy time refactoring parts out of your do-blocks into a separate function
08:39:23 <tsahyt> the only problem is that now you need to name a function, and naming is the hardest problem in computer science
08:39:37 <tsahyt> other than this space leak I'm dealing with here... :(
08:39:51 <eacameron> nshepperd: Well that's just me being lazy in IRC
08:40:05 <eacameron> tsahyt: LOL
08:40:23 <tsahyt> so I've rewritten the relevant parts of my parser not to use choice or <|> when at all possible and do explicit lookahead and case matching on it now. I've reduced parsing time per message from ~250ns to ~60ns in the process. I mean that's great, but it's still leaking space
08:40:55 <eacameron> tsahyt: Have you tried ndmitchell's technique?
08:41:00 <tsahyt> -xc?
08:41:51 <eacameron> tsahyt: Yah. Lowering your memory until it cracks and then working up with that.
08:42:00 <tsahyt> still runs with -K16K
08:42:11 <eacameron> tsahyt: He recommends 1k
08:42:18 <tsahyt> still runs
08:42:24 <eacameron> LOWER
08:42:30 <eacameron> How low can you go??
08:42:55 <nshepperd> maybe that weigh package would help
08:43:39 <tsahyt> I'm starting to think that the actual culprit isn't even the parser
08:43:43 <nshepperd> @hackage weigh
08:43:43 <lambdabot> http://hackage.haskell.org/package/weigh
08:43:46 <tsahyt> it might be the serializing back to disk
08:44:11 <tsahyt> the parser returns a [MidiMessage], to which I then apply foldMap with an appropriate bytestring builder.
08:44:40 <tsahyt> or maybe I'm not being strict enough over the return value of the parser
08:45:07 <tsahyt> but then surely I couldn't run it with a stack size of just 1K on a file with about 1 million messages
08:45:37 <tsahyt> nshepperd: I'll add that to my benchmark suite
08:45:44 <tsahyt> for the high level encoding/decoding functions at least
08:47:32 <eacameron> tsahyt: Another question would be ... if you can't detect the space leak does it matter?
08:47:55 <CoolerZ> why does this give an error ?http://lpaste.net/352557
08:48:12 <CoolerZ> something about no instance of Ord arising from a use of a
08:48:19 <dolio> Indentation?
08:48:47 <moongazer> bollu, Hi
08:48:54 <tsahyt> eacameron: yes, because on this 2ish MB file I require over a 100M of memory
08:48:57 <tsahyt> that's absolutely unacceptable
08:49:11 <dolio> Your paste has a class declaration, a type signature for a separate function tooMany, an instance of the class, and a definition of tooMany that doesn't match the signature.
08:49:19 <eacameron> tsahyt: How is -K1K working?
08:49:24 <tsahyt> just fine
08:49:35 <bollu> moongazer: hello :)
08:49:37 <eacameron> tsahyt: I mean how does it work if you take 100M memory?
08:49:46 <tsahyt> it fails
08:49:59 <tsahyt> running it with say -M50M fails
08:50:24 <eacameron> tsahyt: Oh, I thought you said running with -K1K worked.
08:50:35 <tsahyt> yes, -K1K works. -M50M does not.
08:50:52 <eacameron> tsahyt: o_O
08:51:37 <CoolerZ> anyone?
08:52:06 <glguy> CoolerZ: You need to indent the tooMany definitions
08:52:12 <tsahyt> eacameron: they don't do the same thing
08:52:21 <CoolerZ> oh
08:52:35 <dolio> -M is limiting the heap size, presumably.
08:52:46 <eacameron> tsahyt: Oh I must have gotten that confused.
08:53:46 <tsahyt> eacameron: -K sets the maximum stack size, -M sets the maximum heap size
08:54:33 <eacameron> tsahyt: Ah right.
08:56:47 <m4lvin_> any suggestions how to debug c++ code that behaves very different when compiled via cabal using c-sources? I would like to get rid of my Makefile https://github.com/m4lvin/HasCacBDD/tree/standalone
08:57:05 <dolio> tsahyt: What's a MidiMessage look like? Also, how many are there?
08:57:21 <tsahyt> dolio: https://github.com/tsahyt/midi-simple/blob/master/src/Sound/MIDI/Types.hs#L65
08:57:27 <tsahyt> about 3/4 of a million in this test
08:58:13 <dolio> Okay, so it is only required for there to be ~25 bytes/element to reach 100MB of resident data?
08:58:51 <dolio> And list already gets you, what, 16?
08:59:10 <tsahyt> I'll test it through pipes and see how much the streaming buys me
08:59:41 <dolio> I think that's probably your problem. Using a parser like that will build the entire list in memory.
09:00:44 <tsahyt> hmm, well yes this does make a big difference
09:01:07 <tsahyt> the blow up from the input file to the parsed data is pretty big though. I did not anticipate that.
09:01:18 <tsahyt> each message is about 3 bytes on average in the input data
09:01:51 <tsahyt> but I guess that's what you pay for having a decent representation that you actually want to work with
09:01:53 <dolio> Haskell data types aren't represented in a super compact fashion.
09:02:38 <tsahyt> for my actual usecase, this test is way out of proportion anyhow. in a real-time setting I'm never handling that many messages in one go
09:02:39 <dolio> Or, they aren't in GHC, at least.
09:02:49 <tsahyt> maybe a hundred tops
09:05:39 <krokodil> suppose I have 100 Haskell files, which are all very similar, having exactly the same functions etc. Except a few files are the outliers, they return slightly different outputs.
09:05:59 <krokodil> How do I write a script that compiles these files and tests the functions in these 100 files for correct input-output?
09:06:11 <krokodil> I honestly don't know where to even start, so will be grateful for any pointers
09:08:17 <sbrg> krokodil: write a bash script, perhaps? 
09:08:24 <sbrg> s:bash:shell:
09:09:00 <sbrg> perhaps things might be a bit more complicated if you have a lot of dependencies and are using stack
09:09:09 <sbrg> or maybe `stack ghc` will work fine
09:09:13 <krokodil> sbrg: what I want is to write a Haskell script that can talk to these files, i.e. compile them and make their functions visible, and then directly test their input-output correctness
09:10:41 <sbrg> ah. perhaps you could do something with hint?
09:10:53 <sbrg> https://www.stackage.org/haddock/lts-8.0/hint-0.6.0
09:13:11 <tsahyt> short rant: I hate it when a library doesn't export a type that it is using
09:21:02 <krokodil> sbrg: is there any tutorial on hint?
09:21:08 <eacameron> Can anyone comment on the difference between unordered-containers HashMap and containers Map?
09:21:16 <sbrg> don't know. it's been on my "things to look into" list for a long time now
09:34:57 <Perenelle> Has anyone seen srvdown
09:35:47 <c_wraith> eacameron, basically totally different. 
09:36:24 <c_wraith> eacameron, Map is a (weakly) balanced binary search tree. 
09:37:01 <c_wraith> eacameron, HashMap is a hash array-mapped trie
09:47:13 <eacameron> c_wraith: I saw the difference in implementation but I guess I'm more interested in practical usage. When would one use one over the other?
09:49:36 <c_wraith> when it matters. *shrug*
09:49:52 <byorgey> eacameron: use HashMap when you want fast lookup and membership testing, and your keys are Hashable.  Use Data.Map when your keys are ordered and you want to keep them in order, iterate through them in sorted order, etc.
09:50:16 <c_wraith> HashMap is almost always more compact in memory. for performance, either one can be better. benchmark. 
09:50:37 <eacameron> byorgey: Ah that's perfect. Thanks. I picked HashMap on a hunch and now I'm certain that's what I want.
09:51:39 <ertes> c_wraith: that doesn't sound right
09:51:52 <ertes> HashMap still needs to store the whole key
09:52:50 <c_wraith> ertes, yes, but it has fewer internal nodes because of the branching factor. 
09:53:05 <ertes> i would expect the branching factor to be similar, too
09:53:14 <ertes> but i haven't benchmarked
09:53:30 <tsahyt> I have to say that even though it's somewhat hard due to tight time constraints, playing around with writing a little real-time synth in haskell that works with jack is very rewarding
09:53:48 <c_wraith> Map is a binary search tree. branching factor 2. HashMap uses a HAMT with a branching factor of 32
09:53:59 <ertes> ah, i see
09:54:32 <ertes> why 32 though?  i always assumed that it uses PATRICIA branching
09:54:39 <eacameron> c_wraith: My HashMap has over 50k elements and being used by hundreds of threads every second...so I think that's the right choice.
09:55:12 <c_wraith> ertes, something about clever algorithms involving bit masks. 
09:55:57 <c_wraith> ertes, tibbe gave a bunch of talks about it when he was stealing it from clojure
09:56:06 <ertes> i see
09:56:19 <ertes> does IntMap do the same?
09:56:42 <c_wraith> no, IntMap is a Patricia trie
09:57:17 <ertes> so HashMap potentially outperforms even IntMap?
09:57:42 <c_wraith> in some data distributions and use patterns, yes. 
09:58:16 <ertes> i should really run a few benchmarks…  thanks
09:58:28 <eacameron> ertes: If you do, please share. :D
09:58:39 <ertes> sure
09:58:54 <ertes> eacameron: you could also pick up criterion and run them yourself =)
09:59:23 <ertes> i don't want to do it right now, because i'm on battery
09:59:37 <eacameron> ertes: Certainly...but I doubt I'll get around to it any time soon. I'm already overbudget on this project :/
10:00:01 <fosterite> question about the dimensional library: at runtime it's just multiplying floats, right?
10:00:09 <eacameron> So I'm just going with "hunches" at this point and calling it good. ;)
10:00:52 <eacameron> ertes: And because I'm not so good at writing benchmarks so it takes me way longer than it should :P
10:02:37 <tsahyt> at which point in developing a library do you upload a first version to hackage?
10:02:44 <eacameron> Is there a Generic way to build a default for some large record/tuple type? I have tons of strings and Maybes and I just want to get a default value and use lenses to set certain fields.
10:03:06 <ertes> tsahyt: when i feel that it has reached a state where it might be useful to others
10:03:26 <mmachenry> tsahyt: I think if you feel that it provides some value and you are relatively confident you're not going to wildly change the interface you're good to go.
10:03:30 <ertes> eacameron: is your type a Monoid?
10:03:35 <ertes> if yes, mempty is a good default
10:03:57 <eacameron> ertes: Hmm...not yet but maybe it could be. It's just a giant record of simple fields.
10:04:04 <ertes> eacameron: in any case you may want to use my approach: http://ertes.eu/tutorial/config-monoids.html
10:04:16 <mmachenry> It doesn't have to do everything. Even if it's half implemented but it provides some use, go for it. Especially because someone might send you pull requests for the other stuff.
10:04:39 <mmachenry> eacameron: What's the record for?
10:04:50 <eacameron> mmachenry: Storing a bunch of fields off a scraped page
10:05:54 <eacameron> ertes: This looks really cool.
10:06:35 <eacameron> mmachenry: Essentially I want to start with a record that issumes the scrape failed and I found no data at all. Then the scraper will fill in the bits that it could find.
10:11:40 <tsahyt> mmachenry: well I'm probably going to extend it, but the existing interface shouldn't change too drastically I think
10:11:55 <tsahyt> there really aren't that many ways to write a library for this particular task I think
10:12:09 <tsahyt> at a high level it's just encode and decode, along with a representation of the decoded data
10:13:29 <ertes> eacameron: yeah, that sounds like i would use a product monoid there
10:13:49 <ertes> not necessarily with the phases thing from the article though
10:14:38 <eacameron> ertes: So you can derive a monoid instance with Generics?
10:16:00 <ertes> eacameron: yes…  the generic-deriving library makes this pretty much trivial
10:16:06 <ertes> as long as each field is a monoid
10:16:12 <ertes> and the type is not a sum
10:16:25 <eacameron> ertes: Jeepers that cool.
10:20:54 <mmachenry> tsahyt: I'd go ahead and put it up.
10:21:08 <mmachenry> tsahyt: What does it do?
10:23:42 <tsahyt> mmachenry: just a simple library for parsing and serialization of MIDI messages in a real-time setting
10:23:48 <mmachenry> Awesome.
10:23:57 <tsahyt> I wrote it to hook it into JACK so I could try playing my mini synth with a keyboard
10:24:13 <mmachenry> If you want some encouragement that stuff doesn't have to be perfect to be contributed, look at what they're doing in the Perl community: http://www.perlmonks.org/?node_id=558220 :)
10:24:25 <lynnard> I'm looking at the stencil support in repa - can anyone explain what stencil coefficients really do? I read over wiki and googled for half an hour and all I can see is that a stencil specifies some operations given the neighbours of each cell (thus a function) - but the stencil in repa is just a collection of coefficients - what operation these coefficients represent?
10:24:26 <tsahyt> I'd say it's quite fast. Parsing of common events (e.g. Note On/Off etc) takes around 50-60ns on my machine
10:24:44 <tsahyt> which is about 10x the time to access an IORef or so iirc
10:24:54 <tsahyt> it's sufficient for my use case anyhow
10:24:55 <mmachenry> Not that I necessarily want the Hackage to look like that, but honestly, I think we could benefit from people just getting out there and doing whatever. 
10:25:12 <tsahyt> Well I still have another library sitting around that is actually much more interesting, and I still need to release that as well
10:25:35 <tsahyt> but in this case I'd like to test it some more, because I really don't want to put code on hackage that possibly segfaults, and those are bindings to a C library.
10:29:20 <mnoonan> lynnard: it's probably a convolution, taking the weighted sum of neighbors
10:30:15 <mnoonan> for example: http://illustratedhaskell.org/2011/09/24/conways-game-of-life-with-repa/
10:30:33 <jackhill> Speaking of making bindings to a C library: what resources would people recommend I look at for learning how to create bindings?
10:31:45 <tsahyt> jackhill: I figured out most of it from reading the sdl2 bindings
10:32:00 <tsahyt> also the GHC manual
10:32:13 <tsahyt> there's also a high level overview at ezyang's blog iirc.
10:32:34 <jackhill> tsahyt: cool thanks.
10:33:07 <jackhill> I knew that there were a number of binding out there, but some of them didn't seem like good examples for a first-time user.
10:33:25 <tsahyt> I think the sdl2 bindings are rather tidy, and also pretty big so they cover a lot of possible cases
10:33:32 <tsahyt> but writing C bindings is always a bit painful imo
10:33:44 <tsahyt> because you have to deal with all the C ugliness, take care of memory being managed properly etc
10:35:12 <shapr> I never could get repa to build the examples, so I haven't used it.
10:35:27 <lynnard> mnoonan: awesome material - thanks; still wondering what the center does though
10:36:11 <shapr> tsahyt: too bad there's not alpha hackage and release hackage
10:38:14 <mnoonan> lynnard: what do you mean by 'center'? I'm not seeing anything in the repa Hackage docs, do you just mean the 0 center coefficient in the link I posted?
10:40:28 <simukis_> why are orphan instances called orphan instances?
10:40:42 <johnw> the parent type is not in the file
10:41:04 <steveklabnik> hey everyone! i'm interested in the history of "orphan instances" and why they're called that. the wiki gives a good definition, but not the history or a description of why that name was chosen
10:41:15 <steveklabnik> anyone have any good references for me to check out?
10:42:12 <steveklabnik> lol, apparently who i was talking to beat me to it
10:42:13 <steveklabnik> thanks johnw 
10:42:50 <ontop> Hey guys. I have http://lpaste.net/1903380783754641408 is there any cleaner way to do it? I keep getting something using IO, then having to zip it together with the name I sent in, then filter, then split it back out.
10:43:02 <ontop> End result is supposed to be: "find folders without readme's in them"
10:43:23 <johnw> ontop: btw: pipes-files would make this very easy to express
10:43:55 <johnw> ontop: try filterM
10:44:29 <ontop> johnw: Hm, I'll check out pipes-files, but filterM doesn't help me that much since there's all this IO and I have to invert the bool and ... :(
10:44:52 <johnw> print =<< filterM (\path -> not <$> hasReadme path) folders
10:44:53 <ontop> Well, maybe it does but I just don't know how.
10:45:10 <ontop> O______________o
10:45:15 <ontop> I can applicative functor not over IO?!
10:45:17 * ontop explodes
10:45:24 <johnw> ?
10:45:25 <tsahyt> hmm, so I've uploaded my library, and noticed that it lists things as dependencies that are only required when you build the examples, which are disabled by default
10:45:27 <tsahyt> is that a problem?
10:45:51 <ontop> johnw: That's awesome. The fmap usage of not there.
10:46:43 <shapr> :t filterM
10:46:45 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
10:47:18 <shapr> ontop: have you seen Turtle?
10:47:22 <ontop> shapr: Nope.
10:47:36 <eacameron> ontop: It has a shell.
10:47:49 <ontop> Well that's nice.
10:48:01 <shapr> ontop: https://hackage.haskell.org/package/turtle-1.3.1/docs/Turtle-Tutorial.html
10:48:03 <ontop> What does it mean basil?
10:48:11 <eacameron> hackage turtle
10:48:14 <ontop> Oh neat.
10:48:22 <simukis_> I kinda feel like there should be a deeper story hiding behind orphan instances, personally
10:48:26 <eacameron> :hackage turtle
10:48:32 <ontop> This is sort of what I'm doing lol.
10:48:45 <simukis_> and thus I’m not satisfied :P
10:48:52 <shapr> ontop: Yeah, it looks like what you're doing, so if you'll be doing that much, Turtle will help.
10:49:19 <ontop> This was mostly just a: HEY LOOK, a chance to use Haskell my coworkers can't complain about because it's only mine!
10:50:11 <shapr> ontop: that's an excellent motivation, I have a script that disables the touchpad on my laptop in Haskell for that same reason
10:50:57 <stephA> Hi everyone. I need help with this code, that does not compile: http://lpaste.net/352567 . I want to achieve a lazy listening of what is incoming from the network. Data is sent by lines. If I don't use hIsEOF, then there's an exception hGetLine : end of file. But with the test isMoreContent, I'm blocked with the unless construct. What's your point of view ?
10:51:05 <johnw> I should integrate pipes-files with turtle somehow...
10:51:36 <ontop> Well, this is interesting. But it might be a little beyond me for now. I think I'll revisit turtle though.
10:51:45 <shapr> ontop: from before I found turtle: http://lpaste.net/352568
10:52:18 <ertes> stephA: first of all 'forever' doesn't ever return
10:52:45 <ertes> stephA: so line 7 is pointless, and line 8 is never reached
10:55:52 <ertes> stephA: also i think your logic is backwards
10:56:13 <ertes> receive *unless* more input?
10:57:51 <stephA> rather... else block until more input
10:58:14 <stephA> but hGetLine will throw as soon as I received the first line
10:58:26 <ertes> stephA: i think you have a major misunderstanding of how IO works
10:58:39 <ertes> stephA: therefore i recommend that as your very first step you read this: https://www.vex.net/~trebla/haskell/IO.xhtml
10:59:46 <stephA> ertes, it's not about network
11:00:16 <stephA> here I reach the EOF, it's normal. I want it to wait for further data from network.
11:03:42 <stephA> I don't feel any help while skimming the tutorial you indicate me. What do you think I would learn from it precisely ?
11:04:11 <ertes> stephA: how IO works
11:04:34 <ertes> why your 'forever' construct does not do what you seem to think it does
11:05:42 <ertes> and on line 14 you probably meant to use 'when', not 'unless'
11:05:44 <stephA> they even do not mention the forever function in the tutorial
11:05:55 <ertes> however, as far as i see this code shouldn't even type-check
11:05:57 <ertes> :t unless
11:06:00 <lambdabot> Applicative f => Bool -> f () -> f ()
11:06:13 <ertes> which disagrees with the type of getNextMessage
11:06:23 <ertes> they don't need to
11:06:30 <ertes> don't skim it, read it
11:06:35 <stephA> ertes, it does not compile. I warned about that :-)
11:07:56 <ertes> stephA: what do you think 'return' does?
11:08:40 <stephA> it wraps a value inside a monad:    :a -> m a  is the type of return I think
11:09:51 <stephA> I am surprised by your sentence forever does not ever return as its type is Monad m => m a -> m b
11:12:04 <stephA> I still don't get what part of the tutorial could help me
11:16:39 <johnw> stephA: the 'm b' in that type just allows a forever action to type-check anywhere
11:16:52 <johnw> the fact that it can't know what 'b' is tells you that it cannot return without playing tricks
11:18:48 <ertes> stephA: (forever action) is still an IO action
11:18:53 <ertes> one that never completes
11:19:15 <stephA> so forever is not a infinite replicateM ?
11:19:25 <ertes> nope
11:20:01 <ertes> but an infinite 'replicateM' couldn't return either for IO
11:20:48 <monochrom> I wonder if "they use different amount of space" is a good way to distinguish them.
11:23:05 <ertes> another way would be: one of them pretends to complete
11:23:11 <ertes> if you look at the types
11:23:30 <eacameron> Can anyone recommend a setup for streaming large amounts of data to a CSV file?
11:23:55 <ertes> eacameron: i've hacked cassava to do that…  hacked because cassava doesn't support streaming
11:24:05 <ertes> i can upload the code, if you want
11:24:41 <cocreature> "pipes-csv" supports streaming
11:25:36 <eacameron> ertes: Looks like cassava supports streaming on the input but not output
11:25:50 <eacameron> cocreature: Ah maybe that's the ticket then
11:26:46 <eacameron> ertes: Can you compare your code with pipes-csv?
11:26:55 <ertes> yeah, pipes-csv does pretty much what i did
11:27:02 <eacameron> ertes: Ah ok. I'll try that then.
11:31:09 <ontop> Is there a "." operator for things that have IO (Thing) as a return?
11:31:19 <ontop> I have two functions: String -> IO Bool
11:31:26 <ontop> And I wanted to us... I need to think more.
11:31:27 <ontop> :)
11:31:39 <erewok> that’s what bind is for: composing monadic operations.
11:32:02 <kqr> if I have a stack project that pulls in a library from hackage as a extra-dep, what's the easiest way for me to patch that library locally?
11:32:34 <cocreature> :t <=<
11:32:38 <lambdabot> error: parse error on input ‘<=<’
11:32:41 <cocreature> :t (<=<)
11:32:43 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
11:32:45 <cocreature> ^ ontop
11:33:01 <ontop> Oh.
11:33:12 <ontop> Interesting.
11:33:12 <ontop> :)
11:33:31 <cocreature> there is also (>=>) if you want to compose the other way :)
11:33:52 <erewok> ^better answer @cocreature
11:33:58 <kqr> ah never mind. just found this: https://github.com/commercialhaskell/stack/blob/master/doc/faq.md#i-need-to-use-a-package-or-version-of-a-package-that-is-not-available-on-hackage-what-should-i-do
11:34:26 <ontop> cocreature: Because that's sort of ungoogle-able, is there a named version of that function?
11:34:38 <eacameron> ontop: use Hoogle :D
11:35:05 <cocreature> ontop: kleisli composition
11:35:12 <ontop> Intense.
11:35:20 <eacameron> ontop: https://www.haskell.org/hoogle/?hoogle=%3E%3D%3E
11:35:26 <ontop> Found it using Hoogle.
11:35:28 <ontop> Thx guys.
11:35:40 <cocreature> also the new hoogle is great if you are searching for function names http://hoogle.haskell.org/?hoogle=(%3C%3D%3C)
11:35:44 <cocreature> since it indexes all of stackage
11:36:19 <eacameron> cocreature: Oh my goodness! A hoogle that's actually usable.
11:36:36 <cocreature> eacameron: I’ve been using it for 2 years by now I think :)
11:36:39 <cocreature> it’s great
11:36:51 <eacameron> cocreature: How did I not know about this one?
11:36:57 <cocreature> typesearch is broken afaik but I never really used that anyway
11:37:01 <erewok> there’s also a schoolofhaskell thing in kleisli composition, you might like ontop: https://www.schoolofhaskell.com/user/Lkey/kleisli
11:37:27 <ontop> Well, I just found out I'm a clown and I didn't want to compose them to begin with. They're sort of filters in a way that I wanted to join together so I was barking up the wrong tree :)
11:37:38 <ontop> Gotta find another way.
11:38:24 <Younder> Fninding the right idions can take a while.
11:38:47 <ontop> Feels like I need EitherT here.
11:38:51 <ontop> TBH
11:39:58 <EvanR> better not taking functional programming for granted... i am simply trying to communicate a low-res 360 degree absolute position angle from one thing to an arduino, i wish i had an MVar and a simple algebraic datatype
11:46:29 <dmwit> I wish there was a pattern like `_ { field = pat, ... }`.
11:47:17 <dmwit> Unlike the usual proposals for allowing `_` to match any constructor, this one has the benefit that the things matching the remainder of the pattern are guaranteed to have the right type without further typechecking gymnastics.
11:49:48 <kadoban> dmwit: Is that like duck typing essentially, or am I misreading?
11:49:50 <lyxia> (field -> pat)
11:50:13 <lyxia> Isn't that equivalent
11:50:17 <`Guest00000> ^ - with ViewPatterns
11:50:19 * johnw imagines duck typing involving a typewriter with two very big keys
11:50:41 <johnw> `Guest00000: he wants RecordPuns, but with the constructor being a wildcard
11:51:23 <dmwit> lyxia: It's a bit more convenient when you want to match multiple fields.
11:51:51 <dmwit> kadoban: I don't think so? `field` unambiguously chooses a type constructor.
11:53:16 <`Guest00000> johnw: as in " _ { f1, f2 } " ?
11:53:37 <lyxia> constructors sharing multiple fields...
11:53:47 <lyxia> I find that awful.
11:54:22 <dmwit> In my uses, it wouldn't even be able to match more than one constructor.
11:54:32 <dmwit> I just don't want to type the whole stupid name of the constructor. ^_^
11:54:58 <kadoban> dmwit: Oh, I see what you mean now. Totally misunderstood originally.
11:56:35 <lyxia> Ah I thought you meant the field only to help determine the type, but you also want to deduce the constructor that way?
11:56:55 <lyxia> Haskell < OCaml
11:57:06 <shapr> cocreature: do you know how to get hoogle to only index the stackages I have installed?
11:57:20 <shapr> cabal packages = cabbages -- right?
11:57:38 <johnw> hackage is the cabbage patch
11:57:51 <shapr> ooh, I like it.
11:58:10 <ertes> dmwit: pattern guards can make it somewhat tolerable:  f x | pat1 <- f1 x, pat2 <- f2 x = …
11:58:36 <dmwit> ertes: That's not bad!
11:59:29 <cocreature> shapr: "hoogle generate" accepts a bunch of flags for that but I don’t recall the exact names. stack also has a "stack hoogle" command builtin that runs on the corresponding snapshot
11:59:46 <shapr> ah, ok
12:00:18 <Athas> How come 'uncurry encodeFloat . decodeFloat' isn't identity?
12:00:40 <Athas> > uncurry encodeFloat $ decodeFloat $ 0 / 0
12:00:41 <ertes> > uncurry encodeFloat . decodeFloat $ 0/0
12:00:45 <lambdabot>  -Infinity
12:00:45 <lambdabot>  -Infinity
12:00:51 <ezyang> Flating point shenanigans 
12:00:55 <Athas> > 0 / 0
12:00:58 <lambdabot>  NaN
12:01:05 <dmwit> :t decodeFloat
12:01:08 <lambdabot> RealFloat a => a -> (Integer, Int)
12:01:22 <dmwit> That type looks like a lie to me.
12:01:29 <ertes> it is a lie
12:01:35 <ertes> > decodeFloat $ 1/0
12:01:38 <lambdabot>  (4503599627370496,972)
12:01:40 <dmwit> Without knowing anything further about what the `Integer` and `Int` are even supposed to mean.
12:01:54 <pikajude> hey, how do I generate a haddock index for all the packages in my package DB?
12:02:06 <Athas> dmwit: because it throws away the sign bit?
12:02:15 <ertes> no, the sign is there
12:02:25 <dmwit> Athas: Because I can't imagine a sane way to stuff infinities and NaNs into `(Integer, Int)`.
12:02:31 <ertes> but it can't handle exceptional values like infinity or NaN
12:02:34 <dmwit> Plenty of insane ways, of course.
12:02:46 <Athas> Ah, decodeFloat is explicitly documented not to handle NaNs.  Drat.
12:03:00 <Athas> That kind of stuff is exactly what I need.  Oh well.
12:03:05 <ertes> if you give it infinity, it just returns a value that is large enough that encodeFloat will treat it as infinity for the given type
12:03:19 <dmwit> > read "-Infinity" :: Float
12:03:22 <lambdabot>  -Infinity
12:03:27 <ertes> but it has no idea how to handle NaN
12:03:31 <dmwit> Athas: Perhaps you should use boring old show and read.
12:03:42 <dmwit> Athas: Still won't quite be identity. But closer than encodeFloat/decodeFloat.
12:03:50 <ertes> > read "NaN" :: Double
12:03:53 <lambdabot>  NaN
12:04:03 <Athas> dmwit: that's horrifying!  But I guess...
12:04:18 <ertes> Athas: if you don't care about the representation you could also just serialise
12:04:28 <dmwit> I mean, "asciify" is the only real operation for serialization that the IEEE754 spec promises will exist.
12:04:29 <ertes> that preserves everything, even crazy stuff like negative zero
12:04:59 <dmwit> > -1 / read "Infinity" :: Float
12:05:02 <lambdabot>  -0.0
12:05:07 <dmwit> > read "-0.0" :: Float
12:05:10 <lambdabot>  -0.0
12:05:17 <dmwit> read preserves negative zero =)
12:05:33 <Tuplanolla> How about different kinds of nans?
12:05:48 <dmwit> Tuplanolla: Yep, that's the part that made me say "still won't quite be identity".
12:09:42 <jmg8766> I wrote a function for calculating permutations without resting type variables to a type-class for part of a homework, can I get some critiques? http://lpaste.net/352571
12:10:08 <dmwit> Your base case sucks.
12:10:19 <dmwit> See if you can make it smaller!
12:10:30 <jmg8766> okay
12:11:24 <patientpl> hi
12:11:50 <patientpl> i want a vector array 
12:11:51 <patientpl> 	let masterarray = array (0,0,0) [(0,0,0) | a <- [0..2], b <- [0..7], c <- [0..7]]
12:11:58 <dmwit> jmg8766: You might like `concat`.
12:12:08 <dmwit> :t foldl (++) []
12:12:10 <lambdabot> Foldable t => t [a] -> [a]
12:12:11 <dmwit> :t concat
12:12:14 <lambdabot> Foldable t => t [a] -> [a]
12:12:26 <patientpl> where its an array of 3-tuples but the above example doesnt compile
12:12:45 <patientpl> anyone have any ideas?
12:12:54 <Tuplanolla> :t array
12:12:55 <lambdabot> Ix i => (i, i) -> [(i, e)] -> Array i e
12:13:20 <Tuplanolla> You're missing the elements themselves, patientpl.
12:13:46 <dmwit> jmg8766: For generating rotations of `xs`, consider trying to generate the rotations directly, rather than picking a number and generating that rotation. You can save some work that way: your method for generating rotation `n` already generates rotations `1` through `n-1` anyway, why not reuse that work?
12:14:07 <patientpl> perhaps, but i want the array to be initialized with all zeros, if i declare the elements, it will initialize them with the values of the loop which i dont want
12:15:11 <dmwit> patientpl: How big of an array do you want? That's supposed to be the first argument to `array`.
12:15:20 <Tuplanolla> :t array ((0, 0, 0), (2, 2, 2)) [((x, y, z), 0) | x <- [0 .. 2], y <- [0 .. 2], z <- [0 .. 2]]
12:15:22 <lambdabot> (Ix t2, Ix t1, Ix t, Num t2, Num t1, Num t, Num e, Enum t2, Enum t1, Enum t) => Array (t, t1, t2) e
12:15:24 <patientpl> for example here https://lotz84.github.io/haskellbyexample/ex/arrays the array 'a' has variable 'i' changing at each iteration
12:15:38 <dmwit> :t listArray
12:15:41 <lambdabot> Ix i => (i, i) -> [e] -> Array i e
12:15:51 <patientpl> :t getmeasandwich
12:15:53 <lambdabot> error: Variable not in scope: getmeasandwich
12:15:58 <patientpl> darn :D
12:16:00 <dmwit> :t listArray ((0,0,0), (2,7,7)) (repeat 0)
12:16:02 <lambdabot> (Ix t2, Ix t1, Ix t, Num t2, Num t1, Num t, Num e) => Array (t, t1, t2) e
12:16:14 <Tuplanolla> Those two are your options, patientpl.
12:17:00 <dmwit> jmg8766: As a later trick, you might want to look into zippers as a more efficient implementation technique than rotations.
12:17:39 <dmwit> Then again, you might not.
12:17:55 <patientpl> thanks
12:18:15 <Athas> Man, this floating point stuff is crazy.  I guess I'm OK with not maintaining NaN payloads.
12:18:18 <Athas> Those seem fragile anyway.
12:18:33 <Athas> But my compiler's constant folder was turning NaNs into negative infinity, which seemed bad.
12:19:01 <cocreature> Athas: your haskell compiler?
12:19:11 <jmg8766> dmwit thanks, I'm still working on the base case, and generating rotations tip
12:19:18 <Athas> cocreature: no, that's much too hard for me!  Just a compiler written *in* Haskell.
12:19:35 <dmwit> jmg8766: Good luck! Overall it looks like a very nice start.
12:19:36 <cocreature> Athas: ah ok, I thought you were using some standard compiler that was screwing this up :)
12:19:44 <cocreature> Athas: just sell it as an -ffast-math option
12:20:47 <Athas> -ffast-and-wrong.
12:20:54 <Jinixt> "like -ffast-math, but it's always on"
12:21:01 <cocreature> Athas: nobody cares about correctness as long as it’s fast!
12:23:27 <Athas> Wellll, I guess my compiler kind of assumes of of what -ffast-math does, anyway.  You kind of have to squint and pretend floating-point math is associative if you want parallelism...
12:33:36 <eschnett> associativity and handling nans/infs properly are independent properties
12:36:20 <isd> Hey all. I'm hitting an issue with haddock; it's giving me a parse error for this: http://pastebin.com/DJSSMp91 though the module compiles fine. I'm not sure what the issue is there.
12:36:51 <isd> Specificaly, it complains about the second !
12:37:12 <isd> Foo.hs:6:5: error: parse error on input ‘!’
12:41:03 <isd> Seems to have the same issue without the strictness annotations. I thought you could document individual fields, am I mistaken?
12:42:21 <dmj`> isd: if you remove the strictness annotations it will still error in the same way
12:42:46 <dmj`> isd: adding field names would resolve it, but it seems like this is a limitation
12:43:45 <jmg8766> dmwit, not sure how I would go about reusing my rotations?
12:44:17 <dmwit> jmg8766: Start by splitting out generating a rotation from using it.
12:45:03 <dmwit> jmg8766: i.e. write `rotation :: Int -> [a] -> [a]` which does things like `rotation 0 "abcde" = "abcde"` and `rotation 2 "abcde" = "cdeab"`.
12:45:13 <dmwit> jmg8766: And use that in your implementation of `p`.
12:45:39 <dmwit> jmg8766: Then you can move from there to writing `rotations :: [a] -> [[a]]` and using that in `p`/`perm`, instead.
12:46:00 <dmwit> jmg8766: Then you can move to writing `rotations` directly instead of writing it in terms of `rotation`.
12:46:12 <isd> dmj`: ok, thanks. Unfortunately the real example has multiple variants, so can't just make it a record, but I'll figure something out.
12:47:16 <wizard133> i'm using ghci on osx (installed via homebrew) and everything is crashy
12:47:34 <wizard133> for example i define a factorial function recusrively
12:47:37 <wizard133> try to compute factorial 2
12:47:45 <wizard133> and get a stack overflow
12:48:09 <Tuplanolla> Let's see the definition.
12:48:10 <wizard133> i kinda think something is wrong with my install but i can't figure out what's up
12:48:20 <wizard133> factorial 1 = 1
12:48:26 <wizard133> factorial n = n * factorial (n-1)
12:48:33 <wizard133> factorial 2
12:48:38 <wizard133> *** Exception: stack overflow
12:48:42 <wizard133> lolwut
12:48:44 <wizard133> i'm a haskell noob
12:48:54 <Tuplanolla> Did you put those on two different lines?
12:49:03 <wizard133> yeah that's two different lines in ghci
12:49:05 <Tuplanolla> The latter definition shadowed the former.
12:49:22 <Tuplanolla> Try `let {firstLine; secondLine}`.
12:49:32 <wizard133> ok... so i need to write my sample code in a .hs file
12:49:37 <Tuplanolla> That's even better.
12:50:02 <wizard133> how does the interpreter handle reloading
12:50:11 <wizard133> is it "clean" or is it better to just use ghc and execute
12:50:21 <Tuplanolla> It cleans up your previous definitions.
12:50:51 <wizard133> meaning, it works cleanly on reload, as one would expect
12:51:00 <Tuplanolla> That it does.
12:51:55 * Naughtmare[m] sent a long message: Naughtmare[m]_2017-02-15_20:51:33.txt - https://matrix.org/_matrix/media/v1/download/matrix.org/iHdPkFUujyxGFsELYqMlAtlb
12:51:59 <dmwit> Tuplanolla: Just for fun, the `let` and `{}` aren't even needed.
12:52:00 <Naughtmare[m]> in ghci
12:52:18 <Tuplanolla> Isn't that's GHC 8 specific, dmwit?
12:52:43 <dmwit> Tuplanolla: Sure. But so is `factorial 1 = 1` working in the first place.
12:53:10 <Tuplanolla> Ah.
12:53:16 <wizard133> btw, i discovered that 2^5000000 can cause both Bus error: 10 and segfault
12:53:18 <wizard133> for ghci
12:53:35 <dmwit> wizard133: Works for me.
12:53:50 <dmwit> > length . show $ 2^5000000
12:53:53 <lambdabot>  1505150
12:53:58 <dmwit> Even lambdabot can handle it. =P
12:54:14 <wizard133> Prelude> length . show $ 2^5000000
12:54:15 <wizard133> Segmentation fault: 11
12:54:25 <wizard133> that's on my machine :-P
12:54:33 <dmwit> Fun!
12:54:36 <wizard133> i'm on a macbook air
12:54:41 <dmwit> Is it possible you have a libgmp version mismatch?
12:54:44 <Tuplanolla> I sense GMP troubles.
12:56:38 <wizard133> i did some quick googling and haven't found documentation on that problem that i can follow as a noob
12:56:46 <geekosaur> wizard133, what ghc version?
12:56:55 <geekosaur> that's a known issue with at least older ghc on OS X
12:57:16 <wizard133> i am pretty sure i installed haskell via brew install haskell-stack
12:57:34 <wizard133> 8.0.1
12:58:15 <mofasa> I want to bind a variable to a random value if some condition is true, else bind it to a (non-random) value. Like this: " let aNum = if True then getRandomR(0::Int,10) else 3 :: Int " But I'm getting type errors since one value is monadic and the other is not.
12:59:14 <lyxia> else return 3
12:59:33 <kadoban> You probably also want  aNum <-    instead of let aNum =   then
12:59:37 <wizard133> do i expect that problem on ghc 8.0.1 ?
12:59:57 <mofasa> ah both where needed thanks lyxia+kadoban
13:01:23 <geekosaur> wizard133, I had thought it was fixed, and in fact don't see the bug in the open OS X bugs
13:01:43 <geekosaur> but it's happened on enpough versions that it's probably worth (re-)reporting it
13:01:53 <wizard133> so,... i guess ill do some kind of udpate thing
13:04:09 <patientpl> im trying to get this haskell one-off program to work and the people in haskell-beginners cant help. would anyone be willing to look? https://paste.ee/p/BPNlZ
13:05:17 <wizard133> yeah so  i just upgraded my haskell-stack package with homebrew, it's still version 8.0.1, and i get the same Bus error: 10 message
13:05:44 <geekosaur> 8.0.2 should be current, although I doubt it would fix it
13:06:19 <kadoban> I would assume that 'haskell-stack' is just the stack program, and not GHC itself. Though if you switch to a newer resolver, lts-8 for instance, stack will use GHC 8.0.2 if you want to try that.
13:06:33 <kadoban> I could be wrong though, I don't know homebrew at all.
13:08:19 <monochrom> But my view is different. I think people are drawing analogies from "the TCP/IP stack" and "I'm a full-stack developer" so "haskell-stack" includes everything.
13:08:59 <geekosaur> kadoban, homebrew is mostly build-from-source so ghc will have been pulled in as a build dep
13:09:27 <monochrom> That's a weird way to get the same conclusion :)
13:09:42 <kadoban> Oh I see
13:11:07 <wizard133> i'm a total moron when it comes to this stuff
13:11:25 <wizard133> i was told "stack just works" and "install stuff with homebrew" so i'm doing that :P
13:11:37 <geekosaur> people say lots of things
13:12:12 <wizard133> people say global warming is a hoax perpetrated by the chinese
13:13:34 <dedgrant> something something cabal build something something heat death of universe
13:14:00 <wizard133> what is the "preferred" way of installing on osx
13:14:35 <kadoban> wizard133: from the docs, https://docs.haskellstack.org/en/stable/install_and_upgrade/#mac-os-x , though I have no knowledge if that will go better for you or not
13:14:50 <wizard133> ok so do i need to run on a vm or something
13:16:12 <kadoban> If you continue to have big problems running it, I guess that'd be an option. ubuntu-ish linux seems to be a good platform, from what I can tell, if you want to go that way I guess.
13:16:23 <wizard133> haha
13:16:26 <kadoban> I know there are people who use it on osx though, so it shouldn't be necessary ... but I have no personal experience there.
13:16:44 <wizard133> you'd think it shouldn't be *that* hard
13:16:55 <geekosaur> you'd think
13:16:56 <kadoban> Indeed
13:17:18 <wizard133> and osx should probably be a priority for the haskell team as a platform
13:17:25 <wizard133> since we hipster types are more likely to try haskell
13:17:26 <geekosaur> people have thought that before. so we have fink, then macports, then homebrew, all hitting the same problems, finding the same not quite solutions, and then fading out
13:17:57 <wizard133> i've had other weird build problems on osx
13:18:14 <wizard133> there's something about osx ssl being weird,... and i've had problems with opengl
13:18:16 <ystael> Fortunately Apple is busy correcting the problem presented by their popularity among the developer market
13:18:35 <geekosaur> ^
13:18:39 <wizard133> right,... i get the impression that they are degrading their compatability?
13:18:59 <Tuplanolla> You forget that Haskell is not hip at all. It's 26 years old, academic and boring, wizard133.
13:19:08 <wizard133> haha
13:19:34 <wizard133> you don't think it's experiencing an uptick in popularity?
13:19:55 <ystael> The plural of anecdote is not data, but I don't know any developers who want a laptop without an escape key.
13:20:02 <wizard133> lol
13:20:18 <wizard133> and if you want a disk bigger than X (X = 512gb?) you have to lose the escape key
13:20:24 <wizard133> http://insights.dice.com/2016/11/10/haskell-old-language-grows-popularity/
13:20:35 <wizard133> "Which brings us to one of TIOBE’s highlights for November: Haskell, a 26-year-old programming language, has continued to grow in popularity, coming within 0.255 percent of breaking into the Index’s top 20 languages."
13:21:11 <lwm> Don't worry, the terrible documentation will scare everyone off in a few weeks :)
13:21:21 <wizard133> haha
13:21:28 <lwm> wizard133: I kinda missed the start but what's the stack trace? You have the latest binary?
13:21:43 <wizard133> GHCi, version 8.0.1: http://www.haskell.org/ghc/  :? for help
13:21:44 <wizard133> Prelude> 2^5000000
13:21:44 <wizard133> Bus error: 10
13:21:46 <wizard133> is the problem
13:21:51 <wizard133> on osx, macbook air
13:22:35 <nickels2> hi everyone, how can I use packages installed via cabal?
13:22:52 <wizard133> ghci -fexternal-interpreter -prof
13:22:52 <wizard133> GHCi, version 8.0.1: http://www.haskell.org/ghc/  :? for help
13:22:52 <wizard133> Prelude> 2^5000000
13:22:52 <wizard133> ghc: ghc-iserv terminated (-11)
13:22:54 <wizard133> Leaving GHCi.
13:23:08 <wizard133> i guess that's a stack trace? :P
13:23:40 <sternmull> i want to parse binary messages lazily (actually one strict message each time would be ok too) and write output while doing that. Would a monad transformer for IO and Data.Binary.Get be a good approach?
13:25:18 <lwm> nickels2: you just reference it in your `build-depends` list in <project-name>.cabal and run cabal build
13:29:47 <nickels2> lwm: I haven't learned cabal yet; it looks like any package downloaded with cabal needs to be built then run with cabal, rather than GHC and GHCi?
13:30:55 <glguy> nickels2: If you install a package into the user database (which is the default with cabal-install) then it will be available to GHC/GHCi without using cabal
13:31:56 <nickels2> glguy: ok, so but how do I use said packages?
13:32:15 <glguy> You can import the modules defined by those packages
13:32:39 * monochrom frowns. The user database is ignored when you use sandboxing.
13:33:07 <glguy> I think that's a feature. It's also not the default to use sandboxes
13:33:18 <monochrom> And the global database is something you don't want to touch until you are a cabal expert.
13:33:30 <monochrom> So there is no way to win, eh?
13:33:52 <nickels2> ormg I am sorry for being stupid ppl thank you TwT
13:34:11 <glguy> for common stuff the way to win is just to manage the user package database
13:36:33 <AndreasK> join #haskell-stack
13:36:45 <AndreasK> almost ...
13:38:13 <alexashka> hi, what's the pastebin url?
13:38:19 <monochrom> lpaste.net
13:38:29 <alexashka> for this channel, I should've specified
13:38:36 <monochrom> yes
13:38:47 <alexashka> great, ty
13:39:13 <monochrom> unless you mean http://lpaste.net/new/haskell which is more refined
13:39:58 <monochrom> eh? /new/haskell takes forever
13:40:12 <alexashka> lpaste seems to be lagging altogether
13:41:12 <monochrom> No, I've retested multiple times, lpaste.net alone is immediate, lpaste.net/new/haskell takes forever.
13:41:28 <alexashka> clicking to public freezes, same as new/haskell
13:41:33 <alexashka> to publish that is
13:41:45 <monochrom> Ah yes, actual posting is what I haven't tested.
13:43:26 <alexashka> well maybe I'll just verbalize my question - it's about functional dependencies. Say we have class Plus a b r | a b -> r. How does the unique constraint on a and b producing unique r work itself out?
13:45:17 <lpaste_> alexashka pasted “functional dependencies” at http://lpaste.net/352575
13:45:44 <alexashka> ah there, hopefully that makes my question make sense - how did the compiler figure out the type of r in the pastebin example there
13:47:00 <monochrom> Something is wrong, there are two ::'s on the same line.
13:48:11 <alexashka> in the pastebin?
13:48:20 <monochrom> Yes.
13:48:27 <monochrom> Also, there are syntax errors.
13:48:41 <geekosaur> monochrom, that's normal, :t echoes what you gave it which includes any type ascriptions
13:49:13 <monochrom> err, no, not syntax error, I don't know what error it is, but it is an error.
13:49:17 <glguy> The stuff :t echos isn't even necessarily well-formed, it blindly adds the :: onto echoed lambdas, for example
13:49:20 <geekosaur> which is admittedly weird, but it is what it is
13:49:31 <geekosaur> yep
13:49:39 <alexashka> monochrom: there are language extensions needed to run the code
13:49:46 <monochrom> OK it needs UndecidableInstances
13:50:04 <alexashka> it's a copy-pasted example from https://byorgey.wordpress.com/2010/06/29/typed-type-level-programming-in-haskell-part-i-functional-dependencies/
13:50:47 <alexashka> to run the code you'll need: MultiParamTypeClasses, FlexibleInstances, and EmptyDataDecls, UndecidableInstances
13:51:07 <jmg8766> is there a ways to cons an item onto a list in a map like this map (1:) [[1],[2],[3]] = [[1,1],[1,2],[1,3]]
13:51:51 <MVQq> jmg8766: give it a try in ghci
13:52:21 <alexashka> jmg8766: fmap ((:) 1) list
13:52:33 <jmg8766> alexashka okay thankyou
13:52:36 <MVQq> :<
13:52:56 <glguy> > map (1:) [[1],[2],[3]]
13:52:58 <monochrom> You have "m n -> r". So there will be at most one solution for r, after m and n are given.
13:52:59 <lambdabot>  [[1,1],[1,2],[1,3]]
13:53:37 <jmg8766> glguy, omg I thought I just tried that and it wasn't working
13:53:38 <monochrom> You start with "Plus (S Z) (S Z) r". The first (S Z) matches "instance whatever => Plus (S m) n (S r)"
13:53:52 <alexashka> monochrom: so the compiler figures out since we have m and n = Z n, r must be Z n?
13:54:04 <monochrom> Therefore m = Z, n = S Z, r = S r (different r)
13:54:22 <monochrom> Maybe I hate using "r" multiple times.
13:55:04 <lalalala> Hey, anyone here?
13:55:14 <monochrom> You start with "Plus (S Z) (S Z) b". The first (S Z) matches "instance whatever => Plus (S m) n (S r)". Therefore m = Z, n = S Z, S r = b.
13:55:57 <lalalala> https://gist.github.com/freddedotme/ab82fd0586aadc7d5dfc913b276c4984 
13:56:05 <lalalala> How do I get a IO Int to a Int?
13:56:12 <lalalala> I've tried to fix it for a while now, not sure how to do it.
13:56:33 <monochrom> But the "whatever" now requires "Plus Z (S Z) r"
13:56:55 <alexashka> lalalala: you need the function >>=, to extract it out
13:57:06 <lalalala> alexashka: could you give me an example, please?
13:57:06 <mmachenry> lalalala: You can operate on stuff done in IO most easily using the do notation.
13:57:10 <geekosaur> ...but you have to put it back afterward. no, you cannot avoid this
13:57:20 <monochrom> The first Z matches "instance Plus Z n n". Therefore n = S Z, r = n = S Z.
13:57:26 <mmachenry> do { mynumber <- readIntFromUser; print mynumber }
13:57:36 <alexashka> lalalala: someIOA >>= \a -> doSomethingWithA a
13:57:42 <monochrom> Therefore b = S r = S (S Z).
13:57:56 <lalalala> alexashka: I'm new, so I don't really get that definition, sorry.
13:58:15 <monochrom> The computer stops because it assumes that there are no other solution (fundep).
13:58:30 <alexashka> lalalala: the more intuitive version is probably with a do block: do a <- someIOA; return $ doSomethingWithA a;
13:58:46 <lalalala> alexashka: i'll try to implement it, i'll be back otherwise, thanks.
13:59:29 <ertes> $ $ $ $ $ …
14:00:34 <lalalala> alexashka: like this? https://gist.github.com/freddedotme/cf8a4c72a2654e6d0e87509f0e8b364e
14:00:59 <alexashka> monochrom: I'm comprehending what you wrote :)
14:01:08 <jmg8766> dimwit: this is what i'm at now http://lpaste.net/352571
14:01:51 <alexashka> lalalala: that looks pretty good, does it work?
14:02:35 <alexashka> lalalala:  as in, is that what you wanted?
14:02:36 <lalalala> alexashka: no, let me show where I use it, it still complains on IO Int.
14:02:39 <lalalala> well it compiles
14:02:42 <lalalala> hold on
14:03:05 <lalalala> alexashka: getElement (genRandomInt 0 10)
14:03:13 <lalalala> getElement is a function that takes a element at a position
14:03:20 <lalalala> I just put 0 10 for testing purposes, but it complains.
14:03:32 <lalalala> on IO Int.
14:03:40 <alexashka> lalalala:  what is the function type for getElement? 
14:03:59 <lalalala> Int -> String
14:04:11 <alexashka> lalalala: right, and you're giving it IO Int, and it's not happy :)
14:04:26 <lalalala> alexashka: but didn't the randomInt return a Int now or?
14:04:38 <alexashka> lalalala:  no no, anytime you enter IO, you don't get to leave :)
14:04:48 <lalalala> alexashka: so how would I solve that?
14:05:01 <lalalala> alexashka: can I use IO Int -> String?
14:05:05 <ertes> lalalala: do the same you did with genRandomInt:  do x <- genRandomInt 0 10; return (getElement x)
14:05:26 <lalalala> oh I have to do the random in the function instead?
14:05:35 <jmg8766> dimwit: still not sure about the base case simplification
14:05:44 <alexashka> lalalala: what you're having trouble with is understanding how the IO monad works
14:05:57 <lalalala> alexashka: mhm
14:06:06 <ertes> lalalala: whenever you write "x <- c" and (c :: IO A) for some A, then (x :: A)
14:06:11 <alexashka> lalalala: I'd recommend a tutorial on that, because if you don't get that, you'll be in a cycle of pain :)
14:06:24 <ertes> lalalala: https://www.vex.net/~trebla/haskell/IO.xhtml
14:07:20 <alexashka> lalalala: your main program is always IO (). Meaning you start off inside IO, so you don't really need to get out of it
14:07:27 <jmg8766> dimwit: I think I figured it out actually http://lpaste.net/352571
14:08:01 <alexashka> lalalala: what's nice is you can have pure functions of type Int -> String. And you use them within your main program
14:08:56 <Baude> what is a monad?
14:09:12 <monochrom> Depends on why you want you know.
14:10:28 <lalalala> hmm okey
14:10:32 <lalalala> so how come this won't work then? https://gist.github.com/freddedotme/96958fc85a136183b0650f123df0a0ab
14:11:23 <ertes> lalalala: just a mistake
14:11:29 <lalalala> ertes: hm?
14:11:42 <ertes> return (getElement x0 ++ getElement x1)
14:12:06 <ertes> the way you have written it it would be read as:  (return getElement x0) ++ (getElement x1)
14:12:27 <lalalala> ertes: still doesn't work, hold on let me print error
14:12:40 <geekosaur> Baude: it's a type that supports two operations "pure" (or "return") and "bind" aka (>>=), and some simple rules relating them. it's a surprisingly flexible pattern
14:12:40 <ertes> lalalala: it still has a type error
14:12:47 <lalalala> ertes: yea? Couldn't match type ‘IO’ with ‘[]’
14:13:03 <ertes> lalalala: nothing that uses genRandomInt could ever be of type String
14:13:12 <ertes> it has to have an IO in the type
14:13:22 <ertes> lalalala: read the IO tutorial i linked…  it explains everything
14:14:20 <alexashka> lalalala: if you make the type IO String instead of String, it'll work :)
14:14:27 <alexashka> lalalala: but yes, what ertes said about tutorial
14:14:35 <Clint> assuming getElement gives you a String
14:14:38 <lalalala> it didn't work with Io String
14:14:41 <lalalala> IO*
14:16:12 <lalalala> It did, but then it just continues to the next function that doesn't use it, I'll read that tutorial.
14:17:37 <alexashka> lalalala: try doing IO String and "return $ getElement x0 ++ getElement x1" - add a dollar sign after return
14:18:43 <alexashka> lalalala: learning haskell without an IDE that points out syntax errors is very hard. I'd recommend getting a vim/emacs plugin for haksell or I use atom with a haskell plugin
14:20:20 <lalalala> alexashka: that works, but the thing is that the function calling that function complains on IO String now, hehe.
14:20:27 <erewok> I agree with this point about IDE help
14:20:46 <alexashka> lalalala: haha yes :) you don't get to leave the IO once you get into it
14:21:19 <lalalala> alexashka: I dun like IO. :(
14:21:25 <alexashka> lalalala: so the way most people do it as far as I know is they separate out functions that need IO, like getting a random number, accessing db, network requests, and pure functions like addition/subtraction
14:21:36 <EvanR> getting in and getting out of IO might not be the best intuition 
14:21:46 <lalalala> I need to have a talk with the IO guy
14:21:48 <alexashka> lalalala: it's quite jarring coming from a language without monads
14:22:17 <lalalala> alexashka: so in a sense the function calling the function returning IO String also has to return or use IO types+
14:22:21 <EvanR> IO Foo is simply a type for commands that do something and return a Foo, its not magic.
14:23:54 <alexashka> lalalala: that's the intuition yes, that you can only compose things of similar type. so you can chain IO stuff together. Or Maybe stuff together, etc
14:24:15 <lalalala> mhm
14:24:20 <EvanR> lalalala: thats not true at all
14:24:24 <lalalala> i put the IO stuff in the corner once im done with it
14:24:40 <alexashka> lalalala: you start off in IO, so you don't need to ever put it aside :)
14:24:42 <EvanR> you can write functions to process IO actions all you want, they dont need to have an IO return type
14:25:11 <EvanR> IO actions can be placed in data structures, send through channels, stored and retrieved, sorted and randomized, whatever
14:25:27 <lalalala> I think I'm close now, but now it complains on a Show IO.
14:25:27 <EvanR> they are regular values
14:25:58 <alexashka> EvanR: you're talking to a beginner, what you're saying is flying over his/her head :)
14:26:03 <EvanR> its true they have no Show instance
14:26:23 <lalalala> god, do IO have any pros?
14:26:27 <lalalala> no show instance either?
14:26:49 <EvanR> alexashka: the seeds of "this intuition isnt really right" have hopefully been planted
14:27:04 <alexashka> lalalala: it's probably easier if you pastebin your entire half page program :)
14:27:27 <ezyang> If you have an m :: IO String you want to show, first x <- m and then do what you want 
14:27:39 <alexashka> EvanR: *shrugs* I'm all for misleading a little to get the person to a happy place, that's why we have Santa Clause
14:28:07 <alexashka> EvanR: you can go tell 3 year olds santa isn't real all you want, lol
14:28:08 <EvanR> i cant empathize with the belief in santa
14:28:19 <EvanR> or having 3 year old kids to teach haskell to
14:28:38 <lalalala> alexashka: e voila: https://gist.github.com/freddedotme/5b20002898c7d010c54f6ed4e2fc9064
14:28:47 <alexashka> EvanR: that's fine, that's why I'm talking to lalalala ;) I'm all for Santa Clause
14:29:01 <lalalala> santa claus is not real
14:29:01 <EvanR> so am i
14:29:07 <EvanR> talking to lalalala 
14:29:14 <lalalala> im popular :>
14:29:44 <lalalala> so the thing is now, I use genTeams and a example value I have, and since it doesn't have a show instance, it throws that error
14:31:09 <erewok> I wrote something simple awhile back to create random strings of vowels and consonants
14:31:12 <erewok> https://gist.github.com/pellagic-puffbomb/cdd68522ce03eb78e942
14:31:42 <erewok> it might be illustrative, lalalala
14:31:49 <EvanR> lalalala: its true that it simplies things if youre working on the part of the problem that doesnt actually do IO, you dont use IO
14:32:14 <EvanR> if you dont pay attention to that it can infect your whole program
14:32:25 <lalalala> I needed the IO for the genTeamName or?
14:32:37 <erewok> yeah, one thing to notice is that any function that calls any other function that results in an IO Something must itself return IO somethingOrSomethingElse
14:32:37 <alexashka> lalalala: ok so the Show thing, all basic types in Haskell have a Show instance, which means 'convertible to a string'
14:32:38 <lalalala> and then I had to use a IO String and so on I guess
14:33:42 <lalalala> alexashka: yeah, but it has an IO String in Team now so it throws that exception
14:34:19 <alexashka> lalalala: right, because IO Anything - means a computation, the result of which, is Anything
14:34:32 <alexashka> so until you've done the computation, you have nothign to Show :)
14:34:49 <lalalala> alexashka: so how do I "exit" out of that? I mean I have generated my string?
14:35:06 <geekosaur> you don't
14:35:22 <lalalala> so I'll never be able to show my teams now then?
14:36:32 <alexashka> lalalala:  i wish someone more experienced would explain this IO conundrum you're having. I know how to make it work but I don't k now how to explain it properly :)
14:37:03 <alexashka> lalalala: other than to say to read a book on the basics of haskell - I'm confident that'd help you
14:37:16 <alexashka> lalalala: and you wont' get far without doing it at some point, so
14:37:29 <glguy> lalalala: You're misunderstanding what IO does. You'd do well to start reading the link that has been posted earlier and then ask questions to get to understanding that page
14:37:39 <glguy> https://www.vex.net/~trebla/haskell/IO.xhtml
14:38:48 <alexashka> lalalala: Haskell is unusual in that things that are extremely easy in other languages, are painfully hard in Haskell, in the very beginning. It's just a wall you have to climb if you want to get to the other side
14:40:05 <dolio> That doesn't sound accurate to me.
14:46:43 <lalalala> alexashka: do you use the chaining a lot, like the return $ function foo? Like I did with the randomInt in the beginning?
14:48:33 <Zemyla> Sweet Christmas, I'm trying to compile Idris, and so far, it's taking 5 GB of memory.
14:49:17 <`Guest00000> Zemyla: it's normal
14:49:23 <`Guest00000> add some more to swap
14:49:28 <`Guest00000> capacity
14:49:32 <alexashka> monochrom: I've got it :) It seems devilishly clever to be doing that
14:50:37 <monochrom> OK!
14:51:30 <Zemyla> `Guest00000: It should not be normal. Why is it normal?
14:51:58 <EvanR> how are you measuring memory usage
14:52:02 <Zemyla> I don't even know what it's doing at this point, since it's not launching any applications.
14:52:25 <`Guest00000> Zemyla: normal as in i've done a similar thing and has similar experience
14:52:45 <Zemyla> EvanR: The display in Process Explorer. It's using 5 GB of memory, of which 3 GB is currently in swap.
14:53:34 <`Guest00000> Zemyla: it's a dependent-types functional language compiler. those things are big, and use a lot of complexly-typed libraries
14:53:52 <EvanR> idris has taken a long time for me to compile
14:54:08 <EvanR> not sure how much memory, but i have heard modern GHC is taking more memory than ever
14:54:35 <Zemyla> My question is, is all that memory actually being used concurrently, or is it just leaked?
14:54:36 <`Guest00000> though i was surprised too at first
14:54:39 <geekosaur> the more they overthink the typesystem^Wplumbing...
14:54:40 <EvanR> and if its compiling idris code with idris in the proces... well i just tried to compile some dependent types that took 15 minutes
14:55:23 <EvanR> (but not much memory at all)
14:55:51 <Zemyla> We really need a GHC alternative that doesn't use stop-the-world garbage collection.
14:56:43 <EvanR> throw out the whole compiler because of the GC...
14:57:08 <EvanR> then you want an alternative alternative that does some other thing differently
14:57:44 <Zemyla> Yeah, I know.
14:58:15 <Zemyla> It's just that, even if something is in memory and isn't being currently used, it has to stay in swap because the GC goes over it all the time.
14:58:40 <EvanR> i still question your memory usage measurement
14:58:57 <EvanR> virtual memory obscures whats "really in use"
14:59:22 <EvanR> stuff in swap could either be harmless because its not in use, or denial of service because it is
15:00:21 <EvanR> and since most programs, not sure about GHC, dont return memory to the OS, the process explorer is trolling you
15:02:06 <ezyang> well, it's also bad because newer GHC compiled programs always reserve 1TB virtual address space :) 
15:02:45 <Zemyla> Well, it appears to be GCing at the moment, because the private bytes aren't increasing, but the working set is increasing steadily.
15:03:15 <EvanR> oh, youre profiling it?
15:04:00 <Zemyla> I don't have a profiler open, but why else would the working set just increase monotonically without the private bytes increasing?
15:04:50 <EvanR> i do not know this terminology or what OS that is
15:10:55 <barrucadu> If I want to propose an addition to base, is the libraries@ mailing list still the place to do it, or is there some repo I should send an RFC to now?
15:11:21 <johnw> ezyang: good luck with the talk tonight; sorry I'll miss it
15:11:52 <Zemyla> EvanR: The private bytes is how much virtual memory it's using; the working set is how much is in physical memory.
15:14:35 <ezyang> no problem :) 
15:16:34 <lalalala> alexashka: is there a way to solve so I don't have to use IO String in my team, or that was on the right way?
15:18:08 <alexashka> lalalala: IO is going to be anywhere where you need to talk to the operating system. So to open/close files, make system calls etc. That random number function you're using, is what's using IO in your case
15:18:33 <lalalala> alexashka: I tried to make a main function that uses genTeams, but that still won't work. :/
15:18:35 <alexashka> lalalala: so if you stick to just a recursive function of giving each player/team a name of 1, 2, 3, 4 instead of a random number, you'll be abl eto get rid of IO
15:19:12 <alexashka> lalalala: hehe I'm not sure what you mean
15:19:15 <lalalala> alexashka: the random number is used to get a random adjective and noun, not a number.
15:19:39 <alexashka> lalalala: genRandomInt 0 10 - this uses IO
15:20:01 <lalalala> yeah, and I need it to generate a random strings
15:20:13 <alexashka> lalalala: right, so if you want random things, you'll have IO :) no way around it
15:20:18 <glguy> lalalala: Do you understand that given: x :: IO Int; x = randomRIO (0,9)
15:20:25 <geekosaur> note that you can get the seed from IO once and pass it as an argument (this is made easier with MonadRandom or MonadState but you can do it manually)
15:20:26 <glguy> That there is no actual random number chosen?
15:20:59 <lalalala> glguy: i assume it's chosen on return or?
15:21:00 <glguy> in that example x is a process of choosing random numbers, it's not a random number
15:21:04 <geekosaur> ...you have to thread the seed through random generation yourself in that case since you will get a new seed back
15:21:10 <monochrom> I shall need to improve my "program structure" section for this.
15:21:32 <lalalala> so it'll be a headache for me to use random or?
15:21:33 <monochrom> lalalala: Also, http://lpaste.net/352579
15:21:39 <glguy> lalalala: You can define a new action based on x that uses random numbers
15:22:02 <glguy> all of this is building up to defining an action that you call main
15:22:10 <glguy> running that action means running your program
15:22:31 <glguy> A cake recipe might have type: IO Cake
15:22:38 <glguy> There's no cake in a cake recipe
15:22:50 <alexashka> if someone's having trouble with IO, giving them StdGen is furthering their confusion imho :P
15:22:54 <glguy> You can't extract the cake. but you can "run" the recipe
15:23:19 <lalalala> I did this in my main: main = do genTeams (getPlayers 10), is that wrong?
15:23:22 <EvanR> alexashka: throwing out real understanding and then trying to give hocus pocus solutions cant be helping
15:23:50 <monochrom> No, getting confused by StdGen indicates having problem with the whole notion of PRNG.
15:23:57 <geekosaur> ^
15:24:08 <alexashka> EvanR: fair point :)
15:24:11 <glguy> lalalala: That means that running your program involves generating some teams and then exiting (if that's the whole of your main)
15:24:15 <maerwald> I never got the "cake" analogy wrt IO
15:24:39 <lalalala> glguy: yes but it won't run because of the IO thing
15:24:47 <maerwald> it's the same like burrito... just leave the kitchen out please
15:25:01 <glguy> maerwald: No, it's unrelated to explaining monads as burritos
15:25:06 <monochrom> But I want to include the kitchen sink!
15:25:10 <maerwald> glguy: ?
15:25:10 <lalalala> burritos nom
15:25:19 <nshepperd_> You wouldn't execute a burrito
15:25:26 <alexashka> haha :)
15:25:28 <EvanR> cake is a new one to me, i also heard "IO String contains a string in the same sense that `ls` contains a string"
15:25:44 <maerwald> glguy: you're not baking anything. Just explain what really happens. Explain there is an RTS, explain why the IO type is so weird in GHC.
15:25:47 <glguy> maerwald: Explaining IO as instructions is different from explaining monads as burritos
15:25:47 <maerwald> explain the real stuff
15:25:51 <monochrom> You wouldn't want me to explain IORef :)
15:25:53 <maerwald> don't come up with random stuff like cakes
15:26:00 <glguy> maerwald: Your connecting the wrong dots
15:26:11 <lalalala> so I got "Couldn't match expected type ‘IO t0’ with actual type ‘[Team]’", so I did the datatype to return IO Team, but then all my guards and patterns are wrong.
15:26:13 <glguy> In one case the "food" was the monad type, in that cake example it was a return value
15:26:24 <glguy> You're*
15:26:29 <maerwald> glguy: no, you're just not getting the argument ;)
15:26:47 <maerwald> stop with analogies, explain things
15:26:54 <glguy> this is tha actual explanation
15:27:07 <maerwald> I disagree with you
15:27:10 <glguy> OK
15:27:12 <lalalala> :o
15:27:21 * geekosaur *eyeroll*
15:27:36 <lalalala> i want cake
15:27:40 <nshepperd_> It's not an analogy. You could have an actual cake recipe with type IO Cake. Given some advanced robotics
15:28:53 <EvanR> what
15:29:11 <nshepperd_> (Presumably Cake would be a cake handle though, rather than an actual cake, since cakes aren't virtual)
15:29:23 <EvanR> Cake would be a type, but cake isn't some value
15:29:46 <erewok> this is like that slidedeck from a few weeks back where someone made the argument that you should never say “monadic IO” or “IO Monad”
15:29:51 <maerwald> nshepperd_: "There's no cake in a cake recipe" is the wrong way to explain it imo
15:29:56 <erewok> you should say “IO Action” or something.
15:30:28 <maerwald> and that _is_ analogy
15:30:35 <EvanR> <attack at dawn> :: IO (), its an instruction, a timeless expression, just data
15:30:39 <geekosaur> 3d food printer? :p (yes they exist)
15:30:49 <EvanR> it doesnt mean anyone is being attacked
15:30:50 <erewok> I don’t have any opinion here. I imagine that different people learned differently.
15:30:57 <maerwald> and "burrito" has caused similar confusion
15:31:02 <maerwald> people should stop that stuff
15:31:21 <monochrom> Can a C program make a cake?
15:31:31 <monochrom> And does a C program contain a cake?
15:31:40 <maerwald> monochrom: ask in ##c :P
15:31:43 <maerwald> (or better not)
15:32:08 <ezyang> I like the recipe analogy 
15:32:11 <nshepperd_> IO actions are procedures
15:32:21 <nshepperd_> That's not far from recipe
15:32:30 <monochrom> Ah, I see the light. It is the other way round. Cake contains C. Soviet Russia etc.
15:32:32 <nshepperd_> It's basically the same thing
15:32:56 <maerwald> nshepperd_: so you shove cake recipes into an RTS that exectues them? Maybe say "the RTS is the oven"?
15:32:57 <EvanR> that analogy doesnt distinguish IO actions made up of a series of steps from functional algorithms composed of a series of steps
15:32:58 <maerwald> or wat
15:33:07 <erewok> the problem I had with monads and IO is that they never truly made sense until I used them a lot and learned some basic syntax and then didn’t pay attention at all to what was happening.
15:33:17 <EvanR> both of which "produce" *not food* but data you get back in computer lang
15:33:19 <EvanR> land
15:33:23 <maerwald> or wait... do you shove the cake into the oven or the cake recipe?
15:33:27 <erewok> and IO is still relatively mysterious to me, but I can actually write programs that use it. 
15:33:35 <maerwald> or do you make the cake before you can actually bake it?
15:33:39 <maerwald> when do you bake it?
15:34:15 <alexashka> you put the assembled ingredients into the oven, to get a cake ;)
15:34:25 <nshepperd_> No... The rts is the actual ghc rts
15:34:46 <nshepperd_> Ovens can't run recipes, don't be silly
15:35:18 <monochrom> Put a very hot laptop in a well-insulated box. Put your food there too. Now you have an oven.
15:35:29 <maerwald> now things start to make sense
15:35:36 <EvanR> the type parameter to IO is the type of value returned on execution
15:35:51 <maerwald> EvanR: :)
15:35:53 <EvanR> not necessarily the type of real world objects
15:35:57 <monochrom> Then a recipe for heating up food is simply "forever (recompile GHC)"
15:36:28 <EvanR> you dont have IO Email for an action to send email
15:36:29 <kadoban> Haha
15:38:23 <johnw> monochrom: if using a laptop, then I'd be the food in that case
15:39:09 <nshepperd_> EvanR: it would be Email -> IO () of course
15:39:15 <monochrom> Are both of you in a well-insulated box?
15:39:39 <monochrom> But nom nom nom
15:39:48 <EvanR> right
15:39:54 <EvanR> so Cake -> IO () makes more sense
15:40:10 <EvanR> cake descriptor => ??? => real cake
15:40:16 <monochrom> Remember the good old days when monochrom said, "I love newbies, I eat them for breakfast"
15:40:35 <nshepperd_> No, Cake -> IO () would be something that eats a cake
15:40:42 <maerwald> xD
15:40:45 <nshepperd_> Or puts it in the fridge or something
15:40:49 * EvanR falls through a table
15:41:13 <monochrom> newtype Economy = Ctor (Money -> Economy)
15:41:59 <nshepperd_> Assuming, again, some elaborate Rube Goldberg automated cooking apparatus attached to the computer running the program
15:42:26 <maerwald> nshepperd_: it's not an IORef or MVar or something else, how would it eat the cake?
15:42:40 <maerwald> the cake is still there
15:42:43 <nshepperd_> Obviously you can't eat a cake without any arms
15:42:50 <`Guest00000> i have a type constructor which takes Nat, and i want to emit a warning when the natural is >= 256. is this possible?
15:42:51 <johnw> cake = lie
15:44:13 <geekosaur> `Guest00000, you'd need to use a smart constructor (possibly hidden behind a pattern synonym)
15:45:00 <c_wraith> geekosaur, I don't think that helps at the type level. 
15:45:32 <geekosaur> mm, right, in tht case it's ... well there are those customizable type errors I guess
15:45:41 <geekosaur> but paaaain
15:45:54 <c_wraith> `Guest00000, I don't know that customizable type *warnings* exist. 
15:45:56 <geekosaur> (then again that's kinda how I feel about type level computation anyway :p )
15:46:01 <geekosaur> yeh
15:46:23 <geekosaur> for that matter I dont think there are type warnings period
15:46:30 <geekosaur> unless you count typed holes
15:49:16 <jmg8766> is there an equivalent to assert statements in haskell?
15:49:34 <monochrom> Yes, Control.Exception has "assert".
15:49:41 <Axman6> we have a type system so we can avoid needing that in general though
15:50:01 <geekosaur> only if you can encode value restrictions at type level
15:50:24 <jmg8766> I was just wondering because my homework said that "Following each function there should be commented out expressions to test the function"
15:50:28 <Axman6> which you always can, it just may not be pleasant
15:50:39 <geekosaur> I think they just want comments there, jmg8766
15:50:50 <geekosaur> but see http://hackage.haskell.org/package/doctest
15:51:09 <monochrom> "commented out expressions to test the function" is not assert.
15:51:32 <glguy> asserted monochrom
15:51:36 <jmg8766> I guess he means test_a = a arg1 == true && a arg2 == true etc ?
15:52:08 <nshepperd_> I've been discovering that ghc type checker plugins make type level computation fun again. But only if you're prepared to accidentally make your program unsound on the first 3 attempts
15:52:48 <monochrom> I think you'd better ask him.
15:53:11 <monochrom> Better yet he migh have already given examples.
15:54:03 <jmg8766> monochrom unfortunately I won't have a chance before it's due
15:54:05 <nshepperd_> "I need a function to test expected invariants at runtime" asserted Tom.
15:55:21 <hpc> jmg8766: https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Exception.html#v:assert
15:57:06 <geekosaur> with that description I'd just write the function and then put commented-out expressions after it, one per line, of the form f input1 input2 input3 == expected_result
15:58:55 <SudhanshuJ> Hi All! I'm new on irc, can someone help me out with this  forum's guidelines and general tips
15:59:07 <Koterpillar> SudhanshuJ: join #help
15:59:33 <lalalala> can I do a recursive IO method?
15:59:59 <Koterpillar> lalalala: certainly, for example: lalala = print "la la la" >> lalala
16:00:00 <kadoban> lalalala: Yep
16:01:36 <lalalala> Koterpillar: I wrote this, https://gist.github.com/freddedotme/ef0ca756e2a11943d9c26ae65b17ba51, the thing is that I have the same random number for all of the teams.
16:01:48 <lalalala> how could I do instead generate a new one for each?
16:11:04 <lalalala> if I use "return $ value : recursive call"
16:11:14 <lalalala> how do I do that? if I want to use return and call recursive?
16:11:17 <`Guest00000> lalalala: generate a list of random numbers, instead of generating one random number
16:11:27 <lalalala> i fixed it guest
16:12:01 <Koterpillar> lalalala: return means "take this pure value and return it", you can't use IO in its argument
16:12:18 <lalalala> Koterpillar: so how do I do when I have a recursive call?
16:12:29 <lalalala> like this: "return $ genTeam r0 r1 [x0, x1] : genTeams r0 r1 xs"
16:12:32 <lalalala> or I mean, what do I do instead.
16:12:47 <Koterpillar> lalalala: you have to perform that recursive action first, then make your result from it
16:12:59 <lalalala> how?
16:13:06 <Koterpillar> lalalala: rest <- genTeams r0 r1 xs; return $ genTeam r0 r1 [x0, x1] : rest
16:13:14 <Koterpillar> where ; is a newline
16:13:39 <lalalala> oh thx!
16:13:41 <Koterpillar> but now your genTeams is an IO action, you probably don't need to pass r0 and r1 to it, do you?
16:14:06 <`Guest00000> Koterpillar: can also do without the newline, with ";"
16:14:07 <lalalala> I have r0 and r1 in the genTeams function now
16:14:42 <Koterpillar> `Guest00000: but it's ugly :P
16:15:12 <Koterpillar> lalalala: show?
16:15:20 <lalalala> Koterpillar: soon
16:17:44 <lalalala> Koterpillar: oh oh, when I use the rest <- thing, I got IO [IO Team] instead.
16:18:14 <Koterpillar> ?
16:19:10 <Axman6> Anyone familliar enough with C++ to know which function with type Double -> Int matches the behaviour of static_cast<int>(some double)?
16:21:00 <lalalala> Koterpillar: since I use rest <- it's an IO type, so I get IO [IO Team] instead of just IO [Team]
16:21:18 <Koterpillar> show code
16:21:50 <lalalala> Koterpillar: https://gist.github.com/freddedotme/34bdc049e6416bab214e17603cd2364e
16:21:54 <glguy> Axman6: "A prvalue of a floating point type can be converted to a prvalue of an integer type. The conversion truncates;
16:21:55 <glguy> that is, the fractional part is discarded. The behavior is undefined if the truncated value cannot be
16:21:57 <glguy> represented in the destination type"
16:22:12 <c_wraith> is
16:22:33 <lalalala> i'll remove the r0 and r1 Koterpillar 
16:22:33 <Koterpillar> lalalala: I'll at least need the types of genTeam and genTeams
16:22:39 <c_wraith> so.. round-towards-zero? 
16:22:41 <lalalala> Koterpillar: my bad
16:22:45 <Koterpillar> also, did you mean genTeam in the last line?
16:22:49 <lalalala> Koterpillar: genTeams :: [Player] -> IO [Team]
16:22:53 <Koterpillar> good
16:23:02 <lalalala> yes last line Koterpillar 
16:23:04 <Koterpillar> I think you meant genTeam there
16:23:19 <lalalala> ah nope
16:23:25 <lalalala> oh it is
16:23:26 <lalalala> my bad
16:23:27 <lalalala> ...
16:24:08 <lalalala> Koterpillar: it works :D thanks
16:26:55 <Koterpillar> now you can refactor :)
16:49:25 <Axman6> glguy: great, thanks. I was working of the assumptionn it was truncate
17:04:07 <`Guest00000> which package has  function for safe conversion to Word8?
17:07:41 <`Guest00000> why doesn't assert even let user supply string for failure?
17:07:58 <`Guest00000> :t assert
17:07:59 <lambdabot> Bool -> a -> a
17:08:12 <phz_> hm
17:08:27 <phz_> is it normal that contravariant depends upon… StateVar? :D
17:09:29 <geekosaur> any package that exports an instance for a type needs to import that type
17:09:50 <geekosaur> (which is why lens has such a huge dependency list, since it provides lenses for pretty much everything...)
17:09:50 <phz_> yeah I know that, but I don’t see why it’d need StateVar
17:10:08 <geekosaur> Instances ... Contravariant SettableStateVar
17:10:16 <phz_> I’m so frustrated about that
17:10:23 <phz_> I’ve been doing Haskell for three years
17:10:29 <phz_> and one year of Rust now
17:10:38 <phz_> and I feel Rust has it waaaaaaaaaaay right about that policy
17:10:56 <Koterpillar> some packages are split into base package and -instances
17:11:03 <phz_> keep your features “free”
17:11:07 <phz_> don’t add too much
17:11:40 <phz_> Koterpillar: that’s basically making orphan instances, right?
17:11:53 <Koterpillar> yes, in a separate module
17:12:06 <phz_> implementing a typeclass from a package A for a type in a package B from a package C
17:12:11 <phz_> that’s not a good idea to me
17:12:32 <Koterpillar> mhm
17:12:37 <phz_> if StateVar wants a Contravariant instance, it should depends on contravariant
17:12:40 <phz_> not the opposite way
17:12:46 <phz_> I’ve always found that very frustrating
17:12:53 <phz_> especially because I used to depend on linear
17:12:57 <phz_> which, of course, depends on lens
17:13:03 <phz_> hence, 10 minutes compiling.
17:13:03 <phz_> :(
17:13:04 <Axman6> the usefulness of a class comes from it having instances, and those should only be definied with the type's definition or the class'definition
17:13:17 <phz_> Axman6: exactly
17:13:30 <phz_> so in the case of StateVar… in StateVar.
17:13:38 <Axman6> well that explains why we can't safely do what you want without orphan instances
17:13:50 <phz_> ?
17:13:50 <geekosaur> if StateVar had been the one wanting the instance, StateVar *would* have
17:13:59 <phz_> implementing in StateVar requires orphan instances?
17:14:06 <phz_> geekosaur: what?
17:14:09 <phz_> wait, what?
17:14:28 <Axman6> implementing in  stateVar means it needs to import contravariant
17:14:29 <geekosaur> I did not say that
17:14:34 <phz_> Axman6: exactly!
17:14:38 <phz_> that’s the point
17:14:43 <Axman6> so one of them needs to import the other
17:14:48 <phz_> yes
17:14:59 <phz_> and the idea is just that, Axman6 
17:15:07 <geekosaur> I said that if StateVar wanted the instance, then the instance would have been defined in StateVar. Therefore the instance was *wanted* in contravariant, not StateVar
17:15:36 <geekosaur> people do not go randomly editing other packages to add the instances they want
17:15:41 <phz_> contravariant should provide the instances for all the types in Base or the one that are used the most, like mtl/transforms (and even that, I’m not sure)
17:15:48 <phz_> and if others want the contravariant features
17:15:56 <phz_> they should implement it themselves
17:16:10 <Koterpillar> phz_: but the dependency will still be there, just in reverse
17:16:17 <Axman6> this doesn't actually solve your problem, it moves it elsewhere
17:16:20 <phz_> geekosaur: but I don’t want that instance in contravariant!
17:16:27 <Axman6> this isn't a solution
17:16:27 <phz_> Koterpillar: that’s a lot
17:16:34 <geekosaur> are you the author of contravariant?
17:16:35 <phz_> because I depend on contravariant
17:16:45 <phz_> I don’t give a heck having about StateVar
17:16:46 <geekosaur> if not, what you want is not necessarily relevant
17:16:49 <phz_> so why am I downloading it?
17:16:53 <phz_> and losing time compiling it?
17:17:02 <phz_> geekosaur: that’s not true.
17:17:04 <Koterpillar> phz_: people who depend on statevar might not want contravariant either
17:17:05 <phz_> that’s not how it works.
17:17:16 <phz_> contravariant is a VERY useful lib
17:17:20 <Koterpillar> to you
17:17:21 <geekosaur> you have editorial control over the packages you use, then?
17:17:24 <phz_> it’s being used by a lot of people
17:17:32 <phz_> Koterpillar: take linear as another examples if you disagree.
17:17:46 <Koterpillar> Oh, I don't know what either of those packages do :)
17:17:55 <phz_> damn
17:18:01 <phz_> linear is the most used linear algebra package
17:18:05 <phz_> but it depends on lens
17:18:12 <phz_> which brings a LOAD of packages
17:18:16 <phz_> while I don’t use lens.
17:18:24 <phz_> that’s a really bad issue to me
17:18:35 <phz_> and I know a lot of folks are standing away from Haskell because of that
17:18:46 <phz_> I’m a Haskell lover, I try to convince them
17:18:49 <Koterpillar> What do you propose then?
17:18:54 <phz_> but there’s a point in that dependency “reversed” order
17:18:59 <phz_> Koterpillar: I just said it
17:19:01 <phz_> like we do in Rust
17:19:04 <phz_> don’t provide too much.
17:19:11 <phz_> just keep the features “free”
17:19:19 <Koterpillar> What if contravariant was the "large" package?
17:19:31 <phz_> if the author of contravariant wants StateVar implementing contravariant
17:19:42 <phz_> if they can’t edit StateVar
17:19:45 <phz_> they just make a newtype
17:19:52 <phz_> and implement that in their own codebase
17:19:56 <phz_> not in contravariant
17:20:01 <Koterpillar> but won't the newtype depend on statevar still?
17:20:06 <phz_> yes
17:20:11 <phz_> in THEIR codebase
17:20:13 <phz_> (not in contravariant)
17:20:19 <phz_> you don’t provide that instance.
17:20:21 <Koterpillar> so a third package?
17:20:31 <phz_> Koterpillar: no, at the place you use it
17:20:55 <Koterpillar> Assuming there is a canonical implementation for this instance, where should it exist?
17:21:47 <phz_> Koterpillar: in whatever module of yours that uses contravariant
17:22:08 <phz_> the policy should be to reach out the person using StateVar
17:22:08 <`Guest00000> string large or long?
17:22:27 <phz_> “hey, I have an interesting abstraction that you might find useful; do you want an instance?”
17:22:33 <phz_> “– Yes“ -> problem solved
17:22:43 <phz_> “— No” -> just newtype + instance in your code, and done
17:23:13 <phz_> I have to check something, actually
17:23:22 <phz_> yeah right
17:23:24 <phz_> I knew it.
17:23:29 <phz_> contravariant is from ekmett
17:23:34 <phz_> StateVar is from… ekmett.
17:24:03 <Koterpillar> phz_: what do you mean by "module of yours"?
17:24:06 <phz_> (and Sven Panne)
17:24:12 <phz_> Koterpillar: your application
17:24:14 <phz_> or whatever
17:24:31 <phz_> but just don’t put the instance in contravariant
17:24:33 <Koterpillar> I don't have an application, I (pretend) just wrote these two packages, contravariant and statevar
17:24:35 <phz_> because others will need it
17:24:43 <phz_> but they won’t necessarily need your StateVar
17:24:45 <phz_> and actually
17:24:48 <phz_> I really don’t
17:24:55 <phz_> so it bothers me having to download and compile it
17:25:04 <Koterpillar> phz_: have you heard of the term NIMBY?
17:25:13 <phz_> Koterpillar: oh, if you wrote both
17:25:22 <phz_> then just put the instance in the dependent
17:25:25 <phz_> statevar.
17:25:28 <phz_> NIMBY?
17:25:29 <phz_> nope
17:25:51 <phz_> Not In My Back Yard?
17:25:55 <Koterpillar> Then we have your problem in reverse. If contravariant is large, everyone using statevar is wasting time.
17:25:59 <Koterpillar> yes
17:26:33 <Koterpillar> maaaaaaybe Backpack will solve this?
17:26:37 <phz_> Koterpillar: but contravariant is not…
17:26:48 <phz_> it’s just a very “free” package
17:27:08 <Koterpillar> phz_: OK, then it's more economical to reverse the dependency
17:27:15 <Koterpillar> but generally... sigh
17:27:16 <phz_> and I’m not the only one complaining about that
17:27:26 <phz_> I just “accept” it
17:27:31 <Koterpillar> did you complain to StateVar repo?
17:27:36 <phz_> but I know people not committing to try haskell because of this
17:27:52 <phz_> Koterpillar: I just came across it, so, no, I did not
17:27:57 <phz_> but I know ekmett a bit
17:28:00 <phz_> he won’t give a heck :D
17:28:08 <phz_> just look at the mess lens is
17:28:18 <Koterpillar> I don't get the hate.
17:29:06 <phz_> Koterpillar: I don’t like being forced downloading a shit load of packages I don’t give a heck
17:29:10 <phz_> I think it’s legit, isn’t it?
17:29:28 <phz_> I don’t have that problem in Rust because people care about that as well
17:29:36 <Koterpillar> There's a lot of dependencies and all... but compiling a few things beats getting into arguments on the internet, so that's what I choose
17:31:07 <johnw> it is well established that complaining here results in practically zero change; either pull request the change you want to see, or use something else
17:31:35 <phz_> I’m pretty sure the PR would get rejected; I don’t mean the change the ecosystem by myself
17:31:44 <monochrom> it is also well established that humans don't care, they just want to argue.
17:31:48 <phz_> I’m just saying that such an issue is not “NIMBY”
17:31:53 <phz_> a lot of people complain about that
17:31:56 <phz_> and I understand why
17:32:15 <phz_> one of the biggest crate in Rust might be serde
17:32:20 * Koterpillar out
17:32:24 <phz_> which is something like aeson, but for a lot of formats
17:32:32 <phz_> https://crates.io/crates/serde
17:32:38 <phz_> just, look at the dependencies.
17:32:57 <phz_> https://crates.io/crates/serde_json
17:33:08 <phz_> and the JSON version only has just a few more, like parser stuff
17:33:28 <phz_> I feel like a bit odd people don’t understand that in the Haskell world
17:33:45 <Koterpillar> raise that on the mailing lists?
17:33:52 <phz_> that pulling billions of dependencies because I just wanted to add two vectors is fucking hilarious and annoying
17:35:23 <monochrom> This is why we need robots to write our code and drive our cars (and write the code that drives our cars) so that we can focus on arguing while our cars automatically play Krachenwagen.
17:36:30 <phz_> yeah, well
17:36:42 <phz_> anyway, it’s almost 3:00 AM; off to bed
17:36:45 <phz_> see you later
17:42:43 <johnw> I wonder why "whatever the Rust community is/isn't doing" has become such a basis for argument lately
17:43:19 <monochrom> It was s/Rust/Python/ 10 years ago when dons was around.
17:43:30 <monochrom> And 5 years before that, s/Python/Perl/
17:43:40 <johnw> ah, ok
17:44:01 <monochrom> (It was how hackage was conceived!)
17:47:22 <monochrom> And we know how Perl's CPAN was inspired by TeX's CTAN.
17:47:58 <monochrom> And we in Haskell have \begin{code} \end{code} as one of the two coding syntaxes for *.lhs
17:48:30 <monochrom> The unavoidable conclusion is that Knuth is the grandpa of all of us.
17:49:11 <johnw> let's ask him about dependencies then
17:51:33 <excelsiora> hi haskell hackers
17:51:47 <monochrom> He may write about graph algorithms in volume 5
17:52:05 <dolio> I thought 4 wasn't even finished completely yet.
17:53:00 <monochrom> I know right?
17:53:19 <dolio> Wow, 7 are planned.
17:53:29 <dolio> I really don't believe it's going to get there.
18:03:56 <`Guest00000> Data.ByteString.ByteString is different from Data.ByteString.Char8.ByteString?
18:05:05 <`Guest00000> why?
18:05:06 <monochrom> No. Same.
18:05:53 <monochrom> Same type, different interfaces.
18:06:56 <`Guest00000> hm
18:07:15 <`Guest00000> hackage documentation doesn't show that they're the same type
18:07:39 <monochrom> You may be misinterpreting it.
18:07:58 <monochrom> The correct interpretation is that hackage documentation doesn't show that they are different.
18:08:03 <johnw> maybe you're seeing a difference between Lazy and Strict
18:08:26 <`Guest00000> oh well
18:34:16 <`Guest00000> why doesn't the monomorphism restriction just restrict only non-function types?
18:34:53 <`Guest00000> non-function = not in form (a -> b)
18:45:06 <johnw> why would that distinction be meaningful?
18:46:56 <`Guest00000> double computation of values is avoided, and functions aren't restricted
18:48:26 <glguy> functions are also values and double computation can happen just the same
18:53:26 <maksim__> what does ?$> mean?
18:53:59 <Axman6> no idea, where hve you seen it?
18:54:05 <Axman6> have*
18:54:13 <maksim__> https://github.com/databrary/databrary/blob/1e2a94ac93aa6548db418d9dea5edf2b088a9609/Databrary/Solr/Service.hs#L62
18:55:32 <Axman6> <$> is fmap
18:56:02 <maksim__> okay but that's not fmap is it?
18:56:14 <Axman6> yes
18:56:25 <maksim__> yes it is or yes it isn't
18:56:26 <Axman6> oh sorry
18:56:29 <Axman6> wrong pot
18:56:30 <geekosaur> https://github.com/databrary/databrary/blob/1e2a94ac93aa6548db418d9dea5edf2b088a9609/Databrary/Ops.hs#L64
18:56:32 <Axman6> spot*
18:56:48 <maksim__> geekosaur ?
18:57:01 <geekosaur> that's where it is defined
18:57:39 <maksim__> i figured it was in the codebase but i couldn't search for that string in the repo
18:57:42 <maksim__> thanks
19:05:44 <`Guest00000> is it possible to check package flag in this package's code?
19:14:15 <Zemyla> Fucking hell. Idris built, but then failed during Haddock, and if I just do "cabal install idris", it'll have to go through the whole goddamned rigamarole of building again.
19:26:46 <nshepperd> `Guest00000: monomorphism restriction does not restrict functions that are defined like 'f x = ...'
19:27:08 <nshepperd> because those won't share any values
19:27:56 <`Guest00000> what is difference between this and function defined with lambda?
19:31:26 <nitrix> Monomorphism restriction doesn't apply if the left hand side has arguments or if you explicitly give the desired type annotation to the definition.
19:31:39 <nitrix> When it doubt, always annotate your functions :)
19:34:01 <`Guest00000> nitrix: i don't want to.
19:34:44 <nshepperd> `Guest00000: f = let y = foo in (\x -> ...) shares y, but only if the function is monomorphic
19:37:42 <nshepperd> in general, 'f = someFunctionDefinedElsewhere' could do any amount of sharing. you don't know. but 'f x = ...' never shares values
20:07:50 <ludat> hi everyone, I was trying to get `stack build --pedantic` to work but I have some orphan Arby instances from quickcheck, I added the -fno-warn-orphans to ghc-options in the cabal but it doesn't seem to work
20:12:48 <sm> https://githubengineering.com/scientist needs a haskell port
20:20:03 <Cooler> does this work newtype IntString = IntString (Int, String) deriving Show
20:20:05 <Cooler> ?
20:20:32 <Cooler> typing that into REPL doesn't give any output
20:21:06 <Koterpillar> Cooler: try :t IntString
20:21:43 <Cooler> ok it works
20:22:24 <Cooler> this gives an error though
20:22:24 <Cooler> instance TooMany IntString where
20:22:25 <Cooler>     tooMany IntString (n, s) = n > length s
20:22:47 <Koterpillar> brackets
20:22:53 <Koterpillar> tooMany (IntString ...) = ...
20:23:02 <Cooler> oh
20:31:45 <Cooler> how do you specify a typeclass constraint on newtype?
20:32:23 <Cooler> newtype NumTooMany = (Num a, TooMany a) => NumTooMany (a, a)
20:34:26 <Cooler> does that even make sense
20:34:27 <Cooler> ?
20:35:02 <Cooler> trying to do this exercise
20:35:03 <Cooler> 3. Make another TooMany instance, this time for (Num a, TooMany a)
20:35:03 <Cooler> => (a, a). This can mean whatever you want, such as summing the
20:35:03 <Cooler> two numbers together.
20:35:23 <Koterpillar> you don't have to make a newtype
20:35:38 <Koterpillar> just declare another instance
20:35:50 <Cooler> This will require adding a language pragma
20:35:50 <Cooler> named FlexibleInstances4
20:35:50 <Cooler> if you do not use a newtype
20:36:45 <Cooler> Koterpillar, do i need to enable that language extension if i don't use new type?
20:39:18 <Cooler> Koterpillar, this doesn't make sense instance TooMany (Num a, TooMany a) => (a, a) where
20:40:10 <Cooler> if a already has a TooMany instance then are we overriding it?
20:41:29 <kadoban> Cooler: instance (Num a, TooMany a) => TooMany (a, a) where  -- should be it
20:42:10 <Cooler> kadoban, are we overriding the existing tooMany instance of a?
20:46:28 <Koterpillar> Cooler: it's like this: instance depenencies => my_new_instance
20:46:58 <Koterpillar> so you want: if I know that (Num a) and (TooMany a), then TooMany (a, a)
20:47:20 <kadoban> Cooler: No, we're making an instance for (a, a), when a is both a Num instance and a TooMany instance.
20:47:30 <Squarism> do you people use the debugger alot? 
20:47:39 <Squarism> GHCi debugger that is
20:47:59 <kadoban> There's a debugger? (I think I knew that, but I always just do Debug.Trace debugging really)
20:48:18 <kadoban> But I do that in all other languages as well, so that might just be me.
20:48:25 <Jeanne-Kamikaze> I usually read my core while I'm having breakfast.
20:49:00 <Squarism> kadoban, https://wiki.haskell.org/Debugging
20:49:57 <`Guest00000> if i don't care too much about which bytestrings i need, lazy or strict, which should i use?
20:50:54 <MarcelineVQ> Squarism: I've not used it much since you can often narrow down the problem by splitting something up or testing parts of it in ghci, and debugged code has to be interpreted so I can't debug the things I define while in ghci. the recent stack trace stuff is pretty great for finding a problem site though
20:52:34 <Squarism> MarcelineVQ, "recent stack trace stuff"? Whats that and in what version of GHC(?) was it added?
20:52:35 <MarcelineVQ> related https://simonmar.github.io/posts/2016-02-12-Stack-traces-in-GHCi.html  https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#stack-traces-in-ghci
20:52:50 <dfeuer> `Guest00000: that's a bit of an odd question. They're very different from each other.
20:53:04 <MarcelineVQ> I've only used it a couple times so ymmv
20:53:48 <dfeuer> `Guest00000: you need to consider what you're actually doing with them to determine which you want. If you're dealing with short little strings, almost certainly strict. Otherwise ... it depends.
20:55:27 <Squarism> MarcelineVQ, thanks!
21:03:20 <nitrix> For some reason, this is the first time I'm wondering this.
21:03:38 <nitrix> Is there a function equivalent to `fmap fmap fmap` ?
21:04:44 <Cooler> i am getting the error telling me to use Language extension FlexibleInstances when i try to make an instance like this http://lpaste.net/352584
21:04:51 <`Guest00000> dfeuer: is 512 bytes short enough?
21:05:07 <nitrix> `(<$>) <$> foo <*> bar` maybe? Is that common?
21:05:13 <MarcelineVQ> nitrix: other than (fmap . fmap) ?
21:06:00 <nitrix> Actually I think I want Compose from Data.Functor.Compose.
21:06:06 <Cooler> http://lpaste.net/352585
21:06:10 <dfeuer> `Guest00000: quite likely, for many purposes. But why are you using a ByteString if you don't know what it's for?
21:07:06 <Cooler> is there a way around that?
21:07:22 <Koterpillar> Cooler: newtype
21:07:30 <Koterpillar> or FlexibleInstances
21:07:32 <MarcelineVQ> yes, add the pragma it says, the book will also say to do that :>
21:07:41 <kadoban> Cooler: FlexibleInstances is probably the intended thing.
21:07:46 <Cooler> ok but whats the syntax for newtype with typeclass constraints?
21:08:06 <dfeuer> Cooler: what's your *code*?
21:08:09 <kadoban> Cooler: You don't put the constrains on the newtype
21:08:18 <dfeuer> What are you trying to *do*?
21:08:28 <Cooler> dfeuer, http://lpaste.net/352584
21:08:42 <dfeuer> Flexible instances is overkill here unless you're also using OverlappingInstances (which is evil).
21:08:46 <Cooler> i am trying to do this, 3. Make another TooMany instance, this time for (Num a, TooMany a)
21:08:46 <Cooler> => (a, a). This can mean whatever you want, such as summing the
21:08:46 <Cooler> two numbers together.
21:09:11 <nitrix> MarcelineVQ: files <- getCompose $ ("histdata/" ++) <$> Compose (listDirectory "histdata")
21:09:13 <kadoban> Cooler: Your line 12-15 is essentially what you'd do with a newtype
21:09:20 <nitrix> MarcelineVQ: How does that read? Too heavy probably.
21:10:07 <kadoban> Except it'd be newtype Whatever a = Whatever (a, a)    and then in the instance you need instance (Num a, TooMany a) => TooMany (Whatever a)
21:10:07 <MarcelineVQ> nitrix: It reads a little like "why are you doing this" but I've very little use of Compose so far so I'm no judge
21:10:09 <Cooler> kadoban, newtype NumTooMany = NumTooMany (a, a)
21:10:09 <Cooler>  ?
21:10:10 <dfeuer> Cooler: one option is   instance (a ~ b, Num a, TooMany a) => TooMany (a, b) where ....
21:10:19 <dfeuer> But the newtype option is better.
21:10:33 <dfeuer> For learning, anyway.
21:10:38 <dfeuer> Most of the time in practice too.
21:10:39 <nitrix> MarcelineVQ: Yeah the wrapping-unwrapping on the same line looks super dubious to me. I'll just go with (fmap . fmap), whatever.
21:10:46 <nitrix> MarcelineVQ: Thanks.
21:10:56 <MarcelineVQ> for the room's consideration, Cooler's problem is an exercise which is to be accomplished with a newtype or FlexibleInstances. "Reusing the TooMany typeclass, write an instance of the typeclass for the type (Int, String). This will require adding a language pragma named FlexibleInstances if you do not use a newtype — GHC will tell you what to do."
21:11:03 <dfeuer> What's wrong with wrapping and unwrapping on the same time?
21:11:34 <MarcelineVQ> nitrix: don't eschew the usefulness of >>= and =<< when you're dealing with that kind of line too
21:11:34 <kadoban> MarcelineVQ: I think they're on the one after that
21:11:53 <MarcelineVQ> kadoban: sure, it's still relevant though, I hope
21:12:02 <kadoban> Seems like it, ya.
21:12:47 <jarlidcup> hey there, hoping someone might be able to help me with a build problem. Glut is erroring with "ld.exe -f may not be used without -shared", any thoughts?
21:15:22 <Cooler> well this doesn't work either http://lpaste.net/352586
21:15:55 <Koterpillar> Cooler: importblogkit.com/2015/07/does-not-work/
21:17:21 <MarcelineVQ> nitrix: on further consideration =<< isn't as useful as I was thinking for that one, but I tend to use it a lot with file related stuff since everything you want to do with them is IO so some day that'll be useful :>
21:19:02 <buttons840> when parsing, does `manyTill` consume the "till" argument?
21:19:23 <MarcelineVQ> it can depend on the lib afaik
21:20:46 <buttons840> MarcelineVQ: ty, i'll have to TIAS :)
21:22:57 <MarcelineVQ> looks like it does for Megaparsec at least
21:23:50 <buttons840> it consumes for Trifecta too :(
21:24:16 <Zemyla> buttons840: Why not use lookahead to avoid consumption of the till?
21:25:50 <buttons840> parseTest (manyTill anyChar digit >> digit) "abc3" -- can i use lookAhead here?
21:26:08 <buttons840> i thought anyChar would be greedy and just consume everything?
21:37:00 <CoolerZ> what does this mean? http://lpaste.net/352587
21:37:26 <buttons840> ah, beautiful composition:  parseTest (manyTill anyChar (lookAhead digit) >> digit) "abc3"  -- this works :D
21:38:59 <buttons840> CoolerZ: can we see the full code?
21:38:59 <CoolerZ> i am getting that error with this code http://lpaste.net/352586
21:39:38 <buttons840> CoolerZ: i think you need TooMany to be a "subclass" (wrong word?) of Ord
21:39:47 <Koterpillar> CoolerZ: (>) is a method of Ord
21:39:52 <glguy> CoolerZ: If you want to use >, you'll need to add an Ord a constraint next to Num a and TooMany a
21:39:53 <MarcelineVQ> no, part of the exercise is working around that
21:39:57 <piyush-kurur> any #haskell-ops around. I would like to register the channel #haskell-raaz (as suggested by freenode folks)
21:40:02 <buttons840> basically, any type that implements TooMany needs to be an instance of Ord for (>) to work
21:41:17 <CoolerZ> does Num require Ord?
21:41:19 <CoolerZ> doesn't
21:41:25 <glguy> no
21:41:43 <buttons840> the problem is with the typeclass moreso than the instance (I would say)
21:41:53 <Koterpillar> well, you can use some other implementation
21:41:58 <MarcelineVQ> You need to figure out a way to create a (Num a, TooMany a) => TooMany (NumTooMany a) instance with only the knowlege that it has the methods of both Num and TooMany available to use
21:42:16 <buttons840> (nevermind, disregard my last chat)
21:42:52 <buttons840> :i Num
21:42:57 <buttons840> :t Num
21:42:59 <lambdabot> error:
21:42:59 <lambdabot>     • Data constructor not in scope: Num
21:42:59 <lambdabot>     • Perhaps you meant one of these:
21:43:08 <CoolerZ> MarcelineVQ, so i can't use > <?
21:43:18 <CoolerZ> does Num require == ?
21:43:21 <MarcelineVQ> Not this time unfortunately
21:43:49 <kadoban> CoolerZ: Hint: have you used the fact that 'a' is an instance of TooMany yet?
21:43:54 <MarcelineVQ> there's a very specific lesson to this particular problem that's super great to know once you get it, so don't give up
21:44:02 <CoolerZ> oh
21:44:13 <CoolerZ> right
21:45:29 <CoolerZ>     tooMany (NumTooMany (n1, n2)) = tooMany (n1 + n2)
21:46:33 <MarcelineVQ> CoolerZ: nice
21:46:49 <buttons840> what problems are these CoolerZ ?
21:47:07 <MarcelineVQ> Haskell From First Principles chapter 11 problems
21:47:15 <CoolerZ> ^
21:47:20 <kadoban> from http://haskellbook.com/
21:47:25 <MarcelineVQ> haskell programming from first principles appearantly, what a mouthful :>
21:47:43 <kadoban> hppfp is slightly shorter at least, heh.
21:48:22 <buttons840> MarcelineVQ: heh, that's not the only mouthful in the book :)  i find it quite verbose, but was worth the purchase still
21:49:19 <buttons840> hppfp = haskell++ functional programming?
21:49:27 <buttons840> j/k
22:05:20 <Cooler> why do i simply get a warning when i try to create a number thats out of the range of Int8?
22:05:59 <Cooler> http://lpaste.net/352586
22:06:21 <Cooler> isn't that an error?
22:09:01 <liste> Cooler: no, it isn't. a numeric literal can be any Integer
22:09:31 <liste> the Int8 etc types just wrap the number around
22:09:35 <liste> > 255 :: Int8
22:09:37 <lambdabot>  -1
22:09:56 <Cooler> what?
22:10:31 <liste> > (127 :: Int8) + 1
22:10:34 <lambdabot>  -128
22:10:40 <Cooler> so its cyclic?
22:10:44 <pikhq> Yes.
22:11:00 <Cooler> Int8 converts any Integer to a Int8?
22:11:28 <liste> :t fromInteger -- this function is actually called "under the hood"
22:11:30 <lambdabot> Num a => Integer -> a
22:12:38 <Cooler> liste, but that converts it to a Num a
22:13:00 <Cooler> which isn't a concrete type, so how does that work
22:13:30 <liste> Cooler: there's no type Num a
22:13:58 <Cooler> ik so how does that work
22:14:10 <Koterpillar> it can convert to anything that's a Num
22:14:11 <liste> that signature means that fromInteger can convert an Integer to *any* type `a' that has an Num instance
22:14:15 <Koterpillar> determined at the call site
22:15:51 <liste> > (fromInteger 10) :: Double
22:15:53 <lambdabot>  10.0
22:15:58 <liste> > (fromInteger 10) :: Word8
22:16:00 <lambdabot>  10
22:16:48 <CoolerX> so you have to specify instances for fromInteger for each type that instances Num?
22:17:02 <liste> yes, fromInteger is part of Num
22:17:07 <c_wraith> > 10 :: Bool
22:17:10 <lambdabot>  False
22:17:19 <CoolerX> what?
22:17:21 <c_wraith> *any* type can be made an instance of Num. :)
22:17:38 <CoolerX> Bool is a type of Num?
22:17:45 <c_wraith> If you want it to be.
22:17:53 <c_wraith> I just added that instance to lambdabot
22:17:59 <c_wraith> poorly, I might add:
22:18:01 <CoolerX> oh so its not standard
22:18:02 <liste> evil c_wraith
22:18:03 <c_wraith> > True + False
22:18:05 <lambdabot>  *Exception: Prelude.undefined
22:18:11 <c_wraith> @undefine
22:18:11 <lambdabot> Undefined.
22:18:14 <c_wraith> > True + False
22:18:16 <lambdabot>  error:
22:18:16 <lambdabot>      • No instance for (Num Bool) arising from a use of ‘+’
22:18:16 <lambdabot>      • In the expression: True + False
22:18:22 <c_wraith> That better? :)
22:20:39 <liste> + and negate would make sense for Bool though
22:20:43 <liste> and *
22:20:55 <c_wraith> You can treat Bool as a 1-bit unsigned integer type
22:21:12 <liste> then what would - and negate do?
22:21:36 <c_wraith> negate is not
22:22:07 <liste> and a - b = a + (negate b)
22:22:13 <c_wraith> yeah
22:22:23 <c_wraith> It's all perfectly lawful and consistent
22:23:00 <c_wraith> But it ends mostly ends up obfuscating code
22:36:04 <fresheyeball> foo 7 2 = [2,4,6]
22:36:27 <fresheyeball> foo 10 2 = [2,4,6,8,10]
22:36:34 <fresheyeball> foo 10 5 = [5,10]
22:36:40 <fresheyeball> what is foo?
22:36:57 <nitrix> c_wraith: I had no idea fromInteger is what was being used to convert the literal.
22:37:01 <nitrix> c_wraith: Very nice.
22:37:13 <`Guest00000> flip enumFromTo
22:37:27 <`Guest00000> stoop
22:37:50 <Axman6> > [2..7]
22:37:52 <lambdabot>  [2,3,4,5,6,7]
22:38:10 <Axman6> not quite
22:38:16 <fresheyeball> thats not it
22:38:16 <nitrix> foo x y = [x,2..y]  ?
22:38:33 <c_wraith> :t \a b -> [b, b + b .. a]
22:38:35 <lambdabot> (Num a, Enum a) => a -> a -> [a]
22:38:36 <geekosaur> > [10,9..5]
22:38:39 <lambdabot>  [10,9,8,7,6,5]
22:38:45 <Axman6> it's more like foo end x = takeWhile < end $ iterate (*x) [1..]
22:38:57 <nitrix> c_wraith has it right I think.
22:38:59 <geekosaur> ag, didn't read right
22:39:05 <fresheyeball> its going to be all multiples the second argument, from 0 upto the first arguement
22:39:32 <c_wraith> What I provided is consistent with the test points
22:39:45 <Axman6> > let foo end mul = takeWhile (< end) $ iterate (*mul) [1..] in foo 10 5
22:39:47 <c_wraith> But there are approximately infinite functions consistent with those test points. :)
22:39:49 <lambdabot>  error:
22:39:49 <lambdabot>      • Ambiguous type variable ‘t0’ arising from a use of ‘show_M284478404168...
22:39:49 <lambdabot>        prevents the constraint ‘(Show t0)’ from being solved.
22:40:23 <Axman6> > let foo end mul = takeWhile (< end) $ map (*mul) [1..] in foo 10 5
22:40:27 <lambdabot>  [5]
22:40:35 <Axman6> > let foo end mul = takeWhile (<= end) $ map (*mul) [1..] in foo 10 5
22:40:38 <lambdabot>  [5,10]
22:40:46 <Axman6> > let foo end mul = takeWhile (<= end) $ map (*mul) [1..] in foo 7 2
22:40:49 <lambdabot>  [2,4,6]
22:40:57 <Axman6> > let foo end mul = takeWhile (<= end) $ map (*mul) [1..] in foo 10 2
22:40:59 <lambdabot>  [2,4,6,8,10]
22:41:19 <geekosaur> > let foo a b = enumFromThenTo b (b+b) a in (foo 7 2,foo 10 2,foo 10 5)
22:41:21 <lambdabot>  ([2,4,6],[2,4,6,8,10],[5,10])
22:42:28 <fresheyeball> ooo
22:42:29 <lalalala> what do I use to use variables for two guards? or is it possible?
22:42:36 <lalalala> like can I use a where ?
22:43:00 <johnw> lalalala: can you give an example?
22:43:26 <lalalala> I have two guards atm, they both have two variables x0 x1, and are defined in both guards
22:44:05 <lalalala> so | guard1 = x0 x1 and | guard2 = x0 x1
22:44:18 <lalalala> can I defined a "global" variable for them both?
22:44:25 <lalalala> define*
22:44:39 <johnw> | guard1 /\ guard2 = x0 x1
22:44:42 <Axman6> you can't define variables in guards like that...
22:44:48 <Axman6> you can use where though
22:44:51 <johnw> sorry, \/
22:45:00 <Koterpillar> :t (\/)
22:45:01 <lambdabot> error:
22:45:02 <lambdabot>     • Variable not in scope: \/
22:45:02 <lambdabot>     • Perhaps you meant one of these:
22:45:08 <johnw> oops, ||
22:45:12 <lalalala> i haven't done exactly like the example, but just a example of it
22:45:12 <lalalala> so
22:45:13 <johnw> wrong language
22:45:18 <lalalala> where do I put where, at the end of both guards?
22:45:22 <Koterpillar> where's /\ \/ from?
22:45:26 <johnw> Koterpillar: Coq
22:46:19 <lalalala> can I do | guard1 = blabla; | guard2 = blabla; where blabla?
22:46:29 <nitrix> Sure
22:46:33 <lalalala> woo thx
22:46:43 <nitrix> You could easily do | guard1 || guard2 = blabla
22:46:53 <Axman6> umm, does that work?
22:47:05 <lalalala> it was a bad example, blabla means just code in general :p
22:47:05 <Axman6> does the where clause apply to both guards?
22:47:13 <lalalala> exactly what I wonder Axman6 
22:48:02 <Axman6> > let foo | x = "Yes" | x && True = "..." where x = True
22:48:05 <lambdabot>  <no location info>: error:
22:48:05 <lambdabot>      not an expression: ‘let foo | x = "Yes" | x && True = "..." where x = True’
22:48:41 <Axman6> because variables can be defined in guards using pattern guards... I think that matters?
22:48:45 <nitrix> @let foo x | x || False = 42
22:48:47 <lambdabot>  Defined.
22:48:50 <nitrix> > foo True
22:48:52 <lambdabot>  42
22:49:16 <nitrix> lalalala: The guard only needs be a boolean expression.
22:49:38 <Axman6> the discussion is about efining variables in a where clause which are used in a guard
22:49:46 <Axman6> defining*
22:50:17 <lalalala> so where worked, but I'm using an IO action, how would I do that with "<-"
22:50:53 <c_wraith> If you can use a guard, you can add a where block
22:50:57 <nitrix> Axman6: Pattern matching have isolated where clauses but not guards.
22:51:02 <Axman6> you probably can't. but MultiWayIf exists
22:51:06 <nitrix> Axman6: One can mix pattern matching and guards together.
22:51:20 <Axman6> right, I couldn't remember where that divide happened
22:51:41 <nitrix> @let bar | test = 42 | otherwise = 41 where test = True
22:51:42 <lambdabot>  Defined.
22:51:56 <nitrix> > bar
22:51:58 <lambdabot>  42
23:13:20 <ertes> with -XTypeInType in effect can i make GHC use Type and TYPE in :k output instead of "*" and "#"?
23:14:09 <glguy> i think there is a -f for that
23:14:42 <glguy> or at least for types more interesting than *
23:15:01 <MarcelineVQ> -fprint-explicit-kinds with :i  also interesting is -fprint-explicit-runtime-reps
23:16:09 <MarcelineVQ> though dunno if that'll work out of the box for what you're doing, I've barely tried TypeInType just some DataKinds
23:17:15 <ertes> doesn't seem to make a difference
23:17:49 <ertes> still prints (Int :: *), (* :: *) and (MutVar# :: * -> * -> #)
23:18:10 <ertes> in fact it prints (* :: *) regardless of whether TypeInType is in effect
23:18:15 <ertes> which seems wrong
23:20:06 <MarcelineVQ> guess we'll have to dig around :>
23:29:36 <MarcelineVQ> this documentation doesn't appear to be correct, I can't get the fprint examples aside from explicit-foralls to work in ghc 8.0.2 or 8.0.1  https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using.html#ghc-flag--fprint-explicit-foralls
23:30:58 <MarcelineVQ> actually this was discussed the other night as I recall, related trac here now it seems https://ghc.haskell.org/trac/ghc/ticket/13275
23:31:26 <MarcelineVQ> that one is runtime reps but I'm getting the same with kinds
23:35:12 <Lokathor> StateT can be a monoid only if the state is a Monoid, right?
23:35:35 <Lokathor> otherwise, there's no way to figure the mempty value
23:41:24 <cocreature> Lokathor: I’m not quite sure what a Monoid instance for StateT would look like (and I don’t think it’s particularly useful) but mempty doesn’t require you to make up a state. you need a function s -> (a, s) so you can just use the state you get passed in
23:42:40 <Lokathor> oh right
23:42:47 <Lokathor> the stateT is the func itself
23:42:50 <Lokathor> not the s passing through
23:43:04 <Lokathor> https://www.reddit.com/r/haskell/comments/5udd0m/why_isnt_statet_a_monoid/ there was just a question abotu it on the reddit
23:43:47 <Schrostfutz> Hi, I am trying to work through real-world-haskell and encounter an error in this code: http://sprunge.us/PGEZ?hs. ghc complains about words having the wrong type, String => [String] instead of [a]. I'm not sure how to interpret it, since I'd expect the expected type to be [a] => [[a]].
23:47:57 <MarcelineVQ> head words    means you're applying head to the function words, which won't be what you want. chances are you want to compose them,   head . words
23:48:41 <MarcelineVQ> mechanically it doesn't work because head expects an argument of [a] but the type of words is (String -> [String])
23:51:44 <Schrostfutz> MarcelineVQ: Ah, thanks.
23:55:16 <MarcelineVQ> ertes: These don't work on head either, it's looking like a bug
23:59:14 <Cooler> in repl how do you write multi line statements?
