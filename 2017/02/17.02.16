00:00:46 <MarcelineVQ> there's a couple ways, the best is usually to work from a source file and use :load to load it :> otherwise you can use    :{ some lines :}   or write things like foo :: [a] -> Int; foo [] = 0; foo xs = 1;
00:01:07 <MarcelineVQ> the foo thing would be all one line
00:02:08 <MarcelineVQ> you can also enable multi-line mode   :set +m    but I don't have experience with that 
00:02:49 <MarcelineVQ> type :? in ghci for some interesting things
00:02:55 <Cooler> :{ line1 :} :{line 2 :} ?
00:03:05 <MarcelineVQ> :{
00:03:06 <MarcelineVQ> line one
00:03:08 <MarcelineVQ> line two
00:03:09 <MarcelineVQ> :}
00:03:36 <Cooler> ok
00:04:06 <MarcelineVQ> I use that if I'm pasting a block of stuff into ghci but if it's larger than a block I'll use a source file, and if it's smaller I'd just use ;
00:04:30 <Cooler> do you have to indent the lines properly?
00:04:33 <MarcelineVQ> yes
01:08:12 <ezyang> Does IOError carry call stacks? 
01:08:37 <ezyang> in base-4.9, doesn't look like it 
01:19:06 <Cooler> why does take 4 ([1, 2, 3, 4] ++ undefined) not cause an exception but [1, 2, 3, 4] ++ undefined does?
01:19:41 <Cooler> doesn't it have to evaluate [1, 2, 3, 4] ++ undefined in order to apply take 4 to it?
01:19:54 <ezyang> nope, because ++ is lazy in second arg 
01:24:53 <quchen> Cooler: [1,2,3,4]++undefined does not cause an exception, printing the undefined does.
01:25:31 <quchen> When you »take 4«, you’re keeping only elements that you can print in GHCi, so undefined is never printed/evaluated.
01:25:47 <Cooler> quchen, so does ++ get evaluated?
01:25:57 <liste> > let myList = [1, 2, 3, 4] ++ undefined in ()
01:25:59 <lambdabot>  ()
01:26:10 <quchen> (++) is an ordinary function, just like »odd« or »map«.
01:26:40 <quchen> In order to print a list that is built by an expression involving (++), we have to evaluate that concatenation.
01:27:08 <Cooler> so ++ undefined doesn't cause an exception and gets evaluated
01:27:23 <Cooler> but take 4 only takes the values that are printable
01:29:58 <quchen> ?src (++)
01:29:59 <lambdabot> []     ++ ys = ys
01:29:59 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
01:29:59 <lambdabot> -- OR
01:29:59 <lambdabot> xs ++ ys = foldr (:) ys xs
01:30:13 <quchen> This evaluates only the left operand, not the right one.
01:30:27 <quchen> So in order to evaluate (++), it doesn’t matter what the RHS is.
01:34:21 <nesqi> What happend to Haskell 2014?
01:44:39 <BernhardPosselt> when i reduce a list of values using a monoid, does the order matter?
01:44:57 <BernhardPosselt> the order of the elements
01:45:28 <BernhardPosselt> e.g. Sum and [1, 2, 3] and Sum and [3, 1, 2]
01:45:49 <BernhardPosselt> my guess is that i need a commutative monoid
01:45:57 <BernhardPosselt> correct?
01:46:47 <BernhardPosselt> my usecase is safe parallel reduction
01:52:33 <quchen> Yes, the order matters.
01:52:38 <MarcelineVQ> for monoids in general the order of elements matters, the associativity of operations doesn't. you see this with list concatenation. for the order to not matter your operator needs to be commutative like Sum or Product yes. as for best practices with parallelism, that's a good question, possibly there's something relevant here for that http://chimera.labs.oreilly.com/books/1230000000929/index.html
01:53:02 <quchen> Lists are monoids, and for mappend the order of operands certainly matters.
01:53:08 <BernhardPosselt> exactly
01:53:35 <BernhardPosselt> my whole issue with the whole thing is that commutativity seems to be only defined for a binary operation
01:53:39 <quchen> ?check \xs ys -> xs <> ys == ys <> (xs :: [Int])
01:53:41 <lambdabot>  *** Failed! Falsifiable (after 4 tests and 4 shrinks):
01:53:41 <lambdabot>  [2] [3,3,-1]
01:54:11 <Cooler> can't the types of foldl and foldr be the same?
01:54:13 <BernhardPosselt> so I'm wondering if im allowed to re-order elements in a list of binary operations
01:54:25 <BernhardPosselt> e.g.
01:54:39 <BernhardPosselt> 1 + 2 + 3 + 4 = 4 + 2 + 3 + 1
01:54:50 <BernhardPosselt> where i swapped around the first and last element :D
01:55:13 <BernhardPosselt> compared to
01:55:34 <BernhardPosselt> 1 + 2 + 3 + 4 = 1 + 2 + 4 + 3
01:55:46 <BernhardPosselt> where I'm just swapping around the paramters for a binary op
01:56:13 <BernhardPosselt> usecase: i want to give a talk about monoids :D
01:56:26 <aphorisme> Hey. Had anyone a look on the lambda PI tutorial implementation paper ( https://www.andres-loeh.de/LambdaPi/LambdaPi.pdf ); I don't get how to read the typing rules for the dependently typed calculus (Figure 10), why is there still the distinction between inferable and checkable typing? : /
01:57:21 <MarcelineVQ> Cooler: they are mostly the same, except the function you pass each has swapped inputs  foldr :: (a -> b -> b) -> b -> [a] -> b   vs   foldl :: (b -> a -> b) -> b -> [a] -> b
01:57:47 <Cooler> MarcelineVQ, yeah can't that be the same too?
01:58:11 <MarcelineVQ> I'm not sure what you're asking but a -> b -> b  isn't  b -> a -> b
01:58:12 <Cooler> a -> b -> b
01:58:16 <Cooler> for both
01:58:38 <Cooler> why does foldl require b -> a -> b
02:00:19 <davidar_> BernhardPosselt: commutativity can be generalised: https://en.wikipedia.org/wiki/Symmetric_function
02:00:58 <MarcelineVQ> let me back up a sec, a -> b -> b  isn't  b -> a -> b  but it can be, if the function you pass to either of them is something like a -> a -> a for example, b is specialized to the type of a so you can get foldr :: (a -> a -> a) -> a -> [a] -> a  and  foldl :: (a -> a -> a) -> a -> [a] -> a
02:03:06 <Cooler> why is the type signature for foldl require b -> a -> b?
02:03:13 <Cooler> does*
02:03:50 <MarcelineVQ> I'm not entirely sure
02:05:03 <Cooler> also in this book it says foldl (:) [] [1..5] is ([] : 5) : 4 : 3 : 2 : 1 which is a type error
02:05:04 <MarcelineVQ> possibly owing to the nature of how its recursion is defined it made more sense to have the value you're accumulating to come first
02:05:42 <Cooler> is that correct? i would have thought ([] : 1) : 2 : 3 : 4 : 5
02:05:57 <Cooler> because foldl is left associative
02:06:34 <MarcelineVQ> which page (or specific section) is that on?
02:13:11 <MarcelineVQ> "<BernhardPosselt> so I'm wondering if im allowed to re-order elements in a list of binary operations" only if your operator is commutative.  3 - 4 - 5 /= 4 - 3 - 5
02:15:39 <MarcelineVQ> "<BernhardPosselt> my whole issue with the whole thing is that commutativity seems to be only defined for a binary operation" that's all Monoids are, an identity value and a binary operation :>
02:16:42 <opqdonut> and btw associativity is the thing that lets you write 3 - 4 - 5 instead of (3 - 4) - 5 or 3 - (4 - 5)
02:17:04 <MarcelineVQ> yes good point *an associative binary operation
02:17:06 <tsahyt> is there a data structure that maps Ord k => k to some a, and allows a lookup k' that returns the largest (k,a) pair in the map such that k' >= k?
02:17:25 <tsahyt> something smarter than just traversing a list I mean
02:17:41 <tsahyt> with largest I mean the largest k of course
02:17:47 <opqdonut> tsahyt: I think Data.Map has that
02:18:12 <tsahyt> oh indeed, the lookupGT etc functions look like one might fit
02:18:25 <tsahyt> lookupLT in particular I think
02:18:27 <MarcelineVQ> or lookupMax
02:18:56 <MarcelineVQ> if you want just the biggest :>
02:19:09 <tsahyt> isn't that findMax?
02:19:36 <MarcelineVQ> mostly, findMax is partial
02:22:22 <ayushsinha> hey!
02:22:47 <BernhardPosselt> davidar: ty!
02:22:59 <MarcelineVQ> tsahyt: I should mention it's relatively new so you may not see it, like if you're using a stack lts
02:23:15 <tsahyt> oh that's why then. I was looking at 0.5.7.1
02:35:48 <Cooler> MarcelineVQ, its on page 409 in the pdf
02:36:07 <Cooler> chapter 10 folding lists
02:43:55 <Cooler> MarcelineVQ, is that wrong? is foldl (:) [] [1..5] == ([] : 1) : 2 : 3 : 4 : 5 ?
02:44:38 <opqdonut> [] : 1 doesn't type
02:44:48 <MarcelineVQ> hmm, I'm not sure I see anything like that in the versions I have, not that my pdf search function is that great.
02:45:38 <opqdonut> but yeah, "syntactically" Cooler is right
02:45:39 <opqdonut> > foldl f z [1..5]
02:45:41 <guardianK> :]
02:45:46 <lambdabot>  f (f (f (f (f z 1) 2) 3) 4) 5
02:47:04 <Cooler> you don't see it on page 409, chapter 10 folding lists?
02:47:25 <MarcelineVQ> I don't, my 409's are in chapter 11
02:47:52 <Cooler> its under the heading Effects of left associativity
02:49:47 <MarcelineVQ> I do see an example that is close but it's also noted as a type error
02:51:13 <MarcelineVQ> and in the paragraphs before and after it is explained why it won't work, so have a read if you have that text too :>
02:51:45 <Cooler> MarcelineVQ, yeah thats the one
02:52:05 <Cooler> it is a type error, but the order is still wrong?
02:53:43 <MarcelineVQ> the order is correct
02:56:58 <MarcelineVQ> :t foldl
02:57:00 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
02:58:54 <ertes> most people seem to use 'case' with primitive IO:  case f# s0 of (# s1, x #) -> …
02:58:56 <MarcelineVQ> the function you give foldl takes types of b and a and produces b.   in foldl (:) [] [1..3]  the first b it will use is the [] we've supplied to start with
02:59:43 <MarcelineVQ> not that it 'works' because (:) isn't well-typed as-is, which is explained in that section
03:00:16 <ertes> i find that rather clunky, so i use 'let' most of the time…  since the strictness on the RealWorld state is clear, i wouldn't expect any problems (or in the worst case i'd use bang patterns)
03:00:22 <ertes> is there a reason to prefer 'case' anyway?
03:01:58 <Cooler> MarcelineVQ, yes the first b it will use is [] but the 2nd and 3rd etc are reversed
03:02:39 <Cooler> ([] : 1) : 2 : 3 : 4 : 5 instead of ([] : 5) : 4 : 3 : 2 : 1
03:02:54 <Cooler> since its foldl
03:05:28 <ertes> Cooler: i have a comprehensive tutorial on list folds, if you're interested
03:05:30 <MarcelineVQ> I doubt I'm able to explain it better than your book will, study those examples and compare them to the defintions of foldl and foldr to try and see what's happening
03:05:30 <ertes> Cooler: http://ertes.eu/tutorial/foldr.html
03:06:23 <MarcelineVQ> ertes: I thought maybe something related to unboxed tuples but the examples in the manual use it both ways. Perhaps the people writing those are just to used to core that it's case all the way down :>
03:06:24 <Cooler> nvm
03:08:03 <ertes> MarcelineVQ: yeah, core kinda toughens you against infinitely nested 'case' =)
03:08:29 <MarcelineVQ> I get identifier-fatigue with core, but what can you do really
03:10:47 <ertes> you can avoid looking at it…  that's my strategy most of the time
03:11:42 <ertes> you know all the bad stuff that happened in 2016?  me no longer being a core virgin was one of them
03:12:44 <janos__> has anyone a idea how to transform Bson types to Json?
03:12:57 <janos__> with the aeson 0.11.xx? 
03:13:00 <MarcelineVQ> I've got core tools on my list so we may be revisting this convo
03:13:16 <janos__> as the two aeson-bson libraries just support aeson < 0.9.xx
03:14:08 <ertes> janos__: there are quite a few aeson/BSON libraries on hackage
03:14:19 <ertes> janos__: search for "bson" here: https://hackage.haskell.org/packages/
03:15:03 <janos__> ertes: already searched there, they don't support the newest LTS :(
03:15:45 <MarcelineVQ> too old or too new? you can add them to extra-deps if they're too new
03:15:46 <ertes> janos__: another option is not to do it…  use a regular bson library to go from BSON to a haskell type, then use aeson to go to JSON
03:16:13 <ertes> janos__: in fact if your BSON comes from a database, you can probably let your database library do that for you
03:16:27 <janos__> ertes: yeah, but this seemed unnecessary, as I am just fetching data from mongodb and want to send it to the user as a json
03:16:47 <janos__> ertes: oh, good idea, I'll look into that
03:17:03 <ertes> janos__: it shouldn't have any significant run-time overhead, if that's your concern
03:17:26 <janos__> ertes: My concern is unnecessary typing as a programmer :)
03:19:33 <ertes> janos__: if all else fails writing a function (Bson.Value -> Aeson.Value) should be straightforward enough, if you know how to translate some of the more specialised value types of BSON to equivalent JSON
03:19:52 <ertes> for example JSON has no time type, so you'd probably render into a string
03:20:43 <ertes> in fact aeson's Value type hasn't changed at all, i think, so you can probably just copy this function from one of the libraries that don't work with the newer aeson
03:20:49 <tsahyt> which of the vectors and arrays etc has the fastest time for indexing?
03:20:55 <janos__> ertes: I see, or I update a library which exists and update it to aeson 0.11, but never done something like that before
03:21:16 <janos__> ertes: yeah, probably that is what I am doing
03:21:19 <ertes> tsahyt: they are all similar, although with boxed arrays you get one further indirection (pointer chase)
03:21:57 <ertes> janos__: oh, LTS is < 0.11?  that's ooooold
03:21:59 <tsahyt> okay, I think I'll use array then because that seems to be used the most among all the DSP libraries I've seen
03:22:17 <janos__> no no
03:22:28 <ertes> tsahyt: FWIW i'd use vector, because it's…  better…
03:22:37 <tsahyt> I do agree with that assessment
03:22:57 <ertes> tsahyt: i'd go as far as to say that you shouldn't use the array library at all
03:23:12 <tsahyt> I suppose it mostly exists for historical reasons now then?
03:23:22 <MarcelineVQ> I ran into a lot of hassle trying to use multi-dimentional vectors, array's love of Ix seemed to work out better for that but that's possible Vector inexperience
03:23:41 <tsahyt> I mean in some cases I can't really avoid it, e.g. the jack package exposes a StorableArray as the sample buffers
03:23:45 <janos__> ertes: LTS is 7.16
03:24:26 <janos__> ertes: And LTS 7.16 is using aeson-0.11.xx but the aeson-bson translate-libs just support aeson < 0.9.xx
03:25:31 <montagy> janos__: last time i use mongo and bson, i instance Val and JSON for data,it's tedious.
03:25:45 <ertes> tsahyt: in principle you could convert from StorableArray to storable Vector by using the ForeignPtr, but *of course* the array library hides it away, so you can't =)
03:26:01 <ertes> tsahyt: as if it's desparately trying to keep people from switching to vector =P
03:26:11 <janos__> montagy: yes, so what did you do to solve this :D
03:26:19 <tsahyt> I suppose it's nice to be able to index with Char for whatever reason
03:26:34 <MarcelineVQ> janos__: and some less than 0.8, gosh, that's 2 years ago :(
03:26:37 <ertes> tsahyt: MarcelineVQ's point is valid though…  if you don't feel confident reinventing Ix, array may provide some benefit…  however, audio is one-dimensional
03:26:54 <ertes> personally i'd reinvent Ix
03:27:12 <tsahyt> ertes: why not just use Ix anyhow, it's in base after all
03:27:34 <ertes> bonus: reinventing it lets you take advantage of some *major* speed benefits (avoiding multiplication)
03:27:46 <tsahyt> fair enough, that's always good
03:27:57 <montagy> janos__: some TH,just a small project,not going on.
03:28:08 <ertes> janos__: i meant LTS' aeson, not LTS itself =)
03:29:14 <janos__> ertes: I see. LTS-8 is using 1.0.2.1 - but that doesn't solve my problem
03:29:28 <ertes> i'm not familiar with the package sets that LTS exposes, except that people seem to complain a lot about outdated stuff
03:29:47 <kubbe> Hi guys! So I am trying to get a random int. But when I am using System.Random it will only return a IO Int. Is it possible to convert this IO Int into a Int in some way?
03:29:56 <janos__> ertes: Have experience with updating a library on hackage?
03:30:44 <ertes> kubbe: nope
03:30:59 <ertes> kubbe: an (IO Int) is not an integer, it's a program that returns an Int
03:31:15 <ertes> janos__: what do you mean?
03:31:32 <ertes> janos__: you mean forking it locally?
03:31:40 <janos__> ertes: I though about taking one of the outdated libraries, which transform bson -> json and update it
03:31:43 <kubbe> Okey! Is it possible to get that out of there in some way?
03:31:50 <osa1> "an exception is raised" what exception??? I hate writing Haskell sometimes
03:32:07 <janos__> ertes: well, if I fork it locally and fix it I should also publish the fixed/updated library or?
03:32:33 <MarcelineVQ> osa1: vague docs?
03:32:43 <ertes> kubbe: yes, but not by "extracting", because that doesn't really make sense…  what you do is to *compose* that program with other programs
03:32:49 <osa1> MarcelineVQ: yes, even in widely used libraries like `network` and `process`
03:32:51 <ertes> kubbe: https://www.vex.net/~trebla/haskell/IO.xhtml
03:33:28 <ertes> janos__: no, there is no obligation to publish your changes
03:33:50 <janos__> ertes: haha I know, but it would be helpful for others maybe :D
03:33:57 <ertes> janos__: also updating a library can only be done by the maintainers, so you have to contact them, ideally through a patch or pull-request
03:34:30 <ertes> if they don't respond/agree you have to fork the package
03:35:24 <MarcelineVQ> if they don't respond you can possibly contact trustees at #hackage as well and see what's up
03:36:13 <MarcelineVQ> related https://wiki.haskell.org/Taking_over_a_package  https://wiki.haskell.org/Hackage_trustees
03:37:33 <ertes> yeah, that's how i got my own packages back…  it felt weird to send a mail to my former self, waiting for myself not to answer for a couple of weeks, then letting everyone know that i'm dead =)
03:37:51 <MarcelineVQ> 'I got better'
03:44:29 <ertes> it would have been spooky if i had actually received a reponse
03:45:29 <ertes> "what the hell?  who are you?" – "i'm you two years in the future" – "yeah, right…  leave me alone, weirdo!"
04:03:49 <ertes> another question about primitives: i was wondering whether in a type like (# State# s, a #) the state part is optimised away, but experience suggests that it's not…  does anyone know the details?
04:04:42 <ertes> specifically: benchmarking reveals that using resultless primitive actions directly does give me a slight performance boost
04:04:54 <ertes> like for example writeMutVar#, which doesn't return a tuple at all
04:05:29 <ertes> this is faster than IORef with IO
04:05:47 <ertes> and it's also faster than MutVar# with separate IO actions for read and write
04:07:04 <ertes> i would guess that IO's insistence on result tuples does have a cost for resultless actions
04:15:04 <jaspervdj> ertes: If you don't have the state, you risk de-duplication of some IO actions I think
04:22:52 <ertes> jaspervdj: hmm?  i do thread the state, but *only* the state
04:23:51 <ertes> writeMutVar# :: MutVar# s a -> a -> State# s -> State# s
04:24:17 <EvanR> you want the state?
04:24:19 <ertes> IO coerces it to return an unused () as well
04:24:31 <EvanR> you can't HANDLE the state
04:24:54 <ertes> getting rid of that () and its containing unboxed tuple has given me a speed boost of around 10%
04:27:29 <ertes> in other words: i think having a Monoid-only IOEff type could provide a benefit without forcing people to go through the trouble of working with primitives
04:27:42 <ertes> newtype IOEff = IOEff { fromIOEff :: State# RealWorld -> State# RealWorld }
04:27:53 <ertes> unlike IO this is just a monoid and only allows side effects, no results
04:28:23 <ertes> i'm currently investigating whether it works with this indirection
04:33:53 <MarcelineVQ> interesting stuff
04:41:05 <`Guest00000> runPut :: Put -> ByteString
04:41:20 <`Guest00000> hackage web docs show href to Data.ByteString.Lazy
04:42:01 <`Guest00000> GHCi shows the type is Data.ByteString.Lazy.Internal.ByteString
04:42:47 <`Guest00000> and gives me type error - mismatch with Data.ByteString.ByteString
04:43:11 <janos> ertes: Thanks for information
04:43:45 <liste> `Guest00000: are you using it somewhere a strict ByteString is expected?
04:44:07 <`Guest00000> wait
04:44:42 <`Guest00000> pairs (Data.ByteString.ByteString, Data.ByteString.Char8.ByteString) and (Data.ByteString.ByteString, Data.ByteString.Lazy.ByteString) are different.......
04:45:24 <`Guest00000> was confused
04:54:41 <ertes> benchmarking IO-write: time 3.625 μs (3.624 μs .. 3.627 μs)
04:54:42 <ertes> benchmarking IOEff-write: time 3.373 μs (3.372 μs .. 3.374 μs)
04:54:52 <ertes> it's faster =)
04:55:06 <ertes> both versions traversing a vector of IORefs and writing a value to each
04:58:01 <srhb> I'm not sure I understand how criterion chooses the number of times a benchmark is ran. Can anyone explain that?
04:58:29 <merijn> I'm guessing based on the variance of the measurement results
04:59:49 <srhb> Perhaps combined with some limit...
04:59:59 <srhb> I guess I'll have to look through the source.
05:12:43 <BernhardPosselt> wow, just realized that monoids give you reduction for free
05:13:02 <cocreature> srhb: iirc it just has a max runtime and a maximum number of iterations and when one of those is reached it stops
05:15:17 <BernhardPosselt> or hows it called in haskell? foldl?
05:15:43 <cocreature> :t foldMap
05:15:46 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
05:16:05 <cocreature> BernhardPosselt: that’s a fold using monoids :)
05:16:15 <BernhardPosselt> oh, nice :)
05:16:23 <cocreature> :t mconcat
05:16:26 <lambdabot> Monoid a => [a] -> a
05:16:57 <BernhardPosselt> what does the Monad typeclass give you for free? can only think of pure and liftM
05:17:11 <BernhardPosselt> and maybe do notation
05:17:13 <cocreature> for free?
05:17:37 <BernhardPosselt> for free as in: functions that leverage the type class
05:18:09 <Axman6> mapM?
05:18:16 <cocreature> BernhardPosselt: well you can take a look at Control.Monad for some ideas
05:18:16 <BernhardPosselt> i mean: why define a monad interface if you cant use it in some functions
05:18:21 <AndreasK> everything in Control.Monad and little but more http://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Monad.html
05:18:24 <Axman6> actually, that's a bad example because Traverse exists
05:18:26 <srhb> cocreature: Hmm, it doesn't seem to be able to generate a report if I specify iterations on the command line.
05:18:27 <BernhardPosselt> i see :)
05:19:36 <Axman6> BernhardPosselt: it exists because it summerises a very common pattern (sequencing computations) for many types
05:20:07 <BernhardPosselt> right and you can make use of that pattern
05:20:53 <BernhardPosselt> to define abstractions that would otherwise result in boilerplate code
05:21:12 <Axman6> it doesn't exist just because it can, it exists because it allows us to abstract over the extra power that Monad allows us over say Functor or Applicative; there are things you can only do with the power of Monad that you cannot do with Applicatives (mainly, you can use the values returned by actions to make later decisions)
05:21:45 <Axman6> yes, you can write foldM once and it will work for all Monads you can think of, even if they were written after foldM was
05:22:17 <merijn> srhb: While you're figuring this out, could you find out how I get per-run environment setup/cleanup? :p
05:22:24 <BernhardPosselt> i think it would be very useful to add this stuff in resources that explain the abstractions
05:22:51 <Axman6> there's already far too much written about monads, they're far too simple to get as much press as they do
05:23:32 <srhb> merijn: Using env?
05:23:42 <srhb> merijn: Oh, you mean individually for each iteration?
05:23:53 <merijn> srhb: Env shares the environment across multiple runs *and* doesn't have cleanup, sadly
05:24:02 <srhb> Right, meh.
05:24:13 <Unhammer> My hoogle skills suck – is there a predefined fn that turns [Right 1, Right 2] into Right [1,2], but […,Left l,…] into Left l ?
05:24:20 <srhb> There are definitely some medium sized edge cases here that would be nice to have sorted.
05:24:28 <Axman6> BernhardPosselt: you should watch Conor McBride's talk "What are Types for, or are they only Against?" https://www.youtube.com/watch?v=3U3lV5VPmOU (and if you're new to Haskell, watch it again in a few months and more of it will make sense :P)
05:24:31 <merijn> srhb: I'm trying to benchmark, e.g. Chan operations, but using the same Chan for all results is wrong (since that means each consecutive run consumes more memory)
05:24:34 <srhb> Yeah
05:24:39 <Unhammer> (I'm guessing not since one might as well want [Left l0, Left l1, …]?)
05:24:41 <Axman6> Unhammer: sequence
05:24:44 <Unhammer> oh
05:24:46 <Unhammer> :)
05:24:48 <merijn> srhb: And without a cleanup some concurrent things can get GCed before you want too
05:24:55 <srhb> merijn: Yeah. :/
05:24:58 <Axman6> > sequence [Right 1, Right 2]
05:24:59 <BernhardPosselt> Axman6: new to haskell as in: ive been trying to learn it for 2-3 years :D
05:25:01 <lambdabot>  Right [1,2]
05:25:07 <Axman6> > sequence [Right 1, Right 2, Left "damn"]
05:25:08 <srhb> The simplicity is great, but a bit more flexibility would be nice.
05:25:09 <lambdabot>  Left "damn"
05:25:17 <Unhammer> wow, thanks Axman6 
05:25:24 <Axman6> BernhardPosselt: great, you might have a chance following along for that whole talk =)
05:25:31 <Unhammer> that's great
05:25:34 <merijn> I've looked at it a bit, I don't think it'd be too hard to implement, but I don't have time atm :\
05:25:48 <Unhammer> > sequence [Left 1, Left 2]
05:25:50 <lambdabot>  Left 1
05:25:53 <BernhardPosselt> or rather: been trying to figure out monad for 2 years
05:25:57 <Axman6> Unhammer: if you haven't seen sequence, also take a look at traverse (it's generalised mapM for anything Traversable)
05:25:58 <BernhardPosselt> ;D
05:25:59 <Unhammer> fairenough
05:25:59 <Axman6> :t traverse
05:26:01 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
05:26:19 <Unhammer> I have actually used sequence before for something similar and then forgot about it :-S
05:26:45 <Axman6> (traverse and sequence can be defined in terms of each other, but there are times when one is nicer to use than the other)
05:27:00 <Unhammer> cool
05:27:17 <Axman6> Unhammer: Programming is just neural pattern matching, need to see the patterns several times before they stick ;)
05:27:25 <Unhammer> :)
05:27:28 <srhb> merijn: There's an envWithCleanup to follow along with at least.
05:27:34 <srhb> merijn: Doing it per iteration is the real problem.
05:27:48 <Axman6> BernhardPosselt: don't try to "figure out monad", just use it and eventually all will become clear
05:28:24 <BernhardPosselt> yeah, understood it after i got Promises in JavaScript
05:28:32 <Axman6> BernhardPosselt: I personally found this quite good at distilling the essence of what it means to be a monad, at least somewhat (even if it is all in Ruby): https://codon.com/refactoring-ruby-with-monads
05:28:53 <Axman6>  BernhardPosselt: in that case you might like that article even more
05:29:40 <Axman6> no need to watch the video, it's a pretty short article
05:29:52 * Axman6 -> bed
05:30:58 <merijn> srhb: envWithCleanup was on github, but not yet on hackage when I last looked. Anyway, I'm seeing rather odd performance in measurements, which I'm guessing are caused by the Chan's size increasing into GC territory
05:33:40 <srhb> merijn: Sounds reasonable.
05:35:24 <merijn> But I won't know for sure until I rule it out, unless I can sucker someone into doing my work for me :p But right now I should probably go back to paper writing *sigh*
05:37:32 <srhb> merijn: 1.000 R²   (NaN R² .. 1.000 R²) -- hmm :-)
05:38:21 <cocreature> merijn: https://twitter.com/AcademicsSay/status/830144366333349890
05:38:29 <srhb> merijn: I don't know if I will have the time to go in-depth. I've been suckered into doing this benchmark (which is great! Wish it was every day) but it's back to the old hum-drum after this week.
05:39:20 <merijn> cocreature: :)
05:45:27 <HKei> Is the ghc:DynamicLoading module what I should use if I want to load some user code (e.g. Haskell configuration) dynamically?
05:46:29 <`Guest00000> get :: Get Double should always take 8 bytes, right?
05:47:28 <HKei> `Guest00000: What's this for? binary?
05:48:20 <`Guest00000> yes
05:50:05 <quchen> `Guest00000: Double is IEEE double precision.
05:50:07 <quchen> Whatever that means.
05:50:29 <HKei> `Guest00000: No, looking at the source binary uses Prelude.encodeFloat / Prelude.decodeFloat to write doubles
05:50:35 <quchen> Probably that Double is guaranteed to be 64-bit, but I don’t know IEEE floats very well.
05:50:36 <ertes> BernhardPosselt: understanding monads involves two things: 1. looking at a few individual examples and see that they are monads, 2. understanding what it means to *abstract* over monads
05:50:48 <HKei> and that represents floating point values as a pair (Integer,Int)
05:51:33 <ertes> BernhardPosselt: understanding the second point is perhaps the most important one…  what does it mean to look at a monad, but not knowing which particular one?
05:51:36 <HKei> so the number of bytes it uses will actually vary depending on the value
05:52:28 <HKei> `Guest00000: what exactly do you need to know this for?
05:52:41 <srhb> HKei: I've never used that personally. If you don't mind using plugins, I wrote a tiny example: https://github.com/srhb/plugins-example
05:52:57 <srhb> HKei: (it dynamically loads a static Int, so advanced!)
05:53:21 <`Guest00000> why did it need to encodeFloat
05:53:26 <`Guest00000> when it can perfectly
05:53:38 <`Guest00000> just decode double as it is
05:53:45 <`Guest00000> ok thanks
05:53:52 <ertes> BernhardPosselt: it's also the reason why monads aren't really that useful in most other languages…  either they lack a type system, or their type system lacks the necessary features to support monads
05:54:10 <HKei> `Guest00000: It needs encodeFloat because it uses decodeFloat
05:54:43 <HKei> `Guest00000: as to why it does that? *shrug* This will of course safe some memory in some instances, but I imagine the actual reason they do it like that is portability
05:55:06 <ertes> in those languages monads are just an *interface*, and a rather clunky one at that…  they do not increase your abstraction capabilities
06:00:24 <HKei> srhb: I've looked at plugins, but apparently it only works with ghc<8
06:04:23 <srhb> HKei: Oh, I was unaware of that. Guess I need to update that example.
06:07:31 <RedNifre> Hi. If I have an Either String Stuff where the String is an error message and I have another function Stuff -> Either String OtherStuff, how do I "map" that function to the first Either?
06:08:51 <HKei> first >>= f
06:09:36 <HKei> (>>=) is Monad m => m a -> (a -> m b) -> m b
06:10:04 <HKei> your m in this case would be (Either String), your a would be Stuff, and your b would be OtherStuff
06:10:42 <HKei> also, if you're doing this to carry around error messages / do early termination on errors you might be interested in ExceptT
06:11:10 <RedNifre> Thanks, I'll check it out.
06:53:17 <tsahyt> do MemoTries ever forget anything?
06:53:46 <tsahyt> i.e. can I use them in applications where many inputs may be called eventually over the lifetime of the program without memory blowing up
06:55:39 <ondraa> Hi, I am using the brick and vty libraries. Is there a way to register key press and key release? The API does not seem to provide this kind of information https://hackage.haskell.org/package/vty-5.15/docs/Graphics-Vty-Input-Events.html#t:Event but I hope there is a way around
06:56:05 <ondraa> what I want to do is measure the time the key is pressed
07:04:02 <glguy> ondr
07:04:29 <glguy> ondraa: no, vty doesn't have access to that information
07:05:58 <ondraa> glguy: i see, why not?
07:09:06 <tsahyt> are there any forgetful memoization libraries? i.e. that act like a cache
07:11:00 <Tuplanolla> Here's the long answer, ondraa: http://www.linusakesson.net/programming/tty/index.php?tty
07:11:10 <ondraa> glguy, Tuplanolla: thank you
07:14:31 <haskellnoob> test
07:14:46 <haskellnoob> is this a good place to ask basic haskell questions?
07:15:19 <haskellnoob> I have an error on a concatenate function that I tried
07:15:21 <haskellnoob> myCat :: [[a]] -> [a] myCat (xs:xss) = [x | x <- xs] : myCat xss
07:16:00 <haskellnoob> I get an error on the last bit, where supposedly xss is [a] instead of [[a]]
07:16:14 <haskellnoob> at least that's what I understood
07:16:38 <haskellnoob> is anyone here active?
07:16:51 <lassulus> yes, just wait a little bit :)
07:16:54 <glguy> your list comprehension doesn't do anything
07:17:20 <glguy> and check out the type of (:)
07:17:26 <glguy> :t (:)
07:17:28 <lambdabot> a -> [a] -> [a]
07:17:35 <haskellnoob> I'm supposed to concatenate all the elements from an array of arrays into a big array
07:18:06 <glguy> lists aren't arrays, but the append operator is ++
07:18:40 <haskellnoob> I checked the type of (:)
07:19:04 <haskellnoob> takes an element and a list... not a list and list
07:19:25 <glguy> right, that's not what you needed
07:19:59 <glguy> you had a list xs and a list myCat xss
07:20:16 <HKei> srhb: if you're still here, I managed to make a simple example work with the hint package
07:20:22 <glguy> two lists (both same type)
07:22:07 <haskellnoob> I changed it but its still not working... it loads now (unlike before) but I get a non-exhaustive patterns in function myCat
07:22:35 <haskellnoob> >>oh... I think I need to add an empty list
07:22:36 <HKei> haskellnoob: it means you're not matching some possible pattern in your function definitions
07:23:08 <haskellnoob> success
07:23:15 <haskellnoob> thank you so much
07:23:25 <haskellnoob> such a silly problem with the : vs. ++
07:23:31 <haskellnoob> but makes a big difference
07:24:16 <ertes> haskellnoob: exercise: write your own version of (++)
07:24:20 <ertes> call it 'append'
07:24:40 <ertes> just to see how (:) and (++) interact
07:24:46 <haskellnoob> I didn't realize (:) is not the same as append
07:24:59 <haskellnoob> I imagined it as "append left"
07:26:45 <ertes> haskellnoob: i invite you to do the exercise anyway
07:27:04 <Cooler> is there a function for searching if a char in present in a string?
07:27:17 <ertes> Cooler: 'find'
07:27:30 <merijn> :t elem
07:27:31 <ertes> Cooler: or 'elem'
07:27:32 <lambdabot> (Foldable t, Eq a) => a -> t a -> Bool
07:27:57 <haskellnoob> I will add it to my list
07:28:01 <ertes> > find isDigit "abc0def"
07:28:04 <lambdabot>  Just '0'
07:28:08 <haskellnoob> (pun intended)
07:28:16 <ertes> > elem 0 "abc0def"
07:28:19 <lambdabot>  error:
07:28:19 <lambdabot>      • No instance for (Num Char) arising from the literal ‘0’
07:28:19 <lambdabot>      • In the first argument of ‘elem’, namely ‘0’
07:28:29 <ertes> you get the idea
07:28:34 <HKei> > elem '0' "abc0def"
07:28:37 <lambdabot>  True
07:29:23 <ertes> i just discovered an efficient algorithm to fix my code when it's broken
07:29:32 <ertes> just dump it here
07:30:06 <merijn> ertes: :)
07:30:09 <tsahyt> stable-memo doesn't build with stackage anymore due to the ghc-prim version constraint :/
07:30:18 <tsahyt> that's a shame, it looked very good for what I need
07:30:45 <merijn> tsahyt: This is why I generally recommend using the 2nd newest version of GHC :p
07:31:18 <tsahyt> well it was last updated in 2015
07:31:23 <tsahyt> I'd have to use 7.10.3 I think
07:31:41 <merijn> tsahyt: Try fixing stable-memo and submit a patch? If it's a new GHC issue it's most likely trivial to fix (might just need different bounds)
07:31:46 <HKei> ertes: I think the formal name is the stackoverflow algorithm
07:32:12 <tsahyt> I could try that, yes
07:32:25 <tsahyt> if it's really just a version bump that is
07:32:32 <ertes> HKei: stackoverflow?  you mean that MMORPG?
07:32:54 <merijn> tsahyt: There's like a year between 0.2.4 and 0.3.0 too
07:32:57 <HKei> Exactly. Had a weird UI patch this week(?) too
07:33:09 <Cooler> does "te" pattern match with (x1:x2:xs) ?
07:33:18 <Cooler> what about "t"?
07:33:20 <haskellnoob> How do I show another piece of code that I need a bit of explaining about?
07:33:24 <ertes> Cooler: yes; no
07:33:27 <tsahyt> well it builds
07:33:35 <tsahyt> if it compiles it works.. right?
07:33:39 <merijn> tsahyt: People come here with like JS expectations of "not updated in a year == dead", it might just not have updated because it basically worked unchanged until GHC8 was released
07:33:48 <merijn> tsahyt: tbh, most likely yes if it's just a bounds issue
07:33:55 <Cooler> "t" could be 't':[]:[] ?
07:34:03 <ertes> Cooler: "t" = 't' : []
07:34:08 <haskellnoob> http://lpaste.net/352610#a352610
07:34:13 <HKei> haskellnoob: Well, for sharing small snippets github gists are pretty nice https://gist.github.com/
07:34:14 <ertes> "te" = 't' : ('e' : [])
07:34:16 <tsahyt> all it seems to need from ghc-prim is Any
07:34:29 <tsahyt> I don't think there've been many changes around that
07:34:29 <Cooler> "t" = 't':[]:[]
07:34:43 <ertes> Cooler: that's a type error
07:34:43 <Cooler> whats wrong with that
07:34:44 <tsahyt> the author is here quite often I think
07:34:55 <haskellnoob> I don't follow why in the type declaration we receive [a] first but in the function declaration we get the Int first
07:35:00 <merijn> tsahyt: Yeah, hence why I suspect it's merely "not updated", rather than broken
07:35:08 <Cooler> "t" = ('t':[]):[]
07:35:09 <ertes> Cooler: 't' : [] : [] = ['t', []]
07:35:10 <HKei> haskellnoob: yes, this definition is incorrect.
07:35:17 <HKei> that'd explain your confusion
07:35:33 <merijn> haskellnoob: Well, that would be because this example is wrong :p
07:35:33 <haskellnoob> thank you. I don't know how to load and run this one because of the ambiguity
07:35:34 <tsahyt> merijn: I just need something memoizes and doesn't kill my memory consumption
07:35:40 <ertes> Cooler: x1 : x2 : xs = x1 : (x2 : xs)
07:35:58 <merijn> tsahyt: Help make the world better and mail him a patch with updated bounds ;)
07:36:10 <tsahyt> and since this version doesn't hang on to keys, it doesn't seem to get into the way of GC. though how that works seems magical to me at the moment
07:36:14 <ertes> Cooler: ('t' : []) : []  -- this is something different…  it's well-typed, but of type [[Char]]
07:36:18 <tsahyt> merijn: I'll note it down
07:36:22 <Cooler> ertes, how does 't' : [] : [] = ['t', []] ?
07:36:28 <merijn> tsahyt: There's Weak pointers in GHC
07:36:36 <bollu> Cooler: because : is left associative
07:36:43 <bollu> right*
07:36:45 <ertes> Cooler: 't' : [] : [] = 't' : ([] : [])  -- clear so far?
07:36:46 <bollu> a:b:c = a:(b:c)
07:36:51 <Cooler> yeah
07:36:51 <merijn> tsahyt: So the answer is "builtin magic" :) https://hackage.haskell.org/package/base-4.9.1.0/docs/System-Mem-Weak.html
07:37:01 <Cooler> so 't' : []
07:37:08 <Cooler> = "t"
07:37:08 <ertes> Cooler: that's a list with head 't' and tail [] : []
07:37:17 <ertes> supposedly a two-element list
07:37:31 <ertes> but the second element is of a list type, while the first is of type Char
07:37:31 <tsahyt> I see
07:37:37 <tsahyt> well, not quite. but I kinda see an outline.
07:37:47 <ertes> that's not well-typed, because of the type of (:)
07:37:50 <ertes> :t (:)
07:37:51 <lambdabot> a -> [a] -> [a]
07:38:06 <tsahyt> merijn: btw, the memory consumption of the parsing yesterday was really just the size of its output. when using pipes for streaming IO memory usage disappeared
07:38:08 <ertes> you're trying to set 'a' to two different types
07:38:15 <merijn> tsahyt: \o/
07:38:22 <tsahyt> merijn: but in the process I managed to speed the parser up by about 4x by removing choice and <|> where possible
07:38:28 <Cooler> ertes, what where?
07:38:32 <merijn> tsahyt: Double win :)
07:38:46 <tsahyt> especially the top level choice made a huge difference. Now I use peekWord8 and a case match, because the first byte is enough to fully determine the message type
07:38:52 <Cooler> 't' : ([] : [])
07:38:58 <Cooler> = 't' : []
07:38:59 <tsahyt> which means that I'm down to about 50-60ns for a single message, which I'd say is real time compatible :)
07:39:01 <Cooler>  = "t"
07:39:01 <ertes> Cooler: 't' : ([] : [])  -- you're applying (:) to two arguments, correct?
07:39:06 <Cooler> yes
07:39:14 <ertes> and you're choosing a = Char, correct?
07:39:14 <Cooler> oh wait
07:39:22 <Cooler> i see
07:39:43 <Cooler> [] : [] = [[]] ?
07:39:48 <merijn> tsahyt: Yeah. Like I said, when you use <|> (and thus indirectly, choice) attoparsec has to keep backtrack history (since it auto backtracks), but backtracking only happens at choice points, so eliminating that allows it to skip lots of work
07:39:51 <ertes> Cooler: yes
07:40:30 <tsahyt> merijn: I still have one left because that's still simpler than peeking two bytes ahead, which is necessary in just one case.
07:40:47 <tsahyt> and another one when parsing vendor IDs, which I left in because the explicit case matching actually made that slower.
07:41:18 <ertes> Cooler: you will get a similar error why you try something like ((3 :: Integer) + (4 :: Double))
07:41:24 <ertes> :t (+)
07:41:26 <lambdabot> Num a => a -> a -> a
07:41:43 <ertes> you're trying to choose two different types for 'a' at the same time
07:56:44 <tsahyt> is there a way to express functors that aren't endofunctors on hask, but functors between subcategories of hask?
07:57:22 <merijn> You probably want like edwardk or Cale for that one :p
07:58:09 <Tuplanolla> I recall that being done, but the details elude me, tsahyt.
07:58:50 <tsahyt> having a nice abstraction for that would help with bridging that awful gap between my (semantically) continuous waveforms and DSP on discrete samples
07:59:32 <tsahyt> at least I think it would, I haven't worked out almost any of the details yet, including whether those are indeed categories. but I think they should be.
08:02:20 <Taneb> tsahyt, so, something like (f a -> f b) -> (g a -> g b)?
08:02:56 <tsahyt> yes, basically
08:04:50 <Taneb> tsahyt, do you need it generic or would a one-of special case do you?
08:05:24 <tsahyt> for special f and g I actually have that right now. I just realized that I'm really just reinventing functors in the process
08:05:46 <haskellnoob> I'm having a problem with the (/) in this code: http://lpaste.net/352612
08:05:47 <tsahyt> including the object to object mapping
08:06:28 <haskellnoob> Could not deduce (Fractional Int) arising from a use of '/'
08:07:31 <merijn> haskellnoob: / returns a fractional values, but Int's are, well, not Fractional :p
08:07:35 <tsahyt> :t (/)
08:07:37 <lambdabot> Fractional a => a -> a -> a
08:07:41 <merijn> haskellnoob: So you need to either convert the Int or use integer division
08:07:51 <merijn> :t div
08:07:53 <lambdabot> Integral a => a -> a -> a
08:07:59 <bollu> > 9 `div` 2
08:08:05 <merijn> Presumably (from the code) you want integer division, so use 'div'
08:08:06 <lambdabot>  4
08:08:20 <bollu> haskellnoob: the infix way of writing div is most common
08:08:31 <tsahyt> Taneb: do you know of any package that provides this concept in generality?
08:08:43 <Taneb> tsahyt, I don't think so
08:08:51 <merijn> tsahyt: Well, that depends on what 'f' is
08:08:57 <merijn> tsahyt: Is it a Functor? Monad?
08:09:02 <haskellnoob> that should work... how would I convert types if I had to
08:09:03 <haskellnoob> ?
08:09:05 <tsahyt> merijn: functor
08:09:22 <tsahyt> both f and g are endofunctors on hask in their own right
08:09:22 <merijn> @quote monochrom who.do.you.call
08:09:22 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
08:09:28 <merijn> haskellnoob: ^^
08:09:39 <merijn> :t fromIntegral
08:09:40 <lambdabot> (Num b, Integral a) => a -> b
08:10:10 <tsahyt> the subcategories formed by the image of f and g are isomorphic
08:10:15 <haskellnoob> I tried using fromIntegral but got confused on where to place it
08:10:16 <merijn> @tell monochrom You need to come up with a catch rhyme for realToFrac...
08:10:16 <lambdabot> Consider it noted.
08:10:19 <tsahyt> (pardon if my terminology is off somewhere)
08:10:27 <tsahyt> it's this isomorphism that I wish to express
08:10:38 <merijn> tsahyt: Honestly, my CT mumbo-jumbo is not sufficient to help you :)
08:10:52 <tsahyt> I have a feeling mine isn't even sufficient to express it
08:11:19 <chopsuey> Guys, I'm looking for more Kali Linux channels, kno of any?  
08:12:02 <haskellnoob> i < (fromInteger length xs)/2 ?
08:12:14 <merijn> fromIntegral, not fromInteger, but yes
08:12:23 <merijn> Well, needs more parenthesis
08:12:33 <haskellnoob> i < (fromIntegral (length xs))/2?
08:12:36 <merijn> > fromIntegral (length [1..10]) / 2 :: Double
08:12:39 <lambdabot>  5.0
08:12:43 <merijn> > fromIntegral (length [1..10]) / 2 :: Rational
08:12:46 <lambdabot>  5 % 1
08:13:09 <tsahyt> @hoogle (f a -> f b) -> (g a -> g b)
08:13:13 <lambdabot> Control.Lens.Iso lmap :: (a -> b) -> p b c -> p a c
08:13:13 <lambdabot> Control.Lens.Iso rmap :: (b -> c) -> p a b -> p a c
08:13:13 <lambdabot> Data.Bifunctor.Apply second :: (b -> c) -> p a b -> p a c
08:13:21 <tsahyt> not quite
08:13:39 <merijn> tsahyt: It looks like it might be related to mmorph, but not quite
08:13:42 <merijn> @hackage mmorph
08:13:42 <lambdabot> http://hackage.haskell.org/package/mmorph
08:14:40 <tsahyt> I should have learned more CT in my life
08:16:48 <tsahyt> the adjunctions package looks very interesting
08:17:31 <patientpl> hi
08:18:13 <tsahyt> although not quite what I'm looking for either I think
08:18:56 <patientpl> im looking at the haskell libraries for images here: https://wiki.haskell.org/Libraries_and_tools/GUI_libraries and there seems to be quite a few with no general concensus on what is the standard. Suppose I want to take in an image (say a jpeg), modify it pixel by pixel and then output it. What would be the ideal/standard way of doing this? What package would I want to use?
08:19:11 <patientpl> *package I want to use == library I want to use
08:22:05 <merijn> patientpl: Well, do you want to modify the image programatically or via a GUI?
08:22:16 <merijn> patientpl: Because your question and the GUI link seem unrelated?
08:26:08 <patientpl> ah
08:26:28 <patientpl> sorry i want to alter the image programatically - my mistake
08:26:58 <patientpl> any suggestions given this? ive seen some things on something called "juicy pixels" on reddit. is this any good or is there a better standard?
08:45:19 <mnoonan> tsahyt: does subhask address your case?
08:45:30 <tsahyt> I'll have to look at it to determine that
08:45:35 <tsahyt> but I just found the categories package
08:45:39 <merijn> patientpl: juicy pixels is pretty popular, yeah
08:45:41 <tsahyt> which has this http://hackage.haskell.org/package/categories-1.0/docs/Control-Categorical-Functor.html
08:45:45 <merijn> patientpl: I haven't used it, though
08:45:59 <mnoonan> see here, for example: https://www.quora.com/Why-is-functor-in-Haskell-defined-like-the-endofunctor-from-category-theory
08:46:10 <tsahyt> which I do think does actually adress it in sufficient generality
08:46:23 <mnoonan> "class Category cat => Functor cat f where fmap :: cat a b -> cat (f a) (f b)"
08:46:27 <tsahyt> modulo some maybe necessary newtype wrappers
08:48:13 <tsahyt> mnoonan: thanks! I'll look at subhask too
08:49:07 <tsahyt> is there a notion of a subcategory induced by an endofunctor?
08:49:42 <mnoonan> unfortunately I don't know much about subhask beyond "it exists" and "it matches CT more closely than the usual Haskell typeclasses" :)
08:49:44 <tsahyt> the codomain of any endofunctor on hask should be a subcategory of hask I think
08:50:05 <tsahyt> I mean it really has to, since an endofunctor is also a mapping from category to category
08:50:15 <tsahyt> otherwise the functor wouldn't be a functor
08:50:27 <mnoonan> tsahyt: well, what are the morphisms? do you take everything that was a morphism in Hask?
08:50:42 <tsahyt> yeah I guess
08:50:54 <tsahyt> anything that can still exist between objects in the codomain
08:51:23 <tsahyt> my CT knowledge is very very limited, so I might not be making much sense
09:13:58 <ertes> tsahyt: i'd prefer a functor-based definition of "subcategory" over most others
09:14:29 <ertes> most notably because it doesn't require "object equality"
09:18:39 <patientpl> silly question, but im trying to install juicypixel and having difficulties. i downloaded the source files from the website, and ran setup.hs in haskell and then tried to run ./setup but it didn't work. im a little confused on how to get the libraries to work. does anyone have any suggestions?
09:19:16 <ertes> patientpl: normally you would use a build tool like cabal-install (the 'cabal' command)
09:20:06 <ertes> patientpl: ideally you would use per-project sandboxes, too (the 'cabal sandbox' command)
09:21:39 <patientpl> ertes that was the answer, much obliged
09:23:32 <pikajude> hey all, does anyone know how to invoke haddock to combine all the haddocks for all packages in the global package DB and build an index
09:26:48 <patientpl> hi im trying to get the following to work: https://paste.ee/p/SESxG and im getting an error "not in scope". I find this a little frustrating as im getting the example from here: https://www.stackbuilders.com/tutorials/haskell/image-processing/ so I am thinking it ought to work. does anyone have any suggestions?
09:30:29 <patientpl> im thinking im not importing juicypixels but im not sure of what the command to do that is
09:35:08 <bodisiw> patientpl, i'm trying to get JuicyPixels installed too...  are you using stack?
09:36:37 <patientpl> i used cabal install JuicyPixels
09:36:56 <patientpl> its installed but i dont have a working example running yet
09:37:25 <kadoban> bodisiw: In stack you just include JuicyPixels in your build depends in the .cabal file. Or if no .cabal file applies, you use the --package JuicyPixels argument to the command.
09:37:43 <bodisiw> stack made a .cabal file in my project... i'm not clear on the relationship between the two systems right now
09:38:09 <maerwald> yeah, better just use cabal, saves you some confusion
09:39:01 <tsahyt> ertes: what do you mean with functor-based exactly?
09:39:24 <kadoban> bodisiw: There should be a build-depends section in the .cabal file. You just add it to that list
09:39:35 <bodisiw> kadoban, thanks!  i would've expected `stack install JuicyPixels` to add it to the .cabal file, but i guess that's just an extra manual step
09:39:55 <kadoban> bodisiw: Unfortunately .cabal files are hard to modify programatically apparently. Though yes that would be nice.
09:44:20 <cocreature> bodisiw: it’s the other way around. if you add it to build-depends, "stack build" will automatically install it
09:45:18 <bodisiw> wow, that is... not really intuitive
09:45:31 <bodisiw> but it does seem to be working :-) so thank you
09:47:03 <cocreature> bodisiw: one of the goals of stack is to make builds reproducible. so taking that into account it makes sense to have a config file that you can include in your package (i.e. the cabal file) and then "stack build" automatically figures out what it has to do
09:50:35 <bodisiw> cocreature, yeah, it makes sense to me... for some reason i was thinking stack would be an alternative to cabal, not a wrapper on it
09:51:08 <kadoban> bodisiw: It is separate. But dumping the .cabal files that are already standardly used would be unfortunate.
09:51:34 <t4nk639> Hello! Haskell newbie here, I am in despair! :( I tried everything, what is wrong with let funct percent aug acc _ = (+) (fromIntegral aug) $ (*) (1 + (percent / 100.0)) (fromIntegral acc) :: Double -> Int -> Int -> t -> Double
09:52:49 <ertes> tsahyt: monomorphisms give rise to a partial order on the objects of a category (w.r.t. either isomorphism or "bimonicness")…  this partial order can be interpreted as a "sub"/"super" relationship between objects
09:52:50 <byorgey> t4nk639: when you put a type annotation like that, it only applies to the stuff on the right-hand side of the =
09:53:03 <ertes> tsahyt: now apply this to a category of categories, where the morphisms are functors
09:53:14 <byorgey> t4nk639: try doing   let funct :: Double -> Int -> Int -> t -> Double; funct percent aug acc _ = ...
09:53:16 <ertes> tsahyt: then you get a very natural notion of "subcategory"
09:53:56 <ertes> tsahyt: define C ⊆ D, iff there exists a monomorphic functor from C to D
09:55:02 <cocreature> bodisiw: it is an alternative to cabal-install but not to the concept of cabal packages
09:55:40 <tsahyt> hmm that does make some sense, yes
09:56:04 <tsahyt> :r
09:56:07 <tsahyt> sorry, wrong window
09:56:31 <ertes> tsahyt: consider that in a category of sets and functions the monomorphisms are the injective functions
09:57:27 <ertes> then hopefully it makes more sense =)
09:57:36 <qmm> https://stackoverflow.com/questions/940382/haskell-difference-between-dot-and-dollar-sign#comment4307716_1290727
09:57:43 <ertes> of course this is not the true "subset" relationship, but more the "smaller than" relationship
09:57:47 <qmm> that doesn't seem to work in ghci
09:57:49 <qmm> > putStrLn . show . (+) 1 1
09:57:51 <lambdabot>  error:
09:57:51 <lambdabot>      • Could not deduce (Num (a -> a0))
09:57:51 <lambdabot>          (maybe you haven't applied a function to enough arguments?)
09:58:34 <qmm> > putStrLn . show . ((+) 1 1 :: Int)
09:58:37 <lambdabot>  error:
09:58:37 <lambdabot>      • Couldn't match expected type ‘a -> ()’ with actual type ‘Int’
09:58:37 <lambdabot>      • In the second argument of ‘(.)’, namely ‘((+) 1 1 :: Int)’
09:58:40 <t4nk639> byorgey THANK YOU SO MUCH!!!!
09:58:47 <tsahyt> ertes: I do remember something about how this can be used to reason about cardinality, relatively speaking
10:00:45 <tsahyt> okay so I do now have my notion of functor between discrete and continuous waveforms, but I think I've reached the end of what I can express here.
10:01:04 <tsahyt> the next step would have been to realize this as a family of functors, parameterized over sample rates.
10:01:52 <tsahyt> or maybe that's a bad idea anyhow
10:03:25 <tsahyt> actually this is even possible
10:05:15 <cocreature> qmm: you still need a $ before the last operand
10:05:25 <cocreature> i.e. putStrLn . show $ (+) 1 1
10:05:33 <tsahyt> or maybe not
10:05:42 <tsahyt> apparently scoped type variables and instance sigs don't work together
10:08:14 <tsahyt> wow. it did typecheck eventually. but the more I do of this the more I wonder what this all will actually buy me, other than nicer syntax
10:08:15 <glguy> tsahyt: I seem to remember that they do but you had to be careful not to shadow the variable in scope from the instance itself.
10:08:33 <glguy> (not at computer to check that)
10:16:53 <qmm> > putStrLn . show $ (+) 1 1 -- thanks cocreature 
10:16:55 <lambdabot>  <IO ()>
10:17:08 <qmm> not really sure that is anymore clear than (putStrLn . show) (1 + 1)
10:17:39 <pikajude> or putStrLn (show (1 + 1))
10:18:15 <glguy> print (1+1)
10:18:23 <pikajude> print 2
10:18:28 <glguy> print 2 :)
10:19:32 <glguy> qmm: it's OK to use ()s
10:21:52 <BernhardPosselt> regarding liftM:               liftM f m1 = do { x1 <- m1; return (f x1) }
10:21:55 <BernhardPosselt> whats the x1?
10:22:03 <BernhardPosselt> the value wrapped in the monad?
10:22:08 <bbaren> BernhardPosselt: Correct.
10:22:16 <BernhardPosselt> ty
10:22:21 <bbaren> No problem.
10:22:39 <Tuplanolla> You know `liftM = fmap`, BernhardPosselt?
10:22:54 <BernhardPosselt> thats news to me
10:23:04 <BernhardPosselt> but makes sense
10:23:45 <Tuplanolla> It's an overconstrained variant mostly kept around for historical reasons.
10:23:57 <BernhardPosselt> liftM?
10:24:04 <Tuplanolla> Yes.
10:24:24 <qmm> glguy: hah! or that :P
10:26:33 <BernhardPosselt> what about lift for maybe transformers?
10:26:35 <BernhardPosselt> ehm
10:26:38 <BernhardPosselt> monad transformers
10:26:43 <Tuplanolla> That's a different lift.
10:28:42 <BernhardPosselt> lift :: Monad m => m a -> t m a 
10:28:52 <BernhardPosselt> looks like putting a monad into a transformer
10:29:27 <BernhardPosselt> isnt this kinda like pure/return?
10:31:08 <glguy> sure, it's kind of like it
10:31:32 <glguy> a -> t m a.  compared to.  m a -> t m a
10:32:11 <dfeuer> BernhardPosselt:  sort of, in the sense that it's a fundamental way to make a value of the type "from scratch".
10:33:25 <dfeuer> You can always define   pure = lift . pure  if you like, so lift is more powerful (although that's not always a *good* way to define it!)
10:41:51 <BernhardPosselt> why is it possible to use:   return  = MaybeT . return . Just    https://en.wikibooks.org/wiki/Haskell/Monad_transformers#A_simple_monad_transformer:_MaybeT
10:41:57 <BernhardPosselt> i thought MaybeT was a type?
10:42:08 <BernhardPosselt> why is MaybeT . return legal
10:42:17 <lep-delete> :t MaybeT
10:42:18 <lambdabot> error:
10:42:18 <lambdabot>     • Data constructor not in scope: MaybeT
10:42:18 <lambdabot>     • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
10:42:23 <lep-delete> :k MaybeT
10:42:25 <lambdabot> error:
10:42:25 <lambdabot>     Not in scope: type constructor or class ‘MaybeT’
10:42:25 <lambdabot>     Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
10:44:46 <Tuplanolla> :t Identity () :: Identity () -- Does this answer your question, BernhardPosselt?
10:44:49 <lambdabot> Identity ()
10:46:20 <pikajude> BernhardPosselt: there's a data constructor and a type constructor
10:46:23 <pikajude> they're named the same thing
10:47:52 <cocreature> BernhardPosselt: a simplified version would be "data X = X" in that case X is also a type and a constructor. since these live in different namespaces it doesn’t cause problems (but can cause confusion)
10:48:04 <BernhardPosselt> i see
10:56:12 <ertes> if an IORef is used only by one thread, then non-masked modifyIORef is still all-or-nothing, right?
10:58:34 <cocreature> ertes: what do you mean by all-or-nothing?
10:58:50 <cocreature> ah nvm, I got it
10:59:41 <ertes> cocreature: specifically given async exceptions
10:59:58 <cocreature> yeah I missed the "modify" part and was wondering what a masked IORef is supposed to be
11:00:41 <cocreature> not sure in that case. it seems to boil down to the question whether writeMutVar# has that property. I would assume so but I could just as well be wrong :)
11:00:58 <Tuplanolla> Not having that property seems worrying.
11:01:37 <Tuplanolla> That would mean every interruption introduces a data corruption hazard.
11:01:42 <ertes> well, there is no atomic version of writeMutVar#, so i'm inclined to assume that it's already atomic…  of course documentation would be…  you know…  amazing =)
11:32:19 <benzrf> i'm using ihaskell-diagrams with jupyter to visualize 2d lists of numbers as bitmaps. diagrams is proooobably not ideal for the use case of a perfect grid of lots of squares, but apart from that, i'm having an issue where the results look like this once the squares get small enough: https://i.imgur.com/zytpqED.png (notice the tiny lines)
11:32:39 <benzrf> is this an inescapable consequence of something basic about diagrams, or can i fudge my way around this?
11:41:44 <ClaudiusMaximus> benzrf: i had similar issues with some plain svg (no haskell or diagrams involved), setting the stroke (diagrams 'lc') to the same colour as the fill fixed it for me there; don't know if it's the same issue you are having though
11:42:52 <benzrf> ClaudiusMaximus: oh, neat
11:43:38 <benzrf> trying that now :)
11:43:46 <benzrf> ...nope :\ thanks though
11:45:10 <benzrf> oh wait, wtf... if i put it in svg mode, theres tiny gaps when my squares are large; in png mode, there's tiny gaps when my squares are small
11:45:12 <benzrf> the hell?
11:46:02 <benzrf> ooh, maybe its because of how the scaling happens
11:46:08 <bodisiw> sounds like rounding issues
11:46:36 <benzrf> :\
11:46:41 <monochrom> Yes, I suspect rounding too
11:47:09 <benzrf> i knew i shouldve just done raster from the start
11:48:11 <monochrom> I like the gaps though.
11:51:46 <dmwit> benzrf: Fudge it. Make the envelope 99.9% the size of the actual box.
11:52:02 <monochrom> haha
11:52:17 <benzrf> :{
11:52:29 <monochrom> solving rounding error by moar rounding errors
11:52:59 <Tuplanolla> We call them confidence intervals.
11:53:16 <dmwit> Oh, well, if it's just a rounding error. I wonder how hard it would be to work with diagrams over a space that has no rounding.
11:53:22 <dmwit> Integer or Rational instead of Double, e.g.
11:53:52 <dmwit> I guess all the renderers expect Double, huh?
11:54:13 <dmwit> I have a cunning plan.
11:54:47 <Tuplanolla> I've been recently investigating index space linear algebra. It has its share of fun problems like artifacts stemming from finite-size origin.
11:56:14 <Tuplanolla> Invertibility of matrices also becomes a global property instead of a local one.
12:00:32 <Tuplanolla> So you can get lossless image operations, but it makes life harder.
12:01:49 <benzrf> i wonder how much faster this would be if i used double instead of cyclotomic :>
12:04:09 <benzrf> looks like the answer is: a lot
12:04:51 <pikajude> yes, 2 a lots please
12:05:20 <monochrom> Does it have better gaps?
12:06:53 <benzrf> no
12:06:55 <benzrf> not worse either
12:13:27 <filthyCausual> Would a type class 'RoundMap R where {roundMap : (a -> b) -> (b -> a) -> R a -> R b}' have any instances other than 'Flip Cont' (newtype Flip t a b = Flip (t b a))?
12:15:29 <monochrom> May I make Maybe an instance of it by ignoring b->a?
12:15:49 <dolio> Look up the paper, 'Bananas in Space.'
12:16:56 <dolio> Also, Endo is an example.
12:17:04 <monochrom> Yeah
12:17:16 <monochrom> newtype Endo t = Ctor (t -> t)
12:27:37 <filthyCausual> Yes it is. Hmm.
12:28:57 <filthyCausual> Whats Ctor?
12:29:18 <filthyCausual> Oh, its the data constructor, duh.
12:32:27 <Tesseract> Is there a nice react-like or elm-like gui framework for Haskell desktop programming? Something that lets me define pure functions from app state to some tree-ish of widgets, and is rendered using the native (windows/osx/linux-gtk) toolkit?
12:33:26 <filthyCausual> And you could extend that to "newtype Endo p t = Ctor p t t" "instance Profunctor p => instance RoundMap (Endo p t)" 
12:34:52 <dmwit> filthyCausual: Any functor (co- or contra-variant) can be made a RoundMap. So there's lots of instances.
12:35:12 <mofasa> The Data.Vector.Generic package says NOT to use any of its methods. But I want to create functions that works on different kind of vectors. If I use a Vector.Generic function on a Vector.Unboxed vector, is that OK?
12:36:07 <dmwit> And there should be quite a few instances that are not functors, too. e.g. you could make one for `Iso a b`.
12:36:30 <srhb> Tesseract: I think you get to pick either native or react/elm-like
12:36:50 <filthyCausual> dmwit, right. Hmm.
12:36:52 <Tesseract> srhb: why?
12:37:04 <srhb> Tesseract: Because I'm not aware of the existence of something that does both. :)
12:37:11 <Tesseract> srhb: react uses native widgets, there's no reason haskell couldn't
12:37:19 <srhb> No, there isn't.
12:37:28 <Tesseract> srhb: there isn't what
12:37:38 <srhb> There isn't a particular reason that Haskell couldn't.
12:37:38 <dmwit> There isn't a reason Haskell couldn't use native widgets.
12:38:03 <dmwit> But you originally asked an existential question, not a question about what's possible.
12:38:22 <glguy> mofasa: just keep reading the sentence after the warning about using the class methods directly
12:40:00 <Tesseract> I did; unfortunately I assumed it might spark a discussion about what's possible or desired. By the way, which react-like frameworks exist in Haskell today?
12:40:21 <Tesseract> srhb mentioned I could choose native or react-like; I'm aware of the native ones, but not the react-likes
12:40:30 <mofasa> glguy: I'm not entirely sure what a fusible wrapper is. Does it mean that Generic reroutes the function to the appropriate class, e.g. Unboxed?
12:41:11 <glguy> mofasa: you simply shouldn't use things that start with "basic"
12:42:01 <mofasa> Alright that makes sense
12:42:49 <srhb> Tesseract: Well, threepenny-gui to the extent the FRP'y-ness is similar to what people are doing with React. :)
12:44:06 <Tesseract> srhb: thanks
12:56:11 <ertes> react has nothing to do with FRP…  this is not a statement about react's quality, but about what it is
12:58:33 <ertes> also FRP has absolutely nothing to do with GUIs, and i really wish people would stop conflating the two
12:59:03 <filthyCausual> Notin to do with is a bit strong.
12:59:07 <filthyCausual> *Nothing
12:59:14 <deepfire> is there a way to constrain a type signature to GHC.TypeLits.Nats that are > 0 ?
12:59:15 <ertes> it's the truth
12:59:28 <monochrom> "From the maker of Tangible Values"... :)
12:59:54 <ertes> there is a good reason why FRP libraries don't have any GUI library dependencies
13:00:45 <mizu_no_oto_work> FRP itself is orthogonal to the problem of GUIs, but FRP can be useful for GUIs.
13:00:52 * deepfire wonders if his question makes sense..
13:01:33 <filthyCausual> Yes, but GUI's are an example of the kind of thing that FRP is useful for. 
13:01:37 <ertes> neither will you find a GUI library with FRP dependencies…  but you will find driver libraries that depend on both
13:02:06 <monochrom> deepfire: CmpNat may or may not help you.
13:02:27 <deepfire> monochrom, thank you, looking into it!
13:03:25 <filthyCausual> ertes: But why not use FRP to implement/organize more complicated GUI elements?
13:03:31 * monochrom scrolls down further and sees "User-defined type errors" :S
13:04:37 <ertes> filthyCausual: that's not what i said
13:05:11 <ertes> i said FRP and GUIs are unrelated and shouldn't be conflated, much like concurrency and HTTP servers should not be conflated
13:06:29 <filthyCausual> But HTTP servers and concurrency aren't /unrelated/. I mean I guess you just have a much narrower meaning of /related/ then I do?
13:06:54 * deepfire sees https://www.reddit.com/r/haskell/comments/40j8zf/is_the_ghctypelits_api_unfinished/cyvatb0/
13:07:05 <ertes> i just want people to stop assuming that FRP is a "GUI thing"
13:07:24 <deepfire> i.e. the non-inductive Nat type is said to be useless : -/
13:07:43 <filthyCausual> Fair.
13:08:06 <deepfire> so pretty, so useless.. : -/
13:08:24 <ertes> much like people shouldn't assume that concurrency is a "server thing"…  in fact i really really want it to be a GUI thing as well =)
13:08:25 <monochrom> I find it useful.
13:09:15 <monochrom> But I don't do type-level arithmetic.
13:09:28 <filthyCausual> What do you do with them then?
13:10:12 <deepfire> it is useful for the case when you want to make the type-level-0 case special -- it works for that, because the type _equality_ can be established
13:10:31 <mizu_no_oto_work> ertes: it's probably simpler to say that "FRP has to do with GUIs in the same sense that knives have to do with steak"
13:10:41 <monochrom> I have used the Symbol side to say that a table is guaranteed to have a column called "foo", for example. It works fine.
13:10:56 <ertes> mizu_no_oto_work: fair enough
13:11:36 <mizu_no_oto_work> Get's across that they're orthogonal, that other solutions exist, and it's not only useful for that.
13:11:48 <deepfire> monochrom, have you ever succeeded to use the type-level literals for inequalities?
13:11:58 <monochrom> I haven't tried.
13:12:06 <monochrom> But I don't do type-level arithmetic.
13:12:23 <monochrom> I simply disbelieve in type-level arithmetic gymnastics in Haskell.
13:12:37 <filthyCausual> Well it was the type-level nats under discusion.
13:13:17 <deepfire> the inductive Nat = Z | S Nat definition allows you to at least discharge inequality with zero
13:13:45 <monochrom> Not entirely. Symbols is in GHC.TypeLits too.
13:14:51 <deepfire> ok, I admit I have overstated the "useless" part
13:15:12 <monochrom> They will add more stuff for the number side.
13:15:30 <deepfire> the inability to have the nice things here and now made me momentarily bitter : -)
13:17:04 <Younder> Yes we had all better cool it
13:17:17 <monochrom> Onoes, telescopes, astronomy, computers, computer science, knives, steaks, knife science...
13:17:59 <Younder> I love the little colloquium we have here, lets not make it sour.
13:18:10 <deepfire> CmpNat n 0 ~ GT!
13:18:24 <deepfire> as per: https://www.reddit.com/r/haskell/comments/40j8zf/is_the_ghctypelits_api_unfinished/cyv1i4g/
13:18:24 <monochrom> That may work
13:18:38 <jle`> type level arithmetic in ghc is a bit weird
13:18:52 <Younder> yes it is
13:18:52 <jle`> it's all kind of arbitrary using ad-hoc type families like CmpNat
13:19:09 <jle`> i mean, using the Nat type in TypeLits
13:19:31 <monochrom> I heard that they're adding type-level lcm and gcd.
13:19:40 <Younder> It's not exactly topology no
13:20:04 <monochrom> We may actually be able to implement the general number field sieve at the type level.
13:21:33 <Younder> jle`, has a point why does topology pay such a little part in the type layout
13:21:53 * monochrom is tempted to rekindle the debate in the new guise of "what does topology have to do with arithmetic?"
13:23:06 <filthyCausual> How would topology be useful here?
13:23:24 <Younder> I would just mention  Mc Clanies excellent book on Algebra
13:23:39 <ertes> topology has absolutely nothing to do with…  oh wait…
13:23:55 <monochrom> ertes, I got there first :)
13:24:08 <lep-delete> :t sequenceA
13:24:10 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
13:25:20 <ertes> the relationship conjecture:  there exists no topic that is in no way related to topology =)
13:25:40 <filthyCausual> I would belive it.
13:25:51 <monochrom> I also got that one first in my http://www.vex.net/~trebla/humour/tautologies.html #0
13:25:57 <cocreature> as long as you can fit donuts in your topic you can also fit in topology
13:26:09 <Younder> wery true. All objects are bound by relations.
13:27:02 <monochrom> topology and knife science are related because they are both human inventions.
13:27:29 <Younder> And the basis for topologi, well it is just that all objects worth relating to mus have some connection. Wich is true of pretty much everyhing we study.
13:27:33 <filthyCausual> " Every finite number can be rounded to 0 with enough rounding." Heck you can extend that to transfinite cardinalities and ordinals too.
13:27:52 <cocreature> monochrom: but are you sure mathematics has been invented and not discovered?
13:28:03 <monochrom> transfinite is too hard
13:28:27 <ertes> "I use base 10."
13:28:27 <ertes> haha
13:28:29 <monochrom> Yes I am trying to fuel an orthogonal debate!
13:28:38 <Younder> I am pretty sure mathematics and in particular numers are a prduct of the brain.
13:30:23 <Younder> And relish in it, it is beautiful. Our math we created it. It is perhaps in some part of all primates.
13:30:39 <filthyCausual> "transfinite is too hard" Hmm? You just aren't useing enough rounding.
13:30:58 <monochrom> Oh! I see how now.
13:30:59 <MarcelineVQ> Younder: you'd be surprised about what the birds are up to
13:32:14 <dolio> Is "round" one of the classifications of large cardinals?
13:32:36 <filthyCausual> Not that I know of..
13:33:09 <monochrom> No. It's just "round 3023 to the nearest million --- answer: 0"
13:33:34 <Younder> In particular chimpanzees have been shown to know the concept of numbers and arithmetic. Have you seen that National Geographic special 'Smarter than an ape'?
13:33:58 <monochrom> I think fish can solve differential equations.
13:34:08 <Younder> +get off it
13:34:13 <geekosaur> it goes even beyond birds. math comes out of spatial skills that go quite deep
13:35:28 <Younder> Numbers is a concept of the mind. Period. There are no numbers in nature. They are simply useful.
13:35:54 <Younder> Have you ever seen a number?
13:36:10 <monochrom> Curry da Lamb figured out lambda calculus before Church did.
13:36:36 <Younder> No, You have seen a symbolic representation of one.
13:36:37 <monochrom> Or is it Lamb da Curry?
13:36:43 * Clint coughs.
13:36:47 <ertes> if we continue discussing whether numbers are physically real, the IRC logs of #haskell will form a black hole…  that kinda makes them physically real
13:36:51 <geekosaur> numbers /per se/. "more"/"less" very much does occur
13:36:52 <Younder> cut it monochrom 
13:37:13 <monochrom> Why?
13:37:33 <Younder> Numbers are real in the mind, they lack any physical existence
13:39:41 <srk> what would you use for managing remote workers? e.g. master server dispatching tasks to number of slaves each having its own pool of workers
13:40:47 * deepfire has another GUI-related, yet hopefully usefully generic question in the queue
13:40:52 <ertes> Younder: what does it mean for numbers to exist physically?
13:41:12 <deepfire> ;et
13:41:31 <deepfire> let's postulate solipsism, and everything falls out
13:41:42 <dolio> If you want to discuss physical existence of numbers, you should do it elsewhere.
13:41:46 <ertes> srk: there is distributed-process a.k.a. cloud haskell, but i'd probably just use a simple network API solution
13:42:16 <srk> ertes: yes, I'm pretty much at the same point. can't decide.. :D
13:42:55 <Younder> ertes, Have you, again, ever seen a number. We created numbers to divide things. Like a chimpanzee seeing a orange tree and saying that has enough oranges for 10 of us.
13:43:18 <dolio> That goes for everyone.
13:43:23 <Younder> And all great apes can do this
13:43:40 <deepfire> Younder, there must be channels that are more.. fitting for this kind of philosophy?
13:44:57 <Younder> yes, you are probably right. I will desist from any furter discussion on this topic
13:45:01 <ertes> srk: if you use distributed-process, communication between processes will feel like RPC, while if you use, say, an HTTP API, it will feel more like messaging
13:45:24 <srk> ertes: I want to be able to stream task output
13:46:51 <srk> with distributed-process it would be nice if there was ssh backend but I don't feel like implementing that now
13:49:21 <Younder> In this century we will see beautiful things. A relation between the mind and computation a marriage most intriguing. I am fascinated to be a part of the dawn of machine intelligence. 
13:49:44 <ertes> srk: here is another option, but i haven't used it myself yet: https://hackage.haskell.org/package/cacophony
13:50:01 <haskellnoob> Hello. I could use a bit of help understanding what is wrong with the following code... http://lpaste.net/352623
13:50:36 <ertes> srk: if i ever need a custom crypto protocol again, i will most likely try cacophony
13:51:14 <Koterpillar> haskellnoob: give your function a type
13:51:29 <haskellnoob> how do I do that?
13:51:43 <Younder> But the zeros and ones of a machine are still just semi equilibrate states of atoms. They are not numbers
13:52:06 <ertes> srk: one important detail though: it uses cryptonite which gets all its random numbers from RDRAND, ignoring your system RNG
13:52:10 <geekosaur> haskellnoob, that's the monomorphism restriction in action. it needs to assign a concrete type, but it can't because there is no way to pick a Foldable instance
13:52:24 <Koterpillar> haskellnoob: lengthFoldr :: [somethingsomething]
13:52:40 <srk> ertes: oO
13:52:50 <haskellnoob> I think I got it... trying
13:52:53 <geekosaur> if you give it a type signature that either specifies a Foldable or explicitly specifies any Foldable, it will be accepted
13:53:36 <srk> ertes: think I don't really need encrypted proto. just serializing command and command output should be enough
13:53:46 <geekosaur> alternately eta expand it (that is, don't let it pick up the Foldable implicitly but make it an explicit parameter) which will disable the monomorphism restriction
13:54:51 <haskellnoob> to be honest, I don't feel like I fully understood your explanation
13:54:57 <haskellnoob> I tried the following and it failed:
13:54:57 <haskellnoob> lengthFolder :: [a] -> a
13:55:18 <monochrom> @type foldr (\_ n -> 1+n) 0
13:55:20 <lambdabot> (Foldable t, Num a1) => t a -> a1
13:55:26 <monochrom> Use that type.
13:55:51 <monochrom> Or make it Num a1 => [a] -> a1
13:55:58 <Koterpillar> haskellnoob: your definition says that, for example, if I apply the function to a list of Bool, I'll get a Bool back.
13:56:38 <monochrom> You may have to read up on the monomorphism restriction one day
13:56:44 <Koterpillar> haskellnoob: also, you misspelled the name
13:59:48 <Younder> Cant you just send a no-monomorphism-restriction to the compiler? In this case it is not a good idea
14:00:26 <monochrom> Yes. But the more interesting question is always "what does it mean".
14:00:41 <geekosaur> haskellnoob, the trick there is that there are two constraints that need to be solved, but only the Foldable one can't be solved by the compiler. The Num one can be, but if you specify a type you must solve it yourself or explicitly cite the Num constraint --- just "a" is not good enough, it claims no Num constraint, but (+) requires that constraint
14:01:18 <monochrom> Also the mention of "1".
14:01:30 <geekosaur> true, but trickier
14:01:53 <geekosaur> I suspect this is confusing enough as it is, without dragging in how the compiler treats numeric literals :)
14:02:02 <haskellnoob> lambdabot, monochrom, Koterpillar: thanks a lot!!
14:02:49 <haskellnoob> I might not have it fully figured out, but I certainly feel I understand a bit more and the function works... now I'll try to fix the other one that wasn't working and see if I can solve things myself
14:05:14 <haskellnoob> yup... fixed the other one myself
14:05:30 <mnislaih> question about lenses and #haskell-lens is pretty quiet, so I thought I would as here. Given a Foldable Foo type, a lens from (Foo a) to a, and f :: [a] -> IO [Double], how do I write [Foo Int] -> IO [Foo Double] ?
14:07:06 <Younder> In know some of the deeper details of haskell have always confused me. And infuriated me. I am an empiric. I am a hacker. I need to know he basic components of which all is consequted
14:09:14 <Younder> Until I du I will always be a habitual twiddler speaking inconsequential riddles of philosophy and generally being a pain in the ass.
14:10:19 <Younder> I du = then
14:12:22 <Younder> But my guess I am to lazy to get there'
14:15:54 <ertes> mnislaih: depends on what semantics you want
14:16:13 <Younder> so here is to you local hemorrhoid
14:16:47 <mnislaih> ertes: I want to replace the contents of each Foo with the results of calling f (I forgot to say that f does preserve the number of elements)
14:17:11 <mnislaih> and also that Foo is not only Foldable but also Traversable
14:17:32 <mnislaih> i.e. the trick of shape + contents can be applied
14:18:00 <ertes> @let data Foo a; fooElem :: Lens (Foo a) (Foo b) a b; fooElem = undefined
14:18:02 <lambdabot>  Defined.
14:18:07 <ertes> :t traverse . fooElem
14:18:09 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t (Foo a) -> f (t (Foo b))
14:18:40 <ertes> mnislaih: that's a:  Traversal [Foo a] [Foo b] a b
14:19:04 <mnislaih> @let f :: [a] -> [b] ; f = undefined
14:19:06 <lambdabot>  Defined.
14:19:24 <ertes> rename it…  f is overloaded
14:19:32 <mnislaih> @let Foo_f :: [a] -> [b] ; f = undefined
14:19:32 <lambdabot>  Parse failed: Left-hand side of type signature is not a variable: Foo_f
14:19:40 <mnislaih> @let foo_f :: [a] -> [b] ; foo_f = undefined
14:19:41 <lambdabot>  Defined.
14:20:18 <mnislaih> ertes: I think I need a Lens [Foo a] [Foo b] [a] [b]
14:20:31 <mnislaih> if I had an Iso (Foo a) (Foo b) a b I could lift it
14:20:44 <mnislaih> (using mapped)
14:21:40 <mnislaih> Lens is not strong enough for mapped, but given that Foo is Traversable we know it is possible to extract all the contents for all the Foo's, feed them all to f, and then insert them back in the right positions
14:23:20 <jle`> mnislaih: it's not super clear how you'd want it to behave
14:23:26 <jle`> can you write it manually without lens?
14:23:31 <jle`> and then we can see how you would lensifyit
14:23:52 <jle`> s/it/ it
14:24:15 <dmwit> I suspect the lens-ification will have two steps: one to build the `[Int]`, and one to shove zip the `[Double]` with the original `[Foo Int]`.
14:25:30 <mnislaih> traverse ((`runState`) (\_ -> get >>= \(x:xx) -> put xx >> return x)) . foo_f . foldMap toList
14:25:45 <mnislaih> more or less...
14:26:42 <mnislaih> fmap(traverse (runState (\_ -> get >>= \(x:xx) -> put xx >> return x))) . foo_f . foldMap toList
14:26:43 <monochrom> @type sequenceA
14:26:46 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
14:26:56 <jle`> did you try your best to obfuscate that heh
14:27:18 <ertes> mnislaih: does your 'f' need to be a list function?
14:27:39 <mnislaih> jle' sorry :S
14:27:56 <mnislaih> ertes: f is a given, a library function I don't control
14:27:56 <jle`> :t runState (\_ -> get >>= \(x:xx) -> put xx >> return x))
14:27:57 <lambdabot> error: parse error on input ‘)’
14:28:02 <ertes> honestly i think that's not even that obfuscated =)
14:28:09 <jle`> :t runState (\_ -> get >>= \(x:xx) -> put xx >> return x)
14:28:12 <lambdabot> error:
14:28:12 <lambdabot>     • Couldn't match expected type ‘StateT s Identity a’
14:28:12 <lambdabot>                   with actual type ‘t0 -> m0 b0’
14:28:54 <mnislaih> fmap(runState . traverse (get >>= \(x:xx) -> put xx >> return x)) . foo_f . foldMap toList
14:28:57 <jle`> what's (\_ -> get >>= \(x:xx) -> put xx >> return x)) supposed to do?
14:29:05 <mnislaih> :t runState . traverse (get >>= \(x:xx) -> put xx >> return x)
14:29:06 <lambdabot> (MonadState [StateT s Identity b] ((->) a), Traversable t) => t a -> s -> (t b, s)
14:29:25 <mnislaih> not quite what I wanted, but closer
14:29:31 <jle`> what did you want?
14:29:43 <jle`> it looks like you might not have a lens problemm, but an algorithm problem
14:29:45 <mnislaih> I just want to traverse the Foo, replacing its contents with the state
14:30:32 <jle`> ertes: are you really going to tell me that you can read that and know what's supposed to be happening, heh
14:30:52 <jle`> ertes: or are you comparing it to "actual" obfuscated haskell code :p
14:31:36 <ertes> jle`: if you add layout to it, it's quite readable
14:31:55 <ertes> it's just the nature of one-liners in IRC without syntax highlighting =)
14:32:33 <jle`> i've been staring at it for a while now
14:33:32 <mnislaih> Jeremy Gibbons explained it very clearly in the essence of the Iterator pattern, but I'm afraid I'm no JG
14:34:11 <mnislaih> let me produce a better one liner
14:34:14 <jle`> i can anticipate that one problem with f :: [a] -> IO [Double] is that this doesn't necessarily preserve the length of the list
14:34:26 <jle`> so you can't really pair up each original Foo with a resulting Double
14:34:29 <jle`> which is what i...think you want to do?
14:34:36 <jle`> maybe...?
14:35:34 <mnislaih> Well, that is true in general, but in this case we have the certainty that it does preserve the length and ordering
14:35:53 <jle`> sure, but lens library can't take this guaruntee into account
14:36:04 <jle`> so i don't think there's any nice way to do this
14:36:56 <mnislaih> https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf page 12
14:37:08 <mnislaih> fair enough
14:37:33 <monochrom> I like Jeremy Gibbons
14:37:37 <jle`> if your f was :: a -> IO Double, then i think it's pretty straightforward
14:37:47 <jle`> but the fact that f :: [a] -> IO [Double] sort of breaks the system here
14:38:32 <jle`> mnislaih: but, i can't be sure
14:38:45 <jle`> if you give me a version of your implementation that typechecks, then i can know for sure
14:39:09 <jle`> the last one you gave doesn't quite typecheck either
14:39:12 <mnislaih> Turns out there is a lens idiom for this after all
14:39:14 <mnislaih> :t partsOf (traverse . fooElem)
14:39:16 <lambdabot> (Traversable t, Functor f) => LensLike f (t (Foo b)) (t (Foo b)) [b] [b]
14:39:33 <mnislaih> provided by glguy in haskell-lens
14:40:19 <mnislaih> partsOf might not be polymorphic enough, bun unsafePartsOf is
14:40:26 <mnislaih> :t unsafePartsOf (traverse . fooElem)
14:40:29 <lambdabot> (Traversable t, Functor f) => LensLike f (t (Foo a)) (t (Foo b)) [a] [b]
14:40:34 <mnislaih> it's unsafe, but that's reasonable
14:41:05 <jle`> nice :)
14:41:14 <glguy> It's not unsafe, it just can introduce errors if you don't maintain the list length
14:43:16 <patientpl> hi
14:43:18 <patientpl>     largestDivisible :: (Integral a) => a  
14:43:18 <patientpl>     largestDivisible = head (filter p [100000,99999..])  
14:43:18 <patientpl>         where p x = x `mod` 3829 == 0  
14:43:29 <patientpl> is from the learnyouahaskell bookk
14:43:32 <patientpl> *book
14:44:08 <jle`> neat!
14:44:22 <patientpl> i dont understand how the third line works. specifically, it seems to say 'the p function taking x returns true if x mod 3829 = 0'
14:44:24 <patientpl> however
14:44:40 <patientpl> then largestDivisible = head(True)
14:45:06 <glguy> Why?
14:45:07 <jle`> 'filter' doesn't actually give you the result of p
14:45:08 <kgadek> the function `filter`
14:45:13 <kgadek> is not the same as `map`
14:45:15 <jle`> it gives you the first item in the list that matches the predicate
14:45:24 <kgadek> i.e. it doesn't replace the value with whatever `p` returns
14:45:32 <jle`> > filter (\x -> x > 10) [1..12]
14:45:35 <lambdabot>  [11,12]
14:45:39 <kgadek> but preserves the value on the list iff the `p` for that value returns True
14:45:47 <jle`> er, filter gives you all of the values in the list that match the predicate
14:45:52 <jle`> it doesn't put in the result of the predicate
14:46:01 <jle`> > map (\x -> x > 10) [1..12]
14:46:03 <lambdabot>  [False,False,False,False,False,False,False,False,False,False,True,True]
14:46:07 <jle`> compare to map
14:47:00 <patientpl> ok so p x just returns true for p and filter is then evaluated filter p [x...]
14:47:02 <patientpl> right?
14:47:16 <monochrom> I don't understand that sentence.
14:47:16 <patientpl> *filter True [some x ...]
14:47:23 <monochrom> No.
14:47:49 <patientpl> then i still dont understand
14:48:06 <monochrom> I disbelieve in measuring understanding by writing an essay.
14:48:18 <patientpl> ignore monochrom
14:48:37 <monochrom> Instead, I would measure by having you predict the answer to: filter even [1,2,3,4,5,6,7,8]
14:49:28 <jle`> patientpl: do you undersatnd filter even [1,2,3,4,5,6,7,8]
14:49:29 <patientpl> so is p x = x 'mod' 3829 == 0 returning true to the p value of filter p [100000.....] for some p and some x in [1000000.....]?
14:49:37 <patientpl> yes jle'
14:49:49 <jle`> p is not a value
14:49:50 <monochrom> You have seen jle`'s example of filter (\x -> x > 10) [1..12], so you have something to extrapolate over.
14:49:51 <jle`> it's a function
14:50:01 <glguy> <_<
14:50:15 <patientpl> ah
14:50:16 <kgadek> patientpl: maybe try this one — `filter` is a function that takes a "predicate" and a list. Then, it goes over the list. For each element `x` it fires up `p x`. If `p x` returns True, then this element will be "preserved". Otherwise, it will be dropped from the list
14:51:06 <kgadek> (actually we're creating new list — that's why "preserved" is in quotes. But to understand the `filter`, feel free to <--- ignore this adnotation :) )
14:51:38 <patientpl> ok i think ive got it
14:51:41 <patientpl> thanks for the help
14:51:54 <jle`> no problem
14:52:07 <jle`> well, functions in haskell are values
14:52:11 <jle`> but you get what i mean
14:52:20 <kgadek> patientpl: do you have experience with other languages?
14:52:26 <patientpl> a bit
14:52:41 <kgadek> which one is you fav?
14:52:50 <patientpl> i can write small programs in rust and python
14:52:52 <kgadek> asking since maybe it's easier to explain by translating to your language
14:52:55 <kgadek> ok, then
14:53:11 <kgadek> `filter` is the same for python
14:53:12 <monochrom> python has something equivalent to filter.
14:53:29 <Rembane> List comprehensions! \o/
14:53:35 <kgadek> python has `filter(function, iterable)`
14:53:50 <kgadek> predicate is "function"
14:53:57 <kgadek> list is "iterable"
14:54:17 <wizard1337> is there a list somewhere of significant commercial software making use of haskell
14:54:47 <wizard1337> and "oh NASA uses it" isn't specific enough
14:55:20 <jle`> there's this maybe? https://wiki.haskell.org/Haskell_in_industry
14:55:31 <jle`> not sure how up to date it is
14:55:46 <jle`> but it includes the big names that i can think of off the top of my head (facebook, microsoft)
14:56:14 <wizard1337> i saw a post once where someone systematically reviewed all of the "alleged uses" of haskell in industry
14:56:27 <kgadek> well, history of page mentions some rare updates but latest from this month
14:56:52 <ezyang> Target uses Haskell! 
14:57:04 <jle`> oh yes target is not on that list, better update it
14:57:05 <kgadek> wizard1337: oh? and what was the conclusion? sounds like "no-one actually really using haskell"
14:57:06 <wizard1337> and except for a handful of cases of sponsorship by big companies (e.g. facebook)
14:57:14 <ezyang> is Takt on the list? 
14:57:21 <wizard1337> this quite detailed, seemingly intelligently written post claimed that
14:57:37 <kgadek> hmm
14:57:39 <kgadek> link maybe?
14:57:39 <jle`> imvu is on there, which would be another big one
14:57:40 <wizard1337> nearly all the cases of use in industry were temporary and migrated to other languages
14:58:02 <wizard1337> and were sort of supported by individuals or small groups who were forcefully advocating
14:58:10 <Axman6> the systems I write at work aren't likely to be rewritten :\
14:58:12 <wizard1337> but then these individuals would move on and the projects would be migrated
14:58:24 <glguy> Well, given that you haven't shared the actual post there's not much point to discussing it yet
14:58:30 <wizard1337> yeah i can try to find it
14:58:35 <wizard1337> it was either on reddit or quora
14:59:00 <kgadek> wizard1337: well yeah, this makes sense. If the system is written in language that noone [available] knows, then it becomes a target of rewrite
14:59:02 <Axman6> also, Facebook's use of Haskell is for a core part of their infrastructure, basically everything posted to Facebook goes through Sigma, and it was the rewrite from another language
14:59:23 <Axman6> it's handling something 2 million requests a second
14:59:26 <kgadek> yep, FB is exceptional in this one
14:59:38 <wizard1337> facebook also has unlimited $
14:59:39 <jle`> Axman6: yes, facebook is automatically disqualified arbitrarily as an example
14:59:43 <kgadek> and they have one of the mighty Simons
15:00:04 <jle`> "here is a counter-example" "oh that one doesn't count because it's on my list of counter-examples that don't count"
15:00:05 <jle`> :)
15:00:09 <Axman6> are banks also excluded because they use Haskell to make money?
15:00:24 <kgadek> Axman6: thinking of Standard Chart. I suppose?
15:00:43 <kgadek> they have strong, core Haskell team indeed
15:00:43 <Axman6> and Barclay's
15:00:54 <jle`> you can make any argument strong by specifically disallowing discussions of counter-examples :)
15:01:08 <Axman6> C++ isnt very popular
15:01:19 <kgadek> IOHK is not on the list
15:01:28 <Axman6> because Apple and Microsoft use it for their core business, we'll exclude them
15:01:50 <jle`> er i mean, disallowing counter-examples in an arbitrary and ad-hoc way
15:01:57 <ezyang> TBF, life is not very good at Standard Chartered right now 
15:02:08 <Axman6> yeah?
15:02:08 <monochrom> Simon Peyton Jones helped investment firms use Haskell to write financial contracts. Presumably those contracts are the "bundled debt over bundled debt over bundled debt" kind, the ones that are actually mind-boggling enough to need a formal language at all.
15:02:12 <kgadek> ezyang: oh?
15:02:30 <monochrom> The conclusion being: Haskell contributed to the collapse.
15:02:44 <ezyang> yeah, it's been rough 
15:02:47 <Axman6> aren't they hiring at the moment?
15:02:57 <wizard1337> haha
15:03:46 <ezyang> Axman6: Times can be bad, and they can be still hiring ;) 
15:03:59 <Axman6> wizard1337: it's worth remembering that popularity isn't a good measure of a language. if it were, the VW beatle would be the best car in the world
15:04:00 <kgadek> ezyang: I recall that the Haskell team was there because they were always able to outperform any other teams. Did this change in any way? Like in… had few bad days and few bad projects?
15:04:04 <kgadek> anything related to this?
15:04:47 <Axman6> and I guess we should all start using JavaScript because everyone else is
15:04:49 <ezyang> kgadek: I don't think it was specifically Haskell problem, but I think teams like the Haskell team get less flexibility when the bank as a whole is not as profitable 
15:05:02 <phz_> hey, isn’t there HDBC-sqlite3 in stackage?!
15:05:07 <kgadek> okay
15:05:18 <kgadek> I understand now
15:06:42 <kgadek> that's a pity. I hope SC will get on track again. They really shine in terms of "hey, they use haskell and the team is very successful!"
15:06:47 <Axman6> does anyone use HDBC any more? I haven't seen anyone use it for years
15:07:28 <ertes> what's even the point of HDBC?
15:07:35 <Axman6> phz_: look at packages like sqlite-simple
15:07:42 <phz_> ertes: what do you use?
15:07:50 <ertes> phz_: *-simple
15:08:03 <Axman6> ertes: someone thought Hasjell should have an equivalen to JDBC I guess? it's quite old, is it even maintained?
15:08:18 <phz_> hm, ok, thanks!
15:08:20 * Axman6 ha-yell
15:09:05 <ertes> i don't understand the point of JDBC either, except: "we are crazy OOP fanatics, object-hierarchify all the things!"
15:09:45 <kadoban> I used HDBC a couple of years back. It seemed fine, but even then I recall it showing its age.
15:09:48 <ertes> sorry, of course i meant class-hierarchify…  please don't jump at me =)
15:09:55 <phz_> yeah
15:10:01 <phz_> I’m maintaining my website
15:10:07 <phz_> writen in 2014
15:10:10 <phz_> written*
15:10:17 <phz_> btw
15:10:24 <phz_> is Happstack still maintained?
15:10:30 <kadoban> phz_: But anyway, even if it's not in stackage, you can still use it. You can add it as an extra-dep.
15:10:36 <phz_> kadoban: I know
15:10:38 <Axman6> looks like its last update was in 2015 (HDBC)
15:10:39 <kadoban> Which isn't necessarily to say that that'll work, but you can try anyway.
15:10:47 <phz_> but I guess I should switch to sqlite-simple
15:11:10 <phz_> what’s the most popular framework for web dev out there?
15:11:16 <phz_> I saw that Snap has a dev server 
15:11:17 <ertes> phz_: yes, happstack is still maintained
15:11:23 <Axman6> looks like happstack hasn't been updated since 2014
15:11:35 <Axman6> that's a shame, I remember when happstack was the hip new thing
15:11:39 <phz_> yeah
15:11:43 <ertes> use the happstack-server package, not the happstack package
15:11:47 <phz_> I loved writing my website with it!
15:12:04 <phz_> Fri Feb 10 01:44:09 UTC 2017 by JeremyShaw
15:12:08 <phz_> last update
15:12:09 <ertes> happstack was supposed to be a kind of "batteries included" version, but i think it never went anywhere
15:12:20 <srhb> It did, for a while.
15:12:21 <phz_> what about yesod then?
15:12:53 <Axman6> all my web stuff uses servant, but it tends not to be the sort of stuff you'd use something like yesod or snap for
15:13:08 <phz_> oh yeah
15:13:09 <ertes> yesod is to web frameworks what visual studio is to code editors =)
15:13:09 <phz_> servant!
15:13:11 <phz_> alp’s one!
15:13:16 <phz_> type driven, right?
15:13:18 <phz_> I remember that
15:13:22 <johnw> servant is great
15:13:43 <Axman6> servant is amazing
15:13:49 <phz_> is there any benchmarks?
15:14:00 <phz_> like req/s or that kind of biased stuff haha?
15:14:01 <Axman6> does it actually matter? =)
15:14:02 <kgadek> servant can be even used with yesod IIRC
15:14:09 <johnw> servant uses warp underneath
15:14:17 <Axman6> it's not slow, generally you'd run it on Warp, which is pretty bloody fast
15:14:34 <kgadek> actually I think it can use any server that conforms to $THIS_NAME_I_FORGOT
15:14:39 <srhb> wai
15:14:41 <kgadek> yes
15:14:42 <johnw> WAI
15:14:47 <Axman6> (and means you can get things like http2 basically for free)
15:15:38 <ertes> phz_: i can't show you a benchmark, but snap-server and warp are extremely fast
15:15:51 <phz_> what is warp exactly?
15:15:53 <phz_> a HTTP server?
15:15:56 <Axman6> and they scale very well on many cores
15:15:59 <srhb> techempower has some servant benchmarks.
15:16:05 <srhb> phz_: Yes.
15:16:14 <phz_> and is servant regarding warp then?
15:16:15 <ertes> phz_: yes, it's a WAI implementation
15:16:21 <Axman6> srhb: there have been some weird issues with those in the past showing really unrepresentative numbers
15:16:37 <srhb> Axman6: Weird how? Slow? :-P
15:17:03 <Axman6> I know some of the servant guys made a much faster entry than was in the published results, no idea if it has made it in yet though
15:17:10 <Axman6> yes, unusually slow
15:17:48 <ertes> phz_: most haskell frameworks these days use WAI, and warp is the most common implementation in use, although i've heard that some people don't want to spend their money on BDSM services, so they use something like FastCGI
15:18:24 <phz_> you speak alien to me
15:18:34 <phz_> I just looked up WAI to see what it is
15:18:35 <srhb> phz_: It goes like warp -> wai -> servant, where warp is the http server, wai is the application interface, and servant is the library to build your application in, with routing (in a way cool manner) etc.
15:18:37 <ertes> phz_: i'm glad =)
15:18:42 <ezyang> "BDSM service" lol 
15:18:47 <deepfire> : -)
15:18:54 <deepfire> we are onto something..
15:19:05 <phz_> hm srhb 
15:19:18 <phz_> so wai is a bit like… like wsgi for python, but for Haskell?
15:19:24 <srhb> phz_: Sort of ish.
15:19:33 <srhb> phz_: In Haskell it's all just libraries anyway :-P
15:19:43 <Koterpillar> don't they both claim to be language agnostic?
15:19:44 <srhb> phz_: (As in, you'll be importing the server in your code)
15:19:47 <ertes> phz_: except that WAI is purely a haskell-side API definition
15:19:48 <phz_> ok, so what does warp really providde?
15:20:00 <srhb> phz_: A function that runs a web server that can run wai compatible applications
15:20:01 <Koterpillar> warp provides the server side of the WAI API
15:20:04 <ertes> phz_: an HTTP server
15:20:09 <Axman6> Wai provides an interface where you provide an Application, which is essentially just Request -> IO Response
15:20:21 <phz_> hm so WAI is just some kind of abstraction over HTTP then?
15:20:26 <Axman6> it defines what Request and Response are, and your app builds those
15:20:32 <ertes> phz_: yeah
15:20:40 <phz_> that seems overly overkill :D
15:20:44 <phz_> but ok, I see
15:20:47 <srhb> It's not, you get to transform applications
15:20:52 <srhb> WaiApplication -> WaiApplication
15:20:59 <srhb> Which is pretty darn cool. :-)
15:21:16 <Axman6> phz_: how is that overkill? that's basically as simple as you can get :|
15:21:20 <phz_> ok, so warp is something that you feed with a WaiApplication then
15:21:24 <phz_> and it runs the server for you, right?
15:21:26 <ertes> phz_: snap-server is an example of a direct HTTP server + application interface
15:21:33 <srhb> phz_: It is the server.
15:21:35 <ertes> phz_: with WAI/snap those are separate
15:21:50 <deepfire> :t WaiApplication
15:21:52 <lambdabot> error:
15:21:52 <lambdabot>     Data constructor not in scope: WaiApplication
15:21:54 <phz_> I see
15:22:00 <ertes> phz_: happstack-server is another example
15:22:02 <phz_> so you just have your warp server running WAI stuff
15:22:14 <phz_> and you provide that WAI-compatible stuff with, for instance, servant?
15:22:28 <Axman6> warp is what takes care of handling concurrent requests and forking threads for each request
15:22:34 <Axman6> phz_: yes
15:22:40 <phz_> ok, I see
15:22:43 <Axman6> or snap, or scotty
15:22:47 <phz_> it’s a bit like wsgi then
15:22:55 <phz_> you write your code in, whatever, django
15:22:56 <Koterpillar> it is very much like wsgi
15:22:58 <Koterpillar> or psgi
15:22:59 <Axman6> or just write raw Request -> Response functions
15:23:02 <phz_> but wsgi is the actual thing handling the HTTP part
15:23:10 <srhb> phz_: This is from my current app: run 8080 (serve api app)
15:23:11 <Axman6> (the type is a little more complicated than that)
15:23:12 <phz_> interesting
15:23:21 <phz_> I should give it a try
15:23:29 <srhb> phz_: That runs my app on port 8080 with warp
15:23:34 <Axman6> there's not much to try, is is all intremely simple stuff
15:23:53 <Axman6> libraries like servant are where the interesting stuff happens
15:23:56 <deepfire> IIRC, there was announcement of some spiritual successor to servant
15:23:58 <ertes> phz_: to write a web application without any higher-level framework, you write a WAI application…  that application doesn't know anything about warp
15:24:01 <phz_> Axman6: I meant, turning http://phaazon.net to warp
15:24:05 <srhb> deepfire: Well, that was fast. :-P
15:24:15 <haskellnoob> I am stupmed on this one... redefine map http://lpaste.net/352631
15:24:22 <srhb> servant is, like, the bleedingest edge of cool type level API stuff.
15:24:25 <phz_> ertes: actually, I’m looking for a good framework, or a way to build one with very simple package
15:24:31 <ertes> phz_: what you get is a value of type Application…  that value you pass to warp, which knows how to turn an Application into an IO action that is a web server
15:24:36 <Axman6> deepfire: first I've heard, I would be very surprised if someone had come up with a nicer way of doing what servant does
15:24:36 <phz_> like servent, warp, something for caching, something for migration, etc.
15:24:55 <deepfire> srhb: and yet..
15:25:01 <ertes> phz_: scotty is a very simple framework to get your feet wet
15:25:04 <srhb> deepfire: What's the name?
15:25:07 <Axman6> phz_: maybe just look at yesod, it's more of a bells and whistles kind of deal
15:25:19 <deepfire> srhb, I'm struggling to even find the traces
15:25:30 <srhb> deepfire: Ah, no worries. I should head to bed anyway.
15:25:30 <phz_> ertes: well I say that, but all the code of http://phaazon.net is Happstack and my codebase, without any stuff about migration
15:25:33 <Axman6> deepfire: do you have anything to back that up?
15:25:41 <phz_> I have the sqlite3 dBHCBRCHECHBC stuff
15:25:42 <phz_> :D
15:25:44 <phz_> DHBC
15:25:47 <deepfire> Axman6: er?
15:25:59 <ertes> phz_: happstack-server is fine, too…  it just lacks one modern feature: streaming
15:26:05 <deepfire> Axman6: I don't make a claim or anything, just mentioning a vague recollection.
15:26:21 <Koterpillar> isn't happstack-server sidestepping WAI?
15:26:23 <phz_> ertes: like via conduit / machines?
15:26:28 <Axman6> phz_: is there anything dynamic on that site?
15:26:37 <phz_> Axman6: the browse stuff
15:26:54 <phz_> I’m just live reading a directory and sorting it by mime types
15:26:59 <ertes> phz_: regardless…  it can't have an effectful stream
15:27:05 <phz_> but there’s no other interaction than that and the upload stuff
15:27:14 <Axman6> yeah baring that, that would be a good candidate for something like hakyll
15:27:34 <Axman6> actually, everything but the uploading can be a static page
15:27:38 <ertes> phz_: to most applications that's irrelevant, but some may benefit from effectful streams
15:28:22 <haskellnoob> would be a huge help if anyone could help me with redefining map with foldr... I messed it up somewhere: http://lpaste.net/352631
15:28:29 <ertes> think of video streams, or of a stock tracker that feeds the latest prices continuously
15:28:39 <Axman6> phz_: make a static site, host it on S3 and use lambda (runnning haskell of course) to handle uploads and regenerate the index page when a file is uploaded =)
15:28:54 <phz_> well
15:28:57 <phz_> it’s not that static, actually
15:29:07 <phz_> because all the content of all pages is not Haskell code
15:29:13 <Axman6> haskellnoob: why does the function to foldr take three arguments?
15:29:14 <Koterpillar> haskellnoob: that function inside must take 2 arguments, not 3
15:29:19 <phz_> it’s hot reloaded as markdown via pandoc
15:29:28 <phz_> so that I can change a page without having to restart the server
15:29:42 <phz_> but I truly think the site is really ugly now.
15:29:43 <phz_> :D
15:29:56 <phz_> I’m no not a web developper – I actually hate web dev
15:29:59 <phz_> -no
15:30:22 <phz_> though, I’d like to use a nice technology to have fun with that and rewrite the damned website in a funny way
15:31:24 <haskellnoob> @Koterpillar, I tried (\x fs -> f x : fs) but that didn't work either
15:31:24 <lambdabot> Unknown command, try @list
15:31:52 <Axman6> phz_: so actually, you could easily write a server using something like servant which serves the static files and has a single handler for accepting the uploads and updating the static files when it's done
15:32:07 <phz_> Axman6: plus, I’d like not to have to edit my age at each birthdate haha
15:32:26 <phz_> Axman6: interesting
15:32:32 <Koterpillar> haskellnoob: and then, where do you get f?
15:32:40 <Axman6> haskellnoob: you need to get f from somewhere, your function doesn't have access to f, but your type says it accept something of type (a -> b), maybe you need to name that argument
15:33:04 <haskellnoob> how do I do that?
15:33:11 <phz_> btw, I just rewrote the ContT monad – because it’s been a while I haven’t done any Haskell besides maintaining packages for stackage
15:33:20 <Axman6> haskellnoob: how would you write map without foldr?
15:33:20 <phz_> I was wondering… who actually uses that monster? :D
15:33:56 <haskellnoob> map f (x:xs)= [f x| .... ] 
15:34:02 <Axman6> phz_: you should try writing the reverse state monad
15:34:12 <Aline> :t [True, False]
15:34:13 <phz_> reverse state monad?
15:34:14 <lambdabot> [Bool]
15:34:17 <Axman6> haskellnoob: so what's different to what you have in your foldr function?
15:34:37 <phz_> Axman6: can you explain what you mean? :D
15:34:41 <Axman6> phz_: yeah, the state travels backwards through the execution
15:35:09 <Axman6> phz_: https://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
15:35:11 <phz_> I still don’t get it :D
15:35:16 <haskellnoob> oook
15:35:27 <haskellnoob> I did mapFoldr f = .... before but it didn't work
15:35:32 <haskellnoob> maybe I had a type somewhere
15:35:35 <haskellnoob> dammit
15:35:39 <phz_> Axman6: hm, I see
15:35:43 <phz_> so when you need a state
15:35:50 <phz_> you basically ask to run the next operation
15:35:56 <phz_> and get back to the previous one?
15:36:37 <Axman6> you get the state from the next operation to pass to the thing before =)
15:38:40 <phz_> Axman6: I guess it makes your thunks go crazy, right?
15:39:10 <Axman6> phz_: the key is in how >>= is defined: sf >>= g = \s -> let (s'',a) = sf s''; (s',b) = g a s in (s'',b)
15:39:20 <phz_> yeah, I read that
15:39:30 <Axman6> notice that we run sf using the state returned by g, but we pass g the a returned by sf
15:40:04 <Axman6> to the state that would usually be passed to sf iin the normal state monad is actually passed to the action after
15:40:05 <phz_> that’s very weird
15:40:12 <haskellnoob> thank you everybody that helped
15:40:27 <haskellnoob> trying to get filterFoldr to work...
15:40:47 <phz_> Axman6: that reminds me of the implementation of ArrowLoop
15:40:53 <phz_> I’ve never understood it.
15:40:53 <phz_> :D
15:41:05 <phz_>         let (a,s'') = sf s'
15:41:06 <phz_>             (b,s') = runRState (f a) s
15:41:11 <phz_> this seems so twisted haha
15:41:26 <phz_> to me, it’s like infinite recursion
15:41:50 <phz_> because in order to get the a, you need s', and in order to get s', you need to evaluate (f a), hence you need a, hence s', hence a, etc. …
15:41:53 <phz_> :–’
15:42:00 <phz_> I guess it works because of boxing
15:42:02 <Ninger> Hi all!  Is there an easy way of getting a stack trace for an error message?
15:42:42 <Axman6> Ninger: sort of, you need to compile with profiling, one sec and I'll find a link
15:42:56 <Axman6> Ninger: https://simonmar.github.io/posts/2016-02-12-Stack-traces-in-GHCi.html
15:43:07 <monochrom> You don't need to get down to the level of boxing. At most you need lazy evaluation. But even that isn't necessary, you just need strictness.
15:43:14 <monochrom> Or rather, non-strictness.
15:43:16 <Ninger> Thanks, Axman6 
15:43:17 <haskellnoob> I got it to work but I do have a questions.... http://lpaste.net/352632
15:44:08 <haskellnoob> if p x then x else ?
15:44:40 <monochrom> [x | p x] looks like a type error.
15:44:48 <Axman6> it's not though
15:44:48 <monochrom> No, it's OK.
15:44:59 <phz_> monochrom: well
15:45:06 <monochrom> if p x then [x] else []
15:45:21 <monochrom> But [x | p x] is just fine.
15:45:21 <phz_> I’ve always found it easy to map laziness in mind when you have something like
15:45:37 <phz_> x = foo y
15:45:44 <haskellnoob> monochrom, if I use [], then it is still ++
15:45:53 <phz_> but (x, y) = foo z
15:45:56 <monochrom> Yes ++ is fine too.
15:46:21 <haskellnoob> I think I know how to do it with (:)
15:46:22 <monochrom> Both are equally lazy.
15:46:29 <Axman6> haskellnoob: the usual way to do this would be to use function compisition, foldr (\x -> if p x then (x:) else id) id  xs []
15:46:37 <monochrom> with (:) you really need to use if-then-else.
15:46:41 <phz_> monochrom: yes, but I fail to picture that in mind on how ghc will sort things out
15:46:43 <haskellnoob> if p x then x:fs else fs
15:46:45 <phz_>         let (a,s'') = sf s'
15:46:46 <phz_>             (b,s') = runRState (f a) s
15:46:52 <phz_> it’s hard to get why that works
15:47:02 <Axman6> laziness
15:47:17 <phz_> I guess that sf s' creates a box
15:47:25 <phz_> in which you have  (a, s'') unevaluated
15:47:32 <phz_> then, (f a)
15:47:40 <phz_> I guess it evaluates the box
15:47:42 <monochrom> phz_: You need to read my http://www.vex.net/~trebla/haskell/lazy.xhtml , no GHC or boxes are harmed in this explanation.
15:47:48 <Axman6> remember, those values are only evaluated when demanded, now at that definition site
15:47:58 <phz_> Axman6: yeah, and (f a) demands it
15:47:58 <Axman6> not*
15:48:05 <Axman6> not necessarilly
15:48:10 <phz_> because a is tight to sf s'
15:48:18 <Axman6> f could be (\ -> 1)
15:48:23 <Axman6> uh
15:48:25 <monochrom> You never needed a box. You just need to refrain-from-simplifying-everything-in-sight
15:48:28 <Axman6> \_ -> 1
15:48:35 <phz_> const 1
15:48:37 <phz_> ;)
15:48:39 <phz_> monochrom: yeah
15:49:06 <phz_> ok so let’s just state that (f a) just needs “some kind of pointer” to something that might get evaluated and get you the a when needed
15:49:07 <monochrom> So called "boxing" simply means you put something on the heap and you pass around a pointer.
15:49:20 <monochrom> But Java has been doing that forever and yet it is still not lazy.
15:49:31 <monochrom> Food for thought.
15:49:47 <phz_> that just dosn’t compute in my mind 
15:50:21 <phz_> so there’s no recursion implied here?
15:50:28 <monochrom> So let's say I have a super simple example.
15:50:42 <monochrom> let {x = 0:y ; y = 1:x} in whatevr
15:50:59 <phz_> yeah, I told you I understand this one
15:51:07 <phz_> because it has the signature x = …
15:51:10 <phz_> not (x, y) = …
15:51:19 <phz_> I can “map” in my mind
15:51:20 <phz_> something like
15:51:21 <monochrom> Oh!
15:51:35 <monochrom> Let { (x,y) = (0:y, 1:x) } in ... same difference
15:51:51 <phz_> yeah I don’t get it.
15:52:25 <phz_> the call above
15:52:26 <monochrom> Why am I using the capital L? :)
15:52:27 <phz_> to sf s'
15:52:42 <phz_> (a, s'') = sf s' ; (b, s') = runRState (f a) s
15:52:59 <monochrom> Presumably sf s' equals a certain tuple.
15:53:12 <phz_> yeah, but you cannot get that tuple 
15:53:20 <phz_> because it comes from something that depends on that
15:53:48 <phz_> but I have the exact same comprehension problem with MonadARrow
15:53:52 <phz_> wtf
15:53:55 <phz_> ArrowLoop*
15:54:38 <monochrom> If you have an actual thing instead of sf, you may have an easier time.
15:55:02 <phz_> so, sf s' gets its box and is unevaluated
15:55:06 <monochrom> Because talking abstract about even just "(x,y) = g x y" is not going to help.
15:55:09 <phz_> runRState (f a ) s as well
15:55:22 <phz_> let’s call those boxes sf_box and rst_box (yeah, I know)
15:55:30 <phz_> I guess that (f a) needs sf_box
15:55:34 <monochrom> Whereas a concrete (x,y) = (0:y, 1:x) does.
15:55:38 <phz_> and sf s' needs rst_box
15:55:49 <phz_> so hm, I guess there’s some kind of preallocation of the two boxes
15:55:54 <phz_> so that we can pass the pointers around
15:56:03 <monochrom> phz_, if you using boxing, everything is boxed always, laziness is pervasive.
15:56:14 <phz_> monochrom: Haskell’s types are boxed 
15:56:21 <phz_> and laziness is tightly coupled to that
15:56:24 <monochrom> OK, just so you know.
15:56:38 <phz_> but is my reasoning right with the two pointers?
15:56:41 <monochrom> It seems that I can't talk you out of boxing.
15:57:00 <phz_> I guess than when any of the expressions need to evaluate the other expression
15:57:07 <phz_> they kind of… resolve at the same time?!
15:57:22 <monochrom> What I can do is to make sure you are tired of boxing because you have to do it for every trivial detail.
15:57:38 <phz_> I’m not tired of boxing
15:57:40 <monochrom> If you write so much as "f (g x y) (h y z)"
15:57:46 <phz_> I’ve shifted from Haskell to Rust a year ago ;)
15:57:47 <monochrom> then there is a box around x
15:57:49 <deepfire> So, "a spiritual successor" might have been overblown, but IIRC this was that: https://github.com/nikita-volkov/strelka
15:57:52 <monochrom> a box around y,
15:57:55 <monochrom> a box around z
15:58:00 <phz_> monochrom: I know that
15:58:02 <monochrom> a box around (g x y)
15:58:13 <monochrom> There are altogether 6 boxes.
15:58:23 <phz_> but to me, in Haskell, that’s a way to say “that expression has a pointer behind and because it’s shared and lazy, that’s possible”
15:58:32 <monochrom> No, there are 9 boxes. There are boxes around f, g, and h too.
15:59:17 <phz_> (a, s'') = sf s' ; (b, s') = runRState (f a) s
15:59:29 <phz_> so here
16:00:12 <phz_> if runRState (f a) s is executed first, I guess it makes its way through until it needs a ; maybe that at this time it has already computed s''?
16:00:19 <phz_> uh, s'*
16:00:26 <phz_> so that evaluating sf s' is possible now?
16:00:31 <monochrom> No, nothing is executed now.
16:00:54 <monochrom> What is the thing after "in". *That* is executed now.
16:01:11 <phz_> after in?
16:01:16 <monochrom> Yes, after in.
16:01:21 <phz_> what in?
16:01:24 <phz_> ah, let in?
16:01:39 <monochrom> Whenever you see "let blahblah in foofoo", no one is executing blahblah.
16:01:41 <phz_> I think I should just try to write such a weird let in.
16:02:02 <phz_> monochrom: you’re playing with words
16:02:06 <monochrom> foofoo is the thing executed and it may or may not trigger executing some or all or none of blahblah
16:02:10 <phz_> it gets executed at some time
16:02:11 <monochrom> No.
16:02:28 <phz_> yeah, that’s what I said above
16:03:00 <phz_> in (b, s'')
16:03:14 <phz_> so it’ll need to execute both 
16:03:30 <phz_> so I guess we have to pick one, and the order doesn’t matter
16:03:36 <phz_> let’s say (a, s'') = sf s'
16:04:18 <phz_> it needs the expression holding s' to be evaluated
16:04:48 <phz_> yeah wtf, this is just overwhelming
16:05:00 <phz_> I can’t see how someone can quickly state that that code doesn’t loop forever
16:05:10 <haskellnoob>  how can I make this prettier? ... http://lpaste.net/352633
16:11:38 <deepfire> phz_, by the way, what do you think of Lambdacube3d ?
16:13:09 <phz_> deepfire: I know a little csaba
16:13:32 <phz_> I think the idea is interesting, but in the same time, I think it won’t go anywhere
16:13:44 <phz_> that’s the reason why I dropped Haskell in favor of Rust
16:14:34 <phz_> rendering / animation / video game is a domain in which you need a lot of determinism – in the sense of metal / hardware performance – and great control of your memory
16:15:15 <phz_> Haskell is not suited for that, hence, trying to make a very good 3D framework is noble, but in my opinion, it’s doomed
16:21:23 <deepfire> lambdacube-quake3 sure looks cool : -)
16:22:59 <deepfire> phz_: moreover.. there was a lot of work done on taming GC/laziness in Haskell
16:23:14 <phz_> ?
16:23:29 <phz_> I think that quake 3 stuff is just hilarious
16:23:49 <deepfire> phz_: do tell : -)
16:23:50 <phz_> because quake 3 ran on old machines with a hardware that any haskell programm wouldn’t even run on today
16:23:59 <phz_> (the C version I mean)
16:24:03 <phz_> (the original one)
16:24:28 <deepfire> phz_: the point is in how the rendering pipeline gets constructed, isn't it?
16:24:30 <Axman6> i use to run quake on my iPod 5G
16:24:55 <phz_> deepfire: basically, to the fact that Haskell doesn’t let you know which computation will go first
16:25:05 <phz_> to the fact its allocation scheme is just too violent
16:25:27 <Axman6> I"m not sure either of those are true
16:25:30 <phz_> and that when writing a 3D engine, you need to worry about a lot of stuff Haskell fails to help you reason about
16:25:34 <phz_> like cache misses, for instance
16:25:43 <koala_man> phz_: apart from the predictability, how is Rust compared to Haskell?
16:25:52 <phz_> well, I wrote a demo in Rust
16:26:02 <phz_> and it runs so fast
16:26:03 <koala_man> in language terms I mean
16:26:07 <phz_> ah
16:26:07 <phz_> well
16:26:12 <deepfire> phz_: isn't the modern-day problem in 3D being in the GPU pipeline, rather?
16:26:14 <phz_> it’s imperative with functional aspects
16:26:25 <deepfire> the CPU side is probably the boring side
16:26:26 <phz_> it has the concept of traits – typeclasses
16:26:45 <phz_> deepfire: it is if you consider that the CPU side is already well implemented
16:26:58 <phz_> that is, not too much cache miss, correct branch prediction, etc.
16:27:19 <deepfire> linear types will come, StrictHaskell is a thing
16:27:19 <phz_> in Haskell, where you can have many gigabytes of memory allocated per second…
16:27:32 <deepfire> ..linear types
16:27:34 <phz_> well, if one day Haskell gets rid of its GC
16:27:43 <deepfire> ..ditto
16:27:44 <phz_> I might consider getting back to doing graphics in Haskell
16:27:48 <phz_> but that won’t happen
16:28:04 <phz_> it might come from Idris instead :)
16:28:15 <deepfire> Idris already has linear types
16:28:17 <deepfire> indeed..
16:28:20 <phz_> yes it has
16:28:29 <phz_> it also have effects
16:28:36 <phz_> Haskell also has that wrong :D
16:30:18 <deepfire> that comes with being, what, 30 years, in advance? : -)
16:30:26 <phz_> what do you mean?
16:30:39 <deepfire> haskell goes way back
16:30:58 <phz_> do you links about that btw?
16:31:00 <deepfire> that it manages to evolve at its current pace is, well, nothing short of amazing
16:31:13 <phz_> Haskell is amazing, I love it
16:31:19 <monochrom> phz_: With the wrong sf or f, the code could loop forever.
16:31:20 <phz_> but I’m starting to love Rust maybe a little more now :)
16:31:30 <phz_> monochrom: yeah, I figured that out
16:31:44 <phz_> I guess I have to apply the best behavior: not trying to actually understand it :D
16:32:12 <monochrom> You should try some actual sf and f.
16:32:16 <phz_> and just “nothing is evaluated, so I can put anything I want, even weird relations”
16:32:30 <phz_> it’s the same thing as fix f = let x = fx in x
16:32:35 <phz_> but this one is simple to undersand
16:32:37 <phz_> understand
16:32:45 <deank> haskellnoob http://lpaste.net/352633#a352635
16:33:03 <monochrom> Try also this: http://lpaste.net/41790/ (Just vanilla Control.Monad.State)
16:33:14 <deepfire> phz_: according to wikipedia: "The first version of Haskell ("Haskell 1.0") was defined in 1990."
16:33:28 <phz_> in my mind, I just state that let x = f x in x creates some kind of “place” – you don’t seem to like the term “box” :) – which has a pointer ; we can allocate it at first, then it’s just a recurring call to that address
16:34:18 <monochrom> OK, I thought about it and I guess I shouldn't be too harsh on "box".
16:34:36 <phz_> well
16:34:42 <phz_> the first one actually loops, right?
16:34:55 <monochrom> Because I would talk about "a network of expressions" but then I will have nodes (graph theory) and that's same difference.
16:34:56 <phz_> because it’s like gen >> gen >> gen >> gen >> gen… >> modify (() :)
16:35:12 <phz_> with a lot of modify as well
16:35:27 <monochrom> Have you run it on a computer?
16:35:30 <phz_> not yet
16:35:36 <monochrom> try "take 10 many"
16:36:11 <monochrom> Also of interest is why I can get away with undefined at that place.
16:36:29 <phz_> well that’s easy
16:36:35 <phz_> monochrom: I’ve been doing Haskell for 3 years eh
16:37:02 <phz_> if you don’t ever read the state – which you don’t – no problem with undefined
16:37:32 <monochrom> But I have "modify" which seems to read the state.
16:37:49 <phz_> it doesn’t
16:37:57 <monochrom> I can admit and agree that "seems" is not good enough.
16:38:11 <phz_> monochrom: cons doesn’t read it
16:38:21 <monochrom> That does it.
16:38:27 <phz_> well, evaluate*
16:39:17 <monochrom> s/That does it/You've identified the key/
16:39:20 <phz_> > ()
16:39:23 <lambdabot>  ()
16:39:31 <phz_> ok, that still works
16:39:32 <phz_> yeah, look:
16:39:45 <phz_> I hope I won’t make any mistake and that my Haskell is still ok :D
16:39:55 <phz_> > take 3 $ () <$ fix (undefined:)
16:39:58 <lambdabot>  [(),(),()]
16:40:00 <phz_> :)
16:40:24 <phz_> I have no problem getting that kind of laziness in such a flat situation
16:40:30 <phz_> I just struggle with the tuple situation
16:40:36 <phz_> but I guess it’s kind of the same?
16:42:08 <monochrom> It is more involved.
16:42:15 <phz_> I remember having bad times trying to understand MonadFix as well
16:42:35 <patientpl> data Piece = Piece Float Float deriving (Show)
16:42:35 <patientpl> main = do
16:42:35 <patientpl> 	let blackpiece = Piece 0 0
16:42:35 <patientpl> 	blackpiece
16:42:51 <patientpl> i want to get the above to run, but im getting an error and im not sure why
16:42:52 <monochrom> Also probably you haven't seen the rules about what if the LHS is a general pattern rather than just a name.
16:43:15 <phz_> monochrom: yeah
16:43:18 <Koterpillar> patientpl: what do you want to happen here? What is the type of main? What is the type of blackpiece?
16:43:26 <monochrom> Change the last line to "print blackpiece"
16:44:07 <phz_> monochrom: actually
16:44:17 <phz_> that RState makes me think of Cont
16:44:21 <patientpl> main is main i guess? main is the main function - im not sure that it has a type. the type of the blackpiece is defined by data 
16:44:28 <phz_> how what you get in the do notation is actually something that has not happened yet
16:44:33 <phz_> because of being covariant in a
16:44:37 <phz_> (a -> r) -> r
16:44:51 <phz_> I find that very interesting :)
16:45:07 <monochrom> OK yes Cont is interesting.
16:45:21 <patientpl> Koterpillar what do you mean by main having a type? i find that question very confusing.
16:45:36 <Koterpillar> patientpl: everything has a type
16:45:38 <phz_> main :: IO ()
16:46:21 <patientpl> so im not allowed to define variables from main? is that what im hearing?
16:46:30 <Koterpillar> you can define variables
16:46:31 <phz_> what are you trying to do?
16:46:35 <Koterpillar> yeah
16:46:44 <Koterpillar> and what does the error tell you?
16:47:03 <patientpl> should it not be obvious what i want to do from my (broken) code?
16:47:10 <patientpl> not to be rude
16:47:18 <phaazon> patientpl: I think monochrom gave the best answer given the code you pasted
16:47:28 <monochrom> But they like to ignore me.
16:47:36 <phaazon> I saw :(
16:47:53 <monochrom> I am Delphi and people like to ignore me when I tell them what they need to hear.
16:47:55 <patientpl> do you have any suggestions Koterpillar
16:48:08 <Koterpillar> patientpl: see what monochrom said
16:48:11 <phaazon> I think they actually truly ignore you :D
16:48:14 <deepfire> patientpl: IO a != a 
16:48:32 <patientpl> i see well then i wont ask advice from you too any more
16:48:38 <patientpl> does anyone else have suggestions?
16:48:46 <patientpl> *two
16:48:54 <phaazon> we tried to help you
16:49:01 <phaazon> and we gave you an answer
16:49:03 <patientpl> what do you mean by that deepfire?
16:49:05 <phaazon> what else could we do? :(
16:49:16 <phaazon> deepfire: please just say “what monochrom said”
16:49:19 <kadoban> They are quickly running low on people they haven't ignored yet.
16:49:30 <dfeuer> patientpl: it's actually pretty hard to see what you're trynig to do from that.
16:50:02 <phaazon> and he’s called patientpl, how ironic
16:50:14 <phaazon> they’re*
16:50:19 <patientpl> im trying to set blackpiece to a datatype of Piece with floating points 0 and 0 and then print out blackpiece. i was trying to make a trivial example but i cant get it to compile
16:50:22 <deepfire> patientpl: more specifically, your problem is that IO Piece != Piece
16:50:30 <phaazon> yeah
16:50:40 <phaazon> and monochrom just gave you 3,9THE answer, patientpl 
16:50:47 <patientpl> i still dont understand
16:50:56 <deepfire> or, actally, sorry, IO () != Piece
16:50:58 <dfeuer> patientpl: well, the let is fine.
16:51:00 <ertes> patientpl: but you're not actually requesting to print it…
16:51:04 <dfeuer> Right.
16:51:16 <dfeuer> You're just sticking it there as though it were an IO action.
16:51:22 <ertes> patientpl: each line of a do-block must be an IO action…  a Piece is not an IO action
16:51:36 <phaazon> just replace your blackpiece by print blackpiece, on the last line
16:51:38 <ertes> but (print blackpiece) is an IO action
16:51:39 <phaazon> it’ll work \o
16:52:19 <dfeuer> Yeah. What ertes said.
16:52:24 <patientpl> so should i just call main then? ive not seen main called without main = do
16:52:35 <phaazon> I…
16:52:51 <ertes> patientpl: you see that line that you wrote that says just "blackpiece"?
16:52:52 <patientpl> also putStrLn(blackpiece) doesnt work because blackpiece is not a function im guessing
16:52:53 <dfeuer> patientpl: you need to add print.
16:52:57 <phaazon> I think my dreams of one day trying to teach stuff to people just collapsed
16:53:16 <dfeuer> patientpl: no, putStrLn blackpiece doesn't work because blackpiece isn't a *string*.
16:53:23 <phaazon> patientpl: have you read a Haskell tutorial?
16:53:25 <deepfire> phaazon: living people != IRC approximations, thankfully
16:53:33 <dfeuer> You can use   putStrLn (show blackpiece)
16:53:35 <phaazon> looks like you don’t know what you’re doing
16:53:37 <phaazon> deepfire: sure
16:53:38 <patientpl> interesting 
16:53:41 <dfeuer> Or you can use  print plackpiece.
16:53:43 <dfeuer> Which is the same.
16:53:47 <dfeuer> *blackpiece
16:53:47 <patientpl> does print("im a string!") also work?
16:54:01 <dfeuer> Yes. It prints the string with quotes around it.
16:54:05 <patientpl> ahh
16:54:10 <patientpl> thank you
16:54:17 <dfeuer> print = putStrLn . show
16:54:26 <phaazon> dfeuer: I think they have no idea what (.) is
16:54:26 <dfeuer> > show "Foo"
16:54:28 <lambdabot>  "\"Foo\""
16:54:40 <patientpl> neat
16:54:50 <ertes> thank monochrom…  everyone else has just been repeating it
16:55:10 <monochrom> Thank you ertes.
16:55:12 <dfeuer> . is function composition. (.).(.) is function composition composed with itself. 
16:55:14 <phaazon> I think monochrom just left their computer and drown under the shower for a while
16:55:18 <phaazon> ah they’re back \o
16:55:22 <deepfire> dfeuer, also, a literal substitution of "print" with "putStrLn . show" will /probably/ cause more confusion in this particular case : -)
16:55:39 <dfeuer> deepfire: yes, that would require paretheses.
16:55:49 <phaazon> or a $
16:55:55 <phaazon> to make things even more confusing for them
16:55:56 <phaazon> :)
16:56:07 <dfeuer> I tend to assume people already know how to use parentheses, but that assumption is often proven false.
16:56:19 <phaazon> though, defining print as print = putStrLn . show doesn’t require parens
16:56:24 <patientpl> monochrom was sarcastic to me - that's not something I do to others and it's something I don't have tolerance from from others. if my questions are too trivial to get advice that isn't ego driven, feel free not to respond.
16:56:32 <dfeuer> Because a lot of other languages do it weird.
16:56:40 <ertes> dfeuer: lispers will disagree on how parentheses work =)
16:56:42 <phaazon> patientpl: they wasn’t
16:56:50 <phaazon> they weren’t?*
16:57:16 <dfeuer> ertes: but lispers also don't expect to use operators infix ,so that's okay.
16:57:19 <ertes> patientpl: i think you misunderstood something there
16:58:17 <ertes> there is a "results first, then explanations" approach to teaching that works fairly well
16:58:33 <phaazon> in Haskell especially
16:58:40 <phaazon> otherwise, we’d all still be learning.
16:58:40 <phaazon> :D
16:59:33 <patientpl> im not going to rehash it - again no tolerance for rudeness
17:00:02 <phaazon> I think I better be out of here for a while
17:00:26 <phaazon> before I get to actually being rude for real
17:00:59 <deepfire> patientpl: please, trust us, monochrom didn't mean to offend -- he 1) offered advice, and 2) observed the lack of feedback from you
17:02:25 <ertes> some people were sarcastic, and i don't appreciate it any more than patientpl does
17:09:38 <ertes> patientpl: one (almost) universal truth in haskell is that "=" means "is equal to"…  when dfeuer says something like (print = putStrLn . show), then regardless of whether you know what the "." means, you can replace "print blackpiece" by "(putStrLn . show) blackpiece", and it will do exactly the same thing
17:10:22 <ertes> when people say that haskell is "pure" or "referentially transparent", they mean that you can use equational reasoning like that
17:11:00 <patientpl> interesting thank you
17:12:06 <ertes> notably, if you're coming from other languages, "=" does not mean assignment…  we use it as an equation symbol (almost) exclusively
17:14:37 <deepfire> ertes, thank you, seriousy
17:14:44 <deepfire> *seriously
17:15:59 <maybefbi> what do people ask in haskell interviews?
17:16:11 <maybefbi> is it about typeclassopedia?
17:16:22 <maybefbi> or fizzbuzz perhaps?
17:16:24 <phaazon> I had one a few weeks ago, it was about general knowledge
17:16:30 * Koterpillar got generic questions about some libraries
17:16:35 <ertes> maybefbi: i would ask about common libraries and abstractions
17:16:44 <hpc> zygohistomorphic prepromorphisms ;)
17:16:45 <phaazon> like “Do you know how you’d implement a differential list? what is it?”
17:17:04 <phaazon> or “implement a tree in which we’d like to update stuff and keep them ordered”
17:17:07 <phaazon> that kind of questions
17:17:13 <maybefbi> oh k
17:17:15 <hpc> but yeah, looking for understanding of abstractions and CS in general really
17:17:18 <phaazon> “what is a zipper?”
17:17:20 <phaazon> I got that kind of question
17:17:40 <phaazon> I even got the question “do you know free monads? what are they good for?”
17:17:44 <phaazon> :)
17:17:58 <hpc> interviews tend to all come out the same, once you account for the different focus of the company
17:18:08 <hpc> maybe you get a networking question, or an http question, or an smtp question
17:18:23 <hpc> and then you pick an abstraction for it and they follow up on it
17:18:44 <maybefbi> hmm interesting
17:19:07 <maybefbi> i have one next week. im wondering what to focus my practice on.
17:19:21 <hpc> you can't go wrong with data structures
17:19:27 <maybefbi> im currently just rehearsing my standard typeclass derivations
17:19:31 <maybefbi> ok
17:19:39 <exio4> cool, a haskell interview!
17:19:44 <ertes> maybefbi: look at widely used libraries and write a guestbook in at least one web framework
17:20:07 <maybefbi> copy that. i like the servant, hasql combination
17:20:24 <maybefbi> maybe i will write something simple in it
17:20:33 <ertes> maybefbi: also keep an eye on trends by reading /r/haskell and/or twitter
17:21:12 <maybefbi> yeah to be frank i just focus on principles like that peyton jones talk about lens
17:21:29 <maybefbi> there are too many operators to memorize in Control.Lens
17:21:29 <ertes> and common abstractions…  learn your free monads, lenses, parsers and pipes/conduits =)
17:22:12 <ertes> actually the operators follow a naming scheme that is easy enough to get used to
17:22:46 <ertes> also: learn libraries and abstractions that are relevant to the job
17:23:25 <ertes> i would say: learn data structures, but i'm afraid that a week will not be enough =)
17:23:48 <maybefbi> i guess i will just learn standard typeclass, solve a few leetcode problems, and then write a guestbook rest api in servant and hasql
17:26:13 <maybefbi> the standard typeclasses always amaze no matter how many times i learn it. it deserves a lifetime of meditations
17:27:04 <ertes> just keep in mind that this is a job interview…  you will be doing a lot of "getting stuff done" =)
17:27:32 <ertes> if zygohistomorphic prepromorphisms don't sound like "getting stuff done" to you, they will not sound like that to your interviewer =)
17:28:04 <maybefbi> nah im talking like functor, applicative functor, monad
17:29:19 <phaazon> what is the syntax to build a specific target with stack again?
17:29:20 <ertes> also don't waste time understanding the joke: "monads? they're just monoids in the category of endofunctors, what's the problem?"
17:29:21 <phaazon> stack build stuff?
17:29:27 <phaazon> I have a two bins
17:29:49 <ertes> when i understood it after years of haskell, my first thought was:  well, that was a waste of time =)
17:30:02 <ertes> spending years to understand a joke just to find that it isn't that good =)
17:30:31 <johnw> ertes: well, it is kind of beautiful to understand how pervasive monoids are
17:30:52 <maybefbi> ertes, i like the fish based definition of monad more than the join or bind based one. fish does seem like a composition operator for kleisi arrows
17:31:25 <hpc> that's because it is
17:31:32 <johnw> doesn't the fish version make the monoid aspect harder to see?
17:31:44 <johnw> since the fish is a composition
17:31:44 <maybefbi> and then it is kinda obvious that monads are composition operators in the category of kleisi arrows
17:31:48 <ertes> not if you think of categories as monoids on steroids
17:31:59 <maybefbi> which is a better joke in my opinion
17:32:12 <dmwit> I think fish makes the monoid aspect easier to see.
17:32:13 <hpc> johnw: it's still fairly easy to see, just gotta get to category and the rest is "oh by the way, endofunctors"
17:32:16 <hpc> or something like that
17:32:20 <phaazon> no one for the stack error?
17:32:29 <dmwit> return >=> x = x = x >=> return -- these are the unit laws for monoid
17:32:43 <dmwit> x >=> (y >=> z) = (x >=> y) >=> z -- these are the associativity laws for monoid
17:32:56 <ertes> s/monoid/category/
17:33:07 <hpc> :t sequence
17:33:09 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
17:33:26 <hpc> (almost mconcat)
17:33:29 <ertes> but i suppose johnw is talking about those other monoids
17:33:59 <dmwit> Oh, you're specifically talking about the "monoids in the category of endofunctors" joke. Never mind, then, I don't think these are related to that kind of monoid.
17:34:26 <dmwit> These are related to the "categories are just typed monoids" perspective.
17:37:12 <dolio> I don't see why understanding that definition would make the 'joke' funny.
17:38:05 <johnw> maybe a point being made here is that once you get the joke, it's not funny anymore. :)
17:38:05 <dolio> The 'joke' is that it takes years (maybe) of understanding to unpack that definition, then saying, "what's the problem."
17:39:59 <ertes> say "ε < 0" in a room full of mathematicians, and you'll see that they don't have particularly high standards when it comes to jokes
17:41:03 <JavaSucksMan> OK... it's bad enough that the ghci_history file is backwards....
17:41:11 <JavaSucksMan> How do I get it to keep more than 100 lines?
17:41:47 <JavaSucksMan> mike@kingman:~$ cat .ghc/ghci.conf 
17:41:49 <JavaSucksMan> System.Console.Editline.Readline.stifleHistory 1000000
17:41:57 <JavaSucksMan> gave me the error
17:42:05 <JavaSucksMan>     Not in scope: ‘System.Console.Editline.Readline.stifleHistory’
17:42:40 <ertes> JavaSucksMan: http://trac.haskell.org/haskeline/wiki/UserPrefs
17:44:46 <JavaSucksMan> No... 40 is too small  ;-)
17:44:58 <JavaSucksMan> just kidding... Nothing is the max
17:45:08 <JavaSucksMan> thanks
17:49:18 <monochrom> yikes, monoids on steroids.
17:50:36 <monochrom> The Olympic gods forbid steroids applicative to monoids or any athlete enhancements.
17:51:03 <ertes> JavaSucksMan: i don't think there is a max…  GHC is written in haskell, not in C =)
17:51:32 <ertes> monochrom: "enhancements"?  you mean extensions?
17:51:33 <monochrom> Ah but libgmp is written in C too.
17:51:42 <monochrom> extensions is better!
17:52:16 <monochrom> Also, the history size field is Maybe Int, not Maybe Integer. There is a max, at least in the Just case.
17:52:59 <monochrom> consequence being: you can't have a limit of 293084930284039242348.
17:53:25 <ertes> ah, indeed…  stupid 'take'
17:55:45 <monochrom> I do not actually understand why they bother with Maybe Int to begin with, looks like worst of both worlds, but meh, historical reasons.
17:56:12 <ertes> i don't know what Nothing means
17:56:24 <monochrom> True.
18:02:09 <lpaste_> monochrom pasted “(lazy) pattern bindings” at http://lpaste.net/352637
18:02:18 <monochrom> phaazon: That.
18:13:35 <phaazon> monochrom: yeah
18:13:37 <phaazon> it makes sense :)
18:13:38 <phaazon> thanks
18:14:48 <monochrom> :)
18:16:49 <phaazon> > let h x xs = x : x : xs; let z:zs = h z zs; (z, take 5 zs)
18:16:51 <lambdabot>  <hint>:1:59: error:
18:16:51 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
18:17:13 <monochrom> missing "in z" or something
18:17:21 <phaazon> > { let h x xs = x : x : xs; let z:zs = h z zs; } in (z, take 5 zs)
18:17:23 <monochrom> Oh!
18:17:23 <lambdabot>  <hint>:1:1: error: parse error on input ‘{’
18:17:29 <phaazon> dammit
18:17:30 <monochrom> let {
18:17:39 <Koterpillar> > let h x xs = x : x : xs; z:zs = h z zs in (z, take 5 zs)
18:17:40 <phaazon> > let { h x xs = x : x : xs; let z:zs = h z zs } in (z, take 5 zs)
18:17:42 <lambdabot>  <hint>:1:46: error: parse error on input ‘}’
18:17:45 <lambdabot>  mueval-core: Time limit exceeded
18:17:50 <Koterpillar> I win
18:17:50 <phaazon> yeah I knew it. :D
18:18:32 <monochrom> but "length (take 5 zs)" will work
18:18:37 <phaazon> > let h x xs = 1 : x : xs; let z:zs = h z zs  in (z, take 5 zs)
18:18:39 <lambdabot>  <hint>:1:62: error:
18:18:39 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
18:18:49 <monochrom> You also have one more "let" than necessary.
18:19:04 <phaazon> > let h x xs = 1 : x : xs; z:zs = h z zs  in (z, take 5 zs)
18:19:07 <lambdabot>  (1,[1,1,1,1,1])
18:19:09 <phaazon> I’m tired :)))
18:19:11 <monochrom> neat
18:19:28 <phaazon> this is a bit mindfarting, but hm :D
18:20:00 <phaazon> anyway, it’s 3:20 AM
18:20:03 <phaazon> night all
18:20:08 <monochrom> yikes
18:20:11 <phaazon> thanks for your help explaination
18:20:18 <phaazon> it’s been a while I hadn’t done any Haskell
18:20:18 <monochrom> you're welcome. good sleep.
18:20:33 <phaazon> I just migrated my website from HDBC to sqlite-simple in the meantime
18:20:36 <phaazon> :)
18:20:46 <phaazon> thanks! see you around, have a good day/sleep as well
18:26:01 <monochrom> I compiled this code with -O: x,y :: Int; (x, y) = divMod (y+1) (x+2)
18:26:15 <monochrom> I looked at the core code. It goes simply "y = y; x = y"
18:26:22 <monochrom> damn you smart compiler.
18:31:10 <stephA> little question. Do you know of any simple way to transform a data MyData = OptA | OptB | OptC   into integral values 1,2,3 or 0,1,2  respectively for OptA, OptB,OptC. I may define a custom function doing the pattern matching, but I'm wondering if haskell has not something ready for doing that.
18:31:54 <pacak> stephA: deriving (Enum)
18:31:57 <pacak> :t toEnum
18:31:58 <lambdabot> Enum a => Int -> a
18:31:59 <pacak> :t fromEnum
18:32:02 <lambdabot> Enum a => a -> Int
18:32:10 <stephA> cool
18:32:13 <pacak> fromEnum True
18:32:16 <pacak> > fromEnum True
18:32:18 <lambdabot>  1
18:32:21 <pacak> > fromEnum False
18:32:23 <lambdabot>  0
18:32:30 <stephA> perfect !
18:32:33 <MarcelineVQ> though usually the point of a datatype like that is to avoid using numbers to stand in for things :>
18:33:15 <stephA> yep, but I want to do some kitchen recipe formula for a fantasy ration, and some literal value are better multiplied when integers instead :-°
18:33:19 <stephA> :-)
18:33:52 <MarcelineVQ> :D
18:36:52 <patientpl> can someone tell me why the following doesn't compile:
18:36:54 <patientpl> main = do
18:36:54 <patientpl> 	let blackset = []
18:36:54 <patientpl> 	blackset++[1]
18:36:54 <patientpl> 	print(blackset)
18:36:56 <patientpl> ?
18:37:29 <patientpl> im attempting to make an empty list, store a value of 1 in it, and finally print it, from main
18:37:30 <pacak> (10:36:32) patientpl: 	blackset++[1]
18:37:37 <pacak> probably this
18:37:44 <patientpl> what's wrong with that?
18:38:04 <pacak> main supposed to be IO monad
18:38:23 <pacak> let blackset = [] -- blackset is an empty list
18:38:30 <patientpl> yep
18:38:48 <pacak> next line should be an IO action
18:38:49 <patientpl> and then i want to add one to the list
18:38:52 <pacak> but it's not
18:39:00 <pacak> There are no variables in haskell.
18:39:02 <exio4> patientpl: you can't "add one to the list", though
18:39:11 <pacak> Lists are immutable
18:39:19 <patientpl> ok
18:39:23 <c_wraith> patientpl: the mistake is the mental model.  You don't change data structures in Haskell.
18:39:31 <pacak> let blackset1 = blackset ++[1]
18:39:32 <pacak> print blackset1
18:39:51 <c_wraith> patientpl: fortunately, you don't need to.  You can always create a new one based on an older one.
18:39:57 <patientpl> mmm
18:40:13 <patientpl> so the issue is the mutability?
18:40:34 <pacak> In your case it simply failed to typecheck
18:40:56 <c_wraith> The (++) operator doesn't mutate lists.
18:40:57 <patientpl> ok that compiles however
18:41:02 <c_wraith> It returns a new list
18:41:15 <c_wraith> You were attempting to treat the returned list as an IO action
18:41:24 <c_wraith> Those are not the same thing, so you got a type error
18:41:28 <patientpl> I tried to use : and that doesn't work either. the issue is that I will need to mutate lists for what I have in mind
18:41:40 <pacak> let blackset1 = 1 : blackset
18:42:02 <c_wraith> patientpl: here's a secret: you don't need to mutate anything, ever, with the right computational models. :)
18:42:16 <pacak> patientpl: I suppose it is tempting, if the only tool you have is a hammer, to treat everything as if it were a nail. 
18:42:23 <patientpl> sure, that works, i understand that. however for what i want to do im going to have to add and subtract lots of items from a list
18:42:26 <pacak> patientpl: You probably don't need to mutate stuff.
18:42:47 <exio4> patientpl: you need to think the problem such that you don't need to!
18:42:53 <patientpl> stop
18:43:10 <patientpl> lets say that i do
18:43:16 <patientpl> is there a way to do this
18:43:57 <ertes> patientpl: about your earlier example: remember what i said about "="?  you wrote:  blackset = []
18:44:09 <ertes> that means blackset is equal to [] and will be equal to [] forever
18:44:43 <patientpl> ertes i understand the constraints of an immutable variable. im asking if there is a way of defining a mutable list in haskell.
18:44:48 <c_wraith> patientpl: there are ways to use mutability, but they're a lot more mental overhead, as they should be.
18:45:05 <c_wraith> patientpl: mutability is *really hard* to get right.  It should therefore force you to think to use it.
18:45:14 <exio4> patientpl: they're quite annoying to work with, and bulky :)
18:45:26 <c_wraith> patientpl: and you can't ever mutate a data structure that wasn't intended for it.
18:45:38 <ertes> patientpl: yes, but you shouldn't use them
18:46:00 <ertes> patientpl: the way to achieve state in haskell is recursion
18:46:44 <patientpl> so use a recursive function
18:46:45 <ertes> patientpl: of course what you're doing right now is stateless, so the pedantic answer is:  just define (blackset = [1]) instead
18:47:52 <ertes> patientpl: exercise: define a function (printHelloTimes :: Int -> IO ()) that prints the line "Hello world!" the given number of times
18:48:12 <ertes> so the program (main = printHelloTimes 10) prints "Hello world!" 10 times
18:57:19 <dmwit> pacak++ c_wraith++ exio4++ ertes++ for incredible patience
19:00:38 <ertes> patientpl: this is an exercise on pure state…  if you need help, feel free to ask…  we can also do it step by step
19:00:38 <Rotaerk> why'd you just concatenate pacak, c_wraith, exio4, ertes, and (for incredible patience)
19:00:53 <monochrom> haha
19:00:59 <ertes> =)
19:01:07 <c_wraith> patience is concatenative, right?
19:01:13 <exio4> Rotaerk: we're stronger together!
19:01:19 <Rotaerk> :P
19:01:20 <ertes> but i'm not a list!
19:01:21 <c_wraith> Does this imply there's a patience monoid?
19:02:32 <ertes> sure there is a patience monoid:  newtype Patience = Patience Patience
19:03:35 <monochrom> What is its mempty?
19:03:52 <ertes> mempty
19:03:55 <Koterpillar> no one's got time to answer that!
19:04:03 <monochrom> yikes
19:04:14 <ertes> Koterpillar: just be patient
19:10:23 <pacak> use concat instead of a bunch of ++
19:22:10 <byorgey> dmwit: working with diagrams over Integer or Rational is hard (I have considered it), you really need square root.  And in any case I don't think it would solve benzrf's problem.  Rendering itself introduces error even if your diagrams are represented exactly.
19:23:11 <wizard1337> is there a strict by default haskell?
19:23:14 <dmwit> Yes. I never wrote up my cunning plan, but it was something along the lines of "rendering causes rounding, and we don't want rounding... what if we never render the diagram?". ;-)
19:24:52 <ertes> wizard1337: you can make modules strict by default via -XStrict, but you won't get a strict haskell that way
19:29:02 <monochrom> dmwit: That is anti-climatic. I was hoping for something cleverer than that.
19:29:50 <monochrom> But the real horror is that benzf indicated that they were using cyclotomic numbers already.
19:30:06 <benzrf> :D
19:30:43 <monochrom> We need analog vector graphics on a CRT
19:30:49 <benzrf> @let newtype Patience = Patience Patience
19:30:51 <lambdabot>  Defined.
19:30:56 <Koterpillar> monochrom: been done
19:30:59 <benzrf> @let patient = Patience patient
19:31:00 <lambdabot>  Defined.
19:31:25 <monochrom> Yeah I heard that McCarthy did his first windowing system on vector graphics CRT
19:39:30 <nshepperd> > undefined :: Patience
19:39:32 <lambdabot>  Patience (Patience (Patience (Patience (Patience (Patience (Patience (Patien...
19:40:37 <dmwit> nshepperd: your Patience is unmatched
19:40:56 <monochrom> haha
19:41:00 <LeCamarade> Hah! Not funny! 😁
19:42:46 <byorgey> dmwit: hahahaha (I am laughing at both jokes)
19:43:20 <dmwit> =D
19:44:50 <nshepperd> The close paren is sure to come tomorrow.
19:46:35 <monochrom> The Racket Summer School is advertising on the haskell mailing list.
19:47:10 <monochrom> I have no objection, except "As soon as you get accepted, we will send you your first problem set. Get ready.", which suggests that it starts now.
19:47:24 <monochrom> We are still 6 months away from summer!
19:51:21 <nshepperd> it's always summer (somewhere)
19:54:58 <patientpl> given i have addone = (:[1]) and emptylist = [] i want to write addone emptylist
19:55:36 <patientpl> however i get the error  "non type-variable argument in the constraint Num [t] use flexiblecontexts to permit this"
19:58:43 <Koterpillar> patientpl: give them types
19:59:19 <dmwit> I suspect you would prefer `addone = (1:)`.
20:00:40 <dramforever> :t (:[1]) []
20:00:42 <lambdabot> Num [t] => [[t]]
20:01:15 <dmwit> > []:[1]
20:01:18 <lambdabot>  error:
20:01:18 <lambdabot>      • Ambiguous type variable ‘t0’ arising from a use of ‘show_M886538537024...
20:01:18 <lambdabot>        prevents the constraint ‘(Show t0)’ from being solved.
20:01:19 <dmwit> > 1:[]
20:01:22 <lambdabot>  [1]
20:02:25 <dramforever> patientpl: See? Num [t] is the problem
20:02:25 <dramforever> Lists aren't numbers
20:03:06 <EvanR> instance Num [
20:03:13 <EvanR> instance Num [Bit] where
20:03:17 <dmwit> dramforever: I am mildly curious how you are able to see the conversation. My client pins you as having joined *after* the things you're responding to.
20:03:34 <dramforever> dmwit: See the topic of #haskell?
20:03:38 <dramforever> We have logs
20:03:59 <dmwit> Do you have some client integration with those logs, or do you just check them yourself?
20:04:22 <dramforever> The ircbrowse logs somehow stopped updating since about 2 weeks ago, but the tunes logs are fine
20:04:47 <dramforever> dmwit: I just check them manually
20:04:55 <dramforever> I always do this
20:05:00 <dmwit> fun
20:05:42 <dmwit> EvanR: Or `instance Num a => Num [a] where (+) = liftA2 (+); fromInteger = pure . fromInteger` etc.
20:06:28 <EvanR> > liftA2 (+) [1,2,3] [4,5]
20:06:31 <lambdabot>  [5,6,6,7,7,8]
20:07:00 <dramforever> but hey
20:07:35 * dmwit . o O ( What are the `Num` laws? )
20:07:46 <monochrom> (x:xs) + (y:ys) = (x+y) `mod` 10 : (xs + ys + carry)
20:07:52 <dramforever> Heck
20:08:08 <dmwit> monochrom: yep, 10 seems like the natural base
20:08:09 <dramforever> [[], 1] Just outright doesn't make much sense
20:08:48 <dramforever> monochrom: How about polynominal?
20:08:55 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #10
20:09:54 <monochrom> Doug McIlroy did polynomials
20:10:29 <monochrom> http://www.cs.dartmouth.edu/~doug/powser.html
20:10:46 <monochrom> more than polynomials. power series he did.
20:12:01 <tlahtoani> Ah 
20:12:06 <dramforever> wtf
20:12:32 <tlahtoani> How would I go about doing a left wrapping bitwise rotation in Haskell?
20:13:11 <monochrom> something in Data.Bits. Does "rotate" help?
20:13:36 <monochrom> also rotateL and rotateR
20:13:46 <tlahtoani> Do they wrap?
20:14:11 <dramforever> > printf "%x" (rotateL 0xf0f0f0f0) :: String
20:14:11 <monochrom> If I understand "wrap" correctly, yes.
20:14:14 <lambdabot>  error:
20:14:14 <lambdabot>      • No instance for (PrintfArg (Int -> a0))
20:14:14 <lambdabot>          arising from a use of ‘printf’
20:14:18 <tlahtoani> It's imperative that it wraps 
20:14:23 <dramforever> :t rotateL
20:14:25 <lambdabot> Bits a => a -> Int -> a
20:14:29 <dramforever> > printf "%x" (rotateL 0xf0f0f0f0 4) :: String
20:14:31 <lambdabot>  "f0f0f0f00"
20:14:41 <dramforever> uhoh
20:14:50 <tlahtoani> That did not wrap 
20:15:13 <monochrom> say "Int32" or "Word32"
20:15:17 <dramforever> tlahtoani: I did it wrong sorry
20:15:19 <tlahtoani> It just sort of added a bit 
20:15:24 <dramforever> > printf "%x" (rotateL 0xf0f0f0f0 4 :: Word32) :: String
20:15:28 <lambdabot>  "f0f0f0f"
20:15:32 <dramforever> tlahtoani: because Integer is unbounded
20:15:39 <dramforever> So it will never wrap
20:15:44 <dramforever> Word32 will wrap
20:16:15 <tlahtoani> I guess I should specify that my use case invoked 2-128 bits...
20:16:23 <tlahtoani> Involves*
20:16:37 <monochrom> But which number type are you using?
20:16:51 <EvanR> theres a Word128 lying around probably
20:17:03 <tlahtoani> The one that is only limited by RAM
20:17:27 <dramforever> Integer or Natural, presumably
20:17:38 <tlahtoani> Integer 
20:17:43 <monochrom> Integer and Natural does not know that you're interested in 128 bits.
20:18:08 <kadoban> "For unbounded types like Integer, rotate is equivalent to shift." from the docs
20:18:12 <tlahtoani> My specific use case is 128 bits but the ability to rotate 24000 bits is okay
20:18:24 <kadoban> Which is all it could really do.
20:18:30 <monochrom> I think you'll have to code up something yourself.
20:18:40 <tlahtoani> Aww
20:18:52 <EvanR> a bit zipper
20:19:10 <tlahtoani> JS made me convert to strings 
20:19:36 <tlahtoani> I need to shift the most significant bit to make it the least significant bit 
20:19:51 <tlahtoani> Which is harder in practice than I thought 
20:20:19 <monochrom> Do you only shift for 1 bit?
20:21:35 <tlahtoani> Yes 
20:21:41 <tlahtoani> Just a single bit 
20:22:30 <monochrom> I'm thinking how to obtain a bit mask that has exactly one 1 and it is right at your MSB.
20:22:47 <alx741> hello everyone. Is there a package to print out a human representation of time from a UTCTime type, like in "1 week ago" or "30 minutes ago"?
20:24:15 <monochrom> Or a bit mask that has 1's from your MSB to 0
20:24:47 <tlahtoani> The important part is that 1001 become 0011
20:27:33 <EvanR> alx741: thats not a function of one UTCTime, but rather 2
20:27:46 <tlahtoani> A complicated solution to a complicated problem...
20:28:14 <EvanR> or one Integer number of seconds
20:28:45 <EvanR> (NominalDiffTime)
20:28:58 <alx741> EvanR: oh!, you're right, the current time. UTCTime -> UTCTime -> IO String
20:29:09 <EvanR> IO???
20:29:32 <tlahtoani> Shifting to the the left while wrapping the bit is the solution to the Josephus permutation 
20:30:27 <alx741> EvanR: will take a look at NominalDiffTime, thanks! (and yep, IO would be dumb in there, my mistake)
20:31:01 <EvanR> search for time formatting packages
20:32:31 <dmwit> tlahtoani: http://hackage.haskell.org/package/arithmoi-0.4.3.0/docs/Math-NumberTheory-Logarithms.html#v:integerLog2
20:32:40 <dmwit> for getting the MSB
20:33:11 <EvanR> i have a feeling the most significant bit is 1
20:33:22 <dmwit> Yes. For getting the *index* of the MSB.
20:34:23 <dmwit> But I doubt this is really what's wanted.
20:34:50 <dmwit> After "rotating" the MSB into the LSB position, the index of the MSB may decrease.
20:34:58 <alx741> EvanR: humanRelTime is the winner, just the type signature I was looking for :) , thanks!
20:35:16 <dmwit> So 1001 would not become 0011, it would become 11.
20:35:42 <EvanR> heh "30 seconds ago" is the "human" rendering]
20:36:05 <tlahtoani> Which is fine 
20:36:23 <tlahtoani> The zeros were there to keep the representation consistent 
20:36:29 <Axman6> tlahtoani: I missed the beginning of this, what're you trying to do? looks like something HAcker's Delight would have solutions for
20:37:01 <tlahtoani> Solve the Josephus permutation without calculating each answer 
20:37:02 <Axman6> (I have a copy of it with me if it might be useful)
20:38:29 <tlahtoani> Instead doing a neat bit hack gives you the correct answer Everytime 
20:39:19 <Axman6> there was a video on this recently... which youtube channel was it...
20:39:34 <tlahtoani> Number phone 
20:39:37 <tlahtoani> Fff
20:39:41 <tlahtoani> Numberphile
20:39:52 <Axman6> yes, that one
20:40:48 <Axman6> so, what bit twiddling are you trying to do?
20:41:24 <Axman6> (also writing an efficient rotate function if pretty trivial, it's just two shifts
20:41:25 <tlahtoani> 1001 -> 0011
20:42:00 <EvanR> 1011 -> 0111 ?
20:42:09 <tlahtoani> Yah
20:42:22 <EvanR> 100101101 -> 001101101?
20:42:55 <tlahtoani> Nej
20:42:55 <EvanR> heh
20:42:57 <Axman6> > let rot x n = rotateL x n .|. shiftR x (bitSize x - n) in rot (0b1001 :: Word8)) 1
20:43:00 <lambdabot>  <hint>:1:80: error: parse error on input ‘)’
20:43:10 <Axman6> > let rot x n = rotateL x n .|. shiftR x (bitSize x - n) in rot (0b1001 :: Word8) 1
20:43:12 <lambdabot>  error: Variable not in scope: b1001
20:43:15 <tlahtoani> 100101101 -> 001011011
20:43:17 <Axman6> bleh
20:43:22 <Axman6> Y U NO BITS
20:53:12 <ubsan> is there any way to force onesself to write function types?
20:53:33 <ubsan> make the compiler error in those cases where you define a function without giving its type?
20:54:16 <ubsan> I really don't like full program inference
20:54:28 <Maxdamantus> Presumably you're not referring specifically to functions and you are referring specifically to top-level definitions?
20:54:37 <ubsan> Maxdamantus: yeah
20:54:54 <Koterpillar> ubsan: there's a warning, which you can make into error
20:54:57 <dramforever> I'm pretty sure -Wall -Werror does that
20:55:00 <lubricy> join #haskell-beginners
20:55:08 <dramforever> Koterpillar: lol
20:55:46 <ubsan> Koterpillar: how do?
20:55:57 <ubsan> -Wall -Werror, I guess
20:55:57 <dramforever> -fwarn-missing-signatures
20:56:24 <ubsan> it's very strange to see gcc-style flags in a non-C++ compiler, tbqh :P
20:58:34 <dramforever> ublubu: gcc has them under -W not -fwarn
20:58:48 <ubsan> dramforever: -Werror and -fwarn
20:59:45 <dramforever> Sorta
21:00:08 <ubsan> dramforever: I mean, it looks like C compiler options lol
21:00:11 <lubricy> @help
21:00:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:01:02 <geekosaur> ghc8 uses the -W style, fwiw (the -f forms are still supported for backward compatibility)
21:01:42 <dramforever> Geekingfrog: Thanks for the information
21:01:48 <ubsan> geekosaur: oh, cool
21:01:49 <dramforever> Uh sorry I meant geekosaur 
21:01:57 <geekosaur> but, show me the C++ compiler with -Wunused-do-binds :)
21:02:02 <ubsan> dramforever: you kinda suck at pinging the right person :P
21:02:06 <ubsan> lol
21:02:17 <ubsan> geekosaur: I mean
21:02:22 <ubsan> maybe not do-binds
21:02:23 <ubsan> but
21:02:44 <dmwit> Uniform interfaces are good HCI.
21:02:57 <ubsan> -Wunused-variable
21:03:01 <dmwit> Why invent a new interface when the old one is already familiar?
21:03:02 <dramforever> ubsan: It's hard to get nick autocompleete to work all the time in a 1500-user channel
21:03:11 <dramforever> dmwit: Looking at you, -O and -O2
21:03:18 <dmwit> dramforever: Configure your client to prefer recent speakers.
21:03:21 <ubsan> dramforever: just teasing :)
21:03:24 <dmwit> Most of the 1500 users never talk.
21:04:36 <dmwit> monochrom: I very much like "Every inexplicable problem is caused by something you don't think is the cause.".
21:05:12 <dramforever> dmwit: I didn't know it was a thing. Thanks
21:05:32 <lubricy> @pl map
21:05:32 <lambdabot> map
21:05:40 <dmwit> ?unpl map
21:05:41 <lambdabot> map
21:05:44 <dmwit> pfft
21:05:54 <monochrom> thallada: If you use 0-based indexing instead of 1-based indexing, you don't have to add 1.
21:06:07 <monochrom> heh dmwit
21:06:17 <lubricy> hi guys
21:06:26 <dmwit> hi lubricy
21:06:27 <lubricy> new to this IRC thing
21:06:29 <dramforever> hi
21:06:48 <dramforever> To talk privately to lambdabot, use this command: /query lambdabot 
21:06:55 <Axman6> Welcome to multiplayer notepad!
21:07:12 <todaystomorrow> I love mutliuser vim
21:07:31 <Axman6> it's probably more like multiplayer ed
21:09:00 <ubsan> Axman6: ... I really want to build this now
21:09:07 <dramforever> Twitch exits vim
21:10:05 <Axman6> Hard mode: Twitch exits Emacs
21:10:29 <MP2E> haha
21:10:46 <Maxdamantus> If you press ctrl-c in vim it tells you how to exit.
21:10:55 * Maxdamantus suspects that won't work in emacs.
21:11:19 <dramforever> C-c C-c is undefined
21:11:31 <Axman6> it'll just sit there and eventually say "Well? I'm waiting? what do you want from me!"
21:11:59 <monochrom> No, your laptop battery dies first.
21:45:37 <zipper> You guys do unsafePerformIO a lot? I keep doing it nowadays.
21:54:20 <peddie> zipper: not sure I've ever used it myself, maybe a few times with the FFI
21:54:21 <MarcelineVQ> I've never been able to use it. Mostly due to this line in it's docs "For this to be safe, the IO computation should be free of side effects and independent of its environment." I've never used an IO compution that actually did work that met that crieria
22:04:54 <zipper> MarcelineVQ: In my case I wanted to get a random element in a JSON array while parsing JSON.
22:05:07 <zipper> So it was already in a monad that was not IO
22:05:36 <zipper> Unless I could transfrom the IO monad into the Parser Monad which I don't know how to.
22:06:07 <MarcelineVQ> liftIO possibly, not sure without seeing it
22:07:32 <zipper> MarcelineVQ: https://github.com/nairobilug/nairobi-bot/blob/master/src/Bot/Types.hs#L119 
22:07:37 <zipper> I'll try that
22:08:15 <zipper> :t liftIO
22:08:17 <lambdabot> MonadIO m => IO a -> m a
22:08:26 <zipper> hmmm
22:12:08 <zipper> Where is it defined https://hackage.haskell.org/package/transformers-0.5.2.0/docs/Control-Monad-IO-Class.html#v:liftIO ?
22:12:14 <zipper> Can't find it there
22:12:19 <zipper> :i liftIO
22:13:29 <zipper> Seems to have been removed from newer versions of transformers
22:13:46 <MarcelineVQ> http://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Monad-IO-Class.html
22:14:40 <zipper> MarcelineVQ: Thanks
22:17:45 <MarcelineVQ> likel it doesn't have a MonadIO instance anyway but it's good to be aware of liftIO
22:17:49 <MarcelineVQ> *likely
22:18:13 <zipper> hmmmm "No instance for MonadIO aeson-0.11.3.0:Data.Aeson.Types.Internal.Parser" I wonder how other people do it
22:19:11 <MarcelineVQ> what is the reason for the random selection btw?
22:46:07 <dmwit> zipper: I think other people don't do it. But if you really need to do it, you could consider parameterizing your type. While parsing, put in `()`s where you want random bits. Then afterwards...
22:46:28 <dmwit> :t traverse (\() -> randomRIO (0, 10))
22:46:30 <lambdabot> (Random b, Traversable t, Num b) => t () -> IO (t b)
22:46:59 <dmwit> Or put in whatever data you would use to pick a random number and use it inside the function you pass to `traverse`, of course.
22:49:34 <zipper> MarcelineVQ: I want to select a random gif out of a list of gifs
22:49:54 <zipper> So that say request for a cat gif twice doesn't give you the same cat
22:50:09 <zipper> MarcelineVQ: Not something like landing aeroplanes :)
22:50:28 <zipper> dmwit: Thanks
22:50:29 <geekosaur> nevertheless, you need something you can't get from a FromJSON instance
22:50:42 <zipper> geekosaur: Yes
22:51:04 <geekosaur> tbh, it seems to me you'd generate the structure with an object map, and let a postprocessing step do the random pick
22:51:32 <geekosaur> (well, I suppose object array)
22:51:52 <geekosaur> trying to do too much in one step is not necessarily wise anyway
22:51:57 <zipper> geekosaur: I see what you mean.
22:52:00 <MarcelineVQ> another option is to use parts of what you parse in a psudo-random (thus avoiding IO) fashion, creating a StdGen from the length of lst for example, and using next on it once for slightly better range. I wouldn't go that route because unless you're fetching many many gifs that number isn't an especially good seed though
22:52:16 <zipper> I should pick the random element at a step that is outside of the parsing
22:52:17 <geekosaur> ...and you may find you need to do that anyway (consider that you may need to ensure you pick a different one later)
22:52:25 <zipper> Leave the parsing to do just the parsing
22:52:26 <MarcelineVQ> If you don't want the same cat twice often the solution is so track the cats you've seen already
22:53:15 <zipper> MarcelineVQ: You mean introduce state?
22:54:48 <MarcelineVQ> Yeah, though whether that's the reasonable route depends a lot on your use case
22:57:38 <zipper> MarcelineVQ: naaah one time a person wants a cat gif
22:57:39 <zipper> Another wants a cats gif
22:57:52 <zipper> It would be hard to track all the search words
22:57:56 <zipper> and associate them
23:00:32 <osa1> does anyone know a functional queue library that implements this: `data Queue a = Queue { _front :: [a], _back :: [a] }` I need a functional queue implementation but surprisingly I can't find it on Hackage. should I use Data.Sequence (finger tree) instead?
23:01:32 <ubsan> osa1: https://hackage.haskell.org/package/dequeue-0.1.12/docs/Data-Dequeue.html ?
23:01:43 <ezyang> osa1: Well, if you need it fast, this queue is really easy to implement ;) 
23:01:54 <MarcelineVQ> ezyang, osa1: fun too!
23:02:22 <ubsan> I may be misunderstanding your problem
23:02:22 <ezyang> ubsan's link is for the fancy version 
23:02:39 <ezyang> (also in Okasaki) 
23:03:23 <monochrom> TChan does the front-list-and-back-list too.
23:03:56 <osa1> monochrom: you mean stm? I need a pure one
23:04:06 <monochrom> True.
23:04:25 <osa1> anyway, I already implemented it, takes just a couple of lines to implement push and pop but I'd rather just import it if possible.
23:06:40 <monochrom> I just did http://hackage.haskell.org/packages/search?terms=queue and I think no one has ever uploaded this simple thing.
23:07:06 <monochrom> Everyone has to aim high when releasing a package, eh?
23:09:35 <osa1> heh well if anyone needs it https://gist.github.com/osa1/6427742c411bb53d6894f564e3fde4dd
23:24:00 <zipper> I really need to read on pipes :(
