00:00:04 <jvliwanag> perfect. got this! thanks dramforever. haha, still have to figure out some haskell syntax. but got the gist. thanks again!
00:00:55 <dramforever> You're welcome
01:34:59 <solrize> how do the cool kids install haskell these days?  i.e. with stack, or some other way?
01:38:15 <lassulus> imho is nix the coolest way
01:38:45 <Axman6> I generally just use stack
01:39:34 <merijn> I just install GHC binaries + cabal
01:39:41 <merijn> So, the cool kids don't agree :p
01:44:48 <cocreature> I do both!
01:44:52 <merijn> Anyone reasonably familiar with criterion? I need to do some cleanup after some benchmarks which shouldn't be included in the timing, but I can't seem to find any functionality for that? There seems to only be functionality for explicit initialisation/setup
01:44:56 <cocreature> does that mean I am twice as cool?
01:48:33 <abbe> hi
01:48:41 <bollu> abbe: hello
01:48:57 <abbe> hi bollu!
01:49:03 <abbe> is it possible to generate a import statement using Template Haskell ?
01:49:18 <merijn> I think so?
01:49:21 <cocreature> merijn: afaik criterion does not support cleanups
01:49:40 <abbe> trying to output an AppE for a function which is not present in the scope
01:49:42 <merijn> That seems like a rather annoying flaw...
01:50:39 <cocreature> abbe: afaik you can’t do imports/exports, see https://ghc.haskell.org/trac/ghc/ticket/1475
01:50:43 <merijn> cocreature: Any tricks I can use to prevent something being GCed until after some other expression finishes evaluating?
01:50:48 <cocreature> in general doing module level stuff is hard
01:50:57 <cocreature> or impossible in th
01:51:19 <Wizek_> When I use `stack ghci` there seems to be duplicate effort going on behind the scenes: It first seems to build and link the whole project and produce an executable, and only afterwards starts to load the source files into GHCi. Can I somehow make stack 1.1.2 skip the first step? (since it takes up about 180 seconds)
01:51:33 <MarcelineVQ> merijn: that's the purpose of env afaik
01:51:35 <bollu> merijn: do you have a raw C reference through the FFI?
01:51:43 <MarcelineVQ> that last thing you said I mean, not the cleanup
01:52:11 <merijn> MarcelineVQ: No, because env forces things to be GCed by the end of the benchmark
01:52:20 <abbe> oh! thanks, cocreature 
01:52:25 <merijn> MarcelineVQ: Which is not the same as forcing something to NOT be GCed until the end of the benchmark
01:52:37 <merijn> MarcelineVQ: i.e., nothing stops end from GCing earlier
01:52:59 <merijn> bollu: No, just haskell values, but have to ensure GHC optimiser doesn't outsmart my benchmark...
01:53:01 <cocreature> merijn: sry I don’t know of a nice way to achieve that
01:53:05 <MarcelineVQ> it doesn't persist over a group?
01:53:53 <merijn> MarcelineVQ: I don't know exactly what it's doing
01:54:02 <cocreature> it should persist over a group I think
01:54:15 <merijn> I'm not even sure that's what I want...
01:55:26 <MarcelineVQ> hmm, that aside then could you get what you want by using defaultMain with just the bench you're after and do your init/cleanup before and after? it's IO () so unless it says otherwise you should be able to use it more than once
01:58:34 <merijn> MarcelineVQ: I suppose, but that means writing a ton of individual defaultMain's and I don't think I can actually get comparison graphs that way?
02:02:25 <MarcelineVQ> ah does criterion do graphs? I've only used it for the printed summaries it does
02:02:41 <merijn> MarcelineVQ: Yes, very fancy interactive HTML graphs
02:03:24 <merijn> MarcelineVQ: Like this: http://www.serpentine.com/criterion/report.html
02:03:30 <MarcelineVQ> then it's a shame that's not a major tagline in the haddocks
02:03:59 <merijn> MarcelineVQ: Really? That's like main feature causing me to hear about Criterion...
02:04:17 <MarcelineVQ> it could be that I'm just not seeing it, that's not uncommon
02:04:20 <merijn> And a pretty big link on the actual homepage with docs :)
02:04:51 <merijn> MarcelineVQ: And the haddocks do link to it in the README :p
02:23:08 <merijn> hmmm
02:23:22 <merijn> GHC is segfaulting, that's...suspicious and worrying
02:24:19 <merijn> Or, at least exit-failure...
02:30:03 <merijn> Any clues what's going on here? https://gist.github.com/merijn/60cd1cc3b8b1e0de6d759167f71280be
02:34:00 <tsahyt> @hoogle Double -> Float
02:34:03 <lambdabot> Extra floatToDouble :: Float -> Double
02:34:03 <lambdabot> Numeric.Extra floatToDouble :: Float -> Double
02:34:03 <lambdabot> Llvm.Types widenFp :: Float -> Double
02:34:15 <cocreature> tsahyt: you’re looking for realToFrac
02:34:17 <merijn> tsahyt: You probably want realToFrac
02:34:20 <tsahyt> thanks!
02:37:03 <Ford_Prefect> I'm pretty sure this is a common question, but is there a simple way to override genericParseJSON from Aeson to also deal with a default value for a missing field?
02:41:58 <Ford_Prefect> My terrible solution atm looks like this ... https://hastebin.com/ixeruyexap.hs
02:42:47 <tsahyt> what function is used for float literals?
02:43:25 <tsahyt> floating point literals I should say, not necessarily float
02:43:32 <opqdonut> > Similarly, a floating literal stands for an application of fromRational to a value of type Rational
02:43:35 <lambdabot>  <hint>:1:10: error: parse error on input ‘,’
02:43:35 <opqdonut> https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1360006.4.1
02:43:40 <merijn> tsahyt: fromRational
02:44:03 <tsahyt> so if I implement fromRational for a type I'll be able to create values of it from a literal then, just like with fromInteger?
02:44:42 <merijn> tsahyt: If you make it an instance of Fractional, yes
02:44:49 <tsahyt> good, thanks!
02:45:39 <merijn> As evidenced by
02:45:41 <merijn> :t 0.2
02:45:44 <lambdabot> Fractional t => t
02:45:50 <tsahyt> oh right, I could have just tried that
02:48:15 <tsahyt> wonderful, my new FRP/JACK design for a simple sine generator is down to about 1% CPU usage. the old one was at about 40%. that looks much more manageable
02:49:16 <tsahyt> instead of having the FRP network calculate every sample from a tick stream, I generate a wave function on GUI changes, and share that with the jack process callback. the improvement is staggering
02:49:34 <tsahyt> I did not expect FRP to have that much overhead, but I guess at 44100 polls per second, it adds up
02:49:44 <merijn> tsahyt: Are you familiar with push/pull FRP? :)
02:50:21 <tsahyt> sort of, yeah. I'm pretty new to FRP in general. I've played around with wires last year and made an asteroids clone. this now is implemented using reactive-banana
02:50:40 <tsahyt> I actually tried wires with the more direct approach too, but the results were just as bad.
02:51:20 <tsahyt> but with this now, it works well I think. Instead of having time-varying samples, I have time varying functions varying over time and do the actual evaluation of them outside of FRP
02:51:21 <merijn> tsahyt: Conal's paper on push-pull FRP is rather readable and enlightening
02:51:32 <tsahyt> I did read it
02:51:46 <merijn> ah, ok :)
02:52:15 <merijn> But yeah, pollin 44100 per second is rather intensive. Are you trying to do interactive audio or just audio in general?
02:52:21 <tsahyt> interactive audio
02:52:41 <tsahyt> Eventually I want to write an analog compressor emulation, but I thought I might as well try real-time sound generation while I'm at it
02:53:11 <tsahyt> with this design now it seems like haskell should be well capable of it performance-wise, and I still get to use FRP intensively in the process
02:53:32 <janos> hey, does somebody now if there exists somewhere an extension for the search bar in browsers which supports hoogle?
02:53:46 <Axman6> duck duck go does
02:53:51 <merijn> interactive audio should be doable, with careful programming and some GC tweaking soft realtime is certainly doable, but it'll be tricky
02:54:04 <merijn> janos: Depending on your browser you can just configure it?
02:54:12 <tsahyt> basically I've defined newtype Wave = Wave { runWave :: Time -> Sample }, and this is the type that I'm manipulating in the FRP network. I share it with the JACK callback function in a rather ugly but fast way (IORef), and there it just gets evaluated on the tick stream as JACK requests. Works nicely so far
02:54:14 <merijn> janos: i.e. I have Chrome set up to search hoogle
02:54:24 <tsahyt> but with those small examples, the GC is also not an issue yet
02:54:49 <lyxia> Ford_Prefect: I don't know of a better solution. HM.alter may make your code a bit less repetitive.
02:55:02 <janos> merijn: ok, firefox redirected me to their store for additional search. OK thanks, I'll look into it :)
02:55:07 <tsahyt> we'll see how that develops. I've been thinking about manually invoking GC at opportune times, like right after the jack callback succeeded.
02:55:24 <merijn> janos: Pretty sure firefox lets you do custom search *somehow*, just don't ask me how :)
02:55:30 <cocreature> janos: you can just rightclick in the search field and click on “Add a keyword for this search”
02:55:32 <tsahyt> merijn: I also don't mind the occassional glitch though, that's alright, as long as it doesn't just stop for a second or so
02:55:49 <janos> merijn: I'll look into that :)
02:55:57 <janos> cocreature: you mean the hoogle search field?
02:56:02 <cocreature> janos: yep
02:56:21 <cocreature> then you can configure something like "ho" as the keywoard and when you type "ho searchterm" in the addressbar it will search in hoogle
02:56:42 <Ford_Prefect> lyxia: that is nicer indeed
02:56:52 <janos> cocreature: AMAZING
02:56:58 <janos> cocreature: thanks :)
02:57:03 <cocreature> janos: yw :)
03:15:46 <atabiscuit> quick question from learn you a haskell
03:16:00 <JeKs> Hey guys. I learned some haskell and would like to know if you know any good resources for learning about types typeclasses and data types?
03:16:13 <atabiscuit> class YesNo a where
03:16:23 <atabiscuit>        yesno :: a -> Bool
03:16:44 <atabiscuit> instance YesNo Int where
03:16:50 <atabiscuit>      yesno 0 = False       
03:16:54 <atabiscuit>     yesno _ = True
03:17:11 <atabiscuit> For me, yesno 1 throws error
03:17:17 <atabiscuit> and so does yesno 1::Int
03:17:34 <atabiscuit> although this is verbatim from the book
03:17:44 <JeKs> Could you send how you try to use yesno?
03:17:58 <atabiscuit> yesno 1
03:18:02 <atabiscuit> ^ like this
03:18:21 <exio4> atabiscuit: yesno (1 :: Int)
03:19:01 <atabiscuit> woah
03:19:12 <atabiscuit> but why does " yesno 1::Int " not work?
03:19:31 <exio4> atabiscuit: yesno 1::Int is read as (yesno 1) :: Int
03:19:46 <atabiscuit> gotcha!
03:19:47 <atabiscuit> thanks
03:19:54 <exio4> atabiscuit: and yesno's type is :: YesNo a => a -> Bool -- after you "apply" the value of type a, you're saying Bool :: Int :p
03:20:08 <exio4> atabiscuit: (sorry, x :: Int where x is actually a Bool)
03:20:23 <JeKs> Is it also possible to say "yesno $ 1::Int" ?
03:21:11 <atabiscuit> no, same error as "yesno 1::Int"
03:21:34 <atabiscuit> i wonder why
03:22:41 <exio4> @type id $ 1 :: Int 
03:22:43 <lambdabot> Int
03:22:47 <exio4> seems to work :) 
03:22:59 <exio4> err, well, maybe I didn't use the best example
03:23:04 <exio4> @type length $ [1,2,3] :: [Int]
03:23:05 <lambdabot> error:
03:23:06 <lambdabot>     • Couldn't match expected type ‘[Int]’ with actual type ‘Int’
03:23:06 <lambdabot>     • In the expression: length $ [1, 2, 3] :: [Int]
03:23:23 <exio4> oh, whoops
03:24:40 <vaibhavsagar> what version of GHC is lambdabot running?
03:25:06 <tsahyt> looks like >= 8, judging from the bullet points in error messages
03:25:40 <tsahyt> > compilerVersion
03:25:43 <lambdabot>  error: Variable not in scope: compilerVersion
03:25:52 <tsahyt> > System.Info.compilerVersion
03:25:56 <lambdabot>  error:
03:25:56 <lambdabot>      Not in scope: ‘System.Info.compilerVersion’
03:25:56 <lambdabot>      No module named ‘System.Info’ is imported.
03:26:01 <Tuplanolla> @let import System.Info
03:26:05 <lambdabot>  Defined.
03:26:09 <tsahyt> oh that's how that works with lambdabot 
03:26:10 <Tuplanolla> > compilerVersion
03:26:13 <lambdabot>  Version {versionBranch = [8,0], versionTags = []}
03:26:41 <vaibhavsagar> nice!
03:26:59 <vaibhavsagar> > print __GLASGOW_HASKELL__
03:27:02 <lambdabot>  error:
03:27:02 <lambdabot>      • Found hole: __GLASGOW_HASKELL__ :: ()
03:27:02 <lambdabot>        Or perhaps ‘__GLASGOW_HASKELL__’ is mis-spelled, or not in scope
03:27:30 <vaibhavsagar> :(
03:33:40 <srhb> How does criterion fare as a http benchmarking tool? I imagine I can benchmark any IO action I want, but I'm not sure if it's a great idea. :-)
03:41:15 <tsahyt> how does applicative do work? every time I try it, I get an error about missing monad instance
03:43:45 <Axman6> tsahyt: you'll need to share some code if you want an answer to that question
03:47:04 <tsahyt> Axman6: http://sprunge.us/fIAi?haskell
03:47:32 <Tuplanolla> That's a `return`, tsahyt.
03:47:41 <tsahyt> Tuplanolla: which is used in the GHC manual
03:47:46 <tsahyt> in the applicative do section
03:47:56 <Tuplanolla> I thought you're supposed to use `pure`.
03:48:10 <tsahyt> I've tried pure, and I get the same error
03:48:26 <Tuplanolla> Huh.
03:48:44 <tsahyt> my thoughts exactly
03:48:45 <Axman6> I don't think ApplicativeDo removes the Monad constraint does it?
03:48:48 <merijn> Any help debugging what's going wrong here? https://gist.github.com/merijn/60cd1cc3b8b1e0de6d759167f71280be
03:49:06 <Axman6> it just rewrites it to use Applicative functions when it can
03:49:30 <tsahyt> Axman6: it doesn't work with pure either, so I think that's not it
03:49:34 <merijn> srhb: I think it'd work ok
03:50:10 <merijn> srhb: It's designed to be accurate for benchmarking really small amounts of work, so bigger stuff shouldn't be an issue
03:51:15 <srhb> merijn: Yeah, I couldn't see any theoretical issue with that, but you never know... :-)
03:51:51 <merijn> srhb: Considering most people just use, like, 'time' it should be fine :p
03:54:10 <tsahyt> okay this is really interesting. why will the module not load in ghci, but when I :set -XApplicativeDo, :t \a b -> do { a' <- a; b' <- b; return (sin a' * cos b') } gives me (Applicative f, Floating b) => f b -> f b -> f b
03:54:20 <tsahyt> it's almost like it ignores the pragma
03:55:22 <tsahyt> GHC 8.0.1 for the record
03:55:30 <merijn> tsahyt: Word of warning there's different commands for setting the pragmas for things ghci *loads* and what you type on the prompt
03:56:16 <tsahyt> merijn: but I have {-# LANGUAGE ApplicativeDo #-} in my source file, and when I try to load it, I get an error about a missing monad constraint
03:56:30 <tsahyt> but :t gives me just what I'd expect
03:56:49 <merijn> tsahyt: Can you lpaste the code?
03:56:58 <Tuplanolla> He just did, merijn.
03:57:04 <tsahyt> not lpaste, but I've already got it there http://sprunge.us/fIAi?haskell
03:57:37 <merijn> hmmm
03:57:52 <merijn> that's odd
03:58:31 <tsahyt> I could try with 8.0.2 I suppose
03:59:15 <tsahyt> it also doesn't work with 7.10.3
03:59:39 <merijn> Well 7.10 doesn't have ApplicativeDo...
04:00:07 <merijn> So that seems rather obvious :p
04:02:57 <tsahyt> interestingly enough it doesn't complain about unknown pragma though
04:03:02 <lyxia> tsahyt: it compiles if you type return (sin a' * cos b') instead of return $ sin a' * cos a'
04:03:33 <tsahyt> huh
04:03:35 <tsahyt> it does indeed, thanks
04:03:38 <tsahyt> that's odd too though
04:03:54 <Tuplanolla> That's worrisome.
04:04:24 <merijn> Tuplanolla: I'm guessing the desugarer can't peer *through* ($)
04:05:06 <tsahyt> I wonder if that's documented anywhere or should be classified as a bug
04:06:16 * merijn sighs
04:06:54 <merijn> If I build math-functions separately everything works. Built it as dependency of criterion -> compile error :\
04:07:17 <merijn> Or rather, not a compile error, but GHC crash
04:10:24 <tsahyt> after looking through the bug tracker it seems to be a known problem
04:10:27 <tsahyt> marked as fixed too
04:12:15 <tsahyt> and it compiles with 8.0.2. good
04:14:46 <Gurkenglas> Where can I compile/execute Haskell code online and import Control.Monad.State? (bonus points for Control.Lens)
04:14:54 <Gurkenglas> (lambdabot is too slow in the output)
04:15:05 <Gurkenglas> (as in, too few lines per second)
04:16:13 <tsahyt> are let bindings not allowed in ApplicativeDo?
04:17:01 <hpc> quite likely
04:17:22 <tsahyt> well, still an improvement over literring everything with <$> and <*> or liftAs
04:18:41 <merijn> Gurkenglas: For what purpose?
04:18:54 <merijn> Gurkenglas: i.e., what's preventing you from doing it locally?
04:19:30 <Shoue> Gurkenglas, Cloud9 maybe?
04:19:44 <Gurkenglas> merijn, I'm at university and I don't have admin privileges and different computers here have different systems
04:20:23 <Rodenbach> Does the composition operator (.) bind stronger than parens?
04:20:59 <opqdonut> Rodenbach: what does binding stronger than parens even mean?
04:21:18 <merijn> Gurkenglas: Simplest solution would be to get a VPS if you can spare the cash
04:21:39 <merijn> Gurkenglas: $5 a month gets you a pretty decent VPS, if you're desperate you can get even cheaper
04:22:03 <merijn> Gurkenglas: Then you can install whatever the hell you want
04:22:21 <merijn> Gurkenglas: Incidentally, if it's a *nix system it's pretty trivial to install GHC as unprivileged user
04:22:55 <merijn> Just grab the binary distribution of GHC and follow the instructions
04:23:27 <Rodenbach> opqdonut: first the argument to the right of the  .  is evaluated.
04:23:40 <Rodenbach> Though in a pure environment this most likely doesn’t make any difference.
04:24:17 <opqdonut> evaluating (f . g) x actually starts with evaluating f
04:24:21 <opqdonut> due to laziness
04:25:21 <merijn> Well, it starts with evaluating '.', tbh :p
04:26:21 <opqdonut> yeah
04:37:56 <vaibhavsagar> Gurkenglas, code.world?
04:38:12 <kakashiAL> a functor is an object that implements map, so in javascript Array is an functor, because it has the map method
04:38:25 <kakashiAL> my question is what is an identity functor in javascript terms?
04:39:03 <merijn> kakashiAL: What makes you think a functor has to be an object? And what is an object in this description?
04:39:45 <Gurkenglas> vaibhavsagar: Cant even helloworld :D "Variable not in scope: putStrLn :: Text -> t"
04:40:09 <kakashiAL> merijn: something that contains stuff (in very simple terms)
04:40:20 <merijn> kakashiAL: Plenty of functors don't "contain" stuff
04:40:27 <merijn> kakashiAL: For example, functions are functors
04:40:31 <vaibhavsagar> Gurkenglas, try https://code.world/haskell
04:40:58 <kakashiAL> merijn: could we take the (naive) definition that a functor is an object that implements map=
04:41:02 <kakashiAL> ?
04:41:40 <Gurkenglas> Works :D Control.Monad.State is even already imported - no lens tho. Thx
04:41:40 <merijn> kakashiAL: That depends on what "object" means
04:41:56 <merijn> But, probably not in any sensible way
04:42:30 <vaibhavsagar> Can I download a package from github in a stack script?
04:43:38 <jaspervdj> vaibhavsagar: stack configurations aren't really "scripts", but yeah you can put a git repository in there
04:44:15 <kakashiAL> merijn: [1, 2, 3].map(element => element * 2)  <--this will return [2, 4, 6] in this case the array is a functor because it implements map, so what is an identity functor in this example?
04:44:39 <vaibhavsagar> I mean in the sense of https://docs.haskellstack.org/en/stable/GUIDE/#script-interpreter, jaspervdj
04:44:40 <merijn> kakashiAL: There is no meaningful way to express the identity functor in JS, afaik
04:45:24 <merijn> Am I right in understanding that criterion's 'env' will share the environment it produces across multiple runs of the benchmark?
04:45:33 <vaibhavsagar> I have this project that relies on another project, and it could be a single file stack 'script' except for the dependency on my other project, which is not on hackage
04:46:02 <kakashiAL> merijn: even if we just say that everything that implements map is a functor you cant say what a identy functor is?
04:46:09 <jaspervdj> vaibhavsagar: why not add the dependency in the stack.yaml then?
04:46:25 <vaibhavsagar> jaspervdj: I'd like it to be a single file
04:46:44 <vaibhavsagar> just wondering if that's possible
04:47:32 <kakashiAL> merijn: I GO IT NOW :)
04:47:39 <jaspervdj> I don't think there's a command line flag for that, which is what you'd need vaibhavsagar 
04:47:54 <kakashiAL> merijn: very simple in javascript terms :)
04:48:21 <vaibhavsagar> fair enough, thanks jaspervdj! Also thank you for Hakyll :)
04:48:37 <jaspervdj> vaibhavsagar: no worries, and thanks for using hakyll
04:50:29 <tfc> hey there. i have one haskell app which listens to network output and prints it to stdout. and then i have another haskell app which launches that other app, listens to its stdout and does magic (at first its just printing) with that output. however, during that stdout-stdin piping i have buffering problems. it reads a lot of output, than stops for several seconds and then continues. in the mean time, the first app closed (although it is not supposed
04:50:30 <tfc>  to close)
04:50:52 <tfc> it doesn't matter if i use conduit for stream printing or to hGetContents on a System.Process stdout handle.
04:51:41 <tfc> i read that this might have to do with laziness, but i don't know how to debug this. does anyone have an idea?
04:55:19 <jaspervdj> Well, the way I'd debug that is first test my assumptions on the first app (without using the second)
04:55:42 <jaspervdj> Then, if possible, test the assumptions on the second app.  Hopefully the issue is isolated to only one of the two.
04:56:19 <tfc> jaspervdj: i have similar problems when launching the first app like this: "./myhaskellapp1 | tee output.txt" --> then i have this same "reads a lot of data, suddenly stops for some seconds and app1 closes" problem.
04:57:48 <jaspervdj> So does myhaskellapp1 exit normally or does it throw an exception?  We'd have to see some source code to help you out further.
04:58:54 <tfc> jaspervdj: https://github.com/tfc/hamtsolo/blob/master/src/HamtSolo.hs it's this app. (sorry for the untidy code. i am quite a beginner still)
04:59:12 <tfc> there is no exception. it just seems that the app exits
05:00:43 <cocreature> tfc: and without tee it doesn’t stop in between?
05:00:51 <tfc> cocreature: exactly.
05:04:58 <Onemorenickname_> hello people
05:05:00 <Onemorenickname_> i'm new to haskell
05:05:14 <Onemorenickname_> i was wondering if i could have mutually recursive types without boxing them in a constructor
05:05:25 <tfc> cocreature jaspervdj: if i run mapM_ (`hSetBuffering` LineBuffering) [stdout, stderr] as first thing in main, then i get exactly the same behaviour without tee.
05:05:40 <Onemorenickname_> like this, but without GRAMMAR ( https://ghostbin.com/paste/wu8ek )
05:08:23 <tfc> cocreature jaspervdj: with "NoBuffering", my problem seems to be solved, with tee and with my other haskell app. but i am not sure if that is the right approach. any opinions?
05:08:50 <jaspervdj> tfc: If you are printing binary data (not line based) on stdout, you definitely want to set NoBuffering there
05:09:01 <jaspervdj> You probably don't need it on stderr, though
05:09:21 <tfc> it is basically line based. the content of all the streaming is linux kernel debug output from a development machine
05:09:40 <tfc> but with LineBuffering it's broken at the piping stage, as i described before.
05:09:41 <merijn> Or just hFlush after every crucial operation
05:10:53 <merijn> tfc: FYI, this isn't really haskell specific. Handles default to line-buffering for handles connected to a console and block buffered for handles connected to anything else (i.e., files, pipes, sockets, etc.)
05:11:11 <merijn> This is the exact same as in C
05:11:32 <tfc> merijn: i agree basically, but i did not have this problem with apps i wrote in C/python
05:12:00 <drninjabatman> Hello, Is there a way to make a type family TF so that for another type family TF1 I would have `TF (TF1 a) a = a` and `TF x a = Void` ?
05:12:21 <merijn> tfc: Which hGetContents are you using?
05:12:39 <tfc> merijn: in this case it is hGetLine
05:12:41 <merijn> tfc: String, (lazy) ByteString, or (lazy) Text
05:12:43 <drninjabatman> ghc complains with `Illegal type synonym family application in instance` which is reasonable but how do I get around that?
05:12:49 <tfc> merijn: that of ByteString
05:12:58 <merijn> tfc: Lazy or strict?
05:13:13 <tfc> merijn: is Data.ByteString.Char8 strict?
05:13:29 <merijn> Insert obligatory: Never use Char8
05:13:44 <tfc> ok. why?
05:14:22 <merijn> https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
05:14:24 <jaspervdj> tfc: Data.ByteString.Char8.pack drops data if you use non-ASCII characters
05:14:32 <tfc> jaspervdj: wow i see.
05:14:50 <merijn> jaspervdj: I've ranted about this so often that quchen saved me the effort and wrote it up for me :p
05:15:04 <jaspervdj> merijn: good link to have handy :-)
05:15:16 <tfc> merijn: lol i see. i had a lot of trouble with bytestring/string handling, so that part "evolved"
05:15:49 <merijn> tfc: Things become a lot clearer once you realise that the name "ByteString" is a historical accident/mistake and you should think of it as just "Bytes"
05:16:18 * quchen is MAAS (Merijnnotetaker as a service)
05:16:19 <tfc> i'm just studying that link. :)
05:16:31 <merijn> If you want/need (unicode) text, you do what you always do with bytes, you decode them using Data.Text.Encoding
05:16:50 <tfc> ok
05:17:09 <tfc> back to the strict/lazy thing. what am i actually using in my app if i imported Data.ByteString ?
05:17:18 <merijn> That's the strict one
05:17:20 <tfc> ok.
05:17:29 <merijn> Lazy comes from Data.ByteString.Lazy
05:17:41 <merijn> In which case you really shouldn't be seeing crazy latencies, tbh
05:19:13 <Onemorenickname_> hi people
05:19:27 <Onemorenickname_> i come from ocaml
05:20:02 <Onemorenickname_> in ocaml, through functors, I can make do something along the lines of "type t = Elt.t", and then using "t" in other types that otherwise should have been polymorphic
05:20:16 <Onemorenickname_> can i do something similar in haskell ?
05:20:56 <merijn> Onemorenickname_: Not really, Haskell doesn't really have something similar to ocaml functors.
05:20:57 <dramforever> type A = B
05:21:13 <Onemorenickname_> merijn, I see
05:21:19 <merijn> Onemorenickname_: You can sorta do something kinda similar using typeclasses and associated types, but it's not truly the same
05:21:20 <Onemorenickname_> what's the idiomatic way to do so then ?
05:21:20 <dramforever> ooh I guess I'm not really getting the 'should have been polymorphic' part
05:21:40 <merijn> Onemorenickname_: Well, that depends on what you're doing
05:22:07 <merijn> dramforever: Ocaml functors are more like ezyang's Backpack work, polymorphic modules
05:22:31 <dramforever> I guess I don't know ocaml so I'm not getting it
05:23:37 <Onemorenickname_> i want to make a parsing functor, which takes a type t that implements Eq and ToString (I don't know the Haskell names, just guessing here) and outputs a module parsing lists of t
05:24:00 <dramforever> Fantastic
05:24:13 <jaspervdj> Onemorenickname_: I think typeclasses are the idiomatic approach in this case
05:24:15 <merijn> dramforever: Well, you could, for example, define a "Set module" that is parameterised over a type and a comparator and then build a "Set" for a specific type and comparison
05:24:16 <dramforever> You would make a typeclass for that
05:24:26 <merijn> dramforever: Which is done with typeclasses in Haskell
05:24:38 <dramforever> but is more, well, 'module' in OCaml, right?
05:24:39 <merijn> But typeclasses don't subsume all usecases of ocaml functors
05:24:55 <Onemorenickname_> jaspervdj, i'm trying to make a type class, but I can not define types in typeclass, solely variables
05:25:15 <hodapp> can't define types in a typeclass?
05:25:19 <dramforever> I fail to see why you need to define variables
05:25:23 <dramforever> s/variables/types
05:25:31 <Onemorenickname_> i'm trying to do something along the line of https://ghostbin.com/paste/68o5w
05:32:28 <jaspervdj> Onemorenickname_: I don't think you need to define types in the typeclass.  In fact, it it's only Eq and ToString (Show) that you need, you can use existing typeclasses.
05:32:29 <dramforever> Onemorenickname_: I think you would do something like:
05:32:29 <jaspervdj> Onemorenickname_: You'd need to add `t` to the types you have.  E.g.: `data Letter t = T t | NT Grammar`
05:32:29 <merijn> Onemorenickname_: You'd define those type separately from the typeclasses and then merely define, say, "parse :: (Eq a, ToString a) => String -> Grammar a
05:32:29 <dramforever> class Parsable a where ...
05:32:29 <Onemorenickname_> so i have to make all the types polymorphic ?
05:32:29 <Onemorenickname_> ngh
05:32:29 <merijn> Onemorenickname_: You'd have to propagate the type variable from Letter up through grammar, though
05:32:29 <Onemorenickname_> merijn, that's what pities me
05:32:29 <dramforever> Then you have
05:32:30 <dramforever> instance Parsable a => Parsable [a] where ...
05:32:30 <merijn> Onemorenickname_: What's the problem with that?
05:32:30 <Onemorenickname_> merjin, it's more complicated than what i'm use to write
05:32:30 <dramforever> 'It's nothing like what I used to do in OCaml' is a valid but weak problem...
05:32:30 <dramforever> Onemorenickname_: polymorphism isn't really complicated, don't be afraid
05:32:30 <Onemorenickname_> dramforever, i come to haskell because there are some things that are /much/ simpler here
05:32:30 <Onemorenickname_> like, default lazyness
05:32:30 <Onemorenickname_> but with polymorphism, i have to add the type parameter in every function, and everything using these types
05:32:30 <Onemorenickname_> so be it
05:32:30 <dramforever> Uh
05:32:30 <merijn> dramforever: I don't think people coming from ocaml are afraid of polymorphism :p
05:32:30 <dramforever> Onemorenickname_: maybe type inference can help?
05:32:30 <dramforever> Sorry I don't think I know what you want... I don't know OCaml
05:32:30 <Onemorenickname_> dramforever, type inference is not kind with debugging and clean code
05:32:30 <merijn> dramforever: The problem is that, essentially, ocaml functors let you have "locally scoped" data types
05:32:30 <Onemorenickname_> merijn, you expressed that perfectly
05:32:30 <Onemorenickname_> "locally scoped datatypes" is what i want
05:32:30 <jaspervdj> Yeah, Haskell requires more typing.  It is idiomatic to add the constraints to every top-level function.
05:32:31 <Onemorenickname_> (as in coq)
05:32:31 <dramforever> Associated types?
05:32:31 <merijn> dramforever: And Haskell doesn't let you have that and there's no real way around that :)
05:32:31 <merijn> dramforever: Nope, those are still "global"
05:32:31 <dramforever> Yeah...
05:32:31 <merijn> dramforever: Associated types are visible outside their class
05:32:31 <dramforever> Screw it
05:32:32 <Onemorenickname_> what
05:32:32 <dramforever> Just make these global
05:32:32 <Onemorenickname_> why so many people are coming at once ?
05:32:32 <jaspervdj> For example, almost all definitions in Data.Set start with: `Ord a =>`
05:32:38 <dramforever> It's not like they could change other code or something
05:32:38 <merijn> Onemorenickname_: tbh, for #haskell this is rather quiet ;)
05:32:39 <hodapp> jaspervdj: is this one thing backpacks are meant to handle?
05:32:39 <dramforever> Onemorenickname_: ~1600 people
05:32:40 <Onemorenickname_> merijn, when you say "there is no way around that", you mean it's not idiomatic, or there is really no way around ?
05:32:40 <jaspervdj> hodapp: not really
05:32:40 <merijn> Onemorenickname_: I mean there's no notion of "local data type" in Haskell beyond "defined in module A and not exported"
05:32:40 <jaspervdj> hodapp: backpack would come in if you had multiple implementations of `Set`, for example one based on 2-3 trees and one based on red-black trees
05:32:40 <dramforever> Heck
05:32:46 <Onemorenickname_> I see
05:32:55 <dramforever> Why are these global data types bad?
05:33:07 <merijn> Onemorenickname_: The "work around" in, for example, your case is making it more polymorphic
05:33:09 <dramforever> I'm not saying these aren't... I'm just not really getting it
05:33:22 <merijn> dramforever: Who said bad? It's just not quite as convenient
05:33:54 <merijn> dramforever: Imagine Haskell, but without where-clauses, does it fundamentally limit you? No. Is it kinda annoying when you're used to where-clauses? Yes.
05:34:11 <dramforever> Oh that kind of convenient
05:34:16 <merijn> dramforever: Actually, better argument
05:34:24 <merijn> dramforever: Imagine you could define datatypes in where clauses...
05:34:43 <merijn> Because that's basically what this boils down too
05:34:51 <Onemorenickname_> merijn, this is not possible either ?
05:34:56 <merijn> Onemorenickname_: No
05:34:56 <Onemorenickname_> i was writing that
05:35:11 <dramforever> No, Haskell is a horrible language
05:35:13 <Onemorenickname_> that's why i was wondering about locally scoped type
05:35:13 <merijn> Onemorenickname_: Have you seen the Gentle Introduction?
05:35:21 <merijn> @where gentle
05:35:21 <lambdabot> http://www.haskell.org/tutorial/
05:35:51 <merijn> Onemorenickname_: That one was written as intro for existing functional programmers (hence, why it lost popularity, it's not very readable if all you know is python)
05:35:59 <Onemorenickname_> i see
05:36:03 <Onemorenickname_> i will read it then
05:36:12 <merijn> Onemorenickname_: But that's aimed at experienced SML (so, close enough for ocaml) programmers as a quickstart to Haskell
05:36:16 <Onemorenickname_> i felt like every tutorial i came across was made for people new to programmation
05:36:45 <Onemorenickname_> thanks :)
05:37:27 <merijn> Onemorenickname_: For experienced ocaml programmers I would probably recommend: Gentle Intro first, then after that, just read the Haskell 2010 Report
05:37:47 <merijn> That's probably a lot more readable and useful
05:38:38 <dramforever> Onemorenickname_: You said default laziness was great
05:38:49 <dramforever> Not many non-Haskellers say that
05:38:56 <merijn> dramforever: I do
05:38:59 <Onemorenickname_> dramforever, for what I need, it is indeed great
05:39:07 <dramforever> merijn: You're a non-Haskeller?
05:39:13 <dramforever> Wow
05:39:21 <merijn> dramforever: Oh, wait, no. Although...technically, I suppose...
05:39:37 <merijn> dramforever: I mostly write C++ and bash, so... :p
05:39:55 <Onemorenickname_> without default-lazyness, if i kept going in ocaml, i would have had to make my own fix-point combinators
05:40:05 <Onemorenickname_> or switch every types to lazy.t
05:40:20 <Onemorenickname_> (not going to happen)
05:40:44 <dramforever> Onemorenickname_: And if every tutorial assumed that one is comfortable with 'fix-point combinators' or 'lazy.t', Haskell would have been long dead by now
05:41:00 <merijn> dramforever: To be fair, for a long time that was true
05:41:06 <merijn> Hence why we have this quote
05:41:12 <merijn> @quote Brend gentle.intro
05:41:12 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
05:41:45 <dramforever> a gentle push onto the Himalayas
05:42:04 <Onemorenickname_> i am conscious that the gentle introduction requires previous knowledge
05:42:16 <Onemorenickname_> but so far, despite the prerequisite, it is very clear and concise
05:42:32 <dramforever> It just CAN'T possibly work if you're not already on a helicopter with parachutes
05:43:21 <Onemorenickname_> Haskell permits nested comments
05:43:27 <Onemorenickname_> another great language :D
05:45:51 <Onemorenickname_> "The way ":" is defined here is actually legal syntax---infix constructors are permitted in data declarations, and are distinguished from infix operators (for pattern-matching purposes)"
05:46:00 <Onemorenickname_> So far, it looked perfect
05:46:07 <Onemorenickname_> until " by the fact that they must begin with a ":" "
05:46:09 <leafgreen> is anyone knowledgeable about cabal sandboxes?
05:46:30 <merijn> leafgreen: A little?
05:46:38 <dramforever> Onemorenickname_: 'Upper-case infix operators'
05:47:30 <Onemorenickname_> dramforever, ?
05:47:34 <leafgreen> I'm trying to set up a relocatable sandbox with all of a program's dependency source, so it can be built without an internet connection as long as it has the base cabal, cabal-install, and ghc installations
05:47:48 <dramforever> Onemorenickname_: You see, constructor names have to be upper-case
05:47:58 <dramforever> @let data A = X -- ok
05:48:01 <lambdabot>  Defined.
05:48:04 <dramforever> @let data B = y -- not ok
05:48:04 <lambdabot>  Parse failed: Illegal data/newtype declaration
05:48:23 <leafgreen> it seems like I can do this pretty well by building all dependencies in a sandbox but that includes the binaries. If I remove the binaries it fails to build
05:48:30 <Onemorenickname_> dramforever, i've noticed so far, but what do you mean ?
05:48:55 <dramforever> This rule has to somehow apply to infix operators as well
05:49:08 <dramforever> So there we go, colon means upper-case
05:49:39 <Onemorenickname_> haha
05:49:49 <Onemorenickname_> (i don't like such rules embedded in grammar)
05:50:45 <dramforever> OCaml somehow doesn't have this problem?
05:51:28 <Onemorenickname_> dramforever, ha ha, you don't have infix constructor in ocaml
05:51:53 <dramforever> heh
05:51:59 <merijn> Also, ocaml annotates type variables, so you don't have to distinguish type constructors
05:52:20 <Onemorenickname_> (nice thing imho)
05:53:27 <dramforever> :t (.) -- Extremely & surprisingly commonly used function
05:53:31 <lambdabot> (b -> c) -> (a -> b) -> a -> c
05:53:40 <dramforever> That's going to have a whopping 6 ticks :)
05:56:25 <Onemorenickname_> pointfree code, here i cooome
05:57:00 <Prutheus> Hello! I have an hakyll question: I wanna make a dynamic menu bar, wehre the page i am on is currently highlighted. I have this: »$if (title == "News")$class="active">$endif$« ... but for some reason this is not working, my page has no content now ... anyone an idea what i did wrong or how i could realize my idea?
06:02:04 <leafgreen> To put another way what I'm asking, what paths and files can I remove from a sandbox without breaking its ability to be compiled?
06:02:25 <leafgreen> supposing I want to make it as small as possible but don't care about recompilation time
06:33:05 <hexagoxel> leafgreen: don't you want to safe the results of `cabal fetch` instead of anything in the sandbox? i mean if recompilation times don't matter..
06:33:13 <hexagoxel> *save
06:33:27 <leafgreen> Maybe I do. I don't really know what I'm doing here.
06:34:09 <leafgreen> The issue is that this needs to become a tarball that someone could unpack on a computer with: ghc, Cabal, and cabal-install, no other packages, and no internet.
06:34:21 <leafgreen> Also no root access.
06:34:46 <merijn> leafgreen: You'd be better of just creating a tar ball of all the relevant dependencies?
06:34:57 <merijn> You can point cabal to local package repos, afaik
06:35:18 <leafgreen> I'm just not sure how to do that.
06:35:39 <leafgreen> Keeping in mind the user won't be able to do anything outside of their home directory
06:36:05 <merijn> Step 1) Find the transitive dependencies for the package Step 2) download all those packages Step 3) figure out how to point cabal at those
06:37:12 <cocreature> does it need to be in a single directory? otherwise just copying ~/.cabal/packages might work
06:40:03 <leafgreen> hm but that directory is huge...
06:40:43 <leafgreen> I'm glad you pointed that out though. I've just tested that nuking the ~/.cabal/packages directory and rebuilding the sandbox still works.
06:43:48 <agis> Hey guys! Quick, noob question
06:44:25 <hexagoxel> leafgreen: cabal's config has 'local-repo' key. that might be a more proper solution that copying ~/.cabal/packages/
06:44:49 <agis> I am working on my bachelor thesis, which is (hopefully) going to be a module in Haskell, but I am not sure on how to do the formal design
06:45:12 <agis> Other tools (i.e UML) feel kind of awkward in functional programming
06:46:13 <agis> Is there a proper, native to fp tool to design haskell software?
06:46:28 <cocreature> agis: you could see type signatures as some sort of formal design. diagrams such as UML are not really used for haskell
06:47:08 <tdammers> agis: yes. it's called Haskell.
06:47:22 <tdammers> and I'm only half kidding here
06:47:40 <tdammers> Haskell itself, particularly the type system, is a very decent tool to aid software design
06:48:12 <Tuplanolla> Occasionally designs are built on top of systems borrowed from mathematics, agis.
06:48:37 <jgertm> how do i filter a Map when using mono-traversable?
06:48:41 <tdammers> other than that, it's rather common to see *laws* expressed in some sort of semi-formal superset of Haskell, borrowing some extra stuff from Math notation
06:48:41 <Logio> I'll second that, the abstract design part in Haskell is often figuring out and deciding the mathematical abstraction for your problem
06:48:53 <jgertm> do i always need to convert to and from the list-of-tuples representation?
06:49:53 <cocreature> jgertm: it’s still an ordinary map so Map.filter should work no?
06:50:22 <jgertm> cocreature: it certainly would, but that would lock me into a specific implementation
06:52:17 <agis> Ok, so I'll think from mathematics and I'll use type signatures as formal specification in the report. Thanks cocreature, tdammers, Tuplanolla and Logio!
06:52:51 <cocreature> agis: just make sure to discuss this with your advisor before you start :)
06:54:10 <agis> cocreature: Sure, I'll check with him but he's probably ok with it, I was just wondering if there was something more specific
06:54:36 <hexagoxel> Perhaps some functional-pearl papers can give some examples of how this law/abstraction "design" stage looks like.
06:56:21 <hexagoxel> (unfortunately i have no specific reference in mind)
06:58:56 <jle`> jgertm: mono-traversabl doesn't have any filtering for maps, but if you're looking for a generic filtering, you can also use witherable, which generalizes the 'filterable' pattern
07:00:56 <agis> hexagoxel: just checked a couple of papers and they use type signature, so it seems like the norm
07:03:39 <leafgreen> merijn hexagoxel - Thanks for your help.
07:04:21 <leafgreen> and cocreature 
07:05:37 <jgertm> jle`: thanks, witherable looks cool
07:07:48 <NANDgate> hello
07:07:57 <BernhardPosselt> how do i print a list of strings?
07:08:04 <BernhardPosselt> take 4 $ repeat "hello world"
07:08:06 <BernhardPosselt> for instance
07:09:44 <BernhardPosselt> in other languages id use a forEach
07:09:52 <tdammers> in Haskell you'd use map
07:09:54 <lieven> mapM_
07:09:59 <hexagoxel> forM_
07:10:07 <tdammers> except that map is pure, so you need mapM or mapM_
07:10:18 <BernhardPosselt> function names are sometimes truly horrible
07:10:33 <BernhardPosselt> i suppose the _ is the eager version?
07:10:48 <lieven> no, the throw away the result version
07:10:50 <orion> Technically, isn't mapM also pure?
07:11:01 <glguy> for_ 
07:11:13 <BernhardPosselt> i see :)
07:11:14 <BernhardPosselt> thanks
07:14:33 <abhiroop> Anybody here heard if Datomic in Clojure?
07:14:39 <abhiroop> *of
07:15:17 <hodapp> I've heard of it, yes
07:15:35 <tdammers> orion: of course, just like IO
07:16:02 <tdammers> BernhardPosselt: in an ideal universe, mapM would be called map
07:16:37 <tdammers> BernhardPosselt: but that name was already taken
07:17:39 <hodapp> thanks Obama.
07:17:40 <orion> tdammers: Right, so I don't know why you brought up the fact of map's purity.
07:18:57 <tdammers> orion: yes, I should have said "map isn't monadic"
07:19:05 <orion> :)
07:19:19 <tdammers> but even that is arguably false, because lists are monads too
07:20:08 <hexagoxel> thinking of for_ vs forM_ .. what versions of all the almost-duplicates created by the AMP should be used?
07:20:28 <tdammers> I guess time will tell
07:20:30 <Adeon> e
07:20:51 <tdammers> my head says "for_", but my heart types "forM_"
07:21:42 <barrucadu> I generally like using the weakest constraints for everything, which would mean the Applicative operations. But habit is hard to overcome.
07:23:06 <hexagoxel> are there cases where the Monad-constrained versions can be implemented more efficiently?
07:31:00 <Profpatsch> Do I want -XOverloadedStrings in ghci conf?
07:31:15 <Tuplanolla> Probably not.
07:31:24 <Profpatsch> In my experience I need explicit type signatures lots if I enable that.
07:31:31 <Tuplanolla> It can be annoying.
07:32:01 <Profpatsch> Hm, I think I’ll go with Protolude by default and use toS explicitely should the need arise.
07:32:24 <Profpatsch> Even though I kind of hate the default extreme overloading of Protolude’s show as well.
07:33:04 <Profpatsch> ghcid will probably read the ghci.conf as well.
07:33:19 <Profpatsch> So that might lead to reproducibility problems.
07:33:47 <Tuplanolla> You know there's `:set` and `:seti` for that.
07:34:08 <Profpatsch> I need to study ghci docs really.
07:34:38 <Tuplanolla> I've settled on these default extensions, but I don't have good reasons for all of them: http://tuplanolla.no-ip.org/tmp/.ghci-for-babies
07:36:18 <kubbe> hello! In a binary tree and I am supposed to label every "line" between the nodes and leafs with 0 or 1 depending on if it is going left or right. Is this possible with just a pair of guards?
07:38:18 <Tuplanolla> There should be a `-fharmless-extensions` flag.
07:41:05 <byorgey> kubbe: I doubt guards will help.  This sounds like a job for pattern matching.
07:43:13 <kubbe> Okey, yeah. Patterna matchning will work as well.. Like, I have a huffman tree. And at each leaf it should have counted if it went left, then 0. It is supposed to create a bitcode for each character in the tree
07:43:37 <kubbe> And insert this into a table holding [(char, bitcode)]
07:46:03 <merijn> Tuplanolla: Most ones are rather harmless
07:46:12 <merijn> Tuplanolla: Unless you consider confusion harmful, I suppose
07:53:13 <Tuplanolla> Anything that requires adding explicit type signatures or prohibits syntax that used to work is off.
07:53:36 <byorgey> kubbe: ah, in that case, you probably want a recursive function that keeps track of the current bitstring as a parameter.
07:54:01 <kubbe> yeah I was thinking about something like that. Alrighty then! Lets get to it
07:54:13 <BernhardPosselt> is there something like head but it returns a Maybe?
07:54:17 <BernhardPosselt> if no value is present
07:54:27 <abhiroop> hodapp: Datomic's source code is not open. People in Clojure are trying to reproduce an open source version of Datomic. Have a look at this project: https://github.com/datacrypt-project/hitchhiker-tree
07:54:48 <abhiroop> Haskell folks have tried implementing hitchhiker trees too
07:54:50 <merijn> Tuplanolla: I don't think anything does that, tbh?
07:54:58 <merijn> Tuplanolla: They mostly enable extra syntax
07:55:10 <abhiroop> I was wondering if there are any Haskell implementations of Fractal Tree Index
07:55:23 <abhiroop> Hitchhiker Trees build on top of fractal trees
07:55:23 <merijn> Tuplanolla: Things like RankN/ScopedTypeVariables only requires explicit signatures for the functions to which they apply
07:55:40 <abhiroop> Didn't find anything on fractal trees in haskell
07:56:13 <Tuplanolla> Overloaded things do that, as does `CPP`, merijn.
07:56:21 <jle`> merijn: TypeInType disappears the * kind
07:56:35 <jle`> or at least make sit not work with TypeOperators
07:56:51 <merijn> jle`: I'm not using GHC8, so that I don't know
07:57:08 <Tuplanolla> There's also `Safe` and friends that disallow some things, merijn.
07:57:16 <merijn> I wouldn't call CPP an extension, tbh
07:59:32 <Tuplanolla> :t list -- You might like this, BernhardPosselt.
07:59:36 <lambdabot> b -> ([a] -> b) -> [a] -> b
08:00:05 <Tuplanolla> :t maybe -- It's analogous to this.
08:00:07 <lambdabot> b -> (a -> b) -> Maybe a -> b
08:00:42 <byorgey> BernhardPosselt: there is in the 'safe' package.  You could also make one from stuff in base using  fmap head . nonEmpty  from Data.List.NonEmpty
08:01:30 <jle`> BernhardPosselt: there's 'listToMaybe'
08:01:37 <jle`> > listToMybe [1,2,3]
08:01:41 <lambdabot>  error:
08:01:41 <lambdabot>      • Variable not in scope: listToMybe :: [Integer] -> t
08:01:41 <lambdabot>      • Perhaps you meant ‘listToMaybe’ (imported from Data.Maybe)
08:01:46 <jle`> > listToMaybe [1,2,3]
08:01:48 <lambdabot>  Just 1
08:01:52 <jle`> > listToMaybe []
08:01:55 <lambdabot>  Nothing
08:02:53 <jle`> (it's in base, in Data.Maybe)
08:03:15 <jle`> > fmap fst . uncons $ [1,2,3]
08:03:18 <lambdabot>  Just 1
08:05:14 <BernhardPosselt> jle`: ty
08:05:22 <jle`> np
08:05:41 <BernhardPosselt> found that but looked to me as if it was just mapping a list to a list of maybes
08:06:10 <jle`> Maybe can be considered a list with at most 1 item
08:06:19 <jle`> so listToMaybe "truncates" a list to at most 1 item
08:06:35 <jle`> maybeToList goes the other way around
08:06:46 <pie_> wow thats weird i just had stack crash while compiling some deps for a package
08:06:59 <BernhardPosselt> i mean it sounded like: [a] -> [Maybe a]
08:07:17 <jle`> that'd be listToListOfMaybes :)
08:07:29 <BernhardPosselt> would have expected a function named "findFirst" :D
08:11:19 <sternmull> is there a way to get the qualified name of a type? For example i see hGet returns IO ByteString but i have no idea if it is the lazy or strict version.
08:11:41 <jle`> in the haddocks, you mean?
08:11:45 <jle`> usually i just click the link :|
08:12:31 <sternmull> hm, i am looking at it in ghci. ":t hGet" prints "hGet :: GHC.IO.Handle.Types.Handle -> Int -> IO ByteString".
08:12:32 <jle`> or mouse over it
08:12:42 <jle`> sternmull: did you import ByteString ?
08:12:50 <jle`> usually it'll give you the name by how you import it
08:13:16 <sternmull> hm, ok
08:13:27 <jle`> if you imported lazy bytestring, it's probably a lazy bytestring
08:13:36 <jle`> if you imported strict bytestring, it's probably strict bytestring
08:13:44 <jle`> it wouldn't refer to something unqualified unless it was unqualified in scope
08:13:47 <jle`> ah, you can try :i ByteString
08:14:04 <Tuplanolla> The inferred fully qualified name may be misleading though. You should refer to `System.IO.Handle` instead of `GHC.IO.Handle.Types.Handle`.
08:15:20 <sternmull> ah yes, :i is better. Totally forgot about that for a moment. Although it tells me the internal types or whatever they are, not the qualified names that i am used to import.
08:32:42 <repwisee_> Guten tag mein komeraden
08:33:06 <repwisee_> Privyet balor
08:33:16 <repwisee_> wi
08:33:18 <repwisee_> will
08:33:20 <repwisee_> anyone
08:33:22 <repwisee_> respond
08:33:24 <repwisee_> pls
08:33:43 <repwisee_> hey
08:33:44 <repwisee_> hallo
08:33:46 <glguy> repwisee_: Don't spam the channel. If you have a question you're welcome to ask it
08:33:53 <repwisee_> K, sorry
08:34:49 <repwisee_> Does anyone know how to install a Linux distribution onto a usb? I've having a bit of trouble.
08:35:08 <kgadek> wrong channel
08:35:18 <repwisee_> Alright.
08:36:49 <shapr> Unless you want to boot HaLVM from a USB stick, then you're in the right place.
08:37:49 <kgadek> btw, anyone here using HaLVM on production?
08:37:56 <kgadek> very curious about this project
08:38:03 <kgadek> never had time to actually dive into it
08:38:05 <shapr> I know galois uses it in production
08:38:26 <kgadek> ye, but they've also created it so… usually I try to get second opinion ;P
08:38:54 <kgadek> (this is despite my respect for Galois)
08:39:42 <padre_angolano> All, I read that stack can install ghc. I didn't try stack so far. On a new ubuntu system, do I install haskell platform or stack (which installs ghc for me?)
08:39:46 <padre_angolano> ?
08:39:55 <jle`> padre_angolano: apt-get install stack should do it
08:39:57 <hodapp> say 'galois' three times and our resident Galois employees will jump out of the woodwork
08:40:11 <jle`> and then you can 'stack upgrade' to get the latest version
08:40:25 <jle`> or is it apt-get install haskell-stack
08:40:35 <padre_angolano> jle`: so, should I choose that instead of apt-get install haskell-platform?
08:40:40 <jle`> hm, yeah it's just 'stack'
08:40:58 <jle`> padre_angolano: haskell platform includes stack, but i can't imagine why you'd need the whole platform these days
08:41:33 <jle`> so, yeah, i would recommend just installing stack, but that's just me
08:41:41 <glguy> Most people install the "minimal" platform rather than the "whole" one
08:41:43 <padre_angolano> jle`: hmm, stack includes ghc and haskell platform includes stack. sounds like a circular dependency :-)
08:42:01 <jle`> padre_angolano: how so?
08:42:05 <glguy> And the minimal platform includes ghc, cabal, and stack executables
08:42:08 <tsahyt> I'm parsing a binary format in attoparsec. What's the best way to parse the same byte twice, i.e. the first 4 bits and then the last 4 bits?
08:42:11 <kgadek> IMHO stack > haskell-platform
08:42:13 <tsahyt> ideally using applicative syntax
08:42:23 <padre_angolano> jle`: anyway, i'll try the stack approach then. thanks!
08:42:29 <jle`> padre_angolano: both haskell platform and stack include ghc
08:42:36 <jle`> padre_angolano: "including ghc" doesn't mean including the platform
08:42:57 <glguy> It's good to have the cabal executable around even when you're primarily using stack so that "stack solver" works
08:43:08 <kgadek> `stack install cabal-install`? :D
08:43:20 <jle`> padre_angolano: the haskell platform uses ghc.  so you can have ghc without the platform :)
08:43:57 <jle`> padre_angolano: the platform is ghc + extra stuff
08:45:11 <padre_angolano> jle`: aha
08:46:35 <lpaste_> qmm pasted “i was reading an Aeson tutorial with this example, but it it doesn't seem to work... ” at http://lpaste.net/352490
08:46:40 <jle`> if you do go the stack route, though, remember that all of your haskell comands are 'qualified'
08:46:52 <jle`> so you'd do 'stack ghci', 'stack ghc', 'stack install', etc., instead of just 'ghci'/'ghc'
08:47:02 <glguy> qmm: You have to use the OverloadedStrings extension for that example
08:47:26 <padre_angolano> jle`: I see. BTW can stack uninstall thinks or is it install-only like cabal?
08:47:33 <padre_angolano> "uninstall things"
08:47:44 <jle`> you don't really need to uninstall things when you're using stack
08:47:46 <qmm> glguy: thanks, that did it
08:48:10 <glguy> padre_angolano: It's install only. Every once and a while you can delete all your packages and start over
08:48:36 <glguy> The resolvers are interlinked so make sure you don't delete single package sets when you do that
08:48:41 <jle`> in cabal you might want to uninstall things to fix dependency issues, but dependency issues like that won't come up in stack because it maintains self-consistent snapshots
08:49:46 <padre_angolano> e. g. if stack installs ghc for me, will it be able to update it when a new version is available? or I must delete all and start over?
08:50:06 <jle`> all you'd do is change your resolver
08:50:16 <jle`> and then stack will use the new resolver whenever you do anything
08:50:29 <glguy> It's the same as without stack, you can have multiple installed. It doesn't overwrite
08:50:55 <jle`> different ghc's and packages will exist on your system side-by-side, and when you invoke stack, it uses the versions of ghc/the packages that the resolver uses
08:50:59 <infandum> I have some code: http://lpaste.net/2083873524488863744 , but it doesn't act as expected. I would think "H" and "O" get printed in any order, then "W" and "D" in any order, then "Y", but it's all over the place and there are repeats! What's going on?
08:51:09 <infandum> It's a prallel + shell problem
08:51:21 <padre_angolano> jle`: and what about deleting older ghc versions when they are not needed?
08:51:45 <qmm> how does fromList work? https://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Exts.html#IsList i haven't used it before, but looking at its definition, it looks like it yanks an element from a list
08:51:51 <jle`> i don't think it deletes them automatically, but you can delete the ghc versions manually to save space
08:52:18 <padre_angolano> jle`: delete using stack or just with 'rm'? 
08:52:25 <jle`> qmm: it's a typeclass method, so every instance defines it in a different way
08:52:30 <glguy> stack can't know when aghc version is not needed
08:53:10 <jle`> padre_angolano: with rm
08:53:17 <padre_angolano> aha, thanks
08:53:22 <jle`> stack basically caches everything forever
08:53:34 <jle`> so you can instantly load up an old resolver and everything will work fine
08:53:53 <jle`> if you have a bunch of versions of packages installed, it'll use the set of versions that the resolver dictates
08:54:05 <qmm> jle`: thanks
08:54:09 <jle`> qmm: for instance, for the '[]' instance, fromList = id
08:54:18 <jle`> er, the '[a]' instance
08:54:28 <jle`> for the Data.Map instance, fromList = M.fromList
08:54:35 <jle`> qmm: are you familiar with typeclasses?
08:55:30 <qmm> jle`: i think so
08:55:43 <jle`> qmm: so like, for the Eq typeclass, every Eq instance implements (==) separately in its own way
08:55:55 <jle`> and when you use (==), it uses the definition that you gave for that specific type you're using (==) with
08:55:58 <qmm> (this channel is busy!)
08:56:26 <jle`> it can get busy at times!
08:57:44 <qmm> looking at its definition: instance IsList [a] where type (Item [a]) = a fromList = id toList = id i would htink you could give it [1] and you would get 1 back
08:58:07 <jle`> qmm: why would you think that
08:58:09 <jle`> fromList = id
08:58:16 <jle`> so if you gave fromList [1,2,3], that'd be id [1,2,3]
08:58:26 <jle`> fromList [1,2,3] = [1,2,3]
08:58:36 <qmm> that makes sense
08:58:42 <qmm> what is the type bit
08:58:47 <qmm> type (Item [a]) = a
08:58:48 <jle`> that's an associated type
08:58:58 <jle`> it says that the types of the "items" in an [a] are a's
08:59:05 <jle`> so for an [Int], the type of the items is Int
08:59:12 <jle`> for [Bool], the type of the items is Bool
08:59:29 <qmm> > fromList [1,2,3]
08:59:31 <lambdabot>  error:
08:59:31 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M279578576363...
08:59:31 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
08:59:42 <qmm> that's what i keep getting in my ghci session as well
08:59:50 <jle`> that's because fromList is polymorphic
08:59:52 <jle`> like 'read'
08:59:59 <jle`> you have to specify what type you want to get
09:00:02 <jle`> > fromList [1,2,3] :: [Int]
09:00:05 <lambdabot>  [1,2,3]
09:00:08 <qmm> the example works well though: Array $ fromList [Number 1, Number 2, Number 3]
09:00:19 <jle`> > fromList [1,2,3] :: Set Int
09:00:22 <lambdabot>  error:
09:00:22 <lambdabot>      Not in scope: type constructor or class ‘Set’
09:00:22 <lambdabot>      Perhaps you meant one of these:
09:00:26 <jle`> > fromList [1,2,3] :: S.Set Int
09:00:33 <lambdabot>  mueval-core: Time limit exceeded
09:00:41 <jle`> well, you can specify what type you want, or you can give ghc some way to infer it
09:00:49 <jle`> fromList [1,2,3], there's no way to infer what type you want
09:00:55 <jle`> > (fromList [1,2,3]) ++ [4,5,6]
09:00:59 <lambdabot>  [1,2,3,4,5,6]
09:01:14 <qmm> jle`: thanks!
09:01:28 <jle`> > map toUpper (fromList ['a','b','c'])
09:01:33 <lambdabot>  "ABC"
09:08:46 <Xe> https://puu.sh/u1uM1/de46dae7c9.png
09:18:04 <Profpatsch> Err, the rules and the first example of https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#the-ghci-files
09:18:15 <Profpatsch> are not cohesive, are they?
09:18:25 <Profpatsch> In the last part of that chapter.
09:18:33 <Profpatsch> Do a prefix lookup on the list of built-in commands - if a built-in command matches, but a macro is defined with the same name as the built-in defined, pick the macro.
09:18:40 <Profpatsch> You have a macro :time and enter :t 3
09:19:15 <Profpatsch> So I think it should expand to :time 3, since it prefercs the macro.
09:19:32 <Profpatsch> But the example says I get :type 3
09:19:53 <glguy> Profpatsch: No, prefix match on macro is the lowest priority, rule 5
09:20:21 <glguy> but rule 3 is picking :type
09:20:46 <Profpatsch> glguy: One has to be wrong, or I am reading this falsely.
09:20:51 <lyxia> Profpatsch: it says it prefers the macro if it matches the builtin command. time /= type.
09:20:58 <glguy> Profpatsch: You're reading it wrong
09:21:41 <Profpatsch> So first it does exact macro matching, then exact builtin matching.
09:22:05 <Profpatsch> Ah, I read 3 again and now it makes sense.
09:22:14 <Profpatsch> It’s formulated backwards.
09:22:30 <Onemorenickname> is there a growing sequence datatype in haskell ?
09:22:33 <Onemorenickname> like a dynamic array
09:22:33 <lyxia> Profpatsch: "exact matching" means whether there is a macro named "t"
09:22:38 <jle`> Onemorenickname: there's [a]
09:22:52 <Profpatsch> lyxia: Yes, of course.
09:22:52 <Onemorenickname> jle`, it's immutable, so it can't be growing
09:23:12 <Profpatsch> Onemorenickname: It’s a linked list.
09:23:18 <lyxia> Profpatsch: oh I thought you misunderstood that part, nevermind.
09:23:20 <jle`> there are mutable arrays if that's what you're looking for
09:23:37 <Onemorenickname> jle`, these are of fixed size, so they are not growing
09:23:48 <Onemorenickname> Profpatsch, but i can not change a link, it's immutable
09:23:59 <Profpatsch> Onemorenickname: It’s defined as data List a = Empty | Cons a (List a)
09:24:14 <jle`> Onemorenickname: how about the ones from the 'vector' package?
09:24:42 <Profpatsch> I think you are conflating semantics vs. actual memory actions.
09:24:43 <jle`> but depending on what you need, you can probably use [a] and just work with cons/(:)
09:24:52 <jle`> what sort of algorithm are you trying to implement?
09:25:07 <jle`> list works well for algorithms that involve extending arrays
09:25:20 <Profpatsch> Of course  b = 'c' : a will not copy a to a different memory location first and then append c
09:25:24 <Profpatsch> *'c'
09:25:24 <jle`> (:) doesn't actually duplicate any data
09:25:37 <Onemorenickname> jle`, i'm earley-parsing
09:25:44 <Onemorenickname> in the algorithm, there is "add-to-set"
09:25:52 <Profpatsch> That would be very stupid; but Onemorenickname you come from ML, right?
09:25:54 <Onemorenickname> in ocaml, i've done it with DynArray
09:26:02 <Profpatsch> I can’t imagine they do it any differently.
09:26:07 <Onemorenickname> Profpatsch, yep, whyso ?
09:26:20 <Profpatsch> Copy on write, it’s even in file systems nowadays. :P
09:26:34 <Onemorenickname> again, in ocaml, i've used DynArray
09:27:15 <Profpatsch> So what you want is an unpacked array that is self-extending?
09:27:20 <Profpatsch> *expanding
09:27:30 <Onemorenickname> for instance
09:27:34 <Profpatsch> Are you doing cycle-crunching already? :)
09:27:40 <Onemorenickname> at least, i know i've made-it work
09:27:49 <Onemorenickname> nooot-yet :D
09:28:02 <Profpatsch> How about Data.Set?
09:28:29 <Onemorenickname> Isnt' Data.Set immutable ?
09:28:30 <Profpatsch> Or are you re-implementing sets as excercise?
09:28:36 <Profpatsch> Yeah, so?
09:28:47 <Onemorenickname> I want to iterate over something I'm growing while iterating
09:29:05 <jle`> sounds like you can use immutable sets for that
09:29:09 <Onemorenickname> how so ?
09:29:13 <Profpatsch> As I said,  Set.add a mySet won’t copy mySet.
09:29:20 <Profpatsch> That’s would be stupid.
09:29:38 <Profpatsch> Normally it just adds another element into the internal data structure in an O(1) operation.
09:29:39 <Onemorenickname> Profpatsch, still, if I iterate, won't it stop ?
09:29:49 <jle`> Onemorenickname: just use Set.add to define a new set, and then refer to that new set
09:29:50 <Onemorenickname> In ocaml, Set.add won't copy myset
09:30:01 <Onemorenickname> But if you iterate, it will not iterate through the elements added while iterating
09:30:24 <Profpatsch> The question is: will your previous references change when you modify the set in a different part of the code.
09:30:32 <Profpatsch> That’s the difference between mutable/immutable
09:30:37 <Onemorenickname> jle`, I hope haskell allows references, still, I don't see how it does help
09:30:42 <daig> Right, you'd need to store the set in an STVar or something
09:30:54 <Profpatsch> daig: That’s not his problem.
09:30:58 <jle`> Onemorenickname: do you mean mutate the set while you are iterating through the set?
09:31:09 <Profpatsch> Why would one want that?
09:31:14 <Onemorenickname> jle`, i add element to the sets, while doing that
09:31:19 <Onemorenickname> while iterating
09:31:26 <jle`> so in the same iteration, you'll eventually reach elements that you added?
09:31:32 <Onemorenickname> that's what i want
09:31:42 <Profpatsch> So generating iteration?
09:31:43 <Onemorenickname> with a dyn array, i can do "while i < arr.length"
09:32:34 <mnoonan> do you actually mean a set? no repetition of elements? is the iteration in-order?
09:32:36 <Profpatsch> Isn’t generating recursion the definition of a zygomorphism? :)
09:32:58 <Onemorenickname> mnoonan, yep, it's a set, if there is a repetition, i'm plucked
09:33:00 <daig> If that's really what you need, I would do it as two concurrent producer/consumer processes
09:33:02 <Onemorenickname> (endless recursiooon)
09:33:33 <Profpatsch> Onemorenickname: What’s your source of elements
09:33:43 <Profpatsch> And how do you want to transform them?
09:33:56 <Onemorenickname> Profpatsch, basically
09:34:07 <Onemorenickname> it's https://en.wikipedia.org/wiki/Earley_parser , but keeping track of derivations, and with hooks
09:34:19 <Onemorenickname> and with an other representation for grammars
09:34:35 <Onemorenickname> "but, and, and", not good, not good
09:34:59 <Profpatsch> Onemorenickname: What’s your specific problem right now.
09:35:11 <Onemorenickname> I want to iterate through a growing set
09:35:24 <Profpatsch> What’s a “growing set”?
09:35:38 <Onemorenickname> a set, that gets new elements while being iterated through
09:35:49 <Profpatsch> How could that happen?
09:35:54 <Profpatsch> Are there concurrent processes running?
09:35:57 <daig> Do you need to retain the set after the iteration?
09:36:27 <Onemorenickname> Profpatsch, if the set is a DynArray, it could be done this way ("[]" are for the dynamic array here) :
09:36:40 <Onemorenickname> at start, you have the dynamic array [1,2,3,4,5]
09:37:01 <Onemorenickname> and the iteration states "if the current element % 3 == 0, add a new element to the array"
09:37:40 <Onemorenickname> so, through the iteration, you get : [1, 2, 3, 4, 5],[1, 2, 3, 4, 5],[1, 2, 3, 4, 5, 6],[1, 2, 3, 4, 5, 6],[1, 2, 3, 4, 5, 6],[1, 2, 3, 4, 5, 6, 7], [1, 2, 3, 4, 5, 6, 7], and it's over
09:37:41 <mnoonan> what about focusing on the type of one step of your process? It might have a type like "IterationState -> IterationState" where "data IterationState = Step { newSet :: Set a, todo :: Set a }", right?
09:38:37 <Onemorenickname> daig, yep, i need to retain the set
09:38:44 <mnoonan> you'd start with the whole set in your todo and newSet fields, then on each step you'd remove something from todo until it is empty, potentially adding stuff to todo and newSet as you go
09:39:02 <EvanR> what laws does this data structure follow
09:39:14 <EvanR> if youre in the middle and something is added, do you see it
09:39:17 <Onemorenickname> basically, i have k sets, and I iterate through each of them, each iteration can add elements to the current set, or the previous one, and while iterating a set, i can iterate through a previous one
09:39:22 <Onemorenickname> ( https://en.wikipedia.org/wiki/Earley_parser )
09:39:49 <Onemorenickname> (and there are several kind of iterations)
09:39:52 <EvanR> and when you reach the "end", then something is added, does the iteration continue
09:40:12 <Onemorenickname> EvanR, if the end is reached, the iteration stop
09:40:27 <Onemorenickname> if something is added in the middle of an iteration, i see it because i do it
09:40:45 <Onemorenickname> mnoonan, i'm thinking about such stack
09:41:24 <Onemorenickname> as there are several kind of iterations, it would like a "Stack (t, IterationType)", where IterationType is an enumeration
09:41:30 <EvanR> so specifically the iteration visit is executing an add
09:41:34 <EvanR> its no just happening 
09:41:46 <Onemorenickname> but still, it could work, (the algorithm guarantees that at least)
09:41:48 <Onemorenickname> EvanR, yep
09:41:59 <Onemorenickname> it does not happen out of a concurrent process for instance
09:43:15 <Onemorenickname> (in ocaml, i've done it this way : https://ghostbin.com/paste/nxjxg )
09:43:37 <Profpatsch> Onemorenickname: So it’s basically foo [x:xs] = x : foo (if x `mod` 3 == 0 then xs ++ [(last xs)] else xs)
09:44:20 <Profpatsch> Onemorenickname: err foo [x:xs] = x : foo (if x `mod` 3 == 0 then xs ++ [(last xs) + 1] else xs)
09:44:41 <Onemorenickname> Profpatsch, yep, for the example i gave you, a list works enough
09:44:49 <Profpatsch> And of course one case for []
09:44:57 <Onemorenickname> but
09:45:10 <Onemorenickname> wait
09:45:14 <Onemorenickname> it looks like it works
09:45:19 <Onemorenickname> like your solution works
09:45:23 <Onemorenickname> lemmecheck
09:45:28 <Profpatsch> Yeah, why not. :)
09:45:38 <Profpatsch> The wonders of recursion.
09:45:49 <Onemorenickname> oh no
09:45:58 <Profpatsch> Of course last might make that very (very) slow, because O(n) and stuff.
09:46:01 <Onemorenickname> because i don't only need the current element
09:46:12 <Profpatsch> So maybe not the best representation.
09:46:25 <Onemorenickname> so in my case, it makes it very slow
09:46:36 <Onemorenickname> and because i might come to parse big things, that would not be good
09:46:46 <Profpatsch> What *do* you need?
09:46:54 <Profpatsch> It’s a parser, so probably backtracking, right?
09:47:18 <Profpatsch> There is a very good Earley-style parser available already btw
09:47:43 <Onemorenickname> efficient and with hooks ?
09:49:29 <Profpatsch> Well, if there is a language where you can find any kind of parser(combinator), it’s Haskell.
09:50:15 <Profpatsch> see https://hackage.haskell.org/packages/#cat:Parsing
09:51:37 <daig> what exactly do you mean by hooks?
09:53:07 <Profpatsch> There’s even a library for building parser combinators: https://hackage.haskell.org/package/parsers
09:54:43 <Profpatsch> So you can write your parsers with the same interface and use the implementation that works best for your use-case (and even benchmark different libs for your use-cases).
10:03:01 <jaspervdj> Is there a haskell package that can convert 1 to "one" and "first", 2 to "two" and "second", and so on?
10:03:45 <jaspervdj> there's already a `Plural` libary which can convert "person" to "people" so that's good
10:04:30 <Prutheus> Hello! I have a hakyll-qesution: My question is: inside an HTML document, I wanna make a loop over a number-variable i pass to it via a field. I have a number $amount$, e.g. =5; now i want to draw some html elements 5-times ... how?
10:07:14 <jaspervdj> Prutheus: it would be best to use a list, see http://mattwetmore.me/posts/hakyll-list-metadata.html
10:13:00 <Prutheus> jaspervdj: but how can i get something like the $numPages$ from pagination looped so i can create several links like P1,P2,P3...
10:14:51 <JeKs> Hey guys. I kind of lost motivation to learn haskell because I am not able to see its use. Do you maybe know some place where I can learn to make usefull things with it? I am learning the job right know but am in the first year so we don't learn any programming at all. I am self taught and know python, c++ and some haskell
10:15:29 <infandum> I guess there's not too much experience with turtle
10:16:11 <cocreature> infandum: if you have a question, just ask it directly :)
10:16:12 <jle`> JeKs: what do you use python and c++ for?
10:16:24 <byorgey> jaspervdj: http://hackage.haskell.org/package/numerals
10:16:40 <jle`> JeKs: the next time you are tempted to do a project in python/c++, just do it in haskell instead :)
10:17:08 <infandum> cocreature: I did but no response, I assume because of the small overlap between parallel and turtle
10:17:43 <cocreature> infandum: asking a few hours later again can help. not everybody is constantly checking the channel
10:17:56 <infandum> alrighty
10:18:06 <jaspervdj> byorgey: thanks!
10:18:10 <infandum> I have some code: http://lpaste.net/2083873524488863744 , but it
10:18:11 <infandum>            doesn't act as expected. I would think "H" and "O" get printed in
10:18:11 <infandum>            any order, then "W" and "D" in any order, then "Y", but it's all
10:18:11 <infandum>            over the place and there are repeats! What's going on?
10:18:18 <NANDgate> Jeks: You might find something interesting here http://cufp.org/2016/index.html
10:18:23 <infandum> well that didn't copy the right way, oh well
10:19:07 <osa1> can anyone help me understand this freer error: http://lpaste.net/352491 
10:19:39 <Prutheus> jaspervdj: huhu? still here?
10:19:58 <shapr> infandum: if you post an issue on the github turtle issues, I think you'll get a good response
10:20:15 <shapr> infandum: I've seen several illuminating conversations on Turtle issues on github
10:20:31 <NANDgate> Jeks: Not all of these are exclusively Haskell but do relate in some way and might be fun to experiment with in Haskell  https://www.youtube.com/channel/UCEBcDOjv-bhAmLavY71RMHA/search?query=haskell&spfreload=1
10:20:41 <infandum> shapr: Do you think it's a turtle issue or an async issue?
10:20:49 <shapr> infandum: I got no clue at all, otherwise I'd chime in.
10:20:53 <infandum> k
10:21:20 <cocreature> hm repeats are weird
10:21:30 <shapr> JeKs: I wrote a weekend hack to display my local subway arrival times in my tmux status bar: https://github.com/shapr/tmuxmarta
10:22:12 <Prutheus> jaspervdj: could you tell me how i can get my number to a list?
10:22:31 <Prutheus> jaspervdj: or how to access $numPages$ of pagination in haskell code so i cann parse it as list
10:22:36 <infandum> cocreature: You get it too, right?
10:22:42 <shapr> infandum: have you figured out how to get match to work in Turtle?
10:22:55 <shapr> I want to use grep, but confusion.
10:22:55 <infandum> shapr: You mean from patterns?
10:23:00 <cocreature> infandum: haven’t yet managed to test it. my turtle version seems to be too old to contain "parallel"
10:23:01 <infandum> shapr: Yes
10:23:06 <infandum> You don't use match
10:23:09 <infandum> directly
10:23:28 <infandum> cocreature: The latest version would have it
10:23:37 <infandum> it's in stack nightly
10:23:43 <infandum> it might be in 8.0, let me check
10:24:02 <infandum> yes it is
10:24:04 <infandum> lts-8.0
10:24:22 <cocreature> great, I’m currently switching my global snapshot to lts-8.0 so in a few minutes I should be able to take a look at it
10:24:23 <infandum> shapr: What grep are you confused about exactly?
10:24:36 <infandum> cocreature: Thank you!
10:25:56 <cocreature> infandum: as to the order they are printed: the only thing that should be guaranteed is that in each chunk, the first letter is printed before the second letter. letters from other chunks can be interleaved
10:26:12 <cocreature> but that doesn’t explain repeats
10:27:20 <infandum> cocreature: Exactly. So "H" and "O" could be in any order
10:27:26 <infandum> then "W" and "D"
10:27:28 <infandum> then "Y"
10:27:29 <cocreature> infandum: no! H and O are in the same chunk
10:27:34 <cocreature> so H will be printed before O
10:27:35 <infandum> yes
10:27:37 <infandum> no
10:27:43 <infandum> they are executed in parallel
10:27:44 <cocreature> oh I forgot the map
10:27:46 <cocreature> you are right
10:27:58 <infandum> but in my output it's all wacky,
10:28:11 <infandum> 'O''
10:28:11 <infandum> H'
10:28:11 <infandum> 'W''
10:28:11 <infandum> D'
10:28:14 <infandum> 'Y'
10:28:17 <infandum> 'Y'
10:28:20 <cocreature> by build should be finished soon :)
10:28:20 <infandum> 'W'
10:28:23 <infandum> 'D'
10:28:26 <infandum> 'Y'
10:28:29 <infandum> 'Y'
10:28:32 <cocreature> stop  please :)
10:28:32 <infandum>  
10:28:35 <infandum> Which makes no sense
10:28:42 <infandum> like, I guess up to the first Y it makes sense
10:28:46 <infandum> :(
10:29:27 <cocreature> I’m also seeing duplicates
10:30:11 <infandum> ah
10:31:52 <dmwit_> infandum: I propose that `OverloadedStrings` is doing something odd.
10:32:20 <dmwit_> infandum: In particular: `parallel :: [IO a] -> ...`, but I would expect `chunksOf 2 . fmap print $ "HOWDY" :: [[IO ()]]`.
10:32:46 <cocreature> dmwit: "parallel" is passed to mapM_
10:32:53 <infandum> dimwit: But it's printing characters
10:32:59 <infandum> so it is reading as a string
10:33:00 <dmwit> cocreature: crazy talk
10:33:09 <dmwit> reading code is hard, let's go shopping
10:33:19 <shapr> Haskell Barbie!
10:34:18 <Prutheus> jaspervdj: sorry, but could you please amswer to me?
10:34:33 <cocreature> Prutheus: maybe he’s just busy?
10:34:42 <Prutheus> hmmm...
10:35:55 <cocreature> infandum: oh it’s because Shell is some sort of ListT
10:36:51 <infandum> cocreature: I thought it was something like that, but I put it in a sh $ do even with strict and it still failed. Unless the issues is even lower level inside of the list
10:37:03 <infandum> that probably makes no sense
10:37:24 <cocreature> infandum: here’s a reduced example http://lpaste.net/352492
10:37:58 <cocreature> > do [1,2]; [3,4]
10:38:03 <lambdabot>  [3,4,3,4]
10:38:09 <infandum> oh, I see
10:38:14 <cocreature> it’s the same phenomenon
10:38:21 <infandum> and it returns shell
10:38:30 <infandum> the mapm was throwing me off
10:38:35 <infandum> I thought I was avoiding that
10:39:00 <infandum> wait no, I should be avoiding that though. mapm has sequence, right?
10:39:16 <cocreature> mapM is the problem _because_ it uses >>=
10:39:20 <infandum> ah
10:39:45 <infandum> so I shouldn't be using parallel at all
10:40:07 <infandum> the main idea was to do two of the function at a time
10:40:22 <infandum> but parallel does it all at a time, not two
10:40:46 <jaspervdj> Prutheus: so you'd want to create a list in your page compiler
10:41:03 <jaspervdj> Prutheus: containing the strings ["P1", "P2", "P3...]
10:41:25 <Prutheus> jaspervdj: right, because i need a list of the total pages, not just the number, to have a for loop in my html code to draw multiple links to all teh pages
10:41:41 <Prutheus> jaspervdj: no, just a list, 1..5 would be enought, too
10:41:44 <cocreature> infandum: I think the intention is that you use "parallel" if you have something like a bunch of http requests. they can be fetched in parallel but their results will still be emitted sequentially
10:41:45 <jaspervdj> Prutheus: exactly
10:41:47 <Prutheus> i onl y wanna loop
10:42:10 <jaspervdj> Prutheus: let's take this to PM, don't want to spam the channel full of hakyll help
10:42:14 <infandum> cocreature: Yes, you are right. Converting print to a function that returns a line, then using strict . parallel fixes the issue
10:42:54 <infandum> cocreature: So which is best library for executing a function on a list that doesn't do more than N at a time?
10:43:35 <cocreature> infandum: I would probably use mapConcurrently + a semaphore to ensure that not more than N are executed at the same time
10:43:37 <padre_angolano> what ghc8 extension do I need in order to define things like 'type N = Num a => Maybe a'? in ghc7, it worked with -XRankNTypes -XFlexibleContexts, but no longer works in ghc8
10:43:58 <dmwit> infandum: Fork n threads that all read from the same channel. Shove all your actions into the channel.
10:44:14 <padre_angolano> so my old program stopped to compile after switching to ghc8
10:44:30 <jle`> padre_angolano: i'm surprised that that ever worked
10:44:47 <jle`> but try type N = forall a. Num a => Maybe a
10:45:12 <dmwit> padre_angolano: RankNTypes is enough for me with jle`'s proposed fix
10:46:27 <padre_angolano> jle`, dmwit: works this way, thanks!
10:46:59 <jle`> no problem!
10:47:11 <jle`> the forall a. brings the 'a' into scope, in a manner of speaking
10:47:22 <jle`> i'm surprised that it worked without it in ghc 7
10:47:55 <padre_angolano> jle`: but it did... I just inserted the 'forall' thing to the program which compiled without it in ghc 7...
10:48:05 <jle`> yeah, just tried it out, it does work
10:48:09 <jle`> i'm just surprised that it does
10:48:35 <infandum> seems a little complex for a simple problem...
10:51:42 <lpaste_> dmwit pasted “poor man's thread pool” at http://lpaste.net/352493
10:51:43 <dmwit> infandum: ^^
10:54:51 <infandum> oh my
11:00:11 <dmwit> Is that an "oh my" of horror or admiration?
11:05:10 <jle`> are there any good type-level Map data types
11:08:33 <benzrf> jle`: just use idris :>
11:11:20 <infandum> dmwit: It's a bit more complicated then "pool 2 f"
11:21:33 <cocreature> there is an async-pool package https://hackage.haskell.org/package/async-pool-0.9.0.1/docs/Control-Concurrent-Async-Pool.html
11:40:07 <tsahyt> Hello. I'm working on a library for a binary protocol. Most importantly it needs to do parsing and serialization. I've got the parsing down for a subset of it, but I was wondering what the optimal way would be to do serialization? Should I use bytestring builders or something like cereal? The main goal is performance, the protocol is fairly simple.
11:46:03 <lpaste_> Dynasty pasted “No title” at http://lpaste.net/4198032057382731776
11:46:48 <Dynasty> I'm having trouble writing the FromJSON aeson function. I got the ToJSON pretty easily, but I'm not sure what I should do now
11:49:05 <cocreature> Dynasty: the docs contain examples https://hackage.haskell.org/package/aeson-1.1.0.0/docs/Data-Aeson.html#t:FromJSON
11:49:36 <Dynasty> I've been reading the docs for over an hour now
11:50:14 <Dynasty> and I'm still not sure how to make specifically make PassThrough work
11:50:31 <Dynasty> ^ English is hard
11:51:05 <jle`> Dynasty: it's a bit weird because your ToJSON is not injective
11:51:22 <jle`> Dynasty: what behavior do you really want?
11:51:22 <cocreature> yeah that’s usually not what you want
11:51:42 <cocreature> e.g. PassThrough Hole and Hole serialize to the same JSON
11:51:53 <cocreature> so you have no chance of telling them apart when you deserialize
11:51:56 <monochrom> Accept that FromJSON will not create PassThrough.
11:52:22 <jle`> Dynasty: one thing you can do is check if 'reference', 'substitution', or 'hole' are keys of the object, and if they are, us Ref/Sub/Hol
11:52:43 <jle`> otherwise prase it as PassThrough
11:52:46 <jle`> but that's still not a real inverse
11:52:54 <cocreature> Parser has an Alternative instance so you can just write parser for the individual cases and combine them with <|>
11:53:19 <Dynasty> Yes, that's what I've been trying to write jle`
11:55:18 <Dynasty> Is there a generic "object parser" that I can use for the pass through case?
11:55:52 <cocreature> you can just use the FromJSON instance from "a"
11:55:57 <jle`> Dynasty: yes
11:56:09 <monochrom> Yes, it's called parseJSON again. Because you have "instance FromJSON a => FromJSON (Link a)"
11:56:11 <jle`> Dynasty: it's called parseJSON
11:56:24 <monochrom> This is just like what you did to ToJSON
11:57:08 <Boomerang> I think it's something like: PassThrough <$> parseFSON
11:57:14 <Dynasty> ah okay I think I see now
11:57:17 <Boomerang> *JSON
11:58:39 <jle`> parseJSON also needs the input object for some reason
11:58:45 <jle`> but yeah
11:59:25 <Boomerang> Alright so: parseJSON = fmap PassThrough . parseJSON
11:59:26 <monochrom> "parseJSON" is misnamed.
11:59:45 <Dynasty> I'm still confused on what "withObject" does exactly
12:00:27 <jle`> Dynasty: does looking at the definition help?
12:00:30 <jle`> https://hackage.haskell.org/package/aeson-1.1.0.0/docs/src/Data-Aeson-Types-FromJSON.html#withObject
12:00:32 <jle`> it's mostly a helper function
12:00:37 <padre_angolano> jle`: I installed stack and it even works, but I can't figure out, does it use hackage or stackage? I can see that it created .stack/indices/Hackage, but not Stackage/. Is there a way to switch it to stackage?
12:00:42 <Dynasty> I specifically don't understand why the first parameter is a string
12:00:47 <Dynasty> what is the string even doing?
12:00:51 <jle`> padre_angolano: the resolvers come from stackage
12:00:52 <cocreature> Dynasty: it’s an error message
12:00:55 <monochrom> withObject is a non-essential convenience function.
12:01:00 <Dynasty> oh okay
12:01:43 <jle`> padre_angolano: the packages are hosted on hackage, and stackage is a bunch of self-consistant curated sets of hackage packages
12:02:20 <jle`> padre_angolano: when you use stack with a resolver (like lts-8.0), it'll use stackage to figure out what versions of your package are in lts-8.0, and then download them from hackage
12:02:44 <padre_angolano> jle`: aha, I see. And are the packages garanteed to build?
12:03:02 <jle`> yes, if they all come from the same resolver
12:03:11 <padre_angolano> jle`: I tried to do --package stream-fusion and it files to compile
12:03:25 <jle`> what's the error message?
12:03:45 <jle`> it is possible that stream-fusion has dependencies that aren't in the resolver you're using
12:03:54 <jle`> or also that you haven't initialized stack with stack setup?
12:05:55 <padre_angolano> jle`: I did stack setup. The error message is: Ambiguous occurrence ‘MonadPlus’ It could refer to either ‘GHC.Base.MonadPlus’, imported from ‘GHC.Base’ at Control/Monad/Stream.hs:80:1-15 or ‘Control.Monad.Stream.MonadPlus’ defined at Control/Monad/Stream.hs:124:1
12:06:36 <jle`> oh, sounds like an error with stream-fusion :|
12:06:51 <padre_angolano> jle`: also, if I look for stream-fusion on stackage it says "This package is not currently in any snapshots": https://www.stackage.org/package/stream-fusion
12:07:07 <padre_angolano> jle`: does it mean that if it's not in the snapshots it's not garanteed to build properly?
12:07:51 <jle`> in general packages might have compilation errors, i think snapshots only take care of dependency management
12:08:06 <jle`> the snapshots just guaruntee that the deps will all be self-consistent
12:08:27 <jle`> but it's up to the package maintainers to make sure that their packages actually compile properly, once given those dependencies, heh
12:08:38 <Tuplanolla> Is there a better way to write `oneThing = do {s <- get; a <- liftIO $ async $ runStateT otherThing s; ...}`?
12:08:41 <Luefer> I have some issues with ide-haskell in atom. Is this the place to look for help, or where can I turn?
12:08:46 <padre_angolano> jle`: aha, so this one is broken then...
12:09:11 <Tuplanolla> I basically want `oneThing = do {a <- magic async otherThing; ...}`.
12:09:31 <jle`> padre_angolano: it looks like i thasn't been updated since 2013, which was several GHC major releases ago
12:09:37 <lyxia> Tuplanolla: (liftIO . async . runStateT otherThing) =<< get
12:09:57 <monochrom> Use an IORef and get rid of StateT.
12:10:07 <Tuplanolla> That's not much better, lyxia.
12:10:12 <jle`> padre_angolano: the maintainer put (base < 5) as its dependency, assuming that all versions of base 4.* released in the future will work
12:10:17 <lyxia> :(
12:10:21 <padre_angolano> jle`: then I think I have to switch to vanilla Data.List instead of Data.List.Stream...
12:10:22 <jle`> padre_angolano: unfortunately that assumption did not pan out
12:10:26 <padre_angolano> jle`: thanks anyway :-)
12:10:34 <the_other_cat> Hello, I've got a constructor Foo which takes 3 arguments, and I've those arguments in a list. Since a constructor is a (curried) function, I thought I can do f = foldl Foo (map (\x -> $x) list) but this doesn't work. How can I achieve this?
12:10:56 <jle`> padre_angolano: no problem!  it is possible that the package is deprecated anyway
12:11:22 <reactormonk> the_other_cat, not that simple, since you probably want to handle the case where the list doesn't have three elements.
12:11:37 <jle`> the_other_cat: f [x,y,z] = Foo x y z
12:12:31 <jle`> the_other_cat: it's not really possible to achieve with a fold, because the type of your accumulator/folding function changes across each item
12:12:45 <the_other_cat> reactormonk: Sure, this is a side issue
12:13:00 <jle`> unless you have some sort of generic builder type wrapping Foo that keeps the type the same
12:13:05 <the_other_cat> jle`: Ah ok, makes sense
12:14:52 <Dynasty> jle`: Okay I wrote the cases here: http://pastebin.com/wW4Fs2eL but I'm getting an error on line 27. The error is: http://pastebin.com/p3y6se9J
12:15:02 <Dynasty> Do I need to put a type constraint somewhere?
12:15:28 <the_other_cat> jle`:  Didn't thought about the accumulator changing type. Thanks
12:16:35 <monochrom> You simply have a typo at line 27. <$ vs <$>
12:16:46 <monochrom> Err no, you're right.
12:17:09 <monochrom> You want to check that it's "hole : null"?
12:17:42 <Dynasty> I suppose I should do that
12:17:57 <Dynasty> right now it's just checking for the existence of the hole key
12:18:12 <monochrom> If you check that it's "null" one way or another, the type ambiguity disappears because you commit to one type.
12:18:50 <jle`> Hole <$ mfilter (== Null) (o .: "hole"), i suppose
12:20:00 <Dynasty> ah okay
12:20:06 <jle`> you can also annotate Hole <$ (o .: "hole" :: Parser Value)
12:20:15 <monochrom> Yeah
12:20:41 <jle`> but this is a weird schema in any case
12:21:10 <Dynasty> Thanks for the help :) this is probably the best programming IRC channel I've been on
12:21:33 <Dynasty> I agree that it's weird, but it kinda needs to be this way
12:23:36 <monochrom> It is not too bad actually.
12:25:02 <Dynasty> I'm working on a fine grain software repository system. So basically I've spliced this type everywhere in an AST definition so I can break the AST apart at any point
12:25:10 <Dynasty> and then link them together by hashing the parts
12:26:34 <Tuplanolla> There has to be a way to do this with `mapStateT` or something.
12:29:51 <monochrom> @type mapStateT
12:29:54 <lambdabot> (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
12:30:18 <johnw> ah, mapStateT is hoist & fmap
12:31:23 <Tuplanolla> I arrived at `magic = get >>= lift . f . evalStateT g`.
12:31:34 <Tuplanolla> Make that `magic f g = ...`.
12:35:30 <jle`> mixing . and >>=     ... :|
12:35:53 <SrPx> Stupid question warning, but what is the underlying logic of communication? When you have different objects / agents / processes / whatever that hold a state and interact through messages...
12:37:23 <monochrom> Then the processes are communicating.
12:38:24 <monochrom> Communicating is the underlying logic.
12:38:37 <monochrom> s/ting/tion/
12:56:37 <dmwit> SrPx: Some keywords for your Googling pleasure: pi calculus, calculus of communicating systems, process calculus
12:58:44 <johnw> dmwit: another one:  (Eli Zaretskii)
12:58:50 <johnw> another one: http://iris-project.org/
13:02:41 <SrPx> dmwit: thanks I actually expected those keywords, I still don't get pi calculus / process calculus from the few things I read ): maybe it is time to try again
13:03:06 <barrucadu> Also look up session types
13:04:18 <dmwit> Lambda calculus is what you get when you ask "what if the only thing you can do is functions". Pi calculus is what you get when you ask "what if the only thing you can do is communication channels".
13:05:33 <jle`> \me . o ( lambda calculus should have been called phi calculus )
13:05:34 <lambdamu> aren't there a lot of process calculi? is the pi calculus more standard than others?
13:05:51 * jle` has forgotten how to irc
13:06:27 <dmwit> Yes, there are a lot of process calculi. I don't know how to measure "standard", or what we would get by doing so.
13:08:55 <lambdamu> Hm, I'm not sure either I thought of the vanilla lambda calculus being somewhat standard as opposed to the variants which restrict e.g. beta-reductino
13:09:15 <lambdamu> to capture complexity bounds or things like that
13:09:54 <lambdamu> but maybe that's just how I think about it
13:10:40 <dolio> pi calculus is pretty late, apparently.
13:10:52 <dolio> Unlike lambda calculus.
13:11:05 <Tuplanolla> The type of the `magic` I defined is `(Monad m, Monad n) => (m a -> n b) -> StateT s m a -> StateT s n b`, which looks suspiciously like a monad morphism.
13:12:37 <jle`> Tuplanolla: looks closer to mapStateT
13:12:54 <Tuplanolla> I can't implement it in terms of `mapStateT` though.
13:13:17 <dolio> Are you sure it has that type?
13:13:26 <Tuplanolla> It seems that no matter what I do, I cannot modify the state itself.
13:14:01 <dolio> It's an odd type.
13:14:04 <dmwit> hoist :: Monad m => (forall a. m a -> n a) -> StateT s m b -> StateT s n b
13:14:16 <jle`> Tuplanolla: if you constrain it to be (forall a. m a -> n a), then you can get it to produce a monad morphism
13:14:17 <dmwit> https://hackage.haskell.org/package/mmorph-1.0.9/docs/Control-Monad-Morph.html#t:MFunctor
13:14:17 <jle`> yeah
13:14:49 <Tuplanolla> I originally wanted `(IO a -> IO (Async a)) -> StateT Universe IO a -> StateT Universe IO (Async a)`.
13:15:27 <Tuplanolla> Thus I cannot constrain it the way you suggest, jle`.
13:15:37 <jle`> :t \f g -> lift . f . evalStateT g =<< get
13:15:40 <lambdabot> (MonadState s (t m), MonadTrans t, Monad m1, Monad m) => (m1 a -> m b) -> StateT s m1 a -> t m b
13:15:49 <Tuplanolla> Yes, that's it.
13:15:54 <jle`> hm
13:16:42 <dolio> That's throwing away the state, though.
13:16:58 <Tuplanolla> I can't help that, dolio.
13:17:51 <jle`> yeah, then taking an 'StateT s m1 a' isn't really meaningful
13:18:06 <jle`> it's really taking an (s -> m a)
13:18:41 <dolio> That's why it's not a monad morphism (I think).
13:18:41 <jle`> what you really wrote is an (m a -> n b) -> (s -> m a) -> StateT s n b
13:18:58 <dolio> Well, one reason.
13:19:08 <Squarism> is there some wai middleware that deals with query strings?
13:19:24 <Squarism> im using spock and i cannot find any api method that gives med the query string
13:29:20 <SrPx> dmwit: that makes a lot of sense, I really need to study it, I hope I find good resources
13:29:38 <SrPx> In any case I'm not even sure this is what I really need, although it looks more and more like so
13:30:20 <SrPx> I made a quite long question on Stack Overflow and I do think the answer is something like: "use a type that involves session types / pi calculus / whatever" somehow... but I have no idea how that type would look like because I have no idea what session types / pi calculus really looks like
13:30:28 <SrPx> This is the question: http://stackoverflow.com/questions/42213854/what-is-an-appropriate-type-for-smart-contracts
13:50:39 <SrPx> but to summary this huge question
13:51:04 <SrPx> basically, I'm trying to figure out what is the best type to define smart contracts
13:51:29 <SrPx> I could create a "BlockchainIO" type which included common blockchain actions such as reading/writing to the blockchain state, and calling other contracts...
13:51:34 <SrPx> that would be too powerful though
13:52:24 <SrPx> I could say: "ok a contract is just a fold over a stream of actions"... i.e., `act :: User -> action -> state -> state`... that would be enough to implement any contract logic, but then contracts wouldn't be able to interact with eachother
13:52:57 <SrPx> so, that is too restrictive
13:53:17 <SrPx> I could enable cross-contract communication by allowing the contract to see the whole blockchain state, not just its own state, i.e., `act :: User -> action -> GlobalState -> state`
13:53:42 <SrPx> but then you'd need to build a communication protocol on top of that "ability to read a shared global state"
13:54:00 <SrPx> so at this point I noticed I'm pretty much reimplementing threads / agents / whatever
13:54:25 <SrPx> so I guess what I need is exactly that, a type that captures an "agent", i.e., some self contained process that can send messages
13:54:33 <SrPx> hmm yea I guess that is really what I need
13:54:50 <monochrom> If you know how to solve the "global clock" problem, then you may know how to solve the "global ledger" problem.
13:55:05 <SrPx> monochrom: what do you mean?
13:55:21 <monochrom> I mean what I wrote. The global clock problem.
13:55:28 <SrPx> what 
13:55:37 <SrPx> what clock? 
13:55:38 <johnw> monochrom: like, matrix clocks?
13:55:39 <monochrom> In distributed computing.
13:55:47 <SrPx> I don't even know what is the global clock problem
13:56:33 <lambdamu> basically how to synchronize time consistently
13:57:00 <SrPx> but yea, I think I could delete everything I just said, and that stackoverflow question, and just ask instead: how to correctly define Agents on Haskell? (i.e., self-contained processes which can send/receive messages through a pre-defined protocol)
13:57:19 <SrPx> that is probably the same problem I'm looking at
13:57:46 <SrPx> if "pi calculus" is the answer to that question then that is what I should look for... if not, something else
13:57:59 <lambdamu> Squarism: in spock you can define routes that include vars which capture parts of the url, do you mean that with query string?
13:58:16 <SrPx> that sounds like a very hard problem
13:58:31 <monochrom> No, at this point you have like 3 questions, each pair has a gap between, and you mistakenly think that they are 1 question.
13:59:12 <monochrom> For example there is a big gap between "I can have a communication network of processes" (threads in Haskell) and "they agree on a global ledger".
13:59:43 <monochrom> In fact that gap is almost like the whole field of research of distributed computing.
14:00:03 <dallen> the global clock problem was not solved by hardware?
14:00:08 <megaTherion> whats the proper way to get an (something) out of IO (something)?
14:00:10 <Squarism> lambdamu - i figured it out finally - wierdly enough, the "Param" type was defined in Scotty - the predecessor - just got totally confusing
14:00:31 <mmachenry> SrPx: I'm late to this conversation but doesn't an async reading an mvar model the pi calculus really well?
14:00:36 <monochrom> dallen: How to solve by hardware? Whose hardware?
14:01:07 <glguy> megaTherion: put the IO something on the right side of an <- in do-notation
14:01:12 <dallen> the cloock of the comuter plus the standard time synchroniaztion server
14:01:20 <monochrom> pi calculus is when you start having "MVar (MVar Something)", roughly
14:01:42 <lambdamu> Squarism: alright, but are using soctty now or spock?
14:01:50 <dallen> you attach a time to each event 
14:01:58 <Squarism> lambdabot, spock
14:01:59 <lambdamu> Squarism: i'm confused :D
14:02:09 <monochrom> "the standard time synchroniaztion server" is not purely hardware. Plus what if that server goes down?
14:02:15 <SrPx> monochrom: yes I really don't know what I'm talking about sorry about that, hopefully someone will shed some light and help me organize my thoughts
14:02:33 <dallen> so you have a repeatable sequencing of events
14:02:50 <lambdamu> Squarism: shouldn't depend on anything in scotty, but you figured it out, so i guess its alright
14:03:47 <dallen> since the clocks of the computers that produce the events are synchronized clocks
14:03:53 <dallen> have
14:04:11 <dallen> relativistic effects not considered
14:04:32 <johnw> dallen: assuming "global time" is not good enough.  I'm dealing with this very problem right now, where the clocks are embedded in sensors coming from all over the place; there is no "back-communication" to send a synchronization signal
14:04:58 <Tuplanolla> People are discussing timekeeping. My heresy sense tingles again.
14:05:00 <johnw> the best I can know is that each sensor can yield a reliable delta between events
14:06:10 <dallen> johnw: in most problems a perfect synchronization is not necessary. It is just necessary that the sequence of events be repeatable
14:06:37 <johnw> I don't see how that relates to your comment about global time
14:08:02 <dallen> time 
14:08:45 <SrPx> I love when I make a question that is so misguided it starts a whole philosophical debate that has nothing to do with I wanted to ask 
14:09:20 <monochrom> "time, the final frontier"? "Star Trek: Chronodyssey"
14:09:24 <megaTherion> glguy: ah right, thanks
14:09:48 <Sornaensis> today I did graph theory with haskell
14:09:50 <SrPx> also, nothing sucks more on programming than being so clueless about something you don't even know what to ask :) 
14:09:52 * Sornaensis drops the mic
14:09:59 <megaTherion> glguy: what does it basically mean, return the final result from an unsafe context (the IO monad)?
14:10:11 <monochrom> Sornaensis: How do you do graph theory in Haskell?
14:10:17 <glguy> megaTherion: I don't understand your question
14:10:25 <Sornaensis> monochrom: invariant delimiting
14:10:41 <monochrom> What is that?!
14:10:59 <megaTherion> glguy: I mean by doing 'a <- foo'
14:11:09 <SrPx> Sornaensis: ha I do it every single day. Specifically, the directed acyclic graphs branch of graph theory
14:11:15 <monochrom> IO is not unsafe.
14:11:24 <dallen> a label with time + node identifier, assures that the sequence can be replayed , no matter if the clocks are not synchronized
14:11:27 <max3> is there a way to use Setup.hs with stack?
14:11:30 <dmwit> megaTherion: `a <- foo; e` means `foo >>= \a -> e`
14:11:35 <megaTherion> ok then I still dont understand it, I thought IO in general is unsafe ^^
14:11:38 <tdammers> monochrom: fsvo "safe"
14:11:57 <megaTherion> (unsafe as in not pure functional, eg. has side effects)
14:11:59 <tdammers> but the same goes for lists, records, etc.
14:12:07 <tdammers> IO does not have side effects
14:12:19 <dmwit> megaTherion: `(>>=)` is one of the functions that turns consumers of pure values into consumers of `IO` values.
14:12:37 <monochrom> megaTherion you probably need to read my http://www.vex.net/~trebla/haskell/IO.xhtml
14:12:41 <tdammers> IO merely describes effects; they're effects, not side effects
14:13:02 <monochrom> Also, synonymizing "unsafe" with "effects" is too much a stretch.
14:13:31 <monochrom> Also, all side effects are bugs.
14:13:48 <tdammers> monochrom: including timing side channels?
14:14:01 <monochrom> If I write 'main = putStrLn "hello"', there is no side effect, there is just an intended effect.
14:14:27 <dallen> paradoxically you can exhaust the memory of the computer in a side effect free way
14:14:28 <monochrom> Oh, maybe, I am not good at those exploits.
14:14:52 <tdammers> dallen: only with partial functions >:->
14:15:17 <megaTherion> monochrom: indeed, I'll read it
14:15:37 <Prutheus> jaspervdj are you here?
14:28:26 <nilof_> I'm trying to figure out the peak memory overhead of this quicksort with lazy evaluation:     quicksort [] = []
14:28:26 <nilof_>     quicksort (x:xs) = (quicksort $ filter (< x) xs) ++ [x] ++ (quicksort $ filter (>= x) xs)
14:29:23 <nilof_> It will only compute the second half of the expressions when those elements are requested, right?
14:30:24 <monochrom> Yes.
14:31:37 <benzrf> nilof_: im given to understand that what you just pasted completely misses the point of quicksort, or something
14:31:57 <nilof_> I know, I posted it because I've seen it posted elsewhere
14:32:20 <monochrom> Different people attribute different, conflicting "the point of quicksort".
14:32:37 <monochrom> It only ends in religious wars.
14:32:39 <glguy> Fortunately the nature of quicksort is irrelevant to the question of understanding laziness
14:33:23 <maerwald> probably referring to the argument that quicksort is only quicksort with in-place mutation
14:34:01 <monochrom> I am going to start a religion that says "in-place bubble sort qualifies as quicksort too because the main point is in-place"
14:34:07 <codedmart> Anyone here familiar with resource-pool? I am using that for database connections, but I have a query that sits and waits for changes. So it can be waiting for long periods of time. Resource-pool has a reaper function that closes any resources that have been left idle for too long.
14:34:09 <nilof_> right, in imperative languages it's often cheaper to just copy a linked list to array, use in-place quicksort on that, and convert it back to linked list
14:34:41 <maerwald> monochrom: mind you, you need followers as well, otherwise it doesn't qualify as a religion, just some old mans delusion :P
14:35:07 <monochrom> yes that's the hard part.
14:36:41 <nilof_> I'm mainly unsure about how lazy immutable concats work
14:37:14 <nilof_> with strict semantics it would have to copy the first list
14:37:26 <monochrom> My serious point of view comes from Doug Smith. He unifies quicksort, mergesort, insertion sort into one family.
14:37:54 <dmwit> It has to copy the first list whether the semantics is strict or not.
14:37:58 <benzrf> nilof_: if you're asking about at the implementation level: thunks
14:38:02 <monochrom> They are all divide and conquer sorting. You just change how you divide, and you can get any of the three.
14:38:15 <benzrf> nilof_: semantically, though, it's term simplification
14:38:23 <Tuplanolla> Are you referring to viewing sorting algorithms as circuits, monochrom?
14:38:26 <monochrom> Insertion sort is when your divide is xs = y:ys
14:38:30 <monochrom> No.
14:38:33 <dmwit> Lists are immutable. The whole concatenation is not the same as the first part of the concatenation. Therefore...
14:38:45 <nilof_> right, but it doesn't have to compute the whole first list to produce the first elements of the copied list
14:38:54 <monochrom> Mergesort is when you just cut the input list into two halves, and now you have a non-trivial recombination.
14:39:00 <dmwit> nilof_: correct
14:39:19 <monochrom> Quicksort is when you have a non-trivial divide, and you buy a trivial recombination.
14:39:53 <monochrom> From this point of view, "list vs array" and "mutation vs immutable data structure" are implementation details.
14:40:44 <Tuplanolla> Right. The circuit view unified insertion sort and selection sort instead.
14:40:49 <benzrf> nilof_: approach it from the viewpoint of term simplification (albeit with sharing)
14:41:16 <erisco> monochrom, why is the mergesort recombine nontrivial?
14:41:28 <erisco> this is just merging two sorted lists
14:41:28 <monochrom> Because the divide is trivial? :)
14:41:35 <benzrf> nilof_: suppose i say `quicksort [3, 1, 2, 5, 6]' 
14:41:49 <dmwit> erisco: Because it calls `compare`.
14:41:58 <monochrom> "non-trivial" just means "it is not simply concatenation or cut-in-the-middle"
14:42:03 <erisco> I mean, okay, concatenating two lists in quicksort is even simpler
14:42:07 <dmwit> monochrom: I like my definition better.
14:42:21 <erisco> okay, heh :P
14:42:23 <monochrom> Err sorry, where is your definition?
14:42:27 <benzrf> nilof_: simplifying, i get quicksort (filter (< 3) [1, 2, 5, 6]) ++ [3] ++ quicksort (filter (>= 3) [1, 2, 5, 6])
14:42:39 <dmwit> monochrom: "nontrivial" = "uses the comparison"
14:42:57 <monochrom> erisco: More seriously, in mergesort, the real comparisons happen during the recombination, so it is the non-trivial part.
14:43:12 <monochrom> Oh! Yes, what dmwit says then.
14:43:21 <benzrf> nilof_: the outermost expression is now a call to (++) - do you know the definition of (++)
14:43:51 <erisco> I was moreso thinking of what the easy and difficult parts to understand are
14:44:00 <erisco> since there are some sorts which have those gradients
14:44:29 <ubsan> benzrf: isn't it the increment operator :3
14:44:42 <benzrf> ubsan: shoosh
14:44:44 <nilof_> so lets see, pick out 3, go through and copy 1,2, ignore 5, 6, copy to list, recur quicksort, lazily feed result into first ++
14:44:54 <erisco> the in-place increment operator at that
14:45:04 <benzrf> nilof_: no "copies" here
14:45:10 <benzrf> nilof_: we are just simplifying terms
14:45:20 <monochrom> erisco: Sometimes easy vs hard to understand is a function of the explanation approach.
14:45:50 <monochrom> So for example when I first learned quicksort and mergesort, both were hard. That was before I read Doug Smith's unifying point of view.
14:45:57 <erisco> well I think you human enough to sometimes be talking in non-technical terms
14:46:27 <dolio> Now go learn about smooth sort.
14:46:32 <monochrom> Doug Smith's made both so easy to understand and so connected too.
14:46:39 <nilof_> It's kind of hard to consider memory overhead without trying to keep track of what needs to be copied
14:46:42 <monochrom> I.e., you never thought there were duals.
14:46:50 <monochrom> s/there were/they were/
14:47:45 <dolio> Actually, smooth sort isn't that hard to understand, I guess. Just Dijkstra doesn't know how to make it easy to understand. :)
14:47:50 <benzrf> nilof_: there's no copies going on, exactly - not semantically, at leas
14:47:52 <benzrf> t
14:47:57 <monochrom> erisco: I am a lazy human. Often my "non-trivial" is very lazy-human in "now I guess I have to get things done"
14:48:28 <monochrom> Hrm what does smooth sort do?
14:48:43 <dolio> It builds a heap, but not in the way that normal heapsort does.
14:49:33 <dolio> And Dijkstra's technique for trying to make it understandable is to show you 4 or so versions of the algorithm with various details removed.
14:49:50 <dolio> But I didn't understand it until I read some other paper that explains what was going on overall.
14:49:52 <monochrom> Yikes, Leonardo numbers are involved. It is complicated!
14:49:59 <nilof_> but let's see, ++ is defined as x:xs ++ y =  x:(xs ++ y) and [] ++ y = y right? With first half being tail recursive modulo cons?
14:50:54 <dolio> monochrom: Actually, it doesn't just build a heap, it builds a forest of heaps.
14:50:57 <benzrf> nilof_: "tail recursive modulo cons" isn't tail recursive at all, but yeah
14:51:06 <Tuplanolla> You can't easily reason about memory overhead, because the strictness analyzer may remove some of it, nilof_.
14:51:09 <benzrf> nilof_: you may find this fun to play with btw http://chrisuehlinger.com/LambdaBubblePop/
14:51:28 <dolio> And the Leonardo numbers are important because you can always build a new heap by combining two heaps and one element.
14:52:39 <dolio> monochrom: It's also related to number-systems-as-trees that Okasaki likes.
14:53:03 <dolio> So you could use any number system that had that 'no carries during incrementing' property, I think.
14:53:07 <dolio> Like skew binary.
14:54:06 <dolio> And Dijkstra recognized that, and his rationale for using Leonardo number was basically, "I like Leonardo numbers better."
14:55:18 <monochrom> haha
14:55:30 <nilof_> https://wiki.haskell.org/Tail_recursion
14:56:07 <monochrom> "Tail call" loses its significance when you do lazy evaluation.
14:56:29 <benzrf> ^
14:56:57 <nilof_> but when you call an element of a lazy list, you evaluate that cons cell, right?
14:57:13 <benzrf> what do you mean by "evaluate that cons cell"
14:57:55 <monochrom> If you said "evaluate until a cons cell is exposed", I would agree. But you didn't say that.
14:57:57 <nilof_> evaluate head, set tail to a lazy call to (xs ++ y) in the example above
14:58:12 <monochrom> No, the head may stay unevaluated.
14:58:25 <monochrom> Consider "take 3 (repeat undefined)"
14:58:53 <monochrom> No, consider "length (take 3 (repeat undefined))"
14:59:24 <nilof_> oh dear god, that second example
14:59:42 <nilof_> thanks for showing me that
14:59:48 <Tuplanolla> He's saying that you go from `thunk1` to `thunk2 : thunk3` first, nilof_.
15:00:16 <dolio> If the first case is a tail call to anything, it's a tail call to (:).
15:01:37 <benzrf> bbl
15:02:54 <dolio> Which is how the operational semantics go in GHC. All the calls (excluding funky low-level stuff) are tail calls to the outer-most function.
15:05:12 <monochrom> Although, when that outermost function is a fully-applied data constructor, there is not much to do.
15:05:24 <dolio> Yeah.
15:05:58 <monochrom> "I am (:) and I am tautologically in WHNF, thank you for calling" basically.
15:06:57 <dolio> At that point you'd switch to walking back through the update/pattern-match stack.
15:07:32 <monochrom> Of course, in reality, that is not the end of the story, there is always an even outer caller who now says "Good, now I want to evaluate your first field".
15:12:39 <nilof_> so lets see, if I use nth to call a given element of a lazy list, the elements before it don't have to be evaluated?
15:13:01 <monochrom> Right.
15:13:20 <monochrom> > [undefined, undefined, (), undefined] !! 2
15:13:22 <lambdabot>  ()
15:13:23 <nilof_> Now I'm kind of curious to know if this quicksort implements some variation of quickselect if you only call nth on it
15:13:46 <monochrom> But < and >= usually end up evaluating elements.
15:14:35 <monochrom> If you do so much as "filter (<) the whole bloody list" you have evaluated all elements, in realistic cases.
15:17:12 <monochrom> No, maybe not.
15:19:51 <monochrom> OK, yes it will, because even if you just ask "head (qs whatever)" you have to examine the whole list.
15:20:28 <monochrom> I'm just wondering now what happens to "length (qs whatever)"
15:20:47 <glguy> as defined above, at least, it has to sort the whole list
15:21:38 <monochrom> Yeah, unfortunately even to just count the cons cells, the algorithm still have to finish all comparisons before it decides to give you the cons cells!
15:22:17 <monochrom> Space footprint is a very difficult question.
15:22:22 <glguy> You could add a layer of something [] _ = []; something (x:xs) ~(y:ys) = y : something xs ys
15:23:06 <glguy> and then: qs (x:xs) = let (l,r) = partition (<x) xs in something l (qs l) ++ [x] ++ something r (qs r)
15:23:27 <monochrom> :S
15:28:10 <monochrom> Probably still linear space, but with a pretty high constant. (A thunk is not cheap.)
15:34:34 <max3> anyone have any ideas off of the top of their why i might be getting linker errors (undefined reference) even though i have the libraries, after using Setup to make a make executable?
15:34:59 <max3> and they're (the headers) all in the right places
15:39:18 <eacameron> does anyone know of a http client that can connect through socks5 proxies?
15:52:05 <mmachenry1> I'm about to create a bunch of small repositories implementing code for exercises from a text book. It'd like to manage it with stack but it doesn't seem well suited. Looking for advice. 
15:52:30 <mmachenry1> I think it'd be good to have a subdirectory in my repo for each chapter and implement the code and unit tests all within that subdir.
15:53:02 <mmachenry1> But creating a new stack direcotory with a new name and new stack.yaml and cabal file seems like overkill.
15:54:13 <mmachenry1> But then if I do it all as one stack project, it's hard to separate the chapters into directories. I can't easily name them 03-Foo since that's not going to be a good Haskell module directory name. The tests are going to be all together in a separate directory.
15:54:52 <excelsiora> hi
15:55:23 <dfeuer> mmachenry1: why not stack? Not saying you should use it; just curious why not.
15:55:31 <dfeuer> Another option is just plain old cabal-install.
15:55:45 <dfeuer> People also like to mix cabal-install with nix, I think.
15:56:02 <dfeuer> Although cabal new-install may be obviating that.
15:56:11 <mmachenry1> dfeuer: I am trying to use stack
15:56:17 <mmachenry1> But the reason are in what I wrote.
15:56:49 <dfeuer> mmachenry1: you can make a stack project with multiple packages in it.
15:56:52 <mmachenry1> I want to use stack for the ease of building and testing reproducible builds. It's also just nice to have stuff in that system.
15:56:57 <dfeuer> I think you can now do the same with cabal-install.
15:57:28 <mmachenry1> Would I have a .cabal file in each subdirectory?
15:57:54 <mmachenry1> Would I need to have a stack.yaml file for every subdir or could it be for everything?
15:57:59 <dfeuer> For the stack thing, I think so. I think Cabal has a new thing, but I don't know how that works.
15:58:03 <dfeuer> No, just one stack.yaml.
15:58:15 * dfeuer is REALLY not an expert at this stuff.
15:58:52 <dfeuer> I like how stack can install GHC for you, and the curated package sets are cool, but stack documentation .... kind of sucks IMO.
15:59:27 <glguy> Independent of what tool you build with, you can still build a single "package" and use subdirectories per chapter
15:59:49 <dfeuer> Oh, that's true too.
15:59:52 <dfeuer> Forgot about that.
15:59:54 <glguy> You'd just have Exercises/Chapter1.hs, Exercises/Chapter2.hs
15:59:57 <dfeuer> Multiple source directories.
16:00:10 <glguy> If you need some support modules you can have Exercises/Chapter1/StuffINeed.hs
16:00:33 <glguy> the heirarchical modules map to directories
16:00:56 <dfeuer> Tthat too!
16:00:59 <dfeuer> Buh.
16:01:15 <dfeuer> mmachenry1: listen to glguy. He's much more an expert.
16:03:20 <glguy> If you really want to isolate the packages per chapter you can have one chapterX.cabal per subdirectory and then have a stack.yaml that builds all of those packages.
16:03:55 <mmachenry1> glguy: I think that's likely what I'd want.
16:04:19 <mmachenry1> I am not psyched about having a bunch of .cabal files I guess. 
16:04:44 <glguy> Well, only do it if you want the flexibility it provides
16:04:50 <mmachenry1> But it seems better to have the entire chapter with all tests and code and docs in one place.
16:04:51 <glguy> otherwise use a single one
16:05:33 <mmachenry1> Maybe I could do something rather non-standard with the cabal file and have just one.
16:18:54 <mmachenry1> glguy: I'm trying to mock up what I roughly want it to be like and update the github repo
16:26:43 <mmachenry1> glguy:  https://github.com/mmachenry/tapl 
16:27:23 <mmachenry1> The cabal file is now out of date with how I arranged the files. I think I should probably make a library, executable, and test entry for each chapter? 
16:27:34 <mmachenry1> Seems verbose but that might be the easiest way to do it.
16:34:47 <MarcelineVQ> I see from your module names that it used to be arranged by subfolders in src, is there a reason you don't want to do that now?
16:36:59 <mmachenry1> MarcelineVQ:  It might be a good idea.
16:37:20 <mmachenry1> You mean 04-arith/src/Ast.hs as well as 04-arith/tests/AstSpec.hs perhaps? 
16:37:44 <mmachenry1> I considered it might be overkill but it's probably better to do it that way.
16:37:57 <MarcelineVQ> no I​ meant how it was originally, but I see in the scrollback "<mmachenry1> But it seems better to have the entire chapter with all tests and code and docs in one place." seperate .cabal files like was suggested seems like the best if you want all of that seperated
16:38:16 <mmachenry1> Would you make a library entry in the cabal file and executable and test for every single chapter?
16:39:05 <mmachenry1> MarcelineVQ: Yeah maybe that's easier. Can stack manage that with one stack.yaml? 
16:39:22 <mmachenry1> Or should I just make these totally independent packages?
16:39:35 <mmachenry1> And what about making it easy to share some code between them?
16:40:30 <dmwit> Sharing code between packages just means making another package. =)
16:42:10 <MarcelineVQ> yes stack can, and if you list them off in the stack-yaml packages section you should be able to have them depend on each other in their .cabal files if you want to share code   https://docs.haskellstack.org/en/stable/GUIDE/#multi-package-projects
16:43:15 <MarcelineVQ> But imo this kind of arrangement is a bit much for homework :>
16:45:56 <dfeuer> Hrm.. I wanted to ask twanvl about some design decisions relating to Functor/Foldable/Traversable deriving.
16:45:59 <dfeuer> Keep forgetting.
16:47:47 <mmachenry1> MarcelineVQ: Yeah it's a bit much. I keep coming back to that.
16:47:55 <mmachenry1> I'll take a look now. Thanks.
17:12:39 <Sornaensis> >> (-6)^(1/2)
17:12:44 <Sornaensis> > (-6)^(1/2)
17:12:48 <lambdabot>  error:
17:12:48 <lambdabot>      • Could not deduce (Integral b0) arising from a use of ‘^’
17:12:48 <lambdabot>        from the context: Num a
17:12:55 <Sornaensis> > (-6)**(1/2)
17:12:58 <lambdabot>  NaN
17:16:09 <geekosaur> > (-6:+0)**(1/2)
17:16:13 <lambdabot>  error:
17:16:13 <lambdabot>      Precedence parsing error
17:16:13 <lambdabot>          cannot mix prefix `-' [infixl 6] and ‘:+’ [infix 6] in the same infi...
17:16:21 <geekosaur> sighy, unary int
17:16:27 <geekosaur> > ((-6):+0)**(1/2)
17:16:31 <lambdabot>  1.4998798865218462e-16 :+ 2.449489742783178
17:23:40 <monochrom> > sqrt ((-6) :+ 0)
17:23:43 <lambdabot>  0.0 :+ 2.449489742783178
17:23:49 <monochrom> :)
17:24:03 <monochrom> (Accuracy pissing war!)
17:24:17 <monochrom> (Oh wait, that actually exists.)
18:23:38 <kakashiAL> this is a little javascript parser project that I did:
18:23:41 <kakashiAL> https://paste.xinu.at/M3v/
18:24:16 <kakashiAL> I had to transfrom the data this way and I would like to know if there is a cleaner way
18:24:24 <kakashiAL> and how you would do that in haskell
18:26:55 * markasoftware sees haskell and javascript in the same sentence, promptly dies
18:29:26 <geekosaur> ghcjs :p
18:30:07 <Welkin> I write javascript all day
18:31:18 <kakashiAL> Welkin: my way looks kinda dirty and I would like to know if you know a cleaner haskell way
18:36:43 <Welkin> kakashiAL: you can zip the two arrays together (merge the objects where the `id` fields are equal)
18:37:11 <Welkin> then you can simply map over it to get your "csv" formatted array
18:37:28 <Welkin> and prepend the column names to the front when you are done
18:38:07 <Welkin> using a utility library will be very helpful because the builtin functions in javascript suck
18:38:15 <Welkin> lodash at least, ramda would be better
18:39:34 <Welkin> kakashiAL: http://ramdajs.com/docs/#zipWith
18:40:01 <Dynasty> is there any sort of heuristic I should use when deciding between using the lazy and strict version of a monad?
18:40:14 <Dynasty> like right now I'm just randomly picking one
18:40:18 <Welkin> strict if you need all the data eventually
18:40:28 <Welkin> if you mean strict/lazy map, for example
18:40:39 <Dynasty> State monad
18:46:31 <c_wraith> the funny thing about state is that neither variant tracks the state strictly. 
18:47:43 <c_wraith> if you do a bunch of modify (+1) operations, for instance, the state becomes a big string of thanks. 
18:47:49 <c_wraith> .. *thunks 
18:48:32 <EvanR> this is specifically State 
18:48:41 <EvanR> or does it also apply to StateT
18:49:02 <c_wraith> both. 
18:49:11 <EvanR> o_O
18:49:50 <c_wraith> I think a strict version of modify was added sometime to account for that. 
18:50:54 <c_wraith> but that can only work in strict state. 
18:54:02 <EvanR> laziness is good when you might not look at the result
18:54:32 <EvanR> with state, it seems almost certain you will be looking at the result, in order to modify the state
18:55:36 <EvanR> if you dont look at it, then you certainly have this string of updates
18:55:41 <EvanR> for no reason!
19:01:36 <DemiMarie> Okay so I am now getting linker errors installing pandoc.  Should I just wipe my .cabal directory and start over?
19:01:54 <Welkin> DemiMarie: use stack or nix
19:02:21 <DemiMarie> Welkin: Is cabal unsupported?
19:02:49 <Koterpillar> DemiMarie: what kind of linker errors?
19:03:00 <DemiMarie> I seem to get linker errors (of form "cannot find -lHS...") for several packages.
19:03:02 <Welkin> cabal is used by everything
19:03:24 <Koterpillar> DemiMarie: package conflicts, "reinstalls are dangerous", you are getting bitten by this
19:03:34 <DemiMarie> Koterpillar: What shoud I do about this?
19:03:49 <Koterpillar> either of: wipe ~/.cabal; use cabal sandboxes; use stack
19:04:00 <Welkin> use cabal lunchboxes :D
19:04:22 <Welkin> easiest solution: use stack
19:04:29 <Welkin> best solution: use nix
19:04:43 <Koterpillar> easiest solution would be to get a pre-compiled pandoc
19:05:19 <Koterpillar> Welkin: why are you not on #nix? :P
19:05:44 <Welkin> Koterpillar: forgot about it
19:06:30 <DemiMarie> Koterpillar: Got it.  Wiped ~/.cabal and am starting over.
19:06:57 <DemiMarie> Fortunately my cabal is statically linked so I could just copy the cabal binary away.
19:09:34 <c_wraith> DemiMarie, you need to remove ~/.ghc
19:10:00 <c_wraith> that's where packages actually are installed to
19:10:38 <DemiMarie> c_wraith: Doing that now.
19:10:48 <DemiMarie> cabal really needs to be a proper package manager
19:11:13 <c_wraith> I think the new-build stuff is a better direction. 
19:11:33 <c_wraith> allow simultaneous installs with different dependencies, and just work right. 
19:11:35 <DemiMarie> c_wraith: Can you explain?
19:11:41 <DemiMarie> Do you mean backpack?
19:12:02 <c_wraith> no, backpack is a system for parameterized modules. 
19:12:11 <c_wraith> I mean cabal new-build
19:12:40 <c_wraith> which happily installs any number of copies of the same package, and uses the right one. 
19:13:02 <ezyang> yeah, you basically shouldn't use cabal install for anything complicated 
19:13:11 <c_wraith> (where "right" is defined by the its dependencies) 
19:13:43 <DemiMarie> c_wraith: How can I use cabal new-build for installation?
19:14:06 <c_wraith> I haven't used it yet. it's still experimental. 
19:14:49 <c_wraith> ezyang, are you working on new-build stuff, or just backpack? 
19:14:57 <ezyang> both haha 
19:15:01 <Welkin> what is backpack?
19:15:04 <ezyang> because Backpack is only supported on new-build 
19:15:14 * hodapp listens carefully, being clueless about Backpack
19:15:24 <Welkin> and why doesn't it have a yiddish name?
19:15:37 <ezyang> Welkin: http://blog.ezyang.com/2014/08/whats-a-module-system-good-for-anyway/ 
19:15:46 <ezyang> also https://github.com/ezyang/ghc-proposals/blob/backpack/proposals/0000-backpack.rst 
19:15:56 <hodapp> Welkin: ...are Yiddish names common here?
19:16:03 <c_wraith> and the name isn't Yiddish because ezyang isn't snoyman
19:16:08 <Welkin> hodapp: cabal, yesod, keter
19:16:09 <Welkin> o.o
19:16:10 <Welkin> lol
19:16:24 <ezyang> nothing wrong with yiddish :) 
19:16:52 <hodapp> not all systems handle the right-to-left of Hebrew characters properly though
19:17:11 <Welkin> yiddish isn't written with hebrew characters
19:17:58 <hodapp>  אַ שפּראַך איז אַ דיאַלעקט מיט אַן אַרמיי און פֿלאָט 
19:18:10 <Welkin> it can be
19:18:33 <hodapp> dang. that didn't do right-to-left properly
19:18:56 <Koterpillar> maybe in your client
19:19:06 <siddhu_> Can someone rewrite this with a bit more lens flavor added: let f a bs = any (==True) . fmap (\b -> a^._1 == b^._1 && a^._2 == b^._2) $ bs
19:19:26 <siddhu_> Can someone rewrite this with a bit more lens flavor added: let f a bs = any (==True) . fmap (\b -> a^._1 == b^._1 && a^._2 == b^._2) $ bs
19:19:45 <siddhu_> whoops, didn't mean to double post
19:19:47 <Koterpillar> siddhu_: any (== True) === any
19:20:07 <Welkin> Koterpillar: you're going to confuse the javascript users
19:20:27 <hodapp> Welkin: https://en.wikipedia.org/wiki/Yiddish_orthography indicates it is, but English transliterations are okay too I guess :|
19:20:31 <Koterpillar> I don't have the triple equality thingie
19:20:42 <Koterpillar> handy
19:20:52 <siddhu_> Koterpillar: any needs an argument, right?
19:21:08 <Welkin> any checks if any of th items in a list are True
19:21:09 <Koterpillar> siddhu_: oh, sorry, but it's still (any id)
19:21:17 <Koterpillar> :t or
19:21:19 <lambdabot> Foldable t => t Bool -> Bool
19:21:23 <Koterpillar> any id === or
19:21:32 <Welkin> stop that o.o
19:21:48 <Koterpillar> any id ≡ or
19:21:53 <Welkin> better
19:21:53 <siddhu_> Oh yes. any id .. or works too
19:22:33 <Koterpillar> sadly, don't know how to simplify the lenses
19:22:53 <Koterpillar> but everything else has room for improvement
19:23:06 <DemiMarie> Still get the same error.
19:23:14 <Koterpillar> DemiMarie: post full error
19:23:31 <Koterpillar> siddhu_: why don't you start with any (\b -> ...)?
19:23:32 <DemiMarie> /usr/bin/ld: cannot find -lHSzip-archive-0.3.0.5-HM6o894lYQNK65fW2sO25J-ghc8.0.2
19:23:37 <hodapp> "Mixin libraries can have signatures which permit implementations of values and types to be deferred, while allowing a library with missing implementations to still be type-checked." that sounds very needed
19:24:10 <Koterpillar> DemiMarie: did you remove .ghc? post full build log
19:24:15 <Welkin> DemiMarie: did you remove ~/.ghc and ~/.cabal ?
19:24:20 <Welkin> and reinstall with stack?
19:24:22 <siddhu_> Koterpillar: perfect! That's exactly what I needed. Thank you!
19:24:31 <DemiMarie> Welkin: removed those dirs, but didn't try stack
19:24:54 <Welkin> DemiMarie: https://docs.haskellstack.org/en/stable/README/#quick-start-guide
19:25:25 <Koterpillar> DemiMarie: stack is indeed a good choice, but I'll still ask, why are you building pandoc at all?
19:26:05 <DemiMarie> Koterpillar: I just wanted to install an up-to-date version, so I ran `cabal install pandoc` like I would for any other Haskell program
19:27:08 <Koterpillar> do consider stack
19:28:01 <DemiMarie> Koterpillar: installing now
19:33:52 <schoppenhauer> hi. I am currently trying to understand machines. I read https://dl.dropboxusercontent.com/u/4588997/Machines.pdf and on page 10, there is a definition of Step k o r. I do not understand the role of k o and r. or the semantics of Yield and Await in that case.
19:33:57 <schoppenhauer> can somebody help me?
20:27:04 <knx32542> Hi all, does anyone know how to `curl` a webpage with a restrictive robots.txt?
20:27:38 <Welkin> robot.txt is only for web crawlers
20:27:48 <Welkin> it doesn't stop anyone from doing anything
20:27:48 <knx32542> I am using curl's curlGetString, and have tried changing the user-agent, but I still get a blocked copy of the disired page.
20:27:56 <Welkin> it is like a sign that says "keep off the grass"
20:28:02 <Welkin> you can still step on the grass
20:28:49 <Koterpillar> knx32542: a good starting point is "Copy as cURL" in Chrome
20:28:56 <Welkin> anyway, this is not the channel to ask about that in
20:29:20 <knx32542> Welkin: That is what I thought, but for some reason just using curlGetString still yields the undesired HTML. I assumed it was due to a robots file, as the output mentions robots in a meta tag.
20:29:32 <knx32542> Koterpillar: Will do!
20:31:36 <knx32542> Welkin: Sorry, I just thought that this was the channel because I was using the haskell bindings.
20:46:16 <jchia1> lens question: How do I compose a `Lens' a (b, c)` from `Lens' a b` and `Lens' a c`?
20:47:17 <jchia1> Given a lens that lets me extract b and a lens that lets me extract c, I want to make a lens that extracts (b, c)
20:47:53 <pikajude> (view lensB thing, view lensC thing)
20:48:05 <jchia1> pikajude: But that's not a lens
20:48:13 <pikajude> nope
20:49:08 <johnw> jchia1: https://stackoverflow.com/questions/36521208/how-to-make-the-product-of-two-lenses
20:49:13 <johnw> it's not possible generally
20:54:07 <johnw> it's sort of fun trying to write it anyway
20:54:16 <jchia1> The context is oKey & oLastModified from Network.AWS.S3. The library writer exposed some fields using lens. I don't know why he exposes fields using lens, but whatever reason he has, using (view ..., view ...) will 'unlens' things -- downstream I will stop using lens to access things and I will lose the composability that's supposed to come with lens. So generally, if I want a projection of fields, I can't use lens?
20:55:44 <johnw> your question isn't quite clear enough for me to understand
20:55:48 <johnw> there are other things you can do
20:56:55 <jchia1> My question is mainly "What are the benefits of using lens for library interface, like oKey & oLastModified from Network.AWS.S3"?
20:57:20 <johnw> if it's just record accessors, 1 level deep, then there's almost no benefit
20:57:21 <Welkin> I don't like the fact that the amazon library uses lens
20:57:38 <johnw> plus, you can always just use the record accessors
20:58:06 <jchia1> i can see lens composing depth-wise, but it doesn't do field projection
20:58:15 <johnw> what do you mean by field projection?
20:58:22 <jchia1> select a subset of the fields
20:58:28 <jchia1> like what i'm trying to do right now
20:58:43 <johnw> why do you want to do that?
20:58:45 <jchia1> I have an S3 Object, and I want to extract the oKey & oLastModified values into a pair
20:59:01 <johnw> but you want them extracted in a way that allows you to change them?
20:59:14 <Welkin> there is nothin you can't do with lambdas
20:59:15 <johnw> because you can definitely have a *Getter* that projects two fields
20:59:24 <johnw> you just can't have a *Lens* 
20:59:25 <jchia1> i don't need to change them, but if it's not lens, maybe the syntax will be more concise
20:59:55 <jchia1> with lens, i have to have a 'view' for each field i want to extract
21:00:13 <jchia1> seems quite long-winded
21:05:09 <johnw> jchia1: https://github.com/ekmett/lens/issues/315
21:05:25 <johnw> maybe it will work for your getter case
21:05:57 <buttons840> i'm doing some parsing with trifecta; is there a better way to skip a single character than `_ <- char 's'` ?
21:06:06 <`Guest00000> is there Haskell98 -> Haskell2010 compiler?
21:06:11 <johnw> char 's' *> ...
21:06:21 <Squarism> it feels sortof hard learning haskells indentation rules
21:06:43 <Squarism> are there any failsafe material available on that?
21:07:07 <kadoban> They're a little intricate. The report isn't too bad if you're into that kind of thing. I remember the wikibook explaining it quite well and mostly simply.
21:07:10 <buttons840> :t (*>)
21:07:12 <lambdabot> Applicative f => f a -> f b -> f b
21:07:34 <kadoban> :t (>>)
21:07:36 <lambdabot> Monad m => m a -> m b -> m b
21:07:46 <Squarism> kadoban, report = "the haskell report 2010"? 
21:07:58 <Squarism> (something i heard mentioned)
21:08:01 <kadoban> Yeah
21:11:23 <`Guest00000> i meant Haskell2010 -> Haskell98
21:13:13 <kadoban> I can't say I even know what the differences are, now that I think about it. Seems like the kind of thing I should know.
21:14:03 <vaibhavsagar> I think this might be a leftover from before AMP
21:14:20 <jchia1> johnw: Thanks.
21:14:24 <vaibhavsagar> AFAIK purescript doesn't have (>>)
21:15:12 <Welkin> purescript just has *>
21:15:21 <Welkin> right?
21:15:37 <Welkin> but << and <* do not work the same way in haskell
21:15:46 <Welkin> although I believe >> and *> do
21:16:07 <johnw> Welkin: huh?
21:16:11 <vaibhavsagar> https://github.com/purescript/purescript/wiki/Differences-from-Haskell#where-is--from-haskell
21:16:31 <vaibhavsagar> how are (<<) and (<*) different?
21:16:39 <johnw> I don't think we even have (<<) in Haskell
21:16:47 <Welkin> hm, oh yeah
21:16:51 <Welkin> it was something I defined myself
21:16:54 <Welkin> flip (>>)
21:17:05 <Welkin> and the semantics were different from <*
21:17:59 <johnw> foo << bar make it seem like bar will be executed first, but foo <* bar says to execute foo, then bar, with the result being the value from foo
21:18:25 <Welkin> yes
21:19:21 <vaibhavsagar> in the same way that (<*) is different from `flip (*>)`
21:19:34 <johnw> *> and <* don't change execution order
21:19:41 <johnw> just which side the final result comes from
21:19:53 <johnw> >>= and =<< decide execution order
21:26:06 <buttons840> any opinions on my style here: read <$> (many spaces *> some digit <* (many spaces >> char ':'))  :: Parser Int
21:27:40 <johnw> read <$> many spaces *> some digit <* many spaces <* char ':'
21:28:31 <buttons840> johnw: yeah, i was about to ask if there's anyway i can avoid the monad methods
21:28:46 <buttons840> what are the functions in a typeclass called?
21:28:53 <johnw> typeclass methods?
21:31:02 <buttons840> johnw: the code you pasted doesn't typecheck for me without the parentheses?
21:36:01 <johnw> yeah, you may need parentheses
21:36:10 <johnw> i tried to type check it here, but didn't have all the right modules imported
21:37:28 <buttons840> johnw: the parens were awkward before, but what you posted works with just   `read <$> (...)`   one set of parens
21:37:57 <buttons840> :t <$>
21:37:59 <lambdabot> error: parse error on input ‘<$>’
21:38:07 <buttons840> :|
21:38:17 <buttons840> <$> is fmap?
21:38:24 <kadoban> :t (<$>)
21:38:25 <kadoban> yes
21:38:26 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:43:14 <buttons840> i heard haskell treats ($) special?
21:43:28 <johnw> it's just an operator
21:51:08 <buttons840> I want to identify and parse a line that contains only 1 character many time, (ie, "======") any suggestions on what parsers to use for this?
21:51:30 <johnw> many (char '=')
21:51:51 <johnw> or some (char '=')
21:52:53 <buttons840> johnw: i want to be able to match a line containing any of several different characters, not just equal signs
21:53:08 <johnw> some (oneOf 'A-Zf-g')
21:53:09 <buttons840> so long as the character is the only one that appears on the line
21:53:17 <johnw> ah
21:53:34 <johnw> c <- anyChar; some (char c)
21:53:37 <buttons840> i would match "======" and "---------"   but not   "-=-=-=-"
21:54:30 <dramforever> :t asum
21:54:31 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
21:54:55 <johnw> or: some . char =<< anyChar
21:55:04 <dramforever> :t asum . map (some . Text.Parsec.char)
21:55:06 <lambdabot> Text.Parsec.Prim.Stream s m Char => [Char] -> Text.Parsec.Prim.ParsecT s u m [Char]
21:55:24 <dramforever> :t asum . fmap (some . Text.Parsec.char)
21:55:27 <lambdabot> (Text.Parsec.Prim.Stream s m Char, Foldable t, Functor t) => t Char -> Text.Parsec.Prim.ParsecT s u m [Char]
21:55:34 <buttons840> johnw: can anyChar be combined with oneOf?
21:55:45 <johnw> yeah, or use it in place of it
21:55:46 <buttons840> :t anyChar (oneOf "abc")
21:55:46 <dramforever> buttons840: get all those many (char 'x') together and 'asum' them
21:55:48 <lambdabot> error:
21:55:48 <lambdabot>     Variable not in scope: anyChar :: Splitter Char -> t
21:55:48 <dramforever> good enough?
21:55:57 <johnw> no, that you can't do
21:56:00 <johnw> you'd just use oneOf
21:56:08 <dramforever> :t Text.Parsec.anyChar
21:56:10 <lambdabot> Text.Parsec.Prim.Stream s m Char => Text.Parsec.Prim.ParsecT s u m Char
21:56:15 <dramforever> Is a different thing obviously
21:56:16 <johnw> some . char =<< oneOf "-="
21:56:35 <buttons840> many (oneOf "-=") will match "-=-=" wont it?
21:56:40 <dramforever> johnw: Now *that*'s clever
21:57:01 <dramforever> oneOf "-=" >>= some . char
21:57:22 <dramforever> Means get one '-' or '=', then get 0 or more that character
21:57:31 <johnw> some means 1 or more
21:57:52 <dramforever> Then it probably should be 'many' there
21:57:59 <dramforever> Otherwise it won't match '-'
21:58:04 <johnw> true
21:59:32 <buttons840> :t anyChar
21:59:34 <lambdabot> error: Variable not in scope: anyChar
22:00:49 <dramforever> :t Text.Parsec.anyChar
22:00:52 <lambdabot> Text.Parsec.Prim.Stream s m Char => Text.Parsec.Prim.ParsecT s u m Char
22:01:10 <buttons840> i see, oneOf and anyChar have the same type
22:01:27 <dramforever> :t oneOf
22:01:29 <lambdabot> Eq a => [a] -> Splitter a
22:01:35 <dramforever> :t Text.Parsec.oneOf -- Screw that split
22:01:38 <lambdabot> Text.Parsec.Prim.Stream s m Char => [Char] -> Text.Parsec.Prim.ParsecT s u m Char
22:14:29 <buttons840> and char 'a' :: Parser [Char]   will match "aaa" because of the way the list monad behaves?
22:16:13 <buttons840> not quite
22:23:26 <halogenandtoast> Can someone explain to me the use case for Control.Monad.Fix in this example https://wiki.haskell.org/Implement_a_chat_server I don't understand the need to find a fix-point at all.
22:24:09 <c_wraith> halogenandtoast: *usually* MonadFix is used to give you the ability to refer to something defined later in a do block
22:24:17 <johnw> some of those uses of 'fix' are just 'forever' in disguise
22:24:31 <johnw> fix $ \loop -> ...; loop = forever $ ...
22:24:48 <johnw> it's all just anonymous recursion
22:24:58 <c_wraith> johnw: but that's not MonadFix, that's the regular fix. 
22:24:58 <halogenandtoast> ah right
22:25:04 <johnw> yep
22:25:11 <johnw> Control.Monad.Fix.fix is regular fix
22:25:13 <johnw> mfix is MonadFix
22:25:26 <halogenandtoast> Yeah this was just using regular fix, not mfix.
22:26:01 <c_wraith> oh, yeah, that is stuff that'd be better as forever
22:26:27 <c_wraith> I use fix for things like that when there's a conditional on whether to recurse or not
22:26:39 <johnw> right
22:26:44 <c_wraith> but that is using it unconditionally, where forever would be better
22:26:53 <johnw> fix $ \loop -> if x then loop else bye
22:27:19 <buttons840> how would you parse everything up until another parser matches?     eg.   f (char 'c')  when applied to "ababc" would consume "abab" ?
22:27:29 <halogenandtoast> Of course I've forgotten why finding a fix-point allows for anonymous recursion (time to try to implement the y-combinator again).
22:27:43 <johnw> manyTill anyChar (try (char 'c'))
22:28:23 <buttons840> johnw: ty, i'll look those up in the docs
22:29:32 <halogenandtoast> Thanks c_wraith and johnw that helped a lot.
22:30:37 <johnw> fix f = f (fix f), so f takes a function as its first argument that refers to itself
23:58:31 <ezyang> It's kind of amazing that there is no string search-replace in base 
