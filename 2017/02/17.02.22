00:00:55 <maybefbi> is it true that ever since Applicative became the superset of Monad in Haskell, GeneralizedNewtypeDeriving of application monads need to say deriving (...., Applicative, Functor) also?
00:01:41 <cocreature> maybefbi: I’m tempted to say yes, but I don’t know what you are referring to by “application monad”
00:02:29 <maybefbi> By application monad I mean how we invente newtype App a = App { ... } deriving (....) for our app
00:02:44 <cocreature> oh I was thinking of function application :)
00:02:58 <maybefbi> did i use the wrong name?
00:03:14 <cocreature> I don’t think so. “application” is just an overloaded name
00:03:20 <maybefbi> yeah
00:03:34 <cocreature> maybefbi: you definitely need the Applicative and the Functor instance. whether you get them via GND or write them manually doesn’t matter
00:04:30 <maybefbi> thanks a lot
00:04:36 <maybefbi> i did not know this
00:04:51 <maybefbi> even old textbooks like real world haskell dont say this
00:05:11 <maybefbi> they only preach to GND until Monad, inside your stack
00:05:12 <cocreature> real world haskell was written before Applicative became a superclass of Monad :)
00:05:20 <maybefbi> :D yeah makes sense
00:10:53 <tfc[m]> i always thought that applicative is a subclass of monad, because monad can do more.
00:11:34 <cocreature> tfc[m]: every Monad is an Applicative, so Applicative is more general ⇒ Applicative is a superclass of Monad
00:13:43 <tfc[m]> ok, this is the point which is not completely clear to me. consider stuff like do { a <- foo; b <- bar; return $ Constructor a b }. That can be expressed with Constructor <$> foo <*> bar if i am not wrong. so foo and bar are applicative functions. and then if you have something like do { a <- foo; b <- bar foo; return $ Constructor a b } you cannot express it with applicatives any longer.
00:14:15 <tfc[m]> this looks to me like monads can do more, hence applicatives are more specialized, aren't they?
00:17:10 <sshine> you can't do Constructor <$> foo <*> bar foo? maybe you mean something that uses a rather than foo?
00:17:24 <cocreature> tfc[m]: it kind of depends on what you mean by “being more specialized”. making an instance of Applicative requires less than making something an instance of Monad, so in that sense Applicative is more general. implementing something using an Applicative constraint allows less things than implementing it in terms of a Monad constraint so in that sense Monad is more general
00:17:36 <cocreature> and yeah sshine is right
00:18:20 <ongy> what? It should work to replace the entire do {} block with the <$><*> version
00:18:21 <tfc[m]> sshine i am assuming that foo and bar have side effects. sorry i did not supply that info
00:18:37 <cocreature> tfc[m]: that doesn’t matter
00:19:01 <sshine> tfc[m], I'm assuming you mean something like 'do { a <- foo; b <- bar a; return $ Constructor a b }'
00:19:32 <tfc[m]> sshine: maybe that is a better example than what i provided.
00:19:45 <ongy> ohh, for the second one. What was it that monads give us? That we can decide controll flow? so do { x<- foo; if x then bar else baar }
00:19:47 <Freundlich> I had similar thoughts about subtyping, where you denote "a is a subtype of b" by "a <: b" and you also say "a is smaller than b". Here, a actually has "more elements" than b, but the thing is that a has fewer instances, therefore it's considered "smaller" or "more specialized".
00:19:49 <tfc[m]> cocreature: " making an instance of Applicative requires less than making something an instance of Monad, so in that sense Applicative is more general." ok, that sounds really plausible
00:22:01 <bollu> tfc[m]: one way to look at it is, given Monad m, I can _always_ implement Applicative m
00:24:07 <tfc[m]> bollu how about the following parser example: how do you do something like the following in applicative style: parser = do { bytes <- read $ word; payload <- readbytes bytes; return payload }
00:24:35 <tfc[m]> this is something i wanted to do earlier, but i did not understand how to express this as applicative
00:24:48 <jle`> you cannot express that in Applicative
00:25:13 <tfc[m]> ok, good. then i at least correctly understood that. :)
00:25:20 <jle`> btw, `x <- m; return x` is just 'm'
00:25:35 <tfc[m]> yes
00:26:54 <ongy> and `read $ word` is `read word` so all of this is `readbytes =<< read word` if I'm not mistaken
00:27:08 <ongy> can lambdabot desugar do notation?
00:27:16 <jle`> yes
00:27:25 <ongy> @desugar do { bytes <- read $ word; payload <- readbytes bytes; return payload }
00:27:25 <lambdabot> Unknown command, try @list
00:27:58 <tfc[m]> is there any desugar command i can install on my system for offline use?
00:28:04 <jle`> @undo { bytes <- read $ word; payload <- readbytes bytes; return payload }
00:28:04 <lambdabot> <unknown>.hs: 1: 1:Parse error: {
00:28:09 <jle`> @undo do { bytes <- read $ word; payload <- readbytes bytes; return payload }
00:28:09 <lambdabot> read $ word >>= \ bytes -> readbytes bytes >>= \ payload -> return payload
00:28:16 <tfc[m]> i am often writing unnecessarily complex lines.
00:28:16 <jle`> oops
00:28:29 <jle`> tfc[m]: well, the desugarer won't help you here
00:28:43 <jle`> the desugared version is probably even less readable than the do notation version
00:28:54 <ongy> hlint can find some of those I think
00:28:57 <tfc[m]> ok
00:29:29 <jle`> stuff like this is more similar to seeing that x * 1 = x
00:29:35 <jle`> so instead of writing 'x * 1', you can just write 'x'
00:30:12 <jle`> so it's not a desugaring issue; it's a...refactoring issue?
00:30:37 <tfc[m]> sometimes i am concentrating so much on understanding what i am doing that i miss out some syntax opportunities to write simpler code :D
00:30:45 <tfc[m]> i think that might get better with the time
00:31:44 <jle`> i don't think it's really about the syntax
00:31:54 <jle`> it's just about understanding what you're using :)
00:32:06 <jle`> if you understood multiplication, you'd know that you can simplify x * 1 to just x
00:32:17 <jle`> it's not an issue about syntax
00:32:23 <jle`> knowing the syntax of multiplication wouldn't help you
00:33:11 <ongy> @undo do { a <- foo; b <- bar; return $ C a b }
00:33:12 <lambdabot> foo >>= \ a -> bar >>= \ b -> return $ C a b
00:34:07 <tfc[m]> hm all this >>= lambda chaining does not necessarily look nicer.
00:34:22 <tfc[m]> but it's good to see it for understanding
00:34:52 <cocreature> tfc[m]: if it would look nicer, we wouldn’t have do notation :)
00:34:57 <Axman6> tfc[m]: this is common in any language, write what makes sense in your head first, get it working, then refactor it to make it shorter if it makes sense. don't initially try to come up with the most elegant solution
00:36:02 <tfc[m]> Axman6: it depends on your experience. If i solve problems in C++ i use standard algorithms a lot and come up with short and readable code immediately in most situations. As a beginner i would write wild looping algorithms and then realize "oh thats standard algorithm X!"
00:36:09 <tfc[m]> same applies to me for haskell at the time.
00:36:28 <Axman6> with time you will get better at seeing you're about to write pattern X (maybe this will be Applicative instead of Monadic because none of the computations depend on the results of any of the others, etc.), and then it will become natural to use that pattern
00:36:34 <zipper> Do you guys know about deliberate practice? Is there something of the sort for haskell/software engineering?
00:36:53 <Axman6> tfc[m]: yes, this is exactly the same. 
00:37:05 <mniip> I do deliberate practice all the time :o
00:37:50 <zipper> mniip: How so?
00:38:03 <zipper> Well the quality and nature of practice
00:38:14 <zipper> Like what specifically should one aim for?
00:38:17 <mniip> I like to reimplement studd on my own
00:38:20 <mniip> stuff
00:38:47 <zipper> Self teaching seems to be the slowest way to learn :( by the time one is good they'll be old :(
00:38:59 <mniip> I disagree
00:39:02 <zipper> mniip: Libs or algos?
00:39:03 <mniip> it pays off in the end
00:39:14 <zipper> mniip: Please explain
00:39:28 <mniip> zipper, well, not like whole libs
00:39:42 <zipper> mniip: Why do you say it pays off in the end?
00:39:48 <mniip> but maybe, protocols, or structures that are already implemented in some lib
00:39:52 <mniip> just to see if I can
00:39:55 <zipper> I see
00:40:07 <mniip> zipper, when you self-teach you learn to self-teach really well
00:40:22 <mniip> and you can pick up stuff on your own very quickly
00:40:49 <mniip> and you don't depend on another person preparing the information for you
00:41:07 * ongy partially implemented a DNS resolver to understand dns better
00:41:15 <ongy> then I noticed that DNS  is weird
00:41:52 <mniip> I think a particular subset of like-minded people are OS hobbyists
00:42:24 <zipper> mniip: Well you know in the end when you are say interviewing what matters is, do you or don't you know.
00:42:30 <mniip> writing OSes with code that is analogous to already existing code just to 1) see if they can 2) better understand it 3) find out it's really weird
00:42:34 <zipper> Not can you self teach and such, right?
00:43:08 <mniip> zipper, depends on the interviewer
00:43:42 * zipper wonders what the bottom line is, the process or the result?
00:54:55 <mniip> definitely not the result
00:55:13 <mniip> as it is usually bound to be worse than the already implemented stuff
00:59:19 <zipper> mniip: :) you're an encouraging person.
00:59:34 <zipper> mniip: Ever thought of being a life coach? :P
01:00:38 <mniip> uhh
01:01:03 <mniip> I'd rather set mine straight first :p
01:07:28 <grantwu> Good morning
01:08:36 <grantwu> I'm not sure what sort of unholy thing I have done, but I get this when I try to run stack setup: http://lpaste.net/8694464595516981248
01:08:56 <grantwu> stack exec -- ghci fails with <command line>: can't load .so/.DLL for: libgmp.so (libgmp.so: cannot open shared object file: No such file or directory)
01:11:07 <phadej> grantwu: on what platform you are? Ubuntu?
01:12:54 <phadej> grantwu: how you installed stack, using manual download?
01:13:18 <phadej> have you installed the deps, as in https://docs.haskellstack.org/en/stable/install_and_upgrade/#manual-download_2 ?
01:13:30 <grantwu> I am on Ubuntu 16.10.  I *believe* I installed it through NixOS
01:13:48 <grantwu> Either that, or through the installer...
01:14:36 <grantwu> Yeah, I installed it through nix
01:23:16 <tsahyt> nub is always order independent, right?
01:24:51 <Hafydd> :t nub
01:24:53 <tsahyt> oh, nvm the problem is somewhere else
01:24:53 <lambdabot> Eq a => [a] -> [a]
01:24:55 <Hafydd> No.
01:25:23 <tsahyt> > nub [1,1,1,4,3,2,2] == nub [2,3,2,1,4,1,1]
01:25:27 <lambdabot>  False
01:25:30 <tsahyt> wait what
01:25:39 <tsahyt> oh
01:25:49 <tsahyt> > sort (nub [1,1,1,4,3,2,2]) == sort (nub [2,3,2,1,4,1,1])
01:25:53 <lambdabot>  True
01:25:55 <tsahyt> that's what I meant
01:26:36 <orion> In c2hs, is it possible to capture the return value of a C function and return Nothing if it's less than zero?
01:26:37 <Hafydd> tsahyt: they will be equal with respect to (==), but they might not be structurally equal.
01:26:49 <tsahyt> Hafydd: I'm dealing with Ints anyhow
01:26:51 <orion> I do not want to call throwIO.
01:27:03 <tsahyt> Hafydd: and order of the result doesn't matter in my case either
01:27:04 <dmj`> grantwu: nix-shell -p haskell.compiler.ghc802
01:27:05 <Hafydd> In that case, there is no difference.
01:27:37 <tsahyt> Hafydd: I just wanted to make sure that permutations don't make a difference in terms of what elements are contained in the result, regardless of order
01:27:55 <tsahyt> or put differently, that the length of the result is invariant under permutations of the input
01:32:51 <zipper> :t nub
01:32:54 <lambdabot> Eq a => [a] -> [a]
01:39:37 <tsahyt> is there a way to write an IO action that exhibits one behavior on the first call and another on all subsequent calls?
01:40:01 <tsahyt> my current solution has an IORef Bool to check whether it's the first call, which gets initialized somewhere else
01:42:43 <liste> tsahyt: makeCounter :: IO (IO Int)
01:43:52 <tsahyt> I'm not sure I understand
01:44:38 <tsahyt> what would an implementation look like?
01:45:23 <liste> 1 sec
01:46:51 <liste> tsahyt: http://codepad.org/luHkpPZS
01:48:47 <tsahyt> so I'd basically just defer the statefulness into a closure that way?
01:49:09 <liste> yes, store the ioref in the closure
01:49:22 <tsahyt> that'd be worth considering. thank you!
01:50:02 <liste> you're welcome
02:12:43 <ph88^> when using ApplicativeDo how to know if a do-block still contains monadic bind ?
02:13:30 <quchen> ph88^: Check its type :-)
02:13:57 <quchen> Or give it a type signature so you get an error if it’s monadic
02:14:16 <ph88^> i always give it a monadic type signature
02:15:23 <mrkgnao> Is this something sensible? 
02:15:26 <mrkgnao> mapBone _ (Pure p) = Pure p
02:15:28 <mrkgnao> mapBone f (Free fa) = Free (f (fmap (mapBone f) fa))
02:16:02 <mrkgnao> I feel like fmap should cover this, but that also sounds false since fmap maps along the "leaves" of the Free tree
02:16:21 <mrkgnao> and this is more to do with transforming the "backbone" of the tree (hence the name)
02:17:16 <ph88^> quchen, eh actually i'm not sure what the type is here  https://bpaste.net/show/6780fc9b9261
02:18:36 <polux> ph88^: it's f a, for the f that appears in "Rule f DiscreteRange => Rule f IndexConstraint"
02:19:09 <polux> it is still a type constructor variable at this point
02:20:02 <polux> I'm not sure about quchen suggestion though: you can end up with something of type Foo a where instance Monad Foo and instance Applicative Foo
02:20:23 <polux> so by inspecting the type you can't tell if there is any bind left right?
02:20:30 <polux> Or am I missing something?
02:20:47 <ph88^> polux, this is an example of what f could be  https://hackage.haskell.org/package/megaparsec-5.2.0/docs/Text-Megaparsec-Text.html#t:Parser
02:21:00 <polux> What's certain though is that if there is no Monad instance for Foo then you know for sure
02:21:26 <polux> ph88^: in that cas since Parser has a Monad instance
02:21:35 <polux> I don't think you can tell by looking at the type
02:21:45 <ph88^> ya actually i was thinking the same thing .. when there are applicative and monad instances for both then you can't tell from the type i think
02:22:11 <ph88^> would need to inspect it somehow after ghc did it's heuristics work on it
02:23:04 <polux> There's always the possibility of having an intermediate datatype that only has an Applicative instance, and then you interpret this datatype into a Parser
02:23:27 <polux> but that will probably incur some overhead
02:23:36 <polux> not to mention boilerplate
02:23:59 <ph88^> what kind of overhead are you talking about ?
02:24:51 <polux> Let assume you define some datatype     data MyParser a where FMap :: (a -> b) -> MyParser a -> MyParser b ...
02:25:13 <polux> then you only declare an Applicative instance for MyParser
02:25:18 <polux> but not a Monad one
02:25:34 <polux> then you annotate your applicative do expression to have type "MyParser Foo"
02:25:46 <polux> if that typechecks you'll know there is no bind
02:25:58 <polux> then you write a function interpret :: MyParser a -> Parser a
02:26:33 <polux> the overhead I was talking about is this MyParser constructors + the cost of interpreting them
02:27:15 <phadej> polux: you can use http://hackage.haskell.org/package/free-4.12.4/docs/Control-Alternative-Free.html
02:27:22 <phadej> so not so much boilerplate
02:27:34 <ph88^> i don't really understand it
02:27:57 <phadej> and I'm quite sure that inliner will be able to remove intermediate 'Alt' all-together (but there is no guarantee, that's unfortunate indeed)
02:29:21 <polux> ph88^: what I was proposing and what phadej is suggesting is that instead of buiding an expression of type "Parser Foo" with your do expression, you instead build a tree that represents that expression, and you make sure that tree has no monad instance
02:29:30 <polux> then you translate that tree into a Parser Foo
02:29:43 <polux> to recover the parser you wanted to express in the first place
02:30:06 <polux> the whole point of this intermediate tree is to ensure that there is no bind
02:30:17 <ph88^> ooh like that
02:32:04 <ph88^> that made me look if there is already an applicative parser .. looks that there is https://hackage.haskell.org/package/applicative-parsec  how does applicative give you those extra abilities mentioned:  grammar analysis and validation tools
02:32:29 <ph88^> some things that you can do with applicative that you can't do with monad so that this thing can do grammar analysis ?
02:33:20 <polux> ph88^: let's say it that way: if there is a bind, even bind is a constructor, you end up with a grammar of the form Bind <closure> <value> and you can't "inspect" <closure>, it's a black box
02:34:07 <polux> with applicative the grammars you can express are less expressive (only context-free grammars) but you gain static analysis power over the grammar
02:34:39 <ph88^> polux, actually to think about what you suggest i don't think it will be possible because i need to carry around a symbol table in State .. so i can not force all the rules to be applicative. I thought that ApplicativeDo could avoid using monad when not needed (for example when not reading or writing to State) ..
02:35:45 <polux> State is applicative too, the only thing you must not do in order to be applicative is things of the form  do { x <- e; case x of p1 -> e1 | p2 -> e2 }
02:35:49 <ph88^> polux, how can i do the inspection with applicative which can't be done with monad ?
02:35:51 <polux> i.e., inspect intermediate results
02:36:33 <polux> ph88^: applicative has only <$> and <*> so if you represent those by constructors, you know the "shape of the computation" by inspecting the applicative values
02:36:53 <ph88^> those are constructors ?
02:36:55 <ph88^> o_O
02:37:03 <merijn> ph88^: Monad can do everything Applicative can, but not all Applicatives have corresponding monads
02:37:05 <polux> you can decide to make them constuctors
02:37:20 <polux> for your particular datatype and applicative instance
02:37:29 <ph88^> so <$> and <*> can become data constructors ?
02:37:32 <polux> yes
02:37:43 <polux> >>= can also become one, it's just not as useful for static analysis
02:37:49 <MarcelineVQ> could you elaborate on what  you mean by gaining static analysys power?
02:38:22 <merijn> MarcelineVQ: <*> has an applicative on either side, whereas >>= only does on one side
02:39:04 <polux> it depends on the domain, but for grammars that might mean doing what YACC does on the grammar for instance, for Haxl it means being able to batch requests
02:39:24 <ph88^> polux, when you build the shape of the computation are you only suppose to use <*> ?  and then when you want to execute your computation use <$> ?   or how can you do inspection before you execute ?
02:40:02 <polux> ph88^: you can use both, actually if you have pure, f <$> x is just pure f <*> x
02:40:17 <polux> so you just need a constructor for pure and one for <*>
02:41:59 <ph88^> so it's pure that finally runs the builded computation ?
02:42:12 <polux> ah no, sorry, misunderstood your question
02:42:16 <polux> it's up to you then to run it
02:43:10 <ph88^> so then it's run by applying a value to it ?
02:44:16 <ph88^> if i have build the computation can i build function for it to inspect it and match on data constructors ?
02:44:56 <polux> ph88^: let's say I am the writer of a parsing lib that does some static analysis of grammars, I provide an abstract type Parser a and some combinators (char, sepBy, ...) + some Applicative instance which turns out to be implemented as constructors
02:45:07 <polux> then I provide a function runParser :: Parser a -> Either Error a
02:45:31 <polux> this function performs static analysis of the Parser a value, and then maybe builds some table, and uses that table for parsing
02:46:05 <polux> I can also do that with monads, it's just that my static analysis powers are more limited
02:46:56 <ph88^> oh ok
02:57:06 <MarcelineVQ> polux, merijn: thank you for your responses, it turns out I'm basically unaware of static analysis in the first place so I've located some reading materials
02:58:53 <ph88^> this blog also says that applicative parsers can lead to more compact code .. so i guess ghc can do more optimizations on applicative?  https://web.archive.org/web/20170109085108/http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/
03:03:01 <lep-delete> why does cabal link on every cabal run/build even if i have changed nothing
03:10:01 <earthy> ph88^: there is a fundamental point in monadic parsers that is akin to the prolog cut operator (!) in that it can cull the parse forest
03:10:45 <earthy> ph88^: which means monadic parsers are strictly more powerful than purely applicative parsers, but also that they are harder to optimize
03:11:40 <ph88^> what do you mean   cull the parse forest
03:12:39 <Arguggi> anyone know how to kill a process I start with https://hackage.haskell.org/package/xmonad-0.13/docs/XMonad-Core.html#v:spawnPID ? (every time I restart xmonad I also want to restart my status bar)
03:14:41 <phadej> Arguggi: https://www.stackage.org/haddock/lts-8.2/unix-2.7.2.1/System-Posix-Signals.html#v:signalProcess
03:15:29 <phadej> Arguggi: and there are sigTERM and sigKILL defined in the same module
03:15:54 <Arguggi> phadej, ah right, thanks!
03:17:08 <phadej> Arguggi: np. I'd create an issue to xmonad (if there's no already) to have spawnPID variant which would manage the processes
03:19:33 <Arguggi> ok I'll open an issue
03:20:03 <phadej> I guess you can make a contrib module using https://hackage.haskell.org/package/xmonad-0.13/docs/XMonad-Core.html#t:StateExtension
03:20:15 <phadej> hopefully there is one already :)
04:01:58 <ongy> I think that's not an easy task for xmonad. Afaik that's intentional behaviour that also breaks the normal System.Process api (I don't remember why they chose to do that)
04:33:44 <maybefbi> i had a haskell interview just now. and today i learned that there is a if there isn't a (Foldable t) => .. constraint, your data structure can have other types of folds which have a foldr :: (a -> .. b -> ..) -> z -> U k -> x
04:34:43 <maybefbi> basically anything that can change your data type into another value can be called a fold
04:35:55 <maybefbi> does that make sense?
04:37:16 <Jinixt> let's say i have a complex data structure, like a tree where leaves are lists, and i want to find some inner structure inside this data. "a tree node where the second element in the list is 5 and the sibling tree node has 10 elements in the list"
04:37:33 <Jinixt> is there any alternative to doing it "by hand"?
04:37:55 <maybefbi> doing what "by hand"?
04:38:15 <merijn> Sounds like something for lens
04:38:51 <Jinixt> basically i would like some declarative way to talk about sub-structures
04:39:02 <Jinixt> to locate them and modify them
04:39:19 <athan> yea lens is the berst, aroooound
04:39:22 <Jinixt> maybe lens works yeah
04:39:42 <maybefbi> Jinixt, just invent your own list. e.g. a nested list of ints is like this: data NestedInt = I Int -> N [NestedInts]
04:39:56 <maybefbi> shit typo
04:39:59 <maybefbi> what i meant was 
04:40:07 <lyxia> maybefbi: https://wiki.haskell.org/Catamorphisms
04:40:11 <maybefbi>  data NestedInt = I Int | N [NestedInts]
04:40:28 <maybefbi> sorry im a bit drunk
04:41:09 <maybefbi> lyxia, nice
04:41:12 <Jinixt> maybefbi: i never spoke of having an integer on the leaf nodes though
04:41:26 <maybefbi> ok thats ok
04:41:28 <Jinixt> bit of a messy example but otherwise it would seem trivial
04:41:46 <maybefbi> Jinixt, ok let me see if i can do your messy example
04:43:12 <Jinixt> maybe two constraints make sense here, one to find the "central" object, and from there you can see everything relative to it and decide whether it's a match
04:43:59 <maybefbi> Jinixt, data SecondElementIs5List = I Int | SecondElementIs5 | Cons Int SecondElementIs5List
04:44:04 <Jinixt> to put it into some more real context i'm thinking of AST optimization passes
04:44:19 <Jinixt> maybefbi: what
04:44:24 <Jinixt> why would you put that in the type
04:44:31 <Taneb> Are there any maintained Haskell implementations other than GHC these days
04:44:31 <Jinixt> it's runtime data
04:44:51 <quchen_> UHC is maintained, no?
04:45:08 <Jinixt> is frege a full haskell implementation? i forget
04:45:10 <merijn> UHC, yeah
04:45:26 <maybefbi> Jinixt, sorry i thought you wanted an alternate implementation of a list with some properties
04:45:43 <maybefbi> Jinixt, perhaps then you could use such a list as the leaf of your tree
04:45:47 <Jinixt> nah, given a data structure, i want to search and replace sub-structures
04:46:08 <Jinixt> yeah, that's what i had in my original example :)
04:47:08 <maybefbi> lyxia, so there are more folds than just Foldable 
05:17:31 <ertes> maybefbi: the term "fold" is overloaded, but one well-defined notion of it comes from category theory: what lyxia said
05:17:46 <maybefbi> ertes, copy that
05:18:23 <ertes> maybefbi: it has two main characteristics: 1. it's fully information-preserving, so you can reconstruct the original data structure (the identity fold)
05:18:31 <ertes> like:  foldr (:) []
05:18:46 <ertes> 2. it does nothing "extra"
05:19:05 <max3> is there a way to throw an exception that identifies itself showing line number and source file it came from?
05:19:28 <ertes> so a fold is the "smallest possible" recursive function that can recover the full data structure
05:19:36 <maybefbi> ertes, one of the examples my interviewer showed me had 3 arguments unlike (:)
05:19:51 <ertes> that's fine…  a fold can result in a function
05:19:55 <athan> max3: there's a constraint for it iirc, like WithCallsite or something
05:20:36 <max3> athan, what do you mean by constraint?
05:20:36 <ertes> > foldr (\x xs n -> if n > 0 then x : xs (n - 1) else []) (pure []) "abcdefg" 3
05:20:40 <lambdabot>  "abc"
05:20:48 <ertes> maybefbi: ^ 'take' in terms of foldr
05:21:07 <ertes> maybefbi: http://ertes.eu/tutorial/foldr.html#stateful-folds
05:21:38 <maybefbi> ertes, yeah we weren't talking about anything :: (Foldable t)..
05:22:47 <maybefbi> e.g. i was asked to implement foldr for Maybe a
05:23:03 <maybefbi> and the first parameter of said fold was a function :: (a -> b)
05:23:54 <maybefbi> here is how the interview started:
05:24:12 <maybefbi> Him: write a data type
05:24:16 <maybefbi> Me: data Void
05:24:26 <maybefbi> Him: write foldr for it
05:24:49 <maybefbi> Me: I can write one but you cannot call it foldr _ _ _ = undefined
05:25:09 <maybefbi> Him: yes this is technically correct. write another data type.
05:25:12 <ertes> maybefbi: do you know what the fold for Void is?
05:25:23 <athan> max3: ahh here we go: https://hackage.haskell.org/package/call-stack-0.1.0/docs/Data-CallStack.html#v:callStack
05:25:24 <ertes> at least its type
05:25:42 <maybefbi> ertes, yes i know its type. it is:
05:26:05 <maybefbi> ertes, foldr :: (a -> b -> b) -> b -> Void -> b
05:26:09 <ertes> maybefbi: nope
05:26:20 <ertes> foldVoid :: Void -> r
05:26:41 <ertes> that's the Void fold, and surprisingly enough it's a well-defined function
05:26:54 <ertes> which, unfortunately, you can't write in standard haskell without cheating =)
05:26:56 <maybefbi> i agree it is well-defined although no one can call it
05:26:59 <ertes> but you can write it with -XEmptyCase
05:27:06 <maybefbi> oh cool
05:27:47 <maybefbi> ertes, why isn't foldVoid :: (a -> b -> c -> d) -> e -> Void -> f ?
05:27:57 <maybefbi> because i can still write its definition
05:28:08 <maybefbi> foldVoid _ _ _ = undefined
05:28:40 <max3> i guess because of "Deprecated: error appends the call stack now" error is good enough
05:28:50 <ertes> maybefbi: the true type for the Void catamorphism is the following:  foldVoid :: (F r -> r) -> Fix F -> r
05:29:02 <ertes> maybefbi: can you come up with an F such that Fix F = Void?
05:29:49 <maybefbi> ertes, ok if you say so. because i did not know about catamorphisms back then. to be folds can only be defined for container like things
05:29:51 <athan> max3: oh jeez sorry haha
05:30:10 <maybefbi> ertes, i cannot come up with F such that Fix F is Void
05:30:20 <ertes> maybefbi: folds can be defined for any type that is the least fixed point of a type function
05:30:41 <ertes> maybefbi: newtype Fix f = Fix { fromFix :: f (Fix f) }
05:30:49 <ertes> data VoidF x
05:31:08 <ertes> VoidF (Fix VoidF) ≃ 0
05:31:12 <ertes> where 0 is the empty type
05:31:56 <maybefbi> i didn't know about 0 until just now
05:32:09 <ertes> maybefbi: with that in mind the Void fold has this type:  (VoidF r -> r) -> Fix VoidF -> r
05:32:40 <ertes> now apply some type algebra:
05:32:52 <ertes> (VoidF r -> r) -> Fix VoidF -> r
05:32:56 <ertes> (0 -> r) -> Fix VoidF -> r
05:33:03 <ertes> () -> Fix VoidF -> r
05:33:06 <ertes> Fix VoidF -> r
05:33:37 <ertes> and Void ≃ Fix VoidF, which leaves you with:  Void -> r
05:34:43 <maybefbi> this is news to me.
05:35:41 <maybefbi> it seems everything i learn has a more permissible and more abstract version of it, with a truer meaning
05:36:01 <maybefbi> and the pedants always get the final word over such obscurities
05:36:33 <ertes> types form a semiring under sums and products up to isomorphism, such that (->) is flipped exponentiation:  a -> b ≃ b^a
05:36:33 <maybefbi> this is also how i became an atheist btw
05:36:39 <merijn> maybefbi: Welcome to the wonderful world of math ;)
05:36:57 <maybefbi> i.e. realizing that rules are for suckers. anything can be justified with enough arguments
05:37:01 <ertes> (VoidF r -> r)  -- that's just isomorphic to:  Void -> r
05:37:05 <ertes> and Void ≃ 0
05:37:06 <ertes> 0 -> r
05:37:20 <ertes> 0 -> r ≃ r^0
05:37:30 <ertes> and what's r^0?  well, it's 1 =)
05:37:48 <ertes> and 1 is a singleton type:  1 ≃ ()
05:38:09 <ertes> so: VoidF r -> r ≃ 1 ≃ ()
05:38:42 <hc_> Hi everyone
05:38:49 <hc_> Could you have a look at this diff please: (https://github.com/VirtualForgeGmbH/hascar/commit/ee5ef2486728c5d175cfe67b942f4afd17202db2#diff-12b15ce1b1932450f4a585396dc94498)
05:38:55 <ertes> most of the time you can pretend that types behave like numbers, except that you don't have negatives and reciprocals =)
05:39:01 <hc_> The old version compiled fine with ghc 8.0.1 but doesn't with 8.0.2
05:39:15 <maybefbi> ertes, that seems like a derivation out of principia mathematica
05:39:21 <ertes> and everything is up to isomorphism, so just write "≃" ("isomorphic to") instead of "=" (equal to)
05:39:58 <ertes> (and yes, i'm aware that there is a better symbol) =P
05:40:36 <ertes> maybefbi: type algebra is really useful for stuff like that, so i generally recommend to learn it
05:40:51 <maybefbi> ertes, where do i start?
05:41:09 <ertes> maybefbi: data ListF a x = Nil | Cons a x
05:41:17 <ertes> [a] ≃ Fix (ListF a)
05:41:35 <ertes> foldList :: (ListF a r -> r) -> Fix (ListF a) -> r
05:41:38 <merijn> maybefbi: Here: https://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
05:42:02 <ertes> maybefbi: try to use algebraic reasoning to prove that this type is isomorphic to the more familiar:  (a -> r -> r) -> r -> [a] -> r
05:42:21 <maybefbi> ertes, hmm ok
05:42:34 <ertes> you may assume the following:  [a] ≃ Fix (ListF a)
05:43:18 <ertes> maybefbi: you should probably read merijn's link first though =)
05:43:35 <maybefbi> skimming it now
05:43:42 <ertes> don't skim it…  read it
05:44:41 <hc_> I've pasted the code that compiles with ghc 8.0.1 but not 8.0.2 and pointer to a url that explains what I'm missing here is appreciated: http://lpaste.net/352874
05:46:27 <c_wraith> hc_: what's the type of withSapCarHandle?
05:47:09 <hc_> c_wraith: withSapCarHandle :: (MonadIO m, MonadThrow m, MonadMask m) => (forall s. SapCar s m a) -> Handle -> m a
05:47:39 <c_wraith> hc_: In that case, it's a bug that it compiles in 8.0.1
05:47:52 <hc_> :)
05:48:30 <c_wraith> hc_: it's the same issue runST has
05:49:16 <hc_> Which of my type signatures is wrong?
05:49:20 <c_wraith> none, actually
05:49:28 <c_wraith> It's the implementation that's wrong.
05:49:36 <hc_> -v please ;)
05:49:43 <c_wraith> I'm working on it. :)
05:49:50 <hc_> okay, sorry for being so impatient
05:49:56 <merijn> hc_: Short summary: (.) doesn't like higher rank types
05:50:12 <c_wraith> The problem is that in your implementation, (.) needs to be instantiated at a polymorphic type
05:50:14 <merijn> hc_: $ has a hack built into the typechecker to make it work
05:50:42 <c_wraith> You can make it work by eta-expanding the definition
05:50:51 <c_wraith> (and not using (.))
05:50:59 <hexagoxel> @pointful withSapCarPath sarfile = bracket open close . withSapCarHandle
05:50:59 <lambdabot> withSapCarPath sarfile x = bracket open close (withSapCarHandle x);
05:51:19 <hc_> Okay, that thought had occurred, but it didn't feel too nice ;)
05:51:24 <hc_> I'll do that then, thank you
05:51:41 <c_wraith> There's nothing conceptually wrong with your code.
05:51:53 <c_wraith> But it would require a much more advanced type checker than GHC has.
05:53:37 <c_wraith> The name of the feature that would let it do what you're asking is impredicative polymorphism.  GHC has made several tries at supporting it over time, and there is an extension that still claims to allow it, but it's basically completely non-functional. :)
05:54:53 <c_wraith> I believe that at this point, the official stance on that extension is that if it works for anything it's an accident and probably won't work in the next version of GHC. :)
05:56:02 <hc_> Okay :)
05:57:39 <merijn> I have repeatedly asked for it to be deprecated, since SPJ has (also repeatedly) told me it doesn't work
05:57:55 <merijn> Well, the big problem with ImpredicativeTypes is not whether it works or not
05:58:07 <merijn> It's: No one knows what it's SUPPOSED to do in the first place
05:58:29 <merijn> It's unclear what the theory *should* be, so until that's sorted we don't even know what to implement :)
06:00:13 <CoolerExtreme> 3drwsXA.,ljn
06:01:48 <cocreature> CoolerExtreme: you might want to change your password
06:03:27 <Cooler> cocreature, what?
06:04:01 <cocreature> Cooler: 14:59 <CoolerExtreme> 3drwsXA.,ljn
06:04:30 <Cooler> cocreature, no thats just keyboard mash
06:04:50 <Cooler> i wish my passwords were that strong
06:06:57 <ongy> freenode supports client certs
06:07:07 <max3> what's the more idiomatic way to do this? isn't it Conf.getConfig >>= Conf.get "web.path" conf ?
06:07:09 <max3> http://lpaste.net
06:07:15 <max3> whoops
06:07:16 <max3> http://lpaste.net/352876
06:07:16 <ongy> does that show up if you whois me? I can see it when I /whois ongy
06:08:02 <ongy> Conf.get "web.path" <$> Conf.getConfig. But if that's more idiomatic, no idea
06:09:42 <max3> why isn't it >>=?
06:10:00 <ongy> what's the type of Conf.get ?
06:10:20 <quchen> ongy: Both are fine, pick whatever is more readable.
06:10:55 <max3> FilePath -> Conf.Config -> a
06:11:06 <ongy> :t (>>=)
06:11:08 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:11:10 <ongy> :t (<$>)
06:11:12 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:11:18 <ongy> do you see, why it's the second one?
06:11:35 <ph88^> did anyone know if this got a follow-up ? it looks pretty sweet to me  https://www.youtube.com/watch?v=UsU8h0WYemo
06:12:23 <max3> oh because Conf.get doesn't return a monad
06:12:26 <max3> right?
06:13:37 <ongy> jup
06:14:01 <max3> thanks a lot
06:14:02 <max3> :)
06:26:55 <Denommus> I miss Haskell :-(
07:00:28 <robertkennedy> How can I use DPH? The dph-examples package didn't seem to work on 8.0.1
07:18:23 <GuruGuru> Hello haskellers, I'm trying to learn haskell but i having some trouble with the function signatures
07:19:34 <GuruGuru> I have the following code:
07:19:36 <GuruGuru> listLength :: [a] -> Int listLength []  = 0 listLength a   = 1 + listLength (tail a)  listSum :: (Num a) => [a] -> a listSum []     = 0 listSum (x:xs) = x + listSum(xs)  listMedian :: (Fractional a) => [a] -> a listMedian a = listSum a / fromIntegral (listLength a)
07:20:08 <c_wraith> GuruGuru: I appreciate that you compressed it to a single line, but lpaste is a better way to share code
07:20:10 <c_wraith> @where lpaste
07:20:10 <lambdabot> http://lpaste.net/
07:21:28 <robertkennedy> Your listMedian is the mean, I believe
07:21:36 <GuruGuru> ah sorry, http://lpaste.net/352877
07:22:06 <byorgey> GuruGuru: looks good.  What's your question?
07:22:23 <GuruGuru> okay so this works, but what if i want the listMedian function to be able to accept 
07:22:30 <byorgey> GuruGuru: (you should write listLength using pattern matching too, like listSum, instead of using tail)
07:22:30 <GuruGuru> lists of Num
07:23:07 <kgadek> GuruGuru: well, then you won't be able to perform division
07:23:25 <kgadek> Fractional class provides that operation
07:23:29 <kgadek> Num doesn't
07:24:17 <robertkennedy> To be clear, you can input Ints just fine - but then when it gets to 3 / 5, what type should that have?
07:24:17 <GuruGuru> But cant a Num be viewed as a fractional
07:24:22 <geekosaur> GuruGuru, types in Haskell do not work like in e.g. Java. a class such as Num (which is *not* a type!) specifies a *maximum* behavior, not a minimum
07:25:19 <geekosaur> if you specify a Num constraint then you are asserting that the capabilities defined in Num are available. nothing else can be used, as the capabilities are not known to be available
07:25:19 <kgadek> GuruGuru: try to think of the type definition as the minimal requirement (as geekosaur mentioned). That function requires division for `a`, therefore you need `Fractional a`
07:25:21 <robertkennedy> Which type should `listMedian [1,2]` have? 
07:26:32 <GuruGuru> kgadek, Even if the variable is only used by my sumList function ?
07:26:55 <GuruGuru> which 'returns' a Num
07:27:12 <robertkennedy> But that Num is fed to /
07:27:14 <byorgey> GuruGuru: Num is not a type
07:27:21 <geekosaur> more specifically:  ((Num a, ...) => ...) means "make sure that an implementation of Num is passed along, so it can be used to operate on values of type "a"
07:27:26 <kgadek> GuruGuru: look at it in terms of types, not variables
07:27:40 <kgadek> see what happens when you call `listLength your_list_here`
07:27:53 <byorgey> it might sound like I'm being nitpicky, but I think being careful about this will actually help.
07:28:02 <kgadek> `your_list_here` had a type `Fractional => [a]`
07:28:19 <kgadek> Fractional is "stronger" than Num in that Fractional implies Num
07:28:28 <kgadek> therefore you're allowed to call listSum
07:28:34 <kgadek> what you get back?
07:28:40 <kgadek> `Fractional a => a`
07:28:53 <kgadek> that is
07:29:06 <max3> this is bananas to me: why does generateUglifyJS compile but generateCoffeeJS doesn't after adding line 80
07:29:10 <kgadek> `listLength the_list_variable :: Fractional a => a`
07:29:17 <max3> note lines 34 and 80
07:29:22 <max3> http://lpaste.net/352879
07:29:50 <kgadek> GuruGuru: err, my bad
07:30:33 * kgadek needs more coffee apparently
07:30:59 <kgadek> `listLength your_list :: Int`
07:31:24 <kgadek> then you call `fromIntegral` on the result
07:31:30 <kgadek> which gets you `Fractional`
07:31:41 <kgadek> this was the right side of division
07:31:50 <kgadek> the left works quite similarily:
07:32:23 <geekosaur> max3, note that the action on line 34 is bound within: let ioAction = ( do
07:32:24 <kgadek> `listSum` needs `Num a => [a]`, you provide something even finer. So it's fine and this type-checks
07:32:40 <geekosaur> and the ioAction is subsequently passed to webGenerate
07:32:50 <kgadek> and this is the main point here: you get `listSum your_list :: Fractional a => a`
07:32:57 <kgadek> and not `Num a => a`!
07:33:11 <geekosaur> but you are trying to run it directly on line 80
07:33:36 <max3> true
07:33:50 <kgadek> GuruGuru: this is the crucial point. While `listSum` just took the `Num a` constraint, the caller (listMedial) still knows that this `your_list_variable` is finer and more elaborate
07:34:07 <kgadek> therefore, your left side of division is also `Fractional a => a`
07:34:08 <max3> geekosaur, so why can't i?
07:34:15 <GuruGuru> Yes 
07:34:47 <GuruGuru> but what if i would like my listmedian function to accept any type of Num list?
07:35:09 <byorgey> GuruGuru: what type should it return?
07:35:37 <kgadek> GuruGuru: look at what Num provides. The `fromInteger` will be your friend :)
07:35:49 <GuruGuru> It can return the Fractorional
07:36:01 <geekosaur> because webRegenerate has access to IO, you do not necessarily. You *may* have access to MonadIO, as that's the easiest way for webRegenerate to have access to IO. In that case, *if* it is appropriate to do so there, you can use liftIO. BUT.
07:36:14 <max3> this is like the perfect storm of being unmaintanable: polymorphic and lazy and strong typed (so i absolutely have to know what type a thing might be even though i have no way of figuring out where it will become what it becomes)
07:36:42 <geekosaur> Remember that these are basically callbacks. It is probably deferring the operation until a time when it makes sense, and performing it directly may be too early / the value you want from the config does not yet exist
07:36:51 <byorgey> GuruGuru: do you mean like    listMedian :: (Num a, Fractional b) => [a] -> b  ?
07:36:52 <kgadek> ( GuruGuru: forget my comment about fromInteger, srsly need more coffee)
07:38:01 <GuruGuru> kgadek, I tried listMedian :: (Num a, Fractorial b) => [a] -> b
07:38:07 <byorgey> GuruGuru: this is impossible: the type says it can return *any* type which is an instance of Fractional, but there is no way to convert between type a and type b, because we don't know what types they are in advance
07:38:10 <geekosaur> max3, do you know the difference between someThing(...) and function(){ someThing(...) } in javascript? that is the difference here
07:38:29 <max3> i don't know what you mean there
07:39:07 <byorgey> GuruGuru: for example I could call it with complex numbers and ask it to return a rational number.
07:39:36 <byorgey> there is no way it can keep that promise.
07:41:05 <max3> how does anyone ever refactor haskell code
07:41:06 <geekosaur> max3 ... you may need to learn about callbacks
07:41:12 * ski wishes people wouldn't say things like "`your_list_here` had a type `Fractional => [a]`", in the common case where that's not really the case ..
07:41:25 <max3> i know about callbacks - i've written plenty of guis
07:41:28 <max3> i don't know js
07:41:34 <geekosaur> yet that did not make sense?
07:41:37 <geekosaur> oh
07:42:01 <geekosaur> the first one performs the action directly. the second is a callback to be run when something is available
07:42:38 <c_wraith> max3: refactoring is the best part of haskell.  you make a change, and the compiler tells you everywhere you need to update to support the change.
07:42:47 <geekosaur> that is precisely what happens here: you need to not look up the config now, but tell webRegenerate to do so when it needs the config
07:43:08 <geekosaur> so you need to make it part of the IO action passed to webRegenerate (which is a callback)
07:43:29 <geekosaur> (that is, the IO action is a callback that webRegenerate invokes at the correct time)
07:43:33 <max3> that makes enough sense 
07:44:41 <max3> c_wraith, how would i have recognized here for example that the problem was down the line in webRegenerate
07:44:54 <max3> or maybe geekosaur can answer that because he managed to find my repo
07:45:15 <jstolarek> I have a predicate that works in a monad:  p :: (Monad m) => ... -> m Bool
07:45:23 <jstolarek> is there a way to use it in a guard?
07:45:45 <ski> no really, except for the obvious
07:45:51 <ski> s/no/not/
07:45:53 <geekosaur> I didn't find your repo, I used your paste. webRegenerate is lines 53 and 81 and line 32 makes it clear that webRegenerate receives a callback (IO action)
07:46:11 <max3> so liftIO is basically magic
07:46:13 <max3> got it
07:46:37 <jstolarek> ski: what's "obvious"?
07:46:52 <geekosaur> not really magic. it (a) does typechecking to ensure the bottom of a monad stack is IO, and (b) knows how to forward IO callbacks to that IO
07:47:03 <ski> jstolarek : first run the action in the normal fashion, then check the result (with a guard, if you prefer)
07:47:13 <max3> geekosaur, yes i was kidding a little
07:47:19 <Tuplanolla> @hoogle whenM
07:47:23 <lambdabot> Shelly whenM :: Monad m => m Bool -> m () -> m ()
07:47:23 <lambdabot> Shelly.Lifted whenM :: Monad m => m Bool -> m () -> m ()
07:47:23 <lambdabot> Shelly.Pipe whenM :: Monad m => m Bool -> m () -> m ()
07:47:32 <jstolarek> ski: I'm not even able to do that
07:47:33 <Tuplanolla> Is that what you want, jstolarek?
07:47:47 <max3> but that's actually a good explanation - that it sends a computation to the bottom of a stack of computations
07:47:49 <jstolarek> Tuplanolla: no, not exactly
07:47:52 <max3> thank you
07:48:00 <jstolarek> I want this as a guard on a function case
07:48:10 <jstolarek> foo a | p a = ....
07:48:17 <ski> max3 : rather it "lifts" the computation from the bottom of the stack (being I/O), up to the "current layer"
07:48:22 <jstolarek> where p returns Bool in a monad
07:48:22 <Tuplanolla> That's not happening, jstolarek.
07:48:23 <geekosaur> most of which is done by: instance (MonadTrans t, MonadIO m) = MonadIO (t m) where liftIO = lift . liftIO
07:48:41 <geekosaur> (and at the bootom: instance MonadIO IO where liftIO = id)
07:48:46 <ski> jstolarek : `foo a = do b <- p a; bar b where bar True = ...; ...'
07:48:58 <ski> jstolarek : depending, Tuplanolla suggestion may help
07:49:42 <Tuplanolla> Does the `ViewPatterns` thing allow binding inside patterns?
07:49:58 <nitrix> s/ski/bckw/
07:50:03 * ski smiles
07:50:06 <max3> ski, that confuses me
07:50:31 <max3> how am i lifting a computation from somewhere to the call site of liftIO?
07:50:36 <Tuplanolla> If so, that could be an option, jstolarek.
07:51:03 * jstolarek thinks about view patterns
07:51:39 <ski> max3 : the layers on top of `IO' add extra "features" (effects) to the base I/O ones. `liftIO' knows how to take an I/O computation, and convert it into a computation whose type *allows* all these extra bells and whistles .. but which in this case actually doesn't make any nontrivial use of them. the "lifted" action *just* does the I/O that the input action does, it does nothing more
07:52:01 <ski> Tuplanolla : what do you mean by "allow bindings" here ?
07:52:30 <Tuplanolla> I was thinking of extending a do block inside a pattern, ski. It's probably not a thing, but you never know.
07:52:32 <GuruGuru> kgadek, byorgey Well the penny has dropped finally :d Thanks!
07:52:34 <ski> max3 : does that make any sense ?
07:52:45 <max3> ski, so it's like lifting computational ability
07:52:47 <max3> in some sense
07:52:56 <ski> Tuplanolla : well, not unless you use `runX' in the pattern ..
07:52:57 <kgadek> GuruGuru: great to hear that :)
07:54:13 <jstolarek> this is frustrating
07:54:17 <ski> max3 : yes, go from a more restricted universe to one where more exotic things can happen. but in this case, not actually make any use of the extra power. you can compare it with `fromIntegral' which can be used to convert an `Integer' to a `Rational' (which always in this case happens to be a rational with denominator `1')
07:54:30 <geekosaur> max3, anyway, the point here is that you could use liftIO to do the operation now, but it is possible webRegenerate does some *other* IO action first that makes the config you need available. so you want to attach it to the callback passed to webRegenerate, so it happens at the right time
07:55:28 <jstolarek> I'm rewriting my code to use state monad so that it's shorter and easier to follow but this limitation of guards would force me to construct a workaround that would be even uglier than the original code, thus defeating the purpose of the whole refactoring
07:56:15 <Lokathor> jstolarek, try using stuff from Control.Monad ?
07:56:18 <ski> jstolarek : `when' or `whenM' doesn't fit your case ?
07:56:21 <max3> geekosaur, https://github.com/databrary/databrary/blob/master/Databrary/Web/Generate.hs#L46
07:56:29 <max3> the answer is no? it just runs the action itself 
07:56:31 <max3> right?
07:56:35 <Lokathor> foo a | p a == bar =     that's basically "when", right?
07:56:50 <ski> Lokathor : or `if' ..
07:57:40 <Lokathor> right, depending on the output expression and such it might be reducable to "if"
07:57:47 <max3> any thanks for the help. i worry i'm going to exhaust people's patience before i'm competent enough
07:58:04 <jstolarek> ski, Lokathor: no, that won't work. The thing is I have my function written as a series of cases and I want to enter a case depending on the current monadic state
07:58:29 <ski> max3 : generally we try to be patient enough so that you shouldn't have to worry about that
07:58:40 <jstolarek> the only thing that seems like an option is to rewrite my function to consiste of just one case and then use pattern matching
07:58:57 * ski idly wonders whether jstolarek will show their code
07:59:00 <jstolarek> s/patern matching/case/
07:59:39 <jstolarek> ski: https://github.com/jstolarek/slicer/blob/references/lib/Language/Slicer/Slice.hs#L27
07:59:45 <jstolarek> this is before a rewrite
07:59:59 <jstolarek> store parameter goes into a state monad
08:00:00 <geekosaur> max3, do you know that will always be true? or, more to the point: do you understand *why* the other function is written the way it is? (note: *I* do not know. I have only that working function as a reference; I must assume it defers the IO for a reason)
08:00:58 <max3> geekosaur, do you mean do i know that going forward that function won't change?
08:01:09 <geekosaur> that's another way to put it, yes.
08:01:19 <max3> it won't change unless i change it
08:01:34 <max3> but i do not know why it was written the way it was
08:01:46 <geekosaur> my real point is: if working examples all defer the IO the way line 32 does, then there is likely a good reason for it
08:02:16 <geekosaur> and "cheating" by using liftIO may get you in trouble in the future, if so
08:02:49 <max3> oh i wrote line 32 like that
08:03:07 <max3> that entire do was just passed webRegenerate
08:03:18 <max3> but that's still deferred right?
08:03:25 <max3> doesn't matter if i bind it in a let?
08:03:59 <geekosaur> right, the point is exactly that that one is deferring it, the other one wants to do it directly. if you know that this is just a stylistic difference, go ahead and use liftIO
08:04:35 <max3> the other one is my attempt at refactoring. that <- wasn't there before
08:04:58 <max3> https://github.com/databrary/databrary/blob/master/Databrary/Web/Coffee.hs
08:05:04 <max3> it wasn't io before
08:05:08 <max3> line 21
08:05:32 <max3> binDir comes from Paths_databrary
08:05:40 <max3> anyway you don't need to work too hard on this
08:05:45 <max3> i'm comfortable with this
08:09:28 <geekosaur> allso if you know you don't need to defer the earlier one, consider using liftIO there as well --- because other people looking at the code (this has an annoying tendency to become "you, 6 months later" >.> ) will make the same assumption I did
08:09:50 <max3> that's a good point
08:09:53 <max3> i will do that
08:10:16 <ski> jstolarek : the guards that depend on the store doesn't seem to affect that many subsequent cases, so i'd probably just group such together into a single clause, using `if', or perhaps `when' in some cases
08:11:05 <jstolarek> ski: the problem is that order of these equations matters
08:11:17 <jstolarek> I cannot reorder them arbitrarily
08:11:27 <ski> yes, but it doesn't involve that many equations, from what i can see
08:11:39 <jstolarek> ski: yes, the problem is only with two equations
08:12:03 <ski> jstolarek : no, it's also the `TAssign (Just l) _ _' case
08:12:30 <jstolarek> ah, right
08:12:43 <ski> but that said, not so many equations are involved
08:12:52 * ski would group them together
08:13:36 <ski> (btw, this is a downside to using guards, when the different conditions aren't mutually exclusive .. the same kind of problem exists in Prolog, with the cut, though the problem is even more pronounced there)
08:13:56 <jstolarek> ski: I don't see how
08:14:23 <jstolarek> given that the first equation must remain first so that it;s not overlapped by the third one
08:14:35 <ski> you have a defining equation with a guard that depends on the store : so identify all later defining equations which could possibly match in case the guard fails
08:14:52 <ski> group these together into a single defining equation, using `if' (at least to begin with)
08:15:55 <ski> hm, yes, i suppose `bwdSlice store (VException VHole) trace' also overlaps with `bwdSlice store v (TVar x)'
08:16:16 <jstolarek> ski: it overlaps most of remaining equations
08:16:29 <jstolarek> because they pattern-match on the last argument
08:17:17 <ski> hm, ok. so try split it up into two subsequent matches ?
08:18:01 * ski ponders
08:18:29 <ski> .. in any case, i think all these overlapping patterns are making it hard to grasp
08:18:59 <ski> (perhaps it's hard to avoid using overlapping patterns in your case, i don't know)
08:21:03 <ski> "ExnTy is equal to every type" :/
08:21:43 * ski would consider using a different "equivalence" function, then
08:22:13 <ski> (is `deriving instance Ord Type' really needed ?)
08:22:45 <jstolarek> ski: I agree, this is not easy to grasp - but sadly that's how it works
08:23:54 <ski> `isRefTy',&c.,`fstTy',&c. also makes me :/
08:24:14 <jstolarek> ski: yes, same here
08:24:17 <merijn> Is there a Haskell package for computing binary decision trees?
08:24:26 <jstolarek> that whole ExnTy thing is because we don't have a proper type inference
08:24:45 <jstolarek> reported as issue #25
08:25:18 <jstolarek> ski: this really should be rewritten but not before the ICFP deadline :-)
08:25:32 <jstolarek> oh, and good catch with that Ord Type instance
08:26:10 * ski nods re `Syntax'
08:27:38 <ski> why `Fun (Code Exp)' rather than something involving `a' ?
08:29:34 <jstolarek> beacuse we never use anything else nad this is to express that invariant
08:29:41 <jstolarek> s/nad/and/
08:31:43 <ski> mhm
08:32:06 <ski> re `TRaise Trace', what if an exception is raised inside the expression computing the exception to raise ?
08:32:22 <Tuplanolla> Is it usually a better idea to explicitly order your monad stack and give it a new type rather than name the mtl constraints (with `ConstraintKinds`) and carry them around?
08:32:25 <jstolarek> you mean a nested exception?
08:32:41 <jstolarek> the most nested exception counts
08:33:19 <jstolarek> ski: https://github.com/jstolarek/slicer/blob/references/examples/exceptions.tml
08:33:21 <ski> i mean the expression computing the exception value to raise doesn't terminate, and so the raising doesn't happen (because the expression raised an exception)
08:33:42 <ski> shouldn't this case be distinguished in the trace from the expression successfully computing an exception value, which is then raised ?
08:34:14 <jstolarek> ski: it should, but we're stilldiscussing what is the best way of doing this
08:34:25 <Tuplanolla> My options are `type MonadServer m = (MonadReader Server m, MonadResource m, MonadState Server m)` and `newtype ServerMonad m a = ServerMonad {runServerMonad :: StateT Server (ReaderT Server (ResourceT m)) a}`.
08:34:47 <jstolarek> sorry, let me put it differently
08:35:15 <jstolarek> I understand that you're asking about something like this:  raise (raise "foo") ?
08:35:26 <ski> yes
08:35:28 <barrucadu> Why do you have a Reader Server inside a State Reader?
08:35:37 <barrucadu> That Reader will not see changes made to the State, is that what you want?
08:36:18 <jstolarek> right.  So here we construct a TRaise inside a TRaise
08:36:25 <jstolarek> because this is what actually happened
08:36:30 <ski> just like you have a case `TIfExn Trace' for when the condition raises an exception, it would seem to be consistent to have a case `TRaiseExn Trace' when the expression inside a `raise' raises an exception
08:36:41 <Tuplanolla> I think it doesn't matter, barrucadu.
08:36:58 <jstolarek> ski: hm... I'll test that
08:37:07 <Tuplanolla> The reader only applies to constant data used by other threads.
08:37:18 <Tuplanolla> I guess I could swap them around if it looks suspicious though.
08:38:06 <ski> jstolarek : i mean, i don't get the whole framework here (e.g. should there be a type difference between traces that ends with an exception and those that don't ?) -- but from what little i understand, i'd expect consistency here, unless there's a good reason to deviate
08:38:59 <jstolarek> ski: I;m not sure if I have a good answer
08:39:19 <jstolarek> there's no consistency in recording exceptions
08:39:38 * ski isn't even sure what the point of this project is ..
08:39:54 <jstolarek> as you noticed there is an TIfExn  to record the fact that exception was raised in a condition
08:40:18 <jstolarek> but there are no similar constructs, eg. for operators that take an arbitrary list of arguments
08:40:31 <jstolarek> ski: like most of Haskell projects - get a paper published ;-)
08:40:37 <jstolarek> but seriously
08:40:44 <jstolarek> it's about slicing
08:40:54 <ski> as in type error slicing ?
08:41:03 * ski . o O ( Skalpel )
08:41:05 <jstolarek> or, to be more precise, slicing a functional language with references and exceptions
08:41:23 <jstolarek> I'm not sure what's type error slicing, so probably not
08:41:44 <ski> type error slicing is about giving better diagnoses for type errors
08:41:57 <jstolarek> this is close then
08:42:12 <ChaoticSun> Quit
08:42:22 <jstolarek> this is about giving better diagnoses of results of computations
08:42:31 <ski> basically, instead of flagging the location where an inconsistency was found, we flag all and exactly those locations which (from the POV of the knowledge of the language processor) contribute to the inconsistency
08:42:37 <jstolarek> by figuring out which parts of the code were used to compute a particular component of the result
08:42:44 <ertes> is it possible to have closed associated type synonyms?
08:42:44 <ski> at least one of these must be changed in order to make the inconsistency go away
08:44:33 <ski> "Skalpel: A Type Error Slicer for SML" <http://www.macs.hw.ac.uk/ultra/skalpel/>
08:44:57 <ski> jstolarek : hmm .. sounds related to declarative debuggers
08:45:13 <ertes> nevermind, the question didn't really make sense
08:45:33 <bitonic> When I do `cabal repl`, is there a way to expose all packages in the package db for usage?
08:45:35 <ski> (i recall reading something similar to "figuring out which parts of the code were used to compute a particular component of the result" in a paper for Mercury. was it "Vimer", perhaps ?)
08:45:35 <jstolarek> ski: yes, this is about debugiing a compiled program rather than figuring out why a program does not compile
08:46:48 <ski> "Divide-and-query and subterm dependency tracking in the Mercury declarative debugger" by Ian MacLarty,Zoltan Somogyi,Mark Brown in 2005-09 at <https://www.mercurylang.org/documentation/papers.html#dd3>
08:46:52 <ski> i think
08:48:31 <jstolarek> thanks
08:48:38 <jstolarek> I'll take a look - might be related
08:49:55 <bitonic> Or in other words, is there a flag that undoes `-hide-all-packages`?
09:04:59 <mbrock> it's both fun and sad to run into seeming limitations of the type system
09:05:54 <mbrock> I have functions like ``frob :: (HasFoo s foo, HasBar foo Bar) => ...'' and these Has- constraints are quite repetitive, so I want to factor them out using the constraint kind
09:06:47 <mbrock> but when I try, I run into needing to do something like ``type HasFooBar s = forall foo. (HasFoo s foo, HasBar foo Bar)'' which fails explicitly because "Illegal polymorphic type; a constraint much be a monotype"
09:08:57 <Creepster> Hi all.
09:09:08 <Creepster> Lenses...
09:09:26 <mbrock> actually it might just make sense to pass all the "intermediate" type variables into the type alias anyway, it's just a bit of boilerplate I'd like to avoid
09:09:29 <Creepster> Is there some combinator for filtering based on a predicate?
09:10:03 <Creepster> That is, for all monsters, decrease the health by 20, BUT ONLY IF THEIR RACE IS "OGRE"?
09:11:41 <ski> mbrock : hm, and you actually wanted higher-rank constraints here ?
09:12:03 <ski> mbrock : `frob :: (HasFoo s foo, HasBar foo Bar) => ...' suggests a non-higher-rank constraint ..
09:12:58 <ski> does `foo' (or `s') occur in `...' ?
09:12:58 <Creepster> I guess I'm looking for a traversal with a predicate... Hmm...
09:14:05 <Creepster> filtered! Good!
09:14:15 <mbrock> ski: in reality I have the constraint MonadState s m and ... is (say) "m ()"
09:14:33 <ski> with no other mention of `s' ?
09:14:53 <ski> (sounds strange)
09:15:23 <ski> .. i'm thinking that perhaps you want `exists' instead of `forall', above
09:16:03 <ski> otherwise, it should be possible to parameterize, as `type HasFooBar s foo = (HasFoo s foo, HasBar foo Bar)', and then use `HasFooBar s foo => ...'
09:16:31 <ski> ("otherwise", as in, since `exists' in constraints aren't supported, except possibly in LHC ?)
09:16:45 <mbrock> ah, yes, that's what I think I'll have to do
09:17:08 <ski> ok
09:17:30 <ski> so, iiuc, my main point is then that you were really looking for `exists' here, not `forall'
09:17:44 <platz> is there a way to specify byte literals?
09:17:46 <mbrock> that's good to know, thanks
09:18:03 <ski> .. not that it makes a difference practically here -- but it's good to clear out such conceptual misconceptions
09:18:47 <platz> i.e. I have a sequence of bytes in hex e.g. "2E0FFA" 
09:18:47 <mbrock> indeed, I just tossed in for all because I needed some way of introducing a variable, without thinking much
09:18:56 <platz> but i don't want to read this in from a file
09:19:18 * ski nods
09:20:06 <ski> mbrock : `forall' in constraints would be higher-rank constraints. e.g. as in `instance (forall a. Show a => Show (f a)) => Show (Fix f)'
09:20:37 <ski> (or in a type signature, as `blah :: (forall a. Show a => Show (f a)) => ..f..')
09:21:24 <mbrock> ah, right. But that's only allowed with a newtype, or something?
09:23:04 <ski> you could do `class Show1 f where showsPrec1 :: forall a. Show a => Int -> f a -> ShowS', with `Show1 f' replacing `forall a. Show a => Show (f a)'. but then you need to either manually instance `Show1', or do a generic instance (which perhaps isn't always wanted ?)
09:23:40 <ski> you could also pack dicts up with GADTs, replacing `forall a. Show a => Show (f a)' with an argument
09:24:01 <ski> (doesn't work for the `instance' case, but works for the function case)
09:24:19 <ski> possibly edwardk's `constraints' has something for this ..
09:24:51 * ski isn't sure mbrock is following ..
09:25:44 <mbrock> I basically need to read something to understand what the whole idea of higher rank anything is all about
09:25:56 <mbrock> also I'm in a taxi on my phone thinking hard ;)
09:26:38 <ski> understanding higher-rank first requires understanding polymorphism (properly)
09:27:15 <ski> (and understanding existentials (if not their ramifications) is also related, so one might as well try to grasp them at the same time)
09:28:12 <ski> mbrock : i'd offer to try to explain the important basic points here and now .. but perhaps it'd be hard to follow from the backseat (i hope at least not the driver's seat ;) of a cab ?
09:32:01 <mbrock> ski: I've arrived safely and acquired a bottle of chocolate cocoa porter so conditions are perfect
09:32:08 <ystael> In Emacs haskell-mode, is there a way to tell C-c C-l (`haskell-process-load-file`) that I want it to use my `test-suite` stack target (with test dependencies) instead of `library`?
09:34:17 <ski> mbrock : well, first thing to realize is that it's not the presence of a type variable in the type of something, that makes it polymorphic. it's the presence of `forall'
09:35:50 <mbrock> and `forall` is inserted implicitly so that people aren't forced to understand this stuff, right
09:36:24 <ski> (oh, and types like `[a] -> [a]' or `forall a. a -> a' are not "polymorphic types". a value having the latter type would be polymorphic, the type is not polymorphic. one could call the type a "universal" type, or a `forall'-type. there is a concept of "polymorphic type", but it's doesn't crop up that often. i'm mentioning this because people often confuse the terminology here)
09:36:32 <ski> mbrock : that's the short story, yes
09:36:45 <ski> in the long run, you need to understand `forall' anyway :)
09:37:02 <ski> take e.g.
09:37:08 <ski>   length :: [a] -> Int
09:37:38 <mbrock> I have vague memories from school about how typed lambda calculus actually has forall as a capital lambda or something, i.e. you make "functions from type to type"
09:37:55 <ski> in *most* situations, when there's a free type variable, here `a', in a type *signature*, that means it's implicitly bound, by a `forall a.' at the front of the type, just after the `::' of the signature
09:38:01 <threshold> 07:39 < lpaste_> threshold pasted “Scotty app: replace liftIO with lift, replace pure uid with uid createUser returns Maybe [T.Text]”
09:38:18 <threshold> 07:39 < lpaste_> threshold pasted “Scotty app: replace liftIO with lift, replace pure uid with uid createUser returns Maybe [T.Text]”
09:38:31 <ski> the exception to "most" is in case the type variable is *already* in scope
09:38:34 <threshold> 07:39 < lpaste_> threshold pasted “Scotty app: replace liftIO with lift, replace pure uid with uid createUser returns Maybe [T.Text]” at http://lpaste.net/352867
09:38:38 <threshold> Expected type: Web.Scotty.Internal.Types.ActionT L.Text IO [T.Text]
09:38:42 <threshold> Actual type: Web.Scotty.Internal.Types.ActionT L.Text Maybe [T.Text]
09:39:17 <threshold> I am not trying to align the types. I did that yesterday with the help of Koterpillar
09:39:45 <threshold> I am trying to refactor and make createUser have a less gruesome type :)
09:39:56 <threshold> I don't understand why the line "result <- lift $ createUser email" has an expected type of eb.Scotty.Internal.Types.ActionT L.Text IO [T.Text]
09:40:13 <threshold> Ultimately, I think it would be nice to return a User as suggested by Koterpillar, but this is a start
09:40:30 <ski> mbrock : well, the capital lamda thing is actually an explicit notation in (value) *expressions* for constructing a polymorphic value. it can be described as a function mapping an input type to an output value. e.g. `id : forall a. a -> a; id = /\ a. \(x : a). x'
09:41:08 <mbrock> ski: ah, ok, good clarification
09:41:58 <ski> in Haskell, the capital lambda there (and the corresponding application of a polymorphic value to a *type*) is implicit (but there's now an extension where you can write `id @Bool False' ..)
09:42:19 <ski> mbrock : anyway, here's an example of the exception
09:42:26 <ski> @src Functor
09:42:27 <lambdabot> class Functor f where
09:42:27 <lambdabot>     fmap :: (a -> b) -> f a -> f b
09:42:46 <ski> `a' and `b' are not already scope before that type signature, but `f' *is* !
09:42:58 <ski> hence that type signature (inside the class) really means
09:43:08 <ski>     fmap :: forall a b. (a -> b) -> f a -> f b
09:43:30 <ski> considering `fmap' as any freestanding operation, the signature would be
09:43:48 <ski>   fmap :: forall f. Functor f => forall a b. (a -> b) -> f a -> f b
09:43:53 <ski> which is just another way to spell
09:44:00 <ski>   fmap :: forall f a b. Functor f => (a -> b) -> f a -> f b
09:44:07 <ski> mbrock : does that make sense ?
09:44:22 <mbrock> yeah, that makes sense
09:44:33 <ski> also consider something like
09:44:42 <ski> @src Maybe
09:44:42 <lambdabot> data Maybe a = Nothing | Just a
09:45:00 <ski> here, one can *think* of the `a' here being bound by an implicit `forall' as in
09:45:19 <ski>   data  forall a. (Maybe a = Nothing | Just a)
09:45:38 <ski> iow, for every type `a', we're defining the type `Maybe a' as ...
09:45:56 <ski> (so we're defining a "family" of types, one for each concrete type we could use in place of `a')
09:46:31 <ski> but this (conceptual) `forall' is not the `forall' that occurs in types (`Maybe a = Nothing | Just a' is not a type, it's a `data' type specification)
09:46:36 <ski> similarly, in
09:46:43 <ski>   id x = x
09:46:50 <ski> we can conceptually think of this defining equation as
09:46:56 <ski>   forall x. (id x = x)
09:47:37 <ski> mbrock : this was going off a tangent for a bit, just to emphasize that not every `forall' one might think of would have to appear in a type
09:47:38 <danilo2> Hello guys! Is there any operator in Lenses that would allow me to write `[1 .. 10] & _head <op> (fmap (+1))` ? So It will allow me to process Maybe val into Maybe val 
09:48:32 <ski> (in the `Maybe' case, that's an example of a situation where the type variable `a' is not bound by the kind of implicitly-inserted `forall' that gets inserted just after `::' in type *signatures*)
09:49:18 <mbrock> basically every time we use a free type variable, there is some kind of implicit forall somewhere
09:49:34 <ski> well, there's some kind of implicit *binder* somewhere, yes
09:50:07 <ski> and, usually, it could be thought of as some kind of implicit `forall', either a type-`forall', or some other conceptual `forall'
09:50:16 <ski> mbrock : another thing that people sometimes stumble on : `[a] -> [a]' is *not* implicitly expanded to `forall a. [a] -> [a]'
09:50:34 <ski> i've been specifically talking about an implicit `forall' being inserted after the `::' in type *signatures*
09:51:41 <ski> if `[a] -> [a]' was implicitly expanded to `forall a. [a] -> [a]' (even if only in the case where `a' isn't mentioned elsewhere), then that would mean that `foo :: ([a] -> [a]) -> Bool' would mean `foo :: (forall a. [a] -> [a]) -> Bool' .. which is patently false
09:51:55 <ski> it means `foo :: forall a. ([a] -> [a]) -> Bool'
09:52:22 <ski> (`foo' here is just a silly example. if you like, you could think of it as being defined by `foo f = null (f [])')
09:53:30 <ski> mbrock : apart from `class',`instance',`data',`newtype',`type', the other situations where there's already a type variable in scope tends to involve the language extension `ScopedTypeVariables', so hopefully one knows when that is the case
09:53:45 <ski> going back to
09:53:49 <ski>   length :: [a] -> Int
09:53:50 <ski> which means
09:53:54 <ski>   length :: forall a. [a] -> Int
09:54:19 <ski> similarly to the `Maybe' case above, we can think of this as specifying
09:54:21 <ski>   forall a.
09:54:27 <ski>     length :: [a] -> Int
09:54:52 <ski> iow, for any type `a' (that the user/caller decides to pick), `length' *can* be used as having type `[a] -> Int'
09:55:09 <ski> mbrock : makes sense ? (any questions ?)
09:55:21 <mbrock> just a sec
09:57:03 <mbrock> right, `[a] -> [a]' isn't expanded like that in function type signatures, but all free type variables there are bound with one big forall quantifying the whole function type
09:57:34 <ski> yes, scoping over the whole type in the type signature, with the `forall's inserted at the front/root
09:58:34 <contiver> To write an SVG optimizer (along the lines of https://github.com/svg/svgo ), would it be better to write the parser from scratch, or is there an XML parser I'd benefit from using?
09:59:56 <ski> ok
10:00:11 <mbrock> and "foo :: (forall a. [a] -> [a]) -> Bool" requires a language extension, right?
10:00:18 <ski> yes (`Rank2Types')
10:00:55 <ski> so, just like something isn't a function in case its type doesn't involve `->' (specifically has an `->' as the root node in the abstract syntax tree (AST))
10:01:36 <ski> something isn't a polymorphic value unless its type looks like `forall a. ..a..' (for some choice of naming for the type variable `a'), where `..a..' is allowed (but not required) to refer to `a' (freely)
10:01:56 <ski> so, strictly speaking, `length' isn't a function, but a polymorphic value ..
10:03:06 <ski> .. but since the specialization from a  value of type `forall a. [a] -> Int' to, e.g. `[Integer] -> Int' is implicit on the value-level, it tends to be practical to call it a "polymorphic function", or just a "function" if the polymorphic part of it isn't relevant or important at the moment
10:03:48 <ski> (there's no such thing as a "zero-arity function")
10:04:39 <ski> the important point with polymorphism is that the choice of the actual type to use in place of the type variable `a' is left to the user/caller of the polymorphic value
10:05:11 <ski> and so, the callee/implementor of the polymorphic value has to be prepared for *any* type the user/caller could possibly pick
10:06:16 <ski> in the case of constrained polymorphism, like `sort :: forall a. Ord a => [a] -> [a]', the caller will pick `a', but must also provide evidence of the constraint `Ord a', in order to be able to use `sort' as a function (passing in an argument)
10:06:32 <mbrock> so you wouldn't call that "foo" function a polymorphic value, but rather a function whose argument is a polymorphic value
10:07:25 <ski> on the flip side of the coin, `sort' itself may assume nothing about the type `a' that the caller picks, *except* that it may use the fact that `a' is known to be an instance of `Ord' (and so the methods of that class can be used to manipulate the, otherwise, opaque (to `sort') values of type `a')
10:07:58 <ski> mbrock : `foo :: (forall a. [a] -> [a]) -> Bool' is definitely not a type signature of a polymorphic value, right
10:08:13 <ski> it expects (requires !) the *argument* to be polymorphic
10:08:21 <ski> which is very different from itself being polymorphic
10:08:27 <mbrock> right
10:08:31 <ski> (though both things can happen at the same time ..)
10:08:55 <Aruro> im using System.Directory.Extra to read filesrecursively and make HTML listing with lucid. however, i get problem with unicode. Unicode characters not printed correctly. My suspicion is that Data.Text.pack does not handle FilePath unicode very well?
10:09:13 <ski> in the case of `foo :: (forall a. [a] -> [a]) -> Bool', `foo' *itself* will pick the type to use for `a', and the *caller* (when providing that polymorphic callback) has to be prepared for *any* such choice of `a'
10:09:39 <ski> in fact, `foo' may even use its polymorphic argument more than ones, using different specific types in place of `a' in each case
10:09:48 <ski> s/ones/once/
10:10:26 <ski> so, by putting `forall' in an argument types, we've flipped the roles of who picks the type, and who has to be prepared for any choice
10:10:31 <ski> mbrock : you see this ?
10:11:35 <Aruro> how do i convert file path of the form "\1045\1045..." to Text correctly? so that printed to file it was displayed correctly
10:12:37 <mbrock> yes, foo gets to have fun by doing e.g. ``foo f = length (f [1,2,3]) == length (f "hello")''
10:12:44 * ski nods
10:13:16 <ski> mbrock : so, you need `Rank2Types' to place `forall's in argument types like this
10:13:42 <ski> (at the "top" level of the argument types. if you need to place it in "argument types of callback arguments,&c.", then `RankNTypes')
10:13:59 <ski> the type `forall a. [a] -> Int' has rank one
10:14:13 <ski> the type `(forall a. [a] -> [a]) -> Bool' has rank two
10:14:32 * jle` wonders if he has ever used a Rank3 or higher type
10:14:43 <ski> the rank is a measure of the maximum number of `->'s one has to "dive to the left of" to reach a `forall'
10:15:39 <mbrock> yeah what would be a rank three type?
10:16:11 <ski> something like `((forall a. ..a..) -> ...) -> ...'
10:16:15 <ski> @type callCC
10:16:17 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
10:16:33 <dolio> ((forall b. a -> Cont r b) -> Cont r a) -> Cont r a
10:16:51 <ski>   callCC :: forall m. MonadCont m => ((forall b. a -> m b) -> m a) -> m a  -- a sometimes proposed alternative typing, being rank-three
10:16:54 * ski nods
10:17:19 <ski> @type runST
10:17:21 <lambdabot> (forall s. ST s a) -> a
10:17:30 <ski> is another rank-two operation
10:17:47 <mbrock> okay. is there an interesting reason why Haskell has `Rank2Types' and `RankNTypes'?
10:18:16 <ski> (the alternative typing here would be more flexible, since `b' would be picked at each use of the "continuation", not picked at the site where it is captured)
10:18:38 <dolio> Way back, people were only sure implementing rank-2 was easy enough.
10:19:04 <ski> `Rank2Types' was implemented first. iirc, nowadays you get `RankNTypes' when you ask for `Rank2Types'
10:19:21 <Tuplanolla> You get a deprecation warning too.
10:19:28 <erisco> I hear RankNTypes is the fixed point of Rank2Types
10:19:57 <jle`> RankNTypes is the fixed point of Rank(+1)Types
10:20:01 <ski> mbrock : sometimes you want to store polymorphic things in data structures, iow have arguments of data constructors be polymorphic. that's `PolymorphicComponents'. using that, you can simulate `foo :: (forall a. [a] -> [a]) -> Bool', by inventing a new type for `forall a. [a] -> [a]', but then you get extra wrapping/unwrapping
10:20:22 <lyxia> Aruro: If your String is fine then Text.pack should work.
10:20:50 <ski> `Rank2Types' implies `PolymorphicComponents', and presumably the latter also turns on `RankNTypes' nowadays
10:21:17 <dolio> I don't think PolymorphicComponents turns on RankNTypes.
10:21:32 <ski> hm, ok
10:22:34 <ski> mbrock : e.g. you may have heard about how `class Eq a where (==),(/=) :: a -> a -> Bool' can be thought of as implemented in terms of `data EqDict a = MkEqDict {eq,neq :: a -> a -> Bool}', and explicitly passing dictionaries around instead of implicit type class constraints being automatically propagated (and constructed)
10:22:48 <Aruro> lyxia: i have cyrillic filenames, my string is obtained through getDirectoryContents (im using System.Directory.Extra)
10:23:14 <srhb> Is there some way to get the error in foo = bar 1 where bar = _ to actually constrain the type of bar?
10:23:21 <mbrock> I seem to recall that polymorphic components in data types were called "existential types" years ago
10:23:25 <ski> mbrock : in the case `class Functor f where fmap :: forall a b. (a -> b) -> f a -> f b', whis would be `data FunctorDict f = MkFunctorDict {fmap :: forall a b. (a -> b) -> f a -> f b}', requiring at least `PolymorphicComponents'
10:23:35 <srhb> Short of inlining it, of course.
10:23:35 <ski> mbrock : no, existentials is something different
10:23:52 <Aruro> lyxia : when i renderToFile in lucid i get wrong characters in these file names
10:24:21 <Aruro> completely unreadable
10:24:53 <ski> mbrock : anyway, existentials was the point i wanted to get to, next :)
10:25:03 <mbrock> ok :)
10:25:40 <dolio> srhb: -XMonoLocalBinds
10:25:51 <ski> mbrock : a value of type `forall a. ..a..' can be treated as a value of type `..a..', provided the user picks a particular specific type for `a'. iow for every type `a', it can be treated as having type `..a..'
10:26:33 <ski> mbrock : a value of type `exists a. ..a..' consists of a choice of a type `a', and a value having type `..a..'. iow, there *exists* some type `a', such that the value has type `..a..'
10:27:06 <srhb> dolio: Seems to do nothing.
10:27:23 <ski> mbrock : however, you can't (in the general case, there are some tricks that sometimes apply) recover the actual type `a' that was used when constructing the value. you have to treat it as an abstract/opaque type
10:27:37 <Aruro> lyxia: though less shows that characters in resulting html file are correct, like in terminal. so it seems problem of browser?
10:28:20 <ski> mbrock : when *consuming* a value of type `forall a. ..a..', you pick a specific type to use for `a', and then you consume the value of type `..a..', for that choice of the type `a'
10:28:32 <srhb> dolio: Interestingly, it works if I provoke a type error instead of using a hole.
10:28:38 <srhb> dolio: With and without that extension.
10:28:45 <lyxia> Aruro: maybe. Have you checked the encoding setting in your browser
10:28:47 <Tuplanolla> The browser probably assumes ISO 8859-1, Aruro.
10:29:06 <Aruro> lyxia: yes, i put now Unicode and all is visible correctly :)
10:29:10 <ski> mbrock : then *producing* a value of type `forall a. ..a..', you must be prepared for any choice that the user makes when picking `a', so you must treat `a' as abstract/opaque, being prepared for anything
10:29:30 <ski> mbrock : when *producing* a value of type `exists a. ..a..', you pick a specific type to use for `a', and then you produce a value of type `..a..', for that choice of the type `a'
10:29:32 <srhb> I guess I'll just make a data constructor that will always be an error.
10:29:51 <ski> mbrock : then *consuming* a value of type `exists a. ..a..', you must be prepared for any choice that the producer/implementor made when picking `a', so you must treat `a' as abstract/opaque, being prepared for anything
10:30:33 <Aruro> lyxia: ty
10:30:34 <ski> mbrock : so in this sense, `forall' and `exists' are exactly the opposites of each other, exchanging the roles of producers and consumers, wrt who gets to pick the type, and who must be prepared for any choice of the type
10:30:51 <ski> mbrock : here's a silly example of `exists' :
10:31:09 <ski>   frob :: Bool -> exists a. (a,a -> a,a -> String)
10:31:34 <ski>   frob False = ( True  ,not,show)
10:31:51 <ski>   frob True = ("False",reverse,id)
10:32:32 <ski> mbrock : you should note that the choice of the type `a' in the return type of `frob' here depends on the *run-time* input value
10:32:40 <ski> mbrock : makes sense, so far ?
10:34:33 <mbrock> is your type signature a typo for ``Bool -> exists a. (a, a -> a, String)''?
10:34:50 <mbrock> wait nevermind
10:34:52 <ski> no
10:35:09 <mbrock> sorry I was just confused by your spacing and the precedences of , and -> :)
10:35:26 <ski> in the `False' case, `a = Bool', and so `show :: Bool -> String' fits in the third component
10:35:40 <mbrock> yes, my bad. Is that code valid GHC with some extension?
10:35:44 <ski> in the `True' case, `a = String', and so `id :: String -> String' fits in the third component
10:35:48 <ski> no
10:36:13 <ski> i'm using the `exists' notation to get the concept across (imho) more clearly
10:36:35 <ski> iirc, in LHC, you could actually use `exists' .. but only in argument types
10:36:50 <ski> in GHC, there's basically two ways to *encode* an `exists'
10:36:55 <mbrock> ok
10:37:05 <ski> (if you have time, i'll go through both of them)
10:37:28 <ski> but i hope the basic idea of how `exists' is supposed to work is sufficiently clear
10:38:07 <ski> (Mercury is a language that allows existential quantifiers in types, called `some' there)
10:39:18 <ski> mbrock : anyway, to use a value of type `(a,a -> a,a -> String)', basically what you can do is pass the `a' value through the function of type `a -> a' some fixed number of times, and then convert it to a `String' to inspect the result
10:39:33 <ski> er, of type `exists a. (a,a -> a,a -> String)', i meant
10:40:43 <mbrock> yeah
10:40:56 <ski> mbrock : this is related to abstract data types. one way to specify the *interface* of e.g. queues, would be to have a type `exists q. (q,a -> q -> q,q -> Maybe (q,a))', where the first component is the empty queue, the second is the `enqueue' operation, the third is the `dequeue' operation
10:41:33 <ski> each *value* of type `exists q. (q,a -> q -> q,q -> Maybe (q,a))' would correspond to a (potentially) *different* implementation of the queue interface
10:42:05 <ski> you'd use such an implementation by "opening" it once, then operating with the operations inside until you're done with your queue
10:43:14 <ski> one choice would be to pick `q' as `[a]'. a more efficient choice would be to pick it as `([a],[a])', where we represent a queue with elements like e.g. `2',`3',`5',`7',`11',`13' as `([2,3],[13,11,7,5])'
10:43:36 <ski> iow `front ++ back' is conceptually represented as `(front,reverse back)'
10:44:30 <ski> mbrock : anyway, now i want you to realize that the type `(exists a. ..a..) -> ...' is basically the same thing as `forall a. (..a.. -> ...)' (brackets for emphasis)
10:44:33 <ski> iow
10:44:42 <ski>   length :: forall a. ([a] -> Int)
10:44:44 <ski> is the same thing as
10:44:52 <ski>   length :: (exists a. [a]) -> Int
10:45:16 <ski> in the former case, we say that for any type `a', `length' can be applied to a value of type `[a]', yielding a result of type `Int'
10:45:21 <dolio> srhb: Hmm, strange.
10:46:07 <ski> in the latter case, we say that if the argument has type `[a]', for some type `a', then `length' can be applied to that, and the result has type `Int'
10:46:10 <ski> mbrock : ok ?
10:48:56 <mbrock> so it kind of relates to the notion of a polymorphic value versus a function that works on polymorphic values
10:49:18 <mbrock> I don't know if you would call (exists a. [a]) a polymorphic value though
10:49:28 <ski> i wouldn't
10:49:42 <ski> i'd perhaps call it an "abstract/opaque value"
10:49:47 <mbrock> okay, yeah
10:49:50 <nitrix> I'd word it differently as "if the function can work for all types `a`, surely we can also say there exists a type `a` such that this function works for it".
10:49:55 <ski> it's hiding some choice of `a' inside it
10:50:01 <byorgey> I'd call it a "natural number"
10:50:11 <ski> nitrix : *nod*
10:50:16 * ski grins at byorgey
10:50:22 <nitrix> mbrock: The two are synonymous.
10:50:34 <nitrix> (Well in that context)
10:51:20 <ski> `(exists a. ..a..) -> ...' means the same as `forall a. (..a.. -> ...)', while otoh `(forall a. ..a..) -> ...' is something different, closely related to `... -> (exists a. ..a..)' (`frob' above)
10:51:24 <mbrock> how's about ``length :: (forall a. [a]) -> Int''?
10:51:52 <mbrock> I guess that's a very strange type
10:52:05 <dolio> srhb: Oh, I know why. MonoLocalBinds doesn't just make local bindings monomorphic. It makes certain sorts of local bindings monomorphic.
10:52:05 <jle`> doesn't sound like a very useful type either
10:52:08 <ski> mbrock : so you should understand now how LHC allowed `exists' in argument type positions : namely by implementing `(exists a. ..a..) -> ...' as `forall a. (..a.. -> ...)', plain polymorphism
10:52:09 <jle`> *useful function
10:52:12 <mbrock> because the only value of forall a. [a] is [], right?
10:52:22 <ski> yep
10:52:28 <ski> (apart from partial values)
10:52:48 <dolio> srhb: And `bar = _` is nice enough to be generalized.
10:53:31 <ski> mbrock : you might also note that if we think in terms of type-passing. iow the `id = /\a. \(x : a). x' thing. then the difference between `forall a. (..a.. -> ...)' and `(exists a. ..a..) -> ...' is "currying"
10:53:37 <mbrock> is this `exists a. ...a...' equivalence with `forall a. (...a... -> ...)' also a logical tautology?
10:53:55 <nitrix> mbrock: Yeah now you're explicitly saying that the first argument of `length` must be a list whose values can be any type.
10:54:07 <ski> mbrock : in the latter, we take a pair of a type `a', and a value of type `..a..' as argument. in the former, we first take a type `a', and return a function that takes a value of type `..a..'
10:54:07 <mbrock> eh, `exists a. ...a... -> ...'
10:54:41 <ski> mbrock : if you meant `(exists a. ...a...) -> ...', then yes. it's a logical tautology (holding both classically and intuitionistically)
10:54:46 <dolio> ski: I think LHC allows exists anywhere, but you can't constrain the quantified types.
10:55:30 <ski> mbrock : otoh, the similar logical equivalence between `(forall a. ..a..) -> ...' and `exists a. (..a.. -> ...)' only holds classically, not constructively/intuitionistically
10:55:39 <nitrix> mbrock: [42, "hi", True]. Normally lists are homogeneous in Haskell because there's not anything useful you can do with `[forall a. a]` other than the length of the list.
10:56:14 <ski> mbrock : the difference in terms of computation is that in the latter case, we have picked a single type `a', while in the former (rank-two) case, we can use the polymorphic argument as many times as we like, and so pick many different `a's
10:56:30 <reactormonk> In ghci, what's a way to unlift an Either in ghci? Aka Right a -> a
10:56:36 * ski idly wonders whether nitrix was thinking of `[exists a. a]'
10:56:41 <nitrix> ski: My bad.
10:56:43 <nitrix> I was.
10:56:53 <jle`> reactormonk: you can pattern match
10:57:06 <ski> dolio : ok. news to me. ty
10:57:09 <reactormonk> jle`, I've tried Either foo <- ...
10:57:18 <reactormonk> Ehh Right foo
10:57:29 <jle`> Right foo <- return bar
10:57:29 <nitrix> ski: It gets confusing quickly when you're reading other messages too x]
10:57:30 <jle`> should work
10:57:36 <jle`> or let Right foo = bar
10:57:38 <nitrix> ski: I'll let you handle it.
10:57:51 <jle`> the second one probably is less silly
10:57:53 <reactormonk> jle`, yeah, was let. Thanks.
10:58:15 <ski> mbrock : shall i continue ?
10:58:20 <dolio> ski: I'm not 100% sure. But just putting it in argument position wouldn't be very interesting. :)
10:58:27 <ski> dolio : .. exactly :)
10:58:46 <ski> dolio : mostly useful for type synonyms
10:59:10 <ski> dolio : .. someone (i realized) was wanting `exists' in constraint type synonyms here, a few hours ago
10:59:39 <dolio> Yeah, that's another level beyond what they don't support.
11:00:38 <ski> to be able to abbreivate `forall a b. (Foo a,Bar a b) => ..b..' as `forall b. FooBar b => ..b..', with `type FooBar b = exists a. (Foo a,Bar a b)'
11:01:20 <dolio> Oh, I see. That'd be somewhat more feasible, I suppose.
11:01:46 <mbrock> my specific desire comes from using lens-ish "HasFoo", "HasBar" classes for record fields, in combination with parametricity, to be very specific about which part of a state record is needed for a particular function
11:01:53 <ski> shouldn't be harder than `exists' in argument type positions, from what i see
11:02:17 <ski> (oh, perhaps that someone was mbrock .. i've already forgotten :)
11:02:22 <mbrock> and then wanting to abbreviate common combinations of fields, and combine those combinations too
11:02:26 <mbrock> yeah (:
11:03:41 <mbrock> like ``type HasMonsterHealth s = (HasMonster s monster, HasHealth monster Int)''
11:04:10 <mbrock> which would be written ``type HasMonsterHealth s = exists monster. (Has Monster s monster, HasHealth monster Int)''
11:04:21 <ski> (would need FDs to not be ambiguous, though, i think)
11:05:04 <ski> (and then, maybe, it would be nicer to use associated types ?)
11:06:03 <dolio> Yeah, possibly.
11:06:32 <ski> mbrock : do you want me to go on, now ?
11:07:14 <mbrock> ski: yes!
11:07:47 <ski> mbrock : ok. so i explained the producer/consumer duality for `forall a. ..a..' and `exists a. ..a..'
11:08:45 <ski> mbrock : nitrix hinted at stuff like `[exists a. ..a..]', and i could go on with some discussion of how that differs from `exists a. [..a..]'. and similarly how `forall a. IO (Blah a)' differs from `IO (forall a. Blah a)'
11:09:28 <ski> mbrock : but, first at least, i wanted to explain `.. => ..' vs. `.. *> ..' (the latter also being non-existing, conceptual syntax)
11:10:28 <ski> mbrock : to consume a value of type `C a => Foo a', you must provide evidence for `C a' (for the particular `a' that's in scope). to produce it, you may freely *assume* `C a' holds
11:11:01 <reactormonk> With parsec, is there a way to call it similar to Read?
11:11:40 <ski> mbrock : typically (but not always) `=>' is used together with an immediately preceeding `forall', like `forall m t. MonadState (StateBlah t) m => ..m..' perhaps
11:12:20 <reactormonk> aka `parseParsec ::  Parsec a => String -> Either ParseError a`
11:12:40 <reactormonk> There's all the parseFromFile stuff, but nothing without IO
11:12:55 <ski> mbrock : now, to *produce* a value of type `C a *> Foo a', you must produce evidence for `C a', and "bundle" it up (implicitly) with a value of type `Foo a'. to consume it, you may freely assume `C a' holds, and also use the value of type `Foo a'
11:13:45 <reactormonk> Ah, you simply use `parsec`. Blubb.
11:13:50 <ski> mbrock : we have a similar logical equivalence between `(C a *> Foo a) -> ...' and `C a => (Foo a -> ...)' ("currying" again)
11:14:31 <ski> mbrock : conceptually, a value of type `(C a *> Foo a)' is a pair of evidence for `C a' (e.g. a type class dictionary, with implementations of methods), coupled with a value of type `Foo a'
11:15:01 <ski> mbrock : while a value of type `C a => Foo a' conceptually is a function that when given evidence for `C a' will give you back a value of type `Foo a'
11:16:10 <ski> mbrock : again, `*>' is typically (but not always) coupled with an immediately preceding `exists'. like `[exists a. Show a *> Tree a]', perhaps
11:16:21 <ski> mbrock : is this making any sense ?
11:16:59 <mbrock> that last example seems to make sense
11:17:32 <ski> for each element of that list, there's some type `a', which is showable, such that the element is a tree with elements of type `a'
11:17:34 <mbrock> I see how that would let the consumer assume that (Show a) is true (because they would have access to the actual type class dictionary)
11:17:45 <ski> yes
11:18:29 <ski> if you moved the `exists' outside the list type constructor, then there'd be a single hidden/unknown/opaque/abstract type `a', for all the elements
11:19:07 <ski> with `exists' inside, it can be different for different elements (and so a consumer must treat the elements as if the `a' types actually *are* different, since they might be)
11:19:25 <mbrock> and `[forall a. Show a => Tree a]' would be the same kind of mostly useless type with only trivial/partial inhabitants as `[forall a. a]'
11:19:36 <ski> yep
11:20:00 <ski> using `Arbitary' instead of `Show', might be somewhat more useful, there
11:20:32 <ski> btw, you can easily do the `[exists a. Widget a *> a]' kind of OO thing here
11:20:55 <ski> existentials are related to OO, and to abstract data types. but these two uses use existentials in different ways
11:21:31 <ski> ADTs use existentials by making an existential record of operations (like the "queue" example above), opening it once, then using the operations inside directly
11:22:10 <ski> the "OO" version instead keeps repacking the current internal state (typed with the existentially quantified variable) with the operations/methods
11:22:56 <ski> with ADTs, it's easy to e.g. merge. not so with the OO approach here, since you only know the implementation of "yourself", not of other values that conform to the interface
11:23:11 <ski> .. but this is also an aside, unless you want to hear more about it
11:24:02 <ski> mbrock : what i wanted to get to was the two ways of encoding `exists' (and `*>') in GHC, so that you can actually use it
11:24:13 <mbrock> yeah
11:24:51 <ski> so, let's consider the type `exists q. (q,a -> q -> q,q -> Maybe (q,a)' again, the queue-ops example
11:25:21 <ski> so, the first encoding
11:25:31 <ski> it requires defining a new type (inventing a name)
11:25:58 <ski> so that instead of writing `exists q. (q,a -> q -> q,q -> Maybe (q,a))' in your type signature, you instead write `QueueOps a' (say)
11:26:36 <ski> (and it also requires wrapping and unwrapping of data constructor -- not that that is a big burden here, since usually one'd have to pack/unpack the triple here anyway)
11:26:45 <ski> so, we want to be able to say something like
11:27:01 <ski>   data QueueOps a = MkQO (exists q. (q,a -> q -> q,q -> Maybe (q,a)))
11:27:02 <threshold> Sorry about earlier, I didn't mean to spam the lpaste link 3 times
11:27:10 * ski figured
11:28:17 <ski> mbrock : anyway, there's a different style of defining `data' types, that adds some extra power (though it's not strictly needed here). in this syntax, you instead explicitly specify the type signatures of the data constructors, like
11:28:24 <ski>   data QueueOps a
11:28:28 <ski>     where
11:28:45 <ski>     MkQO :: (exists q. (q,a -> q -> q,q -> Maybe (q,a))) -> QueueOps a
11:28:50 <ski> mbrock : ok, so far ?
11:30:03 <ski> (btw, this style is called Generalized Algebraic Data Types, or GADTs (language extension) for short)
11:30:15 <mbrock> yep
11:30:59 <ski> if we want to consider `MkQO' as "just another operation, with a given type", the type signature (outside of the context of the `data' definition above) would be
11:31:07 <ski>   MkQO :: forall a. (exists q. (q,a -> q -> q,q -> Maybe (q,a))) -> QueueOps a
11:31:15 <ski> (that's an aside)
11:31:39 <mbrock> I'm guessing we will make QueueOps into a type family thing? :)
11:31:49 <ski> nah :)
11:31:59 <ski> in any case, what you now should recall is the logical equivalence between `(exists a. ..a..) -> ...' and `forall a. (..a.. -> ...)', which means that we can now reformulate
11:32:03 <ski>     MkQO :: (exists q. (q,a -> q -> q,q -> Maybe (q,a))) -> QueueOps a
11:32:04 <ski> as
11:32:16 <ski>     MkQO :: forall q. (q,a -> q -> q,q -> Maybe (q,a)) -> QueueOps a
11:32:30 <ski> or, letting this `forall' also be implicit (since this is a type signature), just
11:32:37 <ski>     MkQO :: (q,a -> q -> q,q -> Maybe (q,a)) -> QueueOps a
11:32:54 <ski> note that the data constructor `MkQO' is *polymorphic* in `q' (as well as `a')
11:33:22 <ski> it can work with any particular type `q' (and `a') the caller of `MkQO' decides to pick, when making a queue implementation
11:33:36 <mbrock> ah, ok, yes
11:33:43 <ski> e.g., perhaps `a' is picked as `Char', and `q' as `Text' (though that would probably not be so efficient for queues)
11:34:21 <ski> anyway, what's important here is that, while `a' is mentioned in the return type `QueueOps a' of the data constructor, the type variable `q' is *not* mentioned there !
11:34:50 <ski> this means that after picking `Char' for `a' and `Text' for `q', we get something of type `QueueOps Char', where there's now no trace any longer of `Text' being picked
11:35:37 <ski> iow, the choice of `Text' has been hidden from the result type. a consumer will have to treat `q' as abstract/opaque/unknown, since there's no way to recover it from the return type `QueueOps Char' (while `Char' *can* be recovered from that)
11:35:42 <mbrock> right, so when constructing a queue instance there needs to be an actual q, but it becomes abstract
11:35:55 <ski> *nod*, because it's elided from the return type
11:36:29 <ski> if one wants to use the GADT style, then any of the two last versions above suffices for defining `QueueOps'
11:36:42 <ski> if one wants to use the (older) non-GADT style, then one should type
11:37:01 <ski>   data QueueOps a = forall a. MkQO (q,a -> q -> q,q -> Maybe (q,a))
11:37:11 <ski> er, sorry
11:37:14 <ski>   data QueueOps a = forall q. MkQO (q,a -> q -> q,q -> Maybe (q,a))
11:38:01 <ski> the `forall' here means that the data constructor `MkQO' is *polymorphic* (in `q') .. which *effects/encodes* an existental quantification of the argument type, via the logical equivalence
11:38:08 <ski> people sometimes gets confused about this
11:38:13 <ski> if one would instead write
11:38:17 <mbrock> ok, and that's what's called an "existential type"? and it doesn't use an "exists" keyword because it's using this equivalence
11:38:22 <ski>   data QueueOps a = MkQO (forall q. (q,a -> q -> q,q -> Maybe (q,a)))
11:39:04 <ski> then that would be *very* different, then `MkQO' would have a polymorphic *argument* (iow it would have a rank-two type), instead of *itself* being polymorphic (but forgetting `q' in the return type)
11:39:11 <ski> mbrock : right
11:39:35 <ski> also, you should note that the "existential" part really doesn't attach to the type itself, per se, but rather to the data *constructor*
11:39:52 <ski> you can easily have a type with some data constructors being "existential" in this way, while others are not
11:40:13 <mbrock> the data type definition is saying something like "for any q, you can construct a MkQO involving that q", but then to actually construct an MkQO you will use a concrete q
11:40:44 <mbrock> (or maybe you could somehow come up with a MkQO construction that works for any q)
11:40:54 <ski> but relatively often, when we use this feature, we only have one data constructor, often with only a single argument (i'll come to this), and so we use the term "existential data type" for the data type *encoding* the corresponding `exists q. ..q..'
11:41:19 <ski> mbrock : yes and yes (or for picking `q' as `Blah x' for any `x', say)
11:41:52 <ski> (or `x' is perhaps a type variable that you're being polymorphic in, and which also occurs in other places in your type signature of your operation)
11:42:32 <ski> anyway, instead of
11:42:36 <ski>   data QueueOps a = forall a. MkQO (q,a -> q -> q,q -> Maybe (q,a))
11:42:43 <ski> we could choose to use
11:42:54 <ski>   data QueueOps a = forall a. MkQO q (a -> q -> q) (q -> Maybe (q,a))
11:42:59 <ski> with multiple separate arguments
11:43:09 <ski> in GADT terms, this'd be
11:43:15 <ski>   data QueueOpa a
11:43:16 <ski>     where
11:43:40 <ski>     MkQO :: forall q. q -> (a -> q -> q) -> (q -> Maybe (q,a)) -> QueueOps a
11:44:11 <ski> now, since this is of the form `forall q. (..q..) -> (..q..) -> (..q..) -> ...', we can't directly use the logical equivalence, short of uncurrying back again
11:44:30 <ski> still, we'd usually also call this an "existential data type"
11:44:37 <ski> one could also use record syntax, like
11:45:01 <ski>   data QueueOps a = forall q. MkQO {emptyQ :: q,enqueue :: a -> q -> q,dequeue :: q -> Maybe (q,a)}
11:45:17 <ski> (it is also possible to specify record syntax, when using the GADT style)
11:45:43 <cocreature> Hey, warp seems to be killing threads due to timeouts but it so that _after_ the request has finished (see http://lpaste.net/352887 for the output with -xc and stdoutdev logging). Any ideas what could be causing this? it can hardly be the request taking too long it stdout logging already prints the response
11:45:51 <ski> mbrock : now, if you wanted to express `exists a. Show a *> a', then that would become
11:45:53 <cocreature> I’m using servant if that matters
11:46:14 <ski>   data Showable = forall a. Show a => Wrap a
11:46:16 <ski> alt.
11:46:19 <ski>   data Showable
11:46:20 <ski>     where
11:46:29 <ski>     Wrap :: Show a => a -> Showable
11:47:00 <ski> mbrock : so it's also straight-forward to encode `*>' in this fashion
11:48:17 <ski> mbrock : btw, note that `Showable' probably isn't that more useful than `String' itself -- you should probably think twice, when about to use an existential, namely think about whether you actually need to extra power (and perhaps headache) of existentials :)
11:48:27 <ski> @where existential-antipattern
11:48:27 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
11:48:31 <ski> has some more info on that
11:49:02 <mbrock> ah, yeah
11:49:05 <ski> mbrock : following ? questions ?
11:49:22 <Xe> ski: haskell doesn't have a ternary operator though
11:49:51 <ski> (e.g. note that many things are harder to do with existentials. e.g. making an instance of `Eq' is often impossible)
11:49:54 <kadoban> xD it does, it's just called  if then else
11:50:04 <ski> Xe ?
11:51:18 <kgadek> Xe: hmmmmmmmmm `container & lens .~ value` ?
11:51:29 <ski> mbrock : i'll continue with the other encoding now, if you don't object
11:52:44 <mbrock> ski: ok, yes I'm following, go ahead :)
11:53:59 <ski> mbrock : hm, i just recalled i forgot to say earlier that rank-two can be used both (a) when you actually need to use an argument with different polymorphic specializations; and (b) when you want to avoid disclosing through the type signature which particular type you want to use the argument at (information hiding)
11:55:21 <ski> mbrock : so if you see `foo :: (forall a. ..a..) -> ...', it could be either because `foo' needs to use the "callback" with multiple choices of `a', or because it doesn't want to put the actual `a' it picks in the type signature (dropping the `forall'). the latter option is more closely related to existentials (`exists')
11:56:18 <ski> mbrock : one reason for not wanting to put the actual `a' it uses in the type signature could be that it doesn't want the callback to be able to rely on the particular choice
11:57:18 <ski> mbrock : e.g. we could have something like `foo :: (forall a. Foo a -> Bar a) -> ...', where `foo' will provide a value of type `Foo a', perhaps containing a record of available operations on `a', and the caller can't use any other operations on `a' values, apart from these
11:58:23 <ski> mbrock : <http://lpaste.net/10060> is an example of the (b) use of rank-two, where i wanted to hide the fact that i used an output (`Writer') monad
11:59:17 <ski> in this case, the argument i supply to the callback will do "logging", but i don't want the callback to be able to mess things up by attempting to insert its own log entries
11:59:39 <ski> mbrock : anyway .. enough about that !
12:00:05 <ski> mbrock : so, continuation-passing style ..
12:00:54 <ski> mbrock : the idea of CPS is that instead of returning a value normally, you instead take an extra argument, the continuation, and instead of returning a value, you call the continuation with the value you wanted to return
12:01:02 <mbrock> yeah
12:01:30 <ski> mbrock : the point of this is that one can then, sometimes, do other things than simply returning through the continuation eventually
12:01:58 <ski> e.g. one could "jump out" of a deeply nested recursion (like an exception would)
12:02:24 <ski> and one can do even stranger things, like a call "returning" more than once
12:02:47 <ski> if you see a type that looks like `(a -> o) -> o', chances are that CPS may be related in some way
12:03:18 <ski> `a' is the type of the "original" return value. `a -> o' is the type of the contiuation which accepts such a value, and produces a value of type `o', the "final result/answer" type
12:03:32 <ski> @src Cont
12:03:33 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
12:04:08 <mbrock> right
12:04:13 <ski> @type flip all
12:04:15 <lambdabot> Foldable t => t a -> (a -> Bool) -> Bool
12:04:16 <ski> @type cont . flip all
12:04:19 <lambdabot> Foldable t => t a -> Cont Bool a
12:04:43 <mbrock> @type cont
12:04:45 <lambdabot> ((a -> r) -> r) -> Cont r a
12:04:53 <ski> it's the data constructor `Cont' above
12:04:59 <mbrock> makes sense
12:05:08 <mbrock> yeah
12:05:20 <nitrix> Is there a O(n) way of mutating an element of a list chosen randomly?
12:05:31 <ski> (except the library got slightly redesigned so that now `Cont o a' is defined as `ContT o Identity a' so the real data constructor is `ContT', hence `cont' rather than `Cont')
12:05:42 <ski> here, we "pretend" that `cont . flip all' will "extract *any* element" of the collection"
12:06:54 <kadoban> nitrix: Check the length, choose a random number in that range, "mutate" that element?
12:06:54 <ski> while, in reality, it'll wrap all the "follwing/surrounding context" (the continuation) of the call as a callback, pass that to `all' for each element of the collection, then use the monoid `True'&`(&&)' to reduce all these `Bool's to a single `Bool' result
12:07:34 <ski> mbrock : anyway, if you treat the "final answer" type `o' abstractly, then you wouldn't be able to do this "strange thing" (adding the extra power of CPS)
12:07:51 <ski> mbrock : i claim that the type `forall o. (a -> o) -> o' is equivalent to just plain `a'
12:08:15 <ski> mbrock : clearly, if `x :: a', then `\k -> k x' has type `forall o. (a -> o) -> o', that's easy
12:09:09 <ski> mbrock : in the other direction, if we have a value of type `forall o. (a -> o) -> o', then since (inside the `forall') it's a function, it must be of the form `\k -> ..k..' (when evaluated enough, unless it's partial, of course)
12:09:44 <ski> mbrock : now, since the type `o' here must be treated opaquely, we know that the only way `..k..' can get hold of a result value of type `o' is by calling `k' on some argument of type `a'
12:09:55 <c_wraith> tangentially, this is why Codensity is better than ContT if your only goal is reinversion of control
12:10:34 <ski> mbrock : it could possibly call `k' on more than one such value, but it must then pick which `o' to return. since the language is non-strict, this means there is some `x :: a' such that the value of type `forall o. (a -> o) -> o' must actually be of the form `\k -> k a'
12:10:37 <c_wraith> the universal quantification prevents lots of continuation tricks. 
12:11:29 <ski> mbrock : then, to check that this is an isomorphism, one should also check that going "there and back again" is the same as doing nothing, for both ways of doing that .. but i'll leave that part of the argument "as an exercise" (if you feel like it)
12:11:46 <nitrix> kadoban: Wouldn't this gives me O(2n) ?
12:11:58 <kadoban> O(2n) is the same set as O(n)
12:12:22 <nitrix> I'm not following. The list is traversed twice if I need its length.
12:12:25 <ski> mbrock : this is an *informal* argument (the formal involves something called "parametricity"), but hopefully it should give you some intuition supporting the notion that `forall o. (a -> o) -> o' "ought" to be the same as `a', in terms of the information expressed
12:12:28 <kadoban> If you want, you can use lists annotated with their length though.
12:12:31 <ski> mbrock : does that make sense ?
12:12:42 <nitrix> kadoban: Do Haskell has that :D !?!
12:13:04 <kadoban> nitrix: Not sure if it's in base, I've done it myself ocasionally.
12:13:06 <nitrix> Dependently typed would be even better but I'm keeping my hopes low.
12:14:18 <kadoban> It's not going to change the asymptotic behavior, so I usually wouldn't bother unless it's too slow as-is.
12:14:26 <ski> (as c_wraith said, CPS is related to "inversion of control". it has been used for programs running on, or talking to, web servers, in order to hide the abrupt changes in control between internal computation and waiting for the user to fill in the next form, on the next page)
12:14:53 <ski> mbrock : anyway, this is more or less as much about CPS as i wanted (needed) to explain here ..
12:15:48 <mbrock> ski: yes, I see how `forall o. (a -> o) -> o' must basically be `($ x)' where x :: a
12:16:00 <ski> good
12:16:18 <ski> mbrock : now, we apply this, to get the other encoding (the CPS encoding) of `exists' (and `*>')
12:16:22 <mbrock> it's like the continuation-passing version of `forall a. a'
12:17:13 <ski> mbrock : we start with `exists a. ..a..', which is equivalent to `forall o. ((exists a. ..a..) -> o) -> o', which is equivalent to `forall o. (forall a. ..a.. -> o) -> o'
12:18:03 <ski> mbrock : similarly, starting with `C a *> Foo a', we get `forall o. ((C a *> Foo a) -> o) -> o', which is `forall o. (C a => Foo a -> o) -> o'. having both `exists' and `*>' at the same time is similar
12:18:34 <ski> mbrock : this means that, instead of having
12:18:53 <ski>   folkloreQueueOps :: forall a. QueueOps a
12:19:16 <ski>   folkloreQueueOps = MkQO (([],[]),enqueue,dequeue)
12:19:17 <ski>     where
12:19:24 <ski>     enqueue = ...
12:19:28 <ski>     dequeue = ...
12:19:31 <ski> we instead do
12:20:13 <ski>   withFolkloreQueueOps :: forall a o. (forall q. q -> (a -> q -> q) -> (q -> Maybe (q,a)) -> o) -> o
12:20:29 <ski>   withFolkloreQueueOps k = k ([],[]) enqueue dequeue
12:20:32 <ski>     where ...
12:20:56 <ski> instead of packing the parts together in the "existential data type", we pass them directly on to the continuation
12:21:08 <ski> and instead of using
12:21:16 <ski>   case myQueueOps of
12:21:29 <ski>     (emptyQ,enQ,deQ) -> ..emptyQ..enQ..deQ..
12:21:32 <ski> we use
12:21:45 <ski>   withMyQueueOps (\(emptyQ,enQ,deQ) ->
12:21:51 <ski>     ..emptyQ..enQ..deQ..)
12:21:59 <mbrock> oh, this seems quite clever
12:23:10 <mbrock> so this way we don't need to make a data type
12:23:10 <ski> so instead of the syntactic noise of having to say `Wrap' in `[Wrap "False",Wrap True]' when wanting to express `[exists a. Show a *> a]', we instead have the noise of taking a continuation in `[\k -> k "False",\k -> True]' (or with `($ ...)', if you prefer here)
12:23:33 <ski> similarly, when using, you have to provide a lambda (or a named function), instead of a `case'
12:23:41 <ski> so the noise isn't that much different
12:24:08 <ski> the data type encoding would typically be used when you want/need to store your existentially typed values in data structures
12:24:32 <platz> i think i may have to make a quasiquoter library for hex literals
12:24:42 <ski> while the CPS encoding would typically be used when you simply want to transmit your existentially typed value to the caller, who immediately then unwraps it and uses it
12:25:00 <aweinstock> are "lenses over the values in an STRef" a concept that makes sense?
12:25:03 <ski> also the CPS encoding doesn't force you to invent a new data type, so it's more lightweight in that sense
12:25:07 <nitrix> kadoban: Turns out Data.Sequence is perfect for this.
12:25:09 <ski> mbrock : *nod*
12:25:22 <platz> it' very easy in e.g. python to write a literal such as 0xFEFE 
12:25:22 <nitrix> kadoban: O(1) length and O(log(min(i,n-i))) adjust.
12:25:28 <aweinstock> (if they are, I don't see them defined inside lens (using 'grep -r STRef' and 'grep -r IORef' in the repository)
12:25:31 <aweinstock> )
12:26:09 <ski> mbrock : .. it would be nice if there would be actual syntactic support of `exists' (and `*>') .. but now you know how you can encode it in two different ways
12:26:26 <kadoban> nitrix: Seems possible.
12:27:16 <mbrock> ski: yeah, thanks a lot for the introduction!
12:27:26 <ski> mbrock : btw, consider again `data Showable = forall a. Show a => Wrap a'. in the dictionary-passing translation of constraints, this becomes `data Showable = forall a. Wrap (ShowDict a) a' .. this explains why you can't use `newtype' with "existential data types". .. if you don't have any constraints, you could argue for it being possible, though
12:28:45 <ski> mbrock : however, one could consider implementations which actually pass at run-time info around for `forall' and `exists' (perhaps not insisting on boxing and so e.g. `length' has to know the size, and maybe other layout of values of type `a' at run-time) .. and insisting on `newtype' existentials would preclude that
12:29:33 <ski> mbrock : i think that's what i wanted to cover here. there's other interesting things one could consider, e.g. relation to OO, and relation to recursive types. perhaps another time, if you're interested
12:30:46 * ski bows
12:31:10 <prohobo> STOP THAT
12:46:39 <Jello_Raptor> is there someone who has implemented easy atomic transations using MonadTransControl? 
12:47:55 <Jello_Raptor> I've got a transformer stack over ID that should let you just gather up all the state, run a computation, if that computation errors then restore the state. I just don't want to write all the plumbing myself. 
12:55:12 <max3> does anyone know how to get stack to look for source files outside of the current directory?
12:55:17 <max3> ghc-options: "*": -i /path/to/library doesn't work isn't working
13:06:30 <Zemyla> What are the changes between 4.9.0.0 and 4.9.1.0?
13:25:44 <thatguy> http://lpaste.net/352890 how would this go in nice?
13:26:48 <erisco> :t ord
13:26:50 <lambdabot> Char -> Int
13:27:00 <erisco> > map ord ['a'..'z']
13:27:03 <lambdabot>  [97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,11...
13:27:26 <erisco> > map (subtract 96 . ord) ['a'..'z']
13:27:29 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]
13:27:32 <APic> yay
13:27:36 <Koterpillar> > elemIndex ['a'..'z'] 'a'
13:27:40 <lambdabot>  error:
13:27:40 <lambdabot>      • Couldn't match expected type ‘[[Char]]’ with actual type ‘Char’
13:27:40 <lambdabot>      • In the second argument of ‘elemIndex’, namely ‘'a'’
13:28:01 <Koterpillar> > flip elemIndex ['a'..'z'] 'a'
13:28:06 <lambdabot>  Just 0
13:28:31 <erisco> lol I suppose but how painfully slow
13:29:29 <Koterpillar> > map (subtract 96 . ord) 'а' -- but correct!
13:29:32 <lambdabot>  error:
13:29:33 <lambdabot>      • Couldn't match expected type ‘[Char]’ with actual type ‘Char’
13:29:33 <lambdabot>      • In the second argument of ‘map’, namely ‘'\1072'’
13:29:38 <Koterpillar> > (subtract 96 . ord) 'а' -- but correct!
13:29:41 <lambdabot>  976
13:29:42 <dmwit> platz: What? Why? 0xFEFE works fine in Haskell, too.
13:29:45 <dmwit> > 0xFEFE
13:29:49 <lambdabot>  65278
13:30:52 <dmwit> > '\xFEFE'
13:30:55 <lambdabot>  '\65278'
13:31:15 <thatguy> ericbmerritt_, thanks
13:31:17 <dmwit> > "\xfeefifoefum \xfee\&fifoefum"
13:31:22 <lambdabot>  "\65263ifoefum \4078fifoefum"
13:31:27 <merijn> use text
13:31:33 <merijn> To avoid show escaping
13:31:40 <merijn> > text "\xfeefifoefum \xfee\&fifoefum"  
13:31:43 <lambdabot>  ﻯifoefum ࿮fifoefum
13:31:48 <dmwit> merijn: But I want the escaping.
13:32:01 <merijn> ah
13:32:33 <dmwit> Oh, does `show` have to know about `\&`, too?
13:32:37 <dmwit> > "\0\&1"
13:32:40 <lambdabot>  "\NUL1"
13:32:49 <dmwit> > "\6000\&1"
13:32:54 <lambdabot>  "\6000\&1"
13:32:55 <mauke> > "\SO" ++ "H"
13:32:59 <lambdabot>  "\SO\&H"
13:33:09 <dmwit> Yikes!
13:33:12 <dmwit> show is complicated =)
13:33:36 <Tuplanolla> Arithmetic on `Char`?
13:34:03 <Tuplanolla> @let orchard = iso ord chr
13:34:06 <lambdabot>  Defined.
13:34:28 <Tuplanolla> > over orchard (+ 13) 'A'
13:34:33 <lambdabot>  'N'
13:34:43 <dmwit> That `d` sure slipped a long way down the treeline.
13:48:16 <AbelianGrape> GHC Isn't allowed to assume  that a == a, right? That is, it can't assume that if the two arguments to (==) are  the same in-memory object, they're equal?
13:48:31 <ezyang> AbelianGrape: GHC is not allowed to assume this 
13:49:00 <AbelianGrape> Ok, cool. It would be interesting to have a set of extensions  that lets GHC assume you've followed various typeclass laws
13:49:10 <AbelianGrape> You could get a big performance boost for some things, I imagine
13:49:16 <ezyang> well, you can kind of do this with rewrite rules 
13:49:24 <ezyang> but you need to define a confluent rewriting system that is profitable 
13:50:12 <AbelianGrape> I was thinking more along the lines of Eq/Ord laws than Applicative/Monad laws
13:50:33 <AbelianGrape> Like, if you have a huge object, you can do a cheap pointer equality check before doing the actual equality check
13:51:12 <AbelianGrape> Could save a lot of time for some use cases with strings, vectors, etc
13:51:30 <AbelianGrape> Obviously not a good idea from a theoretical standpoint  though
13:51:56 <ski> AbelianGrape : i'd expect `forall a b. a == b = True => a = b' (observationally speaking), though
13:52:09 <AbelianGrape> Yeah, of course
13:52:42 <ski> some memo-libs do that cheap pointer equality check
13:53:21 <ski> (and `forall a b. a == b = False => a =/= b'. howver not the converses of either, since inputs can be partial or infinite)
13:53:34 <AbelianGrape> What was that extension someone published a few days ago with the ===? You could have GHC prove `(\a -> a == a) === const True` and then it would be safe
13:54:04 <AbelianGrape> Probably wouldn't work for anything complicated though
13:55:47 <dmwit> AbelianGrape: Doing a pointer equality check would change the semantics of `(==)`, though, so that's a potentially scary thing to allow.
13:56:44 <dmwit> AbelianGrape: e.g. `let x = repeat 0 in x == x` could suddenly start terminating, which might be odd, and also wouldn't guarantee that `x` had been fully evaluated as it used to do, which could lead to a memory leak.
13:57:29 <dmwit> (Even in the simpler situation where both would terminate the latter fact is a bit worrisome.)
14:00:09 <AbelianGrape> Good point
14:03:20 * ski isn't sure what `===' is
14:03:35 <AbelianGrape> ski, someone wrote a library that uses GHC's simplification machinery to write proofs of laws
14:03:48 <AbelianGrape> it never makes a false proof, but isn't guaranteed  to find a proof (of course)
14:03:52 <AbelianGrape> Let me look for it
14:03:56 <ski> what's the type of `(===)' ?
14:04:06 <Tuplanolla> https://github.com/nomeata/ghc-proofs
14:04:15 <AbelianGrape> a -> a -> () iirc
14:04:23 <AbelianGrape> Yeah that
14:04:26 <AbelianGrape> 's it Tuplanolla 
14:05:03 <ski> ty
14:05:06 <AbelianGrape> It works well for simple monads and stuff, pretty cool
14:07:03 <dmwit> "Proof" is a funny name for this.
14:07:25 <erisco> Koterpillar, that is not a counter-example
14:07:34 <dmwit> I mean. I guess it's an okay name. But it's not proof of equality in the usual domain we think of; it's proof of equality in GHC's rewrite system.
14:07:58 <Koterpillar> erisco: elemIndex? It should have returned Nothing
14:08:00 <ski> a proof that GHC's rewrite rules believes they are equal
14:08:12 <erisco> that wasn't the whole solution. It didn't even have the correct type! I was just showing the crux of the solution
14:08:18 <dmwit> ski: right
14:08:21 <erisco> you would do a bounds check before that
14:10:29 <mikail> I am looking at monad transformers at the moment and have heard that they can be used to structure programs. Before I jump down a rabbit hole and look into this more deeply, is this the right intuition?
14:10:43 <Koterpillar> a lot of things can be used to structure programs
14:10:46 <ezyang> it depends on what you mean by "structure programs" 
14:11:00 <ezyang> My intuition is that monad transformers are a way of making monads 
14:11:10 <Zemyla> UML can theoretically be used to structure programs, so that's not a very good benchmark.
14:11:11 <dmwit> I think you should jump.
14:11:59 <dmwit> Also, I don't think that's the right intuition. Also I don't think it's possible to have the right intuition before you jump, even if you say the exact same words somebody who has already jumped says.
14:13:51 <mikail> I'm going by this video: https://www.youtube.com/watch?v=8t8fjkISjus&list=WL&index=2
14:15:13 <mikail> In this presentation, he has an example where he has layered application (see 5:59) and then represents that by stacking his monads appropriately
14:15:43 <Zemyla> Why is there a package called ChasingBottoms on hackage where children can see it?
14:16:32 <mniip> is that a serious question
14:16:42 <Zemyla> No it isn't.
14:17:20 <Zemyla> But the package page talking about "getting a grip on bottoms" can't be accidental.
14:31:15 <Zemyla> Also, I can't test or benchmark the latest build of containers from GitHub, because the test and bench tools themselves require containers.
14:33:19 <Zemyla> How do I break the dependency cycle?
14:34:08 <ezyang> Zemyla: https://github.com/haskell/cabal/issues/1575 
14:40:20 <mbrock> mikail: right now I'm working on a program where many operations share similar aspects: they access a state, they emit log events, and they can fail causing rollback in the other aspects.  This kind of operation can be written naturally as functions of some type like "input -> state -> Maybe (output, state, [log])" or something like that. It turns out that
14:40:20 <mbrock> all these three aspects are common patterns that fit into the monad pattern. Monad transformers let me compose them together nicely
14:40:40 <suppi> is it possible to convert turtle's FilePath to String?
14:41:54 <sdx23> suppi: the common FilePath is String.
14:42:20 <suppi> sdx23: turtle's FilePath is not a String though, that's my problem :\
14:42:39 <Tuplanolla> @hackage turtle
14:42:40 <lambdabot> http://hackage.haskell.org/package/turtle
14:43:18 <suppi> it uses this specifically: http://hackage.haskell.org/package/system-filepath-0.4.13.4/docs/Filesystem-Path.html#t:FilePath
14:43:32 <suppi> sorry for not linking that earlier.
14:44:12 <sdx23> that is both IsString and Show
14:45:34 <suppi> IsString is basically "a -> String"
14:45:45 <suppi> sorry: "String -> a"
14:46:30 <suppi> i could use show and drop the constructor name but that seems kinda bad
14:48:12 <suppi> oh i see there's encodeString, let me check
14:48:36 <suppi> yes, seems to work
14:48:44 <suppi> thanks
14:52:36 <Wizek_> Hey! Anyone knows of a TH/QQ function that lets me declare an ADT and its Data.Default instance at once? e.g.: [withDef| data Foo = Foo {_port = 8080 :: Int, _name = def :: Maybe String }|]
14:54:19 <Tuplanolla> That's a nice idea, Wizek.
14:54:47 <Axman6> except many people believe Data.Default is a pretty flawed idea
14:54:58 <dibblego> o/
14:55:23 <Wizek> Tuplanolla, I believe so too, hoping that something exists, and if not I might take a gander at implementing it
14:55:47 <Wizek> Axman6, How so? And if so, do you have something superior in mind?
14:56:08 <dibblego> ((->) t) or Monoid, depending on how it is abused
14:56:50 <Wizek> dibblego, So the idea itself is not flawed, but rather some instances are too broad, perhaps?
14:56:52 <Tuplanolla> It's often a sign of missed opportunities to use monoids, but it has its places, Wizek.
14:57:49 <dibblego> No, the idea is flawed, because there always exists a superior solution, which ime, is usually just "passing an argument" (e.g. reader monad) or "identity not default" (Monoid)
14:58:28 <Axman6> Wizek: there is a subset of haskellers who feel that classes without laws shouldn't exist, because they're usually less useful and ad hoc. Data.Default is a very good example of an ad hoc class without laws
14:58:44 <ezyang> this would be a good subject for a blog post! 
14:58:58 <dibblego> Data.Default is more eggregious than just "has no laws"
14:59:01 <ezyang> For example, I've never been exactly sure how one is supposed to do defaults with monoids 
14:59:02 <Axman6> If only that Edwars Yang guy would write one! :P
14:59:10 <Axman6> Edward*
14:59:20 <ezyang> :) 
14:59:34 <Zemyla> ezyang: So what's the simplest workaround?
14:59:52 <ezyang> is the Monoid approach the one where you put Maybes in all your record fields? 
14:59:52 <dibblego> I look forward to Edward Yang's new blog post!
15:00:12 <dibblego> no, just s/def/mempty, this is least likely
15:00:13 <ezyang> well, I /would/ write it if I knew what to write about :P 
15:00:44 <ezyang> yeah, but most things don't have monoid instances that make sense here 
15:00:51 <Zemyla> ezyang: I meant for enabling tests and benchamrks on containers.
15:01:12 <ezyang> Zemyla: if you call the Setup script manually you can set it up. But why do you need ti to begin with? 
15:01:30 <Zemyla> Because I'm trying to make a change to containers.
15:01:36 <Tuplanolla> :t Test.QuickCheck.stdArgs -- How would you use a monoid or such for this?
15:01:38 <lambdabot> Args
15:02:04 <Wizek> ^ I'm interested in that too.
15:02:47 <dibblego> you wouldn't, that doesn't use Data.Default, it is already done sensibly, could just use a bit of library support
15:02:47 <ezyang> Tuplanolla: So, the way Cabal does it is that argument records have Maybe in every field 
15:03:34 <ezyang> and then eventually you mappend in your default record and then get everything defined 
15:03:35 <Zemyla> I made a post in containers/issues, and wanted to try and implement my idea.
15:04:26 <ezyang> Zemyla: do you know how to use Setup manually? 
15:04:42 <Zemyla> No, I don't.
15:04:47 <ezyang> Tuplanolla: It's a little annoying because if you want to be type safe you need to parametrize your record in Maybe/Id 
15:04:57 <Tuplanolla> Yes, Hakyll does that too.
15:05:37 <ezyang> Zemyla: maybe, try 
15:05:43 <ezyang> cabal act-as-setup -- configure 
15:06:16 <dibblego> I have done similar to the Maybe thing, except use a type-variable and apply it as Identity or Maybe depending on requirement.
15:07:57 <dibblego> also this, newtype ReadFoo a = ReadFoo (Foo -> a); newtype ContFoo a = ContFoo (ReadFoo a -> a); defaults :: ContFoo a -> a
15:09:36 * dmwit mentally inlines some newtypes... `defaults :: ((Foo -> a) -> a) -> a`
15:09:44 <dmwit> yeesh
15:10:06 <ezyang> lol 
15:10:49 <ezyang> why isn't defaults just a ContFoo a 
15:10:54 <dmwit> yeah
15:11:04 <dmwit> Also why isn't defaults just a Foo
15:11:36 <faberbrain> hey all, i am trying to setup some basic application "boilerplate" using a free monad + interpreter approach, but running into some crazy types and errors that i don't fully understand, and am wondering what more experienced folks think about this approach in general
15:11:47 <faberbrain> (i also know that is a somewhat vague description)
15:11:55 <Zemyla> (forall x. (a -> x) -> x) = a.
15:12:05 <dmwit> Also why is it bad to share the name `defaults` between libraries so that people familiar with `defaults` from other libraries can just get off the ground running without further ado
15:12:31 <ezyang> faberbrain: say more, or post some code :P 
15:12:56 <ezyang> Zemyla: Sorry this is annoying, containers README really ought to have posted instructions 
15:13:19 <faberbrain> i'd like to introduce haskell into our stack either w/ servant to devleop api endpoints, or as a background worker to replace the ruby resque stuff
15:13:22 <dmwit> I think it's rare to have multiple interpreters for a free monad, and therefore usually better to just define a monad rather than a free monad/interpreter pair.
15:13:43 <faberbrain> and so i'll need db access, queue access, and email at the very least in terms of "infra" kinds of actions
15:15:04 <faberbrain> so i attempted to make my free monad like this: http://lpaste.net/4554871319157538816
15:15:29 <faberbrain> where the "primitive" action would be like `db $ insertKey k entity` or something
15:16:18 <dibblego> yeah that was wrong, sorry
15:16:49 <faberbrain> then i could define larger application level actions on top of that like `findByEmail = db $ selectFirst [UserEmail .== "some@thing.com"] []`
15:17:42 <faberbrain> does this, at a conceptual/design level, make sense?
15:18:53 <Wizek> Asked the question here as well: https://www.reddit.com/r/haskell/comments/5vm792/anyone_knows_of_a_thqq_function_that_lets_me/ Curious if someone posts a link to a solution and/or about the discussion that arises of alternative approaches.
15:20:52 <ezyang> faberbrain: What free monad reference are you using? 
15:21:48 <ezyang> Wizek: To answer your Q directly, the stynax you've written above is not valid Haskell so you'l lfirst need to write a parser for it 
15:21:59 <ezyang> or reframe your problem so that it is valid HAskell syntax 
15:22:03 <faberbrain> i'm using the "free" package, and loads of various blog posts etc that iv'e found describing this pattern
15:22:31 <dmwit> Wizek: There is `data-default-generics`
15:23:13 <dmwit> Wizek: But you'd need a `newtype` for `Port` or something that had a `Default` instance already.
15:23:19 <faberbrain> trying to find them again, there's "why free monads matter", http://dlaing.org/cofun/posts/free_and_cofree.html, http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html,... and more
15:23:55 <Wizek> dmwit, the newtype requirement sounds sub-optimal, but good to know this exists.
15:31:55 <dibblego> The reason defaults :: ContFoo a is useful, is if other functions library build around ReadFoo. Of course, you have both defaults :: Foo and defaultsCont :: ContFoo a 
15:36:19 <faberbrain> updated for some more context http://lpaste.net/4554871319157538816
15:49:32 <miscyb> is there a good way to organize imports?
15:49:49 <miscyb> looking at my import list makes me cry and i don't want to go through manually
15:50:23 <miscyb> i'd honestly like to explicitly declare every imported function in parens
15:52:56 <MarcelineVQ> don't cry dear, let ghc help you  -ddump-minimal-imports
15:55:53 <jle`> i just sort alphabetically >_>
15:58:04 <MarcelineVQ> the main benefit of that dump is "the “minimal” imports (a) import everything explicitly, by name, and (b) import nothing that is not required."
16:04:40 <lyxia> what happens when you want to import something new?
16:05:08 <lyxia> Do you just add it by hand
16:06:39 <ertes> miscyb: if you use -W, GHC will warn you about unnecessary imports
16:06:49 <ertes> as a middle ground
16:07:39 <xcmw_> Which is better to store small amounts of simple data (records, maps, lists) readMaybe and show, JSON with Aeson, or something else?
16:08:10 <miscyb> ertes: that's useful, but i want something more automatic
16:08:11 <johnw> xcmw_: do you want to be able to edit the data outside of your program?
16:08:14 <ertes> xcmw_: "store"?  on disk?  human-readable?  …?
16:08:45 <ertes> miscyb: emacs with haskell-mode has a function to remove unnecessary imports automatically, which probably uses -ddump-minimal-imports internally
16:08:56 <miscyb> MarcelineVQ: i'll want to try this but i'll have to read about how to pass those args to stack
16:09:07 <xcmw_> human-readable and editable would be nice
16:09:14 <miscyb> ertes: thinking about emacs gives me carpal tunnel syndrome haha
16:09:19 <ertes> xcmw_: then aeson sounds reasonable
16:10:11 <xcmw_> ertes: Ok, Thanks
16:10:24 <ertes> xcmw_: YAML might be a better option for humans
16:10:49 <ertes> @package yaml
16:10:49 <lambdabot> http://hackage.haskell.org/package/yaml
16:11:12 <xcmw_> ertes: I would only need to read it for debugging purposes
16:12:05 <ertes> xcmw_: yeah, it's just that the JSON that aeson produces is minified, so it's hardly human-readable =)
16:12:05 <miscyb> xcmw_: would it make sense to use something like cereal or store?
16:12:28 <miscyb> should be easy to write a printer for it
16:13:31 <MarcelineVQ> lyxia: the dump makes a seperate file, what you do with it after is up to you :>
16:16:14 <xcmw_> miscyb: I think I will use json since I am more familier with it
16:28:11 <dmwit> MarcelineVQ: Obviously the correct solution is to #include it
16:29:16 <Wizek> Can I search for the instances of a particular class with hoogle or hayoo?
16:29:32 <MarcelineVQ> dmwit: it's obvious to everyone :>
16:29:59 <dmwit> Wizek: The haddocks for the class will list instances. Though due to a bug not all of them.
16:35:43 <Wizek> dmwit, Do you mean locally, or on hackage somehow?
16:37:02 <dmwit> On Hackage.
16:37:50 <lpaste_> xcmw revised “Is this supposed to happen?”: “Is this supposed to happen?” at http://lpaste.net/352894
16:38:14 <Welkin> xcmw_: is this real life?
16:38:26 <xcmw_> Welkin: No
16:38:59 <Welkin> xcmw_: one piece of advice: stop using & when you really mean $
16:39:25 <Welkin> no one writes like that because it's painful to read
16:39:59 <Wizek> I do! 
16:40:01 <Welkin> & is an abomination that was invented to be used only with lens
16:40:24 <MarcelineVQ> Welkin: I'm not confident about where you're sourcing your info :X
16:40:54 <Welkin> lol
16:40:56 <dibblego> Welkin does not speak for me.
16:41:10 <Welkin> I don't see ap lace for it outside of lens
16:41:21 <Wizek> Speak up, People of `flip ($)`!
16:41:24 <Koterpillar> it's fine, it's `>>>` in a lot of languages
16:41:39 <Welkin> Koterpillar: >>> in haskell is forward compose
16:41:50 <Koterpillar> (where I mean "a lot" in the mathematical sense of "more than one")
16:42:35 <Axman6> I think & (and <&>) are an excellent compliment to $ and <$>
16:42:57 <Welkin> Axman6: but used in place of them? not at all
16:43:01 <Axman6> reads quite nicely too, I have this, and do this and do this and do this...
16:43:15 <Axman6> Welkin: absolutely, it leads to much cleaner code in many cases
16:44:05 <Wizek> Exactly, for people with LTR writing systems I'd propose it's in general easier to read LTR function composition as well. An example: https://github.com/Wizek/dump/blob/48443d5/src/Debug/Dump.hs#L77
16:44:37 <Welkin> this isn't composition
16:44:41 <Welkin> it's application
16:45:00 <Wizek> Welkin, (.>) = flip (.)
16:45:15 <Welkin> never heard of it
16:45:22 <Welkin> I think you mean >>>
16:45:31 <Koterpillar> both are useful
16:46:11 <hexagoxel> >>>'s precedence is annoying sometimes; then you use .>
16:47:27 <xcmw_> Does anyone know the answer to my question? Why doesn't Aeson give me back what I gave it?
16:48:05 <Koterpillar> xcmw_: because JSON can't encode Maybe (Maybe a) properly
16:48:20 <dibblego> can too, see argonaut.io 
16:48:36 <xcmw_> With an object it could
16:48:54 <lyxia> diagrams also encourages reverse function application
16:48:55 <Koterpillar> xcmw_: but that's not what you want
16:49:09 <lyxia> to set properties of elements
16:49:10 <Koterpillar> xcmw_: what's the result of encode [Just Nothing, Nothing]?
16:49:42 <dmwit> xcmw_: You're free to make your own `Maybe`-like type with better behavior.
16:49:46 <Koterpillar> like, what do you want it to be?
16:50:03 <dmwit> xcmw_: It is perhaps unfortunate that the behavior for `Maybe` is as it is, but it's also darn convenient in a lot of cases.
16:50:49 <xcmw> Koterpillar: compile time error
16:51:18 <Welkin> why would you ever have Maybe (Maybe a)?
16:51:32 <Koterpillar> then remove the instance for ToJSON a => ToJSON (Maybe a)
16:51:56 <Koterpillar> Welkin: it comes up if someone already has a Maybe a and you are wrapping it for another reason
16:51:56 <xcmw> Welkin: I was just testing to see if the library could handle tricky edge cases
16:52:01 <dmwit> Welkin: Because you have a database query operation that can fail, and even if it succeeds it can not match any records.
16:52:21 <Koterpillar> (arguably that can be Either DBError (Maybe a), but well)
16:52:30 <dmwit> Nothing means the connection failed. Just Nothing means the query went through and didn't match. Just (Just foo) means the query went through and matched record foo.
16:52:34 <Welkin> I still don't see why
16:52:43 <Welkin> I never had that issue using something like Persistent
16:53:00 <Welkin> it produced a Maybe Entity
16:53:08 <dmwit> You really can't see why composing two systems that each could fail might be useful occasionally?
16:53:20 <dmwit> And being able to distinguish between which system failed?
16:54:04 <Welkin> why does it matter? If the lookup fails, it fails
16:54:27 <dmwit> Because in one case I'm going to try to reestablish the connection, and in the other I'm going to tell the user nothing matched.
16:54:37 <dmwit> For example.
16:54:38 <Welkin> database access is handled in IO anyway
16:54:42 <Welkin> there are no Maybes involved
16:54:45 <Koterpillar> doesn't have to be
16:54:50 <dmwit> ...
16:55:11 <Koterpillar> Welkin: surprise: there are different ways to do things!
16:55:40 <hexagoxel> dmwit: let me guess, you want to go back to the constructive discussion about operators? what is (...) supposed to be? :D
16:56:26 <dmwit> hexagoxel: it's the partial application of function composition to enumFromTo, obviously
16:56:48 <lyxia> but... applied which way
16:57:13 <dmwit> yes
16:58:37 <xcmw_> Is there a haskell oriented serialization library? Or will readMaybe and show work?
16:59:02 <peddie> @hackage binary  -- xcmw
16:59:03 <lambdabot> http://hackage.haskell.org/package/binary  -- xcmw
16:59:26 <peddie> xcmw_: depending on what you want there are libraries for serializing to a bunch of other formats too
17:00:54 <dmwit> readMaybe and show will work, but read* is notoriously slow.
17:01:00 <ezyang> when I say import A(K(..)), is it always guaranteed that the type constructor K comes into scope? 
17:02:18 <ezyang> relatedly, what's the name of the feature where you can associate pattern synonyms with a type for export?. 
17:02:22 <lyxia> is this a trick question
17:02:44 <ezyang> sort of. In Haskell98 I think the answer is YES 
17:02:48 <ezyang> but I'm not sure about GHC Haskell 
17:02:56 <Axman6> ezyang: this is worrying, you're who we turn to when we have these questions :P
17:03:46 <lyxia> https://github.com/ghc-proposals/ghc-proposals/pull/28
17:04:03 <ezyang> aha! pattern synonym bundling. 
17:04:04 <ezyang> Thank you 
17:04:11 <lyxia> yw
17:10:05 <xcmw> peddie: Thanks. Binary works
17:33:54 <dmwit> ezyang: Interpreting your answer in the strictest possible sense I think the answer is NO even in H98/H2010.
17:34:38 <dmwit> ezyang: I believe `module A (K) where type K a = Int` and `import A(K(..))` is legal in H98, but `K` is not a type constructor.
17:35:31 <dmwit> In case you weren't intending "constructor" in the Report sense, then I'm a bit confused because it seems "obvious" that `K` would be in scope (assuming it compiled at all).
17:37:30 <dmwit> (There is a warning -- `-fwarn-dodgy-imports`, I think -- for this.)
17:43:54 <ezyang> dmwit: I didn't intend constructor in the report sense, so yes, obviously it's in scope :) 
17:44:46 <ezyang> I guess what is giving me trouble is that GHC's formulation of export lists is such that there is a form where MkK is brought into scope but K is not 
17:45:00 <ezyang> for example, if I say module A (pattern MkK) where data K = MkK 
17:45:41 <ezyang> if there were a way of saying the moral equivalent of K(..) (there isn't), MkK would be brought into scope but not K 
17:46:07 <ezyang> This behavior is observable when you see what happens if you do something like module A (K, f) where data K = K { f :: Int } 
17:46:19 <ezyang> if you say import A(K(..)), indeed K and f are brought into scope 
17:46:31 <ezyang> This is what Haskell98 says too 
17:46:52 <dmwit> GHC has an extension that gives you the ability to differentiate between type and term level in import lists, I believe.
17:47:28 <dmwit> So something like `import A (type K)` and `import A (term K)` (not the real syntax) would differentiate between the two kinds of imports.
17:47:56 <ezyang> isn't this pattern? 
17:49:13 <MarcelineVQ> dmwit: that's type yeah? for cases where typeoperators are in effect which causes ambiguity?
17:49:44 <ezyang> I'm not actually talking about the ambiguity here, I think 
17:49:53 <MarcelineVQ> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#explicit-namespaces-in-import-export idk, but in case it's relevant
17:50:38 <dmwit> Oh, MarcelineVQ beat me to it.
17:50:53 <ezyang> oh interesting 
17:51:22 <dmwit> It's always exciting when the documentation isn't even sure why a thing happens.
17:51:56 <dmwit> "The extension -XExplicitNamespaces is implied... (for some reason) by -XTypeFamilies."
17:56:47 <MarcelineVQ> it's to disambiguate the associated families I guess, https://wiki.haskell.org/GHC/Indexed_types#Associated_families
18:00:41 <Zemyla> Is it just me, or does ircbrowse.net no longer have search?
18:02:13 <Welkin> Zemyla: record your own logs, then grep/ack/ag
18:16:54 <chreekat> Zemyla: I've been told that icrbrowse is in the midst of a migration
18:21:35 <mitch_stevens> @let x = 4
18:21:38 <lambdabot>  Defined.
18:23:12 <Axman6> D:
18:23:24 <Axman6> :t (x,y)
18:23:27 <lambdabot> error:
18:23:27 <lambdabot>     Ambiguous occurrence ‘x’
18:23:27 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.x’,
18:26:27 <Axman6> @undef
18:26:28 <lambdabot> Undefined.
18:26:31 <Axman6> :t (x,y)
18:26:34 <lambdabot> (Expr, Expr)
18:28:03 <Welkin> :t (a,b)
18:28:06 <lambdabot> (Expr, Expr)
18:28:25 <Welkin> @let a = 2; b = "fish"
18:28:26 <lambdabot>  Defined.
18:28:32 <Welkin> :t (a,b)
18:28:34 <lambdabot> error:
18:28:34 <lambdabot>     Ambiguous occurrence ‘a’
18:28:34 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.a’,
18:42:32 <Sornaensis> @src unsafePerformIO
18:42:33 <lambdabot> Source not found. Just what do you think you're doing Dave?
19:14:58 <ffilozov> When I do 1.0 :: Integer at the REPL, it tells me that there's "No instance of (Fractional Integer)..". How would implementing Fractional for Integer fix this problem?
19:15:16 <Welkin> integers cannot be fractional
19:15:23 <Welkin> that's the definition
19:15:48 <Welkin> > 1.0 :: Float
19:15:52 <lambdabot>  1.0
19:15:55 <Welkin> > 1.0 :: Integer
19:15:58 <lambdabot>  error:
19:15:59 <lambdabot>      • No instance for (Fractional Integer)
19:15:59 <lambdabot>          arising from the literal ‘1.0’
19:16:02 <Welkin> > 1 :: Integer
19:16:05 <lambdabot>  1
19:18:38 <dmwit> ffilozov: `1.0` is syntactic sugar for `fromRational (10%10)`.
19:18:57 <dmwit> ffilozov: So implementing `Fractional` would solve the problem by providing an implementation of `fromRational` that returned an `Integer`.
19:19:18 <ffilozov> Right, so :t 1.0 -> Fractional a => a. So that makes sense that I get that error. 
19:19:45 <dmwit> ffilozov: However, see also the NumDecimals extension, which lets you write `1.0 :: Integer` but not `1.5 :: Integer`.
19:20:53 <dmwit> ...now I kind of want to push a HexaDecimals extension as an April Fools' joke or something. =P
19:21:02 <ffilozov> Thanks.
19:25:54 <qmm> how can you represent List: Set -> Mon which is a functor taking each set S to the monoid of lists with elements drawn from S?
19:28:49 <qmm> ...in haskell
19:29:09 <Welkin> is that like saying "on the internet"?
19:29:19 <qmm> perhaps
19:30:18 <qmm> i've felt for the longest time that haskell's type system gives us facilities to work with and describe universal truths from category theory
19:30:35 <qmm> i haven't worked up to that point yet, but i'm trying :)
19:33:02 <qmm> :info Functor
19:58:07 <iannnn> hi all
20:05:34 <ezyang> What would people say is the "canonical" reference on overloaded record fields 
20:06:00 <Axman6> lens >_>
20:06:17 <Axman6> sorry, couldn't resist
20:07:06 <ezyang> lol 
20:07:09 <ezyang> is ORF coming to gHC 8.2? 
20:07:41 <ezyang> no it's not 
20:59:08 <jle`> hi all
20:59:15 <jle`> what is the most popular mini-lens library
20:59:24 <jle`> just looking over over/view/set more or less
21:00:03 <jle`> there are a lot of adequate ones on hackage but i was wondering if there was a one people normally used
21:01:18 <Lokathor> GLFW-b builds on windows again!
21:01:19 <Lokathor> yay!
21:01:27 <jle`> :D
21:02:04 <Lokathor> ohhhhhh
21:02:11 <Lokathor> but you can't build gl in lts-8.2
21:02:26 <Lokathor> constantly turned back by the haskell ecosystem
21:03:13 <jle`> looks like stackage says microlens is the most popular mini lens library
21:04:22 <Welkin> what about picolens!? D:<
21:04:57 <johnw> call me when we have attolens
21:04:59 <Welkin> I thought it was lens-family jle` 
21:09:09 <jle`> lens-family has less reverse deps
21:09:13 <jle`> on stackage, at least
21:09:23 <jle`> but also it tries to stay standard haskell so it doesn't have the Rank2 Lens
21:09:31 <jle`> not that that's particularly important
21:15:50 <monochrom> planck-length lens
21:17:52 <Lokathor> half-planck-lens
21:18:37 <Lokathor> uses sub-planck rendering techniques for maximum accuracy universe rendering
21:19:19 <lpaste_> Buttons840 pasted “Spock error” at http://lpaste.net/352897
21:20:16 <buttons840> ^ i have the above spock program, it's very short and close to what i see in the tutorial, but it doesn't compile
21:28:14 <tippenein> buttons840: which tutorial? What _should_ that do?
21:30:22 <buttons840> https://www.spock.li/tutorial/  i am only implementing the `app :: SpockM` portion in the file i posted
21:30:30 <johnw> drive by question
21:30:52 <buttons840> what i posted obviously doesn't do much; notice there's a typehole -- i would expect it to compile at least though
21:45:22 <Axman6> buttons840: you might eant to give those `var`s some types
21:45:28 <buttons840> the spock error I posted was because of type inference, the type of the hole n...
21:45:38 <buttons840> Axman6: yeah, i was just realizing the same thing :)
21:47:48 <buttons840> that seems like a suboptimal error from GHC, why does it complain an unknown type is missing a typclass instance?
21:49:14 <buttons840> generating good errors in all situations is hard I suppose
22:34:11 <jle`> is there a common natural transformation newtype haging around 
22:34:27 <jle`> s/haging/hanging
22:34:37 <jle`> newtype Nat f g = Nat (forall a. f a -> g a)
22:37:52 <Welkin> There is one in servant
22:37:58 <Welkin> not sure if it's imported
22:40:15 <Axman6> does mmorph provide one?
22:41:41 <Welkin> http://hackage.haskell.org/package/servant-server-0.10/docs/Servant-Server.html#t::-126--62-
22:45:54 <jle`> thanks :o
22:46:01 <jle`> it's ok i actually ended up not needing it
