00:01:15 <Cale> mniip: no, that was my mistake, its 2-cells are natural transformations
00:18:05 <mniip> Cale, so what next
00:20:12 <Cale> sleep
00:20:24 <Cale> and then travel to New York for 2 weeks
00:20:33 <Cale> and then travel to Melbourne for a month
00:21:51 <mniip> ok, once in melbourne, can you explain how strength is related? :p
00:22:11 <riaqn> Hi, any counterpart of LLVM in functional programming world?
00:22:32 <riaqn> I mean, an intermediate language for FP, targeting concrete machines.
00:23:15 <riaqn> maybe STG? but it seems STG is bound to GHC. I need something standalone.
00:23:20 <mniip> well, Haskell has Cmm and STG
00:23:23 <mfukar> I think we call that 'lambda calculus'?
00:23:41 <mfukar> i kid, i kid
00:23:48 <riaqn> mfukar: yeah, the main point is "targeting concrete machines".
00:24:32 <riaqn> so I was actually asking some compiler from untyped LC to LLVM/x86.
00:26:31 <mniip> I don't think there's many enough FPs to have an intermediate language
00:26:46 <mniip> GHC has Core, Stg, and Cmm which are useful within GHC,
00:26:51 <mniip> but not so much outside of it
00:44:54 <johndcl> Hello. In the following code http://lpaste.net/2420610067280691200 , if the first argument to compareBranches evaluates to Nothing, will the second argument be also evaluated?
00:45:28 <glguy> no
00:49:49 <johndcl> glguy: http://lpaste.net/2420610067280691200 not even now?
00:50:21 <glguy> no
00:50:24 <opqdonut> haskell tries equations in order, and matches the arguments in order
00:50:51 <johndcl> ok, that is awesome, thank you
00:50:53 <opqdonut> so it starts with comparing the first argument with (Just m). the first argument is reduced until it produces a Maybe consructor
00:51:18 <opqdonut> if the first argument turns out to be Nothing, the first equation can't match, so haskell moves on to the second equation
00:51:26 <opqdonut> which matches everything
00:51:31 <opqdonut> so Nothing is returned
00:51:57 <zipper> Hey what can get me from ["we" "are"] to "we are" ?
00:52:05 <johndcl> thank you
00:52:40 <srhb> zipper: Did you mean ["we","are"]
00:52:42 <opqdonut> > intercalate " " ["we", "are"]  -- zipper 
00:52:44 <lambdabot>  "we are"
00:52:55 <glguy> unwords
00:53:11 <opqdonut> oh, unwords, yeah
00:57:02 <zipper> Thanks for unwords
00:57:12 <knupfer> > const "we are" "[\"we\" \"are\"]"
00:57:14 <lambdabot>  "we are"
00:57:15 <knupfer> :)
00:57:25 <MP2E> hah :p
00:59:07 <knupfer> What's currently going on in GHC-HQ, can we espect fancy new optimizations or language features?
01:03:27 <Axman6> riaqn: riaqn: it's not widely used (yet?), but this is under development where I work: https://gitlab.anu.edu.au/mu/mu-spec/blob/master/overview.rst
01:03:37 <Axman6> uh, only one riaqn :)
01:11:22 <mniip> is end the forall or the exists?
01:12:21 <ski> `forall'
01:19:00 <ski> given `F : C^Op * C >---> D', the end of `F' is specified by : `End F', which is `forall c : C. F(c,c)' (aka ⌜∫_c F(c,c)⌝ or ⌜∫_C D⌝), is an object of `D'; `omega : forall c : C. (End F >---> F(c,c))', iow `omega_c : (forall c : C. F(c,c)) >---> F(c,c)' (for all `c' in `C') is a dinatural transformation
01:19:41 <sL1Me> Any Really Good AHK Coder here who can help me?
01:21:01 <mniip> you're probably talking about auto haskell key
01:21:08 <mniip> which makes a lot of sense in a haskell channel
01:22:32 <ski> such that for any object `e' of `D' with dinatural `beta : forall c : C. (e >---> F(c,c))', there exists a unique morphism `poly_beta : e >---> (forall c : C. F(c,c))' in `D' satisfying `omega_c . poly_beta = beta_c'
01:24:11 <mniip> hmmmm
01:24:22 <mniip> I was expecting it to be simpler
01:24:29 <ski> in the case of categorical products, the "there exists a unique morphism ... satisfying [commuting diagram]" says that (given `f : T >---> A' and `g : T >---> B') there exists a morphism `<f,g> : T >---> A * B', satisfying (in terms of points) `<f,g>(t) = (f t,g t)' (in haskell `<f,g>' is called `f &&& h', at least when using the `Arrow' terminology)
01:25:51 <ski> in this case, it tells you that if you have something (`beta') of type `forall c. ... -> F c c' (where `F' is contravariant in one argument, and covariant in the other), `...' not depending on `c', then you can think of it as something (`poly_beta') of type `... -> (forall c. F c c)'
01:26:46 <ski> so it's merely moving the `forall', going from `forall c. ... -> ..c..' to `... -> (forall c. ..c..)', but with `..c..' here depending both contravariantly and covariantly on `c'
01:26:47 <mniip> <f,g> denotes the mediating morphism for the product?
01:26:50 <ski> yes
01:26:54 <mniip> or is there a more elaborate definition
01:27:22 <ski> in the case of *co*ends, it's instead about going from `forall c. ..c.. -> ...' to `(exists c. ..c..) -> ...'
01:28:13 <ski> so it's telling you that you can inspect an existential input, if you're prepared to be, in your use of the innards, polymorphic in the existentially quantified variable
01:29:00 <ski> (still similarly talking about the case of difunctors, so `c' may occur both contravariantly and covariantly in `..c..')
01:29:58 <mniip> I'm trying to grasp the generic definitions
01:30:05 <mniip> I know what forall/exists do in Hask
01:30:07 <ski> mniip : in categorical semantics, you interpret an *expression* `e' as a morphism described by the mapping from the (values of) the set of free variables `FV(e)' to the corresponding value of `e'
01:30:09 <mniip> probably too well
01:30:48 <ski> so `x + y^2', construed as depending on variables `x',`y',`z' (the last vacuously) will be interpreted as a morphism `(x,y,z) |-> x + y^2'
01:31:57 <ski> `Gamma |- e : tau' gets translated to `|e|_{Gamma,tau} : |Gamma| >---> |tau|', where in this case `|x : Integer,y : Integer,z : Integer| becomes `Integer * Integer * Integer'
01:33:48 <ski> in this situation, the *expression* `(e0,e1)', becomes `<f,g>', assuming `e0' becomes `f' and `e1' becomes `g'
01:36:36 <ski> so i suppose what i'm trying to say here is that the "exists unique" in situations like this typically means that you get some construction in the (internal) language for constructing or deconstructing (depending on whether the new object, characterized by the universal mapping principle, in the category is on the codomain or the domain end of the arrow) "values in the object"
01:37:36 <ski> in the case of `<f,g>', this is how you make a morphism *into* a categorical product, by constructing it from one morphism into each factor, all morphisms having the same domain (`|Gamma|')
01:38:03 <Snardbafulator> Just...
01:38:03 <Snardbafulator> Just ate a burger at the sleazy joint
01:38:03 <Snardbafulator> Now I gotta take a shit, get to the point
01:38:03 <Snardbafulator> Sittin' on the toilet, my ass is a blast
01:38:03 <Snardbafulator> Runnin' smelly diarrhea outta my ass 
01:38:43 <ski> in the dual case of `[p,q] : A + B >---> P' (`P' being thought of as a "property" object, perhaps booleans, or something more involved. in physics, often measurements are in reals) constructed from `p : A >---> P' and `q : B >---> P'
01:39:19 <mniip> uh, sorry I kinda lost track
01:39:23 <ski> in this case, this "exists unique" thing tells us how to make a morphism *out* of a categorical coproduct
01:40:16 <athan> Dang... I think rust has a built-in concept of linear types o.O
01:41:12 <ski> in the case with ends above, we start with a "polymorphic morphism" (specifically a dinatural transformation) `beta_c : e >---> F(c,c)' (`e' (cf `|Gamma|' before) not depending on `c'), that works (in a "dinatural way") for every `c' in `C'
01:41:13 <athan> through it's "Copy" typeclass / trait; you are forbidden to re-use a term unless you can copy its memory location
01:41:27 <athan> er, data in memory* :x
01:43:07 <ski> and from this we construct a morphism into a `forall'-type (*inside* `E') `poly_beta : e >---> (forall c. F(c,c)', in type theory terms we can think of it as being defined as `poly_beta = \x : e. /\c : C. beta_c(x)'
01:44:05 <ski> `/\c : C. ..c..' (`..c..' being an expression) being how in type theory we'd construct a value in the type `forall c : C. ..c..' (this `..c..' being a type, the type of the earlier `..c..' expression)
01:44:17 <ski> mniip : ok
01:45:25 <ski> @type (`replicate` Nothing) :: forall a. Int -> [Maybe a]
01:45:27 <lambdabot> Int -> [Maybe a]
01:45:37 <ski> @type (`replicate` Nothing) :: Int -> (forall a. [Maybe a])
01:45:39 <lambdabot> Int -> [Maybe a]
01:45:47 <ski> (in Haskell the movement of the `forall' is implicit)
01:46:03 <ski> perhaps
01:46:12 <ski> @type (`replicate` id)
01:46:14 <lambdabot> Int -> [a -> a]
01:46:28 <ski> would be more apropos here, since `[a -> a]' mentions `a' both contravariantly and covariantly
01:47:52 <ski> athan : it's not uniqueness, then ?
01:48:35 <mniip> athan, can you destroy / not use a term
01:49:44 <athan> mniip: ! ahh, thank you
01:49:53 <athan> I'm mistaken :x
01:50:02 <ski> mistaken about what ?
01:50:22 <athan> linearity in regards to term _usage_, not necessarilly it's ability to be used
01:50:34 <athan> (I think)
01:51:52 <ski> with linearity, you basically can express that you're not allowed to reuse a thing, in the *future*. with uniqueness, you're ensuring that you haven't reused it, in the *past*
01:52:00 <ski> the latter allows update-in-place
01:52:19 <ski> (since you know you're given the unique reference to the object)
01:52:41 <athan> :O woah, okay thank you ski
01:53:01 <athan> I still don't have a practical outlet to use these features, but do you happen to know of a reference to where I can learn more?
01:53:11 <ski> (also allows "compile-time-GC", iow putting an explicit call to `free' at this point, if you're rather throw the memory block of the object away, rather than reusing it)
01:53:18 <athan> I remember advanced topics in TaPL breifly mentions substructural type systems
01:53:34 <athan> oh wow that sounds awesome
01:55:53 <ski> i suppose you could try looking at Clean (the "other" lazy programming language, whose makers' goals couldn't be reconciled with the general goals agreed upon by the (rest of the) Haskell committe), ..
01:56:44 <ski> .. or Mercury (a (statically typed) logic/functional programming language, interesting in its own right for its (static) mode, inst and determinism system for keeping track of how much info is known yet about variables, and how many solutions predicates/relations and functions may have, given different patterns of known data. also has type classes, existentials, &c.)
01:58:03 <ski> Clean incorporates uniqueness into types. if you call e.g. `(++)' with first argument unique, it'll modify the tail of it to point to the second
01:59:20 <ski> the same can happen in Mercury, except that uniqueness is incorporated into insts (instantiation states) and modes (transitions between instantiation states, also descriptions of how arguments/results of predicates&functions transition, when called in some initial state, together with information on the number of solutions (determinism))
01:59:42 <ski> istr there's also some papers by Wadler (and probably others) ?
02:01:58 <ski> (<https://www.mercurylang.org/documentation/papers.html> has links to papers, e.g. see "Strong modes can change the world!" by Fergus Henderson in 1992-11 (Fergus also participated in <http://research.microsoft.com/en-us/um/people/simonpj/Papers/imprecise-exn.htm> with Peyton Jones,et al.))
02:02:30 <noan> So if I'm using http://www.yesodweb.com/book/persistent... how do I even structure the module definition O.o?
02:02:46 <athan> !!! Awesome, thank you ski!
02:04:29 <ski> for Clean, see <http://wiki.clean.cs.ru.nl/Clean>, e.g. <http://clean.cs.ru.nl/download/html_report/CleanRep.2.2_11.htm#_Toc311798092>. paper list is at <http://wiki.clean.cs.ru.nl/Publications>, i don't recall any particular to recommend
02:05:15 <ski> for Mercury, the docs on uniqueness is at <https://www.mercurylang.org/information/doc-latest/mercury_ref/Unique-modes.html>
02:05:48 <ski> perhaps <http://stackoverflow.com/questions/26309081/how-do-rusts-ownership-semantics-relate-to-uniqueness-typing-as-found-in-clean> could be interesting as well
02:05:51 <ski> athan ^
02:06:45 <athan> thank you ski :)
02:07:25 <noan> Anyone know where I can find baby's first guide to module organisation? like, if I have src/db/SomeFile I would like to import it as DB.SomeFile not simply SomeFile
02:07:55 <athan> noan: They're orthogonal to filesystem paths
02:08:07 <athan> so DB.SomeFile would be src/DB/SomeFile.hs
02:08:36 <noan> athan, and the module declaration in SomeFile would just be module SomeFile where
02:08:37 <noan> ?
02:09:16 <athan> noan, nope, it needs to be absolute as well - module DB.SomeFile where
02:09:33 <athan> and notice though that `src/` is arbitrary under the Cabal `haskell-src-dirs` clause
02:09:37 <athan> (I think it's that)
02:09:40 <noan> oh my god. the . is a valid part of the name
02:09:43 <noan> there's where I was getting fucky.
02:09:50 <athan> hs-source-dirs*
02:09:58 <athan> :)
02:10:09 <noan> So it's not "SomeFile contained in DB" it's "No bitch my name is DB.SomeFile"
02:10:22 <athan> same difference imho
02:10:47 <athan> you can re-export modules, but it's smart to do it predicatively like DB re-exports DB.SomeFile
02:11:01 <noan> and in my cabal file I need to explicitly list every source dir and every module to export, right?
02:11:06 <noan> nothing is assumed recursive?
02:11:08 * athan probably misused that term
02:11:20 <athan> correct
02:11:39 <athan> also, it's wise to list non-exported modules under `other-modules` as well, for linking concerns
02:11:44 * noan adds src/db and src/requests to dirs and DB.SessionToken to exported modules
02:11:46 <noan> for instance?
02:11:57 <athan> yep, that looks right to me
02:12:55 <ski> athan : re Wadler, i was probably thinking of <https://homepages.inf.ed.ac.uk/wadler/topics/linear-logic.html>
02:14:07 <noan> athan, fairly related to this is... I want to start setting up Persistent. Normally I try to define my modules like module Foo( Bar, Baz) where so only Bar and Baz are exported if I understand right...
02:14:36 <noan> But with perstient it gets a little confusing. Is it bad practice(and possible?) to simply module Foo where and then everything past the where is available upon import?
02:14:55 <noan> athan, thanks for the help by the way :D
02:16:18 <athan> noan, yep your intuition is correct, if nothing is explicitly exported then everything is. This is actually pretty tricky because persistent generates terms using metaprogramming, so it's hard to predict what exactly is available for export
02:17:19 <athan> ski: got it! Can't wait to read
02:19:13 * ski . o O ( "A critique of Abelson and Sussman - or - Why calculating is better than scheming" by Philip Wadler in 1987 at <http://cs.kent.ac.uk/people/staff/dat/miranda/wadler87.pdf> )
02:20:50 <ski> athan : for Mercury, it helps to know a little about logic programming (e.g. Prolog) .. imho, every programmer ought to know at least a little about what logic programming (and preferable also constraint (logic) programming) is, just as they ought to know about functional programming
02:21:48 <noan> athan, which is why I was thinking of going "module MyDBTypeFromPerstistent where". Is this generally bad practice or anything like that?
02:21:55 <noan> or in this case seen as "yeah that's fine"
02:24:11 <ski> athan : hmm .. when using TH that generates definitions/bindings, it ought to be possible to (preferably(?), and at least abstractly) give a name to the group of bindings/names, so that you can explicitly choose to list that abstract name in the module export (and also in later imports ?)
02:24:30 <ski> .. hm, i suppose this issue is related to hygiene (or lack thereof) in TH
02:25:25 <athan> ski: I'm only familiar with GHC's Contraint system, but I think I have an intuition to logic programming. That's one field I would like to explore more, though
02:26:03 <athan> I have no idea ski :)
02:26:27 <athan> noan: I wouldn't consider that terrible practice, but I usually do something like `Schema.Foo` and throw all the persistent stuff in there
02:26:28 <ski> i suppose allowing submodules would be an easy way to accomplish this. your TH would give a name to the submodule (which would presumably usually be automatically opened/imported into the enclosing larger module), and then you could refer to that submodule in the export list, at least ?
02:27:13 <noan> athan, in my cause it's going to be DB.SessionToken in this example and only the schema parts. Business rules will go under something like Resources.Whatever
02:27:17 <noan> or something.
02:28:06 <athan> hm, it appears that GHC's RTS options under ARM doesn't recognize -N :s
02:28:41 <athan> noan: That sounds sane to me, I'm sure you'll develop a style that makes sense & comfort to you :)
02:29:18 <ski> athan : there are ##prolog,#mercury (and #cleanlang). if you happen to have access to
02:29:21 <ski> @where CTM
02:29:22 <lambdabot> "Concepts, Techniques, and Models of Computer Programming", by Peter Van Roy,Seif Haridi, at <http://www.info.ucl.ac.be/~pvr/book.html>
02:33:22 <ski> athan : then i'd also recommend it. it is a bit comparable to SICP, but more modern, and covers more paradigms. it uses the multi-paradigm language Oz (a simple logic programming language without disjunction at the base), implementation is Mozart <https://mozart.github.io/>
02:34:08 <athan> oh wow!!!
02:34:10 <ski> <https://mozart.github.io/mozart-v1/doc-1.4.0/fdt/index.html> and <https://mozart.github.io/mozart-v1/doc-1.4.0/fst/index.html> are two constraints tutorials, in terms of Oz
02:34:22 <athan> thank you dearly!
02:35:11 <athan> I've heard of Oz before from somewhere..
02:36:42 <ski> but otherwise, for logic programming, most of the available material is for Prolog (or systems based on it), so i'd recommend checking out Prolog regardless (even though it's dated, has many flaws, no standard module system, higher-order programming is a kludge (works, but can be annoying), side-effects present, the (sadly necessary) "cut" abomination, var/1, &c. ..)
02:37:46 <athan> heh, I'll definitely check it out :) I hear it's a thorn most students like to pluck quickly
02:38:07 <ski> athan : "Re: Mercury in academic teaching?" by Richard A. O'Keefe in 2006-10-(09|10) at <http://www.mercurylang.org/list-archives/users/2006-October/004000.html>,<http://www.mercurylang.org/list-archives/users/2006-October/004011.html> might be interesting re learning Prolog or Mercury first ..
03:20:51 <johndcl> is it possible to ":load" another file in a Haskell script?
03:21:06 <noan> trying to get Aeson and Persistent playing together. But I don't have an instance of Generic MyGeneratedType. Would you guys define the DB type and the type that has JSON encoding separately?
03:21:27 <johndcl> i've some functions in Code/foo.hs and I'd like to use them in my bar.hs script
03:21:32 <noan> nah that seems needless. I think i just need to figure out how to do the generic instance...
03:24:42 <pavonia> johndcl: You have to import Code.Foo from Bar
03:26:02 <johndcl> pavonia: so the file must begin with uppercase letter? I've tried 'import Code.foo' and it ... didn't work
03:26:25 <johndcl> error: parse error on input ‘Code.countdown’
03:26:50 <pavonia> Yes
03:26:55 <johndcl> thank you
03:32:10 <noan> Anyone using both Aeson and Perstistent?
03:32:51 <noan> oh, perstistent depends on aeson anyway... okay so this stuff should be more doable than I think
03:47:56 <NeverDie> What's usually recommended for session cookies with Haskell?
03:49:10 <mbw> Hello everyone. I wanted to try out the Haskell School of Music book, which depends on a library called Euterpea, which is only found on Hackage. I managed to install it locally via cabal sandbox init / cabal install. However, I would like to use stack for working with the examples. Do I have to cabal init, and then stack init? Right now I have only the cabal sandbox, without a ".cabal" file.
04:01:08 <AndreasK> mbw: You can also use stack new and then add the package in stack.yaml under extra.deps
04:05:16 <mbw> AndreasK: I tried that initially, following the recommendations stack gives you when a package is not on stackage. However, after adding the package to extra-deps, new dependencies popped up, and after two "iterations" I was stuck.
04:37:40 <mroman> Is there a Chan version with a maximum capacity?
04:38:00 <mroman> and puts will block until new space is available
04:40:41 <pavonia> mroman: There's a BoundedChan package
04:41:18 <AndreasK> mbw: Did you try using stack solver?
04:42:10 <AndreasK> mbw: That seems to find a build plan for me
04:42:58 <johndcl> How can I check that (a ^ b) :: Int overflowed?
04:43:44 <mroman> so isEmptyChan will block until something is available and then return False in bad cases.
04:43:45 <mroman> neat.
04:50:11 <mbw> Ok, one more question. As mentioned previously, I was trying to use the Euterpea package. stack solver failed with this output: http://lpaste.net/352081. After manually adding "heap-0.6.0" to stack.yaml, it worked. Shouldn't this be something that the solver could figure out on its own?
04:50:15 <mroman> no dupChan in BoundedChan though
04:50:16 <mroman> bummer :(
04:52:12 <mbw> Could it be that there is an issue with my stack / cabal setup?
04:53:28 <mbw> Since I have difficulties finding information about this kind of error messages, at least in the context of stack usage.
04:55:54 <mbw> Ok I've had it with this library. It didn't build after all.
04:59:22 <AndreasK> mbw: Can you post your cabal and yaml file? It built for me
05:01:31 <AndreasK> mbw: I used these cabal/stack files: http://lpaste.net/5101709175214309376  http://lpaste.net/172690674943000576
05:01:51 <AndreasK> Starting by creating a new project using stack new and then adding the library as dependency
05:03:15 <mbw> I added the Euterpea dependency under "library", not "executable". Does that make a difference?
05:04:16 <mbw> No, it does not, it seems. I'll paste the output of solver
05:04:45 <AndreasK> mbw: should not for finding a build plan at least, try running stack update maybe your package index is out of date, although I would think that happens automatically
05:05:19 <mbw> http://lpaste.net/352082
05:05:34 <mbw> I run stack update on a daily basis :(
05:06:02 <mbw> But what's weird when you look at this output, it actually rejects "heap-0.6.0", which it seems to need.
05:06:40 <mbw> This is after stack new, adding Euterpea to the .cabal file, and running solver
05:11:24 <AndreasK> mbw: can you try to check this repo out and run stack build on it? https://github.com/AndreasPK/eur
05:13:22 <mbw> on it
05:13:41 <mbw> It built. What the hell man...
05:14:01 <AndreasK> Something wrong with your project folder/cabal file then i guess
05:14:48 <mbw> I just vimdiffed them. If I would s/eur/hsom/g them, they'd be identical.
05:15:35 <mbw> But of course your stack.yaml has all the extra-deps entries.
05:15:40 <mbw> Did you add those manually?
05:17:09 <mbw> I also noted that the changelog of the newest cabal mentions a bug about handling of non-buildable components. Do you have cabal 1.24.2.0?
05:17:32 <mbw> The errors I got were from the cabal backend after all
05:21:17 <laserpants> How come this is fine; f :: Seq a -> Seq a; f xs = deleteAt 0 xs
05:21:32 <laserpants> but not f xs = ys where ys :: Seq a; ys = deleteAt 0 xs
05:24:45 <mbw> Ok I can't even upgrade cabal it seems
05:26:20 <pavonia> laserpants: Because "Seq a" means it has to work for any type a, but the type of xs is already fixed by the type of f
05:27:04 <laserpants> so I can't use a type signature in this case or?
05:27:48 <pavonia> You can but you have to make sure it's the same a, e.g. by using the ScopedTypeVariables extension
05:28:18 <laserpants> pavonia: I see. Thanks
05:28:21 <mbw> AndreasK: Did you add the extra-deps manually?
05:28:38 <AndreasK> mbw: no stack solver --update-config did
05:29:40 <AndreasK> mbw: cabal 1.22.7 in use by stack
05:30:23 <AndreasK> mbw: But I got the first error as well, but it succeeded the the "running with lts-7.18 as preferences part" for me
05:31:35 <AndreasK> You could try downgrading cabal and checking if stack solver works then
05:31:45 <AndreasK> If your really interested
05:32:46 <mbw> I am actually, since this is not the first time I encounter these kind of problems. However, I thought I had to upgrade. But I think "cabal install Cabal caball-install" is not the correct way to do this :/
05:33:03 <mbw> I feel like I'm stuck building all of hackage right now
05:33:43 <mbw> But what do you mean with the "running with lts-7.18 as preferences part"?
05:34:42 <mbw> And how do I actually update cabal!? It seems to be building the same version again...
05:34:52 <mbw> *upgrade
05:36:27 <mbw> nvm, versions of Cabal/cabal-install are different
05:41:38 <mbw> AndreasK: There is an open issue which I suspect might be the cause https://github.com/commercialhaskell/stack/issues/2585
05:43:40 <AndreasK> mbw: http://lpaste.net/2195246811067711488 is my output for stack solver, it also fails to find a buildplan since it doesnt consider packages from hackage at the start, then relaxes the requirements and succeeds
05:44:39 <AndreasK> mbw: But sounds like your link is the cause for that issue
05:46:46 <mbw> I'm currently trying to get what is suggested here https://stackoverflow.com/questions/39713267/trying-to-solve-a-stack-error-library-must-match-0-10-but-the-stack-configur to work
06:22:33 <libscott> is there any way to have a record that has an extra derived value that gets cached? so the constructor can be (Thing a) but actually it also contains a b
06:26:14 <hodapp> you could have, say, a smart constructor that does that, but why would you need it to be cached?
06:27:04 <libscott> hodapp: I want to provide an Ord instance that doesn't need to recalculate the scalar value each time
06:27:12 <libscott> and also not have to pattern match on the scalar part
06:29:46 <hodapp> I think you can force the value to be strict, but that's almost never necessary to do explicitly
06:36:50 <ertes> what's the difference between GHC.Prim and GHC.PrimopWrappers?  particular example: mkWeak#
06:37:00 <ertes> the types are equal
06:37:41 <ertes> according to the source code they are equal, too
06:54:32 <xcmw> & is to >>> as <&> is to what? (a -> m b) -> (b -> c) -> a -> m c
07:00:00 <xcmw> Anyone know what operator does that?
07:00:22 <c_wraith> doesn't look familiar. 
07:08:29 <tfc> i would like to append "-isome_folder" to my "stack ghci" command line, but i am unable to figure out. can anyone help me?
07:09:13 <EckT_> maybe stack ghci -- -isome_folder?
07:09:43 <tfc> then it tells me "Error parsing targets: Directory not found: -isrc"
07:09:59 <tfc> but the directory is correct.
07:11:20 <c_wraith> is it possible stack is changing the cwd before running ghci? 
07:11:37 <c_wraith> try using an absolute path to the directory 
07:13:01 <tfc> yes, it is possible, but i am going to tell it ":load SomeHaskellModule", which is in $CWD, but imports other modules from a completely different folder. that's why i want to use -I$folder
07:13:18 <c_wraith> ah, I see. 
07:13:34 <c_wraith> I suspect you've just found a case stack wasn't built for. 
07:13:47 <c_wraith> it's very project-oriented
07:14:16 <tfc> hm. i would like to play with functions from my project
07:14:27 <tfc> looks like it's not possible to mix app/ and src/ files in ghci then
07:14:29 <c_wraith> you could add the source dir interactively, maybe? 
07:14:44 <c_wraith> in ghci, :set -idir
07:14:49 <tfc> oh that sounds great
07:15:17 <tfc> yeah that works perfect
07:15:20 <tfc> thank you!
07:15:25 <c_wraith> you're welcome 
07:15:49 <iwmrby> Hey. How can I refer to the current object in Haskell? I am trying to use an element from a Matrix while building the Matrix.
07:16:48 <iwmrby> let a = matrix 3 2 $ \(i, j) -> if i == 1 then 1 else if j == 1 then 1 else (getElem i (j-1) a + getElem (i-1) (j-1) a + getElem (i-1) j a) 
07:17:05 <iwmrby> ^this works, but I want not to use `let a =`. Is there a way?
07:18:12 <michaelt> iwmrby: you are using the matrix library?
07:18:32 <c_wraith> iwmrby: haskell doesn't have any concept of "the current object"
07:18:40 <iwmrby> michaelt: Because I need a matrix.
07:18:57 <iwmrby> c_wraith: oh. I will use let then. Thanks! I tought there maybe was a way
07:19:12 <iwmrby> michaelt: is there something wrong with Matrix?
07:19:22 <c_wraith> iwmrby: I think he was just asking *which* library you're using
07:19:35 <michaelt> yes
07:19:53 <iwmrby> Oh. Yes. Apoogies. I am using Data.Matrix
07:19:59 <Welkin> apoogies
07:19:59 <michaelt> the library is using a vector to represent a matrix
07:20:09 <noan> Anyone know where I can find an example of using a request header in servant? 
07:20:29 <iwmrby> Welkin: :)) It's clear, I need sleep.
07:20:32 <Welkin> noan: #haskell-servant is a good place to ask servant-secific questions
07:20:40 <Welkin> specific*
07:20:49 <noan> Welkin, cheers
07:21:11 <michaelt> iwmrby: such a thing needs to be built all at once. you might want `Data.Array` 
07:21:33 <noan> Welkin, if that weren't an empty channel of course.
07:21:54 <Welkin> oh?
07:22:23 <Welkin> oh yes
07:22:25 <Welkin> #servant
07:22:28 <noan> ty
07:28:28 <michaelt> iwmrby: look at the definition of the array `a` here https://hackage.haskell.org/package/array-0.5.1.1/docs/Data-Array.html#v:array
07:30:22 <michaelt> iwmrby: it is using a list comprehension two build a 1-d array which isn't as interesting but builds it by referring to elements of the array it is defining
07:30:51 <michaelt> iwmrby: this won't be possible with the matrix library if I understand
07:37:46 <opqdonut> it seems vacuum doesn't support GHC>7.8
07:38:01 <Welkin> what's that?
07:38:18 <opqdonut> a debugging / visualization tool that can draw pictures of your stack
07:39:17 <opqdonut> e.g. https://www.youtube.com/watch?v=A1wtQ_mYHHo
07:40:18 <opqdonut> https://hackage.haskell.org/package/ghc-heap-view seems like an alternative but it too says "Currently, GHC 7.4 through 7.10 should be supported."
07:41:02 <opqdonut> heh looks like ghc-heap-view just got ghc 8 support: https://github.com/nomeata/ghc-heap-view/commits/master
07:41:49 <ph88> if i have a string like "foo\"bar" and i want to enclose it with double quotes like so "\"foo\"bar\"" how can i make a parser function so that the parser "gives back" the last " in case it's needed to end the quoted string?
07:44:59 <pavonia> ph88: You just need to escape all "s and \s in the string
07:45:01 <michaelt> iwmrby: or rather, it's possible with this generator function, but you will have to build and rebuild the (partially undefined) vector for each element of the matrix, if I understand
07:45:03 <ph88> hhmm actually i'm not sure if i put the requirement to escape the inner quote ^^ let me check that first
08:03:18 <michaelt> iwmrby: but maybe I'm wrong, maybe the way the `matrix` is written is arranged to make this legitimate. It's a little confusing ...
08:17:45 <iwmrby> michaelt: yup, a little confusing. I decided I shall use let because it works for now. If I hit this problem again sometime, I will look into it more.
08:18:06 <iwmrby> michaelt: thanks a lot for your help and for trying to find a solution!
08:18:22 <tfc> does anyone use haskell on Mac OS? i wrote an application which reads from serial port. this works great unter linux, but in OSX i get EOFs too early after opening the port and reading from it.
08:20:36 <c_wraith> I've used it lots on os x
08:20:43 <c_wraith> But I've never worked with serial ports
08:20:47 <c_wraith> What interface are you using?
08:21:08 <tfc> that is a PL2302 rs232serial to USB converter.
08:21:30 <tfc> and i use the "serial" haskell package
08:22:10 <tfc> results are as expected in linux, but in osx i have those premature EOFs. that drives me mad, because i have no idea what to do differently from haskell side.
08:22:33 <c_wraith> I'm betting the serial package wasn't tested on os x
08:22:57 <tfc> hm that's possible.
08:23:35 <tfc> with apps like "picocom" i can successfully read from the serial file. just with haskell (in osx) there are problems.
08:23:48 <tfc> maybe there's some extra flag needed when opening the port, but i have no clue.
08:48:56 <Tuplanolla> I see the expression `pure ()` be called `pass`, `obvious`, `skip` and `end`. Which name should I choose?
08:49:10 <c_wraith> skip doesn't make a lot of sense.
08:49:17 <c_wraith> end isn't true
08:49:19 <Welkin> I've never seen it called any of those
08:49:22 <Welkin> where do you see this?
08:49:26 <c_wraith> it's called pass in python
08:49:30 <Tuplanolla> Hoogle, Welkin.
08:50:09 <c_wraith> in general, none of those names have enough advantages over just using `pure ()` to be worth using.
08:50:40 <Tuplanolla> That may be, but it's still nice to have a name for it.
08:50:50 <c_wraith> They all have the giant downside of being more work to look up than the idea is worth
08:51:03 <hpc> ^
08:51:16 <Welkin> I find this *very* true
08:51:31 <hpc> also you'd have to get downright obfuscated to get any significant typing savings on "pure ()"
08:51:32 <Welkin> especially when you start using too many DSLs that redfine common things for *no reason whatsoever*
08:51:41 <hpc> 3 characters isn't worth it to gain zero abstraction
09:03:57 <xcmw> Is there a double <&> operator? a ? b = a <&> (<&> b)?
09:04:42 <Tuplanolla> It's useful to be able to mentally say "pass" instead of "pure unit".
09:05:04 <Tuplanolla> :t \ a b -> a <&> (<&> b)
09:05:06 <lambdabot> (Functor f1, Functor f) => f (f1 a) -> (a -> b) -> f (f1 b)
09:06:53 <Welkin> :t (<$>) . (<$>)
09:06:56 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
09:07:10 <Welkin> :t (<&>) . (<&>)
09:07:12 <lambdabot> Functor f => f a -> (f b1 -> b) -> (a -> b1) -> b
09:07:26 <Welkin> :t flip ((<$>) . (<&>))
09:07:28 <lambdabot> (Functor f1, Functor f) => f (a -> b) -> f1 a -> f (f1 b)
09:07:31 <Welkin> :t flip ((<$>) . (<$>))
09:07:33 <lambdabot> (Functor f1, Functor f) => f (f1 a) -> (a -> b) -> f (f1 b)
09:07:36 <Welkin> there you go
09:08:11 <Welkin> @let <&&> = flip ((<$>) . (<$>))
09:08:11 <lambdabot>  Parse failed: Parse error: <&&>
09:08:19 <Welkin> @let (<&&>) = flip ((<$>) . (<$>))
09:08:21 <lambdabot>  Defined.
09:09:34 <ongy> :t (<&&>)
09:09:36 <lambdabot> (Functor f1, Functor f) => f (f1 a) -> (a -> b) -> f (f1 b)
09:11:04 <xcmw> Ok thanks
09:12:34 <noan> Sooo... put my database schema in one file, or split it over many in a db directory?
09:13:35 <Welkin> noan: I usually use one file
09:13:38 <Welkin> are you using Persistent?
09:13:45 <noan> I am.
09:13:49 <Welkin> then go with one file
09:13:53 <Welkin> the syntax is very compact
09:13:59 <noan> was thinking so because of that
09:14:10 <noan> otherwise I have more boilerplate than schema in each file XD
09:15:36 <noan> my instance ToJSON foo and such at the end of the schema are gonna be a biiit weird
09:18:33 <Welkin> noan: you can have those autogenerated
09:18:38 <Welkin> unless you need them to be custom
09:18:52 <Welkin> just add the keyword `json` after the type/table name
09:19:31 <noan> last time I tried that it blew up in my face.
09:19:34 <noan> lets try again
09:20:43 <noan> yep, it mad.
09:20:55 <Welkin> you might need the {-# LANGUAGE DeriveGeneric              #-} pragma
09:21:01 <Welkin> along with `import           GHC.Generics         (Generic)`
09:21:36 <noan> both present
09:21:39 <noan> sec, gisting
09:22:45 <noan> https://gist.github.com/AlexaDeWit/7d5b535cc4f3b4eec0217af8bc26bd43
09:23:13 <Welkin> add another pragma FlexibleInstances
09:23:17 <noan> ty
09:23:44 <noan> all is calm
09:23:52 <noan> you're a good man Welin
09:24:03 <noan> maybe. Unless you're secretly plotting the downfall of humanity. Or something.
09:26:28 <sm> or not a man
09:27:23 <noan> oh that too.
09:29:55 <noan> Migration worked!"
09:30:26 <sm> if you've seen the recent Hidden Figures.. it often still feels like those all-male mission/computer rooms around here
09:30:58 <Welkin> lol
09:31:07 <Welkin> I just found out about that film last night
09:31:14 <sm> it's a pretty good film
09:34:43 <benzrf> dismantle patriarchy tbh
09:35:23 <Welkin> you mean oligarchy
09:35:29 <benzrf> both
09:37:33 <Welkin> @undo do { a; b}
09:37:33 <lambdabot> a >> b
09:38:18 <sm> male techies should watch it. I liked that scene where the women take over the IBM/fortran lab
09:54:50 <monochrom> I like their leader's foresight that it was time to learn programming.
09:55:59 <sm> yeah! and steals a fortran manual! smart lady!
09:57:05 <Welkin> she should have taken the lisp one!
09:58:05 <sm> from the look of things, NASA was not looking for that kind of hippie nonsense at that moment :)
09:58:12 <Welkin> lol
09:58:42 <Welkin> obviously it was a joke
09:58:49 <sm> it seemed just getting "the IBM" running was a huge deal
09:58:49 <Welkin> no one likes the original lisp
09:59:08 <hpc> elispers might
09:59:27 <Welkin> no types, no deal!
10:00:31 <Theophane> :D
10:01:45 <hpc> Welkin: very few people were able to use the original lisp, because the compiler was a room full of grad students
10:02:42 <Xnuk> > 10^123456789
10:02:49 <lambdabot>  mueval: ExitFailure 1
10:03:31 <Welkin> > take 10 $ replicate 123456789 10
10:03:33 <lambdabot>  [10,10,10,10,10,10,10,10,10,10]
10:03:57 <Xnuk> Can I kill this evaluation?
10:04:06 <Welkin> > foldr1' (*) $ replicate 123456789 10
10:04:09 <lambdabot>  error:
10:04:09 <lambdabot>      • Variable not in scope:
10:04:09 <lambdabot>          foldr1' :: (Integer -> Integer -> Integer) -> [Integer] -> t
10:04:19 <monochrom> @quote room.*grad.*student
10:04:19 <lambdabot> hpc says: the first lisp interpreter was a room full of grad students
10:04:51 <hpc> huh, i have mentioned this before
10:05:45 <hpc> lisp was never intended to be run, it was just a theoretical construct for writing lambda calculus, plus some silly things like eval
10:05:54 <Welkin> like coq
10:05:54 <Welkin> :D
10:06:21 <hpc> and said grad students decided if eval was made executable, you had (for the 50s) one of the highest-level languages ever written
10:06:32 <hpc> and they hand-compiled it
10:06:55 <hpc> yeah, imagine going back and showing them a DT language
10:07:25 <hpc> a lot of the math behind DT is quite recent
10:07:39 <Welkin> I feel like most software development is stuck in the stone age even still today
10:07:42 <monochrom> That would cause a divide among them, and they would split and argue over static types vs dynamic types.
10:07:51 <hpc> the calculus of constructions didn't even come about until 88
10:08:06 <hpc> monochrom: they didn't even have types yet
10:08:25 <sm> those poor savages
10:08:25 <monochrom> But you just showed them!
10:08:31 <Xnuk> I did `thread <- forkFinally (return $ 10^123456789) ({- put result to MVar -}); threadDelay 5e6; killThread thread` and this doesn't work
10:08:34 <hpc> actually i guess they did, fortran existed
10:08:35 <Welkin> advanced type systems are slowly taking over
10:08:59 <hpc> and i thiiiiink it was typed?
10:09:56 <hpc> yeah
10:09:59 <monochrom> > 5e6 :: Int
10:10:02 <lambdabot>  error:
10:10:02 <lambdabot>      • No instance for (Fractional Int) arising from the literal ‘5e6’
10:10:02 <lambdabot>      • In the expression: 5e6 :: Int
10:10:08 <monochrom> Is that why?
10:10:18 <hpc> i think we've stagnated pretty heavily on the current trend of untyped interpreted languages (like python)
10:10:37 <Welkin> hpc: thankfully...
10:10:42 <hpc> and the next language to dominate is going to be the first to popularize a powerful type system
10:10:50 <hpc> hopefully that's haskell
10:10:57 <Welkin> facebook seems to be pushing ocaml hard as a backend at least
10:11:00 <hpc> or idris
10:11:19 <Xnuk> monochrom: No, I wrote like 5000000
10:11:37 <Welkin> they released a new dsl called "Reason" that you use to generate javascript using an ocaml backend
10:11:47 <boojinks> I wonder what the relationship is between the guys behind Reason and the guys on the FB Haskell teams?
10:11:57 <hpc> i don't think ocaml will be the one to do it
10:12:00 <monochrom> OK, what does "doesn't work" mean?
10:12:03 <Welkin> hpc: I don't either
10:12:10 <tfc> hm i think the languages will stay popular which make it easy to copy&paste stuff and modify it to make it fit your needs. that's python. 
10:12:22 <hpc> rust might, if they get some more really good ideas
10:12:27 <tfc> put one monad into haskell code and no one from outside gets it
10:12:49 <sm> I think that will change a bit
10:12:50 <boojinks> tfc: similar happened when OOP was pushed though, no?
10:12:52 <hpc> it wouldn't be nearly as effective as a high-level language as haskell, but it would have the advantage of being in a mode of thought many people already use
10:13:02 <hpc> and it's so much better than C that i wouldn't even mind
10:13:16 <Welkin> facebook pretty muhc dominates the js landcscape these days
10:13:26 <Xnuk> monochrom: It compiles successfully, but CPU usage of the compiled program still hits 100% after 5e6 microseconds
10:13:31 <Welkin> and they are pushing hard to immutability, types, and pure functions
10:13:34 <Welkin> for*
10:13:48 <hpc> tfc: i have been slowly convincing my coworkers of what Monad can do and it's been going well
10:14:11 <monochrom> Have you shown the whole complete program?
10:14:12 <tfc> look at c++. it allows for so many no-runtime-cost things which help abstracting ideas further from C
10:14:14 <hpc> showing people what "trailing do" syntax can do in other languages like perl and ruby seems to work well
10:14:21 <tfc> but nevertheless people stick to c-style c++
10:14:34 <sm> tfc: monads will become normal, and we'll make improvements in usability (which might or might not be called haskell)
10:14:57 <tfc> they are thankful for shared_ptr, constructor/destructor logic and so on, but the programs are still sequences of if while else for foo
10:14:57 <hpc> i think just eliminating the magic around the name will go a long way
10:15:03 <hpc> and having more connective concepts like Monoid
10:15:28 <hpc> it's much better now than it was when i first learned haskell
10:15:49 <Welkin> hpc: well now you are a fuly-grown lizard man
10:16:02 <tfc> i am currently programming haskell a lot and i am completely fascinated. i got to understand monads, but i still can hardly explain what applicative and monoid etc. mean
10:16:07 <hpc> FAM also helps document the relationship
10:16:20 <Welkin> FAAMA
10:16:23 <Welkin> FAAMAC
10:16:32 <hpc> Monoid is super easy
10:16:34 <Welkin> oops
10:16:39 <Welkin> FASMMAC
10:16:49 <hpc> it's two operations, (<>) and mempty
10:16:53 <Welkin> :D
10:16:57 <hpc> with x <> mempty = x = mempty <> x
10:17:01 <Welkin> and then you can use that to explain semigroups
10:17:05 <MarcelineVQ> Welkin: what are the last two :>
10:17:08 <hpc> and (x <> y) <> z = x <> (y <> z)
10:17:16 <Welkin> MarcelineVQ: Arrow and Category :D
10:17:37 <hpc> if you need to give examples, i like to give the ones for (+) and (*)
10:17:37 <benzrf> 13:15 <tfc> i am currently programming haskell a lot and i am completely fascinated. i got to understand monads, but i still can hardly explain what applicative and monoid etc. mean
10:17:47 <benzrf> if this is true, i suspect that perhaps you don't actually understand monads =p
10:17:53 <hpc> mempty = 0, (<>) = (+)
10:17:58 <tfc> benzrf: you might be right, lol.
10:17:58 <hpc> mempty = 1, (<>) = (*)
10:18:02 <monochrom> monoid should be the easy one because so many programmers are so obsessed with numbers and strings.
10:18:34 <benzrf> monochrom: i think the problem is less about monoids in specific, and more about mathematical abstractions in general
10:18:34 <hpc> Monoid might even be so important it should be taught before Functor
10:18:48 <Welkin> Monoid and Functor first
10:19:01 <hpc> because it's one that damn near everyone learns already, if they notice it or not
10:19:03 <benzrf> tfc: the key thing to understand is that many of haskell's abstractions don't necessarily map cleanly to a specific intuitive notion
10:19:11 <tfc> when i first read my first haskell book, all the theoretical explanations and concept blew up my brain. i think if i read such introductory stuff again in half a year, i will finally get it. ;)
10:19:16 <Welkin> monoid can help to understand monad
10:19:17 <hpc> anyone who's taken basic algebra will recognize it instantly
10:20:08 <hpc> it introduces the concept of algebraic laws, and you can tell the value of those laws pretty much instantly too
10:20:16 <tfc> well i had a lot algebra at university, but it still doesn't click immediately. although programming haskell in general feels a lot like doing math on the blackboard.
10:20:19 <benzrf> tfc: the purpose of things like monoid, monad, and so on (in haskell), is very simply that empirically speaking, a lot of pieces of code that are useful for specific types all look like each other
10:21:24 <benzrf> tfc: it just so happens that for Int and (+) and 0, for [a] and (++) and [], for Int and (*) and 1, it is empirically the case that you will see a lot of scraps of code that are identical except for swapping out those 3 things
10:21:42 <tfc> yes
10:21:44 <Welkin> so I end up using <> a lot
10:21:49 <benzrf> and that's really all there is to monoids, in the end
10:21:50 <Welkin> and almost never (++)
10:22:22 <Welkin> mainly because of String/Text/ByteString
10:22:32 <benzrf> well, that's not the full story, i guess
10:22:40 <Welkin> benzrf: your quotations look funny
10:22:53 <Welkin> they are `]` with an inverted background color
10:23:01 <benzrf> Welkin: thats italics, your client doesnt render it
10:23:34 <Xnuk> @lpaste
10:23:34 <lambdabot> Haskell pastebin: http://lpaste.net/
10:23:47 <benzrf> tfc: once someone identifies the common features between these usages, you get a kind of feedback effect where people then find new things they can do generically over that set of features - but to begin with, it's really only as simple as i just put it
10:24:23 <Welkin> best monad explanation http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
10:24:28 <benzrf> meh
10:24:34 <tfc> benzrf: yes i realized that, but the picture in my mind around that is still very primitive.
10:24:35 <hpc> you get to say "this is a monoid, therefore a gazillion things other people discovered previously"
10:24:39 <benzrf> tfc: oh, ok :)
10:24:45 <benzrf> sorry
10:24:56 <lpaste> Xnuk pasted “Cannot kill 10^123456789” at http://lpaste.net/352085
10:24:57 <tfc> i use monads every day and it's easy for me to stack IO and state and whatever monads
10:25:09 <benzrf> Welkin: i looked at that a lot back when i was starting out, and ultimately the only thing that really helped was just using a shitload of monads
10:25:25 <Welkin> using monads and understanding them are two different things though
10:25:35 <hpc> Xnuk: are you running it with -threaded?
10:25:37 <tfc> but it was pretty hard for me today to learn how to mix do notation stuff with applicative code lines in Data.Yaml
10:25:38 <Welkin> I used them a lot when I was building apps with yesod
10:25:50 <Welkin> but I didn't really understand them
10:25:53 <benzrf> Welkin: i feel like any blogpost about monads, no matter how good, is going to pretty much be like trying to use new analogies for mathematical concepts instead of actually doing the exercises
10:26:30 <Xnuk> hpc: Oh I forgot it
10:26:31 <monochrom> Xnuk: "print" is where the computation of 10^123456789 begins and will take whatever it takes to finish.
10:27:36 <hpc> Xnuk: oh yeah, you need to put the evaluation of that huge number inside the forked thread
10:28:11 <hpc> Xnuk: replace return with evaluate
10:28:19 <hpc> and import Control.Exception
10:28:23 <monochrom> Another triumph of my http://www.vex.net/~trebla/humour/tautologies.html #4
10:28:53 <Xnuk> monochrom, hpc: Thanks, I'll give it a try
10:29:41 <hexagoxel> :t timeout
10:29:42 <benzrf> tfc: you're comfortable with functor and monad, you said
10:29:42 <lambdabot> error: Variable not in scope: timeout
10:29:44 <benzrf> ?
10:29:50 <hexagoxel> Xnuk: http://hackage.haskell.org/package/base-4.9.1.0/docs/System-Timeout.html#v:timeout
10:30:02 <tfc> benzrf: yes
10:30:40 <benzrf> tfc: well, stop me if you've heard this one before, but you might be able to think of applicative as a "watered-down" version of monad
10:30:50 <hpc> :t ap
10:30:52 <lambdabot> Monad m => m (a -> b) -> m a -> m b
10:30:56 <hpc> :t (<*>)
10:30:57 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:30:59 <hpc> :t return
10:31:00 <hexagoxel> Xnuk: doesn't remove the need to seq/force/evaluate though
10:31:01 <lambdabot> Monad m => a -> m a
10:31:02 <hpc> :t pure
10:31:04 <lambdabot> Applicative f => a -> f a
10:31:45 <tfc> yes, it is very obvious that on some level they do the same thing
10:32:00 <tfc> there's a really really obivous pattern. :D
10:32:02 <benzrf> tfc: in particular, you can treat `f a' where f is an Applicative in the same mental way as `f a' when f is a Monad, but the Applicativeness only gives you the ability to concatenate two of them together into one with the result of both
10:32:09 <Welkin> applicatives cannot be sequenced, and they cannot depend on the result of the previous computation
10:32:11 <benzrf> i.e., f a -> f b -> f (a, b)
10:32:13 <Welkin> unlike monads
10:32:57 <tfc> oh, yes. that's helpful, i did not realize this before.
10:33:11 <benzrf> so you can do everything you can with do-notation EXCEPT that a variable bound with a '<-' cannot appear anywhere except in an argument to pure/return
10:33:31 <benzrf> this is kosher for applicative:   do x <- foo; bar; y <- baz; return (x + y)
10:33:37 <benzrf> this is not:   do x <- foo; bar x; y <- baz; return (x + y)
10:33:50 <benzrf> hence "cannot depend on the result of the previous computation"
10:34:08 <hpc> this is where the concept of applicative do-notation comes from too
10:34:11 <tfc> let me note that down, that's a very helpful example
10:34:29 <Welkin> benzrf: is it halal, too?
10:34:35 <benzrf> i hope so!
10:34:46 <benzrf> in more technical terms, if you have `m (m a)' with Monad m, you can get an `m a'; but with just Applicative m, you can't
10:35:10 <benzrf> in fact, the typical mathematical definition of a monad is about `m (m a) -> a', not bind
10:35:21 <hpc> m (m a) -> m a
10:35:26 <Welkin> mma!
10:35:29 <benzrf> er, fuck yeah
10:35:34 <hpc> ;)
10:35:41 <benzrf> typo :(
10:35:52 <Welkin> but it's easier to think about monad in terms of >>= and return
10:35:57 <Welkin> rather than join
10:35:58 <hpc> sometimes
10:36:11 <kaol> Am I the only one who just tries various permutations of fundeps until GHC type checks whenever they are needed?
10:36:18 <hpc> join :: [[a]] -> [a] is pretty easy to reason about
10:36:26 <hpc> join :: Maybe (Maybe a) -> Maybe a, too
10:36:38 <hpc> join for Cont, maybe not
10:36:55 <tfc> i don't know cont
10:37:09 <Welkin> >>= and return form a monoid though
10:37:17 <benzrf> you mean join
10:37:17 <hpc> tfc: Cont is a good type to save for later
10:37:24 <benzrf> join and return form a monoid
10:37:24 <monochrom> <*> is like product (in fact liftA2(,) is exactly product, and <*> could have been derived from liftA2(,)), >>= is like dependent product.
10:37:27 <hpc> (>=>) and return, rather
10:37:34 <hpc> form a category
10:37:35 <benzrf> no, (>=>) and return form a category ;)
10:37:42 <hpc> yeah
10:37:51 <hpc> categories are very similar to monoids though
10:38:06 <benzrf> Welkin: return and join *literally* form a Monoide , though
10:38:20 <Monoide> Monoid*
10:38:29 <benzrf> ahaha
10:38:32 <benzrf> i press tab compulsively
10:38:34 <Monoide> ;P
10:38:34 <benzrf> sorry
10:38:35 <hpc> tfc: if you want to slightly prepare yourself for it, consider expressions of the form ($ x)
10:38:40 <hpc> :t ($ "yes")
10:38:42 <lambdabot> ([Char] -> b) -> b
10:38:46 <hpc> :t ($ "no")
10:38:48 <lambdabot> ([Char] -> b) -> b
10:39:02 <hpc> but don't think too terribly hard about it, there's more important things to learn first
10:39:28 <monochrom> sodium cyanide and potassium monoide
10:40:45 <benzrf> bbl
10:41:23 <tfc> hpz benzrf yeah i am on it. will use haskell a lot in the next months, and every week there's some other concept finally grasped.
10:42:37 <Welkin> lol, hpz
10:42:43 <tfc> oops
10:42:43 <tfc> :D
10:43:13 <tfc> however i love learning all that stuff because it gives me shitloads of ideas how i can write better C++.
10:43:36 <tfc> i actually started learning haskell when i realized that i already to purely functional programming when doing metaprogramming with C++ templates.
10:45:14 <monochrom> @djinn ((((a -> r) -> r) -> r) -> r) -> ((a -> r) -> r)
10:45:14 <lambdabot> f a b = a (\ c -> c b)
10:48:57 <monochrom> This is interesting.
10:49:32 <opqdonut> isn't that just DNE?
10:50:02 <monochrom> What is DNE?
10:50:17 <opqdonut> double negation elimination
10:50:37 <opqdonut> but I misremembered, double negation elimination is nonconstructive, double negation introduction is constructive
10:51:50 <monochrom> This is the second closest to double-negation elimination. This is quadruple-negation eliminate-to-just-double-ion.
10:51:54 <opqdonut> yeah
10:52:11 <monochrom> The first closest is triple-negation eliminate-to-just-one-ion
10:52:16 <opqdonut> yeah
10:52:26 <opqdonut> which you get from DNI by contraposition
10:52:44 <monochrom> I looked at it because hpc mentioned join for Cont r.
11:16:01 <xcmw> I find that 50% of the functions I write are in the form of: function_name x = x & ... <&> ... >>= ... Is there a way to avoid having x?
11:17:12 <Welkin> yes
11:17:16 <Welkin> it's called point-free
11:17:42 <Welkin> compose your functions and drop the x
11:18:12 <Welkin> not sure why you would use & and <&> thought
11:18:19 <Welkin> instead of just using $ and <$>
11:18:36 <Welkin> you can use =<< instead of >>= to fit function composition better
11:18:45 <Welkin> so it is a pipeline from right to left
11:19:19 <xcmw> Welkin: Becuase $ and <$> and =<< are backwards. At least to me
11:19:32 <Welkin> they are not backwords
11:19:37 <Welkin> they are the correct direction
11:19:41 <Welkin> especially for composition
11:19:48 <Welkin> not backwards*
11:22:41 <xcmw> Welkin: How do you compose with monads? I know & maps to >>> but what about when monads are involved?
11:23:38 <Rembane> xcmw: foldM is very good stuff
11:26:42 <xcmw> Rembane: How does foldM help? I am not working with lists
11:27:48 <Welkin> :t foldM
11:27:50 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
11:27:56 <michaelt> :t \f g h -> f >=> return . g >=> h
11:27:58 <lambdabot> Monad m => (a -> m a1) -> (a1 -> b) -> (b -> m c) -> a -> m c
11:28:05 <Welkin> xcmw: it depends on exactly what you are doing
11:28:12 <michaelt> xcmw: like that maybe ^^^
11:28:51 <Welkin> but of course you can use <=< as well
11:28:51 <rickygee> :t >>=
11:28:53 <lambdabot> error: parse error on input ‘>>=’
11:29:04 <michaelt> :t (>>=)
11:29:06 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:31:45 <xcmw> I see that & maps to >>> and that >>= maps to >=>. What does <&> map too? return . ?
11:32:21 <Welkin> what?
11:32:27 <Welkin> & = flip ($)
11:32:59 <Welkin> <&> = flip <$>
11:33:03 <Welkin> those are the definitions
11:34:50 <xcmw> Welkin: I understand it now
11:39:49 <taktoa> does anyone know why aeson encodes Text without properly escaping it to make valid JSON?
11:40:25 <taktoa> encode ("→" :: Text) becomes "\226\134\146"
11:40:54 <taktoa> which is wrong, it should be "\u2192" (I think.)
11:41:25 <taktoa> at the very least, "\226" is certainly not a valid JSON escape sequence
11:44:39 <taktoa> oh, nevermind, I'm being dumb
12:05:33 <jarlg> I have a two processes that can communicate through a handle. What's a good way to transfer a file between them? I could split my file into lines, then send a flag signifying EOF, but I'm sure there's a better solution. Any ideas?
12:05:54 <erisco> is it more kosher to clamp or modulo with toEnum?
12:06:49 <barrucadu> jarlg: You could first send the length of the file in bytes, and then just send the file
12:06:58 <barrucadu> The receiver will know when to stop reading from the handle
12:07:09 <jarlg> barrucadu: Brilliant, thanks! :)
12:13:11 <Liskni_si> jarlg: not sure if it's relevant for your usecase, but if that handle happens to be an AF_UNIX socket, you can send an open file descriptor as is :-)
12:16:09 <jarlg> Liskni_si: I'm not sure -- the handles are created using createProcess (shell <cmd>) { ... }, which I think basically spawns a shell process and handles to communicate with it.
12:16:39 <geekosaur> pipe, except on *bsd
12:16:40 <Liskni_si> jarlg: oh, that's a pipe then
12:16:58 <Liskni_si> geekosaur: is it a unix socket there?
12:17:05 <geekosaur> socketpair, yes
12:41:54 <osa1> does anyone know any benchmarks that compare extensible-effects with transformers?
13:05:32 <erisco> jle`, I am confused on Ord here... there is POrd and SOrd
13:07:08 <erisco> I would expect there to be something to compare two SNats and get the proof that they are LT, GT, or EQ
13:07:42 <erisco> I am not sure how that would look though, i.e. the handling the various cases, and can't figure out if this can be done between POrd and SOrd
13:10:27 <erisco> I guess it would be something like   SNat n -> SNat m -> Decision (Compare n m :~: LT)  and similar for the other cases
13:11:22 <erisco> IsTrue and :~: can't offer anything for branching
13:12:27 <taktoa> I need to convert a ByteString Builder to an Aeson Encoding in code that must work with aeson-0.13, which lacks an unsafeToEncoding method. Encoding is a newtype, so I tried Data.Coerce.coerce, but it complains that the data constructor for Data.ByteString.Builder.Builder is not in scope. Obviously I could just use unsafeCoerce, but is there a better way I can convince GHC these have the runtime representation?
13:14:41 <hpc> there is no aeson-0.13 afaict
13:15:01 <hpc> it goes from 0.11.3.0 to 1.0.0.0
13:16:27 <taktoa> yes I meant 0.11
13:16:45 <erisco> there is of course sCompare but this doesn't tell me anything about the nats I am comparing =\
13:18:17 <erisco> another design could be  SNat n -> SNat m -> (IsTrue (Compare n m :~: LT) -> r) -> (IsTrue (Compare n m :~: EQ) -> r)
13:18:23 <erisco>  -> (IsTrue (Compare n m :~: GT) -> r) -> r
13:18:38 <taktoa> btw is it possible to tell GHC "hey, focus your optimization efforts on this function, because I know it's hot"
13:18:55 <taktoa> I know there's {-# INLINE ... #-} but other than that
13:19:47 <erisco> though I am not sure how to actually implement that
13:20:35 <rockyw> hello
13:23:54 <Squarism> i manage to use "ix" to look up elements in my String indexed map using myMap^.ix "anIndex"
13:24:06 <erisco> oh maybe I am dead wrong about sCompare
13:25:00 <Squarism> ...but it doesnt work for a map with indices of my own type. It actually complains the value (not keys) have no Monoid instance?
13:26:46 <erisco> of course... sCompare gives me Sing (Compare n m)... at least I think... the haddock is screwed up
13:27:15 <erisco> then when I pattern match on SLT, SEQ, or SGT this must give me that Compare n m ~ LT and so on respectively
13:27:42 <erisco> I still have a tough time intuiting this
13:28:43 <ph88> Squarism, ix ? where did you get that ?
13:29:01 <geekosaur> lens
13:29:06 <Squarism> ph88, lens library
13:29:19 <ph88> oh ok, can't help you then :D
13:31:52 <Gurkenglas> Squarism, is the value-type in the string indexed map a monoid?
13:32:16 <Gurkenglas> ix is a traversal, viewing a traversal collects all the results using the result type's monoid instance
13:32:18 <Squarism> Gurkenglas, yeps.. thats a list of int
13:32:39 <Squarism> oh ok
13:33:07 <Gurkenglas> If "anIndex" isn't in the map, you get back []. If you want Nothing in that case, use ^?. If you want to crash in that case, use ^?!
13:36:48 <Profpatsch> Is there something like a data structure explorer?
13:37:10 <Profpatsch> It’s kind of hard exploring deeply nested structures with ghci
13:37:36 <Profpatsch> You have to import all the modules, you have to skip through the module docs and find out about the types &c.
13:37:52 <Profpatsch> I’m thinking of something that dasplays
13:38:10 <Profpatsch> displays the structure folded and I can expand sections I want to see.
13:38:40 <Profpatsch> Maybe with ihaskell?
13:39:58 <Squarism> Gurkenglas, thanks That workd
13:40:12 <Squarism> readability ftw : defender = forces^?!ix (faction_other attackFact)
13:40:28 <taktoa> oh, apparently aeson-0.11 does export unsafeToEncoding, it's just in Data.Aeson.Types instead of Data.Aeson.Encoding.Internal
13:41:39 <AWizzArd> In one forum comment I saw this:   (n:)   – is this some kind of allowed list destructuring?
13:41:58 <AWizzArd> More context:   allWins (n:ns) = concatMap (map (n:) . allWins) $ take n $ tails ns
13:42:09 <kubbe> Hi! i am a beginner in the world of Haskell, so I have a question about the ' (single quote). Lets say that I have a function myFunc.. What does it mean when I write myFunc'? Is there a general rule regarding that?
13:43:49 <erisco> it is just another character you can use in your identifers
13:44:47 <kubbe> Oh, alright. I have tried to find something more about that since that seems to be very common in examples of sort. Read something about it usually is an accumulator(?), but im not sure. Thats why I asked! Thanks though
13:44:55 <erisco> so you might use it to mean "after some transformation" or inverse or strict or something like that
13:47:04 <barrucadu> Or in case of function names, foo' might be a slightly different version of foo
13:47:33 <erisco> or the strict version
13:48:04 <kubbe> what does "strict version" mean?
13:48:37 <erisco> it means it evaluates arguments before application
13:48:56 <kubbe> oh yeah, alright. thanks!
13:49:05 <erisco> at least somewhere, anyways, like in foldl'
13:50:05 <kubbe> i saw that example in a forum a minutes ago. Didnt really get what foldl and foldl' does, though. I think i will get it soon enough
13:54:02 <ph88> (try char '\\' >> char '\\') <|> otherCharsWithoutBackslash   is this the right way to say that i have a string where backslashes must be escaped by themselves in a parser ?
13:56:00 <erisco> I don't think so. What about  char '\\' >> char '\\' <|> otherCharsWithoutBackslash ?
13:57:44 <ph88> erisco, then  char '\\' always consume 1 character even when it fails, no ?
13:58:18 <erisco> no
13:58:36 <ph88> oh
13:58:38 <erisco> char 'a' <|> char 'b' <|> char 'c'  this recognises a, b, or c
13:58:46 <ph88> oh ye ok
13:59:21 <ph88> so it's only with strings that consume input ?
13:59:22 <myme> I have an IO action `a -> IO (Either String a)` and been wondering how you could write a fold of a list or traversible of these actions, terminating at the first `Left String`.
13:59:32 <erisco> no
13:59:49 <erisco> it depends on the parser, but most are lookahead 1
13:59:53 <myme> My intuition's telling me this can be solved in a more smooth way, but I'm so rusty I can't really see how atm.
13:59:55 <ph88> aah ok
13:59:58 <ph88> i use megaparsec
14:00:17 <erisco> this means that when you have alternation, i.e. a <|> b, it goes with a if the next character matches and goes with b otherwise
14:00:35 <ph88> ok thx erisco 
14:00:57 <myme> (should've mentioned the `a`s are passed along to the consequtive action)
14:01:29 <erisco> so, depending on how the string parser is setup, string "abe" <|> string "ace" may fail to parse "ace"
14:02:06 <erisco> if it is implemented as  char 'a' >> char 'b' >> char 'c' <|> char 'a' >> char 'c' >> char 'e'
14:02:48 <ph88> i use megaparsec which is a variation of parsec .. not sure what it does under the hood
14:04:52 <geekosaur> you need to use `try` on that, pretty sure
14:05:13 <geekosaur> otherwise on seeing "ace" the `string "abe"` parser will consume the "a" and fail
14:05:21 <geekosaur> and then the other starts at the "b:
14:05:23 <ph88> erisco, i implemented it like this atm  https://paste.fedoraproject.org/546569/86245891/
14:06:40 <ph88> geekosaur, i think that's what erisco meant when he said that the parser   string "abe" <|> string "ace"  may fail to parse "ace"
14:06:51 <geekosaur> yes
14:07:10 <ph88> ok but in my case i only have a parser of a single character
14:07:21 <kubbe> what does "Monad" mean? i have tried looking it up but I cant really find an "easy" answer
14:07:39 <erisco> well that is because there are no easy answers, heh
14:07:41 <ph88> see line 41, line 57 and line 72
14:07:58 <ph88> oh oh i think i made a mistake on the 2nd and 3rd parser :/
14:08:00 <barrucadu> It's an abstraction that happens to be useful in many contexts
14:08:05 <erisco> kubbe, http://learnyouahaskell.com/a-fistful-of-monads
14:08:20 <kubbe> thank you!
14:08:43 <kubbe> oh, this is an entire guide with everything! thanks erisco
14:08:47 <ph88> kubbe, have you seen this http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html  ??
14:10:16 <kubbe> Nope! I'll read that one aswell.  thank you mate ph88
14:10:20 <ph88> np
14:10:22 <barrucadu> There's also https://wiki.haskell.org/Typeclassopedia
14:10:47 <geekosaur> @quote geekosaur _Category
14:10:47 <lambdabot> No quotes match. That's something I cannot allow to happen.
14:10:48 <erisco> I'm not sure their "Some Magic Happens" bubble is all that enlightening :P
14:11:06 <geekosaur> blegh. (it didn;t really belong in there anyway)
14:11:15 <ph88> kubbe, which other programming languages do you know? it might be possible to explain the monad in the language you are already familiar with
14:11:19 <geekosaur> 2016 Nov 12 06:21:11 <geekosaur>	so fwiw it looks like he introduced it in _Category Theory for the Working Mathematician_, and his terminology note doesn't explain why he picked "monad", but perhaps can be understood to imply a sort of cross between "monoid" and "triad"
14:11:23 <mniip> monads are just monoids in the endofunctor monoidal category
14:11:31 <geekosaur> dug that out back then ("he" is Mac Lane)
14:11:34 <mniip> :)
14:11:37 <kubbe> erisco, hahah it is good enough for me atm.
14:11:57 <geekosaur> oh
14:11:57 <kubbe> ph88, html css javascript and (some) c++
14:12:07 <geekosaur> @quote geekosaur _Categories
14:12:07 <lambdabot> geekosaur says: so fwiw it looks like [Mac Lane] introduced it in _Categories for the Working Mathematician_, and his terminology note doesn't explain why he picked "monad", but perhaps can be
14:12:07 <lambdabot> understood to imply a sort of cross between "monoid" and "triad". (p.138 at http://www.maths.ed.ac.uk/~aar/papers/maclanecat.pdf)
14:12:14 <mniip> kubbe, you familiar with C++ template metaprogramming?
14:12:49 <geekosaur> probably makes more sense as a @where...
14:12:55 <kubbe> mniip, nope! Cant say I am
14:13:06 <mniip> well damn, that would've been a decent explanation
14:13:11 <ph88> kubbe, if you google like  javacript monad  you will find a few things as well
14:13:31 <maerwald> oh god :D
14:13:42 <mniip> javascript monad?
14:13:48 <kubbe> alrighty then, im on it. thanks guys
14:13:51 <maerwald> that's like googling "haskell duck typing"
14:13:51 <mniip> what's that, State (Map Dynamic Dynamic) ?
14:14:08 <ph88> Data.Dynamic no ? :p
14:14:10 <systemfault> "Promise" in JavaScript is very close to be a monad.
14:14:12 <barrucadu> I have been doing terrible things with Typeable and Dynamic lately...
14:14:17 <geekosaur> acme-php :p
14:14:29 <kubbe> mniip, haha i'll get back to you when I know that aswell
14:14:31 <ph88> barrucadu, tell us more :D
14:14:47 <erisco> it is except that it is usually used for side effects
14:15:23 <barrucadu> ph88: Have you come across QuickSpec? It's a little tool which takes a collection of functions and values, and discovers properties that they satisfy, by generating and testing expressions.
14:16:00 <barrucadu> ph88: I'm trying to do something similar for concurrent data structures, which means I'm generating monadic expressions, and it's all very dynamically typed as I try to make everything fit
14:16:15 <mniip> kubbe, one of the main ideas is that, like, in C++, while std::list<int> is a concrete type, std::list is not, it is a type constructor, and it is parameterizable with whatever type you want contained in the list
14:17:04 <kubbe> mniip, hmm alright. I can understand that
14:17:05 <ph88> barrucadu, have you come across hipspec? it's a little tool which takes your quickspec output and formally verifies it with a theorem prover
14:17:29 <barrucadu> ph88: I've seen it, but not used it. It does look pretty cool.
14:18:35 <mniip> kubbe, perhaps we could pop into #haskell-beginners where it's less noisy
14:18:37 <ph88> barrucadu, i've watched a video online the other day which was very interesting .. it was about how theorem proving meets concurrent designs .. the guy eventually came up with a language in which you can define a lot of stuff for that
14:18:51 <ph88> shall i find it for you ?
14:19:03 <kubbe> alright, sounds like a good idea. didnt know that channel existed! cya there
14:19:20 <barrucadu> ph88: If it wouldn't be inconvenient
14:27:02 <hexagoxel> myme: can only think of EitherT + iterateM_, but that is not very pretty.
14:27:53 <myme> hexagoxel: Been looking at Control.Monad.Trans.Either from `either`.
14:27:59 <myme> Yes.
14:28:58 <myme> The folding may not be that cruical though. The number of steps is deterministic and few. It's basically for writing some tests more pretty than nesting `case`s or something similar.
14:35:20 <ph88> barrucadu, https://www.youtube.com/watch?v=R2Aa4PivG0g related is this language which followed from the stuff this guy talks about http://bloom-lang.net/
14:39:08 <barrucadu> ph88: Thanks, I'll check it out
14:47:43 <erisco> would be so nice if singleton errors were legible
14:47:49 <erisco> instead of being TFHelper_3489463
14:48:35 <erisco> we're getting into error novel territory
14:49:27 <biglambda> How can I generate c header files when I’m using stack?
14:49:49 <biglambda> Or just plain cabal for that matter.
14:56:31 <dmj`> biglambda: not sure you can
14:57:28 <biglambda> Ok, I’m trying to follow tutorials for calling a haskell program from an XCode project and I haven’t figured out how to make it work.
14:57:59 <biglambda> This tutorial: https://wiki.haskell.org/GHC/Using_the_FFI#Calling_Haskell_from_C
14:58:26 <biglambda> And this one: https://wiki.haskell.org/Using_Haskell_in_an_Xcode_Cocoa_project
14:58:43 <biglambda> So far no luck.
15:16:11 <erisco> found a fun parsing quirk...
15:19:01 <erisco> you can write  | x <- y :: t = m  on term guards but not case or multi-way if guards
15:19:15 <Profpatsch> Hm, I wonder how I can get a complete representation of a data type with TypeReps of the fields and the corresponding values?
15:19:20 <erisco> in that case it has to be | x <- (y :: t) = m
15:19:36 <erisco> well, I mean | x <- (y :: t) -> m  but same idea
15:19:36 <Profpatsch> And then maybe serialize that somehow?
15:20:21 <Profpatsch> Or can I get the values for a Data.Data.DataType?
15:21:48 <drostie> That just sounds like Thundercats at that point.
15:21:58 <drostie> "Data, Data, DataType, ho~~~~!"
15:31:05 <Profpatsch> Data is a kind of overloaded module name, yes.
15:31:23 <Profpatsch> Also, it’s funny to write “kind of” in #haskell
15:31:42 <Welkin> sort of kind of
15:33:18 <Profpatsch> oooooohhhhh
15:33:46 <Profpatsch> *insert the corresponding gif with black people here*
15:33:52 <Welkin> o.O
15:36:39 <Profpatsch> Welkin: https://m.popkey.co/732f72/RkGmJ.gif
15:36:41 <Profpatsch> found it
15:38:08 <Profpatsch> I think that’s the best version here: https://i.imgur.com/YKZA6US.gif
15:39:17 <Profpatsch> I just realized I probably want GHC.Generics for what I’m trying.
15:39:35 <Profpatsch> rekt.gif
15:42:24 <erisco> this stuff is starting to make a wee bit of sense so maybe half a year more and I will be competent
15:42:41 <benzrf> can someone help me figure out why im getting the error "cannot find normal object file ‘ModuleName.dyn_o’ while linking an interpreted expression" from ihaskell when i try to load source files
15:42:52 <benzrf> er, when i try to evaluate expressions that reference things from source files
15:50:36 <benzrf> q_q
15:53:08 <Gurkenglas> benzrf, this might help? https://github.com/search?q=%22cannot+find+normal+object+file%22+%22while+linking+an+interpreted+expression%22&type=Code&utf8=%E2%9C%93
15:54:08 <benzrf> We could not perform this search
15:54:11 <benzrf> :p
15:54:12 <geekosaur> benzrf, sounds like ihaskell was built for profiling and therefore is linked to a profiling ghc-api
15:54:43 <benzrf> geekosaur: i dont think so, though.... i'm using Nix, and i think profiling is off by default :?
15:55:16 <Gurkenglas> Wat but it just worked for me and now it doesnt anymore
15:56:37 <Gurkenglas> Try clicking through the four language options at the bottom left? That seems to bring back up disjunct portions of the 37 results
15:56:55 <Ptival> is there a type class capturing the existence of a lens?
15:57:12 <benzrf> Ptival: depends on what you mean, thats a pretty vague question
15:57:22 <benzrf> Gurkenglas:  not working - which repo is this meant to be searching in?
15:57:58 <benzrf> .......i got rate limited
15:57:59 <Gurkenglas> I did not provide a repo. And now it has also stopped working for the literate haskell option, but not yet for the haskell option - nevermind, now that has too
15:58:01 <benzrf> wtf
15:58:21 <Gurkenglas> Gah, here have the first result from my original search https://github.com/timthelion/fenfire/blob/766167d8c5b6829d7df43efdcc67cbbe6fe8db79/RESURECTION-NOTES.md
15:58:59 <Ptival> benzrf: I'm doing a "Trees that Grow" kind of encoding where I have a type with constructors | C1 (FC1 a) | C2 (FC2 a) | ...
15:59:37 <Ptival> and I wonder whether I can write a generic function that writes an Int within each (FCn a), assuming the respective type has an Int slot
16:00:05 <benzrf> :t makeClassy
16:00:09 <lambdabot> Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Lib.DecsQ
16:00:12 <benzrf> hmm
16:00:33 <Gurkenglas> You can just define a "Traversal' YourTree a" and apply that when a has Int
16:00:35 <Profpatsch> Gurkenglas: fenfire looks so cool!
16:00:45 <Profpatsch> I’ve been wanting to have something like that for ages.
16:01:10 <Profpatsch> That is: Just jot down various RDF triples with relations I can define myself.
16:01:20 <Profpatsch> And then make sense of them later when I need to.
16:01:38 <Gurkenglas> I literally took the first result from some github search - maybe you should just start randomly browsing through github haskell projects :D
16:02:12 <Ptival> Gurkenglas: I'll look into Traversal, don't really know them, what do you mean by "a has Int" though?
16:02:16 <benzrf> Gurkenglas: hmm....... but my error is complaining about no dyn_o, not no p_o
16:02:22 <Gurkenglas> (Or you were the one person idling in this channel that happened to be interested in this result, and are unlikely to find another hit quickly - though if the whole thread were watching, someone else would probably soon be interested in something)
16:03:20 <Gurkenglas> benzrf, try googling your exact error message
16:05:44 <benzrf> im not using template haskell at all :?
16:05:48 <benzrf> and all the results seem to be about it
16:05:56 <benzrf> does ihaskell use TH internally?
16:06:31 <Tuplanolla> That doesn't sound TH related, benzrf. The `dyn` refers to dynamically linked libraries.
16:06:49 <benzrf> Tuplanolla: all the results seem to be about TH
16:07:01 <geekosaur> oh, right, I misread that
16:07:26 <geekosaur> anyway, the linking factor there is that TH and ghc-api interpreted expressions (and ghci) all use the bytecode backend
16:07:32 <benzrf> aha
16:07:44 <geekosaur> and it's the bytecode backend's linker that is failing to load a module
16:07:46 <benzrf> more info:
16:08:03 <benzrf> i am 100% able to import and eval stuff from packages, e.g. import Data.MultiSet
16:08:17 <benzrf> the error is when i try to :load a .hs 
16:08:31 <benzrf> furthermore, it loads fine and i can do :t and so on - it only errors when i try to eval an expr
16:08:42 <benzrf> and only if the expr references a definition from the file i loaded
16:08:58 <benzrf> i can confirm that there are no dyn_o files in the dir; only .o
16:09:06 <geekosaur> hm.
16:09:17 <benzrf> i am using Nix to set up my environment, for what thats worth
16:09:35 <benzrf> ghc 7.10.3
16:10:44 <Profpatsch> What was the ihaskell alternative that came up somewhere last month?
16:10:46 <jle`> erisco: did your question already get answered
16:10:59 <erisco> jle`, yeah I figured it out
16:11:02 <jle`> Profpatsch: there's haskell-do that i just heard about last week, if that's waht you mean
16:11:05 <jle`> erisco: ok neat :)
16:11:22 <erisco> working out the Enum instance for BoundedNat now
16:11:29 <geekosaur> actually I had thought ihaskell had been broken by ipython->jupyter and nobody had fixed it...
16:11:49 <geekosaur> (it's not just a rename, they rewoirked the impl in a way that broke ihaskell's assumptions)
16:11:56 <jle`> ouch
16:11:58 <erisco> getting close... just one last proof that needs to get in though I am not sure yet where it is coming from
16:12:43 <benzrf> oh!
16:12:54 <benzrf> id be happy to use something else - i just didnt know there were any alternatives
16:12:55 <Profpatsch> jle`: No, there was one before that.
16:14:37 <geekosaur> ok, looking at the repo, they actually did fix that to at least some extent
16:15:44 <Profpatsch> I tried setting up ihaskell a few hours back, but some deps don’t compile on 8.x
16:16:06 <benzrf> ok, what are you guys talking about?
16:16:12 <Profpatsch> An apparently the nixos module is slightly broken so it ignores the different haskell package set I gave it.
16:16:19 <benzrf> if theres a nicer, newer alternative, id be happy to use it
16:16:21 <erisco> nailed it :D
16:16:38 <erisco> jle`, this stuff is quite fun... always the sort of thing I wanted to get into
16:16:53 <Profpatsch> benzrf: Nothing better than ihaskell right now I’m afraid.
16:17:19 <benzrf> :(
16:17:40 <jle`> erisco: i know how you feel haha
16:17:45 <jle`> have you read the idris book yet?
16:18:01 <benzrf> so why wouldnt it be generating dyn_o files if it expects them to be there?
16:18:04 <benzrf> i am so confused q_q
16:18:05 <Profpatsch> Right now I’d just like a thing that maps deep data structures to an expandable gui element
16:18:18 <erisco> no. I have tinkered with Idris briefly but became confused rather quickly. I feel a bit better here because at least I know Haskell
16:18:20 <Profpatsch> benzrf: There are a few approaches right now, like https://github.com/theam/haskell-do
16:18:31 <Profpatsch> And another project I forgot the name of.
16:18:49 <Profpatsch> Maybe I starred it (but probably not)
16:19:33 <Profpatsch> yeah, no, no star
16:20:04 <erisco> jle`, > [minBound..maxBound] :: [BoundedNat 'Z ('S ('S 'Z))]    [Range SZ :: Range Z (S (S Z)),Range (SS SZ) :: Range Z (S (S Z))]   :D
16:21:05 <erisco> erm, that sound read "BoundedNat" not "Range" ... I changed the name but not in the Show instance heh
16:21:40 <EvanR> is BoundedNat supposed to be like Fin
16:21:56 <erisco> I don't know what Fin is
16:22:17 <EvanR> Fin n is the type of numbers from zero to n-1
16:22:28 <erisco> ah, so bounded above
16:22:34 <erisco> well this has a min bound too so it is more general
16:23:24 <EvanR> yes you could implement a type with configurable minbound if you had Fin
16:23:31 <jle`> erisco: :D
16:24:13 <jle`> erisco: ah yeah i did assume that you knew about fin when you mentioned bounded earlier
16:24:14 <zipper> Hey, how do I escape all the '\' in a string?
16:24:21 <jle`> Fin is nice cause it has a nice inductive definition
16:24:25 <zipper> Like prepend a '\'
16:24:31 <jle`> so you don't have to worry about <= and type families like that
16:24:36 <zipper> Kinda like intersperse
16:24:37 <jle`> zipper: \\ ?
16:24:43 <jle`> oh, all of them?
16:24:44 <zipper> jle`: Yes
16:24:57 <jle`> erisco: http://hackage.haskell.org/package/type-combinators-0.2.4.3/docs/Data-Type-Fin.html
16:25:02 <zipper> Yes escape all the '\' in s a string :)
16:25:25 <erisco> no I was not aware. thanks for the link
16:25:35 <jle`> no problem :)
16:26:30 <jle`> yeah, for say, 'Fin (S (S Z))', there are two inhabitants: 'FZ' and 'FS FZ'
16:26:53 <jle`> and for the type Fin (S (S (S Z)), there are three inhabitants: 'FZ', 'FS (FS FZ)', and 'FS (FS (FS FZ))'
16:26:58 <jle`> um
16:27:05 <jle`> that should have been FZ, FS FZ, and FS (FS FZ)
16:27:23 <erisco> 1, 2, skip a few
16:27:52 <benzrf> ok i manually compiled the files with -dynamic-too and now it works
16:27:53 <benzrf> wtf?
16:28:07 <zipper> escape functions are no help :(
16:28:36 <EvanR> replace "\\" "\\\\"
16:28:56 <EvanR> you could also try
16:29:06 <EvanR> > show "a\\bc\\\\d"
16:29:10 <lambdabot>  "\"a\\\\bc\\\\\\\\d\""
16:30:07 <vektorweg1> +1
16:30:24 <erisco> surprised not to see the Bounded and Enum instances on Fin
16:30:33 <hpc> > fix show
16:30:36 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
16:31:09 <erisco> this is my amateurish mess for Enum on BoundedNat http://lpaste.net/352091
16:31:52 <benzrf> > fix (error "broken")
16:31:54 <lambdabot>  *Exception: broken
16:31:55 <monochrom> I hate escaping.
16:31:59 <benzrf> oops
16:32:01 <benzrf> > fix error
16:32:03 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
16:32:08 <vektorweg1> loooool
16:33:11 <Rembane> Hilarious!
16:33:40 <jle`> erisco: submit a pr :)
16:34:20 <erisco> climb increments the natural until either i is zero or the successor is equal to the maxBound
16:34:27 <hpc> > take 10 . map length . split (oneOf "\"") $ (fix show)
16:34:29 <lambdabot>  [0,1,1,1,3,1,7,1,15,1]
16:34:34 <erisco> took me a while to cobble it together
16:35:03 <zipper> For some reason I can't write an echo function that escapes strings and echoes the exact same thing it got.
16:35:05 <hpc> erp
16:35:13 <hpc> > take 10 . map length . split (dropDelims $ oneOf "\"") $ (fix show)
16:35:16 <lambdabot>  [0,1,3,7,15,31,63,127,255,511]
16:35:17 <zipper> Well I can kinda but it fails quickcheck tests
16:35:29 <zipper> For a random string with stuff like \f
16:35:31 <zipper> SMH
16:35:56 <zipper> I can't make it echo x == x in quickcheck
16:35:58 <zipper> hmmmm
16:40:26 <benzrf> i mean... you shouldnt expect that to hold
16:40:48 <benzrf> the whole point is that you want back the escaped version, not the original string, right?
16:42:53 <erisco> jle`, do you usually look for inductive definitions before propositional ones?
16:43:56 <jle`> yes
16:44:16 <erisco> these are usually more concise in use?
16:47:37 <benzrf> inductive definitions vs propositional definitions?
16:47:40 <benzrf> whats the distinction
16:49:32 <erisco> for example you can use Fin n or you can use (Z :<= x) ~ 'True, (x :< n) ~ 'True
16:50:16 <erisco> Fin defines how to construct all the naturals in the finite range whereas the proposition says what is true about naturals in the range
16:51:41 <benzrf> ah
16:52:34 <erisco> or in use it is the difference between showing how to construct the natural and showing that your natural satisfies the proposition
16:52:39 <raynold> ahh it's a wonderful day
16:57:14 <erisco> raynold, night, but who's looking
16:57:59 <TRManderson> Anyone here run into -fPIC issues on Ubuntu 16.04?
16:58:25 <TRManderson> I can compile plain Haskell fine, I'm just struggling to get the shared object I'm trying to export to compile without linker errors
17:00:07 <TRManderson> I've tried it with stack-installed GHC 7 and 8, and nix-installed GHC 8
17:01:01 <jle`> erisco: i think you can exploit the structure when using it so it's a lot simpler in certain use cases
17:01:09 <jle`> but, there's probably a lot similar
17:01:33 <jle`> in your type, your proofs will be at the whim of the :<= / :< type families
17:01:49 <jle`> for Fin, the proofs don't have to worry about the type families, they're just directly structural
17:02:16 <erisco> yes
17:02:25 <jle`> but ultimately if the :<= type family is defined inductively, then a lot of the overal sturcture of your proofs will be the same.  just a difference in syntax and implementation
17:02:46 <erisco> is there something in Idris which corresponds to the type family approach of :<= and :< ? I've only seen inductive
17:03:28 <jle`> well you can do definitional equality in idris too
17:03:31 <erisco> well I only looked under the hood so far, not sure where the bottom in
17:03:36 <jle`> <= and < will be just normal functions
17:03:41 <jle`> and you can use them at the type level
17:03:52 <EvanR> if its a type family, that would correspond to a ... type family, that is a function of type MyIndex -> Type
17:04:04 <jle`> in idris you'd define <= and < for normal nat's, and then you can use them for type level nats too
17:04:09 <jle`> because type level nats are just normal nats
17:04:20 <erisco> EvanR, I suppose so :)
17:04:35 <EvanR> if it really should be a regular value function, but cant be in haskell, then it should be a regular value function in idris
17:04:57 <EvanR> nat arithmetic has no crazy type level shenanigans in idris
17:05:04 <erisco> well I'd expect something like Leq instead of :<=
17:05:11 <EvanR> its called LTE
17:05:15 <erisco> but then if you want theorems isn't that were :<= comes in?
17:05:26 <jle`> so you'd have Bounded :: (Z <= x = True) -> (x < n == True) -> x -> Bounded n
17:05:35 <jle`> s/==/=
17:05:51 <EvanR> LTEZero : LTE 0 right, LTESucc : LTE left right -> LTE (S left) (S right)
17:05:57 <erisco> or maybe not, I guess you'd just say  Leq a b -> Leq a (S b)  and so on
17:06:10 <jle`> but even better would be Bounded :: (Z <= x) -> (x < n) -> x -> Bounded n
17:06:22 <jle`> instead of definitional equality (~ True)
17:06:34 <jle`> you'd have actual witnesses for LTE/LE
17:06:39 <EvanR> MkBetween : LTE a n -> LTE b n -> Between a b n
17:06:40 <jle`> which is what that one module you showed me had
17:06:56 <jle`> but in the end, the two types are sort of the same
17:07:19 <jle`> constructing a witness for (x, x < n), and constructing a Fin n, would be more or less the same
17:07:21 <jle`> you'd do them both inductively
17:07:33 <EvanR> instead of separate types for numbers that are within a range or non-zero, you can just have extra predicates defined on numbers
17:07:46 <EvanR> even, prime, whatever
17:08:06 <EvanR> then you only have to implement arithmetic once
17:08:25 <EvanR> Fin on the other hand doesnt have arithmetic, youd use it for a set of finite indices
17:08:41 <EvanR> it serves the same role as finite sets
17:08:44 <EvanR> rather than numbers
17:08:49 <erisco> jle`, well it seems to me like we could do that in Haskell with Leq and a Lneq
17:08:59 <jle`> yeah, it's the same thing
17:09:03 <jle`> from that module you showed, http://hackage.haskell.org/package/type-natural-0.7.1.2/docs/Data-Type-Natural.html#t:Leq
17:09:41 <jle`> `exists x. Leq x n` and `Fin n` should be structurally the same
17:09:53 <jle`> *Lneq, but yeah
17:10:39 <jle`> (your BoundedAbove type could have also been exists x. Lneq x n, yeah)
17:11:01 <jle`> all different ways of saying the same thing, neat right
17:11:13 <jle`> the '~ True' way would probably be my least favorite, heh
17:11:47 <jle`> that is, ~ True + type family.  but i think working with all of them should be the same
17:11:54 <EvanR> Bools suck!
17:11:56 <erisco> but then what about the runtime considerations
17:12:08 <jle`> er, i mean, the same "proof tree"/proof structure.  different mechanics of working with them
17:12:14 <jle`> time to benchmark :o
17:12:17 <erisco> yes, ~ 'True feels a lot like == True
17:12:22 <EvanR> erisco: ideally proofs dont happen at runtime?
17:12:40 <EvanR> types only exist at compile time
17:12:42 <erisco> yes but if we're carrying witnesses around in our data that means something
17:12:47 <jle`> haskell carries around most proofs like this at runtime
17:12:51 <jle`> idris erases a lot of them
17:12:51 <EvanR> gross
17:13:06 <jle`> the proofs have to be carried because in general, types are erased
17:13:12 <jle`> so the proofs act as witnesses to the types and their properties
17:13:25 <jle`> that 'in general' should have been at the beginning of the sentence
17:13:45 <EvanR> conceptually, you proved what you need to prove, and the code can run unchecked
17:14:00 <EvanR> but i know in haskell you use typeclasses to convert types to values at runtime
17:14:52 <erisco> hm, well I just don't know enough about the compiler and runtime
17:15:04 <erisco> it is similar to the newtype vs data options yesterday
17:21:28 <spitfireee> win 5$ only for register guys! NO JOKE - > https://www.dailyrewards.com/?r=ref362870&s=7
17:22:17 <Tuplanolla> Too bad all the register guys are over at ##asm.
17:52:04 <dwhitney> Hello - question for you all: anybody know if there is a flag I can pass to stack or cabals or ghc to get the list of files it's going to compile (assuming these use incremental compiling)
17:52:09 <dwhitney> TIA
18:41:07 <noan> How would most people organise their project with respect to... lets say I have /src/db/Schema.hs When it comes to defining a lot of the queries that will operate on the different entities... maybe a /queries folder with one file per entity that defines its related queries?
18:41:33 <ph88> seems like a good idea to me
18:41:33 <noan> Like one to lookup and validate a session token, for instance, returning, maybe, a user.
18:48:13 <erisco> oh joy... both Type.Family.Nat and Data.Type.Natural
18:49:37 <noan> :D
18:54:06 * noan is having a hard time wrapping their head around defining queries without making them stupid-big and accepting a db parameter
18:54:38 <noan> Why is my brain unable to comprehend how to structure these so they just compose later the DB provided only when a query actually needs to run?
18:54:57 <noan> Damn you 4am! (This is all persistent stuff=
18:55:45 <EvanR> well, what is making you have to have a db
18:56:06 <erisco> I was going to say something but figured EvanR would speak up :P
18:56:42 <noan> I think I'm just braindead right now and not yet understanding persistent mostly. I'm not sure what type I need to construct to be able to later be like Okay you servant handler, here's a handler or something to the DB lookup you need. You know what to do.
18:56:48 <noan> Or something. Maybe I should just sleep
18:56:52 <EvanR> i havent used persistent so i might not have any clue 
18:58:26 <erisco> I'm usually for express and interpret
18:58:41 <erisco> so I just say things like "all blog posts" and I interpret this later as a database query
18:59:32 <EvanR> right, but since its persistent i wonder if theres something already setup for that
18:59:39 <erisco> could be, don't know
19:00:51 <Welkin> something set up for what in Persistent?
19:01:06 <Welkin> you could always check the yesod book
19:01:18 <erisco> when you do things this way they always decouple, but it takes work to define and implement
19:01:20 <Welkin> Persistent has lots of secrets
19:02:15 <erisco> when you're working with the data you're probably just interested in the data itself and not making database queries
19:02:45 <erisco> so "display all blog posts" rather than "open database connection, prepare query, execute query, hydrate blog posts, display blog posts, close database connection"
19:03:22 <EvanR> repeat ad infinitum
19:03:26 <erisco> what you're really trying to do gets lost in the noise of making it happen
19:03:30 <Welkin> that is the pooint of an ORM
19:05:54 <noan> Right now I'm to wrap my head around essentially how I can go from String -> (something like) Handler Maybe User
19:06:11 <noan> https://github.com/parsonsmatt/servant-persistent/blob/master/src/Config.hs
19:06:20 <noan> Found an example of someone putting servant and persistent together though.
19:06:39 <noan> This looks like it may be what I needed.
19:07:03 <Welkin> you write a runDB function
19:07:10 <Welkin> you can take cues form yesod in that regard
19:07:15 <Welkin> from*
19:09:08 <noan> https://github.com/parsonsmatt/servant-persistent/blob/98479a423609794ffa9b668b0ae13ae9a57be18e/src/Models.hs
19:09:09 <noan> fancy
19:09:35 <noan> okay, I'll learn my way around this example Matt wrote. Looks fairly well thought out from what I can tell
19:10:20 <Welkin> yes
19:10:29 <Welkin> he didn't do anything but copy yesod
19:13:26 <Welkin> damn you purescript, confusing me with your *slightly* different syntax that makes me think I am reading haskell
19:15:43 <erisco> solve for one program which is valid in three languages and has distinct output
19:17:39 <erisco> is singleton-esque supposed to mean singletons but but the singletons package?
19:20:46 <Welkin> purescript even inherited syntax mistakes from haskell o.o
19:20:56 <Welkin> which leads to a big "wtf?" moment
19:21:07 <Welkin> :: instead of : for "has type"
19:21:14 <Welkin> at least idris fixed that...
19:21:29 <erisco> is that really a mistake?
19:21:34 <Welkin> yes
19:21:58 <Welkin> :: is cons 
19:22:16 <erisco> seems more a style preference to me
19:22:27 <Welkin> the only reason they were swapped for haskell was because someone had the idea that "we'll be writing list cons more often that type signatures"
19:22:30 <Welkin> which is obviously wrong
19:25:37 <erisco> why do I feel like I am going to end up with a third library that does all these things
19:25:45 <erisco> writing one, that is
19:26:01 <erisco> how else do you resolve the fragmentation
19:27:33 <erisco> somehow Data.Type.Fin ended up with UndecidableInstances
19:27:42 <erisco> this is just not necessary -.-
19:34:04 <erisco> jle`, certainly one advantage of uses contexts is they are supplied implicitly
19:34:16 <erisco> parameters on the other hand are always going to be explicit
19:46:53 <Welkin> this is a good article so far http://www.parsonsmatt.org/2016/07/14/rank_n_classy_limited_effects.html
19:47:43 <markasoftware> why don't more major corporations use Yesod for servers if it's so fast?
19:47:47 <markasoftware> couldn't it save them a lot of money?
19:48:05 <Welkin> markasoftware: you mean Warp
19:48:09 <Welkin> yesod is not the server
19:48:12 <markasoftware> yep
19:48:17 <markasoftware> still new to yesod
19:48:21 <markasoftware> and warp
19:48:29 <Welkin> it's because languages and tools are not chosen based on logic alone
19:48:52 <Welkin> sure, it is one of the fastest severs around beside running on bare nginx
19:49:05 <Welkin> but companies are bureaucratic organizations
19:50:03 <Welkin> why do so many companies still run on php?
19:50:12 <Welkin> obviously not for technical reasons
19:51:13 <markasoftware> makes sense, lot easier to find php devs than haskell
19:51:32 <Welkin> (but most php devs will be terrible)
19:51:45 <Welkin> and almost all haskell devs are going to be the best
19:51:57 <Welkin> so it's not a clear tradeoff
19:52:09 <Welkin> bus then again, business people make the decisions
19:52:12 <Welkin> but*
19:54:20 <Sinestro> With the expression table parser in `parsers`, does anyone know how to make it fail when an unknown operator is used?
19:54:50 <Welkin> what parser?
19:55:31 <Sinestro> trifecta, underneath
19:57:44 <Welkin> Sinestro: is this what you are looking for?
19:57:45 <Welkin> https://hackage.haskell.org/package/parsers-0.12.4/docs/Text-Parser-Combinators.html#v:unexpected
19:58:27 <Sinestro> No, I knew about that, the problem is that I can't see a way to trap operators that aren't in the table
19:59:21 <Welkin> https://hackage.haskell.org/package/trifecta-1.6.2.1/docs/Text-Trifecta-Result.html#v:failed
19:59:30 <Welkin> that could work?
20:00:07 <Welkin> I have't used trifecta, so I'm not too familiar with it
20:02:35 <Sinestro> That'd be ugly, but it's the best thing I see right now
20:02:36 <dramforever> Q: Is there a good tutorial on 'syntax transformations' using Template Haskell?
20:02:46 <Sinestro> Gonna step away from that for now
20:02:57 <Sinestro> dramforever: define transformations?
20:03:04 <dramforever> By syntax transformation I mean something like $(transform [| user code |])
20:03:21 <dramforever> And by 
20:03:52 <dramforever> And by 'good tutorial' I mean a guide through best practices, etc
20:04:01 <Welkin> http://research.microsoft.com/en-us/um/people/simonpj/papers/meta-haskell/meta-haskell.pdf
20:04:07 <Welkin> there is one of the papers on templayte haskell by spj
20:04:40 <Welkin> all of his papers are very easy to read and written in a tutorial style
20:04:42 <dramforever> Tutorials I find are usually for emitting Haskell code
20:05:03 <dramforever> Hmm, SPJ's tutorial is definitely going to have something I need
20:05:28 <Welkin> there us also the ghc user guide https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#template-haskell
20:05:35 <Welkin> is*
20:06:01 <mniip> so um
20:06:07 <mniip> does anyone have an example of a weak monad?
20:06:20 <Welkin> mniip: what is that?
20:06:35 <mniip> a monad that is not strong?
20:06:44 <Welkin> never heard of it
20:06:53 <dramforever> something something Category Theory something something
20:06:59 <Welkin> if it satisfies the monad laws, it's a monad o.o
20:07:04 <mniip> well you do know what strong monads are?
20:07:11 <Welkin> nope
20:07:51 <dramforever> It's mumble mumble Category Theory mumble mumble
20:08:24 <Rotaerk> not as interesting as cat theory
20:09:30 <mniip> well, if we have a monoidal category, then a monad M is strong if you have a NT  A*TB-> T(A*B)
20:09:33 <mniip> natural in A and B
20:10:03 <mniip> oh well and some commutative diagrams
20:10:41 <Welkin> I'm not familiar with your notation
20:11:43 <mniip> oh wait
20:11:48 <mniip> well, if we have a monoidal category, then a monad T is strong if you have a NT  A*TB-> T(A*B)
20:11:55 <mniip> there we go
20:12:04 <mniip> * being the tensor product in the monoidal category
20:16:40 <dramforever> Welkin: looks greay
20:16:43 <dramforever> *great
20:17:42 <dramforever> So now I just need to learn Language.Haskell.TH by heart and start working :/
20:24:43 <Rotaerk> dramforever, or just start working and learn it as you use it
20:25:41 <Welkin> jump right in
20:25:49 <Welkin> the water's fine
20:26:34 <Welkin> I think everyone goes through that phase where they think that is they simply memorize a book (or the rules) about something, then they will be able to do it flawlessly
20:26:42 <Welkin> if they*
20:26:59 <Welkin> which is obviously not true
20:28:03 <dramforever> Ok
20:31:27 <dramforever> I guess I'll start with basic constructs and add support for more as I develop it
20:51:35 <Guest94118> Hello, could anyone explain why in this example first function fails with <<loop>>, but second works http://pastebin.com/CG7P8ygh ? Thank you
20:55:55 <dramforever> Should use \~(_,_)
20:56:24 <Guest94118> Thank you! What is the meaning of ~?
20:56:50 <dramforever> Makes the pattern matching more lazy
20:57:09 <dramforever> '\~(x, y) -> e' is like '\xy -> let x = fst xy; y = snd xy in e'
20:57:27 <dramforever> In this way the argument will not be strictly evaluated
20:58:00 <Guest94118> Is this a GHC extention? I just added it to my code and and it didn't compile
20:58:01 <dramforever> In your case, \(_,_) causes the argument to be evaluated *before* the 'return (a, ())' kicks in
20:58:10 <jle`> @tell erisco implicitness is both a strength and a weakness :)
20:58:10 <lambdabot> Consider it noted.
20:58:33 <jle`> Guest94118: what's the error?
20:58:46 <pavonia> It's \ ~(_,_) with a space
20:59:01 <Guest94118> test.hs:7:16: error: parse error on input ‘\~’
20:59:19 <dramforever> Ahh, good catch
20:59:40 <Guest94118> Yes, adding space fixed it
20:59:52 <Guest94118> Everything works now! Thanks a lot!
20:59:54 <dramforever> > let (\~) = 2 in (\~)
20:59:57 <lambdabot>  2
21:00:06 <dramforever> Totally unsurprising
21:03:48 <Zemyla> Hmm. If Haskell didn't have general lazy recursion, but did have folds, maps, and enumFromTo/enumFromThenTo, would that subset of the language be primitive recursive?
21:12:46 <mniip> if those are the only builtin functions then yes
21:13:31 <mniip> if you're careful enough to not allow infinite lists, you could say foldr is primitive recursive
21:13:36 <erisco> but why not this http://lpaste.net/352094
21:13:45 <mniip> trivially map is too, and enumFromTo is basically bounded recursion
21:14:01 <erisco> oh, because then promotion probably doesn't make sense
21:14:08 <erisco> @messages
21:14:44 <erisco> jle`, somewhat yes as I find it really difficult to keep the context in my head
21:14:59 <erisco> which is why I keep annotating
21:15:32 <mniip> erisco, haha
21:15:41 <mniip> add type Nat' = Nat
21:15:44 <mniip> and crash ghc
21:15:56 <erisco> does it? lol no thanks
21:17:03 <erisco> so, Sing is also just the proof terms for constructing data
21:17:37 <mniip> hehe I should test it with a recent ghc
21:17:54 <erisco> SZ is the proof that Z is a Nat, and so on
21:18:56 <mniip> erisco, I don't think you can have an infinite kind hierarchy that isn't *::*
21:19:13 <erisco> well yes, that would be the problem. I wasn't thinking about promotion
21:19:33 <erisco> it would only make sense if you employed special rules for it
21:19:38 <jle`> erisco: yeah, passing witnesses of contexts gives you more manual control
21:19:43 <jle`> and also lets you manipulate them as first-class values
21:19:57 <jle`> one of the common complaints with haskell's typeclass system is that typeclasses aren't first class, and they're magical/implicit
21:20:15 <erisco> existential type classes something something
21:21:24 <jle`> witnesses let you manipulate typeclasses and contexts as first-class values so there's a little bit of magic taken away
21:21:29 <erisco> also looking at Proxy... it is interesting
21:22:23 <erisco> such as why Sing (a :: Nat) and not just Proxy :: Proxy (a :: Nat)
21:22:42 <dramforever> Sing is for pattern matching
21:22:57 <jle`> erisco: if you pattern match on Proxy, it doesn't tell you anything about the type
21:22:58 <dramforever> You can't really pattern match Nat on the value level
21:23:02 <erisco> ah, I suppose that is true
21:23:12 <erisco> I was also going to say that Proxy doesn't give you any proof terms
21:23:25 <dramforever> Because that needs dependent types to work
21:23:53 <erisco> but the pattern matching is a significant difference
21:24:03 <erisco> so really, Proxy is not so appealing
21:24:17 <dramforever> Proxy doesn't do anything
21:24:58 <erisco> maybe you can get around having Proxy by using TypeApplications
21:25:15 <erisco> but that seems to be the purpose... to pass types
21:25:26 <erisco> Haskell doesn't have type parameters per se
21:34:07 <mniip> erisco, I might have a solution
21:34:37 <erisco> well, there is at least the Sing solution
21:36:19 <erisco> what was your thought mniip?
21:37:16 <mniip> oh hmmm
21:37:41 <mniip> I was thinking of using a constraint
21:37:56 <mniip> it didn't work too well
21:40:52 <erisco> there is just something amiss for me though... why do I have data Nat but data family := and data family :<
21:41:10 <erisco> why don't I need data := and a Sing wrapper for it
21:43:09 <jle`> where is := from?
21:44:31 <erisco> http://lpaste.net/352095
21:45:05 <erisco> I am stripping it back to just the fundamentals so I can get a grasp on it
21:45:16 <jle`> it looks like you're using a data family so that your := can be polymorphic
21:45:29 <jle`> but you really don't need one if you just want to do it for Nat's
21:46:03 <erisco> you're right, I could have just defined  data NatEq (a :: Nat) (b :: Nat) where EqZ ... EqS ...
21:46:12 <jle`> data NatEq :: Nat -> Nat -> * where EqZ :: NatEq Z Z; EqS :: NatEq n n -> NatEq (S n) (S n)
21:46:14 <jle`> yeah
21:47:22 <jle`> using a data family lets you use the ':=' identifier for your eq witnesses for different types
21:47:24 <erisco> I suppose the difference is NatEq constructs a *
21:47:39 <jle`> well, so does :=
21:47:46 <erisco> yes I know
21:47:56 <erisco> I just mean that I don't need a := kind
21:48:02 <erisco> whereas I need a Nat kind
21:48:35 <erisco> so I guess it is moreso that Nat defines the types/kind and SNat defines the terms/type
21:48:51 <erisco> but still seems a bit strange for some reason
21:48:56 <mniip>     • Expected kind ‘N (NF 'Nothing)’,
21:48:57 <mniip>         but ‘'Z’ has kind ‘N (NF 'Nothing)’
21:48:58 <mniip> hahah
21:49:21 <erisco> careful mniip. you're causing netsplits with your exploits
21:49:24 <jle`> yeah.  Nat gives you the kind and the types, and SNat is the witnesses of those that you can pass around at the value level
21:49:34 <mniip> that's not a netsplit...
21:49:46 <erisco> oh it was the opposite :P
21:50:00 <mniip> afraid not
21:52:06 <erisco> you just got K-Lined son
21:52:44 <erisco> jle`, I feel like a name other than "Sing" would be helpful
21:52:59 <erisco> yes it is interesting that the types are singletons but it doesn't so much seem the important thing
21:53:00 <wesTT> sup girls join irc.supernets.org
21:53:01 <Pestilence> sup girls join irc.supernets.org
21:53:01 <GrodGod> sup girls join irc.supernets.org
21:53:01 <kriskringle> sup girls join irc.supernets.org
21:53:01 <DioSoft> sup girls join irc.supernets.org
21:53:01 <Guest40015> sup girls join irc.supernets.org
21:53:01 <amsty> sup girls join irc.supernets.org
21:53:24 <jle`> erisco: singletons are a specific consistent pattern
21:54:04 <erisco> yes but the name is odd to me
21:54:34 <jle`> i think it comes from the fact that each type has only a single inhabitant
21:54:51 <erisco> maybe you didn't get my message :P
21:54:58 <jle`> maybe the netsplit :)
21:55:06 <dramforever> In TH am I supposed to use ExpQ everywhere?
21:55:13 <erisco> I said it is interesting that they are singletons but that doesn't seem to be the most important thing
21:55:36 <erisco> :=/NatEq is also a singleton but that isn't what it is about
21:57:07 <erisco> it is literally about defining a term/type equivalent to a promoted type/kind
21:57:27 <erisco> we just can't give both these definitions at once
21:58:58 <erisco> I tried that :P
21:59:26 <mniip> hmm
21:59:30 <jle`> yeah, a bit annoying.  you have to duplicate the definitions
21:59:44 <jle`> that's why the singletons has template haskell to make it a bit smoother
22:01:12 <erisco> or I guess I shouldn't say "equivalent", as that is moreso what the unpromoted definition is
22:01:57 <erisco> I mean we want to inhabit all promoted terms
22:02:07 <dramforever> template haskell
22:02:26 <dramforever> Looks like everything works on 'ExpQ's in TH
22:02:50 <erisco> so, for each promoted term, define a term which has the type of the promoted term
22:03:37 <erisco> and to make that work in Haskell we have to add a little wrapper around it as we cannot actually give two distinct terms the same type
22:03:47 <erisco> (the unpromoted version is still laying about)
22:04:11 <erisco> so that's the Sing/SNat
22:04:37 <erisco> and the simplest way to define these terms is to just copy the same structure
22:07:42 <erisco> jle`, does that sound coherent to you?
22:09:41 <jle`> a bit :o i think i get your idea
22:28:22 <lyxia> dramforever: you can use the constructors which just use Exp, with (>>=)
22:29:01 <dramforever> lyxia: But sometimes I want [| nice $(things like) these |]
22:29:23 <dramforever> and $( ) takes ExpQ, [| |] gives ExpQ
22:29:40 <dramforever> Then I thought, hey it makes sense
22:29:59 <dramforever> because [| |] may need a unique variable name supply
22:30:01 <mniip> but really
22:30:06 <mniip> how do I debug something like this
22:32:50 <dramforever> $(each [| (~! getLine) ++ (~! getLine) |]) splices into ((++) <$> getLine <*> getLine). Sounds good?
22:33:12 <dramforever> It's something I'm working on
22:37:37 <dramforever> Uh, no, the context is like a week away. Ignore that
22:40:33 <mniip> augh
22:40:39 <mniip> this seems to be impossible: class SN s => SN (n :: s -> k)
22:56:45 <mniip> hmm
23:06:38 <mniip> has type C injectivity been implemented in ghc yet?
23:45:34 <zennist_> How's Control.Monad.Except compared to Control.Monad.Catch?
23:46:00 <zennist_> specifically - what's the more 'conventional' option there that unifies throwing exception both in pure and impure code?
23:46:59 <zennist_> anyone?
23:51:59 <kaol> zennist_: Control.Monad.Except gives you ExceptT which is a monad transformer and it's separate from haskell's exception mechanism really. If you throw an exception it won't touch it.
