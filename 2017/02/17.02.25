00:14:28 <adarqui> hey, using withSystemTempFile, is there a way to execute inside that? it's locking the temp file, so i can't write to it when i execute something with System.Process.. ie, withSystemTempFile "blah.txt" $ \tmp_file _ -> r <- createProcess (proc "something_that_writes_to_file" [tmp_file])
00:15:00 <adarqui> or should i just do that manually, openSystemTempFile, execute, unlink it .. maybe just use bracket or something
00:16:05 <sternmull> adarqui: You could pass the handle as stout or stdin.
00:16:56 <adarqui> ah cool
00:17:03 <adarqui> ill try that, thanks sternmull 
00:17:31 <sternmull> and if you need a named file instead you could use withTempDirectory and just tell your process to create its file there
00:59:53 <adarqui> cool thanks sternmull! i ended up just piping stdout: (_, Just h_out, _, _) <- (Process.createProcess $ (proc "proc" args) { std_out = CreatePipe }) >>= hGetContents
01:01:47 <juhp> is there a good name for `not . null` ?
01:03:19 <sternmull> adarqui: right, if you don't actually need a file then it is of course better to just stream the output to the consumer
01:04:38 <MarcelineVQ> that's readProcess yeah?
01:05:39 <juhp> I guess I'll go with notNull ;)
01:06:52 <MarcelineVQ> juhp: I can't think of anything shorter :>
01:07:10 <juhp> :)
01:07:14 <juhp> me neither
01:38:50 <razieliyo> hi
01:39:22 <razieliyo> I'm starting project euler to learn some haskell and I have a question for my naive solution for the second problem
01:39:38 <razieliyo> http://pastebin.com/hgV30ivj
01:40:12 <razieliyo> it's taking forever, is it because the naive fibonacci function approach? also I'm computing it a lot of times
01:40:14 <bollu> razieliyo: what is the question?
01:40:25 <razieliyo> bollu, that's the question
01:40:37 <bollu> ah, OK
01:40:46 <bollu> razieliyo: yes, you're computing the recurrence "fully" each time
01:40:54 <razieliyo> so that's what is slowing it down, right?
01:40:57 <bollu> yep
01:41:00 <bollu> razieliyo: the "slick" way of writing fibonacci in haskell is this:
01:41:01 <razieliyo> nice, thank you bollu 
01:41:07 <bollu> (where we make use of laziness)
01:41:26 <bollu> >fib = 1:1:(zipWith (+) fib (tail fib))
01:41:28 <razieliyo> I read an implementation using zipWith and a infinite list, it's awesome
01:41:30 <bollu> > >fib = 1:1:(zipWith (+) fib (tail fib))
01:41:33 <razieliyo> cool
01:41:33 <lambdabot>  <hint>:1:1: error: parse error on input ‘>’
01:41:36 <bollu> yeah :D
01:41:45 <bollu> well, since you've seen it
01:42:22 <razieliyo> thanks for the help bollu :)
01:42:25 <bollu> razieliyo: np :)
01:42:32 <bollu> razieliyo: this is somewhat unrelated to the problem at hand
01:42:44 <bollu> razieliyo: but have you seen how to compute fib using matrix multiplication?
01:42:56 <razieliyo> bollu, no, how is that?
01:42:56 <bollu> razieliyo: this is useful if you want the nth term in the fib sequence
01:43:11 <razieliyo> well, I'll take a peek at google
01:43:23 <bollu> razieliyo: yes. I think this is decent: https://kukuruku.co/post/the-nth-fibonacci-number-in-olog-n/
01:43:56 <razieliyo> nice, thanks bollu 
01:45:13 <octarin> Yes, you just need to implement a 2x2 matrix data type and make it an instance of Num in order to use (^)
01:45:16 <flxw> a third way to compute the n-th fibonacci number would be to use the golden ratio formula. Have you seen this, too? 
01:45:17 <octarin> that’s quite elegant
01:45:48 <octarin> with powers of φ ?
01:45:57 <flxw> yes
01:46:51 <octarin> but is exponentiation quicker than powering matrixes ?
01:47:35 <flxw> good question. :)
01:47:48 <bollu> octarin: it really depends
01:48:21 <bollu> flxw: exponentiation of phi will need you to use some symbolic method right, otherwise floating point errors?
01:48:31 <bollu> whereas with the matrix method, you have no such problems
01:49:08 <octarin> That’s true
01:49:08 <bollu> flxw: correct me if I'm wrong here
01:49:25 <octarin> for very large numbers you would have to estimate the error for the exponential
01:49:27 <bollu> so I think matrices would be faster keeping correctness in mind
01:49:34 <bollu> yeah
01:51:15 <flxw> this is true. (I don't remember the error bound anymore, but it was pretty amazing how small it was)
01:52:45 <bollu> is there an arrow based FRP library?
01:52:51 <bollu> I've wanted to use both for a while now
01:54:59 <flxw> the wires library, no?
01:55:25 <bollu> is it?
01:55:26 <bollu> let me check
01:56:06 <bollu> uhh, Wire seems to be Monad, not Arrow
01:56:07 <bollu> https://hackage.haskell.org/package/wires-0.1.0/docs/Control-Wire-Core.html
01:56:11 <bollu> oh no
01:56:14 <bollu> there is Arrow, sorry
01:56:40 <bollu> wow the API is small
01:56:41 <bollu> this is cute
01:57:23 <flxw> arrows were the reason for me to stay away from it for another few months. :) 
02:02:19 <bollu> flxw: what do you mean by that?
02:04:34 <flxw> I know nothing about arrows yet. 
02:04:59 <bollu> ah, OK
02:07:17 <flxw> I am wrapping my head around FRP and lenses right now, so I thought I better keep arrows out of the picture for another while.
02:10:13 <bollu> flxw: heh, I'm trying to grok lenses as wel :P
02:10:53 <bollu> flxw: in fact, I had asked a reddit post about understanding lens internals. https://www.reddit.com/r/haskell/comments/5vb6x1/how_do_i_learn_lensinternals/?utm_content=title&utm_medium=user&utm_source=reddit&utm_name=frontpage
02:22:56 <flxw> haha, cool. I am not quite there yet, but once I am, I know where to continue. ;)
03:03:34 <me12345> Hello. Any sweet pussies here, that would like to meet an adorable Estonian man?
03:16:07 <MarcelineVQ> if there were I doubt that'd be the line that sealed the deal
03:24:46 <flxw> and it would depend on what language extensions he's using in his haskell code.
03:29:48 <rmrfroot> flxw: he's probably one of those persons that uses A LOT of CPP macros and wraps *everything* in `unsafePerformIO`
03:30:01 <cocreature> rmrfroot: that’s disgusting
03:30:38 <rmrfroot> cocreature: that was the most digusting thing I could think of :D
03:30:55 <rmrfroot> what can we do to make it worse?
03:31:02 <cocreature> rmrfroot: put some unsafeCoerce in there and it becomes even more disgusting
03:32:53 <int-e> . o O ( unsafePerformIO "wraps" code in the same way that a pair of scissors "wraps" a present. )
03:32:55 <flxw> sorry, I am still learning to write more ellegant haskell, so I don't know all the tricks yet to make it really bad. :) 
03:33:13 <rmrfroot> cocreature: never hard about that one before, reading this "converts a value from any type to any other type." made me shiver
03:33:50 <cocreature> rmrfroot: it’s basically “types? who needs that anyway, I’ll just pretend it has a different type”
03:34:03 <int-e> (scissors may be involved in wrapping presents, and the wrap may even be beautiful, but noone would attribute the result to the scissors.)
03:34:25 <rmrfroot> pfff, types? never heard of such atrocity.
03:34:39 <int-e> rmrfroot: so which type of programmer are you...
03:35:21 <rmrfroot> ine-e: the one that writes jokes in as much source code comments as possible
03:35:25 <rmrfroot> sorry, int-e
03:36:42 <rmrfroot> int-e: and you? :) 
03:37:44 <int-e> mostly lazy
03:38:02 <int-e> (I would elaborate but it doesn't seem worth the effort)
03:38:14 <rmrfroot> *baa-duumm-tisssh*
03:38:18 <rmrfroot> good one!
03:39:10 <rmrfroot> #haskell always has the best kind of jokes, too bad no one I know will ever understand them :(
03:42:53 <flxw> A question about MonadFail. I first came across it when writing some validation code in an Attoparsec based parser. And I find the idea of having an inteface to fail, with implementations which make sense for the different monads quite neat, actually. But some people seem to not like MonadFail at all. Why is that? I mean, one just doesn't need to implmenent fail for monads for which it is not appropriate, no?
03:44:10 <flxw> (and as I understand it, fail is a great way to not throw exceptions uniformly, modulo IO)
03:46:25 <cocreature> flxw: there are two different reasons why people critisize fail: 1. it’s part of Monad for historical reasons. eventually it will only be available in MonadFail but until then it’s weird that every Monad has to supply a fail operation. 2. just being able to supply a string is kind of annoying. usually you want to use more structured types for your errors. for that you can use something like MonadError
03:48:27 <flxw> oh, I see. yeah, this is true. I'll have a look at monaderror now ...
03:51:59 <dramforever> MonadError is more like exceptions...
03:52:30 <dramforever> IIUC MonadFail for binds that may fail to pattern match. MonadError for exception-ish error handling
03:53:02 <mryandao> hi there, haskell newb here. I'm trying to figure out a compiler error with this code snippet -> https://0bin.net/paste/ZiTL6JblqF-bLWBX#gfu1DkpR0RVItaFl2W0VtzkV1vPoNvV3F-2WedYUL2a
03:54:09 <mryandao> here's a pastebin with the error
03:54:17 <cocreature> mryandao: remove the "do" outside the if and add one to the if clause of your if
03:54:17 <mryandao> https://0bin.net/paste/zxMziGbjJa45N-d-#W9SMI5xq9qs7Kv8ujdxtGG6BzsK1-3S7/uBise68RaI
03:54:38 <cocreature> the whole if is a single statement so putting do around it has no effect
03:54:46 <mryandao> oh i see
03:54:54 <cocreature> but if a < n you have two statements so you need "do"
03:56:16 <mryandao> argghh, i've been troubleshooting the types in ghci for a good hour
03:58:10 <flxw> btw, Is it considered bad style to write validation code inside the Parser monads? concretely: I am parsing log files, and building thyme values from the parsed timestamps. And at least for the moment, I want mal-formed timestamps (e.g. 31st of february) to be  errors that abort the later stage of analysis.
04:00:15 <sternmull> i need a secure TCP-channel where both participants verify the identity of the other one. It seems hs-tls should do the job. Are there better examples than the ones in debug/src/? I don't think the API documentation is enough for me to get started.
04:01:59 <cocreature> flxw: I don’t think that’s bad at all. sometimes it is worth the effort to actually pull that validation code inside your parser, i.e., rely on the parser library to fail for mal-formed timestamps, but in a lot of cases (I would say timestamps fall in that category) parsing the timestamp just as a string and then validating it is significantly easier
04:03:52 <dramforever> flxw: You can first parse it into a general structure and refine it further later on
04:04:57 <ongy> sternmull: do you have a pki set up? otherwise the tls verification may be a bit annoying to set up for you
04:07:01 <sternmull> ongy: I think so. I want to store certificates on the participating machines and identify them by that. I have no use for a certificate chain or CAs. It just to securely connect to "services" that are managed by me. Just like i would connect to my systems using ssh.
04:08:20 <sternmull> but i want a kind of rpc and can not assume ssh is there. So i want to do it "manually" instead of using ssh.
04:08:24 <ongy> afaik you will need to set up a CA, but it's not that much work for a small system. Sadly I have no experience with hs-tls
04:08:31 <flxw> thank you both very much. Yes, in the end I think I will just drop invalid timestamps with a warning anyways. And then having several passes oover the parsed structure to refine it will be the better approach.
04:10:23 <flxw> sternmull: for debugging certificate and handshake issues openssl s_client is very helpful.
04:11:04 <sternmull> flxw: At the moment i am still looking for a minimal tls client-server example that i can use as a starting point.
04:11:13 <flxw> this way you could separate out the library issues from actual tls problems. :)
04:12:01 <flxw> would the example need to be in haskell per se?
04:13:14 <sternmull> Yes i want to use haskell for the implementation of the client and the server. I already have a python implementation but stopped with that to see if it is more fun to do it with haskell.
04:13:26 <flxw> I mean, I understand you want to use it in haskell, but for getting to know the tls api, C examples might be helpful, too?
04:14:02 <flxw> ah, okay.
04:15:04 <sternmull> flxw: I don't know if C code would help me to find my way into hs-tls. I know how to use tls in general, its really the haskell API that i have to understand.
04:15:48 <flxw> okay okay, I got that now. :)
04:16:27 <sternmull> But thanks for pointing out s_client. Looks like it will be helpful to test client/server on their own.
04:24:14 <lpaste_> Aku pasted “How do I write pOneOrMore?” at http://lpaste.net/5476984330704125952
04:25:08 <Aku> Can someone look at my code, I want to write the function "pOneOrMore" as in the code?
04:26:42 <bollu> Aku: one sec
04:26:42 <flxw> yeah, because you don't need to hack in lots of debug code for tls stuff. I found this openssl tcp client pretty cool for separating my 'issues' from those of the tls library I'm using. In one case with a proprietary library, it turned out they left out the final newline from clear text certificates and so no certificate was ever valid. ...
04:26:54 <Aku> Ohh..bollu!
04:27:12 <bollu> Aku: oh hey :)
04:27:34 <Aku> Siddarth!
04:27:45 <bollu> yeah
04:28:09 <Aku> Its the same interpreter!
04:28:33 <Aku> There I am stuck at pOneOrMore!
04:28:35 <sternmull> flxw: Have you any experience with hs-tls? I wonder how it performs compared to openssl and others. But as long as it gets me at least around 100MiB/s everything would be fine.
04:31:18 <flxw> sternmull: No, not yet. But now I'm already curious about your findings. :) (and 100MiB/s should be doable, most desktop cpus have more than 2GHz clockrate nowadays ...)
04:31:26 <bollu> Aku: OK, so, describe to me what it must do in the first place
04:31:32 <bollu> Aku: then we will try and combinator it
04:32:14 <bollu> Aku: so, what are the semantics of pOneOrMore?
04:32:16 <sternmull> flxw: Ok, i will tell you my results when/if i get it running.
04:32:28 <bollu> Aku: if I may make a suggestion: first implement pZeroOrMore
04:32:48 <Aku> bollu can you just open page 35 of 'Implementing functional languages, a tutorial?'
04:32:58 <bollu> uh, sure
04:33:03 <bollu> give me a minute
04:33:07 <bollu> sort of in the middle of something
04:33:12 <bollu> Aku: but, I want _you_ to explain to me
04:33:17 <flxw> sternmull: Cool, thank you. hehe
04:33:54 <bollu> Aku: also, calling me by "real name" on IRC is a little… :)
04:34:03 <Aku> I am srry!
04:34:17 <bollu> yes, I'm at the page
04:34:27 <bollu> Aku: OK, he defines zero or more using one or more
04:34:48 <bollu> Aku: OK, neat, he uses mututally recursive definitions
04:34:51 <Aku> Apologies...so it should give me a list of successive application of p
04:34:51 <bollu> which is slick
04:34:53 <bollu> but.. a little weird to see
04:34:57 <bollu> YES
04:34:59 <bollu> Yes*
04:35:35 <bollu> Aku: so yes
04:35:49 <bollu> Aku: it should "try" the parser many times, but the parser should succeed at least once
04:36:04 <Aku> ya correct
04:36:12 <bollu> can you link me to your code again?
04:36:24 <Aku> Yes..sure
04:36:44 <lpaste_> Aku revised “How do I write pOneOrMore?”: “How do I write pOneOrMore?” at http://lpaste.net/5476984330704125952
04:37:07 <bollu> OK so
04:37:08 <Aku> This is the full cod
04:37:08 <bollu> first of all
04:37:12 <Aku> *code
04:37:14 <bollu> we need to return a parser
04:37:28 <Aku> Ya that's where I am stuck
04:37:36 <Aku> How to return a parser?
04:38:09 <bollu> Aku: OK
04:38:24 <bollu> Aku: how does pThen work?
04:38:40 <bollu> Aku: as in, how does pThen return a parser?
04:38:42 <Aku> Also I don't exactly understand the type Paser [a]
04:38:56 <bollu> OK
04:39:00 <bollu> let us start from there first
04:39:05 <bollu> what is "Parser p"?
04:39:10 <Aku> Ya pThen applies p1 then p2 to remaining tokens
04:39:32 <bollu> Aku: wait, tell me what "Parser p" is
04:40:19 <bollu> Aku: ?
04:40:26 <Aku> Ya ...one min
04:40:53 <Aku> Parser p checks whether the list contains anything of type p
04:41:09 <bollu> no, just tell me what the type "Parser p" actually is
04:41:16 <bollu> Parser p is a type alias right?
04:41:21 <Aku> Ya ya
04:41:23 <bollu> what is the "underlying" type?
04:41:27 <Aku> correct
04:41:54 <Aku> a production rule
04:42:04 <Aku> Underlying type^
04:42:21 <bollu> type Parser a = [Token] -> [(a,[Token])]
04:42:28 <bollu> I was hoping for an answer of [Token] -> [(a,[Token])]
04:42:38 <bollu> because "Parser a" is sugar for [Token] -> [(a,[Token])]
04:42:48 <Aku> oops..I thought you read it!
04:42:52 <bollu> I did
04:42:55 <bollu> but I'm asking you
04:43:02 <bollu> so pretend I haven't read it
04:43:11 <Aku> ohh..srry
04:43:16 <bollu> it's okay
04:43:17 <bollu> okay so
04:43:22 <bollu> that is what Parser a is, right?
04:43:32 <bollu> so, what does "Parser a" *represent* ?
04:43:32 <Aku> yup
04:43:40 <bollu> interpret the type [Token] -> [(a,[Token])] for me
04:44:21 <bollu> like, what does the type *mean*? 
04:44:30 <Aku> It takes in a list of tokens which are of type string and returns another list
04:44:36 <bollu> sure
04:44:36 <Aku> type means just an alias
04:44:38 <bollu> but, like
04:44:49 <bollu> what is the list of tokens it takes, and what is return list
04:45:02 <bollu> something along the line of "it takes the raw stream of tokens, and returns …"
04:45:06 <Aku> just a min...
04:45:08 <bollu> sure
04:45:15 <bollu> (you can refer to the book BTW)
04:45:24 <bollu> I'm doing this to make sure you understand what our types represent
04:46:03 <Aku> Still it's not clear fully
04:46:19 <bollu> OK
04:46:27 <bollu> is the question not clear?
04:46:34 <Aku> I mean what are you expecting?
04:46:37 <bollu> OK
04:46:42 <bollu> so, if I tell you "Parser a"
04:46:45 <bollu> what does "Parser a" do?
04:47:29 <Aku> so Parser Int will take [Token] -> [Int,[Token]]
04:47:46 <Aku> a can be anyhting
04:47:51 <Aku> like Int,String
04:48:00 <Aku> Is that what you expect?
04:48:14 <Aku> I mean I....
04:48:17 <bollu> ok
04:48:21 <bollu> how do you use "Parser a"?
04:48:26 <bollu> or, let's take a simpler example
04:48:28 <bollu> have you seen Maybe?
04:48:33 <Aku> ya seen
04:48:38 <bollu> so, what does Maybe a represent?
04:48:44 <bollu> (Maybe a)
04:48:50 <Aku> Just a|Nothing
04:48:53 <bollu> right
04:48:56 <bollu> but conceptually
04:49:09 <bollu> it represents the possibility of having a value "a"
04:49:14 <bollu> or perhaps not having anything
04:49:15 <Aku> Okay
04:49:22 <Aku> Okhay
04:49:23 <bollu> we *implement* it as Just a | Nothing
04:49:26 <bollu> but that doesn't matter
04:49:33 <Aku> Allright
04:49:39 <Aku> Then?
04:49:45 <Aku> I am curious
04:49:48 <bollu> I can write the same thing in some complex way, but that doesn't matter. The _idea_ is that it represents the possiblity of a vaue
04:49:53 <bollu> now, consider ([a])
04:50:02 <Aku> Ya 
04:50:02 <bollu> I ask the same question: what does [a] represent?
04:50:35 <Aku> It doesn't show a possibility here but just that it is a list of type a 
04:50:43 <Aku> Is it?
04:50:53 <bollu> well, sure
04:51:02 <bollu> but, like, what does it mean "to have a list of stuff"?
04:51:11 <bollu> does it not mean "zero or more occurences of a"?
04:51:20 <Aku> Ya It does
04:51:32 <bollu> if you consider [Int], [], [1], [1, 2], … are all valid instances of [a]
04:51:33 <bollu> OK
04:51:36 <Aku> Okay..so thats what is expected
04:51:43 <bollu> so, now, similary, what does "Parser a" represent?
04:51:47 <bollu> (don't give me the type)
04:52:14 <Aku> so u want valid instances of Parser a
04:52:25 <Aku> ?
04:53:00 <Aku> Srry ...its difficult
04:53:02 <bollu> I want what "Parser a" means. "Maybe a" means "possibility of having a". [a] means "zero or more occrences of a". (a -> b) means "something that takes  a and returns b". (a, b) means "something that holds both a and b"
04:53:07 <bollu> no, don't worry
04:53:13 <bollu> it's a little weird to think of types as carrying meaning
04:53:25 <bollu> it's a slightly strange leap to make at first :)
04:53:25 <Aku> let me think
04:53:28 <bollu> sure
04:53:42 <bollu> so, to understand what "Parser a" means, we need to see what it is aliasing. (Since it is a type alias)
04:53:53 <bollu> it is an alias of [Token] -> [(a, Token)]
04:53:59 <bollu> now, this is not some random type
04:54:06 <bollu> this somehow means "Parser a " to us
04:54:23 <bollu> so how do we interpret the ([Token] -> [(a, Token)]) to mean "oh, it is a parser!"?
04:54:26 <Aku> okay
04:54:48 <bollu> you can say "I don't know"
04:54:50 <bollu> which is all right
04:54:51 <Aku> we can interpret it as a function
04:54:56 <bollu> yes
04:55:02 <bollu> which takes what as input and gives out what as output?
04:55:07 <Aku> ya
04:55:25 <bollu> no, I'm asking
04:55:29 <bollu> what is the input and what is the output?
04:55:45 <Aku> my typing is slow...
04:55:46 <bollu> the low level answer would be [Token] is the input and [(a, Token)] is the output
04:55:48 <bollu> yeah
04:55:52 <bollu> no worries
04:55:58 <bollu> but clearly those things have _meanings_ to us
04:56:03 <bollu> so, what is the [Token] representing
04:56:06 <Aku> Ya that's what I was typing
04:56:13 <Aku> It a list of Strings
04:56:38 <Aku> Zero or more occurences of String
04:56:38 <bollu> sure
04:56:49 <bollu> but, like, we are thinking of it as the "unprocessed input tokens" right?
04:56:51 <bollu> are we not?
04:56:58 <Aku> Yess
04:57:08 <bollu> now, what about the output?
04:57:10 <Aku> We are
04:57:13 <bollu> how are we thinking of [(a, Token)]?
04:57:40 <Aku> As processed output list
04:57:48 <bollu> OK, but why a list?
04:57:51 <bollu> why not just (a, Token)
04:58:02 <bollu> [(a, [Token])] sorry*
04:58:06 <bollu> why not just (a, [Token])
04:58:23 <Aku> Because there could be more occurences
04:58:31 <Aku> like in case of ambiguous gmrs
04:58:45 <bollu> OK, so what does (a, [Token]) mean first of all?
04:58:55 <bollu> (you are right about that BTW, Why we use [(a, Token)]
04:59:31 <Aku> here a is what we processed and token is the remaining list to be processed
04:59:46 <bollu> right
05:00:13 <Aku> Then?
05:00:20 <bollu> so we return [(a, [Token]) to represent collection of possible parses, where a "possible parse" is an "a" which we have parsed, and the rest of the input that is not processed, correct?
05:00:34 <Aku> ya perfect!
05:01:01 <bollu> and so, "Parser a" is a function, that takes a list of unprocessed tokens ([Token]]) and return [(a, [Token]) to represent collection of possible parses, where a "possible parse" is an "a" which we have parsed, and the rest of the input that is not processed. right?
05:01:22 <Aku> Yes
05:01:34 <bollu> OK
05:01:43 <bollu> so now, consider Parser [p]
05:01:48 <Aku> Then...curious
05:01:51 <bollu> replace "a" in the previous sentence with [p]
05:01:58 <bollu> what do you get?
05:02:23 <Aku> just a min..
05:02:28 <bollu> sure
05:03:35 <Aku> Now the difference is that what we have parsed is a collection
05:03:40 <Aku> [a]
05:03:44 <bollu> yes
05:03:50 <bollu> so we are able to parse a collection of things
05:03:54 <bollu> given a parser for one thing
05:03:56 <bollu> (Parser a)
05:03:59 <Aku> ya
05:04:08 <bollu> does this seem "logical" to you?
05:04:10 <bollu> like, doable?
05:04:17 <Aku> No eactly
05:04:21 <Aku> exactly
05:04:26 <bollu> it doesn't seem possible?
05:04:33 <Aku> Not exactly
05:04:36 <bollu> OK
05:05:02 <bollu> consider ["50", "50", "50", "30"] as my input list.
05:05:03 <Aku> ya it doesn't...I mean I dont get how we do it
05:05:10 <bollu> now, if I have a (Parser Int)
05:05:17 <bollu> that can take "50" and return 50 :: Int
05:05:26 <bollu> can I not use this parser
05:05:33 <bollu> to parse everything else in the list?
05:05:52 <Aku> Ya i have to use it recursively
05:05:59 <bollu> forget implementation
05:06:04 <bollu> let's try and see if this seems reasonable first of all
05:06:13 <Aku> Ya I can use
05:06:30 <Aku> first parse the first 50 and then parse the second
05:06:34 <Aku> and so on
05:06:36 <bollu> yes
05:06:37 <bollu> now
05:06:39 <bollu> what if I give you
05:06:46 <bollu> ["50", "50", "a"]
05:06:51 <bollu> then what should the behaviour be?
05:06:58 <bollu> how much do we parse, and where do we stop processing?
05:07:23 <Aku> We should be stopping when the token /= 50
05:07:32 <bollu> not necessarily
05:07:41 <bollu> we have a parser that can parse integers
05:07:43 <bollu> so the behaviour I would aim for
05:07:50 <bollu> is to try to parse integers as much as we can
05:07:51 <Aku> Ya right
05:07:57 <bollu> and stop when there are no more integers
05:08:01 <bollu> so, if I give you the input stream
05:08:05 <Aku> Thats a broader set
05:08:09 <bollu> ["30", "20", "10", "a", "b"]
05:08:11 <bollu> well
05:08:21 <bollu> sur
05:08:24 <bollu> sure
05:08:32 <Aku> But the tokens are all strings
05:08:36 <bollu> yes
05:08:44 <bollu> but your parser knows if it can parse something or not
05:08:53 <bollu> if it can, it will return a list of possible parses
05:08:57 <bollu> if the parse was not possible
05:09:00 <bollu> it will return empty list
05:09:00 <Aku> Yess right
05:09:03 <Aku> yes
05:09:07 <Aku> perfect!
05:09:09 <bollu> so
05:09:14 <bollu> we need to keep on trying to parse
05:09:18 <bollu> till we hit empty list
05:09:21 <bollu> at which point we stop parsing
05:09:22 <Aku> ohhhkay
05:09:23 <bollu> correct?
05:09:30 <bollu> (I'm asking)
05:09:47 <Aku> When the parse fails that is returns an empty list
05:10:18 <bollu> yes
05:10:23 <bollu> we can return how much we consumed
05:10:28 <bollu> because remember, we are trying to do "one or more"
05:10:30 <bollu> which means
05:10:34 <bollu> we keep on trying to parse as much as we can
05:10:41 <bollu> and when the parser says "you've exhaused this"
05:10:47 <Aku> Yes we can but how ?
05:10:51 <bollu> OK
05:11:08 <bollu> now
05:11:11 <bollu> let us go back to your code
05:11:13 <Aku> ya....
05:12:13 <bollu> can you tell me how your definition of pAlt works? you have a function that takes 2 inputs and returns one output (pAlt :: Parser a -> Parser a -> Parser a). BUT, when you are *defining*  the function, you are taking *three inputs* (pAlt p1 p2 toks = …). Is this not wrong? :O
05:12:53 <Aku> That's exactly what I didn't understand since morning!
05:13:07 <Aku> Is it a partial function?
05:13:15 <bollu> OK
05:13:18 <bollu> so to understand this
05:13:42 <Aku> yes
05:13:47 <bollu> expand out the type pAlt :: Parser a -> Parser a -> Parser a 
05:13:49 <bollu> expand "Parser a"
05:13:53 <bollu> wait
05:13:54 <Aku> okay
05:13:55 <bollu> first of all
05:13:59 <bollu> do you know the difference between
05:14:06 <bollu> f :: (a -> b) -> c and g :: a -> (b -> c) 
05:14:07 <bollu> ?
05:14:22 <Aku> Ya kind off
05:14:28 <bollu> OK, tell me what the difference is
05:14:35 <Aku> f takes a function and returns c
05:14:44 <Aku> g takes a and returns a function
05:15:00 <Aku> Is it?
05:15:22 <bollu> Aku: what does the function that g returns do?
05:15:23 <Aku> But when we write f:a->b->c
05:15:28 <bollu> yes
05:15:31 <Aku> haskell interprtes as g
05:15:35 <bollu> (also, notation f :: a -> b -> c)
05:15:53 <bollu> : is used in type theory, but haskell uses ::  | :)
05:16:01 <bollu> OK, cool
05:16:09 <Aku> ohhkay
05:16:10 <bollu> so, let us expand the type of Parser a -> Parser a -> Parser a
05:16:11 <bollu> this is:
05:16:25 <bollu> f :: ([Token] -> [(a, [Token]) -> ([Token] -> [(a, [Token]) -> ([Token] -> [(a, [Token])
05:16:29 <bollu> whoops
05:16:34 <Aku> ya 
05:16:36 <Aku> correct
05:16:53 <bollu> f :: ([Token] -> [(a, [Token])]) -> ([Token] -> [(a, [Token])]  -> [Token] -> [(a, [Token])] *
05:17:00 <bollu> fuck that is hard to read without syntax highlighting
05:17:02 <bollu> but OK
05:17:05 <bollu> argh
05:17:06 <bollu> still wrong
05:17:09 <bollu> give me a second
05:17:24 <Aku> Ya u missed one parathesis
05:17:38 <bollu> f :: ( [Token] -> [(a, [Token])] ) -> 
05:17:38 <bollu>     ( [Token] -> [(a, [Token])] )  -> 
05:17:38 <bollu>     ([Token] -> [(a, [Token])] )
05:17:40 <bollu> yes?
05:17:52 <Aku> yess
05:17:57 <bollu> however
05:18:14 <bollu> now, let me "re-compact" some of the terms
05:18:21 <Aku> okay
05:18:33 <bollu> f :: Parser a -> Parser a -> ( [Token] -> [(a, [Token])] ) right?
05:18:42 <Aku> ya 
05:18:45 <Aku> correct
05:19:02 <bollu> this is the "correct associativity" so I can write this as | f :: Parser a -> Parser a ->  [Token] -> [(a, [Token])] ?
05:19:20 <bollu> (I would encourage you to convince yourself that f :: a -> b -> (c -> d) is the same as f' :: a -> b -> c -> d
05:19:26 <Aku> Maybe Yes
05:19:33 <bollu> OK, think of it like this
05:19:38 <bollu> a -> (b -> c) == a -> b -> c ?
05:19:45 <Aku> ya 
05:19:48 <Aku> perfect
05:19:50 <bollu> so here
05:19:51 <Aku> Then?
05:19:53 <bollu> do you see it?
05:20:00 <bollu> why the types I wrote work out?
05:20:06 <bollu> if not, I shall walk you through it
05:20:23 <Aku> I got it but still lets walk !
05:20:26 <bollu> OK
05:20:26 <bollu> so
05:20:27 <bollu> we had
05:20:38 <bollu> f :: Parser a -> Parser a -> ( [Token] -> [(a, [Token])] )
05:20:51 <Aku> Just one question...
05:20:54 <bollu> yes?
05:21:24 <Aku> the toks in my function pAlt is the second last [Token] 
05:21:29 <bollu> yep
05:21:30 <Aku> Is it?
05:21:31 <bollu> exactly
05:21:46 <bollu> beacuse f :: Parser a -> Parser a -> ( [Token] -> [(a, [Token])] ) ~= f' :: Parser a -> Parser a -> [Token] -> [(a, [Token])] 
05:21:53 <bollu> we can "pretend" to take three parameters
05:22:00 <bollu> because haskell automatically curries its parameters
05:22:10 <Aku> I was convinced with this but then later it seems troublesome as I move to lefy
05:22:13 <Aku> *left
05:22:41 <bollu> well, it is "obvious" in some sense, because a -> b -> c is *defined* to be a -> (b -> c)
05:22:55 <bollu> so, a -> b -> c -> d ~= a -> (b -> (c -> d)) ~= a -> b -> (c -> d)
05:23:03 <bollu> right?
05:23:09 <Aku> yup
05:23:11 <bollu> OK
05:23:14 <bollu> so, now, similary
05:23:20 <bollu> similarly*
05:23:27 <bollu> pOneOrMore :: Parser a -> Parser [a]
05:23:28 <bollu> which is
05:23:39 <bollu> pOneOrMore :: Parser a -> [Token] -> [(a, [Token])]
05:23:41 <bollu> right?
05:23:48 <Aku> yes
05:23:49 <bollu> so we can take the parser and the toks as input
05:23:52 <bollu> which is why it works
05:23:55 <bollu> so now
05:23:59 <bollu> we have the first two parameters
05:24:02 <Aku> yessss
05:24:10 <bollu> we need to return [([a], [Token])]*
05:24:14 <Aku> curious.........
05:24:18 <bollu> I am sorry, I messed up the type before
05:24:27 <bollu> It should have been [([a], [Token])]* ([a], not a)
05:24:31 <bollu> right?
05:24:39 <Aku> ya ya
05:25:49 <bollu> now
05:25:57 <bollu> what does it mean to parse one or more times?
05:26:00 <bollu> it mean you parse once
05:26:12 <bollu> or you parse once, and then accept data zero or more times
05:26:14 <bollu> right?
05:26:37 <bollu> "once or more" = once or (once  then (zero or more)) ?
05:26:42 <bollu> does the logic make sense?
05:26:53 <Aku> let me think..
05:26:56 <bollu> sure
05:27:40 <Aku> it is once or (once then (zero or more))
05:27:44 <Aku> Maybe
05:27:49 <bollu> OK
05:27:54 <bollu> why is it maybe?
05:28:17 <Aku> Otherwise pThen is doing the same thing but the second time it parses it uses a different parser
05:28:23 <bollu> yes
05:28:27 <bollu> we will use pThen to do this
05:28:34 <bollu> but, conceptually
05:28:45 <Aku> ya?
05:28:49 <bollu> does it make sense?
05:29:02 <Aku> yes it makes
05:29:03 <bollu> all I'm saying is
05:29:39 <Aku> yess!
05:31:10 <Aku> bollu?
05:31:14 <bollu> yes
05:31:17 <bollu> give me a minute
05:31:39 <bollu> yeah OK
05:31:41 <bollu> so
05:31:51 <bollu> conceptually, makes sense?
05:32:11 <bollu> Aku: ?
05:32:12 <bollu> if it does
05:32:17 <Aku> Once again!
05:32:21 <bollu> we have the ability to convert what I wrote into code
05:32:22 <Aku> plz tell
05:32:26 <bollu> tell what?
05:32:34 <bollu> "once or more" = once or (once  then (zero or more)) ?
05:32:38 <bollu> what does once or more mean?
05:32:39 <Aku> yaa ya
05:32:42 <bollu> I can accept the input once
05:32:45 <bollu> or twice
05:32:46 <bollu> or thrice
05:32:51 <bollu> or four times
05:33:12 <Aku> But its not the same input everytime?
05:33:19 <Aku> Right?
05:34:08 <bollu> for then it won't be the sae
05:34:10 <bollu> same*
05:34:11 <bollu> actually
05:34:15 <bollu> let me restate that
05:34:19 <Aku> ya
05:34:27 <bollu> one or more == once then (zero or more)?
05:34:31 <bollu> be back in 10
05:34:33 <bollu> think about this for a while
05:34:35 <bollu> OK?
05:34:40 <bollu> and if you get it
05:34:47 <Aku> ya 
05:34:49 <bollu> replace the "then" with `pThen`
05:34:56 <bollu> and zero or more is the same pZeroOrMore
05:35:04 <Aku> okay
05:35:10 <bollu> but we need to see how to correctly use pThen
05:35:13 <bollu> think about how
05:35:16 <bollu> I'll be back in 10
05:35:23 <Aku> fine
05:35:26 <bollu> (notice that we are now definition zeroOrMore and oneOrMore in terms of each other)
05:35:53 <Aku> yes that's confusing
05:46:20 <rmrfroot> anyone know of a library similar to `System.Process` that uses Text instead of String?
05:47:00 <sternmull> rmrfroot: https://hackage.haskell.org/package/process-extras
05:47:22 <rmrfroot> sternmull: thank you! 
05:49:17 <Someguy123> hey guys, I'm trying to install hledger, but I'm running into issues with hsc2hs: https://gist.github.com/Someguy123/2efd8dbaf6b057c070bf05c085e91bd8
05:49:24 <Aku> bollu: I would be back in another hr, dinner :D
05:49:32 <Someguy123> stack solver doesn't help, nor does adjusting the stack.yml
05:56:39 <John[Lisbeth]> does haskell have macros?
05:57:00 <ongy> not the way e.g. C has with CPP, but we have TemplateHaskell
05:57:30 <John[Lisbeth]> is it not possible to program concatenatively in haskell?
05:57:50 <ongy> what's concatenative programming?
05:57:58 <John[Lisbeth]> reverse polish notation
05:58:13 <John[Lisbeth]> every function takes a linked list and returns a linked list
06:00:06 <Axman6> uh, it's sort of possible, but Haskell is not a concatenative language, it is a functional language
06:00:17 <ongy> you'd have to use HList and there's pretty much support from libraries, but I don't think it's impossible. I may be wrong
06:00:24 <ongy> *pretty much no
06:00:32 <Axman6> ongy: it can be done trivially using tuples
06:01:00 <Axman6> http://lambda-the-ultimate.org/node/4448
06:01:09 <ongy> Axman6: tuples aren't linked lists. And I think they have an upper bound of elements
06:01:30 <Axman6> you build the list with tuples
06:01:59 <ongy> but a function that takes more than 17(?) arguments may be a bit weird either way
06:02:04 <Axman6> push :: a -> b -> (a,b), dup :: (a,b) -> (a,(a,b))
06:02:23 <Axman6> all functions take one arguments, even when you're pretending to be concatenative ;)
06:02:33 <John[Lisbeth]> ideally you could do it with currying
06:03:39 <Axman6> John[Lisbeth]: check out the lambda-the-ultimate link above
06:04:53 <Axman6> iirc it's actually possible to even get pretty much the same syntax as say forth. trying to find an example
06:06:18 <Axman6> https://github.com/leonidas/codeblog/blob/master/2012/2012-02-17-concatenative-haskell.md expands on that LTU comment. till trying to find the one with slightly nicer syntax
06:20:07 <hexagoxel> does `frag` run smoothly for anyone? the input lag i see is unbearable.
06:32:29 <rmrfroot> i want safer path handling, been looking at the hackage libraries `pathtype` and `path`, any recommendations?
06:36:37 <AWizzArd> Anybody here who uses Stack via Docker on Windows?
06:37:16 <AndreasK> hexagoxel: Seems normal on my machine
06:38:11 <bollu> Aku: ping
06:38:40 <ongy> bollu: aku said they have to leave for dinner and will be back in ~1hour about 45min ago
06:38:50 <bollu> ongy: ah, OK
06:40:31 <bollu> @msg Aku Sorry I wasn't around, I had to go talk to a friend. I'll be around till ~9ish, and I'll be around from 11PM onwards
06:40:32 <lambdabot> Not enough privileges
06:40:35 <bollu> what?
06:40:42 <bollu> you need privileges to message someone?
06:41:50 <AndreasK> I assume it's to prevent people spamming the bot
06:41:59 <dramforever> hexagoxel: It works for me
06:42:38 <dramforever> @help tell
06:42:38 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
06:42:41 <dramforever> bollu: That? ^
06:43:27 <bollu> dramforever: yes
06:43:40 <dramforever> I can move around and the display reacts pretty much instanenously. 
06:43:50 <dramforever> bollu: I didn't know it changed...
06:44:00 <dramforever> Anyway, good to know
06:44:12 <bollu> @tell Aku Sorry I wasn't around, I had to go talk to a friend. I'll be around till ~9ish, and I'll be around from 11PM onwards
06:44:12 <lambdabot> Consider it noted.
06:44:24 <dramforever> hey
06:44:31 <dramforever> these are different things apparently
06:52:38 <Phillemann> What's the easiest/shortest way to execute an IO action if I have a value inside a Maybe and "return ()" if the Maybe is Nothing?
06:53:40 <Phillemann> I get a bit confused by Maybe being Monad, Foldable and Traversable. ;)
06:53:40 <dramforever> :t for
06:53:42 <lambdabot> (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
06:53:55 <dramforever> Phillemann: You're right about Traversable actually
06:53:57 <Phillemann> Ah, exactly, thanks.
06:54:01 <bollu> dramforever: my god, I had never considered using the traversable instance
06:54:05 <dramforever> oh wait you don't need the result?
06:54:08 <dramforever> :t for_
06:54:10 <bollu> :t for_
06:54:10 <lambdabot> (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
06:54:11 <dramforever> That's a Foldable thing
06:54:12 <lambdabot> (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
06:54:21 <bollu> dramforever: that is glorious
06:54:30 <bollu> dramforever: wait, can you derive traversable on any inductive type?
06:54:50 <dramforever> Sorta, if it's obviously traversable
06:55:03 <dramforever> obviously as to, well, GHC's deriving mechanism can figure it out
06:55:11 <bollu> dramforever: what makes something "obviously traversable"?
06:55:26 <bollu> actually don't answer that
06:55:29 <bollu> I want to figure it out
06:56:19 <dramforever> SPOILER: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-traversable-instances
06:57:22 <dramforever> Actually... Go check it. For *these* things, checking the docs is way better than trail and error.
06:58:39 <dramforever> And yeah, glorious Haskell. Python may amaze you with new libraries you can download. Haskell amazes you with things you thought you knew.
07:03:01 <Aku> bollu: up there?
07:15:04 <hexagoxel> AndreasK: may i ask what os you ran frag on?
07:15:16 <AndreasK> hexagoxel: Window
07:15:17 <AndreasK> s
07:16:13 <hexagoxel> ah, i should try that; perhaps linux glut is at fault.
07:17:19 <Welkin> nvidia is at fault
07:17:22 <Welkin> and ati/amd
07:18:57 <hexagoxel> Welkin: but other engines run smoothly.
07:19:22 <AndreasK> hexagoxel: What fps do you get/how bad is the lag?
07:20:11 <AndreasK> It doesn't feel completely snappy for me either, but wouldn't call it unbearable
07:20:25 <hexagoxel> it displays 60 fps, but i am pretty sure it is not accurate/there is a lot of jitter involved.
07:32:03 <hexagoxel> the main non-subjective issue with input is that it seems to "drop" both keyboard and mouse events: keys easily get stuck, and when you move mouse quick-to-left, slow-to-right, the camera ends in a different spot (and no, i have no acceleration whatsoever).
07:33:10 <ph88^> is there a function that takes a Maybe and a function. When value is Nothing yield Nothing, but if is Just a then apply function to a and return that ?
07:33:21 <hexagoxel> :t maybe
07:33:24 <lambdabot> b -> (a -> b) -> Maybe a -> b
07:33:41 <hexagoxel> :t fmap
07:33:43 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:34:50 <ph88^> oh it's fmap o_O
07:34:54 <ph88^> > fmap (\x -> x + 1) Nothing
07:34:56 <lambdabot>  Nothing
07:36:36 <AndreasK> hexagoxel: The slow on direction/fast the other is expected if you have mouse acceleration enabled (on windows thats on by default iirc). Not sure if thats the case for you
07:39:49 <hexagoxel> let me repeat: i am certain that i have exactly 0 mouse acceleration on the os-level.
07:40:00 <ertes> ph88^: (>>=)
07:40:10 <ertes> or yes, fmap
07:40:58 <AndreasK> hexagoxel: I only ran around a few seconds and at least there i got not stuck keys. But dropping events sounds like a sensible explanation
07:41:39 <ph88^> hexagoxel, i'm trying to use fmap to replace a case statement on a Maybe, can you tell what i'm doing wrong here? https://bpaste.net/show/0459c8ca12d6
07:41:56 <Welkin> ph88^: case expression
07:42:01 <Welkin> it's not a statement
07:42:32 <ph88^> oh ok
07:43:20 <hexagoxel> ph88^: your `go` returns a `Just`, i.e. a Maybe
07:43:53 <hexagoxel> but fmap :: (a -> b) -> Maybe a -> Maybe b
07:44:26 <ph88^> ooh
07:44:44 <hexagoxel> with (=<<) it would be (a -> Maybe b) -> Maybe a -> Maybe b
07:44:47 <ph88^> ye ok, i'm being silly :|
07:45:06 <ertes> > (isqrt 0, isqrt 1, isqrt 2, isqrt 3)
07:45:08 <lambdabot>  (Just 0,Just 1,Nothing,Nothing)
07:45:20 <ertes> @let ifourthRoot x = isqrt x >>= isqrt
07:45:21 <lyxia> ph88^: remove Just line 15
07:45:22 <lambdabot>  Defined.
07:45:24 <hexagoxel> (and you can write `go Refl = f x`)
07:45:30 <ertes> > ifourthRoot 256
07:45:33 <lambdabot>  Just 4
07:46:04 <ph88^> just refactoring lyxia's code xD
07:48:28 <hexagoxel> (also, example f = fmap f . cast  , isn't it?)
07:49:01 <hexagoxel> :t \f -> fmap f . cast
07:49:03 <lambdabot> (Typeable a1, Typeable a) => (a -> b) -> a1 -> Maybe b
07:49:18 <Welkin> :t cast
07:49:20 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
07:49:21 <ph88^> what's cast ?
07:49:36 <Welkin> never seen it
07:49:49 <Welkin> @hoogle cast
07:49:52 <lambdabot> Data.Typeable cast :: forall a b . (Typeable a, Typeable b) => a -> Maybe b
07:49:52 <lambdabot> Data.Bson cast :: (Val a, Monad m) => Value -> m a
07:49:52 <lambdabot> Control.Distributed.Process.ManagedProcess.Client cast :: (Addressable a, Serializable m) => a -> m -> Process ()
07:50:06 <hexagoxel> it is the function right above `eqT` :p
07:50:45 <Welkin> http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Typeable.html#v:cast
07:51:16 <Welkin> not sure when or why you would use this
07:52:05 <ph88^> i guess like unsafeCoerce but then safe :P
07:54:37 <ph88^> why does the test work here https://bpaste.net/show/218564bb5c7c even though i have not put deriving (Typeable) on Foo ?
07:54:51 <Tuplanolla> That's `coerce`, ph88.
07:55:11 <bollu> Aku	is not around I guess?
07:55:15 <bollu> did he come back?
07:56:49 <ph88^> i don't understand this, the function requires that there is a typeclass on the type .. the class is not derived but it works anyway ?!
07:57:59 <Tuplanolla> GHC derives it implicitly, ph88.
07:58:40 <ph88^> that's cheating :P
07:58:49 <Tuplanolla> The alternative was worse.
07:58:57 <bollu> Tuplanolla: which typeckass?
07:59:10 <Tuplanolla> `Typeable`, bollu.
07:59:20 <bollu> oh, OK
08:06:14 <lyxia> ph88^: coerce converts between types with a compile-time proof that they have the same runtime representation, cast checks at compile time whether two types are equal.
08:06:21 <lyxia> ph88^: uh, cast checks at runtime
08:06:56 <ph88^> wouldn't i be better off using coerce then ?
08:07:18 <lyxia> I don't remember what you were trying to do. Both have their uses.
08:07:53 <Welkin> how can it check at runtime?
08:08:01 <Welkin> there is no type information at runtime
08:09:09 <ph88^> lyxia, in a structure like   Foo (Wrap T) (Bar (Wrap T)) (Wrap (Qux T))  i want to find the last T and modify it, i got a library for generics (generics-eot) but i needed a mechanism to check if a value is of a given type
08:09:13 <lyxia> Typeable implies a runtime representation of the type.
08:09:26 <ph88^> yes that's what i expected too
08:10:53 <ph88^> i have now made these two small functions https://bpaste.net/show/46903871298d .. not sure how i'm gonna use them yet
08:11:22 <lyxia> ph88^: Well you want to check whether two types are equal.
08:11:37 <lyxia> ph88^: not whether you can coerce one to the other
08:11:51 <ph88^> ah ok .. i get it ^^
08:12:12 <ph88^> i think the isFoo function is all i need ... but then it will be for T so isT as function name
08:12:44 <Tuplanolla> > coerce (Sum 42) :: Product Int
08:12:46 <glguy> ph88^: This isn't really something that Haskell tries to support. The notion of "the last T in your Foo type" is somewhat vague
08:12:47 <lambdabot>  error:
08:12:47 <lambdabot>      Variable not in scope: coerce :: Sum Integer -> Product Int
08:12:55 <glguy> and not something that Haskell makes easy to talk about
08:13:04 <ph88^> if i put deriving Typeable on a type and i only use functions that do NOT use the extra possibilities that Typeable give you does it slow down the code ?
08:13:40 <lyxia> no it doesn't slow down the code. you're just passing an extra parameter around
08:13:55 <lyxia> the values themselves still keep the same representation
08:14:15 <ph88^> but still type information is stored in the cpu cache right ?
08:14:57 <Welkin> o.o what?
08:15:07 <ph88^> i only use this for testing my code, i think i could eventually move the testing function to a separate module and do standalone deriving of Typeable on my types
08:16:07 <lyxia> GHc derives Typeable for all types
08:16:12 <glguy> no, the type information isn't stored in the "cpu cache"
08:16:29 <lyxia> you don't need to write anything
08:17:11 <ph88^> lyxia, ya i've heard that ghc derives this automatically to do it's job. But afterwards the type information is removed at runtime unless you put deriving (Typeable) isn't that right ?
08:17:48 <lyxia> no... 
08:18:29 <Welkin> there is no type information at runtime
08:18:40 <ph88^> ok let's step back then .. why do you want/need to put deriving (Typeable) on a type when GHC already derives this for all types ?
08:18:43 <Welkin> typeable uses data to represent type information, if I understand
08:18:54 <lyxia> It inserts the type representative when you call a function with a Typeable constraint
08:18:59 <lyxia> ph88^: you don't
08:19:14 <ph88^> oh lol
08:19:22 <lyxia> ph88^: there are bits of code on the web that do because they are old.
08:19:29 <ph88^> ooh right ok
08:20:22 <ph88^> lyxia, what extra parameter was it you were talking about a few lines back ?
08:22:02 <ph88^> i guess a pointer to a thunk with type information ?
08:22:05 <lyxia> ph88^: Typeclasses are desugared into dictionaries.
08:22:33 <lyxia> ph88^: The Typeable typeclass corresponds to a dictionary with a single value, representing the type.
08:23:12 <Tuplanolla> @google scrap your haskell
08:23:14 <lambdabot> https://wiki.haskell.org/Scrap_your_boilerplate
08:23:27 <ph88^> so am i wrong to say that this dictionary with type representation ends up in the cpu cache ?
08:23:33 <Tuplanolla> No, not that one.
08:23:42 <lyxia> ph88^: And a function with a typeclass constraint, f :: C a => f a, gets desugared into a function f :: C a -> f a (where C a is now the type of dictionaries)
08:23:45 <Tuplanolla> @google scrap your type classes
08:23:47 <lambdabot> http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
08:23:48 <lambdabot> Title: Haskell for all: Scrap your type classes
08:23:52 <ph88^> at runtime
08:24:06 <Tuplanolla> Read that article, ph88.
08:24:18 <ph88^> for typeclasses and dictionaries ?
08:24:19 <ph88^> ok
08:24:32 <lyxia> well it's stored somewhere if it didn't get inlined and optimized away.
08:24:40 <centril> If I have data type  data Expr p = = EExpr { _eHist :: XExprHist p , _eXExpr :: XExpr p } | ... where XExprHist, XExpr are type families (open)... is it possible to derive Data for this type ?
08:24:46 <ph88^> that's nice, the article is quite lenghty
08:25:05 <centril> I have managed to derive  Typeable + Generic
08:25:22 <centril> there is no existential quantification in the data type, it is not a GADT
08:25:28 <lyxia> centril: you'll probably need to use standalone deriving
08:25:46 <centril> lyxia: tried that, didn't work :/
08:25:51 <ph88^> ok i go do some groceries and read the article when i come back
08:25:52 <ph88^> thanks guys
08:25:55 <lyxia> but if you have Generic, do you really need Data
08:26:09 <centril> lyxia: everything else (Eq, Ord, Show, Read, Typeable, Generic) works
08:26:19 <lyxia> centril: deriving instance (Data (XExprHist p), ...) => Data (Expr p)
08:26:48 <centril> lyxia: not sure - I was going to use Control.Lens.Plated mostly for uniplating
08:26:48 <lyxia> centril: did you try with the extra constraints there ^
08:27:02 <centril> lyxia: sec, ill paste the code
08:27:34 <cocreature> how do I make a dependency conditional on the GHC version?
08:28:51 <lpaste_> Centril pasted “Core.Plain” at http://lpaste.net/352967
08:28:58 <centril> lyxia: ^
08:29:23 <glguy> cocreature: with flags
08:29:30 <centril> (scroll to the end), also, i have ForallXE (fi :: * -> Constraint p)
08:29:34 <glguy> or actually
08:30:20 <glguy> https://github.com/ekmett/semigroups/blob/master/semigroups.cabal
08:30:34 <glguy> cocreature: e.g. https://github.com/ekmett/semigroups/blob/master/semigroups.cabal#L130-L131
08:30:41 <lyxia> centril: what's the error message
08:30:51 <lyxia> centril: could you paste it below
08:30:58 <cocreature> glguy: great, thanks!
08:31:51 <lpaste_> Centril revised “Core.Plain”: “Core.Plain” at http://lpaste.net/352967
08:31:55 <centril> lpaste_: ^
08:32:33 <glguy> cocreature: But it's quite rare that you should be depending on the ghc version itself
08:32:44 <glguy> cocreature: often you're making decisions based on the base version
08:33:57 <lyxia> centril: somehow it's requiring a Data p constraint
08:34:01 <glguy> and things look like this https://github.com/ekmett/transformers-compat/blob/master/transformers-compat.cabal
08:34:11 <lyxia> centril: (ForallXE Data p, Data p) => ... ?
08:34:50 <centril> lyxia: you're awesome <3
08:34:53 <centril> that fixed it
08:35:03 <cocreature> glguy: hm yeah I guess base makes more sense
08:35:14 <cocreature> although it’s tempting to avoid the flag :)
08:35:51 <glguy> cocreature: The flag setting can be inferred by cabal, so it's not extra work for the user
08:36:07 <cocreature> glguy: but extra work for the person writing the cabal file, i.e. me :)
08:37:10 <lyxia> centril: note that it suggests to "add (Data p) to the context of" the typeclass methods. This is one way to fix it.
08:37:27 <lyxia> centril: (adding the constraint to the instance declaration as a whole)
08:38:20 <lyxia> centril: another one is to redesign the typeclass to include such a constraint, but of course this is not applicable here.
08:38:35 <cocreature> glguy: why are the flags in transformers-compat set to manual: True? shouldn’t they be toggled automatically?
08:38:51 <centril> lyxia: right, ofc =)
08:39:43 <codedmart> If I already have a stack `ReaderT AppConfig (ExceptT ServantErr (LogM IO)) a` and I want to in one area wrap that stack with StateT. In order to lift `App` actions into this do I need to write a `MonadTrans` instance?
08:40:40 <glguy> cocreature: Yeah, you'd think that... I'm not sure
08:42:25 <cocreature> glguy: alright, I’ll sak in #hackage in the hope that one of the cabal devs knows.
08:42:27 <cocreature> *ask
08:49:28 <lyxia> codedmart: what's App
08:49:34 <lyxia> no pun intended
08:49:45 <bollu> Aku	hey
08:49:52 <bollu> oh
08:49:54 <bollu> he's not around
08:50:05 <codedmart> lyxia: `ReaderT AppConfig (ExceptT ServantErr (LogM IO)) a` this is App in my stack.
08:50:35 <lyxia> codedmart: And you want StateT s App ?
08:50:42 <Athas> I'm getting a segfault from a program compiled with GHC 8.0.2.  Any advice on how to go about debugging this?
08:50:58 <lyxia> codedmart: this just uses StateT's lift.
08:53:34 <lyxia> Athas: you could wrap your unsafe operations with "trace" to get an idea of where you get stuck
08:55:08 <codedmart> lyxia: Hmm... I tried that but I get this error `Couldn't match type ‘t0 App’ with ‘StateApp’`
08:55:52 <Athas> lyxia: I don't have any unsafe operations, but maybe my dependencies have.  Oh well.
08:56:06 <lyxia> Athas: ouch...
08:56:57 <lyxia> codedmart: did you mean to wrap it in newtype? then you would need to write/derive that instance
08:57:12 <codedmart> Ah
08:57:14 <lyxia> codedmart: but it would be simpler to just use a type synonym
08:57:14 <codedmart> right
08:58:28 <ph88^> codedmart, you need the ReaderT and StateT for different contexts ?
09:00:44 <codedmart> ph88^: Mostly trying something. This is one specific section that I need some state (possibly).
09:01:29 <ph88^> what are you using for the frontend these days ?
09:04:46 <codedmart> Maybe I am going about this all wrong though.
09:05:26 <codedmart> I am working on my own setup to write records to csv.
09:08:36 <codedmart> Where I am hitting a problem is say a `User's` addresses. They can request say `("Address Street One", "addresses.streetOne"), but I need to be able to find how many addresses there are and change this `("Address Street One", "addresses.streetOne")` to `[("Address 1 Street One", "addresses.1.streetOne"), ("Address 2 Street One", "addresses.2.streetOne"),
09:08:36 <codedmart> ...]`. I write to file in batches so memory usage stays down.
09:10:39 <codedmart> My initial idea was I would track in state whether or not I was in the firstBatch and handle the header after I have the firstBatch but before I write then just handle the remaining batches. But maybe I am complicating things and going about this wrong.
09:15:36 <Aku> bollu: up there?
09:15:48 <bollu> yes
09:15:50 <bollu> OK, cool
09:15:54 <bollu> so, we were at one or more, right?
09:16:02 <bollu> one or more = one `then` zero or more?
09:16:04 <bollu> do you see that?
09:16:05 <Aku> ya
09:16:08 <bollu> OK
09:16:09 <bollu> so now
09:16:13 <bollu> we know how to write this :)
09:16:13 <Aku> ya
09:16:20 <bollu> can you paste your code again please?
09:16:25 <Aku> yes
09:17:16 <lpaste_> Aku revised “pOneOrMore”: “pOneOrMore” at http://lpaste.net/5688715794511298560
09:17:45 <Someguy123> hey guys, I'm trying to install hledger, but I'm running into issues with hsc2hs: https://gist.github.com/Someguy123/2efd8dbaf6b057c070bf05c085e91bd8
09:17:48 <Someguy123> stack solver doesn't help, nor does adjusting the stack.yml
09:17:50 <bollu> (you can just post the link :) )
09:17:59 <bollu> yeah so
09:18:04 <Aku> ohhkay
09:18:14 <Aku> I have one more doubt
09:18:23 <bollu> sure
09:18:24 <bollu> go ahead
09:18:37 <Aku> [(combine v1 v2, toks2) | (v1,toks1) <- p1 toks, (v2, toks2) <- p2 toks1]
09:18:44 <Aku> consider that
09:18:44 <bollu> yes
09:18:53 <bollu> OK
09:19:01 <Aku> p1 toks returns a list
09:19:09 <bollu> correct
09:19:17 <Aku> but a writing the tuple (v1,toks1) <- p1 toks
09:19:25 <bollu> it returns a list of tuples
09:19:33 <bollu> so when you pattern match
09:19:33 <Aku> shouln't it be [(v1,toks1)] <- p1 toks
09:19:36 <bollu> no
09:19:42 <bollu> that's not the way the list pattern match works, right?
09:19:48 <bollu> > [x * 2| x <- [1..10]]
09:19:51 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
09:19:53 <c_wraith> you can pretend <- strips off the top-level type constructor.
09:19:58 <bollu> we don't say [x] <- [1..10]
09:20:11 <c_wraith> It's not quite what really happens, but it's a good first intuition
09:20:27 <Aku> ohhkay
09:20:32 <bollu> c_wraith: it gets desugared to maps and filters right?
09:20:48 <c_wraith> bollu: in [], it's actually concatMap
09:21:13 <bollu> c_wraith: oh, right
09:21:19 <bollu> Aku: ok, well, so
09:21:28 <Aku> ya
09:21:44 <bollu> Aku: in  (v1, toks1) <- p1 toks, the (v1, toks1) is a stand-in for _every_ tuple in the list
09:21:50 <bollu> it's like set builder notation
09:22:00 <Aku> ohh..there u go,got it
09:22:05 <bollu> OK
09:22:09 <bollu> so now
09:22:21 <Aku> lets proceed to pOneOrMore
09:22:22 <bollu> we were contemplating how to write one or more
09:22:23 <bollu> yeah
09:22:39 <bollu> we can say pOneOrMore p = pThen ??? p  (pZeroOrMore p)
09:22:51 <bollu> do you agree that the types match first of all?
09:22:54 <bollu> (ignore the ??? for now)
09:23:01 <Aku> no bcoz pThen returns Parser p
09:23:06 <bollu> yes
09:23:12 <bollu> and what is the type of pOneOrMore?
09:23:15 <Aku> we want Parser [a]
09:23:23 <bollu> no, look at the type of pThen carefully
09:23:29 <bollu> it returns whatever we instruct it to
09:23:31 <Aku> I mean [[a],[Token]]
09:23:33 <bollu> with the first paramter
09:23:53 <bollu> Aku: err, I think you mean [([a], [Token])]
09:23:55 <bollu> but yeah
09:23:59 <Aku> yeah
09:24:02 <bollu> pThen :: (a->b->c) -> Parser a-> Parser b-> Parser c
09:24:10 <bollu> ^ so the return type of the pThen (Parser c)
09:24:13 <bollu> is upto us to decide
09:24:22 <Aku> ya correct
09:24:24 <bollu> if we can combine the Parser a and Parser b in a "correct" way
09:24:27 <bollu> then we can make it work
09:24:29 <bollu> so in this case
09:24:31 <Aku> ya right
09:24:35 <bollu> let's see what we are forced to create
09:24:41 <Aku> yup
09:24:51 <bollu> pOneOrMore p = pThen foo p  (pZeroOrMore p)   | we shall figure out the type of "foo" now
09:25:06 <bollu> pThen :: (a->b->c) -> Parser a-> Parser b-> Parser c
09:25:16 <bollu> so, we know that pOneOrMore has return type "Parser [a]"
09:25:24 <bollu> so that means Parser c ~ Parser [a]
09:25:26 <bollu> agreed?
09:25:31 <Aku> agreed
09:25:37 <bollu> OK
09:25:46 <bollu> now we know that "p" has type Parser a
09:25:52 <Aku> yes
09:25:59 <bollu> so therefore Parser a ~ Parser a
09:26:06 <Aku> yesp
09:26:09 <Aku> yep
09:26:10 <bollu> we also know that (pZeroOrMore p) :: Parser [a]
09:26:18 <bollu> so therefore (Parser b ~ Parser [a]) ?
09:26:22 <Aku> yep
09:26:25 <bollu> hence
09:26:35 <bollu> the type of our invocation of pThen becomes
09:26:48 <bollu> pThen :: (a->b->c) -> Parser a-> Parser b-> Parser c where a = a, b = [a], c = [a]?
09:27:00 <Aku> yes
09:27:01 <bollu> which is
09:27:17 <bollu> pThen :: (a->[a]->[a]) -> Parser a-> Parser [a]-> Parser [a]?
09:27:22 <bollu> correct?
09:27:25 <Aku> yes
09:27:34 <bollu> so, now, we need to find out which foo :: a -> [a] -> [a] to use
09:27:39 <bollu> we know what we want pThen to do
09:27:44 <Aku> so foo::(a->[a]->[a])
09:27:47 <bollu> yes
09:27:50 <Aku> yep
09:27:53 <bollu> but now we need to find out _which_ foo to use
09:27:54 <bollu> now
09:28:08 <Aku> okay
09:28:21 <bollu> we know what (pOneOrMore p = pThen foo p  (pZeroOrMore p) ) should do
09:28:37 <bollu> we need it to take the output of the "p" parser, and then prepend it to the "pZeroOrMore p"
09:28:54 <bollu> do you understand that bit?
09:28:59 <bollu> if not, I can explain
09:29:09 <Aku> hmm..right keeping the Token string returned unchanged!
09:29:15 <Aku> Is it?
09:29:21 <bollu> no, that's not the point
09:29:23 <bollu> the point is
09:29:37 <bollu> "foo" controls how the output of the first parser and the second parser are combined
09:29:39 <Aku> ya explain!
09:29:39 <bollu> in this case
09:29:45 <Aku> yes
09:29:48 <bollu> we know that our first parses parses first, then the second parser runs
09:29:49 <Aku> right
09:29:55 <Aku> yes
09:29:55 <bollu> so when we "fuse" the two parsers into one
09:30:06 <Aku> ya
09:30:10 <bollu> we need to take the output of the first parser, and *prepend* it to the list parsed by the second parser
09:30:25 <bollu> because the second parser produces a _list_ of output
09:30:26 <Aku> ya fine
09:30:29 <bollu> right?
09:30:32 <Aku> ya right
09:30:33 <bollu> so, we know what foo should to
09:30:35 <Aku> clear !
09:30:37 <bollu> should do*
09:30:49 <bollu> it should prepend the first parameter to the second parameter
09:30:55 <bollu> now, which is the haskell function that does this?
09:30:56 <Aku> ya
09:31:06 <Aku> :
09:31:11 <bollu> correct
09:31:15 <bollu> so our implementation becomes
09:31:18 <Aku> Cool!
09:31:28 <bollu> pOneOrMore = pThen (:) p (pZeroOrMore p)
09:31:30 <bollu> makes sense?
09:31:34 <Aku> This is awesome!
09:31:40 <Aku> yes..makes sense
09:31:41 <bollu> yeah :D
09:31:44 <bollu> parser combinators are slick
09:31:52 <Aku> Let me try out
09:31:55 <bollu> notice the cool thing: we are definition pZeroOrMore and pOneOrMore in terms of each other
09:31:56 <bollu> sure
09:32:07 <Athas> Hm, it looks like my happy-generatd parser segfaults.
09:32:56 <Aku> Ya also tell me how pEmpty works?
09:33:09 <Aku> and then overall pZeroOrMore!
09:33:19 <Aku> How it works!
09:33:27 <Aku> I want it to be crystal clear
09:33:43 <bollu> uh, paste the link again please
09:33:49 <Aku> ya
09:33:49 <bollu> pZeroOrMore is the same logic
09:33:55 <Aku> http://lpaste.net/5688715794511298560
09:34:19 <bollu> could you add pZeroOrMore and the rest of it into the file?
09:34:35 <Aku> It does not have it, its in the book, 'pEmpty'
09:34:55 <bollu> so implement it
09:35:04 <Aku> yes
09:35:48 <bollu> ok so
09:35:51 <bollu> I'm guessing
09:36:04 <bollu> pZeroOrMore p = pAlt pEmpty  p?
09:36:05 <bollu> correct?
09:36:43 <Aku> yup 
09:36:45 <Aku> correct
09:36:52 <bollu> yeah so
09:36:54 <bollu> basically
09:36:59 <bollu> wait, write the code in lpaste
09:37:06 <bollu> so we can concretely talk about it
09:37:11 <Aku> okay
09:38:13 <Aku> one sec...what are the arguements to pOneOrMore?
09:38:29 <bollu> it depends on how you write it
09:38:32 <Aku> its pOneOrMore p1 toks
09:38:34 <bollu> I take only the parser
09:38:35 <bollu> no
09:38:38 <bollu> we don't take the toks
09:38:41 <bollu> since we are building a parser
09:38:44 <Aku> ya you take the parser
09:38:46 <bollu> using the other combinators
09:38:48 <Aku> right
09:39:00 <bollu> we are not "defining" a parser by taking the [Token] in the "final" parser
09:39:22 <Aku> okay
09:40:12 <Aku> Thanks a lot bollu
09:40:18 <bollu> np
09:40:23 <bollu> yeah, no
09:40:25 <bollu> yeah, so*
09:40:31 <bollu> update the paste? :)
09:40:32 <Aku> The way you explained..just awesome!
09:40:42 <Aku> ya one min
09:41:30 <bollu> preludeDefs are used to have something to start to use the machine with BTW
09:41:54 <lpaste_> Aku revised “pOneOrMore”: “pOneOrMore” at http://lpaste.net/5688715794511298560
09:42:29 <Aku> Now i want to write pEmpty
09:42:45 <bollu> pEmpty does nothing
09:42:48 <bollu> it simply returns []
09:42:58 <bollu> wait, are you sure that is the signature?
09:43:03 <bollu> oh yeah
09:43:10 <Aku> yes
09:43:19 <bollu> OK
09:43:19 <bollu> so
09:43:26 <bollu> pempty doesn't "fail"
09:43:40 <bollu> it simply consumes no input
09:43:43 <bollu> which means
09:43:45 <Aku> ya I dont exaclty understand what pEmpty is doing
09:43:55 <bollu> pEmpty a input = [(a, input)]
09:44:01 <Aku> ya it consumes no input
09:44:04 <bollu> it simply "pretends" to have parsed the input
09:44:09 <bollu> and puts an "a" as the output
09:44:22 <bollu> it's a way of saying "don't take any input, but act like you have gotten this output from parsing"
09:44:26 <Aku> ohhkay
09:44:26 <bollu> this is required
09:44:43 <bollu> because we need a way to have an empty list be retuened from pZeroOrMore
09:44:55 <bollu> if we just did pZeroOrMore = pOneOrMore p 
09:45:05 <bollu> this will fail if we have zero inputs
09:45:07 <bollu> so we say
09:45:12 <bollu> pZeroOrMore p = (pOneOrMore p) ‘pAlt‘ (pEmpty [])
09:45:14 <bollu> which means
09:45:18 <bollu> "try to parse with one or more"
09:45:35 <bollu> "if this doesn't work, then pretend you parsed an empty list"
09:45:39 <Aku> okay what is the input to pEmpty?
09:45:40 <bollu> which is morally correct
09:45:47 <Aku> How to interpret that>
09:45:48 <Aku> ?
09:45:49 <bollu> the input to pEmpty is what the parser should retun
09:45:56 <bollu> it's the output of the parser
09:46:03 <bollu> the parser doesn't _actually_ consume input
09:46:07 <bollu> but it still needs to produce output
09:46:11 <bollu> so what output should it produce?
09:46:18 <bollu> you need to _tell_ it what output to produce
09:46:20 <bollu> that is the "a"
09:46:23 <bollu> you return a Parser a
09:46:33 <bollu> which takes no input and produces the output you asked it t
09:46:35 <bollu> to*
09:47:03 <Aku> ohhkay
09:47:06 <Aku> got it
09:47:27 <bollu> which is why pEmpty a = \tok -> [(a, tok)]
09:47:34 <bollu> you simply accept the input stream
09:47:42 <bollu> and the "put" the a on the output stream
09:47:48 <bollu> while consuming none of the "tok"
09:47:51 <bollu> cool?
09:48:00 <Aku> Cool!
09:48:01 <bollu> so, I gotta run
09:48:07 <Aku> ya fine
09:48:08 <bollu> if you have questions, ping me when I am back
09:48:10 <bollu> or ask the channel
09:48:13 <Aku> Sure Thanks
11:04:06 <saketrule> hello
11:04:21 <Aku> hello
11:04:37 <saketrule> akash kay katos
11:04:56 <saketrule> how do i start learning haskell
11:04:58 <saketrule> ?
11:05:00 <saketrule> ??
11:05:01 <saketrule> ?
11:05:07 <saketrule> From the start :>
11:05:07 <Aku> type username : and then your query!
11:05:26 <Aku> saketrule: Hey!
11:05:26 <saketrule> Aku: Hi Akash
11:05:32 <Aku> ^this way
11:05:37 <Aku> yup
11:05:46 <saketrule> Ajun konich nahiye aapala
11:05:49 <shapr> howdy Aku 
11:06:03 <saketrule> shapr: yo man
11:06:07 <shapr> saketrule: är du sakert det är en bra idee?
11:06:39 <shapr> eftersom jag tror att det finns en kanal för din språk :-)
11:06:56 <saketrule> shapr: You from Sweden?
11:07:18 <shapr> saketrule: nah, I'm from Alabama
11:07:31 <shapr> The Swedish speaking part of Alabama
11:07:32 <saketrule> shapr: I know where you live
11:07:36 <shapr> saketrule: ooh, really?
11:07:44 <shapr> where? I'm lost :-(
11:07:47 <saketrule> shapr: yes
11:07:55 <mw> shapr: finns det en svensktalande del av alabama?
11:07:58 <saketrule> shapr: look to your left
11:08:34 <shapr> mw: naturligtvis! var jag sitter!
11:08:41 <shapr> saketrule: that's not you
11:09:29 <saketrule> shapr: Jag menar, till din andra vänster
11:09:46 <Aku> han skojar
11:10:14 <mw> haha, antar att det är en hel del google translate inblandat här
11:10:21 <Aku> howdy saketrule
11:10:26 <mw> sorry for OT, I was mostly surprised :)
11:10:36 <mauke> that sounds like a very small part
11:10:43 <shapr> mw: jag bodde i svenska fem år :-)
11:10:46 <Tuplanolla> I had to learn Swedish... for this.
11:10:59 <shapr> wait, you speak Swedish too?
11:11:10 <shapr> mw: sverige, whatever
11:11:18 <Tuplanolla> I'd rather not.
11:11:23 <shapr> aww, ok
11:11:34 <shapr> puhutko suomea?
11:11:35 <saketrule> ja
11:11:40 <saketrule> shapr: ja
11:11:48 <shapr> saketrule: I don't believe you.
11:11:56 <Tuplanolla> The same answer applies.
11:12:11 <mw> saketrule: there are a few pretty good online resources that'll get you started, for the beginner stuff "learn you a haskell for great good" and "real world haskell" are pretty good places to start (I think)
11:12:16 <saketrule> shapr: Joo
11:12:36 <shapr> saketrule: mujhi nahi pata
11:12:58 <saketrule> kyu nahi pata
11:13:04 <Tuplanolla> @google github learn haskell repository
11:13:05 <lambdabot> https://github.com/bitemyapp/learnhaskell
11:13:19 <Tuplanolla> That should get you started and some.
11:13:31 <saketrule> Thanks Tuplanolla
11:13:35 <saketrule> Thanks mw
11:13:48 <saketrule> I am off to learn Haskell
11:13:57 <saketrule> Good Night
11:14:04 <saketrule> Sweet Dreams
11:18:25 <centril> I have a bunch of deriving instance ForallXE MyClass p => MyClass (MyType p)  declarations i need to automate... is there some way to do this with template haskell ?
11:19:11 <centril> Otherwise I will have approx 25 * 7 standalone derives in the file, which is a lot...
11:20:06 <Tuplanolla> Short answer: yes, centril.
11:20:27 <edwardk> there is always a way to do it with template haskell, the question is, is it worth your soul?
11:20:36 <jmcarthur> It is possible, but I claim that duplication which is obviously and highly regular is usually just not that bad. Sometimes there are ways that the regularity is less obvious, and then these space-saving abstractions can become worth it.
11:20:52 <centril> Tuplanolla: do you have some reading to do ?
11:21:21 <centril> jmcarthur, edwardk: right, but this is 175 derives...
11:21:27 <centril> Tuplanolla: reading to link to *
11:21:34 <edwardk> stare too long into template haskell and template haskell stares back into you. Your code start sprouting random Qs, and quasiquoters and never again is understood by mere mortals
11:21:37 <Tuplanolla> You should be able to start from the GHC user guide and related library documentation, centril.
11:22:12 <centril> btw, is edwardk  Edward Kmett ?
11:22:13 <Tuplanolla> Basically you want to define a function that returns `Q [Dec]` and then splice it in with `$(f x y z)`, centril.
11:22:15 <edwardk> centril: to be honest? it'd be a one liner to write the function that makes that instance for a given type constructor, and a mapM would spew out all the declaration you needed over a list of such constructors
11:22:17 <edwardk> yeah
11:23:13 <centril> edwardk: right, I have some reading to do then =)
11:24:31 <edwardk> you basically need to make some function like foo x = [d| instance ... $x ... |] with some $x in there for the bits you want to replace, or to use the combinators rather than such a splice, then just put in a splice $(forM ['Whatever, 'You, 'Need] foo)
11:25:03 <edwardk> its actually pretty straightforward
11:25:24 <centril> edwardk: right, im a total newbie to writing my own template haskell, so where is d defined ([d|...|] ?
11:25:50 <edwardk> that is one of the splice types, saying you're splicing together a declaration, rather than an expression
11:26:03 <edwardk> the result of that is a Q Dec
11:26:15 <edwardk> the forM or mapM us being used to make a Q [Dec]
11:26:23 <edwardk> which is suitable to being spliced in at the top level
11:26:37 <centril> edwardk: yeah, the forM part I get, it is the Q [Dec] part that was more tricky =)
11:27:08 <edwardk> $(...) takes a Q Exp if you use it in an expression context like foo = $(whatever)
11:27:19 <edwardk> and it takes a Q Dec or a Q [Dec] when used at the top level
11:27:42 <edwardk> basically you can splice a single or multiple statements
11:28:04 <centril> I guess it would be optimal to take two lists of names, one for the class, one for the types, and then "multiply" them and forM it
11:28:21 <edwardk> you can make your own quasiquoters for your own little languages and then use them with [$whatever| ... |] but the [d| |] one is magic
11:28:36 <edwardk> centril: yeah
11:28:46 <centril> edwardk: right, but the [d||] one, where is it defined? like in what module/package ?
11:28:56 <edwardk> foo x y = [d| instance ... $x ... $y ... |]
11:29:14 <edwardk> its baked into the language when you turn on QuasiQuotes and TemplateHaskell or whatever you get it
11:29:28 <centril> edwardk: ah, nice =)
11:29:28 <edwardk> [d| is syntax
11:30:00 <centril> edwardk: btw... have you like written every package that is on hackage? it is impossible to not find your name on like everything :P
11:30:15 <edwardk> i gave it a good ole college try =)
11:30:33 <centril> ;)
11:30:46 <edwardk> at last check i think i had more packages on there than anybody, but snoyman may have caught up while i was sick ;)
11:31:14 <edwardk> yeah, he has me beat
11:31:23 <centril> edwardk: damn, you have some work to do
11:31:37 <Tuplanolla> What if you measure dependencies instead, edwardk?
11:31:52 <edwardk> Tuplanolla: i'm pretty sure i come out ahead there
11:31:55 <glguy> Snoyman wins on using dependencies
11:32:13 <glguy> stack used so many it wouldn't compile on macOS until they adapted in 8.0.2
11:32:15 <edwardk> or not i guess
11:32:44 <edwardk> i was thinking more about people who incur dependencies on the package than the number you incur going out
11:33:06 <glguy> Oh, I wasn't attempting to weigh in on that case :)
11:33:09 <edwardk> e.g. http://packdeps.haskellers.com/reverse/lens vs. http://packdeps.haskellers.com/reverse/yesod
11:34:17 <edwardk> there i know i get a bunch of random support emails from folks in the strangest walks of life using my code for things i never anticipated.
11:36:30 <mangobot> why do i get the parse error on '|'  in this case? http://lpaste.net/352970 using the guards wrong? i want to compare w1 to w2 
11:37:14 <glguy> mangobot: You shouldn't have "= (((wert (f1 w1)) (wert (f2 w2)))" before the guards
11:37:21 <lpaste_> Centril pasted “template-haskell-standalone-deriving” at http://lpaste.net/352972
11:37:28 <centril> edwardk: ^
11:37:40 <mangobot> glguy how do i apply ths function first to get the wert of f1 and f2?
11:38:12 <centril> edwardk: found this: http://stackoverflow.com/questions/14316656/standalone-deriving-declaration-in-template-haskell-quotation   dont know if it still applies...
11:38:15 <edwardk> does TH do standalone deriving statements?
11:38:21 <glguy> mangobot: In this case you don't need to, you're not using the result of that application
11:38:41 <mangobot> i can just use f1 == f2 = true?
11:38:45 <mangobot> w1 == w2*
11:39:04 <edwardk> which classes are you looking to produce btw?
11:39:06 <glguy> mangobot: Yeah. You don't even need to use guards. You can just return w1 == w2 as the result
11:39:23 <mangobot> glguy thanks!
11:39:26 <centril> edwardk: Eq, Ord, Show, Read, Typeable, Generic, Data
11:39:48 <edwardk> ok. you're in luck. modern TH has a StandaloneDerivD constructor in Dec
11:40:04 <mangobot> glguy i wantt o learn to use the guards though, even without the wert function it says that there is a parsing error :( dont get it
11:40:04 <edwardk> :t Language.Haskell.TH.StandaloneDerivD
11:40:07 <lambdabot> Language.Haskell.TH.Syntax.Cxt -> Language.Haskell.TH.Syntax.Type -> Language.Haskell.TH.Syntax.Dec
11:40:07 <glguy> edwardk, centril: Yes it does
11:40:13 <edwardk> :t Language.Haskell.TH.standaloneDerivD
11:40:15 <lambdabot> Language.Haskell.TH.Lib.CxtQ -> Language.Haskell.TH.Lib.TypeQ -> Language.Haskell.TH.Lib.DecQ
11:40:36 <edwardk> so you just need to build the context and the type manually if it won't parse
11:40:47 <glguy> e.g. Prelude Language.Haskell.TH> $(stringE . show =<< [d| deriving instance Show Int |])
11:40:48 <glguy> "[StandaloneDerivD [] (AppT (ConT GHC.Show.Show) (ConT GHC.Types.Int))]"
11:41:07 <edwardk> oh it did parse
11:41:48 <glguy> mangobot: I won't be able to guess what you're doing wrong. You'll have to show the changed code
11:42:06 <centril> edwardk: wel, it claimed it was a malformed instance... so I dont know
11:42:22 <glguy> centril: Then show us what you did so we can see how you malformed it
11:42:38 <centril> glguy: i did =) http://lpaste.net/352972
11:42:42 <glguy> mangobot: If I did guess, I'd guess you left the = before the |
11:43:36 <edwardk> you probably can't use antiquotation there and will have to write the standaloneDerivD call
11:43:43 <edwardk> this isn't that bad though
11:44:47 <mangobot> glguy got it, yeah, had to delete the '=' 
11:44:48 <mangobot> glguy thanks
11:45:01 <centril> edwardk: ah, so I have to write the creating function manually then, ... , but I guess I can learn some TH-haskell in the process
11:45:10 <edwardk> its not bad
11:45:54 <centril> seeps pretty straight forward once you know where to begin
11:46:00 <centril> edwardk: the link to the API helped a lot
11:49:34 <edwardk> something like: \x t -> standaloneDerivD [conT ''ForallXE `appT` x `appT` varT (mkName"a")] (appT x (appT t (varT (mkName "a")))
11:49:49 <edwardk> you can clean it up a little by let binding a = varT (mkName "a")
11:50:25 <edwardk> the key here is that the lowercased versions of the constructor names do  everything in the monad
11:50:34 <edwardk> so you have some options
11:51:11 <centril> edwardk: right, so a == p in this case
11:51:38 <edwardk> \x t -> let a = VarT (mkName "a") in StandaloneDeriveD [ConT ''ForallXE `AppT` x `AppT` a] (AppT x (AppT t a))
11:51:46 <edwardk> that gives you a pure function that returns a 'Dec'
11:52:08 <glguy> becareful that you aren't using 'a' anywhere in the type you passed in
11:52:49 <edwardk> yeah, in the monad you can make sure that it generates a type variable 'with a name like a' that is distinct from any other
11:53:00 <edwardk> outside the monad like this you risk name capture
11:53:50 <edwardk> anyways with that you should be able to do something like $(foo <$> classes <*> types)
11:53:56 <centril> edwardk: not sure i follow - why would it capture a / p ?
11:54:17 <centril> since it is introduced in the deriving thingy
11:54:30 <lpaste_> glguy pasted “for central” at http://lpaste.net/352973
11:54:32 <edwardk> consider if you passed in a type like (ConT ''Whatever `AppT` VarT (mkName "a")) as one of the types.
11:54:48 <glguy> autocorrect ate your name, centril
11:54:51 <edwardk> then you get a big statement where the same type variable name was used
11:55:15 <edwardk> i prefer glguy's version, less messy
11:55:41 <centril> glguy: nice, thanks =)
11:55:46 <edwardk> pure . VarT = varT?
11:55:50 <glguy> oops, pure . VarT
11:55:55 <glguy> yeah, already edited the paste
11:56:08 <edwardk> thats pretty much optimal then =)
12:01:40 <centril> glguy: hmm, where is   ctx :: [TH.TypeQ] -> TH.CxtQ   coming from ?
12:02:23 <centril> nvm =)
12:04:27 <glguy> edwardk: I started factoring out the logic for normalizing reified DataD/NewtypeDs which can deal with the new gadt syntax stuff from GHC 8 and then basing lens code on that https://github.com/glguy/lens-th/blob/master/src/Test.hs
12:05:00 <edwardk> nice
12:05:08 <glguy> I needed the normalizing pass that existing lens does part of in other code
12:07:29 <glguy> Gives a nicer view of constructors https://github.com/glguy/th-abstraction/blob/master/src/Language/Haskell/TH/Datatype.hs#L58-L65 than Con
12:13:19 <johnw> cocreature: ping
12:13:20 <centril> edwardk, glguy: got problems with GHC stage restrictions... should I take ForallXE as a parameter to fix this?
12:14:20 <cocreature> johnw: pong
12:22:06 <mangobot> if there is one card Card and list of cards [Cards], data Card = Card Color Num, how can i use the filter function to filter the list for only the cards that have the same Num as this card in the argument? http://lpaste.net/352970
12:22:26 <mangobot> cant get the syntax correctly
12:24:01 <mangobot> \(c n) -> n == ...? how to i acces the second elem in every tupels from the [Cards] list
12:24:20 <Akii> on it
12:24:48 <Akii> http://lpaste.net/352970
12:24:50 <Akii> that might work
12:25:08 <Akii> might require lambda case lang extension
12:26:36 <edwardk> centril: how so?
12:26:42 <mangobot> Akii thanks! will check now
12:26:59 <edwardk> so long as the sections read top to bottom through the file you should be okay
12:27:16 <edwardk> that everything you need to be in scope in the slice is defined above the slice
12:27:22 <edwardk> er splice
12:27:57 <Akii> whats this function called that interleaves lists?
12:28:16 <centril> edwardk: moved it to a new file instead, which works too :)
12:28:21 <edwardk> k
12:28:38 <hexagoxel> Akii: intersperse/intercalate (?)
12:29:54 <Akii> :o
12:30:17 <Akii> I thought there was a function that would [a] -> [a] -> [a]
12:30:49 <Akii> take one from the first, then the second, then the first again
12:35:07 <hexagoxel> join . transpose?
12:35:42 <hexagoxel> Akii: ^
12:35:53 <monochrom> @type join . transpose
12:35:56 <lambdabot> [[a]] -> [a]
12:36:23 <hexagoxel> > join . transpose $ [[1,2,3], [4,5,6]]
12:36:26 <lambdabot>  [1,4,2,5,3,6]
12:37:55 <Akii> I should take a look at list comprehensions http://hackage.haskell.org/package/base-4.9.1.0/docs/src/Data.OldList.html#transpose
12:39:42 <tfc[m]> if i have a "Just (Just 1, Just 2)", but i want Just (1,2) from this, or Nothing if anything is nothing related in there, how do i do this?
12:42:49 <hpc> :t join . fmap uncurry
12:42:50 <lambdabot> ((a1, b) -> a1 -> b -> a) -> (a1, b) -> a
12:42:55 <hpc> well that's not remotely it
12:43:10 <kadoban> tfc[m]: An explicit case sounds like the easiest way to me.
12:43:15 <hpc> yeah
12:43:28 <hpc> once you get it to Just (Just (1, 2)), you can use join as well
12:43:37 <hexagoxel> :t (>>= uncurry (liftA2 (,)))
12:43:39 <lambdabot> Monad m => m (m a, m b) -> m (a, b)
12:43:52 <hpc> :t \(x, y) -> do {a <- x; b <- y; return (a, b)}
12:43:53 <kadoban> Nice
12:43:55 <lambdabot> Monad m => (m t, m t1) -> m (t, t1)
12:44:21 <hexagoxel> explicit case probably still is better :)
12:44:23 <hpc> don't try and golf it like we just did though
12:44:39 <Tuplanolla> No! Lenses!
12:44:40 <tfc[m]> lol so many ways. :D
12:44:45 <kadoban> Probably, but it's still cool.
12:44:50 <Tuplanolla> > preview (_Just . both . _Just) (Just (Just 1, Just 2)) :: Maybe Int
12:44:55 <lambdabot>  Just 1
12:44:59 <tfc[m]> ok whats the lens way?
12:45:01 <hpc> we have to write it on one line because it's irc, but use the abstractions we do to write it more nicely
12:47:55 <tfc[m]> hm i am not really getting it
12:48:25 <tfc[m]> can you help me with a working example that transforms Just (Just "foo", Just "bar") to Just ("foo", "bar") ?
12:49:03 <tfc[m]> i am not getting the proposals to run in ghci with my example value
12:51:03 <tfc[m]> oh wait sry
12:51:11 <hexagoxel> Tuplanolla: result should be Maybe (Int, Int)
12:51:22 <kadoban> \x -> case x of (Just (Just a, Just b)) -> Just (a,b)     _ -> Nothing
12:51:25 <tfc[m]> so i need liftA3 (,,)because i have Just (Just 1, Just 2, Just 3)
12:51:29 <Tuplanolla> Oh, right, hexagoxel.
12:51:31 <tfc[m]> but that doesnt work with uncurry...
12:52:00 <kadoban> You'd probably have to write an uncurry3
12:52:15 <tfc[m]> oh then the case is by far easier.
12:53:47 <Tuplanolla> How do you even define a tuple analogue for `toListOf`?
12:57:32 <hexagoxel> > join . fmap (each id) $ Just (Just 'a', Just 'b')
12:57:36 <lambdabot>  Just ('a','b')
12:58:11 <hexagoxel> and that is (>>=) of course
12:58:26 <hexagoxel> > (>>= each id) $ Just (Just 'a', Just 'b')
12:58:30 <lambdabot>  Just ('a','b')
12:58:46 <hexagoxel> well, lens golfing successful
12:59:05 <Tuplanolla> Very nice.
13:35:52 <glguy> > (=<<) bisequence $ Just (Just "foo", Just "bar") -- if you want to sick to "base"
13:35:55 <lambdabot>  Just ("foo","bar")
13:41:11 <maerwald> > bisequence =<< Just (Just "foo", Just "bar")
13:41:14 <lambdabot>  Just ("foo","bar")
13:45:02 <T0pH4t> hello all, quick question. What does ghc prof output mean when you have a type followed by (...). For example foo.(...)
14:34:09 <bollu> HoTT question: how is the expression refl_x . refl_x well typed? refl_x is an inhabitant of the type (x =A x) where (x : A). Hence, it makes no sense to talk about "composition of refl"
14:34:12 <bollu> so, like, what am I missing?
14:37:02 <EvanR> you can join paths from x to x with other paths to x to x
14:37:15 <EvanR> like you can compose id :: a -> a
14:37:17 <EvanR> with itself
14:37:30 <EvanR> or any other function from a to a
14:37:47 <bollu> EvanR: but according to HoTT, refl_x is _not_ a function, is it?
14:37:53 <bollu> it's an inhabitant of (x =A x)
14:37:57 <EvanR> no, its not function composition
14:38:00 <bollu> then?
14:38:01 <bollu> ohh
14:38:09 <bollu> it's a different operator for "path composition"?
14:38:10 <EvanR> its implication
14:38:18 <bollu> I don't see how
14:38:19 <EvanR> if a = b, and b = c, then a = c
14:38:58 <EvanR> "facts" of equality forms a category (and a groupoid thanks to symmetric property)
14:39:07 <bollu> no, I mean
14:39:22 <EvanR> the . you mentioned is the groupoid operation
14:39:22 <bollu> so, the type of the (.) operator is (a =A b) -> (b =A c) -> (a =A c) ?
14:39:25 <bollu> I see
14:39:33 <EvanR> yes
14:40:05 <bollu> ahh, OK :)
14:40:08 <bollu> much appreciated
14:41:01 <EvanR> also theres a dedicated hott channel
14:41:57 <bollu> I asked there
14:42:02 <bollu> I got an answer first here :)
14:42:18 <EvanR> bets hedged
14:42:31 <bollu> xD
14:43:37 <Tuplanolla> How should I connect two brackets seamlessly? Let's say I `(conn, _) <- accept sock` and then `socketToHandle conn ReadWriteMode`.
14:43:58 <Tuplanolla> I want to cancel the "release resource" part of `accept` only if `socketToHandle` is successful.
14:44:27 <EvanR> nest two brackets?
14:44:47 <Tuplanolla> That could result in a double close, which is invalid.
14:45:17 <Tuplanolla> (The outer bracket would `close` the socket that has already been `hClose` as a handle in the inner bracket.)
14:45:19 <EvanR> then only put the close in the outer handler
14:45:46 <EvanR> have the inner handler rethrow
14:46:14 <EvanR> (conditionally, otherwise this sounds pointless)
14:46:32 <Tuplanolla> I don't see what you mean.
14:46:50 <EvanR> what do you want to happen if socketToHandle fails
14:47:08 <Tuplanolla> That would result in `close sock`.
14:47:19 <EvanR> and is accept fails?
14:47:24 <EvanR> and if*
14:47:26 <Tuplanolla> I meant `close conn` there.
14:47:37 <Tuplanolla> Accept failing would result in `close sock`.
14:48:19 <Tuplanolla> A failure at a later point would result in `hClose hand` and `close sock`, but not `close conn`.
14:48:41 <EvanR> jeez
14:49:02 <EvanR> dont ever close anything
14:49:16 <EvanR> in all your handlers, throw an indicator of what fails, and interpret it at the outside
14:49:18 <Tuplanolla> The point is that `socketToHandle` changes one release operation to another and that's awkward.
14:49:28 <EvanR> throw a bitmask of what to close
14:49:40 <EvanR> then you can close any combination of things once
14:50:36 <EvanR> in idris, theres this state machine encoded into the types of where you are in the process, giving you full control over what should happen when
14:51:01 <EvanR> so you can do a sequential logic style state machine diagram to figure out how it should work ;)
14:51:26 <EvanR> doesnt sound like bracket works
14:52:11 <Tuplanolla> Let's see if I can draft a type for the function that does the mapping thing.
14:54:00 <swolffs> so, I recently learned it's supposedly possible to write this:
14:54:10 <swolffs> instance Monad m => Applicative m
14:54:48 <EvanR> every monad can be equipped with <*> in the dumbest possible way, using >>=
14:54:54 <swolffs> and I know that instance can actually be written if the compiler accepts that first line
14:55:07 <EvanR> by using ap
14:55:24 <swolffs> EvanR: so... it's an optimisation issue?
14:55:47 <EvanR> you cant write that because it would be overlapping instances
14:56:42 <swolffs> sorry, I didn't mean "I learned >>= can construct <*>", I knew that. I meant that someone claimed that top-level context restrictions on instances are apparently now OK
14:57:08 <EvanR> huh, what do you mean by top level here
14:57:22 <glguy> swolffs: Yes you can write that syntax; no, it probably doesn't mean what you hope it does
14:57:37 <swolffs> what I hope it does is...
14:57:53 <glguy> Not conflict with every other Applicative instance
14:57:56 <swolffs> sec, let me rewrite the Idris code to be syntactic Haskell
14:58:01 <swolffs> ah
14:58:03 <swolffs> right
14:58:18 <swolffs> so Haskell does *not* have overload conflict resolution
14:58:20 <swolffs> thanks
14:58:33 <EvanR> it does have ways to control overlapping instances, with extensions
14:58:49 <EvanR> but i am scared by it
14:58:53 <swolffs> I always took that to be the reason Haskell does "class Applicative m => Monad m"
14:59:15 <swolffs> which, if you could actually resolve the conflicts safely and easily, would be a weird restriction
14:59:44 <swolffs> but if conflicts cause serious issues, the current approach seems a sensible compromise
14:59:53 <EvanR> normally the resolution process requires a unique instance to choose
15:00:06 <EvanR> idris doesnt have that restriction
15:00:08 <swolffs> yeah, that's how I understood it
15:00:10 <swolffs> yeah
15:00:25 <swolffs> but Idris does copy the "class Applicative m => Monad m" 
15:00:49 <swolffs> and I suspect that's copying a restriction without understanding the original reason, which no longer applies
15:01:11 <swolffs> but I can't be sure
15:01:12 <c_wraith> That's less of a restriction and more of a statement of truth
15:01:24 <EvanR> that means to build a Monad, you need to provide an Applicative on the same argument type
15:01:29 <EvanR> (in idris)
15:01:38 <swolffs> c_wraith: that depends whether your logic is classical
15:01:50 <swolffs> c_wraith: it's true in classic logic, sort of
15:01:53 <c_wraith> swolffs: it's constructive, given that we're programming
15:02:04 <swolffs> c_wraith: correct. Therefore, it's false
15:02:07 <c_wraith> swolffs: the construction is pure = return, (<*>) = ap
15:02:19 <swolffs> c_wraith: I know
15:02:20 <EvanR> instance Monad m => Applicative m means that all Applicatives will be implemented in terms of monads
15:02:25 <EvanR> or a constant implementation
15:02:30 <c_wraith> swolffs: so..  there's a constructive proof
15:02:36 <swolffs> that's the truth of "instance Monad m => Applicative m"
15:03:02 <swolffs> what I'm saying is that "class Applicative m => Monad m" is only equivalent classically
15:03:20 <EvanR> instance and class arent saying anything comparable 
15:03:22 <c_wraith> Oh.  That's *not* an impication
15:03:28 <c_wraith> *implication
15:03:30 <swolffs> I know
15:03:31 <EvanR> class Applicative m => Monad m isnt a restriction
15:03:36 <swolffs> it's an anti-implication
15:04:08 <EvanR> since you can always get a free instance if you cant think of anything
15:04:16 <swolffs> EvanR: it complains if I define instance Monad MyType without adding instance Applicative MyType. Seems like a restriction
15:04:30 <EvanR> its not stopping you from doing anything
15:04:53 <EvanR> it would be nice if the additional instance could be generated with a flag
15:04:57 <swolffs> sec, I'm testing this
15:04:59 <EvanR> besides that its trivial
15:05:04 <swolffs> right
15:05:13 <swolffs> so now the question is:
15:05:30 <swolffs> should Idris have this trivial instance available by default, as a named instance?
15:05:51 <swolffs> instead of having the same class restriction and making return a non-member of Monad
15:05:57 <EvanR> resolution of implementations and everything else in idris is a nightmare
15:06:01 <EvanR> it barely ever works
15:06:02 <lielazive> How do I repopulate stack's package list? It thinks the latest package is directory-1.2 not 1.3
15:06:23 <EvanR> having more stuff for it to fail to disambiguate would only make it worse
15:06:58 <EvanR> but theres a dedicated idris channel
15:07:13 <swolffs> EvanR: so... no trying that unless and until resolution is more robust
15:07:33 <swolffs> EvanR: I know. They sent me here to ask about the why of "class Applicative m => Monad m"
15:07:48 <swolffs> which I now have, so I'll head back
15:07:49 <EvanR> the best way to get it to resolve stuff is to have only 1 choice (kind of defeating the purpose)
15:07:51 <swolffs> thanks
15:08:35 <EvanR> oh, was that the question
15:09:11 <EvanR> didnt realize
15:09:48 <EvanR> class Applicative m => Monad m was a breaking change made relatively recently, and while its interesting, i cant answer why it was done
15:09:58 <swolffs> EvanR: it was, but I got carried away
15:10:37 <glguy> All the types with Monad instance should have Applicative instances, having "class Applicative m => Monad m" means that we don't need a redundant "Applicative" instance to use applicative operations when we have a Monad instance around
15:10:43 <swolffs> I have my suspicions about the why, if conflict resolution can only be done by "scary" language extensions
15:11:06 <glguy> So if you have some definition :: Monad m => m this -> that, it saves you from also needing an Applicative m constraint
15:11:31 <EvanR> ah
15:11:33 <swolffs> glguy: that's the wrong way around I think: "class Applicative m => Monad m" means you can't even define a Monad instance without defining a (redundant) Applicative instnace
15:11:44 <glguy> No, it's what I said
15:11:49 <swolffs> oh, right, the second is what I understood
15:11:59 <glguy> when you define a Monad instance you will in fact also need an Applicative instance
15:12:09 <swolffs> it cuts down on instances of functions
15:12:11 <glguy> but often it's better to implement that instance directly
15:12:22 <swolffs> but it increases instances of Applicative
15:12:23 <glguy> than to derive it
15:12:29 <swolffs> because of speed?
15:12:49 <glguy> yeah, you can write a more efficient implementation
15:12:54 <EvanR> the number of types that *are* applicative remains the same
15:13:05 <EvanR> as before, you just get a more uniform api
15:13:24 <EvanR> rather than ap somewhere and <*> elsewhere
15:13:42 <EvanR> liftA vs liftM
15:14:58 <swolffs> EvanR: yeah, sure. So it's a very sensible choice, but it's a trade-off, with the price being having to give an explicit instance of Applicative, even if it's just the trivial one. Not having to pay that price would require conflict resolution
15:16:11 <swolffs> which Haskell apparently can do with extensions which are deemed "scary", at least by Melvar who I'm taking as representative, and Idris can do but not very reliably
15:16:27 <swolffs> so it's more robust all around to just pay that price
15:16:51 <EvanR> i dont think so
15:17:05 <EvanR> we have auto deriving of Functor right now
15:17:21 <swolffs> but auto deriving of Functor is possible with generics
15:17:27 <EvanR> presumably there could be a flag for "auto derive Applicative for Monads that dont have an Applicative instance already"
15:17:29 <swolffs> Monads aren't structural
15:17:38 <swolffs> right, yeah, that could be done
15:17:41 <EvanR> its not structural, itd be for monads only
15:17:55 <glguy> auto-deriving for functor in GHC isn't based on monads
15:18:16 <swolffs> re: functors: no, that's based on ADT structure
15:18:43 <swolffs> generics are nice
15:18:48 <EvanR> literally putting a catch-all applicatives for "all" monads is truly the wrong way as he said
15:19:23 <EvanR> that leads to crazy ancillary complexity you expect from scala or C++
15:19:39 <pikajude> please no scala
15:20:16 <swolffs> I must say  that I consider C++ a language with horror-show syntax but quite nice semantics (for an imperative language)
15:20:50 <swolffs> basically the proof by example that syntax matters
15:21:13 <ski> @messages-loud
15:21:13 <EvanR> you can also have an editor macro paste a dummy Applicative instance
15:21:13 <lambdabot> athan asked 1d 16h 40m 25s ago: Have you looked into Curry?
15:21:20 <ski> @tell athan a bit, some years ago
15:21:21 <lambdabot> Consider it noted.
15:21:28 <ski> @tell athan if you want to learn a lisp, i suggest Scheme (perhaps you could look into SICP or HtDP, or "The Little Schemer", &c.), which has first-class continuations and hygienic macros
15:21:28 <lambdabot> Consider it noted.
15:22:06 <EvanR> i rather like haskells tendency to have "the obvious spelled out" since its not as much as it would be in other languages, informative, but not enormously tedious and impractical
15:22:14 <EvanR> in this case only
15:22:37 <swolffs> yeah, I generally like Haskell's style as well
15:22:39 <EvanR> for a large pile of dumb record types... i lost interest typing
15:22:43 <Welkin> you mean like all imperative languages and how you have to deal with global state and hidden data messing up your programs?
15:22:53 <Welkin> (at least when taking over legacy codebases)
15:23:40 <Welkin> can't forget about types being coerced automatically into other types without your knowledge or permission
15:23:42 <swolffs> it's just that this specific interaction seems warty, but unavoidably so
15:24:13 <Welkin> explicit is better than implicit
15:24:25 <swolffs> Welkin: are you describing C++ specifically, or all imperative languages?
15:24:36 <Welkin> swolffs: any imperative language, they are all the same
15:24:47 <swolffs> ok, fair enough
15:24:48 <Welkin> big mess of state and mutation
15:25:07 <EvanR> you can also generate this dumb Applicative along with everything else with TH, for large numbers of dumb types
15:25:08 <lpaste_> Tuplanolla pasted “Double Bracket” at http://lpaste.net/352987
15:25:13 <Tuplanolla> I ended up with this, EvanR.
15:25:25 <swolffs> it's still th vast majority of all code being produced, moreso code already produced
15:25:32 <swolffs> so I can't really avoid it
15:26:12 <EvanR> Tuplanolla: you're in a maze of twisty little passages all alike!
15:26:53 <EvanR> thats a admirable piece of plumbing there
15:26:54 <swolffs> Welkin: so, when is the Functional Revolution planned for?
15:27:04 <Tuplanolla> The use is basically `bracket2 (fmap fst . accept sock) close (flip socketToHandle ReadWriteMode) hClose $ \ hand -> do celebrate`.
15:27:48 <Tuplanolla> I'm kind of tempted to generate `bracketN` with TH now.
15:27:53 <MarcelineVQ> Tuplanolla: that looks really familiar somehow
15:30:02 <MarcelineVQ> oh, I made similar in a project I don't have anymore :X well that's not useful
16:06:05 <centril> hmm... so I have a bunch of data types for which I want to drive Eq, but they all have that in common that one field in all constructors must not be involved in the Eq computation... is there any way to somehow derive this, or facilitate it ?
16:08:18 <Axman6> centril: wrap that field ina a newtypw whose Eq instance always returns True for (==)?
16:09:42 <centril> Axman6: hmmh... that'd incur the cost of creating wrapper constructors for all fields, I'd rather implement the instances myself
16:09:58 <centril> wrapper constructors to make the interface feel as nice
16:10:26 <Axman6> whatever you pefer
16:10:42 <centril> =)
16:10:57 <Tuplanolla> Here's a great idea, centril: write a shell script to run `-ddump-deriv`, edit it with `sed` and feed it back into the source file.
16:11:07 <Tuplanolla> That'll definitely not break horribly all the time.
16:11:08 <centril> Tuplanolla: haha, nice one :P
16:11:41 <centril> hmm... is it possible to do -ddump-deriv from ghci / stack ?
16:13:26 <Cale> Tuplanolla: You laugh, but there's all kinds of awful stuff we're doing with -ddump-splices and sed at the moment to get stuff building on mobile platforms
16:14:09 <Cale> (mainly because -ddump-splices emits code which is syntactically invalid and needs editing to repair it)
16:14:34 <Cale> At some point we'll actually fix the problems in GHC. :P
16:16:21 <Cale> (Of course, the real problem is that GHC insists on running the splices on the target architecture all the time, even when we'd rather it not do so.)
16:19:32 <tommd> Does anyone here have a strong opinion on the various git librariese on Hackage?
16:19:39 <centril> is it possible to derive custom classes (yet) ?
16:20:05 <tommd> I'm going to need to automate cloning, pulling, and checkout out commits.  Trying to decide what solution is best.
16:20:29 <tommd> `git` takes a great namespace for a package that doesn't perform any of the desired operations.
16:21:16 <tommd> `gitlib` seems up to the task, but it is frustrating that there are zero haddocks outside of the tutorial module.
16:52:20 <lambdafan> I'm trying to read a UTF-8 encoded file one character at a time, could someone recommend to me a good way to do it?
16:52:31 <lambdafan> it's fine if the file itself is in memory all at once.
16:53:44 <c_wraith> lambdafan: read it as Text then convert it to a String?
16:56:57 <lambdafan> c_wraith: my understanding is that utf-8 is really inefficient as String.
16:57:28 <c_wraith> you said "one character at a time".  That's exactly what String is
16:57:41 <lambdafan> fair enough
16:58:34 <c_wraith> Anyway, converting Text to a String is properly lazy
16:58:55 <c_wraith> If you don't keep multiple characters from the String in memory at once, the only copy of them will be in the Text value
16:59:36 <lambdafan> when you ay convert I am imagining somethig like this
16:59:54 <lambdafan> Data.Text.unpack <$> readFile "foo"
17:00:02 <c_wraith> Yep
17:00:40 <c_wraith> But that doesn't change unpack's laziness properties
17:00:43 <lambdafan> oh I thing I was making this harder than it had to be. I was believing I should stay away from String
17:00:57 <c_wraith> You *could* use a fold in Text, too
17:01:04 <c_wraith> Those also handle one character at a time
17:01:23 <c_wraith> If you found one the right shape for your problem
17:01:44 <lambdafan> Well, ideally I would like a single character to inhabit a Text, such that I end up with a [Text]
17:02:49 <exio4> lambdafan: you can use Data.Text.Lazy
17:03:02 <c_wraith> I guess that's approximately the same memory use as String, due to slicing..
17:03:02 <exio4> which is "basically" a lazy list of Text chunks 
17:04:57 <lambdafan> hmm okay I will stick with String
17:24:05 <EvanR> if you process Chars from a Text, the intermediate [Char] is just a list
17:24:21 <EvanR> and intermediate lists tend to disappear when you do it right
17:25:42 <EvanR> UTF8: you still need to convert that to a Text in the first place
17:26:01 <EvanR> this is where it could fail and doing it all in memory simplifies things
17:27:01 * EvanR wonders about the laziness of decodeUtf8
17:34:47 <EvanR> alan turing wrote about a "universal machine" which could compute the same output sequence as any other turing machine, and lots of articles simply refer to "machines" and the simulation of machines. 
17:35:12 <EvanR> im wondering how appropriate it is to shorten it to machines. Since I am looking up info on motors and weird looking gears
17:35:27 <EvanR> is a universal turing machine able to simulate those?
17:36:05 <EvanR> if not, in what way are turing machines and state machines... machine-like?
17:36:34 <c_wraith> the turing machine was conceptualized as a physical device.
17:36:49 <c_wraith> with a few implausible details like infinite storage space.
17:37:06 <c_wraith> But other than those, it's plausible to construct as a mechanical device
17:37:51 <Sornaensis> they are a machine because they transition from state to state and read and write to a tape, mechanically
17:38:38 <c_wraith> Infinite write/erase is also implausible.  But you can design something that works for quite a while, at least.
17:38:53 <dolio> Can a Turing machine simulate a pulley?
17:39:00 <dolio> Or an incline plane?
17:39:05 <c_wraith> yes, just incline it. :)
17:39:12 <EvanR> realization as an actual machine i think was a side issue, the point was that some idealized mathematician who could only follow instructions and not do real thinking was shown to be unable to do stuff like solve the halting problem, and thus not solve the entscheidung problem as a special case
17:39:51 <EvanR> godel incompleteness, from a few years before, ended up being a special case
17:40:35 <EvanR> then a few years later people starting trying to model the human brain as a machine
17:40:42 <EvanR> which seems odd
17:41:10 <EvanR> but yes i am wondering about the machine aspects, like pulleys and worm screws
17:41:29 <EvanR> are we dealing with two notions of machines
17:41:58 <c_wraith> I don't really understand the question.  The universal turing machine can emulate any turing machine.  It was never claimed it could emulate primitive physical machines.
17:42:16 <dolio> Yes, of course. Turing machines are expected to simulate other kinds of machines that do computation.
17:42:28 <dolio> Not machines that distribute force or whatever.
17:42:44 <EvanR> so strictly, its about turing machines, more loosely any machine that does computation?
17:42:53 <EvanR> or is that already out of the bounds of certainty
17:43:49 <c_wraith> Well, the church-turing thesis claims that a turing machine (and lambda calculus) are at least as powerful as any other formalized computation system.
17:43:57 <EvanR> and today we talk about computers colloquially as "machines", even if they dont seem anything like force distribution
17:44:09 <c_wraith> That hasn't been proven, as far as I know, but it is pretty much assumed.
17:44:12 <EvanR> except maybe the cpu fan
17:44:33 <c_wraith> and the graphics card fan!
17:45:14 <EvanR> i need to read this church-turing thesis
17:45:23 <EvanR> if its even a real paper
17:46:51 <EvanR> "A universal machine changes to be like any other machine when you insert the right software. This is a very deep concept: a flexible digital machine. You don't need lots of special-purpose machines, you can make do with only one machine."
17:47:14 <EvanR> and i immediately wondered if its possible to do this with a "real" machine, not necessarily a computer
17:47:34 <c_wraith> anything flexible enough to do that would be a computer.
17:47:45 <EvanR> it would be a computer as a special case
17:47:49 <c_wraith> It would just have better tools for manipulating its environment
17:47:59 <EvanR> like an FPGA programmed to be a C64
17:49:32 <EvanR> i guess it would look something like the T1000 liquid metal guy
17:51:30 <c_wraith> It could be something less fantastic, like a 3d printer that is capable of wandering around the outside of whatever it's building
17:52:20 <c_wraith> and somehow, of providing for itself.  Maybe it charges money for it has built and uses it to buy supplies. :)
17:52:30 <EvanR> thatd be a universal constructor
18:42:31 <nak> does someone want to walk me thru the last line of http://hackage.haskell.org/package/base-4.9.1.0/docs/src/Data.OldList.html#transpose
18:42:41 <centril> is there some nice lens thingy to apply a function to both operands of a binary operation and then do a fold on the results ?
18:43:13 <nak> i understand up thru : transpose ((x:xs) : xss) = (x : ... then i struggle with [h | (h:_) <- xss]) : transpose (xs : [ t | (_:t) <- xss])
18:43:22 <centril> each operand is a product of types
18:43:36 <nak> what is [ h | (h:_) <- xss] ?
18:43:51 <nak> is that some list comprehension ?
18:44:07 <centril> nak: yeah, it is
18:44:12 <nak> given [[1,2,3]] will that give me [1] ?
18:44:49 <centril> nak: seems about right
18:44:58 <centril> you can always test it =)
18:45:04 <wyhgood> hello
18:47:47 <nak> hmm ok i think i get it
19:15:54 <variable> Is this a good place to ask about stackage ?
19:16:38 <variable> I'm having trouble getting stackage (or cabal or anything) setup
19:16:54 <variable> stack setup fails with an error with ghc
19:16:59 <systadmin> I guess anything Haskell related is allowed here
19:17:49 <variable> http://sprunge.us/RZga
19:17:55 <variable> is the error and OS details
19:22:31 <geekosaur> conftest.c:9:19: fatal error: stdio.h: No such file or directory
19:23:21 <variable> geekosaur wow, I saw that, assumed it was haskell specific, but I just tried gcc 
19:23:23 <variable> and it also fails
19:23:23 * variable dies
19:23:30 <geekosaur> exactly
19:23:42 <geekosaur> I *think* you are missing xcode command line tools
19:24:00 <variable> nope
19:24:00 <variable> xcode-select: error: command line tools are already installed, use "Software Update" to install updates
19:24:16 <geekosaur> but apple keeps changing how you get them and I have no idea how you do it with current sierra (I've basically vacated OS X)
19:24:45 <geekosaur> yehl that's part of the confusion. you;re not the only one who I've seen with that
19:25:00 <variable> I should just install fbsd on this computer
19:25:02 <variable> but meh
19:25:13 <geekosaur> it thinks CLT is installed, but no /usr/include/stdio.h?
19:25:44 <variable> you're right
19:25:45 <geekosaur> historically xcode puts them under its SDKs dir, and CLT puts them (or links/copies) in /usr/include and /usr/lib as appropriate
19:25:52 <variable> CLT 
19:25:52 <geekosaur> but something changed in xcode 8 / sierra
19:25:53 <variable> ?
19:25:55 * variable dies
19:25:57 <geekosaur> command line tools
19:26:03 <variable> oh, right
19:26:13 <variable> I also have gcc installed from macports which makes that even more fun
19:26:22 <variable> going to try removing that
19:26:37 <geekosaur> that shouldn't matter too much since these files still have to come from the OS somehow (apple forbids other distribution)
19:26:39 <variable> ... and that worked
19:26:42 <geekosaur> hm
19:26:51 <geekosaur> so somehow configured with bad defaults, I guess
19:27:02 <geekosaur> no idea...
19:28:03 <variable> thanks for the help
19:28:19 <geekosaur> although uninstalling shouldn;t have been necessary either, just path tweak or `sudo port select --set mp-gccSOMETHING none`
19:28:40 <geekosaur> (and then `hash -r`)
19:29:01 <variable> no worries; it just added confusion
19:29:13 <variable> and I don't need mp gcc; I use clang ayways :)
19:37:42 <wyhgood> exit
19:37:44 <wyhgood> exit
20:28:39 <Xnuk> exit
20:38:16 <newbie> Hi
20:39:10 <c_wraith> hello
20:40:48 <newbie> So I am reading typing dynamic typing
20:40:50 <newbie> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.193.1552&rep=rep1&type=pdf
20:41:44 <newbie> On page 6 there's a TpCon and TpRep, but why such a split?
20:44:15 <lyxia> lolisa: TpRep is a type. TpCon is a constructor.
20:44:32 <c_wraith> lolisa: it looks like TpCon is for things with a known type, where TpRep is for things that have types inferred from context
20:45:03 <c_wraith> and given that it's dynamic typing, multiple different types can be inferred from the context
20:45:38 <c0ncise> hi
20:45:47 <lolisa> There are two TpCon, one is the constructor, one is a * -> *, on page 5
20:45:50 <lyxia> Oh I didn't see data TpCon
20:50:03 <lolisa> what do you mean by "multiple different types"? Can you give an example?
20:50:34 <c_wraith> in javascript, something like...  var a = 1; a = "hello";
20:51:29 <c_wraith> Or even better, ...  var a = 1;  if (someCondition()) { a = "hello"; }
20:51:44 <c_wraith> In that latter case, what's the type of a?
20:51:52 <lolisa> Yes, but this is haskell and dynamic just hold existential haskell term... Does this still happends?
20:52:01 <dolio> It appears they just divided up the atomic types from the compound types. I don't think there's any necessary reason to do that.
21:16:41 <maybefbi> how to implement parametric data types with type constraints on the parameters?
21:23:41 <glguy> You put the constraints on the definitions using those data types rather than on the data types themselves
21:24:32 <maybefbi> glguy, thanks i thought GADTs were the way to go about this
22:05:44 <Xnuk> @hoogle Either a b -> Just b
22:05:46 <lambdabot> Data.Either.Combinators swapEither :: Either e a -> Either a e
22:05:46 <lambdabot> Data.EitherR flipEither :: Either a b -> Either b a
22:05:46 <lambdabot> Control.Lens.Prism left' :: p a b -> p (Either a c) (Either b c)
22:05:56 <Xnuk> @hoogle Either a b -> Maybe b
22:05:57 <lambdabot> Data.Either.Combinators leftToMaybe :: Either a b -> Maybe a
22:05:57 <lambdabot> Music.Theory.Either fromLeft :: Either a b -> Maybe a
22:05:57 <lambdabot> Agda.Utils.Either maybeLeft :: Either a b -> Maybe a
22:06:56 <athan> Xnuk: Check out `hush` from Control.Error
22:07:01 <athan> in the `errors` library
22:07:18 <nishimura> @hoogle hush
22:07:19 <lambdabot> Control.Error.Util hush :: Either a b -> Maybe b
22:07:19 <lambdabot> Text.Pandoc.Shared hush :: Either a b -> Maybe b
22:07:19 <lambdabot> Control.Error.Util hushT :: (Monad m) => ExceptT a m b -> MaybeT m b
22:08:05 <nishimura> Why doesn't hoogle get those though
22:08:32 <nishimura> order of a b in Either a b doesn't matter?
22:09:26 <c_wraith> Actually, it matters quite a lot
22:12:13 <nishimura> Oh that's why it's called hush -- it silences the error
22:58:36 <recur22> hi everyone, has anyone know good docs/examples for FFI, it seems all i can find is some random notes and most of them are outdated
23:02:12 <ongy> recur22: my pulseaudio package is an example of FFI wrapping around a not straight forward api. But I don't think it can be called *good*
23:14:08 <recur22> ongy: nice package, what guide/process you used to do it
23:18:11 <srhb> recur22: The GHC manual is perfectly up to date wrt. the FFI, as far as I know.
23:18:28 <srhb> recur22: I used that when I wrote my first bindings, it was fine.
23:18:54 <ongy> mostly ghc manual/haddock on hackage for the Foreign.* modules and a bit of experience
23:19:21 <srhb> Indeed.
23:37:59 <recur22> i think i'll just turn everthing into shared libraries
23:38:25 <hits1911> hi, how can I merge two trees such that root of one is the leaf of another in the merged tree if there are such nodes? trees are binary but not bst.
23:59:29 <fresheyeball_> Why is (Map k) not Alternative? 
