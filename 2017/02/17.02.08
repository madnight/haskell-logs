00:12:34 <prohobo> HASKELL!
00:12:48 <shiona> k
00:15:34 <ketil_> _|_
00:20:59 <quchen> osa1: Was about to tell you about why not to use ¬ªfail¬´, then I had another look at your nick ;-)
00:26:58 <osa1> heh, I shoot myself in the foot sometimes
00:41:48 <erisco> if I kill line 5 it compiles http://lpaste.net/352218 but what makes this an illegal contraint?
00:44:45 <erisco> I guess you are not allowed to constrain kinds?
00:52:42 <Alxandr> Hi. I'm trying to get the version of my application in haskell, and I read on stackoverflow that I could import Paths_<packageName> to do so
00:52:59 <Alxandr> I did this, and it builds, but it doesn't link
00:53:28 <dmwit> Did you include Paths_<packageName> in your exposed-modules or extra-modules list?
00:53:29 <phadej> you have to add Paths_packagename to the other-modules
00:53:37 <phadej> sorry, extra-
00:53:39 <phadej> ^
00:54:16 <dmwit> Oops, now I'm not sure whether it's extra- or other-. Consult the documentation or use trial-and-error. =P
00:54:53 <Alxandr> Ah, no, that was it :)
00:54:55 <Alxandr> Thanks
00:55:00 <phadej> great
00:55:45 <Alxandr> Btw; what's involved in publishing a haskell package to hackage/stackage?
00:56:12 <dmwit> Publishing to Hackage: make a Hackage username, then `cabal sdist && cabal upload dist/*.tar.gz`.
00:57:13 <dmwit> For stackage, check the official information here: https://github.com/fpco/stackage/blob/master/MAINTAINERS.md#adding-a-package
00:58:15 <Alxandr> Thanks. I'll look at it :)
01:00:07 <Alxandr> Lol, I went to register at hackage, and my password manager thought my username was ByteString.Lazy for some reason :P
01:00:35 <filterfish> ;)
01:00:43 <dmwit> =)
01:02:24 <tabaqui1> there is no bool conversion in Haskell, right?
01:02:35 <tabaqui1> like "class isBool"
01:02:46 <tabaqui1> with "toBool :: a -> Bool"
01:02:56 <tabaqui1> for using in if-then-else syntax
01:03:08 <erisco> use case/of
01:03:23 <davidar> tabaqui1: see the Boolean package
01:03:36 <tabaqui1> case of takes much place
01:04:24 <quchen> > length "case x of True -> y; False -> z"
01:04:27 <lambdabot>  31
01:04:31 <tabaqui1> wtf is "type family"?
01:04:33 <quchen> > length "if x then y else z"
01:04:37 <lambdabot>  18
01:04:39 <quchen> Negligible.
01:04:56 <erisco> tabaqui, a function on types
01:05:23 <tabaqui1> erisco: never seen it before
01:05:47 <tabaqui1> it's not from haskell '98
01:05:47 <erisco> > length "bool y z x"
01:05:50 <lambdabot>  10
01:05:55 <tabaqui1> davidar: looks fine, thx
01:06:09 <erisco> tabaqui, times have moved on
01:07:06 <flxw> Hi, I'm trying to compile an older version of category-extras. ghc (8.0.1) complains about this Span definition:
01:07:09 <flxw> newtype Span (~>) x y z = Span { runSpan :: (y ~> x, y ~> z) }
01:07:29 <flxw> is there an extension I need to switch on to make this valid syntax?
01:08:10 <tabaqui1> ah, ghc extension
01:08:12 <tabaqui1> well
01:08:28 <flxw> oops, yeah.
01:08:50 <tabaqui1> flxw: you cannot use polimorphic types in newtype
01:09:08 <erisco> flxw, TypeOperators maybe? what is the error?
01:09:15 <bitonic> flxw: what's the error? You need TypeOperators
01:09:21 <tabaqui1> newtype will be unboxed after compiling, it allows typecheck for compiler
01:09:40 <tabaqui1> but isn't a new datatype in bytecode
01:09:40 <flxw>  
01:09:40 <flxw> /tmp/stack10841/category-extras-0.53.5/src/Control/Morphism/Span.hs:20:14: error:
01:09:40 <flxw> Unexpected type `(~>)'
01:09:40 <flxw> In the newtype declaration for `Span'
01:09:44 <flxw> A newtype declaration should have form
01:09:46 <flxw> newtype Span a b c d = ...
01:09:56 <erisco> right, you cannot use newtypes recursively
01:10:02 <erisco> which is what I think tabaqui meant
01:10:25 <bitonic> erisco: there is no recursion there, I just think he needs TypeOperators
01:10:54 <erisco> oh I am wrong, you absolutely can :P
01:10:58 <flxw> okay, thank you. I'll try it out ...
01:11:05 <erisco> guess I was thinking of type aliases
01:11:51 <erisco> bitonic, ~> occurs in the definition of ~>
01:12:02 <bitonic> erisco: he's not defining ~>
01:12:15 * erisco *headdesks*
01:12:36 * tabaqui1 test
01:12:37 <erisco> what is (~>) doing in the parameter list
01:13:06 <erisco> newtype Span x y z = Span { runSpan :: (y ~> x, y ~> z) }
01:13:46 <kadoban> Same thing    newtype Span foo x y z = Span { runSpan :: (foo y x, foo y z)}    would be doing I think, except fancy infix? Could be wrong though.
01:14:50 <bitonic> I'm pretty sure the problem here is that before you could have type operators like that
01:14:55 <bitonic> But now they must be prefixed with :
01:15:00 <erisco> you can use ~> as a parameter name? what do I know anymore lol
01:16:06 <quchen> > let (*) = (++) in "hello" * "erisco"
01:16:08 <lambdabot>  "helloerisco"
01:16:20 <bitonic> Ah no, : is for type constructors only, not type parameters
01:16:22 <erisco> parameter name
01:16:39 <bitonic> I think using operator names for type parameters is just not allowed anymore flxw 
01:16:53 <bitonic> So I'd just turn the ~> into a f or some other alphanumeric symbol
01:16:59 <erisco> > let f (*) = (*) + (*) in f 1 -- apparently so
01:17:02 <lambdabot>  2
01:17:06 <quchen> > (\(*) x y = x * y) (++) "hello" "erisco"
01:17:06 <kadoban> That's why Category's types aren't as cute anymore, right?
01:17:08 <lambdabot>  <hint>:1:11: error:
01:17:08 <lambdabot>      parse error on input ‚Äò=‚Äô
01:17:08 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
01:17:10 <kadoban> :t (>>>)
01:17:11 <lambdabot> forall k (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
01:17:12 <quchen> > (\(*) x y -> x * y) (++) "hello" "erisco"
01:17:14 <lambdabot>  "helloerisco"
01:17:18 <kadoban> "cat" and such
01:17:33 <bitonic> flxw: e.g. `newtype Span f x y z = Span { runSpan :: (f y x, f y z) }` should work
01:17:49 <bitonic> I vaguely recall this behavior changing a while back
01:19:01 <kadoban> Ya, I think so too, not really sure what time period.
01:19:38 <quchen> kadoban: Kind polymorphism is responsible for that
01:19:47 <erisco> works for terms but not for types‚Ä¶ syntax
01:19:58 <bitonic> flxw: I think we can probably help you better knowing why you're trying to compile `category-extras` :P
01:20:09 <flxw> bitonic: Thanks alot. This did the trick.
01:20:14 <erisco> I have never seen that used in a term either
01:20:16 <kadoban> quchen: Oh is my example a different issue? Hmm
01:20:32 <bitonic> flxw: it's probably going to be quite a struggle to get it to compile
01:20:34 <quchen> kadoban: The ugly type of >>> is what I meant
01:21:12 <erisco> don't forget preceding ' is for promoted constructors
01:21:18 <flxw> now I just need to go over the whole source and replace funny characters in ty peparameters through an toherwise unused letter ... 
01:21:41 <erisco> and magic hash
01:22:31 <bitonic> flxw: again, why are you trying to get `category-extras` to compile with GHC 8?
01:22:38 <bitonic> Maybe there's an easier path to your goal :P
01:22:54 <erisco> ! for strict, ~ for lazy
01:23:13 <erisco> @ to bind‚Ä¶ is that it? :P
01:24:16 <opqdonut> erisco: I'd call @ alias
01:24:34 <quchen> They‚Äôre called ¬ªas-patterns¬´.
01:24:38 <flxw> yeah, I was about to ask. :) I'm trying to compile conal's reactive package  
01:24:39 <flxw> http://hackage.haskell.org/package/reactive
01:26:37 <flxw> and cabal pulls in this version of category-extras  when I use backjumps of 10000 and reorder-goals. :)
01:27:53 <flxw> with fewer back jumps cabal fails to construct the dependency tree.
01:28:01 <bitonic> flxw: ehhhh... you're experiencing the pain of not having reproducible builds (e.g. what stack/nix give you). The best attempt would probably be to use whatever GHC Conal was using to build it
01:28:12 <bitonic> Rather than GHC 8
01:28:24 <bitonic> Otherwise it's going to be quite a nightmare
01:29:27 <flxw> yeah, I tried stack init --solver on the reactive sources. (reactive is not on stackage)
01:31:40 <bitonic> flxw: the problem is that stack does not go as far back as GHC 6.10
01:31:48 <flxw> okay, then I'll go finding out which ghc version was used during that age.
01:32:19 <bitonic> flxw: I'd guess GHC 6.10 or 6.`1
01:32:26 <bitonic> or 6.12
01:33:01 <flxw> aahh, this explains why my attempt of compiling it with 7.8 failed, too ...
01:33:54 <erisco> jle`, gets a little trippy when Nats get promoted to kinds lol
01:34:19 <flxw> thanks very much again. I'll try with the 6 series now.
01:41:11 <erisco> jle`, I realised I made a slight error on my EqS constructor
01:41:37 <erisco> i.e. I have (n := n) -> 'S n := 'S n but why do I not have (n := m) -> 'S n := 'S m
01:43:51 <erisco> we can also be as simple as EqNat :: forall (n :: Nat). n := n
01:45:51 <erisco> I am not sure why to bother with the inductive proofs
01:49:37 <bitonic> flxw: yeah, I'd also seriously question whether you really need to build it. It's you're probably going to waste quite a bit of time building it if you're not familiar with the tooling.
01:50:46 <fdfddf> hi
01:50:55 <shiona> hello
01:51:17 <halogenandtoast> Is there a way to embed the json itself in an instance of parseJSON. Something like:
01:51:17 <fdfddf> i'm exciting 
01:51:24 <lpaste_> halogenandtoast pasted ‚ÄúEmbed.hs‚Äù at http://lpaste.net/352220
01:51:32 <halogenandtoast> ^^
01:52:46 <erisco> it would make sense to do this if we were not allowed multiple use sites of the same variable
01:53:06 <erisco> i.e. it cannot decide equality
01:53:06 <bartavelle> halogenandtoast, yes, but j has type Value, not Object
01:53:14 <bartavelle> v has type Object
01:53:22 <erisco> but the type system does have that capability, so
01:53:31 <bartavelle> which is just a type alias to HashMap Text Value
01:53:48 <bartavelle> also you'd need "pure v"
01:54:00 <halogenandtoast> Oh right
01:54:31 <halogenandtoast> Thanks erisco and bartavelle 
01:54:35 <bartavelle> np
01:54:41 <erisco> I'll take all the credit
01:54:46 <bartavelle> ;)
01:55:00 <halogenandtoast> Hey I appreciate anyone taking the time to try and help.
01:55:38 <halogenandtoast> You're not getting paid to help me so the fact that anyone does is an amazing testimate to the community
01:55:48 <erisco> I was just mumbling to myself mainly
01:56:20 <bartavelle> crazy guy that mumbles to himself is always welcome in an inclusive community
01:56:59 <Profpatsch> Argh, Spock & Persistent, how.
01:57:24 <erisco> :t Witness
01:57:26 <lambdabot> error: Data constructor not in scope: Witness
01:57:42 <Axman6> halogenandtoast: we're just a bunch of people who hate seeing other wrong on the internet and must correct them, we're just good at hiding it's for our own satisfaction ;)
01:59:18 <erisco> :t Refl
01:59:19 <lambdabot> forall k (a :: k). a :~: a
01:59:39 <erisco> I mean really that is it right there, the only proof you need for all type equality
01:59:48 <Profpatsch> instance MonadIO a => MonadBaseControl IO a
01:59:58 <Profpatsch> hwhy not?
02:00:03 <jita> Will learning clojure first before learning haskell would help grasp the concept easier coming from python background ?
02:00:14 <Profpatsch> jita: That was the route I took.
02:00:17 <halogenandtoast> Axman6: Good enough for me.
02:00:27 <Profpatsch> It‚Äôs easier with type signatures, believe me.
02:01:00 <jita> Profpatsch, would you recommend doing it ? Do u still use clojure ?
02:01:14 <Profpatsch> jita: No, I‚Äôd recommend a typed language.
02:01:20 <erisco> it is definitely a strange matter‚Ä¶ not helped by the noise of Haskell
02:01:24 <Axman6> jita: clojure may feel more like python, but if you want to learn Haskell, learn Haskell. they're quire different. Being functional languages is less important than the stront vs weak type systems
02:01:30 <Axman6> strong*
02:01:36 <Profpatsch> Having type signatures eases grasping higher-order functions.
02:01:49 <jita> Axman6, is clojure weakly typed language ?
02:02:02 <Profpatsch> jita: Yes, it‚Äôs a lips
02:02:04 <Profpatsch> *lisp
02:02:15 <Axman6> as far as I know it is, I haven't used it. most lisps are
02:02:37 <erisco> it has no syntax, you know
02:02:50 <liste> does "weakly typed" here mean "dynamically typed" or "having implicit conversions" ?
02:02:59 <Profpatsch> With the added negative point of throwing Java errors instead of more descriptive ones.
02:03:06 <raichoo> liste: I was wondering the same.
02:03:16 <Axman6> or, it is only syntax ü§î
02:03:18 <Profpatsch> unityped. :)
02:04:05 <Axman6> liste: i'm probably being too imprecise with me terminology, dynamically typed is probably more appropriate
02:04:47 <erisco> 'arr with me terminology
02:04:57 <halogenandtoast> ... persisting JSON to the database is unfun. I wish persistent supported the json time natively.
02:05:09 <liste> Axman6: unityped is even more appropriate (:
02:05:22 <bartavelle> halogenandtoast, you can newtype it
02:05:35 <erisco> implicit conversions are irrelevant
02:05:52 <halogenandtoast> bartavelle: and derive it automagically?
02:05:54 <erisco> with dynamic typing you statically have one type and at runtime there are many types
02:06:13 <erisco> as the program executes it does some type checking and that is when errors will be discovered
02:06:33 <halogenandtoast> I actually don't think I understand newtype very well (it seems the same as data to me, but I haven't figured out when to use it).
02:06:36 <bartavelle> halogenandtoast, you'll just have to write the newtype once, give it the proper instances, and then you'll be able to write "foo (JSON (M.Map Text Int))"
02:06:40 <bartavelle> in the quasiquoter
02:06:40 <erisco> the issue with just one type is that statically just about everything works
02:06:53 <bartavelle> halogenandtoast, ok I'll bring a paste, gimme a second
02:07:33 <halogenandtoast> bartavelle: Quasiquoter is a word I've seen thrown around a lot lately, that's just what TemplateHaskell uses right?
02:07:58 <bartavelle> it's related, but QQ is when you have [stuff| like that]
02:08:01 <bartavelle> err
02:08:09 <bartavelle> [stuff| like that|]
02:08:16 <bartavelle> like your probably define your model
02:08:19 <Maxdamantus> `newtype` is pretty much just a restricted form of `data` with some funny semantics around bottom values.
02:09:17 <erisco> if you have one constructor and one field use newtype. If you think you have one field but are using a tuple then you're doing it wrong. Otherwise use data
02:09:20 <Maxdamantus> particularly, that a value will always destructure without requiring any reduction.
02:09:25 <bartavelle> halogenandtoast, I have this http://lpaste.net/8671642603889885184  it's a bit more complicated than what you'd need, because I introduced a VFromJSON typeclass that tries to decode several versions of the same structure
02:09:42 <erisco> that's how you decide without knowing what it is :P
02:09:55 <bartavelle> halogenandtoast, once you have that, you can declare column types like that "col (PGJS your type here)"
02:10:34 <halogenandtoast> bartavelle: did you summon this from the nether or were you already doing this somewhere?
02:10:41 <halogenandtoast> I hope the later or you're a wizard.
02:10:44 <erisco> I will say it can make some sense to newtype tuples but don't have a tuple just for the sake of newtype
02:10:46 <bartavelle> halogenandtoast, that's a copypasta :)
02:11:10 <halogenandtoast> okay, expectations returned to normal.
02:12:06 <erisco> similarly if you think you have one constructor but you're using Either that is the same idea
02:13:01 <halogenandtoast> erisco: I guess that helps me understand newtype a little.
02:13:15 <bartavelle> the main point of newtype, besides performance (which is often not relevant), is that you can wrap something you already know, derive all type classes instances you require (with GeneralizedNewtypeDeriving), and add/change the instances you need
02:13:34 <bartavelle> for example you could write a HashMap wrapper where the monoid instance is "Monoid a => Monoid (MyMap k a)"
02:13:54 <bartavelle> to change the behaviour of the current Monoid instance for HashMap
02:14:26 <bartavelle> halogenandtoast, oh I forget to most important part :)
02:14:38 <Axman6> it also adds type safety in cases where one type might be used ambiguously, like turning foo :: Text -> Text -> Text -> IO () into foo :: URL -> Port -> Content -> IO ()
02:14:58 <bartavelle> halogenandtoast, http://lpaste.net/8671642603889885184
02:15:04 <bartavelle> it has the newtype on top
02:15:31 <erisco> that's adding semantics, not safety, it is safe either way :) but I know what you mean
02:16:23 <halogenandtoast> bartavelle: unfortunately I have a no cargo-culting policy so it will probably take me some time to grok this.
02:16:51 <halogenandtoast> for instance I assume iso has something to do with isomorphs, but I haven't used them at all yet.
02:17:10 <halogenandtoast> and there's lots of other lens stuff in here (I've just started learning/using lenses)
02:17:19 <bartavelle> halogenandtoast, yah there is a ton of distracting stuff in here
02:17:25 <bartavelle> gimme a sec I'll write a simpler version
02:17:35 <erisco> if you always use data instead of newtype the worst that will happen is you'll spend some extra time deriving instances
02:17:42 <erisco> so I wouldn't sweat it
02:20:08 <bitonic> Well the other thing that would happen is that you're adding a level of indirection for your data
02:20:28 <bitonic> The runtime behavior of `newtype A = A Int` and `data A = A Int` is different
02:20:43 <erisco> imperceptible
02:21:14 <bitonic> erisco: what do you mean?
02:22:21 <erisco> in the average use the difference is negligible
02:22:47 <bitonic> erisco: not really, they have different behavior, you need to be aware of it
02:23:08 <erisco> the performance behaviour? no not really, you don't
02:23:16 <phadej> it is
02:23:36 <phadej> newtype wrapping and unwrapping is (mostly) free
02:23:43 <Axman6> free*
02:23:45 <phadej> with data it always cost something
02:23:51 <erisco> the semantics? well it could come up, but isn't so likely
02:24:02 <erisco> I'm not saying never learn newtype. I am saying it is not important
02:24:06 <Axman6> the whole type safe coercions fraqmework exists because it's not as free as it should be
02:24:32 <phadej> Axman6: yeah, but not using it isn't trying to solve at all
02:25:23 <mutsig> how "unfree" are newtypes? I always imagined that they were pretty much entierly free with ghc. 
02:25:37 <erisco> learn it around the time you're also learning about unboxed data and ST
02:26:15 <phadej> erisco: well, if you do newtype PersonName = PersonName Text, it's imho good to learn to use newtype from beginning
02:26:49 <erisco> I disagree because it is frivolous complication for no perceivable benefit in the average use case
02:28:12 <erisco> it is a Haskellism that goes nowhere
02:28:17 <bartavelle> erisco, newtypes come before that, when you need to override / add type classes instances for types you do not own
02:28:39 <erisco> you eventually wonder how to bump up your performance or how to have multiple class instances and you learn about newtype
02:28:46 <bartavelle> I agree that the performance edge does not matter usually
02:28:46 <erisco> then that's it
02:29:15 <phadej> bartavelle: having million of ints or million of data WrappedInt Int = WrappedInt Int matters
02:29:27 <erisco> but you can still have multiple class instances just using data, so it still isn't critical
02:29:58 <bartavelle> erisco, you loose GeneralizedNewtypeDeriving, so it becomes extremely tedious
02:30:17 <erisco> extremely? we have different notions of extremely :P
02:30:19 <phadej> bartavelle: the pointer indirection is both cpu and memory hit
02:30:56 <bartavelle> phadej, certainly, but I am not convinced this is a common use case
02:31:15 <phadej> bartavelle: when `newtyping` domain-less `Int`s, it is
02:31:20 <bartavelle> erisco, tediousness becomes extreme really fast for me :)
02:31:54 <bartavelle> yeah, I mean, newtypes are useful and commonly used, I just don't think the performance advantage is very useful for most use cases
02:32:03 <bartavelle> obviously, that's just my very limited experience
02:32:10 <roundhouse> hi guys, I have a question about module layout. I'm trying to keep all types of a certain area in a "Types.hs" module. Unfortunately this makes it impossible to hide constructors, since I have to write those in different modules. What is your approach to solve this?
02:32:33 <bartavelle> adding meaning to the types and the type class stuff seem much more useful to me on a daily basis
02:32:47 <bartavelle> for when I need efficient storage I usually reach for unboxed vectors ...
02:33:38 <bartavelle> roundhouse, rename your module Internal.Types and don't hide the constructors ;)
02:34:24 <bartavelle> (I don't think I really understood the question, that was just a quip)
02:34:34 <erisco> if you want abstract data then put it in its own module
02:34:38 <roundhouse> bartavelle, :)
02:35:13 <merijn> roundhouse: Don't export the Types module from cabal and only reexport the types and not constructors
02:35:18 <erisco> that is a valid solution too. Many packages have an Internal module which is understood to be breaking on any version change
02:35:31 <merijn> roundhouse: Not all modules in your package are accessible to users of your package
02:36:10 <bartavelle> roundhouse, erisco : by all means, it's nicer to export everything in "Internal" modules, as you never know when someone will need to tinker a bit ...
02:36:13 <roundhouse> Ah I understand, so by hiding the module Types
02:37:11 <merijn> roundhouse: You'll probably want to re-export the types without constructors, though
02:37:30 <roundhouse> yeah, that makes sense
02:37:55 <erisco> yes. I'd rather be allowed to shoot myself in the foot with a Colt .45 than be safe with only a Nerf blaster
02:43:59 <bitonic> erisco: it's not just performance. `A (error "TODO")` behaves very differently depending on whether `A` is a data constructor or a newtype constructor
02:44:23 <bitonic> And the performance _does_ matter
02:44:30 <bitonic> Boxed types can be a huge drag on performance
02:48:08 <bitonic> erisco: interesting historical note: when Haskell was designed, there was a big debate on whether tuples should behave like newtypes or not with this regard, see section 5.4 in <http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf>
02:48:29 <bitonic> All in all it is definitely something to be aware of when programming in Haskell
02:48:54 <erisco> well, fine, if in your perspective these things matter than I cannot argue that. In mine they should not matter to a beginner
02:50:18 <erisco> I generally avoid anything that is too similar to something else
02:50:30 <erisco> take note at how much confusion there is on pattern matching lists, for example
02:50:39 <bitonic> Is there?
02:50:42 <erisco> yes
02:50:54 <bitonic> What's the point of confusion?
02:50:56 <bitonic> I mean
02:50:59 <bitonic> What confuses you?
02:51:01 <erisco> so last on my list is adding a second but only subtly different way of defining data
02:51:26 <phadej> we disagree on "subtly"
02:51:43 <bitonic> erisco: but they're not the same thing at all
02:51:53 <erisco> or we disagree on what qualifies as beginner material :P
02:51:53 <bitonic> And they serve a specific purpose
02:52:05 <phadej> it's almost as big as struct D { Foo *foo }; ofr struct N { Foo foo; }
02:52:44 <bitonic> erisco: what is rarely needed is `data Foo = Foo A`, I'll grant you that. But newtypes are very important
02:53:08 <erisco> okay, I disagree, sorry :P
02:55:15 <erisco> bitonic, http://stackoverflow.com/documentation/haskell/2281/lists#t=201702081054039105395&a=remarks
02:55:32 <erisco> I clarify most of the misconceptions there
02:56:04 <erisco> they are all based on mistakes I've seen
02:56:45 <erisco> and recalling learning Haskell, the overlap of brackets, commas, and colons was confusing
02:58:36 <phadej> but that's just syntax, the data and newtype are different "below" the syntax as well
02:58:43 <bitonic> erisco: so, the list type has two constructors: (:) and []. You can pattern match on them as you would with any data constructor, `a : (b : [])` etc. What's added is a shortcut to pattern match on whole lists using the syntax that you use to construct lists
02:59:03 <erisco> I wrote that section I linked to you
02:59:21 <bitonic> Would you prefer it to only be able to pattern match using `:` and `[]`? I find the full list pattern matching quite handy
02:59:47 <bitonic> But yes that's syntactic sugar that does not add expressiveness, while `newtype` does
03:00:01 <erisco> this isn't the point I am making. I am saying that having more than one way to do the same thing is confusing
03:00:16 <phadej> it's _not_ the same thing
03:00:17 <bitonic> erisco: well then you won't like Haskell's syntax, it's full of duplication
03:00:17 <erisco> things that look different but are the same, or just subtly different, leaves a lot of confusion
03:00:24 <bitonic> But this is not about `newtype`
03:00:30 <bitonic> `newtype` is not the same thing as `data`
03:00:48 <erisco> you're right that I have some qualms with Haskell's syntax but it is hard to complain given every other language in common use
03:00:48 <bitonic> While pattern matching using [a,b,c] is the same as pattern matching with (a : (b : (c : [])))
03:01:14 <bitonic> Some languages are really adamant about having non-redundant syntax, like Python. I think it's a non-problem
03:01:27 <bitonic> People are going to have difficulties learning Haskell for different reasons imo
03:01:33 <erisco> you are concluding newtype is not the same as data because there are differences. I am saying newtype is too difficult to distinguish from data because those differences are not in reach of a beginner
03:02:14 <phadej> well, I'd say it's beneficial to say "use newdata whenever you have single field single constructor data"
03:02:16 <bitonic> erisco: they're not in reach of a beginner because the beginner does not know Haskell yet. In the process of learning Haskell the differences will become apparent :)
03:02:52 <erisco> that's why I said that :P if you want a way to decide without knowing what you're doing then that is it
03:03:20 <phadej> yes, maybe it's possible to make syntax so the useful thing (i.e. newtype) is "the obvious", then in new languages we probably should
03:03:20 <bitonic> erisco: you gave a wrong rule of thumb though, phadej's suggestion is better even if you don't know what the difference is
03:03:36 <erisco> what was my rule of thumb? I said the very thing
03:03:45 <bitonic> erisco: to ignore `newtype` for now
03:04:01 * bitonic goes for lunch
03:04:16 <erisco> no, I first said exactly what phadej said and then added that you're fine just using data for now
03:09:19 <erisco> jle`, I am still not fully clear on it, but I think the inductive equality is an alright approach
03:11:11 <erisco> jle`, this will usually coincide with type equality but that is alright. Those proofs can uniquely be promoted to the context. However, there are potentially other equalities such as on * which is not the same as type equality
03:11:48 <erisco> and I suppose I enjoy the thoroughness of the inductive definitions *shrug*
03:14:34 <athan> Hey all, I asked a little while ago if it were "possible"[tm] to lens into a lens, so to speak
03:15:21 <athan> for instance, if I lens into some deep substructure, but in the middle there's an `nth` array element I'm getting to first, how could I modify the lens to change that `nth`?
03:15:39 <athan> I'm just postulating some ideas here, not looking for anything practically applicable
03:17:18 <athan> I feel like it /could/ be possible, if there was a god-aweful spanning tree at the type level or something, but I'm not sure
03:17:28 <erisco> not looking for anything practically applicable? you came to the right place :P
03:17:56 * athan ziiiiing that was a good one :v
03:18:20 <tabaqui1> back to haskell Set
03:18:32 <tabaqui1> IntSet has no take/drop/splitAt methods
03:19:21 <tabaqui1> and I don't know how to implement them with O(log n) asymptotic using only library functions
03:19:41 <tabaqui1> because I cannot directly take left branch of a tree
03:19:47 <athan>  tabaqui1: Can't you peek left and right pretty quickly though? hm
03:20:07 <athan> ahh shoot, you can always hack on it yourself though
03:21:17 <erisco> athan, I don't know much about lenses, but they're composable. If you had a way to get to the array, and a way to edit the nth element, those should compose
03:22:08 <tabaqui1> yesterday you've talked that IntSet has not fast "size" method, because we don't need it
03:22:10 <halogenandtoast> I'm coming into the middle of a conversation but `[1,2,3] ^? ix 0` gets an element
03:22:41 <tabaqui1> but when you implement any basic structure, like set, you have some objectives
03:23:12 <tabaqui1> f.e., set - is a structure with O(log n) complexity insert/query/delete operations
03:24:24 <bartavelle> athan, you want to combine an 'over' with a 'view' ?
03:24:46 <athan> bartavelle, erisco: not quite, it's more like treating the lens itself as data
03:24:54 <tabaqui1> and looks like your objectives contain "scan" function, and don't contain "size" and "take"
03:24:55 <athan> composing two functions make the result opaque
03:25:15 <erisco> well the lens is a function and so you can lens it as you would a function
03:25:18 <athan> I'll try and hack something, but it won't be pretty :|
03:25:30 <athan> oh woah, you can lens into functions?
03:25:36 <bartavelle> athan, yeah, if you have code that does what you want to do, that might help
03:25:41 <athan> I thought it was restructed to sums/products
03:26:04 <erisco> well I don't know the lens operators, but this is as trivial as (.)
03:26:08 <athan> erisco: Basically, the idea is recomposing a composition
03:26:08 <bartavelle> look at the 'to' combinator for example
03:26:31 <athan> so, if I have `a -> b` & `b -> c`, that makes `a -> c`, but if I want `b -> d` to replace, that should make `a -> d`
03:26:38 <athan> oh hm
03:26:43 <erisco> (.) edits the return, flip (.) edits the argument
03:27:20 <bartavelle> athan, you mean 'foo = ix 3 . ix 2', and you want 'changeEnd' so that changeEnd (ix 4) foo = ix 3 . ix 4 ?
03:28:00 <bartavelle> (if so I don't think that's possible)
03:28:42 <athan> bartavelle: Well, only if the lenses are functions though :)
03:28:49 <athan> I might be able to make something more data-oriented
03:30:02 <bartavelle> lenses from the lens package are functions
03:30:19 <bartavelle> that's why you can combine them with Prelude's (.)
03:30:36 <erisco> :t (.)
03:30:39 <lambdabot> (b -> c) -> (a -> b) -> a -> c
03:30:53 <erisco> interesting that this hasn't been generalised by Category yet
03:31:09 <bartavelle> imagine the error messages :/
03:31:26 <erisco> hey, they generalised a bunch of other stuff, but I guess Category is a class too far
03:31:50 <athan> erisco: I'm pretty sure it has, the identity lens is just function application for `over`, and get is `id`
03:31:50 <bartavelle> yeah, it would probably break too much code
03:32:43 <athan> bartavelle: I think I'll be doing a lot of type-level machinery to make it happen, which means I get to use GHC 8's Error type! So hopefully it will be... readable >.>
03:33:03 <erisco> I'm in favour of Prelude.ForDummies. I could use this for a number of packages :P
03:33:13 <bartavelle> athan, we were talking about the fact that there is an alternative definition of (.), with the Category type class
03:35:37 <athan> bartavelle: Oh! Derp, I thought that was integrated already :)
03:42:13 <athan> It looks like GHCJS doesn't have any releases on their repository... is it fully-compatible with GHC 7.10 or something? I'd just like to know what version of GHC it claims to mimick
04:13:11 <Rodenbach> I have an annotation   foo :: (Eq a, Num a, Enum a) => a -> [[Int]]     now when I do  :t foo I can see it. If I do  :t foo 10   I see [[Int]], as expected.  But is there a way to get the type of the 10 inside this expression, in ghci?  Can I apply the  :t   somehow to it?
04:16:47 <lyxia> I can't see a straightforward way of knowing how foo is defaulted.
04:18:42 <lyxia> Set MonomorphismRestriction, define    x = x where _ = foo x   , type :t x
04:19:30 <merijn> You can with a simple local definition
04:19:46 <merijn> Just need to copy asAppliedTo from lambdabot :)
04:19:50 <merijn> :t elem
04:19:53 <lambdabot> (Foldable t, Eq a) => a -> t a -> Bool
04:20:00 <merijn> :t elem `asAppliedTo` 'c'
04:20:02 <lambdabot> Foldable t => Char -> t Char -> Bool
04:20:15 <merijn> That only works for the first argument, but still
04:20:35 <merijn> :t asAppliedTo
04:20:37 <lambdabot> (a -> b) -> a -> a -> b
04:20:51 <merijn> Just copy that type and set "asAppliedTo = const"
04:37:53 <karol-cis> Hey everyone :) I am a student at Imperial College on a gap year. Looking to contribute to a cool project, if anyone needs my help
04:38:22 <karol-cis> Anyone knows where I can look?
04:38:56 <dcoutts> karol-cis: infrastructure is always useful :-)  we're always looking for help with cabal & hackage
04:39:21 <dcoutts> ask in #hackage
04:39:37 <karol-cis> Thanks a lot :-)
04:53:45 <old1101> hello, why haskell has a weird syntax for "multiline"? It has a name or influence? like this http://lpaste.net/2033144488934768640
04:54:04 <old1101> the commas
04:54:32 <osa1> old1101: it's not for "multiline". commas used to separate elements in lists, you can put them wherever you want
04:55:02 <old1101> osa1: yes, but why this has become the standard?
04:55:14 <osa1> old1101: it's not standard, some people like this style some don't
04:55:46 <old1101> osa1: I think I haven't found a code on github without this style haha
04:56:16 <osa1> old1101: spend more time reading Haskell and you'll see for sure :)
04:56:31 <hpc> old1101: that style is a lot like K&R
04:57:18 <hpc> old1101: it largely exists because some of the language creators preferred it, but it has some rather weird parts and not as many people use it as you would expect
04:58:12 <hpc> as for not seeing lists written in any other way, it's pretty rare to see multi-line lists like that
04:58:52 <merijn> It has the advantage of allowing a nice consistent pattern for line wrapping
04:59:02 <merijn> the commas lining up with the opening [
04:59:08 <old1101> hpc: thanks, influence on ghc/prelude makes sense
04:59:22 <merijn> I've grown rather fond of this style, I use it in C now too
05:00:09 <merijn> And I think most people grow fond of it after a while
05:00:32 <hpc> i personally write it in more of a json-like style
05:00:49 <hpc> makes it easier to see where things start and end
05:01:03 <tfc> hi there. i wrote a function whileM :: (Monad m) => m Bool -> m ()  which i can execute like "whileM my_monadic_function" in a loop until it errors out.
05:01:14 <tfc> but i was told that there should be a library function like that. i cannot find it.
05:01:31 <hpc> it's not indexed by hoogle for some reason
05:01:32 <hpc> @hayoo
05:01:33 <lambdabot> Unknown command, try @list
05:01:35 <hpc> @where hayoo
05:01:35 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
05:01:51 <hpc> hayoo has a more complete index, but is slower and doesn't always put the most relevant stuff at the top
05:02:31 <merijn> tfc: Have a looke at the monad-loops package
05:02:40 <systadmin> I use Hoogle
05:02:59 <merijn> Hoogle doesn't index everything that exists on Hackage
05:03:04 <merijn> (sadly)
05:03:20 <tfc> merijn: oh that looks useful.
05:03:26 <tfc> for what reason isn't that listed on hoogle?
05:03:31 <tfc> not stable or whatever?
05:03:54 <old1101> merijn, hpc: it's weird at first glance, I'll stick with json-style until perhaps I like it
05:03:56 <merijn> tfc: No particular reason, hoogle covers only a rather small portion of common libraries
05:04:07 <merijn> I have no idea what json-style means
05:04:38 <lyxia> old1101: I would indent lines 9 and 23 less. This style makes the amount of whitespace in front of each line in a block more consistent.
05:04:57 <systadmin> Well... The only thing I *Hoogle* for are what the built-in functions do
05:05:23 <merijn> Incidentally, you can setup a local Hoogle and config cabal to add any package you install to the Hoogle database
05:05:39 <tfc> merijn: ok, hayoo has it. so i will query both search engines in the future. thank you
05:06:18 <hpc> merijn: the typical style you see from most imperative languages, but in haskell i find it reminds me more of json than of blocks of code
05:06:21 <old1101> lyxia: true, I actually just borrow the code I was reading hah
05:06:21 <hpc> Foo {
05:06:27 <hpc>   record = [
05:06:29 <hpc>     1,
05:06:32 <hpc>     2, ...
05:08:00 <lyxia> hpc: good point.
05:09:39 <ahihi> help, I'm stuck in an unclosed list
05:13:38 <hpc> there's probably a bunch of unclosed lists in the channel history by now
05:13:43 <hpc> ]]]]]]]]]]]]]]]]}}}}}}}}}}}}}}}}}}}}))))))))))))))))))))))))
05:13:45 <hpc> you're welcome
05:13:51 <ahihi> :-)
05:14:52 <merijn> hpc: syntax error
05:16:04 <lyxia> What have you done? You matched your { with a ].
05:17:40 <hpc> pppsh, that's not how parenthesis work silly
05:21:04 <lyxia> How much suffering can a language cause with 9 kinds of brackets corresponding to all possible pairings of ([{ and }])?
05:22:26 <hpc> people use php every day
05:24:08 <old1101> and js callback hell
05:26:27 <merijn> Is there a pre-defined "[minBound..maxBound]" somewhere?
05:26:49 <Phyx-> hpc: some even like it.. so i've heard..
05:33:29 <merijn> Any typeclass(es) for Show/Read when you don't want to produce valid Haskell syntax? Or should I just abuse Show/Read?
05:37:17 <bitonic> merijn: pick one of the `Pretty` classes if they work for you
05:37:26 <bitonic> Personally I don't like to abuse `Show` that way
05:37:37 <bitonic> But I don't think there's anything standard
05:38:19 <Tuplanolla> There was a joke Lisp variant where you could only define procedures as the surrounding parentheses, lyxia.
05:39:06 <merijn> I guess I could use Iso from lens, but that means pulling in lens as dependency...
05:39:12 <Tuplanolla> There are lots of them starting at U+2700.
05:42:48 <lyxia> Tuplanolla: hahaha that's good.
05:43:44 <merijn> hmm, is there a nice way to create an iso from pairs of values? I don't wanna write out the conversion in both directions
05:44:10 <Tuplanolla> Can you leverage `Enum`, merijn?
05:44:44 <merijn> Tuplanolla: In what way?
05:45:05 <phadej> toEnum . fromEnum in both directions
05:45:22 <phadej> :t toEnum . fromEnum
05:45:24 <lambdabot> (Enum a, Enum c) => a -> c
05:45:48 <merijn> Well, no, because the Enum for String is unlikely to be useful :p
05:46:52 <phadej> pairs of values: you wan't have lawful Iso (it would be a Prism)
05:47:37 <merijn> oh, I suppose
05:48:01 <merijn> I dunno, I just don't wanna write the exact same case twice with the left/right side of -> swapped
05:48:42 <phadej> merijn: I write something like: https://github.com/futurice/haskell-mega-repo/blob/3217f7bbfa2acbf57442f14fe4c544818c3b7c3d/checklist-app/src/Futurice/App/Checklist/Types/Location.hs#L36-L50
05:49:46 <phadej> I don't know better solution
05:51:56 <merijn> phadej: oh, that's already better
06:15:57 <BernhardPosselt> regarding Monoids: you define them per type correct? arent there sometimes more than one operation per type?
06:16:03 <BernhardPosselt> e.g. ints have sum and product
06:16:19 <ketil_> Hi!  I'm trying to compile an executable with profiling, but of course there is a huge mess of libraries installed without profiling support.  Is there a way to use a sandbox or whatever to get cabal to just download and install what's missing?
06:16:22 <merijn> BernhardPosselt: Correct, usually people use newtypes for that
06:16:32 <merijn> BernhardPosselt: For example, see Sum and Product in Data.Monoid
06:16:49 <merijn> > getSum . mconcat . map Sum $ [1..10]
06:16:51 <lambdabot>  55
06:16:56 <ketil_> Currently, it will complain about one library at a time that exists in the global directory (/usr/lib).
06:17:00 <merijn> > getProduct . mconcat . map Product $ [1..10]
06:17:02 <dcoutts> ketil_: yes you can use a sandbox or the "cabal new-build" beta-ui which handles this stuff much better
06:17:03 <lambdabot>  3628800
06:18:16 <ketil_> dcoutts, how?   My cabal doesn't know about new-build.  How can I get the sandbox to ignore globally insatlled stuff?
06:19:16 <dcoutts> ketil_: oh, the sandboxes do not ignore globally installed stuff, it works on the assumption that the only global things are what come with ghc or with your distro (which will usually install prof versions too, or at least can do)
06:19:28 <dcoutts> ketil_: the new-build ui is in version 1.24+
06:19:37 <dcoutts> or better, in cabal head, if you want to that that new ui
06:20:31 <BernhardPosselt> ok, so tl;dr: a monoid is just a very abstract interface to define operations on types that are assoc and have a neutral element and you need specific instances for using them :)
06:21:01 <ketil_> Ngh.  I fear /usr/lib is now a wild combination of stuff installed via cabal and via apt-get.  So there's no way for me to clean it out safely, and no way to get cabal to ignore it.. 
06:21:27 <ketil_> Seems like it is easiest to find a different machine with nothing installed, and use that as a physical sandbox... :-P
06:21:30 <merijn> BernhardPosselt: Usually there's an "obvious" default instance (such as concat for lists), but in cases of Sum/Product we usually define newtypes for the alternate behaviour
06:21:35 <dcoutts> ketil_: it should be /usr/local/lib for cabal and /usr/lib for apt-get
06:21:46 <merijn> BernhardPosselt: See also "Data.Monoid.Dual" which is the "flip mappend" monoid
06:21:59 <ketil_> Hm.  ghc-pkg only showed /usr/lib, no /usr/local/lib.  Let me check again.
06:22:20 <BernhardPosselt> as for using the interface: you usually want a Monoid for parallel computations, right?
06:22:52 <merijn> Not particularly, they're useful for lots of things
06:23:02 <BernhardPosselt> what are other usecases?
06:23:36 <BernhardPosselt> (apart from being able to combine things :D)
06:24:12 <Welkin> monoids?
06:24:14 <Welkin> semigroups?
06:24:18 <BernhardPosselt> yes
06:24:25 <merijn> BernhardPosselt: I had a neat example yesterday, lemme see if it's logged
06:24:42 <Welkin> BernhardPosselt: monads are monoids, too
06:25:07 <BernhardPosselt> right, but thats not really helpful in understanding the usecase :D
06:25:11 <merijn> Not particularly helpful and not true
06:25:31 <Welkin> it's true, just not in haskell's typeclass system
06:25:48 * Baughn likes defining monads as the intersection of (Functor, application, has-join). ...are we doing a monad tutorial again?
06:25:49 <merijn> Welkin: It requires a monoid instance on the type inside the monad
06:25:57 <Baughn> *Applicative
06:26:12 <Welkin> merijn: how about monoids and finger trees?
06:26:30 <Welkin> http://apfelmus.nfshost.com/articles/monoid-fingertree.html
06:26:41 <ketil_> dcoutts - /usr/local/lib only contains python, so my cabal is apparently misconfigured.
06:26:41 <cocomo> is it possible to traverse over a non-binary tree with tail recursion? because it seems like there are two sub-problem? 1. traversing siblings 2. traversing children.. 
06:27:14 <merijn> BernhardPosselt: See this example of using Monoid for multi-column sorting: http://www.irclogger.com/.haskell-beginnerS/2017-02-07#1486484972
06:27:15 <dcoutts> ketil_: or perhaps you didn't install things globally with cabal at all
06:27:33 <dcoutts> ketil_: afterall it's not the default, you have to explicitly use --global and sudo to do it
06:27:34 <Welkin> cocomo: write a fold for your tree datatype
06:27:41 <merijn> cocomo: 1) yes, it's possible 2) tail recursion in haskell is not as relevant as you might be thinking
06:27:42 <BernhardPosselt> merijn: thanks
06:27:48 <Welkin> Foldable/Traversable instance
06:27:55 <ketil_> Oh yes, they have today's date.  I apt-get remove'd all libghc*, so now it is only my own cruft (and what comes with ghc) left.
06:30:21 <cocomo> Welkin: thank you. merijn I am using a flavor of purescript, they emphasis on tail recursion.
06:30:29 <merijn> Is there a datatype to use for bounds on Int ranges? i.e. an upperbound that is either unknown or some specific value
06:30:30 <Welkin> a flavor?
06:30:34 <Welkin> I thought there is only one purescript
06:30:42 <BernhardPosselt> merijn: i see, Comparator.comparing in java which is lovely
06:30:53 <cocomo> sorry, mixed my thoughts there. I mean't purescript*
06:31:07 <merijn> cocomo: Ah, then I don't know, I have no clue how purescript compiles
06:32:53 <merijn> I could use "Maybe Int", but I think that compiles the wrong way...
06:33:45 <Welkin> merijn: what are you asking exactly?
06:33:48 <cocomo> merijn: it compiles to js and js call stack overflows if you don't do tail recursion. purescript compiles tail recursions to a loop.
06:34:12 <Welkin> cocomo: not in es6
06:34:23 <Welkin> oh, yeah I see
06:34:47 <Welkin> purescript should optimize that away though
06:35:33 <merijn> Welkin: I don't think what I want exists, I'll write out a quick implementation to show what I mean
06:35:47 <cocomo> i hear a js guru/standards committe member crockford douglas say tail recursion didn't make into the es6 standards
06:36:10 <cocomo> sorry I should've googled that before saying it. I am not sure.
06:36:26 <Welkin> BoundedInt bound value
06:36:27 <Welkin> ?
06:36:33 <Welkin> something like that?
06:37:08 <merijn> Welkin: No, not a bounded int, but a type for computing with bounds
06:37:52 <merijn> Like
06:37:55 <merijn> data Min a = MinusInfinity | Min a
06:37:55 <merijn> data Max a = Max | MaxInfinity
06:38:22 <tfc> anyone experienced with conduit? i took a line of code from the tutorial and it doesn't work: (Inherited, src, ClosedStream, cph) <- streamingProcess (shell "cat")
06:38:27 <tfc> it tells me  Ambiguous type variable ‚Äòstdout0‚Äô arising from a use of ‚ÄòstreamingProcess‚Äô
06:38:34 <tfc> am i missing something important here?
06:39:27 <merijn> tfc: It means stdout0 is some kinda typeclass polymorphic variable and GHC can't infer what you wanted it to be
06:39:43 <tfc> the error message tells me i could use instance [safe] OutputSink UseProvidedHandle
06:39:52 <merijn> What library is that from?
06:40:04 <Welkin> tfc: try copying the entire example instead of one line
06:40:09 <tfc> Data.Streaming.Process
06:40:20 <merijn> THat's a module, not a library
06:40:35 <tfc> ok, its a module from the conduit streaming lib
06:41:01 <tfc> Welkin: there is no code which defines that "src" before, which is why i don't understand it. it's that tutorial https://github.com/snoyberg/conduit/blob/master/PROCESS.md
06:42:30 <merijn> It's not from conduit, because Data.Conduit.Process does not exist in the conduit package
06:42:52 <Welkin> just copy the whole example
06:43:08 <merijn> tfc: Are you trying it in ghci?
06:43:13 <tfc> Welkin: i see. when i copy ALL code from the example, it does indeed work. but that is strange, because that var "src" is used _after_ that other line which had the problem
06:43:14 <Welkin> there can be ambiguity because there is not enough information to infer the types
06:43:22 <tfc> how does this work? this looks magic.
06:43:32 <tfc> is this kind of "lazy inference"?
06:43:33 <Welkin> you are not doing anything with the outputs from that action that you are matching on (src, cph)
06:43:37 <merijn> tfc: GHC inference is not bound by ordering so the use later is perfectly sane
06:43:38 <Welkin> but the code one line down uses them
06:43:49 <tfc> wow i was not aware of this.
06:44:01 <tfc> ok, thank you. that solves my problem and i think i understand.
06:44:04 <merijn> tfc: All inference is at compile time, so before code ever runs. So the order of execution is not relevant for type inference
06:44:47 <merijn> tfc: If you do it line by line ghc gets confused because it's polymorphic. In the full example the latter use lets GHC infer which of the possible options you actually wanted
06:45:14 <tfc> i thought that's not possible. :-D
06:46:35 <merijn> > (1/0)
06:46:37 <lambdabot>  Infinity
06:46:40 <merijn> > (1/0) + 2
06:46:43 <lambdabot>  Infinity
06:46:47 <merijn> > (-1/0) + 2
06:46:50 <lambdabot>  -Infinity
06:49:25 <chelfi> > (-1/0) + (1/0)
06:49:27 <lambdabot>  NaN
06:50:08 <Tuplanolla> > let x = 1 / 0 Ôºã x in x
06:50:10 <lambdabot>  error:
06:50:10 <lambdabot>      ‚Ä¢ No instance for (Num Fatality) arising from the literal ‚Äò1‚Äô
06:50:10 <lambdabot>      ‚Ä¢ In the first argument of ‚Äò(/)‚Äô, namely ‚Äò1‚Äô
06:50:22 <merijn> wut
06:50:31 <Tuplanolla> > let x = (1 / 0) Ôºã x in x
06:50:33 <lambdabot>  Fatality
06:51:02 <merijn> What's the minimal lines of code to instance Functor + Applicative + Monad?
06:51:31 <merijn> For 7.10 and later
06:51:37 <Tuplanolla> I guess three for `fmap`, `<*>` and `>>=`, merijn.
06:52:07 <merijn> <*> is annoying to define and I think you can do that with "ap"
06:53:22 <quchen> fmap = liftM, pure = ‚Ä¶, <*> = ap, >>= = ‚Ä¶
06:53:31 <quchen> merijn: ^
06:54:00 <the_other_cat> Hello, sorry for the newbie question but how can I list only packages which are installed in a cabal sandbox?
06:54:02 <merijn> And rely on return defaulting to pure?
06:54:09 <merijn> the_other_cat: cabal sandbox hc-pkg list
06:54:11 <Welkin> the_other_cat: cabal freeze
06:54:13 <Tuplanolla> Right, I forgot `pure` there.
06:54:14 <Welkin> oh
06:54:29 <quchen> merijn: I‚Äôm not sure 7.10 already had return as a non-required definition
06:54:39 <quchen> Maybe you need to add return = pure
06:54:41 <merijn> quchen: We'll see
06:55:03 <Tuplanolla> Yet the answer is still three if you use `DeriveFunctor`, merijn.
06:57:11 <the_other_cat> merijn: I tried that, yet it lists xmonad-0.11 although I just did cabal sandbox init in a fresh directory?!
07:03:55 <merijn> If I have a type "data Foo a" I can't have a different instance for "Enum (Foo a)" depending on whether 'a' is Bounded, right?
07:04:59 <mniip> no
07:05:11 <merijn> Rats...
07:05:19 <mniip> the instance dictionary for Enum (Foo a) will be pi-quantified then
07:05:24 <noan> Today I switched my keyboard layout to Danish so I could write an √ò easier to represent emptyset. To hell with being able to type properly otherwise!. That is all. Worth it.
07:05:37 <mniip> ‚àÖ
07:05:41 <mniip> U+2205
07:05:42 <noan> √∏
07:05:52 <noan> five keys... or one?
07:05:54 <noan> :D
07:06:32 <Tuplanolla> It may look the same, but it's a completely different character, noan.
07:06:40 <noan> Tuplanolla, I'm very aware.
07:06:58 <Tuplanolla> This should give you an unpleasant feeling like leaving open a parenthesis.
07:07:44 <noan> Jokes on you, I am not a parser!
07:07:51 <merijn> mniip: Sadly that makes the instance I have to write impossible :\
07:08:42 <Tuplanolla> You can only redeem yourself by pronouncing it like a Dane would, noan.
07:08:52 <mettekou> Is it a bad practice to create Read and Show instances which read and show pattern synonyms, rather than constructors?
07:08:56 <noan> L√ÜS MERE
07:09:21 <noan> Tuplanolla, I speak swedish. Speaking Danish is a very fun joke between my partner and I. And the rest of this country.
07:09:29 <noan> f.eks
07:10:44 <mettekou> noan: I thought Scandinavian (Danish, Swedish and Norwegian, not Finnish of course, because it's not Germanic) people just spoke their language to one another because the differences are small enough to be worked out at run-time? üòú
07:11:36 <noan> mettekou, sort of. English gets used with the danes a lot, because we have trouble understanding them. But yeah, I'm an immigrant here and I don't even usually notice if someone is speaking Norwegian. I think they just speak funny.
07:11:43 <noan> "What a weird accent"
07:13:00 <Tuplanolla> People at the university sometimes speak English to each other even if they share a common language, because nobody knows how to translate technical terms, mettekou.
07:14:02 <noan> there's also a lot of english loan words in Swedish and other nordic languages, yeah. I guarantee a Monad is still a Monad.
07:15:17 <mettekou> noan: Is that a loan word from English though? I thought it came from Latin.
07:17:03 <mettekou> noan: Just looked it up, it comes from the ancient Greek for unity.
07:17:12 <noan> mettekou, probably not in this case. I suppose I more realistically meant "foreign words for technical things". Juice is Juice lolXD
07:17:48 <Tuplanolla> It's a made-up mix of several words, mettekou, most likely derived monoid and triad.
07:17:57 <merijn> > (0/0)
07:18:01 <lambdabot>  NaN
07:18:21 <merijn> > toRational ((0/0) :: Double)
07:18:28 <lambdabot>  (-26965397022934738615939577861835371004269654684134598591014512173659901370...
07:18:30 <Tuplanolla> See Saunders Mac Lane's book, page 138.
07:18:31 <merijn> hmmm
07:18:36 <merijn> That seems...odd?
07:19:00 <merijn> How can Real/Integral/RealFrac/RealFloat ever be implemented for types that have "NaN" values?
07:19:04 <makalu> this is a subset of my stack.yaml file http://lpaste.net/4260262852146757632 when I run stack build it complains that text-1.2.0.6 requires integer-simple. I don't know where this dependency comes from in the first place since text only requires integer-simple when you specify a flag. Even so, the fact that I added integer-simple does not help. How can I build text like this? I actually want...
07:19:05 <makalu> ...to later replace the URLs with self-hosted package URLs.
07:19:18 <merijn> > toInteger ((0/0) :: Double)
07:19:20 <lambdabot>  error:
07:19:21 <lambdabot>      ‚Ä¢ No instance for (Integral Double)
07:19:21 <lambdabot>          arising from a use of ‚ÄòtoInteger‚Äô
07:19:30 <noan> merijn, through lies. Thanks IEWhatever specifications!
07:19:33 <merijn> oh... that one's obvious, I suppose
07:19:42 <merijn> noan: Yes, but which lies am I supposed to use?
07:20:00 <merijn> I have a type with NaN like values and I'm unsure what to return
07:20:12 <merijn> > toRational ((1/0) :: Double)
07:20:15 <noan> merijn, https://openclipart.org/download/243784/Mentally-Deranged-Smiley-Face-Silhouette.svg
07:20:15 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
07:20:39 <mettekou> Tuplanolla: Page 138 doesn't discuss the etymology of the word though, it just laments about the overuse of triple for the construction.
07:21:32 <merijn> heh...
07:21:49 <byorgey> mettekou: see http://english.stackexchange.com/questions/30654/where-does-the-term-monad-come-from
07:21:58 <merijn> Double is an instance of RealFloat without being one of RealFrac which is a superclass? I'm confused
07:23:17 <merijn> Anyone?
07:23:43 <glguy> merijn: Double is an instance of RealFrac
07:23:59 <merijn> glguy: Where is the instance? It's not in the haddocks
07:24:13 <glguy> merijn: Try typing ":i Double" in GHCi
07:24:21 <mettekou> byorgey: I find it hard to believe that there is no link between the word in the context of category theory and its earlier use in the context of philosophy.
07:24:25 <glguy> It'll show you the instances and where they're defined
07:24:39 <mettekou> Although it's not impossible that they're unrelated, I guess.
07:24:57 <byorgey> mettekou: well, I find it easy to believe.
07:24:59 <mettekou> Or rather that their etymology is, because their meaning is obviously unrelated.
07:25:03 <merijn> glguy: GHC.Float, but that module has no haddocks either...
07:25:54 <byorgey> mettekou: it seems pretty clear from the available evidence that there is no link.
07:27:25 <merijn> hmmm, maybe I should just basically use Double's implementation of toRational for my NaN value...
07:27:47 <mnoonan> there is no link to the "monad" in "monadic second-order logic" either, right?  That's always annoyed me..
07:27:49 <merijn> Then I just have to invent something for Integral
07:39:31 <halogena1dtoast> I successfully finished and released my first yesod app online. Thanks #haskell for all the help.
07:48:47 <merijn> Any opinions whether something like: http://lpaste.net/352229 would be a useful addition for Data.Monoid?
08:02:32 <shapr> halogena1dtoast: yay! link?
08:12:07 <halogena1dtoast> shapr: nhk.halogenandtoast.com and http://github.com/halogenandtoast/nhk-reader-haskell for source
08:12:52 <shapr> oh that's neat!
08:16:09 <byorgey> merijn: this is already in the monoid-extras package, in Data.Monoid.Inf .  There might be some instances missing, I'm happy to consider a PR.
08:17:14 <Profpatsch> I want a class where you can define displayable names for all fields in a Record 
08:17:16 <Profpatsch> Something like data Foo { a :: Int, b :: Bool }                                  
08:17:18 <Profpatsch> (fieldsOf :: Foo -> [Text]) $ Foo 2 3  == [ "A field", "B field" ]               
08:17:20 <Profpatsch> I need that all the time for user interfaces.                                    
08:17:29 <Profpatsch> I‚Äôm sure something similar exists already, maybe with Proxies.
08:17:39 <Profpatsch> Can I haz pls?
08:18:11 <Profpatsch> And it should invalidate the instances somehow if there is a new field.
08:21:29 <glguy> Profpatsch: like this? http://lpaste.net/167793
08:41:40 <Profpatsch> glguy: That‚Äôs cool, yes.
08:42:12 <Profpatsch> glguy: But! It‚Äôs explicitely not for the field names as they exist.
08:42:25 <Profpatsch> But for attaching a ‚Äúname‚Äù to each field.
08:43:57 <Profpatsch> Maybe even with a naming of type forall a. a possible.
08:44:15 <orion> Hey. My goal is to accept an email from postfix on stdin, pull out the From, To, Subject, Body, and Attachments, convert it to JSON, and send it off to RabbitMQ for further processing. Does anyone know of any good libraries for parsing emails?
08:44:42 <Profpatsch> And you can instantiate it for each type, e.g. Named (Html ()) Foo
08:44:55 <Profpatsch> Ah, I‚Äôm procrastinating again. :)
08:45:40 <shapr> orion: https://hackage.haskell.org/package/hsemail ?
08:45:46 <tlahtoani> Would learn you a Haskell for great good be a good starting point for a beginner? 
08:46:04 <shapr> tlahtoani: I'm a huge fan of haskellbook.com, but it's also $60
08:46:25 <shapr> learn you a haskell is one of the good free options, but some of it isn't up to date anymore
08:47:00 <tlahtoani> Is it a print book?
08:47:04 <Profpatsch> I‚Äôm sure edwardk has written that class somewhere already.
08:47:22 <tlahtoani> I kinda need a print book 
08:49:29 <jaspervdj> What's a good regex library to use these days?  I haven't looked at the space in a while.
08:49:51 <jaspervdj> I'd prefer something which doesn't need C libraries, and UTF-8 support is a must.
08:50:13 <tlahtoani> Pcre is best
08:50:44 <Jaxan> I want to define generic instances for one of my type classes. I a bit puzzled at the f :.: g (composition) type. For what kind of data types is the composition used?
08:51:00 <shapr> tlahtoani: I know graham hutton's Programming in Haskell was recently updated to the second edition, but I've only read the 1st edition.
08:51:28 <Jaxan> I experimented with some algebraic data types, but they only had :*: and :+:
08:51:49 <glguy> Jaxan: It's used when implementing the Rep1 type family from GHC.Generics for datatypes that use composition
08:51:50 <orion> shapr: Thank you.
08:52:12 <glguy> Jaxan: Rep1 is paired up with Generic1. You won't see :.: used with normal Generic
08:52:49 <shapr> Speaking of which, I keep thinking Turtle's grep command accepts regexes, but I think it wants parsec-style parsers.
08:53:14 <Jaxan> glguy: ah, I see. The [Class]1 things are a bit above my head still... So I'm ignoring them.
08:53:30 <lpaste_> glguy pasted ‚Äúgeneric1 example for Jaxan‚Äù at http://lpaste.net/352231
08:53:31 <jaspervdj> tlahtoani: Yeah, but I've looked into building pcre on windows and it seems like a lot of pain.
08:53:50 <glguy> Jaxan: well, maybe get on your toes and peek at that paste, then:)
08:56:08 <tlahtoani> I saw a thing on guards and matching which got me super interested in Haskell 
08:56:28 <Jaxan> glguy: thanks, that makes sense.
08:57:53 <shapr> tlahtoani: I still prefer haskellbook.com, but it looks like graham hutton's recently updated book is popular: https://www.amazon.com/Programming-Haskell-Graham-Hutton/dp/1316626229/
08:58:43 <Jaxan> glguy: Say I'm writing a Foo typeclass. Does implementing something for :.: makes sense without a Foo1 class?
08:59:11 <tsahyt> hello, I'm playing around with reactive-banana after having had some time with AFRP. As a first simple example I just want a running time counter (getTime Monotonic) as output. I can use fromPoll to build a Behavior for that value, but then I can't print it. How can I poll into an Event?
08:59:58 <glguy> Jaxan: :.: only makes sense if you intend to derive your implementations with to1 and from1
09:00:13 <glguy> If you're using to and from, then you can forget about :.:
09:00:27 <Jaxan> Ok, then I understand
09:01:12 <tlahtoani> Haskell book is not print though 
09:01:46 <shapr> tlahtoani: yes, but still totally worth it.
09:02:55 <CuriousErnestBro> jaspervdj, mind if I send you a PM?
09:03:03 <tsahyt> basically I'd like an Event Int as an event stream of ticks.
09:03:16 <jaspervdj> CuriousErnestBro: no, go ahead!
09:08:39 <tsahyt> hmm, it seems there really is no way to actually generate an event stream this way, as it only works via AddHandlers and that only works with callback mechanisms
09:16:01 <janos> Hi, can somebody explain me, what a type ((:) * Text ([] *)) means?
09:16:18 <janos> especially: the * 's ?!
09:17:04 <janos> when applying (:) this results in * Text : ([] *) right?
09:17:13 <janos> but what does the * stand for?
09:17:16 <glguy> janos: The * is a kind
09:17:33 <glguy> You're seeing a type with an explicit kind application
09:17:59 <janos> :k Text
09:18:01 <lambdabot> error:
09:18:01 <lambdabot>     Not in scope: type constructor or class ‚ÄòText‚Äô
09:18:20 <janos> something like these "type"s ?
09:18:32 <janos> (sorry for thus noob questions :D )
09:18:51 <glguy> As a "noob" you shouldn't really have to deal with those, I'd think. Where are you seeing them?
09:19:05 <janos> glguy: in the spock webserver library
09:19:38 <janos> glguy: any idea where I could read more about this stuff?
09:20:27 <glguy> The relevant extension here would be DataKinds
09:22:01 <janos> glguy: thank you, I'll look into it and try to understand it :)
09:22:23 <glguy> The (:) and [] here aren't the normal value ones
09:22:41 <tsahyt> should one use gtk or gi-gtk for a new project these days?
09:22:46 <glguy> They've been "lifted" to the type level
09:23:14 <glguy> tsahyt: I recently switched a small project from gtk to gi-gtk and liked how it went
09:23:28 <glguy> afaik they're both active projects
09:23:29 <tsahyt> glguy: I've only used gtk so far, what does gi-gtk do differently?
09:24:53 <glguy> it tries to be less clever, it's "just" a direct binding to all of the gtk api machine generated from the gobject introspection information
09:25:13 <glguy> and then it uses the new OverloadedLabels extension to try and make it nicer to use "methods" on gtk objects
09:25:21 <tsahyt> hmm sounds interesting
09:25:23 <tsahyt> thanks!
09:25:39 <glguy> My experience trying to use the gtk package as that it's support for list views was buggy and incomplete
09:25:51 <glguy> and that was the main thing I needed
09:26:18 <glguy> https://github.com/glguy/CookieCalculator/blob/master/gui/Main.hs
09:27:00 <glguy> I have some code there for using GHC.Generics to match a Haskell record with a glade file that you might find helpful
09:28:10 <glguy> Note that there is in fact documentation for the gi-* packages on hackage, but you have to look for it
09:28:11 <glguy> http://hackage.haskell.org/package/gi-gtk-3.0.11/docs/
09:28:48 <glguy> Hackage consults the .cabal file for the module list when building the table of contents, but gi-* uses dynamically generated modules
09:29:44 <tsahyt> oh that's why, I was already wondering
09:30:04 <tsahyt> is the entire gi-* stuff all generated then?
09:31:56 <Zowlyfon> tsahyt, you talk!
09:32:27 <tsahyt> I do indeed
09:33:07 <Ikarus> Hi, does anyone have a tutorial for create an expression parser with lexer/tokenizer with Parsec?
09:35:48 <cocreature> Ikarus: I don‚Äôt know of a full tutorial, but there is an example at the bottom of https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Expr.html
09:36:11 <tsahyt> does anyone here have experience with the wires package?
09:38:45 <unyu> There was a library with a type similar to Either, except its constructors were This, That and These. I forget what the library was called, though. Anyone remembers?
09:39:06 <unyu> Errr, never mind. Found it.
09:39:13 <Ikarus> thanks cocreature 
09:44:01 <pikajude> unyu: in future, you can use hayoo
09:44:06 <pikajude> http://hayoo.fh-wedel.de/?query=These
09:57:06 <roconnor> I have error: Could not deduce b ~ a1 .... Relevent bindings include refl :: b Data.Type.Equality.:~: a1  
09:57:08 <roconnor> :/
09:57:23 <glguy> print the kinds?
09:57:44 <glguy> or case on the refl?
09:59:03 <roconnor> I do have a case
09:59:26 <roconnor> ... In case alterantive Just refl -> let z = zero in pair z z ...
09:59:34 <glguy> Oh, Just Refl
09:59:36 <glguy> not refl
09:59:37 <roconnor> ahhh
09:59:41 <roconnor> ty!
09:59:45 <roconnor> ha ha
10:00:35 <roconnor> the world makes sense again.
10:19:24 <qmm> is multi-node concurrency possible with stm?
10:25:27 <reactormonk> Is an IsString instance the correct thing when I want to define an instance that's not total? E.g. an URI, not every string is an URI.
10:27:44 <qmm> i guess not 
10:30:20 <dolio> I'm not a fan of that.
10:30:31 <skeuomorf> What does that colon do? http://lpaste.net/2665345129237184512#line4
10:30:43 <skeuomorf> What's that syntax I mean?
10:31:03 <kadoban> (:) is the list "cons" constructor, it's how you add an element to the beginning of a list
10:31:12 <dolio> I feel like a quasiquoter would be nicer, since it could give you errors for malformed URLs at compile time.
10:31:28 <skeuomorf> kadoban: oh, right
10:31:32 <skeuomorf> kadoban: thanks!
10:31:36 <kadoban> It's used once there to do that, and a few times in pattern matches, where it's (partially) deconstructing lists.
10:31:37 <kadoban> Anytime
10:32:35 <skeuomorf> yeah, still not used to the let..in syntax so got thrown off a bit
10:35:08 <kadoban> Yeah, there's definitely a mix of stuff there I could see being confusing if you're not solid on all of them.
10:35:31 <skeuomorf> Yeah, it's from http://book.realworldhaskell.org/read/functional-programming.html
10:35:48 <kadoban> Ah, that's why it looked familiar
10:36:16 <prohobo> holy moly
10:43:37 <reactormonk> Can I execute template haskell from an IsString instance?
10:44:21 <dmwit> If you could, would it help?
10:44:30 <dmwit> (I think the answer to my question is "no".)
10:44:55 <kadoban> You can use template haskell to define an IsString instance I guess? I have a feeling that's not what you're asking though.
10:45:14 <reactormonk> dmwit, I want to convert static string to URIRef via IsString and error out if you can't. Preferably error out at compiletime.
10:45:37 <dmwit> You are wrong. You want to convert and error out, but you don't want to do it via IsString.
10:45:43 <kadoban> This sounds a lot like a job for a quasiquoter, and skip the IsString
10:46:30 <dmwit> Well. I mean, you can want whatever you want, of course. But if you continue to want that, you're going to be disappointed. So I recommend wanting something else. =)
10:47:04 <reactormonk> dmwit, I'm not set on my tools, just on the goal.
10:47:14 <reactormonk> So http://quasimal.com/posts/2012-05-25-quasitext-and-quasiquoting.html it is?
10:47:58 <dmwit> Yep, that looks like it could be a decent tutorial.
10:48:19 <reactormonk> Got another one at hand?
10:48:29 <orion> What is the most state-of-the-art production-ready command line parser available today?
10:48:40 <dmwit> The only time I messed with QQs I just read the docs.
10:49:00 <dmwit> So... no, I don't have a good resource to recommend. =P
10:50:44 <dmwit> orion: You ask an impossible question, I think: state-of-the-art is the newest and greatest stuff, whereas I think of production-ready as being hardened and battle-tested. Hard to do both at the same time. For production-ready, you can't get more stable and familiar to users than getopt. For state-of-the-art, I think I'd probably recommend optparse-applicative.
10:56:15 <orion> dmwit: I see the nature of the contradiction. Thank you.
10:56:45 <maerwald> I still parse manually often :P
10:57:10 <maerwald> it's so easy in haskell, why should I bother to learn the oddities of another library
10:58:53 <dmwit> maerwald: Because dealing with all of `-v 3`, `-v=3`, `-v3`, and `-vvv` manually is annoying.
10:58:58 <hexagoxel> i found optparse-applicative annoying and wrote me an optparse-evil-monadic.
10:59:05 <maerwald> dmwit: just don't give those options
10:59:30 <reactormonk> hexagoxel, unlawful monads?
11:00:22 <maerwald> dmwit: coming up with useless complexity often results in overcomplicated libraries ;)
11:00:44 <maerwald> same for config files
11:01:04 <maerwald> don't make them turing complete :P
11:01:18 <hexagoxel> reactormonk: probably more than unlawful, it will just error if you don't follow a certain pattern.
11:01:31 <reactormonk> hexagoxel, at least compiletime error?
11:01:39 <hexagoxel> still useful until ApplicativeDo works nicely :/
11:01:43 <hexagoxel> nope
11:01:49 <reactormonk> ...
11:01:54 <reactormonk> hexagoxel, doesn't work nicely yet?
11:02:21 <EvanR__> do monkeys fly out of your nose if you dont follow a certain pattern?
11:02:56 <hexagoxel> last i checked things like "return $ .." did not work with ApplicativeDo.
11:03:42 <max3> is it possible to get stack to tell you the list of packages already installed?
11:03:56 <reactormonk> Bug report out yet? :-P
11:03:57 <hexagoxel> and the errors that you get when you mess up at some point (when some part makes it monadic instead of applicative) are not very helpful.
11:04:28 <reactormonk> no app-do yet? ^^
11:04:32 <hexagoxel> these issues are well known.
11:04:57 <hexagoxel> yeah, i also recently wondered why there is not just a separate keyword.
11:06:10 <reactormonk> Possibly because it's really hard to introduce a keyword after the fact.
11:06:39 <hexagoxel> (and that my version has no compile-time check is not too bad in practice; it is possible to call a check that covers every possible path in the construct.)
11:07:13 <hexagoxel> so it is run-time only, but fail-fast.
11:08:15 <hexagoxel> yeah, keywords are always a problem. it is also the only thing that i dislike about the or-pattern proposal - '|' getting yet another meaning.
11:08:58 <hexagoxel> as if "foo | bar <- baz -> grml" was not confusing enough already :p
11:09:00 <sm> orion: that seems to be cmdargs or optparse-applicative. For a long time cmdargs was better documented, but o-a is the community favourite
11:13:31 <EvanR__> If you want to see something which overloads '|' (a straight stroke shape) to all hell, look at Frege's Begriffsschrift
11:14:52 <EvanR__> conclusion, syntax designed for humans (not compiler writers) is more than an assignment of meaning to each ascii character. We can only get anywhere with a complex combination of context... isnt everything (all syntax) some conglomeration of strokes
11:15:38 <monochrom> EvanR__: What does the letter "c" mean in "conclusion"?  <duck> 
11:16:08 <monochrom> Also...
11:16:13 <monochrom> @quote monochrom font
11:16:14 <lambdabot> monochrom says: <monochrom> great way to answer a semantics question by commenting on the font  <monochrom> "what is the semantics of IO?" "the I may be narrower than O in some fonts, and same width
11:16:14 <lambdabot> in some other fonts"  <monochrom> "on very old typewriters, it also denotes the number 10 (ten), for those of you looking for a denotation" XD
11:18:15 <pikajude> some real denotational sem-antics here in #haskell 
11:21:15 <tfc_> hey there. i am launching a process with let p = (shell "cmd ...") { std_in = CreatePipe, std_out = CreatePipe, std_err = Inherit }
11:21:30 <tfc_> and then (Just hin, Just hout, _, ph) <- createProcess p
11:21:55 <tfc_> what my process does, is listening on stdin. if it reads 0 from read(stdin,...) (EOF) it terminates.
11:22:04 <eacameron> Ug. Has anyone hit this before? I was using writeText to write to a file and ended up using "show" on the file name so it had double-quotes in it. Under normal usage writeFile would give me an exception. But in my app it was running in a async thread and it wouldn't throw, just hang.
11:22:06 <tfc_> however my problem is that the app terminates immediately
11:22:23 <tfc_> no chance to use my stdin pipe in order to write to it. can anyone tell me what i am doing wrong?
11:24:33 <EvanR__> begriffsschrift notation: http://i.imgur.com/hpxYTgn.jpg
11:25:31 <max3> i don't understand why i'm getting this error: http://pastebin.com/gEJqWUy8
11:25:48 <max3> happy is installed on line 155 and yet on compilation it's not present
11:26:36 <tsahyt> @hoogle CFloat -> Float
11:26:39 <lambdabot> Foreign.C.Types CFloat :: Float -> CFloat
11:26:39 <lambdabot> Language.C.Syntax.Constants cFloat :: Float -> CFloat
11:26:39 <lambdabot> Language.C.Syntax.Constants CFloat :: String -> CFloat
11:26:47 <tsahyt> oh, it's just a wrapper then?
11:27:26 <monochrom> I don't think "just" does justice to it.
11:27:52 <EvanR__> CFloat corresponds to C's float type
11:28:04 <monochrom> CFloat is guaranteed to be equivalent to C's float. Float is not. Be sure to use CFloat when doing FFI.
11:28:05 <ph88> what is called implode in php is called intercalate in haskell o_O
11:28:26 <reactormonk> I've also seen intersperse
11:28:42 <ph88> intercalate xs xss is equivalent to (concat (intersperse xs xss))
11:29:06 <reactormonk> right. hmm.
11:29:10 <monochrom> It is true that a particular compiler like GHC implements CFloat as a newtype over Float. But this is a compiler's own choice.
11:29:35 <EvanR__> so implode doesnt correspond to either intersperse or intercalate
11:29:39 <geekosaur> ph88, actually it's weirder than that, php's implode is named after lisp's implode which is (*very* roughly) haskell's concat, but adds the ability to intersperse
11:30:06 <reactormonk> geekosaur, php is just wierd. Let's leave it at that.
11:30:09 <geekosaur> which is ... typical php, attach random functionality to random places
11:30:17 <srhb> Please, we need a php -> Haskell cheatsheet
11:30:22 <geekosaur> because it was convenient for someone at the time
11:30:22 <ph88> implode(', ', ["a", "b"]) == "a, b"
11:30:35 <reactormonk> srhb, sad => happy ?
11:30:53 <srhb> reactormonk: I just think it would be awesome fun. :-P
11:31:06 <ph88> never dived into lisp, choose haskell instead :P
11:31:15 <monochrom> Sometimes I wish programmers took a few linguistic classes. Because that's the only way they will understand that there is not going to be 1-1 correspondences between different languages evolving from different cultures.
11:31:18 <reactormonk> srhb, you could probably map about three php functions to one haskell each.
11:31:19 <EvanR__> whats the haskell equivalent of a hierarchy of output buffer jugglers
11:31:20 <ph88> srhb, i already started :D
11:31:26 <geekosaur> max3, actually it's looking for the executable at that point and ... executable dependencies tend to be "fun". possibly you need to install happy as a separate step
11:31:35 <geekosaur> (using stack)
11:31:37 <EvanR__> or the one where you auto export everything in an array into the local variables
11:31:40 <srhb> ph88: yay
11:31:45 <max3> geekosaur, i think it's this https://www.haskell.org/cabal/FAQ.html#runghc-setup-complains-of-missing-packages
11:31:57 <EvanR__> or access a variable whose name is in a variable ($$)
11:32:17 <srhb> EvanR__: Time to get creative!
11:32:19 <geekosaur> max3, not if you're using stack it isn't
11:32:29 <max3> geekosaur, i am using stack
11:32:37 <geekosaur> yes, so that page is not related
11:33:46 <max3> geekosaur, i believe you can you explain a little more about what's happening?
11:33:48 <max3> *but can you
11:34:13 <geekosaur> probably not because I am not an expert on stack
11:34:40 <max3> geekosaur, how about what "executable dependency" means exactly
11:34:51 <geekosaur> it wants a program, not a library
11:34:55 <EvanR__> theres a channel dedicated to stack
11:35:01 <geekosaur> it finds programs via $PATH, like any other program does
11:35:06 <geekosaur> (or %PATH% on Windows)
11:35:17 <max3> geekosaur, how can you tell it's looking for an executable dependency?
11:35:38 <geekosaur> but this means executable searches work differently from library searches, and you can get into trouble if it has to install the executable in the same run as it needs to use it
11:36:06 <geekosaur> max3, in this case it is because "happy" is a program that generates code for lexical analysis
11:36:36 <max3> geekosaur, is it not a library as well?
11:36:48 <geekosaur> it is, but it hasn't gotten that far yet
11:37:17 <geekosaur> (also it doesn't always need the library iirc)
11:37:38 <geekosaur> some configurations it can generate all the code itself, some it ends up generating references into the library
11:37:39 <monochrom> There was a post on haskell-cafe reporting that Network.Download works for 10 times and then fails afterwards. I almost wanted to reply "sounds like shareware". :)
11:37:40 <marekw2143> http://lpaste.net/352233 - could someone tell my why I get : maybeList.hs:9:9: parse error on input ‚Äòcase‚Äô  ?
11:38:15 <EvanR__> need a crack for Network.Download
11:38:24 <geekosaur> marekw2143, indentation matters
11:38:33 <monochrom> Yeah, very misaligned
11:38:51 <monochrom> put "case" under "maybeValue"
11:39:03 <geekosaur> since you combined the `do` and the first line of the do block on the same line, the second line MUST start directly under the `maybeValue <-`
11:39:23 <bwe> Curiosity question: What's the state of concurrency/multi-core/parallelism with Haskell? Referring to http://homolog.us/blogs/blog/2012/09/26/bye-bye-python-enter-haskell/#isso-820 (I don't claim that this had ever to be true, but you get the point)
11:39:31 <geekosaur> you only get to change the indentation the way you did if you also did that with the `maybeValue <-`
11:39:36 <marekw2143> geekosaur, ok
11:39:49 <marekw2143> now I have other errors ;)
11:39:56 <marekw2143> but will try to fix them 
11:40:00 <marekw2143> thanks
11:40:03 <geekosaur> @where concurrency
11:40:03 <lambdabot> I know nothing about concurrency.
11:40:06 <geekosaur> meh
11:40:51 <geekosaur> bwe, http://chimera.labs.oreilly.com/books/1230000000929
11:41:06 <geekosaur> (currently readable online for free)
11:41:35 <monochrom>  @where is not a key-value store. It is a password-message store.
11:42:31 <geekosaur> the par/pseq/force thing is likely to be "but I can't randomly sprinkle nonsense and have it work" which is (a) a usere problem (b) a symptom of the fact that concurrency is hard no matter what language you use
11:42:42 <bwe> geekosaur: Thanks. However, may I admit, I was interested in your personal experience (if present) with concurrency (in relation to other [imperative] languages).
11:43:06 <geekosaur> but with just that comment it is hard to tell
11:43:23 <geekosaur> I don't do much concurrent programming in any language, tbh
11:43:37 <geekosaur> except on the level of processes (as opposed to threads)
11:44:12 <geekosaur> the async library does handle a bunch of common cases these days
11:44:23 <EvanR> bwe: concurrent programming in haskell is awesome
11:44:31 <EvanR> dunno about parallel programming
11:44:55 <bwe> geekosaur: Which I sincerely value and is completely okay anyways. Thanks for your honest statement (which is not natural in our times).
11:45:08 <geekosaur> (par and pseq are a very low level interface)
11:45:22 <EvanR> i havent gotten into a situation where i needed more performance and thought parallel had a chance of giving it to me
11:45:26 <bwe> EvanR: Is there any irony absent in your statement :) ?
11:45:43 <EvanR> theres a distinction to be made
11:45:58 <EvanR> it would be more useful for concurrent to not be synonymous with parallel
11:47:01 <EvanR> i found concurrency abstractions answer a lot of questions about how youre supposed to "do IO"
11:47:53 <monochrom> It is useful to have two words. I am not convinced that "concurrency" is a good word for one of the two. "At the same time" and "parallel" are almost synonyms.
11:48:43 <monochrom> Hoare's "communicating sequential processes" was a good word. But it's too long. But it gets across the real point --- communication.
11:50:12 <monochrom> When multi-threading is hard, it is hard because of communication (aka synchronization primitives). This is exactly what Haskellers mean when they say "when I say 'concurrency' I don't necessarily mean parallelism, what I mean is MVar and STM". See? Communication and/or synchonization.
11:50:53 <sternmull> what is a good project to see how modern real haskell applications are coded? It is easy to find the popular haskell packages, but i am a bit lost when searching for applications.
11:51:12 <EvanR> application as in desktop app?
11:51:19 <EvanR> command line program
11:51:26 <EvanR> server
11:51:43 <sternmull> not necessarily desktop apps, commandline/server stuff is fine
11:52:00 <sternmull> specifically i do not care about GUI stuff at the moment
11:52:11 <EvanR> well heres one https://github.com/joeyh/git-annex
11:52:31 <ph88> EvanR, aren't some things automatically parallel when concurrent ?
11:52:43 <EvanR> like what
11:53:20 <ph88> well doesn't ghc spawn some hw threads ?
11:53:27 <sternmull> thanks. I read about git-annex being made with haskell but totally for got about it...
11:53:58 <EvanR> ghc gives you "capabilities", only one capability can run on a cpu at a time, and only one thread can run on a capability at a time
11:55:02 <ph88> sounds good to mr
11:55:04 <ph88> me
11:55:14 <sm> sternmull: pandoc
11:55:21 <EvanR> in my mind concurrent processes cant tell if they are running in parallel or not, so it shouldnt factor into an analysis
11:55:38 <geekosaur> not sure any of those does anything with either parallelism or concurrency tbh
11:55:44 <sternmull> sm: Thanks.
11:55:53 <ph88> EvanR, what analysis ?
11:56:06 <EvanR> of how concurrent processes will behave
11:56:13 <EvanR> or might behave
11:56:37 <mangobot> hi everyone! i wwas wondering if someone could give me a tip on how to parse a string correctly. here's what i came up with so far: http://lpaste.net/352234 the idea is to parse a string like ",b,b,/bb,b,b/b,,wwb,b/,,/w,,bww,bw/,w,/w,w,w,w w c3-e5", where ,b,b,/bb,b,b/b,,wwb,b/,,/w,,bww,bw/,w,/w,w,w,w = gamestate, w is the next player and c3-e5 is last move
11:56:40 <EvanR> "it might as well be sequential"
11:56:49 <ph88> oh i was thinking more along the lines of them being independent of each other
11:56:52 <monochrom> Take it to the extreme. A program can't tell whether it's running or not. So?
11:57:02 <EvanR> are they independent?
11:57:09 <mangobot> how can i seperate this string into this 3 different types?
11:57:16 <mangobot> these*
11:58:19 <ph88> mangobot, is each character a command on it's own ?
11:58:35 <monochrom> I'm going to gripe on haskell-cafe. It's time someone raised an objection. (Yeah yeah, that ship has sailed etc, I know.)
11:58:44 <ph88> EvanR, i think some problems can be split up and be independent on many cores
11:59:03 <EvanR> thats more of a parallel programming strategy
11:59:23 <ph88> yeah
11:59:25 <mangobot> ph88 what do you mean by each character being a command on its own? each character in the string represent the currnt position of a player on the board. so the part until the first space before "w" is the board state and then w stands for the next player and c3-e5 is the last move
11:59:43 <mangobot> i need to parse the string in order to calculate next possible moves
12:00:17 <ph88> oh didn't even notice that space
12:00:18 <EvanR> if you think like that, you definitely need to know about cores and about simultaneity, to reason about performance, which is the entire point there, and so its a lower level thing
12:00:47 <mangobot> ph88 so "," stands for next square on the field "/" new line and w and b for white and black players
12:01:06 <ph88> mangobot, looks you were doing a good job with splitOn .. what tip do you need ?
12:01:13 <EvanR> if you think like javascript, which has all kinds of things happening asynchronously, you dont need to introduce the complexity of multiple cores and simultaneity
12:01:52 <EvanR> some people think they want to think about that in that situation, but they really dont
12:02:07 <ph88> i just think it's cool to utilize all cores :P
12:02:10 <EvanR> you dont need a core dedicated to waiting for http to come back
12:02:13 <mangobot> ph88 i dont quite get the way it would work if i use the splitOn and how to i assign the correct data types? if i want to seperate the string into 3 parts, first = gamestate, second = next player, third = last move
12:02:26 <EvanR> or waiting for mouse clicks
12:02:43 <ph88> mangobot, you can make a list of type  [String] and the use the first item, second item and third item in that list
12:03:13 <ph88> mangobot, or you can make a dedicated type of 3 things like   data MangoBotsType = DataConstructorForMangoBot String String String
12:03:27 <EvanR> ph88: its cool to get a complex async situation to actually work correctly
12:03:41 <EvanR> and possibly have an argument for how thats true
12:04:05 <ph88> EvanR, i'm not sure if i even did async programming :(
12:04:28 <EvanR> its all the rage
12:04:41 <ph88> yes i know because i read a lot about it
12:04:55 <ph88> especially interested in tokio even though i don't program rust .. but it looks cool
12:05:01 <mangobot> ph88 so the command parse s = parseInput (splitOn " " s) splits the string into 3 parts already? and then in the parseInput i need to assign those 3 parts?
12:05:29 <mangobot> ph88 that would be parseInput :: [String] -> [String] then and then in next line assign each part?
12:06:26 <ph88> mangobot, splitOn splits the parts in as many as is needed to find all the spaces .. so you can have less or more than 3
12:07:46 <ph88> mangobot, i'm not sure what you want to get out of parseInput .. but i doubt it's either String or [String]  .. because likely you want more structured data and use types instead of lists
12:09:41 <ph88> mangobot, here is a small example how you can use guards to check if you have indeed 3 parts https://paste.fedoraproject.org/551255/58454114/
12:10:31 <mangobot> ph88 http://lpaste.net/352235 i receive a string of a form like ",b,b,/bb,b,b/b,,wwb,b/,,/w,,bww,bw/,w,/w,w,w,w w c3-e5" which i want to parse into 3 different data types, first is gamestate (still need to create the structure) , 2 would be the player and 3 is the move which i then want to parse into coordinates ont he field
12:10:43 <mangobot> ph88 ok thanks ill check it out now
12:10:52 <ph88> ok i'll look at your code, just a moment
12:14:18 <mangobot> ph88 thank you! thats really nice. just to make it clear, im working on this game, so there is an exmaple of the string of the starting state: http://pjb.com.au/laska/play_laska.html
12:14:48 <mangobot> ph88 although i also save the last move
12:14:54 <ph88> ok
12:15:23 <reactormonk> With quasiquotes, is there a way to project a data object from TH into a literal in the compiled haskell?
12:17:04 <reactormonk> I'm creating my URIRef data with QuasiQuotes, how do I project it back to runtime?
12:18:20 <ph88> mangobot, just filling in some gaps .. https://paste.fedoraproject.org/551257/48658506/
12:18:37 <ph88> mangobot, there wasn't a type for gamestate and such so i didn't know what to do
12:19:21 <mangobot> ph88 ah yeah i need to create it, didnt do it initially. ill check you code now, thanks a lot though! super helpful
12:19:33 <ph88> mangobot, you might want to consider a parsing library .. then you don't have to put Maybe's everywhere .. or let your code error on runtime when the string is not valid
12:20:15 <ph88> mangobot, line 7 in my code has an error this should be the data constructor PR
12:21:12 <mangobot> ph88 i see, thank you! i get it now. but what could go wrong exactly when parsing the string? like if a string has a different format and so on? 
12:21:21 <ph88> mangobot, it's up to you to decide where you want to put Maybe's in your type .. does it have meaning to have a valid GameState but not a valid Player ?
12:21:38 <ph88> mangobot, if the string contains characters or missing characters which you don't expect
12:22:12 <ph88> mangobot, in case you are always sure it's correct then you can let your code crash on runtime .. but this is not nice of course ^^
12:22:36 <ph88> i mean it won't crash if the input is always valid .. but it's better to build your code in such a way that it handles exception situations too
12:23:38 <mangobot> ph88 hehe yeah it will always be correct, i did the main game interface in java and the haskell part is for a bot. its a server game so two real players can play against each other or one can play with bots which are being created in haskell :))  the strings will also be always valid as its all already checked in java 
12:23:58 <mangobot> ph88 so the bot will always recieve valid strings
12:25:06 <ph88> ok
12:25:27 <ph88> mangobot, then leave out the Maybe's i guess ..
12:25:39 <mangobot> ph88 yeah i will. thanks for the example though, very helpful!
12:25:47 <ph88> mangobot, then you don't need the guard anymore as well since you know splitOn will always yield 3 parts
12:26:13 <mangobot> ph88 ok, yes, i thought to leave it out
12:28:27 <ph88> mangobot, not that it will be less lines of code .. but just to show what you can do  https://paste.fedoraproject.org/551260/14865856/
12:28:54 <ph88> the first code is probably faster
12:29:25 <JeKs> hi guys :)
12:31:28 <mangobot> ph88 why is the first faster? so in the hoogle it says "Convert a letter to the corresponding lower-case letter, if any. Any other character is returned unchanged. " ie so it will parse the string and assignt w to white and b to black, but W and B will just be returned?
12:32:47 <mangobot> ph88 can i ask you something else, so in the line ParseResult (parseGameState parts !! 0) (parsePlayer parts !! 1) (parseMove parts !! 2) it assignes part 0 to the string in the function parseGameState, part 1 to the str in the function parseMove etc?
12:33:32 <ph88> mangobot, W and B will be converted to w and b    and then both w and W  will yield White
12:33:48 <mangobot> ph88 ah i see
12:33:51 <tlahtoani> I understand nothing about Haskell but it is great 
12:34:08 <ph88> mangobot, and then your cpu needs to do some arithmetic on those characters where if you do literally W and w  it's only a lookup .. but this is micro optimization so not important
12:35:08 <ph88> mangobot, yes that's right (about the line ParseResult ..)
12:36:49 <ph88> mangobot, i think in haskell terms you say "function parseMove is applied to the string (parts !! 2)" instead of "(parts !! 2) is assigned to parseMove" .. but whatever you know what it does anyway
12:36:53 <JeKs> Quick question. can anyone of you tell me what IDE/compiler is good for haskell and what book (or ofc preferred free online tutorials) i should follow to learn haskell?
12:37:19 <ph88> JeKs, take GHC as compiler
12:37:30 <mangobot> ph88 ah thanks :) i just started learning it today, so still quite unsure about the terms etc :) 
12:37:47 <ph88> JeKs, for editor there are integrated environments with emacs and vim, but other editors also have plugins for haskell such as sublime text
12:37:47 <travv0> JeKs: I used Learn You a Haskell and liked it
12:38:30 <ph88> JeKs, the go-to tutorial is learnyouahaskell .. but i would only read little bits and browse around a bit because it may not match your preference. There is also real world haskell and other books some free and some paid
12:39:28 <mangobot> ph88 can i ask you one more question about the correct syntax in the lines 4-8 for the function without maybes https://paste.fedoraproject.org/551257/48658506/ so it would be sometihng like http://lpaste.net/352236 ?
12:39:40 <ph88> JeKs, http://www.cs.nott.ac.uk/~pszgmh/pih.html
12:39:57 <mangobot> ph88 () arond the splitOn
12:40:01 <travv0> ph88: If I've read lyah in its entirety, would it make sense to learn RWH or does it cover the same topics?
12:40:13 <travv0> I'm trying to figure out what the next logical step would be
12:40:20 <Tuplanolla> They're quite different, travv0.
12:40:33 <travv0> Thanks, I'll check it out then
12:40:38 <ph88> travv0, i suggest you look at the index at what it covers, but like Tuplanolla said i found them to be quite different indeed
12:40:47 <reactormonk> How do I throw an error, the non-capturing kind?
12:40:57 <ph88> reactormonk,   error "blabla"    i guess
12:41:01 <reactormonk> Thanks
12:41:28 <Tuplanolla> The PCPH book complements RWH nicely as well, travv0.
12:41:29 <ph88> mangobot, yes that looks good but replace the type ParseResult with the data constructor PR
12:41:48 <mangobot> ph88 ok thank youuu soo much! 
12:42:09 <ph88> Tuplanolla, what's PCPH ?
12:42:12 <Tuplanolla> @google Parallel and Concurrent Programming in Haskell
12:42:14 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
12:42:14 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
12:42:22 <ph88> oh that one ^^
12:42:29 <travv0> Tuplanolla: thanks, I'll add that to the list as well
12:42:30 <ph88> i would take that as a more advanced course
12:43:09 <mangobot> ph88 is it bad to call it ParseResult = ParseResult GameState ... , instead of =  PR Gamestate? in all of he example i saw today they would keep the same name of the data type, i didnt really looked into it yet so just copied the form
12:43:16 <ertes> PCPH‚Ä¶  also called The Book
12:44:02 <Tuplanolla> I thought Homotopy Type Theory was The Book.
12:44:05 <ph88> travv0, one thing with learn you a haskell i found personally is that it doesn't explain why typeclasses are usefull (in my opinion at least). Also there is tons of stuff not explained .. there is also this blog 24 days of ghc extensions which is really really useful. Not that you have to remember all the stuff in there but it gives you a great overview of the extensions. You should program haskell with ghc extensions on
12:44:24 <ertes> Tuplanolla: well, every genre has a The Book =)
12:44:31 <tlahtoani> Why extensions on?
12:44:57 <ph88> mangobot, it's only as bad as you will get confused between Type Constructor and Data Constructor. You can prefix the data constructor with "Mk" possibly
12:45:13 <mangobot> ph88 ok i see, thanks
12:45:18 <travv0> ph88: all noted, thanks for the tips
12:45:32 <ertes> tlahtoani: i think ph88 meant to say that you shouldn't shy away from extensions‚Ä¶  everybody uses them
12:45:34 <ph88> tlahtoani, because there are a lot of great extensions you don't really want to do without. Like OverloadStrings if you want to work with Text instead of linked list of characters 
12:46:00 <ph88> ertes, yes that's exactly what i meant :P
12:46:00 <tlahtoani> In C compiler extensions are usually bad, I assume this is not the case in Haskell 
12:46:17 <ertes> tlahtoani: standard haskell is usable, but extensions ramp up its expressivity massively
12:46:29 <ph88> it feels utterly weird to start a new language and then already having to enable some non-standard compiler option (the extension) .. but this is just the case
12:46:30 <Tuplanolla> Would there be life without `NumDecimals`?
12:46:32 <ertes> tlahtoani: it's a cultural difference
12:46:51 <ertes> would there be life without RankNTypes?
12:46:58 <EvanR> ph88: technically non standard
12:47:14 <EvanR> but what they dont know is ghc is the defacto standard
12:47:22 <ph88> tlahtoani, newer versions of GHC will include some extensions by default i'm sure .. it's also a more kind of preference way of programming rather than a non-standard way (although SOME extensions are quite exotic)
12:47:38 <tlahtoani> Like?
12:47:39 <AWizzArd> In ghci, when I have an expression E I can use :t to see the type of E. Is there a way to ask for the type of a subexpression within E?
12:47:40 <EvanR> some extensions are kind of necessary
12:47:59 <reactormonk> How can i derive Data for a higher-kinded type, e.g. https://hackage.haskell.org/package/uri-bytestring-0.2.2.1/docs/URI-ByteString.html#t:URIRef
12:48:09 <EvanR> FlexibleInstances FlexibleContexts OverloadedStrings GADTs RankNTypes
12:48:15 <ertes> AWizzArd: give that subexpression a partial type signature: (SubExp :: _)
12:48:28 <EvanR> ScopedTypeVariables
12:48:32 <ph88> tlahtoani, exotic to me would be DataKinds .. i saw it mentioned but never used it .. other people might say it's not that exotic and can probably give you an example of an even more obscure one
12:49:03 <EvanR> exotic, UndecidableInstances
12:49:19 <ph88> that one i actually do use xD
12:49:25 <EvanR> considered harmful, IncoherentInstances
12:50:06 <Tuplanolla> Don't forget all the little guys like `NegativeLiterals` or `BinaryLiterals`.
12:50:15 <ertes> AWizzArd: or even just an obviously wrong type signature‚Ä¶  then GHC will tell you how terrible you are for lying about its type
12:50:30 <ertes> :t replicate (4 :: ()) 'a'
12:50:31 <lambdabot> error:
12:50:32 <lambdabot>     ‚Ä¢ Couldn't match expected type ‚ÄòInt‚Äô with actual type ‚Äò()‚Äô
12:50:32 <lambdabot>     ‚Ä¢ In the first argument of ‚Äòreplicate‚Äô, namely ‚Äò(4 :: ())‚Äô
12:50:34 <EvanR> i want negative literals in idris
12:50:45 <max3> geekosaur, http://pastebin.com/y5WD8fab
12:50:46 <AWizzArd> ertes: Okay great, will try that.
12:50:47 <CuriousErnestBro> why does the compiler give a warning with a tab character?
12:50:51 <reactormonk> http://lpaste.net/352242
12:51:14 <geekosaur> because different programs treat tabs as having different widths
12:51:23 <ertes> AWizzArd: alternatively turn the subexpression into a hole, then GHC will give you a lot more information, including variables and their types that are in scope for the subexpression
12:51:27 <geekosaur> and this is deadly in an indentation sensitive language
12:51:37 <ertes> :t replicate _ 'a'
12:51:39 <lambdabot> error:
12:51:39 <lambdabot>     ‚Ä¢ Found hole: _ :: Int
12:51:39 <lambdabot>     ‚Ä¢ In the first argument of ‚Äòreplicate‚Äô, namely ‚Äò_‚Äô
12:51:40 <ph88> reactormonk, did you derive Data for Absolute  separately ?
12:51:48 <reactormonk> ph88, as you see
12:51:57 <reactormonk> What's the proper way?
12:52:18 <ph88> reactormonk, i don't see because  where is   "data Absolute = "   ?
12:52:24 <ondraa> Hello. I have a FilePath, set OverloadedStrings and I want to use function which takes Path (http://hackage.haskell.org/package/libmpd-0.9.0.6/docs/Network-MPD.html#t:Path), which is an instance of IsString. But it does not typecheck. Can it be because MPD does not export the IsString instance?
12:52:28 <reactormonk> data Absolute deriving(Typeable)
12:52:33 <reactormonk> ph88, sorry, it's a bit further down.
12:52:34 <geekosaur> max3, you'd want to use `stack exec happy` for the check, and in general I think you need someone who knows stack internals
12:52:48 <CuriousErnestBro> geekosaur, so I should make my text editor turn those tabs into spaces?
12:52:51 <ph88> reactormonk, try  data Absolute deriving (Data)
12:52:55 <max3> geekosaur, that's successful as well
12:53:01 <geekosaur> (note that stack will not use a happy from your normal PATH by default because stack does not control that)
12:53:03 <max3> geekosaur, okay i'll go to #stack
12:53:18 <max3> geekosaur, happy is in both paths
12:53:43 <geekosaur> I mean stack will not use a happy from outside of its own storage
12:53:44 <reactormonk> ph88, can't make an instance, needs at least one constructor :-(
12:53:56 <geekosaur> which the stack exec won;t show. "stack paths" might
12:54:01 <AWizzArd> ertes: how can one turn subexpressions into a hole?
12:54:07 <reactormonk> Ah, standalone
12:54:08 <ph88> reactormonk, ok i guess that is already an indication of some underlying problem ..
12:54:17 <geekosaur> CuriousErnestBro, that's the usual solution, yes. (also the one used with python which has the same issue)
12:54:24 <ph88> reactormonk, did you enable this extensions to have types without data constructor ?
12:54:39 <reactormonk> ph88, nope, works this way now. Back to the initial problem.
12:54:57 <ph88> so you add  deriving Data to Absolute ?
12:55:03 <reactormonk> Yeah
12:56:22 <reactormonk> brb
12:56:31 <ph88> reactormonk, maybe try    instance Data a => Data (URIRef a)
12:56:43 <ph88> not that i know about this stuff, just a guess :D
12:58:21 <ph88> anyone know a good place to get this book ?  http://www.cs.nott.ac.uk/~pszgmh/pih.html
12:58:50 <ertes> AWizzArd: you have to replace them by an identifier that starts with _
12:59:14 <ertes> AWizzArd: not terribly convenient, but usually your kill buffer is good enough =)
13:00:22 <AWizzArd> good
13:02:44 <geekosaur> hm, can you also turn on type wildcards and wrap the subexpression in ( ... :: _) ?
13:03:53 <ertes> geekosaur: yeah, that was my earlier suggestion
13:04:14 <ertes> typed holes are a bit more useful though, because they show the scope as well
13:08:03 <ph88> travv0, tlahtoani look what i just found  https://www.futurelearn.com/courses/functional-programming-haskell  free online course .. and there are also other courses online for free
13:09:19 <travv0> ph88: registered interest, thanks
13:13:02 <max3> this is newb question: what is the debugging workflow? i come from imperative land and i'm having trouble since i can't stick print statement in random places
13:13:12 <max3> let alone breakpoints
13:13:12 <tlahtoani> I don't do courses 
13:13:18 <tlahtoani> I just like print books 
13:13:26 <ph88> max3, you can put  Debug.Trace.trace  statements in random places
13:13:56 <ph88> max3, you put breakpoints in ghci  with  :break
13:14:34 <Tuplanolla> You'll also find that around here people prefer to split things into simple testable functions instead of debugging, max3.
13:14:46 <max3> Tuplanolla, yes that's what i was thinking
13:15:06 <ph88> i debug first and split when debugging gets too hard :P
13:16:22 <max3> is it crazy to ever except the same sort of debugging experience i have with pycharm?
13:16:46 <max3> or chrome dev tools?
13:16:56 <max3> where you can set a breakpoint and fiddle with everything in scope?
13:17:29 <ph88> i would have the same expectations ^^
13:17:36 <Sonolin> that would be nice to have a GUI interface to breakpoints, but I'm not aware of anything available for Haskell
13:17:37 <bwe> Yes, to ask for benchmarks might not be the wisest question. However, I want to get a rough idea how Haskell levels against Go.
13:17:38 <ph88> maybe emacs has some ghci intergration which can do it
13:17:54 <Sonolin> yea that'd be where I check first ^^
13:18:01 <ph88> bwe, i think pretty much the same
13:18:34 <ph88> travv0, tlahtoani max3 https://commercialhaskell.github.io/intero/
13:18:42 <Sonolin> unrelated, but I found profiling with GHC a breeze (and made a huge diff in performance for my use case)
13:18:50 <max3> i'm allergic to emacs
13:18:59 <ph88> :D
13:19:03 <max3> is there an intero for vim :)
13:19:20 <ph88> max3, special for you http://www.stephendiehl.com/posts/vim_2016.html
13:19:27 <bwe> ph88: So Haskell really performs as fast as Go which is similar to C?
13:19:39 <benzrf> go is similar to C? isnt it garbage collected?
13:19:46 <ph88> bwe, yeah
13:19:56 <benzrf> oh... i guess that only adds delays, not necessarily slows down everything in the language
13:20:01 <max3> ph88, thanks
13:20:17 <bwe> ph88: Are you writing from experience or by referring to third parties experiences?
13:20:19 <benzrf> er, intermittent delays, separate from the cost of just executing stuff
13:20:21 <ph88> benzrf, it's similar yes when you compare it with perl or so that is 500x slower  lol
13:20:48 <ph88> bwe, experiences i've read and also benchmarks i saw
13:20:51 <benzrf> bwe: haskell performance is variable - it dpeends on the code you write
13:21:09 <ph88> bwe, there are stories that some programs beat C programs in performance
13:21:17 <Sonolin> yea, I've found well written haskell code to be *very* fast
13:21:20 <bwe> benzrf: Which sounds realistic.
13:21:52 <benzrf> bwe: haskell is static enough that you can do crazy good optimization, but it's high-level enough that plenty of easy code has semantics that don't really correspond to a fast low-level solution
13:21:54 <benzrf> kinda
13:21:58 <ph88> bwe, but with haskell you can optimize the shit out of it ... i mean the compiler is already really good but then you can really tweak it low level as well and also use many cores
13:22:23 <chpatrick> bwe: it's possible but not by default
13:22:41 <benzrf> bwe: so some subset of haskell code can be reliably translated into c-tier performance, but plenty can't
13:22:54 <ertes> is there a variant of MutVar# for unlifted types?
13:23:00 <ertes> like:  MutVar# RealWorld Int#
13:23:01 <benzrf> if you really need high perf, you have to know what you're doing, and a little bit about the low-level stuff
13:23:33 <benzrf> i'd say it's pretty fast in general, though - just maybe not c level
13:23:50 <ph88> bwe, if you do a webserver you can also have a lot of connections just like Go
13:24:09 <chpatrick> bwe: although it's pretty easy to write C++ inline if you really need to
13:24:10 <bwe> benzrf: What do you mean by a 'fast low-level solution`?
13:24:48 <benzrf> chpatrick: lol
13:25:26 <ertes> bwe: it all boils down to predictability‚Ä¶  haskell is not slower than C (it can beat C in some cases, especially when concurrency is involved), but *predicting* the performance/efficiency of haskell code takes experience
13:25:32 <ph88> bwe, i guess he means that if you reach a certain level of abstraction that there are several ways to implement it low-level .. so there is no 1-to-1 relation there
13:25:50 <chpatrick> I'd say "haskell isn't slower than C" is a bit disingenous
13:26:02 <chpatrick> it's possible to make it as fast but it's usually not very idiomatic/readable code
13:26:21 <benzrf> bwe: i mean something fast you might write in C
13:26:29 <tlahtoani> Speed isn't the only thing that matters 
13:26:35 <chpatrick> it is for some things
13:26:53 <tlahtoani> Then you probably wouldn't be using Haskell 
13:27:02 <ertes> chpatrick: i beg to differ‚Ä¶  it's usually the idiomatic haskell code that gets close to C performance, but one needs to realise that e.g. lists aren't idiomatic for everything
13:27:05 <monochrom> You can't discuss speed as a simple boolean "fast vs slow".
13:27:18 <fsestini> hi. can anybody help me understand why a declaration like f = show . read cannot have inferred type (Read a, Show a) => String -> String?
13:27:22 <chpatrick> ertes: well super hand-written basic recursive stuff is very fast
13:27:38 <chpatrick> but for real-world stuff I'd consider list and monad combinators more idiomatic
13:27:40 <chpatrick> but then it won't be fast
13:27:45 * geekosaur wonders at discussions of speed. how many of you actually need absolute speed?
13:27:46 <benzrf> fsestini: it's.... the DREADED MONOMORPHISM RESTRICTION
13:27:48 <benzrf> probably
13:27:49 <bwe> benzrf: Where the question arises C or Go?
13:28:01 <fsestini> benzrf: with that disabled, i should have said
13:28:06 <benzrf> oh, hah
13:28:14 <ertes> chpatrick: something along the lines of (foldr _f _z (unfoldr _g _s0)) is very fast, too and totally idiomatic
13:28:16 <bwe> geekosaur: We all know this to be a purely psychological question.
13:28:19 <benzrf> fsestini: is this top-level or is it bound in a where or let clause
13:28:30 <reactormonk> ph88, works, but warns about missing methods.
13:28:30 <fsestini> benzrf: top level
13:28:37 <bwe> geekosaur: it's like 'who has the shiniest car' issue.
13:28:38 <lyxia> fsestini: the problem is that a is ambiguous, and there is no way to disambiguate it.
13:28:45 <chpatrick> also often the speed depends on getting lucky with the inliner
13:28:50 <chpatrick> which is totally voodoo
13:29:01 <benzrf> lyxia: oh, fuck
13:29:03 <ph88> reactormonk, :D :D :D
13:29:07 <benzrf> i misread it as read . show
13:29:08 <fsestini> lyxia: but why can‚Äôt it just be lest there in the type?
13:29:10 <benzrf> haha
13:29:15 <fsestini> *left
13:29:30 <benzrf> fsestini: if you turn on type applications, you may be able to get away with it
13:29:34 <fsestini> i mean, shouldn‚Äôt be a problem of the caller how to disambiguate it?
13:29:35 <benzrf> although you'll have to allow ambiguous types, i think
13:29:41 <chpatrick> we have a largish computer vision project where the architectural parts are in haskell and the parts that do a lot of number crunching are in C++
13:29:45 <chpatrick> that works pretty well with inline-c
13:29:50 <fsestini> benzrf: i think so
13:29:51 <ertes> chpatrick: that's exactly what i mean by predictability‚Ä¶  you can make haskell code fast without sacrificing its elegance (too much), but it takes a lot of experience
13:29:59 <lyxia> fsestini: yes but why write a function you can't call? (pre-GHC 8)
13:30:24 <ertes> and by fast i don't necessarily mean "as fast as C", just close enough that you don't get PHP levels of performance
13:30:30 <monochrom> fsestini: OK, I am a caller. How do I disambiguate? What exact code should I write? Let's say I want "Int".
13:30:37 <bwe> tlahtoani: So if speed is the question, what should my choice be?
13:30:48 <chpatrick> we're talking about as fast as C though
13:30:58 <chpatrick> which usually takes some dirty tricks
13:31:02 <chpatrick> or you know, cbits
13:31:28 <monochrom> In fact I don't think TypeApplication helps me (the caller) either.
13:31:37 <geekosaur> fsestini, the problem here is that between the read and the show it has to pick some type. what type it picks has an effect on what instances of Read and Show used. this type *is not visible* outside of the definition of f; you cannot control it. you also cannot determine it at runtime based on the string you feed it.
13:31:55 <geekosaur> so no, type applications wouldn't help either
13:31:58 <benzrf> monochrom: what about somethign like
13:32:11 <monochrom> f @ Int?  No, clearly not.
13:32:20 <fsestini> geekosaur: but why not said that the function has type (Read a, Show a) => String -> String
13:32:24 <benzrf> foo :: forall a. (Show a, Read a) => String -> String; foo = show @ a . read @ a
13:32:28 <fsestini> *say
13:32:39 <geekosaur> fsestini, ok fine, let's say this
13:32:52 <benzrf> @let foo :: forall a. (Show a, Read a) => String -> String; foo = show @ a . read @ a
13:32:52 <lambdabot>  Parse failed: Parse error in expression: show@a
13:32:56 <benzrf> :|
13:32:59 <geekosaur> what is the type iof the value passted between read and show?
13:33:10 <geekosaur> remember: what string this accepts is determined by that tyoe
13:33:13 <monochrom> benzrf: Does that work? Have you tried? I'm OK with going GHC 8.
13:33:13 <geekosaur> *type
13:33:38 <geekosaur> there are ways to force this to work and those ways will mean the function accepts exactly one string: "()"
13:33:49 <geekosaur> is this useful to you?
13:34:02 <benzrf> monochrom: it works
13:34:08 <monochrom> Oh that's neat.
13:34:25 <benzrf> @let {-# LANGUAGE TypeApplications #-}
13:34:28 <lambdabot>  Defined.
13:34:33 <benzrf> @let foo :: forall a. (Show a, Read a) => String -> String; foo = show @ a . read @ a
13:34:33 <lambdabot>  Parse failed: Parse error in expression: show@a
13:34:36 <benzrf> :\
13:34:42 <Tuplanolla> @let --
13:34:44 <geekosaur> ghc is failing because it cannot by default assign that inner type. if you use extended defaulting to force it, you get something utterly useless, for essentially the same reason: it cannot do anything useful without that inner type
13:34:45 <lambdabot>  Defined.
13:34:51 <monochrom> yeah I'll have to try on my own computer
13:35:01 <lyxia> http://lpaste.net/352245
13:35:03 <benzrf> monochrom: u also need to turn on scopedtypevariables, of  course
13:35:11 <fsestini> geekosaur: but why does it have to default it?
13:35:21 <fsestini> can‚Äôt a just be left universally quantified?
13:35:23 <geekosaur> fsestini, because that is how it picks *which* read and show
13:35:24 <benzrf> fsestini: it works in ghc 8 when you manually apply stuff and use scoped type variables
13:35:48 <benzrf> bbl
13:35:49 <geekosaur> they are not magic, nor do they accept any type and pick one based on the string (this is not something Haskell does)
13:36:00 <monochrom> I go low-tech and use ExplicitForall :)
13:36:02 <lyxia> I didn't see the problem inside the definition of f earlier.
13:36:32 <geekosaur> they muust have a type *at compile time*, and which one you use determines which `read` and `show` are used (by selecting instances of `Read` and `Show`)
13:36:49 <monochrom> Oh yikes I really need ScopedTypeVariables
13:36:54 <geekosaur> but I suspect you are hanging up on: "dynamic languages will pick one based on the string I give it".
13:37:02 <geekosaur> Haskell is not a dynamically typd language
13:37:18 <geekosaur> > read "5"
13:37:21 <lambdabot>  *Exception: Prelude.read: no parse
13:37:25 <monochrom> I don't think even dynamic languages are that magical.
13:37:34 <fsestini> geekosaur: i‚Äôm not thinking about that
13:37:43 <artstart> hi. haskell noob here. is there a function for the filter and then map pattern e.g: map f . filter pred
13:37:43 <monochrom> I mean unless they foresake user-defined types.
13:37:47 <artstart> ?
13:38:10 <fsestini> i just don‚Äôt see the difference between the type of show . read and some other C a => t, where t contains a
13:38:36 <Tuplanolla> Well, `foldr`, but that's perhaps a bit too general, artstart.
13:38:50 <fsestini> but maybe there are some details of the typeclass resolution that i‚Äôm missing
13:38:59 <monochrom> benzrf: I am still getting an ambiguous-type error.
13:39:33 <lyxia> :t mapMaybe -- artstart 
13:39:35 <lambdabot> (a -> Maybe b) -> [a] -> [b]
13:39:56 <monochrom> But I'm doing everything at the ghci prompt. Maybe I should try a file.
13:40:10 <lyxia> monochrom: http://lpaste.net/352245
13:40:36 <monochrom> Oh God AllowAmbiguousTypes
13:41:10 <lyxia> Best extension.
13:41:15 <geekosaur> fsestini, how do you have it pick an a for (show :: Show a => a -> String) . (read :: Read a => String -> a) ?
13:41:49 <geekosaur> more precisely, how would *you* go about picking that a?
13:41:54 <monochrom> fsestini: But "String -> String" doesn't contain "a".
13:41:59 <artstart> lyxia: thanks
13:42:12 <fsestini> geekosaur: the same way i do for read :: Read a => String -> a, i don‚Äôt. or better, i do when a gets specialized
13:42:20 <geekosaur> you cannot specialize it
13:42:31 <fsestini> geekosaur: the fact that a cannot be specialized should not prevent me from defining that function
13:42:33 <geekosaur> that is precisely the point
13:42:45 <monochrom> Is this an exercise of "the computer should do what I mean"?
13:42:49 <geekosaur> fsestini, so you want a function that has no idea what it does?
13:43:03 <monochrom> Because I don't believe in DWIM. I believe in WDYM.
13:43:39 <fsestini> geekosaur: it‚Äôs just that i think it should type check anyway
13:44:41 <geekosaur> ... I'm sorry, that is nonsense.
13:44:56 <geekosaur> you cannot say what that does, why should it be allowed to typecheck?
13:45:18 <geekosaur> what it does is *defined* by the choice of a. the compiler is telling you this when it refuses to typecheck
13:48:00 <sternmull> is there a good and portable regex package?
13:48:48 <fsestini> geekosaur: so when the compiler says the ambiguity prevents Read a from being solved, should i interpret it as ‚Äòyou won‚Äôt be able to solve it in any way‚Äô or something like that?
13:49:10 <geekosaur> regex-tdfa is good, portable, and slow. the others are faster but generally not portable and sometimes not good (e.g. the pcre one is dependent on your having a pcre library built with utf8 support)
13:49:40 <sternmull> ok, thanks
13:49:41 <geekosaur> fsestini, you cannot solve it from outside of f (unless you enable TypeApplications and annotate every call to f)
13:53:03 <geekosaur> fsestini, this is a general issue with typeclasses. lots of things can lead the compiler to not be able to pick appropriate instances; sometimes you can fix this with a type ascription, but with `f` as defined you can't do that *when calling f*. TypeApplications can in that case (and a few other messy cases) but you have to use it every time... and it becomes a question of whether `f` is worth writing if you have to annotate every single usage
13:55:13 <dfeuer> :t mapMaybeM
13:55:15 <lambdabot> error:
13:55:15 <lambdabot>     ‚Ä¢ Variable not in scope: mapMaybeM
13:55:15 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
13:55:21 <fsestini> geekosaur: i think what confused me is that from the error messages, it seemed to me that the compiler was trying to instantiate the type var, or the type class, at the point or declaration of f, rather than when using it
13:55:37 <geekosaur> yes, because it;s not accessible when you use it
13:56:26 <geekosaur> (again, unless you enable TypeApplications --- but I don't know that the current instance resolution stuff is smart enough to take that into account if you have it enabled)
13:56:27 <monochrom> If the type variable still existed in the overall type, yes the compiler can keep its contraint and defer to the users.
13:56:47 <monochrom> But you still haven't answered where does the letter "a" appear in "String -> String".
13:57:50 <fsestini> monochrom: it doesn‚Äôt, but just deferring the instantiation of a seemed reasonable to me
13:57:54 <geekosaur> what monochrom said is the key point; if "a" were visible then the compiler could defer the type
13:58:13 <geekosaur> since it is not, it has no choice but to resolve it because there is no "hook" for the use site to control it
13:58:56 <fsestini> geekosaur: so if a constrained variable is ambiguous, that is not appearing in the type, the compiler tries to resolve the constraint at the point of declaration?
13:58:56 <monochrom> Do not value "seem reasonable" so much. Design and implement a type system that does what you said. You will see the issues, at the very least the trade-off issues.
13:59:01 <fsestini> i didn‚Äôt know that
13:59:08 <fsestini> i think this clarifies
13:59:32 <monochrom> A lot of unsatiable human desires seem reasonable at various points to various people.
13:59:32 <geekosaur> fsestini, it does, because it knows there is nowhere else that it can be resolved
13:59:39 <fsestini> monochrom: i think i always has something like system f with explicit dictionary passing in mind
13:59:50 <geekosaur> the definition of f knows everything that will ever be known about the type of a
14:00:04 <monochrom> System F is an unfair comparison because System F doesn't even try inference.
14:00:36 <monochrom> And your current example does exploit inference. You are not annotation types left right and centre.
14:01:36 <monochrom> Also I am not convinced that Haskell type classes are equivalent to dictionary passing. For one thing the imaginary dictionary is not even exposed in any way.
14:02:42 <fsestini> monochrom: i mean that in my mind, it should have made sense to accept a type that was acceptable in a system f with explicit dictionaries
14:02:47 <monochrom> (Do not harp "that's how the compiler does it underneath" to me. Does Haskell also expose the quantum mechanics at the silicon level which is "how every computer today does it" too?)
14:03:05 <fsestini> because a constrained type is in the end a function type, where that ‚Äòa‚Äô appears
14:05:47 <monochrom> Haskell is not System F. If you want System F you should use System F directly.
14:06:32 <monochrom> There are going to be a million other things that make sense in System F but simply banned in Haskell even after turning on all extensions.
14:06:51 <ph88> we need more extensions
14:07:53 <monochrom> I used to hold disbelief at people who just assumed that Haskell could do highschool algebra simply because the syntax looks so like math notation.
14:08:14 <monochrom> "If I defined 'x = 2*x' shouldn't the computer figure out I want x=0?"
14:08:37 <monochrom> It makes total sense in Mathematica, you know.
14:08:52 <fsestini> monochrom: i‚Äôm aware that haskell in not system f
14:08:54 <monochrom> But Haskell is neither Mathematica nor System F.
14:09:23 <fsestini> i just though that example function should have been typecheckable anyway
14:09:43 <ph88> not too long ago i believed monads had build-in reflection and whatnot so i'm not surprised about the  x = x*2
14:11:47 <fsestini> the thought being, how is forall a . Read a => String -> a different from forall a . (Read a, Show a) => String -> String, since in both cases a is determined by the caller?
14:12:12 <fsestini> but i didn‚Äôt know that the compiler tries, rightfully in this case, to instantiate ambiguous type variables right away
14:12:20 <monochrom> But you didn't write "forall a . (Read a, Show a) => String -> String". You wrote "String -> String". Your own code.
14:12:45 <ph88> fsestini, i thought the part before the  =>  (forgot what it was called)  needs to be proven before anything is done with control flow
14:13:13 <fsestini> monochrom: my answer was ‚Äúwhy it is not acceptable to infer (Read a, Show a) => String -> String for show . read‚Äù
14:13:35 <fsestini> (without MR)
14:13:44 <monochrom> I don't know. But I would answer "have you written a type inferer that does it?"
14:13:52 <monochrom> Or maybe rather s/answer/ask/
14:14:12 <fsestini> sorry, that was *question
14:14:17 <monochrom> There are trade-offs and you may like or not like what you're giving up for what you want.
14:14:44 <monochrom> So much for armchair type inference.
14:15:21 <fsestini> monochrom: does haskell already infer that type, but then discards it when not able to resolve the constraints?
14:17:08 <fsestini> ph88: that‚Äôs true. my objection with this example was: shouldn‚Äôt it be a problem at call site?
14:17:22 <dolio> Types like `forall a. C a => T` are unacceptable in Haskell because there is no way in the language to ever specify what `a` is. So they must be resolved in the spot where they'd occur.
14:18:57 <ph88> fsestini, at least the compiler message could be a bit more clear about it :/
14:18:59 <dolio> Where `a` doesn't occur in `T`, that is.
14:19:09 <fsestini> dolio: or rather, haskell‚Äôs design decision is to resolve them immediately
14:19:11 <geekosaur> and the answer was: that'd be great, if the call site had any way at all to say what `a` is. but `a` is hidden inside `f` and the call site can't see it much less control it
14:19:38 <geekosaur> `a` has to be exposed in the type of `f` for the call site to have any say
14:20:28 <fsestini> geekosaur: in that case ‚Äòa‚Äô and its constraints would be added to the type of the expression where f is used
14:20:41 <fsestini> but i agree that this does not make much sense
14:21:01 <fsestini> just what a blind type inference would do, i guess
14:27:32 <dolio> Haskell specifies that they must be resolved in the spot they occur.
14:28:32 <dolio> And it is good that it does so.
14:29:31 <CuriousErnestBro> Haskell is so much fun :)
14:30:03 <fsestini> dolio: yes, it definitely makes sense. i just wanted a confirmation that it is indeed a design decision, not something that must be done because otherwise semantic issues occur
14:31:31 <dolio> One could write a compiler that never reports type errors when it detects that two types don't match, and instead carries around unsatisfiable equality constraints, but it would probably not be pleasant to use.
14:37:36 <dmwit> fsestini: You may also like: -XAllowAmbiguousTypes, -fdefer-type-errors
14:41:22 <fsestini> dmwit: actually i‚Äôm ok with the default behaviour, just wanted to understand it more. but thanks
14:41:34 <fsestini> also for some reason it does not type check even with that enabled
14:42:33 <dmwit> WFM
14:43:21 <fsestini> oh, it does in ghci but not on the emacs buffer i have open
14:43:37 <fsestini> w/e
14:44:00 <dmwit> Perhaps this satisfactorily answers your "Can it be done?" question satisfactorily.
14:44:13 <dmwit> Oops. That sentence was way too satisfied with itself.
14:45:38 <hololeap> is there a utility that can take any valid haskell code and create a nice visual diagram sort of like what Beckman shows in this video (look around the 20 minute mark): https://channel9.msdn.com/shows/Going+Deep/Brian-Beckman-The-Zen-of-Expressing-State-The-State-Monad/
14:46:15 <monochrom> "zen" is such an overused meme.
14:46:45 <monochrom> So overused and old, it became a meme even before people started to say "meme".
14:50:35 <Squarism> anyone know a trick to tell stack not to build all executable defined in .cabal file?
14:50:48 <Squarism> executables
14:57:35 <EvanR> state is an overused meme!
15:54:44 <orion> Hey. Does anyone know that syntactic sugar for function paramters where the fields of a record can be referenced directly?
15:55:12 <orion> I thought it was Record (..) or something.
15:55:16 <EvanR> you can pattern match on records
15:55:18 <glguy> RecordWildCards
15:55:21 <orion> Yes!
15:55:30 <orion> Thank you.
15:57:20 <geekosaur> and the syntax you are looking for is {..} (braces, not parens)
16:17:41 <ertes> is there a variant of MutVar# for unlifted types?  or: what's the cheapest method to store a mutable Int/Int#?
16:18:05 <ertes> + strict
16:19:26 <reactormonk> Is there a way to say `a` can either be A or B? in an instance definition.
16:21:05 <ertes> reactormonk: nope, but you can either make instances for both A and B, or an instance for Either A B
16:21:13 <glguy> reactormonk: You can make a new typeclass C, and add separate "instance C A" and "instance C B" and then put a "C a" constraint on this instance definition
16:21:37 <ertes> or that
16:22:44 <ertes> reactormonk: what's the use case?
16:22:46 <reactormonk> End result: I wanna derive Data.Data from the class.
16:23:32 <ertes> reactormonk: are you using an API that requires Data?  if not, consider using the more modern GHC generics
16:23:47 <reactormonk> ertes, quasiquotes
16:23:56 <reactormonk> I'll also take these, if possible.
16:24:42 <reactormonk> I wanted to use lifting, so I can transfer the compiletime data to runtime data.
16:33:06 <reactormonk> Directly tryint to derive a Lift instance give me the error that there's no Lift ByteString :-/
17:05:09 <Taggnostr> hello
17:06:16 <Sornaensis> haskell is such a joy to develop with :3
17:06:19 <Taggnostr> I'm executing ghci -e from another program, and getting the error Error: HOME: getAppUserDataDirectory: does not exist (no environment variable)
17:06:34 <Sornaensis> sounds like they don't have a data directory set
17:06:55 <Sornaensis> can I ask why you are calling ghci from another program?
17:07:21 <Taggnostr> it's an irc bot, I have a command to evaluate haskell snippets
17:07:43 <Sornaensis> Taggnostr: use mueval
17:07:45 <Taggnostr> the weird thing is that the command works fine from the bot, but not from the tests
17:07:53 <Sornaensis> don't call ghci -i
17:07:55 <Sornaensis> -e*
17:08:04 <geekosaur> how are these tests being run?
17:08:11 <EvanR> ghci -e "haskell code for delete users file system"
17:08:12 <Sornaensis> Taggnostr: https://hackage.haskell.org/package/mueval
17:08:39 <Taggnostr> EvanR, it's a private bot, so only I can use the command
17:08:49 <EvanR> heh
17:08:53 <Sornaensis> pls no
17:09:01 <geekosaur> you hope
17:09:03 <EvanR> "these controls are isomorphic"
17:09:06 <Sornaensis> mueval works the same but prevents you from doing dumb stuff
17:09:08 <EvanR> "only i can use them"
17:09:18 * geekosaur would not want such a thing on a public IRC server
17:09:24 <threestrikes> Hi I just made a couple changes to a cloned repository from git.  I already compiled the program earlier and it worked.  I should theoretically be able to re compile the same program without having to create another clone, correct?
17:09:44 <Taggnostr> geekosaur, the bot is written in python, I'm not sure why it fails from the tests, perhaps the test runner prevent access to envvars and/or the home
17:10:28 <dmwit> threestrikes: sure
17:11:03 <Taggnostr> Sornaensis, looking into mueval, thanks for the suggestion
17:15:05 <threestrikes> I used the command "stack install" to recompile the program, which was the same command I used to install it the first time.  Am I missing something?
17:16:06 <Taggnostr> Sornaensis, I'm getting https://github.com/gwern/mueval/issues/16
17:21:10 <geekosaur> threestrikes, if you are making changes to a dependency, you will need to tell stack to use the local copy that has the changes
17:21:51 <geekosaur> otherwise it uses (its cached copy of) what it pulled from upstream, not yours
17:22:10 <kadoban> If you have it referring to a git repo, you have to tell it to use a different commit-hash or whatever.
17:22:12 <threestrikes> thats the message I got I just didn't understand what it was saying
17:22:31 <threestrikes> or how to change it
17:22:39 <kadoban> It'll probably be a bit clearer if you lpaste the message and the relevant files, like stack.yaml
17:23:59 <threestrikes> I'll try to read up on git and see if there are any tutorials, if I can't figure it out I'll upload to lpaste and beg for help later :)
17:24:15 <threestrikes> Thanks 
17:30:52 <halogenandtoast> Does anyone have experience with hedis who can decipher what this means `No instance for (RedisCtx (Either t0) Redis)`
17:30:59 <halogenandtoast> I'll post some code
17:31:48 <lpaste_> halogenandtoast pasted ‚ÄúStories.hs‚Äù at http://lpaste.net/352251
17:36:47 <c_wraith> halogenandtoast: in general, the error message means exactly what it says.  A type is being inferred to require an instance the RedisCtx class, but the concrete type being inferred has no such instance.
17:37:01 <c_wraith> ...an instance *of* the...
17:37:20 <c_wraith> > "1" + "2"
17:37:23 <lambdabot>  error:
17:37:23 <lambdabot>      ‚Ä¢ No instance for (Num [Char]) arising from a use of ‚Äò+‚Äô
17:37:23 <lambdabot>      ‚Ä¢ In the expression: "1" + "2"
17:38:25 <geekosaur> however when the type has a digit appended, it often means you failed to relate some value to its type correctly such that inferred a new instance to be needed
17:39:57 <c_wraith> halogenandtoast: which line of the paste is the error attributed to?
17:41:22 <halogenandtoast> Actually I've messed up that error message. That error message was from a previous build run.
17:42:01 <halogenandtoast> getting the original code now
17:42:13 <lpaste_> halogenandtoast revised ‚ÄúStories.hs‚Äù: ‚ÄúStories.hs‚Äù at http://lpaste.net/352251
17:42:33 <halogenandtoast> the error occured on line 5
17:43:05 <c_wraith> well, now the Either in the error message makes more sense
17:43:35 <c_wraith> > pure 1 :: Either Int Int
17:43:38 <lambdabot>  Right 1
17:45:06 <halogenandtoast> While I now have my code compiling (because I'm doing something different) I'd like to understand what I didn't understand in the first place (that prompted me to write the incorrect code). What is the relation between `pure 1 :: Either Int Int` and what I did previously?
17:45:38 <threestrikes> In order to have git compile my changes that I have committed do I need to create another branch?
17:46:02 <c_wraith> No direct relation, I was just reminding myself which side of Either was Left and which was Right.  I have trouble with those sometimes. :)
17:46:18 <c_wraith> Left and Right are difficult directions.  always being sneaky and changing
17:46:47 <c_wraith> halogenandtoast: so the most recent paste is the one that error came from?
17:46:54 <halogenandtoast> c_wraith: yes
17:47:45 <halogenandtoast> and for reference `exists :: RedisCtx m f => ByteString -> m (f Bool)`
17:48:10 <halogenandtoast> So in this situation m is (Either t0) and f is Redis
17:48:11 <lpaste_> c_wraith annotated ‚ÄúStories.hs‚Äù with ‚ÄúStories.hs (annotation)‚Äù at http://lpaste.net/352251#a352253
17:48:55 <halogenandtoast> oh
17:48:58 <halogenandtoast> how silly
17:50:10 <halogenandtoast> Thanks c_wraith that makes sense
17:50:27 <c_wraith> The error message does seem a bit weird in that case.
17:50:38 <c_wraith> But I'm going to blame that on it being a multiparameter type class
17:50:49 <c_wraith> those make things more complicated.
17:51:27 <dibblego> @where NICTA
17:51:27 <lambdabot> https://github.com/nicta/course
17:53:20 <c_wraith> halogenandtoast: oh, I see.  You had the type parameters backwards.  There's an instance where m is Redis and f is (Either Reply)
17:53:50 <c_wraith> halogenandtoast: so it looked like it was complaining about something bizarre, but really it was just the order of operations being backwards
17:54:15 <halogenandtoast> :?
17:54:40 <halogenandtoast> I kind of understand.
17:54:53 <c_wraith> IE, you needed to bind the result into the Redis context before you could pattern-match on it, not after
17:55:48 <halogenandtoast> Ah yeah
17:58:35 <halogenandtoast> is there any function f with a signature like `Either a b -> b -> b` such that `f False either` is b of Right b or False of Left a?
17:59:16 <halogenandtoast> basically I want to get rid of case fetched of Right truth -> truth; _ -> False with a function call
17:59:44 <halogenandtoast> so something similar to `maybe` but for Either
18:00:07 <geekosaur> :t either (const False) id
18:00:08 <lambdabot> Either b Bool -> Bool
18:00:13 <c_wraith> well, there's the function `either`, but it's closer to `maybe` than `fromMaybe`, and that's what you're describing
18:01:39 <c_wraith> :t \x -> either (const x) id
18:01:41 <lambdabot> c -> Either b c -> c
18:01:50 <halogenandtoast> I guess that will do, thanks geekosaur and c_wraith 
18:02:02 <halogenandtoast> I looked at the type signature and dismissed it
18:02:33 <halogenandtoast> but I just needed to fill in the correct values for (a -> c), (b -> c)
18:28:56 <threestrikes> I'm not sure if I'm using git correctly.  http://pastebin.com/d2T1Uw59 
18:30:16 <threestrikes> I'm trying to change a few images on menu buttons and I'm getting this error after re-compiling.  
18:33:39 <kadoban> That's a weird message ...
18:38:02 <threestrikes> I made changes to a file and added the images to the directory a function checks for images.  I did a git commit but's as if the function is expecting the .png file to be there but for some reason it's not.  I can see it there locally.
18:38:36 <threestrikes> I'm sure it's something simple, but I don't understand.
18:40:03 <kadoban> threestrikes: What is your stack.yaml setup? Which repo did you do this commit in? Did you push it anywhere?
18:40:13 <kadoban> Are the messages at the top new, or is that expected behavior?
18:40:39 <threestrikes> expected behavior
18:41:14 <threestrikes> I did the commit in a cloned repo that is local
18:41:29 <threestrikes> I haven't pushed it 
18:42:42 <threestrikes> How would I find my stack.yaml setup?
18:43:34 <kadoban> threestrikes: Well, are the changes you've made in the thing you're actually building or a dependency? It's not really clear. Before it sounded like you were changing a dependency. You should have a stack.yaml file somewhere usually.
18:44:30 <threestrikes> It's not a dependency it's the actual build
18:45:03 <kadoban> Oh, then I don't see how git is really relevant at all. stack doesn't really care about git unless you tell it to.
18:46:16 <kadoban> threestrikes: Perhaps you need to change something in the .cabal file to refer to the file you've added or whatever? I'm kind of guessing.
18:51:14 <threestrikes> I'll check there and see if anything sticks out. Thanks 
18:52:41 <kadoban> Or it's screwing up at runtime I guess, so could be anything in the code too, I suppose? Not really sure what's going on there.
18:55:23 <geekosaur> likely missing from data-files: so the runtime data file magic didn't magic right
18:55:41 <geekosaur> (https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code)
18:56:15 <threestrikes> yeah I was checking runtime first.  I can see that the source file I changed throws this exception (\(e :: SomeException) -> getDataDir >>= \dataDir -> throwIDE (T.pack $ printf (__ "Can't load icons from %s %s") dataDir (s
18:56:43 <threestrikes> how e)))
18:57:42 <threestrikes> Legion is about to come on so this may have to wait lol
18:58:58 <threestrikes> Thanks geekosaur I'll check that as well
19:05:40 <erisco> is there anything that can be done about this? http://lpaste.net/352256
19:08:17 <Welkin> erisco: you and your type adventures
19:09:20 <geekosaur> good luck with that, then
19:10:47 <Welkin> what is the best resource for learning about dependent typing using idris?
19:11:26 * geekosaur didn't know a GADT (as distinct from an ADT using GADT syntax) could be promoted...
19:11:47 <Welkin> I have the haskell paper "Dependently Typed Programming with Singletons"
19:11:54 <geekosaur> and I have no clue what a constraint would mean when promoted. that error suggests neither does ghc >.>
19:12:03 <mniip> geekosaur, it's new in TypeInType
19:12:05 <lpaste_> xcmw revised ‚ÄúWhy stack fail to build reactive banana and wxwidgets?‚Äù: ‚ÄúWhy does stack fail to build reactive banana and wxwidgets?‚Äù at http://lpaste.net/8538512301479690240
19:12:22 <erisco> I don't either, but maybe it makes sense to merely drop the constraints
19:12:49 <kadoban> xcmw: At a guess, lack of C libraries or something? Did you check the logs it points to?
19:12:59 <geekosaur> xcmw, I think you duyplicated the cabal file as the stack.yaml
19:13:12 <geekosaur> if that's really your stack.yaml then stack is likely *really* confused >.>
19:13:34 <mniip> erisco, I don't think you can promote constraints in any way
19:13:42 <lpaste_> xcmw revised ‚ÄúWhy does stack fail to build reactive banana and wxwidgets?‚Äù: ‚ÄúWhy does stack fail to build reactive banana and wxwidgets?‚Äù at http://lpaste.net/8538512301479690240
19:13:44 <mniip> you'd get impredicative kind polymorphism otherwise
19:14:09 <lpaste_> xcmw revised ‚ÄúWhy does stack fail to build reactive banana and wxwidgets?‚Äù: ‚ÄúWhy does stack fail to build reactive banana and wxwidgets?‚Äù at http://lpaste.net/8538512301479690240
19:14:38 <xcmw> There is nothing in the log not included in the error messsage
19:14:39 <geekosaur> also this looks like one of those cases where stack "helpfully" wrote the error output somewhere other than the terminal
19:15:04 <geekosaur> or maybe one of the corner cases where it forgets to log anything (make sure you;re running latest stack though, thought they fixed those)
19:15:50 <geekosaur> I am however guessing it's the Setup.hs that is failing to build, likely because you are missing the Wx devel libs for your platform
19:16:09 <geekosaur> (runtime libs are not enough, if you are on a fedora/rhel/centos or debian/ubuntu/mint)
19:16:36 <xcmw> I'm on osx
19:17:20 <xcmw> I installed wxmac from homebrew
19:17:32 <geekosaur> might need to tell it to look under /usr/local for wx then
19:17:43 <erisco> glguy, jle` equality or ordering on Fin seems odd. Any ideas?
19:17:51 <geekosaur> --extra-lib-dirs=/usr/local/lib --extra-include-dirs=/usr/local/include
19:18:07 <erisco> is it just inappropriate for either?
19:18:08 <geekosaur> (this usually can *not* be put in a cabal file. no idea if you can put it in stack.yaml)
19:19:38 <erisco> Data.Type.Fin has a * and * -> * kinded equality and ordering. Maybe it is best to just define both then
19:20:03 <GreySunshine> Hello!
19:20:15 <erisco> seems a bit hectic with adding these higher kinded classes but... okay
19:23:02 <GreySunshine> Guys I was wondering if xmonad is tested for properties, It is mathematically sound, then does it not need bug fixes? Is it in maintenance? It is tough to wrap around my this!
19:23:27 <lpaste_> xcmw revised ‚ÄúWhy does stack fail to build reactive banana and wxwidgets?‚Äù: ‚ÄúWhy does stack fail to build reactive banana and wxwidgets?‚Äù at http://lpaste.net/8538512301479690240
19:23:38 <xcmw> geekosaur: Added that same error
19:23:59 <erisco> though... what is reflexivity? normally I say eqRefl :: forall (a :: k). a := a
19:24:10 <erisco> but if there are two kinds what would that be
19:24:10 <geekosaur> only some things can be tested. most stuff can't be because you would have to mathematically model an X server, including the bugs inevitably present in nvidia's drivers...
19:24:53 <geekosaur> xcmw, at this point I think you have to convince stack to tell you the actual error.
19:25:17 <erisco> I am guessing it has to be something like  eqRefl :: forall (a :: F j) (b :: F k). (a :== b) := (b :== a)
19:25:41 <erisco> where :== is the equality on * -> * sorted kinds
19:25:41 <geekosaur> you might have to open a stack bug about it not printing or logging any errors
19:26:06 <erisco> and := is equality on * i.e. it is (a :== b -> b :== a, b :== a -> a :== b)
19:26:16 <xcmw> geekosaur: It logged the error
19:26:31 <xcmw> [1 of 1] Compiling Main             ( /private/var/folders/_m/1h8dd_fd3dx3qvtq87_c4q480000gn/T/stack74916/wxcore-0.11.1.2/Setup.lhs, /private/var/folders/_m/1h8dd_fd3dx3q
19:26:33 <erisco> certainly gets a bit weird
19:26:34 <xcmw> vtq87_c4q480000gn/T/stack74916/wxcore-0.11.1.2/.stack-work/dist/x86_64-osx/Cabal-1.24.0.0/setup/Main.o )
19:26:37 <xcmw> Linking /private/var/folders/_m/1h8dd_fd3dx3qvtq87_c4q480000gn/T/stack74916/wxcore-0.11.1.2/.stack-work/dist/x86_64-osx/Cabal-1.24.0.0/setup/setup ...
19:26:40 <xcmw> error: Unknown option "--sysconfdir=/Users/michaelmesser/Code/gui-test/.stack-work/install/x86_64-osx/lts-7.19/8.0.1/etc". Use "--help" to show valid options.
19:26:49 <geekosaur> o.O
19:27:01 <geekosaur> you have a cabal library mismatch, at minimum
19:27:29 <geekosaur> but you'll have to take this up with the stack devs probably
19:27:45 <Welkin> sorted kinds
19:27:50 <Welkin> I've never heard that before
19:27:57 <Welkin> there is only 1 sort in haskell I thought
19:27:59 <Welkin> BOX
19:28:20 <xcmw> geekosaur: Ok
19:28:22 <geekosaur> Welkin, not true since 7.10
19:28:26 <Welkin> oh?
19:28:44 <Welkin> where can I read about it?
19:28:51 <geekosaur> I think the levity stuff took its place, but it's stll a bit in flux
19:29:26 <MarcelineVQ> Welkin: there's a large section for things related to it in the manual https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#kind-polymorphism-and-type-in-type
19:29:49 <geekosaur> a simple version in 7.10, a more complex one in 8.0.x, and they;re still working on it with more changes coming in 8.2 and likely in 8.4 because some stuff didn't make the cutoff
19:30:30 <Welkin> this makes me want to get back into learning about type systems and category theory again
19:31:03 <MarcelineVQ> Welkin: large as-in  9.10-9.15  are probably all relevant
19:33:42 <Welkin> thanks MarcelineVQ 
19:34:49 * geekosaur is not the one to ask; I see the ghc commits but that doesn't mean I understand any of it :)
19:39:45 <erisco> type family Sing' :: (a :: k) -> (b :: Sing a)    * Expected a type, but `b' has kind `Sing a'
19:39:47 <erisco> hrm darn
19:41:19 <erisco> it doesn't even like (a :: k)
19:41:58 <mniip> erisco, that's the wrong ->
19:42:10 <mniip> you probably want
19:42:19 <mniip> type family Sing' (a :: k) :: Sing a
19:42:21 <mniip> or something
19:42:41 <erisco> oh I see, thanks
19:42:56 <mniip> what you're saying is that Sing' is of kind a -> b
19:43:00 <mniip> where a :: k, b :: Sing a
19:43:26 <mniip> or something
19:44:28 <erisco> type instance Sing' ('Z :: Nat) = ('SZ :: Sing 'Z)  * Data constructor `SZ' cannot be used here (it comes from a data family instance)
19:44:46 <erisco> really? :s
19:46:46 <mniip> is SZ' a monomorphic type?
19:46:57 <mniip> 'SZ *
19:47:07 <erisco> SZ :: Sing 'Z
19:48:07 <erisco> Sing is a data family. Why can I not use this constructor though... what a bummer
19:48:30 <halogenandtoast> Is there any reason to use let over where. I've found I currently prefer where over let (usually because I then don't require a do block).
19:48:37 <mniip> erisco, what happens if you say
19:48:48 <erisco> halogenandtoast, let is an expression, where is not
19:48:50 <mniip> type (SZ' :: Sing 'Z) = SZ
19:48:52 <geekosaur> if you need to work in expression syntax and not declaration syntax
19:48:53 <mniip> and then use that
19:49:14 <geekosaur> also let does not require do
19:49:20 <geekosaur> > let a = 5 in a
19:49:22 <lambdabot>  5
19:49:25 <kadoban> halogenandtoast: let * in *   doesn't require a do block
19:49:29 <halogenandtoast> yeah I like that even less
19:49:30 <kadoban> Oh ... already covered.
19:49:59 <erisco> mniip, Malformed head of type or class declaration: (SZ' :: Sing Z)
19:50:18 <mniip> drop the parens then :s
19:50:26 <mniip> the syntax is wonky
19:50:33 <erisco> parse error on input `::'
19:51:33 <lpaste_> halogenandtoast pasted ‚ÄúWhereVsLet.hs‚Äù at http://lpaste.net/4701458879387533312
19:51:41 <erisco> if monomorphic is a requirement then I am going to have problems anyways because I also need successor
19:51:46 <mniip> hrm
19:51:51 <mniip> can you lpaste it so I could tinker
19:51:53 <halogenandtoast> a before/after that shows my preference ^^ does it make sense to use where there?
19:52:32 <halogenandtoast> also is that the "proper" way to indent a long constructor?
19:53:28 <erisco> mniip, http://lpaste.net/352257
19:54:11 <Welkin> halogenandtoast: each parameter on its own line
19:54:16 <Welkin> that is how I do it
19:54:34 <Welkin> data LongConstructor = LongConstructor a b c d e f g
19:54:39 <Welkin> LongConstructor
19:54:40 <Welkin> a
19:54:40 <Welkin> b
19:54:42 <Welkin> ...
19:55:03 <mniip> erisco, SingI?
19:55:36 <erisco> hrm, I could run into illegal constraint errors with that couldn't I
19:55:52 <halogenandtoast> erisco: well SingI isn't defined in your paste
19:55:53 <mniip> no I mean I can't ghci your example
19:55:55 <halogenandtoast> so it's an error for us
19:55:56 <erisco> well you can kill that line
19:56:09 <erisco> yes I get that :P kill the line
19:56:45 <halogenandtoast> It's dead, where do I dump the body?
19:57:11 <erisco>  /dev/null
19:57:46 <mniip> oh
19:57:51 <mniip> so it's a GADT instance
20:01:37 <mniip> erisco, https://ghc.haskell.org/trac/ghc/wiki/GhcKinds#Promotingdatafamilies
20:02:09 <mniip> though,
20:05:11 <mniip> oh boy
20:05:24 <mniip> erisco, you can totally just move the instance into a different module
20:05:27 <mniip> though,
20:05:29 <mniip> it is a bug
20:05:34 <mniip> probably
20:07:17 <mniip> (I realized this by typing "type SZ' = SZ" in ghci)
20:13:25 <eacameron> What's the most popular tool for generating random numbers and shuffling lists?
20:13:41 <mniip> /dev/urandom, probably
20:13:53 <kadoban> Tool or haskell library?
20:14:12 <eacameron> I mean Haskell library
20:14:45 <ertes> could someone tell me how casMutVar# works?  how does it facilitate comparison?  and which argument is actually used for it?
20:15:02 <kadoban> System.Random from the 'random' package? I'm not 100% sure it has shuffle though.
20:15:46 <ertes> eacameron: mwc-random can do both
20:16:10 <eacameron> kadoban: It doesn't have shuffle but random-shuffle package builds on it to provide that.
20:16:18 <ertes> eacameron: https://hackage.haskell.org/package/mwc-random-0.13.5.0/docs/System-Random-MWC-Distributions.html#g:5
20:16:40 <kadoban> Ah nice, I didn't see shuffle in mwc-random
20:17:36 <ertes> mwc-random is also probably the fastest option on hackage
20:18:11 <eacameron> ertes: Ah cool. Looks like it's pretty solid.
20:18:18 <eacameron> ertes: Thanks very much BTW
20:18:26 <erisco> mniip, hm, well I'll have to rethink things a bit then
20:31:03 <l_zzie> what package do I use for type-level ints in haskell in 2017?
20:31:04 <l_zzie> lol
20:31:48 <ertes> l_zzie: base =)
20:32:11 <ertes> GHC.TypeLits more specifically‚Ä¶  not the most versatile solution, but good enough in many cases
20:32:34 <l_zzie> Ints, not Nats, sadly
20:34:12 <jle`> ertes: can you clarify your question you pinged me?
20:34:14 <ertes> what do you need?  just reification and reflection?  or do you need computation as well?
20:34:37 <ertes> jle`: hmm?  did i ping you?
20:34:41 <l_zzie> just reification and reflection I think
20:35:01 <jle`> oh sorry, erisco 
20:35:08 <ertes> l_zzie: then the reflection library can lift and lower arbitrary types
20:36:38 <todaystomorrow> I want to start programming in 3 dimensional games with haskell. I'm looking at ways to start, lambdacube engine looks good, but openGL appears to look good as well, I would love it if someone would tutor me on how to do a hello world.
20:37:23 <ertes> todaystomorrow: how deeply do you want to get into it, considering that there aren't any full haskell game engines yet?
20:37:25 <mniip> are we talking 3 spatial dimensions
20:37:58 <l_zzie> ertes ty, i'll look at that
20:38:43 <todaystomorrow> ertes I would love to develop that, I'm studying a game called frag
20:40:16 <todaystomorrow> so ertes, this is just going to be a bit messy isn't it? There's many different tounges for 3d game programming with haskell and I... could be the one to unify it?
20:40:23 <ertes> todaystomorrow: 3D from a geometrical standpoint requires some basic linear algebra knowledge, most notably matrices‚Ä¶  if someone uses the word "transformation matrix", do you know what is meant?
20:41:57 <mniip> affine transforms, quaternion positions, rotation matrices
20:42:44 <todaystomorrow> ertes no I don't
20:43:02 <ertes> todaystomorrow: then your first step is to learn basic linear algebra =)
20:43:07 <todaystomorrow> ertes I have some projects that wouldn't require me to understand that. I want to make a 3d rubix cube
20:43:53 <todaystomorrow> ertes, so you would recommend I first learn linear algebra? shouldn't I start just programming to get myself warmed up for it?
20:43:56 <ertes> todaystomorrow: even just perspective projection requires it, and it's not too much learning overhead either
20:44:46 <ertes> todaystomorrow: you can (and probably should) do both in tandem, but i can't point you to any rendering libraries that come will batteries included
20:44:55 <ertes> todaystomorrow: luminance may be closest though
20:45:24 <ertes> it still wants you to write your own shaders though, so it's still fairly low-level
20:45:39 <todaystomorrow> I've been studying and reading code with openGL and it looks easies enough
20:45:43 <ertes> there is also GPipe, which has a haskell EDSL for shaders
20:45:54 <todaystomorrow> so with rendering libraries it's assumed that you learn linear algebra?
20:46:00 <ertes> yes
20:46:45 <todaystomorrow> I should be taking notes right now
20:46:51 <ertes> even if a library doesn't *strictly* require it, you should learn it anyway
20:46:57 <todaystomorrow> but it's almost my bedtime
20:47:05 <todaystomorrow> ertes, thanks great advice
20:47:11 <todaystomorrow> how do I learn vector algebra?
20:47:38 <ertes> any linear algebra course will most likely start with that
20:47:54 <ertes> and there are tons of free resources for it, including entire video series
20:47:54 <monochrom> buy a linear algebra textbook
20:48:32 <todaystomorrow> ertes I'm considering taking the MIT challenge and only studying from books and the internet for a while
20:48:55 <todaystomorrow> so I'm trying to find some books that would be good for it, I think I'll use what berkelley uses
20:49:40 <ertes> the basics literature is pretty timeless, so pick a book, and if you don't like its pacing, pick a different one
20:50:09 <todaystomorrow> ertes I agree!
20:50:13 <todaystomorrow> and just build things!
20:50:18 <todaystomorrow> build very big things!
20:50:40 <ertes> linalg is just the basics‚Ä¶  there is still a lot to learn after that =)
20:51:52 <ertes> anything more complex than a rubik's cube will require interactivity abstractions, efficient spatial data structures, etc.
21:18:03 <excelsiora> hi haskell!
21:18:20 <Sornaensis> hello excelsiora 
21:18:26 <excelsiora> anyone use haskell with emacs?
21:18:33 <excelsiora> (specifically orgmode?)
21:18:48 <Koterpillar> emacs yes, orgmode no
21:20:48 <excelsiora> does it assume stack?
21:21:27 <Koterpillar> no, but it uses stack for stack projects
21:21:59 <excelsiora> I got runhaskell and ghc and ghci from the ubuntu repos, but I'm having problems with the inferior haskell mode for code blocks in orgmode and I think perhaps I should use stack instead, and my problems could go away...
21:23:29 <excelsiora> Koterpillar: thoughts? 
21:24:01 <Koterpillar> excelsiora: "having problems" -?
21:24:48 <excelsiora> specifically it hangs and hangs and doesn't return control when I try to execute a code block.
21:25:35 <Sornaensis> does anyone know of an up to date python library for haskell?
21:25:39 <excelsiora> wget -qO- https://get.haskellstack.org/ | sh
21:25:44 <Koterpillar> excelsiora: OK. Well, no thoughts unfortunately, I use intero and that's pretty much it
21:25:51 <excelsiora> intero?
21:25:53 <Sornaensis> when I try to install cpython I get dependency errors
21:26:41 <excelsiora> Sornaensis: are you trying to install from the python.org site?
21:27:09 <Sornaensis> no I am trying to install the cabal package cpython from hackage
21:27:21 <Koterpillar> excelsiora: error checking in Haskell files
21:27:31 <excelsiora> ok
21:28:02 <excelsiora> well I'll go paralyze myself with some more analysis... :P thanks for the help!
21:28:07 <excelsiora> :)
21:29:55 <ertes> excelsiora: you should use haskell-interactive-mode, not inferior-haskell-mode
21:30:00 <ertes> the latter is‚Ä¶  inferior‚Ä¶
21:30:30 <ertes> however i don't know how well either plays with org-mode
21:31:51 <ertes> org-mode's insistence on strange syntax doesn't make it particularly suited for any interpreter integration
21:32:48 <ertes> however, if you use markdown instead of org, just give the file an .lhs extension and GHCi will happily take it as a literate haskell module
21:48:20 <Sornaensis> ahh I found the solution: pkg-config was mismatched
21:50:35 <excelsiora> runnign stack setup
21:51:52 <excelsiora> ertes: thanks - but I think ob-haskell hard-codes "inf-haskell" - so I'm going to look into haskell-interactive-mode
22:01:06 <ertes> i have a function of the following shape:  f x = unsafePerformIO . IO $ \s0 -> ‚Ä¶
22:01:21 <ertes> will NOINLINEing that function be enough to make it safe?  i'm a bit worried about CSE
22:02:57 <ertes> the IO action only creates a MutVar# and populates a constructor, nothing else
22:03:38 <c_wraith> why unsafePerformIO at all?
22:04:56 <jle`> ertes: the fact that it's function might make it difficult to be safe
22:05:24 <jle`> would 'f 10' return the same thing every time it is called?
22:06:06 <ertes> c_wraith: because the API is going to be pure, but relies heavily on non-local side effects for efficiency
22:06:24 <ertes> jle`: semantically yes
22:06:41 <ertes> but duplicating it would be less efficient
22:06:59 <c_wraith> ertes: if you're worrying about CSE, you're not in a situation unsafePerformIO is good for.
22:08:00 <dramforever> ertes: Can you just keep the bad parts in IO and put unsafePerformIO on the pure API?
22:08:15 <dramforever> because otherwise it's not a pure API
22:11:12 <c_wraith> ertes: I mean, "non-local effects" sounds like it would completely break persistent uses of the API, which a pure API should support transparently.
22:11:29 <ertes> c_wraith: that's the plan
22:11:52 <ertes> it's basically a self-propagating version of Coyoneda IORef
22:11:52 <c_wraith> then the API isn't pure?
22:12:13 <dramforever> c_wraith: I can think of an example I think
22:12:24 <dramforever> Attoparsec!
22:12:43 <ertes> one IORef at the write end, multiple (Coyoneda IORef)s at the read ends
22:13:04 <dramforever> Where I totally do not understand why the docs say this: http://hackage.haskell.org/package/attoparsec-0.13.1.0/docs/Data-Attoparsec-ByteString.html#v:Partial
22:14:14 <c_wraith> ertes: IORef needs IO to write to, Coyoneda IORef needs IO to read from - where's the part that can't be in IO?
22:14:40 <ertes> c_wraith: e.g. fmap
22:14:45 <c_wraith> that's not reading
22:15:08 <c_wraith> It also doesn't require duplicating the mutvar#
22:15:19 <c_wraith> I fail to see where unsafePerformIO becomes a requirement
22:15:45 <dramforever> Is it just 'pure but unsafe' is easier than IO?
22:16:11 <dramforever> oh wait a sec you're trying to squeeze IO into some other function?
22:16:11 <dramforever> huh
22:16:18 * dramforever feels overwhelmed
22:16:19 <ertes> c_wraith: i'm creating a variant of Coyoneda IORef that caches the values
22:17:48 <ertes> simplified:  data Var a = Var (IO a) (IORef (Maybe a))  -- when the value is already known, the IORef is a Just, otherwise the IO action will compute the value based on other Vars
22:17:51 <c_wraith> so your goal is to reduce recalculation of intermediate results in a tree of fmaps?
22:17:58 <ertes> (of course this isn't exposed)
22:18:01 <ertes> yeah
22:18:07 <ertes> not just fmaps
22:18:17 <ertes> basically a fully monadic interface
22:20:48 <c_wraith> dunno.  It seems bad if a result is cached, then the upstream IORef is updated.  Where's the cache invalidation?
22:21:28 <ertes> this is simplified‚Ä¶  the real update action is a (Codensity IO a) that invalidates the cache at the end
22:21:54 <c_wraith> "at the end" isn't good enough in a concurrent environment. :)
22:23:05 <c_wraith> I guess it's OK if you don't demand 100% atomic updates
22:23:12 <c_wraith> dirty reads are ok sometimes
22:24:03 <c_wraith> but once you introduce potential dirty reads, the burden for using the structure properly goes way up..
22:24:04 <ertes> again: this is highly simplified‚Ä¶  there is going to be proper locking as well‚Ä¶  i'm even considering TVar# instead of the current MutVar# =)
22:24:33 <ertes> and yes, i realise that this needs a comprehensive test suite =)
22:25:11 <c_wraith> Why not simplify things and not use unsafePerformIO? :)
22:25:20 <ertes> how?
22:26:04 <ertes> i don't feel very confident about using runRW# directly =P
22:28:12 <orion> Does anyone know which primitive of optparse-applicative I would need for "cmd --foobar -- a b c", where I am looking to collect 'a', 'b', and 'c' in a list of Strings
22:28:39 <c_wraith> ertes: Just don't support things that don't work without invisible allocation.  This just sounds like a problem that needs a different solution design.
22:38:07 <ezyang> Hey reflex users: why is the Reflex type class on (a :: *) and not (a :: * -> *)? 
22:40:04 <MarcelineVQ> idk about that stuff but leave a message in #reflex-frp too, the dev's hang out in there
22:59:33 <ertes> ezyang: because it's just a dummy type
22:59:58 <ertes> ezyang: in particular it (e.g. Spider) is not the host monad (e.g. SpiderHost)
23:00:30 <ertes> all it does is to represent an abstract notion of "timeline"
23:48:13 <qmm> what is this?
23:48:13 <qmm> type InitHandler a s = a -> Process (InitResult s)
23:48:29 <qmm> a type alias for a function which goes from a to Process (InitResult s)?
23:48:57 <qmm> if so, i didn't realize you could have type aliases for functions
23:49:21 <l_zzie> yep
23:49:42 <liste> qmm: yes, function types are just like any other types
23:49:51 <liste> you can have records of functions, newtypes of functions...
23:50:29 <liste> lists of functions etc
23:51:40 <tsahyt> functions of functions too.
23:52:17 <qmm> love it
23:52:19 <qmm> thanks :)
23:54:08 <qmm> how would this be a valid InitHandler? (\() -> init') -- where init' :: Process (InitResult (BlockingQueue a))
23:54:53 <qmm> seems to be a function which takes a single value and returns some value init' which is defined elsewhere (type signature included)
23:55:17 <qmm> i don't know why \() is used
23:55:35 <qmm> \_ _ -> would have made more sense i think
23:56:08 <tsahyt> probably to indicate in types that the parameter isn't important
23:56:21 <Theophane> strange indeed
