00:11:11 <quchen> qmm: »\() -> x« is equivalent to »x«.
00:20:17 <lpaste_> halogenandtoast pasted “Error.hs” at http://lpaste.net/352266
00:21:08 <lpaste_> halogenandtoast revised “Error.hs”: “Error.hs” at http://lpaste.net/352266
00:21:19 <halogenandtoast> Can someone help me figure out why I'm getting that error?
00:22:09 <halogenandtoast> I'm just trying to make a "simple" http request (but I want to ignore non 200 responses)
00:24:15 <pavonia> What are the types of newManager and defaultManagerSettings?
00:24:20 <pavonia> halogenandtoast: ^
00:24:38 <halogenandtoast> `newManager :: ManagerSettings -> IO Manager`
00:24:49 <halogenandtoast> `defaultManagerSettings :: ManagerSettings`
00:24:50 <cocreature> halogenandtoast: could you show your imports?
00:25:46 <lpaste_> halogenandtoast revised “Error.hs”: “Error.hs” at http://lpaste.net/352266
00:25:53 <halogenandtoast> cocreature: Added
00:26:05 <lyxia> looks like you might be confusing newManager with the one here https://hackage.haskell.org/package/http-conduit-2.2.3/docs/Network-HTTP-Client-Conduit.html#v:newManager
00:26:09 <cocreature> halogenandtoast: newManager in http-conduit has a different type
00:26:14 <cocreature> the same goes for httpLbs
00:26:41 <cinimod> What is wrong with ircbrowse?
00:26:58 <quchen> cinimod: Maintenance or something?
00:27:23 <cocreature> maybe drop chris an email?
00:27:38 <cocreature> (depending on how long it is showing that error)
00:27:49 <halogenandtoast> So basically what you're saying is it's using function from two different modules.
00:28:01 <cocreature> halogenandtoast: no it is only using the functions from http-conduit
00:28:02 <halogenandtoast> Instead of both being from Conduit or both being from Http.Client
00:28:09 <cinimod> cocreature: it's been showing 403 for several days
00:28:23 <cocreature> halogenandtoast: you are just using the functions from http-conduit as if they were the functions from http-client which results in those errors
00:28:42 <cocreature> cinimod: his mail address is on http://chrisdone.com/
00:29:51 <cinimod> quchen, cocreature: thanks
00:31:11 <quchen> cinimod: It’s a website by Chris Done, if the error persists we could just ask him.
00:48:45 <halogenandtoast> cocreature: sorry I stepped away. Are you familer enough with conduit to tell me what I'm doing wrong, I don't see a difference in the interface.
00:49:24 <athan> I think the socket-unix library's README is out of date: http://hackage.haskell.org/package/socket-unix - kinda
00:49:40 <cocreature> halogenandtoast: take a look at the docs https://hackage.haskell.org/package/http-conduit-2.2.3/docs/Network-HTTP-Client-Conduit.html#v:newManager "newManager" does not take a setting argument
00:50:12 <halogenandtoast> Oh!
00:50:33 <athan> `socket` should be able to be used, because the Unix type level symbol has instances for both Family and Protocol... but I don't really know what a `socket :: IO (Socket Unix Stream Unix)` would mean
00:50:57 <athan> I can imagine it as a family, but not a protocol :s i don't know anything about domain sockets though
00:51:04 <halogenandtoast> Wow I feel dumb. I even read that and for some reason assumed I still had to pass in the defaults
00:51:11 <athan> are they just line-terminated or something, through stdin/stdout?
00:52:04 <coot> Hi, I need some help with `stack ghci`: I am trying to step through psc (PureScript) in ghci but the `stack ghci` fails in `Purescript/PSString.hs` module: No instance for `A.ToJSON Text` arising from a `A.toJSON`
00:53:32 <halogenandtoast> Theanks cocreature 
00:54:53 <halogenandtoast> s/Theanks/Thanks/
00:57:41 <joneshf-laptop> coot, Is the capitalization correct in your error message?
00:59:19 <coot> joneshf-laptop: yes: no instance of `ToJSON Text` from using `toJSON`
01:19:25 <merijn> byorgey: ah, monoid-extras is exactly what I was looking for :)
01:28:25 <erisco> there are possibly cases where a parameter is relevant and for simplicity the same polymorphic type is used everywhere
01:28:33 <erisco> oh I was way scrolled up, heh
01:37:22 <rewsd> hi! does anyone have any experience in using FRP to keep track of large amounts of data? my application has 10 000+ different things that would be tracked by the FRP system, how well would this work in practice? 
01:38:57 <liste> rewsd: do those values form a graph of dependencies of sorts?
01:41:45 <srhb> Does anyone know of a nice library to connect to a text/event-stream source and stream the events through aeson?
01:42:54 <cocreature> srhb: I’m not quite sure if I’m understanding your question correctly but there is a "pipes-aeson" library so if you manage to get your text/event-stream source as a pipes Producer, you could use that
01:43:29 <srhb> cocreature: That sounds like a reasonable approach. :)
01:44:03 <srhb> Though I'm not sure if there's a nice http pipes client library, I usually go to the conduit based ones. Ah well, can probably figure out something there.
01:44:25 <cocreature> srhb: there is https://hackage.haskell.org/package/pipes-http :)
01:45:01 <cocreature> srhb: you could also use a conduit attoparsec library and use aeson via that
01:45:44 <rewsd> liste: yes, at least to some extent. I have a bunch of nodes that don't change, but a lot of different values or "boxes of content" getting added or deleted, or moving between these nodes
01:48:53 <srhb> cocreature: Perhaps I'll try both and figure out which I like more. :-)
01:49:51 <rewsd> oh, and I forgot to mention, but this supposed to be the business logic for a web server and needs to have a constant uptime. I haven't looked too deeply at FRP yet, so not sure how it performs wrt. e.g. memory over a long period of time, but I'm assuming that part will be okay 
02:01:01 <davean> rewsd: I use FRP as the conceptualization for a website framework
02:02:13 <davean> rewsd: Specificly, https://code.xkrd.net/davean/ALON
02:07:00 <rewsd> davean: I'll take a look at your source. have you done any tests to see how well the application runs with large amounts of data?
02:07:21 <giry> hi
02:07:23 <giry> list!
02:07:36 <davean> define large, your "10000" is entirely unclear - also it isn't really important how many, but how they're composed
02:15:38 <davean> rewsd: well, i'm going to bed
02:15:50 <rewsd> daevean, as my understanding of FRP is (correct me if I've misunderstood), you assign Events or Behaviours to different sources you want to keep track of, for example keyboard input, or the state of some data structure. i.e. the player character in a game, or the state of a prompt in a GUI application. In my case I have some 10000 Haskell records that would have to respond to Events. as I understand your 
02:15:56 <rewsd> case, you track things such as whether or not static files are found in a folder, so I guess what I meant is if there are any limits to the amount of different data sources that can send events. again, please excuse my ignorance when it comes to RP
02:16:44 <rewsd> oh, allright! have a good night! :)
02:25:30 <merijn> @ask byorgey I'm preparing some additions for monoid-extras, do you have any targets w.r.t. which GHCs to support?
02:25:30 <lambdabot> Consider it noted.
02:40:25 <merijn> hmmm, I wonder why we haven't expanded Enum to have "safeToEnum :: Int -> Maybe a", this would drastically make my live easier :\
02:41:34 <merijn> Because as far as I can tell there's no way to write a Bounded instance that adds a single element "after" the last enum from some other type, as there's no way in the Enum to find the highest possible value of a type
02:42:56 <bitonic> merijn: well, if you add a `Bounded` constraint you can
02:43:15 <merijn> bitonic: Right, but I'm trying to write a Enum instance for a newtype wrapper
02:43:33 <merijn> bitonic: And if I add the Bounded constraint it won't work for any type that's not Bounded
02:43:40 <bitonic> merijn: Yeah what I'm saying is that you might have to do `instance (Bounded a) => Enum (Foo a)`
02:43:43 <bitonic> Yep
02:44:13 <merijn> bitonic: The problem is basically that we have a single Enum, rather than one for Bounded and one for unbounded, it's a mess
02:44:52 <bitonic> merijn: or, you could do `safeToEnum n = unsafePerformIO (catch (return (Just (toEnum n))) (\_ -> return Nothing))` :P
02:45:23 <merijn> bitonic: Except that doesn't work, because 'error' leaks out of the catch due to laziness
02:45:43 <bitonic> merijn: ah yes, add an evaluate
02:46:38 <bitonic> I was sort of joking anyway, I don't think that's a good idea unless you're in trouble
02:47:35 <merijn> bitonic: Yes, I'm trying to figure out a more reasonable solution...
02:48:31 <Profpatsch> Is there a way to make sure all fields of a record are used in a function?
02:48:53 <merijn> Profpatsch: Doubt it?
02:48:56 <bitonic> Profpatsch: as a caller?
02:49:24 <Profpatsch> As in data Foo = Foo { a :: Int, b :: Text }
02:49:40 <Profpatsch> foo Foo{..} = show a
02:49:52 <Profpatsch> Warning: field b not used
02:50:19 <merijn> Profpatsch: Well, with -Wall if you don't use wildcards you'd get that warning
02:50:30 <merijn> Profpatsch: But then you don't get a warning for not writing out all fields
02:51:03 <Profpatsch> The problem is if a new field appears (as is often the case in business data)
02:51:20 <Profpatsch> You insert it but don’t get a warning in e.g. render functions.
02:52:13 <bitonic> Profpatsch: yeah, sadly you cannot do that. The best you can do is to use normal pattern matching, but that's inconvenient
02:52:40 <bitonic> Since 1. reordering of fields will break your matches 2. you cannot grep uses of the fields
02:52:54 <bitonic> To be fair that's a pretty uncommon features in languages, although I agree with you that it would be useful
02:53:24 <nut> I'm testing with the Snowball library. main = interact (stem English)
02:53:35 <Profpatsch> It would be neat to integrate that into RecordWildCards.
02:53:41 <nut> but I don't get the stemmed word.
02:53:51 <Profpatsch> Maybe as an annotation
02:54:07 <nut> Could anyone take a look?
02:54:17 <Profpatsch> Foo{..{-#CheckFields#-}}
02:54:39 <bitonic> Profpatsch: yeah, it's not a bad idea, although I think a `-f` flag would probably be better
02:54:50 <bitonic> `-fwarn-unused-wildcards` or whatever
02:54:52 <merijn> bitonic: I think I could do this with CtxtIf, but I doubt that dependency will be accepted :\
02:55:20 <bitonic> merijn: so you assume `fromEnum` is total if the type is not an instance of `Bounded`?
02:55:21 <Profpatsch> bitonic: Yeah, but sometimes you want it and sometimes you don't
02:55:24 <bitonic> What is this for?
02:55:28 <bitonic> (to merijn)
02:55:34 <bitonic> Profpatsch: I think I'd want it always
02:55:38 <bitonic> If you're using wildcards, use everything
02:55:43 <Profpatsch> Right!
02:55:44 <bitonic> Otherwise, use NamedRecordPuns
02:55:48 <merijn> bitonic: Trying to write Enum for Data.Monoid.Inf
02:55:51 <bitonic> NamedFieldPuns
02:56:38 <Profpatsch> bitonic: That’s so cool, we should create a GHC ticket.
02:56:48 <Profpatsch> I’ve been wanting that since forever.
02:57:07 <bitonic> merijn: is that a good idea though? I don't know
02:57:13 <bitonic> It'd be a pretty counter-intuitive instance
02:57:39 <bitonic> What would `toEnum (Infinity :: Inf Pos Integer)`?
02:57:43 <merijn> bitonic: Why's that? You just want it to match the existing enum but with Infinity as first (or last) element
02:58:01 <bitonic> merijn: right but I'm not sure how that would work for non-Bounded types
02:58:21 <bitonic> You could always use 0 as \top or \bot
02:58:26 <bitonic> and then bump all the others
02:58:38 <merijn> bitonic: For unbounded types you can never reach Infinity anyway
02:58:53 <merijn> bitonic: For Inf Pos you'd expect Infinity to be the last enum for a bounded value
02:59:03 <merijn> Enum as a class is fucked up anyway
02:59:16 <bitonic> merijn: what I'm saying is that maybe the Bounded constraint is warranted anyway
02:59:17 <bitonic> In this case
02:59:24 <merijn> Since it requires 'fromEnum :: a -> Int' which is silly
02:59:56 <merijn> maybe...
03:00:08 <bitonic> I mean there is nothing wrong with `Inf Pos Integer` anyway
03:00:38 <bitonic> And you can write an `Enum` instance -- jut set `toEnum Infinity = 0`, bump all positives, decrease all negatives
03:00:46 <merijn> Could write fromEnum to do index "enumFrom (toEnum 0) ++ [Infinity]"
03:00:50 <bitonic> But it's an arbitrary choice
03:01:04 <merijn> bitonic: No, that's a silly instance
03:01:28 <merijn> Positive infinity should not be enumerated before actual values
03:01:28 <bitonic> merijn: ah wait, does `Enum` need to respect `Ord`?
03:01:40 <merijn> bitonic: Does it? No. Should it? Yes.
03:02:26 <bitonic> Then I don't think the `Bounded` constraint is overly restrictive. How would you write the instance manually for `Enum (Inf Pos Integer)` anyway?
03:03:23 <merijn> bitonic: Well, isn't that the exact thing I'm complaining about? The fact that Enum is defined in a stupid way
03:03:31 <Profpatsch> Couldn't match type ‘Text’ with ‘HtmlT Identity ()’
03:03:32 <merijn> We should have a different class for bounded and unbounded types
03:03:40 <Profpatsch> Which is the Actual which is the Expected?
03:03:50 <Profpatsch> Those varying error messages are driving me crazy.
03:03:58 <bitonic> merijn: sure, but at least now we have an idea on how to write `Enum` for `Inf`
03:04:13 <bitonic> Profpatsch: it tells you right below "expected type" "actual type"
03:04:58 <Profpatsch> bitonic: Nope, not with functional dependencies.
03:05:04 <Profpatsch> arising from a functional dependency between constraints:
03:05:57 <bitonic> Profpatsch: Okay. Then usually the first one is the expected and the second the actual
03:06:08 <bitonic> But I'm not sure here. I'd just stare at the code and find out what's wrong :P
03:07:38 <Profpatsch> Yeah, since Blaze got lawful Monad implementations recently maybe it’s better to switch back. Lucid’s extreme overloading is driving me mad.
03:08:02 <Profpatsch> The compiler simply can’t generate very good error messages with so much magic going on.
03:09:14 <Profpatsch> Ah, forgot one toHtml
03:12:06 <lyndon> Hey #haskell
03:12:14 <lyndon> In https://hackage.haskell.org/package/network-uri-static-0.1.0.0/docs/src/Network-URI-Static.html#staticURI
03:12:23 <lyndon> What's the deal with the "||" in the quasiquotes?
03:12:33 <lyndon> I can't find any real documentation on it.
03:14:41 <bitonic> lyndon: it's typed template Haskell
03:15:40 <lyndon> !
03:16:19 <lyndon> bitonic: that snuck under my radar
03:17:09 <bitonic> lyndon: ehe. If you grep for [|| in <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#template-haskell> you'll find references to it
03:17:36 <lyndon> And it doesn't even require a language extension besides regular template haskell! Amazing.
03:23:54 <merijn> Typed TH is amazing :)
03:25:04 <lyndon> Btw, how would you modify that source to remove the orphan instances?
03:25:23 <lyndon> Newtype wrappers seem to get in the way of the QuasiQuoter
03:32:01 <muzzle> hi
03:32:07 <systadmin> hello
03:32:17 <muzzle> I have a question about a performance problem in an application for my thesis
03:32:41 <muzzle> the application builds a very large in-memory index (10s of gigabytes)
03:32:46 <muzzle> and uses it for search
03:32:46 <systadmin> ?
03:32:55 <muzzle> but it's getting slow with large indices
03:32:59 <muzzle> and certain search settings
03:33:09 <muzzle> and I don't know how to go about pinpointing the problem
03:33:14 <muzzle> memory usage is as expected
03:33:22 <muzzle> but it just takes forever to search
03:33:26 <muzzle> and I can't figure out why
03:33:37 <muzzle> when I profile small examples everything looks OK
03:33:47 <muzzle> but I can't use the profiler on large examples
03:33:51 <muzzle> because it's too slow
03:34:08 <muzzle> does anyone have an idea what I can do here?
03:35:39 <quchen> More details are necessary to answer this question.
03:35:46 <quchen> Like what data structure your index is.
03:36:05 <muzzle> My index is a suffix tree
03:36:29 <muzzle> a very large one
03:37:04 <muzzle> which I use for a string-matching algorithm
03:37:12 <muzzle> which should theoretically be running in similar time
03:37:32 <muzzle> *linear time
03:37:56 <muzzle> and then I do some post-processing on the results
03:39:44 <muzzle> which should again not be terribly slow
03:40:08 <muzzle> the problem is just that I'm completely stumped on what part of the code could be the culprit
03:40:56 <muzzle> and I can't really take measurements with the profiler because building a large index with profiling enabled is just too slow
03:41:16 <muzzle> and so far I was unsucessful at building a small(ish) example with which the problem occurs
03:41:41 <muzzle> So what can I do to find badly performing parts of my source code without profiling?
03:44:33 <insitu> muzzle could it be that you are hitting performance issues because of laziness of your data structure?
03:45:09 <insitu> when index is small, evaluating thunk is fast but when the structure gets very large you incur an increasing penalty
03:45:53 <insitu> to run deep thunks and then garbage collect intermediate results?
03:46:03 <muzzle> insitu I don't think so, I made my index data structure an instance of NFData and use deepseq do force it to be completely evaluated
03:50:11 <insitu> maybe you can bench (and profile) specific parts of your code? 
03:53:04 <Profpatsch> > editor with color coding of do-blocks.
03:53:07 <lambdabot>  <hint>:1:26: error: parse error on input ‘of’
03:53:45 <Profpatsch> Each monad context gets a different Color (similar contexts get similar colors?)
04:02:34 <michalrus> Hey, what would be the best way to encode an (errors xor (value + warnings)) monad?
04:08:10 <lyxia> data Output = OError Error | OValue Value Warnings
04:10:39 <michalrus> And define the ops myself? I hoped there already was something like that, seems useful. =)
04:12:14 <lyxia> michalrus: Either Error (Warnings, Value)
04:13:04 <lyxia> michalrus: actually it's hard to say what is "best" without knowing what you want to do.
04:13:53 <michalrus> Still, I’d have to write a function to append warnings, hmm. How about a Writer instead of (,)?
04:14:26 <michalrus> lyxia: I’d want to be able to transform the value, and append warnings along the way. Or sometimes shortcircuit with an error.
04:15:30 <lyxia> A Writer sounds good
04:17:54 <unknown121> hi
04:18:49 <unknown121> what is best hacking forums in world ?
04:19:40 <unknown121> alooo ???
04:19:54 <hpc> go to reddit and ask for the 4chans
04:20:34 <tfc> i want to write a tcp network application, where i use parsec (or similar) in order to elegantly parse and process network packages. does anyone know of a nice example just to get going how stuff is combined? the library documentations don't give me an idea how to combine a parser with sockets elegantly.
04:21:33 <Profpatsch> Is “formatting” the only printf-like package that supports outputting to Text?
04:21:42 <unknown121> socket programming is your mean ?
04:44:19 <srhb> So with ResumableSource I'm confused on how to incrementally parse something from http conduit. In fact, I'm not sure what I want is incremental parsing, but I have something like responseBody response $$++ conduitParser events. The question is now, how do I attach an eventProcessor (something like Event -> IO ...) in this flow?
04:52:29 <srhb> I guess my question is, how do I split the [Event] up into individual Event in the conduit?
04:52:40 <srhb> Something like mapM_ yield...
04:59:12 <ocharles> Can anyone help me work out wtf is going on with my `cabal repl` here?
04:59:15 <ocharles> https://www.irccloud.com/pastebin/TsUVsvs4/
04:59:57 <ocharles> `private :: Int` in Application.Aws, but it's not in exports. So I need Application.Aws interpreted, so I can access non-exported symbols. I get that much. What I don't get is why :add * is giving me a completely useless error
05:00:38 <ondraa> hello. Let `type FilePath = String`, let Path be a type, instance of IsString, let f : Path -> Path and fp : FilePath. Then `f fp` does not typecheck (expects Path, actual is FilePath). How can I go around this?
05:03:23 <Myrl-saki> ondraa: `let g : FilePath -> Path` ?
05:05:03 <kubbe> Hi guys! How can I return a random INT between 1 and 20? I have tried importing System.Random and then use the randomRIO (1,20) but it doesnt work.
05:06:05 <AndreasK> kubbe: What exactly doesn't work
05:06:08 <Freundlich> kubbe: Doesn't work?
05:06:26 <kubbe> 2 seconds, Im gonna put it in a pastebin
05:06:27 <ondraa> Myrl-saki: how do I define g then? Without the call to the fromString implemented for Path as the library I use does not export it.
05:07:10 <kubbe> AndreasK Freundlich http://pastebin.com/3vD9HtKv
05:07:31 <Myrl-saki> Hmmm
05:07:35 <ondraa> here's the example in code http://lpaste.net/352274
05:07:53 <Myrl-saki> kubbe: `main = randomRIO(1,20)`
05:08:00 <kubbe> it cant compile in GHCI, it says its: "Parse error: naked expression blablablba"
05:08:04 <AndreasK> I'm trying to use the GHC Api to get the AST for some haskell code, however pretty much all of the api requires DynFlags, is there an easy way to construct default dynflags?
05:08:04 <kubbe> oh. Alright!
05:08:31 <Myrl-saki> ondraa: `g (Path s) = s`?
05:09:06 <Myrl-saki> ondraa: OverloadedStrings don't make any IsString instance be usable as String.
05:09:36 <Myrl-saki> ondraa: It means anything that can be parsed as a String can be compile-time made into an IsString instance. Correct me if I made an imprecise statement.
05:10:16 <kubbe> Myrl-saki, it cant compile when I try that. GHCI gives me the worlds longest error message
05:10:24 <yaxu> Hello, wondering if there's an easy way to 'compress' haskell? Particularly to remove unnecessary whitespace to help playing code golf (in this case writing music for tidalbot - http://twitter.com/tidalbot)
05:10:49 <Reisen> Is it possible to do this: http://stackoverflow.com/a/3467806 -- but with types using GADT's and type families?
05:11:01 <Myrl-saki> kubbe: How exactly are you using it?
05:11:13 <Myrl-saki> kubbe: In reality, you'd do something like..
05:11:53 <AndreasK> main is expecting type "IO ()" not "IO a" I think
05:12:41 <Myrl-saki> AndreasK: Oh. I thought main is IO a? ._.
05:12:53 <kubbe> When i import System.Random I can compile it and get a random int directly in GHCI. But i want to use it in a function.
05:12:56 <Myrl-saki> I tried it out myself, and it seems to be a type error.
05:12:58 <Myrl-saki> Err
05:13:01 <kubbe> Can I convert a randomRIO into a INT?
05:13:04 <Myrl-saki> A type prediction error
05:13:05 <Myrl-saki> whatsoever.
05:13:14 <AndreasK> main :: IO () yep
05:13:16 <Myrl-saki> kubbe: Yes.
05:13:29 <Myrl-saki> kubbe: `randomRIO (1,20) :: IO Int`
05:14:09 <Myrl-saki> AndreasK: https://ideone.com/Z4oRVT
05:14:13 <Myrl-saki> kubbe: ^
05:14:14 <kubbe> oh, well thanks. This should solve the problem!
05:14:28 <Myrl-saki> AndreasK: `main :: IO Int`
05:14:39 <ondraa> Myrl-saki: this choice of `g` changes the problem to Expected: Path, actual ByteString :- / (this is the Path http://hackage.haskell.org/package/libmpd-0.9.0.6/docs/Network-MPD.html#t:Path)
05:14:40 <Myrl-saki> I wonder if I can use this to return error codes though.
05:15:08 <ondraa> Myrl-saki: thanks for the OverloadedStrings explanation
05:15:26 <kubbe> Myrl-saki what does the last line do? The one 'randomRIO (1,30)'. After the last print where you add the x and y?
05:15:38 <Myrl-saki> kubbe: That was for AndreasK.
05:15:49 <AndreasK> I guess IO () was just the default then
05:15:52 <kubbe> Oh! Nvm then :)
05:16:00 <Myrl-saki> kubbe: Though, that's how you can specify that randomRIO (x,y) to retun an IO Int.
05:16:11 <ondraa> Myrl-saki: moreover this `g` requires me to know how Path is implemented inside the library, which I would preferably like to avoid
05:16:21 <Myrl-saki> ondraa: Right.
05:16:38 <Myrl-saki> ondraa: Hmmm. Can you show me what you're working on so far?
05:18:10 <kubbe> Myrl-saki, this is the function that instead of giving me 4 I want a random INT between 1 and 20. : http://pastebin.com/igBynjrZ
05:18:35 <Myrl-saki> kubbe: Ah. This one's easy then. :(
05:18:37 <Myrl-saki> :)*
05:18:53 <kubbe> There is more code than this ofcourse, and I have imported system.random already. Should I save each and every random in 3 different variables?
05:18:57 <Myrl-saki> kubbe: There are many ways to approach to this.
05:19:16 <Myrl-saki> One is the `x <- randomRIO (1,20)` ... thing.
05:19:45 <Myrl-saki> kubbe: Do you know how to use monadic style already?
05:20:06 <kubbe> I am not sure what monadic style is.. so I say maybe!
05:20:18 <Myrl-saki> kubbe: Okay. Do you know how to use do-notation?
05:20:58 <kubbe> the do-notation is what we are supposed to get to know after this class!
05:21:15 <Myrl-saki> kubbe: That's... weird.
05:21:22 <Myrl-saki> kubbe: Hmmm.
05:21:32 <Myrl-saki> kubbe: Did your teacher teach you about applicatives and functors already?
05:21:52 <kubbe> the complete assignment is to modify the Nim-game, and one of the modifications is to get random amount of stones at each pile. random between 1 and 20
05:21:54 <Myrl-saki> Since for sanity purposes, we'd use do-notation to generate something into a tuple.
05:21:58 <kubbe> yes, more or less
05:22:40 <Myrl-saki> kubbe: Oh. Chances are, you're not supposed to generate the 3 numbers in one go.
05:23:45 <kubbe> Maybe! But I think I got a solution that works now. I did like you said with the "x<- randomRIO(1,20)...."
05:23:47 <Myrl-saki> kubbe: You can use `(,,) <$> randomRIO (1,20) <*> randomRIO (1,20) <*> randomRIO (1,20)` to actually generate 3 random numbers in 1 go without using do-notation though. But that's ugly and probably not what your teacher's looking for. :P
05:24:14 <kubbe> Haha yeah. This is the thing I made : http://pastebin.com/i6WMRdfR
05:24:28 <Myrl-saki> kubbe: Mhm. Good job.
05:24:49 <Myrl-saki> kubbe: Is GameState = (Int, Int, Int)?
05:25:03 <kubbe> Thank you for your help! Yes it is
05:25:17 <Profpatsch> Hm, when I’m in LoggingT IO a, can I run one action with (MonadLogger m) in NoLoggingT?
05:25:34 <Myrl-saki> kubbe: Then you don't have to put the IO Ints.
05:25:37 <Profpatsch> I’m certain it’s possible, but I can’t wrap my head around it.
05:25:59 <kubbe> Oh, yeah i noticed now that I got error on that part. It cant match the types IO Int with INT
05:26:24 <Myrl-saki> kubbe: Mhm. IO Int is an "IO action that returns an int"
05:27:11 <Myrl-saki> kubbe: Think of the difference between `random() and random` in other languages. random() will return a random number while random will result in 4.
05:27:28 <kubbe> Yeah alright
05:28:20 <ondraa_> Myrl-saki: Oh, I realized the problem is in a different place. I had two conflicting claims about types in the code but GHC assumed one is correct and deduced the other is wrong. What I actually want is to change the first claim. 
05:28:33 <ondraa_> Myrl-saki: thank you for your help!
05:29:07 <Myrl-saki> ondraa_: Oh. Hahaha. Glad to hear it's fixed.
05:31:01 <kubbe> Myrl-saki, I took away the IO Int from my randomRIO and it works. But why does it work? And now when I am trying to use the randomRIO in a different location it doesnt work. Let me give you the example
05:32:06 <Myrl-saki> kubbe: No need. I get the idea why.
05:32:12 <Myrl-saki> kubbe: Thing is, numbers are unique.
05:32:14 <Profpatsch> Myrl-saki: My brain auto-corrected your nick to “Miyazaki” on first glance
05:32:29 <Myrl-saki> Profpatsch: That'd be awesome since I'm learning how to draw!
05:32:45 <Profpatsch> But can you learn how to Ghibli?
05:32:48 <Myrl-saki> kubbe: Numbers can manifest into any numerical type.
05:33:01 <Myrl-saki> Profpatsch: Nope, but so far, my necks are broken so I can shaft.
05:33:41 <Myrl-saki> kubbe: So basically, it gets confused as to which code will be used. For Floats, Ints, etc.
05:34:38 <Profpatsch> Myrl-saki: I hope that brings you money for special FX, so you can ufotable it up a bit.
05:34:45 <kubbe> Ohh.. alright! No wonder this get pretty confusing when learning this. Let me give you another example
05:35:12 <Myrl-saki> kubbe: Mhm. It's kinda funny when type inferrence is what makes you confused.
05:35:32 <Myrl-saki> kubbe: I think it happens to anyone no matterh ow long they've used Hs.
05:35:50 <kubbe> Myrl-saki, so in this code when the computer is supposed to make its move I want it to move a random int from 1 to 3.. http://pastebin.com/555Ykker
05:35:56 <kubbe> Hahah okey!
05:35:59 <Myrl-saki> Profpatsch: Or I could learn more structural parts and make mechs and give it a bit of sunrise.
05:36:37 <Profpatsch> Yeah, that would make your popularity A-1-explode, I’m sure of it.
05:36:56 <Myrl-saki> Profpatsch: Aaand I'm out of studios. xD
05:37:36 <Profpatsch> So much potential left. :)
05:38:00 <Myrl-saki> Profpatsch: I'm not a fan of looking at studios. More of authors. :P
05:38:15 <Myrl-saki> kubbe: to move a random int from 1 to 3?
05:38:59 <kubbe> yes!
05:39:16 <Myrl-saki> kubbe: What do you mean by that?
05:40:49 <kubbe> Oh.. So the computer is supposed to be locked to only move 1 to 3 stones from the pile. Therefore a random between (1,3) instead of a, b or c
05:41:07 <Profpatsch> Myrl-saki: https://www.youtube.com/watch?v=bpQK9SA9Hhw
05:41:11 <Profpatsch> You might enjoy that.
05:42:07 <Myrl-saki> Profpatsch: I'll take a look at it in a day or two. Internet got cut off and I'm using my mobile plan.
05:43:45 <Myrl-saki> kubbe: Welp. At least you've learned something in advance. xD
05:48:09 <kubbe> Haha, you got that right. Well the solution we handed in was approved
05:48:30 <kubbe> Thank you for your assistance Myrl-saki, much appricieted
05:48:36 <Myrl-saki> kubbe: Great. I guess I'm going to sleep now. Night~
05:48:44 <Myrl-saki> kubbe: Glad to know I've helped.
05:49:25 <mniip> hey kubbe 
05:50:16 <Profpatsch> Argh.
05:50:27 <Profpatsch> Anyone versed with monad-logger?
05:50:49 <Profpatsch> How do I supress logging output of a sub-task?
05:51:17 <Profpatsch> I have something like               runSqlNoLog = Log.filterLogger (\_ _ -> False) . runSql
05:51:41 <Profpatsch> But it still dumps all inserts to the command line.
05:52:41 <kubbe> mniip, whats up mate!
05:53:38 <kubbe> Btw guys. In this game I have I want to submit a "quit"-function. So it is possible for the player to quit the game and not continue playing after a game. How can I terminate a program without having to clsoe GHCI
05:54:15 <Myrl-saki> :t exit
05:54:17 <lambdabot> error: Variable not in scope: exit
05:54:29 <Myrl-saki> :t exitWith
05:54:31 <lambdabot> error: Variable not in scope: exitWith
05:54:35 <Myrl-saki> Ehhhh
05:54:47 <Myrl-saki> Nyeh. I forgot the type.
05:54:55 <Myrl-saki> kubbe: Check hoogle, it's a great resource.
05:55:26 <kubbe> Alright! Thanks
05:56:23 <Myrl-saki> Apparently, exitWith is correct. https://www.haskell.org/hoogle/?hoogle=exitWith
06:00:00 <kubbe> Hmm, alright! Okey :) Look at this: http://pastebin.com/KTVYaGP3
06:00:37 <kubbe> in the gamestate, atm only when the player has won I want to ask the player if he/she stills wants to play. If yes; run main. else: quit the game
06:01:37 <byorgey> merijn: re: GHC support for monoid-extras, at least 7.8+.  I think currently Travis-CI tests it back to 7.6
06:02:39 <merijn> byorgey: I'm asking because I noticed: "minimum xs = P.minimum (Infinity : map Finite xs)"
06:02:58 <merijn> byorgey: Seems like that'd be asymptotically faster using "minimum = P.minimum . (Infinity:) . coerce"
06:03:06 <merijn> oh, wait
06:03:08 <merijn> I'm dumb
06:03:14 <merijn> It's not a newtype xD
06:03:24 <byorgey> merijn: nope =)
06:04:10 <byorgey> merijn: I don't think it would be asymptotically faster anyway, it would still hae to traverse the list
06:04:15 <byorgey> *have
06:04:28 <merijn> Semi-related, anyone know if I can delete a branch from a repo on github?
06:04:35 <merijn> (from the web, that is)
06:05:07 <byorgey> merijn: hmm, I don't know if there's any way to do it via the web interface
06:05:12 <byorgey> I know how to do it from the command line.
06:05:25 <merijn> byorgey: I'm not using git, hence the problem :p
06:05:50 <byorgey> how do you have a repo on github if you're not using git?
06:06:05 <merijn> byorgey: Mercurial's wonderful bidirectional git-bridge :)
06:06:21 <kubbe> nvm, I solved it with it just returning (). It works since the main is defined main :: IO ()
06:06:38 <byorgey> merijn: oh, you can.  click on "branches" in the little bar at the top (commits ... branches ... releases ... etc.)
06:06:47 <merijn> byorgey: Yeah, I found it :)
06:06:47 <byorgey> merijn: then there are little trash can icons next to each branch
06:06:53 <byorgey> great =)
06:07:12 <byorgey> ah, mercurial git-bridge, cool
06:07:57 <merijn> byorgey: https://github.com/diagrams/monoid-extras/pull/30 Those should all be uncontroversial, I think.
06:08:11 <byorgey> merijn: great, thanks, I'll have a look soon
06:08:32 <merijn> I'd have liked an Enum instance too, but I don't see a way to reasonable properly handle both bounded and unbounded enums
06:10:48 <byorgey> merijn: hmm, the Num/Fractional/Floating instances seem fishy.  I'll have to think through them more carefully.  What do you use those for?
06:12:56 <merijn> byorgey: I'm trying to keep track of upper and lower bounds which I update incrementally so I just end up writing "(+5)", which I suppose could also be "fmap (+5)" but these instances behave the same as, say, Double arithmetic
06:13:05 <merijn> > ((1/0) :: Double)
06:13:07 <lambdabot>  Infinity
06:13:10 <merijn> > ((1/0) :: Double) + 2
06:13:12 <lambdabot>  Infinity
06:14:21 <byorgey> merijn: well, no, that's the problem, they don't behave exactly the same.  For example:
06:14:29 <byorgey> > (-(1/0) :: Double) * (-(1/0))
06:14:32 <lambdabot>  Infinity
06:14:52 <byorgey> but for NegInf the instance you gave would give Infinity * Infinity = Infinity
06:14:58 <merijn> hmmm, I suppose
06:15:15 <merijn> byorgey: I had it in my code because I was using Infinity as undefined, rather than infinity
06:15:30 <merijn> I'm not particularly married to the Num instance if there's a functor
06:15:42 <byorgey> OK, I'll think about it some more
06:17:46 <c_wraith> doesn't countable infinite * countable infinity = countable infinity?
06:18:21 <merijn> c_wraith: His point is that Infinity for NegInf is negative infinity, so it's sign should flip
06:18:30 <c_wraith> Ah
06:18:31 <merijn> Since -inf * -inf = +inf in IEEE754
06:19:47 <merijn> Is there an easy way to compute the number of (decimal) digits required to display an Int64? Or should I fromIntegral and logBase it as a Double?
06:20:11 <mniip> length . show?
06:20:42 <Masterhacker2004> Hey
06:20:43 <merijn> mniip: That's a rather bad way of doing it... :p
06:21:06 <mniip> only computed once if you do it right
06:21:22 <mniip> and, tbf, could be worse
06:21:30 <sqrt2> there won't be a way without taking a logarithm, whether explicitly or implicitly
06:21:45 <mniip> logarithming it is prone to rounding and off by one errors
06:21:56 <byorgey> merijn: http://www.hedonisticlearning.com/posts/find-first-set.html   ;-)  (probably overkill)
06:22:00 <mniip> length.show is concise and clear in what it does
06:22:01 <sqrt2> mniip: you only need one digit of accuracy, so that's not the problem
06:22:06 <c_wraith> Int64 isn't that big.  You can just have a table of points at which the number of digits increases
06:22:21 <mniip> sqrt2, 100000 vs 99999
06:22:22 <c_wraith> Fortunately, the table is easy to create.  10, 100, 1000, ... :)
06:22:25 <byorgey> though I guess that's *binary* logarithm and you want decimal.
06:22:31 <merijn> byorgey: Seems like it'd be considerably slower than just logbase :p
06:22:40 <mniip> one could be rounded into the other, and the floor of the logarithm would change
06:23:05 <sqrt2> mniip: double still has plenty of significant digits
06:23:22 <mniip> not enough for Int64
06:23:30 <byorgey> merijn: agreed =)
06:25:42 <mniip> any of ya folk good with CT?
06:25:53 <merijn> mniip: Probably? ;)
06:26:19 <Masterhacker2004> I am good at counterterroist ye
06:26:20 <mniip> shameless crossposting #2
06:26:21 <mniip> 1486629679 [11:41:19] <mniip> what does the umlaut-arrow denote exactly? 1486629740 [11:42:20] <mniip> the definition of an extranatural transformation implies two profunctors, however I'm seeing it being used as  codomain object -> functor
06:26:33 <sqrt2> in experiment, i can distinguish 10^19 and 10^19-1 using a double
06:26:52 <byorgey> mniip: usually I have seen an arrow with two dots used to indicate a dinatural transformation
06:26:52 <mniip> sqrt2, that is very weird
06:26:59 <merijn> sqrt2: Doubles are accurate up to 2^53
06:27:04 <mniip> byorgey, I'm fairly sure this is an extranatural?
06:27:07 <merijn> sqrt2: After that they lose accuracy
06:27:14 <merijn> > 10^19
06:27:17 <lambdabot>  10000000000000000000
06:27:25 <merijn> > 2^53
06:27:28 <lambdabot>  9007199254740992
06:27:34 <mniip> > 10^19-1
06:27:36 <lambdabot>  9999999999999999999
06:27:39 <mniip> > 10^19-1 :: Double
06:27:42 <lambdabot>  1.0e19
06:27:48 <merijn> Probably got lucky there
06:27:48 <sqrt2> ah, damnit, i mistyped
06:28:24 <byorgey> mniip: extranatural is a special case of dinatural, I think
06:28:30 <mniip> oh?
06:28:41 <byorgey> that's what nlab says at least =)
06:28:42 <mniip> I got the idea of it being something completely different
06:29:35 <byorgey> https://ncatlab.org/nlab/show/dinatural+transformation
06:31:18 <mniip> dinatural is more general than natural too
06:31:36 <byorgey> yes
06:32:39 <merijn> byorgey: Also, the docs of Inf could use a reminder of which is which. I keep having to open the source and look at the Ord implementation to figure out which is which
06:32:59 <mniip> or not
06:33:19 <byorgey> merijn: good idea.  Could you either make a PR or open an issue so I won't forget?
06:33:22 <mniip> a DT is not an NT in the functor-from-product sense
06:33:28 <mniip> but you can encode an NT with a DT
06:33:46 <mniip> if you make the ^op part of the functor a constant functor
06:34:08 <byorgey> merijn: re: your Int64 question, if I were you I would just implement an integer logarithm function.  e.g. see https://bonsaicode.wordpress.com/2010/05/07/programming-praxis-integer-logarithms/
06:34:17 <mniip> then S(c', c) = S(c, c)
06:34:24 <mniip> S(f, 1) = 1
06:34:33 <mniip> and that gets you an NT on the remaining parts of the diagram
06:34:44 <byorgey> mniip: right
06:35:00 <merijn> byorgey: done
06:36:41 <merijn> byorgey: Seems like a hassle compared to "floor . logBase 10 . (+1) . fromIntegral" :) I'm not too worried about possible discrepancies since 1) I expect most/all values to be rather small and 2) I'm trying to determine rough bounds on max request size, so being off by a few bytes isn't that big an issue
06:37:41 <byorgey> merijn: OK, sure, if you don't care about potential inaccuracy then I agree logBase 10 is a better solution.  I thought you cared about it being accurate.
06:38:44 <merijn> byorgey: Just "mostly", trying to figure out how many id's I can squeeze into a single HTTP request by doing exponential increase + binary search, if I'm off by a few bytes and need to redo the request...*shrug*
06:39:00 <zennist> Hi anyone familiar with the yesod/persistent library can shed some light on how to do testing with data layer built on top of that?
06:39:12 <mniip> so a DT is, roughly,
06:39:13 <mniip> forall a. p a a -> q a a
06:39:18 <mniip> for profunctors p and q
06:39:45 <merijn> mniip: DT as in dependent type? Or is that an ambiguous acronym?
06:39:54 <mniip> dinatural transformation
06:41:11 <zennist> notably, I'd like to implement my 'impure' web services such that all the logic in pure - and the data related impure code expressed in persist could be tested but with minimal test footprint
06:41:20 <mniip> and an extranatural is like
06:41:27 <mniip> forall a b. p a a -> q b b
06:41:44 <mniip> for profunctors (possibly differntly kinded) p and q
06:43:09 <byorgey> mniip: that's exactly what a DT is.  I'm not so sure of your analogy for extranatural.  Though to be fair I'm less familiar with them than I am with dinatural.
06:43:25 <mniip> dinatural is "simple enough"
06:43:40 <c_wraith> man, I have so much trouble with CT diagrams, compared to haskell types...
06:43:52 <merijn> c_wraith: Join the club
06:44:11 <c_wraith> I guess CT ideas are always more general than their simplest expression as a haskell type.
06:44:57 <byorgey> c_wraith: yes.  In fact, one can say something stronger: CT ideas are always more general than your current most general understanding of them.
06:45:07 <c_wraith> :)
06:45:16 <mniip> not all CT ideas are exxpressible
06:45:17 <mniip> in haskell
06:45:34 <mniip> I'm learning pure CT because I realized that Hask limits your understanding
06:45:42 <mniip> pretty much in the same way as Set does
06:45:50 <mniip> they're very similar after all
06:45:53 <merijn> byorgey: My problem is usually that many people explaining things about CT seem to arbitrary drop "irrelevant" parts of the category their discussing
06:45:58 <merijn> Which always trips me up
06:46:11 <merijn> Additionally, they fail to point out things which are, to me, not obvious
06:46:22 <merijn> Such as the notion that morphisms have an identity
06:46:38 <mniip> e.g, can you express a Kernel in haskell?
06:46:51 <byorgey> merijn: yes, I know what you mean.
06:47:03 <mniip> much simpler, can you express a null morphism in haskell
06:47:06 <merijn> Even the programmer friendly ones like Bartosz'
06:48:07 <mrkgnao> merijn: I just looked at weechat and had my mental parser hang on Bartosz'
06:48:28 <mrkgnao> I have been trying to make sense of pipes for the last couple hours, which may be relevant
06:48:32 <lpaste_> scipianus pasted “Functor instance” at http://lpaste.net/352276
06:48:52 <zennist> okay reading through the doc in persistent lib I feel like there is significant leakage of state related code expressed in 'impure' mode - e.g., you can use persistent's defined 'update' actions to update data in database but obviously this is going to make it hard to test this transition with randomly generated pure data
06:48:55 <mniip> scipianus, are you aware that you can't say that
06:48:57 <maksim_> i'm having trouble figuring out exactly (precisely) what's happening here because i don't know how bind is defined for io http://pastebin.com/nWePKyae
06:49:22 <scipianus> can somebody help me with this? http://lpaste.net/352276 which should be the way to make Audit instance of Functor?
06:49:27 <maksim_> i understand that filterM basically filters over a list but with side effects
06:49:34 <c_wraith> scipianus: you can't make type aliases instances.
06:49:41 <zennist> can someone recommend an approach of persisting data such that there is good compatibility outside haskell (e.g., database) && there is strong separation between pure logic code and things that only deal with storing
06:49:45 <c_wraith> scipianus: (with some weird exceptions around String)
06:49:45 <mniip> :t filterM -- maksim_: does this type signature explain the function?
06:49:47 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
06:50:05 <maksim_> mniip, yes i understand the semantics completely 
06:50:22 <scipianus> c_wraith : I should make Audit data or class?
06:50:39 <c_wraith> scipianus: data seems best.  data Audit a = Audit a String
06:50:58 <maksim_> mniip, i would like to understand the >>= thoroughly
06:51:11 <byorgey> maksim_: it's just filtering the list, but testing each element of the list may have some I/O effects
06:51:24 <maksim_> byorgey, yes i understand that 
06:51:27 <mrkgnao> is there anyone here who's experienced with pipes? I'm looking at some code that uses it, but I'm not sure if there have been any improvements to the library since that it doesn't use
06:51:27 <mniip> @do getRecursiveContents path >>= filterM check
06:51:27 <lambdabot> do { a <- getRecursiveContents path; filterM check a}
06:51:39 <mniip> is this clearer?
06:51:52 <mrkgnao> https://github.com/BartAdv/pipes-game/blob/master/test.hs if anyone would like to have a look
06:51:53 <maksim_> you just sugared >>=
06:51:56 <mniip> yes
06:51:58 <byorgey> maksim_: I'm not sure what you're confused about then, there's really nothing to understand beyond that
06:52:08 <mniip> what he said ^
06:52:10 <c_wraith> maksim_: do you want to know what >>= does for a specific type, or in general?
06:52:20 <byorgey> maksim_: I don't see how understanding how >>= is defined for I/O would help
06:52:28 <c_wraith> maksim_: because in general, all you know about >>= is what the monad laws and its type tell you.
06:52:35 <mrkgnao> also, is simulating FRP-ish things (which to me means something like event-driven programming) with pipes a good idea?
06:53:03 <merijn> mrkgnao: Not really, FRP is really not anything like pipes
06:53:07 <maksim_> i see many functions. i would like to know what each one of them does exactly
06:53:13 <maksim_> getRecursiveContents is a function
06:53:15 <merijn> mrkgnao: FRP is also not really related to event-driven either
06:53:15 <maksim_> i know what it does
06:53:17 <c_wraith> mrkgnao: pipes is fundamentally pull-based.  event-driven usually means push-based.
06:53:21 <maksim_> check is a function
06:53:23 <maksim_> i know what it does
06:53:32 <BartAdv> mrkgnao: that code you looking at was essentially my exploration to answer similar questions
06:53:37 <maksim_> >>= is a function whose operation i'm not clear on
06:53:38 <merijn> c_wraith: That's not true
06:53:40 <maksim_> same for filterM
06:53:46 <merijn> c_wraith: pipes has both push and pull based
06:53:49 <mrkgnao> BartAdv: whoa, didn't expect this coming
06:53:58 <merijn> c_wraith: Are you perhaps conflating pipes and conduit?
06:54:00 <maksim_> any other time i'm interested in what a function does i go and i look up its implementation
06:54:11 <c_wraith> merijn: oh, does it?  I was assuming it worked the same way as machines and conduit, yes.
06:54:15 <byorgey> maksim_: >>= for IO  runs its first argument, then passes its output as input to the second argument, then runs the resulting IO action
06:54:23 <mrkgnao> I actually planned to play around with your code. did you find it a bad idea?
06:54:32 <BartAdv> mind that I know very little about pipes and maybe I shouldn't even put that on github, it was really just learning experience
06:54:39 <merijn> c_wraith: pipes actually explicitly tracks push vs pull, it's why I prefer it to conduit
06:54:59 <BartAdv> I don't even recall how it went, was probably result of some overnight/early morning hacks
06:54:59 <byorgey> maksim_: does that help?
06:55:01 <scipianus> c_wraith : and after having some parameterized data type, how do i make instance of Functor ?
06:55:04 <c_wraith> merijn: ie, the combinators you use to hook things together determine whether it uses push or pull?
06:55:05 <mrkgnao> merijn: could you take a look at the link? I'm interested in what someone experienced with pipes thinks
06:55:11 <maksim_> byorgey, yes but i have a follow up question
06:55:37 <Eduard_Munteanu> Does WAI allow the request body to be streamed? I recall Yesod didn't.
06:55:44 <c_wraith> scipianus: Overall, I'd say you should figure this out on your own.  I can give you hints, but I think you'd learn a lot from not being handed a full solution.
06:56:08 <maksim_> byorgey, " then runs the resulting IO action" which exactly is the resulting IO action? the entire composition or, here for example `filterM check contents`
06:56:12 <Welkin> scipianus: instance Functor MyDataType a where fmap f (MyDataType a b) = MyDataType a (f b)
06:56:26 <c_wraith> scipianus: start with the what are given, and what you need.  What are the arguments to fmap?  What are their types?  What type does the result need to be?
06:56:28 <Welkin> something like that
06:56:39 <byorgey> maksim_: filterM check contents
06:56:58 <byorgey> maksim_: generally,  x >>= f  means 'run x, call its output a, then run (f a)'
06:57:25 <byorgey> (For IO specifically.)
06:57:58 <maksim_> byorgey, `output` doesn't mean output right? it means a in IO a?
06:58:00 <merijn> c_wraith: Yeah, see for example https://hackage.haskell.org/package/pipes-4.3.2/docs/Pipes-Core.html#g:5
06:58:34 <Welkin> maksim_: the `a` in `Monad m => m a`
06:58:35 <byorgey> maksim_: yes, the a in IO a.  You're right, output is probably a bad word.  How about 'result'.
06:58:52 <maksim_> yes. i was thinking produce
06:58:56 <merijn> mrkgnao: Which link?
06:59:28 <byorgey> maksim_: as for filterM, you can indeed look up its implementation
06:59:48 <byorgey> but of course it is implemented in terms of >>=
06:59:58 <mrkgnao> merijn: https://github.com/BartAdv/pipes-game/blob/master/test.hs
07:00:17 <merijn> mrkgnao: fwiw, I'm not that experiences with pipes either
07:00:23 <c_wraith> Was filterM not changed to only require an Applicative instance?
07:00:41 <Welkin> I was reading up on logic symbols last night, and it seems that `=>` is used as a lambda function arrow instead of haskell's `->`. Why is that?
07:01:07 <Tuplanolla> That's weird, Welkin.
07:01:13 <Welkin> is it similar to the arbitrary decision of swapping (:) and (::)?
07:01:20 <c_wraith> Welkin: "logic" is underspecified.  It can mean many different things with many different symbol sets.
07:01:33 <Tuplanolla> I've seen mathematicians mostly use |-> for anonymous functions.
07:01:36 <mrkgnao> hm, jle`'s auto looks pretty interesting.
07:01:42 <Welkin> yeah, I've seen that one too Tuplanolla 
07:01:44 <maksim_> thank byorgey
07:01:47 <maksim_> *thanks
07:02:18 <Welkin> in my abstract algebra book from maclane is uses |->
07:02:26 <c_wraith> Ah.  In recent versions of GHC, filterM does in fact only require Applicative
07:03:25 <merijn> mrkgnao: This looks more like something along the lines of FRP than something really suited to pipes
07:04:05 <mrkgnao> merijn: I see.
07:05:06 <Welkin> mrkgnao: I keep thinking "mr magoo" when I see your name
07:05:12 <mniip> ok, I think I pieced the definition together http://mathb.in/126509
07:05:13 <mrkgnao> So what I'm trying to do right now is make a game server with an API that people can connect bots to. It's all the rage nowadays.
07:05:29 <Welkin> and then I imagine you are a short bald man with his eyes closed tightly
07:06:39 <mrkgnao> I plan to think of the internet-connected bit later, and just implement the game bit now while doing it so that going to the server model won't require huge amounts of refactoring
07:07:02 <BartAdv> merijn, mrkgnao yes. This is what led me eventually to learn FRP and nowadays I'd just choose FRP for things like that
07:07:38 <Welkin> lol
07:07:40 <merijn> mrkgnao: I could see using pipes to turn a network connection into a sequence of events that you then feed to an FRP framework, though
07:07:43 <Welkin> trying to build a game using pipes?
07:07:56 <Welkin> pipes is only for streaming data
07:08:06 <Tuplanolla> What a coincidence. I just built a server too, mrkgnao.
07:08:32 <mrkgnao> Welkin: https://en.wikiquote.org/wiki/Ulysses_(novel), Ctrl-F my username. I haven't out-PageRank-ed Joyce yet :)
07:08:35 <Tuplanolla> Although the usual happened and I got lost in abstracting modules and elevating everything to the type level.
07:08:45 <mrkgnao> Tuplanolla: the usual indeed
07:09:20 <mrkgnao> inevitably to end in large-scale kill-buffer-rudely and "Idris or nothing from now on" declarations
07:09:23 <Tuplanolla> It's more educational anyway.
07:09:39 <mrkgnao> merijn, Welkin: what do you think of auto?
07:09:41 <mrkgnao> , auto
07:09:47 <mniip> merijn, so back to my question
07:09:51 <Welkin> I haven't read about it in probably 2 years
07:09:58 <Welkin> but yeah, jle's blog is good
07:10:01 <mniip> we have a whatever transformation between 2 profunctors
07:10:02 <mrkgnao> I should learn how to use lambdabot properly
07:10:07 <mrkgnao> ,auto
07:10:12 <mniip> what does "x -''-> S" mean
07:10:14 <Welkin> @where auto
07:10:15 <lambdabot> I know nothing about auto.
07:10:23 <mniip> where x \in Ob(Cod(S))
07:10:27 <merijn> mniip: oh, I'm not the right person to ask CT questions, I just said the *someone* here probably is :p
07:10:49 <mrkgnao> is FRP "active", for lack of a better word?
07:11:04 <Welkin> mrkgnao: what do you mean?
07:11:15 <Welkin> there are many, many FRP libraries in haskell, all for different use cases
07:11:50 <mrkgnao> for whatever reason, I had this idea that nobody did FRP anymore, although I can't place why this ever came to be. :/
07:12:00 <Welkin> reflex is the most "pure" FRP library (in terms of fitting the formal definition of FRP)
07:12:14 <Welkin> mrkgnao: you can join #reflex-frp 
07:13:14 <mrkgnao> I'm really interested in a library that would a) be easy to integrate with, say, servant, and b) be easy to get help about
07:13:38 <Welkin> reflex is used with reflex-dom to build web front-ends
07:13:42 <Welkin> people have used it for games too
07:14:19 <mrkgnao> no, I mean a headless API backend thing that people send commands to. 
07:14:41 <Welkin> I'm not sure how that would work
07:14:46 <Welkin> you could ask in the other channel
07:15:05 <Welkin> I'm only familiar with the request -> response model for web servers over http
07:15:31 <Welkin> maybe using http2 or websockets you could do something here
07:15:34 <mrkgnao> is there a way to integrate reflex with servant?
07:15:41 <mrkgnao> I'm looking for something like that
07:15:47 <Welkin> dunno, go ahead and ask
07:15:48 <takanuva> shouldn't this work? http://pastebin.com/b419HiWT
07:15:58 <mrkgnao> or websockets, yeah. (I haven't thought this through, as you can see.)
07:16:02 <mrkgnao> yeah
07:16:17 <biglama> hi guys, I've read a small parser for reading and writing floats using megaparsec
07:16:32 <tsahyt> writing using megaparsec?
07:16:45 <biglama> i found the result to be slower than a dumb C++ program : 30s to manage a file of 190 000 lines
07:16:55 <biglama> yes, using megaparsec to write my parser
07:17:12 <biglama> but i could use some help with the profiling
07:17:14 <merijn> biglama: megaparsec isn't really optimised for speed, but for flexibility/quality of errors
07:17:25 <tsahyt> megaparsec is built to handle complex grammars and user-facing parsers with good error handling
07:17:29 <tsahyt> what you want is probably attoparsec
07:17:30 <merijn> biglama: i.e., for things like programming language
07:17:35 <Welkin> if you want speed, you want attoparsec
07:17:41 <Welkin> also, don't use String
07:17:44 <Welkin> instead use Text
07:17:49 <Welkin> if you want speed
07:17:53 <tsahyt> or even Data.Attoparsec.Zepto if it's really simple input
07:17:59 <merijn> ALso that
07:18:04 <merijn> String is awful for speed
07:18:08 <mrkgnao> Welkin: I imagine String is probably a far bigger problem than megaparsec
07:18:13 <merijn> Yeah
07:18:15 <mrkgnao> merijn: what FRP library do you use?
07:18:27 <merijn> Actually try that first, switch to Text, try again and then try attoparsec
07:18:40 <takanuva> could anyone please explain to my why the type variables couldn't be unified on my code? http://pastebin.com/b419HiWT
07:18:41 <biglama> okay thanks
07:19:55 <merijn> biglama: For some context, since String is literally a linked list of Char it uses ~24 bytes per letter on 64bit. Text uses ~2-4 bytes per letter plus a few bytes overhead every few kilobyte if using lazy Text)
07:20:04 <Welkin> takanuva: remove everything before the => (including the =>) in your instance declaration
07:20:19 <Welkin> you don't give the type when declaring an instance, only when defining the class
07:20:24 <merijn> And all the other cache downsides of linkedlists
07:21:10 <Welkin> or you can remove it on the class definition
07:21:16 <Eduard_Munteanu> Actually they probably want to remove the constraints on the class method.
07:21:17 <Welkin> try both, see what happens
07:21:24 <mniip> ooooohhh
07:21:31 <mniip> an extranatural transformation is just
07:21:37 <takanuva> Welkin: not my code, actually, I'm trying to help a friend, but I didn't understand the error; on the instance he's qualifying the type variables, as in instance Eq a => Eq (Foo a)... shouldn't it work?
07:21:40 <Profpatsch> Welkin: Every time I read your nick I’m reminded that I should finish Vakyria Chronicles some time.
07:21:42 <Welkin> (the constraints I mean)
07:21:57 <mniip> forall a b c d. (a -> b) -> (c -> d) -> p b a -> q c d
07:21:59 <mrkgnao> I often wonder why GHC couldn't internally nix String and replace it with Text under the hood, although you'd probably have to add special cases for head and such things 
07:22:17 <merijn> mrkgnao: Because they're suitable for entirely different things
07:22:19 <Welkin> Profpatsch: me too
07:22:19 <mniip> "ent id id" recovers the original eta
07:22:24 <Profpatsch> hehe
07:22:30 <mrkgnao> and end up reimplementing a String wrapper over Text
07:22:34 <merijn> mrkgnao: String is nice for easy matching and stream processing
07:22:40 <Eduard_Munteanu> mrkgnao, more likely ByteString than Text.
07:22:59 <merijn> mrkgnao: Incidentally, GHC *does* store literals as dense encodings and converts to String from there
07:23:02 <Eduard_Munteanu> POSIX things are bytestrings.
07:23:09 <mrkgnao> merijn: oh?
07:23:29 <mrkgnao> wow, reflex uses Nix
07:23:42 <merijn> mrkgnao: iso something encoded binary blobs which are dynamically turned into String. Text abuse this by having a rewrite rule that overwrites the conversion function and skips going through String
07:23:52 <merijn> mrkgnao: Which is what makes OverloadedStrings not suck
07:25:02 * mrkgnao is a little less sad for having left Arch behind and jumped ship entirely
07:25:15 <mrkgnao> merijn: that rewrite rule fact is cool.
07:25:48 <merijn> mrkgnao: Lots of cool stuff if you dive into the low level bits of GHC :)
07:26:02 <merijn> Just browsing GHC.Exts and ghc-prim package you can find lots of neat things
07:26:45 <mrkgnao> I actually wish to contribute to GHC someday, once I have something a little more real-world than this Chromebook :)
07:26:53 <jophish> I wonder how long it'll be until we have a better 'FilePath' in widespread usage...
07:26:57 <mrkgnao> merijn: what do you use for FRP?
07:27:09 <merijn> mrkgnao: I'm not really using FRP at the moment
07:27:25 <merijn> mrkgnao: I used netwire (obsoleted by wires, I think?) and reactive-banana
07:27:49 <biglama> merijn: I'm using Text.Megaparsec.ByteString.Lazy
07:27:50 <maksim_> why do you need $ here for the first argument of handle in saferFileSize http://stackoverflow.com/questions/10578572/the-handle-function-and-real-world-haskell (nevermind the question itself)
07:28:02 <biglama> merijn: so it should use bytestring internally and not string, right ?
07:28:18 <biglama> here is my profiling if anyone's interested http://pastebin.com/Ysi78FXT
07:28:51 <merijn> biglama: No clue, can you lpaste your parser?
07:29:08 <merijn> biglama: oh...
07:29:15 <kubbe> mniip, are you up for a bit of a challenge? :D
07:29:21 <merijn> biglama: You're using Read to convert to Double?
07:29:25 <Welkin> maksim_: what? You mean the $ before the `do`?
07:29:28 <merijn> biglama: Read has shit performance
07:29:28 <mniip> uhh
07:29:31 <maksim_> Welkin, yes
07:29:32 <mniip> I'm challenged myself
07:29:41 <Welkin> maksim_: that is just a replacement for parentheses
07:29:46 <Welkin> :t ($)
07:29:47 <lambdabot> (a -> b) -> a -> b
07:29:54 <Welkin> it is function application
07:30:04 <Welkin> it acts like parentheses in this case
07:30:07 <kubbe> Haha, that answer is good enough.. Alright so if its not to much of a problem, would you look at this: http://pastebin.com/AMPbytHt
07:30:45 <merijn> biglama: So, since that's the first line in your profile, I'm pretty sure that's the issue
07:30:50 <kubbe> My question here is: Is it possible to use my insert function and sort the list so that the lowest rank is at the beginning at all times?
07:30:52 <maksim_> Welkin, it wraps the do in parens?
07:31:32 <kubbe> Without a aux-function. Or do I need to create a sortfunction that will sort the values so that the lowest ranks is first? I want the least function just to take out the first value and it will be correct at all times.
07:31:50 <lpaste_> biglama pasted “Slow parsing ?” at http://lpaste.net/1806074898049662976
07:31:55 <Welkin> maksim_: yes
07:32:11 <biglama> merijn: here is my source code if you are kind enough to help me
07:32:24 <Welkin> no the `do`, but the `do` and everything right of it
07:32:25 <biglama> merijn: i'm not using read directly though
07:32:35 <merijn> biglama: That
07:32:47 <merijn> That's weird...dunno why readPrec is so high, then...
07:33:04 <merijn> oh...
07:33:09 <merijn> Megaparsec is using read...
07:33:21 <maksim_> Welkin, yes but from the signature i don't understand how that's the case. what is the (a->b) and what is the a in $ do ...
07:33:31 <mangobot> could someone give me a tip here please? there is an input string of the form: "b,b,b,b/b,b,b/b,,b,b/,,/w,w,bw,w/w,w,w/w,w,w,w w  e3-d4" which represents the gamestate (laska/ sort of checkers). b stands for black/w = white player. "," stands for another column, and slash for a new row. the "w" after space is next player and the tokens e3-d4 is the last move. is it possible to parse the string into a 2D list which will also conta
07:33:35 <mangobot> and the positions int int
07:34:23 <mangobot> and the iterate through the field ie somehow find the coordinates of each player, if the field is 7x7
07:35:45 <merijn> biglama: Yeah, I'd try switching to attoparsec and using Data.Attoparsec.Text.double
07:35:59 <merijn> biglama: attoparsec should (mostly) be a drop-in replacement for megaparsec
07:36:18 <BernhardPosselt> whats the usage difference between a reader monad and partial application?
07:37:04 <mniip> oh my
07:37:05 <biglama> merijn: thanks a bunch !
07:37:07 <mniip> I think I got it
07:37:08 <BernhardPosselt> is a reader DRYer for things needing the same type of parameter?
07:37:11 <mniip> wow this is deep
07:37:20 <biglama> merijn: do you think my code can be easily ported to attoparsec (at a glance) ?
07:37:29 <merijn> biglama: Yeah
07:37:33 <mniip> when we say that 'forall' is a kind of an end,
07:37:34 <Eduard_Munteanu> BernhardPosselt, you can only use the same type of parameter, anyway
07:37:40 <merijn> biglama: Like, if you're lucky you'd only have to replace the imports
07:37:55 <mniip> do we mean to interpret forall a. F(a) as a profunctor P(a, a)
07:37:59 <mniip> and take the end of that profunctor?
07:38:01 <merijn> biglama: attoparsec has almost the same design as parsec/megaparsec, so should be trivial to adapt
07:38:28 <BernhardPosselt> Eduard_Munteanu: i mean you could partially apply two functions which take a different type as their first parameter
07:38:32 <mniip> wow
07:38:43 <mniip> stunning
07:38:48 <BernhardPosselt> whereas i suppose for a reader you need the types to line up
07:39:42 <Eduard_Munteanu> BernhardPosselt, no... "a -> Reader r b" is like "a -> r -> b". It doesn't matter if you vary "a".
07:40:03 <BernhardPosselt> i see
07:40:17 <BartAdv> mrkgnao: you might want to check the https://github.com/BartAdv/hackslash
07:40:19 <Eduard_Munteanu> Because "a" is always explicitly applied.
07:40:28 <BartAdv> just another learning project of mine that I don't have time to finish ;)
07:41:35 <biglama> merijn: would be great :)
07:48:17 <mpickering> Has anyone had any success using the lz4 bindings to decompress externally compressed strings?
07:48:31 <mpickering> It seems they write some additional information into the bytestring 
07:48:52 <mpickering> which the decoding function then expects to be there
07:49:31 <maksim_> i don't understand $ with two argument functions; for `f:: a->b->c` how does f 1 $ \x -> 2 work?
07:49:56 <maksim_> actually
07:50:34 <maksim_> i don't understand $ with two argument functions; for `f:: a->IO b->IO c` how does `f 1 $ do return 2`  work?
07:50:38 <merijn> maksim_: "($) f x = f x", but because $ has extremely low precedence it effectively turns "f 1 $ ..." into "(f 1) ..."
07:51:24 <maksim_> so it creates a section of f?
07:51:37 <maksim_> and then applies it to `...`
07:51:37 <cocreature> no that’s not a section
07:51:42 <merijn> No, it just affects how applications are grouped
07:51:44 <cocreature> it’s just partial application
07:52:01 <cocreature> a -> IO b -> IO c is the same as a -> (IO b -> IO c)
07:52:02 <maksim_> what's the difference between a section and a partial application?
07:52:14 <merijn> I dislike the term partial application
07:52:27 <Eduard_Munteanu> f a b $ g c d  simply parses as   (f a b) (g c d)
07:52:33 <merijn> It doesn't make that much sense in anything other than an operational context
07:52:43 <maksim_> merijn, ah
07:53:06 <merijn> maksim_: "f :: a -> b -> c" is the same as "f :: a -> (b -> c)"
07:53:24 <merijn> maksim_: So if "x :: a" we get "f x :: b -> c"
07:53:41 <maksim_> okay
07:54:05 <Eduard_Munteanu> Similarly   f a b + g c d   parses as   (f a b) + (g c d).
07:54:13 <merijn> maksim_: So if "f :: a -> IO b -> IO c" and we have "f 1 :: IO b -> IO c"
07:55:32 <maksim_> to be concrete what is happening here? http://pastebin.com/c6pbA8Wt
07:55:59 <maksim_> to the left of $ we get a partial application of handle? then that partial application is applied to the do?
07:56:07 <merijn> maksim_: Yes
07:56:26 <merijn> maksim_: Remember that do is just syntactic sugar for a bunch of >>= and >> expressions
07:56:43 <maksim_> merijn, yes that's fine
07:56:51 <merijn> @undo do { h <- openFile path ReadMode; size <- hFileSize h; hClose h; return (Just size) }
07:56:52 <lambdabot> openFile path ReadMode >>= \ h -> hFileSize h >>= \ size -> hClose h >> return (Just size)
07:57:09 <maksim_> desugaring doesn't actually make it more readable
07:57:16 <merijn> maksim_: So it's basically just doing "handle (\_ -> return Nothing) (openFile path ReadMode >>= \ h -> hFileSize h >>= \ size -> hClose h >> return (Just size))
07:57:23 <maksim_> yes
07:57:25 <Welkin> @pl openFile path ReadMode >>= \ h -> hFileSize h >>= \ size -> hClose h >> return (Just size)
07:57:25 <lambdabot> liftM2 (>>=) hFileSize ((. (return . Just)) . (>>) . hClose) =<< openFile path ReadMode
07:57:28 <Welkin> lol
07:57:37 <merijn> Which, if you hate parentehesis could also be written "handle (\_ -> return Nothing) $ openFile path ReadMode >>= \ h -> hFileSize h >>= \ size -> hClose h >> return (Just size)
07:57:42 <Eduard_Munteanu> maksim_, it's the same thing if you wrap the whole do block in parens instead of $
07:57:56 <maksim_> yes that was clear from the beginning - the question was how exactly it was working
07:57:57 <Tuplanolla> What's the Haskell way to do `ioctl(fd, SIOCGIFINDEX, &ifr)`?
07:58:13 <maksim_> Eduard_Munteanu, it couldn't be anything else since handle takes two arguments
07:58:36 <Tuplanolla> I'm looking at sending raw network packets.
07:59:09 <merijn> maksim_: Well, ($) is literally defined like this:  "f $ x = f x" :) But because of the low precedence the 'f' part can be a compound expression, like 'handle (\_ -> return Nothing)'
07:59:21 <merijn> Tuplanolla: unix package?
07:59:42 <Tuplanolla> There's `System.Posix.IOCtl`, but the types seem incompatible, merijn.
07:59:47 <maksim_> merijn, yes. thank you for the explanation 
07:59:56 <merijn> Tuplanolla: In what way?
08:00:48 <sternmull> maksim_: see here for an easy to understand explanation of $: http://learnyouahaskell.com/higher-order-functions#function-application
08:01:06 <Tuplanolla> I need a file descriptor and a `struct ifreq` somehow.
08:01:06 <merijn> Tuplanolla: oh...that's an ugly/weird binding...
08:01:07 <mangobot> has anyone created a laska game in haskell by any chance?:)
08:02:03 <merijn> Tuplanolla: honestly, it might be easier to write your own wrapper for ioctl and call that?
08:02:29 <Tuplanolla> Surely someone has done this before.
08:02:41 <merijn> Tuplanolla: Presumably, but I'm not aware of where :)
08:02:43 <mpickering> How can I construct a Ptr Word8?
08:03:01 <merijn> mpickering: Foreign.C.Marshal.Alloc or whatever it's called?
08:03:02 <Eduard_Munteanu> Tuplanolla, can't you use raw sockets from 'network'?
08:03:10 <cocreature> mpickering: construct based on what? an integer representing the address?
08:03:31 <Tuplanolla> I thought I'm using those, Eduard_Munteanu.
08:03:39 <mpickering> well, I have no idea, this is probably the problem. 
08:03:42 <mpickering> I am trying to use this API https://hackage.haskell.org/package/lz4-0.2.3.1/docs/Codec-Compression-LZ4.html#v:c_LZ4_uncompress
08:03:46 <merijn> Tuplanolla: tbh, if you know enough C to write that example you gave it should be trivial to write, I've got an example for vtys
08:03:57 <merijn> Tuplanolla: https://github.com/merijn/posix-pty
08:05:09 <merijn> mpickering: You get Ptr Word8 by mallocing them :p
08:06:28 <Tuplanolla> That may be, merijn, but I don't really know or care how to deal with structures and constants.
08:07:16 <cocreature> mpickering: "allocaBytes" probably does the job
08:07:25 <merijn> Tuplanolla: Dealing with those on the haskell side is generally even more painful.
08:07:35 <cocreature> or "mallocBytes" but in that case you need to manually call free
08:07:42 <merijn> cocreature: Do you like stackoverflows? Because that's how you get stackoverflows...
08:08:20 <cocreature> merijn: hm?
08:08:51 <merijn> cocreature: Allocating a byte array on the stack for writing compressed data into seems like it invites every single classic stackoverflow exploit in existence
08:09:27 <cocreature> merijn: are you sure that newPinnedByteArray allocates on the stack?
08:09:43 <mpickering> This API is so foreign to me
08:09:51 <mpickering> and I also suspect this will cause problems as I am using ghcjs
08:09:54 <merijn> cocreature: hmmm, maybe allocaBytes is different from alloca I'm thinking off
08:10:17 <merijn> mpickering: oh...I'm not sure you can even get Ptr's using GHCjs
08:10:19 <cocreature> merijn: alloca just calls allocaBytes
08:10:32 <cocreature> merijn: are you talking about C alloca?
08:10:34 <mpickering> but I guess I can use javascript libraries somehow
08:10:47 <merijn> cocreature: alloca definitely suggest stack allocation
08:11:05 <cocreature> merijn: I would be really surprised if the Haskell "alloca" does stack allocation
08:11:19 <Tuplanolla> I'll just put this project on hold until someone comes up with a better `ioctl` binding.
08:11:20 <cocreature> but I’m happy to be proven wrong :)
08:21:03 <slx> join #clojure
08:21:10 <slx> whoops...
08:22:07 <Reisen> Is it possible to enable extentions on the command line with `stack runhaskell`? `stack runhaskell foo.hs -- -XTemplateHaskell` for example?
08:22:20 <Reisen> Can't seem to get anything to work
08:23:26 <sternmull> i think it is "stack runahskell -XTemplateHaskell foo.hs --" and arguments for your program after the --
08:24:03 <Reisen> I get invalid option trying to pass anything like that to stack though
08:26:05 <kgadek> tried --ghc-options -XTemplateHaskell ?
08:26:22 <Wizek> Hey! With GHC 8.0.2, is `{-# OPTIONS_GHC -fno-defer-out-of-scope-variables #-}` supposed to work on a file-by-file basis if in .cabal `-fdefer-type-errors` is specified? in my case the file-specific flag seems to be ignored.
08:28:04 <Reisen> kgadek, yeah, seems its not an available option with `runhaskell`
08:31:18 <kgadek> Reisen: this works for me: stack runhaskell -- -XTemplateHaskell
08:31:57 <kgadek> Reisen: which stack version?
08:32:09 <Reisen> Are you sure that's actually enabling the extension? Because when I try to use it in the file it doesn't work
08:32:17 <Reisen> 1.2.0
08:32:26 <kgadek> ohhh, I know
08:32:43 <kgadek> `stack runhaskell -- -XTemplateHaskell foo.hs`
08:32:53 <kgadek> foo.hs has to be after --
08:33:05 <kgadek> I have stack v1.3.2 fwiw
08:33:11 <Reisen> You're a king, thank you so much
08:33:14 <Reisen> That got it
08:33:14 <nut> with stack how to list all installed pacakges and their versions?
08:33:35 <CindyLinz> nut: stack list-dependencies
08:33:49 <CindyLinz> ... in a stack project's directory
08:33:57 <nut> i mean the global 
08:34:06 <nut> global package
08:35:30 <CindyLinz> no idea.. sorry
08:35:58 <nut> it's ok
08:48:25 <cocreature> nut: "stack exec ghc-pkg -- list" should work iirc
08:48:30 <srhb> nut: Something like stack exec ghc-pkg -- --list maybe
08:48:35 <srhb> Woops, too slow
08:48:50 <srhb> And wrong, too! :(
08:51:19 <reactormonk> So I've written https://stackoverflow.com/questions/42126267/compile-time-checked-uris/42126648 - how woud I write a test for it?
08:53:57 <nut> srhb: thx i think it works
08:56:14 <Rodenbach> I defined a tree like this:   data Tree a = Empty | Node { val :: a, left :: Tree a, right :: Tree a} deriving (Show, Read, Eq, Ord)
08:56:17 <Rodenbach> When I now create a   Node 100 Empty Empty    ghci prints   Node {val = 10, left = Empty, right = Empty}        – given a Node instance, how can I get the field names  "val", "left" and "right"?
08:56:47 <dima-h> hello everyone!!
09:00:06 <lienz> I'm looking for some advice about how to map a non-deterministic function over an (unboxed) array
09:00:25 <lienz> I'd like some sort of map function, of type (a -> Random b) -> Array a -> Random (Array b)
09:01:25 <lienz> at the moment I'm using repa, mostly because its support of multidimensional arrays makes it easy to work with
09:02:02 <cocreature> lienz: I don’t know anything about repa but generally these kind of functions are called "mapM"
09:02:38 <lienz> yeah I know that but repa doesn't have that, because IO messes with parallelisability
09:02:45 <lienz> repa has some "traverse" function (which is different from a traversable "traverse"), which I'm currently using to map my non-deterministic function over the array
09:03:16 <lienz> but to do that I'm using an unsafePerformIO
09:03:38 <lienz> ideally yeah, I'd want a mapM or a Data.Traversable.traverse
09:04:25 <eschnett> lienz: usually, random number generators are inherently serial, i.e. they cannot be parallelized
09:04:48 <eschnett> lienz: if so, you’d be stuck with generating a regular list of Random b, and than create a repa array from that
09:05:00 <benzrf> are there really any haskell solutions for presenting an interactive GUI for editing a tree, that come anywhere near the usability of mutable trees that support references to nodes?
09:05:38 <novakboskov> Hi everyone, I'm trying to reproduce foldl and foldl' from https://wiki.haskell.org/Foldr_Foldl_Foldl' and have no success. Both of them cause stack overflow with [1..10000000] and both produce result with one magnitude smaller list [1..1000000]...
09:05:49 <lienz> eschnett: but I don't really care about any kind of determinism; is there a way to initialise the various parallel threads with a seed and have them each do their thing?
09:06:08 <lienz> one issue is that I don't know ahead of time how many random numbers I'm going to need, so I can't generate random numbers in advance
09:06:18 <cocreature> novakboskov: what are the exact commands that you are using?
09:06:21 <mmachenry1> novakboskov: lpaste.net your code.
09:06:25 <cocreature> novakboskov: and where are you executing them?
09:07:16 <eschnett> lienz: yes, that’s possible. to get it right is non-trivial. i’d look for a library or an algorithm for doing so (initializing the threads). i don’t think that repa exposes an interface that allows you to access thread ids or so; repa assumes that each array element is calculated truly independently.
09:08:00 <novakboskov> mmachenry1: http://lpaste.net/352278 try3 and try4 do the same.
09:08:27 <ph88_> does ghc have an option for profile-guided optimization ?
09:09:17 <novakboskov> cocreature: I'm using GHCi through Stack (wiht Haskell mode from Emacs) resolver: lts-7.19
09:10:34 <ph88_> this looks very cool and haskell uses llvm too https://unhandledexpression.com/2016/04/14/using-llvm-pgo-in-rust/
09:10:35 <lienz> eschnett: ok thanks, I'll go searching in the hope of not having to write it myself
09:11:06 <lienz> I don't particularly mind if I have to use something other than repa, although I would rather avoid fiddling about with Vector to do multidimensional stuff (not that it is at all difficult, I just don't like it)
09:11:34 <cocreature> ph88_: afaik there is no such option
09:12:00 <eschnett> lienz: here’s a pedestrian approach (essentially what you suggested): (1) create a small (20?) random number generators, (2) each rng creates a plain list of values, (3) you combine these to a repa array
09:15:31 <mmachenry1> novakboskov: I didn't get a stack overflow running your code.
09:15:47 <mmachenry1> I reduce it to just the try4 test case.
09:18:21 <novakboskov> mmachenry1: make that list a little bigger. try2 should make stack overflow, it is discussed in the article on wiki
09:18:54 <novakboskov> mmachenry1: try3 also should make stack overflow
09:32:54 <alexv_> Is this family injective?
09:33:04 <alexv_> -- | N-ary function from @n@ arguments of type @t@ to value of type @o@.
09:33:09 <alexv_> type family NAry (n :: Nat) (t :: Type) (o :: Type) = (r :: Type) | r -> n t o where {
09:33:15 <alexv_> NAry 1 t o = t -> o
09:33:20 <alexv_> NAry n t o = t -> (NAry (n - 1) t o) }
09:55:01 <mniip> I always forget, is Hom internal and hom to Set?
09:55:05 <mniip> or is it vice versa
09:56:42 <mniip> yes I was correct
09:57:15 <krey> hey, I'm looking for a function Maybe (IO a) -> IO (Maybe a). does such a thing exist? hoogle didn't help
09:58:08 <kadoban> :t sequence :: Maybe (IO a) -> IO (Maybe a)
09:58:10 <lambdabot> Maybe (IO a) -> IO (Maybe a)
09:58:18 <kadoban> :t sequence
09:58:21 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
09:58:44 <kadoban> Hoogle doesn't do so good when what you want is more polymorphic than what you're asking for it seems.
09:59:03 <lc__> hoogle found sequence fine for me
09:59:13 <lc__> when searching for  Maybe (IO a) -> IO (Maybe a)
09:59:27 <kadoban> Oh
09:59:28 <lc__> https://www.haskell.org/hoogle/?hoogle=Maybe+%28IO+a%29+-%3E+IO+%28Maybe+a%29
09:59:38 <krey> kadoban: thanks
09:59:57 <krey> lc__: yes, this is actually my bad, I skipped that hit because it seemed like an unlikely name
10:00:21 <lc__> the fact that Maybe is Traversable is a good intuition to have
10:00:29 <lc__> it just has at most one element
10:01:09 <lc__> it means you can use it in forM and other things
10:01:20 <lc__> :t forM_
10:01:23 <lambdabot> (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
10:05:43 <mangustt> hi, is anyone familiar with the FEN notation?
10:17:10 <roxxik> mangustt: is that a chess thing?
10:21:50 <mangustt> roxxik yeah or this http://www.pjb.com.au/laska/play_laska.html
10:22:40 <mangustt> roxxik was just wondering if someone had an code example of parsin a FEN string (b,b,b,b/b,b,b/b,b,b,/,,/w,w,bw,w/w,w,w/w,w,w,w w g5-f4-e3)
10:23:42 <roxxik> this should be rather simple
10:23:56 <roxxik> but i don't have code for it
10:24:08 <roxxik> parsing is a real delight in haskell ;)
10:30:39 <ralu> mangustt: take a look at chesshs https://hackage.haskell.org/package/chesshs
10:41:48 <mangustt> ralu thanks, will do now
10:42:12 <mangustt> ralu i found a few examples but it was quite comprehensive and i didnt really get the idea behind the functions
10:44:54 <pie__> hi guys, anyone here have anything to do with program analysis / formal methods?
10:45:09 <pie__> im interested in the area and would like to know "wat do"
10:46:57 <ralu> pie__: do you have more specific questions in mind? 
10:47:22 <pie__> well y priary interest is reverse engineering, but im also interested in verification
10:47:34 <reactormonk> Got some -Werror here, any way I can supress the missing fields warning at a specific point?
10:47:35 <pie__> but i dont know anybody anywhere so i dont really know how to get into it
10:48:00 <pie__> *my
10:48:56 <pie__> i figured people here might be slightly more academically inclined and i might find someone here :P
10:53:32 <reactormonk> Is it possible to have stack add a certain library to all builds globally?
10:53:49 <reactormonk> ghci-pretty is nice to have everywhere.
10:56:42 <mangustt> ralu are you still here?:)
10:57:56 <ralu> mangustt: sure :D
10:58:59 <mangustt> ralu is there any chance you could help me understand this function better? http://lpaste.net/352280 i dont quite understand the recursion there in line 9
10:59:06 <Sonolin> is there a word for "translating" an object from one Data Type to another?
10:59:45 <mangustt> ralu http://sequence.complete.org/node/296 found here, but there is no really explanaiton:/
10:59:50 <mangustt> explanation *
10:59:52 <Sonolin> i.e. maybeToList "transates" a Maybe a value to a [a] value (for lack of better word..)
11:00:06 <lyxia> Sonolin: transform?
11:00:16 <Sonolin> that works, thanks lyxia
11:05:18 <shapr> delYsid``: you still writin Haskell?
11:07:22 <mnoonan> Sonolin: you might be after the notion of "natural transformation", too: https://lukepalmer.wordpress.com/2008/04/28/whats-a-natural-transformation/
11:10:12 <krey> lc__: weird, forM_ is exactly what I needed next!
11:11:59 <kadoban> Haha
11:13:20 <ralu> mangustt: about line 9 - is like : If last element in array is number, then pop this element and move position by x 
11:14:48 <Sonolin> that's actually quite helpful thanks mnoonan
11:21:34 <Tuplanolla> Is `cabal build` supposed to handle `.hsc` files automatically? It's not working for me.
11:24:15 <tsahyt> I'm pretty sure it should, yes
11:24:33 <tsahyt> as long as you have hsc2hs in your path at least
11:24:55 <Tuplanolla> It just says "Could not find module".
11:25:22 <tsahyt> it's listed in exposed-modules or other-modules?
11:25:28 <Tuplanolla> Neither.
11:25:35 <tsahyt> Well you need to have it there
11:26:38 <Tuplanolla> Those fields are not allowed for executables.
11:27:38 <tsahyt> other-modules is allowed for executables afaik
11:27:50 <Tuplanolla> Ah, yes. That one works.
11:28:13 <tsahyt> stack at least even gives a warning when you don't list something in there
11:29:07 <Tuplanolla> This should get me going. Thanks.
11:30:02 <mangustt> ralu ah thanks! got it
11:31:25 <mangustt> ralu can i ask you the last question? i googled it too, but the syntax is still not very clear: http://lpaste.net/352283 how does it compute the representation?:|
11:34:32 <geekosaur> the "representation" here is turning "a1" into [7,0]. google won't help you much there since it's a program specific representation
11:34:37 <wamaral> quick question on Aeson: I have the following `status <- (o .: "fields") >>= (.: "status") >>= (.:? "name")` and it works as expected. However, how do I handle the possibility of the "status" key not being present?
11:34:54 <monochrom> (7,0)
11:34:56 <geekosaur> although the comment is misleading in that case, *or* the code is incomplete
11:35:02 <geekosaur> er, yes
11:35:31 <ralu> aciic char is converted in number using integer (ord). Ascii arithmetics turns 'a' , 'b' , 'c' -> 0 , 1 , 2 .. and similarly for charaters '1' , '2' 
11:35:55 <tsahyt> since yesterday I've been wondering, how does AFRP work with event driven frameworks, say GTK?
11:36:28 <tsahyt> I've been looking at wires in particular, but afaik all AFRP frameworks basically run in a tight loop and aren't driven from an outside source of callbacks like say reactive-banana is
11:37:06 <tsahyt> otherwise AFRP seems like a very good fit for me to implement some audio stuff on top of JACK, for performance reasons
11:38:16 <zipper> WOW ethereum's "Bitcoin As A State Transition System" sounds like the state monad.
11:40:25 <monochrom> No I think it's the writer monad.
11:41:44 <zipper> monochrom: Is that so? I am not familiar with the writer monad :) I am eager to play with this.
11:42:07 <tsahyt> I suppose I could have a polling function that keeps trying to read an MVar and set up the callbacks via a thread that then puts something into that MVar
11:42:10 <zipper> Goddamn Writer monad is not in the book I have :(
11:42:13 <tsahyt> but that seems like a hilariously ugly solution
11:42:22 <zipper> bitemyapp: Give us the Writer monad :P
11:43:11 <monochrom> Bitcoin is a log rather than a state.
11:44:44 <cocreature> zipper: I think it’s deliberately left out. there are very few places where the writer monad is the appropriate thing to use. it tends to lead to space leaks
11:47:34 <zipper> cocreature: Are there prerequisites I should care about before looking at the Writer Monad?
11:47:37 <zipper> It seems there are
11:47:55 <cocreature> zipper: just pretend that it doesn’t exist and don’t use it :)
11:48:36 <monochrom> But then they won't understand my sentence.
11:49:12 <cocreature> well you can take a look at it, it’s simple enough
11:49:29 <MarcelineVQ> dohoho, iirc glguy had a neat use for it for one of his advent challenges so it may be worth asking him about it  related code somewhere within https://github.com/glguy/advent2016/tree/22525949821ba209465471796803c213abd00d15/asmprog-final
11:50:18 <zipper> monochrom: Yeah I want to use it :)
11:50:25 <zipper> cocreature: I do want to use it
11:50:31 <zipper> For this one purpose
11:51:17 <cocreature> zipper: if you are familiar with State, Reader and so on, I would recommend to just look at the source. there is very little magic going on
11:51:43 <cocreature> zipper: https://hackage.haskell.org/package/transformers-0.5.2.0/docs/src/Control.Monad.Trans.Writer.Strict.html#WriterT
11:52:14 <cocreature> the interesting part are the Applicative and Monad instances
11:54:10 <cocreature> but apart from learning purposes I really don’t recommend it. if you have a constant size monoid (e.g. Sum Int) you want it to be strict and if you have something that grows (e.g. logs represented as [Text]) you typically want to stream the results instead of accumulating all of them first
11:54:13 <zipper> hmmm thanks :grin:
11:54:38 <zipper> to stream the results?
11:54:42 <zipper> Like pipes?
11:54:54 <zipper> It would be a bytestring I think
11:55:23 <cocreature> zipper: yeah, http://www.haskellforall.com/2014/02/streaming-logging.html has an example that illustrates the problem with using Writer for logging and shows the pipes based solution
11:57:09 <zipper> cocreature: Thanks a ton :)
11:57:15 <zipper> Gonna have a look
11:57:32 <tsahyt> has anyone ever integrated an AFRP framework with GTK?
11:58:06 <tsahyt> hmm apparently yampasynth uses gtk, that might be worth a look
11:59:12 <tsahyt> ah, but it seems to not actually tie in the gtk events into yampa
12:00:00 <MarcelineVQ> "<zipper> bitemyapp: Give us the Writer monad :P" Writer is in that book zipper, it's just later on when you're taking about transformers
12:02:36 <mniip> dear CT overlords I summon thee
12:03:07 <monochrom> You know the overlords are in ##categorytheory right?
12:03:18 <mniip> that's usually silent :v
12:03:22 <monochrom> Or is that ##category?
12:03:40 <mniip> the latter does not exist
12:04:51 <mniip> I have strong evidence that the end of hom in Grp is the Z groupoid but I can't prove the universality...
12:21:12 <wamaral> If you don't mind slack, there's a #categorytheory channel on the functionalprogramming slack that gets pretty good activity
12:23:28 <mniip> considering I'm not using slack for anything it's pretty unlikely to gain any traction in my workflow :(
12:24:14 <sternmull> is it possible to write a zipNWidth function? I mean something that takes a tuple (of any size) of lists and applies a function to each tuple of nth elements.
12:25:06 <wamaral> oh well I use the IRC bridge so it feels like another server, but I'm not a big fan either
12:26:54 <monochrom> mniip: slack is not for workflow. This is because slack is for competing with IRC, and IRC is not for workflow either. If anything, both are for anti-workflow :)
12:28:00 <monochrom> IRC was my anti-workflow when I tried to work on my PhD
12:28:35 <nshepperd_> sternmull: you'll need a typeclass
12:29:28 <Tuplanolla> These type classes, sternmull: https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Tuple.html
12:29:36 <sternmull> nshepperd_: Thanks for that keyword. I think with my current knowledge i would be unable to express such a function.
12:30:45 <monochrom> You can't express its type to begin with.
12:31:39 <sternmull> Tuplanolla: Hm looks useful, but this is limited to nine fields.
12:32:01 <Tuplanolla> You're doing something rather questionable if nine isn't enough, sternmull.
12:33:11 <ph88> hey guys, when i have structures like   Foo (Wrap T) (Bar (Wrap T)) (Wrap (Qux T))   and i want to modify the last T  what would be a good technique to use ?
12:33:24 <sternmull> Tuplanolla: Not necessarily. It could be useful to write code that is completely generic and does not care how long the tuple is. In C++ templates can have integers as type parameters.
12:33:26 <monochrom> Add your own instances if you want 10 fields.
12:33:35 <Tuplanolla> More lenses, ph88. Lenses for everybody.
12:34:06 <ph88> Tuplanolla, what specific part of lenses? i think i would something generic no ?
12:35:03 <Tuplanolla> You'd `makeLenses` for each and let `lastT = qux . wrap`.
12:35:06 <cocreature> ph88: are these types or constructors? I think you need to give us a bit more information, i.e. show us the types and the constructors used here
12:35:38 <ph88> those are the types !
12:35:44 <Tuplanolla> Then `over lastT f x` where `f` is a function and `x` is some `Foo`.
12:36:22 <ph88> data Wrap a = W a       data T = MakeT StuffHere
12:37:09 <Tuplanolla> You'd have `data Wrap a = W {_wrap :: a}` etc.
12:37:13 <Sibi__> Am I missing something or is the type of `e` should be `Q Exp` in this old proposal: https://mail.haskell.org/pipermail/ghc-devs/2015-September/009838.html
12:37:40 <ph88> Tuplanolla, wouldn't this   lastT = qux . wrap   only work when you have a Qux and then a Wrap  ?
12:38:01 <Tuplanolla> Well, yes, it would become a `Traversal`, ph88.
12:38:24 <ph88> so hhmm then i would have to implement this function like 200 times ?
12:38:33 <Tuplanolla> I don't follow.
12:38:59 <ph88> well if one structure has   (Wrap (Qux T))   you want to use   lastT = qux . wrap   yes ?
12:39:49 <ph88> next structure has maybe    [(Maybe T)]    so i need a  lastT = last . (\Just x -> x)   ?
12:40:19 <ph88> that would be my backup plan ^^
12:40:56 <cocreature> ph88: do you want to map the T to a new T or do you want to change that type parameter as well?
12:41:04 <cocreature> in the first case, you can use biplate
12:41:19 <ph88> i want to change the value of T, and not change the type
12:42:05 <cocreature> :t transformBi
12:42:06 <lambdabot> error:
12:42:06 <lambdabot>     • Variable not in scope: transformBi
12:42:06 <lambdabot>     • Perhaps you meant one of these:
12:42:32 <cocreature> ph88: take a look at transformBi here https://hackage.haskell.org/package/uniplate-1.6.12/docs/Data-Generics-Uniplate-Operations.html
12:42:41 <ph88> i know it
12:43:00 <ph88> just not sure if it's a good fit
12:43:44 <ph88> ok well thanks guys for thinking along
12:44:31 <tsahyt> is there a way to have stack add extra-deps as it recommends automatically?
12:45:06 <MarcelineVQ> stack solver --update-config
12:45:18 <tsahyt> hmm that crashes with cabal errors
12:45:25 <tsahyt> failed to parse output of 'ghc-pkg dump'
12:45:53 <MarcelineVQ> what stack version?
12:46:05 <tsahyt> 1.3.2
12:47:40 <MarcelineVQ> ah hmm, do you have cabal-install? stack needs that for it's solver afaik
12:52:18 <Tuplanolla> This cursed `hsc2hs` is nothing but trouble. Now it complains that a structure is undeclared even though it's right there.
12:52:19 <sternmull> i have a local stack "thingy" (don't know what it is called when you initialize it in a directory). In there i can not import System.Random. If i do it in a normal non-stack ghci i can import it. Do have have to declare System.Random as dependency in .cabal? I thought it is a standard package...
12:55:37 <sternmull> ah, ok. Had to add "random" to the build-depends. Shouldn't have asked so fast...
12:57:51 <tsahyt> MarcelineVQ: I should have it, but there might be a version problem
12:59:17 <tsahyt> sternmull: you need to declare all packages that you use in the cabal file, regardless of whether they are "standard" or not, even including base.
12:59:51 <sternmull> tsahyt: ok.
13:01:24 <Tuplanolla> Looks like I need to enable C11 for `hsc2hs` somehow.
13:03:57 <Tuplanolla> How do I tell `cabal` to tell `hsc2hs` to tell `gcc` to use `-std=c11`?
13:05:12 <tsahyt> Tuplanolla: gcc-options or so
13:05:19 <tsahyt> or cc-options
13:07:20 <Tuplanolla> Looks like `gcc` can find the definitions when called alone, but not through `hsc2hs`.
13:13:27 <bollu> what's the wildest type system that you guys know of? I've seen dependant typing and linear types, as well as structural typing. Are there others?
13:13:37 <geekosaur> hsc2hs-options: --cflag=-std=c++11
13:13:39 <geekosaur> or w/e
13:13:55 <geekosaur> Tuplanolla, ^
13:14:36 <merijn> Hah...that delightful moment where you dread writing some complicated code, only to realise it turns into a trivial handful of lines because Haskell is awesome :D
13:15:19 <Tuplanolla> That didn't help either, but removing `#{alignment ...}` did, geekosaur. It seems to be broken somehow.
13:15:21 <geekosaur> bollu, can't talk about wildest, but row types are another variety
13:15:23 <bollu> merijn: what were you coding?
13:15:36 <bollu> geekosaur: that is like Go, right?
13:15:43 <kadoban> bollu: Wildest? Does python count?
13:15:45 <geekosaur> and like sql
13:16:01 <bollu> kadoban: like, "sensible and interesting", not "fucked up"
13:16:10 <merijn> bollu: A mechanism that automatically determined the maximum request supported by the remote host by exponentially increasing until failure, then doing binary search
13:16:28 <bollu> merijn: and how did you code said thing? what's the code like? :) 
13:16:37 <bollu> right now I'm reading about fractional and negaitve type
13:16:39 <bollu> types*
13:16:44 <kadoban> :)
13:16:50 <merijn> bollu: Well, I realised it basically devolves into two simple nested conduit loops :p
13:16:53 <bollu> I'm a man with a solution (SAT solvers) in search of a problem (type system) 
13:17:07 <merijn> bollu: One to track maximum request size, the other to incrementally build request of that size
13:17:16 <merijn> and just use exception to deal with failure
13:17:21 <bollu> merijn: I see, interesting!
13:17:32 <merijn> bollu: You're not the first to apply SAT solvers to type systems
13:17:34 <EvanR> bollu: type systems are invented continually, each paper defines a new type system to present what its talking about
13:17:41 <mniip> bollu, system F-omega with explicit kind coercions?
13:17:41 <merijn> bollu: See the work on GHC's Nat kind
13:17:50 <bollu> merijn: I suppose I am not. Do you have references to older stuff?
13:17:54 <bollu> merijn: oh, interesting!
13:18:00 <merijn> bollu: LiquidHaskell too, afaik?
13:18:02 <bollu> mniip: go on. Isn't F-w undecidable?
13:18:15 <bollu> merijn: liquidHaskell is SMT, no? It uses it for more stuff
13:18:18 <mniip> oops
13:18:20 <mniip> not F-omega
13:18:22 <mniip> FC
13:18:28 <merijn> bollu: not sure
13:18:40 <bollu> mniip: what is that? I'm not "truly educated" in type systems :)
13:18:58 <mniip> have you seen 8.0's TypeInType yet?
13:19:02 <bollu> mniip: nope
13:19:07 <mniip> well
13:19:25 <mniip> type family KindOf a where KindOf (a :: k) = k
13:19:34 <mniip> promoted gadts
13:19:42 <mniip> and many  other exciting things
13:20:28 <bollu> http://www.pm.ethz.ch/projects/student_docs/Matthias_Niklaus/Matthias_Niklaus_MA_paper.pdf: (Dec. 2005 - May 2006) well fuck, I'm a decade late
13:20:46 <merijn> I haven't decided whether I like TypeInType or am just confused as fuck by it
13:21:02 <mniip> merijn, there are good bits and there are bad bits
13:21:16 <mniip> like, it lets you do some cool stuff
13:21:19 <mniip> and you're like
13:21:26 <bollu> every time I think I have a new idea, I feel sad when I google it
13:21:30 <mniip> oh my, I have this idea, it's the coolest stuff ever
13:21:38 <bollu> idk how I will get a masters at this rate
13:21:38 <mniip> I wonder if the typesystem will allow me to---
13:21:39 <mniip> nope
13:22:09 <mniip> I'm not sure if it's incomplete or impossible
13:22:10 <ralu> arent type systems and computer algorithms isomorhic? 
13:22:26 <bollu> ralu: how so?
13:22:28 <skeuomorf> ralu: programs and proofs
13:22:32 <skeuomorf> ralu: propositions and types
13:22:34 <bollu> ralu: type systems and logics are isomorphic
13:22:44 <mniip> at times it seems to defy the core haskell principle of composability
13:22:52 <skeuomorf> ralu: see: curry-howard isomorphism
13:22:59 <skeuomorf> ralu: propositions as types by philip wadler
13:22:59 <bollu> mniip: is * :: *?
13:23:04 <mniip> actually that seems to happen a lot with the new type system extensions
13:23:06 <bollu> mniip: like, do you get type universe tower?
13:23:06 <mniip> bollu, yes!
13:23:23 <bollu> mniip: so, I can encode Hott? :D
13:23:28 <bollu> or what little I know of it
13:23:45 <mniip> I know none of it so idk
13:24:00 <mniip> do note that the type universes are bounded from above
13:24:13 <mniip> by the amount of type variables you will bind or the amount of kinds you will specify
13:24:33 <mniip> you don't get "absolutely polymoprhic" variables
13:24:49 <mniip> only t1 :: t2 :: ... tn :: *
13:25:03 <bollu> mniip: what is the current haskell type system?
13:25:16 <mniip> haskell? or ghc
13:25:30 <bollu> mniip: ghc with everything on
13:25:48 <bollu> mniip: I remember asking a while back, and the best answer I got was "hindley milner, modified"
13:25:52 <mniip> I'm fairly sure this paper http://www.cis.upenn.edu/~justhsu/docs/nokinds.pdf
13:26:00 <mniip> maybe a few quirks appeared since
13:26:43 <bollu> is this based on outsidein?
13:26:47 <bollu> I found that a couple days back
13:27:00 <geekosaur> bollu, that would be true for standard Haskell (the modification is typeclasses). ghc is System Fc
13:27:09 <geekosaur> with modifications and constant tinkering >.>
13:27:36 <merijn> geekosaur: Not really anymore, though, is it?
13:27:46 <merijn> geekosaur: TypeInType is hardly System Fc?
13:28:16 <geekosaur> mm, true. but then I'm not sure we have a formal type system representing what ghc does any more
13:28:44 <bollu> geekosaur: is that not worrying?
13:28:46 <geekosaur> any grad students around that need a thesis? formalize current ghc >.>
13:28:57 <geekosaur> not really, no
13:29:04 <geekosaur> where do you think new type systems come from?
13:29:15 <mniip> the paper I linked above is goldfire's thesis iirc
13:29:24 <mniip> and it's the one implementing TypeInTyp4
13:29:32 <bollu> I see
13:29:44 <bollu> geekosaur: where do I need to go to learn type systems enough?
13:29:49 <bollu> I'm currently an undergrad, second year :3
13:29:53 <geekosaur> I have no idea
13:29:55 <bollu> enough of type systems*
13:29:57 <bollu> dang
13:30:19 <merijn> bollu: How much do you currently know?
13:30:44 * mniip peeks in on the discussion
13:31:13 <bollu> merijn: well, I understand the basic theory. I've played around with dependant types in idris, and with coq for theorem proving. I've implemented some bastardised version of algorithm w
13:31:26 <merijn> bollu: Have you looked at TaPL?
13:31:29 <bollu> merijn: and I've used dependant typing to encode matrices and all
13:31:32 <bollu> merijn: no, do tell
13:31:37 <merijn> @where tapl
13:31:38 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
13:32:02 <bollu> why pierce :( I need to finish SF as well
13:32:12 <mniip> 1486675264 [00:21:04] <bollu> every time I think I have a new idea, I feel sad when I google it
13:32:17 <merijn> bollu: That should cover most of the basics and not-so-basics (i.e. from untyped lambda calculus) up to more than you need for Haskell2010
13:32:25 <bollu> I see
13:32:33 <merijn> bollu: From there on you've basically reached the point of "read papers"
13:32:34 <bollu> mniip: 'tis true
13:32:48 <merijn> Because there's no books that cover much more
13:32:52 <bollu> merijn: I see
13:33:21 <mniip> every time I do that, google finds nothing, but as I start putting some real effort into doing something with it,
13:33:33 <bollu> merijn: I will try and setup a reading group at college for this: we have a type systems prof who was at UPenn.
13:33:33 <mniip> someone links an obscure paper
13:33:42 <merijn> As for where to go to study this stuff: Oregan State University, Edinburgh, Strathclyde and a few other UK ones and Gothenburg in Sweden come to mind
13:34:06 <monochrom> It is OK if someone already wrote your idea in an obscure paper.
13:34:07 <merijn> bollu: Those are the first that come to mind w.r.t. having research groups on this stuff
13:34:14 <merijn> monochrom++
13:34:30 <merijn> You just steal the idea, minor repackage and write the well-known paper on it ;)
13:34:48 <merijn> mniip: Are you using Google Scholar?
13:34:56 <mniip> sometimes
13:34:57 <merijn> Regular google is useless for finding papers
13:34:58 <monochrom> For a historical example, everyone knows Hoare and his preconditions and postconditions. Did you know that he got it from an obscure paper of Floyd?
13:34:59 <bollu> merijn: I see, tankyou
13:35:05 <bollu> thank you*
13:35:07 <mniip> yeah sure
13:35:23 <bollu> merijn: right now, my life's trajectory is heading towards compilers and LLVM
13:35:30 <merijn> :)
13:35:33 <bollu> merijn: but I don't want to, like, "lose" type systems
13:35:34 <qmm> is it strange that cassava uses strict evaluation? https://github.com/hvr/cassava
13:35:46 <bollu> merijn: seriously :P I'll be working on compilers for the next couple months or so
13:35:56 <monochrom> Only difference being: Floyd did it on flow charts, Hoare brought it to program text.
13:36:04 <vapid_> hey
13:36:11 <vapid_> https://www.youtube.com/watch?v=cU8HrO7XuiE
13:36:15 <merijn> Unrelatedly, I wish I need less operators for haskell...hard to type with one hand when the cat is busy sabotaging my coding
13:36:16 <vapid_> i really, really like this song
13:37:17 <mniip> I really want to find that paper now just to show what I'm talking about
13:37:36 <bollu> also, does anyone know of a way to compile a template instantiation machine output?
13:37:44 <bollu> I've been told that, like, G machine was created for this
13:37:48 <bollu> but are there any alternate strategies?
13:38:05 <bollu> also, question number 2: have there been efforts to mix lazy and strict evaluation?
13:38:19 <bollu> like, I wrote this: https://github.com/bollu/timi. I want to compile it using LLVM now
13:41:24 <mniip> http://ac.els-cdn.com/0167642389900361/1-s2.0-0167642389900361-main.pdf?_tid=69a95938-ef10-11e6-8942-00000aacb361&acdnat=1486676625_88ffb9e081b3ba923dfb360a9f023f5b
13:41:33 <mniip> look at the damn notation
13:41:59 <mniip> not even APL had that
13:42:57 <dmwit> Oh, well. Syntax used in papers is often ASCII-ized when doing an actual implementation.
13:43:00 <bollu> mniip: I remember seeing a book on "pattern calclus"
13:43:43 --- mode: ChanServ set +o glguy
13:43:43 --- mode: glguy set +b-o *!*@h35-65.pool95-168.dyn.tolna.net glguy
13:44:05 <sternmull> When i do "rs :: (RandomGen g, Random a) => g -> [a]; rs g = val:rs g' where (val, g') = random g" in ghci it says "Could not deduce (Random t0) ...". But it works when i compile it. Why is that?
13:44:38 <sternmull> (of course i imported System.Random)
13:44:49 <mniip> @hackage functional-kmp
13:44:49 <lambdabot> http://hackage.haskell.org/package/functional-kmp
13:44:51 <mniip> bollu, ^
13:45:06 <qmm> i have a list of strings and for each string, i want to insert it into the first column of a csv file
13:45:12 <bollu> has anyone seen this? fractional and rational types: https://www.cs.indiana.edu/~sabry/papers/rational.pdf
13:45:15 <glguy> sternmull: Because GHCi disables the monomorphism restriction
13:45:28 <dmwit> sternmull: Do you actually type it like that (with a semicolon), or do you type it on two lines?
13:45:44 <sternmull> dmwit: I tried both
13:45:49 <mniip> bollu, I have
13:45:55 <sternmull> glguy: thank you, will look up what that means
13:45:58 <bollu> mniip: and thoughts on it?
13:46:02 <mniip> but last time I read this I probably didn't have enough expertise to understand
13:46:13 <glguy> sternmull: You can turn it back on with: :set -XMonomorphismRestriction
13:46:19 <glguy> and it'll be good to read about what it is
13:46:21 <bollu> mniip: I see. do you think it is worth implementing?
13:46:51 <bollu> also, I wish H1B is reversed. It basically fucks all my chances for higher education in the USA :(
13:47:19 <mniip> hmm?
13:47:25 <merijn> bollu: You don't need H1B for studying
13:47:34 <monochrom> bollu: Darth Vader says: Come to Canada!
13:47:35 <merijn> bollu: Those are for jobs
13:47:43 <bollu> merijn: oh, I see
13:47:49 <monochrom> darn
13:47:50 <merijn> bollu: You need a J visum for studying/internships
13:47:51 <mniip> I'm fairly sure you need one for studying
13:47:54 <mniip> though a different one
13:48:08 <glguy> Visa varieties and immigration policies are beyond the topic
13:48:17 <sternmull> glguy: Thank you. As you said turning it on made ghci happy.
13:48:19 <bollu> glguy: sorry :)
13:48:38 <kadoban> You need a visa usually, but H1B is a special type of visa that's typically more restricted.
13:48:43 <bollu> mniip: in the paper, they propose a type system, but no inference algorithm. Is that the norm?
13:49:04 <mniip> I don't know
13:49:10 <bollu> #haskll-overflow <- take the conversation here?
13:49:21 <mniip> I probably know less type theory than you do
13:49:26 <bollu> #haskell-overflow *
13:49:32 <dmwit> sternmull: Another solution, in case you don't want to turn on the dreaded MR, is `rs g = case random g of (val, g') -> val : rs g'`
13:49:40 <merijn> bollu: Pretty sure the type theory is fine here, just the US immigration discussion that is not :p
13:49:47 <bollu> merijn: xD
13:49:51 <jle`> sternmull: turning on the monomorphism restriction in ghci is usually a bad idea.  the error here is kind of weird though
13:49:54 <dmwit> sternmull: This forces this particular binding to be monomorphic without forcing all other affected bindings to be monomorphic.
13:50:16 <bollu> why is TaPL not free?
13:50:19 <bollu> (SF is)
13:50:26 <merijn> bollu: Because academic publishers are scum
13:50:27 <dmwit> jle`: I guess this is because of the new pattern-binding desugaring rule that turns this into `let val = fst (random g); g' = snd (random g)` and decouples the types of the two things.
13:50:56 <jle`> wait, what
13:51:04 <monochrom> What is SF?
13:51:05 <jle`> never realized that was a thing now
13:51:11 <bollu> monochrom: software foundations
13:51:14 <sternmull> ok... let me read about the monomorphism stuff. All your good advises are a little bit too much for my tired brain right now :)
13:51:14 <merijn> monochrom: Software Foundations, also by Pierce
13:52:07 <jle`> sternmull: monomorphism restriction is usually the behavior you want when writing source files, but usually the behavior you don't want when using ghci
13:52:22 <dmwit> sternmull: Well, the behavior here surprised me, too, and I think I'm a relatively experienced Haskeller. So don't feel too bad.
13:53:12 <jle`> yeah, heh, i didn't believe there would be an error until i tried it out myself
13:53:39 <jle`> that desugaring rule is a bit odd dmwit. any particular reason it was added?
13:54:34 <monochrom> Oh! Irretuable patterns have a decoupling effect.
13:54:46 <bollu> where is HoTT research being done right now?
13:56:53 <dmwit> jle`: Turns out all possible rules are a bit odd. This was ruled the least odd of all.
13:57:03 <dmwit> jle`: I don't cherish trying to find the mailing list thread discussing this...
13:57:13 <jle`> kind of breaks ghci potentially
13:57:15 <jle`> oh well
14:07:24 <merijn> Christ, Haskell makes me a terrible contributor...
14:08:17 <merijn> I keep submitting PRs without actually bothering to compile things because changes seem so trivial and compiling a shitload of dependencies is annoying >.>
14:09:58 <monochrom> Are you changing code all over the dependencies?
14:10:25 <dmwit> monochrom: I was wondering the same thing. Then I noticed he said "compiling" and not "recompiling".
14:10:40 <merijn> monochrom: No, just small one-of patches
14:11:31 <kubbe> If I were supposed to count each character that occurs in a string, and it is supposed to show up in a table..
14:11:35 <monochrom> I guess it is none of my business. But is it necessary to compile the dependencies for even the second time?
14:11:50 <kubbe> Can I create it without any help-functions? I have a working set of code but it is just way to ugly to submit
14:12:10 <merijn> monochrom: No, I'm saying that Haskell makes the changes look so simple I didn't even compile it the first time >.>
14:12:29 <merijn> monochrom: Hence, why it's making me make terrible PRs >.>
14:13:22 <dmwit> kubbe: We're happy to help you beautify your code. But inventing fresh code for somebody's assignment is questionably ethical.
14:13:31 <dmwit> ?paste what you've got
14:13:32 <lambdabot> Haskell pastebin: http://lpaste.net/
14:13:40 <merijn> Speaking of beautifying code...
14:14:14 <lpaste_> merijn pasted “Ugly...” at http://lpaste.net/8199856595501318144
14:14:25 <kubbe> I absolutely do not want you to give me any answer, I just ask for guidance so I can get to that set of code and understand it myself. I always try to create a working set of code and then "beautify" it and at the same time get it faster! dmwit
14:14:33 <monochrom> Help functions are good ideas.
14:14:36 <merijn> Any suggestions how to make that code less ugly?
14:15:08 <kubbe> Alright, let me enter the code and we'll see if there is something that you could tell me. Promise not to laugh
14:15:35 <dmwit> No promises. But all laughter will come with suggestions. =)
14:15:40 <Akii> kubbe: lpaste though
14:15:51 <kubbe> http://pastebin.com/P8B0eQSX
14:16:03 <kubbe> I dont think I need to import anything else in that for it to work!
14:16:06 <monochrom> I can't promise, but history shows that I don't usually laugh, I usually frown.
14:16:18 <merijn> monochrom: Or sigh :)
14:16:41 <dmwit> kubbe: You might like `partition`.
14:16:42 <dmwit> :t partition
14:16:42 <kubbe> haha monochrom
14:16:44 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
14:17:21 <dmwit> kubbe: Why build up a `[(Char, Int)]` in `characterCounstAux` instead of building up a `Table Char Int`?
14:17:29 <merijn> oh... actually, I guess I could just move the when block into a let bound value and use it in the different cases...
14:18:11 <kubbe> Since I struggled for hours to get it to work that way, but I only got it to work for the first character in the string.. And then I decided I'll go with some help-functions to make it go through the entire string and then end up in the "table char int"
14:20:25 <merijn> No ideas on my code?
14:21:35 <dmwit> kubbe: Sorry for phrasing that as a question. What I really meant was: you should try building up a `Table Char Int` directly instead of building up a `[(Char, Int)]` only to tear it down and make a `Table Char Int` out of it.
14:22:19 <kubbe> Yes! Okey, let me give it a shot.. I am going to show you what I were able to create before. I need some assistance to get it be recursive and go through the list
14:23:02 <dmwit> We'll be happy to help with that. =)
14:23:39 <kubbe> http://pastebin.com/bz7Mirab
14:23:54 <monochrom> kubbe: Basically you can get rid of characterCountsAuxAux, and change characterCountsAux to update Tabe directly (String -> Table Char Int -> Table Char Int)
14:24:18 <kubbe> I can see two faults with this: 1. It just counts the first letter. 2. it will say the length on the array, not acutally count it so the result is -1.
14:24:33 <dmwit> kubbe: I recommend you start from the code in your previous paste.
14:24:44 <dmwit> kubbe: Beautify something that's working, not something that doesn't work. =)
14:25:08 <monochrom> Well, that actually depends
14:25:27 <kubbe> Hmm, okey! Interesting. But it just way to ugly, I want to delete half before even trying
14:25:35 <MarcelineVQ> merijn: your = should be -> in Just a's case expression
14:26:42 <MarcelineVQ> *Just a's guards
14:27:13 <monochrom> As it turns out, the broken version can be fixed and will become the simplest.
14:27:39 <merijn> MarcelineVQ: Eh, right. but that doesn't make it substantially less sucky :p
14:28:24 <dmwit> Okay. Two guides is too many; I defer to monochrom. monochrom, please ping me if you need to leave and I will pick up wherever you left off.
14:29:23 <MarcelineVQ> merijn: no, I am having trouble parsing it to see what can be done though :> for instance lf on line 9 doesn't seem to come from anywhere
14:29:52 <merijn> MarcelineVQ: Yeah, lemme fix it. That's what I get for copying mid refactoring
14:31:03 <kubbe> monochrom, yes this is what I think aswell.. Less is more for all haskellers, I have been told!
14:34:44 <kubbe> Okey.. So monochrome, is it to much to ask you if it the solution has to do with the use of guards, or recursive on the same line?
14:35:02 <monochrom> No guards.
14:35:26 <monochrom> You have always been doing recursive on the same line.
14:36:18 <qmm> i think hvr is too busy to answer, could someone help me this question: https://github.com/hvr/cassava/issues/130
14:36:27 <kubbe> Yeah, but with a bunch of piece of shit Aux :D
14:36:54 <monochrom> You can work on the working version first. It brings you understanding.
14:37:28 <kubbe> Yes, i am going to try!
14:37:56 <monochrom> That understanding will help you see what you're missing in the broken version, if you have time later. (And it will be obvious in retrospect.)
14:39:29 <monochrom> qmm: You can just use [ByteString] for each row. (Therefore [[ByteString]] for the whole table. Or Vector something.)
14:40:44 <monochrom> Vector [ByteString] and [Vector ByteString] are also possible.
14:42:05 <kubbe> Nah, I will have to continue this another night.. Need to sleep! Well thank you for now. Cya!
14:44:46 <tibbe> qmm, you want to parse into e.g. the Vector or HashMap generic representations
14:44:54 <lpaste_> samcal pasted “GADT AST Lambdas” at http://lpaste.net/352288
14:44:58 <tibbe> qmm, e.g. parse ... :: HashMap ByteString ByteString
14:45:17 <tibbe> qmm, you might need to the manually parse the bytestrings in the first column before manipulating them
14:45:45 <tibbe> qmm, http://hackage.haskell.org/package/cassava-0.4.5.1/docs/Data-Csv.html#g:5
14:45:47 <samcal> I need some help, I’m trying to represent an AST for a toy language with a GADT
14:45:57 <monochrom> HashMap would require you to specify a thousand keys.
14:46:18 <monochrom> But I guess if there is a header you're done.
14:46:19 <samcal> everything was going well until I tried to add lambda functions
14:46:21 <tibbe> monochrom, no, you ask cassava to return each row as a HashMap
14:46:36 <tibbe> monochrom, hmm
14:46:42 * tibbe tries to remember the design
14:47:26 <tibbe> >>> decodeByName "name,salary\r\nJohn,27\r\n" :: Either String (Header, Vector Person)
14:47:26 <tibbe> Right (["name","salary"],[Person {name = "John", salary = 27}])
14:47:35 <tibbe> monochrom, ^^^ there you don't have to specify what the header is
14:47:41 <tibbe> qmm ^^^
14:48:04 <merijn> MarcelineVQ: Ok, so now it compiles and looks a bit nicer, but still not really happy with it: http://lpaste.net/6298367134955208704
14:48:12 <tibbe> sorry, replace Person with Vector ByteString
14:48:28 <monochrom> Someone handwrote a Person type for that to work. The Person type for qmm would contain 1000 handwritten fields.
14:48:38 <tibbe> decodeByName "..." :: Either String (Header, Vector (Vector ByteString))
14:49:04 <tibbe> then update first value in vector and decode out again
14:49:08 <tibbe> encode*
15:00:20 <Tuplanolla> I put all this effort into foreign crap to get raw sockets and now the kernel says "socket: protocol error (Protocol not supported)". Nice.
15:00:46 <Tuplanolla> The same thing happens with the equivalent C code too.
15:01:11 <monochrom> dmwit, jle`: Regarding "rs :: (RandomGen g, Random a) => g -> [a]; rs g = val:rs g' where (val, g') = random g" again, there is a middle ground of NoMR and yet MonoLocalBinds.
15:01:58 <jle`> monolocalbinds sounds like a good idea
15:02:12 <jle`> oh wow it's a real thing, i didn't know this :o
15:02:31 <glguy> MonoLocalBinds gets turned on as a dependency of other extensions
15:02:36 <glguy> You might use it more than you know
15:02:56 <monochrom> IIRC GADTs implies it. Is that right?
15:03:16 <glguy> It's slightly tricky, it's only monolocalbinds for binds that couldn't be lifted out of that scoped
15:03:18 <glguy> scope*
15:03:36 <glguy> Yes, GADTs turns it on
15:03:50 <glguy> TypeFamiles will, too
15:04:34 <jle`> hm
15:04:54 <jle`> so it sounds like the ideal set-up in ghci should be NoMonomorphismRestriction, MonoLocalBinds
15:08:09 <markjn1984> leave
15:08:22 <monochrom> come back
15:08:46 <MarcelineVQ> stay
15:09:22 <jle`> flashbacks to Two Towers come up
15:13:59 <babooOn> if i have a function that takes a string and spits it into multiple string lists, how do i access one particular? for example parse :: String -> [[String]] and parse s = splitOn " ", how can i access the difrerent lists afterwards [[String1][String2]..] ?
15:14:45 <monochrom> If you know "I want the 10th string", you can use !! 11
15:14:49 <monochrom> err, !! 9
15:15:04 <MarcelineVQ> @tell merijn your doQuery looks a lot like a manual version of onException since you're rethrowing.  let doQuery = queryGame qsem l `onException` mapM_ leftover l
15:15:04 <lambdabot> Consider it noted.
15:15:07 <monochrom> Else, you will have to say what you want it for.
15:15:52 <monochrom> If you want to stay general, then: You have a list. Use any list-processing functions.
15:16:43 <babooOn> monochrom use it where?
15:16:53 <babooOn> in the same function=
15:17:10 <monochrom> You like to stay general, eh?
15:17:16 <monochrom> Use it where you need it.
15:18:00 <tikhon> What does the number of bytes printed by :set +s in GHCi mean? Is it the total amount of memory allocated?
15:18:23 <hpc> yes
15:18:52 <hpc> it's not the maximum memory consumption, just the sum of all allocations
15:18:59 <tikhon> okay, that's what I was wondering
15:19:00 <tikhon> thanks
15:19:11 <MarcelineVQ> tikhon: more here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-options-to-produce-runtime-statistics
15:19:58 <tikhon> yeah, I'm comparing the stats reported by +RTS -s with what GHCi gives me, but I didn't know which number to compare to
15:20:05 <MarcelineVQ> possibly too much more, I was hoping for a ghci summary note in there too hehe
15:20:20 <tikhon> I'm having an odd problem where my code finishes faster and allocates much less from GHCi than it does as an executable.
15:20:47 <tikhon> I've never run into that before, so I don't have much of an idea on how to debug it.
15:22:39 <Jello_Raptor> Hmm, is it possible to use type families (or data families?) as parameters to a typeclass? Like this http://lpaste.net/352289 ? I've got what amounts to a set of data structures with basically identical constructors but separate inner types, and would like to share the constructors if possible. 
15:25:02 <hpc> Jello_Raptor: looks like you can't and there's a specific error message for it
15:25:03 <hpc> test.hs:14:10: error:
15:25:03 <hpc>     • Illegal type synonym family application in instance: Bar a
15:25:03 <hpc>     • In the instance declaration for ‘Quux (Bar a)’
15:25:11 <hpc> (class Quux a where)
15:28:06 <babooOn> can someone give me a hint why on line 6 if the y input = 0, it = getAllMoves s (x-1) 8 color ? (field is 8x8) http://lpaste.net/352291
15:29:07 <Jello_Raptor> hpc: oh? also that's not what i get when i fox the example a bit more http://lpaste.net/352289
15:29:47 <Jello_Raptor> it's complaining that the we need to apply the type family when we use it as a parameter to the datatype 
15:30:03 <Jello_Raptor> which would mean it has kind * rather than * -> * like I want
15:31:02 <Jello_Raptor> Functors and other normal datatypes with kind `* -> *` work fine in similar situations :/ 
15:38:00 <Jello_Raptor> hpc: huh, replacing the type family with a data family works fine, but adds a pile of constructors I don't want to deal with. 
15:43:56 <qmm> monochrom and tibbe: thank you both! (sorry for the lack of responsiveness over here)
15:44:21 <monochrom> You're welcome
15:53:40 <hpc> Jello_Raptor: maybe it has to do with type families being closer to aliases than to data definitions
15:53:51 <hpc> so when you write an instance for one, it's not really a well-defined type
15:54:41 <hpc> unwanted constructors are pretty much inevitable when you want to do stuff with type classes though
15:54:47 <hpc> what with the newtyping you often have to do
15:55:50 <nshepperd> type families aren't type constructors
15:57:14 <nshepperd> so you can't make a type class instance on them
15:59:00 <ion> Hi, would it be possible for this type to be inferred? https://gist.github.com/ion1/ae343d4c6369cfe048913c6b6b88e12f
15:59:06 <nshepperd> although, now you can make type checker plugins that will produce such instances on demand, then it's up to you to make sure your instances are correct and coherent...
15:59:40 <ion> I know dependent types are incompatible with type inference in general, but it seems to me this specific case should have no ambiguity.
16:00:38 <ion> Not that DataKinds are even necessary for this, actually
16:02:27 <benzrf> ion: thats not dependent types
16:02:33 <benzrf> jsyk
16:03:48 <nshepperd> ion: I think the Vect _ a -> a part could be inferred in theory
16:04:50 <nshepperd> ion: but ghc just gives up on inference for GADTs in general, because of this: is that a total function Vect (S Z) a -> a, or a partial function Vect n a -> a?
16:05:00 <dmwit> ion: If we write `type family Foo n a; type instance Foo (S Z) a = a`, then this also has type `Vect n a -> Foo n a`, which doesn't unify with the type you gave.
16:05:31 <nshepperd> also that
16:05:49 <dmwit> ion: (And there is no type that generalizes both your type and this one.)
16:05:59 <ion> Thanks for your comments.
16:07:26 <dmwit> So I think the answer to your question is that yes, that type could be inferred in principle. But so could other types, and then who's to say which is the best one? Presumably the answer here is "the user should say which is best". And that's the answer GHC chose.
16:09:44 <ion> Is there a way to do "do a :- b :- c :- Nil <- generateStuff", passing the number of outputs to generateStuff implicitly instead of explicitly? "do a :- b ;- c :- Nil <- generateStuff (SS (SS (SS SZ)))" (with singleton types) works and typechecks but I'm having trouble finding a way to infer it.
16:22:44 <MarcelineVQ> @tell merijn made a couple suggestions as paste annotations, hopefully they're relevant, hard to say for sure without the types and imports :>  http://lpaste.net/6298367134955208704
16:22:44 <lambdabot> Consider it noted.
16:53:17 <qmm> urlEncode $ False (BS.pack $ head mystrings) -- Couldn't match expected type ‘BS.ByteString -> Bool’ with actual type ‘Bool’
16:53:36 <qmm> https://hackage.haskell.org/package/http-types-0.9.1/docs/src/Network-HTTP-Types-URI.html#urlEncode
16:53:40 <Koterpillar> qmm: urlEncode False $ BS.pack $ head mystrings
16:54:15 <Koterpillar> qmm: what you had was qmm (False (BS.pack (head mystrings)))
16:54:25 <Koterpillar> sorry, urlEncode (False (BS.pack (head mystrings)))
16:54:27 <dmwit> > f $ g $ x
16:54:30 <lambdabot>  error:
16:54:30 <lambdabot>      • Could not deduce (Show t0) arising from a use of ‘f’
16:54:30 <lambdabot>        from the context: FromExpr t
16:54:47 <dmwit> > f $ g x
16:54:49 <lambdabot>  error:
16:54:49 <lambdabot>      • Could not deduce (Show t0) arising from a use of ‘f’
16:54:49 <lambdabot>        from the context: FromExpr t
16:54:58 <dmwit> okay...
16:55:00 <qmm> Koterpillar: strange, i thought i had function x y
16:55:21 <qmm> urlEncode (False) (BS.pack...)
16:56:40 <qmm> oh, i just needed urlEncode False (BS.pack...)
16:56:56 <Koterpillar> that's what I suggested ^_^
16:56:59 <qmm> not really sure why i put that dollar symbol in there now :P
16:57:13 <Koterpillar> urlEncode False $ BS.pack $ head mystrings -- look, no brackets
16:57:20 <qmm> i probably don't have a great grasp on the $ operator
16:57:32 <Koterpillar> $ == "the rest is the last argument"
17:00:32 <qmm> neat way to think about it, thanks
17:24:46 <Squarism> Theres probebly a good reason but why do 74000 lines of java code take 17s to compile vs 6000 lines of haskell code takes 2 minutes?
17:30:58 <lpaste_> qmm pasted “the error is just "parse error on input 'V.forM_' ...not a lot to go on...” at http://lpaste.net/352294
17:31:37 <qmm> Axman6: i went with your style the other day. it kept it all a little more condensed (thanks for responding then!)
17:33:02 <dmwit> qmm: Your `case` needs an `of`.
17:34:11 <qmm> dmwit: ty
17:34:16 <qmm> facepalm
17:35:31 <qmm> Squarism: does the java file consists of primarily 73,900 lines of elements for a list? :)  
17:35:54 <qmm> i.e. maybe there's more going on in the haskell code?
17:36:13 <markasoftware> Squarism: haskell compiling is known to be very slow
17:36:17 <geekosaur> java code actually maps pretty directly to JVM ops
17:36:34 <markasoftware> and java isn't really "compiling" iirc
17:37:18 <Squarism> qmm, Hehe - no, not a single list. Most of the java code is quite dumb arguebly .  
17:37:38 <monochrom> Java leaves much optimization to run time. GHC doesn't.
17:38:00 <Squarism> i might have "debug" mode enabled in stack though. Can i check that easily? 
17:38:19 <monochrom> Also Haskell type inference is exponential time. Java type checking is not.
17:38:25 <Squarism> monochrom, can one turn of optimzation while developing?
17:38:32 <monochrom> Yes, -O0
17:38:37 <markasoftware> Squarism: just use runghc
17:38:40 <markasoftware> to interpret
17:38:45 <monochrom> But -O0 is already the default.
17:38:46 <markasoftware> if lower performance is ok during development
17:39:05 <monochrom> But maybe stack overrules it. I don't know stack. I don't know jack. That's not my trade.
17:39:16 <Squarism> it is
17:39:40 <Squarism> ^ markasoftware 
17:39:55 <markasoftware> then use it: `runghc script.hs`
17:40:47 <Squarism> oh.. i have -02 everywhere
17:41:13 <Squarism> "-O2 -threaded -with-rtsopts=-N"
17:41:32 <monochrom> -02 would be very fast :)
17:41:43 <Squarism> very optimized?
17:41:53 <Squarism> or fast compileing
17:41:58 <monochrom> "unrecognized flag" immediately :)
17:43:47 <fresheyeball> how can I see the rendered result of template Haskell?
17:44:39 <monochrom> -ddump-splices
17:44:53 <monochrom> add -ddump-to-file if you like
17:45:14 <monochrom> See GHC Users Guide section 10.26.3 "Viewing Template Haskell generated code"
17:45:54 <monochrom> Do not learn from blogs. Learn from GHC Users Guide.
17:47:46 <fresheyeball> hmm
17:47:50 <fresheyeball> so that just eats it
17:48:00 <monochrom> Bill Gates's appraisal at the back cover of GHC Users Guide: "If you have read it cover to cover, send me your CV"
17:48:03 <qmm> monochrom: i don't think i understood what you were suggesting unfortumately :\ https://github.com/hvr/cassava/issues/130
17:48:07 <fresheyeball> I ran `cabal build --ghc-options="-ddump-splices"`
17:48:13 <fresheyeball> and nothing special happened
17:48:29 <monochrom> cabal build is too late for this.
17:48:43 <monochrom> Or maybe not. I don't know. Nevermind.
17:48:49 <markasoftware> monochrom: really?
17:48:57 <qmm> monochrom: it does seem to want a bytestring as you suggested: https://github.com/hvr/cassava/blob/545b86d60276c51ec29681f1917f1e5fb9b67c54/Data/Csv/Encoding.hs#L88
17:49:26 <monochrom> I'm just kidding. I stole that Bill Gates quote from the back cover of Knuth's TAOCP
17:50:39 <monochrom> qmm, wrong parenthesizing.
17:51:02 <monochrom> "x (y :: T)" ≠ "x y :: T"
17:51:42 <monochrom> The error message says that too.
17:52:22 <qmm> i thought i was getting better at error messages
17:53:00 <qmm> just when i think i can write haskell pretty well, i publically embarrass myself
17:53:49 <qmm> case (decodeByName csvData :: Either ...) of -- maybe?
17:54:05 <monochrom> You need no parenthesizing at all
17:54:51 <HaskellLord69> dont worry qmm i will divert
17:55:40 <HaskellLord69> http://pastebin.com/UduEt1Kf
17:55:55 <HaskellLord69> im having trouble with monad transformers if anyone can help
17:56:09 <HaskellLord69> ive been staring at this for hours and I feel like my brain is mush
17:56:50 <lpaste_> qmm pasted “i think it's going to take awhile for me to understand how to use this library” at http://lpaste.net/352296
17:57:11 <qmm> HaskellLord69 :)
17:57:15 <monochrom> HaskellLord69, I think you have the ordering backwards
17:58:23 <HaskellLord69> i thought backwards was the point with monad transformers lol
17:59:07 <monochrom> At some other point you see the backwardness. But your current example doesn't hit it.
18:00:01 <monochrom> The problem with learning from oversimplified simple-minded slogans that would get an A+ from essay graders.
18:03:06 <monochrom> qmm, perhaps use decode instead of decodeByName. This means you won't have a distingished header or column names. But you will have a 2-dimension vector (or list, or both).
18:04:09 <qmm> oops, i updated the comment on github with the result of decode (instead of decodeByName) https://github.com/hvr/cassava/issues/130
18:04:21 <qmm> that's the result of just using decode
18:04:30 <qmm> about to change it to be a result of decodeByName
18:05:25 <dmwit> fresheyeball: -ddump-splices often pairs well with -fforce-recomp
18:06:05 <monochrom> I don't see the update. I have already crtl-r'ed 3 times.
18:06:21 <qmm> monochrom: now it's there
18:06:39 <monochrom> the 4th time and still don't see it.
18:06:47 <qmm> it's an edit
18:06:48 <monochrom> OK, sorry, see it now.
18:06:50 <qmm> not a new comment
18:07:19 <monochrom> You will not have Header.
18:07:44 <monochrom> It's simply Either String V.Vector (V.Vector BL.ByteString)
18:08:31 <monochrom> I don't know whether to point out that the error message also says this.
18:09:25 <monochrom> I don't know. tibbe misled you down this path and I suppose I'll just say it's his problem now.
18:10:23 <qmm> monochrom: thank you for your patience 
18:10:43 <qmm> monochrom: i won't ask anymore from you
18:38:51 <skeuomorf> is the order of the definitions of a function important? e.g. a function that takes the empty list, returns an empty list, if it takes a non-empty list, it does some computation
18:39:08 <skeuomorf> so, they're defined as patterns
18:39:20 <skeuomorf> e.g. myfunc [] = []
18:39:29 <skeuomorf> myfunc xs = dostuff
18:39:54 <geekosaur> the first one that matches is used, so if you swapped them then xs would also match the empty list
18:40:23 <skeuomorf> yeah, that was just a quick example
18:40:32 <skeuomorf> but I see what you mean
18:41:28 <skeuomorf> is there a resource more terse than real world haskell?
18:42:03 <Rotaerk> I didn't like RWH because its examples were way too elaborate and distracting
18:42:38 <skeuomorf> yeah, I am already comfortable programming in multiple other languages, some of them functional, some of them typed, but not both
18:42:42 <skeuomorf> I get the general idea
18:43:06 <skeuomorf> But I think I will need to learn all the IO stuff
18:43:19 <skeuomorf> cause it's unconventional, at least for me
18:45:51 <c_wraith> skeuomorf: it's unconventional, but it has a nice internal consistency.  The one warning I'd give is that monads aren't important.  No matter what you read that says otherwise, they just aren't.  Don't waste time trying to "learn monads"
18:47:23 <c_wraith> skeuomorf: if you want a very get-your-hands-dirty intro, maybe https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours ?
18:48:52 <kgadek> agreed on not learning monads. Actually, I'd go further and ban everyone new to Haskell from reading any monad tutorial until they wrote at least few programs
18:49:49 <kgadek> and insist on saying "action" instead of "monad"
18:49:53 <skeuomorf> c_wraith: ah, that looks interesting, I think I looked at it before and ignored cause I was disappointed in the fact that it used a parsing library
18:50:12 <c_wraith> skeuomorf: eh.  parsing libraries are something haskell makes really good.
18:50:22 <skeuomorf> c_wraith: but I will probably give it a go now again, thanks!
18:50:36 <c_wraith> skeuomorf: it's kind of like using boost::spirit, but without being such an abuse of the host language.
18:51:04 <skeuomorf> ah, monads, I don't understand what's the big deal, I am fairly comfortable with math and I've played around with category theory before and I don't find these concepts that complex
18:51:26 <c_wraith> skeuomorf: that's because they're not complex. :)
18:51:38 <c_wraith> skeuomorf: they're just an abstraction most programming languages can't express.
18:51:45 <skeuomorf> haven't looked into what haskell does yet but I think that you folks use these concepts (monad, monoid, functor) as a way to define a common interface for common behavior?
18:52:09 <c_wraith> people think "I don't recognize this" is the same as "this is hard and unlearnable" and choke on their own fear.  I did it!
18:52:51 <skeuomorf> aha
18:52:57 <c_wraith> I eventually stopped trying to learn what they were, and just learned the language.  Worked much better. :)
18:53:03 <skeuomorf> hah
18:54:29 <skeuomorf> is there a decent library to mess around with automata in Haskell?
18:54:40 <c_wraith> what kind of automata are you looking for?
18:54:40 <skeuomorf> to clarify, NFAs, DFAs not cellular automata
18:55:48 <c_wraith> Hmm.  I don't actually know of anything offhand, but some of the more advanced regex libraries (the ones that aren't character-based) must have those.
18:56:09 <skeuomorf> aha
18:56:22 <skeuomorf> I meant something like https://github.com/ztellman/automat
18:57:14 <qmm> tibbe: updated the comment
18:57:16 <c_wraith> Ok, I was thinking of the right thing.
18:57:33 <qmm> tibbe: oh sorry, i was scrolled up and thought you were online
18:57:49 <qmm> i was able to figure out how to parse with casavva
18:57:58 <qmm> i am so noobish
18:58:15 <c_wraith> skeuomorf: looks like there are a few options on hackage.  https://hackage.haskell.org/package/hDFA  has some tools for generating dot graphs and minimizing DFAs
19:00:07 <qmm> now i have a list of urls and a vector of bytestrings, and for each url i want to drop the first item in the vector and cons/prepend the url
19:00:17 <qmm> in an imperative language i woudl use two for loops
19:02:17 <c_wraith> skeuomorf: looks like https://www.cs.kent.ac.uk/people/staff/sjt/craft2e/regExp.pdf is a solid resource if you want to play with implementations as well as the automata themselves
19:02:43 <EvanR> qmm: if you write the imperative algorithm into an lpaste, im sure someone can help you translate it into haskell
19:02:50 <EvanR> i just dont really understand what youre trying to do from that description
19:03:01 <skeuomorf> c_wraith: Very cool, will check those out after I am done writing a scheme
19:03:08 <skeuomorf> c_wraith: Thanks! :)
19:05:47 <monochrom> skeuomorf: The Gentle Introduction is more terse than RWH.
19:06:31 <monochrom> But my http://www.vex.net/~trebla/haskell/IO.xhtml is better for IO.
19:06:43 <monochrom> (and I/O)
19:09:06 <skeuomorf> monochrom: nice
19:10:47 <skeuomorf> Is there something like https://www.conj.io for Haskell?
19:11:54 <monochrom> I think no.
19:12:29 <skeuomorf> hmm
19:12:42 <roboguy`> skeuomorf: that looks like something a bit different, but there is https://www.haskell.org/hoogle/
19:12:45 <bitemyapp> be the conj.io you want to see in the world
19:13:19 <roboguy`> That looks like it's describing the language itself though
19:14:52 <Koterpillar> http://haskell.io/ is squatted
19:15:10 <skeuomorf> roboguy`: Hoogle looks good enough for me
19:15:38 <skeuomorf> I like being able to glance all the stuff in conj.io but eh
19:15:47 <roboguy`> skeuomorf: there's also Hayoo which uses a different algorithm (so it can sometimes find things Hoogle can't): http://hayoo.fh-wedel.de/
19:16:12 <skeuomorf> roboguy`: good to know
19:19:29 <dhalgren> hi! so any examples on hackage or whatever of pipelines of calculations done elegantly? I've been writing a quick&dirty script calculating various contract bridge related things; probabilities of hands, fits, deals, biasing by certain ways of counting points etc. Doing it in ghci mostly like long compositions of maps, folds, filters etc. Fun and effective, but the shape of this code imho starts to get 
19:19:35 <dhalgren> opaque rather quickly, esp if I need multiple results from a stage and so start tupling things up etc.
19:20:11 <HaskellLord69> monochrom:  ty for the slight "nudge".  I figured it out.
19:24:31 <dhalgren> eg something like this: shapescount count = map (\x->((head (fst x), (fromIntegral.length) (fst x) / count, listAvg (snd x)))).map (\x-> (map (fst) x, map snd x).reverse.myGroup.mySort.map (sort.shape &&& hcp)
19:24:55 <Koterpillar> dhalgren: add more types?
19:25:44 <Koterpillar> dhalgren: by the way, you can do: map (\(x1, x2) -> ((head x1, (fromIntegral . length) x1 / count ...
19:27:10 <dhalgren> hah, yeah, didn't notice it this time
19:27:24 <roboguy`> also
19:27:27 <roboguy`> :t unzip
19:27:28 <dhalgren> so you mean, like data decl for various intermediate shapes?
19:27:29 <lambdabot> [(a, b)] -> ([a], [b])
19:28:03 <roboguy`> ^ that is (\x -> map fst x, map snd x)
19:28:58 <Koterpillar> dhalgren: and give names to these intermediate functions too
19:29:17 <Koterpillar> dhalgren: what _is_ an x there? It's a pair of something, but of what?
19:29:51 <Koterpillar> dhalgren: then if you're always using mySort on them, define an instance of Ord instead
19:31:44 <qmm> i want the equivalent of this in haskell without the crashing :) https://paste.pound-python.org/show/OhdCM4AmuTnML3xSVruP/
19:33:05 <Koterpillar> qmm: zip
19:33:19 <qmm> Koterpillar: ah!
19:33:32 <qmm> Koterpillar: i can't believe that didn't come to mind
19:33:34 <Koterpillar> > zip ["example", "reddit", "nothing"] ["foo", "bar", "baz"]
19:33:37 <lambdabot>  [("example","foo"),("reddit","bar"),("nothing","baz")]
19:33:38 <qmm> yep yep
19:34:07 <qmm> > zip ["example", "reddit", "nothing"] ["foo", "bar", "baz", "qux"]
19:34:09 <lambdabot>  [("example","foo"),("reddit","bar"),("nothing","baz")]
19:34:57 <dhalgren> Koterpillar: its just that these are all so ephemeral; just there for a couple of calc steps for that particular function. step 1, its a sorted hand shape and point count of a particular hand, next sorted by hand shape, then grouped, now I have something like lists of lists of pairs of a list of int and an int or something like that - and I clearly should be naming something like that.. 
19:35:13 <qmm> zipping a [String] and a Vector ByteString should be fun
19:35:24 <Koterpillar> dhalgren: put them into a module
19:36:38 <Koterpillar> dhalgren: and give them generic types. E.g. does that function need to know that the list if of hands, or maybe it can operate on any lists?
19:48:03 <dhalgren> and thx roboguy` ; should've recognised it
19:59:49 <lpaste_> qmm pasted “parse error, missing something...” at http://lpaste.net/352297
20:02:35 <Koterpillar> qmm: try moving let to the right of -> 
20:02:49 <Koterpillar> qmm: also, it's not in a do block, so it must be "let ... in ..."
20:02:56 <Koterpillar> oh wait
20:03:00 <Koterpillar> data is a keyword
20:05:49 <qmm> https://wiki.haskell.org/Keywords
20:05:52 <qmm> thanks Koterpillar 
20:06:08 <qmm> and on that note :)
20:12:31 <Squarism> anyone vetted in scala? I wonder how i write : Maybe $ anExpression
20:12:41 <Squarism> in scala wo using (..)
20:12:57 <Squarism> Some expr
20:13:40 <geekosaur> why would you be asking about scala in here?
20:14:22 <geekosaur> (I see one person in here who I know has scala experience... and his opinion is "avoid")
20:14:50 <EvanR> edk
20:15:23 <EvanR> Squarism: #scalaz
20:15:47 <monochrom> Perhaps because scala people wouldn't know what "Maybe $ anExpression" means.
20:16:05 <aarvar> Squarism: `foo.some` ?
20:16:18 <aarvar> and I'm guessing you meant Just, not Maybe
20:16:19 <monochrom> I for one is in #haskell and couldn't answer "how do you write <scala code here> in Haskell?"
20:16:36 <Squarism> sorry
20:16:39 <Squarism> got desperate here
20:16:44 <Squarism> need to get home from work
20:17:01 <Axman6> do you mean Just $ anExpression??
20:17:06 <Axman6> s/??/?
20:17:18 <dibblego> Axman6 ❤ scala
20:17:35 <EvanR> while leaving the building you are confronted by a kung-fu master who refuses to let you pass without translating a snippet of haskell into scala
20:17:40 <aarvar> dibblego: everyone ❤ scala
20:18:21 <Squarism> Axman6, yes.. but now ive dropped it.
20:19:26 <monochrom> You can get past the kung-fu master by asking them "what would you answer if you were asked which way is the way out?"
20:19:37 <monochrom> @quote monochrom sentinel
20:19:37 <lambdabot> No quotes match.
20:19:39 <thepreacher> Working through haskellbook and am stuck of the following exercise. Given a :: (a -> c) -> a -> a define a function that will type check. My solution so far is myFunc aToc a = (aToc a). But I think its wrong because the signature for that is myFunc :: (a -> c) -> a -> c.
20:20:00 <monochrom> @quote monochrom angel
20:20:00 <lambdabot> monochrom says: at a crossroad you meet an angel (always tells the truth) or demon (always lies). the crossroad gives you two choices of roads, one to heaven, one to hell, and only the angel or
20:20:00 <lambdabot> demon knows which is which. if you ask "how would you answer if I asked 'what is a monad?'", what will happen?
20:20:19 <monochrom> That may also work :)
20:20:22 <jchia> I'm making binary getter & putter for some nested product type. The serialization result is fixed-length, so I want to use 'isolate' in my getter. However, hand-calculating the number of bytes expected is quite tedious. Is there a way to get the number of bytes automatically or semi-automatically in a less error-prone way? I suppose for each type that needs to be serialized/deserialized, I can define a compile-time value for the "number of bytes needed", and 
20:20:48 <vandino>  hello
20:20:50 <monochrom> So many "a"s
20:20:54 <glguy> thepreacher: you're right, your given solution has the wrong type
20:21:27 <EvanR> jchia: theres sizeOf
20:21:34 <monochrom> I'm wondering if you should care about the parameter at all.
20:21:49 <monochrom> err, I mean the first parameter.
20:21:54 <glguy> you've got values with types a, and a->c.  you need a value with type a, what do you do?
20:22:07 <jchia> EvanR: sizeOf from Foreign.Storable? How do I bridge Foreign.Storable and Data.Binary?
20:22:29 <glguy> it's not necessary to care about all the parameters
20:23:18 <EvanR> jchia: er uh... you could replicate that scheme, define a class Sized and everything involved has an instance which calculates your binary size from whatever it consists of (which are also sized)
20:23:57 <monochrom> jchia: There is no need to bridge. Write Storable instances for your types. Then just call sizeOf when you serialize. It doesn't even have to be Storable, it can be your own class of your invention.
20:24:14 <jchia> is Storable derivable?
20:24:30 <EvanR> i have seen Binary be derivable
20:24:33 <EvanR> through TH
20:24:38 <monochrom> No, but it is composable.
20:24:48 <monochrom> err, compositional.
20:25:46 <thepreacher> glguy: I thought of myFunc _ a = a which from GHCi gives a type signature of myFunc :: t1 -> t -> t but t1 doesn't capture the idea of being a function.
20:25:58 <monochrom> I mean this. If you have "data X = ..." and you know how to write it's sizeOf, then when you have "data Y = Ctor X X X", then you simply write Y's sizeOf (Ctor x _ _) = 3 * sizeOf x
20:26:04 <jchia> monochrome: I think using Storable involves IO, so it's impure
20:26:19 <monochrom> So you still have to handwrite something but it is tractable.
20:26:26 <EvanR> sizeOf doesn't involve IO
20:26:32 <glguy> I don't know what you were thinking the idea of being a function was, but that's the right solution
20:27:06 <monochrom> Again, you can always make your own class.
20:27:07 <jchia> EvanR: But since I'm using Storable, shouldn't I use the other functions to do the get and put? Or do I use Storable just for the sizeOf?
20:27:22 <EvanR> i would make my own class
20:27:29 <monochrom> And while you invent your own class, you can bring in Proxy so you don't have to use undefined.
20:27:50 <monochrom> class MySize t where size :: proxy t -> Int
20:27:59 <thepreacher> glguy: Hmm thanks.
20:28:04 <EvanR> and the only reason to use a class here is to use the same word "size" at each stage
20:28:08 <glguy> don't put Proxy in the class though, proxy is better for that
20:28:14 <monochrom> yeah
20:28:48 <EvanR> if everything were in its own module you could also do Foo.size Bar.size, etc, and no proxies would be harmed in the making of this calculation
20:29:02 <monochrom> And so it doesn't even have to be Proxy. It can be "size ([] :: [Y])"
20:29:13 <jchia> monochrome: What about the 'compositional' part?
20:29:30 <monochrom> You saw my sentence starting with "I mean this"?
20:29:48 <jchia> e.g. if I have data Foo = Foo {bar :: Bar, bar :: Baz}, how do I define the size of Foo?
20:30:17 <EvanR> sizeOf bar + sizeOf baz ?
20:30:18 <monochrom> size of Foo = size of Bar + size of Baz, no?
20:31:05 <jchia> monochrom: Yes, but it's still boilerplate. i already defined the constituents of Foo and then I still have to define the size in the same way.
20:31:20 <monochrom> What we're telling you now, which can be done in an hour, can be saved by 4 days of learning Template Haskell, GHC.Generics, and Data.Generics, and then arguing with yourself which way to go.
20:31:37 <glguy> it's not even necessary to use isolate
20:31:51 <glguy> so we could solve this exercise by not solving it
20:32:17 <jchia> glguy: If I use isolate, I'll find out early that the input is too short
20:32:22 <monochrom> Sorry, what is isolate again?
20:32:52 <jchia> 'reserve' a number of bytes. if we end up consuming less or trying to consume more, the get fails.
20:35:36 <glguy> what kind of expensive computation are you doing during deserialization that there is an "early"?
20:35:37 <jchia> my top-level product type is not very deep. maybe i'll just calculate the size by hand.
20:36:20 <jchia> glguy: It's not about calculation. it's just about trying to follow the principle of failing early
20:37:35 <jchia> glguy: But it's just a general principle, I really need to isolate.
20:37:41 <jchia> i mean i don't need
20:37:59 <monochrom> Sure. If you have written 1MB and then find that the length is wrong after all, I can agree that it's too late.
20:38:19 <monochrom> But until you have written 64KB or something, I say it is still early enough.
20:38:37 <glguy> this is reading not writing
20:38:46 <monochrom> Reason being buffer size etc etc.
20:39:05 <jchia> I'm converting from one format to another, so it's preferable to output less garbage when the input is garbage
20:39:33 <jchia> but it's not essential, maybe i don't need it
20:39:40 <jchia> if it takes so much engineering effort
20:41:13 <monochrom> Bear in mind that even lazy bytestring is in 64KB blocks
20:42:31 <jchia> Although I haven't analyzed the laziness, I think I'll fully evaluate the entire top-level product type before I output anything for it, so here outputting less garbage here is probably moot, so I think glguy is right.
20:43:43 <ryantm____> I was playing with the example code in https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#generalised-algebraic-data-types-gadts and I was trying to derive Show for Term, but it cannot derive show for Pair: https://gist.github.com/ryantm/2d548185fc81c98775f0d591343b26e5 Is there some way to modify it so it can derive Show for
20:43:44 <ryantm____> Pair?
20:44:38 <ryantm____> I tried using type equality in the definition of Pair like: Pair :: a ~ b => Term a -> Term b -> Term (a,b) but that didn't work
20:49:24 <markasoftware> why is literally everything on the haskell wiki written in such a way that you can't understand it unless you already know it?
20:49:55 <monochrom> ryantm____: Pretty sure you saw the sentence there "You cannot use a deriving clause for a GADT; only for an ordinary data type."
20:49:58 <markasoftware> "The concept of a type family comes from type theory. An indexed type family in type theory is a partial function at the type level. Applying the function to parameters (called type indices) yields a type. Type families permit a program to compute what data constructors it will operate on, rather than having them fixed statically (as with simple type systems) or treated as opaque unknowns (as with parametrically polymorphic types)."
20:50:03 <markasoftware> what the flying fuck does this mean
20:50:07 <c_wraith> markasoftware: It's not.  It's written so that if you know haskell, you can learn new concepts.
20:50:40 <ryantm____> monochrom: You can use standalone deriving or a GADT generally, it doesn't work for Pair. For example, if you comment out Pair it works.
20:50:49 <ryantm____> for a GADT*
20:50:49 <c_wraith> markasoftware: type families aren't part of base haskell.  They're an extension.  They only make sense if you know base haskell.
20:50:57 <markasoftware> i mostly know base haskell
20:51:04 <markasoftware> not that well, but enough
20:52:01 <c_wraith> markasoftware: so what's unclear about "applying a type function to parameters yields a type"?
20:52:14 <markasoftware> that sentence is ok
20:52:20 <monochrom> markasoftware: Because of self-selection bias. Someone writing on the haskell wiki is very likely in an enthusiastic high mode such that they want to share you with their excitement and keep talking and not think whether you understand or what order is a good order to explain.
20:52:27 <c_wraith> markasoftware: that's all you need to know, until you get to syntax.
20:52:36 <markasoftware> it's unclear what "Type families permit a program to compute what data constructors it will operate on, rather than having them fixed statically (as with simple type systems) or treated as opaque unknowns (as with parametrically polymorphic types)." means
20:53:53 <markasoftware> well, i hope i figure it out eventually
20:54:16 <monochrom> Read the GHC Users Guide for type family. I learned it there.
20:54:16 <c_wraith> Type families just let you write functions on types.
20:54:26 <c_wraith> and yeah, the User's Guide is actually really good.
20:54:49 <monochrom> Bill Gates's appraisal at the back cover of GHC Users Guide: "If you have read it cover to cover, send me your CV"
20:55:57 <monochrom> I also learned GADTs there. I also learned multiple parameter type class there.
20:56:18 <c_wraith> markasoftware: a type family takes types as arguments.  You write type instances which pattern-match on types and produce a type.
20:56:22 <ryantm____> monochrom: I figured it out! If I remove the (Show a) constraint, it works
20:57:04 <c_wraith> markasoftware: the original paper discusses uses of the feature, if you are looking for them: https://pdfs.semanticscholar.org/8dd2/c7c64451e6dda5d72351ef5c75d091352e05.pdf
20:57:36 <c_wraith> markasoftware: I know, "paper" is often a dirty word, but Simon Peyton Jones is a fantastic author.  His papers are all readable because they use code instead of random symbols. :)
20:57:53 <markasoftware> oh, is that the guy who made the "haskell is useless" video?
20:58:14 <EvanR> type families seem to be named after indexed families of types, that is, a mapping from some index type A to types, A -> Type. However the Haskell feature doesn't allow you pick the type A...
20:58:47 <markasoftware> coming from js all this type stuff is new to me
20:58:53 <markasoftware> before its just put anything together and it will work
20:58:57 <ezyang> "not just the video" ;) 
20:59:02 <monochrom> type-indexed family of types.
20:59:38 <ryantm____> ezyang: ha!
21:00:10 <Whatishisname> yo
21:00:14 <EvanR> markasoftware: after using haskell for so long, i seem to recall it the opposite way around. Most stuff i put together in js does NOT work...
21:00:25 <markasoftware> yep, hopefully that's how I'll be thinking in 6 months
21:00:29 <Whatishisname> is this the most popular haskell channel
21:00:29 <EvanR> at least not until some monumental mental efforts
21:00:30 <Whatishisname> ?
21:00:39 <markasoftware> Whatishisname: yes
21:00:39 <monochrom> Yes.
21:00:49 <markasoftware> EvanR: is your username based on Yesod resource naming scheme?
21:00:50 <Whatishisname> ok am gonna hang here then
21:01:12 <c_wraith> markasoftware: yes, he is the one from that video.  He's also been one of the main authors of GHC for over 20 years.  He knows a bit about it. :)
21:01:17 <markasoftware> js is sh*t to debug though
21:01:19 <Whatishisname> I tried doing a crash course on lambda calculus
21:01:23 <Whatishisname> seemed very simple
21:01:29 <Whatishisname> am I missing something?
21:01:30 <monochrom> I learned js after haskell. And everything I put together works. Both side.
21:01:32 <EvanR> my username is actually based on a suggestion by eric S raymond to not use silly names online
21:01:49 <Whatishisname> I learnt Java first
21:01:55 <Whatishisname> now learning JS
21:01:59 <monochrom> I even trampolined correctly in js.
21:02:25 <Whatishisname> JS seems like a confused person to me
21:02:25 <markasoftware> monochrom: what a god
21:02:32 <Whatishisname> it has its hands in everything
21:02:33 <markasoftware> not as bad as php at least
21:02:36 <EvanR> well now that i see imaginary types in js, it works more often
21:02:58 <markasoftware> "5 dogs" == "5.00000000000000000000000000000001" => true in js
21:03:01 <markasoftware> i mean php
21:03:03 <markasoftware> sorry
21:03:06 <markasoftware> definitely not true in js
21:03:12 <Whatishisname> anyone know lambda calculus?
21:04:01 <monochrom> how much do I have to know to qualify as your "know"?
21:04:11 <Whatishisname> that's right
21:04:22 <Whatishisname> the eternally unsure knowledable guy
21:04:32 <Whatishisname> you know enough
21:04:42 <monochrom> I concur.
21:04:47 <Whatishisname> First am consued about how zero is notated
21:05:01 <Whatishisname> then it seems all too simple
21:05:09 <Whatishisname> that I don't know what the fuss is about
21:05:23 <Whatishisname> confused*
21:05:25 <EvanR> LC was an attempt at a formal language for logic, but they messed up and made a programming language instead
21:05:35 <monochrom> haha
21:05:44 <Whatishisname> oh nice nice that explains a bit
21:06:00 <dhalgren_> what do you expect? what fuss? afaik its supposed to be a minimalist abstract formalism of what an "algorithm" is, analogous to the turing machine 
21:06:08 <monochrom> I am not going to address "what the fuss". I don't care.
21:06:24 <Whatishisname> ok then
21:06:26 <monochrom> But if you see that things work out as claimed, you already understand.
21:07:02 <Whatishisname> I don't see any difference
21:07:15 <monochrom> And if you don't see how things work out, I can answer.
21:07:21 <Whatishisname> its the same thing deep down
21:07:37 <Whatishisname> instead of a for loop you got like, some notation
21:08:38 <Whatishisname> brb
21:08:45 <EvanR> :t (\x -> x x) (\x -> x x)
21:08:47 <lambdabot> error:
21:08:47 <lambdabot>     • Occurs check: cannot construct the infinite type: t0 ~ t0 -> t
21:08:47 <lambdabot>       Expected type: t0 -> t
21:08:56 <dhalgren_> where do for loop come in? aren't we talking about the 'language' w just lambda abstraction, applicaton and variable
21:09:51 <monochrom> See this is why I won't address "what the fuss". You have already made up your mind. I said "I don't care" because I know that you already don't care.
21:10:22 <Whatishisname> monochrom I got not idea what you are talking about
21:10:30 <Whatishisname> dhalgren um
21:11:10 <dhalgren_> that's the simple l.c. at least afaik
21:11:30 <EvanR> not simple as in simply typed
21:11:42 <monochrom> dhalgren_: "for loop" comes up because "programming" came up, for better or worse.
21:11:57 <Whatishisname> the 'application' part, isn't that just a for loop?
21:12:06 <dhalgren_> EvanR: yeah, untyped I guess
21:12:39 <nshepperd> Whatishisname: you mean the "apply the rewriting rules until none of them apply"?
21:12:50 <monochrom> the untyped one hides its difficulty in the denotational semantics (if you want one)
21:13:12 <Whatishisname> nshepperd yeah
21:13:47 <Whatishisname> function application seems like a list iteration
21:13:50 <EvanR> that would be a while loop
21:14:27 <Whatishisname> sure you don't have to work all the details but aren't they both the same thing?
21:14:31 <nshepperd> I don't think that's really a for loop any more than the cpu of a machine carrying out instructions is
21:14:50 <nshepperd> the cpu executes the current execution and advances the IP until it runs out
21:15:46 <athan> If I have a rose tree, but modified to be a zipper, could I use a lens to focus to a specific point?
21:15:50 <Whatishisname> deep down in the CPU all just jumps
21:15:56 <nshepperd> similarly, the LC 'machine' evaluates the current term by applying rewriting rules until it runs out of rules
21:16:30 <EvanR> if it was all just jumps, you could optimize away the cpu entirely
21:16:56 <monochrom> I think this is a pointless discussion.
21:16:57 <EvanR> or replace it with a simple heater, because there would be no observable result of computation
21:17:09 <Whatishisname> yeah but the 'LC' machine does not exist.
21:17:26 <athan> lambdacalculus machine?
21:17:38 <athan> There's an SK combinator chip thing iirc
21:17:50 <athan> (that I really want to have >.> muh supercombinators)
21:18:20 <Whatishisname> you do it with a for loop or a function application, the machine we got does the same thing
21:18:30 <dhalgren_> I mean, application is just any application of a lambda abstraction to a variable. like where are the implicit for loops in say the  Y combinator Y = λ f . ( λ x . f   ( x   x ) )   ( λ x . f   ( x   x ) ) ?
21:18:55 <nshepperd> monochrom: quite.
21:19:24 <dhalgren_> (actually to a lambda term)
21:19:54 <Whatishisname> dhalgren what does the f stand for?
21:19:58 <athan> dhalgren_: iirc you can turn Y into a recursive pointer thing, but not an explicit for loop, because of decidable termination or something
21:20:06 <Whatishisname> is there a faster way to print people's names?
21:20:16 <Whatishisname> like a shortcut?
21:20:50 <dhalgren_> well its any lambda term, right :)
21:22:02 <Whatishisname> ok the expression you typed, it could be just a sequence of instructions.
21:22:12 <Whatishisname> the loop happens when you supply it an input
21:22:19 <Whatishisname> function application?
21:22:39 <EvanR> so you want to implement lambda calculus with C
21:23:00 <monochrom> No, C is too complex. Use BASIC.
21:23:09 <dhalgren_> well obviously, given that turing machines and lambda calculus are proved to be equivalent. There's a few other formalisms that are equivalent to it too
21:23:17 <Whatishisname> fortunaltely i know just BASIC :D
21:23:39 <Whatishisname> It has a GOSB
21:23:43 <Whatishisname> GOSUB
21:24:12 <Whatishisname> my point is if you pay attention to what is happening deep down, you see no difference between the two styles
21:24:37 <Whatishisname> What is the point of having a different style?
21:24:44 <EvanR> next you will challenge us to prove you wrong
21:24:55 <Whatishisname> How is that?
21:25:01 <EvanR> just a guess
21:25:25 <Whatishisname> ok
21:25:49 <Whatishisname> tell me what benefit is there to programming this way if you know what is happening deep down
21:26:56 <EvanR> no one programs that way
21:27:03 <Whatishisname> dhalgren oh so they are equivalent
21:27:25 <Whatishisname> so its all just semantics
21:27:28 <Whatishisname> then?
21:27:46 <EvanR> by default LC doesnt even come with semantics
21:27:54 <EvanR> its meaningless!
21:28:08 <Whatishisname> :D
21:28:12 <dhalgren_> Whatishisname:  basically 4 mathematicians in about the same time were solving the same problem. 2 together and the other 2 each independently solved it with a formalism of their own. Turing created the turing machine, Church created the lambda calculus, and Godel and Herbrand general recursive functions. THen they proved they are all equivalent. 
21:28:41 <Whatishisname> dhalgren oh I did not know
21:28:55 <Whatishisname> I though LC was this special new something
21:28:57 <Whatishisname> :D
21:29:09 <dhalgren_> this was in the  early 1930s.  :)
21:29:46 <EvanR> LC is almost 90 years old, and Begriffsschrift is even older
21:30:04 <Whatishisname> ok what else can you do with this style. other than having shorter code?(coz of the implicit loops)
21:30:07 <EvanR> and calculus ratiocinator is even older
21:30:35 <Whatishisname> what is that?
21:31:02 <Whatishisname> dhalgren what was the problem they were trying to solver?
21:31:08 <Whatishisname> solve*
21:33:37 <Whatishisname_> I got dced
21:33:53 <Whatishisname_> I work with a group of people who don't see the point of say OOP, patterns etc
21:34:02 <Whatishisname_> Its all a rearrangement of code to them
21:34:16 <Whatishisname_> and unecessarily complicating things
21:34:34 <dhalgren_> formalizing what a "computable function" really is; basically showing that if a human could calculate something, at least given infinite resources and time, then so could a turing machine/lambda expression etc.
21:34:45 <Whatishisname_> it is much easier to manually fix everything than any benefit those things provide
21:35:12 <Whatishisname_> ok the idea of what is 'computable'
21:35:13 <EvanR> not a human
21:35:40 <monochrom> I don't see the point of OOP either.
21:36:09 <EvanR> if an "idealized mathematician", one who only carries out a fixed algorithm, who can follow the instructions exactly without messing up, but ultimately unable to do any "genuine reasoning" of his own
21:36:18 <EvanR> could do it, so could a turing machine
21:36:56 <monochrom> I do see the point of patterns. They mean the language you chose is too dumb to make your boilerplate a procedure, so you have to keep writing the boilerplate and you call it a pattern to feel better.
21:36:56 <Whatishisname_> so the idea of which task does not involve any thinging other than calculations
21:37:03 <Whatishisname_> thinking*
21:37:05 <dhalgren_> yes, a human following an algorithm, sry
21:37:47 <monochrom> You can see more past computers in the movie HIdden Figures.
21:37:48 <dhalgren_> I should really stop talking mathematics in a room with matematicians present, my sloppiness is bound to irritate :D
21:37:50 <Whatishisname_> A machine can do add. that's about it
21:37:54 <EvanR> a human may be able to make progress enumerating busy beaver numbers, but we now know a computer cant
21:37:59 <Whatishisname_> everything is else is derived off that
21:38:07 <monochrom> And you will see that they will learn programming too.
21:38:12 <Whatishisname_> wait also read and write to a storage
21:39:13 <EvanR> hmm, maybe a computer can
21:39:16 <Whatishisname_> off of reading and writing to storage, you get registers
21:39:16 <monochrom> @quote monochrom substitut
21:39:16 <lambdabot> monochrom says: Dilbert's substitutability principle.  A subclass's programmer should work as a drop-in replacement of his/her predecessor.
21:39:18 <EvanR> but not an algorithm
21:39:44 <Whatishisname_> if you make the location of read write variable then you get an index register
21:39:55 <Whatishisname_> you get sequential computing
21:39:56 <Whatishisname_> jumps
21:40:13 <Whatishisname_> hmm what would be an if statement
21:40:20 <Whatishisname_> a comparision
21:40:31 <EvanR> none of this pertains to haskell
21:40:48 <EvanR> im here to kick ass and do haskell
21:40:49 <Whatishisname_> it pertains to computers
21:40:51 <Whatishisname_> :D
21:41:03 <Whatishisname_> and what is computable
21:41:18 <EvanR> ideally in haskell
21:41:20 <monochrom> Clearly the foundation of computing is important to a Haskell channel.
21:41:23 <Whatishisname_> Am trying to figure out the point of what the mathematicians did
21:41:39 <monochrom> Next you're going to learn quantum mechanics with me because it's how computers work.
21:41:42 <Whatishisname_> what was the point of LC or turing machine
21:41:48 <Whatishisname_> it seems so straight forward
21:41:51 <Whatishisname_> :(
21:42:06 <EvanR> i have a few books here which go into the point
21:42:10 <glguy> Sorry Whatishisname_, the topic of this channel is *specifically* Haskell programming rather than anything related to computers
21:42:14 <EvanR> blurbs dont do it justice
21:42:20 <monochrom> Yes quantum mechanics is straightforward and obvious too. At least according to Scott Anderson.
21:42:20 <Whatishisname_> maybe at that time they had no concrete proof of anything
21:42:38 <EvanR> you are pretty close
21:42:47 <Whatishisname_> how about the point of lambda calculus?
21:42:53 <Whatishisname_> glguy
21:42:57 <Whatishisname_> I wills top spamming
21:43:18 <EvanR> in the late 19th century peano was famous for publishing mathematical works where each step in the "proof" merely looked like the previous step
21:43:18 <Whatishisname_> you see to a guy here it is very hard to explain this
21:43:43 <EvanR> no basis for how you get from one step to the other was given in most of his work
21:44:47 <EvanR> up to that point mathematical proofs consisted of a lot more "intuitive" reasoning, rather than what we now consider logic
21:44:52 <Whatishisname_> so we need proofs for...
21:45:12 <monochrom> me
21:45:19 <Whatishisname_> peano was it?
21:45:20 <monochrom> I demand proof.
21:45:22 <EvanR> frege said fuck that, but was larely unknown until the 1920s
21:45:48 <Whatishisname_> all this history is lost here
21:45:58 <Whatishisname_> we only see the present
21:46:02 <Whatishisname_> :D
21:46:16 <Whatishisname_> and noone agrees on one way of doing stuff
21:46:20 <Whatishisname_> anyways thanks guys
21:46:23 <Whatishisname_> am done
21:46:33 <EvanR> history of haskell from the 80s to 2011: http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf
21:53:38 <dhalgren_> Whatishisname_: maybe more relevant than its matemathical roots to practical matters was how the abstract, conceptual turing machine inspired very real practical computer architectures, and how lambda calc inspired programming language design - or at least the Lisp family, and by now you have the key elements, like first class functions, closures in quite a number of languages.
21:54:05 <Whatishisname_> What is a boilerplate? monochrom
21:55:35 <Whatishisname_> dhalgren
21:55:48 <Axman6> it's repetitious code that you have to write every time you do X
21:56:24 <Whatishisname_> I know long time back it was a different time. Things we assume to be normal now might have been new and unique
21:56:32 <Whatishisname_> but good point.
21:59:36 <Whatishisname_> difference between high class functions and objects, isn't it just that objects got more functions in them by default?
21:59:59 <Whatishisname_> and by funtion and objects I mean a block of code
22:00:12 <Whatishisname_> with their address location 
22:00:48 <dhalgren_> Whatishisname_: think you can look at it almost like that: http://www.c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent
22:00:50 <ertes> if you insist on identifying things with their address and/or block of code, you will not learn anything interesting about them
22:01:18 <Whatishisname_> but that is how it is
22:01:29 <Whatishisname_> everything else is imainary and not real
22:01:33 <ertes> nope…  try to get the address of a function in haskell
22:01:49 <Whatishisname_> it is there deep down in the implementation
22:01:51 <Whatishisname_> just hidden
22:02:03 <ertes> that's not a function…  that's machine code
22:02:16 <ertes> machine code is not very interesting in terms of what functions are
22:02:26 <Whatishisname_> a function is a block of machine code, with its starting address known
22:02:37 <ertes> wrong…  that's what a C function is
22:02:40 <Whatishisname_> Maybe you can substitude some variables it refers to
22:02:58 <Whatishisname_> yeah C is the closes to machine language
22:03:01 <ertes> if you translate C/assembly concepts to haskell, again, you will not learn anything interesting about functions
22:03:02 <Whatishisname_> clsest*
22:03:06 <Whatishisname_> closest*
22:03:18 <Whatishisname_> There is nothing interesting
22:03:25 <Lokathor> Whatishisname_, I think the trouble here is that you're still using the C-language version of the word "function", but here in the land of Haskell we used the math form of the word
22:03:31 <Whatishisname_> maybe the way its handled slightly differs
22:03:47 <Lokathor> in other words, a funciton is an operation that takes one input and gives one output and that's all
22:03:56 <ertes> it's only when you let go of this particular insistence that functions become an abstract concept that we can reason about
22:04:03 <Whatishisname_> Am interested in new lower level abstactions. 
22:04:07 <gdfgdfh> exit
22:04:12 <Whatishisname_> Higher level abstactions are boring
22:04:24 <Lokathor> Whatishisname_, higher level abstractions are the only ones worth having
22:04:28 <ertes> then you may be in the wrong channel
22:04:47 <Whatishisname_> ertes i thought functional programming was it
22:04:54 <Whatishisname_> but I should leave
22:05:03 <ertes> also i'd argue that "lower level" by definition means less abstraction, so i'm not even sure what you're asking for
22:05:28 <ertes> functional programming and in particular haskell are not low level…  quite the opposite
22:05:35 <Whatishisname_> I am talking about machine language techniques
22:05:54 <Whatishisname_> not sure if that would be an abstaction
22:05:55 <Lokathor> ah, this is very much not the channel to help with machine language techniques
22:06:04 <Whatishisname_> yes cya
22:06:24 <Lokathor> what an odd fellow
22:06:40 <dhalgren_> I'm confused. I took it you simply wanted to understand what's actually going on, "behind the screen" when some haskell prog is executed?
22:06:52 <Whatishisname_> yes
22:07:02 <Whatishisname_> dhalgren
22:07:06 <Whatishisname_> and you explained it to me
22:07:37 <Whatishisname_> It was vry helpful
22:07:42 <ertes> now if you're interested in new ways to solve engineering problems, this channel is probably the best place =)
22:07:46 <Whatishisname_> Lets talk about haskell now
22:07:49 <Whatishisname_> am good
22:08:15 <dhalgren_> You could take a look at the compiler's architecture then: there's a couple of languages progressively closer to the machine that haskell is translated into, and you can make the compiler spit out the results of these transformations if you want
22:08:45 <Whatishisname_> dhalgren I want to do that :D
22:08:56 <Whatishisname_> Just before that I wanted to confirm that I wasn't missing anything
22:08:58 <ertes> you should also know that GHC-produced machine code looks *very* different from something like compiled C
22:09:41 <ertes> example: there is no call stack
22:09:54 <Whatishisname_> okay
22:10:23 <ertes> well, there is a call stack, but it's only used when calling foreign functions
22:11:47 <dhalgren_> Whatishisname_: i think it goes something like this haskell -> FC -> STG -> Cmm -> machine or LLVM
22:12:28 <Whatishisname_> looks interesting. will definitely look into int
22:12:31 <Whatishisname_> it*
22:14:22 <Whatishisname_> btw dhalgren you put things into perspective for me
22:14:34 <Whatishisname_> it was very helpful to know other point of views
22:15:50 <Whatishisname_> Mainly why we had the LC
22:15:56 <dhalgren_> thx, glad to be of help
22:16:30 <Whatishisname_> before i read it i thought it is something new I need to learn and use
22:16:37 <Whatishisname_> after i read it i was kind of bummed out
22:17:19 <dhalgren_> :D
22:19:14 <eacameron> I'm reading some stuff from a few years ago and people complain that WriterT has bad space leaks.
22:19:22 <eacameron> Have those been fixed in more recent base?
22:19:42 <ertes> eacameron: they can't be fully fixed…  use StateT
22:20:06 <monochrom> StateT has the same leak.
22:20:18 <dhalgren_> monochrom: prob you meant Scott Aaronson , not anderson :) has a great blog.
22:20:19 <ertes> the fix you're asking for is also unlikely to happen, because there are really three different semantics for WriterT
22:20:21 <eacameron> ertes: As in...they are necessary for abiding by the laws?
22:20:33 <monochrom> Oh! Yes, Aaronson.
22:21:12 <eacameron> ertes: Ah. Hmm...
22:21:37 <monochrom> What I read from someone else right here is that WriterT doesn't have leaks, it's the careless use that causes the leak.
22:21:59 <ertes> eacameron: lazy WriterT is completely lazy, strict WriterT as in transformers is strict on the result tuple, not the value you 'tell'
22:22:39 <monochrom> And the grand conclusion of that discussion (contains a series of examples) is that "it depends". And there were like 5 factors named.
22:23:25 <eacameron> ertes: Oh I see. Yes that makes sense. There are many places to be strict
22:23:36 <eacameron> Which one you want is...up to you.
22:23:51 <ertes> eacameron: in general when you think you need strict WriterT you probably need strict StateT
22:23:53 <eacameron> Probably leading to monochrom's point
22:24:01 <ertes> when you don't you should use lazy WriterT
22:25:33 <ertes> > snd (runWriter (forever (tell "abc")))
22:25:37 <lambdabot>  "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc...
22:26:20 <jle`> > fst (runWriter (forever (tell "abc")))
22:26:26 <lambdabot>  mueval-core: Time limit exceeded
22:26:28 <ertes> the lazy variant is useful when you care more about the log than the actual result, or when you only ever ask for the result after you've consumed the whole log
22:27:04 <nshepperd> monochrom: source on 'StateT has the same leak'? I remember the lack of the 's ->' in StateT's 's -> m (s, a)' being one of the factors that made fixing the leak in WriterT 'impossible'
22:29:18 <monochrom> StateT f >>= k = StateT (\s -> do ~(a, s') <- f s ...  The ~ there.
22:29:18 <nshepperd> because 'foo >> bar' in StateT lets bar decide to evaluate the state given by foo first, whereas WriterT gives you no such choice
22:30:23 <ertes> lazy StateT is useful in the same way
22:31:29 <EvanR> seems ironic that a desirable property of a lazy data structure is productivity
22:32:37 <ertes> but this time you'd want to consume the *result* first
22:32:49 <ertes> > fst (runState (traverse (\x -> modify (x:) >> pure x) [1..]) [])
22:32:53 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
22:33:04 <ertes> and the log will diverge
22:33:09 <nshepperd> monochrom: what about strict StateT?
22:33:25 <monochrom> delete the ~, you get strict StateT.
22:33:33 <jle`> EvanR: isn't productivity the main benefit of laziness?
22:34:02 <jle`> or are you talking about irony with the typical usage of the word 'lazy' heh
22:34:05 <nshepperd> EvanR: the first hacker virtue is productive laziness
22:34:07 <EvanR> this joke just diverged
22:34:42 <c_wraith> jle`: I'd put the fact that programming with combinators results in efficient code as the main benefit of laziness.
22:35:04 <monochrom> But I agree that you can always use "get" and then you have something to bang on.
22:35:12 <ertes> the strict variant of StateT (unlike strict WriterT) lets you force the current state
22:36:23 <ertes> modify' f = f <$> get >>= (put $!)
22:36:33 <ertes> :t \f -> f <$> get >>= (put $!)
22:36:35 <lambdabot> MonadState s m => (s -> s) -> m ()
22:36:54 <EvanR> i want this: someone is trying to learn haskell and is lost when issues like what youre talking about come up, strict vs lazy vs diverging vs efficient vs inefficient, and you give them one exercise to do involving laziness, or a repl expression to evaluate, and it all becomes clear
22:37:02 <monochrom> But I disagree with the cognitive dissonance in asserting "WriteT leaks, StateT doesn't".
22:37:12 <EvanR> or you just need to go back to that one exercise if you need a review
22:37:24 <monochrom> Unfair comparison if you say "after I add more bangs it doesn't leak".
22:37:36 <monochrom> Fair comparison is when you don't add bangs to either.
22:37:55 <c_wraith> EvanR: write https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-List.html#v:dropWhileEnd using foldr.
22:38:00 <ertes> both WriterTs leak with strict mappend
22:38:18 <ertes> StateT gives you the option not to leak (but doesn't do it on its own)
22:38:25 <c_wraith> EvanR: and make sure that it works on infinite inputs as long as there are more characters it won't drop.
22:38:32 <c_wraith> :t dropWhileEnd
22:38:34 <lambdabot> (a -> Bool) -> [a] -> [a]
22:38:44 <monochrom> But who is going to believe me. The whole etymology of "space leak" is founded on the same cognitive dissonance.
22:38:50 <c_wraith> > dropWhileEnd isSpace $ cycle "hello! "
22:38:52 <lambdabot>  "hello! hello! hello! hello! hello! hello! hello! hello! hello! hello! hello...
22:39:18 <ertes> the problem with "space leak" is that it needs a lot more context than "WriterT"
22:39:19 <c_wraith> EvanR: if you can do that, you probably have a pretty solid idea how laziness works.
22:39:21 <nshepperd> that's not what cognitive dissonance means >_<
22:39:42 <EvanR> oh wow
22:40:22 <stephaner> hi everyone, by default if I have a value that changes over time ( a mutable state), should I first think about State monad or STRef ? without performance insight... just the default de-facto standard thing to do. I tend to think it is to use State, just want to be sure.
22:40:22 <monochrom> Would "hypocrisy" work better?
22:40:49 <EvanR> State, probably not
22:41:09 <EvanR> STRef would not be able to remember after the ST action ends
22:41:18 <monochrom> You should think about both simultaneously, concurrently, and in parallel.
22:41:31 <EvanR> so you might want a TVar or IORef
22:41:38 <nshepperd> StateT avoidably leaks. WriterT unavoidably leaks
22:41:40 <monochrom> Actually throw in IORef too. Think all three in parallel and concurrently and whatnot.
22:42:08 <nshepperd> meh. foldr leaks too if you use it on integers
22:42:37 <EvanR> c_wraith: i was also hoping the exercise or repl command was simple and easy ;)
22:43:11 <c_wraith> EvanR: laziness ends up not being simple.  It's useful, but it's not really simple. :)
22:43:39 <stephaner> what do you mean by "leaks", you mean it keeps everything in memory until end of program ? and that's the problem with StateT and WriterT ?
22:43:57 <c_wraith> not until the end of the program - just longer than needed
22:44:04 <stephaner> okay, good to know
22:44:43 <c_wraith> At least, longer than ideal.
22:44:51 <EvanR> the same issue happens in java, and ruby for that matter
22:44:58 <c_wraith> foldl (+) vs foldl' (+) is a common example.
22:45:20 <nshepperd> yeah, 'space leaks' aren't really memory leaks. it's just inefficient use of memory, caused by doing things in the wrong order
22:45:28 <EvanR> you generate data willy nilly and references to stuff remain because youre holding on to them somehow, despite being logically "done" with them
22:47:43 <EvanR> c_wraith: in that case, a pile of exercise in increasing order of difficulty would be in order, specifically about lazy evaluation
22:47:57 <c_wraith> EvanR: that's true
22:48:15 <stephaner> Am I correct to think use IORef when only one thread modifies the value, and TVar otherwise ?
22:48:36 <monochrom> 95% correct.
22:48:39 <ertes> stephaner: what kind of application?  i.e. *why* is the value changing?
22:48:40 <stephaner> :-)
22:48:55 <monochrom> There are 5% of the time when you just need atomicModifyIORef. I did.
22:49:02 <stephaner> it's a list of subscribers over network
22:49:12 <EvanR> values never change, even in languages with mutable variables
22:49:13 <athan> stephaner: Also, there are STRefs
22:49:20 <ertes> stephaner: so it changes in response to events?
22:49:31 <stephaner> atyep
22:49:36 <athan> wait.. STRefs are multithread capable, right?
22:49:45 <monochrom> No, STRef is very private.
22:49:58 <athan> D: disregard my naevity
22:49:59 <ertes> stephaner: then you may want to look at FRP as well, unless heavy concurrency is going on
22:50:13 <stephaner> no, it's a pet project for the moment
22:50:27 <EvanR> why would you *not* want FRP when heavy concurrency is going on :(
22:50:38 <ertes> stephaner: what you're describing sounds like a behaviour from FRP
22:50:52 <ertes> EvanR: because none of the currently existing frameworks handle concurrency very well =)
22:51:04 <EvanR> thats a terrible answer!
22:51:15 <lpaste_> qmm pasted “help requested on matching up the types ” at http://lpaste.net/352299
22:51:30 <ertes> EvanR: yeah, sometimes the truth is terrible =)
22:51:33 <lpaste_> qmm pasted “help requested on matching up the types ” at http://lpaste.net/352300
22:53:45 <stephaner> monochrome: what did you mean by STRef is very private ?
22:54:14 <osa1> is the freer monad paper a continuation of the extensible effects paper?
22:54:22 <monochrom> Even within one thread, you can't always access it.
22:55:06 <monochrom> If you write "runST ( ... v <- newSTRef xxx ....)" v is invisible outside that runST block.
22:55:11 <qmm> strange, i received an error the first time i posted
22:57:31 <phadej> qmm: first V.zip should bbe just (,) ?
22:59:16 <phadej> or maybe not, my mental type-checker cannot handle that
22:59:37 <qmm> same 
22:59:44 <monochrom> I have doubt about the part V.zip (V.head v) $ V.singleton ["foo"]
23:00:06 <qmm> phadej: the second argument to V.cons drops the head of the Vector and then adds urls "to the beginning" 
23:00:32 <qmm> it kind of ends up with something like [("url string", "the rest of the csv row"), etc.]
23:00:54 <monochrom> What is the type of urls?
23:01:03 <qmm> the first argument is mainly just to put the dropped row back into the vector
23:01:18 <qmm> it's a list of strings
23:01:22 <qmm> ["String"]
23:01:24 <qmm> er..
23:01:26 <qmm> [String]
23:01:27 <phadej> qmm: I'd suggest using lenses to do such adhoc editing :P
23:01:41 <monochrom> Not even [ByteString]?
23:01:46 <qmm> oh, i'm wrong...
23:01:47 <qmm> urls :: [[Char]]
23:02:08 <phadej> original & ix 0 %~ ...
23:02:21 <qmm> i'm right :)
23:02:57 <monochrom> OK, V.drop 1 v has type Vector (Vector ByteString).
23:03:38 <monochrom> No, wait, why are you even zipping? Not the right thing to do.
23:03:47 <monochrom> Or rather, not the right way to get what you want.
23:04:11 <qmm> yeah, it seems like this is going to be a nightmare to sort back together
23:04:25 <qmm> i'm zipping because i asked a question earlier
23:04:29 <monochrom> You're supposed to be V.zipWith V.cons, if anything
23:04:44 <qmm> question asked earlier: i want the equivalent of this in haskell without the crashing :) https://paste.pound-python.org/show/OhdCM4AmuTnML3xSVruP/
23:04:52 <monochrom> Or V.zipWith V.append, depending on the detail.
23:08:11 <monochrom> Which one are you more familiar with, [] or Vector?
23:08:16 <qmm> []
23:08:34 <qmm> today was the first day i came across Data.Vector
23:08:37 <monochrom> OK, aeson can totally do [[ByteString]]. You should start with that first.
23:09:19 <osa1> which library do you use for MTL-style logging monad class (extra points if it provides a transfomer too) ?
23:09:26 <monochrom> Later you can go Vector (Vector ByteString) after you understand the basic algorithm in terms of []. It will be a tractable substitution.
23:09:36 <qmm> monochrom: Vector seems more familiar than Aeson
23:09:40 <qmm> i haven't used aesone before
23:09:52 <qmm> the reason i think it seems more familiar is that it has familiar functions from []
23:10:01 <qmm> maybe they don't work how i imagine though
23:10:42 <monochrom> aeson is pretty much unbiases and neutral between "list vs vector, which one?". So start with the easier one.
23:11:20 <monochrom> I can continue with Vector if you want. I am neutral too. But I want you to know you have a choice.
23:11:57 <monochrom> Do not rely on slight pretexts such as "I saw one Vector-using example".
23:12:08 <monochrom> (one is not enough. a million would be.)
23:13:08 <qmm> i'm open to the easier solution, whichever one that is
23:13:11 <monochrom> In terms of list, you will have to worry about this:
23:13:23 <monochrom> > zip [1,2,3,4] ["x"]
23:13:25 <lambdabot>  [(1,"x")]
23:13:40 <monochrom> It will truncate not extend. This will not be what you want.
23:14:09 <monochrom> The same issue will happen to V.zip. You understand one version, you understand both.
23:14:11 <qmm> > zip ["x"] [1,2,3,4]
23:14:14 <lambdabot>  [("x",1)]
23:14:19 <monochrom> Same problem.
23:14:22 <qmm> that's what i want
23:14:32 <qmm> i only have about 50 urls but about 1000 rows
23:14:48 <qmm> i want to insert about 50 urls and leave the rest of the rows untouched
23:15:01 <monochrom> Are you sure? Because your example shows unpaired ['qux'] and ['zoo'] being preserved.
23:15:10 <qmm> yep, that's exactly what i want
23:15:20 <monochrom> whereas zip will lose things seriously
23:16:51 <qmm> > zip [1,2,3,4] ["url1", "url2"]
23:16:53 <lambdabot>  [(1,"url1"),(2,"url2")]
23:16:58 <qmm> not desired
23:17:08 <qmm> > zip ["url1", "url2"] [1,2,3,4] 
23:17:11 <lambdabot>  [("url1",1),("url2",2)]
23:17:19 <qmm> er..
23:17:32 <qmm> sorry, i want the 3 and 4 
23:18:05 <qmm> i want "unpaired ['qux'] and ['zoo'] being preserved."
23:18:24 <qmm> guess 'zip' is out
23:18:56 <qmm> (sorry for the confusion)
23:19:47 <monochrom> @let emerge xs yss = zipWith (++) (map (:[]) xs ++ repeat ([])) yss
23:19:50 <lambdabot>  Defined.
23:19:57 <monochrom> > emerge ["1", "2"] [["foo"], ["bar"], ["john"]]
23:20:00 <lambdabot>  [["1","foo"],["2","bar"],["john"]]
23:20:46 <monochrom> But you need to know that if you now encode that table into csv...
23:21:06 <monochrom> First column will be "1", "2", "john"
23:21:33 <monochrom> And actually I am not sure whether aeson will like the fact that the 2nd column is shorter.
23:22:02 <monochrom> I'm wondering if you should want [["1","foo"],["2","bar"],["", "john"]] instead.
23:23:26 <monochrom> (:[]) is probably too nerdy. It means (\x -> x:[]) i.e. (\x -> [x])
23:24:02 <qmm> that seems very much ideal
23:24:16 <qmm> [["1","foo"],["2","bar"],["","john"]]
23:24:50 <monochrom> OK, that's an easy change.
23:24:55 <monochrom> @undefine
23:24:55 <lambdabot> Undefined.
23:25:06 <monochrom> @let emerge xs yss = zipWith (++) (map (:[]) xs ++ repeat ([""])) yss
23:25:08 <lambdabot>  Defined.
23:25:13 <monochrom> > emerge ["1", "2"] [["foo"], ["bar"], ["john"]]
23:25:15 <lambdabot>  [["1","foo"],["2","bar"],["","john"]]
23:25:29 <qmm> [["url", "stuff", "another column", "colum4"], ["url2", "morestuff", ...]]
23:25:56 <stephaner> do you know if it is posible to filter out the join and quit messages on the irc channel ?
23:26:07 <qmm> stephaner: which irc client
23:26:13 <stephaner> freenode
23:26:22 <stephaner> I should have a dedicated application ?
23:26:23 <qmm> irssi, weechat, etc
23:26:25 <monochrom> Depends on what software you use for irc.
23:26:31 <stephaner> okay
23:26:50 <qmm> for irssi, it's /ignore -channels #chan1,#chan2,#chan3 * JOINS PARTS QUITS NICKS
23:27:00 <monochrom> You using the web page thing? Look around there, it may have a setting. Or not.
23:27:56 <monochrom> > emerge ["1", "2"] [["foo", "d"], ["bar", "e"], ["john", "son"]]
23:27:57 <stephaner> perfect! thanks. it is indeed an option in FreeNode.net
23:27:58 <lambdabot>  [["1","foo","d"],["2","bar","e"],["","john","son"]]
23:30:00 <bollu> cocreature: how stable are the LLVM haskell bindings?
23:30:02 <qmm> guess i should look into V.toList
23:30:31 <monochrom> No, if you want Vector, keep it Vector all along. Don't make an XY problem.
23:31:06 <monochrom> zip just becomes V.zip, map just becomes V.map. repeat is harder, I'm looking for a substitute.
23:31:07 <qmm> something has to be converted 
23:31:35 <monochrom> Are you sure?
23:31:39 <qmm> urls has type [String]
23:32:09 <monochrom> You know, you need to convert String to ByteString too.
23:32:15 <cocreature> bollu: our fork or llvm-general?
23:32:30 <qmm> map (\s -> "https://myurl.com/images") ++ s) (drop 2 $ getDirectoryContents "./static/images")
23:32:44 <cocreature> bollu: also what exactly do you mean by “stable”?
23:32:44 <qmm> that's how urls is defined
23:33:21 <qmm> oops, forgot to add the last forward slash
23:35:06 <qmm> csvData <- BL.ReadFile "./static/data.csv" ; case decode NoHeader csvDtaa :: String (V.Vector (V.Vector BL.ByteString)) of ...
23:35:30 <qmm> (typo just now)
23:35:37 <osa1> how do I actually print a LogStr in when defining a logger function for LoggingT (monad-logger) ?
23:36:37 <bollu> cocreature: well
23:36:55 <bollu> cocreature: I'm building LLVM with polly, which is an LLVM pass. Can I use the given FFI to target this LLVM?
23:37:30 <qmm> osa1: logDebug ?
23:37:33 <qmm> Generates a function that takes a Text and logs a LevelDebug message. Usage:
23:37:40 <qmm> $(logDebug) "This is a debug log message"
23:38:12 <osa1> qmm: no, I mean in the function with type `(Loc -> LogSource -> LogLevel -> LogStr -> IO ())` to run LoggingT
23:38:13 <qmm> oh, wrong type, nm
23:39:38 <osa1> do I need fast-logger for that?
23:39:49 <qmm> fast-logger has this in it
23:39:49 <qmm> pushLogStr :: LoggerSet -> LogStr -> IO ()
23:39:53 <qmm> "Writing a log message to the corresponding buffer.
23:40:08 <qmm> i'll be quiet
23:40:56 <cocreature> bollu: not easily iirc. the haskell bindings have an ADT that lists passes and if your pass is not in there you’re out of luck. fixing this is on my todolist but I haven’t gotten around to it yet. if you mess with the external modules (which need to be exposed first) you could probably achieve what you want relatively easily
23:41:24 <bollu> cocreature: I see
23:41:32 <bollu> cocreature: any way I can help with the effort?
23:43:36 <cocreature> bollu: mostly we need to come up with a decent API that allows users to supply custom passes without modifying llvm-hs. I don’t yet know how that API would look like so any ideas are appreciated. it might also make sense to do this directly for llvm’s new pass manager since otherwise we are going to have to rethink this relatively soon.
23:44:01 <cocreature> bollu: just opening an issue and adding any ideas you have to that would already be helpful
23:51:49 <jchia> cabal/stack question: What's the different between --enable-executable-profiling & --enable-library-profiling? What do 'executable' & 'library' refer to? Do they mean code for executables & code for modules respectively?
23:57:06 <ezyang> jchia: It's terrible and you shouldn't pay much attention to it 
23:57:27 <ezyang> but basically, it just controls whether or not the library is built with profiling, and whether or not the executable is built with profiling 
23:58:22 <jchia> ezyang: Can I say I want profiling for my project libraries & executables but not for packages that my project uses?
23:58:52 <ezyang> That's a different issue 
23:59:15 <ezyang> you must compile every library transitively depended upon with profiling 
23:59:26 <ezyang> but you're probably asking about what cost centers get stats reported 
23:59:28 <jchia> ezyang: I suppose what I'm looking for doesn't exist, then
23:59:59 <jchia> For debugging, I just want to see my own functions in a stack trace when I get an error.
