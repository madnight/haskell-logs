00:03:11 <mniip> hmm
00:03:16 <mniip> finally decided to read maclane
00:03:41 <mniip> curiously, he defines Matr but not Vect?
00:03:57 <tfc> isnt a vect a matr?
00:04:45 <mniip> no?
00:04:53 <mniip> there are objects in Vect that aren't in Matr
00:05:01 <mniip> infinite dimensional vector spaces
00:05:25 <mniip> you can't talk about linear maps as of matrices anymore
00:05:44 <tfc> ok. i do actually not know what library you are talking about. just guessed that it's something purely mathematical, where it would make sense to regard a vector as a Nx1 matrix. :)
00:06:03 <mniip> I'm reading MacLane's book on category theory
00:06:36 <tfc> i see
00:06:36 <mniip> Matr is a category he defines in the book
00:07:09 <mniip> Matr_K over ring of scalars K to be precise
00:27:46 <tfc> i started to read about parallel&concurrent programming in haskell because i will need that stuff soon.
00:27:58 <tfc> is there any better reference as for example http://community.haskell.org/~simonmar/par-tutorial.pdf ?
00:40:10 <erisco> hrm
00:40:26 <erisco> I can't seem to convince Haskell that there is a sing for all Nat
00:40:39 <erisco> I shouldn't need SingI n in context when n is a Nat
00:42:06 <erisco> not sure this is a weakness that can be overcome
00:43:37 <erisco> I guess Haskell can't always be that smart
00:48:40 <erisco> GHC doesn't yet support impredicative polymorphism
00:56:42 <erisco> one solution would be to carry the SingI context around everywhere... but that would be rather burdensome
00:58:28 <erisco> it is sort of strange because Haskell whines there are two SingI instances for Nat
00:59:00 <erisco> but then there are exactly two cases for Nat
00:59:43 <erisco> I dunno, maybe the underlying implementation just wouldn't work
01:11:31 <erisco> ah ha, I figured out something that seems good
01:13:51 <erisco> I worked my way to the grand proof of (a :<= b) := ((a :< b) :\/ (a := b)) lol
01:20:30 <nilof_> ...The minesweep clear operation is a rather interesting problem to solve without mutation
01:26:35 <Axman6> how so? a nieve implementation involves just iterating a set of coordinates and their empty neighbours until the set doesn;t change
01:27:53 <nilof_> Yes, but it's easy to make it behave badly asymptotically
01:28:48 <Axman6> how big di you plan to make you games? =)
01:29:31 <nilof_> well, I would like a 50 x 50 grid to be possible
01:30:02 <Axman6> doesn't sound too bad
01:30:03 <nilof_> well, to be fair that shouldn't be too bad
01:30:05 <erisco> computers can eat that for breakfast
01:31:21 <nilof_> But I'm curious about how to make it perform similarly to the imperative queue & mutable grid approach where you do a breadth first traversal
01:31:59 <nilof_> I think a lazy data structure is what I need here
01:35:15 <Axman6> might be able to do something efficient using efficient using lazy arrays
01:37:12 <Axman6> tfc: The book you're reading is about as good as it gets
01:37:20 <tfc> Axman6: thx
01:42:50 <erisco> hm, I think type family injectivity might be too conservative
01:43:21 <erisco> http://lpaste.net/352101
02:44:04 <zipper> What is the difference between `decode` and `decode'` ?
02:44:13 <zipper> Seems the same here https://hackage.haskell.org/package/aeson-1.1.0.0/docs/Data-Aeson.html
02:45:23 <Akii> "This function parses and performs conversion immediately."
02:45:34 <Akii> decode "defers conversion"
02:46:10 <zipper> Akii: SMH how did I miss that? :(
02:46:47 <Akii> well interesting detail I didn't know
02:47:18 <Akii> this also seems to be kind of a konvention; e. g. see foldl'
02:47:22 <Akii> and stuff
02:55:51 <the_2nd> How can I convert a [Maybe a] -> Maybe [a]   where result is just if all inital values were just
02:56:11 <the_2nd> sequence looks similar to what I want
03:11:21 <wz1000> How do I define the fixity of type operators?
03:16:42 <phadej> wz1000: in the very same way as for value-level
03:18:11 <wz1000> phadej: How are ambiguities resolved?
03:18:22 <wz1000> Supposing I use the same operator on the type and value level
03:19:05 <phadej> AFAICS they have to have same fixity
03:19:17 <phadej> (otherwise it would be confusing)
03:30:48 <pavonia> This is more an algorithm question, but I can't seem to come up with how to transform a list L of 2k elements into 2k-1 sublists of k pairs (order doesn't matter) such that a) each sublist includes all elements of L, b) there's no duplicate pair in all the sublists, and c) all possible pairs are present in all the sublists
03:31:30 <pavonia> e.g. [0,1,2,3] would become [[(0,1),(2,3)], [(0,2),(1,3)], [(0,3),(1,2)]]
03:35:02 <dramforever> the_2nd: catMaybes
03:35:10 <dramforever> But you're gone?
03:35:15 <dramforever> :t catMaybes
03:35:16 <lambdabot> [Maybe a] -> [a]
03:35:35 <dramforever> :t sequence -- sorry I meant this
03:35:37 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
03:36:03 <tfc> dramforever: i was also about to answer sequence. but he was gone already.
03:36:41 <dramforever> Let's hope he figured it out
03:42:36 <tfc> dramforever: got to love the feature of hoogle to query for types of functions. :D
03:43:39 <dramforever> If this were javascript I would never figure this out
03:43:51 <dramforever> BECAUSE practically no types
03:44:05 <tfc> dramforever: i hate all languages with dynamic types. it's just not for me.
03:44:28 <tfc> i've built complex things in python and shoot in my foot all the time for the same reasons: type errors
03:53:42 <systadmin> Hi
03:57:22 <dramforever> systadmin: Hi :)
03:58:10 <dramforever> If you've got any questions just ask and you'll get answers if someone knows and sees you :)
03:59:58 <ph88> i'm not sure how to read this https://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Unicode.html#isSpace could anyone tell me if it matches 0x202f unicode for NARROW NO-BREAK SPACE  ?
04:00:30 <ph88> let me try, d0h
04:00:54 <dramforever> > isSpace '\x202f'
04:00:56 <lambdabot>  True
04:01:00 <dramforever> Yes it is space
04:01:07 <dramforever> > isSpace '\x203f' -- sanity check
04:01:08 <ph88> oh it does
04:01:10 <lambdabot>  False
04:01:15 <ph88> o_O
04:01:16 <dramforever> Looks good enough
04:01:26 <ph88> ok
04:15:40 <xa0> any difference between break isSpace and head.lex
04:15:58 <xa0> oh, wtf, what a timely coincidence you're already talking about it
04:16:37 <xa0> whutevs
04:18:15 <dramforever> > lex "1,2,3,4,5"
04:18:18 <lambdabot>  [("1",",2,3,4,5")]
04:18:28 <dramforever> > break isSpace "1,2,3,4,5"
04:18:30 <lambdabot>  ("1,2,3,4,5","")
04:18:36 <dramforever> xa0: yes, obviously
04:20:09 <xa0> oh right yeah
04:20:22 <xa0> i forgot what lex did
04:57:58 <cocomo> hi, how do you destruct a list in function definition fn (x:xs) = ... is this the right syntax?
04:59:27 <dramforever> yes
05:00:10 <michaelt> cocomo: but don't forget the other case!
05:00:39 <sternmull> in which package is floldr' and floldl'? The Prelude seems to only provide the non-strict versions.
05:00:45 <cocomo> thank you very much.
05:01:00 <michaelt> sternmull: foldl' is in Data.List is that what you mean?
05:01:16 <michaelt> it should be in the Prelude I would think
05:02:16 <sternmull> michaelt: Yes think that is what i was looking for. Thanks.
05:02:36 <michaelt> sternmull: it is the left fold, foldl' where strictness is especially an issue.
05:03:53 <sternmull> michaelt: I am reading about strictness and wanted to play with the different folds. But the tick-versions are not defined and i saw no information where they should come from.
05:08:11 <michaelt> sternmull: I remember learning a lot about foldr foldl foldl' from say pp 7-40 of this http://www.slideshare.net/tibbe/highperformance-haskell The author is maybe a little hard on strictness and it's now pretty old, but it has lots of nice information
05:08:28 <michaelt> hard on /laziness/ rather
05:10:29 <cocomo> using fn name (x:xs) = ... for destructuring List a core feature or does it requires importing a package? 
05:10:58 <michaelt> it's hard to think of a more core feature than that
05:11:37 <cocomo> I am using a flavor of haskel where it is complaining that (:) unknown operator.
05:12:44 <michaelt> oh what version
05:12:47 <michaelt> > let fn name [] = []; fn name (x:xs) = (name,x) : fn name xs in fn "hi" ["Meredith", "Steve"]
05:12:49 <lambdabot>  [("hi","Meredith"),("hi","Steve")]
05:13:33 <cocomo> is it allowed to ask about purescript here? its a flavor of haskel
05:14:18 <michaelt> oh purescript doesn't use : [] etc
05:14:24 <michaelt> I think there's a #purescript
05:15:39 <cocomo> michaelt: thank you. they don't have many users. its very quite there
05:16:58 <sternmull> hm, ghci uses around 90MB when i call "print (foldl' (+) 0 [1..1000000])". Isn't that supposed to avoid such allocations?
05:23:03 <tfc> sternmull: how did you measure that it's using 90mb? i have no answer to your question, but i am curious
05:23:49 <sternmull> tfc: By using ":set +s" ghci tells me duration and memory usage after each call.
05:24:31 <tfc> oh that is useful. thank you
05:24:42 <hpc> that number isn't the maximum resident memory, it's the total number of allocations
05:24:52 <hpc> optimizations will probably make it mutate in place
05:25:08 <hpc> but the benefit of foldl' over foldr in that particular case is that you simply don't overflow
05:25:44 <simendsjo> I tried asking the following in #haskell-beginners some time ago, but I'll try reposting here as I didn't get any answers: I'm having some big issues trying to understand ((sequence .) . fmap). I think its the combination of composition, type-classes, higher-order functions and parametric polymorphisms that is causing a lot of confusion. I'd be happy if someone could look at my "understanding" of this and point out my mistakes:
05:25:44 <simendsjo> https://gist.github.com/simendsjo/ddcfd2dc88c98cf273bacebcbee1c1ce
05:25:44 <simendsjo>  
05:25:53 <hpc> most of the time, ghc's memory allocations consist of incrementing a register, so it's not something you should try to optimize first
05:27:03 <sternmull> hpc: How does incrementing a register does cause an allocation?
05:27:19 <sternmull>  maybe i have a different concept of a register...
05:27:31 <dramforever> sternmull: No that's not what it means
05:28:22 <dramforever> GHCi goes, generate a list node, allocate that, generate 1, allocate that, generate another list node, allocate that, generate 2, allocate that, generate 1 + 2, allocate that
05:29:07 <dramforever> But at the same time GC sees, oh hey list node not needed anymore, deallocate that, number not needed, deallocate that, etc.
05:29:48 <tfc> how to uncover then with ghci measures that one optimized variant is better than the other?
05:29:49 <sternmull> so it is simply that ghci does not optimize the allocation of the temporaries away, right?
05:30:04 <dramforever> yes
05:30:10 <dramforever> GHCi does not support optimizations
05:30:35 <hpc> it will load compiled code if it exists though
05:30:42 <hpc> and that can be compiled with optimizations
05:30:55 <sternmull> that is sad, playing interactively to test performance of different notations had been nice. But good to know that i should not give too much attention to resource usage in ghci.
05:32:15 <dramforever> sternmull: Uh, you do get that the 'bytes' part is *not* memory usage in the conventional sense, right?
05:32:16 <tfc> is there some nice framework which can be used for compiling little benchmarks which tells what ghci will not tell due to lack of optimization?
05:32:20 <michaelt> sternmull: yes the results of ghci :set +s are of limited use
05:33:15 <dramforever> [criterion] provides a powerful but simple way to measure software performance
05:33:16 <hpc> for a more sophisticated set of numbers, look at ghc's profiling features
05:33:18 <dramforever> http://hackage.haskell.org/package/criterion
05:33:36 <Xnuk> simendsjo: You might make a mistake in Line 32: `(g .) f` is `a -> c`,  while `(g .) . f` is not.
05:33:37 <dramforever> for benchmarking try this criterion thing
05:33:50 <michaelt> for time, criterion, other things ghc profiling options
05:36:07 <simendsjo> Xnuk: Thanks! I'll go through everything again.
05:36:21 <dramforever> Is there a way to 'see' how my cabal package description will render before publishing to hackage?
05:36:48 <hpc> you can preview an upload on hackage
05:37:45 <hpc> and i think now you can upload non-release versions too, which stick around and you can mark as release after the fact?
05:37:49 <dramforever> Oh right, that
05:37:51 * hpc hasn't used that yet
05:40:39 <michaelt> tfc here's a dumb use of criterion http://sprunge.us/hTdD 
05:41:04 <michaelt> tfc: together with the results of running it , compiling with -)2
05:41:19 <michaelt> tfc: I mean ghc -O2
05:41:39 <tfc> what makes it dumb?
05:41:54 <michaelt> tfc I just mean simple
05:42:00 <tfc> oh, ok :)
05:42:00 <michaelt> tfc:  sorry that wasn't clear
05:42:39 <michaelt> tfc `whnf` takes a function and an argument and the idea is to measure how long it takes to get to weak head normal form
05:43:32 <tfc> ok, i read some stuff about whnf, but i'm not sure if i really understand all implications of that
05:43:36 <michaelt> with Int this wouldnt differ from using `nf` which measures how long it takes to get the whole result worked out. 
05:44:07 <michaelt> for Int they come to the same, for [Int], where in whnf if we have either [] or 12:_ never mind what _ is
05:44:08 <sternmull> Now I compile "main = print $ foldl' (+) 0 [1..10000000]" with "ghc -O2 -prof foo.hs"  and run it with "./foo +RTS -p" and have 320MB of allocations in the profile output. This number scales with the length of the list. I expected the allocations to get optimized away...
05:48:39 <vijay> Hi, Can anybody explain (or point to a good resource) how do you identify what monads you need in your application. I read that "Monads are a remarkably elegant way for structuring programs in a flexible and extensible way".   
05:52:03 <ggVGc> vijay: it's not about "what monads you need". It's more about "Is this computation monadic"
05:52:40 <tfc> vijay i am still no expert at this, but i wrote little example apps in order to understand the most typical monads. (state, reader, writer, etc.) and as soon as you understand how to use them, you will see automatically where you can profit from them.
05:53:10 <halogenandtoast> Is there any obvious way to use persistant to query on a range. For example, given a UTCTime I want a query that checks if a value is in the same day.
05:53:40 <halogenandtoast> I'm considering trying to use esqueleto instead, but I don't see an obvious way to do it there either.
05:55:02 <michaelt> sternmull: here is a little course of action. ghc -O2 -prof -rtsopts 
05:55:11 <sternmull> Oh, i found the reason for all the allocations: By default the numbers are handled as Integer which need allocations because they are of variable size. When i force the numbers to Int then only a constant allocation remains (independent of the length of the list).
05:55:12 <vijay> I can use monads in my application. And I always figure out (later) that something could be a monad. And then refactor some code to make it Monadic. I thought  there is a better way ! 
05:56:04 <michaelt> sternmull: sternmull ghc -O2 -prof -rtsopts foldl.hs ; fold +RTS -hc ; hp2ps fold; open fold.ps
05:58:35 <michaelt> sternmull do you have hp2ps I think it comes with ghc. I shouldn't have used ; above, it's just the sequence of things I typed beginning ghc -O2 -prof -rtsopts fold.hs
05:58:49 <vijay> ggVgc, tic: Comparing to my Java days, I feel what I am doing now is like to refactor code to come up with new object/class :) 
05:59:47 <sternmull> michaelt: Yes i have hp2ps and your command works fine. What is -rtsopts? Can't find it in the ghc manual.
06:00:08 <michaelt> sternmull: the result of viewing blah.ps will show you the memory use over time. If you look at it, there is no comparison between foldl' and foldr
06:00:31 <michaelt> -rtsopts is needed to use +RTS -blah 
06:00:41 <michaelt> I'm not sure of all the ins and outs of it 
06:01:12 <michaelt> there were security reasons for making you request it explicitly in compiling
06:01:27 <sternmull> But "+RTS -p" woks without -rtsopts.
06:02:06 <michaelt> you compile with -prof -rtsopts or with -threaded -rtsopts , then you can do stuff like +RTS -hc or in the concurrency case, +RTS -N2 for cores etc etc
06:02:20 <michaelt> sternmull: yes that puzzled me, my information is incomplete
06:02:54 <sternmull> maybe -p is more primitive and does not need -rtsopts. After all it just prints a few resource counters.
06:02:57 <michaelt> maybe it's let through because -prof is obviously a development thing? 
06:03:00 <vijay> ggVGc: Are you suggesting that I should be thinking about all computations in application and then see if any of them are Monadic in nature?  
06:03:29 <michaelt> sternmull: total speculation. 
06:03:36 <sternmull> yes :)
06:04:35 <michaelt> sternmull: I have been using -rtsopts in compiling when I propose to use +RTS ... when running, for so long I may be out of date
06:05:27 <michaelt> sternmull: with -threaded you might actually want to run an executable on some days with -N1 on others with -N16
06:09:12 <michaelt> sternmull: anyway, i hope that picture of how to get a .ps file was clear enough, though typed badly.
06:12:14 <sternmull> michaelt: Yes, that was helpful. But for now i have to learn more about effectively writing haskell code. Performance considerations can wait for later... or maybe never be an issue in practice.
06:24:17 <michaelt> sternmull: benchmarking with criterion is always good! It's a little fiddly sometimes.
06:25:18 <Xnuk> simendsjo: Here's my solution. hth https://gist.github.com/xnuk/0074ac3235ca471ee39c77eebf2dbf71
06:27:00 <sternmull> michaelt: It is good to know such tools exist. But at the moment i really should invest my time in getting used to haskell. And the project i evaluate it for is not really performance critical. It will spend 99.9% of its time with copying files, sending/receiving network streams and waiting for child processes.
06:29:23 <michaelt> sternmull: here's an example where i was helping an SO user for such problems, and we were using hs2ps http://stackoverflow.com/questions/41905139/reduce-memory-usage-of-a-haskell-program/41938047
06:29:51 <thatguy> I am getting no instance of Eq h, but I have no clue where I am comparing h to anything, can someone take a look? http://lpaste.net/352108
06:30:05 <thatguy> code is only ~5 lines
06:30:50 <michaelt> thatguy: the line `g str2 == Nothing ...`
06:31:05 <michaelt> thatguy: means g has to result in a thing that has an Eq instance
06:31:40 <michaelt> so that g str2 == x makes sense
06:31:41 <thatguy> but g is of type String -> Maybe (a, String)), i.e. g str is of type Maybe (a, String)
06:31:54 <thatguy> ahh and Maybe is not of Eq instance if a is not, right?
06:31:56 <thatguy> is that the problem?
06:32:02 <michaelt> right, but haw can i tell if two e Maybe (a, String) are the same
06:32:06 <michaelt> right
06:32:22 <thatguy> ah ok thanks :)
06:32:30 <thatguy> is there a way to just check if it is Nothing?
06:32:44 <michaelt> yes
06:33:16 <sternmull> michaelt: Thanks, bookmarking the link. Maybe it comes in handy later.
06:33:45 <michaelt> h (Just (fRes, str2)) = case g str2 of Nothing -> whatever; Just _ -> whateverelse
06:33:51 <michaelt> thatguy: ^^^
06:34:11 <halogenandtoast> I doubt anyone did, but if someone answered my question from 22:52 I had step away.
06:34:45 <thatguy> michaelt, does case do something else than compare?
06:35:21 <halogenandtoast> but now that I'm back, does anyone know how to do a between query with either persistent or esqueleto?
06:35:40 <michaelt> thatguy: well it just looks at the constructor the type as whole neednt support Eq
06:36:05 <thatguy> so its just another pattern match so to say?
06:36:07 <michaelt> thus e.g. Maybe (Int -> Int) can be inspect for Just or Nothing, but has no Eq instance
06:36:10 <michaelt> yeah
06:36:30 <thatguy> michaelt, ok, thanks for taking the time to help :)
06:39:03 <halogenandtoast> I suppose I can just use rawSql
06:41:18 <michaelt> halogenandtoast: you can check the feed here http://tunes.org/~nef/logs/haskell/ or http://ircbrowse.net/day/haskell/today/recent
06:41:23 <michaelt> halogenandtoast: for what it's worth
06:41:57 <halogenandtoast> michaelt: Thanks!
06:42:13 <halogenandtoast> should have read the top
06:42:38 <michaelt> oh I forget they mention it
06:43:32 <halogenandtoast> yeah, and lo and behold my question was not answered, as expected, but now I can be certain.
07:08:40 <simendsjo> Xnuk: Very informative, thanks. I'll study your solutions carefully.
07:25:43 <boccato> Should I still put package boundaries on project.cabal build-depends if I am using stack with a resolver?
07:30:38 <Polarina> boccato, yes.
07:31:27 <rx> How useful is haskell in the industry?
07:31:52 <rx> Hello?
07:31:58 <davenpcm> What are the major examples of http client libraries in Haskell? Googling found me quite a few more than I liked.
07:32:24 <davenpcm> rx - It's fairly useful, but has some trouble with adoption in some orgs.
07:32:29 <opqdonut> rx: used quite a bit in financial tech
07:32:36 <rx> Just wanted to know if anyone in here worked on anything fun personally.
07:32:43 <rx> But yeah, I can imagine.
07:33:02 <opqdonut> our project uses postgrest, and I realised only after a month or so that it's written in haskell
07:33:21 <opqdonut> (http://postgrest.com/en/v0.4/)
07:33:39 <boccato> Polarina: Why is that? Won't it use the versions on the chosen resolver?
07:33:42 <rx> I'll take a look, thanks!
07:34:05 <hpc> a huge number of people use pandoc
07:34:14 <opqdonut> yeah pandoc is a great example
07:34:39 <rx> Lol where has this software been all my life
07:34:53 <Polarina> boccato, it would, yes. However, your package will most likely be broken for non-stack users.
07:36:15 <boccato> Hmm, haven't thought about that.
07:38:51 <maerwald> boccato: use upper bounds only if you _know_ it doesn't work with later ones, not if you are not sure
07:40:04 <hpc> usually you should add an upper bound on major version numbers anyway, because semantic versioning says those are where breaking changes are allowed to happen
07:40:39 <boccato> Any tips on lower bounds?
07:40:56 <maerwald> hpc: that's still guessing
07:40:57 <hpc> as far as you feel like testing if it works
07:41:30 <hpc> maerwald: not really
07:41:33 <maerwald> hackage is currently "rolling release"... and should be treated as such
07:41:43 <boccato> I am browsing around cabal files on github and it seems a few packages get their bounds defined but most dont.
07:41:56 <maerwald> hpc: yes it is, just because breaking changes are allowed to happen doesn't mean they actually do happen for package XY
07:41:59 <maerwald> it's just guessing
07:42:24 <maerwald> if you look at any rolling release distro, none of them use upper bounds, because it makes the depgraph explode
07:42:26 <hpc> https://pvp.haskell.org/?rdfrom=https%3A%2F%2Fwiki.haskell.org%2Findex.php%3Ftitle%3DPackage_versioning_policy%26redirect%3Dno
07:42:40 <maerwald> instead you fix stuff as you go
07:43:03 <maerwald> unless a package is really "broken" and cannot just be fixed... then you set an upper bound
07:43:53 <maerwald> hpc: I'm aware of that, it's still guessing as I pointed out, because it depends on used features etc
07:43:54 <hpc> "When publishing a Cabal package, you SHALL ensure that your dependencies in the build-depends field are accurate. This means specifying not only lower bounds, but also upper bounds on every dependency."
07:44:08 <maerwald> hpc: yeah and that suggestion is wrong
07:44:31 <hpc> then get it changed
07:44:33 <hpc> but that's the policy
07:44:47 <maerwald> I don't blindly follow policies just because someone put them on some wiki
07:44:53 <hpc> it's not on the wiki
07:44:57 <hpc> it's on pvp.haskell.org
07:45:20 <maerwald> so?
07:45:57 <hpc> so that's not "some wiki"
07:46:12 <maerwald> yeah, whatever
07:46:52 <maerwald> authority arguments incoming
07:49:51 <phadej> boccato: depends on what packages you look, "most" packages "I use" have upper bounds
07:50:42 <nshepperd_> Isn't setting upper bounds kind of how to fix things as you go? When a new dependency version comes out, test it with that version, fix it then update the deps?
07:51:08 <phadej> maerwald: the distro argument is missleading, there the "release team" decides which and when packages go in
07:51:11 <hpc> you can't go back and add upper bounds after the fact
07:51:21 <phadej> Hackage is distributed system
07:51:24 <maerwald> phadej: most don't have a release team, so no
07:51:29 <hpc> a published version of a package (except in particularly exceptional cases) is immutable
07:51:48 <michaelt> even if one old version lacked upper bounds it can produce cabal chaos 3 years later
07:51:53 <boccato> phadej: wasn't an extensible search, was almost random
07:51:58 <maerwald> if you want a set of tested versions, use stackage
07:52:06 <maerwald> that's what it's for... hackage is rolling release
07:52:06 <michaelt> cabal goes through and says 'oh i see this one works ...'
07:52:22 <phadej> boccato: there are authors which omits them, and authors which dont
07:52:41 <maerwald> phadej: but yes... there's not enough communication/coordination on hackage
07:52:43 <nshepperd_> Right, so if you didn't add deps in the first place, cabal will keep trying to use the broken package
07:52:43 <maerwald> it's just chaos
07:53:00 <phadej> maerwald: the versions bounds are the mechanism to communicate
07:53:07 <hpc> coordination is supposed to happen through version bounds and semantic versioning
07:53:11 <maerwald> phadej: that's not true most of the time
07:53:13 <phadej> hpc: :+1:
07:53:20 <maerwald> stuff just bitrots there and people forget to update deps
07:53:28 <phadej> maerwald: it doesn't
07:53:32 <hpc> it's not true when you blithely upload packages with no upper bounds and refuse to follow the policy
07:53:32 <phadej> provide evidence
07:53:39 <maerwald> phadej: erm?
07:53:48 <Tuplanolla> Wouldn't it be nice if we had automatic versioning based on changes?
07:54:07 <phadej> maerwald: e.g. stackage is an evidence that bounds get updates, as well as that packages break when there aren't upper bounds
07:54:08 <hpc> if package uploaders could do whatever they wanted, hackage would be like npm
07:54:27 <maerwald> phadej: ok, that's wrong when you look at the last upper bound change on base
07:54:29 <hpc> where a "package" consists of a url saying "download a bunch of stuff from some random github url"
07:54:37 <maerwald> most packages worked fine with the new GHC base version
07:54:47 <phadej> maerwald: but didn't with 4.8
07:54:47 <maerwald> and still everything needed to be "fixed" manually
07:54:52 <phadej> maerwald: how you can know?
07:54:54 <Clint> upper bounds are the devil
07:55:04 <maerwald> phadej: if you don't know, don't add upper bounds
07:55:12 <maerwald> Clint: exactly
07:55:14 <phadej> imho lazy maintainers is worse when there aren't upper bounds
07:55:18 <phadej> if they are lazy, they won't add them
07:55:28 <phadej> imho it's bigger "bad"
07:55:49 <hpc> upper bounds mean that package installs crap out on package versions instead of on "not in scope: Foo.Bar.baz"
07:55:58 <maerwald> Clint: most people don't understand the impact though... and now since we have cabal sandboxes and everything, things are a little less broken from the user perspective. But the depgraph is still just f'ed up
07:56:02 <hpc> or ridiculous and non-obvious type errors that are different every time
07:56:08 <michaelt> if you don't believe in upper bounds you can mechanize the process of bumping them for your packages.
07:56:18 <Welkin> maerwald: and stack and nix
07:56:28 <maerwald> Welkin: more random tools yeah :P
07:56:28 <Clint> michaelt: it's not my packages that i'm annoyed by
07:56:38 <ertes> i used to use bounds like:  kan-extensions >= 5.0 && < 6
07:56:51 <michaelt> Clint: try --allow-newer if you are using cabal install
07:56:58 <ertes> it worked well enough, but also raised a concern about semantic changes
07:57:04 <Welkin> stackage is supposed to solve those issues
07:57:10 <phadej> ertes: but you rely on kmett's "extra semantics" on top of pvp. It's not wrong
07:57:14 <Clint> michaelt: i'm not
07:57:17 <hpc> stackage solves the issue by eliminating it entirely
07:57:23 <maerwald> michaelt: yeah, but now... you have the problem of not knowing "did he add an upper bound because he KNOWS it doesn't work or because he DOESNT KNOW"
07:57:25 <maerwald> see the problem?
07:57:33 <hpc> dependency solving ceases to exist and it's just "build with these exact versions of everything"
07:57:46 <phadej> except that stackage has to do solving in the first place
07:57:53 <ertes> phadej: the PVP does not specify that though…  the issue was brought to my attention by the maintainer of the unix package
07:58:03 <michaelt> maerwald: yes, it speaks in favor of doing the work to have rational upper bounds, no?
07:58:03 <ertes> that's why i now go with stricter bounds
07:58:46 <hpc> maerwald: upper bounds in cabal, much like something not existing in a stackage LTS, mean the exact same thing
07:58:47 <Welkin> I've run into issues with too tightly restricted upper bounds that required a re-upload to hackage for packages I needed to use
07:58:52 <hpc> untested or non-functional
07:58:53 <maerwald> michaelt: yes, I want to ignore all "lalala, I don't know, so I just randomly add upper bounds everywhere", but I don't want to ignore the cases where an upper bound might safe me from unexpected runtime behavior
07:58:56 <Tuplanolla> Could we have a tool that looks through your code to see what parts of a package you use and then find the oldest version of that package where all those things have remained unchanged?
07:58:57 <Welkin> I had to contact the author for it
07:59:34 <ertes> i wish the PVP would specify explicitly that semantic *changes* can only happen in major-major jumps
07:59:35 <maerwald> michaelt: because the maintainer actually knows it
07:59:54 <ertes> no semantic changes allowed, only semantic additions: 5.0 -> 5.1
07:59:57 <hpc> Welkin: that's the system working as intended
08:00:01 <Clint> and if the author is bos you have to wait 18 months for a fix
08:00:02 <ertes> semantic changes allowed: 5.0 -> 6.0
08:00:05 <maerwald> if I want a perfectly safe set of packages... then I use stackage (or distro packages)
08:00:05 <drostie> Well that's why semver was being pushed so hard for... the major versions track breaking API changes so you always add upper bounds because you don't know whether it's gonna work or not.
08:00:16 <phadej> ertes: what you mean by semantic additions?
08:00:18 <nshepperd_> Tuplanolla: we could have something that just builds the package and sees if it fails. That would detect practically all problems
08:00:36 <ertes> phadej: new functions or old functions with new functionality that doesn't interfere with the older API
08:00:37 <Tuplanolla> That seems really computationally expensive, nshepperd.
08:00:39 <maerwald> drostie: it's just laziness and impractical
08:00:43 <phadej> non breaking changes are allowed in the third digit
08:00:49 <ertes> personally i think the PVP is flawed in this respect
08:00:57 <Welkin> pvp?
08:01:04 <hpc> package versioing policy
08:01:04 <phadej> e.g. adding function is ok to go from 1.2.5 -> 1.2.6
08:01:05 <ertes> Package Versioning Policy
08:01:07 <Welkin> lol
08:01:15 <Welkin> I see pvp and think player vs player
08:01:22 <maerwald> haha
08:01:27 <ertes> hehe
08:01:34 <Clint> it's related
08:01:37 <ertes> it's *kind of* player vs. player =)
08:01:39 <michaelt> ha
08:01:41 <boccato> For a private project (not published) would it be bad to put the explicit version of the dependency?
08:01:42 <ertes> dev vs. dev
08:01:57 <maerwald> boccato: like you do in javascript?
08:01:59 <hpc> boccato: to specify version numbers exactly?
08:02:02 <Welkin> boccato: no, that is what stackage does already
08:02:03 <hpc> should be fine
08:02:04 <ertes> boccato: for private projects i don't bother using bounds at all =)
08:02:07 <phadej> boccato: I won't put any versions, and use stack or cabal freeze
08:02:10 <ertes> if it breaks, i'll just fix it
08:02:10 <maerwald> ertes: exactly
08:02:12 <drostie> phadej: the semver definition is that when you add functionality in a backwards compatible manner you increment the second number.
08:02:15 <hpc> stackage does that, and a number of packages that are tightly bound to each other do it too
08:02:19 <Polarina> boccato, I do that for my private projects. That way, I know which packages' ChangeLogs to read when they publish a new major version.
08:02:27 <phadej> drostie: don't mix up semver and pvp
08:02:39 <drostie> Oh, I see what you're saying then.
08:02:41 <phadej> https://pvp.haskell.org/faq/#how-does-the-pvp-relate-to-semantic-versioning-semver
08:02:45 <hpc> https://hackage.haskell.org/package/ghc-boot
08:02:49 <Welkin> so wait
08:02:54 <hpc> depends on ghc-boot-th exactly equal to the same version
08:03:04 <Welkin> what is with chrome and the ever-increasing versions?
08:03:06 <ertes> anyway, so far i've only run into one problem…  i have to pay attention to stuff like:  vector >= 0.11 && < 0.13
08:03:07 <maerwald> ertes: the problem with hackage though is... I know when I break my own package, but not when reverse deps break my package. That's simply a lack of functionality of the hackage platform.
08:03:08 <ertes> it's good enough
08:03:09 <boccato> Hmm... good to know.
08:03:11 <Welkin> it is definitely not semver
08:03:17 <Welkin> unless it break every time they make a release
08:03:18 <maerwald> but relatively easy to implement, if someone wanted to
08:03:31 <hpc> chrome's version numbering system is an advertising trick
08:03:45 <hpc> the idea was that chrome version 22 looks better than firefox version 3.5
08:03:58 <ertes> maerwald: not sure…  i feel like every more expressive solution would come with an engineering cost
08:04:07 <ertes> not for hackage, but for package developers
08:04:17 <hpc> it could be a breaking change every time though
08:04:24 <ertes> my view is that hackage and the PVP are good enough
08:04:33 <hpc> (for something other than chrome)
08:04:40 <ertes> sometimes stuff breaks, and then you fix it
08:04:44 <Welkin> and wait
08:04:47 <maerwald> ertes: not really, you just need build servers testing stuff and could then rather easily propagate the results via e-mail (optionally) or on some website
08:04:58 <Welkin> version numbers don't seem to mean anything unless you follow a system like semver
08:05:03 <hpc> what do the build servers test?
08:05:05 <drostie> Welkin: yeah, Chrome and Firefox decided to have more aggressively pushed majors, Ubuntu decided to have majors be just dates of release.
08:05:06 <ertes> maerwald: you want to turn hackage into a CI platform?
08:05:07 <phadej> maerwald: the question is "who is the one who will build and maintain these servers"
08:05:08 <maerwald> "the new lens release just broke your package, we are sorry"...
08:05:11 <hpc> the powerset of every package version?
08:05:11 <Welkin> elm made breaking changes from version 0.16 to 0.17
08:05:21 <phadej> maerwald: you can do it yourself now
08:05:38 <maerwald> aha
08:05:45 <michaelt> it would be nice if hackage somehow informed me if my packages no longer build with the latest as stackage sort of does
08:06:01 <ertes> maerwald: i wouldn't mind it, but any concrete form of CI is going to upset *someone*
08:06:04 <phadej> michaelt: but Hackage isn't a CI, it's a repository
08:06:10 <maerwald> ertes: not really "turn into". It wouldn't even have to be related to the hackage site
08:06:16 <Welkin> of course another problem is that docs dont get generated all the time because it fails on the server
08:06:24 <michaelt> phadej: yes, but I would still like to know in advance when things are changing
08:06:28 <Welkin> documentation generation should be happening on the uploader's machine
08:06:45 <drostie> Welkin: breaking changes from 0.16 to 0.17 are allowed by both PVP and semver.
08:06:52 <drostie> (for different reasons.)
08:06:59 <phadej> michaelt: with proper bounds you can follow http://packdeps.haskellers.com rss
08:07:04 <Tuplanolla> Documentation generation happens upon installation for me.
08:07:09 <maerwald> well, I think the biggest obstacle here is not technologically, but just that maintainers are used to the semi-broken workflow on hackage and don't want to bother with more
08:07:15 <Tuplanolla> I don't see any other way making sense.
08:07:29 <Welkin> Tuplanolla: I am talking about the hosted docs on hackage
08:07:37 <michaelt> Tuplanolla: the docs on hackage?
08:07:51 <phadej> Welkin: you can upload the docs!
08:07:55 <Tuplanolla> Right. I don't use those.
08:08:06 <phadej> both cabal and stack (AFAIK) can do it
08:08:19 <michaelt> oh I thought Welkin knew that 
08:09:15 <Welkin> I can?
08:09:35 <Welkin> it has been annoying me to no end that certain package fail to have docs
08:09:39 <hpc> anyway, the automation behind version upper bounds is what distros do manually with every release
08:09:47 <Welkin> like ghcjs-dom
08:09:52 <michaelt> Welkin: no doubt I'm out of date but i use this script https://raw.githubusercontent.com/michaelt/streaming/master/upload.sh
08:09:56 <maerwald> hpc: no
08:10:04 <michaelt> Welkin: which was floating around a year or so ago
08:10:45 <phadej> Welkin: https://github.com/haskell/cabal/issues/2080
08:11:20 <maerwald> releases are _consistent_, update process of upper bounds is inherently not... and it's not even proper rolling release... it's an ugly hybrid that doesn't work
08:11:50 <phadej> Welkin: the tooling UX is not easy, someone just needs to go thru designing and implementing it
08:12:01 <michaelt> Welkin: it's pretty straightforward, someone probably has a sexier script these days.
08:12:09 <phadej> maerwald: why you insist of seeing the Hackage as a whole, and not collection of releases per packages?
08:12:13 <hpc> upper bounds following semantic versioning are consistent
08:12:16 <phadej> in the same way ase.g. PyPi
08:12:23 <phadej> or maven
08:12:36 <hpc> the lifetime of a distro release defines the support period for the packages it contains
08:12:49 <hpc> on the next release, those previous versions become unsupported and new versions become supported
08:13:00 <maerwald> I know how distros work
08:13:17 <hpc> some packages drop off, those are the kind of thing Welkin mentioned where you have to get the package maintainer to update
08:13:21 <maerwald> and it's nowhere near similar to the upper bounds mess on hackage
08:13:43 <maerwald> phadej: because of the dependency graph
08:13:44 <hpc> upper bounds define the period of support for a package
08:14:06 <hpc> when the dependencies do new potentially-breaking releases, the support period for that version has ended
08:14:22 <hpc> and a new version has to be rolled (possibly a minor version bump) that updates the support period
08:14:34 <hpc> it's only a mess if you don't follow the PVP
08:14:37 <phadej> maerwald: so are you saying mavens or pypis approach is also wrong?
08:15:01 <maerwald> I'm tired of explaining the difference... but here we go: next GHC version with new base version will cause what? 30% of hackage working after 2 weeks. How's that anywhere near a consistent, tested debian release?
08:15:01 <hpc> you can't just ignore the thing that makes it work and then proclaim that it's broken
08:15:01 <phadej> imho they are in even worse situation, as they have no semantics in the version components
08:15:03 <maerwald> it's not
08:15:22 <maerwald> stop comparing things that are totally different
08:15:23 <phadej> maerwald: why it should work in the next 2 weeks?
08:15:38 <maerwald> hackage is rolling release
08:15:40 <phadej> it will work when authors have ability to test it
08:15:45 <hpc> maerwald: packages disappear between debian releases too
08:16:03 <maerwald> disappear...
08:16:07 <michaelt> Welkin: https://github.com/ekmett/lens/blob/67ac5db4ee24364c435e6e9fbe29fe429bce8d0c/scripts/hackage-docs.sh looks very modern 
08:16:24 <hpc> and it's not a rolling release, it's distributed discrete releases
08:16:32 <maerwald> it's a broken hybrid yes
08:16:40 <hpc> it's a working hybrid if you follow the rules
08:16:46 <maerwald> I disagree
08:16:49 <hpc> okay?
08:17:02 <nshepperd_> Ghc maintainers could fix everyone's packages for them, sure
08:17:10 <maerwald> but since you're barely responding to my arguments, I guess we are done
08:17:19 <nshepperd_> Write everyone's Applicative instances
08:17:27 <phadej> nshepperd_: :)
08:17:39 <hpc> debian releases work by debian taking ownership of every package they publish
08:17:53 <drostie> This is why I wanted to write a metadata-based programming language where every function was hashable. It could have release tooling where it says "hey, you changed the public API for your package by adding this new function, based on this we want to bump the minor release number, is that OK with you?" and you can say "cancel out of all this, that function was supposed to be private!" or whatevs.
08:17:59 <ongy> nshepperd_: why didn't they? From how I understand it 'instance Monad a => Applicative a where' could be a thing (overlappable for saner definitions)
08:18:23 <Tuplanolla> Perhaps we are too fixated on the concept of packages.
08:18:25 <hpc> and the maintainers spend a crazy-stupid amount of effort doing what cabal version numbers do automatically
08:18:39 <phadej> ongy: oh, that won't work far
08:18:57 <nshepperd_> ongy: dunno, probably some reason
08:19:14 <ongy> why though? shouldn't return and ap do the trick?
08:19:27 <hpc> when a new ghc comes out, it doesn't suddenly break the old ghc, is the end result
08:19:34 <ongy> I get that there's some more ideological reason not to, but is there a technical?
08:19:48 <hpc> the same version resolution just makes it work, without having to repoint your repos like with a new debian release
08:19:56 <hpc> or without having to always be upgrading like with arch
08:20:08 <hpc> where if you wait for a month or two, the upgrade path vanishes because they move so fast
08:20:53 <hpc> don't upgrade right away if you aren't prepared to do what debian does, really
08:21:40 <nshepperd_> ongy: i suppose it's better not to need overlapping instances in base
08:21:51 <hpc> ongy: once you defined that, you can't write any other Applicative instances without OverlappingInstances
08:21:56 <hpc> because everything overlaps with 'a'
08:22:13 <nshepperd_> Ah, that's why
08:22:18 <ongy> everything? or everything that's Monad?
08:22:25 <hpc> everything
08:22:26 <phadej> everything
08:22:37 <hpc> the constraint doesn't factor into it
08:22:42 <thatguy> is there some quick way to write functions that take n arguments and just return ()
08:22:44 <ongy> oh, that makes more sense
08:22:56 <thatguy> even quicker than (\a b c -> ())
08:23:08 <hpc> \_ _ _ -> ()
08:23:15 <Tuplanolla> Pile `const`, thatguy?
08:23:23 <hpc> :t const const const const
08:23:24 <lambdabot> b -> a -> b1 -> a
08:23:30 <hpc> :t const const const const const
08:23:31 <lambdabot> a -> b -> a
08:23:32 <Welkin> wtf?
08:23:37 <Welkin> how do you log out of your accoint on hackage?
08:23:39 <hpc> (const is weird)
08:23:50 <phadej> @pl \x y z -> ()
08:23:50 <lambdabot> const (const (const ()))
08:24:06 <Tuplanolla> > (const . const . const . const) () 1 2 3 4
08:24:08 <lambdabot>  ()
08:24:19 <hpc> thatguy: why do you need this?
08:24:24 <phadej> @pl \a x y z -> a
08:24:24 <lambdabot> const . const . const
08:24:52 <thatguy> Tuplanolla, thanks
08:25:16 <thatguy> hpc, and exercise in the CIS 194 course where I am doing a parser which parses either an int or an uppercase char
08:25:39 <reactormonk> How do I tell cabal which cabal file to use?
08:25:51 <thatguy> hpc, I am doing it as ((\a -> ()) <$> IntParser) <|> ((\a -> ()) UpperCharParser), is that ok?
08:26:11 <phadej> :t void
08:26:12 <lambdabot> Functor f => f a -> f ()
08:26:21 <thatguy> and I need that \a -> () so that the two parser are both of type Parser () and I can use <|> on them
08:26:43 <phadej> :t \f -> const () <$> f
08:26:45 <lambdabot> Functor f => f b -> f ()
08:26:50 <phadej> :t \f -> () <$ f
08:26:51 <lambdabot> Functor f => f b -> f ()
08:26:56 <phadej> :t \f -> void f
08:26:58 <lambdabot> Functor f => f a -> f ()
08:27:04 <phadej> pick yours
08:27:11 <hpc> void IntParser <|> void UpperCharParser?
08:27:36 <thatguy> phadej, thanks
08:27:47 <phadej> the <$ is useful when you have many parsers, e.g.
08:28:04 <phadej> \a b c -> () <$ a <* b <* c
08:28:06 <phadej> :t \a b c -> () <$ a <* b <* c
08:28:08 <lambdabot> Applicative f => f b2 -> f b1 -> f b -> f ()
08:28:16 <phadej> yet you can write
08:28:29 <phadej> :t \a b c -> void (a *> b *> c)
08:28:31 <lambdabot> Applicative f => f a2 -> f a1 -> f a -> f ()
08:28:40 <phadej> which might perform better
08:29:48 <lyxia> ongy: instance Monad f => Applicative f  also requires UndecidableInstances
08:30:04 <thatguy> :t <$
08:30:06 <lambdabot> error: parse error on input ‘<$’
08:30:10 <drostie> maerwald: I just wanted to say that I benefitted a lot from rereading the chat history from your perspective.
08:30:13 <phadej> :t (<$)
08:30:15 <lambdabot> Functor f => a -> f b -> f a
08:30:38 <ongy> lyxia: From how I understand it, that would be required only in the file that defines this instance and should be ok here, but I'm not 100% on that
08:30:56 <ongy> but I also understand that it's not the cleanest solution either
08:31:53 <thatguy> phadej, thanks for the help and the nice examples
08:31:56 <thatguy> hpc, thank you too
08:33:22 <lyxia> ongy: If you want to provide custom specialized instances, you will need not only Overlapping, but also IncoherentInstances whenever you write code that just expects a Monad constraint while using Applicative.
08:33:49 <lyxia> ongy: and such code will not ever use the specialized instances
08:33:55 <phadej> thatguy: np
08:34:37 <ongy> it will not? I thought it's the smallest head or something? But thinking about that I see problems with a lot of instances
08:34:54 <drostie> ongy: remember that Monad f => Applicative f stores a dictionary for Applicative functions on every Monad type, so then if you custom-define your own Applicative you are providing two such functions for the computer to use and no guidance about which one it should actually select at runtime. 
08:35:53 <ongy> afaik we have the {-# OVERLAPPABLE #-} macro for instance declarations in the new ghc versions, which I asumed lowers priority against any non-overlappable at least
08:35:56 <drostie> Then you get messy stuff like how CSS has a rule of "the more specific selector takes priority" which are huge nuisances in their own right, and like css you'll need to eventually implement the !important flag.
08:35:59 <lyxia> ongy: but when you are writing code over an abstract f (with only Monad f) there is no single most specific instance of Applicative that matches.
08:36:11 <Welkin> css is bullshit
08:36:23 <Welkin> inline styles are better
08:36:44 <drostie> right, like {-# OVERLAPPABLE #-}
08:38:25 <ongy> it worked well as far as I tried, but I only ever used it for type'd show instances (Show (Packet a)) and (Show (Packet Special))
08:39:03 <drostie> Whereas if you just had some functions inheritFmapFromMonad :: (a -> b) -> f a -> f b in your Monad class you would at least be able to reduce it to a one-liner. ^_^
08:39:18 <lyxia> ongy: it works when the type you are showing is concrete
08:39:25 <drostie> like Traversible does with foldMapDefault or whatever
08:39:25 <lyxia> I mean, not abstract
08:41:17 <ongy> oh, so if I have a function that's 'Monad m => m a' that's not specialised during compile that calls into another function 'Applicative a => a v'? Then I'd alwasy fall back? I hope I got it
08:43:30 <lyxia> Right.
08:43:40 <lyxia> ongy: http://lpaste.net/352109
08:46:35 <ongy> oh, it's still the slow version with -O2? I would expect it to inline and specialize there o.0
08:46:39 <lyxia> BTW it doesn't type check if you remove IncoherentInstances
08:48:55 <ongy> pulling w and main into their own file, that one needs no extension
08:52:26 <lyxia> You shouldn't need it for something as trivial as w.
09:00:52 <reactormonk> how do I define ifdefs for compliation?
09:01:06 <Welkin> use the c preprocessor
09:01:18 <Welkin> same as you would in c
09:02:01 <reactormonk> ... how do I tell the ghc that it should define a define via command line?
09:02:04 <reactormonk> or stack, to be specific
09:02:19 <phadej> cpp-options
09:02:28 <phadej> cpp-options="-DMYDEFINE"
09:02:48 <phadej> but that's not a good idea.
09:03:57 <reactormonk> phadej, playing around with cabal sources - they have CABAL_PARSEC_DEBUG in there as an ifdef
09:05:44 <phadej> reactormonk: it's defined thru the flag
09:06:00 <phadej> add `flags: Cabal: parsec: true` to stack.yaml
09:06:15 <phadej> and to cabal-install, if you up to that
09:06:53 <phadej> there's other stuff as well, so it has to go thru flag (dependencies)
09:14:01 <rgrinberg> What's the fastest binary parser that supports partial input?
09:29:30 <phadej> rgrinberg: partial as in?
09:30:08 <phadej> rgrinberg: do you mean incremental, like attoparsec?
09:31:08 <phadej> rgrinberg: e.g. binary supports incremental input, or do you need something much faster?
09:37:47 <buglebudabey> i'm getting an exception while trying to install quipper package, how can i go about adding the package it mentions? http://lpaste.net/352112
09:39:10 <qmm> i'm happy about this :)
09:39:28 <qmm> i just searched for "create a bytestring with string" and the first result was https://www.haskell.org/hoogle/?hoogle=String+-%3E+ByteString
09:39:52 <qmm> there were no matching words in the html tags :)
09:40:06 <qmm> it's like google is trying to learn from hoogle ;)
09:44:42 <phadej> qmm: don't use Char8 module, except if you are sure you can
09:45:35 <phadej> qmm: you most likely want some of encode functions: http://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Encoding.html
09:45:48 <phadej> or https://hackage.haskell.org/package/utf8-string
09:46:05 <qmm> ah, thank you phadej 
09:46:34 <lyxia> buglebudabey: the last two lines give the solution
09:46:48 <lyxia> buglebudabey: modify your stack.yml file
09:46:57 <buglebudabey> lyxia yeah i just did it but now i've run into another problem
09:47:07 <buglebudabey> lyxia Could not find module ‘Distribution.Superdoc’
09:47:28 <lyxia> where is that error located
09:49:42 <buglebudabey> lyxia looks like where stack installed that missing extra dependency
09:57:00 <joneshf-laptop> I'm trying to follow along with this blog post locally: https://izbicki.me/blog/the-categorical-distributions-algebraic-structure It seems like it needs ghc 7.6. I have ghc 8.0.1 installed on my machine and stack only supports 7.8 and newer. Is there a non-intrusive way to run the code on my machine?
09:57:08 <joneshf-laptop> Maybe with nix or some such?
09:59:04 <qmm> phadej: is there a way to go from Text to Lazy Bytestring?
09:59:43 <joneshf-laptop> Or maybe `cabal new-build` might work?
09:59:53 <drninjabatman> hello, does anyone know why `retract` from the `free` package requires that the returned type be Monad and not Functor? 
10:00:04 <phadej> qmm: strict text to lazy bytestring?
10:00:39 <qmm> or lazy text
10:00:50 <qmm> is data.text strict?
10:00:56 <monochrom> Yes.
10:01:24 <phadej> qmm: then there's also http://hackage.haskell.org/package/string-conversions-0.4.0.1/docs/Data-String-Conversions.html
10:01:29 <qmm> Data.Text.Lazy
10:01:34 <phadej> with http://hackage.haskell.org/package/string-conversions-0.4.0.1/docs/Data-String-Conversions-Monomorphic.html
10:02:11 <phadej> probably there are other solutions to this problem as well
10:02:13 <lyxia> drninjabatman: its implementation uses return and (>>=)
10:02:23 <joneshf-laptop> lambdabot, :t retract
10:02:25 <lyxia> drninjabatman: how would you write it otherwise
10:02:26 <phadej> (string-conversions is used in servant, that how I know about it)
10:02:27 <joneshf-laptop> :t retract
10:02:30 <lambdabot> error: Variable not in scope: retract
10:02:52 <lyxia> :t Control.Monad.Free.retract
10:02:53 <lambdabot> Monad f => Control.Monad.Free.Free f a -> f a
10:03:08 <qmm> that did it
10:04:25 <Zemyla> Okay, I have a thought about expressing regular expressions in Haskell.
10:05:26 <phadej> Zemyla: applicative?
10:05:47 <Zemyla> Regular expressions are basically Applicative parsers expressing a tree, yes.
10:05:58 <phadej> Zemyla: http://hackage.haskell.org/package/regex-applicative
10:06:25 <Zemyla> phadej: I saw that. But the way it's constructed seems inefficient, because it doesn't do any kind of minimization on the resultant parser.
10:06:58 <Zemyla> Also, regular expressions are closed under intersection and complement, neither of which this offers.
10:07:19 <opqdonut> neither do usual regexps
10:07:28 <phadej> Zemyla: intersections is hard when you have capture groups
10:07:53 <Zemyla> Actually, I know how I would do it.
10:08:32 <phadej> i.e. if you have capture groups you are in NFA world, not DFA
10:10:01 <phadej> but if you don't want to capture substrings, then minimising implementation may be faster
10:10:45 <phadej> https://github.com/phadej/tarzan/blob/master/src/Tarzan.hs
10:11:34 <qmm> which style is does the community like?
10:11:38 <qmm> buckets <- R.listBuckets c (Just ( encodeUtf8 (L.pack "default")))
10:11:44 <qmm> buckets <- R.listBuckets c (Just $ encodeUtf8 (L.pack "default"))
10:11:50 <qmm> buckets <- R.listBuckets c $ Just $ encodeUtf8 $ L.pack "default"
10:11:57 <maerwald> first world problems
10:11:59 <phadej> qmm: personally, consistent
10:12:17 <qmm> phadej: hm?
10:12:32 <phadej> qmm: if you use some style, use it consistently, but I don't care which
10:12:51 <maerwald> there are 3453 similar questions you could ask about style
10:12:59 <qmm> the second one example i suppose is inconsistent?
10:13:01 <Zemyla> phadej: Actually, I figured out how you can do capture groups with DFAs.
10:13:02 <monochrom> The beginner community likes the fully $ version. The learned community likes the fully () version.
10:13:06 <qmm> that's the typical style for me currently
10:13:10 <qmm> i just use what works :)
10:13:15 <Tuplanolla> This question comes up all the time though.
10:13:22 <phadej> Zemyla: even ambigious ones?
10:13:34 <phadej> Zemyla: i.e. "few" "many" difference
10:13:45 <Zemyla> Yes, seriously.
10:13:49 <qmm> Tuplanolla: you have a great point. i should crawl through the logs and look for previous conversations
10:13:57 <phadej> Zemyla: then you should write it up :)
10:14:16 <Zemyla> Well, I've only got kind of a skeleton of it so far.
10:14:19 <Tuplanolla> Actually monochrom already summarized it, qmm.
10:15:12 <Tuplanolla> Once you've seen primitive and higher-rank types, you'll realize how strange `$` really is and might start avoiding it.
10:15:26 <Zemyla> But I'm thinking that a state in a regex - DFA, NFA, or e-NFA - is represented by a profunctor, StateP t (where t is the token type).
10:15:46 <qmm> Tuplanolla: what do high rank types have to do with $
10:15:52 <qmm> if you don't mind me asking
10:16:14 <maerwald> I suggest you just keep on coding instead of worrying about such style crap :P
10:16:36 <Zemyla> A StateP t a b receives a value of type a, and a token of type t, and eventually produces a value of type b.
10:16:38 <phadej> qmm: there is a special case in type checker so runST $ do ... is accepted
10:16:52 <qmm> i kind of like the mixture of both parens and the $ 
10:17:16 <boojinks> the mix is the ugliest imho, would definitely go for the first option
10:17:56 <phadej> boojinks: but how about `map (partiallyApplied foo) $ bar xs`
10:18:23 <maerwald> 1$ for the style question jar
10:18:27 <drninjabatman> lyxia: it's just that `retract . liftF = id` but `liftF` takes functor as an argument and it seems a bit strange
10:18:58 <ertes> the problem i had earlier was not related to nix at all…  there was a major LD_PRELOAD hack in place that interfered with nix
10:19:01 <drninjabatman> lyxia: it's not a proble, I ended up using `iter`, I just found it a bit odd
10:19:06 <boojinks> phadej: can't say I'm a fan :)
10:19:26 <phadej> boojinks: well, that's where the $ breaks
10:19:36 <Zemyla> I know that a StateP with epsilon transitions would be represented as StateP { accepts :: Maybe (a -> b), eTransitions :: [exists c. (a -> c, StateP tc b)], transitions :: t -> [exists c. (a -> c, StateP t c b)] }
10:19:38 <phadej> tbh, I actually doesn't have an opinion
10:20:38 <Tuplanolla> > I# $ 42#
10:20:41 <lambdabot>  error:
10:20:41 <lambdabot>      • Data constructor not in scope: I# :: GHC.Prim.Int# -> t
10:20:41 <lambdabot>      • Perhaps you meant ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Tr...
10:20:46 <Zemyla> And the regex would be represented as newtype Regex t a = Regex { unRegex :: forall r x. StateP t (a, r) x -> StateP t r x }
10:21:13 <phadej> isn't exists c. (a -> c, StateP t c b) same as StateP t a b
10:21:25 <phadej> why you need the existential there?
10:22:38 <phadej> Zemyla: how the intersection would look like?
10:24:40 <Zemyla> phadej: Because I actually was planning to have it return a value of type exists c. (a -> c, Key c), which would index into a keyed map which returns a StateP t c b.
10:24:42 <sternmull> can anyone suggest a good editor or even an IDE? Currently i am using emacs with haskell-mode... but i am not really happy with it.
10:24:58 <phadej> Zemyla: ah
10:25:00 <phadej> like how ((aa)*|(aaa)*)+ would work
10:25:17 <Zemyla> This way, whatever takes the state list could minimize them.
10:26:23 <Zemyla> But the reason for the Regex type is its input is the final state, which wants a value of type (a, r) and produces an x, and returns the initial state, which only requires an r.
10:33:14 <Zemyla> @let newtype RegexP p a = RegexP { unRegexP :: forall r x. p (a, r) x -> p r x } -- phadej
10:33:16 <lambdabot>  Defined.
10:33:27 <Zemyla> @let instance Profunctor p => Functor (ApP p) where fmap f (ApP m) = ApP $ m . lmap (\(a, r) -> (f a, r))
10:33:28 <lambdabot>  .L.hs:186:35: error: Not in scope: type constructor or class ‘ApP’
10:33:28 <lambdabot>  
10:33:28 <lambdabot>  .L.hs:187:17: error: Not in scope: data constructor ‘ApP’
10:33:47 <Zemyla> @let instance Profunctor p => Functor (RegexP p) where fmap f (RegexP m) = RegexP $ m . lmap (\(a, r) -> (f a, r))
10:33:48 <lambdabot>  Defined.
10:33:55 <joneshf-laptop> sternmull, what things make you unhappy about haskell-mode?
10:34:25 <Zemyla> @let instance Profunctor p => Applicative (RegexP p) where { pure a = RegexP $ lmap ((,) a); RegexP mf <*> RegexP ma = RegexP $ \p -> mf $ ma $ lmap (\(a, (f, r)) -> (f a, r)) p }
10:34:27 <lambdabot>  Defined.
10:34:31 <joneshf-laptop> sternmull, alternatively, what things would make you happy about haskell-mode
10:34:44 <sm> sternmull: I like IDEA and haskforce or intellij-haskell
10:35:53 <sternmull> joneshf-laptop: Autocompletion does not work and i can't see why. The documentation does not help with this, it tells me that it works out of the box. And the "interactive-mode" does some stupid things i don't understand (types lambda in my buffer and nothing else...). So i think i should look for alternatives.
10:35:56 <sm> also, have you tried intero in emacs
10:36:05 <maerwald> some people (I think Cale) also use Sublime
10:36:15 <maerwald> I personally tried leksah once, but I don't like the internal editor 
10:36:19 <maerwald> great as an IDE though
10:38:11 <joneshf-laptop> sternmull, I see. Thats pretty bad.
10:39:03 <sternmull> ok, i will check out intellij. I also think to give atom a try.
10:48:53 <Zemyla> phadej: But yeah, once you have a StateP t u a and a StateP t v b, each of which has a series of states, you can actually take the cartesian product of those states and it'll produce a StateP t (u, v) (a, b).
10:51:27 <Zemyla> And complement involves taking the StatePs and applying maybe (Just $ const ()) (const Nothing) to the accept functions.
10:53:53 <muesli4> Hi, is there something that allows to build with stack on another machine (same architecture)? 1GB doesn't seem to be enough to build with GHC. It's constantly swapping and I fear it will never finish.
10:54:46 <hpc> it'll finish, i used a machine with 1G of ram up until about 2 weeks ago
10:55:00 <hpc> but also can you not just set up stack on the other machine?
10:55:09 <Zemyla> hpc: Had Stack finished compiling by then?
10:55:23 <hpc> haha
10:56:22 <muesli4> hpc: Not in time. It's a netbook.
10:58:59 <muesli4> hpc: Once I compiled on a Raspberry PI 2 (also 1 GB of memory). I couldn't get bytestring to build with a specific version (although with a newer version it worked).
11:08:09 <qmm> there's a tldr example in hackage: >>> get conn "counters" "bucket" "key" 
11:08:20 <qmm> get has this signature: get :: Connection -> BucketType -> Bucket -> Key -> IO (Maybe DataType)
11:09:30 <qmm> i guess that is pseudocode since BucketType is a Maybe Data.ByteString.Lazy.Internal.ByteString
11:10:13 <qmm> (guess i don't have a question)
11:19:45 <ph88> how to add optional functions to a class ? functions that don't need to be implemented for the minimal implementation
11:20:15 <ph88> is it also possible to have a condition that either one of two functions need to be implemented ?
11:21:20 <opqdonut> ph88: "optional" functions are just functions that have a default implementation
11:21:28 <ph88> oh ok
11:22:09 <opqdonut> and you can't really encode minimal implementation rules in the language, you just use documentation for that
11:22:33 <opqdonut> GHC will emit a warning if you don't give an implementation to a method that doesn't have a default implementation
11:22:59 <ph88> when i have two functions and implement them in term of each other does that encode that either one of them has to be implemented by the instance ?
11:23:20 <sm> muesli4: there are flags you can set to limit memory usage and avoid swapping
11:24:20 <opqdonut> ph88: no, not really. it might be completely valid mutual recursion for instance
11:24:54 <opqdonut> ah there's a GHC pragma
11:25:02 <opqdonut> for minimal complete definitions
11:25:18 <opqdonut> see e.g. http://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Show.html#Show
11:26:44 <ph88> opqdonut, i have this class and i want to add get2  https://paste.fedoraproject.org/547988/63226901/  most of the time i don't need the extra functionality that get2 offers, but for some situations i MUST give the extra argument that get2 takes .. but when i only implement get2 then ghc is gonna complain that get is not implemented
11:27:26 <ph88> likewise when i have the "normal" situation where get is implemented i don't really care about an implementation for get2
11:27:53 <opqdonut> perhaps it should be two classes then?
11:27:58 <ph88> so i was thinking to give a default implementation for both of them and express on in terms of the other
11:28:02 <opqdonut> right
11:28:11 <opqdonut> that would be typical
11:28:18 <ph88> get2 default implementation is easy   get2 _ = get
11:28:35 <opqdonut> ah
11:28:38 <opqdonut> yeah
11:29:09 <ph88> but for get i'm not sure, because get2 will need to be passed some function which doesn't really make sense
11:29:19 <ph88> get = get2 ???
11:29:20 <muesli4> sm: Thanks!
11:29:34 <ph88> get = get2 <something here>
11:29:53 <ph88> i guess i will have to decode myself what is the default function in this case ?
11:29:58 <ph88> decode -> decide
11:30:57 <opqdonut> if you know nothing of f there is no function f a -> f [a] you can use
11:31:12 <opqdonut> do you really need the default for get? can't you just define get and get2?
11:32:23 <ph88> i have two functions that are  f a -> f [a]  many and some  combinators
11:33:05 <opqdonut> in the context of the class definition you know nothing of f
11:33:13 <opqdonut> so you can't operate on values of type f a at all
11:33:46 <opqdonut> if the class was, say, "class Functor f => Rule f a where ..."
11:34:02 <opqdonut> then you coud use something like "fmap (\x -> [x])"
11:36:33 <ph88> i think i will go with   get = undefined  actually
11:37:11 <ph88> that way if get2 is implemented and get is not implemented then i will find out really quickly when somewhere else i use get when i'm suppose to use get2
11:39:22 <opqdonut> sounds like two type classes would be a better fit
11:39:32 <opqdonut> but I don't have the context
11:40:23 <muesli4> sm: I'm apparently not able to find any information on how to reduce the amount of used memory of stack and ghc. Could you point me to the right place?
11:41:20 <sm> muesli4: it's a ghc RTS option, something like +RTS -M500m, which you must pass to ghc through the layers of stack/cabal, I can never remember how
11:41:39 <muesli4> sm: Ah, I see.
11:41:43 <sm> stack build --ghc-options='+RTS -M500m' ?
11:42:13 <sm> see also ghc +RTS --help
11:44:54 <ClaudiusMaximus> does ghc still support environment variables for RTS options?
11:45:11 <monochrom> yes
11:45:36 <sm> muesli4: it's imprecise, but does influence the usage. Also, some cheap tricks: ensure you build one thing at a time (-j1), and build some lower level things first so you are building/linking fewer deps at once (stack build text; stack build myproj)
11:46:38 <muesli4> sm: I'm actually stuck at a single module. :)
11:46:43 <sm> ack
11:47:01 <sm> building with an older/newer GHC might also help
11:48:23 <ketil_> join #haskell
11:48:33 <monochrom> joined
11:48:38 <hpc> is that a new channel?
11:49:29 <ketil_> Anybody use travis-ci?  Do they support ghc 7.10 or 8 with language:haskell, or is it all the rage these days to use language:c and a huge yml file to hack things to work?
11:50:57 <ketil_> And: can I just drop ghc 7.4 support now?  I'm getting weird errors from using `fmap`.
11:52:55 <lyxia> 7.4 is pretty old, but whether you can drop support depends on circumstances only you know of.
11:54:52 <ketil_> lyxia: just supporting it out of habit - travis-ci makes it easy (but ghc or library incompatibilities make it hard)
11:57:18 <muesli4> sm: Thanks again. Instead of several hours it took only a few minutes.
12:01:41 <sm> muesli4: great, no problem
12:09:13 <sternmull> i am new to haskell. Should i ignore cabal and only use stack? Or do i need to know both?
12:10:01 <ph88> sternmull, start with stack and look into cabal when needed later
12:10:09 <dolio> I completely ignore stack.
12:10:26 <sternmull> now its getting complicated :)
12:10:39 <hpc> sternmull: it helps to know what each thing is
12:10:55 <hpc> sternmull: cabal does dependency resolution, downloads from hackage, and calls ghc to build packages
12:10:59 <geekosaur> sternmull, it's more a religious question tbh
12:11:23 <hpc> sternmull: stack lives on top of cabal and makes reproducible builds by specifying exact versions of packages, exact versions of ghc, and controlling the whole environment
12:11:46 <hpc> you can get by with either, or with neither and just building with ghc directly
12:11:49 <sternmull> for the moment i just want to get started with my tiny learning/test projects. Unfortunately i seem to need cabal/stack projects to make IDEs happy.
12:11:52 <hpc> though doing that last one is pretty miserable
12:12:01 <ph88> the callstack i get when i hit error only prints one callee and not the complete stack, how to get the full callstack ?
12:12:28 <monochrom> . o O ( The stack that can be traced is not the true stack :) )
12:12:37 <sm> hmm do IDEs not support non-cabal/stack code any more ?
12:12:42 <hpc> you might be happiest with cabal if you don't mind managing your environment
12:13:03 <hpc> or you might be happiest with stack if you don't mind being explicit in how everything you write is built
12:13:16 <ph88> monochrom, how to get the true stack? :P
12:13:16 <sternmull> at the moment my linux distro manages ghc and all the related tools.
12:14:30 <hpc> sternmull: in that case, you should use your distro's packaging for installing dependencies of your own code
12:14:42 <hpc> sternmull: or use stack, which has a separate environment if the distro isn't good enough
12:14:45 <ph88> sternmull, i would let stack handle all, i'm also a beginner and i found this the easiest and it works too
12:14:47 <sm> ph88: build in profiling mode, I think
12:14:58 <hpc> your distro will likely have stack as a package already, which makes it easier
12:15:08 <ph88> sm, i'm in ghci, do i need to compile outside of ghci and run ?
12:15:08 <hpc> stack is probably the way to go
12:15:10 <maerwald> cabal sandboxes are fine too
12:15:10 <sternmull> yes, i have stack installed as a package
12:15:18 <maerwald> you don't need stack really
12:15:33 <sm> ph88: yes, I think you'd need to restart ghci with the profiling flag, if that's supported
12:15:36 <maerwald> especially not for development
12:15:50 <ph88> sm, didn't even know ghci takes flags :/
12:16:10 <sm> almost everything takes flags
12:17:59 <sternmull> stack/cabal on windows? Do they both work? If i succeed my project has to run on Windows too.
12:18:17 <sm> stack
12:18:18 <hpc> they both work on windows
12:18:25 <hpc> in my experience, stack is muuuuuuuch better on windows
12:18:26 <ph88> i stopped taking flags since i quit CTF
12:18:26 <ph88> sternmull, i run stack on windows too, no problem
12:18:32 <ph88> sternmull, but sometimes when a haskell library needs some C headers then windows is not easy
12:19:05 <hpc> stack knows how to install some C libraries
12:19:18 <sternmull> ph88: Ok. I want to use yaml. The library depends on a C code...
12:19:44 <sm> use a different lib
12:20:30 <sm> or, build and ship the windows binaries yourself
12:20:50 <ph88> is there even a guide how to dynamic link haskell code on windows ?
12:21:09 <hpc> sm: not gonna lie, i subconsciously read that as "build a ship and sail away from windows"
12:22:01 <sm> heh, it's not that bad.. for some use cases you might need to do that no matter what (build-averse users)
12:22:16 <sm> but picking a pure haskell lib is much better if possible
12:22:39 <ph88> i have this small piece of template haskell https://paste.fedoraproject.org/548251/14863261/ is it possible to pass it a regular function as well ? or can functions only be used with $( )  ?
12:23:29 <ph88> sm, you were right building outside of stack gives slightly more information .. i pass a lot of debug flags that way
12:25:17 <sm> there's stack ghci --ghci-option=... too. Just a bit more hair-pulling
12:27:20 <ph88> i'm not bald yet so i'll give it a go
12:27:44 <ph88> by the way i use stack so i guess it will be something like   stack ghci -- --ghci-option  ?
12:29:33 <Welkin> or `stack exec -- ghci --option`
12:30:59 <sm> stack ghci --help lists --ghci-option, so 1 (or 3.. but not 2)
12:31:29 <sm> --ghci-options, rather
12:32:32 <vxr> hello
12:35:38 <Phyx-> C sources shouldn't be much of an issue anymore
12:36:03 <Phyx-> ph88: as in, make a dynamic library of your haskell code?
12:36:20 <zipper> Is there a haskell blockchain channel?
12:36:24 <zipper> Seems to me that everything I can find regarding blockchain involves some DSL and not like a haskell lib.
12:37:47 <reactormonk> in ghci, how do I save String instead of IO String from a readFile?
12:37:55 <hpc> save?
12:38:37 <Clint> rescue
12:38:47 <EvanR> ph88: you can factor out the optional methods into a different class which extends the original core one
12:39:04 <hpc> oh wait, derp
12:39:16 <hpc> reactormonk: contents <- readFile "/etc/passwd"
12:39:26 <hpc> ghci is a lot like a giant do-block
12:44:17 <pikajude> with imports
12:45:02 <hpc> reactormonk: if your next question is how to do it in a regular file, the answer is far more educational :D
12:45:22 <hpc> if you don't read about it first
12:49:33 <reactormonk> hpc, yeah, I know the rest, just wondering specifically about ghci.
12:52:00 <eschnett> I’m looking at free applicative functors, e.g. described in https://paolocapriotti.com/assets/applicative.pdf . I notice that Control.Applicative.Free <https://hackage.haskell.org/package/free-4.12.4/docs/Control-Applicative-Free.html> uses a different representation — the type parameters are reversed. Why?
12:52:46 <eschnett> I would have expected `Ap :: f b -> Ap f (b -> a) -> Ap f a`, but the `a` and `b` are reversed…
12:55:52 <Tuplanolla> It's a Haskell convention to name the types such that functions go from `a` to `b`, eschnett.
12:56:37 <eschnett> Tuplanolla: Isn’t `a` bound by the type declaration?
12:56:51 <eschnett> `data Ap f a where` …
12:57:21 <Tuplanolla> Oh, I see what you mean now.
12:59:15 <sm> Phyx-: re "C sources shouldn't be much of an issue anymore" - why's that ? more details welcome
12:59:33 <fendor> hello! i started programming in haskell a while ago and started to implement a connect four game and i was wondering myself, is there any convention for an application architecture?
12:59:59 <fendor> i just started coding and introduced functions, after a while, i used the elm architecture to define updates and models
13:00:39 <fendor> i could not find any resources on how to develop a program in haskell, and how the architecure may look like
13:00:42 <sm> fendor: for a game, your gui framework/game engine will often determine it
13:01:56 <Tuplanolla> You should probably ask edwardk since he wrote that thing, eschnett.
13:02:16 <fendor> well, in the current state, the gui is not final, it may be something drawn by gloss, but it might as well be a server application that you can play with over a webinterface
13:03:52 <Phyx-> sm: well, mostly because the runtime linker has had significant changes since 7.x days. 7.10.3 added lazy linking support, enabling support for linking against static libraries like mingwex, 8.0.1 fixed relocation issues, library search paths were expanded etc. 8.0.2 added import libraries support and better handling of object files. 8.2 will add better support for dynamicly linked libraries
13:04:37 <Phyx-> and 8.4 will add full dynamic linking support so GHC itself can switch to dynamicly linked libraries, after this we can adopt the same linking procedures as the unix codebase
13:05:04 <Phyx-> the problem is though, you still need to properly configure your searchpath
13:05:26 <lyxia> eschnett: it's not bound
13:06:00 <sm> Phyx-: this all sounds very good, but I think it's concerned with linking - the advice to choose pure haskell deps if you want your app to build easily on windows is still valid, yes ?
13:06:10 <lyxia> eschnett: you could write data Ap g x where...  and not change the other variables. 
13:06:38 <lyxia> eschnett: or even data Ap_ _ where 
13:07:35 <lyxia> The type signatures of constructors are independent
13:07:53 <eschnett> lyxia: oh, thanks. apparently i need to re-read about data syntax.
13:08:13 <Tuplanolla> That only applies to `GADTSyntax` though, eschnett.
13:08:34 <lyxia> Ap :: forall a b. f a -> Ap f (a -> b) -> Ap f b
13:08:37 <Phyx-> sm: not really, linking *is* the major sore point. If you have a library that's portable, then it should work. A lot of difficulties people have had in the past is linking. When I try to build hackage, i hit two issues mostly. Linking and the use of the unix package
13:09:41 <Phyx-> sm: I can't do anything about B, but A has gotten significantly better. THat said, it's true that a lot of libraries are simply untested on Windows, mostly because their writers couldn't get it to work before.
13:09:52 <Phyx-> oh and 8.4 will add support for statically linked C++ code
13:09:57 <sm> Phyx-: what about, say http://hackage.haskell.org/package/regex-pcre. Will stack install regex-pcre work ?
13:10:25 <sm> are you working on making this better ? if so, thank you!
13:13:39 <Phyx-> sm: if pcre is installed then yes, likely you'll have to do "pacman -S mingw-w64-(uname -m)-pcre"
13:14:02 <Phyx-> but after that it should work if stack has it's include and lib directories setup correctly, which I assume they have
13:14:12 <Phyx-> I don't use stack so can't say much about it
13:14:26 <sm> how about cabal install regex-pcre ? 
13:14:49 <sm> it sounds more doable than in the past, but still definitely not "just works"
13:15:14 <sm> or "well documented and understood"
13:16:18 <Phyx-> both suffer the same issue really. The biggest question is how to install and find these libraries. if you use stack you have msys2 and pacman. if you use cabal, you have to specify a place to look.
13:16:36 <Phyx-> though this is an issue for *all* compilers on Windows, not just GHC
13:16:40 <sm> sure
13:17:07 <sm> well good to know about stack providing pacman, I wasn't sure about that
13:17:45 <sm> it sounds like windows haskellers could write up a pretty reliable how-to for installing many popular C-based hackage packages
13:18:13 <sm> ie, paste these 3-4 commands and it will work
13:18:35 <fendor> hey, i got another question, what would good learning materials for haskell?
13:19:19 <sternmull> fendor: I spend the last two days reading the wikibook and found it really good.
13:19:36 <sternmull> this one: https://en.wikibooks.org/wiki/Haskell/
13:20:40 <sternmull> ...and just a few minutes ago i found out that atom with the "haskell-ide" plugin works really nice. The fun can go on.
13:21:18 <fendor> sternmull: ok, do they also have an oppurtunity to test your knowledge? i read the book "learn yourself a haskell for great good" but i'd like to do some things on my own too?
13:21:55 <sternmull> fendor: Yes, there are exercises.
13:22:07 <fendor> well, "haskell-ide" fails sometimes terribly and in combination with ghc-mod, if you want to edit a file without a .cabal file, loads of error messages pop up
13:22:51 <fendor> switched to visual studio code for that reason, although the initial problem persists but isn't as invasive as the atom plugin
13:22:55 <sternmull> fendor: But to be honest i skipped the most of the exercises when i was sure i understood it... was impatient to learn the rest.
13:23:34 <fendor> yeah, me too, switiching the topics all the time, but i guess i should more focus on one topic
13:24:12 <ertes> fendor: https://www.seas.upenn.edu/~cis194/spring13/lectures.html
13:24:18 <sternmull> fendor: I tested Atom only for a few minutes now. But so far everything works perfectly: Highlighting, auto-completion, building, linting, ... really nice.
13:24:39 <ertes> fendor: and if that's too easy, there is also the NICTA course, or alternatively: just start doing something with haskell
13:24:42 <ertes> start a project
13:25:04 <reactormonk> I've got something with lenses lying around, if you wanna tinker with it.
13:25:08 <fendor> yeah, working on it, connect-four, but i lack of an idea of how the architecture should look like
13:25:10 <ertes> at some point you have to make the transition from "i'm learning" to "i'm using" =)
13:26:16 <fendor> i already am using it, i just love it, im studying computer science for 4 years now and for everything not related to university, i use haskell, but i want to extend my knowledge to practical projects
13:27:21 <fendor> ok, can someone explain to me, how i can answer directly? :D never used irc before
13:27:23 <sternmull> fendor: You could pick some existing interesting project and hack around in it. Maybe you discover new interesting approaches this way.
13:27:28 <ertes> fendor: then what would you like to learn?  at this point it's your choice
13:27:41 <Koterpillar> fendor: like this
13:28:04 <fendor> just the name followed by a colon?
13:28:04 <ertes> fendor: perhaps pick up a web framework and write a web app, or pick up an FRP framework and do something interactive
13:28:13 <Tuplanolla> You just refer to another person by name, fendor. It's like real life but better.
13:28:29 <fendor> would reactive banana be a good start for an frp framework?
13:28:45 <ertes> fendor: also hint: type "Kote" and hit tab
13:29:00 <ertes> fendor: yes, reactive-banana is an excellent FRP framework
13:29:06 <sternmull> fendor: Antoher thing that helped me is to find haskell-implementations of problems/algorithms that i know. So i know what they do and can learn how to implement them in haskell.
13:29:09 <fendor> ertes: oh nice, thanks a lot
13:30:29 <fendor> ertes: so, yesod would be good idea, wouldnt it? I tried it a while back, but i had a lack of ideas of what i could create
13:30:49 <fendor> sternmull: you mean for example to implement my own AVL tree?
13:31:34 <sternmull> fendor: for me it was stuff like astar or path-tracing. Simple algorithms for which i was curious how an haskell implementation would look like.
13:32:46 <fendor> sternmull: so also BFS and DFS on a graph?
13:33:37 <sternmull> fendor: Stuff like that, yes. Whatever you are interested in.
13:34:30 <fendor> sternmull: ok thanks, i will think about it 
13:35:01 <fendor> but still, the overall question was, are there conventions on how the architecture of a haskell program should look like?
13:35:23 <fendor> would the elm architecture be an easy and good enough architecture?
13:35:25 <monochrom> sternmull: My http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.html (there is a "Source" link at the top right corner)
13:36:04 <monochrom> Marvel at my exemplary doc-to-code ratio!
13:37:00 <ertes> fendor: personally i don't like yesod, because it relies so much on magic that i have no idea what's really going on
13:37:08 <sternmull> monochrom: I am not sure what i am looking at... do you show this to me because it could be used for graph search stuff?
13:37:20 <ertes> fendor: currently i'd go for snap or, in simpler cases, even scotty
13:38:48 <fendor> ertes: what exactly you didnt like? i read the introductions and it seemed really cool, of course magic, but still fun stuff, lucius and julius and hamlet. Can i use them too in scotty and snap? And why would you recommend the other two?
13:40:02 <ertes> fendor: i prefer the compositional design of snap over the monolithic design of yesod
13:40:25 <ertes> yesod: "integrate everything"
13:40:30 <ertes> snap: "compose me with everything"
13:41:33 <fendor> ok thank you for the tips, i will look into it right now
13:41:52 <ertes> back when i was using yesod i couldn't even figure out how subsites work properly, because there was so much magic involved that i couldn't just look at the types
13:41:54 <fendor> *i am going to look into it 
13:42:05 <fendor> yeah, the types are terrible
13:42:19 <boojinks> hey all, are there any libraries that give a similar feel to BeautifulSoup?
13:42:20 <geekosaur> hamlet only requires wai/warp and can be used with pretty much everything. there's an adaptor for happstack, other stuff you iirc just plug whamlets in at the warp level
13:42:24 <fendor> but i think purescript's typesystem is almost worse
13:43:07 <ertes> yeah, shakespeare templates work with everything, but then again:  the magic seems unnecessary, so i'd rather go with something compositional like lucid and clay
13:43:15 <fendor> geekosaur: i read all this template librarys can be used with almost every web framework, is that right?
13:43:20 <ertes> and jmacro, if you need javascript…  or even GHCJS
13:43:49 <geekosaur> fendor, mostly. again. most of it plugs in at the warp/wai level, which underlies almost every web framework
13:43:49 <fendor> ertes: lucid and clay are template languages as well?
13:44:04 <fendor> geekosaur: ok cool, thx!
13:44:16 <ertes> fendor: they are combinator libraries for constructing HTML and CSS respectively
13:44:43 <fendor> they are also checked at compile time, i suppose? 
13:44:48 <ertes> p_ ("Heed my " <> em_ "emphasised words!")
13:45:52 <ertes> yes, but not in the sense that they will check standards compliance
13:46:06 <ertes> only that you can't have unescaped HTML fragments, unless you ask for it
13:46:28 <hpc> you could probably try writing one that does check standards compliance
13:46:32 <hpc> but the standards are pretty heinous
13:47:00 <fendor> ertes: well, thats better than nothing, but i can still provide undefined elements?
13:47:28 <fendor> hpc: i see, it is css and html after all
14:04:47 <ertes> fendor: to be honest HTML/CSS compliance has never worried me as much as some of the more important things like security
14:05:18 <ertes> similarly there was a period when people were going crazy about statically checked routes
14:05:47 <ertes> when ultimately it's one of the least important things, and the least likely to ever bite you in practice
14:06:59 <ertes> libraries like web-routes make it reasonably practical, but personally i wouldn't bother even with that anymore
14:07:40 <Koterpillar> it's nice to have typed routes though
14:07:48 <ertes> it is however very important to get stuff like forms right both to validate user inputs properly and to prevent some of the more common web vulnerabilities like CSRF
14:08:38 <ertes> and for that we have libraries like digestive-functors
14:08:58 <ertes> (or rather its backends)
14:19:46 <pikajude> hi, i want to use the Generic default implementation for web-routes toPathSegments, but I want to override it for one constructor of my ADT
14:19:57 <pikajude> gToPathSegments isn't exported though :(
14:20:02 <pikajude> is there any way to do this
14:37:56 <filthyCausual> @pl f v = g <$> v
14:37:56 <lambdabot> f = (g <$>)
14:38:07 <filthyCausual> @pl f v = g <$> h v
14:38:07 <lambdabot> f = (g <$>) . h
14:41:35 <erisco> how do you import * with DataKinds ?
14:44:38 <erisco> ah, import Data.Kind (type (*))
14:45:04 <erisco> little odd that you cannot just use *
15:01:29 <barrucadu> pikajude: You can use the template haskell instance-deriver and selectively override things. I have a small example here: https://github.com/barrucadu/bookdb/blob/master/src/Routes.hs#L60
15:02:16 <barrucadu> That's from the web-routes-th package
15:43:23 <pikajude> ok
15:56:21 <noan> If anyone knows Matt Parsons, thank him for me for http://www.parsonsmatt.org/2015/06/07/servant-persistent.html
15:56:29 <noan> That man has saved me a lot of headaches.
15:57:24 <hoppfull> Hey, what's up? I just checked out property based testing and it's really cool. Very terse. I wonder what you guys think about keeping tests together with implementation in the same source files.
15:57:49 <hoppfull> Property based tests say a lot about intended use so code becomes self documenting.
16:00:37 <jle`> sometimes people include them with implementations as doctests
16:01:19 <jle`> like, writing property tests as a part of the documentation for the functions, and having the CI suite detect and run them
16:02:37 <hoppfull> Cool
16:03:17 <erisco> what is a property test?
16:04:16 <hoppfull> Tomorrow me and my friend starts writing code for our thesis. It's in C# but it's still quite terse so I started thinking that maybe it would be a good idea to keep tests together with implementation. http://pastebin.com/i94G2s2n
16:04:32 <hoppfull> erisco: Check out this: http://pastebin.com/i94G2s2n
16:04:54 <erisco> hm, I still have the same question
16:05:05 <hoppfull> erisco: Basically the tests checks that f(x) always returns a positive number
16:05:13 <erisco> how does it do that?
16:05:15 <hoppfull> erisco: I just came here, perhaps I can help you.
16:06:04 <hoppfull> erisco: It seems to generate a whole bunch of random numbers and when it finds something that disproves your assertion, it starts looking for the simplest case that disprove it and tells you about it.
16:06:16 <erisco> so, it is just unit testing
16:07:18 <hoppfull> It fills the same function. Though I am not sure if it is strictly unit testing.
16:07:23 <hoppfull> I'm pretty new to this.
16:07:24 <filthyCausual> Sort of? I find that the random generation finds more bugs then traditional unit test would.
16:07:39 <nshepperd> well, sort of, but usually tests conceived as 'unit tests' have a fixed input-output pair
16:07:58 <erisco> depends on how you write unit tests. I've never written them that way
16:08:06 <hoppfull> filthyCasual: It seems like the world of functional programming is lifting another weight off my shoulder.
16:08:10 <erisco> I write them in terms of relations
16:08:28 <nshepperd> proptests aim to test forall x y. statements
16:09:03 <erisco> random inputs isn't good for reproducibility of test failures (or successes)
16:09:19 <hoppfull> Please note that I am not an experienced programmer. Only last friday did I land an internship (where they use F#) so I am quite inexperienced.
16:09:48 <Koterpillar> erisco: correct, but it is good for finding edge cases
16:10:04 <nshepperd> erisco: quickCheck prints out the failing input
16:10:06 <erisco> why not generate some random inputs and paste them in as the test cases
16:10:10 <erisco> then you get one consistent list
16:10:24 <nshepperd> because that has less coverage
16:10:36 <nshepperd> why have less coverage when you can have more
16:10:49 <Koterpillar> erisco: because letting quickcheck do it is easier
16:11:00 <Koterpillar> erisco: especially since you don't have to worry about the types
16:11:09 <erisco> there is quickcheck for C#?
16:11:15 <hoppfull> FsCheck
16:11:20 <hoppfull> http://pastebin.com/i94G2s2n
16:11:31 <nshepperd> iirc quickcheck can also be made to print out a command to reproduce an exact test case, by supplying the seed or something
16:12:10 <Koterpillar> Is there an option to "pin" a test, so that a particular edge case is always executed?
16:12:35 <erisco> hm, well I can see the validity of the arguments for random tests
16:12:50 <hoppfull> In case of C# instead of using [Property] you just use [Fact] and test a single specific case.
16:12:55 <erisco> still am not excited about the idea
16:14:02 <erisco> you definitely want at least some consistent lists of tests
16:14:08 <erisco> otherwise how are you supposed to prevent regressions
16:14:14 <hoppfull> erisco: As someone who isn't very experienced with TDD, I'd love to learn more about your scepticism. What do you think could go wrong with this kind of philosophy?
16:14:34 <erisco> a consistent list of tests + random tests seems alright
16:15:04 <hoppfull> erisco: That sounds reasonable!
16:15:28 <nshepperd> Koterpillar: I dunno if in quickcheck itself, but a framework like tasty would let you add tests alongside a QuickCheck test that just applies the test with some explicit arguments
16:15:43 <hoppfull> erisco: What's a regression test?
16:15:43 <erisco> well there is the issue I just stated i.e. regressions, but then also I am concerned about reproducing the errors
16:15:44 <nshepperd> i think
16:16:02 <erisco> if I get the error then how do I easily give this to my coworker to fix?
16:16:09 <nshepperd> like you can turn a proptest into a normal unit test by just applying it to some arguments
16:16:11 <erisco> if that is easy then not a problem
16:16:32 <Koterpillar> erisco: QuickCheck lets you set an environment variable to a seed, which is printed on failure
16:16:45 <erisco> hoppfull, once you discover there is an error you want to add a test that reproduces this error. Then you fix the error and the test passes. If someone makes the same boo-boo again this test will catch it
16:16:56 <erisco> if your tests are only random then you do not have this assurance
16:17:06 <nshepperd> erisco: sure, when it fails it prints out the failing input. then you can just say 'test xyz fails with inputs foobar! fix it!'
16:17:38 <hoppfull> What are regressions?
16:17:55 <erisco> things that break which were not broken before
16:17:59 <lordcirth> hoppfull, regressions are when something that used to work, doesn't.
16:18:01 <hoppfull> ah
16:18:04 <lordcirth> ie, going backwards
16:18:07 <hoppfull> Fascinating
16:18:20 <lordcirth> as opposed to a bug in a new feature, which is less bad
16:21:10 <nshepperd> the problem with unit tests is you straight up forget to include the corner cases, which proptests would automatically find. so a mixture of boths gets the best of both worlds imo
16:23:07 <Tuplanolla> I see `Network.Socket` supports some `AF_CAN`. What is it?
16:23:09 <davean> nshepperd: sadly I find the only thing good at finding the corner cases is a skilled hostile tester
16:23:49 <davean> Tuplanolla: https://en.wikipedia.org/wiki/SocketCAN
16:24:31 <Tuplanolla> I see some talk about drivers.
16:24:39 <davean> ?
16:25:17 <Tuplanolla> This seems to explain it better: https://www.kernel.org/doc/Documentation/networking/can.txt
16:25:17 <erisco> nshepperd, why do you forget? I try not to :P
16:25:28 <Tuplanolla> I still don't know if I want to touch it though.
16:26:00 <Koterpillar> Tuplanolla: "if you don't know what it is, you don't need it"
16:26:08 <erisco> it isn't particularly difficult. Ints? -2, -1, 0, 1, 2 and some values around that
16:26:18 <erisco> lists? empty list, singleton list, list of two elements, then some other lists
16:26:22 <Koterpillar> erisco: graphs?
16:26:30 <erisco> what is your encoding?
16:26:41 <nshepperd> erisco: "If I should not forget the corner cases, I wouldst not need for tests"
16:27:28 <Koterpillar> erisco: doesn't matter. These structures and algorithms on them might have a corner case of "a perfectly balanced tree", say
16:27:49 <erisco> sure, but you're just hoping random tests stumble on these
16:27:57 <erisco> which is arguably better than nothing guessing
16:29:25 <mbw> Are there any resources on *learning* Http/sockets/web programming with Haskell that do not assume any prior knowledge?
16:30:25 <nshepperd> it's better than hoping that I'll stumble on them. I'm not even random! and you can't run me 1000 times a day :p
16:31:02 <erisco> I'm fine with that. I just don't want anyone too satisfied with it :P
16:31:23 <Koterpillar> all of these are just some approximations of proofs
16:31:34 <erisco> exactly
16:31:43 <Koterpillar> "it runs on -1, 0, 1" "it runs on 1000 random cases"
16:32:28 <Koterpillar> doesn't beat "it runs, QED"
16:34:52 <erisco> there was a project called Code Contracts for C# which tried to do some verification... it is still kicking but not much
16:35:48 <Koterpillar> do they have compiler integration?
16:36:48 <Koterpillar> also, http://joeduffyblog.com/2016/02/07/the-error-model/
16:37:12 <erisco> the main bit is a preprocessor. I am guessing it leverages the compiler to do analysis
16:38:02 <Koterpillar> it's easy to specify contracts and enforce them at runtime (Ruby has a library, for example), but that doesn't help with proofs
16:38:35 <erisco> it does static verification and optionally will put in runtime checks for what it cannot prove
16:40:28 <erisco> hoppfull, also, your test fails
16:41:04 <Koterpillar> not if I didn't think of the edge case (or quickcheck didn't find it)
16:41:54 <erisco> I thought of it :P
16:42:30 <hoppfull> erisco: I tried to get code contracts to work for compile time static checking but it isn't working in latest versions of visual studio. It's basically just runtime checking right now.
16:42:31 <Koterpillar> oh! I misread that nick as "hopefully, also, your test fails"
16:42:50 <erisco> hoppfull, I had a miserable time with it. I couldn't recommend it
16:43:51 <hoppfull> erisco: It seemed cool a two years ago when it worked. It was like getting refinement types in C#.
16:48:39 <erisco> jle`, any hints with negation? I have seen a -> Void used but I can't see what this really informs the type checker of
16:50:55 <erisco> I can't construct an a -> Void either
17:02:04 <xcmw> How can I configure stack to use ghc 8.0.3? I need a bugfix that did not make 8.0.2
17:02:30 <kadoban> Do you need it to install it too?
17:02:37 <Koterpillar> xcmw: compiler-check: newer-minor?
17:02:53 <kadoban> Ya, mostly that ^
17:03:11 <Koterpillar> https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md#compiler
17:03:17 <kadoban> Though you can specify exactly 8.0.2 if you like as well, not really sure which is the better idea in general.
17:03:50 <Ptival> so, the only way to flip two arguments of a type constructor is to make a newtype?
17:04:08 <Ptival> (if one wishes to eventually partially apply it)
17:04:13 <erisco> yes
17:04:18 <Ptival> thanks
17:05:35 <tapirus> Beginner question: what'd be the most idiomatic way to do something like somethingLikePrint [1,2,3,4] so that it prints '1 2 3 4' without quotes
17:06:24 <erisco> > (unwords . fmap show) [1,2,3,4]
17:06:27 <lambdabot>  "1 2 3 4"
17:06:29 <Koterpillar> > traverse print [1, 2, 3, 4]
17:06:31 <lambdabot>  <IO [()]>
17:06:34 <Koterpillar> err
17:06:58 <erisco> well then you'd use print, not show
17:07:07 <erisco> can't make lambdabot do that afaik
17:07:43 <kadoban> Was going to say something like: putStrLn . unwords . map show
17:08:12 <erisco> or I guess print is putStrLn . show
17:08:20 <xcmw> Koterpillar: That does not work for me. stack build does nothing after changing that. 8.0.3 is not released yet
17:08:55 <Koterpillar> xcmw: what about compiler: as I linked later?
17:09:00 <jle`> erisco: the (a -> Void) negation in haskell is mostly useful because it 'composes'
17:09:16 <jle`> you can build complex negation proofs by composing simpler ones that you might get
17:09:29 <kadoban> xcmw: stack is very unlikely to know how to install 8.0.3 for you, so you'll probably have to do that part yourself and use --system-ghc, or figure out how to teach it, which I forget how you do
17:09:36 <hpc> erisco: for certain a you are able to construct it
17:09:57 <hpc> erisco: you can't provide proof that anything implies false, but you can prove that false implies false
17:10:02 <erisco> okay I just need to see it in action then... what is the double negation proof i.e. ((a -> Void) -> Void) -> a ?
17:10:11 <erisco> it doesn't even seem to make sense =\
17:10:20 <jle`> erisco: and you can make some "primitive" (a -> Void)'s whenever you have a type 'a' with no constructors
17:10:27 <jle`> foo = \case {}
17:10:29 <hpc> double-negation elimination can't be written constructively
17:10:39 <jle`> erisco: double negation is not something you have in haskell
17:10:48 <hpc> you can do quad-to-double though
17:10:54 <hpc> and that's join for the "classical" monad
17:11:12 <hpc> join :: ¬¬(¬¬a) -> ¬¬a
17:11:23 <jle`> but you can prove like, say, if (n = m) is not true, then so is (S n = S m)
17:11:38 <jle`> erisco: that would go like ((n = m) -> Void) -> (S n = S m) -> Void
17:11:48 <jle`> s/so/neither
17:11:56 <hpc> @djinn ((((a -> Void) -> Void) -> Void) -> Void) -> ((a -> Void) -> Void) -> a
17:11:56 <lambdabot> -- f cannot be realized.
17:12:00 <hpc> @djinn ((((a -> Void) -> Void) -> Void) -> Void) -> ((a -> Void) -> Void)
17:12:00 <lambdabot> f a b = void (a (\ c -> void (c b)))
17:12:25 <hpc> cool, i didn't even know if djinn knew Void
17:12:45 <erisco> okay, so if we wanted a logic with double negation we'd have to choose something else for negation
17:12:55 <erisco> double negation elimination
17:13:06 <hpc> or we can embed it inside another double-negation
17:13:37 <hpc> and you can eliminate all but one of those doubles
17:14:02 <erisco> jle`, okay, so lets take your last example... what would that proof look like?
17:14:06 <erisco> again it doesn't make sense to me
17:15:17 <hpc> erisco: you would use (S n = S m) -> (n = m)
17:15:27 <jle`> foo f x = f (predEq x)
17:15:40 <jle`> where, yeah, predEq :: (S n = S m) -> (n = m)
17:15:56 <hpc> it turns refl :: (S n = S m) into refl :: (n = m)
17:15:57 <jle`> so in that case foo :: ((n = m) -> Void) -> (S n = S m) -> Void
17:16:03 <hpc> and then you pass it on to the function you got
17:16:28 <hpc> erisco: have you tried agda yet?
17:17:21 <hpc> if you haven't, you're pretty much ready for it with these sorts of questions and it opens a whole new area of type theory
17:17:44 <halogenandtoast> If I have `data NhkDateGrouping = NhkDateGrouping (Map String [NhkArticle])` and I want to get the array out, how can I do that, I'm trying `printDateGrouping (NhkDateGrouping (Map _ xs)) = undefined` but I'm getting `Not in scope: data constructor ‘Map’` so I feel like I have something fundamentally wrong.
17:17:52 <erisco> I am getting along with Haskell for now. Still lots to figure out
17:18:15 <jle`> halogenandtoast: Map is a type
17:18:16 <erisco> I see how the proof works. I'll have to mull it over some
17:18:24 <jle`> it doesn't "contain" an array
17:18:28 <hpc> halogenandtoast: you can't pattern match on Map
17:18:31 <jle`> its data constructor isn't Map
17:18:32 <xcmw> kadoban: How would I do that? I need https://git.haskell.org/ghc.git/commitdiff/3540d1e1a23926ce0a8a6ae83a36f5f6b2497ccf or later
17:18:50 <jle`> halogenandtoast: 'Map _ xs' isn't the constructor of a type (Map String [NhkArticle])
17:18:54 <hpc> halogenandtoast: (Map String [foo]) is a key-value data structure that looks up values of type [foo] by values of type String
17:18:57 <jle`> halogenandtoast: are you familiar with constructors, and types?
17:19:10 <jle`> like, for example, 'Maybe Int' has two constructors, 'Just x' and 'Nothing'
17:19:13 <hpc> halogenandtoast: so you would instead do printDateGrouping (NhkDateGrouping map) = ...
17:19:22 <halogenandtoast> jle`: briefly, and I'm not sure why I thought that was possible...
17:19:24 <jle`> and if you have a value of type 'Maybe Int', you could pattern match on the 'Just x' and 'Nothing' constructors
17:19:30 <hpc> halogenandtoast: and inside "..." you would look up in the map by some particular string
17:19:30 <halogenandtoast> Right
17:19:41 <hpc> halogenandtoast: and decide what to do if you don't find anything
17:19:49 <jle`> but, 'Map String [NhkArticle]''s constructor is *not* 'Map s xs'
17:19:50 <hpc> (since not all keys map to values)
17:20:06 <jle`> in general, for most types, the constructor isn't the same as the type name
17:20:29 <jle`> (see Maybe and Just/Nothing)
17:20:38 <hpc> halogenandtoast: as for keeping straight what level (type or value) you are at, consider the following:
17:20:48 <hpc> halogenandtoast: data Bool = False | True
17:20:54 <hpc> foo :: Bool -> String
17:20:56 <hpc> foo False = ""
17:20:59 <hpc> foo True = "yes"
17:21:14 <jle`> halogenandtoast: if you're using Map from the standard libraries, 'Map' is implemented as an abstract data type, so it actually doesn't expose any constructors directly
17:21:27 <halogenandtoast> Yeah as soon as you guys said that, I realized how absurd I was being.
17:21:27 <kadoban> xcmw: Which part? Telling stack how to install a different GHC version? I'd have to look it up.
17:21:29 <jle`> halogenandtoast: you have to manipulate it using the API that the Data.Map module exports for the type
17:21:32 <halogenandtoast> I blame it being early
17:21:38 <jle`> that's fair :)
17:21:44 <halogenandtoast> *blame it on being early
17:21:52 <hpc> halogenandtoast: it's really hard to keep straight when you're still new to the syntax :)
17:22:37 <hpc> it'll get really easy with just more exposure to it
17:24:49 <Ptival> erisco: do you know if there's a standard way of naming the function extract :: FlippedSomething a b -> Something b a?
17:25:22 <Koterpillar> unFlipped?
17:25:23 <erisco> usually if your newtype's name is X the field is called runX or unX or getX
17:25:39 <Ptival> ah, unX sounds good yeah
17:29:29 <xcmw> kadoban: The entire thing. A link to instructions is fine. My googling is not coming up with anything
17:30:00 <halogenandtoast> Next, probably dumb, question... If I have `data NhkDateGrouping = NhkDateGrouping (Map String [NhkArticle]) ` and `printDateGrouping (NhkDateGrouping m) = (printNhkArticles . elems) m` and finally `printNhkArticles :: [NhkArticle] -> IO ()` why am I getting `Couldn't match type ‘NhkArticle’ with ‘[NhkArticle]’`
17:30:17 <halogenandtoast> nvm I think I know
17:30:22 <halogenandtoast> I need to flatten
17:30:25 <halogenandtoast> `concat`
17:31:09 <halogenandtoast> and that was correct.
17:36:38 <Ptival> q: if I have   data Foo (φ :: * -> *) ξ = MkFoo (φ ξ)  is there anything I can pass to Foo to get the effect of identity?
17:38:04 <Koterpillar> Data.Functor.Identity.Identity
17:42:00 <jle`> Foo is IdentityT
17:42:12 <jle`> so you could pass in Identity, heh
17:42:29 <jle`> IdentityT Identity = Identity
17:42:43 <jle`> er, s/=/is isomorphic to
17:42:57 <jle`> well IdentityT f ~ f, in general
17:43:47 <xcmw> kadoban: I found instructions. I think I see how to do it
17:47:04 <halogenandtoast> Is there any way to see how/why Aeson failed to parse some JSON
18:00:29 <qmm> how would i run a warp server on top of cloud haskell? 
18:02:44 <lpaste> qmm pasted “attempt at running warp on cloud haskell” at http://lpaste.net/352119
18:04:33 <qmm> forkProcess :: LocalNode -> Process () -> IO ProcessId
18:05:12 <qmm> run :: Port -> Application -> IO ()
18:05:54 <qmm> i guess my question is how to turn IO () into a Process ()
18:06:07 <qmm> https://hackage.haskell.org/package/distributed-process-0.6.6/docs/Control-Distributed-Process-Internal-Types.html#t:Process
18:06:36 <qmm> it derives MonadIO
18:09:28 <qmm> the end goal is to supervise the wai application
18:10:54 <qmm> maybe i should have asked "how do i run a wai application on cloud haskell" :)
18:12:00 <qmm> but my real question is:  how to turn IO () into a Process ()
18:12:15 <qmm> (i think)
18:34:03 <redmq> what version of alex gets used if a project depends on a project which contains a *.x file?
18:34:38 <redmq> i'm trying to compile a project which has as a dependency language-c-comments-0.3, but it's failing in the generated lexer code from a *.x file
18:35:08 <redmq> however if i do `stack unpack language-c-comments-0.3` and in that directory do `stack build` there are no issues (both are on stackage lts-7.19)
18:36:00 <redmq> tl;dl it seems language-c-comments-0.3 compiles on its own but not as a dependency even though both times i use lts-7.18
18:36:05 <redmq> 7.19**
18:43:48 <MarcelineVQ> what's your stack.yaml look like?
18:49:02 <redmq> MarcelineVQ: for the standalone (where language-c-comments-0.3 compiles successfully) it's just `stack unpack language-c-comments-0.3; cd language-c-comments-0.3; stack init; vim stack.yaml` to add language-c-comments-0.3 to extra deps and then build succeeds
18:49:39 <redmq> MarcelineVQ: for the project which has language-c-comments-0.3 as a dependency, the stack.yaml is the same (vanilla result of `stack new` with language-c-comments-0.3 added to extra deps)
18:51:43 <redmq> ** ah the standalone is language-c-comments-0.3, it doesn't have itself in extra deps
18:51:49 <redmq> i'll paste.
18:56:56 <MarcelineVQ> I also get errors when trying to simply use it as an extra-dep, not sure which part is the issue given that it's 3 years old, I'd recommend using a local package if you're able to get it to build by itself:  http://lpaste.net/352120
18:59:55 <redmq> MarcelineVQ: here's my repro http://lpaste.net/3420369529123897344
19:00:19 <redmq> yeah, i probably will just use it as a local package; just wondering if there was more to be learned about how alex gets resolved though
19:04:44 <MarcelineVQ> dunno, cabal-install also chokes on it when built as a depdendency
19:05:23 <redmq> weird!
19:05:33 <redmq> this didn't happen a few weeks ago when i was developing on a different machine
19:05:55 <redmq> i suppose it's a recent change in the cabal library then, since that machine hadn't had its toolset updated in awhile
19:06:04 <redmq> unfortunately that machine has now been wiped 
19:08:35 <MarcelineVQ> I wonder if it's beause it has a dist directory, somehow allowing some things to not be rebuilt that should be, like the generated Lexer.hs
19:09:14 <MarcelineVQ> I know basically nothing about that though, so just spitballing
19:11:13 <redmq> i don't see a dist directory in the repo: https://github.com/ghulette/language-c-comments
19:11:28 <MarcelineVQ> http://hackage.haskell.org/package/language-c-comments-0.3/src/
19:14:24 <redmq> oh, interesting
19:15:09 <redmq> i cloned the repo and did `stack sdist` .. the resulting tarball does not have a dist dir, but leaves the *.x file as is.. perhaps the source distribution format has changed since the package was updated
19:20:51 <redmq> MarcelineVQ: local package workaround fixed it, for now.. thank you!
19:22:30 <MarcelineVQ> np, weird issue
19:32:19 <banrash> q
19:36:43 <xcmw_> How can I tell stack to use a custom built ghc?
19:37:16 <kadoban> --system-ghc I believe, you also need the compiler settings such that it'll accept that one.
19:45:35 <xcmw_> kadoban: Apparantly I built the wrong version. How can I build 8.0.3. I says I built 8.1.20170206.
19:45:50 <xcmw_> I used git
19:46:10 <kadoban> No idea honestly. Maybe you checked out the wrong tag, at a guess?
19:46:24 <geekosaur> check out ghc-8.0 branch
19:46:30 <geekosaur> you built HEAD
19:46:54 <xcmw_> I need this commit. https://git.haskell.org/ghc.git/commitdiff/3540d1e1a23926ce0a8a6ae83a36f5f6b2497ccf
19:47:27 <xcmw_> Will ghc-8.0 have that?
19:48:58 <kadoban> xcmw_: You can try 'git branch --contains 3540d1e' or something
19:49:16 <kadoban> Probably want -a on that
19:50:16 <xcmw_> I get master
19:50:30 <geekosaur> right, I think you want head, there is no 8.0.3 planned
19:50:35 <geekosaur> 8.2.1 is the next release
19:51:30 <xcmw_> geekosaur: So what do I run? Does head (which I think I built) have that commit?
19:52:00 <geekosaur> if you have master checked out then yes (that would be the default)
19:52:45 <geekosaur> HEAD is shorthand for the tip of the master branch (this is a slight lie as every branch has a HEAD, but conventional git usage tends to assume HEAD only applies to master...)
19:52:53 <xcmw_> geekosaur: So then stack is not using that ghc then because the glitch still occurs
19:53:08 <geekosaur> you'll need to figure out what stack is using, then
19:53:18 <Koterpillar> it won't be using 8.2
19:53:22 <geekosaur> unless git status says you are not on master
19:53:27 <xcmw_> geekosaur: I am running stack --system-ghc build
19:53:38 <Koterpillar> did you specify compiler: ?
19:54:19 <geekosaur> xcmw_, I can say sensible things about ghc, not so much about stack, don't bother directing those at me
19:54:23 <kadoban> Pretty sure --system-ghc just means "you can use the system GHC, if you feel like it", it doesn't stop it from trying to use a "correct" version of GHC, including its own. Fairly sure
19:54:40 <geekosaur> and ^ that would not surprise me much
19:54:55 <kadoban> So you need to both tell it that it's okay to use a system GHC, and also tell it to use the version you want. Which is the stuff Koterpillar linked earlier I believe.
19:54:55 <geekosaur> so you probably need to convince stack that a "ghc 8.1" is valid
19:55:15 <Koterpillar> or 8.2?
19:55:30 <geekosaur> (note that it will not call itself ghc 8.2 until that is branched, which is iirc a month or so down the road)
19:55:37 <xcmw_> ghc version is 8.1.20170206
19:55:44 <kadoban> Usually just a matter of setting the flags in the stack.yaml file, or there's probably a way on the command line if a stack.yaml isn't relevant.
19:55:55 <xcmw_> compiler: 8.1
19:56:47 <kadoban> xcmw_: The usual matching algo it uses is something like "only the exact version" so you either need to make that match exactly, or change that with compiler-match or whatever it is.
19:57:05 <Koterpillar> https://docs.haskellstack.org/en/stable/yaml_configuration/?highlight=compiler#compiler
19:57:18 <Koterpillar> xcmw_: compiler: ghc-8.1.20170206
19:58:24 <xcmw_> Now I get Failure when adding dependencies for a bunch of packages
19:59:25 <kadoban> What resolver are you using? I'd hope whichever one is nearest to new at least? Other than that, I dunno. A bunch of them just might not even be ready to support that version even.
19:59:40 <xcmw_> resolver: nightly-2017-02-03
20:00:05 <Koterpillar> xcmw_: do you want to build this yourself, or does it have to go to other people?
20:00:18 <xcmw_> Koterpillar: Just me
20:00:24 <geekosaur> I suspect you will lose until a resolver exists or you manually pick and possibly patch packages to match that compiler
20:00:41 <Koterpillar> xcmw_: can you cherry-pick that commit on top of 8.0 and rebuild as 8.0.3?
20:00:42 <geekosaur> that's the problem with bleeding edge, especially when building with a reproducible builds tool
20:01:31 <kadoban> Ya, stack isn't exactly working with you for this kind of usage. There are resolvers for "just the crap that comes with GHC", you could start there and add extra-deps maybe, depending on what this is and how much it uses in terms of packages, perhaps that's more likely to succeed.
20:02:07 <xcmw_> Is there an I don't care about versions just built it flag?
20:02:46 <Koterpillar> no
20:02:48 <Koterpillar> by design
20:03:06 <xcmw_> Can I fake the ghc version to 8.0.2?
20:03:39 <Koterpillar> xcmw_: can you cherry-pick that commit on top of 8.0 and rebuild as 8.0.3?
20:03:42 <Koterpillar> or 8.02
20:03:43 <kadoban> Probably? I would imagine the GHC version is just somewhere in a text file you change before you build GHC, but that's a pretty big guess.
20:03:52 <kadoban> Or yeah that makes more sense.
20:04:32 <xcmw_> Koterpillar: I will try that tomorrow
20:04:35 <xcmw_> Thanks
20:10:55 <sshine> https://hackage.haskell.org/package/bytestring-trie-0.2.4.1/docs/src/Data-Trie-Internal.html#line-163 -- trying to understand where this 'Mask' type comes from. can anyone here see that?
20:15:09 <kadoban> sshine: Very likely either Data.Trie.ByteStringInternal or Data.Trie.BitTwiddle  I don't see it in Data.Binary. If you still can't find it, you can load that in ghci, if it's convenient, and see. (:i Mask or whatever)
20:17:45 <sshine> kadoban, I see that it is probably modelled on http://hackage.haskell.org/package/containers-0.5.9.1/docs/src/Data.IntMap.Internal.html#line-347
20:17:58 <sshine> kadoban, this code makes it more clear that they're just aliases to Int. :)
20:18:56 <kadoban> Suspected it was just an alias (or a newtype), but still couldn't find exactly where it's defined, heh.
20:19:39 <sshine> kadoban, yeah.
20:27:18 <halogenandtoast> Is there any cleaner way to write `mStory <- getBy $ UniqueNewsId nid    case mStory of Just _ -> return ()    Nothing -> insert_ story`
20:27:43 <halogenandtoast> I keep wanting to use `maybe` but can't get the types to check out
20:28:09 <Koterpillar> :t maybe
20:28:10 <lambdabot> b -> (a -> b) -> Maybe a -> b
20:28:20 <Koterpillar> maybe (return ()) (void . insert)
20:28:53 <Axman6> needs const (insert_ story) I think
20:29:20 <halogenandtoast> Axman6: I think I tried something like that, but I'll try again
20:29:30 <Axman6> maybe (pure ()) (const (insert_ story)) =<< getBy (UniqueNewsId nid)
20:30:53 <halogenandtoast> Axman6: yeah that worked, last time I was trying to one line both operations and was using `<$>` instead of `=<<`
20:31:59 <halogenandtoast> thanks Axman6 and Koterpillar 
20:40:25 <kotangent> exit
20:44:29 <halogenandtoast> Another cleanup challenge if anyone has ideas... `runDB $ do    dbcount <- countPublishedToday   return $ void $ when (dbcount == 0) (runDB refreshStories)`
20:45:01 <jle`> what's the return . void supposed to be doing
20:45:10 <jle`> oh
20:45:25 <halogenandtoast> The void isn't needed
20:45:25 <jle`> are you doing runDB inside a runDB ...?
20:45:48 <halogenandtoast> and no I'm not, the void was leftover from tryign to do something else
20:47:30 <jle`> it's hard to see what's going on with the layouting removed
20:47:52 <jle`> what lines/indents go where
20:48:07 <jle`> maybe use { .. ; ..}, or put it on a paste?
20:48:32 <lpaste> halogenandtoast pasted “Stories.hs” at http://lpaste.net/352126
20:48:40 <halogenandtoast> jle`: ^^
20:49:15 <halogenandtoast> probably going to move groups into the single runDB section
20:49:16 <jle`> it looks like you are using runDB inside a runDB
20:49:23 <halogenandtoast> I'm not
20:49:28 <halogenandtoast> what makes you think I am?
20:49:36 <jle`> line 5
20:49:42 <jle`> is inside a block you are runDBing
20:49:46 <jle`> and it is a runDB
20:49:52 <halogenandtoast> ha
20:49:53 <halogenandtoast> yeah I am
20:49:55 <halogenandtoast> :|
20:50:19 <jle`> and yeah, you can probably pull everything into one runDB
20:50:42 <halogenandtoast> okay removing the runDB allowed me to remove the return
20:51:03 <jle`> the return did not do what you think it does
20:51:13 <jle`> if you return something and don't name the reuslt, that's basically a no-op
20:51:22 <jle`> _ <- return (putStrLn "hello")
20:51:24 <jle`> won't print out hello
20:51:32 <lpaste> halogenandtoast revised “Stories.hs”: “Stories.hs” at http://lpaste.net/352126
20:51:37 <jle`> it just is a no-op IO action that returns an IO action that you don't do anything with
20:52:07 <halogenandtoast> jle`: Good point
20:52:37 <halogenandtoast> Does that paste look better then?
20:53:16 <jle`> mhm
20:53:57 <halogenandtoast> jle`: Thanks!
20:55:07 <jle`> halogenandtoast: you never use groups btw
20:55:22 <jle`> if you really don't, you don't need the (grouped <$>) on line 6
20:56:01 <sshine> why write (grouped <$>) when you can write fmap grouped?
20:56:43 <jle`> it's actually `grouped <$> blah` in the paste, heh, just writing it like this for irc purposes
20:56:52 <sshine> ah, ok
20:57:27 <Ptival> Koterpillar: but Identity t is not ~ t, right, so it requires a lot of wrap/unwrap?
20:57:45 <halogenandtoast> jle`: what do you mean about not using groups?
20:57:57 <halogenandtoast> oh
20:58:00 <jle`> halogenandtoast: you named it but never used it
20:58:03 <Koterpillar> Ptival: correct
20:58:09 <halogenandtoast> jle`: it's used in the template
20:58:26 <halogenandtoast> some TemplateHaskell shenanigans going on in there
20:58:28 <jle`> ah ok
21:01:23 <halogenandtoast> Haskell is often difficult, but I love it.
21:01:57 <halogenandtoast> One day it will be easy, and I will still love it.
21:12:23 <halogenandtoast> What is the purpose of mzero. For instance `parseJSON _ = mzero` I don't understand how or why that's the case.
21:12:46 <Ptival> is it ever possible to mention the type of the outermost function in the type of a where-function?
21:13:05 <Axman6> I don't understand the question
21:13:14 <Ptival> sorry, to mention a type variable from the outermost function type*
21:13:50 <Axman6> if you use ScopedTypeVariables then you can mention types from the top level funtion in places like where clauses
21:14:08 <Ptival> oooh
21:15:23 <Ptival> Axman6: ah, perfect, this solves my issue!
21:15:39 <geekosaur> ...but you have to mark the ones you use with explicit foralls
21:15:42 <Axman6> it's kind of frustrating that's not the default behaviour
21:15:53 <Axman6> geekosaur: do you? I don't think I ever have
21:16:24 <Koterpillar> halogenandtoast: this is the definition of mzero: http://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Monad.html#v:mzero
21:16:38 <Koterpillar> halogenandtoast: it's a "do nothing" operation, if applicable
21:17:11 <Ptival> geekosaur: even the ones you don't use it seems?
21:17:20 <Axman6> for AESON, I think mzero returns an error
21:17:26 <geekosaur> Axman6, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#declaration-type-signatures
21:17:42 <geekosaur> Ptival, only the ones you need in scope, see the link ^
21:19:23 <halogenandtoast> Axman6: you are right, also thanks Koterpillar looks like it's better to use `typeMismatch`
21:23:16 <Axman6> yeah something more explicit it usually a better idea. I tend to just use the withFoo (withObject, withString etc.) functions, they allow you to name what you're expecting to be there and Aeson takes care of the error cases
21:29:44 <jle`> halogenandtoast, Koterpillar: er, wait, the do-nothing operation is not mzero
21:29:47 <jle`> it's 'return'
21:30:04 <jle`> halogenandtoast: mzero's use depends on the type that instances it
21:30:09 <halogenandtoast> :t return
21:30:11 <lambdabot> Monad m => a -> m a
21:30:14 <halogenandtoast> :t mzero
21:30:16 <lambdabot> MonadPlus m => m a
21:30:28 <jle`> for the parser type tat aeson uses, 'mzero' is "fail to parse"
21:30:31 <jle`> it's the failure action
21:30:49 <jle`> most instances of MonadPlus have mzero usually mean some failure of some sort
21:30:58 <jle`> but the actual meaning of mzero varies from instane to instance
21:31:21 <jle`> 'mzero' is the parser that parses nothing and fails immediately
22:57:53 <qmm> http://lpaste.net/352119 forkProcess :: LocalNode -> Process () -> IO ProcessId ; run :: Port -> Application -> IO () ; how to turn IO () into a Process ()? https://hackage.haskell.org/package/distributed-process-0.6.6/docs/Control-Distributed-Process-Internal-Types.html#t:Process derives a MonadIO
22:58:48 <liste> :t liftIO
22:58:49 <lambdabot> MonadIO m => IO a -> m a
22:59:00 <liste> qmm: ^
22:59:33 <magthe> is there no IRC channel for stack/stackage discussions?
22:59:59 <jle`> magthe: there's #haskell-stack
23:00:27 <magthe> jle`: aha... I'll see about adding it to the wiki then :) thanks!
23:00:37 <jle`> no problem!
23:09:40 <marekw2143> hello, in case of code: "data SuperData a  = SuperData { runSuperData :: Maybe a }
23:09:45 <marekw2143> then what is runSuperData / 
23:09:46 <marekw2143> ?
23:10:12 <srhb> marekw2143: It says what it is right there in the type of the field, it's a Maybe a
23:10:57 <marekw2143> oh, so "superData" is just a field  -generally it's field syntax constructor ? 
23:11:29 <srhb> marekw2143: There is no superData. SuperData is a value constructor though. Not a field.
23:11:36 <srhb> marekw2143: runSuperData is a field.
23:11:51 <marekw2143> yes, I've meant runSuperData
23:12:04 <srhb> Then yes, it's a field. :)
23:13:34 <marekw2143> but here https://github.com/kqr/gists/blob/master/articles/gentle-introduction-monad-transformers.md#type-classes 
23:13:39 <marekw2143> then there's rfield runEitherIO
23:13:47 <marekw2143> but I cannot see it's definitio 
23:14:06 <srhb> marekw2143: It has no "definition" beyond that.
23:14:32 <marekw2143> so how it works ? 
23:14:41 <srhb> marekw2143: If you make a _value_ of type EitherIO e a, you would _provide_ an IO (Either e a)
23:14:49 <dramforever> @let data SuperData a  = SuperData { runSuperData :: Maybe a }
23:14:50 <lambdabot>  Defined.
23:14:52 <dramforever> :t runSuperData
23:14:54 <lambdabot> SuperData a -> Maybe a
23:14:58 <srhb> marekw2143: It doesn't "work." I think you're confused by the "run" in the name.
23:15:16 <dramforever> it just gets the 'Maybe a' out of a SuperData
23:15:22 <dramforever> :t SuperData
23:15:27 <lambdabot> Maybe a -> SuperData a
23:15:31 <dramforever> ^ basically the reverse of this
23:15:47 <marekw2143> hmm, it seems like just pattern matching
23:15:52 <dramforever> You know record syntax?
23:15:59 <marekw2143> I thought I know
23:16:00 <marekw2143> ;)
23:16:08 <dramforever> @let data Point = Point { x :: Double, y :: Double }
23:16:10 <lambdabot>  Defined.
23:16:13 <dramforever> :t x
23:16:14 <lambdabot> error:
23:16:15 <lambdabot>     Ambiguous occurrence ‘x’
23:16:15 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.x’,
23:16:18 <dramforever> Exactly the same here
23:16:27 <dramforever> except I've got another stupid x interfering here
23:16:42 <marekw2143> ok, so in runEitherIO example
23:16:44 <dramforever> @let data BetterPoint = BetterPoint { betterx :: Double, bettery :: Double }
23:16:45 <lambdabot>  Defined.
23:16:49 <dramforever> :t betterx
23:16:50 <lambdabot> BetterPoint -> Double
23:16:52 <marekw2143> thne runEitherIO is just a function
23:17:02 <marekw2143> which on the basis of instance EitherIO a e 
23:17:09 <dramforever> no basis
23:17:26 <dramforever> oops sorry
23:17:34 <dramforever> marekw2143: What do you mean by basis?
23:18:02 <marekw2143> by "on basis" I mean that having "value of type EitherIO a e"
23:18:14 <dramforever> okay
23:18:20 <marekw2143> so that runEitherIO just unpacks "value of type EitherIO a e"
23:18:31 <marekw2143> to value of type IO (Either a e )
23:18:31 <dramforever> exactly
23:18:45 <marekw2143> so it' s just something like pattern mathicnng ? 
23:19:09 <dramforever> ('IO (Either e a)' really)
23:19:36 <dramforever> Yeah
23:19:41 <dramforever> Just how records work
23:19:49 <marekw2143> ok
23:19:53 <dramforever> It's kinda like a trick or something
23:19:57 <marekw2143> but how to set that value to it ? 
23:20:11 <dramforever> EitherIO is a constructor :P
23:20:16 <dramforever> :t EitherIO
23:20:18 <lambdabot> error: Data constructor not in scope: EitherIO
23:20:30 <dramforever> oh, we've got SuperData
23:20:33 <dramforever> :t SuperData
23:20:34 <lambdabot> Maybe a -> SuperData a
23:20:46 <dramforever> That's how to 'set that value to it'
23:21:06 <dramforever> For record syntax you would probably normally do this:
23:21:15 <dramforever> :t BetterPoint { x = 1, y = 2 }
23:21:16 <lambdabot> error:
23:21:17 <lambdabot>     Ambiguous occurrence ‘x’
23:21:17 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.x’,
23:21:24 <dramforever> :t BetterPoint { betterx = 1, bettery = 2 }
23:21:26 <lambdabot> BetterPoint
23:21:31 <dramforever> Sorry, the second one is correct
23:21:38 <dramforever> But this works just fine:
23:21:45 <dramforever> :t BetterPoint 1 2
23:21:47 <lambdabot> BetterPoint
23:21:57 <dramforever> > betterx (BetterPoint 1 2) -- You can even get the x out of it
23:22:00 <lambdabot>  1.0
23:22:08 <dramforever> but it kinda defeats the purpose of records
23:22:15 <marekw2143> ok, so in example with "EitherIO"
23:22:21 <dramforever> *but* for EitherIO we *know* we have only one field
23:22:29 <dramforever> so it's not going to be any trouble
23:22:32 <dramforever> it's actually easier to do
23:22:44 <dramforever> so I called it sorta a trick above
23:22:51 <marekw2143> ok
23:23:32 <marekw2143> so when I'd have value1 = EitherIo { runEitherIod = IO ( Either 1 "error" } }
23:23:38 <marekw2143> that is the way ? 
23:23:50 <dramforever> That's one way
23:24:07 <dramforever> 'the' way is usually just 'EitherIO something'
23:24:23 <dramforever> And you are confusing types and values in your construction as well
23:24:27 <halogenandtoast> Anyone here from Tokyo?
23:24:37 <dramforever> 'IO ( Either 1 "error")' makes no sense
23:25:06 <marekw2143> because 1 and "error" are values 
23:25:38 <pikajude> well they could be Nat and Symbol
23:25:40 <pikajude> or whatever those are called
23:25:58 <dramforever> marekw2143: then what are your IO and Either doing there?
23:26:08 <dramforever> pikajude: go away you're ruining the fun
23:27:51 <marekw2143> hmm, so in example with monad transformers
23:28:21 <marekw2143> for definition of monad like x >>= f = EitherIO $ runEitherIO x >>= either (return .Left) (runEitherIO . f) 
23:28:36 <recur22> dose anyone here know if diagrams support hittesting?i tried to google it but no luck
23:29:08 <marekw2143> then first "runEitherIO x" just gives us value of IO (Eitther a e)
23:29:45 <marekw2143> then there's used ">>=" defined for IO monad ? 
23:31:53 <ertes> the API of System.Mem.StableName is confusing…  why does StableName have a type argument, and why does makeStableName take a value of that type?
23:31:53 <marekw2143> :t either
23:31:55 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
23:32:05 <ertes> isn't it basically equivalent to Data.Unique?
23:35:19 <ertes> ah, i see
23:35:29 <ertes> it does actually take sharing into account
23:37:47 <ertes> yet i don't see why StableName would require a type argument
23:40:35 <opqdonut> ertes: yeah it's not really used for anything, except to limit the Eq instance to the same type
23:41:04 <ertes> opqdonut: even that is questionable since there is eqStableName, which doesn't have that limit
23:42:11 <opqdonut> maybe the answer is that GHC.Base.StableName# takes a type argument
23:43:09 <ibrahemgebri> 9 11 attacks, Did USA do it itself or it just let it happen?
23:43:09 <ibrahemgebri> Did USA administration murder 3000 American citizen in 9 11 attacks to justify starting a war against iraq?
23:43:09 <ibrahemgebri> If al-qaeda did it, why go to kill 2 million Iraqi?
23:43:09 <ibrahemgebri> http://creatvchaos.blogspot.com.eg/    https://creatvchaos.wordpress.com/
23:43:09 <ibrahemgebri> Some of the benefits Americans say they achieved after 9 11 attacks include:
23:43:09 <ibrahemgebri> *constant flow of oil, which price is in continuous decline. Trump said he will simply take the Iraqi oil, and when he was told that Iraqi oil belongs to iraq he said there is no iraq(after usa destroyed it ).
23:43:10 <ibrahemgebri> *Invasion of afghanstan with construction of not less than 14 american military base which give a close eye on china.
23:43:10 <ibrahemgebri> *Removal of potential threat to isreal represented in iraq which throw isreal with more than 30 rocket after American assault on iraq during 2nd gulf war.
23:43:39 <ertes> opqdonut: it does, but it's not used for anything either
23:44:00 <opqdonut> ertes: well some other use case might use it
23:44:21 <ertes> in base?
23:44:33 <opqdonut> yeah I know of now other use cases :)0~
23:44:36 <opqdonut> if you really really want to know maybe the (-users) mailing list is the best place to ask
23:48:11 <zipper> lol Some nice 9/11 conspiracies to start a haskell day.
