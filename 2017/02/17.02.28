00:00:20 <ushakovo> Well that's unlucky
00:00:33 <ushakovo> I'm gonna need a new project to work on then haha
00:02:14 <cocreature> ushakovo: you can always post your code here and hope that someone finds the time to look at it :)
00:04:30 <ushakovo> cocreature: I'd rather not subject anyone to my newbie haskell...
00:04:58 <ushakovo> I contacted the creator of the library so maybe they'll be interested in it
00:05:14 <cocreature> ushakovo: don’t worry about that. people that hang around here usually do because they want to help others
00:05:20 <cocreature> we’ve all been beginners at some point
00:07:59 <fuzzy_id> heya
00:08:47 <ushakovo> cocreature: the help has been great! I'm 90% sure the problem isn't with my code, but if I get really desperate I'll be back
00:09:10 <cocreature> ushakovo: alright, I hope you’ll be able to fix the bug!
00:09:26 <fuzzy_id> I spawn an external process via createProcess and try to read the resulting stderr and stdout handles in forkIO'd threads (passing lines back in MVars to feed them back to my logging stack).
00:09:45 <fuzzy_id> now my program uses 100% cpu while the other program is running :/
00:10:13 <fuzzy_id> can someone point me in the right direction how to avoid that?
00:10:38 <ushakovo> cocreature: Thanks!
00:10:40 <fuzzy_id> is there some routine that uses select in the background?
00:10:43 <Cale> fuzzy_id: it's unclear to me from that description why your program would do that
00:11:07 <cocreature> fuzzy_id: ghc generally uses "select" by default. could you show us the code you’re using to read the output?
00:11:11 <Cale> Yeah, just ordinary IO will use select/epoll/kqueue as appropriate based on your platform
00:11:12 <ongy> fuzzy_id: I don't think that should happen. And there's the RTS in the background managing IO
00:11:33 <fuzzy_id> just one moment
00:11:33 <cocreature> also maybe try the threaded runtime. weird things happen sometimes using the nonthreaded runtime
00:11:39 <Cale> ah yeah
00:12:04 <cocreature> we really should just make the threaded runtime the default.
00:12:11 <Cale> We should
00:12:12 <ongy> iirc non-threaded runtime uses the normal epoll manager and additional selects around reads
00:12:16 <cocreature> it comes up from time to time and everybody seems to agree but for some reason it doesn’t happen
00:13:19 <fuzzy_id> https://github.com/fuzzy-id/btrbkp/blob/master/src/Btrbkp/BkpStore/Local.hs
00:13:36 <fuzzy_id> logProcess is the calling function (line 71…)
00:14:08 <cocreature> fuzzy_id: do you use the threaded runtime? if not try that first
00:14:16 <fuzzy_id> alright
00:15:38 <cocreature> the mvar could also become a bottleneck if there is a lot of output on both stdout & stderr
00:23:51 <fuzzy_id> is there some way to see if '-threaded' was actually set during compilation?
00:24:09 <fuzzy_id> i'm not sure when stack actually rebuilds… :)
00:24:18 <fuzzy_id> i set ghc-options in the cabal file…
00:24:35 <cocreature> try running your executable with +RTS --info
00:24:46 <cocreature> I think "RTS way" shows you what it used
00:25:43 <fuzzy_id> "RTS way" is set tho "rts_thr"
00:25:49 <cocreature> that looks fine
00:26:26 <cocreature> fuzzy_id: oh I think I found the problem
00:26:32 <cocreature> fuzzy_id: you are using "tryTakeMVar"
00:26:40 <cocreature> so you are essentially doing a busy loop
00:26:44 <cocreature> even if there is no output
00:26:52 <cocreature> oh no you exit in that case nvm
00:27:13 <cocreature> no it’s a busy loop
00:27:16 <fuzzy_id> nope, i don't
00:27:22 <fuzzy_id> yeah, you're right
00:30:12 <cocreature> one way to fix this is to use a bounded channel instead of an mvar and have it hold "Maybe Text", then errThread and outThread both write Nothing if they are finished and loopLogProcess steps looping once it encountered two Nothings
00:32:54 <fuzzy_id> where can i find bounded channels
00:34:36 <cocreature> https://hackage.haskell.org/package/unagi-chan-0.4.0.0/docs/Control-Concurrent-Chan-Unagi-Bounded.html is one of the faster implementations afaik
00:34:58 <cocreature> https://hackage.haskell.org/package/unagi-chan-0.4.0.0/docs/Control-Concurrent-Chan-Unagi-Bounded.html is one of the faster implementations afaik
00:36:07 <mniip> https://hackage.haskell.org/package/unagi-chan-0.4.0.0/docs/Control-Concurrent-Chan-Unagi-Bounded.html is one of the faster implementations afaik
00:38:45 <fuzzy_id> the bound simply ensures that my reading thread will read although my program writes a lot to stdout/stderr, right?
00:39:27 <cocreature> the bound ensures that your writing thread will block if the reading thread doesn’t keep up
00:39:38 <cocreature> you can think of your current approach using an mvar as a bounded channel of size 1
00:40:12 <cocreature> you could also use an unbounded channel but unbounded channels are usually a bad idea :)
00:40:57 <fuzzy_id> yeah, that makes sense
00:41:01 <fuzzy_id> :)
00:57:53 <yezariaely> I have a function living in the IO monad and now I call the parsec parse function (which lives in another monad). How can I get them to work together? Do I need a monad transformer?
00:58:19 <fendoer> liftIO ?
00:58:25 <liste> yezariaely: what does the function do?
00:58:46 <slack1256> you can `runParse` and work with the value
00:59:29 <fendoer> :t liftIO
00:59:30 <slack1256> { do ; let parsed = runParse scheme string ; print parsed }
00:59:31 <lambdabot> MonadIO m => IO a -> m a
01:01:30 <fendoer> > foo n = n * 2 
01:01:33 <lambdabot>  <hint>:1:7: error:
01:01:33 <lambdabot>      parse error on input ‘=’
01:01:33 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
01:01:38 <fendoer> > let foo n = n * 2 
01:01:43 <lambdabot>  <no location info>: error: not an expression: ‘let foo n = n * 2 ’
01:02:15 <mniip> @let foo n = n * 2
01:02:18 <lambdabot>  Defined.
01:03:25 <fendoer> > foo 4  
01:03:29 <lambdabot>  8
01:03:37 <fendoer> very cool, thanks :)
01:04:08 <fendoer> can i do IO stuff with the bot, too?
01:07:56 <ongy> no. that would be risky for the host of the bot
01:08:02 <liste> > putStrLn "hi" -- :)
01:08:05 <lambdabot>  <IO ()>
01:08:22 <ongy> > readFile "/etc/shadow"
01:08:26 <lambdabot>  <IO [Char]>
01:08:29 <liste> why don't they use the "safe" IO variant that try haskell uses?
01:08:36 <fendoer> so, he just ignroes you? ^^
01:08:50 <liste> fendoer: no, there's a Show instance for IO in the bot
01:09:01 <liste> so it doesn't execute the actions, it just shows them
01:09:18 <ongy> liste: o.0 what's that?
01:09:25 <ongy> not the show instance, "save" IO
01:09:37 <liste> ongy: http://chrisdone.com/posts/pure-io-tryhaskell
01:10:21 <fendoer> uhmmm.... what happened?
01:10:45 <mauke> matrix.org disconnected?
01:11:21 <fendoer> everyone just died?
01:11:33 <mauke> no, just people on matrix.org
01:11:48 <fendoer> i see, it happened on #Solus too
01:11:54 <liste> the whole Freenode
01:12:13 <nshepperd_> When you die on matrix.org you die in real life
01:12:27 <liste> ouch, that's gonna be in the news soon
01:15:43 <Theophane> :')
01:15:45 <fendor> well, that joke's kinda good 
01:16:12 <Theophane> sure it is
01:17:27 <ongy> IRC is real life
01:18:05 <liste> IRL is just a waste of time, IRC is real life
01:18:44 <ongy> who needs food when you can have lambdabot karma
01:18:46 <ongy> @karma
01:18:47 <lambdabot> You have a karma of 0
01:19:00 <liste> seems ongy's gonna need food after all
01:19:13 <liste> @karma edwardk
01:19:13 <lambdabot> edwardk has a karma of 55
01:19:30 * edwardk smiles
01:19:33 <liste> (just checking that it hasn't been reset)
01:19:50 <liste> sorry for bothering :)
01:19:50 <edwardk> that number gets knocked around a lot
01:20:32 <ongy> you are a celebrity after all
01:20:53 <edwardk> its more the bot seems to have selective amnesia
01:21:26 <ongy> what was that quote? "If learning to program is like climbing a mountain, haskell is a brick wall, with edwardk building it higher and higher" (I think that was in one of the talks around lens?)
01:21:56 <edwardk> https://twitter.com/codemiller/status/695516883483828224
01:22:07 <edwardk> something katie posted to twitter once
01:23:01 <edwardk> i'm also partial to this one: http://imgur.com/TTBBeJs
01:24:45 <fendor> @karma
01:24:46 <lambdabot> You have a karma of 0
01:25:03 <mauke> @karma
01:25:03 <lambdabot> You have a karma of 60
01:25:18 <fendor> what does the karam determine?ß
01:25:27 <fendor> and lenses look cool :D 
01:25:33 <mauke> how often someone's said "mauke++"
01:25:45 <mauke> austrian confirmed
01:26:09 <Gurkenglas> Germans also have that key there
01:26:38 <mauke> but they don't IRC from a tuwien host
01:27:24 <merijn> mauke: They could if they moved or had a conference ;)
01:27:25 <edwardk> fendor imaginary points on the internets
01:27:37 <edwardk> @karma shachaf
01:27:37 <lambdabot> shachaf has a karma of 97
01:27:41 <tabaqui1> @karma
01:27:42 <lambdabot> You have a karma of 0
01:27:47 <ongy> I should have more than 0 of those... at least if taken absolute
01:27:51 <tabaqui1> fendor++
01:27:55 <fendor> @karma
01:27:55 <lambdabot> You have a karma of 1
01:27:56 <tabaqui1> @karma fendor
01:27:56 <merijn> I remember walking through Vienna and randomly going "huh? Why do I have wifi?" only to find out I was automagically connecting to TU Wien :p
01:27:56 <lambdabot> fendor has a karma of 1
01:27:59 <fendor> yeah :D 
01:28:00 <tabaqui1> hm
01:28:04 <tabaqui1> fendor--
01:28:08 <fendor> yeah eduroam is great :D 
01:28:17 <tabaqui1> @karma fendor
01:28:18 <lambdabot> fendor has a karma of 0
01:28:32 <tabaqui1> @karma merijn
01:28:33 <lambdabot> merijn has a karma of 51
01:29:06 <ongy> hackage should have a feature: list packages by karma on #haskell
01:29:11 <ongy> @karma lens
01:29:11 <lambdabot> lens has a karma of 4
01:29:23 <fendor> @karma foldable 
01:29:24 <lambdabot> foldable has a karma of 0
01:29:31 <fendor> @karma someRandomWord
01:29:31 <lambdabot> someRandomWord has a karma of 0
01:29:38 <mauke> @karma i
01:29:38 <lambdabot> i has a karma of 153
01:29:52 <edwardk> you know you can /msg lambdabot these queries ;)
01:29:59 * edwardk hints unsubtly
01:30:05 <ongy> is karma not bound to the channel?
01:30:10 <edwardk> nope
01:30:26 <fendor> it should be bound to the bot, shouldnt it?
01:31:02 <fendor> i love that bot :D 
01:31:09 <fendor> what else can he do?
01:31:25 <edwardk> she can do lots of stuff
01:31:33 <edwardk> @vixen a/s/l
01:31:34 <lambdabot> I'm glad I'm not Brezhnev. Being the Russian leader in the Kremlin. You never know if someone's tape recording what you say.
01:32:11 <merijn> vixen was removed
01:32:15 <edwardk> ah
01:32:19 <merijn> So it auto corrects to @nixon
01:32:23 <edwardk> heh
01:32:35 <merijn> Which, unlike, @vixen was not deemed politically incorrect enough to remove
01:32:43 <edwardk> fair
01:32:54 <edwardk> and now is oddly topical
01:33:04 <edwardk> well not for here
01:33:34 <mniip> ! and edwardk
01:33:37 <mniip> an*
01:35:26 <fendor> why the hell does lambdabot has a brainfuck interpreter?
01:35:31 <fendor> *have
01:35:35 <merijn> fendor: Why not?
01:35:47 <fendor> ok, convinced, for the lolz?
01:35:52 <edwardk> lambdabot is sort of a community effort
01:36:09 <mniip> edwardk, is there a way to construct ends of Hask profunctors
01:36:12 <edwardk> lots of folks wrote lambdabot plugins as their first bit of haskell back circa 2006
01:36:26 <mniip> and is it possible to do in the Hask.hs framework?
01:36:36 <ongy> googling for the vixen plugin in lambdabot... why was that even a thing?
01:36:42 <edwardk> mniip: forall a. p a a    is an end over p
01:36:47 <fendor> can one still submit code for the lambdabot?
01:36:47 <mniip> right
01:36:54 <mniip> but that's not really constructive
01:37:07 <edwardk> i don't know that i include it in the profunctors package
01:37:15 <merijn> fendor: I don't know who runs lambdabot currently, but if you convince said person to add it, sure
01:37:31 <merijn> fendor: You could also run your own copy of lambdabot, but you'll probably be asked not to do it here
01:37:31 <edwardk> what do you mean? it passes all the laws and by parametricity is forced to be the unique definition up to isomorphism
01:37:43 <edwardk> you can make a newtype wrapper for it if you must
01:37:46 <edwardk> same with coends
01:38:13 <fendor> merijn, ok, i bet there is a github repo?
01:38:16 <mniip> hmm
01:38:26 <mniip> maybe not Hask.hs framework is what I had in mind
01:38:31 <mniip> maybe closer to Generics
01:38:40 <merijn> fendor: https://hackage.haskell.org/package/lambdabot
01:38:54 <fendor> merijn, thanks
01:38:58 <edwardk> https://github.com/lambdabot/lambdabot
01:39:09 <mniip> if you have an algebraic construction of an ADT, can you obtain an algebraic description of the end of its profunctor?
01:39:16 <edwardk> mniip: still not sure what you are getting at
01:39:48 <mniip> edwardk, I'm not sure how common it is to represent ADTs as profunctors? if at all?
01:39:51 <edwardk> depends on if said adt has two type arguments and one of them is only in negative position
01:40:14 <edwardk> you may want to look up a couple of old papers
01:40:18 <edwardk> let me give you a reference
01:40:32 <edwardk> http://comonad.com/reader/2008/rotten-bananas/
01:40:54 <edwardk> that post is about separating out positive and negative occurences of a type variable in an ADT
01:40:58 <edwardk> and making it into a profunctor
01:41:03 <edwardk> i didn't use those words back then
01:41:04 <mniip> yeah
01:41:06 <mniip> exactly that
01:41:30 <edwardk> with that you can apply a trick from erik meijer to get a form of catamorphism/anamorphism
01:41:43 <edwardk> or you can use a more modern technique like used in the article that works better in practice
01:41:54 <mniip> "Λa. f a -> g a" turns into "Λa b. f b a -> g a b"
01:41:57 <mniip> and so on
01:42:23 <edwardk> anyways that article used the 'expfunctor' abstraction with one type variable, rather than a profunctor
01:42:28 <edwardk> later on i switched to a profunctor version
01:42:56 <edwardk> i think i wrote it up for a post about phoas for free or something
01:43:05 <edwardk> i don;'t remember if i ever fixed a couple bugs in that article though
01:43:15 <edwardk> yep
01:43:47 <mniip> is the integral notation intentional or just a coincidence
01:44:06 <edwardk> intentional, but the connection is kinda crappy to explain
01:44:09 <mniip> I mean the fact that we only bind one variable in the intergral and use it twice in the profunctor
01:45:14 <edwardk> well, what is positive and what is negative is "clear by context" to a mathematician, so they like to write less and maybe use little +/- signs to disambiguate
01:46:09 <mniip> somehow I don't like that
01:46:34 <mniip> is there a popular notation with two bindings?
01:46:43 <edwardk> most computer scientists get deeply uncomfortable at that point. most mathematicians get sore hands if they must be too explicit ;)
01:46:51 <edwardk> no
01:46:59 <mniip> damn
01:47:07 <mniip> anyway
01:47:20 <edwardk> in the right setting its just a limit anyways
01:47:36 <mniip> is there like, an algorithm to turn an ADT into the end ADT?
01:47:37 <edwardk> so you can reset your thinking so that it isn't even wrong
01:47:55 <edwardk> under certain assumptions of variance
01:48:15 <mniip> e.g
01:48:21 <edwardk> f (g x)  -- is f co or contravariant?g?
01:48:45 <mniip> ?
01:49:12 <mniip> once again, the ADT is described profunctorially
01:49:13 <edwardk> with derive Functor we just assume all 'f's in the type are Functors, and not Contravariant instances or something
01:49:31 <edwardk> i thought you wanted to generate the other way, nm
01:49:39 <mniip> the co and contravariant occurences of the tyvar are split
01:49:57 <mniip> and intertwined where appropriate
01:50:01 <edwardk> anywyas yes you could come up with something but we don't have Generic2
01:50:15 <edwardk> so you won't get a way to make the compiler write it for you
01:50:36 <mniip> what makes you so sure it's decidable?
01:51:36 <edwardk> converting to an one parameter version and taking a fixed point is a defineable thing in a language like haskell. in coq you're screwed
01:51:41 <mniip> also, I think, Generic1 probably contains enough information to reencode the ADT as a profunctor?
01:51:46 <mniip> and then you have tyfams
01:52:05 <edwardk> if you need to know where both parameters are plumbed, Generic1 is useless
01:52:46 <edwardk> and again, the whole thing needs assumption about which p's and q's are profunctors or bifunctors
01:53:18 <mniip> uh
01:53:20 <edwardk> that information isn't god given. with Functor deriving we just assume covariance. by the very nature o this you can't
01:53:47 <mniip> I'm not sure if you're following
01:54:32 <mniip> the idea is to take a *->* ADT and turn into into a profunctor *->*->*, with first arg guaranteed contravariant and second arg guaranteed covariant
01:54:41 <mniip> and such that the Join of that profunctor is the original ADT
01:54:57 <edwardk> data Foo p q f g a b = Foo (p (q (f a) (g b)) ())  -- if p is a bifunctor and q is a profunctor and f and g are functors then that is a profunctor.
01:55:07 <mniip> uh
01:55:09 <mniip> *->*
01:55:17 <edwardk> ok, so you're going the other way now
01:55:27 <mniip> not ((*->*)->(*->*))->(*->*)->(*->*)
01:55:48 <mniip> no like I mean
01:55:52 <mniip> suppose we have
01:55:57 <mniip> data Endo a = Endo (a -> a)
01:56:03 <mniip> using Generic1 we could make
01:56:15 <mniip> data EndoProfunctor a a' = Endo' (a -> a')
01:56:27 <edwardk> yes
01:56:34 <mniip> then, whether we can take the end of that is the question
01:56:54 <mniip> it should be iso to () but is there an algorithm for the general case
01:57:16 <edwardk> right up until i give you Compose, because you don't know if f and g in Compose are co or contravariant except by convention
01:57:39 <mniip> Compose doesn't, uh, break apart with Generic1
01:58:03 <edwardk> (:.:) is in GHC.Generics
01:58:06 <edwardk> or whatever
01:58:13 <edwardk> it'll let you drill in
01:58:26 <mniip> hmm
01:58:28 <edwardk> most people don't  know how to use it, but its there
01:58:40 <edwardk> and you have to pick a stylized convention, e.g. that f is a Functor
01:59:04 <edwardk> that is the one caveat i'm pointing out
01:59:14 <edwardk> is that you have an algorithm up to assumptions of positive variance
01:59:14 <mniip> well
01:59:16 <mniip> type Rep1 ((:.:) f g) = D1 (MetaData ":.:" "GHC.Generics" "base" True) (C1 (MetaCons "Comp1" PrefixI True) (S1 (MetaSel (Just Symbol "unComp1") NoSourceUnpackedness NoSourceStrictness DecidedLazy) ((:.:) f (Rec1 g))))
01:59:37 <mniip> you mean how it recursively Rep1's g but not f?
02:00:07 <edwardk> you're looking at the Rep1 of (:.:), look at the Rep1 of (Compose f g)
02:00:26 <edwardk> thats like looking at Rep1 of U1 itself, not something that winds up using U1
02:00:46 <edwardk> but anyways, yes
02:00:48 <mniip> is that not derived?
02:01:08 <edwardk> its derived. but its just a level of misunderstanding waiting to happen
02:01:16 <mniip> anyway, let's ignore the implications of Generic1 mixed with polymorphism
02:01:32 <edwardk> once you drop polymorphism on the floor then the issue is boring
02:01:40 <mniip> well
02:01:41 <edwardk> you only have one source of contravariance (->)'s first argument
02:01:44 <edwardk> and so you can just tree walk
02:01:49 <edwardk> go nuts
02:01:58 <mniip> how do you propose to take ends of stuff with unknown variance?
02:02:01 <edwardk> and swap argument positions every time you recurse into the left of a (->)
02:02:14 <edwardk> what unknown variance. _everything_ is covariant other than the first argument of (->)
02:02:26 <mniip> no like I mean
02:02:35 <mniip> is it even possible to do in presence of polymorphism like you're describing
02:03:14 <mniip> 'end_a f a a' is not even a valid statement if we don't know f is contravariant in first and covariant in second
02:03:21 <edwardk> ghc.generics itsef is predicated into breaking the world into sums, products, and some random decorations to spot constructors. it should also handle (->)'s but doesn't very well.
02:03:36 <mniip> 1488276082 [13:01:22] <edwardk> and so you can just tree walk
02:03:42 <edwardk> yes, but you're taking a concrete ADT, and turning it INTO that.
02:03:48 <mniip> you mean to turn the adt into the profunctor representation
02:03:53 <mniip> yes, that's a tree walk
02:03:53 <edwardk> you only have to deal with the small handful of cases
02:03:58 <mniip> question is about the ends
02:04:00 <edwardk> and yes, because that is what you asked for
02:04:22 <mniip> can we similarly tree walk the end?
02:04:51 <edwardk> the tree construction you just asked for will make a profunctor. then you can take the end off it easy
02:04:59 <mniip> how?
02:05:09 <edwardk> forall a. f a a
02:05:13 <mniip> uh
02:05:15 <mniip> without that
02:05:17 * edwardk doesn't get where the disconnect is coming from
02:05:29 <edwardk> that is literally what an end is in the category of haskell data types
02:05:36 <mniip> right
02:05:51 <mniip> but that doesn't give you a clue of what that type is
02:06:35 <edwardk> its an object with a series of morphisms from End f -> f a a for all the objects a in your category C.
02:06:48 <mniip> is it possible to construct 'forall a. f a a' with sums products exponents 1 and 0?
02:06:52 <edwardk> parametricity forces that to be one morphism with all those types
02:07:22 <edwardk> no. because the list of things provided by generics is incomplete
02:07:27 <edwardk> it doesn't handle quantification
02:07:47 <edwardk> no existentials, no universal quantification under ghc.generics
02:07:51 <edwardk> it doesn't understand such things
02:08:17 <edwardk> you can't make a rank-2 thing out of rank-1 parts in general
02:08:19 <mniip> if f is made up of sums, products, exponents, 1 and 0, can you do that
02:08:52 <edwardk> if you say so. i don't have such a construct in front of me
02:09:18 <mniip> also hm,
02:09:32 <mniip> so you say there's no universal algorithm to do that if f involves quantification?
02:09:41 <edwardk> i'm saying ghc.generics isn't up to the task
02:09:51 <edwardk> i'm not saying that you can't do something in a fancier language
02:09:54 <mniip> generics is kinda tangential to the question
02:10:26 <mniip> constructive constructions of ends is where I'm at
02:10:33 <edwardk> you can probably get some fancy self-describing thing in nice type theories like HoTT even when these start to include dependent types.
02:10:51 <edwardk> but you probably need induction-recursion
02:10:55 <edwardk> so meh
02:11:09 <Aruro> is Tagsoup capable of extracting tagpairs (open-close) together with their content?
02:11:25 <Aruro> like extract all <code> </code> together with code itself
02:11:38 <edwardk> i don't know once the type theory is weak enough that haskell is all you've got
02:12:25 <mniip> well
02:12:29 <edwardk> i'm just saying that forall a. f a a is a constructive construction in this type theory. it is a perfectly cromulent widget you can pass around. =)
02:12:38 <mniip> I'm mainly curious about the construction
02:12:43 <edwardk> you can refactor it into rank-1 parts some of the time
02:12:46 <mniip> forall a. f a a doesn't sound constructive
02:13:03 <cocreature> is there some json parser that accepts javascript notation, i.e., keys not enclosed in ""?
02:13:07 <edwardk> it doesn't sound rank-1
02:13:17 <mniip> maybe
02:13:23 <edwardk> but it works just fine and satisfies all the properties it is supposed to
02:13:25 <mniip> not sure what the precise definition is
02:13:28 <mniip> sure does
02:14:10 <edwardk> anyways the problem is i wind up with existentials and universals in all sorts of data types anyways, so they are part of my tools for describing the domain
02:14:38 <edwardk> that i can sometimes push stuff in and out of the quantifier until it disappears is a nicety, not something i expect to always get rid of it
02:14:45 <edwardk> its symbol pushing
02:14:54 <edwardk> if _that_ is the algorithm you are looking for, i don't know it
02:15:16 <edwardk> and i have no reason to expect the representation to be finite
02:15:27 <mniip> hmm
02:15:56 <edwardk> data Jet f a = a :- Jet f (f a) 
02:16:06 <mniip> something something small caregories
02:16:11 <edwardk> has no finite representation in that form due to polymorphic recursion
02:16:25 <mniip> if we don't restrict ourselves to the category of small sets (types)
02:16:36 <mniip> then the naive forall a. f a a is a non-small quantification
02:16:48 <edwardk> you can make that thing above small enough by adding a base case.
02:17:15 <edwardk> but any number of distributive steps won't finish
02:17:16 <mniip> hm?
02:17:28 <mniip> ah
02:17:37 <edwardk> a :- f a :- f (f a) :- f (f (f a)) :- ...
02:18:12 <mniip> well it is expected that infinite adts might have infinite ends
02:18:22 <mniip> but they could still be algebraically described
02:18:48 <mniip> even though we can't tell 1 tree from seven
02:18:55 <edwardk> anyways, maybe you can find something suitable for representation in https://cs.appstate.edu/~johannp/tlca07-rev.pdf
02:18:55 <mniip> or was it four
02:19:32 <edwardk> seven
02:20:20 <edwardk> http://www.sciencedirect.com/science/article/pii/002240499500098H
02:20:34 <edwardk> there was a nice talk on the subject last year at lambdajam.au
02:21:26 <edwardk> anyways, i've blown all the energy i have tonight.
02:21:36 * edwardk apologizes
02:21:39 * edwardk waves
02:22:07 <mniip> cya
02:22:09 <mniip> thanks
02:22:29 <[1]anon> it has been great learning from you
02:23:21 <f-a> hello #haskell. I downloaded (let's say from github) a library cabal new-build it. The version of this particular is not present on hackage. Can I depend upon in on another project?
02:24:16 <mniip> but wait
02:24:30 <mniip> End Jet f = Void
02:24:44 <mniip> because Jet f a = a * ...
02:25:09 <mniip> and, I guess, end of a product is a product of ends?
02:33:48 <Akii> f-a: with stack you can add additional dependencies
02:35:17 <Akii> meh
02:35:21 <Akii> for the record http://lpaste.net/353051
02:35:42 <Akii> f-a: http://lpaste.net/353051
02:35:46 <Akii> with stack you can add additional dependencies
02:38:20 <f-a> thanks Akii 
02:40:06 <bollu> how do I encode not (forall not a) in the type level?
02:42:29 <bollu> merijn: ^ any idea?
02:47:06 <merijn> bollu: If you're happy with a hacky approximation that's a bit brittle: https://gist.github.com/merijn/6130082
02:47:36 <bollu> merijn: hm
02:47:47 <bollu> merijn: I don't understand how that is equivalent to what I asked >_<
02:47:56 <edwardk> mniip: decorate it as need be to make it nontrivial. add a base case if you only want finite cases
02:48:03 <bollu> merijn: I'm trying to show that LEM <-> (not forall not a <-> exists a)
02:48:35 <bollu> merijn: like, I'm trying to show that adding either LEM or the (not forall not a <-> exists a) to intutionistic logic gives you the same expressive power
02:48:37 <bollu> am I mistaken?
02:48:48 <bollu> edwardk: ^ I think you would have ideas about this? :)
02:49:11 <edwardk> i would if i could keep my eyes open, but pain meds say otherwise =P
02:49:14 <bollu> xD
02:49:16 <bollu> OK :)
02:49:32 <edwardk> there is a whole ##logic channel though =)
02:49:33 <bollu> edwardk: I also wanted to talk to you about applicativeDo as I took it up, but perhaps some other time
02:49:35 <bollu> I see
02:50:04 <edwardk> i'm more apt to field applicativedo questions ;)
02:50:22 <bollu> xD
02:52:11 <edwardk> re your LEM thing, dolio can probably remember/decipher the connections there. i dont have all the different gradations of laws categorized in my brain about what implies what off hand
02:53:45 <tabaqui1> why Int is not a instance of Monoid class?
02:53:53 <tabaqui1> with mempty = 0, mappend = (+)
02:54:13 <cocreature> tabaqui1: because there are multiple valid instances, e.gg. mempty = 1, mappend = (*) would also work
02:54:24 <cocreature> tabaqui1: there are Sum and Product newtypes in Data.Monoid
02:54:34 <tabaqui1> cocreature: hm, yeah, right, thx
03:09:06 <Aruro> how does ghci keep completions strings? is it one big [String] ?
03:10:37 <Aruro> i have list of length 1885, and it should take 20k space. is it suitable for old philosophical question when the list is too long to be good? :)
03:11:06 <Aruro> particularly for operations like isSuffixOf
03:11:19 <Rembane> Aruro: What do you use the list for?
03:11:21 <cocreature> how often does your list change and what kind of operations do you perform on it?
03:11:25 <Aruro> completions
03:11:34 <Aruro> its static list, forefer
03:12:04 <bot_tester> pl \f g h x -> f (g x) (h x)
03:12:09 <Aruro> its [String] im running filter with isPrefixOf on it and form completions in haskeline
03:12:12 <cocreature> A trie seems more appropriate for completions
03:13:05 <bot_tester> @pl \f g h x -> f (g x) (h x)
03:13:05 <lambdabot> liftM2
03:13:12 <Aruro> emacs haskell mode is for sure slow to edit a list of strings this big :)
03:13:40 <Aruro> cocreature: my question is does this type of data slow down things?
03:14:19 <cocreature> Aruro: does calling isPrefixOf on thousands of elements slow down things? definitely!
03:14:46 <cocreature> but the slowdown is mostly caused by doing a linear scan over all elements and not so much by using a list instead of a vector
03:15:08 <Aruro> so i will not win much in switching to different data structure?
03:15:35 <cocreature> you will win enormously if you switch to a trie, you will probably win a bit if you switch to vector
03:15:40 <cocreature> so use a trie :)
03:15:44 <Aruro> :)
03:16:28 <Aruro> im using haskeline simpleCompletion function, will haskeline work well with trie?
03:17:07 <cocreature> sry, I’ve never used haskeline so I can’t answer this
03:17:33 <cocreature> I don’t see why not
03:17:41 <Aruro> the thing is haskeline completion module has data structures which are based on strings
03:18:19 <Unhammer> last time I checked, packed-dawg was the most space-efficient trie I found on hackage, while bytestring-trie was slightly faster (and lets you store values, in case you need tath)
03:18:38 <Unhammer> argh
03:18:53 <Aruro> im sorry, trie i need just for search, i can have Trie String? right?
03:19:15 <Unhammer> Aruro,  if you're just checking membership, try packed-dawg or bytestring-trie
03:19:43 <Unhammer> I *think* bytestring-trie will be faster, but test it.
03:19:58 <cocreature> Aruro: that depends on the library you use but you can definitely put a String into a trie. it just might require that you encode it to a bytestring or something like that
03:21:00 <Unhammer> Aruro,  import           Data.Text.Encoding       (decodeUtf8With, encodeUtf8)
03:21:03 <Unhammer> and Data.Trie.fromList (map (\s -> (encodeUtf8 s, ()))) listOfStrings
03:21:07 <Unhammer> something like that
03:21:41 <Aruro> Unhammer: cocreature: ty guys for help
03:21:45 <Unhammer> np
03:21:56 <Aruro> i will switch to trie
03:26:41 <nak> hello
03:27:10 <nak> i am looking at https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Cont.html and i'm trying to find the implementation of >>=
03:27:16 <nak> but i can't seem to find it. any help?
03:29:28 <bennofs> nak: look at http://hackage.haskell.org/package/transformers-0.5.4.0/docs/src/Control-Monad-Trans-Cont.html#line-173
03:30:07 <bennofs> nak: the types for mtl are defined in the transformers package, mtl only reexports them (mtl provides the type classes like MonadCont and MonadReader etc but not the types themselves)
03:31:16 <nak> bennofs: a lot of that is going over my head
03:31:38 <nak> bennofs: i'm trying to find the >>= implementation for Cont, not ContT
03:31:54 <bennofs> nak: yeah but Cont r is just a type synonym for ContT r Identity
03:32:04 <bennofs> nak: so it's a "special" form of ContT
03:32:25 <nak> hmm ok maybe i have to understand what ContT is better then
03:32:30 <nak> do you think you can help me?
03:32:39 <nak> i *barely* have a partial understanding of Cont
03:32:45 <bennofs> nak: that code I linked is pretty unreadable though, there's lot of pragmas/ifdef 
03:33:29 <bennofs> nak: the concept you're looking for is called monad transformers. don't know where the best resource to learn about them is though
03:33:31 <mauke> m >>= k  = ContT $ \ c -> runContT m (\ x -> runContT (k x) c)
03:33:35 <mauke> you can just ignore the T's
03:33:59 <merijn> I always recommend the "learn monad transformers by implementing one" approach
03:34:20 <merijn> See here: https://gist.github.com/merijn/098106abd45c940dab09
03:34:31 <nak> well i'm not sure i want to learn about monad transformers to be honest
03:34:37 <nak> i just want to learn the basics of the continuation monad
03:34:51 <nak> like this 
03:34:53 <nak> runCont (calculateLength "123" >>= double) print
03:34:58 <bennofs> nak: oh, then there's probably better places to find the definition of >>= for Cont other than the mtl package
03:35:06 <nak> there calculateLength and double each have a continuation parameter
03:35:36 <nak> i learn things well by learning how they're implemented
03:35:51 <nak> maybe this is a stupid question:
03:35:53 <bennofs> nak: the code is equavilent to: s >>= f  = Cont $ \c -> runCont s $ \x -> runCont (f x) c for 'Cont'
03:35:56 <nak> does Cont have fmap ?
03:36:03 <bennofs> nak: yes
03:37:09 <mauke> :t \m k -> cont $ \ c -> runCont m (\ x -> runCont (k x) c)
03:37:11 <lambdabot> Cont r t -> (t -> Cont r a) -> Cont r a
03:37:59 <Reisen> Is it possible to use a typeclass to resolve a method based purely on the type chosen, even if that method doesn't use it in its type signature?
03:38:05 <Reisen> Attempts: http://lpaste.net/2147505651117457408
03:38:20 <Reisen> I.E, I'd like to be able to write          x = multiply 3 :: MultiplyBy 5
03:38:43 <nak> so when we're looking at ContT r m
03:38:48 <Reisen> Where the 5 selects the typeclass, but it's ambiguous, and of course the type family was my attempt to get the class variable into the method somehow but injectivity stops that working
03:38:58 <nak> so when we're looking at ContT r m, what exactly is r and m? how can i reason about them
03:39:13 <mauke> Reisen: needs more explicit type application
03:39:36 <Reisen> mauke, how do you mean?
03:40:02 <mauke> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#visible-type-application
03:40:26 <Reisen> mauke, well I mean, I could write that as `multiply @5 3` sure but
03:40:32 <Reisen> Isn't the problem that I can't write this without ambiguoustypes?
03:40:53 <bennofs> Reisen: I think multiply @5 3 should work
03:41:03 <Reisen> bennofs, but I get errors at compile time even before I try and use the function
03:41:33 <bennofs> Reisen: do you get those errors with -XTypeApplications as well?
03:41:43 <mauke> nak: r is the continuation return type. m is the base monad (the one we're transforming)
03:41:49 <bennofs> Reisen: i believe that extension also extends the ambigouousness check
03:42:02 <Reisen> bennofs, yes
03:43:52 <bennofs> Reisen: hmm, seems you need -XAllowAmbiguousTypes as well
03:44:02 <bennofs> Reisen: also -XFlexibleInstances
03:44:05 <Reisen> Yeah, but I kind of was hoping there might be a way of avoiding that
03:44:07 <bennofs> Reisen: after that, it works
03:44:08 <Reisen> FlexibleInstances is in my paste
03:44:25 <bennofs> Reisen: oh only in the second one, i used the first one
03:44:27 <Reisen> But AmbiguousTypes is... I feel like I'm doing something really wrong when I use that extension
03:45:09 <bennofs> Reisen: well, your type really is ambiguous. You need to explictly specify the type when using it, so that's ambiguous. If you want that, use the extension, I think that's what it is made for
03:45:44 <Reisen> Perhaps there's another way to get a similar behaviour, essentially my goal is to write a function that you can use to choose a formatter with something like
03:45:59 <Reisen> output = format :: As "html"
03:46:09 <Reisen> So that I can use DataKinds to select the instance with a type level string
03:46:34 <bennofs> Reisen: how about: format @"html" ?
03:46:53 <Reisen> It's the same problem though, the ambiguous type doesn't really give me a way to write the method without an error
03:47:00 <Reisen> Because It's `format :: Text -> Text`
03:47:24 <bennofs> Reisen: well, but with -XAmbiguousTypes, you could make it work as format @"html" :: Text -> Text
03:47:41 <Reisen> Yeah, I guess I have no choice but to use AmbiguousTypes for this then
03:47:49 <Reisen> Dang
03:49:36 <mauke> format (Proxy :: Proxy "html")
03:49:56 <mauke> formatHTML
04:01:26 <rgc> hi
04:02:04 <rgc> I don't understand this one : foldr (/) 1 [12,2,3] = 18.0
04:02:27 <rgc> it seems like 12*3/2
04:03:08 <brynser> > (12 / (2 / (3 / 1)))
04:03:10 <rgc> as in foldr (/) 1 [12,2,24] = 144.0
04:03:11 <lambdabot>  18.0
04:03:17 <brynser> I think
04:03:21 <mauke> > foldr (/) 1 [12,2,3] :: Expr
04:03:25 <lambdabot>  12 / (2 / (3 / 1))
04:03:41 <brynser> Neat
04:04:24 <rgc> brynser: can't get it :)
04:05:31 <mauke> > foldr f z [a,b,c] :: Expr
04:05:37 <lambdabot>  f a (f b (f c z))
04:07:00 <rgc> 12/2=6 ; 6/3=2
04:07:03 <brynser> rgc: I'm not great at it myself. There's a thorough chapter in the haskellbook.com book if you have that, or maybe this https://wiki.haskell.org/Fold
04:07:05 <rgc> confused :)
04:07:48 <rgc> as in foldr (/) 1 [12,2,24] = 144.0
04:08:18 <rgc> 12*24=228
04:08:28 <rgc> 228/2=144
04:08:36 <rgc> why the *?
04:08:39 <mauke> rgc: do you understand 12 / (2 / (3 / 1))?
04:09:19 <rgc> ops
04:09:27 <rgc> mauke: can see it now :9
04:09:30 <rgc> thank's
04:09:34 <rgc> :)
04:16:03 <wz1000> So Haskell isn't in GSOC this year too. Are there plans for a Summer of Haskell?
04:21:55 <fendor> there is a summer of haskell? :O
04:22:49 <tdammers> not sure if it's going to be a permanent thing, but last year Haskell didn't make it into Google's SoC, so people set up a Summer Of Haskell
04:25:45 <fendor> oh cool, i want a summer of haskell!
05:01:29 <merijn> ertes: I actually realised I can simplify my life
05:01:49 <ongy> do we have a nice commandline parsing library that does mode/subcommands like the ip command?
05:02:09 <merijn> ongy: optparse-applicative has subcommands
05:03:14 <tdammers> so far, the most pleasant solution I've found was writing a custom parser with something like parsec
05:03:29 <tdammers> there's nothing stopping you from writing a parser over [String] rather than String
05:03:38 <merijn> tbh my experience with optparse-applicative was pretty good
05:03:50 <merijn> As long as you don't need anything to specifically custom
05:05:36 <django_> whats a bold app
05:05:38 <django_> a bold project
05:06:07 <merijn> tdammers: Have you used optparse-applicative? If so, what was insufficient about it?
05:06:43 <tdammers> I have, but I can't remember what I was missing specifically
05:07:15 <ongy> merijn: oh looks good. thx
05:17:50 <merijn> Anyone know what the fastest way to block a thread until some condition (a simple Int) is true?
05:18:15 <merijn> QSem(N)? Spin loop on IORef? Hand-written CAS loop using GHC primitives? Something else entirely?
05:18:18 <hpc> well, an int can never be true :P
05:18:32 <hpc> how does the condition change?
05:18:51 <hpc> if you can write it so the thread sleeps until notified, that'd likely be best
05:18:56 <merijn> hpc: Some threads increment a counter. Terminate when counter >N
05:19:32 <merijn> hpc: I want to benchmark concurrent operations, so I need to know when every thread is finished to end the benchmark
05:19:38 <merijn> hpc: Low latency > efficiency
05:19:46 <hpc> maybe a Chan?
05:19:59 <merijn> hpc: Chan is basically an MVar, but less efficient
05:20:02 <hpc> when a thread finishes, it sends () through the chan, and the waiting thread counts them
05:20:17 <merijn> hpc: Yeah...no, way too much overhead
05:20:26 <merijn> Since "sending to a Chan" is what I'm benchmarking
05:20:32 <hpc> oh lol
05:24:29 <hpc> maybe use MSem?
05:24:56 <hpc> initialize it to a negative number
05:25:16 <hpc> have the main thread wait (which waits to take until it's > 0)
05:25:24 <hpc> and the child threads signal (which adds 1)
05:25:58 <hpc> https://hackage.haskell.org/package/SafeSemaphore-0.10.1/docs/src/Control-Concurrent-MSem.html#MSem
05:26:49 <hpc> looks like QSem is deprecated
05:28:30 <merijn> hpc: Based on what? I don't see a deprecation ote
05:33:58 <cocreature> merijn: I would guess that a hand-written cas loop is best, but that’s really just guessing :)
05:34:27 <merijn> cocreature: Yeah, leaves the question whether I should use GHC CAS primitives or unsafe FFI to C
05:34:33 <merijn> Guess that's another experiment xD
05:34:53 <cocreature> merijn: if the unsafe FFI stuff is faster, we need new primitives :)
05:35:06 <merijn> True :p
06:21:03 <orion> If a thread created by forkIO throws an exception that is not caught, will it take down the whole application?
06:32:52 <Arguggi> orion, no you should only get some text on stderr (something like program-name: excep-message) iinm
06:34:48 <merijn> The real answer is: "It Depends"
06:34:58 <merijn> Since you can overwrite the default exception handler
06:35:55 <ertes> merijn: how?
06:36:01 <ertes> by not using criterion? =)
06:36:13 <Aruro> is it possible to use unicode fraction slash to create custom fractions (using ghc putStr) ?
06:36:22 <merijn> ertes: Well, no, my problem was with the batching, right? Well, I realised I can work around that
06:37:27 <merijn> ertes: Normally criterion does batching (if you use nfIO, nf, whnf, etc.) by wrapping a loop around your workload and calling that in a batch (running your benchmark N times per batch)
06:38:16 <merijn> ertes: If you use the Benchmarkable constructor directly, your benchmark can basically by-pass this batching loop, as long as it accepts some input N that increases your benchmarks size
06:38:44 <merijn> ertes: Then, instead of treating it as batches of N being run, you can treat it a batch as a single benchmark of variable size
06:38:50 <leshow> i'm writing a traversable instance for List, just to practice. I have it written the traditional way with fmap and applicative. out of curiousity i wanted to write it with the applicativedo notation
06:39:04 <leshow> however ghc tells me "cannot deduce monad f arising from do statement"
06:39:22 <leshow> is there a way to get ghc to use only the applicative instance for my definition
06:39:28 <merijn> ertes: So, instead of writing 1 message to the channel, just write a benchmark the concurrently writes some N messages and have criterion parameterise it to figure out how large N should be for useful measurements
06:39:43 <merijn> ertes: Then you only have to do setup/cleanup per batch
06:43:05 <Aruro> this guide tells that it is possible to create any unicode fraction using super,subsrcipts and fraction slash  http://unicodefractions.com/
06:43:22 <Aruro> but tests in ghc does not confirm it working in haskell
06:45:09 <merijn> Define not working?
06:45:24 <Aruro> fraction slash is shown as box in uxterm
06:45:36 <Aruro> emacs displays it correctly
06:45:47 <benzrf> ...that doesnt sound like a haskell issue
06:45:47 <merijn> Sounds like uxterm or your locale is misconfigured
06:45:51 <benzrf> it sounds like a uxterm issue
06:46:00 <Aruro> sub and superscripts work just fine
06:46:01 <merijn> And/or your font missing a glyph
06:46:06 <ertes> merijn: ah, nice
06:46:30 <ertes> leshow: did you actually use -XApplicativeDo?
06:46:40 <ertes> e.g. via {-# LANGUAGE ApplicativeDo #-}
06:46:45 <leshow> ertes, yes i have it enabled at the top
06:46:56 <ertes> leshow: then paste your code
06:47:32 <ertes> ApplicativeDo is highly sensitive to things that could in principle be expressed using Applicative, but isn't quite in the right form
06:48:32 <Aruro> can some one confirm unicode fraction slash working for him?
06:49:21 <Aruro> in terminal, using putStr
06:50:00 <ertes> Aruro: you mean as a character/string literal?
06:50:07 <merijn> Works fine if I run 'putStr "¼"' in ghci
06:50:14 <leshow> sorry about that ertes
06:50:23 <leshow> lpaste.net/353061
06:50:54 <ertes> leshow: i suspect that the ($) is your problem
06:51:04 <ertes> try: return (Cons a b)
06:51:15 <ertes> or even, to be actually consistent with Applicative:  pure (Cons a b)
06:51:17 <leshow> huh yeah that worked
06:51:33 <Aruro> merijn: its not unicode fraction slash
06:51:39 <ertes> leshow: the problem is that ApplicativeDo expects the expression to be in this form:  pure x
06:51:39 <leshow> why would function app operator make it choose the monad instance
06:51:45 <ertes> but yours is in this form:  ($) pure x
06:51:50 <ertes> so ($) is the top-level function
06:52:09 <leshow> oh ok, that makes sense. thank you
06:52:13 <ertes> it also teaches you not to over-use ($) =)
06:52:36 <Aruro> ertes: yes, if i understood correctly form like SUPERSCRIPT FRACTIONSLASH SUBSCRIPT can form any custom unicode fraction as one symbol 
06:52:38 <leshow> i prefer the fmap and apply for this instance anyway, but it puzzled me why it wouldnt work
06:53:15 <ertes> ApplicativeDo is particularly useful with record stuff, especially together with RecordWildCards
06:53:31 <ertes> do field1 <- c1; field2 <- c2; field3 <- c3; pure MyConstr{..}
06:54:10 <ertes> for: data MyType = MyConstr { field1 :: A, field2 :: B, field3 :: C }
06:54:55 <ertes> there is simply no nice way to write this using the Applicative combinators, unless you stop using the field names =)
06:55:07 <leshow> does record wild cards put do the field1 = field1, ... there automatically?
06:55:13 <ertes> yeah
06:55:20 <leshow> that's pretty cool
06:55:39 <ertes> it will use whatever is in scope and has that name
06:56:03 <ertes> so this works as well:  f field1 = do field2 <- c2; field3 <- c3; pure MyConstr{..}
06:56:17 <leshow> i thought it was only useful for pattern matching on the left side in fn arguments
06:57:08 <leshow> so it's better to explicitly use pure instead of return when i use applicativedo? the ghc.haskell page on the ext used return
06:57:30 <lyxia> I thought you were supposed to use return
06:57:37 <leshow> i mean it makes sense of course, i just didnt see it the ghc page
06:57:46 <leshow> https://ghc.haskell.org/trac/ghc/wiki/ApplicativeDo
06:58:41 <byorgey> I'm sure with ApplicativeDo turned on it makes no difference whether you use 'return' or 'pure'
07:00:53 <lyxia> Right I just tested it.
07:01:42 <ertes> it has worked with 'pure' for me in the past, too…  that's why i suggested it
07:02:58 <lyxia> I guess I confused it with another gotcha of ApplicativeDo...
07:18:34 <mehs> Hello, was wondering what the is generally considered the 'best' JetBrains IDE plugin for Haskell
07:19:18 <leshow> is there more than one?
07:20:23 <mehs> Yeah, JetBrains repo one, HaskForce and IntelliJ-Haskell
07:51:32 <nitrix> Personally, if all the IDE is going to do is just be a wrapper to do calls to GHCi; I might as well use GHCi myself.
07:52:33 <nitrix> If it provided additional features, then it'd be a different story. Autocompletion and stuff aren't the IDE features I have in mind when I say that, since any decent text editor should be able to do this.
07:53:52 <nitrix> I'm thinking more like debugging, benchmarking, profiling... GHC's tooling is again fairly competent there :/
08:24:39 <ertes> does anyone know a CAS that lets me do manual equational reasoning (i.e. without any automatic simplifications or anything), including calculus?
08:26:35 <ertes> for example i'd like to do calculus, especially involving gradients, starting with an initial differential equation and then applying equational reasoning to get to my desired result
08:26:35 <dgpratt> I know about https://www.tryhaskell.org/ but is there anything analogous to a Haskell "fiddle" where I could send someone a snippet of Haskell and they could run it and/or see the results?
08:26:56 <ertes> dgpratt: tryhaskell isn't good enough for that?
08:27:57 <dgpratt> maybe it is, ertes, but I don't know how to send someone a snippet via tryhaskell other than "paste this into tryhaskell.org"
08:29:35 <nitrix> One day I'll finish haskellcode.com
08:30:16 <nitrix> I got stuck on the real-time collaborative part with the Operational Transformation algos.
08:31:07 <nitrix> I miss the old fpcomplete :(
08:31:32 <dgpratt> that was nice
08:31:51 <dgpratt> I was hoping it would resurface in some form at some point
08:32:11 <nitrix> Maybe I should dedicate more time to it.
08:32:26 <meze> dgpratt: https://repl.it/languages/haskell ?
08:32:46 <dgpratt> looks very promising meze 
08:33:46 <shapr> I miss the old fpcomplete also, so many good f eatures
08:49:43 <ertes> monochrom: i'm trying isabelle for the above purpose now…  seems like everybody is using it, so i figured i might just do the same =)
09:00:59 <clmg> Can fclabels traverse a record?
09:01:15 <clmg> I need to find a record with a specific field
09:03:48 <yaxu> I'm failing to get type inference to work across typeclasses, a minimal example: http://lpaste.net/353064
09:04:15 <yaxu> This in ghci 7.10.3
09:04:35 <yaxu> Any tips on making this work? Would dearly love to do this sort of thing without declaring types!
09:04:51 <byorgey> yaxu: the problem is that it doesn't know what type the '4' should have
09:05:09 <byorgey> yaxu: try  toS (4 :: Int)
09:05:22 <byorgey> yaxu: how should it work without declaring types?
09:05:34 <yaxu> byorgey: Yes I get that but would like to not have to declare the type
09:05:54 <ertes> clmg: "traverse"? "find"?
09:05:55 <byorgey> type inference is not allowed to depend on the fact that there is only one instance of Foo, because another module could add another instance later
09:06:06 <yaxu> byorgey: I expected the use of typeclass to constrain the types it would consider
09:06:36 <byorgey> yaxu: no, because typeclass instances are open.
09:07:55 <ertes> clmg: please explain more clearly what you have right now and what you would like to do with it
09:08:47 <yaxu> byorgey: hmm, but I've just noticed (actually someone else noticed) that this works if I use Integer rather than Int
09:13:37 <yaxu> byorgey: hmm, but I've just noticed (actually someone else noticed) that this works if I use Integer rather than Int (resending in case it got lost in the netsplit)
09:37:39 <wrengr> Someone pinged me yesterday?
09:42:19 <sternmull> I have a list like [["ah"], ["bee", "cee"], "dee"] and want to "multiply it out" into ["ahbeedee", "ahceedee"]. What is the function/operator i am looking for?
09:42:35 <wz1000> I remember seeing a non-recursive(in type or value) implementation of the y combinator. Does anyone know of what I am talking about?
09:42:41 <pikajude> sternmull: i don't think that list can exist, can it
09:42:44 <pikajude> it doesn't typecheck
09:43:01 <glguy> > concat <$> sequence [["ah"], ["bee", "cee"], ["dee"]]
09:43:03 <lambdabot>  ["ahbeedee","ahceedee"]
09:43:08 <sternmull> yes... the last element should be in a list of course
09:43:08 <pikajude> but sequence is what you're looking for
09:43:12 <pikajude> yeah, glguy got it
09:43:24 <sternmull> thank you!
09:43:38 <wz1000> i.e without a recursive type definition like data Mu a = Roll (Mu a -> a)
09:44:11 <wz1000> I remember it used higher ranked types to achieve this.
09:49:29 <glguy> newtype Value = Value { ($$) :: Value -> Value } ; y = Value (\f -> f $$ (y $$ f))
09:51:21 <wz1000> glguy: That has both recursive types and values :)
09:52:29 <glguy> You didn't say anything about values, and the type isn't the one you excluded!
09:53:15 <wz1000> wz1000 | I remember seeing a non-recursive(in type or value) implementation of the y combinator. Does anyone know of what I am talking about?
09:53:24 <wz1000> glguy: ^
09:53:28 <glguy> OK
09:54:54 <sternmull> i made a bash-like "brace expansion" for strings: http://lpaste.net/353065 it would be nice if someone could comment on it. Did i do any stupid unnecessary/complicated things?
10:01:16 <sm> looks reasonable sternmull 
10:03:56 <sternmull> oh nice :) Would you do it like this in production code (except for replacing String with Text)? Or would you use something like Parsec instead?
10:05:47 <ertes> sternmull: i would abstract Char away
10:05:50 <ertes> in practice
10:06:23 <ertes> sternmull: but more likely i would just use the monadic interface to []
10:07:19 <ertes> @let (<++>) = liftA2 (++)
10:07:19 <sternmull> Can i abstract Char? How does that work with  '}' and ',' as literals in the code?
10:07:22 <lambdabot>  Defined.
10:08:04 <ertes> > ["hello"] <++> ["!", "?"] <++> " i'm the " <++> ["girl", "guy"]
10:08:06 <lambdabot>  error:
10:08:07 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
10:08:07 <lambdabot>        Expected type: [[Char]]
10:08:14 <ertes> > ["hello"] <++> ["!", "?"] <++> [" i'm the "] <++> ["girl", "guy"]
10:08:17 <lambdabot>  ["hello! i'm the girl","hello! i'm the guy","hello? i'm the girl","hello? i'...
10:08:34 <ertes> also gives you a few things for free
10:08:44 <leshow> > :t (<++>)
10:08:47 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
10:08:54 <ertes> > sequenceA ["h", "e3", "l", "lL", "o0"]
10:08:56 <leshow> what the heck is <++>
10:08:56 <lambdabot>  ["hello","hell0","helLo","helL0","h3llo","h3ll0","h3lLo","h3lL0"]
10:09:04 <ertes> leshow: i defined it above
10:09:10 <leshow> oh, missed that
10:09:34 <sternmull> ertes: Thanks. I will try to write another version that uses the list monad.
10:09:44 <thoughtpolice> Public announcement (since I just wrote it): Hackage will have a short maintenance window within a few hours. https://www.reddit.com/r/haskell/comments/5wpkhh/heads_up_short_hackage_downtime_today_30_minutes/ It shouldn't last very long.
10:10:58 <sm> thank you thoughtpolice 
10:12:46 <sm> sternmull: in production code I'd probably do it exactly like that, and move on, until I had some need to make it smarter
10:15:21 <sm> ie, if it's working and reasonably easy to understand. I might add a one sentence description and an example to the main function
10:17:59 <ertes> > foldr (liftA2 (++)) [[]] [["abc"], ["def", "ghi"], ["jkl"]]
10:18:02 <lambdabot>  ["abcdefjkl","abcghijkl"]
10:18:31 <sternmull> sm: Ok. I had do this stuff today with python and did it a regex and a few lines around it. So i thought it would be a nice exercise to see how it would look in haskell. I think at the moment i have a similar linecount.
10:18:45 <Onemorenickname_> hello people
10:18:52 <Onemorenickname_> i don't haskell, but i'm reading https://arxiv.org/pdf/1512.01895.pdf
10:19:03 <Onemorenickname_> it's written "For example, a
10:19:03 <Onemorenickname_> Haskell program can only contain at most one instance of Show Int"
10:19:33 <Onemorenickname_> does it mean that in 2 independant files, there can not be difference instances of Show Int ?
10:19:45 <ertes> Onemorenickname_: there can, but it's discouraged
10:20:10 <Onemorenickname_> ertes, what's the rationale ?
10:20:12 <glguy> Onemorenickname_: That's correct, Haskell doesn't allow that
10:20:13 <byorgey> Onemorenickname_: well, there can be, but then you can never use those files together as part of the same program.
10:20:21 <ertes> Onemorenickname_: type classes in haskell follow the "open world" principle, which means that in general instances should be considered global and unique
10:20:31 <Onemorenickname_> ertes, even for libraries ?
10:20:35 <ertes> Onemorenickname_: yes
10:20:38 <Onemorenickname_> hm
10:20:50 <Onemorenickname_> is there some doc on why the open world assumption is followed ?
10:21:30 <Tuplanolla> Imagine putting items with some `Ord` instance into a `Map` and consider what happens if you suddenly change that instance, Onemorenickname_.
10:21:47 <ertes> Onemorenickname_: it's both historical, and it establishes a notion of responsibility…  an instance should be defined either at the definition site of the type or of the class
10:22:05 <ertes> Onemorenickname_: instances defined elsewhere we call "orphan instances", and they are discouraged for precisely that reason
10:22:13 <Onemorenickname_> Tuplanolla, if you say from where the Ord instance comes, it's not really a problem. If you include two files defining "Ord", then I can see the problem
10:22:42 <glguy> ertes: GHC doesn't aggressively check for colliding orphans as a performance optimization, not as a way to sneak them in
10:22:42 <Onemorenickname_> ertes : I see. and as the guideline is followed by the community, it's counter-productive to go against it
10:22:53 <Tuplanolla> You would need a mechanism for distinguishing instances then, Onemorenickname_.
10:23:28 <ertes> Onemorenickname_: the rationale is that for any potential instance there should be one particular semantics that everybody agrees on…  different semantics are implemented by using wrapper types
10:23:51 <glguy> If two instances are in scope when resolving that constraint compilation will fail with an error
10:23:58 <ertes> > getAny . fold . map Any $ [True, False]
10:24:01 <lambdabot>  True
10:24:03 <ertes> > getAll . fold . map All $ [True, False]
10:24:05 <lambdabot>  False
10:24:15 <ertes> Any and All establish different monoids over Bool
10:24:35 <glguy> Onemorenickname_: Without this coherence property you can't be sure that each operation you define in terms of these instances will get the same instance for the same type
10:24:36 <Tuplanolla> Related: should I use `First` or `Alt Maybe`?
10:24:42 <glguy> so you can't rely on things like a consistent ordering
10:24:45 <Cale> It's worth noting that orphan instances are only a concern for *libraries*
10:25:03 <ertes> depending on which wrapper type you choose you get different 'mappend' semantics
10:25:23 <johnw> > ala Any foldMap [True, False]
10:25:29 <lambdabot>  mueval-core: Time limit exceeded
10:25:35 <johnw> => True
10:25:39 <Cale> If what you're producing is the final executable program, then there's no problem defining some orphan instances, because you have the last word on what conventions you want, and can't conflict with anyone else.
10:26:07 <ertes> Onemorenickname_: yeah, but more importantly it's not a limitation…  you can still have different semantics for the same type, but the way you choose the semantics is by multiple types, not by multiple instances
10:26:57 <ertes> and a practical benefit, of course, is that inference doesn't need a lot of help
10:27:00 <Cale> Also, if you find yourself limited or annoyed by the fact that you can't define multiple instances of your class for the same type, you can always just switch to using a record datatype instead of a class.
10:28:14 <leshow> is the definition of traverse always equivalent to the Functor instance i some way? im noticing a pattern when writing traversable instances that it's just the Functor instance but with function application switched with <$> and <*> and fmap switched with traverse
10:28:41 <glguy> leshow: You can derive a Functor instance from a Traversable instance
10:28:59 <glguy> :t Data.Traversable.fmapDefault
10:29:01 <lambdabot> Traversable t => (a -> b) -> t a -> t b
10:29:03 <leshow> for instance, fmap f (Cons a fa) = Cons (f a) (fmap f fa), traverse f (Cons a fa) = Cons <$> f a <*> traverse f fa
10:29:42 <glguy> They're related in that if you choose Identity to be your Applicative for traverse you get fmap
10:29:43 <johnw> leshow: traverse is sequence . fmap
10:29:51 <johnw> so you're noticing the "fmap" part of that definition
10:29:58 <leshow> glguy, can you derive a foldable instance too
10:30:03 <leshow> from traversable
10:30:11 <leshow> it also seems similar in structure
10:30:12 <glguy> :t Data.Traversable.foldMapDefault
10:30:15 <lambdabot> (Monoid m, Traversable t) => (a -> m) -> t a -> m
10:30:30 <leshow> ah ok, the universe is starting to make sense
10:30:40 <leshow> i was like damn these look really similar somehow
10:30:46 <glguy> Which is why: class (Functor t, Foldable t) => Traversable t
10:37:03 <jaspervdj> registration for the yearly zurich haskell hackathon has opened :-)
10:42:19 <kubunto> is it possible to execute a string as a line of haskell?
10:43:32 <sm> ghc -e 'putStrLn "hello"'
10:43:36 <EvanR> theres mueval
10:44:45 <kubunto> mueval?
10:44:57 <EvanR> > putStrLn "hello"
10:45:00 <lambdabot>  <IO ()>
10:45:06 <EvanR> > let x = x in x
10:45:12 <lambdabot>  mueval-core: Time limit exceeded
10:46:12 <EvanR> > 'c' + True
10:46:14 <lambdabot>  error:
10:46:14 <lambdabot>      • Couldn't match expected type ‘Char’ with actual type ‘Bool’
10:46:15 <lambdabot>      • In the second argument of ‘(+)’, namely ‘True’
10:46:15 <Cale> kubunto: Or you can use the thing that mueval uses, called hint, which is itself a wrapper around the GHC API
10:46:33 <kubunto> Cale: where is hint
10:46:38 <Cale> Basically, you'll end up including GHC as a library in your program
10:46:54 <Cale> http://hackage.haskell.org/package/hint
10:47:55 <kubunto> wow, missing hs file
10:47:59 <kubunto> awesomesause
10:48:00 <Cale> ?
10:48:16 <kubunto> the example.hs file is gone
10:48:33 <Cale> http://hackage.haskell.org/package/hint-0.6.0/src/examples/example.hs ?
10:48:45 <Cale> loads for me
10:48:51 <drdo> Does ScopedTypedVariables not work with constraints?
10:49:16 <Cale> drdo: It works with basically everything, as far as I'm aware.
10:49:17 <kubunto> Cale: the link on the original page you gave me doesnt
10:49:25 <drdo> Cale: sec, I'll post the example
10:50:14 <lpaste_> drdo pasted “No title” at http://lpaste.net/353069
10:50:14 <ertes> kubunto: it's from the README, which is github-relative
10:50:25 <ertes> so it doesn't work from hackage
10:50:54 <drdo> Cale: For some reason GHC thinks those "p" are distinct
10:50:55 <ertes> or rather repo-relative
10:51:24 <kubunto> either way, i dont think i can nessesarily use those libraries
10:52:02 <kubunto> might have to have a bash script staple 2 together
10:52:12 <Cale> drdo: That's because you're not using the extension. You need to forall the variables you want to be scoped.
10:52:37 <drdo> Cale: Oh, you need to add the explicit forall for it to be scoped?
10:52:40 <drdo> Didn't know that
10:52:57 <Cale> yeah
10:53:13 <drdo> Cool, thanks
10:53:36 <kubunto> ill probably set one script to create an hs file and then compile and execute from a bash script
10:53:55 <kubunto> gotta love over engineering
10:54:15 <ertes> kubunto: there is also 'runhaskell'
10:54:17 <EvanR> sounds like a security issue
10:54:25 <EvanR> potentially
10:54:38 <shapr> Isn't that why SafeHaskell was created?
10:54:53 <ertes> kubunto: it's not clear whether you want to execute a haskell source file, or whether you want to integrate a haskell interpreter into your program
10:55:04 <kubunto> well it is on a server which only i really have access to
10:55:41 <kubunto> ertes: a bash script that runs a haskell executable which would generate a .hs to be compiled and executed
10:55:57 <kubunto> i know i am working too hard at this
10:56:16 <ertes> kubunto: why doesn't the outer program already do what the inner program is supposed to do?
10:56:20 <EvanR> thats what your solution is, but not your problem
10:56:45 <ertes> why the shell round-trip?
10:57:06 <kubunto> because i wanna execute an equation generated by the first one
10:57:19 <EvanR> execute an equation??
10:57:27 <ertes> kubunto: explain your problem, not the solution
10:57:59 <kubunto> i have a program that would generate an equation like add 3 4
10:58:04 <kubunto> as a string
10:58:10 <ertes> kubunto: ok, why?
10:58:10 <EvanR> thats an expression
10:58:14 <kubunto> but i wanna execute it as 3 + 4
10:58:26 <EvanR> you want to evaluate it
10:58:39 <kubunto> EvanR: cept it is a string
10:58:45 <ertes> kubunto: why doesn't the program just evaluate 3 + 4 right away instead of producing a haskell program that does?
10:58:48 <shapr> write an interpreter?
10:58:51 <EvanR> and are you sure you dont want to evaluate it as an algebraic data type, not a string
11:00:04 <kubunto> ertes: ill write something up for that when i get back
11:00:15 <ertes> kubunto: you're still explaining your solution, while the actual problem remains a mystery…  if you want to stop overengineering this, explain the *problem*
11:00:37 <EvanR> the input is a string, you could write a parser to get an expression data structure, which could be evaluated directly
11:00:49 <EvanR> "add 3 4" ==> Add 3 4
11:01:09 <kubunto> EvanR: this is the resulting string out of a tree traversal
11:01:26 <EvanR> Add (N 3) (N 4) ==> N 7
11:01:30 <ertes> kubunto: why is the result a string?
11:01:51 <ertes> again: i'm almost willing to bet that anything that involves parsers or interpreters is the wrong solution here
11:02:23 <kubunto> ertes: i could evaluate each sub equation at traversal time
11:02:38 <Cale> kubunto: Maybe generate the string at the same time as performing the arithmetic alongside that?
11:02:46 <kubunto> ^
11:02:50 <kubunto> thats what i am thinking
11:02:58 <Cale> Sounds reasonable to me
11:03:06 <ertes> and of course haskell is lazy, so you don't have to worry about passes too much
11:03:46 <kubunto> fp is fun times
11:03:53 <ertes> in any case, don't produce haskell source code =)
11:04:07 <kubunto> ill use pattern matching instead
11:04:23 <EvanR> good idea
11:06:12 <Tuplanolla> I like the way this problem went from a metacircular Haskell interpreter to pattern matching on a tree.
11:06:49 <EvanR> the solutions did at least
11:06:56 <EvanR> the problem is unknown
11:07:08 <okrasit> what is this crap? O
11:07:08 <EvanR> the problem is polymorphic
11:08:56 <drdo> Does there happen to be an extension for holes similar to agda?
11:09:17 <drdo> And something helpful in haskell-mode to go with it :)
11:09:49 <ertes> drdo: poor man's holes are available
11:09:56 <ertes> drdo: just start an identifier name with an underscore
11:10:17 <ertes> drdo: GHC will then give you the type of the whole as well as an overview of the types and values in scope
11:10:50 <ertes> drdo: if you enable -fdefer-typed-holes, you can even compile your program…  the hole error turns into a hole warning, and the hole itself turns into a run-time bottom
11:10:52 <drdo> Guess I need to enable something?
11:11:03 <EvanR> nope
11:11:04 <ertes> drdo: no, holes work out of the box
11:11:34 <ertes> s/whole/hole/
11:12:52 <drdo> I must be doing something wrong
11:13:29 <ertes> drdo: which GHC version?
11:13:39 <drdo> It says it finds the hole, but then claims it infered type "t", where "t" appears to be a fresh variable
11:13:43 <drdo> ertes: 8.0.2
11:14:11 <ertes> drdo: it needs enough context to give you more specific types, of course
11:14:23 <ertes> main = let x = 3 in print (x + _)
11:14:28 <EvanR> it reports the most general type thta will work
11:14:38 <drdo> EvanR: Then it's definitely wrong
11:16:09 <drdo> foo = (let a = _a ; b = _b in a + b) ∷ Int
11:16:22 <drdo> GHC says: "Found hole: _a :: t"
11:16:31 <drdo> Same for _b
11:16:55 <Tuplanolla> Does it not tell you the constraints of `t` later, drdo?
11:17:20 <drdo> "Where: ‘t’ is a rigid type variable bound by the inferred type of a :: t"
11:17:23 <ertes> drdo: seems like holes are pre-MMR then
11:17:29 <drdo> Which is equality unhelpful
11:17:33 <drdo> It should clearly infer Int
11:17:34 <ertes> drdo: because pre-MMR that *is* the actual type
11:17:39 <ertes> no, not clearly
11:18:17 <ertes> if you view 'a' in isolation, its type is completely undetermined
11:18:48 <ertes> in fact i'm sure agda would tell you the same thing
11:19:02 <drdo> I strongly doubt that
11:19:06 <drdo> Let's test
11:22:42 <drdo> ertes: It says the expected
11:22:59 <drdo> foo : ℕ
11:23:00 <drdo> foo = let a = {!!} ; b = {!!} in a + b
11:23:06 <drdo> ?0 : ℕ
11:23:06 <drdo> ?1 : ℕ
11:23:07 <lambdabot> Maybe you meant: v @ ? .
11:23:07 <lambdabot> : ℕ
11:23:28 <drdo> It's kinda obvious that it should
11:23:35 <ertes> i stand corrected then…  in any case, typed holes in GHC are far less powerful
11:23:38 <drdo> Otherwise holes wouldn't be very useful
11:24:02 <ertes> in this particular case i'm pretty sure that GHC does not look at the context first, so it will sometimes infer more general types
11:24:07 <drdo> ertes: If this is what it does, I'd say it's useless
11:24:23 <drdo> Other than as a placeholder for code you want to write later
11:24:35 <drdo> ertes: But context is what holes are all about
11:24:44 <ertes> drdo: it has been useful to me in the past, especially to look at the types of things that are locally in scope
11:24:52 <drdo> You want to know the type you need as precisely as possiblre
11:24:54 <drdo> *possible
11:24:57 <ertes> but obviously typed holes are not nearly as powerful as agda holes =)
11:26:06 <raspberryPI> are the Stack Servers down?
11:26:35 <drdo> ertes: It also would be useful to know what type an expression would have if placed in that context
11:26:35 <raspberryPI> cause when I use curl or wget I get this error  0curl: (7) Failed to connect to github-cloud.s3.amazonaws.com port 443: Connection timed out
11:26:38 <raspberryPI> curl download failed: https://www.stackage.org/stack/linux-arm
11:26:48 <shapr> raspberryPI: yes, Amazon S3 US-East-1 is down
11:26:57 <Darwin226> I was just about to ask lol
11:27:05 <Darwin226> Anything that can be done?
11:27:22 <dolio> drdo, ertes: No. Let in agda is less powerful.
11:28:02 <raspberryPI> Darwin226: I think the download page still works :P
11:28:05 <raspberryPI> https://docs.haskellstack.org/en/stable/install_and_upgrade/#manual-download_3
11:28:25 <raspberryPI> or not
11:28:29 <Darwin226> I can't do a "stack build" thought
11:28:35 <Darwin226> after adding a new dep
11:28:55 <dolio> Also there's no overloading.
11:29:41 <dolio> Or, no constrained polymorphism.
11:29:54 <ertes> yeah, true
11:30:26 <ertes> 'where' might be more difficult for agda
11:30:45 <dolio> Agda has where, and it's more powerful than let.
11:32:30 <dolio> Let is very limited, which is why you don't have to (and, I think, can't) annotate the values you're defining.
11:33:22 <kubunto> ertes: btw, the reason it was a string is because i cant data type well yet
11:33:24 <dolio> It doesn't do function definitions, or recursion, or polymorphism.
11:36:33 <ertes> kubunto: that's why you should always explain the problem first…  we can guide you to good solutions and tell you where to find the proper learning materials
11:40:50 <kubunto> ertes: how would i be able to create a mixed type data structure?
11:41:08 <ertes> kubunto: do you have an example?
11:41:19 <raspberryPI> is there a get.haskellstack.org mirror?
11:41:43 <ertes> kubunto: like a heterogenous list?
11:41:59 <kubunto> ertes: this is my base structure data Equation a = Digit a | Operator a (Equation a) (Equation a)
11:42:17 <kubunto> ideally digit would be a num and operator would be a string
11:42:44 <ertes> kubunto: data Equation = Digit Rational | Operator String Equation Equation
11:43:07 <raspberryPI> is there a get.haskellstack.org mirror?
11:43:13 <ertes> or:  data Equation d o = Digit d | Operator o (Equation d o) (Equation d o)
11:46:00 <kubunto> ertes: i take it that second one is more generic?
11:46:06 <Tuplanolla> The lenses `_Just` and `each` seem to work the same. Is there any reason to prefer one over the other?
11:46:54 <ertes> kubunto: yeah, sure…  the former is equivalent to (Equation Rational String) using the latter variant
11:47:13 <ertes> Tuplanolla: _Just is not just a lens, but a prism
11:47:22 <ertes> > _Just # 5
11:47:26 <lambdabot>  Just 5
11:47:44 <Tuplanolla> Ah, of course. I didn't consider that since Microlens doesn't have prisms.
11:48:43 <ertes> i believe 'each' isn't even a lens
11:48:45 <ertes> :t each
11:48:48 <lambdabot> (Each s t a b, Applicative f) => (a -> f b) -> s -> f t
11:48:53 <ertes> yeah, it's a traversal
11:49:24 <ertes> (neither is _Just)
11:50:54 <mbw> Hello everyone. I have a question regarding zipping stuff, in the sense of vector operations. I can prototype code using lists by making it highly polymorphic, using Functor, Foldable etc. However, the Prelude zip functions refer to lists. While I could use liftA2 or something, I would in general need a wrapper like ZipList. I saw that Data.Vector.Vector is an instance of MonadZip, however. Is this the way 
11:51:00 <mbw> to go in this case? Shouldn't there be a version that only needs an Applicative constraint, instead of Monad?
11:51:30 <mbw> I just would like to know what the "idiomatic" solution would be.
11:52:19 <johnw> I'd guess that an Applicative-only zip would work for vectors
11:55:17 <mbw> It doesn't appear that this exists, however. But I have to admit that I only *presume* that the Applicative instance behaves like lists.
11:56:28 <johnw> what I mean is: liftA2 (,)
11:57:48 <dolio> That will probably be a cartesian product.
11:57:58 <johnw> mostly likely, yes, not ZipList
11:58:05 <johnw> for that, you'll need a ZipVector wrapper, won't you?
11:58:19 <dolio> You would, but you'd have to make it yourself.
11:59:14 <shapr> You wouldn't download a profunctor, would you?
12:00:31 <johnw> huh?
12:04:14 <Sornaensis> shapr: lol
12:04:26 <mbw> I just wanted to do the idiomatic thing. MonadZip probably isn't too terrible, but it's overkill, albeit for the same reasons MonadPlus is, compared to Alternative. Or Maybe in contrast to Option. This is probably very pedantic and I don't know if it's of any "real world" relevance.
12:05:47 <johnw> mbw: I think the "idiomatic" way is to use a type wrapper that provides the instance you need for the least typeclass that will do the job; even if you went with MonadZip, you'd still need a way to say that it's a ZipList-like variant, and not the usual zip for two vectors (for which a function of that name with that functionality already exists in Data.Vector)
12:06:06 <pi___> hi is there a get.haskellstack.com mirror?
12:07:16 <dolio> ZipList-like variant of what?
12:07:16 <kubunto> ertes: tyvm for the help btw
12:07:35 <johnw> dolio: he wanted a zip for Vector that was akin to ZipList for lists, according to what I understood of the original request
12:08:13 <dolio> I thought the problem was just 'how do you abstract over zipping?'
12:08:34 <mbw> dolio's got it right.
12:08:51 <johnw> so then, isn't the simplest expression of that liftA2 (,)?
12:09:07 <dolio> No, because that isn't zipping.
12:09:27 <johnw> oh?  maybe I don't understand what zipping is then
12:09:38 <mbw> But then I'd still have to roll my own Applicative wrapper for arrays, vectors, assuming they behave like lists by default (cartesian product).
12:10:29 <mbw> > (,) <$> [1..3] <*> [1..3]
12:10:34 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
12:10:45 <mbw> > (,) <$> ZipList [1..3] <*> ZipList [1..3]
12:10:46 <dolio> Zipping is when you pair up values by aligning the common positions in two structures.
12:10:51 <lambdabot>  mueval-core: Time limit exceeded
12:10:53 <thoughtpolice> Heads up: Hackage downtime window is about to happen.
12:11:07 <johnw> is liftA2 (,) a sort of "free zip" then?
12:11:17 <Rotaerk> zipping *should* be interleaving, because that's what real zippers actually do
12:11:19 <thoughtpolice> Expect a little downtime, hopefully < 20min worth (syncing a large database with many files is slow)
12:12:30 <mbw> > (,) <$> (ZipList [1..3]) <*> (ZipList [1..3])
12:12:33 <lambdabot>  ZipList {getZipList = [(1,1),(2,2),(3,3)]}
12:13:57 <dolio> ZipList is an applicative whose operation is zipping of lists, but that doesn't mean that every Aplicative is zipping.
12:15:08 <benzrf> @let rotaerk'sZip = (toListOf (traverse . each) .) . zip
12:15:11 <lambdabot>  Defined.
12:15:19 <Rotaerk> lol
12:15:23 <benzrf> > rotaerk'sZip [1, 2, 3, 4] [5, 6, 7, 8]
12:15:23 <mbw> Exactly, hence the abstraction via Applicative => t a -> t a -> a or something doesn't uniquely describe what I want to do. Since MonadZip does, I'll just use that for now. I wouldn't use that kind of super-polymorphic code for number crunching anyway I think.
12:15:26 <Sornaensis> is hackage down
12:15:27 <johnw> dolio: so cartesian product isn't zipping?
12:15:29 <lambdabot>  mueval-core: Time limit exceeded
12:15:33 <benzrf> oops
12:15:39 <johnw> that makes sense
12:15:53 <johnw> I see the reason for the name ZipList then
12:16:09 <dolio> Right.
12:16:33 <benzrf> hmm, what the heck?
12:16:36 <benzrf> that worked on my end o=
12:16:45 <mbw> Maybe Applicatives haven't been in base long enough to mandate an abstraction that doesn't warrant a monad instance?
12:16:46 <Tuplanolla> > rotaerk'sZip [1, 2, 3, 4] [5, 6, 7, 8]
12:16:50 <lambdabot>  [1,5,2,6,3,7,4,8]
12:16:59 <Tuplanolla> Maybe lambdabot just hates you, benzrf.
12:16:59 <Rotaerk> that's a proper zipper
12:17:07 <Sornaensis> > sum [1..]
12:17:15 <lambdabot>  mueval: ExitFailure 1
12:18:14 <benzrf> i finally read-and-understood the Clowns and Jokers paper the other day
12:18:16 <benzrf> its nifty!
12:18:16 <dolio> MonadZip is around to generalize GHC's list comprehension syntax.
12:18:52 <benzrf> whoa, hackage down for me too Sornaensis
12:18:54 <benzrf> =(
12:19:11 <mbw> I am not misusing it, am I?
12:19:17 <dolio> Which, until very recently, was necessarily going to be a Monad.
12:19:29 <thoughtpolice> https://www.reddit.com/r/haskell/comments/5wpkhh/heads_up_short_hackage_downtime_today_30_minutes/
12:19:36 <benzrf> oh
12:19:37 <mbw> I see.
12:19:39 <shapr> dolio: huh?
12:19:40 <Sornaensis> kk
12:20:03 <shapr> dolio: list comp generalization is now an applicative?
12:20:09 <Rotaerk> > rotaerk'sZip [1, 2, 3] [4, 5, 6, 7, 8, 9]
12:20:14 <lambdabot>  [1,4,2,5,3,6]
12:20:21 <Rotaerk> crap, lined up the zipper wrong
12:20:50 <dolio> I'm not sure if it works, but you could use Applicative for some comprehensions if ApplicativeDo were enabled.
12:20:52 <mbw> isn't your zip something like interleave?
12:21:04 <Rotaerk> that's what I'm saying; that's what a zipper actually does :P
12:21:22 <dolio> I'm not sure how that would interact with zipping.
12:22:33 <mbw> I am probably overthinking things again by trying to be "clever"
12:22:41 <joseph07> I'm trying to install turtle globally (stack install turtle) but I'm getting a lot of 443 errors (e. g. s3.amazonaws.com/hackage.fpcomplete.com/package/mwc-random-0.13.4.0.tar.gz) using lts-5.17. Anyone know if stackage is known to be down or something?
12:22:41 <dolio> shapr: For instance [x + y + z | x <- a, y <- b, z <- c] only needs Applicative.
12:23:18 <dolio> And [f x | x <- a] only needs functor.
12:23:52 <shapr> I want a blog post so I can read more detail when I'm not at work *sigh*
12:23:58 <shapr> but yeah, I see some of that
12:24:15 <mbw> This is one hell of an abstraction though, since the underlying monoid isn't unique.
12:24:16 <Chousuke> joseph07: might have something to do with Amazon S3 having trouble...
12:24:24 <dolio> You only need Monad when the bound variables appear in subsequent right hand sides.
12:25:37 <joseph07> Chousuke: is amazon s3 having trouble?
12:26:02 <Ptival> anyone familiar with unbound/unbound-generics/bound? any reason to prefer one over the others? does the latter even solve the same problem?
12:26:02 <joseph07> oh yup look at that
12:27:05 <shapr> dolio: ah, that boils it down nicely
12:27:12 <joseph07> looks like quora is down too.. whelp guess I might as well go home
12:28:29 <cocreature> great hackage is hosted on s3 …
12:28:44 <davean> cocreature: huh what?
12:28:54 <dolio> No.
12:28:55 <davean> no it isn't, what are you talking about?
12:29:07 <cocreature> davean: oh so it is down for a different reason?
12:29:15 <davean> cocreature: planned migration, announced even!
12:29:17 <dolio> It's just down for some scheduled maintenance that has been announced several times in the last 15 minutes here.
12:29:25 <Ptival> https://www.reddit.com/r/haskell/comments/5wpkhh/heads_up_short_hackage_downtime_today_30_minutes/
12:29:27 <cocreature> davean: ah ok, sry
12:29:36 <davean> cocreature: we're updating the base system and migrating it to a new server
12:29:49 <nitrix> S3 is down.
12:30:00 <davean> It'll be back up as soon as this acid-state DB reloads, so like 5 minutes
12:30:01 <joseph07> but it looks like "stackage" is hosted on s3
12:30:15 <davean> Its a touch ironic our planned migration is during S3 downtime
12:30:15 <cocreature> great
12:30:24 <davean> maybe we should have moved it ...
12:30:29 <davean> I didn't realize AWS was down
12:30:33 <thoughtpolice> no, this is the perfect cover
12:30:36 <nshepperd_> Stackage is hosted on s3, it seems
12:30:55 <mnoonan> aww man, I just 'stack new'd :(
12:30:56 <davean> and hackage is back!
12:31:08 <Ptival> neat!
12:31:16 <jackhill> Thanks for you work, devean!
12:32:04 <joseph07> woot so I guess I could download the packages for stack myself from hackage
12:32:07 <cocreature> yep, thanks davean! (and whoever else was involved)
12:32:17 <davean> thoughtpolice too
12:32:31 <jackhill> yes, everyone else too ♥
12:32:32 <davean> I really need to make a high-availabiltiy version of hackage :(
12:32:33 <thoughtpolice> FWIW, Stackage repository mirrors are hosted on S3. But technically you should be able to use Hackage's index to resolve and download packages. Maybe not GHC bindists, tho
12:32:46 <davean> Ok, I did
12:32:48 <thoughtpolice> (I have no idea how to point it to Hackage's index but it's surely something obvious in stack.yaml, I'm guessing)
12:32:49 <Darwin226> how?
12:32:52 <davean> I need to make it available to people
12:33:13 <cocreature> thoughtpolice: I think it’s not quite that easy. they maintain additional metadata or something like that
12:33:25 <thoughtpolice> Mmm. I was about to say, this might be the ticket: https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md#package-indices
12:33:34 <cocreature> maybe I’m wrong :)
12:41:14 <mnoonan> while I'm twiddling my thumbs re: s3, I have a question: I want to do some parsing of some relatively uniform C++ headers that wrap a C API in order to automatically generate analogous Haskell bindings to that C API.
12:41:21 <mnoonan> What are some good options for parsing C++?
12:42:48 <mnoonan> is LibClang the only full-featured option? (not that I require a full-featured option for this use case)
12:44:07 <benzrf> mnoonan: couldnt you parse the C instead?
12:45:10 <mnoonan> benzrf: Yeah, but the "problem" is that the C represents an older API, and it was cleaned up in various ways for the C++ API.
12:45:11 <mnoonan> So I'
12:45:21 <mnoonan> d like to make use of that cleanup, ideally.
12:45:25 <joseph07> wow changing the download-prefix in package-indices in stack's config.yaml actually seems to work like a charm
12:46:03 <thoughtpolice> joseph07: Cool. Apparently S3 is beginning to come back online in read-only mode soon, so hopefully you won't need it forever.
12:46:12 <thoughtpolice> Or at least it is, for some people.
12:46:37 <joseph07> thoughtpolice: thanks for the tip! I was pretty pessimistic for some reason but it totally worked
12:46:48 <doomlord> can haskell make a function generic over the size of a tuple, e.g.   get-first (x,y)=x    get-first (x,y,z)=x etc
12:47:06 <cocreature> doomlord: no
12:47:35 <joseph07> cocreature: couldn't you make a typeclass for get-first?
12:47:59 <doomlord> and implement that for any types in the tuple slots?
12:48:25 <doomlord> (or would you need to explicitely tell the tuples that they're instances of that typeclass)
12:48:35 <cocreature> joseph07: that kind of works since there is an upper limit on the size of a tuple but it wouldn’t otherwise since you would need to create an infinite number of instances
12:48:38 <benzrf> doomlord: you don't want to do this, trust me
12:48:50 <doomlord> heh ok
12:49:01 <benzrf> it's almost never what you want in practice
12:49:22 <benzrf> that said, lens does have a class for this:
12:49:50 <joseph07> doomlord: did you have a particular problem you were trying to solve?
12:49:56 <benzrf> > (1, 2, 3)^?each
12:50:00 <lambdabot>  Just 1
12:50:01 <benzrf> > (1, 2, 3, 4) ^? each
12:50:05 <lambdabot>  Just 1
12:50:15 <benzrf> this is probably a bad idea, though
12:52:14 <benzrf> bbl
12:59:18 <doomlord> 'problem/solve' - i remembered thinking about this more from the pov of having an accessor for records - the same named field in the same slot
13:01:53 <yaxu> Any ideas why testA works fine, and testB fails to work out that `4` is an Int? http://lpaste.net/353074
13:02:08 <Sonarpulse> is it possible for seqing a function to do real work?
13:02:35 <cocreature> Sonarpulse: could you be a bit more precise? I don’t understand your question
13:02:37 <Sonarpulse> I can't think of anything one can do with a function without applying it that doesn't already involve eta expansion and thus no work
13:03:09 <cocreature> ah ok
13:03:25 <Sonarpulse> cocreature: what "interesting" computation can happen from seqing a function
13:03:31 <cocreature> Sonarpulse: well you can evaluate to check that it evaluates _to_ a function, e.g. does not throw an exception
13:03:31 <Sonarpulse> except for divergence?
13:03:56 <Sonarpulse> cocreature: ok fair, anything else?
13:04:49 <danielsmw> is it possible to have the dimensionality of a Data.Vector.Unboxed.Mutable MVector element to be specified at runtime?
13:04:51 <cocreature> I don’t think so but I don’t think functions are fundamentally different here. seqing a function stops once you have evaluated it to a primitive function, sequing an Int stops once you have a primitive int, …
13:05:27 <dolio> let n = ack 4 4 in n `seq` \x -> x
13:05:43 <danielsmw> i've tried making an MVector of (V n k)'s from the Linear library, but I'm finding the type-level dimensionality impossilbe to resolve without specifying the dimensions explicitly at compile time.
13:05:49 <dolio> That computes the Ackermann function at 4 and 4 before evaluating to the identity function.
13:06:40 <drostie> yaxu: well I can tell you why testB fails but not why testA doesn't, does that help?
13:06:49 <Sonarpulse> dolio: ah that we can optomize it away
13:06:57 <Sonarpulse> but one can imagine closing over the value too
13:07:02 <yaxu> drostie: heh, it might
13:07:09 <Sonarpulse> let n = ack 4 4 in n `seq` \x -> + n x
13:07:58 <drostie> yaxu: the literal 4 really means the expression `fromInteger 4` wherever it appears, where the latter 4 is an actual value of type Integer.
13:08:22 <Sonarpulse> cocreature dolio: I think the answer is the only interesting thing that can happen is forcing the evaluation of eventually-closed-over variables
13:08:24 <drostie> yaxu: therefore in testB 4 you really have testB (fromInteger 4).
13:08:39 <alexknvl> Sonarpulse: unsafePerformIO can happen :P
13:09:33 <drostie> yaxu: now the compiler says "well that's a problem, because I might have many types which are both a Num and a Bar. If I did, which one would I choose?"
13:09:39 <Sonarpulse> alexknvl: but how do you force the unsafePerformIO call? :P
13:10:06 <drostie> yaxu: because anyone can define instances anywhere and come up with something useful.
13:10:38 <drostie> So it's now asking you to resolve that "ambiguous type variable" because it does not like the fact that based on whatever instances happen to be loaded, this might have a unique answer or not.
13:11:00 <yaxu> drostie: thanks, this makes some sense
13:11:02 <drostie> yaxu: that means that the fact that testA passes is the real mystery, not the fact that testB does.
13:11:10 <drostie> s/does/fails/
13:11:58 <alexknvl> Sonarpulse: lol. you can also reduce the amount of unevaluated stuff on the heap by sequing afaik
13:12:03 <drostie> yaxu: my guess is that somewhere inside the language this idea of "4 is really fromInteger 4" doesn't really apply if there is some way to view 4 as an Integer in the first place.
13:12:26 <yaxu> drostie: it 'works' for String as well
13:13:31 <drostie> yaxu: that doesn't have ambiguity unless you have the generic string literals -X set, whatever that was.
13:13:49 <drostie> -XOverloadedStrings, I think.
13:13:59 <yaxu> I do have that set
13:14:07 <drostie> kk.
13:14:39 <yaxu> With overloaded strings set, this works for strings, but not overloaded strings
13:14:42 <yaxu> (if that makes sense)
13:15:08 <yaxu> drostie: what I'm trying to do is have a function that can take different types of values that are part of the same typeclass, and have type inference work
13:16:13 <drostie> yaxu: do you want a polymorphic function or something weirder like a polymorphic list?
13:17:28 <yaxu> drostie: A polymorphic function. Thinking about it, I suppose that `show` does this quite happily. I should look at its definition
13:17:40 <drostie> because I mean, `sum :: (Foldable t, Num a) => t a -> a` does just fine as a polymorphic function, but I understand if you're having trouble with "I want to create a list of heterogeneously-typed values that are all polymorphic."
13:17:47 <drostie> er.
13:18:06 <drostie> replace the second "polymorphic" with "all Num instances."
13:19:19 <mbw> You can create such a list with forall. 
13:19:36 <drostie> yaxu: right, note that the polymorphism isn't what's getting in your way, it's that you're feeding a polymorphic output into a polymorphic input in a way that totally destroys any attempt to work out which intermediate state you went through.
13:20:34 <faberbrain> hey, i'm wondering if theres a way to make this FromJSON instance less verbose: http://lpaste.net/1577998090089005056
13:20:42 <yaxu> drostie: What I'm actually trying to do is make a function with a parameter that is either a rational number, or a container of rational numbers (in this case the container is a Pattern, as defined by tidalcycles.org)
13:20:58 <faberbrain> problem i'm having is that the json int is wrapped in quotes, so it is failing
13:22:02 <drostie> yaxu: ok. You've got a couple options there.
13:22:03 <mbw> I also have another question. I have a fold that behaves like this: (sumx', sumy', sumxy', sumxx') = foldr f e xys; where: f (x, y) (sx, sy, sxy, sxx) = (x+sx, y+sy, x*y+sxy, x*x+sxx); e = (0, 0, 0, 0).
13:22:21 <mbw> Is it possible to define a Monoid instance for this quadruple that captures this behavior?
13:22:43 <mbw> It should be trivial for the first two elements, but I am not so sure about the other two.
13:23:06 <mbw> Let the input be a list of pairs of Nums.
13:23:08 <kadoban> (<>) in a Monoid is associative. I don't think that will be?
13:23:09 <drostie> yaxu: option 1: sum type. `data Music x = Single (Ratio x) | Multi (Container x)` or what have you. Dead simple to process and accept, make it part of whatever classes it needs to be, good to go.
13:23:36 <drostie> option 2: put every rational in its own container.
13:24:00 <drostie> option 3, a typeclass which admits of two instances, the `Ratio x` and the `Container x`.
13:24:51 <drostie> option 4, like option three but then with Rank2Types you can actually put these things into a monotyped black hole which removes all ability to figure anything else but the typeclass out from them.
13:24:53 <mbw> kadoban: I thought so, too, but I was not sure if I am not simply too unimaginative.
13:26:00 <drostie> Option 4 looks like data Music = Music (forall r. MusicClass r => r) or so. It forgets everything about your data except its instance as a MusicClass.
13:26:03 <dolio> mbw: Adding a pair to a quadruple doesn't make sense for a monoid, because it's not a binary operation on a single type.
13:26:18 <kadoban> Oh, also that
13:26:22 <drostie> yaxu: mix and match those options to your heart's desire.
13:26:22 <dolio> You could define an operation that turns pairs into quadruples, though.
13:26:26 <dolio> Then the monoid is addition.
13:26:32 <dolio> Point-wise.
13:27:00 <dolio> And foldMap with your function produces the equivalent of your foldr.
13:27:21 <yaxu> drostie: I think options 1 and 2 still have some overhead in terms of having to be explicit about what the type of something is
13:27:34 <mbw> dolio: The thing is, I had quite the same situation with a fold that calculated the sum and the maximum. The type signature for foldl also was of type (b -> a -> b), but I was able to convert it.
13:27:49 <mbw> hmm
13:28:33 <mbw> But then a copy couldn't be avoided?
13:28:36 <yaxu> drostie: option 3 is what I have but it only works if I declare the type of the input each time
13:29:05 <mbw> Ah, you mean just "quadruple" each pair?
13:29:12 <yaxu> drostie: I'll read into option 4.. thanks again!
13:29:28 <drostie> np.
13:29:57 <mbw> This would probably be what I did with the sumMax thing. I knew I was uncreative.
13:31:32 <dolio> Yes, (Integer, Integer) -> (Integer,Integer,Integer,Integer) or whatever.
13:31:36 <Sonarpulse> dolio: wait I meant the other side of the seq
13:31:54 <Sonarpulse> closed over ackerman would never be forced until function is run because laziness
13:32:19 <dmwit> mbw: `foldMap (\(x,y) -> (Sum x, Sum y, Sum (x*y), Sum (x*x)))` perhaps.
13:32:27 <dolio> My expression is a function that requires evaluation of the ackermann function when the function is evaluated.
13:32:50 <dminuoso> k
13:33:57 <dmwit> mbw: For sum and max, a similar trick applies. `foldMap (\x -> (Sum x, Max x))`.
13:34:22 <mbw> Yeah, that's what I did, although I defined my own newtype wrapper.
13:34:57 <mbw> But right now I am too stupid to define a mempty = (0,0,0,0)
13:35:21 <byorgey> mbw: why define your own newtype wrapper?  The Monoid instance for (Sum a, Max a) comes for free!
13:35:26 <mbw> I have newtype Quad a = Quad (a,a,a,a) and instance Num a => Monoid (Quad a) where ...
13:35:47 <mbw> Yeah, I am just trying to figure out my mistake here.
13:35:51 <EvanR> data Quad a = Quad a a a a ?
13:36:09 <dmwit> EvanR: Basically equivalent to his definition
13:36:14 <mbw> ah
13:36:19 <mbw> I forgot ... Quad!
13:36:22 <EvanR> yeah but i dont see what (a,a,a,a) gets you
13:36:41 <byorgey> well, it's a newtype
13:36:51 <mbw> Force of habit?
13:36:53 <byorgey> so you can GeneralizedNewtypeDeriving and such
13:37:05 <EvanR> ok, theres that
13:37:20 <EvanR> but other than that theres no useful predefined support for (a,a,a,a)
13:37:45 <beaky> hello
13:38:04 <mbw> There actually is a monoid instance already
13:38:05 <beaky> https://ideone.com/9ws6qn is it a good idea to put typeclass constraints in `data` definitions
13:38:20 <byorgey> beaky: no, it's not
13:38:25 <beaky> why not :<
13:38:35 <byorgey> beaky: because they don't mean what you think they mean.
13:38:40 <beaky> hmm what do they mean
13:38:45 <byorgey> I don't remember.
13:38:59 <EvanR> > mempty :: (String,String,String,String)
13:39:02 <lambdabot>  ("","","","")
13:40:05 <implementation> also there's CarCdr support for (a,a,a,a)
13:41:10 <mbw> What is CarCdr?
13:41:32 <mmaruseacph2> beaky: because you have to replicate those constraint in _every_ function that uses that type
13:41:37 <nshepperd_> mbw: common pattern with me is to define some monoid like Quad a = Quad a a a a, then a function usually called "inject" (because I'm lazy with naming) that turns one input value into a Quad
13:41:40 <beaky> ah so its more messy
13:42:01 <mmaruseacph2> whereas, if you didn't include the constraint in the definition then you'd only need it in the functions which require the constraint
13:42:43 <drostie> https://hackage.haskell.org/package/acme-lookofdisapproval-0.1/docs/Acme-LookOfDisapproval.html
13:42:49 <drostie> ahahahahahahahaha
13:42:53 <mniip> inject? why not use Control.Applicative.pure
13:43:18 <nshepperd_> mbw: in this case inject (x, y) = Quad x y (x*y) (x*x)
13:43:28 <mniip> aah
13:43:29 <dmwit> nshepperd_: But why define a new type at all?
13:43:30 <beaky> isnt it a godo thing so that i can verify my type always satisfies that constraint everywhere
13:43:36 <dmwit> (Sum a, Sum a, Sum a, Sum a) works just fine.
13:43:46 <Rupsbant_> Question: does haskell have problems with x87 floating point instructions that C has? https://gcc.gnu.org/bugzilla/show_bug.cgi?id=323 
13:44:17 <Rupsbant_> Can x+y == x+y fail?
13:44:20 <nshepperd_> dmwit: Meh. I don't like the look of that as much
13:45:21 <byorgey> beaky: why would you care whether your type satisfies the constraint *everywhere*?  Why not just verify that it satisfies the constraint *where the constraint is actually needed*?
13:45:23 <mbw> Probably the newtype thing might be preferable if you want to give it a domain specific name. Otherwise, it should be a matter of taste, no?
13:45:42 <beaky> byorgey: so i can verify my BST is ordered everywhere 
13:46:00 <mniip> Rupsbant_, I suppose it may, but only in optimized code
13:46:02 <byorgey> beaky: just because you have an Ord constraint does not actually mean it satisfies the BST invariant
13:46:06 <beaky> ah
13:46:24 <byorgey> it just means elements of the type can be compared
13:46:42 <beaky> hmm this is better but it seems to not like the `mappend`? https://ideone.com/hgUxxG
13:47:04 <nshepperd_> dmwit: plus, probably want to make it a strict structure
13:47:29 <beaky> byorgey hmm so how do i make sure it is always bst invariant
13:48:07 <Rupsbant_> mniip but its not really known? Then ill have to test this myself. Thanks
13:48:32 <dmwit> beaky: If you want the compiler to check this for you, you are probably going to prefer working in a language with more proof capabilities than GHC has.
13:48:36 <byorgey> beaky: your choices are (1) prove it yourself, or (2) write the code in Agda/Coq/Idris/etc. and encode the BST invariant in the types.
13:48:37 <mbw> I was thinking about mentioning that, but I have no idea if people use bang patterns and unpack pragmas by default.
13:48:42 <beaky> ah
13:48:51 <beaky> hmm ok i will check those out
13:49:06 <dmwit> You might look at Liquid Haskell (don't know if it has the necessary power), or one of the dependently typed languages floating around like Agda, Coq, or Idris.
13:49:49 <dmwit> beaky: Practically, the most popular solution is to write the code carefully, following a known and proven-on-paper algorithm, and test it a lot. =)
13:49:56 <mniip> Rupsbant_, that might be hard to test
13:50:28 <beaky> dmwit hmm do those proof languages automagically do the 'test it a lot' thing for me
13:50:47 <Ptival> beaky: Coq has something called QuickChick that tries to do that
13:51:14 <dmwit> beaky: Generally, one proof is equivalent to infinitely many tests. So, yes, in a way.
13:51:32 <dmwit> beaky: The trick is you get all the fun of writing the proof. =)
13:51:46 <Rupsbant_> I know, but if i use a user input and obfuscate the addition it should work i think
13:51:52 <Ptival> dmwit: I understood the question as "test it works before trying to prove" haha
13:51:54 <Koterpillar> there are infinitely many cases where infinitely many tests are worse than one proof
13:51:54 <nshepperd_> I think i actually made a bst with compiler checked ordering once. For nats, using type level nats :0
13:52:01 <Ptival> but yeah, a proof is worth all tests
13:52:10 <nshepperd_> But of course it was not very usable at all
13:52:54 <Ptival> Liquid Haskell is a good compromise for this, pretty sure the BST invariant would be easy for it to handle
13:55:07 <Ptival> cf. https://ucsd-progsys.github.io/liquidhaskell-tutorial/05-datatypes.html#/binarysearchtree
13:56:38 <mniip> Rupsbant_, are xmm insns susceptible to the issue too?
13:57:57 <mniip> because for double, ghc generates addsd+ucomisd
13:58:37 <Rupsbant> mniip the bug is noted in the list of haskell bugs
13:59:29 <Rupsbant> Let x = E1 in E2 may be different than E2[x/E1]
14:00:40 <Rupsbant> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/bugs.html#bugs-ghc
14:13:48 <mbw> K thanks for your help (before I forget).
14:18:08 <Sonarpulse> dolio: sorry for adding confusion with this "closing over" talk, that's separate forget about it
14:18:39 <Sonarpulse> dolio: I meant to include a condition that only functions may be the first argument of seq
14:19:09 <Sonarpulse> ack 4 4 `seq` \x -> x
14:19:13 <Sonarpulse> is no good then
14:19:34 <Sonarpulse> let n = ack 4 4 in \() -> n is also no good cause laziness
14:20:32 <dolio> "ack 4 4 `seq` \x -> x" is a function.
14:20:58 <Sonarpulse> dolio: sure, but I'm by fiat prohibiting non-function left of `seq`
14:21:05 <dolio> Why?
14:21:13 <Sonarpulse> that's too easy away to make some meaningful computation happen :)
14:21:38 <Sonarpulse> dolio: for background, I'm thinking about what I wrote in https://github.com/ghc-proposals/ghc-proposals/pull/27#issuecomment-283153349
14:21:47 <Sonarpulse> say all we had were unlifted functions
14:22:06 <dolio> It's easy to do without seq, too. It's just easiest with seq.
14:22:34 <Sonarpulse> if we only had those.....what would the downside be?
14:23:05 <Sonarpulse> explicit delaying with \() -> sucks
14:23:38 <Sonarpulse> but plain old exta expansion can delay any expression of type `a -> b` *without* changing the type!
14:24:22 <Sonarpulse> (similar with `let x = ... in (fst x, snd x)`)
14:24:51 <Sonarpulse> I'm thinking we should have always only had unlifted functions and products
14:25:06 <Sonarpulse> dolio: it may be easy, but I don't yet see it, care to show me?
14:25:29 <Sonarpulse> dolio: I can see doing big recursion with accumulator
14:25:38 <Sonarpulse> and then throwing away acumulator in base case
14:25:42 <Sonarpulse> (or closing over it)
14:25:46 <dolio> if even (ack 4 4) then (\x -> 1) else (\x -> 2)
14:26:07 <Sonarpulse> :)
14:26:11 <Sonarpulse> d'oh
14:27:12 <Sonarpulse> dolio: I was going to say "hmm still eliminating bool" but one can church-encode everything
14:28:47 <mniip> Sonarpulse, so you want product ADTs be strict by default?
14:28:52 <mniip> to be*
14:29:34 <mniip> but then [] would be unlifted
14:29:43 <mniip> and suddenly the ever-elegant [1..] is no more
14:29:55 <dolio> [] isn't a product.
14:30:24 <mniip> [](a) = 1 + a * [](a)
14:30:42 <dolio> And you don't need to be strict to be unlifted, just unable to distinguish bottom from a tuple of bottoms.
14:31:50 <glguy> mniip: The + there gives away that [] isn't a product
14:32:01 <mniip> okay what about Stream then
14:32:20 <glguy> that works fine, unlifted doesn't mean strict fields
14:33:43 <mniip> yeah but you can't tell bottom from bottom `Cons` bottom
14:34:19 <glguy> You'd only get to interact with it via head and tail, casing on the data constructor wouldn't "force" anything
14:35:25 <mniip> wouldn't that kinda imply having to provide all the elements' thunks upfront
14:40:20 <codedmart> any doctest users here? can you control the order of modules tested?
14:42:38 <Squarism> Not sure how i should think of this. I often find i have a dynamic datastructure where "i know" i have certain elements (because of prior checks) - but persist doing : fromJust $ M.lookup someKey mapContainingSomeKey. Any clean solutions to this?
14:43:23 <johnw> fromJust $ M.lookup key m = m M.! key
14:45:17 <Squarism> johnw, ? Not sure what you wrote there?
14:45:41 <johnw> Data.Map defines an operator (!) that does what you're doing
14:45:51 <Squarism> ah ok
14:46:20 <Squarism> johnw, good to know
14:48:14 <pikajude> Q: does Data.Map expose a way to unsafely lookup a key? A: yes !
14:48:48 <johnw> but maybe that's not what he meant
14:50:18 <kadoban> Huh, I never knew that it had a (!) actually, that could be useful sometimes. I too just use fromMaybe in such situations.
14:52:42 <Squarism> no.. its rather like i wanted a way to to freeze a map into a static datatype. Say i have a game of 3 players. For the rest of the game ill only lookup player 23,34,45 - and i know theyll never leave the map - so it feels moronic doing fromJust / lookup. I dont expect theres a soluton but ive been suprised before how haskell tackles problems. 
14:52:47 <pikajude> for some reason, in the module, (!) = find and find isn't exported
14:52:52 <pikajude> how strange
14:53:50 <MarcelineVQ> which module
15:01:01 <EvanR> Squarism: theres a package for a "total map"
15:01:09 <EvanR> where lookups cant fail
15:01:30 <johnw> Squarism: you're thought is natural to dependently typed programming, btw
15:02:27 <EvanR> you can also use the type system to introduce a phantom type token that lets you use keys that are "smart" constructed along with the map, so no other keys will work
15:03:18 <EvanR> lookup :: k p -> Map p k a -> a
15:05:29 <Squarism> EvanR, oh ok. Nice to know.
15:06:19 <EvanR> to do it like ST, youd need a wrapper that runs your whole program in a lambda that is given the p
15:06:28 <EvanR> or has the p in the type
15:07:33 <Squarism> Maybe its a pointless bother about - it just strikes me as repeated source of irritation
15:08:25 <EvanR> yeah the more you become aware of these potential sources of error the more you get sucked into trying to make the system prove it impossible
15:08:30 <EvanR> it can get out of hand
15:08:53 <Tuplanolla> The first step is admitting you have a thinking problem.
15:09:24 <johnw> in a language like Agda, when you have a value of type "is element of list xs", it comes with a proof of how that element is a member of xs.  For the map case, you'd want a constructor that shows that the map to which your key is a member, was created by inserting the asociated value at that key. This is a bit trickier to work with in Haskell, but there are ways.
15:11:57 <fiddlerwoaroof> Does anyone here have any recommendations for learning about the architecture of functional applications?
15:13:31 <drostie> My architecture for functional applications: open text file with GHCi console in Kate. Type things into GHCi until something seems to work. Paste into the text file, save. Repeat.
15:14:14 <fiddlerwoaroof> But, what do you think about when it comes to organizing code and choosing your abstractions?
15:14:26 <fiddlerwoaroof> That is, currently, more or less my process
15:14:30 <drostie> Results in bottom-up design which is a bit of a mess at the higher-levels but has a bunch of small functions that each get some distance towards the goal.
15:15:00 <EvanR> for separate sections of the program, you can use a record-of-functions(or-other-things) to specify a java-like interface
15:15:31 <EvanR> a value of that type is the implementation, and you can have multiple versions of the same interface (ex. for testing)
15:16:08 <EvanR> within each implementation you could use regular functional programming
15:16:36 <drostie> I mean I view abstraction choice as something for later, mostly. Occasionally I will do programming by wishful thinking where I will say, "okay, I am just going to let myself write stub functions `foo = undefined; bar = undefined; baz = undefined`, if I could cook up any functions I wanted, how would this program actually look?" -- and that comes with a bit more organization.
15:17:31 <drostie> Because after the main body is complete and you give the undefineds type signatures and everything typechecks, you usually start to get into more-abstract types.
15:17:47 <EvanR> rather than undefineds you can use holes
15:18:04 <EvanR> since i find it annoying to find the undefines later
15:18:56 <drostie> But ironically my limited experience with Haskell has been a surprising amount of *not* abstracting. It's more been that everyone else has abstracted stuff for me.
15:19:13 <drostie> Then again I've never published a library like lens or HXT.
15:42:01 <Tuplanolla> I draw lots of GraphViz diagrams (mostly data flow) and split modules with lots of imports into modules with less imports (adding type parameters as I go), drostie.
15:42:18 <Tuplanolla> Then architecture just happens.
15:44:58 <Tuplanolla> If I consciously reserve time to design an architecture, I'll just end up with lens-but-useless.
16:00:29 <johnw> it's also always surprising how much you can abstract with just a closure
16:01:16 <monaddanom> hum?
16:01:30 <johnw> I recently create a data generator where tracks have columns, and I wanted to be able to let the user manipulate which columns were printed, and in what order.  I ended up just taking a list [Row -> Text] as input, which means my algorithm didn't need to care about the columns at all.
16:02:11 <johnw> i.e., a list of closures, where each lambda closes over the column it cares about
16:05:39 <monaddanom> @help
16:05:40 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:05:48 <monaddanom> @help list
16:05:48 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
16:06:39 <johnw> do you need some assistance, monaddanom?
16:07:03 <monaddanom> no i don't think so:-) new here 
16:11:21 <Ptival> is there a pragma to disable a warning for some definition or some file?
16:11:52 <Tuplanolla> Put `{-# OPTIONS_GHC -fno-warn-whatever #-}` in the beginning, Ptival.
16:12:17 <Tuplanolla> There's also plain `OPTIONS` for common flags.
16:13:32 <Ptival> Tuplanolla: thanks!
16:17:53 <Ptival> I hope someone works on exhaustiveness checking with simple pattern synonyms :)
16:38:35 <mniip> edwardk, hmm, the algorithm is by no means trivial, I'm looking at some example cases (of End_a Hom(Fa, Ga)) and I'm not seeing any pattern whatsoever
16:39:17 <mniip> and then there's stuff like End_a Hom(Hom(a+, a-), Hom(a-, a+)) = Z
16:39:30 <mniip> errr s/Z/N/
16:40:59 <mniip> this sounds a lot like what djinn is donig
16:43:04 <Forkk> is using gmp in C code called from Haskell possible now? everything I'm finding about it on google seems dated
16:43:36 <Forkk> and if it is, how would one go about marshalling `Integer`s to and from C code
16:45:35 <EvanR> you can import Prim something to deconstruct Integer to get a pointer to gmp object
16:45:52 <EvanR> im not sure about what you do in C though
16:47:25 <Forkk> what if the garbage collector deletes the integer while C is using it though
16:48:25 <lambdafan> @type a -> m (a -> b) -> m b
16:48:28 <lambdabot> error: parse error on input ‘->’
16:48:36 <lambdafan> @type (a -> m (a -> b) -> m b)
16:48:39 <lambdabot> error:
16:48:39 <lambdabot>     Pattern syntax in expression context: a -> m (a -> b) -> m b
16:48:39 <lambdabot>     Did you mean to enable TypeApplications?
16:49:09 <lambdafan> @djinn (a -> m (a -> b) -> m b)
16:49:10 <lambdabot> -- f cannot be realized.
16:49:14 <glguy> lambdabot: What are you trying to do?
16:49:27 <lambdafan> @djinn a -> m (a -> b) -> m b
16:49:27 <lambdabot> -- f cannot be realized.
16:49:34 <Sornaensis> @kind (a -> (a -> b) -> b)
16:49:36 <lambdabot> error: Not in scope: type variable ‘a’
16:49:36 <lambdabot> error: Not in scope: type variable ‘a’
16:49:36 <lambdabot> error: Not in scope: type variable ‘b’
16:49:41 <lambdafan> I'm trying to find the operator with that type
16:50:04 <Sornaensis> @hoogle a -> m (a -> b) -> m b
16:50:05 <mniip> :t fmap . flip id
16:50:07 <Tuplanolla> :t \ x f -> f <*> pure x
16:50:07 <lambdabot> Functor f => b1 -> f (b1 -> b) -> f b
16:50:07 <lambdabot> Control.Lens.Getter contramap :: (a -> b) -> f b -> f a
16:50:07 <lambdabot> Data.Functor.Compat fmap :: (a -> b) -> f a -> f b
16:50:07 <lambdabot> Data.Functor.Apply fmap :: (a -> b) -> f a -> f b
16:50:09 <lambdabot> Applicative f => a -> f (a -> b) -> f b
16:50:35 <mniip> it is not doable for a generic f
16:50:43 <mniip> hence djinn's failing
16:50:57 <glguy> :t flip (??)
16:50:58 <EvanR> Forkk: well, you have a reference to it, so not sure if thats possible
16:50:59 <lambdabot> Functor f => a -> f (a -> b) -> f b
16:51:26 <Sornaensis> @hoogle Functor f => a -> f (a -> b) -> f b
16:51:27 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
16:51:27 <lambdabot> Prelude (<$>) :: Functor f => (a -> b) -> f a -> f b
16:51:27 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
16:51:36 <lambdafan> @hoogle a -> m (a -> b) -> m b
16:51:37 <lambdabot> Control.Lens.Getter contramap :: (a -> b) -> f b -> f a
16:51:37 <lambdabot> Data.Functor.Compat fmap :: (a -> b) -> f a -> f b
16:51:37 <lambdabot> Data.Functor.Apply fmap :: (a -> b) -> f a -> f b
16:51:49 <mniip> lambdafan, you were already given an answer
16:51:52 <Forkk> EvanR: C code having a pointer to it doesn't count I don't think
16:51:57 <Forkk> I suppose I could copy it
16:52:01 <glguy> lambdabot: You can mess around with lambdabot in /msg
16:52:05 <glguy> lambdafan: : You can mess around with lambdabot in /msg
16:52:09 <lambdafan> ah, thanks :)
16:52:11 <EvanR> haskell code will have a reference to it
16:52:36 <mniip> EvanR, that depends on the code
16:52:38 <Forkk> that's not guaranteed
16:52:57 <mniip> you can easily have it unreferenced just as the gmp object goes into ffi
16:53:14 <EvanR> i mean, a reference to the object itself
16:53:17 <mniip> and gmp objects are what? Addr#?
16:53:20 <EvanR> if the integer wrapper is gone, so what
16:54:06 <Forkk> also, can gmp even be used in called C code
16:54:24 <Forkk> I've heard there were issues, but I can't find anything specific saying they were fixed
16:54:35 <mniip> aha
16:54:39 <mniip> it's a ByteArray#
16:54:47 <mniip> which can be spontaneously moved
16:55:18 <EvanR> ByteArray# can?
16:55:28 <mniip> if it's not pinned?
16:55:31 <EvanR> i know whatever ByteString uses cant
16:55:43 <mniip> hmm
16:55:51 <mniip> or was it mutable byte arrays
16:56:09 <Forkk> so integers are stored as byte arrays?
16:56:34 <mniip> Forkk, more like unpacked mpz_t
16:56:50 <Forkk> right
16:57:01 <Forkk> so how would I turn that into an mpz_t in C
16:58:43 <Forkk> I'd probably want to have it copy it so it's not subject to the GC
17:00:14 <mniip> ah
17:00:17 <mniip> 1.0.0.1 changed it
17:00:26 <lambdafan> can lambdabot tell me the fixity of an operator?
17:00:34 <glguy> no, but GHCi can do that, too
17:00:55 <Sornaensis> lambdafan: :info at ghci prompt
17:01:01 <lambdafan> :)
17:01:10 <mniip> Forkk, so, well, there's
17:01:26 <mniip> mp_limb_t mpn_add (mp_limb_t *rp, const mp_limb_t *s1p, mp_size_t s1n, const mp_limb_t *s2p, mp_size_t s2n)
17:01:34 <mniip> in gmp lowlevel functions
17:01:51 <Forkk> ok
17:02:00 <mniip> and then integer-gmp just foreign imports that, and passes the bytearrays as limb arrays
17:02:55 <mniip> you could convert it into an mpz_t in accordance with https://gmplib.org/manual/Integer-Internals.html
17:03:38 <EvanR> so a less pain in the ass way might be
17:04:01 <EvanR> render the integer as a CString, pass that through ffi, load the string into gmp on the other side
17:04:05 <EvanR> and vice versa
17:04:39 <Forkk> lol
17:05:04 <Forkk> I think that may work
17:05:33 <Forkk> I could just drop in a better replacment later if necessary
17:05:52 <mniip> I would recommend formatting them to hexadecimal and loading with 0x and base=0
17:05:56 <mniip> as a premature optimization
17:06:26 <Forkk> and in case gmp doesn't work this way I could use something else
17:06:31 <EvanR> "I would recommend... premature optimization" ;)
17:06:46 <Forkk> lol
17:06:55 <mniip> but divisions by 10
17:07:08 <EvanR> this is the simplest possible thing that will work
17:07:18 <EvanR> humongs love base 10
17:08:01 <Forkk> thanks for the suggestion
17:08:21 <mniip> "Conversions from binary to a power-of-2 radix use a simple and fast O(N) bit extraction algorithm."
17:09:06 <EvanR> honestly rendering as base 16 or base 10 is pretty much equal effort on the haskell side
17:09:44 <EvanR> :t showIntAtBase
17:09:46 <lambdabot> (Show a, Integral a) => a -> (Int -> Char) -> a -> ShowS
17:10:49 <EvanR> > showIntAtBase 16 intToDigit 1234
17:10:52 <lambdabot>  <[Char] -> [Char]>
17:11:06 <EvanR> > showIntAtBase 16 intToDigit 1234 ""
17:11:09 <lambdabot>  "4d2"
17:11:38 <mniip> foreign import ccall mpn_get_str "gmp.h mpn_get_str" :: CString -> CInt -> ByteArray# -> GmpSize#
17:12:00 <mniip> :p
17:12:55 <Forkk> {#call mpn_get_str#}
17:15:18 <Forkk> what is mpn, all I see in the docs is mpz
17:15:39 <mniip> https://gmplib.org/manual/Low_002dlevel-Functions.html
17:16:00 <Forkk> oh I see
17:31:11 <mniip> wait, is the (# State# a, b #) return convention the same as just 'b' ?
17:33:46 <hpc> i suggest reading the (non-haddock) comments around the definition of IO
17:34:26 <hpc> it touches a bit on that, and leads to an amusing conclusion (that is perhaps obvious in retrospect if you consider the existence of unsafePerformIO)
17:39:04 <mniip> hpc, which module is it defined in?
17:39:50 <mniip> ah GHC.Types
17:40:23 <mniip> hpc, there aren't many comments there
17:40:27 <mniip> nothing seems relevant
17:41:34 <Ptival> is there something like (<*>) for when the right thing has to be `pure`d?
17:42:00 <mniip> fmap?
17:42:05 <mniip> aka <$>
17:42:15 <mniip> oh the RIGHT thing
17:42:21 <mniip> <&>
17:43:27 <Ptival> mniip: where is that from?
17:43:31 <mniip> oops
17:43:38 <mniip> it's not defined in any common packages
17:43:49 <Ptival> I guess I can define it locally :)
17:43:50 <mniip> yeah you're out of luck
17:55:29 <Wizek> Hey, anyone knows why this throws an exception instead of returning Left? `parseTimeM True defaultTimeLocale "%Y" "a" $> either (show .> ("fail: "<>)) ((show :: UTCTime -> _) .> ("parse: "<>)) where ($>) = flip ($)`
17:56:46 <glguy> because fail for either doesn't return a Left
17:57:07 <glguy> and that function is unfortunately defined to use fail for errors
17:57:20 <Wizek> that does sound deeply unfortunate
17:57:30 <Wizek> how come?
17:57:49 <glguy> you'd have to ask the author
17:57:57 <hpc> mniip: er, forgot about https://downloads.haskell.org/~ghc/7.8.2/docs/html/users_guide/roles.html too
17:58:37 <mniip> hpc, ???
17:58:47 <hpc> and the docs for State#
17:59:24 <hpc> basically, State# a has no underlying representation
17:59:48 <hpc> and in the unboxed tuple, the whole representation is just b
17:59:49 <mniip> right
18:00:06 <hpc> for IO that means IO a has the same representation as a
18:00:12 <hpc> which means ghc haskell is impure
18:00:23 <hpc> which it must necessarily be in order to admit unsafePerformIO in the first place
18:00:37 <mniip> I was asking a fairly specific question about calling conventions
18:00:43 <mniip> not generic IO stuff
18:00:53 <hpc> ah nvm then
18:01:15 <mniip> just noticed that you can operate on (# State# a, b #) in ghci without object code
18:01:32 <mniip> which means that by the time it hits the codegen there is already no unbox tuple
18:03:28 <hpc> probably part of the magic of State#
18:08:35 <dolio> I don't think representing `IO a` the same way as `a` necessarily makes you impure. It's giving access to that representation that makes you impure.
18:12:40 <hpc> dolio: yeah, i was taking a bit of license there ;)
18:12:55 <hpc> it's a pretty neat thing to learn for the first time though
18:48:06 <doomlord> one thing that bugged me about haskell was the lack of 'dot' accessor syntax (dot is used for function composition?)  .. do they have an operator like that these days.   "object.field"   I seem to remember being told haskell concention is always to write expressions 'right to left' (e.g. $ operator) instead of 'left to right' (the threading macro in clojure)
18:48:40 <Koterpillar> there's & if you want it
18:48:59 <marchelzo> you mean like for accessing fields of records?
18:49:10 <Koterpillar> :t (&)
18:49:13 <lambdabot> a -> (a -> b) -> b
18:49:29 <marchelzo> you can use lens for that and then you can just use regular . to compose
18:49:46 <Koterpillar> so if you have data Data = { foo :: Int, bar :: String }, then this works: data & foo
18:49:55 <Koterpillar> and with lenses, data & foo.bar.baz
18:50:09 <Koterpillar> or even without lenses
18:50:35 <tibbe> I'm trying to use ConstraintKinds to alias a MonadReader: type EnvM m n = MonadReader (Env n) m
18:50:41 <tibbe> where Env is a concrete data type
18:50:50 <tibbe> but I get: Non type-variable argument in the constraint: MonadReader (Env n) m
18:50:58 <tibbe> why isn't this working? :)
18:52:54 <tibbe> I'm just trying to create a new, more specialized version of the MonadReader type class (i.e. with the environment fixed)
18:56:29 <robkennedy> @hoogle (b -> c -> t b c) -> (a -> Maybe b) -> (a -> Maybe c) -> (a -> Maybe (t b c))
18:56:32 <lambdabot> Control.Monad.HT liftJoin4 :: Monad m => (a -> b -> c -> d -> m e) -> m a -> m b -> m c -> m d -> m e
18:56:33 <lambdabot> Control.Concatenative biSpM :: Monad m => (a -> m c) -> (b -> m d) -> (c -> d -> m e) -> a -> b -> m e
18:56:33 <lambdabot> Control.Concatenative triM :: Monad m => (a -> m b) -> (a -> m c) -> (a -> m d) -> (b -> c -> d -> m e) -> a -> m e
18:57:12 <pikajude> robkennedy: try liftA2
18:57:25 <robkennedy> :t liftA2
18:57:27 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
18:57:40 <pikajude> > liftA2 (,) (Just 3) (just 4)
18:57:43 <lambdabot>  error:
18:57:43 <lambdabot>      • Variable not in scope: just :: Integer -> Maybe b
18:57:43 <lambdabot>      • Perhaps you meant data constructor ‘Just’ (imported from Data.Maybe)
18:57:43 <pikajude> > liftA2 (,) (Just 3) (Just 4)
18:57:45 <pikajude> whoops
18:57:47 <lambdabot>  Just (3,4)
18:59:14 <suica> is lpaste.net down? related to S3 issues?
18:59:24 <robkennedy> :t liftA2 (,) listToMaybe (\l -> if null l then Nothing else Just (sum l)) [1..5]
18:59:27 <lambdabot> (Num t, Enum t) => (Maybe t, Maybe t)
19:00:03 <robkennedy> pikajude: I'm hoping to join them
19:00:10 <threshold> I am learning about the fixed point of a functor, Fix, by reading http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
19:00:10 <pikajude> what's in them
19:01:08 <robkennedy> Well if I have two functions I'm hoping to get Nothing if failure happens in either. 
19:01:27 <threshold> Given data Toy b next = Output b next | Bell next | Done  and  data Fix f = Fix (f (Fix f))  What is going on here? Fix (Output 'A' (Fix Done)) :: Fix (Toy Char)  
19:05:09 <dfeuer> *headshake*. containers is full of unresolved GitHub issues, and I absolutely don't have time to work through most of them soon. (Which isn't to say I haven't been working on containers; just a lot of work all around.)
19:05:36 <hpc> threshold: when used with Fix, next = Fix (Toy b)
19:05:39 <hpc> so it's like writing
19:05:49 <hpc> data Toy b = Output b (Toy b) | Bell (Toy b) | Done
19:06:42 <hpc> to do it with Fix, you need to add the Fix data constructor in a few places
19:08:12 <hpc> threshold: how much have you done with fix at the value level?
19:08:34 <EvanR> i waiting for the article on "you could have invented free monad monad monad algebras"
19:08:53 <pikajude> the "you could have invented this" free monad
19:09:41 <hpc> i can't wait for the retrospective on haskell
19:09:48 <hpc> "'you could have invented lens' and other falsehoods"
19:10:33 <hpc> threshold: anyhoo, any understanding you are able to carry over from fix will also apply to Fix
19:10:36 <hpc> which can make it easier
19:12:02 <threshold> hpc: Today is the first day that I've heard of a fixed point, so I have very little experience with fix
19:15:05 <raynold> ahh it's a wonderful day
19:25:09 <threshold> Maybe a better question is how does fix work?
19:25:49 <threshold> @src fix
19:25:50 <lambdabot> fix f = let x = f x in x
19:29:54 <barrucadu> Perhaps a more readable definition if `fix f = f (fix f)`
19:29:56 <barrucadu> *is
19:30:46 <threshold> barrucadu: That is still mind boggling
19:31:04 <threshold> How do you use it?
19:32:32 <threshold> https://en.wikipedia.org/wiki/Fixed_point_(mathematics) should be useful in understanding?
19:33:33 <barrucadu> `fix` lets you do recursion without giving a name to your recursive function
19:33:54 <barrucadu> > fix (\go x -> if x == 0 then 1 else x * go (x-1)) 5 -- factorial
19:33:56 <lambdabot>  120
19:39:47 <nshepperd> threshold: fix returns the 'least' fixed point of the function, in the domain theory sense
19:40:44 <Squarism> does it sound sane to "send a channel over a channel" ? =D
19:41:38 <benzrf> threshold: `fix f' is a fixpoint of f in a very boring way, by definition
19:42:01 <benzrf> threshold: `fix f' expands to `f (fix f)' by definition, so naturally `fix f = f (fix f)'
19:42:12 <benzrf> then `fix f' is a fixpoint, in a very cheating-y way
19:42:47 <benzrf> intuitively, if you have an infinitely deeply nested list of applications of f, like `f (f (f (f (f ...))))', then adding another f won't hurt
19:43:01 <nshepperd> threshold: I guess http://stackoverflow.com/a/4787577 is the thing to read
19:43:14 <benzrf> but note that this is only useful if you have lazy evaluation - with strict evaluation, this is always an infinite loop
19:43:36 <benzrf> `fix f' is quite often still an infinite loop in haskell, but not always:
19:43:38 <benzrf> > fix (+1)
19:43:45 <lambdabot>  mueval-core: Time limit exceeded
19:43:46 <benzrf> > fix (1:)
19:43:50 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
19:44:09 <benzrf> `1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + ...' is undefined, of course, but `1:1:1:1:1:1:1:...' makes sense!
19:44:17 <pacak> > fix error
19:44:20 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
19:44:25 <benzrf> :}
19:44:30 <pacak> Exceptions all the way down!
19:44:49 <benzrf> @let me = const (text "Some things are unfixable.")
19:44:52 <lambdabot>  Defined.
19:44:53 <benzrf> > fix me
19:44:57 <lambdabot>  Some things are unfixable.
19:45:08 <nshepperd> :{
19:51:01 <MarcelineVQ> </3
20:11:28 <Squarism> Any threading person that could do a sanity check : ok to "send a channel over a channel"?
20:11:58 <monochrom> Yes. The pi calculus does that all the time.
20:16:51 <orion> :t fix
20:16:54 <lambdabot> (a -> a) -> a
20:17:41 <nshepperd> Squarism: that seems perfectly fine to me
20:18:15 <Squarism> nshepperd, thanks
20:18:16 <nshepperd> you're just putting an mvar in an mvar, which channel already does
20:21:08 <Koterpillar> what's that computable float type that makes it possible to fix sin?
20:21:27 <monochrom> Is it CReal?
20:22:35 <Koterpillar> fix sin :: CReal
20:22:39 <Koterpillar> > fix sin :: CReal
20:22:45 <lambdabot>  mueval-core: Time limit exceeded
20:24:01 <Koterpillar> > fix (\x -> x / 100) :: CReal
20:24:07 <lambdabot>  mueval-core: Time limit exceeded
20:24:12 <Koterpillar> how come this doesn't converge either?
20:42:09 <nshepperd> for those to work you'd need sin undefined ≠ undefined
20:42:57 <threshold> Koterpillar: What do you mean by converge?
20:43:00 <nshepperd> it would have to be some weird representation with lazy continued fractions or something o_O
20:43:52 <threshold> nshepperd: Thank you for the Stack Overflow link. I will read through it.
20:45:34 <davean> go #ghc
20:46:34 <Koterpillar> nshepperd: well, sin undefined <= 1
20:57:26 <nshepperd> fix (\x -> x / 100) would work in a decimal bounded setting (0 < x < 1), then you could do x/100 = 0:0:x
20:57:29 <Cale> Koterpillar: But then the next step gets you, you would presumably want to know that sin (sin undefined) <= sin 1, however, to get that, you need to know something more subtle about the sine function, such as the fact that it's monotonic on [0,1]
21:08:38 <Koterpillar> Cale: if I (somehow) compute sine starting from the most significant digit, then since head (sin undefined) == 0, that gives me a _better_ upper bound on sin (sin undefined)
21:10:04 <Cale> How though?
21:10:18 <Cale> I know that by using arbitrary amounts of analysis you can get that
21:12:33 <Cale> Just knowing that sin (undefined) < 1 doesn't tell you much about sin (sin undefined) unless you know something about sine itself, such as monotonicity in an interval.
21:13:09 <Cale> In particular, without something special, you're not going to obtain sin (sin undefined) < sin 1 like you want
21:14:36 <threshold> Do the integers for a partially ordered set with respect to the order ≤ ?
21:14:40 <threshold> form
21:17:52 <Cale> yes
21:18:05 <Cale> (moreover, they're totally ordered)
21:19:05 <pikajude> duuude
21:23:34 <nshepperd> I think you need to take advantage of one the trigonometric identities involving sin to do this. and to be able to express such identity as a constructor of your real number type
21:24:02 <nshepperd> it seems like it might be possible, but I don't know how
21:25:12 <Cale> Yeah, maybe if you contrived your representation of the reals around the ability to do this :)
21:26:05 <Cale> (i.e. cheating by building in sine-related stuff)
21:27:49 <nshepperd> well, not quite cheating
21:28:02 <nshepperd> I mean, putting in a Sin constructor wouldn't help at all
21:28:52 <nshepperd> I was thinking of continued fractions or something but I don't really know
21:28:56 <Cale> It might help :)
21:29:18 <Cale> (though it would make the implementation of all your operations really annoying)
21:30:27 <nshepperd> show x@(Sin y) | accursedUnutterablePtrEquality x y = "0" -- :)
21:32:35 <Koterpillar> a bounded constructor will help, probably
21:33:16 <Koterpillar> data BReal = ExactValue Float | Between Float Float BReal
21:34:14 <Younder> Quirky ADA :)
21:35:02 <nshepperd> hmm.... a sequence of decreasing bounds, perhaps
21:35:07 <nshepperd> this sounds familiar
21:36:27 <Koterpillar> I thought this was how CReal was implemented anyway?
21:37:09 <Cale> iirc, CReal is implemented as a sequence of rational numbers such that the nth is within 1/2^n of the limit.
21:37:39 <nshepperd> sin x 0 = Between (-1) 1; sin x n = Between { some function of (x (n-1)) }
21:37:39 <Cale> So that effectively gives you a sequence of intervals of decreasing size
21:38:15 <Cale> nshepperd: that first bit is a type error... ;)
21:38:41 <Younder> How are the size and computational properties of CReal?
21:39:06 <Cale> It's fairly impractical
21:39:14 <Cale> It's okay for some things
21:39:18 <nshepperd> Cale: nah, I'm talking about numbers that are functions now
21:39:27 <nshepperd> the Int -> a kind of sequence
21:39:57 <Cale> > sum [1..1000] :: CReal
21:40:04 <lambdabot>  mueval-core: Time limit exceeded
21:40:11 <Cale> ^^ but it's pretty bad for general computation
21:43:54 <Cale> > exp (pi * sqrt 163) :: CReal
21:43:57 <lambdabot>  262537412640768743.9999999999992500725971981856888793538563
21:44:08 <Cale> ^^ not that bad so long as the expression is simple
21:44:55 <nshepperd> so in conclusion, I feel like maybe CReal or something like it should be able to do this, but I don't really understand its implementation
21:45:20 <nshepperd> unfortunately sin ⊥ is actually ⊥ in CReal though
21:45:35 <Cale> Well, yeah
21:46:29 <jle`> is there any nice way to write '(,) a b
21:46:33 <jle`> the type
21:46:50 <nshepperd> even though I don't really see why because it's a function inside?
21:47:03 <nshepperd> like, it's not even const ⊥
21:47:40 <nshepperd> I guess probably performance reasons outweigh being able to do tricks like fix sin
21:48:23 <Younder> Well are you familiar with Pythons implementation of numbers in it's original form. Incredibly inefficient. Feels something like that. So ADA using Python implementation methods. Neither fish nor foul!
21:50:21 <Cale> Younder: It's almost surely more inefficient than that (but also does more)
21:55:41 <sjakobi> Quick heads-up that Hackage has lost a few packages: https://github.com/haskell/hackage-server/issues/573
21:57:07 <sjakobi> stack users might run into a strange issue with nightly-2017-03-01 which contains one or more of these lost packages.
22:00:45 <kadoban> Uh oh
22:30:35 <hrumph> hi
22:33:10 <hrumph> hi
22:33:25 <hrumph> i'm looking for something you might call a "degenerate monad" or something like that
22:33:28 <hrumph> http://lpaste.net/353088
22:33:37 <hrumph> is there a standard designation for this?
22:46:08 <Ptival> what indentation mode do emacs users use? I'm getting frustrated by the lack of support of standalone deriving in the one I have now
22:50:58 <osa1> my indentation script just follows the line before on enter, it works great.
22:52:45 <Ptival> nvm, I found out https://github.com/haskell/haskell-mode/pull/1276 it was recently fixed
22:53:16 <cocreature> hrumph: I’m not aware of any library that provides this
23:49:30 <tsahyt> @hoogle (f a -> f b) -> f (m a) -> f (m b)
23:49:33 <lambdabot> Data.Tuple.HT mapFst3 :: (a -> d) -> (a, b, c) -> (d, b, c)
23:49:33 <lambdabot> Data.Tuple.Lazy mapFst3 :: (a -> d) -> (a, b, c) -> (d, b, c)
23:49:33 <lambdabot> Data.Tuple.Strict mapFst3 :: (a -> d) -> (a, b, c) -> (d, b, c)
23:53:10 <c_wraith> tsahyt: Can do it if both f and m are Traversable - not sure about anything weaker.
23:53:55 <tsahyt> m is IO, f is not traversable in practice. there is an instance but it's not feasible to even have it because of computational constraints
23:54:28 <tsahyt> maybe I can write a function that does it in that special case though
