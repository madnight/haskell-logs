00:07:30 <ongy> is parsec a good choice to build a config parser?
00:14:05 <ezyang> ongy: Yes. 
00:14:45 <ongy> ok, then I will have to wrap my head around it
00:18:44 <thunderrd> slyfox: thanks for all the work, everything successfully built now
00:23:03 <ongy> what's the most recent idiot-friendly parsec tutorial? The website seems to be down, the archive is rather outdated
00:24:55 <ertes> ongy: you could also just use a common format and not bother with writing a parser
00:25:01 <ertes> @package yaml
00:25:01 <lambdabot> http://hackage.haskell.org/package/yaml
00:27:00 <ongy> my current plan is to have a small language for specifying match-rules either way, so I will need a parser either way. Also yuck, yaml
00:28:20 <louispan> what are some of the bad extensions?
00:34:11 <osa1> RecordWildCards :-)
00:47:45 <ezyang> Public service announcement: do NOT use regex-posix (and transitively, regex-compat) on Windows, it's buggy as hell 
00:50:07 <clinton> I'm using rewrite rules, and I'm getting this type of error: "add (C l) to the context of the RULE...". Where do I add a signature, including class constraint, into a rule (I can't find an example like it in the docs)
00:50:37 <clinton> as in "Possible fix: add (C l) to the context of the RULE..." is the error I'm getting
00:51:12 <pavonia> ezyang: I'm using both on Windows, could you elaborate?
00:52:18 <ezyang> pavonia: Look at this: http://lpaste.net/352641 
00:53:01 <ezyang> Also look at http://stackoverflow.com/questions/39047317/simple-regular-expression-substitution-crashes-on-windows-using-regex-compat/39101634#39101634 
00:53:51 <ezyang> this is with regex-posix-0.95.2 
00:55:26 <`Guest05> Hackage needs comments to packages
00:56:50 <ezyang> bleh, time to find a new regex library 
00:56:51 <pavonia> ezyang: My version is regex-compat-0.93.1 and it returns the correct result "<ROOT>\\xxx\\yyy\\zzz"
00:57:25 <ezyang> pavonia: Interesting. Could be a regression in the newer version! 
00:57:51 <ezyang> oh wait, don't give me your compat version, give me your regex-posix version 
00:58:09 <pavonia> regex-posix-0.94.4
00:58:32 <ezyang> ok, my comment stands ;) 
00:58:39 <ezyang> btw, this is 64-bit windows 
01:01:08 <cdornan>  ezyang: realised we were in this swamp a while back and switched to regex-tufa
01:01:31 <cdornan> Might also want. To look at regex
01:01:55 <ezyang> cdornan: Thanks 
01:02:05 <ezyang> I find the regex-* family of packages to have... really hard to understand APIs 
01:02:20 <ezyang> like, how do I do a search-replace with the non compat interface?! 
01:02:33 <cdornan> Actually you have a great opportunity to shape regex as it is about to hit RFC
01:03:19 <ezyang> heh 
01:03:39 <cdornan> ezyang: regex intends to capture goodness of regex-base with a nicer API
01:04:03 <ezyang> So many deps :( 
01:04:18 <cdornan> GOING
01:04:30 <cdornan> going to split the package
01:04:33 <ezyang> good! :) 
01:04:59 <cdornan> Just about to upload a version that strips library deeps to minimum
01:05:47 <ezyang> I wonder what the canonically used regex libraries in yesod/stack-world are 
01:06:19 <pavonia> ezyang: Btw, the linked SX program works for me too
01:06:58 <cdornan> I thing they are based on regex-base, regex-tdfa, regex-pcre
01:07:11 <ezyang> pavonia: Still with the older version? 
01:07:20 <pavonia> Yes
01:07:33 <ezyang> pavonia: If you're curious, try it with the new version :) 
01:09:23 <ezyang> wait, I'm reading a blog post that claims the new-style regex-* apis (including regex-pcre/regex-tdfa) doesn't support substitutions at all 
01:09:28 <ezyang> is this actually ture 
01:10:01 <ezyang> well, there seems to be a regex-compat-tdfa to solve this 
01:10:37 <cdornan> @ezyang yes -- a major motivation for regex
01:10:37 <lambdabot> Unknown command, try @list
01:11:04 <ezyang> cdornan: :) Did you also look at the other regex libraries out there before deciding to build one? 
01:11:23 <cdornan> Yes indeed
01:11:36 <ezyang> what did you discover? 
01:13:43 <cdornan> Serious stacks are rightly based on regex-{base,pcre,tufa} but as you say the API is not easy to use and missing stuff
01:15:59 <ezyang> btw, does your library have escaping fns? 
01:16:01 <cdornan> I have tried to add every thing that the other packages were providing -- and then some -- but build it strictly on top of the regex-base framework
01:16:14 * ezyang nods 
01:16:22 <cdornan> Escaping fns?
01:16:45 <ezyang> Takingh a string and escaping it so you can include it in a regex 
01:17:04 <cdornan> Not yet!
01:17:49 <cdornan> I do have regex analysis under the hood -- should be easy to extend it for this
01:17:57 <ezyang> good! 
01:18:30 <cdornan> I will do this but feel free to take credit by raising an issue
01:19:52 <cdornan> (can't do it immediately -- under the cosh -- but happy to put it into the roadmap)
01:20:08 <ezyang> np 
01:20:34 <ezyang> Cabal isn't going to grow a dep on regex in the near future, anyhoo 
01:36:43 <pepeiborra> I have a Lens question but Haskell-lens is not being very responsive. Given an IndexedLens, what is the best way to produce a Getter for the index ?
01:41:50 <merijn> pepeiborra: I think a lot of haskell-lens peeps tend to be in the US timezone, so most of them are probably asleep atm
01:44:35 <ongy> in parsec many1 should run a parser 2 to N times, returning N-1 itmes, when the Nth try to parse fails, right?
01:45:11 <merijn> ongy: Yes
01:46:13 <MarcelineVQ> why 2 to n?
01:48:24 <ongy> because it's a special case if when first one fails
01:49:33 <merijn> Well, I suppose it could run only once and abort immediately
01:51:11 <tsahyt> :r
01:51:21 <tsahyt> ... I should make my IRC client block that
01:51:27 <tsahyt> it happens way too often. sorry.
01:51:59 <cocreature> ongy: also note that the Nth try should fail but _not_ consume any input while doing so
01:52:34 <ongy> I just noticed that. Explains why it didn't behave like I thougt it should
01:52:49 <cocreature> that’s why you often see many (try …)
01:56:34 <ongy> I just slightly changed the parser to make up for it (whitspaces at the end, not front)
01:57:03 <cocreature> if you can avoaid try that’s definitely the better solution :)
02:01:05 <ezyang> see also http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/ ;) 
02:01:39 <merijn> ezyang: That blog post has saved me so much typing in here over there past years :p
02:03:26 <cdornan> ezyang: absolutely -- at the very least a stable 1.x version will be needed for that
02:17:16 <tsahyt> is there any resource that can help me understand loop from ArrowLoop better?
02:17:51 <tsahyt> I've got a type here for which I think an instance should be possible but just letting the types guide the implementation wasn't exactly fruitful so far
02:18:23 <merijn> tsahyt: Think of the 'd' type in the tuple as a local State
02:19:59 <tsahyt> I'll give it another shot later on. first I need to check the laws on some other instances I wrote. having a Monad instance for waveforms seems weird somehow.
02:22:35 <tsahyt> wasn't there some package that provided quickcheck properties for common typeclass laws?
02:22:46 <tsahyt> it would be easier to use that as a sanity check before I delve into equational reasoning I think
02:22:58 <MarcelineVQ> checkers
02:23:57 <tsahyt> thanks!
02:49:45 <Cooler> what does this mean? Surprise! You can bind infix names for function arguments.
02:49:58 <`Guest05> flip3
02:50:32 <Cooler> does that mean <> can be bound to any function at runtime? \ (<>) a b c ->
02:50:32 <Cooler> a <> (b <> c) == (a <> b) <> c
02:55:01 <merijn> Cooler: yeah
02:55:14 <infinity0_> is there a function to turn a Lens' s a into a Lens' (s, r) (a, r) ?
02:55:21 <merijn> > let a <> b = a+b * a+b in 3 <> 4
02:55:26 <lambdabot>  19
02:55:31 <tsahyt> > let 2 + 2 = 5 in 2 + 2
02:55:31 <infinity0_> ofc i could write it myself but, would be good if there was a standard one
02:55:34 <lambdabot>  5
02:55:34 <merijn> wut
02:55:39 <tsahyt> evil but legal
02:55:51 <tsahyt> tbf the compiler will shout warnings at you for that
02:55:52 <merijn> I'm pretty sure 7*7 is not 19...
02:55:54 <merijn> > let a <> b = a+b * a+b in 3 <> 4
02:55:57 <lambdabot>  19
02:56:00 <merijn> @undefine
02:56:01 <lambdabot> Undefined.
02:56:02 <merijn> > let a <> b = a+b * a+b in 3 <> 4
02:56:05 <lambdabot>  19
02:56:10 <merijn> oh
02:56:14 <merijn> I'm an idiot >.>
02:56:38 <merijn> tsahyt: Only with -Wall or the shadowing warning
02:56:46 <merijn> And you can just define a non-shadowing operator instead
02:56:50 <quchen> > let 7*7 = 19 in 7*7 
02:56:52 <lambdabot>  19
02:57:00 <tsahyt> merijn: but defining a non-shadowing operator isn't as evil
02:57:26 <tsahyt> checkers really needs category laws too
02:57:38 <merijn> > let x ☃ y = (x+y) * (x+y) in 3 ☃ 4
02:57:40 <lambdabot>  49
02:57:41 <tsahyt> but at least my other instances check out, and the category laws are trivial to prove in my case
02:58:03 <merijn> actually, I suppose this showing the wrong thing
02:58:15 <merijn> This is defining an infix function, not an infix argument
02:58:17 <tsahyt> I need an uppercase tortilla unicode character, so I can finally reimplement that paper
02:58:36 <merijn> > let foo (+) x y = x + y in foo (*) 3 4
02:58:38 <lambdabot>  12
02:58:41 <merijn> > let foo (+) x y = x + y in foo (+) 3 4
02:58:44 <lambdabot>  7
02:58:47 <merijn> > let foo (+) x y = x + y in foo (-) 3 4
02:58:50 <lambdabot>  -1
02:58:57 <merijn> I suppose that was the real original question
02:59:11 <tsahyt> this process of just randomly walking through the design space that I'm in is really strange at times. so I have a handful of law abiding instances for my types and yet have no idea of their semantics
02:59:31 <tsahyt> e.g. the monad instance for my waves, or the applicative instance for arrows between waves
03:19:00 <dbeacham> has anyone got any particularly good examples of rest api bindings in haskell?
03:20:13 <tsahyt> I'm rather fond of using servant-client for that. The servant-github package does it like that for example.
03:21:57 <infinity0_> is there a function to turn a Lens' s a into a Lens' (s, r) (a, r) ?
03:22:30 <infinity0_> i don't think any composition involving _1 will suffice, because it can't touch the second element, but Lens' (s, r) (a, r) could touch the second element
03:22:54 <infinity0_> (i could ofc write my own, but wondering if there was a standard one to do that)
03:24:27 <phadej> infinity0_: there is
03:24:29 <Gurkenglas> :t alongside
03:24:30 <tsahyt> is the reader monad the only monad that can be defined over ((->) r) for some fixed r?
03:24:30 <phadej> :t beside id id
03:24:31 <lambdabot> LensLike (Control.Lens.Internal.Getter.AlongsideLeft f b') s t a b -> LensLike (Control.Lens.Internal.Getter.AlongsideRight f t) s' t' a' b' -> LensLike f (s, s') (t, t') (a, a') (b, b')
03:24:32 <lambdabot> (Data.Bitraversable.Bitraversable r, Data.Profunctor.Rep.Representable q, Applicative (Data.Profunctor.Rep.Rep q), Applicative f) => Optical q q f (r s' s') (r t' t') s' t'
03:24:40 <phadej> ah, alongside too
03:24:47 <phadej> can't ever remember which is which
03:25:01 <infinity0_> phadej, Gurkenglas: nice, thanks!
03:25:25 <tsahyt> or can some specific choices for r lead to different semantics?
03:25:36 <tsahyt> open up the possibility for different semantics I should say
03:26:53 <Gurkenglas> tsahyt, I think this is related to that question on whether there are coapplicatives
03:27:22 <tsahyt> wouldn't that be Divisibles or whatever they were called?
03:28:58 <Gurkenglas> (you mean comonoids? coapplicatives are to comonoids as applicatives to monoids so sure)
03:29:20 <tsahyt> oh I was thinking of contravariant functors and their applicative counterpart
03:29:43 <phadej> thallada: with Natural -> a you can have ZipList like monad (which isn't, cause list can be finite), or [a] like monad
03:30:05 <phadej> the ZipList is like reader
03:31:27 <phadej> relates to the fact, that for Vec i a, one can define different (indexed) monads depending on which monoid operations you pick for `i`
03:31:29 <Gurkenglas> tsahyt, you can think of it as "instance Comonoid r => Monad ((->) r) where ..." with the same instance as usual, but r provides the "r -> ()" to get rid of the r in for the implementation of return and the "r -> (r, r)" to be able to use the r twice for the implementation of join
03:31:52 <Gurkenglas> *but Comonoid r provides
03:38:56 <tsahyt> right. now I just need to figure out what a Comonoid is
03:44:43 <ongy> does the Text.Parser.Expr buildExpressionParser support parens in the expresion? If not, what's the easiest way to do that?
03:54:41 <mutsig_> ?src mapM
03:54:41 <lambdabot> mapM f as = sequence (map f as)
03:55:35 <quchen> Does an allocation always clean the pipeline/miss the cache, or is that just a very likely side effect of it?
03:56:06 <quchen> I’m trying to understand why GHC schedules its yields to happen only on allocation
03:57:33 <alexbiehl> quchen: can you elaborate? 
03:58:07 <alexbiehl> I often look at cmm/asm code and it seems allocation really is just a bump of some register, no calls to rts involved
03:58:28 <alexbiehl> so I don't see how it can sync on allocation
03:59:07 <quchen> alexbiehl: GHC allows context switches after heap allocations, and I’m wondering why exactly
03:59:19 <merijn> quchen: Well, why not?
03:59:23 <ongy> if you are looking at asm, that's probably the stack allocation. Heap allocation has to be more than that
03:59:27 <quchen> merijn: Why not elsewhere?
03:59:47 <quchen> Eh, »GHC *only* allows context switches after heap allocs«
03:59:48 <merijn> quchen: Because then you'd have to change the code generation everywhere to check whether to yield
04:00:13 <merijn> quchen: allocation already interrupts the flow of code, so easy to sneak a schedule check in there
04:00:18 <alexbiehl> maybe its more concrete: not only heap allocation but allocation of thunk maybe? 
04:00:27 <merijn> alexbiehl: thunks *are* heap allocations
04:00:32 <quchen> merijn: Why does allocation interrupt the code flow?
04:00:42 <alexbiehl> Iam pretty sure it does not
04:00:51 <alexbiehl> Entering a thunk is
04:01:17 <merijn> quchen: Lemme rephrase, when else would you check whether to yield or not? Every instruction? Require hardware interrupt?
04:01:28 <quchen> Yes, for example.
04:01:42 <quchen> Every 10 clock cycles. Every 10 minutes. Every time we enter a case expression.
04:01:53 <quchen> Why was after heap allocs chosen specifically?
04:01:57 <merijn> quchen: Hardware interrupt is a messy thing, since you can't reliably cause them
04:02:13 <merijn> quchen: You'd have to rely on posix signals (which isn't portable) and they are costly
04:02:23 <merijn> quchen: They effectively require a context switch to yield, then
04:02:30 <ongy> don't we have the "every X-time" with the SIGVALARM? I thought that's what it's used for
04:02:59 <merijn> quchen: Allocations happen frequently enough to allow somehwat preemptive scheduling, but infrequently enough to not interfere with performance significantly
04:03:12 <quchen> alexbiehl: The heap contains mostly thunks
04:03:28 <merijn> ongy: What about systems without SIGVALARM, not to mention the fact that signal interrupts aren't very fast
04:03:38 <merijn> So using signals for frequent interrupts will slow you down
04:03:46 <quchen> merijn: So it’s just a »works« solution? That sounds a bit too simple
04:04:02 <merijn> quchen: Why?
04:04:02 <alexbiehl> yes: but if you look closely on cmm code you can see that allocation itself is just a bump of the heap pointer, no call to rts to preempt or something
04:04:04 <exio4> sounds something like "best compromise we could find"  :P
04:04:32 <merijn> quchen: I'm pretty sure that most schemes you listed will end up being significantly slower, tbh
04:04:36 <quchen> merijn: I thought it had something to do with the way CPUs work, which makes it a particularly efficient arbitrary choice.
04:04:56 <quchen> Such as »we have a cache miss already, so we might as well miss it twice« or something like that.
04:05:04 <merijn> quchen: Well, it certainly is when compared to interrupts for scheduling
04:05:09 <quchen> Hence me asking what an allocation entails that makes it such a good place to yield.
04:05:25 <merijn> quchen: And if not interrupts, you're stuck doing checks in places that happen reliably enough to not hog the CPU
04:05:56 <quchen> Hm. I guess the reliability is key, and the lack of alternatives.
04:06:10 <quchen> But still, I’m wondering whether there’s something deeper :-s
04:06:28 <merijn> quchen: Not really, afaict from the GHC/RTS documentation/papers I've read
04:06:31 <quchen> But the non-working alternatives are pretty helpful to know about.
04:06:50 <ongy> merijn: there's a fallback of course. But I'm pretty sure the default setting is with SIGVALARM and that quite often. I'd have to check the -V option to the RTS
04:06:50 <quchen> merijn: Do you know one that talks about this issue?
04:07:16 <exio4> it also allows to tight loops to be heavily optimized (at the expense of not having context switches inside it)
04:07:28 <merijn> ongy: It uses SIGVALARM for threadDelay (i.e. sleep), not for yielding running threads
04:08:59 <ongy> merijn: then why does it need so many of them? IIRC that's a recouring timer with a fixed intervall
04:09:24 <merijn> ongy: I don't remember seeing that, but I don't recall too much detail
04:10:35 <bennofs> ongy: perhaps it's for idle GC?
04:10:52 <bennofs> but that would be too often as well i think
04:13:25 <ongy> https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/runtime-control.html -V here. Probably the timer is used for counting if a context change is in order, not triggering it then
04:16:10 <alexbiehl> Interesting: http://ezyang.com/jfp-ghc-rts-draft.pdf p. 9 footnote 7. GHC yields threads at heap checks. The timer sets the heap limit to 0 which triggers a "false heap overflow"
04:18:07 <alexbiehl> ezyang mentions that heap checks are nice places for context switches because we save the execution context anyways in case garbage collection happens
04:27:18 <quchen> ezyang should »complete, flesh out, rewrite« all the coloured parts of that paper, it’s awesome :-)
04:34:34 <Cooler> why can't non empty be  data NonEmpty a = a : [a] deriving (Eq, Ord, Show)
04:34:37 <Cooler> ?
04:34:46 <Cooler> why does it need :|
04:34:47 <Cooler> ?
04:35:00 <bennofs> Cooler: because : is already used for List?
04:35:10 <Cooler> oh
04:35:40 <bennofs> also I don't think you can use : as a constructor in your own code, i believe it is built in 
04:36:11 <Cooler> newtype NonEmpty a = NonEmpty (a : [a])
04:43:57 <kgadek> Cooler: your example doesn't work even with DataKinds & TypeOperators. The reason: "Expected a type, but ‘a : [a]’ has kind ‘[*]’"
04:44:13 <quchen> merijn: Ah, I found something in ezyang’s preprint. When allocation is supposed to happen, we have to do a heap check (»enough mem? else GC«). GC should only happen when we’re in a »clean« execution state. And since we’ve cleaned up already, we might as well handle the context switching business at the same time.
04:44:13 <kgadek> i.e. you're creating a list of kinds there
04:45:34 <kgadek> Cooler: in other words — to state that you have at least one element, you need a different mechanism. The one that will not make you a [KIND] but rather a KIND
04:45:57 <kgadek> (n.b. I'm using KIND and * interchangeably)
04:46:46 <Cooler> kgadek, what does [*] mean? a list of possibly different types?
04:47:10 <kgadek> let's call it [KIND], will be easier a bit to understand
04:47:37 <Cooler> [a] is of kind * right?
04:47:43 <kgadek> yes
04:47:56 <Cooler> so a : [a] is also kind *
04:47:57 <kgadek> when you have any type that you can construct, it's type is KIND 
04:48:10 <kgadek> when you have a type constructor
04:48:12 <kgadek> like Functor
04:48:22 <kgadek> it's kind is KIND -> KIND 
04:48:29 <kgadek> (i.e. * -> *)
04:48:30 <kgadek> that means
04:48:38 <Cooler> yes i know
04:48:38 <kgadek> that given a KIND, it will produce a KIND
04:48:40 <kgadek> so
04:48:46 <kgadek> we're talking about [*]
04:48:59 <kgadek> [KIND]
04:49:00 <kgadek> I know no uses of it right now
04:49:05 <Cooler> just to be clear a : [a] == [a] ?
04:49:27 <kgadek> hmm, rather [a,a] as to how `:` works
04:49:33 <kgadek> but not sure now
04:49:36 <Cooler> or well
04:49:41 <Cooler> a : [a] :: a
04:49:45 <Cooler> a : [a] :: [a]
04:50:14 <kgadek> wait
04:50:15 <Nik05> 13:48 < Cooler> just to be clear a : [a] == [a] ? -- What about 1 : [2] == [2]?
04:50:20 <kgadek> :k Int : '[Int]
04:50:21 <lambdabot> [*]
04:50:33 <Cooler> no a doesn't represent a value
04:50:46 <Cooler> t : [t] :: [t] is perhaps more clear
04:50:59 <Cooler> t represents a type not a value like 2
04:51:31 <Nik05> Notation is imporant here :P
04:52:19 <Nik05> But well yes a : [a] :: [a], per definition of List
04:52:39 <Cooler> ok and [a] is of kind *?
04:52:39 <kgadek> :kind! Int : '[Int]
04:52:51 <kgadek> oh, lambdabot doesn't understand this? :<
04:52:56 <kgadek> λ> :kind! Int : '[Int]
04:52:56 <kgadek> Int : '[Int] :: [*]
04:52:56 <kgadek> = '[Int, Int]
04:53:24 <Cooler> [a] is of kind * not [*] ?
04:54:20 <Nik05> Cooler [Int] :: *
04:54:21 <kgadek> it's: '[a] :: [*]
04:54:31 <kgadek> wait, Im confused right now
04:54:52 <kgadek> Nik05: you sure? GHCi tells me otherwise
04:55:05 <kgadek> ohhhhhh
04:55:07 <Cooler> ok now i am confused is [a] :: * -> * ?
04:55:11 <kgadek> I see
04:55:12 <Nik05> kgadek a is a kind variable
04:55:14 <kgadek> I'm using '[]
04:55:15 <kgadek> and not []
04:55:20 <kgadek> THIS is the difference
04:55:25 <Nik05> [] :: * -> *
04:55:34 <Cooler> what about [a] ?
04:55:40 <kgadek> :k []
04:55:41 <lambdabot> * -> *
04:55:43 <kgadek> :k '[]
04:55:45 <Cooler> :k [a]
04:55:45 <lambdabot> [k]
04:55:47 <lambdabot> error: Not in scope: type variable ‘a’
04:55:50 <superherointj> Is generics the same as parametric polymorphism?
04:55:53 <Nik05> What is '[]?
04:56:04 <kgadek> a kind constructor
04:56:17 <Cooler> a type constructor?
04:56:34 <Cooler> a kind constructor? that would be one more level up
04:56:36 <Nik05> oh, oke
04:56:45 <kgadek> it works on both levels to my knowledge
04:56:56 <kgadek> (i.e. it's both kind and type constructor)
04:57:20 <kgadek> in other words:
04:57:24 <hpc> or to be slightly more precise, there is a kind constructor and a type constructor that both have that name
04:57:37 <hpc> (they're still in different namespaces, ish)
04:57:45 <kgadek> [Int] is a type representing a list of types. It's * because it can be constructed
04:57:49 <Nik05> Why would you want to have a list of kinds?
04:58:01 <kgadek> '[Int] is not a type, it's a [*]. It can't be constructed
04:58:11 <kgadek> for example in type level programming
04:58:25 <hpc> Nik05: it's a list of types
04:58:27 <kgadek> like: write a set operations on type level
04:58:40 <hpc> Nik05: but you'd want either of them in order to do programming in the type system
04:58:46 <Cooler> ok but what is [a]?
04:59:08 <Cooler> its of kind *\
04:59:18 <Cooler> its of kind * assuming a is a concrete type
04:59:36 <kgadek> remind me, `a` is a type or kind?
04:59:37 <Cooler> so a : [a] :: [a] which is of kind *
05:00:25 <Cooler> so <Cooler> newtype NonEmpty a = NonEmpty (a : [a])
05:00:44 <dramforever> superherointj: Short answer: no
05:01:02 <quchen> No?
05:01:12 <hpc> java generics?
05:01:28 <quchen> Java generics are a horribly broken version of parametric polymorphism, if »generics« refers to that.
05:01:43 <superherointj> For example. People say, Go doesn´t have .map/reduce because it doesnt support generics.
05:01:49 <hpc> there are deliberate similarities though (java generics were designed by one of the simons)
05:02:07 <quchen> hpc: Simons? I think you mean Wadler
05:02:09 <dramforever> Generally, if you ask questions like 'Is <foo> the same as <bar>?' where <foo> is a Haskell concept and <bar> is a concept from another more 'mainstream' programming language, the answer is almost alwaysNo.
05:02:32 <hpc> quchen: ah, misremembered
05:02:54 <superherointj> Is Haskell wrong on something?
05:02:55 <hpc> go doesn't support polymorphism in any way at all
05:02:56 <kgadek> hpc: "In 1998, Gilad Bracha, Martin Odersky, David Stoutamire and Philip Wadler created Generic Java"
05:02:59 <quchen> Wadler and Odersky if I remember correctly
05:03:14 <hpc> so not only can you not write map or reduce, you can't even write sort
05:04:06 <kgadek> hpc: well, golang is happy to provide `sort` (even in a quite nice way. Surely not as good as in Haskell, but "okayish")
05:04:11 <dramforever> superherointj: What do you mean?
05:04:35 <kgadek> superherointj: there are many wrongs in Haskell, depends on who you ask :)
05:04:37 <tsahyt> is fmap over something that is an arrow always the same as post-composition with a pure function?
05:04:41 <dramforever> If you think different == wrong, then nope
05:04:49 <tsahyt> i.e. is fmap == ^<<
05:05:06 <hpc> :t (^<<)
05:05:08 <lambdabot> Arrow a => (c -> d) -> a b c -> a b d
05:05:10 <superherointj> I hear a lot of good things on Haskell. And how many other languages are messed up. So I was wondering what about Haskell that might not have been well thought out.
05:05:21 <dramforever> tsahyt: Yes, you can verify the functor laws
05:05:26 <hpc> superherointj: n+k patterns were pretty terrible
05:05:32 <tsahyt> dramforever: alright, thanks
05:05:35 <dramforever> And the fact that a functor instance is unique
05:05:49 <hpc> superherointj: record syntax is not as good as it could be either, but it's not clear what changes would improve it
05:06:24 <hpc> but ultimately you can ignore those
05:06:49 <dramforever> superherointj: One thing that definitely hasn't been well thought out is adoption
05:07:08 <tsahyt> hpc: what about DatatypeContexts?
05:07:12 <quchen> There are many language extensions required by many modern Haskell libraries, so Haskell-the-language lacks those, but Haskell-the-GHC-implementation has them.
05:07:13 <tsahyt> and other deprecated extensions for that matter
05:07:26 <hpc> tsahyt: also terrible, but i have never seen them used
05:07:28 <quchen> So all good GHC extensions can be seen as something missing in Haskell.
05:07:32 <quchen> e.g. rank-N types.
05:07:50 <quchen> Or flexible type class instances.
05:07:51 <tsahyt> quchen: s/Haskell/Haskell98 or Haskell2010.
05:07:59 <tsahyt> and now we wait for Haskell Prime
05:08:27 <dramforever> quchen: it's not very fair, because it gives languages with de-facto standards (instead of written down ones) advantage
05:08:28 <hpc> really where it matters is the ability to write abstractions
05:08:32 <quchen> Waiting won’t bring us further, I should get to working on it again, tsahyt :-s
05:08:36 <hpc> that's usually what you would here anyone here ding another language on
05:08:44 <merijn> hpc: I've seen them used, but only once and I got a patch approved to remove that use ;)
05:09:05 <tsahyt> quchen: as far as I'm concerned I'm pretty happy with GHC Haskell and accepting the state of GHC as the current "standard"
05:09:10 <ahihi> I'm not a big fan of error handling in haskell
05:09:14 <ahihi> particularly IO exceptions
05:09:14 <tsahyt> although having an updated language standard would be great of course
05:09:28 <merijn> Yes, unchecked exceptions were a bad idea
05:09:32 <quchen> GHC isn’t a standard, we don’t even know how many of the extensions interact.
05:09:49 <merijn> I would love checked exceptions, but I'm not sure that can ever be retrofit into Haskell
05:09:58 <kgadek> superherointj: it's not a problem per se, but I'm very curious of how Haskell would look if instead of monad transformers it was using freer-effects everywhere
05:10:00 <quchen> Just being there doesn’t make a standard
05:10:03 <tsahyt> quchen: hence the quotes
05:10:10 <hpc> also getting people to not hate them
05:10:23 <kgadek> merijn: hmm, you mean checked async exceptions?
05:10:24 <merijn> kgadek: Not all transformer functionality can be subsumed by effects
05:10:25 <hpc> java got checked exceptions and the first thing everyone did was extend RuntimeException to avoid it
05:10:26 <superherointj> Interesting.
05:10:34 <dramforever> kgadek: It loses like 90% of the current amount users and gains <1%
05:10:40 <tsahyt> my point is really that I'm okay with being rather pragmatic about it, since there is no competing compiler at the moment anyhow as far as I know
05:10:51 <kgadek> merijn, dramforever : oh? just started playing with them, they seemed nice
05:11:01 <merijn> kgadek: Async exceptions == exceptions thrown from other threads. I would love to see *those* checked too, but that *definitely* is infeasible to retrofit in haskell
05:11:05 <dramforever> kgadek: Actually, maybe not
05:11:12 <dramforever> because we f**ked up with monads
05:11:14 <kgadek> merijn: ok, got it & agree
05:11:30 <merijn> kgadek: transformers have an explicit ordering, effects do not, but the ordering matters!
05:11:33 <dramforever> And getting a new concept in place could actually be quite good
05:11:39 <kgadek> merijn: you can impose ordering AFAIR
05:11:45 <kgadek> in the runner
05:12:05 <kgadek> but yeah, I got it 
05:12:38 <kgadek> you can't say anything about ordering in the definition because the order is imposed at caller site
05:12:50 <kgadek> (or did I mess it up? not sure about that)
05:14:25 <dramforever> superherointj: Monads. Basically *the* one thing about Haskell that wan't well thought out. And I mean its adoption, not monad per se.
05:14:53 <superherointj> What about dependent types? Is it an issue?
05:15:09 <hpc> dependent types are coming soon
05:15:34 <superherointj> dramforever, but that wouldnt be a language problem, right?
05:15:43 <dramforever> Dependent type isn't a solved problem
05:15:46 <hpc> if you look at the math behind it, dependent types are an extremely new concept
05:16:04 <hpc> calculus of constructions in the late 80s, first language to implement it in 2007-ish
05:16:09 <dramforever> You can't expect open problems to be well thought out
05:16:36 <dramforever> superherointj: it's the first thing beginners *expect* to stumble upon
05:17:00 <hpc> this is sort of where i consider haskell and the languages built off of it to be the next 20 years of computer science development
05:17:02 <dramforever> I award it the most mis-ununderstood programming concept 
05:17:55 <hpc> maybe once a week at my current job, someone has presented a new idea and went "brace yourselves, because $something_already_common_in_haskell"
05:18:23 <hpc> and i just sit there and chuckle
05:18:36 <dramforever> superherointj: If a problem serious blocks adoption of a language X, I don't know where else to put it
05:18:38 <kgadek> hpc: I have JS and Elixir friends. This is really common :D
05:18:50 <dramforever> hpc: examples?
05:18:52 <kgadek> OH LOOK AT THIS AMAZING $actually_a_lens
05:19:23 <hpc> the other day it was using some shennanigans with ruby's blocks to express configuration instead of imperative steps to be executed
05:19:32 <hpc> which... do notation
05:20:16 <hpc> i ended up explaining afterwards a piece of code i wrote that runs both backwards and forwards (to do some image manipulation with short-circuiting)
05:20:31 <hpc> and my coworker looked at me like i was a cheeseman from the dark side of the moon
05:21:19 <kgadek> ye, in Ruby I had abused the ||= only to get Nothing monad-like effects
05:21:59 <dramforever> superherointj: Did you mean it's a problem with humans not languages?
05:22:18 <superherointj> Yes. Or motivation. Or education.
05:22:26 <superherointj> Not a technical fault.
05:22:51 <dramforever> That's like half of Haskell's problems
05:23:04 <ongy> I would argue in this case: if a language produces the errors from humans, it's in the language.
05:23:30 <dramforever> I would argue: this classification is pointless
05:23:54 <ongy> since it's more lively now, I'll ask again :)
05:24:02 <ongy> does the Text.Parser.Expr buildExpressionParser support parens in the expresion? If not, what's the easiest way to do that?
05:25:34 <dramforever> ongy: write two expression parsers 'expr' and 'exprAtom'
05:25:37 <jaspervdj> ongy: if you have a token parser, it's just: expr = parens expr <|> expr
05:26:33 <dramforever> Construct expr with buildExpressionParser, giving exprAtom as the second argument
05:26:44 <dramforever> in exprAtom, add a case: parens expr
05:26:57 <dramforever> ongy: Hey it's literally at the bottom of here: http://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Expr.html
05:28:35 <ongy> dramforever: where? Do we get different pages, or have I worded my question badly?
05:29:04 <dramforever> see this? 'term    =  parens expr'
05:29:31 <dramforever> ongy: ^
05:29:50 <ongy> ohh didn't see that. So it can recurse into itself, I was wondering how to do it
05:29:52 <ongy> thanks
05:30:01 <dramforever> It's an indirect recursion
05:42:53 <Axman6> anyone know if Haskell defines a sloating point floor function? the one from RealFrac returns an Integral type, I want one which returns the same type a la C++'s std:floor
05:43:38 <Nik05> Axman6 what about floor?
05:44:00 <Nik05> http://hackage.haskell.org/package/base-4.9.1.0/docs/Prelude.html#v:floor 
05:44:10 <Nik05> oh oops
05:44:10 <geekosaur> :t floor
05:44:12 <lambdabot> (RealFrac a, Integral b) => a -> b
05:44:12 <kgadek> Axman6: you want Floating returned?
05:44:15 <geekosaur> "Integral"
05:44:20 <Axman6> yes
05:44:29 <Axman6> well... floored
05:44:35 <Axman6> uh, misread
05:44:37 <kgadek> hmm… fromIntegral?
05:44:56 <kgadek> :t :t fromIntegral . floor
05:44:58 <lambdabot> error: parse error on input ‘:’
05:44:58 <Axman6> I'm not sure if the behaviour will be exactly the same
05:45:00 <kgadek> :t fromIntegral . floor
05:45:02 <lambdabot> (RealFrac a, Num c) => a -> c
05:45:10 <Axman6> but, I guess if I ensure it's a 64 bit Int, then it should be
05:45:33 <kubbe> Hello guys! So I have an array, filled with arrays. How can I check so that each array inside my array is of equal length?
05:45:35 <Axman6> kgadek: numerical precision is key here
05:45:59 <Axman6> kubbe: any reason not to use a two dimensional array?
05:46:22 <Axman6> I think fromIntegral is probably ok for this
05:46:30 <kgadek> Axman6: ensure you get Integer in the mid of the expression
05:46:32 <kgadek> and you should be okay
05:46:38 <kgadek> Integer is arbitrary precision IIRC
05:46:44 <Axman6> if you're trying to compute sin on something *10^300 then you have other problems
05:46:49 <kubbe> Hmm.. So this is how it looks Axman6: type Grid = [[Cell]]
05:46:55 <Axman6> kgadek: it is, but may also be slow
05:47:01 <kgadek> Axman6: yeah, true
05:47:04 <Axman6> kubbe: those aren't Arrays ;)
05:47:16 <kubbe> It is a grid as you can tell! Its a list then.. xD(?)
05:48:49 <ongy> list of lists
05:48:55 <kubbe> I want to check that the grid is valid, which means that I want to check that the length of [Cell] is equally against all other [Cell]
05:49:50 <ongy> a simple aproach would be to 1. make a list of lengths 2. us nub on that list 3. Check that length of that list is 1
05:50:13 <ongy> nub removes duplicates from a list.
05:51:41 <ongy> kubbe: can you come up with the code for that idea, or do you need a bit more help?
05:51:46 <kubbe> yes! 
05:51:48 <kubbe> http://pastebin.com/qtgmPXAm
05:52:01 <kubbe> So, this is how far I have gotten.
05:52:55 <kubbe> The thing is that the validGrid is supposed to give me True when my input is goodgrid and False when my input is badgrid. As you can see the badgrid misses 1 element in the 2nd index
05:53:04 <ongy> ok. Do you know how to do the first step? The type would be [[Cell]] -> [Int]
05:53:28 <kubbe> Oh, okey. yeah
05:54:10 <ongy> and then nub (from Data.List, maybe it's in prelude) will remove all duplicates
05:54:28 <ongy> so for the good gird, the result is [4] for the bad grid it would be [4, 3]
05:57:52 <kubbe> Ohhhh, alright! Amazing :D
05:57:57 <kubbe> look at this: http://pastebin.com/SvMn1KhL
05:58:14 <kubbe> Works perfectly fine. Thank you! nub is from Data.List by the way
05:58:42 <kubbe> ongy
05:59:27 <ongy> kubbe: :) I will make no guarantees bout the performance of this, but's it's a nice high-ish level to think about this
05:59:53 <ongy> also style nots: `[x] ++ xs` should be `x:xs`
05:59:56 <ongy> :t (++)
05:59:57 <lambdabot> [a] -> [a] -> [a]
05:59:58 <ongy> :t (:)
06:00:00 <lambdabot> a -> [a] -> [a]
06:00:10 <kubbe> Haha it is fine! We wont work with so big grids so the performance is fine for this :)
06:00:15 <ongy> and you may want to check out map
06:00:17 <ongy> :t map
06:00:19 <lambdabot> (a -> b) -> [a] -> [b]
06:00:53 <kubbe> yeah, haha! That would be later, when my pinball works. then it is time to make the performance better :)
06:02:36 <kubbe> Ehm ongy, on what function should I use map? My partner wanted me to ask :D
06:03:23 <ongy> kubbe: you can replace validGridLength with `map length` in validGrid here
06:04:32 <ongy> are you doing a course? If you ever encounter fmap, map is fmap specialized to lists
06:05:21 <kubbe> yeah, this is some assignment we are supposed to do. Yeah we have just been  slightly introduced to map, so I still find it a bit unsual but I am getting there
06:05:35 <ongy> others here: Is there a current consensus on whether map should be recommended (for nicer errors) or go directly to fmap?
06:06:09 <ongy> kubbe: if you have been introduced to map, think about what you are doing here and why map does the same
06:06:51 <kubbe> Oh! yeah :D solved it!
06:06:58 <kubbe> ongy: now it looks like this: validGridLength x = map length x
06:07:33 <kubbe> much nicer!
06:10:12 <benneh> I have some code which does a lot of file reading, but no other I/O. Since I'm not using most of its capabilities, would it be considered bad practice to do this in the IO monad?
06:10:30 <quchen> no
06:10:54 <quchen> In fact, IO is the only type in which you can do this.
06:11:12 <quchen> (up to wrapper types around it)
06:12:03 <benneh> quchen: I was wondering whether there was some way of lazily reading the entire filesystem and passing it around in a Reader-like fashion.
06:12:35 <benneh> Or the part of the filesystem I care about, anyway.
06:13:19 <cocreature> one thing you can do is to make something like a MonadFileIO class and then keep your code polymorphic so you can not use any other IO except for the one provided by MonadFileIO. I usually find that to not be worth the effort but some people like it
06:16:38 <benneh> I was basically just hoping that someone had already implemented something like that.
06:16:55 <benneh> If not, then I agree with you, it seems like it would be more effort than it's worth.
06:17:01 <zipper> benneh: You wanna read a whole filesystem?
06:17:18 <zipper> You have to do IO in the IO monad
06:17:28 <zipper> How else would you do the I ?
06:18:15 <benneh> zipper: But I don't have to do the logic in the IO monad. For example, I can accumulate some output in the Writer monad, then the only I/O is actually outputting it in a single location.
06:18:36 <benneh> I was wondering whether there was something similar I could do for file reading.
06:18:51 <cocreature> benneh: just read your file and pass it to some pure function?
06:19:04 <zipper> cocreature: Yeah I think that's what you want
06:19:16 <zipper> but you want to read the file lazily, right?
06:19:24 <zipper> You could try a lazy bytestring
06:19:29 <benneh> cocreature: But the contents of the file will determine which other files I need to read, and so on.
06:19:45 <benneh> It is unavoidably monadic.
06:19:48 <zipper> hmmmm you want a forever with an if
06:20:09 <zipper> read a file check for something readfile again
06:21:34 <cocreature> benneh: you might be able to have a pure function return a lists of files that will be processed next but the exact way that you implement this heavily depends on your specific code
06:22:56 <zipper> `fn(f) = readFile f >>= \x -> g(x)` where g(x) calls f again with a certain file
06:23:13 <zipper> I could be totally wrong that's just a quick thing
06:24:29 <zipper> *calls fn
06:24:55 <zipper> but g(x) would be impure? idk
06:25:50 <benneh> zipper: That's essentially what I'm doing currently, but it means that all of the code has to be in IO.
06:26:20 <benneh> But it seems like that's unavoidable.
06:26:44 <fizbin> Is there a standard preprocessing symbol or similar I can use to compile differently when Int is at least 64 bits?
06:26:54 <zipper> Ok ummmmm after reading your file you want to do some "pure stuff", right?
06:27:12 <zipper> fizbin: That is not setting a type to Int* ?
06:27:46 <nshepperd_> data FSTree = Tree (Map Filename Bytestring) (Map Filename FSTree) -- make one of these with lazy io?
06:27:57 <benneh> zipper: I want to do some stuff involving "pure" logic and file reading, but no other form of I/O.
06:28:07 <fizbin> I've got some code where I'm a bit worried about the performance, and I'm using Integer currently because the values I'm processing can be up to 64 bits long, but I'd like to use Int when I know that's big enough.
06:28:16 <fizbin> Specifically, I want to use IntSet.
06:28:36 <zipper> benneh: but you determine the next step based on the contents of your file, right?
06:28:41 <fizbin> (Instead of (Set Integer))
06:29:14 <nshepperd_> Alternatively you could make a custom Free monad containing only "list directory, read file" commands and interpret it in io
06:29:27 <benneh> zipper: Yes.
06:29:52 <nshepperd_> That might be considered pointless though
06:29:54 <zipper> nshepperd_: hmmmm you have an interesting approach
06:30:05 <zipper> Using a Tree
06:30:37 <zipper> benneh: because you answered yes you don't have a pure function, or do you?
06:30:57 <zipper> Your g(x) doesn't always give the same output
06:31:05 <zipper> You could do it in a let in your IO
06:31:49 <benneh> zipper: Sorry, I meant to say that there is a large amount of pure logic, and a small amount of impure logic that involves file reading but no other I/O.
06:31:51 <nshepperd_> (you probably want to use lazy Bytestring and definitely lazy Map in that FSTree)
06:32:53 <benneh> nshepperd_: That's an interesting idea. Thanks.
06:33:43 <zipper> Ah
06:34:04 <ongy> depending on how you look at your filesystem, it's not alwasy a tree. Be careful with that
06:35:14 <nshepperd_> Possibly the values in the maps should be Maybes or Eithers if you want to have some non-crashing response to a file being removed after reading the directory but before reading the file
06:36:58 <zipper> benneh: http://lpaste.net/3127984351933890560
06:37:57 <ongy> does a monad exist that's kinda read-only state? So I can have monadic actions as getters, but not setters? (I can just use state, but restricting myself is good)
06:39:21 <benneh> ongy: The Reader monad?
06:39:38 <zipper> benneh: :)
06:39:50 <mfukar> or State, sounds like both fit the bill
06:39:55 <zipper> ongy: If you only read isn't that just being a pure function?
06:40:07 <ongy> last I looked into that I thought it's more of a streaming abstraction, maybe I got it wrong
06:40:13 <zipper> mfukar: but he doesn't want to be able to set
06:40:37 <Adluc> t
06:40:37 <Adluc> es
06:40:44 <Adluc> sorry, mistype
06:42:08 <ongy> zipper: I should be doable with a pure function and an explicit argument, yes
06:42:46 <zipper> ongy: What's the problem then?
06:42:53 <zipper> You don't have the arg?
06:43:48 <ongy> I want to store the function to apply it later when I have the arguments. And I may have multiple arguments over the runtime of the application
06:44:26 <zipper> ongy: You want to store a function to apply later when you have the args
06:44:33 <zipper> Aha! as benneh said
06:44:37 <zipper> Reader newtype
06:44:43 <ongy> I don't think it's hard to write the code. I mainly want it to look nice :)
06:45:01 <zipper> newtype Reader = Reader {runReader :: r -> a}
06:45:12 <zipper> newtype Reader r a = Reader {runReader :: r -> a}
06:45:33 <zipper> So yeah Reader has your back there
06:46:33 <zipper> ongy: No?
06:47:25 <zipper> Maybe mfukar benneh can explain better
06:47:31 <zipper> Crap
06:47:39 <zipper> I am typing wong nicks sorry
06:47:42 * zipper out
06:49:41 <ongy> zipper: I think it should work
06:58:17 <tsahyt> what's the difference between quotRem and divMod again?
06:59:03 <Axman6> the handling of negatives
06:59:24 <tsahyt> is there a performance difference when inputs are strictly positive?
07:00:21 <Axman6> > [(x,y,divMod x y, quotRem x y) | x <- [-7,7],y <- [-4,4]]
07:00:27 <lambdabot>  [(-7,-4,(1,-3),(1,-3)),(-7,4,(-2,1),(-1,-3)),(7,-4,(-2,-1),(-1,3)),(7,4,(1,3...
07:01:15 <ski> tsahyt : `quotRem' is probably to be preferred, efficiency-wise, under those conditions
07:01:33 <tsahyt> I'll set up a criterion benchmark
07:05:13 <tsahyt> there's no tangible difference
07:05:26 <tsahyt> in my case I'm operating on Words and the second argument is a power of 2.
07:05:49 <Axman6> in that case there are better methods
07:06:30 <tsahyt> well, they're powers of 2 in the ideal case. unless I can figure out a way how to ensure this property in types (I'm using typelits at that point), I need to support other numbers as well
07:06:59 <Geekingfrog> Using amazonka, I want to catch multiple errors in one go with catching. Is there a way to compose the amazonka errors? The type of an error is typically: Getting (First ServiceError) a ServiceError
07:07:03 <Axman6> use myMod x y = x .&. y-1 and moyQuot x y = x .&. complement (y-1)
07:07:48 <Axman6> Geekingfrog: are there prisms provided for the different error types?
07:08:09 <tsahyt> is that x .&. (y-1)?
07:08:14 <Geekingfrog> Yes, these are prism (according to the doc). The whole thing is designed to be used with Control.Exception.Lens
07:09:11 <Axman6> Geekingfrog: you probably want to use handler
07:09:26 <Axman6> http://hackage.haskell.org/package/lens-4.15.1/docs/Control-Exception-Lens.html#t:Handleable
07:09:36 <Axman6> if you're trying to handle different exceptions in different ways
07:09:42 <tsahyt> Axman6: it actually turns out slightly slower
07:09:47 <tsahyt> unless I've made a mistake somewhere
07:10:08 <Axman6> tsahyt: it?
07:10:20 <ongy> also slightly different, since x .&. complement(y-1) still has to be shifted
07:10:21 <tsahyt> Axman6: your myMod and myQuot
07:10:22 <Axman6> also what types are you operating on? Int? Integer? Word?
07:10:28 <tsahyt> Word64
07:10:37 <ongy> iirc divMod (or/and) quotRem are an x86 instruction
07:10:42 <Axman6> ongy: oh yes, of course =)
07:10:47 <Geekingfrog> Axman6: I'd like to use the same handler for a few exceptions. Any way to lump them together?
07:11:07 <Axman6> Geekingfrog: not sure I understand what you mean
07:11:11 <tsahyt> that explains it. at ~3.8ns I don't think it'll become the bottleneck here any time soon
07:11:29 <Axman6> no...
07:11:52 <glguy> Geekingfrog: you can combine them with failing
07:12:35 <Geekingfrog> Currently I would need to duplicate the handling part: catches [handler ExcPrism1 handlingAction, handler ExcPrism2 handlingAction]. Ideally I would have [handler (ExcPrims1 || ExcPrism2) handlingAction]
07:13:08 <ongy> so it's like 1 (slow) instruction against 5 (I think) fast ones. And div is pretty fast these days.
07:13:18 <Axman6> glguy: argh! I needed exactly that yesterday!
07:14:15 <Geekingfrog> glguy: what do you mean?
07:14:52 <Axman6> :t failing _Left _Right
07:14:53 <lambdabot> Applicative f => Over (->) f (Either c c) (Either c c) c c
07:15:22 <Geekingfrog> :i failing
07:16:13 <Geekingfrog> Ok, let me work my way through this thing. Thanks for the help
07:24:09 <ongy> :t failing
07:24:11 <lambdabot> (Conjoined p, Applicative f) => Traversing p f s t a b -> Over p f s t a b -> Over p f s t a b
07:28:17 <bollu> where is Identity?
07:28:48 <bollu> nvm, found it.  import Data.Functor.Identity
07:32:38 <bollu> what is the extension that lets me write types in where clauses?
07:32:59 <cocreature> bollu: you don’t need an extension for this
07:33:19 <bollu> cocreature: oh, really? I thought you needed the thing that lets you write type signature in class instantiation?
07:33:32 <bollu> cocreature: damn, TIL that I have been enabling an extension for no reason :)
07:33:36 <ski> you can't define local types, unfortunately
07:34:04 * ski assumes cocreature was thinking of type *signatures*
07:34:12 <cocreature> oh yeah
07:34:30 <bollu> oh, hm
07:34:36 <bollu> I vaguely remember doing this
07:34:41 <bollu> okay, maybe I'm mistaken. thanks!
07:34:44 <ski> hm, on second thought, it seems that's also what bollu was wanting. proceed
07:35:10 <cocreature> bollu: you can add _type signatures_ to where clauses. you can’t define a new type with "data X = Y"
07:36:50 <bollu> cocreature: oh, yeah, I wanted signatures itself
07:36:56 <bollu> not new type declarations
07:36:59 <bollu> sorry for being vague :)
07:39:27 <lpaste_> bollu pasted “flip-lens-type-error” at http://lpaste.net/352648
07:39:35 <bollu> ^ I'm having a weird type error if I use "get"
07:39:40 <bollu> if I use "flip"
07:39:51 <bollu> with an existentially quantified type variable
07:39:55 <bollu> could someone take a loop?
07:39:56 <bollu> look*?
07:40:04 <bollu> (works if I implement flip myself)
07:40:18 <bollu> oh, why didn't lpaste try to compile my code? :(
07:40:27 <lpaste_> bollu revised “flip-lens-type-error”: “flip-lens-type-error.hs” at http://lpaste.net/352648
07:40:46 <lyxia> :t flip
07:40:49 <lambdabot> (a -> b -> c) -> b -> a -> c
07:40:52 <bollu> yes
07:41:01 <bollu> -- (^.) o l = get l o <- this line compiles fine
07:41:03 <lyxia> bollu: GHC doesn't unify variables with polymorphic types
07:41:21 <bollu> lyxia: which variable here has a polymorphic type?
07:41:24 <lyxia> a ~ Lens o a
07:41:24 <bollu> lyxia: and why not?
07:41:44 <bollu> lyxia: okay, I don't understand what "polymorphic types" means in that case
07:41:57 <bollu> lyxia: what does it mean for a type to be polymorhphic? could you please explain?
07:42:19 <nshepperd> contains a forall
07:42:42 <Reisen> If I have some associated type family: `class A a where; type X a`, and I want to write some method: `x :: A a => X a -> ()`, I get an error about a0 being ambiguous in the type signature
07:42:47 <Reisen> Is this something TypeApplications can solve?
07:42:53 <bollu> I see
07:43:06 <bollu> nshepperd: like, "higher ranked" forall right?
07:43:10 <lyxia> bollu: This behavior is documented here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#impredicative-polymorphism
07:43:20 <bollu> lyxia: thank you :)
07:45:10 <nshepperd> hence, when consuming lenses, you usually use LensLike' f s a with some concrete f
07:45:30 <nshepperd> to avoid higher ranked shenanigans
07:45:53 <lyxia> Reisen: you need AllowAmbiguousTypes to write such a method, and TypeApplications to use it.
07:46:54 <Reisen> lyxia, but it is enough to have the return type be that type correct? I.E, `x :: A a => X a`
07:47:05 <Reisen> Should work with TypeApplications but without AllowAmbiguousTypes?
07:47:15 <ski> s/polymorphic type/universal type/
07:47:24 <ski> (a polymorphic type is something else)
07:48:12 <lyxia> ski: Oh.
07:48:27 <ski> Reisen : perhaps you could use `data X a' instead ?
07:48:34 <lyxia> Yeah "polymorphic" should qualify the function.
07:48:41 <bollu> why do lenses compose "backwards" ?
07:48:48 <ski> (a polymorphic type would be a type whose *kind* looks like `forall k. ..k..')
07:48:49 <bollu> backwards to function composition
07:49:12 <bollu> like, why do they compose "correctly"? _2 . _1 = access 2 then 1. But function composition is backwards
07:49:14 <ski> (just like a polymorphic value is a value whose type looks like `forall a. ..a..', iow whose type is universal)
07:49:15 <bollu> I'm confused :P
07:49:39 <lyxia> bollu: it makes more sense if you see lenses as transforming functions (a -> b) to (s -> t).
07:50:00 <bollu> lyxia: could you unpack that? :)
07:50:10 <ski> bollu : `(. g) . (. f) = (. (f . g))'
07:50:36 <ski> (as opposed to `(f .) . (g .) = ((f . g) .)')
07:51:00 <bollu> ski: I can see how the equations work, but I do not see the relation to the lens type >_<
07:51:30 <lyxia> bollu: oh you didn't write the 4 variable version. with type Lens o a = forall f. Functor f => (a -> f a) -> o -> f o, a lens transforms functions on *views* (a -> f a) to functions on *sources* (o -> f o).
07:52:07 <nshepperd> bollu: here's your lens definition, with slightly different parens: type Lens o a = forall f. Functor f => (a -> f a) -> (o -> f o)
07:52:36 <nshepperd> bollu: so a lens takes a function that operates on values (a) and turns it into a function that operates on containers (o)
07:52:47 <bollu> nshepperd: OK
07:53:23 <bollu> nshepperd: so function composition will take something like (a -> f a) -> (o -> f o), (o -> f o) -> (p -> f p) to (a -> f a) -> (p -> f p)?
07:53:26 <bollu> ohh
07:53:27 <bollu> neat :)
07:53:34 <bollu> thanks for rubber duckying :D
07:53:55 <nshepperd> yup
07:54:05 <lyxia> Reisen: it doesn't matter whether it's an argument or the return type. What matters is whether you can deduce "a" given "X a", which requires that X be injective.
07:54:30 <Reisen> lyxia, yup, sorry it just ocurred to me that that's the case, I had a type that looked something like
07:54:33 <bollu> nshepperd: can you tell me about Prism and Traverse? :3
07:54:37 <Reisen> Foo a => X a -> Y a
07:54:52 <Reisen> And I thought both X and Y were associated type families, but Y isn't, so it fixed the type
07:54:58 <ski> in `_2 . _1', the `_2' part explains how to traverse down from the whole/total structure into the second component of that (by explaining how to *lift* a modification of the second component into a modification of the whole). then `_1' in turn tells how to focus on the first component of *that* part
07:55:04 <Reisen> My own silly inability to read, sorry lyxia 
07:55:06 <samvher> Does the continuation monad have something like ask? I'm trying to do something like this: http://www.haskellforall.com/2012/12/the-continuation-monad.html but I want the supplied continuation to be available in more than one function. Let me know if I'm not explaining clearly :)
07:55:10 <ski> @where SEC
07:55:10 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
07:55:27 <bollu> ski: the paper has Prism and Taverse as well?
07:55:38 <ski> which paper ?
07:55:58 <bollu> ski: AFAIK there is a paper with the same name? (SEC)?
07:56:04 <ski> samvher : you're not explaining clearly :)
07:56:07 <bollu> ski: I want to understand Prism and Traversal as well
07:56:20 <tsahyt> @hoogle Functor f => f (Either a b) -> Either (f a) (f b)
07:56:24 <lambdabot> Data.Functor.Adjunction uncozipL :: Functor f => Either (f a) (f b) -> f (Either a b)
07:56:24 <lambdabot> Data.List.NonEmpty unzip :: Functor f => f (a, b) -> (f a, f b)
07:56:24 <lambdabot> Control.Functor.HT unzip :: Functor f => f (a, b) -> (f a, f b)
07:56:33 <ski> bollu : ah .. no. but imho it helps to understand SEC before or about the same time
07:56:38 <samvher> In the link it uses "ContT $ \f -> do [monad operations]"
07:56:42 <tsahyt> is such a function even possible in the general case?
07:56:43 <bollu> ski: SEC is not the same as lens?
07:56:48 <nshepperd> bollu: Traverse is basically the same, except the container can contain zero or more values, instead of exactly one. which means the function might be applied multiple times
07:56:57 <ski> bollu : it's related
07:56:57 <samvher> but I want to use this f in more than one place, I want to have multiple functions returning monadic values
07:57:03 <samvher> all accessing the same continuation
07:57:36 <samvher> maybe I just don't want to use ContT, so then I should use lift, but then I don't know how to reference the continuation
07:57:50 <bollu> nshepperd: I see. 
07:57:59 <samvher> hence "ask" because I think Cont and Reader seem sort of similar, only Cont takes a more specific argument
07:58:01 <ski> samvher : you're not explaining clearly :)
07:58:13 <ski> samvher : perhaps you're looking for `callCC' ?
07:58:40 <samvher> Haha ok. I was looking at callCC but somehow the type isn't what I would expect. Maybe I'm just confused by the Cont monad :)
07:58:49 <ski> samvher : .. or perhaps you'd rather use delimited continuations
07:59:06 <ski> being confused by `Cont' is normal
07:59:28 <nshepperd> bollu: I think Prisms are zero or one? I'm not too sure about those
07:59:30 <ski> @type callCC
07:59:32 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
07:59:34 <ski> @type asks
07:59:36 <lambdabot> MonadReader r m => (r -> a) -> m a
07:59:39 <Cale> :t runCont . sequence . map cont
07:59:42 <lambdabot> [(a -> r) -> r] -> ([a] -> r) -> r
07:59:44 <ski> i suppose there's a certain similarity
07:59:48 <samvher> ok, I would have to read up on delimited continuations to know if that's what I need
07:59:52 <nshepperd> but they all follow the same pattern of lifting functions on values to functions on 'containers'
07:59:57 <bollu> nshepperd: yes, for sum types
08:00:08 <ski> samvher : well .. perhaps it would be better if you tried to describe what you want to do ?
08:00:21 <nshepperd> :t traverse
08:00:30 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
08:01:32 <ski> samvher : using `ContT $ \f -> ..f..', if you use it in a certain stylized way, is equivalent to using `callCC'
08:01:53 <ski> samvher : elaborate on "I want to have multiple functions returning monadic values","all accessing the same continuation" ?
08:02:01 <samvher> I'm building a website and I want to be able to supply blocks to my template. The template uses the Html monad from Lucid. I thought with the approach in this blog I could do this
08:02:26 <samvher> So I have "html statements >> f MyBlockType >> more html statements"
08:02:42 <samvher> and then by supplying f from above I could fill different types of blocks
08:02:56 <samvher> so MyBlockType1, MyBlockType2, that kind of thing
08:03:16 <Cale> samvher: That sounds more like ReaderT than anything related to continuations.
08:03:28 <Cale> Or just a plain old function parameter
08:04:41 <ski> well .. *perhaps* it could be useful to use `ContT' here, to avoid clutter .. or perhaps not
08:04:53 <Cale> Note that transforming Lucid's monad isn't likely to be made worthwhile without a bunch of effort lifting all the things it provides you.
08:05:06 <samvher> I was looking a bit at ReaderT as well.
08:05:18 <samvher> Cale: yes that's what I was worried about as well, that I would have to do a lot of lifting.
08:05:22 <Cale> I'd just pass your f in as a function parameter
08:05:30 <samvher> Cale: I hoped I could maybe derive the Term monad or something
08:05:52 <ski> perhaps samvher's wanting a relatively local use of `ContT' or `ReaderT' .. which wouldn't be bad
08:06:08 <Cale> maybe...
08:06:29 <ski> (e.g. just using it in one operation or a couple, to make the formulation of it/them nicer)
08:07:28 <ski> (though in the case of `ReaderT', i suppose it'd be less likely to be warranted in such situations)
08:07:39 <Cale> ah, right, I forgot about how Lucid was structured -- it might actually not be terrible
08:08:11 * ski has no idea how `Lucid' is structured, btw :}
08:09:42 <Cale> There's a relatively simple class which defines a few operations over which all the tag-building stuff is abstracted
08:10:11 <Cale> So you *could* just write a lifting instance of the Term class for ReaderT
08:12:03 <Cale> ... or maybe it'd have to be a few, to match the instances which exist for HtmlT
08:12:14 <Nik05> I thought I read something about generalising type inference to kinds or programs. Does anyone know if this exists or not?
08:12:21 <samvher> Sorry about that, I somehow lost my connection on IRC
08:13:02 <Cale> samvher: It might actually be possible to write instances of Term for ReaderT, but I'm not sure I'd even bother with that.
08:13:35 <Cale> I'd just make a record type for the blocks to be filled in
08:13:35 <samvher> Cale: you sound like you have experience with Lucid, do you have some nice approach for working with blocks in a template?
08:13:40 <Cale> and then pass that around
08:14:09 <samvher> Hm yeah I was afraid of that. But then I end up with many pieces of code taking the argument only to be able to pass it on to other code. I never really like that.
08:14:48 <samvher> I was hoping I could derive the instances, but I tried a bit and that didn't go so easily.
08:15:09 <Cale> I think people are over-anxious about introducing function parameters in general
08:15:30 <Cale> You can always figure out what things tend to travel to the same places and package them together.
08:16:03 <Cale> and once you have the program written and know what things are needed everywhere, you can work out something like ReaderT at that point
08:16:14 <samvher> Cale: Right. I know it's possible, I just find it a bit painful/ugly
08:16:58 <samvher> I was thinking I could maybe put the HtmlT over the ReaderT, but then I need to do some hoisting or so after running the Reader (which is also new to me)
08:17:14 <ape> I'm working on understanding dictionary-passing translation. if I have a function that takes an argument from a type class which contains a parametrized type like Maybe a, presumably the compiler needs to compile just one function to handle any argument of a type of the form Maybe a
08:17:42 <bollu> ski: SEC seems like a proto-lens
08:17:44 <bollu> ski: am I mistaken?
08:18:29 <ape> how does the compiler product a single function to handle any argument of type Maybe a for any a?
08:18:33 <ape> *produce
08:18:34 <samvher> ski, Cale: in any case, thanks.
08:19:34 <Cale> ape: By just pushing pointers around and making sure it doesn't follow them
08:20:00 <bollu> Cale: do you know of a general class of examples of Profunctor?
08:20:02 <ape> my guess is that if I try to e.g. get the value of a Just and then do addition, it's calling an external addition function (which itself has a dict of possibilities for Integer, Float, ...)
08:20:13 <bollu> Cale: I've seen the examples in Haskell, but I was hoping for more "universal" examples
08:20:19 <bollu> Cale: (heh, universal)
08:20:43 <ape> Cale: these pointers are the ones in the dict for the functions my function wants to call?
08:21:50 <ski> bollu : i don't think so
08:22:57 <bollu> ski: :( okay
08:23:09 <bollu> ski: then I don't see why the idea of a profunctor even came about
08:23:12 <ski> bollu : i.e. i don't think you're mistaken :)
08:23:24 <Cale> ape: I mean, if a function wants to pattern match against (Just x) or Nothing, and the function doesn't have to examine what 'x' is, then there's no problem -- the same code will work no matter what's on the other end of that pointer.
08:23:34 <bollu> ski: oh xD that one
08:24:35 <Cale> ape: Similarly, if a function gets a pointer to some x of type a, it can package that up in a Just data constructor without needing to examine x, so:
08:24:38 <Cale> :t Just
08:24:39 <lambdabot> a -> Maybe a
08:25:08 <Cale> ^^ parametrically polymorphic, because everything is pointers to code anyway
08:25:39 <Cale> :t map
08:25:41 <lambdabot> (a -> b) -> [a] -> [b]
08:26:40 <Cale> Here, the code for map doesn't need to care about what actual memory layout the concrete values of types 'a' and 'b' have, because it's only ever going to be manipulating pointers to them.
08:27:04 <ape> Cale: that makes sense. so if my class needs to add something but doesn't know which type of class Num it's going to be, there's a reference to the "add" function, and the linker will figure out which add function to use?
08:27:23 <Cale> Oh, type classes are something I haven't mentioned yet
08:27:48 <ape> (basically I'm trying to make sure I really understand why you can separately compile Haskell polymorphic functions, in contrast to C++ template functions)
08:27:48 <Cale> Type class polymorphism *is* implemented by passing dictionaries of operations around
08:28:07 <ski> ape : not the linker. if the constraint isn't discharged, it's result in another implicit argument to the whole thing
08:28:14 <Cale> right
08:28:18 <Cale> e.g.
08:28:20 <Cale> :t sort
08:28:22 <lambdabot> Ord a => [a] -> [a]
08:28:53 <Cale> The implementation of sort merely uses the operations in the Ord type class (ordering comparisons like (<=) and (>) and compare)
08:29:04 <ape> so the compiled version of sort just shuffles around pointers and gets its comparison operator from the dict is receives, right?
08:29:16 <Cale> yeah
08:29:18 <ape> *it
08:29:24 <ape> cool, thanks! that clarifies things
08:29:41 <Cale> and the dictionary is computed from the available instances
08:29:46 <Cale> You can have instances like
08:29:52 <Cale> (Ord a, Ord b) => Ord (a,b)
08:30:11 <Cale> So, if you pass sort a list of type [(Integer, String)]
08:30:15 <ape> I guess what wasn't obvious to me is why this dict will necessarily be of finite size
08:30:36 <Cale> ah, the dictionaries can be computed at runtime
08:30:39 <ski> well .. what do you mean by "finite size" ?
08:30:45 <Cale> For example...
08:30:54 <ski> often it will be cyclic (thus infinite)
08:31:03 <ski> (recursive functions are cyclic data structures)
08:31:08 <ape> so if sort knows how to handle Maybe a, there are potentially infinitely many types: Maybe Integer, Maybe (Maybe Integer), ...
08:31:13 <ape> yes
08:31:52 <Cale> > let f :: (Show a) => a -> Integer -> String; f x 0 = show x; f x n = f (x,x) (n-1) in map (f ()) [0..]
08:31:55 <lambdabot>  ["()","((),())","(((),()),((),()))","((((),()),((),())),(((),()),((),())))",...
08:32:11 <Cale> ^^ This uses instances of Show for infinitely many types
08:32:21 <Cale> which are constructed from the instance Show ()
08:32:32 <Cale> and the instance (Show a, Show b) => Show (a,b)
08:33:36 <ski> `sort' itself doesn't know (or care) "how to handle Maybe a". it's the job of the caller to provide an instance for `Ord a' to use un `sort :: Ord a => [a] -> [a]'. the particular `a' the caller picks can be `Maybe b', for some `b' (maybe `Integer', maybe `(Integer,String)', maybe `(Integer,c)' for a type variable `c' that's not statically known to this caller, iow which it is polymorphic in)
08:33:38 <Cale> But in cases where you're not using polymorphic recursion, the compiler will often be able to generate the instances you actually use by inspection at compile time.
08:34:28 <Cale> Yeah, you can think of the "Ord a =>" as representing an additional hidden parameter which is passed in by the user of the function.
08:34:33 <ski> "there are potentially infinitely many types: Maybe Integer, Maybe (Maybe Integer), ..." -- that's a consequence of `instance Ord Integer' together with `instance Ord a => Ord (Maybe a)'. `sort' is not involved here
08:35:00 <ape> ic. so the dict of implementations of the function just needs one implementation for each concrete type as well as e.g. an implementation that handles `Maybe a' by possibly re-calling a different implementation of itself
08:35:15 <Cale> yeah
08:35:32 <Cale> Well, sort isn't itself part of any dictionary
08:35:49 <Cale> It's not a type class method, just something defined in terms of the methods of Ord
08:36:40 <Cale> It's compiled once, and takes a dictionary for Ord, which is constructed somehow at the usage sites (sometimes by abstracting the definition they occur in over another dictionary parameter to defer the decision)
08:36:48 <ape> is there a good reference for more of this implementation-level stuff about Haskell? I'm pretty new to the language, and the sources I've found don't go too deep
08:37:47 <Cale> The papers by Simon Peyton Jones and Phil Wadler are particularly good -- there are lots of others as well.
08:38:12 <ski> ape : what do you mean by "the dict of implementations of the function just needs one implementation for each concrete type as well ..." ?
08:38:29 <Cale> my flight is boarding, so I'm off :)
08:38:33 <Cale> later!
08:38:42 <ape> thanks!
08:40:08 <ape> ski: my understanding of how haskell implements polymorphic functions is that it replaces `f :: a -> ...' with `f_ :: dictOfFunctions -> a -> ...', where `dictOfFunctions' has implementations of `f' for different concrete values of `a'
08:40:33 <ski> that's not quite right
08:41:49 <ape> ski: how does it go?
08:42:01 <Jaak> more like functions like "f :: Show a => a -> ..." will be replaced with "f :: ShowDict a -> a -> ..." where data ShowDict a = ShowDict { show :: a -> String ...
08:42:16 <dolio> For one, `id :: a -> a` is polymorphic and does not require a dictionary of functions.
08:42:29 <ski> `f :: Ord a => ..a..' (not necessarily any `a ->' in there !) is translated to `f_ :: OrdDict a -> ..a..', where `OrdDict a' has *one* implementation of each of the operations of `Ord' (not of `f' !), for the particular type `a' chosen by the caller
08:43:32 <dolio> For three, this is how GHC implements it. The Haskell report doesn't specify how it's implemented, and there are other compilers that implement it differently.
08:43:33 <glguy> ape: A polymorphic Haskell function can be compiled independent its instantiation because normal Haskell values have a uniform representation
08:43:42 <glguy> ape: While in C++ the values do not
08:44:05 <ape> ohhhh that makes more sense. the caller is responsible for providing the operations required by the type class(es) involved in the function definition
08:44:32 <ape> so the compiled function just has to refer to the pointers in that dict, which are guaranteed to be there
08:44:35 <ski> so if the user wants to call `sort :: Ord a => [a] -> [a]', with `a' being `Integer', then the corresponding dictionary argument of type `OrdDict Integer' will contain implemenentations of `(<)',`(<=)',&c. for the particular type `Integer'
08:44:39 <ski> @src Ord
08:44:39 <lambdabot> class (Eq a) => Ord a where
08:44:39 <lambdabot>     compare              :: a -> a -> Ordering
08:44:39 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
08:44:39 <lambdabot>     max, min             :: a -> a -> a
08:44:50 <nitrix> Using conduit, I'm working with a library that yields a Source; I'm guessing I'll need to create a Sink and connect the two using ($$) in some ConduitM monad, but how do I create such Sink?
08:45:42 <ski> ape : so, there's no implementations of `f' for any particular types stored in the dict. only implementations of the *actual* operations/methods in the type class (`Ord' here), for the *particular* type `a' that the caller chooses
08:46:06 <ape> ski, others: thanks! gotta run off to work, where I get to apply 0% of what I learn about haskell
08:46:15 <ski> there being a contraint `Ord a' in `sort :: Ord a => [a] -> [a]' doesn't mean that `sort' is a method of `Ord'
08:46:26 <ski> ape : have fun :)
08:47:03 <nitrix> It looks like I'd need `await` and that `Consumer` is a generalization of a `Sink`?
08:55:07 <max3> what does pie in ghc-nopie-7.10.3 mean?
08:55:47 <Clint> max3: position-independent executable
08:56:39 <max3> Clint, why am i all of a sudden getting pie ghcs when doing stack setup
08:56:58 <max3> and now stack is trying to install into /root/.stack for all dependencies!
09:18:11 <Clint> max3: i don't know anything about stack but presumably it has to do with "recent" toolchain changes on debian-based systems
09:28:11 <platz> thinking about writing some binding packages to c libs, but haven't done much with FFI.  Is c2hs the way to go in this space?
09:29:07 <glguy> I'd stick with hsc2hs until you determine that you need more than it does
09:35:47 <platz> I thought it might be easier if c2hs genereates the "foreign import"s for me, but i could also see how it might just be better to do it manually
09:46:59 <flxw> Hi, I'd like to parse unix-style timestamps in log files. On hackage I found the Thyme library, which looks pretty cool for this task. My problem: parseTime (from Data.Thyme.Format) takes a TimeLocale argument from old-locale. I found ways to query the current locale using getCurrentLocale from system-locale and current-locale packages, but not old-locale. Am I missing something, or do I really have to instantiate a TimeLocale va
09:47:00 <flxw> hand?
09:58:30 <johnw> platz: you could use c2hsc instead
09:58:50 <johnw> it's designed around generating the FFI into an .hsc file that you can edit/review
10:06:48 <platz> johnw: this looks nice, I will definitely check it out - thanks!
10:07:04 <johnw> sure thing; if you have questions, I'd be the one to ask :)
10:07:29 <johnw> I didn't like c2hs because it was too "automagic" for my tastes
10:28:10 <t4nk563> Hello, friends! How do I use "where" so ghci understands it? Semicolon does not work ;/
10:30:37 <glguy> t4nk563: It'd be easier if you just showed what you were trying to do than if we guess
10:31:02 <t4nk563> (+) 1 . sum . map (1 /) . take (n-1) $ iterate ((+) 3) 4 ; where n = 9
10:31:06 <glguy> Also, if you're writing something complicated enough to use a where it should probably be going into a file instead of GHCi directly
10:31:21 <glguy> You can't use where as part of building an expression like that
10:31:30 <glguy> That's what let is for
10:31:46 <t4nk563> Uhm.
10:31:57 <t4nk563> Why not?
10:32:01 <glguy> where is part of the syntax for declarations and case alternatives
10:32:07 <glguy> it's not part of the syntax of expressions
10:32:34 <glguy> > let n = 9 in (+) 1 . sum . map (1 /) . take (n-1) $ iterate ((+) 3) 4
10:32:36 <lambdabot>  1.7703663441821336
10:32:46 <t4nk563> Thank you very much, I'll use let then :)
10:38:26 <kgadek> (maybe?) quick question. True or false?: freer-effects is the best/most developed lib providing FreeR monads
10:39:43 <johnw> I'm guessing you mean "that's published on Hackage"?
10:46:20 <pikajude> is there a cloud-haskell irc channel
11:00:45 <crosleyt> is there any good way to uninstall all cabal packages?
11:00:46 <clmg> Does anyone know how to draw a border around some text using vty?
11:01:42 <johnw> crosleyt: rm -fr ~/.ghc ~/.cabal is the most devastating way
11:02:47 <crosleyt> that was devastating, thx
11:06:32 <johnw> is skolem pronounced "school-em"?
11:06:51 <johnw> the IPA notation is ˈskuːləm, which seems to suggest this
11:07:05 <Tuplanolla> I thought the o was supposed to be short, johnw.
11:10:29 <mekeor> is there a function 'f' (within the base package?) so that 'f "foo,bar,baz,qux," == ["foo","bar","baz","qux",""]' ?
11:11:06 <monochrom> johnw: I was in Stephen Cook's class and he still said it like English :)
11:11:11 <pikajude> mekeor: there's a split library
11:11:13 <pikajude> that can do that
11:11:34 <pikajude> mekeor: http://hackage.haskell.org/package/split-0.2.3.1/docs/Data-List-Split.html
11:11:44 <mekeor> thanks, pikajude  :)
11:17:57 <crosleyt> hmm still in version hell...
11:18:02 <crosleyt> next goal: base (dependency of haskell98-2.0.0.3) rejecting: base-4.9.1.0/installed-4.9... (conflict: haskell98 => base>=4.7 && <4.8)
11:18:43 <crosleyt> the idea was to uninstall all packages and then install haskell98 so that it works no matter what
11:19:00 <monochrom> Please don't do that.
11:19:14 <crosleyt> what to do instead
11:19:37 <monochrom> There are a small bunch of packages locked with your GHC. Replacing them breaks your copy of GHC.
11:20:10 <crosleyt> would I need a previous version of GHC to use that package then
11:20:13 <monochrom> And then there are a dozen more that, while an expert would know how to replace, it would take expertise.
11:20:20 <monochrom> Yes.
11:20:50 <clmg> anyone here know vty?
11:21:00 <monochrom> I do not actually know what you need this for. The solution depends on the problem.
11:21:21 <monochrom> At this point I can only tell you what will not solve any problem.
11:21:46 <crosleyt> I'm trying to compile an older package which depends (among other things) on haskell98
11:22:20 <monochrom> hrm does haskell98 come with recent GHC?
11:22:36 <monochrom> ah it's dropped.
11:23:05 <Tuplanolla> Are you sure you don't want Brick instead, clmg?
11:23:08 <monochrom> Now I wonder if you can simply add it.
11:23:40 <monochrom> ah it can't be.
11:24:13 <monochrom> Short term: Use an older GHC. Long term: Modify the package for today's environment.
11:25:07 <crosleyt> ok, thx.
11:27:03 <clmg> Tuplanolla: ah it has border. great.
11:43:08 <max3> should passing this -L/usr/lib/x86_64-linux-gnu/ -lavformat -lavcodec -lavfilter -lavutil to ghci pick up things like libavfilter.so.6.31.100
11:59:16 <max3> i feel silly but how do i perform all of the imports in a .hs from the interpreter without running the main?
12:00:05 <monochrom> Use :load myfile.hs ?
12:00:28 <max3> i've done that and none of the imports are in scope
12:00:45 <monochrom> That's strange, because it works for me.
12:01:02 <max3> yea maybe i'm wrong
12:02:13 <monochrom> Also I think your previous question about -L and -l is yes.
12:03:04 <monochrom> (GHC Users Guide section 5.6.2)
12:22:48 <dolio> Was your file already compiled? Because ghci works differently when loading already compiled vs. interpreted files.
12:23:19 <dolio> I think it's not strictly compiled vs. interpreted, but that's the easiest way to trigger the difference.
12:24:31 <monochrom> I judged it unlikely because "ghc -c myfile.hs" would not cause it at all, it has to have the secret password "ghc -c -dynamic myfile.hs", but few people actually know.
12:25:05 <monochrom> But oh maybe it's Windows and doesn't need -dynamic.
12:37:55 <Tuplanolla> Does the type `Reader r r` suggest something is designed poorly or should I go ahead with it?
12:38:19 <monochrom> Depends on context, no?
12:38:45 <monochrom> @type tell
12:38:47 <lambdabot> MonadWriter w m => w -> m ()
12:38:54 <monochrom> err no
12:39:09 <tdammers> @type ask
12:39:11 <lambdabot> MonadReader r m => m r
12:39:11 <tdammers> this one?
12:39:18 <monochrom> Yeah.
12:39:21 <Tuplanolla> What I really want is `StateT`, but only for the main thread, because forking would make the state diverge.
12:40:27 <Rembane> Tuplanolla: What stops you?
12:40:39 <Tuplanolla> Self-doubt, Rembane.
12:41:23 <Rembane> Tuplanolla: I say: Go for it! You will learn things from it regardless if it's a good idea or not.
12:41:42 <Tuplanolla> My plan was to use `ReaderT` and finish by returning the new state, but that feels like abuse.
12:43:06 <Rembane> Tuplanolla: I think StateT is the way to go. It has the right feel for your usecase.
12:43:26 <johnw> I love the feel of StateT
12:43:49 <Rembane> johnw: I love the smell of ContT in the morning.
12:44:20 <Tuplanolla> @hoogle smell
12:44:22 <lambdabot> No results found
12:44:51 <Rembane> I must fix this. Control.Smell
13:07:39 <ReinH> Please. Data.Smell.
13:08:40 <ReinH> End the arbitrary segregation of data from other, misnamed data.
13:09:07 <monochrom> I have a cunning plan to bring the two of us to a consensus. Both "control" and "data" could be unified under the umbrella of "code". So, Code.Smell
13:09:16 <monochrom> s/us/you/
13:09:29 * ReinH slow claps
13:09:52 <monochrom> Should I slow-bow?
13:10:04 <ReinH> I mean... That doesn't look like anything to me.
13:12:18 <Tuplanolla> I wouldn't mind less descriptive categories like `Essential` or `Wacky`.
13:16:22 <AWizzArd> Using Control.Monad.Writer and this function:   logNumber :: Int -> Writer [String] Int
13:16:26 <AWizzArd> Why does this work?   logNumber 5 >>= (\x -> writer ((), []))   — why can one input  ()
13:16:54 <AWizzArd> Basically this is the  tell  FN.
13:16:54 <Tuplanolla> :t writer
13:16:56 <lambdabot> MonadWriter w m => (a, w) -> m a
13:18:55 <EvanR> recent talk about unums https://www.youtube.com/watch?v=aP0Y1uAA-2Y
13:18:56 <Tuplanolla> You discard the integer and return `()`, AWizzArd. Nothing says `a` has to remain constant.
13:19:31 <Tuplanolla> :t fmap -- Here's a less convoluted function for changing `a` to something else.
13:19:33 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:20:49 <EvanR> i really like the part on "posits" which out perform floats at their own game
13:21:44 <ph88^> is this an implementation of miniKanren ? https://hackage.haskell.org/package/unification-fd-0.10.0.1/docs/Control-Unification.html
13:21:45 <AWizzArd> logNumber 5 >>= (\x -> writer ((), []) >>= (\y -> writer (2*x, ["Hello"])))   evaluates to   WriterT (Identity (10,["Got number: 5","Hello"]))
13:22:41 <AWizzArd> So this is fine as long the value  y  isn’t used.
13:22:45 <AWizzArd> Okay, makes sense.
13:23:02 <EvanR> and since there are no NaNs, computation throws an exception in the specific cases of 0/0. when someone said "but how do you try a bunch of computations some of which are bad, you dont want to throw out all the work from before and after" i immediately though about [Maybe Float]
13:23:28 <EvanR> floating point errors can be caught and masked as Nothings
13:24:14 <EvanR> though this takes some time and memory to do
13:28:59 <monochrom> EvanR: Interesting.
13:29:11 <Athas> Has anyone here tried to use the cuda package on CUDA 8?
13:34:34 <hagr> Hello, all. Is there a good case for using a Haskell compiler for DOM applications?
13:36:02 <AWizzArd> When using foldl' on an extremly large input seq, then the code will eagerly go through the whole seq, yes?  I can’t „abort” this process earlier, and there is no lazyness involved?
13:40:05 <Tuplanolla> Basically so, but laziness is only uninvolved in the spine of the fold, AWizzArd.
13:42:02 <monochrom> hagr: Yes. Cale works with a company that uses reflex-dom.
13:42:38 <monochrom> Maybe also GHCJS, I forgot.
13:42:51 <hagr> monochrom: Ok, so people are using it in production. 
13:43:29 <hagr> I know GHCJS -> javascript and GHCJS-Dom has DOM bindings (among others), I just didn't know if the projects
13:43:36 <hagr> are mature enough to trust in production. 
13:44:36 <stepcut> Is it possible to implement, showProxy :: (Show a) => Proxy a -> String, so that you could have, showProxy (Proxy :: Proxy True) == "Proxy :: Proxy True"
13:46:03 <lyxia> stepcut: you'd want showProxy :: forall a (x :: a) :: Show a => Proxy x -> String, which is a dependent type.
13:46:06 <stepcut> I can do it using a type-class, class ShowProxy a where showProxy :: Proxy a -> String, instance ShowProxy True where showProxy _ = "Proxy :: Proxy True", but it would be nice to leverage the exist show instance 
13:47:01 <lyxia> and GHC doesn't have dependent types yet. I heard you can get pretty close with singletons.
13:47:15 <stepcut> lyxia: right.. I think I have to do this the ugly way for now
13:47:15 <lyxia> @hackage singletons
13:47:15 <lambdabot> http://hackage.haskell.org/package/singletons
13:48:18 <stepcut> I think I will just use the type class worka
13:48:36 <stepcut> workaround for now, I really only care about one type at the moment and it doesn't have that many constructors
13:48:57 <lyxia> good idea
13:51:13 <siddhu_> Athas: no, but it does support CUDA 8. Ping the author if you run into issues.
13:53:03 <Athas> siddhu_: you know for a fact that is supports CUDA 8?  The hackage page mentions that it has only been tested up to 7.5.  I'd be surprised if it didn't work, but I figured I'd fish around for experiences while I wait for it to build.
13:55:33 <siddhu_> Athas: actually, there's a github issue https://github.com/tmcdonell/cuda/issues/42
13:55:48 <Tuplanolla> This `ReaderT` idea turned out to be very good, because it also made me find a better solution to the `forkStateT` problem I mentioned a few days ago.
13:57:52 <Athas> siddhu_: that looks like it's about supporting new features, which is not important to me.
13:58:01 <Athas> I just want to run on a machine with CUDA 8 drivers.
14:01:03 <siddhu_> Athas: I know the author merged some patches which allow compiling with CUDA 8. So it should work, but I haven't tried it myself.
14:01:33 <Athas> I'll try it out.
14:07:11 <hagr> monochrom: Is Cale a regular in this channel? Is Cale his nick? 
14:07:30 <monochrom> Yes and yes.
14:07:36 <hagr> Ok, thanks!
14:09:33 <jle`> stepcut: note that 'Show' there in your example isn't well-kinded
14:09:58 <jle`> stepcut: Show can only have instances that are kind *
14:10:09 <jle`> stepcut: but in your example, 'a' has kind Bool
14:10:21 <jle`> stepcut: that should be a hint that Show can't do what you need it to do in Haskell
14:10:44 <Athas> Is there a way to get stack to tell me why it's trying to install some dependency?
14:10:53 <Athas> I tried to visualise with 'stack dot', but it's near-unreadable.
14:11:15 <stepcut> jle`: oh yeah
14:11:16 <Athas> I vaguely recall that'cabal-install could show the path, but stack --verbose doesn't seem to do it.
14:11:29 <monochrom> Oh, is that in the graphviz format?
14:11:39 <jle`> oh, i think that was the point that lyxia made earlier that i didn't read carefully :)
14:11:47 <stepcut> jle`: yup
14:12:29 <stepcut> This was all a lot easier when there was Idris and pre-DataKinds Haskell. Back then it was easier to remember what you could or could not do in Haskell
14:12:38 <stepcut> now.. you have to think a lot harder
14:13:09 <monochrom> There is still Idris. :)
14:13:15 <stepcut> yeah
14:13:44 <nitrix> Is there a better idiom for something inline similar to:    (fix $ \loop n -> print n; foo; loop (n+1))) 0
14:13:45 <stepcut> But, implementing my class-based solution was faster than porting this to Idris
14:13:50 <monochrom> Also, type-level list is so much less gymnastics in Idris than in Haskell.
14:13:58 <stepcut> yeah
14:14:12 <jle`> stepcut: you might have also been able to leverage singleton's TH to get something like this automatically
14:14:14 <nitrix> Wheareas, you can have an infinite loop with an incrementable variable with a default value? Or am I just re-inventing runST ?
14:14:33 <monochrom> No, runST would be bad at this.
14:15:01 <Tuplanolla> You can define `fix1 a f = fix f a` to make it look a bit nicer, but that's about it, nitrix.
14:15:09 <nitrix> Tuplanolla: :(
14:15:10 <stepcut> I think I figured out how to abuse Haskell enough so that you can do, pHttpVersion :: Parser [abnf| "HTTP" "/" 1*DIGIT "." 1*DIGIT|] (Int,Int), and get a compile type 'proof' that your parser conforms to the ABNF spec :p
14:15:40 <stepcut> which would also be a lot less messy in Idris
14:15:49 <jle`> yea but if you are going to use TH might as well just do compiletime validation using TH right
14:16:18 <jle`> TH can throw compile errors arbitrarily
14:16:39 <stepcut> jle`: sure.. but at compile time
14:17:12 <stepcut> anyway, my solution only requires QuasiQuotes -- TH's less evil sister
14:17:16 <jle`> isn't your case at compile time, too?
14:17:30 <stepcut> yes
14:17:48 <nitrix> Tuplanolla: monochrom: I came up with  fix $ 0 & \n loop -> do ...
14:18:00 <nitrix> It's not terribly bad, is it :/
14:18:02 <stepcut> perhaps I am unclear why you brought up TH and compile time errors
14:18:09 <monochrom> Cunning!
14:18:18 <jle`> stepcut: compiletime validation is 'easy' if you bring in TH
14:18:20 <Tuplanolla> How does it generalize for more arguments, nitrix?
14:18:27 <jle`> s/easy/trivial
14:18:33 <stepcut> jle`: perhaps
14:18:36 <monochrom> I needed what you need now 10 years go, and back then there was no &.
14:18:40 <jle`> so you don't even need to bring in a type system thing
14:18:44 <monochrom> s/go/ago/
14:18:44 <nitrix> Tuplanolla: Actually, crap, you're right, `loop` will have the wrong type.
14:18:50 <nitrix> Tuplanolla: I wont be able to pass new `n`'s.
14:19:10 <Tuplanolla> So that's just `flip fix`, nitrix.
14:19:37 <nitrix> Yeah which isn't good enough. Alright, I'll just extract it as a function I suppose.
14:20:17 <exio4> nitrix: let go n = ... go (f n) ... in go start
14:20:22 <lpaste_> Tuplanolla pasted “Flipped Fixes” at http://lpaste.net/352673
14:20:24 <Tuplanolla> ...to save you some effort, nitrix.
14:20:38 <monochrom> "flip fix" is less reliant on operatoer precedence
14:23:22 <stepcut> jle`: I am not entirely clear on what the TH solution would look like
14:40:42 <ezyang> This is very puzzling: as far as I can tell, it looks like hPutStr on Windows is truncating the string I'm outputting D: 
14:42:08 <`Guest05> how does fromException work?
14:42:34 <ezyang> `Guest05: internally, you mean? 
14:42:42 <ezyang> it makes use of Typeable 
14:42:55 <`Guest05> i look at sources and see that it pattern matches
14:43:42 <`Guest05> i try to repeat this same thing and GHCi says that 
14:43:48 <`Guest05> * Couldn't match expected type `a0' with actual type `n'
14:43:48 <`Guest05>         because type variable `n' would escape its scope
14:43:48 <`Guest05>       This (rigid, skolem) type variable is bound by
14:43:48 <`Guest05>         a pattern with constructor:
14:44:05 <ezyang> wait, no, it doesn't use Typeable 
14:44:30 <ezyang> `Guest05: It's a type class method, so when you have SomeException e =>, you implicitly have a function that says how to get out the appropriate type from e 
14:44:55 <`Guest05> how *does* that function work?
14:45:30 <implementation> there is no single function, there is a whole family of functions, one for each instance of the Exception typeclass
14:45:46 <ezyang> oh, actually, it does use Typeable \o/ 
14:45:52 <ezyang> fromException (SomeException e) = cast e is the magic 
14:46:23 <implementation> where do you see that?
14:46:54 <`Guest05> so..
14:46:56 <monochrom> ezyang: It is possible that the default locale dislikes certain non-ASCII characters. chcp 65001 to ensure UTF-8.
14:47:23 <`Guest05> if i do it exactly as in source for fromException
14:47:29 <`Guest05> by defining a function
14:47:30 <monochrom> There are also per-handle functions to just set this per handle.
14:47:32 <`Guest05> it works
14:47:43 <`Guest05> but if i make a lambda or a case
14:47:44 <ezyang> monochrom: Hmm 
14:47:53 <mniip> SomeException stores the Typeable instance of the type
14:47:55 <ezyang> ok, I'll give that a try 
14:48:04 <`Guest05> it complains about "(rigid,skolem)"s
14:48:04 <monochrom> `Guest05, the intention is that you don't implement your own fromException, you just use the default, i.e., you write no code.
14:48:05 <mniip> so that you don't impose a restriction on a skolem tyvar
14:48:20 <mniip> but still can derive type information and the validity of a cast from the Typeable dictionary
14:48:36 <monochrom> But if you do need to write custom code for whatever reason, you will need to know existential types.
14:48:38 <ezyang> but I'm pretty sure there are no non-ASCII characters in my output 
14:48:46 <`Guest05> monochrom: hackage documentation says that i do implement fromException if i want to make  hierarchy
14:49:12 <monochrom> Yes but it is unusual to want a hierarchy. Even the OOP people are growing out of it.
14:49:43 <`Guest05> i want to make assertions with user messages and have catchable AssertFailed...
14:50:12 <ezyang> oooh, I didn't even realize that we could define hierarchies! 
14:50:17 <monochrom> 5 hours of abstract hierarchy can be saved by 5 minutes of sum type.
14:50:39 <monochrom> Take for example AsyncException.
14:51:10 <ezyang> If I want to create an exception that masquerades as an IOException can I do it with the hierarchy mechanisms? 
14:51:28 <MarcelineVQ> is the only way to distinguish between 'too many open files' and 'device is out of space' with an IOException of ioe_type ResourceExhausted to examine the ioe_description string? worded more directly, or if that string doesn't contain that info, how can I discern between the two?
14:51:40 <monochrom> No, you need a type class first.
14:51:47 <ezyang> :( 
14:52:17 <ezyang> MarcelineVQ: If you look under the covers of IOException there are a number of fields that you can access via functions 
14:52:21 <monochrom> Actually let me double-check.
14:52:22 <ezyang> If all of them are the same you're outta luck 
14:52:59 <monochrom> Yeah you need a type class first.
14:53:07 <ezyang> Sigh 
14:53:08 <MarcelineVQ> yes, I've yet to investigate fully, but the pretty printed error is distinct for the two so I wanted to ask ahead of exploring to see if there was something common
14:53:34 <ezyang> the relevant info should be squirreled away in one of the other fields 
14:53:38 <monochrom> But why masquerade as IOException when you can masquerade as SomeException :)
14:54:07 <ezyang> monochrom: Because some end user who I don't have control over used catchIO and now I am sad 
14:55:20 <monochrom> Approximately you have to use the String argument of userError.
14:55:52 <ezyang> yeah, that's what we ended up doing 
14:55:57 <jle`> ezyang: (error "hey" :: IOException)
14:55:59 <jle`> hehe
14:56:00 <MarcelineVQ> ezyang: mostly I was hoping for something other than english language strings to be basing my error classifying off of :>
14:56:08 <monochrom> Put Gödel numbering in the string so your catcher can decode it and find a whole hierarchy.
14:56:09 <MarcelineVQ> does anyone know if errno here http://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.IO.Exception.html#IOException is well defined anywhere?
14:56:20 <`Guest05> * My brain just exploded
14:56:20 <`Guest05>       I can't handle pattern bindings for existential or GADT data constructors.
14:56:22 <ezyang> There should be errnos 
14:56:39 <`Guest05> what a wording...
14:56:43 <ezyang> `Guest05: don't let-bind: case 
14:56:44 <monochrom> Unfortunately no errnos for the Windows people.
14:56:45 <`Guest05> i was startled
14:57:19 <monochrom> Double negative elimination: errnono -> err
14:59:01 <monochrom> `Guest05: See how this is a whole rabbit hole right inside a pandora box. Is it simpler to just use a sum type?
14:59:17 <mniip> wait
14:59:23 <mniip> you can't let-bind gadts?
14:59:29 <monochrom> Right.
14:59:38 <mniip> oh I suppose that might be a problem with recursive bindings?
14:59:53 <monochrom> I don't actually know the issue.
15:00:09 <MarcelineVQ> ezyang, monochrom: thank you for your responses
15:00:16 <monochrom> Somewhere on the GHC trac someone may have discussed it.
15:00:42 <`Guest05> monochrom: how do i make assertions with user messages convertible to AssertionFailed with sum types?
15:00:47 <jle`> maybe it has to do with let polymorphism
15:00:59 <mniip> maybe it's maybelline
15:01:27 <monochrom> :)
15:01:48 <MarcelineVQ> maybe it's read, maybe it's haskeline
15:02:01 <monochrom> haha great
15:04:51 <monochrom> Either use AssertionFailed directly (via "assert"), or forget AssertionFailed altogether and just write your own type.
15:05:02 <monochrom> Conversion is a lost cause.
15:05:33 <monochrom> Two cases:
15:06:22 <monochrom> Either the user uses "assert", which will not use the hierarchy you endeavoured to build.
15:06:57 <monochrom> Or the user uses your hierarchy and your nice thrower functions, in which case why invite AssertionFailed to the party?
15:07:22 <monochrom> The thing is so-called "conversion" will have to lose the user message you have.
15:07:46 <`Guest05> i don't know
15:07:52 <`Guest05> i just waant it, it seems nice
15:07:55 <`Guest05> want *
15:11:44 <`Guest05> poor AssertionFailed, it wasn't invited
15:21:07 <monochrom> Re: pattern bindings and GADTs. "The reason for this restriction is really an implementation one. Type-checking binding groups is already a nightmare without existentials complicating the picture. Also an existential pattern binding at the top level of a module doesn’t make sense, because it’s not clear how to prevent the existentially-quantified type “escaping”. So for now, there’s a simple-to-state restriction. We’ll see how 
15:21:07 <monochrom> annoying it is."
15:24:58 <buttons840> in ghci I will do `let f = 'x'` but then whenever I do `:r` all my let bindings are gone from ghci; is there a way to avoid this?
15:26:43 <dolio> EvanR: That talk was pretty awesome.
15:28:05 <dolio> As an IEEE754 hater, at least.
15:30:10 <EvanR_> i am somewhat more convinced now that the unum guy is not a crackpot
15:31:23 <monochrom> err, s/GADTs/existential/
15:32:34 <monochrom> buttons840: Put it in a file, and :r that file.
15:33:39 <dolio> There are non-typechecking reasons.
15:50:54 <ishmael> is myFunction :: a -> b  an expression? or what is it?
15:51:04 <haasn> I have a function :: Double -> Double. What's the easiest/quickest way to visualize it, over a given input range?
15:51:16 <haasn> e.g. plot :: Double -> Double -> (Double -> Double) -> IO ()
15:51:29 <`Guest05> it's impossible to make a value `cast`able to two types right?
15:51:37 <haasn> I don't want to concern myself with setting up axes
15:51:50 <jle`> ishmael: depends on the context
15:51:55 <EvanR> cast ?
15:51:56 <jle`> ishmael: but at the top level, it's a type signature
15:52:17 <jle`> if it'as associated with a definition of 'myFunction', then it's a type signature
15:52:24 <haasn> ah https://hackage.haskell.org/package/easyplot-1.0/docs/Graphics-EasyPlot.html seems like my best bet
15:52:27 <jle`> but the same syntax also shows up in usage as an expression
15:52:37 <buttons840> I have a question about parsing with Trifecta -- if I have two parsers, p1 and p2, is "try (p1 <|> p2)" equivalent to "(try p1) <|> (try p2)" ?
15:52:46 <ishmael> jle`: im trying to understand that line of code in the context of a purely functional language
15:53:02 <ishmael> and i mean it as a type signature
15:53:05 <jle`> ishmael: it can show up as an expression too
15:53:05 <`Guest05> e. g. cast x :: Maybe A === Just something1  and cast x :: Maybe B === Just something2
15:53:07 <jle`> oh, ok
15:53:12 <jle`> ishmael: in that case, yes, it's a part of declaration syntax
15:53:25 <jle`> i'm assuming you don't mean something like (succ :: Int -> Int) 10
15:53:28 <geekosaur> ishmael: it's a type assertion. attached to a definition, it asserts the type of that definition; attached to an expression, it asserts that the expression must have that type
15:53:35 <jle`> where (succ :: Int -> Int) is an expression, 'succ' with a type annotation
15:53:44 <EvanR> `Guest05: what is the type of cast
15:53:55 <jle`> buttons840: i don't think it is
15:54:04 <jle`> i'm pretty sure it's not
15:54:08 <jle`> depending on p1 and p2
15:54:14 <geekosaur> (asserting the type of an expression may affect typeclass resolution, leading to an effect similar to "casting"; but it is not, itself, a cast)
15:54:39 <`Guest05> haasn: plot a b f = print $ f <$> [a,a+0.05..b]
15:54:42 <jle`> ishmael: in the context of a purely functional language, your program might simply be a bunch of (immutable) definitions/declarations
15:54:45 <buttons840> jle`: i think you are right, because i have experienced them behaving differently, but I'm not sure I understand why?
15:54:58 <jle`> ishmael: a type signature like that is a part of the syntax for defining/declaring somything
15:55:05 <jle`> it describes the declaration
15:55:35 <jle`> ishmael: similar to saying sin : R -> R; sin(x) = x - x^3/3! + x^5/5! + ...
15:55:56 <jle`> buttons840: 'p1 <|> p2' will try p2 if p1 fails, but it'll start parsing from when p1 left off
15:56:14 <dolio> No, that is not what happens.
15:56:29 <jle`> aw
15:56:46 <buttons840> jle`: oh, good to know
15:57:07 <`Guest05> haasn: or if you need to make it *visual*, plot f = print $ (/ 0.05) . (+ 1) . f <$> [-1,-0.95..1]
15:57:21 <buttons840> jle`: i figured "choose [p1, p2]" was the same as "p1 <|> p2", but it sounds like that's not the case?
15:57:37 <ishmael> jle`: ah, i see, so it's not really an expression on its own when it's part of a type signature, but it's part of the definition of the function
15:57:42 <dolio> try allows backtracking arbitrarily far.
15:57:43 <jle`> if p1 consumes input and then fails after consuming stuff, the, for p1 <|> p2, trifecta will start "running" p2 on the input that's already consumed
15:57:50 <ishmael> and the definition of the function is a function, right? one that returns the fuction?
15:58:16 <`Guest05> haasn: correction,  plotVisual f = print $ (`replicate` '*') . truncate . (/ 0.05) . (+ 1) . f <$> [-1,-0.95..1]
15:58:19 <dolio> So, `try (p1 <|> p2)` is not able to do as much p1 backtracking as `(try p1) <|> (try p2)`.
15:58:32 <jle`> buttons840: choose [p1, p2] should be the same as p1 <|> p2, but i'm not 100% sure i remember the exact definition of choose
15:58:40 <jle`> but asum [p1,p2] is indeed p1 <|> p2
15:58:46 <haasn> `Guest05: it's alright, I already found my solution
15:58:55 <haasn> and I need this as a PNG for a blog post :)
15:59:01 <haasn> visual means visual
15:59:05 <jle`> ishmael: yes, it's a part of the syntax of defining something
15:59:36 <ishmael> jle`: and the definition is a function which returns itself?
15:59:55 <jle`> definition is not a function
16:00:04 <jle`> at least not in Haskell
16:00:04 <buttons840> choose = asum if I remember -- i'm not supper familiar with asum though
16:00:20 <jle`> it might be considered a function in a homoiconic language like lisp?
16:00:24 <ishmael> its an expression, though
16:00:28 <jle`> but definition/declaration is not a function
16:00:31 <jle`> it's not an expression, either
16:00:39 <jle`> declarations/definitions aren't considered expressions
16:00:45 <jle`> at least not in Haskell
16:00:56 <jle`> they are a wholly separate construct
16:01:20 <EvanR> declarations are not expressions, lets not speculate on what lisp thinks
16:01:39 <lambdamu> Hi, it is not possible to specify defaulting for arbitrary type classes with ExtendendDefaultRules, just a selected few, right?
16:01:55 <ishmael> jle`: why is that? that's how its implemented, or thats a difference in theory as well?
16:02:06 <`Guest05> :t cast
16:02:07 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
16:02:11 <jle`> well it's just how it is in the definition of Haskell
16:02:20 <jle`> in the language spec
16:02:42 <EvanR> `Guest05: then casst should work for multiple types
16:02:59 <ishmael> do they have different data structures?
16:03:28 <jle`> what data structures are you referring to?
16:03:45 <`Guest05> EvanR: how did you infer that from the type signature alone?
16:03:47 <ishmael> behind the scenes
16:04:01 <jle`> are you talking about how a compiler might implement an AST?
16:04:11 <EvanR_> `Guest05: your ` is really annoying
16:04:28 <`Guest05> how?
16:04:44 <EvanR_> i tried to type g<tab>, then ~<tab> then...
16:05:00 <EvanR_> all of which do stuff
16:05:17 <jle`> ishmael: in any case, the language spec is pretty clear that expressions and declarations are different concepts
16:05:18 <ishmael> jle`: in the C implementation (haskell is written in C, i think?)
16:05:19 <jle`> https://www.haskell.org/onlinereport/index.html
16:05:26 <`Guest05> EvanR_: sorry
16:05:29 <jle`> GHC is written in Haskell
16:05:30 <`Guest05> i'll note this
16:05:38 <jle`> and Haskell is written in English
16:05:49 <`Guest05> and English isn't written
16:05:52 <jle`> (provided in the link i gave)
16:06:17 <jle`> Haskell is a language specification; it's up to the implementations to decide how to...implement it
16:06:30 <`Guest05> chain = GHC : Haskell  : English : []
16:06:35 <jle`> the spec itself is written in English, butI'm sure tere are versions transpiled to other languages
16:06:53 <ishmael> ok, well, i think that the runtime engine GHC uses is a C program
16:06:54 <EvanR_> > cast 'a' :: Maybe Char
16:06:56 <lambdabot>  Just 'a'
16:07:02 <EvanR_> > cast 'a' :: Maybe Int
16:07:04 <lambdabot>  Nothing
16:07:17 <EvanR_> > cast (4::Int) :: Maybe Integer
16:07:19 <jle`> ishmael: sure, but what relevance is what language the runtime engine is written in, for your question?
16:07:20 <lambdabot>  Nothing
16:07:23 <EvanR_> maybe not
16:07:27 <jle`> are you asking about the AST that GHC parses the source code into?
16:07:50 <jle`> GHC parses haskell source code into an AST in Haskell, which presumably does differentiate expressions and declarations
16:08:00 <jle`> if only because expressions and declarations are different things in Haskell
16:08:02 <EvanR_> ishmael: you can ask what the type of an expression is, but not what the type of a declaration is
16:08:23 <EvanR_> you can evaluate an expression, but not a declaration
16:08:28 <jle`> expressions and declarations are just different concepts in Haskell
16:08:48 <jle`> the only similarity is that a haskell source file's text might contain both somewhere in them
16:09:19 <EvanR_> the source text is an image of the AST
16:09:52 <EvanR_> seeing it the other way might be delusional
16:10:20 <jle`> fair :)
16:10:23 <`Guest05> task: make AssertionFailed and AssertionFailedUser exchangeable, that is, for all A, B = any of them, fromException . toException :: A -> Maybe B returns Just ...
16:10:36 <jle`> although the haskell spec includes text/syntax rules for expressions and declarations
16:10:51 <jle`> so are those source text aspects a part of what an expression/declaration are?
16:11:24 <ishmael> ah, here is the answer to the question i was (or at least meant to ask)
16:11:44 <EvanR_> geopardy time
16:11:49 <`Guest05> thing: how do i get (fromException :: SomeException -> Maybe AssertionFailed) to return Just ...  for (toException $ AssertionFailedUser ...) ?
16:12:00 <ishmael> a value stored in a register or memory may have only one type: bit vector. However, bit vector is a polymorphic type and may come in several widths, e.g., bits8, bits32, or bits64. In addition to the bit-vector type C-- also provides a Boolean type bool, which can be computed by expressions and used for control flow but cannot be stored in a register or in memory.
16:12:03 <EvanR_> er jeopardy
16:12:48 <ishmael> i should have said, "lower level," not "behind the scenes." the former has more meaning, i think
16:13:03 <EvanR_> what does that have to do with declarations and expressions in haskell?
16:13:12 <jle`> if you're talking about runtime, neithre declarations nor expressions exist at runtime
16:13:15 <`Guest05> heh, is "more meaning" a total order?
16:13:20 <ishmael> i was wondering about their representation at execution time
16:13:31 <jle`> ah, yeah, at execution time, neither declarations nor expressions exist
16:13:44 <EvanR_> types dont exist either
16:13:45 <jle`> only values
16:13:53 <jle`> well, for GHC, at least
16:14:06 <EvanR_> values is a weird thing, runtime objects exist at runtime
16:14:14 <jle`> fair enough!
16:14:23 <jle`> in any case declarations and expressions definitely are not in the picture at all
16:14:45 <ishmael> jle`: do you mean for any language, or for haskell?
16:14:45 <jle`> they are aspects of haskell-the-language
16:14:51 <jle`> for Haskell
16:14:58 <jle`> they are semantic concepts of Haskell
16:15:06 <jle`> they don't have anything to do with what actually happens at runtime
16:15:07 <ishmael> ah, that's a great answer!
16:15:15 <EvanR_> haskell is a high level language which can be compiled into a more efficient form for execution
16:15:26 <ishmael> and that explains why i was having such a hard time expressing my question
16:15:30 <EvanR_> and that form looks way different
16:15:50 <jle`> yeah, you might be having a hard time separating the semantics of the language from how things are executed
16:16:28 <jle`> declarations and expressions are semantic concepts, but when a compiler wants to get things executed, they are both interpreted together to yield something runtimey
16:16:42 <ishmael> jle`: i still think like an imperative programmer. i just started learn you a haskell a week or two ago. first like real immersion into functional, or even higher level programming
16:17:20 <EvanR> the distinction should really be made in imperative languages too
16:17:30 <EvanR> one of many things you can take with you from haskell back to the real world
16:17:40 <jle`> maybe you can think of declarations and expressions as tools to write the recipe.  when you actually cook a dish, you aren't expected to throw the ink and picture and paper into the pot
16:17:50 <jle`> just the things that they describe (like the ingredients)
16:18:12 <ishmael> right, so you can have a conceptual distinction between a declaration and an expression that is not recognized by the actual execution
16:18:47 <EvanR> you might think that C the language reflects real computer architecture better, but it doesnt, which is why you hear about "the C VM"
16:18:49 <jle`> yeah, the distintion is a semantic one
16:19:00 <jle`> re: the language, not the execution
16:19:59 <EvanR> once you realize a given language doesnt really reflect precisely what a computer will do, you get the non trivial question of what programs really mean
16:21:03 <EvanR> you can get abstract answers that better reflect ways to think about stuff, more useful ways
16:21:45 <ishmael> EvanR: C, like any programming language, is an abstraction of the lower level of implementation. if you assume that, C is less abstract than haskell, and is more directly analogous to what the machine does at runtime
16:22:07 <EvanR> i dont believe that, but we dont have a metric for this right now
16:22:22 <jle`> i don't think it's true that programming languages are an abstraction of lower level implementation
16:22:33 <jle`> in general
16:22:52 <ishmael> EvanR: you dont believe the assumption, or you think the conclusion is non sequitur?
16:23:10 <EvanR_> none of it
16:23:46 <buttons840> I've been thinking a lot about a question from Bartosz Milewski (the category theory guy) who asked "Do we want to make programmers happy, or produce correct programs?"
16:23:57 <jle`> i'll admit that the need for programming languages came out of a desire of abstracting over lower level implementations
16:24:04 <EvanR_> compiled c programs, with their implementation defined runtime systems dont have the concept of struct, defined macros, functions, linkage, etc
16:24:11 <jle`> and that might be a purpose that they are applied to
16:24:29 <EvanR_> bitfields, trigraphs heh
16:24:30 <ishmael> EvanR_: you're saying, and i agree, that there is a inviolable distinction between a physical thing at the way we describe what it does
16:24:38 <ishmael> is that right?
16:24:52 <EvanR_> "what it does" is one thing, "what a given program means" is another
16:25:09 <EvanR_> even in C what it does is only a part
16:25:10 <nshepperd_> buttons840: i hope that producing correct programs would make programmers happy!
16:25:18 <EvanR_> a struct declaration does not do anything
16:25:33 <ishmael> it allocates memory
16:25:36 <EvanR_> a main function definition doesnt do anything
16:25:39 <EvanR_> no
16:25:53 <ishmael> oh, you mean at static time
16:26:00 <EvanR_> what is "at static time"
16:26:52 <jle`> a struct declaration doesn't allocate memory... allocating a value of a given struct does
16:26:55 <ishmael> when the program is not executing
16:27:19 <EvanR_> a declaration doesnt allocate memory ever
16:27:22 <jle`> if you declare a struct but never make any instances, it doesn't allocate any memory
16:27:41 <buttons840> nshepperd_: i would hope so too, but many seem to think it's too much work to be correct and instead want something that "just works"
16:28:11 <buttons840> "works [99.9% of the time] every time"
16:28:14 <Profpatsch> Gosh, the megaparsec docs for indentation are just so bad.
16:28:18 <Profpatsch> Or is that just me?
16:29:16 <Profpatsch> Most of it just doesn’t parse for me, neither gramatically nor content-wise.
16:29:46 <Profpatsch> pun intended.
16:30:02 <Profpatsch> well, that was a lie.
16:31:24 <ishmael> jle`: when that code is executed, memory is allocated
16:31:28 <ishmael> in C at least
16:31:43 <EvanR> declarations dont correspond to anything at runtime
16:31:51 <EvanR> its like types in haskell
16:31:54 <ishmael> they do in C
16:32:02 <ishmael> when theyre executed, memory is allocated
16:32:03 <EvanR> no, you wont find it anywhere in memory
16:32:09 <EvanR> you dont execute declarations
16:32:17 <EvanR> you execute statements
16:33:07 <buttons840> the most recent example of working yet incorrect software was a coworker who wanted to write tabular data into a CSV, rather than dealing with quoting and escaping (which can handle ANY combination of characters), he's using "~|~" as a delimiter, because that would never appear in text on it's own, right?   it's a difficult argument because his strategy has been very reliable, yet it is not correct 
16:33:07 <ishmael> a declaration is a statement which requests a given amount of memory to be allocated on the stack
16:33:08 <Profpatsch> I’d say this here should parse integers indentedy by two spaces:
16:33:10 <Profpatsch> i = indentBlock (void spaceChar) (pure $ IndentSome (Just $ unsafePos 2) pure integer)
16:33:13 <buttons840> because there are certain valid inputs that will break everything
16:33:17 <EvanR> you could come up with the meaning of all these things, but thats not a good one
16:33:20 <Profpatsch> parseTest (i :: Parsec Dec String [Integer]) ""
16:33:34 <Profpatsch> But every conceivable input just errors out somehow
16:33:43 <ishmael> when int n; is executed, a word is allocated on the stack
16:33:54 <EvanR> no
16:34:12 <ishmael> not sure why you think that....
16:34:32 <Tuplanolla> If you read the C standard carefully, it doesn't even mention "stack" or "heap", ishmael.
16:34:38 <EvanR> well i am kind of sure why you think that, but if you wan more info on this you need to go to ##c
16:35:37 <EvanR> besides we were talking about struct declarations, not local variables
16:36:41 <EvanR> haskell declarations at the top level are similar, they dont do anything. but you might ask what they mean, and the haskell report explains it
16:36:53 <ishmael> write a c program int main { int i; printf("%i\n",i); return 0 }
16:37:00 <ishmael> it will compile and execute
16:37:49 <EvanR> struct A{ int i; }; int main { return 0; }
16:37:58 <dmwit> Is this argument related to Haskell?
16:38:08 <EvanR> ##c
16:38:12 <dmwit> yes please
16:39:30 <ishmael> (and if you were to  print the memory location of i, it wouldnt output "in theory") kbye
16:39:34 <ishmael> and thanks for your help!
16:39:42 <ishmael> w the haskell stuff, i mean
16:42:22 <Tuplanolla> I wonder why C attracts so much cargo cult knowledge about memory management.
16:42:30 <Tuplanolla> That never comes up here.
16:42:44 <johnw> when you think in terms of pointers and memory cells, it sort of follows naturally
16:42:46 <jle`> i think it tricks you into believing you know what's going on
16:43:01 <monochrom> Just wait until the next time someone has a "space leak" and ask here!
16:43:07 <dmwit> Tuplanolla: You're kidding, right? How many times have you dispelled the "no Haskell doesn't automatically memoize things" myth?
16:43:20 <monochrom> There will be cargo culting about thunks.
16:43:38 <johnw> yes, the common believe that all space leaks = too many thunks
16:44:16 <monochrom> In fact the whole etymology of so-called "space leak" is based on cargo culting on the "leak" word.
16:44:34 <johnw> so much cargo, so many cults
16:45:04 <monochrom> I now propose that we s/thunk/cargo/g
16:45:06 <Tuplanolla> Not once, dmwit, but now that I think about it, these things do come up occasionally.
16:47:56 <jle`> haskell runtime works by allocating cargos
16:48:04 <monochrom> \∩/
16:48:23 <tom7942> how come ghci hangs when you write: let bot = bot in bot ? 
16:48:25 <jle`> evaluation is simply culting those cargos
16:48:34 <jle`> tom7942: it tries to print out bot
16:48:37 <jle`> but like, what is it even
16:48:43 <tom7942> can it give up after a billion recurse?
16:48:53 <EvanR> should it give you cant find Show instance for ambiguous type or some such
16:48:59 <jle`> are you asking of it *does* give up?
16:49:04 <monochrom> It doesn't. But you can modify GHCi's source code so it does.
16:49:06 <jle`> or if it is theroetically possible to have it give up
16:49:24 <tom7942> jle`: asking if I can make it give up eventually with an option or something
16:49:29 <dmwit> tom7942: It does give up, after just one recursion. But it doesn't notice for a few esconds.
16:49:32 <EvanR> actually for me it does this
16:49:35 <EvanR> *** Exception: <<loop>>
16:49:42 <monochrom> EvanR: There is extended defaulting that chooses ().
16:49:55 <mniip> 1487378902 [03:48:22] <tom7942> can it give up after a billion recurse?
16:49:58 <dmwit> tom7942: In the meantime you'll notice that it's not using any CPU.
16:49:58 <jle`> > let bot = bot in bot
16:50:02 <mniip> but then you can't sum numbers from 1 to billion
16:50:04 <monochrom> Because it's also how "print []" works.
16:50:04 <lambdabot>  mueval-core: Time limit exceeded
16:50:06 <EvanR> i enabled solving the halting problem
16:50:06 <tom7942> yeah I never get that exception, it just spins
16:50:12 <tom7942> haha
16:50:13 <tom7942> neat
16:50:37 <tom7942> dmwit:  indeed, it's not burning my battery at least :)
16:51:01 <dmwit> tom7942: Try compiling it.
16:51:07 <EvanR> agreed stopping after one billion steps would render a lot of stuff useless
16:51:14 <EvanR> like video games
16:51:18 <tom7942> oh, i was just throwing out a number
16:51:18 <dmwit> `main = let bot = bot in print bot` or even just `main = main`
16:52:06 <monochrom> "Haskell is unsuitable for games because it stops your game after a million steps."
16:53:00 <EvanR> haskell is unsuitable for heaters because it throws <<loop>> instead of spinning forever
16:53:13 <monochrom> "Haskell is superb for servers because it can handle a million connections per second. But it is unsuitable because it stops after a million steps."
16:53:16 <tom7942> apparently my ghc is borked, i can't compile things
16:53:21 <tom7942> TIL
16:53:26 <yushyin> monochrom: headline of the next hot topic on reddit
16:54:19 <tom7942> mniip:  yeah i was expecting the <<loop>> exception
16:55:31 <EvanR> actually spawning a thread a blocks forever comes up, in which case you have to trick the system with a very long sleep time
16:55:52 <EvanR> that repeats
16:56:30 <EvanR> like if youre simulating a future that will never happen
16:57:54 <monochrom> Yeah, if you just try to wait on an MVar that nobody else knows, the runtime system actually notices it.
16:58:22 <jle`> lucky for us ghc has solved the halting problm
16:59:42 <monochrom> Very harsh thing on Valentine's Day for the runtime system to notify you "No one is dating you!"
17:00:25 <mniip> > sum' [0..1000000000]     500000000500000000      (176.22 secs, 144,000,080,824 bytes)
17:00:32 <lambdabot>  error:
17:00:32 <lambdabot>      • Variable not in scope:
17:00:32 <lambdabot>          sum'
17:01:51 <`Guest05> > (sum' :: _) [0..1000000000]     500000000500000000      (176.22 secs, 144,000,080,824 bytes)
17:01:53 <lambdabot>  error:
17:01:53 <lambdabot>      • Variable not in scope: sum'
17:01:53 <lambdabot>      • Perhaps you meant ‘sum’ (imported from Data.List)error:
17:01:54 <monochrom> You... have... 144GB of RAM?!
17:02:18 <`Guest05> no typeholes here..
17:02:36 <EvanR> > "world" (176.22 secs, 144,000,080,824 bytes)
17:02:39 <lambdabot>  error:
17:02:40 <lambdabot>      • Couldn't match expected type ‘(t0, Integer, Integer, Integer, t1)
17:02:40 <lambdabot>                                      -> t’
17:02:49 <EvanR> what are you freaks trying to do
17:03:13 <monochrom> #! /usr/bin/env stack --lts-7.12 (176.22 secs, 144,000,080,824 bytes)
17:03:23 <`Guest05> :t let sum' = undefined; _ = sum' [0..1000000000]     500000000500000000      (176.22 secs, 144,000,080,824 bytes) in sum'
17:03:26 <lambdabot> error:
17:03:26 <lambdabot>     • Variable not in scope: secs
17:03:26 <lambdabot>     • Perhaps you meant ‘sets’ (imported from Control.Lens)
17:03:30 <Sornaensis> :t undefined
17:03:32 <lambdabot> a
17:03:39 <Sornaensis> :t unsafePerformIO
17:03:40 <lambdabot> error: Variable not in scope: unsafePerformIO
17:03:44 <`Guest05> :t let (sum', secs, bytes) = undefined; _ = sum' [0..1000000000]     500000000500000000      (176.22 secs, 144,000,080,824 bytes) in sum'
17:03:45 <mniip> monochrom, uh no
17:03:46 <lambdabot> error:
17:03:46 <lambdabot>     • No instance for (Fractional (t2 -> t0))
17:03:46 <lambdabot>         arising from the literal ‘176.22’
17:04:13 <mniip> it's showing the total allocations
17:04:23 <monochrom> OK that's better.
17:04:35 <mniip> which might very well have exceeded 144 GB but it was using under 0.2% of ram the whole time
17:04:43 <monochrom> But now everyone thinks that you have to end every line with (176.22 secs, 144,000,080,824 bytes)
17:05:00 <monochrom> Like it is the new fullstop punctuation or something.
17:05:05 <EvanR> kind of like please in intercal
17:05:36 <mniip> welp
17:05:40 <mniip> that's 100x slower than C
17:06:14 <monochrom> Using gmp in C?
17:06:22 <EvanR> using Int?
17:06:26 <mniip> long long int
17:06:29 <Sornaensis> using computers?
17:06:29 <mniip> in ghci I used Int
17:06:39 <monochrom> Ah OK.
17:06:42 <Lokathor> i ain't never used a computer in my life
17:06:45 <Lokathor> and i won't start now
17:07:28 <monochrom> Lokathor: You will like Dijkstra. He reasoned about programs rather than run them.
17:07:56 <Lokathor> i'm afraid that logic is against the code of the Real Programmer (tm) as well
17:12:04 <mniip> actually
17:12:23 <mniip> a naive for loop in C takes 1.5s while a good strict loop in haskell is 0.3s
17:12:42 <mniip> though, if the C loop is less naive the compiler just calculates the results as a compile-time constant
17:13:10 <mniip> it's just that ghci is slow
17:13:19 <EvanR> i guess it knows that kind of loop is terminating
17:13:46 <EvanR> i vaguely recall an entire course on optimization of C loops
17:14:59 <monochrom> https://plus.google.com/u/0/102208456519922110915/posts/DZsZ6mvA4T6
17:22:09 <EvanR> what
17:22:45 <EvanR> proof in C that int is arbitrary precision
17:31:38 <monochrom> Nah, what shachaf said, undefined behaviour so the compiler can do what's simple.
17:33:25 <monochrom> Also try this with GHC.  x, y :: Int;  (x, y) = divMod (y+1, x+2).
17:33:46 <monochrom> ghc -O -ddump-prep  and see what happens.
17:34:04 <augur> hey peeps
17:34:29 <augur> anyone know any good follow-ups to CalcFP that make good on the promise of the paper to show show how to actually calculate functional programs?
17:51:48 <`Guest05> monochrom: how, in interpreter or print in main?
17:52:57 <monochrom> Sorry, what is the context again?
17:54:18 <`Guest05> [06:32:52] <monochrom> Also try this with GHC.  x, y :: Int;  (x, y) = divMod (y+1, x+2).
17:54:18 <`Guest05> [06:33:13] <monochrom> ghc -O -ddump-prep  and see what happens.
17:54:19 <mniip> monochrom, am I looking for Main.x = case ds_r3Ti of _ [Occ=Dead] { }
17:55:06 <mniip> haha, fun: ds_r3Ti = ds_r3Ti
17:57:57 <monochrom> Yes, you should see how all the +1 and +2 and divMod disappear and the generated code just uses the simplest way to express a blackhole or something.
17:58:17 <monochrom> It is very analogous to my C example.
17:58:39 <monochrom> Both compilers decide that I have a semantic infinite loop so why bother.
17:59:15 <monochrom> `Guest05: At your OS's shell's command line.
17:59:49 <monochrom> You will need to put the code in a file and give the filename.
17:59:50 <`Guest05> monochrom: no new information :/
17:59:54 <`Guest05> okay
18:02:44 <`Guest05> hmmm
18:02:46 <`Guest05> i see something
18:02:54 <`Guest05> then:
18:02:58 <`Guest05> realgcc.exe: fatal error: no input files
18:02:58 <`Guest05> compilation terminated.
18:02:58 <`Guest05> `gcc.exe' failed in phase `Assembler'. (Exit code: 1)
18:02:58 <`Guest05>  
18:03:12 <MarcelineVQ> did you call gcc instead of ghc
18:03:19 <`Guest05> no..
18:03:25 <MarcelineVQ> sounds bad then
18:03:50 <`Guest05> wait... is my ghc doomed?
18:03:50 <geekosaur> dd you put it in a file with a .hs extension?
18:03:54 <`Guest05> yes..
18:04:19 <MarcelineVQ> also "<monochrom> Also try this with GHC.  x, y :: Int;  (x, y) = divMod (y+1, x+2)."   did you mean  x, y :: Int;  (x, y) = divMod (y+1) (x+2)
18:04:44 <`Guest05> though, it was on other drive, and when i cd'd to it, it worked
18:06:14 <EvanR> spooky side effects of cdihg
18:06:16 <EvanR> cding
18:07:16 <monochrom> Yes MarcelineVQ
18:11:49 <`Guest05> hmm
18:12:15 <`Guest05> will ghc -O remove mapException if inner code hasn't any exceptions?
18:15:30 <ezyang> I don't think so, but it wouldn't be that far fetchedd 
18:23:55 <MarcelineVQ> going through my list of tools I'd like to see here, does anyone know of a utility that dumps the defintions you've made in a ghci session to a source file?
18:26:07 <suzu> you could use `script`
18:26:22 <suzu> script  makes a typescript of everything displayed on your terminal.  It is useful for students who need a hardcopy record of an interactive session as proof of an assignment, as
18:26:23 <suzu>        the typescript file can be printed out later with lpr(1).
18:26:25 <suzu>        If the argument file is given, script saves the dialogue in this file.  If no filename is given, the dialogue is saved in the file typescript.
18:27:15 <geekosaur> otherwise I don't know of any, and ghci is not especially good at that kind of thing
18:27:24 <geekosaur> might see if ihaskell fits better
18:27:35 <MarcelineVQ> I'm interested in making one but I wanted to make sure it wasn't explored
18:27:39 <MarcelineVQ> suzu: thank you
18:27:43 <geekosaur> there's also trawling the history
18:28:04 <geekosaur> ~/.ghc/ghci_history on linux
18:28:12 <geekosaur> and probably os x
18:30:04 <suzu> oh yes ghci_history would be good too
18:38:59 <glguy> `Guest05: Exceptions can come from other threads. It's not possible to know that an exception couldn't occur
18:39:54 <`Guest05> glguy: "code hasn't exceptions" as in "obviously"
18:40:02 <`Guest05> like, 5 :: Int
18:40:04 <c_wraith> until the runtime gets more advanced, you can know that an exception won't happen if a pure computation doesn't allocate. :)
18:40:15 <`Guest05> whoah
18:40:17 <`Guest05> okay.
18:40:21 <`Guest05> allocations.
18:40:28 <c_wraith> (5 :: Int) allocates, at least potentially. :P
18:40:36 <`Guest05> ok you win.
18:40:55 <c_wraith> The optimizer might remove that, though, if it can prove it's used strictly.
18:41:42 <glguy> Code doesn't have to be able to throw exceptions for another thread to throw an exception to it
18:45:55 <ubsan> I'm trying to figure out how to case statement
18:46:32 <ubsan> how would I do the equivalence of `match a { b @ ExprTrue => ..., ... }`
18:46:39 <ubsan> (Rust)
18:47:42 <glguy> case a of ExprTrue -> ...; ...
18:48:08 <ubsan> glguy: yeah but I want it to be bound to a variable
18:48:25 <ubsan> that's that `a @` syntax
18:48:30 <ubsan> because I'd like to do something like
18:48:43 <glguy> It's already bound to a
18:48:50 <ubsan> match a { b @ ExprTrue | b @ ExprFalse -> b, ... }
18:48:51 <glguy> otherwise you can use the same @ for an "as-pattern"
18:49:36 <lordcirth_> So I'm not very good with monads yet.  If I have a State wrapping a GameState datatype, is it easy to bind functions, which themselves call functions which operate on the State?
18:49:49 <ubsan> > 
18:49:49 <ubsan> main.hs:131:5: error: Parse error in pattern: b @ExprTrue
18:49:51 <lambdabot>  <no location info>: error: not an expression: ‘’
18:49:54 <ubsan> glguy: ^
18:50:10 <ubsan> with the expression
18:50:25 <ubsan> case (eval a) of b @ ExprTrue | b @ ExprFalse -> ExprFail (ExprSucc b)
18:50:27 <glguy> ubsan: You can paste your code to lpaste.net ; I don't know what you did wrong from that
18:50:29 <lordcirth> ubsan, emptystring is not an expression, this seems reasonable?
18:50:43 <lordcirth> oh nvrm
18:50:43 <glguy> ubsan: You use a ; to separate case alternatives
18:51:01 <ubsan> glguy: so like, b @ ExprTrue; b @ ExprFalse
18:51:01 <ubsan> ?
18:51:13 <glguy> ubsan: and there is no syntax for "or-patterns"
18:51:20 <glguy> which is perhaps what you were trying to do with the |
18:51:23 <ubsan> ergh
18:51:23 <ubsan> why
18:51:29 <glguy> because
18:51:33 <c_wraith> lordcirth: Pretend state actions are just like IO actions, and everything composes the same way.
18:52:07 <ubsan> ...
18:52:21 <lordcirth> c_wraith, as I said, I am not good with monads yet.  I understand how to use -> and so on, but haven't really worked with binding
18:52:32 <ubsan> I do not like haskell case syntax very much :[
18:52:52 <c_wraith> lordcirth: so, what are the types of a few actions you'll be working with?
18:53:47 <lordcirth> c_wraith, well mostly GameState -> (... more args ...) -> (GameState, output) if I'm understanding how to use a State correctly
18:54:35 <lordcirth> functions which take a GameState, and different args depending on function, and return a changed GameState and some value
18:54:37 <c_wraith> lordcirth: State is a wrapper for functions that look vaguely like that, but the whole point of it is that it removes those details
18:54:55 <dmwit> Normally stateful actions have types like `(... more args ...) -> State GameState output`.
18:55:08 <dmwit> These are easy to combine with the bind operation.
18:55:54 <lordcirth> dmwit, so rather than returning a tuple of two, you return a State containing the two, so you can bind?
18:56:36 <lordcirth> and the first item in the State must always be the same (GameState here) and the second can be anything depending on the function?
18:57:11 <dmwit> That sounds right.
18:57:11 <c_wraith> if you mean the first type argument to State, yes
18:57:25 <c_wraith> The type arguments need to align for bind to be well-typed
18:57:43 <lordcirth> So all functions/actions must have a return type of "State GameState a" ?
18:57:53 <dmwit> "must" is such a strong word
18:57:59 <lordcirth> should?
18:58:03 <dmwit> Let's say yes. But that's a first approximation to the truth.
18:58:20 <gtsteel> I'm trying to upload a package I wrote, but I'm getting a build error (FFI related) I can't reproduce. Any idea what's going on? https://hackage.haskell.org/package/maxent-learner-hw-0.1.1
18:59:27 <dmwit> Have you tried unpacking your tarball in a fresh directory and trying to build it?
18:59:48 <dmwit> It's possible the tarball doesn't have all the same files as your dev directory does.
19:00:56 <yushyin> ubsan: I guess haskell does not have it because it would be ambiguous and could also mean 'pattern guards'
19:01:15 <dmwit> That would be my first guess. My second guess would be about a library that's installed on your machine but not Hackage. But the function name it's looking for looks close enough to the function name it has that I suspect you wrote it in one of your C files, making that second guess seem much less likely to me.
19:01:50 <ubsan> yushyin: every time I try to use haskell, I keep hitting up against really dumb problems
19:03:15 <yushyin> that’s what happens every time I try to program in any language so far ^^
19:03:29 <gtsteel> builds fine in a clean directory. The function it's complaining about is an inline function defined in the same file where it's called. https://github.com/george-steel/maxent-learner/blob/master/ffisrc/packeddfa.c
19:04:02 <ubsan> mostly syntax
19:04:18 <ubsan> I really dislike small parts haskell's syntax
19:04:20 <ubsan> *of
19:04:34 <lordcirth> 'fst' and 'snd' do annoy me a bit
19:04:43 <ubsan> it's not stuff like htat
19:04:51 <lordcirth> no one would die if they used 4 letters
19:04:52 <ubsan> it's like, :: vs :
19:05:00 <ubsan> or -> vs =>
19:05:00 <lordcirth> ubsan, what's : ?
19:05:35 <ubsan> or haskell's specific method of whitespace dependence, which is shockingly bad, compared to other languages like F# or idris
19:05:42 <ubsan> lordcirth: cons
19:05:48 <lordcirth> right I'm dumb
19:05:51 <yushyin> -> vs => is so irrelevant
19:06:01 <lordcirth> further proof I need to get back to working on Haskell
19:06:04 <ubsan> yushyin: death by a thousand cuts
19:06:26 <lordcirth> whitespace dependence is controversial, for good reason
19:06:30 <lordcirth> record syntax needs work
19:06:40 <lordcirth> Other than that, I can't say I have major complaints
19:06:51 <ubsan> lordcirth: it's not whitespace dependence
19:06:55 <ubsan> it's haskell's specific method
19:07:09 <lordcirth> ubsan, what about it?
19:07:15 <ubsan> which is confusing. haskell's shitty errors about whitespace make it worse
19:07:21 * ubsan finds the gist
19:07:38 <`Guest05> ubsan: what's bad about thin arrows for function type instead of fat arrows?
19:07:47 <ubsan> `Guest05: not that
19:07:52 <ubsan> in case statements, => is better
19:07:58 <ubsan> -> for function types is goo
19:07:59 <ubsan> d
19:08:02 <`Guest05> ok
19:08:05 <lordcirth> meh
19:08:06 <`Guest05> why for case then?
19:08:08 <yushyin> you think it is better for what reason?
19:08:16 <ubsan> yushyin: because I like it better
19:08:25 <lordcirth> It's an arbitrary choice
19:08:26 <yushyin> ok so it is irrelavant
19:08:29 <`Guest05> why do you like it better?
19:08:45 <yushyin> e*
19:08:49 <ubsan> `Guest05: it makes it obvious that they're two different constructs
19:09:01 <ubsan> it's weird that -> for function types and -> for cases is the same operator
19:09:06 <`Guest05> ubsan: heh, there is also => in types
19:09:17 <`Guest05> syntax space for  arrows is tight
19:09:23 <ubsan> `Guest05: I guess so.
19:09:23 <lordcirth> but they are in different contexts.  I don't recall ever confusing the two
19:09:31 <ubsan> but I'm trained on idris
19:09:35 <ubsan> so I like => better
19:09:39 <ubsan> and also Rust
19:09:56 <ubsan> that's not a big thing at all, I just get annoyed about it
19:10:08 <ubsan> when I make the mistake and have to switch my code
19:11:07 <yushyin> just don’t sweat the small stuff?
19:12:08 <`Guest05> ubsan: just remember better that they have different arrows?
19:12:08 <ubsan> https://gist.github.com/ubsan/f8d45340792a394b84809b6626ffdb20
19:12:26 <ubsan> yushyin: the issue with it is just a small annoyance on a pile of bigger annoyances
19:12:57 <ubsan> like, {all this stuff sucks} *and also* {this small thing sucks}
19:13:45 <ubsan> whoever asked about whitespace dependence, that ^ gist
19:14:28 <gtsteel> dmwit: my c file is not using any external libraries
19:15:09 <glguy> ubsan: The definition of dirs must be indented more than dirs is
19:15:19 <ubsan> glguy: no I know
19:15:21 <ubsan> I hate that
19:15:33 <glguy> that's fine
19:21:21 <dmwit> gtsteel: For what it's worth, it builds on my machine, too.
19:25:35 <gtsteel> any idea what version of GCC hackage uses?
19:27:39 <lordcirth> I want to make ~/.stack/config.yaml make all projects GPL by default.  Is it the 'copyright' field that I want to change?  do I need to copy the GPL text into LICENSE?
19:31:26 <kadoban> lordcirth: You probably actually have to change the template itself. If you always use the same template, it's fairly easy, and you can set your own default template (which can just be a file on your hard drive)
19:32:18 <kadoban> https://github.com/commercialhaskell/stack-templates/blob/master/new-template.hsfiles is what you can start from, you can change the LICENSE file to the GPL text, with appropriate placeholders if they fit into the license text. And then change the license line in the .cabal file too.
19:32:41 <lordcirth> kadoban, oh ok.  I don't think I'll bother right now.  just did  "wget https://www.gnu.org/licenses/gpl-3.0.txt -O LICENSE "
19:32:55 <lordcirth> kadoban, by "the license line" do you mean "copyright" ?
19:33:13 <kadoban> Yeah, that's the easier way. You should also make sure you change the line in .cabal as well, so the metadata matches up.
19:33:31 <lordcirth> oh ok
19:33:37 <lordcirth> cabal + stack seems a bit clumsy
19:33:44 <kadoban> Naw, the copyright line is who has copyright, it's usually like   copyright: 2017 John Smith
19:33:50 <`Guest05> i'm using bytestrings which most time are from 64 to 256 bytes but occasionally are 2K and can rarely be as big as 60K. which ByteString flavor should i choose?
19:34:03 <kadoban> And license: specifies the license it's under, so you'd want to put I think GPL3 is a valid value. 
19:34:19 <EvanR> `Guest05: define "using"
19:34:48 <EvanR> generating them, accepting them as input, processing them in a pipeline, ...
19:34:55 <lordcirth> kadoban, I was trying to look up if it was "GPL3" or GPLv3, etc
19:35:15 <mac10688> what's the best documented haskell web server framework?
19:35:18 <kadoban> lordcirth: I can't remember where you look them up. If you do 'cabal check' it should tell you if the value is bogus I think.
19:35:47 <lordcirth> kadoban, oh that's handy!  Apparently it's "GPL-3"
19:36:17 <kadoban> Really? Hmm, wacky. I guess it makes sense though, kinda.
19:38:37 <lordcirth> kadoban, 'category' doesn't seem to be checked by cabal check.
19:39:48 <kadoban> I think things like that are free-form, I don't know that it has a way to check them.
19:40:16 <kadoban> Could be wrong though.
19:43:18 <`Guest05> EvanR: they are packets, i'm decoding and encoding them
19:50:23 <EvanR> `Guest05: i would try lazy bytestrings, but ultimately you will need to try both and profile them to see which is better
20:31:42 <`Guest05> hmmmmmmm
20:31:52 <`Guest05> idiom brackets for records
20:31:58 <Sinestro> How does one implement primitives in an cofree comonad AST? I can't figure out a way to combine the naïeve method (for use when interpreted, at least) of just using functions `AST -> AST`. :/
20:33:04 <`Guest05> [| Constructor { field1 = getWord8, field2 = getWord16le, field3 = getRemainingLazyByteString } |]
20:33:38 <`Guest05> why no IdiomBrackets yet in GHC...
20:39:27 <EvanR> how would that work
20:39:36 <EvanR> force you to write the fields in order?
20:44:35 <jle`> Sinestro: there should be some lifting functions in the library ou're using
20:46:40 <Sinestro> Lifting? I don't get the relevance. The issue is that `a -> a` over the recursive type doesn't permit a functor instance, which is required.
20:49:47 <jle`> can you give a concrete example?
20:50:15 <`Guest05> EvanR: equivalent to [| (\f1 f2 f3 -> Constructor { field1 = f1, field2 = f2, field3 = f3 }) getWord8 getWord16le getRemainingLazyByteString |]
21:00:01 <EvanR> equivalent to liftA4 Constructor getWord8 getWord16le getRemainingLazyByteString
21:00:06 <EvanR> er, liftA3
21:09:13 <`Guest05> EvanR: no, fields may have different order!
22:13:42 <fizbin> Anyone know how to interpret this error? "Stack space overflow: current size 33568 bytes."
22:14:13 <fizbin> Specifically, what's up with that number 33568 in there? I ran the program with +RTS -K8M
22:18:08 <jle`> fizbin: you should interpret it as a sign that you might be using an outdated GHC
22:18:41 <fizbin> How outdated? I'm apparently using 8.0.1
22:18:46 <jle`> oh, hm
22:18:54 <jle`> those things happened all the time with 7.6
22:19:12 <jle`> haven't seen that since
22:19:29 <fizbin> "those" being what? stack overflows in general, or ones where the numbers given make no sense?
22:19:42 <jle`> stack space overflows like that yes
22:19:52 <jle`> and the numbers are consistent with the kind of ones we got back then
22:27:57 <fizbin> Also, the stack trace -xc shows for where I'm getting the stack overflow makes no sense.
22:28:56 <spear2> hi all, does anyone know what is meant by a "linear type constructor" ? a constructor of a linear type, or it's some other meaning?
22:53:01 <jchia_1> I have a elementary category theory question. Can there be more than one arrow between u and v for some object u and some object v?
22:53:18 <jle`> yes
22:53:21 <jchia_1> i mean "more than one arrow from u to v"
22:54:08 <jle`> jchia_1: the case where there is at most one is a special case, called a thin category
22:54:09 <jchia_1> jle`: Then when you compose two arrows, (u -> v) and (v -> w), there could be multiple possible arrows (u -> w)?
22:54:25 <jle`> well, if you compose those two arrows, there is a unique result
22:54:34 <jle`> but that result is potentially not the only (u -> v)
22:54:38 <jle`> *not the only (u -> w)
22:54:55 <jchia_1> if there are multiple arrows (u->w), which arrow is the result of the composition?
22:55:04 <jle`> that depends on the category
22:55:48 <jle`> that's like asking "if there are multiple items in a group, which one is the result of x*y?"
22:56:03 <jle`> the result is a part of the definition of that group action
22:56:14 <jchia_1> jle`, so when you define a category, not only do you have to say what the objects and arrows are, if the category is not thin, you have to say how to compute composition?
22:56:21 <jle`> yes
22:56:42 <EvanR> that is the main question to answer, what you get when you smush two arrows together
22:56:52 <jle`> that's like saying if you define a group, you don't only have to say what the items are, but also what teh result of 'multiplication' is
22:57:06 <EvanR> and show that its associative and respects identity arrows
22:57:13 <jle`> so when you say that the integers is a group under +, you have to define what the result of 2 + 3, 2 + 4 is, etc.
22:57:32 <jle`> and that's actually the interesting part of the group
22:58:21 <jle`> jchia_1: are you familiar with groups/monoids?
22:58:35 <jle`> if you're familiar with Haskell, it's sort of like writing a Monoid instance
22:58:41 <jchia_1> jle`: No, only graphs, sets and some haskell types
22:58:43 <jle`> not only do you have to define what type is the Monoid, you also have to define (<>)
22:58:44 <EvanR> example, in the category of sets and functions, there are 4 functions from Bool to Bool
22:58:51 <jchia_1> and haskell monoids
22:58:54 <jle`> instance Monoid [] where
22:59:07 <jle`>     mappend = concat
22:59:18 <jle`> * Monoid [a]
22:59:29 <jle`> * (++)
22:59:44 <jle`> you have to give what type you're talking about ([a]), and also what it means to 'mappend' (here, (++))
23:00:46 <jle`> instance Monoid Int where
23:00:49 <jle`>     mappend = (+)
23:01:40 <jle`> here we define a monoid (Int, 0, (+)), which is what the items of the monoid are (values of type Int), the identity (0), and the mappending action (here, addition)
23:01:49 <jle`> we have to provide all three
23:03:06 <jle`> it's the same for defining a Category.  you have to provide what the objects are, what the morphisms are, how to generate the identity morphism for each object, and the composing action
23:04:09 <jchia_1> jle`: I get it. I was under the impression that you can only have one arrow from u to v.
23:04:36 <EvanR> a basic example of a category is sets as objects and functions between them as arrows
23:04:56 <EvanR> you can see for many sets there are more than one possible function
23:06:02 <jle`> jchia_1: one way you can think of a category is as a partial monoid
23:06:14 <EvanR> in the case of 1 -> N, there are an infinite number of functions
23:06:37 <jchia_1> EvanR: OK. I suppose if you try to draw the category, it's hard to it justice. You draw one arrow from one set to another set but it's really representing a multitude of functions.
23:06:43 <jchia_1> "hard to do it justice"
23:06:54 <EvanR> if your category is simple enough you can draw it completely
23:07:08 <EvanR> its ok to draw more than one arrow between the same pair of objects
23:08:11 <EvanR> heres one http://category-theory.mitpress.mit.edu/images/Art_P216.jpg
23:09:47 <jchia_1> EvanR: Yeah, but in the category where (large) sets are objects and arrows are functions mapping between them, there are potentially many arrows from one object to another, so realistically it can't be drawn.
23:09:55 <EvanR> in diagrams one arrow means one arrow, or else "insert whatever arrow you want here"
23:10:46 <EvanR> for finite sets you can think about it combinatorially
23:11:50 <EvanR> there are n^m functions from set of size m to set of size n
23:11:59 <jchia_1> how are some applications of category theory in haskell? are there libraries that are easier to understand/use if i know category?
23:12:13 <jchia_1> EvanR: yeah, that's exactly what i mean. too many arrows to draw on paper
23:12:25 <jle`> jchia_1: you might not even just want to draw a bunches of arrows because to make it useful you'd also have to label them
23:12:58 <jle`> jchia_1: well, on one level, you can use it to help with your program refactoring
23:13:24 <jle`> similar to monoids, you get associativity and stuff
23:13:56 <jle`> jchia_1: on another level, there's http://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Category.html
23:14:03 <jle`> which lets you write code that's polymorphic ove all Categories
23:14:26 <jle`> in the same way that you can use the Monoid typeclass to write monoid-polymorphic code.  like for Writer, and mconcat
23:14:40 <EvanR> so far i have no found CT directly beneficial to haskell coding
23:14:51 <EvanR> its just an interesting decorative thing
23:14:54 <jle`> jchia_1: but, to answer your more general question, category theory extends to more than just the definition of categories
23:15:17 <jchia_1> jle`: Roughly speaking, how can I apply category theory to do refactoring?
23:15:30 <jchia_1> Control.Category looks abstract. Are there examples of how to use it?
23:15:41 <jle`> Control.Category should look very familiar
23:15:52 <jle`> the Category typeclass is more or less the Monoid typeclass
23:15:54 <jle`> but higher-kinded
23:16:01 <jchia_1> jle`: it has the elements of category, but how do i write a program with it?
23:16:13 <jchia_1> "elements of category theory"
23:16:25 <jle`> do you understand why the Monoid typeclass is useful, or why knowing that something is a monoid is useful?
23:16:36 <EvanR> if you have arrows a, b, c, d of the appropriate types, you can do a . b . c . d
23:16:48 <jchia_1> jle`: Yes, it's polymorphic, i can work with a Monoid without knowing what kind of Monoid it is
23:16:58 <jle`> the only reason that we can have a Writer monad is because of the Monoid typeclass abstracting over monoids
23:17:22 <jle`> and yeah, it's similar here; you can do category-polymorphic things with any instance of Category
23:17:44 <jle`> practically though there are less interesting category-polymorphic things you can do than there are interesting monoid-polymorphic things you can do
23:18:05 <EvanR> just like in CT, you have to add extra powers to a category to get things to be interesting
23:18:19 <EvanR> which is what you have in kmett libs
23:18:36 <jle`> yeah, if you impose more structure on your categories, you can get some more interesting polymorphic things you can do with them
23:18:52 <jle`> kind of like how adding extra structure to Applicative gives you Monad, which lets you do more interesting things
23:19:19 <jle`> jchia_1: but on a refactoring level, there are libraries like 'pipes' that give you values that they claim are morphisms in some category
23:19:40 <jle`> jchia_1: so with that in mind you know that their composition operator is associative
23:19:46 <Cooler> > fmap (10/) (4, 5)
23:19:46 <jle`> jchia_1: and also that you have access to an identity at any time
23:19:49 <lambdabot>  (4,2.0)
23:20:00 <Cooler> why does that give 4?
23:20:04 <Cooler> 10/4 = 4?
23:20:06 <jchia_1> EvanR: Yeah, Control.Category looks like a "kmett lib" to me. I look at it and wonder how exactly I'm supposed to use it, and I try to find examples.
23:20:37 <glguy> Cooler: The fmap instance for (,)a can't touch the first component of the tuple
23:20:40 <jle`> Cooler: fmap doesn't change the first item
23:20:44 <jle`> > fmap (10/) ('a', 5)
23:20:48 <lambdabot>  ('a',2.0)
23:20:59 <Cooler> why?
23:21:17 <jle`> Cooler: its implementation is parametrically polymorphic, so it has to be the same no matter waht the type of the first item is
23:21:18 <fizbin> Because tuples aren't lists?
23:21:19 <jchia_1> jle`: I'm not sure what 'cat' is in the Category class
23:21:24 <jle`> jchia_1: cat is your instance
23:21:29 <jle`> sort of like Monoid m, m is the instance
23:21:45 <jle`> the Category typeclass is more or less identical to the Monoid typeclass, so if you understand one, you should understand the other
23:21:48 <jchia_1> jle`: What is cat a b?
23:21:52 <jchia_1> a function?
23:22:12 <jle`> Cooler: it's a value of 'cat' applied to two type parameters
23:22:21 <jle`> sort of like how you have fmap :: Functor f => (a -> b) -> f a -> f b
23:22:28 <jle`> 'f a' is f (the instance) applied to a type parameter, a
23:22:34 <jle`> oh sorry, that was meant for jchia_1 
23:22:42 <jle`> Cooler: what do you think fmap (10/) ('a', 5) should do?
23:22:57 <jle`> fmap :: (a -> b) -> (c, a) -> (c, b)
23:23:03 <jle`> that's the type of fmap for tuples
23:23:11 <Cooler> but why?
23:23:15 <jle`> :t fmap
23:23:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:23:19 <narasca> the functor is ((,) a)
23:23:29 <jle`> the tuple instance is `((,) c)`
23:23:37 <dmj`> Cooler: it can, since tuples are also bifunctors
23:23:43 <dmj`> > bimap (+1) (+1) (1,1)
23:23:47 <lambdabot>  (2,2)
23:23:55 <jle`> Cooler: so that's fmap :: (a -> b) -> ((,) c) a -> ((,) c) b
23:24:06 <jle`> Cooler: do you see why?  i replaced the 'f' (the Functor instance) with ((,) c)
23:24:16 <jle`> and so then we get fmap :: (a -> b) -> (c, a) -> (c, b)
23:24:29 <Cooler> ok
23:24:33 <jle`> the functor instance for tuples is ((,) c)
23:24:43 <jchia_1> jle`: I think I can use (->) as cat, correct? But then it's not that interesting, is it? I could just use regular haskell function composition. What's the point of using Category?
23:24:49 <fizbin> Cooler: I think part of the reasoning you're missing is that in general a 2-tuple has two different types for fst and snd.
23:24:53 <Cooler> so for a 3 tuple (a, b, c)  it would just affect c?
23:25:05 <jle`> jchia_1: that's like asking what's the point of using Monoids if i can always just use (+)/(||)/(++)/(*)
23:25:26 <jle`> jchia_1: you can use [a] is the Monoid instance and then your mappend is (++)
23:25:31 <jle`> so why bother with making a monoid instance
23:25:34 <jle`> when you can always just use (++)
23:25:37 <jchia_1> jle`: Could you give me a few examples of useful things to use as cat?
23:25:44 <fizbin> Cooler: So the natural definition of fmap is only going to apply to one of the members
23:25:55 <jle`> jchia_1: do you mean, useful Category-polymorphic functions?
23:26:16 <jle`> jchia_1: or do you mean interesting Category instances
23:26:18 <Cooler> so for a 3 tuple (a, b, c)  it would just affect c?
23:26:23 <jchia_1> Category instances
23:26:30 <narasca> Cooler: that you cant do
23:26:47 <glguy> cooler: right
23:26:58 <jle`> jchia_1: i can, but remember that individual category instances aren't the 'neat' thing about using Category in haskell
23:27:10 <jle`> jchia_1: just like individual monoid instances aren't the neat thing about the Monoid typeclass
23:27:24 <jchia_1> i just want to understand with some concrete examples
23:27:39 <jle`> jchia_1: the common instasnce people are shown next is Kleisli m
23:27:50 <jle`> where newtype Kleisli m a b = K (a -> m b)
23:28:07 <fizbin> Cooler: You could define fmap applied to (a,b,c) to mean that (affect only the last one)
23:28:10 <jchia_1> jle`: I'm not familiar with Control.Arrow.
23:28:19 <jle`> this has nothing to do with Control.Arrow
23:28:27 <jle`> this is just a type that has a Category instance
23:28:33 <jle`> can you think of what it would be?
23:28:46 <jle`> what would (K f) . (K g) = ??
23:28:53 <fizbin> Cooler: But basic haskell doesn't define what fmap on a 3-tuple is
23:28:54 <jchia_1> jle`: Isn't Kliesli defined in Control.Arrow?
23:28:56 <fizbin> > fmap (+1) (0 , 0, 0 ) :: (Int,Int,Int)
23:28:59 <lambdabot>  error:
23:28:59 <lambdabot>      • No instance for (Functor ((,,) Int Int))
23:28:59 <lambdabot>          arising from a use of ‘fmap’
23:29:07 <fizbin> Cooler: ^^^
23:29:08 <jle`> jchia_1: it could be, but i'm giving you the definition here
23:29:17 <jle`> jchia_1: you can just think of it as a newtype wrapper over an (a -> m b) function
23:29:31 <Cooler> fizbin, why does it define fmap on a tuple given its so weird?
23:29:32 <jle`> newtype Foo m a b = MkFoo (a -> m b)
23:29:46 <jle`> jchia_1: can you write a Category instance for Monad m => m ?
23:29:54 <jle`> er
23:29:58 <jle`> Monad m => Foo m
23:30:06 <jle`> id :: Monad m => Foo m a a
23:30:21 <jle`> (.) :: Monad m => Foo m b c -> Foo m a b -> Foo m a c
23:30:21 <EvanR> a 3-tuple is strictly speaking superfluous
23:30:48 <fizbin> Cooler: Because it's useful? Also, after using it for a while it doesn't seem that weird.
23:30:50 <jle`> Cooler: you can think of the Functor, Applicative, Monad, Traversable, Foldable, etc. instances of tuple as treating the tuple as a tagged value
23:30:52 <EvanR> if you think of (a,b) functor as being some computation with read-only environment a, then the 3-tuple from earlier would be ((a,b),c)
23:31:00 <jle`> Cooler: an (Int, a) is an 'a' that's "tagged" with an Int
23:31:15 <jle`> Cooler: so fmapping a function over an (Int, a) would be mapping over the actual value, while leaving the tag unchanged
23:31:24 <jle`> jchia_1: let me know if you want me to spoil the answer for you :)
23:31:49 <EvanR> and at the point you have (((a,b),c),d) you probably want a record in that spot 
23:32:20 <EvanR> binary products implies all finite products
23:32:45 <fizbin> EvanR: Unless you've gotten yourself tied in knots and at that point are addicted to &&& and *** etc.
23:32:50 <jchia_1> (MkFoo x) . (MkFoo y) = MkFoo (x >=> y)
23:33:10 <jle`> jchia_1: yup.  well actaully MkFoo (x <=< y), for the types to line up
23:33:10 <jchia_1> jle`: Maybe i got the direction wrong, hold on
23:33:16 <EvanR> arrows are sad
23:33:54 <jle`> jchia_1: so you found out that for the (a -> m b) instance of Category, (.) is just kleisli composition
23:34:06 <jle`> so kleisli arrows form a category, with (>=>) as their composition action
23:34:30 <EvanR> isnt it <=<
23:34:46 <jle`> sure :o
23:34:47 <jchia_1> jle`: OK, so I could write some code in terms of Category that I could use on monads and functions, among other things.
23:34:53 <EvanR> this is haskell we do everything backwards
23:34:57 <EvanR> and we like it
23:35:00 <jle`> jchia_1: yeah, yu can use it for kleisli arrows, and also for functions
23:35:24 <spear2> lol i look away for 2 minutes and "there can be more than one arrow between objects a and b" becomes "so kleisli arrows form a category, with (>=> as their composition action"
23:35:27 <jle`> but this is kind of yawn bc there aren't too many occasions where you think "oh i wish i could write something that is generalized for both normal functions and kleisli arrows"
23:35:54 <jle`> so while this is interesting, the Category typeclass ends up not being super useful for writing polymorphic code
23:36:15 <EvanR> bare categories dont have much going on
23:36:37 <EvanR> 2-categories maybe
23:36:49 <jle`> yeah, there just isn't enough structure to take advantage of
23:37:27 <jle`> jchia_1: another instance in base is (:~:) or type equality
23:37:38 <EvanR> every weirdo category is a valid category, but the key is your polymorphic code cant know about those non-standard details without extra assumptions
23:38:09 <EvanR> unlike in java where every Object has a huge array of bog standard support methods
23:38:43 <jle`> jchia_1: if you know about (:~:), then a value of (a :~: b) is a proof that 'a' and 'b' are the same type
23:39:10 <jle`> so, for the (:~:) category, `id :: a :~: a`, which says, "you can always get a proof that a type is the same as itself"
23:39:25 <jle`> and (.) :: (b :~: c) -> (a :~: b) -> (a :~: c)
23:40:02 <jle`> which says, "if i have a proof that 'b' is the same as 'c', and a proof that 'a' is the same as 'b', then i can make a proof that 'a' is the same as 'c'"
23:40:16 <jle`> so, for the (:~:) category, (.) is the transitive property of equality
23:40:56 <jle`> and 'id' is the reflexive property of euqality
23:41:00 <EvanR> every ordered set is a category in the same way
23:43:18 <jchia_1> jle`: How could I make use of this in a program?
23:43:38 <jchia_1> jle`: To somehow test for type equality?
23:44:00 <EvanR> :t testEq
23:44:01 <lambdabot> error: Variable not in scope: testEq
23:44:06 <jle`> jchia_1: well, in the context of this discussion, it gives you a familiar API to work with (:~:)
23:44:19 <jle`> if you know that (:~:) is an instance of Category, you already know that you have (.) and id
23:44:32 <EvanR> :t testEquality
23:44:33 <lambdabot> error: Variable not in scope: testEquality
23:44:34 <jle`> just like if you know IO is a Monad, you know that you have 'return' and (>>=)
23:45:05 <EvanR> if you are resorting to runtime testing of type equality, you are likely doing something wrong
23:45:23 <EvanR> and if youre not, then you know so much this advice doesnt matter
23:46:11 <jchia_1> EvanR: I only do run-time testing in other languages. However, isn't the exception mechanism in haskell doing something like run-time testing of type equality?
23:46:11 <jle`> yeah, this question sort of exists on three levels
23:46:46 <jle`> (1) how is (:~:) useful?;  (2) why is knowing that it has a Category instance usefu?;   (3) why is it being a Category instance useful
23:46:58 <EvanR> exceptions are dynamically typed indeed
23:47:06 <EvanR> its kind of embarassing
23:47:07 <jle`> for (2), it's that you can use a unified API, so you know that you can use id/(.) instead of whatever arcane name the normal API functions have
23:47:24 <jle`> for (3), it's because you can use Category-polymorphic functions like (<<<) on it
23:47:28 <jle`> for (1), that is beyond the scope of this discussion
23:47:38 <jchia_1> EvanR: I don't know how it could be better, though. Practically, an exception could be anything
23:47:51 <jchia_1> you could get an exception for all kinds of reasons
23:47:55 <EvanR> "_ could be anything" should sound like a red flag to you
23:48:10 <jchia_1> EvanR: Isn't that what happens when you write a real-world program?
23:48:22 <EvanR> and after getting into haskell "i dont know how it could be done better" has become the worse justification for anything
23:48:33 <jchia_1> the program can fail for all kinds of reasons outside its control
23:48:40 <EvanR> because i regularly am blown away by new solutions
23:48:54 <jchia_1> EvanR: enlighten me
23:49:40 <EvanR> i have a paper here which extends the idea of extensible records (products) with its dual: extensible variants (coproducts)
23:50:22 <EvanR> so you can use (co-)row polymorphism to talk about only some of the potential cases of a variant
23:50:36 <EvanR> which are identified by arbitrary labels
23:50:56 <EvanR> the end result is type safe and checked at compile time
23:53:42 <jchia_1> EvanR: what's the paper title?
23:54:08 <EvanR> https://www.microsoft.com/en-us/research/publication/extensible-records-with-scoped-labels/
23:57:49 <jchia_1> jle`, EvanR: Thanks for answering my questions.
23:58:31 <jle`> jchia_1: no problem!  the answers might not be too satisfying at this level, but that's sort of a universal consensus about the Category typeclass itself
