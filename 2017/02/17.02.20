00:00:01 <Cooler> how do you deal with recursive definitions for the parser?
00:00:29 <Cooler> in the json spec http://www.json.org/ an object parser needs a value parser and so does an array parser
00:00:44 <Cooler> but a value parser needs an object and an array parser
00:04:45 <Cale> Cooler: You just use recursion.
00:05:39 <Cooler> Cale, well i am actually doing this in javascript but in a functional way
00:05:43 <Cooler> https://plnkr.co/edit/eppjircbxmwL47lLlMsR?p=preview
00:06:03 <Cooler> i am building parsers for various things
00:06:22 <Cooler> basically that means returning functions that take a string as input
00:09:53 <Cooler> so in order to build a value parser i need an object and array parser
00:10:16 <Cooler> but in order to build those i need a value parser
00:10:26 <Cooler> so its gonna go into an infinite loop
00:13:11 <cocreature> Cooler: that’s not an infinite loop, that’s mutual recursion
00:13:29 <cocreature> it can of course turn into an infinite “loop” if you have no basecase
00:38:37 <gfixler> Bartosz keeps talking about C x C -> C in his bifunctors video, but I don't get why it's not C x D -> E
00:42:06 <Cooler> any ideas?
00:42:17 <Cale> gfixler: It could be, but maybe he's just not interested in bifunctors of that sort
00:42:41 <gfixler> Cooler: I feel like he just took everything from C, D, and E, and smooshed them into one category C
00:42:48 <gfixler> and that's a cartesian category...?
00:43:14 <gfixler> oh, I found it
00:43:22 <Cale> gfixler: If he's talking about Haskell, there's practically only one category we're usually concerned with anyway
00:43:26 <gfixler> he says "Because we're talking Haskell, it will be a category of C with itself"
00:43:30 <gfixler> Cale: yep
00:43:49 <gfixler> I must have dozed off @35:00
00:44:02 <gfixler> I did like that C x C -> C looked monoidal
00:44:13 <gfixler> and at the end of the talk he mentions something about its monoidalness
00:44:38 <gfixler> this answers a question I had earlier in the talk
00:45:06 <gfixler> which was "But aren't all of these the same category in Haskell?"
00:46:05 <tdammers> 19
00:46:13 <tdammers> hrrngh, ignore that
00:46:27 <gfixler> oh, right, it was because he said C x C -> C is really a functor from a *product* of 2 Hasks to Hask
00:46:40 <gfixler> and I thought "But aren't products of Hask still just Hask?"
00:47:17 <gfixler> so far, this is what's been tough about CT - all these little teeny details
00:48:40 <gfixler> and if C x C -> C, then it follows that (C x C) x (C x C) -> C x C -> C
00:48:44 <gfixler> and so on
00:49:02 <gfixler> infinite recursion
00:49:05 <gfixler> unless I'm missing something
00:53:35 <Cale> Hm?
00:53:41 <Cale> I'm confused about what you mean.
00:53:47 <gfixler> I may be as well
00:53:52 <Cale> C x C is a category whose objects are pairs of objects of C
00:53:57 <gfixler> right
00:54:00 <gfixler> but we're reusing C
00:54:01 <Cale> and whose arrows are pairs of arrows
00:54:07 <gfixler> which means some elements of C are C x C
00:54:09 <gfixler> no?
00:54:31 <gfixler> C is made of objects, some of which are products of things in C
00:54:32 <Cale> i.e. an arrow (X,Y) -> (Z,W) consists of some pair (f,g) with f: X -> Z and g: Y -> W
00:55:15 <Cale> We're taking a product of categories, not a product on objects of those categories
00:55:34 <gfixler> this is a constant source of confusion for me
00:55:38 <gfixler> mixing up levels
00:57:58 <gfixler> now I'm confused about the ->
00:58:02 <gfixler> C x C -> C
00:58:27 <gfixler> I thought it meant that the product of two categories C was itself in C
01:02:32 <gfixler> I think it's Hask tripping me up
01:02:46 <gfixler> Bartosz wrote C x C -> C as a kind of stand-in for Hask, I think
01:02:54 <gfixler> in which case, what I was trying to say is [mostly?] right
01:03:28 <Cale> Well, it would be Hask x Hask -> Hask
01:03:31 <gfixler> yeah
01:03:42 <Cale> So, such a functor would take pairs of types to types
01:03:46 <gfixler> yep
01:03:49 <gfixler> which he goes over
01:04:06 <gfixler> and it is recursive, because you can keep doing that, and always stay in types
01:04:13 <gfixler> and that's where the monoidal nature of the category comes in
01:04:17 <gfixler> although you need an identity
01:04:24 <gfixler> I suppose it's a semigroup category otherwise?
01:04:39 <gfixler> maybe the word cartesian needs to go in there, too?
01:27:32 <maybefbi> im unable to avoid mistakes without a type checker. is that acceptable for a live coding interview?
01:27:54 <maybefbi> did the interviewer forgive minor type errors?
01:28:00 <maybefbi> in your case?
01:32:39 <maybefbi> example using (:) instead of (++)
01:55:54 <xeviox> is it possible to put every dependency into the repository (in source form like it's handled by Go) with any of the package managers?
01:56:04 <xeviox> (or build tools)
02:02:16 <BernhardPosselt> what is *> used for
02:02:29 <BernhardPosselt> deprecated?
02:03:24 <jle`> BernhardPosselt: *> is 'andThen'
02:03:42 <jle`> used for 'sequencing' applicative actions
02:04:33 <jle`> BernhardPosselt: putStrLn "hello" *> putStrLn "world" will return an IO action that prints 'hello', then 'world'
02:05:22 <maybefbi> in case of applicative parsers it can be used to skip spaces
02:05:37 <maybefbi> skipSpaces *> parseSomethingElse
02:05:58 <tfc[m]> isn't *> for applicatives, what >> is for monads?
02:06:08 <jle`> tfc[m]: *> is for Applicatives what *> is for Monads
02:06:15 <mauke> >>
02:06:23 <jle`> *> works for Monads too
02:06:39 <jle`> so "*> for monads" is just *>
02:06:48 <mauke> only because Applicative is now a superclass of Monad
02:07:33 <maybefbi> tfc[m], *> can be parallelized unlike >>, and *> cannot avoid the values inside their applicative functors
02:07:33 <gfixler> :t (*>)
02:07:36 <lambdabot> Applicative f => f a -> f b -> f b
02:07:50 <tfc[m]> i see
02:08:27 <tfc[m]> but when i am using stuff like MyType <$> (string "foo" *> many1 digit) then "*>" also cannot be parallelised?
02:08:53 <maybefbi> in that context no
02:08:59 <jle`> it depends on the Applicative instance you're using
02:09:09 <maybefbi> in that context you are using a parser
02:09:22 <maybefbi> which is an applicative instance 
02:09:37 <maybefbi> but i dont think it allows any form of parallel computing
02:09:56 <gfixler> that's something I've wondered; how can parsers be applicative if they're reading characters in sequentially?
02:10:02 <jle`> every instance gets to implement *> however it wants, so whether or not *> is parallel is up to the specific instance
02:10:41 <jle`> gfixler: applicative doesn't necessarily mean parallel
02:10:49 <jle`> the Applicative instance for IO sequences IO action sequentially
02:11:02 <gfixler> jle`: sure
02:11:14 <gfixler> I guess my real question is about the point of applicative parsing in general 
02:11:27 <gfixler> but I'm just wondering aloud now
02:12:07 <tfc[m]> gfixler: well the syntax is really nice.
02:12:29 <maybefbi> gfixler, i guess it allows parsers to be reused to generators. but im not sure
02:12:43 <maybefbi> iirc one of the laws of <*> allow this
02:13:12 <maybefbi> s/to generators/as generators/
02:13:12 <gfixler> I wondered about things like parsing non-sequential things
02:13:16 <gfixler> e.g. trees of information
02:14:17 <tfc[m]> yeah but in unparsed form they are sequential, no matter how non-sequential they are after parsing
02:14:57 <gfixler> parsers don't have to be only of text, though
02:15:05 <gfixler> you can have parsers of sensor input, e.g.
02:15:54 <gfixler> I could imagine parsing something from its center outward
02:16:08 <gfixler> especially if it were already some kind of binary tree - you could keep doing that, recursively, perhaps
02:17:54 <BernhardPosselt> jle`: oh nice :)
02:18:20 <BernhardPosselt> haskell people have a strange fetish for weird infix functions
02:18:33 <BernhardPosselt> names*
02:28:34 <dramforever> What are some convincing arguments that show the benefits of non-strict semantics outweigh the performance penalty of a lazy implementation?
02:29:26 <ezyang> I always notice the thing where the naive definition of 'map' doesn't take O(n) space 
02:29:46 <ezyang> streams are everywhere 
02:30:03 <tdammers> transparent eta reduction, infinite lists, "TCO" for "free"
02:31:08 <Rembane> Working with infinity in a reasonable way
02:31:11 <dramforever> Uh, actually I asked it badly. I'm more interested arguments in the other direction, showing that lazy evaluation isn't really inefficient
02:32:03 <dramforever> What are some convincing arguments that show the performance penalty of a lazy implementation is small enough to be worth it?
02:32:09 <ezyang> there's this thing called strictness analysis which is all about optimizing away the cost of lazy evaluation when it's not needed 
02:33:15 <tdammers> dramforever: to me, the kicker argument in this context is that the lazy evaluation overhead is linear, but the gain, when it exists, is exponential-ish
02:33:37 <dramforever> Do we have something like Debunking the 'Expensive Lazy Evaluation' Myth?
02:34:07 <dramforever> (Akin to Debunking the 'Expensive Procedure Call' Myth, or, Procedure Call Implementations Considered Harmful, or, Lambda: The Ultimate GOTO)
02:34:25 <ezyang> dramforever: Well, laziness is kind of expensive 
02:34:44 <tdammers> afaik, procedure calls *are* expensive, just not in an interesting way that would make for a good argument against using them
02:35:16 <ezyang> But it's all relative. Tell me why the overhead of a PHP interpreter is worth it 
02:37:31 <dramforever> ezyang: What does your experience tell you about strictness analysis? How well does it work in practice?
02:38:03 <ezyang> I don't know, because for the things I work on CPU is basically never the bottleneck 
02:41:27 <dramforever> Sorry, was disconnected earlier
02:41:52 <tdammers> ezyang: the overhead of a PHP interpreter is worth it because PHP is all you know, and all you will ever be comfortable with, and besides, PHP7 is fast now, yolo
02:45:37 <dramforever> tdammers: Sadly too many are obsessed with making their 3s-run-time network-intensive apps 10us faster, even if it's just about a *claim* that 'strict evaluation is faster than lazy evaluation'
02:53:40 <ezyang> Ooh, programming with Brick is fun 
02:57:44 <gargawel> Hi, is there something like a priority queue in base ?
02:59:35 <ezyang> gargawel: Not publically. (There actually is a priority queue for the event manager but you're not supposed to use it) 
03:01:21 <gargawel> ezyang: OK. Seems quite surprising.
03:10:30 <jophish_> Is there a way to install a packages documentation only, so I can browse documentation without building the package?
03:32:54 <systadmin> heyo
03:36:44 <quchen> gargawel: You can easily build a priority queue as a wrapper around a »Map Double a«. Map has an API function to get the element with the largest/lowest index.
03:37:02 <quchen> Map isn’t in base, but part of the used-everywhere-de-facto-standard.
03:37:11 <systadmin> Is there a way to remove a certain element from a list?
03:37:20 <quchen> :t delete
03:37:23 <lambdabot> Eq a => a -> [a] -> [a]
03:37:24 <systadmin> Like an expression that removes the 2nd and 4th element?
03:37:32 <quchen> > delete 3 [1..10]
03:37:35 <lambdabot>  [1,2,4,5,6,7,8,9,10]
03:38:06 <systadmin> > delete 2, 4 [1, 2, 3, 4]
03:38:08 <lambdabot>  <hint>:1:9: error: parse error on input ‘,’
03:38:12 <quchen> I don’t think there’s a standarf function for indexed deletion.
03:38:37 <gfixler> > foldr delete [2,4] [1,2,3,4]
03:38:43 <lambdabot>  []
03:38:46 <gfixler> done
03:38:52 <yushyin> :t deleteBy
03:38:55 <lambdabot> (a -> a -> Bool) -> a -> [a] -> [a]
03:39:49 <quchen> > let deleteNth n xs = let (as,b:bs) = splitAt n xs in as ++ bs in deleteNth 4 "hello world" -- Delete index N.
03:39:53 <lambdabot>  "hell world"
03:40:10 <gfixler> guess that should have been reversed
03:40:17 <gfixler> > foldr delete [1,2,3,4] [2,4]
03:40:20 <lambdabot>  [1,3]
03:41:04 <systadmin> :t foldr
03:41:07 <quchen> systadmin: You can write the function yourself as an exercise.
03:41:08 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
03:41:17 <gfixler> what about take and drop?
03:41:42 <quchen> It’s similar to how »drop« and »take« are implemented, only that you’re not dropping everything up to/beginning from your element.
03:42:01 <gfixler> > let x = 3 in xs = [0..9] in take x xs ++ drop x xs
03:42:07 <lambdabot>  <hint>:1:17: error:
03:42:07 <lambdabot>      parse error on input ‘=’
03:42:07 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
03:42:08 <gfixler> > let x = 3, xs = [0..9] in take x xs ++ drop x xs
03:42:13 <lambdabot>  <hint>:1:10: error: parse error on input ‘,’
03:42:19 <gfixler> > let x = 3; xs = [0..9] in take x xs ++ drop x xs
03:42:22 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
03:42:27 <gfixler> I give up
03:42:44 <gfixler> > let x = 3; xs = [0..9] in take x xs ++ drop (x + 1) xs
03:42:47 <lambdabot>  [0,1,2,4,5,6,7,8,9]
03:42:50 <quchen> ?check \n xs -> xs == take n xs ++ drop n (xs :: Int)
03:42:53 <lambdabot>  error:
03:42:53 <lambdabot>  • Couldn't match expected type ‘Int’ with actual type ‘[()]’ • In the second...
03:43:31 <quchen> ?check \n xs -> xs == take n xs ++ drop n (xs :: [Int])
03:43:35 <lambdabot>  +++ OK, passed 100 tests.
03:43:36 <quchen> Take plus drop is id :-)
03:43:42 <gfixler> :)
03:44:46 <quchen> gfixler: And splitAt n xs = (take n xs, drop n xs)
03:44:51 <quchen> (But more efficient)
03:48:06 <gfixler> > let x = 3; xs = [0..9] in map snd $ filter ((/=x) . fst) (zip [0..] xs)
03:48:09 <lambdabot>  [0,1,2,4,5,6,7,8,9]
03:53:07 <chpatrick> is it possible to have a buildEnv that has the dependencies of haskell packages A and B without building either?
03:55:33 <ongy> if you can get the sources for A and B you can `cabal install --dependencies-only` both of them
03:55:35 <ongy> aaand I'm to late
04:01:32 <flxw> Hi. Could somebody please tell me if I am wrong, or if ghc-mod's refine command is not working for me. :-) Minimal example:
04:01:38 <flxw> f :: [Int] -> [Int]; f x = _a; main=return()
04:02:20 <flxw> When I try to refine _a by (:) it refines _a to (:) _a1 _a2.
04:03:11 <flxw> but when I try to refine by "filter", it does put in the word filter, but wothout the new holes fo rthe argumetns.
04:04:26 <flxw> ie. $ ghc-mod$ ghc-mod refine t.hs 1 28 filter
04:04:30 <cocreature> flxw: maybe it only works for constructors? I don’t use ghc-mod so I sadly can’t be of more help
04:04:32 <flxw> 1 28 1 30 "filter"
04:05:13 <flxw> but the ad showed it with filter! ;_)
04:05:23 <flxw> *on
04:05:42 <cocreature> flxw: in that case reporting a bug is probably not a bad idea :)
04:07:49 <flxw> yeah. I haven't used ghc-mod before, so I wanted to at least check whether I'm completely off or not.
04:08:46 <flxw> Just for completeness sake: www.mew.org/~kazu/proj/ghc-mod/en/emacs.html
04:10:04 <flxw> but you'reright, I'll file a bug tonight. (I waswwant to try the repos HEAD before)
04:10:34 <flxw> *want
04:11:44 <tabaqui1> hi all
04:11:50 <gfixler> > liftA2 (++) fst snd $ (take 3 &&& drop (3 + 1)) "hello"
04:11:52 <Schrostfutz> The type of foldl is foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b. What is the -> t a doing in the definition? foldl takes only two paramerters, not three, doesn't it?
04:11:53 <lambdabot>  "helo"
04:11:55 <tabaqui1> where can I find concurrency patterns in haskell?
04:12:19 <tabaqui1> I have to write some code, but in my naive implementation it's too complicated
04:12:25 <gfixler> tabaqui1:http://chimera.labs.oreilly.com/books/1230000000929
04:13:07 <tabaqui1> gfixler: looks fine, thanks
04:13:17 <gfixler> Schrostfutz: no, it takes 3
04:13:55 <Schrostfutz> gfixler: Oh, you're right, thanks.
04:14:06 <gfixler> Schrostfutz: it takes the fold function, the starting value/accumulator, then the value to operate on
04:14:55 <gfixler> Schrostfutz: have a look at the behavior of foldr, foldl, and foldl' if you haven't encountered anything about them yet
04:15:58 <Schrostfutz> gfixler: I'm currently trying to understand the implemenation of foldl using foldr which is described in readl world haskell.
04:16:21 <quchen> Hah, that’s a tough one.
04:16:37 <gfixler> Schrostfutz: okay, I'm guessing that RWH goes over the issues with strictness and such
04:16:46 <quchen> I use it as a mental exercise every now and then ;-)
04:16:48 <Schrostfutz> quchen: Yeah, I noticed...
04:17:18 <gfixler> I should probably look through that again - it's been a couple of years, and I remember it being tough back then
04:17:43 <quchen> (And foldr does not have an accumulator by the way.)
04:18:50 <quchen> Schrostfutz: I wasn’t able to come up with the solution when I heard about foldr-for-foldl, but studying the solution proved useful.
04:19:18 <quchen> Schrostfutz: Try evaluating foldrViaFoldl (+) 0 [1,2,3] by hand.
04:19:29 <gfixler> it doesn't?
04:19:31 <gfixler> :t foldr
04:19:34 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
04:19:39 <gfixler> what's that b?
04:19:41 <quchen> (If you have the solution already. I could give it to you if you want.)
04:19:58 <quchen> b is the type of the resulting structure.
04:20:11 <quchen> ?src foldr
04:20:11 <lambdabot> foldr f z []     = z
04:20:12 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:20:12 <Schrostfutz> gfixler: I think it's not an accumulator but you rather use an 'init' value
04:20:15 <quchen> This accumulates nothing.
04:20:24 <gfixler> alright, semantics
04:20:24 <Schrostfutz> But my terminology is likely way of
04:20:36 <gfixler> I think of all the bs as b at different times
04:20:48 <gfixler> in the (a -> b -> b) it's the current and next b
04:20:52 <quchen> Semantics describe the meaning of things, and it’s fairly important.
04:20:54 <gfixler> the b arg is the starting b
04:21:01 <gfixler> and the final b is the ultimate/resultant b
04:23:29 <quchen> No, the b arg is not the starting b.
04:23:36 <quchen> There is no starting b. There is an ending b.
04:23:55 <quchen> (The 2nd argument to foldr)
04:24:07 <gfixler> > foldr (+) 0 [1,2,3,4]
04:24:10 <lambdabot>  10
04:24:13 <gfixler> > foldr (+) 5 [1,2,3,4]
04:24:16 <lambdabot>  15
04:24:20 <gfixler> sure looks like a starting value to me
04:24:39 <merijn> > foldr f z [1..5] :: Expr
04:24:40 <quchen> > foldr (:) [] [1,2,3,4] -- [] is not a starting value.
04:24:45 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 z))))
04:24:45 <lambdabot>  [1,2,3,4]
04:24:53 <merijn> gfixler: Looks like an ending to me...
04:25:10 <gfixler> is that why I got out 0 and 5?
04:25:31 <merijn> > foldr (+) 5 [1..5] :: Expr
04:25:33 <quchen> In »foldr f z xs«, »z« is not touched until the entire list »xs« is traversed.
04:25:35 <lambdabot>  1 + (2 + (3 + (4 + (5 + 5))))
04:25:53 <gfixler> are you talking about evaluation order?
04:27:15 <quchen> No. »foldl f z xs« recursively calls itself, and modifies the »z« in the process. That’s why we say that »z« accumulates something.
04:27:16 <quchen> Foldr does not do this.
04:27:42 <quchen> There is no recursion in foldr that modifies part of it. It builds up a chain of function calls (as merijn demonstrated).
04:27:49 <cocreature> if you want to be pedantic: foldr for lists doesn’t do this :)
04:27:57 <quchen> There is no field that is repeatedly modified to hold the result.
04:28:09 <quchen> cocreature: foldr for Foldable can do anything it wants because Foldable has no laws, so yeah.
04:28:26 <gfixler> I see where you're coming from now
04:28:32 <gfixler> and it was semantics
04:28:48 <gfixler> I wasn't concerned with the implementation of foldr under the hood
04:28:50 <quchen> Yes, it was semantics. Like calling »value« »rabbit« is semantics.
04:28:58 <gfixler> you sure are upset
04:29:01 <quchen> It likely leads to misunderstandings.
04:30:10 <gfixler> it's good, though, what you're doing
04:30:41 <gfixler> makes sure a lot of people more shy than me will never dare ask questions in here
04:31:13 <Cooler> why does fmap length $ (,) <$> getLine <*> getLine return 1?
04:31:29 <Cooler> >let x =  fmap length $ (,) <$> getLine <*> getLine
04:31:55 <liste> Cooler: because the Foldable instance of (,) concerns just the first element
04:32:00 <liste> > length (1,2)
04:32:04 <lambdabot>  1
04:32:51 <liste> Cooler: http://hackage.haskell.org/package/base-4.9.1.0/docs/src/Data.Foldable.html#line-305
04:33:05 <liste> the second element*
04:33:07 <liste> not the first
04:33:23 <liste> foldMap id (1,2)
04:33:25 <liste> > foldMap id (1,2)
04:33:29 <lambdabot>  error:
04:33:29 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M161567402854...
04:33:29 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
04:33:43 <merijn> liste: Numbers aren't monoids :p
04:33:46 <liste> yeah
04:33:47 <liste> :/
04:33:56 <liste> > toList (1,2)
04:34:01 <lambdabot>  error:
04:34:01 <lambdabot>      Ambiguous occurrence ‘toList’
04:34:01 <lambdabot>      It could refer to either ‘F.toList’,
04:34:13 <liste> results in [2]
04:34:46 <quchen> > F.toList (1,2)
04:34:53 <lambdabot>  [2]
04:34:54 <richardcq> Hi guys. I'm building an application using hedis (for the redis key-value store) and control.concurrent, and I'm thinking that the best way to handle locking/unlocking would be with setup, tear down, and rollback on error functions and a global list of keep-lock-alive lambdas that the main thread goes through every so often. I think this is a use case for making my own monad, but I just wanted some suggestions to make sure I'm d
04:41:11 <quchen> Schrostfutz: Anyway, foldr in terms of foldr is a good riddle, but probably not necessary as a beginner. But it’s a very interesting thing to learn about. The basic idea is that you can »add another parameter« to foldr that holds an arbitrary value, and then use that to implement an accumulator.
04:41:24 <quchen> Here are a bunch of simpler versions of the same idea: https://github.com/quchen/articles/blob/master/useful_techniques.md#bouncy-folds
04:43:54 <quchen> Schrostfutz: In the »find2nd« example, there is a Bool parameter which says whether something has been found already.
04:43:56 <mbrock> can I tell ghci to please optimize and compile the module I'm fiddling with?
04:44:27 <quchen> mbrock: You have to compile it externally, GHCi will load the compiled version if it’s there I think
04:44:37 <cocreature> shouldn’t -fobject-code help?
04:44:56 <quchen> Should it? That sounds interesting
04:45:11 <cocreature> I thought it does, but maybe I’m wrong
04:45:28 <cocreature> -fobject-code and -O2 if you want to optimize
04:45:38 <quchen> When you start GHCi with -O it complains that this conflicts with --interactive :-/
04:46:10 <cocreature> quchen: after -fobject-code it doesn’t complain anymore
04:46:37 <quchen> Woah
04:46:41 <mbrock> I think it does work, thanks.  Using cabal repl --ghc-options='-fobject-code -O2'
04:47:38 <cocreature> the main advantage of -fobject-code however is that it reloads significantly faster since it only recompiles a single module instead of all modules
04:47:38 <Schrostfutz> quchen: Thanks, I'll look into that.
04:48:37 <quchen> Schrostfutz: The good news is that once you understand foldl-via-foldr, you probably know everything about foldl/foldr there is to know. :-)
04:49:04 <Schrostfutz> quchen: Haha, question is just in how many weeks that will be :D
04:49:49 <cocreature> working through a solution for foldl-via-foldr is not that hard. coming up with it yourself is really hard (I don’t think I’ve come up with a solution myself)
04:50:58 <quchen> Schrostfutz: I can’t recommend evaluating »foldlViaFoldr (+) 0 [1,2,3]« by hand enough. The key is understanding foldr’s »fourth parameter«, and once you have that, everything becomes clear.
04:52:25 <Cooler> is there an ide for haskell that lets you click on functions to get their source?
04:52:40 <Cooler> like the source for foldr for instance
04:53:07 <Schrostfutz> quchen: So far I as I understand it the step function does not implement the step but binds the n+1 parameters to n...
04:53:10 <quchen> Cooler: None that I know of. But Lambdabot has lots of common functions in simple notation stored.
04:53:12 <quchen> ?src foldr
04:53:13 <lambdabot> foldr f z []     = z
04:53:13 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:53:32 <quchen> Schrostfutz: Right, the step function uses the excess parameter.
04:53:53 <cocreature> Cooler: I think https://github.com/aloiscochard/codex can do that (it’s not an idea but you can integrate tags with at least emacs & vim and probably most other editors)
04:54:14 <quchen> Schrostfutz: foldr f z (x:xs) foo = f x (foldr f z xs) foo
04:54:31 <quchen> The foldr ignores the foo, but the f uses it :-)
04:54:46 <quchen> (Or may use it, rather)
05:03:14 <Cooler> do you need to import something for liftA2?
05:03:20 <Cooler> Control.Applicative?
05:09:38 <ski> @index liftA2
05:09:38 <lambdabot> Control.Applicative
05:11:06 <Schrostfutz> quchen: I think I'm stuck here: http://sprunge.us/HURM The last two steps are likely wrong
05:22:56 <Schrostfutz> quchen: Now I've got it: http://sprunge.us/dBSE Thanks for the help!
05:24:54 <Schrostfutz> So you basically hack the accumulator onto the foldr function. I don't have much experience with haskell yet but this smells for me like bad style since I rely on how the foldr function is implemented such that I can pass the excess parameter to my step parameter, don't I?
05:33:33 <Squarism> After dealing with haskell for 8 months this is my interpretion of haskells deal with IO Monad. Correct me if im wrong. The IO Monad (modelling "an effect") main purposes are - 1. Makes valus from io inaccessible outside the Monad - thus makes it impossible to do io computations wo returning IO values. And further lets 2. provides a single point callback to track interactions with the outside. So, atleast in theory, one can set up an execution that is 
05:33:33 <Squarism> completely deterministic.
05:34:48 <merijn> Squarism: Rather relevant: https://blog.jle.im/entry/io-monad-considered-harmful.html
05:35:15 <Squarism> ops should be "And further ... makes IO computations explicit in the type signatures of function"
05:35:30 <merijn> And no, point 2 isn't really (and by that I mean: really isn't) true
05:37:06 <merijn> Squarism: One of the key insights is that in Haskell we distinguish two things: 1) evaluation (which covers the behaviour of Haskell as described in the standard) and 2) execution (which covers IO). The 2nd is unobservable from the first and thus cannot influence the behaviour of how expressions reduce
05:37:47 <merijn> So the thing that makes Haskell pure is that the IO behaviour of execution cannot be observed inside the non-IO expressions that are evaluated
05:38:44 <Squarism> merijn, ah ok. That was a nice summary. 
05:42:32 <stefR> hi everyone. In my code I define default value myDefaultList = []      the compiler advise me to define it with explicit type this way    myDefaultListForAll :: forall t. [t]      whereas a simple myDefaultList :: [a]    seems to suffice to satisfy the compiler warning. What is the difference between the two definition ? 
05:44:15 <merijn> stefR: Nothing, basically. In basic (as in, no extensions) Haskell ALL type variables implicitly have a "forall" on the left. The forall doesn't normally exist in Haskell, but is used in the underlying theory (and some extensions)
05:44:35 <merijn> stefR: So "myDefaultList :: [a]" is treated, internally as "myDefaultList :: forall a . [a]"
05:46:07 <Cooler> why do this  const <$> Identity [1, 2, 3] <*> Identity [9, 9, 9] when you can do  const [1, 2, 3] [9, 9, 9] ?
05:46:31 <stefR> merijn thx
05:48:19 <quchen> Schrostfutz: Congratulations!
05:48:35 <quchen> Schrostfutz: The »bolted on accumulator« is fairly useful to know about :-)
05:49:04 <quchen> Schrostfutz: It’s often not as readable as an explicit recursive implementation of the same feature though.
05:49:33 <quchen> Schrostfutz: foldr is a somewhat fundamental function on lists, so relying on the implementation of it isn’t bad style.
05:50:04 <quchen> Schrostfutz: foldr captures what it means to consume a list element-wise to build a result.
05:50:46 <quchen> Anything that walks a list element-wise can be written using foldr :-) map, filter, sequence, …
05:51:00 <Schrostfutz> quchen: Okay, thanks again :)
05:51:44 <quchen> Schrostfutz: It’s kind of like »relying on the implementation of id« is not bad style when you write »id f x«.
05:53:09 <quchen> I’m not sure whether foldr is unique, but I strongly suspect there is no other (total) function with its type.
05:53:36 <quchen> Well, no other nontrivial ones.
05:54:02 <quchen> foldr f z xs = z -- would also have the right type, but is clearly nonsense.
05:54:42 <stefR> I have another question. During compilation I have tons of this warning for many modules, (not only Control.Monad, also my own modules): The qualified import of 'Control.Monad' is redundant except perhaps to import instances from 'Control.Monad'. To import instances alone, use: import Control.Monad().   I clearly do not understand the warning. What does it mean ?
05:55:32 <quchen> stefR: GHC warns about unnecessary imports. When you don’t need anything from Control.Foo, you should not import it. GHC detects this by checking whether you make use of any of the definitions made in the Foo module in your own (importing) module.
05:56:00 <quchen> stefR: For type classes, this mechanism may be undesirable: maybe you’re importing the module because it contains an instance definition that you want to use.
05:56:15 <stefR> Ok, so it is a message about unecessary imports. I'm gonna check that immediatly. Thx.
05:56:18 <ongy> so if you used void from Control.Monad before and then removed the use of it, the compiler will warn about an unused import Control.Monad
05:56:29 <stefR> I like this
05:56:40 <quchen> If you *only* want to import instances from a module, you can make this explicit, you can write »import Foo ()«. This imports nothing except the instances, so to speak.
05:56:46 <quchen> (Instances are always exported/imported.)
05:56:55 <quchen> (Known as the open world assumption)
05:57:05 <saolof> What is cheaper, evaluating a thunk or dereferencing a cons?
05:57:39 <quchen> »Dereferencing«? Do you mean »pattern matching on«?
05:57:59 <saolof> right, deconstructing
05:58:33 <Cooler> why doesn't Integer have a monoid?
05:58:35 <quchen> Pattern matching on something may require evaluation of a thunk, so you could say it may be more expensive the first time
05:58:54 <quchen> Cooler: There are two possible Monoids for Integer (sum and product), and by default none is chosen
05:59:11 <saolof> But is calculating something that's easy to evaluate necessarily more expensive than accessing a stored value on the heap?
05:59:19 <Cooler> quchen, that didn't stop list from getting an applicative
05:59:48 <quchen> Cooler: Heh, good point. But there is a law that says that the Applicative has to match the Monad of a type, and there is only one list monad.
06:00:03 <quchen> So here we have something that helps us pick one of the two (equally valid) Applicatives.
06:00:41 <ongy> what are the 2 valid applicatives for lists?
06:00:41 <quchen> saolof: Well, it depends. Pattern matching might be expensive, like in »Just x = expensive« requires a long computation to be done before matching it.
06:00:45 <merijn> quchen: Eh, there's a LOT more monoids for Integer than two :p
06:00:57 <quchen> merijn: I didn’t say »exactly« :-þ
06:01:17 <quchen> ongy: zip lists and umm cartesian-product-lists (or whatever the standard behaviour is called)
06:01:39 <AndreasK> saolof: Not neccesarily, but depends on a lot of factors, from cache hits to what it is your matching on and if you use the variables bound by it (Just _  -> 1 vs Just a -> a)
06:01:57 <Schrostfutz> How do I properly write list literals? This fails: ["foo" "bar"], this works: ("foo":"bar":[])
06:02:15 <AndreasK> Schrostfutz: You forgot the ,
06:02:20 <kadoban> ["foo", "bar"]
06:02:22 <ongy> ["foo", "baar"]
06:02:30 <Tuplanolla> ["foo", "baaar"]
06:02:36 <Schrostfutz> AndreasK, kadoban: ah, thanks
06:02:51 <saolof> But if I write something like lazylist = iterate (*2)  and pow2 n = lazylist !! n  , will it actually be less expensive the first time I call it?
06:02:52 <Schrostfutz> ongy, Tuplanolla: Those give the wrong result! :P
06:03:17 <ongy> > ["foo", 'b': drop 2 "baar"]
06:03:19 <ongy> better?
06:03:22 <lambdabot>  ["foo","bar"]
06:03:49 <Schrostfutz> ongy: Yes! And very concise, too :)
06:04:43 <saolof> sorry, lazylist = iterate (*2) 1
06:05:28 <AndreasK> saolof: Unlikely usually the first call is the most expensive one. It's usually only cheaper to recalculate for primitive unboxed operations like adding two unboxed integers and things like that
06:07:04 <saolof>  I see
06:07:37 <Cooler> are there default values for types?
06:07:38 <Cooler> *Main> pure 1 :: Constant String Int
06:07:39 <Cooler> Constant {getConstant = ""}
06:07:53 <Cooler> how did it get ""?
06:08:30 <saolof> Is there a lazy datastructure that I can use like lazy linked lists, but with O(1) access to computed values?
06:08:48 <ongy> Cooler: the mempty from monoid is a sort of default value
06:08:58 <ongy> and I think there's a Defaults class aswell
06:09:30 <ongy> > mempty :: String
06:09:34 <lambdabot>  ""
06:09:55 <Tuplanolla> > def :: String
06:09:56 <mroman> What's the command again to construct a function based on a type?
06:09:56 <Cooler> what does pure have to do with monoid mempty?
06:10:02 <lambdabot>  ""
06:10:04 <Schrostfutz> I've been writing mostly C++ lately, GHCs error messages are a blessing...
06:10:34 <hpc> Schrostfutz: they really are
06:10:46 <ongy> Cooler: I think djin(n) not sure exactly
06:10:59 <ongy> whoops ^ is for mroman 
06:11:14 <hpc> Schrostfutz: my favorite are the language extension errors which tell you exactly what to do to fix it
06:11:20 <kadoban> saolof: Either Data.Array comes to mind or something like Data.Map, but the latter is O(lg n) access, not O(1).
06:11:24 <AndreasK> saolof: Sequence comes probably closest, but it's logarithmic. True O(1) access would require you to convert the structure something that can be offset accessed as you go which sounds possible but probably won't be worth the overhead and complexity
06:11:33 <moljac024> hey guys
06:11:49 <moljac024> is there a blog post or page where i can see an example implementation of future/promise monad?
06:11:53 <mroman> (and mempty is the identity element in the monoid.)
06:11:54 <ongy> Cooler: what's the exact header of the Applicative instance for Constant? If it's something like `instance Monoid a => Monad (Constant a) where` then it probably uses the monoid instance (and therefore mempty)
06:12:10 <mroman> (not really a default value imo)
06:12:15 <mroman> @djinn a -> b -> a
06:12:16 <lambdabot> f a _ = a
06:12:25 <mroman> yep. that's it.
06:12:33 <kadoban> Hmm, Sequence is probably a better suggestion.
06:12:40 <Cooler> ongy, not sure, in this book they actually tell you to write the functor and applicative instances
06:12:46 <Cooler> yourself
06:13:00 <ongy> mroman: it's (ab)used as a way to get a "default" value in a bunch of places
06:14:13 <mroman> ongy: oh. Good to know :)
06:14:22 <mroman> wouln't that break the monoid laws in some instances though?
06:14:52 <Cooler> oh would you look at that, they give you this "instance Monoid a => Applicative (Constant a) where
06:14:53 <Cooler> "
06:15:00 <ongy> monoid shouldn't be defined for that use, but if it exists it works. And probably is useful most of the
06:15:27 <Cooler> they want you to use mempty
06:16:17 <Tuplanolla> :t def -- There's this thing for when things aren't quite monoids, mroman.
06:16:21 <lambdabot> Default a => a
06:17:20 <foxbored> hoi
06:17:54 <padre_angolano> is it possible to install the 'cabal' binary using stack? '--package cabal-install' doesn't seem to do this
06:18:32 <kadoban> padre_angolano: 'stack install cabal-install' works
06:18:49 <kadoban> It will install to ~/.local/bin/ , so make sure that's on your $PATH
06:19:31 <padre_angolano> kadoban: thanks, working now :-)
06:19:48 <kadoban> Anytime.
06:20:32 <Schrostfutz> > groupBy (\a b -> (a `mod` 3) == (b `mod` 3)) [0..10]
06:20:35 <lambdabot>  [[0],[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
06:21:14 <Schrostfutz> What am I doing wrong here? I'd expect something like [[0, 3, 6, 9], [1, 4, 7, 10], [2, 5, 8]]
06:21:31 <kadoban> Schrostfutz: group/groupBy only looks at adjacent values.
06:21:54 <saolof> Ah, thanks for the advice, I can live with O(log n) access, just not linear ^^
06:22:01 <Schrostfutz> kadoban: Ah, thanks
06:22:55 <kadoban> > groupBy (\a b -> (a `mod` 3) == (b `mod` 3)) . sortBy (comparing (`mod`3)) $ [0..10]
06:22:59 <lambdabot>  [[0,3,6,9],[1,4,7,10],[2,5,8]]
06:23:07 <kadoban> Schrostfutz: That's a common fix ^
06:23:21 <Cooler> is there something weird going on?     fmap :: (a -> b) -> Constant e a -> Constant e b
06:23:28 <Cooler>     fmap _ x = x
06:23:42 <Cooler> x is returned as is but its type changes
06:23:51 <hpc> does that compile?
06:24:11 <Schrostfutz> kadoban: Ty
06:25:08 <Cooler> no it doesn't compile
06:25:39 <hpc> there you go ;)
06:25:55 <Cooler> so you have to unwrap it just to wrap it again
06:26:09 <hpc> what ends up happening is unifying x :: Constant e a and x :: Constant e b gives you a = b
06:26:15 <hpc> which is an invalid equation
06:26:38 <hpc> when you wrap and unwrap it, you never get that equality and it works
06:29:08 <Cooler> so the fmap and <*> are the exact same
06:29:09 <Cooler>     fmap _ (Constant a) = Constant a
06:29:13 <Cooler>     (<*>) _ (Constant e) = Constant e
06:29:32 <Cooler> is there a way to repeat?
06:29:46 <Cooler> i mean is there a way to say <*> = fmap
06:29:54 <Cooler> the types don't match
06:32:19 <Cooler>     (<*>) _ = fmap doesn't work
06:32:40 <Cooler> oh nvm
06:34:03 <Cooler> is there a way?
06:35:31 <Cooler> no there doesn't seem to be
06:37:51 * sudoreboot[m] sent a long message: sudoreboot[m]_2017-02-20_14:37:29.txt - https://matrix.org/_matrix/media/v1/download/matrix.org/JhuUBzWduzspdnNiOLaGlRbK
06:39:14 <ahihi> Cooler: you could define something like rewrap :: Constant e a -> Constant e b; rewrap (Constant a) = Constant a and then have fmap _ = rewrap, (<*>) _ = rewrap
06:39:19 <ahihi> but I'm not sure it's worth it :)
06:40:26 <mroman> Are there some clever algorithms to turn a number in base N to base N+1?
06:41:59 <ongy> there's alwasy unsafeCoerce if you want hate :)
06:43:11 <hexagoxel> coerce should be sufficient in this case.
06:45:09 <kadoban> mroman: I suspect not, unless you count the usual base-conversion algorithm as clever.
06:46:56 <foxbored> hello
06:48:00 <mroman> the only one I know is to convert them to from base_n -> native -> base_n+1 :)
06:48:13 <foxbored> do what?
06:48:19 <mroman> which involves too many divisions.
06:48:28 <mroman> (but not really a haskell question)
06:48:35 <foxbored> *looks cunfoosed at yoo*
06:48:59 <foxbored> whats a haskel?
06:49:54 <Theophane> foxbored: the topic of this channel :P
06:50:11 <ongy> sudoreboot[m]: your message became a link through the matrix gateway on our side... If you are familiar with how C# interacts with static C libraries, you may have a good idea of how things work. If C# has it's own runtime, then the haskell RTS and the C# runtime will probably compete for some resources (both running a thread pool, trying to work around foreign calls). I think there was some discussion
06:50:13 <ongy> around this a while ago in here, you may want to check the logs
06:50:39 <foxbored> uuuuh... i know ome HTML/CSS/Batch and some JS
06:50:42 <foxbored> but no C
06:51:04 <ongy> foxbored: haskell is a general purpose programming language. The main difference to most others is that it's purely functional
06:51:34 <foxbored> oh. ok :)
06:51:49 <mroman> Haskell is like batch. Except there's no @echo off.
06:52:01 <ongy> comparing to those, haskell gives you the nice property of a static and strong type system
06:52:21 <foxbored> huh. you know you dont have to use @echo off... that just hides the code form the user
06:52:43 <foxbored> i came cuz i wanted to talk :)
06:53:31 <ongy> this channel isn't intended for smalltalk, but rather for haskell (and ecosystem) related problems.
06:53:45 <foxbored> ok. ill be on #furry
06:56:02 <sudoreboot[m]> ongy: My whole message became a link (dead I presume)?
06:56:03 <sudoreboot[m]> I'm not sure I have the whole runtime thing down, as I am not sure what would make machine code compiled from haskell and machine code compiled from csharp different in terms of how it is run.
06:56:39 <ongy> sudoreboot[m]: the link is live (on the matrix website) and yes. IRC has a maximum message length of 512chars, so anything longer has to be split (like mine did) or worked around
06:57:53 <sudoreboot[m]> ongy: Is it readable or should I repeat it in parts?
06:58:34 <ongy> it's readable for people that care to follow the link. You should probably cut it down to the essential question and post it
07:01:58 <mroman> (except that C# is bytecode -> jit and Haskell is not?)
07:03:27 <ongy> also the rts can intercept allocations done by haskell code and reschedule, while the C# (is it a C# vm?) probably does something else with thread managing
07:03:43 <sudoreboot[m]> Here's the tldr of my question:
07:03:43 <sudoreboot[m]> I want to compile my Haskell code into a static linked library with an FFI wrapper and use this as a plugin in Unity3D, by calling the library from C# during runtime and get the desired results back. Am I going to have to spend weeks on trying to get this to work?
07:04:09 <ongy> I guess intercept is the wrong word here, the code calls into rts code on to co allocations and the RTS can decide to run another thread
07:05:39 <sudoreboot[m]> mroman: Unity3D has support for compiled plugins, so the fact that it's compiled to machine code while C# is bytecode shouldn't be a problem?
07:05:55 <mroman> C# can do native calls
07:05:59 <mroman> using DllImport and Marshalling.
07:06:28 <mroman> but I sadly don't know how this works together with Haskells RTS.
07:06:45 <merijn> This is rather misleading
07:07:04 <merijn> Calling Haskell from C# is the exact same as calling C from C# (since C FFI is the only thing that exists)
07:07:17 <sudoreboot[m]> mroman: So, in theory, making it work should involvelittle more than following the typical FFI docs?
07:07:28 <merijn> The only difference is that the Haskell library might introduce a bit of overhead in the form of it's own scheduling and memory managment
07:07:32 <merijn> sudoreboot[m]: Yes
07:07:41 <mroman> You can invoke C functions from C#. That's not a problem.
07:07:49 <mroman> If haskell can expose them as C functions.
07:07:56 <mroman> which I take from merijn's answer it can.
07:08:22 <merijn> sudoreboot[m]: I have a minimal example of calling haskell from C here: https://gist.github.com/merijn/4a0fee2b3a5ef3476aa4
07:08:45 <merijn> sudoreboot[m]: Simply replace the C code with C# using C#'s C FFI to call the same functions
07:09:20 <sudoreboot[m]> Thank you, I'm going to try your examples out
07:09:45 <merijn> sudoreboot[m]: Might require a bit of fiddling, but should be rather straightforward, mostly
07:09:59 <sudoreboot[m]> I'm struggling with linking because ghc is telling me ghc needs to be compiled with -fPIC, which is giving me a headache
07:10:39 <sudoreboot[m]> All examples thus far have all given me errors about linking errors
07:11:18 <sudoreboot[m]> s/linking errors/-fPIC/
07:11:39 <ongy> have you tried to pass -fPIC to ghc?
07:12:18 <sudoreboot[m]> ongy: Yeah. libHSbase is the one saying it needs to be recompiled
07:14:15 <ongy> then you are probably trying to link the static library into a dynamic object (if you are on windows that's .lib (I think) into a .dll)
07:18:35 <sudoreboot[m]> Trying to compile using `ghc -O2 --make -no-hs-main -optl '-shared' -o Foo.so Foo.hs` should work according to https://stackoverflow.com/questions/16615641/calling-haskell-from-c-sharp#16618038
07:18:49 <sudoreboot[m]> ongy: I'm on Ubuntu 16.04.4
07:18:50 <mauke> why do people still use --make?
07:19:06 <merijn> mauke: Because the internet is littered without outdated examples that people blindly copy
07:19:08 <ongy> because it shows up on the internet in tutorials
07:19:24 <sudoreboot[m]> mauke: I usually omit it, but I just copy pasted
07:19:44 <ongy> sudoreboot[m]: have you tried to add -fPIC to that line?
07:19:52 <ongy> ah sorry, not where the problem is
07:19:54 <ongy> I should think first
07:21:13 <sudoreboot[m]> ```Linking Foo.so ...
07:21:13 <sudoreboot[m]> /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crt1.o: In function `_start':
07:21:14 <sudoreboot[m]> (.text+0x20): undefined reference to `main'```
07:21:51 <mauke> it's trying to create an executable
07:22:16 <ongy> https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/using-shared-libs.html mentions -dynamic/-shared as ghc arguments
07:22:25 <sudoreboot[m]> mauke: Why is it doing that with the -shared and -no-hs-main flags
07:22:40 <ongy> mauke: that for example also has the -make and it's ghc docs from 7.8.4. Since when is -make not required anymore?
07:23:22 <ongy> sudoreboot[m]: you are passing the -shared to the linker not ghc itself
07:24:15 <sudoreboot[m]> ongy: Should I pass it both?
07:26:03 <mauke> ongy: 7.0
07:29:28 <ongy> sudoreboot[m]: trial and error? It shouldn't take that long. I would try both and see
07:31:24 <merijn> ongy: --make hasn't been required for years
07:31:44 <merijn> ongy: It exists, but --make is the default unless you override it, so "ghc" and "ghc --make" do the exact same thing
07:32:17 <sudoreboot[m]> ongy: Trial and error is how I tend to do things because I don't understand enough about how the linker, compiler, runtime system, etc work
07:33:33 <ongy> merijn: ah. I think the first ghc I used was 7.8 and when I looked around I found more with --make than without so I default to use it when I remember to
07:33:52 <ongy> sudoreboot[m]: :) I know the C toolchain a bit better, but with GHC I trial&error aswell
07:36:19 <sudoreboot[m]> merijn: Trying to build your ffi example tells me `-strict` is not a recognized option
07:36:25 <merijn> I know how the C parts work too and I know roughly what GHC does, but I never remember all the right flags/incantations to make GHC do exactly what I want
07:36:55 <merijn> sudoreboot[m]: That flags isn't necessary, but means your C compiler sucks ;)
07:37:39 <mudri> Is there a standard typeclass containing just an elem function?
07:37:52 <sudoreboot[m]> merijn: I'll talk to it
07:38:12 <merijn> sudoreboot[m]: honestly you could remove all the C flags in the cabal file and it should work :)
07:38:24 <merijn> sudoreboot[m]: They're just the default warnings I used when I wrote that
07:39:06 <cocreature> mudri: afaik there isn’t. "elem" works on any Foldable however, so if you have that you get it for free
07:39:07 <merijn> mudri: You mean like
07:39:08 <merijn> :t elem
07:39:11 <lambdabot> (Foldable t, Eq a) => a -> t a -> Bool
07:40:09 <sudoreboot[m]> merijn: ongy: Thank you for all the help :)
07:43:18 <mudri> cocreature: Okay, thanks. I'll consider Foldable. I don't think I actually want to use containers like Eq a => (a -> Bool), but it somehow seems nice to include them.
07:43:35 <mudri> (Or even not Eq a in that case.)
08:04:21 <srhb> Is there a module-scoping-alike proposal somewhere? A la with Data.Text { ... }
08:04:39 <merijn> srhb: ezyang's backpack?
08:04:50 <merijn> Or are you meaning something else?
08:06:07 <slack1256> On Pipes.Core, I don't see what is the semantic differece between the request and pull category. Anybody can lend me a hand?
08:06:57 <merijn> I think pull is () and request uses something other than ()?
08:08:27 <slack1256> merijn: it seems you are thinking in `await` which is `request ()` ?
08:08:42 <merijn> slack1256: Yeah
08:10:42 <Tuplanolla> Is anyone up for some lens polishing? Find the given key `k :: Int`, return the value `x :: Char` and delete the key from the submap `n :: Map Int Char`. Do not delete keys from the supermap `m :: Map Ordering (Bool, Map Int Char)`.
08:10:42 <Tuplanolla> @let m = Map.fromList [(LT, (False, Map.fromList [(1, 'a'), (2, 'b')])), (EQ, (True, Map.empty)), (GT, (False, Map.fromList [(3, 'c'), (4, 'd')]))] :: Map Ordering (Bool, Map Int Char)
08:10:45 <lambdabot>  .L.hs:161:5: error:
08:10:45 <lambdabot>      Not in scope: ‘Map.fromList’
08:10:45 <lambdabot>      Perhaps you meant one of these:
08:10:58 <slack1256> but you're in the right direction, is the return type what changes
08:11:07 <Tuplanolla> I don't really know how to "search" with lenses.
08:16:18 <ClaudiusMaximus> Tuplanolla: i don't know enough lens to answer, but perhaps considering what should happen if the Int key occurs multiple times in those maps might help reach a sensible answer
08:16:55 <Tuplanolla> That should be impossible, so I'd accept any behavior, ClaudiusMaximus.
08:17:12 <Tuplanolla> Ideally the search would stop on the first match though.
08:33:26 * lambdafan bounces around
08:39:10 <Tuplanolla> > preview (each . _2 . ix 3) m -- At least this works for getting.
08:39:13 <lambdabot>  error:
08:39:13 <lambdabot>      Ambiguous occurrence ‘m’
08:39:14 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.m’,
08:39:36 <Tuplanolla> > preview (each . _2 . ix 3) L.m
08:39:40 <lambdabot>  Just 'c'
08:46:56 <glguy> > let m = Map.fromList [(LT, (False, Map.fromList [(1, 'a'), (2, 'b')])), (EQ, (True, Map.empty)), (GT, (False, Map.fromList [(3, 'c'), (4, 'd')]))] in (traverse . _2 . at 3) (\old -> ([old], Nothing)) m
08:46:59 <lambdabot>  ([Nothing,Nothing,Just 'c'],fromList [(LT,(False,fromList [(1,'a'),(2,'b')])...
08:47:40 <glguy>  (traverse . _2 . at 3) (\old -> (First old, Nothing)) L.m
08:47:42 <glguy> > (traverse . _2 . at 3) (\old -> (First old, Nothing)) L.m
08:47:46 <lambdabot>  (First {getFirst = Just 'c'},fromList [(LT,(False,fromList [(1,'a'),(2,'b')]...
08:48:51 <Tuplanolla> Very nice, glguy. I was kind of expecting `First` to pop up.
08:49:30 <Tuplanolla> It's surprising to see no operator like `preview` there.
08:49:47 <glguy> :t preview
08:49:50 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
08:50:00 <glguy> The preview is "inlined" via the use of First
08:50:09 <pikajude> why doesn't the `highlighter` package exist in any stack build plan?
08:50:11 <pikajude> it's clearly on hackage
08:50:14 <pikajude> what do I do in this scenario?
08:50:28 <glguy> add it to your extra-deps
08:50:30 <Tuplanolla> What did you change when inlining it, glguy?
08:50:33 <merijn> pikajude: Because stack uses stackage and not everything on hackage is on stackage?
08:50:47 <pikajude> oh, ok
08:50:49 <pikajude> i didn't know that
08:51:05 <glguy> Tuplanolla: It's inlined into the merged operation that both previews your result and removes that key from the maps
08:51:14 <Tuplanolla> Let me meditate over this for a while.
08:51:52 <glguy> Tuplanolla: While medatating consider that preview typically works with Const, and set works with Identity
08:52:08 <glguy> Here those two are smashed together into (,)
08:52:29 <quchen> pikajude: Stack has only Stackage in scope by default; anything not in stackage you have to add to the extra dependencies. You can use »stack solver« to do this for you, see »stack solver --help«.
08:52:44 <pikajude> thanks everyone
08:52:45 <pikajude> that fixed it
08:52:54 <pikajude> why are packages on hackage not on stackage
08:52:58 <pikajude> are they manually curated
08:53:02 <Tuplanolla> Would it make sense to isolate the idea into a `preset`, glguy?
08:53:30 <quchen> pikajude: Yes, Stackage is a vetted set of packages that are all buildable together, giving a guaranteed-to-be-working subset of Hackage.
08:53:41 <glguy> Tuplanolla: possibly locally, but I don't think it needs to be in the lens package. There are lots of combinations like this
08:53:43 <pikajude> oh ok
08:53:47 <quchen> Upside: works, downside: deviating from the vetted set can be tricky.
08:53:55 <Tuplanolla> Locally indeed. Let's see what happens.
08:59:15 <Tuplanolla> Certainly you mean `First` instead of `Const`, glguy.
08:59:22 <glguy> no
08:59:45 <glguy> I'm talking about the choice of types providing Applicative instances
09:00:05 <lambdamu> Are there any interesting instances for a Group type class apart from the obvious numerical ones?
09:03:10 <nitrix> I have a curious question. An email thread at work meant to be helpful about a disctinction between "Composition vs. Inheritance" https://www.thoughtworks.com/insights/blog/composition-vs-inheritance-how-choose , yet I can't help but think that Inheritance is a form of composition (at least at the type level).
09:04:21 <merijn> nitrix: In what way?
09:04:34 <nitrix> I'm not that great with CT, but if your objects are type classes and morphisms are dependencies between them, isn't (.) essentially inheritance?
09:04:43 <t4nk492> Hello, friends! Why this fails? let {listGen (x@(a:b):_) = x} in listGen [1,2,3,4]
09:05:05 <t4nk492> can you not extract two numbers this way?
09:05:28 <glguy> t4nk492: You've parenthesized it incorrectly
09:06:01 <glguy> (a:b) is a whole list where a is an element and b is a list
09:06:28 <glguy> [1,2,3,4] is   (1:(2:(3:(4:[]))))
09:07:07 <t4nk492> hmm, I see
09:07:38 <t4nk492> Thank you! 
09:08:46 <Benzi-Junior> hey I'm trying to generate tags for a library that uses a header file and the ghci parser always fails when it comes to the #include line 
09:09:05 <glguy> Benzi-Junior: Did you add {-# Language CPP #-} to the top of the file?
09:09:14 <glguy> Oh, #include usually happens in .hsc
09:09:15 <glguy> not .hs files
09:09:49 <Squarism> Looking at package Data.Time here. Cannot find some clear candidate for a type carrying "unix-timestamp" / seconds-or-millis since 1970...
09:09:55 <Benzi-Junior> glguy, yes its in there
09:10:04 <Squarism> anyone know a such
09:10:15 <glguy> Benzi-Junior: If you're trying to load a .hsc file, you'll need to process it with hsc2hs first
09:10:32 <quchen> Squarism: https://hackage.haskell.org/package/time-1.8/docs/Data-Time-Clock-POSIX.html
09:10:39 <glguy> otherwise it might help to paste the code and error message
09:10:45 <Benzi-Junior> cabal was able to build the package
09:10:48 <quchen> Squarism: POSIXTime is »Unix time« here.
09:10:58 <Squarism> ah ok
09:11:00 <Benzi-Junior> so this appears to be something specific to ghci
09:11:41 <Benzi-Junior> glguy, the code is the vector library on hackage 
09:13:01 <glguy> Benzi-Junior: You can open vector package in GHCi with "cabal repl"
09:13:46 <Benzi-Junior> glguy, ah 
09:14:18 * Benzi-Junior is a novice with cabal
09:16:27 <Benzi-Junior> glguy, ok sweet that works
09:18:39 <Tuplanolla> @let presetBad l = asks (first getFirst . l (\ x -> (First x, Nothing))) -- I can define it like this, but this doesn't quite match the way `preview` is defined, glguy.
09:18:42 <lambdabot>  Defined.
09:19:04 <Tuplanolla> There's no `foldMapOf` there.
09:19:57 <glguy> That means you haven't meditated enough on the idea that    Const + Identity = (,)
09:22:24 <nitrix> edwardk: This is just a thought experiment, but is it remotely possible to have a category whose objects are type classes and morphisms, dependencies between them? If so, does composition becomes inheritence?
09:39:25 <spaceshi1s> any recommendations on a library to use for manipulating polynomials?
09:40:10 <JuanDaugherty> any basic alg?
09:40:47 <JuanDaugherty> or just hs
09:42:37 <spaceshi1s> we need expansion - i hope thats what it's called. for instance translating (x+y)(x+y) into x^2 + 2xy + y^2
09:44:26 <ffilozov> How do I report a broken link on haskell.org?
09:46:29 <Tuplanolla> Well, I don't see how `foldMapOf` would be needed here.
09:46:36 <JuanDaugherty> it's the revers of factoring
09:46:58 <spaceshi1s> yeah
09:47:54 <JuanDaugherty> don't recall a name for that, evaluation, finding product
09:48:28 <ski> "expansion into terms" perhaps
09:50:14 <ski> "multiply out" ?
09:50:57 <spaceshi1s> multiply out? ah, something we could just do ourselves
09:53:23 <JuanDaugherty> or "find the polynomial"
09:55:42 <monochrom> sum of products
09:56:31 <nshepperd_> nitrix: constraints package has that, I think. There's a type for constraint implication that gets a category instance
09:56:43 <thatguy> what is the easiest way if I want a program that converts chars to ints in the following way: a to 1, b to 2, ...
09:57:19 <thatguy> nvm
09:57:25 <monochrom> HSTNF = highschool teacher normal form :)
10:00:38 <spaceshi1s> hah!
10:02:13 <nshepperd_> nitrix: newtype a :- b = Sub (a => Dict b)
10:03:05 * ski . o O ( `constraints' )
10:03:12 <nitrix> nshepperd_: Ah! An EdwardK package, who've thought :P
10:03:20 <glguy> Tuplanolla: foldMapOf is just a use of Const, there's no magic. Instead of using Const we're using (,) here
10:03:21 <ocramz> hullo!
10:03:23 <nitrix> nshepperd_: Checking. Very appreciated.
10:04:10 <nshepperd_> There's an edwardk package for that ™
10:04:42 <ocramz> Sending out a thought to edwardk for a prompt full recovery
10:10:28 <Tuplanolla> :t presetBad -- I still have to clean up this type, glguy.
10:10:30 <lambdabot> MonadReader a m => ((Maybe a2 -> (First a2, Maybe a3)) -> a -> (First a1, d)) -> m (Maybe a1, d)
10:11:13 <Tuplanolla> There's clearly `(a -> f b) -> s -> f t` in there.
10:13:52 <Squarism> anyone know if theres some trick to make aeson "to-json" conversion take a provided TimeZone in to account and convert date/time types into some timezone local datetime representation?
10:14:10 <nitrix> nshepperd_: I'm truely impressed. Turns out, it's called type entailment and someone thought of it before me :P
10:15:11 <Akii> johnw: thanks for your suggestion regarding rewriting my transformerstack, that should work
10:16:03 <johnw> Akii: it will save you from storing a lambda inside an Either in many places, which *might* have a performance impact
10:16:34 <Akii> I thought I'd need to make this a monad http://lpaste.net/352780
10:16:47 <Akii> but all I really need to do is to make this state and have a function manipulate it
10:19:06 <Tuplanolla> Does `MonadReader r m => Lens r t (Maybe a) (Maybe b) -> m (Maybe a, t)` look right to you, glguy?
10:19:06 <johnw> sound right; plus, it can't be a monad
10:19:20 <Akii> johnw: as we figured out yesterday D
10:19:21 <Akii> :D
10:19:27 <Akii> was fun trying though
10:20:00 <glguy> Tuplanolla: Generally you shouldn't take an actual Lens as a parameter, you'd take some non-polymorphically typed argument
10:20:30 <johnw> you can use ALens' to take a lens as a parameter
10:20:38 <johnw> (or ALens, in this case)
10:20:46 <johnw> just know that you have to call cloneLens on it before you can use it
10:20:57 <glguy> In this case it would be better to not take an ALens either, but the specific type you needed
10:21:06 <glguy> otherwise you'll have an unnecessary cloneLens in the definition
10:21:39 <Tuplanolla> What would that be? The explicit function type.
10:22:11 <glguy> for example: (<<.~) :: LensLike ((,) a) s t a b -> b -> s -> (a, t)
10:22:21 <glguy> this is a function very similar to what you're implementing
10:22:37 <Tuplanolla> Ah, I did take a look at that one earlier.
10:24:17 <glguy> Also the operation you were using wouldn't have been compatible with the Lens version since what you were using wasn't a Lens
10:24:39 <Tuplanolla> So I have `MonadReader r m => LensLike ((,) (First a)) r t (Maybe a) (Maybe b) -> m (Maybe a, t)`.
10:25:08 <glguy> That seems fine
10:27:25 <Tuplanolla> :t Data.IORef.atomicModifyIORef' -- Now the last annoyance is that the return value is swapped wrt this.
10:27:27 <lambdabot> GHC.IORef.IORef a -> (a -> (a, b)) -> IO b
10:31:40 <Tuplanolla> This is similar to asking whether `StateT` should've been `s -> m (s, a)` instead of `s -> m (a, s)`.
10:31:40 <JuanDaugherty> does 8.0.2 actually have so many fixes as to make upgrade needful?
10:31:57 <JuanDaugherty> (from 8.0.1)
10:32:58 <JuanDaugherty> s/so many/such/
10:34:06 <glguy> JuanDaugherty: You can look at the release notes to determine if the things that were fixed are important to you
10:34:17 <bollu> does anyone know of a standalone implementation of OutsideIn(X) type inference?
10:34:21 <bollu> (that is, not part of GHC)
10:34:56 <JuanDaugherty> glguy, ty
10:53:42 <littleBoss> Hi
10:54:13 <orizzonte> ciao
10:54:26 <orizzonte> !list
11:01:39 <Akii> johnw: this does _exactly_ what I had in mind, thanks again http://lpaste.net/352783
11:02:01 <johnw> great!
11:02:50 <johnw> you shouldn't need the first two extensions anymore
11:03:09 <Akii> the second one is to satisfy stylish-haskell
11:03:14 <Akii> but the first one definitely not
11:03:23 <Akii> (also this is just playground, gonna move that now xD)
11:04:55 <Akii> I so much love this line http://lpaste.net/352783#line36
11:05:17 <Akii> like the statement, not the line xD
11:06:38 <Akii> event sourcing in 36 lines
11:06:46 <johnw> st' <- maybe (appInit agg) (aggApply agg) st ev
11:06:55 <Akii> not a single day goes by where Haskell does not surprise me
11:07:15 <Akii> and there is always room for improvement xD
11:07:23 <johnw> we love to golf code here
11:09:03 <Akii> let me process that wow
11:09:29 <Akii> wow
11:10:18 <Akii> I can already see the next improvement: something with Applicative lifting
11:11:22 <Akii> as far as readability goes, I think this is pretty good
11:12:09 <johnw> as long as you're happy with it :)
11:12:24 <Akii> working on this for a year now, at least
11:16:50 <Tuplanolla> I just noticed that `uncurry (set (at i)) . preset (at i) = id`, so that's a good guideline for ordering the tuple.
11:22:06 <jpthing> so a tuple is like a set?
11:22:13 <ski> no
11:22:48 <ski> a (sub)set can have arbitrarily many elements, which are given without order, and without counting multiplicity
11:23:26 <ski> a tuple is always an `n'-tuple, for some `n', so a fixed number (`n') of components, given in order (and multiplicity, if you want to think of it like that)
11:23:56 <ski> in a subset, all the elements must come from the same ambient superset ("universe"/"domain of discourse")
11:24:15 <jpthing> It is just that Tuplanolla's form looks like the transform from a set to a sequence without recursive types.
11:24:21 <ski> in a tuple, each position/component has its own associated type, from which the component at that position must come
11:24:40 <jle`> jpthing: er, where is the set in what Tuplanolla wrote?
11:24:55 <Tuplanolla> That remark relates to some earlier lens polishing, jpthing.
11:25:08 * ski didn't realize jpthing was referring/responding to what Tuplanolla was talking about
11:25:22 <jle`> jpthing: are you talking about the 'set' function, which means "make it this value" ?
11:25:39 <Tuplanolla> Sets aren't really involved at all, jpthing.
11:26:09 <jle`> maybe jpthing saw the word 'set' and thought it was referring to sets in set theory
11:26:45 <jle`> instead of '2. to put or bring into a specified state'
11:26:51 <jle`> https://www.google.com/search?q=define+set
11:27:36 <jpthing> No they are not. I find sequences are a better match for how computers work. Even in so called set related definitions like SQL order is important to achieve performance. So It would have been better to define it as a relation of sequences.
11:28:37 <jle`> what is that in response to?
11:28:50 <ski> jpthing : but that precludes useful optimizations ..
11:29:10 <ski> (and makes it harder to reason about, declaratively)
11:29:14 <jpthing> In Haskell list can only have one type and a tuple many types but only a fixed length. I find this a fiddly restriction to work around so I am somewhat interested in lenses.
11:29:36 * ski doesn't see how optics would help there
11:29:49 <ski> however .. with dependent types, you could get more general
11:30:04 <jle`> in what way do you need to work around this?
11:30:48 <Tuplanolla> Lenses don't give you heterogeneous lists, jpthing. They only get you tools for working with existing things as if they were.
11:30:49 <ski> e.g. you could easily have a sequence of `Maybe' trees, where each tree (if present) would be a perfectly balanced binary tree with `2^n' elements, `n' being the index of the `Maybe' tree in the sequence
11:32:14 <ski> (Okasaki had a datastructure like that in PFDS, though not using dependent types to ensure the sizing being related to the index)
11:32:23 <ski> @where PFDS
11:32:23 <lambdabot> http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
11:32:50 <jpthing> thx
11:34:09 <ski> the `Just's/`Nothing's in the sequence would spell out a binary numeral, and e.g. merging of two such sequences into one would correspond to addition of binary numerals
11:34:42 <jpthing> Yes a tree should work. And has a decent efficiency model. Even if a pure data structure.
11:36:47 <ski> jpthing : "I find sequences are a better match for how computers work." -- if you by this refer to how in Zermelo-Fränckel set theory, they build everything (including tuples and functions) out of sets, only having such sets as elements .. then i'm sympathetic to preferring structures with more "stricture" (like tuples, trees, &c.) over (sub)set ..
11:37:14 <ski> jpthing : .. but, for particular purposes, like relations (SQL), sets have their place
11:38:24 <ski> (if anything, i don't like SQL because it doesn't fit well enough with the relational model theory. e.g. the order of attributes sometimes making a difference)
11:39:29 <Benzi-Junior> ok I think I'm going mad here
11:40:14 <Benzi-Junior> does there anywhere exist an implementation of basicUnsafeIndexM in the vector library ?
11:42:30 <Benzi-Junior> I'm trying to find where the inefficiency of indexing is coming from and have traced it all back to basicUnsafeIndexM which is declared and always implemented in terms of basicUnsafeIndexM (presumably from another module) but it seems not end on a concrete case 
11:42:37 <Benzi-Junior> except for bool
11:46:14 <roconnor> set theory was supposed to be built out of predicates, but that doesn't work, so we get this weird construction that is ZF where sets are trees modulo ordering.
11:47:15 <ski> hello roconnor
11:47:36 * ski . o O ( Aczel's anti-foundation axiom )
11:47:42 <roconnor> Perhaps indexed sets being unordered isn't that strange, especially when the index becomes uncountable.
11:49:10 <ski> indexed sets = families, yes
11:50:00 * ski . o O ( sub-finite indexing )
11:50:12 <roconnor> sure that too.
11:50:13 <Benzi-Junior> does anyone here know where the vector implementations for tuples are defined ?
11:50:32 <roconnor> though the notion of sub-finite doesn't really exist in ZF.
11:51:26 <roconnor> It exists, but it is identical to finite, so it doesn't get any attention
11:51:45 <ski> like overt
11:52:00 <roconnor> yes.  except I understand subfinite, but not overtness.
11:54:29 <sternmull> it seams stack does not use source files that i add in the src/ subirectory that was created by it. Where do i have to add them?
11:54:40 <ski> what is a good name for glbs of images of endofunctions on naturals ? or glbs of subsets of naturals, if you want more general ?
11:55:04 <ski> for the former, you can only compute approximate upper bounds (except if you reach zero)
11:56:43 <kadoban> sternmull: In the .cabal file , you have to specify exposed modules and "other modules", whatever the real names for them are. They should be in the file already and you just add to the list, as I recall.
11:57:43 <sternmull> kadoban: Can i have multiple files that belong to the same module?
11:58:39 <kadoban> sternmull: No. Each file is one module
11:59:27 <sternmull> kadoban: Oh ok.
12:09:51 <sgript> If I do say sqrt(25) in Haskell I get 5.0, any easy way to get 5?
12:11:43 <sgript> Would round $ sqrt $ fromIntegral 25 suffice?
12:14:12 <Tuplanolla> Does it matter if the result is a bit wrong sometimes, sgript?
12:14:34 <sgript> nope, but if there's a way to fix that, i would like to know anyway :d
12:14:50 <Tuplanolla> Number theory packages should provide integer square roots.
12:14:53 <kadoban> sgript: For reasonably sized inputs that should work fine, as long as you don't care much that it's off for a bit for non-squares.
12:15:13 <kadoban> Yeah, you can do integer square roots directly, but it doesn't seem to be in base.
12:15:40 <Nik05> w 4
12:15:46 <Nik05> im sorry
12:16:03 <roconnor> GMP supports integer square roots.  It'd be nice to have that in base.
12:16:16 <Nik05> but sgript depends what you want for an answer when the argument is not a square
12:16:19 <Tuplanolla> Much more number theory ought to be in `base`.
12:17:00 <Tuplanolla> At least I often reach for logarithms, roots and factorization.
12:17:28 <sgript> oh the arg is always square
12:18:01 <sgript> answer *
12:18:22 <sgript> I'm just doing this for trigonometrystuff
12:19:55 <sgript> so is there no way to do it without packages?
12:20:17 <kadoban> Well, your way will work fine for reasonable inputs.
12:21:10 <kadoban> as-in probably anything double can represent exactly, and maybe a bit more.
12:21:16 <sgript> I noticed, it is a bit off actually
12:21:23 <Nik05> So you already know that they are squares, sgript. What do you want to do with the return value? 
12:21:40 <kadoban> sgript: Really? For what inputs?
12:22:24 <ski> Tuplanolla : discrete logarithms ?
12:23:09 <Tuplanolla> Rounding up or down, ski.
12:25:18 <kadoban> sgript: Anyway, if it's not quite right and if you can't use a library, you can implement it using binary search that'll likely perform acceptably.
12:25:33 <kadoban> But it seems to work fine for me for reasonable inputs I tried.
12:25:57 <kadoban> > round . sqrt . fromIntegral $ (999999999999999^2)
12:26:05 <lambdabot>  mueval-core: Time limit exceeded
12:26:11 <Tuplanolla> > floor (64 ** (1 / 3) :: Double)
12:26:15 <lambdabot>  3
12:26:18 <Tuplanolla> > 3 ^ 3 :: Int
12:26:22 <lambdabot>  27
12:26:28 <kadoban> > round . sqrt . fromIntegral $ (999999999999999^2)
12:26:32 <lambdabot>  999999999999999
12:26:40 <kadoban> Heh, the first one was just lambdabot being funny I think.
12:26:54 <hpc> > floor (0/0)
12:26:57 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
12:28:31 <stepcut> Is there a way to pass extra cpp-options on the commandline with cabal? Specifically, I want to set, -DEMBEDDED_FILEPATH="/path/to/file"
12:37:04 <ski> Tuplanolla : ok
12:37:30 <dolio> stepcut: Is it CPP as run by GHC? Wouldn't it be a GHC option, then?
12:39:13 <stepcut> dolio: We currently have this set in .cabal and it works `cpp-options: -DEMBEDDED_FILEPATH="/path/tofile"`, but the problem is that the path is hardcoded, but to build on Nix, we need to specify the path since it changes
12:43:11 <dolio> Oh, I see. I misunderstood what you were asking.
12:45:31 <dolio> Looks like --cpp-options=... is an accepted cabal flag.
12:45:44 <dolio> And should add to the cpp-options from the file.
13:24:48 <sternmull> i have to read from two handles, wrap their data into messages and write that messages to a third handle. At the moment i use two threads to read the handles. How do i synchronize writes to the third handle? Are two reader threads a good idea at all?
13:26:34 <merijn> two threads seems fine
13:26:41 <geekosaur> multiple reader threads and a TChan to send the resulting message packets to the third?
13:26:53 <merijn> ^^ that, except I'd probably use Chan
13:27:19 <Tuplanolla> You probably want a bounded channel here, merijn.
13:27:35 <geekosaur> depends on the data flow
13:27:52 <merijn> Tuplanolla: True
13:28:03 <sternmull> i thought about using a channel. But then i have a third thread that processes the message and has to stop when both readers are done. I hoped it could be solved less complicated.
13:28:22 <geekosaur> and in particular, precisely *how* it gets bounded depends on the data flow and the application requirements. for video streaming, you drop stuff; for some other uses, you block the readers...
13:28:32 <merijn> Which is why I was working on a closable version of Chan (well, actually, it's mostly done, I just need to write benchmarks)
13:28:51 <merijn> Unfortunately, that means first fixing criterion, because as-is it's not good enough :\
13:28:58 <merijn> Hence why I keep postponing it :p
13:29:00 <geekosaur> sternmull, so you define the message data as data Message = Done | Data yourData
13:29:14 <geekosaur> (first cut...)
13:30:35 <sternmull> geekosaur: yes something like that. And the writer has to count the Done messages it has seen and finish at the last one... ok.
13:31:16 <geekosaur> you can also have the Done message include a sender id and track until you've seen all senders
13:31:23 <Tuplanolla> Do the read threads quit when they're done, sternmull?
13:31:36 <sternmull> Tuplanolla: Yes they do.
13:31:42 <geekosaur> (which has the potential advantage that you can add more threads and have it autoadapt instead of having to change a hardcoded count)
13:31:51 <Tuplanolla> Another option presents itself: link the threads via exceptions.
13:31:54 <Tuplanolla> @hackage async
13:31:54 <lambdabot> http://hackage.haskell.org/package/async
13:33:14 <sternmull> geekosaur: There should be no need for more threads. I want to read stdout and stderr from a process and multiplex that to a TCP stream. Date should be stuff like log output and compiler messages. So no need for super high performance. Easy implementation is more important right now :)
13:33:36 <merijn> Tuplanolla: For some workflows (most I have) that doesn't work out so nicely
13:33:38 <geekosaur> that's why I said "potential"
13:33:49 <Tuplanolla> Not all options are good options!
13:33:49 <Benzi-Junior> does anyone here know where the implementations for vector tuples are defined ?
13:33:53 <sternmull> Tuplanolla: I already found async and happily use it to wait for the two readers.
13:36:54 <Benzi-Junior> alternatively is there a way to look up instance declarations on hackage or with hoogle ?
13:45:44 <dmwit> Benzi-Junior: The newest haddock will link instances to their sources, but some packages haven't had an upload since Hackage's haddock got that upgrade.
13:46:08 <dmwit> In that case, you're out of luck. You'll have to use the old way (grep!).
13:46:25 <Benzi-Junior> dmwit, its not in there
13:46:29 <dmwit> Actually, come to think of it, you can probably ask GHC.
13:46:50 <Benzi-Junior> dmwit, I've literally spent days looking for this
13:47:04 <dmwit> :i shows information about instances of a class (or classes a type instantiates) which I think mentions where the instance lives.
13:47:38 <Tuplanolla> Then it's in some `Internal` module that you have to dig up separately.
13:47:54 <dmwit> Benzi-Junior: What is the specific instance you're looking for source for?
13:48:10 <dmwit> "implementations for vector tuples" doesn't make much sense to me.
13:49:01 <Benzi-Junior> dmwit, (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => Vector Vector (a, b, c, d, e)
13:50:50 <fizbin> If I have a library I'm importing qualified, and that library defines a function that's meant to be used inline (e.g. if that lib. defines a function called "&"), what's the syntax for invoking that function inline? a `(G.&)` b  isn't working.
13:51:17 <dmwit> Benzi-Junior: In ghci, load `Data.Vector.Generic` and `Data.Vector.Unboxed`, then ask `:i Vector`.
13:51:33 <Tuplanolla> > f Data.Function.$ x -- Like this, fizbin.
13:51:36 <lambdabot>  error:
13:51:36 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M785854188758...
13:51:36 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
13:51:41 <Benzi-Junior> if I clikc the #source link on hackage it points me to line 671 in Data.Vector.Generic.Base ... which is only 140 lines long 
13:51:42 <dmwit> Benzi-Junior: It will tell you about that instance, followed by a comment that says `-- Defined in 'Data.Vector.Unboxed.Base'`
13:52:03 <fizbin> Tuplanolla: Huh. Ok...
13:56:15 <dmwit> Benzi-Junior: In the source, look in `internal/unbox-tuple-instances`.
13:57:22 <dmwit> Benzi-Junior: lines 537-730
13:58:37 <Benzi-Junior> dmwit, oh god 
13:58:54 <dmwit> ?
13:59:01 <Benzi-Junior> dmwit, I was to focused looking under the Data directory 
13:59:40 <dmwit> Just read the source. It's what I did. At the end of the file that GHC pointed me at is a comment `-- Tuples` followed by `#include "unbox-tuple-instances"`.
14:01:11 <dmwit> Probably explains the whole "line 671 of 140" thing in the haddocks, too, come to think of it.
14:01:44 <hpc> haha
14:02:28 <hpc> does template haskell have the same issue?
14:07:49 <Benzi-Junior> dmwit, ye that would explain it 
14:18:03 <cheshircat> Hello, what is the simplest way to get haskell and rust IPC? I have JSON serialization and deserialization for the structures I want to send set up, but I don't know whether to use named pipes or unix domain sockets, and I don't know what libraries to use on either side. I care more about the Haskell interface because the bulk of my code is on that side, so whatever works best on Haskell's side I will make
14:18:04 <cheshircat> work on Rust's side
14:19:11 <jpthing> There are plenty of JSON libs. Like the one in Real world Haskell. Why do you need rust.
14:19:14 <dmwit> Both solutions should be relatively easy to use. There's also dbus bindings if you find yourself needing asynchronous communication.
14:19:40 <dmwit> jpthing: He's already done the JSON part. And why does it matter why he needs rust?
14:20:31 <dmwit> cheshircat: I should clarify that when I said "relatively easy to use" I meant "...in Haskell". No idea about the rust side of things but I'd be shocked if they don't have support for pipes and sockets.
14:22:09 <cheshircat> yeah, the have support for either
14:22:42 <cheshircat> is there not any particular reason why I should favor one over the other, and are there particular haskell libraries you would recommend?
14:23:23 <dmwit> Boring old file IO functions work for named pipes, too (kind of the point of named pipes).
14:23:46 <dmwit> ?hackage bytestring is probably preferable for file IO
14:23:46 <lambdabot> http://hackage.haskell.org/package/bytestring is probably preferable for file IO
14:23:55 <dmwit> ?hackage network has socket operations
14:23:56 <lambdabot> http://hackage.haskell.org/package/network has socket operations
14:24:24 <dmwit> I expect there are higher-level wrappers around these, too; depends what you want, I guess.
14:25:30 <dmwit> e.g. I think conduit probably has something for both kinds of interaction
14:25:49 <cheshircat> Oh, I've heard good things about conduit
14:26:23 <cheshircat> OK, thank you, I guess the answer is a little self-evident in retrospect but I didn't really know where to start
14:31:00 <nate_> I'm trying to understand pretty-printed Core, and it's not clear what the meaning of the various sigils is ($, #, @) is there a legend somewhere?
14:32:44 <megaTherion> strange question maybe, but is it possible to colorize the output of ghci - to let it be more friendly to the eyes? ^^
14:37:09 <merijn> Is it possible? Yes!
14:37:14 <merijn> Do I remember how? No! :p
14:39:41 <mzabani> Hi everyone, I'm trying to instantiate http-client's ManagerSettings with custom connectionRead and connectionWrite functions. The problem is that these functions need to call a function that runs in a MonadState. Is this possible?
14:48:11 <megaTherion> merijn: :(
14:48:35 <megaTherion> merijn: dont worry, I'll google around
14:48:46 <merijn> google for like "ghci custom print" or something
14:49:48 <dmwit> megaTherion: What kind of coloring do you want?
14:50:08 <megaTherion> syntax hilighting, like for the things you write in ghci and also for type informations and stuff
14:50:25 <megaTherion> no color at all just seems to be a little unsatisfying
14:50:46 <megaTherion> Im checking this right now: https://wiki.haskell.org/GHCi_in_colour
14:50:49 <dmwit> You might like iHaskell.
14:50:53 <merijn> megaTherion: syntax highlighting for like writing?
14:51:32 <ludat> after working in rust I really miss colors in my compiler output
14:52:38 <MarcelineVQ> next major ghc release has error colors :>
14:52:44 <megaTherion> dmwit: iHaskell?
14:53:13 <dmwit> https://camo.githubusercontent.com/8e92d2d571f80b17019e8e477cc29015cf57a4bd/68747470733a2f2f7261772e6769746875622e636f6d2f67696269616e736b792f494861736b656c6c2f6d61737465722f696d616765732f696861736b656c6c2d6e6f7465626f6f6b2e706e67
14:53:17 <dmwit> oh dear
14:53:29 <dmwit> That URL ended up being longish. Sorry about that.
14:53:32 <dmwit> https://github.com/gibiansky/IHaskell
14:53:38 <glguy> mzabani: makeConnection takes arguments with types "IO ByteString" and "ByteString -> IO ()". It's unlikely that you'd want to make a MonadState instance for those types
14:54:10 <ludat> MarcelineVQ, which one? 8.2? that would be so awesome
14:54:25 <dmwit> mzabani: You could consider storing your state in an `IORef`.
14:55:59 <MarcelineVQ> ludat: yeah, it's in head already so I'd expect a presence in 8.2
14:57:37 <ludat> :hardcore_party_parrot:
14:58:10 <ludat> now I have more incentive to get snap into the latest stackage
14:59:06 <MarcelineVQ> it's probbaly not as spectacular as you're imagining :>
14:59:43 <ludat> I really like colors on my cli things
15:01:26 <mzabani> dmwit: I thought of something like that.. is this the only way you see to make this happen?
15:01:59 <mzabani> glguy: I'm not sure I understand you correctly (I'm new to all this, sorry), but I'm not trying to make IO an instance of MonadState
15:02:46 <mzabani> what I'm trying to do is have http-client send and receive from a websockets tunnel, whose functions live in a custom monad (which is basically a MonadState).
15:03:22 <glguy> makeConnection isn't interested in any custom types. You'll have to provide things with the specific types being requested of IO ByteString and ByteString -> IO ()
15:05:33 <glguy> You could perhaps define something with type:   MVar SomeState -> StateT SomeState IO ByteString -> IO ByteString    and use that to adapt your MonadState constrained definition
15:05:56 <glguy> MVar SomeState -> StateT SomeState IO a -> IO a *
15:09:36 <MarcelineVQ> ludat: afaik this is about the sum of it currently https://phabricator.haskell.org/D2716
15:11:40 <mzabani> glguy: if the tunnel is to be used by something other than http-client, shouldn't I make its implementation rely only on (MVar SomeState)? Any modifications to the State done by http-client should be accessible to others in the same tunnel..
15:13:00 <glguy> mzabani: That's why you'd need to put the final state back into the MVar at the end
15:16:49 <mzabani> glguy: could I just get rid of StateT entirely and do this inside my own Monad implementation (let's say MonadTunnel), always depending on (MVar SomeState)?
15:19:21 <glguy> Whether or not you make a new typeclass (is that what MonadTunnel was going to be?) isn't important. The main thing is that at the end what you've built has the type expected by makeConnection
15:20:30 <mzabani> all right, I think I've got a lot of info on how to get on with this. Thank you very much for your help!
15:46:07 <buttons840> could someone give me some feedback on my approach to wrapping some errors here? http://lpaste.net/352796  it's taken me quite awhile to get this far and I still don't have some obvious error cases covered
15:55:01 <ongy> 3/quit
15:55:23 <johnw> buttons840: use decodeUtf8' if you want an Either result
15:57:26 <buttons840> johnw: yeah, I'm doing that now -- am i way off the mark on how I'm handling things, or is this close to how good error handling might look?
15:58:40 <johnw> it feels a bit heavy on the error handling, since the actual "code" is almost nothing compared to everything else; maybe ExceptT would help to lighten it up
15:58:55 <johnw> gotta run
15:59:44 <buttons840> ty
16:05:23 <jle`> buttons840: i think some of this might make more sense as exceptions
16:06:27 <buttons840> jle`: you mean just let the code throw exceptions and catch it somewhere
16:06:56 <jle`> not quite 'just let'; but convey the errors as exceptions instead of as Either
16:09:26 <lpaste_> Buttons840 pasted “Error wrapping attempt (complete)” at http://lpaste.net/352797
16:10:06 <buttons840> jle`: ok, i got it working the way i originally wanted -- why do you think this api would be better using exceptions?
16:11:08 <jle`> you already have exceptions that can come out anyway
16:11:24 <jle`> so it's about drawing the line about what should go through exceptions and waht should go through Either
16:11:45 <jle`> typically IO processes that can fail are handled using exceptions, as a general heuristic
16:12:04 <buttons840> i understand -- as far as I'm aware there are no exceptions i have not accounted for, but i believe you that I have missed some
16:12:20 <jle`> and "pure" exceptions (giving functions inputs that don't have a defined answer) are handled using Either/Maybe
16:12:58 <jle`> you mentioned the exceptions you haven't accounted for in your paste
16:13:28 <buttons840> jle`: i accounted for the one exception (as far as im aware) i was missing in my latest code
16:13:47 <jle`> i'm referring to things like network errors etc.
16:13:57 <jle`> the user still has to handle that no matter what
16:14:10 <buttons840> jle`: this specific case doesn't matter, i agree with you that in general you can expect IO code to throw many kinds of exceptions
16:14:24 <jle`> so i guess the judgment call comes to what you want to consider IO exceptions and what you want to consider 'pure' API errors
16:15:31 <jle`> an HttpException's classification is sort of debatable, but i think it'd fall more into the exception camp than a pure API input error
16:16:45 <buttons840> jle`: even if I do want to present the exceptions using Either, it seems like using catch behind the scenes might be easier at this point
16:17:44 <jle`> i meant, httpexceptions might make more sense as a thrown exception than as a Left
16:19:13 <buttons840> this will be part of a web app, and if I get either "NotFound" or "Directory" I'll tell the user, any other errors I'll just have to give a 500 error since the user can't really do anything about them
16:20:21 <jle`> it's the 'Other String' case that you might have to watch out for then in that case
16:21:42 <buttons840> "Other String" means I'll give the user a 500 error and log the string for further investigation
16:22:44 <buttons840> ill have to look into exception handling more
16:23:15 <buttons840> does `catches` mask like `catch` does?
16:24:03 <jle`> ah, so 'Other' is realy '505 error'
16:24:19 <jle`> looks sound then
16:25:59 <MarcelineVQ> does catch mask?
16:26:27 <glguy> The masking behavior is the difference between why you use catch or try
16:26:58 <monochrom> IIRC catches masks just as catch does. The whole reason why catches exists.
16:27:06 <monochrom> Also same atomicity.
16:27:14 <buttons840> there is catch and catches, and then theirs try, but no tries (or trys?)
16:27:25 <glguy> catches exists so that exceptions raised by one of the handlers aren't caught by another
16:28:09 <glguy> Given that: catches io handlers = io `catch` catchesHandler handlers
16:28:14 <glguy> it masks the same as catch
16:28:34 <lambdafan> ($) applies from right to left, is there an operator that applies left to right?
16:28:47 <MarcelineVQ> which piece of catch is responsible for the masking behavior?
16:28:52 <MarcelineVQ> lambdafan &
16:29:05 <lambdafan> is that in Lens.Micro?
16:29:13 <MarcelineVQ> I'm not sure right to left is what I would describe $ as though
16:29:14 <jle`> it's in Data.Function
16:29:14 <lambdafan> I know <&> is
16:29:16 <jle`> in base
16:29:17 <MarcelineVQ> Data.Function
16:29:24 <lambdafan> gotcha thanks
16:29:33 <jle`> @hoogle (&)
16:29:36 <lambdabot> Data.Function (&) :: a -> (a -> b) -> b
16:29:37 <lambdabot> Control.Lens.Lens (&) :: a -> (a -> b) -> b
16:29:37 <lambdabot> Control.Lens.Operators (&) :: a -> (a -> b) -> b
16:30:14 <monochrom> "tries" would be nice but what would its type be?
16:31:16 <buttons840> same as catches?
16:31:23 <buttons840> :t catches
16:31:26 <lambdabot> error:
16:31:26 <lambdabot>     Ambiguous occurrence ‘catches’
16:31:26 <lambdabot>     It could refer to either ‘Control.Exception.catches’,
16:32:28 <buttons840> :t catches
16:32:30 <lambdabot> error:
16:32:30 <lambdabot>     Ambiguous occurrence ‘catches’
16:32:30 <lambdabot>     It could refer to either ‘Control.Exception.catches’,
16:32:38 <monochrom> That can work. And then people get confused because there are two things, very different behaviour, and same type.
16:32:53 <Axman6> @hoogle catches
16:32:53 <lambdabot> Control.Exception catches :: IO a -> [Handler a] -> IO a
16:32:54 <lambdabot> Control.Monad.Error.Lens catches :: MonadError e m => m a -> [Handler e m a] -> m a
16:32:54 <lambdabot> Control.Monad.Catch catches :: (Foldable f, MonadCatch m) => m a -> f (Handler m a) -> m a
16:33:02 <buttons840> monochrom: it would be just like the catch/try situation then
16:33:13 <buttons840> maybe we don't want to make things worse though?
16:33:21 <monochrom> No, try has a different type from catch.
16:34:09 <buttons840> true
16:34:31 <buttons840> how would you catch multiple exception types without masking then?
16:35:53 <monochrom> I might try for SomeException and then cast my way out.
16:36:40 <buttons840> monochrom: I have no idea what that would look like
16:36:51 <buttons840> what is casting in haskell?
16:36:59 <monochrom> Data.Typeable
16:39:36 <monochrom> Actually fromException.
16:43:41 <buttons840> :t fromException
16:43:43 <lambdabot> Exception e => SomeException -> Maybe e
16:44:43 <buttons840> under what conditions would fromException evaluate to Nothing?
16:44:59 <jle`> buttons840: you can think of SomeException as a sum type containing constructors for every instance of Exception
16:45:08 <monochrom> When you chose the wrong type for e.
16:45:11 <jle`> data SomeExcption = SEIO IOExcepetion | SEBlah BlahException
16:45:25 <jle`> it'll return 'Maybe' if you ask for an IOException, but it actually contained a BlahException
16:45:42 <jle`> getIOExeption :: SomeException -> Maybe IOException
16:45:55 <jle`> it'll return Nothing if the SomeException didn't contain an IOException
16:46:07 <buttons840> jle`: ah
16:46:59 <jle`> the Typeable class (which is a superclass of Exception) has some useful methods that let us write this open-sum-kinda type of behavior
16:57:02 <MarcelineVQ> this is quite confusing, the documentation claims "The difference between using try and catch for recovery is that in catch the handler is inside an implicit mask" but try uses catch, and I can't find evidence of masking involved in catch itself in the first place. the function in the mask related section are quite explicit about how they tinker with the masking state by using primitives with the word mask in them which aren't 
16:57:02 <MarcelineVQ> present in catch :O
16:57:32 <MarcelineVQ> But let's assume for the sake of having a focus that the implicit masking is in the catch# primitive, why does try lose this property when it's using catch?
16:58:27 * Clint squints.
16:59:27 <MarcelineVQ> shoulda linked: http://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Exception.html#g:3
17:04:07 <lyxia> Hmmm
17:04:28 <lyxia> I think the difference they want to point out is that try returns the error to be handled
17:04:32 <MarcelineVQ> maybe they mean something as simple as the fact that try doesn't have a handler that can be interacted with
17:04:37 <lyxia> right
17:05:41 <MarcelineVQ> What you've just said makes sense to me, thank you
17:07:05 <Cale> MarcelineVQ: Right, when you use try, you're going to have the *actual* handler out in some case expression afterward.
17:07:18 <jle`> edwardk: is there any way to abuse the Reverse type from 'ad' to do reverse-mode autodifferentiation with calculations involving multiple types?  was going to write my own custom one
17:09:01 <unknownln> Hey all, interesting problem: I'm writing something which needs to read data from a source and serve it over http to a client. However, I want it to read the data as fast as it can from the source (essentially loading the whole thing into memory), regardless of the speed the client reads. I also don't want to block until the entire input has been read into memory before I start to serve the client data. Any way to do this?
17:09:02 <unknownln> Input data is coming from a Handle, output is a lazy bytestring sent with Spock/Wai
17:09:13 <MarcelineVQ> lyxia, Cale: thank you, now I'm going to troll around in ghc source for whether the implicit masking they mention is part of catch# or some effect of how they classify interruptible things
17:41:38 <Wizek> Hi. Anyone knows if there is a lens combinator that allows to set with a monadic function? e.g. something like this: https://gist.github.com/Wizek/9dc20498f7539a5b3850e9ce8829be5b 
17:42:28 <Wizek> I'm thinking that the function I am looking for could have the type: `MonadState s m => ASetter s s a b -> (a -> m b) -> m ()`
17:46:54 <glguy> Wizek: I dunt think there is
17:47:19 <glguy> don't
17:48:07 <Wizek> glguy, do you think it is possible to write? I attempted like so: https://gist.github.com/Wizek/95e82df4c2cc938f4ba85de81307dde1
17:55:01 <lyxia> l <~ (f =<< use l)
18:04:23 <Wizek> lyxia, thanks for the tip, although I seem to be getting the same type mismatch between Identity and Const
18:07:35 <lyxia> Wizek: add a type signature
18:08:33 <lyxia> :t \(l :: Lens s a) f -> l <~ (f =<< use l)
18:08:35 <lambdabot> error:
18:08:35 <lambdabot>     • The type synonym ‘Lens’ should have 4 arguments, but has been given 2
18:08:35 <lambdabot>     • In a pattern type signature: Lens s a
18:08:41 <lyxia> :t \(l :: Lens' s a) f -> l <~ (f =<< use l)
18:08:44 <lambdabot> MonadState s m => Lens' s a -> (a -> m a) -> m ()
18:12:55 <Wizek> lyxia, yaay, that works! Thanks. I wonder why inference wasn't able to guess.
18:14:47 <Wizek> :t \(l :: Lens' s a) f -> (l .=) =<< (f =<< use l) -- btw, this works with type annotation too.
18:14:50 <lambdabot> MonadState s m => Lens' s a -> (a -> m a) -> m ()
18:17:09 <glguy> the type annotation is required because you need explicit type signatures to get a polymorphic function parameter
18:17:19 <glguy> as part of RankNTypes
18:17:37 <Wizek> hmm, I see
18:22:24 <FatBoyXPC> how do I figure out where the various modNMasks came from? Where N is a number. Such as mod1mask is alt, mod4mask is windows key
18:22:32 <FatBoyXPC> I'm looking for the modmask for control, or a list of the mod masks
18:23:00 <FatBoyXPC> Oh crap, wrong chat, sorry guys. I meant to post this in #xmonad
18:23:34 <monochrom> Heh, but consider the program called "xev"
19:29:17 <soulisson> Hi, how haskell passes functions to other functions? Does it pass a reference to the function?
19:29:31 <soulisson> (in memory address)?
19:29:56 <ezyang> soulisson: Like most languages, it passes a "closure", containing both the function code to run, and its lexically captured variables 
19:30:41 <Axman6> ezyang: the function may be inlined at compile time too though right?
19:30:55 <soulisson> ezyang: so each time, the function code is duplicated and passed to the target function?
19:31:03 <Axman6> I believe the answer isn't quite as simple as a closure is passed
19:31:16 <ezyang> the function code doesn't change, so in C-parlance, you can just pass the function pointer 
19:31:25 <Axman6> soulisson: there's no need for the function code to be duplicated as it can never change
19:31:59 <ezyang> If you have ever seen the convention in C where you pass both a function pointer and a void* pointer, that data together is a "closure" 
19:32:02 <soulisson> Axman6, ezyang, ok, thank you
19:33:33 <soulisson> I've seen function pointers in C, for the convention you're talking about, I don't know it
19:35:20 <Welkin> ezyang: isn't the void* the data?
19:37:03 <ezyang> well, it's the data you want the function to have access to 
19:37:14 <ezyang> that is, the function that the funptr points to 
19:40:10 <ezyang> (and yes, C programmers don't use closures very often) 
19:41:04 <suzu> i would if they werent so unsafe and tricky
19:42:48 <monochrom> C lacks inner functions. This and related concepts such as closures are bound to be alien to most C programmers.
19:43:43 <suzu> C is hard enough to get right as-is
19:44:45 <soulisson> I have a terminology question. Is it incorrect to say a C function that accept a function ptr is a higher order function?
19:45:02 <monochrom> I think it's correct.
19:45:26 <soulisson> ok, thanks
19:45:40 <Welkin> a function pointer isn;t the same as passing a function though
19:47:51 <SolitaryCypher> It kinda is. You can do primitive maps and monadic operations if they don't require context/closure 
20:08:50 <joe9> http://stackoverflow.com/a/4408556 is there a library that can do this? format a decimal monetary number 1001.99 => 1,001.99
20:09:15 <Welkin> joe9: you can just write a function o.o
20:09:41 <Welkin> convert a decimal value to a string
20:09:51 <Welkin> instead of the standard Show instance
20:10:04 <Welkin> there already is a library that provides this somewhere
20:46:57 <buttons840> do typeclass laws have any significance in the language itself, or is it just that the author of the typeclass is saying "the functions that use my typeclass assume these laws are true, and if you violate them, the functions may fail"
20:47:13 <barrucadu> The latter
20:47:44 <Axman6> there's no mechanism to enforce laws
20:48:08 <Axman6> so if you break them you go to bad code jail, but the compiler can't tell you you've broken them
20:48:48 <buttons840> i heard they only allow intercal and malbolge in bad code jail?
20:49:41 <barrucadu> If you rbeak the law, the code police will come to take you away
20:49:44 <barrucadu> *break
20:50:05 <Axman6> there are no computers in bad code jail
20:50:12 <Axman6> you can code on paper only
20:50:39 <johnw> you can code in binary, but only where space = 0 and tab = 1
20:50:41 <barrucadu> If you're good they'll let you use an infinite number of rocks and a flat plane for one afternoon a week.
20:51:21 <buttons840> an infinite number of rocks sounds like a good power source, we should be using for better things
20:51:35 <Koterpillar> infinite != unlimited
20:51:36 <buttons840> we can travel through space with that
20:52:15 <Koterpillar> an infinite number of rocks has infinite gravity, that seems dangerous
20:52:32 <barrucadu> Koterpillar: That's why nobody gets out of bad code jail.
20:53:25 <buttons840> so similar to breaking typeclass laws -- i've always thought that unsafePerformIO is ok as long as the surrounding function behaves like a pure function -- because if you break the purity the compiler or other code will probably not do what you want -- is this a good way to think of it?
20:54:53 <barrucadu> Generally you shouldn't be breaking laws or using unsafe IO, but occasionally situations do crop up where it's the right thing to do. But then the burden is on you the programmer to make sure nothing goes funky.
20:54:53 <S11001001> buttons840: related: with enough stuff in the language, you can push all the laws down into members, e.g. https://github.com/idris-lang/Idris-dev/blob/v0.99/libs/contrib/Interfaces/Verified.idr#L16-L20 This may be inconvenient, though.
20:55:57 <barrucadu> For example, the Par monad uses unsafe IO to make use of actual concurrency, but as it only lets you write deterministic computations, that's fine.
21:01:07 <Cooler> hey what happens with  (+1) <$> [1..10] <*> [1,2,3,4]  ?
21:01:34 <Cooler> hey what happens with  (+) <$> [1..10] <*> [1,2,3,4]  ?
21:01:41 <johnw> every combination
21:01:43 <Cooler> not (+1)
21:01:50 <Cooler> oh right
21:25:25 <buttons840> about catch: "Furthermore it is possible to accidentally stay inside the implicit mask by tail-calling rather than returning from the handler..." -- what does it mean to "return" in Haskell? I'm a little fuzzy because most of the time it feels like a haskell program is just one big expression being evaluated
21:27:59 <monochrom> But IO is where you go back to imperative programming and you actually have control flow.
21:29:11 <monochrom> My http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml#catch has a simple example of how to wrongly stay inside the mask forever.
21:30:11 <buttons840> so, simplest the Control.Exception docs reommends using try instead of catch wherever possible, did I intepret that right?
21:30:29 <buttons840> the Control.Exception docs reommends using try instead of catch wherever possible, did I intepret that right?
21:30:53 <monochrom> Yes. And I have the same recommendation too.
21:35:26 <Cooler> is this over complicated? http://lpaste.net/352802
21:36:50 <johnw> I'm not sure your Applicative is what you mean
21:37:24 <johnw> don't you want: Cons f fs <*> Cons x xs = Cons (f x) (fs <*> xs)
21:37:41 <johnw> which is equivalent to ZipList
21:37:47 <johnw> but not to the applicative for []
21:38:09 <Cooler> johnw, what?
21:38:15 <mpiechotka> Hi. I have a Lens s t [a] [b]. I try to traverse over it with index. How can I do it using lenses combinators?
21:38:35 <Cooler> no its an exercise to write the list applicative
21:38:39 <Cooler> not ziplist
21:38:53 <johnw> Cooler: then your Nil <*> _ rule needs to change
21:38:55 <johnw> and _ <*> Nil
21:39:04 <Cooler> why?
21:39:21 <mpiechotka> (I try to somehow get IndexedTraversal but I fail to figure out the type zoo)
21:39:55 <johnw> Cooler: hmm.. maybe not
21:41:51 <johnw> Cooler: no, you're fine
21:42:04 <johnw> sorry for the confusion, my mental checker was off
21:49:14 <mpiechotka> Ok. I was looking at the documentation of wrong version of lenses
22:02:22 <buttons840> I want to catch multiple exception types, but do not need to use catch, but I'm not sure how to catch multiple exception types with try or tryJust
22:02:51 <buttons840> I asked earlier and got some recomendations, but having read some tutorials I'm still not sure what it would look like
22:05:50 <c_wraith> buttons840: You probably don't really have a better option than using catches
22:07:21 <c_wraith> buttons840: I guess you could do something crazier, but you'd have to write it yourself
22:08:57 <buttons840> c_wraith: I know getting stuck inside a mask is a risk with catch, and since I don't really understand how that happens I wanted to avoid it
22:09:28 <c_wraith> buttons840: do you care about recovering the exception?  That complicates things a lot if you do
22:10:17 <c_wraith> buttons840: that is, do you care about recovering the exception value, like the way try gives you the Left value
22:10:32 <buttons840> Control.Exception says: "To recover after an exception and do something else, the best choice is to use one of the try family.
22:10:37 <buttons840> ... unless you are recovering from an asynchronous exception, in which case use catch or catchJust."
22:10:54 <buttons840> (sry) -- i don't need to recover from async exceptions
22:11:23 <c_wraith> But...  do you need the exception value, or are you good with just knowing that an exception from your list happened?
22:12:28 <buttons840> i can see the value of catches, it seems like a common case that you'd want to deal with more than one type of exception from a piece of code, but what if those 2 or 3 exceptions I want to deal with do not involve async exceptions
22:12:57 <buttons840> c_wraith: I'd like to know what exception occured
22:13:54 <c_wraith> In that case, I can't really see a better interface than catches
22:14:00 <buttons840> c_wraith: but even if i didn't care what exception occured, it's not good to act on ANY exception, right?
22:16:17 <c_wraith> depends on what you're doing.
22:19:22 <buttons840> c_wraith: i'm not doing anything specific, I just see a logical hole in the Control.Exception guidelines, they seem to say "if you're not catching async exceptions, use the 'try' family of functions", and I want to catch multiple exceptions, none of which are async exceptions, but there is no way to do that?
22:19:58 <spatial> General question. Have a list of lists. Each list entry has a label. This list of lists also has a GUI representation. Is there a functional pattern for this general use case ?
22:21:28 <c_wraith> buttons840: that doesn't really seem like a good rule of thumb.  catch runs the handler masked, sure, but that doesn't mean it's inappropriate to use for synchronous exceptions.  It just means you need to be aware that the handler is masked.
22:22:40 <spatial> Separating a data structure and it GUI but update when structure changes.
22:24:55 <c_wraith> spatial: lots of reactive programming deals with that pattern
22:51:14 <Cooler> why does repeat 1 == repeat 1 not respond to Ctrl + c?
22:51:26 <Cooler> isn't Ctrl + c the interrupt?
22:52:55 <qmm> what happens when you have have these two lines in a file?
22:52:55 <qmm> import qualified Database.Persist as DB
22:52:58 <qmm> import qualified Database.Persist.Postgresql as DB
22:53:28 <qmm> all of the functions Persist.Postgresql are now available through DB?
22:53:28 <barrucadu> You can refer to things from Database.Persist and Database.Persist.Postgresql as DB.<name>
22:53:43 <barrucadu> If the name is defined in both modules, the compiler will yell at you
22:53:49 <qmm> what happens if there is a function in Persist with the same name as a function in Persist.Postgresql?
22:53:58 <qmm> oh
22:54:01 <qmm> thanks barrucadu 
22:59:04 <c_wraith> Cooler: it sends an asynchronous exception to the thread doing the evaluation
22:59:40 <c_wraith> Cooler: but...  receiving asynchronous exceptions is actually cooperative.  It's only done when the running thread checks to see if there are any exceptions waiting
22:59:57 <c_wraith> Cooler: that check is done on allocations
23:00:19 <c_wraith> Cooler: but evaluating that expression only does two allocations total.  After that, it spins without allocating
23:00:50 <c_wraith> Cooler: so the exception never has a chance to get delivered
23:09:44 <qmm> > fmap (maybe (Just "foo") read) Nothing
23:09:48 <lambdabot>  Nothing
23:10:00 <qmm> > fmap (maybe (Just "foo") read) (Just "foo") -- fails, why? also hello!
23:10:03 <lambdabot>  error:
23:10:04 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘Maybe String’
23:10:04 <lambdabot>        Expected type: Maybe (Maybe String)
23:15:17 <Xnuk> :t fmap (maybe (Just "foo") read)
23:15:19 <lambdabot> Functor f => f (Maybe String) -> f (Maybe [Char])
23:15:40 <Xnuk> :t maybe (Just "foo") read
23:15:42 <lambdabot> Maybe String -> Maybe [Char]
23:16:19 <Xnuk> > (maybe (Just "foo") read) (Just "foo")
23:16:22 <lambdabot>  *Exception: Prelude.read: no parse
23:17:19 <Xnuk> qmm: ^
23:18:01 <Xnuk> :t fmap
23:18:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:19:44 <qmm> :t read
23:19:47 <lambdabot> Read a => String -> a
23:20:11 <Xnuk> > read "foo" :: String
23:20:13 <lambdabot>  "*Exception: Prelude.read: no parse
23:20:16 <MarcelineVQ> > (maybe (Just "foo") read) (Just "Just \"foo\"") -- not quite sure what you're after, it's looking a litttle hairy
23:20:19 <lambdabot>  Just "foo"
23:20:21 <Xnuk> > read "\"foo\"" :: String
23:20:25 <lambdabot>  "foo"
23:21:08 <qmm> MarcelineVQ: i'm simply playing with maybe since i found out about it today
23:23:16 <srhb> qmm: Did you figure out the problem? The idea of maybe is that you get to "uniformize" the result, whether or not you had a Nothing or Just Something, but the type of Just "foo" and read are not the same.
23:24:09 <srhb> Ie. Just "foo" has a different type from (read "foo")
23:26:33 <qmm> how does (Just "Just\"foo\"") have type f (Maybe String) ?
23:27:21 <srhb> It does not.
23:27:23 <MarcelineVQ> it doesn't, I didn't fmap
23:27:27 <Xnuk> qmm: it's Maybe String
23:27:57 <qmm> aha
23:28:33 <qmm> wait
23:28:54 <qmm> Just = f ?
23:29:02 <srhb> No, Just isn't a type
23:29:10 <srhb> It's a value constructor.
23:29:18 <srhb> It does signify that the f in question is Maybe
23:29:28 <srhb> (Since it's one of the value constructors of Maybe)
23:29:40 <qmm> so f = Maybe
23:29:43 <srhb> Yes.
23:30:04 <qmm> but it derives that from knowing Just that Just is value constructor in the Maybe class
23:30:12 <srhb> Yes.
23:30:13 <qmm> in the Maybe data constructor
23:30:15 <qmm> sorry
23:30:25 <srhb> No need to be sorry. :)
23:30:42 <srhb> (Though I wouldn't use class, that's wrong.)
23:30:56 <srhb> :-)
23:31:01 <qmm> Just = Maybe = f, "Just\"foo\"" is the Maybe String?
23:31:06 <srhb> Actually, data constructor is wrong too.
23:31:13 <srhb> data constructor is synonymous to value constructor
23:31:20 <srhb> Maybe is a *type* constructor
23:31:21 <liste> Just is constructor for Maybe type
23:31:32 <qmm> oh right
23:31:36 <qmm> sorry again 
23:31:53 <srhb> qmm: I didn't understand your last question, can you elaborate?
23:32:10 <qmm> :t fmap (maybe (Just "foo") read)
23:32:13 <lambdabot> Functor f => f (Maybe String) -> f (Maybe [Char])
23:32:22 <qmm> it takes an f (Maybe String)
23:32:25 <qmm> the f is the Maybe
23:32:26 <srhb> Right.
23:32:28 <srhb> No
23:32:30 <srhb> Not yet.
23:32:32 <qmm> oh
23:32:34 <srhb> It's more general than that.
23:33:02 <srhb> It's only when you gave it a Maybe (Maybe String) as argument you had to pick f ~ Maybe
23:33:08 <srhb> Let's start one simpler.
23:33:19 <srhb> :t maybe (Just "foo") read
23:33:21 <lambdabot> Maybe String -> Maybe [Char]
23:34:38 <srhb> If we *fmap* that over some f a, we can pick any f.
23:34:48 <srhb> (where the a matches, at least)
23:35:01 <srhb> For instance, IO, [], ...
23:35:24 <srhb> If you fmap that over a Nothing, you've picked a specific f, namely Maybe.
23:36:05 <srhb> What I'm saying is that you could replace `maybe (Just "foo") read` with any other a -> b, and it would not change the logic at all.
23:36:15 <srhb> :t fmap undefined Nothing
23:36:17 <lambdabot> Maybe b
23:36:20 <srhb> See?
23:36:45 <qmm> i see
23:37:08 <srhb> And we get back the parametricity over the Functor with...
23:37:11 <srhb> :t fmap undefined
23:37:13 <lambdabot> Functor f => f a -> f b
23:37:21 <srhb> Because we didn't pick an `f` yet.
23:38:29 <qmm> > fmap (\x -> x) Nothing
23:38:32 <lambdabot>  Nothing
23:38:37 <qmm> > fmap (\x -> x) (Just 3)
23:38:40 <lambdabot>  Just 3
23:38:50 <qmm> okay, i'm not going crazy
23:38:54 <qmm> just checking
23:38:58 <srhb> A little crazy is ok. :-)
23:43:07 <qmm> srhb: i guess i'm not understanding why (Just "Just\"foo\"") is f (Maybe String) still
23:44:01 <srhb> It's still not.
23:44:08 <srhb> So that's ok :)
23:44:13 <srhb> It's Maybe String
23:44:20 <qmm> i think i get it
23:44:28 <MarcelineVQ> your original problem combined 3 interesting problems people run into all at once so it's tougher to dissect :> "why didn't read parse" "how does maybe work" "what's happening with fmap here"
23:44:28 <qmm> fmap over Just makes the f a Maybe
23:44:41 <srhb> fmap maybe does, yes!
23:44:56 <srhb> That's why you get two layers.
23:45:16 <srhb> :t fmap (maybe undefined undefined) Nothing
23:45:19 <lambdabot> Maybe b
23:45:25 <srhb> :t fmap (maybe Nothing undefined) Nothing
23:45:29 <lambdabot> Maybe (Maybe a)
23:45:46 <srhb> (I'm trying to carve off all the irrelevancies wrt. the type)
23:46:10 <srhb> :t fmap (maybe Nothing read) Nothing
23:46:13 <lambdabot> Read a => Maybe (Maybe a)
23:46:35 <srhb> :t fmap (maybe (Just "foo") read) Nothing
23:46:37 <lambdabot> Maybe (Maybe [Char])
23:46:49 <srhb> Hope that helps a bit. It's a good technique, by the way/
