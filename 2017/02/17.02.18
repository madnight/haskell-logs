00:02:47 <jle`> jchia_1: oh, and just like for the common misconception of the 'IO Monad', the *usefulness* of kleisli arrows and of type equality and of functions doesn't come from thje fact that tehy are Category instance
00:02:48 <jle`> s
00:03:00 <jle`> just like that the usefulness of IO doesn't come from the fact that it's a Monad instance
00:03:20 <jle`> the usefulness of the types comes from the types themselves. Category, Monad, etc. only provide a convenient universal API, and also a way to write polymorphic functions
00:08:36 <jchia_1> jle`: OK
00:08:54 <`Guest05> Binary is not lazy enough
00:15:19 <jchia_1> jle`: OK
00:15:35 <jchia_1> so i just have to open my eyes and see the patterns?
00:15:49 <jchia_1> to see the opportunities for abstraction?
00:16:08 <jchia_1> is there a method for this?
00:16:18 <MarcelineVQ> when you get tired of repeating yourself things tend to pop up on their own
00:16:40 <MarcelineVQ> in my fairly limited experience
00:17:55 <jchia_1> MarcelineVQ: That's also partly my experience with templates in C++.
00:22:58 <ertes> i have a type class with a single type argument that carries no significance except to select the instance, where the associated types are the actual significant types:  class C s where type A s; type B s; type C s; …
00:23:40 <ertes> any of the associated types selects the instance uniquely and determines all others…  what i'd like is to get rid of the 's' argument, because it's redundant
00:24:14 <ertes> i tried with a nullary type class and injective type families, but then GHC insists that i can only have a single instance anyway
00:24:27 <lyxia> class C a b c | a -> b c, b -> a c, c -> a b where ...?
00:25:07 <ertes> lyxia: i'd like to avoid that, because it would make me spell out all the types in every context
00:25:51 <lyxia> Why?
00:25:51 <ertes> any other options?
00:26:19 <ertes> lyxia: myFunction :: (C a b c d e f) => …
00:26:55 <lyxia> oh.
00:27:25 <ertes> also single-letter names aren't really appropriate here, which makes it even worse
00:28:13 <ertes> guess i'll go with the dummy type then
00:32:46 <Cooler> does negate have an instance of functor?
00:34:14 <jle`> Cooler: types are functor instances
00:34:24 <jle`> negate is not a type
00:34:51 <jle`> but, functions have a Functor instance.  or, ((->) r) has a Functor instance
00:35:15 <Cooler> wait
00:35:32 <Cooler> (->) has functor instance?
00:35:38 <narasca> only ((->) a)
00:35:54 <jle`> `((->) r)` has a functor instance, for any r
00:36:14 <Cooler> isn't the kind of (->) r :: *?
00:36:18 <jle`> you can read ((->) r) like (r ->), if sections were allowed for typeclass instances
00:36:21 <Wizek_> hello. I'm in a situation in some of my projects that the import list in some of my files are growing rather longer than I'd like. About 20-40 lines. And many of these are redundant between my modules. So initially I though to use the trick I saw Yesod use: have a file named Imports.hs that does only a single thing: import the common modules and re-export them. Then I realized that this way I won't be able to distinguish my import 
00:36:21 <Wizek_> based on module qualification, e.g. Set.fromList vs Map.fromList to name a common one. Then another idea came: Couldn't I use the C preprocessor for this? I just did a quick test and amazingly writing `#include "Imports.hs"` seems to work! So at this point I decided to ask around: Is there any well-known/potential drawbacks of doing this? I don't remember it being done in any Haskell source I've read.
00:36:24 <jle`> Cooler: not quite
00:36:31 <jle`> what do you think the kind of (->) is?
00:36:42 <Cooler> * -> *?
00:36:54 <Cooler> no wait
00:37:06 <Cooler> * -> * -> * ?
00:37:22 <Cooler> takes 2 types and gives you a function type
00:37:25 <Lokathor> A functor is like any type that can hold a value without the structure needing to change if the value changes, and a function can be thought of as matching that
00:37:45 <Lokathor> well, a partly applied function that is
00:38:29 <jle`> Cooler: yeah
00:38:35 <jle`> so (->) :: * -> * -> *
00:38:39 <jle`> but, say, (->) Int :: * -> *
00:38:42 <jle`> (->) Bool :: * -> *
00:39:13 <Cooler> why does (->) r have a functor instance?
00:39:42 <Lokathor> well if it's a law abiding instance, you'd always prefer to have more instances than less
00:40:35 <jle`> Cooler: are you asking about a fundamental mathematical reason, or about why the instance exists in Haskell?
00:40:44 <jle`> the instance is in haskell because it's a pretty useful one
00:40:56 <jle`> so it would be kind of silly to not have it
00:40:57 <dmj`> Wizek: I’d keep cpp usage to a minimum if possible, and probably for things external to your own logic, like package versions, os’s, compiler versions, etc.
00:42:40 <Wizek_> dmj`, Do you mean that some of those variables may influence of what gets spliced in?
00:43:57 <Cooler> jle`, is the fmap instance for (->) r just function composition .?
00:44:26 <dmj`> Wizek: If you have a lot of imports, it sounds like a refactor might be a better choice, as opposed to reaching for cpp
00:44:36 <jle`> Cooler: interesting idea
00:44:46 <jle`> does fmap = (.) typecheck?  does it follow the laws?
00:45:31 <ertes> jle`: that *is* fmap for ((->) r)
00:45:50 <MarcelineVQ> he's doin a thing :>
00:45:58 <ertes> > ((*2) `fmap` (+ 1)) 5
00:46:01 <lambdabot>  12
00:46:06 <jle`> ertes: Cooler was asking if fmap = (.) makes sense, and i'm suggesting that they can answer that question using their own deduction :o
00:46:17 <ertes> oh, i'm sorry
00:46:33 <ertes> didn't realise that =)
00:46:36 <Cooler> jle`, no i was asking if it fmap == (.) in case of (->) r
00:46:43 <jle`> it's ok, it's not like the answer is a surprise
00:46:54 <jle`> Cooler: you're wondering if fmap = (.) for the case of `(->) r`
00:46:54 <Wizek_> dmj`, Potentially, although the vast majority of the imports that I want to de-duplicate are not intra-project. So if I don't import them from outside packages, are you proposing that I re-implement their functionality within my project?
00:47:04 <jle`> Cooler: my reply is, that's a question you can answer for yourself :o
00:47:07 <jle`> does it typecheck?
00:47:10 <jle`> does it follow the laws?
00:47:18 <MarcelineVQ> ertes: could implicit parameters factor into what you're working on now or are they one level too low? https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#implicit-parameter-type-constraints
00:47:30 <ertes> Wizek_: one option is to optimise your editor for rapid importing…  that's what i do
00:47:38 <jle`> Cooler: keep in mind that all Functor instances are unique
00:47:41 <Cooler> jle`,  well you could have multiple instances for a single typeclass for the same type
00:47:56 <jle`> yeah, that was what my last message was about
00:48:08 <jle`> all Functor instances are unique
00:48:13 <ertes> Wizek_: i have a shortcut to jump to the imports in a separate window, where i generally type a few characters, then tab, then close the window (which automatically sorts my imports, too)
00:48:17 <jle`> if a type has a Functor instance, then that's the *only* Functor instance it can have
00:48:29 <Cooler> ok
00:48:50 <ertes> Wizek_: i have something similar for extensions and exports, too
00:48:58 <Wizek_> ertes, interesting. What setup?
00:49:16 <jle`> Cooler: but, that is a good point
00:49:17 <jle`> :)
00:50:09 <dmj`> Wizek_: I wouldn’t say re-implement, but I’d import moduels from external packages and then export types and functions on types that correspond to your logic. So new functionality can be implemented using only your types
00:50:26 <dmj`> newtype is cheap
00:50:34 <dmj`> and safe
00:50:38 <ertes> Wizek_: emacs + haskell-mode + haskell-interactive-mode + https://github.com/esoeylemez/config/blob/master/emacs/ertes-haskell.el
00:51:03 <dmj`> s/moduels/modules
00:51:10 <Wizek_> Although I'm not sure that would fully solve my use-case: Lately I've been moving code around and I am getting tired of having to move/copy imports from one file to another even if I put them side-by-side.
00:51:35 <Wizek_> ertes, thanks, one of these days I might give [spac]emacs a try.
00:51:39 <ertes> Wizek_: i'm using haskell-import-mapping to get short names for common modules, and for all others i can just tab-complete using haskell-interactive-mode (so it uses the packages in scope for the current project)
00:52:45 <ertes> Wizek_: haskell-interactive-mode also has an option to suggest imports fully automatically, but i'm not using that (it requires some kind of backend like hoogle, which is not practical in my setup)
00:53:06 <ertes> (haskell-interactive-mode is part of haskell-mode)
00:55:51 <Cooler> why does (fmap . fmap) f foo == fmap (fmap f) foo ?
00:57:01 <cocreature> Cooler: (fmap . fmap) f foo = (\x -> fmap (fmap x)) f foo = fmap (fmap f) foo
00:59:04 <Cooler> actually nvm
00:59:08 <Cooler> i see it now
03:31:15 <athan> Is a TChan similar to a list of items, where writing appends an element?
03:31:50 <athan> but without list or indexing operations
03:31:55 <athan> length**
03:32:07 <athan> (and in a concurrent setting, of course)
03:33:16 <athan> The reason I ask, is because I'm trying to model function application over a forked thread
03:33:18 <ph88^> oh nice :)  https://news.ycombinator.com/item?id=13674324
03:33:33 <athan> basically my idea is that `a -> b` could be modeled as `(TChan a, Async b)`
03:34:04 <athan> where the async thread also has access to the TChan reference in its scope, so it can peek at the "applications" so to speak
03:34:27 <ph88^> anyone know which option that guy is talking about ?
03:35:43 <c_wraith> ph88^: something about split-objs
03:36:43 <ph88^> aha it's here !  https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html
03:38:44 <c_wraith> athan: I'm not completely seeing what you mean, as an Async can only return once, where TChan is an unbounded queue
03:38:51 <ph88^> for compiling with llvm i just have to download llvm with my package manager ?
03:39:42 <c_wraith> ph88^: you need the right version of llvm for your version of ghc.  I know that has caused issues in the past.
03:40:00 <ph88^> how do i know which version ?
03:40:43 <ph88^> why is that even required ? did the llvm IR change that much between versions ?
03:42:58 <ph88^> in the docs it says   Currently LLVM 2.8 and later are supported.
03:43:10 <ph88^> and also:  Linux: Use your package management tool.
03:43:35 <AndreasK> LLVM IR has breaking changes with each point version iirc
03:45:06 <ph88^> :(
03:45:52 <ph88^> if i use llvm which linker does it use ?
03:46:09 <c_wraith> whatever your system linker is, for now
03:47:35 <ph88^> ah ok
03:48:05 <AndreasK> The llvm page says "The textual format is not backwards compatible. We don’t change it too often, but there are no specific promises." :(
03:51:20 <lyxia> athan: is that related to pi-calculus
03:55:54 <ph88^> maybe a dumb question .. but if i don't specify anything to parallelize in my program does the -threaded option do anything ?
04:04:08 <ezyang> ph88^: Yes 
04:04:34 <ezyang> it links against the threaded runtime, which is coded differently 
04:04:44 <ezyang> you'll get different (better) IO behavior 
04:07:09 <AndreasK> Anyone know why https://www.haskell.org/hoogle/?hoogle=Num shows Num as requiring a Eq instance but Prelude doesn't?
04:07:28 <ph88^> ezyang, how does my code get executed differently ?
04:07:55 <c_wraith> AndreasK: Num used to depend on Eq and Show.  Those were removed in GHC a while back.  Guess hoogle still thinks it's the old days
04:08:01 <ezyang> ph88^: it should be enitrely observationally equivalent 
04:08:07 <AndreasK> I see thanks
04:17:49 <athan> c_wraith: Ahh good point - yeah I'm not sure if I have my model correct. It might just be an `Async ()`, which internally loops forever or something similar, peeking into the TChan
04:18:25 <athan> lyxia: I don't believe it is related to pi, but I'm not sure :)
04:19:06 * athan needs to get the CTM book >.>
04:28:39 <sphinxo> what is the Wrap type from https://mainisusuallyafunction.blogspot.co.uk/2011/09/lambda-to-pi.html
04:33:25 <marekw2143> hello 
04:33:32 <marekw2143> is putStr always flushes the buffer ? 
04:33:51 <Wizek_> Anyone has encountered the error `Failed to load interface for ‘Gtk2HsSetup’
04:33:51 <Wizek_> ` in relation to cairo, glib, reflex-dom (, ghcjs)? I'm Trying to add reflex-dom to a project using GHC 8.0.2 (tried both with `nix: enable: true/false`). This error usually means that gtk2hs-buildtools is missing, doesn't it?
04:37:00 <haasn> it would be great if we could get literate haskell to recognize ```haskell and ``` as valid code tags
04:43:53 <c_wraith> marekw2143: putStr never flushes the buffer.
04:44:18 <marekw2143> c_wraith, and putStrLn "" ? 
04:44:36 <c_wraith> that will flush if stdout is set to line-buffered
04:44:48 <c_wraith> which is the default if it's attached to a terminal
04:46:31 <marekw2143> hmm, I'm writing chess engine 
04:46:40 <marekw2143> and GUI app uses my code
04:46:48 <marekw2143> and I'm not sure that gui uses line buffered IO
04:47:11 <c_wraith> you can set stdout to non-buffered
04:47:34 <marekw2143> how ? 
04:47:57 <c_wraith> whatever function sets buffering mode on a handle.  I think it's in System.IO
04:48:55 <c_wraith> Yeah.  System.IO has everything that you need for that.
04:49:10 <marekw2143> ok, I'll look for it
04:55:41 <marekw2143> c_wraith, thanks, it works 
04:55:50 <marekw2143> I just didn't think that it's such important 
04:55:55 <c_wraith> you're welcome
04:56:40 <c_wraith> yeah, IO buffering is one of those things that isn't important at all, until everything breaks when it suddenly is important. :)
05:02:23 <marekw2143> ;)
05:02:37 <marekw2143> I just have a question about monad transformers
05:02:51 <marekw2143> their purpose is just to be able to execute one monad in context of another ? 
05:03:31 <Kuros> or making a frankenstein's monad
05:03:38 <c_wraith> I'd describe their purpose as being able to combine the effects of different monads
05:03:49 <athan> marekw2143: Yeah kinda, or extending a monad with the properties of another
05:04:03 <athan> where the monad being extended is the "base" monad
05:04:20 <marekw2143> ok, but when there's for example MaybeList omnad
05:04:34 <marekw2143> then List behaviour (that is applying function to each element of the list) 
05:04:40 <marekw2143> is not handled by MaybeList 
05:04:43 <marekw2143> am I right ? 
05:04:54 <athan> MaybeList a = MaybeT (ListT Identity) a
05:05:28 <athan> idk :)
05:05:50 <athan> usually you see the tuple monad and function monad combined
05:06:01 <athan> as StateT / ReaderT (kinda)
05:09:16 <marekw2143> usually yes
05:09:34 <marekw2143> but list monad is different to other ,that is executes another function many times 
05:09:57 <marekw2143> and that example maybe is not best for learning monad transformers from scratch
05:09:59 <marekw2143> ;)
05:10:11 <marekw2143> but I'm a haskell beginner as you can see ;)
05:10:28 <athan> s_s
05:11:55 <cocreature> marekw2143: list is very rarely used in monad transformer stacks. it’s probably easier to start with something like MaybeT IO if you want to figure out how to use them and why they can be useful
05:21:21 <piyush-kurur> does any one know a function with the types (i -> Source m o) -> Conduit i m o
05:21:53 <piyush-kurur> The intuition is similar to concatMap. I do not seem to find it
05:28:34 <lyxia> piyush-kurur: awaitForever
05:29:00 <lyxia> After composing the continuation with toProducer
05:34:24 <piyush-kurur> lyxia: sorry what do you mean by after composing the continuation with toProducer?
05:35:05 <piyush-kurur> awaitForever just has an extra i in it, i.e. it is (i -> Conduit i m o) 
05:36:21 <piyush-kurur> Okey sorry I think I got it. Let me try
05:36:39 <lyxia> :)
05:37:31 <piyush-kurur> lyxia: yeah worked for me
05:37:40 <piyush-kurur> but that was non-trivial
05:37:44 <lyxia> right
05:37:48 <piyush-kurur> lyxia: thanks
05:38:05 <lyxia> you'll get used to it!
05:38:25 <piyush-kurur> I was banging my head on how to get rid of the i.
05:38:29 <piyush-kurur> for quite some time
05:51:41 <athan> edwardk should rename microlens to lentils, because it's small enough to digest :v
05:55:06 <jmnoz> Is there a way to avoid out of memory death on systems without swap? and low memory. docker.
06:02:02 <sm> jmnoz: if systems means gnu/linux, there's https://github.com/rfjakob/earlyoom
06:06:19 <jmnoz> it's linux. alpine for now. on a low mem server with no swap
06:08:33 <cocreature> jmnoz: there is some way to limit the max amount of ram which will cause the GC to be more aggressive but in the end, when the memory is needed, there is nothing you can do
06:09:31 <c_wraith> jmnoz: if the out of memory is during compilation, you can try using gold instead of ld as your linker
06:09:41 <jmnoz> it's runtime
06:09:56 <c_wraith> Then..  yeah.  No good answer.
06:11:37 <sternmull> jmnoz: You could limit the maximum memory usage of a haskell process with the -M runtime option. See here https://downloads.haskell.org/~ghc/7.0.1/docs/html/users_guide/runtime-control.html
06:12:43 <jmnoz> sternmull: interesting, thanks
06:13:01 <cocreature> yeah that’s the option I was referring to
06:13:20 <cocreature> I would be surprised if you get anything more than a decrease by a factor of 2 using this
06:13:42 <jmnoz> currently my entire machine gets killed off so the process dying would be a step up... I think
06:14:18 <jmnoz> Oh no I guess when the docker CMD ends the container ends
06:17:08 <lordcirth> jmnoz, yes it does.  There's a flag that changes that, which I forget 
06:18:18 <Squarism> theres no testframework in haskell that lets you pick a test in a suite from the commandline?
06:19:29 <cocreature> Squarism: I’m pretty sure hspec and hunit both let you do that
06:19:45 <Squarism> oh ok
06:20:13 <cocreature> hspec has a --match=PATTERN option and then it will only run tests that match that pattern
06:21:22 <vaibhavsagar> is there a way to use that command line option with `stack test`?
06:21:46 <vaibhavsagar> I've resorted to building an executable that is essentially my test suite and using -m there
06:22:00 <Squarism> im using hunit and stack btw
06:22:13 <cocreature> vaibhavsagar: there is a --test-arguments option or something like that that you can use to pass arguments to your test suite via "stack test"
06:25:02 <vaibhavsagar> cool, thanks for letting me know!
06:28:26 <orion> If I require a single function from a massive library, is GHC able to strip out all the unused code associated with that library?
06:30:58 <Squarism> cocreature, thanks for hinting! stack test --test-arguments "-t pattern" works perfectly for the combo stack/hunit/testframework
06:31:00 <athan> orion: I'm not precisely sure, but I've heard that doing sparse imports like `import Foo (foo)` helps the object file size
06:31:13 <athan> I'm sure there's a lot of dead code elimination though
06:31:24 <athan> I think what I noted was just for interface files or something though :s
06:31:42 <athan> you may find better answers on #ghc
06:36:19 <ClaudiusMaximus> orion: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html#ghc-flag--split-objs and -split-sections seem relevant
06:38:54 <orion> ClaudiusMaximus: Thanks.
06:41:13 <orion> Why don't people use -split-sections all the time then?
06:49:37 <sphinxo> What is the Wrap constructor from this tut? https://mainisusuallyafunction.blogspot.co.uk/2011/09/lambda-to-pi.html
06:49:52 <lyxia> newtype MuChan = Wrap (Chan MuChan)
06:56:38 <vctr> is there a good library to do pretty auto-completion hints like what fish shell does?
06:57:12 <vctr> but generalized to non-shell applications?
06:57:48 <jmnoz> is there a way to launch sub processes which can get oom killed without the main process getting killed (complete newbie question)?
07:06:25 <cocreature> jmnoz: not quite, but you can use the allocation limit (https://hackage.haskell.org/package/base-4.9.1.0/docs/System-Mem.html#v:enableAllocationLimit). However, allocations do not reflect the current memory usage but instead the total memory usage. so they are more a bound on the amount of work a thread can do in total
07:07:20 <jmnoz> cocreature: thanks!
07:13:06 <AWizzArd> In my .cabal file I’ve added the dependency ‘list-extras’, and now  stack list-dependencies shows me  list-extras <unknown>
07:16:25 <AWizzArd> Any idea how this can be fixed?
07:17:34 <sphinxo> What is the Wrap constructor from this tut? https://mainisusuallyafunction.blogspot.co.uk/2011/09/lambda-to-pi.html
07:32:55 <EvanR> sphinxo: its a newtype wrapper around a Chan of itself
07:33:08 <EvanR> since you cant do Chan (Chan (Chan (...
07:33:18 <EvanR> it would be an infinite type
07:37:55 <stevenxl> Hi folks. I'm having a bit of a tough time defining an expression. 
07:38:10 <stevenxl> Are atomic values such as 1 valid expressions?
07:38:17 <stevenxl> Would a structured value be a valid expression?
07:40:09 <Welkin> stevenxl: example code?
07:40:53 <stevenxl> Welkin - Hi. There's no code to show. Sorry, I used defining poorly. I meant to say I am having a tough time understanding what an expression is. 
07:41:15 <Welkin> everything is an expression
07:42:43 <cocreature> stevenxl: the haskell standard which defines this is relatively easy to understand in that regard https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003
07:44:07 <stevenxl> cocreature: thanks - i'll take a look
07:44:10 <stevenxl> Welkin: thank you!
07:45:04 <cocreature> “everything is an expression” is not quite true, but the things that are not are usually pretty obvious
08:18:30 <maksim__> i'm trying to debug a package in ghci
08:18:43 <maksim__> executing :main gives me gcc: error: /tmp/ghc3784_0/ghc_318.o: No such file or directory
08:18:44 <maksim__> phase `Linker' failed (exitcode = 1)
08:26:07 <pavonia> maksim__: Did you delete temp files while GHCi was still running?
08:26:19 <maksim__> pavonia, no
08:26:45 <maksim__> unless suspend deletes temp files?
08:26:54 <pavonia> Does that happen for all programs or just a certain one?
08:27:21 <ClaudiusMaximus> is /tmp full?
08:27:38 <maksim__> pavonia, i have only one program that i've been working on on this machine
08:27:43 <maksim__> ClaudiusMaximus, no
08:29:10 <cocreature> maksim__: are you using plain ghci or "stack ghci" or "cabal repl"?
08:29:23 <maksim__> stacak
08:30:18 <cocreature> I think I’ve seen that with stack before but I never figured out what was causing it. usually it disappeared after restarting "stack ghci" or "stack clean"ing
08:56:21 <Cooler> for the Constant functor, why can't fmap map over the a type?
08:56:39 <Cooler> in data Constant a b = Constant a
08:57:18 <Cooler> actually its newtype Constant a b = Constant { getConstant :: a }
08:57:27 <Cooler> deriving (Eq, Show)
08:57:49 <Welkin> look at the Functor instance
08:57:57 <Welkin> it depends on how it is defined
08:58:43 <geekosaur> Cooler, the short reason is that the type variable to map over has to be the *last* one in the type definition
08:58:49 <Welkin> http://hackage.haskell.org/package/transformers-0.5.4.0/docs/src/Data-Functor-Constant.html#line-87
08:58:54 <geekosaur> it's the one that is "exposed"
08:59:33 <Welkin> I know that (,) is a common source of confusion for Functor as well
09:00:10 <geekosaur> (this is similar to how you can simplify `f a xs = ... xs` by removing the `xs` on both sides because it's at the end on both sides, but the `a` can't be moved the same way)
09:01:48 <Cooler> oh wait i think its because fmap :: (a -> b) -> f a -> f b and f a in this case is Constant x y where f = Constant x and a = y, and f b is Constant x z where b = z, so a -> b is y -> z which can't be applied to the pattern match of the data constructor Constant s where s :: x
09:04:56 <Welkin> it's not necessarily a technical reason
09:05:27 <Welkin> semantically, it is doing what a constant should
09:05:42 <Welkin> same with (,) as a (key-value) pair
09:06:20 <tfc> anyone here every used ghci with some shelly/hsh/whatever language as default shell?
09:07:01 <Cooler> Welkin, well not really, if you apply (+2) to the literal (constant) 2    (+2) 2 = 4
09:07:34 <Welkin> that's not the constant I'm talking about
09:07:36 <Cooler> Welkin, what you are thinking of is an eigen value
09:07:50 <Cooler> that doesn't change when put through a function
09:07:53 <Welkin> > const 2 4
09:07:56 <lambdabot>  2
09:08:17 <Welkin> it will always produce a 2 no matter what
09:08:28 <Cooler> oh your talking about the function const
09:08:47 <Cooler> no we were discussing the newtype Constant
09:08:59 <Welkin> Constant is just a data representation of the same concept, isn't it?
09:09:17 <Cooler> yes
09:10:04 <Cooler> but it could also make sense in terms of literal constants like 2
09:10:29 <Tuplanolla> A literal actually follows the same concept, but it's actually "constant over universal quantification", Cooler.
09:11:04 <SudhanshuJ> My program takes Integers as input and returns a string based upon calculations that may be fractional
09:11:18 <SudhanshuJ> It doesn't compile however http://lpaste.net/352691
09:12:38 <monochrom> use fromIntegral on books too
09:15:32 <SudhanshuJ> <monochrom> I thought since one of them will be in that (float-like) format it should work ?
09:16:27 <SudhanshuJ> <monochrom> It worked Thanks.
09:32:02 <maksim__> cocreature, did stack clean and build
09:32:05 <maksim__> still can't run main
09:32:31 <cocreature> maksim__: sorry not sure what’s going on then
09:32:41 <cocreature> maksim__: do you use the C ffi?
09:32:45 <maksim__> yes
09:33:22 <maksim__> cocreature, yes
09:35:29 <cocreature> maksim__: there were problems in the past with stack ghci and the C ffi, so opening a bugreport is probably the best you can do
09:38:34 <fizbin> Is anyone else using "cabal new-build" ? I am and I'm finding I have to wipe out the dist-newstyle directory every time 
09:38:59 <fizbin> I switch from profiling to non-profiling builds. Am I doing something wrong?
09:40:33 <cocreature> fizbin: I haven’t experienced that myself but I’m using git master instead of 1.24. you might want to try that as well
09:46:52 <ombasa> I want to make an abstract program which can take different read-only presets that specifies functions, e.g. a preset that specifies (*) or (+) for folding list which is a common operation throughout the program. If I use a Reader monad everything becomes monadic. Is there any disadvantage for passing around a data structure representing the preset which containing the specified functions?
09:49:31 <Cale> ombasa: no
09:50:05 <ombasa> What then is the purpose or advandage of the Reader monad?
09:50:13 <Cale> ombasa: apart from the few characters you'll spend on the function argument, and the fact that it will be possible to change what the argument is from various points in the program
09:50:36 <Cale> The reader monad *on its own* is not terribly practical
09:50:55 <cocreature> ombasa: you don’t need to manually pass the same argument to a lot of functions
09:51:13 <cocreature> it’s just a syntactic nicety
09:51:15 <Cale> But it's another way of expressing the same thing
09:51:56 <ombasa> Okay, so the trade off is that you don't have to pass the data structure around, but you have to do monadic computation 
09:52:01 <Cale> Of course, if you ReaderT over something like IO, then it's also a syntactic disadvantage, to about the same degree.
09:52:22 <the_2nd> Has anyone sent an array of values via a from to happstack? I struggle getting it to parse properly. Can anyone help?
09:52:46 <Tuplanolla> I think the real benefit stems from `MonadReader` instead of `Reader` directly, ombasa.
09:54:34 <ombasa> `Tuplanolla` I though they where the same. What's the benefit of MonadReader compared to passing a datastructure, ignoring the extra argument?
09:55:17 <Cale> Well, hah, I just finished refactoring all the MonadReader constraints out of a large project so that our type errors would be sane again, so I don't think it's that either.
09:55:46 <Tuplanolla> With `MonadReader` you don't need to explicitly `lift` other things through it, ombasa.
09:55:47 <Cale> But we still use ReaderT -- it's just we use it with a custom type class instead of MonadReader
09:56:35 <Cale> The trouble with having large amounts of code generalised over MonadReader is that (->) e is a MonadReader instance for any type e, so if you forget an argument to a function, it confuses the shit out of GHC most of the time and you get terrible type errors.
09:57:08 <Tuplanolla> That's a fun one.
09:57:09 <Cale> (which usually occur at the level of the entire definition in which the omission applies to, rather than on the line where you missed the arg)
09:58:27 <Welkin> mombasa
09:58:41 <ombasa> yes
09:58:44 <Cale> So it's much better if you define your own type class with operations to get the things you want -- it looks better too, to have something like  getUserToken  rather than something like  asks userEnvUserToken
10:00:24 <Cale> But then you can implement those operations for ReaderT of whatever
10:00:44 <Cale> The important thing is just to somehow hide the specific monad that you're using.
10:01:25 <Cale> (If you want extensibility in terms of the operations it supports)
10:02:44 <ombasa> okay so instead of passing around data Preset: cmp1=(<), cmp2=(>=) then instead implement getCmp1=(<) somewhere at top level and use it in all the deeper functions
10:02:45 <Cale> and the constraints on whatever monad it actually is can come from either type class constraints or from polymorphic function arguments which carry operations for some monad m -- with Reader only, that would be kinda silly though
10:06:12 <Cale> Well, I don't know what you're doing, but you *might* have something like  class HasComparisons m where getComparison :: Ord a => m (a -> a -> Bool)
10:06:28 <Cale> er, I intended to do more than one operation there :)
10:06:44 <Cale> But whatever, you should name the class something more specific to your application anyway
10:07:14 <Cale> also, you might rather specify an operation which only works for a specific 'a' rather than any type 'a'
10:07:31 <Cale> In which case, probably the easiest thing is a functional dependency
10:07:50 <Cale> class HasComparison a m | m -> a where getComparison :: m (a -> a -> Bool)
10:08:02 <Cale> and then you might write something like
10:08:38 <Cale> instance Monad m => HasComparison a (ReaderT (a -> a -> Bool) m) where getComparison = ask
10:08:42 <maksim__> why am i getting a cabal.config parse error here? http://pastebin.com/ZAXQUPtU
10:08:59 <maksim__> Unable to parse cabal file /home/maksim/dev_projects/databrary/databrary.cabal: NoParse "other-modules" 84
10:09:22 <maksim__> changing to exposed-modules gives me a different parse error
10:09:30 <maksim__> Cabal file warning in /home/maksim/dev_projects/databrary/databrary.cabal: Unknown fields: exposed-modules (line 84)
10:10:11 <Cale> maksim__: On that line in your paste, you have other-modules, rather than exposed-modules. Are you sure you pasted the same thing?
10:10:25 <Cale> oh, oops
10:10:27 <maksim__> Cale, i'm saying both give me a parse error, 2 different parse errors
10:10:43 <ombasa> exposed_modules gives me parse errors as well
10:10:49 <Cale> okay, is an Executable section allowed to have exposed-modules?
10:11:03 <Cale> I wouldn't expect that
10:11:18 <maksim__> ah
10:11:35 <maksim__> so why is stack warning me that not exposing those modules could lead to linker errors
10:11:46 <ombasa> so in a test-suite you need to list all the modules tested in 'other-modules'?
10:13:40 <Cale> You should list the modules under other-modules... I don't know why you're getting a parse error for that though.
10:14:05 <Cale> oh, I know why
10:14:09 <Cale> There are no commas
10:14:24 <maksim__> lol
10:14:25 <monochrom> heh
10:15:04 <Cale> Databrary.Store.Config- In databrary component:
10:15:07 <Cale> also this
10:15:14 <orion_> The darkness of humanity seeps from this bottomless pitch-black hole, the gap filled by the accumulation of the curse.
10:15:17 <orion_> The darkness of humanity seeps from this bottomless pitch-black hole, the gap filled by the accumulation of the curse.
10:15:23 <Cale> oops
10:15:53 <maksim__> Cale, i don't understand
10:15:58 <maksim__> oh
10:16:00 <maksim__> i see it now
10:42:50 <Xyza> hi
11:23:42 <delYsid> Ugh, where do I start to get a grip on Lens?  wreq sorta forced me to use it, and I just realized I dont have any clue how it works.
11:24:40 <delYsid> In particular, I have defaults & manager .~ Left settings, and I wonder if I can construct a Lens that will update a certain field in the ManagerSettings.
11:27:54 <Tuplanolla> Get yourself Microlens' documentation and read about `view`, `set`, `over` and `toListOf`, delYsid.
11:42:04 <nitrix> delYsid: Sticking to the simplified Lens' type might help too.
11:43:10 <johnw> delYsid: it will probably look like "manager.nameOfField"
12:27:53 <jle`> delYsid: what you have is set manager (Left settings) defaults
12:29:27 <jle`> if you want to set a specific field, if you have a lens availab,e you can do `set (manager . _Left . nameOfField) defaults`
12:59:35 <clmg> How do I use maybes with fclabels?
12:59:55 <clmg> For instance if I want to set (c . Just b . a) how?
13:26:25 <lalalala> How do I use local functions when I use IO?
13:26:38 <lalalala> when the function returns a IO type*
13:27:06 <tom7942> fmap
13:30:11 <stevenxl> Hi folks. I want to check if I understand right / left associativity correctly. Left associativity means that, if I fully parenthesis an expression, I would start with the parenthesis on the left. For example, functions are left associative, so add 1 2 is equivalent to (add 1) 2. 
13:31:02 <stevenxl> Right associativity means that, if I fully parenthesis an expression, I would start with the parenthesis on the right. For example, the cons operator is right associative, so 1:2:3:[] is equivalent to (1:(2:(3:[])))
13:32:50 <tom7942> helps to use mathematical operators like ^ and (+ - * / )
13:35:20 <tom7942> is it 5^(4^(3^2)) or ((5^4)^3)^2 ? 
13:35:51 <lalalala> someone knows how to help me with what I wrote earlier? :)
13:35:58 <bollu> lalalala: what was the question?
13:36:02 <monochrom> > [5^4^3^2, 5^(4^(3^2)), ((5^4)^3)^2]
13:36:06 <lambdabot>  [620606987866087447074832055728467930919421926519911717317738324478446890420...
13:36:09 <monochrom> oops
13:36:15 <bollu> monochrom: modulo 12 or something
13:36:24 <monochrom> oh, good idea
13:36:31 <lalalala> bollu: How do I use local functions when the functions returns a IO type? 
13:36:37 <bollu> > map `mod 17` [5^4^3^2, 5^(4^(3^2)), ((5^4)^3)^2]
13:36:37 <monochrom> > map (`mod` 12) [5^4^3^2, 5^(4^(3^2)), ((5^4)^3)^2]
13:36:39 <lalalala> function*
13:36:41 <lambdabot>  <hint>:1:10: error: parse error on input ‘17’
13:36:42 <lambdabot>  [1,1,1]
13:36:44 <bollu> fuck, I fucked p
13:36:45 <bollu> xD
13:36:46 <bollu> lol
13:36:52 <monochrom> 12 is no good
13:36:55 <bollu> > map `mod` 17 [5^4^3^2, 5^(4^(3^2)), ((5^4)^3)^2]
13:36:58 <bollu> prime should be better
13:36:59 <lambdabot>  error:
13:36:59 <lambdabot>      • Could not deduce (Num t0)
13:36:59 <lambdabot>        from the context: (Num ([t] -> (a -> b) -> [a] -> [b]),
13:37:00 <monochrom> > map (`mod` 17) [5^4^3^2, 5^(4^(3^2)), ((5^4)^3)^2]
13:37:03 <lambdabot>  [1,1,16]
13:37:07 <bollu> argh, yes, thanks
13:37:41 <monochrom> @quote monochrom 17
13:37:41 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
13:37:43 <bollu> lalalala: what does "local function" mean?
13:37:56 <tom7942> lol
13:37:57 <lalalala> bollu: let me show ya, a sec
13:39:00 <tom7942> lalalala: lift functions over structure with fmap
13:39:20 <lalalala> bollu: https://gist.github.com/freddedotme/caab60ab11f2964d666814f2a67a1bae
13:39:22 <lalalala> tom7942: what?
13:40:17 <bollu> lalalala: oh, IIRC, where and do do not play well. Instead, use let
13:40:33 <monochrom> I think this "where" should be fine. What's the problem?
13:40:41 <bollu> lalalala: or you can use a let inside the do
13:40:48 <lalalala> it isn't since return is running and it will never reach it
13:40:59 <lalalala> ^monochrom
13:41:07 <bollu> monochrom: is it?
13:41:10 <bollu> monochrom: I'm not sure
13:41:19 <lalalala> it will compile and never run the where bollu
13:41:27 <bollu> lalalala: what do you mean?
13:41:36 <lalalala> bollu: the functions stops after return as it should
13:42:10 <bollu> lalalala: wait, what happens when you run this piece of code, exactly?
13:42:20 <monochrom> What is inside "..."?
13:42:31 <lalalala> bollu: it compiles and ends the function at return
13:42:46 <lalalala> monochrom: let me update it
13:43:00 <bollu> lalalala: that is not the way "where" works, or "return" for that matter. 
13:43:38 <lalalala> bollu: how come it compiles then and runs?
13:43:49 <bollu> lalalala: because you're not doing anything syntactically wrong
13:44:03 <bollu> lalalala: but I think you have misunderstood return, and haskell's evaluation model
13:45:01 <lalalala> bollu: now it works as where should, weird, no idea what I did wrong earlier
13:45:10 <monochrom> OK good.
13:45:23 <monochrom> "did not save the file" or something
13:45:32 <lalalala> monochrom: :p probably... smh
13:45:38 <bollu> lalalala:  :)
13:45:41 <lalalala> thanks tho!
13:45:51 <bollu> lalalala: just to clarify, return is not the same as the usual return in other languages
13:45:59 <bollu> lalalala: I hope you are aware of that? :)
13:46:36 <tom7942> doesn't matter; program works
13:46:45 <lalalala> bollu: it's do bracket specific or?
13:46:45 <bollu> tom7942: :P
13:46:56 <bollu> lalalala: return is just another function in haskell
13:46:58 <bollu> :t return
13:46:59 <lambdabot> Monad m => a -> m a
13:47:03 <bollu> lalalala: it's not a language inbuilt
13:47:10 <bollu> lalalala: yes, it's closely related to monads
13:47:22 <monochrom> Consider do { x <- return 5; print x }
13:47:48 <bollu> > do { x <- return 4; y <- return 3; return 2; print x; }
13:47:51 <lambdabot>  <IO ()>
13:47:54 <lalalala> x will return a 5 of type IO Int or?
13:47:55 <bollu> well fuck
13:48:04 <monochrom> Run it on your computer.
13:48:04 <bollu> I was hoping lambdabot would strip the IO
13:48:17 <bollu> would print the output*
13:48:26 <monochrom> lambdabot doesn't want to get into security trouble, that's all.
13:48:27 <bollu> > do { return 2; return 3 }
13:48:27 <lalalala> oh it :t is IO ()
13:48:30 <lambdabot>  error:
13:48:30 <lambdabot>      • Ambiguous type variables ‘m0’, ‘b0’ arising from a use of ‘show_M67005...
13:48:30 <lambdabot>        prevents the constraint ‘(Show (m0 b0))’ from being solved.
13:48:34 <lalalala> ops...
13:48:39 <bollu> > do { return 2; return 3 } :: IO Int
13:48:43 <lambdabot>  <IO Int>
13:48:46 <bollu> -_-
13:48:52 <bollu> > do { return 2; return 3 } :: Maybe Int
13:48:55 <lambdabot>  Just 3
13:49:05 <bollu> lalalala: ^ (if you know that Maybe is a monad)
13:49:15 <lalalala> no, i still don't get the concept of monads tbh
13:49:21 <bollu> lalalala: OK
13:49:31 <tom7942> lalalala:  how about a functor?
13:49:49 <tom7942> > :t fmap
13:49:52 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
13:50:05 <lalalala> sorry no
13:50:19 <tom7942> lalalala:  how about map?
13:50:22 <lalalala> yeye
13:50:25 <bollu> lalalala: personal suggestion that people may disagree with: forget trying to understand "what a monad is". Start using haskell. You will find problems for which you will need a particular function with a particular type (usually >>= or >>). Then, just use the function. Till you get a feeling for what is happening. 
13:50:41 <monochrom> I actually agree.
13:50:44 <tom7942> ok, so fmap is like map, only for generic structure. 
13:50:59 <tom7942> map is fmap specialized to list structure
13:51:21 <tom7942> list is one kind of functor
13:51:29 <tom7942> a tree could be another kind
13:51:42 <monochrom> You have always used natural numbers to count money and you still don't know rings and fields and even the Peano axioms. This is normal.
13:52:13 <lalalala> tom7942: a functor of originally what?
13:52:14 <bollu> monochrom: I wonder if bourbaki had decided to setup a school, whether the opposite would have happened :P
13:52:17 <Tuplanolla> I'm not sure this is going to be helpful, tom7942.
13:52:29 <tom7942> ok
13:52:37 <bollu> tom7942: but please do try
13:53:03 <tom7942> lalalala:  oh, a functor of whatever the type inside the list is
13:53:05 <elperdut> Tuplanolla, I am anxious to see an explanation. I have sort of an intuition about this now, but the more I hear/read about it the better.
13:53:17 <lalalala> hm okey
13:53:21 <monochrom> bollu: I can imagine that. Because there was a time I wanted that too. (Later saw how wrong it was.) And I also observe that many math enthusiasists tend to think like that.
13:53:23 <bollu> elperdut: for Functor? or Monad?
13:53:30 <elperdut> functor
13:53:32 <tom7942> lalalala:  this is what I meant about lifting over structure
13:53:38 <bollu> monochrom: oh no, I don't think that will work
13:53:46 <bollu> monochrom: like, abstract to concrete is the way we learn in most cases
13:53:49 <Tuplanolla> For sure, but our original goal was performing `IO`, elperdut.
13:53:52 <bollu> monochrom: but it would be.. interesting
13:53:53 <tom7942> you have a list of values, you want to do something to them
13:54:01 <tom7942> so you map a function onto the list
13:54:09 <elperdut> this is what gave me (what i think) is my aha moment - https://blog.jle.im/entry/inside-my-world-ode-to-functor-and-monad.html
13:54:11 <tom7942> the function you map knows nothing about the list
13:54:47 <monochrom> "Wouldn't it be nice if kindergarten begins with category theory, primary school does universal algebra, secondary school does fields and rings, university undergrad does complex numbers... and finally when you go for a PhD you will finally see how to multiply natural numbers"
13:54:55 <elperdut> you sort of inject the code for "how to handle the structure", that's why the function doesn't need to know it. right?
13:54:57 <bollu> lol
13:54:59 <tom7942> yeah the functor is only interesting because it's a superclass of monad
13:55:06 <tom7942> so we're rewinding a few steps 
13:55:17 <elperdut> ok good. i'll be quiet.
13:55:25 <tom7942> no, speak up please
13:55:46 <tom7942> elperdut:  so the functor is the thing that knows how to handle the structure
13:55:47 <bollu> monochrom: do you know a natural class of Profunctor examples?
13:55:59 <tom7942> so your list functor knows how to process each element in the list structure
13:56:00 <monochrom> No. I haven't studied Profunctors.
13:56:07 <bollu> monochrom: OK
13:56:20 <bollu> monochrom: do you know lens' internals by any chance?
13:56:22 <tom7942> the tree functor does the same for tree strutures
13:56:26 <monochrom> Neither.
13:56:31 <bollu> monochrom: hm, OK :)
13:56:35 <Cale> bollu: What kind of thing are you looking for?
13:56:49 <elperdut> check out the small paragraph in the "Can I have a lift?" section of the article I posted by Justin Le
13:56:54 <Cale> bollu: What's a "natural class"?
13:56:55 <bollu> Cale: in the Profunctor case, some natural set of examples. Something akin to Sn or dihedral in groups
13:57:00 <Cale> ah
13:57:02 <elperdut> btw, do you guys think Justin Le is ever in this channel? he's freakin' awesome
13:57:11 <bollu> Cale: is there such a thing?
13:57:18 <tom7942> lift isn't a precise term, but we use it anyways
13:57:32 <bollu> tom7942: one can make it precise, though
13:57:34 <monochrom> would that be jle` ?
13:57:44 <Cale> Well, Hom functors are the most obvious ones.
13:57:47 <tom7942> sure, in haskell :)
13:58:20 <bollu> Cale: right :)
13:58:24 <bollu> Cale: can I have 2 more examples?
13:58:27 <lalalala> oh I got another question
13:58:27 <Cale> and Hom functors which have been composed with some other things in various ways
13:58:39 <bollu> Cale: such as?
13:58:47 <lalalala> I wanted to use a web framework to get input from a html form, is that possible to do?
13:59:04 <bollu> lalalala: yes, it is
13:59:12 <Cale> I mean like Hom(F(-), G(-)) for some appropriately typed functors F and G
13:59:33 <bollu> Cale: hm
13:59:37 <lalalala> bollu: can you recommend any specific web framework?
13:59:40 <bollu> Cale: what's a concrete example?
13:59:51 <bollu> lalalala: I have played around with Yesod and Snap. I like Snap as it is easy to start with
14:00:45 <bollu> lalalala: but I don't know what the space is like, currently :) take what I say with a grain of salt
14:00:56 <mniip> 1487455000 [00:56:40] <elperdut> btw, do you guys think Justin Le is ever in this channel? he's freakin' awesome
14:00:58 <mniip> his nick is jle` 
14:01:10 <elperdut> cool, thanks mniip
14:01:17 <lalalala> bollu: thanks
14:01:37 <bollu> Cale: of the Hom(F(-), G(-))?
14:01:42 <lalalala> bollu: can i use a apache or nginx host or are they based on something else?
14:02:04 <tom7942> lalalala: scotty?
14:02:37 <tom7942> apache is C
14:02:45 <Cale> Oh, here's another: suppose we just take some arbitrary sets A and B, and consider them as discrete categories. Then relations R: A -> B can be seen as profunctors P: A -/-> B where if R(a,b) then P(a,b) = {*} (some one-element set) and otherwise P(a,b) = {}
14:03:04 <lalalala> tom7942: wat
14:03:10 <hpc> lalalala: you're writing your own webserver, with those libraries compiled in
14:03:14 <hpc> it's a different model from cgi
14:03:24 <hpc> or mod_foo
14:03:26 <Cale> and then composition of profunctors corresponds to composition of relations
14:03:33 <lalalala> hpc: okey, but I mean if I want to put it on a host, I'd have to run a VPS or something then, since most hosts are based on other things?
14:03:41 <tom7942> lalalala:  http://hackage.haskell.org/package/scotty
14:03:59 <kr_> lalala: most haskell web frameworks provide an integrated server and/or a wai interface (which is like wsgi for python)
14:04:01 <bollu> Cale: where is the co/contra variance?
14:04:13 <Cale> bollu: I dunno, just pick basically any pair of functors which would go there.
14:04:24 <kr_> lalalala: you then either reverse proxy, or use a wai web server
14:04:27 <Cale> and stick ^op on things to make it work out
14:04:35 <tom7942> bollu and Cale are having a higher order conversation here
14:05:18 <lalalala> thanks for the info
14:07:20 <bollu> Cale: what are the arrows in your sets-as-categories A and B?
14:07:25 <Cale> lalalala: Basically any of the Haskell web servers will be able to do that. Scotty is one of the more lightweight ones. Snap will also do. I would be surprised if happstack-server didn't also do it.
14:07:37 <Cale> bollu: Just the identities
14:07:37 <lalalala> Cale: alright
14:07:57 <bollu> Cale: oh
14:10:51 <AWizzArd> In the dependency section of my .cabal file I listed  , list-extras    but also tried   list-extracs >= 0.4.1.4   but „stack list-dependencies” only shows me „list-extras <unknown>”.
14:11:00 <AWizzArd> How can I add it, so I can make use of argmax?
14:13:16 <Cale> AWizzArd: What's the problem you're having?
14:14:52 <AWizzArd> Cale: I am using Intero (Emacs). I want to call argmax, to find the triple (a,b,Int) where the third element is the maximum of a list of such triples.
14:15:20 <AWizzArd> It seems that argmax is good for that. I’ve added it as a dependency, the same way as I did it before with other libs.
14:16:00 <AWizzArd> Now however when I restart Intero, it tells me that there was a problem. And as mentioned above `stack list-dependencies` does say version <unknown>, while all other deps are listed with a concrete version number.
14:17:49 <bollu> Cale: P :: A^op x B -> Set right?
14:17:54 <bollu> Cale: in your example?
14:17:59 <bollu> Cale: I am unfamiliar with the P: A -/-> B notation
14:19:22 <Cale> bollu: yes
14:19:57 <Cale> AWizzArd: You could also just use maximumBy (comparing (\(x,y,z) -> z))
14:20:10 <lalalala> can I somehow avoid the duplicates of r0 and r1 in this function? https://gist.github.com/freddedotme/64fc391ffaa2e7fb11a3f02f93ddfa88
14:20:35 <Cale> AWizzArd: I'm not sure, I've never tried intero.
14:20:51 <Rembane> lalalala: By using MonadRandom. 
14:20:51 <dolio> I think it's B^op × A if you want to get super technical.
14:21:01 <bollu> dolio: really?
14:21:08 <lyxia> lalalala: check the conditions after getting r0 and r1 instead of before in the guards
14:21:10 <Cale> Oh, yeah, I wasn't paying very close attention :)
14:21:12 <Cale> haha
14:21:14 <AWizzArd> Cale: it’s not related to Intero. Stack can’t download this version it seems. Or cabal.
14:21:18 <bollu> dolio: isn't it contra in the first argument and then co in the second?
14:21:21 <Rembane> lalalala: https://hackage.haskell.org/package/MonadRandom-0.5.1/docs/Control-Monad-Random-Lazy.html
14:21:36 <Cale> AWizzArd: maybe you need an additional resolver in stack? I also don't use Stack very much.
14:21:43 <dolio> bollu: No, not the way the category theorists do it.
14:21:49 <bollu> dolio: I see
14:22:14 <lalalala> Rembane: that's the only way?
14:22:20 <lalalala> lyxia: hm what?
14:22:52 <Tuplanolla> :t let mapReaderTIO f m = ask >>= (runReaderT m >>> f >>> liftIO) in mapReaderTIO -- Does this function seem suspicious to anyone?
14:22:52 <Tuplanolla> :t let mapReaderT f m = ask >>= (runReaderT m >>> f >>> lift) in mapReaderT -- It's a specialized version of this one.
14:22:57 <lyxia> lalalala: genTeams p@(x0 : x1 : xs) = do { r1 <- ... ; r2 <- ... ; if length p == 3 then return ... else do { rest <- ... ; return ... } }
14:22:58 <lambdabot> forall k (m :: * -> *) a b (m1 :: k -> *) (a1 :: k). (MonadIO m, MonadReader a m) => (m1 a1 -> IO b) -> ReaderT a m1 a1 -> m b
14:22:58 <lambdabot> forall k a b (m :: k -> *) (a1 :: k) (t :: (* -> *) -> * -> *) (m1 :: * -> *). (MonadTrans t, MonadReader a (t m1), Monad m1) => (m a1 -> m1 b) -> ReaderT a m a1 -> t m1 b
14:23:19 <Cale> bollu: You could probably get by with either convention so long as you're consistent about it, but C -/-> D meaning D^op x C -> Set is probably the most obvious one.
14:23:22 <Rembane> lalalala: No, lyxia's way is better. My was just a general advice on how to make working with randomness less painful in Haskell. :)
14:23:32 <bollu> Cale: I see
14:23:42 <lalalala> can you fellas give an example of how, Rembane lyxia ?
14:24:01 <lyxia> lalalala: I just did.
14:24:06 <dolio> bollu: The reason being (among others) that when you turn a functor F : A -> B into a profunctor Hom(-, F=) : A -/-> B, you can see that it's B^op × A -> Set.
14:24:20 <lalalala> lyxia: oh i didn't see that, my bad.
14:24:25 <bollu> dolio: what is Hom(-, F=)?
14:24:28 <lyxia> lalalala: np.
14:24:43 <Cale> It's the bifunctor which sends (X,Y) to Hom(X,FY)
14:24:54 <Cale> Or profunctor, rather :)
14:24:54 <bollu> is the "=" standard notation?
14:24:58 <bollu> :)
14:25:06 <Cale> it's just a double dash, indicating a second argument
14:25:09 <bollu> ahh
14:25:10 <bollu> OK
14:25:26 <dolio> And that lifting preserves the variance.
14:25:27 <AWizzArd> Cale: thx for the maximumBy suggestion. Works too.
14:25:37 <Cale> A lot of the time, people will write another long dash and just expect you to discern that it means a different argument from the first dash.
14:25:39 <dolio> If F is a covariant functor, Hom(-,F=) is a covariant profunctor.
14:25:51 <dolio> Covariant in its A stuff.
14:26:38 <dolio> The other way of turning F into a profunctor, Hom(F-, =) makes it contravariant in the A stuff.
14:26:54 <bollu> right
14:26:58 <dolio> So it'd be flipping the variance.
14:28:19 <AWizzArd> Is there a Haskell code pasting website?
14:28:25 <Tuplanolla> @paste
14:28:25 <lambdabot> Haskell pastebin: http://lpaste.net/
14:28:26 <bollu> lpaste.net
14:28:41 <miscyb> hi i'm trying to build a package on hackage that requires gi-gtk, and hackage is complaining that it doesn't have some stuff in pkg-config
14:28:48 <miscyb> what's the proper way to upload this?
14:28:54 <miscyb> https://hackage.haskell.org/package/reactive-banana-gi-gtk
14:29:38 <ezyang> miscyb: The haddock docs? You can build and upload them yourself 
14:29:47 <AWizzArd> Tuplanolla: thx
14:30:15 <ezyang> What do people think is the best performing trie implementation in Haksell? 
14:30:16 <AWizzArd> Can this be written in a better/more haskellish way?  maximumBy (\(_,_,p1) (_,_,p2) -> compare p1 p2) myListWithTriples
14:30:18 <miscyb> ezyang: is there a stack command i can use for that?
14:31:01 <ezyang> miscyb: Dunno; I guess not see https://github.com/commercialhaskell/stack/issues/737 
14:31:03 <Tuplanolla> I'd write `maximumOn (view _3)`, AWizzArd.
14:32:32 <AWizzArd> :t view  => var not in scope
14:32:34 <lambdabot> error: parse error on input ‘=>’
14:32:43 <c_wraith> AWizzArd: Tuplanolla's example uses lens
14:33:00 <AWizzArd> c_wraith: okay, didn’t study those yet.
14:33:26 <Tuplanolla> I have become a lens addict.
14:35:30 <c_wraith> lens is an amazing sweet spot of concise and principled.  The only downside is that learning it means picking up a rather large collection of new ideas.
14:35:55 <bollu> does MakeLenses generate prisms as well?
14:36:51 <lalalala> im using Atom atm, any "real" IDE that is better to use?
14:37:06 <dolio> There's makePrisms for making prisms.
14:38:28 <bollu> Tuplanolla: do you lens your entire codebase? or only parts?
14:38:59 <bollu> Tuplanolla: as in, do you generate lenses for every data type?
14:41:37 <AWizzArd> lalalala: I like Intero, for Emacs.
14:42:13 <Tuplanolla> Usually all or nothing, bollu.
14:42:24 <bollu> Tuplanolla: OK, ty
14:43:31 <chopsuey> More Linux channels plz 
14:44:44 <lalalala> AWizzArd: gonna check thx
14:46:41 <bollu> who uses that much category theory to encounter things like "Sieve"?
14:49:25 <Prutheus> someone here who can help me witha hakyll-related question?
14:58:30 <bollu> if I have a prism, how do I check if a value is "accepted" by the given prism?
15:00:13 <`Guest05> can stack help with crosscompiling to windows 32bit if i have 64-bit Haskell Platform and don't want to reinstall?
15:01:31 <`Guest05> and am on 64-bit windows
15:13:15 <c_wraith> bollu: if you just want a boolean back, https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Fold.html#v:has
15:13:36 <c_wraith> bollu: if you want to actually do something with the value if it matches, just use it as a traversal
15:14:02 <bollu> c_wraith: I see
15:44:17 <maksim__> is it possible to get ghci :history to give more than 20 results?
15:45:42 <c_wraith> ghci uses the haskeline library for things like that.  It's probably configurable one way or another
15:46:26 <maksim__> no i mean during debugging
15:46:29 <maksim__> for the stack trace
15:46:33 <c_wraith> Oh, I see
15:47:02 <maksim__> fghci-hist-size=n
15:47:02 <lalalala> hm Scotty is acting up for me, I get this error "Expected type: ScottyM () Actual type: ActionM ()" even though I just copied their example?
15:47:29 <c_wraith> lalalala: is the example for the same version as you're running?
15:47:40 <jle`> Prutheus: just ask your question :)
15:47:44 <lalalala> c_wraith: i used cabal so i haven't checked the version
15:48:17 <c_wraith> lalalala: haskell libraries tend to change.  Best to be sure your version matches the version used in samples
15:48:33 <lalalala> c_wraith: how do I check that?
15:49:08 <Tuplanolla> Is there a more concise way to say `void . sequenceA . over _Just f`?
15:49:49 <c_wraith> Tuplanolla: at least use sequenceA_ ?
15:49:59 <jle`> :t \f -> void . sequenceA . over _Just f
15:50:00 <Tuplanolla> Oh!
15:50:01 <lambdabot> Applicative f => (a1 -> f a) -> Maybe a1 -> f ()
15:50:10 <Tuplanolla> The idea was to only perform an effect with the contents of `Just`.
15:50:12 <jle`> Tuplanolla: sounds like mapM_ ?
15:50:20 <jle`> :t mapM_
15:50:21 <lambdabot> (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
15:50:25 <lalalala> what does this do "{-# LANGUAGE OverloadedStrings #-}" ?
15:50:33 <jle`> mapM_ :: (a -> m b) -> Just a -> m ()
15:50:39 <lalalala> or it's just a comment huh
15:50:50 <Tuplanolla> Thanks. I knew I was overthinking it.
15:50:52 <c_wraith> lalalala: no, it's a pragma that enables a language extension
15:50:57 <jle`> Tuplanolla: fwiw this is one of the most common usages of mapM_
15:51:03 <lalalala> c_wraith: oh i need it?
15:51:08 <c_wraith> lalalala: That particular extension makes string literals polymorphic the way numeric literals are
15:51:21 <lalalala> c_wraith: i didn't use that from the example
15:51:38 <c_wraith> lalalala: does your code have no string literals?
15:52:10 <lalalala> c_wraith: i haven't used that before, im quite new and it worked without
15:52:32 <c_wraith> lalalala: turns out I don't know nearly enough about Scotty to figure out how ActionM and ScottyM are related.
15:53:00 <lalalala> c_wraith: thanks tho
15:53:04 <jle`> lalalala: it's useful for when you need to use functions that expect a Text, and you want to use one from a string literal like "hello"
15:53:15 <jle`> lalalala: "hello" is a String so the function wouldn't be happy
15:53:38 <jle`> but OverloadedStrings will automatically parse the string literal as a Text so you can give it directly to the function
15:53:53 <lalalala> jle`: this is all I've done so far: https://gist.github.com/freddedotme/01c729071cc15a5224b77ffd3e9fa773
15:54:20 <jle`> i guess this means that the 'html' function is happy accepting a String as an input
15:54:29 <jle`> so using a string literal there is fine w/o overloaded strings
15:54:44 <jle`> btw i'm sure you know this, but mconcat [x] = x
15:54:59 <lalalala> jle`: the thing is that is from the example on their github
15:55:03 <lalalala> it is*
15:56:18 <lalalala> i think i've realized what i did wrong
15:56:59 <lalalala> it works, I had to add the "get "/" $ do" before as well, i forgot that step.
16:04:10 <mniip> we call a category P-enriched if it's accompained with a C^op x C -> P hom-functor?
16:19:26 <Zemyla> So question. Assume I have a newtype ConstN n a = ConstN { getConstN :: n } such that instance Num n => Applicative (ConstN n) where { pure = const (ConstN 1); ConstN nf <*> ConstN na = ConstN $ nf * na }
16:19:58 <Zemyla> I want to have an Alternative instance with empty = 0 and (<|>) = (+).
16:21:44 <Zemyla> However, I'm wondering if I'll need to require a Fractional instance for it, though, because the solution to many n = n <*> many n <|> pure (:) is m = n * m + 1, which is m = -1 / (n - 1).
16:21:48 <Zemyla> And similarly for some n.
16:23:30 <monochrom> That is an interesting instance.
16:23:58 <monochrom> It is OK to stay Num and leave many and some as bottoms.
16:39:59 <jle`> many and some are bottoms for almost every instance of Alternative anyway
16:43:28 <EvanR> "if the termination status of a program is neither provable or disprovable in standard set theory, then the program must not terminate. if it did, the program itself stands as proof of termination, contradicting the assumption that it cant be proved either way"
16:43:49 <EvanR> "if you dont believe the program stands as proof of termination, just run it until it stops, which is guaranteed by assumption"
16:44:41 <EvanR> HOWEVER the assumption that it stops is a hypothetical, and i read that computing under binders assumption a contradiction is a common source of freeze ups if the implementation isnt careful
16:45:12 <dolio> Huh?
16:45:36 <EvanR> if hypothetically the program does halt, it stands as a proof of termination, just run it and see
16:45:56 <EvanR> since this is supposed to get a contradiction, that doesnt work!
16:47:20 <dolio> No.
16:47:32 <dolio> The execution trace would be a proof of termination, maybe.
16:47:48 <ezyang> One has to be careful about the modality of these types of statements 
16:49:49 <dolio> Unless the program is written in some system where all programs terminate. Then I'd accept it as a proof of termination.
16:51:47 <EvanR> and if you are evaluating under a binder that introduces a false hypothesis aiming for a contradiction, i can see that blowing up in your face
16:53:28 <dolio> Yes, you have to be careful. There are systems where normalizing in a consistent context must terminate, but may fail to terminate in an inconsistent context.
16:54:05 <Prutheus> jaspe/quit
16:55:10 <EvanR> ok, marking that off my list of assertions which dont seem completely convincing
17:15:16 <maksim__> i'm trying debug a program and for the life of me i can't figure out where this exception is coming from
17:15:19 <maksim__>  solr: createProcess: runInteractiveProcess: exec: does not exist (No such file or directory)
17:15:47 <maksim__> i've tried so many different things but i'm kind of at my wit's end
17:16:19 <maksim__> the symbol runInteractiveProcess doesn't appear in my codebase
17:16:24 <maksim__> but createProcess does
17:16:54 <maksim__> some advice
17:19:14 <maksim__> it's saying solr doesn't exist
17:21:38 <hpc> what happens if you run "which solr"?
17:21:50 <maksim__> i don't have solr
17:21:57 <maksim__> i'm trying to get this thing to talk to solr over http
17:22:33 <hpc> ah
17:22:45 <hpc> it looks like what your code may actually be doing is attempting to launch solr itself
17:22:58 <maksim__> can you show me where exactly that happens
17:22:59 <maksim__> http://pastebin.com/McfAZ5hn
17:23:59 <maksim__> this is the definition of ?$>
17:24:00 <maksim__> http://pastebin.com/RsVtmXgp
17:24:30 <maksim__> which i don't quite understand
17:24:43 <hpc> that whole thing is just running solr
17:24:58 <hpc> if you want to talk to it over http, you need an http library or something
17:25:08 <maksim__> yes i understand that much but i want it to fail gracefully
17:25:13 <maksim__> instead of throwing an exception
17:25:39 <maksim__> where does the actual call to run happen?
17:25:50 <hpc> createProcess
17:26:10 <hpc> cr defines what process to run, then createProcess does the thing
17:26:26 <maksim__> yes
17:27:08 <maksim__> i think this line is supposed to being the graceful fail
17:27:10 <maksim__>  p <- fromMaybe fg (conf C.! "run") ?$> Proc.createProcess cr
17:27:25 <maksim__> `conf C.! "run"` just gets the run key from conf
17:27:32 <maksim__> *run value
17:28:15 <hpc> sort of
17:28:33 <hpc> it tests a boolean value and decides if it should do something or produce an "empty" value
17:28:49 <hpc> since you want to handle an exception, the way to do that is to catch the exception
17:29:20 <maksim__> what is it here?
17:29:21 <hpc> which i believe there is something that'll translate exceptions to Either somewhere in base
17:29:25 <maksim__> the operator ?$> ?
17:29:30 <hpc> yeah
17:30:17 <maksim__> what does the `pure` keyword mean?
17:30:42 <benzrf> maksim__: it's not a keyword - just a normal function. it's a method in the Applicative class
17:30:59 <maksim__> so map pure over the functor f
17:31:00 <maksim__> right?
17:33:05 <hpc> there's actually two different uses of pure there
17:33:11 <hpc> the first one is for m, the second is for f
17:37:00 <maksim__> well okay i figured out how to make it not exception
17:37:36 <maksim__> by putting run = "false" in the config
18:33:46 <marrenarre> Hi. I'm having a weird problem with GHC. I modified my Haskell file, but runhaskell seems to be running the old code, somehow. It shows me old code when reporting type errors.
18:36:31 <Cale> marrenarre: That's odd
18:37:16 <kadoban> marrenarre: Are you sure you're in the correct directory and editing the correct file? And changes are actually being saved?
18:37:32 <Cale> marrenarre: Are you sure? Maybe make sure that there aren't .o or .hi files hanging around, but usually those will be determined to be out of date if there are more recent changes to the file.
18:38:51 <marrenarre> Cale: There are no such files. Seems to me they are not generated when using the interpreter.
18:40:23 <marrenarre> kadoban: I was just going to show you an example, but it works now. It seems to happen every time I change something, though.
18:40:46 <marrenarre> And then GHC "catches up" after some time.
18:44:38 <ReinH> How are you invoking runhaskell?
18:45:25 <pikajude> also which editor
18:46:35 <Cale> marrenarre: The only reason I ask is that it will load the compiled code if present -- usually it's smart about not loading it when it's out of date though.
18:47:58 <Cale> marrenarre: But generally, it can't load code which doesn't exist because it's been replaced on the disk. So if it's somehow loading stuff which is out of date, then make sure your editor is saving to the correct location.
18:52:38 <marrenarre> ReinH: Interactively in bash.
18:52:54 <ReinH> What did you type?
18:52:55 <marrenarre> pikajude: Vim in urxvt.
18:53:12 <marrenarre> ReinH: clear; runhaskell parser.hs 
18:53:45 <ReinH> is this something you can reproduce consistently?
18:54:03 <marrenarre> There is also a compiled file parser-hs, but that can't be it since it's more outdated than the things GHC tell me anyway, and the current code in parser.hs gives me type errors.
18:56:36 <marrenarre> ReinH: Well I'm not noticing the problem anymore right now.
19:04:24 <ReinH> Glad I could help ;)
19:10:05 <marrenarre> Haha.
19:38:30 <qmm> "Implement Functor instances for Either e and ((->) e)."
19:38:52 <qmm> i'm confused by this since it is Either a b, not Either e
19:39:14 <ezyang> Functor is on * -> * kinded thing 
19:39:19 <qmm> i'm guessing it's something like ((,) e)
19:39:20 <ezyang> Either a b :: *; but Either a :: * -> * 
19:39:32 <qmm> okay
19:39:51 <qmm> thanks ezyang, i'll try it out
19:49:52 <qmm> :info (->)
19:50:05 <qmm> data (->) t 1    -- Defined in 'GHC.Prim'
19:50:23 <qmm> i don't see it defined at https://hackage.haskell.org/package/ghc-prim-0.4.0.0/candidate/docs/src/GHC-Prim.html
19:51:27 <geekosaur> things sometimes move around; make sure you are checking the version that your ghci is using. (I would be surprised if it is a candidate release)
19:52:21 <geekosaur> in particular, I think changes related to the new Typeable coming in 8.2.1 caused it to move (possibly into base?)
19:52:31 <qmm> ah, ghc 8.0.1 instead of 8.0.2
19:53:11 <geekosaur> hm, actually
19:54:14 <geekosaur> I think it is not there because it is special. if it can be described (not defined!) in Haskell then it'll show up there. some things are so primitive they are wired in and can't have a stub in GHC.Prim, and haddock can't document them as a result
19:55:57 <geekosaur> right, not in the haddock for 8.0.1 either, it's probably too primitive to have a Haskell stub for haddock to hang docs off of
19:56:56 <qmm> geekosaur: there's no definition of (->) then?
19:57:15 <geekosaur> not in Haskell syntax
19:57:23 <geekosaur> there are no actual definitions in GHC.Prim
19:57:55 <geekosaur> just fake ones that all resolve to "let x = x in x"; GHC.Prim is documentation stubs for things that are built in to the compiler and/or runtime
19:58:20 <geekosaur> as for (->), you can't even describe it properly using Haskell syntax, so not even a documentation stub
19:59:12 <geekosaur> (part of the problem is (->) is too polymorphic for its type to be described properly; what ghci shows is a slight lie, although not as much of one as it was in 6.x and 7.x)
19:59:43 <geekosaur> (and the type level one's kind similarly can't be described, at least pre-8.0 and possibly still not)
19:59:43 <qmm> it is function application, right?
19:59:54 <geekosaur> no
20:00:08 <geekosaur> ($) is function application. (->) is function *definition*
20:00:21 <qmm> that makes sense
20:00:43 <qmm> i've only seen it in type signatures 
20:02:14 <qmm> i like to imagine this is you on the other of the keyboard when i say things like "it is funciton application, right" https://www.youtube.com/watch?v=e5Lx9bH0n1E
20:02:55 <qmm> thanks for your help!
20:03:14 <Cooler> can you only write deriving for data?
20:03:25 <Cooler> or can you derive for newtype?
20:03:58 <geekosaur> you can derive for newtype, but it requires an extension
20:04:14 <qmm> -XGeneralizedNewtypeDeriving
20:04:22 <geekosaur> and it works differently: newtype deriving exposes specific instances from the underlying type
20:04:54 <geekosaur> (for Show and Read it modifies them slightly, so it acts a little more like deriving for data)
20:07:14 <ReinH> (->) is special notation for function type, just like [a] is special notation for [] a and (a,b) is special notation for (,) a b
20:08:57 <ReinH> It's special syntax.
20:09:55 <lpaste_> maybefbi pasted “The result should be [True, True, False, False, False, True]” at http://lpaste.net/1650252320614645760
20:10:15 <maybefbi> can anyone help me with this ^
20:10:55 <maybefbi> i can't seem to update the state
20:11:00 <ReinH> maybefbi: don't use isNothing and fromJust, use pattern matching
20:11:15 <maybefbi> ok will do. but the bug is the state doesnt update
20:11:58 <ReinH> that just happens to work because || False is non-strict
20:12:09 <ReinH> er, (||) False
20:13:11 <maybefbi> uhm it doesnt work.  i mean it doesnt return the expected result
20:13:28 <maybefbi> the LogState is not updated
20:13:48 <ReinH> I mean work as in "doesn't cause a runtime error"
20:14:11 <maybefbi> ok. but im trying to get the expected result
20:14:51 <maybefbi> not avoid runtime errors which does not exist
20:15:59 <ReinH> Why are you using Map.update instead of Map.insert when you always insert?
20:16:25 <ReinH> maybe if this was written more simply, the issue would be easier to find
20:16:59 <maybefbi> if the key already exists and i chose to print into log, i need to update the time the log entry was last printed
20:17:03 <ReinH> Also, what result *do* you get?
20:17:10 <ReinH> insert overwrites
20:17:24 <ReinH> it's literally the same as what you're doing without the unnecessary complexity
20:17:30 <maybefbi> [True,True,True,True,True,True]
20:17:35 <maybefbi> is the result i get
20:17:43 <ReinH> (well, it doesn't overwrite in place, ofc, it returns a new map with that key changed)
20:20:59 <mckeankylej> Hey everyone I have a piece of code that uses scoped type variables, but I dont like that as it pollutes the haddocks with foralls. Is there a better way of doing the following code: http://lpaste.net/352700
20:22:15 <maybefbi> ReinH, hmm using insert seems to make a change. seems like update only updates if the key is already in the map
20:23:28 <ReinH> Ah, good catch
20:23:36 <ReinH> So it's never adding your values
20:23:47 <ReinH> because you start with an empty map
20:24:39 <maybefbi> ReinH, yeah
20:25:09 <Cale> mckeankylej: I generally wouldn't worry about it.
20:26:28 <Cale> There's probably some much uglier thing you can do by introducing a bunch of dead code...
20:27:22 <Cale> But this is pretty much exactly the sort of situation which ScopedTypeVariables exists for
20:27:52 <ReinH> Instead of worrying about the foralls, we suggest not worrying about the foralls.
20:28:48 <ReinH> maybefbi: so I was right about switching to insert, but only by accident.
20:29:39 <maybefbi> ReinH, only partially. the last element of the result array is still wrong. im inspecting why
20:31:04 <mckeankylej> ReinH: would you want a patch to haddocks to not pretty print top level foralls?
20:32:48 <maybefbi> ReinH, seems like that last issue was because test case says to print at the 11th second even if there was a print at the 1st second
20:34:15 <Cale> mckeankylej: You may be able to get away with using the C preprocessor to define the function differently while building the haddocks
20:34:38 <Cale> But I'm not sure it's worth the trouble, tbh. Explicit foralls are so common that they don't bother me.
20:36:12 <mckeankylej> Cale: ho boy that feels like bringing a nuke to a knife fight, and it would make the code much harder to read. Thanks though!
21:03:15 <CoolerZ> can you give a type signature in a instance declaration? http://lpaste.net/352701
21:03:24 <CoolerZ> http://lpaste.net/352701
21:04:15 <CoolerZ> i get an error telling me to use a language extension InstanceSigs
21:04:27 <kadoban> It requires that extension, yes.
21:09:38 <CoolerZ> kadoban, is there a way around that
21:10:28 <Cale> CoolerZ: Yes, not giving the type signature there
21:10:41 <Cale> It should be uniquely determined by the class definition
21:12:02 <CoolerZ> Cale, uh well the type signature is required to use fmap
21:12:19 <CoolerZ> to specify x is a Functor
21:13:35 <CoolerZ> trying to do this exercise to write a functor instance
21:13:36 <CoolerZ> 5. Do you need something extra to make the instance work?
21:13:37 <CoolerZ> data LiftItOut f a =
21:13:37 <CoolerZ> LiftItOut (f a)
21:18:18 <CoolerZ> anyone?
21:18:20 <MarcelineVQ> you can place constraints ( => ) on instances, check back on your chapter exercises for chapter 15 for a reminder on where you've done that before
21:19:46 <CoolerZ> oh right
21:20:00 <Cale> Yeah, it should be  instance Functor x => Functor (LiftItOut x) where ...
21:20:16 <Cale> (or better yet, use f instead of x ;)
21:53:21 <marrenarre> Hey. I'm a beginner but maybe I can ask here since no response in the beginner channel and I heard this channel is beginner friendly sometimes too, and it seems kinda quiet now anyway.
21:54:30 <marrenarre> > liftA2 (:) (Right 3) (Left [5])
21:54:33 <lambdabot>  Left [5]
21:54:43 <marrenarre> > liftA2 (:) (Left 3) (Right [5])
21:54:46 <lambdabot>  Left 3
21:54:49 <marrenarre> How can it be that the contained value is only a list in the first case?
21:55:36 <c_wraith> the Applicative instance for Either considers Left values to be failures
21:55:47 <c_wraith> And it short-circuits any further evaluation if it finds one
21:56:19 <c_wraith> If it encounters any Left, it just returns that left
21:56:53 <c_wraith> > liftA2 (:) (Left 5) (Right "Hello, world")
21:56:55 <lambdabot>  Left 5
21:57:15 <c_wraith> The only time the lifted function would actually be applied is if both arguments are Right
21:59:56 <dramforever_> marrenarre: You can see why by subsituting the definitions in
22:00:04 <dramforever_> That's how Haskell works basically
22:06:32 <marrenarre> Oh right.
22:07:32 <marrenarre> > liftA2 (:) (Left 3 :: Either Integer Integer) (Left [5])
22:07:35 <lambdabot>  error:
22:07:35 <lambdabot>      • Couldn't match type ‘[Integer]’ with ‘Integer’
22:07:35 <lambdabot>        Expected type: Either Integer [Integer]
22:07:59 <marrenarre> > liftA2 (:) (Left 3) (Left [5])
22:08:02 <lambdabot>  error:
22:08:02 <lambdabot>      • Ambiguous type variable ‘t0’ arising from a use of ‘show_M306146079492...
22:08:02 <lambdabot>        prevents the constraint ‘(Show t0)’ from being solved.
22:09:14 <marrenarre> I meant I kinda know how liftA2 works but it seems like sometimes when two expressions should have the same type one of them gives a list and the other one doesn't.
22:09:17 <marrenarre> I mean*
22:09:44 <marrenarre> And I'm thinking "How can they have different types?".
22:13:18 <marrenarre> I think I get it though. They can have different types because the Left and Right literals only imply one type argument each to the Either type constructor. That's why it doesn't work when I have two Left value constructors that I give values of different types.
22:15:30 <marrenarre> Hmm that makes sense and seems to work for me in GHCi. I think I was just messing something up before and that's why I got confused. I realise the two I wrote before that didn't error can have different types.
22:16:27 <marrenarre> (Anyone wanna agree/disagree?)
22:18:55 <c_wraith> marrenarre: that sounds right
22:19:06 <ClaudiusMaximus> marrenarre: the   Applicative   instance is for   Either e :: * -> *   with e fixed across the whole computation, only the a in  Either e a :: *  can change
22:24:55 <MarcelineVQ> marrenarre: the type of liftA2 is  liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c   using ClaudiusMaximus's example above let's assign Int to `e`
22:25:14 <MarcelineVQ> substituting (Either Int) for f would give us a liftA2 that looks like   liftA2  :: (a -> b -> c) -> Either Int a -> Either Int b -> Either Int c    which may make it clearer as to why  liftA2 (:) (Left 3) (Left [5]) was an error
22:33:49 <abhiroop> Has anyone used ekmett's trifecta library
22:34:07 <abhiroop> when i try to do cabal install trifecta-1.5.2
22:34:33 <abhiroop> I get the following error in blaze-markup- one of its dependencies
22:34:34 <abhiroop> There are files missing in the ‘blaze-markup-0.7.1.0@blaze_IswqgMcsaFk6TfFYttEfHj’ package,
22:34:45 <abhiroop> Any idea how I go about fixing?
22:36:41 <marrenarre> MarcelineVQ: Yeah, I mean I knew that shouldn't be right, it's just I forgot that the ones that did work should work. In my head I imagined that the compiler would want them to have the same type (since I was thinking of them simultaneously) but obviously that's not the case.
22:37:34 <marrenarre> I mean `liftA2 (:) (Right 3) (Left [5])` and  `liftA2 (:) (Left 3) (Right [5])`.
22:38:20 <marrenarre> (So I was confused as to why both of those work, but I get it now.)
22:38:55 <marrenarre> c_wraith, ClaudiusMaximus, MarcelineVQ: Thanks!!
22:45:23 <shinX> $/names #haskell
23:04:11 <finite_projectiv> Here's a fun one liner in haskell
23:04:14 <finite_projectiv> let f1 x = (x,x); f2 = f1 . f1; f3 = f2 . f2; f4 = f3 . f3; f5 = f4 . f4; f6 = f5 . f5 in f6 
23:04:18 <finite_projectiv> Run this in a vm btw
23:04:25 <finite_projectiv> Or be ready to kill the process
23:10:54 <Koterpillar> ghc: out of memory
23:11:22 <Koterpillar> (alternate way: ulimit -Sv 1000000)
23:13:22 <raynold> ahh it's a wonderful day
23:13:28 <MarcelineVQ> poor little typechecker :(
23:33:19 <ongy> why does ghc take up so much memory with that one-liner
23:34:14 <glguy> :t let f1 x = (x,x) in f1 -- ; f2 = f1 . f1
23:34:16 <lambdabot> t -> (t, t)
23:34:24 <glguy> :t let f1 x = (x,x); f2 = f1 . f1 in f2
23:34:26 <lambdabot> t -> ((t, t), (t, t))
23:34:37 <glguy> :t let f1 x = (x,x); f2 = f1 . f1; f3 = f2 . f2 in f3
23:34:39 <lambdabot> t -> ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))
23:35:19 <glguy> :t let f1 x = (x,x); f2 = f1 . f1; f3 = f2 . f2; f4 = f3 . f3 in f4
23:35:20 <lambdabot> t -> ((((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t,
23:35:21 <lambdabot>  t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t,
23:35:21 <lambdabot> t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t,
23:35:21 <lambdabot> t))), (((t, t), (t, t)), ((t, t), (t, t))))))), (((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t,
23:35:21 <lambdabot>  t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t), (t, t)), ((t, t),
23:35:22 <lambdabot> (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t,
23:35:24 <lambdabot>  t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))))))
23:35:36 <shinX> =_=
23:35:41 <glguy> I didn't expect lambdabot to offer so much output
23:35:50 <MP2E> hah :P
23:35:54 <glguy> In any case, these types grow very quickly
23:36:15 <ongy> they do. That's more than 2^n, wow
23:36:45 <ongy> and good to know that lambdabot doesn't limit the type output
23:41:53 <MarcelineVQ> ongy: related http://spacemanaki.com/blog/2014/08/04/Just-LOOK-at-the-humongous-type/
23:42:32 <glguy> > iterate (2^) 1
23:42:35 <lambdabot>  [1,2,4,16,65536,200352993040684646497907235156025575044782547556975141926501...
23:44:42 <ongy> that 6th number looks fine
23:45:05 <kadoban> That sure is a number
23:48:46 <lispy> biggest type is best type
23:49:09 <dynamical_system> Did yall crash lambdabot with it?
23:49:36 <glguy> nope
23:50:18 <dynamical_system> do itttt
23:51:11 <MarcelineVQ> > let x = x in x -- lambdabot has ways around that :>
23:51:17 <lambdabot>  mueval-core: Time limit exceeded
23:52:02 <dynamical_system> :t let f1 x = (x,x); f2 = f1 . f1; f3 = f2 . f2; f4 = f3 . f3; f5 = f4 . f4; f6 = f5 . f5 in f6
23:52:34 <dynamical_system> whoopsies
23:55:40 <lyxia> > let areYouDead = "No" in areYouDead
23:55:52 <lambdabot>  mueval: ExitFailure 1
23:56:09 <dynamical_system> whoopsies
23:57:20 <dynamical_system> > print "Hi!"
23:57:34 <kadoban> I would imagine it has trouble even type checking that thing, if the pattern holds. lambdabot is a champ though, it comes back.
23:58:16 <dynamical_system> Yeah, I think it's something along the lines of 2^(2^6) operations
23:58:25 <MarcelineVQ> I guess protections are just in place for expressions :>
23:58:33 <MarcelineVQ> she's prety clammed up atm
23:58:37 <dynamical_system> Which is about 2 * 10^19
23:58:55 <dynamical_system> Yeah, the typechecker isn't done in the same way I think
23:58:58 <dynamical_system> Compile vs run time
