00:09:24 <flxw> oh, I see. This would be good enough for must cases.
00:09:37 <flxw> most
00:45:04 <Nerterologist> Slow night, hm?
00:47:34 <Unhammer> hm, io-streams has System.IO.Streams.Attoparsec, but it's only for Parser ByteString – is there some converter somewhere to make it usable with Parser Text? (do I have to write a parser that runs decodeUtf8?)
00:51:02 <Unhammer> oh https://github.com/snapframework/io-streams/issues/35 
01:23:35 <bollu> I'm having an issue submitting a comment to Trac. I'm not able to comment on ticket 12636. I've submitted an error patch: https://ghc.haskell.org/trac/ghc/ticket/13273#ticket
01:33:07 <dhalgren_> bollu: seems bgamari is/was doing some trac maintenance and some problems happened http://mail.haskell.org/pipermail/ghc-devs/2017-February/013768.html
01:37:29 <bollu> i see, thank you :)
01:38:30 <bollu> dhalgren_: what mailing list is that?
01:38:58 <dhalgren_> bollu: ghc-devs
01:39:14 <dhalgren_> bollu: http://www.haskell.org/mailman/listinfo/ghc-devs
01:39:19 <bollu> oh, thanks! I shall subscribe
02:52:07 <volhovm> Is there any way in haskell to use read/write in unix-way, without those System.IO handles that take RWlocks on opening?
02:52:40 <volhovm> should be crossplatform
02:55:09 <volhovm>  What i would like to do is append to the file in one thread while reading from beginning in another.
02:58:36 <bitonic> volhovm: you can do it by creating an FFI signature for recv/send and just using `Fd`s
02:58:48 <bitonic> Then you can also use epoll and similar facilities manually
02:58:53 <bitonic> There is no nice pre-packaged library though
02:59:38 <volhovm> Pretty sad, i must support it under windows but have no idea how do they use read/write.
03:00:02 <volhovm> Maybe there's a way to emulate this behaviour using low-level ghc bindings or something?
03:00:08 <bitonic> volhovm: ah, no idea about windows. I don't even know if windows has apis that match posix in that regard.
03:01:25 <bitonic> volhovm: this is an example of doing what I described from warp <https://github.com/yesodweb/wai/blob/master/warp/Network/Wai/Handler/Warp/Recv.hs#L132>
03:01:25 <sternmull> volhovm: On windows you do have to call CreateFile, ReadFile and WriteFile via FFI
03:01:58 <volhovm> How do people usually implement sending logs while program is working?
03:02:26 <volhovm> That's the exact usecase -- i must send last log files over network if i see that something strange has happened, without stopping logger
03:03:42 <sternmull> volhovm: you could write your log output to the log and in addition to a network stream. Then there would be no need to read the log while it is opened for appending.
03:05:55 <volhovm> sternmull: not an option when i must send _previous_ logs in a "crash-like report" style. But still, duplicating last N Mb of logs in memory must be a good idea.
03:22:14 <Phyx-> if it's just a shared lock on the file, why can't you read it while something else is writing?
03:39:45 <flxw> Right after I learnt about hindent here this morning (afternoon/night), I installed it. :) A question about the minor mode in emacs: M-q works great for single lines, but I can't get it to work on whole regions. I mark the start of the region with C-space and then movethe point to where I want it to end. Pressing M-q just formats this last line I am on. What am I doing wrong?
04:06:23 <tstrrt> can someone help me with the pattern matching here? http://lpaste.net/352427 i wanted to parse it into lists separated by "/" and not return only the first elem, but continue parsing?
04:06:57 <tstrrt> how to define the xs correctly? to include the rest of the list?
04:08:23 <sternmull> in your code xs is the second element of the list, not the rest of the list
04:08:56 <sternmull> the left side of a : is always an element of the list
04:10:49 <tstrrt> sternmull oh ok, thanks. i tried it with the map function but the data types arent working out http://lpaste.net/352427 do i need to include one more function in between to match the data types?
04:11:08 <tstrrt> as i get     Couldn't match type ‘Char’ with ‘[Char]’     Expected type: [[String]]       Actual type: [String]     In the expression: parseBoard1 (parseFEN s)     In an equation for ‘parseBoard’:         parseBoard s = parseBoard1 (parseFEN s)
04:12:00 <sternmull> what do you want to do? Split one string at its "/" occurrences?
04:13:16 <tstrrt> sternmull split a string like "b,b,b,b/b,b,b/b,b,b,b/,,/w,w,w,w/w,w,w/w,w,w,w" into list of [String] so it would be [[b,b,b,b][b,b,b]..]
04:14:03 <tstrrt> so parseFEN gets a string like "b,b,b,b/b,b,b/b,b,b,b/,,/w,w,w,w/w,w,w/w,w,w,w w a3-c4" parses it into [string] seperated by " " and first one is the input of parseBoard
04:16:11 <tstrrt> sternmull is there a way to save it directly in the parseFEN function? something like first list = board , 2 = nextplayer and 3 = last move? and then call the different functions on each list within the parseFEN function?
04:17:04 <tstrrt> sternmull http://lpaste.net/352427 like this?
04:17:16 <sternmull> i think something like this does what you want to do: map (splitOn ",") $ splitOn "/" "a,a/b,b2,b3/c,c,c123"
04:17:16 <tstrrt> and then call parseBoard on board etc?
04:17:53 <sternmull> it means "split the string at /" and then for each element "split it at ,"
04:18:31 <tstrrt> sternmull yeah i thought of it, as eventually i want to parse each elem into a position on a board, so i can modify the parseBoard like this?
04:19:40 <tfc> hi there. how can i print a word8 as its numeric value, instead of as a character? I completely do not see how to "cast" between different numeric types
04:19:51 <dram_phone> :t fromIntegral
04:19:52 <cocreature> :t ord
04:19:53 <lambdabot> (Num b, Integral a) => a -> b
04:19:54 <lambdabot> Char -> Int
04:19:59 <dram_phone> :t realToFrac
04:20:02 <lambdabot> (Real a, Fractional b) => a -> b
04:20:02 <cocreature> oh Word8 not char
04:20:06 <dram_phone> And wait a sec
04:20:12 <dram_phone> > 2 :: Word8
04:20:16 <lambdabot>  2
04:20:19 <dram_phone> tfc: 
04:20:23 <tfc> ok, that works nevertheless.
04:20:29 <dram_phone> tfc: What do you mean?
04:20:30 <dram_phone> ah
04:20:33 <tfc> and if i have an int and want a word8 from it?
04:20:43 <dram_phone> :t fromIntegral
04:20:46 <lambdabot> (Num b, Integral a) => a -> b
04:21:55 <tfc> i am having quite a type hell here when dealing with ByteStrings and Integers, because sometimes the bytestrings are lazy, sometimes they are not and i am dealing with type problems here in 90% of my time.
04:24:24 <vaibhavsagar> is anyone else seeing a Trac error? https://ghc.haskell.org/trac/
04:24:40 <pavonia> tfc: How is lazy vs. strict related to Word8 vs. Char?
04:24:59 <dram_phone> :t Data.ByteString.Lazy.toStrict
04:25:01 <lambdabot> BSLC.ByteString -> BSC.ByteString
04:25:07 <dram_phone> :t Data.ByteString.Lazy.fromStrict
04:25:08 <lambdabot> BSC.ByteString -> BSLC.ByteString
04:25:29 <bollu> vaibhavsagar: yes, trac was updated today and there have been ussues 
04:25:31 <bollu> issues*
04:26:45 <dram_phone> pavonia: Perhaps because of unsigned char?
04:29:02 <dram_phone> toStrict says: Note that this is an expensive operation that forces the whole lazy ByteString into memory and then copies all the data. If possible, try to avoid converting back and forth between strict and lazy bytestrings.
04:29:06 <dram_phone> hmm
04:33:08 <bollu> can I use lenses to create "first class" pattern matchers?
04:33:41 <bollu> Like, can I have a function that takes an object, and a "pattern" of some shape with holes in it, and returns Maybe [Value] or something if the pattern matches?
04:33:52 <bollu> LLVM does this to pattern match on ASTs
04:33:56 <bollu> and it's quite elegant
04:36:24 <cocreature> bollu: you are probably looking for “Prisms”
04:36:36 <cocreature> bollu: btw could you point me to where llvm uses this? I don’t think I’ve seen this there
04:37:06 <osa1> bollu: you can write that function yourself
04:37:27 <osa1> oh you wanted to use lenses
04:37:29 <osa1> not sure about that part
04:39:03 <bollu> cocreature: oh, I was mistaken, it's a clang thing: ASTMatcher
04:39:10 <bollu> cocreature: still, the idea is nice
04:39:15 <cocreature> bollu: ah that explains why I don’t know about it :)
04:39:16 <bollu> cocreature: so, prims will let me write such code?
04:41:28 <cocreature> > preview (_2 . _Just) (1, Nothing)
04:41:32 <lambdabot>  Nothing
04:41:38 <cocreature> > preview (_2 . _Just) (1, Just 2)
04:41:41 <lambdabot>  Just 2
04:41:46 <cocreature> bollu: is that what you’re looking for?
04:42:01 <bollu> cocreature: yes, very nice.
04:42:10 <bollu> cocreature: I'm assuming this would work over an ADT as well?
04:42:24 <cocreature> bollu: sure, Maybe is already in adt :)
04:42:37 <cocreature> bollu: you just need to write the corresponding prisms/generate them
04:42:45 <bollu> cocreature: I wanted to use it for this: http://github.com/bollu/timi. I pattern match a lot over the stack and the heap. It would be nice to have the ability to do this in Rust
04:42:58 <bollu> cocreature: but I don't think Rust's type system is ready for things like this yet?
04:43:07 <cocreature> I have no idea
04:43:13 <cocreature> I know very little about rust
04:43:13 <bollu> cocreature: OK. thanks :)
04:43:32 <bollu> cocreature: Is there a way to have a shape be.. "monadic" for the lack of a better word?
04:43:43 <bollu> cocreature: like, can the fact that one part of the shape be matched influence the later matches?
04:44:14 <cocreature> bollu: do you have a more concrete example?
04:45:05 <tstrrt> is it possible to define this function somehow more "elegantly"? by using a recursion? http://lpaste.net/352427 
04:45:15 <bollu> cocreature: yes. Imagine I have a Stack and a Heap. Stack contains addreses to heap objects. I need a way to say, I need the first stack address to be of the shape FnApplication {fn_addr, arg_addr}, and I need Heap[arg_addr] to be of the shape PrimitiveNum
04:45:28 <bollu> so, like, my restriction of the shape of the heap depends on the value of the stack address
04:46:17 <bollu> positiontoStringRow (Position x _) = show (7 - x) ?
04:46:53 <bollu> positiontoStringColumn (Position _ c) = names !! c where names = ['a'..
04:46:54 <dram_phone> tstrrt: I would try this:
04:46:58 <cocreature> bollu: hm I think that’s going to be hard
04:46:58 <dram_phone> :t lookup
04:47:00 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
04:47:06 <cocreature> bollu: you might want to ask in #haskell-lens
04:47:12 <bollu> cocreature: OK, thank you
04:47:18 <bollu> cocreature: this is more of an intellectual exercise
04:48:51 <dram_phone> I thinl that if we consider those strings as 'names' of cols and rows, the table approach is more clear
04:48:55 <dram_phone> *think
04:51:25 <sternmull> i am reading https://wiki.haskell.org/Implement_a_chat_server and do not understand fix and liftM yet. Are they useful or are they replaced by different things in modern haskell code (don't know how old that tutorial is)?
04:53:12 <tstrrt> bollu thanks! i could also use something like this for the columns? ((ord c) - (ord 'a') + 1) or wouldnt match with the argument?
04:54:34 <bollu> positiontoStringColumn (Position _ i) = return (chr (i + ord 'a')) # find correct character, return :: a -> [a]. (convert character to string)
04:55:12 <bollu> tstrrt: tell me if that satisfies your need
04:56:15 <bollu> tstrrt: you may have to import Data.Char
04:56:38 <tstrrt> bollu :D it does, indeed, thank you! yes thats the only module i can use in the assignment 
04:56:53 <bollu> tstrrt: wait, this was homework? >_<
04:57:18 <bollu> god damn, you should have told me that first :P I would have given you hints then, not the answer outright
04:58:44 <tstrrt> bollu well, there is still soo much parsing to do! thus no worries :))
04:59:01 <bollu> tstrrt: ok :)
05:19:37 <reactormonk> How would I execute a command that doesn't have a Show instance?
05:20:57 <cocreature> reactormonk: what kind of command are you talking about here? execution doesn’t require a show instance in general
05:21:16 <reactormonk> cocreature, got some code without IO with some trace statements in there.
05:21:43 <cocreature> reactormonk: so you want to traceShow something that doesn’t have Show instance?
05:22:07 <reactormonk> cocreature, no, I have some traceShow in code that I wanna run from ghci, but said code doesn't have a Show instance, so ghci complains.
05:23:26 <vaibhavsagar> <code> `seq` ()?
05:23:31 <cocreature> yep
05:23:38 <cocreature> or evaluate <code>
05:25:55 <reactormonk> cocreature, not in scope
05:26:15 <reactormonk> vaibhavsagar, works, thanks
05:26:21 <cocreature> reactormonk: it’s in Control.Exception
05:38:20 <sternmull> Could someone explain the purpose of "fix" here https://wiki.haskell.org/Implement_a_chat_server It does not tell why it is used and i don't see a reason to use it.
05:39:48 * hexagoxel .oO couldn't -Wall warn me about -Wall overriding a previous -fno-warn-foo ..
05:40:09 <kgadek> sternmull: you're asking about what does? basically, it allows you to write recursive code. This includes both infinite loops (like in this case) and finite loops (google for "fix factorial")
05:41:11 <sternmull> kgadek: I think i roughly understand what fix does. But i don't see why it is used in that example. It explicitly does a recursive call.
05:41:27 <kgadek> you can always "inline `fix`", i.e. always write recursion by yourself
05:41:45 <kgadek> well, I think it's a preference
05:42:26 <kgadek> guys could've written a named lambda "worker" that calls itself, then just `forkIO worker` or sth. like that
05:42:42 <sternmull> the example does "fix $ \loop -> do ... loop". Isn't that senseless when fix does the implicit recursion?
05:42:49 <kgadek> here they've decided they'd rather use `fix` that gives the name to call recursively using `fix`
05:43:15 <kgadek> `loop` gets instantiated to code block itself
05:43:39 <kgadek> so `forkIO` calls first one that calls itself second time, that calls itself third time, ad infinitum
05:43:59 <kgadek> it's a trick
05:44:22 <sternmull> ah, i think that gets me in the right direction. Thanks!
05:44:24 <kgadek> imagine this as writing: `let worker = do … worker` instead
05:44:33 <kgadek> and using `forkIO worker`
05:45:00 <ocramz> Hi all
05:45:06 <kgadek> here lambda is used to name the block itself. Just a trick, nothing more
05:45:32 <bollu> kgadek: can we emulate recursiveDo with mFix?
05:45:48 <ocramz> does `Functor f => (a -> b) -> (t -> f a) -> (t -> f b)` have a name? I just found a use for it but don't know how to call it
05:46:35 <kgadek> I'm not confident in my understanding of mfix, but I think the answer is not (unless I misunderstood the question), since mfix calls the thing only once (!)
05:46:43 <bollu> I see!
05:46:55 <hexagoxel> sternmull: using `forever` would remove the need to give any name to the thing-being-looped.
05:46:55 <kgadek> and I've never used recursiveDo so…
05:47:09 <kgadek> hexagoxel: good point
05:47:27 <sternmull> hexagoxel: thanks
05:48:01 <hexagoxel> sternmull: but for anything where you actually pass something to the next iteration, `forever` becomes too weak.
05:48:08 <hexagoxel> or where you want to conditionally abort
05:49:19 <hexagoxel> i suppose for that reason the tutorial has used fix, even when their code so far would work with `forever`.
05:51:29 <kgadek> bollu: I was wrong apparently
05:51:32 <kgadek> https://wiki.haskell.org/MonadFix
05:51:42 <kgadek> recursiveDo is equivalent to using mfix
05:51:52 <kgadek> so it's the same stuff
05:52:30 <cocreature> the ghc docs have an example of how desuraging works https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=recursivedo#recursive-binding-groups
05:52:34 <hexagoxel> (one can also use MaybeT with forever to get the conditional-aborting power back - but that's yet another direction, design-wise.)
05:53:40 <Jinixt> ocramz: i don't know if it exists, but at least it's pretty simple to write yourself
05:56:19 <kgadek> ocramz: hmm, isn't it (<$>) ?
05:57:31 <Jinixt> :t (<$>)
05:57:34 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:57:34 <Jinixt> not quite
05:57:38 <ocramz> Jinixt kgadek : yes it's very simple to write: `\g f x -> g <$> f x`
05:58:14 <hexagoxel> (the real question of course is if -Wall should also warn about -Wall overriding -fno-warn-Wall-overriding-no-warn. heh)
05:59:05 <reactormonk> Is there an :up in ghci debugging?
05:59:21 <reactormonk> or rather, how can I let it continue until it leaves the current function?
05:59:54 <ocramz> yep it appears under a  number of names in the wild: http://hayoo.fh-wedel.de/?query=Functor%20f%20%3D%3E%20(a%20-%3E%20b)%20-%3E%20(t%20-%3E%20f%20a)%20-%3E%20t%20-%3E%20f%20b
06:00:26 <ocramz> a "post-composition"
06:00:37 <bollu> Control.Kleislify <- I bet that this is kmett's module
06:01:02 <bollu> oh wow it's not xD
06:01:16 <bollu> I just immediately assume that everything category theoretic was made by him :3
06:02:04 <kgadek> offtop: anyone working on GHC trac? (I have some minor issues with mailing list, wanted to ask before I try to tackle them)
06:03:12 <kgadek> cc bgamari ?
06:08:37 <unclechu> hey guys, can I somehow get process id from child process handler from this package: http://hackage.haskell.org/package/process-1.5.0.0/docs/System-Process.html
06:13:11 <cocreature> unclechu: you can import System.Process.Internals and pattern match on ProcessHandle https://hackage.haskell.org/package/process-1.5.0.0/docs/System-Process-Internals.html#t:ProcessHandle__
06:13:16 <cocreature> I don’t know of a less hacky way
06:16:29 <unclechu> cocreature: i think it might work for me, thanks
06:17:58 <cocreature> unclechu: you could also consider using https://hackage.haskell.org/package/unix-2.7.2.1/docs/System-Posix-Process.html (or the corresponding windows versions) if you ignore cross-platform support
06:18:40 <kubbe> Whats up cocreature
06:19:02 <cocreature> kubbe: busy studying for exams :)
06:19:31 <kubbe> Ohh, cool! Me 2 :)
06:25:25 <kubbe> is there a channel for haskell beginners?
06:25:41 <bollu> #haskell-beginners I think
06:25:56 <kubbe> alright, thanks! Imma try
06:29:25 <hpc> or here
06:44:58 <kubbe> Yeah, that channel wasnt very active. So some of you know me from before, but anyways. I have trouble creating my huffmantree. The function that counts all the characters are done and is working, and my PriorityQueue is working
06:46:43 <kubbe> But to create my huffmantree... I know the algorithm: From the table that holds the, lets call them tuples, with the character and the INT (<- the number of times it occurs in the input string), I need to take out them and create leafs and put them in the priorityqueue
06:47:05 <kubbe> and then create trees with the leafs and the node that is the sum of the 2 INTS.
06:47:51 <kubbe> But how in the name of God do I actually create this sort of tree. Or like: what should I write in code to make it work.. Its hard to code in Haskell, imo, after have coding in JS or C++
07:11:34 <kakashiAL> I am spending time with haskell to become a better programmer :)
07:11:47 <kakashiAL> now I have a question: in javascript you can chain methods, something like this:
07:11:55 <kakashiAL> foo.map().map().map()
07:12:13 <reactormonk> https://hackage.haskell.org/package/flow
07:12:18 <kakashiAL> this is the way how compostion in OOP languages is done (more or less)
07:12:25 <Welkin> kakashiAL: that is the same thing as nesting the functions
07:12:46 <Welkin> a.f().g().h() is the same as h(g(f(a)))
07:12:49 <reactormonk> kakashiAL, you can compose on the function level with . - flow just gives you a bit nicer operators
07:13:11 <Welkin> function composition is much nicer though
07:13:15 <kakashiAL> yes, but composition with pure functions  like Welkin mentioned
07:13:19 <kakashiAL> but its harder to read
07:13:20 <Welkin> so in haskell you can do this to get the same effect
07:13:24 <kakashiAL> harder to reason about
07:13:27 <Welkin> h . g . f $ a
07:13:45 <Welkin> it's not harder to read at all
07:13:52 <kakashiAL> f(g(w(z(y(u(x))))))
07:13:56 <Welkin> it's just how function composition works in math
07:13:59 <Welkin> oh, yes
07:14:05 <Welkin> we don't do it that way in haskell
07:14:07 <Welkin> we use composition
07:14:17 <Welkin> the ends up being the same after a transformation
07:14:38 <kakashiAL> Welkin: let me give you a simple javascript example, I would like to see the haskell way:
07:14:46 <Welkin> I just showed you one
07:14:47 <Welkin> lol
07:14:59 <Welkin> and you can still compose functions in javascript using a library like ramda
07:15:09 <Welkin> it just doesn't look as nice as haskell's (.)
07:15:36 <kgadek> kubbe: what is your actual problem? creating a tree that represents the huffman tree?
07:16:00 <kakashiAL> Welkin: how would you write this in haskell?
07:16:03 <kakashiAL> https://paste.xinu.at/UEQ/js
07:17:43 <kubbe> I have read what you said now, and I sort of understand that. Its the implementation thats bothering me. I need to go to work now though! I'll come back later and i'll ask for help then instead with some actual code examples that I already have
07:17:54 <Welkin> map ((<> " cents") . (*100) . parseFloat . trim)
07:17:57 <Welkin> in pseudocode of course
07:18:09 <reactormonk> Welkin, any way you can reverse the order?
07:18:12 <Welkin> ?
07:18:15 <Welkin> what do you mean?
07:18:24 <reactormonk> trim . parseFloat . (*100) . (<> "cents")
07:18:29 <Welkin> why would you do that?
07:18:34 <Welkin> it is backwards
07:18:41 <Welkin> the value comes in on the right-hand side
07:18:42 <reactormonk> I like my code going from left to right.
07:18:52 <Welkin> it's a pipeline
07:18:54 <Welkin> right to left
07:19:04 <Welkin> yes, you *can* applie left to right if you want
07:19:09 <Welkin> using flip ($)
07:19:17 <Welkin> which is aliased as (&)
07:19:20 <Welkin> it is not idiomatic
07:19:25 <Welkin> but you see it in lens code
07:19:40 <Welkin> but that is not composition then
07:20:00 <reactormonk> Gotta start reading arabic in that case?
07:20:06 <Welkin> if you want to *compose* left to right, you need to use the alternate compose operator from Data.Arrow
07:20:09 <Welkin> (>>>)
07:20:22 <Welkin> :t (>>>)
07:20:25 <lambdabot> forall k (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
07:20:37 <Welkin> :t (.)
07:20:39 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:20:57 <Welkin> the first two arguments are flipped
07:21:12 <Welkin> so I suppose you could also just alias `flip (.)`
07:21:17 <Welkin> :t flip (.)
07:21:18 <Gurkenglas__> reactormonk, note \x -> (<> " cents") ((*100) (parseFloat (trim x)))
07:21:18 <lambdabot> (a -> b) -> (b -> c) -> a -> c
07:21:37 <reactormonk> Gurkenglas__, yeah, I know
07:21:58 <reactormonk> I just protest the arabic influence with reading from left to right ;-)
07:22:04 <reactormonk> ehh right to left.
07:22:06 <Welkin> it's not an arabic influence
07:22:11 <Welkin> that is how it is done in mathematics
07:22:22 <Welkin> it's just how functions compose
07:22:27 <reactormonk> lemme dig up some history
07:23:17 <Welkin> (f . g) a = f(g(a))
07:23:21 <Welkin> they are in the same order
07:23:31 <reactormonk> I'd make a guess the original functions may come from the arabs, since they were miles ahead back in these times... or did the function notation come before that?
07:23:37 <Welkin> the way it is done in object-centric languages like javascript is backwards
07:23:48 <hpc> reactormonk: do you protest the arabic influence in our digits for numbers being 0123456789?
07:24:10 <hpc> that region was an institution of math before the crusades
07:24:23 <hpc> they discovered zero and algebra
07:24:31 <reactormonk> hpc, yeah. That's why I suppose it's that way.
07:24:33 <hpc> and the radius of the earth, to under 1%
07:24:55 <hpc> and what even is bad about it having that influence?
07:24:58 <hpc> who gives a shit, it's math
07:25:21 <hpc> it either works as a notation, or it doesn't
07:25:59 <reactormonk> I've always found it easier to write my code left-to-right - time to change that in certain locations.
07:26:07 <hpc> we have something like 5 or 6 different notations for exponentiation, just as many for integration and differentiation
07:26:12 <hpc> even fractions have multiple representations
07:26:42 <reactormonk> hpc, I've only ever seen one for fractions, what are the others?
07:26:59 <hpc> x / y
07:27:01 <hpc> x ÷ y
07:27:08 <hpc> 0.z
07:27:13 <hpc> x
07:27:14 <hpc> _
07:27:14 <hpc> y
07:27:29 <reactormonk> I'd consider the first and the last to be the same, but totally forgot about the second.
07:27:50 <hpc> z%
07:28:05 <taktoa> continued fraction representation
07:28:07 <hpc> z‰
07:28:34 <hpc> and sometimes z**-1
07:28:49 <Welkin> reactormonk: you can even use right-to-left monadic bind/composition as well
07:28:53 <Welkin> it it works out
07:29:04 <reactormonk> Welkin, <<= ?
07:29:09 <Welkin> =<< instead of >>=, and <=< instead of >=>
07:29:20 <reactormonk> almost.
07:29:32 <Welkin> it is very nice for composiing a pipeline
07:29:44 <hpc> reactormonk: anyhoo, you might find it being good for your brain to be able to think in both directions
07:29:58 <hpc> even if just for things like mutually recursive let-bindings
07:30:06 <Welkin> or for more complex expressions, you can use do-notation, which looks like imperative code
07:30:32 <hpc> at one logical extreme, you may even find yourself writing code that executes in both directions
07:30:39 <reactormonk> hpc, like lenses?
07:30:45 <hpc> heh
07:30:47 <Welkin> lol lenses
07:30:59 <hpc> i wrote a toy image manipulation library that wrapped around imagemagick
07:31:08 <hpc> it uses do-notation that runs in both directions
07:31:20 <hpc> there's a checkpoint stage that runs backwards, looking for the sections it needs to compute
07:31:31 <Welkin> hpc: and you used the imagemagick logo of the stoned wizard in your tests?
07:31:34 <hpc> and then a generation step that runs forwards through whatever sub-images haven't been generated
07:31:47 <hpc> Welkin: please, nasa images :D
07:32:09 <reactormonk> Got that code somewhere?
07:32:17 <hpc> yeah, sec
07:32:28 <Welkin> https://github.com/reflex-frp/reflex-examples/blob/master/BasicTodo/BasicTodo.hs#L28
07:32:34 <Welkin> this wizard is stoned out of his mind
07:32:38 <hpc> https://github.com/headprogrammingczar/magick-mirror/tree/master/haskell
07:32:41 <Welkin> oops
07:32:42 <Welkin> lol
07:32:44 <Welkin> https://en.wikipedia.org/wiki/ImageMagick#/media/File:ImageMagick_logo.svg
07:32:45 <Welkin> that one
07:34:02 <hpc> reactormonk: should work on any system that has imagemagick on the path, and works relative to the current working directory
07:34:33 <hpc> and because they're all tests, the images they make are pretty stupid-looking
07:37:00 <Welkin> no way
07:37:07 <Welkin> Persistent is written mostly in C?
07:37:11 <Welkin> https://github.com/yesodweb/persistent
07:38:20 <ahihi> https://github.com/yesodweb/persistent/search?l=c doesn't look like it
07:38:28 <Welkin> wtf?
07:38:31 <Welkin> I don't see any C code
07:38:32 <Welkin> lol
07:38:36 <Welkin> github is just fucked up
07:39:41 <rmrfroot> in this example: `data A = X | Y' A is called a "sum type", what are X and Y called? just "types"?
07:40:01 <Welkin> they are data constructors
07:40:05 <Welkin> A is the type
07:40:06 <implementation> don't forget the 5% Objective C :D
07:42:23 <ahihi> actually it does include sqlite.c
07:42:27 <ahihi> which is 6.33 MB
07:42:36 <Welkin> where o.o
07:42:50 <ahihi> sorry, sqlite3.c
07:42:54 <ahihi> https://github.com/yesodweb/persistent/tree/18028b4d4403ee2b2636fe2c9b8ffee6b4cded33/persistent-sqlite/cbits
07:42:55 <Welkin> oh damn
07:43:03 <Welkin> sqlite, always screwing things up
07:43:06 <rmrfroot> Welkin: if we're in "math land" and not in "haskell land"?
07:43:22 <Welkin> rmrfroot: no, these are the haskell terms
07:43:47 <rmrfroot> Welkin: i know, i'm asking about the mathematical terms :)
07:43:53 <Welkin> oh, I don't know
07:44:07 <rmrfroot> alright, no worries! 
07:51:06 <reactormonk> Which typeclass would I define for m a -> a?
07:51:52 <Welkin> what do you mean?
07:52:03 <Tuplanolla> Is it a comonad, reactormonk?
07:52:29 <Tuplanolla> If so, you're in luck. Otherwise you'll have to settle with the disgusting copointed.
07:53:21 <reactormonk> The data point is basically https://github.com/ghc/ghc/blob/e9a239ce3569239768204c93a2eb90bfb0f3383d/compiler/basicTypes/SrcLoc.hs#L516
07:53:30 <reactormonk> s/point//
07:54:36 <reactormonk> ah, they just did the unLoc function here. eh, I guess that works.
08:04:03 <reactormonk> Is there a nice way to ask ghc about the dependency graph of files?
08:08:26 <hackal> Hi, I am sorry if this is a bad question. I have "newtype Symbol = LTR (Bool,Variable)" in code. What exactly does the keyword 'LTR' means? I have never seen it before.
08:08:41 <Welkin> LTR is not a symbol
08:08:46 <opqdonut> reactormonk: ghc -M, "generate dependency information suitable for use in a Makefile"
08:08:53 <Welkin> it looks like it is a data constructor there
08:09:09 <Welkin> er
08:09:13 <Welkin> it is a type
08:09:17 <Welkin> (because of the newtype)
08:09:28 <Welkin> type constructor
08:09:34 <opqdonut> no
08:09:41 <opqdonut> it's the (value) constructor for the type Symbol
08:09:49 <Welkin> o.o
08:09:52 <Welkin> oh yeah
08:09:58 <Welkin> I was thinking type alias
08:10:13 <Welkin> but it's a newtype, which is the same as using `data` with one field
08:10:17 <opqdonut> hackal: so it's just like somebody had defined "data Symbol = Symbol (Bool,Variable)", except instead of data they've used newtype
08:10:34 <opqdonut> hackal: and instead of naming the value constructor the same as the type, they've given it the name LTR
08:10:49 <Welkin> switching between so many different yet similar languages can be confusing
08:12:34 <reactormonk> opqdonut, hmm, any way to do that from stack?
08:12:39 <hackal> Oh, I see. So if I were to make an instance I would call LTR (True, "var"). Variable is just "type Variable = String"
08:13:24 <opqdonut> reactormonk: "stack ghc -M ..."?
08:13:54 <opqdonut> hackal: yeah
08:14:32 <hackal> thank you
08:14:58 <reactormonk> opqdonut, doesn't search all the files specified by cabal, which makes it a bit more interesting
08:15:33 <reactormonk> ah, subprojects...
08:16:57 <bgamari> kgadek, have you tried recently?
08:17:01 <bgamari> I worked on it last night
08:17:12 <bgamari> but there was apparently one lurking issue that I fixed this morning
08:18:15 <kgadek> bgamari: yes, it worked :)
08:18:22 <kgadek> thank you :)
08:19:43 <bgamari> great
08:19:51 <bgamari> let me know if you encounter any other issues
08:30:17 <reactormonk> Now the fun part - how do I compile a .x file to a .hs file?
08:30:32 <reactormonk> The default stack build seems to work nicely, but when I manually invoke ghc, it doesn't find that.
08:35:17 <erewok> I was experimenting with DataKinds this morning I couldn’t figure out how to get term-level access to some promoted types inside a type-level tuple
08:37:13 <erewok> If I have the following:
08:37:16 <erewok> type Indent = '((" " :: Symbol), (4 :: Nat))
08:37:23 <erewok> indent:: Proxy Indent
08:37:23 <erewok> indent = Proxy
08:37:42 <erewok> Are there some equivalent type-level functions to fst and snd?
08:37:55 <reactormonk> ah, it's alex.
08:46:12 <glguy> erewok: That isn't defined in the base package. The singletons package has it, but it's a pretty big investment. You can also define such a type function with a Type Family
08:46:34 <erewok> ah, thanks for the info.
08:46:52 <Tuplanolla> This question may be a bit vague, but here goes. I have a stack of threads are tied to various resources, so I end up with a `bracket` nest about 12 levels deep. What abstractions should I look into in order to untangle this mess?
08:54:10 <maksim__> i'm trying code get the ghc-mod extension to work in vscode and there's a suggestion for debugging to "open the ghc-mod server output channel."
08:54:16 <maksim__> does anyone understand what that means?
08:55:25 <hexagoxel> Tuplanolla: resourcet maybe?
08:56:29 <Tuplanolla> Looking good, hexagoxel.
08:56:30 <nshepperd_> Tuplanolla: you can't make a withFoo function that does all 12 brackets at once?
08:56:54 <Tuplanolla> No, they all depend on intermediate results, nshepperd.
08:58:16 <nshepperd_> I think ContT can also abstract away withBlah actions
08:58:56 <nshepperd_> ... Probably
08:59:04 <Tuplanolla> I can paste the essential part I have now, but be warned that it's pretty disgusting.
09:02:25 <hexagoxel> i wonder if ContT can express the interleaving-part of ResourceT as well..
09:02:41 <lpaste_> Tuplanolla pasted “Bracket Mess” at http://lpaste.net/352447
09:04:48 <Rembane> Good morning, I am using mtl, and I have transformer stack like this: newtype m a = CustomMonad (... m) a; and I would like to run a computation in m, how do I do that?
09:04:51 <Tuplanolla> There's the main thread that owns the clock thread that owns the dispatch thread that owns several accept threads that each own a monitor thread of which each owns a read thread that owns a write thread.
09:06:18 <Tuplanolla> Dispatch and monitor both wait for messages to add or remove accept or read threads.
09:07:51 <hexagoxel> .. Tuplanolla you mind if i use that as a testcase for my pretty-printing lib?
09:08:46 <Tuplanolla> I don't care.
09:09:50 <Tuplanolla> Do you reckon `ResourceT` would help?
09:11:23 <hexagoxel> i think so, but i have not used ResourceT heavily myself.
09:12:09 <nshepperd_> I think probably moving these into separate functions would help more
09:13:22 <Tuplanolla> I'll start there, but the big reason why the bracketing is so nontrivial is because some resources outlive `runThreads`.
09:22:33 <zipper> Stack seems to be stuck at "Updating package index Hackage (mirrored at https://github.com/commercialhaskell/all-cabal-hashes.git) ..." know how I can get progress on this part?
09:23:06 <zipper> I ran `stack update --verbose`
09:23:23 <zipper> but no visible progress really I know it's cloning the repo 
09:23:34 <zipper> but I'm not sure how to know that this is even happening
09:23:44 <zipper> Anyone?
09:24:46 <AndreasK> You could always check network/cpu usage although that won't help for some cases like infinite loops
09:24:59 <AndreasK> But stack update never took over a minute for me
09:25:16 <zipper> AndreasK: hmmmm my internet connection seems to go to shit at git clone
09:25:29 <zipper> Also not in like the country with the fastest network
09:25:31 <zipper> :D
09:25:49 <zipper> I wish it took even 5 mins but it doesn't
09:26:57 <AndreasK> zipper:To be honest I think it's faster if you run it regulary. So maybe it takes longer for a new install as well
09:27:10 <zipper> AndreasK: Yes this is a new install
09:27:26 <zipper> Actually a new computer that I haven't gotten stack to work on for some reason
09:27:36 <zipper> wiped
09:35:06 <kakashiAL> hey guys, I spend more and more time with haskell and I also want to sepend some time with category theory (still a newbie)
09:35:17 <kakashiAL> at the moment I love and do a lot with javascript
09:35:42 <kakashiAL> what I want to know is why is haskell so fast? I mean even facebook uses it for the backend
09:36:05 <kakashiAL> if I use the functional ideas in javascript or other languages, its not so fast like in haskell
09:36:28 <kakashiAL> I dont understand why
09:36:51 <pavonia> kakashiAL: The compiler generates fast code, that doesn't mean the language itself is fast or slow
09:37:34 <c_wraith> kakashiAL: GHC has like...  25ish? years of time spent on optimizing code using common functional patterns, at the expense of other things.
09:38:10 <c_wraith> kakashiAL: in particular, GHC generates quite slow code if you use certain patterns you might be used to in other languages but are considered bad in Haskell.
09:40:53 <kakashiAL> c_wraith, pavonia: so even if I use patterns and ideas from haskell, I will not get the speed what I get in haskell :(
09:41:59 <kakashiAL> in javascript and other languages mutations are faster, for-loops are faster, recursion and stuff like map()/reduce() and other functions like these are slow in comparison with loops
09:42:02 <pavonia> Sure, because JS compilers are likely not optimized for Haskell patterns
09:43:14 <reactormonk> Also, compiling without type information is a bit harder.
09:53:14 <Welkin> javascript is not meant to be fast (and is not anyway)
09:53:54 <Welkin> you can program using ap urely functional approach just fine
09:54:07 <Welkin> don't worry about performance until (or if ever) is becomes a problem
09:54:27 <Welkin> I see this a lot with people fairly new to programming (not sure about your background)
09:54:43 <Welkin> I think this is a symptom of the wrong concepts being focused on in schools
09:55:00 <Welkin> "let's optmimize this made-up toy example problem for no reason"
09:57:38 <monochrom> Another wrong concept from school (those who preach OO anyway): "let's abstract the hell out of this simple record into an abstract class for purely speculative futurology reasons"
09:59:19 <hpc> there's a good concept in there that got cargo-culted into some sort of low-level prescriptive way of writing code
10:10:49 <hackal> monochrom: working on my haskell assignment. I completely agree with the abstraction.
10:42:13 <abhiroop> A blog post on Apfelmus' blog post on Finger Trees: https://abhiroop.github.io/Finger-Trees/
10:44:28 <osfameron> abhiroop: thanks, that looks useful
10:44:55 <lordcirth> abhiroop, interesting thnaks
11:01:27 <AWizzArd> How should this be understood?   count = (length .) . filter
11:01:39 <mrkgnao> @jle`: https://gist.github.com/mrkgnao/a45059869590d59f05100f4120595623 :)
11:01:39 <lambdabot> Unknown command, try @list
11:02:23 <geekosaur> @unpl count = (length .) . filter
11:02:23 <lambdabot> count x x0 = length (filter x x0);
11:04:44 <AWizzArd> geekosaur: what is   (length .)?
11:05:02 <geekosaur> partially applied composition
11:05:20 <geekosaur> it's just like (1 +) but the operator is (.) instead of (+)
11:05:22 <kgadek> AWizzArd: similarily to (123 +)
11:07:49 <AWizzArd> Okay, makes sense.
11:23:34 <excelsiora> hi haskell!
11:24:04 <excelsiora> Anyone having a good experience with using orgmode and haskell? If so, what are you doing?
11:25:44 <bollu> excelsiora: I _hate_ literate org mode. The tooling is sub-par and interacts poorly with tools like intero.
11:30:58 <bollu> I saw the Frank language where computations / effects are first class (represented by the type system). Has anyone written a language where free monads are first class?
11:31:08 <bollu> so we can do the whole DSL-interpreter thing?
11:33:37 <hpc> idris has something like that
11:33:54 <bollu> hpc: god damn, why are all the ideas I have taken
11:33:59 <nshepperd> are free monads not first class in haskell?
11:34:00 <bollu> hpc: can you point me to a link?
11:34:15 <bollu> nshepperd: not at the type system level, they are the same as any other monadic "thing"
11:34:17 <hpc> http://docs.idris-lang.org/en/latest/tutorial/syntax.html
11:34:35 <hpc> bollu: it's not quite what your idea is though, so maybe it's not taken yet ;)
11:34:42 <bollu> hpc: fair point :)
11:34:49 <hpc> bollu: all the good ideas build on other ideas anyway
11:35:06 <Tuplanolla> It's delightful to find other people have successfully implemented your new idea, because then you can skip the doing and go right to using, bollu.
11:35:25 <nshepperd> bollu: in what sense would you want them to be different?
11:36:31 <bollu> nshepperd: I'm not sure to be honest. Perhaps allow the type system to capture the notion of "interpretation" at a more detailed level. 
11:36:45 <bollu> Tuplanolla: but.. I'm an undergrad enrolled in a program that needs me to publish to graduate :P
11:37:02 <Tuplanolla> Too bad.
11:37:12 <hpc> wait what
11:37:19 <bollu> hpc: idk
11:37:23 <hpc> publish or perish in undergrad?
11:37:31 <bollu> hpc: well, it's a dual-degree program. 
11:37:42 <hpc> is it one of those accelerated masters'?
11:37:44 <bollu> hpc: so, we get both our undergrad and master's at once
11:37:45 <bollu> yes
11:37:48 <hpc> ah
11:38:11 <Tuplanolla> I'm doing both the same year too, but they're normal theses, bollu.
11:38:21 <bollu> I see
11:38:35 <bollu> Tuplanolla: link to thesis or some such?
11:39:12 <Tuplanolla> If you insist: http://users.jyu.fi/~sapekiis/pen-of-pigs/thesis.pdf
11:39:39 <Tuplanolla> The next one will be in English.
11:40:19 <bollu> thanks :)
11:42:31 <bollu> Tuplanolla: for eigenlanguage, did you implement STG or some other evaluation strategy?
11:43:07 <Tuplanolla> No. I was going to go straight for LLVM, but it remains just an interpreter.
11:43:16 <bollu> I see
11:43:30 <Tuplanolla> I couldn't make my mind about modules.
11:43:53 <bollu> also, |L> for the symbol is cute :) Wonder what <L| will be like though
11:44:10 <Tuplanolla> The name isn't that good since we already have Eigen though.
11:44:32 <Tuplanolla> That's what you get when your projects are built from jokes.
11:47:32 <Tuplanolla> I still don't know how modules should work in a homoiconic language. If they're too general, the compiler won't be able to do static analysis on dependencies. If they're too restricted, life is suffering.
11:52:52 <DemiMarie> I can't install crypto-api or monad-logger
11:52:58 <DemiMarie> both give linker errors 
11:53:01 <DemiMarie> using cabal
12:07:39 <Wizek_> DemiMarie, Can you paste the error e.g. here? http://lpaste.net/
12:08:10 <cocreature> also some information on your system would be helpful (os, ghc version, cabal version, …)
12:11:54 <DemiMarie> http://lpaste.net/3498054500982194176
12:12:35 <DemiMarie> OS: Fedora 25; GHC version: 8.0.2 built from source; Cabal version: 1.25.0.0
12:12:48 <DemiMarie> Wizek_: is that enough information?
12:13:30 <pikajude> reinstall stm-chans and entropy?
12:14:44 <tsahyt> is there anyone around with AFRP experience?
12:15:06 <tfc> hi. i am using optparse-applicative. and when i write (long "fooparam" <> short 'f'), GHC tells me "No instance for (Semigroup (O.Mod O.OptionFields String)) arising from a use of ‘<>’" i don't understand why, as the Mod type is an instance of that class by documentation.
12:15:28 <pikajude> tfc: open up GHCi and see if Mod is an instance of Semigroup
12:15:30 <pikajude> sometimes the docs are wrong
12:15:55 <tfc> pikajude: i basically copy&pasted a tutorial in order to not do anything wrong. 
12:16:00 <pikajude> ok
12:16:16 <pikajude> copy+paste could be considered wrong, but in this case it sounds like the tutorial is
12:16:50 <puregreen> tfc: are you looking at the right version of optparse-applicative docs?
12:16:56 <puregreen> (right = the one you have installed locally)
12:17:12 <puregreen> maybe in older versions they didn't have a Semigroup instance yet, or something
12:17:40 <pikajude> it depends on the version, yes
12:17:49 <pikajude> but at the end of the day, if GHC tells you the instance isn't there, it's not there
12:17:54 <pikajude> maybe use the Monoid version of <> instead
12:18:00 <tfc> puregreen, pikajude i just checked. it's indeed a verion point older, but in the example of the right version it's the same notation.
12:18:07 <pikajude> ok
12:18:18 <pikajude> did you check in GHCi if Mod is an instance of Semigroup
12:18:39 <tfc> not yet. how can i check that exactly?
12:18:52 <pikajude> run ghci
12:19:03 <pikajude> then import whatever modules are necessary, probably Options.Applicative and Data.Semigroup
12:19:03 <tfc> ok
12:19:12 <pikajude> input `:i Mod`
12:19:16 <pikajude> it will tell you what instances are in scope
12:19:34 <tfc> indeed. it only lists monoid
12:19:34 <Wizek_> DemiMarie, Looking at this I'm not sure what is going wrong, however I have two hunches: (a) May be an incompatibility with GHC 8.0.2, have you tried with 7.10.3 perhaps? (b) somewhat less likely in this case since this is a third party library, but I remember getting similar linker errors when I didn't specify some modules in the other-modules field of my cabal file. Maybe that's relevant for you.
12:19:46 <pikajude> tfc: sounds like that's the problem then
12:20:02 <pikajude> did you install that library with docs enabled?
12:20:21 <tfc> no
12:20:37 <pikajude> i see
12:20:56 <pikajude> well, unless you really want to use Semigroups, the Monoid <> should accomplish the same thing
12:21:05 <pikajude> or you could update your version of optparse-applicative, maybe the instance is in the newer version
12:21:11 <tfc> pikajude so i removed the semigroup module from my includes list, and now it doesn't find "<>". seems like i need to include something else. is that Data.Monoid ((<>)) then?
12:21:20 <pikajude> yes
12:21:47 <tfc> wow that worked!
12:21:51 <tfc> thank you man
12:22:26 <pikajude> no problem
12:22:29 <tfc> i was looking for different command line option parse libs and i thought that optparse-applicative seems to be the "best" one as of today. but that semigroup thing puzzled me. :D
12:22:30 <pikajude> ghci is very useful for these types of problems
12:22:41 <tfc> yeah i'm getting some experience here...
12:24:01 <Tuplanolla> Unfortunately `ResourceT` doesn't seem to help me much, hexagoxel.
12:24:04 <bollu> what s the current state of FRP?
12:28:16 <hexagoxel> Tuplanolla: ah i am sorry. managing differing lifetimes still too hard?
12:28:19 <DemiMarie> Wizek_: I will check.  I also think I might have a screwed up cabal installation.
12:28:45 <Tuplanolla> It's the problem that I don't want to release all resources at once, but let some live through the computation, hexagoxel.
12:30:15 <hexagoxel> Tuplanolla: and when you start manually releasing there is not enough advantage to using resourcet in the first place?
12:30:21 <Tuplanolla> Yeah.
12:30:35 <Squarism> Can i have a list of Eq * ?
12:30:47 <Tuplanolla> The ones that need to be released are all nested anyway.
12:30:50 <geekosaur> no
12:30:54 <hexagoxel> i see
12:31:06 <Tuplanolla> This is a cool package though.
12:31:16 <geekosaur> not without an existential that will almost certainly render it useless for whatever you are trying to do
12:32:31 <cocreature> if I want to use Data.List.NonEmpty with base < 4.9, what’s the package I’m looking for?
12:33:35 <cocreature> base-compat doesn’t seem to have it
12:33:56 <hexagoxel> semigroups
12:34:06 <Wizek_> Squarism, In GHCi you may type `:i Eq` and AFAIK that will give you all the loaded instances.
12:34:19 <cocreature> hexagoxel: ah right, thanks!
12:34:39 <hexagoxel> hayoo does not mention base, curiously, only semigroups..
12:35:30 <cocreature> hexagoxel: hoogle only mentions base and not semigroups :)
12:35:42 <hexagoxel> good we have indices on different ghcs :)
12:37:19 <sternmull> i have to split a ByteString (coming from TCP) that contains data blocks (purpose, len, data) into multiple streams (Lazy ByteStrings?). What would be a good approach?
12:37:50 <dikdik> How would I convert Just "Hello" to Hello 
12:37:59 <dikdik> While still handling Nothing
12:38:04 <pikajude> what do you mean "handling"
12:38:07 <cocreature> dikdik: how do you want to handle Nothing?
12:38:22 <geekosaur> "maybe" combinator, or the Monad instance
12:38:23 <dikdik> "Goodbye"
12:38:38 <pikajude> fromMaybe "Goodbye"
12:38:38 <geekosaur> or fromMaybe
12:38:40 <pikajude> :t fromMaybe "Goodbye"
12:38:41 <cocreature> you can just pattern match on the maybe value
12:38:42 <lambdabot> Maybe [Char] -> [Char]
12:39:12 <dikdik> someValue fromMaybe "Goodbye"?
12:41:09 <pikajude> only if someValue :: (a -> Maybe a -> a) -> [Char] -> [Char]
12:41:10 <pikajude> which I doubt it is
13:00:42 <sternmull> Anyone knows if i can use conduit to mulitplex/demultiplex chunks of data? I need custom logic to decide where which chunk goes.
13:02:59 <dikdik> So, I need help with the type signature of getResponse src/Main.hs:12:17:
13:02:59 <dikdik>     Expected a constraint, but ‘Maybe a’ has kind ‘*’
13:02:59 <dikdik>     In the type signature for ‘getResponse’:
13:02:59 <dikdik>       getResponse :: (Maybe a) => a -> String
13:03:03 <dikdik> Urg
13:03:06 <dikdik> Wrong key 
13:03:09 <dikdik> I appologize 
13:03:27 <pikajude> why is that written as a constraint
13:03:45 <dikdik> I though that was thr right way to do it...
13:03:51 <dikdik> http://lpaste.net/834874632262647808
13:03:57 <dikdik> this is what I meant to paste
13:04:00 <pikajude> what do you believe a constraint does?
13:04:14 <dikdik> Um, aliases a to type Maybe a?
13:04:53 <pikajude> no
13:04:57 <pikajude> imagine (Ord a) => a
13:05:04 <pikajude> this requires that `a` is an instance of Ord, which is a typeclass
13:05:09 <pikajude> Maybe is a type constructor
13:05:32 <pikajude> (Maybe a) => a would mean "a must be an instance of Maybe" which doesn't make sense because Maybe can't have "instances" because it isn't a class.
13:05:44 <pikajude> all you need is getResponse :: Maybe a -> String
13:05:45 <dikdik> So how would I rewrite it to say that it takes a Maybe and results in a String?
13:05:51 <dikdik> Oh
13:06:28 <lordcirth> pikajude, can any not-taken string be used in place of 'a'? Just wondering
13:06:40 <pikajude> lordcirth: by string, do you mean identifier?
13:06:47 <lordcirth> yes
13:06:58 <pikajude> yeah
13:07:03 <pikajude> GHC doesn't care what you use for your type variable names
13:07:17 <pikajude> except that the same identifier used in different places requires that those two places refer to the same type, obviously
13:07:25 <VitorCBSB> I have a dumb question. How would a function that splits a list by length look like? (e.g.: f [1,2,3,4,5,6] 2 = [[1,2],[3,4],[5,6]]).
13:07:30 <pikajude> sorry, by "in different places" here i mean in the same type signature
13:07:31 <dikdik> Okay that fixed one error 
13:07:44 <dikdik> Now I get a longer, more daunting one xD
13:07:50 <pikajude> foo :: a -> a means foo takes a value of any type and returns a value of the same type
13:07:59 <pikajude> foo :: a -> b means foo accepts anything and returns anything
13:08:09 <pikajude> which, of course, is a useless type
13:08:30 <Koterpillar> VitorCBSB: it exists in Data.List.Split
13:08:43 <dikdik> http://lpaste.net/834874632262647808
13:08:58 <dikdik> I think this is telling me it is expecting an IO() and is not getting one
13:09:02 <pikajude> dikdik: i still see (Maybe a) => in your code
13:09:23 <VitorCBSB> Koterpillar: Oh? What is it called?
13:10:06 <dikdik> I changed the signature to what you told me
13:10:16 <pikajude> no you didn't
13:10:32 <VitorCBSB> Koterpillar: Just found it. It's called chunksOf. Thanks. :)
13:10:34 <Koterpillar> VitorCBSB: chunksOf
13:11:08 <dikdik> http://lpaste.net/834874632262647808
13:11:12 <dikdik> Yeah I did
13:11:16 <pikajude> oh, ok
13:11:18 <dikdik> Just not in that particular paste...
13:11:23 <pikajude> i see, the paste wasn't updated
13:11:32 <dikdik> I know, my bad
13:11:43 <pikajude> ok, so the way you've written the type signature for getResponse indicates that it takes a Maybe a and returns a String
13:11:54 <pikajude> but the way you've written the body, the argument must be a Maybe String; it can't just be anything
13:11:57 <pikajude> that's why the compiler is complaining
13:13:32 <dikdik> Oh, I see
13:14:16 <dikdik> http://lpaste.net/834874632262647808
13:14:35 <pikajude> next error is because you're using do-notation wrong
13:14:37 <dikdik> I think this has to do with wrong string types but I thought overloadedstrings fixed that...
13:14:44 <dikdik> I am?
13:15:01 <pikajude> yeah
13:15:14 <pikajude> the monad you're in on line 18 is IO
13:15:28 <pikajude> if you want to use `<-` to bind a variable, the right hand side must be of type IO a
13:15:32 <pikajude> and then the left hand side will be type a
13:15:39 <pikajude> but getResponse is just Maybe String -> String
13:15:43 <pikajude> you should be using `let`
13:16:04 <dikdik> let address = getResponse .. in print address?
13:16:20 <pikajude> you don't need `in` if you write a let-binding in a do block
13:16:37 <pikajude> do { x <- someIOOperation; let y = somePureFunction x; doSomethingWith y }
13:16:43 <Squarism> do i need to export instances from a module also - if so, how do i write that?
13:17:04 <pikajude> Squarism: no, instances are all exported and you have no control over it
13:30:26 <Squarism> hmm.. many months of haskell and i havent used classes that much. I gather they are not to be seen as interfaces ? As i cannot declare a value to be of a certain class?
13:30:49 <Squarism> (with interface i mean javas dito)
13:31:44 <johnw> Squarism: they are algebraic interfaces, and not so much object interfaces
13:31:57 <benzrf> what is algebraic about them exactly johnw 
13:32:15 <johnw> all instances of that interface used in a function call must be the same
13:32:21 <johnw> Monad m => m a -> m a -> m a
13:32:27 <johnw> this will involved only one Monad instance for any given call
13:32:36 <johnw> object interfaces would allow 3 different Monads to be involved
13:33:56 <Squarism> i think i get it. So its better to use a data type and have function fields - to mimic object interfaces
13:34:13 <johnw> exactly
13:34:24 <johnw> I've used that trick successfully on many occasions
13:36:58 <Squarism> thanks
13:56:07 <Nambla> Given a list list0, is there any way to make the list of all length n lists from elements of  list0?  That is, list0^n
13:57:06 <Nambla> For example, if $n = 2$, we could just do [[x1,x2] | x1 <- list0, x2 <-list0]
13:57:15 <monochrom> I do not understand "That is, list0^n". I think it is an unclarification.
13:57:19 <Nambla> But I'd like to make $n$ vary
13:57:20 <ubsan> Nambla: I'd use a recursive function
13:57:31 <Nambla> ubsan: thanks
13:57:36 <hpc> this sounds like the choose function, if i read way into the more confusing parts of that question
13:57:40 <ubsan> f : List a -> Nat -> List (List a)
13:57:47 <ubsan> f _ 0 = []
13:57:54 <monochrom> > sequence [[a,b], [a,b]]
13:57:58 <lambdabot>  [[a,a],[a,b],[b,a],[b,b]]
13:58:08 <ubsan> f lst (S n) = lst :: (f lst n)
13:58:27 <kgadek> Nambla: for n=2, you have `liftM2 (,)`
13:58:29 <Koterpillar> ubsan: this looks like PureScript
13:58:34 <kgadek> > liftM2 (,) [1,2,3] [1,2,3]
13:58:37 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
13:58:40 <ubsan> Koterpillar: it's idris, I guess
13:58:53 <Koterpillar> oh right, everyone except Haskell itself swapped : and ::
13:58:57 <ubsan> translating it to haskell is left as an exercise to the reader
13:59:00 <monochrom> I see now, ^n refers to cartesian product, yes.
13:59:10 <ubsan> :: as type syntax is gross
13:59:37 <Nambla> monochome, that seems to work
13:59:57 <monochrom> So in general it's going to be sequence (replicate n list0)
14:00:39 <Nambla> monochrom: sequence works, but I haven't figured out why yet ^^
14:00:44 <kgadek> Nambla: http://stackoverflow.com/a/3387461/547223
14:01:41 <monochrom> sequence is a recursive function that unrolls to basically sequence [xs, ys, zs] = do { x<-xs; y<-ys; z<-zs; return [x,y,z] } which is cartesian product.
14:01:42 <kgadek> so for arbitrary n, it's:
14:01:42 <Nambla> kgadek: Thanks, I should have expected more of google 
14:01:47 <kgadek> > sequence . replicate 3  $ [1,2,3]
14:01:50 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,...
14:02:01 <kgadek> > sequence . replicate 4  $ lst
14:02:05 <lambdabot>  error:
14:02:05 <lambdabot>      • Variable not in scope: lst :: m a
14:02:05 <lambdabot>      • Perhaps you meant one of these:
14:02:06 <kgadek> > sequence . replicate 3  $ [1,2,3]
14:02:09 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,...
14:02:15 <kgadek> > sequence . replicate 4  $ [1,2,3]
14:02:18 <ubsan> how is that solving the problem?
14:02:18 <lambdabot>  [[1,1,1,1],[1,1,1,2],[1,1,1,3],[1,1,2,1],[1,1,2,2],[1,1,2,3],[1,1,3,1],[1,1,...
14:02:45 <johnw> btw, sequence . replicate = replicateM
14:02:55 <monochrom> Ah even better
14:03:15 <kgadek> ah yes
14:03:39 <monochrom> Apart from a technicality :)
14:04:06 <monochrom> No, it's fine.
14:04:19 <monochrom> Err, Yes it is not fine.
14:05:03 <Nambla> replicateM 3 [1,2]
14:05:13 <Nambla> > replicateM 3 [1,2]
14:05:16 <lambdabot>  [[1,1,1],[1,1,2],[1,2,1],[1,2,2],[2,1,1],[2,1,2],[2,2,1],[2,2,2]]
14:05:20 <Nambla> Magic...
14:05:57 <monochrom> @type traverse
14:06:00 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
14:06:05 * geekosaur feels like quoting http://languagelog.ldc.upenn.edu/nll/?p=30943 is appropriate here
14:06:28 <monochrom> Haha yes
14:10:50 <Nambla> Quick question: is there a reason why lists  of a's aren't just maps "Int -> a" ? 
14:11:14 <johnw> Int -> a is hard to ask the size of
14:11:27 <Koterpillar> Nambla: you described only infinite lists
14:11:28 <c_wraith> Int -> a allows negative indices
14:11:42 <Nambla> Hmm, hmm. You're all right of course.
14:11:43 <Koterpillar> Int -> Maybe a will allow holes, though
14:12:13 <Nambla> But it seems like it would be nice to avoid typing "map" so much.
14:12:37 <Koterpillar> try <$>
14:13:57 <monochrom> Int -> Maybe a can get transcendental on where the holes are
14:16:00 <monochrom> If you came here 10 years ago, lambdabot would accept (1 +) . [3,4,5]
14:16:38 <monochrom> ( = (1 +) `fmap` [3,4,5] )
14:19:58 <hpc> (Int -> a) encodes a fixed-size list of a
14:20:14 <hpc> which is at least 2^30 elements
14:20:23 <monochrom> :)
14:22:22 <monochrom> A good rule of thumb for communication: When you read "Int", interpret it as a quantum superposition of (1/sqrt 2) Int + (1/sqrt 2) Integer.
14:25:00 <byorgey> monochrom: needs moar < |
14:27:08 <monochrom> No no, it's the other side, |Int> and |Integer>
14:28:36 <Tuplanolla> Now you introduced state where there should be none.
14:29:34 <byorgey> monochrom: ah, right =)
14:32:19 <monochrom> Tuplanolla: It is a "pure" state, if it's a consolation :)
14:34:08 <alexashka> hi folks, simple question, in class Functor f where ... How come you don't need to specify that f :: * -> *? Is it because fmap includes types f a, f b?
14:34:29 <alexashka> and there's kind inference happening?
14:35:21 <c_wraith> alexashka: there is indeed inference.
14:35:37 <c_wraith> FIrst, it sees that a and b are arguments to (->)
14:35:46 <c_wraith> So it knows that they have kind *
14:36:12 <c_wraith> then it sees f a and f b are arguments to ->, so f a :: * and f b :: *
14:36:34 <c_wraith> so then it's simple inference that f :: * -> *
14:36:41 <alexashka> ahh ok, it's because -> has a defined kind
14:36:47 <c_wraith> yes
14:36:52 <alexashka> very clever :)
14:37:46 <alexashka> thank you
14:37:52 <c_wraith> sometimes kinds can't be inferred from signatures - then they're assumed to *, unless specified otherwise
14:38:16 <c_wraith> Also, when -XPolyKinds is enabled, kinds are made polymorphic when possible
14:38:52 <c_wraith> I guess that's exactly when they can't be inferred normally.
14:43:15 <alexashka> ok and when you want to make Either for example, an instance of Functor class - you're forced to do instance Functor (Either e) because Either has kind * -> * -> *. And we need * -> *... Does the 'e' have any significance, can it be used in the instance implmenetation for example? Or is it just a placeholder for 'any type'?
14:44:05 <c_wraith> It is a type variable, the same as any other type variable in a signature.
14:44:36 <c_wraith> So if you have -XScopedTypeVariables enabled, you can refer to it explicitly
14:44:49 <c_wraith> Or you could put a constraint on e in the instance head
14:45:20 <lpaste_> lambdafan pasted “type tetris, lens and me” at http://lpaste.net/352467
14:45:33 <c_wraith> With -XFlexibleInstances enabled, you could replace the e with a concrete type, but there's little value to that, at least with Either and Functor
14:46:27 <alexashka> ok so in: instance Functor (Either a) where     fmap _ (Left x) = Left x. If I replace the x with an a there, does that change anything?
14:46:41 <c_wraith> well, it's not in scope
14:46:50 <c_wraith> It's a type variable, not a value variable :)
14:47:27 <Tuplanolla> Are you after `over (game_data_gs . scores_gd . ix name) (points +) g_data`, lambdafan?
14:47:30 <alexashka> ah ok, you're right :)
14:47:31 <Gurkenglas__> lambdafan, how is PInt connected to line 26?
14:47:38 <hpc> alexashka: did you mean fmap _ a = a?
14:48:03 <hpc> alexashka: it's necessary to deconstruct and reconstruct the value, if you follow the types
14:48:09 <Gurkenglas__> (I only see it defined in 17, never used)
14:48:12 <hpc> alexashka: fmap :: (a -> b) -> f a -> f b
14:48:15 <lambdafan> Gurkenglas__ the binding 'points' should be a PInt.
14:48:18 <hpc> alexashka: so you do fmap _ a
14:48:26 <hpc> alexashka: that _ fills in (a -> b), and a :: f a
14:48:32 <lambdafan> Gurkenglas__ : I have a Num instance for PInt
14:48:33 <hpc> alexashka: now on the other side you have a again
14:48:35 <hpc> a :: f b
14:48:39 <hpc> alexashka: which doesn't match
14:48:53 <hpc> if you pattern match, both sides of the equation have x :: a
14:49:00 <Gurkenglas__> lambdafan, do you somewhere define "FaceCount = PInt"?
14:49:07 <hpc> and independent Left x :: Either a a'
14:49:13 <hpc> Left x :: Either a b
14:49:14 <lambdafan> Gurkenglas__ : Yes
14:49:56 <lpaste_> lambdafan annotated “type tetris, lens and me” with “type tetris, lens and me (annotation)” at http://lpaste.net/352467#a352468
14:50:21 <alexashka> hpc: sorry you lost me
14:50:27 <Gurkenglas__> Go with Tuplanolla's suggestion, perhaps consider "game_data_gs . scores_gd . ix name +~ points"
14:52:11 <lambdafan> okay I will try that brb
14:52:39 <hpc> alexashka: lemme pastebin it
14:54:35 <lambdafan> Gurkenglas: this does not type_check (\name points g_data -> over (game_data_gs . scores_gd . ix name +~ points) g_data)
14:56:36 <hpc> lpaste is slow today
14:56:45 <lpaste_> xcmw pasted “Does this operator already exist?” at http://lpaste.net/352469
14:56:52 <hpc> alexashka: http://lpaste.net/5767637729835745280
14:57:13 <hpc> alexashka: this is a rough reconstruction of how types are resolved
14:57:25 <hpc> alexashka: notice that in the second fmap, x has two different types
14:57:51 <lambdafan> Gurkenglas__ : The example Tuplanolla gave me works, but I would like to use your suggestion. My attempt to do so (see above) does not type check.
14:58:15 <Tuplanolla> Check out Microlens' documentation, lambdafan.
14:58:18 <hpc> basically, type checking is done by building a huge-normous system of equations and then solving for all the variables
14:58:37 <lambdafan> Tuplanolla : Thanks, I will :)
14:58:39 <Tuplanolla> You can gradually swap functions for operators if you fancy.
14:58:41 <hpc> the first one has multiple equations representing x :: e
14:58:48 <Gurkenglas__> lambdafan, (\name points -> game_data_gs . scores_gd . ix name +~ points)
14:58:50 <hpc> the second one has contradictory equations that can't solve
14:59:20 <hpc> the types are different so the values have to be, even if they are constructed in the same way
14:59:43 <hpc> (if i am even reading your question right)
14:59:57 <Gurkenglas__> lambdafan, alternatively, (\name -> (+~) $ game_data_gs . scores_gd . ix name) or (\name -> (game_data_gs . scores_gd . ix name +~))
15:00:27 <lambdafan> Gurkenglas__ : Nice, I like it
15:00:44 <lambdafan> I'll refer to microlens docs for further clarification.
15:00:50 <alexashka> hpc:  we have to be talking past one another - the code I pasted is from ghc base, I just left out the remaining line being: fmap f (Right y) = Right (f y)
15:01:34 <hpc> i know
15:02:06 <hpc> that second line doesn't matter for the way that particular type error works
15:02:35 <alexashka> hm, what type error could there be in ghc base?
15:03:13 <monochrom> Actually what is the question?
15:03:57 <hpc> i might have been misinterpreting it
15:04:21 <hpc> the base code is correct
15:04:30 <kgadek> ohh, LTS-8.0 is here. nearly missed that
15:04:44 <hpc> monochrom: it's about 50-ish lines up
15:05:10 <hpc> monochrom: i read it as "why does fmap _ a = a fail and fmap _ (Left a) = (Left a) typecheck"
15:05:23 <alexashka> hpc i am a beginner so I'm siding on the side of caution - but there is no problem with fmap _ (Left x) = Left x as far as I can tell. It just merely means a and b are the same type, which's fine right?
15:06:07 <alexashka> and in fmap f (Right x) = Right f x, a and b are different types
15:07:03 <alexashka> hpc: hehe I didn't ask that question no
15:08:04 <Onemorenickname> hello people
15:08:15 <Onemorenickname> i'm /very new/ to haskell, and come from #ocaml
15:08:21 <hpc> maybe take some time to just experiment with it in ghci?
15:08:24 <Onemorenickname> i was wondering if there was something akin to merlin for haskell
15:08:31 <hpc> see what sort of error messages you get when you change particular things
15:08:33 <Axman6> what is merlin?
15:08:36 <Onemorenickname> like, an emacs plugin where i can ctrl+t the type of an expression
15:08:44 <hpc> and come up with more precise questions
15:08:47 <Onemorenickname> an ctrl+x to the next compilation error
15:08:51 <Onemorenickname> that kind of things
15:08:53 <tesod> Say I have a list of lists like this: MonadRandom M => Vector (m (Vector a)) with Vector from the Data.Vector package. How do I get the random monad out to top level?
15:08:59 <hpc> often just doing that helps answer them in the first place - https://en.wikipedia.org/wiki/Rubber_duck_debugging
15:09:22 <Koterpillar> Onemorenickname: haskell-mode with intero has these
15:09:44 <alexashka> my confusion stemmed from class declarations using class Functor f where... and f is used in the definitions of the type of fmap. And then in the instance declaration of Functor, instance Functor (Either a), the a is not accessible.
15:10:53 <hpc> ooooooooh
15:10:56 <Onemorenickname> Koterpillar, thankks !
15:11:19 <biglama> hi guys, I'm reading CIS194 and stumbled across this question
15:11:22 <biglama> "how would you make function types an instance of Monoid?"
15:11:28 <hpc> alexashka: in "instance Functor (Either a)", a is at the type level
15:11:31 <alexashka> so for class declarations, Functor f, f is a type variable, and gets used. But in instance declarations, Functor (Either a), a is also a type varible, and it is NOT used anywhere
15:11:32 <biglama> do you have any hints about that ?
15:11:35 <hpc> alexashka: which is separate from the value level
15:11:45 <c_wraith> hpc: yes, that's the answer I gave when the question was first asked. :P
15:11:56 <c_wraith> hpc: also, the answer the alexashka said made sense. :P
15:11:59 <alexashka> c_wraith: hehe yes, ty
15:12:06 <Koterpillar> biglama: look at their types
15:12:09 <Tuplanolla> The confusion is even worse with gadt syntax where you can have `data F a where ... -> F b`.
15:12:10 * hpc goes back to ignoring the channel now lol
15:12:17 <Koterpillar> biglama: and how can you make two functions into one
15:15:38 <biglama> Koterpillar: oh, it's easy. thanks :)
15:38:48 <Andr3a_> hi
16:09:28 <magicman_> What's the canonical package for serializing and deserializing binary data? Still the "binary" package?
16:17:13 <johnw> magicman_: I thought so
16:20:28 <magicman_> Cheers!
17:13:44 <qmm> triSum n = foldl (+) 0 [1..n] ; tetraSum n = sum $ map triSum [1..n] -- can anyone think of an alternative way of writing triSum?
17:14:54 <EvanR> > foldl (+) 0 [1..100]
17:14:56 <lambdabot>  5050
17:15:05 <EvanR> > (100*101)/2
17:15:07 <lambdabot>  5050.0
17:15:25 <EvanR> > (100*101) `div` 2
17:15:29 <lambdabot>  5050
17:15:37 <EvanR> triSum has a formula
17:17:50 <qmm> that's interesting
17:18:06 <qmm> tetraSum n = sum $ map (\n -> (100 * n) `dev` 2) [1..n]
17:18:15 <qmm> i would expect tetraSum 12 to equal 364
17:18:17 <qmm> this gives 3900
17:18:33 <qmm> oh, times 101
17:18:36 <Zoybean> triSum n = (n * (n + 1)) `div` 2
17:18:49 <c_wraith> > sum $ scanl (+) 0  [1..12]
17:18:52 <lambdabot>  364
17:19:05 <c_wraith> skip the multiplies and divides. :)
17:20:51 <qmm> c_wraith: i like it
17:21:03 * qmm hasn't used scan before
17:21:19 <c_wraith> scanl is foldl but it gives you back all the intermediate results
17:22:52 <qmm> c_wraith: thank you for that :)
17:23:12 <qmm> now i know how many presents to expect next year?
17:24:01 <qmm> i feel greedy even joking about it
17:28:39 <lyndon> Is there a changelog referencing ghci definition sans let functionality?
17:28:52 <lyndon> For 8.*
17:29:09 <ertes> i bet there is a formula for tetraSum, too
17:29:28 <ertes> > (12*13*14) / (2*3) :: Rational
17:29:31 <lambdabot>  364 % 1
17:30:30 <Zoybean> wait, what's that % notation?
17:31:00 <c_wraith> It's how Rationals show
17:31:05 <MarcelineVQ> lyndon: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/8.0.1-notes.html#ghci  "Added support for top-level function declarations (Trac #7253)."
17:31:18 <lyndon> MarcelineVQ: Thanks!
17:31:31 <Zoybean> Huh, I don't think I've ever directly used rationals
17:31:34 <ertes> @let nSum n x = product [x .. x + n] / product [2..n + 1]
17:31:38 <lambdabot>  Defined.
17:31:45 <ertes> > nSum 2 12
17:31:49 <lambdabot>  364.0
17:31:50 <ertes> > nSum 3 12
17:31:53 <lambdabot>  1365.0
17:32:08 <lyndon> MarcelineVQ: This is so useful for teaching... having to explain and remember the 'let' keyword at the repl is such a pain.
17:32:08 <ertes> > sum (scanl (+) 0 (scanl (+) 0 [1..12]))
17:32:11 <lambdabot>  1365
17:32:26 <c_wraith> ertes: nice
17:32:32 <Zoybean> Wow
17:32:43 <ertes> should work for any n now =)
17:33:28 <ertes> qmm: ^
17:34:35 <MarcelineVQ> lyndon: I've heared ghci described as like being inside a big do block, in which case let isn't quite as confusing and being able to say   foo <- readFile "stuff.txt"   makes some sense
17:34:56 <MarcelineVQ> I don't have any particular stock in whether that description is a good thing to toss around thougfh
17:35:06 <ertes> i wish real do-blocks would allow the 'let' without "let", too =)
17:35:32 <ertes> do x <- c; y = f x; d x y
17:35:37 <lyndon> MarcelineVQ: Oh totally, it makes sense but in practice it trips newbies up a lot.
17:35:51 <lyndon> ertes: That would be awesome.
17:37:14 <ertes> for single-clausers at least
17:47:42 <confusedNoob> Hello all
17:48:01 <confusedNoob> Dont suppose anyone has a second to answer a ( probably ) easy question
17:49:50 <oelewapperke> jatfq
17:49:58 <oelewapperke> (just ask the fine question)
17:51:01 <confusedNoob> lul
17:51:23 <mrkgnao> on the math.stackexchange chatroom they say "just ask, don't ask to ask"
17:51:24 <confusedNoob> I have a function foldr (\x y-> if x == True then y+1 else y) 0
17:51:38 <confusedNoob> To count How many trues in a list
17:51:49 <confusedNoob> How do I use that value in another function?
17:52:00 <confusedNoob> I cannot figure out the syntax I think
17:52:01 <mrkgnao> what value? the result?
17:52:05 <confusedNoob> Yea
17:52:07 <confusedNoob> The result
17:52:24 <mrkgnao> > @let f = foldr (\x y -> if x then (y+1) else y) 0
17:52:27 <lambdabot>  <hint>:1:1: error: parse error on input ‘@’
17:52:36 <mrkgnao> @let f = foldr (\x y -> if x then (y+1) else y) 0
17:52:38 <lambdabot>  Defined.
17:52:43 <confusedNoob> @
17:52:46 <mrkgnao> f [True,True,False]
17:52:52 <mrkgnao> > f [True,True,False]
17:52:54 <lambdabot>  error:
17:52:55 <lambdabot>      Ambiguous occurrence ‘f’
17:52:55 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
17:53:06 <mrkgnao> @let numTrue = foldr (\x y -> if x then (y+1) else y) 0
17:53:08 <lambdabot>  Defined.
17:53:12 <mrkgnao> > numTrue [True,True,False]
17:53:14 <lambdabot>  2
17:53:25 <pikajude> confusedNoob: you bind the result to an identifier
17:53:30 <qmm> @let nSum n = sum(scal (+) 0 (scanl (+) 0 [1..n]))
17:53:32 <lambdabot>  .L.hs:212:1: error:
17:53:32 <lambdabot>      Equations for ‘nSum’ have different numbers of arguments
17:53:32 <lambdabot>        .L.hs:212:1-54
17:53:36 <confusedNoob> I had no idea about bindings
17:53:40 <confusedNoob> That makes sense
17:53:43 <pikajude> read about them
17:53:45 <qmm> @let nSum2 n = sum(scal (+) 0 (scanl (+) 0 [1..n]))
17:53:46 <confusedNoob> I will give it a shot.
17:53:47 <lambdabot>  .L.hs:213:16: error:
17:53:47 <lambdabot>      • Variable not in scope:
17:53:47 <lambdabot>          scal :: (Integer -> Integer -> Integer) -> Integer -> [b] -> t0 a
17:53:50 <pikajude> they're like variable or function definitions
17:53:54 <pikajude> in fact that's what they are
17:53:56 <qmm> @let nSum2 n = sum(scanl (+) 0 (scanl (+) 0 [1..n]))
17:53:59 <lambdabot>  Defined.
17:53:59 <mrkgnao> so now if you have some other function that uses this, you can substitute that expression in, or bind it to something and use the binding as pikajude says
17:54:02 <pikajude> as well as other things
17:54:06 <qmm> > nsum2 12
17:54:08 <lambdabot>  error:
17:54:08 <lambdabot>      • Variable not in scope: nsum2 :: Integer -> t
17:54:08 <lambdabot>      • Perhaps you meant ‘nSum2’ (line 213)
17:54:29 <confusedNoob> I will def go look up some stuff on bindings.  Thats a huge help
17:54:48 <pikajude> you can't get very far in haskell without them
17:54:57 <qmm> > let n = 12 in sum(scanl (+) 0 (scanl (+) 0 [1..n]))
17:55:00 <lambdabot>  1365
17:55:04 <qmm> ertes ^
17:55:18 <qmm> not really following i usppose
17:55:39 <confusedNoob> I did feel like I was at a stand still in Haskell 
17:55:58 <confusedNoob> I have to ask, what exactly is this languange used for, when most of it seems to be replaced by Python
17:56:05 <confusedNoob> At least from my perspective
17:56:10 <pikajude> replaced?
17:56:28 <confusedNoob> Better wording....can be substituted with?
17:56:39 <confusedNoob> With libraries and the like
17:56:50 <qmm> i think this is the formula to use: https://wikimedia.org/api/rest_v1/media/math/render/svg/cd0d400f129098e951207d52c19a470d610b0606
17:56:50 <pikajude> nearly any language can be substituted with any other
17:56:59 <pikajude> haskell users usually prefer haskell over other languages
17:57:20 <Zoybean> 1: Haskell is a strongly typed compiled language, meaning it has certain guarantees at compile time that python won't have
17:58:14 <qmm> ertes, c_wraith EvanR: https://en.wikipedia.org/wiki/Tetrahedral_number
17:59:10 <Zoybean> 2: Haskell is a pure functional language, and so a function can only affect the program through its return value (except IO), meaning debugging is far simpler
17:59:55 <pikajude> debugging tools in haskell are no picnic though
18:00:02 <kgadek> confusedNoob: I heard Python is being replaced with Java. Which is being replaced with Scala. Which is being replaced with Haskell. Which is being replaced by Befunge. Totally what I heard [citation needed]
18:00:19 <kgadek> sorry for being sarcastic, it's just for laughs ;D 
18:00:25 <pikajude> if you come into #haskell asking "why use haskell" you're going to get a terribly biased set of answers 
18:00:27 <qmm> not really sure how to represent n^3.333333333333333333 / 3! in haskell :)
18:00:29 <kgadek> where did you hear that Haskell is being replaced with Python?
18:00:38 <Zoybean> 3: in haskell, all function application is currying. Though you can implement currying in python, it is much more convenient and expressive in Haskell
18:00:58 <pikajude> use haskell if you like it and it fits your needs 
18:01:08 <pikajude> the runtime is efficient and the tooling is quite good
18:01:12 <confusedNoob> I didnt hear it, I just feel like most things I do in Haskell take me forever compared to in Python.  Seems like the learning curve is pretty steep
18:01:15 <pikajude> but it's not for everyone
18:01:50 <Koterpillar> confusedNoob: the other day I struggled to express a thing in Python that would have been way easier in Haskell
18:02:12 <kgadek> confusedNoob: ohhh, that
18:02:12 <kgadek> been there
18:02:12 <kgadek> had exactly same thoughts
18:02:12 <kgadek> (with OCaml, but it doesn't matter)
18:02:13 <kgadek> but then some bigger project happen and I've realized that Python needs *a lot* of attention
18:02:15 <Koterpillar> I'd like to think this means Haskell is replacing Python... in my brain
18:02:26 <kgadek> while Haskell scales easily ("easier") to big codebases
18:02:41 <CoconutCrab> confusedNoob: piping the result of one shell command to another takes much longer in python than in bash too. My point is that safety can only come with less.. convenience
18:02:59 <dunx> if you are not approaching haskell thinking functionally. if you program in haskell like you fo in python, it will not always turn out well
18:03:05 <CoconutCrab> the traffic light is there to keep you safe, but also an inconvenience
18:03:35 <pikajude> easily-er
18:03:49 <confusedNoob> True.  I am probably much more OOP than functional in my brain
18:03:51 <kgadek> confusedNoob: the "problem" with Haskell is that you need to DESIGN properly the program for it to even compile. In python you don't. So in writing really small programs, you will be probably quicker with Python (just a bit if you're comfy with Haskell. Which will come sooner or later)
18:04:28 <kgadek> anyway, it took me much longer to write quickly in OCaml/Haskell than I'd like to admit
18:04:36 <kgadek> I was completely ineffective for quite a bit of time
18:05:03 <qmm> like meeee
18:05:14 * qmm is kgadek from the past
18:05:35 <confusedNoob> Ineffective would be an upgrade for me, heh
18:05:52 <kgadek> confusedNoob: easy. this will come
18:05:57 <kgadek> you're changing a paradigm
18:06:13 <kgadek> this is not a change from Python to Ruby (i.e. mostly syntactical change)
18:06:17 <kgadek> this is big
18:06:24 <kgadek> give yourself some time
18:06:33 <kgadek> there will be some "A-HA" moments. More than one
18:07:03 <confusedNoob> pikajude: To be fair a biased answer on why Haskell is good would be a good balance to the 100's of biased answers against it I've seen all over 
18:07:03 <kgadek> if you ask me — it's totally worth it :) even if you'll never ever write Haskell again. Knowing Haskell will help you write better programs
18:07:24 <kgadek> (n.b. sapir-whorf )
18:08:05 <pikajude> most of the biased-against-haskell answers i see seem to be from jaded devs panning what they believe to be the next flavor of the month language
18:08:20 <pikajude> now, can't fault them for that
18:08:26 <pikajude> but it doesn't make haskell a bad language
18:08:49 <kgadek> one of my lecturers said: "[want to write REST server in] Haskell? is it even possible?!"
18:09:00 <kgadek> and this is what most people think about Hs
18:09:12 <pikajude> why yes, haskell does indeed support I/O
18:09:16 <kgadek> no shit :D
18:09:19 <sandonfuge> Haskell is great, I love it
18:09:45 <kgadek> pikajude: I had this snippet that I wrote to show-off Haskell then, gimme sec
18:09:53 <sandonfuge> I hate studying languages through a book though, do you guys know of any good youtube series or any internet course?
18:10:13 <sandonfuge> I want to learn more about Haskell
18:10:45 <kgadek> pikajude: got it. https://gist.github.com/kgadek/11380592
18:11:11 <kgadek> confusedNoob: take a look at it. there's python for comparison
18:11:31 <pikajude> indeed
18:11:32 <kgadek> fun story around this gist
18:11:42 <kgadek> my friends heard that I wrote Haskell server 
18:11:46 <kgadek> "OH? SHOW US!"
18:12:01 <kgadek> "ohh, so it looks like this?… *disappointment*"
18:12:05 <pikajude> heh, and you just use a library function from a web server package
18:12:10 <pikajude> that's funny
18:12:26 <kgadek> yes :D
18:12:27 <pikajude> "look! an IRC bot in one line!"
18:12:27 <sandonfuge> A college project that I got was to write a Haskell database
18:12:40 <Squarism> ok.. not a hard task. But i wonder if it can be done more efficient. Task : Find listOfKeys : [k] in myMap : Map k a, return Maybe (Map k a) - Just if all listOfKeys are found, othewise false
18:14:37 <pikajude> Squarism: forM listOfKeys (flip M.lookup myMap)
18:15:16 <kgadek> Squarism: I would probably create `newMap :: Map k ()` containing only keys, then use `difference newMap myMap` and check the size
18:15:34 <kgadek> if the implementation is good, then it could be quicker
18:15:43 <confusedNoob> Ok, so this relates to my earlier dumb question.  How do I place the binding in the function itself?  I have the header, obviously, but what is the syntax for binding a function to a name within that function.  I get how to do it when I am using it with the bars and otherwise, but this is stumping me
18:16:08 <kgadek> then — if all keys are there — use `intersectionWith snd newMap myMap`
18:16:26 <pikajude> confusedNoob: use where or let
18:16:30 <kgadek> and and `toList` on the result
18:16:34 <Squarism> pikajude, wow
18:16:51 <confusedNoob> pikajude: Where exactly.  I am sorry if this seems dense....
18:17:24 <Zoybean> sandonfuge: http://book.realworldhaskell.org/read/
18:17:32 <kgadek> confusedNoob: did you use any learning material? which?
18:17:43 <pikajude> Squarism: sorry, that returns a list of the values
18:17:53 <confusedNoob> I am reading, but I am missing the syntax for this particular case.
18:17:57 <pikajude> to get a map out of it the function will look significantly different
18:18:42 <sandonfuge> Zoybean: thank you
18:19:03 <kgadek> confusedNoob: ok, there may be some confusion. First question: in your function, do you use actions (i.e. do you use `do` keyword)? (I really don't want to use the word beginning with M here :P )
18:19:18 <kgadek> I assume that not
18:19:35 <kgadek> then, you can use `let a = … in …` as expression
18:19:55 <Zoybean> sandonfuge: I haven't read much into it, but I've heard it's pretty good. Don't know what level it goes to, but it starts pretty basic
18:20:00 <confusedNoob> Well, let me show you my current iteration of this.  which is embarassing at how wrong it is. 
18:20:03 <kgadek> `where` is somewhat similar, but is used in different place
18:20:09 <kgadek> confusedNoob: k
18:20:15 <confusedNoob> http://lpaste.net/352479
18:20:35 <kgadek> ohh, there is quite a lot of confusion here
18:20:37 <kgadek> no worries :)
18:21:06 <Squarism> kgadek, oh.. sounds  interresting too
18:21:17 <kgadek> > test3 = (foldr (\x y-> if x == True then y+1 else y) 0)
18:21:19 <lambdabot>  <hint>:1:7: error:
18:21:19 <lambdabot>      parse error on input ‘=’
18:21:19 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
18:21:25 <kgadek> oh yeah, lambdabot…
18:21:27 <kgadek> > let test3 = (foldr (\x y-> if x == True then y+1 else y) 0)
18:21:30 <lambdabot>  <no location info>: error:
18:21:30 <lambdabot>      not an expression: ‘let test3 = (foldr (\x y-> if x == True then y+1 els...
18:21:44 <sandonfuge> Zoybean: Good to hear, I'll certainly read it. 
18:22:48 <kgadek> confusedNoob: ehh, nvm lambdabot for now. Anyway. This is the syntax for you. The code is still not correct though
18:22:56 <Koterpillar> kgadek: try: > let test3 = ... in test3 1 2
18:23:07 <Koterpillar> kgadek: or whatever your arguments are
18:23:31 <ertes> qmm: yes, that's the formula my code snippet uses
18:23:35 <kgadek> Koterpillar: thanks :) hoped lambdabot could just verify the code
18:23:48 <kgadek> (ACK it or something)
18:23:54 <Koterpillar> > let test3 = (foldr (\x y-> if x == True then y+1 else y) 0) in undefined
18:23:57 <lambdabot>  *Exception: Prelude.undefined
18:24:01 <Koterpillar> it compiled
18:24:18 <kgadek> Koterpillar: this is the trick that I wouldn't dare to explain to confusedNoob now :)
18:24:27 <confusedNoob> lul
18:24:27 <ertes> qmm: you just wrote nsum instead of nSum
18:24:33 <Koterpillar> I think there actually was a command
18:24:38 <Koterpillar> :let test3 = "test3"
18:24:42 <Koterpillar> @let test3 = "test3"
18:24:45 <lambdabot>  Defined.
18:24:48 <Koterpillar> here you go
18:24:54 <kgadek> nice :)
18:24:57 <kgadek> anyway
18:25:42 <confusedNoob> So, stupid question, this is what you would write into GHCi as opposed into the function itself?
18:25:51 <kgadek> yes
18:25:56 <kgadek> GHCi accepts actions
18:25:58 <confusedNoob> I swear I am not this stupid, just at Haskell I guess lol
18:26:28 <kgadek> whenever you hear "monad", replace it with "action". This is all you need to know for now :)
18:26:46 <confusedNoob> How would i bind it within the function itself?  This paste thing is timing out, but I have the following binding working
18:27:10 <kgadek> > foldr (\x y-> if x == True then y+1 else y) 0 [True, True, False]
18:27:13 <lambdabot>  2
18:27:19 <kgadek> confusedNoob: see? your code works :)
18:27:28 <confusedNoob> splitListAt :: [a] -> Int -> ([a], [a]); splitListAt []_= ([], []); splitListAt front@(x : xs) n ;                     | n > 0 = (x : ys, zs) ;                    | otherwise = ([], front) ;                where (ys,zs) = splitListAt xs (n - 1);
18:27:48 <confusedNoob> I was able to bind within the function easily there
18:28:02 <confusedNoob> But I cant get this particular thing to bind and then be useable.  It'
18:28:39 <kgadek> ok, so first things first: `let test3 = foldr (\x y-> if x == True then y+1 else y)` is correct
18:28:49 <Koterpillar> confusedNoob: maybe use lpaste.net?
18:28:50 <confusedNoob> ok
18:28:55 <confusedNoob> It's timing out
18:29:00 <confusedNoob> Sorry, I was trying to
18:29:14 <kgadek> oh, you had 0 there as well. Add it, it'll be still correct
18:29:18 <kgadek> `let test3 = foldr (\x y-> if x == True then y+1 else y) 0`
18:29:38 <confusedNoob> There we go
18:29:39 <confusedNoob> http://lpaste.net/352481
18:29:53 <confusedNoob> That was a case where i was able to figure out how to bind.
18:30:16 <confusedNoob> In this case, I was just trying to get that return value as an integer to use
18:30:37 <Koterpillar> confusedNoob: I think this is an indentation problem
18:31:00 <kgadek> ohh, good point!
18:31:05 <Koterpillar> move 'where' under '|'
18:31:52 <kgadek> Koterpillar: but wait, this example works
18:32:11 <confusedNoob> That one works. 
18:32:15 <Koterpillar> oh... then what's an example where it doesn't?
18:32:30 <confusedNoob> My problem is I cant figure out how to bind that returned int to a value in the first one
18:32:45 <confusedNoob> Like lets say I was to arbitrarily want to return the value/2
18:32:52 <confusedNoob> or whatever
18:32:59 <Koterpillar> what "returned int"?
18:33:24 <kgadek> write `let test3 = foldr (\x y-> if x == True then y+1 else y) 0      in       test3 [True, False, True, True]`
18:33:41 <kgadek> the layout is `let … in …`
18:33:44 <monochrom> There is no "bind a value to a value". You can bind a value to a name.
18:35:33 <confusedNoob> I'll play with this for a bit, I am missing something big.
18:35:34 <confusedNoob> lol
18:35:37 <confusedNoob> Derp
18:36:41 <Zoybean> confusedNoob: you needn't put yourself down like that. There's a lot you'll struggle with when switching paradigms.
18:37:18 <kgadek> confusedNoob: you must unlearn what you have learned
18:38:10 <Zoybean> confusedNoob: I mean, you're working with an entirely new set of tools, and without a lot of the typical imperative tools you'd have used until now
18:39:10 <kgadek> ^ this
18:39:38 <confusedNoob> True
18:41:30 <confusedNoob> This http://lpaste.net/352483 is giving me "Variable not in scope: test3 :: [Bool]-> t
18:42:05 <confusedNoob> I am going to have to read fo rhours to figure this out I think
18:42:45 <Koterpillar> confusedNoob: test3 = let result = ... in result - 10
18:43:25 <Koterpillar> also, that expression is of type [Bool] -> Int, and you can't subtract 10 from it
18:43:47 <Koterpillar> so you'll want something like: test3 xs = let result = ... in result xs - 10
18:43:59 <monochrom> confusedNoob: Things are actually less mysterious if you put code in file rather than the REPL prompt.
18:44:18 <Zoybean> confusedNoob: I'd recommend to you, like I did to sandonfuge, this resource for a general intro to and reference for haskell: http://book.realworldhaskell.org/read/
18:44:29 <Dynasty> I'm having trouble getting uniplate to operate on template haskell types. Does anyone know how to get it working? The error I'm receiving is: No instance for (Biplate Dec Type) arising from a use of ‘transformBi’
18:45:02 <Edith> maybe I'm being dense but
18:45:08 <Dynasty> However both Dec and Type derive Data, which means that it should work
18:45:22 <Edith> why not just use test3 = (- 10) . foldr (\x y-> if x then y+1 else y) 0
18:45:35 <Dynasty> There is an instance (Data a, Data b, Uniplate b) => Biplate a b
18:46:21 <monochrom> But is "Uniplate Type" true?
18:46:29 <Edith> or just (- 10) . length . filter id
18:46:53 <Dynasty> monochrom there is an instance for Uniplate: Data a => Uniplate a
18:47:17 <Zoybean> Edith: why (-10)?
18:47:21 <monochrom> That looks strange, but OK.
18:47:55 <Zoybean> (also, because of unary negation, (-10) isn't a function. You probably want (+(-10)) )
18:48:20 <geekosaur> (subtract 10)
18:48:26 <Zoybean> ooh
18:48:40 <Zoybean> geekosaur: I hadn't heard of that one!
18:49:04 <Zoybean> geekosaur: That helps so much
18:49:14 <Dynasty> monochrome okay I figured it out. I just had to import Data.Generics.Uniplate.Data 
18:49:29 <monochrom> Ah
18:50:24 <kgadek> confusedNoob: how are you doing? :)
18:50:32 <confusedNoob> Working through it
18:51:07 <kgadek> cool :)
18:53:37 <jchia> is there a variant of the 'fix' function that stops when a predicate returns true?
18:54:38 <jchia> (a -> a) (a -> Bool) -> a -> a
18:55:04 <confusedNoob> Edith solution works, and is fairly close to where I started off.   But I am still lost on the " test3 = let result = ... in result - 10 " portion.  I don't believe I understand the syntax.  I cant get it to compile
18:55:43 <Koterpillar> > let x = 2 in x + 4
18:55:46 <lambdabot>  6
18:56:12 <Koterpillar> > let test3 y = let x = 2 in x + y in test3 5
18:56:14 <lambdabot>  7
18:56:18 <monochrom> confusedNoob: Are you still entering code directly at the REPL prompt?
18:56:35 <confusedNoob> Not sure what the REPL prompt is
18:56:43 <Zoybean> confusedNoob: this is equivalent to "test3 = result - 10 where result = ...", which may be easier to understand
18:56:44 <confusedNoob> I have been using Notepad++ and compileing through GHCi
18:57:03 <monochrom> Well, it's a simple dichotomy. If your code is not in a file then you're entering at the REPL prompt.
18:57:03 <confusedNoob> compiling**
18:57:12 <confusedNoob> Those examples do help some. 
18:57:57 <confusedNoob> Fair enough.  My code is in a file.  I used the prompt when I was just trying to understand folds and maps and such
18:58:22 <confusedNoob> Actually composing a function is the point, so I moved to Notepad++ quickly enough. 
18:59:54 <monochrom> It may be just some simple typo that caused an error.
19:01:08 <aluminumtubes> in the definition of == and /= in Eq class, is it imposing the law the excluded middle and overloading the == and /= operators for instances of Eq?
19:01:39 <aluminumtubes> and == and /= is defined internally or something?
19:01:49 <aluminumtubes> because it looked circular at first and i was confused
19:02:22 <monochrom> OK, suppose you write "instance Eq MyType where x == y = whatever"
19:02:45 <monochrom> Then when a user uses == on MyType, that instance code is used.
19:03:01 <excelsiora> Someone said they hated literate orgmode, any thoughts on that?
19:03:11 <confusedNoob> So in the example let x = 2 in x + 4
19:03:13 <monochrom> And when a user uses /=, the code you saw is used. But it calls == right? Which ==? MyType's ==.
19:03:20 <geekosaur> aluminumtubes, it is circular: you define one of them, the other is defined in terms of that. you define neither and you get a loop. :) (see also: ghc's MINIMAL pragma)
19:03:39 <confusedNoob> When you place that under, say, test5::Int , it works
19:04:02 <monochrom> In other words, instance code overrides default code, and you don't have to override everything.
19:04:11 <confusedNoob> But if you use test5 = let x = y in x + 4 under test5 :: Int->Int it does not compile
19:04:22 <confusedNoob> I think that is where my mental disconnect is
19:04:40 <monochrom> Your type signature is wrong. test5 :: Int
19:04:52 <monochrom> OTOH who is x?
19:05:00 <monochrom> No, who is y?
19:06:42 <aluminumtubes> oh i see
19:08:15 <confusedNoob> Then how do you define x y in the function, a different signature?
19:08:49 <monochrom> What do you want to define y to be?
19:09:22 <confusedNoob> The input, I suppose.  I am just trying to understand bindings on a basic level inside a function
19:09:44 <monochrom> test5 y = let x = y in x + 4
19:09:51 <monochrom> now this is Int -> Int.
19:11:25 <confusedNoob> That make way more sense now
19:11:31 <confusedNoob> One slow step at a time....
19:16:46 <NeverDie> What's a good prime checker in Haskell?
19:16:54 <NeverDie> Or the best one I could find?
19:17:34 <monochrom> http://hackage.haskell.org/packages/search?terms=prime  see if any of them you like
19:17:54 <monochrom> (And yes, I am too lazy to determine which one is best.)
19:18:02 <confusedNoob> Ok, I THINK I get it now
19:18:06 <NeverDie> I want one with the source code.
19:18:08 <confusedNoob> Why was this so confusing
19:18:11 <confusedNoob> hah
19:18:24 <monochrom> You know what hackage is right? All of them come with source code.
19:18:24 <confusedNoob> test6 y= let x = (test5 y) in x `mod` 2
19:18:42 <ezyang> clubbing :O 
19:19:13 <ezyang> mix 
19:19:24 <confusedNoob> Thank you for the help, btw.  
19:19:28 <monochrom> I would be surprised if a hackage package contains binary code only.
19:19:30 <confusedNoob> Wow, I was confused AF
19:21:19 <confusedNoob> Holy moly.  You guys rock.
19:21:27 <monochrom> thanks
19:21:41 <confusedNoob> Now that I get it, I am laughing looking at what I was trying
19:21:50 <confusedNoob> Like getting stuck on Hello World in Java
19:55:39 <pikajude> this is definitely a long shot, but has anyone seen or heard of a rofi script to browse haddocks
20:27:31 <Axman6> rofi?
20:34:42 <pikajude> it's like dmenu, but better
20:35:07 <Clint> it would be hard not to be
20:36:24 * Axman6 doesn't know what dmenue is
20:36:27 <Axman6> dmenu*
20:40:33 <geekosaur> text-based file / program / whatever menu
20:40:58 <Clint> it's a thing for when you don't have xmonad-contrib
20:41:06 <geekosaur> heh
20:42:19 <MP2E> hah :P
20:43:06 <atavistic> folks, small doubt with (.) function 
20:43:20 <atavistic> a = ( * 2 )
20:43:32 <atavistic> a.a $ 3 works
20:43:42 <atavistic> but a.a 3 gives error
20:43:51 <atavistic> whats the difference? 
20:43:52 <jle`> a.a 3 is a . (a 3)
20:44:01 <jle`> a.a $ 3 is (a . a) 3
20:44:19 <c_wraith> atavistic: function application has higher precedence than operators
20:44:30 <atavistic> ah!
20:44:34 <atavistic> thanks!
20:44:42 <atavistic> jle` and c_wraith
20:44:46 <jle`> np
20:50:15 <aluminumtubes> what's the operator precedence of <$> and <*>?
20:51:29 <jle`> aluminumtubes: you can check in ghci or the docs :)
20:51:43 <jle`> with :i
20:51:53 <jle`> http://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Applicative.html#v:-60--36--62-
20:52:10 <jle`> http://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Applicative.html#v:-60--42--62-
20:52:20 <aluminumtubes> thanks
20:55:18 <mmachenry> Is there an easy way to manage a directory of stack projects where every subdirectory has its own stack.yaml and .cabal file but from the parent I can run a command to build and test all?
20:55:39 <mmachenry> Would I need to write my own script for that or is there a recommended process for stack that orchestrates this?
20:56:43 <kadoban> You can have multiple projects in a package, I think is the right terms anyway, but I believe they all share the same stack.yaml
20:57:03 <kadoban> So you probably need your own script, fairly sure.
21:03:09 <mmachenry> Okay thanks.
21:03:34 <aluminumtubes> why do i need to put parenthesis around the (+2) for this to work ((+2) . (+2)) 3
21:03:46 <aluminumtubes> around the (+2) . (+2) i mean
21:04:03 <geekosaur> application is highest preceden ce
21:04:19 <geekosaur> it would be read as (+2) . ((+2) 3) otherwise
21:04:38 <aluminumtubes> oh
21:04:41 <aluminumtubes> but isn't . infix?
21:04:51 <aluminumtubes> so the parens would go around the (+2)?
21:04:57 <aluminumtubes> (+2)s
21:05:12 <geekosaur> you may be assuming that some kind of type directed resolution is going on
21:05:20 <aluminumtubes> oh my bad
21:05:24 <geekosaur> because otherwise I can't see how you'd get tjhat
21:05:37 <pikajude> (+2) . (+2) 3 is parsed as (.) (+2) ((+2) 3)
21:05:38 <aluminumtubes> when you said application i read it as composition
21:05:40 <pikajude> yes
21:05:58 <geekosaur> (also type based doesn't help since it's entirely possible to have a Num instance for functions, in which case both versions typecheck!)
21:06:21 <geekosaur> (...which is confusing as all heck...)
21:07:40 <aluminumtubes> oo
21:07:44 <aluminumtubes> thank you
21:11:17 <aluminumtubes> man the <*> operator is so cool
21:11:35 <Axman6> Applicatives are pretty badass
21:11:44 <aluminumtubes> how do you pronounce this thing?
21:11:49 <jle`> tie figher
21:11:55 <jle`> or 'ap'
21:12:03 <Axman6> anglebum
21:13:27 <aluminumtubes> ha other people asked the same thing on reddit
21:13:34 <aluminumtubes> why ap?
21:13:43 <Axman6> that's what it's called in Monad
21:13:47 <Axman6> :t ap
21:13:49 <lambdabot> Monad m => m (a -> b) -> m a -> m b
21:13:50 <jle`> it was originally called 'ap'
21:13:54 <jle`> before we thought of a cute operator for it
21:13:59 <Axman6> :t (<*>)
21:14:01 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
21:14:35 <Axman6> app is from a time before we knew about Applicatives. now ap is just a more constrained version of <*>
21:14:39 <Axman6> ap*
21:14:40 <jle`> the idea of an 'ap' as a useful concept pre-dates Applicative
21:15:07 <jle`> it was a concept that originated with monads, but then people realized that the "'ap' pattern" was useful for things that weren't monads, as well
21:15:21 <aluminumtubes> i see
21:15:23 <jle`> so they isolated out the design pattern and Applicative was born
21:15:36 <jle`> ~2008
21:16:18 <jle`> oh ap was called 'ap' because it's like function application
21:16:28 <jle`> f (a -> b) -> f a -> f b
21:16:46 <jle`>   (a -> b) ->   a ->   b
21:16:50 <jle`> :t (#)
21:16:53 <lambdabot> error: parse error on input ‘)’
21:16:55 <jle`> :t ($)
21:16:58 <lambdabot> (a -> b) -> a -> b
21:17:08 <jle`> 'ap' is function application "inside functors"
21:21:26 <jle`> @tell chrisdone looks like ircbrowse hasn't been logging anything for about a week?
21:21:27 <lambdabot> Consider it noted.
21:23:03 <zq> :t (.)
21:23:05 <lambdabot> (b -> c) -> (a -> b) -> a -> c
21:25:11 <Ford_Prefect> Hi folks. I'm trying to write a job queue of sorts on top of persistent + postgres
21:25:56 <Ford_Prefect> Does anybody know the right way to do this?
22:28:14 <piyush-kurur> Ford_Prefect: you might want to build a package for this. I do not remember seeing a package for this kind of stuff
22:29:08 <piyush-kurur> also you might not need such a queue (If you are looking for something like sending mails)
22:29:24 <piyush-kurur> you can use an async action for this
22:35:32 <runeks> What's the easiest way to sign something using any private key allowed by x509, to produce a signature? I've been looking at  https://hackage.haskell.org/package/x509-1.6.5/docs/Data-X509.html#v:objectToSignedExact
22:35:52 <runeks> but I'm not sure what the "signature function" is supposed to be, exactly. 
22:37:43 <piyush-kurur> runeks: how familiar are you with the X509 standard
22:37:45 <piyush-kurur> ?
22:38:07 <runeks> piyush-kurur: Not particularly. But I'm willing to learn.
22:38:46 <c_wraith> that package looks really low-level
22:38:59 <runeks> Yeah. Too many ByteStrings IMHO
22:39:26 <piyush-kurur> runeks: the signature function, from what I gather from the docs, is the function that takes the data and spits out the signed message and a discription of what algorithm is used (RSA+SHA1 or whatever)
22:39:35 <runeks> I was hoping there'd be something a bit higher level. Preferably something where I don't have to worrty about pub/privkey/signature type
22:40:11 <piyush-kurur> runeks: unfortunately X509 is a terrible standard (as is most IETF standards on cryptography)
22:40:30 <c_wraith> ByteString isn't low level.  It's just the only type that means "a sequence of bytes" with a good api.  the low-level part is the operations are all separated out into super-primitive parts
22:40:44 <runeks> piyush-kurur: Surely, it should be possible to abstract over pubkey types. I assume...
22:41:32 <runeks> Why not create a "newtype Message = Message ByteString" and "newtype Signature = Signature ByteString". Explains everything to the library user and prevents the library author from messing up.
22:41:33 <piyush-kurur> https://www.cs.auckland.ac.nz/~pgut001/pubs/x509guide.txt
22:44:23 <piyush-kurur> runeks: yes it should be possible to have better interface to signature but some of the standards like x509 is terrible (Please read the link above that I sent). It might look like the latest script of Monty Python but it is sadly the reality of crypto standards
22:44:38 <runeks> Thankfully I don't plan on implementing verification. Only signing. 
22:45:59 <runeks> piyush-kurur: I don't doubt that you're right. Looks a lot more complex than I had anticipated.
22:47:17 <piyush-kurur> runeks: if it is for a private application, by which I mean you control the consumer and producer of signature, you might be well of by using ed25519 signature. Most likely cryptonite would have an implementation of it.
22:48:01 <Ford_Prefect> piyush-kurur: this is a queue for long-running jobs -- they might need to be issued once, timeout if it's too long since an update, acknowledge when done, etc.
22:48:42 <piyush-kurur> Ford_Prefect: you might be better of with just using async calls. 
22:49:36 <piyush-kurur> https://hackage.haskell.org/package/async-2.1.1/docs/Control-Concurrent-Async.html
22:50:02 <runeks> piyush-kurur: I would totally use ed25519 if I could. The only reason I'm looking at x509 is because that's what the spec says. In fact, I'm using ed25519 for a different part of the application.
22:51:35 <runeks> It's SO fast
22:52:36 <piyush-kurur> X509 is a wrapper format for signatures, you need an actual Public key algorithm for signing. That is what the signature function does I guess
22:53:37 <piyush-kurur> There are fields in X509 that says what is the algorithm besides many other things. If you want to know more about it the x509 style guide has specific suggestion which is good to follow
22:54:47 <piyush-kurur> otherwise you might end up producing signatures that although correct will not be acceptable by clients
22:56:26 <piyush-kurur> runeks: Last time I wrote some make files for managing a simple CA, I realised that it is better to stick to RSA as some clients (typically web browsers) only understand RSA+some hash
22:56:55 <piyush-kurur> Also do not use RSA+sha1 if you can as sha1 is mostly broken, use RSA+SHA512 or some such thing
23:00:19 <runeks> I will be using SHA256 for hashing. And yeah, I should probably stick to RSA to begin with.
23:00:29 <ezyang> I'm always amazed at how awesome monads are 
23:01:04 <runeks> piyush-kurur: Do you have any code at hand that works for x509 with only RSA+SHA256?
23:02:03 <runeks> ezyang: Aren't there any terrible monads in existence?
23:02:55 <Ford_Prefect> piyush-kurur: maybe I'm misunderstanding -- would this make sense for a job queue where workers are on a different box?
23:04:51 <piyush-kurur> runeks: I have some make files that uses openssl command to manage some servers. I have used it in private and would not recommed it but you can have a look http://hub.darcs.net/ppk/make-ssl-server-ca and http://hub.darcs.net/ppk/make-ssl-server
23:05:35 <piyush-kurur> Ford_Prefect: In that case you might need a queuing framework like ZeroMQ or something. I believe bindings for it exists in Haskell
23:06:32 <Ford_Prefect> piyush-kurur: trying to hack this up on top off Postgres so I don't need to add another entity into the system (need a db anyway)
23:08:43 <piyush-kurur> Ford_Prefect: Are you looking for something like sidekiq in rails
23:09:11 <piyush-kurur> I do not think such a library exists but should not be difficult to write one.
23:09:22 <Ford_Prefect> piyush-kurur: I am indeed
23:09:44 <Ford_Prefect> piyush-kurur: er, actually not necessarily, because I want this to work off pg
23:10:27 <piyush-kurur> Ford_Prefect: you are using persistent layer are you not?
23:10:38 <Ford_Prefect> piyush-kurur: it's probably easier to write this on top of rabbitmq, but that means adding a message queue to orchestration
23:10:50 <Ford_Prefect> piyush-kurur: yup, I am using persistent
23:11:26 <piyush-kurur> then just create a model for the queue object and have a process that reads object of that type and dispatches the job
23:11:48 <Ford_Prefect> Sure, on the consumer side that's doable
23:12:07 <piyush-kurur> Your main can do a forkOS to run the consumer
23:12:27 <Ford_Prefect> So I was planning on having the queue management exist on a single service
23:12:39 <piyush-kurur> Okey I get it
23:12:41 <Ford_Prefect> It receives and enqueues, and also provides an API to dequeue/update status/complete
23:12:48 <piyush-kurur> you want the consumer to be some where else
23:12:51 <Ford_Prefect> Right
23:13:27 <piyush-kurur> Ford_Prefect: that is precisely the thing where queing framework shines
23:13:49 <Ford_Prefect> Agreed,just trying
23:14:03 <Ford_Prefect> to minimise the number of services needed to get the system up and running
23:14:03 <piyush-kurur> Even with the persistance design you can run it on a different machine
23:15:19 <piyush-kurur> By the way have you tried ZeroMQ. It is considerably simpler than RabbitMQ and might be what you are looking for
23:15:32 <piyush-kurur> I am not sure of the haskell binding though
23:16:00 <piyush-kurur> ZeroMQ does not need any central server.
23:16:37 <piyush-kurur> The 0mq page does say about the haskell binding but I am not sure of the quality
23:19:07 <piyush-kurur> Ford_Prefect: Does sidekiq support the kind of stuff that you are thinking about
23:19:12 <piyush-kurur> I do not think so
23:22:33 <Ford_Prefect> piyush-kurur: I looked at zeromq briefly, but not sure this works for what I want (viz. a persistent job queue) -- the transport itself is less of an issue
23:23:17 <piyush-kurur> Ford_Prefect: you can use persistent based design
23:24:03 <piyush-kurur> In the repository have two executables one for the webserver and one for the worker
23:24:48 <piyush-kurur> Your cabal package will have two executables 
23:25:06 <Ford_Prefect> Hmm, I see -- so just do the dequeue on the client via the database
23:25:13 <piyush-kurur> Yes 
23:25:38 <piyush-kurur> You might need some way to transfer status
23:26:27 <Ford_Prefect> The queue incorporates the job state from queued, in-progress { percent }, to complete
23:26:44 <Ford_Prefect> So that table could just be the mechanism by which this is communicated
23:27:15 <piyush-kurur> Yes the table is where the pay load lies but queue is for communication
23:27:17 <Ford_Prefect> (I'd still need to solve all the same problems single issue though
23:27:30 <Ford_Prefect> (there'll be two tables now, one for the payload, one for the queue)
23:27:50 <jvliwanag> guys, i'm looking for something that defines the ff:  m a -> m b -> (c -> (a, b)) -> m c .  Anyone have an idea?
23:28:28 <dramforever> :t liftA2
23:28:30 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
23:28:38 <piyush-kurur> Ford_Prefect: who will clean up the queue when things are done. Or do you want to preserve all the status messages
23:28:47 <fvh> hi folks! I have servant with servant-swagger module that generates properly docs, but I can't find a way to add function description for swagger. Any tips on how to do this?
23:28:52 <dramforever> jvliwanag: You sure not (a -> b -> c)?
23:29:21 <dramforever> '(c -> (a, b))' looks reversed
23:29:31 <jvliwanag> dramforever, yeah. i need it as c -> (a, b)
23:29:47 <dramforever> Then what's m?
23:29:49 <lyxia> jvliwanag: monoidal+contravariant
23:30:24 <dramforever> 'm' looks suspiciously like 'Monad'
23:30:31 <dramforever> but then it's reversed...
23:30:41 <lyxia> invertible has a Monoidal but it has an invariant Functor superclass.
23:31:15 <jvliwanag> hehe, sorry. still new with haskell, not sure what variable to use besides 'm' :)
23:31:37 <dramforever> jvliwanag: Okay can you tell what it does in English?
23:32:06 <Ford_Prefect> piyush-kurur: might be OT to talk about the overall service' design here, so going off channel
23:32:52 <jvliwanag> data Foo a e = Foo [String] (a -> e)
23:33:19 <dramforever> And?
23:35:11 <jvliwanag> given say Foo Int Bool and a Foo String Bool, and a function that defines (Double) -> (Int String). I want it to emit a Foo Double Bool
23:37:28 <EvanR> Int String isnt well kinded
23:38:16 <dramforever> I think it should have been (Int, String)
23:38:26 <jvliwanag> oh right. typo
23:38:27 <dramforever> lyxia: You were right
23:39:33 <dramforever> This is a thing: https://hackage.haskell.org/package/contravariant-1.2/docs/Data-Functor-Contravariant-Divisible.html
23:39:52 <dramforever> But it looks overly overwhelming
23:40:32 <jvliwanag> oooh
23:40:34 <dramforever> jvliwanag: No it doesn't. It's exactly what you need
23:40:47 <dramforever> It's exactly what you need
23:42:59 <jvliwanag> hmm. Is there a divisible though without a the 'conquer' part? I don't think I can define one for the Foo type I gave
23:43:13 <dramforever> You should be able to
23:43:28 <dramforever> Firstly, I'd like to point out that your Foo seems reversed
23:43:48 <dramforever> Should have been 'data Foo e a = Foo [String] (a -> e)' right? With 'a' as the last argument
23:44:06 <dramforever> Then 'Foo e' could be Divisible
23:45:10 <dramforever> jvliwanag: Then, create an instance of this: https://hackage.haskell.org/package/contravariant-1.2/docs/Data-Functor-Contravariant.html#t:Contravariant
23:45:32 <jvliwanag> ahh right. It should've been Foo e a
23:45:34 <dramforever> Exercise: define contramap yourself
23:45:51 <dramforever> Now let's consider divide
23:47:46 <jvliwanag> right. contramap is just basic contramap for the function
23:47:59 <dramforever> Yes!
23:48:06 <dramforever> But how are you dividing?
23:48:34 <dramforever> The [String] part is easy to combine
23:50:02 <jvliwanag> divide, I get. :) but having trouble imagining the 'conquer' part of it. conquer :: f a
23:50:08 <jvliwanag> or... is it just the constant function? hehe
23:53:08 <dramforever> jvliwanag: Wait don't go so quick
23:53:31 <dramforever> how do you combine then (b -> e) and (c -> e) part?
23:53:33 <dramforever> That's nontrivial
23:53:40 <dramforever> s/then/the
23:53:54 <dramforever> In fact that should tell you how to define conquer
23:54:33 <dramforever> jvliwanag: still there?
23:54:54 <jvliwanag> yup! thanks dramforever for your patience with this. typing it out. hehe. :)
23:55:02 <dramforever> :)
23:56:25 <dramforever> Just, in case I have to go in a while, a hint:
23:56:31 <dramforever> Monoid
23:57:16 <jvliwanag> hmm. does that imply that I can define a Divisible for Foo as long as e has a Monoid instancE? :)
23:57:28 <dramforever> :)
23:57:31 <dramforever> Write that out
23:57:32 <dramforever> you win!
23:58:07 <dramforever> Check this out: http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Monoid.html#t:All
23:58:22 <dramforever> And also 'Any' just below it
23:58:27 <dramforever> You are very good at these :)
