00:00:33 <Xnuk> @hoogle (\k -> k1) -> HashMap k v -> HashMap k1 v
00:00:35 <lambdabot> package base
00:00:35 <lambdabot> package bytestring
00:00:35 <lambdabot> package containers
00:00:41 <Xnuk> @hoogle (k -> k1) -> HashMap k v -> HashMap k1 v
00:00:42 <lambdabot> Data.HashMap.Lazy map :: (v1 -> v2) -> HashMap k v1 -> HashMap k v2
00:00:42 <lambdabot> Data.HashMap.Strict map :: (v1 -> v2) -> HashMap k v1 -> HashMap k v2
00:00:42 <lambdabot> Data.HashMap.Lazy mapWithKey :: (k -> v1 -> v2) -> HashMap k v1 -> HashMap k v2
00:01:08 <wz1000> jle`: it isn possible to construct a term of Pierce or 
00:01:20 <wz1000> LEM
00:01:28 <wz1000> s/isn/isn't
00:02:26 <jle`> wz1000: yes, not in haskell
00:02:49 <jle`> that was the point, right?
00:03:16 <jle`> that's how you'd represent pierce's law or LEM in haskell's type system, but they aren't inhabited in haskell
00:03:27 <jle`> well, aside from bottom
00:05:24 <jle`> their equivalence means that if you have a value of one type, you can get a value of the other
00:08:48 <Lokathor> so i have an RNG
00:08:59 <Lokathor> and i want it to support the RandGen typeclass I guess
00:09:14 <Lokathor> but only if the random package is being compiled into the whole deal
00:09:17 <Lokathor> can the CPP do this for me?
00:19:40 <jle`> why not just have random be a dependency
00:29:37 <Lokathor> jle`, well if you don't want to pull in random, the module should keep on working
00:29:56 <hololeap> can someone give me a concise definition of what a monad transformer is?
00:30:45 <Lokathor> hololeap, a monad transformer is a type that adds the effects that are characteristic of one type to a monad of another type. For example, MaybeT adds possibly not having a value to some other type such as IO
00:31:23 <Lokathor> open question, https://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Int.html#Int32 this seems to imply that Int32 uses up a full machine word of space no matter what? or do GHC intrinsics replace this definition in actual programs?
00:31:47 <hololeap> Lokathor: can you give me a rough explaination of how this is accomplished?
00:32:40 <Lokathor> hololeap, the secret is that you can compose the lower forms of the Functor/Applicative/Monad scale, but for Monads you can only compose them if you know at least one of the two monads being composed
00:33:13 <Lokathor> so MaybeT adds special logic that's particular to the "Mabyness" of the situation, and leaves the rest of the logic to the monad being composed with
00:33:31 <hololeap> ok
00:33:52 <Lokathor> and StateT needs its own totally seperate definition that's particular to "having a state"
00:33:55 <Lokathor> and EitherT and so on
00:34:25 <hololeap> Lokathor: ty. that is really helpful. is Control.Monad.ST the same thing as StateT? i can't find StateT
00:34:39 <Lokathor> ST is absolutely not the same as StateT
00:34:48 <phadej> StateT is in transformers
00:35:08 <xf000> Is there a way to convert this to binary in haskell: http://pastebin.com/2fuwRz9t
00:35:19 <xf000> so ONE = 1 ZERO = 0
00:35:21 <phadej> hololeap: if you want to get dirty, try to write `instance (Monad m, Monad n) => Monad (Compose m n) where ...`
00:35:41 <phadej> then you'll see why transformers exist
00:35:54 <Lokathor> hololeap, https://hackage.haskell.org/package/transformers-0.5.2.0/docs/Control-Monad-Trans-State-Lazy.html
00:36:33 <hololeap> Lokathor: what is ST, because it has conversions to IO, which is what i am looking for. i want to perform IO using state, and create state using IO, iterating over each line from STDIN
00:37:06 <Lokathor> hololeap, ST is a special type that's (in some sense) like a restricted form of IO that doesn't interact with the world. You get the speed boost of destructive mutability, but it's kept closed in and away from outside computations
00:37:27 <hololeap> ok, so pretty specialized then
00:37:35 <Lokathor> if you want to use IO for lines with StdIn, you should look into an IORef
00:37:37 <Lokathor> https://hackage.haskell.org/package/base-4.6.0.1/docs/Data-IORef.html#t:IORef
00:38:31 <Lokathor> hololeap, yes, ST is for when you want to do things like, say, high speed vector transformations in a non-IO context
00:39:07 <hololeap> its essentially a card-counting program that takes in a card suit/number and then displays the current percentage of the next card meeting criteria. it displays this output after each line but needs to keep a record of each previous card to compute the statistics
00:39:28 <Lokathor> ah, you don't even need an IORef for that, really
00:39:43 <Lokathor> you can just pass the cards to the next iteration each time you loop
00:39:51 <xf000> Anyone?
00:39:54 <hololeap> it's not that i *need* it, but looking at my code, i realize i am looking to compose two different monads
00:40:16 <hololeap> and i'm looking for a more general way to do this
00:40:24 <Lokathor> xf000, this seems like a job for a text editor
00:40:40 <hololeap> i can post my code if that helps
00:40:41 <xf000> xf000: That would take a while
00:40:46 <hololeap> it's only 100 lines or so
00:41:32 <Lokathor> xf000, http://pastebin.com/VguTRNsY ?
00:41:44 <laz> hololeap: looks like you need StateT state IO 
00:41:47 <Lokathor> hololeap, yes make an lpaste
00:42:05 <xf000> Lokathor: Howd you do that?
00:42:19 <Lokathor> xf000, just search and replace
00:42:37 <hololeap> it's a gist: https://gist.github.com/hololeap/6c75526bcb29a3dae975ce0460724780
00:43:35 <hololeap> the function printAll at line 99 is recursive, but i feel it could be genericized further
00:48:00 <spatial> Haskell spock is the UI framework for beginners ? I use spacemacs. Any tutorial to get started.
00:49:55 <liste> spatial: scotty is an easier web framework for beginners than Spock
00:50:31 <liste> spatial: http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html
00:50:39 <molina> i have a bunch of functions that look the same....
00:50:45 <molina> what should I do
00:50:48 <liste> spatial: though that's a somewhat old tutorial
00:50:56 <spatial> Have some experience with OCaml.
00:51:03 <molina> i could generalize them into one function but Idk
00:51:12 <liste> spatial: this is more modern: https://seanhess.github.io/2015/08/19/practical-haskell-json-api.html
00:51:45 <liste> molina: what kind of functions?
00:52:15 <spatial> You mean Spock and Servant are for advanced users ?
00:52:24 <liste> spatial: yes, compared to Scotty
00:52:40 <liste> scotty doesn't use advanced type system concepts, like type families
00:53:12 <molina> functions that calculate the volatility of a time series and returns various aspects of the time series, like dates when the volatility is high, or the next data after a high volatility event. etc
00:53:33 <spatial> Intention is to use TensorFlow bindings with UI.
00:53:52 <molina> for speed of implementation i just modified one function into many now I have a bunch of similar looking functions.
00:54:08 <spatial> To start with Machine Learning projects using Haskell.
00:54:55 <liste> molina: do those have a common "shell", with one specific functionality different?
00:55:27 <liste> molina: you could extract the "shell" into one function, and pass the specifics as function arguments
00:56:00 <molina> yeah
00:56:11 <Xnuk> Can I increse indentation size when I encode data to YAML?
00:57:53 <Xnuk> I cannot find how to adjust indentation using Data.Yaml
00:59:08 <liste> > let f1 x = show ((read x :: Int) + 1); f2 x = show ((read x :: Int) * 2); f g x = show (g (read x :: Int)) in (f1 "5", f2 "5", f (+1) "5", f (*2) "5") -- molina like this
00:59:11 <lambdabot>  ("6","10","6","10")
01:13:12 <slack1256> how is `fmap Sum [1,2,3]` guarranted to be a no cost operation?
01:15:47 <quchen> It’s not
01:16:07 <slack1256> at least will the cost be just the traversing of the list?
01:16:24 <quchen> Yes, that’s true
01:16:57 <slack1256> nice, I guess that for all other cases Data.Coercible is the right answer
01:17:39 <quchen> Right, »coerce [1::Int,2,3] :: [Sum Int]« is a no cost operation.
01:20:09 <slack1256> thanks for clarifying!
01:37:04 <quchen> For the record, I don’t think Haskell demands newtypes to be free, but it leaves the option open to implement them that way
01:37:43 <quchen> It requires newtypes to be unlifted, i.e. »Newtype ⊥ = ⊥«, but that’s about it
01:38:01 <quchen> Plus some pattern matching rules
01:45:54 <nhooyr> in yesod, does the development server automatically refresh the page in the browser when a file is changed? like say I edit some html file, template, or whatever, is the page itself reloaded in the browser?
01:55:16 <tfc> hi there. i am going to implement some kind of config file support for my haskell app. i have seen that there are multiple libraries. can someone tell me which library seems to be the most dependable regarding stability, usability and futureproofness?
01:57:01 <simli> I have a typeclass TypedMessage a where messageType :: a -> MessageType. All instances define this as messageType _ = SomeKindOfMessage. Is there some way I can call this without having an instance of a?
01:58:17 <simli> I'd like to make a function which does not need to know the constructors of a but still can get this information, it's part of a serialization thing
02:00:03 <simli> nhooyr: it's been a while, but I think not. However, if you access the page before the dev server is ready, I think it does, like you get a page saying drink some water, breathe, etc while waiting
02:01:01 <quchen> simli: We usually use Proxy for that
02:01:17 <quchen> class TypedMessage a where messageType :: Proxy a -> MessageType
02:01:28 <quchen> messageType _ = SomeKindOfMessage
02:01:55 <quchen> You can create a »Proxy a« for any »a«
02:02:21 <nhooyr> simli: ah, so only the first time, when you first start the dev server does it reload. otherwise nope?
02:02:24 <quchen> Use e.g. as »messageType (Proxy :: Proxy Foobar)« to get the message type associated to »Foobar«.
02:02:41 <jophish> tfc: What I do is just use yaml
02:02:51 <jophish> and derice FromJSON to get a parser
02:02:54 <jophish> derive*
02:03:18 <tfc> jophish: that one: https://hackage.haskell.org/package/yaml-0.8.21.2 ?
02:03:31 <jophish> tfc: yeah, I'll post an example of my code
02:03:41 <tfc> jophish: oh an example would be great.
02:04:14 <jophish> tfc: It's probably a little more complicated than it needs to be
02:04:40 <tfc> jophish: no problem, any help is great.
02:04:47 <simli> nhooyr: I think so, yes
02:04:57 <danza> i love Haskell because in order to improve my program i need to study for 10 minutes what an applicative is, then i change two lines of code and everything works as expected <3 <3 <3
02:04:59 <nhooyr> simli: cool thanks :D
02:05:57 <simli> quchen: I'll read up on that, thanks :)
02:06:46 <jophish> Here is the 'Config' type: https://github.com/hercules-ci/hercules/blob/master/backend/src/Hercules/Config.hs The strange FromJSON code is to strip 'config' from the beginning of each field (this can do exactly that job and I should switch over https://hackage.haskell.org/package/aeson-casing-0.1.0.5/docs/Data-Aeson-Casing.html). Here is the config file https://github.com/hercules-ci/hercules/blob/master/
02:06:52 <jophish> backend/example-config.yaml And here is a command line parser https://github.com/hercules-ci/hercules/blob/master/backend/app/Main.hs
02:07:15 <jophish> tfc: The command line parser takes either '-c YAML' and loads the config from a yaml description, or takes all the options on the command line
02:07:49 <tfc> jophish: cool thx. btw the https://github.com/hercules-ci/hercules/blob/master/ link does not work
02:08:15 <jophish> tfc: It got split between two messages on IRC
02:08:25 <jophish> tfc: this might be the interesting part for you https://github.com/hercules-ci/hercules/blob/master/backend/app/Main.hs#L25-L27
02:08:32 <tfc> ah yes i see the split, oops. :D 
02:08:35 <jophish> This takes a filename and parses it as yaml into a 'Config'
02:09:21 <tfc> ok, i will back down in my coding chamber and study your code. i hope it does not disturb you if i come back with questions later.
02:09:35 <jophish> sure, I'll answer if I'm around
02:09:40 <tfc> cool thx
02:22:33 <ph88> hello
02:23:40 <jophish> tdammers: is casing on github?
02:24:50 <ocharles> Hmm, this question raises a good point (https://stackoverflow.com/questions/42016605/haskell-implement-unix-touch-command): "The documentation for openFile states that: If the file does not exist and it is opened for output, it should be created as a new file."
02:25:08 <ph88> could anyone explain me this "could not deduce" error ?  https://paste.fedoraproject.org/544464/86117456/
02:25:19 <ocharles> Yet the documentation for openFile *also* states: This operation may fail with: ..., isDoesNotExistError if the file does not exist;"
02:25:23 <ph88> hi ocharles 
02:25:25 <ocharles> So... which is it `base`~?
02:25:26 <ocharles> !?
02:25:27 <ocharles> :)
02:25:29 <ocharles> Hi ph88 
02:25:36 <ph88> i got the generic stuff working :)
02:25:55 <ocharles> Oh, I guess the documentation isn't conflicting, because it only creates the file if you try open it for output, but won't be created for input.
02:25:57 <ocharles> Duh
02:26:00 <ocharles> ph88: fantastic! Can I see?
02:26:04 <ph88> yes sure
02:26:35 <ph88> ocharles, https://paste.fedoraproject.org/544468/48611756/
02:27:26 <ph88> in the end i needed to make more instances like on line 56 and 57 all the way up to a 6-tuple
02:29:58 <ocharles> Cool, glad it worked out :)
02:31:25 <ph88> :)
02:36:46 <ph88> ocharles, now that you're here, do you know perhaps why i get that could not deduce error ?
02:37:41 <ocharles> Well, you wrote "trace ("DecimalLiteral return " ++ d1 ++ dz ++ ex) (d1 ++ dz ++ ex)" - that second argument is a list, no?
02:38:01 <ocharles> trace :: Decorator [] => String -> [a] -> [a], but there is no Decorator [] instance in your paste
02:39:50 <simli> quchen: Proxy seems spot on with what I want to do, but I get inference errors if I try to use a type parameter from the function signature. like messageType (Proxy :: Proxy a) where a is constrained to TypedMessage a
02:40:01 <ph88> ocharles, that second argument is a list of Char, since d1 and dz and ex are of type String
02:40:33 <ocharles> ph88: ok, but how does that change anything? It's still a list, and there is no instance for lists, regardless of what they are lists of
02:40:49 <ocharles> ph88: put it another way, which instance do you think you have provided that is sufficient that GHC shouldn't complain?
02:40:50 <simli> is this not possible, or am I missing something else? ghc claims the type is ambigous between all the instances of TypedMessage
02:41:17 <ocharles> simli: can you share any code? (Please use a pastebin)
02:42:00 <ph88> ocharles, ah i am in the list monad, but why? i expect to be either in the Parser or in the Gen monad
02:42:43 <ph88> not that i have solid base for that expectation, but i'm still surprised that it isn't so
02:43:15 <ocharles> ph88: that let binding still uses [Char] as its second argument, that is the source of your problem
02:44:08 <ocharles> Maybe you want to trace (...) (return (d1 ++ dz ++ ex) :: Parser String) or something
02:44:29 <ocharles> But then you try and pack the result, which means it has to be a string, so that next line isn't going to type check
02:44:37 <ph88> hmmz
02:45:36 <ph88> the point is that i was adding "P: " or "A: " to the trace message so that i could see if the function was used by 1 monad or the other .. but now in the return i loose this monad information because now i'm in the list monad ..
02:45:54 <ph88> yes you're right this is not gonna type check and work
02:46:15 <ph88> ah maybe i could write    trace blabla $ return blabla
02:46:48 <ocharles> that return will need a type signature, because it's ambiguous which Monad's return you would be using
02:46:58 <lpaste> simli pasted “Proxy confusion” at http://lpaste.net/352039
02:47:00 <ocharles> `trace blablah` doesn't give you enough information to know what `f` should be
02:47:03 <simli> ocharles: ^
02:47:40 <ph88> yes i got it, this type checked:    trace ("DecimalLiteral return " ++ d1 ++ dz ++ ex) $ return $ T.pack $ (d1 ++ dz ++ ex)
02:47:46 <ocharles> simli: I think you need {-# LANGUAGE ScopedTypeVariables #-}, then change line 32 of your paste to: sourceMessage :: forall a m. (MonadThrow m, Encode a, TypedMessage a) => a -> Producer m BS.ByteString
02:48:00 <ph88> thanks for thinking along ocharles  :)
02:48:40 <simli> ocharles: oh my, haskell is heavy on the type theory :P
02:49:10 <ocharles> simli: without that extension, the 'a' type variable in "Proxy :: Proxy a" is not necessarily the same as the one in the type signature to sourceMessage.
02:50:10 <simli> ocharles: so the extensions basically give types a scope where they normally don't have one at all? (except for the signature itself)
02:50:18 <simli> *extension
02:50:23 <ocharles> yep, I'd say that sounds right
02:51:02 <ocharles> It's a shame that Data.Proxy doesn't have  `proxyFor :: a -> Proxy a`, because then you could use `proxyFor message` (because that *does* have the type 'a' that you want)
02:52:02 <ph88> when making a parser and choosing from 2 different parsers   parserA <|> parserB   i see often that try is used like     try parserA <|> try parserB    is there some situation where you want to choose but NOT use try for each parser ?
02:52:44 <ocharles> When they don't share a common prefix
02:52:46 <simli> ocharles: I would have run into this either way since what I really want is to validate the messageType field in sinkMessage, where no instance is available :)
02:53:10 <ph88> ocharles, ah ok good point !
02:53:32 <ocharles> simli: Ah, right.
02:53:50 <simli> ocharles: the forall a m. part was what was missing btw, already had ScopedTypeVariables. 
02:54:00 <ocharles> 👍
02:54:09 <simli> thanks for the help!
02:54:15 * ski thinks `ScopedTypeVariables' is counterintuitive, in this way
02:57:34 <jophish> ski: yeah :|
03:01:13 <roxxik> ocharles: that's trivial to write yourself: proxyFor :: a -> Proxy a; proxyFor _ = Proxy, just from the top of my head, but i think it should work, and i wrote this one in several project already... so yeah it would be nice to have that in Data.Proxy
03:01:41 <ocharles> Yes, that's the implementation, just surprised Data.Proxy doesn't have it
03:03:00 <tdammers> jophish: bitbucket. https://bitbucket.org/tdammers/casing
03:18:30 <jophish> gotcha, thanks tdammers 
03:34:03 <noan_> WHELP, back to basics for me I think
03:34:03 <noan_> https://gist.github.com/AlexaDeWit/ec8ccc64255625d77a99dae6e533de0d
03:38:10 <merijn> noan_: tbh, starting at line 1 that's already leaving beginner territory :p
03:38:28 <noan_> that's just ripped out of the servant docs
03:38:37 <noan_> I understand basically nothing about these combinators.
03:38:49 <noan_> And I'm pretty hazy on haskell evaluation order too
03:39:02 <noan_> infix operators get my brain all fucky.
03:39:42 <merijn> noan_: Yeah, don't feel bad, because DataKinds and TypeOperator are extensions that really don't make things easy if you're not already fairly comfortable with the basics
03:40:05 <phadej> 's Post
03:40:07 <phadej> not POST
03:40:11 <phadej> It's*
03:40:57 <phadej> http://hackage.haskell.org/package/servant-0.10/docs/Servant-API-Verbs.html#t:Post
03:41:15 <phadej> there is POST as well, but it's used in different place..
03:42:29 <noan_> mother of fuck
03:42:44 <noan_> >no issues
03:42:50 <noan_> phadej, IT IS ALWAYS A GODDAMN TYPO
03:42:52 <noan_> :D
03:45:18 <noan_> That's a hard one for me to spot, owing to the actual request on the browser being POST
03:45:31 <Theophane> < noan_> phadej, IT IS ALWAYS A GODDAMN TYPO // story of my life
03:45:34 <noan_> er, from the browser*. Thus it looks right.
03:47:28 <noan_> I was trying to find a t-shirt where it's the process of figuring out things and in the middle there's "what am I doing with my life" and at the end "oh it's a typo". Couldn't find it. Found this though.
03:47:29 <noan_> https://s-media-cache-ak0.pinimg.com/736x/8e/13/ed/8e13ed343e62203e988de2ef6e6a59fe.jpg
03:48:02 <noan_> I have gone through this process at my old job SO MANY TIMES. One thing was owing to weird behaviour on chrome, so for everyone else it worked fine, but I developped on firefox so it didn't.
03:48:05 <noan_> But I'd seen it work
03:48:19 <noan_> There was another stage on the process... "oh... it never worked."
03:51:24 <Theophane> noan_: I feel ya >_>
03:54:13 <noan_> and then I was looking at shirts instead of working... heh. "alias yolo=git push --force". Brace yourself repo. we're going in dry.
03:54:19 <markus3> hi! Is it possible to pass custom flags to stack repl
03:54:33 <markus3> i.e the custom flags you define yourself in the cabal file
03:55:19 <merijn> markus3: What are these flags doing that you need to control them?
03:55:54 <markus3> I have another main which uses the rapid package
03:55:59 <markus3> merijn: 
03:57:11 <Theophane> noan_: in the [alias] section of your ~/.gitconfig
03:57:13 <Theophane> yolo = !git commit -m \"$(curl -s whatthecommit.com/index.txt)\"
03:57:16 <Theophane> :) :) :)
03:57:48 <noan_> Theophane, you sir... are a special kind of evil.
03:58:01 <Theophane> nah I'm just French
03:58:24 <noan_> C'est la meme n'est-ce pas?
03:58:31 <Theophane> ouais :>
03:58:40 <noan_> I have no idea how to type the reflexive accent on this keyboard.
03:58:49 <noan_> Swedish sorcery.
03:59:08 <noan_> also.. ouais. french canadian?
03:59:12 <noan_> or is that pan-french?
03:59:32 <Theophane> nah, everyone says that
04:00:26 <Theophane> Québecois have their special slang, and I find it awesome ^^
04:04:37 <merijn> bleh, don't you hate it when two really similar things refuse to simply generalise into a single generic version without duplicating code? :\
04:05:45 <ocharles> merijn: no, because it teaches me something fundamental that I missed :)
04:06:14 <merijn> ocharles: In what way?
04:06:43 <ocharles> Well, if you had the assumption that two things could be simplified into one, that there is something you didn't know about the data. That thing is stopping you simplifying, so it's taught you something
04:06:56 <ocharles> Now you can go looking and see if that something is essential or accidental, and maybe it can be moved somewhere else
04:07:06 <ocharles> I can only hand wave not knowing anything more about your problem
04:08:22 <merijn> ocharles: I'm submitting some patches to xml-conduit to fix some gaps in the API, my desired functionality is really similar to the existing combinators, but not so much that I can easily turn them into a generalised version that can do both, and I hate duplicating code
04:17:22 <Mamemaki> What do people think of Netwire vs Reactive-Banana for FRP?
04:17:53 <Mamemaki> I'm learning Netwire now, it's pretty tough
04:25:06 <liste> Mamemaki: I have good experiences with reactive-banana, have tried netwire a bit but it didn't seem appropriate for my use case (updating UI based on user input)
04:25:56 <liste> Mamemaki: netwire is pull-only, reactive-banana is push-pull
04:26:29 <Arguggi> anyone know if anything haskell related is happening at FOSDEM this weekend?
04:26:46 <Mamemaki> liste: What does that mean? I've seen in mentioned before
04:27:48 <liste> Mamemaki: http://stackoverflow.com/q/26164135
04:28:11 <sm> Mamemaki: see also yesterday's discussion by ertes in channel log
04:41:39 <Mamemaki> liste: So I read the chat logs from yesterday. Interesting disucssion. What I've gathered is that Netwire is best for realtime simulations and games, but the arrow notation is awkward. Is this the main takeaway?
04:43:38 <ocharles> Mamemaki: I love reactive-banana and have done realtime stuff with it
04:43:41 <Mamemaki> liste: People seem to say good things about Reactive-banana, but mainly for GUI type work. Is it worth trying to use it if I want to make a simulation/game, or should I stick with Netwire
04:44:56 <ocharles> https://www.youtube.com/watch?v=RDSbOPWGDGU & https://www.youtube.com/watch?v=FPt5f-bl9o8 are both using r-b (both for GTK and OpenGL)
04:45:39 <Mamemaki> ocharles: I read your article on Asteroids with Netwire. You think it would be better the make your Asteroids program with reactive-banana?
04:45:41 <liste> Mamemaki: I have only done GUI work, but I think reactive-banana could work for simulations too
04:46:39 <noan_> in my cabal file... are my source directories compiled recursively? Or must they be defined? As in... if I say /src is my source directory, and I have /src/requests, will contents in requests be compiled first?
04:46:58 <noan_> minus the word first there.
04:47:27 <sm> noan: you must list the modules (source files) explicitly
04:47:39 <sm> or, use hpack
04:47:45 <ocharles> Mamemaki: I dunno about "better", but it's entirely possible to build it in both
04:47:53 <ocharles> Mamemaki: note that netwire has been superceded by 'wires' now
04:48:00 <noan> sm, I have it in exposed-modules. But it must also be in hs-source-dirs, then?
04:48:21 <sm> I forget, sorry. Check the fine manual
04:48:26 <sm> or experiment
04:49:01 <noan> looks like I need to add subdirectories
04:49:02 <noan> wonky.
04:49:25 <Mamemaki> ocharles: Wires? I didn't know about that. I haven't looked at reactive-banana, how is the learning curve compared to netwire (which I would consider difficult)
04:50:05 <ocharles> That's hard to answer. The learning curve of FRP is fairly high, but reactive-banana has a fairly tiny API, so it's more about learning that API. But the API is built on Functor + Applicative + Monad, which is why I like it
04:50:27 <Mamemaki> liste: Seems like reactive-banana is the better choice at the moment, between your and ocharles' responses
04:52:14 <Mamemaki> ocharles: I think I'll have a look at reactive-banana then. I do like learning about Arrows though, they're pretty interesting
04:52:52 <merijn> Mamemaki: Arrows have mostly fallen out of favour, though :)
04:53:21 <merijn> Mamemaki: Turns out almost all their usecases can be covered by Applicative, Category and Profunctor, all of which are more general and nice abstractions
04:53:54 <Mamemaki> merijn: Really? I guess it's unfortunate that I spent so much time reading about them recently
04:54:55 <phadej> ... except that arrow syntax can be much more understandable in some not so linear "wirings"
04:55:14 <merijn> Mamemaki: Well, understanding Arrow will still help you "get" parts of those others :)
04:55:41 <phadej> although, ApplicativeDo might help there
04:56:20 <Mamemaki> ocharles: Just checking the new Wires package. It's on its first version, is it as stable as the most recent Netwire?
04:56:36 <ocharles> I believe so. ertes is the author, you'd have to check with him
04:57:18 <Mamemaki> Why the change in name?
04:57:43 <Mamemaki> Too many changes?
04:59:14 <Mamemaki> Thanks for the advice everyone. Netwires/wires seems interesting, but I'll have a look at reactive-banana.
05:03:52 <noan> sooo, anyone have baby's first guide to navigating haskell documentation? I want to create a UTCTime representing 24 hours into the future. looking http://hackage.haskell.org/package/time-1.7.0.1/docs/Data-Time-Clock.html#t:UTCTime here now to find the appropriate stuff
05:06:36 <phadej> nextDay = timestamp { utctDay = succ (utctDay timestamp) }
05:06:52 <warbo> Hello, I'm playing with the ghc-dup package, updating the C-- code to work with GHC 7.10.3, but I've hit a problem with some hard-coded symbol names
05:07:41 <warbo> the .cmm file is using the symbol ghczmdupzm0zi1_GHCziDup_deepDupFun_closure, but this causes an error since the name isn't found
05:07:57 <warbo> I know it's due to the switch to package keys instead of name-version
05:08:12 <warbo> but don't know how to reliably replace it
05:08:15 <warbo> any thoughts?
05:09:18 <Ford_Prefect> Hello. I have what is likely a dumb question.
05:09:42 <noan> phadej, my hoogle lookup can't seem to find timestamp
05:09:48 <Ford_Prefect> I'm using Aeson with an object like say data User = User { userName :: String }
05:10:28 <Ford_Prefect> And I'm trying to have the JSON have keys such that I drop "user" and convert the rest to hyphen-separated lower case
05:11:03 <Ford_Prefect> I thought using 'constructorTagModifier' from Aeson.Types.Options would be the right way to do this, but that seems to not be the case
05:11:17 <Ford_Prefect> Do I just need to manually write toJSON/parseJSON for this?
05:11:30 <laz> Ford_Prefect: you need fieldLabelModifier
05:11:50 <Ford_Prefect>  /o\
05:11:53 <Ford_Prefect> knew I was being dumb
05:12:07 <Ford_Prefect> So fieldLabelModifier does record name -> json key
05:12:12 <Ford_Prefect> and constructorTagModifier does the reverse?
05:12:44 <laz> constructorTagModifier  is for, well, constructor tags
05:12:51 <warbo> There is CPP floating about in this .cmm, so I think the CURRENT_PACKAGE_KEY and CURRENT_COMPONENT_ID from Cabal might form part of a solution; but they'll also need z-encoding :S
05:13:47 <laz> Ford_Prefect: when you encode sum type, it uses constructor tags to tag the object
05:14:28 <phadej> :t \timestamp -> timestamp { Data.Time.utctDay = succ (Data.Time.utctDay timestamp) }
05:14:30 <lambdabot> time-1.6.0.1:Data.Time.Clock.UTC.UTCTime -> time-1.6.0.1:Data.Time.Clock.UTC.UTCTime
05:15:38 <phadej> Ford_Prefect: constuctorTagModifier modifies the name of constructors, in your case 'User'
05:15:50 <Ford_Prefect> Oooh
05:15:52 <Ford_Prefect> Okay
05:15:55 <phadej> Ford_Prefect: that's needed when you have data OneOfThree = One | Two | Three
05:19:35 <piyush-kurur> has any one come across a monad/applicative functor that has the following lifting property
05:20:33 <reactormonk> What's the relation between http-conduit and http-client?
05:20:44 <piyush-kurur> you can lift IO a, you can lift (a -> IO b) -> IO c  you can lift (a1 -> a2 -> IO b) -> IO c etc etc to the corresponding types with the monad replaced for IO 
05:20:44 <reactormonk> ... which one should I be using?
05:21:35 <Ford_Prefect> phadej: so doesn't parseJSON need something that is the inverse of fieldLabelModifier to parse those labels back?
05:22:11 <osa1> where can I learn more about typeclass resolution rules? I can't find a relevant chapter in Haskell 2010 report. more specifically I'm wondering about the behavior when there are more than one instance that can be used and rules for FlexibleInstances
05:22:50 <phadej> Ford_Prefect: no
05:23:49 <jophish> piyush-kurur: might want to check out MonadMask, somewhat related to your question
05:23:55 <phadej> osa1: does report even speak about FlexibleInstances, imho it's all GHC specific, so GHC manual is where to look about them
05:24:24 <phadej> osa1: and you are in OverlappingInstances territory
05:25:46 <phadej> osa1: hopefully https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overlapping-instances answers your question
05:26:17 <geekosaur> Ford_Prefect, fieldLabelModifier controls how the ToJSON and FromJSON instances are built, it is not a modifier you apply to the JSON or the data
05:26:37 <noan> ohboy. this makes sense but complicates things.. getCurrentTime is of type IO UTCTime
05:26:42 <ski> hm, what's a package with an exception applicative functor, that collects multiple exceptions ?
05:27:50 <Axman6> noan: how does that makr things difficult?
05:28:04 <sm> noan: the time packages are known to be hard to navigate.. one way to find that would be by type signature https://www.haskell.org/hoogle/?hoogle=UTCTime+-%3E+UTCTime
05:28:11 <geekosaur> they probably wanted to use it from pure code
05:28:26 <noan> Axman6, I'm just starting to learn and it means I need some way to manage it all in IO all the way down.
05:28:48 <sm> noan: but since you're working with dates, this might be better http://hoogle.haskell.org/?hoogle=Day+-%3E+Day&scope=set%3Astackage
05:29:02 <noan> sm, yeah I couldn't wrap my head around even how to construct a nominaldifftime so I could perform an addtime
05:29:11 <sm> http://hoogle.haskell.org/?hoogle=addDays is really the answer
05:29:16 <noan> I want datetimes.
05:29:17 <piyush-kurur> jophish: Is the paper Monad Zippers and Views (ICFP 11) relevant 
05:29:22 <noan> 24 hours exactly into the future.
05:29:26 <sm> ok
05:29:45 <geekosaur> strictly speaking you're already in trouble :)
05:29:49 <noan> I'll figure it out. This is learning. I need to figure out how to compose my functions wtihout brackets everywhere. I think it involves $
05:29:54 <sm> addUTCTime then I guess
05:29:56 <noan> I'll go find it in learn you a haskell
05:30:03 <geekosaur> (leap seconds, DST changes...)
05:30:04 <warbo> hmm, I seem to have lucked out; using ghcduzuCURRENT_PACKAGE_KEY_GHCziDup_deepDupFun_closure as the symbol works
05:30:47 <piyush-kurur> jophish: I guess you were refereing to the package mzv (that is where I got the reference from)
05:31:01 <warbo> CURRENT_PACKAGE_KEY will get replaced by CPP with the current package ID, and the rest is reverse-engineered from running the `strings` command on the .so file
05:31:06 <Axman6> noan: make sure you look ayt what class instances each type has. for instance NominalDiffTime I believe implements Num where "1" is 1 second
05:31:35 <osa1> phadej: I don't mean OverlappingInstances, I mean more innocent cases like when you have `instance X a => X [a]`, `instance X Int` and `instance X [Int]`
05:31:40 <warbo>  this isn't actually safe, since the key won't get z-encoded, but the hash of my dependencies just-so-happens to avoid containing any "z" characters ;)
05:31:54 <phadej> osa1: tha's the same issue
05:31:56 <osa1> but you're right that I'm searching it in wrong place
05:32:08 <noan> Axman6, as in I can use 86400 in place of an actual NominalDiffTime of 24 hours?
05:32:16 <osa1> phadej: same with what?
05:32:40 <noan> geekosaur, I'm aware of that stuff. I want it represented in UTC time, and I don't care about leap seconds. It doesn't require per-second precision.
05:32:46 <phadej> osa1: overlapping instances, X [Int] and [a] unify, so they are overlapping
05:33:12 <phadej> osa1: and if they are orphans, you can define them in different modules without overlapping pragmas
05:33:17 <phadej> you just won't be able to use them
05:33:41 <osa1> ahh right. OK thanks I'll read the manual section
05:39:19 <Clint> <p><strong><a href="http://bethanyon36th.com/wp-content/fluffed.php">Click here</a></strong> to confirm your email address.</p>
05:40:48 <geekosaur> o.O
05:41:01 <Clint> geekosaur: er, sorry
05:43:31 <reactormonk> How do I join lenses, e.g. _Just . fooL . _Just should give me a Prism, not a Traversal.
05:46:15 <Taneb> reactormonk, is fooL a lens there
05:46:26 <reactormonk> Taneb, Foo (Maybe Bar)
05:46:29 <ph88> hey guys, i know that ghc can get stuck when you do something like    instance Class a => Class b    instance Class b => Class a    anyone know how this is called and if there is documentation about this ?
05:46:44 <Taneb> reactormonk, what is the type of "fooL"
05:47:42 <mroman> How can I teach ghc that I'm not in a list monad :(
05:47:47 <reactormonk> Taneb, the whole thing is  (authorityL .> _Just .> authorityPortL .> _Just .> portNumberL) via https://hackage.haskell.org/package/uri-bytestring-0.2.2.1/docs/URI-ByteString.html - authorityL :: Lens' (URIRef a) (Maybe Authority) Source
05:48:08 <reactormonk> authorityPortL :: Lens' Authority (Maybe Port) - portNumberL :: Lens' Port Int
05:48:27 <srhb> mroman: By not using the wrong type.
05:48:31 <mroman> if i have a function foo :: Mondad m -> Foo m -> m ()
05:48:38 <Taneb> reactormonk, that should in fact be a Traversal
05:49:06 <Taneb> Because you can use a Prism to construct things, and you can't turn authorityPortL around to get a constructor like you can with _Just
05:49:06 <reactormonk> Taneb, ... which I can't really call view on.
05:49:38 <reactormonk> Yeah, I'm not too solid on the things above the basic Lens.
05:49:51 <Gurkenglas> :t [(undefined :: Prism' String Int) . (undefined :: Prism' Int Char), undefined :: Prism' String Char] -- Composing two prisms will give you a prism, reactormonk
05:49:53 <lambdabot> (Choice p, Applicative f) => [p Char (f Char) -> p String (f String)]
05:49:55 <Taneb> > Just (2, Just 3) ^? _Just . _2 . _Just
05:49:57 <srhb> mroman: What's your actual problem?
05:49:58 <lambdabot>  Just 3
05:50:50 <geekosaur> mroman, not enough information. but my guess is you tried to do something like produce a String, without using pure/return so it inferred the list monad because String = [Char]. Show code.
05:50:51 <geekosaur> @paste
05:50:51 <lambdabot> Haskell pastebin: http://lpaste.net/
05:50:55 <Gurkenglas> reactormonk, can you construct an Authority from a Maybe Port? If yes, you can write a prism there, and compose that with the _Just parts
05:51:00 <mroman> I have xs <- f; mapM_ g xs
05:51:06 <reactormonk> Gurkenglas, nope, I can't.
05:51:08 <mroman> and it keeps telling me xs is a instead of [a]
05:51:19 <mroman> but the return type of f is [a]
05:51:34 <reactormonk> Gurkenglas, know some good documentation about advanced lensing? I feel like I'm in for some RTFM
05:51:54 <geekosaur> mroman, you probably wanted let, then
05:52:14 <mroman> no it's m [a]
05:52:17 <geekosaur> if f :: [a] then using <- does in fact mean [] is the monad
05:52:28 <mroman> or not
05:52:29 <mroman> hmb
05:52:31 <mroman> Right.
05:52:36 <mroman> Maybe it assumes that
05:52:45 <geekosaur> er
05:53:05 <reactormonk> Gurkenglas, I think I'm looking for something akin to an Optional in the haskell lens lib - https://julien-truffaut.github.io/Monocle/optics.html
05:53:15 <Gurkenglas> Hmm the literal documentation https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Prism.html talks a little about what a Prism is, but it doesn't explain the composition rules
05:53:35 <mroman> Thx.
05:53:38 <mroman> fixed it :)
05:53:51 <Gurkenglas> Maybe he thought that's not his department because "its just function composition and anybody knows how that works with typeclasses"
05:55:01 <Gurkenglas> reactormonk, an optional is a traversal that has up to one target? How do you use that there's only up to one target?
05:55:09 <Tuplanolla> The lack of a node between Prism and Setter in that image is unsettling, reactormonk.
05:55:55 <reactormonk> Tuplanolla, what are you missing there?
05:56:10 <Tuplanolla> I don't know, but something ought to be there for symmetry.
05:56:29 <reactormonk> Gurkenglas, hmm, I'd say it's a specialization of Traversable to Maybe
05:56:51 <reactormonk> That doesn't need a Monoid.
05:57:02 <Gurkenglas> Tuplanolla, but https://hackage.haskell.org/package/lens also has nothing in between there
05:57:22 <Gurkenglas> reactormonk, but that would allow you to replace Nothing with Just or vice versa, which breaks the traversal laws
05:58:23 <reactormonk> Gurkenglas, pretty sure I don't follow
05:59:03 <mroman> geekosaur: yeah it was a missing m there.
05:59:15 <Gurkenglas> If you treat the Optional as a Traversal, you can only update at each place (and read something out meanwhile), i.e. you "traverse". This does not modify the number of elements traversed over
06:00:48 <reactormonk> There's only one element anyway.
06:01:08 <reactormonk> ... and no, the set on there is a regular set. It just either happens or doesn't.
06:01:16 <Gurkenglas> Up to one. Even Traversals traversing over up to one element maybe not remove it or add one if there isnt one
06:01:37 <Gurkenglas> -maybe+may
06:02:34 <reactormonk> Where do you conclude that the Optional modifies the number of elements?
06:03:15 <Gurkenglas> If you implement it as Lens' s (Maybe a), you can set Nothing or Just-values in there at will
06:05:02 <reactormonk> So what should it be?
06:05:56 <reactormonk> Or a bit more practical, how do I construct my lens that I pass to view in such a way that I get a Maybe Int out?
06:06:22 <Gurkenglas> (Well, if you want to be able to set Nothing or Just-valus, you can still do it as Lens' s (Maybe a), but it wouldn't be Optional? :P)
06:06:35 <Gurkenglas> reactormonk, you can just preview the traversal you already have gotten out of the composition
06:07:06 <reactormonk> Gurkenglas, nice, thanks.
06:07:15 <Gurkenglas> :t preview :: Traversal' String Int -> String -> Maybe Int
06:07:17 <lambdabot> Traversal' String Int -> String -> Maybe Int
06:07:38 <reactormonk> darn, should have been looking for that.
06:07:48 <reactormonk> Thanks, problem solved.
06:07:58 <reactormonk> Now is there a way to maybe make an update to a record?
06:08:09 <reactormonk> ... or should I construct a lens for said record first?
06:08:28 <Gurkenglas> Well, might an update a value where there wasnt one before?
06:08:41 <Gurkenglas> *insert
06:09:26 <Gurkenglas> :t over :: Traversal' String Int -> (Int -> Int) -> (String -> String)
06:09:27 <lambdabot> Traversal' String Int -> (Int -> Int) -> String -> String
06:10:21 <reactormonk> defaultRequest via https://www.stackage.org/haddock/lts-7.18/http-conduit-2.1.11/Network-HTTP-Conduit.html#t:Request
06:10:23 <Gurkenglas> :t set :: Traversal' String Int -> Int -> (String -> String) -- replaces each existing int with the one given
06:10:26 <lambdabot> Traversal' String Int -> Int -> String -> String
06:10:31 <reactormonk> No lenses provided.
06:11:07 <Gurkenglas> https://hackage.haskell.org/package/http-client-lens-0.1.0/docs/Network-HTTP-Client-Lens.html ?
06:12:33 <Gurkenglas> And now consider how many more hours you're working because you're not asking the right questions :D
06:13:55 <roxxik> if you just experimenetd with some code for a few days and then some random comment on irc points you to an 8 years old gist from ekmett, solving your problem
06:14:01 <reactormonk> Gurkenglas, I'm asking here so I know which questions to ask. And yes, I've done that before with uri and bytestring
06:14:29 <reactormonk> Gurkenglas, is there a nice way to wire the Maybe port from the preview into the setter for Request?
06:15:00 <Gurkenglas> Umm, more exact names or types pls
06:15:41 <reactormonk> Take the above lens, preview it, https://hackage.haskell.org/package/http-client-lens-0.1.0/docs/Network-HTTP-Client-Lens.html port
06:16:21 <Gurkenglas> I keep wanting to be an established question format where you just say into irc ":manual-exf Lens' s a -> s -> a" and people answer "view"
06:16:31 <reactormonk> So I'd have Lens' URIRef a b -> Lens' Request b -> Request -> Request
06:16:50 <reactormonk> or rather, that's what I'd like.
06:16:57 <mroman> https://wiki.haskell.org/Type_witness <- does that example code actually cast anything?
06:16:57 <Gurkenglas> Lens' URIRef a b <- too many type parameters
06:17:13 <reactormonk> So And Lens' (URIRef a) Maybe b -> Lens' Request b -> Request -> Request
06:17:23 <reactormonk> So Lens' (URIRef a) (Maybe b) -> Lens' Request b -> Request -> Request
06:17:37 <mroman> I don't really follow what it's supposed to do :(
06:18:04 <merijn> ok, so any persistent users here? I have a bunch of ugly repetitive code that I'm unsure how to clean up :\
06:18:17 <Gurkenglas> reactormonk, cannot instantiate. Did you mean to provide more parameters to the function im supposed to write?
06:18:21 <merijn> But I'm not really sure how
06:19:24 <reactormonk> Gurkenglas, I have lenses to get the information out of URIRef, and lenses how to put them into Request. How do I combine them? And how do I deal with Maybe in between?
06:19:26 <Gurkenglas> reactormonk, "Lens' Request b -> Request -> Request" reduces to "b -> b" - is there a parameter of that form?
06:20:43 <Gurkenglas> :t maybe id const :: Maybe b -> b -> b -- is this the intended behavior?
06:20:46 <lambdabot> Maybe b -> b -> b
06:20:51 <geekosaur> mroman, it's not a cast like in C
06:20:59 <geekosaur> because you can;t do that in Haskell
06:21:15 <reactormonk> Gurkenglas, in case of a Maybe, yes, I think so. Don't modify in that case.
06:21:34 <reactormonk> ... in case of Nothing, to be exact.
06:21:57 <geekosaur> what it does is let you extract a value that could be one of several types, by providing a witness for the stored value's type and a witness for the type you want; it will only produce a Just if they match
06:21:58 <Gurkenglas> reactormonk, where do I get the URIRef to call the first lens on? Is there some Lens' Request (URIRef a)?
06:22:03 <reactormonk> But I don't see the reduction right now, so maybe I'm talking on another track.
06:22:10 <reactormonk> Gurkenglas, fuck, forgot about that.
06:22:51 <Gurkenglas> Okay so more generally we're at "Lens' s (Maybe a) -> Lens' s a -> s -> s"?
06:23:02 <reactormonk> Yeah.
06:23:19 <reactormonk> Ehh, wait. No.
06:23:30 <noan> where would be the best place to learn my way through haskell syntax? lyahfgg? 
06:23:42 <reactormonk> Lens' s (Maybe a) -> Lens' r a -> s -> r -> r
06:24:54 <roxxik> reactorMonk: `Getter s (Maybe a) -> Setter r a -> s -> r -> r` ?
06:25:06 <reactormonk> roxxik, yeah.
06:25:10 <roxxik> having a Lens where you don't need one might restrict you later
06:25:21 <roxxik> and it shows better what you want to do
06:25:22 <geekosaur> mroman, so if you pattern match a GADT constructor, you bring its type into scope. this means pattern matching IntWitness "proves" that pa is a p Int (since otherwise the pattern match fails to typecheck and falls through)
06:25:22 <Gurkenglas> \sa ra s -> ra %~ views sa (maybe const id) s
06:25:56 <roxxik> :t views
06:25:57 <lambdabot> MonadReader s m => LensLike' (Const r) s a -> (a -> r) -> m r
06:26:36 <reactormonk> roxxik, might be nice to have Lens' s (Maybe a) -> Lens' r a -> Lens' s r and then just stack them all up (not sure how yet)
06:26:59 <reactormonk> Also because it's not an Iso from what I understand, just a partial transferal of informations.
06:27:15 <roxxik> reactorMonk: Lens' s r is not very useful, i think
06:27:16 <Gurkenglas> Or with less advanced lens words and more pointfree, \sa ra -> over ra . maybe const id . view sa
06:27:37 <mroman> geekosaur: so the dynamicCast function just proves that both are p Int?
06:27:45 <roxxik> :t \sa ra -> over ra . maybe const id . view sa
06:27:47 <lambdabot> Getting (Maybe (a -> b -> a)) s1 (Maybe (a -> b -> a)) -> ASetter s t a (b -> a) -> s1 -> s -> t
06:28:15 <reactormonk> :t \sa ra s -> ra %~ views sa (maybe const id) s
06:28:17 <lambdabot> LensLike' (Const (a -> b -> a)) s1 (Maybe (a -> b -> a)) -> ASetter s t a (b -> a) -> s1 -> s -> t
06:28:19 <geekosaur> yes, and refuses you the value otherwise. this is the best you can do in Haskell because you must have a definite type
06:28:29 <roxxik> :t \sa ra -> over ra . maybe const id . view sa :: Getter s a -> Setter' r a -> s -> r -> r
06:28:31 <lambdabot> error:
06:28:31 <lambdabot>     • Couldn't match expected type ‘ASetter
06:28:31 <lambdabot>                                       ((a1 -> f0 a1) -> r1 -> f0 r1) (s1 -> r1 -> r1) a0 (b0 -> a0)’
06:28:37 <roxxik> :t \sa ra -> over ra . maybe const id . view sa :: Getter s (Maybe a) -> Setter' r a -> s -> r -> r
06:28:39 <lambdabot> error:
06:28:39 <lambdabot>     • Couldn't match expected type ‘ASetter
06:28:40 <lambdabot>                                       ((a1 -> f0 a1) -> r1 -> f0 r1) (s1 -> r1 -> r1) a0 (b0 -> a0)’
06:28:43 <mroman> so it doesn't actually do type casting?
06:28:49 <Gurkenglas> Experiment in queries.
06:29:00 <roxxik> jusst opened one
06:29:18 <geekosaur> mroman, as I said earlier, it does not do C style type casting, because that is not possible in Haskell
06:29:39 <mroman> You can do dynamic type casting by using type classes.
06:29:42 <geekosaur> (barring unsafeCoerce which will happily break your program if (ab)used)
06:29:52 <geekosaur> only to a point
06:30:18 <reactormonk> :t :t (\sa ra -> over ra . maybe const id . view sa) (preview (authorityL .> _Just .> authorityPortL .> _Just .> portNumberL))
06:30:21 <lambdabot> error: parse error on input ‘:’
06:30:23 <reactormonk> :t (\sa ra -> over ra . maybe const id . view sa) (preview (authorityL .> _Just .> authorityPortL .> _Just .> portNumberL))
06:30:28 <lambdabot> error:
06:30:28 <lambdabot>     • Couldn't match type ‘Maybe a0’
06:30:28 <lambdabot>                      with ‘s1 -> Const (Maybe (a -> b -> a)) s1’
06:31:31 <mroman> http://codepad.org/0nUm18yb <- something like that.
06:31:53 <mroman> but then this has nothing to do with the casting as in that type witnesses article
06:32:06 <Gurkenglas> :t \sa ra -> over ra . maybe const id . view sa :: Lens' String (Maybe Int) -> Lens' Char Int -> String -> Char -> Char -- reactormonk
06:32:08 <lambdabot> (Functor f1, Functor f) => Getting (Maybe (a -> b -> a)) ((Maybe Int -> f1 (Maybe Int)) -> String -> f1 String) (Maybe (a -> b -> a)) -> ASetter ((Int -> f Int) -> Char -> f Char) (String -> Char ->
06:32:08 <lambdabot> Char) a (b -> a) -> Lens' String (Maybe Int) -> Lens' Char Int -> String -> Char -> Char
06:32:39 <mniip> that looks
06:32:46 <mniip> fairly horrifying
06:32:58 <roxxik> :t maybe const id -- this is weird
06:33:00 <lambdabot> Maybe (a -> b -> a) -> a -> b -> a
06:33:06 <roxxik> :t maybe id const -- this is better
06:33:07 <lambdabot> Maybe b -> b -> b
06:33:14 <mroman> (gotta catch train. be back later)
06:33:30 <Gurkenglas> argh you're right
06:33:39 <Gurkenglas> (gotta catch brain. be back later)
06:34:21 <roxxik> :t \sa ra -> over ra . maybe id const . view sa -- this makes sense now
06:34:23 <lambdabot> Getting (Maybe b) s1 (Maybe b) -> ASetter s t b b -> s1 -> s -> t
06:35:57 <int-index> Ok, so I wrote an UTLC interpreter... (with de Bruijn indices). What do I put in a test suite? It seems to handle Church numerals fine, but I want to test corner cases
06:36:06 <reactormonk> :t let lens = undefined   :: Applicative f => (Int -> f Int) -> URIRef a -> f (URIRef a); (\sa ra -> over ra . maybe id const . view sa) lens
06:36:08 <lambdabot> error:
06:36:08 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
06:36:48 <roxxik> try `in` instead of `;`
06:36:56 <mniip> int-index, implement division
06:37:00 <reactormonk> :t lens = undefined   :: Applicative f => (Int -> f Int) -> URIRef a -> f (URIRef a) in (\sa ra -> over ra . maybe id const . view sa) lens
06:37:02 <lambdabot> error:
06:37:02 <lambdabot>     parse error on input ‘=’
06:37:02 <mniip> that ought to be a good enough test
06:37:02 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
06:37:16 <roxxik> reactormonk: you still need let
06:37:18 <reactormonk> :t let lens = undefined   :: Applicative f => (Int -> f Int) -> URIRef a -> f (URIRef a) in (\sa ra -> over ra . maybe id const . view sa) lens
06:37:20 <lambdabot> error:
06:37:20 <lambdabot>     Not in scope: type constructor or class ‘URIRef’
06:37:20 <lambdabot> error:
06:37:27 <reactormonk> Got me a cood alternative?
06:37:39 <reactormonk> :t let lens = undefined   :: Applicative f => (Int -> f Int) -> [a] -> f ([a]) in (\sa ra -> over ra . maybe id const . view sa) lens
06:37:40 <lambdabot> error:
06:37:41 <lambdabot>     • Couldn't match type ‘Int’ with ‘Maybe b’
06:37:41 <lambdabot>       Expected type: [a] -> Maybe b
06:37:47 <reactormonk> ^ there we go.
06:42:01 <merijn> I have like 10 or 12 entities + relationships like this http://lpaste.net/1552983955743965184 in persistent and some code that generally needs to be able to 1) construct an entity, 2) extract it's content and 3) construct the relation. Which results in the bottom boilerplate code. Any suggestions on how I can make this less noisy/boilerplatey?
06:42:41 <merijn> It seems like things should be possible in a simpler way...
06:46:16 <nitrix> merijn: Cute.
06:46:37 <nitrix> merijn: Remember how I was discussing this very problem a month ago for a game of mine :P ?
06:47:19 <nitrix> merijn: I ended up with memory cells.
06:48:15 <Profpatsch> How do I make file reads strict?
06:48:53 <Profpatsch> I have the problem that I do newIORef =<< getConfig
06:49:10 <nitrix> merijn: data BoardCategory = BoardCategory { game :: Link Game, category :: Link Category }
06:49:42 <nitrix> merijn: Link was describing a relation between two cells. Each cell is given a unique ID.
06:49:44 <Profpatsch> getConfig should really put the configuratino into the ioRef directly, because otherwise the file handle will be closed when it tries to read the file.
06:50:24 <nitrix> merijn: Since they are memory cell, I'd have O(1) lookups and writes instead of resolving the id in tons of maps.
06:51:09 <int-e> Profpatsch: there's http://hackage.haskell.org/package/strict-0.3.2/docs/System-IO-Strict.html
06:51:28 <nitrix> merijn: And a single id system for all relations possible was very convenient because I could serialize and unserialize easily from disk. Type inference would figure out the rest and an error would be thrown if the json weren't to parse to the proper constructor.
06:52:02 <tirej> what does forward slash means ? e.g. : 5 /= 5 
06:52:05 <Benzi-Junior> hey I'm looking at the core for a library that I'm developing and discovered that functions declared in record types aren't being inlined, and adding a INLINE pragma doesn't find the binding 
06:52:12 <nitrix> merijn: It was lazy loading/unloading entities as needed to manipulate related data on the fly.
06:52:36 <Benzi-Junior> is there a way to have these inlined ?
06:54:19 <fuzzyhorns> trying to build up my mental model. what's the difference between just passing a bunch of parameters around in a function invocation and setting up the state monad?
06:54:42 <nitrix> Explicit vs. Implicit parameters.
06:55:00 <nitrix> fuzzyhorns: With the state monad, you end up with a tuple being passed implicitly to lambdas.
06:55:11 <nitrix> :t StateT
06:55:12 <lambdabot> (s -> m (a, s)) -> StateT s m a
06:55:16 <Profpatsch> int-e: lel hGetContents h  = IO.hGetContents h >>= \s -> length s `seq` return s
06:55:20 <nitrix> fuzzyhorns: That (a, s)
06:55:31 <fuzzyhorns> yeah, what's my advantage in doing that though, do you think? just avoiding boilerplate?
06:55:37 <tirej> anyone?
06:55:42 <fuzzyhorns> i quite like it so far btw, just trying to fully understand :x
06:55:55 <nitrix> fuzzyhorns: Well, the boilerplate that you'll invent will end up being a poor version of a monad.
06:56:22 <Tuplanolla> Nothing, tirej. It's just that `(/=)` is a function.
06:56:26 <fuzzyhorns> nitrix: mm, i'd like to see the comparison sometime — perhaps i should do it as an exercise
06:56:43 <mniip> fuzzyhorns, the difference is syntactic convenience
06:56:54 <int-e> Profpatsch: sure, depending on the package might be overkill.
06:56:56 <Tuplanolla> It means "not equal", tirej.
06:57:10 <nitrix> fuzzyhorns: Let me guess, your functions have the form :: State -> Val -> (State, Result) ?
06:57:15 <tirej> like != in imp lang right Tuplanolla ?
06:57:30 <nitrix> fuzzyhorns: Taking and old state and returning a new state?
06:57:34 <nitrix> s/and/an/
06:57:36 <Tuplanolla> Yes.
06:57:39 <tirej> ty
06:57:48 <mniip> tirej, hardly related to imperative/function
06:58:01 <tirej> mniip: i see
06:58:06 <mniip> just that the haskell committee decided to call it /= because of the mathematical symbol of inequaliy
06:58:08 <fuzzyhorns> nitrix: kinda
06:58:14 <nitrix> :t StateT
06:58:16 <lambdabot> (s -> m (a, s)) -> StateT s m a
06:58:19 <fuzzyhorns> nitrix: basically so
06:58:23 <mniip> ≠
06:58:23 <nitrix> fuzzyhorns: Notice (s -> m (a, s))
06:58:28 <tirej> uhm, mniip ty for the info
06:58:32 <Tuplanolla> Do you have a moment to talk about our lord and savior Hoogle, tirej?
06:58:54 <mniip> nitrix, I think ':t state' would be an easier example
06:58:54 <unknownln> http://bloodatius.deviantart.com/art/Tea-661090078
06:58:57 <nitrix> fuzzyhorns: Your function have the same exact form than the StateT monad transformer.
06:59:00 <unknownln> Sorry
06:59:05 <nitrix> :t state
06:59:05 <tirej> Tuplanolla: i googled : )
06:59:07 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
06:59:08 <unknownln> Derped up on my phone
06:59:13 <fuzzyhorns> nitrix: neat, i dont understand yet how that helps me
06:59:31 <fuzzyhorns> i dont understand transformers yet really
06:59:37 <nitrix> fuzzyhorns: Maybe I need to backtrack. Possibly you don't have experience yet with monads?
06:59:44 <Tuplanolla> It'll tell you where functions or types you don't know live, tirej.
06:59:53 <mniip> hmm, is there a stock State that is not a sugared down transformer
07:00:13 <nitrix> mniip: No, which is why I didn't try to sugar coat it :/
07:00:18 <mniip> welp
07:00:24 <fuzzyhorns> https://gist.github.com/mooreniemi/f2b3cf9f6db3cd527254404e5a845beb forgive that it is very messy
07:00:37 <fuzzyhorns> nitrix: i mostly use them via do notation, so i feel like i may not fully understand
07:00:48 <fuzzyhorns> my mental model is basically "use this to carry around some computational context"
07:01:20 <nitrix> ... and yet I see Proxy used in your code ._.
07:01:30 <tirej> Tuplanolla: probably didnt ask the right question, or hoogle is just a scam, meh
07:01:41 <nitrix> Is Haskell so intuitive that people do poly-kinded stuff accidently now :P ?
07:01:41 <fuzzyhorns> nitrix: it is from servant :/
07:01:43 <mniip> Proxy hardly is a monad
07:02:04 <mniip> I mean it is but not like...
07:02:05 <fuzzyhorns> i dont fully understand Proxy either, keep in mind I am just copying what servant does for HasDocs without fully understanding it
07:02:07 <Tuplanolla> @hoogle (/=)
07:02:08 <reactormonk> Gurkenglas, ah, works if I put preview instead of view.
07:02:11 <lambdabot> Prelude (/=) :: a -> a -> Bool
07:02:11 <lambdabot> Data.Eq (/=) :: a -> a -> Bool
07:02:11 <lambdabot> Data.GI.Base.ShortPrelude (/=) :: a -> a -> Bool
07:02:20 <mniip> I'm yet to see anyone use a Proxy do-block :p
07:02:22 <Tuplanolla> Works for me, tirej.
07:02:42 <nitrix> fuzzyhorns: If you come over #haskell-beginners, I can dedicate some time to good through was you know and build up from there.
07:02:45 <fuzzyhorns> also this code doesnt fully do what i want it to ultimately do yet, but you can see how I used state monad (clumsily im sure)
07:02:50 <nitrix> fuzzyhorns: Monads are very useful, especially State.
07:03:00 <nitrix> s/good/go/
07:03:06 <fuzzyhorns> cool i will go over there :)
07:04:09 <tirej> Tuplanolla: ty anyway
07:18:28 <mbrock> with lens, is there a nice way to do nested Map access? ``foo ^. bars . at "x" . at "y"`` isn't valid because at gives a Maybe. I would like the whole expression to become Nothing if either "x" or "y" don't exist as keys
07:19:30 <Gurkenglas> mbrock, foo ^? bars . ix "x" . ix "y"
07:19:54 <Gurkenglas> at lenses into Maybe a, ix traverses over a
07:20:09 <mbrock> oh, that seems to work, interesting, thanks
07:20:22 <Gurkenglas> (see http://hackage.haskell.org/package/lens-4.15.1/docs/Data-Map-Lens.html )
07:22:18 <Tuplanolla> How should I define a `newBroadcastChan` for `Control.Concurrent.Chan` (like `newBroadcastTChan` for `Control.Concurrent.STM.TChan`)?
07:25:59 <Tuplanolla> The constructor for `Chan` isn't exposed.
07:55:12 <Tuplanolla> Is it possible to copy the constructor into my module and `unsafeCoerce` the result?
07:55:36 <Lokathor> Tuplanolla, unlikely
07:56:04 <Lokathor> though i'm no expert, i think that if you copied all their stuff into your module you'd just have a new type that didn't work with the rest of their functions
07:56:25 <Tuplanolla> Thus the `unsafeCoerce`, Lokathor.
08:33:33 <Tuplanolla> That's a segmentation fault.
08:34:46 <Cale> Tuplanolla: Yeah, you can try stuff like that, but you need to be really careful about how everything is compiled, and I wouldn't generally recommend it.
08:34:56 <lyxia> what a relief
08:36:41 <mbrock> lens newbie question: I have a "Map Int Word8" but I often want to work with it as if it were "Map Int Word32", e.g. to set a 32-bit word at a certain byte index. I think I should define some kind of traversal, but I'm a bit confused
08:37:17 <Cale> uhhh, what?
08:37:39 <Tuplanolla> It seems to work if I compile both with the same flags though.
08:38:26 <mbrock> I want to do stuff like ``memory & words32 . ix 7 .~ 0xffffffff``, which would actually set the values at indices 7, 8, 9, 10
08:38:27 <Gurkenglas> mbrock, that sounds like you expect each index to already have a value - why is this a map?
08:38:43 <mbrock> Gurkenglas: it's a weird kind of sparse memory
08:38:56 <Gurkenglas> I see, makes sense
08:39:23 <Gurkenglas> You'll have to do two passes, but this is just a lens
08:39:52 <Cale> mbrock: Well, start by just writing the view and set operations normally without lens. You can turn them into a lens after.
08:43:28 <mbrock> ah, yes. I think it will be more like ``memory & word32at 7 .~ 0xffffffff``, so I should write a ``Int -> Lens' (Map Int Word8) Word256``
08:43:42 <reactormonk> Is it possible to make a lens that can't always set, because not all the values are valid in the container?
08:43:48 <saylu> Hey folks! Quick question -- anyone know of good resources for learning more about CoArbitrary from QuickCheck (aside from the documentation)?
08:43:57 <reactormonk> or rather, how's that called?
08:44:51 <Gurkenglas> reactormonk, you mean "Prism' t a -> Lens' s a -> t -> s -> s"?
08:45:02 <reactormonk> saylu, it's +/- obj => Seed, so you can seed another Gen
08:45:55 <mniip> hey Cale
08:46:58 <mniip> hmm
08:47:32 <reactormonk> Gurkenglas, so use the prism for the Either on checking if it would be a valid lens?
08:48:35 <Taneb> reactormonk, a Lens must obey the law view l (set l x) = x
08:48:40 <Gurkenglas> reactormonk, you mean "Either e a -> Lens' s a -> t -> s -> s"?
08:48:58 <Gurkenglas> um
08:49:06 <Gurkenglas> "Either e a -> Lens' s a -> s -> s"
08:49:28 <mniip> does anyone know what does the Arrow typeclass represent in CT?
08:50:07 <Cale> mniip: hi
08:50:20 <Gurkenglas> You might even say "Maybe a -> a -> a" :P
08:50:20 <mniip> it appears that &&& is the mediating morphism of the binary product in the category, and then first/second/*** are built from it and projections
08:50:21 <Cale> mniip: It's sorta kinda like the definition of a symmetric monoidal category
08:50:21 <reactormonk> Taneb, yeah, that's not the problem. However, it's possible to have x which can't be set.
08:50:42 <mniip> but then I'm not sure why 'arr' which is a kind of inverse of a forgetful functor is in the class
08:51:05 <Cale> Yeah, arr doesn't really fit in with that description
08:51:19 <Taneb> reactormonk, if set l x silently fails, then view l (set l x) will not be x
08:51:22 <mniip> and then ArrowChoice implements the comediating morphism to the binary coproduct
08:51:29 <Taneb> reactormonk, so you don't have a lens
08:51:32 <mniip> and it's a subclass of Arrow which makes no sense again
08:51:39 <Tuplanolla> Didn't Conal have arrows without `arr`?
08:51:39 <Gurkenglas> reactormonk, afaik you'll just have to use or not use set depending on whether x is valid
08:51:57 <dolio> Arrows are strong monads in a 2-category involving profunctors instead of functors.
08:52:03 <dolio> Or something along those lines.
08:52:05 <Gurkenglas> Which you can do by turning x into Maybe a and then using the maybe id const thing from earlier :D
08:52:10 <Cale> Yeah, there's that description...
08:52:19 <dolio> It's the correct one. :)
08:52:54 <Cale> I don't know about Conal, but back when Ryan and I were working on AFRP for our game, we ended up making the Arrow class hierarchy reflect the definition of a symmetric monoidal category better
08:53:19 <Cale> and for instance, arr went off into its own subclass
08:53:19 <dolio> Cale: Right, you want arrows to be soemthing better. :)
08:53:46 <Cale> Well, yeah. They pretty much undermine all their own best usecases as it stands.
08:53:56 <reactormonk> Gurkenglas, which I could turn into a Prism as well, with the error message.
08:54:24 <reactormonk> I'm wondering if there's another type which allows me to encode that only one way might fail, and the other is fine.
08:54:38 <Gurkenglas> Will the one way always fail?
08:55:01 <reactormonk> No, it can.
08:55:41 <reactormonk> Request => URI is always valid. URI => Request is not. Prism URI (Either Err Request) from what I understand.
08:55:49 <dolio> reactormonk: You can't make a lens that fails to set. People have tried, I think, calling them stuff like, 'partial lenses,' but you end up not being able to specify nice things about them the way you can with lenses, as I recall.
08:56:10 <Taneb> reactormonk, why not Prism' URI Request
08:56:22 <reactormonk> Taneb, let's go with that.
08:56:24 <mniip> dolio, ok, let's dissect that one
08:56:30 <mniip> which 2-category are we talking
08:56:52 <reactormonk> ah nice, Prism looks pretty reasonable.
08:56:55 <dolio> mniip: Let's not do that. Instead, let's think about switching the monad definition to profunctors.
08:57:32 <mniip> eh
08:57:56 <dolio> The identity profunctor is (->), and profunctor composition is: (F . G)(x,y) = exists e. F x e * G e y
08:58:27 <lpaste_> chrisdone pasted “Testing paste announcement on DigitalOcean” at http://lpaste.net/352059
08:59:09 <dolio> So if you just take the definition of monad and swap 'profunctor' for 'functor', (->) for identity functor, and profunctor composition for functor composition...
08:59:23 <mniip> dolio, you mean the hom(-, -) profunctor into Set, or the internal hom endo-profunctor?
08:59:49 <dolio> hom, profunctors in category theory all go into Set.
08:59:59 <mniip> okee
09:00:37 <dolio> You'll notice: eta : hom(-,-) -> M is hom(x,y) -> M(x,y).
09:00:41 <dolio> Which is arr.
09:01:06 <ARTF2> hi
09:01:12 <mniip> wait
09:01:20 <mniip> what is a natural transformation on a profunctor?
09:01:20 <ARTF2> wha?
09:01:30 <dolio> Just a point-wise natural transformation.
09:01:35 <mniip> just NT on like a regular functor?
09:01:51 <mniip> treating profunctor as a (- x -) ---> - functor?
09:02:07 <mniip> ok
09:02:14 <dolio> As D^op x C -> Set, yes.
09:02:41 <mniip> hm, this might be easier to imagine if we construct the category of profunctors
09:02:47 <mniip> and examine monoids under composition
09:03:01 <dolio> In this case it's C^op x C -> Set, I guess, because it has to be an endo-profunctor, like a monad is an endofunctor.
09:03:09 <Jinixt> anyone used llvm-general for llvm ir generation? is it any good?
09:03:21 <mniip> ok so, what's the composition again?
09:03:50 <dolio> (F . G)(x,y) = exists e. F(x, e) * G(e, y)
09:04:21 <mniip> * being the binary product in Set?
09:04:22 <dolio> I think, at least. I might have things swizzled around.
09:04:25 <dolio> Yeah.
09:05:16 <mniip> how do you propose we impose equality on profunctors to warrant that F . G == F . G?
09:05:32 <dolio> So mu in the monad is going to look like: forall a c. (exists b. M(a,b) * M(b,c)) -> M(a,c)
09:06:30 <dolio> I don't understand your question.
09:06:49 <mniip> you define profunctor composition nonconstructively
09:07:00 <dolio> exists is the Haskell-like exists.
09:07:10 <dolio> In category theory it'd be a coend.
09:07:47 <mniip> so a sum over all possible e's?
09:07:52 <dolio> Yeah.
09:08:04 <mniip> I need to think about that
09:08:14 <e> there is only one possible e, thank you
09:08:25 <dolio> Yeah, good choice of name. :)
09:08:44 <mniip> e: go back into Set
09:08:53 <Forty-Bot> I've created an implementation of <https://en.wikipedia.org/wiki/Dual_number> in haskell: https://gist.github.com/anonymous/81000a73ba2604964d870ed089498e14
09:08:57 <e> haha
09:09:19 <mniip> no wait, actually, e is in C, and the *sum* is over Set
09:09:23 <Forty-Bot> I'm not a very experienced haskeller, so I'd appreciate some feedback on if stuff isn't idiomatic
09:10:16 <noan> Oh god baby's first haskell. I'm sitting here staring at IO UTCTime and trying to figure out how to Construct a IO SessionToken { String, UTCTime } out of it
09:10:19 <dolio> mniip: One thing to think about is turning functors into profunctors. Like if F is a functor (- -> F=) is a profunctor. And if you do (exists e. (- -> Fe) * (e -> G=)), you can massage that into (- -> FG=).
09:10:20 <noan> baby's first monad please
09:10:22 <noan> XD
09:10:31 <Forty-Bot> I'm also not sure which bits should be inlined; I've based it mostly off of Number.Complex, but I haven't figured out a general rule for that
09:11:04 <mniip> noan, do x <- ioutctime; return $ SessionToken string x
09:11:07 <mniip> if all else fails
09:11:14 <dolio> So composing two profunctors built that way out of functors is equivalent to building a profunctor out of the functor composition.
09:11:42 <mniip> dolio, I don't understand the notation of (- -> F=)
09:12:17 <dolio> Star f x y = x -> f y
09:12:35 <dolio> Star f . Star g ~ Star (f . g)
09:13:17 <dolio> Where the left side is profunctor composition and the right side is functor composition.
09:13:42 <mniip> wait
09:14:51 <mniip> I can't see how id_X . id_X would be equal to id_X
09:15:08 <spatial> Anyone can point out some tutorial to get started with Spock. I use spacemacs
09:15:09 <dolio> They're isomorphic.
09:15:11 <mniip> hence again, how do we equate profunctors
09:15:39 <dolio> Wait, id_X?
09:15:50 <mniip> er
09:15:54 <mniip> yes, id(X, X)
09:16:14 <mniip> eh
09:16:17 <mniip> no not that either
09:16:25 <dolio> You mean the identity profunctor (hom)?
09:17:00 <mniip> yes that's what I mean
09:17:13 <dolio> So, if you have F(x,y) and hom(y,z) you can use the fact that you can use covariant mapping to turn that into F(x,z).
09:18:19 <dolio> And if you have hom(z,x) and F(x,y) you can turn that into F(z,y).
09:19:24 <mniip> hom(x, y) is the set of all morphisms from x to y, (hom . hom)(x, y) is the disjoin union of (set of morphisms from x to e, set of morphisms from e to y) for every e in C
09:19:29 <mniip> how do you propose we equate the two
09:20:35 <mniip> doesn't sound very isomorphic to me tbf
09:21:44 <dolio> To go from (exists e. hom(x,e) * hom(e, y)) to hom(x,y) you compose the two arrows.
09:22:22 <dolio> To go from hom(x,y) to (exists e. hom(x,e) * hom(e, y)) you pair the arrow you have with either the identity-on-x or identity-on-y.
09:22:36 <dolio> Depending on whether you choose e = x or e = y.
09:23:21 <dolio> And that's an isomorphism because while 'disjoint union' is the right kind of intuition, it's not perfectly accurate.
09:24:19 <dolio> It's more like a disjoint union quotiented by the fact where you sort of forget about exactly what 'e' you picked.
09:24:57 <mniip> okay that kinda makes sense
09:25:08 <mniip> though, hom is a set not a morphism
09:25:32 <dolio> It's the set of arrows.
09:25:46 <mniip> 1486142483 [20:21:23] <dolio> To go from (exists e. hom(x,e) * hom(e, y)) to hom(x,y) you compose the two arrows.
09:25:57 <dolio> To give an isomorphism, you explain how to map between the values of the two sets.
09:26:12 <dolio> And then prove that the mappings are inverses.
09:27:04 <mniip> your explanation doesn't sound correct but I think I figured it out anyway
09:27:17 <dolio> Okay. :)
09:28:30 <oz_> hello
09:28:32 <mniip> o
09:28:40 <mniip> I forgot one important detail
09:28:53 <oz_> where am i
09:28:56 <mniip> it's not a pair of sets, it's a cartesian product
09:29:04 <dolio> Yeah.
09:29:05 <mniip> oz_, this is #haskell on freenode
09:29:18 <dolio> Values are pairs of arrows.
09:31:43 <oz_> thank you! i was trying to find #cicadian but have had no luck
09:31:53 <sm> oz_: on the internet. planet earth, sol system. 
09:32:08 <mniip> oz_, /join #cicadian
09:36:10 <Forty-Bot> does anyone have feedback on the comments in https://gist.github.com/anonymous/81000a73ba2604964d870ed089498e14 ?
09:44:54 <spatial> Any tutorial explains how to use Spock. I have spacemacs.
09:45:40 <ski> Forty-Bot : you have various redundant brackets .. `(showsInfixPrec, )' could be `(showsInfixPrec)', `(Show a) => ' could be `Show a =>', `(-:) a b' could be `a -: b', `(+) (Cons a b) (Cons c d)' could be `Cons a b + Cons c d', `((b * c - a * d)/(c ^ 2)' could be `((b * c - a * d) / c ^ 2', `(fromRational' c) * b' could be `fromRational' c * b'
09:45:52 <ski> Forty-Bot : is `infixr 8 ^/' (or higher) ? if so `b * (a ^/ (c - 1))' could be `b * a ^/ (c - 1)', `b * (exp a)' could be `b * exp a', `b * (negate $ sin a) could be `b * negate (sin a)', `one + (a ^ 2)' could be `one + a ^ 2'
09:46:32 <ski> Forty-Bot : sometimes you use `Cons', sometimes `+:' in expressions .. is there any rhyme or reason to when you pick one over the other ?
09:47:03 <Forty-Bot> I remember trying to replace all the Cons with +: at one point and getting errors
09:47:07 <Forty-Bot> so I reverted it
09:47:22 <Forty-Bot> I think it only complains about the cons on the left side
09:47:31 <ski> (Forty-Bot : i refrained from mentioning some stuff that were similar to other stuff i already mentioned. you should be able to find them, and consider whether you want to change them)
09:50:06 <hrk> @pl \x y -> sum $ zipWith f x y
09:50:06 <lambdabot> (sum .) . zipWith f
09:50:56 <ski> Forty-Bot : yes, you can't match on `+:', unless you make it a pattern synonym, see <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-synonyms>
09:51:28 <ski> .. hm, i wonder whether pattern synonyms can be infix ? i suspect they will have to start with a `:' in that case (so you'd have to rename to `:+:', say)
09:51:50 <Forty-Bot> from hackage.haskell.org/package/numeric-prelude-0.4.2/docs/Algebra-Algebraic.html it appears ^/ is infixr 8
09:52:06 <ski> Forty-Bot : sorry, forgot `deriving (Eq)' could be just `deriving Eq'
09:52:24 <ski> .. and in that case, possibly it's simpler to just use `data T a = (:+:) { real :: !a, nonreal :: !a } deriving Eq' ?
09:52:46 <ski> Forty-Bot : i suspected so, since `^' is `infixr 8'
09:52:50 <Forty-Bot> are there any naming conventions for infixes?
09:53:12 <ski> presumably this `*' is still `infixl 7', so then `b * a ^/ (c - 1)' will parse as you want
09:53:34 <cocreature> spatial: there is an official spock tutorial, have you looked at that? https://www.spock.li/tutorial/
09:53:43 <ski> it's common to use a "symmetric symbol" for commutative operations
09:54:09 <Forty-Bot> this isn't really commutative, though
09:54:24 <Forty-Bot> because you get a different value for a +: b as b +: a
09:54:37 * ski nods
09:54:50 <ski> maybe `:+|' or something ..
09:55:04 <Rodenbach> Anyone here who has many years professional experience with Haskell AND Clojure?
09:55:40 <phadej> just askk your question :)
09:56:33 <Rodenbach> I don’t have a specific question, but want to talk to this person (in private).
09:57:02 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
09:57:02 --- topic: set by glguy on [Fri Jan 13 08:41:11 2017]
09:57:18 <ski> (sometimes not directly commutative, e.g. `(++)' (with `reverse (xs ++ ys) = reverse ys ++ reverse xs', so "commutative upto distributing `reverse'", probably that can be stated in another way ?),`(<*>) :: Applicative i => i a -> i b -> i (a,b)' (here (depending on `i'), you may get the same if you commute as if you swap the pair)
09:59:15 <ski> Forty-Bot : are you sure `todual' (`toDual' ?) shouldn't use `zero' instead ?
10:00:03 <Forty-Bot> ski: well, I found myself wanting a function to convert 
10:00:11 <ski> Forty-Bot : looks like your `deriv' could avoid matching on the `T a', and also use `toDual' (assuming it was meant to use `zero')
10:00:12 <Forty-Bot> when I was graphing derivatives
10:00:45 <Forty-Bot> and it has to be one or else the value gets treated like a constant
10:00:55 <Forty-Bot> and you don't get a derivative from it
10:01:12 <ski> Forty-Bot : shouldn't `toDual zero = zero' and `toDual one = one' hold ? they can't if `toDual' uses `one' like that, while `one' and `zero' uses `zero' in the infinitesimal component
10:01:43 <Forty-Bot> hm
10:02:01 <Forty-Bot> maybe I could use asconst and asvar
10:03:31 <ski> Forty-Bot : yeah, but i thought `toDual' was meant to include the plain ring elements as constants ? and anyway, `deriv' doesn't currently use `toDual' ..
10:04:29 <ski> `asVar' could be constructed with multiplication (or scaling) with `one +: one', which possibly should get a name (`identity' ? `time' ?)
10:04:45 <Forty-Bot> ok, I think that makes sense
10:05:43 <Forty-Bot> as for deriv, somehow I need to get f to apply on a T (T a)
10:05:54 <Forty-Bot> so it will calculate the 2nd derivative
10:09:00 <noan> I did it mommy, I made haskell respond to a POST request from my game project. Day is good. That is all.
10:09:32 <runeks> So, if I allocate a resource using Control.Monad.Trans.Resource.allocate, how do I either never call the release action or change what the release action is? I'm beginning a transaction using `allocate`, and setting the release action to "rollback tx", but I only want this to fire if something goes wrong, otherwise I want to do "commit tx".
10:10:20 <runeks> "unprotect" returns a cleanup action, too, so I'm not quite sure if I should be using this
10:11:05 <runeks> Is "unprotect" giving me back the release action registered using "allocate", thus allowing me to just no run it?
10:11:21 <runeks> *just not run it
10:12:36 <ski> Forty-Bot : btw, are you aware of Automatic Differentiation, <https://en.wikipedia.org/wiki/Automatic_differentiation> ? there's a package <https://hackage.haskell.org/package/ad> by edwardk. you could also check "Functional Differentiation of Computer Programs" by Jerzy Karczmarczuk in 2000-09-15 at <https://karczmarczuk.users.greyc.fr/arpap/> (you could also take a look at "Adjoint Codes in Functional Framework" if you like the other one)
10:13:11 <Forty-Bot> ski: yeah, but this is more for myself than anything else :P
10:13:39 <ski> i thought the Karczmarczuk paper was neat, when i first found it
10:15:34 * ski assumes noan must be referring to Day convolution, which was hinted at earlier
10:18:25 * ski only now notices much henning
10:21:00 <ski> Forty-Bot : it is (or at least was) possible to add a context on a data type, like your `T', but it didn't do what people expected, so we usually advice away from it. if you really want it, use GADT syntax when defining the type, and add the constraint(s) on the data constructor(s)
10:21:27 <ski> Forty-Bot : however, usually people seem to think it's nicer to only add the constraints on the operations involving the type which really needs the constraint
10:21:38 <ski> @type Data.Set.empty
10:21:39 <lambdabot> S.Set a
10:21:52 <ski> has no `Ord a' constraint, since it's not necessary in this simple case
10:21:52 <Forty-Bot> hm
10:21:59 <ski> @type Data.Set.singleton
10:22:00 <ski> nor there
10:22:01 <lambdabot> a -> S.Set a
10:22:16 <Forty-Bot> I suppose dual dumbers are general enough...
10:22:33 <ski> one *could* argue something similar re your "because it doesn't make sense to take a derivative of something else" comment
10:23:33 <Forty-Bot> do you know how to deal with the Absolute implementation?
10:24:24 <mniip> 1486141510 [20:05:10] 18<dolio> So mu in the monad is going to look like: forall a c. (exists b. M(a,b) * M(b,c)) -> M(a,c)
10:24:32 <mniip> how does that correspond with the Arrow tyclass?
10:24:35 <ski> `toDual' could possibly be made into `pointed' in `Pointed' (a type class), but only if you manage to hide the constraint (by a GADT, or perhaps by something `Yoneda'/`CoYoneda'-like) .. or maybe there's a variant of `Pointed' which allows you to specify custom constraints ..
10:25:13 <ski> Forty-Bot : perhaps you can use `ZeroTestable' instead ?
10:25:51 <Forty-Bot> Ideally, I'd like to make it instance Absolute.C a => Absolute.C (T a) where
10:25:56 <ski> (i.e., give an error yourself in case you get zero, instead of relying on `/' to error out)
10:26:50 <Forty-Bot> because then for all a -> b there is a function T a -> T b
10:27:09 <ski> in case you want the derivative of `signum' at `zero' to be undefined, rather than `one', i think you need at least `ZeroTestable' or `Field', or something of that ilk
10:30:54 <mniip> if we examine monoids in ([C^op x C, Set], (- . -), hom)
10:31:36 <mniip> then mempty is a morphism from hom to F, in [C^op x C, Set]
10:31:47 <mniip> and mappend is a morphism from F.F to F, in the same
10:31:52 <ph88> how can i pattern match on one item of a record and then return the same record while modifying that one thing ?
10:32:14 <ph88> so that i don't have to pattern match all the fields of the records and then put all the stuff back in
10:32:17 <mniip> so they are functions natural in 2 C objects
10:32:39 <Tuplanolla> Curly braces or lenses, ph88.
10:32:55 <mniip> okay, mempty is arr,
10:33:22 <mniip> but mappend is something like, uh, yes, exactly what you said
10:33:28 <ph88> Tuplanolla, i know it's something with curly braces but i forgot the syntax .. and also on the return i'm not sure
10:33:38 <mniip> but what is it
10:33:47 <mniip> it looks exactly like arrow composition
10:34:50 <noan> ski, I was infact referring to real world days and a feeling of accomplishment over the course of this day
10:34:56 <ph88> Tuplanolla, i have no (which is not compiling):   prettyPrint (IExtended terminal@Ter {t_text=(pos_t, t) }) = terminal {t_text(pos_t, '\\' : ei ++ ['\\'])}
10:35:15 <ph88> IExtended has 3 more fields but i want them unchanged
10:35:44 <Tuplanolla> You say `terminal {t_text = ...}` inside the expression, ph88.
10:36:30 <ski> > let frob tree @ Node {rootLabel = r} = tree {subForest = [Node r []]} in frob (Node 0 [Node 1 [],Node 2 [Node 3 []]])  -- ph88 ?
10:36:32 <lambdabot>  Node {rootLabel = 0, subForest = [Node {rootLabel = 0, subForest = []}]}
10:37:02 <ph88> Tuplanolla, but i want to change t_text so why i put  = ...    ?
10:37:19 <Tuplanolla> The idea is to replace the constructor `Ter` with the value `terminal` if you want to reuse existing values, ph88.
10:38:01 <ski> ph88 : is `IExtended' or `Ter' the record constructor which you want to do an update on ?
10:38:21 <ph88> I want to update on Ter
10:38:34 <ph88> good point i forgot to fmap IExtended back on :/
10:38:39 <ski> and `IExtended' is a record constructor ?
10:39:09 <ph88> data BlaBla = IExtended T    data T = Ter {4 fields here}
10:39:30 <ph88> i think i just forgot the = after  t_text  :/
10:40:22 <ski> mhm
10:42:25 <ph88> Tuplanolla, this helped, thank you    You say `terminal {t_text = ...}` inside the expression
10:42:55 <Tuplanolla> You'll definitely enjoy discovering lenses later, ph88.
10:43:11 <ph88> :D
10:43:26 <akfp> is there a generalized groupBy?
10:43:44 <akfp> something like (a -> a -> Bool) -> f a -> f (f a)
10:50:13 <abhiroop_> I was reading Gabriel Gonalez's blog on `pipes-bytestring`
10:50:19 <abhiroop_> http://www.haskellforall.com/2013/09/perfect-streaming-using-pipes-bytestring.html
10:50:23 <abhiroop_> In it he mentions
10:50:30 <Forty-Bot> ski: so I think the problem is there is no general-case fmap
10:50:38 <abhiroop_> ```
10:50:42 <Forty-Bot> only an fmap over differentiable functions
10:50:52 <abhiroop_> FreeT is smart and statically enforces that we cannot read lines from the next Producer (i.e. the next line) until we finish the first line.
10:50:58 <Forty-Bot> which are functions of the form T a -> T a
10:51:07 <deech> Hi all, does anyone know if there's a way to pull an `extra-dep` in stack.yaml from Github?
10:51:09 <Forty-Bot> or maybe T a -> b
10:52:30 <abhiroop_> So considering his example of parsing `dev/null`
10:52:41 <abhiroop_> what is the buffer size that is loaded onto memory
10:52:52 <abhiroop_> is that buffer size hardcoded in the library
10:53:21 <abhiroop_> I understand that it takes constant space
10:53:43 <abhiroop_> and the solution as mentioned in conduits is linesBounded :: MonadThrow m => Int -> Conduit Text m Text
10:54:04 <abhiroop_> where we actually mention the line size exceeding which it throws an exception
10:54:14 <abhiroop_> how is this size determined for pipes
11:00:50 <ski> Forty-Bot : hm .. can you make it into a comonad ?
11:01:10 <ski> (`T a -> b' made me wonder that ..)
11:08:25 <mojjo> hi! Anyone experienced with Aeson? I'm wondering why the following does not work:
11:08:31 <mojjo>  (fromJust $ (decode "{\"key\":1}" :: Maybe Object)) .: "key" 
11:11:12 <aureum> Hello, I have a Haskell function that consists of if-else statements
11:11:27 <aureum> I need help with iterating through a list to find a match to the input
11:12:20 <mojjo> aureum: sounds like 'filter' could be helpful..
11:12:32 <aureum> Thanks mojjo
11:12:37 <aureum> Let me look it up
11:13:48 <mojjo> filter odd [1,6,4,3,4] --> [1,3]
11:18:46 <erisco> I am unhappy with a library uses unsafe ops
11:19:10 <erisco> good 'ol unsafeInterleaveIO instead of pipes *sigh*
11:19:49 <erisco> I wonder if you can undo the damage
11:21:00 <erisco> if you're going to use unsafeInterleaveIO under the assumption foreign calls will succeed then why bother with IO at all
11:21:44 <erisco> either go full convenience or full safety... not this no man's land
11:22:17 <cocreature> mojjo: could you describe what you are trying to do with your aeson code?
11:22:50 <sternmull> is "Real World Haskell" a good way to quickly evaluate if haskell will be a good choice for a medium-sized project i plan? I am unexperienced in haskell but want to spend around a day or so to see if it is a valid choice for my purpose.
11:23:07 <erisco> in this scenario I have no issues with assuming the calls will succeed so I may as well go further and drop their IO
11:23:08 <monochrom> erisco: There are people who like lazy I/O :)
11:23:21 <Clint> sternmull: no
11:23:42 <sternmull> Clint: Any suggestions for a better approach?
11:23:53 <Clint> not offhand
11:24:07 <erisco> monochrom, I suppose there is still the opportunity to catch exceptions
11:24:29 <sternmull> Clint: What is wrong with "Real World Haskell"? Is it simply to old?
11:24:32 <erisco> I think oO
11:24:44 <monochrom> sternmull: The constant "Yes" is 70% accurate for your question. The irony is that no resource of a day is going to do better than that accuracy.
11:25:06 <erisco> though perhaps not... not entirely sure how exception handling works
11:25:26 <Clint> sternmull: it's pretty obsolete
11:25:29 <cocreature> pay someone who knows Haskell to talk with you for a day and let him answer the question
11:25:55 <dolio> 'Not working' is not the only thing that could put something in IO.
11:26:13 <erisco> sternmull, it probably is not a good choice if you want the project done soon. Same goes for choosing any new language
11:26:17 <monochrom> cocreature's answer is better.
11:26:18 <dolio> Or even the primary thing.
11:27:11 <erisco> pay someone who knows Haskell to write the code :P
11:27:22 <cocreature> if you are interested in Haskell, by all means, give it a shot. but making an informed business decision based on 1 day of research is not possible.
11:29:28 <monochrom> Publish your project requirement and accept bids. From the price quotes from the bidders, you can get a feeling of how difficult this project is.
11:29:41 <monochrom> maybe s/accept/invite/
11:30:18 <sternmull> erisco: It is a hobby project, so it is okay if switching to a new language delays it or does not really work in the end. It would be nice to have async/coroutine-stuff, nice handling of child processes, TCP/TLS and other high level things. I started with Python, prototyped with Go and also consider C++. But Haskell could be a valid choice. So i want to spend one or two days to see if it fits. But i am not sure which resources to use to q
11:31:21 <erisco> there is also Learn You A Haskell
11:31:53 <dolio> Well, there are a lot of books, but most won't cover most of those topics.
11:32:23 <erisco> it covers zippers? lol that seems like an odd topic
11:32:54 <monochrom> Learn You A Haskell is just a trailer the language.
11:33:11 <monochrom> s/trailer/trailer of/
11:33:24 <dolio> Trailer?
11:33:31 <erisco> like a movie trailer
11:33:34 <monochrom> Movie trailer. Movie preview.
11:33:45 <monochrom> Imagine a 2-hour movie preview.
11:33:52 <dolio> Oh.
11:33:59 <glguy> That sounds like a regular movie
11:34:09 <glguy> or even a long movie
11:34:24 <dolio> Imagine if movies were a week long.
11:34:59 <monochrom> Yes. My analogy is that LYAH is at the depth of a trailer but the length of a full feature.
11:35:00 <erisco> the road map is usually something like fac, fib, lists (includes laziness), Functor, Applicative, Monad
11:35:00 <Tuplanolla> Well, Das Boot wanted to be...
11:35:56 <sternmull> it is ok if there is no perfect book (which probably isn't there). A list of essential primitives/concepts to effectively use modern haskell in real applications would probably be ok for me.
11:36:05 <monochrom> Maybe next time I will paint the picture of a book report longer than the book :)
11:36:14 <erisco> and a parser fits the bill, so that is what I'd do
11:36:51 <erisco> I wonder if there are any Haskell books which use parsing
11:36:55 <monochrom> @quote monochrom fibonacci.*nature
11:36:55 <lambdabot> monochrom says: the fibonacci sequence is everywhere in nature, for example haskell tutorials and python tutorials
11:37:06 <erisco> :D
11:37:15 <Sonolin> lol
11:37:35 <monochrom> the "write scheme in 48 hours" thing uses parsing.
11:38:15 <erisco> does it derive an Applicative parser or does it grab one off the shelf?
11:38:17 <monochrom> Several textbooks also include a monadic parsing chapter.
11:38:44 <monochrom> I don't know. But the several textbooks derive their own parsers.
11:39:24 <erisco> realistically parsing is only a good through-line if you're familiar with parsing
11:39:27 <monochrom> The standard simple [T] -> [(a, [T])] story. (And usually T = Char)
11:41:07 <ski> sternmull : .. if you don't know any functional programming language already, you can expect it to take longer and more effort to get to a point where you feel comfortable getting stuff done
11:41:22 <erisco> since it is a bit esoteric and you're not really going to understand all the hubbub
11:42:54 <erisco> monochrom, lol I remember a prof telling me, iirc, that returning an empty list on a failed parse was impressive
11:43:59 <erisco> supposedly that was a leap forward at one time
11:44:26 <sternmull> ski: I first looked at haskell around 7 years ago. Back then i was unable to understand monads and even more primitive stuff. Yesterday i read an explanation of monads and had no problem to understand it. I have an idea of what it means to use a functional language with lazy evaluation. But it would be nice to have a kick-start introduction that gives me all the toys the experienced guys play with. So i can check out if this would fit my 
11:45:18 <Tuplanolla> It sounds like a trailer could work, sternmull.
11:45:28 <erisco> stop chatting and get reading! :)
11:46:49 <sternmull> i do it while i chat with you :) But i still have no idea what would be a good starting point. At the moment i am looking at wiki.haskell.org.
11:47:10 <erisco> http://learnyouahaskell.com/chapters
11:47:12 <Tuplanolla> Definitely not the wiki.
11:47:23 <Tuplanolla> It's the least coherent of all sources.
11:47:34 <erisco> the wiki is only for experts who can weed out the obsolete information
11:47:52 <Geraldus> Hi folks!
11:48:08 <sternmull> oh, i hoped the wiki would be more up to date than the other resources.
11:48:42 <erisco> it is partially an article graveyard
11:49:30 <mniip> monochrom, when will textbooks include a FreeT ((->) t) parser
11:49:43 <erisco> you can just scroll through here and pick stuff off https://wiki.haskell.org/Learning_Haskell
11:49:51 <Geraldus> Sorry about this off-chanell question, I really don't know a better place to ask (: Are there some idioms meaning (sweet) dreams which will never come true?
11:50:02 <erisco> https://wiki.haskell.org/Tutorials
11:50:18 <mniip> Geraldus, you mean delusions?
11:50:48 <ski> sternmull : suspected cut off near ".. So i can check out if this would fit my"
11:50:48 <Tuplanolla> Pipe dreams, Geraldus?
11:51:06 <Tuplanolla> Are you naming modules or variables?
11:51:10 <ski> the old wiki was more live ..
11:51:16 <Geraldus> mniip: not exactly, just something I wish to happen
11:51:28 <ski> (MoinMoin, vs. MediaWiki, iirc)
11:52:24 <erisco> there is good stuff on the wiki too, not just old things, but it doesn't guide you down any path
11:52:40 <Geraldus> Tuplanolla: Google Translate offers such translation, but I wasn't certain and decided to ask some native English people.  Also it offered "candy-floss"
11:53:12 <erisco> so you might start reading https://wiki.haskell.org/Fold which is an important topic but it might be too quick
11:54:04 <erisco> therefore it is more useful as a reference, as you'd expect wikis to be, when you already know what you need information on
11:55:19 <erisco> then you stumble on https://wiki.haskell.org/Catamorphisms and are not informed you are in the twilight zone
11:55:54 <mniip> hey ski
11:56:06 <mniip> do you happen to know what the Arrow tyclass corresponds to in CT?
11:56:19 <Geraldus> mniip, Tuplanolla, thanks )
12:00:23 <cocreature> mniip: there is this paper http://www-kb.is.s.u-tokyo.ac.jp/~asada/papers/arrStrMnd.pdf which claims to answer that question but I’ve come to the conclusion that I don’t really care about arrows before I read more than the abstract :)
12:00:59 <erisco> "nope"
12:01:06 <cocreature> mniip: without "arr" it’s a cartesian closed category iirc
12:01:18 <mniip> well
12:01:39 <mniip> I did find the resemblance between &&& and a product's mediating morphism
12:02:00 <mniip> but then ||| is a comediating morphism of a coproduct
12:02:13 <mniip> and it is somehow a subclass of Arrow (ArrowChoice) which makes no sense
12:02:17 <mniip> and then there's arr
12:02:37 <dolio> I thought we just talked about this. :)
12:02:55 <mniip> I was about to mention your dialogue with me
12:04:10 <mniip> then dolio mentions that arrows are actually profunctors that are like monads but profunctors
12:04:23 <sternmull> what do you guy think about en.wikibooks.org/wiki/Haskell? To me it looks like a good list of topics to start with. But of course i can't tell if they are really what matters or if they are of poor quality.
12:04:44 <mniip> which I guess is better explained with monoids in a monoidal profunctor category under profunctor composition
12:04:57 <mniip> though, that explains 'arr' and composition
12:04:58 <geekosaur> mniip, I think Arrow predates giving stuff CT basis, and it's a mixed-up and confused beast
12:05:15 <mniip> which suggests that arrows are closer to profunctors that compose, than to categories
12:05:21 <geekosaur> which eventually got untangled into profunctors, Control.Category, and Applicative
12:05:24 <mniip> and there's no sign of ***/&&& anywhere
12:05:33 <dolio> mniip: The last piece is the 'strong' part which gives you 'first'.
12:05:59 <dolio> M x y -> M (x, z) (y, z)
12:06:17 * ski idly wonders whether there's any witty Wadler (or other) paper mentioning "strength"
12:06:32 <dolio> mniip: I can probably find a paper that goes into all this, by the way.
12:06:32 <ski> (.. in the title, i.e.)
12:06:48 <dolio> If you want to look at that.
12:08:45 <dolio> Oh, the paper is called "Arrows are Strong Monads."
12:10:21 <mniip> please do
12:10:24 <mniip> while I brb
12:10:34 <dolio> If you google that title, it should be the first hit.
12:10:45 <cocreature> that’s the one I linked above
12:23:22 <erisco> seems there are two ways to do this... I want to write some code independent of a solver. There are just two problems I need solved
12:23:58 <erisco> I can define classes for these functions, or I can define a GADT for them
12:24:17 <erisco> in the former it is implemented by instancing the class and in the latter it is implemented by interpreting the GADT
12:24:47 <erisco> the GADT commits me to a Monad which is more syntactic noise so maybe the former is better
12:25:00 <erisco> I just get antsy about spuriously adding classes
12:28:29 <erisco> though with the class I am not sure how to make the type parameter appear in the class body, hrm
12:32:44 <erisco> yeah I don't think that works... not the way I am setting it up anyhow
12:33:18 <erisco> I guess the other way is to pass in a dictionary but that is clumsy... Reader helps but I am back to a Monad again
12:34:00 <erisco> it is quite simply that I need an X -> S where X is my problem type and S is my solution type
12:34:17 <erisco> but this needs to be given later
12:34:59 <erisco> class Solve solver where solve :: X -> S  can't work
12:35:18 <erisco> neither can   class Solve solver problem | solver -> problem where solve :: problem -> S
12:36:57 <mniip> ca
12:37:09 <erisco> reversing the dependency is a bit janky... would happen to work because there is only one solver I am interested in
12:38:56 <erisco> maybe I just don't try to untangle the solver... but I know that that is a weaker design
12:39:35 <erisco> hurts my head more to think about it that way :P
12:44:50 <mniip> "Hughes’ arrows were shown, by Jacobs et al., to be roughly monads in the bicategory Prof of profunctors"
12:44:58 <mniip> wouldn't they by monoids in that category
12:46:12 <dolio> bicategory is a sort of 2-category.
12:46:50 <dolio> 0-cells are categories, 1-cells are profunctors between categories, 2-cells are natural transformations.
12:49:31 <dolio> If you take the 1 and 2 levels of a bicategory above a single 0-cell (so, the endo-1-cells), you get a monoidal category. And the monads in the bicategory are monoids in the monoidal catgory.
12:50:22 <dolio> I should say, my description was of what the Prof bicategory is.
12:51:01 <dolio> A bicategory in general has 0-cells, 1-cells between pairs of 0-cells, and 2-cells between pairs of compatible 1-cells.
12:51:22 <dolio> And identities and composition and whatnot.
12:54:12 <mniip> I don't think I have that strong of a grasp on higher CT
12:54:30 <dolio> You can also make any monoidal category into a 1-object bicategory, and then the monoids in that monoidal category are monads in that bicategory.
12:55:17 <dolio> Kind of similar how you can make a monoid into a 1-object category.
12:58:27 <dolio> mniip: The 'obvious' example is category theory and monads.
12:58:51 <dolio> There's a bicategory with categories as the 0-cells, functors as the 1-cells and natural transformations as the 2-cells.
12:59:23 <dolio> And monads in that bicategory are the usual definition of monads.
13:00:09 <dolio> And when people talk about monads being monoids, that's taking one category (0-cell) and considering the monoidal category of endofunctors (endo-1-cells) and transformations.
13:01:16 <mniip> right
13:01:17 <dolio> Bicategories and monads in a bicategory let you talk about them within one whole structure instead of a bunch of similar ones.
13:05:25 <mniip> I have no idea what any of that means :p
13:18:13 <monochrom> erisco: In 1985, Wadler actually made the paper "how to replace failure by a list of successes", and it actually got accepted to a conference. So apparently the idea was considered impressive in the early days.
13:19:34 <monochrom> Although, the subtitle "a method for exception handling, backtracking, and pattern matching in lazy functional languages" was more impressive.
13:20:26 <monochrom> Sometimes you've got to measure an idea not by how easy to explain the solution, but how long it took the research community to think it up.
13:21:34 <monochrom> It was impressive to say "I have a way to unify exception and backtracking". (I think it still is.) You just feel anti-climatic because the punchline is "use [a]".
13:23:48 <bbear> what language should I learn next ?
13:23:50 <bbear> now ?
13:23:53 <bbear> Why ?
13:23:55 <bbear> Java ?
13:24:05 <monochrom> Today I would explain the idea level-headed and wouldn't make a big fuss about it, to be sure. It's 2017 already, we don't get easily excited by while-loops and the [] monad.
13:24:15 <bbear> []
13:24:18 <bbear> []
13:24:20 <bbear> []
13:24:25 <bbear> \o/ monochrom
13:25:51 <bbear> was wondering if digging into real project is better for learning the language
13:25:59 <bbear> than doing noob tutorials.
13:26:05 <bbear> noob is not pejorative here
13:26:26 <mniip> huh
13:26:44 <mniip> if F is a functor C^op x C -> D, what does F(C, f) denote?
13:26:48 <bbear> looking into that https://wiki.haskell.org/Web/Frameworks that's plenty of meat 
13:27:10 <mniip> F(id_C, f) ?
13:28:46 <bbear> monochrom: do you have a job ?
13:30:10 <monochrom> Not at the moment.
13:31:23 <bbear> what are you doing ?
13:31:38 <monochrom> Learning linear algebra.
13:31:46 <bbear> how old are you ?
13:31:53 <monochrom> No comment.
13:32:19 <Tuplanolla> Old enough to learn linear algebra, I hope.
13:32:23 <bbear> are you working with infinite dimensions or not yet ?
13:32:24 <mniip> what kind of linear algebra :o
13:32:34 <monochrom> Still finite dimension.
13:33:27 <monochrom> Finite dimension, complex scalars, the standard inner product, unit vectors under the 2-norm, unitary matrices and self-adjoint matrices.
13:33:30 <bbear> but why are you learning linear algebra ? Is it R-algebra or C-algebbra ?
13:33:49 <mniip> monochrom, that sounds simple enough
13:33:51 <bbear> monochrom: that's trivial matter for undergrad students in most countries
13:33:57 <bbear> well not so trivial
13:34:12 <bbear> but still that's the ground on which you build mathematics
13:34:17 <monochrom> If you think that my secret agenda is quantum something, you're right.
13:34:19 <bbear> at a higher level.
13:34:41 <mniip> monochrom, somehow you gave an impression of already knowing that :o
13:35:42 <bbear> well being able to define mathematically a monad gives you extra buckets that will pay your ticket outside of undergrad zone I would have bet but may be i am mistaked.
13:36:00 <bbear> and quantum mechanics is cool as well.
13:36:05 <mniip> bbear, can you define a monad?
13:36:08 <bbear> nope
13:36:10 <Tuplanolla> Where are we going with this, bbear?
13:36:17 <bbear> Nowhere 
13:36:21 <bbear> absolutely nowhere
13:36:27 <mniip> idunno, I know 3 definitions and they are yet to come up useful :P
13:36:50 <bbear> 3 definitions
13:36:56 <monochrom> I can define 5 monads.
13:37:40 <mniip> no like, define what a monad is in 3 separate ways
13:38:19 <mniip> maybe 6
13:38:33 <mniip> er, I meant maybe 4
13:38:38 <bbear> !monad
13:38:41 <mniip> your 5 distracted me
13:38:52 <bbear> mniip: anyway. Linear algebra is kewl
13:38:57 <mniip> sure is
13:39:26 <dmwit> mniip: I think F(C, f) denotes (f.)
13:39:29 <monochrom> I can do 2 off the top of my head. The usual 2 anyway. I can do 2 more if you let me re-watch some catster lectures first. (The Kleisli story and the Eisensomething story?)
13:39:35 <mniip> dmwit, and that is?
13:39:57 <dmwit> like, \g -> f . g
13:40:12 <mniip> monochrom, NTs, monoids, kleislis, and then specifically monoids in Hask as polymorphic data structures
13:40:47 <dmwit> mniip: Never mind. I'm confused and thinking of the Hom functor, which F is not necessarily. Sorry.
13:41:27 <bbear> scala is ok for FP ?
13:41:28 <byorgey> monochrom: Eilenberg-Moore?
13:41:36 <monochrom> yeah that one
13:41:56 <byorgey> yeah, I'd have to rewatch the catster lectures too =)
13:42:06 <byorgey> I'm just good at remembering names.
13:42:23 <mniip> I'm yet to learn what that is :p
13:42:28 <dmwit> mniip: Yes, I think F(id_C, f)
13:42:46 <dolio> dmwit: Which specializes to what you thought for the case of hom.
13:42:52 <mniip> dmwit, yeah that'd make sense
13:43:22 <merijn> nitrix: Can you explain what you meant with you 'Link' type you mentioned earlier today?
13:43:49 <knupfer> These join points are so intriguing!
13:44:10 <dmwit> mniip: As I recall from the one or two pages of MacLane that I managed to read, some people don't even both defining objects in the first place, using the id arrows as the objects.
13:44:29 <dmwit> mniip: Perhaps whatever source you're perusing is making that identification.
13:45:34 <dolio> I don't think so. Putting an object name in like that is common.
13:46:34 <dolio> Like, if F(g,h) is `bimap g h`, F(C,h) is how `second h` is written.
13:47:36 <dolio> second@C h
13:48:00 <nitrix> merijn: In my implementation (this is very old and I was new to Haskell), a Link would look like this:
13:48:34 <nitrix> merijn: data Link = MkLink { linkId :: Integer, linkRef :: IORef (Maybe (Weak (IORef a))) }
13:49:05 <nitrix> merijn: All the functions to manipule the links would have this Linkable constraint: type Linkable a = (Typeable a, FromJSON a, ToJSON a)
13:49:08 <pikajude> where does the `a` come from?
13:49:27 <nitrix> Sorry, add the `a` parameter, my bad.
13:50:05 <merijn> nitrix: ah, I think the problem with mimicing that is that my datatypes are generated by persistent and backed by an SQL database.
13:50:27 <merijn> nitrix: So I can't copy that approach. And I'm pretty sure persistent can do what I want, I'm just not sure how :p
13:50:54 <nitrix> merijn: The idea is that a Link would contain the id of a resource, and as the application was resolving dependencies between things that are linked, it'd load from disk the data and update the IORef.
13:51:36 <nitrix> merijn: I don't loose type information :/
13:52:34 <nitrix> I had an interesting system that'd maintain only the N most recently used resources and unload the ones not needed, hence the Weak pointer.
13:52:53 <nitrix> Essentially, lazy relations x]
13:53:42 <nitrix> It was quite the idea. I've had multiple iterations. The latest is the most sane, and it lets you chose the storage of your choice, but I'm still not ready to publish it.
13:54:04 <nitrix> It has a cute monad transformer too :D
13:55:32 <nitrix> gameState @> player @> inventory @> money %~ (+100)
13:56:14 <nitrix> Where that player is a Link Player. Multiple things in the game would use this Link Player instead of the actual Player. Like the word map, guilds, friend lists, etc.
13:56:28 <pikajude> Link Player, lol
13:57:11 <nitrix> Laugh all you want. When you'll need to figure out how to do O(1) relational data in Haskell I'll be the one laughing :P
13:57:14 <merijn> nitrix: Yeah, but I'm using SQLite anyway for persistence reasons :)
13:59:00 <pikajude> nitrix: this sounds like a great setup to make a Zelda game in Haskell
13:59:46 <nitrix> The newer version uses the names Cell, Relation and Relational.
14:00:24 <nitrix> I haven't looked at it in a while but it's much less ridiculous, I agree.
14:00:57 <jophish> Are there any nice high-level libraries for shared memory between processes?
14:01:31 <merijn> jophish: I don't think any amount of high-level can make that nice... :)
14:01:42 <nitrix> readLink :: Linkable a => Context -> Link a -> IO (Maybe a)
14:02:08 <nitrix> merijn: O(log n) first read, O(1) for subsequent reads and writes.
14:02:13 <jophish> merijn: you're probably right. It should be possible to go beyond "here's a buffer, deal with it"
14:02:25 <merijn> jophish: What's the end goal?
14:03:49 <nitrix> merijn: The problem with all of it is that after trying to make it pure, removing the IO, using dirty hacks, infinite lists, time varying functions, I had basically re-created FRP.
14:04:02 <nitrix> Hence why I was so interested in it and why I bring it up often.
14:04:18 <jophish> merijn: Some short lived processes which need to pass some information back to a long lived master process
14:04:36 <jophish> a linux fifo might be best
14:05:17 <merijn> jophish: Yeah, go with a pipe, IMO
14:05:46 <merijn> Way easier to deal with
14:05:47 <jophish> I think I got carried away trying to think of a nice way to handle a shared buffer in haskell :)
14:07:30 <merijn> jophish: I'm still working on high-level mmap for haskell :p
14:08:04 <merijn> Because mmap == best syscall :D
14:10:24 <jophish> It is a pretty good one
14:11:28 <merijn> mmap is like compilers in terms of tools, when you know it everything starts to look like an mmap/compiler problem ;)
14:12:20 <pikajude> everything can be reimplemented in terms of mmap
14:13:55 <Gurkenglas> Can I make stack ghci hide the import list? Can I make it keep the stuff I import imported?
14:14:02 <Gurkenglas> *between sessions
14:15:23 <merijn> Gurkenglas: You can import stuff in a .ghci file that gets run automatically
14:15:45 <merijn> Gurkenglas: For example: https://github.com/merijn/dotfiles/blob/master/dotfiles/ghci
14:16:13 <Gurkenglas> I put that in the global project, I guess?
14:16:22 <merijn> Gurkenglas: I have no clue about stack
14:16:28 <merijn> Gurkenglas: I just have that in ~/.ghci
14:23:28 <erisco> why not coeffects, sigh
14:23:31 <erisco> then this would be trivial
14:24:15 <erisco> I am serious when I say it is one of the best ideas for practical programming
14:24:26 <erisco> solves so many headaches
14:24:33 <Lokathor> i don't know what coeffects are
14:24:43 <Lokathor> and i have a throbbing headache from sickness
14:24:52 <Lokathor> a test: can you still get me to understand them?
14:24:57 <erisco> http://tomasp.net/coeffects/
14:25:18 <Lokathor> we'll call that a "soft fail"
14:25:42 <Lokathor> you tried hard, but were beaten by the afore mentioned throbbing headache alsmost as soon as i opened the page and saw how much text there is
14:26:10 <erisco> the TLDR is free variables become part of the type
14:26:17 <Lokathor> oh cool
14:26:18 <erisco> known as the context
14:26:28 <Lokathor> burritos are like a context
14:26:36 <Lokathor> ;3
14:26:54 <nitrix> A delicious context.
14:28:00 <erisco> so now you can easily write code in a sort of ad hoc generic manner
14:28:43 <monochrom> What is coeffect?
14:28:49 <erisco> DI, dictionaries, type classes ... all these things can be used like that
14:29:05 <Lokathor> DI = Directional Influence, right?
14:29:18 <erisco> dep injection
14:29:28 <erisco> IoC also relevant
14:29:48 <Lokathor> does one even do dependency injection outside of an OO context?
14:30:16 <erisco> monochrom, I think it is a bit of a play with words
14:30:27 <Gurkenglas> :t [undefined :: AnIso s t a b, undefined :: Optic (Costar f) g s t a b, _Unwrapping Sum] -- Removing either of the first two makes this well-typed. (They are the types of the first arguments of au and auf.) Why isn't this well-typed?
14:30:29 <lambdabot> error:
14:30:29 <lambdabot>     • Couldn't match type ‘Control.Lens.Internal.Iso.Exchange
14:30:29 <lambdabot>                              (Sum b) (Sum b1) (Sum b) (Identity (Sum b1))’
14:30:35 <erisco> Lokathor, absolutely. That is what dicts and Reader and so on are about
14:30:40 <erisco> and TCs are used for this sometimes
14:31:06 <erisco> different mechanism than in OO but same idea
14:31:18 <Lokathor> ah hmm
14:31:53 <erisco> monochrom, I think loosely they mean that effects come out and coeffects go in
14:32:44 <erisco> the PITA with Reader is now you're committed to Monad
14:33:03 <erisco> and while do-notation helps a bunch it still isn't as pleasant as not needing it at all
14:33:22 <Gurkenglas> "If the device visiting your client/server application does not have clock, the coeffect can use clock available from the server." <- you accidentally article
14:33:23 <Jello_Raptor> What should I call the following? `newtype Foo a b c = (Monad a, Monad b) => Foo { getFoo :: a (c,b ())}` which has the instance `k >>= f = Foo $ do { (v,d) <- k ; (v',d') <- f v ; return (v', d >> d'); }` ? 
14:34:14 <Jello_Raptor> basically, run one monad that sends out "instructions" in another monad that are all chained together? 
14:34:37 <Gurkenglas> Looks like a writer monad with the monoid being outputless monad actions
14:34:49 <Jello_Raptor> yup, pretty much 
14:35:45 <Jello_Raptor> is there some straightforward way to construct that out of a writer? (a newtype wrapper that gives me a monoid instance using ">>") 
14:36:00 <monochrom> Interesting, erisco.
14:36:39 <Gurkenglas> So I'd do `newtype Foo m = Foo { getFoo :: m () }`, give "Monad m => Foo m" a monoid instance, and use WriterT (Foo b) a c
14:36:56 * Jello_Raptor nods at Gurkenglas 
14:38:04 <Jello_Raptor> still needs a name though. :P 
14:38:57 <Gurkenglas> "Silent"? "Scribing"? *looks though ekmett's libraries*
14:39:16 <Jello_Raptor> Scribe is pretty good
14:39:33 * Jello_Raptor wonders if it follows the MonadTrans laws, goes to check
14:40:20 <merijn> Is there like a yesod/persistent channel?
14:40:24 <rblaze> is there any runtime difference between newtype Foo = Foo String and newtype Foo = Foo { unFoo :: String }? I'm not sure about record layout in haskell.
14:40:29 <Gurkenglas> That'd be for the ($()) Foo of course, not your first - that one is emergent enough not to deserve a simple name
14:40:31 <Jello_Raptor> yes it does if I swap the arguments 
14:41:07 <merijn> rblaze: No
14:41:21 <merijn> rblaze: Well, there is a difference in that the letter will generate an accessor for you
14:41:31 <merijn> rblaze: But no difference in memory
14:41:50 <erisco> if you've ever seen the dreaded x = y; f(); calling convention, coeffects is actually a bit like that but typed (and no mutation in a pure lang of course)
14:41:51 <merijn> s/letter/latter
14:42:43 <erisco> the reason you're seeing that convention, at least when used most intelligently, is because there is then a series of calls all using the same assignment
14:42:43 <Jello_Raptor> Gurkenglas: mhmm
14:42:53 <erisco> *cough* OpenGL
14:43:23 <rblaze> merijn: thanks. Do you know any short doc on records implementation? I'd like to learn a bit about it.
14:43:33 <Gurkenglas> (except for those names applications can always use like "GameState" and "MyApp")
14:43:50 <merijn> rblaze: Records aren't really different from non-records
14:44:07 <merijn> rblaze: IN fact, you can use non-record pattern matching on records and vice versa
14:44:28 <merijn> @define data Foo = Foo { unFoo :: String } deriving (Show)
14:44:30 <lambdabot>  Defined.
14:44:38 <merijn> > let x = Foo "test" in x
14:44:42 <lambdabot>  Foo {unFoo = "test"}
14:44:47 <merijn> > let Foo x = Foo "test" in x
14:44:49 <lambdabot>  "test"
14:45:00 <monochrom> rblaze: The Haskell 2010 Report describes the record syntax completely. It is a fairly shallow syntax sugar.
14:45:10 <merijn> > case Just True of Just{} -> 'a'; Nothing -> 'b'
14:45:12 <lambdabot>  'a'
14:46:08 <Tuplanolla> > Nothing {}
14:46:10 <lambdabot>  Nothing
14:46:21 <mniip> > (){}
14:46:23 <lambdabot>  ()
14:46:29 <Gurkenglas> erisco, what's the difference between implicit type parameters in Haskell and coeffects?
14:46:30 <merijn> Tuplanolla: For a cool trick:
14:46:30 <mniip> ok that's one I did not know
14:46:44 <monochrom> erisco: When writing in BASIC, I used to use that idiom "formal_param = actual param; gosub 450"
14:47:17 <merijn> > [x | x@Left{} <- [Left 'c', Right True, Left 'b', Right False]] -- <- future proof should the number of fields of 'Left' change
14:47:19 <lambdabot>  [Left 'c',Left 'b']
14:47:57 <mniip> "should the number of fields of 'Left' change"
14:48:19 <merijn> mniip: Unlikely for Left, but not for other constructors
14:48:37 <merijn> mniip: You can future proof parts of your code that way if you don't care about fields
14:48:51 <erisco> Gurkenglas, they are similar and I am not sure where the differences lie
14:50:46 <reactormonk> I want to lift https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/Cabal-1.24.0.0/Distribution-PackageDescription-Parse.html#v:parsePackageDescription such that I have the exact string position of every element that's parsed? Would it be easier to write a new one?
14:50:52 <Tuplanolla> :t has _Left
14:50:54 <lambdabot> Either b c -> Bool
14:52:56 <reactormonk> ... probably too nasty.
14:55:48 <dedgrant> Can [https://wiki.haskell.org/Foldl_as_foldr#foldl_which_may_terminate_early] be viewed as an instance of shortcut fusion? Is this what shortcut fusion is supposed to do?
14:58:25 <qmm> servant's hello world example seems to be more modular 
14:58:46 <qmm> i'm wondering how to make scotty a little more modular
15:00:08 <qmm> suggestions on how to extract the route handlers so there isn't  get root $ do ... get "/:word" do in a large IO block
15:00:12 <qmm> ?
15:01:01 <erisco> Gurkenglas, I think I can use them quite effectively here so thanks for reminding me of them
15:01:20 <qmm> i guess i could do
15:01:40 <qmm> get foo $ fooRoute
15:05:31 <erisco> you're programming right when the types are twice as long as the terms
15:27:39 <erisco> and when your comments reduce to some propositions... nice place to be
15:27:58 <Lokathor> erisco, sounds like you need more descriptive term names
15:28:14 <Lokathor> and like you need better comments
15:28:19 <erisco> actually I've gone for more than one letter this time :P
15:28:38 <erisco> the English can only vaguely explain what the precise language can
15:28:49 <Lokathor> the fact that haskell looks like math sometimes, and people think that's bad, to me means that math just has garbage for notation that should not be imitated.
15:29:54 <erisco> can you really imitate those parts of it?
15:30:31 <Lokathor> i've used Haskell for two years now and I still use java style nameTheWholeThing variables as much as possible
15:30:39 <Lokathor> in any code i expect to need to understand later
15:31:09 <Lokathor> because "some random person trying to learn the code base 6 months from now" is usually me
15:31:23 <erisco> I'm in the camp that believes verbosity can be superfluous
15:31:46 <erisco> for example, I say ncol, instead of numberOfColumns
15:31:59 <Lokathor> well, given other context, that might be a fair shortening
15:32:20 <Lokathor> but i've yet to see any other Haskell code that i'd ever call too verbose
15:32:50 <erisco> I'm happy to use single letters when the type already says everything
15:33:07 <erisco> when I say ncol it is relevant because the kind is Nat, and who knows otherwise what I am using this Nat for
15:33:17 <Tuplanolla> I'd use longer names if Vim's autocompletion wasn't so bad.
15:33:35 <Lokathor> Tuplanolla, did you know that there's a build tool called tup?
15:33:42 <Tuplanolla> Yes.
15:33:43 <Lokathor> it's jsut the first thing your name made me think of
15:33:45 <erisco> when I say p it is not ambiguous because it has the type Puzzle and things of type Puzzle are just puzzles
15:34:01 <Lokathor> if there's a "TQueue InputEvent" i'll still call it inQueue instead of i
15:34:58 <erisco> just like if I was using an Int really as just an Int, say when writing fac, I am just going to call it x or n
15:35:01 <Lokathor> Tuplanolla, maybe you should consider an editor with better copy and paste support :3
15:35:20 <erisco> whereas if it is a dimension then maybe I call it width or height
15:35:21 <yushyin> I do it like this, the length and descriptively of my identifiers are proportional to there scope
15:35:27 <Tuplanolla> I don't see the connection, Lokathor.
15:35:53 <yushyin> their*
15:36:06 <Lokathor> Tuplanolla, you said that lack of auto-complete hindered your desire for longer identifiers. If there's something that's long enough i'll just copy it and paste it into wherever else it's used
15:36:33 <Lokathor> but I don't use autocomplete in haskell so perhaps i'm considering it from the wrong angle
15:36:34 <Tuplanolla> Vim can already access X11, GTK+ and internal register clipboards. The problem is that I can't keep twenty registers in my head.
15:37:25 <Lokathor> you gotta pick a naming style and stick to it, is all the advice i can give
15:37:36 <Lokathor> if short names are your style then that's managable i guess
15:37:52 <erisco> iNVERTEDlOWERcAMELcASE
15:38:01 <Lokathor> yes that
15:38:26 <Lokathor> let's see, my very most recent haskell writing would be.. this https://github.com/Lokathor/galaxy-break/blob/master/src/Main.hs
15:38:40 <Lokathor> a text game demo that's already running 3 threads at once!
15:38:44 <Tuplanolla> Typing `liftIO $ async $ bracketCont msgChan ThreadClock $ fix $ \ again -> do` should only require `lif<Tab>$asy<Tab>$br<Tab>msg<Tab><Tab>C$fix$\a<Tab>->do` and the rest would come from a properly trained Markov chain completion algorithm.
15:38:52 <erisco> lol, mk? rand?
15:38:57 <erisco> what is this
15:39:31 <Lokathor> Tuplanolla, you've got some wild ideas there
15:39:37 <Lokathor> erisco, did you mean to me?
15:39:56 <erisco> I am just teasing
15:40:08 <erisco> your code looks neither more nor less verbose than I typically see
15:40:10 <merijn> hmmm
15:40:11 <systadmin> hi
15:40:19 <Lokathor> SPJ himself uses mkValue constructors :P
15:41:25 <merijn> Any Conduit users? I have a function "Consumer Foo m r -> Consumer Foo m r" which won't accept my "ConduitM Foo Foo m r" how can I beat it into working? Or will it simply not work with those types?
15:41:35 <erisco> it is fine because everyone knows what mk means
15:48:53 <erisco> how might you document the length function
15:49:24 <Lokathor> "this returns the number of entries within this functor"
15:49:37 <erisco> that isn't what length does oO
15:49:46 <Lokathor> :t length
15:49:48 <lambdabot> Foldable t => t a -> Int
15:49:53 <Lokathor> Foldable*
15:50:12 <erisco> what is an entry?
15:50:27 <Lokathor> the 'a' part in 't a'
15:50:42 <erisco> so is the answer always 1?
15:50:49 <Lokathor> no
15:51:01 <Lokathor> in fact it's rarely one i suspect
15:51:16 <erisco> I only see one "a" :P
15:51:30 <Lokathor> in a [Int], it's the number of ints, in a Maybe String, it's how many strings you have, and so on
15:52:00 <Lokathor> it's an easy argument to makt that there's more to it than one sentence, but IRC doesn't lend itself to "more than a sentence" things
15:52:05 <erisco> is [1,1,2] 3 Ints or 2?
15:52:13 <Lokathor> it's three of them
15:52:14 <wonder924> where does the "nofib" benchmark suite get its name "nofib" ?
15:52:40 <erisco> is [undefined,undefined,undefined] 3 Ints or 2?
15:52:50 <Lokathor> still three :P
15:52:56 <yushyin> 'Returns the size/length of a finite structure as an Int.' says the doc
15:53:22 <Lokathor> yushyin, but how *would you* write it?
15:53:49 <erisco> how many Ints is (1,2) ?
15:53:59 <Lokathor> oddly, just one
15:54:06 <Lokathor> because of how the Foldable is defined for (.)
15:54:08 <Lokathor> (,) *
15:54:26 <mniip> > length (1,2)
15:54:28 <lambdabot>  1
15:54:32 <mniip> yup
15:55:26 <erisco> I am just highlighting that despite the explanation seeming clear it really doesn't tell us much
15:55:51 <yushyin> Lokathor: yeah, but because of your discussion I was curious what is written in the documentation :)
15:56:10 <jle`> maybe length can be defined as the length of the list returned by toList
15:56:14 <erisco> even if we just consider the old length before Foldable was put in Prelude, i.e. lists only, the explanation is not clear
15:56:21 <Lokathor> if i had written a whole deal about Foldable earlier in the module, as I would have naturally, I think it would explain plenty
15:56:57 <erisco> it leaves a lot for the reader to figure out
15:57:19 <erisco> when we write such comments we're really just trying to tip the reader off to these facts that are more complicated to explain
15:57:32 <Lokathor> of course, you'd still want to give some examples, hopefully in code blocks that the compiler can auto-test during testing (hey-o rust!) and exaplin any gotchas such as with tuple
15:57:48 <erisco> which is fine, but you cannot blame one for wanting to be more precise as well
15:58:11 <Lokathor> i suppose
15:58:31 <erisco> I really don't know how to explain length precisely other than with the definition itself
15:58:31 <Lokathor> I'd say that the explanation required is often proportional to the difficulty of setting up a proper ability to test it out yourself
15:58:49 <Lokathor> so with length, you don't have to say much, it's easy to test
15:59:10 <Lokathor> with a websocket library you want to explain more because it's pretty mysterious if things don't work what went wrong
15:59:27 <erisco> you might add other facts though, such as 0 <= length xs
15:59:35 <Lokathor> well
15:59:46 <Lokathor> length is mistyped in the first place I'd say
15:59:50 <Lokathor> it should be Word
16:00:02 <erisco> and  length xs + length ys = length (xs ++ ys)
16:00:07 <Lokathor> but it's not for ergonomic reasons
16:00:24 <Lokathor> :t (++)
16:00:30 <lambdabot> [a] -> [a] -> [a]
16:01:00 <Lokathor> :t (<>)
16:01:03 <lambdabot> Monoid m => m -> m -> m
16:01:09 <Lokathor> ah right, here we go
16:01:28 <jle`> > length (("a","b") <> ("c","d"))
16:01:30 <lambdabot>  1
16:01:42 <jle`> > length ("a","b") + length ("c","d")
16:01:44 <lambdabot>  2
16:02:16 <Lokathor> > (("a","b") <> ("c","d"))
16:02:18 <erisco> well as I tried to make clear I am only talking about lists at this point
16:02:19 <jle`> length xs + length ys = length (toList xs ++ toList ys)
16:02:19 <lambdabot>  ("ac","bd")
16:02:20 <geekosaur> wonder924, iirc it replaced an older benchmark suite "fibon"
16:03:01 <Lokathor> erisco, "length gives you the number of items in the list", if that's not enough for you i'm not sure how to help
16:04:39 <wonder924> geekosaur: interesting! Any idea why "fibon" was named so ?
16:05:05 <geekosaur> no, I barely recall it as old lore. not much mention on ghc wiki either
16:05:18 <erisco> Lokathor, well as I pointed out it comes down to defining "item" and "number of"
16:05:18 <geekosaur> I would hguess fibonacci, but ...
16:05:48 <erisco> if this were something other than lists then we could be genuinely confused
16:06:51 <erisco> it really has nothing to do with the items or elements but rather it counts :
16:07:54 <erisco> "length counts the number of cons in the list"
16:09:53 <erisco> as for the Foldable length I think you'd have to talk in terms of toList
16:10:54 <erisco> granted this is just folding with the list constructors so you might break it down more
16:11:09 <jle`> maybe, for Foldable f => f a, toList gives the number of a's ?
16:11:18 <jle`> er, length
16:14:28 <mniip> hahaha
16:14:39 <mniip> someone who does toList (3, 5) is in for a great surprise
16:15:05 <erisco> > toList (3, 5) -- okay I'll bite
16:15:07 <lambdabot>  error:
16:15:07 <lambdabot>      Ambiguous occurrence ‘toList’
16:15:07 <lambdabot>      It could refer to either ‘F.toList’,
16:15:14 <erisco> shock! horror!
16:15:48 <mniip> > Data.Foldable.toList (3, 5)
16:15:53 <lambdabot>  [5]
16:19:46 <erisco> you'll also get a surprise doing listPlease (3, 5)
16:20:11 <mniip> :t listPlease
16:20:13 <lambdabot> (t, t1) -> [Char]
16:20:25 <mniip> my parametricity sense is tingling
16:20:38 <erisco> darn, I wasn't expecting your trap disarming skill to be so high
16:22:16 <Tuplanolla> > Data.Foldable.toList (True, 'T')
16:22:18 <lambdabot>  "T"
16:22:26 <mniip> > listPlease (1, 2)
16:22:29 <lambdabot>  "No list for you!"
16:22:32 <mniip> ha
16:22:52 <mniip> that was a surprise because I was expecting "surprise" literally
16:23:18 <erisco> the joke is lame but not *that* lame :P
16:25:45 <mniip> erisco, I updated and improved your listPlease function :)
16:25:59 <erisco> > listPlease (3, 9)
16:26:02 <lambdabot>  No list for you!
16:26:08 <erisco> now in IO
16:26:20 <mniip> er no, lambdabot doesn't do IO
16:26:29 <erisco> :t listPlease
16:26:30 <lambdabot> (a, b) -> List a b
16:27:09 <mniip> your trap disarming skills could use some training :p
16:27:10 <erisco> show instance?
16:27:40 * geekosaur was guessing it used Doc, but other custom Show instance would do as well
16:29:11 <erisco> I would expect there to be a Sing Nat -> Nat conversion somewhere
16:29:44 <erisco> no no, I mean SNat n -> Nat conversion
16:29:57 <erisco> which is a Sing (n :: Nat) -> Nat conversion
16:30:30 <erisco> wish you could hoogle packages more easily
16:34:35 <planetstarbucks> #haskell-beginners
16:35:52 <erisco> sNatToInt
16:36:06 <erisco> a bit hidden because it sends to Num rather than specifically Nat
16:36:49 <Welkin> lol erisco 
16:36:57 <Welkin> still going on that
16:37:07 <erisco> it is the new hotness
16:38:39 <erisco> lol, a bit strange to write f x where f = const y and actually have it matter what x is
16:39:19 <erisco> it projects information out of the type of x
16:39:29 <erisco> kinda freaky! :)
16:39:44 <Welkin> astral projection!
16:45:45 <monochrom> @type asTypeOf
16:45:46 <lambdabot> a -> a -> a
16:46:22 <monochrom> That one also does const but extracts type.
16:46:36 <Welkin> how can it extract the type?
16:46:40 <Welkin> types don't exist at runtime
16:46:56 <geekosaur> it's just const with a type signature
16:46:58 <monochrom> Sure, I am not using precise wording. You have a better word?
16:47:07 <geekosaur> :t const
16:47:09 <lambdabot> a -> b -> a
16:47:17 <Welkin> no, I am just cursious what you mean
16:47:49 <geekosaur> now just give it a type signature that forces b ~ a
16:48:21 <monochrom> Perhaps I'll stick to "astral projection".
16:48:40 <Zemyla> Types sometimes exist. Like with Typeable.
16:49:29 <mniip> those aren't types
16:49:44 <mniip> that's type information
16:49:48 <monochrom> People really like to pick and argue, no?
16:49:55 <mniip> yeah
16:50:29 <erisco> Welkin, well with GADTs you have some information
16:50:43 <nshepperd> typeclass dictionaries exist at runtime!
16:50:53 <mniip> erisco, only dicts and coercions!
16:50:56 <nshepperd> (and that's what sNatToInt is using)
16:50:59 <erisco> yes
16:51:10 <Zemyla> @let data Dyn' where { Dyn' :: (Typeable a) => a -> Dyn' }
16:51:12 <lambdabot>  Defined.
16:51:19 <erisco> but you can also do this statically. geekosaur gives one example
16:51:32 <bennofs2> Can anyone tell me what I'm doing wrong here? https://github.com/bennofs/repros/tree/master/ghc/ffi-segfault
16:51:43 <bennofs2> running script.sh gives segfault
16:52:39 <geekosaur> failing to return p from make_struct?
16:53:24 <bennofs2> geekosaur: wow... thanks!
16:53:31 <bennofs2> geekosaur: such obvious
16:54:41 <monochrom> The type checker of C ought to flag this.
16:55:05 <bennofs2> I should've turned on warnings for the c compiler...
16:55:13 <geekosaur> -Wall should have caught it. for historical reasons it's not a default
16:55:23 <geekosaur> (K&R has many sins to answer for)
16:55:42 <bennofs2> Or, wait a minute, didn't I just ignore some warning because it didn't look relevant? lol
16:56:12 <Gurkenglas> It is said that https://wiki.haskell.org/Roll_your_own_IRC_bot is bad. Should that page be marked as deprecated, then? Should https://github.com/bitemyapp/learnhaskell/blob/master/code_to_learn_from.md stop linking there?
16:56:48 <monochrom> Is it also said why the page is bad?
16:57:09 <erisco> can anything be as bad as the invention of null, though
16:57:24 <geekosaur> and also that should probably have warned even without -Wall because its return type isn't (int)
16:57:31 <monochrom> The perpetuation of null is worse than the invention of null.
16:58:01 <erisco> all your data may or may not exist. Have fun programming!
16:59:05 <hpc> null is self-perpetuating though, because of the train of thought it has created
16:59:16 <hpc> try and take it away, and people will think you would rather be using -1 as "null"
17:00:04 <monochrom> I almost thought you were to say "give them the hope of null, then take it away" :)
17:01:28 <hpc> no, that's C++ references
17:02:07 <Welkin> null and undefined
17:07:17 <erisco> is it bad to kind restrict in data/newtype parameters?
17:08:27 <monochrom> Probably yes but don't worry too much.
17:11:20 <erisco> I look and, for example, :k Vector :: * -> Nat -> *
17:12:12 <erisco> so that actually forces me to add the same constraint to my types should they be defined with Vector
17:13:19 <monochrom> Ah but that's because Vector is actually a container of real data.
17:14:06 <monochrom> No one is going to really request "i_want_to_implement :: Vector Either 5"
17:14:34 <erisco> I am referring to Nat moreso
17:15:16 <monochrom> OK, but the Nat there is under even less need to generalize.
17:16:38 <erisco> was it ever really a point of need when it came to contexts? I thought the point was we don't know the needs ahead of time
17:17:29 <monochrom> OK, there is a balance between how much you can generalize and how much you can implement.
17:18:23 <monochrom> I know how to implement "Vector (IO Int) 10". I don't know how to implement "Vector IO [Int]".
17:19:19 <monochrom> And I suspect that if one day someone claims to "need Vector IO [Int]" it is likely going to be nonsense.
17:22:40 <pikajude> a vector of IO!
17:23:19 <erisco> with a list of possible sizes
17:31:14 <ch4rli3_unicorn> roar
17:35:27 <erisco> why might this be the case http://lpaste.net/352066
17:36:15 <jle`> erisco: what definitions of SNat/Nat are you using?
17:36:26 <Jello_Raptor> is there a standard way to get a pile of different WriterTs (or the like) playing well together? I see ether has tagged transformers, but right now the most straightforward approach is just use a concrete stack with functions that have lots of lifts in them 
17:36:46 <erisco> from Data.Type.Natural
17:37:07 <jle`> Jello_Raptor: you can write natural transformations to convert your different writer's into one mega-writer type?
17:37:15 <erisco> I just threw RankNTypes in there and I don't know them all that well... probably where this is going wrong
17:37:19 <jle`> erisco: what package?
17:37:24 <erisco> type-natural
17:37:40 <erisco> http://hackage.haskell.org/package/type-natural-0.7.1.2/docs/Data-Type-Natural.html
17:39:20 <jle`> erisco: i think you might have wanted to make an existential type
17:39:48 <erisco> how do I define that
17:40:17 <jle`> added an annotation
17:40:45 <jle`> right now you have it as sa RankN type which I don't think is what you want, if i'm interpreting the names of your constructors/types properly
17:41:12 <erisco> "A newtype constructor cannot have a context in its type" hrm
17:41:26 <erisco> yes the forall doesn't seem right at that position
17:41:55 <jle`> aded a version using GADT syntax, which feels  abit more natural to me
17:42:00 <jle`> ah i see, you probably can't have it be a newtype
17:42:02 <jle`> it probably has to be 'data'
17:42:40 <erisco> that spoils all the juicy performance though :P
17:43:13 <monochrom> Worry about correctness before worrying about performance.
17:43:15 <erisco> wonder why that is the case... hm
17:43:19 <erisco> yes yes
17:43:29 <jle`> in this case it isn't obvious why
17:43:32 <erisco> but what do I tell all my friends
17:43:47 <jle`> but there are some cases where newtype obviously can't do
17:44:01 <jle`> newtype Showable = forall a. Show a => Showable a
17:44:06 <monochrom> But if you have an existential type that involves a type class, you will be carrying a dictionary around per value, exactly what OOP does with virtual tables. It is going to be an overhead.
17:44:21 <jle`> a value of type 'Showable' has to carry around the 'Show' typeclass dicitionary
17:44:26 <jle`> yeah, exactly what monochrom said
17:44:59 <jle`> so really, at an implementation level, it's like newtype Showable a = Showable (forall a. (ShowDict a, a))
17:45:11 <jle`> * newtype Showable
17:45:21 <jle`> so it doesn't hold *just* an 'a', it also holds the typeclass instance dictionary
17:45:45 <dgpratt> does anyone know, is it possible to tell ghci to ignore the standard .ghci file and possibly load a different one instead?
17:45:46 <erisco> right, hrm, makes sense. I guess they don't have a special case for these contexts
17:46:05 <monochrom> The GHC Users Guide says that banning existential newtype is just because the GHC people are too lazy to implement it and too few users asked. You can ask them if you want it happen.
17:46:10 <jle`> in this case you don't actually have a typeclass constraint, so i feel like it should technically be ok
17:46:58 <erisco> I'd only ask if I had a donation to throw at them
17:47:08 <jle`> erisco: you could recover newtypeness by skolemizing your existential, potentially
17:47:34 <dgpratt> that just sounds like word salad
17:48:20 <jle`> newtype BoundedAbove n = BoundedAbove (forall r. (forall m. (m :<= n) ~ True => SNat m -> r) -> r)
17:48:21 <erisco> I'd have to review skolems
17:48:23 <Welkin> lol
17:48:29 <Welkin> I remember skolems
17:48:34 <Welkin> no idea what they are though
17:48:46 <jle`> in that case you get a newtype, but .... you aren't storing an actual SNat m anymore
17:49:02 <jle`> so maybe it's not an actual gain heh
17:49:20 <erisco> well I'd say not, seeing as that is the point of it :P
17:49:30 <Welkin> "rigid type variable"
17:49:36 <monochrom> You can think of that as continuation-passing style and/or church encoding (more accurately Boehm-Bararducci encoding)
17:49:40 <jle`> dgpratt: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#the-ghci-files
17:49:43 <erisco> I see the idea but that is saying I can give any m later on
17:49:49 <erisco> rather than giving one now
17:50:10 <jle`> that's actually the opposite of the idea
17:50:12 <dgpratt> ah, excellent, thanks jle` 
17:50:32 <jle`> the idea is that one m exists, and whatever it is, you're going to have to handle it in a uniform way
17:51:11 <Welkin> wow, this paper is 88 pages
17:51:12 <Welkin> http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/putting.pdf
17:51:18 <Welkin> but it reads pretty easily
17:51:30 <erisco> oh derp I missed it was (SNat m -> r) -> r not SNat m -> r
17:52:04 <jle`> um i have a brief skolemization tutorial in https://blog.jle.im/entry/practical-dependent-types-in-haskell-2.html
17:52:16 <erisco> I don't know how this relates to skolems but in effect we're just storing m in a closure
17:52:16 <jle`> if you wanted to hear what i'd say if you asked me for more detail
17:52:32 <monochrom> Be careful. (forall m. (constraints) => SNat m -> r) -> r
17:52:36 <erisco> so I don't think that is actually addressing the "moar speed pl0x" need
17:52:53 <jle`> well
17:52:56 <jle`> who knows :)
17:53:03 <jle`> (answer: the person that benchmarks)
17:53:31 <monochrom> You should benchmark and you may be surprised.
17:53:50 <jle`> i'm actually not sure which result would surprise me more
17:54:13 <monochrom> Because the way Oleg and edwardk and attoparsec gain their speed is by doing this.
17:54:32 <erisco> jle`, thanks for the article
17:54:36 <Welkin> lol
17:54:40 <Welkin> that is a funny grouping
17:54:42 <jle`> no problem!
17:54:52 <erisco> seems bizarre as to how it could help
17:55:01 <Welkin> so you are saying that Oleg and edwardk are just programs!?
17:55:16 <monochrom> For example attoparsec's Parser type is a lot of continuations that encodes an algebraic data type.
17:55:22 <erisco> but much more clear if you're intimate with the runtime
17:55:27 <jle`> edwardk gains his speed when he wakes up by using a healthy diet of some good ol' skolemized existentials
17:55:54 <erisco> I mean, what the hey, I'll use this variation just for the fun of it
17:55:59 <erisco> doesn't bother me either way
17:56:21 <jle`> if you're just playing around, the existential constructor might be the conceptually simpler version
17:56:53 <monochrom> Yes. Write a program you actually understand first.
17:57:08 <monochrom> Then transform it for speed until you understand none of it anymore.
17:57:36 <monochrom> That is how to achieve a legacy.
17:58:00 <erisco> I intermingle a bit of known and unknown into my screwing around so that I am learning something ;)
17:58:04 <jle`> i explain some pro's and cons of both styles in the linked article
17:59:54 <monochrom> BTW I hate ACL2 precisely because it doesn't have a native, direct existential, it encodes by the skolemization.
18:00:39 <monochrom> It has the consequence of making existentials second-class. This is a hindrance if I need existentials significantly.
18:01:09 <monochrom> OTOH ACL2's main use case doesn't need existentials, so that's how they do just fine.
18:01:16 <erisco> jle`, wrt the nesting point I find that one a bit weird. I'd be hesitant to format my code like that for CP
18:01:27 <erisco> jle`, and for multiple cases the way to go is guards
18:03:40 <jle`> can you elaborate on which examples you are talking about?
18:04:23 <erisco> https://blog.jle.im/entry/practical-dependent-types-in-haskell-2.html#a-tale-of-two-styles
18:05:02 <jle`> how would you use guards?
18:06:25 <jle`> i've seen nested cp style like that used a lot of codebases and library/application code, but ymmv :)
18:09:51 <erisco> jle`, something like this http://lpaste.net/352071
18:10:40 <jle`> ah, pattern guards
18:10:43 <jle`> um
18:10:44 <jle`> does that work?
18:10:49 <erisco> sure
18:10:50 <jle`> that'd be nice
18:13:12 <jle`> oh hey it works :o
18:13:41 <jle`> might not always be possible to refactor it out as a separate function, though, but i suppose you could just throw in a multi-way if if it's in the middle of an expression
18:13:41 <erisco> I am just hesitant with the CPS notation because I like to use the same formatting regardless of what the content is
18:14:07 <jle`> ty for the tip
18:14:17 <jle`> finally a nice use for pattern guards
18:14:26 <erisco> yeah not sure if you can kick off an anonymous guard
18:14:34 <jle`> you can do it with multi-way if
18:14:37 <jle`> maybe
18:17:17 <jle`> oh yes, it does work
18:17:20 <jle`> but it's kind of awkward
18:18:20 <jle`> indentation for multi-way ifs is different than indentation for normal guards apparently
18:26:21 <erisco> oh I guess the wins really come in because the compiler takes off the newtype and can reduce the applications
18:29:28 <erisco> now this one is puzzling http://lpaste.net/352072
18:30:07 <erisco> happily it seems to know Z is <= to everything
18:33:02 <jle`> erisco: you probably need a proof that forall n. (n :<= n) ~ True
18:33:29 <jle`> type-natural might come with one if you're lucky
18:34:51 <jle`> erisco: yup, it does http://hackage.haskell.org/package/type-natural-0.7.1.2/docs/Data-Type-Natural.html#v:sLeqReflexive
18:35:51 <erisco> lol someone has to standardise these containers... Decision, :~:, Refl, IsTrue
18:35:54 <erisco> too much! :P
18:36:09 <jle`> :~:/Refl are in base
18:36:16 <jle`> Decision is in singletons but it really should be in base i think
18:39:18 <jle`> IsTrue is cute.  but '~ True'/definitional equality is kinda weird
18:39:23 <jle`> at this level at least
18:48:19 <Axman6> @hoogle ForeignPtr Word8 -> Int -> IO ByteString
18:48:23 <lambdabot> GHC.Conc runHandlers :: ForeignPtr Word8 -> Signal -> IO ()
18:48:23 <lambdabot> GHC.Conc.Signal runHandlers :: ForeignPtr Word8 -> Signal -> IO ()
18:48:23 <lambdabot> FastString mkFastStringForeignPtr :: Ptr Word8 -> ForeignPtr Word8 -> Int -> IO FastString
18:48:54 <riaqn> Hi, how is closure implemented in GHC? Does the whole stack frame got copied into a new allocated chunk?
18:49:54 <Axman6> the stack in Haskell is not a stack as you know it, importantly it is not use for function calls and returns
18:50:20 <Axman6> look for papers by Simon Peyton-Jones on the STG, Spineless, Tagless G-machine
18:50:36 <Axman6> (I should say, thet stack in GHC, other compilers may use other techniques)
18:51:08 <riaqn> Axman6: OK, thanks!
18:53:26 <erisco> Module `Data.Type.Natural' does not export `sLeqReflexive'  what curse is this
18:54:30 <erisco> seems I have to update... weird I just installed it a few days ago
18:57:18 <erisco> oh, damn, that was the issue...
18:57:32 <erisco> sized-vector has the dependency set on 0.4.2.0
18:57:52 <erisco> and now cabal has installed a newer version of type-natural and now sized-vector doesn't work... why does cabal do this
18:58:09 <erisco> any other sized vectors I can use? :s
19:00:04 <erisco> apparently it was a deprecated package to begin with
19:00:28 <schoppenhauer> hi. is it possible to dump the generated STGM-code that ghc generates while compiling?
19:00:34 <erisco> and they did that thing I don't like... they generalised it
19:00:47 <erisco> now I have to use Sized which has gems such as ListLike? oh boy
19:03:55 <geekosaur> schoppenhauer, -ddump-stg
19:04:04 <erisco> when writing the new generalised shiny version do me a favour and also write the specialised functions to mimic the old one
19:04:26 <erisco> import Data.Sized.ForDummies
19:05:25 <schoppenhauer> geekosaur: thx
19:09:36 <riaqn> Axman6: so in SPJ92, 9.4.1, he mentioned that the local environment has to be saved.
19:09:52 <riaqn> but I'm not sure what he means by "save in the stacks"
19:10:47 <erisco> lol the hilarity of doing simple things when you need to prove them
19:10:50 <Axman6> me either, I haven't read it :)
19:11:18 <riaqn> Axman6: I assume it's the stacks allocated in heap.
19:11:29 <erisco> one does not simply subtract 1 from a natural
19:14:27 <erisco> need to get from a < b to there is a predecessor to b, c, and a <= c
19:16:48 <erisco> so one browses through the zoo of axioms and theorems and tries to concoct this fact
19:19:24 <mniip> erisco, are a,b reals?
19:19:30 <erisco> naturals
19:19:53 <erisco> lneqRightPredSucc is probably involved
19:19:56 <mniip> hmm
19:20:02 <erisco> this brings me back to logic class in uni...
19:20:14 <erisco> spend 4 hours trying to find the magical step
19:20:50 <mniip> b is either 0 or has a predecessor, if b=0 then existence of a proves falsehood
19:21:18 <erisco> a < b is true, that is assumed
19:21:27 <mniip> right
19:21:40 <mniip> but surely,
19:21:44 <mniip> a < 0 => falso
19:23:50 <erisco> lneqRightPredSucc gives me b :~: Succ (Pred b)
19:24:01 <erisco> so I've got that b has a predecessor
19:25:24 <erisco> lneqSuccLeq then gives me  Succ a :<= Succ (Pred b)
19:25:34 <erisco> where is the Succ peeler!
19:26:41 <erisco> leqSucc adds a Succ
19:28:47 <erisco> jle`, there is leqRefl :: Sing (n :: nat) -> IsTrue (n :<= n)  btw
19:29:03 <erisco> rather than the longer sLeqReflexive a a (reflToSEqual a a Refl)
19:31:35 <erisco> hm, I can piece together the Succ elimination from leqSuccStepR (adds Succ to the right) and leqTrans and leqRefl
19:33:16 <erisco> would be nicer to have a lemma for any two naturals though
19:37:50 <erisco> there is addition elimination
19:40:32 <patbecich> /msg NickServ VERIFY REGISTER patbecich lwadzlhxtxzg
19:40:32 <patbecich>  
19:40:54 <MarcelineVQ> :>
19:46:39 <erisco> surely  S m <= S n  ==>  m <= n  is a theorem
19:47:04 <erisco> why is finding it so tricky :s
19:47:39 <barryburd> I must have some confusion about the IO monad, and maybe someone can clear it up for me. Suppose you have    x <- getLine ; putStrLn x    and the user inputs Hello. Then getLine is an action (a monadic value) and the <- symbol lets x refer to the value "Hello" that's part of the getLine action. But in another run of the code, the user inputs Goodbye, so doesn't getLine then represent a slightly different monadic value (one 
19:47:40 <barryburd> which "Goodbye" is part of the value)? As far as I can see, the difference between the two getLine actions is like the difference between Just "Hello" and Just "Goodbye" in a Maybe monad.
19:47:50 <dfeuer> erisco: what's your definition of <=?
19:48:07 <erisco> dfeuer, http://hackage.haskell.org/package/type-natural-0.7.1.2/docs/Data-Type-Natural.html#t:PeanoOrder
19:48:29 <dfeuer> Oh.
19:48:31 <dfeuer> That.
19:48:33 <mniip> barryburd, getLine doesn't "contain" Hello or Goodbye
19:48:45 <mniip> same way as (+) doesn't contain the number 8
19:48:46 <geekosaur> @quote /bin/ls
19:48:46 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
19:49:31 <mniip> good quote
19:49:49 <barryburd> … so referential transparency is preserved.
19:50:11 <mniip> sure is
19:50:28 <mniip> it never was broken
19:50:29 <geekosaur> getLine contains a read-a-string instruction to the runtime. when you use <-, it's actually making a function that will be called when that runtime instruction is executed
19:50:43 <dfeuer> When you start trying to get things out of IO, you're suddenly out of Haskell and writing programs for a graph reduction machine while the optimizer is trying to scramble your code.
19:50:48 <geekosaur> so a Haskell program ends up being a chain of callbacks in IO
19:51:07 <erisco> normally you'd use induction
19:51:11 <geekosaur> (if that sounds vaguely familiar, you may be a JS frontend programmer :)
19:51:11 <mniip> dfeuer, shhhhh
19:51:16 <mniip> you cannot get things out of IO
19:51:33 <erisco> so you'd have  S 0 <= S 0 ==> 0 <= 0  trivially because 0 <= 0 is an axiom
19:51:36 <dfeuer> mniip: right. You can only *try* to. And be in a world of extreme difficulty :P
19:51:38 <Axman6> barryburd: getLine is an action which, when executed by the haskell runtime system takes a line of input from the user and pass that into the program. it is a recipe for how to do that, it is not the string itself
19:51:42 <mniip> dfeuer, shhhhhhhhh
19:52:00 <erisco> S m <= S n ==> S (S m) <= S (S n)  is trivial because that is already given to us
19:52:01 <barryburd> I understand that it’s not the string itself.
19:52:12 <erisco> but I don't think we can convince Haskell about inductive proofs here
19:52:32 <mniip> erisco, if you eat away the S you can
19:52:35 <mniip> it wouldn't be undecidable
19:52:54 <dfeuer> mniip: normally I'm on your side, but I just overhauled the implementation of Control.Monad.ST.Lazy to make it thread-safe, so I have weird stuff on the brain.
19:52:54 <erisco> oh I think my inductive step is backwards :P
19:53:12 <jle`> erisco: oh yes, that one is probably better :)
19:53:17 <mniip> huh
19:53:22 <barryburd> I’ve asked about the definition of the bind function for the IO monad, and been told that it’s not worth looking at. 
19:53:44 <dfeuer> barryburd: it is not worth looking at until you get to extreme low-level hacking.
19:53:45 <mniip> barryburd, it's not useful to look at, at your stage
19:53:52 <geekosaur> and possibly not even then
19:53:52 <mniip> you might get mislead
19:54:11 <jle`> i can't even imagine a situation where it would be worth looking at
19:54:12 <geekosaur> the real trick here is do notation turns your apparently imperative "statements" into chains of callbacks
19:54:19 <dfeuer> GHC's model of IO is pretty badly broken, in fact. 
19:54:28 <mniip> dfeuer, how come
19:54:33 <mniip> (do you have a better proposal)
19:54:53 <dfeuer> mniip: it requires a large number of terrible compiler hacks to mostly work.
19:54:56 <jle`> the implementation of IO is a lie too I think
19:54:59 <dfeuer> There have been several better proposals.
19:55:13 <erisco> it needs to be  assuming S m <= S n ==> m <= n prove S (S m) <= S (S n) ==> S m <= S n
19:55:18 <dfeuer> The trouble is that a shit-ton of libraries and applications will break if that's changed.
19:55:18 <mniip> I think it's fine if I understand it correctly?
19:55:46 <jle`> erisco: fun stuff with peano nats huh
19:55:55 <geekosaur> "state hack"
19:56:06 <erisco> well I don't think I could use an inductive proof even if I could figure it out
19:56:10 <dfeuer> mniip: fine? No, it's not fine. Doing IO in the G-machine is not the way anyone would likely try to do it if GHC were being built from the start today.
19:56:20 <jle`> erisco: are you on the same problem from when i last saw
19:56:26 <mniip> uh
19:56:29 <jle`> at this point i don't even use IO in any of my application code anymore
19:56:32 <erisco> jle`, I am trying to prove S m <= S n ==> m <= n
19:56:32 <jle`> i just make a custom data type
19:56:52 <mniip> dfeuer, what way then?
19:57:33 <erisco> not sure it is possible :s
19:57:33 <jle`> erisco: in haskell?
19:57:37 <erisco> yes
19:57:50 <jle`> i suppose it depends on what axioms you have at hand to use
19:57:55 <erisco> http://hackage.haskell.org/package/type-natural-0.7.1.2/docs/Data-Type-Natural.html#t:PeanoOrder
19:58:19 <dfeuer> mniip: there have been various suggestions; Ed seems to like a sort of codensity-based thing over an opaque FFI type to start with.
19:58:40 <jle`> erisco: maybe you can get away with just doing it inductively
19:58:49 <jle`> hm
19:58:53 <jle`> oh nvm because <= is a type family
19:58:54 <erisco> jle`, how do you encode an inductive proof
19:59:10 <mniip> dfeuer, would that allow for unsafeCoerce
19:59:19 <dfeuer> mniip: what?
19:59:39 <dfeuer> What does unsafeCoerce have to do with it?
20:00:30 <jle`> erisco: maybe you can use http://hackage.haskell.org/package/type-natural-0.7.1.2/docs/Data-Type-Natural.html#v:leqSuccStepL
20:00:37 <jle`> anything with Succ n on the lhs
20:00:54 <dfeuer> mniip: look at http://comonad.com/reader/2011/free-monads-for-less-3/
20:00:58 <mniip> dfeuer, oops, my mind slipped
20:00:59 <erisco> well, sure, so now I am at m <= Succ n but I don't think this gets me far
20:01:03 <mniip> unsafePerformIO
20:01:10 <dfeuer> ?
20:01:16 <erisco> in fact I could have just used m <= Succ m then transitivity to get there
20:01:22 <dfeuer> How's that, mniip? 
20:01:51 <mniip> hmmmm
20:01:57 <mniip> that's a long read
20:02:02 <mniip> but looks cool
20:02:18 <jle`> erisco: hey you can probably just do it by using the Leq GADT
20:02:21 <dfeuer> The real idea here is that the RTS should *actually* be calculating the "next action", driving evaluation that way,
20:02:30 <erisco> jle`, I just have to do it for Nat. I will try writing it inductively
20:02:37 <geekosaur> I think we may be stuck with unsafePerformIO anyway, unless this also finds a way to make unsafeLocalState go away
20:02:40 <jle`> yes Leq does it for nats
20:02:43 <dfeuer> rather than making that a very short-lived lie.
20:03:15 <jle`> erisco: \case SuccLeqSucc l -> l
20:03:39 <dfeuer> [or actually compiling down to something more low-level, but doing so much later in the game]
20:03:47 <dfeuer> Anyway, I have to try to go to sleep.
20:04:21 <jle`> erisco: so you can use boolToPropLeq/propToBoolLeq and then your proof is trivial
20:04:51 <ph88> is there a way to figure out, programatically, if the code is being run in ghci ? 
20:05:13 <erisco> thanks I was looking for how to get :<= from Leq... what is LeqTrueInstance
20:05:57 <jle`> not sure, seems to not be exported
20:06:02 <jle`> maybe you can just use propToClassLeq then
20:06:42 <jle`> a bit annoying
20:06:48 <jle`> time to switch to idris
20:07:53 <erisco> I'm a little deeper than I anticipated but this is good nonetheless
20:08:12 <jle`> it might become clearer once you finish
20:08:20 <jle`> you might see a clear path to refactor
20:11:10 <geekosaur> ph88, nothing other than horrid hacks
20:11:27 <geekosaur> (like poking at /proc/self/exe on linux)
20:11:38 <ph88> did you see it being done before ?
20:11:39 <jle`> maybe check __name__
20:13:44 <geekosaur> ph88, you can be running compiled code in ghci or interpreted code in ghc (TH), compiled code does not know where it is running, what problem are you trying to solve? because this is probably the wrong way
20:14:21 <ph88> i'm doing some quickcheck and i try to adjust the amount of iterations on the speed of the code
20:15:08 <ph88> in ghci i can do 100 iterations reasonably fast, with compiled code 10^9
20:16:35 <erisco> jle`, yup this type checks http://lpaste.net/352073 is there a better way to deal with ZeroLeq?
20:16:58 <jle`> i'd case it
20:17:16 <erisco> but what is the body?
20:18:02 <jle`> added an annotation but
20:18:17 <jle`> i'm hoping that ghc desn't warn you on the ZeroLeq case
20:18:32 <erisco> doesn't seem to
20:18:36 <jle`> neat, it's smart enough
20:18:47 <erisco> maybe I don't have the appropriate warnings enabled
20:18:52 <erisco> I don't usually get partial match warnings
20:18:56 <jle`> o
20:19:10 <ph88> can haskell denote integer literals with an exponent or underscores ?
20:19:13 <jle`> yeah, you should turn on -Wall when doing dependent type stuff like this, that's kind of the whole point, to an extent
20:19:39 <jle`> partial pattern matches should probably be errors
20:20:15 <jle`> the magic is when you can trust ghc/the type system to know what GADT cases can't come up
20:20:44 <dmwit> > 1e9 :: Integer
20:20:46 <lambdabot>  error:
20:20:46 <lambdabot>      • No instance for (Fractional Integer)
20:20:46 <lambdabot>          arising from the literal ‘1e9’
20:20:56 <dmwit> ?let {-# LANGUAGE NumDecimals #-}
20:20:57 <lambdabot>  Defined.
20:21:03 <dmwit> > 1e9 :: Integer
20:21:05 <lambdabot>  error:
20:21:05 <lambdabot>      • No instance for (Fractional Integer)
20:21:05 <lambdabot>          arising from the literal ‘1e9’
20:21:14 <jle`> letting language pragmas just adds a plain ol' comment to the end of L.hs
20:21:27 <dmwit> ok =(
20:21:31 <jle`> lambdabot doesn't know to put them at the top of a file yet heh
20:21:37 <erisco> well then yeah it is not happy with me
20:22:23 <erisco> can I -Wall and disable certain warnings? like unused imports?
20:22:36 <erisco> I have a lot of stuff commented out as I work on this
20:27:03 <ertes> helo
20:28:22 <erisco> I guess I just write undefined for the case? seems pointless but it shuts off the warning I now have lol
20:28:36 <erisco> can I write anything that type checks here?
20:29:01 <erisco> I have to find an n such that S n ~ Z and that seems a bit difficult
20:31:22 <erisco> I don't even know if m is non-zero
20:31:47 <erisco> or I guess I don't have to for that one
20:35:17 <erisco> does Haskell have type inequality? maybe I can bring 'S n !~ Z into scope
20:35:32 <mniip> yes but it's ugly
20:35:32 <geekosaur> nope
20:35:41 <geekosaur> (well, ugly hackery aside)
20:35:45 <mniip> and there's not much you can reason about
20:35:55 <geekosaur> I seem to recall actual type inequalities cause problems
20:36:03 <mniip> yes
20:36:19 <mniip> you could have an evidence that a type family equation does not match
20:36:22 <mniip> with e.g.
20:36:36 <mniip> type family Equals x y where Equals x x = True; Equals x y = False
20:36:58 <mniip> but like, inference on that is going to be terrible
20:37:15 <erisco> ('S n :== 'Z) ~ 'False  perhaps
20:37:33 <erisco> but I don't see how Haskell is going to figure out the case is impossible from this
20:37:39 <erisco> if it doesn't understand inequalities in the first place
20:37:41 <mniip> Could not decude a ~ S b from the context (Equals a Z) ~ False
20:39:39 <erisco> guess I'll try and see what happens
20:49:30 <erisco> I can say 0 < S n but Haskell obviously still has no idea what is going on
20:51:10 <mniip> 0 < S n is an axiom
20:51:16 <mniip> you could define < as a tyclass
20:51:25 <erisco> yes it is given to me
20:51:26 <mniip> or as a tyfam
20:51:32 <erisco> I am saying I can bring it in scope but this doesn't help
20:51:36 <mniip> with that as a rul
20:51:36 <mniip> e
20:53:53 <erisco> when is Haskell actually going to know a case is impossible
20:54:22 <erisco> I don't know what kind of evidence would ever work
20:55:23 <erisco> if it cannot figure out 'S n ~ 'Z never succeeds then what else could I possibly do
20:55:33 <erisco> they are plainly stated as a data type
20:55:57 <erisco> 'S and 'Z are distinct constructors of the same lifted type... it should be obvious!
21:00:26 <erisco> I figured out the problem folks
21:01:05 <erisco> my code was wrong :)
21:01:29 <erisco> http://lpaste.net/352076 there we go
21:01:57 <erisco> I was taking Sing n and Sing m instead of Sing ('S n) and Sing ('S m)
21:02:09 <erisco> which was giving me the wrong proposition
21:04:26 <Jinixt> if one were to implement a compiler in haskell, is there a way to piggyback on GHC's type inference system? (with my own compiler's types)
21:08:44 <erisco> well the typical way to do this is with an eDSL
21:09:02 <erisco> if you mean to rip out pieces of GHC to use in your own compiler, I dunno
21:10:21 <Jinixt> the source language isn't haskell so it'd have to be the latter
21:12:01 <erisco> how am I supposed to get an IsTrue (a :< b), bleh
21:12:19 <erisco> you can construct Leq proofs but there is no Lneq
21:13:39 <erisco> I have (n :< m) ~ True in context but there is no conversion
21:16:47 <jle`> i think you should be able to just use the Witness constructor
21:17:19 <erisco> hm, I suppose that makes sense
21:17:40 <erisco> Witness :: IsTrue P  where P is whatever my problem is
21:18:07 <jle`> you can use 'Witness :: IsTrue p' whenever (p ~ True) is in your context
21:18:09 <jle`> yeah
21:18:52 <erisco> a bit mind bending for me at the moment
21:18:58 <jle`> so if you have `(n :< m) ~ True` in your context, you can use 'Witness :: IsTrue (n :< m)'
21:19:13 <erisco> yes, right
21:19:20 <jle`> to get a value of IsTrue (n :< m)
21:19:29 <jle`> *of type
21:23:35 <erisco> I expect there to be a way to do substitution... so  IsTrue (n :~: n') -> IsTrue (n :<= m) -> IsTrue (n' :<= m)
21:24:11 <erisco> maybe I have to make that lemma as well
21:26:11 <erisco> or maybe I just bring the equality into the context and work it that way? maybe so
21:37:27 <dmwit> Jinixt: GADTs are essentially a way to embed your language's type system into Haskell.
21:38:57 <Jinixt> dmwit: and this would give me "free" type inference? got any good resources for this?
21:39:30 <Jinixt> i haven't really used GADTs before
21:39:54 <dmwit> http://www.monoidal.net/papers/qhaskell.pdf shows how to use GADTs + typeclasses to embed a linearly typed language into Haskell and get inference on it.
21:40:02 <Jinixt> thanks!
21:56:58 <Lokathor> someone said something to me earlier
21:57:05 <Lokathor> but i was asleep for 5 hours
21:57:13 <Lokathor> so it's not in my scrollback
22:13:57 <shtuka> How would you write a Haskell program solving the Einstein riddle https://udel.edu/~os/riddle.html ? It is easy in Prolog.
22:16:09 <jle`> probably could do something similar with list's monad instance maybe
22:16:33 <erisco> jle`, I have something fun to show you in a few minutes :D
22:16:41 <jle`> :o
22:20:17 <erisco> seems my program hangs =\
22:23:42 <shtuka> what does your program do?
22:24:29 <erisco> it defines bounded naturals
22:25:00 <shtuka> natural == {0,1,2,...}?
22:25:05 <erisco> yes
22:25:15 <Jinixt> shtuka: easy, start by implementing prolog in haskell
22:25:20 <erisco> unfortunately it hangs when I ask for maxBound
22:25:22 <Jinixt> :-)
22:25:26 <shtuka> ;-)
22:26:11 <erisco> jle`, here it is http://lpaste.net/352077
22:27:09 <erisco> type checks but something goes awry
22:27:44 <erisco> maybe sPred' doesn't do what I think it does
22:31:29 <Jinixt> shtuka: i'm no expert, but my intuition would be to create a (lazy) list of all possibilities, have another list of the conditions, and just strike off possibilities from the front when they violate a condition
22:31:40 <Jinixt> should essentially be the same as what you do in prolog
22:31:58 <erisco> well it seems to run fine in isolation... sPred' that is
22:32:05 <erisco> maybe one of the proofs does not terminate? hrm
22:32:37 <shtuka> Jinixt: ok. would this be as efficient as the Prolog program?
22:33:25 <erisco> I suppose I do not prove that Pred b is actually the max or that a is actually the min, heh
22:33:43 <erisco> I just did enough to prove that they're okay to put in Range
22:33:50 <dramforever> shtuka: We don't have 'the' Prolog program :)
22:34:55 <shtuka> http://swish.swi-prolog.org/example/houses_puzzle.pl :)
22:38:03 <erisco> alright interesting, it is lneqSucc b that hangs
22:39:27 <Jinixt> i'll make an attempt at the puzzle
22:39:45 <jpgarcia> Is there a way to enable ghc extensions at the middle of a file?
22:40:01 <dramforever> shtuka: it's a bit difficult to say, actually
22:40:32 <dramforever> because Prolog can do symbolic manipulation, like how you have 'Hs', '_' all over your code
22:40:33 <jpgarcia> I want to do literate programming, and call extensions pragmas when i need them, not at the start of the file
22:40:56 <dmiles> https://rosettacode.org/wiki/Zebra_puzzle 
22:40:59 <dramforever> it's not going to happen automatically in Haskell
22:41:07 <dmiles> (there is a Haskel version there)
22:41:33 <dmiles> two Haskell versions
22:44:36 <erisco> jle`, another problem with Haskell is proofs can be wrong because they don't terminate =\
22:44:48 <erisco> bottom proves all!
22:44:59 <erisco> the null of proofs
22:45:08 <jle`> :/
22:45:26 <erisco> I am guessing there is an error in type-natural
22:45:40 <erisco> a circular definition probably resulting from class defaults
22:47:15 <dmwit> jpgarcia: There's currently no way to do that, sorry.
22:47:45 <dmwit> jpgarcia: That said, I think people are generally friendly to the extensions+imports block that inevitably clutters up the start of any literate Haskell.
22:49:11 <dramforever> The lhs isn't literate enough obviously
22:50:30 <nshepperd> I don't know about prolog, but SAT programs like minisat can be a lot more efficient than naively listing all possibilities as one might in the list monad. because they can use clever heuristics and substitute things into other things iirc
22:51:55 <nshepperd> (I wish for a nicer haskell library for encoding arbitrary problems into SAT so I can outsource the backtracking/solving/magic :)
22:52:09 <erisco> nshepperd, I am using sbv
22:52:46 <dmwit> nshepperd: http://hackage.haskell.org/package/ersatz ?
22:53:55 <erisco> so now the question is how I recreate a :< Succ a
22:53:59 <shtuka> thanks! @dmiles and dmwit
22:54:31 <nshepperd> I saw ersatz before. I couldn't understand how to use ersatz back then :/ maybe I should try again
22:55:14 <erisco> sbv lets you use popular solvers like z3
22:55:40 <erisco> you write regular Haskell... ish... and it solves it
22:55:51 <dmwit> Yep. sbv is pretty brilliant
22:56:33 <erisco> not so bad generating the problems as you just have to swap out some operators for equivalents
22:57:27 <erisco> you have to then take some fairly crude solutions and map them back to your domain though
22:57:57 <dmwit> Looks like ersatz can call out to popular solvers, too.
22:57:57 <nshepperd> interesting. I'll give sbv a go
22:58:13 <dmwit> Dunno whether it's *just* a front-end or whether it tries to implement a solver itself, too.
22:59:18 <shtuka> Which IDE would you suggest for Windows and GHC?
22:59:27 <dmwit> vim
22:59:43 <dmwit> Or emacs, I guess, if you already know it.
22:59:48 <erisco> I'm a pleb and I use Notepad++
22:59:51 <dmwit> But vim is objectively superior. ;-)
22:59:53 <shtuka> please not emacs or vim ...
23:04:47 <dramforever> shtuka: atom
23:05:45 <shtuka> thx@atom
23:05:57 <dramforever> If you ask me I would say there's nothing comparable to an IDE yet
23:06:15 <mniip> ok so
23:06:36 <Cale> dramforever: What about leksah?
23:06:44 <mniip> what exactly is a strong monad in a profunctor bicategory
23:06:48 <Cale> I haven't really used it, but it looked pretty ide-like
23:07:05 <erisco> that is a good description of it i.e. "ide-like"
23:07:09 <dramforever> Could have been a bias
23:07:18 <mniip> or rather, given I'm not very familiar with higher CT, how does the concept of strength expand to monoids in the endo-profunctor category?
23:07:22 <dramforever> but last time I tried it it just hang
23:07:30 <dramforever> hang pretty reliably
23:07:53 <erisco> well that's a common IDE feature
23:08:15 <mniip> are we talking about an A x F(X, Y) ---> F(A x X, A x Y) nt?
23:08:25 <erisco> especially when running the debugger, for some reason
23:08:36 <dramforever> It it's 'hanger' than jetbrains stuff
23:08:51 <Cale> mniip: https://en.wikipedia.org/wiki/Strong_monad spells it out
23:09:05 <dramforever> Debugging is like a 'major WTF' of Haskell actually
23:09:12 <dramforever> because single-stepping is non-existent
23:09:18 <mniip> Cale, yeah but profunctors
23:09:23 <mniip> arrows, not monads
23:09:40 <dramforever> Uh, in some sense
23:10:02 <mniip> hmm
23:10:06 <mniip> that NT above made no sense
23:10:07 <Ke> dramforever: very often tracing is much faster than single steppinh
23:10:18 <dramforever> Oh sorry, I think I meant stack trace
23:10:42 <erisco> I just get lost in the endless stack
23:11:04 <erisco> you go so many levels deep and can't remember anymore why it is even here
23:11:21 <dramforever> It's really like non-existent
23:11:39 <shtuka> how does one install the haskell IDE for Atom on Windows?
23:11:59 <erisco> you search plugins for "haskell" and install most of the stuff you find, iirc
23:12:27 <dramforever> Remember to install ghc-mod
23:12:34 <dramforever> and if that fails *don't* ask me
23:12:38 <erisco> and set up the config so Atom knows where it is
23:12:46 <erisco> my problem was that it continually broke
23:13:48 <erisco> and fyi Atom was benched as the slowest editor ever :P
23:13:48 <shtuka> thanks, I will try
23:15:36 <dramforever> so leksah isn't really on stackage
23:16:26 <shtuka> I installed ide-haskell and haskell-ghc-mod, but when I open a file named main.hs, there is no syntax highlighting and not option to run the code
23:17:15 <erisco> you have to configure the ide-haskell plugin so it can find ghc-mod
23:17:15 <dramforever> You need to take 'install most of the stuff you find' seriously
23:18:05 <erisco> also I think it only kicks in when it finds a .cabal package file but I could be mistaken
23:18:30 <Cale> shtuka: Try pressing Ctrl+Shift+L and choosing Haskell
23:18:57 <shtuka> Cale: there is no Haskell to select
23:19:01 <Cale> okay
23:19:08 <dramforever> I have autocomplete-haskell, haskell-ghc-mod, ide-haskell, ide-haskell-cabal, language-haskell
23:19:15 <Cale> That's odd, does it not come with Haskell support to begin with?
23:19:18 <dramforever> shtuka: You didn't install 'language-haskell' right?
23:19:22 <mniip> Cale, any idea?
23:20:12 <dramforever> Oh, Hey new Absolute Beginner (tm) here :)
23:20:33 <dramforever> shtuka: Welcome :)
23:22:07 <Cale> mniip: Maybe I don't understand the question. You have a monoidal category of profunctors, the definition of a monad in that is the same as the definition of monad in any category, and the definition of strong monad to use is the one on the Wikipedia page I linked...
23:22:35 <mniip> Cale, take a category C
23:22:52 <mniip> a monad in C is a monoid in (End(C), ., 1)
23:23:12 <shtuka> syntax highlighting does now work in Atom.
23:23:18 <mniip> but we're talking about monoids in (Prof(C), ., 1)
23:23:27 <dramforever> shtuka: https://github.com/Gabriel439/post-rfc/blob/master/sotu.md#ide-support
23:23:36 <mniip> which according to some people here are what arrows  are
23:23:48 <dramforever> shtuka: Are you familiar with the command line?
23:23:49 <mniip> the question is how does the concept of monadic strength expand to this
23:24:06 <shtuka> dramforever: I am using Windows 10 64
23:24:32 <dramforever> What programming languages have you learned before?
23:24:33 <shtuka> when I try to build my .hs file, I get the error "No cabal file found"
23:24:35 <shtuka> C++
23:25:07 <dramforever> does 'g++ -O2 -Wall -o prog.exe prog.cpp' scare you off?
23:26:23 <Cale> mniip: Ah, okay. I wasn't understanding the setting correctly. Here: http://www-kb.is.s.u-tokyo.ac.jp/~asada/papers/arrStrMnd.pdf
23:26:42 <mniip> dramforever, not as much as
23:26:46 <mniip> g++.exe -O2 -Wall -o prog.exe prog.cpp
23:26:49 <Cale> mniip: The strength will just be a 2-cell of a particular type
23:27:06 <Cale> mniip: It'll be perfectly analogous to the situation with strength being a natural transformation in Cat
23:27:07 <mniip> Cale, could you explain without invoking higher ct
23:27:19 <Cale> no?
23:27:22 <mniip> uhhhuh
23:27:24 <shtuka> dramforever: no
23:27:41 <Cale> Well, I suppose we can explain what 2-cells in Prof are
23:27:43 <shtuka> I did cabal init in my main.hs directory, and it seems to work now
23:27:49 <mniip> what's a cell
23:28:06 <erisco> as I said, you need a .cabal package file for the plugin to kick in
23:28:17 <dramforever> shtuka: Oh wait, which book/tutorial/whatever are you using to learn Haskell?
23:28:30 <Cale> mniip: a generic term for something like an object or arrow
23:28:34 <shtuka> http://learnyouahaskell.com
23:28:34 <Cale> Objects are 0-cells
23:28:37 <Cale> Arrows are 1-cells
23:28:38 <dramforever> most tutorials tell you how to get a Haskell environment running
23:28:42 <shtuka> @dramforever
23:28:43 <lambdabot> Unknown command, try @list
23:28:49 <dramforever> shtuka: Just do what they say
23:29:09 <mniip> Cale, I don't see a pattern
23:29:14 <Cale> But then you might have 2-cells which go between pairs of 1-cells, and 3-cells would go between pairs of 2-cells and so on.
23:29:15 <erisco> I just type ghci and what else do you need :P
23:29:28 <mniip> ah
23:29:45 <Cale> For example, for Cat, the 0-cells are categories, the 1-cells are functors, and the 2-cells are natural transformations
23:29:58 <shtuka> ghci works for me, but I want an IDE
23:30:03 <mniip> ok
23:30:06 <dramforever> :(
23:30:22 <shtuka> building the Haskell.exe works now
23:30:23 <mniip> so in prof we have what
23:30:26 <Cale> For Prof, the 0-cells are categories, the 1-cells are profunctors, and the 2-cells are "dinatural transformations".
23:30:36 <mniip> dinatural transformations
23:30:37 <mniip> yeah
23:30:46 <mniip> but wait
23:30:52 <Cale> https://en.wikipedia.org/wiki/Dinatural_transformation
23:30:55 <mniip> aren't profunctors the 0-cells in Prof
23:31:02 <dramforever> shtuka: Sorry we don't really have that
23:31:15 <Cale> no
23:31:25 <mniip> isn't a profunctor category like a [-, -] functor category?
23:31:33 <shtuka> dramforever: what do we not have?
23:31:47 <mniip> ok, so Prof is more similar to Cat than to End?
23:31:52 <Cale> yeah
23:31:52 <dramforever> A very good IDE
23:31:58 <mniip> okay
23:32:02 <shtuka> OK. I'm fine with Atom.
23:33:08 <Cale> shtuka: There's a program called ghcid which will continually report errors in your program as you save it.
23:33:44 <Cale> ghcid, a text editor, and ghci are typically enough of an IDE for my sake :P
23:33:53 <mniip> Cale, hmm, is dinatural transformation a more generic version of a natural transformation in case of a profunctor?
23:34:20 <Cale> mniip: It's an analogous concept, but it's hard to say that it's "more generic"
23:34:23 <Cale> It's just different
23:34:27 <mniip> I mean,
23:34:46 <mniip> an NT on profunctors would be eta_X,Y : F(X, Y) -> G(X, Y)
23:35:18 <mniip> this one only makes use of F(X, X)
23:35:46 <mniip> any NT on profunctors is a DT
23:36:02 <mniip> (it looks like, I haven't checked the diagram thoroughly)
23:36:09 <Cale> oh wait a minute
23:36:22 <Cale> It looks like this paper doesn't even want that
23:36:45 <Cale> You can indeed just use natural transformations there
23:36:54 <mniip> it does mention DT in Definition 1
23:37:32 <Cale> On the next page, it says that 2-cells of profunctors are just natural transformations.
23:38:53 <Cale> (When I was looking up what category the paper was talking about, the fact that they mention dinatural transformations right away threw me off too)
23:41:08 <mniip> okay
23:41:23 <mniip> so we have Prof where 2-cells are dinatural transformations
23:42:49 <shtuka> can I also interpret .hs files from Atom? I don't want to compile everything.
23:43:04 <mniip> Cale, when does strength come into play
23:48:45 <noan> sooo, database library to use together with servant.. What's nice and relatively simple, since I'm still learning basics?
23:49:52 <_sras_> Why does `lookupTypeName "[]"` return nothing? 
23:50:33 <mniip> no idea about the context but it's polymorphic which might be an issue with whatever you're using
