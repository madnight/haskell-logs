00:07:27 <spatial> Is there a gentle introduction reactive programming in haskell ?
00:08:21 <spatial> Mine is a simple board game. 2 players playing.
00:08:57 <spatial> A GUI shows the progress. Is that reactive ?
00:13:33 <geekosaur> reactive isn't so much how the game works, as how you implement the logic
00:14:13 <geekosaur> you can think of it as a style of event driven programming
00:16:37 <tdammers> it's a bit of a fuzzy term really, because implementation details vary a lot, but IMO the core idea of reactive programming is that you model your application logic in terms of immutable state objects, transitions between them, and some sort of event mechanism to close the cycle
00:36:49 <jnj> Hi. I have a function x ocurring both as "x" and "x.\" in the profiling report. What does the ".\" part mean?
00:37:39 <jle`> jnj: '\' refers to anonymous functions/lambdas
00:37:45 <jle`> so x.\ is a lambda inside x
00:38:11 <spatial> Let's say I have a board game. And a GUI. What is the functional pattern that transforms and updates from one to the other ?
00:38:49 <jnj> jle`: thank you
00:38:55 <jle`> no problem!
00:39:49 <srhb> spatial: FRP is all the rage these days.
00:42:07 <spatial> Functional Reactive programming ? 
00:42:08 <osa1> spatial: update your state, recurse using updated state
00:42:39 <sm> spatial: the GPIH book (Game Programming in Haskell) is a nice intro
00:43:32 <spatial> osal: Yes. Done it with OCaml. But as I am new I was looking for a functional way.
00:43:39 <spatial> in Haskell
00:44:02 <osa1> spatial: that's a functional way
00:45:00 <osa1> spatial: I don't mean in-place update, I mean functional update, as in updates in persistent data structures
00:45:28 <spatial> osal: How do I transform between a list and a screen co-ordinate system ?
00:45:50 <spatial> Updates in persistent data structures. What is it ?
00:46:43 <suppi> spatial: this might help https://youtube.com/watch?v=dOy7zIk3IUI
00:48:40 <suppi> also this https://youtube.com/watch?v=GXW1jBijhlk
00:48:53 <spatial> Let me view those videos.
00:50:03 <suppi> there are also other approaches in the purescript world such as in the libraries signal, pux, thermite and halogen
00:57:25 <quchen> ertes: I remember you mentioning reactive-banana was your favourite FRP lib until something else came along. What is this other library called?
00:58:03 <ertes> quchen: reflex
00:58:15 <quchen> Thanks!
00:58:50 <quchen> Okay, looks more complicated.
00:59:40 <quchen> instance Reflex Spider«, hah
01:03:38 <Cale> quchen: Yeah, unless you're really keen to help Ryan work on it, looking at Spider's actual implementation probably isn't too helpful
01:04:07 <ezyang> Well, the fancy rank-2 types in the Spider implementation make the types look more complicated 
01:04:12 <ezyang> but if you've done the ST monad before it's not too bad 
01:04:21 <quchen> I have.
01:04:29 <quchen> But I find line-long constraints a bit scary.
01:04:43 <quchen> It brings so many definitions into scope that I lose sight of what I can do with things.
01:05:05 <quchen> But ertes endorsement means it’s probably worth it :-)
01:05:07 <ezyang> yeah. Fortunately reflex uses a lot of associated types so there's only ever one type parameter 
01:05:25 <ezyang> I wish I could say Backpack would make this better... but they still need the phantom parameter T_T 
01:05:55 <tsahyt> ertes: what are the benefits of reflex over r-b?
01:07:19 <ezyang> tsahyt: https://www.reddit.com/r/reflexfrp/comments/3c36ya/differences_between_reflex_and_other_frp_libraries/ might say a little 
01:09:48 <tsahyt> I guess I'll just have to try it eventually then
01:09:59 <ertes> quchen: the 't' parameter is mostly a dummy argument to select an implementation (reflex is both a semantics (Reflex) and an implementation of it (Spider))
01:10:00 <tsahyt> efficiency is always a good thing
01:10:24 <ertes> quchen: the size of the constraint is unfortunate, but necessary
01:10:42 <ertes> with backpack it would become a lot less scary though
01:10:57 <ezyang> ertes: It's not true though :( 
01:11:01 <Cale> At some point we might use the t parameter in some more interesting ways
01:11:02 <quchen> ertes: I think I need to read up on the lib more before understanding sentences like these. I’m only, let’s call it »phenomenologically«, familiar with FRP.
01:11:04 <ezyang> Unless you only let one instance of Spider run at a time 
01:11:08 <Cale> Timeline transformers :)
01:11:20 <halogenandtoast> Can someone explain to me the "k" in the kind for Const: Const :: * -> k -> *
01:11:27 <ertes> ezyang: it's not?  wouldn't backpack basically make the Reflex class vanish and give us Behaviour, Event, PushM, etc. directly?
01:11:30 <ezyang> halogenandtoast: It's kind polymorphic 
01:11:42 <ezyang> ertes: So, in my Backpack version of Reflex, indeed the Reflex class goes away 
01:11:49 <halogenandtoast> ezyang: thanks, looking that up
01:11:52 <ezyang> but we still need the type parameter two enforce no timeline crossing 
01:12:06 <ezyang> halogenandtoast: You can set k = *, and then you have * -> * -> * 
01:12:10 <Cale> halogenandtoast: That indicates that any kind can be chosen for k, when you use Const, just like how any type can be used for a type variable.
01:12:20 <quchen> halogenandtoast: k can be * (e.g. Int) or * -> * (e.g. Maybe) or Constraint (e.g. Eq ()) or * -> Constraint (e.g. Eq) or … 
01:12:24 <ertes> ezyang: yeah, sure
01:12:44 <ertes> i'm not entirely convinced that multiple timelines are useful, but i haven't really thought about it too much either =)
01:12:54 <ertes> as far as i see the only thing it prevents is global locking
01:12:57 <halogenandtoast> quchen: can't the first * be any of those things as well?
01:13:10 <ezyang> yeah :) 
01:13:14 <cocreature> halogenandtoast: it can’t be Maybe because Maybe has kind * -> * and not *
01:13:19 <ezyang> well, that's why there's Spider Global 
01:13:30 <implementation> quchen: can it also be # (e.g. for Int# ?)
01:13:38 <ertes> Cale: any comments on that?
01:14:11 <ezyang> implementation: yep 
01:15:18 <ertes> in particular: timeline transformers?  like translating a Pure system into a Spider system?
01:15:41 <quchen> implementation: Just like in the type »a -> a«, »a« can be anything – Int, Bool, Maybe (Int,Bool,Char) – the kind »k« can be anything in »* -> k -> *«.
01:15:43 <ezyang> ertes: Definitely not that, but I'm curious what timeline transformers would be for too ^^ 
01:15:58 <ertes> ezyang: why not?  seems like a reasonable thing to do
01:16:23 <ertes> instead of defining events based on effects, you could have events that occur in certain frames chosen by a formula =)
01:16:49 <Cale> We might be able to systematically change the semantics in various ways, like transforming Events so that they can occur multiple times simultaneously (a la Conal's FRP)
01:17:16 <Cale> Or adding nondeterminism (branching timelines)
01:17:32 <implementation> quchen: just remembered that the # kind had some restrictions when it came to polymorphy
01:17:58 <Cale> I haven't come up with anything too hard-hitting that I'd really like to have yet.
01:18:08 <ertes> that's one thing conal and i disagree on (or at least he seemed to revisit that notion when i told him that multi-occurrence is basically equivalent to events over monoids) =)
01:18:13 <Cale> But there are lots of things one could do by transforming a Reflex implementation.
01:18:44 <ezyang> implementation: Certainly, you can't write a function that is polymorphic on # 
01:19:13 <ezyang> Cale: So... when you say timeline transformer, you really mean it in a monad transformer sense? 
01:19:19 <Cale> Perhaps eventually there will be a transformer to add a measure to time
01:19:31 <Cale> yeah
01:20:56 <Cale> (though it's quite likely that adding integrals would be better done just by changing the implementation out altogether -- it's not clear the extent to which you'd have to rework everything to *really* make things efficient)
01:22:51 <ertes> Cale: at this point branching is an O(n) copying process, as far as i can tell
01:23:03 <ertes> number of behaviours + number of events
01:24:41 <Cale> Oh, branching is almost guaranteed to be horrible in terms of performance, but it might be interesting if we could introduce it for some kind of exhaustive testing.
01:25:33 <sm> what about elerea ? It seems to be nice and simple and works well in dow
01:26:06 <sm> I mean, http://hackage.haskell.org/package/dow
01:26:26 <Cale> Well, it doesn't have events, which will work for some applications, but it's pretty limiting.
01:27:03 <sm> I see. Then there's http://hackage.haskell.org/package/euphoria which seems to add events to elerea
01:28:01 <Cale> You end up doing various sorts of (somewhat expensive) edge detection to simulate events if you don't have them. I don't know how euphoria works though, hadn't heard of it before.
01:28:21 <tsahyt> I can "zip" Applicatives using liftA2 (,), but can I unzip them as well?
01:30:12 <tsahyt> so basically I'd need Applicative f => f (a,b) -> (f a, f b)
01:30:37 <Cale> sm: It seems euphoria implements Events as Signals (behaviours) that carry a list of values at each moment -- which means it's sort of just formalising one of the things you can do to try to simulate events in elerea.
01:31:01 <Cale> Well, I haven't really looked in detail what it does from there out
01:31:22 <tsahyt> oh nvm, I don't even need applicative for that of course
01:31:44 <tsahyt> :t fmap fst &&& fmap snd
01:31:47 <lambdabot> Functor f => f (b, b1) -> (f b, f b1)
01:32:12 <jle`> tsahyt: not that that is not necessarily an inverse of liftA2 (,)
01:32:31 <sm> Cale: interesting. I would guess it's somewhat performant since it comes from industry
01:32:35 <tsahyt> jle`: it should be in my case
01:32:36 <Cale> Usually it won't be... thinking of liftA2 as zipping is a bit misleading in some cases
01:32:50 <tsahyt> jle`: I've just been wondering whether I should provide a zip/unzip for my type
01:33:01 <tsahyt> but it can be done in terms of applicative and functor here
01:35:07 <Cale> sm: I'm sure you can do some stuff with it, but I'm less sure about whether it will be competitive with reflex performance-wise :)
01:35:52 <sm> ok. I'd like to see/make a (non-web) game with reflex some time
01:36:51 <sm> dow and the examples in the GPIH book seem to run very well, I guess they are rather simple though
01:36:58 <srhb> sm: Dave Laing was making sdl2 bindings at some point - I got stuck with mine. :)
01:42:21 <ertes> sm: systems like reactive-banana and reflex take an events-first approach
01:42:31 <ertes> all behaviours are derived from events
01:42:43 <ertes> doing the opposite, as far as i can tell, is bound to be inefficient
01:43:57 <Cale> I think reflex can eventually have behaviours which don't come from events
01:44:06 <ertes> sm: just to give you a perspective: reflex can easily handle millions of events and behaviours
01:44:06 <Cale> But it'll take some doing
01:44:12 <ertes> Cale: in fact i'm working on that =)
01:44:34 <Cale> ah, cool :)
01:45:23 <ertes> ryan also agreed to potential semantics changes to make reflex useful for some new application domains like games/simulations, where it will be highly beneficial to have data structure support
01:45:43 <ertes> like a reactive k-d-tree or BSP
01:46:08 <ertes> stuff that only AFRP can handle well right now
02:54:22 <ertes> GHC question: what is more efficient?  keeping values (mostly IORefs) in a data constructor and exposing separate functions for using them, or keeping those functions themselves in the constructor and letting GC take care of keeping values?
02:56:12 <ertes> i would expect the former to be more efficient, because when the data constructor dies, GC will know that the values it contained can also be GCed, whereas for functions it would have to track the closure of each
02:58:28 <ezyang> The second scheme is more indirect 
02:58:48 <ezyang> In the first scheme, you directly access the IORef stored in the data structure 
02:58:56 <ezyang> In the second scheme, you have to go through the closure to get to the IORef 
02:59:14 <ezyang> Although, this is all a bit specious because IORefs are hella indirect to begin with 
03:01:22 <ertes> ezyang: yeah, that doesn't really matter…  could as well be any other value
03:01:42 <ertes> ezyang: so you would expect the same?
03:02:39 <ezyang> Well, yes 
03:02:48 <ezyang> Also if you're storing the functions, that's dynamic dispatch 
03:05:03 <ertes> ezyang: what does that entail?  i would expect it to require function pointers instead of known addresses, but x86 is reasonably good at dealing with those
03:05:45 <ezyang> The greatest cost of indirection is not so much the jump, but the inability of GHC to inline the target 
03:05:55 <ertes> ah, yes
03:05:58 <ertes> good point
03:07:04 <bollu> ezyang: I am trying to understand how to optimise STG. Doesn't every continuation incur an indirect jump as it is a function pointer?
03:07:39 <ezyang> bollu: Yes? But only if you're passing around the continuation explicitly 
03:07:57 <bollu> ezyang: but, like, inside STG, isn't "everything a continuation"?
03:08:23 <ezyang> ..err, not really? 
03:09:27 <bollu> ezyang: hm, OK
03:09:43 <ertes> i think STG only has TCO "built-in" in a sense
03:09:48 <bollu> ezyang: I was of the understanding that the "tagless" implied that nothing is tagged. Rather, one simply executes the function pointer
03:10:35 <ertes> as in: in something like (f (g x)), g is more likely to jump directly to f
03:10:55 <ertes> this might seem like CPS, but it's not
03:10:58 <ezyang> bollu: Oh, well, GHC doesn't actually implement tagless design haha 
03:11:14 <bollu> ezyang: oh, interesting xD
03:11:21 <bollu> ezyang: OK, so what does GHC implement?
03:11:23 <ezyang> http://simonmar.github.io/bib/papers/ptr-tagging.pdf 
03:11:50 <bollu> ezyang: oh, OK, thanks
03:11:57 <bollu> ezyang: one more thing to read :P
03:12:14 <ezyang> this paper is "more modern" than the STG paper, so it should be easier 
03:13:15 <bollu> ezyang: another question: how well does GHC auto parallelise?
03:13:19 <bollu> ezyang: (at all?)
03:13:34 <bollu> ezyang: but all the architectures are based on STG, right?
03:14:11 <ezyang> GHC doesn't really auto parallelize, but it has sparks and stuff like that? 
03:14:20 <ezyang> I don't understand your other q 
03:17:53 <bollu> ezyang: the push/enter and eval/apply
03:17:58 <bollu> ezyang: it applied "on top of" STG?
03:18:09 <ezyang> that's a funny thing to say 
03:18:47 <bollu> ezyang: how so?
03:19:13 <ezyang> I guess you could say, yes, semitagging was built on top of the STG model 
03:19:46 <bollu> ah, OK
03:27:52 <ertes> ezyang: reading the paper gives me the impression that each and every evaluation layer needs an indirect jump…  is this true for GHC, or does it employ further optimisations?
03:28:09 <ertes> (for unevaluated thunks that is)
03:32:00 <ezyang> an unevaluated thunk will always need an indirect jump 
03:32:31 <ertes> i see
03:32:50 <ezyang> note that GHC's optimizer will try to eliminate thunks as much as possible 
03:34:42 <kgadek_> ezyang: you mean strictness analyser or other part of optimiser (all parts?)
03:35:00 <ezyang> strictness analyzer mostly, I think! 
03:35:35 <merijn> I wonder how much of GHC's machinery could be lifted out and made Haskell agnostic (i.e., the Core->STG->Cmm->LLVM pipeline)
03:36:37 <merijn> It would be nice to have a machinery for Core (or whatever) similar to what LLVM is for assembly. So that you wouldn't have to reinvent all of GHC work when you wanna write your own compiler
03:39:39 <ertes> i guess most people would rather implement a new language
03:39:52 <ezyang> Well, external core used to be a thing 
03:39:58 <ezyang> it probably can be a thing, given enough love and attention 
03:40:01 <merijn> ertes: I would rather implement a new language, but I would rather NOT reinvent optimisation passes from scratch
03:41:18 <ertes> well, most new languages need a different core, unless you're making another instance of the historical mistake to reinvent the square wheel =)
03:41:29 <ertes> like a dependently typed core
03:41:43 <bollu> ertes: …wait what? :dependently typed core"?
03:42:06 <ertes> bollu: sure…  in GHC's core the value and type languages are still separate
03:42:54 <bollu> ertes: isn't Core untyped?
03:42:57 <bollu> oh no, wait
03:43:04 <ezyang> STG is untyped 
03:43:11 <bollu> stuff gets desugared to Core and then type-checking happens on core, right?
03:43:13 <bollu> STG is untyped, yeah
03:43:16 <ertes> bollu: GHC just doesn't use core's type system in production
03:43:22 <ertes> it's mostly used for testing core transforms
03:43:34 <bollu> I see
03:43:43 <ezyang> ...well, we do run core lint on every test in the test suite ;) 
03:43:48 <bollu> so where does the "actual" type checking happen?
03:43:55 <ezyang> the "Frontend" 
03:44:03 <bollu> ertes: also, since you are here, where does the desugaring for applicative-do happen? :)
03:44:10 <ertes> bollu: type-checking actually checks haskell code, not the generated core
03:44:14 <bollu> I see
03:44:25 <ertes> reason, i guess, is better error reporting
03:44:47 <Jaak> @unpl \x -> or[True|Just{}<-[x]]
03:44:47 <lambdabot> \ x -> or [True | Just{} <- [x]]
03:44:57 <ertes> bollu: i don't know…  probably the same phase regular do-desugaring takes place in
03:44:59 <bollu> what does unpl do?
03:45:07 <bollu> ertes: I found code in RnExpr.hs
03:45:10 <ertes> the opposite of @pl =)
03:45:15 <ertes> @unpl f . g
03:45:15 <lambdabot> (\ x -> f (g x))
03:45:16 <bollu> ertes: but it seems too simple to be true at a cursory glance
03:45:19 <bollu> ah
03:45:21 <Jaak> oops
03:45:24 <Jaak> @pl \x -> or[True|Just{}<-[x]]
03:45:25 <lambdabot> (line 1, column 19):
03:45:25 <lambdabot> unexpected "{"
03:45:25 <lambdabot> expecting variable
03:46:08 <bollu> @pl \x -> or[True | Just(_)<-[x]]
03:46:09 <lambdabot> (line 1, column 23):
03:46:09 <lambdabot> unexpected '_'
03:46:09 <lambdabot> expecting variable
03:46:12 <bollu> uh
03:46:31 <ertes> @pl [ x | x <- [1..5] ]
03:46:31 <lambdabot> [x | x <- [1..5]]
03:47:59 <ertes> :t foldr (flip (`maybe` const True)) False
03:48:02 <lambdabot> Foldable t => t (Maybe b) -> Bool
03:48:08 <Jaak> nice
03:48:19 <ertes> no, it's not =)
03:48:39 <ertes> > foldr (flip (`maybe` const True)) False [Nothing, Nothing, Nothing]
03:48:42 <lambdabot>  False
03:48:55 <ertes> > foldr (flip (`maybe` const True)) False (Nothing : Just 5 : repeat Nothing)
03:48:59 <lambdabot>  True
03:50:08 <ertes> > not . null . concatMap (maybe [] pure) $ [Nothing]
03:50:12 <lambdabot>  False
03:50:20 <ertes> > not . null . concatMap (maybe [] pure) $ (Nothing : Just 5 : repeat Nothing)
03:50:23 <lambdabot>  True
03:50:28 <ertes> Jaak: better
03:50:54 <ertes> i can actually tell what this code does without @unpl-ing it in my head =)
03:51:26 <ertes> :t or . fmap (maybe False (const True))
03:51:32 <lambdabot> (Foldable t, Functor t) => t (Maybe b) -> Bool
03:51:34 <ertes> even better
03:51:57 <ertes> except that it requires Functor
03:52:13 <Jaak> i'm bummed about the maybe tho, not easy generalize
03:52:28 <ertes> :t or . fmap (foldr (\_ _ -> True) False)
03:52:30 <lambdabot> (Foldable t1, Foldable t, Functor t) => t (t1 a) -> Bool
03:52:36 <ertes> Jaak: better?
03:52:52 <ertes> or rather
03:52:58 <ertes> :t or . fmap (not . null)
03:53:00 <lambdabot> (Foldable t1, Foldable t, Functor t) => t (t1 a) -> Bool
03:53:37 <bollu> :t or
03:53:40 <lambdabot> Foldable t => t Bool -> Bool
03:54:00 <bollu> ah, that is cool.
03:54:08 <Jaak> hmm, not really, the aim was to write "generic" isFoo function where Foo is some constructor
03:54:33 <bollu> so, you replace every Maybe with True / False based on (not. null), exploiting the fact that it is a foldable, and then use "or" to or all the Bools, right?
03:54:39 <Jaak> as in isFoo x = or[True|Foo{}<-[x]]
03:54:47 <ertes> :t foldr ((||) . not . null) False
03:54:49 <lambdabot> (Foldable t1, Foldable t) => t (t1 a) -> Bool
03:55:06 <bollu> ertes: can you non mconcat?
03:55:11 <merijn> Jaak: You can't really write a generic version like that since there's no "first-class" patterns
03:55:12 <bollu> ertes: with Any?
03:55:28 <ertes> bollu: sure
03:55:43 <bollu> merijn: I think you can with lens
03:55:50 <bollu> merijn: take a prism as a parameter and use "has"
03:55:53 <ertes> :t getAny . foldMap (Any . not . null)
03:55:55 <lambdabot> (Foldable t1, Foldable t) => t (t1 a) -> Bool
03:56:00 <ertes> bollu: ^
03:56:01 <merijn> bollu: prisms aren't general
03:56:06 <Jaak> merijn: hmm, figured something like that. was curious if one could write than version even in a more pointless style :p
03:56:08 <merijn> bollu: You need to handwrite one for each constructor
03:56:29 <bollu> merijn: but you can makePrisms?
03:56:40 <bollu> ertes: neat
03:56:49 <bollu> :t foldMap
03:56:49 <merijn> Sure, but you can trivially write TemplateHaskell for what Jaak wants too
03:56:52 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
03:57:00 <bollu> oh, neat
03:57:03 <bollu> :t mconcat
03:57:07 <lambdabot> Monoid a => [a] -> a
03:57:28 <ertes> if you want mconcat, you need Functor again
03:57:45 <ertes> :t getAny . mconcat . fmap (Any . not . null)
03:57:47 <lambdabot> Foldable t => [t a] -> Bool
03:57:57 <ertes> and it's less general, too
03:58:03 <ertes> uhm
03:58:03 <bollu> yeah
03:58:07 <ertes> yeah, that was non-sense =)
03:58:11 <bollu> because it is specialised to []
03:58:15 <ertes> if you want mconcat, it's less general =)
03:58:21 <bollu> :)
03:58:29 <bollu> not "necessarily"
03:58:33 <bollu> ertes: I can use toList :P
03:58:36 <ertes> but foldMap is basically mconcat on steroids
03:58:41 <bollu> yeah, I can see that.
03:58:44 <bollu> :t foldMap
03:58:48 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
03:59:00 <ertes> :t getAny . fold . fmap (Any . not . null)
03:59:03 <lambdabot> (Foldable t1, Foldable t, Functor t) => t (t1 a) -> Bool
03:59:04 <bollu> ertes: it's quite cute, it transforms each element into the monoid and then collapses it
03:59:14 <ertes> yeah
03:59:14 <bollu> ertes: I should know Foldable better
03:59:20 <ertes> it's MapReduce without the parallelism =)
03:59:30 <bollu> ertes: xD
04:02:46 <lpaste_> bollu pasted “flexible-context-for-parsec?” at http://lpaste.net/352809
04:02:56 <bollu> help with compile error?
04:03:14 <bollu> Non type-variable argument in the constraint: Text.Parsec.Prim.Stream s m Char
04:04:27 <bollu> (what is the error trying to say?(
04:05:00 <bollu> why is it not specialising the monad to Identity?
04:05:51 <bollu> huh, if I lift it to toplevel and give it a signature, it works
04:05:55 <bollu> so it's some type inference thing?
04:08:47 <ertes> another question about unsafePerformIO: in order to prevent let-floating, would it be enough to force an arbitrary function argument?  like:  f x y = _ where ref = unsafePerformIO (y `seq` newIORef Nothing); {-# NOINLINE ref #-}
04:09:14 <ertes> preferably: is there a way to do it without forcing anything?
04:10:18 <ertes> it would be extremely useful to have a pragma for such things that does everything necessary to make it safe:  {-# UNSAFE_IO ref #-}
04:13:02 <bollu> wha does flexibleContexts do and why does haskell not automatically infer the type in the lpaste?
04:13:28 <slack1256> how is the idiomatic use of bidirectional pipes? (Pipes.Core). On unidirectional one, you compose the Producers and Consumers separately and a single >-> in the middle, the result *will* be an Effect
04:13:33 <merijn> bollu: FlexibleContexts allows constraints that include non-type variables
04:13:45 <slack1256> does bidirectional pipes have a similar rule?
04:13:57 <merijn> bollu: i.e. "(Foo Int a) =>" normally you can only have "(Foo a b) =>" as constraint because the report is rather conservative
04:14:21 <merijn> bollu: It *is* inferring the type, it's just that said type is illegal without the extension
04:16:50 <bollu> merijn: I see
04:16:53 <bollu> meriinteresting
04:16:57 <bollu> merijn: interesting*
04:18:03 <bollu> also, unrelated question: how do I go from (forall f. Functor f => (a -> f b) -> (s -> f t)) to instance (Coyonda g, Cthulu f, Profunctor p) => s p f g or whatever the lens types are? :P
04:18:12 <bollu> I understand the first part
04:18:24 <bollu> but, like, where's the "gap bridging"?
04:19:28 <Cooler> in this book, it says you can accumulate errors with applicative, but with monad it short circuits on the first error?
04:19:40 <Cooler> i am paraphrasing
04:20:08 <Cooler> why is that?
04:21:00 <Cooler> so you can accumulate errors with the Validation datatype
04:21:02 <Rembane> Because both behaviours are useful.
04:21:06 <Cooler> why can
04:21:12 <Cooler> 't you do the same with monad/
04:21:16 <Cooler> ?
04:21:18 <Rembane> And they are defined that way.
04:21:24 <guardianN> bok bok
04:22:19 <Cooler> "Note that Either always short-circuits on the first thing to have failed. It
04:22:19 <Cooler> must because in the Monad, later values can depend on previous ones:"
04:22:20 <sbrg> Cooler: well, "applicative" and "monad" are just patterns, so to speak. how exactly the semantics are defined depends on each instance definition. 
04:22:40 <sbrg> there is a difference between what can be achieved in terms of power and such when it comes to applicative and monad, so maybe that's what you're looking for?
04:22:41 <Cooler> it says it "must" do that
04:23:13 <sbrg> Cooler: yes, that's one way to make (Either a) an instance of Monad. it's a pretty useful one, but there are others that make sense and are also useful
04:24:01 <Cooler> well it sounds like its saying no
04:24:52 <sbrg> Cooler: the way that Either has been made an instance of Monad in the base libraries exhibits the semantics described above
04:25:32 <sbrg> it also makes sense, since if you have a computation that at some point depends on previous computations to (successfully) return a value so that they can continue, it obv. can't continue if it didn't successfully return a value
04:26:04 <Cooler> "you can’t make a Monad for Validation that
04:26:04 <Cooler> accumulates the errors like the Applicative does."
04:26:27 <Cooler> its saying no
04:35:24 <cocreature> Cooler: the problem is that if you have something like "Failure e >>= f" you can’t apply f to anything and check if it evaluates to Failure e' so that you can then combine them with mappend
04:36:26 <Cooler> cocreature, why isn't that a problem with Applicative?
04:37:37 <cocreature> Cooler: because the left and the right argument of <*> are independent, so you can check if the right one is Failure even if the left one is Failure
04:38:02 <cocreature> :t (>>=)
04:38:05 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:38:25 <Cooler> :t (<*>)
04:38:27 <cocreature> you don’t get the "a" if the first argument evaluates to "Failure e"
04:38:30 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
04:39:07 <Cooler> they look similar
04:39:19 <Cooler> oh wait i get it
04:39:34 <Cooler> its because the structure is outside the function
04:39:53 <Cooler> whereas with monad you need to apply the function to get the structure
04:40:32 <cocreature> yep, and applying the function requires, that the first argument evaluates to Success a, so you get an argument that you can apply the function to
04:41:16 <bollu> what is the difference between "mtl" and "transformers"?
04:41:35 <merijn> bollu: mtl provides convenience type classes for use with transformers
04:41:42 <bollu> I see
04:42:06 <Cooler> data Sum a b = First a | Second b deriving (Eq, Show)
04:42:10 <merijn> So you can use transformers without mtl, but not mtl without transformers
04:42:11 <Cooler>     (<*>) (First e) _ = (First e)
04:42:24 <Cooler> can i not take the function out of First and apply it?
04:42:50 <Cooler>     (<*>) (First e) (Second a) = Second (f a)
04:43:19 <Cooler> or
04:43:21 <cocreature> Cooler: the important part is that you can do (<*>) (First e) (First e') = First (mappend e e')
04:43:24 <Cooler>     (<*>) (First e) (Second a) = First (f a)
04:44:06 <Cooler> no theres no monoid type constraint
04:44:23 <cocreature> what is "f" supposed to be here? that variable doesn’t exist
04:44:33 <Cooler>     (<*>) (First f) (Second a) = First (f a)
04:44:40 <cocreature> that won’t typecheck
04:44:41 <Cooler> is that not valid
04:45:01 <cocreature> try it :)
04:46:53 <Cooler> it says the actual type of f is a
04:47:14 <Cooler> and so its not a function, but a can be a function type can't it?
04:47:24 <Cooler> a can be b -> c
04:50:22 <Cooler> cocreature, ^
04:52:08 <BernhardPosselt> why doesn't head simply return a Maybe?
04:52:18 <BernhardPosselt> instead of panicking when it encounters an empty list
04:53:04 <Cooler> why doesn't read do the same
04:53:05 <merijn> Two reasons: 1) historical mistake and 2) sometime that's what you need, for example "map head . group" is perfectly safe (because group doesn't return empty lists), but writing the same code with Maybe involved would be cumbersome
04:53:22 <merijn> Cooler: We have readMaybe since GHC 7.6!
04:53:28 <merijn> :t Text.Read.readMaybe
04:53:31 <lambdabot> Read a => String -> Maybe a
04:53:45 <Cooler> can you derive it?
04:54:07 <jnj> BernhardPosselt, there is also listToMaybe in Data.Maybe if you wish to avoid head.
04:54:16 <BernhardPosselt> ah right
04:54:45 <merijn> Cooler: It just uses Read
04:54:58 <Cooler> oh
04:54:59 <merijn> Cooler: So "deriving (Read)" already makes it work
04:55:03 <Cooler> right
04:55:11 <merijn> Cooler: Note the "Read a => String -> Maybe a" constraint :)
04:56:40 <ahihi> maybe group should have a return type of [NonEmpty a] ;)
05:00:44 <quchen> NonEmpty is much newer than group, but yes.
05:02:02 <cocreature> Cooler: it _can_ be a function, but if you make an "instance Applicative (Sum a)" you can’t chose what a is. it has to work for any a
05:03:24 <chocopuff> I'm trying to use the System.Process module, I'm a bit confused about the typeclasses. I defined a function "test" by test :: String -> [String] -> IO GHC.IO.Exception.ExitCode
05:03:39 <chocopuff> test = rawProcess "ls" []
05:04:07 <chocopuff> I found the type of *rawSystem (sorry typo) and copied it verbatim, but ghc is giving me errors during compile
05:04:21 <chocopuff> saying the type could not be matched. am not sure what is going on
05:04:45 <Cooler> cocreature, right
05:05:01 <mauke> chocopuff: consider the following code: foo :: String -> Int; foo = length "abc"
05:05:07 <mauke> do you see a problem with that?
05:06:28 <mauke> (there are no wrong answers, I'm just trying to bisect the explanation space)
05:07:09 <chocopuff> mauke: isn't foo just type int? 
05:07:18 <mauke> right
05:07:36 <chocopuff> mauke: I think, I'm getting there but unable to connect the dots yet
05:07:58 <mauke> what's the type of rawSystem?
05:07:59 <chocopuff> mauke: oh shoot! sorry, I forgot the modify the code
05:08:09 <chocopuff> I meant to write test x = rawProcess "ls" [x]
05:08:33 <chocopuff> mauke: rawSystem :: String -> [String] -> IO GHC.IO.Exception.ExitCode
05:08:36 <chocopuff> sorry about that
05:08:39 <mauke> what's the type of rawSystem "ls"?
05:09:46 <chocopuff> mauke: rawSystem "ls" :: [String] -> IO GHC.IO.Exception.ExitCode
05:10:08 <chocopuff> That's the currying taking place I believe
05:10:13 <mauke> correct
05:10:38 <mauke> then I'm not sure what's unclear
05:10:41 <Cooler> look the type of test x
05:10:44 <mauke> how many arguments does test take?
05:10:58 <Cooler> look at*
05:12:52 <chocopuff> mauke: I thought the error was saying the output was type IO GHC.IO.Exception.ExitCode
05:13:18 <mauke> what's the error message?
05:13:53 <chocopuff> will be back in a few minutes, going to try again
05:15:59 <spatial> Still have a question. Transform lists of data into GUI co-ordinate system and display. How ?
05:16:45 <srhb> spatial: Like a plot?
05:16:50 <srhb> Your question isn't very specific.
05:17:00 <Cooler> this book seems to imply that monads allow you to look at the result of previous computations
05:17:04 <spatial> A grid or board game.
05:17:15 <Cooler> but applicatives and functors don't?
05:17:39 <srhb> spatial: The answer will mostly depend on which toolkit you use to draw the image.
05:17:58 <spatial> http://stackoverflow.com/questions/41930307/linking-ocaml-record-with-its-gui-representation
05:18:12 <spatial> I asked a OCaml question there
05:18:47 <srhb> spatial: And?
05:19:16 <spatial> So there was a functional approach suggested.
05:19:37 <spatial> Trying to learn a Haskell way of doing it.
05:20:21 <srhb> spatial: Looks like it's basically the same approach.
05:20:33 <srhb> Or well, that would be possible.
05:21:09 <chocopuff> mauke: I understand now! thanks. managed to get it fixed
05:21:30 <chocopuff> mauke: partly was my carelessness and using String instead of [String] in definition
05:21:46 <srhb> spatial: Perhaps check out the gloss examples (the conway one, for instance)
05:21:47 <chocopuff> this is fun, thanks for your guidance
05:22:04 <spatial> Let me check.
05:22:46 <srhb> spatial: After that you can read the definition of simulate and decide if that looks like something you'd want to do.
05:22:56 <spatial> Don't want libraries.
05:23:08 <mauke> heh
05:23:14 <srhb> spatial: Eventually you will need one to put stuff on your screen.
05:23:14 <Cooler> can't applicatives and functors look at the result of previous computation?
05:23:16 <spatial> Maybe I will try the OCaml solution.
05:23:23 <srhb> spatial: Goes for that one as well.
05:23:40 <spatial> Right
05:23:47 <mauke> the ocaml solution uses the lablgtk library
05:24:05 <srhb> And if you were to reimplement that, you'd end up in imperative horror land anyway.
05:24:17 <srhb> Libraries can hide that for you.
05:24:24 <srhb> Keeps you sane. More or less. :-)
05:25:56 <Cooler> anyone?
05:26:47 <srhb> Cooler: What do you mean by "previous computation" ?
05:26:54 <pavonia> They can't look at the result of any other actions
05:30:28 <Cooler> srhb, i don't know thats whats it says in the book
05:31:07 <Cooler> we are basically talking about chaining function application
05:31:21 <Cooler> using <*>
05:34:29 <Cooler> > pure (+1) <*> (pure (*2) <*> pure 2)
05:34:35 <lambdabot>  error:
05:34:35 <lambdabot>      • Ambiguous type variables ‘f0’, ‘b0’ arising from a use of ‘show_M19995...
05:34:35 <lambdabot>        prevents the constraint ‘(Show (f0 b0))’ from being solved.
05:35:01 <Cooler> weird it works in REPL
05:35:23 <Cooler> gives 5 as the result
05:36:00 <Cooler> > pure (+1) <*> (pure (*2) <*> pure 2 :: Maybe Int)
05:36:06 <lambdabot>  Just 5
05:36:36 <Cooler> see the result does depend on previous computations
05:36:55 <mauke> what do you mean by "previous computation"?
05:37:10 <Cooler> mauke, that basically
05:37:38 <mauke> that's a definition up with which I shall not put
05:38:02 <Cooler> the result of the rest of chain depends on the result of the previous function applications
05:38:52 <mauke> > return (+1) `ap` (return (*2) `ap` return 2) :: Maybe Int
05:38:57 <lambdabot>  Just 5
05:38:59 <Cooler> mauke, also its not what i mean by it, its what the book means
05:39:35 <Cooler> and i am not sure what definition they are using
05:41:02 <t4nk800> What is the syntax for multiple let expressions in a list comprehension?
05:41:40 <mauke> ?
05:41:44 <Cooler> 1. With the Maybe Applicative, each Maybe computation fails or succeeds
05:41:45 <Cooler> independently of each other. You’re just lifting functions that
05:41:45 <Cooler> are also Just or Nothing over Maybe values.
05:41:45 <Cooler> 2. With the Maybe Monad, computations contributing to the final result
05:41:45 <Cooler> can choose to return Nothing based on “previous” computations.
05:42:22 <tdammers> > [ (x, y) | x <- [1,2,3], y <- [4,5,6] ]
05:42:29 <lambdabot>  mueval-core: Time limit exceeded
05:42:32 <tdammers> hehe
05:42:36 <tdammers> > [ (x, y) | x <- [1,2,3], y <- [4,5] ]
05:42:42 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
05:42:53 <tdammers> t4nk800: ^ like this?
05:42:58 <t4nk800> what if i want to insert let expressions in the list comprehension?
05:43:07 <mauke> just ... do it?
05:43:27 <tdammers> > [ let pair = (x, y) in pair | x <- [1,2], y <- [4,5] ]
05:43:34 <lambdabot>  mueval-core: Time limit exceeded
05:43:39 <tdammers> wat
05:44:35 <athan> that's a good find o-o
05:45:46 <athan> > do {x <- [1,2]; y <- [4,5]; let pair = (x,y) in pair}
05:45:50 <pavonia> Cooler: With Applicative all actions could be evaluated in parallel because they are independent of each other, imagine the results of all are combined at the end
05:45:52 <lambdabot>  error:
05:45:52 <lambdabot>      • Couldn't match type ‘(,) Integer’ with ‘[]’
05:45:52 <lambdabot>        Expected type: [b]
05:46:02 <athan> ermp
05:46:07 <athan> > do {x <- [1,2]; y <- [4,5]; pure $ let pair = (x,y) in pair}
05:46:11 <lambdabot>  [(1,4),(1,5),(2,4),(2,5)]
05:46:23 <yushyin> > [let p = (x, y) in p | let y = 1, let x = 'a']
05:46:29 <lambdabot>  [('a',1)]
05:46:30 <pavonia> Cooler: With Monad you can't (always) evaluate then in parallel, because one action could depend on the result of any other action
05:46:45 <t4nk800> if I have mutiple let expressions are they separated with commas : let a = 3+x, let b = a+3?
05:46:56 <mauke> yes
05:47:03 <t4nk800> thank you.
05:47:12 <Cooler> pavonia, well no when you chain using <*> each function does depend on the previous result
05:47:25 <Cooler> you can't run that in parallel
05:47:34 <pavonia> You can
05:47:49 <Cooler> > pure (+1) <*> (pure (*2) <*> pure 2 :: Maybe Int)
05:47:52 <pavonia> How does it depend on the previous one?
05:47:53 <lambdabot>  Just 5
05:48:17 <Cooler> you have to run *2 on 2 first
05:48:24 <mauke> Cooler: you can run pure (+1), pure (*2), pure 2, all in parallel
05:48:25 <Cooler> then +1
05:48:45 <Cooler> mauke, what?
05:50:14 <Cooler> mauke, ok well that makes sense if its IO (+1)
05:51:08 <Cooler> but you still need to chain them in order when evaluating the expression
05:51:20 <pavonia> You have to distunguish between the evaluation of the actions and combining the results of these actions. The latter of course has so certan order because you are applying a function to various parameters
05:51:38 <mbrock> in ghci, can I somehow get a maximally polymorphic type of a top-level definition that has been monomorphized?
05:52:14 <mbrock> like, print the constraints that can be derived from the definition
05:52:17 <pavonia> Cooler: But with Monad you can't even evaluate an action itself without having evaluated the previous actions
05:53:00 <mbrock> ahh, I just disable the monomorphism restriction and there we go
05:53:19 <pavonia> Cooler:  (>>=) takes an additional parameter which is the result of the previous action. You need this to even know how the second action looks like
05:54:02 <Cooler> pavonia, what do you mean another parameter?
05:54:12 <Cooler> hidden parameter?
05:54:13 <pavonia> :t (<*>)
05:54:36 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
05:54:44 <pavonia> :t (>>=)
05:54:46 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:55:28 <pavonia> Cooler: I meant the 'a' in the second function
05:55:41 <mauke> do { c <- getChar; case c of { '-' -> getChar; '?' -> return 'A'; _ -> putchar c >> return c }  -- can't do this with Applicative
05:56:33 <mauke> depending on the result of the first getChar, we either run a second getChar, do nothing, or run a putChar
05:58:35 <Cooler> well i think it would be a lot clearer to say the each structure is independent in case of functor or applicative
05:59:17 <Cooler> instead of saying computation because that makes it seem like your talking about (+1) $ (*2) 2
06:13:18 <Cooler> is this a valid Applicative? http://lpaste.net/352815
06:13:28 <Cooler> seems like it would fail composition
06:14:03 <merijn> Cooler: Hard to say without the definition of CountMe
06:14:05 <Cooler> or maybe not
06:14:40 <Cooler> data CountMe a = CountMe Integer a deriving (Eq, Show)
06:14:41 <merijn> Actually it isn't valid, because of your choice of pure :)
06:14:51 <merijn> '0' is not the identity for *
06:15:00 <merijn> But you could make a valid one
06:15:14 <Cooler> oh
06:15:16 <Cooler> right
06:15:23 <Cooler> "This’ll pass as a valid Functor and Applicative, but it’s not a valid Monad." they need to fix that
06:15:26 <merijn> Actually, you could make 2 (probably even more :p) valid ones
06:15:46 <warbo> hello, I'm feeding large lazy values into a hashing algorithm and want to know if it's running in constant space (forcing part of the value, updating the hash, recursing on the rest, garbage-collecting the forced part)
06:16:06 <warbo> I'd like to do thi programatically, rather than fiddling with GHC options from bash
06:16:29 <warbo> I've played with weigh, but it only seems to give me total allocation, rather than e.g. max residency
06:16:35 <warbo> is there a better tool for this?
06:17:28 <merijn> warbo: For finding out the memory usage of code?
06:17:36 <warbo> yes
06:17:41 <Zemyla> How are pinned byte arrays garbage collected?
06:17:42 <merijn> warbo: The sanest way is to build a profiling version
06:18:03 <merijn> warbo: And then run your code with "+RTS -sstderr" to get GC statistics
06:21:28 <ph88> i was looking at this tutorial https://generics-eot.readthedocs.io/en/latest/tutorial.html#th-example-meta-information-with-types-generating-sql-schemas and wondering if this does allow me to find a field of a certain type in a data structure, can i test for a specific type and then change the value? does someone know?
06:22:11 <warbo> merijn: hmm, I was afraid of that; might as well just use /usr/bin/time in that case
06:22:12 <warbo> thanks
06:22:27 <merijn> warbo: How so?
06:22:46 <merijn> warbo: Time measures runtime, profiling measures GC time, allocation rate, max residency, etc.
06:23:55 <warbo> time can report memory usage, page faults, context switches, etc. as well
06:24:14 <merijn> warbo: Sounds like you're using a non-POSIX time?
06:24:23 <warbo> yup
06:24:31 <warbo> GHC is a non-POSIX program too
06:24:35 <warbo> so nothing lost ;)
06:25:07 <merijn> warbo: Anyway, I'd still use profiling, because that can also give you call stacks and produce graphs *where* memory is allocated in the source
06:25:25 <merijn> warbo: So it will almost certainly be more useful for analysing your results
06:25:59 <warbo> merijn: I already have a bunch of test cases, using various hash implementations on data of various sizes
06:26:20 <warbo> but I've been running them through weigh, which tells me that they all use a bunch of memory
06:27:12 <warbo> but doesn't tell me whether that was being allocated and collected in small chunks, or building up
06:27:44 <warbo> the only indication I have is to watch `top` as it runs
06:28:06 <merijn> I just don't really understand the reason not to use GHC's profiling, given that it provides you A LOT of very detailed info
06:28:43 <warbo> I mostly don't want to wait all day for all my dependencies to be built with profiling enabled
06:29:07 <warbo> I've done it before, and it took several hours
06:29:17 <merijn> warbo: Ah, are you using cabal or stack?
06:29:21 <warbo> Nix
06:29:27 <warbo> with cabal
06:30:24 <warbo> I've spend many hours trying to make stack run; might as well have been banging my head against a wall ;)
06:30:25 <merijn> warbo: For the future: edit your ~/.cabal/config and set "library-profiling: True" that makes cabal always build profiling versions when installing libraries
06:30:59 <warbo> I don't like my builds depending on personal preferences
06:31:01 <merijn> warbo: That way you will always already have profiling libraries build whenever you decide you want to profile stuff (at the cost of making installs slightly slower, since it always builds profiling...)
06:31:31 <merijn> warbo: How does it make your build depend on personal preferences?
06:31:42 <warbo> I've got a dedicated set of `profiledHaskellPackages`, with profiled libraries for GHC 7.8.4, 7.10.3, 8.0.1, etc.
06:31:45 <merijn> warbo: By default it will still use non-profiling versions
06:32:15 <merijn> It just means that when you realise "I want to profile this" you will already preemptively have the profiling versions installed too
06:32:33 <warbo> I don't have *any* Haskell packages installed
06:32:36 <warbo> because I use Nix
06:32:56 <merijn> I'm sure Nix has some way to do the same (at least, so I hope...)
06:33:03 <warbo> (well, I do have a minimal GHC installed, so I can do Prelude stuff in GHCi)
06:33:17 <warbo> Nix is lazy
06:33:22 <warbo> it builds stuff as needed
06:33:34 <warbo> if profiled versions weren't needed, they won't be built
06:33:50 <warbo> until asked for, then they're all built at once
06:33:51 <merijn> Well, I guess that means I can preemptively scratch learning Nix of my todo list :)
06:34:12 <warbo> (well, the ones being used; not the whole of Hackage ;) )
06:35:08 <bollu> is there a way to have a parser combinator that accepts a token based on a predicate?
06:35:19 <bollu> I'm trying to look for such a combinator but I can't find one
06:35:25 <bollu> in Parsec
06:35:43 <ahihi> satisfy?
06:36:42 <mauwy> Am I incorrect to assume that the ,div, operator always truncates towards negative infinity? When my divisor is negative and dividend positive I get a value that if multiplied by the divisor is greater than the divedend, suggesting it truncated towards posotive infinity. Am I missing something or is it a quirk/bug?
06:37:35 <bollu> :t satisfy
06:37:38 <lambdabot> error: Variable not in scope: satisfy
06:38:25 <bollu> ahihi: oh, looks like there's not one for general parser
06:38:33 <Cooler> i think they need to take a look at the CountMe exercise of the Chapter Monads in this book Haskell Programming from First principles
06:38:37 <bollu> it says "you can build your own on top of TokenPrim"
06:38:42 <ahihi> bollu: ah right, it's for Char only
06:38:47 <Cooler> there seems to be a bunch of errors
06:41:41 <mauke> > div 12 (-5)
06:41:44 <lambdabot>  -3
06:42:09 <mauke> > (/) 12 (-5)
06:42:13 <lambdabot>  -2.4
06:42:18 <mauke> > floor ((/) 12 (-5))
06:42:23 <lambdabot>  -3
06:47:19 <fizbin> Is there any way to get a heap profile to use longer names for cost centers? I'm naming my cost centers with -fprof-auto and have multiple different large pieces labeled "makeMyProp.splitExpan...", which isn't that helpful.
06:48:30 <fizbin> I mean, right now I'm re-running it with SCC annotations at every spot I could think of in that function, but I was wondering if there was a more generic solution that didn't require running a heap profile once to find out what code I should annotate the stuffing out of, and then running it again.
06:50:09 <Cooler> http://lpaste.net/352816
06:50:16 <Cooler> does that work?
06:50:48 <stobix> What's a good package to install if I want to do something like foo:: Natural -> Natural?
06:50:57 <Cooler> seems kinda weird that something like that is a monad
06:51:37 <ph88> Cooler, you know any imperative languages ?
06:51:52 <Cooler> yes
06:52:07 <ph88> if you have a function like   foo(arg1, arg2) {  return "hello";  }   and then you say: kind of weird that something like that is a function
06:52:13 <stobix> Cooler: huh! Yeah, that's a weird monad alright.
06:52:27 <ph88> i think specifically it's weird to ignore the arguments, not that it's a monad perce
06:53:18 <Cooler> what does that have to do with monad?
06:53:32 <ph88> you ignore the arguments with _
06:53:46 <Cooler> so?
06:53:53 <ph88> that's weird lol
06:53:57 <plantedseed> Cale: you still here? what are you up to? you dont remember me and i dont even remember my username but i leanred haskell around 2008-09 and you helped a lot. what are you dong these days? programming in haskell? or is it still the same with haskell jobs another 10 years down the road?
06:54:49 <Cooler> no i am saying its weird that something that basic is a monad
06:54:51 <ph88> and you plantedseed ?
06:55:18 <ph88> Cooler, i know what you were saying, i guess the anology to a function isn't working for you ^^
06:55:40 <Cooler> ph88, well a function can be anything
06:56:04 <Zemyla> Cooler: Nope a is basically a function Void -> a.
06:56:13 <Cooler> you expect more structure with something like a monad
06:56:41 <ph88> Cooler, well you have more structure with the definition of >>= and so forth ..
06:57:07 <Cooler> not really, all they do is return NopeDotJpg
06:57:08 <sm> ertes: very cool (reflex comments)
06:57:29 <Zemyla> The reason it has only one value is that there is only one function of type Void -> a.
06:57:31 <ph88> Cooler, as far as i know it's normal for a monad to return a value
06:57:34 <Zemyla> :t absurd
06:57:38 <lambdabot> Void -> a
07:01:13 <stobix> There is a very similar type to what Cooler describes that can be an Applicative, but not a monad. Interesting that this compiles, whereas the other one doesn't. (Is it data Const a b = Const b? Can't remember.)
07:01:25 <Zemyla> @let newtype Nope a = Nope (Void -> a) -- Cooler
07:01:28 <lambdabot>  Defined.
07:01:36 <merijn> stobix: "data Const a b = Const a" :)
07:01:42 <stobix> ah, right
07:01:42 <Zemyla> @let nopeDotJpg = Nope absurd
07:01:47 <lambdabot>  Defined.
07:02:14 <Zemyla> @let instance Functor Nope where fmap _ _ = nopeDotJpg
07:02:18 <lambdabot>  Defined.
07:03:04 <kgadek_> There was a discussion about incorporating Shake into Stack. The topic seems to be dead though, as there was no top-priority reason to do so, right?
07:03:07 <Zemyla> You can write similar instances for Applicative and Monad.
07:03:38 <kgadek_> re myself: the discussion was here: https://groups.google.com/d/msgid/haskell-stack/5c46f622-a261-487b-96fd-3c9a86edb4ce%40googlegroups.com?utm_medium=email&utm_source=footer
07:04:07 <Cooler> Zemyla, i did already
07:04:16 <Cooler> was just saying its weird
07:06:08 <plantedseed> ph88: what do you mean?
07:06:23 <ph88> are you working with haskell n stuff
07:08:36 <mniip> > case fmap id (Nope id) of Nope f -> f `seq` ()
07:08:39 <lambdabot>  ()
07:08:47 <mniip> curious
07:09:36 <mniip> ah, it is still covariant, nevermind
07:11:14 <mniip> Zemyla, isn't this functor the same as (Void ->) ?
07:22:45 <Cooler> how do you write join in terms of the other functions like fmap >>=
07:23:17 <Cooler> ?src join
07:23:17 <lambdabot> join x = x >>= id
07:24:12 <Cooler> wait what?
07:24:19 <Cooler> oh
07:24:43 <Cooler> wait
07:25:09 <Cooler> isn't the type of id there m a -> m a ?
07:25:17 <mauke> yes
07:25:20 <mauke> \x -> do { y <- x; z <- y; return z }
07:25:37 <Cooler> so how does that type check?
07:26:01 <merijn> Cooler: Well, what's the type of 'x' there? :)
07:26:06 <Cooler> >>= needs a -> ma
07:26:09 <Cooler> >>= needs a -> m a
07:26:27 <merijn> Cooler: No, >>= needs 'a -> m b'
07:26:34 <Cooler> right
07:26:42 <merijn> Cooler: But it's perfectly fine if 'a == m b'
07:26:56 <Cooler> hmm
07:28:12 <merijn> So, can 'id :: c -> c' be equal to 'a -> m b'? Well 'c == a' and 'c == m b' in that case, so it's fine IFF 'a == m b'
07:30:15 <merijn> Now, 'join :: m (m a) -> m a' so in 'x >>= id' we have 'x :: m (m a)' (from join) and 'id :: m b -> m b' (from >>=)
07:30:32 <merijn> Plug those into the type of >>= and we see that, indeed, the signature of join falls out
07:33:05 <merijn> Unrelatedly, I aspire to be as entertaining a speaker as Wadler is...
07:33:15 <merijn> His strange loops talks are gold :>
07:38:27 <max3> i'm going to get raked over the coals for this but how do i use the global-variables package?
07:41:17 <sm> max3: there's an example in the haddock
07:41:26 <max3> in ghc it works
07:41:31 <max3> but not in a script
07:41:35 <max3> *in ghci it works
07:41:38 <max3> but not in a script
07:43:18 <spatial> list of lists and each element also has a label. Is there a way to associate a label ?
07:47:16 <lyxia> max3: what did you do that doesn't work
07:47:24 <max3> i got it working
07:47:27 <max3> thanks
07:49:17 <max3> lyxia, i am a little confused though about how i access the access the variable
07:49:28 <max3> in this script i'm accessing it using the bound name
07:49:35 <max3> but what is the quoted string for then?
07:49:57 <merijn> max3: Internal detail
07:50:27 <max3> so the bound name is the name in the global namespace through which i acess this variable? i know i'm just reiterating but i'm just making sure
07:51:55 <merijn> No, the name isn't what you use, you just do "myVar = declareIORefSource "foo" 1" and then use myVar to access it
07:52:38 <max3> yes that's what i meant
07:52:43 <max3> myVar
07:52:47 <max3> is in the global name space
07:52:55 <max3> through readIORef?
07:54:08 <lyxia> "foo" is in the global name space, and you bind the variable to myVar to use in regular Haskell code.
07:55:12 <merijn> lyxia: Well, myVar is global too if you just export it or whatever
07:56:30 <lyxia> oh right
07:57:00 <max3> how do i bind "foo" to another variable after it's been declared?
07:57:14 <Rembane> max3: let bar = foo in ...
07:59:46 <max3> http://pastebin.com/ftHB1mFQ
07:59:50 <max3> what am i doing wrong?
08:01:40 <Rembane> max3: Try let b = someVar1 instead.
08:01:42 <merijn> max3: You should use "someVar1"
08:02:04 <max3> Rembane let b = someVar1 will work
08:02:10 <max3> merijn, don't understand
08:02:23 <max3> the question is how to access the global through the quoted identifier
08:03:29 <merijn> Why do you want that?
08:03:50 <max3> well 1 i'm just curious 2 i'm interested in accessing this global in other modules
08:04:00 <max3> merijn, as you said i could export
08:04:01 <merijn> max3: Then you just export someVar1?
08:04:26 <max3> yes i was wondering if there were another way
08:08:01 <nate__> Is there anyone here who understands Core well?
08:08:32 <merijn> ish? :p
08:08:56 <Rembane> nate__: Ask and we'll see if anyone answers. :)
08:09:55 <nate__> I've been trying to read through the -ds and -spec output, and see a lot of symbols like $dApplicative and $fAlternativeRedexT_$c<|>
08:10:16 <nate__> What is the meaning of the dollar sign in these symbols?
08:11:01 <nate__> Other symbols like void# --- what does the pound sign mean?
08:11:19 <erisco> that is magic hash which is a special GHC feature that does unboxing of values
08:11:22 <merijn> # is usually unboxed types
08:12:09 <nate__> In some places, I see lines like (\ @ b -> ...)
08:12:38 <erisco> > (\@b -> 3) 5
08:12:40 <kgadek> nate__: http://stackoverflow.com/a/1153485/547223
08:12:42 <lambdabot>  <hint>:1:6: error: parse error on input ‘->’
08:12:44 <nate__> I looked in the pretty printer code, and it said the @ symbol meant lambda-bound variables, but it wasn't clear to me why that was a distinction.
08:12:54 <erisco> I don't think it is valid syntax
08:13:28 <erisco> x@y is valid and binds y to x
08:13:39 <erisco> so, a common use is xxs@(x:xs)
08:13:50 <erisco> that way you get the head, the tail, plus the cons of the two
08:14:04 <nate__> It doesn't appear that that's the meaning of '@' in this context.
08:14:14 <tabaqui1> I've read somewhere that quotRem is much faster than divMod
08:14:31 <tabaqui1> or maybe vice versa
08:14:34 <tabaqui1> dunno
08:14:35 <tabaqui1> is it true?
08:14:43 <erisco> well, if you could show where that exists I'd like to know
08:14:46 <kgadek> nate__: hmm was this in the core/STG output?
08:14:59 <kgadek> I don't recall the syntax for lambdas in STG
08:15:21 <erisco> there is \ ~b ->  and \ !b ->  so maybe you were thinking of one of those
08:15:29 <nate__> kgadek: yes.  See line 352 here https://ghc.haskell.org/trac/ghc/browser/ghc/compiler/coreSyn/PprCore.hs
08:15:30 <Zemyla> tabaqui1: quotRem is an Integer primitive, and divMod is defined by fiddling with the signs of those numbers, so it may be faster for Integers.
08:16:10 * kgadek is quickly looking at the old STG paper
08:16:23 <tabaqui1> Zemyla: so quotRem is faster, right?
08:16:24 <erisco> > (\ @ b -> 3) 5
08:16:27 <lambdabot>  <hint>:1:4: error: parse error on input ‘@’
08:16:39 <kgadek> no, there is `stuff \u stuff` but no at sign
08:16:53 <erisco> the spacing matters actually, but still this isn't valid syntax without some extension (which I have not heard of)
08:17:14 <nate__> Not sure.  I'm pulling this directly from a .dump-spec file
08:17:16 <kgadek> erisco: it appears that we're talking about Core, not actually Haskell
08:17:28 <erisco> oh, heh, well have fun :P
08:17:57 <ph88> i was looking at this tutorial https://generics-eot.readthedocs.io/en/latest/tutorial.html#th-example-meta-information-with-types-generating-sql-schemas and wondering if this does allow me to find a field of a certain type in a data structure, can i test for a specific type and then change the value? does someone know?
08:18:34 <nate__> A complete example: $s=<< = \ @ a @ b f x -> >>= $fMonadMaybe x f
08:18:39 <kgadek> nate__: I have a blurry memory so I may be wrong, but… this may be true. So this `@stuff` would be a dictionary containing instance methods
08:19:49 <Zemyla> tabaqui1: Probably. Try benchmarking it to be sure, though.
08:20:00 <kgadek> that's how you deal with ad-hoc polymorphism anyway: passing a dictionary that contains actual methods
08:20:16 <kgadek> the same is with C++, but it's called vptr there
08:20:20 <kgadek> (or sth like that)
08:20:21 <lyxia> ph88: you can by adding a typeable constraint to the field
08:21:20 <nate__> You're thinking of the virtual function table
08:21:37 <ph88> lyxia, yeah ok i thought i first try without Data and Typeable
08:21:40 <nate__> Rather, the pointer thereto.
08:22:48 <lyxia> ph88: You could also use some overlapping instances
08:23:17 <nate__> kgadek: The weird thing is that the names preceded by the '@' seem to never be used.
08:23:27 <ph88> lyxia, how do you figure overlapping instances help ?
08:23:57 <lyxia> ph88: because you can write one instance for all types, and one instance for all types that match
08:24:02 <kgadek> nate__: hmm. Do you have optimization passes turned on?
08:24:28 <nate__> Other than dumping the output, I have no special flags.
08:24:43 <lyxia> ph88: and then the first instance will never be used for types that match, so you can assume that they don't.
08:25:26 <ph88> lyxia, if you look at the EotCreateTableStatement function .. i think it's possible to get the type with    show (typeRep (Proxy :: Proxy x))    only that i don't need to show it i just need to compare it with a specific type to see if it's the one i need
08:25:51 <ph88> lyxia, the first as being the first in the source file ?
08:26:06 <lyxia> ph88: I thought you didn't want to use typeable
08:26:53 <lyxia> ph88: and I just showed how you can do it without it
08:26:57 <kgadek> nate__: so that's probably this. Or that's my guess
08:27:00 <ph88> lyxia, damn you got me, i didn't look carefully .. i thought GHC.Generics was providing this -___-  .. 
08:27:22 <ph88> isn't it possible to extract the type from the metadata ?
08:27:33 <nate__> kgadek: any idea about the dollar sign in $dMonad or $fMonadMaybe?
08:28:20 <nate__> It seems to exclusively appear by names of type classes
08:28:27 <ph88> lyxia, yes i will seriously consider that option if it can't be done with pure GHC.Generics
08:28:31 <kgadek> nate__: I have no in-depth practical knowledge on Core/STG. Sorry, can't help
08:29:07 <nate__> Ah, okay.  Well, thank you anyhow.
08:29:50 <kgadek> nate__: if you mind my guessing, then probably this fMonadMaybe is the dictionary for `Maybe`
08:30:14 <kgadek> but that's a wild shot
08:31:05 <benneh> With 'Writer w', the function 'tell' uses 'mappend :: w -> w -> w'. With 'WriterT w m', is there a monadic version of this which uses a function 'w -> w -> m w'?
08:31:08 <nate__> Yeah, I'm starting to lean in about that direction.  I wish I could find it documented though.
08:31:35 <lyxia> ph88: AFAIK the metadata only contains information about the type constructor and the constructors
08:31:41 <codedmart> If I have my own monad stack is it possible to forkIO within the stack?
08:32:07 <nitrix> codedmart: As long as your stack type has an instance of MonadIO, yes.
08:32:14 <nitrix> codedmart: You'll be able to liftIO . forkIO
08:32:33 <ph88> lyxia, aaaah ok then the way i had imagined is impossible. I will either have to use overlapping instances or use typeable
08:32:45 <nitrix> codedmart: Note that monad transformers over the IO monad automagically have a MonadIO instance.
08:32:46 <codedmart> nitrix: Hmm... It does and I thought I tried that. Let me try again.
08:33:21 <nitrix> (At least if you're using the existings transformers, not creating a new one)
08:36:05 <lyxia> benneh: it doesn't seem to easily obey the monad laws
08:36:25 <ph88> lyxia, this makes me think i'm better of going back to uniplate rather than whipping something up myself
08:37:04 <lyxia> ph88: why
08:37:22 <ph88> cuz i don't really know what i'm doing and i have experience with uniplate from last time
08:37:59 <lyxia> :/ Uniplate doesn't seem so good to me.
08:38:05 <ph88> oh :/
08:38:10 <ph88> can type by compared with Typeable ? if i have a function like   a -> b -> Bool
08:38:16 <SudhanshuJ> How do I go about making a 2 player tic tac toe game in haskell ? I want to display the 3*3 grid as cordinates which each player would enter to make his move.
08:38:17 <ph88> by -> be
08:38:46 <lyxia> ph88: (Typeable a, Typeable b) => proxy a -> proxy b -> Bool
08:38:53 <ph88> SudhanshuJ, start with making some types to represent your data, then show us your code
08:39:09 <lyxia> ph88: comparing types is what Typeable is about
08:39:15 <ph88> lyxia, not to nitpick but don't you mean Proxy with capital P ?
08:39:25 <codedmart> nitrix: But the func that I call with forkIO needs to be IO correct?
08:39:37 <ph88> (Typeable a, Typeable b) => Proxy a -> Proxy b -> Bool
08:39:46 <nitrix> codedmart: Yeah.
08:39:49 <nitrix> :t forkIO
08:39:51 <lyxia> ph88: nope. They are actually isomorphic.
08:39:51 <lambdabot> error: Variable not in scope: forkIO
08:40:03 <erisco> probably not, seeing as the Proxy term is irrelevant ph88
08:40:03 <nitrix> codedmart: forkIO :: IO () -> IO ThreadId
08:40:05 <lyxia> ph88: but using a type variable makes it more polymorphic
08:40:07 <codedmart> That is what I am getting at though. Is can I forkIO but stay in my monad stack?
08:40:09 <erisco> it just exists to pass type arguments
08:40:23 <erisco> so it can literally be any f a
08:40:29 <nitrix> codedmart: (Also it's not higher-order, you're not giving a function to forkIO :P)
08:41:02 <glguy> codedmart: You certainly can't do that in general, but perhaps your particular monad stack is such that you could construct that operation
08:41:37 <lyxia> ph88: http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Typeable.html#v:eqT is a better equality function because it returns a witness.
08:41:44 <ph88> lyxia, ok in this case i would like to attempt using GHC.Generics and Typeable and if that doesn't work go for an alternative solution. What i would like to do is find the last T in a structure like  Foo (Wrap T) (Bar (Wrap T)) (Wrap (Qux T))  and then change the value of it
08:42:07 <ph88> i don't know what a witness is in this context
08:42:13 <kgadek> nate__: https://gist.github.com/kgadek/1fcc4677f908693fa9401afd58b235c3
08:42:16 <codedmart> glguy: Hmm... This is what I have `ReaderT AppConfig (ExceptT ServantErr (LogM IO)) a`
08:43:15 <ph88> lyxia, hmm that function returns some extra information (i guess the actual witness? of type  a :~: b  ??)
08:43:19 <lyxia> ph88: By pattern matching on the witness, you allow the typechecker to unify the types that compare equal.
08:43:23 <glguy> codedmart: OK, so you'll need to write a function from that type to IO a
08:43:54 <glguy> and in that function you can decide how to handle if it results in an exception and what to do with the logging in the other thread
08:44:18 <ph88> lyxia, i can't really imagine this kind of pattern matching just yet, is that still using proxies ?
08:45:47 <lyxia> no
08:46:08 <codedmart> glguy: And then I just use that before forkIO ?
08:46:10 <erisco> Refl :: a :~: a   and so say you are given some x :: a :~: b
08:46:21 <codedmart> Still trying to grasp.
08:46:43 <erisco> what happens in  case x of Refl -> m  ? well in m we have x :: a :~: b and x :: a :~: a (because x is Refl)
08:46:56 <erisco> so how does that unify? well, it must be that b = a
08:47:07 <glguy> codedmart: I'm not sure which part you're unsure about.
08:47:31 <nitrix> codedmart: Pasting what you have on lpaste.net might help from this point.
08:48:13 <codedmart> glguy: If I write a function from App a -> IO a. Just not sure how to use it. I guess I will write that function and try.
08:48:32 <merijn> ph88: witness just is a fancy way of saying 'a proof' (it is "a witness" to the fact that some predicate is true")
08:48:49 <glguy> codedmart: It'd be a normal function. You'd apply it as in applying f to x: 'f x'
08:49:24 <codedmart> I know that I meant in the context of forkIO, but let me just give it a go first. Then circle back.
08:49:25 <codedmart> Thanks
08:55:27 <ph88> lyxia, still don't know what you mean with pattern match in context of eqT :\
08:57:53 <ph88> https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Typeable.html#t::-126-:
08:57:57 <ph88> Propositional equality. If a :~: b is inhabited by some terminating value, then the type a is the same as the type b. To use this equality in practice, pattern-match on the a :~: b to get out the Refl constructor; in the body of the pattern-match, the compiler knows that a ~ b.
08:58:11 <ph88> no idea what this is talking about
08:58:15 <codedmart> glguy: So if I usually have `IO (Either ServantErr a)` when I unstack. To get to `IO a` what is the common thing to do with the Left branch? `error`? 
08:58:40 <glguy> codedmart: That's up to you. There's no default answer. Why are you forking? What do you want to do if the think you forked failed?
08:59:00 <ph88> is there a search engine for haskell example code maybe ?
08:59:23 <codedmart> Just log it, but that should happen in LogM if I am thinking correctly. I am forking to run something in the background.
09:00:08 <codedmart> glguy: As long as I am thinking correct and LogM will log any error I would just like to ignore the Left.
09:01:32 <lpaste_> lyxia pasted “ph88 how do you write this without pattern matching on r.” at http://lpaste.net/352818
09:02:39 <ph88> oooh you pass the type variables down to the lower function
09:02:45 <ph88> so instead of b i could a concrete type there
09:03:19 <ph88> thanks lyxia !
09:03:34 <ph88> i was just used to pattern match on values
09:04:50 <lyxia> well Refl is a value
09:05:11 <ph88> yeah i just thought the pattenr matching was about the  (a :~: b)  part !!
09:05:30 <ph88> " pattern-match on the a :~: b "
09:05:38 <ph88> it says in the text
09:06:42 <codedmart> glguy: If I use `error` in the Left will that cause problems for the main thread of my app or just that thread? Not sure what else to use?
09:11:19 <pikajude> does anyone in here use docker for local development in conjunction with GHC
09:13:14 <ph88> i'm relieved to know that it's possible to compare types in haskell pfew
09:15:42 <gracjan> hi, a question
09:15:54 <gracjan> I do not understand spacing requirements for -XTypeApplication
09:16:08 <gracjan> why is `read@ Int “4”` problematic?
09:16:10 <pikajude> iirc it's @Type or @(Longer Type)
09:16:16 <pikajude> otherwise the parser gets confused
09:16:24 <pikajude> yeah you can't have a space there
09:16:29 <gracjan> why?
09:16:39 <pikajude> because that's the rule
09:16:45 <pikajude> i don't know
09:16:48 <gracjan> Prelude> let x @ Nothing = Just "abc" in print x
09:16:49 <gracjan> *** Exception: <interactive>:4:5-28: Irrefutable pattern failed for pattern x@Nothing
09:16:59 <gracjan> I can have spaces in patterns
09:17:06 <pikajude> a type application isn't a pattern
09:17:18 <pikajude> they're entirely separate. the only similarity is the use of @
09:17:36 <Tuplanolla> What problem does disallowing spaces solve?
09:17:36 <gracjan> type application is always in expression context, isn’t it?
09:18:36 <gracjan> What problem does requiring spaces solve/
09:18:37 <gracjan> ?
09:19:11 <gracjan> it does not locally distinguish from patterns, as patters can have as many spaces as they want
09:19:28 <gracjan> so, what is the point?
09:22:32 <glguy> gracjan: https://github.com/ghc/ghc/blob/master/compiler/parser/Lexer.x#L533-L558
09:23:58 <gracjan> Example for this: “because we want to allow type patterns within expression patterns”?
09:25:15 <glguy> Maybe it should say "we want to be able to", because I don't think that it does that at this point
09:26:56 <codedmart> nitrix glguy Thanks for your help.
09:31:21 <gracjan> Prelude> let xx x @ Nothing = print x in xx Nothing
09:31:21 <gracjan> Nothing
09:44:21 <Sonolin> j
09:47:50 <magicman> Is there an existing library for scheduling and descheduling IO actions at a specific time?
09:49:11 <magicman> hcron sounded promising, but I can only see a way to create a schedule, but not actually run it.
09:52:41 <phadej> magicman: i'm not aware of anything wrapped in standalone lib, if you find one please tell me too
09:54:25 <phadej> magicman: there is https://github.com/haskell/hackage-server/blob/master/Distribution/Server/Framework/Cron.hs inside hackage-server
09:54:44 * magicman looks.
09:55:09 <k_p__> Hey everyone. I am trying to learn Haskell. I have a lot fo experience with FP (Scala, Clojure, Elixir) what is the best way for me to learn. I've found this https://github.com/bitemyapp/learnhaskell and have also looked at Real World Haskell && Learn you a haskell. 
09:55:37 <magicman> I mean, I could hack up something myself with a PQueue, threadDelay, forkIO, and more MVars than is good for a person, but I feel that it'd either be clunky, or fall apart at the earliest thrown exception.
09:55:55 <Tuplanolla> Learn You a Haskell might be a good tour for you, k_p__.
09:56:15 <Tuplanolla> You can probably read it in an afternoon or two.
09:57:00 <k_p__> Tuplanolla: Thanks! However I always tend to read the books and never really commit to writing code. That kind of why I like the CIS194 course. But there really isn't a way to verify that I am writing decent code. 
09:57:21 <phadej> magicman: well, you can start with the Cron.hs from hackage-server than, it's done that hacking for you :)
09:57:56 <Tuplanolla> You can post your creations here for review, k_p__.
09:58:25 <magicman> phadej: Yeah, it looks like a usable basis. Not too many heavy imports, that's always good. Thanks!
09:58:26 <kadoban> k_p__: I like http://haskellbook.com/ a lot. Or if you don't do that, the cis194 thing is fine. I'd recommend against trying to learn just from LYAH by itself.
10:00:02 <Tuplanolla> I think those are needlessly basic and exercise-heavy for someone with "a lot of experience", kadoban.
10:00:42 <Wizek> Hey! I think these two datatypes are cool! `Printed` and `CShow`: https://gist.github.com/Wizek/d5807fdd3b2f67622dd9b5a0b6187b40 Anyone agrees/disagrees?
10:01:23 <kadoban> I don't, unless their "lot of experience" is actually in haskell, which wasn't in the list, they'll still have lots to learn. And exercises will help keep it moving smoothly along.
10:02:31 <srhb> k_p__: Don't worry about decent, that will be much easier to figure out with the basics solidly out of the way :)
10:04:26 * hexagoxel adds another 15minutes wasted because some maintainer was too cool for upper bounds
10:04:44 <k_p__> too cool for upper bounds?
10:05:10 <k_p__> on like the version?
10:05:38 <hexagoxel> i mean (s)he published a package with no appropriate upper bounds on one or more of its dependencies.
10:06:09 <k_p__> ah thats what I thought it meant. Maybe they just always wanted the latest version for soem reason though. 
10:07:02 <hexagoxel> because they like non-compiling packages i'd guess.
10:07:07 <k_p__> At work we done things like [1.2) which sets a lower bound but not an uppper bound (in Scala)
10:12:01 <k_p__> so I haven't really looked much into how Haskell does its package system. Is it more like a Node.js system, Java with jars, or c with lib(.a) files?
10:12:46 <phadej> k_p__: it's more of Clojure jars with the source code
10:12:54 <nil_> Tuplanolla: how do you read LYAH "in an afternoon"?
10:12:59 <phadej> but not Node.js (at it allows multiple versions of same package)
10:13:24 <Tuplanolla> By knowing most of the concepts already, nil_?
10:13:31 <srhb> k_p__: I don't think there's any binary distribution except via system package managers or Nix.
10:14:09 <Tuplanolla> It's just syntax and type system specifics that are different wrt other fp languages.
10:14:12 <nil_> Tuplanolla: oh, that certainly helps. Still, it's not /that/ short. Or maybe I'm just a slow reader.
10:14:38 <k_p__> Interesting, and the libaries are kept locally in the same folder as the project or are they kept in a central location somewhere?
10:14:48 <srhb> k_p__: Depends what solution you use.
10:15:07 <k_p__> srhb: Lets assume stack, since thats what I heard people use?
10:15:15 <srhb> k_p__: Both cabal and stack support project local sandboxes with sharing.
10:15:31 <srhb> cabal-install, I should say
10:15:54 <k_p__> Interesting, so kinda like python's virtualenv but not as annoying to use I hope.
10:16:18 <srhb> A lot of people seem to like it. :)
10:16:23 <srhb> Stack is especially popular these days.
10:16:52 <tfc[m]> stack is great
10:16:55 <k_p__> Typical language package managers building on top of another right? 
10:17:21 <srhb> k_p__: I think the rivalry between cabal-install and stack has been both a boon and a curse. I use neither, so who am I to say...
10:17:34 <srhb> (Well, I do use cabal-install, but not that functionality)
10:18:14 <phadej> k_p__: the package manager has a bit of wrong sound in it, they are build tools
10:18:24 <phadej> which happen to know how to download dependencies
10:18:30 <phadej> but you cannot really "manage" anything
10:18:31 <maerwald> they are both package managers
10:18:37 <maerwald> poor ones though
10:19:11 <k_p__> SBT in the Scala world is a build tool too but still does package managment. Even though its so slow. 
10:19:55 <phadej> well, I guess it's up to definiton
10:20:06 <phadej> dpkg is a package manager, sbt is a build tool
10:20:26 <maerwald> sbt is a package manager, it installs packages and doesn't just build your project
10:20:32 <maerwald> make is a build tool
10:20:52 <k_p__> I agree with maerwald's sentiment.
10:21:23 <phadej> maerwald: well, sbt downloads the artifacts, thru maven, but maven calls itself "build manager" :)
10:21:40 * srhb thinks it's a spectrum, and filled with opinion at that
10:21:44 <k_p__> Sounds like a bunch of semantics
10:23:30 <phadej> well, stack doesn't have stack uninstall or stack list (of what installed)
10:23:32 <phadej> etc.
10:23:39 <phadej> e.g. if I say stack install happy
10:23:53 <maerwald> that's why they are both poor package managers
10:24:10 <phadej> ... and I rather not call them such to begin with :)
10:25:04 <phadej> to me they are build tools (which do a bit more too)
10:26:16 <maerwald> then you have no word for build tools that cannot install packages
10:27:31 <phadej> even make can if you write proper build-targets ;)
10:27:53 <maerwald> no, make has no knowledge of packages
10:28:32 <maerwald> make is also a language, yes
10:28:40 <maerwald> but you won't call C a build tool, would you?
10:30:20 <phadej> maerwald: if the "package managment" is up to download source zips from the internet, it's not even a lot of coding in the Make-world
10:30:58 <maerwald> then you've created a make-based package manager
10:31:02 <maerwald> I don't understand your confusion
10:31:10 <maerwald> FreeBSD basically did that
10:31:28 <maerwald> but make is still not a package manager
10:33:02 <phadej> well, I'd really want a word to separate system package maangers, like nix and apt from "smart build tools" like npm/sbt/stack/lein/...
10:33:18 <phadej> they are distinct groups to me
10:33:41 <maerwald> well, those are language-specific package managers: sbt, cargo, whatever ppl use in javascript, cabal etc
10:33:53 <Ternary> So I'm starting to mess around with lenses
10:33:57 <Ternary> One of the lenses I have is a list of objects that each have their own identifier. So I can do something like this: base ^.. someProperty . (key "someKey") . otherProperty
10:34:03 <Ternary> Is it possible for me to make my own custom getter to shorten that? So that I could effectively do something like: base ## "someKey" . otherProperty
10:34:15 <maerwald> "system" is a fuzzy term. Ghc is a system package, but stack can install ghc
10:35:13 <maerwald> ppl would probably say "distro package manager" or something like that. And even there, you can potentially mix them on one system 
10:35:17 <phadej> maerwald: for me they are still development tools, if I make a program for end-user than I'd package it in .deb or .rpm or whatever, and not make they install stack first
10:35:46 <maerwald> that's not based on functionality, but your use case
10:35:58 <bennofs> What's the word for ghc-pkg then? ghc package manager is probably wrong...
10:36:03 <hexagoxel> but you make them install apt/rpm first?
10:36:18 <phadej> hexagoxel: :)
10:36:20 <EvanR> is categorizing random programs into music-genre-like categories really "semantics"
10:36:23 <maerwald> bennofs: package managers in most distros actually consist of separate tools
10:36:59 <EvanR> fix ("semantics of " ++)
10:38:04 <maerwald> phadej: except that most (except for nix) distro package managers lack sandboxing functionality, which makes haskell packages extremely annoying, so I don't see much point in that
10:40:54 <phadej> there i'd say haskell /libraries/, I used xmonad from debian testing and was quite happy with it
10:41:07 <phadej> and completely different setup for the development work
10:41:12 <maerwald> that applies only to binary distros then
10:41:23 <phadej> (it's kind of nice they don't interfere)
10:41:36 <maerwald> on source distros you have to install (just like in cabal/stack) all libraries to get xmonad
10:41:45 <hexagoxel> bennofs: ghc-pkg is a cli around a package db, which is just a specific db, isn't it?
11:01:03 <mroman> http://codepad.org/oIUm5mMB <- I feel like passing 8 arguments asks for Monads of some sort .
11:02:30 <pikajude> well, you could use Reader
11:02:41 <byorgey> mroman: nested pattern-matching on Nothing/Just also calls for using the Maybe monad
11:03:06 <c_wraith> mroman, do you have to pass all of those? 
11:03:23 <mroman> Yes.
11:03:41 <c_wraith> mroman, a quick glance made it look like checkBinOp' could just close over most of its arguments  
11:04:16 <mroman> it passes on the other arguments to checkTypes
11:04:22 <byorgey> mroman: it looks to me like you want to create a custom monad which is something like   newtype TC a = TC (ReaderT stuff (ExceptT String) a)
11:04:38 <c_wraith> it can do that without receiving them as arguments. 
11:04:55 <mroman> c_wraith: hu?
11:05:05 <mroman> with a State Monad of some sort probably.
11:05:10 <mroman> or what else are you refering to?
11:05:41 <c_wraith> mroman, just define checkBinOp' in the let block. 
11:05:55 <c_wraith> mroman, then all those definitions are already in scope 
11:06:01 <mroman> oh. right.
11:06:18 <c_wraith> or alternatively, define everything else in the where block. 
11:07:20 <c_wraith> you still might want a monad, but you can simplify things first. :) 
11:08:11 <mroman> yeah.
11:08:31 <mroman> that'll also allow for more convenience function such as bindType and stuff like that.
11:08:40 <mroman> instead of doing inserts all day long.
11:09:19 <johnw> byorgey: did you mean: newtype TC m a = TC (ReaderT stuff (ExceptT String m) a)?
11:10:07 <mroman> I hope I used the term polymorphic type correctly :)
11:10:19 <mroman> I have no real CS background.
11:13:08 <mroman> and I should probably allow type classes to contain other type classes.
11:15:54 <mroman> and it would be nice to allow circular imports :)
11:16:50 <phadej> there is .hs-boot
11:17:01 <phadej> but I don't think it's agood idea
11:18:29 <phadej> at least I didn't needed them ever, and the average file has ~100 lines at work
11:18:35 <phadej> so you can break the cycles quite well in practive
11:18:39 <phadej> practice*
11:18:59 <mroman> most of the time you can just pull stuff out into a third module and break the cycle that way
11:19:04 <johnw> I've used .hs-boot from time to time
11:19:06 <johnw> can be very useful
11:19:12 <mroman> or combine the two modules into one.
11:19:43 <mroman> not that I'd really use haskell for anything productive.
11:20:00 <johnw> why not?
11:20:28 <mroman> few people know it.
11:20:47 <mroman> strength of a language is a.) libraries b.) amount of people who know it.
11:21:00 <jle`> that hasn't stopped me from using haskell for everything productive i do heh
11:21:08 <johnw> not really sure how languages become strong, by that logic...
11:21:32 <mroman> I personally think all languages without a proper typesystem are complete crap.
11:22:09 <mroman> but still many people use them.
11:22:21 <mroman> thus I have to use them.
11:22:40 <jle`> i'm feeling like i'm missing a step in logic here
11:22:43 <jle`> 1. many people use them
11:22:45 <jle`> 2. ????
11:22:48 <jle`> 3. i have to use them
11:22:56 <jle`> 4. profit (?)
11:23:09 <mroman> Very few people hire you to write Haskell code.
11:23:11 <sternmull> i try to understand Pipes.Concurrent. In the tutorial there is a function "user" which seems to be called repeatedly when it gets "potion" as input. What causes this repeated calls? (This is the tutorial: https://hackage.haskell.org/package/pipes-concurrency-2.0.7/docs/Pipes-Concurrent-Tutorial.html)
11:23:23 <mroman> Very many people hire you to write javascript, python.
11:23:43 <mroman> and java. luckily java has a typesystem.
11:24:47 <mroman> and it's not like type systems are hard to implement.
11:24:56 <srhb> sternmull: Do you mean the recursive call?
11:25:18 <srhb> sternmull: Oh, no, on potion...
11:25:20 <mbrock> I'd think a Haskell-like type system is pretty hard to implement
11:25:43 <johnw> mbrock: for Haskell 2010 without extensions, not so terrible
11:25:47 <sternmull> srhb: Yes. What calls "user" when the input is "potion"?
11:26:23 <srhb> sternmull: There are many examples here... Is it this one? user = P.stdinLn >-> P.takeWhile (/= "quit")
11:26:45 <mroman> sure but c-like type systems are easy.
11:27:07 <mbrock> johnw: true, but you'll probably face a steady demand (as Haskell has) for new features, straddling the fractal tradeoff between inference and dependent types, etc
11:27:15 <sternmull> srhb: I mean "game.hs" in the appendix.
11:27:28 <mroman> nobody wants dependent types in practice anyway :D
11:28:30 <srhb> sternmull: The handler loops on a Heal event.
11:29:16 <srhb> sternmull: Heal n -> loop (health + n)
11:30:06 <mroman> inference is nice but most of the time it's fine if you have to write top level decls and let the compiler infer from that.
11:30:19 <sternmull> srhb: Ok... but isnt user called in another thread? As i understand it the "user" thread should terminate as soon as it processed "potion".
11:30:21 <mbrock> basically I think it's unfair to say languages without type systems are crap, because the work that goes into making Haskell's type system both ergonomic and powerful is enormous, and lots of cool stuff has been done in e.g. Smalltalk, Erlang, bash, you name it, that probably wouldn't have happened if their designers tried to fit everything into a type
11:30:21 <mbrock> formalism
11:30:30 <mroman> i.e. writing int foo(int a, int b) { c = a * b; return c; } is inference enough for most.
11:32:02 <mroman> mbrock: I don't like them because a.) it's unsafe b.) documentation
11:32:18 <mroman> I like to know what functions return.
11:32:28 <mroman> which I can't in languages like python
11:32:51 <shapr> mbrock: Weren't you at EuroHaskell 2003?
11:32:54 <mroman> (I also hate unchecked exceptions)
11:32:56 <mbrock> shapr: :) yes!
11:32:59 <shapr> I thought so
11:33:14 <srhb> sternmull: So if user doesn't find quit or heal or harm, it loops (consuming the next line from the input) but otherwise it's just "mapped" over the input stream
11:33:19 * shapr hugs mbrock
11:33:30 * mbrock purrs
11:33:39 <mbrock> I saw John Hughes ride your unicycle!
11:33:48 <shapr> Yeah, many years ago
11:34:07 <srhb> sternmull: If there was never an invalid input, you could get rid of the recursive call in user and it would function the same
11:34:28 <srhb> sternmull: Does that make sense?
11:35:55 <sternmull> srhb: I still don't see it. When "user" sees "potion" it returns a "Heal 10" and i don't understand what calls it again. But according to the example output it is called until Quit is processed by the handler.
11:37:07 <sternmull> srhb: Does "lift user >~" somehow run it in a loop until the mailbox is sealed?
11:37:17 <mroman> mbrock: I just don't see a benefit of duck typed languages.
11:37:22 <mroman> except that you can hack around easier.
11:37:51 <fizbin> I wish there were an option for hp2ps to color the graph by a hash of the allocation point name, so that you could compare two graphs (of different versions of the program, or the behavior with different inputs) without mentally working out a color translation table.
11:38:13 <mroman> well... you can do more runtime hacking and runtime dependency things
11:38:15 <mroman> I give you that.
11:38:44 <mbrock> by some kind of meta-pragmatic philosophy I basically see their existence and popularity as proof that there are benefits. Identifying and formulating those benefits can be hard though
11:40:16 <mbrock> for example, David H. H. didn't make Rails in an ML-style language, and it might be interesting to think about why, if we concede that Rails has been quite a productive and useful thing
11:40:45 <mbrock> this might be too flamebaity or off-topic for #haskell though :)
11:40:54 <mroman> yep :)
11:41:21 <sternmull> srhb: Ah! Pipes documentation says "(draw >~ p) loops over p replacing each await with draw". So there it is. I probably should not assume that i could skip Pipes-tutorial and jump directly to Pipes.Concurrent without getting confused...
11:42:24 <shapr> sounds like a calm discussion so far
11:43:02 <shapr> I do wish I'd found Haskell earlier in my programming career.
11:43:42 <Akii> can I "embed" the failure type of one MonadError into a type of another MonadError?
11:43:57 <mroman> I found haskell at age 17 or something.
11:44:01 <Akii> (MonadError Text m1, MonadError (TextError err) m2) => m1 a -> m2 a
11:44:20 <browndawg> mbrock, rails is great for prototyping stuff, but then when you want some guarantees as to your code, you end up writing a huge test suite for it anyway
11:44:29 <browndawg> a lot of which is just compensating for the lack of static types
11:44:54 <bollu> mroman: same. mind was blown when I started learning. 
11:45:02 <Cale> plantedseed: hey
11:45:07 <browndawg> Something like ruby / rails is great for getting work done initially with less overhead, which is useful when you might not know if your prototype will survive the week
11:45:08 <bollu> I still remember fondly someone showing me "fmap fmap fmap" :)
11:45:08 <mroman> I noticed that as soon as you handle user input you need to check the type.
11:45:34 <mroman> def f(a): return a*3 is already unsafe.
11:45:52 <Cale> plantedseed: I'm working at Obsidian Systems now, developing web applications for various clients entirely in Haskell. :)
11:46:03 <mroman> weird things can happen when you get types you didn't expect.
11:46:42 <srhb> sternmull: Oh, you found that faster than me, good. :-)
11:46:43 <fresheyeball> Cale: Nice!
11:47:49 <mroman> bollu: one has to accept to never fully understand Haskell though.
11:47:53 <mroman> At least I have to accept that.
11:48:03 <mroman> With my poor CS knowledge no chance :)
11:48:48 <mroman> that might actually be one reason why people wouldn't use it.
11:50:15 <dmwit> "fully understand Haskell" sounds like a no-true-Scotsman kind of thing
11:50:21 <shapr> mroman: lack of CS knowledge?
11:50:34 <mroman> yes.
11:50:52 <mroman> Some haskell extensions arguably can not be understood without a lot of theoretical CS background.
11:50:58 <shapr> dmwit: yeah, I learn new things about Haskell all the time. A friend just showed me TransformListComp and dramatically simplified my subway API code.
11:51:11 <shapr> mroman: I'm not convinced, got any specifics?
11:51:23 <sternmull> i think most people that use C++ only understand at most 80% or so of the language. I use it for over a decade every day and know that there are dark corners. I am new to haskell but it seems in haskell i have a much better chance to know every corner of the language.
11:51:32 <mroman> generic newtype deriving?
11:51:47 <mroman> functional dependencies
11:51:53 <dmwit> s/generic/generalized/ ?
11:52:09 <shapr> I thought fundeps were just extra switching on the type?
11:52:54 <shapr> mroman: I dunno, I wrote useful Haskell code before I ever had college courses about math or CS
11:53:14 <mroman> well yeah
11:53:22 <mroman> I can just wip everything up in IO if I want to.
11:53:39 <mroman> but there's still a lot of code and extensions I don't understand.
11:53:45 <dmwit> GND seems especially easy to understand without CS training. It just uses the same method implementations as the type the newtype wraps.
11:53:47 <johnw> fundeps just help unification; given Foo a b | a -> b, if you can infer Foo a c then for any Foo a d, c ~ d
11:54:29 <johnw> I think you're making Haskell seem more magical than it is
11:54:52 <mroman> do I look like I know what unification is :D?
11:55:00 <shapr> mroman: means makin stuff match
11:55:21 <johnw> if you means, knowing a implies knowing b. full stop.
11:56:10 <dmwit> I am sympathetic to mroman.
11:56:29 <dmwit> Advanced technology appears magical until you peer behind the curtain, and sometimes the curtain is thick and heavy and hard to move.
11:56:44 <max3> what is a CAF error?
11:56:55 <johnw> appearing magical, OK; being magical and thus "no one will ever understand it", not OK
11:57:15 <mroman> "fully"
11:57:19 <dmwit> max3: Perhaps you should post the exact text of the error. Probably the minimal code to cause it, too.
11:57:33 <max3> minimal code would be impossible
11:57:39 <dmwit> no
11:57:55 <max3> no?
11:57:58 <dmwit> illegal, maybe; impossible seems very unlikely to me
11:58:04 <max3> trust me impossible
11:58:10 <dmwit> I do not trust you.
11:58:51 <max3> it's 4 calls deep
11:58:55 <max3> i don't know what you want from me
11:59:06 <max3> especially given i'm just wondering what the identifier means
11:59:28 <dmwit> I want the minimal code that reproduces the error you're seeing, and the text of the error it causes.
11:59:35 <mroman> It's one thing to call "get" and "set" and one thing to understand how "MonadState" works and again another thing unterstand how "Monads" work and what you can do with them.
11:59:56 <max3> you're being unreasonable. i'm not asking for debug help - just a glossing 
12:00:22 <dmwit> You're being unreasonable. You're asking for further information, but being completely opaque about what the topic is.
12:00:25 <mauke> how can you ask for help with an error without telling us what the error message is?
12:00:28 <shapr> mroman: I want to hear a list of magic things, because I'm sure I have much to learn.
12:00:49 <mroman> kind, rank types, type families
12:00:52 <max3> http://pastebin.com/Xci3zXP6
12:00:57 <mroman> those are all more or less still magical to me
12:00:58 <shapr> mroman: I enjoyed the magic of TransformListComp: https://github.com/shapr/tmuxmarta/blob/master/src/Lib.hs
12:01:16 <shapr> mroman: I think kind is just the type of the type
12:01:25 <mroman> shapr: yeh
12:01:56 <mauke> sounds like someone's evaluated undefined
12:02:44 <mroman> genericParseJSON 
12:02:47 <mroman> that sounds magical :D
12:03:08 <mroman> how does Generic work
12:03:14 <mroman> that's some other questions on my ToDo list
12:03:14 <shapr> mroman: it was! I put "deriving Generic" on the record, and made sure the names matched, and the magic worked!
12:03:16 <dmwit> max3: "CAF" is only tangentially related to the error you posted. The real error is the last line.
12:03:18 <mroman> my todolist is full of things.
12:03:58 <mroman> `then group by station using groupWith` <- what the hell is that?
12:04:15 <max3> is it possible to make the result of a function strict?
12:04:23 <dmwit> max3: The previous four lines are a callstack that will help you find that error. The comment about a CAF is talking about a technical detail about `Prelude.undefined` that doesn't really matter for the purposes of fixing the problem.
12:04:38 <mroman> LINQ for Haskell?
12:04:40 <shapr> mroman: that's the TransformListComp extension fun
12:04:43 <shapr> mroman: pretty much
12:04:50 <mbrock> it would be an interesting case study to try to make the Nix (as in NixOS) language into a typed language. As it is, it's fairly successful despite being dynamically typed
12:04:51 <shapr> That's what I thought when I saw it, LINQ for Haskell
12:05:04 <dmwit> max3: "strict" is a property of functions. Consequently the answer to that is "yes" subject to the condition that the result of your function is another function.
12:05:08 <shapr> Mind you, LINQ was done by Erik Meijer, so really LINQ is Haskell for C#
12:05:10 <mbrock> so I wonder what kind of effort by what kind of experts would be required to think of and implement a good type system for Nix
12:05:38 <mbrock> as far as I know the original developers of that language were highly skilled functional programmers from the university of Utrecht
12:05:48 <max3> then i guess i meant is there a way to make a function strict
12:05:49 <mroman> that's not production level code though.
12:06:04 <mroman> no error handling.
12:06:22 <dmwit> max3: http://stackoverflow.com/q/15627849/791604
12:06:38 <max3> thank you
12:07:22 <shapr> mroman: oh, my code? It runs in my byobu/tmux status bar.
12:08:06 <dmwit> max3: However, I am worried. Is this question related to your previous one? If so, I don't think "making things strict" is going to help with "I did something that resulted in `undefined`".
12:08:16 <dmwit> max3: Making things stricter can only make them more undefined, not less.
12:08:44 <max3> i'm trying to do something probably dumb
12:08:46 <max3> i'll admit it
12:08:55 <shapr> I do that often.
12:09:13 <max3> this is probably the reason for the exception
12:09:13 <max3> http://pastebin.com/L08rHV01
12:09:57 <max3> i have loadConfig in a do somewhere else
12:10:07 <max3> and then its result is evaluated further on
12:10:55 * dmwit smells an unsafe unsafePerformIO
12:11:05 <max3> yes
12:11:08 <max3> like i said
12:11:20 <mroman> databrary_configuration <- is that even used?
12:11:35 <max3> it's exported from the module
12:11:43 <dmwit> no
12:12:11 <mroman> and the fact that there's no '<-' smells indeed like unsafePerformIO
12:12:13 <dmwit> databraray_configuration, not databraryConfiguration
12:12:37 <max3> i was in here earlier asking how to access databrary_configuration 
12:12:48 <max3> but i forget who said just export databraryConfiguration
12:13:20 <dmwit> I believe you are using unsafe* without understanding unsafe*.
12:13:31 <dmwit> I suggest considering how to achieve your goals without using unsafe*.
12:13:39 <merijn> @quote not.a.bug
12:13:40 <lambdabot> SPJ says: [This is] clearly not a bug in GHC; but it would be more felicitous if it gave you a warning...
12:13:45 <merijn> eh...wrong quote
12:14:12 <merijn> @quote Lemmih not.a.bug
12:14:13 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
12:14:16 <merijn> ^ that one
12:15:11 <dmwit> "Understanding unsafe*" is also a potential solution. But I suspect once you do that you will wish to avoid using unsafe*, so the first solution is a shortcut.
12:15:23 <max3> i would prefer the latter
12:15:24 <bitemyapp> @karma+ dmwit
12:15:25 <lambdabot> dmwit's karma raised to 67.
12:16:16 <max3> i would prefer the latter
12:17:52 <max3> before i do a deep-dive on unsafe*
12:17:59 <max3> can someone tell me how to access the global variable?
12:18:06 <max3> databrary_configuration
12:18:06 <max3> ?
12:18:21 <mroman> max3: http://codepad.org/A0LZVEav
12:19:08 <dmwit> max3: Yes, it is easy. Build the `IORef` once, in `IO`, at the beginning of `main`. Then pass the `IORef` everywhere it's needed.
12:19:21 <dmwit> This does not require unsafe*.
12:19:43 <mroman> vs. http://codepad.org/07PSMaJ4
12:19:59 <max3> dmwit, yes but there's no difference between that and passing what i've already been passing around (a config object)
12:20:09 <max3> i'm trying to avoid that in particular
12:20:13 <dmwit> mroman: Now predict: what does `case q of () -> case q of () -> return 1` do? Does it do that every time?
12:20:28 <Cale> max3: Sure -- if you're already passing a config object, you might want to put the IORef inside it
12:20:32 <dmwit> max3: Sorry, if your functions depend on a configuration, you can't avoid that.
12:20:37 <mroman> only a true haskell guru knows that.
12:20:42 <mroman> Which I am not :D
12:21:05 <max3> dmwit, are you saying that global-variables doesn't work?
12:21:18 <Cale> max3: I'd say just relax and pass the config around -- I've never actually regretted doing that.
12:21:24 <dmwit> max3: I am saying you should program as if global variables don't work.
12:21:54 <dmwit> It is easy to do and easy to get right.
12:22:02 <dmwit> The alternatives are easy to get wrong.
12:22:06 <dmwit> That seems like an easy choice to make to me.
12:22:20 <max3> that's fine. i'm a consenting adult
12:22:24 <max3> how do i do it?
12:22:54 <mroman> unsafePerformIO is not type safe.
12:22:55 <mroman> what.
12:22:58 <mroman> that's also magical :(
12:24:34 <dmwit> max3: You should begin by reading the documentation for `unsafePerformIO`.
12:25:20 <mroman> also demand analysis sounds magical too.
12:25:30 <mroman> just too much magical stuff in Haskell.
12:26:07 <lassulus> a
12:28:26 <mroman> isTrue# (x# <# 0#) && isTrue# (y# ># 0#) <- and wtf is that.
12:28:30 <mroman> magical. all magical.
12:29:21 <Cale> mroman: What was the thing that's magical?
12:29:46 <Cale> That's a bunch of unboxed operations, which by convention have their names end in #
12:34:18 <mroman> Cale: I'm just listing magical things. I'm not expecting answers to those.
12:34:23 <Cale> ah
12:35:20 <Cale> One reason unsafePerformIO breaks type safety is that newIORef :: IO (IORef a) is polymorphic, so if you unsafePerformIO it, you can let-bind something whose type is IORef a, which you can then proceed to read and write at different types
12:36:24 <Cale> This polymorphism isn't a problem without unsafePerformIO because you can't otherwise use the result polymorphically (it'll be bound via a lambda rather than let)
12:37:41 <mroman> but why can I even write to an IORef a?
12:37:58 <Cale> because you get to pick a
12:38:01 <Cale> every time
12:38:15 <clmg> Who here likes Haskell?
12:38:18 <clmg> I think it's great.
12:38:28 <Cale> I rather like it :)
12:38:37 <mroman> Isn't a an unbound type
12:38:55 <clmg> Haskell is more fun to write than other languages.
12:39:03 <Cale> you get something of type  forall a. IORef a
12:39:28 <Cale> so you get to pick whatever a you like, at each usage site
12:39:58 <clmg> I'm writing a text editor. I wrote everything in Rust and then decided to translate it to Haskell. Joy.
12:39:58 <mroman> That ok.
12:40:08 <mroman> that's like existential types
12:40:10 <mroman> but
12:40:18 <Cale> No, universal types :)
12:40:20 <mroman> if it's a
12:40:29 <Cale> The usual sort of polymorphism you get without extensions
12:40:31 <mroman> I mean
12:40:36 <nil_> <sternmull> "i think most people that use C++ only understand at most 80% or so of the language"
12:40:38 <mroman> you cant' have a forall (Show s). s
12:40:43 <mroman> and then cast that to :: [Char]
12:40:46 <nil_> Make that 30%, tops.
12:40:59 <Tuplanolla> Lens talk: I can overwrite values with `set (at i)`, but what if I only want to insert missing values?
12:41:04 <mroman> you can use show on it
12:41:42 <Cale> mroman: If you had a value of type forall s. Show s => s, then you'd be able to use it as a [Char]
12:42:00 <Cale> mroman: However, getting one of those which isn't simply undefined is going to be hard
12:42:20 <Cale> :t read "[1,2,3]"
12:42:22 <lambdabot> Read a => a
12:42:23 <zennist> [thumbsup]
12:42:30 <Cale> > read "[1,2,3]" :: [Integer]
12:42:33 <lambdabot>  [1,2,3]
12:42:36 <Cale> > read "[1,2,3]" :: [Double]
12:42:39 <lambdabot>  [1.0,2.0,3.0]
12:42:42 <Cale> > read "[1,2,3]" :: ()
12:42:45 <lambdabot>  *Exception: Prelude.read: no parse
12:42:56 <Cale> ^^ note, runtime exception rather than type error
12:43:14 <phadej> > readMaybe "[1,2,3]"
12:43:18 <lambdabot>  error:
12:43:18 <lambdabot>      Variable not in scope: readMaybe :: [Char] -> t
12:43:23 <phadej> > Text.Read.readMaybe "[1,2,3]"
12:43:27 <lambdabot>  error:
12:43:28 <lambdabot>      Not in scope: ‘Text.Read.readMaybe’
12:43:28 <lambdabot>      No module named ‘Text.Read’ is imported.
12:43:31 <phadej> :(
12:44:26 <clmg> Is fclabels objectively the best lens library?
12:44:45 <Cale> :t (\x -> let { r = System.IO.Unsafe.unsafePerformIO (Data.IORef.newIORef undefined) } in System.IO.Unsafe.unsafePerformIO $ do Data.IORef.writeIORef r x; Data.IORef.readIORef r)
12:44:48 <lambdabot> a1 -> a
12:45:44 <mroman> Cale: http://codepad.org/WfXlnXJt
12:46:19 <Cale> mroman: Sure...
12:46:35 <Cale> mroman: But you're trying to let the existential escape there.
12:46:53 <Cale> The unsafePerformIO stuff I did there with IORef didn't involve any existentials.
12:47:22 <Cale> also, wtf hugs?
12:47:25 <mroman> I also think undefined is magical.
12:47:36 <Tuplanolla> It's actually not, mroman.
12:47:37 <mroman> it inhabits every type
12:47:46 <mroman> which is weird.
12:47:50 <int-e> so does  let x = x in x
12:48:04 <mroman> yeh
12:48:09 <nitrix> mroman: undefined is a bottom value. You could create bottom yourself.
12:48:10 <mroman> I call that magical :D
12:48:29 <mroman> let x = x in x shouldn't even have an assignable type
12:48:38 <int-e> It's just lazy?
12:48:45 <Tuplanolla> Magical usually means something you couldn't define yourself, mroman.
12:48:45 <nitrix> mroman: The type system (and the whole design of Haskell) actually accomodates and takes into account bottoms in its specification, as well as proofs.
12:49:10 <mroman> Tuplanolla: Obviously magical here means "I don't understand it" ;)
12:49:23 <Tuplanolla> Well, then all bets are off.
12:50:16 <mroman> and in the type system I have in my head let x = x in x doesn't have an assignable type.
12:50:32 <mroman> that's like writing def foo(): return foo();
12:50:34 <nitrix> mroman: forall t. t
12:50:41 <Tuplanolla> I bet you'd enjoy Gallina (Coq), mroman.
12:50:53 <nitrix> mroman: For every type `t`, we're at value of type `t`.
12:50:56 <int-e> mroman: what about  template<class T> T f() { return f<T>(); }  in C++ ;-)
12:51:04 <nitrix> mroman: *that
12:51:22 <nitrix> mroman: It represents very nicely what the expression does.
12:51:27 <int-e> mroman: granted that doesn't inhabit every type, but it can be instantiated for any type.
12:51:29 <nitrix> mroman: Polymorphism for every `t`.
12:51:55 <int-e> (the lesson here is that strict languages have bottoms too)
12:52:18 <int-e> (as long as they don't ensure termination)
12:52:24 <mroman> I think there's already a nice quote which states my opinion of bottoms.
12:52:58 <mroman> I refuse to believe in them.
12:53:05 <kadoban> Is it a sir mixalot quote?
12:53:33 <mroman> I'm a hardcore finetist.
12:53:37 <mroman> or whatever that's called.
12:53:45 <mroman> *finitetist
12:54:55 <Tuplanolla> Finitist, no?
12:55:19 <mroman> That seems to be the correct spelling, yes.
12:55:31 <mroman> Goes without saying I refuse the halting problem.
12:56:05 <Tuplanolla> Too bad all the interesting things are at least countable.
12:56:07 <nitrix> It's a good attitude. Some people have designed languages that are guaranteed to halt.
12:56:13 <nitrix> It's very useful for theorem proving.
12:56:34 <mroman> Mainly because I haven't found a proof yet that doesn't rely on magic.
12:57:01 <Tuplanolla> Thus my remark about Coq, mroman.
12:57:07 <nitrix> You keep calling universal quantification "magic".
12:57:40 <nitrix> mroman: May I ask what confuses you with `forall t. t` ?
13:00:33 <mroman> Can I read that as "forall t. I return t"?
13:01:14 <mroman> Tuplanolla: well the problem with the "sketch proofs" is that they feed something to itself 
13:01:23 <mroman> which wouldn't properly type check.
13:01:54 <nitrix> mroman: First, there is no `->` so what you're working with isn't a function that'd take arguments.
13:02:21 <nitrix> mroman: It merely is a value. A polymorphic value at that. It's type is `t`, where we introduced `t` to be all types.
13:03:07 <mroman> That assumes the existence of values that are members of an infinite amount of types.
13:03:31 <nitrix> mroman: So it doesn't "return" really. It's an inhabitant of all types.
13:03:35 <mroman> I don't even believe in values being member of multiple types.
13:04:17 <mroman> if it doesn't return
13:04:21 <mroman> then what's it's value?
13:04:30 <mroman> *its
13:04:41 <nitrix> It doesn't _have_ a value. It _is_ a value.
13:05:12 <mroman> I see.
13:05:26 <mroman> so undefined :: forall t. t?
13:05:31 <nitrix> :t undefined
13:05:34 <lambdabot> a
13:05:44 <nitrix> Correct.
13:05:53 <mroman> is undefined == undefined?
13:06:06 <mroman> or undefined == 5?
13:06:07 <dolio> What is ==?
13:06:15 <mroman> comparison
13:06:34 <Tuplanolla> Choose your equality: https://ncatlab.org/nlab/show/equality
13:06:35 <nitrix> mroman: No, because not all types allows you to compare for equality.
13:06:44 <dolio> Then no.
13:06:52 <mroman> undefined == 5 aborts with an error.
13:06:59 <mroman> which I consider to be an incredibly bad design choice.
13:07:01 <nitrix> mroman: But I guaranteed you `id undefined = undefined`, that is, its identity can be preserved.
13:07:08 <mroman> it means that foo a b = a == b is UNSAFE
13:07:42 <nitrix> mroman: The decision behind making undefined terminate the program is by choice.
13:08:08 <dolio> undefined is an 'abort with an error'.
13:08:37 <nitrix> mroman: A different implementation of undefined could just make the program hang, trying to compute a value it cannot compute, and then, it'd be "safe" by any consideration.
13:09:04 <nitrix> mroman: What you're describing is merely the essence of _|_ (bottom). `undefined` is a design choice for convenience.
13:09:58 <dolio> Being able to detect undefined is actually the bad design.
13:10:15 <mroman> well... letting undefined hang forever would be worse
13:10:17 <dolio> Because that makes it the equivalent of null.
13:11:19 <mroman> I'd prefer null.
13:11:27 <nitrix> mroman: But as far as the limited examples you provided, undefined == undefined is a type error.
13:11:45 <mroman> :t undefined == undefined
13:11:48 <mroman> no it's not.
13:11:48 <lambdabot> Bool
13:12:00 <mroman> not to haskell at least.
13:12:43 <dolio> Not in GHC with extended default rules.
13:12:51 <dolio> It'd be a type error in Haskell.
13:13:07 <mroman> because can't deduce that t is Eq
13:13:12 <mroman> I presume?
13:13:39 <dolio> It can't decide which Eq instance to use.
13:13:40 <mroman> although if it inhabits any type wouldn't it inhabit every type class as well?
13:13:43 <kadoban> Because it has no way to know what instance of t you want, and has no defaulting rules to pick one for you.
13:13:56 <Tuplanolla> What's the lens way to perform `insertWith`? I'd like to only insert a value if it's not present.
13:14:13 <kadoban> s/instance of t/instance of Eq/
13:14:19 <mroman> but ok
13:14:52 <mroman> but why can't I create an IORef a and break the type system without unsafePerformIO?
13:15:44 <dolio> Because breaking the type system relies on let generalization.
13:16:16 <dolio> To use the same reference at multiple types.
13:18:21 <mroman> let generalizations.
13:18:24 <mroman> my todo list just grew :D
13:19:58 <mroman> int-e: T f() { return f(); } is fine btw.
13:20:17 <mroman> because it defines f to have a return type T
13:20:39 <mroman> but infering f() { return f(); } is something different.
13:20:40 <sternmull> i want to call a STM () inside a IO ()... what do i have to do? Probably one of the lifts.
13:20:46 <mroman> that's not possible.
13:20:49 <exio4> :t let f () = f () in f
13:20:52 <lambdabot> () -> t
13:20:53 <mroman> except in haskell maybe :D
13:20:57 <exio4> sternmull: atomically!
13:21:14 <fresheyeball> anyone out there know how to serve gzipped files with Servant?
13:21:39 <int-e> mroman: Well, ML too. Which probably extends to all the other typed functional programming languages.
13:21:45 <mroman> in some type systems inference is impossible
13:21:56 <int-e> (That don't mandate totality)
13:21:57 <mroman> unless type annotations are given.
13:21:58 <sternmull> exio4: Oh.. would never had figured that out on myself. Thank you.
13:22:55 <mroman> is there even another way to construct forall t. t except doing infinite recursion?
13:23:07 <ertes> helo
13:23:16 <exio4> mroman: in Haskell?
13:23:21 <lyxia> throw an exception
13:23:31 <mroman> in a haskell-y type system 
13:23:31 <exio4> mroman: exceptions in pure code are a bottom too
13:24:24 <lyxia> there's nothing more Haskell-y than Haskell.
13:25:16 <nitrix> Speaking of which, can someone explain to me why this is possible?
13:25:26 <nitrix> let x = 1 : [length x] ?
13:25:56 <Tuplanolla> > let x = 1 : [length x] in x
13:26:01 <lambdabot>  [1,2]
13:26:08 <Cale> nitrix: Well, what prevents it from working? :)
13:26:14 <nitrix> Nevermind, wrong example.
13:26:19 <nitrix> That one works because of lazyness.
13:26:23 <Cale> length doesn't care about the actual elements of the list, right
13:26:39 <bollu> what does ~(a, b) do?
13:26:43 <nitrix> I had a funkier case today.
13:26:43 <bollu> it's a little hard to google
13:26:46 <nitrix> Trying to find it.
13:26:49 <Cale> bollu: That's a lazy pattern match
13:26:57 <bollu> Cale: oh, that exists?
13:27:01 <fresheyeball> anyone know if serveDirectory serves gzip files?
13:27:04 <Cale> bollu: It will succeed without doing any evaluation
13:27:11 <bollu> Cale: in the sense?
13:27:17 <Cale> bollu: and only evaluate the argument if x or y needs to be evaluated
13:27:30 <Cale> With pairs, it's safe
13:27:52 <Cale> With types that have multiple constructors, be a bit careful, because you'll get an error if the pattern doesn't actually match
13:28:08 <bollu> Cale: can you show me an example of you using it?
13:28:08 <Cale> > case Nothing of ~(Just x) -> 5
13:28:13 <lambdabot>  5
13:28:17 <bollu> what? o_O
13:28:22 <bollu> OK
13:28:23 <Cale> ^^ but only if you actually use the variable
13:28:26 <Cale> > case Nothing of ~(Just x) -> x
13:28:32 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Irrefutable pattern failed for patte...
13:28:53 <bollu> Cale: I don't understand, why did it match with ~(Just x) ?
13:28:57 <bollu> does it always succeed
13:28:58 <bollu> ?
13:29:02 <Cale> yes
13:29:02 <exio4> a lazy pattern match always succeeds
13:29:06 <bollu> I see
13:29:16 <exio4> the error happens when you *use* a variable, not when you match 
13:29:21 <bollu> > case undefined of ~(1, 1) -> 4
13:29:24 <lambdabot>  4
13:29:26 <Tuplanolla> It's mostly useful for single-constructor values, bollu.
13:29:26 <bollu> wow
13:29:42 <mroman> witchcraft.
13:29:46 <Cale> For ~(x,y)
13:29:49 <bollu> Tuplanolla: I found a comment in the GHC source: mfix (\ ~(a,b,c) -> do ...; return (a',b',c'))
13:29:57 <bollu> so, like, why would you want a ~(a, b, c)?
13:30:00 <Cale> it's the same as if you wrote  let x = fst p; y = snd p in ...
13:30:06 <bollu> I see
13:30:12 <bollu> till you use it, it is never used
13:30:35 <bollu> > case undefined of (x, y) -> 5
13:30:35 <johnw> it's a thunk that only deconstructs the value when the result is demanded
13:30:38 <lambdabot>  *Exception: Prelude.undefined
13:30:49 <bollu> > case undefined of ~undefined -> 5
13:30:52 <exio4> bollu: the idea is delaying the pattern match as far as you want
13:30:55 <lambdabot>  5
13:30:56 <bollu> right
13:31:04 <bollu> > case undefined of ~~~4 -> 4
13:31:08 <lambdabot>  <hint>:1:24: error: parse error on input ‘->’
13:31:09 <mroman> > case 2 of ~1 -> 1
13:31:12 <lambdabot>  1
13:31:16 <bollu> multiple ~ not allowed?
13:31:26 <Cale> > case undefined of ~(~(~4)) -> 4
13:31:31 <lambdabot>  4
13:31:33 <bollu> oh
13:31:38 <mroman> > let x = 2 in case x of ~1 -> x
13:31:39 <nil_> I don't think evaluating "undefined == 5" leading to an error is a "design choice".
13:31:41 <lambdabot>  2
13:31:57 <Tuplanolla> > case undefined of ~ ~ ~ 42 -> 13
13:32:01 <lambdabot>  13
13:32:06 <Tuplanolla> No need for parentheses.
13:32:16 <mroman> > let x = 2 in case x of ~x -> x
13:32:20 <lambdabot>  2
13:32:28 <bollu> I see
13:32:33 <Cale> > let 0 = 1 in 0
13:32:33 <bollu> that is just.. weird
13:32:36 <nitrix> nil_: How undefined is implemented is a design choice, was my point.
13:32:37 <lambdabot>  0
13:32:42 <bollu> yeah no that's a cute trick :)
13:32:47 <nitrix> nil_: Stopping the execution rather than, say, hanging.
13:32:54 <Cale> ^^ note that pattern bindings in let are also lazy matches by default
13:32:57 <exio4> > foldr (\~(a,b) c -> if c then a else 0) False [(undefined, undefined)]
13:32:57 <bollu> > let x = 1 : [length x] in x
13:33:00 <lambdabot>  <hint>:1:18: error: parse error on input ‘->’
13:33:01 <lambdabot>  [1,2]
13:33:08 <Cale> > let (x,y) = undefined in 5
13:33:12 <lambdabot>  5
13:33:30 <pikajude> > let 2 + 2 = 5 in 2 + 2
13:33:35 <lambdabot>  5
13:33:40 <Cale> exio4: The space between the \ and ~ is required
13:33:49 <Cale> (or you can use parens)
13:33:51 <exio4> Cale: oh, that explains it
13:33:54 <pikajude> Cale: is that because \~ parses as an operator
13:33:55 <exio4> > foldr (\ ~(a,b) c -> if c then a else 0) False [(undefined, undefined)]
13:33:58 <Cale> yeah
13:33:59 <lambdabot>  error:
13:33:59 <lambdabot>      • No instance for (Num Bool) arising from the literal ‘0’
13:33:59 <lambdabot>      • In the expression: 0
13:34:02 <bollu> let x = 1 : [length x] in x <- I am guessing the "x" first gets instantiated to _, which then evaluates to 1:(length x), which becomes 1:length(_:_) which is 2?
13:34:06 <pikajude> we have the best operators, don't we folks
13:34:20 <nitrix> \~ is a cute operator.
13:34:27 <Cale> x = 1 : (length x : [])
13:34:29 <bollu> :t \~
13:34:38 <lambdabot> error: parse error on input ‘\~’
13:34:44 <Cale> So it's of the form _ : (_ : []) which will have length 2
13:34:48 <bollu> right
13:35:07 <bollu> _:_:[], I missed the :[] while typing it out
13:35:13 <nil_> nitrix: it was mroman who called it a "bad design choice".
13:35:18 <mroman> :t (\~)
13:35:21 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
13:35:26 <Cale> LOL
13:35:29 <bollu> nice :P
13:35:30 <Cale> figures
13:35:54 <bollu> what is LensLike, anyone? :)
13:35:54 <exio4> I am not surprised it is a lens operator
13:36:17 <mroman> nil_: It's a better choice than looping forever.
13:36:41 <Tuplanolla> I just learned that `LensLike` is `Lens` without the `Functor f` constraint with universally quantified `f`, bollu.
13:36:52 <mroman> although the much better choice would be nullable types
13:36:53 <bollu> Tuplanolla: oh, interesting
13:37:02 <bollu> Tuplanolla: so it's like, one functor section of a Lens
13:37:03 <nitrix> Tuplanolla: Yup! Have you looked at Lens
13:37:07 <nitrix> Tuplanolla: Lens' *
13:37:18 <mroman> I hate Java exactly because it doesn't distinguish between nullable and non-nullable types
13:37:23 <bollu> Tuplanolla: in that case, Getter and Setter are LensLike since they pick the Functor?
13:37:32 <nitrix> I do appreciate that lens has multiple level of abstractions within its own library.
13:37:32 <Tuplanolla> Indeed, bollu.
13:37:43 <mroman> and having nullable types as default is also a bad choice.
13:38:32 <mroman> What's a Day Functor .
13:38:53 <exio4> mroman: "mcuh better choice"?
13:39:17 <fresheyeball> mroman: its a vampire functor that can survive in sunlight
13:39:39 <mroman> exio4: yes...?
13:39:51 <exio4> mroman: undefined represents a ⊥, it's not directly related to nullable types
13:40:11 <nil_> mroman: my point is, it's not really a "choice" at all. Bottom is what it is, you don't get to design its behaviour.
13:40:13 <exio4> mroman: it's a result of having a turing-complete non-strict programming language
13:40:35 <mroman> I'm pretty sure you could get that without bottom too
13:40:39 <mroman> but I can never proof it.
13:40:48 <exio4> mroman: nullable types are akin to having a value you can "pattern match on" for every value
13:41:18 <mroman> yes. because nullable types might have a value or a non-value
13:41:23 <ph88^> does anyone know how to enable the optimal compiler algorithm for ApplicativeDo ?
13:41:40 <Tuplanolla> It's probably related to Day convolution, which I know nothing about, mroman.
13:41:51 <bollu> mroman: from what little I understand, there is an operation called Day Convolution, which lets one express Applicative as "monoid of endofunctors" with "compostition" being "Day convolution"
13:42:10 <Tuplanolla> I see I'm not alone on this.
13:42:37 <mroman> exio4: undefined is used for "NotImplemented" stuff.
13:42:39 <mroman> which is uhm..
13:42:42 <mroman> mostly bad anyway
13:43:07 <MarcelineVQ> ph88^: same way as any other extension, ApplicativeDo is picky about your notation though, don't end your do block with something like  return $ foo 3  bur rather return (foo 3)
13:43:08 <exio4> mroman: undefined is ⊥, I don't get what you mean?
13:43:27 <nil_> dolio has also pointed out that allowing you to *catch* errors /is/ a design decision and a bad one at that.
13:43:37 <fresheyeball> exio4: undefined is an absurd type
13:43:38 <MarcelineVQ> ph88^: Though, I read that as optional, if you meant optimal then I'm not sure what you mean
13:43:40 <fresheyeball> :t undefined
13:43:43 <exio4> fresheyeball: it's a value
13:43:43 <lambdabot> a
13:44:00 <fresheyeball> exio4: sorry, I mean undefined HAS an absurd type
13:44:21 <exio4> fresheyeball: well, ⊥ has an nonsense type :)
13:44:22 <fresheyeball> undefined :: forall a. a
13:44:29 <exio4> fresheyeball: it's one of the issues of being turing-complete
13:44:35 <ph88^> MarcelineVQ, really it can't handle $ in return ? wow :|
13:44:39 <ph88^> i use that EVERYWHERE
13:44:54 <fresheyeball> undefined is really good for development workflow
13:44:56 <exio4> fresheyeball: in a "normal" strict programming language you might still have nonsense values too
13:45:08 <fresheyeball> exio4: yes this is true
13:45:16 <exio4> template <typename T> T f() { return f(); } -- like given earlier, it's a "nonsense" function
13:45:20 <ph88^> MarcelineVQ, in the ICFP 2016 talk about it they say you can choose a heuristic search that O^2 and an optimal search that's O^3 .. so your compilation is slower but you get the best results
13:45:24 <exio4> that works in ML too, which is a functional and strict language
13:45:31 <ph88^> hi fresheyeball 
13:45:40 <fresheyeball> ph88^: hey dude
13:45:43 <ph88^> :D
13:45:59 <fresheyeball> exio4: anyway, undefined is like an exploding null 
13:46:02 <ph88^> MarcelineVQ, how did you know that about $ even ?
13:46:11 <exio4> fresheyeball: minus all the null semantics
13:46:11 <fresheyeball> null statisifies any type signature in imperative code
13:46:31 <fresheyeball> undefined does the same thing in Haskell
13:46:46 <fresheyeball> except if you evaluate null in imperative code, all is well, we do a null check for example.
13:46:58 <fresheyeball> but if you attempt to evaluate undefined in any way in Haskell, its a runtime error
13:47:21 <bollu> > undefined:undefined:[]
13:47:22 <dolio> exio4: ML folks would probably not say that there is an undefined _value_.
13:47:24 <lambdabot>  [*Exception: Prelude.undefined
13:47:24 <ahihi> not all imperative languages have null, and even in many that do it doesn't inhabit every type
13:47:42 <fresheyeball> ahihi: yes, I'm just giving an example to explain
13:47:54 <dolio> Although how they explain functions like that, I don't exactly know.
13:47:56 <exio4> dolio: I said nonsense values while refering to other PLs 
13:47:58 <MarcelineVQ> ph88^: I'm not sure, it came up when it was being implemented I think.
13:48:07 <exio4> dolio: to make 'em happy :)
13:48:15 <mroman> well in other languages you throw NotImplementedException
13:48:40 <exio4> dolio: as a function which claims it ∀X. () -> X is as nonsense as ∀X.X 
13:48:59 <fresheyeball> exio4: yes indeed
13:49:01 <nil_> Does "absurd type" mean "returns a and takes arguments that cannot yield a"?
13:49:08 <mroman> which with checked exceptions at least tell you that you shouldn't call that function
13:49:21 <MarcelineVQ> ph88^: but afaik it's a consequence of the fact that despite what people want to think $ is simply not (  )  and when you desugar, $ is reeeeally not (  )
13:49:25 <mroman> you don't see undefined until it's too late
13:49:28 <fresheyeball> nil_: absurd type means that you cannot have a value/term of this type
13:49:41 <exio4> nil_: it's related to the Curry-Howard isomorphism
13:49:52 <nil_> fresheyeball: is that not equivalent to what I wrote?
13:49:56 <mroman> I might be using a library right now that uses undefined somewhere
13:50:13 <mroman> so I have no idea whether my haskell code will crash in production because some library has an undefined SOMEWHERE
13:50:16 <fresheyeball> I think anything with a codomain with forall is absurd
13:50:28 <fresheyeball> mroman: correct
13:50:31 <exio4> mroman: it's the imperative equivalent of an infinite loop
13:50:39 <nil_> fresheyeball: that's basically what I was trying to convey.
13:50:41 <exio4> mroman: not the equivalent of a null
13:50:45 <fresheyeball> mroman: you can use safe-haskell I think
13:51:07 <fresheyeball> exio4: I drew distinctions on purpose
13:51:15 <ph88^> MarcelineVQ, this makes me sad :'(
13:51:22 <exio4> fresheyeball: is it? ∀a, a -> (∀r. r -> a) :p
13:51:31 <MarcelineVQ> I can't recall at the moment if $ with ApplicativeDo was an oversight, there wasn't time for it, or if people are finally getting tired of special cases for it :>
13:52:11 <nil_> exio4: fresheyeball meant codomains that are like "∀a".
13:52:14 <mroman> sure. you can write while(1); in any other programming language .
13:52:20 <fresheyeball> exio4: it is on the type level
13:52:37 <fresheyeball> exio4: but it has notable differences in behavior from Haskell (most of the time)
13:53:04 <exio4> nil_: I know, I am just bored :P
13:53:22 <Cale> mroman: Well, in production, I would recommend using error at the very least, but loch-th is better. https://hackage.haskell.org/package/loch-th
13:53:38 <fresheyeball> nil_: more like codomains that are like "∀a. a"
13:53:42 <exio4> fresheyeball: I don't know what we are talking about?
13:53:47 <Cale> mroman: Then when one of the supposedly-impossible cases arises, you at least get a line number.
13:54:10 <exio4> it was people comparing null to undefined
13:54:20 <exio4> they're different beasts
13:54:31 <exio4> undefined is the result of turing-completeness, either way
13:54:39 <Cale> yeah
13:54:45 <dmwit> Now that stack traces are a thing, is loch-th even needed?
13:55:01 <mroman> exio4: why?
13:55:06 <Cale> dmwit: We don't always run our production code with profiling turned on.
13:55:23 <mroman> I can have turing completeness without undefined as well.
13:55:27 <exio4> mroman: how? :)
13:55:43 <mroman> I uhm.
13:55:55 <mroman> write a brainfuck interpreter in a language with a c-like type system?
13:55:56 <bollu> there is no way to "step through" a haskell codebase is there?
13:56:14 <bollu> mroman: if it is turing complete, I can always encode non-termintation
13:56:17 <bollu> termination*
13:56:17 <mroman> you don't need a forall t. t type for turing completeness.
13:56:43 <exio4> mroman: ⊥ means "doesn't produce a `meaningful` value
13:56:44 <Cale> (though it's getting to the point where it almost seems like a good idea -- I'd just love to be able to extract heap profiling data in realtime as the program is running, for the sake of monitoring
13:56:45 <exio4> "
13:56:46 <dmwit> Cale: From the documentation, "CallStacks do not interact with the RTS and do not require compilation with -prof."
13:56:51 <Cale> hmm
13:57:10 <Cale> Well, I haven't ever seen them outside of building with -prof, so I'm not sure.
13:57:31 <ezyang> We're talking about the GHC.Stack functionality 
13:57:47 <dmwit> Cale: Just stick `main = error "foo"` in a file, compile and run.
13:57:49 <mroman> of course... you can have stuff that never terminates.
13:57:57 <ezyang> The major problem is you have to thread the CallStack around in the type signatures 
13:57:57 <mroman> but it still has a bound type.
13:58:08 <exio4> mroman: which is what exactly undefined is? 
13:58:17 <mroman> undefined doesn't have a bound type.
13:58:18 <dmwit> Cale: Prints out "`error, called at test.hs:1:8`" and some other stuff.
13:58:27 <bollu> :t undefined
13:58:30 <lambdabot> a
13:58:41 <mroman> but i'm probably using the wrong terminology here.
13:58:50 <exio4> mroman: its type is ∀t.t 
13:58:54 <exio4> mroman: every value has a type
13:59:12 <exio4> mroman: if you mean "polymorphic type", then you also have values like Nothing
13:59:15 <exio4> :t Nothing 
13:59:17 <lambdabot> Maybe a
13:59:23 <exio4> ∀a. Maybe a
14:00:09 <mroman> yeah... that's fine
14:00:19 <mroman> if the type is bound during invocation.
14:00:34 <mroman> anyway
14:00:44 <fresheyeball> well if we are thinking without undefined
14:00:47 <Cale> dmwit: ah, you're right, hm! I suppose it must have been a while since I've actually hit an error of that sort in backend code :)
14:00:53 <fresheyeball> ∀a. Maybe a must be Nothing
14:00:58 <bollu> Cale: denotational semantics question: what is the use of the Scott topology?
14:01:01 <dmwit> Cale: grats =)
14:01:02 <mroman> just saying that you don't need forall t. t types to build a turing-complete language.
14:01:45 <exio4> mroman: I don't understand what you mean by that phrase :)
14:01:56 <kadoban> Well, you don't need types to have a turing-complete language, so I'm not sure how to respond to that really.
14:01:59 <exio4> mroman: "you don't need ∀t.t to build a turing complete language" ? 
14:02:10 <exio4> Brainfuck is turing complete and doesn't have types, so is untyped lambda calculus
14:02:22 <dmwit> exio4: You can throw `fix` as a syntactic term into STLC no problem. `fix (id : Int -> Int)` will still be an infinite loop, and doesn't require any exciting types.
14:02:51 <dmwit> exio4: I think you do understand the statement, and agree with it vehemently. =)
14:02:51 <mroman> I may have misinterpreted your statement that "undefined is a consequence of turing-completeness"
14:03:08 <bollu> dmwit: you can't type Y in STLC, right?
14:03:15 <exio4> dmwit: oh, well, that makes sense indeed
14:03:20 <dmwit> bollu: No, but you can *add* it.
14:03:26 <Cale> bollu: Well, continuity under that topology imposes a condition on functions between the sets we're using to model the elements of various types which has to hold if the functions are to be computable
14:03:28 <dmwit> bollu: STLC+Y is an easy system to define.
14:03:57 <bollu> Cale: I see, so, continuity of the function in the topology means computable? that is rad :) 
14:04:17 <exio4> so, "you don't need polymorphic types/parametric polymorphism for being turing-complete"? :)
14:04:28 <bollu> Cale: I wanted a sneak peek, I was reading the Scott and Stratchey book
14:04:31 <mroman> you don't.
14:04:33 <Cale> At the very least, computable implies that the function will be continuous with respect to that topology.
14:04:38 <bollu> I see
14:04:42 <mroman> but they are convenient to have :)
14:04:55 <exio4> mroman: while discussing about undefined, it's about ⊥ that we were talking about, might have no been clear, though.
14:05:22 <mroman> i.e. in the type system I'm currently working with
14:05:24 <joe9> is there a boxes package that can work with Text? instead of using String. https://github.com/treeowl/boxes/pull/1 seems to be pending for quite some time. Just want to check if there is something better out there.
14:05:26 <bollu> Cale: also, how do CCCs come into the picture, if you know?
14:05:33 <mroman> def foo(): foo() doesn't have an assignable type.
14:06:08 <Cale> You can interpret the simply typed lambda calculus in any CCC.
14:06:45 <mroman> so it's impossible to construct undefined :: a
14:07:09 <exio4> mroman: undefined = foo () ?
14:07:20 <Cale> So, rather than defining functions between sets, or Scott-continuous maps between directed complete partial orders, you're defining arrows between objects in some other CCC.
14:07:38 <exio4> mroman: I don't get what you mean
14:07:44 <bollu> Cale: yes, but I remember reading something about "category of scott domains forms a CCC" (?) 
14:07:49 <dmwit> mroman: Wait, are you saying your type-checking function must first determine if the term halts?
14:07:54 <Cale> bollu: yeah
14:07:58 <mroman> dmwit: No.
14:08:00 <nshepperd> mroman: you mean that foo's type can't be inferred, or it can't be given a type at all? can you just write foo :: Int?
14:08:28 <mroman> def foo(): foo() is like saying "foo's type is foo's type"
14:08:29 <mroman> which
14:08:33 <zennist> test
14:08:38 <mroman> can't be done.
14:09:00 <bollu> Cale: I see, thanks for the overview :)
14:09:13 <bollu> Cale: do you know what I can read after the denotational semantics book?
14:09:16 <Cale> bollu: That just means that it has a terminal object, that any pair of objects has a product A x B, and that any pair of objects has an exponential B^A
14:09:29 <exio4> :t let foo () = foo () in foo
14:09:32 <lambdabot> () -> t
14:09:35 <exio4> mroman: I just gave it one.
14:09:44 <exio4> mroman: it can be () -> Int, too
14:09:48 <dmwit> mroman: Okay. Why have you made this design decision?
14:10:44 <mroman> because it's impossible to assign it a type?
14:10:49 <Cale> mroman: As much as I'd be all for having more totality checking, there are cases which arise in real world settings that unrestricted recursion is just really useful.
14:10:52 <nshepperd> mroman: so you are forbidding recursion?
14:10:59 <mroman> nshepperd: no.
14:11:02 <dmwit> mroman: Why is that a good goal?
14:11:19 <mroman> "concrete" type I should say.
14:11:33 <exio4> mroman: it's perfectly possible to assign it one?
14:11:41 <exio4> :let foo () = 1 + foo () in foo 
14:11:43 <mroman> exio4: it's in more powerful type systems.
14:11:49 <Cale> I don't necessarily want to have to prove to the compiler that my definition is terminating, or productive in the case of coinduction.
14:11:50 <exio4> :t let foo () = 1 + foo () in foo 
14:11:52 <lambdabot> Num a => () -> a
14:12:04 <Cale> Sometimes it might be a good idea to eventually get that done, but there are only so many hours in the day :)
14:12:06 <nshepperd> mroman: i'm not sure I understand. what concrete error message will I get if I try to write 'def foo(): foo()' in your system?
14:12:34 <mroman> "Can't assign type to foo".
14:12:54 <exio4> mroman: which error would "foo () = 1 + foo()" throw?
14:12:57 <dmwit> Cale: I think it wouldn't be too hard to design a system that ruled out `foo = foo` without ruling out all recursion or all nonterminating terms. e.g. `foo = if x then 1 else foo` could still be typable. I don't see *why* you would want to do this (yet), but I think you *could*.
14:13:25 <mroman> def foo(x): if x == 0 return x else return foo(x) is assignable
14:13:35 <sternmull> when writing a Consumer for Pipes... how can i terminate it when the end of the input is reached? Or does "await" do that for me?
14:13:54 <dmwit> Cale: (e.g. the type system that asks GHC what the type of a term is, and rejects when the answer is `forall a. a`, would have the property I'm suggesting.)
14:14:00 <t4nk315> What is a good package for prime numbers?
14:14:10 <mroman> that's a constraint on the if
14:14:19 <mroman> both the then as well as the else clause MUST have the same type
14:14:48 <exio4> mroman: so you are restricting polymorphism?
14:14:52 <mroman> so if you have either a then or an else clause with an assignable type it binds the other one as well.
14:14:59 <exio4> mroman: you will still have non-terminating values which can inhabit every type? 
14:15:23 <dmwit> exio4: I don't think he will. Only non-terminating values that can inhabit specific types. =)
14:15:41 <mroman> well
14:15:56 <mroman> def loop(a): if False then return a else lop(a)
14:16:01 <mroman> won't return.
14:16:10 <mroman> but it has type a -> a
14:16:14 <exio4> dmwit: heh, yeah, seems like a loss of generality which doesn't tackles the real "issue" though 
14:16:30 <dmwit> Yes. I am awaiting an answer to my "why" question. =)
14:16:31 <Cale> dmwit: Perhaps we could at least have a warning about that. :)
14:16:39 <dmwit> Cale: Yeah!
14:16:44 <exio4> Cale: that sounds cool, actually!
14:16:55 <dmwit> Cale: We have a runtime warning. ;-)
14:17:01 <dmwit> * Exception: <<loop>>
14:17:29 <Cale> <<loop>> is a bit more general -- you might not be able to do enough static analysis to figure all of those out at compile time
14:18:16 <Cale> But yeah, when something ends up with type forall a. a without literally being a call to error or undefined, it's fishy and it might be nice to have a warning about it.
14:18:25 <dmwit> mroman: So I think one downside of ruling out `forall a. a` as a type is that you lose the ability to define a library function that plays the role that `error` does in Haskell.
14:18:46 <exio4> mroman: do you have exceptions?
14:19:02 <exio4> mroman: if so, what's the type of your "throw" function?
14:19:39 <mroman> nope. no exceptions.
14:19:48 <mroman> more like a maybemonad
14:21:58 <mroman> although you could get that by circumventing the type system
14:22:03 <mroman> well
14:22:07 <mroman> "circumventing"
14:22:45 <dmwit> t4nk315: arithmoi?
14:23:06 <mroman> I mean you can always have a builtin abort that just aborts.
14:23:46 <dmwit> mroman: Congratulations, you just invented `undefined`. =)
14:23:58 <mroman> not really.
14:24:07 <dmwit> What's the difference?
14:24:18 <mroman> you can have int abort(); 
14:24:27 <ezyang> it's more like undefinedIO 
14:24:40 <dmwit> Yes. But then you can't use `abort` in a branch of an `if` that returns a `String`.
14:25:00 <dmwit> If you want `abort` to be useful in that sense, it should be able to take on any type, so that you can use it to signify dead code.
14:25:24 <max3> dmwit, okay i've considered just passing my config around and it's too painful. if my global variable (the config) is never mutated, is it still such a terrible idea?
14:25:33 <mroman> of course I can.
14:25:36 <dmwit> max3: Then it's an even worse idea.
14:25:41 <max3> why?
14:25:53 <mroman> it's not a lazy language.
14:26:07 <dmwit> Because now you've introduced a subtle failure mode to your software: somebody writing to that `IORef` by accident (or on purpose!).
14:26:16 <mroman> const "" abort would do the trick
14:26:23 <max3> dmwit, okay what's the solution then
14:26:30 <dmwit> mroman: I mean something like `if x then "foo" else abort` would not be allowed presumably, if `abort` has type `int`.
14:26:40 <dmwit> max3: Reader, or pass your config around.
14:26:52 <mroman> no, but if x then foo else const "" abort is allowed.
14:27:06 <max3> Reader requires rewriting a lot potentially right?
14:27:29 <ezyang> yes, the trick is to define a custom monad from the beginning 
14:27:42 <dmwit> mroman: Now your programmer has to be able to construct a value of whatever stupid type is in the other side of the branch. That seems annoying; it could be a big struct type with lots of fields to fill in.
14:28:02 <max3> ezyang, yes well i'm very far from the beginning 
14:29:19 <mroman> you could also special case abort to have any type.
14:29:30 <dmwit> mroman: Okay, *now* you've invented `undefined`.
14:29:36 <mroman> that's probably what I'm going to do later anyway.
14:29:55 <dolio> > const "" undefined
14:29:55 <ezyang> max3: You and I :) 
14:29:58 <lambdabot>  ""
14:30:07 <ezyang> sometimes there's a parameter you were threading around anyway so you start stuffing everything in that haha 
14:30:09 <dmwit> dolio: He's stipulated earlier that his language is strict.
14:31:06 <dmwit> mroman: (To make my point more clear: "abort has any type" and `abort :: forall a. a` look strikingly similar to me.)
14:31:51 <mroman> well it's still an unassignable type.
14:32:10 <mroman> you can't *write* a function *in* the language to have that type.
14:32:26 <dmwit> Why have you chosen to prevent this?
14:33:03 <mroman> because it's much easier to understand.
14:33:29 <exio4> it's actually harder to do that
14:33:37 <dmwit> mroman: hm =)
14:33:51 <exio4> because you are making the type system more complicated than if you "simply allowed polymorphism"
14:34:07 <mroman> there's polymorphism.
14:34:17 <mroman> you can perfectly write a function a -> b -> a
14:34:24 <mroman> even Num a => a -> b -> a
14:34:35 <dmwit> mroman: Can I write `fix` in your language?
14:34:40 <mroman> :t fix
14:34:42 <lambdabot> (a -> a) -> a
14:34:54 <mroman> @src fix
14:34:55 <lambdabot> fix f = let x = f x in x
14:35:00 <mroman> probably not.
14:35:33 <mroman> although
14:36:04 <dolio> It's like leap years.
14:36:10 <max3> okay this is pretty irrelevant but what's a scripting language that strikes a good balance between easy to write and type safe-ish?
14:36:40 <dolio> Every 4 years, except every 100 years, except every 400 years.
14:36:53 <frontendloader> typescript
14:36:53 <dmwit> mroman: Can I write the Y combinator in your language?
14:36:56 <mroman> I might have to get back to you once I've actually implemented functions as values.
14:36:58 <Rembane> max3: Dylan
14:37:44 <max3> okay i should've said *with a decen eco-system* too
14:37:45 <dolio> Things can be polymorphic, except not when they're polymorphic like this, except certain functions which are allowed.
14:39:04 <mroman> well... a function has an assignable type if when there's no cycle in type checking.
14:39:06 <kgadek> is anybody working on language-server [LSP] for Haskell? It seems to be quite à la mode now
14:39:29 <frontendloader> max3: still typescript
14:39:33 <Berra> Does anyone here know if there existed a lazy language before KRC?
14:39:49 <max3> frontendloader, hmm js
14:40:14 <mroman> let x = f x in x is not doable though.
14:40:41 <mroman> that's like writing x = f(x)
14:40:50 <kgadek> re my question: nvm, found this https://www.reddit.com/r/haskell/comments/5r3i04/haskell_for_vscode_ide/ 
14:40:55 <dmwit> It is like writing that, yes. Why shouldn't that be doable?
14:41:46 <dmwit> (Before you say "because my language is strict": OCaml is strict, and you can write `x = 1 :: x` just fine there and it makes exactly the cyclic data structure you would want it to make.)
14:42:02 <dmwit> (`::` is OCaml's spelling of `:`)
14:43:02 <dmwit> > let fib' f x = if x < 2 then 1 else f (x-1) + f (x-2); fib = fib' fib in map fib [0..5]
14:43:06 <lambdabot>  [1,1,2,3,5,8]
14:43:08 <mroman> you could write x = 0; x = f(x);
14:43:15 <mroman> something like that
14:43:28 <mroman> except that that's also not doable
14:43:36 <mroman> because variables aren't mutable
14:43:48 <mroman> x = 0; y = f(x); would work though.
14:44:01 <dmwit> But that means something very different.
14:44:07 <mroman> I know.
14:44:19 <mroman> what you want is f(f(f(f(....
14:44:29 <dmwit> Yes.
14:44:32 <mroman> nope
14:44:34 <mroman> can't due that.
14:44:40 <mroman> that's witchcraft.
14:44:47 <mroman> *do
14:44:51 <dmwit> You keep saying that. But you've never answered *why* it's good to rule that out.
14:45:46 <mroman> f(f(f(f( never even returns.
14:46:05 <mroman> it provably never returns.
14:46:17 <Rembane> Side effects to the rescue!
14:46:20 <dmwit> mroman: What do you make of my code above that returns despite using that pattern, then?
14:46:42 <mroman> the fib?
14:46:46 <dmwit> yes
14:47:18 <Axman6> mroman: that depends on what f is
14:47:35 <dmwit> mroman: Or even more simply,
14:47:50 <dmwit> > let f = (1:); x = f x in x
14:47:52 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:47:53 <Axman6> seems you're talking about a specific f, but it si not the case in general. a trivial example is f = const ()
14:48:11 <dmwit> Oh, I like `const`.
14:48:12 <Axman6> it is true if f is strict in that argument
14:48:23 <Cale> let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
14:48:25 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
14:48:30 <mroman> if you chain an infinite amount of f(f(f(f(f(...)
14:48:30 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
14:48:35 <mroman> then it doesn't return.
14:48:38 <dmwit> I wonder what OCaml would make of `fix const`.
14:48:44 <Cale> mroman: How do you know that?
14:49:01 <Cale> mroman: The outermost f might finish immediately without needing to examine its argument
14:49:21 <Axman6> > let f = const () in f (f(f(f(f(f(f)))))
14:49:27 <lambdabot>  <hint>:1:40: error:
14:49:27 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
14:51:22 <mroman> Cale: good point.
14:55:45 <dmwit> At a high level: I think you want to support user-written recursion combinators. These are very useful e.g. for implementing memoization libraries and the like. But if you allow those, then you allow `fix`; and if you allow `fix` and polymorphism, then you allow `fix id`; and if you have `fix id` then you have `undefined`.
14:59:45 <hpc> clearly polymorphism is to blame
15:11:14 <tommd> I'm trying to make heads or tails of `HookedBuildInfo` in Cabal.  Does anyone have a non-source-code-dive explanation?
15:11:47 <tommd> The short of it is I want to change the BuildInfo, but in preConf the `fst` element is `Nothing`.
15:17:52 <bollu> someone on #haskell was asking about applicativeDo?
15:18:02 <bollu> I was reading the paper, and it says: "A shortcoming of our design is that the check for return or pure is purely syntactic, and is easily defeated. For example, even return $ x or let p = pure in p x are not recognised"
15:18:14 <bollu> I thought they would be interested as to why the return $ x didn't work :)
15:22:59 <lyxia> ph88^: ^
15:23:25 <ph88^> hi lyxia 
15:23:57 <ph88^> ah yes ok :P
15:29:07 <alviprofluvium> :q
15:37:50 <codedmart> Can you prepend a line to a file?
15:41:14 <fresheyeball> codedmart: yes
15:41:48 <codedmart> fresheyeball: I guess I know you can, but I mean is there already a func for it somewhere I am missing?
15:43:47 <fresheyeball> not that I know of
15:43:55 <fresheyeball> I think the easiest would be to read and then write
15:46:50 <jle`> sounds O(n) on the length of the file...which isn't ideal
15:49:43 <kadoban> The way files work in most filesystems, isn't it required to be O(n)? or maybe I'm not thinking of something.
15:50:19 <jle`> yeah i think that's the best you can do
15:56:30 <ffilozov> I'm not very familiar with cabal, but I'm trying to understand what is meant by "cabal hell". I'm reading the following: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html. I don't quite understand what the issue is with installing quux-1.0, because bar-1.0 can still point to baz-1.0, and quux-1.0 can point to baz-2.0 at the same time. Shared modules that only differ in version can be loaded together.
15:57:07 <ezyang> ffilozov: It's not that important to understand what it is; just use cabal new-build or stack 
15:57:36 <ezyang> people mean different things when they say "cabal hell" so it's not particularly well defined 
15:57:37 <ffilozov> ezyang, I'm aware of stack and sandboxes, but I will like to understand it anyway.
15:58:33 <ezyang> In my head, cabal hell refers to a specific implementation problem with "cabal install", which is that you can't have multiple copies of the same package name + package version combo in your package database 
16:01:29 <ffilozov> Do you know why that is? Is it a limitation with cabal, or Haskell package manager?
16:02:54 <ezyang> ffilozov: It was a limitation with Cabal. There were some design reasons for it but history shows that it was in the wrong point of the design space 
16:03:42 <ffilozov> In the example I gave you, I don't see how this rule is broken. It says that bar-1.0 will be rebuilt against baz-2.0, but I don't see why that would be the case. Seems like they're implying possible issues with linking?
16:05:25 <ezyang> in th eexample, quux requires baz-2.0 
16:05:42 <ezyang> and there is a "same version" restriction, which states that package versions must be consistent through the transitive dep graph 
16:09:07 <max3> why do i have to jump through all the hoops i jump through on line 15 here 
16:09:08 <max3> http://lpaste.net/352828
16:09:11 <max3> why doesn't line 16 work
16:09:18 <ffilozov> Could you elaborate on that? I'm not sure what you mean. My expectation is that when building quux, cabal-install sees that bar-1.0 has been built, so it skips that step, and moves on to baz-2.0.
16:09:26 <max3> i get the exception at the top
16:09:34 <max3> err compilation error not exception
16:10:17 <ezyang> ffilozov: This is a little hard to explain if you are used to something like node.js 
16:10:45 <ezyang> but essentially, bar-1.0 built against baz-1.0, and bar-1.0 buitl against baz-2.0, are *completely different libraries* 
16:14:33 <ffilozov> What is the reason for trying to build bar1.0 against baz2.0? Does it not look for previously build libraries?
16:14:40 <MarcelineVQ> max3: give it a try with OverloadedStrings on https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overloaded-string-literals
16:15:17 <max3> hmm really?
16:15:30 <max3> i guess i misunderstood stringliterals
16:16:09 <max3> MarcelineVQ, thanks a lot
16:28:38 <xpika> monad has fmap is there an equivalent for pipes ?
16:30:41 <lyxia> pipes are monads
16:36:32 <benzrf> xpika: actually, Functor has fmap
16:36:36 <benzrf> attention to detail https://i.imgur.com/cHR8tuD.png https://i.imgur.com/21ClPZL.png
16:48:16 <xpika> I basically want to: fmapPipe f p = p >-> (do { x <-await ; yield (f x)} )
16:51:18 <xpika> runEffect $ (fmap (Prelude.drop 1) stdinLn) >-> stdoutLn
16:51:21 <xpika> this doesn’t work
16:52:48 <lyxia> http://hackage.haskell.org/package/pipes-extras-1.0.8/docs/Pipes-Extras.html arr?
16:53:38 <lyxia> oh it's called map in pipes
16:55:33 <xpika> lyxia: crosses fingers
17:04:37 <xpika> lyxia: not precisly what I wanted but pretty close
17:13:28 <clmg> Is there a simple way to provide a link to a parent in a tree-like structure of records?
17:13:35 <clmg> is this 'tying the knot'?
17:14:52 <clmg> If I put the parent as a field of the child record, it will just be a duplicate of the record, no?
17:16:12 <kgadek> clmg: no, it should work
17:16:24 <kgadek> (unless you make the field unpacked)
17:17:04 <clmg> kgadek: what if I do a `set` with lenses, will it set the value in both places?
17:19:46 <kgadek> clmg: re original question — http://pastebin.com/Krn4rfyZ this is a kind-of-proof that it works. If you paste it into GHCi it will just work. But don't try to print it :)
17:19:52 <kgadek> (or actually do try :) )
17:20:23 <clmg> kgadek: ha okay, thanks!
17:26:15 <kgadek> clmg: as for lens question
17:26:21 <kgadek> no, it will not do that
17:26:40 <kgadek> let's use the example from my code
17:27:22 <kgadek> if you will change the root then… you don't actually make a change
17:27:29 <kgadek> you create a new `root`
17:27:35 <kgadek> the old one is still there
17:27:51 * kgadek is wondering how to clearly explain this
17:28:27 <kgadek> ok, so if you look at "pointers" you have essentially `root --> left --> root`
17:28:51 <kgadek> root has pointer to left children, which has pointer to its parent — that is, to the root
17:28:53 <kgadek> cool
17:29:00 <kgadek> and now you "modify" root
17:29:13 <kgadek> in Haskell you don't modify things, you create new ones
17:29:27 <kgadek> (unless you really insist ;) )
17:30:15 <kgadek> e.g. you say: take the `root`, modify its `left.val` to contain some new value
17:30:32 <kgadek> so new root2 and left2 objects are created
17:30:33 <kgadek> but wait
17:30:42 <kgadek> you didn't update left2 value for parent
17:30:54 <kgadek> so you have: root2 --> left2 --> root
17:31:08 <kgadek> actually, it's even deeper: root2 --> left2 --> root --> left
17:33:06 <kgadek> in other words: if you have knot tied, than any change will require WHOLE STRUCTURE to be recreated
17:34:46 <kgadek> this is… well, troublesome sometimes. If you have this situation, you'd usually use ST/IO monad to perform actual mutation (I told: you can insist! :) )
17:35:04 <kgadek> however, most often a zipper "idiom" is totally enough
18:06:38 <robertkennedy> Test (sorry)
18:08:54 <robertkennedy> How can I check that ((,) <$> fst <*> f . snd) == fmap f?
18:11:20 <byorgey> robertkennedy: by "check" do you mean "test", or "prove"?
18:12:22 <robertkennedy> Check, I'd guess - there should be a level in ghc's cycles where the two converge
18:12:46 <robertkennedy> That would be a proof
18:13:15 <byorgey> OK.  In that case, just apply both of them to an arbitrary value of type (a,b) and see that they reduce to the same result.
18:14:15 <robertkennedy> Hmmm.... That would work for (reverse . reverse . reverse) == reverse 
18:14:18 <byorgey> though of course in order to do that you have to understand what fmap, <$>, and <*> do for the types in question
18:14:43 <byorgey> robertkennedy: not really, you would have to prove that by induction.
18:14:58 <robertkennedy> I want to ensure that GHC is as clever as I give it credit for
18:15:04 <monochrom> A test is a proof, when the statement is an existential statement.
18:15:53 <byorgey> robertkennedy: then I'm not sure I really understand your question.  Are you asking whether those two expressions (1) have the same result, or (2) actually compile to the same code?
18:16:06 <monochrom> In fact, with parametricity, a test can also prove some special universal statements.
18:16:10 <robertkennedy> The latter 
18:16:45 <byorgey> robertkennedy: ah.  Then I suppose you want -ddump-core or something like that.
18:17:02 <monochrom> -ddump-simpl or -ddump-prep
18:17:10 <byorgey> though to be honest, I am not sure why you would care.
18:17:19 <monochrom> -ddump-prep is very detailed but also one of the most honest
18:17:29 <byorgey> interesting, I didn't know about those
18:17:30 <exio4> and the code might be the same today, and different tomorrow
18:17:51 <monochrom> I don't think there is -ddump-core. That would be too easy. :)
18:18:18 <byorgey> heh, you can tell how often I actually use any of these features.
18:19:13 <robertkennedy> I'm sure that my code is so sophisticated that GHC wouldn't recognize two similar functions. 
18:19:38 <monochrom> -ddump-prep is the very final Core stage (right before STG --- but I don't like STG, more information overload with no benefit over Core)
18:20:40 <monochrom> -ddump-simpl is just before -ddump-prep. Main difference: Whereas -ddump-simpl may say "y = f (g x)", -ddump-prep spells it out as "y = let tmp1 = g x in let tmp2 = f tmp1 in tmp2"
18:21:24 <monochrom> So it's useful to know of both options. Sometimes you may like the more human-friendly version, some other times you want to see every bloody thunkification.
18:22:44 <monochrom> There are a whole bunch of more -ddump-* things that tell you the Core stages before these last two, but they are the stages when not all optimizations have finished, so their utility to end-users like me is low.
18:25:01 <robertkennedy> Right... If I just want to see if my newtype/data wrappers have correctly desugared (before bug hunting through core), I could create these sorts of tests. Is there architecture to support those tests? Or is it best to gain an intuition for core's ability through trial and error?
18:26:24 <MarcelineVQ> where is that documented monochrom? I thought, without much grounds to think so, that simpl came after prep. is prep the CoreTidy pass?
18:26:38 <halogenandtoast> What's the idiom for naming modules with Data in front of it. For instance I'm writing a game (that I would like to tast) so I'd like to have a bunch of stuff compiled as a library. Why would I choose to prefix the module name with Data?
18:26:48 <halogenandtoast> s/tast/test/
18:27:06 <MarcelineVQ> monochrom: Oh I see it here, nvm, thank you
18:27:43 <MarcelineVQ> hard to find writing about it but it does exist in an overview diagram
18:28:18 <MarcelineVQ> mm, there we go, in case others have interest  https://ghc.haskell.org/trac/ghc/browser/ghc/compiler/coreSyn/CorePrep.hs
18:31:29 <robertkennedy> Ah, earlier I should've said "my code is not so sophisticated that GHC could not receive recognize similar functions". GHC ought to recognize f = fmap (+1+1) = fmap (+2), unless I misunderstand the goal of GHC
18:31:45 <jle`> halogenandtoast: there's is a trend these days of just using the top level naming space for things like that
18:33:01 <robertkennedy> If GHC is not so sophisticated, is that an open problem or a decided discontinuity?
18:33:34 <ezyang> overloading interacts poorly with other features (e.g., polymorphism) 
18:34:22 <monochrom> > (+1+1) 0
18:34:26 <lambdabot>  error:
18:34:26 <lambdabot>      The operator ‘+’ [infixl 6] of a section
18:34:26 <lambdabot>          must have lower precedence than that of the operand,
18:35:14 <jle`> robertkennedy: ad-hoc optimizations like that don't really scale
18:35:22 <jle`> and it's hard to know if constant term elimination terminates
18:35:27 <jle`> before actually trying it
18:35:54 <miscyb> what's the proper way to use frp (in my case reactive-banana) with async? example: I call async to make a thread that is constantly modifying an IORef that my main thread reads from. I'd like to do something like fire an event instead, but I don't think reactive banana allows for that.
18:39:27 <robertkennedy> > (+1) . (+1) $ 3
18:39:30 <lambdabot>  5
18:47:25 <halogenandtoast> jle`: thanks, so Data.Game.Foo would just be Game.Foo, but what was the original intent with Data?
18:47:31 <halogenandtoast> afk for lunch
18:50:08 <chocopuff> Is it a good idea to use Haskell for systems level programming? like scripting? are there any downsides to doing that 
18:50:16 <johnw> for scripting it's amazing
18:51:19 <johnw> the downside is that (a) it can be hard to get running on <some random system>, because you need to build it for that system (b), other people will have no idea what you've done, unless they're also Haskellers, (c) you can't get away with doing stupid things as easily, and sometimes, system scripting just doesn't need to be all that smart
18:51:50 <johnw> for quick-and-dirty I use bash, and once I start needing things like arrays and dictionaries, I switch to Haskell
18:52:20 <ezyang> This is what we mean when we say "Haskell is the best imperative language" ;) 
18:52:54 <johnw> ezyang: how did the backpack talk go?
18:53:42 <ezyang> johnw: Well, I think! 
18:54:57 <johnw> is it recorded anywhere?
18:55:25 <ezyang> I was recorded, but I don't know if it's been uploaded 
19:01:02 <chocopuff> johnw: but I guess the "downside" (as in onthing inherently wrong with the actual haskell) is the portability/sharing it
19:02:03 <johnw> chocopuff: I use it for a lot of scripting; one of its nicest feature is how easily you can add support for concurrency
19:02:23 <chocopuff> you'd have to have haskell on that system
19:02:23 <chocopuff> good to hear then! I think i'll try that out more
19:02:53 <johnw> if resource efficiency means nothing to you, Docker is an easy way to get complex Haskell programs running on many systems
19:04:11 <Cale> chocopuff: You might find Propellor to be interesting
19:04:50 <Cale> https://hackage.haskell.org/package/propellor-3.3.1
19:04:55 <Cale> https://propellor.branchable.co
19:05:01 <Cale> oops https://propellor.branchable.com/
19:05:16 <johnw> Cale: have you ever used Propellor for anything?
19:07:03 <Cale> I haven't, but I'm thinking about using it for my personal machine configuration -- somewhat jealous of nixos' ability to encode all that sort of thing.
19:07:35 <Cale> (But there are various reasons that nixos is annoying to configure the way I want -- the main one being that it doesn't have my favourite desktop environment)
19:17:34 <johnw> I'm not brave enough to use NixOS on a laptop, the way ryantrinkle does, but I do use it for my file server; on the laptop, I use nixpkgs on top of macOS. The way it lets me work with Haskell is nothing short of miraculous.
19:19:37 <Koterpillar> Is there a NixOS guide that doesn't start with a lot of manual steps, and instead focuses on writing a configuration first and then applying it to a clean machine?
19:27:21 <johnw> Koterpillar: not that I know of
19:52:36 <c0dehero> man. i wish security upgrades would work nicely on NixOS
19:53:58 <c0dehero> Koterpillar: i can give you my config file if that helps. lol
19:54:23 <Koterpillar> c0dehero: I'd love to have a look, thanks
19:56:29 <c0dehero> Koterpillar: there you go https://github.com/C0DEHERO/nixrc https://github.com/C0DEHERO/dotfiles/tree/master/nixpkgs
19:56:54 <c0dehero> lol. it's been 2 years already since i stopped using nixos oO
19:56:58 <c0dehero> wow
19:57:04 <c0dehero> how time flies
19:58:09 <clmg> Why do I get 'cannot construct the infinite type' when trying to pull the just out of this maybe?
19:58:21 <clmg> data Foo = Foo { child :: Maybe Foo }
19:58:31 <clmg> let Just child = get child foo
19:58:54 <Koterpillar> clmg: what's the type of foo?
19:59:03 <clmg> "cannot construct the infinite type a ~ Maybe (Foo :-> a)"
19:59:23 <clmg> Koterpillar: it's a data constructor? Its type is Foo.
19:59:27 <clmg> right?
19:59:50 <Koterpillar> clmg: then why not: let Just child = child foo
20:00:03 <Koterpillar> you've clobbered the name, but well
20:00:23 <clmg> oh
20:00:34 <clmg> I think it's because of the name clobber
20:00:35 <clmg> omg
20:00:36 <clmg> thanks
20:02:38 <monochrom> "The child that you named is not the real child" :)
20:04:01 <johnw> The name that can be named is not the Eternal Name.
20:18:09 <lpaste_> threshold pasted “Error in using Scotty” at http://lpaste.net/352847
20:19:44 <halogenandtoast> I need to learn to become better with Docker. My currently deployment strategy is rather archaic.
20:20:10 <threshold> Is it not possible to capture variables in a post with Scotty?
20:20:33 <halogenandtoast> Currently, I ssh in, pull down my git repo, run stack build, stop my webserver, and start it back up with nohup
20:20:39 <Koterpillar> threshold: post "..." $ do
20:20:59 <halogenandtoast> I wanted to use Halcyon, but couldn't figure it out.
20:21:09 <threshold> Koterpillar: That is what was used.
20:21:26 <Koterpillar> threshold: you are missing the $
20:23:18 <threshold> Koterpillar: Thanks. post "/users/:email/:pass" $ do -- still gives error: parse error on input ‘post’
20:23:55 <Koterpillar> hmm. It's still a syntax error, but I can't see where.
20:24:07 <Koterpillar> did you post the full code for main?
20:24:27 <Koterpillar> by the way, why do you need 'liftIO' in main? main is IO ()
20:24:46 <threshold> threshold: That is the only location where post is located
20:24:52 <threshold> Koterpillar* 
20:25:16 <Koterpillar> please post the full code for main
20:28:35 <spatial> Can gloss be installed using stack on Ubuntu ?
20:29:00 <spatial> After installation spacemacs is not finding it.
20:31:10 <lpaste_> threshold pasted “Simple Scotty App” at http://lpaste.net/352848
20:31:34 <threshold> Koterpillar: I have simplified the app to its core 
20:32:19 <threshold> I think the database connection information should be passed in as part of the 
20:32:35 <threshold> Scotty configuration, but I haven't made it to that step.
20:34:10 <Koterpillar> OK, so that's a different error
20:34:15 <Koterpillar> give createUser a type
20:35:19 <halogenandtoast> Basically because you don't use the params, Haskell can't infer the type.
20:38:56 <lpaste_> threshold pasted “New Error for simple Scotty application” at http://lpaste.net/352849
20:39:02 <spatial> Maybe stack and cabal use different paths
20:39:52 <threshold> I wonder what "Web.Scotty.Internal.Types.ActionT T.Text IO T.Text" represents.
20:40:01 <halogenandtoast> threshold: You might need to liftIO the connect call
20:40:07 <Koterpillar> threshold: liftIO createUser
20:40:19 <halogenandtoast> or sorry, yes, createUser
20:41:31 <threshold> :t liftIO
20:41:33 <lambdabot> MonadIO m => IO a -> m a
20:45:55 <lpaste_> threshold pasted “Scotty App take 3” at http://lpaste.net/352850
20:46:48 <Koterpillar> uid <- liftIO $ createUser email pass
20:47:05 <Koterpillar> when you have x <- y, and y :: m a, x :: a
20:55:22 <slack1256> anybody set up intero on nixos?
21:06:53 <threshold> The code error at post from earlier was due to accidentally using tabs.
21:07:28 <Welkin> threshold: burn it with fire
21:07:57 <threshold> Welkin: I wish I knew how to make vim convert tabs into spaces automatically on paste
21:08:36 <Koterpillar> hindent
21:12:45 <lpaste_> threshold pasted “Scotty App take 3” at http://lpaste.net/352851
21:14:08 <jle`> halogenandtoast: nobody really knows
21:15:34 <Koterpillar> threshold: I suggest you review the 'do' syntax
21:15:55 <Koterpillar> threshold: in particular, what the "let" and "<-" mean
21:17:50 <threshold> Koterpillar: I don't understand what is wrong wit the way they were used
21:18:49 <Koterpillar> main (well, the part inside post) is in the Scotty monad (the one you see as Web.Scotty.Internal.Types.ActionT T.Text IO T.Text)
21:19:17 <Koterpillar> so every "<-" action in the "do" must have the type Scotty a (for some a)
21:19:42 <Koterpillar> however, "createUser email" has the type of "Maybe [Text]"
21:20:10 <Koterpillar> if your createUser can really cope without IO (which I doubt), you can say "let user = createUser email" on that line.
21:20:54 <Koterpillar> But I think you'll find that the right type for it is T.Text -> IO (Maybe [T.Text]) (not sure why it returns multiple texts, but I hope you get the point).
21:24:07 <pikajude> i wonder what implementation of createUser could return Maybe [Text]
21:24:40 <Welkin> not Maybe User ?
21:34:18 <lpaste_> threshold pasted “Scotty take 5” at http://lpaste.net/352852
21:35:03 <Koterpillar> what is unclear now?
21:35:20 <Koterpillar> both type errors show you what you wrote vs. what you expected
21:37:46 <sshine> hi. I just did 'stack new foo simple' and then 'stack build', but I got "No compiler found, expected minor version match with ghc-8.0.2 (x86_64-tinfo6)", and the system GHC is rightfully 7.10.3. but how do I install 8.0.2 in my homedir so I don't have to keep a copy in my project dir? trying 'stack install ghc' in my homedir gives "The following package identifiers were not found in your indices: ghc-8.0.1
21:37:52 <sshine> "
21:38:06 <jle`> sshine: stack setup
21:38:26 <jle`> i feel like i remember this being mentioned in the error
21:38:30 <jle`> also remember to cd to 'foo'
21:39:00 <sshine> jle`, in my homedir that gives "For more information on paths, see 'stack path' and 'stack exec env'". you're right that 'stack setup' will install GHC 8.0.2 in my project dir. I can't seem to make it install 8.0.2 in my homedir.
21:39:22 <jle`> sshine: it wo'nt install ghc 8.0.2 in your project dir
21:40:03 <jle`> it doesn't put it there, actually
21:40:09 <kadoban> sshine: It installs it in its own private location that it knows to look.
21:40:19 <sshine> eh...
21:40:36 <sshine> looking at .stack/programs/x86_64-linux/ghc-tinfo6-8.0.2/bin.stack/programs/x86_64-linux/ghc-tinfo6-8.0.2/bin, I *have* 8.0.2. >_<
21:40:59 <sshine> I wonder why my local stack project doesn't recognize that.
21:41:09 <sshine> jle`, ohhh, ok.
21:41:20 <centril> I need to prove the following:  minOne :: Sing n -> Maybe ((n :> 0) :~: True)  , does anyone have some idea of how to do that?
21:41:20 <sshine> jle`, so that's what it just did. heh.
21:41:22 <jle`> stack build uses a ghc that it caches
21:41:38 <centril> n :: Nat
21:41:48 <sshine> jle`, kadoban: thanks!
21:41:49 <jle`> centril: where is :> from
21:42:05 <centril> jle`: https://hackage.haskell.org/package/singletons-2.2/docs/Data-Singletons-Prelude-Ord.html#t:SOrd
21:42:40 <centril> i.e:  I have to prove that an  SNat n is > 0, or >= 1
21:43:31 <centril> damn... dependent types is so much easier in Agda :/
21:44:24 <jle`> centril: you can use %:<, and pattern match on the resulting Sing
21:44:34 <pikajude> %:< looks like the best emoji ever
21:45:05 <jle`> ther'es the walrus in that lib too, %:<=
21:45:31 <centril> jle`: but i need to verify this at run time, not compile time
21:46:04 <centril> jle`: i.e: it has to produce a  Maybe
21:46:10 <jle`> centril: yeah, you can pattern match and return a Maybe
21:46:25 <Cooler> how do you write this? meh :: Monad m => [a] -> (a -> m b) -> m [b]
21:46:31 <jle`> case s %:< Snat @0 of
21:46:32 <threshold> Couldn't match expected type ‘T.Text’ with actual type ‘[Text]’ In the first argument of ‘html’, namely ‘uid’ In the expression: html uid
21:46:37 <jle`>     STrue -> Just Refl
21:46:39 <jle`>     SFalse -> Nothing
21:46:45 <centril> jle`: Oh, I see =)
21:46:53 <Koterpillar> Cooler: isn't that mapM/forM?
21:47:04 <jle`> Cooler: that looks like for, or yeah, forM
21:47:13 <Cooler> for?
21:47:15 <Koterpillar> threshold: right, uid :: [Text], html takes a single Text
21:47:17 <jle`> :t for
21:47:19 <lambdabot> (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
21:47:26 <jle`> ^ Cooler 
21:47:29 <Koterpillar> @src for
21:47:29 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
21:47:32 <threshold> I don't understand why Text and T.Text are different
21:47:45 <Koterpillar> threshold: they aren't, but [Text] and Text are
21:47:53 <threshold> Data.Text.Internal.Text is different from Data.Lazy.Text.Text?
21:47:58 <jle`> threshold: do you understand why Bool is differen than [Bool]
21:48:00 <kadoban> Well, they could be different. It could be the Lazy one vs the other one.
21:48:02 <threshold> Yes
21:48:10 <Cooler> jle`, that doesn't explain what it does
21:48:43 <jle`> Cooler: it maps the function over the items in [a] and collects the result
21:49:07 <Cooler> it takes the applicative context outside the traversable context
21:49:19 <jle`> i'm not sure what that is supposed to mean
21:49:26 <Cooler> looking at the type
21:49:32 <jle`> for :: Applicative f => [a] -> (a -> f b) -> f [b]
21:50:03 <threshold> If I remove import Data.Text.Internal (Text) and change createUser to createUser :: T.Text -> IO (Maybe [T.Text]) from createUser :: T.Text -> IO (Maybe [Text]) I receive Expected type: IO (Maybe [T.Text]) Actual type: IO (Maybe [Data.Text.Internal.Text])
21:50:08 <jle`> so it applies the (a -> f b) to every item in [a], sequentially, and then collects the results
21:50:19 <Cooler> so [a] -> (a -> Maybe b) -> Maybe [b]
21:50:20 <threshold> I think you all know what you're talking about, but it doesn't seem like the two are the same here.
21:50:37 <jle`> Cooler: yup, that would map the (a -> Maybe b) over every item and sequence it applicatively
21:50:40 <jle`> and collect the results
21:50:44 <jle`> > for [1,2,3] Just
21:50:47 <lambdabot>  Just [1,2,3]
21:50:56 <Koterpillar> threshold: [Text] is not Text
21:51:02 <jle`> > for [1,2,3] (\x -> if x == 3 then Nothing else Just x)
21:51:06 <lambdabot>  Nothing
21:51:09 <jle`> > for [1,2] (\x -> if x == 3 then Nothing else Just x)
21:51:10 <Koterpillar> threshold: createUser returns a list of Texts, but html expects one Text
21:51:12 <lambdabot>  Just [1,2]
21:51:22 <Koterpillar> threshold: this is in addition to whatever Lazy/Strict woes you have
21:52:34 <ongy> :t traverse
21:52:36 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
21:53:00 <jle`> Cooler: forM f [x,y,z] = do x' <- f x; y' <- f y; z' <- f z; return [x',y',z']
21:53:47 <threshold> Koterpillar: Along with that change, I get this error: Couldn't match expected type ‘[T.Text]’ with actual type ‘T.Text’
21:54:05 <threshold> In the first argument of ‘head’, namely ‘uid’ In the second argument of ‘($)’, namely ‘head uid’ In the expression: html $ head uid
21:54:40 <jle`> threshold: you're giving it a T.Text when it expects a [T.Text]
21:54:45 <Koterpillar> paste again?
21:55:03 <threshold> Is a struggle like this normal for beginners?
21:55:18 <threshold> Koterpillar: Okay.
21:55:40 <centril> jle`: I can't manage to get the type level 0...  http://paste2.org/enHcJmth  wont compile
21:55:51 <Koterpillar> threshold: I would suggest you to write out the types of all functions right away, like you _want_ them
21:56:14 <Koterpillar> for example, I'd have thought createUser would return a Maybe User (or IO (Maybe User))
21:56:28 <Koterpillar> and then you have to define User
21:56:46 <Koterpillar> Haskell can't really help you if you define everything to be Text
21:57:29 <Cooler> jle`, so you apply the a -> m b on x in (x:xs) then sequence that using >>= ?
21:57:30 <Koterpillar> Even a newtype UserId = UserId Int can help.
21:57:47 <Cooler> and recurse?
21:58:26 <Cooler> jle`, i need the de sugared version
21:58:47 <lpaste_> threshold pasted “Simple Scotty App take 6” at http://lpaste.net/352856
21:59:26 <threshold> Koterpillar: I don't know what I want, but I do know I want it work 
22:00:17 <Koterpillar> OK, so now we're down to lazy/strict text
22:00:44 <Koterpillar> remove .Lazy from your import?
22:00:45 <Cooler> :t (>>)
22:00:47 <lambdabot> Monad m => m a -> m b -> m b
22:01:33 <Cooler> i am confused about what this is doing meh :: Monad m => [a] -> (a -> m b) -> m [b]
22:01:58 <Cooler> its applying f to the first element of the list
22:01:59 <jle`> centril: what's the error
22:02:25 <jle`> Cooler: it's applying it to every element in the list
22:03:20 <Cooler> then its using some version of >>= :: m x -> (a -> m b) -> m b
22:03:35 <Cooler> to sequence it with the next application
22:03:35 <jle`> Cooler: the type signatures are similar yes
22:03:38 <centril> jle`: http://lpaste.net/352858
22:04:05 <centril> u = undefined
22:04:08 <Cooler> is that right?
22:04:08 <jle`> Cooler: what part are you confused about?
22:04:33 <Cooler> is it using  weirdBind :: m x -> (a -> m b) -> m b to sequence?
22:04:44 <lpaste_> threshold pasted “Simple Scotty App Error Lazy/Strict Text” at http://lpaste.net/352859
22:04:50 <Cooler> actually
22:05:03 <jle`> centril: why are you typing zero
22:05:05 <jle`> instead of 0
22:05:05 <threshold> Koterpillar: Sorry for just seeing your message. I actually had tried that and was staring at the error pasted above
22:05:10 <jle`> > 1 + zero
22:05:11 <Cooler> weirdBind :: m x -> (a -> m b) -> a -> m b
22:05:13 <lambdabot>  error:
22:05:13 <lambdabot>      • Variable not in scope: zero
22:05:13 <lambdabot>      • Perhaps you meant ‘mzero’ (imported from Control.Monad.Writer)
22:05:25 <jle`> in general, haskell doesn't recognize zero as 0
22:05:47 <centril> jle`: well, i tried 0, but it complained then as well
22:05:53 <jle`> what's the error?
22:05:59 <centril> sec
22:06:24 <Cooler> it seems like you need
22:06:25 <Cooler> weirdBind :: m x -> (a -> m b) -> a -> m b
22:06:40 <jle`> what do you need it for?
22:06:48 <centril> jle`: http://lpaste.net/352860
22:07:02 <Cooler> where your looking at the structure of m x and then using a instead of x
22:07:09 <Cooler> applying f to a
22:07:19 <centril> jle`: i need to construct a  Sized from a list which is at minimum of length 1
22:07:25 <jle`> centril: %:< takes two Sing's
22:07:27 <jle`> but you gave it 0
22:07:30 <jle`> give it a Sing
22:07:35 <jle`> like `SNat @0`
22:07:36 <threshold> Koterpillar: I didn't see your feedback about how to write out the functions with their expected domains/codomains. That feedback helps. A type of Maybe User might be something I can work toward 
22:07:46 <Cooler> here m x would be the result of the previous application of f to a
22:07:59 <jle`> Cooler: what are you trying to do?
22:08:09 <Cooler> meh :: Monad m => [a] -> (a -> m b) -> m [b]
22:08:17 <jle`> a good way to start wuld be by pattern matching
22:08:22 <jle`> meh [] _ = ???
22:08:26 <jle`> meh (x:xs) _ = ???
22:08:32 <jle`> er, meh (x:xs) f = ??
22:08:44 <centril> jle`: parse error on input `@'
22:08:52 <jle`> centril: turn on TypeApplications
22:09:45 <centril> jle`: where does the constructor SNat even come from ?
22:09:57 <Cooler> meh [1, 2, 3] f = weirdBind (weirdBind (f 1) f 2) f 3 ?
22:10:04 <Cooler> weirdBind :: m x -> (a -> m b) -> a -> m b
22:10:06 <Koterpillar> threshold: more types is good, you can always unify them later
22:10:10 <threshold> Koterpillar: It did return strict Text, but scotty's html function is expecting lazy Text
22:10:20 <jle`> Cooler: start from the skeleton i gave
22:10:30 <johnw> weirdBind, by its type, must be useless
22:10:34 <johnw> weirdBind _ = id
22:10:37 <pikajude> meh (x:xs) f = f x >>= \ x' -> (x':) <$> meh xs f
22:10:41 <jle`> centril: it's from Data.Singletons.TypeLits
22:10:51 <Cooler> johnw, why would it be useless?
22:10:55 <Koterpillar> threshold: there are toStrict and fromStrict if you are really confused
22:11:07 <jle`> Cooler: if you're trying to write your function, start from the skeleton i gave
22:11:07 <threshold> fromSTrict
22:11:25 <Cooler> jle`, no i am trying to figure out the semantics first
22:11:26 <threshold> Koterpillar: Sorry, I didn't see your message. Maybe this will fix it
22:11:35 <buttons840> is there any shorthand for something like: (\a -> a {b = c}) <$> x    ?
22:11:40 <Cooler> i am not sure i understand what it does
22:11:42 <jle`> Cooler: start with the implementation, then you can look at the semantics from there
22:11:51 <Koterpillar> buttons840: lens
22:11:54 <pikajude> did they update the hackage CSS?
22:11:58 <Koterpillar> buttons840: but it's a large library
22:12:02 <Cooler> jle`, i can't write it if i don't know what its supposed to do
22:12:05 <pikajude> doesn't look like type signatures are on a gray background anymore
22:12:19 <johnw> buttons840: that's pretty squarely in lens territory
22:12:28 <jle`> Cooler: apply f to every item in the list
22:12:32 <jle`> Cooler: and collect the results
22:12:34 <johnw> buttons840: x & b .~ c
22:12:41 <jle`> Cooler: let the types guide you :)
22:12:45 <jle`> meh [] f = ???
22:12:46 <Koterpillar> pikajude: that's up to the version of haddock that generated the documentation
22:12:58 <pikajude> Koterpillar: yeah, I'm just trying to figure out if it's my screen or not
22:13:00 <buttons840> Koterpillar: ok, I'll take a look at lense, I know it has quite a learning curve
22:13:04 <Cooler> jle`, thats how i got weirdBind
22:13:05 <centril> jle`: http://lpaste.net/352861  still doesnt work :/
22:13:06 <jle`> the result has to be m [b], but, what is the only way to make an m [b]?
22:13:21 <Koterpillar> pikajude: which package?
22:13:23 <jle`> Cooler: start from the skeleton; you don't need weirdbind
22:13:25 <buttons840> johnw: wouldn't it be: x <&> b .~ c ?
22:13:34 <pikajude> http://hackage.haskell.org/package/singletons-2.2/docs/Data-Singletons-TypeLits.html
22:13:36 <jle`> centril: well
22:13:36 <pikajude> Koterpillar: ^
22:13:38 <pikajude> very topical
22:13:38 <jle`> you need to import it...
22:13:39 <Cooler> jle`, you said let the types guide me, thats how i got weirdBind
22:13:43 <buttons840> johnw: & vs <&>
22:13:50 <pikajude> it looks like it's all black on white
22:13:57 <Koterpillar> pikajude: I see the gray background
22:14:00 <jle`> centril: it should give you an error for :~: too
22:14:04 <pikajude> really?
22:14:05 <johnw> buttons840: yeah, maybe so
22:14:06 <jle`> if you didn't import it
22:14:09 <centril> jle`: how? i've already done:  import Data.Singletons.TypeLits (SNat)
22:14:15 <centril> still, it complains
22:14:21 <buttons840> :t (<&>)
22:14:24 <lambdabot> Functor f => f a -> (a -> b) -> f b
22:14:33 <buttons840> :t &
22:14:35 <lambdabot> error: parse error on input ‘&’
22:15:03 <buttons840> johnw: would I need to use the full lense library for your example, or should i start with one of the lighter varients?
22:15:30 <Cooler> jle`, meh [] _ = []
22:15:34 <jle`> Cooler: almost
22:15:39 <johnw> buttons840: for what you asked, you could get away with a smaller variant
22:15:43 <Cooler> jle`, meh [] _ = return []
22:15:43 <pikajude> Koterpillar: it was my screen, thanks for checking
22:15:49 <jle`> Cooler: yup
22:15:50 <johnw> like lens-family-core, or whatever it's called
22:16:03 <jle`> centril: you'd want to import the constructor
22:16:31 <jle`> centril: import Data.Singletons.TypeLits (Sing(..)) should work
22:16:40 <jle`> or Sing(SNat) if you just want to import the SNat constructor
22:16:44 <centril> jle`: yay!
22:16:54 <centril> jle`: you are my hero <3
22:17:05 <jle`> haha congrats :)
22:17:19 <jle`> yeah, in Haskell, constructors have to be imported using Foo(MyConstr) syntax
22:17:24 <jle`> you can't import constructors nakedly
22:17:39 <centril> jle`: yeah, i just didnt realize that it belonged to Sing, and not SNat
22:18:06 <centril> type-naturals, singletons ==> crazy town
22:18:14 <jle`> i'm not really even sure what import ... (SNat) would do
22:18:34 <centril> import the type SNat
22:18:41 <jle`> oh yeah
22:18:42 <jle`> the type synonym
22:18:46 <lpaste_> threshold pasted “The simple Scotty App is almost there” at http://lpaste.net/352862
22:19:01 <jle`> it looks like SNat is a type synonym that Singletons exports
22:19:02 <jle`> kinda confusing
22:19:08 <centril> I tried  SNat (..), but i forgot that it is just a synonym
22:19:17 <centril> jle`: very confusing
22:19:25 <jle`> yeah, it's a bit confusing that they had the same name
22:19:35 <centril> jle`: i hope haskell gets proper dependent types soon, so we can get rid of all this hackery
22:19:41 <jle`> SNat(..) wouldn't help you either because SNat the type synonym is not related to SNat the constructor
22:19:51 <centril> yea =)
22:19:59 <threshold> Koterpillar: The paste above is directed at you, probably, since you have been helping me 
22:20:00 <centril> type synonyms dont have constructors anyways
22:20:08 <jle`> mhm
22:20:20 <johnw> I'm not entirely sure you want full dependent types in Haskell; they do make code harder to writer (which is the point), but sometimes it's more difficulty than it's worth
22:20:33 <jle`> SNat is a constructor for the 'Sing n' type, for (n :: Nat)
22:20:56 <johnw> the approach I'm taking is to make it easier to integrate Coq into Haskell development
22:21:02 <centril> jle`: yeah =)
22:21:58 <threshold> johnw: How do you go about that?
22:22:09 <Cooler> is meh something like this? http://lpaste.net/352863
22:22:47 <johnw> threshold: if we had a few hours at a café, I'd love to tell you all about it :)
22:22:52 <jle`> centril: kinda close, but (f x :) is the wrong type
22:22:56 <jle`> * Cooler 
22:23:00 <jle`> try using do notation
22:23:01 <Cooler> actually no that doesn't work
22:23:14 <jle`> meh (x:xs) = do
22:23:22 <jle`> * (x:xs) f = do
22:25:38 <Koterpillar> threshold: OK, now you've got to ask Scotty what's happening
22:26:25 <Koterpillar> threshold: "If parameter is found, but read fails to parse to the correct type, next is called. This means captures are somewhat typed, in that a route won't match if a correctly typed capture cannot be parsed." - is this it?
22:26:31 <johnw> anyone know why pokeArray N xs would be slower than an explicit recursion that repeatedly calls poke?
22:26:39 <Koterpillar> threshold: try removing the capture (:email) and hardcoding the email
22:27:49 <Cooler> is this it? http://lpaste.net/352864
22:28:13 <Cooler> it compiles
22:29:19 <kadoban> Cooler: Looks good to me
22:29:25 <johnw> Cooler: yep, that's it
22:29:50 <threshold> Koterpillar: post "/users" $ do { -- email <- param "email" ; result <- liftIO $ createUser "email" ... } -- results in the same <h1>404: File Not Found!</h1>
22:30:05 <Cooler> if i fmap f xs to get [m b]
22:30:10 <threshold> Koterpillar: Maybe I am not catching an error?
22:30:20 <Koterpillar> threshold: well, now you can't get email from param
22:30:22 <johnw> now, 'meh' has a name within the stdlib, so next question is, do you recognize it?
22:30:28 <Koterpillar> ah, wait
22:30:35 <Koterpillar> threshold: you have to POST, not GET
22:30:41 <threshold> Koterpillar: I realize what it was
22:30:41 <Cooler> then you go through the array doing b <- m b
22:30:47 <threshold> Koterpillar: I was getting insteading of posting
22:31:15 <Cooler> and combine all the bs and return bs
22:31:18 <threshold> Koterpillar: That did it!
22:31:34 <Koterpillar> yay!
22:32:07 <threshold> Koterpillar: Thank you for helping me. I will study why this works and ask questions again later. It feels as though my karma is too low to continue asking and not aiding others.
22:32:09 <Cooler> how does b <- m b work?
22:32:31 <threshold> Cooler: I believe <- is >>=
22:33:02 <Cooler> need the desugared version
22:33:22 <Koterpillar> Cooler: threshold: do { x1 <- y1; x2 <- y2; y3 } is the same as: y1 >>= \x1 -> y2 >>= \x2 -> y3
22:34:21 <threshold> f x >>= (\x -> ...  I think is equivalent to x <- m x -- but others here have my experience and are probably smarter
22:34:42 <threshold> I mean that others here have more experience
22:36:28 <Cooler> f x >>= (\b -> (meh xs f >>= (\bs -> return (b:bs))))
22:36:39 <johnw> f x >>= (\x -> ...) is equivalent to x <- fx; ...
22:36:44 <johnw> s/fx/f x
22:37:44 <mrkgnao1> I never tried writing out the instances for Free until today
22:37:56 <mrkgnao1> very educative 
22:37:58 <mrkgnao1> oh, no
22:38:28 <threshold> mrkgnao: What is it?
22:38:41 <threshold> mrkgnao: The suspense is killing me ;)
22:39:01 <Cooler> are the parens correct?
22:40:36 <jle`> Cooler: does it compile?
22:41:05 <threshold> Cooler: I believe so, but I don't know why you want (\bs -> return (b:bs) when meh already has return $ b:bs
22:42:39 <threshold> Is it okay to refer to the return type as the codomain or is that confusing?
22:45:35 <lookup> Hi
22:45:36 <johnw> the return type is the domain
22:45:47 <johnw> or am I up too late?
22:45:48 <mrkgnao> threshold: I meant my nick, haha
22:46:05 <johnw> sorry, co-domain is good
22:46:17 <mrkgnao> I spoke too soon, though. I'm trying to write (>>=) without looking.
22:46:21 <threshold> johnw: So it is confusing :)
22:46:36 <johnw> not having started out as a mathematician, I still get them confused
22:46:45 <Koterpillar> mrkgnao: for which type?
22:47:20 <threshold> johnw: I do too, but it would be nice to use these terms
22:47:53 <johnw> not two seconds ago I just edited a variable named "cod" that represented the return type of a function, so yes, it is too late
22:47:54 <johnw> good night :)
22:50:19 <threshold> johnw: I can't think of a term for the elements in the domain. Using spatial ordinal numbers plus the term "parameter" seems to be understandable by everyone, e.g. "This function takes two parameters, the first parameter is a list of Ints, the second parameter is a function, and the return type is also a list of Ints"
22:50:52 <threshold> johnw: Oh, sorry. I didn't realize you were going to bed. Thanks for your input!
22:54:02 <Cooler> when you have m a >>= (a -> m b) does m a get evaluated to weak head normal form so that >>= can pattern match?
22:55:08 <threshold> Cooler: That seems like a good guess
22:55:10 <athan> Cooler: Iff >>= is defined s.t. it needs the pattern match
22:55:21 <athan> the pattern-match induces the evaluation level
22:55:23 <threshold> s.t.?
22:55:27 <Cooler> right
22:55:30 <kadoban> such that
22:55:36 <athan> much wow
22:56:09 <Cooler> so what about IO a?
22:56:16 <athan> Cooler: So for the Identity monad, it only evaluates the Identity data constructor, because that's all that's matched
22:56:24 <athan> for Maybe, it could be Just or Nothing
22:56:52 <Cooler> are there patterns to match for IO a?
22:56:56 <athan> IO is tricky - it doesn't have a data representation (someone might call me out on this C:)
22:57:03 <phadej> Cooler: there are
22:57:15 <ReinH> it has one, but it's basically a lie
22:57:35 <phadej> the RealWorld# is a lie, but the IO as a state monad isn't :)
22:57:39 <threshold> > pure 3 :: IO Int
22:57:41 <lambdabot>  <IO Int>
22:57:52 <ReinH> phadej: unless you think the state contains something that isn't a lie
22:58:23 <threshold> > let x = pure 3 :: IO Int in case x of IO 3 -> putStrLn "3 detected"
22:58:26 <lambdabot>  error:
22:58:26 <lambdabot>      Not in scope: data constructor ‘IO’
22:58:26 <lambdabot>      Perhaps you meant ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trus...
22:58:34 <threshold> > let x = pure 3 :: IO Int in case x of IO 3 -> print "3 detected"
22:58:36 <lambdabot>  error:
22:58:37 <lambdabot>      Not in scope: data constructor ‘IO’
22:58:37 <lambdabot>      Perhaps you meant ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trus...
22:58:40 <phadej> (also IO uses unlifted tuple, so the `a` in IO a is forced to whnf in binds)
22:58:49 <threshold> lambdabot: What do you have in scope? :)
22:59:07 <ReinH> well, it doesn't have a nonexistent constructor in scope.
22:59:13 <threshold> :)
22:59:18 <phadej> the constructor is there: https://www.stackage.org/haddock/lts-8.2/ghc-prim-0.5.0.0/src/GHC-Types.html#IO
22:59:21 <threshold> I see that it fails in ghci as well
22:59:27 <phadej> import GHC.Types
22:59:36 <ReinH> ghc-prim is a lie
22:59:48 <phadej> ~an implementation detail
23:01:21 <ReinH> the implementation is... I think you get my point.
23:01:42 <lpaste_> threshold pasted “Attempt to pattern match on IO 3” at http://lpaste.net/352865
23:01:57 <athan> RealWorld# can't melt State beams
23:02:00 <phadej> well, if we had linear types, we could safely export IO constructor (and only keep RealWorld abstract)
23:03:48 <mrkgnao> Koterpillar (for when you come back): the Free monad on a functor
23:04:28 <Cooler> so does that mean you can't pattern match on IO?
23:04:44 <phadej> you can, but you don't need to
23:05:10 <phadej> (you'll get it wrong few first times anyway)
23:06:23 <threshold> As exemplified by my first attempt
23:07:16 <Cooler> how does the Monad instance of IO pattern match in the definition of >>=
23:07:18 <Cooler> ?
23:08:44 <phadej> https://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Base.html#bindIO
23:09:32 <threshold> phadej: It might be useful to know how to pattern match on IO, but I don' think I could figure it out tonight
23:09:44 <athan> oh woah I didn't know it was single threaded
23:09:49 <athan> is that how ST works too?
23:09:52 <fProgrammer> quick question: I'm trying to use a haskell library (https://github.com/haskell-works/kafka-client/)  and this is my stack.yml(http://lpaste.net/5184215642999357440). It builds fine, but I get warning from stack: "This is usually a mistake, external packages should typically be treated as extra-deps to avoid spurious test case failures."  what does this mean and how do I solve it?
23:10:42 <athan> fProgrammer: There's an `extra-dep: true` field you should use under the `packages:` section in your stack.yaml
23:10:43 <Cooler> well thats weird, they pretend like IO has a data constructor IO
23:10:55 <threshold> Is Template Haskell necessary to pattern match on IO?
23:11:07 <phadej> threshold: there is no template haskell
23:11:16 <athan> something like `packages:\n - foo:\ git: blahblahblah\n commit: !@$#\n extra-dep:true` or something
23:11:25 <phadej> threshold: there is UnboxedTuples
23:11:37 <threshold> phadej: (# new_s, a #) the (# and #) symbols represent unboxed tuples?
23:11:40 <phadej> yes
23:12:10 <fProgrammer> athan: Tried adding "- extra-dep: true"  under "packages:"  but it fails parsing stack.yaml: Error in $.packages[0]: failed to parse field 'packages': failed to parse field 'location': key "location" not present
23:12:14 <phadej> which are ~ StrictPair a b = SP !a !b
23:12:25 <athan> fProgrammer: It's a subfield for items in that list
23:12:30 <athan> not an item itself
23:12:33 <phadej> not 100% sure if those are the same, close enough
23:13:28 <Cooler> how does this work? bindIO (IO m) k = IO (\ s -> case m s of (# new_s, a #) -> unIO (k a) new_s)
23:13:40 <Cooler> can't pattern match on IO m
23:14:02 <athan> fProgrammer: Here's an example: https://github.com/moneybit/moneybit/blob/master/stack.yaml#L42
23:14:26 <threshold> phadej: Thank you for the explanation. I don't know how important it is for me to dive into boxed and unboxed types today. It does sound intriguing though 
23:15:25 <fProgrammer> athan: Tried this snippet: http://lpaste.net/5820708218350862336  I get following error "Error parsing targets: The project contains no local packages (packages not marked with 'extra-dep')"   
23:15:53 <fProgrammer> sorry, I realize it's something v trial but I can't seem to get it right
23:16:06 <threshold> athan: Why is it surprising that it is single threaded? I'm new, but I thought that it was linear/sequential and if you needed parallelism or concurrency, there are functions available. 
23:16:09 <athan> np, I've been there more than I'll admit :)
23:16:21 <athan> threshold: eh idk lol
23:16:26 <threshold> I do not know why I pointed out that I'm new
23:16:31 <athan> it just feels more like StateT than ST
23:16:45 <athan> (I don't know how ST works though v.v)
23:17:03 <kadoban> fProgrammer: add the line     - '.'    after "packages:" most likely
23:17:36 <threshold> athan: I haven't messed with monad transformers yet. I'm guessing it will be a bumpy ride
23:17:39 <athan> I think it just needs an indent :x
23:17:41 <phadej> athan: ST, IO and State are all variations on the same: https://www.stackage.org/haddock/lts-8.2/base-4.9.1.0/src/GHC-ST.html#ST
23:17:54 <athan> threshold: It's actually a lot of fun :) just higher-order monads
23:17:59 <athan> :O
23:18:03 <athan> thanks phadej 
23:18:20 <fProgrammer> kadoban: Yeah, it worked! Thanks! But now I am confused, why do I have to add "." i.e. a root directory?
23:18:32 <athan> fProgrammer: try indenting lines 2-5
23:18:37 <Cooler> anyone?
23:18:40 <phadej> athan: there is a special op in IO: fork# which let you tell the run-time-system "evaluate that part in parallel as well"
23:18:40 <threshold> athan: I struggle with knowing how to move values between monads. I've only started bumping into lift and liftIO
23:19:01 <kadoban> Well, it's presumably supposed to be building something with this package, right? You have to tell it where that is. Usually it's just "the current directory" aka '.'
23:19:17 <kadoban> extra-dep ones just tell it what stuff you want to use as a dependency, essentially.
23:19:17 <phadej> athan: you might look into https://www.youtube.com/watch?v=-MFk7PIKYsg
23:19:36 <athan> phadej: ahhhh that's how they do it :)
23:19:52 <athan> threshold: That's monad transformers :D
23:19:56 <phadej> which explains how haskell is evaluated, the threads are just having two simultaneous evaluators (IIRC it's briefly mentioned in the talk)
23:20:36 <phadej> athan: it's all not so complicated, you just have to click "source" in haddocks
23:20:40 <athan> oh sweet, I need to know more STG
23:20:55 <athan> yeah, but... gossip is so much easier :D
23:20:59 <athan> thanks phadej 
23:21:01 <phadej> np
23:21:32 <fProgrammer> athan: Thanks, I added "." and it worked, unsure why  ¯\_(ツ)_/¯
23:21:57 <athan> fProgrammer: hmm, I think it needs a target package or something, not just deps x_x
23:24:07 <kadoban> Ya, it does.
23:25:37 <lpaste_> threshold pasted “Monad Transformer Talk” at http://lpaste.net/352866
23:26:14 <threshold> If I set the return value to be "pure id" then it compiles successfully. 
23:27:15 <threshold> Is it possible to not use "pure id" and take the Maybe value and lift it into the monad used by Scotty?
23:27:47 <threshold> maybe that is what lift does :)
23:28:18 <Cale> threshold: What are you trying to do?
23:29:11 <threshold> Cale: I am simply looking to refactor
23:29:38 <Cale> Perhaps you meant to write  return id
23:29:56 <threshold> Cale: pure id and return id both work
23:30:09 <Cale> Yeah, because you need an IO action there.
23:30:29 <threshold> Cale: I am wondering if I can return id though and have it working by using something other than liftIO
23:30:47 <threshold> id has type Maybe [T.Text]
23:31:08 <Cale> (which btw, is really confusing naming for a Haskeller -- id is the identity function ;)
23:31:30 <threshold> Cale: Oh! That is a good point 
23:33:03 <Cale> This seems okay to me. If you want, you can move the liftIO into the definition of createUser and give it a more general type. I wouldn't worry about the difference too much until there are at least a few instances of it in your code though.
23:34:52 <Cale> But yeah, if you change it to   createUser email = liftIO $ do
23:35:19 <Cale> you can change the type to  createUser :: (MonadIO m) => T.Text -> m (Maybe [T.Text])
23:35:42 <Cale> and then you won't need the liftIO in main
23:36:20 <Cale> Also, you might find it more comfortable to add a line:  import Data.Text (Text)  so that you can write Text in the types rather than T.Text
23:37:39 <Cale> (though sometimes it's kind of nice to be emphatic about whether it's strict or lazy Text)
23:40:11 <lpaste_> threshold pasted “Scotty app: replace liftIO with lift, replace pure uid with uid createUser returns Maybe [T.Text]” at http://lpaste.net/352867
23:41:36 <threshold> Expected type: Web.Scotty.Internal.Types.ActionT L.Text IO [T.Text]
23:41:38 <threshold> Actual type: Web.Scotty.Internal.Types.ActionT L.Text Maybe [T.Text]
23:41:45 <threshold> That is close
23:43:15 <threshold> I don't understand why the line "result <- lift $ createUser email" has an expected type of Web.Scotty.Internal.Types.ActionT L.Text IO [T.Text]
23:46:38 <threshold> Cale: I don't know if you were around earlier, but it was working. This is me refactoring to make the types of createUser a little nicer
23:46:59 <threshold> Ultimately, I think it would be nice to return a User as suggested by Koterpillar
