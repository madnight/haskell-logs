00:00:41 <osa1> I'm looking at Oleg's Eff.hs, in the Trace effect he defines this runner: `runTrace :: Eff (Trace :> Void) w -> IO w` this forces me to run trace effect as the last thing, but what happens if I have other IO effects in my effect type? if ever IO effect requires to be run the last I can't run it at all, right?
00:01:53 <osa1> this file btw http://okmij.org/ftp/Haskell/extensible/Eff.hs
00:04:26 <mniip> ertes, so I'm thinking
00:04:31 <mniip> what makes a profunctor a functor
00:04:58 <mniip> if we have F(X', X), it is sufficient if F(-, X) is isomorphic to a constant functor
00:05:02 <mniip> but is it necessary
00:08:17 <osa1> huh, I think I managed to generalize runTrace
00:11:20 <osa1> nope, didn't work
00:17:46 <pppppp> I need help in sql injection
00:18:10 <pppppp> Is any one here
00:18:21 <mniip> this is #haskell
00:47:32 <lyxia> Looks like I found what I wanted. http://hackage.haskell.org/package/haskell-src-exts
01:02:39 <tsahyt> does anyone here have some experience with reactive-banana? I'm playing around with it and GTK and tried to do a simple application with two spinbuttons and a result field that should contain the sum of the values in the spinbuttons. http://sprunge.us/FLcF?haskell
01:02:57 <tsahyt> but what I've found is that it displays the sum of the values as they were in the previous frames instead
01:03:12 <tsahyt> so there's some lag going on, probably by my use of fromPoll
01:03:17 <tsahyt> what would be the right way to do this then?
01:04:09 <tsahyt> disregard the Num instance, I was just wondering whether that would make things a bit nicer syntactically. in real code I'd use applicative directly to avoid orphans
01:17:16 <zipper> Have you guys been having issues with `stack setup`?
01:47:05 <tsahyt> is there even any way to have a behavior represent the current value rather than one frame back?
01:47:22 <tsahyt> it seems like this is due to enabling recursion, but what if you don't need recursion in a situation
01:58:49 <tsahyt> alright I figured it out. at least one solution, using the changes function to trigger an event on changes of the behavior
02:35:53 <winny> my type signature isn't correct, what should it be instead? https://gist.github.com/8612a7597673473cf62643c95ca8052e
02:37:42 <tsahyt> winny: median :: Num a => a is what you wanted to write
02:37:57 <tsahyt> but that's not gonna be enough, because (/) is not part of the Num typeclass
02:38:13 <mniip> winny, that function seems broken
02:38:29 <tsahyt> the last pattern match is incorrect
02:39:08 <winny> yeah probably pretty broken, i'm pretty novice with haskell
02:39:28 <dramforever> It's unclear what you want to do
02:39:49 <dramforever> Your function is nothing like the 'median' I learned in school :P
02:40:01 <winny> :)
02:40:07 <winny> how did you learn in school?
02:40:13 <dramforever> What
02:40:23 <dramforever> median is a statistics thing right?
02:40:39 <piyush-kurur> I just wanted to ask how you perform releases. Immediately after a release do you update the version number or do you keep it till you are in the stage where you plan to make the next release
02:40:51 <piyush-kurur> ?
02:41:26 <mniip> piyush-kurur, well you have to push something to hackage
02:42:33 <piyush-kurur> mniip: after you upload the hackage I mean. Do you continue to keep the version number in the cabal file (in the git repository) till you are ready for the next release 
02:42:49 <tsahyt> I do it that way, yes. although I also have no packages on hackage atm
02:43:13 <mniip> I don't have many packages personally, but that seems to be common
02:43:36 <piyush-kurur> mniip: to clarify, immediate bump of version
02:43:40 <tsahyt> that way I can have a commit like "bump version to A.B.C.D" with just the version change, and use that as the tag in git.
02:44:15 <tsahyt> if it's the last thing in the commit history that has changed up to the release, the git tag certainly matches, and any users that might want to check out the code can find it quickly
02:44:31 <mangobot> can anyone help, why am i getting the following error here: http://lpaste.net/352362 , heres the error: http://lpaste.net/352363
02:44:41 <winny> So tsahyt i want Fractional?
02:44:56 <tsahyt> winny: if you want (/) then yes
02:44:58 <mangobot> i understand thats its due to the arguments, but dont get why
02:45:17 <tsahyt> winny: that will automatically imply Num, because of how Fractional is defined
02:45:20 <mniip> mangobot, show returns a string
02:45:29 <winny> so i want something like Fractional a => [a] -> a ?
02:45:46 <tsahyt> yes
02:46:48 <winny> somebody mentioned my last pattern is not correct
02:47:04 <mangobot> mniip so i need to define an alterntive function to print that result?
02:47:18 <piyush-kurur> tsahyt: thanks is that a common style of releasing?
02:47:30 <mniip> mangobot, you claim to return [String] from parseFEN
02:47:32 <mniip> but you return String
02:47:53 <mangobot> mniip well i want to parse that string into [String]
02:48:07 <mniip> that's not what show does
02:48:16 <piyush-kurur> For example how do you know in the next release would you be making an breaking changes (which means bumping the A.B according to PVP)
02:48:40 <piyush-kurur> I am talking about packages in the initial stage of API stabilisation
02:48:48 <mangobot> mniip ok thanks
02:49:47 <mangobot> mniip any tips how can i print that list out? print doesnt work either
02:49:57 <mangobot> putStrLn?
02:50:06 <mniip> what are you trying to do
02:50:25 <mniip> parseFEN sounds like it should be parsing something
02:50:32 <mniip> that's not where you'd put "printing that list out"
02:51:07 <tsahyt> piyush-kurur: tbh I never bothered to check, it's just a natural way to do it in my mind.
02:51:18 <mangobot> mniip eventually i need to parse that string into [String] or ideally [[String]] and then parse each list for different purposes (board state, player color, move) so i want to check if that actually works in this test module 
02:51:22 <tsahyt> you could just look around some repositories and see how different maintainers do it
02:51:35 <mangobot> mniip so i need a separate function to print it out?
02:51:37 <mniip> mangobot, do it with ghci
02:51:40 <mniip> or main
02:51:56 <mniip> you can't "debug printf" inside functions like that, not in haskell
02:52:03 <mniip> well  you can but it's an entirely different story
02:52:11 <mangobot> mniip what would i write in the Predule if using ghci 
02:52:22 <tsahyt> reminds me that I need to get rid of a myriad of trace statement that I've accumulated over the last two days...
02:52:23 <mniip> well,
02:52:29 <mniip> just call 'parseFEN' from ghci
02:56:14 <mangobot> mniip it says its not in scope ? 
02:57:21 <mangobot> mniip ok it works, thanks fr the tip
03:05:15 <mangobot> if i use ghci, and then change the content of the hs file, do i need to quit and then call gchi again or can i compile it again without quiting?
03:05:18 <mangobot> make doesnt work
03:05:43 <cocreature> mangobot: :r
03:06:12 <systadmin> How do I print out the output of a variable?
03:06:27 <cocreature> systadmin: what is the output of a variable supposed to be?
03:06:34 <cocreature> :t print
03:06:36 <lambdabot> Show a => a -> IO ()
03:06:41 <systadmin> cocreature: a number
03:06:42 <cocreature> systadmin: maybe that’s what you’re looking for
03:08:05 <systadmin> http://sprunge.us/ZbhF?haskell this is the code
03:08:44 <mangobot> cocreature thanks!
03:08:55 <cocreature> systadmin: "print" should work
03:09:54 <systadmin> `print` followed by the variable?
03:10:01 <cocreature> yep
03:11:26 <systadmin> okay thanks!
03:11:48 <cocreature> systadmin: print is just putStrLn . show
03:13:19 <systadmin> Okay, I'm done with my code :D http://sprunge.us/OcOL?haskell
03:18:02 <mangobot> why does this work http://lpaste.net/352363 but when i use String-> [[String]] ghc says Couldn't match type ‘Char’ with ‘[Char]’     Expected type: [String]       Actual type: [Char]     In the first argument of ‘splitOn’, namely ‘" "’     In the expression: (splitOn " " str)     In an equation for ‘parseFEN’: parseFEN str = (splitOn " " str)
03:19:43 <cocreature> mangobot: because it’s the wrong type? I don’t think I understood your question. you already seem to have figured out the correct type and just using another type isn’t going to work
03:20:07 <cocreature> [[String]] also doesn’t make a lot of sense. why should splitOn return a nested list?
03:21:27 <mangobot> cocreature ok i see, i thought i can change the type as i wanted to get [[string]]
03:21:47 <cocreature> mangobot: what do you expect splitOn to return in that case?
03:22:20 <mangobot> cocreature a list of lists split on " " ?
03:22:54 <cocreature> mangobot: you are giving it a single string, and you are splitting on " ". how do you expect to end up with a list of list of strings instead of only a list of strings?
03:24:26 <mangobot> cocreature so it cant split the string into lists but only a list ? i thought the same way it would split the string into a list of those strings but instead strings it would create lists
03:25:23 <cocreature> mangobot: let’s take a concrete example, you are calling 'parseFEN "first second third"' and you want to get a [[String]] out of it. what is the exact result you expect?
03:25:49 <mangobot> cocreature [[b,b,b][b]]
03:26:27 <cocreature> mangobot: what? where do you get b from? parseFEN "first second third" is the same as splitOn " " "first second third"
03:27:32 <mangobot> cocreature ah i thought of the string from the code. well then [[first][second][third]]
03:27:56 <cocreature> mangobot: so you just want to wrap each word in a single item list?
03:28:06 <mangobot> cocreature yeah
03:28:18 <mangobot> and then parse those lists seperatly with different functions
03:28:26 <cocreature> mangobot: in that case you can first call splitOn and then "map (\x -> [x])" over the result
03:29:09 <mangobot> cocreature in the same function=
03:29:10 <mangobot> ?
03:29:38 <cocreature> mangobot: sure, e.g. parseFEN str = map (\x -> [x]) (splitOn " " str)
03:30:13 <mangobot> cocreature ah awesome, thanks a lot
03:30:36 <mangobot> cocreature and if i want to access each list i use !! 0 , !! 1 etc?
03:31:36 <cocreature> mangobot: yep but usually lists are the wrong data structure if you want to do random access. accessing the nth element of a list requires scanning through the whole list before that element
03:32:24 <mangobot> cocreature the idea is to parse a string like "b,b,b,b w a3-c4" into a gamestate, player and move, so ithought i culd then apply the differnt functions ot each lists depending on the purpose
03:32:37 <mangobot> like to find the cooardinates for the next move etc
04:07:23 <AndreasK> Are there cases where its better to manually use a case instead of fromMaybe?
04:11:36 <reactormonk> AndreasK, then you can also use a `maybe`.
04:12:30 <AndreasK> It's not my code and the linter was complaining, just wondering if anyone could think of a reason if changed case to fromMaybe there could break something
04:12:40 <AndreasK> Besides the unreadability ... :D
04:19:52 <cocreature> AndreasK: theoretically, if fromMaybe wasn’t inlined the performance could be worse. but I would expect GHC to always inline this
04:21:58 <monad-mad> Hey guys
04:22:06 <monad-mad> a little help
04:23:31 <monad-mad> guys
04:23:35 <monad-mad> gais
04:23:38 <monad-mad> there?
04:23:43 <cocreature> monad-mad: just ask your question directly :)
04:23:57 <monad-mad> ok
04:24:04 <monad-mad> foo :: Maybe String   foo = do       x <- Just 3       y <- Just "!"       Just (show x ++ y)
04:24:18 <monad-mad> sorry for weird formatting
04:24:47 <cocreature> @where lpaste
04:24:47 <lambdabot> http://lpaste.net/
04:24:51 <cocreature> you can paste your code there
04:25:15 <monad-mad> doing that
04:25:23 <monad-mad> anyway
04:25:33 <monad-mad> the last Just (x ++ y)
04:25:41 <monad-mad> can it be show x++y
04:25:47 <monad-mad> as i understand
04:26:01 <monad-mad> the last line is going to be returned
04:26:16 <cocreature> you are using do notation for Maybe so the last line has to be of type Maybe a
04:26:23 <cocreature> show x ++ y is of type String
04:26:27 <monad-mad> and return will convert show x ++ y into Just (show x ++ y)
04:26:40 <monad-mad> oh, so the last line is not automatically returned?
04:26:57 <monad-mad> I could do return (show x++y) can't I?
04:27:06 <cocreature> yes
04:27:17 <cocreature> but "return" is different from the return statement found in other languages
04:27:24 <cocreature> it’s just an ordinary function
04:27:25 <monad-mad> http://lpaste.net/352365
04:27:26 <cocreature> :t return
04:27:29 <lambdabot> Monad m => a -> m a
04:27:30 <monad-mad> I know, I know
04:28:02 <monad-mad> in the Maybe monad , return x is defined as Just x
04:28:20 <cocreature> "return" it is not automagically inserted in the last line of a do block
04:29:07 <reactormonk> Not sure why it's called return, "lift" or "point" would have been a bit better, because distinct naming.
04:29:16 <mangobot> parser :: String -> [Figure] -> Int -> Int -> [Figure] means that the function takes a string returning a function that takes a figure int int and returns a figure?
04:29:25 <monad-mad> I understand how return works in haskell
04:29:38 <monad-mad> http://lpaste.net/352367
04:29:47 <monad-mad> the last line in that, calls return x
04:30:09 <monad-mad> which calls Maybe monad's return x, which is Just x
04:30:16 <cocreature> monad-mad: so what exactly is your question? return is not automatically inserted if that’s what you’re asking
04:30:54 <monad-mad> in the first code, I do return (show x++y) instead of Just (show x++y)
04:31:02 <monad-mad> It is correct, right
04:31:09 <cocreature> yep
04:31:13 <monad-mad> as return will convert it into Maybe
04:31:24 <monad-mad> Ok, thanks
04:31:31 <monad-mad> now my 2nd question
04:31:40 <monad-mad> what if I do return Nothing
04:31:46 <monad-mad> in the last line
04:31:59 <monad-mad> return x = Just x
04:32:09 <cocreature> monad-mad: then your do block has type "Maybe (Maybe a)"
04:32:39 <monad-mad> will result in an error then right
04:33:24 <cocreature> mangobot: not quite it means that parser is a function that takes a String and returns a function that takes a [Figure] and returns a function that takes an Int and returns a function that takes an Int and returns [Figure]
04:33:43 <cocreature> monad-mad: yep because your type signature says that it should have type Maybe Char
04:34:03 <monad-mad> thanks cocreature
04:35:08 <monad-mad> I am almost done with learnyouahaskell, can you suggest some other tutorials or blogs to help me
04:36:05 <monad-mad> \me is indebted to cocreature
04:36:14 <dramforever> https://github.com/bitemyapp/learnhaskell
04:36:21 * monad-mad is indebted to cocreature
04:36:52 <dramforever> That's basically THE beginner's free resource list
04:37:51 <monad-mad> thanks
04:39:13 <monad-mad> monads monoids applicatives and functors
04:39:46 <monad-mad> that's basically it right, in terms of mathematics 
04:40:28 <monad-mad> If I can leverage these + know the basic syntax and semantics I am good to go right
04:40:29 <dramforever> You're oversimplifying
04:40:52 <dramforever> TBH these *are* basic syntax and semantics
04:41:15 <monad-mad> I was talking about pattern matching, let etc.
04:41:37 <dramforever> umm, you *don't* know what these are right?
04:42:10 <dramforever> Just go. Rest assured that you're good to go.
04:42:19 <monad-mad> I am currently done with the basics + everyting upto monads
04:42:40 <monad-mad> and with you guys' help I am pretty confident with monads too
04:42:41 <warrshrike> hey guys
04:42:54 <warrshrike> im doing a sudoku solver thing
04:43:10 <boccato> When I do "stack ghci" outside a project. To load a package, should I install it globally?
04:43:26 <cocreature> monad-mad: at this point I would recommend to just write some code and pick the rest up along the way. practise is important.
04:43:56 <reactormonk> warrshrike, there's an implementation in dpkg, if you're looking for one. :-P
04:43:59 <dramforever> Just, kinda try to remember monad isn't really much
04:44:34 <warrshrike> reactormonk: thanks buddy but I seek to Learn and Gain Enlightenment
04:44:34 <monad-mad> Yeah, that's what I thought. I like to be well versed in the basics *before* writing code
04:44:39 <warrshrike>  Part 1: Implement the sudoku solver that takes a board and returns a -- solved board.  Assume that a solution always exists.  Use toElements,  -- fromElements, and sudokuElements functions described below. sudoku :: Board -> Board sudoku b      | b == inputBoard = solvedBoard     | otherwise = error "sudoku not implemented"
04:44:52 <warrshrike> Im having some trouble getting what his is saying
04:45:00 <dramforever> monad-mad: Well I guess you should interleave learning <-> coding
04:45:06 <cocreature> monad-mad: becoming well-versed in the basics without writing code is going to be hard :)
04:45:06 <monad-mad> warrshrike: http://lpaste.net/new/haskell
04:45:27 <warrshrike> is it saying i should i assume those function exist and just give solution like that?
04:45:38 <warrshrike> monad-mad: sorry...will use next time :)
04:45:51 <warrshrike> because the next task it to implement those functions
04:45:53 <dramforever> warrshrike: it means that the given board is not contradictory
04:46:12 <warrshrike> dramforever: I meant this part Use toElements,  -- fromElements, and sudokuElements functions described below.
04:46:16 <monad-mad> I am doing simple bits of code as I am learning. I was talking about small projects
04:46:32 <dramforever> monad-mad: That's about right?
04:46:54 <warrshrike> Do I assume they exist now? And then as I implement them later i can test?
04:47:05 <dramforever> Sounds about right
04:47:19 <warrshrike> ah...alright tho it sounds about a 
04:47:26 <warrshrike> backwards way of doing things ~_~
04:47:48 <monad-mad> dramforever: yeah
04:48:19 <monad-mad> dramforever: I do things a little different, just like haskell :D
04:48:32 <dramforever> TBH I don't I think I can write a sudoku solver without basic utilities already in place...
04:48:52 <warrshrike> Brothers. A man abused me and asked me to learn clojure instead as it is so much better
04:49:01 <dramforever> Aaand lpaste is down :(
04:49:02 <warrshrike> it was an experienced and well respected man 
04:49:21 <dramforever> Oh wait it's not. Ignore that
04:49:22 <warrshrike> from the valley. Can you guys tell me why he might he say that? IS there any advantage?
04:49:36 <cocreature> dramforever: is a sat solver included in “basic utilities”? :)
04:49:51 <monad-mad> warrshrike: clojure is good if you come from Java or wanna go to LISP
04:50:09 <dramforever> cocreature: 'toElements' and 'fromElements' sound like basic input conversion
04:50:39 <dramforever> Well I guess perhaps clojure has a larger community?
04:51:00 <monad-mad> warrshrike: interop with Java, is a biggie
04:51:04 <dramforever> Like LISPers can do clojure, and there's the JVM behind it or something
04:51:12 <warrshrike> can you guys actually implement this sudoku for me? I imagine it wouldn't take more than a few minute and I would LOVE a stock solution to compare myself against
04:51:18 <dramforever> Haskell is just heck too different
04:51:40 <warrshrike> Hmmm...are you saying haskell will be difficult to use as an 'every day lang'
04:51:48 <warrshrike> :/
04:52:12 <dramforever> I said *different*
04:52:14 <mangobot> cocreature can i ask one more question? if in this function http://lpaste.net/352363 id like to further parse the board string seperatly into positions in order to find the coordinates on the field, i just write the name of that function that does it in the parseResult function? haskell will know that the first list = board?
04:52:24 <monad-mad> I enjoy writing haskell, so it is not difficult for mw
04:52:34 <warrshrike> Like I typically use ruby whenever I need to do some quick shit or sth like that...scripts and competitive programming and the like
04:52:46 <reactormonk> warrshrike, there's a reason that stackoverflow has a high difference between haskell posts during the week and weekend. Don't let that discourage you. I also started with ruby :-)
04:52:51 <monad-mad> a fellow ruby user, :D
04:53:10 <reactormonk> I haven't written any ruby in the last few years though.
04:53:10 <monad-mad> coming from ruby, haskell is much more simple for me
04:53:32 <warrshrike> monad-mad: yeah srsly...in ruby you can literally rape classes at run time
04:53:47 <warrshrike> it can lead to confusion and less clarity while still not being too expressive
04:53:49 <reactormonk> warrshrike, heh, ever done template haskell? ^^
04:53:56 <monad-mad> I do C# too, so learning F# after haskell will help me become more productive
04:54:04 <dramforever> It's different enough that so-called language agnostic algorithm descriptions don't suit Haskell well :(
04:54:05 <warrshrike> reactormonk: I'm still a 'askell rookie good sir
04:54:27 <kgadek> dramforever: "language agnostic algorithm"? whoah
04:54:37 <cocreature> mangobot: sry I’m busy right now, but maybe someone else can help you
04:54:44 <reactormonk> warrshrike, it's +/- macro haskell, for metaprogramming. A tiny bit more advanced.
04:54:56 <AWizzArd> I want to produce an IO Int via   read <$> getLine   - is   (\x -> read x :: Int) <$> getLine   the right way to do it?
04:55:00 <monad-mad> warrshrike: exactly, I feel that haskell gives me that same flexibility ruby gave me
04:55:07 <dramforever> kgadek: I don't believe them
04:55:14 <kgadek> ;D
04:55:27 <dramforever> But algorithm books often write pseudo-code thing and they claim that it's language agnostic
04:55:32 <dramforever> It's all bs
04:55:54 <monad-mad> haskell is more mathematical, innit?
04:56:07 <warrshrike> monad-mad: Yup. So basically haskell is more mistress than wife. Good for fun and shit and side projects but not like every day job-y stuff
04:56:09 <monad-mad> so converting maths to code will work
04:56:11 <kgadek> dramforever: well, there was a point in my life when I though "ok, I know $n languages, no new language will be a challenge to me"
04:56:14 <dramforever> uh, I mean the 'language agnostic' part is bullshit
04:56:32 <kgadek> then I've learned that beyond syntactical differences there are other
04:56:42 <kgadek> like: FP, immutability, laziness
04:57:03 <monad-mad> the books write in some form of pascal, it is OO language agnostic
04:57:12 <monad-mad> never language agnostic
04:57:22 <dramforever> kgadek: You've heard people claiming things like a programmer should be able to learn the basics of any PL in a day
04:57:25 <dramforever> right?
04:57:34 <kgadek> dramforever: something like that, yes
04:57:38 <mangobot> if in this function http://lpaste.net/352363 id like to further parse the board string seperatly into positions in order to find the coordinates on the field, i just write the name of that function that does it in the parseResult function? haskell will know that the first list = board?
04:57:43 <dramforever> like all PLs are different but just minor syntactic differences
04:57:48 <monad-mad> dramforever: wait, really?
04:57:55 <dramforever> monad-mad: bs
04:57:57 <kgadek> dramforever: exactly, that's what it was :D
04:57:59 <dramforever> they need to see Haskell
04:58:05 <kgadek> dramforever: then I've learned common lisp
04:58:07 <monad-mad> dramforever: C to Haskell or LISP in a day
04:58:09 <kgadek> and my world never looked the same
04:58:16 <monad-mad> I challenge anyone
04:58:25 <kgadek> then was Erlang, then was OCaml, then was Haskell
04:58:27 <kgadek> oh boy
04:58:29 <dramforever> monad-mad: Welcome to Haskell. Have your nice one day heree
04:58:30 <dramforever> *here
04:58:35 <warrshrike> Ocaml was a good 'un
04:58:44 <warrshrike> like a one night stand it was goof un
04:58:50 <warrshrike> fun*
04:59:18 <warrshrike> how are the standard libs for haskell? are they at least as good as stl  for cpp?
04:59:33 <monad-mad> dramforever: It took me a week to get to novice level in haskell. I was saying that in a day, is impossible
04:59:37 <dramforever> mangobot: I didn't really get your English description, but line 6 looks about right
04:59:43 <dramforever> monad-mad: yeah
05:00:01 <monad-mad> dramforever: what was that bs for?
05:00:14 <dramforever> the 'one-day myth'
05:00:22 <monad-mad> yeah
05:00:27 <kgadek> dramforever, monad-mad: well, sometimes it's true. Like golang
05:00:34 <kgadek> gosh, this is such a boring language
05:00:35 <warrshrike> mangobot: what are you trying to make?
05:00:37 <dramforever> mangobot: You can just write [board, color] for that, Haskell will know :)
05:00:47 <kgadek> (though I have to admit, it's beautiful in terms of engineering)
05:00:51 <dramforever> kgadek: That's not how 'any' works
05:01:10 <dramforever> golang is an amazing language tbh
05:01:11 <kgadek> yes, I precisely used 'exists', not 'forall'
05:01:20 <monad-mad> kgadek: if the paradigm is same
05:01:26 <dramforever> not too low-level, very fast
05:01:29 <mangobot> warrshrike im trying to parse that string1 with b,b,b,.. into positions in order to find out each players coordinates on the board
05:01:35 <kgadek> dramforever: well, my first encounter with golang was with FFI with C
05:01:41 <kgadek> that was pure beauty
05:01:43 <kgadek> srsly
05:01:46 <kgadek> import "C"
05:01:54 <warrshrike> mangobot: cool. I mean what board game is this?
05:02:03 <dramforever> kgadek: what's the C part like?
05:02:05 <dramforever> regular C?
05:02:09 <mangobot> warrshrike pjb.com.au/laska/play_laska.html
05:02:17 <kgadek> FFI looks like this:
05:02:21 <kgadek> import "C"
05:02:22 <monad-mad> kgadek: have you done elixir?
05:02:25 <kgadek> / arbitrary C statement
05:02:33 <kgadek>  import "C"
05:02:34 <kgadek>  // arbitrary C statement
05:02:35 <mangobot> warrshrike http://pjb.com.au/laska/play_laska.html
05:02:36 <dramforever> Oh god
05:02:46 <warrshrike> mangobot: cool cool
05:02:51 <dramforever> That looks even better than Haskell's
05:02:59 <kgadek> yes, and it just works
05:03:01 <dramforever> but Haskell's sure suits Haskell better :P
05:03:05 <kgadek> I did #import <stdlib.h>
05:03:11 <kgadek> then I could call anything 
05:03:14 <kgadek> the same for my libs
05:03:23 <kgadek> that is just engineering beauty
05:03:40 <kgadek> monad-mad: no, I didn't "yet
05:04:01 <kgadek> though I don't find the Erlang syntax "bad" so…
05:04:12 <kgadek> …that's probably the reason I didn't pursue elixir too much
05:05:20 <monad-mad> kgadek: erlang vs haskell. where do you use one over the other?
05:05:37 <kgadek> monad-mad: haven't used erlang for quite a while
05:05:42 <monad-mad> I wanted to learn erlang instead of haskell, for elixir's sake
05:05:52 <kgadek> though I would say, that Erlang is more battle tested
05:05:56 <monad-mad> but then I fell in love with Monads
05:06:17 <kgadek> well, Erlang is different in terms of "safety"
05:06:29 <kgadek> in Haskell (or cloud-haskell for this matter) you have typechecker
05:06:35 <monad-mad> I watched a video about monads in ruby and was captivated with them
05:06:42 <kgadek> in Erlang you don't care too much, you just pattern match and embrace failure
05:06:46 <monad-mad> so I said, to haskell we go
05:06:52 <kgadek> both are nice
05:07:07 <kgadek> but I know that Erlang had some really amazing stories regarding uptime
05:07:23 <monad-mad> similar? like C# and Java similar?
05:07:23 <kgadek> so if I would have to create system with high uptime (many 9's)
05:07:42 <kgadek> I would probably use Erlang
05:08:08 <kgadek> because their VM is older, because it has been tested so thoroughly in so many places
05:08:17 <kgadek> because their 'behaviours' are amazing
05:08:29 <monad-mad> Oh, College kid here, so no scalable creations in functional languages any time soon
05:08:50 <monad-mad> Haskell seems more fun tho
05:09:19 <kgadek> "fun" :D
05:09:48 <monad-mad> kgadek: My brain hurt a lot learning haskell
05:10:00 <kgadek> me too, that's why I love it :D
05:10:05 <kgadek> Haskell
05:10:08 <kgadek> the BDSM of languages
05:10:11 <monad-mad> and the last time that happened was learning C# reflections
05:10:25 <monad-mad> and more advanced C#
05:10:43 <monad-mad> and even C pointers when I was a complete newbie
05:11:08 <monad-mad> The languages I like fuck with my head a lot
05:11:18 <monad-mad> even ruby metaprogramming is crazy
05:11:29 <monad-mad> and I love all these languages
05:12:18 <monad-mad> Want to go into language design in future, so Haskell seems like a good choice to get my feet wet with functional concepts
05:14:32 <thoradam> Reading the source for PureScript is also fun for that ^_^
05:15:25 <monad-mad> thoradam: there is a difference between masochism and self harm
05:15:28 <monad-mad> :P
05:15:32 <thoradam> Haha
05:15:51 <monad-mad> Javascript is the only language I truly hate
05:16:31 <reactormonk> monad-mad, no hate here, just pity.
05:16:37 <thoradam> Well that's the why of PS hehe
05:16:56 <monad-mad>  reactormonk pity is reserved for php
05:17:17 <thoradam> There's also http://dev.stephendiehl.com/fun/
05:17:34 <monad-mad> thoradam: PS hello world looks like applicative functors
05:17:40 <monad-mad> what is up with that?
05:18:10 <thoradam> Hmm, the Flare thing on the homepage?
05:18:52 <monad-mad> thoradam: ooh writing haskell, noice
05:19:10 <monad-mad> yes the Flare thing
05:19:19 <thoradam> It generates html :)
05:19:21 <monad-mad> looks like applicative functors no
05:20:23 <monad-mad> wait a minute, purescript is haskell for js. Ohh
05:20:40 <monad-mad> I felt it was like typescript or something
05:20:44 <monad-mad> this is weird
05:20:53 <thoradam> Yup :D
05:21:51 <monad-mad> The people behind it must have nerves of steel
05:24:06 <thoradam> Well it's strict like JS, I only mention it because it's fairly new so the compiler doesn't have a lot of baggage if you're interested in getting into that
05:26:17 <warrshrike> More Dumb Questions: does anyone use haskell competitively? i was just wondering why...the top 200 are always using c++/c
05:29:06 <warrshrike> also is stack good for using haskell on windows?
05:29:57 <warrshrike> https://docs.haskellstack.org/en/stable/install_and_upgrade/#windows
05:30:09 <mangobot> mm can someone give me a tip maybe, im a little clueless here.. http://lpaste.net/352363 how would one go in order to find the position of each figure on the board which is represented by that fen string? so if its b its black, but how can i find out the coordinates just with the string?
06:11:56 <kgadek> hmm, anyone mind helping a bit with performance? I stumbled upon this thread about hashtable performance http://stackoverflow.com/q/3058529/547223
06:12:03 <kgadek> wanted to try it out with GHC 8.0.2
06:12:09 <kgadek> and I'm dissatisfied :<
06:12:29 <kgadek> OCaml runs in ~4.4s
06:12:35 <kgadek> GHC in ~16
06:13:01 <kgadek> (gimme sec)
06:14:37 <kgadek> https://gist.github.com/kgadek/515e9c36bc79706cba3f5dcdc350fcbe
06:15:18 <kgadek> ideas?
06:19:16 <AndreasK> kgadek: What hashtable implementation are you using?
06:19:47 <AndreasK> kgadek: I think the standard is to use these from unordered-containers
06:19:51 <kgadek> hashtables-1.2.1.0
06:20:01 <janos> Hi, I have a short question regarding QuickCheck:
06:20:17 <janos> I'd like to make Data.UUID an instance of Arbitrary
06:20:34 <janos> UUID is an instance of Random
06:20:54 <janos> and QuickCheck provides the function chooseAny :: Random a => Gen a
06:21:15 <cocreature> kgadek: have you tried the other hash table implementations in that package?
06:21:21 <janos> but for some reason I don't know how to combine these two to get an instance Arbitrary UUID where
06:21:38 <janos> anybody an idea?
06:22:06 <mangobot> can someone help me imrove the color function? http://lpaste.net/352363 can i not access the color directly via "if color == "b" then? 
06:22:16 <hpc> janos: arbitrary = chooseAny will work
06:22:20 <kgadek> cocreature: …whoah, BasicHashTable got me into 4.4s range
06:22:21 <hpc> janos: you just need to provide a shrink function
06:22:29 <cocreature> kgadek: nice!
06:22:32 <janos> hpc
06:22:36 <kgadek> cocreature: but this doesn't make too much sense
06:22:38 <cocreature> kgadek: the docs claim it’s the fastes hash table so that makes sense
06:22:46 <hpc> janos: which involves having some sense of what UUID values are "simple" to test and "complex" to test
06:22:57 <cocreature> oh no only the fastes lookups
06:22:59 <hpc> janos: or what ones will be more and less likely to expose what kinds of bugs
06:23:07 <janos> hpc: unfortunately I get " Variable not in scope: chooseAny :: Gen UUID"
06:23:08 <kgadek> > Randomized testing shows this implementation of cuckoo hashing to be slightly faster on insert and slightly slower on lookup than Data.Hashtable.ST.Basic, while being more space efficient by about a half-word per key-value mapping
06:23:11 <lambdabot>  <hint>:1:46: error: parse error on input ‘of’
06:23:31 <kgadek> so… yeah
06:23:35 <kgadek> I have a lot of insertions
06:23:37 <cocreature> kgadek: well you are not doing randomized testing at all. you are _only_ inserting
06:23:43 <kgadek> yes
06:23:51 <kgadek> and docs state that cuckoo shall be quicker than basic
06:23:53 <hpc> janos: how are you importing chooseAny?
06:24:10 <kgadek> cocreature: that's why I said "that doesn't make much sense"
06:24:25 <janos> hpc: just by import Test.QuickCheck 
06:24:28 <pavonia> mangobot: What exactly is your question? You already have that if expression there
06:24:32 <cocreature> kgadek: fair enough, but general statements like X is faster than Y are pretty meaningless if you only look at a specific workload
06:24:42 <hpc> janos: that won't bring it in scope
06:24:46 <hpc> janos: see https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Gen.html#v:chooseAny
06:25:21 <janos> I also import Test.QuickCheck.Gen
06:25:30 <janos> hpc: I also import Test.QuickCheck.Gen
06:26:05 <hpc> what version of quickcheck are you using?
06:26:05 <mangobot> pavonia http://lpaste.net/352380 i get this error when testing parseFEN
06:26:53 <kgadek> cocreature: well, this workload I have is matching precisely the description when Cuckoo shall be quicker. I'll create an issue anyway to discuss with author about this
06:26:54 <janos> hpc: good question, I am just importing QuickCheck into Stack
06:27:01 <AndreasK> kgadek: If your using Integer keys something like IntMap might be better to begin with.
06:27:21 <kgadek> AndreasK: yep, though I didn't want to in this scenario
06:27:54 <hpc> janos: try https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck.html#v:choose too, if that turns out to not work
06:28:20 <janos> hpc: I see...
06:28:21 <pavonia> mangobot: What is (parseColor part !! 1) supporsed to do?
06:28:27 <pavonia> *supposed
06:29:04 <janos> hpc: I just checked: I'm using LTS 7.19 which uses QuickCheck 2.8.2 which hasn't this function
06:31:06 <mangobot> pavonia return the color black or white if the string is "b,b,b,/... b" or "b,b,b,b/...  w"
06:31:38 <cocreature> mangobot: the problem is that "parseColor part" is of type Color but you are treating it like a list
06:32:03 <cocreature> the problem is _not_ in parseColor, the problem is in parseFEN where you are trying to get the second element of "parseColor part"
06:32:17 * hpc . o O ( stack should have a built-in implementation of hoogle for things like this )
06:32:34 <cocreature> hpc: I thought it had that already?
06:32:42 <hpc> it does?
06:32:47 <cocreature> yep, I just checked
06:32:52 <cocreature> "stack hoogle"
06:33:04 <mangobot> cocreature but parsefen splits the string into lists, no?
06:33:11 <hpc> huh
06:33:32 <hpc> i don't have it
06:33:45 <cocreature> mangobot: parseColor has type "[String] -> Color" so "parseColor part" is going to have type Color (or not typecheck)
06:34:10 <hpc> (at least on my main box, which is an older version)
06:34:18 <cocreature> hpc: it’s relatively new
06:35:01 <kgadek> cocreature: FYI, https://github.com/gregorycollins/hashtables/issues/39
06:35:04 <hpc> nix's version might have it
06:35:44 <hpc> just gotta wait for it to download the LTS
06:35:45 <mangobot> cocreature how can i implement it correctly? define parseColor as Color -> Color?
06:35:50 <exio4> cocreature: woah, I didn't know
06:36:08 <AndreasK> kgadek: For what it's worth unordered-containers implementation is also in the same ballpark as your original code
06:36:25 <kgadek> AndreasK: so ~15s?
06:36:35 <janos> hpc: thanks, added the newest quickcheck to extra depends and it works now!
06:36:41 <AndreasK> kgadek: On my machine both where ~18s
06:36:50 <cocreature> mangobot: parseColor is just fine (well at least it’s correct haskell, I don’t know if it is what you want). the problem is calling !! 1  on the result. I still don’t understand why you think that’s the right thing to do
06:37:13 <kgadek> AndreasK: that's… not good
06:37:43 <mangobot> cocreature well i dont quite see how can i do it alternatively, if i want tos plit that string into board state, color and move later
06:38:18 <cocreature> mangobot: are you maybe looking for something like parseColor (part !! 1)?
06:38:21 <AndreasK> kgadek: Inserting 10M elements and only doing lookup once is probably not what it's designed for though. If I construct the hashmap from a list of pairs instead it cuts the time almost in halfe
06:38:25 <kgadek> AndreasK: oh yeah, I missed that unordered-containers is THIS unordered-containers. lol. I've tried it as well (.Strict version), got very dissatisfying results
06:38:30 <cocreature> otherwise this parses as (parseColor part) !! 1
06:38:48 <cocreature> that might explain your misunderstanding
06:38:53 <mangobot> cocreture within the parseFEN function?
06:39:01 <cocreature> mangobot: yes
06:39:11 <hpc> :( "stack setup" on nixos fails weirdly
06:39:18 <hpc> configure: error: cannot determine current directory
06:39:28 <cocreature> pavonia: you then need to change the type of parseColor to "String -> Color" which is also more appropriate since it only handles single element lists
06:39:33 <kgadek> AndreasK: well, perks of microbenchmarks. This doesn't make much sense per-se, it's there to test 'insert' performance
06:39:53 <kgadek> creating from [(Int,Int)] should be quicker, yes
06:40:11 <kgadek> but that's something (just a bit) different
06:40:30 <kgadek> still, if that made 18->9 s on your machine
06:40:34 <mangobot> cocreature it gives me the following error http://lpaste.net/352380
06:40:49 <kgadek> then — by my extrapolation — I assume it's still 2x slower than OCaml
06:40:50 <tfc> hey there. i am writing a conduit network app. it's basically "appSource A $$ myconduit =$ appSink A". in myconduit, i want to yield a "hello" string to the server, and then read exactly 13 bytes of which i want the first two bytes to be [0x10, 0], don't care about the rest. but it must be 13. i have problems implementing this conduit because i do not understand conduits well enough yet. can anybody help me? 
06:41:15 <AndreasK> kgadek: Do you know any details about ocalms implementation?
06:41:19 <cocreature> mangobot: without seeing the code you’re using, helping you is hard
06:41:43 <kgadek> AndreasK: no, unfortunately not. I'm not educated enough to verify what's happening inside as well
06:41:51 <mangobot> cocreature http://lpaste.net/352363
06:41:57 <kgadek> maybe some magic optimization happens that breaks the microbenchmark
06:42:03 <kgadek> because microbenchmarking is HARD
06:42:05 <cocreature> mangobot: you haven’t changed the type of parseColor as I told you
06:42:10 <kgadek> I don't know
06:42:36 <cocreature> kgadek: that’s why you use criterion for this instead of just writing a main function that runs your benchmark once :)
06:42:38 <AndreasK> kgadek: Does it allow sharing of older hashmaps? Not too familiar with ocalm. The unordered container implementation is still a pure one
06:43:49 <mangobot> cocreature missed that msg, thanks. now its says the where part doesntwork though? test.hs:43:17: parse error on input ‘where’
06:43:51 <kgadek> cocreature: oh yes, I know. I have in my TODO list to dissect criterion into runner and stats-summarizer, plug in arbitrary stuff as former and use the latter to be able to benchmark random commands. But I don't have it today
06:44:15 <kgadek> AndreasK: no idea :<
06:46:53 <mangobot> cocreature can i leave the !! part from the fen function but then still access the first string somehow?
06:47:02 <mangobot> to use it in the parseBoard function?
06:49:48 <AndreasK> kgadek: Seems like ocalm hashtables are mutable, that would explain much of the difference
06:50:12 <kgadek> of course
06:50:35 <kgadek> I'm not that surprised by this result
06:50:41 <kgadek> only by Cuckoo vs Basic
06:52:35 <cocreature> mangobot: sry I don’t have the time right now to explain every error in your code. here’s a version that typechecks http://lpaste.net/352383. You still need to replace the underscore by something that produces a list of strings given board & color
06:53:00 <mangobot> cocreature ok thanks a lot for the help
06:54:01 <AndreasK> kgadek: The hash of ints are their values, I assume the performance issues might arise from that
06:54:33 <kgadek> AndreasK: oh? really?
06:54:48 <AndreasK> kgadek: As in insert is faster for random hashes, but inserting hashes which are strictly ascending would at least be an edge case
06:55:08 <kgadek> instance Hashable Int where hash = id
06:55:12 <kgadek> oh my, this is really the case
06:56:29 <kgadek> but wait
06:57:02 <kgadek> Cuckoo's `insert` uses `updateOrFail` which internally uses both `hash` and `hashWithSalt`
06:59:47 <kgadek> AndreasK: ok, I don't know too much about Cuckoo hashing so I give up slightly in trying to explain this
07:00:01 <AndreasK> kgadek: What does it use as salt?
07:00:14 <kgadek> hashPrime = if wordSize == 32 then hashPrime32 else hashPrime64
07:00:14 <kgadek>   where
07:00:14 <kgadek>     hashPrime32 = 0xedf2a025
07:00:14 <kgadek>     hashPrime64 = 0x3971ca9c8b3722e9
07:02:32 <AndreasK> kgadek: If you care enough you could try to insert ints with random keys and check the difference then
07:03:11 <kgadek> AndreasK: in a sec, I'm learning F# now :D
07:03:12 <cocreature> just make sure you are not benchmarking your prng
07:07:00 <kgadek> …wut. `fsharpc` is making me .exe files. On my OSX. Like srsly? Ehh
07:07:05 <kgadek> anyway, F# is blazing fast
07:07:15 <kgadek> 0,47s vs 4.4s for OCaml and Haskell
07:07:20 <kgadek> wondering what it does internally
07:10:19 <kgadek> anyone got .net disassembler?
07:15:39 <AndreasK> kgadek: Maybe more aggressive resizing
07:15:58 <kgadek> I suspect that .Net could optimize something away
07:21:20 <AndreasK> kgadek: If you presize the Cuckoo hashtable its also below 4s in time
07:21:37 <kgadek> AndreasK: oh, nice
07:21:57 <SrPx> Hey guys, this program is taking 2s to execute here. Am I doing something wrong? I think I have -O2 (I included it on ghc-options on .cabal). The equivalent JS program takes 20ms to complete so that can't be right.
07:22:00 <SrPx> http://lpaste.net/352384
07:23:19 <AndreasK> kgadek: nevermind hat the wrong type alias, gets faster by a lot though
07:23:21 <kgadek> btw, I was thinking that .Net could optimize sth away. But if my math is right, this may not be the case. Let's be generous and assume 0,48s for whole program is only in the tight loop. That means that on my 2GHz machine, it spends 96 instructions per loop, or 48ns. This is… plausible?
07:24:19 <kgadek> for OCaml & Haskell, this gives 896 instructions / 448ns
07:24:24 <Tuplanolla> Try `import qualified Data.Vector.Unboxed as V`, SrPx.
07:24:43 <SrPx> Wooops
07:24:51 <kgadek> AndreasK: so the question that remains: is 100 instructions for inserting value into hashtable possible.
07:25:14 <SrPx> Thanks and sorry
07:25:42 <kgadek> yes => something's wrong in Haskell OCaml. no => something magical is happening in fsharpc compiler
07:25:52 * Clint squints.
07:26:55 <AndreasK> kgadek: F sharp probably uses the equivalent of unboxed ints
07:29:26 <AndreasK> kgadek: And it's hard to say if thats realistic since we don't know if/how often the map gets resized. But without resizing I would say its certainly possible with a simple hash and few conflicts
07:29:39 <joneshf-laptop> So, HLearn is effectively stymied and impossible to install. Is there anything like it around that's still active?
07:30:19 <joneshf-laptop> "Like it" meaning cares about algebra, instead of just wanting to have pandas in haskell.
07:30:59 <SrPx> So, why adding more `incAll` calls degrades his program's performance? http://lpaste.net/352385 -- I assumed that, due to fusion, all those `incAll`s would be compiled to a single pass...
07:31:47 <Rotaerk> someone say "pandas in haskell"?! that'd be awesome
07:34:08 <kgadek> AndreasK: I don't think it's possible to use Int# in this implementation though :<
07:34:30 <joneshf-laptop> Rotaerk, don't things like that already exist?
07:34:43 <joneshf-laptop> Rotaerk, unless I really don't understand pandas.
07:34:59 <Rotaerk> oh, "pandas" is the name of something? darn
07:36:30 <AndreasK> kgadek: That's a drawback with synthetic benchmarks, hard to tell how much they matter for real use cases ... 
07:36:46 <kgadek> AndreasK: ok, no more ideas for how to make Haskell quicker. We're in 8-9x range comparing to F# now
07:37:12 <kgadek> true, though this one is quite dissatisfying
07:39:44 <AndreasK> kgadek: It's not a good comparison either way when you try to match implementations, more sensible would be to compare something like whats the fastest way to associate integers with integers.
07:40:32 <kgadek> hm, IMHO that's a different kind of benchmark. Comparing implementations makes sense for me
07:40:48 <kgadek> BTW, there was somewhere this paper about encoding boxiness in kinds…
07:41:19 <kgadek> anyone remember/know it? can't find it
07:41:34 <Tuplanolla> That's "levity", kgadek.
07:41:45 <kgadek> Tuplanolla: thanks!
07:41:58 <AndreasK> Well haskell's whole runtime is built on the idea that you take advantage of sharing and lazyness, imperative algorithms will pretty much always be slower in haskell for that reason imo
07:42:38 <AndreasK> Although a factor 10 seems high still
07:43:30 <kgadek> well, if something is slower b/c of sharing/laziness then there shall be an option to disable them. E.g. BangPatterns do quite a good job usually
07:53:19 <zipper> btw what's the reason stack does this:
07:53:26 <zipper> `haskell-src-exts-1.17.1 must match >=1.18 (latest applicable is 1.19.1)`
07:53:37 <zipper> Clearly 1.19 is greater than 1.18
07:53:53 <zipper> How can I fix this without forcing it in my stack.yaml
07:54:11 <mangobot> can someone help me with the data types here http://lpaste.net/352383 ? how to apply the functions correctly?
07:54:27 <hpc> zipper: 1.17.1 is what's conflicting with the constraint
07:54:42 <hpc> zipper: and 1.19.1 is how new you can go
07:55:35 <zipper> oh so in this case I am trying to install strucutured haskell mode but it requires 1.17.1 which is not available in this build plan
07:55:38 <zipper> I see
07:58:06 <zipper> Adding haskell-src-exts-1.17.1 as an extra dep in my ~/.stack/global-project/stack.yaml should work, right? because it's not.
07:58:13 <zipper> hpc: 
07:58:40 <hpc> no, you need to deal with the >=1.18 constraint
07:59:02 <hpc> it's already trying to use 1.17.1
08:02:24 <zipper> I'd like to use the latest version
08:02:34 <zipper> 1.19 if possible
08:03:31 <hpc> ah, then try adding 10:57 < zipper> Adding haskell-src-exts-1.17.1 as an extra dep in my ~/.stack/global-project/stack.yaml should work, right? because it's not.
08:03:34 <hpc> whoops
08:03:40 <hpc> try adding haskell-src-exts-1.19.1
08:04:05 <hpc> and see if you bump into a constraint that's forcing it to consider 1.17.1
08:04:07 <zipper> Thanks
08:04:41 <zipper> It's running *crossing fingers*
08:04:53 <zipper> How come we don't install happy and alex no more? :)
08:42:06 <mangobot> is there an error in this function? http://lpaste.net/352389
08:43:19 <logzet> there is no else?
08:44:11 <yushyin> yup
08:44:53 <Welkin> mangobot: your indentation is wrong
08:45:09 <Welkin> and you are missing an `else`
08:45:13 <logzet> And I suppose countFigures is the intended name, so ghc recognizes that and throws an error ;)
08:45:16 <Welkin> and you misspelled "Figrues"
08:45:27 <Welkin> "Figures"*
08:45:43 <logzet> First!
08:45:48 <Welkin> and you can do that same thing you are trying to do in a much simpler way using `filter` and `length`
08:47:03 <Welkin> > let countFigures = length . filter (`isElem` ['c', 'w']) in countFigures "abcdefgwc"
08:47:07 <lambdabot>  error:
08:47:07 <lambdabot>      Variable not in scope: isElem :: a -> [Char] -> Bool
08:47:49 <Welkin> > let countFigures = length . filter (`elem` ['c', 'w']) in countFigures "abcdefgwc"
08:47:52 <lambdabot>  3
08:48:00 <mangobot> Welkin thanks!
08:48:22 <Welkin> when possible, avoid using if-then-else
08:48:30 <Welkin> it is not idiomatic and can be confusing
08:48:44 <Welkin> also remember that you must insclude the `else` when you do
08:48:48 <Welkin> include*
08:50:01 <mangobot> Welkin ok thanks!
08:51:11 <mangobot> Welkin can i ask another questions, ive been stuck on this for over 4h.. http://lpaste.net/352389 so the idea is to parse the string into different strings and the first one represents the board state. i thought to then seperate it into [[String]] and each list would = a row and then parse each list to locate the figures
08:51:35 <mangobot> Welkin but im failing to combine the functions so it would work this way, like in the commented function
08:51:53 <zipper> Welkin: Habari yako?
08:52:57 <Welkin> zipper: great, and you?
08:53:13 <zipper> Welkin: Great also :)
08:53:15 <Welkin> sorry, I haven't learned anything beyond that yet :P
08:54:11 <Welkin> mangobot: could you explain what your goal is?
08:54:31 <Welkin> there may be a simpler way to do it that you haven't thought about yet (like with the previous example)
08:55:13 <cocreature> mangobot: can you describe what a board is supposed to be? you probably also want to make a separate type for that
08:55:17 <Welkin> `initialFEN` is the board state?
08:55:47 <Welkin> and what are the '/''s for?
08:56:12 <mangobot> Welkin the goal is to parse a string like "b,b,b,b/b,b,b/b,b,b,b/,,/w,w,w,w/w,w,w/w,w,w,w w a3-c4" into 3 strings and 1 would be the boardstate which i could then parse into positions to iterate through the board and list possible moves. the 2 string would represent the next player and 3 the last move. in the string "," stands for next colm and / for next row
08:56:26 <mangobot> like here http://pjb.com.au/laska/play_laska.html
08:56:34 <Welkin> you are still describing what you want your solution to look like
08:56:41 <Welkin> what is the problem you are trying to solve here though?
08:56:51 <Welkin> I don't understand what the board represents
08:57:16 <Welkin> how does this string work as the board state? What is '/'?
08:58:44 <mangobot> Welkin / stands for next row, so as in the link b is black, "," indicates next column, another b etc. then next row = /, has 3 players etc. so parseBoard splits the string into list of strings and if there are 7 rows then there will be 7 lists with player positions
08:59:05 <mangobot> Welkin but that was just an idea to be able to locate each player by only using this string
08:59:23 <Welkin> okay
08:59:33 <Welkin> instead of working directly off of that string format
08:59:38 <Welkin> why not parse the board into an internal format
08:59:52 <Welkin> then if you want to export it to that same string format later, you can do so with one function
09:00:07 <monochrom> Because they came from Tcl :)
09:00:12 <Welkin> then you don't need to worry about parsing the board every time you want to evaluate it
09:00:48 <mangobot> Welkin yeah thats what i want to do, but not sure how to actually implement it, so thats why i thought to parse the string and get the coordinates from there
09:01:35 <Welkin> okay
09:01:47 <Welkin> and the space followed by a letter is the current player?
09:01:54 <Welkin> here's what you can do
09:02:02 <mangobot> Welkin yeah
09:02:18 <mangobot> Welkin and there also will be a a3-c4 for last move
09:02:22 <Welkin> parse all the data from the string up front, then your program only needs to operate on clean data, like a custom defined Player datatype and Board datatype
09:03:39 <Welkin> so the format is "<board> <player> <last move>" ?
09:03:50 <mangobot> Welkin could you give an example of how youd implement it? i was trying to do it for the whole day but just starte leaning haskell so it gets confusing with the data types etc
09:03:51 <mangobot> yeah
09:03:57 <Welkin> > lines "<board> <player> <last move>"
09:04:00 <lambdabot>  ["<board> <player> <last move>"]
09:04:06 <Welkin> > words "<board> <player> <last move>"
09:04:10 <lambdabot>  ["<board>","<player>","<last","move>"]
09:04:23 <Welkin> that will gives you the 3 parts that you need to continue parsing
09:04:50 <Welkin> > splitOn " " "<board> <player> <last-move>"
09:04:53 <lambdabot>  ["<board>","<player>","<last-move>"]
09:04:55 <Welkin> same thing
09:05:18 <Welkin> assuming the string that comes in is properly formatted
09:05:44 <mangobot> Welkin yeah i did it with parseFEN :: String -> [String] parseFEN =   (splitOn " ") so it splits it into strings but failed to access each string afterwards
09:07:34 <mangobot> Welkin so i wanted to have something like http://lpaste.net/352389
09:09:02 <monochrom> @pl mu f = f (mu f)
09:09:02 <lambdabot> mu = fix (ap id)
09:11:03 <zcourts> is it possible (if so how?) to make a type assertion/constraint about all fields of a type? I mean, if I have a function f that takes some a, can I write a constraints that requires that fields in a are of some type T?
09:11:22 <mangobot> Welkin and have the listMoves and getMoves function in this format http://lpaste.net/352389
09:13:17 <pavonia> mangobot: Have you considered using a parser combinator library for the parsing stuff?
09:13:47 <pavonia> zcourts: By fields do you mean record fields?
09:14:40 <bonnie> hey guys I'm a haskell baby trying to understand why my code doesn't compile, could u help maybe?
09:14:58 <bonnie> tried to redefine the lines function
09:15:11 <lordcirth> bonnie, under the same name or different?
09:15:21 <bonnie> no different named it lines'
09:15:25 <bonnie> :)
09:15:25 <lordcirth> ok
09:15:48 <zcourts> yes, pavonia, record fields so if I were to have some type data X = X{c::X2, d::X3}, and a function f:: a -> Y. Can I write a constraint that requires that c and d in X are of type X2 and fail on anything else so in this example fail because d is of type X3 ?
09:16:25 <lordcirth> bonnie, well, pastebin the code and error
09:16:59 <bonnie> what is pastebin?sorry
09:17:13 <pavonia> zcourts: You could make define X like "data X a = X { c :: a, d :: a }" and then use the constraint on that type parameter
09:17:13 <sandonfuge> zcourts: you could do your function like this for example: sum :: (Num a) => a -> a -> a
09:17:19 <sandonfuge> if I understood you right, that is
09:18:08 <lordcirth> bonnie, pastebins are sites that let you upload text and get a link.  https://bpaste.net/
09:18:13 <geekosaur> @paste
09:18:14 <lambdabot> Haskell pastebin: http://lpaste.net/
09:18:25 <sandonfuge> That forces a to implement Num, but I think that's not what you meant
09:18:31 <lordcirth> arg it's @? I tried ! and .
09:18:46 <monochrom> Or "data X a b = X{c::a, d::b}" then f can be "f :: X X2 X2 -> ..." but other places can still enjoy X X2 X3
09:18:50 <bonnie> lordcirth: https://bpaste.net/show/ed888c979460
09:18:51 <geekosaur> zcourts, that question only makes sense if Z is a typeclass instance, and even then I think you;d have to parameterize it with X2 and X3 for that question to make any sense
09:18:59 <bonnie> there it is
09:19:13 <geekosaur> otherwise it's just X as the type and the parameter is either that type or not
09:19:52 <bonnie> the problem must be in the "otherwise" line, i think i can't put the x: there 
09:20:25 <lordcirth> your formatting is strange
09:20:25 <geekosaur> lordcirth, it's @ or ?
09:21:00 <geekosaur> I think that's 2 or 4 space tabs expanding to 8 on paste?
09:21:23 <geekosaur> or possibly something cut and pasted into vi with :set ai
09:22:16 <zcourts> pavonia: I figured as much on the type params but it's a lib so no control over the actual decls. sandonfuge geekosaur I'm currently using a typeclass to do it but got to the point where I was wondering if I was over complicating it 
09:22:17 <geekosaur> bonnie, I think the problem is [ : ]
09:22:28 <geekosaur> as in the pattern, you probably want parentheses
09:22:43 <geekosaur> it's [x,y,z] or (x:y:z:[])
09:22:48 <geekosaur> [x:y] is a list of lists
09:23:27 <bonnie> geekosaur okay i will try that thanks!
09:25:12 <Welkin> mangobot: http://lpaste.net/352389
09:25:24 <Welkin> something like that
09:25:29 <Welkin> I'm missing a lot of information
09:25:35 <Welkin> but that is the basic idea for how to structure it
09:26:01 <mangobot> Welkin wow thanks! ill look through it now
09:29:54 <mangobot> Welkin yeah thats basically what i was trying to do. thanks for the example. so now i can apply these functions http://lpaste.net/352396 to get the coordinates and eventually get the move list and the best possible move
09:33:33 <mangobot> general question: why if defining something like data Move = Move Pos Pos, Move is used again but if something like data Type = W | B there is no need to write Type again?
09:34:13 <Welkin> to the left of the `=` is the Type
09:34:14 <kosmikus> monochrom: Move is the name of a data constructor, just like W and B are data constructors
09:34:19 <Welkin> to the right is the Data constructor
09:34:21 <kosmikus> mangobot: ^^
09:34:24 <Welkin> they are two different namespaces
09:34:28 <kosmikus> monochrom: sorry
09:34:32 <monochrom> The second "Move" is not a type. It's a data constructor and is in the same category as W and B.
09:35:02 <monochrom> You can also have "data Type = Type | NotType".
09:35:06 <mangobot> ah ok thanks a lot
09:35:11 <monochrom> This is the problem with meaningful names.
09:37:52 <mangobot> Welkin one more question, the last one! why is data Square    = Empty    | Occupied [Player] why is player a list?
09:41:59 <Bish> Helooooooo
09:42:23 <Theophane> sup
09:42:47 <Bish> Theophane: was joining to ask the obvious troll questions again but decided not to! whats up in here!?
09:43:31 <Theophane> I'm watching webcomics and fidgeting with Haskell and the Erlang VM
09:43:55 <Bish> funny thing is, that's partly the qesiton iwas going to ask
09:44:02 <Bish> then i remembered there is erlang
09:44:15 <Bish> ( i was going to ask,why there aren't good functional language running on vm )
09:44:22 <Bish> which is not jvm. because that doesn't count
09:44:35 <Theophane> well, F# runs on a VM
09:44:42 <Bish> well microsoft does not count aswell
09:45:03 <nitrix> Hard to answer without a commonly agreed definition of "good".
09:45:11 <Bish> im wondering, i am not an expert on that level, just trying to find out if functional programming is something for me
09:45:23 <Bish> but shouldn't be functional languages easily be jit-able?
09:45:27 <Welkin> I don't see what a vm has to do with anything
09:45:30 <ongy> other question, why do you want it to run in a vm?
09:45:47 <Welkin> Bish: why do you want to have jit?
09:45:49 <Bish> hm.. well, i really like the concept of functional programming, after read myself into the theory of it
09:46:01 <Bish> Welkin: because vm always means bad performance.. without jit
09:46:02 <nitrix> Bish: Typically, people that never try FP will never like it. I'm sure there are statistical evidences.
09:46:16 <Bish> to my understanding a perfect jit would make a bytecodevm as fast as native code ( which doesn't exist, ofc )
09:46:33 <nitrix> Bish: So the best recommendation would be for you to try it and see if it's for you.
09:46:42 <Lokathor> Bish, erlang has reasonable performance if you use it for what it's intended for :P
09:46:54 <Bish> what is is intended to do?
09:47:14 <Bish> http://b.z19r.com/upload/did-you-just-tell-me-to-go-fuck-myself.jpg
09:47:21 <Bish> that?
09:47:47 <Lokathor> no
09:47:55 <Lokathor> Erlang is good for highly concurrent programs
09:48:05 <Bish> that sounds like something i like
09:48:15 <Lokathor> because it's designed around having lots and lots of little processes passing around messages
09:48:41 <Lokathor> it has worse straight line performance than just writing whatever in another language, if you're only going to be doing straight line computations
09:50:25 <nitrix> It has an overhead cost but that same overhead is what allows you to distribute the work to multiple threads/machines, making it cost-worthy again past some treshold.
09:51:26 <Lokathor> yes, and of course all the normal concurrency limits apply, "running on N cores won't get you a Nx speedup if your program isn't actually that concurrent", and so on
09:51:56 <Bish> actually i don't have a use case, i am in search of the holy grail.. meaning i want to do all with it
09:52:17 <Bish> right now this was ruby to me, which is like the opposite of functional
09:52:25 <Bish> (meaning it has state all over the place)
09:52:38 <Bish> i am aware of the fact that this holy grail might not exist
09:53:14 <Lokathor> the holy grail is either Haskell, Rust, or Erlang. probably, depending on use case
09:53:15 <nitrix> C.S. is going to be a perpetual tradeoff between space and speed. So no.
09:54:45 <nitrix> (Because we're working with finite machines)
09:55:04 <Bish> why rust?
09:55:31 <Bish> nitrix: i know all that :D i just like to dream
09:55:32 <Lokathor> Rust wins the "no overhead" category, Erlang wins the "never stops" category, Haskell wins the rest because look at the channel name
09:55:49 <Bish> but rust is not functional is it?
09:56:01 <nitrix> It's general purpose.
09:56:18 <nitrix> Multi paragdim :)
09:56:39 <Bish> haskell isn't ?
09:56:52 <Lokathor> You could do things functionally-oriented in rust if you wanted to, but that's probably going to be worse for your performance, BUT, it'd be pretty obvious the whole time what the performance hits were going to be
09:57:23 <nitrix> Bish: Of course haskell is functional.
09:57:42 <Bish> doesn't mean it's not general purpose
09:57:46 <Bish> or does it?
09:58:12 <Lokathor> haskell is a general purpose language that is also a functional language, correct
09:58:31 <nitrix> Bish: I haven't said otherwise. I think you're getting tangled in your own questions.
09:58:33 <sandonfuge> Bish: You can do anything with Haskell, but sometimes Haskell might not be the best choice.
09:58:52 <nitrix> Bish: The argument made for Rust was the "no overhead" part.
10:00:17 <Bish> whats haskells overhead?
10:00:20 <Bish> i mean it compiles to native
10:01:19 <nitrix> Sure and that native code can still contain overheads in respect to how other languages are translated natively.
10:01:25 <Lokathor> Haskell has a garbage collector, and lazyness is also a lot of overhead, and also the way it treats numbers can be a lot of overhead too, and List is a linked list which is a pretty bulky data type so if you use it for all of your sequences instead of switching to Vector as needed you'll be losing some there too for example
10:01:48 <nitrix> For one, Haskell programs have a very important runtime system that they all depend on.
10:02:02 <Bish> oh sure forgot about gc
10:02:15 <Bish> lists are real lists :o?
10:02:16 <Bish> dafuq
10:02:27 <Bish> thought they will be arrays in mem
10:02:33 <nitrix> Bish: It's not just GC. There are thunks and everything.
10:02:42 <nshepperd> [] is a cons list
10:02:53 <Lokathor> a haskell "List" is a linked list
10:02:54 <nitrix> Bish: We have boxed values and quite a lot of pointer indirection for various things.
10:03:08 <nitrix> Heck, strings are linked lists.
10:03:30 <exio4> note that in Haskell, what you see isn't what you get in terms of assembly, with optimizations, a list might be removed from the final code
10:03:34 <Lokathor> plays murder on your cache. that's why switching to Vector and Text and ByteString and such get such performance benefits
10:03:42 <Lokathor> they're not magic, they're just cache friendly
10:03:45 <nshepperd> for many cases, haskell overhead is not very terrible though. because things can be inlined and erased
10:04:17 <nitrix> The overheads are made up elsewhere by the variety of optimizations the language abstractions offer.
10:04:40 <Lokathor> there's that too. When you tell the compiler what things should be what other things, and not the specific memory operations it should do, then it's free to sometimes make things faster than you would have
10:04:55 <nshepperd> if you produce a list and immediately consume it, you usually get a loop in asm instead of building and destroying a linked list
10:07:57 <exio4> even so, GHC's GC is heavily optimized for that kind of situation
10:09:48 <Lokathor> i wonder how different "data StrictHeadList a = Nil | Cons !a (StrictHeadList a)" would be performance wise
10:10:03 <Lokathor> probably "crazily different in some way you don't expect"
10:23:24 <Bish> Lokathor: plays murder on your cache
10:23:36 <Bish> lists or arrays
10:23:56 <Lokathor> linked lists are bad for cache, arrays are good for cache
10:24:08 <Bish> yeah i guessed so, but your statement confused me
10:24:18 <tsahyt> with the caveat that you can implement cache efficient lists too, although I'm not sure what that would look like in haskell
10:24:36 <Bish> but why do lists really have to be lists?
10:24:50 <Bish> i really thought they gonna be abstracted away ( is that even a word in english )
10:25:00 <monochrom> Lokathor: scanl for StrictHeadList will use a lot less space
10:25:26 <tsahyt> having lists behave like lists sometimes and like arrays at other times when the optimizer happens to trigger would be even worse. predictability is important
10:25:48 <Lokathor> Bish, when you load memory address X, the CPU will often load X+1, X+2, X+3, and so on, since loads are so long relative to the instrucitons that act on the memory once it's in cache. With an array, this is a helpful optimization, with a linked list it's not helpful since you're just jumping some other place anyway
10:25:57 <Bish> yeah i get that, but why does it really have to be list, why could you not construc them as arrays
10:26:23 <Bish> Lokathor: i know all that i studied cs.. but it doesn't help me understand why they're not just virtually lists
10:26:29 <exio4> because of the way it is constructed
10:26:49 <Bish> wow, that's some sherlock statement there
10:26:52 <Lokathor> A lazy haskell list has very different properties from an array. Particularly, a lazy list can be infinite and generated on the fly, but an array must be a fixed size that you pick when you allocate it
10:26:54 <Bish> it is because it has been made this way
10:27:27 <monochrom> Bish, I think you're pitching it at the wrong level of programming. You need to go higher level and go declarative, in which you describe problems (and the computer solves it the best way) not solutions.
10:27:41 <Bish> monochrom: isn't that opinion?
10:27:51 <monochrom> No.
10:28:16 <monochrom> The Haskell language is still a language for writing solutions, not writing problems.
10:28:36 <Bish> i don't know what you're trying to say :D
10:28:46 <monochrom> It wants to respect the programmer's will of sticking to list, if the programmer says "list".
10:29:07 <tsahyt> if you want an array, there's Array
10:29:10 <tsahyt> and Vector for that matter
10:29:16 <tsahyt> it's nice to know what's actually going on
10:29:20 <Bish> that's like saying you don't want cache, because if programmer says memory he wants memory
10:29:23 <Lokathor> Bish, here's an example. To have a list of all the postive Int values, you just write [0..], and that'll take up just a few bytes of memory until you start to evaluate it. If you wanted an array of all the positive Int value you'd use up 2^63 * 8 bytes of memory all at once
10:29:55 <Bish> Lokathor: yeah i understand, but i don't get why non-infinite lists will not be saved as arrays
10:30:11 <Bish> i mean.. infinite arrays will also not be in ram, since there is not quite enough memory for it
10:30:14 <tsahyt> I don't think that's even possible to optimize in all cases
10:30:18 <monochrom> Yes, I would say that too. The programmer wants memory.
10:30:19 <exio4> Bish: how do you know if a list isn't infinite?
10:30:38 <tsahyt> deciding whether a list will be infinite from its construction is surely equivalent to the halting problem in the general case, isn't it?
10:31:10 <monochrom> Did you notice how the cache implementers took so much pain to make sure that the programmer can't tell the difference between memory and cache? (Except by looking at the clock.)
10:31:26 <Lokathor> i admit that most list literals would possibly be convertable to arrays, but then you wouldn't be able to mix those list literals with other list operiaotns because the internal reprisentation of a list and an array are quite different
10:31:31 <Bish> monochrom: yeah that's all im saying... want a list? you get a list, but it doesn't have to be implemented as list
10:32:13 <exio4> Bish: quite often - it doesn't even exist in memory, or only a few cells exist at an specific point of time.
10:32:45 <Bish> i get that, was just wondering
10:32:57 <exio4> Bish: (:) provides fast cons, too. that operation is expensive on arrays :)
10:34:31 <monochrom> Bish: Go to grad school, do your PhD on writing a compiler that does what you said.
10:34:51 <monochrom> It has not happened because you haven't done it.
10:35:36 <tsahyt> you can also build a structure that's inbetween right now in Haskell, say [Vector a], with a corresponding list-like interface to it
10:37:23 <exio4> tsahyt: so, a generic Data.ByteString.Lazy? :P
10:37:30 <tsahyt> basically, yeah
10:37:41 <tsahyt> lazy list of chunks
10:37:44 <Bish> monochrom: geez, take a chill pill
10:37:57 <monochrom> No, you take a chill pill.
10:37:58 <Tuplanolla> Don't we already have that somewhere, tsahyt?
10:38:00 <nshepperd> also you could add extra constructors to the list, like 'Cons4 a a a a [a]' and have the compiler automatically use them 'when appropriate'. but that would 1. be complicated 2. have overhead 3. probably mess with other optimizations
10:38:06 <tsahyt> Tuplanolla: I'd be surprised if we didn't
10:38:16 <Tuplanolla> Likewise.
10:38:42 <Lokathor> Bish, basically, the benefits of an array are great if you're willing to pre-allocate, but the things you'd use Lits for aren't things you want to pre-allocate
10:38:59 <Lokathor> in Haskell, the List type is more often for loop control than for holding all your data
10:39:24 <Lokathor> we've got other types for holding data that are each specialized to how you're using the data (Set, Sequence, Vector, etc)
10:40:31 <Tuplanolla> You're unlikely to come across the C idiom `char buf[BUFSIZ]` in Haskell, Bish.
10:40:35 <nshepperd> tsahyt: actually I use [Vector a] sometimes, as a cheap way of holding some arrays that are waiting to be concatenated
10:41:01 <makrusak> Hello, Sarkin :)
10:41:20 <tsahyt> nshepperd: what are the performance characteristics of that then, since every concatenation would take O(m+n) time, wouldn't it?
10:41:34 <sarkin> makrusak hey
10:41:53 <Lokathor> tsahyt, you'd walk the whole list and compute the final size once I think :P
10:42:04 <Bish> not saying it has to be this way, im asking questions to understand
10:42:11 <Bish> if you dont want to be part of that, don't be
10:42:25 <Bish> Lokathor: thanks, that helps
10:42:59 <Lokathor> Bish, for better or worse, Haskell has more types that are each a little more specialized than you would have in other languages. It's our version of being performance aware
10:43:00 <nshepperd> tsahyt: well, when I concatenate two of those it takes O(length of list) instead of O(length of arrays). And then yeah at the end I concatenate all the arrays at once in O(final array length)
10:43:18 <tsahyt> using mconcat I suppose
10:43:48 <nshepperd> maybe I should really be using DList or Data.Sequence for that use case, but [] works well enough for 1-10 elements. the important thing is the constant factors are much lower
10:43:55 <nshepperd> yep
10:43:59 <tsahyt> nice
10:44:14 <tsahyt> some digging in vector suggests that this all happens due to fusion magic that I don't understand
10:46:03 <nshepperd> you mean the implementation of mconcat? yeah I suppose it would use fusion magic. although in the end it's really just adding up the length, allocating that much then doing some memcpys
10:46:48 <tsahyt> but it would require two traversals of the list, one for the length, one for the memcpys?
10:47:08 <tsahyt> I suppose at least for small lists that's the fastest way to do it anyhow
10:47:23 <tsahyt> besides, depending on the origin of the list, that one itself might be subject to fusion
10:49:55 <tsahyt> Bish: FWIW, lists make great control structures for some tasks due to their implementation as actual lists. e.g. foldl' (+) [0..10000] might look like it's building a linked list in memory with 10000 elements in it and then iterating over them, adding them all up, but with optimizations on it compiles to a tight loop much like you would write it in C
10:50:09 <tsahyt> and this sort of thing often works across relatively complicated transformations
10:51:11 <tsahyt> I'm missing a 0 in there, foldl' (+) 0 [0..10000]
10:55:02 <e> if that compiles to a loop it's not exactly a poster child for good optimisation
10:55:46 <monochrom> Why?
10:56:34 <barrucadu> Because it could be reduced to a constant
10:56:52 <tsahyt> fair enough, bad example
10:57:13 <e> no, it's a reasonable example
10:57:42 <tsahyt> I'm not even sure whether GHC transforms this into a constant time form though
10:57:46 <e> i'm just stretching it further than it was intended and acting surprised when it breaks
10:58:29 <monochrom> Would this be a poster child? (But this time C.) https://plus.google.com/u/0/102208456519922110915/posts/DZsZ6mvA4T6
10:59:11 <WzC> Question: I would ike to store a bunch of functions, lets say of type (Ord b => a -> b) in a data structure, s.t. when I want to do a lookup I'm given a value of type a and I wish to report all functions in the DS that report b. 
10:59:38 <Lokathor> barrucadu, imagine (\x -> foldl' (+) 0 [0..x]) then :P
10:59:41 <WzC> does anyone see a way of fiddling around that so that I can use Data.Set/Data.Map as the DS? 
10:59:56 <e> monochrom: haha
11:00:07 <monochrom> :)
11:00:09 <Welkin> WzC: you cannot inspect types at runtime
11:00:11 <WzC> or do I have to basically redo the work and reimplement everything in Data.Set again 
11:00:19 <Welkin> because they don't exist any more
11:00:20 <WzC> I know what the types will be 
11:00:23 <WzC> they will be fixed 
11:00:36 <mr_sm1th> Is there no nor operator?
11:00:39 <WzC> ist's just that the functions I'm storing are only comparable once I give you a thing of type a 
11:00:40 <NeverDie> Functional programming discord chat if anyone's interested: https://discord.gg/NGM7BGW
11:01:11 <mr_sm1th> NeverDie: I think IRC people tend to look down on Discord. :')
11:01:16 <Welkin> WzC: you can store anything you want (functions, values)
11:01:38 <osfameron> NeverDie: eeeek, *voice* chat?
11:01:40 <Welkin> that is how typeclasses work; they are just a "dictionary" with the methods
11:02:02 <monochrom> Oh wait, discord is voice?!
11:02:18 <WzC> sure, but I don't see a way of sneaking in the value of type a to use for the comparison though
11:02:21 <osfameron> dunno, I just googled it, saw VoIP and skype mentioned
11:02:24 <mr_sm1th> No it's just a proprietary chat/voice platform.
11:02:25 <monochrom> There is a reason I use IRC, not talk on the phone, you know that?
11:02:37 <Welkin> WzC: I'm not sure what you are asking
11:02:56 <mr_sm1th> In any case, I'm going to have to write my own nor operator?
11:03:16 <Welkin> WzC: just apply the function over the `a`
11:03:33 <WzC> sure, but then I have to apply all *n* of them to a,
11:03:35 <monochrom> mr_sm1th: Look into Data.Bits, it's what's already avaiable.
11:03:40 <WzC> I want to search in O(lg n) time
11:03:46 <NeverDie> mr_sm1th: Hmm, I see.
11:04:05 <mr_sm1th> monochrom: Looks like it then.
11:04:30 <WzC> maybe mapMonotonicKeys works, I don't know if that function is lazy enough
11:04:42 <mr_sm1th> nor = not xor
11:04:47 <mr_sm1th> that works I suppose
11:04:52 <monochrom> No no!
11:05:10 <monochrom> nor x y = not (x || y)
11:05:19 <nshepperd> e: hm, that does actually compile to a loop in ghc. how sad.
11:05:56 <mr_sm1th> oh I'm actually looking for a && b || !a && !b
11:06:06 <mr_sm1th> I don't even know what it's called my god
11:06:09 <monochrom> Ah that yes.
11:06:09 <WzC> doesn't look like it at least 
11:06:17 <Lokathor> Discord has a texual chat in all channels, and some channels can have voice enabled as well
11:06:20 <monochrom> People call it xnor, I call it equality.
11:06:49 <mr_sm1th> monochrom: ^^
11:07:10 <mr_sm1th> I was confused because my predicate itself is an equality.
11:07:12 <monochrom> I call it equality because my thesis supervisor calls it equality and I learned from him.
11:07:15 <mr_sm1th> But thanks
11:07:29 <mr_sm1th> monochrom: Your thesis advisor sounds like wise (wo)man.
11:07:38 <monochrom> YES!
11:08:11 <boarders_> if I write my own implementation of church numerals in haskell like the bottom here: http://shhaumb.github.io/arithmetical-theorems-with-lambda-calculus/
11:08:35 <boarders_> how can I get it to write a convert from numbers into unary notation 
11:08:48 <boarders_> like into succ(succ(succ(...succ zero))...)
11:08:52 <Tuplanolla> Surely we should enumerate all the 16 possible function and name them.
11:09:10 <nshepperd> WzC: you're doing a point query given two values a, b and you want to find all functions where f a == b?
11:09:35 <lambdamu> Hi, is there a way to make this work http://lpaste.net/352399, it works with Show instead of ShowEq the compound constraint seems to be not passable as an type argument, I guess this is to be expected?
11:09:54 <boarders_> or maybe I should ask why convert 0 = zero and convert n+1 = succ (convert n) is not valid?
11:10:33 <WzC> yes, (and I'll give you that the Set is somehow build s.t. it is ordered on the b values) 
11:10:35 <monochrom> lambdamu: IIRC there is one more extension for that
11:11:08 <nshepperd> WzC: this won't work with arbitrary functions, you'll need more structure on them to search efficient
11:11:12 <lambdamu> monochrom: Ah, got a name? I activated quite a lot already
11:11:22 <monochrom> I forgot
11:12:05 <WzC> nshepperd: given that I tell you that if I were to evaluate all of them, the b values would be ordered I should be able to get O(log n) query
11:12:29 <lambdamu> monochrom: It is not one of those http://lpaste.net/352401
11:12:30 <nshepperd> WzC: eg. an ordering on the functions such that f < g means that forall a. f a < g a
11:12:31 <WzC> (as some background context: I'm implementing a sweep-line algo)
11:13:12 <d_tox> Has anyone seen a Prolog interpreter implemented in Haskell? 
11:13:31 <Tuplanolla> Why, d_tox? Did you lose one?
11:13:42 <WzC> i.e. I'll give you a datastructure d, storing functions of type a -> b, where b is ordable, and as a query I now give you an a, and I promise you that *if* i were to do a : fmap (a $) on my data structure, the b's would be in order 
11:13:48 <WzC> can you find them in O(log n) time 
11:13:53 <d_tox> Tuplanolla: ^o^. Nope, but looking for one ^^
11:14:06 <nshepperd> WzC: hm, I see
11:14:14 <WzC> I'm hoping to reuse Data.Set/Data.Map somehow 
11:14:26 <WzC> without having to reimplement that 
11:14:30 <Tuplanolla> @hackage prolog
11:14:30 <lambdabot> http://hackage.haskell.org/package/prolog
11:15:07 <d_tox> Tuplanolla: Thank you! Will look into it!
11:15:08 <WzC> if mapWithKeys would be lazy I guess it would suffice, but since the trees behind Data.Set seem to have a strict spine I don't think that works 
11:15:40 <monochrom> lambdamu: I'm now wondering if it's just "it's a type synonym with a parameter, so you always have to name the parameter syntactically"
11:15:46 <WzC> mapKeysMonotonic* I mean 
11:15:48 <monochrom> s/name/give/
11:15:57 <nshepperd> given this is a sweepline algorithm I guess the ordering property here is going to be kind of dynamic and depend on the current 'a'
11:16:12 <monochrom> i.e. it wants you to write "ShowEq something" not "ShowEq" alone
11:16:53 <WzC> nshepperd: exactly 
11:17:18 <lambdamu> monochrom: Yes I suspect this is to be expected type synonyms are probably reduced immediately
11:17:46 <boarders_> oh nevermind I was just being a fool above
11:18:00 <lambdamu> monochrom: Makes ConstraintKinds a little less useful
11:18:10 <nshepperd> WzC: probably I would put these in a Data.Sequence and do a binary search manually
11:18:15 <WzC> in my current approach I reimplemented a part of a balanced BST, but I keep needing more of the ops in Data.Set that I kind of just want to reuse it 
11:18:35 <WzC> nshepperd: the crappy thing is that Data.Sequence doesn't support binary searching in O(log n) time, it only gives O(log^2 n) time 
11:18:58 <WzC> which proabaly doesn't show up in practice, but I'd like to use a proper solution if possible 
11:19:35 <nshepperd> WzC: Otherwise, I think you could use a Data.Map if you wrap these in a newtype and use unsafe Data.Reflection voodoo to provide the 'current' value of 'a' for each operation
11:19:50 <monochrom> lambdamu: Maybe LiberalTypeSynonyms allows it. If not, I don't know.
11:20:15 <nshepperd> newtype DynamicOrd s a b = Do (a -> b)
11:21:01 <nshepperd> instance Reifies s a, Ord b => Ord (DynamicOrd s a b) where { ... }
11:21:33 <nshepperd> and then you wrap each call to Map functions with 'given' providing the current 'a'
11:21:45 <WzC> hmm that is an interesting idea
11:22:14 <WzC> let's see if I can get s.t. like that to work 
11:22:23 <nshepperd> Do f < Do g = let a = reflect Proxy in f a < f g
11:24:30 <volhovm> Hi! I'm logging some data with exclusive lock (hslogger does that i suppose) and trying to read those logs to send them at the same time. 
11:24:56 <volhovm> the read log fails with "openBinaryFile: resource busy (file is locked)", it seems like i'm missing something
11:25:18 <volhovm> so lock is one-process-only? i can read logs with cat w/o problems
11:26:02 <Tuplanolla> What should happen when the reader reaches end of file, volhovm?
11:26:07 <nshepperd> WzC: Yet another alternative would be to roll your own http://hackage.haskell.org/package/fingertree instead of using Data.Sequence, and do binary search in log(n) then
11:26:48 <volhovm> Tuplanolla: i suppose i'd be okay with any number of finished lines in it.
11:27:04 <WzC> nshepperd: do you have an estimate how much overhead the Reflection stuff would give? 
11:29:22 <nshepperd> WzC: I would expect it to be compiled down to basically what you would write by hand for a 'dynamic' Map, assuming the Ord instance is inlined
11:29:34 <nshepperd> basically the Map functions taking an extra argument
11:30:06 <WzC> hmm ok that is quite ok it seems 
11:30:25 <WzC> it does seem that I will have to drag around Typable a constraints everwhere then 
11:30:58 <nshepperd> huh, that shouldn't be required
11:31:52 <WzC> hmm maybe I'm missing something about that approach then, let me read through the docs for a bit longer 
11:32:44 <codedmart> Anyone with some pointers? I would like to use a uuid as my Primary key with persistent.
11:38:19 <hugh-adolph> https://www.youtube.com/watch?v=1aqLpNXQsUI
11:38:43 <monochrom> What is that video?
11:39:39 <monochrom> OK you are a spammer.
11:39:41 <hugh-adolph> yes it is a video
11:39:42 --- mode: ChanServ set +o monochrom
11:39:46 --- mode: monochrom set +b *!*@gateway/web/irccloud.com/x-lccopqrlwvmikmyj
11:39:46 --- kick: hugh-adolph was kicked by monochrom (hugh-adolph)
11:40:08 --- mode: monochrom set -o monochrom
11:41:11 <monochrom> And are they trying to compete with me in my niche of tautologies?!
11:46:05 <spear> what are haskell "batteries"?
11:47:10 <lordcirth> spear, never heard of them
11:47:54 <cocreature> spear: haskell is a programming language not a battery
11:48:22 <monochrom> batteries means libraries.
11:48:25 <Tuplanolla> It probably refers to libraries that used to be in the platform.
11:48:46 <monochrom> Blame the python people for their "batteries included" analogy to just mean libraries.
11:49:10 <monochrom> which unfortunately is adopted by Don Stewart to Haskell to refer to the Haskell Platform.
11:50:02 <monochrom> There was a time Don was overexcited by the ways of the python community, even their bad habits.
11:50:10 <nshepperd> isn't "batteries included" a rather common idiom?
11:50:38 <monochrom> Yes.
11:50:44 <reactormonk> Provide a defaultconfig or similar is pretty "batteries included" to me.
11:50:51 <monochrom> Before python, it was a common idiom for real batteries.
11:50:56 <hpc> it's annoying to see programmers put so much stock in that sort of marketing speak :/
11:51:26 <Tuplanolla> Alternatively it's the activity Haskell patrons perform to you when you write your code too imperatively.
11:51:53 <hpc> "batteries included" could mean parsec, or it could mean mysql_real_escape_string
11:53:06 <reactormonk> Or `stack init`
11:54:28 <hpc> or GADTs, or a repl, or a local copy of emacs
11:54:49 <EvanR> mysql_real_escape_string is a battery that youd rather not have to find
11:55:05 <EvanR> because your code runs on ambient microwave power
11:55:22 <EvanR> i.e. a real SQL DSL
11:55:23 <nshepperd> one of those batteries that explodes on your lap :L
11:56:05 <hpc> abstractions, like batteries, make things run properly but only when they aren't leaking
11:56:27 <WzC> ah cool, the reflection docs/tutorial/example thing actually has constructing dynamic Ord instances as an example 
11:56:35 <monochrom> haha hpc
11:56:36 <Bish> EvanR: examples for real SQL DSLs please
11:56:53 <EvanR> haskelldb ?
11:56:55 <hpc> sql is already a dsl
11:57:04 <Bish> i know thats why i asked :D
11:57:06 <monochrom> Can an abstraction catch fire?
11:57:17 <EvanR> sql is a dsl in the same way assembly is a dsl
11:57:40 <EvanR> you target it with compilers
11:57:44 <monochrom> EvanR means an EDSL in Haskell that corresponds to SQL.
11:58:30 <monochrom> You can also have an EDSL in Haskell that corresponds to asm too. And we would abbreivate it as "asm DSL".
11:58:59 <monochrom> And don't forget https://hackage.haskell.org/package/BASIC
11:59:06 <hpc> you beat me to it
12:33:03 <mr_sm1th> Is there a version of map that maps over two elements at once?    map2 :: (a -> a -> a) -> [a] -> [a]
12:33:27 <mr_sm1th> and it's type is not    (a -> a -> b) -> [a] -> [b]       because I just want it to leave the last element alone if there is an uneven number of arguments
12:33:43 <jle`> mr_sm1th: what two elements do you want to map over
12:33:57 <jle`> what would the result of yourmap (+) [1,2,3,4,5] be?
12:33:58 <mr_sm1th> jle`: first and second element, third and fourth element, and so forth
12:34:08 <mr_sm1th> [3,7,5]
12:35:28 <mr_sm1th> I've been thinking about zipWith func (list with elements with even indexes) (list with elements with odd indexes)
12:35:35 <Logio> mr_sm1th: you might be wanting a fold of a sort
12:35:55 <jle`> i don't think there's a clean one provided in any standard library
12:36:01 <jle`> the easiest way might just be with explicit recursion
12:36:20 <jle`> map2 f (x:y:zs) = f x y : map2 f zs
12:37:24 <Logio> that's probably more clear than writing the equivalent fold
12:38:06 <mr_sm1th> jle`: looks very good thank you 
12:38:32 <jle`> no problem :)
12:38:39 <mr_sm1th> Didn't think about that, :zs can of course match empty list
12:38:53 <jle`> yup. you'll have to handle the other two cases of course
12:39:24 <mr_sm1th> sure
13:14:52 <Haskello> hey 
13:14:59 <Haskello> i need some help
13:15:27 <Haskello> Ive got a list of tuples
13:16:03 <Haskello> and I need to pass them as arguements into a function which only accepts tuples
13:17:03 <Haskello> help?
13:17:30 <WzC> nshepperd: hmm. I think that for the reflection approach I'll need to use some unsafeCoercing somewhere; since basically the Map would have keys of type (DynamicOrd s a b) (note the s), and every instantiation of a lookup would do it's own reify, and thus want its own s. Do you think there is a way to avoid this? Or am I simply missing something?
13:18:00 <epsilonhalbe> Haskello: do you know of map?
13:18:13 <epsilonhalbe> i mean the function `map`
13:18:15 <epsilonhalbe> :t map
13:18:16 <Haskello> no
13:18:17 <lambdabot> (a -> b) -> [a] -> [b]
13:19:18 <epsilonhalbe> then I think it would be best if you checked out learnyouahaskell.com and look up this very useful function
13:19:46 <Haskello> ok will do
13:20:06 <epsilonhalbe> map makes a function that works on things into a function that works on list of things
13:20:22 <epsilonhalbe> sounds quite right to me 
13:27:46 <janos> Hi, a quick question: I'm using Generic in order to create To/FromJSON instances. But it doesn't work on maps, eg.: Map UUID Text
13:28:04 <janos> Am I missing something? In the Data.Aeson it says, it can handle Map
13:28:24 <ezyang> I think you want to use the built-in instance, not the Generic derived one 
13:30:25 <janos> The build in?
13:31:09 <janos> There is no one or?
13:31:29 <hexagoxel> (ToJSON v, ToJSONKey k) => ToJSON (Map k v)
13:31:53 <xcmw> I understand how to deal with single monads but when I use more than one monad with either transformers or nested monads things become confusing. Are there any good resources that explain how to properly deal with many monads?
13:34:13 <hexagoxel> janos: so the interesting question becomes: do you have From/ToJSONKey for UUID?
13:34:14 <ezyang> xcmw: My mental model is that you have a monad, which internally may be implemented with a number of transformers 
13:34:22 <ezyang> but the specific stack is an implementation detail. Abstract over it 
13:35:37 <janos> hexagoxel: I think I see the problem :) But in the Doc of Aeson.Types it says, that UUID is an instance of From/ToJSONKey
13:35:51 <xcmw> ezyang: Should functions return IO (Maybe t), MaybeT IO t, or (MonadPlus m, MonadIO m) => m t?
13:36:05 <ezyang> xcmw: Latter is more general 
13:36:34 <Unhammer> I'm fiddling with attoparsec to parse some fairly big (e.g. 17M) files where I want to put Entries into a Trie, and Entries can refer to previously seen Definitions-of-subentries and Symbols. Attoparsec easily gives me e.g. lists of the three types, but I've not yet seen an example that creates other data structures (like Trie/HashMap/Vector etc.) "on-the-fly" while parsing. Is this simply not recommended /
13:36:36 <Unhammer> something only Parsec does
13:36:38 <Unhammer> well?
13:36:41 <ezyang> that doesn't necessarily make it right, but a nice heuristic is to be as general as possible 
13:36:58 <xcmw> ezyang: The problem with that is that IO is considered a monad plus
13:37:38 <hexagoxel> janos: oh, right. and something does not work still?
13:37:57 <ezyang> xcmw: Ah, yeah, trouble. 
13:38:15 <ezyang> IO (Maybe a) is definitely something that I feel is a bit awkward to deal with in standard libraries 
13:38:49 <ezyang> Unhammer: attoparsec has incremental input? 
13:39:05 <janos> hexagoxel: yes :(. My map is: Map UUID Class   and Class has From/ToJSON instances
13:39:32 <Unhammer> ezyang,  I read that, but I don't understand the significance … 
13:40:51 <merijn> So, if I wanna benchmark concurrency primitives (i.e. benchmarks with multiple threads) using criterion, what'd be the best way to set that up? Spawn all threads up front and have them block on an MVar (or similar) and then unblocking all at once to start the benchmark?
13:41:52 <janos> hexagoxel: It also says Not in scope: type constructor or class ‘ToJSONKey’ if I try to do an instance for UUID
13:41:54 <Unhammer> … maybe I should trust more in laziness and treat the list as an incoming stream of data that I use to build&verify the Trie, because trying to thread the Trie through the parsers just feels like I'm doing something I'm not supposed to
13:43:27 <ezyang> merijn: MVar is not great at the multicast thing. Maybe use a TVar? 
13:44:54 <merijn> ezyang: I was thinking create empty MVar (), have all threads do "readMVar" and then use that to unblock everything
13:45:37 <monochrom> That is a little bit error-prone.
13:46:16 <merijn> Also, with criterion there is a way to have a setup, but there doesn't seem to be a tear down. There's some variable I want to keep alive (to avoid stuff getting GCed) during my benchmark, but without actually using it in the benchmark...anyway to accomplish that
13:46:24 <merijn> monochrom: How so?
13:46:30 <monochrom> But there are multicasting variants of Chan and TChan. (In fact you can already use them for multicast, just not super-efficient)
13:46:49 <monochrom> Just a little bit. It means you rely on careful coding.
13:47:15 <merijn> monochrom: I don't want to multicast data, I want to block a set of threads until they've all been spawned, as not to benchmark the time spent on setting things up
13:47:26 <hexagoxel> janos: uh have a look at the aeson instance you are using and see if you look at the appropriate docs maybe? if i read this correctly, the ~Key stuff is ~half a year old.
13:47:27 <monochrom> Ah.
13:47:38 <ezyang> merijn: What is going to happen if you do that is that the threads get woken up one by one 
13:47:51 <ezyang> rather than all of them being dumped into the thread queue 
13:47:56 * monochrom tries to save the idea. Multi-cast "you may start now!" like in exams!
13:48:10 <janos> hexagoxel: I am using aeson-0.11.3.0
13:48:21 <merijn> ezyang: And STM would be better for that?
13:48:23 <janos> hexagoxel: and indeed, I cannot find anything with key's there
13:48:42 <merijn> I'm just a bit lost how I can reliably write concurrent benchmarks
13:48:45 <ezyang> merijn: Well, not really 
13:48:51 <ezyang> heh heh 
13:49:07 <merijn> oh!
13:49:14 <monochrom> There will be a tiny delay no matter what you do.
13:49:19 <merijn> unagi-chan has some concurrent benchmarks, maybe I can rip them off
13:49:37 <merijn> monochrom: Sure, but that's ok, if the delay is consistent and similar across benchmarks :)
13:50:05 <monochrom> Actually I mean tiny unfairness.
13:50:43 <monochrom> The scheduler being a queuing system and all.
13:50:53 <merijn> I dunno why I didn't think off ripping off unagi-chan's benchmarks before...
13:51:03 <merijn> ALthough they seem a bit limited, skipping over some interesting things
13:54:04 <monochrom> This is interesting. Contemporary schedulers are basically a big global lock. It would be interesting to research into "distributed scheduler" (in the same sense that lock-free distributed queues exist).
13:54:04 <libscott_> What do you do if you have a long and complicated function and you want to remove all the IO calls without breaking up the logic? Is this a good time to use Cont or similar?
13:54:35 <ezyang> libscott_: why don't helper functions work? 
13:54:47 <monochrom> Why was IO there in the first place?
13:55:02 <merijn> monochrom: Afaik GHC threaded doesn't use a big global lock
13:55:31 <monochrom> But a general question begets a tautological answer. I would understand the program and factor it out accordingly.
13:55:45 <merijn> monochrom: afaik it has a per capability work queue with it's own lock, which means they only contend with eachother for locks when workstealing
13:55:52 <hexagoxel> janos: instances on that version are more limited, which should be the reason for your troubles. also no uuid yet it seems, without uuid-aeson.
13:56:12 <janos> yeah I create my own instance of UUID
13:56:19 <janos> hexagoxel:  for To/FromJSON
13:56:20 <libscott_> its a complicated validation routine that may need things from the database. I'd like to keep the logic of the validation routine together and give it a pure interface so it's more testable
13:56:57 <monochrom> Use dependency injection.
13:57:03 <merijn> Is it me or is it a bit weird that unagi-chan's benchmarks only advertise with identical numbers of readers and writers? Wouldn't it be more interesting to see how channels cope with many-to-one and one-to-many workloads?
14:02:36 <janos> hexagoxel: I now just used aeson-1.1.0.0 and now it works :)
14:20:21 <aluminumtubes> > (-2) 4
14:20:26 <lambdabot>  error:
14:20:26 <lambdabot>      • Could not deduce (Num t0)
14:20:26 <lambdabot>        from the context: (Num (t -> t1), Num t)
14:20:29 <aluminumtubes> why doesn't that work?
14:20:39 <aluminumtubes> but > (+2) 4
14:20:52 <aluminumtubes> > (+2) 4 -- works
14:20:56 <lambdabot>  6
14:21:14 <merijn> aluminumtubes: Well, consider this: How would you write a negative number?
14:21:38 <aluminumtubes> oh i see
14:21:42 <merijn> aluminumtubes: There were two options while defining Haskell 1) use different symbols for binary and unary minus or 2) disallow sections
14:21:47 <merijn> aluminumtubes: They went with 2
14:22:00 <merijn> Incidentally, if you do want a sectioned - there is
14:22:01 <merijn> :t subtract
14:22:04 <lambdabot> Num a => a -> a -> a
14:22:05 <merijn> > subtract 2 4
14:22:05 <Bish> disallow section?
14:22:08 <lambdabot>  2
14:22:22 <merijn> Well, I guess that technically they only disallow one of two sections of -
14:23:41 <AWizzArd> http://haskellbook.com/  —  will buyers get a dead-tree version of it? Or is it digital-only?
14:25:20 <Lokathor> currently there's no paper version
14:25:27 <AWizzArd> Oki thx
14:25:41 <Lokathor> they're shopping it around, but the book is like 1500 pages, which most people just don't want to publish
14:26:27 <AWizzArd> Understandable.
14:29:52 <HaskellLord69> yeah but the pages are super small
14:30:11 <HaskellLord69> huge margins and stuff
14:30:22 <HaskellLord69> i bet they could mess with it and bring the page count down
14:31:52 <Lokathor> bitemyapp is no slouch at LaTeX, I'm sure he's tried a few ways
14:33:30 <merijn> There's a reason for having huge margins and that's because things without those margins reads like shit. Which is why LaTeX has such big ones to begin with
14:33:49 <HaskellLord69> I personally find it very easy to read that way
14:33:53 <HaskellLord69> im not complaining
14:33:59 <HaskellLord69> but I like paper too
14:34:10 <merijn> The optimal line length for reading is somewhere around 60-72 characters per line. So unless you go double column you end up with rather a lot of margin
14:35:08 <Rembane> You could of course cut the paper to have a more reasonable width.
14:35:35 <merijn> Rembane: Sure, but generally you wanna stock to common paper formats, because custom paper size becomes even more expensive :)
14:36:24 <Rembane> merijn: Indeed. :)
14:37:48 <Rembane> merijn: I'm blaming society.
14:51:01 <merijn> My sad conclusion after my simple plan of "rip-off unagi-chan" is that their benchmarking is...rather questionable and not all that helpful to rip off >.> Anyone know of any other libraries benchmarking concurrent code?
14:51:28 <Welkin> they use the volkswagen method?
14:51:52 <Welkin> (if it detects it is being tested, it makes the tests pass)
14:52:04 <merijn> Well, if you benchmark a channel I would expect some benchmarks to include things like "simultaneous read and write operations from different threads"
14:52:23 <merijn> They appear to "write N message to chan, then read N messages from chan" all in the same thread
14:52:28 <merijn> So there's never any contention
14:53:39 <merijn> Which explains why TChan looks so good compared to Chan
14:53:52 <merijn> (in their benchmarks) because uncontested STM is basically free
14:54:14 <dhalgren> wondering about the new records work for 8.2 and the IsLabel (->) instance that was apparently punted for 8.4 : if the lens interpretation gets adopted, so then all lenses get written like #foo as opposed to just foo as today, right? Is this even acceptible to lens authors or still too noisy in comparison to status quo? 
14:54:42 <Welkin> what o.o
14:55:46 <dhalgren> I have a vague recollection of ekmett disliking the #foo in some old discussion, because of the extra #, but no hope of digging that up
14:56:53 <dhalgren> but if that memory is not false, perhaps even if the lensy interpretation is adopted, it would still not be actually usefull?
15:05:26 <merijn> bleh, this means I have to invent benchmarks from scratch after all :/
15:13:49 <mr_sm1th> Noob question time: how do I operate on values nested in two contexts.
15:13:59 <mr_sm1th> I have a String -> String and an [IO String]
15:14:11 <Rembane> mr_sm1th: fmap . fmap
15:14:19 <mr_sm1th> Really
15:14:24 <mr_sm1th> Oh OK...
15:14:28 <Welkin> fmap fmap fmap fmap
15:14:28 <Rembane> Yes. :)
15:14:32 <Rembane> :t fmap . fmap
15:14:34 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
15:14:41 <Welkin> :t fmap fmap fmap fmap
15:14:43 <lambdabot> (Functor f2, Functor f1, Functor f) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
15:14:55 <merijn> Also, if you have [IO String] you (usually) used map in a place where you wanted to use "mapM"
15:15:20 <mr_sm1th> lines <- sequence $ take (read noLines :: Integer) $ repeat getLine
15:15:28 <mr_sm1th> ^ probably
15:15:31 <Rembane> :t mapM
15:15:33 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
15:25:23 <NeverDie> If anyone wants to join the FP discord chat, check it out here: https://discord.gg/NGM7BGW
15:25:26 <merijn> welp...this is confusing...
15:25:51 <merijn> According to my benchmarks the code that is going more work is...faster by a significant percentage? o.O
15:38:57 <markasoftware> how can I make haskell go acceptably fast for text processing?
15:39:09 <markasoftware> right now, doing getContents, then lines, then processign, then unlines and putStr is ungodly slow
15:40:10 <markasoftware> just `input <- getContents` then `putStr input` as my whole main body goes less than 10 mb/s
15:40:55 <Lokathor> consider using Text instead of String, for one
15:40:57 <Lokathor> it's more compact
15:41:12 <Lokathor> also consider processing by line instead of by file, if possible, for less in memory at once
15:41:50 <markasoftware> Lokathor: from what I've read getContents and l ines should be lazy enough to avoid loading the whole file into memory
15:42:01 <markasoftware> ill have to try text
15:42:36 <Lokathor> ah, you're right
15:42:42 <Lokathor> depends on how you process the lines i suppose
15:42:54 <markasoftware> im doing a 3.5 gb file and it's not in memory
15:43:00 <markasoftware> otherwise i would notice, haha
15:45:35 <tlahtoani> Large file processing usually works in nice 8k chunks 
15:51:51 <markasoftware> ugh, even with text it's not going that fast
15:51:59 <markasoftware> more like 75 mb/s
15:52:07 <markasoftware> i get over 100 mb/s with awk
15:52:27 <exio4> markasoftware: is the text UTF8? 
15:52:41 <Welkin> are you using pipes?
15:53:08 <markasoftware> exio4: idk
15:53:10 <markasoftware> Welkin: no
15:53:15 <markasoftware> what is this pipe business
15:53:25 <Welkin> I thought you were processing streaming data
15:53:35 <sleblanc> markasoftware, it's actually very useful. it's a way to abstract streaming data
15:53:41 <sleblanc> producers, consumers, processors
15:53:56 <Welkin> it makes it run a lot faster and uses constant memory
15:55:10 <markasoftware> ok ill have to look into this
15:55:32 <mr_sm1th> Use Haskell they said. If it compiles it works they said. :') http://lpaste.net/79979635445596160
15:55:35 <Welkin> also, are you compiling with optimizations?
15:59:02 <markasoftware> hmm, when i do runghc it works but when i compile it says 'lexical error at character \DEL'
15:59:42 <sleblanc> markasoftware, it seems like there are stray characters in your source. try using a hex editor view to locate them
15:59:57 <markasoftware> it's a runtime error
16:00:00 <markasoftware> it compiles fine
16:01:06 <sleblanc> markasoftware, does this help? https://stackoverflow.com/questions/27415073/lexical-error-at-character-del-when-doing-runhaskell#27415315
16:01:45 <markasoftware> yeah i think i accidentall ran runghc ./test
16:02:24 <markasoftware> i think i will just use awk, i guess it's more the right tool for the job
16:05:09 <nshepperd> markasoftware: I get 6GiB/s when I compile with -O2 there
16:05:27 <markasoftware> nshepperd: htat sounds broken, your io probably sin't even that fast
16:05:57 <markasoftware> unless you have like 3 pcie ssds in raid 0
16:06:25 <nshepperd> no, I was catting from /dev/zero
16:06:53 <markasoftware> oh
16:06:55 <nshepperd> but, turns out I had a stray | so I was measuring the wrong thing. whoops :p
16:06:59 <markasoftware> what code?
16:07:02 <markasoftware> oh ok
16:07:06 <nshepperd> 50MB/s is more like it
16:07:17 <markasoftware> yeh awk can do better
16:07:24 <markasoftware> even though it's interpreted
16:07:29 <markasoftware> at least with mawk
16:07:32 <markasoftware> gawk is not so fast
16:08:43 <markasoftware> im sure somebody who knows what they're doing can do faster in haskell but not me
16:09:35 <nshepperd> ah, it's definitely the unicode stuff
16:10:19 <nshepperd> lazy ByteString is a bajillion times faster
16:10:20 <markasoftware> im not sure if i need unicode things, I have some special characters i think but nothing too exotic
16:10:24 <markasoftware> maybe some dots over some letters or something
16:10:53 <nshepperd> 3.33GiB/s
16:11:46 <markasoftware> now take out the extra pipe ;)
16:11:49 <markasoftware> what code got that fast?
16:11:53 <markasoftware> could you paste it somewhere
16:12:48 <dolio> He used ByteString, which just reads and writes raw bytes for the code you mentioned, instead of doing unicode validation and encoding.
16:12:53 <MarcelineVQ> nshepperd: how are you measuring that? Eventually I'll need to do similar so it'd be good to know
16:12:56 <Welkin> supposedly, just swap Text for ByteString.Lazy
16:13:18 <Welkin> MarcelineVQ: filesize / time ?
16:13:43 <markasoftware> well, i actually need to process the data, not just read in then flush out
16:13:46 <lpaste_> nshepperd pasted “cat.hs” at http://lpaste.net/352407
16:14:03 <markasoftware> MarcelineVQ: i would d o it like this: `pv < /dev/zero | ./test-stuff > /dev/null`
16:14:24 <MarcelineVQ> thank you, I don't have pv so I'll look into it
16:14:36 <nshepperd> markasoftware: pv! http://www.ivarch.com/programs/pv.shtml
16:14:45 <nshepperd> oops, MarcelineVQ ^^
16:14:54 <markasoftware> lol
16:14:54 <Welkin> cool, I never knew about this https://linux.die.net/man/1/pv
16:15:00 <markasoftware> it's cool as crap
16:15:08 <MarcelineVQ> yep it should be available in my pacakage manager I​ Just wasn't aware of it :>
16:15:44 <markasoftware> well, im doing the awk thing, wish me luck
16:16:03 <sleblanc> if you know the size, you can tell pv with the option --s
16:16:24 <sleblanc> oops, that's '-s'
16:16:36 <nshepperd> normally I just throw in pv -rab without thinking
16:17:30 <Welkin> kind of like ps aux | grep <something>
16:17:31 <Welkin> lol
16:17:39 <sleblanc> you can also give the name of the file to pv, so it can infer the size automatically, instead of using shell input redirection
16:19:49 <nshepperd> Welkin: ah well, ps is a different monster -- were any mortal to understand wtf its flags do, they would surely go insane
16:20:01 <nshepperd> using 'ps aux' is the only safe option :)
16:20:21 <sleblanc> I prefer htop with its filtering ability
16:21:53 <MarcelineVQ> I used ps to make a haskell app to kill the biggest processes in case of memory dunks because I'm too dumb to just invoke ghc with -M
16:24:41 <nshepperd> heh. I always install https://github.com/rfjakob/earlyoom first on any new machine
16:47:42 <topkek> hi
16:47:58 <topkek> i got a handshake in wifite
16:48:04 <topkek> what do i do next
16:57:28 <MarcelineVQ> nshepperd: thanks for that link too
16:57:44 <sm> earlyoom, nice
16:58:05 <MarcelineVQ> I've got "kill the biggest hog" set to a quick keybind already but this could be better
17:02:27 <Tuplanolla> That would just kill Firefox every time.
17:03:18 <MarcelineVQ> I'm okay with that
17:03:29 <MarcelineVQ> If I can't move my mouse because firefox lives, it must die.
17:04:26 <bennofs> MarcelineVQ: with sysrq, you can press SysRq Key + f to invoke the oom killer
17:05:05 <bennofs> MarcelineVQ: the good thing about that it that is low level enough so that it probably still works even if it's already "too late" for moving mouse etc
17:08:00 <threestrikes> Can someone explain to me what this means " import qualified GI.Gtk as Gtk"  I understand how to import functions but I don't understand this syntax. 
17:08:38 <MarcelineVQ> bennofs: that's good info as well thank you
17:10:08 <geekosaur> threestrikes, it means you can't refer to functions from that module without qualification, but you can use the shorter qualification Gtk.whatever instead of GI.Gtk.whatever
17:10:17 <nshepperd> using sysrq to invoke the oom killer has never worked for me, dunno why
17:10:49 <geekosaur> (those are separate and come from "qualified" and "as Gtk" respectively)
17:11:01 <bennofs> have yiz checked that sysrq was enabled? sysrq needs to be explictly enabled, and there's some ways to enable only part of it i believe (with a flag mask)
17:11:10 <MarcelineVQ> nshepperd: it spun up my HDD here so it's doing something, didn't kill anything but it may have dumped cache's etc
17:11:50 <bennofs> you should see in dmesg what it killed
17:12:59 <threestrikes> geekosaur: what do you mean by qualification?
17:13:06 <MarcelineVQ> "SysRq : This sysrq operation is disabled." hehe, that's enough offtopic from me for now though. thanks for your help everyone
17:13:08 <nshepperd> apparently it purged gpu memory
17:13:40 <geekosaur> threestrikes, like Data.Map.lookup
17:13:49 <geekosaur> (the unqualified one usually refers to the one in Data.List)
17:13:58 <dikdik> omg wreq has a tonne of deps
17:17:13 <threestrikes> geekosaur: what would be the advantage of doing that?
17:18:16 <geekosaur> because functions on container-like types often have similar/"the same" name, so there's a lookup in Data.List and there's one in Data.Map and one in Data.Set
17:18:48 <threestrikes> Ok thanks
17:19:29 <geekosaur> some gtk bindings also overlap, so you use qualified names --- but you often want a shorter name than the full module name, so import ... as SN
17:19:49 <geekosaur> (like Data.Map is usually imported "as M" so we say M.lookup, M.insert, etc.)
17:26:13 <lordcirth> Working on a game and it seems like wrapping the entire GameState in a State would work well, but at that point, it doesn't seem very functional/pure in practice.  Any opinions?
17:28:47 <barrucadu> lordcirth: To be honest, that's probably how I'd do a game. The state is explicit, so it's still a better situation than in procedural code.
17:29:06 <barrucadu> You can still test your stateful functions individually, because you have total control over the state they use.
17:29:27 <barrucadu> State isn't so bad, it's hidden state that is.
17:30:20 <pikajude> smash the hidden state!
17:30:36 <dikdik> Is there any reason that after doing cabal install I can't use the pakage?
17:31:27 <barrucadu> dikdik: Are you getting a compilation error about a hidden package, or something like that? You need to list packages you are depending on in a project's .cabal file, it's not sufficient to just install them.
17:33:24 <dikdik> I am getting a cannot find module 
17:33:33 <dikdik> But ghc-pkg shows it's installed
17:33:52 <dikdik> Is there an automated way to add them to the file?
17:34:26 <pikajude> is it possible to write a cabal project that uses different compilers for different modules?
17:35:14 <barrucadu> dikdik: I don't think so. At least, I don't know about such a tool.
17:36:02 <ezyang> pikajude: not unless they're in separate packages, and even then it will be difficult 
17:36:20 <pikajude> ezyang: they are separate packages
17:36:30 <pikajude> i have a frontend and a backend, and one needs to be compiled using ghcjs
17:36:39 <pikajude> but they share some code
17:54:38 <noan> Today I started to think generating a securely random token string in haskell might be more of a kick in the pants than I usually would expect
18:08:34 <lordcirth> barrucadu, ok, thanks!
18:09:29 <Welkin> \msg lambdabot @undo rec do {a <- b; b <- c; c <- a}
18:15:29 <jay_> @unpl flip flip id
18:15:30 <lambdabot> (\ y y0 -> y y0 (\ x -> x))
18:28:52 <jle`> pikajude: you probably don't want different compilers for different modules
18:28:58 <jle`> pikajude: you want different compilers for different executables
18:28:58 <pikajude> probably not
18:29:12 <jle`> the modules themselves will have to be compiled using both compilers of course
18:29:31 <pikajude> yeah, right now i have a package in backend/ and frontend/ and a shared/ dir
18:30:01 <jle`> yeah, and you couild even have two compilers for different executables within the same package/project, as well
18:30:12 <pikajude> but then i have to configure twice right
18:30:28 <jle`> not necessarily; they exist side by side
18:30:44 <pikajude> right
18:30:56 <pikajude> but how do i compile one executable with ghcjs and one with ghc without running cabal configure again
18:30:59 <pikajude> i don't understand
18:31:01 <jle`> so installing one executable would not affect the installation of the other executable
18:32:20 <jle`> ah well you'd cabal build one executable, and then cabal build the other separately.  but configuration is maintained appropriately, as two separate things
18:32:35 <pikajude> can i have an example
18:32:49 <pikajude> i still don't see how to set a compiler for a specific executable in a package
18:33:09 <ezyang> pikajude: You are using cabal-install with sandboxes? 
18:33:12 <athan> woah.. GHC.Natural.Natural... is this usable for casual haskell users?
18:33:15 <pikajude> ezyang: no
18:33:21 <pikajude> i'm just using cabal-install
18:33:41 <ezyang> OK, so, with that interface, it's possible to have two simultaneous builds with different config 
18:33:44 <ezyang> the parameter is --builddir 
18:33:47 <pikajude> oh
18:33:56 <ezyang> cabal configure -w ghcjs --builddir=dist.ghcjs 
18:34:03 <pikajude> oh
18:34:04 <pikajude> ok
18:34:22 <pikajude> and then what, do I set buildable based on impl(ghc) or impl(ghcjs)
18:34:26 <ezyang> I'm... not sure I should honestly suggest you do this, but with enough bludgeoning you will be able to get it this way 
18:34:48 <ezyang> Well, I don't know what your Cabal file looks like, but if a library/exe is ghc/ghcjs-only, yes, you should do that 
18:34:53 <pikajude> ok
18:38:00 <noan> Oh lord it does not feel good to stare at weeks of failed attempts to get a simple json api working in haskell and then just go "fuck it I'll do it in ruby I guess"
18:39:21 <ezyang> noan: :-/ 
18:39:30 <dikdik> Gah
18:39:31 <ezyang> If the only thing I had to do was sling json around, Haskell would not be my first choice 
18:39:40 <dikdik> I cannot get this HTTP request to work 
18:39:54 <noan> because of the usual simplicity, I was thinking "hey, this is a simple problem. Lets go learn haskell"
18:40:50 <noan> then I find myself mired in a type mismatch where the types are 7 things nested and I cry softly.
18:42:18 <jle`> might be an issue with documentation and bad error messages more so than haskell itself, unfortunately
18:43:54 <dikdik> I am sort of getting the same thing 
18:43:55 <noan> jle`, I'm not trying to say the language is at fault. It seems to me to be a combination of lack of documentation, a lack of grasp of the language myself, and a set of tools that compose with even further complexity.
18:43:59 <dikdik> Though I am not sure why 
18:44:05 <dikdik> I am following a tutorial xD
18:44:09 <noan> I could throw a repo link for anyone who wants a good laugh at someone being hopelessly lost XD
18:44:14 <noan> oh, you meant @ dikdik, nvm
18:44:30 <jle`> oh i meant that to be towards you :)
18:44:52 <jle`> yeah haskell also isn't a good language to jump in and learn ad-hoc; usually you need a disciplined plan
18:45:11 <jle`> because a big part about learning haskell is learning what parts of your intuition to ignore
18:45:42 <kgadek> oh, ghc ticket tracker gives errors?
18:45:53 <kgadek> or is it just for me? 
18:45:56 <kgadek> e.g. https://ghc.haskell.org/trac/ghc/ticket/11473
18:46:21 <geekosaur> bgamari's working on trac
18:46:26 <noan> jle`, trying to learn several libraries concurrently with a new language and new concepts... well.. that aint easy
18:46:30 <noan> and gives you shit like https://github.com/AlexaDeWit/haskellsandboxserver
18:46:31 <noan> XD
18:46:47 <kgadek> geekosaur: ok, great. wanted to verify this is "known problem"
18:46:53 <geekosaur> "I'll be doing some maintenance on the Trac installation in a few minutes. It may be a bit flaky while this happens. Sorry for the inconvenience!"
18:47:01 <dikdik> what I want to do works in GHCI
18:47:05 <dikdik> Though I am not sure why
18:47:26 <ezyang> dikdik: If you post some code we might be able to help 
18:47:30 <geekosaur> @paste the code dikdik
18:47:30 <lambdabot> Haskell pastebin: http://lpaste.net/
18:47:37 <dikdik> kk
18:48:01 <geekosaur> but ghci has ExtendedDefaultRules and a few other ghci-specific behaviors that mean that code can indeed behave differently
18:48:30 <geekosaur> also include any errors (full error messages ideally) you get
18:50:05 <dikdik> http://lpaste.net/2769602084503289856
18:50:15 <dikdik> Ah
18:50:17 <dikdik> One moment
18:50:57 <geekosaur> the let is wrong; <- would be at least less wrong
18:51:13 <dikdik> http://lpaste.net/2769602084503289856
18:51:21 <dikdik> Oh, same url 
18:51:38 <dikdik> It gives me a syntax error I think 
18:51:40 <ezyang> oof, trying to learn lenses AND haskell at the same time XD 
18:51:43 <dikdik> when I use <-
18:51:49 <kgadek> is it possible to get levity info in GHCi?
18:52:00 <dikdik> The lenses work in ghci ;~;
18:52:12 <geekosaur> ghci is implicitly in a "do"
18:52:25 <geekosaur> although I see a "do" there...
18:52:55 <ezyang> kgadek: Does -dppr-debug work? 
18:53:11 <geekosaur> is it actually the same error message, or a similar one with different types? I'd expect the latter when using <-
18:53:18 <dikdik> Oh, wow
18:53:21 <dikdik> it compiled
18:53:32 <dikdik> :D
18:53:50 <dikdik> But it didn't compile before...
18:53:51 <dikdik> Hmm
18:54:42 <kgadek> ezyang: well, nothing happens…
18:55:15 <kgadek> wait
18:55:24 <MarcelineVQ> kgadek: are you looking for -fprint-explicit-runtime-reps possibly
18:56:36 <geekosaur> dikdik, one thing to watch out for in a file is indentation
18:56:37 <kgadek> MarcelineVQ: this is for GHC of GHCi ?
18:56:48 <MarcelineVQ> both
18:56:52 <geekosaur> it doesn't matter as much in ghci unless you are in multiline mode
18:58:12 <MarcelineVQ> At least it's supposed to, but it didn't just now for me, hmm
18:59:02 <geekosaur> kgadek, per mail to ghc-devs the trac maintenance (upgrade, apparently; no wonder you had problems) is complete. email to ghc-devs list if you still have problems
18:59:24 <kgadek> geekosaur: thank you :) noticed already
18:59:45 <kgadek> MarcelineVQ: I see docs — https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using.html#ghc-flag--fprint-explicit-runtime-reps — but it doesn't work for me? strange
18:59:52 <kgadek> GHC 8.0.2
19:01:33 <MarcelineVQ> me neither, not sure why, there's a whole section on it here as well https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=levity#runtime-rep
19:04:31 <kgadek> oh well. will investigate tomorrow, must go now. thanks again MarcelineVQ for name of the option :)
19:06:06 <MarcelineVQ> oddness, -fprint-explicit-kinds doesn't seem to be working either and I KNOW I've used that before
19:06:39 <MarcelineVQ> oh nvm, I was thinking of -fprint-explicit-foralls for the one I've used before, which is working
19:06:57 <MarcelineVQ> oh oh
19:07:06 <MarcelineVQ> kgadek: try :i instead of :t
19:07:50 <kgadek> oh yes, this one gives the results
19:08:08 <MarcelineVQ> possibly it's a documentation issue to show using :t
19:08:51 <kgadek> seems like so
19:08:54 <MarcelineVQ> or ghci is incorrectly not being fully honest, since -fprint-explicit-kinds works fine with :t
19:09:20 <MarcelineVQ> er, -fprint-explicit-foralls :>
19:14:31 <jle`> is there an fgl for "heterogeneous" graphs?  where every node is differently typed?
19:19:30 <kgadek> geekosaur: oh yeah, I get the error on track while creating new ticket
19:20:16 <geekosaur> https://mail.haskell.org/pipermail/ghc-devs/2017-February/013768.html by any chance?
19:20:41 <kgadek> yes. you're quicker than I am
19:36:38 <aluminumtubes> i tried to make curry for triples but i made uncurry instead :|
19:36:46 <aluminumtubes> > curry' f (a,b,c) = f a b c; (curry' (\ a b c -> a + b + c)) (1,2,3)
19:36:49 <lambdabot>  <hint>:1:18: error:
19:36:49 <lambdabot>      parse error on input ‘=’
19:36:49 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
19:36:55 <aluminumtubes> help
19:37:15 <aluminumtubes> also how do i evaluate those expressions in one line?
19:37:46 <kgadek> > let curry' f (a,b,c) = f a b c in (curry' (\ a b c -> a + b + c)) (1,2,3)
19:37:50 <lambdabot>  6
19:38:18 <aluminumtubes> why doesn't semicolon work?
19:38:30 <unyu> Is there some way to set the prompt used for multiline definitions in GHCi (delimited by “:{” and “:}”) ?
19:38:52 <geekosaur> aluminumtubes, lambdabot is not ghci, it only handles expressions
19:39:00 <geekosaur> unyu, no
19:39:04 <aluminumtubes> i mean it doesn't work for ghci either
19:39:09 <geekosaur> I thinkt hat's a "patches accepted" kind of thing...
19:39:13 <aluminumtubes> i thought semicolon could be used in place of new lines
19:39:30 <unyu> geekosaur: Ah, thanks! Will check.
19:39:49 <geekosaur> ghci 8.x should allow that (at least without the extra parens). 7.10 and earlier will need a "let"
19:40:11 <geekosaur> oh, no, that's not a separate equation, I see
19:40:19 <geekosaur> no, ghci is not smart enough to handle that correctly
19:40:28 <geekosaur> it's a bit of a hack, sadly
19:41:11 <aluminumtubes> i'm on 8.0.2
19:41:21 <aluminumtubes> are you saying it's a bug
19:41:29 <geekosaur> it "should" work, in theory, but pretty much anything that is not an expression has to be handled specially in ghci, ad ghci's special handling doesn't extend to combining a definition and an expression on the same line
19:41:42 <aluminumtubes> i see
19:42:25 <aluminumtubes> so why did my curry behave like uncurry?
19:42:25 <geekosaur> (or, more shortly: "yeah, it's dumb" :)
19:43:53 <geekosaur> because you got them backwards
19:43:56 <geekosaur> :t curry
19:43:58 <lambdabot> ((a, b) -> c) -> a -> b -> c
19:44:28 <geekosaur> first parameter is a function expecting tupled parameters
19:44:39 <aluminumtubes> oh i see
19:44:55 <aluminumtubes> thank you sirs
19:57:29 <mangobot> if i can only use Data.Char and a defined function splitOn, how can i parse a string into lists and then access list 1 for example in order to use it in a different function? any alternatives to (!! 0) ?
20:00:14 <geekosaur> pattern matching (x:_)
20:01:04 <geekosaur> > let f (x:_) = x in f [[1,2,3],[4,5,6]]
20:01:12 <lambdabot>  mueval-core: Time limit exceeded
20:01:12 <lambdabot>  mueval: ExitFailure 1
20:01:22 <geekosaur> derp
20:01:27 * geekosaur is too tired...
20:01:41 <geekosaur> hm, actually
20:02:09 <aluminumtubes> huh what's wrong with that line?
20:02:20 <exio4> > let f (x:_) = x in f [[1,2,3], [4,5,6]]
20:02:23 <lambdabot>  [1,2,3]
20:02:24 <geekosaur> nothing, bot's just slow
20:02:24 <exio4> nothing 
20:02:34 * geekosaur retried it in /msg
20:02:48 <geekosaur> still too tired for this I think :/
20:03:07 <geekosaur> > let f (_:x:_) = x in f [[1,2,3],[4,5,6]]
20:03:09 <lambdabot>  [4,5,6]
20:03:44 <dhalgren> let f (x:_) = x in f [[1,2,3],[4,5,6]]
20:03:55 <geekosaur> because a list [a,b,c] is actually (a:b:c:[])
20:03:56 <dhalgren> > let f (x:_) = x in f [[1,2,3],[4,5,6]]
20:03:59 <lambdabot>  [1,2,3]
20:04:06 <dhalgren> so it is fine
20:04:08 <geekosaur> the bracket syntax is just a convenient shorthand
20:04:40 <dhalgren> yeah but your mueval: Exitfailure 1 seems like some fluke: I just copy-pasted your very line
20:07:33 <bitemyapp> Lokathor: Yeah, I'm not reducing the page margins on the screen version. For the reasons merijn stated too.
20:07:49 <bitemyapp> It's not some superstition, people have tested the 46-72 character length limit
20:07:58 <mangobot> geekosaur thanks!
20:08:17 <geekosaur> yeh, I presume the VM was heavily loaded for a moment and the bot timed out without managing to do anything
20:08:52 <dhalgren> I see
20:09:07 <dhalgren> bitemyapp: yeah, don't go beyond 76ish
20:10:07 <geekosaur> but at first I thought I had repeated the wrong binding or something and created a loop :/
20:18:08 <mangobot> can someone give me a tip on how to use pattern matching here and instead of having multiple functions for the parseBoard combine it into 1? http://lpaste.net/352413
20:19:53 <ezyang> mangobot: General advice is to consider using a parsing library 
20:20:04 <ezyang> there's a simple one in base (ReadP) and you can also use parsec 
20:20:48 <mangobot> ezyang its an assignment so i can only use Data.Char and those utils
20:23:05 <ezyang> ok 
20:23:16 <ezyang> where you see l!!0 and tail l, you should turn that into a pattern match 
20:23:23 <ezyang> are you having syntax trouble? 
20:23:39 <threestrikes> I'm building a project in stack and I have a dependency that is needed but I have a newer version already listed that I need to rollback. Does anyone know how to do that?
20:24:28 <threestrikes> I tried listing the older dependency in my stack.yaml file but that didn't work.
20:25:00 <mangobot> ezyang yeah still a little confused about the syntax and the data types etc
20:26:27 <mangobot> ezyang so someting like this http://lpaste.net/352413
20:29:06 <kadoban> threestrikes: "newer version already listed" where, in what fashion? Can't you just ... remove it?
20:30:08 <ezyang> mangobot: Anywhere you see "foo ls = bar (ls!!0) (tail ls)" 
20:30:15 <ezyang> you can replace it with "foo (l:ls) = bar l ls 
20:30:28 <ezyang> give that a try on your previous code sample. Do one declaration at a time, keep it typechecking. 
20:31:02 <threestrikes> how do I remove it?  It's listed with "stack --list-dependencies
20:32:21 <ezyang> threestrikes: Does this work? http://stackoverflow.com/a/35392852/23845 
20:33:43 <mangobot> ezyang ok thanks!
20:35:28 <threestrikes> ezyang: no it doesn't that's what I originally tried. 
20:36:16 * ezyang has never used stack before lol 
20:39:09 <kadoban> threestrikes: Is there a stack.yaml for what you're building? How did you specify what versions of things to use? The usual way is with a resolver in stack.yaml and then you specify extra-deps, which if you want to stop using the newer versions, you just ... remove the extra-dep.
20:39:23 <kadoban> threestrikes: You should really specify more about what you've done.
21:03:25 <aluminumtubes> why do some people put semicolons at the front of the line in do blocks?
21:03:49 <aluminumtubes> it works the same if i move the semicolons to the back
21:03:56 <aluminumtubes> and it doesn't look weird
21:08:18 <ertes> aluminumtubes: that's a really good question…  i don't do it
21:08:51 <aluminumtubes> i guess it's a just stylistic preference
21:10:08 <ertes> it's more a declaration of war against every author with a sense of aesthetics =)
21:11:15 <aluminumtubes> i was trying to be tolerant but it might very well be
21:11:36 <ertes> aluminumtubes: of course in a vertical do-block you don't need semicolons at all
21:11:51 <ertes> you only need them when you use braces, or when you write multiple actions in a single line
21:12:50 <aluminumtubes> yes but i noticed the same trend with commas
21:13:08 <aluminumtubes> https://wiki.archlinux.org/index.php/xmonad#Configuration
21:13:25 <ertes> yes, you will also notice it with some associative operators like (.)
21:14:04 <vaibhavsagar> the parser doesn't accept trailing commas/semicolons afaik
21:14:49 <vaibhavsagar> so this way the separator lines up nicely with the curly braces and you don't accidentally miss one
21:15:30 <ertes> vaibhavsagar: that's not true
21:15:46 <ertes> the only thing you achieve by that is to move the singularity from the bottom to the top
21:16:25 <vaibhavsagar> I don't understand, how is the singularity moved?
21:16:44 <ertes> f,\\g,\\h  -- the last line is different from the others
21:16:55 <ertes> f\\, g\\, h  -- the first line is different from the others
21:17:14 <aluminumtubes> vaibhavsagar: i worked fine when i tried it, do you want me to pastebin?
21:17:24 <vaibhavsagar> which is why the opening brace goes there ertes
21:17:32 <ertes> BTW, you can have trailing commas in export lists
21:17:43 <ertes> vaibhavsagar: but that's a singularity
21:17:56 <ertes> you might as well put the closing brace on the last line
21:18:14 <vaibhavsagar> the closing brace goes in a line on its own
21:18:22 <ertes> why?
21:18:35 <vaibhavsagar> this is just the way I do it :)
21:18:45 <ertes> ok, but it's another stylistic choice
21:18:52 <aluminumtubes> ertes: what's a singularity?
21:18:53 <ertes> there is no technical reason to do it
21:19:14 <vaibhavsagar> https://github.com/vaibhavsagar/duffer/blob/4b63b2384ae8eaa903f5257403f98f9db7fb6d24/src/Duffer/Loose/Objects.hs#L36
21:19:28 <ertes> aluminumtubes: something where the usual rules don't apply…  something "weird", like a line without a comma among a number of lines, each ending with a comma
21:19:42 <vaibhavsagar> it's a stylistic choice, I wasn
21:20:04 <vaibhavsagar> 't claiming that it doesn't work any other way
21:20:28 <ertes> i promise that the punctuation-first choice is completely pointless…  the only way you could argue is that you think it looks better…  and then you should know that every self-respecting author would punch you in the face for a statement like that =)
21:20:57 <vaibhavsagar> I do think it looks better
21:21:12 <aluminumtubes> lol that's probably the original definition but this is the first time i've seen singularity used that way
21:21:24 <vaibhavsagar> and it's the style used in the the linked wiki article
21:22:37 <vaibhavsagar> https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md#data-declarations
21:23:27 <vaibhavsagar> I rest my case
21:24:51 <aluminumtubes> but that's just that guy's style
21:25:17 <ertes> you just got used to it, and that's fine…  just keep in mind this style is like alcohol: every time you start a line with punctuation, a few brain cells die =)
21:25:25 <vaibhavsagar> no, http://chrisdone.com/posts/hindent-5
21:25:39 <aluminumtubes> anyone who's used to english writes their commas so that it immediately follows word before it
21:26:25 <vaibhavsagar> this is the default style for the most commonly used code formatting tool in Haskell land
21:26:40 <ertes> so?
21:26:42 <vaibhavsagar> and by default I mean the only style
21:27:54 <ertes> linus torvalds said that code must be indented in tabs, and that a tab is 8 characters wide, "because K&R said it, and K&R are always right"
21:28:00 <vaibhavsagar> so you should format your code however you like, but don't threaten to punch me in the face for liking this one, I think that's unnecessary
21:28:18 <Sornaensis> hi does anyone have tutorials for monadic logging in haskell
21:28:33 <aluminumtubes> https://github.com/ghc/ghc/blob/master/compiler/types/Class.hs#L51
21:28:52 <aluminumtubes> but you're right i do see tibbe's style elsewhere in the code
21:29:19 <ertes> vaibhavsagar: you're taking this far more seriously than you should ;)
21:29:25 <ertes> if you like it, use it
21:30:19 <aluminumtubes> gosh looks i have to write my own indentor
21:30:30 <ertes> aluminumtubes: just use your editor
21:31:22 <monochrom> There was a time punctuation-first helped the indentation algorithm. I certainly did it back then.
21:31:32 <monochrom> SPJ did it but I don't know why.
21:31:58 <ertes> i believe that code should always be laid out for the reader, not for the editor
21:32:05 <ertes> that's why i line up my equal signs
21:32:41 <aluminumtubes> where's the fun in that
21:33:04 <aluminumtubes> vim doesn't indent properly for anything but c
21:33:23 <ertes> emacs sometimes fails to do it for me, so yes, this is manual work, and it's worth it just as much as it's worth to choose good names and write type signatures
21:33:39 <Sornaensis> vim indents just fine for me
21:33:52 <Sornaensis> I couldn't tell you what plugin does it. probably installed it 6 years ago
21:34:45 <monochrom> Let's take it to the extreme: http://lpaste.net/311978 :)
21:35:42 <vaibhavsagar> I weep at the beauty of this monochrom
21:35:51 <aluminumtubes> at first i thought that looked hideous
21:35:59 <aluminumtubes> but then i realised that it's not so bad
21:36:03 <monochrom> "code laid out for the reader, not for some machine requirement of balanced parentheses" :)
21:36:07 <Sornaensis> that is hilarious
21:36:31 <monochrom> inspired by this tweet: https://twitter.com/UdellGames/status/788690145822306304
21:36:34 <Sornaensis> why not just program in a language that compiles to lisp
21:37:46 <vaibhavsagar> I'd hate to edit code that way, but I actually wouldn't mind reading it in that format
21:38:04 <vaibhavsagar> hence Python and Haskell
21:38:10 <vaibhavsagar> problem solved
21:38:42 <monochrom> ML used to be compiled to Lisp.
21:45:25 <ertes> i kind of think that this style is an improvement over braces/parens =)
21:46:01 <ertes> i also think that haskell could use more layout
21:47:25 <vaibhavsagar> ertes, you might enjoy http://chrisdone.com/z/
21:47:27 <ertes> a few things still require braces and delimiters and would totally benefit from layout:  data constructors with field names, export/import lists, lists, …
21:48:39 <ertes> vaibhavsagar: not sure about that one =)
21:49:46 <vaibhavsagar> I don't think you can have more layout than that
21:50:04 <ertes> it should still give you the option to have *less* layout =)
21:50:07 <mangobot> i got a little confused with the data types and correct function arguments, could someone give me a tip here? http://lpaste.net/352416
21:50:50 <ertes> mangobot: what's your question?
21:52:25 <Lokathor> i use haskell mode in emacs sometimes, but i deliberately turn off its auto-indent system
21:52:26 <Lokathor> it's horrid
21:52:43 <vaibhavsagar> Sornaensis: do you mean using WriterT for logging or a do you have a specific framework in mind?
21:53:16 <ertes> Lokathor: haskell-mode has two indenters…  have you tried both?
21:53:18 <mangobot> ertes am i calling the parseFen function correctly in line 28? and the Board . map?
21:53:27 <ertes> there is the older indent-mode and the newer indentation-mode
21:53:54 <Lokathor> ertes, i'm sure that, this being emacs, both will fail to do what i want in vastly different ways. Instead, I just set it up to have each line copy the last line's indentation, and i handle it from there
21:54:31 <Lokathor> actually i've been editing haskell in notepad++ the most lately
21:54:38 <ertes> mangobot: you say:  [x, y] = parseFEN
21:54:52 <ertes> mangobot: so you're saying that parseFEN is a list
21:55:05 <ertes> mangobot: now look at the type of parseFEN and tell me whether that's correct
21:56:02 <mangobot> ertes right yes its a string
21:56:19 <ertes> Lokathor: yeah, that's not too bad i guess…  it would still be nice if backspacing could be a bit cleverer
21:56:28 <ertes> mangobot: nope
21:56:49 <ertes> parseFEN :: String -> [String]  -- it's not a list
21:57:02 <Lokathor> ertes, https://github.com/Lokathor/rcfiles/blob/master/emacs#L123
21:57:12 <aluminumtubes> have you guys tried yi
21:57:31 <aluminumtubes> maybe it formats haskell better
21:57:56 <Lokathor> aluminumtubes, unless it does exactly what notepad++ and my .emacs file do, it does not format haskell better. and if it does, i don't need it
21:58:05 <ertes> Lokathor: no, i wish it would jump in the steps indent-mode infers from the preceding text
21:58:33 <Lokathor> doesn't indent-mode go by tab-width?
21:58:50 <ertes> only if it has no contextual clues
21:59:04 <aluminumtubes> Lokathor: i thought you just criticised emacs haskell mode
21:59:12 <ertes> actually no, it doesn't at all…  if it can't figure it out, it will just not indent at all
21:59:43 <ertes> aluminumtubes: haskell-mode is far from perfect when it comes to indentation, and i doubt that any other editor can do it much better
22:00:02 <Lokathor> aluminumtubes, i did. that's why my .emacs file overrides haskell-mode indentation and just does "copy the last line's indentation"
22:00:14 <ertes> although indentation-mode gets really close, it has a few nasty quirks that are just annoying enough to make me use indent-mode instead
22:00:28 <aluminumtubes> oh
22:00:34 <ertes> and indent-mode is not super-helpful
22:00:48 <aluminumtubes> i thought yi might be better because it's made by haskell people
22:00:51 <aluminumtubes> but i haven't tried it yet
22:01:29 <ertes> structured-haskell-mode may be the best approach i've seen conceptually
22:01:47 <Lokathor> copying the last line and letting the user take it from there is the best way to handle haskell indentation that i've seen so far
22:01:51 <ertes> but unfortunately it hardcodes a certain code style, and i don't like it
22:02:16 <ertes> Lokathor: structured-haskell-mode is better – conceptually
22:02:27 <Lokathor> whats it make code look like?
22:02:38 <ertes> Lokathor: have you ever used paredit?
22:02:44 <Lokathor> nope
22:03:02 <ertes> Lokathor: it's best explained as: "what paredit does, but for haskell"
22:03:06 <Lokathor> oh it's an emacs thing
22:03:29 <ertes> unfortunately you can't really configure the style it produces
22:03:32 <Lokathor> disclaimer: I hate emacs throughly and wish that it wasn't the best at the few things it's the best at
22:03:53 <ertes> and that would be an important feature for it to be useful, unless you agree 100% with the style choices that are built in
22:03:55 <aluminumtubes> best at being everything except being an editor?
22:04:16 <aluminumtubes> sorry i couldn't resist
22:04:27 <Lokathor> aluminumtubes, emacs is honestly the best at editing remote files directly via SSH when you're on windows
22:04:38 <Lokathor> that is roughtly where the list ends
22:05:14 <aluminumtubes> ertes: oh it's made the by that guy who's very intolerant of other's style choices
22:05:37 <aluminumtubes> Lokathor: that is a nice feature indeed
22:05:42 <ertes> aluminumtubes: i don't know if he's intolerant, but i don't agree with his style choices =)
22:06:02 <Lokathor> my code style looks like this, https://github.com/Lokathor/galaxy-break/blob/master/lib/GalaxyBreak.hs
22:06:15 <Lokathor> but i could imagine slightly different styles working out
22:06:23 <ertes> emacs is a monster…  in an ideal world we would use emacs to write a better editor that gets the things right emacs gets wrong =)
22:06:37 <ertes> but we don't live in an ideal world, so i use emacs for doing other things =)
22:07:42 <aluminumtubes> ertes: he's the guy that made the indentor that supports one style only
22:08:04 <Lokathor> with rust, i didn't have a super favorite style, so i tried the rustfmt tool
22:08:07 <Lokathor> and it's good enough
22:08:20 <Lokathor> with java, eclipse can format your code in all sorts of ways
22:08:28 <Lokathor> haskell will one day have a good tool.
22:08:31 <Lokathor> but it's not today
22:10:39 <ertes> perhaps when we no longer write code ourselves, we can instruct our super-human AI assistant to write such a tool for us…  but then nobody would use it
22:10:58 <Lokathor> at least it'd avoid using \t probably
22:13:44 <oelewapperke> ertes: come now, we'd have that AI also write another super-human AI assistant to use such a tool for us too
22:13:45 <ertes> the craft of programming reduced to artistic self-expression…  haskell has a lot of that even today, while the rest of the world clicks around in visual studio…  kinda depressing thought
22:26:04 <monochrom> No no, look at the trajectory of the mouse while one clicks in visual studio. You will see artistic expression there. :)
22:26:30 <monochrom> You may even see postmodern caligraphy!
22:42:08 <ertes> i couldn't see it if it were right in front of me…  my brain rejects the very idea that VS and art could be related in any way =)
22:43:39 <monochrom> When I did programming assignments, I would listen to a piano concerto or something, and sync my keystroke with the music.
22:43:51 <monochrom> Talk about program performance.
22:45:07 <ertes> reinforcing the fact that performance does not lead to efficiency
22:45:14 <monochrom> Sometimes I also did it while entering LaTeX code for the math assignments.
23:10:58 * nshepperd . o O (train some deep learning system to DWIM when indenting haskell)
23:11:40 <c_wraith> I mean, I'm sure I could summarize my haskell indentation policy in only a few thousand rules.
23:14:46 <nshepperd> hm, it ticks all the boxes - reasonably local, not *hugely* complex (but complex enough that coding the rules by hand would be annoying), huge training data set (hackage)
23:19:55 <c_wraith> hackage is not a good training set
23:20:08 <c_wraith> it has at least 10s, possibly hundreds, of distinct styles
23:21:03 <vaibhavsagar> solution: preprocess by running hindent on hackage
23:21:06 <nshepperd> good, so you can choose your style :)
23:22:26 <c_wraith> hasn't hindent gone to a style that no one uses without customization options now?
23:27:58 <nshepperd> packages are labeled by author, so we can learn about the latent space of indenting styles and provide an option for that. hindent will certainly also be useful as a way of canonicalizing the training set so that we can learn to automatically reformat your files in any of the hackage styles
23:30:53 <jle`> i don't think hackage can be called a huge data set by typical deep learning standards
23:31:11 <jle`> but what do i know
23:32:21 <dmj`> acid state is big data
23:33:04 <nshepperd> maybe not 'huge'
23:34:49 <flxw> Hello all. from the stack command line, is there a way to see which resolvers are available? e.g. prior to running stack init.
23:36:22 <MarcelineVQ> not that I'm aware of, you can use any resolver on https://www.stackage.org/ though  by specifying like so   stack init --resolver lts-7.19
23:37:05 <MarcelineVQ> often you'll want the --solver flag as well with init
23:37:37 <flxw> I see. Yeah, this is true. :)
23:39:56 <flxw> Usually I'm fine with whatever resolver stack init suggests. But in the particular case, it suggested 8.0 with needs ghc 8.0.2, which I haven't installed on that system. So I wanted to just pick the largest 7.x before 8.0, I couldn't remember the version number, though. 
23:40:34 <MarcelineVQ> ah yeah, there's a list for that on the front of https://www.stackage.org/ luckily
23:40:56 <kadoban> Yay there's a 8.0.2 resolver now
23:41:47 <flxw> I'll write a script to fetch that information. :)
23:42:16 <MarcelineVQ> I'm surpised there isn't an api to a lot of things on stackage.org, or at least not a well-advertised one
23:42:47 <nshepperd> (actually hackage is about 5GB of haskell code going by a small estimate, more than enough O_O)
23:45:32 <flxw> lol, had I run stack init yesterday, I would still have gotten 7.19 I learnt just now.
23:51:38 <kadoban> flxw: By the way: stack init --resolver lts-7   works
23:53:26 <kadoban> (also usable with 'stack new')
