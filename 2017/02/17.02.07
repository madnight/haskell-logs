00:43:21 <absence> "stack init" tells me "Fetching package index ...fatal: Not a git repository: '.git'"
00:43:42 <absence> anyone know what could be wrong?
00:47:48 <laz> absence: looks like global stack cache is corrupted
00:48:07 <laz> absence: try to clean ~/.stack
00:57:01 <absence> laz: thanks. i had already cleaned AppData\Local\Programs\stack, but there was an AppData\Roaming\stack that i missed
01:01:53 <tfc> hi there, i built a little applicative parser and i would like someone to look over it to tell me if there is a better way to express it
01:01:54 <tfc> Prelude Text.ParserCombinators.Parsec> parse ((manyTill anyChar $ string "FOO") *> (many $ oneOf ['0'..'9']) <* (string "BAR")) "foo" "bla bla FOO123BAR bla"
01:15:17 <erisco> jle`, I have now defined and proven the total and strict total orders for Nat :)
01:15:29 <jle`> congrats :o
01:16:06 <erisco> negation is still a bit of a strange beast... I found you can also use it to prove branches are dead
01:16:13 <erisco> though I am not sure how well GHC recognises this
01:16:25 <erisco> i.e. you find a contradiction
01:16:54 <jle`> the extent that i've used it in haskell/ghc is just from empty case statements more or less, heh
01:17:10 <lyxia> tfc: that looks good
01:17:19 <erisco> jle`, like this proof here http://lpaste.net/352160
01:18:07 <erisco> so you reach a context where you can construct a :<= proof, such as LteZ n, and then you pass this to the negation proof to find Void
01:18:08 <jle`> nice :)
01:18:12 <tfc> lyxia: thx. how would you change it in order to allow for strings like "bla FOO blabla FOO123BAR" ?
01:18:30 <erisco> which feels a bit odd because we're kinda in a way backtracking
01:18:43 <jle`> it feels weird at first, but yeah, you kind of get used to it
01:18:47 <erisco> we're saying that m can be SZ but oh no wait that is a contradiction
01:18:50 <tfc> lyxia: right now it would error out and i would need to use some kind of a "try" statement ,but i feel uncomfortable with that because i could quickly buffer overflow
01:19:35 <erisco> I couldn't think of any other way to do this proof other than by induction on m and n
01:20:03 <erisco> or recursion I guess
01:22:34 <erisco> jle`, I was happy to realise := for *
01:22:46 <erisco> so that I can prove (a :< b) := Not (b :<= a)
01:23:00 <jle`> :o
01:23:06 <jle`> that gives you the two way implication doesn't it
01:23:12 <erisco> yes
01:24:22 <erisco> though unlike := for Nat, these aren't equivalent types
01:24:34 <erisco> so it cannot be promoted to the context
01:24:39 <erisco> (or derived from the context)
01:25:21 <jle`> oh i see
01:26:19 <erisco> Iso :: { fwd :: a -> b, bwd :: b -> a } -> a := b
01:26:52 <erisco> and of course I prove := is an equivalence relation for all instances
01:27:15 <BernhardPosselt> hi, just wondering if this very simple/naive maybe implementation is similar to the one implemented https://dpaste.de/u17Z
01:27:50 <erisco> because you can mix families and classes it is easy to stipulate the properties along with the data family
01:28:41 <jle`> BernhardPosselt: you're missing a few parentheses, but, yeah
01:30:04 <BernhardPosselt> jle`: yeah, just realised now :D
01:30:09 <BernhardPosselt> Just (f x)
01:30:40 <BernhardPosselt> so basically the only difference between map and flatMap/concatMap for maybe is that map needs to wrap it in a maybe again
01:30:54 <BernhardPosselt> whereas flatMap just returns the value from the function
01:31:17 <jle`> well, that's the difference in how they're implemented
01:31:26 <jle`> conceptually, there are deeper consequences
01:31:45 <jle`> map for Maybe cannot change whether or not a value is Nothing or Just
01:31:52 <jle`> but flatMap/bind can
01:32:09 <BernhardPosselt> so you could return an IO monad from bind?
01:32:26 <jle`> er, that's not what i meant, and it doesn't really make sense either
01:32:42 <jle`> i mean that no matter what function you map, you can't change a Nothing to a Just or a Just to a Nothing
01:33:03 <jle`> but if you use flatMap/bind, you can decide whether or not the result is Just or Nothing based on any potential values that the Maybe might contain
01:33:16 <jle`> that's the extra power you get with bind for Maybe
01:33:26 <jle`> (that you don't have with fmap)
01:33:55 <jle`> er, to be more precise, the function that you flatmap/bind has the power to say whether or not the result is Just or Nothing
01:34:31 <jle`> but, for 'map'/'fmap', the function you pass can't change Nothing/Justness, no matter what
01:35:58 <jle`> people commonly say that map/fmap necessarily preserves 'structure', but bind doesn't have to.
01:36:40 <jle`> in the case of IO, "structure" can be thought of as "effects"; so, fmap/map for IO can never change the effects that that IO action encodes
01:36:57 <jle`> you can fmap any function you want onto an IO action, and it won't change its effects
01:36:59 <BernhardPosselt> i see :)
01:37:28 <erisco> the preservation coming from the requirement fmap id = id
01:37:38 <jle`> but, for >>=/bind on IO, the function bind has the ability to determine what effects your resulting IO action has
01:37:50 <jle`> *the function that you bind
01:38:07 <jle`> just like for how Maybe, the function that you bind has the ability to determine whether or not the resulting value is Just/Nothing
01:40:26 <lyxia> tfc: Sorry for the delay. I think that the manyTill should be moved out. manyTill anyChar . try $ string "FOO" *> many digit <* string "BAR". But was is the try there that worried you or were you using it in another way?
01:41:20 <tfc> lyxia: what bugs me is that i need to tell the parser "drop all the garbage which might prepend my FOO123BAR content."
01:41:40 <tfc> lyxia: and manyTill was my only idea of how to do that
01:42:11 <lyxia> oh I see, manyTill keeps the repeated results and not the end
01:42:23 <BernhardPosselt> concerning algebraic datatypes: when you create a list/tree you need modify nodes. since everything is non mutable how do you do that? construct a completely new tree/list?
01:43:03 <Logio> short answer: yes
01:43:04 <jle`> BernhardPosselt: you don't have to construct a completely new one; because everything is immutable, you can use sharing
01:43:10 <erisco> you must reconstruct the path from the node to the root
01:43:27 <BernhardPosselt> but the compiler can optimize it i suppose
01:43:32 <erisco> no
01:44:28 <lyxia> tfc: looks like the combinator doesn't exist in parsec
01:44:42 <BernhardPosselt> jle`: what do you mean by sharing?
01:44:52 <lyxia> tfc: I suppose because it's not so common that you're just throwing away information.
01:45:20 <mfukar> dminuoso , QAM. Turns out you can easily achieve optimal or near-optimal minimal distances w/ Gaussian integer constellations
01:45:39 <jle`> BernhardPosselt: if you want to, say, add an item to the front of a list
01:45:45 <jle`> you don't have to make a copy of the original list
01:45:53 <jle`> your result can refer to the original list
01:45:54 <BernhardPosselt> right
01:46:17 <BernhardPosselt> however if i want to append something or put it inside the list
01:46:19 <jle`> same principle here; if you change a part of your immutable data structure, you can usually reference a lot of the original structure
01:46:26 <jle`> you can often share a lot
01:46:45 <tfc> lyxia: hm i see. in my case it's just that i get a lot of content from the internet and i like parsers more than using regex. but in regex i can say "get me /FOO([0-9]+)BAR/, group 1 of all matches"
01:47:24 <erisco> if you want append then you use Sequence. There are different data structures for different jobs
01:47:29 <tfc> lyxia: while the "/FOO..." part says "start matching at FOO, i don't care about the rest". and if this "i dont care" thing is nicely expressible in parsec, i've got what i want
01:47:50 <tsahyt> hmm, am I missing something or is there no simple way to transform a HashMap Foo a to HashMap Bar a?
01:47:55 <tsahyt> i.e. map over the keys
01:48:25 <erisco> :t (M.mapKeys, M.mapKeysMonotonic)
01:48:27 <lambdabot> Ord k2 => ((k1 -> k2) -> M.Map k1 a -> M.Map k2 a, (k4 -> k5) -> M.Map k4 a1 -> M.Map k5 a1)
01:48:51 <tsahyt> but mapKeys doesn't exist for HashMap
01:49:00 <erisco> oh, HashMap, heh :)
01:50:07 <lyxia> tfc: foobar = string "FOO" *> many digits <* string "BAR"   is your pattern. Then you search it anywhere with a wrapper like:   search foobar = try foobar <|> (anyChar *> searchFoobar)
01:50:38 <laz> tsahyt: you can't extract keys from hash map as it stores only hashes
01:50:49 <tsahyt> laz: yes you can extract them
01:51:00 <tsahyt> keys :: HashMap k v -> [k] exists
01:51:32 <tfc> lyxia ok, that looks already nicer than what i came up before. 
01:51:57 <tsahyt> laz: it stores the keys along with the hashes for when collisions occur. that's also why the Eq constraint exists on pretty much all the functions provided.
01:51:57 <erisco> well you can define it with toList and fromList
01:52:05 <tsahyt> erisco: yeah, I think that's what I'll do
01:52:10 <erisco> you have to rebuild the whole hash anyways
01:52:15 <tsahyt> I was hoping for a nicer way though
01:52:23 <laz> tsahyt: oh, really
01:53:20 <tsahyt> laz: yeah, otherwise the structure would have some very undesireable properties. the same is also done with other hashtable implementations in pretty much any language. collisions must always be accounted for.
01:54:08 <erisco> meh, what is the statistical likelihood of collision?
01:54:58 * erisco has algorithm class flashbacks
01:55:25 <tsahyt> depends on the hash function used and the size of the table (talking about hash tables in general, not necessarily just HashMap)
01:55:34 <tsahyt> with a small table, it actually becomes very likely
01:56:02 <tsahyt> with HashMaps, probably not so much, but I don't know enough about the implementation details to say that with certainty
01:58:02 <erisco> well it is an IntMap which iirc uses the word size of the machine, or maybe it is just 32 bits
01:58:53 <erisco> depends on the distribution of the hash function and how full the table is
01:59:06 <tsahyt> erisco: afaik it's not exactly an IntMap anymore. e.g. HashMap Int has different performance characteristics from IntMap, even though hashing an Int is just id
01:59:30 <tsahyt> in my benchmarks, HashMap Int was faster for lookups, yet slower for insertions than IntMap
02:02:47 <erisco> actually I think the size is relevant because of the effects modulo will have
02:04:10 <erisco> also you can consider the data you are inserting
02:04:28 <erisco> are they going to be near-valued or not
02:04:47 <erisco> an overly complicated subject the whole thing is
02:04:59 <tsahyt> it depends both on hash size and how the data you're dealing with is going to be inserted. for Int there shouldn't ever be collisions, as hashes are also just Ints
02:05:20 <erisco> the "perfect hash"
02:06:28 <tsahyt> erisco: yes, because both the domain and codomain of the hashing function have the same size in that case.
02:06:38 <tsahyt> so the hash function can be a bijection
02:07:23 <tsahyt> but most of the time, you're mapping an infinite space onto a finite space, e.g. Text -> Int, so collisions must necessarily exist.
02:07:45 <tsahyt> theoretically infinite that is, unless someone discovers a way to have infinite memory.
02:07:46 <cocreature> an identity hash on ints seems like a great idea until you try using it for hyperloglog
02:08:14 <tsahyt> cocreature: I'm not that familiar with hyperloglog. why would that cause problems there?
02:08:48 <erisco> you can have infinite memory given infinite time :)
02:09:46 <erisco> though, um, I don't know about random access
02:10:19 <cocreature> tsahyt: in a lot of applications your ints are always in some specific range meaning that the top bits are more or less equal. hyperloglog uses these to index into an array. this will often mean that you only use a single element of your array
02:10:43 <tsahyt> is there a more general way to do unionWith? I'm looking for (v -> v -> a) -> HashMap k v -> HashMap k v -> HashMap k a basically
02:11:03 <opqdonut> what do you do with keys that are only in one map?
02:11:12 <opqdonut> you need a (v -> a) for those, right?
02:11:18 <tsahyt> hmm, good point. yeah I'd need that too
02:11:33 <tsahyt> acutally I'd want two of these, because I want to handle them differently depending on what map they came from
02:12:41 <opqdonut> you can use intersectionWith to handle the elements that are in both
02:13:01 <opqdonut> it's (a -> b -> c) -> Map k a -> Map k b -> Map k c
02:13:57 <tsahyt> Data.Map has this mergeWithKey function that is fully general. Of course, HashMaps don't have that either...
02:14:28 <opqdonut> oh right you're on hashmaps
02:14:57 <tsahyt> since the second map is derived from the first, I might as well just write it all as a fold at that point
02:41:01 <tsahyt> @hoogle Bifunctor f => (a -> b) -> f a a -> f b b
02:41:04 <lambdabot> Data.Bifunctor first :: Bifunctor p => (a -> b) -> p a c -> p b c
02:41:04 <lambdabot> Bifunctor first :: Bifunctor p => (a -> b) -> p a c -> p b c
02:41:04 <lambdabot> Data.Bifunctor second :: Bifunctor p => (b -> c) -> p a b -> p a c
03:01:41 <nmattia> barrucadu: do you have examples of people using deja-fu for File I/O?
03:14:12 <erisco> jle`, what other kinds are interesting other than Nat? of course you could have integers and rationals and so on, but what else other than numbers?
03:15:17 <erisco> so many things can be built from Nat it is rather remarkable
03:29:26 <ij> Say you've a complex function of a sum type to another type. Would it be possible to prove that a value obtained by applying a non-bottom sum type to a pattern matching function is non-bottom?
03:36:01 <opqdonut> ij: sure, just go through the cases
03:36:31 <reactormonk> How do I ask the question "does this .cabal file somehow transitively depend on X?"?
03:44:49 <opqdonut> reactormonk: I think "cabal freeze" tells you that
03:45:20 <reactormonk> opqdonut, do I have to pass it additional flags?
03:46:05 <opqdonut> reactormonk: well with --dry-run you only get the output, without modifications to your .cabal file
03:46:35 <reactormonk> opqdonut, thanks
03:49:34 <merijn> dfeuer: You're working on containers, right?
04:25:13 <Profpatsch> Is the strictContents fh = T.getContents fh >>= \s -> seq (T.length s) s
04:25:16 <Profpatsch> tick
04:25:35 <Profpatsch> *trick the way to go?
04:25:59 <merijn> Profpatsch: eh, getContents for strict Text is already strict
04:26:07 <merijn> Profpatsch: So..."no"? :)
04:26:30 <Profpatsch> merijn: Hm, for non-strict stuff like String?
04:26:54 <merijn> Profpatsch: getContents in base is lazy, the ones from Text/ByteString are only lazy IO for the lazy versions
04:26:59 <Profpatsch> merijn: That means if my code reaches T.getContents it will always read the handle at that second?
04:27:20 <merijn> Profpatsch: Assuming T is a qualified import of strict Text, yes
04:27:40 <Profpatsch> Because I had the problem that the handle was closed once the server tried to read the actual values from the handle.
04:27:49 <Profpatsch> (on page refresh in my case)
04:29:17 <merijn> Profpatsch: That shouldn't happen with the strict versions
04:29:36 <merijn> Profpatsch: Did you (perhaps) accidentally close the handle elsewhere/leak the handle from a bracket?
04:29:38 <BernhardPosselt> how would i partially apply reverse (map (map toUpper) ["hi", "ho"])
04:29:45 <BernhardPosselt> so that the list can be passed in
04:30:20 <merijn> :t reverse . map (map toUpper)
04:30:22 <lambdabot> [[Char]] -> [[Char]]
04:30:29 <Profpatsch> merijn: I wrapped withBinaryFile, like so: http://lpaste.net/352165
04:30:29 <BernhardPosselt> ty
04:30:35 <Profpatsch> Maybe that caused the problem.
04:32:36 <merijn> Where's withBinaryFile from?
04:32:40 <Profpatsch> But I can’t see how that could happen, really.
04:32:48 <Profpatsch> system.IO
04:33:54 <Profpatsch> The handle stuff should be wrapped in readBinaryFile me thinks.
04:34:05 <merijn> hmmm, that's odd, I don't suppose you have minimal example
04:34:46 <Profpatsch> OH
04:34:53 <Profpatsch>     s <- BL.hGetContents h
04:34:55 <Profpatsch>     BL.length s `seq` pure s
04:34:57 <Profpatsch> y
04:35:12 <merijn> Lazy bytestring, looks like?
04:35:15 <Profpatsch> Like you said, BL.hGetContents is lazy indeed.
04:35:20 <merijn> Yeah, that's the issue
04:36:04 <Profpatsch> So my function is http://lpaste.net/352166
04:36:51 <merijn> simply replacing that with strict bytestring should avoid the 'seq' + length bit
04:37:04 <merijn> Also, this hack attempt at forcing it is subtly broken :p
04:37:14 <Profpatsch> how?
04:38:32 <merijn> 'seq x y' causes 'x' to be forced when 'seq x y' is forced, but nothing in that code actually forces 'seq x y'
04:38:45 <Profpatsch> Ah, I missed the aeson eitherDecodeStrict' function.
04:39:15 <Profpatsch> merijn: Hm, it at least didn’t throw a closed handle error once I inserted that.
04:40:33 <Profpatsch> merijn: Does the same apply to B/BL.hPut?
04:40:47 <Profpatsch> Will hPut defer if the bytestring is lazy?
04:41:28 <hpc> the "lazy" in "lazy bytestring" is the same as the lazy in []
04:41:54 <Profpatsch> aeson only exports an encode function to lazy BS
04:41:55 <hpc> it just means the bytestring is an ordinary list of strict bytestring "chunks"
04:42:08 <hpc> following non-strict semantics for evaluation
04:42:20 <hpc> lazy IO is on a different axis
04:42:21 <Profpatsch> So if I say BL.hPut $ decode …, will it defer the actual writing? 
04:42:25 <hpc> no
04:42:34 <hpc> read the documentation for hPut, it will say if it does lazy IO
04:42:44 <hpc> very few things do, and they are all very explicit about doing so in their haddock
04:43:25 <Profpatsch> Ah, the hPut function is the same for all variants of ByteString.
04:43:36 <Profpatsch> hpc: merijn Thanks for the help.
04:43:44 <Profpatsch> That’s enlightening.
04:44:20 <merijn> People drastically overestimate the amount of lazy IO in base
04:45:11 <noan> (Foo Bar) is a tuple of 2 right?
04:45:15 <noan> that's haskell notation for it?
04:46:33 <lyxia> Foo Bar is the constructor Foo applied to Bar. (Foo, Bar) is a tuple of Foo and Bar.
04:47:14 <systadmin> > length (Foo, Bar)
04:47:17 <lambdabot>  error: Data constructor not in scope: Fooerror:
04:47:17 <lambdabot>      • Data constructor not in scope: Bar
04:47:17 <lambdabot>      • Perhaps you meant one of these:
04:47:47 <noan> can't be that then.. type: Foo (Bar Baz) is just a chain of constructors then?
04:49:07 <Reisen> Would it look less strange to you if it were slightly more descriptive names? I.E, Array (Maybe Unit)?
04:51:01 <Ferdirand> we don't even know if you are talking about expressions or types
04:51:08 <noan> Ferdirand, type.
04:53:02 <noan> It's App (Key User) where App is https://hastebin.com/olehumurit.hs User is a simple data type, and Key is something off persistent I'm still looking for in a moment
04:54:20 <BernhardPosselt> got this: ifFunc True val _ = val
04:54:20 <BernhardPosselt> ifFunc _ _ val = val
04:54:27 <BernhardPosselt> ifFunc (1 < 3) "correct" "incorrect"
04:54:32 <BernhardPosselt> spits out "incorrect"
04:54:40 <BernhardPosselt> why doesnt it match True?
04:55:30 <Ferdirand> BernhardPosselt: works for me
04:55:36 <BernhardPosselt> ghci btw
04:55:48 <lyxia> > let ifFunc True val _ = val ; ifFunc _ _ val = val in ifFunc (1 < 3) "correct" "incorrect"
04:55:50 <Ferdirand> maybe you shadowed ifFunc ?
04:55:51 <lambdabot>  "correct"
04:56:02 <Ferdirand> did you give the two clauses in separate lets ?
04:56:18 <BernhardPosselt> i pasted in my two lines
04:56:26 <BernhardPosselt> and then pasted in ifFunc (1 < 3) "correct" "incorrect"
04:56:29 <BernhardPosselt> and executed it
04:56:33 <lyxia> if you did this in ghci then you wrote two functions
04:56:39 <lyxia> and the second one shadows the first
04:56:45 <BernhardPosselt> i see
04:56:57 <BernhardPosselt> is there a neat way to combine it without let?
04:57:39 <Ferdirand> stick in a file ?
04:57:46 <BernhardPosselt> ;D
04:57:55 <lyxia> in ghci you can use :{    :} to wrap a multiline definition
04:58:14 <BernhardPosselt> ok, seems you can also do ifFunc True val _ = val ; ifFunc _ _ val = val
05:07:23 <BernhardPosselt> is there a way to show the type/type class of Maybe?
05:07:26 <BernhardPosselt> in ghci
05:07:30 <BernhardPosselt> :t Nothing works
05:07:32 <lambdabot> error:
05:07:32 <lambdabot>     • Couldn't match expected type ‘t0 -> t’
05:07:32 <lambdabot>                   with actual type ‘Maybe a0’
05:07:34 <BernhardPosselt> :t Maybe doesnt
05:07:36 <lambdabot> error:
05:07:36 <lambdabot>     • Data constructor not in scope: Maybe :: t0 -> t
05:07:36 <lambdabot>     • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
05:08:22 <BernhardPosselt> ah
05:08:24 <BernhardPosselt> :info Maybe
05:08:30 <Axman6> BernhardPosselt: try :info (and maybe also :kind)
05:16:17 <BernhardPosselt> what do you use for returning a result that can hold a value or an error? Either seems very low level
05:16:26 <BernhardPosselt> e.g. in Rust you can use Result https://doc.rust-lang.org/std/result/
05:16:42 <BernhardPosselt> which allows you to map over results if no error is present
05:16:58 <BernhardPosselt> or execute further code if no error is present
05:17:10 <hpc> Either is that thing
05:17:46 <hpc> if you want to add short-circuiting with an error value to some other sort of computation, consider ErrorT
05:17:54 <hpc> (or ExceptT, i can never remember the difference between them)
05:18:13 <opqdonut> https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html
05:18:20 <BernhardPosselt> thanks!
05:20:13 <phadej> hpc: ErrorT is deprecated (it restricts what kind of errors can be thrown)
05:21:50 <hpc> ah, that's it then
05:23:41 <absence> @let import Data.List.NonEmpty
05:23:42 <lambdabot>  Defined.
05:23:48 <absence> :t \f fz (a :| as) -> foldl' f (fz a) as
05:23:49 <lambdabot> (b -> a -> b) -> (a -> b) -> NonEmpty a -> b
05:24:01 <absence> is there something like this in the libraries?
05:25:41 <opqdonut> well there's the Foldable NonEmpty instance
05:25:46 <opqdonut> but that's not quite what you want?
05:26:16 <Aravindh> Can someone tell me a streaming library in haskell? like akka streams for scala
05:26:39 <absence> opqdonut: it doesn't quite seem to fit, but maybe i haven't thought it through properly
05:28:25 <absence> opqdonut: the Foldable instance requires a constant "zero" value, but i don't have a way to make one
05:29:13 <opqdonut> absence: foldl1?
05:29:34 <magthe> Any intero users in here? I'm trying out intero in spacemacs and get an error when compiling a "setup-shim": http://lpaste.net/352128
05:29:46 <quchen> Aravindh: pipes or conduit are our standard streaming libs
05:30:20 <Aravindh> @quchen: Thank you
05:30:21 <lambdabot> Unknown command, try @list
05:30:41 <Xnuk> @list
05:30:41 <lambdabot> What module?  Try @listmodules for some ideas.
05:30:52 <Xnuk> @listmodules
05:30:52 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
05:30:52 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
05:31:34 <absence> opqdonut: it's "f a -> a" rather than "f a -> b"
05:32:11 <opqdonut> absence: ah yes because it doesn't have the fz, that makes sense
05:32:18 <opqdonut> absence: I think you'll have to define your own
05:33:09 <Aravindh> quchen: Thank You
05:35:10 <absence> opqdonut: i seem to run into similar problems quite often when working with NonEmpty. makes me feel like i'm missing something, or that it's less useful than i imagine :)
05:35:39 <BernhardPosselt> why doesnt Monad Maybe define return https://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Base.html#line-665
05:35:51 <BernhardPosselt> can it be derived automatically from the Monad defintition?
05:36:13 <BernhardPosselt> e.g. only Just matches the type in return (a -> m a)
05:36:59 <phadej> BernhardPosselt: lookup 'Monad m where' i.e the definition of Monad class
05:37:09 <phadej> it says 'return = pure'
05:37:49 <phadej> i.e. you can omit return definition starting from base-4.8 / GHC 7.10 IIRC
05:37:50 <BernhardPosselt> ah
05:37:55 <BernhardPosselt> default implementation?
05:38:09 <phadej> yes
05:38:17 <BernhardPosselt> ty
05:40:37 <systadmin> Just a quick question, what does the `IO ()` type do?
05:41:18 <merijn> systadmin: Depends on what you mean by "what does X type do"?
05:41:28 <phadej> hard question indeed
05:41:32 <merijn> systadmin: Can you elaborate what you want to know?
05:41:54 <systadmin> Like the `IO` used in this piece of code? http://sprunge.us/VEXO?haskell
05:41:58 <m4lvin> systadmin: something of type IO () can do any IO operations but only return something of the empty type, so in some sense nothing.
05:42:14 <Xe> systadmin: IO is a type that orders execution of its functions and data, haskell is normally unordered
05:42:15 <merijn> systadmin: I mean, type don't really do anything
05:42:31 <merijn> Xe: That's...not right
05:42:42 <merijn> Types don't "order" anything
05:43:08 <Denommus> we could try to understand what he meant instead of what he said
05:43:20 <Xe> no, but the runtime and compiler do use the RealWorld tokens to order execution
05:43:21 <merijn> And IO certainly doesn't turn Haskell from unordered to ordered execution. Especially considering (GHC) haskell has a pretty well-defined order
05:43:40 <merijn> Denommus: I'm awaiting clarification, because it's not enough for me to guess what he is really asking
05:43:51 <m4lvin> ^this.
05:44:16 <barrucadu> nmattia: Unfortunately I don't, no
05:44:23 <merijn> Xe: The runtime doesn't use RealWorld at all and you're better off forgetting it's existence, because it's really not a helpful fact to know. Especially considering the unfortunately chosen name
05:45:48 <merijn> systadmin: I've always liked the "IO as program fragments" explanations. Values with an IO type can be thought of as 'fragments' of a program that describe some behaviour. For example, 'getLine :: IO String' is the description of how to read a line from stdin. These fragments can be composed into bigger components
05:45:53 <Denommus> systadmin: you use the IO type in general to perform side effects (such as operating with files). IO () specifically is the type of a function that might perform some side effect but doesn't evaluate to a value
05:46:04 <merijn> Denommus: Haskell doesn't have side effects
05:46:11 <merijn> That's the entire point
05:46:35 <systadmin> So IO doesn't really give me an output?
05:46:55 <merijn> They're called *side* effects because they're invisible in the type of a function. In haskell they *are* visible, so they're not *side* effects, they're just *effects*
05:47:09 <merijn> (they happen "on the side" of the function's execution)
05:47:22 <merijn> systadmin: Let's take a step back
05:47:38 <merijn> systadmin: You've probably heard 'Haskell is pure', yes?
05:47:53 <systadmin> I guess so
05:48:00 <Denommus> merijn: meh. I believe that's just a confusing statement that helps nobody. "Haskell doesn't perform side-effects, instead it generates instructions that actually perform side-effects". Ok, you can say the same thing about C. You actually program with the pure macro language, that generates actual expressions that perform side-effects. Big deal
05:48:47 <merijn> systadmin: So, what does this mean? It means that "a function, when given the same input, will always give the same output" and also that you whether a function is evaluated zero, once, or twice, doesn't impact the rest of your program
05:48:55 <lpaste_> KyleFang pasted “How to instance Monad?” at http://lpaste.net/352172
05:49:27 <merijn> systadmin: So, let's think about a non-existent 'putStrLn :: String -> IO ()', well if that immediately printed something to stdout, we'd pretty obviously lose purity
05:49:42 <Denommus> http://conal.net/blog/posts/the-c-language-is-purely-functional
05:50:05 <merijn> Denommus: My stance is that pedantic correctness is important when teaching beginners to avoid letting subtle confusions slip in and propagate
05:50:50 <kylefang> hey guys, really new to haskell, trying to write a Maybe look alike... having trouble finding the example source to follow. this is what I've current at http://lpaste.net/352172 . Can you point me at some syntax guide or example code maybe?
05:51:08 <merijn> systadmin: Well, if we take the IO as program fragments interpretation 'putStrLn :: String -> IO ()' is fine. If we call it with the same input (string) we always get the same result a "description of how to print that string" and it's perfectly pure. Whether we do it zero, once, or more is irrelevant
05:52:06 <merijn> systadmin: So what you end up with is a pure programming language that lets you construct programs by combining these sorts of descriptions. The crucial thing is that the *execution* of these fragments can never be observed (or impact) by the pure code
05:52:46 <merijn> systadmin: Look at 'main :: IO ()', it's basically saying that main is a single program (fragment) which, when executed, may do all sorts of things, like print to stdout, read from stdin, etc.
05:53:23 <merijn> systadmin: How does that get run? Well, the runtime system has machinery to actually execute these IO programs. But this execution can't impact the way pure code evaluates
05:53:48 <dfeuer> merijn: I do work on containers, although I have a bit less time for it now.
05:54:14 <merijn> dfeuer: So, I have some function I need/want, but I'm not sure if the machinery is in there and if not if there's support to add
05:54:19 <systadmin> So it can't alter/mess with/etc the evaluation?
05:54:26 <merijn> systadmin: Right
05:54:32 <dfeuer> merijn: whaddya want?
05:54:33 <kylefang> Found it... thx https://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Base.html#line-665 Dash was having trouble jumping to correct line. :)
05:55:28 <merijn> dfeuer: I have two sets A and B which potentially intersect and I want to both insert missing elements from B into A and find out which elements were inserted
05:56:22 <dfeuer> merijn: I think that'll fall out of adding an alterF analogue for Set, which I was already hoping to do.
05:56:31 <merijn> I can do difference first and then union, but I feel like that'd be much nicer/faster to do at once
05:56:34 <dfeuer> But I could be wrong.
05:56:39 <dfeuer> Oh, you want *that*.
05:56:47 <dfeuer> difference and union too.
05:57:04 <dfeuer> Hmmm....
05:57:57 <systadmin> I'm just working on a little project btw :)
05:59:36 <dfeuer> merijn: we don't have any other such combos, because it's a bit hard to know where to stop. Can you try implementing it by importing Data.Set.Internal? What gains do you see?
05:59:45 <merijn> Unlike Map there's no operation that allows you to both "set" *and* check if it was already in there, so you can simply reformulate this as "foldr insert setA setB" either
06:00:09 <dfeuer> merijn: well, *that* functionality is probably coming.
06:00:25 <Profpatsch> noan: Nobody answered your question; if App (Key User) is a type of kind *, then App is a type constructor of kind * -> * with one argument, (Key User).
06:00:36 <dfeuer> (alterF, specifically)
06:00:43 <merijn> ok, that's good :)
06:00:59 <Profpatsch> noan: (Key User) is of kind *, Key of kind * -> * and User of kind *
06:01:12 <Profpatsch> It’s like function application really.
06:01:14 * dfeuer attempts to go back to sleep for 45 minutes. Haha, yeah right.
06:01:47 <merijn> dfeuer: heh, what timezone are you in?
06:02:20 <Profpatsch> merijn: Since it’s 15:00 here in Germany, probably LA time?
06:02:42 <Profpatsch> Or UK and he went to bed at 6am :)
06:02:48 <opqdonut> merijn: how about using Data.Map.mergeWithKey?
06:03:10 <merijn> opqdonut: I'm using IntSet, I was just observing the absence of that functionality for Sets
06:03:20 <opqdonut> mmh
06:03:22 <merijn> Profpatsch: I was under the impression he was closer to my timezone :)
06:04:45 <Profpatsch> merijn: which is? :)
06:04:52 <taktoa> seems like maryland: http://math.stackexchange.com/users/17596/dfeuer
06:05:06 <merijn> Profpatsch: CET
06:05:21 <merijn> Or he just has an unhealthy sleep pattern if he's in maryland :p
06:05:45 <Profpatsch> merijn: Hm, but CET is 15:00 right now, right?
06:06:03 <Profpatsch> If it’s Central European Time.
06:06:11 <merijn> Yes
06:06:50 <jchia_> How do I get the length of a sized vector (Data.Vector.Sized) without using undefined? I.e. given the type of the sized vector, I want to get the length. I know how to get the size using undefined: Data.Vector.Sized.length (undefined :: Data.Vector.Sized.Vector 123 Char)
06:07:09 <systadmin> What should I use to define a factorial function?
06:07:44 <dramforever> systadmin: Try to say in English first
06:07:52 <dramforever> What's the factorial of n?
06:07:59 <taktoa> systadmin: https://www.willamette.edu/~fruehr/haskell/evolution.html
06:08:15 <dramforever> Okay, this has got a little bit out of hand
06:09:07 <jophish> jchia_: hi, this is the vector-sized package, right?
06:09:15 <jchia_> jophish: yes
06:09:55 <jophish> undefined will work there, but I'm surprised I didn't add a version taking a Proxy :)
06:10:07 <jophish> you could also just use the nat from the type
06:10:42 <jophish> ah, there is a version which returns a proxy, not quite what you want
06:11:39 <jophish> jchia_: You might just want to use https://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-TypeLits.html#v:natVal
06:12:36 <jophish> so you have something like: length'' :: forall n a. Vector n a -> Natural; length'' = fromInteger (natVal (Proxy @n))
06:12:48 <jophish> sorry that should have been: length'' _ = ...
06:13:42 <jophish> That's using scoped type variables to get the length type variable in scope in the expression, so it can be used to type the 'Proxy' value being given to 'natVal'
06:13:45 <Profpatsch> defEndpoint :: forall p i o m ctx. (MonadIO m, HasRep p) => Endpoint p i o -> HVectElim p (HVectElim (MaybeToList i) (ActionCtxT ctx m o)) -> SpockCtxT ctx m ()
06:13:46 <jchia_> jophish: Thanks. This is using OverloadedLabels, right?
06:13:52 <Profpatsch> Yay Haskell webframeworks
06:13:54 <jophish> It's using TypeApplication
06:14:03 <jophish> s
06:14:14 <jophish> you'll also need a KnownNat constraint in there
06:14:55 <jophish> jchia_: please let me know if there's anything I can help you with with vector-sized
06:15:50 <jophish> anything else*
06:16:00 <jchia_> jophish: I think I understand length''. Why do we want to return Natural instead of Integer?
06:16:13 <merijn> jchia_: Because negative lengths are impossible
06:16:40 <jophish> sadly, natVal was introduced before Natural 
06:16:48 <jophish> I believe this is being corrected in 8.2 though
06:16:53 <jophish> or a new module introduced
06:19:55 <jchia_> jophish: I see. Thanks.
06:20:36 <jophish> If you don't need to guarantee that the result is non-negative then you could return Integer and remove the fromInteger
06:21:00 <jchia_> merijn: Thanks
06:21:40 <dramforever> I feel Natural is, it's not that useful because it doesn't let you have negative intermediate results
06:22:23 <phadej> FWIW, natVal in GHC8.2 will return Natural
06:22:34 <dramforever> which is, actually more natural (no pun intended)
06:23:09 <phadej> ah, someone already mentioned that
06:23:38 <jophish> dramforever: Is that like saying Float isn't that useful because it doesn't let you have complex intermediate results?
06:23:45 <jophish> :P
06:25:16 <dramforever> complex isn't that natural
06:25:28 <dramforever> real is enough closed on most operations
06:26:26 <dramforever> like I don't really want to restrict myself to a + b - c not a - c + b because the latter may underflow or something
06:26:51 <phadej> dramforever: in practice you rarely substract naturals
06:27:08 <jophish> recently we've been using quite a lot of constraints, making sure that naturals are above a certain value
06:27:14 <dramforever> rarely?
06:27:45 <dramforever> I guess I need more inherently non-negative things to use Natural...
06:27:54 <merijn> Any guesstimate for reasonable "max URL length" for querying servers? Or should I just binary search to figure out the limit for a specific server and then use that
06:27:58 <phadej> fwiw, I probably never needed to substract two lengths of vectors for example
06:29:17 <Logio> if you are substracting them, they aren't really naturals, are they?
06:29:30 <dramforever> Logio: maybe
06:29:40 <phadej> well, I can imagine situation where you pad the shorter one so they are of equal length
06:30:11 <dramforever> Yeah, when you subtract the smaller amount from the larger amount
06:30:27 <phadej> but then I'd use `Natural -> Natural -> Integer` function
06:30:38 <phadej> or `Natural -> Natural -> (Bool, Natural)`
06:30:44 <dramforever> :(
06:30:53 * dramforever is lazy
06:31:05 <phadej> yeah, that's the reason people had `null` in Java ;)
06:31:14 <phadej> (sorry, for overshooting)
06:31:16 <dramforever> numbers are hard
06:31:17 <Logio> what about (-) :: Natural -> Natural -> Maybe (Natural)?
06:31:21 <dramforever> ADTs are better
06:31:29 <phadej> Logio: there is minusNaturalMaybe
06:31:33 <dramforever> Logio: now arithmetic got way harder
06:31:41 <phadej> but you cannot have (-) with that type
06:32:00 <Logio> yeah
06:32:01 <exio4> dramforever: you have to use combinators then
06:32:13 <dramforever> arithmetic got way harder
06:32:23 <Logio> I actually sinned recently and implemented a Num instance for clifford algebras
06:32:42 <Logio> now there's arithmetic gone hard
06:32:48 <dramforever> It's remarkable how dealing with immutable abstract things and ADTs are much easier...
06:32:49 <exio4> (`minus` (plus 5 7)) <$> (minus 4 3) == (4 - 3) - (5 + 7)
06:32:56 <phadej> dramforever: well, I think that we should use compiler to catch bugs, and not add 'if x < 0 ...' checks
06:33:49 <merijn> phadej: So...LiquidHaskell? :)
06:33:58 <dramforever> Well, aren't 'Natural's 'if x < 0'?
06:34:58 <phadej> merijn: In some cases yeah, but I still think you can get quite far with just NonEmpty, then with { [x] | len x > 0 }
06:34:58 <dramforever> Just the 'if x < 0' get everywhere and go out of hand and get annoying and whatever...
06:35:23 <Logio> on that note, does anyone know if base expects (*) to possibly be non-commutative?
06:35:37 <phadej> Logio: base doesn't expect it to be anything
06:35:38 <quchen> (*) has no laws.
06:35:41 <phadej> ^
06:36:24 <__monty__> I'm looking for a library that provides functionality to search a sorted file for line prefix. Do I really have to implement binary search for this myself?
06:36:53 <dramforever> phadej: but then stuffs like (^) uses (*) and they sure have assumptions
06:37:08 <phadej> merijn: but I have no opinion whether I prefer external (refinement types) or internal (gadts to the next level) "more precise types"
06:37:18 <dramforever> > x ^ 0x5a -- Perhaps we can see?
06:37:20 <lambdabot>  x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x) * (x * x * (x * x))) ...
06:37:43 <dramforever> stupid idea, that doesn't really show anything...
06:37:54 <systadmin> Is there a way to remove the first letter in a word?
06:37:54 <Logio> Anything that uses (*) through Product should be fine due to Monoid laws, I guess
06:38:46 <__monty__> systadmin: If the word is a String, simply use "tail"
06:39:15 <systadmin> oh...
06:39:20 <noan> Profpatsch, http://www.reactiongifs.com/r/eli5.gif I think I need to go read LYAHFGG from the beginning...
06:39:22 <systadmin> Okay, thanks
06:39:23 <dramforever> I would hesitate to use a Num instance that math doesn't really agree or something
06:39:26 <noan> but thanks
06:39:39 <dramforever> sorry ignore me
06:40:15 <Profpatsch> noan: Some people don’t like LYAH, it very much helped me in the first stages.
06:40:47 <Profpatsch> You can also buy the http://haskellbook.com/, which is praised by many (no experience here)
06:40:59 <noan> Profpatsch, Do you know any decent books that would be approachable for someone new to FP but not OOP etc?
06:41:00 <merijn> Profpatsch: I think the issue is that LYAH was better than everything before it and came out during a rather quick growth of Haskell. But it's not very didactically sound and newer things tend to be better
06:41:19 <quchen> LYAH is very shallow, but it got me interested in Haskell. :-)
06:41:26 <dramforever> systadmin: uh, are you learning Haskell *by* writing small utility programs?
06:41:32 <Profpatsch> Aaaand, it’s the LYAH discussion again. :P
06:41:44 * Profpatsch stops now
06:41:58 <merijn> quchen: Sure, same here
06:42:00 <noan> I would but I don't really have expendable income, and I don't wanna pirate Chris and Julie's book. They worked damn hard at it and Chris is super nice.
06:42:01 <systadmin> I mainly read Haskell Book, but I g to LYAH for reference
06:42:08 <noan> (I've not spoken to Julie)
06:42:10 <merijn> quchen: But rereading it it's...rather unsound :)
06:42:12 <dramforever> oh good
06:42:13 <thatguy> Is there something similar to foldr but instead of going through a finite list I can pass it something like "repeat a" and a termination conidition?
06:42:16 <Profpatsch> noan: If you know JS “Purescript by Example” is your book.
06:42:20 <systadmin> dramforever: no, I'm reading a book. But I'm making a small utility program just for fun
06:42:25 <dramforever> good
06:42:38 <merijn> noan: If you ask Chris he'll gladly give you a discounted (or maybe free?) version if you don't have money
06:42:38 <dramforever> thatguy: foldr can do that
06:42:39 <kadoban> thatguy: Sounds kind of like unfoldr to me? But that's just a guess.
06:42:41 <dramforever> :t foldr
06:42:43 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
06:42:59 <dramforever> see the second argument in (a -> b -> b), the b?
06:43:01 <Profpatsch> Actually, it might be easier learning Purescript first, since it has less historical baggage and no laziness.
06:43:02 <quchen> > foldr const 0 [1..]
06:43:06 <lambdabot>  1
06:43:15 <dramforever> If the condition is reached just ignore the b
06:43:33 <dramforever> const is a good b-ignoring function obviously
06:43:42 <noan> Profpatsch, I'm already working on a project in haskell. I wanna learn the necessary components to get some stuff working and understand it at present. a detour of that size is maybe a bit much
06:44:02 <Profpatsch> I still don’t know what a HeytingAlgebra is. :(
06:44:07 <c_wraith> Profpatsch: Why would you not want laziness? It's what makes basic combinators work.
06:44:08 <noan> I think I need mainly a) a syntax review and b) a better understanding of how converting between types works in haskell
06:44:12 <dramforever> noan: What are your previous experiences?
06:44:31 <Profpatsch> noan: That’s nice, so definitely stick with one of the Haskell books.
06:44:45 <Profpatsch> It should be fairly quick to learn the other once you master one.
06:44:49 <noan> dramforever, C#, Ruby, Javascript + underscore, a bit of scala.
06:44:50 <merijn> noan: tbh, depending on your background you might consider just reading the spec
06:44:50 <quchen> No laziness *is* historical baggage :-C
06:44:51 <sm> noan: how about Haskell Tutorial And Cookbook
06:45:14 <merijn> noan: The Haskell Report is pretty readable, especially compared to monstrosities like C
06:45:17 <merijn> quchen: Boo you!
06:45:25 <merijn> quchen: Laziness is the only sane default!
06:45:31 <noan> merijn, is that the name of the spec?
06:45:33 <Profpatsch> quchen: Yes, but it’s another concept one has to learn.
06:45:41 <quchen> merijn: That’s what I said. There was no comma missing.
06:45:43 <noan> laziness is fine and doesn't trouble me
06:45:53 <merijn> noan: https://www.haskell.org/onlinereport/haskell2010/
06:45:57 <thatguy> dramforever: so my function which I pass to foldr should just return the same thing forever once the condition has been reached?
06:45:57 <dramforever> I doubt if you'll make it...
06:46:18 <thatguy> noan: I am learning haskell with http://www.cis.upenn.edu/~cis194/spring13/lectures.html it has a lot of exercises and is pretty concise, I like it very much
06:46:23 <dramforever> thatguy: just remember one thing, there isn't really a thing called 'terminating condition'
06:46:24 <quchen> The Report is a great beginner learning resource, provided you are already proficient in Haskell.
06:46:37 <dramforever> because there's no sequence there
06:46:49 <Profpatsch> merijn: quchen Took me a second to understand that sentence as well. Commas are hard. :)
06:47:03 <merijn> quchen: Also for some types of imperative programmers
06:47:10 <dramforever> hmm
06:47:14 <noan> thatguy, I worked with that a while back but found it had a gross gap in information personally
06:47:14 <Profpatsch> Especially when most people leave them out and your brain automatically insert them.
06:47:25 <Profpatsch> *inserts
06:47:30 <merijn> quchen: People who are used to C/C++ insanity to the point of reading those specs the Haskell spec is pretty light reading :)
06:47:50 <noan> I'm curious about this though. With regard to laziness.. Where is it that people typically trip up?
06:47:58 <noan> It seems perfectly reasonable to me
06:48:00 <thatguy> noan: yeah I know what you mean, you learn most while doing the exercises not while reading the book, it doesn't ellaborate much
06:48:44 <AndreasK> noan: Causes spaceleaks and unexpected performance characteristics at times
06:48:49 <Profpatsch> noan: Most people I know who don’t like laziness argue that you can’t know what happens.
06:48:55 <thatguy> dramforever: I am not sure I get what you mean, but I'll try to do it with foldr
06:49:20 <Profpatsch> And that’s true if you come from a (light) C background.
06:49:24 <Profpatsch> Or maybe Perl.
06:49:28 <dramforever> you know what
06:49:40 <dramforever> thatguy: search for "findKey key =" in http://learnyouahaskell.com/modules#data-list
06:49:52 <noan> Profpatsch, why on earth would I need to know what happens at a machine level? I'm not programming microcontrollers here.
06:49:57 <dramforever> you'll see a 'terminating' foldr
06:50:07 <quchen> > foldr const 0 [1..]
06:50:10 <lambdabot>  1
06:50:13 <Profpatsch> But I’d argue the garbage collector weighs harder there.
06:50:20 <noan> I don't want to know what's happening at machine level. That means throwing away WAY too much abstraction
06:50:21 <dramforever> quchen: that's too trivial
06:50:26 <quchen> > foldr const 0 [2..]
06:50:28 <lambdabot>  2
06:50:38 <dramforever> quchen: stop that
06:50:49 <Profpatsch> noan: Just promise me you won’t try hard realtime programming in Haskell :P
06:51:05 <noan> Profpatsch, define that term.
06:51:14 <merijn> noan: Well at some point it helps to know what's going on, but only selectively
06:51:22 <dramforever> noan: I believe that concepts and practices are different enough that you'd better start from the basics
06:51:29 <quchen> :t \p -> foldr (\x rest -> if p x then rest else x:rest) [] -- filter – less trivial?
06:51:31 <lambdabot> Foldable t => (a -> Bool) -> t a -> [a]
06:51:40 <c_wraith> noan: hard realtime programs have fixed deadlines that they must perform actions by.  If they don't, it's considered a hard failure.
06:51:48 <merijn> noan: "hard realtime" is when there are 1) deadlines (usually rather short ones) and 2) missing a deadline is considered complete system failure
06:51:58 <quchen> e.g. radio transmitters.
06:52:02 <noan> aaah
06:52:04 <dramforever> If that 'just need syntax reference' thing worked going from C# -> Ruby that's *not*, *NOT* going to work with Haskell
06:52:12 <quchen> Not hard real time: most things.
06:52:15 <dramforever> definitely not
06:52:19 <noan> That's the sort of thing I was referring to when I said "I'm not programming microcontrollers here"
06:52:20 <merijn> noan: As opposed to soft realtime when X% of deadlines can be missed without considering it complete system failure
06:52:23 <dramforever> not, not, not, not working
06:52:29 <noan> aka HIGHLY performance dependant and specific applications.
06:52:29 <dramforever> I think that's probably enough
06:52:29 <AndreasK> Lazyness sometimes leads to unexpected space leaks, unexpected performance characteristics can also happen but so far i didn't hit that often
06:52:31 <Profpatsch> At least soft realtime processing is the reason why the golang GC is “optimized” the way it is.
06:53:00 <merijn> noan: Soft realtime would be things like audio/video/games where dropping a frame once in a while is considered ok
06:53:06 <noan> makes sense though, and yeah, I would likely use something a lot closer to metal for those things.
06:53:34 <Profpatsch> Like a GL library that has a nice Haskell wrapper. ;P
06:53:38 <noan> Thanks, I hadn't heard that term before. I've been out of the loop for a couple years not really programming, and was doing web stuff before then
06:53:39 <dramforever> noan: Let's have an example, perhaps
06:54:03 <noan> noan, of something closer to metal if I wanted to program for instance a radio transmitter?
06:54:13 <dramforever> Hmm, Actually I wonder if Scala would have helped you getting into Haskell
06:54:13 <Profpatsch> Then again, lots of people doing hard numeric in Python.
06:54:17 <noan> Probably C or Rust.
06:54:41 <noan> dramforever, It has. I have a basic understanding of the idea of a typeclass and stuff like that
06:54:49 <dramforever> hmm
06:55:07 <noan> here... lets give context of where I'm struggling...
06:55:18 <dramforever> I just, you know it just sort of never worked before
06:55:34 <noan> https://github.com/AlexaDeWit/haskellsandboxserver/blob/master/src/db/queries/User.hs
06:55:47 <noan> I am currently attempting to accomplish something akin to this..
06:55:54 <dramforever> and people end up like throwing 'do' everywhere and don't get how to do IO at all or something
06:55:55 <noan> (this is my currently broken code=
06:56:50 <noan> I think one big barrier I'm having is I don't understand that App type very well, which is from Matt Parson's work here: https://github.com/parsonsmatt/servant-persistent/blob/master/src/Config.hs
06:57:40 <AndreasK> Profpatsch: afaik numerical programming in python falls back to calling c for almost anything performance sensitive though
06:57:48 <noan> I currently think of IO as an analogue to Scalaz's Task type. Representing some side-effecting code to be executed later.
06:58:13 <dibblego> Task is full of bugs, and generally does not work. This is not true of IO :)
06:58:15 <dramforever> You know what a monad is?
06:58:28 <noan> dibblego, dachshund <3
06:58:30 <Profpatsch> AndreasK: Yeah of course.
06:58:33 <noan> dramforever, yes.
06:58:39 <dramforever> If I tell you line 21 is wrong, do you notice something?
06:58:39 <dibblego> rottweiler
06:58:42 <noan> although I forgot the endofunctor laws
06:58:54 <Profpatsch> But contrary to python we can actually get bare-metall-y fast with pure Haskel.l
06:59:00 <Profpatsch> So that’s that.
06:59:09 <dramforever> that's for hard mathematics that programmers need only a feeling of
06:59:11 <noan> http://www.dogbreedplus.com/dog_breeds/images/rottweiler-puppy-2.jpg
06:59:13 <sm> g'day all. ircbrowse.net is down, anyone we can ping here ?
06:59:36 <dibblego> sm: I believe (not 100%) it is chrisdone
06:59:59 <sm> I don't think he is here alas
07:00:35 <dramforever> noan: line 21 and 24 are wrong and I think it's because you don't know what *the* monad does
07:01:07 <dramforever> oh uh...
07:01:33 <noan> dramforever, Oh, a lot of it is wrong. Mostly I wanted to show the type signature I was thinking I would like to have, and the repo for the dependant types involved.
07:01:46 <noan> That function is a god damn mess and will be thrown in the bin 
07:02:07 <dramforever> oh
07:02:30 <noan> There's a lot of standard haskell I don't yet understand. And type signatures alone only convey so much
07:02:31 <thatguy> I don't get why foldr const 0 [1..] returns 1. As I understood it, the first call will be const 1 0 which returns 1, the second call will be const 2 1, which should return 2 and so on...what am I missunderstanding?
07:02:34 <dramforever> I see you've now at least half-baked your manmonadship :)
07:02:36 <thatguy> >foldr const 0 [1..]
07:02:55 <thatguy> > foldr const 0 [1..]
07:02:57 <lambdabot>  1
07:03:01 <dramforever> thatguy: it's 'const 0 (...)' and the rest don't matter
07:03:13 <dramforever> thatguy: it's 'const 1 (...)' and the rest don't matter
07:03:45 <dramforever> The *last* call will be 'const ??? 0' but there's no such last call
07:03:58 <thatguy> ahh ok
07:04:06 <thatguy> yeah I need to look up the implementation again
07:04:27 <thatguy> I think I had a wrong model of that function in my head which worked until now
07:04:29 <thatguy> dramforever: thanks
07:04:45 <noan> dramforever, got a moment to walk me through what App is here in terms of Haskell syntax? https://github.com/AlexaDeWit/haskellsandboxserver/blob/master/src/db/Config.hs
07:05:07 <noan> I get the deriving part, that's just typeclass membership
07:05:25 <dramforever> uh, you sure you do?
07:05:37 <dramforever> Tell me how they work
07:05:41 <merijn> noan: What syntax don't you understand?
07:05:45 <dramforever> say, just the Functor part
07:05:48 <noan>  { runApp :: ReaderT Config (ExceptT ServantErr IO) a
07:06:00 <dramforever> That's called record syntax
07:06:10 <noan> dramforever, I didn't mean to say I understood all the typeclasses. Just that it was a member of them
07:06:11 <merijn> I suspect he's not familiar with record syntax :p
07:06:19 <noan> and as such I can walk myself through each typeclass in turn
07:06:26 <dramforever> noan: well what does being a member mean?
07:07:18 <merijn> noan: "data Foo = Bar { myId :: Int, blah :: String, quux :: Bool }" defines a "Bar" constructors with an Int, String and Bool field. The record syntax just generate some convenient named fields for interacting with those fields
07:07:22 <noan> in haskell terms, I'm not sure how it's worded. In Scala it means that for each type class it is a member of there exists an instance of that typeclass for that class, which provides all the functions defined for that type class.
07:07:31 <dramforever> (Disclaimer: I'm not walking you through this. I believe with good faith that you don't know enough to get started, so I'm walking you to the beginner tutorial)
07:07:49 <dramforever> But I *will* explains things as best as I could
07:08:01 <dramforever> noan: That's quite right
07:08:13 <dramforever> but where are the functions for Functor defined?
07:08:37 <dramforever> The definitions are nowhere to be found
07:09:01 <noan> my expectation here is that somehow within the haskell type system it is able to use instances from magically elsewhere, which is admittedly part of the frustration
07:09:22 <noan> as if haskell provides somehow a "standard" depending on how you define your new type
07:09:28 <dramforever> Yes!
07:09:50 <dramforever> How? It's actually compiler magic here!
07:09:51 <dibblego> noan: Haskell uses a different mechanism to Scala, but for the same idea. Scala also a) allows abuse of this mechanism b) has a highly populated cottage industry of this abuse so as to make differentiation difficult
07:09:55 <dramforever> 'GeneralizedNewtypeDeriving'
07:10:11 <noan> because in scala you bet your ass I'd be providing a implicit object Monad[App[T]] which provides... oh fuck what is it in scalaz? id and flatMap?
07:10:12 <dibblego> class Functor f where fmap :: (a -> b) -> f a -> f b
07:10:27 <dramforever> Enough for that, let's get the newtype part right first
07:10:32 <noan> dibblego, I know, I know.
07:10:33 <dibblego> trait Functor[F[_]] { def fmap[A, B](f: A => B): F[A] => F[B] {
07:10:49 <dramforever> What's a 'newtype'? Well, do you know what's a 'data'?
07:10:56 <dibblego> noan: scalaz does not repeat some of the historical mistakes of haskell
07:11:16 <dibblego> newtype is what scala tries to implement with value types, but fails [again]
07:11:16 <noan> a data is just what I would think of as a type with a default constructor? something which can contain data.
07:11:23 <noan> I don't want to compare it to a struct
07:11:28 <noan> since it could be a sum or product type
07:11:39 <dramforever> I heard there's a thing called a 'case class' in scala
07:11:49 <dramforever> but a 'data' is non-extendable
07:11:57 <dibblego> noan: I haven't been following properly, so not sure on where the issue is, just saying facts in the hope one helps :)
07:12:02 <noan> a scala case class is a product type.
07:12:03 <dramforever> You define it to have 7 constructors, it has 7 constructors everywhere
07:12:17 <dramforever> noan: but they often extend a common class right?
07:12:22 <dibblego> scala implements sum types using sealed trait
07:12:31 <dibblego> dramforever: No.
07:12:38 <dramforever> dibblego: oh
07:12:40 <dramforever> they do
07:12:42 <dramforever> Sorry
07:12:44 <merijn> dibblego: Can you elaborate what the historical mistakes of Haskell's newtype are?
07:12:46 <dramforever> I don't really know scala
07:12:56 <noan> don't stress yourself over analogues
07:13:10 <dibblego> merijn: none, I meant in library design, Scala does not improve on anything over Haskell wh en it comes to language design
07:13:13 <dramforever> noan: so somehow None and Some[A] are both Option[A] right?
07:13:14 <noan> You can use proper terms and I will either look them up, know them, or seek to learn them
07:13:18 <merijn> dibblego: oh, right
07:13:37 <dibblego> noan: then what is the query>
07:13:38 <dibblego> ?
07:13:43 <noan> dramforever, I haven't really written scala in like 2 years, but it's something like that
07:13:46 <dramforever> ok, I was trying to make an analogy
07:13:49 <dramforever> sorry about the confusion
07:13:54 <dramforever> okay no more scala
07:13:58 <noan> dibblego, at present, helping me understand https://github.com/AlexaDeWit/haskellsandboxserver/blob/master/src/db/Config.hs line 54
07:14:22 <dibblego> be advised, I have typed with 9 fingers since 1996, and from today I have only 6
07:14:24 <dramforever> dibblego: This is going to take forever, what do you think?
07:14:30 <noan> sealed trait Option[+E]
07:14:30 <noan> case class Some[+E]( element : E ) extends Option[E]
07:14:30 <noan> case object None extends Option[Nothing]
07:14:34 <noan> Is what it basically is iirc
07:14:35 <dramforever> ooh
07:14:37 <dramforever> nice
07:14:42 <dibblego> dramforever: we'll be right
07:14:50 <noan> None is a singleton for which there exists one instance.
07:14:58 <noan> and only ever one
07:15:11 <dramforever> Nothing is a type that extends every single type right?
07:15:18 <dibblego> noan: there is no close analogue to that in haskell
07:15:42 <noan> dibblego, True? False?
07:15:42 <dibblego> sealed trait Option[E]
07:15:44 <dramforever> yes because Haskell uses the easier notion of sum and produc types
07:15:57 <dramforever> data Option a = Some a | None
07:16:02 <dibblego> case class Some[E](element: E) extends Option[E]
07:16:09 <dibblego> case class None[E]() extends Option[E]
07:16:12 <dibblego> that is closer to haskell
07:16:23 <dibblego> noan: yes, true, for scala
07:16:26 <dramforever> dibblego: Thank you for helping me with scala
07:16:34 <dramforever> Let's move on
07:16:46 <dibblego> believe me, I've moved on from scala :)
07:16:54 <dramforever> So what's that { x :: y } thing?
07:16:57 <noan> dibblego, I was thinking you were talking about singleton objects with one instance. Hence why I was thinking of things like.. Nothing True False etc.
07:16:58 <dibblego> waste of human
07:17:07 <dibblego> noan: data () = ()
07:17:12 <noan> that too.
07:17:18 * dramforever made a bad joke
07:17:19 <dibblego> there is no nominal subtyping and subsequent variance, in haskell
07:17:40 <dibblego> dramforever: cons is :: in scala, don't know what you mean otherwise
07:17:47 <Xnuk> @let data A = A { foo :: Int }
07:17:48 <lambdabot>  Defined.
07:17:51 <noan> so.. newtype App a... is a polymorphic type, right?
07:17:55 <dramforever> https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-700004.2.1
07:17:59 <noan> like App[T]
07:18:01 <dramforever> There you go
07:18:08 <dibblego> noan: yes, since (a) is lower-case it is declared forall, similar in scala to [A]
07:18:10 <dramforever> dibblego: I was refering to the record syntax
07:18:20 <dibblego> scala has record syntax, but it's shit
07:18:31 <merijn> dibblego: So...like haskell then? ;)
07:18:39 <noan> ooooh
07:18:41 <dibblego> yes, pretty much
07:18:44 <dramforever> Haskell's record syntax isn't like it really works or anything
07:18:44 <noan> I got a little lost in the noise
07:18:54 <dramforever> https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-700004.2.1
07:18:55 <noan> it's analogous to it being a Data thing?
07:19:05 <Logio> noan: yes, but with only a single constructor
07:19:13 <merijn> dramforever: I don't like haskell records, but then I'm not sure how to make them better either :\
07:19:22 <merijn> Syntax is hard!
07:19:24 <dibblego> noan: if you replace newtype with data, on line 54, not much will change and it is best to ignore that which will change, for now only
07:19:30 <dramforever> Because it's a raw, compile-time only wrapper around the inner type
07:19:42 <dramforever> It's easier to work with sometimes
07:19:49 <noan> if it's defined for all a, how can it have the type runApp :: ReaderT Config (ExceptT ServantErr IO)
07:20:12 <dramforever> Because it's *not*
07:20:17 <dibblego> noan: the analogue to newtype, for scala, is value types, where an optimisation under certain restrictions can be applied [scala messes it up badly though]
07:20:27 <dramforever> It has type runApp :: App a -> ReaderT Config (ExceptT ServantErr IO) a
07:20:43 <noan> ooooooh
07:20:45 <dramforever> According to the Haskell Report section I linked
07:20:59 <dibblego> case class App[A](runApp :: ReaderT[Config, ExceptT[ServantErr, IO], A]) // there is no deriving
07:21:13 <dramforever> That one is just newtype App a = App (ReaderT Config (ExceptT ServantErr IO) a)
07:21:18 <dramforever> with extra goodies
07:21:19 <jchia_> Which container gives me good performance if I only need to prepend/append and get length? Getting the length of a list is linear, correct? Is there a container with O(1) append and O(1) length?
07:21:34 <Logio> noan: without the record syntax, the line would read: newtype App a = App (ReaderT Config (ExceptT ServantErr IO) a)
07:21:36 <dibblego> in haskell, you can use runApp to "get" and "set" the [one and only] field 
07:21:50 <dibblego> in scala, you do the same with .runApp and .copy(runApp = 
07:21:53 <kadoban> jchia_: Data.Sequence I think has O(1) length, or it's pretty easy to wrap a list with length.
07:22:08 <dramforever> Which is *not* the common use here, when it wraps monads
07:22:15 <niklasb> jchia_: just use two lists plus an int
07:22:17 <kadoban> jchia_: Oh you say you need to prepend and append? Then probably Data.Sequence for sure
07:22:20 <Logio> noan: then you could define runApp separately to unwrap the value from the App constructor
07:22:24 <dibblego> jchia: data DList a = DList (a -> a) has O(1) cons/snoc/append with O(n) on most other operations
07:22:34 <jchia_> kadoban, niklasb: append or prepend, doesn't matter which
07:22:35 <dramforever> noan: Let's get a simpler example
07:22:43 <dramforever> @undefine
07:22:43 <lambdabot> Undefined.
07:22:44 <niklasb> jchia_: then just ([a], Int)
07:22:49 <dramforever> That cleans the environment
07:22:57 <noan> I know lambdabot
07:22:59 <jchia_> niklasb OK
07:23:01 <noan> it is/was present in #scala
07:23:07 <dramforever> @let data Point a = Point { px :: a, py :: a }
07:23:08 <lambdabot>  Defined.
07:23:18 <dramforever> What can you do? well
07:23:20 <dramforever> :t Point
07:23:22 <lambdabot> a -> a -> Point a
07:23:23 <dramforever> :t px
07:23:24 <dramforever> :t py
07:23:24 <dibblego> noan: haskell does kind inference (scala never does), and type constructors always take one argument, where in scala, yopu have to go through the type-lambda ceremony, or subsequent efforts to mitigate that
07:23:26 <lambdabot> Point a -> a
07:23:26 <lambdabot> Point a -> a
07:23:52 <dramforever> :t px (Point 1 2) -- Let's see an example
07:23:53 <lambdabot> Num a => a
07:23:57 <dramforever> > px (Point 1 2) -- Let's see an example
07:23:59 <lambdabot>  1
07:24:12 <dramforever> it gives us the first field
07:24:28 <dibblego> scala> case class Point[A](px: A, py: A)
07:24:34 <dibblego> scala> Point(1, 2).px
07:24:35 <dibblego> res0: Int = 1
07:24:40 <dramforever> which is quite reasonable, given that we defined it with px as the first field
07:25:06 <noan> > px (Point "Foo" "Bar")
07:25:08 <lambdabot>  "Foo"
07:25:16 <noan> right okay this explains a lot more.
07:25:26 <dibblego> scala> Point("foo", "bar").px
07:25:26 <dibblego> res2: String = foo
07:25:36 <dramforever> You can also construct these with named fields
07:25:42 <noan> Seeing things in the scala syntax sometimes clears it up a lot
07:25:44 <dramforever> > py (Point { px = 1, py = 2 })
07:25:48 <lambdabot>  2
07:26:05 <dibblego> @let data Point a = Point { px :: a, py :: a } deriving Show -- add Show
07:26:06 <lambdabot>  .L.hs:160:1: error:
07:26:06 <lambdabot>      Multiple declarations of ‘Point’
07:26:06 <lambdabot>      Declared at: .L.hs:158:1
07:26:14 <dibblego> @let data Point' a = Point' { px :: a, py :: a } deriving Show -- add Show
07:26:16 <lambdabot>  .L.hs:160:24: error:
07:26:16 <lambdabot>      Multiple declarations of ‘px’
07:26:16 <lambdabot>      Declared at: .L.hs:158:22
07:26:19 <dibblego> blah
07:26:21 <dramforever> @undefine
07:26:22 <lambdabot> Undefined.
07:26:26 <dramforever> @let data Point a = Point { px :: a, py :: a } deriving Show -- add Show
07:26:27 <dibblego> @let data Point a = Point { px :: a, py :: a } deriving Show -- add Show
07:26:29 <lambdabot>  Defined.
07:26:29 <dibblego> lol
07:26:30 <dramforever> lol
07:26:31 <lambdabot>  .L.hs:161:1: error:
07:26:31 <lambdabot>      Multiple declarations of ‘Point’
07:26:31 <lambdabot>      Declared at: .L.hs:158:1
07:26:36 <noan> heh
07:26:38 <dramforever> one of us stop...
07:26:48 <dramforever> > Point { px = 1, py = 2 }
07:26:49 <dibblego> > (Point 1 2) { px = 77 }
07:26:50 <lambdabot>  Point {px = 1, py = 2}
07:26:52 <lambdabot>  Point {px = 77, py = 2}
07:27:02 <dibblego> scala> Point(1, 2).copy(px = 77)
07:27:02 <dibblego> res3: Point[Int] = Point(77,2)
07:27:05 <dramforever> Maybe I stop?
07:27:15 <dibblego> just wanted to show set/copy
07:27:20 <dibblego> that's it, done
07:27:22 <dramforever> > Point { px = 1, py = 2 }
07:27:27 <lambdabot>  Point {px = 1, py = 2}
07:27:37 <dramforever> noan: see it's nicely constructed
07:27:53 <noan> yeah
07:27:56 <dramforever> @let myHome = Point { px = 123, py = 234 }
07:27:57 <lambdabot>  Defined.
07:28:02 <dibblego> scala> Point(px = 1, py = 2)
07:28:02 <dibblego> res1: Point[Int] = Point(1,2)
07:28:03 <dramforever> You can do record updates
07:28:06 <thatguy> am I right that this application of mapA won't work on infinite lists? http://lpaste.net/352176
07:28:19 <dibblego> scala> Point(py = 1, px = 2)
07:28:19 <dibblego> res2: Point[Int] = Point(2,1)
07:28:22 <dramforever> > myHome { px = 0 } -- move the x coordinates
07:28:27 <lambdabot>  Point {px = 0, py = 234}
07:28:30 <noan> dramforever, well, copy operations returning a new copy of the same type
07:28:34 <dramforever> see how it changed
07:28:38 <noan> which is what dibbles shoed if I understand right
07:28:51 <dramforever> I don't know, I can't read Scala
07:28:54 <dibblego> thatguy: it will, why do you think it won't?
07:28:55 <noan> myHome never changed.
07:29:02 <dramforever> > myHome -- you bet
07:29:03 <noan> the value you got after is a new Point.
07:29:05 <lambdabot>  Point {px = 123, py = 234}
07:29:05 <dibblego> yes, .copy does update in scala
07:29:27 <dramforever> which is right everywhere in Haskell
07:29:43 <dibblego> scala equals haskell at one thing, the most annoying part of haskell, this is quite funny
07:29:47 <dramforever> (Exceptions are not interesting at all, in case anyone wants to be pedantic)
07:29:50 <noan> indeed, I just wanted to be clear that we weren't doing any "changing"
07:30:00 <dramforever> yes
07:30:09 <dramforever> review
07:30:10 <dramforever> :t Point
07:30:13 <lambdabot> a -> a -> Point a
07:30:14 <dibblego> there is no changing in haskell, because haskell, and no changing in scala, if you are a moral person
07:30:14 <dramforever> :t px
07:30:16 <lambdabot> Point a -> a
07:30:18 <merijn> thatguy: Well, define "work" :)
07:30:47 <dramforever> constructor makes a value, record selector gets values out of them
07:30:47 <thatguy> merijn: it wouldn't terminate :P
07:31:04 <merijn> thatguy: It won't terminate and, presumably, crash because it ran out of memory at some point
07:31:05 <thatguy> i.e. it would work quite a lot actually
07:31:08 <dramforever> noan: and now we have: newtype App a = App (Voodoo a)
07:31:08 <thatguy> :D
07:31:43 <dramforever> Where I shall let 'Voodoo' stand for 'ReaderT Config (ExceptT ServantErr IO)'
07:31:48 <thatguy> merijn: would you know a better way to implement that function which works on infinite lists?
07:31:49 <dibblego> thatguy: sorry, you are right
07:32:19 <merijn> thatguy: Well, not as-is
07:32:24 <dramforever> now with records, we understand what this means: newtype App a = App { runApp :: Voodoo a }
07:32:25 <thatguy> dibblego: I think you got the wrong person
07:32:31 <merijn> thatguy: But presumably you don't care about the result list if it's infinite?
07:32:43 <dramforever> it gives 'App :: Voodoo a -> App a', and 'runApp :: App a -> Voodoo a'
07:32:51 <dibblego> thatguy: no, I said earlier it will, that is a mistake, I missed a bit of the code
07:32:59 <dramforever> noan: 'App a' itself? Just a wrapper to let us better track of it
07:33:05 <dramforever> *keep better track
07:33:19 <Xnuk> > let mapA fun = foldr (liftA2 (:).fun) (pure []) in mapA Just [1..]
07:33:20 <merijn> thatguy: :et
07:33:21 <lambdabot>  *Exception: stack overflow
07:33:26 <Xnuk> > let mapA fun = foldr (liftA2 (:).fun) (pure []) in mapA (const Nothing) [1..]
07:33:29 <lambdabot>  Nothing
07:33:34 <merijn> thatguy: Let's start from something else, what do you actually wanna do?
07:33:36 <noan> ah hah. So anything that is a Voodoo a I should be able to wrap freely... and anything that is an App a should be unwrappable with runApp?
07:33:36 <dramforever> So we've went such length just to get a... wrapper
07:33:48 <dramforever> Sure we've learned more about records
07:33:53 <dramforever> noan: That's right
07:34:03 <dibblego> noan: correct, just like in scala
07:34:07 <noan> the part that had me all fucky is I couldn't understand the wrapping part
07:34:12 <noan> especially
07:34:26 <noan> well, I guess it's just a constructor like Point
07:34:27 <dramforever> And the meaning itself is pretty simple
07:34:30 <noan> so the wrapping is super easy
07:34:32 <thatguy> merijn: accomplish a task in CIS 194, they said in the tutorial you should try to implement that function and I did it that way, now I have a different task and find doing myself something similar (I want to run a lot of parsers after each other and "terminate" when the one of them returns nothing)
07:34:37 <thatguy> and return the result I got until then
07:35:30 <dramforever> noan: so.. end of this 'walkthrough'?
07:35:32 <thatguy> merijn: wouldn't there be a way to implement this mapA s.t. stuff like take 20 resultList works even if I passed in an infinite list
07:35:58 <noan> a much better understanding of what you referred to as "record syntax" 
07:36:16 <merijn> thatguy: Not directly, you might wanna have a look at the monad-loops package
07:37:00 <thatguy> merijn: I am not at monads yet
07:37:11 <noan> so lets take it one step closer on a related sort of thing for instance
07:37:19 <thatguy> but if that is a hard task and I am not just to stupid to find the answer I'm okay with that for now
07:37:30 <dramforever> still there :)
07:37:39 <noan> if I have... App (Key User) as a type... syntactically that's essentially an App a where the a is Key b where b is User?
07:37:45 <noan> a Foo of a Bar of a Baz?
07:37:47 <dramforever> yep
07:38:06 <dramforever> Apparently the basics of types of Scala is sane :)
07:38:08 <noan> kay, wanted to make sure that wasn't a tuple. Tuple notation would be ,
07:38:14 <noan> dramforever, HAH
07:38:16 <Sheo> Hey! Does anyone know about compiler steps. GHC wiki says src->Core->STG->c-- . But c-- has some outdated marks on the page.
07:38:30 <noan> dramforever, I try to abstract away languages.
07:38:53 <dramforever> noan: I've seen worse influences :)
07:38:58 <dibblego> the first trap in scala is thinking there is sanity, even if just a little bit
07:39:04 <noan> dramforever, https://tpolecat.github.io/2013/11/13/list.html
07:39:25 <noan> Rob does the Lord's... or maybe Satan's work. I still don't know which.
07:40:00 <dramforever> It's good enough
07:40:19 <merijn> Sheo: GHC uses Cmm which is kinda based on C--, but not entirely the same (since C-- never really got wide adoption)
07:40:36 <dramforever> People say they don't understand monads because they can't see why it's useful :facepalm:
07:40:44 <merijn> Sheo: Additionally there's a new backend which uses LLVM instead of Cmm (I think...not 100% sure)
07:40:57 <noan> dramforever, nah. If I was trying to do this stuff I'm trying to learn in haskell right now I'd be staring at a compiler error where I lack an implicit instance of a CanBuildFrom[Satan'sAsshole] and I'd just start crying.
07:41:21 <Sheo> Oh, I thought that was just another name for c--. ty
07:41:23 <tdammers> usually, when people say "I don't understand monads", what they really mean is "I don't accept monads", except that they don't know it yet
07:41:35 <dramforever> They could be too confused
07:41:59 <merijn> Sheo: It started out as C-- proper, but it has evolved into a slightly different GHC specific dialect since there's no real incentive to stay C-- compatible
07:42:08 <noan> dibblego, define a functor for me, I forgot since you did it two years ago
07:42:10 <noan> <3
07:42:13 <noan> thanks dramforever 
07:42:18 <Sheo> Oh ok, thanks.
07:42:26 <tdammers> what I mean is that there isn't a lot to understand there - >>= and return aren't exactly rocket science; it just takes a mental leap of faith to accept them as useful abstractions
07:42:32 <dibblego> noan: haskell or scala?
07:42:47 <dramforever> I've seen one so confused he/she asks How do monads handle these: 1. running multiple actions concurrently 2. running multiple actions concurrently, and only collect the results of those that terminate within a timeouut
07:42:48 <noan> either. Wait a minute
07:42:49 <dramforever> *timeout
07:42:56 <noan> https://en.wikipedia.org/wiki/Functor Is this just a morphism?
07:43:01 <dramforever> and WTF
07:43:24 <jophish> dramforever: sounds like a job for Applicative Functors!
07:43:29 <dramforever> Kinda like how do you control multiple motors with a pizza
07:43:37 <dibblego> class Functor f where fmap :: (a -> b) -> f a -> f b        trait Functor[F[_]] { def fmap[A, B](f: A => B): F[A] => F[B] }
07:43:43 <jophish> burrito*
07:43:53 <sshine> applicative burritos?
07:44:01 <sea_wulf> Correct me if I'm wrong, but isn't a morphism a type of functor?
07:44:04 <noan> oh okay.
07:44:10 <dramforever> they perhaps confused the Italian food with the Italian Arduino or whatever
07:44:22 <sshine> sea_wulf, in what sense?
07:44:25 <dramforever> I think the level of confusion is about that bad
07:44:54 <dramforever> noan: You're welcome :)
07:45:03 <noan> dibblego, thingy that turns a function between two types into a function between two functors of those types
07:45:04 <noan> basically?
07:45:22 <dramforever> Getting Haskell concepts straight makes me happier :)
07:45:37 <dibblego> instance Functor [] where fmap f = foldr ((:) . f) []        implicit def ListFunctor: Functor[List] = new Functor[List] { def fmap[A, B](f: A => B) = _.foldRight(Nil)((a, b) => f(a) :: b) }
07:45:38 <noan> well, not a thingy, a mapping
07:46:07 <sea_wulf> My bad, I was conflating mappings between categories and mappings, themselves I think
07:46:10 <dibblego> "morphism" is a very general, and context-dependent term. It is Greek for transformation
07:46:12 <sshine> sea_wulf, in the category of small categories, functors can be thought of as morphisms. =)
07:46:14 <Logio> noan: between the images of the types, yes
07:46:18 <dibblego> what sea_wulf said :)
07:46:47 <noan> I meant it in the category sense.
07:46:53 <sshine> sea_wulf, yeah, morphisms are what's inside categories and functors are what's between categories.
07:47:00 <noan> Trying to learn me some basic category theory lately.
07:47:06 <sea_wulf> thanks sshine!
07:47:08 <sshine> sea_wulf, so when you have categories of categories they can be the same :P
07:47:20 <dibblego> noan: I am typing with 6 fingers, instead of 9, I have to stop, bye
07:47:41 <noan> wait... does this mean that an Endofunctor is a sort of identity mapping for a category?
07:48:12 <Ford_Prefect> Anyone know how I can make JSON output from Aeson+Servant pretty?
07:48:15 <noan> dibblego, perfectly understandable. Rest well. Type me a 1 if they're permanently lost and 2 if merely injured. I'll ask for an explanation at a later date.
07:48:26 <sea_wulf> Cool cool, I have been trying to work through https://arxiv.org/pdf/1612.09375v1.pdf lately so any bits of knowledge on category theroy help
07:48:27 <sshine> there can be other endofunctors than the identity functor.
07:48:35 <sea_wulf> *theory
07:48:40 <Logio> noan: not _the_ identity, but a morphism from the category to itself, yes
07:49:00 <sshine> yes, an endofunctor is a functor between a category and itself. that's what endo means .P
07:49:09 <dibblego> endo is greek for unto itself
07:49:37 <noan> sshine, but the identity morphism for a category is by definition an endofunctor I presume?
07:50:40 <dibblego> trait Endo[~>[_, _]] { def ontoitself[A]: A ~> A }
07:50:42 <thatguy> can someone maybe give me some hint how to achieve a thing like this: I have a Applicative Functor: Parser a which consumes some part of a string and returns a Maybe(a, String) with the rest of the string. I want to have a Parser [a] which runs parsers until one of them returns Nothing
07:50:45 <dibblego> gotta go 4 realz
07:50:51 <noan> id :: Foo a -> Foo a --must be an endofunctor right?
07:51:08 <noan> dibblego, just give me the 1 or 2, other people have brains to pick little dachshund. Rest well my friend.
07:51:20 <noan> I worry.
07:51:46 <dibblego> noan: it has been 9 fingers since 1996, it is 6 fingers until April, and hopefully 10 after that
07:54:31 <sshine> dibblego, you have a variable number of fingers?
07:55:23 <dibblego> I have had 9 [available for typing] since an accident in 1996, which was repaired today, leaving another 3 currently unservicable, with a long term goal of having all 10 typing
07:55:34 <sshine> noan, I'm not sure you'd call a morphism an endofunctor unless you're dealing with a category of categories...
07:56:21 <noan> dibblego, ah, I hope the recovery from surgery goes well.
07:57:53 <dibblego> I'd even type scala for you, with 6 fingers, never forget
07:59:23 <halogenandtoast> Is it possible to filter out attributes using taggy-lens? I know this is completely wrong, but something like `fmap (transform (children . attrs %~ filter (\n -> n ^? attr "class" != Just "class"))) a`
07:59:35 <sshine> noan, are you thinking of Yoneda's lemma?
08:00:26 <sshine> noan, I think you still need them to be small categories then.
08:01:02 <halogenandtoast> I don't understand lenses well so my code might not make any sense.
08:06:35 <tabaqui1> I have f :: Maybe (Int, Int)
08:06:55 <tabaqui1> and I want use alike pattern-matching in "where"
08:06:58 <tabaqui1> like so:
08:07:01 <tabaqui1> (a, b) = f
08:07:18 <tabaqui1> *(a, b) ~= f
08:07:25 <tabaqui1> a = b = Nothing if f returns Nothing
08:07:36 <tabaqui1> ah, ok, case syntax
08:07:38 <tabaqui1> nevermind
08:13:55 <Sheo> or, if i understood. a = fmap fst f; b = fmap snd f
08:14:31 <ph88> is there any way to figure out what is the next Arbitrary (quickcheck) thing being generated in the parent type?  https://paste.fedoraproject.org/550625/86484004/
08:32:35 <lyxia> ph88: what does that mean
08:33:20 <lyxia> Oh, there's some comments I should read first.
08:35:24 <thatguy> if I have a parser for ints, and a parser for strings and a type Atom = I Int | S String, how can I make an Atom parser out of Parser Int <|> Parser String
08:36:07 <lyxia> thatguy: I <$> parseInt <|> S <$> parseString
08:36:38 <thatguy> lyxia: thanks :)
08:40:46 <tabaqui1> hmm, Data.Set has O(1) asymptotic for "size :: Set -> Int", while Data.HashSet and Data.IntSet have O(n)
08:41:06 <lyxia> ph88: the only options I can see are either to add the expected result of the lookahead as a parameter, or to return it in arbitraryT alongside T.
08:42:05 <ertes> tabaqui1: IntSet doesn't seem to store its size explicitly
08:42:21 <ertes> if you want it to be O(1), you need to keep track of it yourself
08:42:22 <tabaqui1> Sheo: about fmap . fst - there was little complicated tuple, and I wanted to extract (a, (_, c), _)
08:42:35 <tabaqui1> ertes: yes, why it doesn't store by desing
08:42:50 <ertes> tabaqui1: because it doesn't need it for its operations
08:42:57 <jophish> whois jw358 
08:43:18 <tabaqui1> ertes: Data.Set don't use it too, right?
08:43:43 <byorgey> tabaqui1: perhaps because in order to compute the correct size it would have to force an entire insertion operation?
08:43:52 <byorgey> rather than letting some parts of it be computed lazily.
08:44:12 <byorgey> I am just guessing here, I don't actually know the details.  You'd think if it was easy to keep track of the size the implementor would have done it.
08:44:30 <ertes> tabaqui1: Set needs the size for balancing
08:44:46 <tabaqui1> ertes: ok
08:45:09 <ertes> Set is a binary tree, while IntSet is a radix tree (or as djb would call it: a "critbit tree")
08:45:44 <tabaqui1> so most of haskell developers prefers to optimize memory agains speed?
08:45:58 <merijn> IntSet is a patricia tree, afaik
08:46:12 <merijn> Which is similar, but not quite a radix, iirc
08:46:14 <tabaqui1> or they think, that I can choose between them, just by adding new Int in structure>
08:46:15 <tabaqui1> ?
08:46:31 <ertes> tabaqui1: it's not an optimisation, it's just: "this data structure doesn't need to know the size for efficiency, so we don't store it"
08:46:41 <byorgey> tabaqui1: there's no way to generalize to all Haskell developers by looking at a single library.
08:46:54 <ertes> tabaqui1: users who need the size can keep track of it themselves (or pay the cost to compute it on the fly)
08:48:04 <ertes> tabaqui1: after all you could ask the same question of 'length' for '[]'
08:48:26 <tabaqui1> in case of lists, it pretty clear for me
08:48:46 <tabaqui1> after all they can have infinite size
08:49:09 <ertes> that doesn't mean that you couldn't store the size anyway…  the size field would just diverge for infinite lists =)
08:49:26 <ertes> just make sure the size field isn't strict
08:49:50 <tabaqui1> hm, ok, data for the god of data
08:52:43 <ertes> merijn: the terminology is a bit overloaded…  a trie is supposed to branch for every bit, while a radix tree is supposed to branch more effectively…  you could probably say that a PATRICIA/"critbit" tree is a structure that branches most effectively
08:55:22 <recursion-ninja> Hey I want to use the function: GHC.Integer.Logarithms.integerLog2# on some `Integer` value but the compiler says " Couldn't match a lifted type with an unlifted type". How do I use the function?
08:56:34 <jophish> recursion-ninja: flog2 :: Natural -> Natural; flog2 x = fromIntegral (I# (integerLog2# (toInteger x)))
08:56:52 <glguy> recursion-ninja: If you don't want to dive into GHC internals you can use a package like http://hackage.haskell.org/package/integer-logarithms-1.0.1/docs/Math-NumberTheory-Logarithms.html
08:57:11 <jophish> you can use Integer and Int instead of Natural by dropping toInteger and fromIntegral
08:57:23 <recursion-ninja> I just need the `countLeadingZeros` with reasonable time complexity
08:57:54 <recursion-ninja> On Integers, which, for obvious reasons aren't instances of FiniteBits...
08:58:24 <merijn> recursion-ninja: Well, what would the leading zeros on an Integer be?
08:58:37 <merijn> Wouldn't that just always be either 0 or infinity?
08:59:11 <recursion-ninja> Fine trailing zeros, the zeros beofre the least significant bit
08:59:41 <recursion-ninja> I need `BitVector` to be an instance of FiniteBits which uses an `Integer` internally to store the bits.
09:00:24 <ertes> recursion-ninja: is there a difference between BitVector and Natural?
09:00:53 <recursion-ninja> Yes, BitVector has a dimension. It contains a finite number of bits
09:01:04 <ertes> statically?
09:01:33 <recursion-ninja> ertes: It's my understanding that Natural has no finite number of bits
09:02:16 <ertes> that's correct, but how does your BitVector constrain the size?  its only option for FiniteBits to make sense is via a type argument
09:02:17 <recursion-ninja> ertes: Not statically, but the type signature for `finiteBits :: b -> Int` doesn't require the bits to be static across all values.
09:02:56 <ertes> finiteBitSize is supposed to return the *size* of the *type*, not the base 2 logarithm of the argument
09:03:09 <glguy> recursion-ninja: No, it's expected to ignore it's argument
09:03:15 <glguy> "Return the number of bits in the type of the argument. The actual value of the argument is ignored."
09:03:21 <glguy> http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Bits.html#v:finiteBitSize
09:03:35 <ertes> > finiteBitSize (0 :: Int64)
09:03:37 <lambdabot>  64
09:03:40 <ertes> > finiteBitSize (15 :: Int64)
09:03:43 <lambdabot>  64
09:04:00 <glguy> recursion-ninja: You should expect a user to provide 'undefined' as the argument to that class method and for that to work
09:04:11 <recursion-ninja> glguy: I've read that. But if it's expected to ignore the argument why isn't the type signature: `finiteBits :: Int`? Obviously this hack exists for my use case.
09:04:29 <glguy> recursion-ninja: Your proposed type couldn't fit into the typeclass
09:04:55 <ertes> recursion-ninja: because of the way type classes work…  the proper type would be:  finiteBitSize :: (FiniteBits a) => proxy a -> Int
09:05:07 <ertes> but for historical reasons (i guess) it doesn't use a proxy
09:05:13 <glguy> (he left)
09:05:20 <ertes> ah
09:06:58 <christiaanb> ertes: the proper type would be "finiteBitSize :: FiniteBits a => proxy a -> Word"
09:10:36 <reactormonk> https://hackage.haskell.org/package/uri-conduit-1.1.1.2 is deprecated - how do I find out what is the succeeding package?
09:12:32 <glguy> reactormonk: You could email the author or try a web search to see if the author said anything about it online.
09:16:32 <ph88> lyxia, the expected result should be either passed down to the arbitraryT function, or the arbitraryT function should be able to detect it from the context (which i don't think is possible .. but who knows). Unlike a parsing function arbitrary is not working on a stream and so i don't think there is lookahead to what the next arbitrary value will be (need to reverse the order of the execution here as well)
09:20:08 <ph88_> :)
09:31:22 <stephaner> hi everyone, in this code http://lpaste.net/352179 , I don't understand why I need to use the bang pattern, why deepseq alone is not sufficient so as the content of the file is evaluated strictly ? 
09:33:45 <nitrix> stephaner: I think that's because it only calls the `depseq` if the value is needed.
09:34:30 <stephaner> ok, there is a thunk just above deepseq that isnt evaluated
09:34:40 <nitrix> So if strictContent is needed lazily, deepseq doesn't have a chance to evaluate the data structure deeply.
09:34:45 <nitrix> stephaner: That's my guess.
09:35:01 <stephaner> good guess, that's partly why I try the bang pattern
09:35:06 <nitrix> stephaner: Your let-expression is similar to `force` from the same module you're using and it's documented this way.
09:35:08 <stephaner> I will try to verify this
09:35:35 <stephaner> oh ? thanx
09:35:43 <stephaner> I will check the documentation then, thx
09:36:08 <nitrix> "a variant of deepseq that is useful in some circumstances:"
09:36:10 <nitrix> "force x = x `deepseq` x"
09:36:15 <nitrix> "force x fully evaluates x, and then returns it. Note that force x only performs evaluation when the value of force x itself is demanded, so essentially it turns shallow evaluation into deep evaluation."
09:37:03 <recursion-ninja> Is there a predefined function I can use of type: `Integer -> [Word]` or `Integer -> [Int]` that will give me the "byte/int/word array" backing of the `Integer` value so I can opperate on it block by block?
09:38:38 <muzzle> recursion-ninja Data.Binary.encode ?
09:39:11 <muzzle> which gives you a bytestring, that you can unpack into a [Word8]
09:39:15 <muzzle> ?
09:39:46 <recursion-ninja> muzzle: will that operate in O( log-base< machine-word-size>(n) )
09:41:15 <muzzle> recursion-ninja, I'm not really sure
09:41:20 <muzzle> maybe someone else knows
09:41:49 <stephaner> nitrix, where do you read the documentation ? you had to generate it ?
09:42:26 <recursion-ninja> muzzle: I was hoping for a larger word size than 8 bits so that the logrimic complexity of the operation would have a much higher base. a list of Word32 or Word64 would be preferable. Does Data.Binary have something that outputs a lis of larger Word sizes
09:43:41 <muzzle> recursion-ninja, I don't think so
09:44:10 <muzzle> recursion-ninja, encoding with Data.Binary gives you a ByteString which is Word8-backed
09:45:13 <geekosaur> only when unpacked. ByteString itself is stored in a packed byte format
09:46:44 <recursion-ninja> muzzle: It looks like calling `encode` on an `Integer` isn't O(1), but O(log_8(n)). It'll work I guess, but just "getting" a copy of the `Integers` already existing `ByteArray` would be better.
09:46:49 <geekosaur> if for some reason you need to "unpack" into a different format, you can use the unsafe* ByteString functions to access the packed byte array directly and decompose it as you need using the Foreign.Marshal.Array stuff
09:46:55 <lyxia> "logarithmic complexity" is the same no matter the base
09:48:33 <recursion-ninja> lyxia: Thanks for the pedantic remark. A higher logrithmic base will require fewer computational steps than a lower logrithmic base. I was inquiring if a more efficient option was readily available.
09:48:47 <Tuplanolla> Suddenly base `1 + 1 / n`.
09:49:14 <nitrix> stephaner: https://hackage.haskell.org/package/deepseq-1.4.2.0/docs/Control-DeepSeq.html#v:force
09:51:17 <lyxia> recursion-ninja: how about unpacking the Integer http://hackage.haskell.org/package/integer-gmp-1.0.0.1/docs/GHC-Integer-GMP-Internals.html#t:Integer
09:51:35 <lyxia> BigNat is a ByteArray#
09:52:38 <recursion-ninja> lyxia: Every time I try to use functions from that module I get compilation errors about "lifted" and "unlifted" types. 
09:53:06 <recursion-ninja> lyxia: I'd appreciate a tutorial that explains how to use funtions with '#' in them.
09:54:24 <thatguy> can anyone tell me why this here gives me parse error on ')' (the last ) is meant) : satisfy (=='C') <|> (pure '')
09:54:39 <glguy> thatguy:  '' is invalid
09:54:43 <glguy> there's no "empty" character
09:55:09 <EvanR> empty set is a subset of every type
09:55:10 <Tuplanolla> Since `IPV6_V6ONLY` is not guaranteed to be supported, is it a better idea to run different socket types separately and concurrently?
09:55:43 <EvanR> you want ipv6 only?
09:55:47 <thatguy> glguy: EvanR thanks
09:55:52 <Tuplanolla> I want both, EvanR.
09:55:57 <EvanR> lol i didnt help you at all
09:56:14 <EvanR> Tuplanolla: right, so you wouldnt ONLY
09:56:30 <EvanR> the only system i know of that doesnt allow listening on both with one server socket is netbsd
09:56:46 <Tuplanolla> Good to know.
09:57:06 <EvanR> and that fact is over 10 years old now
09:57:36 <thatguy> how do I do what I need then: I want a parser which will parse a ')', the parser satisfy (==')') does exactly this. the problem is, that it will return Nothing in case it does not find a ')', I need it to resurn Just '' in case it does not parse anything
09:57:51 <thatguy> ah thats really not possible probably
09:57:52 <EvanR> you cant need to return Just ''
09:57:59 <EvanR> '' doesnt make any sense
09:58:07 <EvanR> a char is exactly 1 char
09:58:07 <thatguy> yeah I get what is the problem now
09:58:35 <lyxia> recursion-ninja: Okay, so you unwrap your Integer, and get a ByteArray#, then you can wrap it back in ByteArray (http://hackage.haskell.org/package/primitive-0.6.2.0/docs/Data-Primitive-ByteArray.html) and you're back in the lifted world.
09:59:12 <recursion-ninja> lyxia: So just use the `ByteArray` constructor?
09:59:17 <thatguy> Yeah well I have this big parsing thing and I just want the whole expression to eat up any ')' at the end of my line, so I thought "<* satisfy (==')' )" would do, the problem is, if this returns Nothing, the whole expression will turn to nothing what I can't have
09:59:22 <thatguy> can anyone help me out?
09:59:53 <recursion-ninja> lyxia: I wish that hoogle helped me when I searched for that: https://www.haskell.org/hoogle/?hoogle=ByteArray%23+-%3E+ByteArray
10:00:42 <recursion-ninja> lyxia: Thank you VERY VERY MUCH. I'm goign to go try and see if I can get this to work :)
10:00:48 <EvanR> thatguy: use optional to parse something that might not be there
10:02:01 <lyxia> recursion-ninja: the hackage hoogle is pretty outdated indeed.
10:02:04 <lyxia> recursion-ninja: https://www.stackage.org/lts-7.19/hoogle?q=ByteArray%23+-%3E+ByteArray
10:02:10 <thatguy> EvanR: hmm, satisfy (==')' ) will return Nothing in case there is no ')'
10:02:13 <thatguy> but that is the problem
10:02:22 <thatguy> since usefulStuff <* Nothing == Nothing
10:02:31 <thatguy> and I want usefulStuff <* Nothing = usefulStuff
10:02:42 <recursion-ninja> lyxia: I guess I
10:02:53 <lyxia> recursion-ninja: there's hoogle.haskell.org which has been hidden in alpha forever, and hayoo is a pretty comprehensive alternative, with weaker type search IIRC.
10:02:53 <recursion-ninja> lyxia: I guess I'll use that one from now on
10:03:25 <EvanR> thatguy: optional (char ')')
10:04:06 <thatguy> EvanR: thanks
10:04:08 <EvanR> satisfy doesnt return a Maybe
10:04:14 <EvanR> optional does
10:04:23 <EvanR> satisfy might fail, optional wont
10:04:25 <thatguy> but I forgot to mention I am doing it with an own implemented class (I am doing the CIS 194, Spring 2013 course) 
10:04:36 <EvanR> oh well then i dont know whats what
10:05:41 <thatguy> EvanR: yeah probably its hard to answer that question without knowing what the class implementations are
10:05:57 <thatguy> thanks anyway
10:06:02 <thatguy> :)
10:06:19 <lyxia> recursion-ninja: when you get an error about lifted vs unlifted, it's a type mismatch. Like you put an Int# where an Int was expected. Int# and Int are different types, like Bool and String, but Int# also has a different kind and that's what GHC is complaining about.
10:07:33 <uros> Hey all, i'm still kinda haskell noob and i have small problem. I don't have $ and <$> in my module. What could be a reason for that?
10:07:53 <recursion-ninja> lyxia: I gathered that from the documentation, but there was no explanation about how to convert between lifted and unlifted types.
10:08:28 <recursion-ninja> lyxia: It'll probably be different for every set of values but a few examples would have been nice.
10:08:43 <geekosaur> @index (<$>)
10:08:43 <lambdabot> Data.Functor, Control.Applicative, Prelude
10:09:12 <lyxia> recursion-ninja: oh, yeah they're somewhat spread out in various modules.
10:09:26 <geekosaur> in older ghc you probably won;'t have <$> from Prelude. $ should be there. can you show full source (i.e. including imports) that fails?
10:09:30 <geekosaur> @paste
10:09:30 <lambdabot> Haskell pastebin: http://lpaste.net/
10:09:35 <MarcelineVQ> recursion-ninja: don't forget to bone up on the manual in such cases https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#primitives
10:09:46 <Tuplanolla> @index (&)
10:09:47 <lambdabot> Data.Function
10:09:57 <Tuplanolla> Does this thing not index `lens`?
10:10:31 <uros> geekosaur: sure, in a sec
10:10:32 <geekosaur> lens is not a bootlib
10:10:43 <geekosaur> (it only indexes things that come with ghc)
10:11:27 <uros> by the way, it's a yesod app and it excludes prelude so it would be nice to include $ only or something like that
10:12:42 <geekosaur> excluding Prelude is usually a bad idea unless you are using a Prelude replacement (which should have at least ($))
10:13:13 <lpaste_> uros pasted “MyAuth” at http://lpaste.net/352180
10:13:51 <uros> geekosaur: lines 22 and 32 
10:15:29 <geekosaur> ok, you probably want to add ($) and (<$>) to the import on line 8
10:17:36 <uros> geekosour: that's it. I tried that earlier, but forgot parents so it didt'n work. now is's ok
10:18:14 <uros> i have a feeling that ghc it's messing with me.. "The import of ‘$’ from module ‘Prelude’ is redundant"
10:18:21 <uros> *is
10:18:59 <Enigmagic> recursion-ninja: run `:info Int` in ghci to display the constructors for Int. Int/Double/etc are wrappers around the unlifted primitives
10:20:34 <Enigmagic> :t GHC.Ext.I#
10:20:37 <lambdabot> error:
10:20:38 <lambdabot>     Not in scope: data constructor ‘GHC.Ext.I#’
10:20:38 <lambdabot>     No module named ‘GHC.Ext’ is imported.
10:20:48 <Enigmagic> :t GHC.Exts.I#
10:20:50 <lambdabot> GHC.Prim.Int# -> Int
10:57:42 <Squarism> ive managed to avoid using classes. Is it possible to define a class wo methods? I just wanna make a "generic" datastructure that holds channels who's id is just an instance of a certain class (that doesnt need any methods except those of Eq) . Some "sketch" http://lpaste.net/352186
10:58:04 <Squarism> (...avoid working alot with own made classes that is)
11:00:21 <AWizzArd> In the section about applicative functors the Learn You A Haskell book says: “pure should take a value of any type and return an applicative functor with that value inside it. When we say inside it, we're using the box analogy again, even though we've seen that it doesn't always stand up to scrutiny.”  – What is “wrong” with the box-analogy?
11:00:37 <AWizzArd> *in* the Learn You A Haskell book
11:03:24 <dolio> IO isn't a box.
11:07:04 <AWizzArd> dolio: because it is defined via newtype?
11:07:27 <dolio> No.
11:07:38 <Sonolin> well, technically IO is a box around the RealWorld# state var, right?
11:07:40 <dolio> It just isn't a box.
11:07:47 <geekosaur> RealWorld# doesn't exist
11:07:50 <nshepperd> AWizzArd: an IO String doesn't contain a String
11:07:56 <dolio> It's not a container.
11:08:21 <monochrom> @quote monochrom contain
11:08:21 <lambdabot> monochrom says: new catchy thing to say: an IORef Int contains an Int in the same sense as an IO Int contains an Int
11:08:52 <koala_man> @quote /bin/ls
11:08:52 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
11:08:54 <nshepperd> it 'produces' a String, when executed
11:08:59 <nshepperd> monochrom: :(
11:10:28 <AWizzArd> Okay good, makes sense.
11:10:37 <monochrom> But more seriously, if IO String "contained" a string, then it would have to contain the string that I will enter as input tomorrow, a string that even I don't contain.
11:23:43 <dolio> I think `IO String` has more ways of not containing a string than `IORef String`. :)
11:25:19 <ph88> if i remove line 3 to 6 in this paste https://paste.fedoraproject.org/550692/86495428/ i get  modifyTspace  not in scope on line 2, anyone know why that happens ?
11:25:56 <geekosaur> ph88, where scopes over a single definition. line 7 begins a new definition
11:26:14 <ph88> no other choice than to make a top-level function here ?
11:26:51 <geekosaur> you could rephrase it as a single definition with a case
11:29:04 <ph88> oh ye that works nicely
11:29:18 <ph88> :r
11:38:22 <Phyx-> https://phabricator.haskell.org/P144 anyone see anything weird here? The process starts but never does anything. If I don't try to pipe the stdout it does work
11:39:05 <ertes> Phyx-: don't use hClose
11:39:20 <ertes> or preferably: don't use lazy input (hGetContents)
11:39:27 <Squarism> I read here that constructor constraints are not supported or encouraged. See https://wiki.haskell.org/Data_declaration_with_constraint . What should one use instead?
11:40:06 <ertes> Squarism: constraints at the use sites
11:40:09 <ertes> you will use them anyway
11:40:11 <Phyx-> ertes: it doesn't get there, so that's not my immediate problem..
11:41:11 <Squarism> ertes: you mean, in functions that use the types ?
11:41:48 <ertes> Phyx-: perhaps a buffering issue?  but i don't see how it would apply to your example
11:42:59 <ertes> Phyx-: oh, if your program attempts to write to its stdout, but the handle is already closed, the other possibility is that it receives a SIGPIPE or SIGHUP or something (i can't remember which of those)
11:43:46 <ertes> Phyx-: so removing hClose might fix your problem anyway
11:44:12 <Phyx-> ertes: hm, maybe, but I do wait till process termination to close the handle. But i'll try removing it
11:44:37 <ertes> Phyx-: ah, i don't know if it's correct to do that
11:44:50 <ertes> the process writes, buffer runs full, but nobody is reading
11:45:11 <ertes> the other side is waiting for the process to finish…  so the processes wait for each other
11:45:31 <Phyx-> that is all assuming the process writes. currently, the process starts and is immediately idle
11:45:54 <ertes> Phyx-: is it "idle" or "blocking"?  they look the same from outside
11:46:10 <ertes> Phyx-: try moving waitForProcess to the end
11:46:42 <ertes> (side note: "_ <- c" is the same thing as "c"
11:46:43 <ertes> )
11:46:45 <Phyx-> let's see
11:47:04 <Phyx-> no it's not, GHC will warn that you're ignoring the value
11:47:15 <ertes> ah, you're using -Wall =)
11:47:22 <Phyx-> yes :)
11:47:32 <Phyx-> recompiling
11:48:17 <nitrix> Does async has known issues with bounded threads on windows?
11:48:19 <dolio> `_ <- c` is also potentially less efficient. Thanks Wall.
11:48:33 * ertes uses -W
11:48:46 <ertes> it's a good set of non-annoying warnings
11:49:30 <ertes> the only warning i would add to -W would be shadowing
11:50:00 <Phyx-> right, that worked, thanks ertes 
11:50:22 <ertes> Phyx-: now that you have working code, here is what you should do:  import Control.Exception, then use 'bracket'
11:50:59 <ertes> bracket (createProcess_ …) (\(_, _, _, ph) -> waitForProcess ph) …
11:51:33 <jmnoz[m]> Building code with bitbucket pipelines, they don't have a cache option. for e.g. ~/.stack. What would you do
11:52:37 <monochrom> Hmm, -W is not -Wall?
11:53:10 <ertes> monochrom: -Wall is a lot more picky
11:53:12 <geekosaur> no, -W typically is a subset, -Wall should be everything (sometimes "almost everything", gcc has been known to pull that one)
11:53:45 <monochrom> Ah I found it in the user guide.
11:53:50 <MarcelineVQ> it's in the almost case afaik
11:54:12 <monochrom> GHC also says -Wall is "almost all"
11:54:13 <Tuplanolla> Clang has `-Weverything` for literally every warning.
11:54:38 <Tuplanolla> GCC does not and they don't even document all the flags.
11:55:03 <ertes> BTW, is "_ <- c" really less efficient?  GHC could totally optimise that away
11:55:08 <monochrom> The crowning achievement is that we also have -Wcompat "enable future compatibility warnings"
11:55:24 <monochrom> (I so want to rename it to "enable future-proof warnings" :) )
11:55:42 <ertes> -Wfuture  # warn about the future
11:56:26 * monochrom invents the dual to -Werror! -Ewarn "make errors non-fatal" :)
11:57:00 <Tuplanolla> After you do some `-funsafe-math` and `-vomit-frame-pointer`, you can get yourself a `-Wombat`.
11:57:26 <Tuplanolla> Who even started this naming convention?
11:57:47 <ertes> `catch` (\(SyntaxError moduleName) -> …)
11:58:01 <monochrom> You know, "omit" and "vomit" are opposites, too...
11:58:18 <ertes> -eat-frame-pointer
11:59:22 <monochrom> Tuplanolla: I think someone hierarchically minded did. There are the -W hierarchy, the -f hierarchy, the -d hierarchy, etc.
12:00:29 <MarcelineVQ> actually there is a flag without a dual that should have one, -ddump-to-file
12:02:21 <Tuplanolla> ...and then there is `-fwarn-unsafe`.
12:02:43 <ertes> -Wbeginner would be in order
12:03:01 <ertes> warn about things like 'head', 'read', 'openFile', 'getContents', etc.
12:03:23 <kadoban> -Wbeginner would be really cool
12:11:09 <kubbe> Hello! mniip are you in here? I have some more advanced questions for you. I have got an assignment from school where I am supposed to create this huffman tree. But I got stuck on the priorityqueue-thing. Got a few minutes over for some questions?
12:14:02 <kubbe> or anyone else if they are willing to help me some with this
12:14:18 <ongy> I may be able to help, if you post the question
12:18:13 <kubbe> Yes! Okey: So as said, my assignment is to create a huffman tree and everything that is connected to it. Let me post the code I have so you can check what I am talking about.
12:19:10 <Ptival> what's the 2017-approved Haskell unit testing library?
12:19:56 <kubbe> http://pastebin.com/Fedz7RsJ
12:19:57 <kadoban> I use hunit (and quickcheck and tasty to bring it all together) and it seems to work fine
12:20:32 <Ptival> I was thinking of HUnit+QuickCheck, was wondering about whether Hspec was something to look into
12:20:43 <Ptival> did not know tasty, will look
12:21:06 <kadoban> I don't know much about hspec, I think it's instead of tasty, from overhearing things. Couldn't say much what the difference are.
12:21:11 <kubbe> onyg, here we believe that we create the tree under "data Tree", which is polymorphic. It is supposed to show us both the character and the Int (rank) in the tree. But it is giving us error on the empty-function for some reason
12:23:02 <kubbe> So my question: What should the type PrioQ a be equal to so it wont give me errors?
12:23:34 <sternmull> Documentation of seq says "The value of seq a b is bottom if a is bottom, and otherwise equal to b.". What the hell is "bottom"?
12:24:23 <kadoban> sternmull: Bottom is undefined/error "something" or computations that loop forever, or otherwise don't complete.
12:25:29 <sternmull> kadoban: Ah, thank you.
12:27:33 <kadoban> That documentation is a little ... hard to understand the first time, at least it was for me. The more intelligible description would probably be something like ...  a `seq` b  means  evaluate 'a' before you evaluate 'b'. Though that's not exactly 100% rigorous or correct.
12:28:15 <cocreature> Ptival: fwiw I really like hspec
12:28:48 <jle`> @tell erisco there's a lot you can do with lists
12:28:48 <lambdabot> Consider it noted.
12:29:14 <jle`> @tell erisco working with lists and working with nat's is actually pretty similar, structurally.  Nats are just [()]
12:29:14 <lambdabot> Consider it noted.
12:30:03 <jle`> @tell so you can use a lot of what you learned working with nats and generalize it directly to working with lists
12:30:03 <lambdabot> Consider it noted.
12:31:13 <byorgey> jle`: you know you just @told that second sentence to the nick 'so'
12:32:08 <sternmull> kadoban: What was a bit surprising is that "seq a b does not guarantee that a will be evaluated before b.". But it probably only means i should read the documentation very carefully before i use stuff.
12:33:57 <byorgey> sternmull: right, it only guarantees that a *will* be evaluated before the value of b is returned.  But that doesn't say anything about the order of evaluation.
12:35:00 <byorgey> sternmull: if you really care about the evaluation order (for example, if you are doing something with parallelism), you can use 'pseq'
12:35:42 <sternmull> byorgey: yes, that is even mentioned in the documentation of seq.
12:36:04 <byorgey> ah, so it is
12:36:41 <ph88> can someone talk to me about my parser code? i'm getting stuck on how to organize my code and abstractions
12:37:41 <sshine> ph88, sure. link?
12:38:20 <spikefoo> kubbe: you used 'type' to define PriorityQueue, which makes it an alias of [Heap a]. So a PriorityQueue is the same as [Heap a], and the definition of empty would be 'empty = []'
12:38:21 <sternmull> is there a kind of "cheat sheet" for all the popular operators? As a beginner i find myself constantly checking out the types of >> >>= and so on to remember what their purpose was. It will take me a while before i can decide quickly when to use which one.
12:38:22 <ph88> sshine, can i query you ?
12:38:54 <spikefoo> kubbe: but you probably wanted to use 'data' to define a new type: 'data PriorityQueue a = ...', which will make your definition of empty correct
12:39:06 <Tuplanolla> Send an email and ask if you can email him, ph88.
12:39:13 <sshine> ph88, okay, but I'd prefer if you posted a link to a pastebin here. :)
12:41:55 <kubbe> Oh, okey! I changed it now. I saw a few "hints" we got. Check this out: http://pastebin.com/v9C86V2f
12:42:20 <kubbe> It works for empty now. Now I am planning on attacking the next part: With the insert.
12:46:51 <spikefoo> kubbe: I think it's better to use 'data PriorityQueue = ...' instead. That way priority queues are a different type than lists, which makes sure you never use a list as a priority queue
12:47:43 <kubbe> spikefoo, you are probably right but we are 'forced' to use type. We are supposed to learn how to handle types and typeclasses aswell. I would not have done this way normal
12:49:41 <kubbe> but in this case; the priotityqueue-type is returning a list of the two values I have in the tree, right? spikefoo
12:50:22 <spikefoo> kubbe: make sure your assignment is to really use a 'type' statement, because only a 'data' statement actually creates a new type. 'type' statements do not create a new type, only an alias
12:51:17 <spikefoo> kubbe: It looks like you're not using the Tree data type you defined. Are you implementing a priority using an array or using a heap (tree)?
12:54:28 <kubbe> I am not really sure if im honest. I am supposed to use heaps, but I havn't really understood whats up. Since I am creating arrays of tuples with the values. And the least-function is supposed to take out the lowest rank (the int-value) from I gues the array. And the input-examples you can see under the function-specs
12:57:59 <kubbe> I am only using the Tree data type in the Heap data type. But I am not sure what either is doing. Especially confused around the "[Tree a]" in the Tree data type spikefoo
12:58:45 <spikefoo> kubbe: did you write the definitions of Tree and Heap, or are they part of the assignment?
13:00:01 <spikefoo> kubbe: if you're implementing a priority queue using a heap, you don't need a [(a,Int)] list. Just a heap (a tree whose root is the minimum element)
13:00:03 <kubbe> I wrote the definitions on the data types Tree and Heap. They are not really that important, but that is the way we did trees before. And I have understood that the Heap is supposed to create an array of trees? Why, I have no idea spikefoo
13:00:44 <kubbe> Oh, okey. How do I create that? I got a bunch of errors when I tried to return Heap directly into PQ a
13:01:06 <c_wraith> "heap" is a name shared by a lot of partially ordered data structures. 
13:02:25 <spikefoo> kubbe: if you write 'data PriorityQueue a = PriorityQueue [(a, Int)]', use can use 'PriorityQueue lst' to make a priority queue out of list lst. so empty becomes 'empty = PriorityQueue []'
13:03:16 <spikefoo> kubbe: but if you're implementing a heap, you don't need that array. You only a need a tree.
13:03:35 <kubbe> Alright, 2 sec im gonna write it. I have some "Hows it going"-class tomorrow where I'll ask if the code is OK. But I think that as long as I can explain whats up then it'll be fine
13:04:11 <kubbe> Okey, are those two variants different? The thing where I re-write the priorityqueue or where I change the data types? spikefoo
13:06:31 <spikefoo> kubbe: if you're using the heap implementation, you'll only use one data definiton: 'data PriorityQueue = ...' to define it as a tree structure. If you're implementing using an array, you'll also use a single data definition 'data PriorityQueue = PriorityQueue [(a,Int)]'.
13:07:00 <spikefoo> So, you only need one data definition any way
13:07:14 <spikefoo> I'm guessing you need to implement a binary heap, if you learned about trees
13:07:30 <spikefoo> so find out what implementation you need to write
13:08:08 <kubbe> Yes, I do need to implement a binary heap. Trees have been the focus for a few classes now. Now I heard that I can use w/e definition of priorityqueue. Its my choosing, and therefor I can have w/e data types aswell
13:09:27 <spikefoo> kubbe: so you only a single definition 'data PriorityQueue = ...'. There's no need to define the Tree and Heap data structures.
13:09:33 <spikefoo> *only need
13:09:42 <kubbe> I think I'll try it with the heap implementation. But if Im not going to have heap as a data type, should it be a type statement instead?
13:12:42 <spikefoo> kubbe: you can define a single data type called PriorityQueue, you don't need a data type named "Heap". The PriorityQueue itself will be a binary heap
13:13:31 <kubbe> thats cool! Okey. I guess it will look the same as my data Tree does at the moment?
13:13:37 <kubbe> spikefoo
13:15:02 <spikefoo> kubbe: yes, except you don't want a list of children ([PriorityQueue]), becuase there are at most two children for each node, not any number of children
13:16:41 <kubbe> Oh, and then I'll create the tree recursivly instead? Like this: http://pastebin.com/JGJ5BwKL spikefoo
13:17:40 <spikefoo> kubbe: exactly. you need to update 'empty' now for this new implementation
13:19:42 <kubbe> So 'empty' should now return the empty tree?
13:19:48 <spikefoo> kubbe: yes
13:20:49 <AWizzArd> One „problem” of static type checking for example in Java is: when you want to implement an interface you need to implement all methods at once. But typically a dev wants to implement one specific functionality.
13:20:53 <AWizzArd> If the compiler now rejects incomplete implementations then some stub methods need to be added. It could happen that they are forgotten later.
13:20:58 <AWizzArd> How does this work out with Haskell, when one wants to make a data type an instance of a Type Class?
13:21:05 <kubbe> spikefoo: in my point it should just say "empty = Empty"?
13:21:16 <spikefoo> kubbe: yes
13:21:36 <spikefoo> i'm ave to go now
13:21:38 <spikefoo> bye
13:23:28 <EvanR> AWizzArd: classes with a huge number of interfaces that you dont want to fully implement? sounds broken
13:23:51 <EvanR> a huge number of methods*
13:24:21 <EvanR_> however you dont have to implement anything if you dont want to, you can leave it undefined, in which case itll crash at runtime
13:25:36 <AWizzArd> EvanR: probably one would like to implement all methods belonging to an interface, but not at the moment of realization that a type should belong to a certain type class.
13:26:21 <EvanR_> haskell definitely supports incomplete programs
13:27:37 <EvanR_> i just write the code
13:27:46 <EvanR_> instance Show Foo where -- nothing else
13:27:58 <EvanR_> code loads, gives me a warning
13:28:01 <sshine> AWizzArd, not sure Haskell is any different there. you might leave a bunch of 'undefined's around and forget about them. in both cases one should be able to detect such matters using a lint tool.
13:28:31 <EvanR_> show Foo gives me a freeze up
13:31:18 <AWizzArd> Okay, so I can use  instance TC MyType where …  and simply not write implementations for all functions belonging to the type class TC.
13:33:14 <nitrix> mokus_: I opened https://github.com/mokus0/monad-loops/pull/16
13:33:42 <nitrix> mokus_: Let me know if you're actually the maintainer and if you need to discuss it.
13:40:44 <nitrix> Is async bounded threads known to not be compatible with runInBoundThread? Also, are there known issues for async on windows?
13:42:33 <nitrix> I'm getting really curious freezing of my SDL window, presumably stuck in a foreign call. It looks like there are no race conditions with the MVars I'm using, but that too is plausible.
13:43:04 <nitrix> If I had a memory corruption problem with local thread variables, would the Haskell runtime segfault instead of freezing?
13:43:26 <nitrix> GHC detects MVar deadlocks too, I'm confused.
13:43:41 <maerwald> use promela :P
13:45:09 * nitrix debugs a little more before figuring out a minimum test case.
13:48:03 <sternmull> can i use hoogle to get a complete offline documentation? When i start the server locally then it searches the local index (i think) but all the links point to the public site. It would be nice to have the complete documentation offline.
13:48:30 <mzabani> Does anyone here know if http-client can be used on a different medium? My intention is to use it through a WebSocket tunnel on an already established connection..
13:51:35 <EvanR_> nitrix: thread-local variables?
13:51:43 <EvanR_> like, OpenGL
13:53:00 <nitrix> SDL
13:55:26 <EvanR_> i mean, thread-local state, or just variables
13:56:54 <nitrix> EvanR_: https://wiki.libsdl.org/SDL_PumpEvents
13:56:57 <nitrix> EvanR_: "WARNING: This should only be run in the thread that initialized the video subsystem, and for extra safety, you should consider only doing those things on the main thread in any case."
13:57:30 <nitrix> EvanR_: It's not much to work with. Just a mere warning telling me the polling of events has to happen in the same thread as the one that initialized SDL.
14:04:19 <nitrix> Oh gosh, I think I found the problem.
14:04:41 <nitrix> EvanR_: Are multiple invocations of runInBoundThread going to use their own independent thread?
14:04:54 <nitrix> (As opposed to sharing a common one?)
14:05:58 <kstuart> sternmull: have you tried 'hoogle generate --local'
14:06:28 <kstuart> https://github.com/ndmitchell/hoogle/blob/master/docs/Install.md#index-all-ghc-pkg-installed-packages
14:06:44 <nitrix> EvanR_: e.g. do { a <- forkIO $ runInBoundThread $ foo; b <- forkIO $ runInBoundThread $ bar }
14:07:19 <nitrix> EvanR_: Are `a` and `b` going to share the same bound thread? How about forkOS ?
14:10:57 <sternmull> kstuart: i do not remember how i generated the index. Now i did it with --local. Search still works, but now the links to more documentation are dead... but at least they point to local URLs :)
14:13:05 <kstuart> ah, just getting started with haskell and happened to be reading that hoogle page ;)
14:14:04 <exio4> nitrix: I don't know there are guarantees about that, nor about the opposite
14:14:46 <nitrix> exio4: Can I have two forkIO threads pinned to the same forkOS thread easily?
14:15:13 <exio4> nitrix: no idea, I haven't played much with that stuff =)
14:15:28 <dmwit> forkIO threads can't be pinned at all.
14:15:35 <nitrix> exio4: It doesn't help that GHCi has a bug in it, where the main function isn't ran in a bound thread.
14:15:58 <dmwit> Also you cannot ask that two forkOS'd actions be run on the same OS thread.
14:15:58 <nitrix> The documentation says main is always ran in a bound thread, but this is a lie for GHCi.
14:16:20 <dmwit> What's the goal?
14:16:25 <Tuplanolla> You should probably rethink your architecture if you find yourself yearning for these guarantees, nitrix.
14:16:40 <nitrix> dmwit: Polling events from a window as well as rendering it.
14:16:54 <nitrix> dmwit: Both twos must happen in the OS thread that initialized SDL.
14:17:09 <dmwit> Usually GUI libraries have a way to send an action as an event.
14:17:15 <dmwit> Then the event loop will get the event and act on it.
14:17:23 <nitrix> dmwit: That's the precise problem.
14:17:42 <nitrix> I don't want the rendering to stop while waiting for events. And polling events is a naive approach.
14:18:08 <Tuplanolla> You can have the main thread read a channel, which other threads write into, to pass messages around, nitrix.
14:18:12 <dmwit> nitrix: Make another thread. It doesn't have to be bound to the same OS thread. Have it send an event to the event loop.
14:18:32 <dmwit> Tuplanolla: Not if the main thread is running the event loop...
14:18:34 <nitrix> Tuplanolla: I am doing exactly that and here we are :)
14:18:47 <Tuplanolla> Oh, right...
14:18:48 <nitrix> dmwit: I'm doing also exactly that :)
14:18:59 <dmwit> nitrix: Then I very much don't understand.
14:19:41 <nitrix> https://github.com/nitrix/lspace/blob/develop/src/Kawaii/Engine.hs#L52
14:20:03 <nitrix> This was one of the original implementation. Things have been thrown around a lot since then.
14:20:36 <nitrix> You can basically imagine all the combinations of asyncBound, async and runInBoundThread possible.
14:20:58 <ph88> if i have structures like  Foo (Wrap T) (Bar (Wrap T)) (Wrap (Qux (Wrap T)))  where all the structures contain a T eventually somewhere and i want to modify the last T .. is that a job for Lens or for generic programming ?
14:21:06 <nitrix> I do feel like I have a better understanding now so this definitely looks wrong. But even my current approach yields weird results.
14:21:37 <dmwit> nitrix: Have you looked through http://dmwit.com/gtk2hs, which discusses how to do threading the Right Way for gtk2hs? Probably the same commentary applies to SDL with some alpha varying of API call names.
14:21:43 <ph88> nitrix, you should put some screenshots in your readme :P
14:21:53 <glguy> ph88: That doesn't have anything in particular to do with a Lens
14:22:03 <ph88> k
14:22:08 <dmwit> nitrix: In short: almost nothing needs to run in a bound thread.
14:22:09 <nitrix> ph88: The master branch had somewhat of a working game with physics and all.
14:22:19 <glguy> You might make a lens that "refers" to the "last T" that's at a different layer
14:22:21 <dmwit> nitrix: Just the main event loop, usually; and on Linux, not even that. =P
14:22:37 <nitrix> ph88: https://github.com/nitrix/lspace/blob/master/assets/tileset.png Look at the cute little guy !
14:22:43 <ezgoat> .leave
14:22:45 <ph88> glguy, i don't want to write a function for each structure separately
14:23:00 <ph88> oh ye looks nice
14:23:13 <dmwit> nitrix: This code looks a bit  bigger than I expect I can digest in one sitting.
14:24:10 <nitrix> dmwit: I think I was rubber ducking more than anything. Don't waste your time.
14:24:17 <nitrix> I'll eventually figure it out, as always :P
14:25:06 <Tuplanolla> I recently did something similar with Brick, but that thing gives you a `Chan` to send messages through.
14:25:12 <dmwit> nitrix: I'd like to help. But at the moment it's not clear to me what you're trying; what behavior you're exhibiting; and what behavior you're expecting instead.
14:25:55 <nitrix> dmwit: Give me a little time to experiment. I am trying to narrow it down for simplicity sake, and I'll actually have a test case to present if it doesn't lead anywhere.
14:26:03 <dmwit> cool
14:26:46 <nitrix> I realise not many people care about havin their events processed in parallel while the rendering is happening but I do :P
14:27:38 <dmwit> I think it's a perfectly reasonable goal.
14:27:58 <nitrix> And it's not realistic to ask library authors to design their library to be thread safe. That'd just be an overhead.
14:28:16 <qmm> data Foo :: !Foo
14:28:33 <qmm> does the bang represent strict evaluation?
14:28:49 <davean> qmm: yes
14:29:23 <nitrix> qmm: In this case I think it makes no difference.
14:29:24 <dmwit> qmm: Generally ! is about strictness. But that exact syntax doesn't look valid to me; are you sure you copied/pasted right?
14:29:43 <nitrix> qmm: I recall someone saying that the bang pattern makes the constructor strict and you have no constructor there.
14:30:18 <davean> qmm: https://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/glasgow_exts.html#bang-patterns-and-strict-haskell
14:31:27 <nitrix> data Foo = MkFoo !Int;   MkFoo's implementation basically becomes MkFoo x = x `seq` ...
14:31:29 <qmm> dmwit: not necessarily sure that it's correct, but i keep seeing bangs in value constructors and i wasn't entirely confident why
14:31:44 <qmm> nitrix: thanks
14:31:48 <qmm> davean: thank you as well
14:45:04 <jle`> qmm: the idea is that when you pattern match on the MkFoo constructor, it also forces evaluation of the :Int field inside
14:45:23 <jle`> when you pattern match on something, ghc has to evaluate it enough to figure out what the constructor is
14:45:53 <jle`> the ! annotation for fields tells ghc that when it does try to figure out the constructor, then also evaluate what it *contains* as well
15:00:11 <athan> Hi everyone. The ARM RTS doesn't accept -N as a parameter; does this mean the ARM GHC targets are all single threaded?
15:00:34 <athan> in terms of green threads, I mean. I see that -threaded is accepted as a compile option though
15:18:37 <czcxa> Hello! I encountered a problem. I am using zlib in my project. The problem is that decompress can throw exception and I want avoid it. I would like to have something like decompress :: ByteString -> Maybe ByteString. Does anybody have any ideas how to achieve this?
15:20:23 <jle`> czcxa: the reason why it's ByteString -> ByteString is because it might not be known that the result is failing until the entire thing is valuated
15:20:40 <jle`> while you can process it chunk-by-chunk up to the point where the error is
15:20:48 <johnw> has anyone created bindings from Haskell to Google's or-tools?
15:21:03 <jle`> any 'ByteString -> Maybe ByteString' implementation would necessarily be non-lazy
15:21:08 <hpc> czcxa: use rnf and evaluate to tie the evaluation back to IO
15:21:14 <hpc> czcxa: and then you can catch the exception normally
15:21:19 <jle`> and load the entire resulting final byetstring into memory
15:21:30 <hpc> (if you don't mind it being in IO)
15:21:32 <jle`> if you're ok with that, you can use the 'spoon' library
15:21:44 <hpc> or use https://hackage.haskell.org/package/spoon
15:21:47 <hpc> lol
15:21:48 <jle`> specifically the 'spoon' function
15:21:51 <jle`> http://hackage.haskell.org/package/spoon-0.3.1/docs/Control-Spoon.html
15:22:27 <jle`> but this does force the entire input to be decompresse and stored in memory before you can ever access even the first byte of the result
15:23:19 <jle`> if you want more fine-grained control, you might have want to look for a pipes/conduit wrapper for zlib, but for simple use cases it might be fine
15:25:06 <czcxa> Hm. I don't need Lazy BS, and wish avoid IO. I know about spoon, I thought there is a better solution...
15:25:49 <jle`> if you don't want a lazy BS, then you're going to have to store the entire result in memory anyway
15:25:57 <jle`> so spoon should work
15:29:05 <czcxa> Good. I'll try to use a spoon. Of course it would be nice if the zlib would provide the function with no exceptions.
15:30:04 <czcxa> Thanks <hpc> and <jle`> for help!
15:34:08 <jle`> no problem!
15:34:31 <jle`> yeah, like i said, the no exception approach has some issues, but i suppose it should be left to the user to weigh in on the trade-offs
15:52:27 <lpaste_> qmm pasted “is this an acceptable style?” at http://lpaste.net/352194
15:53:25 <jle`> lol
15:53:46 <kadoban> Looks kind of whitespacey to me.
15:54:02 <jle`> usually people put the first field on the same line as the constructor, but
15:54:03 <qmm> kadoban: same
15:54:05 <jle`> i mean, who's going to judge
15:54:24 * Axman6 is going to judge
15:54:52 <Koterpillar> hindent is going to judge
15:54:57 <lpaste_> jle` annotated “is this an acceptable style?” with “is this an acceptable style? (annotation)” at http://lpaste.net/352194#a352195
15:55:11 <jle`> posted an example of how the official jle` style guide would recommend
15:55:18 <jle`> (the official jle` style guide is me)
15:55:26 <lpaste_> qmm pasted “is this better?” at http://lpaste.net/352196
15:55:28 <qmm> ah :)
15:55:31 <lpaste_> Axman6 annotated “is this an acceptable style?” with “is this an acceptable style? (annotation)” at http://lpaste.net/352194#a352197
15:55:51 <qmm> i didn't realize lpaste had annotations!
15:56:02 <qmm> i'll add the latest paste as an annotation
15:56:35 <lpaste_> qmm annotated “is this an acceptable style?” with “is this an acceptable style? (annotation)” at http://lpaste.net/352194#a352198
15:56:40 <lpaste_> Axman6 revised “is this an acceptable style? (annotation)”: “is this an acceptable style? (annotation)” at http://lpaste.net/352197
15:57:27 <lpaste_> qmm revised “is this an acceptable style? (annotation)”: “is this an acceptable style? (annotation)” at http://lpaste.net/352198
15:58:32 <jle`> i don't prefer that one becuase it's not extendable
15:58:41 <jle`> if you decide to add or subtract fields
15:58:42 <qmm> jle`: yeah
15:59:09 <jle`> the thing with both Axman6's and my formatting is that adding/removing fields is easy, with only adding/removing individual lines
15:59:36 <Axman6> yeah, the only difficult one is the first line
15:59:43 <Axman6> "difficult"
16:00:52 <lpaste_> Axman6 revised “is this an acceptable style? (annotation)”: “is this an acceptable style? (annotation)” at http://lpaste.net/352197
16:01:14 <Axman6> bleh, meant to turn that announcement off before submitting >_<
16:02:15 <qmm> Axman6: how do you do that? i don't want to spam the room with annotations either :)
16:02:19 <Axman6> I hate code that gets too wide, the style I use means you only indent once per record. preferably I'd use Lens for everything though
16:02:42 <Axman6> qmm: see my annotation on your original paste
16:02:55 <qmm> Axman6: i'm with you. i'm not a fan of weird spacing as in the original post :)
16:03:07 <jle`> i admit that i often get wasteful with horizontal space
16:03:12 <lpaste_> qmm revised “is this an acceptable style? (annotation)”: “is this an acceptable style? (annotation)” at http://lpaste.net/352198
16:03:23 <johnw> jle`: me                            too!!!
16:03:44 <lpaste_> qmm revised “is this an acceptable style? (annotation)”: “is this an acceptable style? (annotation)” at http://lpaste.net/352198
16:03:46 <Axman6> _Foo # (_Bar # (qux 1, Zoo Zebra 2)) >_>
16:04:06 <qmm> Axman6: how do you turn off announcements?
16:04:22 <Axman6> up the top it says which channel it'll be announced to
16:06:56 <qmm> i see, thank you
16:08:01 <qmm> while a few of you are nice enough to chime in on style, will i cause haskellers to grab pitchforks if i don't inlcude the space indicating "qualified" wasn't used? :)
16:08:17 <qmm> i see this often: import            Foo
16:08:40 <Axman6> some tools do that automatically, like stylish-haskell
16:11:12 <qmm> thanks!
16:11:30 <qmm> it would be nice to have the editor automatically do the indenting for me
16:12:47 <Koterpillar> I am almost there with hindent, spacemacs and comma-f
16:15:50 <dmwit> qmm: What editor?
16:16:05 <qmm> i'm all over the place 
16:16:20 <qmm> i've been slowly getting myself back into emacs
16:16:41 <dmwit> qmm: For vim, I use tabular, which would let you do e.g. `:Tab /^import\s+\ze[A-Z]` or similar.
16:16:41 <qmm> i really like spacemacs, but i ran into issues where intero wasn't working on it and it's a known issue on github
16:20:30 <nak> does the following function have a commonly known name: a -> (a -> b) -> b
16:20:43 <dmwit> :t flip id
16:20:44 <lambdabot> b -> (b -> c) -> c
16:20:49 <dmwit> :t (&)
16:20:50 <lambdabot> a -> (a -> b) -> b
16:20:51 <Axman6> :t (&)
16:20:53 <lambdabot> a -> (a -> b) -> b
16:21:07 <nak> does "&" have a name ?
16:21:14 <Rembane> flip $
16:21:25 <dmwit> Is `&` not a good enough name for `&`?
16:21:27 <Tuplanolla> Flipped function application, nak.
16:22:16 <nak> dmwit, it's not a good name like "apply", "map" or "fold" 
16:22:35 <nak> knowing names of things makes it easier to communicate about them
16:22:51 <Koterpillar> :t (>>>)
16:22:52 <lambdabot> forall k (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
16:23:00 <Koterpillar> no, not that.
16:23:10 <Tuplanolla> Yes, that.
16:23:11 <nak> ok so "flipped function application" Tuplanolla 
16:23:24 <Koterpillar> > 2 & negate
16:23:26 <lambdabot>  -2
16:23:26 <dmwit> No, not that.
16:23:30 <Koterpillar> > 2 >>> negate
16:23:32 <lambdabot>  error:
16:23:33 <lambdabot>      • No instance for (Typeable a0)
16:23:33 <lambdabot>          arising from a use of ‘show_M693013032023542532621022’
16:23:38 <dmwit> That is `flip (.)`, not `flip ($)`.
16:23:41 <Tuplanolla> Right, composition.
16:24:10 <Tuplanolla> It's a really nice type signature too.
16:24:30 <nak> Tuplanolla: (&) you mean ?
16:24:37 <nak> (re: nice type signature)
16:24:41 <Axman6> I would usually read it as just "and"
16:24:52 <Tuplanolla> I meant stuff from `Control.Category`, nak.
16:25:00 <nak> Tuplanolla: ok
16:25:30 <Axman6> it's often used with Lens: foo & bar.baz .~ 2 & lol.yum *~ 20 -> "foo and set foo.baz to 2 and multiply lol.yum by 10"
16:25:33 <Axman6> 20*
16:28:34 <nak> Axman6: thanks :)
16:29:01 <ertes> are there any clear figures about the memory and indirection costs of the various variable types that exist?  particularly IORef, MVar, TVar and MutVar#
16:29:28 <ertes> memory: "how many extra bytes does it use apart from the actual value it stores?"
16:29:49 <ertes> indirection: "how many pointers need to be chased until you get to the value?"
16:30:50 <dmwit> IORef has one extra pointer (and one extra indirection) compared to MutVar#.
16:31:20 <dmwit> data STRef s a = STRef (MutVar# s a); newtype IORef a = IORef (STRef RealWorld a)
16:32:31 <dmwit> I don't know how MVar and TVar compare, though. Apparently MVar#, TVar#, and MutVar# are all pretty primitive.
16:34:14 <ertes> is a MutVar# itself an indirection compared to the actual value thunk?
16:38:26 <dfeuer> glguy?
16:39:16 <Welkin> graphics library guy
16:39:31 <c_wraith> ertes, I think it has to be, since IORef supports reference equality 
16:39:41 <Welkin> EvanR_: no no cox?
16:40:37 <c_wraith> ertes, that is, (==) on IORef is "are these the same reference? " rather than "do these refer to the same thing?" 
16:42:05 <ertes> thanks dmwit and c_wraith…  looks like it's benchmark time =)
16:42:50 <dfeuer> Welkin: I wanted to know whether glguy (Eric Mertens) was actually here; what his nick stands for is somewhat less interesting.
16:43:24 <glguy> hi
16:44:59 <dfeuer> glguy: as far as I can tell (famous last words), your tries library doesn't try to do any path compression (including shortening long tails). Is that true?
16:45:59 <glguy> That's correct. The only "optimization" in that space that that library does is to avoid the generic representation having paths out to empty parts of the tree per data type
16:46:16 <dfeuer> Do you have a sense of what would be involved in adding such support?
16:47:35 <dfeuer> I would imagine compressing the tails would be non-impossible, while trying to compress internal runs would at least be very difficult, but that's just a guess.
16:47:58 <glguy> I don't really, at least not off the top of my head. The path is derived from the structure of the type.
16:48:39 <dfeuer> IIUC, the Generic `from` converts things one constructor at a time.
16:49:08 <dfeuer> So presumably you could avoid unrolling the path further than necessary?
16:49:15 <dfeuer> I don't quite grok all your code yet.
16:49:26 <dfeuer> (although I see the general outlines fairly well)
17:15:35 <Squarism> is there some way i can tell stack not to build all executables defined in my cabal file when i just want to run the testsuite ? 
17:16:29 <Welkin> cabal build test ?
17:18:32 <Squarism> id prefer stack because of my initial troubles with cabal non-install
17:18:40 <jchia> Recursion can often be converted into a fold. Some people say using fold is more efficient but sometimes recursion is more readable, at least to me. Any rules of thumb for deciding whether to convert a recursion into a fold?
17:19:42 <ThusSpakeHarambe> hey guys its 2040, is this channel still active?
17:19:56 <suzu> pretty sure ghc will do the same thing regardless of if it's a use of fold or a recursion that is a fold
17:20:01 <Welkin> 2040?
17:20:02 <suzu> barring rewrite rules
17:29:35 <jle`> ThusSpakeHarambe: will this channel be actuve in 23 years?
17:29:37 <jle`> probably
17:29:55 <Welkin> o.o
17:29:57 <jle`> haskell is 27 years old
17:30:10 <ThusSpakeHarambe> still the friendliest channel on freenode in 23 years too? or will u all be robots then
17:30:11 <Welkin> do you notice the nickname of the person who left that comment?
17:30:21 <jle`> i just Th<tab> :|
17:31:01 <jle`> jchia: i think you might have it backwards
17:31:07 <jle`> recursion typically makes things less readable
17:31:22 <jle`> using a higher order function usually makes things easier to read/understand
17:31:27 <Welkin> jle`: unless you are doing something that would be a big mess with a fold
17:31:55 <jle`> yes, there exist cases where explicit recursion would be the more readable option
17:32:05 <jle`> but one of the entire points of higher order functions is that they make most code more readable
17:32:27 <jle`> the cases were the fold is less readable is the exception, not the norm
17:32:40 <Welkin> @pl Nothing <$ a
17:32:41 <lambdabot> Nothing <$ a
17:32:42 <Welkin> lol
17:33:19 <dfeuer> ?
17:34:54 <kylo_> hi guys 
17:35:03 <Squarism> Is there something really wrong with this cabal file : http://lpaste.net/352210 - if i change my root modules it rebuild every executable even if i run : stack build jc:test:jc-testsuite
17:35:17 <Squarism> rebuilds
17:35:22 <kylo_> im new to programming , and what book would you recommend for learning haskell ? 
17:36:48 <Welkin> @where learnhaskell -- kylo_ 
17:36:48 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:38:36 <jchia> http://gerrit/#/c/979/
17:52:38 <Squarism> I understand its not so pure / FP - but is there any cache with automatic eviction that someone can recommend - im not curious on learning some exotic method of caching - just something easy that just works
17:54:38 <Welkin> Squarism: a list
17:55:08 <Welkin> or a lazy map
18:06:51 <dmwit> Welkin: "with automatic eviction"
18:06:55 <ClaudiusMaximus> Squarism: perhaps https://hackage.haskell.org/package/lrucaching (not used it myself though)
18:09:05 <Squarism> ClaudiusMaximus, Ill check it out
18:09:42 <halogenandtoast> Is there any way to simplify this `    return $ (pack . replaceDictionaryLinks . unpack . toStrict . render) <$> mArticle
18:10:03 <halogenandtoast> I don't like that I have the pack unpack toStrict stuff in there and I'm wondering if there's a better way.
18:11:51 <dmwit> You would have to rewrite `replaceDictionaryLinks` to work on lazy `ByteString`s instead of `[Word8]`s, I guess.
18:12:08 <dmwit> Not sure what you're asking, to be honest.
18:23:15 <halogenandtoast> dmwit: that's fair, I just wasn't sure if there was some way to encapsulate (probably the wrong word entirely) that I wanted to both unpack and repack a Text
18:23:47 <halogenandtoast> something like: return $ (repack replaceDictionaryLinks . toStrict .render) <$> mArticle
18:26:43 <halogenandtoast> unfortunately replaceDictionaryLinks just calls out to regexReplace from Hledger.Utils.Regex so it has to operate on String
18:36:00 <ClaudiusMaximus> halogenandtoast: you could define your own  repack f = pack . f . unpack
18:42:24 <jchia> jli: See what吴岳said in the wechat group at 20170123 15:55. Isn't that the code you said you need for MD login?
18:42:54 <jchia> sorry, wrong chat
18:43:11 <halogenandtoast> ClaudiusMaximus: yeah that's what I ended up doing
18:43:31 <halogenandtoast> allthough repack was poorly named because it confliched with ClassyPrelude
18:44:01 <halogenandtoast> So I ended up making `lazyTextFun f = pack . f . unpack . toStrict`
18:44:43 <halogenandtoast> I couldn't come up with a better name
18:53:19 <deech> Hi all, is it possible to load a shared library built with g++ into GHCi? It has a bunch of extern'ed symbols which I'm trying to use.
18:55:47 <geekosaur> you might need to tell it to include -lstdc++ (or -lc++ for clang / OS X or *BSD)
18:56:25 <yushyin> deech: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#extra-libraries
18:56:26 <geekosaur> otherwise your biggest problem is likely to be mangled symbols if you are trying to FFI, and of course anything needing a C++-specific type won't work via FFI
18:57:12 <deech> geekosaur: But all I'm only trying to access extern'd symbols in theory I should be good?
18:57:22 <qmm> i'm dealing with an m a and i really need that a
18:57:34 <geekosaur> are they extern "C"?
18:57:46 <geekosaur> qmm, "that a" may not exist
18:58:02 <deech> geekosaur: Yeah.
18:59:00 <yushyin> :t (>>=)
18:59:02 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:59:25 <yushyin> qmm: you provide the m a and the a -> m b and >>= will deal with the 'a' for you
18:59:36 <qmm> geekosaur: i was declaring that an m a was coming across, but actually i was getting an a
19:04:42 <pistachio_> HELP
19:05:16 <pistachio_> guys, can I ask a question?
19:05:21 <qmm> pistachio_: go for it
19:05:23 <suzu> yes
19:05:25 <suzu> of course
19:06:37 <pistachio_> I am new to Haskell and when I type "gchi" into the compiler, it says there is an error. Why does that happen?
19:06:58 <qmm> pistachio_: can you paste the error at lpaste.net?
19:07:35 <qmm> http://lpaste.net/new/haskell rather
19:07:53 <Koterpillar> pistachio_: it should be 'ghci', not 'gchi'
19:08:09 <geekosaur> and, "into the compiler"?
19:08:22 <Koterpillar> > ghci
19:08:22 <geekosaur> would be at the shell or CMD/PowerShell prompt
19:08:23 <pistachio_> haha, I know, that was a typo in the chat
19:08:25 <lambdabot>  error: Variable not in scope: ghci
19:08:33 <pistachio_> exactly
19:09:23 <pistachio_> :1:1: error: Variable not in scope: ghci
19:09:33 <pistachio_> that is what it spells
19:09:39 <pistachio_> :(
19:09:47 <geekosaur> why are you trying to run ghci from ghci?
19:09:50 <Koterpillar> pistachio_: you are already in ghci, likely. What did you want to do?
19:10:01 <Welkin> is that like running emacs inside emacs?
19:10:02 <suzu> you made it fam
19:10:05 <Welkin> because it can be done
19:10:07 <suzu> we up in ghci now
19:10:08 <Welkin> and I have done it :D
19:10:34 <nitrix> pistachio_: It might be that you're confusing GHCi for a terminal emulator.
19:10:50 <pistachio_> could be
19:11:09 <nitrix> pistachio_: The error message you gave seems like it'd be coming from GHCi so it hints that you'd be trying to run the function `ghci` with GHCi, which wont work.
19:11:21 <pistachio_> alright
19:11:26 <pistachio_> thank you
19:11:33 <pistachio_> however
19:11:39 <pistachio_> when I try to run a file
19:11:48 <nitrix> pistachio_: What happens if you do :help ?
19:11:58 <pistachio_> it gives me an error again
19:12:07 <pistachio_> when I try to load the file
19:12:29 <geekosaur> in ghci, it'd be:   :load MyFile.hs
19:12:32 <nitrix> pistachio_: http://lpaste.net could you paste the file and your error there?
19:12:36 <pistachio_> precisely
19:12:44 <pistachio_> that is how I did it
19:13:27 <pistachio_> just a moment,please
19:14:37 <pistachio_> MyFile is not a module name or a source file
19:15:02 <Jello_Raptor> huh, where do I find the functions for working with AssocLists ? 
19:15:03 <nitrix> Is your file named MyFile.hs ?
19:15:22 <nitrix> Is it also located where you launched GHCi from?
19:15:34 <pistachio_> yes, it has the .hs at the end
19:15:42 <nitrix> You might have to use :cd to change directory, or change the working directory prior to launching GHCi.
19:16:37 <nitrix> pistachio_: Would you happen to be a Windows user?
19:16:39 <pistachio_> the folder with the file is in the same place as where I launch haskell from
19:17:02 <pistachio_> yep
19:17:05 <pistachio_> windows
19:17:27 <nitrix> I believe the windows installer for Haskell Platform adds a link in the right click contextual menu to load a file automatically in GHCi.
19:17:47 <nitrix> "Run in GHCi" or something.
19:18:07 <nitrix> That could be a good starting point.
19:19:45 <pistachio_> I have a separate icon called winghci
19:19:58 <pistachio_> is that it?
19:20:17 <deech> geekosaur: I think I figured it out. The option to pass to GHCi is `-fobject-code`. Not exactly sure what it does.
19:20:42 <nitrix> pistachio_: If you're seeing winghci, you're most likely not in the good menu. 
19:21:14 <nitrix> pistachio_: The one I was talking about is by rick-clicking on the file, and chosing the 2nd or 3rd option down the list, if I remember, it should say "Run in GHCi"
19:22:00 <Koterpillar> http://stackoverflow.blog/2017/02/What-Programming-Languages-Weekends/ Haskell is on top
19:22:50 <nitrix> A second alternative is to launch GHCi and use :cd to change directory to where your project is located or launch cmd.exe, use cd to change directory, then execute ghci. Both approaches are equally as good.
19:23:14 <pistachio_> oh, I got it
19:23:17 <pistachio_> sorry
19:23:34 <pistachio_> opened it with right click
19:24:17 <nitrix> That's a good starting point. It's probably enough to write simple projects for now and test them :)
19:24:44 <pistachio_> yes!
19:24:49 <pistachio_> thank you so much!
19:25:06 <pistachio_> that is all I needed at the moment!
19:25:22 <nitrix> Ideally you'd get more comfortable with running commands on Windows if you're going to use GHCi (which is a command line application and text-based).
19:25:36 <pistachio_> alright
19:25:42 <nitrix> :]
19:25:49 <pistachio_> <3
19:26:05 <pistachio_> have good night guys!
19:26:11 <pistachio_> or good day!
19:35:50 <deech> Anyone know if there is way of specifying `ghc-options` in your .cabal file that are *not* used when running in GHCi? Is there something like an `if (repl)` conditional available?
19:51:54 <nitrix> I don't think so. The opposite seems easier to achieve. As a last resort, you could add :unset directives to your ~/.ghci file.
19:52:44 <nitrix> ~/.ghc/ghci.conf, sorry.
20:40:03 <bjrnt> exit
20:45:45 <ertes> are there strict versions of MutVar# that even avoid the indirection of a thunk?
20:55:48 <halogenandtoast> I think I'm in love with lenses, now if I can figure out how to use them.
21:20:37 <Lokathor> people keep saying stuff at me that i don't see because hexchat has limited scrollback
21:20:39 <Lokathor> oh well
21:22:41 <MarcelineVQ> there's a scrollback folder in hexchat's config that would keep more than what will show
21:23:24 <MarcelineVQ> in my experience it does poor book-keeping though so it's hard to rely on its logs in any case
23:08:04 <athan> edwardk: Do you happen to have your mmorph++ library hosted?
23:15:43 <athan> Is it possible to lens into a lens? Where you can partition the lens given you have an "identical" prefix or something?
23:16:08 <athan> given that you have some different kind of lens design (more data oriented) than Control.Lens I mean
23:23:31 <athan> Like given you have some lens from `a -> c` (like Lens' a c), and another lens `a -> b`, then you could use `over` with some new `b -> d`, and turn `a -> c` into `a -> d`, given that the `a -> b` lens is a bona-fide prefix of the `a -> c` one
23:23:44 <athan> idk this is probably impossible (quote unquote)
23:23:59 <athan> due to existentials and dynamic types or something
23:24:14 <athan> maybe actually... type-level lenses or something bananas?
23:32:25 <osa1> does this error message look familliar to anyone: "Error in $: endOfInput" this is from parsec
23:33:20 <halogenandtoast> osa1: If I had to guess I'd say that it was expecting more input and instead read an endOfInput character
23:33:58 <osa1> halogenandtoast: but it doesn't expect more input. full error message is three lines: unexpected end of input; expecting end of input; Error in $: endOfInput
23:34:06 <osa1> I have no idea what it's trying to say
23:35:14 <halogenandtoast> Do you have any code you can paste (with the example you are parsing)?
23:37:14 <halogenandtoast> also where is the `endOfInput` function coming from?
23:37:34 <osa1> I don't know; certainly not my function
23:37:56 <osa1> this is just `manyTill anyChar (try (string "...")) <* eof`
23:38:41 <osa1> stream is Text
23:51:49 <lyxia> osa1: this looks more like an aeson error than a parsec error.
23:51:56 <osa1> lyxia: indeed that's just what I figured
23:52:33 <osa1> I'm trying to parse an UTCTime string
23:55:07 <osa1> the problem was I used `either fail ...` so error messages looked like they were coming from parsec
